{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "073571ccac536bd90d46cf840a3f9ee2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0bf913dbd2c2452b5d55df108cfaa9eb", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/ext/JGraphModelAdapter.java", "commitBeforeChange": "56c09b98e6df528eeef0b8df9f8d932a1ba40192", "commitAfterChange": "75098fa5c7281c0f169434b46722c0b4e66b3a8c", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 28, "signatureBeforeChange": "         public void graphChanged( GraphModelEvent e )", "signatureAfterChange": "         public void graphChanged( GraphModelEvent e )", "diff": ["-            GraphModelChange change    = e.getChange(  );", "-            Set              jEdges    = new HashSet(  );", "-            Set              jVertices = new HashSet(  );", "+            GraphModelChange change = e.getChange(  );", "+            ", "+            Object[] removedCells = change.getRemoved(  );", "-            Object[]         arrayToProcess = change.getRemoved(  );", "-", "-            if( arrayToProcess != null ) {", "-                filterEdgesAndVertices( arrayToProcess, jEdges, jVertices );", "-", "-                for( Iterator i = jEdges.iterator(  ); i.hasNext(  ); ) {", "-                    org.jgraph.graph.Edge jEdge =", "-                        (org.jgraph.graph.Edge) i.next(  );", "-", "-                    if( !m_jEdgesBeingRemoved.remove( jEdge ) ) {", "-                        removeJGraphEdge( jEdge );", "-                    }", "-                }", "-", "-                for( Iterator i = jVertices.iterator(  ); i.hasNext(  ); ) {", "-                    GraphCell jVertex = (GraphCell) i.next(  );", "-", "-                    if( !m_jVerticesBeingRemoved.remove( jVertex ) ) {", "-                        removeJGraphVertex( jVertex );", "-                    }", "-                }", "-", "-                jEdges.clear(  );", "-                jVertices.clear(  );", "+            if( removedCells != null ) {", "+                handleRemovedEdges( filterEdges( removedCells ) );", "+                handleRemovedVertices( filterVertices( removedCells ) );", "-            arrayToProcess = change.getInserted(  );", "+            Object[] insertedCells = change.getInserted(  );", "-            if( arrayToProcess != null ) {", "-                filterEdgesAndVertices( arrayToProcess, jEdges, jVertices );", "+            if( insertedCells != null ) {", "+                handleInsertedVertices( filterVertices( insertedCells ) );", "+                handleInsertedEdges( filterEdges( insertedCells ) );", "+            }", "+            ", "+            // Now handle edges that became 'dangling' or became connected.  ", "+            Object[] changedCells = change.getChanged(  );", "+            ", "+            if( changedCells != null ) {", "+                handleChangedEdges( filterEdges( changedCells ) );", "+            }", "+        }", "-                for( Iterator i = jVertices.iterator(  ); i.hasNext(  ); ) {", "-                    GraphCell jVertex = (GraphCell) i.next(  );", "-                    if( !m_jVerticesBeingAdded.remove( jVertex ) ) {", "-                        addJGraphVertex( jVertex );", "-                    }", "-                }", "-                for( Iterator i = jEdges.iterator(  ); i.hasNext(  ); ) {", "-                    org.jgraph.graph.Edge jEdge =", "-                        (org.jgraph.graph.Edge) i.next(  );", "-", "-                    if( !m_jEdgesBeingAdded.remove( jEdge ) ) {", "-                        addJGraphEdge( jEdge );", "-                    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0ea89a232f00e4d12a6b257fa074b843", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-ext/src/main/java/org/jgrapht/ext/DOTImporter.java", "commitBeforeChange": "583bedb628992418bdbd952ca092e65831d3b133", "commitAfterChange": "43aa0f5e11b9b56a524f92631cd31dc060fa1ca7", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "    public void read(String input, AbstractBaseGraph<V, E> graph)          throws ImportException", "signatureAfterChange": "    public void read(String input, AbstractBaseGraph<V, E> graph)          throws ImportException", "diff": ["-      String[] lines = input.split(\"[;\\r\\n]\");", "-", "-      validateLines(lines, graph);", "-", "-      // cache of vertexes added to the graph.", "-      for(int lineIndex = 1; lineIndex < lines.length - 1; lineIndex ++ ) {", "-         String line = lines[lineIndex].trim();", "+      int state = HEADER;", "+      int lastState = HEADER;", "+      int position = 0;", "-         // trim off line comments.", "-         if (line.contains(\"//\")) {", "-            line = line.substring(0, line.indexOf(\"//\"));", "-         }", "+      StringBuilder sectionBuffer = new StringBuilder();", "-         // with \\r\\n or just ;\\n line ends we get blanks. Filter here.", "-         if(line.isEmpty()) {", "-            continue;", "-         }", "-", "-         if (line.startsWith(\"#\")) {", "-            // line comment so ignore", "-            // TODO: block comments", "-         } else if (!line.contains(\"[\") && line.contains(\"=\")) {", "-            throw new ImportException(", "-                  \"graph level properties are not currently supported.\"", "-            );", "-         } else if (isVertexLine(line)) {", "-            // probably a vertex", "-            Map<String, String> attributes = extractAttributes(line);", "-", "-            String id = line.trim();", "-            int bracketIndex = line.indexOf('[');", "-            if (bracketIndex > 0) {", "-               id = line.substring(0, line.indexOf('[')).trim();", "-            }", "-", "-            String label = attributes.get(\"label\");", "-            if (label == null) {", "-               label = id;", "-            }", "-", "-            V existing = vertexes.get(id);", "-            if (existing == null) {", "-               V vertex = vertexProvider.buildVertex(label, attributes);", "-               graph.addVertex(vertex);", "-               vertexes.put(id, vertex);", "-            } else {", "-               if (vertexUpdater != null) {", "-                  vertexUpdater.updateVertex(existing, attributes);", "-               } else {", "-                  throw new ImportException(", "-                        \"Update required for vertex \"", "-                        + label", "-                        + \" but no vertexUpdater provided\"", "-                  );", "+      while (state != DONE && position < input.length()) {", "+         int existingState = state;", "+         switch(state) {", "+            case HEADER:", "+               state = processHeader(input, position, sectionBuffer, graph);", "+               break;", "+            case NODE:", "+               state = processNode(input, position, sectionBuffer, graph, vertexes);", "+               break;", "+            case EDGE:", "+               state = processEdge(input, position, sectionBuffer, graph, vertexes);", "+               break;", "+            case LINE_COMMENT:", "+               state = processLineComment(input, position, sectionBuffer, lastState);", "+               if (state == lastState) {", "+                  // when we leave a line comment we need the new line to still appear in the old block", "+                  position = position - 1;", "-            }", "-         } else {", "-            Map<String, String> attributes = extractAttributes(line);", "-", "-            List<String> ids = extractEdgeIds(line);", "-", "-            // for each pair of ids in the list create an edge.", "-            for(int i = 0; i < ids.size() - 1; i++) {", "-               V v1 = getVertex(ids.get(i), vertexes, graph);", "-               V v2 = getVertex(ids.get(i+1), vertexes, graph);", "-", "-               E edge = edgeProvider.buildEdge(v1,", "-                                               v2,", "-                                               attributes.get(\"label\"),", "-                                               attributes);", "-               graph.addEdge(v1, v2, edge);", "-            }", "+               break;", "+            case BLOCK_COMMENT:", "+               state = processBlockComment(input, position, lastState);", "+               break;", "+            case NODE_QUOTES:", "+               state = processNodeQuotes(input, position, sectionBuffer);", "+               break;", "+            case EDGE_QUOTES:", "+               state = processEdgeQuotes(input, position, sectionBuffer);", "+               break;", "+            case NEXT:", "+               state = processNext(input, position, sectionBuffer, graph, vertexes);", "+               break;", "+            // DONE not included here as we can't get to it with the while loop.", "+            default:", "+               throw new ImportException(\"Error importing escaped state machine\");", "+         position = position + 1;", "+", "+         if (state != existingState) {", "+            lastState = existingState;", "+         }", "+", "+      }", "+", "+      // if we get to the end and are some how still in the header the input must be invalid.", "+      if(state == HEADER) {", "+         throw new ImportException(\"Invalid Header\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7e516ef6944c87ade116b502739afc55", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/StoerWagnerMinimumCut.java", "commitBeforeChange": "a8056d6aafd19ddde3f88a7357d27b280fbbac76", "commitAfterChange": "8786155732723df083d81ecffc66379e7847e52a", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     protected void minimumCutPhase(Set<V> a)", "signatureAfterChange": "     protected void minimumCutPhase(Set<V> a)", "diff": ["-        //construct sorted queue with vertices connected to vertex a", "+        // The last and before last vertices added to A.", "+        Set<V> last = a, beforelast = null;", "+        // queue contains vertices not in A ordered by max weight of edges to A.", "-            new PriorityQueue<VertexAndWeight>();", "+                new PriorityQueue<VertexAndWeight>();", "+        // Maps vertices to elements of queue", "-            new HashMap<Set<V>, VertexAndWeight>();", "+                new HashMap<Set<V>, VertexAndWeight>();", "+        ", "+        // Initialize queue", "-            if (v != a) {", "-                Double w =", "-                    -workingGraph.getEdgeWeight(workingGraph.getEdge(v, a));", "-                VertexAndWeight vandw = new VertexAndWeight(v, w);", "-                queue.add(vandw);", "-                dmap.put(v, vandw);", "-            }", "+            if (v == a)", "+                continue;", "+            DefaultWeightedEdge e = workingGraph.getEdge(v, a);", "+            Double w = e == null ? 0.0 : workingGraph.getEdgeWeight(e);", "+            VertexAndWeight vandw = new VertexAndWeight(v, w, e != null);", "+            queue.add(vandw);", "+            dmap.put(v, vandw);", "-        //now iteratatively update the queue to get the required vertex ordering", "-        List<Set<V>> list =", "-            new ArrayList<Set<V>>(workingGraph.vertexSet().size());", "-        list.add(a);", "+", "+        // Now iteratively update the queue to get the required vertex ordering", "+", "+            //System.out.println(\"Q:\"+ queue);", "-            list.add(v);", "+            //System.out.println(\"q:\"+ v);", "+", "+            beforelast = last;", "+            last = v;", "+", "-                Set<V> vc;", "-                if (v != workingGraph.getEdgeSource(e)) {", "-                    vc = workingGraph.getEdgeSource(e);", "-                } else {", "-                    vc = workingGraph.getEdgeTarget(e);", "-                }", "-                if (dmap.get(vc) != null) {", "-                    Double neww =", "-                        -workingGraph.getEdgeWeight(workingGraph.getEdge(v, vc))", "-                        + dmap.get(vc).weight;", "-                    queue.remove(dmap.get(vc)); //this is O(logn) but could be", "-                                                //O(1)?", "-                    dmap.get(vc).weight = neww;", "-                    queue.add(dmap.get(vc)); //this is O(logn) but could be", "-                                             //O(1)?", "+                Set<V> vc = Graphs.getOppositeVertex(workingGraph, e, v);", "+                VertexAndWeight vcandw = dmap.get(vc);", "+                if (vcandw != null) {", "+                    queue.remove(vcandw); //this is O(logn) but could be O(1)?", "+                    vcandw.active = true;", "+                    vcandw.weight += workingGraph.getEdgeWeight(e);", "+                    queue.add(vcandw); //this is O(logn) but could be O(1)?", "-        //if this is the first run we compute the weight of last vertex in the", "-        //list", "-        if (firstRun) {", "-            Set<V> v = list.get(list.size() - 1);", "-            double w = vertexWeight(v);", "-            if (w < bestcutweight) {", "-                bestcutweight = w;", "-                bestCut = v;", "-            }", "-            firstRun = false;", "+        // Update the best cut", "+        double w = vertexWeight(last);", "+        if (w < bestCutWeight) {", "+            bestCutWeight = w;", "+            bestCut = last;", "-        //the last two elements in list are the vertices we want to merge.", "-        Set<V> s = list.get(list.size() - 2);", "-        Set<V> t = list.get(list.size() - 1);", "+        //merge the last added vertices", "+        mergeVertices(beforelast, last);", "-        //merge these vertices and get the weight.", "-        VertexAndWeight vw = mergeVertices(s, t);", "-", "-        //If this is the best cut so far store it.", "-        if (vw.weight < bestcutweight) {", "-            bestcutweight = vw.weight;", "-            bestCut = vw.vertex;", "-        }", "+        //System.out.println(\"C:\"+ bestCut +\" \"+ bestCutWeight);"]}]}