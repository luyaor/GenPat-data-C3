{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "481a1e789b3210f0367d64b12d2dcf59", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5ee46c13506d82cbe66953940104dced", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/ext/JGraphModelAdapter.java", "commitBeforeChange": "56c09b98e6df528eeef0b8df9f8d932a1ba40192", "commitAfterChange": "75098fa5c7281c0f169434b46722c0b4e66b3a8c", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 23, "signatureBeforeChange": "     protected boolean removeJGraphVertex( GraphCell jVertex )", "signatureAfterChange": "     void handleJGraphRemovedVertex( GraphCell jVertex )", "diff": ["-    protected boolean removeJGraphVertex( GraphCell jVertex ) {", "-        if( !m_cellToVertex.containsKey( jVertex ) ) {", "-            return false;", "-        }", "-", "-        Object jtVertex      = m_cellToVertex.get( jVertex );", "-        List   incidentEdges = m_jtGraph.edgesOf( jtVertex );", "-", "-        if( incidentEdges != null ) {", "-            // We can't just call removeAllEdges with this list: that", "-            // would throw a ConcurrentModificationException. So we create", "-            // a shallow copy.", "-            Iterator iterator = incidentEdges.iterator(  );", "-            incidentEdges = new ArrayList( incidentEdges.size(  ) );", "-", "-            while( iterator.hasNext(  ) ) {", "-                incidentEdges.add( iterator.next(  ) );", "+    void handleJGraphRemovedVertex( GraphCell jVertex ) {", "+        if( m_cellToVertex.containsKey( jVertex ) ) {", "+            Object jtVertex      = m_cellToVertex.get( jVertex );", "+            List   jtIncidentEdges = m_jtGraph.edgesOf( jtVertex );", "+    ", "+            if( !jtIncidentEdges.isEmpty(  ) ) {", "+                // We can't just call removeAllEdges with this list: that", "+                // would throw a ConcurrentModificationException. So we create", "+                // a shallow copy.", "+                // This also triggers removal of the corresponding JGraph edges.", "+                m_jtGraph.removeAllEdges( new ArrayList( jtIncidentEdges ) );", "-", "-            m_jtGraph.removeAllEdges( incidentEdges );", "-", "-            // This also triggers removal of the corresponding JGraph", "-            // edges.", "+    ", "+            m_jtGraph.removeVertex( jtVertex );", "+    ", "+            m_cellToVertex.remove( jVertex );", "+            m_vertexToCell.remove( jtVertex );", "-", "-        m_jtVerticesBeingRemoved.add( jtVertex );", "-", "-        boolean result = m_jtGraph.removeVertex( jtVertex );", "-", "-        m_cellToVertex.remove( jVertex );", "-        m_vertexToCell.remove( jtVertex );", "-", "-        return result;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a781d86360cd1596574ac89783dcb21", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/NaiveLcaFinder.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     private V findLca(Set<V> aSet, Set<V> bSet, LinkedHashSet<V> aSeenSet, LinkedHashSet<V> bSeenSet)", "signatureAfterChange": "     private V findLca(         Set<V> aSet,         Set<V> bSet,         LinkedHashSet<V> aSeenSet,         LinkedHashSet<V> bSeenSet)", "diff": ["-    private V findLca(Set<V> aSet, Set<V> bSet, LinkedHashSet<V> aSeenSet, LinkedHashSet<V> bSeenSet) {", "+    private V findLca(", "+        Set<V> aSet,", "+        Set<V> bSet,", "+        LinkedHashSet<V> aSeenSet,", "+        LinkedHashSet<V> bSeenSet)", "+    {", "+        // if there is no LCA...", "+        if ((aSet.size() == 0) && (bSet.size() == 0)) {", "+            return null;", "+        }", "-\t// if there is no LCA...", "-\tif (aSet.size() == 0 && bSet.size() == 0)", "-\t    return null;", "-\t// does aSet intersect with bSeenSet", "-\tif (!Collections.disjoint(aSet, bSeenSet))", "-\t    return overlappingMember(aSet, bSeenSet);", "-\t// does bSet intersect with aSeenSet", "-\tif (!Collections.disjoint(bSet, aSeenSet))", "-\t    return overlappingMember(bSet, aSeenSet);", "-\tif (!Collections.disjoint(aSet, bSet))", "-\t    return overlappingMember(aSet, bSet);", "+        // does aSet intersect with bSeenSet", "+        if (!Collections.disjoint(aSet, bSeenSet)) {", "+            return overlappingMember(aSet, bSeenSet);", "+        }", "-\taSeenSet.addAll(aSet);", "-\tbSeenSet.addAll(bSet);", "+        // does bSet intersect with aSeenSet", "+        if (!Collections.disjoint(bSet, aSeenSet)) {", "+            return overlappingMember(bSet, aSeenSet);", "+        }", "+        if (!Collections.disjoint(aSet, bSet)) {", "+            return overlappingMember(aSet, bSet);", "+        }", "-\taSet = allParents(aSet);", "-\t// no point doing the same again (and it can stop us getting stuck in an infinite loop)", "-\taSet.removeAll(aSeenSet);", "+        aSeenSet.addAll(aSet);", "+        bSeenSet.addAll(bSet);", "-\tbSet = allParents(bSet);", "-\tbSet.removeAll(bSeenSet);", "+        aSet = allParents(aSet);", "-\treturn findLca(aSet, bSet, aSeenSet, bSeenSet);", "+        // no point doing the same again (and it can stop us getting stuck in", "+        // an infinite loop)", "+        aSet.removeAll(aSeenSet);", "+        bSet = allParents(bSet);", "+        bSet.removeAll(bSeenSet);", "+", "+        return findLca(aSet, bSet, aSeenSet, bSeenSet);"]}]}