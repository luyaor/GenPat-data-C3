{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "946375e2a6455d884ad81ed997a42ac1", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "05c14fd0844ceb4bab5147bc0fa3ed44", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r     public UndirectedGraph<V, E> getMinimalTriangulation()", "signatureAfterChange": "     public UndirectedGraph<V, E> getMinimalTriangulation()", "diff": ["-     */\r", "-    public UndirectedGraph<V, E> getMinimalTriangulation()\r", "-    {\r", "-        if (chordalGraph == null)\r", "-            computeMinimalTriangulation();\r", "-\r", "-        return chordalGraph;\r", "-    }\r", "+     */", "+    public UndirectedGraph<V, E> getMinimalTriangulation()", "+    {", "+        if (chordalGraph == null) {", "+            computeMinimalTriangulation();", "+        }", "+", "+        return chordalGraph;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09044d31b5b796400047c38dcaf0d7dc", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/flow/PushRelabelMaximumFlow.java", "commitBeforeChange": "ca153311ebb476220b5c58117cc53dc83fd78ea6", "commitAfterChange": "813f75565241c6a2b1109a8415fe2c264ac5efee", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "      private void relabel(VertexExtension vx)", "signatureAfterChange": "      private void relabel(VertexExtension vx)", "diff": ["-        if (min != Integer.MAX_VALUE)", "+        if (min != Integer.MAX_VALUE) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0a3fd45008906cc60ecaa5edca997604", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/util/FibonacciHeap.java", "commitBeforeChange": "8351950dcc8104326561fbac86d56dbf0db2a035", "commitAfterChange": "2e175b661db8815954cc8d1fa143c72587edb77b", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "     protected void consolidate()", "signatureAfterChange": "     protected void consolidate()", "diff": ["-        for (int i=0; i<arraySize; i++)", "+        for (int i = 0; i < arraySize; i++) {", "+        }", "-                array.set(d,null);", "+                array.set(d, null);", "-            array.set(d,x);", "+            array.set(d, x);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c836d8ff0e4b8b0b794f56cc7cefa80", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/StoerWagnerMinimumCut.java", "commitBeforeChange": "76399a5646342a12a99375b728ce65e0fef58fa7", "commitAfterChange": "836df798105be860e011cc4cc0ecf308ba811d44", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "     public double vertexWeight(Set<V> v)", "signatureAfterChange": "     public double vertexWeight(Set<V> v)", "diff": ["-    /** Compute the sum of the weights entering a vertex */", "-    public double vertexWeight(Set<V> v){", "+     */", "+    public double vertexWeight(Set<V> v)", "+    {", "-        for(DefaultWeightedEdge e : workingGraph.edgesOf(v) )", "+        for (DefaultWeightedEdge e : workingGraph.edgesOf(v)) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c9a0e77a6fa8ab8bf9c93ce5ff2f2af", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r     private void computeMinimalTriangulation()", "signatureAfterChange": "     private void computeMinimalTriangulation()", "diff": ["-     */\r", "-    private void computeMinimalTriangulation()\r", "-    {\r", "-        // initialize chordGraph with same vertices as graph\r", "-        chordalGraph = new SimpleGraph<V, E>(graph.getEdgeFactory());\r", "-        for (V v : graph.vertexSet())\r", "-            chordalGraph.addVertex(v);\r", "-\r", "-        // initialize g' as subgraph of graph (same vertices and edges)\r", "-        final UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);\r", "-        int s = -1;\r", "-        generators = new ArrayList<V>();\r", "-        meo = new LinkedList<V>();\r", "-\r", "-        final Map<V, Integer> vertexLabels = new HashMap<V, Integer>();\r", "-        for (V v : gprime.vertexSet()) {\r", "-            vertexLabels.put(v, 0);\r", "-        }\r", "-        for (int i = 1, n = graph.vertexSet().size(); i <= n; i++) {\r", "-            V v = getMaxLabelVertex(vertexLabels);\r", "-            LinkedList<V> Y = new LinkedList<V>(\r", "-                Graphs.neighborListOf(gprime, v));\r", "-\r", "-            if (vertexLabels.get(v) <= s)\r", "-                generators.add(v);\r", "-\r", "-            s = vertexLabels.get(v);\r", "-\r", "-            // Mark x reached and all other vertices of gprime unreached\r", "-            HashSet<V> reached = new HashSet<V>();\r", "-            reached.add(v);\r", "-\r", "-            // mark neighborhood of x reached and add to reach(label(y))\r", "-            HashMap<Integer, HashSet<V>> reach = \r", "-                new HashMap<Integer, HashSet<V>>();\r", "-\r", "-            // mark y reached and add y to reach\r", "-            for (V y : Y) {\r", "-                reached.add(y);\r", "-                addToReach(vertexLabels.get(y), y, reach);\r", "-            }\r", "-\r", "-            for (int j = 0; j < graph.vertexSet().size(); j++) {\r", "-                if (!reach.containsKey(j)) {\r", "-                    continue;\r", "-                }\r", "-                while (reach.get(j).size() > 0) {\r", "-                    // remove a vertex y from reach(j)\r", "-                    V y = reach.get(j).iterator().next();\r", "-                    reach.get(j).remove(y);\r", "-\r", "-                    for (V z : Graphs.neighborListOf(gprime, y)) {\r", "-                        if (!reached.contains(z)) {\r", "-                            reached.add(z);\r", "-                            if (vertexLabels.get(z) > j) {\r", "-                                Y.add(z);\r", "-                                E fillEdge = graph.getEdgeFactory().createEdge(\r", "-                                    v,\r", "-                                    z);\r", "-                                fillEdges.add(fillEdge);\r", "-                                addToReach(vertexLabels.get(z), z, reach);\r", "-                            } else {\r", "-                                addToReach(j, z, reach);\r", "-                            }\r", "-                        }\r", "-                    }\r", "-\r", "-                }\r", "-            }\r", "-\r", "-            for (V y : Y) {\r", "-                chordalGraph.addEdge(v, y);\r", "-                vertexLabels.put(y, vertexLabels.get(y) + 1);\r", "-            }\r", "-\r", "-            meo.addLast(v);\r", "-            gprime.removeVertex(v);\r", "-            vertexLabels.remove(v);\r", "-        }\r", "-    }\r", "+     */", "+    private void computeMinimalTriangulation()", "+    {", "+        // initialize chordGraph with same vertices as graph", "+        chordalGraph = new SimpleGraph<V, E>(graph.getEdgeFactory());", "+        for (V v : graph.vertexSet()) {", "+            chordalGraph.addVertex(v);", "+        }", "+", "+        // initialize g' as subgraph of graph (same vertices and edges)", "+        final UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);", "+        int s = -1;", "+        generators = new ArrayList<V>();", "+        meo = new LinkedList<V>();", "+", "+        final Map<V, Integer> vertexLabels = new HashMap<V, Integer>();", "+        for (V v : gprime.vertexSet()) {", "+            vertexLabels.put(v, 0);", "+        }", "+        for (int i = 1, n = graph.vertexSet().size(); i <= n; i++) {", "+            V v = getMaxLabelVertex(vertexLabels);", "+            LinkedList<V> Y =", "+                new LinkedList<V>(", "+                    Graphs.neighborListOf(gprime, v));", "+", "+            if (vertexLabels.get(v) <= s) {", "+                generators.add(v);", "+            }", "+", "+            s = vertexLabels.get(v);", "+", "+            // Mark x reached and all other vertices of gprime unreached", "+            HashSet<V> reached = new HashSet<V>();", "+            reached.add(v);", "+", "+            // mark neighborhood of x reached and add to reach(label(y))", "+            HashMap<Integer, HashSet<V>> reach =", "+                new HashMap<Integer, HashSet<V>>();", "+", "+            // mark y reached and add y to reach", "+            for (V y : Y) {", "+                reached.add(y);", "+                addToReach(vertexLabels.get(y), y, reach);", "+            }", "+", "+            for (int j = 0; j < graph.vertexSet().size(); j++) {", "+                if (!reach.containsKey(j)) {", "+                    continue;", "+                }", "+                while (reach.get(j).size() > 0) {", "+                    // remove a vertex y from reach(j)", "+                    V y = reach.get(j).iterator().next();", "+                    reach.get(j).remove(y);", "+", "+                    for (V z : Graphs.neighborListOf(gprime, y)) {", "+                        if (!reached.contains(z)) {", "+                            reached.add(z);", "+                            if (vertexLabels.get(z) > j) {", "+                                Y.add(z);", "+                                E fillEdge =", "+                                    graph.getEdgeFactory().createEdge(", "+                                        v,", "+                                        z);", "+                                fillEdges.add(fillEdge);", "+                                addToReach(vertexLabels.get(z), z, reach);", "+                            } else {", "+                                addToReach(j, z, reach);", "+                            }", "+                        }", "+                    }", "+                }", "+            }", "+", "+            for (V y : Y) {", "+                chordalGraph.addEdge(v, y);", "+                vertexLabels.put(y, vertexLabels.get(y) + 1);", "+            }", "+", "+            meo.addLast(v);", "+            gprime.removeVertex(v);", "+            vertexLabels.remove(v);", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "119ed9066a6b93f7aff9c079de398067", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r     private V getMaxLabelVertex(Map<V, Integer> vertexLabels)", "signatureAfterChange": "     private V getMaxLabelVertex(Map<V, Integer> vertexLabels)", "diff": ["-     */\r", "-    private V getMaxLabelVertex(Map<V, Integer> vertexLabels)\r", "-    {\r", "-        Iterator<Entry<V, Integer>> iterator = vertexLabels.entrySet()\r", "-            .iterator();\r", "-        Entry<V, Integer> max = iterator.next();\r", "-        while (iterator.hasNext()) {\r", "-            Entry<V, Integer> e = iterator.next();\r", "-            if (e.getValue() > max.getValue())\r", "-                max = e;\r", "-        }\r", "-        return max.getKey();\r", "-    }\r", "+     */", "+    private V getMaxLabelVertex(Map<V, Integer> vertexLabels)", "+    {", "+        Iterator<Entry<V, Integer>> iterator =", "+            vertexLabels.entrySet().iterator();", "+        Entry<V, Integer> max = iterator.next();", "+        while (iterator.hasNext()) {", "+            Entry<V, Integer> e = iterator.next();", "+            if (e.getValue() > max.getValue()) {", "+                max = e;", "+            }", "+        }", "+        return max.getKey();", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1daef27d4c07d71bc03eac084f80a307", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r     public List<V> getGenerators()", "signatureAfterChange": "     public List<V> getGenerators()", "diff": ["-     */\r", "-    public List<V> getGenerators()\r", "-    {\r", "-        if (generators == null)\r", "-            computeMinimalTriangulation();\r", "-\r", "-        return generators;\r", "-    }\r", "+     */", "+    public List<V> getGenerators()", "+    {", "+        if (generators == null) {", "+            computeMinimalTriangulation();", "+        }", "+", "+        return generators;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1eb32be9eb82d78be26b073d02872920", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r     public LinkedList<V> getMeo()", "signatureAfterChange": "     public LinkedList<V> getMeo()", "diff": ["-     */\r", "-    public LinkedList<V> getMeo()\r", "-    {\r", "-        if (meo == null)\r", "-            computeMinimalTriangulation();\r", "-\r", "-        return meo;\r", "-    }\r", "+     */", "+    public LinkedList<V> getMeo()", "+    {", "+        if (meo == null) {", "+            computeMinimalTriangulation();", "+        }", "+", "+        return meo;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "24bdb78b147ae035753c394389c018d1", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/KruskalMinimumSpanningTree.java", "commitBeforeChange": "b5348f8a80e818c9b0dd566a68eb23f3eca4389b", "commitAfterChange": "29039f1f20cd2b1397eba3afdb9fc72182dd2062", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public KruskalMinimumSpanningTree(final Graph<V,E> graph)", "signatureAfterChange": "     public KruskalMinimumSpanningTree(final Graph<V, E> graph)", "diff": ["-    public KruskalMinimumSpanningTree(final Graph<V,E> graph)", "+    public KruskalMinimumSpanningTree(final Graph<V, E> graph)", "-        Collections.sort(allEdges, new Comparator<E>(){", "-            @Override", "-            public int compare(E edge1, E edge2)", "-            {", "-                return Double.valueOf(graph.getEdgeWeight(edge1)).compareTo(graph.getEdgeWeight(edge2));", "-            }", "-        });", "-        ", "+        Collections.sort(", "+            allEdges,", "+            new Comparator<E>() {", "+                @Override public int compare(E edge1, E edge2)", "+                {", "+                    return Double.valueOf(graph.getEdgeWeight(edge1)).compareTo(", "+                        graph.getEdgeWeight(edge2));", "+                }", "+            });", "+", "-        ", "-        for(E edge:allEdges)", "-        {", "+", "+        for (E edge : allEdges) {", "-            if(forest.find(source).equals(forest.find(target)))", "+            if (forest.find(source).equals(forest.find(target))) {", "-            ", "-            forest.union(source,target);", "+            }", "+", "+            forest.union(source, target);", "-        }        ", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "324455aecdb52cb53d744beb96b0ea9f", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r     private void computeAtoms()", "signatureAfterChange": "     private void computeAtoms()", "diff": ["-     */\r", "-    private void computeAtoms()\r", "-    {\r", "-        if (chordalGraph == null)\r", "-            computeMinimalTriangulation();\r", "-\r", "-        separators = new HashSet<Set<V>>();\r", "-\r", "-        // initialize g' as subgraph of graph (same vertices and edges)\r", "-        UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);\r", "-\r", "-        // initialize h' as subgraph of chordalGraph (same vertices and edges)\r", "-        UndirectedGraph<V, E> hprime = copyAsSimpleGraph(chordalGraph);\r", "-\r", "-        atoms = new HashSet<Set<V>>();\r", "-\r", "-        Iterator<V> iterator = meo.descendingIterator();\r", "-        while (iterator.hasNext()) {\r", "-            V v = iterator.next();\r", "-            if (generators.contains(v)) {\r", "-                Set<V> separator = new HashSet<V>(Graphs.neighborListOf(\r", "-                    hprime,\r", "-                    v));\r", "-\r", "-                if (isClique(graph, separator)) {\r", "-                    if (separator.size() > 0) {\r", "-                        if (separators.contains(separator)) {\r", "-                            fullComponentCount.put(\r", "-                                separator,\r", "-                                fullComponentCount.get(separator) + 1);\r", "-                        } else {\r", "-                            fullComponentCount.put(separator, 2);\r", "-                            separators.add(separator);\r", "-                        }\r", "-                    }\r", "-                    UndirectedGraph<V, E> tmpGraph = copyAsSimpleGraph(gprime);\r", "-\r", "-                    tmpGraph.removeAllVertices(separator);\r", "-                    ConnectivityInspector<V, E> con = \r", "-                        new ConnectivityInspector<V, E>(tmpGraph);\r", "-                    if (con.isGraphConnected()) {\r", "-                        throw new RuntimeException(\r", "-                            \"separator did not separate the graph\");\r", "-                    }\r", "-                    for (Set<V> component : con.connectedSets()) {\r", "-                        if (component.contains(v)) {\r", "-                            gprime.removeAllVertices(component);\r", "-                            component.addAll(separator);\r", "-                            atoms.add(new HashSet<V>(component));\r", "-                            assert (component.size() > 0);\r", "-                            break;\r", "-                        }\r", "-                    }\r", "-                }\r", "-            }\r", "-\r", "-            hprime.removeVertex(v);\r", "-        }\r", "-\r", "-        if (gprime.vertexSet().size() > 0) {\r", "-            atoms.add(new HashSet<V>(gprime.vertexSet()));\r", "-        }\r", "-    }\r", "+     */", "+    private void computeAtoms()", "+    {", "+        if (chordalGraph == null) {", "+            computeMinimalTriangulation();", "+        }", "+", "+        separators = new HashSet<Set<V>>();", "+", "+        // initialize g' as subgraph of graph (same vertices and edges)", "+        UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);", "+", "+        // initialize h' as subgraph of chordalGraph (same vertices and edges)", "+        UndirectedGraph<V, E> hprime = copyAsSimpleGraph(chordalGraph);", "+", "+        atoms = new HashSet<Set<V>>();", "+", "+        Iterator<V> iterator = meo.descendingIterator();", "+        while (iterator.hasNext()) {", "+            V v = iterator.next();", "+            if (generators.contains(v)) {", "+                Set<V> separator =", "+                    new HashSet<V>(Graphs.neighborListOf(", "+                            hprime,", "+                            v));", "+", "+                if (isClique(graph, separator)) {", "+                    if (separator.size() > 0) {", "+                        if (separators.contains(separator)) {", "+                            fullComponentCount.put(", "+                                separator,", "+                                fullComponentCount.get(separator) + 1);", "+                        } else {", "+                            fullComponentCount.put(separator, 2);", "+                            separators.add(separator);", "+                        }", "+                    }", "+                    UndirectedGraph<V, E> tmpGraph = copyAsSimpleGraph(gprime);", "+", "+                    tmpGraph.removeAllVertices(separator);", "+                    ConnectivityInspector<V, E> con =", "+                        new ConnectivityInspector<V, E>(tmpGraph);", "+                    if (con.isGraphConnected()) {", "+                        throw new RuntimeException(", "+                            \"separator did not separate the graph\");", "+                    }", "+                    for (Set<V> component : con.connectedSets()) {", "+                        if (component.contains(v)) {", "+                            gprime.removeAllVertices(component);", "+                            component.addAll(separator);", "+                            atoms.add(new HashSet<V>(component));", "+                            assert (component.size() > 0);", "+                            break;", "+                        }", "+                    }", "+                }", "+            }", "+", "+            hprime.removeVertex(v);", "+        }", "+", "+        if (gprime.vertexSet().size() > 0) {", "+            atoms.add(new HashSet<V>(gprime.vertexSet()));", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39e5610b0cf23241d1f75deaa3507404", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/StoerWagnerMinimumCut.java", "commitBeforeChange": "76399a5646342a12a99375b728ce65e0fef58fa7", "commitAfterChange": "836df798105be860e011cc4cc0ecf308ba811d44", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public StoerWagnerMinimumCut(WeightedGraph<V, E> graph)", "signatureAfterChange": "     public StoerWagnerMinimumCut(WeightedGraph<V, E> graph)", "diff": ["-    public StoerWagnerMinimumCut(WeightedGraph<V, E> graph){", "+    public StoerWagnerMinimumCut(WeightedGraph<V, E> graph)", "+    {", "-        workingGraph = new SimpleWeightedGraph<Set<V>, DefaultWeightedEdge>(", "-            DefaultWeightedEdge.class);", "+        workingGraph =", "+            new SimpleWeightedGraph<Set<V>, DefaultWeightedEdge>(", "+                DefaultWeightedEdge.class);", "-        ", "+", "-        while(workingGraph.vertexSet().size() > 2) minimumCutPhase(a);", "-        ", "+        while (workingGraph.vertexSet().size() > 2) {", "+            minimumCutPhase(a);", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3b8b3c9c111308264321f7558d41cd74", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/EdmondsBlossomShrinking.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "      @Override     public Set<E> getMatching()", "signatureAfterChange": "      @Override public Set<E> getMatching()", "diff": ["-    @Override", "-    public Set<E> getMatching() {", "-        if (matching == null)", "+    @Override public Set<E> getMatching()", "+    {", "+        if (matching == null) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "40391396c679eda93e5830ec7b871c94", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/HamiltonianCycle.java", "commitBeforeChange": "ce0f78b94ba0a535e51aa5dfcfb3c56c6c67d881", "commitAfterChange": "40bf8c7c8736ae974ebda20b591cad2363132552", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static <V, E> List<V> getApproximateOptimal( \t\t\tSimpleWeightedGraph<V, E> g)", "signatureAfterChange": "     public static <V, E> List<V> getApproximateOptimal(         SimpleWeightedGraph<V, E> g)", "diff": ["+     */", "+    public static <V, E> List<V> getApproximateOptimal(", "+        SimpleWeightedGraph<V, E> g)", "+    {", "+        List<V> vertices = new LinkedList<V>(g.vertexSet());", "-\t */", "-\tpublic static <V, E> List<V> getApproximateOptimal(", "-\t\t\tSimpleWeightedGraph<V, E> g) {", "-\t\tList<V> vertices = new LinkedList<V>(g.vertexSet());", "+        // If the graph is not complete then return null since this algorithm", "+        // requires the graph be complete", "+        if ((vertices.size() * (vertices.size() - 1) / 2)", "+            != g.edgeSet().size())", "+        {", "+            return null;", "+        }", "-\t\t// If the graph is not complete then return null since this algorithm", "-\t\t// requires the graph be complete", "-\t\tif (vertices.size() * (vertices.size() - 1) / 2 != g.edgeSet().size())", "-\t\t\treturn null;", "+        List<V> tour = new LinkedList<V>();", "-\t\tList<V> tour = new LinkedList<V>();", "+        // Each iteration a new vertex will be added to the tour until all", "+        // vertices have been added", "+        while (tour.size() != g.vertexSet().size()) {", "+            boolean firstEdge = true;", "+            double minEdgeValue = 0;", "+            int minVertexFound = 0;", "+            int vertexConnectedTo = 0;", "-\t\t// Each iteration a new vertex will be added to the tour until all", "-\t\t// vertices have been added", "-\t\twhile (tour.size() != g.vertexSet().size()) {", "-\t\t\tboolean firstEdge = true;", "-\t\t\tdouble minEdgeValue = 0;", "-\t\t\tint minVertexFound = 0;", "-\t\t\tint vertexConnectedTo = 0;", "-", "-\t\t\t// A check will be made for the shortest edge to a vertex not within", "-\t\t\t// the tour and that new vertex will be added to the vertex", "-\t\t\tfor (int i = 0; i < tour.size(); i++) {", "-\t\t\t\tV v = tour.get(i);", "-\t\t\t\tfor (int j = 0; j < vertices.size(); j++) {", "-\t\t\t\t\tdouble weight = g.getEdgeWeight(g.getEdge(v, vertices", "-\t\t\t\t\t\t\t.get(j)));", "-\t\t\t\t\tif (firstEdge || weight < minEdgeValue) {", "-\t\t\t\t\t\tfirstEdge = false;", "-\t\t\t\t\t\tminEdgeValue = weight;", "-\t\t\t\t\t\tminVertexFound = j;", "-\t\t\t\t\t\tvertexConnectedTo = i;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\ttour.add(vertexConnectedTo, vertices.get(minVertexFound));", "-\t\t\tvertices.remove(minVertexFound);", "-\t\t}", "-\t\treturn tour;", "-\t}", "+            // A check will be made for the shortest edge to a vertex not within", "+            // the tour and that new vertex will be added to the vertex", "+            for (int i = 0; i < tour.size(); i++) {", "+                V v = tour.get(i);", "+                for (int j = 0; j < vertices.size(); j++) {", "+                    double weight =", "+                        g.getEdgeWeight(g.getEdge(v, vertices.get(j)));", "+                    if (firstEdge || (weight < minEdgeValue)) {", "+                        firstEdge = false;", "+                        minEdgeValue = weight;", "+                        minVertexFound = j;", "+                        vertexConnectedTo = i;", "+                    }", "+                }", "+            }", "+            tour.add(vertexConnectedTo, vertices.get(minVertexFound));", "+            vertices.remove(minVertexFound);", "+        }", "+        return tour;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4207c1060f1194303cd84298b6a7d0d6", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "b261cb99c92126b64c9129dbe772684f0da5e234", "commitAfterChange": "22927827f36ad9b2cef7c5f5670c4d2598840023", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "     public List<GraphPath<V, E>> getShortestPaths(V v)", "signatureAfterChange": "     public List<GraphPath<V, E>> getShortestPaths(V v)", "diff": ["-    public List<GraphPath<V, E>> getShortestPaths(V v) {", "-        if (v == null)", "+    public List<GraphPath<V, E>> getShortestPaths(V v)", "+    {", "+        if (v == null) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "429f152875b745ae34d6527e25ce6fa6", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/StoerWagnerMinimumCut.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     protected void minimumCutPhase(Set<V> a)", "signatureAfterChange": "     protected void minimumCutPhase(Set<V> a)", "diff": ["+", "-                new PriorityQueue<VertexAndWeight>();", "+            new PriorityQueue<VertexAndWeight>();", "+", "-                new HashMap<Set<V>, VertexAndWeight>();", "-        ", "+            new HashMap<Set<V>, VertexAndWeight>();", "+", "-            if (v == a)", "+            if (v == a) {", "+            }", "-            Double w = e == null ? 0.0 : workingGraph.getEdgeWeight(e);", "+            Double w = (e == null) ? 0.0 : workingGraph.getEdgeWeight(e);", "-"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "440427cfd826c2fc430d291056152bef", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/IsomorphicGraphMapping.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "     public boolean isEqualMapping(GraphMapping<V, E> rel)", "signatureAfterChange": "     public boolean isEqualMapping(GraphMapping<V, E> rel)", "diff": ["-    public boolean isEqualMapping(GraphMapping<V, E> rel) {", "+    public boolean isEqualMapping(GraphMapping<V, E> rel)", "+    {", "-                            rel.getVertexCorrespondence(v, false)))", "+                    rel.getVertexCorrespondence(v, false)))", "+            {", "+            }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "50182b383fb1cea05eed571cd5c931cd", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "f22d5340d3e5a85121314bf9c919e8bc029f4114", "commitAfterChange": "3c0ee1168b0aca54d591ff143b739fb03202fd37", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public FloydWarshallShortestPaths(Graph<V,E> g)", "signatureAfterChange": "     public FloydWarshallShortestPaths(Graph<V, E> g)", "diff": ["-    public FloydWarshallShortestPaths(Graph<V,E> g){", "+    public FloydWarshallShortestPaths(Graph<V, E> g)", "+    {", "-\t\t", "-        //Initialise distance to infinity, or the neighbours weight, or 0 if same", "-        for(V v1:g.vertexSet()){", "-            for(V v2:g.vertexSet()){", "-                if(v1 == v2) d[index(v1)][index(v2)]=0;", "-                else{", "-                    E e = g.getEdge(v1,v2);", "-\t\t\t\t\t", "-                    if(e == null){", "+", "+        //Initialise distance to infinity, or the neighbours weight, or 0 if", "+        //same", "+        for (V v1 : g.vertexSet()) {", "+            for (V v2 : g.vertexSet()) {", "+                if (v1 == v2) {", "+                    d[index(v1)][index(v2)] = 0;", "+                } else {", "+                    E e = g.getEdge(v1, v2);", "+", "+                    if (e == null) {", "-                    }else{", "+                    } else {", "-\t\t", "+", "-        for(int k=0; k<sz;k++){", "-            for(V v1:g.vertexSet()){", "-                for(V v2:g.vertexSet()){", "-                    d[index(v1)][index(v2)] = ", "+        for (int k = 0; k < sz; k++) {", "+            for (V v1 : g.vertexSet()) {", "+                for (V v2 : g.vertexSet()) {", "+                    d[index(v1)][index(v2)] =", "-                            d[index(v1)][index(v2)], ", "-                            d[index(v1)][k]+d[k][index(v2)]", "-                            );", "+                            d[index(v1)][index(v2)],", "+                            d[index(v1)][k] + d[k][index(v2)]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5b607e1f2bb8076c5336e7f9ab597870", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/EulerianCircuit.java", "commitBeforeChange": "ee432b2d260ae5197884a4bde7ebfd8fbc425567", "commitAfterChange": "fc11048fde6fa30641d7d466b45a9729e009006e", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)", "signatureAfterChange": "     public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)", "diff": ["-\t */", "-\tpublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {", "-\t\t", "-\t\t// If the graph is not connected, then no Eulerian circuit exists", "-\t\tif (!(new ConnectivityInspector<V, E>(g)).isGraphConnected())", "-\t\t\treturn false;", "-\t\t", "-\t\t// A graph is Eulerian if and only if all vertices have even degree", "-\t\t// So, this code will check for that", "-\t\tIterator<V> iter = g.vertexSet().iterator();", "-\t\twhile (iter.hasNext()) {", "-\t\t\tV v = iter.next();", "-\t\t\tif (g.degreeOf(v) % 2 == 1) {", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t}", "-\t\treturn true;", "-\t}", "+     */", "+    public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)", "+    {", "+        // If the graph is not connected, then no Eulerian circuit exists", "+        if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {", "+            return false;", "+        }", "+        // A graph is Eulerian if and only if all vertices have even degree", "+        // So, this code will check for that", "+        Iterator<V> iter = g.vertexSet().iterator();", "+        while (iter.hasNext()) {", "+            V v = iter.next();", "+            if ((g.degreeOf(v) % 2) == 1) {", "+                return false;", "+            }", "+        }", "+        return true;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6bf59258e300592b498789d284d4848e", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/experimental/alg/color/BrownBacktrackColoring.java", "commitBeforeChange": "e601cce570393b1ad5c879b58ec483ca42a9532b", "commitAfterChange": "df9e52ba034eea98b94d0b6e1470ce50769bc1ce", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "          void recursiveColor(int pos)", "signatureAfterChange": "      void recursiveColor(int pos)", "diff": ["-    ", "-    void recursiveColor(int pos) {", "-        _colorCount[pos] = _colorCount[pos-1];", "-        _allowedColors[pos].set(0, _colorCount[pos]+1);", "+", "+    void recursiveColor(int pos)", "+    {", "+        _colorCount[pos] = _colorCount[pos - 1];", "+        _allowedColors[pos].set(0, _colorCount[pos] + 1);", "-            if (_color[nb] > 0) _allowedColors[pos].clear(_color[nb]);", "+            if (_color[nb] > 0) {", "+                _allowedColors[pos].clear(_color[nb]);", "+            }", "-        for (int i = 1; i <= _colorCount[pos] && _colorCount[pos] < _chi; i++) {", "+        for (", "+            int i = 1;", "+            (i <= _colorCount[pos])", "+            && (_colorCount[pos] < _chi);", "+            i++)", "+        {", "-                if (pos < _neighbors.length - 1) {", "-                    recursiveColor(pos+1);", "+                if (pos < (_neighbors.length - 1)) {", "+                    recursiveColor(pos + 1);", "-        if (_colorCount[pos]+1 < _chi) {", "+        if ((_colorCount[pos] + 1) < _chi) {", "-            if (pos < _neighbors.length - 1) {", "-                recursiveColor(pos+1);", "+            if (pos < (_neighbors.length - 1)) {", "+                recursiveColor(pos + 1);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "772e3100292086eb5a15798962c645c5", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/VF2State.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "     protected void showLog(String method, String str)", "signatureAfterChange": "     protected void showLog(String method, String str)", "diff": ["-    protected void showLog(String method, String str)    {", "-        if (!DEBUG)", "+    protected void showLog(String method, String str)", "+    {", "+        if (!DEBUG) {", "+        }", "-        char[] indent = new char[2 * coreLen];", "+        char [] indent = new char[2 * coreLen];"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7bf7813f5b4356fc9d26ad819ab63779", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/experimental/GraphReader.java", "commitBeforeChange": "e601cce570393b1ad5c879b58ec483ca42a9532b", "commitAfterChange": "df9e52ba034eea98b94d0b6e1470ce50769bc1ce", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public void generateGraph(         Graph<V, E> target,         VertexFactory<V> vertexFactory,         Map<String, V> resultMap)", "signatureAfterChange": "     public void generateGraph(         Graph<V, E> target,         VertexFactory<V> vertexFactory,         Map<String, V> resultMap)", "diff": ["-        if (resultMap == null)", "+        if (resultMap == null) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7d0c3341cc9375ad972fc5a0aa7909db", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/VF2MappingIterator.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      protected IsomorphicGraphMapping<V,E> matchAndCheck()", "signatureAfterChange": "      protected IsomorphicGraphMapping<V, E> matchAndCheck()", "diff": ["-    protected IsomorphicGraphMapping<V,E> matchAndCheck() {", "-        IsomorphicGraphMapping<V,E> rel = match();", "-        if (rel != null)", "+    protected IsomorphicGraphMapping<V, E> matchAndCheck()", "+    {", "+        IsomorphicGraphMapping<V, E> rel = match();", "+        if (rel != null) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "84ce89d1ade8c9b69ebfa5bdf91959f4", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "b261cb99c92126b64c9129dbe772684f0da5e234", "commitAfterChange": "22927827f36ad9b2cef7c5f5670c4d2598840023", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "      private void shortestPathRecur(List<E> edges, int v_a, int v_b)", "signatureAfterChange": "      private void shortestPathRecur(List<E> edges, int v_a, int v_b)", "diff": ["-    private void shortestPathRecur(List<E> edges, int v_a, int v_b) {", "+    private void shortestPathRecur(List<E> edges, int v_a, int v_b)", "+    {", "-            if (edge != null)", "+            if (edge != null) {", "-        }", "-        else {", "+            }", "+        } else {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "84e59fa98a12101a2a03550956b18553", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/experimental/alg/color/GreedyColoring.java", "commitBeforeChange": "e601cce570393b1ad5c879b58ec483ca42a9532b", "commitAfterChange": "df9e52ba034eea98b94d0b6e1470ce50769bc1ce", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "      @SuppressWarnings(\"unchecked\")     int[] smallestDegreeLastOrder()", "signatureAfterChange": "      @SuppressWarnings(\"unchecked\")     int [] smallestDegreeLastOrder()", "diff": ["-    int[] smallestDegreeLastOrder() {", "-        final int[] order = new int[_neighbors.length];", "-        final int[] degree = new int[_neighbors.length];", "-        final List[] buckets = new List[_neighbors.length];", "-        int index = _neighbors.length-1;", "+    int [] smallestDegreeLastOrder()", "+    {", "+        final int [] order = new int[_neighbors.length];", "+        final int [] degree = new int[_neighbors.length];", "+        final List [] buckets = new List[_neighbors.length];", "+        int index = _neighbors.length - 1;", "-                final int vertex = (Integer)buckets[i].get(s);", "+                final int vertex = (Integer) buckets[i].get(s);", "-                        if (degree[nb] < i) i = degree[nb];", "+                        if (degree[nb] < i) {", "+                            i = degree[nb];", "+                        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "88df1842f4148602cf4c6ff88fb764cb", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/alg/DijkstraAlgorithm.java", "commitBeforeChange": "ede00ba6ca48a7a81231a62519a30fabb26ae338", "commitAfterChange": "f63e1142cae73862c9c4f7b6ce46225b40f3ef86", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public final WeightedGraph optimumPathTree(Object from)", "signatureAfterChange": "     public final WeightedGraph optimumPathTree( Object from )", "diff": ["-    */", "-    public final WeightedGraph optimumPathTree(Object from) {", "+     */", "+    public final WeightedGraph optimumPathTree( Object from ) {", "-        if (_directed) {", "-            optimumPathTree = new SimpleDirectedWeightedGraph();", "-        } else {", "-            optimumPathTree = new SimpleWeightedGraph();", "+", "+        if( _directed ) {", "+            optimumPathTree = new SimpleDirectedWeightedGraph(  );", "-        _heap.clear();", "-        _heapVertices.clear();", "-        for (Iterator it = _wgraph.vertexSet().iterator(); it.hasNext();) {", "-            Object vertex = it.next();", "-            HeapVertex heapV;", "-            if (vertex instanceof HeapVertex) {", "-                heapV = (HeapVertex)vertex;", "-            } else {", "-                heapV = new HeapVertex(vertex);", "-                _heapVertices.put(vertex, heapV);", "-            }", "-            if (vertex == from) {", "-                heapV.setPriority(_compare > 0 ? 0 : Double.POSITIVE_INFINITY);", "-            } else {", "-                heapV.setPriority(_compare * Double.POSITIVE_INFINITY);", "-            }", "-            _heap.add(heapV);", "+        else {", "+            optimumPathTree = new SimpleWeightedGraph(  );", "-        while (!_heap.isEmpty()) {", "-            HeapVertex hv = heapVertex(_heap.extractTop());", "-            Object v = hv.getVertex();", "-            Edge treeEdge = (Edge)hv.getAdditional();", "-            if (treeEdge != null) GraphHelper.addEdgeWithVertices(optimumPathTree, treeEdge);", "-            Iterator edges;", "-            if (_directed) {", "-                edges = ((DirectedGraph)_wgraph).outgoingEdgesOf(v).iterator();", "-            } else {", "-                edges = _wgraph.edgesOf(v).iterator();", "+        _heap.clear(  );", "+        _heapVertices.clear(  );", "+", "+        for( Iterator it = _wgraph.vertexSet(  ).iterator(  ); it.hasNext(  ); ) {", "+            Object     vertex = it.next(  );", "+            HeapVertex heapV;", "+", "+            if( vertex instanceof HeapVertex ) {", "+                heapV = (HeapVertex) vertex;", "-            while (edges.hasNext()) {", "-                Edge e = (Edge)edges.next();", "-                HeapVertex u = heapVertex(e.oppositeVertex(v));", "-                double newPrio = priorityFunction(hv.getPriority(), e.getWeight());", "-                if (_compare * (u.getPriority() - newPrio) > 0) {", "-                    u.setPriority(newPrio);", "-                    u.setAdditional(e);", "-                    _heap.update(u);", "+            else {", "+                heapV = new HeapVertex( vertex );", "+                _heapVertices.put( vertex, heapV );", "+            }", "+", "+            if( vertex == from ) {", "+                heapV.setPriority( _compare > 0 ? 0 : Double.POSITIVE_INFINITY );", "+            }", "+            else {", "+                heapV.setPriority( _compare * Double.POSITIVE_INFINITY );", "+            }", "+", "+            _heap.add( heapV );", "+        }", "+", "+        while( !_heap.isEmpty(  ) ) {", "+            HeapVertex hv       = heapVertex( _heap.extractTop(  ) );", "+            Object     v        = hv.getVertex(  );", "+            Edge       treeEdge = (Edge) hv.getAdditional(  );", "+", "+            if( treeEdge != null ) {", "+                GraphHelper.addEdgeWithVertices( optimumPathTree, treeEdge );", "+            }", "+", "+            Iterator edges;", "+", "+            if( _directed ) {", "+                edges =", "+                    ( (DirectedGraph) _wgraph ).outgoingEdgesOf( v ).iterator(  );", "+            }", "+            else {", "+                edges = _wgraph.edgesOf( v ).iterator(  );", "+            }", "+", "+            while( edges.hasNext(  ) ) {", "+                Edge       e       = (Edge) edges.next(  );", "+                HeapVertex u       = heapVertex( e.oppositeVertex( v ) );", "+                double     newPrio =", "+                    priorityFunction( hv.getPriority(  ), e.getWeight(  ) );", "+", "+                if( _compare * ( u.getPriority(  ) - newPrio ) > 0 ) {", "+                    u.setPriority( newPrio );", "+                    u.setAdditional( e );", "+                    _heap.update( u );", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8d1304d747c9a3d12fd376e0398c15ca", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "testsrc/org/jgrapht/alg/util/UnionFindTest.java", "commitBeforeChange": "b5348f8a80e818c9b0dd566a68eb23f3eca4389b", "commitAfterChange": "29039f1f20cd2b1397eba3afdb9fc72182dd2062", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     private boolean same(ArrayList<ArrayList<String>> sets, String a, String b)", "signatureAfterChange": "      private boolean same(ArrayList<ArrayList<String>> sets, String a, String b)", "diff": ["-    }", "-    private boolean same(ArrayList<ArrayList<String>> sets, String a, String b)", "-    {", "-        for(ArrayList<String> set:sets)", "-            if(set.contains(a) && set.contains(b))", "-                return true;", "-        return false;", "-    }", "+    private boolean same(ArrayList<ArrayList<String>> sets, String a, String b)", "+    {", "+        for (ArrayList<String> set : sets) {", "+            if (set.contains(a) && set.contains(b)) {", "+                return true;", "+            }", "+        }", "+        return false;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9065579007b84370012625c6b9644664", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/NaiveLcaFinder.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private Set<V> allParents(Set<V> vertexSet)", "signatureAfterChange": "     private Set<V> allParents(Set<V> vertexSet)", "diff": ["-    private Set<V> allParents(Set<V> vertexSet) {", "-\tHashSet<V> result = new HashSet<V>();", "-\tfor (V e : vertexSet) {", "-\t    for (E edge : graph.incomingEdgesOf(e)) {", "-\t\tif (graph.getEdgeTarget(edge).equals(e))", "-\t\t    result.add(graph.getEdgeSource(edge));", "-\t    }", "-\t}", "-\treturn result;", "+    private Set<V> allParents(Set<V> vertexSet)", "+    {", "+        HashSet<V> result = new HashSet<V>();", "+        for (V e : vertexSet) {", "+            for (E edge : graph.incomingEdgesOf(e)) {", "+                if (graph.getEdgeTarget(edge).equals(e)) {", "+                    result.add(graph.getEdgeSource(edge));", "+                }", "+            }", "+        }", "+        return result;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90c4bf49027c6c9fbc829c4982ed6a63", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/heap/BinaryHeap.java", "commitBeforeChange": "ede00ba6ca48a7a81231a62519a30fabb26ae338", "commitAfterChange": "f63e1142cae73862c9c4f7b6ce46225b40f3ef86", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 8, "signatureBeforeChange": "      private void percolateDown(int pos)", "signatureAfterChange": "       private void percolateDown( int pos )", "diff": ["-    private void percolateDown(int pos) {", "-        Elem h = (Elem)_elems.get(pos);", "-        while (2 * pos + 1 < size()) {", "-            int i = 1;", "-            Elem c = (Elem)_elems.get(2 * pos + i);", "-            if (2 * pos + 2 < size() &&", "-                isSmaller(((Elem)_elems.get(2 * pos + 2)).x, c.x)) {", "-                i++;", "-                c = (Elem)_elems.get(2 * pos + i);", "-            }", "-            if (isSmaller(h.x, c.x)) break;", "-            _elems.set(pos, c);", "-            c.pos = pos;", "-            pos = 2 * pos + i;", "-        }", "-        _elems.set(pos, h);", "-        h.pos = pos;", "-    }", "+", "+    private void percolateDown( int pos ) {", "+        Elem h = (Elem) _elems.get( pos );", "+", "+        while( 2 * pos + 1 < size(  ) ) {", "+            int  i = 1;", "+            Elem c = (Elem) _elems.get( 2 * pos + i );", "+", "+            if( 2 * pos + 2 < size(  )", "+                    && isSmaller( ( (Elem) _elems.get( 2 * pos + 2 ) ).x, c.x ) ) {", "+                i++;", "+                c = (Elem) _elems.get( 2 * pos + i );", "+            }", "+", "+            if( isSmaller( h.x, c.x ) ) {", "+                break;", "+            }", "+", "+            _elems.set( pos, c );", "+            c.pos     = pos;", "+            pos       = 2 * pos + i;", "+        }", "+", "+        _elems.set( pos, h );", "+        h.pos = pos;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "910c0a7dec82ae3e52e7d37738d953b7", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/HopcroftKarpBipartiteMatching.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \t \tprivate LinkedList<V> dfs(V startVertex, Map<V,Set<V>> layeredMap)", "signatureAfterChange": "      private LinkedList<V> dfs(V startVertex, Map<V, Set<V>> layeredMap)", "diff": ["+", "+    private LinkedList<V> dfs(V startVertex, Map<V, Set<V>> layeredMap)", "+    {", "+        if (!layeredMap.containsKey(startVertex)) {", "+            return null;", "+        } else if (unmatchedVertices1.contains(startVertex)) {", "+            LinkedList<V> list = new LinkedList<V>();", "+            list.add(startVertex);", "+            return list;", "+        } else {", "+            LinkedList<V> partialPath = null;", "+            for (V vertex : layeredMap.get(startVertex)) {", "+                partialPath = dfs(vertex, layeredMap);", "+                if (partialPath != null) {", "+                    partialPath.add(startVertex);", "+                    break;", "+                }", "+            }", "+            return partialPath;", "+        }", "+    }", "-\t", "-\tprivate LinkedList<V> dfs(V startVertex, Map<V,Set<V>> layeredMap){", "-\t\tif(!layeredMap.containsKey(startVertex))", "-\t\t\treturn null;", "-\t\telse", "-        if(unmatchedVertices1.contains(startVertex)){", "-\t\t\tLinkedList<V> list=new LinkedList<V>();", "-\t\t\tlist.add(startVertex);", "-\t\t\treturn list;", "-\t\t}else{", "-\t\t\tLinkedList<V> partialPath=null;", "-\t\t\tfor(V vertex: layeredMap.get(startVertex)){", "-\t\t\t\tpartialPath=dfs(vertex,layeredMap);", "-\t\t\t\tif(partialPath!=null){", "-\t\t\t\t\tpartialPath.add(startVertex);", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn partialPath;", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "999c079fa188787ea2421f7eaefc39f5", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "\r     public Set<Set<V>> getAtoms()", "signatureAfterChange": "     public Set<Set<V>> getAtoms()", "diff": ["-     */\r", "-    public Set<Set<V>> getAtoms()\r", "-    {\r", "-        if (atoms == null)\r", "-            computeAtoms();\r", "-\r", "-        return atoms;\r", "-    }\r", "+     */", "+    public Set<Set<V>> getAtoms()", "+    {", "+        if (atoms == null) {", "+            computeAtoms();", "+        }", "+", "+        return atoms;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa39c3904973bf8381dcd91980e8cae7", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/GraphOrdering.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public GraphOrdering(Graph<V, E> graph,                          boolean orderByDegree,                          boolean cacheEdges)", "signatureAfterChange": "     public GraphOrdering(         Graph<V, E> graph,         boolean orderByDegree,         boolean cacheEdges)", "diff": ["-    public GraphOrdering(Graph<V, E> graph,", "-                         boolean orderByDegree,", "-                         boolean cacheEdges) {", "-        this.graph      = graph;", "+    public GraphOrdering(", "+        Graph<V, E> graph,", "+        boolean orderByDegree,", "+        boolean cacheEdges)", "+    {", "+        this.graph = graph;", "-        if (orderByDegree)", "-            java.util.Collections.sort(vertexSet,", "-                            new GeneralVertexDegreeComparator<V>(graph));", "+        if (orderByDegree) {", "+            java.util.Collections.sort(", "+                vertexSet,", "+                new GeneralVertexDegreeComparator<V>(graph));", "+        }", "-        vertexCount      = vertexSet.size();", "+        vertexCount = vertexSet.size();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac200ba4cfe0ae2b0c7403351332114e", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/cycle/HawickJamesSimpleCycles.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r \r \tprivate void unblock(Integer u)", "signatureAfterChange": "      private void unblock(Integer u)", "diff": ["-\r", "-\tprivate void unblock(Integer u) {\r", "-\t\tblocked[u] = false;\r", "-\r", "-\t\tfor (int wPos = 0; wPos < B[u].size(); wPos++) {\r", "-\t\t\tInteger w = B[u].get(wPos);\r", "-\r", "-\t\t\twPos -= removeFromList(B[u], w);\r", "-\r", "-\t\t\tif (blocked[w])\r", "-\t\t\t\tunblock(w);\r", "-\t\t}\r", "-\t}\r", "+", "+    private void unblock(Integer u)", "+    {", "+        blocked[u] = false;", "+", "+        for (int wPos = 0; wPos < B[u].size(); wPos++) {", "+            Integer w = B[u].get(wPos);", "+", "+            wPos -= removeFromList(B[u], w);", "+", "+            if (blocked[w]) {", "+                unblock(w);", "+            }", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b47b5c479b4c2f33ced52aeaa5c8e55e", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/heap/HeapVertex.java", "commitBeforeChange": "320f41319eefcc411b999151096f11d4608d80c3", "commitAfterChange": "94cd40aee7737a3929e0568a1e5623a7da828391", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "      public String toString()", "signatureAfterChange": "     public String toString(  )", "diff": ["-    public String toString() {", "-        if (_vertex != this) return _vertex.toString()+\" (\"+_priority+\")\";", "-        return super.toString()+\" (\"+_priority+\")\";", "+     */", "+    public String toString(  ) {", "+        if( _vertex != this ) {", "+            return _vertex.toString(  ) + \" (\" + _priority + \")\";", "+        }", "+", "+        return super.toString(  ) + \" (\" + _priority + \")\";"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b932834caecce593b4d5e8ec297e76d0", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/IsomorphicGraphMapping.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "      @Override     public String toString()", "signatureAfterChange": "      @Override public String toString()", "diff": ["-    @Override", "-    public String toString() {", "+    @Override public String toString()", "+    {", "-        for (V v : vertexSet)", "+        for (V v : vertexSet) {", "+        }", "-        for (Map.Entry<String, V> entry : vertexMap.entrySet())   {", "+        for (Map.Entry<String, V> entry : vertexMap.entrySet()) {", "-            str += (i++ == 0 ? \"\" : \" \") + entry.getKey() + \"=\" +", "-                            (u == null ? \"~~\" : u);", "+            str +=", "+                ((i++ == 0) ? \"\" : \" \") + entry.getKey() + \"=\"", "+                + ((u == null) ? \"~~\" : u);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bda7bef473b7fdbcbd3ce4e20d6971d1", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r     public Set<E> getFillEdges()", "signatureAfterChange": "     public Set<E> getFillEdges()", "diff": ["-     */\r", "-    public Set<E> getFillEdges()\r", "-    {\r", "-        if (fillEdges == null)\r", "-            computeMinimalTriangulation();\r", "-\r", "-        return fillEdges;\r", "-    }\r", "+     */", "+    public Set<E> getFillEdges()", "+    {", "+        if (fillEdges == null) {", "+            computeMinimalTriangulation();", "+        }", "+", "+        return fillEdges;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c115dede93e37b15ab0d8149ae26a800", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/VF2MappingIterator.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "      @Override     public IsomorphicGraphMapping<V,E> next()", "signatureAfterChange": "      @Override public IsomorphicGraphMapping<V, E> next()", "diff": ["-    @Override", "-    public IsomorphicGraphMapping<V,E> next() {", "+    @Override public IsomorphicGraphMapping<V, E> next()", "+    {", "-            IsomorphicGraphMapping<V,E> tmp = nextMapping;", "+            IsomorphicGraphMapping<V, E> tmp = nextMapping;", "-        if (rel == null)", "+        if (rel == null) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c6b3f961c36b682c476abadec89377b5", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r     private static <V, E> boolean isClique(\r         UndirectedGraph<V, E> graph,\r         Set<V> vertices)", "signatureAfterChange": "     private static <V, E> boolean isClique(         UndirectedGraph<V, E> graph,         Set<V> vertices)", "diff": ["-     */\r", "-    private static <V, E> boolean isClique(\r", "-        UndirectedGraph<V, E> graph,\r", "-        Set<V> vertices)\r", "-    {\r", "-        for (V v1 : vertices) {\r", "-            for (V v2 : vertices) {\r", "-                if (v1 != v2 && graph.getEdge(v1, v2) == null)\r", "-                    return false;\r", "-            }\r", "-        }\r", "-        return true;\r", "-    }\r", "+     */", "+    private static <V, E> boolean isClique(", "+        UndirectedGraph<V, E> graph,", "+        Set<V> vertices)", "+    {", "+        for (V v1 : vertices) {", "+            for (V v2 : vertices) {", "+                if ((v1 != v2) && (graph.getEdge(v1, v2) == null)) {", "+                    return false;", "+                }", "+            }", "+        }", "+        return true;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc99de281e37a6624ec43aecc708eef2", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/IsomorphicGraphMapping.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      @Override     public E getEdgeCorrespondence(E e, boolean forward)", "signatureAfterChange": "      @Override public E getEdgeCorrespondence(E e, boolean forward)", "diff": ["-    @Override", "-    public E getEdgeCorrespondence(E e, boolean forward) {", "+    @Override public E getEdgeCorrespondence(E e, boolean forward)", "+    {", "-        int[] core;", "+        int [] core;", "-            firstGraph  = g1;", "+            firstGraph = g1;", "-            core        = core1;", "+            core = core1;", "-            firstGraph  = g2;", "+            firstGraph = g2;", "-            core        = core2;", "+            core = core2;", "-        int[] eNumbers = firstGraph.getEdgeNumbers(e);", "-        if (core[eNumbers[0]] == VF2State.NULL_NODE ||", "-                        core[eNumbers[1]] == VF2State.NULL_NODE)", "+        int [] eNumbers = firstGraph.getEdgeNumbers(e);", "+        if ((core[eNumbers[0]] == VF2State.NULL_NODE)", "+            || (core[eNumbers[1]] == VF2State.NULL_NODE))", "+        {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d719f79b55c2c8faf5d0165799fd6aab", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/cycle/HawickJamesSimpleCycles.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \r \t@SuppressWarnings(\"unchecked\")\r \tprivate void initState(Operation o)", "signatureAfterChange": "            @SuppressWarnings(\"unchecked\")     private void initState(Operation o)", "diff": ["-\r", "-\t@SuppressWarnings(\"unchecked\")\r", "-\tprivate void initState(Operation o) {\r", "-\t\tnCycles = 0;\r", "-\t\tnVertices = graph.vertexSet().size();\r", "-\t\tif (o == Operation.ENUMERATE)\r", "-\t\t\tcycles = new ArrayList<List<V>>();\r", "-\t\tblocked = new boolean[nVertices];\r", "-\t\tstack = new ArrayDeque<Integer>(nVertices);\r", "-\r", "-\t\tB = new ArrayList[nVertices];\r", "-\t\tfor (int i = 0; i < nVertices; i++) {\r", "-\t\t\t//B[i] = new ArrayList<Integer>(nVertices);\r", "-\t\t\tB[i] = new ArrayList<Integer>();\r", "-\t\t}\r", "-\r", "-\t\tiToV = (V[]) graph.vertexSet().toArray();\r", "-\t\tvToI = new HashMap<V, Integer>();\r", "-\t\tfor (int i = 0; i < iToV.length; i++) {\r", "-\t\t\tvToI.put(iToV[i], i);\r", "-\t\t}\r", "-\r", "-\t\tAk = buildAdjacencyList();\r", "-\r", "-\t\tstack.clear();\r", "-\t}\r", "+", "+    @SuppressWarnings(\"unchecked\")", "+    private void initState(Operation o)", "+    {", "+        nCycles = 0;", "+        nVertices = graph.vertexSet().size();", "+        if (o == Operation.ENUMERATE) {", "+            cycles = new ArrayList<List<V>>();", "+        }", "+        blocked = new boolean[nVertices];", "+        stack = new ArrayDeque<Integer>(nVertices);", "+", "+        B = new ArrayList[nVertices];", "+        for (int i = 0; i < nVertices; i++) {", "+            //B[i] = new ArrayList<Integer>(nVertices);", "+            B[i] = new ArrayList<Integer>();", "+        }", "+", "+        iToV = (V []) graph.vertexSet().toArray();", "+        vToI = new HashMap<V, Integer>();", "+        for (int i = 0; i < iToV.length; i++) {", "+            vToI.put(iToV[i], i);", "+        }", "+", "+        Ak = buildAdjacencyList();", "+", "+        stack.clear();", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "daefbd44b5d20acb14aee2afd59eb743", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/EdmondsBlossomShrinking.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "      private V findPath(V root)", "signatureAfterChange": "      private V findPath(V root)", "diff": ["-                if (to == v)", "+                if (to == v) {", "+                }", "-                if (to == root || (match.containsKey(to))", "-                        && (p.containsKey(match.get(to)))) {", "+                if ((to == root)", "+                    || ((match.containsKey(to))", "+                        && (p.containsKey(match.get(to)))))", "+                {", "-                                && blossom.contains(base.get(i)))", "+                            && blossom.contains(base.get(i)))"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e35f5afb2d9a6284b2d926b9481c90d8", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "b261cb99c92126b64c9129dbe772684f0da5e234", "commitAfterChange": "22927827f36ad9b2cef7c5f5670c4d2598840023", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public double shortestDistance(V a, V b)", "signatureAfterChange": "     public double shortestDistance(V a, V b)", "diff": ["-    public double shortestDistance(V a, V b) {", "-", "+    public double shortestDistance(V a, V b)", "+    {", "-        if (d == null)", "+        if (d == null) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e6356465f9a2e11aebfe7acdc28fa544", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/DijkstraShortestPath.java", "commitBeforeChange": "9925a64dfac7ab322a635b1bf982c0481a3c1421", "commitAfterChange": "b807c0433e272bfef62ba41e0db8e4bd3d8200de", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     private static List createPath( ClosestFirstIterator iter, Object endVertex )", "signatureAfterChange": "     private static List createPath( ClosestFirstIterator iter, Object endVertex )", "diff": ["-        for( ;; ) {", "+        while( true ) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e794ab145829eef793f86be207793ab2", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "b261cb99c92126b64c9129dbe772684f0da5e234", "commitAfterChange": "22927827f36ad9b2cef7c5f5670c4d2598840023", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     private void lazyCalculate()", "signatureAfterChange": "     private void lazyCalculate()", "diff": ["-    private void lazyCalculate() {", "-", "+    private void lazyCalculate()", "+    {", "-        for (int i = 0; i < n; i++)", "+        for (int i = 0; i < n; i++) {", "+        }", "-        for (int i = 0; i < n; i++)", "+        for (int i = 0; i < n; i++) {", "+        }", "-                        diameter = diameter > d[i][j] ? diameter : d[i][j];", "+                        diameter = (diameter > d[i][j]) ? diameter : d[i][j];"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e7cf27992ef3d21d07600beaa2e1a352", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/alg/NearestNeighborTSPAlgorithm.java", "commitBeforeChange": "ede00ba6ca48a7a81231a62519a30fabb26ae338", "commitAfterChange": "f63e1142cae73862c9c4f7b6ce46225b40f3ef86", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "      public WeightedGraph tspTour() throws Exception", "signatureAfterChange": "     public WeightedGraph tspTour(  ) throws Exception", "diff": ["-    public WeightedGraph tspTour() throws Exception {", "+     */", "+    public WeightedGraph tspTour(  ) throws Exception {", "+        WeightedGraph tour      = new SimpleWeightedGraph(  );", "+        Set           used      = new HashSet(  );", "+        Object        posVertex = _wgraph.vertexSet(  ).iterator(  ).next(  );", "+        used.add( posVertex );", "-        WeightedGraph tour = new SimpleWeightedGraph();", "-        Set used = new HashSet();", "-        Object posVertex = _wgraph.vertexSet().iterator().next();", "-        used.add(posVertex);", "+        while( used.size(  ) < _wgraph.vertexSet(  ).size(  ) ) {", "+            double min  = Double.POSITIVE_INFINITY;", "+            Edge   next = null;", "-        while (used.size() < _wgraph.vertexSet().size()) {", "-            double min = Double.POSITIVE_INFINITY;", "-            Edge next = null;", "-            for (Iterator it = _wgraph.edgesOf(posVertex).iterator(); it.hasNext();) {", "-                Edge edge = (Edge)it.next();", "-                if (!used.contains(edge.oppositeVertex(posVertex)) &&", "-                    edge.getWeight() < min) {", "-                    min = edge.getWeight();", "-                    next = edge;", "+            for( Iterator it = _wgraph.edgesOf( posVertex ).iterator(  );", "+                    it.hasNext(  ); ) {", "+                Edge edge = (Edge) it.next(  );", "+", "+                if( !used.contains( edge.oppositeVertex( posVertex ) )", "+                        && edge.getWeight(  ) < min ) {", "+                    min      = edge.getWeight(  );", "+                    next     = edge;", "-            if (next == null) throw new Exception(\"NoTSPTour\");", "-            posVertex = next.oppositeVertex(posVertex);", "-            used.add(posVertex);", "-            tour.addEdge(next);", "+", "+            if( next == null ) {", "+                throw new Exception( \"NoTSPTour\" );", "+            }", "+", "+            posVertex = next.oppositeVertex( posVertex );", "+            used.add( posVertex );", "+            tour.addEdge( next );", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e9c8bd0df5fbe10ffec9f1bd04f474ca", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/HopcroftKarpBipartiteMatching.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " \tprivate boolean interSectionNotEmpty(Set<V> vertexSet1, Set<V> vertexSet2)", "signatureAfterChange": "     private boolean interSectionNotEmpty(Set<V> vertexSet1, Set<V> vertexSet2)", "diff": ["+     */", "+    private boolean interSectionNotEmpty(Set<V> vertexSet1, Set<V> vertexSet2)", "+    {", "+        for (V vertex : vertexSet1) {", "+            if (vertexSet2.contains(vertex)) {", "+            }", "+        }", "+        return false;", "+    }", "-\t */", "-\tprivate boolean interSectionNotEmpty(Set<V> vertexSet1, Set<V> vertexSet2){", "-\t\tfor(V vertex: vertexSet1)", "-\t\t\tif(vertexSet2.contains(vertex))", "-\t\t\t\treturn true;", "-\t\treturn false;", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eaa7ecac442a33e2e3d089cdee3f25ec", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/heap/AbstractHeap.java", "commitBeforeChange": "ede00ba6ca48a7a81231a62519a30fabb26ae338", "commitAfterChange": "f63e1142cae73862c9c4f7b6ce46225b40f3ef86", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 6, "signatureBeforeChange": "      protected final boolean isSmaller(Object x, Object y)", "signatureAfterChange": "     protected final boolean isSmaller( Object x, Object y )", "diff": ["-    protected final boolean isSmaller(Object x, Object y) {", "-        if (_comp != null) return _comp.compare(x, y) * _compareFactor < 0;", "-        return ((Comparable)x).compareTo(y) * _compareFactor < 0;", "+     */", "+    protected final boolean isSmaller( Object x, Object y ) {", "+        if( _comp != null ) {", "+            return _comp.compare( x, y ) * _compareFactor < 0;", "+        }", "+", "+        return ( (Comparable) x ).compareTo( y ) * _compareFactor < 0;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eedb628dfda1a3e16f81be52fa1e37e3", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r     public Set<Set<V>> getSeparators()", "signatureAfterChange": "     public Set<Set<V>> getSeparators()", "diff": ["-     */\r", "-    public Set<Set<V>> getSeparators()\r", "-    {\r", "-        if (separators == null)\r", "-            computeAtoms();\r", "-\r", "-        return separators;\r", "-    }\r", "+     */", "+    public Set<Set<V>> getSeparators()", "+    {", "+        if (separators == null) {", "+            computeAtoms();", "+        }", "+", "+        return separators;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f33c2977673ee6681d98720c739fc788", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/graph/AsWeightedGraph.java", "commitBeforeChange": "76d8d52bc063f9cd4364e294dbe191c5648bf05d", "commitAfterChange": "d11cabd1aabdc954107d901bc835dd46e2c5b915", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public void setEdgeWeight(E e, double weight)", "signatureAfterChange": "     public void setEdgeWeight(E e, double weight)", "diff": ["-        if ( isWeightedGraph )", "+        if (isWeightedGraph) {", "+        }", "-    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f37229ecae19255dcd2012350bdadcfa", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/IsomorphicGraphMapping.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "      @Override     public V getVertexCorrespondence(V v, boolean forward)", "signatureAfterChange": "            @Override public V getVertexCorrespondence(V v, boolean forward)", "diff": ["-    @Override", "-    public V getVertexCorrespondence(V v, boolean forward) {", "+", "+    @Override public V getVertexCorrespondence(V v, boolean forward)", "+    {", "-        int[] core;", "+        int [] core;", "-            firstGraph  = g1;", "+            firstGraph = g1;", "-            core        = core1;", "+            core = core1;", "-            firstGraph  = g2;", "+            firstGraph = g2;", "-            core        = core2;", "+            core = core2;", "-        int vNumber = firstGraph.getVertexNumber(v),", "-            uNumber = core[vNumber];", "+        int vNumber = firstGraph.getVertexNumber(v), uNumber = core[vNumber];", "-        if (uNumber == VF2State.NULL_NODE)", "+        if (uNumber == VF2State.NULL_NODE) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f402d1814026cb20fbbbaf4a5e36a4c4", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r     public Map<Set<V>, Integer> getFullComponentCount()", "signatureAfterChange": "     public Map<Set<V>, Integer> getFullComponentCount()", "diff": ["-     */\r", "-    public Map<Set<V>, Integer> getFullComponentCount()\r", "-    {\r", "-        if (fullComponentCount == null)\r", "-            computeAtoms();\r", "-\r", "-        return fullComponentCount;\r", "-    }\r", "+     */", "+    public Map<Set<V>, Integer> getFullComponentCount()", "+    {", "+        if (fullComponentCount == null) {", "+            computeAtoms();", "+        }", "+", "+        return fullComponentCount;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5e5c50dced429f37c8c89046dfee9cf", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r     public boolean isChordal()", "signatureAfterChange": "     public boolean isChordal()", "diff": ["-     */\r", "-    public boolean isChordal()\r", "-    {\r", "-        if (chordalGraph == null)\r", "-            computeMinimalTriangulation();\r", "-\r", "-        return (chordalGraph.edgeSet().size() == graph.edgeSet().size());\r", "-    }\r", "+     */", "+    public boolean isChordal()", "+    {", "+        if (chordalGraph == null) {", "+            computeMinimalTriangulation();", "+        }", "+", "+        return (chordalGraph.edgeSet().size() == graph.edgeSet().size());", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f7902dcd73350b4c80d7fe1bc1d52dac", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/HopcroftKarpBipartiteMatching.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tprivate void symmetricDifference(LinkedList<V> augmentingPath)", "signatureAfterChange": "     private void symmetricDifference(LinkedList<V> augmentingPath)", "diff": ["+     */", "+    private void symmetricDifference(LinkedList<V> augmentingPath)", "+    {", "+        int operation = 0;", "+", "+        //The augmenting path alternatingly has an edge which is not part of the", "+        //matching, and an edge which is part of the matching. Edges which are", "+        //already part of the matching are removed, the others are added.", "+        while (augmentingPath.size() > 0) {", "+            E edge =", "+                graph.getEdge(augmentingPath.poll(), augmentingPath.peek());", "+            if ((operation % 2) == 0) {", "+                matching.add(edge);", "+            } else {", "+                matching.remove(edge);", "+            }", "+            operation++;", "+        }", "+    }", "-\t */", "-\tprivate void symmetricDifference(LinkedList<V> augmentingPath){", "-\t\tint operation=0;", "-\t\t//The augmenting path alternatingly has an edge which is not part of the matching, and an edge", "-\t\t//which is part of the matching. Edges which are already part of the matching are removed, the others are added.", "-\t\twhile(augmentingPath.size()>0){", "-\t\t\tE edge=graph.getEdge(augmentingPath.poll(),augmentingPath.peek());", "-\t\t\tif(operation%2==0){", "-\t\t\t\tmatching.add(edge);", "-\t\t\t}else", "-\t\t\t\tmatching.remove(edge);", "-\t\t\toperation++;", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f86bc49369b194502561daee3a6609fa", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/VF2MappingIterator.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "      @Override     public boolean hasNext()", "signatureAfterChange": "      @Override public boolean hasNext()", "diff": ["-    @Override", "-    public boolean hasNext() {", "-        if (nextMapping != null)", "+    @Override public boolean hasNext()", "+    {", "+        if (nextMapping != null) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fcefb68ea1b96b2cf7c396ae940c1c37", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/MinSourceSinkCut.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic Set<V> getSinkPartition()", "signatureAfterChange": "     public Set<V> getSinkPartition()", "diff": ["-\t */", "-\tpublic Set<V> getSinkPartition(){", "-\t\tif(minCut==null)", "-\t\t\treturn null;", "-\t\tSet<V> set=new HashSet<V>(graph.vertexSet());", "-\t\tset.removeAll(minCut);", "-\t\treturn Collections.unmodifiableSet(set);", "-\t}", "+     */", "+    public Set<V> getSinkPartition()", "+    {", "+        if (minCut == null) {", "+            return null;", "+        }", "+        Set<V> set = new HashSet<V>(graph.vertexSet());", "+        set.removeAll(minCut);", "+        return Collections.unmodifiableSet(set);", "+    }"]}]}