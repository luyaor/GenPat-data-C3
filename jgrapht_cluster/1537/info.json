{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bf44abd0a29b641a7d332c3e5083d372", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f1c3564f2bb8879472ebeed92ea64dd", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/CycleDetector.java", "commitBeforeChange": "2003496a80f483b98d40a459268e93d0fdaec76c", "commitAfterChange": "618193dfca3ac4de3a61698028cfd965351c74a1", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     public Set<V> findCycles()", "signatureAfterChange": "     public Set<V> findCycles()", "diff": ["+        // ProbeIterator can't be used to handle this case,", "+        // so use StrongConnectivityInspector instead.", "+        StrongConnectivityInspector<V, E> inspector =", "+            new StrongConnectivityInspector<V, E>(graph);", "+        List<Set<V>> components = inspector.stronglyConnectedSets();", "+", "+        // A vertex participates in a cycle if either of the following is", "+        // true:  (a) it is in a component whose size is greater than 1", "+        // or (b) it is a self-loop", "+", "-        execute(set, null);", "+        for (Set<V> component : components) {", "+            if (component.size() > 1) {", "+                // cycle", "+                set.addAll(component);", "+            } else {", "+                V v = component.iterator().next();", "+                if (graph.containsEdge(v, v)) {", "+                    // self-loop", "+                    set.add(v);", "+                }", "+            }", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f179429d4ad60a425412e308ca61a375", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/KShortestPathsIterator.java", "commitBeforeChange": "94e0b9cdbd464a6b60ddbb8cd6d473a32e102eaf", "commitAfterChange": "90d794caa7b37ed092890eb859473902af3157bc", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 9, "signatureBeforeChange": "      private void savePassData(Set<V> improvedVertices)", "signatureAfterChange": "      private void savePassData(Set<V> improvedVertices)", "diff": ["-            RankingPathElementList<V, E> clonedData =", "+            RankingPathElementList<V, E> pathElementList =", "+                this.seenDataContainer.get(vertex);", "+", "+            RankingPathElementList<V, E> improvedPaths =", "-                    this.seenDataContainer.get(vertex));", "-            this.prevSeenDataContainer.put(vertex, clonedData);", "+                    this.graph,", "+                    pathElementList.maxSize,", "+                    vertex);", "+", "+            for (", "+                Iterator<RankingPathElement<V, E>> pathIter =", "+                    pathElementList.iterator();", "+                pathIter.hasNext();)", "+            {", "+                RankingPathElement<V, E> path = pathIter.next();", "+                if (path.getHopCount() == this.passNumber) {", "+                    // the path has just been computed.", "+                    improvedPaths.pathElements.add(path);", "+                }", "+            }", "+", "+            this.prevSeenDataContainer.put(vertex, improvedPaths);"]}]}