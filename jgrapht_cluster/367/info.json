{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1f6d6a0034cb301732e676fa2eca5d24", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1a01dab21d852baa745117d25f1f1cd5", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/PrimMinimumSpanningTree.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "      public PrimMinimumSpanningTree(final Graph<V, E> g)", "signatureAfterChange": "            public PrimMinimumSpanningTree(final Graph<V, E> g)", "diff": ["-", "-    public PrimMinimumSpanningTree(final Graph<V, E> g) {", "-", "-        this.minimumSpanningTreeEdgeSet = new HashSet<E>(g.vertexSet().size());", "-", "-        Set<V> unspanned  = new HashSet<V>(g.vertexSet());", "-", "-        while (!unspanned.isEmpty()) {", "-", "-            Iterator<V> ri = unspanned.iterator();", "-", "-            V root = ri.next();", "-", "-            ri.remove();", "-", "-            // Edges crossing the cut C = (S, V \\ S), where S is set of already spanned vertices", "-", "-            PriorityQueue<E> dangling =", "-                new PriorityQueue<E>(", "-                    g.edgeSet().size(),", "-                    new Comparator<E>() {", "-                        @Override", "-                        public int compare(E lop, E rop) {", "-                            return Double.valueOf(g.getEdgeWeight(lop)).compareTo(g.getEdgeWeight(rop));", "-                        }", "-                    }", "-                );", "-", "-            dangling.addAll(g.edgesOf(root));", "-", "-            for (E next; (next = dangling.poll()) != null;) {", "-", "-                V s, t = unspanned.contains(s = g.getEdgeSource(next)) ? s : g.getEdgeTarget(next);", "-", "-                // Decayed edges aren't removed from priority-queue so that having them just ignored", "-                // being encountered through min-max traversal", "-                if (!unspanned.contains(t))", "-                    continue;", "-", "-                this.minimumSpanningTreeEdgeSet.add(next);", "-", "-                unspanned.remove(t);", "-", "-                for (E e : g.edgesOf(t)) {", "-                    if (unspanned.contains(g.getEdgeSource(e).equals(t) ? g.getEdgeTarget(e) : g.getEdgeSource(e)))", "-                        dangling.add(e);", "-                }", "-", "-            }", "-", "-        }", "-", "-        double spanningTreeWeight = 0;", "-        for (E e : minimumSpanningTreeEdgeSet) {", "-            spanningTreeWeight += g.getEdgeWeight(e);", "-        }", "-", "-        this.minimumSpanningTreeTotalWeight = spanningTreeWeight;", "-", "-    }", "+", "+    public PrimMinimumSpanningTree(final Graph<V, E> g)", "+    {", "+        this.minimumSpanningTreeEdgeSet = new HashSet<E>(g.vertexSet().size());", "+", "+        Set<V> unspanned = new HashSet<V>(g.vertexSet());", "+", "+        while (!unspanned.isEmpty()) {", "+            Iterator<V> ri = unspanned.iterator();", "+", "+            V root = ri.next();", "+", "+            ri.remove();", "+", "+            // Edges crossing the cut C = (S, V \\ S), where S is set of", "+            // already spanned vertices", "+", "+            PriorityQueue<E> dangling =", "+                new PriorityQueue<E>(", "+                    g.edgeSet().size(),", "+                    new Comparator<E>() {", "+                        @Override public int compare(E lop, E rop)", "+                        {", "+                            return Double.valueOf(g.getEdgeWeight(lop))", "+                                .compareTo(g.getEdgeWeight(rop));", "+                        }", "+                    });", "+", "+            dangling.addAll(g.edgesOf(root));", "+", "+            for (E next; (next = dangling.poll()) != null;) {", "+                V s,", "+                    t =", "+                        unspanned.contains(s = g.getEdgeSource(next)) ? s", "+                        : g.getEdgeTarget(next);", "+", "+                // Decayed edges aren't removed from priority-queue so that", "+                // having them just ignored being encountered through min-max", "+                // traversal", "+                if (!unspanned.contains(t)) {", "+                    continue;", "+                }", "+", "+                this.minimumSpanningTreeEdgeSet.add(next);", "+", "+                unspanned.remove(t);", "+", "+                for (E e : g.edgesOf(t)) {", "+                    if (unspanned.contains(", "+                            g.getEdgeSource(e).equals(t) ? g.getEdgeTarget(", "+                                e)", "+                            : g.getEdgeSource(e)))", "+                    {", "+                        dangling.add(e);", "+                    }", "+                }", "+            }", "+        }", "+", "+        double spanningTreeWeight = 0;", "+        for (E e : minimumSpanningTreeEdgeSet) {", "+            spanningTreeWeight += g.getEdgeWeight(e);", "+        }", "+", "+        this.minimumSpanningTreeTotalWeight = spanningTreeWeight;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "88df1842f4148602cf4c6ff88fb764cb", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/alg/DijkstraAlgorithm.java", "commitBeforeChange": "ede00ba6ca48a7a81231a62519a30fabb26ae338", "commitAfterChange": "f63e1142cae73862c9c4f7b6ce46225b40f3ef86", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public final WeightedGraph optimumPathTree(Object from)", "signatureAfterChange": "     public final WeightedGraph optimumPathTree( Object from )", "diff": ["-    */", "-    public final WeightedGraph optimumPathTree(Object from) {", "+     */", "+    public final WeightedGraph optimumPathTree( Object from ) {", "-        if (_directed) {", "-            optimumPathTree = new SimpleDirectedWeightedGraph();", "-        } else {", "-            optimumPathTree = new SimpleWeightedGraph();", "+", "+        if( _directed ) {", "+            optimumPathTree = new SimpleDirectedWeightedGraph(  );", "-        _heap.clear();", "-        _heapVertices.clear();", "-        for (Iterator it = _wgraph.vertexSet().iterator(); it.hasNext();) {", "-            Object vertex = it.next();", "-            HeapVertex heapV;", "-            if (vertex instanceof HeapVertex) {", "-                heapV = (HeapVertex)vertex;", "-            } else {", "-                heapV = new HeapVertex(vertex);", "-                _heapVertices.put(vertex, heapV);", "-            }", "-            if (vertex == from) {", "-                heapV.setPriority(_compare > 0 ? 0 : Double.POSITIVE_INFINITY);", "-            } else {", "-                heapV.setPriority(_compare * Double.POSITIVE_INFINITY);", "-            }", "-            _heap.add(heapV);", "+        else {", "+            optimumPathTree = new SimpleWeightedGraph(  );", "-        while (!_heap.isEmpty()) {", "-            HeapVertex hv = heapVertex(_heap.extractTop());", "-            Object v = hv.getVertex();", "-            Edge treeEdge = (Edge)hv.getAdditional();", "-            if (treeEdge != null) GraphHelper.addEdgeWithVertices(optimumPathTree, treeEdge);", "-            Iterator edges;", "-            if (_directed) {", "-                edges = ((DirectedGraph)_wgraph).outgoingEdgesOf(v).iterator();", "-            } else {", "-                edges = _wgraph.edgesOf(v).iterator();", "+        _heap.clear(  );", "+        _heapVertices.clear(  );", "+", "+        for( Iterator it = _wgraph.vertexSet(  ).iterator(  ); it.hasNext(  ); ) {", "+            Object     vertex = it.next(  );", "+            HeapVertex heapV;", "+", "+            if( vertex instanceof HeapVertex ) {", "+                heapV = (HeapVertex) vertex;", "-            while (edges.hasNext()) {", "-                Edge e = (Edge)edges.next();", "-                HeapVertex u = heapVertex(e.oppositeVertex(v));", "-                double newPrio = priorityFunction(hv.getPriority(), e.getWeight());", "-                if (_compare * (u.getPriority() - newPrio) > 0) {", "-                    u.setPriority(newPrio);", "-                    u.setAdditional(e);", "-                    _heap.update(u);", "+            else {", "+                heapV = new HeapVertex( vertex );", "+                _heapVertices.put( vertex, heapV );", "+            }", "+", "+            if( vertex == from ) {", "+                heapV.setPriority( _compare > 0 ? 0 : Double.POSITIVE_INFINITY );", "+            }", "+            else {", "+                heapV.setPriority( _compare * Double.POSITIVE_INFINITY );", "+            }", "+", "+            _heap.add( heapV );", "+        }", "+", "+        while( !_heap.isEmpty(  ) ) {", "+            HeapVertex hv       = heapVertex( _heap.extractTop(  ) );", "+            Object     v        = hv.getVertex(  );", "+            Edge       treeEdge = (Edge) hv.getAdditional(  );", "+", "+            if( treeEdge != null ) {", "+                GraphHelper.addEdgeWithVertices( optimumPathTree, treeEdge );", "+            }", "+", "+            Iterator edges;", "+", "+            if( _directed ) {", "+                edges =", "+                    ( (DirectedGraph) _wgraph ).outgoingEdgesOf( v ).iterator(  );", "+            }", "+            else {", "+                edges = _wgraph.edgesOf( v ).iterator(  );", "+            }", "+", "+            while( edges.hasNext(  ) ) {", "+                Edge       e       = (Edge) edges.next(  );", "+                HeapVertex u       = heapVertex( e.oppositeVertex( v ) );", "+                double     newPrio =", "+                    priorityFunction( hv.getPriority(  ), e.getWeight(  ) );", "+", "+                if( _compare * ( u.getPriority(  ) - newPrio ) > 0 ) {", "+                    u.setPriority( newPrio );", "+                    u.setAdditional( e );", "+                    _heap.update( u );", "+"]}]}