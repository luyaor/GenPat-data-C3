{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1cfad471e743791885546bf3db8d1471", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35fbff8be0e44836e3227d8a8a1685db", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/util/equivalence/EquivalenceSetCreator.java", "commitBeforeChange": "dd14e683f649f6134a6a191da9a4899af88c4041", "commitAfterChange": "b4805f5d86b128879dfab0c1dd754e481a6373b2", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "     private static HashMap createEqualityGroupMap(         Object [] aElementsArray,         EquivalenceComparator aEqComparator,         Object aComparatorContext)", "signatureAfterChange": "     private static <EE, CC> HashMap<Integer,List<EquivalenceSet<? super EE,? super CC>>> createEqualityGroupMap(         Collection<EE> elements,         EquivalenceComparator<? super EE,? super CC> aEqComparator,         CC aComparatorContext)", "diff": ["-    private static HashMap createEqualityGroupMap(", "-        Object [] aElementsArray,", "-        EquivalenceComparator aEqComparator,", "-        Object aComparatorContext)", "+    private static <EE, CC> HashMap<Integer,List<EquivalenceSet<? super EE,? super CC>>> createEqualityGroupMap(", "+        Collection<EE> elements,", "+        EquivalenceComparator<? super EE,? super CC> aEqComparator,", "+        CC aComparatorContext)", "-        HashMap equalityGroupMap = new HashMap(aElementsArray.length);", "+        HashMap<Integer,List<EquivalenceSet<? super EE,? super CC>>> equalityGroupMap =", "+            new HashMap<Integer,List<EquivalenceSet<? super EE,? super CC>>>(elements.size());", "-        for (int i = 0; i < aElementsArray.length; i++) {", "+        for( EE curentElement : elements ) {", "-                aEqComparator.equivalenceHashcode(", "-                    aElementsArray[i],", "-                    aComparatorContext);", "-            Object mapValue = equalityGroupMap.get(Integer.valueOf(hashcode));", "+                aEqComparator.equivalenceHashcode( curentElement,", "+                                                   aComparatorContext);", "+            List<EquivalenceSet<? super EE,? super CC>> list =", "+                equalityGroupMap.get(Integer.valueOf(hashcode));", "-            // EquivalenceSet(there", "-            // is one already with that hash) , or a list of EquivalenceSet", "-            if (mapValue == null) {", "-                // create list with one elemnt in it", "-                List list = new LinkedList();", "-                list.add(new EquivalenceSet(", "-                        aElementsArray[i],", "+            // or a list of EquivalenceSet", "+", "+            if (list == null) {", "+                // create list with one element in it", "+                list = new LinkedList<EquivalenceSet<? super EE,? super CC>>();", "+                list.add(new EquivalenceSet<EE,CC>(", "+                        curentElement,", "-            } else if (mapValue instanceof List) {", "-                List list = (List) mapValue;", "+            } else {", "-                for (Iterator iter = list.iterator(); iter.hasNext();) {", "-                    EquivalenceSet eqGroup = (EquivalenceSet) iter.next();", "+                for (EquivalenceSet<? super EE,? super CC> eqGroup : list) {", "-                            aElementsArray[i],", "+                            curentElement,", "-                        eqGroup.add(aElementsArray[i]);", "+                        eqGroup.add(curentElement);", "-                    list.add(new EquivalenceSet(", "-                            aElementsArray[i],", "+                    list.add(new EquivalenceSet<EE,CC>(", "+                            curentElement,", "-            } else {", "-                throw new RuntimeException(", "-                    \"The equalityGroupMap value may only be null or List\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "40391396c679eda93e5830ec7b871c94", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/HamiltonianCycle.java", "commitBeforeChange": "ce0f78b94ba0a535e51aa5dfcfb3c56c6c67d881", "commitAfterChange": "40bf8c7c8736ae974ebda20b591cad2363132552", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static <V, E> List<V> getApproximateOptimal( \t\t\tSimpleWeightedGraph<V, E> g)", "signatureAfterChange": "     public static <V, E> List<V> getApproximateOptimal(         SimpleWeightedGraph<V, E> g)", "diff": ["+     */", "+    public static <V, E> List<V> getApproximateOptimal(", "+        SimpleWeightedGraph<V, E> g)", "+    {", "+        List<V> vertices = new LinkedList<V>(g.vertexSet());", "-\t */", "-\tpublic static <V, E> List<V> getApproximateOptimal(", "-\t\t\tSimpleWeightedGraph<V, E> g) {", "-\t\tList<V> vertices = new LinkedList<V>(g.vertexSet());", "+        // If the graph is not complete then return null since this algorithm", "+        // requires the graph be complete", "+        if ((vertices.size() * (vertices.size() - 1) / 2)", "+            != g.edgeSet().size())", "+        {", "+            return null;", "+        }", "-\t\t// If the graph is not complete then return null since this algorithm", "-\t\t// requires the graph be complete", "-\t\tif (vertices.size() * (vertices.size() - 1) / 2 != g.edgeSet().size())", "-\t\t\treturn null;", "+        List<V> tour = new LinkedList<V>();", "-\t\tList<V> tour = new LinkedList<V>();", "+        // Each iteration a new vertex will be added to the tour until all", "+        // vertices have been added", "+        while (tour.size() != g.vertexSet().size()) {", "+            boolean firstEdge = true;", "+            double minEdgeValue = 0;", "+            int minVertexFound = 0;", "+            int vertexConnectedTo = 0;", "-\t\t// Each iteration a new vertex will be added to the tour until all", "-\t\t// vertices have been added", "-\t\twhile (tour.size() != g.vertexSet().size()) {", "-\t\t\tboolean firstEdge = true;", "-\t\t\tdouble minEdgeValue = 0;", "-\t\t\tint minVertexFound = 0;", "-\t\t\tint vertexConnectedTo = 0;", "-", "-\t\t\t// A check will be made for the shortest edge to a vertex not within", "-\t\t\t// the tour and that new vertex will be added to the vertex", "-\t\t\tfor (int i = 0; i < tour.size(); i++) {", "-\t\t\t\tV v = tour.get(i);", "-\t\t\t\tfor (int j = 0; j < vertices.size(); j++) {", "-\t\t\t\t\tdouble weight = g.getEdgeWeight(g.getEdge(v, vertices", "-\t\t\t\t\t\t\t.get(j)));", "-\t\t\t\t\tif (firstEdge || weight < minEdgeValue) {", "-\t\t\t\t\t\tfirstEdge = false;", "-\t\t\t\t\t\tminEdgeValue = weight;", "-\t\t\t\t\t\tminVertexFound = j;", "-\t\t\t\t\t\tvertexConnectedTo = i;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\ttour.add(vertexConnectedTo, vertices.get(minVertexFound));", "-\t\t\tvertices.remove(minVertexFound);", "-\t\t}", "-\t\treturn tour;", "-\t}", "+            // A check will be made for the shortest edge to a vertex not within", "+            // the tour and that new vertex will be added to the vertex", "+            for (int i = 0; i < tour.size(); i++) {", "+                V v = tour.get(i);", "+                for (int j = 0; j < vertices.size(); j++) {", "+                    double weight =", "+                        g.getEdgeWeight(g.getEdge(v, vertices.get(j)));", "+                    if (firstEdge || (weight < minEdgeValue)) {", "+                        firstEdge = false;", "+                        minEdgeValue = weight;", "+                        minVertexFound = j;", "+                        vertexConnectedTo = i;", "+                    }", "+                }", "+            }", "+            tour.add(vertexConnectedTo, vertices.get(minVertexFound));", "+            vertices.remove(minVertexFound);", "+        }", "+        return tour;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "888deeb8012bcb8b8eab93bb740fe6c7", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/StrongConnectivityInspector.java", "commitBeforeChange": "04b4adb9d61a0a7a990979c19fd44e55accd860f", "commitAfterChange": "ccbda858621a3d1beb6a9381a0fc81c3673ee66c", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public List stronglyConnectedSets(  )", "signatureAfterChange": "     public List stronglyConnectedSets()", "diff": ["-    public List stronglyConnectedSets(  ) {", "-        if( m_stronglyConnectedSets == null ) {", "-            m_verticesToVerticesData =", "-                new HashMap( m_graph.vertexSet(  ).size(  ) );", "-            m_orderedVertices           = new LinkedList(  );", "-            m_stronglyConnectedSets =", "-                new Vector( m_graph.vertexSet(  ).size(  ) );", "+    public List stronglyConnectedSets() {", "+        if (m_stronglyConnectedSets == null) {", "+", "+            m_orderedVertices = new LinkedList();", "+            m_stronglyConnectedSets = new Vector();", "-            Iterator iter = m_graph.vertexSet(  ).iterator(  );", "-", "-            while( iter.hasNext(  ) ) {", "-                Object vertex = iter.next(  );", "-                m_verticesToVerticesData.put( vertex,", "-                    new VertexData( vertex, false, false ) );", "-            }", "+            createVertexData();", "-            iter = m_verticesToVerticesData.values(  ).iterator(  );", "+            Iterator iter = m_vertexToVertexData.values().iterator();", "-            while( iter.hasNext(  ) ) {", "-                VertexData data = (VertexData) iter.next(  );", "+            while (iter.hasNext()) {", "+                VertexData data = (VertexData) iter.next();", "-                if( !data.m_discovered ) {", "-                    dfsVisit( m_graph, data, null );", "+                if (!data.m_discovered) {", "+                    dfsVisit(m_graph, data, null);", "-            // calculate inverse graph (i.e. every edge is turned)", "-            DirectedGraph inverseGraph = new DefaultDirectedGraph(  );", "-            GraphHelper.addGraphReversed( inverseGraph, m_graph );", "+            // calculate inverse graph (i.e. every edge is reversed)", "+            DirectedGraph inverseGraph = new DefaultDirectedGraph();", "+            GraphHelper.addGraphReversed(inverseGraph, m_graph);", "-            resetVertexData(  );", "+            resetVertexData();", "-            iter = m_orderedVertices.iterator(  );", "+            iter = m_orderedVertices.iterator();", "-            while( iter.hasNext(  ) ) {", "-                VertexData data = (VertexData) iter.next(  );", "+            while (iter.hasNext()) {", "+                VertexData data = (VertexData) iter.next();", "-                if( !data.m_discovered ) {", "+                if (!data.m_discovered) {", "-                    Set set = new HashSet(  );", "-                    m_stronglyConnectedSets.add( set );", "-                    dfsVisit( inverseGraph, data, set );", "+                    Set set = new HashSet();", "+                    m_stronglyConnectedSets.add(set);", "+                    dfsVisit(inverseGraph, data, set);", "-            m_graph                      = null;", "-            m_orderedVertices            = null;", "-            m_verticesToVerticesData     = null;", "+            m_orderedVertices = null;", "+            m_vertexToVertexData = null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d4c6295c97fae13e6810aa34aeb60a20", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/GraphReader.java", "commitBeforeChange": "706aa3597ecf30c14c3a4ac469519dd45ef4dc50", "commitAfterChange": "55241662127745f1a473298706f974517b39b392", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public static void main( String[] args ) throws Exception", "signatureAfterChange": "     public static void main( String[] args ) throws Exception", "diff": ["-        Graph g = new SimpleGraph(  );", "+        Graph g = new SimpleWeightedGraph(  );", "-", "-        Set uncovered = new HashSet( g.edgeSet(  ) );", "-", "-        for( Iterator it = g.vertexSet(  ).iterator(  ); it.hasNext(  ); ) {", "-            Object v = it.next(  );", "-            Set    c = new HashSet( GraphHelper.neighborListOf( g, v ) );", "-            c.add( v );", "-", "-            Graph sub = new Subgraph( g, c, null );", "-", "-            if( GraphTests.isComplete( sub ) ) {", "-                System.out.println( c );", "-                uncovered.removeAll( sub.edgeSet(  ) );", "-            }", "+        ", "+        {long time = System.currentTimeMillis();", "+        ShortestPathIterator spi = new ShortestPathIterator(g, g.vertexSet(  ).iterator(  ).next(), org._3pq.jgrapht.experimental.heap.FibonacciHeap.getFactory());", "+        while (spi.hasNext(  )) {", "+            Object v = spi.next(  );", "+//             System.out.println( v + \" \" + spi.getSpanningTreeEdge(v) + \" \" + spi.getPrio(v));", "+        System.out.println( System.currentTimeMillis() - time );", "+        time = System.currentTimeMillis();", "+        ClosestFirstIterator cfi = new ClosestFirstIterator(g, g.vertexSet(  ).iterator(  ).next());", "+        while (cfi.hasNext(  )) {", "+            Object v = cfi.next(  );", "+//             System.out.println( v + \" \" + cfi.getSpanningTreeEdge(v));", "+        }", "+        System.out.println( System.currentTimeMillis() - time );}", "+        {long time = System.currentTimeMillis();", "+        ShortestPathIterator spi = new ShortestPathIterator(g, g.vertexSet(  ).iterator(  ).next(), org._3pq.jgrapht.experimental.heap.FibonacciHeap.getFactory());", "+        while (spi.hasNext(  )) {", "+            Object v = spi.next(  );", "+//             System.out.println( v + \" \" + spi.getSpanningTreeEdge(v) + \" \" + spi.getPrio(v));", "+        }", "+        System.out.println( System.currentTimeMillis() - time );", "+        time = System.currentTimeMillis();", "+        ClosestFirstIterator cfi = new ClosestFirstIterator(g, g.vertexSet(  ).iterator(  ).next());", "+        while (cfi.hasNext(  )) {", "+            Object v = cfi.next(  );", "+//             System.out.println( v + \" \" + cfi.getSpanningTreeEdge(v));", "+        }", "+        System.out.println( System.currentTimeMillis() - time );}", "+        long time = System.currentTimeMillis();", "+        ShortestPathIterator spi = new ShortestPathIterator(g, g.vertexSet(  ).iterator(  ).next(), org._3pq.jgrapht.experimental.heap.FibonacciHeap.getFactory());", "+        while (spi.hasNext(  )) {", "+            Object v = spi.next(  );", "+//             System.out.println( v + \" \" + spi.getSpanningTreeEdge(v) + \" \" + spi.getPrio(v));", "+        }", "+        System.out.println( System.currentTimeMillis() - time );", "+        time = System.currentTimeMillis();", "+        ClosestFirstIterator cfi = new ClosestFirstIterator(g, g.vertexSet(  ).iterator(  ).next());", "+        while (cfi.hasNext(  )) {", "+            Object v = cfi.next(  );", "+//             System.out.println( v + \" \" + cfi.getSpanningTreeEdge(v));", "+        }", "+        System.out.println( System.currentTimeMillis() - time );", "+        time = System.currentTimeMillis();", "-        System.out.println( uncovered.size(  ) );", "-        System.out.println( uncovered );"]}]}