{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d2b42ccfd1b1d6fa4f19d31a264f4934", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1899b573046c5b02f1ca50fff4d745c8", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/graph/AbstractGraph.java", "commitBeforeChange": "8413c0621739087aaa2597f10b6a867735224f2d", "commitAfterChange": "39b789d7e41c82b46b5b0099b4e021514410c6a5", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "     public boolean equals(Object object)", "signatureAfterChange": "     public boolean equals(Object object)", "diff": ["-        if (object == null) return false;", "-        if (!(object instanceof Graph)) return false;", "-        if (getClass() != object.getClass()) return false;", "+        if (object == null || getClass() != object.getClass()) return false;", "+        Set<E> otherEdges = new LinkedHashSet<E>(g.edgeSet());", "+            // first of all we should check that the same vertices are connected in other graph (VK);", "+            V source = getEdgeSource(e);", "+            V target = getEdgeTarget(e);", "+", "+            if (!g.containsEdge(source, target)) return false;", "+", "-                if (!g.containsEdge(getEdgeSource(e), getEdgeTarget(e))) return false;", "-                E edge = g.getEdge(getEdgeSource(e), getEdgeTarget(e)); ", "-                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(edge)) > 10e-7) return false;", "-            } else {", "-                if (!g.containsEdge(e)) return false;", "-                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(e)) > 10e-7) return false;", "-            }", "+                // we also should check if there is any overridden equals() method in hierarchy", "+                // so, users can write their own edge classes as subclasses of DefaultEdge", "+                // with custom implementation of equals() method (VK);", "+                try {", "+                    Method equals = e.getClass().getMethod(\"equals\", new Class<?>[] { Object.class });", "+                    boolean edgeFound = false;", "+                    for (E ee: g.getAllEdges(source, target)) {", "+                        if (!otherEdges.contains(ee)) continue;", "+                        if (equals.getDeclaringClass() != Object.class) {", "+                            if (e.equals(ee)) {", "+                                if (e instanceof DefaultWeightedEdge) {", "+                                    if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(ee)) > 10e-7) return false;", "+                                }", "+                                otherEdges.remove(ee);", "+                                edgeFound = true;", "+                                break;", "+                            }", "+                        } else {", "+                            if (e instanceof DefaultWeightedEdge) {", "+                                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(ee)) < 10e-7) {", "+                                    otherEdges.remove(ee);", "+                                    edgeFound = true;", "+                                    break;", "+                                }", "+                            } else {", "+                                otherEdges.remove(ee);", "+                                edgeFound = true;", "+                                break;", "+                            }", "+                        }", "+                    }", "+                    if (!edgeFound) return false;", "+                } catch (NoSuchMethodException ignored) {", "+                    // should never happens, we always have equals() method (VK);", "+                }", "+            } else if (!otherEdges.remove(e)) return false;", "-        for (E e: g.edgeSet()) {", "-            if (e instanceof IntrusiveEdge) {", "-                if (!containsEdge(g.getEdgeSource(e), g.getEdgeTarget(e))) return false;", "-                E edge = getEdge(g.getEdgeSource(e), g.getEdgeTarget(e)); ", "-                if (Math.abs(g.getEdgeWeight(e) - getEdgeWeight(edge)) > 10e-7) return false;", "-            } else {", "-                if (!containsEdge(e)) return false;", "-                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(e)) > 10e-7) return false;", "-            }", "-        }", "+        // finally, if edges set of the other graph is empty - graphs are equal (VK);", "+        if (!otherEdges.isEmpty()) return false;", "-       return true;", "+        return true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f482ab601d902503e024f328ca847bde", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/StrongConnectivityInspector.java", "commitBeforeChange": "f9fe1a9b0c0422b26e26b94edd9001801984e770", "commitAfterChange": "04b4adb9d61a0a7a990979c19fd44e55accd860f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public List stronglyConnectedSets(  )", "signatureAfterChange": "     public List stronglyConnectedSets(  )", "diff": ["-        LinkedList result = new LinkedList(  );", "+        if( m_stronglyConnectedSets == null ) {", "+            m_verticesToVerticesData =", "+                new HashMap( m_graph.vertexSet(  ).size(  ) );", "+            m_orderedVertices           = new LinkedList(  );", "+            m_stronglyConnectedSets =", "+                new Vector( m_graph.vertexSet(  ).size(  ) );", "-        // calculate discover and finish times", "-        AnalyzingDepthFirstIterator iter =", "-            new AnalyzingDepthFirstIterator( m_graph );", "+            // create VertexData objects for all vertices, store them", "+            Iterator iter = m_graph.vertexSet(  ).iterator(  );", "-        while( iter.hasNext(  ) ) {", "-            iter.next(  );", "+            while( iter.hasNext(  ) ) {", "+                Object vertex = iter.next(  );", "+                m_verticesToVerticesData.put( vertex,", "+                    new VertexData( vertex, false, false ) );", "+            }", "+", "+            // perform the first round of DFS, result is an ordering", "+            // of the vertices by decreasing finishing time", "+            iter = m_verticesToVerticesData.values(  ).iterator(  );", "+", "+            while( iter.hasNext(  ) ) {", "+                VertexData data = (VertexData) iter.next(  );", "+", "+                if( !data.m_discovered ) {", "+                    dfsVisit( m_graph, data, null );", "+                }", "+            }", "+", "+            // calculate inverse graph (i.e. every edge is turned)", "+            DirectedGraph inverseGraph = new DefaultDirectedGraph(  );", "+            GraphHelper.addGraphReversed( inverseGraph, m_graph );", "+", "+            // get ready for next dfs round", "+            resetVertexData(  );", "+", "+            // second dfs round: vertices are considered in decreasing", "+            // finishing time order; every tree found is a strongly", "+            // connected set", "+            iter = m_orderedVertices.iterator(  );", "+", "+            while( iter.hasNext(  ) ) {", "+                VertexData data = (VertexData) iter.next(  );", "+", "+                if( !data.m_discovered ) {", "+                    // new strongly connected set", "+                    Set set = new HashSet(  );", "+                    m_stronglyConnectedSets.add( set );", "+                    dfsVisit( inverseGraph, data, set );", "+                }", "+            }", "+", "+            // clean up for garbage collection", "+            m_graph                      = null;", "+            m_orderedVertices            = null;", "+            m_verticesToVerticesData     = null;", "-        Map verticesData = iter.getVerticesData(  );", "+        return m_stronglyConnectedSets;", "+    }", "-        // create inverted graph", "-        DirectedGraph invertedGraph = new DefaultDirectedGraph(  );", "-        GraphHelper.addGraphReversed( invertedGraph, m_graph );", "-        // sort vertices in increasing finish time order", "-        VertexData[] orderedVertices =", "-            new VertexData[ verticesData.values(  ).size(  ) ];", "-        verticesData.values(  ).toArray( orderedVertices );", "-        Arrays.sort( orderedVertices, new FinishingTimeComparator(  ) );", "-        // create DepthFirstOrder forest on inverted graph,", "-        // save trees as strongly connected components", "-        HashSet processedVertices = new HashSet(  );", "-        for( int i = 0; i < orderedVertices.length; i++ ) {", "-            VertexData data = orderedVertices[ i ];", "-            // already contained in one of the trees?", "-            if( !processedVertices.contains( data.getVertex(  ) ) ) {", "-                Set                stronglyConnectedComponent = new HashSet(  );", "-                DepthFirstIterator myIter =", "-                    new DepthFirstIterator( invertedGraph, data.getVertex(  ) );", "-", "-                while( myIter.hasNext(  ) ) {", "-                    Object vertex = myIter.next(  );", "-", "-                    if( !processedVertices.contains( vertex ) ) {", "-                        processedVertices.add( vertex );", "-                        stronglyConnectedComponent.add( vertex );", "-                    }", "-                // save tree", "-                result.add( stronglyConnectedComponent );", "-        }", "-", "-        return result;", "-    }"]}]}