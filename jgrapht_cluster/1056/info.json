{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e8fe8aa7a2abca703344274f10d79968", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0bf913dbd2c2452b5d55df108cfaa9eb", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/ext/JGraphModelAdapter.java", "commitBeforeChange": "56c09b98e6df528eeef0b8df9f8d932a1ba40192", "commitAfterChange": "75098fa5c7281c0f169434b46722c0b4e66b3a8c", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 28, "signatureBeforeChange": "         public void graphChanged( GraphModelEvent e )", "signatureAfterChange": "         public void graphChanged( GraphModelEvent e )", "diff": ["-            GraphModelChange change    = e.getChange(  );", "-            Set              jEdges    = new HashSet(  );", "-            Set              jVertices = new HashSet(  );", "+            GraphModelChange change = e.getChange(  );", "+            ", "+            Object[] removedCells = change.getRemoved(  );", "-            Object[]         arrayToProcess = change.getRemoved(  );", "-", "-            if( arrayToProcess != null ) {", "-                filterEdgesAndVertices( arrayToProcess, jEdges, jVertices );", "-", "-                for( Iterator i = jEdges.iterator(  ); i.hasNext(  ); ) {", "-                    org.jgraph.graph.Edge jEdge =", "-                        (org.jgraph.graph.Edge) i.next(  );", "-", "-                    if( !m_jEdgesBeingRemoved.remove( jEdge ) ) {", "-                        removeJGraphEdge( jEdge );", "-                    }", "-                }", "-", "-                for( Iterator i = jVertices.iterator(  ); i.hasNext(  ); ) {", "-                    GraphCell jVertex = (GraphCell) i.next(  );", "-", "-                    if( !m_jVerticesBeingRemoved.remove( jVertex ) ) {", "-                        removeJGraphVertex( jVertex );", "-                    }", "-                }", "-", "-                jEdges.clear(  );", "-                jVertices.clear(  );", "+            if( removedCells != null ) {", "+                handleRemovedEdges( filterEdges( removedCells ) );", "+                handleRemovedVertices( filterVertices( removedCells ) );", "-            arrayToProcess = change.getInserted(  );", "+            Object[] insertedCells = change.getInserted(  );", "-            if( arrayToProcess != null ) {", "-                filterEdgesAndVertices( arrayToProcess, jEdges, jVertices );", "+            if( insertedCells != null ) {", "+                handleInsertedVertices( filterVertices( insertedCells ) );", "+                handleInsertedEdges( filterEdges( insertedCells ) );", "+            }", "+            ", "+            // Now handle edges that became 'dangling' or became connected.  ", "+            Object[] changedCells = change.getChanged(  );", "+            ", "+            if( changedCells != null ) {", "+                handleChangedEdges( filterEdges( changedCells ) );", "+            }", "+        }", "-                for( Iterator i = jVertices.iterator(  ); i.hasNext(  ); ) {", "-                    GraphCell jVertex = (GraphCell) i.next(  );", "-                    if( !m_jVerticesBeingAdded.remove( jVertex ) ) {", "-                        addJGraphVertex( jVertex );", "-                    }", "-                }", "-                for( Iterator i = jEdges.iterator(  ); i.hasNext(  ); ) {", "-                    org.jgraph.graph.Edge jEdge =", "-                        (org.jgraph.graph.Edge) i.next(  );", "-", "-                    if( !m_jEdgesBeingAdded.remove( jEdge ) ) {", "-                        addJGraphEdge( jEdge );", "-                    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1a01dab21d852baa745117d25f1f1cd5", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/PrimMinimumSpanningTree.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "      public PrimMinimumSpanningTree(final Graph<V, E> g)", "signatureAfterChange": "            public PrimMinimumSpanningTree(final Graph<V, E> g)", "diff": ["-", "-    public PrimMinimumSpanningTree(final Graph<V, E> g) {", "-", "-        this.minimumSpanningTreeEdgeSet = new HashSet<E>(g.vertexSet().size());", "-", "-        Set<V> unspanned  = new HashSet<V>(g.vertexSet());", "-", "-        while (!unspanned.isEmpty()) {", "-", "-            Iterator<V> ri = unspanned.iterator();", "-", "-            V root = ri.next();", "-", "-            ri.remove();", "-", "-            // Edges crossing the cut C = (S, V \\ S), where S is set of already spanned vertices", "-", "-            PriorityQueue<E> dangling =", "-                new PriorityQueue<E>(", "-                    g.edgeSet().size(),", "-                    new Comparator<E>() {", "-                        @Override", "-                        public int compare(E lop, E rop) {", "-                            return Double.valueOf(g.getEdgeWeight(lop)).compareTo(g.getEdgeWeight(rop));", "-                        }", "-                    }", "-                );", "-", "-            dangling.addAll(g.edgesOf(root));", "-", "-            for (E next; (next = dangling.poll()) != null;) {", "-", "-                V s, t = unspanned.contains(s = g.getEdgeSource(next)) ? s : g.getEdgeTarget(next);", "-", "-                // Decayed edges aren't removed from priority-queue so that having them just ignored", "-                // being encountered through min-max traversal", "-                if (!unspanned.contains(t))", "-                    continue;", "-", "-                this.minimumSpanningTreeEdgeSet.add(next);", "-", "-                unspanned.remove(t);", "-", "-                for (E e : g.edgesOf(t)) {", "-                    if (unspanned.contains(g.getEdgeSource(e).equals(t) ? g.getEdgeTarget(e) : g.getEdgeSource(e)))", "-                        dangling.add(e);", "-                }", "-", "-            }", "-", "-        }", "-", "-        double spanningTreeWeight = 0;", "-        for (E e : minimumSpanningTreeEdgeSet) {", "-            spanningTreeWeight += g.getEdgeWeight(e);", "-        }", "-", "-        this.minimumSpanningTreeTotalWeight = spanningTreeWeight;", "-", "-    }", "+", "+    public PrimMinimumSpanningTree(final Graph<V, E> g)", "+    {", "+        this.minimumSpanningTreeEdgeSet = new HashSet<E>(g.vertexSet().size());", "+", "+        Set<V> unspanned = new HashSet<V>(g.vertexSet());", "+", "+        while (!unspanned.isEmpty()) {", "+            Iterator<V> ri = unspanned.iterator();", "+", "+            V root = ri.next();", "+", "+            ri.remove();", "+", "+            // Edges crossing the cut C = (S, V \\ S), where S is set of", "+            // already spanned vertices", "+", "+            PriorityQueue<E> dangling =", "+                new PriorityQueue<E>(", "+                    g.edgeSet().size(),", "+                    new Comparator<E>() {", "+                        @Override public int compare(E lop, E rop)", "+                        {", "+                            return Double.valueOf(g.getEdgeWeight(lop))", "+                                .compareTo(g.getEdgeWeight(rop));", "+                        }", "+                    });", "+", "+            dangling.addAll(g.edgesOf(root));", "+", "+            for (E next; (next = dangling.poll()) != null;) {", "+                V s,", "+                    t =", "+                        unspanned.contains(s = g.getEdgeSource(next)) ? s", "+                        : g.getEdgeTarget(next);", "+", "+                // Decayed edges aren't removed from priority-queue so that", "+                // having them just ignored being encountered through min-max", "+                // traversal", "+                if (!unspanned.contains(t)) {", "+                    continue;", "+                }", "+", "+                this.minimumSpanningTreeEdgeSet.add(next);", "+", "+                unspanned.remove(t);", "+", "+                for (E e : g.edgesOf(t)) {", "+                    if (unspanned.contains(", "+                            g.getEdgeSource(e).equals(t) ? g.getEdgeTarget(", "+                                e)", "+                            : g.getEdgeSource(e)))", "+                    {", "+                        dangling.add(e);", "+                    }", "+                }", "+            }", "+        }", "+", "+        double spanningTreeWeight = 0;", "+        for (E e : minimumSpanningTreeEdgeSet) {", "+            spanningTreeWeight += g.getEdgeWeight(e);", "+        }", "+", "+        this.minimumSpanningTreeTotalWeight = spanningTreeWeight;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35fbff8be0e44836e3227d8a8a1685db", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/util/equivalence/EquivalenceSetCreator.java", "commitBeforeChange": "dd14e683f649f6134a6a191da9a4899af88c4041", "commitAfterChange": "b4805f5d86b128879dfab0c1dd754e481a6373b2", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "     private static HashMap createEqualityGroupMap(         Object [] aElementsArray,         EquivalenceComparator aEqComparator,         Object aComparatorContext)", "signatureAfterChange": "     private static <EE, CC> HashMap<Integer,List<EquivalenceSet<? super EE,? super CC>>> createEqualityGroupMap(         Collection<EE> elements,         EquivalenceComparator<? super EE,? super CC> aEqComparator,         CC aComparatorContext)", "diff": ["-    private static HashMap createEqualityGroupMap(", "-        Object [] aElementsArray,", "-        EquivalenceComparator aEqComparator,", "-        Object aComparatorContext)", "+    private static <EE, CC> HashMap<Integer,List<EquivalenceSet<? super EE,? super CC>>> createEqualityGroupMap(", "+        Collection<EE> elements,", "+        EquivalenceComparator<? super EE,? super CC> aEqComparator,", "+        CC aComparatorContext)", "-        HashMap equalityGroupMap = new HashMap(aElementsArray.length);", "+        HashMap<Integer,List<EquivalenceSet<? super EE,? super CC>>> equalityGroupMap =", "+            new HashMap<Integer,List<EquivalenceSet<? super EE,? super CC>>>(elements.size());", "-        for (int i = 0; i < aElementsArray.length; i++) {", "+        for( EE curentElement : elements ) {", "-                aEqComparator.equivalenceHashcode(", "-                    aElementsArray[i],", "-                    aComparatorContext);", "-            Object mapValue = equalityGroupMap.get(Integer.valueOf(hashcode));", "+                aEqComparator.equivalenceHashcode( curentElement,", "+                                                   aComparatorContext);", "+            List<EquivalenceSet<? super EE,? super CC>> list =", "+                equalityGroupMap.get(Integer.valueOf(hashcode));", "-            // EquivalenceSet(there", "-            // is one already with that hash) , or a list of EquivalenceSet", "-            if (mapValue == null) {", "-                // create list with one elemnt in it", "-                List list = new LinkedList();", "-                list.add(new EquivalenceSet(", "-                        aElementsArray[i],", "+            // or a list of EquivalenceSet", "+", "+            if (list == null) {", "+                // create list with one element in it", "+                list = new LinkedList<EquivalenceSet<? super EE,? super CC>>();", "+                list.add(new EquivalenceSet<EE,CC>(", "+                        curentElement,", "-            } else if (mapValue instanceof List) {", "-                List list = (List) mapValue;", "+            } else {", "-                for (Iterator iter = list.iterator(); iter.hasNext();) {", "-                    EquivalenceSet eqGroup = (EquivalenceSet) iter.next();", "+                for (EquivalenceSet<? super EE,? super CC> eqGroup : list) {", "-                            aElementsArray[i],", "+                            curentElement,", "-                        eqGroup.add(aElementsArray[i]);", "+                        eqGroup.add(curentElement);", "-                    list.add(new EquivalenceSet(", "-                            aElementsArray[i],", "+                    list.add(new EquivalenceSet<EE,CC>(", "+                            curentElement,", "-            } else {", "-                throw new RuntimeException(", "-                    \"The equalityGroupMap value may only be null or List\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "888deeb8012bcb8b8eab93bb740fe6c7", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/StrongConnectivityInspector.java", "commitBeforeChange": "04b4adb9d61a0a7a990979c19fd44e55accd860f", "commitAfterChange": "ccbda858621a3d1beb6a9381a0fc81c3673ee66c", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public List stronglyConnectedSets(  )", "signatureAfterChange": "     public List stronglyConnectedSets()", "diff": ["-    public List stronglyConnectedSets(  ) {", "-        if( m_stronglyConnectedSets == null ) {", "-            m_verticesToVerticesData =", "-                new HashMap( m_graph.vertexSet(  ).size(  ) );", "-            m_orderedVertices           = new LinkedList(  );", "-            m_stronglyConnectedSets =", "-                new Vector( m_graph.vertexSet(  ).size(  ) );", "+    public List stronglyConnectedSets() {", "+        if (m_stronglyConnectedSets == null) {", "+", "+            m_orderedVertices = new LinkedList();", "+            m_stronglyConnectedSets = new Vector();", "-            Iterator iter = m_graph.vertexSet(  ).iterator(  );", "-", "-            while( iter.hasNext(  ) ) {", "-                Object vertex = iter.next(  );", "-                m_verticesToVerticesData.put( vertex,", "-                    new VertexData( vertex, false, false ) );", "-            }", "+            createVertexData();", "-            iter = m_verticesToVerticesData.values(  ).iterator(  );", "+            Iterator iter = m_vertexToVertexData.values().iterator();", "-            while( iter.hasNext(  ) ) {", "-                VertexData data = (VertexData) iter.next(  );", "+            while (iter.hasNext()) {", "+                VertexData data = (VertexData) iter.next();", "-                if( !data.m_discovered ) {", "-                    dfsVisit( m_graph, data, null );", "+                if (!data.m_discovered) {", "+                    dfsVisit(m_graph, data, null);", "-            // calculate inverse graph (i.e. every edge is turned)", "-            DirectedGraph inverseGraph = new DefaultDirectedGraph(  );", "-            GraphHelper.addGraphReversed( inverseGraph, m_graph );", "+            // calculate inverse graph (i.e. every edge is reversed)", "+            DirectedGraph inverseGraph = new DefaultDirectedGraph();", "+            GraphHelper.addGraphReversed(inverseGraph, m_graph);", "-            resetVertexData(  );", "+            resetVertexData();", "-            iter = m_orderedVertices.iterator(  );", "+            iter = m_orderedVertices.iterator();", "-            while( iter.hasNext(  ) ) {", "-                VertexData data = (VertexData) iter.next(  );", "+            while (iter.hasNext()) {", "+                VertexData data = (VertexData) iter.next();", "-                if( !data.m_discovered ) {", "+                if (!data.m_discovered) {", "-                    Set set = new HashSet(  );", "-                    m_stronglyConnectedSets.add( set );", "-                    dfsVisit( inverseGraph, data, set );", "+                    Set set = new HashSet();", "+                    m_stronglyConnectedSets.add(set);", "+                    dfsVisit(inverseGraph, data, set);", "-            m_graph                      = null;", "-            m_orderedVertices            = null;", "-            m_verticesToVerticesData     = null;", "+            m_orderedVertices = null;", "+            m_vertexToVertexData = null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "88df1842f4148602cf4c6ff88fb764cb", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/alg/DijkstraAlgorithm.java", "commitBeforeChange": "ede00ba6ca48a7a81231a62519a30fabb26ae338", "commitAfterChange": "f63e1142cae73862c9c4f7b6ce46225b40f3ef86", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public final WeightedGraph optimumPathTree(Object from)", "signatureAfterChange": "     public final WeightedGraph optimumPathTree( Object from )", "diff": ["-    */", "-    public final WeightedGraph optimumPathTree(Object from) {", "+     */", "+    public final WeightedGraph optimumPathTree( Object from ) {", "-        if (_directed) {", "-            optimumPathTree = new SimpleDirectedWeightedGraph();", "-        } else {", "-            optimumPathTree = new SimpleWeightedGraph();", "+", "+        if( _directed ) {", "+            optimumPathTree = new SimpleDirectedWeightedGraph(  );", "-        _heap.clear();", "-        _heapVertices.clear();", "-        for (Iterator it = _wgraph.vertexSet().iterator(); it.hasNext();) {", "-            Object vertex = it.next();", "-            HeapVertex heapV;", "-            if (vertex instanceof HeapVertex) {", "-                heapV = (HeapVertex)vertex;", "-            } else {", "-                heapV = new HeapVertex(vertex);", "-                _heapVertices.put(vertex, heapV);", "-            }", "-            if (vertex == from) {", "-                heapV.setPriority(_compare > 0 ? 0 : Double.POSITIVE_INFINITY);", "-            } else {", "-                heapV.setPriority(_compare * Double.POSITIVE_INFINITY);", "-            }", "-            _heap.add(heapV);", "+        else {", "+            optimumPathTree = new SimpleWeightedGraph(  );", "-        while (!_heap.isEmpty()) {", "-            HeapVertex hv = heapVertex(_heap.extractTop());", "-            Object v = hv.getVertex();", "-            Edge treeEdge = (Edge)hv.getAdditional();", "-            if (treeEdge != null) GraphHelper.addEdgeWithVertices(optimumPathTree, treeEdge);", "-            Iterator edges;", "-            if (_directed) {", "-                edges = ((DirectedGraph)_wgraph).outgoingEdgesOf(v).iterator();", "-            } else {", "-                edges = _wgraph.edgesOf(v).iterator();", "+        _heap.clear(  );", "+        _heapVertices.clear(  );", "+", "+        for( Iterator it = _wgraph.vertexSet(  ).iterator(  ); it.hasNext(  ); ) {", "+            Object     vertex = it.next(  );", "+            HeapVertex heapV;", "+", "+            if( vertex instanceof HeapVertex ) {", "+                heapV = (HeapVertex) vertex;", "-            while (edges.hasNext()) {", "-                Edge e = (Edge)edges.next();", "-                HeapVertex u = heapVertex(e.oppositeVertex(v));", "-                double newPrio = priorityFunction(hv.getPriority(), e.getWeight());", "-                if (_compare * (u.getPriority() - newPrio) > 0) {", "-                    u.setPriority(newPrio);", "-                    u.setAdditional(e);", "-                    _heap.update(u);", "+            else {", "+                heapV = new HeapVertex( vertex );", "+                _heapVertices.put( vertex, heapV );", "+            }", "+", "+            if( vertex == from ) {", "+                heapV.setPriority( _compare > 0 ? 0 : Double.POSITIVE_INFINITY );", "+            }", "+            else {", "+                heapV.setPriority( _compare * Double.POSITIVE_INFINITY );", "+            }", "+", "+            _heap.add( heapV );", "+        }", "+", "+        while( !_heap.isEmpty(  ) ) {", "+            HeapVertex hv       = heapVertex( _heap.extractTop(  ) );", "+            Object     v        = hv.getVertex(  );", "+            Edge       treeEdge = (Edge) hv.getAdditional(  );", "+", "+            if( treeEdge != null ) {", "+                GraphHelper.addEdgeWithVertices( optimumPathTree, treeEdge );", "+            }", "+", "+            Iterator edges;", "+", "+            if( _directed ) {", "+                edges =", "+                    ( (DirectedGraph) _wgraph ).outgoingEdgesOf( v ).iterator(  );", "+            }", "+            else {", "+                edges = _wgraph.edgesOf( v ).iterator(  );", "+            }", "+", "+            while( edges.hasNext(  ) ) {", "+                Edge       e       = (Edge) edges.next(  );", "+                HeapVertex u       = heapVertex( e.oppositeVertex( v ) );", "+                double     newPrio =", "+                    priorityFunction( hv.getPriority(  ), e.getWeight(  ) );", "+", "+                if( _compare * ( u.getPriority(  ) - newPrio ) > 0 ) {", "+                    u.setPriority( newPrio );", "+                    u.setAdditional( e );", "+                    _heap.update( u );", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f482ab601d902503e024f328ca847bde", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/StrongConnectivityInspector.java", "commitBeforeChange": "f9fe1a9b0c0422b26e26b94edd9001801984e770", "commitAfterChange": "04b4adb9d61a0a7a990979c19fd44e55accd860f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public List stronglyConnectedSets(  )", "signatureAfterChange": "     public List stronglyConnectedSets(  )", "diff": ["-        LinkedList result = new LinkedList(  );", "+        if( m_stronglyConnectedSets == null ) {", "+            m_verticesToVerticesData =", "+                new HashMap( m_graph.vertexSet(  ).size(  ) );", "+            m_orderedVertices           = new LinkedList(  );", "+            m_stronglyConnectedSets =", "+                new Vector( m_graph.vertexSet(  ).size(  ) );", "-        // calculate discover and finish times", "-        AnalyzingDepthFirstIterator iter =", "-            new AnalyzingDepthFirstIterator( m_graph );", "+            // create VertexData objects for all vertices, store them", "+            Iterator iter = m_graph.vertexSet(  ).iterator(  );", "-        while( iter.hasNext(  ) ) {", "-            iter.next(  );", "+            while( iter.hasNext(  ) ) {", "+                Object vertex = iter.next(  );", "+                m_verticesToVerticesData.put( vertex,", "+                    new VertexData( vertex, false, false ) );", "+            }", "+", "+            // perform the first round of DFS, result is an ordering", "+            // of the vertices by decreasing finishing time", "+            iter = m_verticesToVerticesData.values(  ).iterator(  );", "+", "+            while( iter.hasNext(  ) ) {", "+                VertexData data = (VertexData) iter.next(  );", "+", "+                if( !data.m_discovered ) {", "+                    dfsVisit( m_graph, data, null );", "+                }", "+            }", "+", "+            // calculate inverse graph (i.e. every edge is turned)", "+            DirectedGraph inverseGraph = new DefaultDirectedGraph(  );", "+            GraphHelper.addGraphReversed( inverseGraph, m_graph );", "+", "+            // get ready for next dfs round", "+            resetVertexData(  );", "+", "+            // second dfs round: vertices are considered in decreasing", "+            // finishing time order; every tree found is a strongly", "+            // connected set", "+            iter = m_orderedVertices.iterator(  );", "+", "+            while( iter.hasNext(  ) ) {", "+                VertexData data = (VertexData) iter.next(  );", "+", "+                if( !data.m_discovered ) {", "+                    // new strongly connected set", "+                    Set set = new HashSet(  );", "+                    m_stronglyConnectedSets.add( set );", "+                    dfsVisit( inverseGraph, data, set );", "+                }", "+            }", "+", "+            // clean up for garbage collection", "+            m_graph                      = null;", "+            m_orderedVertices            = null;", "+            m_verticesToVerticesData     = null;", "-        Map verticesData = iter.getVerticesData(  );", "+        return m_stronglyConnectedSets;", "+    }", "-        // create inverted graph", "-        DirectedGraph invertedGraph = new DefaultDirectedGraph(  );", "-        GraphHelper.addGraphReversed( invertedGraph, m_graph );", "-        // sort vertices in increasing finish time order", "-        VertexData[] orderedVertices =", "-            new VertexData[ verticesData.values(  ).size(  ) ];", "-        verticesData.values(  ).toArray( orderedVertices );", "-        Arrays.sort( orderedVertices, new FinishingTimeComparator(  ) );", "-        // create DepthFirstOrder forest on inverted graph,", "-        // save trees as strongly connected components", "-        HashSet processedVertices = new HashSet(  );", "-        for( int i = 0; i < orderedVertices.length; i++ ) {", "-            VertexData data = orderedVertices[ i ];", "-            // already contained in one of the trees?", "-            if( !processedVertices.contains( data.getVertex(  ) ) ) {", "-                Set                stronglyConnectedComponent = new HashSet(  );", "-                DepthFirstIterator myIter =", "-                    new DepthFirstIterator( invertedGraph, data.getVertex(  ) );", "-", "-                while( myIter.hasNext(  ) ) {", "-                    Object vertex = myIter.next(  );", "-", "-                    if( !processedVertices.contains( vertex ) ) {", "-                        processedVertices.add( vertex );", "-                        stronglyConnectedComponent.add( vertex );", "-                    }", "-                // save tree", "-                result.add( stronglyConnectedComponent );", "-        }", "-", "-        return result;", "-    }"]}]}