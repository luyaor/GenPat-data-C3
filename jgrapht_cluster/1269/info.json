{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9338b487054ffdc9f28a0877352b0bbd", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4ef9e3b8c332851575928af72673b1e6", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/TransitiveReduction.java", "commitBeforeChange": "dc598aeea99bdfe17df08d02612a83157bf58529", "commitAfterChange": "8c43a5a1403dca2041b43ee00856b56c5e3d4dc0", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": "      public void reduce()", "signatureAfterChange": "     public void reduce(final DirectedGraph<V, E> directedGraph)", "diff": ["-    public void reduce() {", "-        ", "-        int n = pathMatrix.length;", "-        int[][] transitivelyReducedMatrix = new int[n][n];", "-        System.arraycopy(pathMatrix, 0, transitivelyReducedMatrix, 0, pathMatrix.length);", "+     */", "+    public void reduce(final DirectedGraph<V, E> directedGraph) {", "+", "+        final List<V> vertices = new ArrayList<V>(directedGraph.vertexSet());", "+", "+        final int n = vertices.size();", "+", "+        BitSet[] originalMatrix = new BitSet[n];", "+        for (int i = 0; i < originalMatrix.length; i++) {", "+            originalMatrix[i] = new BitSet(n);", "+        }", "+", "+        // initialize matrix with zeros", "+        // 'By default, all bits in the set initially have the value false.'", "+        // cf. http://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html", "+", "+        // initialize matrix with edges", "+        final Set<E> edges = directedGraph.edgeSet();", "+        for (final E edge : edges) {", "+            final V v1 = directedGraph.getEdgeSource(edge);", "+            final V v2 = directedGraph.getEdgeTarget(edge);", "+", "+            final int v_1 = vertices.indexOf(v1);", "+            final int v_2 = vertices.indexOf(v2);", "+", "+            originalMatrix[v_1].set(v_2);", "+        }", "+", "+        // create path matrix from original matrix", "+        final BitSet[] pathMatrix = originalMatrix;", "+", "+        transformToPathMatrix(pathMatrix);", "+", "+        // create reduced matrix from path matrix", "+        final BitSet[] transitivelyReducedMatrix = pathMatrix;", "+", "-        ", "-        for (int i = 0; i <n; i++) {", "-            for (int j = 0; j < n; j++) { ", "-                if (transitivelyReducedMatrix[i][j] == 0) {", "-                    // System.out.println(\"removing \"+vertices.get(i)+\" -> \"+vertices.get(j));", "-                    graph.removeEdge(graph.getEdge(vertices.get(i), vertices.get(j)));", "+", "+        // remove edges from the DirectedGraph which are not in the reduced", "+        // matrix", "+        for (int i = 0; i < n; i++) {", "+            for (int j = 0; j < n; j++) {", "+                if (!transitivelyReducedMatrix[i].get(j)) {", "+                    directedGraph.removeEdge(directedGraph.getEdge(vertices.get(i), vertices.get(j)));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8848baa151415d3ecccebba49fa6e3db", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/StrongConnectivityInspector.java", "commitBeforeChange": "04b4adb9d61a0a7a990979c19fd44e55accd860f", "commitAfterChange": "ccbda858621a3d1beb6a9381a0fc81c3673ee66c", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": "     private void dfsVisit( DirectedGraph graph, VertexData vertexData,         Set vertices )", "signatureAfterChange": "     private void dfsVisit(DirectedGraph graph, VertexData vertexData,             Set vertices)", "diff": ["-    private void dfsVisit( DirectedGraph graph, VertexData vertexData,", "-        Set vertices ) {", "-        Stack stack = new Stack(  );", "-        stack.push( vertexData );", "+    private void dfsVisit(DirectedGraph graph, VertexData vertexData,", "+            Set vertices) {", "+        Stack stack = new Stack();", "+        stack.push(vertexData);", "-        while( !stack.isEmpty(  ) ) {", "-            VertexData data = (VertexData) stack.pop(  );", "+        while (!stack.isEmpty()) {", "+            VertexData data = (VertexData) stack.pop();", "-            if( !data.m_discovered ) {", "+            if (!data.m_discovered) {", "-                if( vertices != null ) {", "-                    vertices.add( data.m_vertex );", "+                if (vertices != null) {", "+                    vertices.add(data.m_vertex);", "-                stack.push( new VertexData( data, true, true ) );", "+                stack.push(new VertexData(data, true, true));", "-                Iterator iter =", "-                    graph.outgoingEdgesOf( data.m_vertex ).iterator(  );", "+                Iterator iter = graph.outgoingEdgesOf(data.m_vertex).iterator();", "-                while( iter.hasNext(  ) ) {", "-                    DirectedEdge edge       = (DirectedEdge) iter.next(  );", "-                    VertexData   targetData =", "-                        (VertexData) m_verticesToVerticesData.get( edge", "-                            .getTarget(  ) );", "+                while (iter.hasNext()) {", "+                    DirectedEdge edge = (DirectedEdge) iter.next();", "+                    VertexData targetData = (VertexData) m_vertexToVertexData", "+                            .get(edge.getTarget());", "-                    if( !targetData.m_discovered ) {", "+                    if (!targetData.m_discovered) {", "-                        stack.push( targetData );", "+                        stack.push(targetData);", "-            }", "-            else if( data.m_finished ) {", "-                if( vertices == null ) {", "+            } else if (data.m_finished) {", "+                if (vertices == null) {", "-                    m_orderedVertices.addFirst( data.m_vertex );", "+                    m_orderedVertices.addFirst(data.m_vertex);"]}]}