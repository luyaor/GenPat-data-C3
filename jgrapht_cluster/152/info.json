{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c7774f9678bc07c884dc875f5803dcaf", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60bc51eb0e0e5bd881e0c3949b88500f", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/graph/DefaultGraphMapping.java", "commitBeforeChange": "857bf50cc4b146a4020c6dc6b730687dfcd7de35", "commitAfterChange": "3358959abc414f2281c71486c6c1a90935b1e909", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     protected Object getCorrespondenceVertex(         Object keyVertex,         boolean forward)", "signatureAfterChange": "      public V getVertexCorrespondence(         V keyVertex,         boolean forward)", "diff": ["-     */", "-    protected Object getCorrespondenceVertex(", "-        Object keyVertex,", "+    public V getVertexCorrespondence(", "+        V keyVertex,", "-        Graph sourceGraph;", "-        int direction;", "-        Object resultObject = null;", "-", "-        if (keyVertex == null) {", "-            throw new NullPointerException(", "-                \"keyVertex parameter may not be null!\");", "-        }", "+        Map<V,V> graphMapping;", "-            sourceGraph = this.graph1;", "-            direction = FORWARD;", "+            graphMapping = graphMappingForward;", "-            sourceGraph = this.graph2;", "-            direction = REVERSE;", "+            graphMapping = graphMappingReverse;", "-        if (!sourceGraph.containsVertex(keyVertex)) {", "-            throw new IllegalArgumentException(", "-                \"The vertex cannot be found in the source graph\");", "-        } else if (!this.graphMapping[direction].containsKey(keyVertex)) {", "-            throw new IllegalArgumentException(", "-                \"The vertex cannot be found in the mapping\");", "-        } else {", "-            resultObject = this.graphMapping[direction].get(keyVertex);", "-        }", "-        return resultObject;", "+        return graphMapping.get(keyVertex);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66ed31445b07f4b7b597fa7a3b33b541", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/AbstractPathElementList.java", "commitBeforeChange": "94e0b9cdbd464a6b60ddbb8cd6d473a32e102eaf", "commitAfterChange": "90d794caa7b37ed092890eb859473902af3157bc", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 1, "signatureBeforeChange": "     protected AbstractPathElementList(         Graph<V, E> graph,         int maxSize,         T pathElement)", "signatureAfterChange": "     protected AbstractPathElementList(         Graph<V, E> graph,         int maxSize,         T pathElement)", "diff": ["-     */", "-    protected AbstractPathElementList(", "-        Graph<V, E> graph,", "-        int maxSize,", "-        T pathElement)", "-    {", "-        if (maxSize <= 0) {", "-            throw new IllegalArgumentException(\"maxSize is negative or 0\");", "-        }", "-        if (pathElement == null) {", "-            throw new NullPointerException(\"pathElement is null\");", "-        }", "-", "-        this.graph = graph;", "-        this.maxSize = maxSize;", "-        this.vertex = pathElement.getVertex();", "-", "-        this.pathElements.add(pathElement);", "-    }", "+    protected AbstractPathElementList(", "+        Graph<V, E> graph,", "+        int maxSize,", "+        T pathElement)", "+        if (maxSize <= 0) {", "+            throw new IllegalArgumentException(\"maxSize is negative or 0\");", "+        }", "+        if (pathElement == null) {", "+            throw new NullPointerException(\"pathElement is null\");", "+        }", "+        if (pathElement.getPrevEdge() != null) {", "+            throw new IllegalArgumentException(\"path must be empty\");", "+        }", "+", "+        this.graph = graph;", "+        this.maxSize = maxSize;", "+        this.vertex = pathElement.getVertex();", "+", "+        this.pathElements.add(pathElement);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f179429d4ad60a425412e308ca61a375", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/KShortestPathsIterator.java", "commitBeforeChange": "94e0b9cdbd464a6b60ddbb8cd6d473a32e102eaf", "commitAfterChange": "90d794caa7b37ed092890eb859473902af3157bc", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 9, "signatureBeforeChange": "      private void savePassData(Set<V> improvedVertices)", "signatureAfterChange": "      private void savePassData(Set<V> improvedVertices)", "diff": ["-            RankingPathElementList<V, E> clonedData =", "+            RankingPathElementList<V, E> pathElementList =", "+                this.seenDataContainer.get(vertex);", "+", "+            RankingPathElementList<V, E> improvedPaths =", "-                    this.seenDataContainer.get(vertex));", "-            this.prevSeenDataContainer.put(vertex, clonedData);", "+                    this.graph,", "+                    pathElementList.maxSize,", "+                    vertex);", "+", "+            for (", "+                Iterator<RankingPathElement<V, E>> pathIter =", "+                    pathElementList.iterator();", "+                pathIter.hasNext();)", "+            {", "+                RankingPathElement<V, E> path = pathIter.next();", "+                if (path.getHopCount() == this.passNumber) {", "+                    // the path has just been computed.", "+                    improvedPaths.pathElements.add(path);", "+                }", "+            }", "+", "+            this.prevSeenDataContainer.put(vertex, improvedPaths);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f9cb0c88caf6345cc5bc6957d76dcd35", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/RankingPathElementList.java", "commitBeforeChange": "9891701e497d82d53bd2f7288493ff266ebc25b7", "commitAfterChange": "d3ef70f973371a0a14daeb6ea1ebefb2fcfefa11", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     RankingPathElementList(         Graph<V, E> graph,         int maxSize,         RankingPathElementList<V, E> elementList,         E edge,         V guardVertexToNotDisconnect)", "signatureAfterChange": "     RankingPathElementList(         Graph<V, E> graph,         int maxSize,         RankingPathElementList<V, E> elementList,         E edge,         V guardVertexToNotDisconnect)", "diff": ["-        for (int i = 0; i < elementList.size(); i++) {", "+        for (int i = 0;", "+             (i < elementList.size()) && (size() < maxSize); i++)", "+        {", "+                // go to the next path element in the loop", "-            if (size() < this.maxSize) {", "-                double weight = calculatePathWeight(prevPathElement, edge);", "-                RankingPathElement<V, E> newPathElement =", "-                    new RankingPathElement<V, E>(", "-                        this.graph,", "-                        prevPathElement,", "-                        edge,", "-                        weight);", "+            double weight = calculatePathWeight(prevPathElement, edge);", "+            RankingPathElement<V, E> newPathElement =", "+                new RankingPathElement<V, E>(", "+                    this.graph,", "+                    prevPathElement,", "+                    edge,", "+                    weight);", "-                // the new path is inserted at the end of the list.", "-                this.pathElements.add(newPathElement);", "-            }", "+            // the new path is inserted at the end of the list.", "+            this.pathElements.add(newPathElement);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc72ed8862838a0d63c5d2e1a83082a3", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/KuhnMunkresMinimalWeightBipartitePerfectMatching.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public KuhnMunkresMinimalWeightBipartitePerfectMatching(         final WeightedGraph<V, E> G,         List<? extends V> S,         List<? extends V> T)", "signatureAfterChange": "     public KuhnMunkresMinimalWeightBipartitePerfectMatching(         final WeightedGraph<V, E> G,         List<? extends V> S,         List<? extends V> T)", "diff": ["-        List<? extends V> T) {", "-", "+        List<? extends V> T)", "+    {", "-        if (S.size() != T.size())", "-          throw new IllegalArgumentException(\"Graph supplied isn't complete bipartite with equally sized partitions!\");", "+        if (S.size() != T.size()) {", "+            throw new IllegalArgumentException(", "+                \"Graph supplied isn't complete bipartite with equally sized partitions!\");", "+        }", "-        int partition   = S.size(),", "-            edges       = G.edgeSet().size();", "+        int partition = S.size(), edges = G.edgeSet().size();", "-        if (edges != partition * partition)", "-          throw new IllegalArgumentException(\"Graph supplied isn't complete bipartite with equally sized partitions!\");", "+        if (edges != (partition * partition)) {", "+            throw new IllegalArgumentException(", "+                \"Graph supplied isn't complete bipartite with equally sized partitions!\");", "+        }", "-        graph           = G;", "-        firstPartition  = S;", "+        graph = G;", "+        firstPartition = S;", "-        matching = new KuhnMunkresMatrixImplementation<V, E>(G, S, T).buildMatching();", "-", "+        matching =", "+            new KuhnMunkresMatrixImplementation<V, E>(G, S, T).buildMatching();"]}]}