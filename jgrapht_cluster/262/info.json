{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "141406f38f772001cede7fa80cf02b44", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0278672186aaf203e9417a0bbd0f8b69", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/VF2AbstractIsomorphismInspector.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public VF2AbstractIsomorphismInspector(             Graph<V, E> graph1,             Graph<V, E> graph2,             Comparator<V> vertexComparator,             Comparator<E> edgeComparator,             boolean cacheEdges)", "signatureAfterChange": "     public VF2AbstractIsomorphismInspector(         Graph<V, E> graph1,         Graph<V, E> graph2,         Comparator<V> vertexComparator,         Comparator<E> edgeComparator,         boolean cacheEdges)", "diff": ["-            Graph<V, E> graph1,", "-            Graph<V, E> graph2,", "-            Comparator<V> vertexComparator,", "-            Comparator<E> edgeComparator,", "-            boolean cacheEdges)", "+        Graph<V, E> graph1,", "+        Graph<V, E> graph2,", "+        Comparator<V> vertexComparator,", "+        Comparator<E> edgeComparator,", "+        boolean cacheEdges)", "-        if (graph1 instanceof Multigraph  || graph2 instanceof Multigraph ||", "-            graph1 instanceof Pseudograph || graph2 instanceof Pseudograph ||", "-            graph1 instanceof DirectedMultigraph ||", "-            graph2 instanceof DirectedMultigraph ||", "-            graph1 instanceof DirectedPseudograph ||", "-            graph2 instanceof DirectedPseudograph)", "-            throw new UnsupportedOperationException(\"graphs with multiple \"", "-                            + \"edges are not supported\");", "+        if ((graph1 instanceof Multigraph)", "+            || (graph2 instanceof Multigraph)", "+            || (graph1 instanceof Pseudograph)", "+            || (graph2 instanceof Pseudograph)", "+            || (graph1 instanceof DirectedMultigraph)", "+            || (graph2 instanceof DirectedMultigraph)", "+            || (graph1 instanceof DirectedPseudograph)", "+            || (graph2 instanceof DirectedPseudograph))", "+        {", "+            throw new UnsupportedOperationException(", "+                \"graphs with multiple \"", "+                + \"edges are not supported\");", "+        }", "-        if (graph1 instanceof DirectedGraph &&", "-                        graph2 instanceof UndirectedGraph ||", "-            graph1 instanceof UndirectedGraph &&", "-                        graph2 instanceof DirectedGraph)", "-            throw new IllegalArgumentException(\"can not match directed with \"", "-                            + \"undirected graphs\");", "+        if (((graph1 instanceof DirectedGraph)", "+                && (graph2 instanceof UndirectedGraph))", "+            || ((graph1 instanceof UndirectedGraph)", "+                && (graph2 instanceof DirectedGraph)))", "+        {", "+            throw new IllegalArgumentException(", "+                \"can not match directed with \"", "+                + \"undirected graphs\");", "+        }", "-        this.graph1           = graph1;", "-        this.graph2           = graph2;", "+        this.graph1 = graph1;", "+        this.graph2 = graph2;", "-        this.edgeComparator   = edgeComparator;", "-        this.ordering1        = new GraphOrdering<V, E>(graph1, true,", "-                                                        cacheEdges);", "-        this.ordering2        = new GraphOrdering<V, E>(graph2, true,", "-                                                        cacheEdges);", "+        this.edgeComparator = edgeComparator;", "+        this.ordering1 = new GraphOrdering<V, E>(graph1, true,", "+            cacheEdges);", "+        this.ordering2 = new GraphOrdering<V, E>(graph2, true,", "+            cacheEdges);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "107f4af5594c50ebe231de21379615a5", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/experimental/alg/color/GreedyColoring.java", "commitBeforeChange": "e601cce570393b1ad5c879b58ec483ca42a9532b", "commitAfterChange": "df9e52ba034eea98b94d0b6e1470ce50769bc1ce", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "      int[] largestSaturationFirstOrder()", "signatureAfterChange": "      int [] largestSaturationFirstOrder()", "diff": ["-    int[] largestSaturationFirstOrder() {", "-        final int[] order = new int[_neighbors.length]; // could be removed since buckets contains order reversed", "-        final int[] satur = new int[_neighbors.length];", "-        final int[] buckets = new int[_neighbors.length];", "-        final int[] cumBucketSize = new int[_neighbors.length];", "-        final int[] bucketIndex = new int[_neighbors.length];", "+    int [] largestSaturationFirstOrder()", "+    {", "+        final int [] order = new int[_neighbors.length]; // could be removed", "+                                                         // since buckets", "+                                                         // contains order", "+                                                         // reversed", "+        final int [] satur = new int[_neighbors.length];", "+        final int [] buckets = new int[_neighbors.length];", "+        final int [] cumBucketSize = new int[_neighbors.length];", "+        final int [] bucketIndex = new int[_neighbors.length];", "-            while (maxSat > 0 && cumBucketSize[maxSat] == cumBucketSize[maxSat-1]) {", "+            while (", "+                (maxSat > 0)", "+                && (cumBucketSize[maxSat] == cumBucketSize[maxSat - 1]))", "+            {", "-                final int nb = (int)_neighbors[v][j];", "+                final int nb = (int) _neighbors[v][j];", "-                    if (bi != cumBucketSize[satur[nb]]-1) {", "-                        buckets[bi] = buckets[cumBucketSize[satur[nb]]-1];", "-                        buckets[cumBucketSize[satur[nb]]-1] = nb;", "-                        bucketIndex[nb] = cumBucketSize[satur[nb]]-1;", "+                    if (bi != (cumBucketSize[satur[nb]] - 1)) {", "+                        buckets[bi] = buckets[cumBucketSize[satur[nb]] - 1];", "+                        buckets[cumBucketSize[satur[nb]] - 1] = nb;", "+                        bucketIndex[nb] = cumBucketSize[satur[nb]] - 1;", "-                    if (cumBucketSize[satur[nb]] == 0) cumBucketSize[satur[nb]] = cumBucketSize[satur[nb]-1]+1;", "-                    if (satur[nb] > maxSat) maxSat = satur[nb];", "+                    if (cumBucketSize[satur[nb]] == 0) {", "+                        cumBucketSize[satur[nb]] =", "+                            cumBucketSize[satur[nb] - 1] + 1;", "+                    }", "+                    if (satur[nb] > maxSat) {", "+                        maxSat = satur[nb];", "+                    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1754cd7eba205de7d18a3ec87214968e", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/heap/HeapVertex.java", "commitBeforeChange": "320f41319eefcc411b999151096f11d4608d80c3", "commitAfterChange": "94cd40aee7737a3929e0568a1e5623a7da828391", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "      public int compareTo(Object o)", "signatureAfterChange": "     public int compareTo( Object o )", "diff": ["-    public int compareTo(Object o) {", "-        HeapVertex other = (HeapVertex)o;", "-        if (other._priority < _priority) return 1;", "-        if (other._priority > _priority) return -1;", "+     */", "+    public int compareTo( Object o ) {", "+        HeapVertex other = (HeapVertex) o;", "+", "+        if( other._priority < _priority ) {", "+            return 1;", "+        }", "+", "+        if( other._priority > _priority ) {", "+            return -1;", "+        }", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1a01dab21d852baa745117d25f1f1cd5", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/PrimMinimumSpanningTree.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "      public PrimMinimumSpanningTree(final Graph<V, E> g)", "signatureAfterChange": "            public PrimMinimumSpanningTree(final Graph<V, E> g)", "diff": ["-", "-    public PrimMinimumSpanningTree(final Graph<V, E> g) {", "-", "-        this.minimumSpanningTreeEdgeSet = new HashSet<E>(g.vertexSet().size());", "-", "-        Set<V> unspanned  = new HashSet<V>(g.vertexSet());", "-", "-        while (!unspanned.isEmpty()) {", "-", "-            Iterator<V> ri = unspanned.iterator();", "-", "-            V root = ri.next();", "-", "-            ri.remove();", "-", "-            // Edges crossing the cut C = (S, V \\ S), where S is set of already spanned vertices", "-", "-            PriorityQueue<E> dangling =", "-                new PriorityQueue<E>(", "-                    g.edgeSet().size(),", "-                    new Comparator<E>() {", "-                        @Override", "-                        public int compare(E lop, E rop) {", "-                            return Double.valueOf(g.getEdgeWeight(lop)).compareTo(g.getEdgeWeight(rop));", "-                        }", "-                    }", "-                );", "-", "-            dangling.addAll(g.edgesOf(root));", "-", "-            for (E next; (next = dangling.poll()) != null;) {", "-", "-                V s, t = unspanned.contains(s = g.getEdgeSource(next)) ? s : g.getEdgeTarget(next);", "-", "-                // Decayed edges aren't removed from priority-queue so that having them just ignored", "-                // being encountered through min-max traversal", "-                if (!unspanned.contains(t))", "-                    continue;", "-", "-                this.minimumSpanningTreeEdgeSet.add(next);", "-", "-                unspanned.remove(t);", "-", "-                for (E e : g.edgesOf(t)) {", "-                    if (unspanned.contains(g.getEdgeSource(e).equals(t) ? g.getEdgeTarget(e) : g.getEdgeSource(e)))", "-                        dangling.add(e);", "-                }", "-", "-            }", "-", "-        }", "-", "-        double spanningTreeWeight = 0;", "-        for (E e : minimumSpanningTreeEdgeSet) {", "-            spanningTreeWeight += g.getEdgeWeight(e);", "-        }", "-", "-        this.minimumSpanningTreeTotalWeight = spanningTreeWeight;", "-", "-    }", "+", "+    public PrimMinimumSpanningTree(final Graph<V, E> g)", "+    {", "+        this.minimumSpanningTreeEdgeSet = new HashSet<E>(g.vertexSet().size());", "+", "+        Set<V> unspanned = new HashSet<V>(g.vertexSet());", "+", "+        while (!unspanned.isEmpty()) {", "+            Iterator<V> ri = unspanned.iterator();", "+", "+            V root = ri.next();", "+", "+            ri.remove();", "+", "+            // Edges crossing the cut C = (S, V \\ S), where S is set of", "+            // already spanned vertices", "+", "+            PriorityQueue<E> dangling =", "+                new PriorityQueue<E>(", "+                    g.edgeSet().size(),", "+                    new Comparator<E>() {", "+                        @Override public int compare(E lop, E rop)", "+                        {", "+                            return Double.valueOf(g.getEdgeWeight(lop))", "+                                .compareTo(g.getEdgeWeight(rop));", "+                        }", "+                    });", "+", "+            dangling.addAll(g.edgesOf(root));", "+", "+            for (E next; (next = dangling.poll()) != null;) {", "+                V s,", "+                    t =", "+                        unspanned.contains(s = g.getEdgeSource(next)) ? s", "+                        : g.getEdgeTarget(next);", "+", "+                // Decayed edges aren't removed from priority-queue so that", "+                // having them just ignored being encountered through min-max", "+                // traversal", "+                if (!unspanned.contains(t)) {", "+                    continue;", "+                }", "+", "+                this.minimumSpanningTreeEdgeSet.add(next);", "+", "+                unspanned.remove(t);", "+", "+                for (E e : g.edgesOf(t)) {", "+                    if (unspanned.contains(", "+                            g.getEdgeSource(e).equals(t) ? g.getEdgeTarget(", "+                                e)", "+                            : g.getEdgeSource(e)))", "+                    {", "+                        dangling.add(e);", "+                    }", "+                }", "+            }", "+        }", "+", "+        double spanningTreeWeight = 0;", "+        for (E e : minimumSpanningTreeEdgeSet) {", "+            spanningTreeWeight += g.getEdgeWeight(e);", "+        }", "+", "+        this.minimumSpanningTreeTotalWeight = spanningTreeWeight;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4382a7aecfec5dea78395b2ec4468a3e", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/ext/GmlExporter.java", "commitBeforeChange": "e601cce570393b1ad5c879b58ec483ca42a9532b", "commitAfterChange": "df9e52ba034eea98b94d0b6e1470ce50769bc1ce", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "      private void export( Writer output, Graph<V,E> g, boolean directed )", "signatureAfterChange": "      private void export(Writer output, Graph<V, E> g, boolean directed)", "diff": ["-    private void export( Writer output, Graph<V,E> g, boolean directed )", "+    private void export(Writer output, Graph<V, E> g, boolean directed)", "-\tPrintWriter out = new PrintWriter(output);", "+        PrintWriter out = new PrintWriter(output);", "-\texportHeader( out );", "-\tout.println( \"graph\" );", "-\tout.println( \"[\" );", "-\tout.println( tab1 + \"label\" + delim + quoted(\"\") );", "-\tif ( directed )", "-\t    out.println( tab1 + \"directed\" + delim + \"1\" );", "-\telse ", "-\t    out.println( tab1 + \"directed\" + delim + \"0\" );", "-\texportVertices( out, nameProvider, g );", "-\texportEdges( out, nameProvider, g );", "-\tout.println( \"]\" );", "+        exportHeader(out);", "+        out.println(\"graph\");", "+        out.println(\"[\");", "+        out.println(tab1 + \"label\" + delim + quoted(\"\"));", "+        if (directed) {", "+            out.println(tab1 + \"directed\" + delim + \"1\");", "+        } else {", "+            out.println(tab1 + \"directed\" + delim + \"0\");", "+        }", "+        exportVertices(out, nameProvider, g);", "+        exportEdges(out, nameProvider, g);", "+        out.println(\"]\");", "-"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a5e65ed6f9a1c1e425382bc5d1b6656", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/generate/SimpleWeightedGraphMatrixGenerator.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      @Override     public void generateGraph(WeightedGraph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)", "signatureAfterChange": "      @Override public void generateGraph(         WeightedGraph<V, E> target,         VertexFactory<V> vertexFactory,         Map<String, V> resultMap)", "diff": ["-    @Override", "-    public void generateGraph(WeightedGraph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap) {", "-", "-      if (weights == null)", "-        throw new IllegalArgumentException(\"Graph may not be constructed without weight-matrix specified\");", "-", "-      if (vertices == null)", "-        throw new IllegalArgumentException(\"Graph may not be constructed without vertex-set specified\");", "-", "-      assert vertices.size() == weights.length;", "-", "-      for (V vertex : vertices) {", "-        target.addVertex(vertex);", "-      }", "-", "-      for (int i=0; i < vertices.size(); ++i) {", "-", "-        assert vertices.size() == weights[i].length;", "-", "-        for (int j=0; j < vertices.size(); ++j) {", "-          if (i != j) {", "-            target.setEdgeWeight(", "-              target.addEdge(vertices.get(i), vertices.get(j)),", "-              weights[i][j]", "-            );", "-          }", "+    @Override public void generateGraph(", "+        WeightedGraph<V, E> target,", "+        VertexFactory<V> vertexFactory,", "+        Map<String, V> resultMap)", "+    {", "+        if (weights == null) {", "+            throw new IllegalArgumentException(", "+                \"Graph may not be constructed without weight-matrix specified\");", "-      }", "+        if (vertices == null) {", "+            throw new IllegalArgumentException(", "+                \"Graph may not be constructed without vertex-set specified\");", "+        }", "+", "+        assert vertices.size() == weights.length;", "+", "+        for (V vertex : vertices) {", "+            target.addVertex(vertex);", "+        }", "+", "+        for (int i = 0; i < vertices.size(); ++i) {", "+            assert vertices.size() == weights[i].length;", "+", "+            for (int j = 0; j < vertices.size(); ++j) {", "+                if (i != j) {", "+                    target.setEdgeWeight(", "+                        target.addEdge(vertices.get(i), vertices.get(j)),", "+                        weights[i][j]);", "+                }", "+            }", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "62ae05424b10c222a76f650e01512c48", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/MinSourceSinkCut.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic Set<E> getCutEdges()", "signatureAfterChange": "     public Set<E> getCutEdges()", "diff": ["-\t */", "-\tpublic Set<E> getCutEdges(){", "-\t\tif(minCut==null)", "-\t\t\treturn null;", "-\t\tSet<E> cutEdges=new HashSet<E>();", "-\t\tfor(V vertex: minCut){", "-\t\t\tfor(E edge: graph.outgoingEdgesOf(vertex)){", "-\t\t\t\tif(!minCut.contains(Graphs.getOppositeVertex(graph, edge, vertex)))", "-\t\t\t\t\tcutEdges.add(edge);", "-\t\t\t}", "-\t\t}", "-\t\treturn Collections.unmodifiableSet(cutEdges);", "-\t}", "+     */", "+    public Set<E> getCutEdges()", "+    {", "+        if (minCut == null) {", "+            return null;", "+        }", "+        Set<E> cutEdges = new HashSet<E>();", "+        for (V vertex : minCut) {", "+            for (E edge : graph.outgoingEdgesOf(vertex)) {", "+                if (!minCut.contains(", "+                        Graphs.getOppositeVertex(graph, edge, vertex)))", "+                {", "+                    cutEdges.add(edge);", "+                }", "+            }", "+        }", "+        return Collections.unmodifiableSet(cutEdges);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7b84dbcca1939acbf33d401deef31733", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "b261cb99c92126b64c9129dbe772684f0da5e234", "commitAfterChange": "22927827f36ad9b2cef7c5f5670c4d2598840023", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "     public GraphPath<V, E> shortestPath(V a, V b)", "signatureAfterChange": "     public GraphPath<V, E> shortestPath(V a, V b)", "diff": ["-    public GraphPath<V, E> shortestPath(V a, V b) {", "-", "-        if (d == null)", "+    public GraphPath<V, E> shortestPath(V a, V b)", "+    {", "+        if (d == null) {", "+        }", "-        if (edges.size() < 1)", "+        if (edges.size() < 1) {", "+        }", "-        GraphPathImpl<V, E> path = new GraphPathImpl<V, E>(graph, a, b, edges, edges.size());", "+        GraphPathImpl<V, E> path =", "+            new GraphPathImpl<V, E>(graph, a, b, edges, edges.size());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8a6c82a21e7ad8e96050672d5fd11aad", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/experimental/GraphTests.java", "commitBeforeChange": "8351950dcc8104326561fbac86d56dbf0db2a035", "commitAfterChange": "2e175b661db8815954cc8d1fa143c72587edb77b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "      public static <V, E> boolean isBipartite(Graph<V,E> g)", "signatureAfterChange": "      public static <V, E> boolean isBipartite(Graph<V, E> g)", "diff": ["-    public static <V, E> boolean isBipartite(Graph<V,E> g)", "+    public static <V, E> boolean isBipartite(Graph<V, E> g)", "-        if ((4 * g.edgeSet().size())", "-            > (g.vertexSet().size() * g.vertexSet().size()))", "+        if (", "+            (4 * g.edgeSet().size())", "+            > (g.vertexSet().size() * g.vertexSet().size())) {", "-        if (isEmpty(g))", "+        }", "+        if (isEmpty(g)) {", "+        }", "-            for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator();", "+            for (", "+                Iterator<V> it = Graphs.neighborListOf(g, v).iterator();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8abe37d24fa55bf231d4445d9ef23901", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "b261cb99c92126b64c9129dbe772684f0da5e234", "commitAfterChange": "22927827f36ad9b2cef7c5f5670c4d2598840023", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "     public int lazyCalculatePaths()", "signatureAfterChange": "     public int lazyCalculatePaths()", "diff": ["-    public int lazyCalculatePaths() {", "-", "+    public int lazyCalculatePaths()", "+    {", "-        if (d == null)", "+        if (d == null) {", "+        }", "-        Map<VertexPair<V>, GraphPath<V, E>> sps = new HashMap<VertexPair<V>, GraphPath<V, E>>();", "+        Map<VertexPair<V>, GraphPath<V, E>> sps =", "+            new HashMap<VertexPair<V>, GraphPath<V, E>>();", "-", "-", "-                if (i == j)", "+                if (i == j) {", "+                }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "926e017a44dbc617c5091f8239525590", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/generate/SimpleWeightedBipartiteGraphMatrixGenerator.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      @Override     public void generateGraph(WeightedGraph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)", "signatureAfterChange": "      @Override public void generateGraph(         WeightedGraph<V, E> target,         VertexFactory<V> vertexFactory,         Map<String, V> resultMap)", "diff": ["-    @Override", "-    public void generateGraph(WeightedGraph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap) {", "-", "-      if (weights == null)", "-        throw new IllegalArgumentException(\"Graph may not be constructed without weight-matrix specified\");", "-", "-      if (first == null || second == null)", "-        throw new IllegalArgumentException(\"Graph may not be constructed without either of vertex-set partitions specified\");", "-", "-      assert second.size() == weights.length;", "-", "-      for (V vertex : first) {", "-        target.addVertex(vertex);", "-      }", "-", "-      for (V vertex : second) {", "-        target.addVertex(vertex);", "-      }", "-", "-      for (int i=0; i < first.size(); ++i) {", "-", "-        assert first.size() == weights[i].length;", "-", "-        for (int j=0; j < second.size(); ++j) {", "-          target.setEdgeWeight(", "-            target.addEdge(first.get(i), second.get(j)),", "-            weights[i][j]", "-          );", "+    @Override public void generateGraph(", "+        WeightedGraph<V, E> target,", "+        VertexFactory<V> vertexFactory,", "+        Map<String, V> resultMap)", "+    {", "+        if (weights == null) {", "+            throw new IllegalArgumentException(", "+                \"Graph may not be constructed without weight-matrix specified\");", "-      }", "+        if ((first == null) || (second == null)) {", "+            throw new IllegalArgumentException(", "+                \"Graph may not be constructed without either of vertex-set partitions specified\");", "+        }", "+", "+        assert second.size() == weights.length;", "+", "+        for (V vertex : first) {", "+            target.addVertex(vertex);", "+        }", "+", "+        for (V vertex : second) {", "+            target.addVertex(vertex);", "+        }", "+", "+        for (int i = 0; i < first.size(); ++i) {", "+            assert first.size() == weights[i].length;", "+", "+            for (int j = 0; j < second.size(); ++j) {", "+                target.setEdgeWeight(", "+                    target.addEdge(first.get(i), second.get(j)),", "+                    weights[i][j]);", "+            }", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "965e96e29067df075ff309a3e01021b0", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/util/UnionFind.java", "commitBeforeChange": "b5348f8a80e818c9b0dd566a68eb23f3eca4389b", "commitAfterChange": "29039f1f20cd2b1397eba3afdb9fc72182dd2062", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public V find(V element)", "signatureAfterChange": "     public V find(V element)", "diff": ["-        if(!parentMap.containsKey(element))", "-            throw new IllegalArgumentException(\"elements must be contained in given set\");", "-        ", "+        if (!parentMap.containsKey(element)) {", "+            throw new IllegalArgumentException(", "+                \"elements must be contained in given set\");", "+        }", "+", "-        if(parent.equals(element))", "+        if (parent.equals(element)) {", "-        ", "+        }", "+", "-        parentMap.put(element,newParent);", "+        parentMap.put(element, newParent);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a0940d33a495dbb7a85b44b6aea4d7e4", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/GraphOrdering.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "     public boolean hasEdge(int v1Number, int v2Number)", "signatureAfterChange": "     public boolean hasEdge(int v1Number, int v2Number)", "diff": ["-    public boolean hasEdge(int v1Number, int v2Number) {", "+    public boolean hasEdge(int v1Number, int v2Number)", "+    {", "-        if (cacheEdges)", "+        if (cacheEdges) {", "+        }", "-        if (!cacheEdges || containsEdge == null) {", "+        if (!cacheEdges || (containsEdge == null)) {", "-        ", "-        if (cacheEdges && adjMatrix[v1Number][v2Number] == null)", "+", "+        if (cacheEdges && (adjMatrix[v1Number][v2Number] == null)) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4d766a66308237cf92af8e486551151", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/graph/AsWeightedGraph.java", "commitBeforeChange": "76d8d52bc063f9cd4364e294dbe191c5648bf05d", "commitAfterChange": "d11cabd1aabdc954107d901bc835dd46e2c5b915", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public double getEdgeWeight(E e)", "signatureAfterChange": "     public double getEdgeWeight(E e)", "diff": ["-    ", "+", "-        if (weightMap.containsKey(e))", "+        if (weightMap.containsKey(e)) {", "-        else", "+        } else {", "+        }", "-    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "de626099269b29f0f50a6d5e32648f4b", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/experimental/GraphTests.java", "commitBeforeChange": "8351950dcc8104326561fbac86d56dbf0db2a035", "commitAfterChange": "2e175b661db8815954cc8d1fa143c72587edb77b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "      public static <V, E> boolean isConnected(Graph<V,E> g)", "signatureAfterChange": "      public static <V, E> boolean isConnected(Graph<V, E> g)", "diff": ["-    public static <V, E> boolean isConnected(Graph<V,E> g)", "+    public static <V, E> boolean isConnected(Graph<V, E> g)", "-        if (numEdges < (numVertices - 1))", "+        if (numEdges < (numVertices - 1)) {", "-        if ((numVertices < 2)", "-            || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2)))", "+        }", "+        if (", "+            (numVertices < 2)", "+            || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {", "+        }", "-            for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator();", "+            for (", "+                Iterator<V> it = Graphs.neighborListOf(g, v).iterator();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e42663dc43afbc6280f587d4856325c1", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/StoerWagnerMinimumCut.java", "commitBeforeChange": "76399a5646342a12a99375b728ce65e0fef58fa7", "commitAfterChange": "836df798105be860e011cc4cc0ecf308ba811d44", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     protected void minimumCutPhase(Set<V> a)", "signatureAfterChange": "     protected void minimumCutPhase(Set<V> a)", "diff": ["-    /** Implements the MinimumCutPhase function of Stoer and Wagner */", "-    protected void minimumCutPhase(Set<V> a){", "-        ", "+     */", "+    protected void minimumCutPhase(Set<V> a)", "+    {", "-        PriorityQueue<VertexAndWeight> queue = new PriorityQueue<VertexAndWeight>();", "-        Map<Set<V>, VertexAndWeight> dmap = new HashMap<Set<V>, VertexAndWeight>();", "-        for(Set<V> v : workingGraph.vertexSet()) {", "-            if( v != a ){", "-                Double w = -workingGraph.getEdgeWeight(workingGraph.getEdge(v, a));", "-                VertexAndWeight vandw = new VertexAndWeight(v,w);", "+        PriorityQueue<VertexAndWeight> queue =", "+            new PriorityQueue<VertexAndWeight>();", "+        Map<Set<V>, VertexAndWeight> dmap =", "+            new HashMap<Set<V>, VertexAndWeight>();", "+        for (Set<V> v : workingGraph.vertexSet()) {", "+            if (v != a) {", "+                Double w =", "+                    -workingGraph.getEdgeWeight(workingGraph.getEdge(v, a));", "+                VertexAndWeight vandw = new VertexAndWeight(v, w);", "-        ", "+", "-        List<Set<V>> list = new ArrayList<Set<V>> (workingGraph.vertexSet().size());", "+        List<Set<V>> list =", "+            new ArrayList<Set<V>>(workingGraph.vertexSet().size());", "-        while(!queue.isEmpty()){", "-            Set<V> v = queue.poll().vertex; ", "-            dmap.remove(v);         ", "+        while (!queue.isEmpty()) {", "+            Set<V> v = queue.poll().vertex;", "+            dmap.remove(v);", "-            for( DefaultWeightedEdge e : workingGraph.edgesOf(v) ){", "+            for (DefaultWeightedEdge e : workingGraph.edgesOf(v)) {", "-                if( v != workingGraph.getEdgeSource(e) ) vc = workingGraph.getEdgeSource(e); ", "-                else vc = workingGraph.getEdgeTarget(e);", "-                if(dmap.get(vc) != null){", "-                    Double neww = - workingGraph.getEdgeWeight(workingGraph.getEdge(v, vc)) + dmap.get(vc).weight;                 ", "-                    queue.remove(dmap.get(vc)); //this is O(logn) but could be O(1)?", "+                if (v != workingGraph.getEdgeSource(e)) {", "+                    vc = workingGraph.getEdgeSource(e);", "+                } else {", "+                    vc = workingGraph.getEdgeTarget(e);", "+                }", "+                if (dmap.get(vc) != null) {", "+                    Double neww =", "+                        -workingGraph.getEdgeWeight(workingGraph.getEdge(v, vc))", "+                        + dmap.get(vc).weight;", "+                    queue.remove(dmap.get(vc)); //this is O(logn) but could be", "+                                                //O(1)?", "-                    queue.add(dmap.get(vc)); //this is O(logn) but could be O(1)?", "+                    queue.add(dmap.get(vc)); //this is O(logn) but could be", "+                                             //O(1)?", "-        ", "-        //if this is the first run we compute the weight of last vertex in the list", "-        if(firstRun){", "-            Set<V> v = list.get(list.size()-1);", "+", "+        //if this is the first run we compute the weight of last vertex in the", "+        //list", "+        if (firstRun) {", "+            Set<V> v = list.get(list.size() - 1);", "-            if(w < bestcutweight){", "+            if (w < bestcutweight) {", "-        ", "-        //the last two elements in list are the vertices we want to merge. ", "-        Set<V> s = list.get(list.size()-2);", "-        Set<V> t = list.get(list.size()-1);", "-        //merge these vertices and get the weight.  ", "-        VertexAndWeight vw = mergeVertices(s, t); ", "+", "+        //the last two elements in list are the vertices we want to merge.", "+        Set<V> s = list.get(list.size() - 2);", "+        Set<V> t = list.get(list.size() - 1);", "+", "+        //merge these vertices and get the weight.", "+        VertexAndWeight vw = mergeVertices(s, t);", "+", "-        if(vw.weight < bestcutweight){", "+        if (vw.weight < bestcutweight) {", "-        "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e68d09a831f364a7dc597a5f29429565", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/ext/DOTExporter.java", "commitBeforeChange": "e601cce570393b1ad5c879b58ec483ca42a9532b", "commitAfterChange": "df9e52ba034eea98b94d0b6e1470ce50769bc1ce", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public void export(Writer writer, Graph<V,E> g)", "signatureAfterChange": "     public void export(Writer writer, Graph<V, E> g)", "diff": ["-    public void export(Writer writer, Graph<V,E> g)", "+    public void export(Writer writer, Graph<V, E> g)", "-        ", "-        if (g instanceof DirectedGraph)", "-        {", "-    \t\tout.println(\"digraph G {\");", "-    \t\tconnector = \" -> \";", "+", "+        if (g instanceof DirectedGraph) {", "+            out.println(\"digraph G {\");", "+            connector = \" -> \";", "+        } else {", "+            out.println(\"graph G {\");", "+            connector = \" -- \";", "-        else", "-        {", "-    \t\tout.println(\"graph G {\");", "-    \t\tconnector = \" -- \";", "-    \t}", "-\t\tfor (V v : g.vertexSet())", "-\t\t{", "-\t\t    out.print(indent + vertexIDProvider.getVertexName(v));", "-\t\t    ", "-\t\t    if (vertexLabelProvider != null)", "-\t\t        out.print(\" [label = \\\"\" + vertexLabelProvider.getVertexName(v) + \"\\\"]\");", "-\t\t    ", "+        for (V v : g.vertexSet()) {", "+            out.print(indent + vertexIDProvider.getVertexName(v));", "+", "+            if (vertexLabelProvider != null) {", "+                out.print(", "+                    \" [label = \\\"\" + vertexLabelProvider.getVertexName(v)", "+                    + \"\\\"]\");", "+            }", "+", "-\t\t}", "+        }", "-        for (E e : g.edgeSet())", "-\t\t{", "-\t\t    String source = vertexIDProvider.getVertexName(g.getEdgeSource(e));", "-\t\t    String target = vertexIDProvider.getVertexName(g.getEdgeTarget(e));", "+        for (E e : g.edgeSet()) {", "+            String source = vertexIDProvider.getVertexName(g.getEdgeSource(e));", "+            String target = vertexIDProvider.getVertexName(g.getEdgeTarget(e));", "-\t\t\tout.print(indent + source + connector + target);", "-\t\t\t", "-\t\t\tif (edgeLabelProvider != null)", "-                out.print(\" [label = \\\"\" + edgeLabelProvider.getEdgeName(e) + \"\\\"]\");", "-                ", "+            out.print(indent + source + connector + target);", "+", "+            if (edgeLabelProvider != null) {", "+                out.print(", "+                    \" [label = \\\"\" + edgeLabelProvider.getEdgeName(e) + \"\\\"]\");", "+            }", "+", "-\t\t}", "+        }", "-\t\tout.println(\"}\");", "-\t\t", "-\t\tout.flush();", "+        out.println(\"}\");", "+", "+        out.flush();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc72ed8862838a0d63c5d2e1a83082a3", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/KuhnMunkresMinimalWeightBipartitePerfectMatching.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public KuhnMunkresMinimalWeightBipartitePerfectMatching(         final WeightedGraph<V, E> G,         List<? extends V> S,         List<? extends V> T)", "signatureAfterChange": "     public KuhnMunkresMinimalWeightBipartitePerfectMatching(         final WeightedGraph<V, E> G,         List<? extends V> S,         List<? extends V> T)", "diff": ["-        List<? extends V> T) {", "-", "+        List<? extends V> T)", "+    {", "-        if (S.size() != T.size())", "-          throw new IllegalArgumentException(\"Graph supplied isn't complete bipartite with equally sized partitions!\");", "+        if (S.size() != T.size()) {", "+            throw new IllegalArgumentException(", "+                \"Graph supplied isn't complete bipartite with equally sized partitions!\");", "+        }", "-        int partition   = S.size(),", "-            edges       = G.edgeSet().size();", "+        int partition = S.size(), edges = G.edgeSet().size();", "-        if (edges != partition * partition)", "-          throw new IllegalArgumentException(\"Graph supplied isn't complete bipartite with equally sized partitions!\");", "+        if (edges != (partition * partition)) {", "+            throw new IllegalArgumentException(", "+                \"Graph supplied isn't complete bipartite with equally sized partitions!\");", "+        }", "-        graph           = G;", "-        firstPartition  = S;", "+        graph = G;", "+        firstPartition = S;", "-        matching = new KuhnMunkresMatrixImplementation<V, E>(G, S, T).buildMatching();", "-", "+        matching =", "+            new KuhnMunkresMatrixImplementation<V, E>(G, S, T).buildMatching();"]}]}