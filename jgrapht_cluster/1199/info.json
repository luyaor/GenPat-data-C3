{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "71a7d2b21af2afb2fe5c5d0fdb2f4c15", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7e516ef6944c87ade116b502739afc55", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/StoerWagnerMinimumCut.java", "commitBeforeChange": "a8056d6aafd19ddde3f88a7357d27b280fbbac76", "commitAfterChange": "8786155732723df083d81ecffc66379e7847e52a", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     protected void minimumCutPhase(Set<V> a)", "signatureAfterChange": "     protected void minimumCutPhase(Set<V> a)", "diff": ["-        //construct sorted queue with vertices connected to vertex a", "+        // The last and before last vertices added to A.", "+        Set<V> last = a, beforelast = null;", "+        // queue contains vertices not in A ordered by max weight of edges to A.", "-            new PriorityQueue<VertexAndWeight>();", "+                new PriorityQueue<VertexAndWeight>();", "+        // Maps vertices to elements of queue", "-            new HashMap<Set<V>, VertexAndWeight>();", "+                new HashMap<Set<V>, VertexAndWeight>();", "+        ", "+        // Initialize queue", "-            if (v != a) {", "-                Double w =", "-                    -workingGraph.getEdgeWeight(workingGraph.getEdge(v, a));", "-                VertexAndWeight vandw = new VertexAndWeight(v, w);", "-                queue.add(vandw);", "-                dmap.put(v, vandw);", "-            }", "+            if (v == a)", "+                continue;", "+            DefaultWeightedEdge e = workingGraph.getEdge(v, a);", "+            Double w = e == null ? 0.0 : workingGraph.getEdgeWeight(e);", "+            VertexAndWeight vandw = new VertexAndWeight(v, w, e != null);", "+            queue.add(vandw);", "+            dmap.put(v, vandw);", "-        //now iteratatively update the queue to get the required vertex ordering", "-        List<Set<V>> list =", "-            new ArrayList<Set<V>>(workingGraph.vertexSet().size());", "-        list.add(a);", "+", "+        // Now iteratively update the queue to get the required vertex ordering", "+", "+            //System.out.println(\"Q:\"+ queue);", "-            list.add(v);", "+            //System.out.println(\"q:\"+ v);", "+", "+            beforelast = last;", "+            last = v;", "+", "-                Set<V> vc;", "-                if (v != workingGraph.getEdgeSource(e)) {", "-                    vc = workingGraph.getEdgeSource(e);", "-                } else {", "-                    vc = workingGraph.getEdgeTarget(e);", "-                }", "-                if (dmap.get(vc) != null) {", "-                    Double neww =", "-                        -workingGraph.getEdgeWeight(workingGraph.getEdge(v, vc))", "-                        + dmap.get(vc).weight;", "-                    queue.remove(dmap.get(vc)); //this is O(logn) but could be", "-                                                //O(1)?", "-                    dmap.get(vc).weight = neww;", "-                    queue.add(dmap.get(vc)); //this is O(logn) but could be", "-                                             //O(1)?", "+                Set<V> vc = Graphs.getOppositeVertex(workingGraph, e, v);", "+                VertexAndWeight vcandw = dmap.get(vc);", "+                if (vcandw != null) {", "+                    queue.remove(vcandw); //this is O(logn) but could be O(1)?", "+                    vcandw.active = true;", "+                    vcandw.weight += workingGraph.getEdgeWeight(e);", "+                    queue.add(vcandw); //this is O(logn) but could be O(1)?", "-        //if this is the first run we compute the weight of last vertex in the", "-        //list", "-        if (firstRun) {", "-            Set<V> v = list.get(list.size() - 1);", "-            double w = vertexWeight(v);", "-            if (w < bestcutweight) {", "-                bestcutweight = w;", "-                bestCut = v;", "-            }", "-            firstRun = false;", "+        // Update the best cut", "+        double w = vertexWeight(last);", "+        if (w < bestCutWeight) {", "+            bestCutWeight = w;", "+            bestCut = last;", "-        //the last two elements in list are the vertices we want to merge.", "-        Set<V> s = list.get(list.size() - 2);", "-        Set<V> t = list.get(list.size() - 1);", "+        //merge the last added vertices", "+        mergeVertices(beforelast, last);", "-        //merge these vertices and get the weight.", "-        VertexAndWeight vw = mergeVertices(s, t);", "-", "-        //If this is the best cut so far store it.", "-        if (vw.weight < bestcutweight) {", "-            bestcutweight = vw.weight;", "-            bestCut = vw.vertex;", "-        }", "+        //System.out.println(\"C:\"+ bestCut +\" \"+ bestCutWeight);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e42663dc43afbc6280f587d4856325c1", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/StoerWagnerMinimumCut.java", "commitBeforeChange": "76399a5646342a12a99375b728ce65e0fef58fa7", "commitAfterChange": "836df798105be860e011cc4cc0ecf308ba811d44", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     protected void minimumCutPhase(Set<V> a)", "signatureAfterChange": "     protected void minimumCutPhase(Set<V> a)", "diff": ["-    /** Implements the MinimumCutPhase function of Stoer and Wagner */", "-    protected void minimumCutPhase(Set<V> a){", "-        ", "+     */", "+    protected void minimumCutPhase(Set<V> a)", "+    {", "-        PriorityQueue<VertexAndWeight> queue = new PriorityQueue<VertexAndWeight>();", "-        Map<Set<V>, VertexAndWeight> dmap = new HashMap<Set<V>, VertexAndWeight>();", "-        for(Set<V> v : workingGraph.vertexSet()) {", "-            if( v != a ){", "-                Double w = -workingGraph.getEdgeWeight(workingGraph.getEdge(v, a));", "-                VertexAndWeight vandw = new VertexAndWeight(v,w);", "+        PriorityQueue<VertexAndWeight> queue =", "+            new PriorityQueue<VertexAndWeight>();", "+        Map<Set<V>, VertexAndWeight> dmap =", "+            new HashMap<Set<V>, VertexAndWeight>();", "+        for (Set<V> v : workingGraph.vertexSet()) {", "+            if (v != a) {", "+                Double w =", "+                    -workingGraph.getEdgeWeight(workingGraph.getEdge(v, a));", "+                VertexAndWeight vandw = new VertexAndWeight(v, w);", "-        ", "+", "-        List<Set<V>> list = new ArrayList<Set<V>> (workingGraph.vertexSet().size());", "+        List<Set<V>> list =", "+            new ArrayList<Set<V>>(workingGraph.vertexSet().size());", "-        while(!queue.isEmpty()){", "-            Set<V> v = queue.poll().vertex; ", "-            dmap.remove(v);         ", "+        while (!queue.isEmpty()) {", "+            Set<V> v = queue.poll().vertex;", "+            dmap.remove(v);", "-            for( DefaultWeightedEdge e : workingGraph.edgesOf(v) ){", "+            for (DefaultWeightedEdge e : workingGraph.edgesOf(v)) {", "-                if( v != workingGraph.getEdgeSource(e) ) vc = workingGraph.getEdgeSource(e); ", "-                else vc = workingGraph.getEdgeTarget(e);", "-                if(dmap.get(vc) != null){", "-                    Double neww = - workingGraph.getEdgeWeight(workingGraph.getEdge(v, vc)) + dmap.get(vc).weight;                 ", "-                    queue.remove(dmap.get(vc)); //this is O(logn) but could be O(1)?", "+                if (v != workingGraph.getEdgeSource(e)) {", "+                    vc = workingGraph.getEdgeSource(e);", "+                } else {", "+                    vc = workingGraph.getEdgeTarget(e);", "+                }", "+                if (dmap.get(vc) != null) {", "+                    Double neww =", "+                        -workingGraph.getEdgeWeight(workingGraph.getEdge(v, vc))", "+                        + dmap.get(vc).weight;", "+                    queue.remove(dmap.get(vc)); //this is O(logn) but could be", "+                                                //O(1)?", "-                    queue.add(dmap.get(vc)); //this is O(logn) but could be O(1)?", "+                    queue.add(dmap.get(vc)); //this is O(logn) but could be", "+                                             //O(1)?", "-        ", "-        //if this is the first run we compute the weight of last vertex in the list", "-        if(firstRun){", "-            Set<V> v = list.get(list.size()-1);", "+", "+        //if this is the first run we compute the weight of last vertex in the", "+        //list", "+        if (firstRun) {", "+            Set<V> v = list.get(list.size() - 1);", "-            if(w < bestcutweight){", "+            if (w < bestcutweight) {", "-        ", "-        //the last two elements in list are the vertices we want to merge. ", "-        Set<V> s = list.get(list.size()-2);", "-        Set<V> t = list.get(list.size()-1);", "-        //merge these vertices and get the weight.  ", "-        VertexAndWeight vw = mergeVertices(s, t); ", "+", "+        //the last two elements in list are the vertices we want to merge.", "+        Set<V> s = list.get(list.size() - 2);", "+        Set<V> t = list.get(list.size() - 1);", "+", "+        //merge these vertices and get the weight.", "+        VertexAndWeight vw = mergeVertices(s, t);", "+", "-        if(vw.weight < bestcutweight){", "+        if (vw.weight < bestcutweight) {", "-        "]}]}