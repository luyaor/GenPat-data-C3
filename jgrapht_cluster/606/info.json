{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "73c5b9386bfffcf80528178b9aa9c8bf", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2dc54349957f6ada64e1d772a841257d", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/cycle/HawickJamesSimpleCycles.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r \r \tprivate boolean circuit(Integer v, Operation o)", "signatureAfterChange": "      private boolean circuit(Integer v, Operation o)", "diff": ["-\r", "-\tprivate boolean circuit(Integer v, Operation o) {\r", "-\t\tboolean f = false;\r", "-\r", "-\t\tstack.push(v);\r", "-\t\tblocked[v] = true;\r", "-\r", "-\t\tIterator<Integer> iteratorAk = Ak[v].iterator();\r", "-\t\twhile (iteratorAk.hasNext()) {\r", "-\r", "-\t\t\tInteger w = iteratorAk.next();\r", "-\r", "-\t\t\tif (w < start)\r", "-\t\t\t\tcontinue;\r", "-\r", "-\t\t\tif (w == start) {\r", "-\r", "-\t\t\t\tif (o == Operation.ENUMERATE) {\r", "-\t\t\t\t\tList<V> cycle = new ArrayList<V>(stack.size());\r", "-\r", "-\t\t\t\t\tIterator<Integer> iteratorStack = stack.iterator();\r", "-\t\t\t\t\twhile (iteratorStack.hasNext()) {\r", "-\t\t\t\t\t\tcycle.add(iToV[iteratorStack.next()]);\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\tcycles.add(cycle);\r", "-\t\t\t\t}\r", "-\r", "-\t\t\t\tif (o == Operation.PRINT_ONLY) {\r", "-\t\t\t\t\tfor (Integer i : stack) {\r", "-\t\t\t\t\t\tSystem.out.print(iToV[i].toString() + \" \");\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tSystem.out.println(\"\");\r", "-\t\t\t\t}\r", "-\r", "-\t\t\t\tnCycles++;\r", "-\r", "-\t\t\t\tf = true;\r", "-\r", "-\t\t\t} else if (!blocked[w]) {\r", "-\t\t\t\tif (circuit(w, o))\r", "-\t\t\t\t\tf = true;\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\tif (f) {\r", "-\t\t\tunblock(v);\r", "-\r", "-\t\t} else {\r", "-\t\t\titeratorAk = Ak[v].iterator();\r", "-\t\t\twhile (iteratorAk.hasNext()) {\r", "-\t\t\t\tInteger w = iteratorAk.next();\r", "-\r", "-\t\t\t\tif (w < start)\r", "-\t\t\t\t\tcontinue;\r", "-\r", "-\t\t\t\tif (!B[w].contains(v))\r", "-\t\t\t\t\tB[w].add(v);\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\tstack.pop();\r", "-\r", "-\t\treturn f;\r", "-\t}\r", "+", "+    private boolean circuit(Integer v, Operation o)", "+    {", "+        boolean f = false;", "+", "+        stack.push(v);", "+        blocked[v] = true;", "+", "+        Iterator<Integer> iteratorAk = Ak[v].iterator();", "+        while (iteratorAk.hasNext()) {", "+            Integer w = iteratorAk.next();", "+", "+            if (w < start) {", "+                continue;", "+            }", "+", "+            if (w == start) {", "+                if (o == Operation.ENUMERATE) {", "+                    List<V> cycle = new ArrayList<V>(stack.size());", "+", "+                    Iterator<Integer> iteratorStack = stack.iterator();", "+                    while (iteratorStack.hasNext()) {", "+                        cycle.add(iToV[iteratorStack.next()]);", "+                    }", "+", "+                    cycles.add(cycle);", "+                }", "+", "+                if (o == Operation.PRINT_ONLY) {", "+                    for (Integer i : stack) {", "+                        System.out.print(iToV[i].toString() + \" \");", "+                    }", "+                    System.out.println(\"\");", "+                }", "+", "+                nCycles++;", "+", "+                f = true;", "+            } else if (!blocked[w]) {", "+                if (circuit(w, o)) {", "+                    f = true;", "+                }", "+            }", "+        }", "+", "+        if (f) {", "+            unblock(v);", "+        } else {", "+            iteratorAk = Ak[v].iterator();", "+            while (iteratorAk.hasNext()) {", "+                Integer w = iteratorAk.next();", "+", "+                if (w < start) {", "+                    continue;", "+                }", "+", "+                if (!B[w].contains(v)) {", "+                    B[w].add(v);", "+                }", "+            }", "+        }", "+", "+        stack.pop();", "+", "+        return f;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf84fda25a901ce00d0e9a7e7bf7cd4f", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/isomorphism/AbstractExhaustiveIsomorphismInspector.java", "commitBeforeChange": "bc0edf459db61509a8a89769f512605e140e204b", "commitAfterChange": "be762e0954643fc21a24645a8b9b6765fa5b12ef", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tprivate IsomorphismRelation findNextIsomorphicGraph()", "signatureAfterChange": "     private IsomorphismRelation findNextIsomorphicGraph()", "diff": ["-\t */", "-\tprivate IsomorphismRelation findNextIsomorphicGraph()", "-\t{", "-\t\tboolean result=false;", "-\t\tIsomorphismRelation resultRelation=null;", "-\t\tif (this.vertexPermuteIter!=null)", "-\t\t{", "-\t\t\t//System.out.println(\"Souce  LabelsGraph=\"+this.lableGraph1);", "-\t\t\twhile (this.vertexPermuteIter.hasNext())", "-\t\t\t{", "-\t\t\t\tcurrVertexPermutation = this.vertexPermuteIter.getNextSet();", "-\t\t\t\t//comapre vertexes", "-\t\t\t\tif (!areVertexSetsOfTheSameEqualityGroup(this.graph1VertexSet,currVertexPermutation))", "-\t\t\t\t{", "-\t\t\t\t\tcontinue;\t//this one is not iso, so try the next one", "-\t\t\t\t}", "-\t\t\t\t//compare edges", "-\t\t\t\tGraphOrdering currPermuteGraph = new GraphOrdering(currVertexPermutation,this.graph2EdgeSet);", "-\t\t\t\t//System.out.println(\"target LablesGraph=\"+currPermuteGraph);", "-\t\t\t\tif (this.lableGraph1.equalsByEdgeOrder(currPermuteGraph))", "-\t\t\t\t{", "-\t\t\t\t\t", "-\t\t\t\t\t//create result object .", "-\t\t\t\t\tresultRelation= new IsomorphismRelation(", "-\t\t\t\t\t\t\tgraph1VertexSet.toArray(),", "-\t\t\t\t\t\t\tcurrVertexPermutation.toArray(),", "-\t\t\t\t\t\t\t(Graph)graph1,", "-\t\t\t\t\t\t\t(Graph)graph2", "-\t\t\t\t\t\t\t);", "-\t\t\t\t\t//if the edge comparator exist , check euqivalce by it", "-\t\t\t\t\tboolean edgeEq = areAllEdgesEquivivalant(resultRelation,this.edgeComparator);", "-\t\t\t\t\tif (edgeEq) //only if euqivalant", "-\t\t\t\t\t{", "-\t\t\t\t\t\tresult=true;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\tif (result==true)", "-\t\t{", "-\t\t\treturn resultRelation;", "-\t\t}", "-\t\telse", "-\t\t{", "-\t\t\treturn null;", "-\t\t}", "-\t}", "+     */", "+    private IsomorphismRelation findNextIsomorphicGraph()", "+    {", "+        boolean result = false;", "+        IsomorphismRelation resultRelation = null;", "+        if (this.vertexPermuteIter != null) {", "+            // System.out.println(\"Souce  LabelsGraph=\"+this.lableGraph1);", "+            while (this.vertexPermuteIter.hasNext()) {", "+                currVertexPermutation = this.vertexPermuteIter.getNextSet();", "+", "+                // compare vertexes", "+                if (!areVertexSetsOfTheSameEqualityGroup(", "+                        this.graph1VertexSet,", "+                        currVertexPermutation)) {", "+                    continue; // this one is not iso, so try the next one", "+                }", "+", "+                // compare edges", "+                GraphOrdering currPermuteGraph =", "+                    new GraphOrdering(", "+                        currVertexPermutation,", "+                        this.graph2EdgeSet);", "+", "+                // System.out.println(\"target LablesGraph=\"+currPermuteGraph);", "+                if (this.lableGraph1.equalsByEdgeOrder(currPermuteGraph)) {", "+                    // create result object.", "+                    resultRelation =", "+                        new IsomorphismRelation(", "+                            graph1VertexSet.toArray(),", "+                            currVertexPermutation.toArray(),", "+                            (Graph) graph1,", "+                            (Graph) graph2);", "+", "+                    // if the edge comparator exists, check equivalence by it", "+                    boolean edgeEq =", "+                        areAllEdgesEquivalent(", "+                            resultRelation,", "+                            this.edgeComparator);", "+                    if (edgeEq) // only if equivalent", "+                    {", "+                        result = true;", "+                        break;", "+                    }", "+                }", "+            }", "+        }", "+", "+        if (result == true) {", "+            return resultRelation;", "+        } else {", "+            return null;", "+        }", "+    }"]}]}