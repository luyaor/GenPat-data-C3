{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "87dd815f6ada8a1b8f89e744bec79450", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0cac4077a33bb7bc50856da0f1b14889", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/BreadthFirstIterator.java", "commitBeforeChange": "1a139deda5ac7b2aaba241b3824c64caaee23fb6", "commitAfterChange": "ddcca677c21de372890c813874f294b371ec5648", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     public Object next(  )", "signatureAfterChange": "     public Object next(  )", "diff": ["-            List edges = m_specifics.edgesOf( nextVertex );", "-", "-            for( Iterator iter = edges.iterator(  ); iter.hasNext(  ); ) {", "-                Edge e = (Edge) iter.next(  );", "-                fireEdgeVisited( e );", "-", "-                Object v = e.oppositeVertex( nextVertex );", "-", "-                if( m_seen.add( v ) ) { // means: if NOT seen", "-                    m_queue.add( v );", "-                }", "-            }", "+            enqueueUnseenChildrenOf( nextVertex );", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0d804614a2bf6661827f3f85afcf9e35", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/graph/AbstractGraph.java", "commitBeforeChange": "2cb98d0c1094fff00a22763c10d4fd59f71eaae5", "commitAfterChange": "4efd29b14c87e09927591be73abc578e10bee63c", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "     public int hashCode()", "signatureAfterChange": "     public int hashCode()", "diff": ["-            int part = 27;", "-", "-            if (!(e instanceof IntrusiveEdge)) {", "-               part = 27 * part + e.hashCode();", "-            } else {", "-                // we should check if there is any overridden hashCode() method in hierarchy", "-                // so, users can write their own edge classes as subclasses of DefaultEdge", "-                // with custom implementation of hashCode() method (VK);", "-                try {", "-                    Method hashCode = e.getClass().getMethod(\"hashCode\", new Class<?>[0]);", "-                    if (hashCode.getDeclaringClass() != Object.class) {", "-                        part = 27 * part + e.hashCode();", "-                    }", "-                } catch (NoSuchMethodException ignored) {", "-                    // should never happens, we always have hashCode() method (VK);", "-                }", "-            }", "+            int part = e.hashCode();", "-            // this is a \"pairing function\" (see details here: http://en.wikipedia.org/wiki/Pairing_function) (VK);", "-            int pairing = ((source + target) * (source + target + 1) / 2) + target;", "+            // see http://en.wikipedia.org/wiki/Pairing_function (VK);", "+            int pairing = ((source + target) * ", "+                (source + target + 1) / 2) + target;", "-            // we also should add hash code of weighted edge to result (VK);", "-            if (e instanceof DefaultWeightedEdge) {", "-                long weight = (long) getEdgeWeight(e);", "-                part = 27 * part + (int) (weight ^ (weight >>> 32));", "-            }", "+            long weight = (long) getEdgeWeight(e);", "+            part = 27 * part + (int) (weight ^ (weight >>> 32));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1b6d3e9606d49f3096cdf539e983788c", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/graph/AbstractGraph.java", "commitBeforeChange": "d31c0a461f002b1bbca978a729161e05d339538a", "commitAfterChange": "ee11f3bf4fcb52f92037c518ce52556a0f7dfbad", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "     public boolean equals(Object object)", "signatureAfterChange": "     public boolean equals(Object object)", "diff": ["-", "-        // TODO: maybe we should add class checking here:", "-        // for example: Undirected and Directed are different graphs, but could looks the same (have same hashCodes()) (VK)", "+        if (getClass() != object.getClass()) return false;", "-        if (vertexSet().size() != g.vertexSet().size() ", "-            || edgeSet().size() != g.edgeSet().size()) return false;", "-", "-        for (V v: vertexSet()) {", "-            if (!g.containsVertex(v)) return false;", "-        }", "-", "-        for (V v: g.vertexSet()) {", "-            if (!containsVertex(v)) return false;", "-        }", "+        if (!vertexSet().equals(g.vertexSet())) return false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2064a74ad238c2fb803513a82e08576b", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/DijkstraShortestPath.java", "commitBeforeChange": "e3d152c903d64a55a394899016d3b983c6acef7f", "commitAfterChange": "07571b88304723826e2edaac1a71e187c5b1dbe3", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public DijkstraShortestPath(Graph<V, E> graph,         V startVertex,         V endVertex,         double radius)", "signatureAfterChange": "     public DijkstraShortestPath(Graph<V, E> graph,         V startVertex,         V endVertex)", "diff": ["+     */", "+    public DijkstraShortestPath(Graph<V, E> graph,", "+        V startVertex,", "+        V endVertex)", "+    {", "+        this(graph, startVertex, endVertex, Double.POSITIVE_INFINITY);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "888deeb8012bcb8b8eab93bb740fe6c7", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/StrongConnectivityInspector.java", "commitBeforeChange": "04b4adb9d61a0a7a990979c19fd44e55accd860f", "commitAfterChange": "ccbda858621a3d1beb6a9381a0fc81c3673ee66c", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public List stronglyConnectedSets(  )", "signatureAfterChange": "     public List stronglyConnectedSets()", "diff": ["-    public List stronglyConnectedSets(  ) {", "-        if( m_stronglyConnectedSets == null ) {", "-            m_verticesToVerticesData =", "-                new HashMap( m_graph.vertexSet(  ).size(  ) );", "-            m_orderedVertices           = new LinkedList(  );", "-            m_stronglyConnectedSets =", "-                new Vector( m_graph.vertexSet(  ).size(  ) );", "+    public List stronglyConnectedSets() {", "+        if (m_stronglyConnectedSets == null) {", "+", "+            m_orderedVertices = new LinkedList();", "+            m_stronglyConnectedSets = new Vector();", "-            Iterator iter = m_graph.vertexSet(  ).iterator(  );", "-", "-            while( iter.hasNext(  ) ) {", "-                Object vertex = iter.next(  );", "-                m_verticesToVerticesData.put( vertex,", "-                    new VertexData( vertex, false, false ) );", "-            }", "+            createVertexData();", "-            iter = m_verticesToVerticesData.values(  ).iterator(  );", "+            Iterator iter = m_vertexToVertexData.values().iterator();", "-            while( iter.hasNext(  ) ) {", "-                VertexData data = (VertexData) iter.next(  );", "+            while (iter.hasNext()) {", "+                VertexData data = (VertexData) iter.next();", "-                if( !data.m_discovered ) {", "-                    dfsVisit( m_graph, data, null );", "+                if (!data.m_discovered) {", "+                    dfsVisit(m_graph, data, null);", "-            // calculate inverse graph (i.e. every edge is turned)", "-            DirectedGraph inverseGraph = new DefaultDirectedGraph(  );", "-            GraphHelper.addGraphReversed( inverseGraph, m_graph );", "+            // calculate inverse graph (i.e. every edge is reversed)", "+            DirectedGraph inverseGraph = new DefaultDirectedGraph();", "+            GraphHelper.addGraphReversed(inverseGraph, m_graph);", "-            resetVertexData(  );", "+            resetVertexData();", "-            iter = m_orderedVertices.iterator(  );", "+            iter = m_orderedVertices.iterator();", "-            while( iter.hasNext(  ) ) {", "-                VertexData data = (VertexData) iter.next(  );", "+            while (iter.hasNext()) {", "+                VertexData data = (VertexData) iter.next();", "-                if( !data.m_discovered ) {", "+                if (!data.m_discovered) {", "-                    Set set = new HashSet(  );", "-                    m_stronglyConnectedSets.add( set );", "-                    dfsVisit( inverseGraph, data, set );", "+                    Set set = new HashSet();", "+                    m_stronglyConnectedSets.add(set);", "+                    dfsVisit(inverseGraph, data, set);", "-            m_graph                      = null;", "-            m_orderedVertices            = null;", "-            m_verticesToVerticesData     = null;", "+            m_orderedVertices = null;", "+            m_vertexToVertexData = null;"]}]}