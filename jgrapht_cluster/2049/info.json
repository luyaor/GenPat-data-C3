{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7b6d5a6e3aebfbaf180528e7e8678c41", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85e3eb7641699e01df8ff21cec7636c1", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/util/FibonacciHeap.java", "commitBeforeChange": "22aa7e82f42fce210220bdbc283c0138f6f5ab70", "commitAfterChange": "0f3a10c6ea5258c0add31f2c1eb0ac64b015315a", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "     protected void consolidate()", "signatureAfterChange": "      protected void consolidate()", "diff": ["-     */", "-        int arraySize = nNodes + 1;", "+        int arraySize =", "+            ((int) Math.floor(Math.log(nNodes) * oneOverLogPhi)) + 1;", "+", "-            while (array.get(d) != null) {", "-                // There is, make one of the nodes a child of the other.", "+            for (;;) {", "+                if (y == null) {", "+                    // Nope.", "+                    break;", "+                }", "+                // There is, make one of the nodes a child of the other.", "-            if (array.get(i) != null) {", "-                // We've got a live one, add it to root list.", "-                if (minNode != null) {", "-                    // First remove node from root list.", "-                    array.get(i).left.right = array.get(i).right;", "-                    array.get(i).right.left = array.get(i).left;", "+            FibonacciHeapNode<T> y = array.get(i);", "+            if (y == null) {", "+                continue;", "+            }", "+            // We've got a live one, add it to root list.", "+            if (minNode != null) {", "+                // First remove node from root list.", "+                y.left.right = y.right;", "+                y.right.left = y.left;", "-                    // Now add to root list, again.", "-                    array.get(i).left = minNode;", "-                    array.get(i).right = minNode.right;", "-                    minNode.right = array.get(i);", "-                    array.get(i).right.left = array.get(i);", "+                // Now add to root list, again.", "+                y.left = minNode;", "+                y.right = minNode.right;", "+                minNode.right = y;", "+                y.right.left = y;", "-                    // Check if this is a new min.", "-                    if (array.get(i).key < minNode.key) {", "-                        minNode = array.get(i);", "-                    }", "-                } else {", "-                    minNode = array.get(i);", "+                // Check if this is a new min.", "+                if (y.key < minNode.key) {", "+                    minNode = y;", "+            } else {", "+                minNode = y;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5d679a9bb48a4bf3214b8150098e1ed", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/graph/AbstractGraph.java", "commitBeforeChange": "2cb98d0c1094fff00a22763c10d4fd59f71eaae5", "commitAfterChange": "4efd29b14c87e09927591be73abc578e10bee63c", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "     public boolean equals(Object object)", "signatureAfterChange": "     public boolean equals(Object obj)", "diff": ["-    public boolean equals(Object object)", "+    public boolean equals(Object obj)", "-        if (this == object) return true;", "-        if (object == null || getClass() != object.getClass()) return false;", "+        if (this == obj) {", "+            return true;", "+        }", "+        if (obj == null || getClass() != obj.getClass()) {", "+            return false;", "+        }", "-        Graph<V, E> g = TypeUtil.uncheckedCast(object, typeDecl);", "+        Graph<V, E> g = TypeUtil.uncheckedCast(obj, typeDecl);", "-        if (!vertexSet().equals(g.vertexSet())) return false;", "+        if (!vertexSet().equals(g.vertexSet())) {", "+            return false;", "+        }", "+        if (edgeSet().size() != g.edgeSet().size()) {", "+            return false;", "+        }", "-        Set<E> otherEdges = new LinkedHashSet<E>(g.edgeSet());", "-            // first of all we should check that the same vertices are connected in other graph (VK);", "-            if (!g.containsEdge(source, target)) return false;", "-", "-            if (e instanceof IntrusiveEdge) {", "-                // we also should check if there is any overridden equals() method in hierarchy", "-                // so, users can write their own edge classes as subclasses of DefaultEdge", "-                // with custom implementation of equals() method (VK);", "-                try {", "-                    Method equals = e.getClass().getMethod(\"equals\", new Class<?>[] { Object.class });", "-                    boolean edgeFound = false;", "-                    for (E ee: g.getAllEdges(source, target)) {", "-                        if (!otherEdges.contains(ee)) continue;", "-                        if (equals.getDeclaringClass() != Object.class) {", "-                            if (e.equals(ee)) {", "-                                if (e instanceof DefaultWeightedEdge) {", "-                                    if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(ee)) > 10e-7) return false;", "-                                }", "-                                otherEdges.remove(ee);", "-                                edgeFound = true;", "-                                break;", "-                            }", "-                        } else {", "-                            if (e instanceof DefaultWeightedEdge) {", "-                                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(ee)) < 10e-7) {", "-                                    otherEdges.remove(ee);", "-                                    edgeFound = true;", "-                                    break;", "-                                }", "-                            } else {", "-                                otherEdges.remove(ee);", "-                                edgeFound = true;", "-                                break;", "-                            }", "-                        }", "+            boolean found = false;", "+            for (E ee: g.getAllEdges(source, target)) {", "+                if (e == ee || e.equals(ee)) {", "+                    if (e != ee && Math.abs(getEdgeWeight(e) ", "+                        - g.getEdgeWeight(ee)) > 10e-7)", "+                    {", "+                        return false;", "-                    if (!edgeFound) return false;", "-                } catch (NoSuchMethodException ignored) {", "-                    // should never happens, we always have equals() method (VK);", "+                    found = true;", "+                    break;", "-            } else if (!otherEdges.remove(e)) return false;", "-        }", "+            }", "-        // finally, if edges set of the other graph is empty - graphs are equal (VK);", "-        if (!otherEdges.isEmpty()) return false;", "+            if (!found) {", "+                return false;", "+            }", "+        }"]}]}