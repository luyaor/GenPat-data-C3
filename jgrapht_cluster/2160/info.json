{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d5ff2119f496e3e94fbee5a44f395c6e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c099665fa6eced726ca7e693569b042", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/util/VertexPair.java", "commitBeforeChange": "b261cb99c92126b64c9129dbe772684f0da5e234", "commitAfterChange": "22927827f36ad9b2cef7c5f5670c4d2598840023", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "       @Override     public boolean equals(Object o)", "signatureAfterChange": "      @Override public boolean equals(Object o)", "diff": ["-", "-    @Override", "-    public boolean equals(Object o) {", "-        if (this == o) return true;", "-        if (o == null || getClass() != o.getClass()) return false;", "+    @Override public boolean equals(Object o)", "+    {", "+        if (this == o) {", "+            return true;", "+        }", "+        if ((o == null) || (getClass() != o.getClass())) {", "+            return false;", "+        }", "-        if (n1 != null ? !n1.equals(that.n1) : that.n1 != null) return false;", "-        if (n2 != null ? !n2.equals(that.n2) : that.n2 != null) return false;", "+        if ((n1 != null) ? (!n1.equals(that.n1)) : (that.n1 != null)) {", "+            return false;", "+        }", "+        if ((n2 != null) ? (!n2.equals(that.n2)) : (that.n2 != null)) {", "+            return false;", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2dc54349957f6ada64e1d772a841257d", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/cycle/HawickJamesSimpleCycles.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r \r \tprivate boolean circuit(Integer v, Operation o)", "signatureAfterChange": "      private boolean circuit(Integer v, Operation o)", "diff": ["-\r", "-\tprivate boolean circuit(Integer v, Operation o) {\r", "-\t\tboolean f = false;\r", "-\r", "-\t\tstack.push(v);\r", "-\t\tblocked[v] = true;\r", "-\r", "-\t\tIterator<Integer> iteratorAk = Ak[v].iterator();\r", "-\t\twhile (iteratorAk.hasNext()) {\r", "-\r", "-\t\t\tInteger w = iteratorAk.next();\r", "-\r", "-\t\t\tif (w < start)\r", "-\t\t\t\tcontinue;\r", "-\r", "-\t\t\tif (w == start) {\r", "-\r", "-\t\t\t\tif (o == Operation.ENUMERATE) {\r", "-\t\t\t\t\tList<V> cycle = new ArrayList<V>(stack.size());\r", "-\r", "-\t\t\t\t\tIterator<Integer> iteratorStack = stack.iterator();\r", "-\t\t\t\t\twhile (iteratorStack.hasNext()) {\r", "-\t\t\t\t\t\tcycle.add(iToV[iteratorStack.next()]);\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\tcycles.add(cycle);\r", "-\t\t\t\t}\r", "-\r", "-\t\t\t\tif (o == Operation.PRINT_ONLY) {\r", "-\t\t\t\t\tfor (Integer i : stack) {\r", "-\t\t\t\t\t\tSystem.out.print(iToV[i].toString() + \" \");\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tSystem.out.println(\"\");\r", "-\t\t\t\t}\r", "-\r", "-\t\t\t\tnCycles++;\r", "-\r", "-\t\t\t\tf = true;\r", "-\r", "-\t\t\t} else if (!blocked[w]) {\r", "-\t\t\t\tif (circuit(w, o))\r", "-\t\t\t\t\tf = true;\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\tif (f) {\r", "-\t\t\tunblock(v);\r", "-\r", "-\t\t} else {\r", "-\t\t\titeratorAk = Ak[v].iterator();\r", "-\t\t\twhile (iteratorAk.hasNext()) {\r", "-\t\t\t\tInteger w = iteratorAk.next();\r", "-\r", "-\t\t\t\tif (w < start)\r", "-\t\t\t\t\tcontinue;\r", "-\r", "-\t\t\t\tif (!B[w].contains(v))\r", "-\t\t\t\t\tB[w].add(v);\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\tstack.pop();\r", "-\r", "-\t\treturn f;\r", "-\t}\r", "+", "+    private boolean circuit(Integer v, Operation o)", "+    {", "+        boolean f = false;", "+", "+        stack.push(v);", "+        blocked[v] = true;", "+", "+        Iterator<Integer> iteratorAk = Ak[v].iterator();", "+        while (iteratorAk.hasNext()) {", "+            Integer w = iteratorAk.next();", "+", "+            if (w < start) {", "+                continue;", "+            }", "+", "+            if (w == start) {", "+                if (o == Operation.ENUMERATE) {", "+                    List<V> cycle = new ArrayList<V>(stack.size());", "+", "+                    Iterator<Integer> iteratorStack = stack.iterator();", "+                    while (iteratorStack.hasNext()) {", "+                        cycle.add(iToV[iteratorStack.next()]);", "+                    }", "+", "+                    cycles.add(cycle);", "+                }", "+", "+                if (o == Operation.PRINT_ONLY) {", "+                    for (Integer i : stack) {", "+                        System.out.print(iToV[i].toString() + \" \");", "+                    }", "+                    System.out.println(\"\");", "+                }", "+", "+                nCycles++;", "+", "+                f = true;", "+            } else if (!blocked[w]) {", "+                if (circuit(w, o)) {", "+                    f = true;", "+                }", "+            }", "+        }", "+", "+        if (f) {", "+            unblock(v);", "+        } else {", "+            iteratorAk = Ak[v].iterator();", "+            while (iteratorAk.hasNext()) {", "+                Integer w = iteratorAk.next();", "+", "+                if (w < start) {", "+                    continue;", "+                }", "+", "+                if (!B[w].contains(v)) {", "+                    B[w].add(v);", "+                }", "+            }", "+        }", "+", "+        stack.pop();", "+", "+        return f;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b284451d0c69a3ee7ececa73319c90b", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/GraphOrdering.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     public int[] getOutEdges(int vertexNumber)", "signatureAfterChange": "     public int [] getOutEdges(int vertexNumber)", "diff": ["-    public int[] getOutEdges(int vertexNumber) {", "-        if (cacheEdges && outgoingEdges[vertexNumber] != null)", "+    public int [] getOutEdges(int vertexNumber)", "+    {", "+        if (cacheEdges && (outgoingEdges[vertexNumber] != null)) {", "+        }", "-        if (graph instanceof DirectedGraph<?, ?>)", "+        if (graph instanceof DirectedGraph<?, ?>) {", "-        else", "+        } else {", "+        }", "-        int[] vertexArray = new int[edgeSet.size()];", "+        int [] vertexArray = new int[edgeSet.size()];", "-              target = graph.getEdgeTarget(edge);", "+                target = graph.getEdgeTarget(edge);", "-        if (cacheEdges)", "+        if (cacheEdges) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a781d86360cd1596574ac89783dcb21", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/NaiveLcaFinder.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     private V findLca(Set<V> aSet, Set<V> bSet, LinkedHashSet<V> aSeenSet, LinkedHashSet<V> bSeenSet)", "signatureAfterChange": "     private V findLca(         Set<V> aSet,         Set<V> bSet,         LinkedHashSet<V> aSeenSet,         LinkedHashSet<V> bSeenSet)", "diff": ["-    private V findLca(Set<V> aSet, Set<V> bSet, LinkedHashSet<V> aSeenSet, LinkedHashSet<V> bSeenSet) {", "+    private V findLca(", "+        Set<V> aSet,", "+        Set<V> bSet,", "+        LinkedHashSet<V> aSeenSet,", "+        LinkedHashSet<V> bSeenSet)", "+    {", "+        // if there is no LCA...", "+        if ((aSet.size() == 0) && (bSet.size() == 0)) {", "+            return null;", "+        }", "-\t// if there is no LCA...", "-\tif (aSet.size() == 0 && bSet.size() == 0)", "-\t    return null;", "-\t// does aSet intersect with bSeenSet", "-\tif (!Collections.disjoint(aSet, bSeenSet))", "-\t    return overlappingMember(aSet, bSeenSet);", "-\t// does bSet intersect with aSeenSet", "-\tif (!Collections.disjoint(bSet, aSeenSet))", "-\t    return overlappingMember(bSet, aSeenSet);", "-\tif (!Collections.disjoint(aSet, bSet))", "-\t    return overlappingMember(aSet, bSet);", "+        // does aSet intersect with bSeenSet", "+        if (!Collections.disjoint(aSet, bSeenSet)) {", "+            return overlappingMember(aSet, bSeenSet);", "+        }", "-\taSeenSet.addAll(aSet);", "-\tbSeenSet.addAll(bSet);", "+        // does bSet intersect with aSeenSet", "+        if (!Collections.disjoint(bSet, aSeenSet)) {", "+            return overlappingMember(bSet, aSeenSet);", "+        }", "+        if (!Collections.disjoint(aSet, bSet)) {", "+            return overlappingMember(aSet, bSet);", "+        }", "-\taSet = allParents(aSet);", "-\t// no point doing the same again (and it can stop us getting stuck in an infinite loop)", "-\taSet.removeAll(aSeenSet);", "+        aSeenSet.addAll(aSet);", "+        bSeenSet.addAll(bSet);", "-\tbSet = allParents(bSet);", "-\tbSet.removeAll(bSeenSet);", "+        aSet = allParents(aSet);", "-\treturn findLca(aSet, bSet, aSeenSet, bSeenSet);", "+        // no point doing the same again (and it can stop us getting stuck in", "+        // an infinite loop)", "+        aSet.removeAll(aSeenSet);", "+        bSet = allParents(bSet);", "+        bSet.removeAll(bSeenSet);", "+", "+        return findLca(aSet, bSet, aSeenSet, bSeenSet);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9dfc25bbb22d1e541650cfee20a57f56", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/MinSourceSinkCut.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void computeMinCut(V source, V sink)", "signatureAfterChange": "     public void computeMinCut(V source, V sink)", "diff": ["-\t */", "-\tpublic void computeMinCut(V source, V sink){", "-\t\tthis.source=source;", "-\t\tthis.sink=sink;", "-\t\tminCut=new HashSet<V>();", "-\t\t//First compute a maxFlow from source to sink", "-\t\tekMaxFlow.calculateMaximumFlow(source, sink);", "-\t\tthis.cutWeight=ekMaxFlow.getMaximumFlowValue();", "-\t\tMap<E, Double> maxFlow=ekMaxFlow.getMaximumFlow();", "-\t\t", "-\t\tQueue<V> processQueue=new LinkedList<V>();", "-\t\tprocessQueue.add(source);", "-\t\t", "-\t\twhile(!processQueue.isEmpty()){", "-\t\t\tV vertex=processQueue.remove();", "-\t\t\tif(minCut.contains(vertex))", "-\t\t\t\tcontinue;", "-\t\t\telse", "-\t\t\t\tminCut.add(vertex);", "-\t\t\t//1. Get the forward edges with residual capacity", "-\t\t\tSet<E> outEdges=new HashSet<E>(graph.outgoingEdgesOf(vertex));", "-\t\t\tfor(Iterator<E> it=outEdges.iterator(); it.hasNext();){", "-\t\t\t\tE edge=it.next();", "-\t\t\t\tdouble edgeCapacity=graph.getEdgeWeight(edge);", "-\t\t\t\tdouble flowValue=maxFlow.get(edge);", "-\t\t\t\tif(Math.abs(edgeCapacity-flowValue)<=epsilon) //No residual capacity on the edge", "-\t\t\t\t\tit.remove();", "-\t\t\t}", "-\t\t\tfor(E edge: outEdges){", "-\t\t\t\tprocessQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));", "-\t\t\t}", "-\t\t\t", "-\t\t\t//2. Get the backward edges with non-zero flow", "-\t\t\tSet<E> inEdges=new HashSet<E>(graph.incomingEdgesOf(vertex));", "-\t\t\tfor(Iterator<E> it=inEdges.iterator(); it.hasNext();){", "-\t\t\t\tE edge=it.next();", "-\t\t\t\t//double edgeCapacity=graph.getEdgeWeight(edge);", "-\t\t\t\tdouble flowValue=maxFlow.get(edge);", "-\t\t\t\tif(flowValue<=epsilon) //There is no flow on this edge", "-\t\t\t\t\tit.remove();", "-\t\t\t}", "-\t\t\tfor(E edge: inEdges){", "-\t\t\t\tprocessQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t}", "+     */", "+    public void computeMinCut(V source, V sink)", "+    {", "+        this.source = source;", "+        this.sink = sink;", "+        minCut = new HashSet<V>();", "+", "+        //First compute a maxFlow from source to sink", "+        ekMaxFlow.calculateMaximumFlow(source, sink);", "+        this.cutWeight = ekMaxFlow.getMaximumFlowValue();", "+        Map<E, Double> maxFlow = ekMaxFlow.getMaximumFlow();", "+", "+        Queue<V> processQueue = new LinkedList<V>();", "+        processQueue.add(source);", "+", "+        while (!processQueue.isEmpty()) {", "+            V vertex = processQueue.remove();", "+            if (minCut.contains(vertex)) {", "+                continue;", "+            } else {", "+                minCut.add(vertex);", "+            }", "+", "+            //1. Get the forward edges with residual capacity", "+            Set<E> outEdges = new HashSet<E>(graph.outgoingEdgesOf(vertex));", "+            for (Iterator<E> it = outEdges.iterator(); it.hasNext();) {", "+                E edge = it.next();", "+                double edgeCapacity = graph.getEdgeWeight(edge);", "+                double flowValue = maxFlow.get(edge);", "+                if (Math.abs(edgeCapacity - flowValue) <= epsilon) { //No residual capacity on the edge", "+                    it.remove();", "+                }", "+            }", "+            for (E edge : outEdges) {", "+                processQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));", "+            }", "+", "+            //2. Get the backward edges with non-zero flow", "+            Set<E> inEdges = new HashSet<E>(graph.incomingEdgesOf(vertex));", "+            for (Iterator<E> it = inEdges.iterator(); it.hasNext();) {", "+                E edge = it.next();", "+", "+                //double edgeCapacity=graph.getEdgeWeight(edge);", "+                double flowValue = maxFlow.get(edge);", "+                if (flowValue <= epsilon) { //There is no flow on this edge", "+                    it.remove();", "+                }", "+            }", "+            for (E edge : inEdges) {", "+                processQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));", "+            }", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c2d1af1e1bdcb841e5816cfde1b01b32", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/util/UnionFind.java", "commitBeforeChange": "b5348f8a80e818c9b0dd566a68eb23f3eca4389b", "commitAfterChange": "29039f1f20cd2b1397eba3afdb9fc72182dd2062", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     public void union(V element1, V element2)", "signatureAfterChange": "     public void union(V element1, V element2)", "diff": ["-        if(!parentMap.containsKey(element1) || !parentMap.containsKey(element2))", "-            throw new IllegalArgumentException(\"elements must be contained in given set\");", "-        ", "+        if (!parentMap.containsKey(element1)", "+            || !parentMap.containsKey(element2))", "+        {", "+            throw new IllegalArgumentException(", "+                \"elements must be contained in given set\");", "+        }", "+", "-        ", "+", "-        if(parent1.equals(parent2))", "+        if (parent1.equals(parent2)) {", "-        ", "+        }", "+", "-        if(rank1 > rank2)", "+        if (rank1 > rank2) {", "-        else if(rank1 < rank2)", "+        } else if (rank1 < rank2) {", "-        else", "-        {", "-            parentMap.put(parent2,parent1);", "-            rankMap.put(parent1, rank1+1);", "+        } else {", "+            parentMap.put(parent2, parent1);", "+            rankMap.put(parent1, rank1 + 1);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f34e6cce01d31f28930aa837e408b868", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/GraphOrdering.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public int[] getInEdges(int vertexNumber)", "signatureAfterChange": "     public int [] getInEdges(int vertexNumber)", "diff": ["-    public int[] getInEdges(int vertexNumber) {", "-        if (cacheEdges && incomingEdges[vertexNumber] != null)", "+    public int [] getInEdges(int vertexNumber)", "+    {", "+        if (cacheEdges && (incomingEdges[vertexNumber] != null)) {", "+        }", "-        V v            = getVertex(vertexNumber);", "+        V v = getVertex(vertexNumber);", "-        if (graph instanceof DirectedGraph<?, ?>)", "+        if (graph instanceof DirectedGraph<?, ?>) {", "-        else", "+        } else {", "+        }", "-        int[] vertexArray = new int[edgeSet.size()];", "-        int i             = 0;", "+        int [] vertexArray = new int[edgeSet.size()];", "+        int i = 0;", "-              target = graph.getEdgeTarget(edge);", "+                target = graph.getEdgeTarget(edge);", "-        if (cacheEdges)", "+        if (cacheEdges) {", "+        }"]}]}