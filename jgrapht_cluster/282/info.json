{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ebb11f1402ae9a73deb803bdc53cf8e4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c099665fa6eced726ca7e693569b042", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/util/VertexPair.java", "commitBeforeChange": "b261cb99c92126b64c9129dbe772684f0da5e234", "commitAfterChange": "22927827f36ad9b2cef7c5f5670c4d2598840023", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "       @Override     public boolean equals(Object o)", "signatureAfterChange": "      @Override public boolean equals(Object o)", "diff": ["-", "-    @Override", "-    public boolean equals(Object o) {", "-        if (this == o) return true;", "-        if (o == null || getClass() != o.getClass()) return false;", "+    @Override public boolean equals(Object o)", "+    {", "+        if (this == o) {", "+            return true;", "+        }", "+        if ((o == null) || (getClass() != o.getClass())) {", "+            return false;", "+        }", "-        if (n1 != null ? !n1.equals(that.n1) : that.n1 != null) return false;", "-        if (n2 != null ? !n2.equals(that.n2) : that.n2 != null) return false;", "+        if ((n1 != null) ? (!n1.equals(that.n1)) : (that.n1 != null)) {", "+            return false;", "+        }", "+        if ((n2 != null) ? (!n2.equals(that.n2)) : (that.n2 != null)) {", "+            return false;", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2dc54349957f6ada64e1d772a841257d", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/cycle/HawickJamesSimpleCycles.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r \r \tprivate boolean circuit(Integer v, Operation o)", "signatureAfterChange": "      private boolean circuit(Integer v, Operation o)", "diff": ["-\r", "-\tprivate boolean circuit(Integer v, Operation o) {\r", "-\t\tboolean f = false;\r", "-\r", "-\t\tstack.push(v);\r", "-\t\tblocked[v] = true;\r", "-\r", "-\t\tIterator<Integer> iteratorAk = Ak[v].iterator();\r", "-\t\twhile (iteratorAk.hasNext()) {\r", "-\r", "-\t\t\tInteger w = iteratorAk.next();\r", "-\r", "-\t\t\tif (w < start)\r", "-\t\t\t\tcontinue;\r", "-\r", "-\t\t\tif (w == start) {\r", "-\r", "-\t\t\t\tif (o == Operation.ENUMERATE) {\r", "-\t\t\t\t\tList<V> cycle = new ArrayList<V>(stack.size());\r", "-\r", "-\t\t\t\t\tIterator<Integer> iteratorStack = stack.iterator();\r", "-\t\t\t\t\twhile (iteratorStack.hasNext()) {\r", "-\t\t\t\t\t\tcycle.add(iToV[iteratorStack.next()]);\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\tcycles.add(cycle);\r", "-\t\t\t\t}\r", "-\r", "-\t\t\t\tif (o == Operation.PRINT_ONLY) {\r", "-\t\t\t\t\tfor (Integer i : stack) {\r", "-\t\t\t\t\t\tSystem.out.print(iToV[i].toString() + \" \");\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tSystem.out.println(\"\");\r", "-\t\t\t\t}\r", "-\r", "-\t\t\t\tnCycles++;\r", "-\r", "-\t\t\t\tf = true;\r", "-\r", "-\t\t\t} else if (!blocked[w]) {\r", "-\t\t\t\tif (circuit(w, o))\r", "-\t\t\t\t\tf = true;\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\tif (f) {\r", "-\t\t\tunblock(v);\r", "-\r", "-\t\t} else {\r", "-\t\t\titeratorAk = Ak[v].iterator();\r", "-\t\t\twhile (iteratorAk.hasNext()) {\r", "-\t\t\t\tInteger w = iteratorAk.next();\r", "-\r", "-\t\t\t\tif (w < start)\r", "-\t\t\t\t\tcontinue;\r", "-\r", "-\t\t\t\tif (!B[w].contains(v))\r", "-\t\t\t\t\tB[w].add(v);\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\tstack.pop();\r", "-\r", "-\t\treturn f;\r", "-\t}\r", "+", "+    private boolean circuit(Integer v, Operation o)", "+    {", "+        boolean f = false;", "+", "+        stack.push(v);", "+        blocked[v] = true;", "+", "+        Iterator<Integer> iteratorAk = Ak[v].iterator();", "+        while (iteratorAk.hasNext()) {", "+            Integer w = iteratorAk.next();", "+", "+            if (w < start) {", "+                continue;", "+            }", "+", "+            if (w == start) {", "+                if (o == Operation.ENUMERATE) {", "+                    List<V> cycle = new ArrayList<V>(stack.size());", "+", "+                    Iterator<Integer> iteratorStack = stack.iterator();", "+                    while (iteratorStack.hasNext()) {", "+                        cycle.add(iToV[iteratorStack.next()]);", "+                    }", "+", "+                    cycles.add(cycle);", "+                }", "+", "+                if (o == Operation.PRINT_ONLY) {", "+                    for (Integer i : stack) {", "+                        System.out.print(iToV[i].toString() + \" \");", "+                    }", "+                    System.out.println(\"\");", "+                }", "+", "+                nCycles++;", "+", "+                f = true;", "+            } else if (!blocked[w]) {", "+                if (circuit(w, o)) {", "+                    f = true;", "+                }", "+            }", "+        }", "+", "+        if (f) {", "+            unblock(v);", "+        } else {", "+            iteratorAk = Ak[v].iterator();", "+            while (iteratorAk.hasNext()) {", "+                Integer w = iteratorAk.next();", "+", "+                if (w < start) {", "+                    continue;", "+                }", "+", "+                if (!B[w].contains(v)) {", "+                    B[w].add(v);", "+                }", "+            }", "+        }", "+", "+        stack.pop();", "+", "+        return f;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b284451d0c69a3ee7ececa73319c90b", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/GraphOrdering.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     public int[] getOutEdges(int vertexNumber)", "signatureAfterChange": "     public int [] getOutEdges(int vertexNumber)", "diff": ["-    public int[] getOutEdges(int vertexNumber) {", "-        if (cacheEdges && outgoingEdges[vertexNumber] != null)", "+    public int [] getOutEdges(int vertexNumber)", "+    {", "+        if (cacheEdges && (outgoingEdges[vertexNumber] != null)) {", "+        }", "-        if (graph instanceof DirectedGraph<?, ?>)", "+        if (graph instanceof DirectedGraph<?, ?>) {", "-        else", "+        } else {", "+        }", "-        int[] vertexArray = new int[edgeSet.size()];", "+        int [] vertexArray = new int[edgeSet.size()];", "-              target = graph.getEdgeTarget(edge);", "+                target = graph.getEdgeTarget(edge);", "-        if (cacheEdges)", "+        if (cacheEdges) {", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a781d86360cd1596574ac89783dcb21", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/NaiveLcaFinder.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     private V findLca(Set<V> aSet, Set<V> bSet, LinkedHashSet<V> aSeenSet, LinkedHashSet<V> bSeenSet)", "signatureAfterChange": "     private V findLca(         Set<V> aSet,         Set<V> bSet,         LinkedHashSet<V> aSeenSet,         LinkedHashSet<V> bSeenSet)", "diff": ["-    private V findLca(Set<V> aSet, Set<V> bSet, LinkedHashSet<V> aSeenSet, LinkedHashSet<V> bSeenSet) {", "+    private V findLca(", "+        Set<V> aSet,", "+        Set<V> bSet,", "+        LinkedHashSet<V> aSeenSet,", "+        LinkedHashSet<V> bSeenSet)", "+    {", "+        // if there is no LCA...", "+        if ((aSet.size() == 0) && (bSet.size() == 0)) {", "+            return null;", "+        }", "-\t// if there is no LCA...", "-\tif (aSet.size() == 0 && bSet.size() == 0)", "-\t    return null;", "-\t// does aSet intersect with bSeenSet", "-\tif (!Collections.disjoint(aSet, bSeenSet))", "-\t    return overlappingMember(aSet, bSeenSet);", "-\t// does bSet intersect with aSeenSet", "-\tif (!Collections.disjoint(bSet, aSeenSet))", "-\t    return overlappingMember(bSet, aSeenSet);", "-\tif (!Collections.disjoint(aSet, bSet))", "-\t    return overlappingMember(aSet, bSet);", "+        // does aSet intersect with bSeenSet", "+        if (!Collections.disjoint(aSet, bSeenSet)) {", "+            return overlappingMember(aSet, bSeenSet);", "+        }", "-\taSeenSet.addAll(aSet);", "-\tbSeenSet.addAll(bSet);", "+        // does bSet intersect with aSeenSet", "+        if (!Collections.disjoint(bSet, aSeenSet)) {", "+            return overlappingMember(bSet, aSeenSet);", "+        }", "+        if (!Collections.disjoint(aSet, bSet)) {", "+            return overlappingMember(aSet, bSet);", "+        }", "-\taSet = allParents(aSet);", "-\t// no point doing the same again (and it can stop us getting stuck in an infinite loop)", "-\taSet.removeAll(aSeenSet);", "+        aSeenSet.addAll(aSet);", "+        bSeenSet.addAll(bSet);", "-\tbSet = allParents(bSet);", "-\tbSet.removeAll(bSeenSet);", "+        aSet = allParents(aSet);", "-\treturn findLca(aSet, bSet, aSeenSet, bSeenSet);", "+        // no point doing the same again (and it can stop us getting stuck in", "+        // an infinite loop)", "+        aSet.removeAll(aSeenSet);", "+        bSet = allParents(bSet);", "+        bSet.removeAll(bSeenSet);", "+", "+        return findLca(aSet, bSet, aSeenSet, bSeenSet);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c2d1af1e1bdcb841e5816cfde1b01b32", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/util/UnionFind.java", "commitBeforeChange": "b5348f8a80e818c9b0dd566a68eb23f3eca4389b", "commitAfterChange": "29039f1f20cd2b1397eba3afdb9fc72182dd2062", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     public void union(V element1, V element2)", "signatureAfterChange": "     public void union(V element1, V element2)", "diff": ["-        if(!parentMap.containsKey(element1) || !parentMap.containsKey(element2))", "-            throw new IllegalArgumentException(\"elements must be contained in given set\");", "-        ", "+        if (!parentMap.containsKey(element1)", "+            || !parentMap.containsKey(element2))", "+        {", "+            throw new IllegalArgumentException(", "+                \"elements must be contained in given set\");", "+        }", "+", "-        ", "+", "-        if(parent1.equals(parent2))", "+        if (parent1.equals(parent2)) {", "-        ", "+        }", "+", "-        if(rank1 > rank2)", "+        if (rank1 > rank2) {", "-        else if(rank1 < rank2)", "+        } else if (rank1 < rank2) {", "-        else", "-        {", "-            parentMap.put(parent2,parent1);", "-            rankMap.put(parent1, rank1+1);", "+        } else {", "+            parentMap.put(parent2, parent1);", "+            rankMap.put(parent1, rank1 + 1);"]}]}