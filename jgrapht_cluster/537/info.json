{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3cb8582b45c00326dbf6c83ac635e851", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "815f98d2b2e4ac1f3f23087b3bb156ff", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "75bb7fff0bef1beed23710a8eaf7c22f02662da2", "commitAfterChange": "1852d2744de03b9218bb1f8c6e65dc81c980d59b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r     public static <V, E> boolean isClique(\r         SimpleGraph<V, E> graph,\r         Set<V> vertices)", "signatureAfterChange": "\r     private static <V, E> boolean isClique(\r         UndirectedGraph<V, E> graph,\r         Set<V> vertices)", "diff": ["-    public static <V, E> boolean isClique(\r", "-        SimpleGraph<V, E> graph,\r", "+    private static <V, E> boolean isClique(\r", "+        UndirectedGraph<V, E> graph,\r", "-        Subgraph<V, E, SimpleGraph<V, E>> sub = \r", "-            new Subgraph<V, E, SimpleGraph<V, E>>(graph, vertices);\r", "-        int n = vertices.size();\r", "-        if (sub.edgeSet().size() == n * (n - 1) / 2)\r", "-            return true;\r", "-        else\r", "-            return false;\r", "+        for (V v1 : vertices) {\r", "+            for (V v2 : vertices) {\r", "+                if (v1 != v2 && graph.getEdge(v1, v2) == null)\r", "+                    return false;\r", "+            }\r", "+        }\r", "+        return true;\r", "+    }\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0385d27315ceb4adb1e6657d04e52c8", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "e5d892ea988755999c21c3831434c4fc251611da", "commitAfterChange": "60fae450bc7df1fe1188f2da01fd4eefb4912b4d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 9, "signatureBeforeChange": "      private int index(V vertex)", "signatureAfterChange": "     public List<GraphPath<V, E>> getShortestPaths(V v)", "diff": ["-    private int index(V vertex)", "-    {", "-        Integer index = indices.get(vertex);", "-        if (index == null) {", "-            indices.put(vertex, nextIndex);", "-            index = nextIndex++;", "-        return index;", "+     */", "+    public List<GraphPath<V, E>> getShortestPaths(V v) {", "+        if (v == null)", "+            return null;", "+", "+        List<GraphPath<V, E>> found = new ArrayList<GraphPath<V, E>>();", "+        for (VertexPair<V> pair : paths.keySet()) {", "+            if (pair.hasVertex(v)) {", "+                found.add(paths.get(pair));", "+            }", "+        }", "+", "+        return found;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d67f398e3204965dd8b8cfb77d3fa043", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/EdmondsBlossomShrinking.java", "commitBeforeChange": "09f8c42369e19bad56b44493e9da23f84c9f33d0", "commitAfterChange": "8eb48033f951ffcc0a59543e123e6881cda6c1db", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "      private V findPath(V root)", "signatureAfterChange": "      private V findPath(V root)", "diff": ["-        used.clear();", "-        p.clear();", "-        base.clear();", "+        Set<V>      used    = new HashSet<V>();", "+        Queue<V>    q       = new ArrayDeque<V>();", "+", "+        // Expand graph back from its contracted state", "+        path.clear();", "+        contracted.clear();", "-            base.put(i, i);", "+            contracted.put(i, i);", "+", "+", "+", "-                if ((base.get(v) == base.get(to)) || (match.get(v) == to)) {", "+", "+                if ((contracted.get(v) == contracted.get(to)) || (match.get(v) == to)) {", "+", "+                // Check whether we've hit a 'blossom'", "-                    || ((match.containsKey(to))", "-                        && (p.containsKey(match.get(to)))))", "-                {", "-                    V curbase = lca(graph, v, to);", "-                    blossom.clear();", "-                    markPath(v, curbase, to);", "-                    markPath(to, curbase, v);", "+                || ((match.containsKey(to)) && (path.containsKey(match.get(to))))) {", "+                    V stem = lca(v, to);", "+", "+                    Set<V> blossom = new HashSet<V>();", "+", "+                    // ?", "+                    markPath(v, to, stem, blossom);", "+                    markPath(to, v, stem, blossom);", "-                        if (base.containsKey(i)", "-                            && blossom.contains(base.get(i)))", "+                        if (contracted.containsKey(i) && blossom.contains(contracted.get(i)))", "-                            base.put(i, curbase);", "+                            contracted.put(i, stem);", "+                            // ???", "-                } else if (!p.containsKey(to)) {", "-                    p.put(to, v);", "+", "+                // Check whether we've had hit a loop (of even length (!) presumably)", "+                } else if (!path.containsKey(to)) {", "+                    path.put(to, v);", "+", "+", "+"]}]}