{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b5d4057733fdd559a263c424035f746d", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "638fd310406c569d954d25ec1cbab464", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/ext/JGraphModelAdapter.java", "commitBeforeChange": "215e752a693cedd4e948342c99e93722b6fbe26a", "commitAfterChange": "56c09b98e6df528eeef0b8df9f8d932a1ba40192", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 24, "signatureBeforeChange": "         public void graphChanged( GraphModelEvent e )", "signatureAfterChange": "         public void graphChanged( GraphModelEvent e )", "diff": ["-            Set              JVertices = new HashSet(  );", "+            Set              jVertices = new HashSet(  );", "-                filterEdgesAndVertices( arrayToProcess, jEdges, JVertices );", "+                filterEdgesAndVertices( arrayToProcess, jEdges, jVertices );", "-                    if( m_jEdgesBeingRemoved.contains( jEdge ) ) {", "-                        m_jEdgesBeingRemoved.remove( jEdge );", "-                    }", "-                    else {", "+                    if( !m_jEdgesBeingRemoved.remove( jEdge ) ) {", "-                for( Iterator i = JVertices.iterator(  ); i.hasNext(  ); ) {", "+                for( Iterator i = jVertices.iterator(  ); i.hasNext(  ); ) {", "-                    if( m_jVerticesBeingRemoved.contains( jVertex ) ) {", "-                        m_jVerticesBeingRemoved.remove( jVertex );", "-                    }", "-                    else {", "+                    if( !m_jVerticesBeingRemoved.remove( jVertex ) ) {", "-                JVertices.clear(  );", "+                jVertices.clear(  );", "-                filterEdgesAndVertices( arrayToProcess, jEdges, JVertices );", "+                filterEdgesAndVertices( arrayToProcess, jEdges, jVertices );", "-                for( Iterator i = JVertices.iterator(  ); i.hasNext(  ); ) {", "+                for( Iterator i = jVertices.iterator(  ); i.hasNext(  ); ) {", "-                    if( m_jVerticesBeingAdded.contains( jVertex ) ) {", "-                        m_jVerticesBeingAdded.remove( jVertex );", "-                    }", "-                    else {", "+                    if( !m_jVerticesBeingAdded.remove( jVertex ) ) {", "-                    if( m_jEdgesBeingAdded.contains( jEdge ) ) {", "-                        m_jEdgesBeingAdded.remove( jEdge );", "-                    }", "-                    else {", "+                    if( !m_jEdgesBeingAdded.remove( jEdge ) ) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d67f398e3204965dd8b8cfb77d3fa043", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/EdmondsBlossomShrinking.java", "commitBeforeChange": "09f8c42369e19bad56b44493e9da23f84c9f33d0", "commitAfterChange": "8eb48033f951ffcc0a59543e123e6881cda6c1db", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "      private V findPath(V root)", "signatureAfterChange": "      private V findPath(V root)", "diff": ["-        used.clear();", "-        p.clear();", "-        base.clear();", "+        Set<V>      used    = new HashSet<V>();", "+        Queue<V>    q       = new ArrayDeque<V>();", "+", "+        // Expand graph back from its contracted state", "+        path.clear();", "+        contracted.clear();", "-            base.put(i, i);", "+            contracted.put(i, i);", "+", "+", "+", "-                if ((base.get(v) == base.get(to)) || (match.get(v) == to)) {", "+", "+                if ((contracted.get(v) == contracted.get(to)) || (match.get(v) == to)) {", "+", "+                // Check whether we've hit a 'blossom'", "-                    || ((match.containsKey(to))", "-                        && (p.containsKey(match.get(to)))))", "-                {", "-                    V curbase = lca(graph, v, to);", "-                    blossom.clear();", "-                    markPath(v, curbase, to);", "-                    markPath(to, curbase, v);", "+                || ((match.containsKey(to)) && (path.containsKey(match.get(to))))) {", "+                    V stem = lca(v, to);", "+", "+                    Set<V> blossom = new HashSet<V>();", "+", "+                    // ?", "+                    markPath(v, to, stem, blossom);", "+                    markPath(to, v, stem, blossom);", "-                        if (base.containsKey(i)", "-                            && blossom.contains(base.get(i)))", "+                        if (contracted.containsKey(i) && blossom.contains(contracted.get(i)))", "-                            base.put(i, curbase);", "+                            contracted.put(i, stem);", "+                            // ???", "-                } else if (!p.containsKey(to)) {", "-                    p.put(to, v);", "+", "+                // Check whether we've had hit a loop (of even length (!) presumably)", "+                } else if (!path.containsKey(to)) {", "+                    path.put(to, v);", "+", "+", "+"]}]}