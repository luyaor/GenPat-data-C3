{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "216cb4738d6e898a72569ecd1466a91b", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c9a0e77a6fa8ab8bf9c93ce5ff2f2af", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r     private void computeMinimalTriangulation()", "signatureAfterChange": "     private void computeMinimalTriangulation()", "diff": ["-     */\r", "-    private void computeMinimalTriangulation()\r", "-    {\r", "-        // initialize chordGraph with same vertices as graph\r", "-        chordalGraph = new SimpleGraph<V, E>(graph.getEdgeFactory());\r", "-        for (V v : graph.vertexSet())\r", "-            chordalGraph.addVertex(v);\r", "-\r", "-        // initialize g' as subgraph of graph (same vertices and edges)\r", "-        final UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);\r", "-        int s = -1;\r", "-        generators = new ArrayList<V>();\r", "-        meo = new LinkedList<V>();\r", "-\r", "-        final Map<V, Integer> vertexLabels = new HashMap<V, Integer>();\r", "-        for (V v : gprime.vertexSet()) {\r", "-            vertexLabels.put(v, 0);\r", "-        }\r", "-        for (int i = 1, n = graph.vertexSet().size(); i <= n; i++) {\r", "-            V v = getMaxLabelVertex(vertexLabels);\r", "-            LinkedList<V> Y = new LinkedList<V>(\r", "-                Graphs.neighborListOf(gprime, v));\r", "-\r", "-            if (vertexLabels.get(v) <= s)\r", "-                generators.add(v);\r", "-\r", "-            s = vertexLabels.get(v);\r", "-\r", "-            // Mark x reached and all other vertices of gprime unreached\r", "-            HashSet<V> reached = new HashSet<V>();\r", "-            reached.add(v);\r", "-\r", "-            // mark neighborhood of x reached and add to reach(label(y))\r", "-            HashMap<Integer, HashSet<V>> reach = \r", "-                new HashMap<Integer, HashSet<V>>();\r", "-\r", "-            // mark y reached and add y to reach\r", "-            for (V y : Y) {\r", "-                reached.add(y);\r", "-                addToReach(vertexLabels.get(y), y, reach);\r", "-            }\r", "-\r", "-            for (int j = 0; j < graph.vertexSet().size(); j++) {\r", "-                if (!reach.containsKey(j)) {\r", "-                    continue;\r", "-                }\r", "-                while (reach.get(j).size() > 0) {\r", "-                    // remove a vertex y from reach(j)\r", "-                    V y = reach.get(j).iterator().next();\r", "-                    reach.get(j).remove(y);\r", "-\r", "-                    for (V z : Graphs.neighborListOf(gprime, y)) {\r", "-                        if (!reached.contains(z)) {\r", "-                            reached.add(z);\r", "-                            if (vertexLabels.get(z) > j) {\r", "-                                Y.add(z);\r", "-                                E fillEdge = graph.getEdgeFactory().createEdge(\r", "-                                    v,\r", "-                                    z);\r", "-                                fillEdges.add(fillEdge);\r", "-                                addToReach(vertexLabels.get(z), z, reach);\r", "-                            } else {\r", "-                                addToReach(j, z, reach);\r", "-                            }\r", "-                        }\r", "-                    }\r", "-\r", "-                }\r", "-            }\r", "-\r", "-            for (V y : Y) {\r", "-                chordalGraph.addEdge(v, y);\r", "-                vertexLabels.put(y, vertexLabels.get(y) + 1);\r", "-            }\r", "-\r", "-            meo.addLast(v);\r", "-            gprime.removeVertex(v);\r", "-            vertexLabels.remove(v);\r", "-        }\r", "-    }\r", "+     */", "+    private void computeMinimalTriangulation()", "+    {", "+        // initialize chordGraph with same vertices as graph", "+        chordalGraph = new SimpleGraph<V, E>(graph.getEdgeFactory());", "+        for (V v : graph.vertexSet()) {", "+            chordalGraph.addVertex(v);", "+        }", "+", "+        // initialize g' as subgraph of graph (same vertices and edges)", "+        final UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);", "+        int s = -1;", "+        generators = new ArrayList<V>();", "+        meo = new LinkedList<V>();", "+", "+        final Map<V, Integer> vertexLabels = new HashMap<V, Integer>();", "+        for (V v : gprime.vertexSet()) {", "+            vertexLabels.put(v, 0);", "+        }", "+        for (int i = 1, n = graph.vertexSet().size(); i <= n; i++) {", "+            V v = getMaxLabelVertex(vertexLabels);", "+            LinkedList<V> Y =", "+                new LinkedList<V>(", "+                    Graphs.neighborListOf(gprime, v));", "+", "+            if (vertexLabels.get(v) <= s) {", "+                generators.add(v);", "+            }", "+", "+            s = vertexLabels.get(v);", "+", "+            // Mark x reached and all other vertices of gprime unreached", "+            HashSet<V> reached = new HashSet<V>();", "+            reached.add(v);", "+", "+            // mark neighborhood of x reached and add to reach(label(y))", "+            HashMap<Integer, HashSet<V>> reach =", "+                new HashMap<Integer, HashSet<V>>();", "+", "+            // mark y reached and add y to reach", "+            for (V y : Y) {", "+                reached.add(y);", "+                addToReach(vertexLabels.get(y), y, reach);", "+            }", "+", "+            for (int j = 0; j < graph.vertexSet().size(); j++) {", "+                if (!reach.containsKey(j)) {", "+                    continue;", "+                }", "+                while (reach.get(j).size() > 0) {", "+                    // remove a vertex y from reach(j)", "+                    V y = reach.get(j).iterator().next();", "+                    reach.get(j).remove(y);", "+", "+                    for (V z : Graphs.neighborListOf(gprime, y)) {", "+                        if (!reached.contains(z)) {", "+                            reached.add(z);", "+                            if (vertexLabels.get(z) > j) {", "+                                Y.add(z);", "+                                E fillEdge =", "+                                    graph.getEdgeFactory().createEdge(", "+                                        v,", "+                                        z);", "+                                fillEdges.add(fillEdge);", "+                                addToReach(vertexLabels.get(z), z, reach);", "+                            } else {", "+                                addToReach(j, z, reach);", "+                            }", "+                        }", "+                    }", "+                }", "+            }", "+", "+            for (V y : Y) {", "+                chordalGraph.addEdge(v, y);", "+                vertexLabels.put(y, vertexLabels.get(y) + 1);", "+            }", "+", "+            meo.addLast(v);", "+            gprime.removeVertex(v);", "+            vertexLabels.remove(v);", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0ea89a232f00e4d12a6b257fa074b843", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-ext/src/main/java/org/jgrapht/ext/DOTImporter.java", "commitBeforeChange": "583bedb628992418bdbd952ca092e65831d3b133", "commitAfterChange": "43aa0f5e11b9b56a524f92631cd31dc060fa1ca7", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "    public void read(String input, AbstractBaseGraph<V, E> graph)          throws ImportException", "signatureAfterChange": "    public void read(String input, AbstractBaseGraph<V, E> graph)          throws ImportException", "diff": ["-      String[] lines = input.split(\"[;\\r\\n]\");", "-", "-      validateLines(lines, graph);", "-", "-      // cache of vertexes added to the graph.", "-      for(int lineIndex = 1; lineIndex < lines.length - 1; lineIndex ++ ) {", "-         String line = lines[lineIndex].trim();", "+      int state = HEADER;", "+      int lastState = HEADER;", "+      int position = 0;", "-         // trim off line comments.", "-         if (line.contains(\"//\")) {", "-            line = line.substring(0, line.indexOf(\"//\"));", "-         }", "+      StringBuilder sectionBuffer = new StringBuilder();", "-         // with \\r\\n or just ;\\n line ends we get blanks. Filter here.", "-         if(line.isEmpty()) {", "-            continue;", "-         }", "-", "-         if (line.startsWith(\"#\")) {", "-            // line comment so ignore", "-            // TODO: block comments", "-         } else if (!line.contains(\"[\") && line.contains(\"=\")) {", "-            throw new ImportException(", "-                  \"graph level properties are not currently supported.\"", "-            );", "-         } else if (isVertexLine(line)) {", "-            // probably a vertex", "-            Map<String, String> attributes = extractAttributes(line);", "-", "-            String id = line.trim();", "-            int bracketIndex = line.indexOf('[');", "-            if (bracketIndex > 0) {", "-               id = line.substring(0, line.indexOf('[')).trim();", "-            }", "-", "-            String label = attributes.get(\"label\");", "-            if (label == null) {", "-               label = id;", "-            }", "-", "-            V existing = vertexes.get(id);", "-            if (existing == null) {", "-               V vertex = vertexProvider.buildVertex(label, attributes);", "-               graph.addVertex(vertex);", "-               vertexes.put(id, vertex);", "-            } else {", "-               if (vertexUpdater != null) {", "-                  vertexUpdater.updateVertex(existing, attributes);", "-               } else {", "-                  throw new ImportException(", "-                        \"Update required for vertex \"", "-                        + label", "-                        + \" but no vertexUpdater provided\"", "-                  );", "+      while (state != DONE && position < input.length()) {", "+         int existingState = state;", "+         switch(state) {", "+            case HEADER:", "+               state = processHeader(input, position, sectionBuffer, graph);", "+               break;", "+            case NODE:", "+               state = processNode(input, position, sectionBuffer, graph, vertexes);", "+               break;", "+            case EDGE:", "+               state = processEdge(input, position, sectionBuffer, graph, vertexes);", "+               break;", "+            case LINE_COMMENT:", "+               state = processLineComment(input, position, sectionBuffer, lastState);", "+               if (state == lastState) {", "+                  // when we leave a line comment we need the new line to still appear in the old block", "+                  position = position - 1;", "-            }", "-         } else {", "-            Map<String, String> attributes = extractAttributes(line);", "-", "-            List<String> ids = extractEdgeIds(line);", "-", "-            // for each pair of ids in the list create an edge.", "-            for(int i = 0; i < ids.size() - 1; i++) {", "-               V v1 = getVertex(ids.get(i), vertexes, graph);", "-               V v2 = getVertex(ids.get(i+1), vertexes, graph);", "-", "-               E edge = edgeProvider.buildEdge(v1,", "-                                               v2,", "-                                               attributes.get(\"label\"),", "-                                               attributes);", "-               graph.addEdge(v1, v2, edge);", "-            }", "+               break;", "+            case BLOCK_COMMENT:", "+               state = processBlockComment(input, position, lastState);", "+               break;", "+            case NODE_QUOTES:", "+               state = processNodeQuotes(input, position, sectionBuffer);", "+               break;", "+            case EDGE_QUOTES:", "+               state = processEdgeQuotes(input, position, sectionBuffer);", "+               break;", "+            case NEXT:", "+               state = processNext(input, position, sectionBuffer, graph, vertexes);", "+               break;", "+            // DONE not included here as we can't get to it with the while loop.", "+            default:", "+               throw new ImportException(\"Error importing escaped state machine\");", "+         position = position + 1;", "+", "+         if (state != existingState) {", "+            lastState = existingState;", "+         }", "+", "+      }", "+", "+      // if we get to the end and are some how still in the header the input must be invalid.", "+      if(state == HEADER) {", "+         throw new ImportException(\"Invalid Header\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "324455aecdb52cb53d744beb96b0ea9f", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r     private void computeAtoms()", "signatureAfterChange": "     private void computeAtoms()", "diff": ["-     */\r", "-    private void computeAtoms()\r", "-    {\r", "-        if (chordalGraph == null)\r", "-            computeMinimalTriangulation();\r", "-\r", "-        separators = new HashSet<Set<V>>();\r", "-\r", "-        // initialize g' as subgraph of graph (same vertices and edges)\r", "-        UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);\r", "-\r", "-        // initialize h' as subgraph of chordalGraph (same vertices and edges)\r", "-        UndirectedGraph<V, E> hprime = copyAsSimpleGraph(chordalGraph);\r", "-\r", "-        atoms = new HashSet<Set<V>>();\r", "-\r", "-        Iterator<V> iterator = meo.descendingIterator();\r", "-        while (iterator.hasNext()) {\r", "-            V v = iterator.next();\r", "-            if (generators.contains(v)) {\r", "-                Set<V> separator = new HashSet<V>(Graphs.neighborListOf(\r", "-                    hprime,\r", "-                    v));\r", "-\r", "-                if (isClique(graph, separator)) {\r", "-                    if (separator.size() > 0) {\r", "-                        if (separators.contains(separator)) {\r", "-                            fullComponentCount.put(\r", "-                                separator,\r", "-                                fullComponentCount.get(separator) + 1);\r", "-                        } else {\r", "-                            fullComponentCount.put(separator, 2);\r", "-                            separators.add(separator);\r", "-                        }\r", "-                    }\r", "-                    UndirectedGraph<V, E> tmpGraph = copyAsSimpleGraph(gprime);\r", "-\r", "-                    tmpGraph.removeAllVertices(separator);\r", "-                    ConnectivityInspector<V, E> con = \r", "-                        new ConnectivityInspector<V, E>(tmpGraph);\r", "-                    if (con.isGraphConnected()) {\r", "-                        throw new RuntimeException(\r", "-                            \"separator did not separate the graph\");\r", "-                    }\r", "-                    for (Set<V> component : con.connectedSets()) {\r", "-                        if (component.contains(v)) {\r", "-                            gprime.removeAllVertices(component);\r", "-                            component.addAll(separator);\r", "-                            atoms.add(new HashSet<V>(component));\r", "-                            assert (component.size() > 0);\r", "-                            break;\r", "-                        }\r", "-                    }\r", "-                }\r", "-            }\r", "-\r", "-            hprime.removeVertex(v);\r", "-        }\r", "-\r", "-        if (gprime.vertexSet().size() > 0) {\r", "-            atoms.add(new HashSet<V>(gprime.vertexSet()));\r", "-        }\r", "-    }\r", "+     */", "+    private void computeAtoms()", "+    {", "+        if (chordalGraph == null) {", "+            computeMinimalTriangulation();", "+        }", "+", "+        separators = new HashSet<Set<V>>();", "+", "+        // initialize g' as subgraph of graph (same vertices and edges)", "+        UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);", "+", "+        // initialize h' as subgraph of chordalGraph (same vertices and edges)", "+        UndirectedGraph<V, E> hprime = copyAsSimpleGraph(chordalGraph);", "+", "+        atoms = new HashSet<Set<V>>();", "+", "+        Iterator<V> iterator = meo.descendingIterator();", "+        while (iterator.hasNext()) {", "+            V v = iterator.next();", "+            if (generators.contains(v)) {", "+                Set<V> separator =", "+                    new HashSet<V>(Graphs.neighborListOf(", "+                            hprime,", "+                            v));", "+", "+                if (isClique(graph, separator)) {", "+                    if (separator.size() > 0) {", "+                        if (separators.contains(separator)) {", "+                            fullComponentCount.put(", "+                                separator,", "+                                fullComponentCount.get(separator) + 1);", "+                        } else {", "+                            fullComponentCount.put(separator, 2);", "+                            separators.add(separator);", "+                        }", "+                    }", "+                    UndirectedGraph<V, E> tmpGraph = copyAsSimpleGraph(gprime);", "+", "+                    tmpGraph.removeAllVertices(separator);", "+                    ConnectivityInspector<V, E> con =", "+                        new ConnectivityInspector<V, E>(tmpGraph);", "+                    if (con.isGraphConnected()) {", "+                        throw new RuntimeException(", "+                            \"separator did not separate the graph\");", "+                    }", "+                    for (Set<V> component : con.connectedSets()) {", "+                        if (component.contains(v)) {", "+                            gprime.removeAllVertices(component);", "+                            component.addAll(separator);", "+                            atoms.add(new HashSet<V>(component));", "+                            assert (component.size() > 0);", "+                            break;", "+                        }", "+                    }", "+                }", "+            }", "+", "+            hprime.removeVertex(v);", "+        }", "+", "+        if (gprime.vertexSet().size() > 0) {", "+            atoms.add(new HashSet<V>(gprime.vertexSet()));", "+        }", "+    }"]}]}