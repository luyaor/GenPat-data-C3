{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "343594f969bf38c538c47c2e81265577", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0bf913dbd2c2452b5d55df108cfaa9eb", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/ext/JGraphModelAdapter.java", "commitBeforeChange": "56c09b98e6df528eeef0b8df9f8d932a1ba40192", "commitAfterChange": "75098fa5c7281c0f169434b46722c0b4e66b3a8c", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 28, "signatureBeforeChange": "         public void graphChanged( GraphModelEvent e )", "signatureAfterChange": "         public void graphChanged( GraphModelEvent e )", "diff": ["-            GraphModelChange change    = e.getChange(  );", "-            Set              jEdges    = new HashSet(  );", "-            Set              jVertices = new HashSet(  );", "+            GraphModelChange change = e.getChange(  );", "+            ", "+            Object[] removedCells = change.getRemoved(  );", "-            Object[]         arrayToProcess = change.getRemoved(  );", "-", "-            if( arrayToProcess != null ) {", "-                filterEdgesAndVertices( arrayToProcess, jEdges, jVertices );", "-", "-                for( Iterator i = jEdges.iterator(  ); i.hasNext(  ); ) {", "-                    org.jgraph.graph.Edge jEdge =", "-                        (org.jgraph.graph.Edge) i.next(  );", "-", "-                    if( !m_jEdgesBeingRemoved.remove( jEdge ) ) {", "-                        removeJGraphEdge( jEdge );", "-                    }", "-                }", "-", "-                for( Iterator i = jVertices.iterator(  ); i.hasNext(  ); ) {", "-                    GraphCell jVertex = (GraphCell) i.next(  );", "-", "-                    if( !m_jVerticesBeingRemoved.remove( jVertex ) ) {", "-                        removeJGraphVertex( jVertex );", "-                    }", "-                }", "-", "-                jEdges.clear(  );", "-                jVertices.clear(  );", "+            if( removedCells != null ) {", "+                handleRemovedEdges( filterEdges( removedCells ) );", "+                handleRemovedVertices( filterVertices( removedCells ) );", "-            arrayToProcess = change.getInserted(  );", "+            Object[] insertedCells = change.getInserted(  );", "-            if( arrayToProcess != null ) {", "-                filterEdgesAndVertices( arrayToProcess, jEdges, jVertices );", "+            if( insertedCells != null ) {", "+                handleInsertedVertices( filterVertices( insertedCells ) );", "+                handleInsertedEdges( filterEdges( insertedCells ) );", "+            }", "+            ", "+            // Now handle edges that became 'dangling' or became connected.  ", "+            Object[] changedCells = change.getChanged(  );", "+            ", "+            if( changedCells != null ) {", "+                handleChangedEdges( filterEdges( changedCells ) );", "+            }", "+        }", "-                for( Iterator i = jVertices.iterator(  ); i.hasNext(  ); ) {", "-                    GraphCell jVertex = (GraphCell) i.next(  );", "-                    if( !m_jVerticesBeingAdded.remove( jVertex ) ) {", "-                        addJGraphVertex( jVertex );", "-                    }", "-                }", "-                for( Iterator i = jEdges.iterator(  ); i.hasNext(  ); ) {", "-                    org.jgraph.graph.Edge jEdge =", "-                        (org.jgraph.graph.Edge) i.next(  );", "-", "-                    if( !m_jEdgesBeingAdded.remove( jEdge ) ) {", "-                        addJGraphEdge( jEdge );", "-                    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f482ab601d902503e024f328ca847bde", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/StrongConnectivityInspector.java", "commitBeforeChange": "f9fe1a9b0c0422b26e26b94edd9001801984e770", "commitAfterChange": "04b4adb9d61a0a7a990979c19fd44e55accd860f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public List stronglyConnectedSets(  )", "signatureAfterChange": "     public List stronglyConnectedSets(  )", "diff": ["-        LinkedList result = new LinkedList(  );", "+        if( m_stronglyConnectedSets == null ) {", "+            m_verticesToVerticesData =", "+                new HashMap( m_graph.vertexSet(  ).size(  ) );", "+            m_orderedVertices           = new LinkedList(  );", "+            m_stronglyConnectedSets =", "+                new Vector( m_graph.vertexSet(  ).size(  ) );", "-        // calculate discover and finish times", "-        AnalyzingDepthFirstIterator iter =", "-            new AnalyzingDepthFirstIterator( m_graph );", "+            // create VertexData objects for all vertices, store them", "+            Iterator iter = m_graph.vertexSet(  ).iterator(  );", "-        while( iter.hasNext(  ) ) {", "-            iter.next(  );", "+            while( iter.hasNext(  ) ) {", "+                Object vertex = iter.next(  );", "+                m_verticesToVerticesData.put( vertex,", "+                    new VertexData( vertex, false, false ) );", "+            }", "+", "+            // perform the first round of DFS, result is an ordering", "+            // of the vertices by decreasing finishing time", "+            iter = m_verticesToVerticesData.values(  ).iterator(  );", "+", "+            while( iter.hasNext(  ) ) {", "+                VertexData data = (VertexData) iter.next(  );", "+", "+                if( !data.m_discovered ) {", "+                    dfsVisit( m_graph, data, null );", "+                }", "+            }", "+", "+            // calculate inverse graph (i.e. every edge is turned)", "+            DirectedGraph inverseGraph = new DefaultDirectedGraph(  );", "+            GraphHelper.addGraphReversed( inverseGraph, m_graph );", "+", "+            // get ready for next dfs round", "+            resetVertexData(  );", "+", "+            // second dfs round: vertices are considered in decreasing", "+            // finishing time order; every tree found is a strongly", "+            // connected set", "+            iter = m_orderedVertices.iterator(  );", "+", "+            while( iter.hasNext(  ) ) {", "+                VertexData data = (VertexData) iter.next(  );", "+", "+                if( !data.m_discovered ) {", "+                    // new strongly connected set", "+                    Set set = new HashSet(  );", "+                    m_stronglyConnectedSets.add( set );", "+                    dfsVisit( inverseGraph, data, set );", "+                }", "+            }", "+", "+            // clean up for garbage collection", "+            m_graph                      = null;", "+            m_orderedVertices            = null;", "+            m_verticesToVerticesData     = null;", "-        Map verticesData = iter.getVerticesData(  );", "+        return m_stronglyConnectedSets;", "+    }", "-        // create inverted graph", "-        DirectedGraph invertedGraph = new DefaultDirectedGraph(  );", "-        GraphHelper.addGraphReversed( invertedGraph, m_graph );", "-        // sort vertices in increasing finish time order", "-        VertexData[] orderedVertices =", "-            new VertexData[ verticesData.values(  ).size(  ) ];", "-        verticesData.values(  ).toArray( orderedVertices );", "-        Arrays.sort( orderedVertices, new FinishingTimeComparator(  ) );", "-        // create DepthFirstOrder forest on inverted graph,", "-        // save trees as strongly connected components", "-        HashSet processedVertices = new HashSet(  );", "-        for( int i = 0; i < orderedVertices.length; i++ ) {", "-            VertexData data = orderedVertices[ i ];", "-            // already contained in one of the trees?", "-            if( !processedVertices.contains( data.getVertex(  ) ) ) {", "-                Set                stronglyConnectedComponent = new HashSet(  );", "-                DepthFirstIterator myIter =", "-                    new DepthFirstIterator( invertedGraph, data.getVertex(  ) );", "-", "-                while( myIter.hasNext(  ) ) {", "-                    Object vertex = myIter.next(  );", "-", "-                    if( !processedVertices.contains( vertex ) ) {", "-                        processedVertices.add( vertex );", "-                        stronglyConnectedComponent.add( vertex );", "-                    }", "-                // save tree", "-                result.add( stronglyConnectedComponent );", "-        }", "-", "-        return result;", "-    }"]}]}