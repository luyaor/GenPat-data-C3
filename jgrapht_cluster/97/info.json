{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1e2204624821ebebd808ce8454d9db55", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f35a5248849f115a2f7ceb1a13cbd11", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "commitAfterChange": "82f01404dfe36eb0f878e007bce7de6e76c70836", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 6, "signatureBeforeChange": "     public GraphPath<V, E> getShortestPath(V a, V b)", "signatureAfterChange": "     public GraphPath<V, E> getShortestPath(V a, V b)", "diff": ["-        lazyCalculatePaths();", "-        return getShortestPathImpl(a, b);", "-    }", "+        lazyCalculateMatrix();", "+        if(backtrace[v_a][v_b]==-1) //No path exists", "+", "+        //Reconstruct the path", "+        List<E> edges = new ArrayList<E>();", "+        int u=v_a;", "+        while(u != v_b){", "+            int v=backtrace[u][v_b];", "+            edges.add(graph.getEdge(vertices.get(u), vertices.get(v)));", "+            u=v;", "+        return new GraphPathImpl<V, E>(graph, a, b, edges, d[v_a][v_b]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "baae8e7dd011b9a45fe82a244406d352", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/EdmondsKarpMaximumFlow.java", "commitBeforeChange": "5f0104ac684044809cb315b79d4a999c5e1da731", "commitAfterChange": "a35680f67c56e8fcc81e697983a084c86d356dae", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "      private void breadthFirstSearch()", "signatureAfterChange": "      private void breadthFirstSearch()", "diff": ["+            nodes.get(i).lastArcs = null;", "+", "+", "+", "+        nodes.get(currentSink).flowAmount = 0.0;", "+", "+        boolean seenSink = false;", "+", "+", "-                    if (!nodes.get(currentArc.head).visited) {", "-                        nodes.get(currentArc.head).visited = true;", "-                        nodes.get(currentArc.head).flowAmount =", "+", "+                    Node currentArcHead = nodes.get(currentArc.head);", "+", "+                    if (currentArc.head == currentSink) {", "+", "+                        currentArcHead.visited = true;", "+", "+                        if (currentArcHead.lastArcs == null)", "+                            currentArcHead.lastArcs = new ArrayList<Arc>();", "+", "+                        currentArcHead.lastArcs.add(currentArc);", "+", "+                        currentArcHead.flowAmount +=", "-                        nodes.get(currentArc.head).lastArc = currentArc;", "-                        queue.add(currentArc.head);", "+", "+                        seenSink = true;", "+", "+                    } else if (!currentArcHead.visited) {", "+", "+                        currentArcHead.visited = true;", "+", "+                        currentArcHead.flowAmount =", "+                            Math.min(", "+                                nodes.get(currentNode).flowAmount,", "+                                currentArc.capacity - currentArc.flow);", "+", "+                        currentArcHead.lastArcs = Collections.singletonList(currentArc);", "+", "+                        if (!seenSink)", "+                            queue.add(currentArc.head);"]}]}