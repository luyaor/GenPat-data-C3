{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9fca75aef41ffa60f819f525f0cdece3", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "20b67a37fa96a9d144be38917e20aaf4", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/ext/JGraphModelAdapter.java", "commitBeforeChange": "a4491f801ff4eba32d8029dda18c582844b268e3", "commitAfterChange": "dca8f0b0b2b997b3562b349da681aa495eb852bf", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 7, "signatureBeforeChange": "     public void remove( Object[] theRoots )", "signatureAfterChange": "     protected boolean addJGraphEdge( org.jgraph.graph.Edge jEdge )", "diff": ["+    protected boolean addJGraphEdge( org.jgraph.graph.Edge jEdge ) {", "+        org._3pq.jgrapht.Edge jtEdge;", "+        Object                jSource = getSourceVertex( this, jEdge );", "+        Object                jTarget = getTargetVertex( this, jEdge );", "+", "+        if( !( m_cellToVertex.containsKey( jSource )", "+                && m_cellToVertex.containsKey( jTarget ) ) ) {", "+            // This is a 'dangling edge'. We have to remove it in the", "+            // JGraph. ", "+            // TODO: Consider alternatives that will allow dangling edges.", "+            Object[] eArray = { jEdge };", "+            m_jEdgesBeingRemoved.add( jEdge );", "+            super.remove( eArray );", "+", "+            return false;", "+        }", "+", "+        Object jtSource = m_cellToVertex.get( jSource );", "+        Object jtTarget = m_cellToVertex.get( jTarget );", "+", "+        if( m_jtGraph instanceof UndirectedGraph ) {", "+            jtEdge = new UndirectedEdge( jtSource, jtTarget );", "+        }", "+        else if( m_jtGraph instanceof DirectedGraph ) {", "+            jtEdge = new DirectedEdge( jtSource, jtTarget );", "+        }", "+        else {", "+            jtEdge =", "+                new org._3pq.jgrapht.edge.DefaultEdge( jtSource, jtTarget );", "+", "+            // We use the JGraph DefaultEdge all the time, so we import", "+            // that and not this version.", "+        }", "+", "+        m_jtEdgesBeingAdded.add( jtEdge );", "+", "+        boolean result = m_jtGraph.addEdge( jtEdge );", "+", "+        if( result ) {", "+            m_cellToEdge.put( jEdge, jtEdge );", "+            m_edgeToCell.put( jtEdge, jEdge );", "+", "+            return true;", "+        }", "+        else {", "+            // Adding the edge failed. We have to remove it from the", "+            // JGraph too.", "+            super.remove( new Object[] { jEdge } );", "+", "+            return false;", "+        }", "-    public void remove( Object[] theRoots ) {", "-        throw new UnsupportedOperationException( ", "-            \"Remove only via the JGraphT graph.\" );", "-    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2a39cb4b5daf8f6019a8237fd83aa6a9", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/StrongConnectivityInspector.java", "commitBeforeChange": "f9fe1a9b0c0422b26e26b94edd9001801984e770", "commitAfterChange": "04b4adb9d61a0a7a990979c19fd44e55accd860f", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 3, "signatureBeforeChange": "         protected void encounterVertexAgain( Object vertex, Edge edge )", "signatureAfterChange": "     private void dfsVisit( DirectedGraph graph, VertexData vertexData,         Set vertices )", "diff": ["+     */", "+    private void dfsVisit( DirectedGraph graph, VertexData vertexData,", "+        Set vertices ) {", "+        Stack stack = new Stack(  );", "+        stack.push( vertexData );", "+        while( !stack.isEmpty(  ) ) {", "+            VertexData data = (VertexData) stack.pop(  );", "+            if( !data.m_discovered ) {", "+                data.m_discovered = true;", "+                if( vertices != null ) {", "+                    vertices.add( data.m_vertex );", "+                // TODO: other way to identify when this vertex is finished!?", "+                stack.push( new VertexData( data, true, true ) );", "+", "+                // follow all edges", "+                Iterator iter =", "+                    graph.outgoingEdgesOf( data.m_vertex ).iterator(  );", "+", "+                while( iter.hasNext(  ) ) {", "+                    DirectedEdge edge       = (DirectedEdge) iter.next(  );", "+                    VertexData   targetData =", "+                        (VertexData) m_verticesToVerticesData.get( edge", "+                            .getTarget(  ) );", "+", "+                    if( !targetData.m_discovered ) {", "+                        // the \"recursion\"", "+                        stack.push( targetData );", "+                    }", "+                }", "-         */", "-        protected void encounterVertexAgain( Object vertex, Edge edge ) {", "-            super.encounterVertexAgain( vertex, edge );", "-", "-            VertexData data = (VertexData) m_vertices.get( vertex );", "-            data.visit( m_time );", "-            m_time++;", "-        }", "+            else if( data.m_finished ) {", "+                if( vertices == null ) {", "+                    // see TODO above", "+                    m_orderedVertices.addFirst( data.m_vertex );", "+                }"]}]}