{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "570bfca1ba80444030a7fa880344a84b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f1c3564f2bb8879472ebeed92ea64dd", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/CycleDetector.java", "commitBeforeChange": "2003496a80f483b98d40a459268e93d0fdaec76c", "commitAfterChange": "618193dfca3ac4de3a61698028cfd965351c74a1", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     public Set<V> findCycles()", "signatureAfterChange": "     public Set<V> findCycles()", "diff": ["+        // ProbeIterator can't be used to handle this case,", "+        // so use StrongConnectivityInspector instead.", "+        StrongConnectivityInspector<V, E> inspector =", "+            new StrongConnectivityInspector<V, E>(graph);", "+        List<Set<V>> components = inspector.stronglyConnectedSets();", "+", "+        // A vertex participates in a cycle if either of the following is", "+        // true:  (a) it is in a component whose size is greater than 1", "+        // or (b) it is a self-loop", "+", "-        execute(set, null);", "+        for (Set<V> component : components) {", "+            if (component.size() > 1) {", "+                // cycle", "+                set.addAll(component);", "+            } else {", "+                V v = component.iterator().next();", "+                if (graph.containsEdge(v, v)) {", "+                    // self-loop", "+                    set.add(v);", "+                }", "+            }", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ba53c6c19340157b774e554506c448e2", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/TarjanLowestCommonAncestor.java", "commitBeforeChange": "5e0a623da07f9a88365fbfbdcfe89366f3ec07c1", "commitAfterChange": "2bc963d635f1387003153797aed8f23b13ab7da1", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tprivate V calculate(final V u)", "signatureAfterChange": " \tprivate void calculate(final V u)", "diff": ["-\tprivate V calculate(final V u) {", "+\tprivate void calculate(final V u) {", "-\t\t    V result = calculate(v);", "-\t\t    // fraction horrible because of the recursion", "-\t\t    if (result != null)", "-\t\t\treturn result;", "+\t\t    calculate(v);", "-\t\tif (black.contains(a) && b.equals(u)) {", "-\t\t    return ancestors.get(uf.find(a));", "-\t\t}", "-\t\tif (black.contains(b) && a.equals(u)) {", "-\t\t    return ancestors.get(uf.find(b));", "-\t\t}", "+\t\tfor (LcaRequestResponse<V> current : lrr)", "+\t\t    if (current.getLca() == null) {", "+\t\t\tif (black.contains(current.getA()) && current.getB().equals(u)) {", "+\t\t\t    current.setLca(ancestors.get(uf.find(current.getA())));", "+\t\t\t}", "+\t\t\tif (black.contains(current.getB()) && current.getA().equals(u)) {", "+\t\t\t    current.setLca(ancestors.get(uf.find(current.getB())));", "+\t\t\t}", "+\t\t    }", "-\t    return null;"]}]}