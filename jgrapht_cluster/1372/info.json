{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8c439f8e78545177dce84eb72ddf6ecf", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0278672186aaf203e9417a0bbd0f8b69", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/VF2AbstractIsomorphismInspector.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public VF2AbstractIsomorphismInspector(             Graph<V, E> graph1,             Graph<V, E> graph2,             Comparator<V> vertexComparator,             Comparator<E> edgeComparator,             boolean cacheEdges)", "signatureAfterChange": "     public VF2AbstractIsomorphismInspector(         Graph<V, E> graph1,         Graph<V, E> graph2,         Comparator<V> vertexComparator,         Comparator<E> edgeComparator,         boolean cacheEdges)", "diff": ["-            Graph<V, E> graph1,", "-            Graph<V, E> graph2,", "-            Comparator<V> vertexComparator,", "-            Comparator<E> edgeComparator,", "-            boolean cacheEdges)", "+        Graph<V, E> graph1,", "+        Graph<V, E> graph2,", "+        Comparator<V> vertexComparator,", "+        Comparator<E> edgeComparator,", "+        boolean cacheEdges)", "-        if (graph1 instanceof Multigraph  || graph2 instanceof Multigraph ||", "-            graph1 instanceof Pseudograph || graph2 instanceof Pseudograph ||", "-            graph1 instanceof DirectedMultigraph ||", "-            graph2 instanceof DirectedMultigraph ||", "-            graph1 instanceof DirectedPseudograph ||", "-            graph2 instanceof DirectedPseudograph)", "-            throw new UnsupportedOperationException(\"graphs with multiple \"", "-                            + \"edges are not supported\");", "+        if ((graph1 instanceof Multigraph)", "+            || (graph2 instanceof Multigraph)", "+            || (graph1 instanceof Pseudograph)", "+            || (graph2 instanceof Pseudograph)", "+            || (graph1 instanceof DirectedMultigraph)", "+            || (graph2 instanceof DirectedMultigraph)", "+            || (graph1 instanceof DirectedPseudograph)", "+            || (graph2 instanceof DirectedPseudograph))", "+        {", "+            throw new UnsupportedOperationException(", "+                \"graphs with multiple \"", "+                + \"edges are not supported\");", "+        }", "-        if (graph1 instanceof DirectedGraph &&", "-                        graph2 instanceof UndirectedGraph ||", "-            graph1 instanceof UndirectedGraph &&", "-                        graph2 instanceof DirectedGraph)", "-            throw new IllegalArgumentException(\"can not match directed with \"", "-                            + \"undirected graphs\");", "+        if (((graph1 instanceof DirectedGraph)", "+                && (graph2 instanceof UndirectedGraph))", "+            || ((graph1 instanceof UndirectedGraph)", "+                && (graph2 instanceof DirectedGraph)))", "+        {", "+            throw new IllegalArgumentException(", "+                \"can not match directed with \"", "+                + \"undirected graphs\");", "+        }", "-        this.graph1           = graph1;", "-        this.graph2           = graph2;", "+        this.graph1 = graph1;", "+        this.graph2 = graph2;", "-        this.edgeComparator   = edgeComparator;", "-        this.ordering1        = new GraphOrdering<V, E>(graph1, true,", "-                                                        cacheEdges);", "-        this.ordering2        = new GraphOrdering<V, E>(graph2, true,", "-                                                        cacheEdges);", "+        this.edgeComparator = edgeComparator;", "+        this.ordering1 = new GraphOrdering<V, E>(graph1, true,", "+            cacheEdges);", "+        this.ordering2 = new GraphOrdering<V, E>(graph2, true,", "+            cacheEdges);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "14af198f4831670ffdefa5b14ac6bdf0", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/ext/JGraphModelAdapter.java", "commitBeforeChange": "56c09b98e6df528eeef0b8df9f8d932a1ba40192", "commitAfterChange": "75098fa5c7281c0f169434b46722c0b4e66b3a8c", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 35, "signatureBeforeChange": "         private void filterEdgesAndVertices( Object[] allCells, Set jEdges,             Set jVertices )", "signatureAfterChange": "         private List filterVertices( Object[] cells )", "diff": ["-         */", "-        private void filterEdgesAndVertices( Object[] allCells, Set jEdges,", "-            Set jVertices ) {", "-            for( int i = 0; i < allCells.length; i++ ) {", "-                Object current = allCells[ i ];", "-                if( current instanceof org.jgraph.graph.Edge ) {", "-                    jEdges.add( current );", "-                }", "-                else if( current instanceof Port ) {", "-                    // ignore it -- we don't care about ports.", "-                }", "-                else if( current instanceof DefaultGraphCell ) {", "-                    DefaultGraphCell graphCell = (DefaultGraphCell) current;", "-", "-                    if( graphCell.isLeaf(  ) // Note: do not change the order", "-                            || ", "-                        // of these conditions; the code uses the short-cutting of ||.", "-                        ( graphCell.getFirstChild(  ) instanceof Port ) ) {", "-                        jVertices.add( current );", "-                    }", "-", "-                    // If a DefaultGraphCell has a Port as a child, it is a", "-                }", "-                else if( current instanceof GraphCell ) {", "-                    // If it is not a DefaultGraphCell, it doesn't have", "-                    // children.", "-                    jVertices.add( current );", "-                }", "-                else {", "-                    // Otherwise, this is neither an Edge nor a GraphCell; ", "-                    // we don't have any use for it -- ignore.", "+         */", "+        private List filterVertices( Object[] cells ) {", "+            List jVertices = new ArrayList();", "+            ", "+            for( int i = 0; i < cells.length; i++ ) {", "+                Object cell = cells[ i ];", "+", "+                if( cell instanceof org.jgraph.graph.Edge ) {", "+                    // ignore -- we don't care about edges.", "+                }", "+                else if( cell instanceof Port ) {", "+                    // ignore -- we don't care about ports.", "+                }", "+                else if( cell instanceof DefaultGraphCell ) {", "+                    DefaultGraphCell graphCell = (DefaultGraphCell) cell;", "+", "+                    // If a DefaultGraphCell has a Port as a child, it is a vertex.", "+                    // Note: do not change the order of following conditions; ", "+                    // the code uses the short-circuit evaluation of ||.", "+                    if( graphCell.isLeaf(  ) ", "+                            || graphCell.getFirstChild(  ) instanceof Port ) {", "+                        jVertices.add( cell );", "+                    }", "+                }", "+                else if( cell instanceof GraphCell ) {", "+                    // If it is not a DefaultGraphCell, it doesn't have", "+                    // children.", "+                    jVertices.add( cell );", "+                }", "+            }", "+            ", "+            return jVertices;"]}]}