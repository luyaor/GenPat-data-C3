{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c46b21b445b055495bda6987c671d222", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3d5273d34e3788a9ce3da46c6e17885d", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/EdmondsKarpMaximumFlow.java", "commitBeforeChange": "a35680f67c56e8fcc81e697983a084c86d356dae", "commitAfterChange": "b4e8f6742028ccb6628bd42dbfef197bf5f06148", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public void calculateMaximumFlow(         V source,         V sink)", "signatureAfterChange": "     public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)", "diff": ["+     */", "+    public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)", "+    {", "+        if (!network.containsVertex(source)) {", "+            throw new IllegalArgumentException(", "+                \"invalid source (null or not from this network)\");", "+        }", "+        if (!network.containsVertex(sink)) {", "+            throw new IllegalArgumentException(", "+                \"invalid sink (null or not from this network)\");", "+        }", "+", "+        if (source.equals(sink)) {", "+            throw new IllegalArgumentException(\"source is equal to sink\");", "+        }", "+", "+        currentSource = indexer.get(source);", "+        currentSink = indexer.get(sink);", "+", "+        for (int i = 0; i < numNodes; i++) {", "+            for (Arc currentArc : nodes.get(i).outgoingArcs) {", "+                currentArc.flow = 0.0;", "+            }", "+        }", "+", "+        final Map<E, Double> maxFlow = new HashMap<E, Double>();", "+", "+        double maxFlowValue;", "+", "+        for (;;) {", "+            breadthFirstSearch();", "+", "+            if (!nodes.get(currentSink).visited) {", "+                maxFlowValue = 0.0;", "+                for (int i = 0; i < numNodes; i++) {", "+                    for (Arc currentArc : nodes.get(i).outgoingArcs) {", "+                        if (currentArc.head == currentSink)", "+                            maxFlowValue += currentArc.flow;", "+", "+                        if (currentArc.prototype != null) {", "+                            maxFlow.put(", "+                                currentArc.prototype,", "+                                currentArc.flow);", "+                        }", "+                    }", "+                }", "+                break;", "+            }", "+", "+            augmentFlow();", "+        }", "+", "+        return new VerbatimMaximumFlow<V, E>(maxFlowValue, maxFlow);", "+    }", "-     */", "-    public void calculateMaximumFlow(", "-        V source,", "-        V sink)", "-    {", "-        if (!network.containsVertex(source)) {", "-            throw new IllegalArgumentException(", "-                \"invalid source (null or not from this network)\");", "-        }", "-        if (!network.containsVertex(sink)) {", "-            throw new IllegalArgumentException(", "-                \"invalid sink (null or not from this network)\");", "-        }", "-", "-        if (source.equals(sink)) {", "-            throw new IllegalArgumentException(\"source is equal to sink\");", "-        }", "-", "-        currentSource = indexer.get(source);", "-        currentSink = indexer.get(sink);", "-", "-        for (int i = 0; i < numNodes; i++) {", "-            for (Arc currentArc : nodes.get(i).outgoingArcs) {", "-                currentArc.flow = 0.0;", "-            }", "-        }", "-        maximumFlowValue = 0.0;", "-        for (;;) {", "-            breadthFirstSearch();", "-            if (!nodes.get(currentSink).visited) {", "-                maximumFlowValue = 0.0;", "-                maximumFlow = new HashMap<E, Double>();", "-                for (int i = 0; i < numNodes; i++) {", "-                    for (Arc currentArc : nodes.get(i).outgoingArcs) {", "-                        if (currentArc.head == currentSink)", "-                            maximumFlowValue += currentArc.flow;", "-", "-                        if (currentArc.prototype != null) {", "-                            maximumFlow.put(", "-                                currentArc.prototype,", "-                                currentArc.flow);", "-", "-                            // _DBG", "-                            //System.out.println(currentArc.prototype + \" : \" + currentArc.capacity + \" : \" + currentArc.flow);", "-                        }", "-                    }", "-                }", "-                return;", "-            }", "-            augmentFlow();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a39407f20bf4220577ef3a2d3f8d2e6", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/DijkstraShortestPath.java", "commitBeforeChange": "2ceefe9200145eb7ccb4779e5535bb11c08686cf", "commitAfterChange": "ade4c3e7f85eb300837fc2abe82dbccf087859d4", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": "      private void createEdgeList(         Graph<V, E> graph,         ClosestFirstIterator<V, E> iter,         V endVertex)", "signatureAfterChange": "      private void createEdgeList(         Graph<V, E> graph,         ClosestFirstIterator<V, E> iter,         V startVertex,         V endVertex)", "diff": ["+        V startVertex,", "-        edgeList = new ArrayList<E>();", "+        List<E> edgeList = new ArrayList<E>();", "+", "+        V v = endVertex;", "-            E edge = iter.getSpanningTreeEdge(endVertex);", "+            E edge = iter.getSpanningTreeEdge(v);", "-            endVertex = Graphs.getOppositeVertex(graph, edge, endVertex);", "+            v = Graphs.getOppositeVertex(graph, edge, v);", "+        double pathLength = iter.getShortestPathLength(endVertex);", "+        path = new GraphPathImpl<V, E>(", "+            graph,", "+            startVertex,", "+            endVertex,", "+            edgeList,", "+            pathLength);"]}]}