{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5393998e33d2c920cbe9a3690ea0d963", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "20b67a37fa96a9d144be38917e20aaf4", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/ext/JGraphModelAdapter.java", "commitBeforeChange": "a4491f801ff4eba32d8029dda18c582844b268e3", "commitAfterChange": "dca8f0b0b2b997b3562b349da681aa495eb852bf", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 7, "signatureBeforeChange": "     public void remove( Object[] theRoots )", "signatureAfterChange": "     protected boolean addJGraphEdge( org.jgraph.graph.Edge jEdge )", "diff": ["+    protected boolean addJGraphEdge( org.jgraph.graph.Edge jEdge ) {", "+        org._3pq.jgrapht.Edge jtEdge;", "+        Object                jSource = getSourceVertex( this, jEdge );", "+        Object                jTarget = getTargetVertex( this, jEdge );", "+", "+        if( !( m_cellToVertex.containsKey( jSource )", "+                && m_cellToVertex.containsKey( jTarget ) ) ) {", "+            // This is a 'dangling edge'. We have to remove it in the", "+            // JGraph. ", "+            // TODO: Consider alternatives that will allow dangling edges.", "+            Object[] eArray = { jEdge };", "+            m_jEdgesBeingRemoved.add( jEdge );", "+            super.remove( eArray );", "+", "+            return false;", "+        }", "+", "+        Object jtSource = m_cellToVertex.get( jSource );", "+        Object jtTarget = m_cellToVertex.get( jTarget );", "+", "+        if( m_jtGraph instanceof UndirectedGraph ) {", "+            jtEdge = new UndirectedEdge( jtSource, jtTarget );", "+        }", "+        else if( m_jtGraph instanceof DirectedGraph ) {", "+            jtEdge = new DirectedEdge( jtSource, jtTarget );", "+        }", "+        else {", "+            jtEdge =", "+                new org._3pq.jgrapht.edge.DefaultEdge( jtSource, jtTarget );", "+", "+            // We use the JGraph DefaultEdge all the time, so we import", "+            // that and not this version.", "+        }", "+", "+        m_jtEdgesBeingAdded.add( jtEdge );", "+", "+        boolean result = m_jtGraph.addEdge( jtEdge );", "+", "+        if( result ) {", "+            m_cellToEdge.put( jEdge, jtEdge );", "+            m_edgeToCell.put( jtEdge, jEdge );", "+", "+            return true;", "+        }", "+        else {", "+            // Adding the edge failed. We have to remove it from the", "+            // JGraph too.", "+            super.remove( new Object[] { jEdge } );", "+", "+            return false;", "+        }", "-    public void remove( Object[] theRoots ) {", "-        throw new UnsupportedOperationException( ", "-            \"Remove only via the JGraphT graph.\" );", "-    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3af8871ef80f3e081c8db65142410ee", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/ext/JGraphModelAdapter.java", "commitBeforeChange": "56c09b98e6df528eeef0b8df9f8d932a1ba40192", "commitAfterChange": "75098fa5c7281c0f169434b46722c0b4e66b3a8c", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 11, "signatureBeforeChange": "     protected boolean addJGraphEdge( org.jgraph.graph.Edge jEdge )", "signatureAfterChange": "     private void internalRemoveCell( GraphCell cell )", "diff": ["-    protected boolean addJGraphEdge( org.jgraph.graph.Edge jEdge ) {", "-        org._3pq.jgrapht.Edge jtEdge;", "-        Object                jSource = getSourceVertex( this, jEdge );", "-        Object                jTarget = getTargetVertex( this, jEdge );", "-", "-        if( !( m_cellToVertex.containsKey( jSource )", "-                && m_cellToVertex.containsKey( jTarget ) ) ) {", "-            // This is a 'dangling edge'. We have to remove it in the", "-            // JGraph.", "-            // TODO: Consider alternatives that will allow dangling edges.", "-            Object[] eArray = { jEdge };", "-            m_jEdgesBeingRemoved.add( jEdge );", "-            remove( eArray );", "-", "-            return false;", "-        }", "-", "-        Object jtSource = m_cellToVertex.get( jSource );", "-        Object jtTarget = m_cellToVertex.get( jTarget );", "-", "-        if( m_jtGraph instanceof UndirectedGraph ) {", "-            jtEdge = new UndirectedEdge( jtSource, jtTarget );", "-        }", "-        else if( m_jtGraph instanceof DirectedGraph ) {", "-            jtEdge = new DirectedEdge( jtSource, jtTarget );", "-            jtEdge =", "-                new org._3pq.jgrapht.edge.DefaultEdge( jtSource, jtTarget );", "-            // We use the JGraph DefaultEdge all the time, so we import", "-            // that and not this version.", "-        }", "-", "-        m_jtEdgesBeingAdded.add( jtEdge );", "-", "-        boolean result = m_jtGraph.addEdge( jtEdge );", "-", "-        if( result ) {", "-            m_cellToEdge.put( jEdge, jtEdge );", "-            m_edgeToCell.put( jtEdge, jEdge );", "-", "-            return true;", "-        }", "-        else {", "-            // Adding the edge failed. We have to remove it from the", "-            // JGraph too.", "-            remove( new Object[] { jEdge } );", "-", "-            return false;", "+     */", "+    private void internalRemoveCell( GraphCell cell ) {", "+        m_jCellsBeingRemoved.add( cell );", "+        remove( new Object[] { cell } );", "+        m_jCellsBeingRemoved.remove( cell );", "+    }"]}]}