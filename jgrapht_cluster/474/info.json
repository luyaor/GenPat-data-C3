{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a8bf1c6a77af7c68599d1fd72968b9f1", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3d5273d34e3788a9ce3da46c6e17885d", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/EdmondsKarpMaximumFlow.java", "commitBeforeChange": "a35680f67c56e8fcc81e697983a084c86d356dae", "commitAfterChange": "b4e8f6742028ccb6628bd42dbfef197bf5f06148", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public void calculateMaximumFlow(         V source,         V sink)", "signatureAfterChange": "     public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)", "diff": ["+     */", "+    public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)", "+    {", "+        if (!network.containsVertex(source)) {", "+            throw new IllegalArgumentException(", "+                \"invalid source (null or not from this network)\");", "+        }", "+        if (!network.containsVertex(sink)) {", "+            throw new IllegalArgumentException(", "+                \"invalid sink (null or not from this network)\");", "+        }", "+", "+        if (source.equals(sink)) {", "+            throw new IllegalArgumentException(\"source is equal to sink\");", "+        }", "+", "+        currentSource = indexer.get(source);", "+        currentSink = indexer.get(sink);", "+", "+        for (int i = 0; i < numNodes; i++) {", "+            for (Arc currentArc : nodes.get(i).outgoingArcs) {", "+                currentArc.flow = 0.0;", "+            }", "+        }", "+", "+        final Map<E, Double> maxFlow = new HashMap<E, Double>();", "+", "+        double maxFlowValue;", "+", "+        for (;;) {", "+            breadthFirstSearch();", "+", "+            if (!nodes.get(currentSink).visited) {", "+                maxFlowValue = 0.0;", "+                for (int i = 0; i < numNodes; i++) {", "+                    for (Arc currentArc : nodes.get(i).outgoingArcs) {", "+                        if (currentArc.head == currentSink)", "+                            maxFlowValue += currentArc.flow;", "+", "+                        if (currentArc.prototype != null) {", "+                            maxFlow.put(", "+                                currentArc.prototype,", "+                                currentArc.flow);", "+                        }", "+                    }", "+                }", "+                break;", "+            }", "+", "+            augmentFlow();", "+        }", "+", "+        return new VerbatimMaximumFlow<V, E>(maxFlowValue, maxFlow);", "+    }", "-     */", "-    public void calculateMaximumFlow(", "-        V source,", "-        V sink)", "-    {", "-        if (!network.containsVertex(source)) {", "-            throw new IllegalArgumentException(", "-                \"invalid source (null or not from this network)\");", "-        }", "-        if (!network.containsVertex(sink)) {", "-            throw new IllegalArgumentException(", "-                \"invalid sink (null or not from this network)\");", "-        }", "-", "-        if (source.equals(sink)) {", "-            throw new IllegalArgumentException(\"source is equal to sink\");", "-        }", "-", "-        currentSource = indexer.get(source);", "-        currentSink = indexer.get(sink);", "-", "-        for (int i = 0; i < numNodes; i++) {", "-            for (Arc currentArc : nodes.get(i).outgoingArcs) {", "-                currentArc.flow = 0.0;", "-            }", "-        }", "-        maximumFlowValue = 0.0;", "-        for (;;) {", "-            breadthFirstSearch();", "-            if (!nodes.get(currentSink).visited) {", "-                maximumFlowValue = 0.0;", "-                maximumFlow = new HashMap<E, Double>();", "-                for (int i = 0; i < numNodes; i++) {", "-                    for (Arc currentArc : nodes.get(i).outgoingArcs) {", "-                        if (currentArc.head == currentSink)", "-                            maximumFlowValue += currentArc.flow;", "-", "-                        if (currentArc.prototype != null) {", "-                            maximumFlow.put(", "-                                currentArc.prototype,", "-                                currentArc.flow);", "-", "-                            // _DBG", "-                            //System.out.println(currentArc.prototype + \" : \" + currentArc.capacity + \" : \" + currentArc.flow);", "-                        }", "-                    }", "-                }", "-                return;", "-            }", "-            augmentFlow();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ea7a0eafd4bace1b5c01d20643eec3e7", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/EdmondsKarpMaximumFlow.java", "commitBeforeChange": "c9321cdd6f93b7e8e241f348de2e975bf226c350", "commitAfterChange": "96bea297cb6d79531586150eeb7ae5f6fce792c9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 8, "signatureBeforeChange": "     public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)", "signatureAfterChange": "      @Override     public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)", "diff": ["-    public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)", "-        if (!network.containsVertex(source)) {", "-            throw new IllegalArgumentException(", "-                \"invalid source (null or not from this network)\");", "-        }", "-        if (!network.containsVertex(sink)) {", "-            throw new IllegalArgumentException(", "-                \"invalid sink (null or not from this network)\");", "-        }", "-        if (source.equals(sink)) {", "-            throw new IllegalArgumentException(\"source is equal to sink\");", "-        }", "-", "-        currentSource = indexer.get(source);", "-        currentSink = indexer.get(sink);", "-", "-        for (int i = 0; i < numNodes; i++) {", "-            for (Arc currentArc : nodes.get(i).outgoingArcs) {", "-                currentArc.flow = 0.0;", "-            }", "-        }", "-", "-        final Map<E, Double> maxFlow = new HashMap<E, Double>();", "-", "-        double maxFlowValue;", "-", "-        for (;;) {", "-            breadthFirstSearch();", "-", "-            if (!nodes.get(currentSink).visited) {", "-                maxFlowValue = 0.0;", "-                for (int i = 0; i < numNodes; i++) {", "-                    for (Arc currentArc : nodes.get(i).outgoingArcs) {", "-                        if (currentArc.head == currentSink)", "-                            maxFlowValue += currentArc.flow;", "-", "-                        if (currentArc.prototype != null) {", "-                            maxFlow.put(", "-                                currentArc.prototype,", "-                                currentArc.flow);", "-                        }", "-                    }", "-                }", "-                break;", "-            }", "-", "-            augmentFlow();", "-        }", "-", "-        return new VerbatimMaximumFlow<V, E>(maxFlowValue, maxFlow);", "+    @Override", "+    public MaximumFlow<V, E> buildMaximumFlow(V source, V sink) {", "+        currentSource   = source;", "+        currentSink     = sink;", "+        build();", "+        return maxFlow;"]}]}