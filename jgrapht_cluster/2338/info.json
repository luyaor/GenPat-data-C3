{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e100991a62747ccededcd74d568ae9d2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1899b573046c5b02f1ca50fff4d745c8", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/graph/AbstractGraph.java", "commitBeforeChange": "8413c0621739087aaa2597f10b6a867735224f2d", "commitAfterChange": "39b789d7e41c82b46b5b0099b4e021514410c6a5", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "     public boolean equals(Object object)", "signatureAfterChange": "     public boolean equals(Object object)", "diff": ["-        if (object == null) return false;", "-        if (!(object instanceof Graph)) return false;", "-        if (getClass() != object.getClass()) return false;", "+        if (object == null || getClass() != object.getClass()) return false;", "+        Set<E> otherEdges = new LinkedHashSet<E>(g.edgeSet());", "+            // first of all we should check that the same vertices are connected in other graph (VK);", "+            V source = getEdgeSource(e);", "+            V target = getEdgeTarget(e);", "+", "+            if (!g.containsEdge(source, target)) return false;", "+", "-                if (!g.containsEdge(getEdgeSource(e), getEdgeTarget(e))) return false;", "-                E edge = g.getEdge(getEdgeSource(e), getEdgeTarget(e)); ", "-                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(edge)) > 10e-7) return false;", "-            } else {", "-                if (!g.containsEdge(e)) return false;", "-                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(e)) > 10e-7) return false;", "-            }", "+                // we also should check if there is any overridden equals() method in hierarchy", "+                // so, users can write their own edge classes as subclasses of DefaultEdge", "+                // with custom implementation of equals() method (VK);", "+                try {", "+                    Method equals = e.getClass().getMethod(\"equals\", new Class<?>[] { Object.class });", "+                    boolean edgeFound = false;", "+                    for (E ee: g.getAllEdges(source, target)) {", "+                        if (!otherEdges.contains(ee)) continue;", "+                        if (equals.getDeclaringClass() != Object.class) {", "+                            if (e.equals(ee)) {", "+                                if (e instanceof DefaultWeightedEdge) {", "+                                    if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(ee)) > 10e-7) return false;", "+                                }", "+                                otherEdges.remove(ee);", "+                                edgeFound = true;", "+                                break;", "+                            }", "+                        } else {", "+                            if (e instanceof DefaultWeightedEdge) {", "+                                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(ee)) < 10e-7) {", "+                                    otherEdges.remove(ee);", "+                                    edgeFound = true;", "+                                    break;", "+                                }", "+                            } else {", "+                                otherEdges.remove(ee);", "+                                edgeFound = true;", "+                                break;", "+                            }", "+                        }", "+                    }", "+                    if (!edgeFound) return false;", "+                } catch (NoSuchMethodException ignored) {", "+                    // should never happens, we always have equals() method (VK);", "+                }", "+            } else if (!otherEdges.remove(e)) return false;", "-        for (E e: g.edgeSet()) {", "-            if (e instanceof IntrusiveEdge) {", "-                if (!containsEdge(g.getEdgeSource(e), g.getEdgeTarget(e))) return false;", "-                E edge = getEdge(g.getEdgeSource(e), g.getEdgeTarget(e)); ", "-                if (Math.abs(g.getEdgeWeight(e) - getEdgeWeight(edge)) > 10e-7) return false;", "-            } else {", "-                if (!containsEdge(e)) return false;", "-                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(e)) > 10e-7) return false;", "-            }", "-        }", "+        // finally, if edges set of the other graph is empty - graphs are equal (VK);", "+        if (!otherEdges.isEmpty()) return false;", "-       return true;", "+        return true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "56a7c57504960c08d78e7cb583c33b68", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/util/FibonacciHeap.java", "commitBeforeChange": "dd14e683f649f6134a6a191da9a4899af88c4041", "commitAfterChange": "b4805f5d86b128879dfab0c1dd754e481a6373b2", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "     protected void consolidate()", "signatureAfterChange": "     protected void consolidate()", "diff": ["-        Node [] array = new Node [arraySize];", "+        List<Node> array = new ArrayList<Node>(arraySize);", "-        for (int i = 0; i < arraySize; i++) {", "-            array[i] = null;", "-        }", "+        for (int i=0; i<arraySize; i++)", "+        \tarray.add(null);", "-            while (array[d] != null) {", "+            while (array.get(d) != null) {", "-                Node y = array[d];", "+                Node y = array.get(d);", "-                array[d] = null;", "+                array.set(d,null);", "-            array[d] = x;", "+            array.set(d,x);", "-            if (array[i] != null) {", "+            if (array.get(i) != null) {", "-                    array[i].m_left.m_right = array[i].m_right;", "-                    array[i].m_right.m_left = array[i].m_left;", "+                    array.get(i).m_left.m_right = array.get(i).m_right;", "+                    array.get(i).m_right.m_left = array.get(i).m_left;", "-                    array[i].m_left = m_min;", "-                    array[i].m_right = m_min.m_right;", "-                    m_min.m_right = array[i];", "-                    array[i].m_right.m_left = array[i];", "+                    array.get(i).m_left = m_min;", "+                    array.get(i).m_right = m_min.m_right;", "+                    m_min.m_right = array.get(i);", "+                    array.get(i).m_right.m_left = array.get(i);", "-                    if (array[i].m_key < m_min.m_key) {", "-                        m_min = array[i];", "+                    if (array.get(i).m_key < m_min.m_key) {", "+                        m_min = array.get(i);", "-                    m_min = array[i];", "+                    m_min = array.get(i);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "992478a522df909617751c08b7d93481", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-ext/src/main/java/org/jgrapht/ext/DOTImporter.java", "commitBeforeChange": "583bedb628992418bdbd952ca092e65831d3b133", "commitAfterChange": "43aa0f5e11b9b56a524f92631cd31dc060fa1ca7", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 14, "signatureBeforeChange": "     private void validateLines(String[] lines,                               AbstractBaseGraph<V,E> graph)          throws ImportException", "signatureAfterChange": "     private void processCompleteEdge(String edge, AbstractBaseGraph<V, E> graph, Map<String, V> vertexes)", "diff": ["-   private void validateLines(String[] lines,", "-                              AbstractBaseGraph<V,E> graph)", "-      if(lines.length < 2) {", "-         throw new ImportException(\"Dot string was invalid\");", "-      }", "-      // validate the first line", "-      String[] firstLine = lines[0].split(\" \", 4);", "-      if(firstLine.length < 3) {", "-         throw new ImportException(\"not enough parts on first line\");", "-      int i = 0;", "-      if (graph.isAllowingMultipleEdges() && firstLine[i].equals(\"strict\")) {", "-         throw new ImportException(", "-               \"graph defines strict but Multigraph given.\"", "-         );", "-      } else if (firstLine[i].equals(\"strict\")) {", "-         i = i + 1;", "-      if (graph instanceof DirectedGraph && firstLine[i].equals(\"graph\") ) {", "-         throw new ImportException(", "-               \"input asks for undirected graph and directed graph provided.\"", "-         );", "-      } else if (!(graph instanceof DirectedGraph)", "-                 && firstLine[i].equals(\"digraph\")) {", "-         throw new ImportException(", "-               \"input asks for directed graph but undirected graph provided.\"", "-         );", "-      } else if(!firstLine[i].equals(\"graph\")", "-                && !firstLine[i].equals(\"digraph\")){", "-         throw new ImportException(\"unknown graph type\");", "+", "+   private void processCompleteEdge(String edge, AbstractBaseGraph<V, E> graph, Map<String, V> vertexes) {", "+      Map<String, String> attributes = extractAttributes(edge);", "+", "+      List<String> ids = extractEdgeIds(edge);", "+", "+      // for each pair of ids in the list create an edge.", "+      for(int i = 0; i < ids.size() - 1; i++) {", "+         V v1 = getVertex(ids.get(i), vertexes, graph);", "+         V v2 = getVertex(ids.get(i+1), vertexes, graph);", "+", "+         E resultEdge = edgeProvider.buildEdge(v1,", "+                                         v2,", "+                                         attributes.get(\"label\"),", "+                                         attributes);", "+         graph.addEdge(v1, v2, resultEdge);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f482ab601d902503e024f328ca847bde", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/StrongConnectivityInspector.java", "commitBeforeChange": "f9fe1a9b0c0422b26e26b94edd9001801984e770", "commitAfterChange": "04b4adb9d61a0a7a990979c19fd44e55accd860f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public List stronglyConnectedSets(  )", "signatureAfterChange": "     public List stronglyConnectedSets(  )", "diff": ["-        LinkedList result = new LinkedList(  );", "+        if( m_stronglyConnectedSets == null ) {", "+            m_verticesToVerticesData =", "+                new HashMap( m_graph.vertexSet(  ).size(  ) );", "+            m_orderedVertices           = new LinkedList(  );", "+            m_stronglyConnectedSets =", "+                new Vector( m_graph.vertexSet(  ).size(  ) );", "-        // calculate discover and finish times", "-        AnalyzingDepthFirstIterator iter =", "-            new AnalyzingDepthFirstIterator( m_graph );", "+            // create VertexData objects for all vertices, store them", "+            Iterator iter = m_graph.vertexSet(  ).iterator(  );", "-        while( iter.hasNext(  ) ) {", "-            iter.next(  );", "+            while( iter.hasNext(  ) ) {", "+                Object vertex = iter.next(  );", "+                m_verticesToVerticesData.put( vertex,", "+                    new VertexData( vertex, false, false ) );", "+            }", "+", "+            // perform the first round of DFS, result is an ordering", "+            // of the vertices by decreasing finishing time", "+            iter = m_verticesToVerticesData.values(  ).iterator(  );", "+", "+            while( iter.hasNext(  ) ) {", "+                VertexData data = (VertexData) iter.next(  );", "+", "+                if( !data.m_discovered ) {", "+                    dfsVisit( m_graph, data, null );", "+                }", "+            }", "+", "+            // calculate inverse graph (i.e. every edge is turned)", "+            DirectedGraph inverseGraph = new DefaultDirectedGraph(  );", "+            GraphHelper.addGraphReversed( inverseGraph, m_graph );", "+", "+            // get ready for next dfs round", "+            resetVertexData(  );", "+", "+            // second dfs round: vertices are considered in decreasing", "+            // finishing time order; every tree found is a strongly", "+            // connected set", "+            iter = m_orderedVertices.iterator(  );", "+", "+            while( iter.hasNext(  ) ) {", "+                VertexData data = (VertexData) iter.next(  );", "+", "+                if( !data.m_discovered ) {", "+                    // new strongly connected set", "+                    Set set = new HashSet(  );", "+                    m_stronglyConnectedSets.add( set );", "+                    dfsVisit( inverseGraph, data, set );", "+                }", "+            }", "+", "+            // clean up for garbage collection", "+            m_graph                      = null;", "+            m_orderedVertices            = null;", "+            m_verticesToVerticesData     = null;", "-        Map verticesData = iter.getVerticesData(  );", "+        return m_stronglyConnectedSets;", "+    }", "-        // create inverted graph", "-        DirectedGraph invertedGraph = new DefaultDirectedGraph(  );", "-        GraphHelper.addGraphReversed( invertedGraph, m_graph );", "-        // sort vertices in increasing finish time order", "-        VertexData[] orderedVertices =", "-            new VertexData[ verticesData.values(  ).size(  ) ];", "-        verticesData.values(  ).toArray( orderedVertices );", "-        Arrays.sort( orderedVertices, new FinishingTimeComparator(  ) );", "-        // create DepthFirstOrder forest on inverted graph,", "-        // save trees as strongly connected components", "-        HashSet processedVertices = new HashSet(  );", "-        for( int i = 0; i < orderedVertices.length; i++ ) {", "-            VertexData data = orderedVertices[ i ];", "-            // already contained in one of the trees?", "-            if( !processedVertices.contains( data.getVertex(  ) ) ) {", "-                Set                stronglyConnectedComponent = new HashSet(  );", "-                DepthFirstIterator myIter =", "-                    new DepthFirstIterator( invertedGraph, data.getVertex(  ) );", "-", "-                while( myIter.hasNext(  ) ) {", "-                    Object vertex = myIter.next(  );", "-", "-                    if( !processedVertices.contains( vertex ) ) {", "-                        processedVertices.add( vertex );", "-                        stronglyConnectedComponent.add( vertex );", "-                    }", "-                // save tree", "-                result.add( stronglyConnectedComponent );", "-        }", "-", "-        return result;", "-    }"]}]}