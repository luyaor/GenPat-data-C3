{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "eccb7063cbb0bf6ec7da64ef297b37ad", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a76d52d7d61d11c82ff2e7d42b7ff74", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/experimental/subgraphisomorphism/VF2SubState.java", "commitBeforeChange": "0f84a6eb9a8e82fa212601f7200f9180f90ead45", "commitAfterChange": "896719167544e845d0c05f24d4c6f4e7be2d6624", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 5, "signatureBeforeChange": "     public boolean isFeasiblePair()", "signatureAfterChange": "     public boolean isFeasiblePair()", "diff": ["-               abortmsg = indent + \"isFeasiblePair> \" + pairstr + \" passt nicht ins aktuelle Matching\";", "+               abortmsg = pairstr + \" does not fit in the current matching\";", "-                    System.out.println(abortmsg + \": Kante von \" + g2.getVertex(addVertex2) +", "-                                    \" nach \" + g2.getVertex(other2) + \" fehlt im 2. Graph\");", "+                    showLog(\"isFeasiblePair\", abortmsg + \": edge from \" +", "+                                    g2.getVertex(addVertex2) + \" to \" +", "+                                    g2.getVertex(other2) +", "+                                    \" is missing in the 2nd graph\");", "-                    System.out.println(abortmsg + \": Kante von \" + g2.getVertex(other2) +", "-                                    \" nach \" + g2.getVertex(addVertex2) + \" fehlt im 2. Graph\");", "+                    showLog(\"isFeasbilePair\", abortmsg + \": edge from \" +", "+                                    g2.getVertex(other2) + \" to \" +", "+                                    g2.getVertex(addVertex2) +", "+                                    \" is missing in the 2nd graph\");", "-                    System.out.println(abortmsg + \": Kante von \" + g1.getVertex(addVertex1) +", "-                                    \" nach \" + g1.getVertex(other1) + \" fehlt im 1. Graph\");", "+                    showLog(\"isFeasbilePair\", abortmsg + \": edge from \" +", "+                                    g1.getVertex(addVertex1) + \" to \" +", "+                                    g1.getVertex(other1) +", "+                                    \" is missing in the 1st graph\");", "-                    System.out.println(abortmsg + \": Kante von \" + g1.getVertex(other1) +", "-                                    \" nach \" + g1.getVertex(addVertex1) + \" fehlt im 1. Graph\");", "+                    showLog(\"isFeasiblePair\", abortmsg + \": edge from \" +", "+                                    g1.getVertex(other1) + \" to \" +", "+                                    g1.getVertex(addVertex1) +", "+                                    \" is missing in the 1st graph\");", "-            System.out.println(indent + \"isFeasiblePair> \" + pairstr + \" passt\");", "+            showLog(\"isFeasiblePair\", pairstr + \" fits\");", "-                cause = \"|Tin2 \u2229 Pred(Graph2, \" + v2 + \")| > |Tin1 \u2229 Pred(Graph1, \" + v1 + \")|\";", "+                cause = \"|Tin2 \u2229 Pred(Graph2, \" + v2 +", "+                    \")| > |Tin1 \u2229 Pred(Graph1, \" + v1 + \")|\";", "-                cause = \"|Tout2 \u2229 Pred(Graph2, \" + v2 + \")| > |Tout1 \u2229 Pred(Graph1, \" + v1 + \")|\";", "+                cause = \"|Tout2 \u2229 Pred(Graph2, \" + v2 +", "+                    \")| > |Tout1 \u2229 Pred(Graph1, \" + v1 + \")|\";", "-                cause = \"|N\u203e \u2229 Pred(Graph2, \" + v2 + \")| > |N\u203e \u2229 Pred(Graph1, \" + v1 + \")|\";", "+                cause = \"|N\u203e \u2229 Pred(Graph2, \" + v2 +", "+                    \")| > |N\u203e \u2229 Pred(Graph1, \" + v1 + \")|\";", "-                cause = \"|Tin2 \u2229 Succ(Graph2, \" + v2 + \")| > |Tin1 \u2229 Succ(Graph1, \" + v1 + \")|\";", "+                cause = \"|Tin2 \u2229 Succ(Graph2, \" + v2 +", "+                    \")| > |Tin1 \u2229 Succ(Graph1, \" + v1 + \")|\";", "-                cause = \"|Tout2 \u2229 Succ(Graph2, \" + v2 + \")| > |Tout1 \u2229 Succ(Graph1, \" + v1 + \")|\";", "+                cause = \"|Tout2 \u2229 Succ(Graph2, \" + v2 +", "+                    \")| > |Tout1 \u2229 Succ(Graph1, \" + v1 + \")|\";", "-                cause = \"|N\u203e \u2229 Succ(Graph2, \" + v2 + \")| > |N\u203e \u2229 Succ(Graph1, \" + v1 + \")|\";", "+                cause = \"|N\u203e \u2229 Succ(Graph2, \" + v2 +", "+                    \")| > |N\u203e \u2229 Succ(Graph1, \" + v1 + \")|\";", "-            System.out.println(abortmsg + \": \" + cause);", "+            showLog(\"isFeasbilePair\", abortmsg + \": \" + cause);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8848ef09509b81edadd35e5f223054fb", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/test/java/org/jgrapht/alg/flow/MaximumFlowAlgorithmTestBase.java", "commitBeforeChange": "62325cdd7548d0cf930d478a885b2a08e669b9bb", "commitAfterChange": "6a8a4c15d51c52101d91cd979c3d30cc12195d89", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "      private void checkPushRelabel(SimpleDirectedWeightedGraph<Integer, DefaultWeightedEdge> network, Integer source, Integer sink)", "signatureAfterChange": "      private static void check(MaximumFlow<Integer, DefaultWeightedEdge> maxFlow, int source, int sink, DirectedGraph<Integer, DefaultWeightedEdge> network)", "diff": ["-    private void checkPushRelabel(SimpleDirectedWeightedGraph<Integer, DefaultWeightedEdge> network, Integer source, Integer sink) {", "-        MaximumFlow<Integer, DefaultWeightedEdge> pr = new PushRelabelMaximumFlow<Integer, DefaultWeightedEdge>(network).buildMaximumFlow(source, sink);", "-", "-        System.out.println(\"------------\");", "-        System.out.println(\"PUSH-RELABEL\");", "-        System.out.println(\"------------\");", "-", "-        dumpFlow(pr);", "-", "-        MaximumFlowAlgorithmTestBase.verify(source, sink, pr.getValue(), network, pr);", "+    private static void check(MaximumFlow<Integer, DefaultWeightedEdge> maxFlow, int source, int sink, DirectedGraph<Integer, DefaultWeightedEdge> network) {", "+        MaximumFlowAlgorithmTestBase.verify(source, sink, maxFlow.getValue(), network, maxFlow);", "+        dumpFlow(maxFlow);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a0bd77eefc2dde466f112a5032492dd3", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/generate/GridGraphGenerator.java", "commitBeforeChange": "9fccd288aecb7a6be4551f716b437c4367e54366", "commitAfterChange": "182e90616a442256f64c34fe7c36c675d95227ef", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     @Override public void generateGraph(         Graph<V, E> target,         VertexFactory<V> vertexFactory,         Map<String, V> resultMap)", "signatureAfterChange": "     @Override public void generateGraph(         Graph<V, E> target,         VertexFactory<V> vertexFactory,         Map<String, V> resultMap)", "diff": ["-        Map<String, V> map = new TreeMap<String, V>();", "+        Map<Integer, V> map = new TreeMap<Integer, V>();", "-        //Adding all vertices to the set", "+        // Adding all vertices to the set", "-            map.put(String.valueOf(i + 1), vertex);", "+            map.put(i + 1, vertex);", "-        //Iterating twice over the key set, for undirected graph edges are added", "-        //from upper vertices to lower, and from left to right. the second", "-        //addEdge call will return nothing; it will not add a the edge at the", "-        //opposite direction. For directed graph, edges in opposite direction", "-        //are also added.", "-        for (String i : map.keySet()) {", "-            for (String j : map.keySet()) {", "-                if ((((Integer.valueOf(i) % cols) > 0)", "-                        && ((Integer.valueOf(i) + 1) == Integer.valueOf(j)))", "-                    || ((Integer.valueOf(i) + cols) == Integer.valueOf(j)))", "+        // Iterating twice over the key set, for undirected graph edges are", "+        // added from upper vertices to lower, and from left to right. The", "+        // second addEdge call will return nothing; it will not add a the edge", "+        // at the opposite direction. For directed graph, edges in opposite", "+        // direction are also added.", "+        for (int i : map.keySet()) {", "+            for (int j : map.keySet()) {", "+                if ((((i % cols) > 0)", "+                        && (i + 1 == Integer.valueOf(j)))", "+                    || ((i + cols) == j))"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bb80f6294479f3770de1cb7702c276c5", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/demo/PerformanceDemo.java", "commitBeforeChange": "0363545e8290260126e9c13c52724dd67b796b7e", "commitAfterChange": "d7b11005f4a4271e0f5137bcf7a8bb639ef393f0", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "       private static void reportElapsedFor( String msg, long startTime )", "signatureAfterChange": "       private static long usedMemory(  )", "diff": ["-    private static void reportElapsedFor( String msg, long startTime ) {", "-        double time = ( System.currentTimeMillis(  ) - startTime ) / 1000;", "-        System.out.println( msg + \" (\" + time + \" secs)\" );", "+", "+    private static long usedMemory(  ) {", "+        Runtime rt = Runtime.getRuntime(  );", "+", "+        return rt.totalMemory(  ) - rt.freeMemory(  );"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf1c07fc4d838bf875cabc20c86b8a1f", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/experimental/subgraphisomorphism/SubgraphIsomorphismRelation.java", "commitBeforeChange": "af1b824446ff484516d50232b001351d46878322", "commitAfterChange": "7e936137877a73e8b9c1b2921fc4174c64f683c0", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "      @Override     public String toString()", "signatureAfterChange": "      @Override     public String toString()", "diff": ["-", "-        // somehow enforce an ordering on the vertices of g1..", "-        TreeSet<V> vertexSet = new TreeSet<V>(g1.getGraph().vertexSet());", "-        for (V v : vertexSet)", "-            str += v.toString() + \"=\" +(hasVertexCorrespondence(v) ?", "-                            getVertexCorrespondence(v, true) : \"~~\") + \" \";", "-        return str.substring(0, str.length() - 1) + \"]\";", "+        Set<V> vertexSet = g1.getGraph().vertexSet();", "+        ", "+        int i = 0;", "+        for (V v : vertexSet)   {", "+            V u = getVertexCorrespondence(v, true);", "+            str += (i++ == 0 ? \"\" : \" \") + v.toString() + \"=\" +", "+                            (u == null ? \"~~\" : u);", "+        }", "+        ", "+        return str + \"]\";"]}]}