{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cce5cf422035ec55cc57b536d413be7e", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "62ae05424b10c222a76f650e01512c48", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/MinSourceSinkCut.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic Set<E> getCutEdges()", "signatureAfterChange": "     public Set<E> getCutEdges()", "diff": ["-\t */", "-\tpublic Set<E> getCutEdges(){", "-\t\tif(minCut==null)", "-\t\t\treturn null;", "-\t\tSet<E> cutEdges=new HashSet<E>();", "-\t\tfor(V vertex: minCut){", "-\t\t\tfor(E edge: graph.outgoingEdgesOf(vertex)){", "-\t\t\t\tif(!minCut.contains(Graphs.getOppositeVertex(graph, edge, vertex)))", "-\t\t\t\t\tcutEdges.add(edge);", "-\t\t\t}", "-\t\t}", "-\t\treturn Collections.unmodifiableSet(cutEdges);", "-\t}", "+     */", "+    public Set<E> getCutEdges()", "+    {", "+        if (minCut == null) {", "+            return null;", "+        }", "+        Set<E> cutEdges = new HashSet<E>();", "+        for (V vertex : minCut) {", "+            for (E edge : graph.outgoingEdgesOf(vertex)) {", "+                if (!minCut.contains(", "+                        Graphs.getOppositeVertex(graph, edge, vertex)))", "+                {", "+                    cutEdges.add(edge);", "+                }", "+            }", "+        }", "+        return Collections.unmodifiableSet(cutEdges);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "71b0422e576a77d779ad618949036656", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "testsrc/org/_3pq/jgrapht/experimental/alg/VertexCoverAlgorithmTest.java", "commitBeforeChange": "a61c430f2ac7af9e4b0519b792fa90091fa0462d", "commitAfterChange": "3dfe7bd3c3baf72541946589aad20525c29233c0", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprivate boolean isSolution(Collection possibleSolution)", "signatureAfterChange": "     private boolean isCover( Set vertexSet, Pseudograph g )", "diff": ["-\t */", "-\tprivate boolean isSolution(Collection possibleSolution) {", "-\t\tSet edgesToCover = new HashSet(graph.edgeSet());", "-\t\tfor (Iterator iVertices = possibleSolution.iterator();", "-\t\t\t iVertices.hasNext();", "-\t\t\t ) {", "-\t\t\tedgesToCover.removeAll(new ArrayList(graph.edgesOf(iVertices.next())));", "-\t\t}", "-\t\tif (edgesToCover.size() == 0) {", "-\t\t\treturn true;", "-\t\t}", "-\t\telse {", "-\t\t\treturn false;", "-\t\t}", "-\t}", "+     */", "+    private boolean isCover( Set vertexSet, Pseudograph g ) {", "+        Set uncoveredEdges = new HashSet( g.edgeSet(  ) );", "+", "+        for( Iterator i = vertexSet.iterator(  ); i.hasNext(  ); ) {", "+            uncoveredEdges.removeAll( g.edgesOf( i.next(  ) ) );", "+        }", "+", "+        return uncoveredEdges.size(  ) == 0;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9065579007b84370012625c6b9644664", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/NaiveLcaFinder.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private Set<V> allParents(Set<V> vertexSet)", "signatureAfterChange": "     private Set<V> allParents(Set<V> vertexSet)", "diff": ["-    private Set<V> allParents(Set<V> vertexSet) {", "-\tHashSet<V> result = new HashSet<V>();", "-\tfor (V e : vertexSet) {", "-\t    for (E edge : graph.incomingEdgesOf(e)) {", "-\t\tif (graph.getEdgeTarget(edge).equals(e))", "-\t\t    result.add(graph.getEdgeSource(edge));", "-\t    }", "-\t}", "-\treturn result;", "+    private Set<V> allParents(Set<V> vertexSet)", "+    {", "+        HashSet<V> result = new HashSet<V>();", "+        for (V e : vertexSet) {", "+            for (E edge : graph.incomingEdgesOf(e)) {", "+                if (graph.getEdgeTarget(edge).equals(e)) {", "+                    result.add(graph.getEdgeSource(edge));", "+                }", "+            }", "+        }", "+        return result;"]}]}