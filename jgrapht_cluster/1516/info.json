{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "efbd845ec568f450caffd511173cdcaa", "detectedBy": ["DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3a3528ecf7ef54a5f7b5728d7a89d49e", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/alg/VertexCoverGreedyAlgorithm.java", "commitBeforeChange": "a61c430f2ac7af9e4b0519b792fa90091fa0462d", "commitAfterChange": "3dfe7bd3c3baf72541946589aad20525c29233c0", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic Collection vertexCover()", "signatureAfterChange": "     public Set findCover(  )", "diff": ["-\t */", "-\tpublic Collection vertexCover() {", "-\t\t// C <-- \ufffd", "-\t\tSet currentCover = new HashSet();", "-\t\t// G' <-- G", "-\t\tPseudograph graphToCover = (Pseudograph) graph.clone();", "-\t\t// while G' != \ufffd", "-\t\twhile (graphToCover.edgeSet().size() > 0) {", "-\t\t\t// v <-- vertex with maximum degree in G'", "-\t\t\t// sort vertices in descending order of degree", "-\t\t\tSet originalVertexSet = graphToCover.vertexSet();", "-\t\t\tVertexComparator comp = new VertexComparator(graphToCover, false);", "-\t\t\tList sortedVertexList = new ArrayList(originalVertexSet);", "-\t\t\tCollections.sort(sortedVertexList, comp);", "-\t\t\tObject v = sortedVertexList.get(0);", "-\t\t\t// C <-- C U {v}", "-\t\t\tcurrentCover.add(v);", "-\t\t\t// remove from G' every edge incident on v, and v itself", "-\t\t\tgraphToCover.removeAllEdges(", "-\t\t\t\tnew ArrayList(graphToCover.edgesOf(v)));", "-\t\t\t} // end while", "-\t\treturn currentCover;", "-\t}\t", "+     */", "+    public Set findCover(  ) {", "+        // C <-- \ufffd", "+        Set cover = new HashSet(  );", "+", "+        // G' <-- G", "+        Subgraph g = new Subgraph( m_graph, null, null );", "+", "+        // compare vertices in descending order of degree", "+        VertexDegreeComparator comp = new VertexDegreeComparator( g );", "+", "+        // while G' != \ufffd", "+        while( g.edgeSet(  ).size(  ) > 0 ) {", "+            // v <-- vertex with maximum degree in G'", "+            Object v = Collections.max( g.vertexSet(  ), comp );", "+", "+            // C <-- C U {v}", "+            cover.add( v );", "+", "+            // remove from G' every edge incident on v, and v itself", "+            g.removeVertex( v );", "+        }", "+", "+        return cover;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b79cb277416fb6f6d12ae1269ca6853", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/experimental/alg/VertexCoverApproximationAlgorithm.java", "commitBeforeChange": "a61c430f2ac7af9e4b0519b792fa90091fa0462d", "commitAfterChange": "3dfe7bd3c3baf72541946589aad20525c29233c0", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic Collection vertexCover()", "signatureAfterChange": "     public Set findCover(  )", "diff": ["-\t */", "-\tpublic Collection vertexCover() {", "-\t\t// C <-- \ufffd", "-\t\tSet currentCover = new HashSet();", "-\t\t// E' <-- E // set of edges of G", "-\t\tSet edgesToCover = new HashSet(graph.edgeSet());", "-\t\t// while E' != empty set", "-\t\twhile (!edgesToCover.isEmpty()) {", "-\t\t\t// let (u,v) be an arbitrary edge of E'", "-\t\t\tEdge e = (Edge) edgesToCover.iterator().next();", "-\t\t\t// C <-- C U {u,v}", "-\t\t\tObject u = e.getSource();", "-\t\t\tObject v = e.getTarget();", "-\t\t\tcurrentCover.add(u);", "-\t\t\tcurrentCover.add(v);", "-\t\t\t// remove from E' every edge incident on either u or v", "-\t\t\tList incidentU = graph.edgesOf(u);", "-\t\t\tedgesToCover.removeAll(incidentU);", "-\t\t\tList incidentV = graph.edgesOf(v);", "-\t\t\tedgesToCover.removeAll(incidentV);", "-\t\t} // end while", "-\t\t// return C", "-\t\treturn currentCover;", "-\t}\t\t", "+     */", "+    public Set findCover(  ) {", "+        // C <-- \ufffd", "+        Set cover = new HashSet(  );", "+", "+        // G'=(V',E') <-- G(V,E)", "+        Subgraph g = new Subgraph( m_graph, null, null );", "+", "+        // while E' is non-empty", "+        while( g.edgeSet(  ).size(  ) > 0 ) {", "+            // let (u,v) be an arbitrary edge of E'", "+            Edge e = (Edge) g.edgeSet(  ).iterator(  ).next(  );", "+", "+            // C <-- C U {u,v}", "+            Object u = e.getSource(  );", "+            Object v = e.getTarget(  );", "+            cover.add( u );", "+            cover.add( v );", "+", "+            // remove from E' every edge incident on either u or v", "+            g.removeVertex( u );", "+            g.removeVertex( v );", "+        }", "+", "+        return cover; // return C", "+    }"]}]}