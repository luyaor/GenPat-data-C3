{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8ac9d1a919e0e37d9bc664086d9499d2", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0ea89a232f00e4d12a6b257fa074b843", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-ext/src/main/java/org/jgrapht/ext/DOTImporter.java", "commitBeforeChange": "583bedb628992418bdbd952ca092e65831d3b133", "commitAfterChange": "43aa0f5e11b9b56a524f92631cd31dc060fa1ca7", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "    public void read(String input, AbstractBaseGraph<V, E> graph)          throws ImportException", "signatureAfterChange": "    public void read(String input, AbstractBaseGraph<V, E> graph)          throws ImportException", "diff": ["-      String[] lines = input.split(\"[;\\r\\n]\");", "-", "-      validateLines(lines, graph);", "-", "-      // cache of vertexes added to the graph.", "-      for(int lineIndex = 1; lineIndex < lines.length - 1; lineIndex ++ ) {", "-         String line = lines[lineIndex].trim();", "+      int state = HEADER;", "+      int lastState = HEADER;", "+      int position = 0;", "-         // trim off line comments.", "-         if (line.contains(\"//\")) {", "-            line = line.substring(0, line.indexOf(\"//\"));", "-         }", "+      StringBuilder sectionBuffer = new StringBuilder();", "-         // with \\r\\n or just ;\\n line ends we get blanks. Filter here.", "-         if(line.isEmpty()) {", "-            continue;", "-         }", "-", "-         if (line.startsWith(\"#\")) {", "-            // line comment so ignore", "-            // TODO: block comments", "-         } else if (!line.contains(\"[\") && line.contains(\"=\")) {", "-            throw new ImportException(", "-                  \"graph level properties are not currently supported.\"", "-            );", "-         } else if (isVertexLine(line)) {", "-            // probably a vertex", "-            Map<String, String> attributes = extractAttributes(line);", "-", "-            String id = line.trim();", "-            int bracketIndex = line.indexOf('[');", "-            if (bracketIndex > 0) {", "-               id = line.substring(0, line.indexOf('[')).trim();", "-            }", "-", "-            String label = attributes.get(\"label\");", "-            if (label == null) {", "-               label = id;", "-            }", "-", "-            V existing = vertexes.get(id);", "-            if (existing == null) {", "-               V vertex = vertexProvider.buildVertex(label, attributes);", "-               graph.addVertex(vertex);", "-               vertexes.put(id, vertex);", "-            } else {", "-               if (vertexUpdater != null) {", "-                  vertexUpdater.updateVertex(existing, attributes);", "-               } else {", "-                  throw new ImportException(", "-                        \"Update required for vertex \"", "-                        + label", "-                        + \" but no vertexUpdater provided\"", "-                  );", "+      while (state != DONE && position < input.length()) {", "+         int existingState = state;", "+         switch(state) {", "+            case HEADER:", "+               state = processHeader(input, position, sectionBuffer, graph);", "+               break;", "+            case NODE:", "+               state = processNode(input, position, sectionBuffer, graph, vertexes);", "+               break;", "+            case EDGE:", "+               state = processEdge(input, position, sectionBuffer, graph, vertexes);", "+               break;", "+            case LINE_COMMENT:", "+               state = processLineComment(input, position, sectionBuffer, lastState);", "+               if (state == lastState) {", "+                  // when we leave a line comment we need the new line to still appear in the old block", "+                  position = position - 1;", "-            }", "-         } else {", "-            Map<String, String> attributes = extractAttributes(line);", "-", "-            List<String> ids = extractEdgeIds(line);", "-", "-            // for each pair of ids in the list create an edge.", "-            for(int i = 0; i < ids.size() - 1; i++) {", "-               V v1 = getVertex(ids.get(i), vertexes, graph);", "-               V v2 = getVertex(ids.get(i+1), vertexes, graph);", "-", "-               E edge = edgeProvider.buildEdge(v1,", "-                                               v2,", "-                                               attributes.get(\"label\"),", "-                                               attributes);", "-               graph.addEdge(v1, v2, edge);", "-            }", "+               break;", "+            case BLOCK_COMMENT:", "+               state = processBlockComment(input, position, lastState);", "+               break;", "+            case NODE_QUOTES:", "+               state = processNodeQuotes(input, position, sectionBuffer);", "+               break;", "+            case EDGE_QUOTES:", "+               state = processEdgeQuotes(input, position, sectionBuffer);", "+               break;", "+            case NEXT:", "+               state = processNext(input, position, sectionBuffer, graph, vertexes);", "+               break;", "+            // DONE not included here as we can't get to it with the while loop.", "+            default:", "+               throw new ImportException(\"Error importing escaped state machine\");", "+         position = position + 1;", "+", "+         if (state != existingState) {", "+            lastState = existingState;", "+         }", "+", "+      }", "+", "+      // if we get to the end and are some how still in the header the input must be invalid.", "+      if(state == HEADER) {", "+         throw new ImportException(\"Invalid Header\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f4235111fdaa6ee29a952330ba8f9d4e", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/HopcroftKarpBipartiteMatching.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \t \tprivate List<LinkedList<V>> getAugmentingPaths()", "signatureAfterChange": "      private List<LinkedList<V>> getAugmentingPaths()", "diff": ["+", "+    private List<LinkedList<V>> getAugmentingPaths()", "+    {", "+        List<LinkedList<V>> augmentingPaths = new ArrayList<LinkedList<V>>();", "+", "+        //1. Build data structure", "+        Map<V, Set<V>> layeredMap = new HashMap<V, Set<V>>();", "+        for (V vertex : unmatchedVertices1) {", "+            layeredMap.put(vertex, new HashSet<V>());", "+        }", "+", "+        Set<V> oddLayer = new HashSet<V>(unmatchedVertices1); //Layer L0 contains the unmatchedVertices1.", "+        Set<V> evenLayer;", "+        Set<V> usedVertices = new HashSet<V>(unmatchedVertices1);", "+", "+        while (true) {", "+            //Create a new even Layer A new layer can ONLY contain vertices", "+            //which are not used in the previous layers Edges between odd and", "+            //even layers can NOT be part of the matching", "+            evenLayer = new HashSet<V>();", "+            for (V vertex : oddLayer) {", "+                //List<V> neighbors=this.getNeighbors(vertex);", "+                List<V> neighbors = Graphs.neighborListOf(graph, vertex);", "+                for (V neighbor : neighbors) {", "+                    if (usedVertices.contains(neighbor)) {", "+                        // Vertices placed into odd-layer may not be matched by", "+                        // any other vertices except for the one we came from", "+                        continue;", "+                    } else {", "+                        evenLayer.add(neighbor);", "+                        if (!layeredMap.containsKey(neighbor)) {", "+                            layeredMap.put(neighbor, new HashSet<V>());", "+                        }", "+                        layeredMap.get(neighbor).add(vertex);", "+                    }", "+                }", "+            }", "+            usedVertices.addAll(evenLayer);", "+", "+            //Check whether we are finished generating layers. We are finished", "+            //if 1. the last layer is empty or 2. if we reached free vertices", "+            //in partition2.", "+            if ((evenLayer.size() == 0)", "+                || this.interSectionNotEmpty(evenLayer, unmatchedVertices2))", "+            {", "+                break;", "+            }", "+", "+            //Create a new odd Layer A new layer can ONLY contain vertices which", "+            //are not used in the previous layers Edges between EVEN and ODD", "+            //layers SHOULD be part of the matching", "+            oddLayer = new HashSet<V>();", "+            for (V vertex : evenLayer) {", "+                List<V> neighbors = Graphs.neighborListOf(graph, vertex);", "+                for (V neighbor : neighbors) {", "+                    if (usedVertices.contains(neighbor)", "+                        || !matching.contains(", "+                            graph.getEdge(vertex, neighbor)))", "+                    {", "+                        continue;", "+                    } else {", "+                        oddLayer.add(neighbor);", "+                        if (!layeredMap.containsKey(neighbor)) {", "+                            layeredMap.put(neighbor, new HashSet<V>());", "+                        }", "+                        layeredMap.get(neighbor).add(vertex);", "+                    }", "+                }", "+            }", "+            usedVertices.addAll(oddLayer);", "+        }", "+", "+        //Check whether there exist augmenting paths. If not, return an empty", "+        //list. Else, we need to generate the augmenting paths which start at", "+        //free vertices in the even layer and end at the free vertices at the", "+        //first odd layer (L0).", "+        if (evenLayer.size() == 0) {", "+            return augmentingPaths;", "+        } else {", "+            evenLayer.retainAll(unmatchedVertices2);", "+        }", "+", "+        //Finally, do a depth-first search, starting on the free vertices in the", "+        //last even layer. Objective is to find as many vertex disjoint paths", "+        //as possible.", "+        for (V vertex : evenLayer) {", "+            //Calculate an augmenting path, starting at the given vertex.", "+            LinkedList<V> augmentingPath = dfs(vertex, layeredMap);", "+", "+            //If the augmenting path exists, add it to the list of paths and", "+            //remove the vertices from the map to enforce that the paths are", "+            //vertex disjoint, i.e. a vertex cannot occur in more than 1 path.", "+            if (augmentingPath != null) {", "+                augmentingPaths.add(augmentingPath);", "+                for (V augmentingVertex : augmentingPath) {", "+                    layeredMap.remove(augmentingVertex);", "+                }", "+            }", "+        }", "+", "+        return augmentingPaths;", "+    }", "-\t", "-\tprivate List<LinkedList<V>> getAugmentingPaths(){", "-\t\tList<LinkedList<V>> augmentingPaths=new ArrayList<LinkedList<V>>();", "-\t\t", "-\t\t//1. Build data structure", "-\t\tMap<V,Set<V>> layeredMap= new HashMap<V,Set<V>>();", "-\t\tfor(V vertex:unmatchedVertices1)", "-\t\t\tlayeredMap.put(vertex, new HashSet<V>());", "-\t\t", "-\t\tSet<V> oddLayer=new HashSet<V>(unmatchedVertices1); //Layer L0 contains the unmatchedVertices1.", "-\t\tSet<V> evenLayer;", "-\t\tSet<V> usedVertices=new HashSet<V>(unmatchedVertices1);", "-\t\t", "-\t\twhile(true){", "-\t\t\t//Create a new even Layer", "-\t\t\t//A new layer can ONLY contain vertices which are not used in the previous layers", "-\t\t\t//Edges between odd and even layers can NOT be part of the matching", "-\t\t\tevenLayer=new HashSet<V>();", "-\t\t\tfor(V vertex: oddLayer){", "-\t\t\t\t//List<V> neighbors=this.getNeighbors(vertex);", "-\t\t\t\tList<V> neighbors=Graphs.neighborListOf(graph, vertex);", "-\t\t\t\tfor(V neighbor: neighbors){", "-", "-", "-\t\t\t\t\tif(usedVertices.contains(neighbor))", "-            // Vertices placed into odd-layer may not be matched by any other vertices except for the one", "-            // we came from", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\telse{", "-\t\t\t\t\t\tevenLayer.add(neighbor);", "-\t\t\t\t\t\tif(!layeredMap.containsKey(neighbor))", "-\t\t\t\t\t\t\tlayeredMap.put(neighbor, new HashSet<V>());", "-\t\t\t\t\t\tlayeredMap.get(neighbor).add(vertex);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tusedVertices.addAll(evenLayer);", "-\t\t\t", "-\t\t\t//Check whether we are finished generating layers.", "-\t\t\t//We are finished if 1. the last layer is empty or 2. if we reached free vertices in partition2.", "-\t\t\tif(evenLayer.size()==0 || this.interSectionNotEmpty(evenLayer, unmatchedVertices2))", "-\t\t\t\tbreak;", "-\t\t\t", "-\t\t\t//Create a new odd Layer", "-\t\t\t//A new layer can ONLY contain vertices which are not used in the previous layers", "-\t\t\t//Edges between EVEN and ODD layers SHOULD be part of the matching", "-\t\t\toddLayer=new HashSet<V>();", "-\t\t\tfor(V vertex: evenLayer){", "-\t\t\t\tList<V> neighbors=Graphs.neighborListOf(graph, vertex);", "-\t\t\t\tfor(V neighbor: neighbors){", "-\t\t\t\t\tif(usedVertices.contains(neighbor) || !matching.contains(graph.getEdge(vertex, neighbor)))", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\telse{", "-\t\t\t\t\t\toddLayer.add(neighbor);", "-\t\t\t\t\t\tif(!layeredMap.containsKey(neighbor))", "-\t\t\t\t\t\t\tlayeredMap.put(neighbor, new HashSet<V>());", "-\t\t\t\t\t\tlayeredMap.get(neighbor).add(vertex);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tusedVertices.addAll(oddLayer);", "-\t\t}", "-\t\t", "-\t\t//Check whether there exist augmenting paths. If not, return an empty list.", "-\t\t//Else, we need to generate the augmenting paths which start at free vertices in", "-\t\t//the even layer and end at the free vertices at the first odd layer (L0).", "-\t\tif(evenLayer.size()==0){", "-\t\t\treturn augmentingPaths;", "-\t\t}else{", "-\t\t\tevenLayer.retainAll(unmatchedVertices2);", "-\t\t}", "-\t\t", "-\t\t//Finally, do a depth-first search, starting on the free vertices in the last even layer.", "-\t\t//Objective is to find as many vertex disjoint paths as possible.", "-\t\tfor(V vertex : evenLayer){", "-\t\t\t//Calculate an augmenting path, starting at the given vertex.", "-\t\t\tLinkedList<V> augmentingPath=dfs(vertex,layeredMap);", "-", "-\t\t\t//If the augmenting path exists, add it to the list of paths and remove the vertices", "-\t\t\t//from the map to enforce that the paths are vertex disjoint, i.e. a vertex cannot occur in", "-\t\t\t//more than 1 path.", "-\t\t\tif(augmentingPath!=null){", "-\t\t\t\taugmentingPaths.add(augmentingPath);", "-\t\t\t\tfor(V augmentingVertex: augmentingPath)", "-\t\t\t\t\tlayeredMap.remove(augmentingVertex);", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\treturn augmentingPaths;", "-\t}"]}]}