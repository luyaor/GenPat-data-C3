{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "89772c354aa217379405566e2c02c09d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ffc117edf0c98784151d85cd0a54a93", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/RankingPathElementList.java", "commitBeforeChange": "94e0b9cdbd464a6b60ddbb8cd6d473a32e102eaf", "commitAfterChange": "90d794caa7b37ed092890eb859473902af3157bc", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public boolean addPathElements(         RankingPathElementList<V, E> elementList,         E edge)", "signatureAfterChange": "     public boolean addPathElements(         RankingPathElementList<V, E> elementList,         E edge)", "diff": ["-            if (isAlreadyImprovedByThisEdge(edge, prevPathElement)", "-                || containsTargetPreviously(prevPathElement))", "-            {", "-                // checks if path is simple.", "+", "+            if (isNotValidPath(prevPathElement, edge)) {", "+                // checks if path is simple and if guard-vertex is not", "+                // disconnected.", "-            double weight = calculatePathWeight(prevPathElement, edge);", "+            double newPathWeight = calculatePathWeight(prevPathElement, edge);", "+            RankingPathElement<V, E> newPathElement =", "+                new RankingPathElement<V, E>(", "+                    this.graph,", "+                    prevPathElement,", "+                    edge,", "+                    newPathWeight);", "-            // loop over the paths elements of the list at vertex y from yIndex", "-            // to the end.", "+            // loop over the paths of the list at vertex y from yIndex to the", "+            // end.", "+            RankingPathElement<V, E> yPathElement = null;", "-                RankingPathElement<V, E> yPathElement = get(yIndex);", "-                RankingPathElement<V, E> newPathElement =", "-                    new RankingPathElement<V, E>(", "-                        this.graph,", "-                        prevPathElement,", "-                        edge,", "-                        weight);", "+                yPathElement = get(yIndex);", "-                if (weight < yPathElement.getWeight()) {", "+                // case when the new path is shorter than the path Py stored at", "+                // index y", "+                if (newPathWeight < yPathElement.getWeight()) {", "+                    pathAdded = true;", "+", "+                    // ensures max size limit is not exceeded.", "-                    pathAdded = true;", "-                if (weight == yPathElement.getWeight()) {", "-                    // checks if newPathElement is not already in the list.", "-                    if (isAlreadyAdded(newPathElement)) {", "-                        break;", "-                    }", "-                    if (size() <= (this.maxSize - 1)) {", "-                        this.pathElements.add(yIndex + 1, newPathElement);", "-                        if (size() > this.maxSize) {", "-                            this.pathElements.remove(this.maxSize);", "-                        }", "-                        pathAdded = true;", "-                        break;", "+                // case when the new path is of the same length as the path Py", "+                // stored at index y", "+                if (newPathWeight == yPathElement.getWeight()) {", "+                    this.pathElements.add(yIndex + 1, newPathElement);", "+                    pathAdded = true;", "+", "+                    // ensures max size limit is not exceeded.", "+                    if (size() > this.maxSize) {", "+                        this.pathElements.remove(this.maxSize);", "+                    break;", "+            }", "-                if ((weight > yPathElement.getWeight())", "-                    && (yIndex == (size() - 1)))", "-                {", "-                    if (size() <= (this.maxSize - 1)) {", "-                        this.pathElements.add(newPathElement);", "-                        pathAdded = true;", "-                        break;", "-                    }", "+            // case when the new path is longer than the longest path in the", "+            // list (Py stored at the last index y)", "+            if (newPathWeight > yPathElement.getWeight()) {", "+                // ensures max size limit is not exceeded.", "+                if (size() < this.maxSize) {", "+                    // the new path is inserted at the end of the list.", "+                    this.pathElements.add(newPathElement);", "+                    pathAdded = true;", "+                } else {", "+                    // max size limit is reached -> end of the loop over the", "+                    // paths elements of the list at vertex v.", "+                    break;", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "888deeb8012bcb8b8eab93bb740fe6c7", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/_3pq/jgrapht/alg/StrongConnectivityInspector.java", "commitBeforeChange": "04b4adb9d61a0a7a990979c19fd44e55accd860f", "commitAfterChange": "ccbda858621a3d1beb6a9381a0fc81c3673ee66c", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public List stronglyConnectedSets(  )", "signatureAfterChange": "     public List stronglyConnectedSets()", "diff": ["-    public List stronglyConnectedSets(  ) {", "-        if( m_stronglyConnectedSets == null ) {", "-            m_verticesToVerticesData =", "-                new HashMap( m_graph.vertexSet(  ).size(  ) );", "-            m_orderedVertices           = new LinkedList(  );", "-            m_stronglyConnectedSets =", "-                new Vector( m_graph.vertexSet(  ).size(  ) );", "+    public List stronglyConnectedSets() {", "+        if (m_stronglyConnectedSets == null) {", "+", "+            m_orderedVertices = new LinkedList();", "+            m_stronglyConnectedSets = new Vector();", "-            Iterator iter = m_graph.vertexSet(  ).iterator(  );", "-", "-            while( iter.hasNext(  ) ) {", "-                Object vertex = iter.next(  );", "-                m_verticesToVerticesData.put( vertex,", "-                    new VertexData( vertex, false, false ) );", "-            }", "+            createVertexData();", "-            iter = m_verticesToVerticesData.values(  ).iterator(  );", "+            Iterator iter = m_vertexToVertexData.values().iterator();", "-            while( iter.hasNext(  ) ) {", "-                VertexData data = (VertexData) iter.next(  );", "+            while (iter.hasNext()) {", "+                VertexData data = (VertexData) iter.next();", "-                if( !data.m_discovered ) {", "-                    dfsVisit( m_graph, data, null );", "+                if (!data.m_discovered) {", "+                    dfsVisit(m_graph, data, null);", "-            // calculate inverse graph (i.e. every edge is turned)", "-            DirectedGraph inverseGraph = new DefaultDirectedGraph(  );", "-            GraphHelper.addGraphReversed( inverseGraph, m_graph );", "+            // calculate inverse graph (i.e. every edge is reversed)", "+            DirectedGraph inverseGraph = new DefaultDirectedGraph();", "+            GraphHelper.addGraphReversed(inverseGraph, m_graph);", "-            resetVertexData(  );", "+            resetVertexData();", "-            iter = m_orderedVertices.iterator(  );", "+            iter = m_orderedVertices.iterator();", "-            while( iter.hasNext(  ) ) {", "-                VertexData data = (VertexData) iter.next(  );", "+            while (iter.hasNext()) {", "+                VertexData data = (VertexData) iter.next();", "-                if( !data.m_discovered ) {", "+                if (!data.m_discovered) {", "-                    Set set = new HashSet(  );", "-                    m_stronglyConnectedSets.add( set );", "-                    dfsVisit( inverseGraph, data, set );", "+                    Set set = new HashSet();", "+                    m_stronglyConnectedSets.add(set);", "+                    dfsVisit(inverseGraph, data, set);", "-            m_graph                      = null;", "-            m_orderedVertices            = null;", "-            m_verticesToVerticesData     = null;", "+            m_orderedVertices = null;", "+            m_vertexToVertexData = null;"]}]}