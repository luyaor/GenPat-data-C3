{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d0f5ff730ba27d0370f61b93a936567a", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c9a0e77a6fa8ab8bf9c93ce5ff2f2af", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/CliqueMinimalSeparatorDecomposition.java", "commitBeforeChange": "b338dc522beb4643906288a4c91571a7ab1b1795", "commitAfterChange": "8b53e2969b312c1e6f35e85a43bc0437bf413b79", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r     private void computeMinimalTriangulation()", "signatureAfterChange": "     private void computeMinimalTriangulation()", "diff": ["-     */\r", "-    private void computeMinimalTriangulation()\r", "-    {\r", "-        // initialize chordGraph with same vertices as graph\r", "-        chordalGraph = new SimpleGraph<V, E>(graph.getEdgeFactory());\r", "-        for (V v : graph.vertexSet())\r", "-            chordalGraph.addVertex(v);\r", "-\r", "-        // initialize g' as subgraph of graph (same vertices and edges)\r", "-        final UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);\r", "-        int s = -1;\r", "-        generators = new ArrayList<V>();\r", "-        meo = new LinkedList<V>();\r", "-\r", "-        final Map<V, Integer> vertexLabels = new HashMap<V, Integer>();\r", "-        for (V v : gprime.vertexSet()) {\r", "-            vertexLabels.put(v, 0);\r", "-        }\r", "-        for (int i = 1, n = graph.vertexSet().size(); i <= n; i++) {\r", "-            V v = getMaxLabelVertex(vertexLabels);\r", "-            LinkedList<V> Y = new LinkedList<V>(\r", "-                Graphs.neighborListOf(gprime, v));\r", "-\r", "-            if (vertexLabels.get(v) <= s)\r", "-                generators.add(v);\r", "-\r", "-            s = vertexLabels.get(v);\r", "-\r", "-            // Mark x reached and all other vertices of gprime unreached\r", "-            HashSet<V> reached = new HashSet<V>();\r", "-            reached.add(v);\r", "-\r", "-            // mark neighborhood of x reached and add to reach(label(y))\r", "-            HashMap<Integer, HashSet<V>> reach = \r", "-                new HashMap<Integer, HashSet<V>>();\r", "-\r", "-            // mark y reached and add y to reach\r", "-            for (V y : Y) {\r", "-                reached.add(y);\r", "-                addToReach(vertexLabels.get(y), y, reach);\r", "-            }\r", "-\r", "-            for (int j = 0; j < graph.vertexSet().size(); j++) {\r", "-                if (!reach.containsKey(j)) {\r", "-                    continue;\r", "-                }\r", "-                while (reach.get(j).size() > 0) {\r", "-                    // remove a vertex y from reach(j)\r", "-                    V y = reach.get(j).iterator().next();\r", "-                    reach.get(j).remove(y);\r", "-\r", "-                    for (V z : Graphs.neighborListOf(gprime, y)) {\r", "-                        if (!reached.contains(z)) {\r", "-                            reached.add(z);\r", "-                            if (vertexLabels.get(z) > j) {\r", "-                                Y.add(z);\r", "-                                E fillEdge = graph.getEdgeFactory().createEdge(\r", "-                                    v,\r", "-                                    z);\r", "-                                fillEdges.add(fillEdge);\r", "-                                addToReach(vertexLabels.get(z), z, reach);\r", "-                            } else {\r", "-                                addToReach(j, z, reach);\r", "-                            }\r", "-                        }\r", "-                    }\r", "-\r", "-                }\r", "-            }\r", "-\r", "-            for (V y : Y) {\r", "-                chordalGraph.addEdge(v, y);\r", "-                vertexLabels.put(y, vertexLabels.get(y) + 1);\r", "-            }\r", "-\r", "-            meo.addLast(v);\r", "-            gprime.removeVertex(v);\r", "-            vertexLabels.remove(v);\r", "-        }\r", "-    }\r", "+     */", "+    private void computeMinimalTriangulation()", "+    {", "+        // initialize chordGraph with same vertices as graph", "+        chordalGraph = new SimpleGraph<V, E>(graph.getEdgeFactory());", "+        for (V v : graph.vertexSet()) {", "+            chordalGraph.addVertex(v);", "+        }", "+", "+        // initialize g' as subgraph of graph (same vertices and edges)", "+        final UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);", "+        int s = -1;", "+        generators = new ArrayList<V>();", "+        meo = new LinkedList<V>();", "+", "+        final Map<V, Integer> vertexLabels = new HashMap<V, Integer>();", "+        for (V v : gprime.vertexSet()) {", "+            vertexLabels.put(v, 0);", "+        }", "+        for (int i = 1, n = graph.vertexSet().size(); i <= n; i++) {", "+            V v = getMaxLabelVertex(vertexLabels);", "+            LinkedList<V> Y =", "+                new LinkedList<V>(", "+                    Graphs.neighborListOf(gprime, v));", "+", "+            if (vertexLabels.get(v) <= s) {", "+                generators.add(v);", "+            }", "+", "+            s = vertexLabels.get(v);", "+", "+            // Mark x reached and all other vertices of gprime unreached", "+            HashSet<V> reached = new HashSet<V>();", "+            reached.add(v);", "+", "+            // mark neighborhood of x reached and add to reach(label(y))", "+            HashMap<Integer, HashSet<V>> reach =", "+                new HashMap<Integer, HashSet<V>>();", "+", "+            // mark y reached and add y to reach", "+            for (V y : Y) {", "+                reached.add(y);", "+                addToReach(vertexLabels.get(y), y, reach);", "+            }", "+", "+            for (int j = 0; j < graph.vertexSet().size(); j++) {", "+                if (!reach.containsKey(j)) {", "+                    continue;", "+                }", "+                while (reach.get(j).size() > 0) {", "+                    // remove a vertex y from reach(j)", "+                    V y = reach.get(j).iterator().next();", "+                    reach.get(j).remove(y);", "+", "+                    for (V z : Graphs.neighborListOf(gprime, y)) {", "+                        if (!reached.contains(z)) {", "+                            reached.add(z);", "+                            if (vertexLabels.get(z) > j) {", "+                                Y.add(z);", "+                                E fillEdge =", "+                                    graph.getEdgeFactory().createEdge(", "+                                        v,", "+                                        z);", "+                                fillEdges.add(fillEdge);", "+                                addToReach(vertexLabels.get(z), z, reach);", "+                            } else {", "+                                addToReach(j, z, reach);", "+                            }", "+                        }", "+                    }", "+                }", "+            }", "+", "+            for (V y : Y) {", "+                chordalGraph.addEdge(v, y);", "+                vertexLabels.put(y, vertexLabels.get(y) + 1);", "+            }", "+", "+            meo.addLast(v);", "+            gprime.removeVertex(v);", "+            vertexLabels.remove(v);", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8d1304d747c9a3d12fd376e0398c15ca", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "testsrc/org/jgrapht/alg/util/UnionFindTest.java", "commitBeforeChange": "b5348f8a80e818c9b0dd566a68eb23f3eca4389b", "commitAfterChange": "29039f1f20cd2b1397eba3afdb9fc72182dd2062", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     private boolean same(ArrayList<ArrayList<String>> sets, String a, String b)", "signatureAfterChange": "      private boolean same(ArrayList<ArrayList<String>> sets, String a, String b)", "diff": ["-    }", "-    private boolean same(ArrayList<ArrayList<String>> sets, String a, String b)", "-    {", "-        for(ArrayList<String> set:sets)", "-            if(set.contains(a) && set.contains(b))", "-                return true;", "-        return false;", "-    }", "+    private boolean same(ArrayList<ArrayList<String>> sets, String a, String b)", "+    {", "+        for (ArrayList<String> set : sets) {", "+            if (set.contains(a) && set.contains(b)) {", "+                return true;", "+            }", "+        }", "+        return false;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e9c8bd0df5fbe10ffec9f1bd04f474ca", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/HopcroftKarpBipartiteMatching.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " \tprivate boolean interSectionNotEmpty(Set<V> vertexSet1, Set<V> vertexSet2)", "signatureAfterChange": "     private boolean interSectionNotEmpty(Set<V> vertexSet1, Set<V> vertexSet2)", "diff": ["+     */", "+    private boolean interSectionNotEmpty(Set<V> vertexSet1, Set<V> vertexSet2)", "+    {", "+        for (V vertex : vertexSet1) {", "+            if (vertexSet2.contains(vertex)) {", "+            }", "+        }", "+        return false;", "+    }", "-\t */", "-\tprivate boolean interSectionNotEmpty(Set<V> vertexSet1, Set<V> vertexSet2){", "-\t\tfor(V vertex: vertexSet1)", "-\t\t\tif(vertexSet2.contains(vertex))", "-\t\t\t\treturn true;", "-\t\treturn false;", "-\t}"]}]}