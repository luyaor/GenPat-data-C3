{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "96ae6d964ac08fe4ad0809ac7f91922e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "10e42b755d8e655175d2c316873547c2", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/test/java/org/jgrapht/alg/flow/MaximumFlowAlgorithmTestBase.java", "commitBeforeChange": "16877ce18b6445d7238b8a78693c87c95971617b", "commitAfterChange": "024fc7b86a9ced21b7444077ac5895f2b6a50bf9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 8, "signatureBeforeChange": "      private void runTest(         int [] tails,         int [] heads,         double [] capacities,         int [] sources,         int [] sinks,         double [] expectedResults)", "signatureAfterChange": "      private void runTest(         int [] tails,         int [] heads,         double [] capacities,         int [] sources,         int [] sinks,         double [] expectedResults)", "diff": ["+", "-            MaximumFlowAlgorithm.MaximumFlow<Integer, DefaultWeightedEdge> maxFlow = solver.buildMaximumFlow(sources[i], sinks[i]);", "+            verify(sources[i], sinks[i], expectedResults[i], network, solver.buildMaximumFlow(sources[i], sinks[i]));", "+        }", "+    }", "-            assertEquals(", "-                expectedResults[i],", "-                maxFlow.getValue(),", "-                EdmondsKarpMaximumFlow.DEFAULT_EPSILON);", "-            Double flowValue = maxFlow.getValue();", "-            Map<DefaultWeightedEdge, Double> flow = maxFlow.getFlow();", "-            for (DefaultWeightedEdge e : network.edgeSet()) {", "-                assertTrue(flow.containsKey(e));", "-", "-            for (DefaultWeightedEdge e : flow.keySet()) {", "-                assertTrue(network.containsEdge(e));", "-                assertTrue(", "-                    flow.get(e) >= -EdmondsKarpMaximumFlow.DEFAULT_EPSILON);", "-                assertTrue(", "-                    flow.get(e)", "-                        <= (network.getEdgeWeight(e)", "-                        + EdmondsKarpMaximumFlow.DEFAULT_EPSILON));", "-", "-            for (Integer v : network.vertexSet()) {", "-                double balance = 0.0;", "-                for (DefaultWeightedEdge e : network.outgoingEdgesOf(v)) {", "-                    balance -= flow.get(e);", "-                }", "-                for (DefaultWeightedEdge e : network.incomingEdgesOf(v)) {", "-                    balance += flow.get(e);", "-                }", "-                if (v.equals(sources[i])) {", "-                    assertEquals(", "-                        -flowValue,", "-                        balance,", "-                        MaximumFlowAlgorithmBase.DEFAULT_EPSILON);", "-                } else if (v.equals(sinks[i])) {", "-                    assertEquals(", "-                        flowValue,", "-                        balance,", "-                        MaximumFlowAlgorithmBase.DEFAULT_EPSILON);", "-                } else {", "-                    assertEquals(", "-                        0.0,", "-                        balance,", "-                        MaximumFlowAlgorithmBase.DEFAULT_EPSILON);", "-                }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34e974e239e91bbfd6494580774d5375", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "e5d892ea988755999c21c3831434c4fc251611da", "commitAfterChange": "60fae450bc7df1fe1188f2da01fd4eefb4912b4d", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public FloydWarshallShortestPaths(Graph<V, E> g)", "signatureAfterChange": "      public FloydWarshallShortestPaths(Graph<V, E> graph)", "diff": ["+    public FloydWarshallShortestPaths(Graph<V, E> graph) {", "+        this.graph = graph;", "+        this.vertices = new ArrayList<V>(graph.vertexSet());", "+    }", "-    public FloydWarshallShortestPaths(Graph<V, E> g)", "-    {", "-        int sz = g.vertexSet().size();", "-        d = new double[sz][sz];", "-        indices = new HashMap<V, Integer>();", "-        //Initialise distance to infinity, or the neighbours weight, or 0 if", "-        //same", "-        for (V v1 : g.vertexSet()) {", "-            for (V v2 : g.vertexSet()) {", "-                if (v1 == v2) {", "-                    d[index(v1)][index(v2)] = 0;", "-                } else {", "-                    E e = g.getEdge(v1, v2);", "-                    if (e == null) {", "-                        d[index(v1)][index(v2)] = Double.POSITIVE_INFINITY;", "-                    } else {", "-                        d[index(v1)][index(v2)] = g.getEdgeWeight(e);", "-", "-        //now iterate k times", "-        for (int k = 0; k < sz; k++) {", "-            for (V v1 : g.vertexSet()) {", "-                for (V v2 : g.vertexSet()) {", "-                    d[index(v1)][index(v2)] =", "-                        Math.min(", "-                            d[index(v1)][index(v2)],", "-                            d[index(v1)][k] + d[k][index(v2)]);", "-                    diameter = Math.max(diameter, d[index(v1)][index(v2)]);", "-                }", "-            }", "-        }", "-    }"]}]}