{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "96e83f5a90d4a929712870b4de829db9", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1899b573046c5b02f1ca50fff4d745c8", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/graph/AbstractGraph.java", "commitBeforeChange": "8413c0621739087aaa2597f10b6a867735224f2d", "commitAfterChange": "39b789d7e41c82b46b5b0099b4e021514410c6a5", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "     public boolean equals(Object object)", "signatureAfterChange": "     public boolean equals(Object object)", "diff": ["-        if (object == null) return false;", "-        if (!(object instanceof Graph)) return false;", "-        if (getClass() != object.getClass()) return false;", "+        if (object == null || getClass() != object.getClass()) return false;", "+        Set<E> otherEdges = new LinkedHashSet<E>(g.edgeSet());", "+            // first of all we should check that the same vertices are connected in other graph (VK);", "+            V source = getEdgeSource(e);", "+            V target = getEdgeTarget(e);", "+", "+            if (!g.containsEdge(source, target)) return false;", "+", "-                if (!g.containsEdge(getEdgeSource(e), getEdgeTarget(e))) return false;", "-                E edge = g.getEdge(getEdgeSource(e), getEdgeTarget(e)); ", "-                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(edge)) > 10e-7) return false;", "-            } else {", "-                if (!g.containsEdge(e)) return false;", "-                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(e)) > 10e-7) return false;", "-            }", "+                // we also should check if there is any overridden equals() method in hierarchy", "+                // so, users can write their own edge classes as subclasses of DefaultEdge", "+                // with custom implementation of equals() method (VK);", "+                try {", "+                    Method equals = e.getClass().getMethod(\"equals\", new Class<?>[] { Object.class });", "+                    boolean edgeFound = false;", "+                    for (E ee: g.getAllEdges(source, target)) {", "+                        if (!otherEdges.contains(ee)) continue;", "+                        if (equals.getDeclaringClass() != Object.class) {", "+                            if (e.equals(ee)) {", "+                                if (e instanceof DefaultWeightedEdge) {", "+                                    if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(ee)) > 10e-7) return false;", "+                                }", "+                                otherEdges.remove(ee);", "+                                edgeFound = true;", "+                                break;", "+                            }", "+                        } else {", "+                            if (e instanceof DefaultWeightedEdge) {", "+                                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(ee)) < 10e-7) {", "+                                    otherEdges.remove(ee);", "+                                    edgeFound = true;", "+                                    break;", "+                                }", "+                            } else {", "+                                otherEdges.remove(ee);", "+                                edgeFound = true;", "+                                break;", "+                            }", "+                        }", "+                    }", "+                    if (!edgeFound) return false;", "+                } catch (NoSuchMethodException ignored) {", "+                    // should never happens, we always have equals() method (VK);", "+                }", "+            } else if (!otherEdges.remove(e)) return false;", "-        for (E e: g.edgeSet()) {", "-            if (e instanceof IntrusiveEdge) {", "-                if (!containsEdge(g.getEdgeSource(e), g.getEdgeTarget(e))) return false;", "-                E edge = getEdge(g.getEdgeSource(e), g.getEdgeTarget(e)); ", "-                if (Math.abs(g.getEdgeWeight(e) - getEdgeWeight(edge)) > 10e-7) return false;", "-            } else {", "-                if (!containsEdge(e)) return false;", "-                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(e)) > 10e-7) return false;", "-            }", "-        }", "+        // finally, if edges set of the other graph is empty - graphs are equal (VK);", "+        if (!otherEdges.isEmpty()) return false;", "-       return true;", "+        return true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ffc117edf0c98784151d85cd0a54a93", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/RankingPathElementList.java", "commitBeforeChange": "94e0b9cdbd464a6b60ddbb8cd6d473a32e102eaf", "commitAfterChange": "90d794caa7b37ed092890eb859473902af3157bc", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public boolean addPathElements(         RankingPathElementList<V, E> elementList,         E edge)", "signatureAfterChange": "     public boolean addPathElements(         RankingPathElementList<V, E> elementList,         E edge)", "diff": ["-            if (isAlreadyImprovedByThisEdge(edge, prevPathElement)", "-                || containsTargetPreviously(prevPathElement))", "-            {", "-                // checks if path is simple.", "+", "+            if (isNotValidPath(prevPathElement, edge)) {", "+                // checks if path is simple and if guard-vertex is not", "+                // disconnected.", "-            double weight = calculatePathWeight(prevPathElement, edge);", "+            double newPathWeight = calculatePathWeight(prevPathElement, edge);", "+            RankingPathElement<V, E> newPathElement =", "+                new RankingPathElement<V, E>(", "+                    this.graph,", "+                    prevPathElement,", "+                    edge,", "+                    newPathWeight);", "-            // loop over the paths elements of the list at vertex y from yIndex", "-            // to the end.", "+            // loop over the paths of the list at vertex y from yIndex to the", "+            // end.", "+            RankingPathElement<V, E> yPathElement = null;", "-                RankingPathElement<V, E> yPathElement = get(yIndex);", "-                RankingPathElement<V, E> newPathElement =", "-                    new RankingPathElement<V, E>(", "-                        this.graph,", "-                        prevPathElement,", "-                        edge,", "-                        weight);", "+                yPathElement = get(yIndex);", "-                if (weight < yPathElement.getWeight()) {", "+                // case when the new path is shorter than the path Py stored at", "+                // index y", "+                if (newPathWeight < yPathElement.getWeight()) {", "+                    pathAdded = true;", "+", "+                    // ensures max size limit is not exceeded.", "-                    pathAdded = true;", "-                if (weight == yPathElement.getWeight()) {", "-                    // checks if newPathElement is not already in the list.", "-                    if (isAlreadyAdded(newPathElement)) {", "-                        break;", "-                    }", "-                    if (size() <= (this.maxSize - 1)) {", "-                        this.pathElements.add(yIndex + 1, newPathElement);", "-                        if (size() > this.maxSize) {", "-                            this.pathElements.remove(this.maxSize);", "-                        }", "-                        pathAdded = true;", "-                        break;", "+                // case when the new path is of the same length as the path Py", "+                // stored at index y", "+                if (newPathWeight == yPathElement.getWeight()) {", "+                    this.pathElements.add(yIndex + 1, newPathElement);", "+                    pathAdded = true;", "+", "+                    // ensures max size limit is not exceeded.", "+                    if (size() > this.maxSize) {", "+                        this.pathElements.remove(this.maxSize);", "+                    break;", "+            }", "-                if ((weight > yPathElement.getWeight())", "-                    && (yIndex == (size() - 1)))", "-                {", "-                    if (size() <= (this.maxSize - 1)) {", "-                        this.pathElements.add(newPathElement);", "-                        pathAdded = true;", "-                        break;", "-                    }", "+            // case when the new path is longer than the longest path in the", "+            // list (Py stored at the last index y)", "+            if (newPathWeight > yPathElement.getWeight()) {", "+                // ensures max size limit is not exceeded.", "+                if (size() < this.maxSize) {", "+                    // the new path is inserted at the end of the list.", "+                    this.pathElements.add(newPathElement);", "+                    pathAdded = true;", "+                } else {", "+                    // max size limit is reached -> end of the loop over the", "+                    // paths elements of the list at vertex v.", "+                    break;", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5d679a9bb48a4bf3214b8150098e1ed", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/graph/AbstractGraph.java", "commitBeforeChange": "2cb98d0c1094fff00a22763c10d4fd59f71eaae5", "commitAfterChange": "4efd29b14c87e09927591be73abc578e10bee63c", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "     public boolean equals(Object object)", "signatureAfterChange": "     public boolean equals(Object obj)", "diff": ["-    public boolean equals(Object object)", "+    public boolean equals(Object obj)", "-        if (this == object) return true;", "-        if (object == null || getClass() != object.getClass()) return false;", "+        if (this == obj) {", "+            return true;", "+        }", "+        if (obj == null || getClass() != obj.getClass()) {", "+            return false;", "+        }", "-        Graph<V, E> g = TypeUtil.uncheckedCast(object, typeDecl);", "+        Graph<V, E> g = TypeUtil.uncheckedCast(obj, typeDecl);", "-        if (!vertexSet().equals(g.vertexSet())) return false;", "+        if (!vertexSet().equals(g.vertexSet())) {", "+            return false;", "+        }", "+        if (edgeSet().size() != g.edgeSet().size()) {", "+            return false;", "+        }", "-        Set<E> otherEdges = new LinkedHashSet<E>(g.edgeSet());", "-            // first of all we should check that the same vertices are connected in other graph (VK);", "-            if (!g.containsEdge(source, target)) return false;", "-", "-            if (e instanceof IntrusiveEdge) {", "-                // we also should check if there is any overridden equals() method in hierarchy", "-                // so, users can write their own edge classes as subclasses of DefaultEdge", "-                // with custom implementation of equals() method (VK);", "-                try {", "-                    Method equals = e.getClass().getMethod(\"equals\", new Class<?>[] { Object.class });", "-                    boolean edgeFound = false;", "-                    for (E ee: g.getAllEdges(source, target)) {", "-                        if (!otherEdges.contains(ee)) continue;", "-                        if (equals.getDeclaringClass() != Object.class) {", "-                            if (e.equals(ee)) {", "-                                if (e instanceof DefaultWeightedEdge) {", "-                                    if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(ee)) > 10e-7) return false;", "-                                }", "-                                otherEdges.remove(ee);", "-                                edgeFound = true;", "-                                break;", "-                            }", "-                        } else {", "-                            if (e instanceof DefaultWeightedEdge) {", "-                                if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(ee)) < 10e-7) {", "-                                    otherEdges.remove(ee);", "-                                    edgeFound = true;", "-                                    break;", "-                                }", "-                            } else {", "-                                otherEdges.remove(ee);", "-                                edgeFound = true;", "-                                break;", "-                            }", "-                        }", "+            boolean found = false;", "+            for (E ee: g.getAllEdges(source, target)) {", "+                if (e == ee || e.equals(ee)) {", "+                    if (e != ee && Math.abs(getEdgeWeight(e) ", "+                        - g.getEdgeWeight(ee)) > 10e-7)", "+                    {", "+                        return false;", "-                    if (!edgeFound) return false;", "-                } catch (NoSuchMethodException ignored) {", "-                    // should never happens, we always have equals() method (VK);", "+                    found = true;", "+                    break;", "-            } else if (!otherEdges.remove(e)) return false;", "-        }", "+            }", "-        // finally, if edges set of the other graph is empty - graphs are equal (VK);", "-        if (!otherEdges.isEmpty()) return false;", "+            if (!found) {", "+                return false;", "+            }", "+        }"]}]}