{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "14265cf51f800edd14fccfb4a6075bc6", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9dfc25bbb22d1e541650cfee20a57f56", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/MinSourceSinkCut.java", "commitBeforeChange": "2368f894a5f86458e6220ed61039dad10454d9ab", "commitAfterChange": "8bbdd0b15ef2a408186085d20f1a6fb81ea81686", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void computeMinCut(V source, V sink)", "signatureAfterChange": "     public void computeMinCut(V source, V sink)", "diff": ["-\t */", "-\tpublic void computeMinCut(V source, V sink){", "-\t\tthis.source=source;", "-\t\tthis.sink=sink;", "-\t\tminCut=new HashSet<V>();", "-\t\t//First compute a maxFlow from source to sink", "-\t\tekMaxFlow.calculateMaximumFlow(source, sink);", "-\t\tthis.cutWeight=ekMaxFlow.getMaximumFlowValue();", "-\t\tMap<E, Double> maxFlow=ekMaxFlow.getMaximumFlow();", "-\t\t", "-\t\tQueue<V> processQueue=new LinkedList<V>();", "-\t\tprocessQueue.add(source);", "-\t\t", "-\t\twhile(!processQueue.isEmpty()){", "-\t\t\tV vertex=processQueue.remove();", "-\t\t\tif(minCut.contains(vertex))", "-\t\t\t\tcontinue;", "-\t\t\telse", "-\t\t\t\tminCut.add(vertex);", "-\t\t\t//1. Get the forward edges with residual capacity", "-\t\t\tSet<E> outEdges=new HashSet<E>(graph.outgoingEdgesOf(vertex));", "-\t\t\tfor(Iterator<E> it=outEdges.iterator(); it.hasNext();){", "-\t\t\t\tE edge=it.next();", "-\t\t\t\tdouble edgeCapacity=graph.getEdgeWeight(edge);", "-\t\t\t\tdouble flowValue=maxFlow.get(edge);", "-\t\t\t\tif(Math.abs(edgeCapacity-flowValue)<=epsilon) //No residual capacity on the edge", "-\t\t\t\t\tit.remove();", "-\t\t\t}", "-\t\t\tfor(E edge: outEdges){", "-\t\t\t\tprocessQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));", "-\t\t\t}", "-\t\t\t", "-\t\t\t//2. Get the backward edges with non-zero flow", "-\t\t\tSet<E> inEdges=new HashSet<E>(graph.incomingEdgesOf(vertex));", "-\t\t\tfor(Iterator<E> it=inEdges.iterator(); it.hasNext();){", "-\t\t\t\tE edge=it.next();", "-\t\t\t\t//double edgeCapacity=graph.getEdgeWeight(edge);", "-\t\t\t\tdouble flowValue=maxFlow.get(edge);", "-\t\t\t\tif(flowValue<=epsilon) //There is no flow on this edge", "-\t\t\t\t\tit.remove();", "-\t\t\t}", "-\t\t\tfor(E edge: inEdges){", "-\t\t\t\tprocessQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t}", "+     */", "+    public void computeMinCut(V source, V sink)", "+    {", "+        this.source = source;", "+        this.sink = sink;", "+        minCut = new HashSet<V>();", "+", "+        //First compute a maxFlow from source to sink", "+        ekMaxFlow.calculateMaximumFlow(source, sink);", "+        this.cutWeight = ekMaxFlow.getMaximumFlowValue();", "+        Map<E, Double> maxFlow = ekMaxFlow.getMaximumFlow();", "+", "+        Queue<V> processQueue = new LinkedList<V>();", "+        processQueue.add(source);", "+", "+        while (!processQueue.isEmpty()) {", "+            V vertex = processQueue.remove();", "+            if (minCut.contains(vertex)) {", "+                continue;", "+            } else {", "+                minCut.add(vertex);", "+            }", "+", "+            //1. Get the forward edges with residual capacity", "+            Set<E> outEdges = new HashSet<E>(graph.outgoingEdgesOf(vertex));", "+            for (Iterator<E> it = outEdges.iterator(); it.hasNext();) {", "+                E edge = it.next();", "+                double edgeCapacity = graph.getEdgeWeight(edge);", "+                double flowValue = maxFlow.get(edge);", "+                if (Math.abs(edgeCapacity - flowValue) <= epsilon) { //No residual capacity on the edge", "+                    it.remove();", "+                }", "+            }", "+            for (E edge : outEdges) {", "+                processQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));", "+            }", "+", "+            //2. Get the backward edges with non-zero flow", "+            Set<E> inEdges = new HashSet<E>(graph.incomingEdgesOf(vertex));", "+            for (Iterator<E> it = inEdges.iterator(); it.hasNext();) {", "+                E edge = it.next();", "+", "+                //double edgeCapacity=graph.getEdgeWeight(edge);", "+                double flowValue = maxFlow.get(edge);", "+                if (flowValue <= epsilon) { //There is no flow on this edge", "+                    it.remove();", "+                }", "+            }", "+            for (E edge : inEdges) {", "+                processQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));", "+            }", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f34e6cce01d31f28930aa837e408b868", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/isomorphism/GraphOrdering.java", "commitBeforeChange": "6245588ef354746c5c3ae9a477b956068a878121", "commitAfterChange": "7c92324c62793ccd32781d7e3f1ebd3ed525f69b", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public int[] getInEdges(int vertexNumber)", "signatureAfterChange": "     public int [] getInEdges(int vertexNumber)", "diff": ["-    public int[] getInEdges(int vertexNumber) {", "-        if (cacheEdges && incomingEdges[vertexNumber] != null)", "+    public int [] getInEdges(int vertexNumber)", "+    {", "+        if (cacheEdges && (incomingEdges[vertexNumber] != null)) {", "+        }", "-        V v            = getVertex(vertexNumber);", "+        V v = getVertex(vertexNumber);", "-        if (graph instanceof DirectedGraph<?, ?>)", "+        if (graph instanceof DirectedGraph<?, ?>) {", "-        else", "+        } else {", "+        }", "-        int[] vertexArray = new int[edgeSet.size()];", "-        int i             = 0;", "+        int [] vertexArray = new int[edgeSet.size()];", "+        int i = 0;", "-              target = graph.getEdgeTarget(edge);", "+                target = graph.getEdgeTarget(edge);", "-        if (cacheEdges)", "+        if (cacheEdges) {", "+        }"]}]}