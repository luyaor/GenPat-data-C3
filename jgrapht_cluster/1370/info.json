{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fc89de3bb2eee983b37917771d817e07", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0d115d780fb21399cb661f78c3563ae4", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/ChromaticNumber.java", "commitBeforeChange": "a6d8abd126ba3a06ab884ca429c2b00d917433e6", "commitAfterChange": "6779b908c35c78402d4661605d6152ac0908883b", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)", "signatureAfterChange": "     public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)", "diff": ["+        Map<Integer,Set<V>> coloredGroups =", "+            findGreedyColoredGroups(g);", "+        return coloredGroups.keySet().size();", "+    }", "-        // Each vertex will attempted to be colored with a single color each", "-        return color;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "10e42b755d8e655175d2c316873547c2", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/test/java/org/jgrapht/alg/flow/MaximumFlowAlgorithmTestBase.java", "commitBeforeChange": "16877ce18b6445d7238b8a78693c87c95971617b", "commitAfterChange": "024fc7b86a9ced21b7444077ac5895f2b6a50bf9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 8, "signatureBeforeChange": "      private void runTest(         int [] tails,         int [] heads,         double [] capacities,         int [] sources,         int [] sinks,         double [] expectedResults)", "signatureAfterChange": "      private void runTest(         int [] tails,         int [] heads,         double [] capacities,         int [] sources,         int [] sinks,         double [] expectedResults)", "diff": ["+", "-            MaximumFlowAlgorithm.MaximumFlow<Integer, DefaultWeightedEdge> maxFlow = solver.buildMaximumFlow(sources[i], sinks[i]);", "+            verify(sources[i], sinks[i], expectedResults[i], network, solver.buildMaximumFlow(sources[i], sinks[i]));", "+        }", "+    }", "-            assertEquals(", "-                expectedResults[i],", "-                maxFlow.getValue(),", "-                EdmondsKarpMaximumFlow.DEFAULT_EPSILON);", "-            Double flowValue = maxFlow.getValue();", "-            Map<DefaultWeightedEdge, Double> flow = maxFlow.getFlow();", "-            for (DefaultWeightedEdge e : network.edgeSet()) {", "-                assertTrue(flow.containsKey(e));", "-", "-            for (DefaultWeightedEdge e : flow.keySet()) {", "-                assertTrue(network.containsEdge(e));", "-                assertTrue(", "-                    flow.get(e) >= -EdmondsKarpMaximumFlow.DEFAULT_EPSILON);", "-                assertTrue(", "-                    flow.get(e)", "-                        <= (network.getEdgeWeight(e)", "-                        + EdmondsKarpMaximumFlow.DEFAULT_EPSILON));", "-", "-            for (Integer v : network.vertexSet()) {", "-                double balance = 0.0;", "-                for (DefaultWeightedEdge e : network.outgoingEdgesOf(v)) {", "-                    balance -= flow.get(e);", "-                }", "-                for (DefaultWeightedEdge e : network.incomingEdgesOf(v)) {", "-                    balance += flow.get(e);", "-                }", "-                if (v.equals(sources[i])) {", "-                    assertEquals(", "-                        -flowValue,", "-                        balance,", "-                        MaximumFlowAlgorithmBase.DEFAULT_EPSILON);", "-                } else if (v.equals(sinks[i])) {", "-                    assertEquals(", "-                        flowValue,", "-                        balance,", "-                        MaximumFlowAlgorithmBase.DEFAULT_EPSILON);", "-                } else {", "-                    assertEquals(", "-                        0.0,", "-                        balance,", "-                        MaximumFlowAlgorithmBase.DEFAULT_EPSILON);", "-                }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34e974e239e91bbfd6494580774d5375", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/alg/FloydWarshallShortestPaths.java", "commitBeforeChange": "e5d892ea988755999c21c3831434c4fc251611da", "commitAfterChange": "60fae450bc7df1fe1188f2da01fd4eefb4912b4d", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public FloydWarshallShortestPaths(Graph<V, E> g)", "signatureAfterChange": "      public FloydWarshallShortestPaths(Graph<V, E> graph)", "diff": ["+    public FloydWarshallShortestPaths(Graph<V, E> graph) {", "+        this.graph = graph;", "+        this.vertices = new ArrayList<V>(graph.vertexSet());", "+    }", "-    public FloydWarshallShortestPaths(Graph<V, E> g)", "-    {", "-        int sz = g.vertexSet().size();", "-        d = new double[sz][sz];", "-        indices = new HashMap<V, Integer>();", "-        //Initialise distance to infinity, or the neighbours weight, or 0 if", "-        //same", "-        for (V v1 : g.vertexSet()) {", "-            for (V v2 : g.vertexSet()) {", "-                if (v1 == v2) {", "-                    d[index(v1)][index(v2)] = 0;", "-                } else {", "-                    E e = g.getEdge(v1, v2);", "-                    if (e == null) {", "-                        d[index(v1)][index(v2)] = Double.POSITIVE_INFINITY;", "-                    } else {", "-                        d[index(v1)][index(v2)] = g.getEdgeWeight(e);", "-", "-        //now iterate k times", "-        for (int k = 0; k < sz; k++) {", "-            for (V v1 : g.vertexSet()) {", "-                for (V v2 : g.vertexSet()) {", "-                    d[index(v1)][index(v2)] =", "-                        Math.min(", "-                            d[index(v1)][index(v2)],", "-                            d[index(v1)][k] + d[k][index(v2)]);", "-                    diameter = Math.max(diameter, d[index(v1)][index(v2)]);", "-                }", "-            }", "-        }", "-    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5241f30913009c9fd2fd1b335bc07869", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "src/org/jgrapht/util/FibonacciHeapNode.java", "commitBeforeChange": "e001cc8146b616d3da90eb6cff49e32ca1fc4a04", "commitAfterChange": "b7f329ad24e729f34dfea65831437c4420189a75", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     public String toString()", "signatureAfterChange": "     public String toString()", "diff": ["-        if (true) {", "-            return Double.toString(key);", "-        } else {", "-            StringBuffer buf = new StringBuffer();", "-            buf.append(\"Node=[parent = \");", "-", "-            if (parent != null) {", "-                buf.append(Double.toString(parent.key));", "-            } else {", "-                buf.append(\"---\");", "-            }", "-", "-            buf.append(\", key = \");", "-            buf.append(Double.toString(key));", "-            buf.append(\", degree = \");", "-            buf.append(Integer.toString(degree));", "-            buf.append(\", right = \");", "-", "-            if (right != null) {", "-                buf.append(Double.toString(right.key));", "-            } else {", "-                buf.append(\"---\");", "-            }", "-", "-            buf.append(\", left = \");", "-", "-            if (left != null) {", "-                buf.append(Double.toString(left.key));", "-            } else {", "-                buf.append(\"---\");", "-            }", "-", "-            buf.append(\", child = \");", "-", "-            if (child != null) {", "-                buf.append(Double.toString(child.key));", "-            } else {", "-                buf.append(\"---\");", "-            }", "-", "-            buf.append(']');", "-", "-            return buf.toString();", "-        }", "+        return Double.toString(key);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e5309930bb61d003f9e88c9abb445cf", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "testsrc/org/_3pq/jgrapht/traverse/AbstractGraphIteratorTest.java", "commitBeforeChange": "5e9dfdedbd0f501394dd50a31fc000abcac738de", "commitAfterChange": "0fa22166c3bce2b4318de51e3645ef9910304701", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public void testDirectedGraph(  )", "signatureAfterChange": "     public void testDirectedGraph(  )", "diff": ["+        m_result = new StringBuffer(  );", "+", "+        DirectedGraph         graph = createDirectedGraph(  );", "+", "+        AbstractGraphIterator iterator = createIterator( graph, \"1\" );", "+        iterator.addTraversalListener( new MyTraversalListener(  ) );", "+", "+        while( iterator.hasNext(  ) ) {", "+            m_result.append( (String) iterator.next(  ) );", "+", "+            if( iterator.hasNext(  ) ) {", "+                m_result.append( ',' );", "+            }", "+        }", "+", "+        assertEquals( getExpectedStr2(  ), m_result.toString(  ) );", "+    }", "-        AbstractGraphIterator iterator = createIterator( graph, v1 );", "-        iterator.addTraversalListener( new MyTraversalListener(  ) );", "-", "-        while( iterator.hasNext(  ) ) {", "-            m_result.append( (String) iterator.next(  ) );", "-", "-            if( iterator.hasNext(  ) ) {", "-                m_result.append( ',' );", "-            }", "-        }", "-", "-        assertEquals( getExpectedStr2(  ), m_result.toString(  ) );"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ea7a0eafd4bace1b5c01d20643eec3e7", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/EdmondsKarpMaximumFlow.java", "commitBeforeChange": "c9321cdd6f93b7e8e241f348de2e975bf226c350", "commitAfterChange": "96bea297cb6d79531586150eeb7ae5f6fce792c9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 8, "signatureBeforeChange": "     public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)", "signatureAfterChange": "      @Override     public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)", "diff": ["-    public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)", "-        if (!network.containsVertex(source)) {", "-            throw new IllegalArgumentException(", "-                \"invalid source (null or not from this network)\");", "-        }", "-        if (!network.containsVertex(sink)) {", "-            throw new IllegalArgumentException(", "-                \"invalid sink (null or not from this network)\");", "-        }", "-        if (source.equals(sink)) {", "-            throw new IllegalArgumentException(\"source is equal to sink\");", "-        }", "-", "-        currentSource = indexer.get(source);", "-        currentSink = indexer.get(sink);", "-", "-        for (int i = 0; i < numNodes; i++) {", "-            for (Arc currentArc : nodes.get(i).outgoingArcs) {", "-                currentArc.flow = 0.0;", "-            }", "-        }", "-", "-        final Map<E, Double> maxFlow = new HashMap<E, Double>();", "-", "-        double maxFlowValue;", "-", "-        for (;;) {", "-            breadthFirstSearch();", "-", "-            if (!nodes.get(currentSink).visited) {", "-                maxFlowValue = 0.0;", "-                for (int i = 0; i < numNodes; i++) {", "-                    for (Arc currentArc : nodes.get(i).outgoingArcs) {", "-                        if (currentArc.head == currentSink)", "-                            maxFlowValue += currentArc.flow;", "-", "-                        if (currentArc.prototype != null) {", "-                            maxFlow.put(", "-                                currentArc.prototype,", "-                                currentArc.flow);", "-                        }", "-                    }", "-                }", "-                break;", "-            }", "-", "-            augmentFlow();", "-        }", "-", "-        return new VerbatimMaximumFlow<V, E>(maxFlowValue, maxFlow);", "+    @Override", "+    public MaximumFlow<V, E> buildMaximumFlow(V source, V sink) {", "+        currentSource   = source;", "+        currentSink     = sink;", "+        build();", "+        return maxFlow;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0f579666004eccf43213cfe45606eab", "repository": "https://github.com/jgrapht/jgrapht", "fileName": "jgrapht-core/src/main/java/org/jgrapht/alg/EdmondsKarpMaximumFlow.java", "commitBeforeChange": "c9321cdd6f93b7e8e241f348de2e975bf226c350", "commitAfterChange": "96bea297cb6d79531586150eeb7ae5f6fce792c9", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     private void buildInternalNetwork()", "signatureAfterChange": "     public void calculateMaximumFlow(         V source,         V sink)", "diff": ["+    public void calculateMaximumFlow(", "+        V source,", "+        V sink)", "+        currentSource   = source;", "+        currentSink     = sink;", "+        build();", "-    // converting the original network into internal more convenient format", "-    private void buildInternalNetwork()", "-        numNodes = network.vertexSet().size();", "-        nodes = new ArrayList<Node>();", "-        Iterator<V> it = network.vertexSet().iterator();", "-        indexer = new HashMap<V, Integer>();", "-        for (int i = 0; i < numNodes; i++) {", "-            V currentNode = it.next();", "-            nodes.add(new Node(currentNode));", "-            indexer.put(currentNode, i);", "-        }", "-        for (int i = 0; i < numNodes; i++) {", "-            V we = nodes.get(i).prototype;", "-            for (E e : network.outgoingEdgesOf(we)) {", "-                V he = network.getEdgeTarget(e);", "-                int j = indexer.get(he);", "-                Arc e1 = new Arc(i, j, network.getEdgeWeight(e), e);", "-                Arc e2 = new Arc(j, i, 0.0, null);", "-                e1.reversed = e2;", "-                e2.reversed = e1;", "-                nodes.get(i).outgoingArcs.add(e1);", "-                nodes.get(j).outgoingArcs.add(e2);", "-            }", "-        }"]}]}