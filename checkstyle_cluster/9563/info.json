{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "14921190500966d60b13cda26ff3bec5", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ce6470eb09ebe28b160f3c73e5c00b3a", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RedundantModifierCheck.java", "commitBeforeChange": "8acc405dd30502bbbcdaf60a75ddd60dfa2b5a50", "commitAfterChange": "3ed2fd68f81f6200362f4babc9595b29f437ddd9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public void visitToken(DetailAST aAST)", "signatureAfterChange": "     public void visitToken(DetailAST aAST)", "diff": ["-        if (!ScopeUtils.inInterfaceBlock(aAST)) {", "-            return;", "-        }", "+        if (ScopeUtils.inInterfaceBlock(aAST)) {", "+            final DetailAST modifiers =", "+                aAST.findFirstToken(TokenTypes.MODIFIERS);", "-        DetailAST modifiers = aAST.findFirstToken(TokenTypes.MODIFIERS);", "+            DetailAST modifier = (DetailAST) modifiers.getFirstChild();", "+            while (modifier != null) {", "-        DetailAST modifier = (DetailAST) modifiers.getFirstChild();", "-        while (modifier != null) {", "+                // javac does not allow final or static in interface methods", "+                // hence no need to check that this is not a method", "-            // javac does not allow final or static in interface methods", "-            // hence no need to check that this is not a method", "+                final int type = modifier.getType();", "+                if (type == TokenTypes.LITERAL_PUBLIC", "+                    || type == TokenTypes.ABSTRACT", "+                    || type == TokenTypes.LITERAL_STATIC", "+                    || type == TokenTypes.FINAL)", "+                {", "+                    log(modifier.getLineNo(),", "+                        modifier.getColumnNo(),", "+                        \"redundantModifier\",", "+                        new String[] {modifier.getText()});", "+                    break;", "+                }", "-            final int type = modifier.getType();", "-            if (type == TokenTypes.LITERAL_PUBLIC", "-                || type == TokenTypes.ABSTRACT", "-                || type == TokenTypes.LITERAL_STATIC", "-                || type == TokenTypes.FINAL)", "-            {", "-                log(modifier.getLineNo(),", "-                    modifier.getColumnNo(),", "-                    \"redundantModifier\",", "-                    new String[] {modifier.getText()});", "-                break;", "+                modifier = (DetailAST) modifier.getNextSibling();", "-", "-            modifier = (DetailAST) modifier.getNextSibling();", "+        }", "+        else if (aAST.getType() == TokenTypes.METHOD_DEF) {", "+            final DetailAST modifiers =", "+                            aAST.findFirstToken(TokenTypes.MODIFIERS);", "+            // private method?", "+            boolean checkFinal =", "+                modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);", "+            // declared in a final class?", "+            DetailAST parent = aAST.getParent();", "+            while (parent != null) {", "+                if (parent.getType() == TokenTypes.CLASS_DEF) {", "+                    final DetailAST classModifiers =", "+                        parent.findFirstToken(TokenTypes.MODIFIERS);", "+                    checkFinal |=", "+                        classModifiers.branchContains(TokenTypes.FINAL);", "+                    break;", "+                }", "+                parent = parent.getParent();", "+            }", "+            if (checkFinal) {", "+                DetailAST modifier = (DetailAST) modifiers.getFirstChild();", "+                while (modifier != null) {", "+                    final int type = modifier.getType();", "+                    if (type == TokenTypes.FINAL) {", "+                        log(modifier.getLineNo(),", "+                            modifier.getColumnNo(),", "+                            \"redundantModifier\",", "+                            new String[] {modifier.getText()});", "+                        break;", "+                    }", "+                    modifier = (DetailAST) modifier.getNextSibling();", "+                }", "+            }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1282f29c917dd6f7e837a4eb8257b3d", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java", "commitBeforeChange": "9aa49c8f6d2b30577565f87984819e1df0d62d0f", "commitAfterChange": "c56dce9222a819b4741b4c0cd664d38c58b31050", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": "     private static DetailAST getArrayTypeOrIdentifier(DetailAST arrayDeclarator)", "signatureAfterChange": "     private static DetailAST getArrayDeclaratorPreviousElement(DetailAST ast)", "diff": ["-    private static DetailAST getArrayTypeOrIdentifier(DetailAST arrayDeclarator) {", "-        DetailAST typeOrIdent = arrayDeclarator;", "-        if (isArrayInstantiation(arrayDeclarator)) {", "-            typeOrIdent = arrayDeclarator.getParent().getFirstChild();", "-        else if (isMultiDimensionalArray(arrayDeclarator)) {", "-            if (isCStyleMultiDimensionalArrayDeclaration(arrayDeclarator)) {", "-                if (arrayDeclarator.getParent().getType() != TokenTypes.ARRAY_DECLARATOR) {", "-                    typeOrIdent = getArrayIdentifier(arrayDeclarator);", "-                }", "+     */", "+    private static DetailAST getArrayDeclaratorPreviousElement(DetailAST ast) {", "+        final DetailAST previousElement;", "+        final DetailAST firstChild = ast.getFirstChild();", "+        if (firstChild.getType() == TokenTypes.ARRAY_DECLARATOR) {", "+            // second or higher array index", "+            previousElement = firstChild.findFirstToken(TokenTypes.RBRACK);", "+        }", "+        else {", "+            // first array index, is preceded with identifier or type", "+            final DetailAST parent = getFirstNonArrayDeclaratorParent(ast);", "+            switch (parent.getType()) {", "+                // generics", "+                case TokenTypes.TYPE_ARGUMENT:", "+                    final DetailAST wildcard = parent.findFirstToken(TokenTypes.WILDCARD_TYPE);", "+                    if (wildcard == null) {", "+                        // usual generic type argument like <char[]>", "+                        previousElement = getTypeLastNode(ast);", "+                    }", "+                    else {", "+                        // constructions with wildcard like <? extends String[]>", "+                        previousElement = getTypeLastNode(ast.getFirstChild());", "+                    }", "+                    break;", "+                // 'new' is a special case with its own subtree structure", "+                case TokenTypes.LITERAL_NEW:", "+                    previousElement = getTypeLastNode(parent);", "+                    break;", "+                // mundane array declaration, can be either java style or C style", "+                case TokenTypes.TYPE:", "+                    previousElement = getPreviousNodeWithParentOfTypeAst(ast, parent);", "+                    break;", "+                // i.e. boolean[].class", "+                case TokenTypes.DOT:", "+                    previousElement = getTypeLastNode(ast);", "+                    break;", "+                // java 8 method reference", "+                case TokenTypes.METHOD_REF:", "+                    final DetailAST ident = getIdentLastToken(ast);", "+                    if (ident == null) {", "+                        //i.e. int[]::new", "+                        previousElement = ast.getFirstChild();", "+                    }", "+                    else {", "+                        previousElement = ident;", "+                    }", "+                    break;", "+                default:", "+                    throw new IllegalStateException(\"unexpected ast syntax\" + parent);", "+            }", "+        }", "+        return previousElement;", "+    }", "-                DetailAST arrayIdentifier = arrayDeclarator.getFirstChild();", "-                while (arrayIdentifier != null) {", "-                    typeOrIdent = arrayIdentifier;", "-                    arrayIdentifier = arrayIdentifier.getFirstChild();", "-                }", "-            if (isCStyleArrayDeclaration(arrayDeclarator)) {", "-                typeOrIdent = getArrayIdentifier(arrayDeclarator);", "-                if (isArrayUsedAsTypeForGenericBoundedWildcard(arrayDeclarator)) {", "-                    typeOrIdent = arrayDeclarator.getParent();", "-                    typeOrIdent = arrayDeclarator.getFirstChild();", "-        return typeOrIdent;", "-    }"]}]}