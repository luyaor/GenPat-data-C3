{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9a5cd5aa70b62ca5f116208284b9a763", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4705584c3286eb9e068396ac21496613", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/design/HideUtilityClassConstructorCheck.java", "commitBeforeChange": "2da46d26c19466929d404e20e0e7f38cd7db9aee", "commitAfterChange": "0759e2257417baf28eb663636cd788f807ce953d", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public void visitToken(DetailAST aAST)", "signatureAfterChange": "     public void visitToken(DetailAST aAST)", "diff": ["-        boolean hasMethod = false;", "-        boolean hasNonStaticMethod = false;", "+        boolean hasMethodOrField = false;", "+        boolean hasNonStaticMethodOrField = false;", "-            if (child.getType() == TokenTypes.METHOD_DEF) {", "-                hasMethod = true;", "+            int type = child.getType();", "+            if (type == TokenTypes.METHOD_DEF", "+                    || type == TokenTypes.VARIABLE_DEF)", "+            {", "+                hasMethodOrField = true;", "-                if (!modifiers.branchContains(TokenTypes.LITERAL_STATIC)) {", "-                    hasNonStaticMethod = true;", "+                boolean isStatic =", "+                    modifiers.branchContains(TokenTypes.LITERAL_STATIC);", "+                boolean isPrivate =", "+                    modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);", "+", "+                if (!isStatic && !isPrivate) {", "+                    hasNonStaticMethodOrField = true;", "-            if (child.getType() == TokenTypes.CTOR_DEF) {", "+            if (type == TokenTypes.CTOR_DEF) {", "-        if (extendsJLO", "-                && hasMethod && !hasNonStaticMethod && hasAccessibleCtor)", "-        {", "+        final boolean isUtilClass =", "+            extendsJLO && hasMethodOrField && !hasNonStaticMethodOrField;", "+", "+        if (isUtilClass && hasAccessibleCtor) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c466da6d06410cfedd15b327506b4c3", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/CovariantEqualsCheck.java", "commitBeforeChange": "9309a784711a3510b8e8de08b3543fcc4cdb4813", "commitAfterChange": "e03dd7a0a03f9cf91e466ebee911ef0fa10130a4", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 8, "signatureBeforeChange": "     public void visitToken(DetailAST aAST)", "signatureAfterChange": "     public void visitToken(DetailAST aAST)", "diff": ["-        if (aAST.getType() == TokenTypes.CLASS_DEF) {", "-            //push", "-            mClassStack.add(new ClassAttributes());", "-        }", "-        else {", "-            // METHOD_DEF", "-            if (!ScopeUtils.inInterfaceBlock(aAST) && isEqualsMethod(aAST)) {", "-                final ClassAttributes attrs =", "-                    (ClassAttributes) mClassStack.getLast();", "-                if (hasObjectParameter(aAST)) {", "-                    attrs.setHasEqualsObject();", "+        if (aAST.getType() == TokenTypes.METHOD_DEF) {", "+            final DetailAST definer = getDefiner(aAST);", "+            final int type = definer.getType();", "+            if ((type == TokenTypes.CLASS_DEF)", "+                || (type == TokenTypes.LITERAL_NEW))", "+            {", "+                if (mClassStack.isEmpty()) {", "+                    mClassStack.add(new ClassAttributes(definer));", "-                else {", "-                    attrs.addEqualsNode(aAST);", "+                final ClassAttributes attrs =", "+                        (ClassAttributes) mClassStack.getLast();", "+                final DetailAST currentRoot = attrs.getRootAST();", "+                if (definer != currentRoot) {", "+                    mClassStack.add(new ClassAttributes(definer));", "+                }", "+                if (!ScopeUtils.inInterfaceBlock(aAST)", "+                    && isEqualsMethod(aAST))", "+                {", "+                    if (hasObjectParameter(aAST)) {", "+                        attrs.setHasEqualsObject();", "+                    }", "+                    else {", "+                        attrs.addEqualsNode(aAST);", "+                    }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6d05bc80e007650656315ead01e2e532", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/CovariantEqualsCheck.java", "commitBeforeChange": "9309a784711a3510b8e8de08b3543fcc4cdb4813", "commitAfterChange": "e03dd7a0a03f9cf91e466ebee911ef0fa10130a4", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 12, "signatureBeforeChange": "     public void leaveToken(DetailAST aAST)", "signatureAfterChange": "     public void leaveToken(DetailAST aAST)", "diff": ["-        if (aAST.getType() == TokenTypes.CLASS_DEF) {", "-            //pop and report equals errors", "-            final ClassAttributes attrs =", "-                (ClassAttributes) mClassStack.removeLast();", "-            final Set equalsNodes = attrs.getEqualsNodes();", "-            final Iterator it = equalsNodes.iterator();", "-            while (it.hasNext()) {", "-                final DetailAST equalsAST = (DetailAST) it.next();", "-                final DetailAST nameNode =", "-                    equalsAST.findFirstToken(TokenTypes.IDENT);", "-                log(nameNode.getLineNo(), nameNode.getColumnNo(),", "-                        \"covariant.equals\");", "+        final int type = aAST.getType();", "+        if ((type == TokenTypes.LITERAL_NEW)", "+            || (type == TokenTypes.CLASS_DEF))", "+        {", "+            // pop class stack", "+            if (!mClassStack.isEmpty()) {", "+                final ClassAttributes attrs =", "+                    (ClassAttributes) mClassStack.getLast();", "+                if (attrs.getRootAST() == aAST) {", "+                    mClassStack.removeLast();", "+                    final Set equalsNodes = attrs.getEqualsNodes();", "+                    final Iterator it = equalsNodes.iterator();", "+                    while (it.hasNext()) {", "+                        final DetailAST equalsAST = (DetailAST) it.next();", "+                        final DetailAST nameNode =", "+                            equalsAST.findFirstToken(TokenTypes.IDENT);", "+                        log(nameNode.getLineNo(), nameNode.getColumnNo(),", "+                            \"covariant.equals\");", "+                    }", "+                }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aead43eb6da6939f33536b6a1a857db4", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java", "commitBeforeChange": "de6862e0bedab5c22d54b4cf503144c28f1aea26", "commitAfterChange": "55c2560774f0624afeae9e6c29fd19ae59e8c24b", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 6, "signatureBeforeChange": "      @Override     public void visitToken(DetailAST aAST)", "signatureAfterChange": "      @Override     public void visitToken(DetailAST aAST)", "diff": ["+", "-        final int type = aAST.getType();", "+        final int currentType = aAST.getType();", "-        if (((type == TokenTypes.RCURLY) || (type == TokenTypes.LCURLY))", "+        if (((currentType == TokenTypes.RCURLY)", "+                || (currentType == TokenTypes.LCURLY))", "-        if ((type == TokenTypes.STAR)", "+        if ((currentType == TokenTypes.STAR)", "-        if ((type == TokenTypes.SLIST)", "+        if ((currentType == TokenTypes.SLIST)", "-        if ((type == TokenTypes.COLON)) {", "+        if ((currentType == TokenTypes.COLON)) {", "-        // Check for allowed empty method or ctor blocks.", "-        if (emptyMethodBlockCheck(aAST, parentType)", "-            || emptyCtorBlockCheck(aAST, parentType))", "+        // Checks if empty methods, ctors or loops are allowed.", "+        if (isEmptyMethodBlock(aAST, parentType)", "+                || isEmptyCtorBlock(aAST, parentType)", "+                || isEmptyLoop(aAST, parentType))", "+            return;", "+        }", "+", "+        // Checks if empty classes, interfaces or enums are allowed", "+        if (mAllowEmptyTypes && (isEmptyType(aAST, parentType))) {", "-            && !((type == TokenTypes.LITERAL_RETURN)", "+            && !((currentType == TokenTypes.LITERAL_RETURN)", "-            && !((type == TokenTypes.RCURLY)", "+            && !((currentType == TokenTypes.RCURLY)"]}]}