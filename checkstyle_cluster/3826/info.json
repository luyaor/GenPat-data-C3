{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "309224b33f56156ad48c8c5319fba2e9", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "63785b887ef5a1c3e350f33d4ab387fb", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java", "commitBeforeChange": "410111f1dcee8241b7649a83675281693a3067ec", "commitAfterChange": "e853ed726fc5ea30084202fa72c8117147fedb2b", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public static Configuration loadConfiguration(String aConfigFname,                                                   Properties aOverrideProps)         throws CheckstyleException", "signatureAfterChange": "     public static Configuration loadConfiguration(         String aConfig, Properties aOverrideProps)         throws CheckstyleException", "diff": ["-    public static Configuration loadConfiguration(String aConfigFname,", "-                                                  Properties aOverrideProps)", "+    public static Configuration loadConfiguration(", "+        String aConfig, Properties aOverrideProps)", "-            loader.parseFile(aConfigFname);", "+            // figure out if this is a File or a URL", "+            InputStream configStream;", "+            try {", "+                URL url = new URL(aConfig);", "+                configStream = url.openStream();", "+            }", "+            catch (MalformedURLException ex) {", "+                configStream = new FileInputStream(aConfig);", "+            }", "+            final InputStream bufferedStream =", "+                new BufferedInputStream(configStream);", "+            loader.parseInputStream(bufferedStream);", "+            bufferedStream.close();", "-                \"unable to find \" + aConfigFname, e);", "+                \"unable to find \" + aConfig, e);", "-                \"unable to parse \" + aConfigFname, e);", "+                \"unable to parse \" + aConfig, e);", "-                    + aConfigFname + \" - \" + e.getMessage(), e);", "+                    + aConfig + \" - \" + e.getMessage(), e);", "-            throw new CheckstyleException(\"unable to read \" + aConfigFname, e);", "+            throw new CheckstyleException(\"unable to read \" + aConfig, e);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ba45c48f4c57aeabcc6ab87b1389aa55", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/duplicates/StrictDuplicateCodeCheck.java", "commitBeforeChange": "b0240a0200663fbf1d3146d1aefe12207fdde4af", "commitAfterChange": "9aa72722de7b5a4ffb5d50945c7bce8b58f25e8e", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "     private void findDuplicatesInFiles(int aI, int aJ)", "signatureAfterChange": "     private void findDuplicatesInFiles(int aI, int aJ)", "diff": ["+        final ChecksumInfo iChecksumInfo = mChecksumInfo[aI];", "+        final ChecksumInfo jChecksumInfo = mChecksumInfo[aJ];", "+        if (!iChecksumInfo.hasChecksumOverlapsWith(jChecksumInfo)) {", "+            return;", "+        }", "+", "-        final long[] jSortedBlockChecksums = mSortedRelevantChecksums[aJ];", "+", "+        // blocks of duplicate code might be longer than 'min'. We need to", "+        // remember the line combinations where we must ignore identical blocks", "+        // because we have already reported them for an earlier blockIdx.", "+        // Note: MultiHashMap is deprecated in the latest releases of o.a.j.c.c", "+        final MultiMap ignorePairs = new MultiHashMap();", "-        for (int blockIdx = 0; blockIdx < iBlockCount; blockIdx++) {", "+        for (int iLine = 0; iLine < iBlockCount; iLine++) {", "-            // detailed analysis only if the block does occur in jFile at all", "-            if (Arrays.binarySearch(", "-                    jSortedBlockChecksums,", "-                    iLineBlockChecksums[blockIdx]) >= 0)", "-            {", "-                blockIdx = findDuplicateFromLine(aI, aJ, blockIdx);", "+            final long iSum = iLineBlockChecksums[iLine];", "+            int[] jLines = jChecksumInfo.findLinesWithChecksum(iSum);", "+            // detailed analysis only if the iLine block occurs in jFile at all", "+            if (jLines.length > 0) {", "+                findDuplicateFromLine(aI, aJ, iLine, jLines, ignorePairs);"]}]}