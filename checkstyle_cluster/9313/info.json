{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "26c25890d70612bb5949b608af2aeb9c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6d2c3b7054eeea9eed6e4e771b8f89e2", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java", "commitBeforeChange": "624f82b556974bf15cafee6a057acca3dac5eec5", "commitAfterChange": "6125beffc437f970eae276b4a6542265c6547784", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "     public void visitToken(DetailAST aAST)", "signatureAfterChange": "     public void visitToken(DetailAST aAST)", "diff": ["-        final FullIdent ident = FullIdent.createFullIdentBelow(aAST);", "+        final FullIdent ident;", "+        boolean isStatic;", "+        if (aAST.getType() == TokenTypes.IMPORT) {", "+            ident = FullIdent.createFullIdentBelow(aAST);", "+            isStatic = false;", "+        }", "+        else {", "+            ident = FullIdent.createFullIdent(", "+                (DetailAST) aAST.getFirstChild().getNextSibling());", "+            isStatic = true;", "+        }", "-                        shouldFireError = (mLastImport.compareTo(name) >= 0);", "+                        shouldFireError =", "+                            //current and previous static or current and", "+                            //previous non-static", "+                            (!(mLastImportStatic ^ isStatic)", "+                            &&", "+                            //and out of lexicographic order", "+                            (mLastImport.compareTo(name) >= 0))", "+                            ||", "+                            //previous static but current is non-static", "+                            (mLastImportStatic && !isStatic);", "-                            (mLastImport.compareToIgnoreCase(name) >= 0);", "+                                //current and previous static or current and", "+                                //previous non-static", "+                                (!(mLastImportStatic ^ isStatic)", "+                                &&", "+                                //and out of lexicographic order", "+                                (mLastImport.compareToIgnoreCase(name) >= 0))", "+                                ||", "+                                //previous static but current is non-static", "+                                (mLastImportStatic && !isStatic);", "+            mLastImportStatic = isStatic;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a2f2ac3636d20df66bdfcdbe81b6655a", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ModifierOrderCheck.java", "commitBeforeChange": "c3af7d4b0e9ffd5bdf1fa55273170f45b3b3d9e0", "commitAfterChange": "a827b7cbbf1f29e24e3f814149809941e754c93c", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     static DetailAST checkOrderSuggestedByJLS(List<DetailAST> modifiers)", "signatureAfterChange": "     static DetailAST checkOrderSuggestedByJLS(List<DetailAST> modifiers)", "diff": ["+        DetailAST offendingModifier = null;", "+", "-        if (modifier.getType() == TokenTypes.ANNOTATION) {", "-            return null;", "-        }", "+        if (modifier.getType() != TokenTypes.ANNOTATION) {", "+            int i = 0;", "-        int i = 0;", "-        while (modifier != null) {", "-            if (modifier.getType() == TokenTypes.ANNOTATION) {", "-                //Annotation not at start of modifiers, bad", "-                return modifier;", "-            }", "+            while (modifier != null) {", "+                if (modifier.getType() == TokenTypes.ANNOTATION) {", "+                    //Annotation not at start of modifiers, bad", "+                    offendingModifier = modifier;", "+                    break;", "+                }", "-            while (i < JLS_ORDER.length", "-                   && !JLS_ORDER[i].equals(modifier.getText())) {", "-                i++;", "-            }", "+                while (i < JLS_ORDER.length", "+                       && !JLS_ORDER[i].equals(modifier.getText())) {", "+                    i++;", "+                }", "-            if (i == JLS_ORDER.length) {", "-                //Current modifier is out of JLS order", "-                return modifier;", "-            }", "-            else if (it.hasNext()) {", "-                modifier = it.next();", "-            }", "-            else {", "-                //Reached end of modifiers without problem", "-                modifier = null;", "+                if (i == JLS_ORDER.length) {", "+                    //Current modifier is out of JLS order", "+                    offendingModifier = modifier;", "+                    break;", "+                }", "+                else if (it.hasNext()) {", "+                    modifier = it.next();", "+                }", "+                else {", "+                    //Reached end of modifiers without problem", "+                    modifier = null;", "+                }", "-", "-        return null;", "+        return offendingModifier;"]}]}