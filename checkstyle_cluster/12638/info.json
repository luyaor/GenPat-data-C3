{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5efe0af908d8a5bf6db77b28269cedf3", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "553c4e4890dc12f88cf042d1a7566fa0", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java", "commitBeforeChange": "4011bf37400a7932f6c7a6f8fe1686673cea31c7", "commitAfterChange": "fd6a743fd4b3c9283d62174327dd978bda694892", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "     private void checkHtml(DetailAST aAST, String[] aComment)", "signatureAfterChange": "     private void checkHtml(DetailAST aAST, String[] aComment)", "diff": ["-        for (int i = 0; i < aComment.length; i++) {", "-            TagParser parser = null;", "-            try {", "-                // Can throw NoSuchElementException when tokenizing encounters", "-                // \"<\" at end of aComment[i].", "-                parser = new TagParser(aComment[i], lineno + i);", "-            }", "-            catch (NoSuchElementException e) {", "-                log(", "-                    lineno + i,", "-                    \"javadoc.incompleteTag\",", "-                    new Object[] {aComment[i]});", "+        TagParser parser = null;", "+        try {", "+            // Can throw NoSuchElementException when tokenizing encounters", "+            // \"<\" at end of aComment[i].", "+            parser = new TagParser(aComment, lineno);", "+        }", "+        catch (NoSuchElementException e) {", "+            log(lineno, \"javadoc.incompleteTag\", new Object[] {aComment[0]});", "+            return;", "+        }", "+", "+        while (parser.hasNextTag()) {", "+            final HtmlTag tag = parser.nextTag();", "+", "+            if (tag.isIncompleteTag()) {", "+                log(tag.getLineno(), \"javadoc.incompleteTag\",", "+                    new Object[] {aComment[tag.getLineno() - lineno]});", "-            while (parser.hasNextTag()) {", "-                final HtmlTag tag = parser.nextTag();", "-", "-                if (!tag.isCloseTag()) {", "-                    htmlStack.push(tag);", "+            if (tag.isClosedTag()) {", "+                //do nothing", "+                continue;", "+            }", "+            if (!tag.isCloseTag()) {", "+                htmlStack.push(tag);", "+            }", "+            else {", "+                // We have found a close tag.", "+                if (isExtraHtml(tag.getId(), htmlStack)) {", "+                    // No corresponding open tag was found on the stack.", "+                    log(tag.getLineno(),", "+                        tag.getPosition(),", "+                        EXTRA_HTML,", "+                        tag);", "-                    // We have found a close tag.", "-                    if (isExtraHtml(tag.getId(), htmlStack)) {", "-                        // No corresponding open tag was found on the stack.", "-                        log(tag.getLineno(),", "-                            tag.getPosition(),", "-                            EXTRA_HTML,", "-                            tag);", "-                    }", "-                    else {", "-                        // See if there are any unclosed tags that were opened", "-                        // after this one.", "-                        checkUnclosedTags(htmlStack, tag.getId());", "-                    }", "+                    // See if there are any unclosed tags that were opened", "+                    // after this one.", "+                    checkUnclosedTags(htmlStack, tag.getId());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f82bf96fb618d929b2c9cadb889099c0", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java", "commitBeforeChange": "4011bf37400a7932f6c7a6f8fe1686673cea31c7", "commitAfterChange": "fd6a743fd4b3c9283d62174327dd978bda694892", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private void parseTags(String aText, int aLineNo)", "signatureAfterChange": "     private void parseTags(String[] aText, int aLineNo)", "diff": ["-    private void parseTags(String aText, int aLineNo)", "+    private void parseTags(String[] aText, int aLineNo)", "-        int position = 0;", "-        final StringTokenizer tokenizer =", "-            new StringTokenizer(aText, \" \\t\\n\\r\\f<>\", true);", "+        final int nLines = aText.length;", "+        Point position = new Point(0, 0);", "-        while (tokenizer.hasMoreTokens()) {", "-            String token = tokenizer.nextToken();", "-            position += token.length();", "+        position = findChar(aText, '<', position);", "+        while (position.getLineNo() < nLines) {", "+            // if this is html comment then skip it", "+            if (isCommentTag(aText, position)) {", "+                position = skipHtmlComment(aText, position);", "+            }", "+            else if (!isTag(aText, position)) {", "+                position = getNextCharPos(aText, position);", "+            }", "+            else {", "+                // find end of tag", "+                final Point endTag = findChar(aText, '>', position);", "+                final boolean incompleteTag = (endTag.getLineNo() >= nLines);", "+                // get tag id (one word)", "+                final String tagId =", "+                    (incompleteTag ? \"\" : getTagId(aText, position));", "+                // is this closed tag", "+                final boolean closedTag =", "+                    (endTag.getLineNo() < nLines && endTag.getColumnNo() > 0", "+                     && aText[endTag.getLineNo()]", "+                     .charAt(endTag.getColumnNo() - 1) == '/');", "+                // add new tag", "+                add(new HtmlTag(tagId,", "+                                position.getLineNo() + aLineNo,", "+                                position.getColumnNo(),", "+                                closedTag,", "+                                incompleteTag,", "+                                aText[position.getLineNo()]));", "+                position = endTag;", "+            }", "+            position = findChar(aText, '<', position);", "+        }", "+    }", "-            if (token.equals(\"<\")) {", "-                token = tokenizer.nextToken();", "-                position += token.length();", "-                if (((token.charAt(0) >= 'A')", "-                     && (token.charAt(0) <= 'Z'))", "-                    || ((token.charAt(0) >= 'a')", "-                        && (token.charAt(0) <= 'z'))", "-                    || (token.charAt(0) == '/'))", "-                    // If a character or / follows the < sign,", "-                    // then assume its html.", "-                    // The non-html version is \"&lt;\"", "-                    // Point before the angle bracket", "-                    final int startOfTag = position - token.length() - 1;", "-                    add(new HtmlTag(token, aLineNo, startOfTag, aText));"]}]}