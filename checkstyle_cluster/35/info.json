{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "86699b33e475132416902edffadf8c0e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2b82d5711c908c1ef0814e753b75bd0b", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java", "commitBeforeChange": "1c7341013d0e8a34498eb49ccdb4e91419f13280", "commitAfterChange": "cd89321522d9bf7fc10547e743fb8bbb4c993791", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "     private void checkThrowsTags(List aTags, List aThrows)", "signatureAfterChange": "     private void checkThrowsTags(List aTags, List aThrows)", "diff": ["+            Class documentedClass = null;", "+            if (!found", "+                && (mAllowThrowsTagsForSubclasses || mAllowUndeclaredRTE))", "+            {", "+                documentedClass = resolveClass(documentedEx);", "+                if (documentedClass == null) {", "+                    log(tag.getLineNo(), \"javadoc.classInfo\",", "+                        \"@throws\", documentedEx);", "+                }", "+            }", "+", "-                final FullIdent fi = ei.getFullIdent();", "+                final FullIdent fi = ei.getName();", "-                else if (mAllowThrowsTagsForSubclasses) {", "-                    final ClassResolver cr = getClassResolver();", "-                    try {", "-                        final Class documentedClass = cr.resolve(documentedEx);", "-                        try {", "-                            final Class declaredClass = cr.resolve(declaredEx);", "-                            found =", "-                                declaredClass.isAssignableFrom(documentedClass);", "-                            if (found) {", "-                                ei.setFound();", "-                            }", "-                        }", "-                        catch (ClassNotFoundException e) {", "-                            log(tag.getLineNo(), \"javadoc.classInfo\",", "+                else if (mAllowThrowsTagsForSubclasses", "+                         && documentedClass != null)", "+                {", "+                    if (ei.isLoadable() && ei.getClazz() == null) {", "+                        // if the class is not loaded yet.", "+                        // try to load it.", "+                        ei.setClazz(resolveClass(declaredEx));", "+                        if (!ei.isLoadable()) {", "+                            log(fi.getLineNo(), \"javadoc.classInfo\",", "-                    catch (ClassNotFoundException e) {", "-                        log(tag.getLineNo(), \"javadoc.classInfo\",", "-                                      \"@throws\", documentedEx);", "+", "+                    found = isSubclass(documentedClass, ei.getClazz());", "+                    if (found) {", "+                        ei.setFound();", "-                if (mAllowUndeclaredRTE) {", "-                    final ClassResolver cr = getClassResolver();", "-                    try {", "-                        final Class clazz = cr.resolve(tag.getArg1());", "-                        reqd =", "-                            !RuntimeException.class.isAssignableFrom(clazz)", "-                                && !Error.class.isAssignableFrom(clazz);", "-                    }", "-                    catch (ClassNotFoundException e) {", "-                        log(tag.getLineNo(), \"javadoc.classInfo\",", "-                                      \"@throws\", tag.getArg1());", "-                    }", "+                if (mAllowUndeclaredRTE && documentedClass != null) {", "+                    reqd = !isUnchecked(documentedClass);", "-                    final FullIdent fi = ei.getFullIdent();", "+                    final FullIdent fi = ei.getName();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4cfb31a49d4b47b34a4096a095c47857", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java", "commitBeforeChange": "343b75b252db9492ace4c4e5bfb36016e631c7a5", "commitAfterChange": "f9f60d3142533c3eebff775e8eb1159935faaba1", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 11, "signatureBeforeChange": "      @Override     public void visitToken(DetailAST ast)", "signatureAfterChange": "      @Override     public void visitToken(DetailAST ast)", "diff": ["-        if ((ast.getType() != TokenTypes.VARIABLE_DEF)", "-            || (ast.getParent().getType() != TokenTypes.OBJBLOCK))", "-        {", "-            return;", "+        switch (ast.getType()) {", "+            case TokenTypes.VARIABLE_DEF:", "+                if (!isAnonymousClassVariable(ast)) {", "+                    visitVariableDef(ast);", "+                }", "+                break;", "+            case TokenTypes.IMPORT:", "+                visitImport(ast);", "+                break;", "+            default:", "+                final String exceptionMsg = \"Unexpected token type: \" + ast.getText();", "+                throw new IllegalArgumentException(exceptionMsg);", "+    }", "-        final DetailAST varNameAST = getVarNameAST(ast);", "-        final String varName = varNameAST.getText();", "-            ScopeUtils.inInterfaceOrAnnotationBlock(ast);", "-        final Set<String> mods = getModifiers(ast);", "-        final String declaredScope = getVisibilityScope(mods);", "-        final String variableScope =", "-             inInterfaceOrAnnotationBlock ? \"public\" : declaredScope;", "-        if (!(\"private\".equals(variableScope)", "-                || inInterfaceOrAnnotationBlock // implicitly static and final", "-                || (mods.contains(\"static\") && mods.contains(\"final\"))", "-                || (\"package\".equals(variableScope) && isPackageAllowed())", "-                || (\"protected\".equals(variableScope) && isProtectedAllowed())", "-                || (\"public\".equals(variableScope)", "-                   && getPublicMemberRegexp().matcher(varName).find())))", "-        {", "-            log(varNameAST.getLineNo(), varNameAST.getColumnNo(),", "-                    MSG_KEY, varName);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4e5a798a9b5c3478902f5c3b29db6ff5", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/whitespace/MethodParamPadCheck.java", "commitBeforeChange": "a81008fd6fd383b6acb39866355aae8a750a326f", "commitAfterChange": "14172dd01adff4bc99296f633c4acad32e3d570f", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public void visitToken(DetailAST aAST)", "signatureAfterChange": "     public void visitToken(DetailAST aAST)", "diff": ["-        int parenColumnNo = parenAST.getColumnNo();", "-        final String[] lines = getLines();", "-        int identLineNo = -1;", "-        int identColumnNo = -1;", "-        final String identText;", "-        final DetailAST identAST;", "-        final DetailAST dotAST = aAST.findFirstToken(TokenTypes.DOT);", "-        if (dotAST != null) {", "-            identAST = dotAST.getLastChild();", "-        }", "-        else if (aAST.getType() == TokenTypes.SUPER_CTOR_CALL) {", "-            identAST = aAST;", "+", "+        final String line = getLines()[parenAST.getLineNo() - 1];", "+        if (Utils.whitespaceBefore(parenAST.getColumnNo(), line)) {", "+            if (!mAllowLineBreaks) {", "+                log(parenAST, \"line.previous\", parenAST.getText());", "+            }", "-            identAST = aAST.findFirstToken(TokenTypes.IDENT);", "-        }", "-        identLineNo = identAST.getLineNo();", "-        identColumnNo = identAST.getColumnNo();", "-        identText = identAST.getText();", "-", "-        if (identLineNo == parenAST.getLineNo()) {", "-            final int after = identColumnNo + identText.length();", "-            final String line = lines[identLineNo - 1];", "+            final int before = parenAST.getColumnNo() - 1;", "-                && (Character.isWhitespace(line.charAt(after))))", "+                && (Character.isWhitespace(line.charAt(before))))", "-                log(identLineNo, after, \"ws.followed\", identText);", "+                log(parenAST , \"ws.preceded\", parenAST.getText());", "-                     && !Character.isWhitespace(line.charAt(after)))", "+                     && !Character.isWhitespace(line.charAt(before)))", "-                log(identLineNo, after, \"ws.notFollowed\", identText);", "+                log(parenAST, \"ws.notPreceded\", parenAST.getText());", "-        }", "-        else if (!mAllowLineBreaks) {", "-            log(", "-                parenAST.getLineNo(),", "-                parenColumnNo,", "-                \"line.previous\",", "-                parenAST.getText());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "61479c2750f0f5566172279bc29082cb", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java", "commitBeforeChange": "6f937bff1da1183d58b20f48e3cc401dc9eb06f4", "commitAfterChange": "0024de5711531372850e883c970414563ab8e3ad", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": "      @Override     public void visitToken(final DetailAST methodCall)", "signatureAfterChange": "      @Override     public void visitToken(final DetailAST ast)", "diff": ["-    public void visitToken(final DetailAST methodCall) {", "+", "+    @Override", "+    public void visitToken(final DetailAST ast) {", "+        switch (ast.getType()) {", "+            case TokenTypes.VARIABLE_DEF:", "+            case TokenTypes.PARAMETER_DEF:", "+                currentFrame.addField(ast);", "+                break;", "+            case TokenTypes.METHOD_CALL:", "+                processMethodCall(ast);", "+                break;", "+            case TokenTypes.SLIST:", "+                processSlist(ast);", "+                break;", "+            case TokenTypes.LITERAL_NEW:", "+                processLiteralNew(ast);", "+                break;", "+            default:", "+                processFrame(ast);", "+        }", "+    }", "-        if (dot.getType() != TokenTypes.DOT) {", "-            return;", "-        final DetailAST objCalledOn = dot.getFirstChild();", "-            return;", "-        final DetailAST method = objCalledOn.getNextSibling();", "-        final DetailAST expr = dot.getNextSibling().getFirstChild();", "-", "-        if (\"equals\".equals(method.getText())", "-            && containsOneArgument(methodCall) && containsAllSafeTokens(expr)) {", "-            log(methodCall.getLineNo(), methodCall.getColumnNo(),", "-                MSG_EQUALS_AVOID_NULL);", "-        }", "-", "-        if (!ignoreEqualsIgnoreCase", "-            && \"equalsIgnoreCase\".equals(method.getText())", "-            && containsOneArgument(methodCall) && containsAllSafeTokens(expr)) {", "-            log(methodCall.getLineNo(), methodCall.getColumnNo(),", "-                MSG_EQUALS_IGNORE_CASE_AVOID_NULL);", "-        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "983170077b25648116dc417ca98e8983", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java", "commitBeforeChange": "ae9d1d6217ad7dbc2e6f1faa890298c68726dcb4", "commitAfterChange": "2e1382c5bb1aa61cc01d7958a589e2a3831f56b5", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "      @Override     public final void visitToken(DetailAST aBlockCommentAst)", "signatureAfterChange": "      @Override     public final void visitToken(DetailAST aBlockCommentAst)", "diff": ["-        mBlockCommentAst = aBlockCommentAst;", "+        if (JavadocUtils.isJavadocComment(aBlockCommentAst)) {", "+            mBlockCommentAst = aBlockCommentAst;", "-        final String commentContent = JavadocUtils.getBlockCommentContent(aBlockCommentAst);", "+            final String treeCacheKey = aBlockCommentAst.getLineNo() + \":\"", "+                    + aBlockCommentAst.getColumnNo();", "-        if (JavadocUtils.isJavadocComment(commentContent)) {", "+            ParseStatus ps;", "-            final String javadocComment = commentContent.substring(1);", "-", "-            // Log messages should have line number in scope of file,", "-            // not in scope of Javadoc comment.", "-            // Offset is line number of beginning of Javadoc comment.", "-            mErrorListener.setOffset(aBlockCommentAst.getLineNo() - 1);", "-", "-            try {", "-                final ParseTree parseTree = parseJavadoc(javadocComment);", "-", "-                final DetailNode node = convertParseTree2DetailNode(parseTree);", "-", "-                processTree(node);", "+            if (TREE_CACHE.containsKey(treeCacheKey)) {", "+                ps = TREE_CACHE.get(treeCacheKey);", "-            catch (IOException e) {", "-                // Antlr can not initiate its ANTLRInputStream", "-                log(aBlockCommentAst.getLineNo(), \"javadoc.parse.error\",", "-                        e.getMessage());", "+            else {", "+                ps = parseJavadocAsDetailNode(aBlockCommentAst);", "+                TREE_CACHE.put(treeCacheKey, ps);", "-            catch (ParseCancellationException e) {", "-                // If syntax error occurs then message is printed by error listener", "-                // and parser throws this runtime exception to stop parsing.", "-                // Just stop processing current Javadoc comment.", "-                return;", "+", "+            if (ps.getParseErrorMessage() == null) {", "+                processTree(ps.getTree());", "+            }", "+            else {", "+                final LocalizedMessage parseErrorMessage = ps.getParseErrorMessage();", "+                log(parseErrorMessage.getLineNo(), parseErrorMessage.getColumnNo()", "+                        , parseErrorMessage.getMessage());", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "baf8bffb498ab4f1547460371f546ba6", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java", "commitBeforeChange": "ef422e76c6b0bcac8fda2608a4d2d4301e09eca4", "commitAfterChange": "d282d5b8db9eba5943d1cb0269315744d5344a47", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "     private void validate(Details details, DetailAST rcurly, DetailAST lcurly)", "signatureAfterChange": "     private static String validate(Details details, RightCurlyOption bracePolicy,                                    boolean shouldStartLine, String targetSourceLine)", "diff": ["-    private void validate(Details details, DetailAST rcurly, DetailAST lcurly) {", "+    private static String validate(Details details, RightCurlyOption bracePolicy,", "+                                   boolean shouldStartLine, String targetSourceLine) {", "+        final DetailAST rcurly = details.rcurly;", "+        final DetailAST lcurly = details.lcurly;", "+        String violation = \"\";", "-        if (getAbstractOption() == RightCurlyOption.SAME", "+        if (bracePolicy == RightCurlyOption.SAME", "-            log(rcurly, MSG_KEY_LINE_BREAK_BEFORE, \"}\", rcurly.getColumnNo() + 1);", "+            violation = MSG_KEY_LINE_BREAK_BEFORE;", "-                log(rcurly, MSG_KEY_LINE_ALONE, \"}\", rcurly.getColumnNo() + 1);", "+                violation = MSG_KEY_LINE_ALONE;", "-        else if (getAbstractOption() == RightCurlyOption.SAME", "+        else if (bracePolicy == RightCurlyOption.SAME", "-            log(rcurly, MSG_KEY_LINE_SAME, \"}\", rcurly.getColumnNo() + 1);", "+            violation = MSG_KEY_LINE_SAME;", "-        else if (getAbstractOption() == RightCurlyOption.ALONE", "+        else if (bracePolicy == RightCurlyOption.ALONE", "-            log(rcurly, MSG_KEY_LINE_ALONE, \"}\", rcurly.getColumnNo() + 1);", "+            violation = MSG_KEY_LINE_ALONE;", "-        else if (getAbstractOption() == RightCurlyOption.ALONE_OR_SINGLELINE", "+        else if (bracePolicy == RightCurlyOption.ALONE_OR_SINGLELINE", "-            log(rcurly, MSG_KEY_LINE_ALONE, \"}\", rcurly.getColumnNo() + 1);", "+            violation = MSG_KEY_LINE_ALONE;", "-                Utils.whitespaceBefore(rcurly.getColumnNo(),", "-                    getLines()[rcurly.getLineNo() - 1]);", "+                Utils.whitespaceBefore(rcurly.getColumnNo(), targetSourceLine);", "-                log(rcurly, MSG_KEY_LINE_NEW, \"}\", rcurly.getColumnNo() + 1);", "+                violation = MSG_KEY_LINE_NEW;", "+        return violation;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bc87308a31b258f93026252bb88f1581", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java", "commitBeforeChange": "94e8285d4cb6d5e0b49acade6dbba5b8654b42dd", "commitAfterChange": "22136c67e9c83494e7aa977ffe7a79beee1b4175", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 8, "signatureBeforeChange": "      @Override     public void visitToken(DetailAST aAST)", "signatureAfterChange": "      @Override     public void visitToken(DetailAST aAST)", "diff": ["+", "+    @Override", "+    public void visitToken(DetailAST aAST)", "+    {", "+        final FullIdent ident;", "+        final boolean isStatic;", "+", "+        if (aAST.getType() == TokenTypes.IMPORT) {", "+            ident = FullIdent.createFullIdentBelow(aAST);", "+            isStatic = false;", "+        }", "+        else {", "+            ident = FullIdent.createFullIdent((DetailAST) aAST.getFirstChild()", "+                    .getNextSibling());", "+            isStatic = true;", "+        }", "+", "+        switch (getAbstractOption()) {", "+        case TOP:", "+            if (!isStatic && mLastImportStatic) {", "+                mLastGroup = Integer.MIN_VALUE;", "+                mLastImport = \"\";", "+            }", "+            // no break;", "+", "+        case ABOVE:", "+            // previous non-static but current is static", "+            doVisitToken(ident, isStatic, (!mLastImportStatic && isStatic));", "+            break;", "+", "+        case INFLOW:", "+            // previous argument is useless here", "+            doVisitToken(ident, isStatic, true);", "+            break;", "+", "+        case BOTTOM:", "+            if (isStatic && !mLastImportStatic) {", "+                mLastGroup = Integer.MIN_VALUE;", "+                mLastImport = \"\";", "+            }", "+            // no break;", "+", "+        case UNDER:", "+            // previous static but current is non-static", "+            doVisitToken(ident, isStatic, (mLastImportStatic && !isStatic));", "+            break;", "+", "+        default:", "+            break;", "+        }", "+", "+        mLastImportLine = aAST.findFirstToken(TokenTypes.SEMI).getLineNo();", "+        mLastImportStatic = isStatic;", "+        mBeforeFirstImport = false;", "+    }", "-", "-    @Override", "-    public void visitToken(DetailAST aAST)", "-    {", "-        final FullIdent ident;", "-        boolean isStatic;", "-        if (aAST.getType() == TokenTypes.IMPORT) {", "-            ident = FullIdent.createFullIdentBelow(aAST);", "-            isStatic = false;", "-        }", "-        else {", "-            ident = FullIdent.createFullIdent(", "-                (DetailAST) aAST.getFirstChild().getNextSibling());", "-            isStatic = true;", "-        if (ident != null) {", "-            final String name = ident.getText();", "-            final int groupIdx = getGroupNumber(name);", "-            final int line = ident.getLineNo();", "-", "-            if (groupIdx > mLastGroup) {", "-                if (!mBeforeFirstImport && mSeparated) {", "-                    // This check should be made more robust to handle", "-                    // comments and imports that span more than one line.", "-                    if (line - mLastImportLine < 2) {", "-                        log(line, \"import.separation\", name);", "-                    }", "-                }", "-            }", "-            else if (groupIdx == mLastGroup) {", "-                if (mOrdered) {", "-                    boolean shouldFireError = false;", "-                    if (mCaseSensitive) {", "-                        shouldFireError =", "-                            //current and previous static or current and", "-                            //previous non-static", "-                            (!(mLastImportStatic ^ isStatic)", "-                            &&", "-                            //and out of lexicographic order", "-                            (mLastImport.compareTo(name) >= 0))", "-                            ||", "-                            //previous static but current is non-static", "-                            (mLastImportStatic && !isStatic);", "-                    }", "-                    else {", "-                        shouldFireError =", "-                                //current and previous static or current and", "-                                //previous non-static", "-                                (!(mLastImportStatic ^ isStatic)", "-                                &&", "-                                //and out of lexicographic order", "-                                (mLastImport.compareToIgnoreCase(name) >= 0))", "-                                ||", "-                                //previous static but current is non-static", "-                                (mLastImportStatic && !isStatic);", "-                    }", "-                    if (shouldFireError) {", "-                        log(line, \"import.ordering\", name);", "-                    }", "-                }", "-            }", "-            else {", "-                log(line, \"import.ordering\", name);", "-            }", "-", "-            mLastGroup = groupIdx;", "-            mLastImport = name;", "-            mLastImportLine = aAST.findFirstToken(TokenTypes.SEMI).getLineNo();", "-            mLastImportStatic = isStatic;", "-            mBeforeFirstImport = false;", "-        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e466d4086a046bfb9274d9d59503ff51", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/it/java/com/google/checkstyle/test/base/IndentationConfigurationBuilder.java", "commitBeforeChange": "a2ae6fa3a82abc0562772af74de80bee2f927cd8", "commitAfterChange": "d1a6a437100b26d4f3932472ca3241b3f4b05da2", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "      private static boolean isCommentConsistent(String comment)", "signatureAfterChange": "      private static boolean isCommentConsistent(String comment)", "diff": ["+        boolean result;", "+        CommentType type = getCommentType(comment);", "+        switch (type) {", "+            case MULTILEVEL:", "+                result = isMultiLevelCommentConsistent(comment, indentInComment, isWarnComment);", "+                break;", "+", "+            case SINGLE_LEVEL:", "+                result = isSingleLevelCommentConsistent(comment, indentInComment, isWarnComment);", "+                break;", "+", "+            case NON_STRICT_LEVEL:", "+                result = isNonStrictCommentConsistent(comment, indentInComment, isWarnComment);", "+                break;", "+", "+            case UNKNOWN:", "+                throw new IllegalArgumentException(\"Cannot determine comment consistent\");", "+", "+            default:", "+                throw new IllegalStateException(\"Cannot determine comment is consistent\");", "+", "+        }", "+        return result;", "+    }", "-            final String[] levels = multilevelMatch.group(1).split(\",\");", "-            final String indentInCommentStr = String.valueOf(indentInComment);", "-            final boolean containsActualLevel =", "-                            Arrays.asList(levels).contains(indentInCommentStr);", "-", "-            return containsActualLevel && !isWarnComment", "-                    || !containsActualLevel && isWarnComment;", "-", "-        Matcher singleLevelMatch = SINGLE_LEVEL_COMMENT_REGEX.matcher(comment);", "-        if (singleLevelMatch.matches()) {", "-            final int expectedLevel = Integer.parseInt(singleLevelMatch.group(1));", "-", "-            return expectedLevel == indentInComment && !isWarnComment", "-                    || expectedLevel != indentInComment && isWarnComment;", "-", "-        Matcher nonStrictLevelMatch = NON_STRICT_LEVEL_COMMENT_REGEX.matcher(comment);", "-        if (nonStrictLevelMatch.matches()) {", "-            final int expectedMinimalIndent = Integer.parseInt(nonStrictLevelMatch.group(1));", "-", "-            return indentInComment >= expectedMinimalIndent && !isWarnComment", "-                    || indentInComment < expectedMinimalIndent && isWarnComment;", "-        }", "-", "-        throw new IllegalArgumentException(\"Cannot determine if commit is consistent\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eece3953006154257cf34b04e6c07ebf", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressElement.java", "commitBeforeChange": "37a393ae29949480ebd8d02fd903d0d18ee574f3", "commitAfterChange": "ffd17e5ad649a03e4c9044005d2cb707be1261a1", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 7, "signatureBeforeChange": "      @Override     public boolean equals(Object object)", "signatureAfterChange": "      @Override     public boolean equals(Object o)", "diff": ["-    public boolean equals(Object object) {", "-        if (object instanceof SuppressElement) {", "-            final SuppressElement other = (SuppressElement) object;", "-", "-            // same file pattern?", "-            if (!this.filePattern.equals(other.filePattern)) {", "-                return false;", "-            }", "-", "-            // same check pattern?", "-            if (checkPattern != null) {", "-                if (!checkPattern.equals(other.checkPattern)) {", "-                    return false;", "-                }", "-            }", "-            else if (other.checkPattern != null) {", "-                return false;", "-            }", "-", "-            // same module id?", "-            if (moduleId != null) {", "-                if (!moduleId.equals(other.moduleId)) {", "-                    return false;", "-                }", "-            }", "-            else if (other.moduleId != null) {", "-                return false;", "-            }", "-", "-            // same line number filter?", "-            if (lineFilter != null) {", "-                if (!lineFilter.equals(other.lineFilter)) {", "-                    return false;", "-                }", "-            }", "-            else if (other.lineFilter != null) {", "-                return false;", "-            }", "-", "-            // same column number filter?", "-            if (columnFilter != null) {", "-                if (!columnFilter.equals(other.columnFilter)) {", "-                    return false;", "-                }", "-            }", "-            else if (other.columnFilter != null) {", "-                return false;", "-            }", "-", "-            // everything is the same", "+    public boolean equals(Object o) {", "+        if (this == o) {", "-        return false;", "+        if (o == null || getClass() != o.getClass()) {", "+            return false;", "+        }", "+        final SuppressElement that = (SuppressElement) o;", "+        return Objects.equals(filePattern, that.filePattern)", "+                && Objects.equals(checkPattern, that.checkPattern)", "+                && Objects.equals(moduleId, that.moduleId)", "+                && Objects.equals(linesCSV, that.linesCSV)", "+                && Objects.equals(columnsCSV, that.columnsCSV);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5efcd6460b423aeeaab119825a12f7f", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java", "commitBeforeChange": "3e25a4911d0f0e4ea1b9c22f1b65158794f7d093", "commitAfterChange": "7f452f66c8ac18a9d0093c0cb05009ddae0b8ea9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": "      @Override     public void visitToken(DetailAST ast)", "signatureAfterChange": "      @Override     public void visitToken(DetailAST ast)", "diff": ["-        DetailAST theAst = ast;", "-        // Strange logic in this method to guard against checking RPAREN tokens", "-        // that are associated with a TYPECAST token.", "-        if (theAst.getType() != TokenTypes.RPAREN) {", "-            if (theAst.getType() == TokenTypes.CTOR_CALL", "-                || theAst.getType() == TokenTypes.SUPER_CTOR_CALL) {", "-                theAst = theAst.getFirstChild();", "-            }", "-            if (!isPreceedsEmptyForInit(theAst)) {", "-                processLeft(theAst);", "+        switch (ast.getType()) {", "+            case TokenTypes.METHOD_CALL:", "+                processLeft(ast);", "+                processRight(ast.findFirstToken(TokenTypes.RPAREN));", "+                processExpression(ast);", "+                break;", "+            case TokenTypes.EXPR:", "+            case TokenTypes.QUESTION:", "+                processExpression(ast);", "+                break;", "+            case TokenTypes.LITERAL_FOR:", "+                visitLiteralFor(ast);", "+                break;", "+            case TokenTypes.ANNOTATION:", "+            case TokenTypes.ENUM_CONSTANT_DEF:", "+            case TokenTypes.LITERAL_NEW:", "+            case TokenTypes.LITERAL_SYNCHRONIZED:", "+                visitNewEnumConstDefAnnotationSync(ast);", "+                break;", "+            default:", "+                processLeft(ast.findFirstToken(TokenTypes.LPAREN));", "+                processRight(ast.findFirstToken(TokenTypes.RPAREN));", "+        }", "+    }", "-        else if ((theAst.getParent() == null", "-                 || theAst.getParent().getType() != TokenTypes.TYPECAST", "-                 || theAst.getParent().findFirstToken(TokenTypes.RPAREN)", "-                     != theAst)", "-                 && !isFollowsEmptyForIterator(theAst)) {", "-            processRight(theAst);"]}]}