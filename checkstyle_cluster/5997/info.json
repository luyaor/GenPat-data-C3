{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f27cf48312f548ef28da4504c390b5f6", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "185eda51d3ca91a862b2a87a47f54ff3", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/gui/ParseTreeInfoPanel.java", "commitBeforeChange": "302f80bd65e3670d296bba40de712be7a0932bd3", "commitAfterChange": "ef791720f010bcc2a05da76cac8021085bc71155", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "      public void openFile(File aFile, final Component aParent)", "signatureAfterChange": "       public void openFile(File aFile, final Component aParent)", "diff": ["+", "-                DetailAST parseTree = parseFile(aFile.getAbsolutePath());", "+                Main.frame.setTitle(\"Checkstyle : \" + aFile.getName());", "+                final DetailAST parseTree = parseFile(aFile.getAbsolutePath());", "+", "+                String[] sourceLines = Utils.getLines(aFile.getAbsolutePath());", "+                //clean the text area before inserting the lines of the new file", "+                if (mJTextArea.getText().length() != 0) {", "+                    mJTextArea.replaceRange(\"\", 0, mJTextArea.getText()", "+                            .length());", "+                }", "+", "+                // insert the contents of the file to the text area", "+                for (int i = 0; i < sourceLines.length; i++) {", "+                    mJTextArea.append(sourceLines[i] + \"\\n\");", "+                }", "+", "+                // move back to the top of the file", "+                mJTextArea.moveCaretPosition(0);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2dfe9514ab0b057ea769a894c8fec25a", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/test/java/com/puppycrawl/tools/checkstyle/BaseCheckTestSupport.java", "commitBeforeChange": "3a2cb4d787e3c626bb0e2e02915cc1c37deb9d0b", "commitAfterChange": "189da7314d1b29f0e14479210c2fd567305a64d2", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "      protected void verify(Checker checker,                           File[] processedFiles,                           String messageFileName,                           String... expected)             throws Exception", "signatureAfterChange": "     protected void verify(Checker checker,                           File[] processedFiles,                           String messageFileName,                           String... expected)             throws Exception", "diff": ["+     */", "-        final Map<String, List<String>> expectedMessages = new HashMap<>(1);", "-        expectedMessages.put(messageFileName, asList(expected));", "-        verify(checker, processedFiles, expectedMessages);", "+        stream.flush();", "+        final List<File> theFiles = Lists.newArrayList();", "+        Collections.addAll(theFiles, processedFiles);", "+        final int errs = checker.process(theFiles);", "+", "+        // process each of the lines", "+        final ByteArrayInputStream inputStream =", "+                new ByteArrayInputStream(stream.toByteArray());", "+        try (final LineNumberReader lnr = new LineNumberReader(", "+                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {", "+", "+            for (int i = 0; i < expected.length; i++) {", "+                final String expectedResult = messageFileName + \":\" + expected[i];", "+                final String actual = lnr.readLine();", "+                assertEquals(\"error message \" + i, expectedResult, actual);", "+            }", "+", "+            assertEquals(\"unexpected output: \" + lnr.readLine(),", "+                    expected.length, errs);", "+        }", "+", "+        checker.destroy();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "31da884ba86861f8dfbc41b06b5e198c", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java", "commitBeforeChange": "6f6e4db399353f769525820d9a7319287105d3e5", "commitAfterChange": "06c32930c34e2b10b5926883c29a4a20fe6ecf05", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "     private void checkParamTags(List aTags, List aParams,                                 boolean aReportExpectedTags)", "signatureAfterChange": "     private void checkParamTags(final List aTags, final DetailAST aParent,                                 boolean aReportExpectedTags)", "diff": ["-    private void checkParamTags(List aTags, List aParams,", "+    private void checkParamTags(final List aTags, final DetailAST aParent,", "+        List params = getParameters(aParent);", "+        List typeParams = CheckUtils.getTypeParameters(aParent);", "+", "-            // Loop looking for matching param", "-            final Iterator paramIt = aParams.iterator();", "+", "+            // Loop looking for matching param", "+            final Iterator paramIt = params.iterator();", "+            if (tag.getArg1().startsWith(\"<\") && tag.getArg1().endsWith(\">\")) {", "+                // Loop looking for matching type param", "+                Iterator typeParamsIt = typeParams.iterator();", "+                while (typeParamsIt.hasNext()) {", "+                    final DetailAST typeParam = (DetailAST) typeParamsIt.next();", "+                    if (typeParam.findFirstToken(TokenTypes.IDENT).getText()", "+                        .equals(tag.getArg1().substring(", "+                            1, tag.getArg1().length() - 1)))", "+                    {", "+                        found = true;", "+                        typeParamsIt.remove();", "+                        break;", "+                    }", "+                }", "+", "+            }", "+", "-        // Now dump out all parameters without tags :- unless", "+        // Now dump out all type parameters/parameters without tags :- unless", "-            final Iterator paramIt = aParams.iterator();", "+            final Iterator paramIt = params.iterator();", "+", "+            final Iterator typeParamsIt = typeParams.iterator();", "+            while (typeParamsIt.hasNext()) {", "+                final DetailAST typeParam = (DetailAST) typeParamsIt.next();", "+                log(typeParam, \"javadoc.expectedTag\", \"@param\",", "+                    \"<\"", "+                    + typeParam.findFirstToken(TokenTypes.IDENT).getText()", "+                    + \">\");", "+            }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "683cabaec13703cbc8aa466393476972", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java", "commitBeforeChange": "fe6e0fd4231aaba97cf423899f93697400880c93", "commitAfterChange": "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 8, "signatureBeforeChange": "     public Checker(Configuration aConfig)         throws RESyntaxException, IOException", "signatureAfterChange": "      public Checker(Configuration aConfig, CheckConfiguration[] aConfigs)         throws ClassNotFoundException, InstantiationException,                IllegalAccessException", "diff": ["+", "+    public Checker(Configuration aConfig, CheckConfiguration[] aConfigs)", "+        throws ClassNotFoundException, InstantiationException,", "+               IllegalAccessException", "+    {", "+        // TODO: document to make testing easier", "+        mConfig = aConfig;", "+        mCache = new PropertyCacheFile(aConfig);", "+        LocalizedMessage.setLocale(new Locale(mConfig.getLocaleLanguage(),", "+                                              mConfig.getLocaleCountry()));", "+        mMessages = new LocalizedMessages(mConfig.getTabWidth());", "+        mWalker = new TreeWalker(mMessages);", "+        // TODO: improve the error handing", "+        for (int i = 0; i < aConfigs.length; i++) {", "+            final CheckConfiguration config = aConfigs[i];", "+            mWalker.registerCheck(", "+                config.createInstance(mConfig.getClassLoader()), config);", "+        }", "+    }", "-        throws RESyntaxException, IOException"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6ca57fd963f92a415bc4e301085b0260", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java", "commitBeforeChange": "59aa66c3cc43db0a7cd8bb0ea3a39b6f4339fe88", "commitAfterChange": "a24df47cafeab03fd65cf72b460aad3d2fafce3d", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 19, "signatureBeforeChange": "     private void processRec(DetailAST aAST)", "signatureAfterChange": "     private static DetailAST appendHiddenCommentNodes(DetailAST aRoot)", "diff": ["-    private void processRec(DetailAST aAST)", "-        if (aAST == null) {", "-            return;", "-        notifyVisit(aAST);", "-", "-        final DetailAST child = aAST.getFirstChild();", "-        if (child != null) {", "-            processRec(child);", "-        }", "-", "-        notifyLeave(aAST);", "-", "-        final DetailAST sibling = aAST.getNextSibling();", "-        if (sibling != null) {", "-            processRec(sibling);", "-        }", "-    }", "+     */", "+    private static DetailAST appendHiddenCommentNodes(DetailAST aRoot)", "+    {", "+        DetailAST result = aRoot;", "+        DetailAST curNode = aRoot;", "+        DetailAST lastNode = aRoot;", "+", "+        while (curNode != null) {", "+            if (isPositionGreater(curNode, lastNode)) {", "+                lastNode = curNode;", "+            }", "+", "+            CommonHiddenStreamToken tokenBefore = curNode.getHiddenBefore();", "+            DetailAST currentSibling = curNode;", "+            while (tokenBefore != null) { // threat multiple comments", "+                final DetailAST newCommentNode =", "+                         createCommentAstFromToken(tokenBefore);", "+", "+                currentSibling.addPreviousSibling(newCommentNode);", "+", "+                if (currentSibling == result) {", "+                    result = newCommentNode;", "+                }", "+", "+                currentSibling = newCommentNode;", "+                tokenBefore = tokenBefore.getHiddenBefore();", "+            }", "+", "+            DetailAST toVisit = curNode.getFirstChild();", "+            while ((curNode != null) && (toVisit == null)) {", "+                toVisit = curNode.getNextSibling();", "+                if (toVisit == null) {", "+                    curNode = curNode.getParent();", "+                }", "+            }", "+            curNode = toVisit;", "+        }", "+        if (lastNode != null) {", "+            CommonHiddenStreamToken tokenAfter = lastNode.getHiddenAfter();", "+            DetailAST currentSibling = lastNode;", "+            while (tokenAfter != null) {", "+                final DetailAST newCommentNode =", "+                        createCommentAstFromToken(tokenAfter);", "+", "+                currentSibling.addNextSibling(newCommentNode);", "+", "+                currentSibling = newCommentNode;", "+                tokenAfter = tokenAfter.getHiddenAfter();", "+            }", "+        }", "+        return result;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e79847d86b6c688526a8e5ace13198d", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java", "commitBeforeChange": "e3741d10267df217664f47fdf68169286e2d31bc", "commitAfterChange": "2554557c1c4dda6cb348ba053a60c17d8ada9f73", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 5, "signatureBeforeChange": "     private boolean isAssignment(DetailAST aAST)", "signatureAfterChange": "     private static boolean isInContext(DetailAST aAST, int[][] aContextSet)", "diff": ["-    private boolean isAssignment(DetailAST aAST)", "-        // TODO: make actual tokens available to Check and loop over actual", "-        // tokens here?", "-        final int[] tokens = getDefaultTokens();", "-        for (int i = 0; i < tokens.length; i++) {", "-            final int tokenType = tokens[i];", "-            if (astType == tokenType) {", "-                return true;", "+     */", "+    private static boolean isInContext(DetailAST aAST, int[][] aContextSet)", "+    {", "+        for (int i = 0; i < aContextSet.length; i++) {", "+            DetailAST current = aAST;", "+            final int len = aContextSet[i].length;", "+            for (int j = 0; j < len; j++) {", "+                current = current.getParent();", "+                final int expectedType = aContextSet[i][j];", "+                if (current == null || current.getType() != expectedType) {", "+                    break;", "+                }", "+                if (j == len - 1) {", "+                    return true;", "+                }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7750383b1215586625f48f659d4be4aa", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/tests/com/puppycrawl/tools/checkstyle/ConfigurationLoaderTest.java", "commitBeforeChange": "440cf6836f278602a790d764f257777be80d8b9e", "commitAfterChange": "686afc521a11088c57632352eb6fd60a682b03d6", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 8, "signatureBeforeChange": "          public void testCheckOption()         throws Exception", "signatureAfterChange": "      private void verifyConfigNode(         DefaultConfiguration aConfig, String aName, int aChildrenLength,         Properties atts) throws Exception", "diff": ["-    ", "-    public void testCheckOption()", "-        throws Exception", "-//        Configuration config =", "-//            loadConfiguration(\"rightcurlycheck_configuration.xml\");", "-//                    ", "-//        GlobalProperties globalProps =", "-//            new GlobalProperties(new Properties(), System.out);", "-//        assertEquals(\"properties\", globalProps.getProperties(),", "-//            config.getProperties());", "-//                ", "-//        CheckConfiguration[] checkConfigs = config.getCheckConfigurations();", "-//        assertEquals(\"checkConfigs.length\", 1, checkConfigs.length);", "-//        ", "-//        RightCurlyCheck rightCurly =", "-//            (RightCurlyCheck) (checkConfigs[0].", "-//                createInstance(this.getClass().getClassLoader()));", "-//        RightCurlyOption option =", "-//            (RightCurlyOption) rightCurly.getAbstractOption();", "-//        assertEquals(\"option\", \"alone\", option.toString());", "+", "+    private void verifyConfigNode(", "+        DefaultConfiguration aConfig, String aName, int aChildrenLength,", "+        Properties atts) throws Exception", "+    {", "+        assertEquals(\"name.\", aName, aConfig.getName());", "+        assertEquals(", "+            \"children.length.\", aChildrenLength, aConfig.getChildren().length);", "+", "+        final String[] attNames = aConfig.getAttributeNames();", "+        assertEquals(\"attributes.length\", atts.size(), attNames.length);", "+", "+        for (int i = 0; i < attNames.length; i++) {", "+            assertEquals(", "+                \"attribute[\" + attNames[i] + \"]\", atts.get(attNames[i]),", "+                aConfig.getAttribute(attNames[i]));", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e6aae68c80b0c5850de68db2d78126c", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/duplicates/StrictDuplicateCodeCheck.java", "commitBeforeChange": "b0240a0200663fbf1d3146d1aefe12207fdde4af", "commitAfterChange": "9aa72722de7b5a4ffb5d50945c7bce8b58f25e8e", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "     private int findDuplicateFromLine(         final int aI, final int aJ, final int aILine)", "signatureAfterChange": "     private void findDuplicateFromLine(         final int aI, final int aJ, final int aILine,         final int[] aJLines, final MultiMap aIgnore)", "diff": ["-    private int findDuplicateFromLine(", "-        final int aI, final int aJ, final int aILine)", "+    private void findDuplicateFromLine(", "+        final int aI, final int aJ, final int aILine,", "+        final int[] aJLines, final MultiMap aIgnore)", "-        final long checkSum = mLineBlockChecksums[aI][aILine];", "+        final long[] iCheckSums = mLineBlockChecksums[aI];", "+        final long[] jCheckSums = mLineBlockChecksums[aJ];", "-        final int iBlockCount = mLineBlockChecksums[aI].length;", "-        final int jBlockCount = mLineBlockChecksums[aJ].length;", "+        final int iBlockCount = iCheckSums.length;", "+        final int jBlockCount = jCheckSums.length;", "-        for (int jBlock = 0; jBlock < jBlockCount; jBlock++) {", "+        final long checkSum = iCheckSums[aILine];", "-            if (aI == aJ && aILine >= jBlock) {", "+        final Integer iLine = new Integer(aILine);", "+", "+        for (int jLineIdx = 0; jLineIdx < aJLines.length; jLineIdx++) {", "+", "+            int jLine = aJLines[jLineIdx];", "+", "+            if (aI == aJ && aILine >= jLine) {", "-            if (mLineBlockChecksums[aJ][jBlock] != checkSum) {", "+            if (jCheckSums[jLine] != checkSum) {", "-            int duplicateLines = verifiyDuplicateLines(aI, aJ, aILine, jBlock);", "+            final Collection ignoreEntries = (Collection) aIgnore.get(iLine);", "+            // avoid Integer constructor whenever we can", "+            if (ignoreEntries != null) {", "+                if (ignoreEntries.contains(new Integer(jLine))) {", "+                    continue;", "+                }", "+            }", "+", "+            int duplicateLines = verifiyDuplicateLines(aI, aJ, aILine, jLine);", "-                reportDuplicate(duplicateLines, aILine, mFiles[aJ], jBlock);", "-", "-                // skip to end of equivalent section", "-                return aILine + duplicateLines;", "+                reportDuplicate(duplicateLines, aILine, mFiles[aJ], jLine);", "+                int extend = duplicateLines - mMin;", "+                for (int i = 0; i < extend; i++) {", "+                    final int offset = (i + 1);", "+                    aIgnore.put(new Integer(aILine + offset),", "+                            new Integer(jLine + offset));", "+                }", "-        return aILine;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8efd3908113de2ba9b0933f18cea264f", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java", "commitBeforeChange": "0406304865b4fdd6e5294f0bcd948f1158f4ae84", "commitAfterChange": "e15f70ac5b1460236e14237acc3a041102238efd", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "     private String getImportGroup(boolean isStatic, String importPath)", "signatureAfterChange": "     private String getImportGroup(boolean isStatic, String importPath)", "diff": ["-        for (String group : customImportOrderRules) {", "-            if (matchesImportGroup(isStatic, importPath, group)) {", "-                return group;", "+        RuleMatchForImport bestMatch = new RuleMatchForImport(NON_GROUP_RULE_GROUP, 0, 0);", "+        if (isStatic && customImportOrderRules.contains(STATIC_RULE_GROUP)) {", "+            bestMatch.group = STATIC_RULE_GROUP;", "+            bestMatch.matchLength = importPath.length();", "+        }", "+        else if (customImportOrderRules.contains(SAME_PACKAGE_RULE_GROUP)) {", "+            final String importPathTrimmedToSamePackageDepth =", "+                    getFirstNDomainsFromIdent(samePackageMatchingDepth, importPath);", "+            if (samePackageDomainsRegExp.equals(importPathTrimmedToSamePackageDepth)) {", "+                bestMatch.group = SAME_PACKAGE_RULE_GROUP;", "+                bestMatch.matchLength = importPath.length();", "-        return NON_GROUP_RULE_GROUP;", "+        if (bestMatch.group.equals(NON_GROUP_RULE_GROUP)) {", "+            for (String group : customImportOrderRules) {", "+                if (STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(group)) {", "+                    bestMatch = findBetterPatternMatch(importPath,", "+                            STANDARD_JAVA_PACKAGE_RULE_GROUP, standardPackageRegExp, bestMatch);", "+                }", "+                if (SPECIAL_IMPORTS_RULE_GROUP.equals(group)) {", "+                    bestMatch = findBetterPatternMatch(importPath,", "+                            SPECIAL_IMPORTS_RULE_GROUP, specialImportsRegExp, bestMatch);", "+                }", "+            }", "+        }", "+        if (bestMatch.group.equals(NON_GROUP_RULE_GROUP)", "+                && customImportOrderRules.contains(THIRD_PARTY_PACKAGE_RULE_GROUP)", "+                && thirdPartyPackageRegExp.matcher(importPath).find()) {", "+            bestMatch.group = THIRD_PARTY_PACKAGE_RULE_GROUP;", "+        }", "+        return bestMatch.group;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "96ba897890e5eb9e065df496c8530f18", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/DeclarationCollector.java", "commitBeforeChange": "8787efc822fd27a4a3f3dd795c34525ccc08d297", "commitAfterChange": "2fe9f501d86b6e70aa64f4474ae0863bb0b928d5", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "      @Override     public void visitToken(DetailAST aAST)", "signatureAfterChange": "      @Override     public void visitToken(DetailAST aAST)", "diff": ["+        final LexicalFrame frame = this.mFrames.current();", "-        case TokenTypes.PARAMETER_DEF :", "-        case TokenTypes.VARIABLE_DEF : {", "+        case TokenTypes.VARIABLE_DEF :  {", "+            final String name =", "+                    aAST.findFirstToken(TokenTypes.IDENT).getText();", "+            if (frame instanceof ClassFrame) {", "+                final DetailAST mods =", "+                    aAST.findFirstToken(TokenTypes.MODIFIERS);", "+                if (mods.branchContains(TokenTypes.LITERAL_STATIC)) {", "+                    ((ClassFrame) frame).addStaticMember(name);", "+                }", "+                else {", "+                    ((ClassFrame) frame).addInstanceMember(name);", "+                }", "+            }", "+            else {", "+                frame.addName(name);", "+            }", "+            break;", "+        }", "+        case TokenTypes.PARAMETER_DEF : {", "-            this.mFrames.current().addName(nameAST.getText());", "+            frame.addName(nameAST.getText());", "-            this.mFrames.current().addName(nameAST.getText());", "+            frame.addName(nameAST.getText());", "-        case TokenTypes.METHOD_DEF :", "+        case TokenTypes.METHOD_DEF : {", "+            final String name = aAST.findFirstToken(TokenTypes.IDENT).getText();", "+            if (frame instanceof ClassFrame) {", "+                final DetailAST mods =", "+                    aAST.findFirstToken(TokenTypes.MODIFIERS);", "+                if (mods.branchContains(TokenTypes.LITERAL_STATIC)) {", "+                    ((ClassFrame) frame).addStaticMember(name);", "+                }", "+                else {", "+                    ((ClassFrame) frame).addInstanceMember(name);", "+                }", "+            }", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "989737de6b41ae9d193584bce0ad7b90", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java", "commitBeforeChange": "d6272b70eb5ad61fd8ab34091e970c50b1f67386", "commitAfterChange": "1a2c318e22a0b2b22ccc76019217c0892fe2d59b", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public static void main(String... args) throws UnsupportedEncodingException", "signatureAfterChange": "     public static void main(String... args) throws UnsupportedEncodingException             , CheckstyleException, FileNotFoundException", "diff": ["+            , CheckstyleException, FileNotFoundException", "-        boolean parseResult = false;", "+        int errorCounter = 0;", "+        boolean cliViolations = false;", "+", "-            processCommandLine(parseCli(args));", "-            parseResult = true;", "+            //parse CLI arguments", "+            final CommandLine commandLine = parseCli(args);", "+", "+            // show version and exit if it is requested", "+            if (commandLine.hasOption(\"v\")) {", "+                System.out.println(\"Checkstyle version: \"", "+                        + Main.class.getPackage().getImplementationVersion());", "+            }", "+            else {", "+                // return error is smth is wrong in arguments", "+                final List<String> messages = validateCli(commandLine);", "+                cliViolations = !messages.isEmpty();", "+                if (messages.isEmpty()) {", "+", "+                    // create config helper object", "+                    final CliOptions config = convertCliToPojo(commandLine);", "+                    // run Checker", "+                    errorCounter = runCheckstyle(config);", "+", "+                }", "+                else {", "+                    errorCounter = 1;", "+                    for (String message : messages) {", "+                        System.out.println(message);", "+                    }", "+                }", "+            }", "-        catch (final ParseException e) {", "-            System.err.println(\"Could not parse parameters: \" + e.getMessage());", "-            e.printStackTrace();", "+        catch (ParseException pex) {", "+            // smth wrong with arguments - print error and manual", "+            cliViolations = true;", "+            errorCounter = 1;", "+            System.out.println(pex.getMessage());", "+            printUsage();", "-        catch (final Exception e) {", "-            System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());", "-            e.printStackTrace();", "+        catch (Exception ex) {", "+            // smth wrong during processing", "+            errorCounter = 1;", "+            throw ex;", "-            if (!parseResult) {", "-                usage();", "+            // return exit code base on validation of Checker", "+            if (errorCounter != 0 && !cliViolations) {", "+                System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));", "-            System.exit(parseResult ? 0 : 1);", "+            System.exit(errorCounter);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a0955b1cc3f239d367eec15440a482c2", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/CovariantEqualsCheck.java", "commitBeforeChange": "cc822a77b4846b180eef883288627aff2d85384d", "commitAfterChange": "a03dc8c1c9b1a7308be5e92324efab3413f6a771", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "         public void addEqualsNode(DetailAST aAST)", "signatureAfterChange": "     public void visitToken(DetailAST aAST)", "diff": ["-         */", "-        public void addEqualsNode(DetailAST aAST)", "-        {", "-            if (!mHasEqualsObject) {", "-                mEqualsNodes.add(aAST);", "-            }", "-        }", "+        mEqualsMethods.clear();", "+        mHasEqualsObject = false;", "+", "+        // examine method definitions for equals methods", "+        final DetailAST objBlock = aAST.findFirstToken(TokenTypes.OBJBLOCK);", "+        DetailAST child = (DetailAST) objBlock.getFirstChild();", "+        while (child != null) {", "+            if (child.getType() == TokenTypes.METHOD_DEF) {", "+                if (isEqualsMethod(child)) {", "+                    if (hasObjectParameter(child)) {", "+                        mHasEqualsObject = true;", "+                    }", "+                    else {", "+                        mEqualsMethods.add(child);", "+                    }", "+            child = (DetailAST) child.getNextSibling();", "+        // report equals method definitions", "+        if (!mHasEqualsObject) {", "+            final Iterator it = mEqualsMethods.iterator();", "+            while (it.hasNext()) {", "+                final DetailAST equalsAST = (DetailAST) it.next();", "+                final DetailAST nameNode =", "+                    equalsAST.findFirstToken(TokenTypes.IDENT);", "+                log(", "+                    nameNode.getLineNo(),", "+                    nameNode.getColumnNo(),", "+                    \"covariant.equals\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ce6470eb09ebe28b160f3c73e5c00b3a", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RedundantModifierCheck.java", "commitBeforeChange": "8acc405dd30502bbbcdaf60a75ddd60dfa2b5a50", "commitAfterChange": "3ed2fd68f81f6200362f4babc9595b29f437ddd9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public void visitToken(DetailAST aAST)", "signatureAfterChange": "     public void visitToken(DetailAST aAST)", "diff": ["-        if (!ScopeUtils.inInterfaceBlock(aAST)) {", "-            return;", "-        }", "+        if (ScopeUtils.inInterfaceBlock(aAST)) {", "+            final DetailAST modifiers =", "+                aAST.findFirstToken(TokenTypes.MODIFIERS);", "-        DetailAST modifiers = aAST.findFirstToken(TokenTypes.MODIFIERS);", "+            DetailAST modifier = (DetailAST) modifiers.getFirstChild();", "+            while (modifier != null) {", "-        DetailAST modifier = (DetailAST) modifiers.getFirstChild();", "-        while (modifier != null) {", "+                // javac does not allow final or static in interface methods", "+                // hence no need to check that this is not a method", "-            // javac does not allow final or static in interface methods", "-            // hence no need to check that this is not a method", "+                final int type = modifier.getType();", "+                if (type == TokenTypes.LITERAL_PUBLIC", "+                    || type == TokenTypes.ABSTRACT", "+                    || type == TokenTypes.LITERAL_STATIC", "+                    || type == TokenTypes.FINAL)", "+                {", "+                    log(modifier.getLineNo(),", "+                        modifier.getColumnNo(),", "+                        \"redundantModifier\",", "+                        new String[] {modifier.getText()});", "+                    break;", "+                }", "-            final int type = modifier.getType();", "-            if (type == TokenTypes.LITERAL_PUBLIC", "-                || type == TokenTypes.ABSTRACT", "-                || type == TokenTypes.LITERAL_STATIC", "-                || type == TokenTypes.FINAL)", "-            {", "-                log(modifier.getLineNo(),", "-                    modifier.getColumnNo(),", "-                    \"redundantModifier\",", "-                    new String[] {modifier.getText()});", "-                break;", "+                modifier = (DetailAST) modifier.getNextSibling();", "-", "-            modifier = (DetailAST) modifier.getNextSibling();", "+        }", "+        else if (aAST.getType() == TokenTypes.METHOD_DEF) {", "+            final DetailAST modifiers =", "+                            aAST.findFirstToken(TokenTypes.MODIFIERS);", "+            // private method?", "+            boolean checkFinal =", "+                modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);", "+            // declared in a final class?", "+            DetailAST parent = aAST.getParent();", "+            while (parent != null) {", "+                if (parent.getType() == TokenTypes.CLASS_DEF) {", "+                    final DetailAST classModifiers =", "+                        parent.findFirstToken(TokenTypes.MODIFIERS);", "+                    checkFinal |=", "+                        classModifiers.branchContains(TokenTypes.FINAL);", "+                    break;", "+                }", "+                parent = parent.getParent();", "+            }", "+            if (checkFinal) {", "+                DetailAST modifier = (DetailAST) modifiers.getFirstChild();", "+                while (modifier != null) {", "+                    final int type = modifier.getType();", "+                    if (type == TokenTypes.FINAL) {", "+                        log(modifier.getLineNo(),", "+                            modifier.getColumnNo(),", "+                            \"redundantModifier\",", "+                            new String[] {modifier.getText()});", "+                        break;", "+                    }", "+                    modifier = (DetailAST) modifier.getNextSibling();", "+                }", "+            }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d6e262d9aebf6e29de575debfd7fb89c", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/PackageNamesLoader.java", "commitBeforeChange": "79404974eff1458f4243f8acd6a08b6a8b869342", "commitAfterChange": "fe9057366308642868c25d427c3ee94411b37170", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": "     private ModuleFactory getModuleFactory()", "signatureAfterChange": "     public static Set<String> getPackageNames(ClassLoader aClassLoader)         throws CheckstyleException", "diff": ["-     */", "-    private ModuleFactory getModuleFactory()", "-    {", "-        return mModuleFactory;", "-    }", "+    public static Set<String> getPackageNames(ClassLoader aClassLoader)", "+        Enumeration<URL> packageFiles = null;", "+        try {", "+            packageFiles = aClassLoader.getResources(CHECKSTYLE_PACKAGES);", "+        }", "+        catch (IOException e) {", "+            throw new CheckstyleException(", "+                    \"unable to get package file resources\", e);", "+        }", "+", "+        //create the loader outside the loop to prevent PackageObjectFactory", "+        //being created anew for each file", "+        final PackageNamesLoader namesLoader = newPackageNamesLoader();", "+", "+        while ((null != packageFiles) && packageFiles.hasMoreElements()) {", "+            final URL aPackageFile = packageFiles.nextElement();", "+            InputStream stream = null;", "+", "+            try {", "+                stream = new BufferedInputStream(aPackageFile.openStream());", "+                final InputSource source = new InputSource(stream);", "+                loadPackageNamesSource(source, \"default package names\",", "+                    namesLoader);", "+            }", "+            catch (IOException e) {", "+                throw new CheckstyleException(", "+                        \"unable to open \" + aPackageFile, e);", "+            }", "+            finally {", "+                if (stream != null) {", "+                    try {", "+                        stream.close();", "+                    }", "+                    catch (IOException e) {", "+                        throw new CheckstyleException(", "+                                \"error closing stream\", e);", "+                    }", "+                }", "+            }", "+        }", "+        return namesLoader.getPackageNames();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e64f993ace4412945bc8b427a6bf5034", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/HeaderCheck.java", "commitBeforeChange": "c2afeecbf7b6c8e2ed6b50516adbe788fd105f31", "commitAfterChange": "f24c8ee834e006c406c0538dbfccc2fe6c07279c", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public void beginTree()", "signatureAfterChange": "     public void beginTree()", "diff": ["-        String[] lines = getLines();", "-        log(0, \"file has \" + lines.length + \" lines\");", "+        System.out.println(\"HeaderCheck.beginTree\");", "+        if (mHeaderLines != null) {", "+", "+            final String[] lines = getLines();", "+", "+            if (mHeaderLines.length > lines.length) {", "+                log(1, \"header.missing\");", "+            }", "+            else {", "+                for (int i = 0; i < mHeaderLines.length; i++) {", "+                    // skip lines we are meant to ignore", "+                    if (isIgnoreLine(i + 1)) {", "+                        continue;", "+                    }", "+", "+                    if (!isMatch(i)) {", "+                        log(i + 1, \"header.mismatch\", mHeaderLines[i]);", "+                        break; // stop checking", "+                    }", "+                }", "+            }", "+        }"]}]}