{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "93fc4b0d83556f48f32117f7bea2390e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "276f033d467d3fa2afa4684b049e33fc", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java", "commitBeforeChange": "be8127a604bfdd91ff7cd32a1f825c9851d791ec", "commitAfterChange": "7d097b6fa682f8dcfedd95da2db8fed980c51705", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "     private List<JavadocTag> getJavadocTags(TextBlock aCmt)", "signatureAfterChange": "     private List<JavadocTag> getJavadocTags(TextBlock aCmt)", "diff": ["-        final String[] text = aCmt.getText();", "-        final List<JavadocTag> tags = Lists.newArrayList();", "-        Pattern tagPattern = Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");", "-        for (int i = 0; i < text.length; i++) {", "-            final String s = text[i];", "-            final Matcher tagMatcher = tagPattern.matcher(s);", "-            if (tagMatcher.find()) {", "-                final String tagName = tagMatcher.group(1);", "-", "-                String content = s.substring(tagMatcher.end(1));", "-                if (content.endsWith(\"*/\")) {", "-                    content = content.substring(0, content.length() - 2);", "-                }", "-                int col = tagMatcher.start(1) - 1;", "-                if (i == 0) {", "-                    col += aCmt.getStartColNo();", "-                }", "-", "-                if (JavadocTagInfo.isValidName(tagName)) {", "-                    tags.add(new JavadocTag(aCmt.getStartLineNo() + i, col,", "-                            tagName, content.trim()));", "-                }", "-                else if (!mAllowUnknownTags) {", "-                    log(aCmt.getStartLineNo() + i, col,", "-                            \"javadoc.unknownTag\", tagName);", "-                }", "+        JavadocTags tags =", "+            JavadocUtils.getJavadocTags(aCmt, JavadocTagType.BLOCK);", "+        if (!mAllowUnknownTags) {", "+            for (InvalidJavadocTag tag : tags.invalidTags) {", "+                log(tag.line, tag.col, \"javadoc.unknownTag\", tag.name);", "-            tagPattern = Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");", "-        return tags;", "+        return tags.validTags;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a1c2ffe45ad22458a271d4856b1a47b", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java", "commitBeforeChange": "5b01236f52f59b632659cac386768805f7a9006f", "commitAfterChange": "41740f2d68baba3ae185e8303038f841e7d6fc5a", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public static JavadocTags getJavadocTags(TextBlock cmt,             JavadocTagType tagType)", "signatureAfterChange": "     public static JavadocTags getJavadocTags(TextBlock cmt,             JavadocTagType tagType)", "diff": ["-                // Match Javadoc text after comment characters", "-                final Pattern commentPattern = Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");", "-                final Matcher commentMatcher = commentPattern.matcher(s);", "-                final String commentContents;", "-", "-                // offset including comment characters", "-                final int commentOffset;", "-", "-                if (commentMatcher.find()) {", "-                    commentContents = commentMatcher.group(1);", "-                    commentOffset = commentMatcher.start(1) - 1;", "-                }", "-                else {", "-                    // No leading asterisks, still valid", "-                    commentContents = s;", "-                    commentOffset = 0;", "-                }", "-                final Pattern tagPattern = Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");", "-                final Matcher tagMatcher = tagPattern.matcher(commentContents);", "-                while (tagMatcher.find()) {", "-                    final String tagName = tagMatcher.group(1);", "-                    final String tagValue = tagMatcher.group(2).trim();", "-                    final int line = cmt.getStartLineNo() + i;", "-                    int col = commentOffset + tagMatcher.start(1) - 1;", "-                    if (i == 0) {", "-                        col += cmt.getStartColNo();", "-                    }", "-                    if (JavadocTagInfo.isValidName(tagName)) {", "-                        tags.add(new JavadocTag(line, col, tagName,", "-                                tagValue));", "-                    }", "-                    else {", "-                        invalidTags.add(new InvalidJavadocTag(line, col,", "-                                tagName));", "-                    }", "-                    // else Error: Unexpected match count for inline Javadoc", "-                    // tag!", "-                }", "+                lookForInlineTags(cmt, i, tags, invalidTags);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ce662deb4a3e1d9799368a418a7a925e", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java", "commitBeforeChange": "cc6caa71f55ae33ad8c018e3b7915e6b93b7de81", "commitAfterChange": "3eca04c940bcdf575c2f9009202a4145e9a82c15", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      @Override     public void visitToken(DetailAST ast)", "signatureAfterChange": "      @Override     public void visitToken(DetailAST ast)", "diff": ["-        ScopeState state;", "-                state = scopeStates.peek();", "-                if (state.currentScopeState > STATE_CTOR_DEF) {", "-                    if (!ignoreConstructors) {", "-                        log(ast, MSG_CONSTRUCTOR);", "-                    }", "-                }", "-                else {", "-                    state.currentScopeState = STATE_CTOR_DEF;", "-                }", "+                processConstructor(ast);", "-                state = scopeStates.peek();", "+", "-                if (state.currentScopeState > STATE_METHOD_DEF) {", "-                    if (!ignoreMethods) {", "-                        log(ast, MSG_METHOD);", "-                    }", "-                }", "-                else {", "-                    state.currentScopeState = STATE_METHOD_DEF;", "-                }", "+                processMethod(ast);", "-                    || ast.getParent().getParent().getType()", "+                        || ast.getParent().getParent().getType()", "-                state = scopeStates.peek();", "-                if (ast.findFirstToken(TokenTypes.LITERAL_STATIC) != null) {", "-                    if (state.currentScopeState > STATE_STATIC_VARIABLE_DEF) {", "-                        if (!ignoreModifiers", "-                            || state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {", "-                            log(ast, MSG_STATIC);", "-                        }", "-                    }", "-                    else {", "-                        state.currentScopeState = STATE_STATIC_VARIABLE_DEF;", "-                    }", "-                }", "-                else {", "-                    if (state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {", "-                        log(ast, MSG_INSTANCE);", "-                    }", "-                    else if (state.currentScopeState == STATE_STATIC_VARIABLE_DEF) {", "-                        state.declarationAccess = Scope.PUBLIC;", "-                        state.currentScopeState = STATE_INSTANCE_VARIABLE_DEF;", "-                    }", "-                }", "-", "-                final Scope access = ScopeUtils.getScopeFromMods(ast);", "-                if (state.declarationAccess.compareTo(access) > 0) {", "-                    if (!ignoreModifiers) {", "-                        log(ast, MSG_ACCESS);", "-                    }", "-                }", "-                else {", "-                    state.declarationAccess = access;", "-                }", "+                processModifiers(ast);", "+                break;", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d1e7811e8f6b51356d133fae773432d9", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java", "commitBeforeChange": "3c99349a8403f878ea4e3d1295b700db8c1cbe67", "commitAfterChange": "d64bdf0caa867be3913f2665ef4fcc654524937e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "     private String getIllegalInstantiation(String className)", "signatureAfterChange": "     private String getIllegalInstantiation(String className)", "diff": ["+", "-", "-            // class from java.lang", "-            if (illegalLen - JAVA_LANG.length() == clsNameLen", "-                && illegal.endsWith(className)", "-                && illegal.startsWith(JAVA_LANG)) {", "-                // java.lang needs no import, but a class without import might", "-                // also come from the same file or be in the same package.", "-                // E.g. if a class defines an inner class \"Boolean\",", "-                // the expression \"new Boolean()\" refers to that class,", "-                // not to java.lang.Boolean", "-", "-                final boolean isSameFile = classNames.contains(className);", "-", "-                boolean isSamePackage = false;", "-                try {", "-                    final ClassLoader classLoader = getClassLoader();", "-                    if (classLoader != null) {", "-                        final String fqName = pkgName + \".\" + className;", "-                        classLoader.loadClass(fqName);", "-                        // no ClassNotFoundException, fqName is a known class", "-                        isSamePackage = true;", "-                    }", "-                }", "-                catch (final ClassNotFoundException ex) {", "-                    // not a class from the same package", "-                    isSamePackage = false;", "-                }", "-", "-                if (!(isSameFile || isSamePackage)) {", "-                    return illegal;", "-                }", "-            }", "-", "-            // class from same package", "-", "-            // the toplevel package (pkgName == null) is covered by the", "-            // \"illegalInsts.contains(className)\" check above", "-", "-            // the test is the \"no garbage\" version of", "-            // illegal.equals(pkgName + \".\" + className)", "-            if (pkgName != null", "-                && clsNameLen == illegalLen - pkgNameLen - 1", "-                && illegal.charAt(pkgNameLen) == '.'", "-                && illegal.endsWith(className)", "-                && illegal.startsWith(pkgName)) {", "+            if (isStandardClass(className, clsNameLen, illegal, illegalLen)) {", "-            // import statements", "-            for (FullIdent importLineText : imports) {", "-                final String importArg = importLineText.getText();", "-                if (importArg.endsWith(\".*\")) {", "-                    final String fqClass =", "-                        importArg.substring(0, importArg.length() - 1)", "-                        + className;", "-                    // assume that illegalInsts only contain existing classes", "-                    // or else we might create a false alarm here", "-                    if (illegalClasses.contains(fqClass)) {", "-                        return fqClass;", "-                    }", "+            if (isSamePackage(className, clsNameLen, pkgNameLen, illegal, illegalLen)) {", "+                return illegal;", "+            }", "+            final String importArg = checkImportStatements(className);", "+            if (importArg != null) {", "+                return importArg;", "+            }", "+        }", "+        return null;", "+    }", "-                else {", "-                    if (Utils.baseClassname(importArg).equals(className)", "-                        && illegalClasses.contains(importArg)) {", "-                        return importArg;", "-                    }"]}]}