{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0c892dacf5392d1992d3736e50f6338e", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0f95dc34b35fc6ca286876bdb1f07db6", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/OperatorWrapCheck.java", "commitBeforeChange": "36af550d96f529ecd299b568702c2e197b1c0aa9", "commitAfterChange": "468541ac37d54fbeac5061958d3661ff133a7ffe", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public void visitToken(DetailAST aAST)", "signatureAfterChange": "     public void visitToken(DetailAST aAST)", "diff": ["-        if (wOp != OperatorWrapOption.NL.IGNORE) {", "-            final String text = aAST.getText();", "-            final int colNo = aAST.getColumnNo();", "-            final int lineNo = aAST.getLineNo();", "-            // TODO: Handle comments before and after operator", "-            // Check if rest of line is whitespace, and not just the operator", "-            // by itself. This last bit is to handle the operator on a line by", "-            // itself.", "-            if (wOp == OperatorWrapOption.NL", "-                && !text.equals(getLines()[lineNo - 1].trim())", "-                && (getLines()[lineNo - 1].substring(colNo + text.length())", "-                    .trim().length() == 0))", "-            {", "-                log(lineNo, colNo, \"line.new\", text);", "-            }", "-            else if (wOp == OperatorWrapOption.EOL", "-                      && Utils.whitespaceBefore(colNo - 1,", "-                                               getLines()[lineNo - 1]))", "-            {", "-                log(lineNo, colNo, \"line.previous\", text);", "-            }", "+        final String text = aAST.getText();", "+        final int colNo = aAST.getColumnNo();", "+        final int lineNo = aAST.getLineNo();", "+        final String currentLine = getLines()[lineNo - 1];", "+        // TODO: Handle comments before and after operator", "+        // Check if rest of line is whitespace, and not just the operator", "+        // by itself. This last bit is to handle the operator on a line by", "+        // itself.", "+        if (wOp == OperatorWrapOption.NL", "+            && !text.equals(currentLine.trim())", "+            && (currentLine.substring(colNo + text.length())", "+                .trim().length() == 0))", "+        {", "+            log(lineNo, colNo, \"line.new\", text);", "-", "+        else if (wOp == OperatorWrapOption.EOL", "+                  && Utils.whitespaceBefore(colNo - 1, currentLine))", "+        {", "+            log(lineNo, colNo, \"line.previous\", text);", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6cb9c42e5d0f409f5b866357d8468320", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/GenericIllegalRegexpCheck.java", "commitBeforeChange": "c5dfb268770999ece0efcab2f47f007dec339264", "commitAfterChange": "5f0f6d3929dc2c7f1570c03f24a652bffe61db6f", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "     private boolean findNonCommentMatch(             String aLine, int aLineNumber, int aStartPosition)", "signatureAfterChange": "     private boolean findNonCommentMatch(             String aLine, int aLineNumber, int aStartPosition)", "diff": ["-        if (foundMatch) {", "-            // match is found, check for intersection with comment", "-            final int startCol = matcher.start(0);", "-            final int endCol = matcher.end(0) - 1;", "-            final FileContents fileContents = getFileContents();", "-            if (fileContents.hasIntersectionWithComment(aLineNumber,", "-                startCol, aLineNumber, endCol))", "-            {", "-                // was part of comment", "-                if (endCol < aLine.length()) {", "-                    // check if the expression is on the rest of the line", "-                    return findNonCommentMatch(aLine, aLineNumber, endCol);", "-                }", "-                // end of line reached", "-                return false;", "-            }", "-            // not intersecting with comment", "-            return true;", "+        if (!foundMatch) {", "+            return false;", "-        // no match is found", "-        return false;", "+        // match is found, check for intersection with comment", "+        final int startCol = matcher.start(0);", "+        final int endCol = matcher.end(0);", "+        // Note that Matcher.end(int) returns he offset AFTER the", "+        // last matched character, but hasIntersectionWithComment()", "+        // needs column number of the last character.", "+        // So we need to use (endCol - 1) here.", "+        final boolean intersectsWithComment = getFileContents()", "+            .hasIntersectionWithComment(aLineNumber, startCol,", "+                                        aLineNumber, endCol - 1);", "+        if (intersectsWithComment) {", "+            if (endCol < aLine.length()) {", "+                // check if the expression is on the rest of the line", "+                return findNonCommentMatch(aLine, aLineNumber, endCol);", "+            }", "+            // end of line reached", "+            return false;", "+        }", "+        // not intersecting with comment", "+        return true;"]}]}