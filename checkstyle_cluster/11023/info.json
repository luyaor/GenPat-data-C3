{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9c3e80633b6204ada1b0a83ef8fb280a", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "41b46294ae19529a7c71f81adfd9779e", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java", "commitBeforeChange": "f58f92adf6804395c66c41d408dc8e2155cb0c5d", "commitAfterChange": "f02d45fd6d0615ca856e6cc79a37596e70e4ece9", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "      @Override     public void visitToken(DetailAST ast)", "signatureAfterChange": "      @Override     public void visitToken(DetailAST ast)", "diff": ["-        if (ScopeUtils.isInInterfaceOrAnnotationBlock(ast)) {", "-            return;", "-        }", "-        if (isPrivateOrFinalOrAbstract(ast)) {", "-            return;", "-        }", "+        if (!ScopeUtils.isInInterfaceOrAnnotationBlock(ast)", "+                && !isPrivateOrFinalOrAbstract(ast)", "+                && ScopeUtils.getSurroundingScope(ast).isIn(Scope.PROTECTED)) {", "-        // method is ok if containing class is not visible in API and", "-        // cannot be extended by 3rd parties (bug #884035)", "-        if (!ScopeUtils.getSurroundingScope(ast).isIn(Scope.PROTECTED)) {", "-            return;", "-        }", "+            // method is ok if it is implementation can verified to be empty", "+            // Note: native methods don't have impl in java code, so", "+            // implementation can be null even if method not abstract", "+            final DetailAST implementation = ast.findFirstToken(TokenTypes.SLIST);", "+            final boolean nonEmptyImplementation = implementation == null", "+                    || implementation.getFirstChild().getType() != TokenTypes.RCURLY;", "-        // method is ok if it is implementation can verified to be empty", "-        // Note: native methods don't have impl in java code, so", "-        // implementation can be null even if method not abstract", "-        final DetailAST implementation = ast.findFirstToken(TokenTypes.SLIST);", "-        if (implementation != null", "-            && implementation.getFirstChild().getType() == TokenTypes.RCURLY) {", "-            return;", "-        }", "+            final DetailAST classDef = findContainingClass(ast);", "+            final DetailAST classMods = classDef.findFirstToken(TokenTypes.MODIFIERS);", "+            // check if the containing class can be subclassed", "+            final boolean classCanBeSubclassed = classDef.getType() != TokenTypes.ENUM_DEF", "+                    && !classMods.branchContains(TokenTypes.FINAL);", "-        // check if the containing class can be subclassed", "-        final DetailAST classDef = findContainingClass(ast);", "-        final DetailAST classMods =", "-            classDef.findFirstToken(TokenTypes.MODIFIERS);", "-        if (classDef.getType() == TokenTypes.ENUM_DEF", "-            || classMods.branchContains(TokenTypes.FINAL)) {", "-            return;", "-        }", "+            if (nonEmptyImplementation && classCanBeSubclassed", "+                    && hasDefaultOrExplNonPrivateCtor(classDef)) {", "-        if (hasDefaultOrExplNonPrivateCtor(classDef)) {", "-            final String name = ast.findFirstToken(TokenTypes.IDENT).getText();", "-            log(ast.getLineNo(), ast.getColumnNo(),", "-                MSG_KEY, name);", "+                final String name = ast.findFirstToken(TokenTypes.IDENT).getText();", "+                log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY, name);", "+            }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8fe6a4a939731f19514f2f0d4810f555", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java", "commitBeforeChange": "5a3f05ec8038daa674666bbaa82d59127aa74f92", "commitAfterChange": "99ce97725cd037d152c571e5ff58eac9247d072d", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "     private void processField(DetailAST ast, int parentType)", "signatureAfterChange": "     private void processField(DetailAST ast, int parentType)", "diff": ["-        if (ScopeUtils.getSurroundingScope(ast) == null) {", "-            // it is not a class or interface it's", "-            // either import or package", "-            // we shouldn't checks this", "-            return;", "-        }", "+        final boolean importOrPackage = ScopeUtils.getSurroundingScope(ast) == null;", "+        final boolean methodNameInMethodCall = parentType == TokenTypes.DOT", "+                && ast.getPreviousSibling() != null;", "+        final boolean typeName = parentType == TokenTypes.TYPE", "+                || parentType == TokenTypes.LITERAL_NEW;", "-        if (parentType == TokenTypes.DOT", "-                && ast.getPreviousSibling() != null) {", "-            // it's the method name in a method call; no problem", "-            return;", "-        }", "-        if (parentType == TokenTypes.TYPE", "-                || parentType == TokenTypes.LITERAL_NEW) {", "-            // it's a type name; no problem", "-            return;", "-        }", "-        if (isDeclarationToken(parentType)) {", "-            // it's being declared; no problem", "-            return;", "-        }", "+        if (!importOrPackage", "+                && !methodNameInMethodCall", "+                && !typeName", "+                && !isDeclarationToken(parentType)) {", "-        final String name = ast.getText();", "-        if (isClassField(name)) {", "-            log(ast, MSG_VARIABLE, name);", "+            final String name = ast.getText();", "+", "+            if (isClassField(name)) {", "+                log(ast, MSG_VARIABLE, name);", "+            }"]}]}