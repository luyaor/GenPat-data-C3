{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e5707e1d2bc2c11e9e7da446d84d3619", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "683cabaec13703cbc8aa466393476972", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java", "commitBeforeChange": "fe6e0fd4231aaba97cf423899f93697400880c93", "commitAfterChange": "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 8, "signatureBeforeChange": "     public Checker(Configuration aConfig)         throws RESyntaxException, IOException", "signatureAfterChange": "      public Checker(Configuration aConfig, CheckConfiguration[] aConfigs)         throws ClassNotFoundException, InstantiationException,                IllegalAccessException", "diff": ["+", "+    public Checker(Configuration aConfig, CheckConfiguration[] aConfigs)", "+        throws ClassNotFoundException, InstantiationException,", "+               IllegalAccessException", "+    {", "+        // TODO: document to make testing easier", "+        mConfig = aConfig;", "+        mCache = new PropertyCacheFile(aConfig);", "+        LocalizedMessage.setLocale(new Locale(mConfig.getLocaleLanguage(),", "+                                              mConfig.getLocaleCountry()));", "+        mMessages = new LocalizedMessages(mConfig.getTabWidth());", "+        mWalker = new TreeWalker(mMessages);", "+        // TODO: improve the error handing", "+        for (int i = 0; i < aConfigs.length; i++) {", "+            final CheckConfiguration config = aConfigs[i];", "+            mWalker.registerCheck(", "+                config.createInstance(mConfig.getClassLoader()), config);", "+        }", "+    }", "-        throws RESyntaxException, IOException"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e79847d86b6c688526a8e5ace13198d", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java", "commitBeforeChange": "e3741d10267df217664f47fdf68169286e2d31bc", "commitAfterChange": "2554557c1c4dda6cb348ba053a60c17d8ada9f73", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 5, "signatureBeforeChange": "     private boolean isAssignment(DetailAST aAST)", "signatureAfterChange": "     private static boolean isInContext(DetailAST aAST, int[][] aContextSet)", "diff": ["-    private boolean isAssignment(DetailAST aAST)", "-        // TODO: make actual tokens available to Check and loop over actual", "-        // tokens here?", "-        final int[] tokens = getDefaultTokens();", "-        for (int i = 0; i < tokens.length; i++) {", "-            final int tokenType = tokens[i];", "-            if (astType == tokenType) {", "-                return true;", "+     */", "+    private static boolean isInContext(DetailAST aAST, int[][] aContextSet)", "+    {", "+        for (int i = 0; i < aContextSet.length; i++) {", "+            DetailAST current = aAST;", "+            final int len = aContextSet[i].length;", "+            for (int j = 0; j < len; j++) {", "+                current = current.getParent();", "+                final int expectedType = aContextSet[i][j];", "+                if (current == null || current.getType() != expectedType) {", "+                    break;", "+                }", "+                if (j == len - 1) {", "+                    return true;", "+                }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e6aae68c80b0c5850de68db2d78126c", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/duplicates/StrictDuplicateCodeCheck.java", "commitBeforeChange": "b0240a0200663fbf1d3146d1aefe12207fdde4af", "commitAfterChange": "9aa72722de7b5a4ffb5d50945c7bce8b58f25e8e", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "     private int findDuplicateFromLine(         final int aI, final int aJ, final int aILine)", "signatureAfterChange": "     private void findDuplicateFromLine(         final int aI, final int aJ, final int aILine,         final int[] aJLines, final MultiMap aIgnore)", "diff": ["-    private int findDuplicateFromLine(", "-        final int aI, final int aJ, final int aILine)", "+    private void findDuplicateFromLine(", "+        final int aI, final int aJ, final int aILine,", "+        final int[] aJLines, final MultiMap aIgnore)", "-        final long checkSum = mLineBlockChecksums[aI][aILine];", "+        final long[] iCheckSums = mLineBlockChecksums[aI];", "+        final long[] jCheckSums = mLineBlockChecksums[aJ];", "-        final int iBlockCount = mLineBlockChecksums[aI].length;", "-        final int jBlockCount = mLineBlockChecksums[aJ].length;", "+        final int iBlockCount = iCheckSums.length;", "+        final int jBlockCount = jCheckSums.length;", "-        for (int jBlock = 0; jBlock < jBlockCount; jBlock++) {", "+        final long checkSum = iCheckSums[aILine];", "-            if (aI == aJ && aILine >= jBlock) {", "+        final Integer iLine = new Integer(aILine);", "+", "+        for (int jLineIdx = 0; jLineIdx < aJLines.length; jLineIdx++) {", "+", "+            int jLine = aJLines[jLineIdx];", "+", "+            if (aI == aJ && aILine >= jLine) {", "-            if (mLineBlockChecksums[aJ][jBlock] != checkSum) {", "+            if (jCheckSums[jLine] != checkSum) {", "-            int duplicateLines = verifiyDuplicateLines(aI, aJ, aILine, jBlock);", "+            final Collection ignoreEntries = (Collection) aIgnore.get(iLine);", "+            // avoid Integer constructor whenever we can", "+            if (ignoreEntries != null) {", "+                if (ignoreEntries.contains(new Integer(jLine))) {", "+                    continue;", "+                }", "+            }", "+", "+            int duplicateLines = verifiyDuplicateLines(aI, aJ, aILine, jLine);", "-                reportDuplicate(duplicateLines, aILine, mFiles[aJ], jBlock);", "-", "-                // skip to end of equivalent section", "-                return aILine + duplicateLines;", "+                reportDuplicate(duplicateLines, aILine, mFiles[aJ], jLine);", "+                int extend = duplicateLines - mMin;", "+                for (int i = 0; i < extend; i++) {", "+                    final int offset = (i + 1);", "+                    aIgnore.put(new Integer(aILine + offset),", "+                            new Integer(jLine + offset));", "+                }", "-        return aILine;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e64f993ace4412945bc8b427a6bf5034", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/HeaderCheck.java", "commitBeforeChange": "c2afeecbf7b6c8e2ed6b50516adbe788fd105f31", "commitAfterChange": "f24c8ee834e006c406c0538dbfccc2fe6c07279c", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public void beginTree()", "signatureAfterChange": "     public void beginTree()", "diff": ["-        String[] lines = getLines();", "-        log(0, \"file has \" + lines.length + \" lines\");", "+        System.out.println(\"HeaderCheck.beginTree\");", "+        if (mHeaderLines != null) {", "+", "+            final String[] lines = getLines();", "+", "+            if (mHeaderLines.length > lines.length) {", "+                log(1, \"header.missing\");", "+            }", "+            else {", "+                for (int i = 0; i < mHeaderLines.length; i++) {", "+                    // skip lines we are meant to ignore", "+                    if (isIgnoreLine(i + 1)) {", "+                        continue;", "+                    }", "+", "+                    if (!isMatch(i)) {", "+                        log(i + 1, \"header.mismatch\", mHeaderLines[i]);", "+                        break; // stop checking", "+                    }", "+                }", "+            }", "+        }"]}]}