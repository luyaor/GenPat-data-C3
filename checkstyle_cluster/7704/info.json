{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9005d5874493d7feb187bb694afd43d4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1282f29c917dd6f7e837a4eb8257b3d", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java", "commitBeforeChange": "9aa49c8f6d2b30577565f87984819e1df0d62d0f", "commitAfterChange": "c56dce9222a819b4741b4c0cd664d38c58b31050", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": "     private static DetailAST getArrayTypeOrIdentifier(DetailAST arrayDeclarator)", "signatureAfterChange": "     private static DetailAST getArrayDeclaratorPreviousElement(DetailAST ast)", "diff": ["-    private static DetailAST getArrayTypeOrIdentifier(DetailAST arrayDeclarator) {", "-        DetailAST typeOrIdent = arrayDeclarator;", "-        if (isArrayInstantiation(arrayDeclarator)) {", "-            typeOrIdent = arrayDeclarator.getParent().getFirstChild();", "-        else if (isMultiDimensionalArray(arrayDeclarator)) {", "-            if (isCStyleMultiDimensionalArrayDeclaration(arrayDeclarator)) {", "-                if (arrayDeclarator.getParent().getType() != TokenTypes.ARRAY_DECLARATOR) {", "-                    typeOrIdent = getArrayIdentifier(arrayDeclarator);", "-                }", "+     */", "+    private static DetailAST getArrayDeclaratorPreviousElement(DetailAST ast) {", "+        final DetailAST previousElement;", "+        final DetailAST firstChild = ast.getFirstChild();", "+        if (firstChild.getType() == TokenTypes.ARRAY_DECLARATOR) {", "+            // second or higher array index", "+            previousElement = firstChild.findFirstToken(TokenTypes.RBRACK);", "+        }", "+        else {", "+            // first array index, is preceded with identifier or type", "+            final DetailAST parent = getFirstNonArrayDeclaratorParent(ast);", "+            switch (parent.getType()) {", "+                // generics", "+                case TokenTypes.TYPE_ARGUMENT:", "+                    final DetailAST wildcard = parent.findFirstToken(TokenTypes.WILDCARD_TYPE);", "+                    if (wildcard == null) {", "+                        // usual generic type argument like <char[]>", "+                        previousElement = getTypeLastNode(ast);", "+                    }", "+                    else {", "+                        // constructions with wildcard like <? extends String[]>", "+                        previousElement = getTypeLastNode(ast.getFirstChild());", "+                    }", "+                    break;", "+                // 'new' is a special case with its own subtree structure", "+                case TokenTypes.LITERAL_NEW:", "+                    previousElement = getTypeLastNode(parent);", "+                    break;", "+                // mundane array declaration, can be either java style or C style", "+                case TokenTypes.TYPE:", "+                    previousElement = getPreviousNodeWithParentOfTypeAst(ast, parent);", "+                    break;", "+                // i.e. boolean[].class", "+                case TokenTypes.DOT:", "+                    previousElement = getTypeLastNode(ast);", "+                    break;", "+                // java 8 method reference", "+                case TokenTypes.METHOD_REF:", "+                    final DetailAST ident = getIdentLastToken(ast);", "+                    if (ident == null) {", "+                        //i.e. int[]::new", "+                        previousElement = ast.getFirstChild();", "+                    }", "+                    else {", "+                        previousElement = ident;", "+                    }", "+                    break;", "+                default:", "+                    throw new IllegalStateException(\"unexpected ast syntax\" + parent);", "+            }", "+        }", "+        return previousElement;", "+    }", "-                DetailAST arrayIdentifier = arrayDeclarator.getFirstChild();", "-                while (arrayIdentifier != null) {", "-                    typeOrIdent = arrayIdentifier;", "-                    arrayIdentifier = arrayIdentifier.getFirstChild();", "-                }", "-            if (isCStyleArrayDeclaration(arrayDeclarator)) {", "-                typeOrIdent = getArrayIdentifier(arrayDeclarator);", "-                if (isArrayUsedAsTypeForGenericBoundedWildcard(arrayDeclarator)) {", "-                    typeOrIdent = arrayDeclarator.getParent();", "-                    typeOrIdent = arrayDeclarator.getFirstChild();", "-        return typeOrIdent;", "-    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f82bf96fb618d929b2c9cadb889099c0", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java", "commitBeforeChange": "4011bf37400a7932f6c7a6f8fe1686673cea31c7", "commitAfterChange": "fd6a743fd4b3c9283d62174327dd978bda694892", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private void parseTags(String aText, int aLineNo)", "signatureAfterChange": "     private void parseTags(String[] aText, int aLineNo)", "diff": ["-    private void parseTags(String aText, int aLineNo)", "+    private void parseTags(String[] aText, int aLineNo)", "-        int position = 0;", "-        final StringTokenizer tokenizer =", "-            new StringTokenizer(aText, \" \\t\\n\\r\\f<>\", true);", "+        final int nLines = aText.length;", "+        Point position = new Point(0, 0);", "-        while (tokenizer.hasMoreTokens()) {", "-            String token = tokenizer.nextToken();", "-            position += token.length();", "+        position = findChar(aText, '<', position);", "+        while (position.getLineNo() < nLines) {", "+            // if this is html comment then skip it", "+            if (isCommentTag(aText, position)) {", "+                position = skipHtmlComment(aText, position);", "+            }", "+            else if (!isTag(aText, position)) {", "+                position = getNextCharPos(aText, position);", "+            }", "+            else {", "+                // find end of tag", "+                final Point endTag = findChar(aText, '>', position);", "+                final boolean incompleteTag = (endTag.getLineNo() >= nLines);", "+                // get tag id (one word)", "+                final String tagId =", "+                    (incompleteTag ? \"\" : getTagId(aText, position));", "+                // is this closed tag", "+                final boolean closedTag =", "+                    (endTag.getLineNo() < nLines && endTag.getColumnNo() > 0", "+                     && aText[endTag.getLineNo()]", "+                     .charAt(endTag.getColumnNo() - 1) == '/');", "+                // add new tag", "+                add(new HtmlTag(tagId,", "+                                position.getLineNo() + aLineNo,", "+                                position.getColumnNo(),", "+                                closedTag,", "+                                incompleteTag,", "+                                aText[position.getLineNo()]));", "+                position = endTag;", "+            }", "+            position = findChar(aText, '<', position);", "+        }", "+    }", "-            if (token.equals(\"<\")) {", "-                token = tokenizer.nextToken();", "-                position += token.length();", "-                if (((token.charAt(0) >= 'A')", "-                     && (token.charAt(0) <= 'Z'))", "-                    || ((token.charAt(0) >= 'a')", "-                        && (token.charAt(0) <= 'z'))", "-                    || (token.charAt(0) == '/'))", "-                    // If a character or / follows the < sign,", "-                    // then assume its html.", "-                    // The non-html version is \"&lt;\"", "-                    // Point before the angle bracket", "-                    final int startOfTag = position - token.length() - 1;", "-                    add(new HtmlTag(token, aLineNo, startOfTag, aText));"]}]}