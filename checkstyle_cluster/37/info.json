{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "904bbf3f0dd60ab628d00481474293af", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "31da884ba86861f8dfbc41b06b5e198c", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java", "commitBeforeChange": "6f6e4db399353f769525820d9a7319287105d3e5", "commitAfterChange": "06c32930c34e2b10b5926883c29a4a20fe6ecf05", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "     private void checkParamTags(List aTags, List aParams,                                 boolean aReportExpectedTags)", "signatureAfterChange": "     private void checkParamTags(final List aTags, final DetailAST aParent,                                 boolean aReportExpectedTags)", "diff": ["-    private void checkParamTags(List aTags, List aParams,", "+    private void checkParamTags(final List aTags, final DetailAST aParent,", "+        List params = getParameters(aParent);", "+        List typeParams = CheckUtils.getTypeParameters(aParent);", "+", "-            // Loop looking for matching param", "-            final Iterator paramIt = aParams.iterator();", "+", "+            // Loop looking for matching param", "+            final Iterator paramIt = params.iterator();", "+            if (tag.getArg1().startsWith(\"<\") && tag.getArg1().endsWith(\">\")) {", "+                // Loop looking for matching type param", "+                Iterator typeParamsIt = typeParams.iterator();", "+                while (typeParamsIt.hasNext()) {", "+                    final DetailAST typeParam = (DetailAST) typeParamsIt.next();", "+                    if (typeParam.findFirstToken(TokenTypes.IDENT).getText()", "+                        .equals(tag.getArg1().substring(", "+                            1, tag.getArg1().length() - 1)))", "+                    {", "+                        found = true;", "+                        typeParamsIt.remove();", "+                        break;", "+                    }", "+                }", "+", "+            }", "+", "-        // Now dump out all parameters without tags :- unless", "+        // Now dump out all type parameters/parameters without tags :- unless", "-            final Iterator paramIt = aParams.iterator();", "+            final Iterator paramIt = params.iterator();", "+", "+            final Iterator typeParamsIt = typeParams.iterator();", "+            while (typeParamsIt.hasNext()) {", "+                final DetailAST typeParam = (DetailAST) typeParamsIt.next();", "+                log(typeParam, \"javadoc.expectedTag\", \"@param\",", "+                    \"<\"", "+                    + typeParam.findFirstToken(TokenTypes.IDENT).getText()", "+                    + \">\");", "+            }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8efd3908113de2ba9b0933f18cea264f", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java", "commitBeforeChange": "0406304865b4fdd6e5294f0bcd948f1158f4ae84", "commitAfterChange": "e15f70ac5b1460236e14237acc3a041102238efd", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "     private String getImportGroup(boolean isStatic, String importPath)", "signatureAfterChange": "     private String getImportGroup(boolean isStatic, String importPath)", "diff": ["-        for (String group : customImportOrderRules) {", "-            if (matchesImportGroup(isStatic, importPath, group)) {", "-                return group;", "+        RuleMatchForImport bestMatch = new RuleMatchForImport(NON_GROUP_RULE_GROUP, 0, 0);", "+        if (isStatic && customImportOrderRules.contains(STATIC_RULE_GROUP)) {", "+            bestMatch.group = STATIC_RULE_GROUP;", "+            bestMatch.matchLength = importPath.length();", "+        }", "+        else if (customImportOrderRules.contains(SAME_PACKAGE_RULE_GROUP)) {", "+            final String importPathTrimmedToSamePackageDepth =", "+                    getFirstNDomainsFromIdent(samePackageMatchingDepth, importPath);", "+            if (samePackageDomainsRegExp.equals(importPathTrimmedToSamePackageDepth)) {", "+                bestMatch.group = SAME_PACKAGE_RULE_GROUP;", "+                bestMatch.matchLength = importPath.length();", "-        return NON_GROUP_RULE_GROUP;", "+        if (bestMatch.group.equals(NON_GROUP_RULE_GROUP)) {", "+            for (String group : customImportOrderRules) {", "+                if (STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(group)) {", "+                    bestMatch = findBetterPatternMatch(importPath,", "+                            STANDARD_JAVA_PACKAGE_RULE_GROUP, standardPackageRegExp, bestMatch);", "+                }", "+                if (SPECIAL_IMPORTS_RULE_GROUP.equals(group)) {", "+                    bestMatch = findBetterPatternMatch(importPath,", "+                            SPECIAL_IMPORTS_RULE_GROUP, specialImportsRegExp, bestMatch);", "+                }", "+            }", "+        }", "+        if (bestMatch.group.equals(NON_GROUP_RULE_GROUP)", "+                && customImportOrderRules.contains(THIRD_PARTY_PACKAGE_RULE_GROUP)", "+                && thirdPartyPackageRegExp.matcher(importPath).find()) {", "+            bestMatch.group = THIRD_PARTY_PACKAGE_RULE_GROUP;", "+        }", "+        return bestMatch.group;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ce6470eb09ebe28b160f3c73e5c00b3a", "repository": "https://github.com/checkstyle/checkstyle.git", "fileName": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RedundantModifierCheck.java", "commitBeforeChange": "8acc405dd30502bbbcdaf60a75ddd60dfa2b5a50", "commitAfterChange": "3ed2fd68f81f6200362f4babc9595b29f437ddd9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public void visitToken(DetailAST aAST)", "signatureAfterChange": "     public void visitToken(DetailAST aAST)", "diff": ["-        if (!ScopeUtils.inInterfaceBlock(aAST)) {", "-            return;", "-        }", "+        if (ScopeUtils.inInterfaceBlock(aAST)) {", "+            final DetailAST modifiers =", "+                aAST.findFirstToken(TokenTypes.MODIFIERS);", "-        DetailAST modifiers = aAST.findFirstToken(TokenTypes.MODIFIERS);", "+            DetailAST modifier = (DetailAST) modifiers.getFirstChild();", "+            while (modifier != null) {", "-        DetailAST modifier = (DetailAST) modifiers.getFirstChild();", "-        while (modifier != null) {", "+                // javac does not allow final or static in interface methods", "+                // hence no need to check that this is not a method", "-            // javac does not allow final or static in interface methods", "-            // hence no need to check that this is not a method", "+                final int type = modifier.getType();", "+                if (type == TokenTypes.LITERAL_PUBLIC", "+                    || type == TokenTypes.ABSTRACT", "+                    || type == TokenTypes.LITERAL_STATIC", "+                    || type == TokenTypes.FINAL)", "+                {", "+                    log(modifier.getLineNo(),", "+                        modifier.getColumnNo(),", "+                        \"redundantModifier\",", "+                        new String[] {modifier.getText()});", "+                    break;", "+                }", "-            final int type = modifier.getType();", "-            if (type == TokenTypes.LITERAL_PUBLIC", "-                || type == TokenTypes.ABSTRACT", "-                || type == TokenTypes.LITERAL_STATIC", "-                || type == TokenTypes.FINAL)", "-            {", "-                log(modifier.getLineNo(),", "-                    modifier.getColumnNo(),", "-                    \"redundantModifier\",", "-                    new String[] {modifier.getText()});", "-                break;", "+                modifier = (DetailAST) modifier.getNextSibling();", "-", "-            modifier = (DetailAST) modifier.getNextSibling();", "+        }", "+        else if (aAST.getType() == TokenTypes.METHOD_DEF) {", "+            final DetailAST modifiers =", "+                            aAST.findFirstToken(TokenTypes.MODIFIERS);", "+            // private method?", "+            boolean checkFinal =", "+                modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);", "+            // declared in a final class?", "+            DetailAST parent = aAST.getParent();", "+            while (parent != null) {", "+                if (parent.getType() == TokenTypes.CLASS_DEF) {", "+                    final DetailAST classModifiers =", "+                        parent.findFirstToken(TokenTypes.MODIFIERS);", "+                    checkFinal |=", "+                        classModifiers.branchContains(TokenTypes.FINAL);", "+                    break;", "+                }", "+                parent = parent.getParent();", "+            }", "+            if (checkFinal) {", "+                DetailAST modifier = (DetailAST) modifiers.getFirstChild();", "+                while (modifier != null) {", "+                    final int type = modifier.getType();", "+                    if (type == TokenTypes.FINAL) {", "+                        log(modifier.getLineNo(),", "+                            modifier.getColumnNo(),", "+                            \"redundantModifier\",", "+                            new String[] {modifier.getText()});", "+                        break;", "+                    }", "+                    modifier = (DetailAST) modifier.getNextSibling();", "+                }", "+            }"]}]}