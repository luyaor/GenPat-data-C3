{"members": [{"repository": "git://git.code.sf.net/p/fitlibrary/fitlibrary", "methodNumberBeforeChange": 3, "signatureBeforeChange": "   protected LinkedList<Diff> diff_compute(String text1, String text2,                                           boolean checklines)", "fileName": "src/fitlibrary/diff/Diff_match_patch.java", "methodNumberAfterChange": 3, "commitBeforeChange": "ab046d65905e417d3e94904fed3739580da01753", "diff": ["+\t */", "+\tprotected LinkedList<Diff> diff_compute(String text1Initial,", "+\t\t\tString text2Initial, boolean checkLinesInitial) {", "+\t\tString text1 = text1Initial;", "+\t\tString text2 = text2Initial;", "+\t\tboolean checklines = checkLinesInitial;", "+\t\tLinkedList<Diff> diffs = new LinkedList<Diff>();", "+\t\tif (\"\".equals(text1)) {", "+\t\t\t// Just add some text (speedup)", "+\t\t\tdiffs.add(new Diff(Operation.INSERT, text2));", "+\t\t\treturn diffs;", "+\t\t}", "+\t\tif (\"\".equals(text2)) {", "+\t\t\t// Just delete some text (speedup)", "+\t\t\tdiffs.add(new Diff(Operation.DELETE, text1));", "+\t\t\treturn diffs;", "+\t\t}", "+\t\tString longtext = text1.length() > text2.length() ? text1 : text2;", "+\t\tString shorttext = text1.length() > text2.length() ? text2 : text1;", "+\t\tint i = longtext.indexOf(shorttext);", "+\t\tif (i != -1) {", "+\t\t\t// Shorter text is inside the longer text (speedup)", "+\t\t\tOperation op = (text1.length() > text2.length()) ? Operation.DELETE", "+\t\t\t\t\t: Operation.INSERT;", "+\t\t\tdiffs.add(new Diff(op, longtext.substring(0, i)));", "+\t\t\tdiffs.add(new Diff(Operation.EQUAL, shorttext));", "+\t\t\tdiffs.add(new Diff(op, longtext.substring(i + shorttext.length())));", "+\t\t\treturn diffs;", "+\t\t}", "+\t\tlongtext = shorttext = null; // Garbage collect", "-   */", "-  protected LinkedList<Diff> diff_compute(String text1, String text2,", "-                                          boolean checklines) {", "-    LinkedList<Diff> diffs = new LinkedList<Diff>();", "+\t\t// Check to see if the problem can be split in two.", "+\t\tString[] hm = diff_halfMatch(text1, text2);", "+\t\tif (hm != null) {", "+\t\t\t// A half-match was found, sort out the return data.", "+\t\t\tString text1_a = hm[0];", "+\t\t\tString text1_b = hm[1];", "+\t\t\tString text2_a = hm[2];", "+\t\t\tString text2_b = hm[3];", "+\t\t\tString mid_common = hm[4];", "+\t\t\t// Send both pairs off for separate processing.", "+\t\t\tLinkedList<Diff> diffs_a = diff_main(text1_a, text2_a, checklines);", "+\t\t\tLinkedList<Diff> diffs_b = diff_main(text1_b, text2_b, checklines);", "+\t\t\t// Merge the results.", "+\t\t\tdiffs = diffs_a;", "+\t\t\tdiffs.add(new Diff(Operation.EQUAL, mid_common));", "+\t\t\tdiffs.addAll(diffs_b);", "+\t\t\treturn diffs;", "+\t\t}", "-    if (\"\".equals(text1)) {", "-      // Just add some text (speedup)", "-      diffs.add(new Diff(Operation.INSERT, text2));", "-      return diffs;", "-    }", "+\t\t// Perform a real diff.", "+\t\tif (checklines && (text1.length() < 100 || text2.length() < 100)) {", "+\t\t\tchecklines = false; // Too trivial for the overhead.", "+\t\t}", "+\t\tList<String> linearray = null;", "+\t\tif (checklines) {", "+\t\t\t// Scan the text on a line-by-line basis first.", "+\t\t\tLinesToCharsResult b = diff_linesToChars(text1, text2);", "+\t\t\ttext1 = b.chars1;", "+\t\t\ttext2 = b.chars2;", "+\t\t\tlinearray = b.lineArray;", "+\t\t}", "-    if (\"\".equals(text2)) {", "-      // Just delete some text (speedup)", "-      diffs.add(new Diff(Operation.DELETE, text1));", "-      return diffs;", "-    }", "+\t\tdiffs = diff_map(text1, text2);", "+\t\tif (diffs == null) {", "+\t\t\t// No acceptable result.", "+\t\t\tdiffs = new LinkedList<Diff>();", "+\t\t\tdiffs.add(new Diff(Operation.DELETE, text1));", "+\t\t\tdiffs.add(new Diff(Operation.INSERT, text2));", "+\t\t}", "-    String longtext = text1.length() > text2.length() ? text1 : text2;", "-    String shorttext = text1.length() > text2.length() ? text2 : text1;", "-    int i = longtext.indexOf(shorttext);", "-    if (i != -1) {", "-      // Shorter text is inside the longer text (speedup)", "-      Operation op = (text1.length() > text2.length()) ?", "-                     Operation.DELETE : Operation.INSERT;", "-      diffs.add(new Diff(op, longtext.substring(0, i)));", "-      diffs.add(new Diff(Operation.EQUAL, shorttext));", "-      diffs.add(new Diff(op, longtext.substring(i + shorttext.length())));", "-      return diffs;", "-    }", "-    longtext = shorttext = null;  // Garbage collect", "+\t\tif (checklines) {", "+\t\t\t// Convert the diff back to original text.", "+\t\t\tdiff_charsToLines(diffs, linearray);", "+\t\t\t// Eliminate freak matches (e.g. blank lines)", "+\t\t\tdiff_cleanupSemantic(diffs);", "-    // Check to see if the problem can be split in two.", "-    String[] hm = diff_halfMatch(text1, text2);", "-    if (hm != null) {", "-      // A half-match was found, sort out the return data.", "-      String text1_a = hm[0];", "-      String text1_b = hm[1];", "-      String text2_a = hm[2];", "-      String text2_b = hm[3];", "-      String mid_common = hm[4];", "-      // Send both pairs off for separate processing.", "-      LinkedList<Diff> diffs_a = diff_main(text1_a, text2_a, checklines);", "-      LinkedList<Diff> diffs_b = diff_main(text1_b, text2_b, checklines);", "-      // Merge the results.", "-      diffs = diffs_a;", "-      diffs.add(new Diff(Operation.EQUAL, mid_common));", "-      diffs.addAll(diffs_b);", "-      return diffs;", "-    }", "+\t\t\t// Rediff any replacement blocks, this time character-by-character.", "+\t\t\t// Add a dummy entry at the end.", "+\t\t\tdiffs.add(new Diff(Operation.EQUAL, \"\"));", "+\t\t\tint count_delete = 0;", "+\t\t\tint count_insert = 0;", "+\t\t\tString text_delete = \"\";", "+\t\t\tString text_insert = \"\";", "+\t\t\tListIterator<Diff> pointer = diffs.listIterator();", "+\t\t\tDiff thisDiff = pointer.next();", "+\t\t\twhile (thisDiff != null) {", "+\t\t\t\tswitch (thisDiff.operation) {", "+\t\t\t\tcase INSERT:", "+\t\t\t\t\tcount_insert++;", "+\t\t\t\t\ttext_insert += thisDiff.text;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase DELETE:", "+\t\t\t\t\tcount_delete++;", "+\t\t\t\t\ttext_delete += thisDiff.text;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase EQUAL:", "+\t\t\t\t\t// Upon reaching an equality, check for prior redundancies.", "+\t\t\t\t\tif (count_delete >= 1 && count_insert >= 1) {", "+\t\t\t\t\t\t// Delete the offending records and add the merged ones.", "+\t\t\t\t\t\tpointer.previous();", "+\t\t\t\t\t\tfor (int j = 0; j < count_delete + count_insert; j++) {", "+\t\t\t\t\t\t\tpointer.previous();", "+\t\t\t\t\t\t\tpointer.remove();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tfor (Diff newDiff : diff_main(text_delete, text_insert,", "+\t\t\t\t\t\t\t\tfalse)) {", "+\t\t\t\t\t\t\tpointer.add(newDiff);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tcount_insert = 0;", "+\t\t\t\t\tcount_delete = 0;", "+\t\t\t\t\ttext_delete = \"\";", "+\t\t\t\t\ttext_insert = \"\";", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tthisDiff = pointer.hasNext() ? pointer.next() : null;", "+\t\t\t}", "+\t\t\tdiffs.removeLast(); // Remove the dummy entry at the end.", "+\t\t}", "+\t\treturn diffs;", "+\t}", "-    // Perform a real diff.", "-    if (checklines && (text1.length() < 100 || text2.length() < 100)) {", "-      checklines = false;  // Too trivial for the overhead.", "-    }", "-    List<String> linearray = null;", "-    if (checklines) {", "-      // Scan the text on a line-by-line basis first.", "-      LinesToCharsResult b = diff_linesToChars(text1, text2);", "-      text1 = b.chars1;", "-      text2 = b.chars2;", "-      linearray = b.lineArray;", "-    }", "-    diffs = diff_map(text1, text2);", "-    if (diffs == null) {", "-      // No acceptable result.", "-      diffs = new LinkedList<Diff>();", "-      diffs.add(new Diff(Operation.DELETE, text1));", "-      diffs.add(new Diff(Operation.INSERT, text2));", "-    }", "-    if (checklines) {", "-      // Convert the diff back to original text.", "-      diff_charsToLines(diffs, linearray);", "-      // Eliminate freak matches (e.g. blank lines)", "-      diff_cleanupSemantic(diffs);", "-      // Rediff any replacement blocks, this time character-by-character.", "-      // Add a dummy entry at the end.", "-      diffs.add(new Diff(Operation.EQUAL, \"\"));", "-      int count_delete = 0;", "-      int count_insert = 0;", "-      String text_delete = \"\";", "-      String text_insert = \"\";", "-      ListIterator<Diff> pointer = diffs.listIterator();", "-      Diff thisDiff = pointer.next();", "-      while (thisDiff != null) {", "-        switch (thisDiff.operation) {", "-        case INSERT:", "-          count_insert++;", "-          text_insert += thisDiff.text;", "-          break;", "-        case DELETE:", "-          count_delete++;", "-          text_delete += thisDiff.text;", "-          break;", "-        case EQUAL:", "-          // Upon reaching an equality, check for prior redundancies.", "-          if (count_delete >= 1 && count_insert >= 1) {", "-            // Delete the offending records and add the merged ones.", "-            pointer.previous();", "-            for (int j = 0; j < count_delete + count_insert; j++) {", "-              pointer.previous();", "-              pointer.remove();", "-            }", "-            for (Diff newDiff : diff_main(text_delete, text_insert, false)) {", "-              pointer.add(newDiff);", "-            }", "-          }", "-          count_insert = 0;", "-          count_delete = 0;", "-          text_delete = \"\";", "-          text_insert = \"\";", "-          break;", "-        }", "-        thisDiff = pointer.hasNext() ? pointer.next() : null;", "-      }", "-      diffs.removeLast();  // Remove the dummy entry at the end.", "-    }", "-    return diffs;", "-  }"], "commitAfterChange": "ccec4a1da96e4230996fd3f45653be59c64dac88", "signatureAfterChange": " \tprotected LinkedList<Diff> diff_compute(String text1Initial, \t\t\tString text2Initial, boolean checkLinesInitial)", "id": "1458d72f2086aedc137737e8ac500546", "@class": "de.fau.cs.inf2.cthree.data.CodeChange"}, {"repository": "git://git.code.sf.net/p/fitlibrary/fitlibrary", "methodNumberBeforeChange": 2, "signatureBeforeChange": "   public LinkedList<Diff> diff_main(String text1, String text2,                                     boolean checklines)", "fileName": "src/fitlibrary/diff/Diff_match_patch.java", "methodNumberAfterChange": 2, "commitBeforeChange": "ab046d65905e417d3e94904fed3739580da01753", "diff": ["+\t */", "+\tpublic LinkedList<Diff> diff_main(String text1Initial, String text2Initial,", "+\t\t\tboolean checklines) {", "+\t\t// Check for equality (speedup)", "+\t\tString text1 = text1Initial;", "+\t\tString text2 = text2Initial;", "+\t\tLinkedList<Diff> diffs;", "+\t\tif (text1.equals(text2)) {", "+\t\t\tdiffs = new LinkedList<Diff>();", "+\t\t\tdiffs.add(new Diff(Operation.EQUAL, text1));", "+\t\t\treturn diffs;", "+\t\t}", "+\t\t// Trim off common prefix (speedup)", "+\t\tint commonlength = diff_commonPrefix(text1, text2);", "+\t\tString commonprefix = text1.substring(0, commonlength);", "+\t\ttext1 = text1.substring(commonlength);", "+\t\ttext2 = text2.substring(commonlength);", "+\t\t// Trim off common suffix (speedup)", "+\t\tcommonlength = diff_commonSuffix(text1, text2);", "+\t\tString commonsuffix = text1.substring(text1.length() - commonlength);", "+\t\ttext1 = text1.substring(0, text1.length() - commonlength);", "+\t\ttext2 = text2.substring(0, text2.length() - commonlength);", "-   */", "-  public LinkedList<Diff> diff_main(String text1, String text2,", "-                                    boolean checklines) {", "-    // Check for equality (speedup)", "-    LinkedList<Diff> diffs;", "-    if (text1.equals(text2)) {", "-      diffs = new LinkedList<Diff>();", "-      diffs.add(new Diff(Operation.EQUAL, text1));", "-      return diffs;", "-    }", "+\t\t// Compute the diff on the middle block", "+\t\tdiffs = diff_compute(text1, text2, checklines);", "-    // Trim off common prefix (speedup)", "-    int commonlength = diff_commonPrefix(text1, text2);", "-    String commonprefix = text1.substring(0, commonlength);", "-    text1 = text1.substring(commonlength);", "-    text2 = text2.substring(commonlength);", "+\t\t// Restore the prefix and suffix", "+\t\tif (!\"\".equals(commonprefix)) {", "+\t\t\tdiffs.addFirst(new Diff(Operation.EQUAL, commonprefix));", "+\t\t}", "+\t\tif (!\"\".equals(commonsuffix)) {", "+\t\t\tdiffs.addLast(new Diff(Operation.EQUAL, commonsuffix));", "+\t\t}", "-    // Trim off common suffix (speedup)", "-    commonlength = diff_commonSuffix(text1, text2);", "-    String commonsuffix = text1.substring(text1.length() - commonlength);", "-    text1 = text1.substring(0, text1.length() - commonlength);", "-    text2 = text2.substring(0, text2.length() - commonlength);", "+\t\tdiff_cleanupMerge(diffs);", "+\t\treturn diffs;", "+\t}", "-    // Compute the diff on the middle block", "-    diffs = diff_compute(text1, text2, checklines);", "-    // Restore the prefix and suffix", "-    if (!\"\".equals(commonprefix)) {", "-      diffs.addFirst(new Diff(Operation.EQUAL, commonprefix));", "-    }", "-    if (!\"\".equals(commonsuffix)) {", "-      diffs.addLast(new Diff(Operation.EQUAL, commonsuffix));", "-    }", "-    diff_cleanupMerge(diffs);", "-    return diffs;", "-  }"], "commitAfterChange": "ccec4a1da96e4230996fd3f45653be59c64dac88", "signatureAfterChange": " \tpublic LinkedList<Diff> diff_main(String text1Initial, String text2Initial, \t\t\tboolean checklines)", "id": "5357d3c773d9618e2b43523ffc51cb0a", "@class": "de.fau.cs.inf2.cthree.data.CodeChange"}, {"repository": "git://git.code.sf.net/p/fitlibrary/fitlibrary", "methodNumberBeforeChange": 37, "signatureBeforeChange": "   public Object[] patch_apply(LinkedList<Patch> patches, String text)", "fileName": "src/fitlibrary/diff/Diff_match_patch.java", "methodNumberAfterChange": 37, "commitBeforeChange": "ab046d65905e417d3e94904fed3739580da01753", "diff": ["-   */", "-  public Object[] patch_apply(LinkedList<Patch> patches, String text) {", "-    if (\"\".equals(patches)) {", "-      return new Object[]{text, new boolean[0]};", "-    }", "-    // Deep copy the patches so that no changes are made to originals.", "-    patches = patch_deepCopy(patches);", "-    String nullPadding = patch_addPadding(patches);", "-    text = nullPadding + text + nullPadding;", "-    patch_splitMax(patches);", "-    int x = 0;", "-    // delta keeps track of the offset between the expected and actual location", "-    // of the previous patch.  If there are patches expected at positions 10 and", "-    // 20, but the first patch was found at 12, delta is 2 and the second patch", "-    // has an effective expected position of 22.", "-    int delta = 0;", "-    boolean[] results = new boolean[patches.size()];", "-    for (Patch aPatch : patches) {", "-      int expected_loc = aPatch.start2 + delta;", "-      String text1 = diff_text1(aPatch.diffs);", "-      int start_loc;", "-      int end_loc = -1;", "-      if (text1.length() > this.Match_MaxBits) {", "-        // patch_splitMax will only provide an oversized pattern in the case of", "-        // a monster delete.", "-        start_loc = match_main(text,", "-            text1.substring(0, this.Match_MaxBits), expected_loc);", "-        if (start_loc != -1) {", "-          end_loc = match_main(text,", "-              text1.substring(text1.length() - this.Match_MaxBits),", "-              expected_loc + text1.length() - this.Match_MaxBits);", "-          if (end_loc == -1 || start_loc >= end_loc) {", "-            // Can't find valid trailing context.  Drop this patch.", "-            start_loc = -1;", "-          }", "-        }", "-      } else {", "-        start_loc = match_main(text, text1, expected_loc);", "-      }", "-      if (start_loc == -1) {", "-        // No match found.  :(", "-        results[x] = false;", "-        // Subtract the delta for this failed patch from subsequent patches.", "-        delta -= aPatch.length2 - aPatch.length1;", "-      } else {", "-        // Found a match.  :)", "-        results[x] = true;", "-        delta = start_loc - expected_loc;", "-        String text2;", "-        if (end_loc == -1) {", "-          text2 = text.substring(start_loc,", "-              Math.min(start_loc + text1.length(), text.length()));", "-        } else {", "-          text2 = text.substring(start_loc,", "-              Math.min(end_loc + this.Match_MaxBits, text.length()));", "-        }", "-        if (text1.equals(text2)) {", "-          // Perfect match, just shove the replacement text in.", "-          text = text.substring(0, start_loc) + diff_text2(aPatch.diffs)", "-              + text.substring(start_loc + text1.length());", "-        } else {", "-          // Imperfect match.  Run a diff to get a framework of equivalent", "-          // indices.", "-          LinkedList<Diff> diffs = diff_main(text1, text2, false);", "-          if (text1.length() > this.Match_MaxBits", "-              && diff_levenshtein(diffs) / (float) text1.length()", "-              > this.Patch_DeleteThreshold) {", "-            // The end points match, but the content is unacceptably bad.", "-            results[x] = false;", "-          } else {", "-            diff_cleanupSemanticLossless(diffs);", "-            int index1 = 0;", "-            for (Diff aDiff : aPatch.diffs) {", "-              if (aDiff.operation != Operation.EQUAL) {", "-                int index2 = diff_xIndex(diffs, index1);", "-                if (aDiff.operation == Operation.INSERT) {", "-                  // Insertion", "-                  text = text.substring(0, start_loc + index2) + aDiff.text", "-                      + text.substring(start_loc + index2);", "-                } else if (aDiff.operation == Operation.DELETE) {", "-                  // Deletion", "-                  text = text.substring(0, start_loc + index2)", "-                      + text.substring(start_loc + diff_xIndex(diffs,", "-                      index1 + aDiff.text.length()));", "-                }", "-              }", "-              if (aDiff.operation != Operation.DELETE) {", "-                index1 += aDiff.text.length();", "-              }", "-            }", "-          }", "-        }", "-      }", "-      x++;", "-    }", "-    // Strip the padding off.", "-    text = text.substring(nullPadding.length(), text.length()", "-        - nullPadding.length());", "-    return new Object[]{text, results};", "-  }", "+\t */", "+\tpublic Object[] patch_apply(LinkedList<Patch> patchesInitial,", "+\t\t\tString textInitial) {", "+\t\tLinkedList<Patch> patches = patchesInitial;", "+\t\tString text = textInitial;", "+\t\tif (\"\".equals(patches)) {", "+\t\t\treturn new Object[] { text, new boolean[0] };", "+\t\t}", "+\t\t// Deep copy the patches so that no changes are made to originals.", "+\t\tpatches = patch_deepCopy(patches);", "+\t\tString nullPadding = patch_addPadding(patches);", "+\t\ttext = nullPadding + text + nullPadding;", "+\t\tpatch_splitMax(patches);", "+\t\tint x = 0;", "+\t\t// delta keeps track of the offset between the expected and actual", "+\t\t// location", "+\t\t// of the previous patch. If there are patches expected at positions 10", "+\t\t// and", "+\t\t// 20, but the first patch was found at 12, delta is 2 and the second", "+\t\t// patch", "+\t\t// has an effective expected position of 22.", "+\t\tint delta = 0;", "+\t\tboolean[] results = new boolean[patches.size()];", "+\t\tfor (Patch aPatch : patches) {", "+\t\t\tint expected_loc = aPatch.start2 + delta;", "+\t\t\tString text1 = diff_text1(aPatch.diffs);", "+\t\t\tint start_loc;", "+\t\t\tint end_loc = -1;", "+\t\t\tif (text1.length() > this.Match_MaxBits) {", "+\t\t\t\t// patch_splitMax will only provide an oversized pattern in the", "+\t\t\t\t// case of", "+\t\t\t\t// a monster delete.", "+\t\t\t\tstart_loc = match_main(text,", "+\t\t\t\t\t\ttext1.substring(0, this.Match_MaxBits), expected_loc);", "+\t\t\t\tif (start_loc != -1) {", "+\t\t\t\t\tend_loc = match_main(text, text1.substring(text1.length()", "+\t\t\t\t\t\t\t- this.Match_MaxBits),", "+\t\t\t\t\t\t\texpected_loc + text1.length() - this.Match_MaxBits);", "+\t\t\t\t\tif (end_loc == -1 || start_loc >= end_loc) {", "+\t\t\t\t\t\t// Can't find valid trailing context. Drop this patch.", "+\t\t\t\t\t\tstart_loc = -1;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tstart_loc = match_main(text, text1, expected_loc);", "+\t\t\t}", "+\t\t\tif (start_loc == -1) {", "+\t\t\t\t// No match found. :(", "+\t\t\t\tresults[x] = false;", "+\t\t\t\t// Subtract the delta for this failed patch from subsequent", "+\t\t\t\t// patches.", "+\t\t\t\tdelta -= aPatch.length2 - aPatch.length1;", "+\t\t\t} else {", "+\t\t\t\t// Found a match. :)", "+\t\t\t\tresults[x] = true;", "+\t\t\t\tdelta = start_loc - expected_loc;", "+\t\t\t\tString text2;", "+\t\t\t\tif (end_loc == -1) {", "+\t\t\t\t\ttext2 = text", "+\t\t\t\t\t\t\t.substring(", "+\t\t\t\t\t\t\t\t\tstart_loc,", "+\t\t\t\t\t\t\t\t\tMath.min(start_loc + text1.length(),", "+\t\t\t\t\t\t\t\t\t\t\ttext.length()));", "+\t\t\t\t} else {", "+\t\t\t\t\ttext2 = text.substring(", "+\t\t\t\t\t\t\tstart_loc,", "+\t\t\t\t\t\t\tMath.min(end_loc + this.Match_MaxBits,", "+\t\t\t\t\t\t\t\t\ttext.length()));", "+\t\t\t\t}", "+\t\t\t\tif (text1.equals(text2)) {", "+\t\t\t\t\t// Perfect match, just shove the replacement text in.", "+\t\t\t\t\ttext = text.substring(0, start_loc)", "+\t\t\t\t\t\t\t+ diff_text2(aPatch.diffs)", "+\t\t\t\t\t\t\t+ text.substring(start_loc + text1.length());", "+\t\t\t\t} else {", "+\t\t\t\t\t// Imperfect match. Run a diff to get a framework of", "+\t\t\t\t\t// equivalent", "+\t\t\t\t\t// indices.", "+\t\t\t\t\tLinkedList<Diff> diffs = diff_main(text1, text2, false);", "+\t\t\t\t\tif (text1.length() > this.Match_MaxBits", "+\t\t\t\t\t\t\t&& diff_levenshtein(diffs) / (float) text1.length() > this.Patch_DeleteThreshold) {", "+\t\t\t\t\t\t// The end points match, but the content is unacceptably", "+\t\t\t\t\t\t// bad.", "+\t\t\t\t\t\tresults[x] = false;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tdiff_cleanupSemanticLossless(diffs);", "+\t\t\t\t\t\tint index1 = 0;", "+\t\t\t\t\t\tfor (Diff aDiff : aPatch.diffs) {", "+\t\t\t\t\t\t\tif (aDiff.operation != Operation.EQUAL) {", "+\t\t\t\t\t\t\t\tint index2 = diff_xIndex(diffs, index1);", "+\t\t\t\t\t\t\t\tif (aDiff.operation == Operation.INSERT) {", "+\t\t\t\t\t\t\t\t\t// Insertion", "+\t\t\t\t\t\t\t\t\ttext = text", "+\t\t\t\t\t\t\t\t\t\t\t.substring(0, start_loc + index2)", "+\t\t\t\t\t\t\t\t\t\t\t+ aDiff.text", "+\t\t\t\t\t\t\t\t\t\t\t+ text.substring(start_loc + index2);", "+\t\t\t\t\t\t\t\t} else if (aDiff.operation == Operation.DELETE) {", "+\t\t\t\t\t\t\t\t\t// Deletion", "+\t\t\t\t\t\t\t\t\ttext = text", "+\t\t\t\t\t\t\t\t\t\t\t.substring(0, start_loc + index2)", "+\t\t\t\t\t\t\t\t\t\t\t+ text.substring(start_loc", "+\t\t\t\t\t\t\t\t\t\t\t\t\t+ diff_xIndex(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdiffs,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex1", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ aDiff.text", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.length()));", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (aDiff.operation != Operation.DELETE) {", "+\t\t\t\t\t\t\t\tindex1 += aDiff.text.length();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tx++;", "+\t\t}", "+\t\t// Strip the padding off.", "+\t\ttext = text.substring(nullPadding.length(),", "+\t\t\t\ttext.length() - nullPadding.length());", "+\t\treturn new Object[] { text, results };", "+\t}"], "commitAfterChange": "ccec4a1da96e4230996fd3f45653be59c64dac88", "signatureAfterChange": " \tpublic Object[] patch_apply(LinkedList<Patch> patchesInitial, \t\t\tString textInitial)", "id": "c9b110f5614bdb582239738e8c34c3a2", "@class": "de.fau.cs.inf2.cthree.data.CodeChange"}], "id": "280fdc3794d39333351889fe38895755", "@class": "de.fau.cs.inf2.cthree.data.Cluster", "detectedBy": ["AST_HIERARCHICAL"]}