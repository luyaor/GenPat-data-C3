{"members": [{"repository": "git://git.code.sf.net/p/fitlibrary/fitlibrary", "methodNumberBeforeChange": 37, "signatureBeforeChange": "   public Object[] patch_apply(LinkedList<Patch> patches, String text)", "fileName": "src/fitlibrary/diff/Diff_match_patch.java", "methodNumberAfterChange": 37, "commitBeforeChange": "ab046d65905e417d3e94904fed3739580da01753", "diff": ["-   */", "-  public Object[] patch_apply(LinkedList<Patch> patches, String text) {", "-    if (\"\".equals(patches)) {", "-      return new Object[]{text, new boolean[0]};", "-    }", "-    // Deep copy the patches so that no changes are made to originals.", "-    patches = patch_deepCopy(patches);", "-    String nullPadding = patch_addPadding(patches);", "-    text = nullPadding + text + nullPadding;", "-    patch_splitMax(patches);", "-    int x = 0;", "-    // delta keeps track of the offset between the expected and actual location", "-    // of the previous patch.  If there are patches expected at positions 10 and", "-    // 20, but the first patch was found at 12, delta is 2 and the second patch", "-    // has an effective expected position of 22.", "-    int delta = 0;", "-    boolean[] results = new boolean[patches.size()];", "-    for (Patch aPatch : patches) {", "-      int expected_loc = aPatch.start2 + delta;", "-      String text1 = diff_text1(aPatch.diffs);", "-      int start_loc;", "-      int end_loc = -1;", "-      if (text1.length() > this.Match_MaxBits) {", "-        // patch_splitMax will only provide an oversized pattern in the case of", "-        // a monster delete.", "-        start_loc = match_main(text,", "-            text1.substring(0, this.Match_MaxBits), expected_loc);", "-        if (start_loc != -1) {", "-          end_loc = match_main(text,", "-              text1.substring(text1.length() - this.Match_MaxBits),", "-              expected_loc + text1.length() - this.Match_MaxBits);", "-          if (end_loc == -1 || start_loc >= end_loc) {", "-            // Can't find valid trailing context.  Drop this patch.", "-            start_loc = -1;", "-          }", "-        }", "-      } else {", "-        start_loc = match_main(text, text1, expected_loc);", "-      }", "-      if (start_loc == -1) {", "-        // No match found.  :(", "-        results[x] = false;", "-        // Subtract the delta for this failed patch from subsequent patches.", "-        delta -= aPatch.length2 - aPatch.length1;", "-      } else {", "-        // Found a match.  :)", "-        results[x] = true;", "-        delta = start_loc - expected_loc;", "-        String text2;", "-        if (end_loc == -1) {", "-          text2 = text.substring(start_loc,", "-              Math.min(start_loc + text1.length(), text.length()));", "-        } else {", "-          text2 = text.substring(start_loc,", "-              Math.min(end_loc + this.Match_MaxBits, text.length()));", "-        }", "-        if (text1.equals(text2)) {", "-          // Perfect match, just shove the replacement text in.", "-          text = text.substring(0, start_loc) + diff_text2(aPatch.diffs)", "-              + text.substring(start_loc + text1.length());", "-        } else {", "-          // Imperfect match.  Run a diff to get a framework of equivalent", "-          // indices.", "-          LinkedList<Diff> diffs = diff_main(text1, text2, false);", "-          if (text1.length() > this.Match_MaxBits", "-              && diff_levenshtein(diffs) / (float) text1.length()", "-              > this.Patch_DeleteThreshold) {", "-            // The end points match, but the content is unacceptably bad.", "-            results[x] = false;", "-          } else {", "-            diff_cleanupSemanticLossless(diffs);", "-            int index1 = 0;", "-            for (Diff aDiff : aPatch.diffs) {", "-              if (aDiff.operation != Operation.EQUAL) {", "-                int index2 = diff_xIndex(diffs, index1);", "-                if (aDiff.operation == Operation.INSERT) {", "-                  // Insertion", "-                  text = text.substring(0, start_loc + index2) + aDiff.text", "-                      + text.substring(start_loc + index2);", "-                } else if (aDiff.operation == Operation.DELETE) {", "-                  // Deletion", "-                  text = text.substring(0, start_loc + index2)", "-                      + text.substring(start_loc + diff_xIndex(diffs,", "-                      index1 + aDiff.text.length()));", "-                }", "-              }", "-              if (aDiff.operation != Operation.DELETE) {", "-                index1 += aDiff.text.length();", "-              }", "-            }", "-          }", "-        }", "-      }", "-      x++;", "-    }", "-    // Strip the padding off.", "-    text = text.substring(nullPadding.length(), text.length()", "-        - nullPadding.length());", "-    return new Object[]{text, results};", "-  }", "+\t */", "+\tpublic Object[] patch_apply(LinkedList<Patch> patchesInitial,", "+\t\t\tString textInitial) {", "+\t\tLinkedList<Patch> patches = patchesInitial;", "+\t\tString text = textInitial;", "+\t\tif (\"\".equals(patches)) {", "+\t\t\treturn new Object[] { text, new boolean[0] };", "+\t\t}", "+\t\t// Deep copy the patches so that no changes are made to originals.", "+\t\tpatches = patch_deepCopy(patches);", "+\t\tString nullPadding = patch_addPadding(patches);", "+\t\ttext = nullPadding + text + nullPadding;", "+\t\tpatch_splitMax(patches);", "+\t\tint x = 0;", "+\t\t// delta keeps track of the offset between the expected and actual", "+\t\t// location", "+\t\t// of the previous patch. If there are patches expected at positions 10", "+\t\t// and", "+\t\t// 20, but the first patch was found at 12, delta is 2 and the second", "+\t\t// patch", "+\t\t// has an effective expected position of 22.", "+\t\tint delta = 0;", "+\t\tboolean[] results = new boolean[patches.size()];", "+\t\tfor (Patch aPatch : patches) {", "+\t\t\tint expected_loc = aPatch.start2 + delta;", "+\t\t\tString text1 = diff_text1(aPatch.diffs);", "+\t\t\tint start_loc;", "+\t\t\tint end_loc = -1;", "+\t\t\tif (text1.length() > this.Match_MaxBits) {", "+\t\t\t\t// patch_splitMax will only provide an oversized pattern in the", "+\t\t\t\t// case of", "+\t\t\t\t// a monster delete.", "+\t\t\t\tstart_loc = match_main(text,", "+\t\t\t\t\t\ttext1.substring(0, this.Match_MaxBits), expected_loc);", "+\t\t\t\tif (start_loc != -1) {", "+\t\t\t\t\tend_loc = match_main(text, text1.substring(text1.length()", "+\t\t\t\t\t\t\t- this.Match_MaxBits),", "+\t\t\t\t\t\t\texpected_loc + text1.length() - this.Match_MaxBits);", "+\t\t\t\t\tif (end_loc == -1 || start_loc >= end_loc) {", "+\t\t\t\t\t\t// Can't find valid trailing context. Drop this patch.", "+\t\t\t\t\t\tstart_loc = -1;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tstart_loc = match_main(text, text1, expected_loc);", "+\t\t\t}", "+\t\t\tif (start_loc == -1) {", "+\t\t\t\t// No match found. :(", "+\t\t\t\tresults[x] = false;", "+\t\t\t\t// Subtract the delta for this failed patch from subsequent", "+\t\t\t\t// patches.", "+\t\t\t\tdelta -= aPatch.length2 - aPatch.length1;", "+\t\t\t} else {", "+\t\t\t\t// Found a match. :)", "+\t\t\t\tresults[x] = true;", "+\t\t\t\tdelta = start_loc - expected_loc;", "+\t\t\t\tString text2;", "+\t\t\t\tif (end_loc == -1) {", "+\t\t\t\t\ttext2 = text", "+\t\t\t\t\t\t\t.substring(", "+\t\t\t\t\t\t\t\t\tstart_loc,", "+\t\t\t\t\t\t\t\t\tMath.min(start_loc + text1.length(),", "+\t\t\t\t\t\t\t\t\t\t\ttext.length()));", "+\t\t\t\t} else {", "+\t\t\t\t\ttext2 = text.substring(", "+\t\t\t\t\t\t\tstart_loc,", "+\t\t\t\t\t\t\tMath.min(end_loc + this.Match_MaxBits,", "+\t\t\t\t\t\t\t\t\ttext.length()));", "+\t\t\t\t}", "+\t\t\t\tif (text1.equals(text2)) {", "+\t\t\t\t\t// Perfect match, just shove the replacement text in.", "+\t\t\t\t\ttext = text.substring(0, start_loc)", "+\t\t\t\t\t\t\t+ diff_text2(aPatch.diffs)", "+\t\t\t\t\t\t\t+ text.substring(start_loc + text1.length());", "+\t\t\t\t} else {", "+\t\t\t\t\t// Imperfect match. Run a diff to get a framework of", "+\t\t\t\t\t// equivalent", "+\t\t\t\t\t// indices.", "+\t\t\t\t\tLinkedList<Diff> diffs = diff_main(text1, text2, false);", "+\t\t\t\t\tif (text1.length() > this.Match_MaxBits", "+\t\t\t\t\t\t\t&& diff_levenshtein(diffs) / (float) text1.length() > this.Patch_DeleteThreshold) {", "+\t\t\t\t\t\t// The end points match, but the content is unacceptably", "+\t\t\t\t\t\t// bad.", "+\t\t\t\t\t\tresults[x] = false;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tdiff_cleanupSemanticLossless(diffs);", "+\t\t\t\t\t\tint index1 = 0;", "+\t\t\t\t\t\tfor (Diff aDiff : aPatch.diffs) {", "+\t\t\t\t\t\t\tif (aDiff.operation != Operation.EQUAL) {", "+\t\t\t\t\t\t\t\tint index2 = diff_xIndex(diffs, index1);", "+\t\t\t\t\t\t\t\tif (aDiff.operation == Operation.INSERT) {", "+\t\t\t\t\t\t\t\t\t// Insertion", "+\t\t\t\t\t\t\t\t\ttext = text", "+\t\t\t\t\t\t\t\t\t\t\t.substring(0, start_loc + index2)", "+\t\t\t\t\t\t\t\t\t\t\t+ aDiff.text", "+\t\t\t\t\t\t\t\t\t\t\t+ text.substring(start_loc + index2);", "+\t\t\t\t\t\t\t\t} else if (aDiff.operation == Operation.DELETE) {", "+\t\t\t\t\t\t\t\t\t// Deletion", "+\t\t\t\t\t\t\t\t\ttext = text", "+\t\t\t\t\t\t\t\t\t\t\t.substring(0, start_loc + index2)", "+\t\t\t\t\t\t\t\t\t\t\t+ text.substring(start_loc", "+\t\t\t\t\t\t\t\t\t\t\t\t\t+ diff_xIndex(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdiffs,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex1", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ aDiff.text", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.length()));", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (aDiff.operation != Operation.DELETE) {", "+\t\t\t\t\t\t\t\tindex1 += aDiff.text.length();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tx++;", "+\t\t}", "+\t\t// Strip the padding off.", "+\t\ttext = text.substring(nullPadding.length(),", "+\t\t\t\ttext.length() - nullPadding.length());", "+\t\treturn new Object[] { text, results };", "+\t}"], "commitAfterChange": "ccec4a1da96e4230996fd3f45653be59c64dac88", "signatureAfterChange": " \tpublic Object[] patch_apply(LinkedList<Patch> patchesInitial, \t\t\tString textInitial)", "id": "c9b110f5614bdb582239738e8c34c3a2", "@class": "de.fau.cs.inf2.cthree.data.CodeChange"}, {"repository": "git://git.code.sf.net/p/fitlibrary/fitlibrary", "methodNumberBeforeChange": 1, "signatureBeforeChange": "\r \tpublic boolean tablesEqual(String path, TableElement actual, TableElement expected)", "fileName": "src/fitlibrary/spec/TablesCompare.java", "methodNumberAfterChange": 1, "commitBeforeChange": "ffb3a105f2dd1aba96f84ebd4186987eb580fd1c", "diff": ["-\tpublic boolean tablesEqual(String path, TableElement actual, TableElement expected) {\r", "+\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r", "+\tpublic boolean tablesEqual(String path, TableElement actualInitial, TableElement expectedInitial) {\r", "+\t\tTableElement actual = actualInitial;\r", "+\t\tTableElement expected = expectedInitial;\r", "-\t\t\tif (expected.getLeader().isEmpty() && actual.getLeader().equals(\"<html>\"))\r", "-\t\t\t\t;\r", "-\t\t\telse if (!equals(actual.getLeader(),expected.getLeader())) {\r", "+\t\t\tif (expected.getLeader().isEmpty() && actual.getLeader().equals(\"<html>\")) {\r", "+\t\t\t\t//\r", "+\t\t\t} else if (!equals(actual.getLeader(),expected.getLeader())) {\r", "-\t\t\tif (expected.getTrailer().isEmpty() && actual.getTrailer().equals(\"</html>\"))\r", "-\t\t\t\t;\r", "-\t\t\telse if (!equals(actual.getTrailer(),expected.getTrailer())) {\r", "+\t\t\tif (expected.getTrailer().isEmpty() && actual.getTrailer().equals(\"</html>\")) {\r", "+\t\t\t\t//\r", "+\t\t\t} else if (!equals(actual.getTrailer(),expected.getTrailer())) {\r", "-\t\t\tif (expected.getTagLine().isEmpty() && actual.getTagLine().equals(\"border=\\\"1\\\" cellspacing=\\\"0\\\"\"))\r", "-\t\t\t\t;\r", "-\t\t\telse if (!actual.getTagLine().equals(expected.getTagLine())) {\r", "+\t\t\tif (expected.getTagLine().isEmpty() && actual.getTagLine().equals(\"border=\\\"1\\\" cellspacing=\\\"0\\\"\")) {\r", "+\t\t\t\t//\r", "+\t\t\t} else if (!actual.getTagLine().equals(expected.getTagLine())) {\r"], "commitAfterChange": "217037b82c662a130b6f1897ec27b10c0077de31", "signatureAfterChange": "\r \t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r \tpublic boolean tablesEqual(String path, TableElement actualInitial, TableElement expectedInitial)", "id": "d65a6d023dd1f1e7c1479b5199a1a0d3", "@class": "de.fau.cs.inf2.cthree.data.CodeChange"}], "id": "73172afbb2715438473842e19d84be6a", "@class": "de.fau.cs.inf2.cthree.data.Cluster", "detectedBy": ["AST_DBSCAN"]}