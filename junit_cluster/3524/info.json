{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "01c359ec6143cf08867f4af39a3e4451", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9bb8eb9357c8887b48f8a9bbac199753", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/main/java/org/junit/experimental/max/MaxCore.java", "commitBeforeChange": "68cc61e2b6ae43f3ab6ef9a54e16b9318d3d038f", "commitAfterChange": "30f2b16525dabb477373be9ed3e76bb98b200806", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tprivate Runner buildRunner(Description each)", "signatureAfterChange": "      private Runner buildRunner(Description each)", "diff": ["-\tprivate Runner buildRunner(Description each) {", "-\t\tif (each.toString().equals(\"TestSuite with 0 tests\"))", "-\t\t\treturn Suite.emptySuite();", "-\t\tif (each.toString().startsWith(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX))", "-\t\t\t// This is cheating, because it runs the whole class ", "-\t\t\t// to get the warning for this method, but we can't do better, ", "-\t\t\t// because JUnit 3.8's", "-\t\t\t// thrown away which method the warning is for.", "-\t\t\treturn new JUnit38ClassRunner(new TestSuite(getMalformedTestClass(each)));", "-\t\tClass<?> type= each.getTestClass();", "-\t\tif (type == null)", "-\t\t\tthrow new RuntimeException(\"Can't build a runner from description [\" + each + \"]\");", "-\t\tString methodName= each.getMethodName();", "-\t\tif (methodName == null)", "-\t\t\treturn Request.aClass(type).getRunner();", "-\t\treturn Request.method(type, methodName).getRunner();", "-\t}", "+    private Runner buildRunner(Description each) {", "+        if (each.toString().equals(\"TestSuite with 0 tests\")) {", "+            return Suite.emptySuite();", "+        }", "+        if (each.toString().startsWith(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX)) {", "+            // This is cheating, because it runs the whole class", "+            // to get the warning for this method, but we can't do better,", "+            // because JUnit 3.8's", "+            // thrown away which method the warning is for.", "+            return new JUnit38ClassRunner(new TestSuite(getMalformedTestClass(each)));", "+        }", "+        Class<?> type = each.getTestClass();", "+        if (type == null) {", "+            throw new RuntimeException(\"Can't build a runner from description [\" + each + \"]\");", "+        }", "+        String methodName = each.getMethodName();", "+        if (methodName == null) {", "+            return Request.aClass(type).getRunner();", "+        }", "+        return Request.method(type, methodName).getRunner();", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e79e4f77225158874d673bb6e2f5c2af", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/main/java/org/junit/runner/JUnitCore.java", "commitBeforeChange": "68cc61e2b6ae43f3ab6ef9a54e16b9318d3d038f", "commitAfterChange": "30f2b16525dabb477373be9ed3e76bb98b200806", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tprivate Result runMain(JUnitSystem system, String... args)", "signatureAfterChange": "     private Result runMain(JUnitSystem system, String... args)", "diff": ["-\t */", "-\tprivate Result runMain(JUnitSystem system, String... args) {", "-\t\tsystem.out().println(\"JUnit version \" + Version.id());", "-\t\tList<Class<?>> classes= new ArrayList<Class<?>>();", "-\t\tList<Failure> missingClasses= new ArrayList<Failure>();", "-\t\tfor (String each : args)", "-\t\t\ttry {", "-\t\t\t\tclasses.add(Class.forName(each));", "-\t\t\t} catch (ClassNotFoundException e) {", "-\t\t\t\tsystem.out().println(\"Could not find class: \" + each);", "-\t\t\t\tDescription description= Description.createSuiteDescription(each);", "-\t\t\t\tFailure failure= new Failure(description, e);", "-\t\t\t\tmissingClasses.add(failure);", "-\t\t\t}", "-\t\tRunListener listener= new TextListener(system);", "-\t\taddListener(listener);", "-\t\tResult result= run(classes.toArray(new Class[0]));", "-\t\tfor (Failure each : missingClasses)", "-\t\t\tresult.getFailures().add(each);", "-\t\treturn result;", "-\t}", "+     */", "+    private Result runMain(JUnitSystem system, String... args) {", "+        system.out().println(\"JUnit version \" + Version.id());", "+        List<Class<?>> classes = new ArrayList<Class<?>>();", "+        List<Failure> missingClasses = new ArrayList<Failure>();", "+        for (String each : args) {", "+            try {", "+                classes.add(Class.forName(each));", "+            } catch (ClassNotFoundException e) {", "+                system.out().println(\"Could not find class: \" + each);", "+                Description description = Description.createSuiteDescription(each);", "+                Failure failure = new Failure(description, e);", "+                missingClasses.add(failure);", "+            }", "+        }", "+        RunListener listener = new TextListener(system);", "+        addListener(listener);", "+        Result result = run(classes.toArray(new Class[0]));", "+        for (Failure each : missingClasses) {", "+            result.getFailures().add(each);", "+        }", "+        return result;", "+    }"]}]}