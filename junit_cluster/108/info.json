{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "077a7907a1cb86a2482f9b58dddc9a84", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a19d2143d4f59318359b4c987e11134", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/test/java/org/junit/tests/experimental/max/MaxCore.java", "commitBeforeChange": "451ca12156d5704809a1feff78a10a9451cd2023", "commitAfterChange": "ce7bda3346278aab6ccebedcd5b8c8d4ab27ba02", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 16, "signatureBeforeChange": " \t \t\tprivate boolean isNew(Description o1)", "signatureAfterChange": "  \tprivate boolean isNewTest(Description key)", "diff": ["-\t\tprivate boolean isNew(Description o1) {", "-\t\t\treturn ! fDurations.containsKey(o1);", "-\t\t}", "+", "+\tprivate boolean isNewTest(Description key) {", "+\t\treturn ! fDurations.containsKey(key.toString());", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf4149f95f2af7b4f963949cf57ed626", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/org/junit/internal/runners/TestMethod.java", "commitBeforeChange": "85c570ea92f0ee7d17573966dd7f94f4c3b0b61a", "commitAfterChange": "79d696c81cb996e6a199b062c0ae1f53408d5ebd", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tpublic void invoke(Object test) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException", "signatureAfterChange": "  \tprotected void invoke(Roadie context) throws IllegalArgumentException, \t\t\tIllegalAccessException, InvocationTargetException", "diff": ["-\tpublic void invoke(Object test) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {", "-\t\tfMethod.invoke(test);", "+\tprotected void invoke(Roadie context) throws IllegalArgumentException,", "+\t\t\tIllegalAccessException, InvocationTargetException {", "+\t\tfMethod.invoke(context.getTarget());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7c6c16fd55aec861e361455c6946a82", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/main/java/org/junit/runners/model/TestClass.java", "commitBeforeChange": "26f9ebac45e0ff95c72d356b98b64eaf3de4f618", "commitAfterChange": "99b0ebc70e061d7620179f4e72e735e3944e54cd", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "      public <T> List<T> getAnnotatedMethodValues(Object test,             Class<? extends Annotation> annotationClass, Class<T> valueClass)", "signatureAfterChange": "      public <T> List<T> getAnnotatedMethodValues(Object test,             Class<? extends Annotation> annotationClass, Class<T> valueClass)", "diff": ["-                Object fieldValue = each.invokeExplosively(test);", "-                if (valueClass.isInstance(fieldValue)) {", "+                /*", "+                 * A method annotated with @Rule may return a @TestRule or a @MethodRule,", "+                 * we cannot call the method to check whether the return type matches our", "+                 * expectation i.e. subclass of valueClass. If we do that then the method ", "+                 * will be invoked twice and we do not want to do that. So we first check", "+                 * whether return type matches our expectation and only then call the method", "+                 * to fetch the MethodRule", "+                 */", "+                if (valueClass.isAssignableFrom(each.getReturnType())) {", "+                    Object fieldValue = each.invokeExplosively(test);"]}]}