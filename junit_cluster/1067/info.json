{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0d467c31b95337cac123c4af367b5eb3", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "572221b3f353f65578eaa65c537a1a19", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/org/junit/runners/Parameterized.java", "commitBeforeChange": "1d982e5310d57fe0ea4b63e05f20215ee3add1fe", "commitAfterChange": "24a5aad1f49b4decf946f1df701e354a18544132", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 12, "signatureBeforeChange": " \t \tprivate TestMethod getParametersMethod() throws Exception", "signatureAfterChange": "  \tprivate TestMethod getParametersMethod() throws Exception", "diff": ["-\t", "+", "-\t\tList<TestMethod> methods= fTestClass.getAnnotatedMethods(Parameters.class);", "+\t\tList<TestMethod> methods= fTestClass", "+\t\t\t\t.getAnnotatedMethods(Parameters.class);", "-\t\tthrow new Exception(\"No public static parameters method on class \" + getName());", "+\t\tthrow new Exception(\"No public static parameters method on class \"", "+\t\t\t\t+ fTestClass.getName());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7be09f3c37868412782b55b9fa53f859", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/org/junit/experimental/theories/internal/TheoryMethodRunner.java", "commitBeforeChange": "679e5dd3e4af3115492fabed45ea8c48bfa9d9bf", "commitAfterChange": "4081076e513e84bb2376f889d4108e64e9a18653", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tprotected void runWithCompleteAssignment(Assignments complete) \t\t\tthrows InstantiationException, IllegalAccessException, \t\t\tInvocationTargetException, NoSuchMethodException, Throwable", "signatureAfterChange": "  \t\tprotected void runWithCompleteAssignment(Assignments complete) \t\t\t\tthrows InstantiationException, IllegalAccessException, \t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable", "diff": ["-\tprotected void runWithCompleteAssignment(Assignments complete)", "-\t\t\tthrows InstantiationException, IllegalAccessException,", "-\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {", "-\t\ttry {", "-\t\t\tfinal Object[] values= complete.getActualValues(nullsOk());", "-\t\t\tfinal Object freshInstance= complete.getTarget().getClass()", "-\t\t\t\t\t.getConstructor().newInstance();", "-\t\t\tfinal Roadie thisContext= complete.getContext().withNewInstance(", "-\t\t\t\t\tfreshInstance);", "-\t\t\tthisContext.runProtected(this, new Runnable() {", "-\t\t\t\tpublic void run() {", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tinvokeWithActualParameters(freshInstance, values);", "-\t\t\t\t\t} catch (Throwable e) {", "-\t\t\t\t\t\tthrown= e;", "+", "+\t\tprotected void runWithCompleteAssignment(Assignments complete)", "+\t\t\t\tthrows InstantiationException, IllegalAccessException,", "+\t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {", "+\t\t\ttry {", "+\t\t\t\tfinal Object[] values= complete.getActualValues(nullsOk());", "+\t\t\t\tfinal Object freshInstance= complete.getTarget().getClass()", "+\t\t\t\t\t\t.getConstructor().newInstance();", "+\t\t\t\tfinal Roadie thisContext= complete.getContext()", "+\t\t\t\t\t\t.withNewInstance(freshInstance);", "+\t\t\t\tthisContext.runProtected(TheoryMethodRunner.this, new Runnable() { // TODO Ugly...", "+\t\t\t\t\tpublic void run() {", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tinvokeWithActualParameters(freshInstance, values);", "+\t\t\t\t\t\t} catch (Throwable e) {", "+\t\t\t\t\t\t\tthrown= e;", "+\t\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t});", "-\t\t\tif (thrown != null)", "-\t\t\t\tthrow thrown;", "-\t\t} catch (CouldNotGenerateValueException e) {", "+\t\t\t\t});", "+\t\t\t\tif (thrown != null)", "+\t\t\t\t\tthrow thrown;", "+\t\t\t} catch (CouldNotGenerateValueException e) {", "+\t\t\t\t// Do nothing", "+\t\t\t}", "+\t\t}"]}]}