{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "56800acf508e1336fa1cb53169c73882", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3bf332ccccd91b0ff122c690b7069a62", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/main/java/org/junit/runners/model/FrameworkMethod.java", "commitBeforeChange": "68cc61e2b6ae43f3ab6ef9a54e16b9318d3d038f", "commitAfterChange": "30f2b16525dabb477373be9ed3e76bb98b200806", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic void validatePublicVoid(boolean isStatic, List<Throwable> errors)", "signatureAfterChange": "     public void validatePublicVoid(boolean isStatic, List<Throwable> errors)", "diff": ["-\t */", "-\tpublic void validatePublicVoid(boolean isStatic, List<Throwable> errors) {", "-\t\tif (Modifier.isStatic(fMethod.getModifiers()) != isStatic) {", "-\t\t\tString state= isStatic ? \"should\" : \"should not\";", "-\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName() + \"() \" + state + \" be static\"));", "-\t\t}", "-\t\tif (!Modifier.isPublic(fMethod.getDeclaringClass().getModifiers()))", "-\t\t\terrors.add(new Exception(\"Class \" + fMethod.getDeclaringClass().getName() + \" should be public\"));", "-\t\tif (!Modifier.isPublic(fMethod.getModifiers()))", "-\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName() + \"() should be public\"));", "-\t\tif (fMethod.getReturnType() != Void.TYPE)", "-\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName() + \"() should be void\"));", "-\t}", "+     */", "+    public void validatePublicVoid(boolean isStatic, List<Throwable> errors) {", "+        if (Modifier.isStatic(fMethod.getModifiers()) != isStatic) {", "+            String state = isStatic ? \"should\" : \"should not\";", "+            errors.add(new Exception(\"Method \" + fMethod.getName() + \"() \" + state + \" be static\"));", "+        }", "+        if (!Modifier.isPublic(fMethod.getDeclaringClass().getModifiers())) {", "+            errors.add(new Exception(\"Class \" + fMethod.getDeclaringClass().getName() + \" should be public\"));", "+        }", "+        if (!Modifier.isPublic(fMethod.getModifiers())) {", "+            errors.add(new Exception(\"Method \" + fMethod.getName() + \"() should be public\"));", "+        }", "+        if (fMethod.getReturnType() != Void.TYPE) {", "+            errors.add(new Exception(\"Method \" + fMethod.getName() + \"() should be void\"));", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f91723433f06dfad94a5ee62967c701", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/main/java/org/junit/internal/runners/MethodValidator.java", "commitBeforeChange": "68cc61e2b6ae43f3ab6ef9a54e16b9318d3d038f", "commitAfterChange": "30f2b16525dabb477373be9ed3e76bb98b200806", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tprivate void validateTestMethods(Class<? extends Annotation> annotation, \t\t\tboolean isStatic)", "signatureAfterChange": "      private void validateTestMethods(Class<? extends Annotation> annotation,             boolean isStatic)", "diff": ["-\tprivate void validateTestMethods(Class<? extends Annotation> annotation,", "-\t\t\tboolean isStatic) {", "-\t\tList<Method> methods= fTestClass.getAnnotatedMethods(annotation);", "-\t\t", "-\t\tfor (Method each : methods) {", "-\t\t\tif (Modifier.isStatic(each.getModifiers()) != isStatic) {", "-\t\t\t\tString state= isStatic ? \"should\" : \"should not\";", "-\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName() + \"() \"", "-\t\t\t\t\t\t+ state + \" be static\"));", "-\t\t\t}", "-\t\t\tif (!Modifier.isPublic(each.getDeclaringClass().getModifiers()))", "-\t\t\t\tfErrors.add(new Exception(\"Class \" + each.getDeclaringClass().getName()", "-\t\t\t\t\t\t+ \" should be public\"));", "-\t\t\tif (!Modifier.isPublic(each.getModifiers()))", "-\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()", "-\t\t\t\t\t\t+ \" should be public\"));", "-\t\t\tif (each.getReturnType() != Void.TYPE)", "-\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()", "-\t\t\t\t\t\t+ \" should be void\"));", "-\t\t\tif (each.getParameterTypes().length != 0)", "-\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()", "-\t\t\t\t\t\t+ \" should have no parameters\"));", "-\t\t}", "-\t}", "+", "+    private void validateTestMethods(Class<? extends Annotation> annotation,", "+            boolean isStatic) {", "+        List<Method> methods = fTestClass.getAnnotatedMethods(annotation);", "+", "+        for (Method each : methods) {", "+            if (Modifier.isStatic(each.getModifiers()) != isStatic) {", "+                String state = isStatic ? \"should\" : \"should not\";", "+                fErrors.add(new Exception(\"Method \" + each.getName() + \"() \"", "+                        + state + \" be static\"));", "+            }", "+            if (!Modifier.isPublic(each.getDeclaringClass().getModifiers())) {", "+                fErrors.add(new Exception(\"Class \" + each.getDeclaringClass().getName()", "+                        + \" should be public\"));", "+            }", "+            if (!Modifier.isPublic(each.getModifiers())) {", "+                fErrors.add(new Exception(\"Method \" + each.getName()", "+                        + \" should be public\"));", "+            }", "+            if (each.getReturnType() != Void.TYPE) {", "+                fErrors.add(new Exception(\"Method \" + each.getName()", "+                        + \" should be void\"));", "+            }", "+            if (each.getParameterTypes().length != 0) {", "+                fErrors.add(new Exception(\"Method \" + each.getName()", "+                        + \" should have no parameters\"));", "+            }", "+        }", "+    }"]}]}