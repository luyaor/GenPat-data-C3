{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c220bac94fa27bbf175eb84b7c7b35dd", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f91723433f06dfad94a5ee62967c701", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/main/java/org/junit/internal/runners/MethodValidator.java", "commitBeforeChange": "68cc61e2b6ae43f3ab6ef9a54e16b9318d3d038f", "commitAfterChange": "30f2b16525dabb477373be9ed3e76bb98b200806", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tprivate void validateTestMethods(Class<? extends Annotation> annotation, \t\t\tboolean isStatic)", "signatureAfterChange": "      private void validateTestMethods(Class<? extends Annotation> annotation,             boolean isStatic)", "diff": ["-\tprivate void validateTestMethods(Class<? extends Annotation> annotation,", "-\t\t\tboolean isStatic) {", "-\t\tList<Method> methods= fTestClass.getAnnotatedMethods(annotation);", "-\t\t", "-\t\tfor (Method each : methods) {", "-\t\t\tif (Modifier.isStatic(each.getModifiers()) != isStatic) {", "-\t\t\t\tString state= isStatic ? \"should\" : \"should not\";", "-\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName() + \"() \"", "-\t\t\t\t\t\t+ state + \" be static\"));", "-\t\t\t}", "-\t\t\tif (!Modifier.isPublic(each.getDeclaringClass().getModifiers()))", "-\t\t\t\tfErrors.add(new Exception(\"Class \" + each.getDeclaringClass().getName()", "-\t\t\t\t\t\t+ \" should be public\"));", "-\t\t\tif (!Modifier.isPublic(each.getModifiers()))", "-\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()", "-\t\t\t\t\t\t+ \" should be public\"));", "-\t\t\tif (each.getReturnType() != Void.TYPE)", "-\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()", "-\t\t\t\t\t\t+ \" should be void\"));", "-\t\t\tif (each.getParameterTypes().length != 0)", "-\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()", "-\t\t\t\t\t\t+ \" should have no parameters\"));", "-\t\t}", "-\t}", "+", "+    private void validateTestMethods(Class<? extends Annotation> annotation,", "+            boolean isStatic) {", "+        List<Method> methods = fTestClass.getAnnotatedMethods(annotation);", "+", "+        for (Method each : methods) {", "+            if (Modifier.isStatic(each.getModifiers()) != isStatic) {", "+                String state = isStatic ? \"should\" : \"should not\";", "+                fErrors.add(new Exception(\"Method \" + each.getName() + \"() \"", "+                        + state + \" be static\"));", "+            }", "+            if (!Modifier.isPublic(each.getDeclaringClass().getModifiers())) {", "+                fErrors.add(new Exception(\"Class \" + each.getDeclaringClass().getName()", "+                        + \" should be public\"));", "+            }", "+            if (!Modifier.isPublic(each.getModifiers())) {", "+                fErrors.add(new Exception(\"Method \" + each.getName()", "+                        + \" should be public\"));", "+            }", "+            if (each.getReturnType() != Void.TYPE) {", "+                fErrors.add(new Exception(\"Method \" + each.getName()", "+                        + \" should be void\"));", "+            }", "+            if (each.getParameterTypes().length != 0) {", "+                fErrors.add(new Exception(\"Method \" + each.getName()", "+                        + \" should have no parameters\"));", "+            }", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9bb8eb9357c8887b48f8a9bbac199753", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/main/java/org/junit/experimental/max/MaxCore.java", "commitBeforeChange": "68cc61e2b6ae43f3ab6ef9a54e16b9318d3d038f", "commitAfterChange": "30f2b16525dabb477373be9ed3e76bb98b200806", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tprivate Runner buildRunner(Description each)", "signatureAfterChange": "      private Runner buildRunner(Description each)", "diff": ["-\tprivate Runner buildRunner(Description each) {", "-\t\tif (each.toString().equals(\"TestSuite with 0 tests\"))", "-\t\t\treturn Suite.emptySuite();", "-\t\tif (each.toString().startsWith(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX))", "-\t\t\t// This is cheating, because it runs the whole class ", "-\t\t\t// to get the warning for this method, but we can't do better, ", "-\t\t\t// because JUnit 3.8's", "-\t\t\t// thrown away which method the warning is for.", "-\t\t\treturn new JUnit38ClassRunner(new TestSuite(getMalformedTestClass(each)));", "-\t\tClass<?> type= each.getTestClass();", "-\t\tif (type == null)", "-\t\t\tthrow new RuntimeException(\"Can't build a runner from description [\" + each + \"]\");", "-\t\tString methodName= each.getMethodName();", "-\t\tif (methodName == null)", "-\t\t\treturn Request.aClass(type).getRunner();", "-\t\treturn Request.method(type, methodName).getRunner();", "-\t}", "+    private Runner buildRunner(Description each) {", "+        if (each.toString().equals(\"TestSuite with 0 tests\")) {", "+            return Suite.emptySuite();", "+        }", "+        if (each.toString().startsWith(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX)) {", "+            // This is cheating, because it runs the whole class", "+            // to get the warning for this method, but we can't do better,", "+            // because JUnit 3.8's", "+            // thrown away which method the warning is for.", "+            return new JUnit38ClassRunner(new TestSuite(getMalformedTestClass(each)));", "+        }", "+        Class<?> type = each.getTestClass();", "+        if (type == null) {", "+            throw new RuntimeException(\"Can't build a runner from description [\" + each + \"]\");", "+        }", "+        String methodName = each.getMethodName();", "+        if (methodName == null) {", "+            return Request.aClass(type).getRunner();", "+        }", "+        return Request.method(type, methodName).getRunner();", "+    }"]}]}