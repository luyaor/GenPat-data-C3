{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a27805efc5b34848c05b34534184a732", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0cda79b1961fe3bb0f7c97804fb2e16a", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/main/java/org/junit/runners/ParentRunner.java", "commitBeforeChange": "68e59d6de3c48be43bfe2d6104fdb6e8280b1232", "commitAfterChange": "334bd9ce923cf0293cbca49be4ae5947abf51897", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "      public void filter(Filter filter) throws NoTestsRemainException", "signatureAfterChange": "      public void filter(Filter filter) throws NoTestsRemainException", "diff": ["-        synchronized (fLock) {", "+        synchronized (fChildrenLock) {", "-            try {", "-                for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {", "-                    T each = iter.next();", "-                    if (shouldRun(filter, each)) {", "-                        try {", "-                            filter.apply(each);", "-                        } catch (NoTestsRemainException e) {", "-                            iter.remove();", "-                        }", "-                    } else {", "+            for (Iterator<T> iter = filteredChildren.iterator(); iter.hasNext(); ) {", "+                T each = iter.next();", "+                if (shouldRun(filter, each)) {", "+                    try {", "+                        filter.apply(each);", "+                    } catch (NoTestsRemainException e) {", "+                } else {", "+                    iter.remove();", "-            } finally {", "-                fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);", "-        }", "-", "-        if (getFilteredChildren().isEmpty()) {", "-            throw new NoTestsRemainException();", "+            fFilteredChildren = Collections.unmodifiableCollection(filteredChildren);", "+            if (fFilteredChildren.isEmpty()) {", "+                throw new NoTestsRemainException();", "+            }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7c6c16fd55aec861e361455c6946a82", "repository": "https://github.com/junit-team/junit.git", "fileName": "src/main/java/org/junit/runners/model/TestClass.java", "commitBeforeChange": "26f9ebac45e0ff95c72d356b98b64eaf3de4f618", "commitAfterChange": "99b0ebc70e061d7620179f4e72e735e3944e54cd", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "      public <T> List<T> getAnnotatedMethodValues(Object test,             Class<? extends Annotation> annotationClass, Class<T> valueClass)", "signatureAfterChange": "      public <T> List<T> getAnnotatedMethodValues(Object test,             Class<? extends Annotation> annotationClass, Class<T> valueClass)", "diff": ["-                Object fieldValue = each.invokeExplosively(test);", "-                if (valueClass.isInstance(fieldValue)) {", "+                /*", "+                 * A method annotated with @Rule may return a @TestRule or a @MethodRule,", "+                 * we cannot call the method to check whether the return type matches our", "+                 * expectation i.e. subclass of valueClass. If we do that then the method ", "+                 * will be invoked twice and we do not want to do that. So we first check", "+                 * whether return type matches our expectation and only then call the method", "+                 * to fetch the MethodRule", "+                 */", "+                if (valueClass.isAssignableFrom(each.getReturnType())) {", "+                    Object fieldValue = each.invokeExplosively(test);"]}]}