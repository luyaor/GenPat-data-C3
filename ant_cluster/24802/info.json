{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c6eda661e78e20636cf259f36a4c2c05", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "063a4b8413bd05e8aaa2eb2eb99f9199", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/ProcessDestroyer.java", "commitBeforeChange": "97263e1fedac0972ffe52f673da89a531556cba2", "commitAfterChange": "5e4408208a34ba760533b1c6738ccb71cdfa03ba", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "     private void removeShutdownHook()", "signatureAfterChange": "     private void removeShutdownHook()", "diff": ["-        if (removeShutdownHookMethod != null && destroyProcessThread != null) {", "+        if (removeShutdownHookMethod != null && added && !running) {", "-                // start the hook thread, a unstarted thread may not be", "-                // eligible for garbage collection", "-                // Cf.: http://developer.java.sun.com/developer/bugParade/bugs/4533087.html", "-                destroyProcessThread.setShouldDestroy(false);", "-                destroyProcessThread.start();", "-                // this should return quickly, since Process.destroy()", "-                try {", "-                    destroyProcessThread.join(20000);", "-                } catch (InterruptedException ie) {", "-                    // the thread didn't die in time", "-                    // it should not kill any processes unexpectedly", "-                }", "-                destroyProcessThread = null;", "-                added = false;", "-                e.printStackTrace();", "+                Throwable t = e.getCause();", "+                if (t != null && t.getClass() == IllegalStateException.class) {", "+                    // shutdown already is in progress", "+                    running = true;", "+                } else {", "+                    e.printStackTrace();", "+                }", "+            // start the hook thread, a unstarted thread may not be", "+            // eligible for garbage collection", "+            // Cf.: http://developer.java.sun.com/developer/bugParade/bugs/4533087.html", "+            destroyProcessThread.setShouldDestroy(false);", "+            destroyProcessThread.start();", "+            // this should return quickly, since it basically is a NO-OP.", "+            try {", "+                destroyProcessThread.join(20000);", "+            } catch (InterruptedException ie) {", "+                // the thread didn't die in time", "+                // it should not kill any processes unexpectedly", "+            }", "+            destroyProcessThread = null;", "+            added = false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aca49402c83f6dc07ceb21c156ca8885", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/ProcessDestroyer.java", "commitBeforeChange": "97263e1fedac0972ffe52f673da89a531556cba2", "commitAfterChange": "5e4408208a34ba760533b1c6738ccb71cdfa03ba", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private void addShutdownHook()", "signatureAfterChange": "     private void addShutdownHook()", "diff": ["-        if (addShutdownHookMethod != null) {", "+        if (addShutdownHookMethod != null && !running) {", "-                e.printStackTrace();", "+                Throwable t = e.getCause();", "+                if (t != null && t.getClass() == IllegalStateException.class) {", "+                    // shutdown already is in progress", "+                    running = true;", "+                } else {", "+                    e.printStackTrace();", "+                }"]}]}