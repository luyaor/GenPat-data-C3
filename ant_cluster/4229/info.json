{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4dd74a8660cc32153f20a28cbd6c43e2", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a61a4457e6654e797340f9b7804d2755", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/IntrospectionHelper.java", "commitBeforeChange": "92ff24a7e3d486fc2176ab1704e66d481e38d9c8", "commitAfterChange": "5fef1f8fdeb0bddad97fe16b69f7592275cefa2a", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": "     private AttributeSetter createAttributeSetter(final Method m,                                                   Class arg,                                                   final String attrName)", "signatureAfterChange": "     private AttributeSetter createAttributeSetter(final Method m,                                                   Class arg,                                                   final String attrName)", "diff": ["-        // resolve relative paths through Project", "-        } else if (org.apache.tools.ant.types.Path.class.equals(reflectedArg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Path[] {new Path(p, value)});", "-                    }", "-", "-                };", "-", "+        // also supports new Whatever(Project, String) as for Path or Reference", "+            boolean includeProject;", "+            Constructor c;", "-                final Constructor c =", "-                    reflectedArg.getConstructor(new Class[] {java.lang.String.class});", "-", "-                return new AttributeSetter() {", "-                        public void set(Project p, Object parent,", "-                                        String value)", "-                            throws InvocationTargetException,", "-                                   IllegalAccessException, BuildException {", "-                            try {", "-                                Object attribute = c.newInstance(new String[] {value});", "-                                if (p != null) {", "-                                    p.setProjectReference(attribute);", "-                                }", "-                                m.invoke(parent, new Object[] {attribute});", "-                            } catch (InstantiationException ie) {", "-                                throw new BuildException(ie);", "-                            }", "-                        }", "-                    };", "-", "+                // First try with Project.", "+                c = reflectedArg.getConstructor(new Class[] {Project.class, String.class});", "+                includeProject = true;", "-                // ignore", "+                // OK, try without.", "+                try {", "+                    c = reflectedArg.getConstructor(new Class[] {String.class});", "+                    includeProject = false;", "+                } catch (NoSuchMethodException nme2) {", "+                    // Well, no matching constructor.", "+                    return null;", "+                }", "+            final boolean finalIncludeProject = includeProject;", "+            final Constructor finalConstructor = c;", "+            ", "+            return new AttributeSetter() {", "+                public void set(Project p, Object parent, String value)", "+                        throws InvocationTargetException, IllegalAccessException, BuildException {", "+                    try {", "+                        Object[] args;", "+                        if (finalIncludeProject) {", "+                            args = new Object[] {p, value};", "+                        } else {", "+                            args = new Object[] {value};", "+                        }", "+                        Object attribute = finalConstructor.newInstance(args);", "+                        if (p != null) {", "+                            p.setProjectReference(attribute);", "+                        }", "+                        m.invoke(parent, new Object[] {attribute});", "+                    } catch (InstantiationException ie) {", "+                        throw new BuildException(ie);", "+                    }", "+                }", "+            };", "+            ", "-", "-        return null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c83c24070af41286997eb186c31123e7", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/mutant/src/java/antcore/org/apache/ant/antcore/execution/Reflector.java", "commitBeforeChange": "7499c443d67445ea8fd0b8f4bd56c72251b18bf4", "commitAfterChange": "b7e43ad8c5906ae2b6d6b42f8b2715dc7d2e7a16", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 14, "signatureBeforeChange": "     public void addAttributeMethod(final Method m, String propertyName,                                          Map converters)", "signatureAfterChange": "     public void addAttributeMethod(final Method m, String propertyName,                                          Map converters)", "diff": ["-            final Converter converter = (Converter)converters.get(type);", "-            attributeSetters.put(propertyName,", "-                new AttributeSetter() {", "-                    public void set(Object obj, String value)", "-                         throws InvocationTargetException, ExecutionException,", "-                        IllegalAccessException, ConversionException {", "-                        Object convertedValue = converter.convert(value, type);", "-                        m.invoke(obj, new Object[]{convertedValue});", "-                    }", "-                });", "-        } else if (type.equals(String.class)) {", "-            attributeSetters.put(propertyName,", "+            Converter converter = (Converter)converters.get(type);", "+            addConvertingSetter(m, propertyName, converter, type);", "+            return;", "+        }", "+", "+        if (type.equals(String.class)) {", "+            attributeSetters.put(propertyName.toLowerCase(),", "-        } else {", "-            try {", "-                final Constructor c =", "-                    type.getConstructor(new Class[]{java.lang.String.class});", "-                attributeSetters.put(propertyName,", "-                    new AttributeSetter() {", "-                        public void set(Object parent, String value)", "-                             throws InvocationTargetException,", "-                            IllegalAccessException, ExecutionException {", "-                            try {", "-                                Object newValue", "-                                     = c.newInstance(new String[]{value});", "-                                m.invoke(parent, new Object[]{newValue});", "-                            } catch (InstantiationException ie) {", "-                                throw new ExecutionException(ie);", "-                            }", "+            return;", "+        }", "+", "+        try {", "+            final Constructor c =", "+                type.getConstructor(new Class[]{java.lang.String.class});", "+            attributeSetters.put(propertyName.toLowerCase(),", "+                new AttributeSetter() {", "+                    public void set(Object parent, String value)", "+                         throws InvocationTargetException,", "+                        IllegalAccessException, ExecutionException {", "+                        try {", "+                            Object newValue", "+                                 = c.newInstance(new String[]{value});", "+                            m.invoke(parent, new Object[]{newValue});", "+                        } catch (InstantiationException ie) {", "+                            throw new ExecutionException(ie);", "-                    });", "-            } catch (NoSuchMethodException nme) {", "-                // ignore", "+                    }", "+                });", "+            return;", "+        } catch (NoSuchMethodException nme) {", "+            // ignore", "+        }", "+", "+        if (converters != null) {", "+            // desparate by now - try top find a converter which handles a super", "+            // class of this type and which supports subclass instantiation", "+            for (Iterator i = converters.keySet().iterator(); i.hasNext(); ) {", "+                Class converterType = (Class)i.next();", "+                if (converterType.isAssignableFrom(type)) {", "+                    // could be a candidate", "+                    Converter converter", "+                         = (Converter)converters.get(converterType);", "+                    if (converter.canConvertSubType(type)) {", "+                        addConvertingSetter(m, propertyName, converter, type);", "+                        return;", "+                    }", "+                }"]}]}