{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5a769fd3c63f6213f2c9d120406aa19a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "185892630bad769fc818428453b58eba", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/IntrospectionHelper.java", "commitBeforeChange": "60551b04f236357f91059b2af5d150fe6d9a7ee7", "commitAfterChange": "575646714ea2ebaf97a6290ea7d7585403175fb5", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "     private AttributeSetter createAttributeSetter(final Method m,                                                   final Class arg)", "signatureAfterChange": "     private AttributeSetter createAttributeSetter(final Method m,                                                   Class arg)", "diff": ["-                                                  final Class arg) {", "+                                                  Class arg) {", "+\t\t// use wrappers for primitive classes, e.g. int and Integer are treated identically", "+\t\tfinal Class reflectedArg = PRIMITIVE_TYPE_MAP.containsKey (arg) ?", "+\t\t    (Class) PRIMITIVE_TYPE_MAP.get(arg) : arg;", "-        if (java.lang.String.class.equals(arg)) {", "+        if (java.lang.String.class.equals(reflectedArg)) {", "-        // now for the primitive types, use their wrappers", "-        } else if (java.lang.Character.class.equals(arg)", "-                   || java.lang.Character.TYPE.equals(arg)) {", "+        // char and Character get special treatment - take the first character", "+        } else if (java.lang.Character.class.equals(reflectedArg)) {", "-        } else if (java.lang.Byte.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Byte[] {new Byte(value)});", "-                    }", "-", "-                };", "-        } else if (java.lang.Short.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Short[] {new Short(value)});", "-                    }", "-", "-                };", "-        } else if (java.lang.Integer.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Integer[] {new Integer(value)});", "-                    }", "-", "-                };", "-        } else if (java.lang.Long.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Long[] {new Long(value)});", "-                    }", "-", "-                };", "-        } else if (java.lang.Float.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Float[] {new Float(value)});", "-                    }", "-", "-                };", "-        } else if (java.lang.Double.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Double[] {new Double(value)});", "-                    }", "-", "-                };", "-", "-        // boolean gets an extra treatment, because we have a nice method", "+        // boolean and Boolean get special treatment because we have a nice method", "-        } else if (java.lang.Boolean.class.equals(arg)", "-                   || java.lang.Boolean.TYPE.equals(arg)) {", "+        } else if (java.lang.Boolean.class.equals(reflectedArg)) {", "-        } else if (java.lang.Class.class.equals(arg)) {", "+        } else if (java.lang.Class.class.equals(reflectedArg)) {", "-        } else if (java.io.File.class.equals(arg)) {", "+        } else if (java.io.File.class.equals(reflectedArg)) {", "-        } else if (org.apache.tools.ant.types.Path.class.equals(arg)) {", "+        } else if (org.apache.tools.ant.types.Path.class.equals(reflectedArg)) {", "-        } else if (org.apache.tools.ant.types.EnumeratedAttribute.class.isAssignableFrom(arg)) {", "+        } else if (org.apache.tools.ant.types.EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {", "-                            org.apache.tools.ant.types.EnumeratedAttribute ea = (org.apache.tools.ant.types.EnumeratedAttribute)arg.newInstance();", "+                            org.apache.tools.ant.types.EnumeratedAttribute ea = ", "+                                (org.apache.tools.ant.types.EnumeratedAttribute)reflectedArg.newInstance();", "+        // This is used (deliberately) for all primitives/wrappers other than ", "+        // char and boolean", "-                    arg.getConstructor(new Class[] {java.lang.String.class});", "+                    reflectedArg.getConstructor(new Class[] {java.lang.String.class});"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b19cd238e4feebec16c760d766925050", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/sandbox/antlib/src/main/org/apache/tools/ant/IntrospectionHelper.java", "commitBeforeChange": "6540a295cd786c80c28c14f6c544aa1d64ab3778", "commitAfterChange": "5cdfabc038e26f67080037ea0c7ad6ab284d821c", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 18, "signatureBeforeChange": "     private AttributeSetter createAttributeSetter(final Method m,                                                   final Class arg)", "signatureAfterChange": "     private AttributeSetter createAttributeSetter(final Method m,                                                   Class arg,                                                    final String attrName)", "diff": ["-                                                  final Class arg) {", "+                                                  Class arg, ", "+                                                  final String attrName) {", "+        // use wrappers for primitive classes, e.g. int and ", "+        // Integer are treated identically", "+        final Class reflectedArg = PRIMITIVE_TYPE_MAP.containsKey (arg) ", "+            ? (Class) PRIMITIVE_TYPE_MAP.get(arg) : arg;", "-        if (java.lang.String.class.equals(arg)) {", "+        if (java.lang.String.class.equals(reflectedArg)) {", "-        // now for the primitive types, use their wrappers", "-        } else if (java.lang.Character.class.equals(arg)", "-                   || java.lang.Character.TYPE.equals(arg)) {", "+        // char and Character get special treatment - take the first character", "+        } else if (java.lang.Character.class.equals(reflectedArg)) {", "+                        if (value.length() == 0) {", "+                            throw new BuildException(\"The value \\\"\\\" is not a \" ", "+                                + \"legal value for attribute \\\"\" ", "+                                + attrName + \"\\\"\");", "+                        }", "-        } else if (java.lang.Byte.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Byte[] {new Byte(value)});", "-                    }", "-", "-                };", "-        } else if (java.lang.Short.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Short[] {new Short(value)});", "-                    }", "-", "-                };", "-        } else if (java.lang.Integer.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Integer[] {new Integer(value)});", "-                    }", "-", "-                };", "-        } else if (java.lang.Long.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Long[] {new Long(value)});", "-                    }", "-", "-                };", "-        } else if (java.lang.Float.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Float[] {new Float(value)});", "-                    }", "-", "-                };", "-        } else if (java.lang.Double.TYPE.equals(arg)) {", "-            return new AttributeSetter() {", "-                    public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException {", "-                        m.invoke(parent, new Double[] {new Double(value)});", "-                    }", "-", "-                };", "-", "-        // boolean gets an extra treatment, because we have a nice method", "-        // in Project", "-        } else if (java.lang.Boolean.class.equals(arg)", "-                   || java.lang.Boolean.TYPE.equals(arg)) {", "+        // boolean and Boolean get special treatment because we ", "+        // have a nice method in Project", "+        } else if (java.lang.Boolean.class.equals(reflectedArg)) {", "-        } else if (java.lang.Class.class.equals(arg)) {", "+        } else if (java.lang.Class.class.equals(reflectedArg)) {", "-        } else if (java.io.File.class.equals(arg)) {", "+        } else if (java.io.File.class.equals(reflectedArg)) {", "-        } else if (org.apache.tools.ant.types.Path.class.equals(arg)) {", "+        } else if (org.apache.tools.ant.types.Path.class.equals(reflectedArg)) {", "-        } else if (org.apache.tools.ant.types.EnumeratedAttribute.class.isAssignableFrom(arg)) {", "+        } else if (org.apache.tools.ant.types.EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {", "-                            org.apache.tools.ant.types.EnumeratedAttribute ea = (org.apache.tools.ant.types.EnumeratedAttribute)arg.newInstance();", "+                            org.apache.tools.ant.types.EnumeratedAttribute ea = ", "+                                (org.apache.tools.ant.types.EnumeratedAttribute) reflectedArg.newInstance();", "+        // This is used (deliberately) for all primitives/wrappers other than ", "+        // char and boolean", "-                    arg.getConstructor(new Class[] {java.lang.String.class});", "+                    reflectedArg.getConstructor(new Class[] {java.lang.String.class});"]}]}