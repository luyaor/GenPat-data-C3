{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "487946dcefee9c68f6749774a955d21a", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8736f05789089dd3748726a9efc3d342", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Replace.java", "commitBeforeChange": "948ce9bca757a323b0e07ce25a10a76f759898ba", "commitAfterChange": "003b013e23a3ddefa411b4340f52f43df5ea0870", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public void execute() throws BuildException", "signatureAfterChange": "     public void execute() throws BuildException", "diff": ["+        if (token == null) {", "+            throw new BuildException(\"replace token must not be null\");", "+        }", "+", "+        if (src == null && dir == null) {", "+            throw new BuildException(\"Either the file or the dir attribute must be specified\");", "+        }", "+        ", "-        ", "-        if (src == null || token == null ) {", "-            project.log(\"File and token must not be null\");", "-            return;            ", "+", "+        if (src != null) {", "+            processFile(src);", "-        if (dest == null) {", "-            throw new BuildException(\"Error creating temp file.\");", "+        if (dir != null) {", "+\t    DirectoryScanner ds = super.getDirectoryScanner(dir);", "+            String[] srcs = ds.getIncludedFiles();", "+", "+            for(int i=0; i<srcs.length; i++) {", "+                File file = new File(dir,srcs[i]); ", "+                processFile(file);", "+            }", "-                ", "+    }", "-            BufferedWriter bw = new BufferedWriter(new FileWriter(dest));", "-            dest.renameTo(src);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8ba67364f128f13294388457589f9a02", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java", "commitBeforeChange": "4f13f33c394e7865e3120b86066e3317bdb2605e", "commitAfterChange": "c1288a2b32be38143c6a6d3d512aaaaf3fdbefa6", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "     private void translate() throws BuildException", "signatureAfterChange": "     private void translate() throws BuildException", "diff": ["-                        int stLength = startToken.length();", "-                        int etLength = endToken.length();", "-                            int startIndex = -1;", "-                            int endIndex = -1;", "-outer:                      while (true) {", "-                                startIndex = line.indexOf(startToken, endIndex + etLength);", "-                                if (startIndex < 0 ||", "-                                    startIndex + stLength >= line.length()) {", "-                                    break;", "-                                }", "-                                endIndex = line.indexOf(endToken, startIndex + stLength);", "-                                if (endIndex < 0) {", "-                                    break;", "-                                }", "-                                String matches = line.substring(startIndex + stLength,", "-                                                                endIndex);", "-                                //If there is a white space or = or :, then", "-                                //it isn't to be treated as a valid key.", "-                                for (int k = 0; k < matches.length(); k++) {", "-                                    char c = matches.charAt(k);", "-                                    if (c == ':' ||", "-                                        c == '=' ||", "-                                        Character.isSpaceChar(c)) {", "-                                        endIndex = endIndex - 1;", "-                                        continue outer;", "-                                    }", "-                                }", "-                                String replace = null;", "-                                replace = (String) resourceMap.get(matches);", "-                                    //If the key hasn't been loaded into resourceMap,", "-                                    //use the key itself as the value also.", "-                                if (replace == null) {", "-                                    log(\"Warning: The key: \" + matches", "-                                        + \" hasn't been defined.\",", "-                                        Project.MSG_DEBUG);", "-                                    replace = matches;", "-                                }", "-                                line = line.substring(0, startIndex)", "-                                    + replace", "-                                    + line.substring(endIndex + etLength);", "-                                endIndex = startIndex + replace.length() + etLength;", "-                                if (endIndex + etLength >= line.length()) {", "-                                    break;", "-                                }", "-                            }", "+\t\t\t\t\t\t// 2003-02-21 new replace algorithm by tbee (tbee@tbee.org)", "+\t\t\t\t\t\t// because it wasn't able to replace something like \"@aaa;@bbb;\"", "+", "+\t\t\t\t\t\t// is there a startToken", "+\t\t\t\t\t\t// and there is still stuff following the startToken", "+\t\t\t\t\t\tint startIndex = line.indexOf(startToken);", "+\t\t\t\t\t\twhile ( startIndex >= 0 && (startIndex+startToken.length()) <= line.length() )", "+\t\t\t\t\t\t{", "+\t\t\t\t\t\t\t// the new value, this needs to be here", "+\t\t\t\t\t\t\t// because it is required to calculate the next position to search from", "+\t\t\t\t\t\t\t// at the end of the loop", "+\t\t\t\t            String replace = null;", "+", "+\t\t\t\t\t\t\t// we found a starttoken, is there an endtoken following?", "+\t\t\t\t\t\t\t// start at token+tokenlength because start and end token may be indentical", "+\t\t\t\t\t\t\tint endIndex = line.indexOf(endToken, startIndex + startToken.length());", "+\t\t\t\t\t\t\tif (endIndex < 0) startIndex += 1;", "+\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t{", "+\t\t\t\t\t\t\t\t// grab the token", "+\t\t\t\t\t\t\t\tString token = line.substring(startIndex + startToken.length(), endIndex);", "+", "+\t\t\t\t                // If there is a white space or = or :, then", "+\t\t\t\t                // it isn't to be treated as a valid key.", "+\t\t\t\t                boolean validToken = true;", "+\t\t\t\t                for (int k = 0; k < token.length() && validToken; k++)", "+\t\t\t\t                {", "+\t\t\t\t                    char c = token.charAt(k);", "+\t\t\t\t                    if ( c == ':'", "+\t\t\t\t                      || c == '='", "+\t\t\t\t                      || Character.isSpaceChar(c)", "+\t\t\t\t                       )", "+\t\t\t\t                    {", "+\t\t\t\t                    \tvalidToken = false;", "+\t\t\t\t                    }", "+\t\t\t\t                }", "+\t\t\t\t                if (!validToken) startIndex += 1;", "+\t\t\t\t                else", "+\t\t\t\t                {", "+\t\t\t\t                \t// find the replace string", "+\t\t\t\t                \tif (resourceMap.containsKey(token)) replace = (String)resourceMap.get(token);", "+\t\t\t\t                \telse                                replace = token;", "+", "+", "+\t\t\t\t                    // generate the new line", "+\t\t\t\t                    line = line.substring(0, startIndex)", "+\t\t\t\t                         + replace", "+\t\t\t\t                         + line.substring(endIndex + endToken.length());", "+", "+\t\t\t\t\t\t\t\t\t// set start position for next search", "+\t\t\t\t\t\t\t\t\tstartIndex += replace.length();", "+\t\t\t\t                }", "+\t\t\t\t\t\t\t}", "+", "+\t\t\t\t\t\t\t// find next starttoken", "+\t\t\t\t\t\t\tstartIndex = line.indexOf(startToken, startIndex);", "+\t\t\t\t\t\t}", "+", "+"]}]}