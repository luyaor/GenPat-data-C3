{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4ee5d1e8fb8e309f2a1ef1f146fb0cde", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b21a4b609fa9ba122055f5b7854ad9c", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/myrmidon/src/java/org/apache/myrmidon/components/workspace/DefaultWorkspace.java", "commitBeforeChange": "50fb7f5643cba98640e7d4ce2b00736e9d42cbab", "commitAfterChange": "6ff9bf50ad2e4fcda69911d207c8dfe93e7b4e0b", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "     private void executeTarget( final Project project,                                 final String name,                                 final Target target,                                 final ExecutionFrame frame )         throws TaskException", "signatureAfterChange": "     private void executeTarget( final ProjectEntry entry,                                 final String name,                                 final Target target )         throws TaskException", "diff": ["-    private void executeTarget( final Project project,", "+    private void executeTarget( final ProjectEntry entry,", "-                                final Target target,", "-                                final ExecutionFrame frame )", "+                                final Target target )", "-        //notify listeners", "-        m_listenerSupport.targetStarted( project.getProjectName(), name );", "+        final Project project = entry.getProject();", "-        //check the condition associated with target.", "-        //if it is not satisfied then skip target", "-        final Condition condition = target.getCondition();", "-        if( null != condition )", "+        // Check target state, to see if it has already been executed, and", "+        // to check for dependency cycles", "+        final TargetState state = entry.getTargetState( target );", "+        if( state == TargetState.FINISHED )", "-            try", "+            // Target has been executed", "+            return;", "+        }", "+        if( state == TargetState.TRAVERSING )", "+        {", "+            // Cycle in target dependencies", "+            final String message = REZ.getString( \"target-dependency-cycle.error\", name );", "+            throw new TaskException( message );", "+        }", "+", "+        // Set state to indicate this target has been started", "+        entry.setTargetState( target, TargetState.TRAVERSING );", "+", "+        // Execute the target's dependencies", "+", "+        // Implicit target first", "+        if( target != project.getImplicitTarget() )", "+        {", "+            executeTarget( entry, \"<init>\", project.getImplicitTarget() );", "+        }", "+", "+        // Named dependencies", "+        final Dependency[] dependencies = target.getDependencies();", "+        for( int i = 0; i < dependencies.length; i++ )", "+        {", "+            final Dependency dependency = dependencies[ i ];", "+            final String otherProjectName = dependency.getProjectName();", "+            if( otherProjectName != null )", "-                final boolean result = condition.evaluate( frame.getContext() );", "-                if( !result )", "-                {", "-                    final String message = REZ.getString( \"skip-target.notice\", name );", "-                    getLogger().debug( message );", "-                    return;", "-                }", "+                // Dependency in a referenced project", "+                final Project otherProject = getProject( otherProjectName, project );", "+                final ProjectEntry otherEntry = getProjectEntry( otherProject );", "+                executeTarget( otherEntry, dependency.getTargetName() );", "-            catch( final TaskException te )", "+            else", "-                final String message = REZ.getString( \"condition-eval.error\", name );", "-                throw new TaskException( message, te );", "+                // Dependency in this project", "+                executeTarget( entry, dependency.getTargetName() );", "-        final String message = REZ.getString( \"exec-target.notice\", name );", "-        getLogger().debug( message );", "+        // Now execute the target itself", "+        executeTargetNoDeps( entry, name, target );", "+", "+        // Mark target as complete", "+        entry.setTargetState( target, TargetState.FINISHED );", "+    }", "-        //execute all tasks assciated with target", "-            executeTask( tasks[ i ], frame );", "-        //notify listeners"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d17dc6f92ffd4bb9438695419fab75cf", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Parallel.java", "commitBeforeChange": "f30f3d21cb86225cc13531c5fe463ac1dd78892d", "commitAfterChange": "db75fcb34ed8d469fe7ff1a0e7afddf4a1d89177", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 11, "signatureBeforeChange": "     private void spinThreads() throws BuildException", "signatureAfterChange": "     private void spinThreads() throws BuildException", "diff": ["-                = new TaskRunnable(threadNumber, nestedTask);", "+                = new TaskRunnable(nestedTask);", "-        // now run them in limited numbers...", "-        // start initial batch of threads", "-        for (int i = 0; i < maxRunning; ++i) {", "-            running[i] = runnables[threadNumber++];", "-            Thread thread =  new Thread(group, running[i]);", "-            thread.start();", "+        TaskRunnable[] daemons = null;", "+        if (daemonTasks != null && daemonTasks.tasks.size() != 0) {", "+            daemons = new TaskRunnable[daemonTasks.tasks.size()];", "-        if (timeout != 0) {", "-            // start the timeout thread", "-            Thread timeoutThread = new Thread() {", "-                public synchronized void run() {", "-                    try {", "-                        wait(timeout);", "-                        synchronized (semaphore) {", "-                            stillRunning = false;", "-                            timedOut = true;", "-                            semaphore.notifyAll();", "-                        }", "-                    } catch (InterruptedException e) {", "-                        // ignore", "-                    }", "+        synchronized (semaphore) {", "+            // start any daemon threads", "+            if (daemons != null) {", "+                for (int i = 0; i < daemons.length; ++i) {", "+                    daemons[i] = new TaskRunnable((Task) daemonTasks.tasks.get(i));", "+                    Thread daemonThread =  new Thread(group, daemons[i]);", "+                    daemonThread.setDaemon(true);", "+                    daemonThread.start();", "-            };", "-            timeoutThread.start();", "-        }", "+            }", "-        // now find available running slots for the remaining threads", "-        outer:", "-        while (threadNumber < numTasks && stillRunning) {", "-            synchronized (semaphore) {", "+            // now run main threads in limited numbers...", "+            // start initial batch of threads", "+            for (int i = 0; i < maxRunning; ++i) {", "+                running[i] = runnables[threadNumber++];", "+                Thread thread =  new Thread(group, running[i]);", "+                thread.start();", "+            }", "+", "+            if (timeout != 0) {", "+                // start the timeout thread", "+                Thread timeoutThread = new Thread() {", "+                    public synchronized void run() {", "+                        try {", "+                            wait(timeout);", "+                            synchronized (semaphore) {", "+                                stillRunning = false;", "+                                timedOut = true;", "+                                semaphore.notifyAll();", "+                            }", "+                        } catch (InterruptedException e) {", "+                            // ignore", "+                        }", "+                    }", "+                };", "+                timeoutThread.start();", "+            }", "+", "+            // now find available running slots for the remaining threads", "+            outer:", "+            while (threadNumber < numTasks && stillRunning) {", "-        }", "-        synchronized (semaphore) {", "-        StringBuffer exceptionMessage = new StringBuffer();", "-        int numExceptions = 0;", "-        Throwable firstException = null;", "-        Location firstLocation = Location.UNKNOWN_LOCATION;", "-        for (int i = 0; i < numTasks; ++i) {", "-            Throwable t = runnables[i].getException();", "-            if (t != null) {", "-                numExceptions++;", "-                if (firstException == null) {", "-                    firstException = t;", "-                }", "-                if (t instanceof BuildException", "-                    && firstLocation == Location.UNKNOWN_LOCATION) {", "-                    firstLocation = ((BuildException) t).getLocation();", "-                }", "-                exceptionMessage.append(StringUtils.LINE_SEP);", "-                exceptionMessage.append(t.getMessage());", "-            }", "-        }", "+        exceptionMessage = new StringBuffer();", "+        numExceptions = 0;", "+        firstException = null;", "+        firstLocation = Location.UNKNOWN_LOCATION;", "+        processExceptions(daemons);", "+        processExceptions(runnables);"]}]}