{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ca7514fb33490109d6c9e04d1a5c4b5e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1885b621d85311c267bb5e66b2e1dcd3", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Delete.java", "commitBeforeChange": "dbf40e84c3662111689611818c57483f16b60c59", "commitAfterChange": "dd6d777fec28c68e88af5345564f70a1f515cc1c", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 43, "signatureBeforeChange": "     public void execute() throws BuildException", "signatureAfterChange": "     public void execute() throws BuildException", "diff": ["-        if (file == null && dir == null && filesets.size() == 0 && rcs.size() == 0) {", "+        if (file == null && dir == null && filesets.size() == 0 && rcs == null) {", "-                        String message = \"Unable to delete file \"", "-                            + file.getAbsolutePath();", "-                        if (failonerror) {", "-                            throw new BuildException(message);", "-                        } else {", "-                            log(message, quiet ? Project.MSG_VERBOSE", "-                                               : Project.MSG_WARN);", "-                        }", "+                        handle(\"Unable to delete file \" + file.getAbsolutePath());", "-        Path p = new Path(getProject());", "-        p.addAll(rcs);", "+        Resources resourcesToDelete = new Resources();", "+        resourcesToDelete.setProject(getProject());", "+        Resources filesetDirs = new Resources();", "+        filesetDirs.setProject(getProject());", "+", "-            p.add(includeEmpty ? new BCFileSet(fs) : fs);", "+            resourcesToDelete.add(fs);", "+            if (includeEmpty) {", "+              filesetDirs.add(new ReverseDirs(fs.getDir(),", "+                  fs.getDirectoryScanner().getIncludedDirectories()));", "+            }", "-            p.add(includeEmpty ? new BCFileSet(implicit) : implicit);", "+            resourcesToDelete.add(implicit);", "+            if (includeEmpty) {", "+              filesetDirs.add(new ReverseDirs(dir,", "+                  implicit.getDirectoryScanner().getIncludedDirectories()));", "+            }", "-        Restrict exists = new Restrict();", "-        exists.add(EXISTS);", "-        exists.add(p);", "-        // delete the files in the resource collections; sort to files, then dirs", "-        Sort s = new Sort();", "-        s.add(REVERSE_FILESYSTEM);", "-        s.add(exists);", "-        String errorMessage = null;", "+        resourcesToDelete.add(filesetDirs);", "+        if (rcs != null) {", "+            // sort first to files, then dirs", "+            Restrict exists = new Restrict();", "+            exists.add(EXISTS);", "+            exists.add(rcs);", "+            Sort s = new Sort();", "+            s.add(REVERSE_FILESYSTEM);", "+            s.add(exists);", "+            resourcesToDelete.add(s);", "+        }", "-            for (Iterator iter = s.iterator(); iter.hasNext();) {", "-                FileResource r = (FileResource) iter.next();", "-                if (!(r.isDirectory()) || r.getFile().list().length == 0) {", "-                    log(\"Deleting \" + r, verbosity);", "-                    if (!delete(r.getFile())) {", "-                        errorMessage = \"Unable to delete \"", "-                            + (r.isDirectory() ? \"directory \" : \"file \") + r;", "+            if (resourcesToDelete.isFilesystemOnly()) {", "+                for (Iterator iter = resourcesToDelete.iterator(); iter.hasNext();) {", "+                    FileResource r = (FileResource) iter.next();", "+                    // nonexistent resources could only occur if we already", "+                    // deleted something from a fileset:", "+                    if (!r.isExists()) {", "+                        continue;", "+                    }", "+                    if (!(r.isDirectory()) || r.getFile().list().length == 0) {", "+                        log(\"Deleting \" + r, verbosity);", "+                        if (!delete(r.getFile()) && failonerror) {", "+                            handle(\"Unable to delete \"", "+                                + (r.isDirectory() ? \"directory \" : \"file \") + r);", "+                        }", "+            } else {", "+                 handle(getTaskName() + \" handles only filesystem resources\");", "-            errorMessage = e.getMessage();", "-        }", "-        if (errorMessage != null) {", "-            if (failonerror) {", "-                throw new BuildException(errorMessage);", "-            }", "-            log(errorMessage, quiet ? Project.MSG_VERBOSE : Project.MSG_WARN);", "+            handle(e);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c0a8e4b89122bfe90820fb3286ca80a", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/zip/ZipOutputStream.java", "commitBeforeChange": "aa43e37a025cdf54b8914b8283e57419a253ed59", "commitAfterChange": "dee95e3acc5154aee03ff5f91f9a56426ae79f3f", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 14, "signatureBeforeChange": "     public void putNextEntry(ZipEntry ze) throws IOException", "signatureAfterChange": "     public void putNextEntry(ZipEntry archiveEntry) throws IOException", "diff": ["-    public void putNextEntry(ZipEntry ze) throws IOException {", "-        closeEntry();", "-        entry = ze;", "-        entries.add(entry);", "+     */", "+    public void putNextEntry(ZipEntry archiveEntry) throws IOException {", "+        if (finished) {", "+            throw new IOException(\"Stream has already been finished\");", "+        }", "+", "+        if (entry != null) {", "+            closeEntry();", "+        }", "+", "+        entry = new CurrentEntry(archiveEntry);", "+        entries.add(entry.entry);", "+", "+        setDefaults(entry.entry);", "+", "+        final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);", "+        validateSizeInformation(effectiveMode);", "+", "+        if (shouldAddZip64Extra(entry.entry, effectiveMode)) {", "+", "+            Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry.entry);", "+", "+            // just a placeholder, real data will be in data", "+            // descriptor or inserted later via RandomAccessFile", "+            ZipEightByteInteger size = ZipEightByteInteger.ZERO;", "+            if (entry.entry.getMethod() == STORED", "+                && entry.entry.getSize() != -1) {", "+                // actually, we already know the sizes", "+                size = new ZipEightByteInteger(entry.entry.getSize());", "+            }", "+            z64.setSize(size);", "+            z64.setCompressedSize(size);", "+            entry.entry.setExtra();", "+        }", "+", "+        if (entry.entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {", "+            def.setLevel(level);", "+            hasCompressionLevelChanged = false;", "+        }", "+        writeLocalFileHeader(entry.entry);", "+    }", "-        if (entry.getMethod() == STORED && raf == null) {", "-            if (entry.getSize() == -1) {", "-            if (entry.getCrc() == -1) {", "-            entry.setCompressedSize(entry.getSize());", "-        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {", "-            def.setLevel(level);", "-            hasCompressionLevelChanged = false;", "-        writeLocalFileHeader(entry);"]}]}