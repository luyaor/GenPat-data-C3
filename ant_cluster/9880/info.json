{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d833f86dd503314f720e5184d40660b1", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "049e04346f7d73b3ab0da1829ecdecc9", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/ExecTask.java", "commitBeforeChange": "2429a99dd695f4832b9321b72835944922fc176d", "commitAfterChange": "bd8601a5a3ba0794ff75168fd65a488a5a4939f4", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 24, "signatureBeforeChange": "     protected String resolveExecutable(String exec)", "signatureAfterChange": "     protected String resolveExecutable(String exec, boolean searchPath)", "diff": ["-    protected String resolveExecutable(String exec) {", "+    protected String resolveExecutable(String exec, boolean searchPath) {", "+        FileUtils fileUtils = FileUtils.newFileUtils();", "-            FileUtils fileUtils = FileUtils.newFileUtils();", "+        if (searchPath) {", "+            Vector env = Execute.getProcEnvironment();", "+            Enumeration e = env.elements();", "+            Path p = null;", "+            while (e.hasMoreElements()) {", "+                String line = (String) e.nextElement();", "+                if (line.startsWith(\"PATH=\") || line.startsWith(\"Path=\")) {", "+                    p = new Path(getProject(), line.substring(5));", "+                    break;", "+                }", "+            }", "+", "+            if (p != null) {", "+                String[] dirs = p.list();", "+                for (int i = 0; i < dirs.length; i++) {", "+                    executableFile = fileUtils.resolveFile(new File(dirs[i]),", "+                                                           exec);", "+                    if (executableFile.exists()) {", "+                        return executableFile.getAbsolutePath();", "+                    }", "+                }", "+            }", "+        }", "+", "+        // searchPath is false, or no PATH or not found - keep our", "+        // fingers crossed."]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16fd658f33c41ed212c93e8b9b13e507", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/myrmidon/src/java/org/apache/myrmidon/components/converter/DefaultMasterConverter.java", "commitBeforeChange": "4b3e0ee2041826e51ec60af99e7bcca7024bf676", "commitAfterChange": "ed3fafb887fef0afbcd90eef7f263fef3bde95d9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      private String getConverterName( final Class originalClass,                                      final Class destination )         throws ConverterException", "signatureAfterChange": "     private String getConverterName( final Class originalClass,                                      final Class destination )         throws ConverterException", "diff": ["+     */", "-        //TODO: Maybe we should search the source classes hierarchy aswell", "-        for( Class clazz = destination;", "-             clazz != null;", "-             clazz = clazz.getSuperclass() )", "+        //TODO: Maybe we should search the destination classes hierarchy as well", "+", "+        // Recursively iterate over the super-types of the original class,", "+        // looking for a converter from source type -> destination type.", "+        // If more than one is found, choose the most specialised.", "+", "+        Class match = null;", "+        String converterName = null;", "+        ArrayList queue = new ArrayList();", "+        queue.add( originalClass );", "+", "+        while( ! queue.isEmpty() )", "-            final String name =", "-                m_registry.getConverterName( originalClass.getName(),", "-                                             clazz.getName() );", "-            if( name != null )", "+            Class clazz = (Class)queue.remove( 0 );", "+", "+            // Add superclass and all interfaces", "+            if( clazz.getSuperclass() != null )", "-                return name;", "+                queue.add( clazz.getSuperclass() );", "+            }", "+            final Class[] interfaces = clazz.getInterfaces();", "+            for( int i = 0; i < interfaces.length; i++ )", "+            {", "+                queue.add( interfaces[i ] );", "+            }", "+", "+            // Check if we can convert from current class to destination", "+            final String name = m_registry.getConverterName( clazz.getName(),", "+                                                             destination.getName() );", "+            if( name == null )", "+            {", "+                continue;", "+            }", "+", "+            // Choose the more specialised source class", "+            if( match == null || match.isAssignableFrom( clazz ) )", "+            {", "+                match = clazz;", "+                converterName = name;", "+            }", "+            else if( clazz.isAssignableFrom( clazz ) )", "+            {", "+                continue;", "+            }", "+            else", "+            {", "+                // Duplicate", "+                final String message = REZ.getString( \"ambiguous-converter.error\" );", "+                throw new ConverterException( message );", "-        final String message =", "-            REZ.getString( \"no-converter.error\",", "-                           originalClass.getName(),", "-                           destination.getName() );", "+        // TODO - should cache the (src, dest) -> converter mapping", "+        if( match != null )", "+        {", "+            return converterName;", "+        }", "+", "+        // Could not find a converter", "+        final String message = REZ.getString( \"no-converter.error\" );"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "189ca9d2560a761cf58a4a051d5bfd11", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/testcases/org/apache/tools/ant/taskdefs/AntTest.java", "commitBeforeChange": "6ef4875d061c42465f53150b1397b4d7d3b65905", "commitAfterChange": "3745d5dc705f587314a801d7a7ffe9dd2a0e60b3", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": "          public void targetStarted(BuildEvent event)", "signatureAfterChange": "          public void targetStarted(BuildEvent event)", "diff": ["-                    assertEquals(\"Call \"+calls+\" refid=\\'\"+keys[calls]+\"\\'\", ", "-                                 expectSame[calls],", "-                                 event.getProject().getReferences().get(keys[calls++]) == value);", "+                    String msg = ", "+                        \"Call \" + calls + \" refid=\\'\" + keys[calls] + \"\\'\";", "+                    if (value == null) {", "+                        Object o = event.getProject().getReference(keys[calls]);", "+                        if (expectSame[calls++]) {", "+                            assertNull(msg, o);", "+                        } else {", "+                            assertNotNull(msg, o);", "+                        }", "+                    } else {", "+                        // a rather convoluted equals() test", "+                        Path expect = (Path) value;", "+                        Path received = (Path) event.getProject().getReference(keys[calls]);", "+                        boolean shouldBeEqual = expectSame[calls++];", "+                        if (received == null) {", "+                            assertTrue(msg, !shouldBeEqual);", "+                        } else {", "+                            String[] l1 = expect.list();", "+                            String[] l2 = received.list();", "+                            if (l1.length == l2.length) {", "+                                for (int i=0; i<l1.length; i++) {", "+                                    if (!l1[i].equals(l2[i])) {", "+                                        assertTrue(msg, !shouldBeEqual);", "+                                    }", "+                                }", "+                                assertTrue(msg, shouldBeEqual);", "+                            } else {", "+                                assertTrue(msg, !shouldBeEqual);", "+                            }", "+                        }", "+                    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26cd158f7599c06ab97109981c24e9bb", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/sandbox/antlib/src/main/org/apache/tools/ant/taskdefs/Antlib.java", "commitBeforeChange": "f1548aec2b4a57bfdca206f32178a9e03c39d3a1", "commitAfterChange": "7ed240811799349f5a0932e7a464086e5ce31527", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 21, "signatureBeforeChange": "     public static String dtdVersion()", "signatureAfterChange": "  \tprivate void parseAttributes(String tag, AttributeList attrs)  \t    throws SAXParseException", "diff": ["-     */", "-    public static String dtdVersion() {", "-        return ANTLIB_DTD_URL + ANTLIB_DTD_PREFIX +", "-                ANTLIB_DTD_VERSION + ANTLIB_DTD_EXT;", "-    }", "+\tprivate void parseAttributes(String tag, AttributeList attrs) ", "+\t    throws SAXParseException {", "+\t    name = null;", "+\t    className = null;", "+\t    adapter = null;", "+\t    ", "+\t    for (int i = 0, last = attrs.getLength(); i < last; i++) {", "+\t\tString key = attrs.getName(i);", "+\t\tString value = attrs.getValue(i);", "+\t\t", "+\t\tif (key.equals(\"name\")) {", "+\t\t    name = value;", "+\t\t}", "+\t\telse if (key.equals(\"class\")) {", "+\t\t    className = value;", "+\t\t}", "+\t\telse if (\"role\".equals(tag) && key.equals(\"adapter\")) {", "+\t\t    adapter = value;", "+\t\t}", "+\t\telse {", "+\t\t    throw new SAXParseException(\"Unexpected attribute \\\"\"", "+\t\t\t\t\t\t+ key + \"\\\"\", locator);", "+\t\t}", "+\t    }", "+\t    if (name == null || className == null) {", "+\t\tString msg = \"Underspecified \" + tag + \" declaration.\";", "+\t\tthrow new SAXParseException(msg, locator);", "+\t    }", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2a6afbf487fd41ebf994a6c83d338444", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Chmod.java", "commitBeforeChange": "ece10d579b717271df6d23074bfd0345e58ceb95", "commitAfterChange": "d55b86ab4fbcc8807e105e8c99c56488dadc6aeb", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 4, "signatureBeforeChange": "      public void execute() throws BuildException", "signatureAfterChange": "      public void execute() throws BuildException", "diff": ["-\ttry {", "-\t    // XXX if OS=unix", "-\t    if (System.getProperty(\"path.separator\").equals(\":\") &&", "-                    !System.getProperty(\"os.name\").startsWith(\"Mac\"))", "-\t\tRuntime.getRuntime().exec(\"chmod \" + mod + \" \" + srcFile );", "-\t} catch (IOException ioe) {", "-\t    // ignore, but warn", "-\t    System.out.println(\"Error chmod\" + ioe.toString() );", "-\t}", "+        try {", "+            // XXX if OS=unix", "+            if (System.getProperty(\"path.separator\").equals(\":\") &&", "+                !System.getProperty(\"os.name\").startsWith(\"Mac\")) {", "+        ", "+                if (srcFile != null && srcDir == null) {", "+                    chmod(srcFile.toString());", "+                } else if(srcFile == null && srcDir == null) {", "+                    project.log(\"The attribute 'file' or 'dir' needs to be set.\", Project.MSG_WARN);", "+                    throw new BuildException(\"Required attribute not set in Chmod\", location);", "+                } else if(srcFile == null && srcDir != null) {", "+          ", "+                    DirectoryScanner ds = getDirectoryScanner(srcDir);", "+                    String[] files = ds.getIncludedFiles();", "+          ", "+                    for (int i = 0; i < files.length; i++) {", "+                        chmod(files[i]);", "+                    }", "+                }", "+            }", "+        } catch (IOException ioe) {", "+            // ignore, but warn", "+            project.log(\"Error in Chmod \" + ioe.toString() , Project.MSG_WARN);", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5d558bda10d3f30ebb80380af3894f6a", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Delete.java", "commitBeforeChange": "c17ffac927d4a3188516ea4b04d4dffa144f3a1d", "commitAfterChange": "746290bbea7d8062bfd117c8ef9a401e578be8c7", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 16, "signatureBeforeChange": "      protected void removeFiles(File d, String[] files)", "signatureAfterChange": "      protected void removeFiles(File d, String[] files, String[] dirs)", "diff": ["-    protected void removeFiles(File d, String[] files) {", "+    protected void removeFiles(File d, String[] files, String[] dirs) {", "-                if (!quiet && !f.delete()) {", "+                if (!f.delete() && !quiet) {", "+", "+        if (dirs.length > 0 && includeEmpty) {", "+            int dirCount = 0;", "+            for (int j=0; j<dirs.length; j++) {", "+                File dir = new File(d, dirs[j]);", "+                String[] dirFiles = dir.list();", "+                if (dirFiles == null || dirFiles.length == 0) {", "+                    log(\"Deleting \" + dir.getAbsolutePath(), verbosity);", "+                    if (!dir.delete() && !quiet) {", "+                        throw new BuildException(\"Unable to delete directory \" + dir.getAbsolutePath());", "+                    } else {", "+                        dirCount++;", "+                    }", "+                }", "+            }", "+", "+            if (dirCount > 0) {", "+                log(\"Deleted \" + dirCount + \" director\" + ", "+                    (dirCount==1 ? \"y\" : \"ies\") + ", "+                    \" from \" + d.getAbsolutePath());", "+            }", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7f9296b12e37eb466349a9a420b0b5d7", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Delete.java", "commitBeforeChange": "40bf7243ac6b80a6aca5f4a56b6634b7018db629", "commitAfterChange": "2c8c53f98ad69042c3ecb1dbbb6844c8a7cc4020", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 3, "signatureBeforeChange": "      public void execute() throws BuildException", "signatureAfterChange": "   public void execute() throws BuildException", "diff": ["+   */", "+  public void execute() throws BuildException {", "+", "+    if (f == null && delDir == null) {", "+      throw new BuildException(\"<file> or <dir> attribute must be set!\");", "-    public void execute() throws BuildException {", "-        if (f.exists()) {", "-            if (f.isDirectory()) { ", "-                project.log(\"Directory: \" + f.getAbsolutePath() + ", "-                    \" cannot be removed with delete.  Use Deltree instead.\");", "-            } else {", "-                project.log(\"Deleting: \" + f.getAbsolutePath());", "-                f.delete();", "-            }", "+    // old <delete> functionality must still work", "+    if (f != null) {", "+      if (f.exists()) {", "+        if (f.isDirectory()) {", "+          project", "+            .log(\"Directory: \" + f.getAbsolutePath()", "+                 + \" cannot be removed with delete.  Use Deltree instead.\");", "+        else {", "+          project.log(\"Deleting: \" + f.getAbsolutePath());", "+          f.delete();", "+        }", "+      }", "+", "+    // now we'll do the fancy pattern-driven deletes", "+    if (delDir == null) {", "+      return;", "+    }", "+    if (!delDir.exists()) {", "+      throw new BuildException(\"dir does not exist!\");", "+    }", "+    DirectoryScanner ds    = super.getDirectoryScanner(delDir);", "+    String[]         files = ds.getIncludedFiles();", "+", "+    if (files.length > 0) {", "+      project.log(\"Deleting \" + files.length + \" files from \" + delDir.getAbsolutePath());", "+      for (int i = 0; i < files.length; i++) {", "+        File f = new File(delDir, files[i]);", "+", "+        if (f.exists()) {", "+          project.log(\"Deleting: \" + f.getAbsolutePath(), verbosity);", "+          f.delete();", "+        }", "+      }", "+    }", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "824c5f13271214b81c0fc7381ed00810", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/repository/Library.java", "commitBeforeChange": "4d831bb7cbb2bb2839303380a28f888c587802a0", "commitAfterChange": "f630ef56ed68316b07aaa27e05cf871de1070498", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 29, "signatureBeforeChange": "     public String getIf()", "signatureAfterChange": "     public boolean equals(Object o)", "diff": ["-     */", "-    public String getIf() {", "-        return ifClause;", "-    }", "+     */", "+    public boolean equals(Object o) {", "+        if (this == o) {", "+            return true;", "+        }", "+        if (!(o instanceof Library)) {", "+            return false;", "+        }", "+", "+        final Library library = (Library) o;", "+", "+        if (archive != null ? !archive.equals(library.archive) : library.archive != null) {", "+            return false;", "+        }", "+        if (destinationName != null ? !destinationName.equals(", "+                library.destinationName) : library.destinationName != null) {", "+            return false;", "+        }", "+        if (project != null ? !project.equals(library.project) : library.project != null) {", "+            return false;", "+        }", "+        if (suffix != null ? !suffix.equals(library.suffix) : library.suffix != null) {", "+            return false;", "+        }", "+        if (version != null ? !version.equals(library.version) : library.version != null) {", "+            return false;", "+        }", "+", "+        return true;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94dc14c4610b9155ca3518445ef9351d", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Available.java", "commitBeforeChange": "3f37290d4ae3797033fd3dc89cada6b329753eff", "commitAfterChange": "cad841b38aec395f91809031598a293237bc8665", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "      private boolean checkFile()", "signatureAfterChange": "      private boolean checkFile()", "diff": ["-                log(\"Searching \" + paths[i], Project.MSG_VERBOSE);", "-                if(new File(paths[i], file.getName()).isFile()) {", "-                    return true;", "+                log(\"Searching \" + paths[i], Project.MSG_DEBUG);", "+                File filename = new File(paths[i]);", "+                if (type != null) {", "+                    if (type.equalsIgnoreCase(\"dir\")) {", "+                        String dir = filename.getParent();", "+                        if(dir != null) {", "+                            int index = dir.lastIndexOf(File.separator);", "+                            String dirname = dir.substring(index + 1);", "+                            if(dirname.equals(file.getName())) {", "+                                log(\"Found directory: \" + dir, Project.MSG_VERBOSE);", "+                                return true;", "+                            }", "+                        }", "+                    } else if (type.equalsIgnoreCase(\"file\")) {", "+                        if(filename.isFile()) {", "+                            if(filename.getName().equals(file.getName())) {", "+                                log(\"Found file: \" + filename, Project.MSG_VERBOSE);", "+                                return true;", "+                            }", "+                        }", "+                    }", "+                } else if(filename.isFile()) {", "+                    if(filename.getName().equals(file.getName())) {", "+                        log(\"Found file: \" + filename, Project.MSG_VERBOSE);", "+                        return true;", "+                    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a04a6ac65df75bd9bf837d30c864e58b", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java", "commitBeforeChange": "b0b920b08fae74de3fd7a7dd5efbca9e8cf379e6", "commitAfterChange": "114d55869f46b382375b6b32ddc17bb2e5fc598c", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 12, "signatureBeforeChange": "     public void run()", "signatureAfterChange": "     public void run()", "diff": ["+                final boolean testMethodsSpecified = (methods != null);", "+", "+                if (!testMethodsSpecified) {", "+                }", "+                    boolean useSingleMethodAdapter = false;", "+                    if (junit.framework.TestCase.class.isAssignableFrom(testClass)) {", "+                        // Do not use JUnit 4 API for running JUnit 3.x", "+                        // tests - it is not able to run individual test", "+                        // methods.", "+                        //", "+                        // Technical details:", "+                        // org.junit.runner.Request.method(Class, String).getRunner()", "+                        // would return a runner which always executes all", "+                        // test methods. The reason is that the Runner would be", "+                        // an instance of class", "+                        // org.junit.internal.runners.OldTestClassRunner", "+                        // that does not implement interface Filterable - so it", "+                        // is unable to filter out test methods not matching", "+                        // the requested name.", "+                    } else {", "+                            if (testMethodsSpecified) {", "+                                /*", "+                                 * We cannot try to load the JUnit4TestAdapter", "+                                 * before trying to load JUnit4TestMethodAdapter", "+                                 * because it might fail with", "+                                 * NoClassDefFoundException, instead of plain", "+                                 * ClassNotFoundException.", "+                                 */", "+                                junit4TestAdapterClass = Class.forName(", "+                                    \"org.apache.tools.ant.taskdefs.optional.junit.JUnit4TestMethodAdapter\");", "+                                useSingleMethodAdapter = true;", "+                            }", "+                            if (testMethodsSpecified) {", "+                                junit4TestAdapterClass =", "+                                    Class.forName(", "+                                        \"org.apache.tools.ant.taskdefs.optional.junit.JUnit4TestMethodAdapter\",", "+                                        true, loader);", "+                                useSingleMethodAdapter = true;", "+                            }", "+                    }", "+                        Class[] formalParams;", "+                        Object[] actualParams;", "+                        if (useSingleMethodAdapter) {", "+                            formalParams = new Class[] {Class.class, String[].class};", "+                            actualParams = new Object[] {testClass, methods};", "+                        } else {", "+                            formalParams = new Class[] {Class.class};", "+                            actualParams = new Object[] {testClass};", "+                        }", "-                            .getConstructor(new Class[] {Class.class}).", "-                            newInstance(new Object[] {testClass});", "+                            .getConstructor(formalParams).", "+                            newInstance(actualParams);", "-                        suite = new TestSuite(testClass);", "+                        if (!testMethodsSpecified) {", "+                            suite = new TestSuite(testClass);", "+                        } else if (methods.length == 1) {", "+                            suite = TestSuite.createTest(testClass, methods[0]);", "+                        } else {", "+                            TestSuite testSuite = new TestSuite(testClass.getName());", "+                            for (int i = 0; i < methods.length; i++) {", "+                                testSuite.addTest(", "+                                    TestSuite.createTest(testClass, methods[i]));", "+                            }", "+                            suite = testSuite;", "+                        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eb0e60e854b930563495f609f2c27729", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Sync.java", "commitBeforeChange": "13b07b313fdc7ab2620f71517ab16698be496f24", "commitAfterChange": "a799f17a4e2ff063e0d4c05d6a1be064e84d68c8", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private int[] removeOrphanFiles(Set nonOrphans, File toDir)", "signatureAfterChange": "     private int[] removeOrphanFiles(Set nonOrphans, File toDir)", "diff": ["-            syncTarget.setTargetDir(toDir);", "-            ds = syncTarget.getDirectoryScanner(getProject());", "+            FileSet fs = new FileSet();", "+            fs.setDir(toDir);", "+            fs.setCaseSensitive(syncTarget.isCaseSensitive());", "+            fs.setFollowSymlinks(syncTarget.isFollowSymlinks());", "+", "+            // preserveInTarget would find all files we want to keep,", "+            // but we need to find all that we want to delete - so the", "+            // meaning of all patterns and selectors must be inverted", "+            PatternSet ps = syncTarget.mergePatterns(getProject());", "+            String[] excludes = ps.getExcludePatterns(getProject());", "+            fs.appendExcludes(ps.getIncludePatterns(getProject()));", "+            fs.appendIncludes(ps.getExcludePatterns(getProject()));", "+            fs.setDefaultexcludes(!syncTarget.getDefaultexcludes());", "+", "+            // selectors are implicitly ANDed in DirectoryScanner.  To", "+            // revert their logic we wrap them into a <none> selector", "+            // instead.", "+            FileSelector[] s = syncTarget.getSelectors(getProject());", "+            if (s.length > 0) {", "+                NoneSelector ns = new NoneSelector();", "+                for (int i = 0; i < s.length; i++) {", "+                    ns.appendSelector(s[i]);", "+                }", "+                fs.appendSelector(ns);", "+            }", "+            ", "+            ds = fs.getDirectoryScanner(getProject());", "-        // ds returns the directories as it has visited them.", "+        // ds returns the directories in lexicographic order."]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fa5754261a0e0bf29fb837b3388fc3c9", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/email/MimeMailer.java", "commitBeforeChange": "b1b76c9c72c63ad046f952916e61b6aa8c1fea94", "commitAfterChange": "1be216b5d5ba9365d09b12c64ad31cd3cc7d5cdd", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "     public void send()", "signatureAfterChange": "     public void send()", "diff": ["-            Transport.send(msg);", "+            try {", "+                Transport.send(msg);", "+            } catch (SendFailedException sfe) {", "+                if (!shouldIgnoreInvalidRecipients()) {", "+                    throw new BuildException(GENERIC_ERROR, sfe);", "+                } else if (sfe.getValidSentAddresses() == null", "+                           || sfe.getValidSentAddresses().length == 0) {", "+                    throw new BuildException(\"Couldn't reach any recipient\",", "+                                             sfe);", "+                } else {", "+                    Address[] invalid = sfe.getInvalidAddresses();", "+                    if (invalid == null) {", "+                        invalid = new Address[0];", "+                    }", "+                    for (int i = 0; i < invalid.length; i++) {", "+                        didntReach(invalid[i], \"invalid\", sfe);", "+                    }", "+                    Address[] validUnsent = sfe.getValidUnsentAddresses();", "+                    if (validUnsent == null) {", "+                        validUnsent = new Address[0];", "+                    }", "+                    for (int i = 0; i < validUnsent.length; i++) {", "+                        didntReach(validUnsent[i], \"valid\", sfe);", "+                    }", "+                }", "+            }", "-            throw new BuildException(\"Problem while sending mime mail:\", e);", "+            throw new BuildException(GENERIC_ERROR, e);", "-            throw new BuildException(\"Problem while sending mime mail:\", e);", "+            throw new BuildException(GENERIC_ERROR, e);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fcb214d184a7864e5cfe3c90e1dc710a", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/ejb/EjbcHelper.java", "commitBeforeChange": "403c32e5c5322f65e184f6d21496d0295d74f6e1", "commitAfterChange": "655df7f9e198a141defc9dcfb45f7f14cd7749f8", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 10, "signatureBeforeChange": "     private void regenerateSupportClasses(File descriptorFile) throws Exception", "signatureAfterChange": "     private void regenerateSupportClasses(File descriptorFile)", "diff": ["-    private void regenerateSupportClasses(File descriptorFile) throws Exception {", "-        // create a Java task to do the rebuild", "+    private void regenerateSupportClasses(File descriptorFile) {", "+        Project project = ejbcTask.getProject();", "+        String javaHome = System.getProperty(\"java.home\");", "-        String[] args = {\"-noexit\",", "-                         \"-keepgenerated\",", "-                         \"-d\", generatedFilesDirectory.getPath(),", "-                         descriptorFile.getPath()};", "+        String compiler = project.getProperty(\"build.compiler\");", "+        String[] args = null;", "+        if (compiler.equalsIgnoreCase(\"jikes\")) {", "+            Path execClassPath = new Path(project);", "+            if (Project.getJavaVersion() == Project.JAVA_1_1) {", "+                execClassPath.addExisting(new Path(project, System.getProperty(\"java.home\")", "+                                          + \"/lib/classes.zip\"));", "+            } else {", "+                execClassPath.addExisting(new Path(project,", "+                                                System.getProperty(\"java.home\")", "+                                                + \"/lib/rt.jar\"));", "+                // Just keep the old version as well and let addExisting", "+                // sort it out.", "+                execClassPath.addExisting(new Path(project,", "+                                                System.getProperty(\"java.home\")", "+                                                + \"/jre/lib/rt.jar\"));", "+            }", "+            execClassPath.append(classpath);", "+    ", "+            args = new String[] {\"-noexit\",", "+                                 \"-keepgenerated\",", "+                                 \"-compiler\", \"Jikes\",", "+                                 \"-d\", generatedFilesDirectory.getPath(),", "+                                 \"-classpath\", execClassPath.toString(), ", "+                                 descriptorFile.getPath()};", "+        }", "+        else {            ", "+            args = new String[]{\"-noexit\",", "+                                \"-keepgenerated\",", "+                                \"-d\", generatedFilesDirectory.getPath(),", "+                                \"-classpath\", classpath.toString(), ", "+                                descriptorFile.getPath()};", "+        }", "+                                       ", "-            // run with no exit for better reporting", "-            String[] newArgs = {\"-keepgenerated\",", "-                         \"-d\", generatedFilesDirectory.getPath(),", "-                         descriptorFile.getPath()};", "-            weblogic.ejbc.main(newArgs);", "+            e.printStackTrace();", "+            throw new BuildException(e);"]}]}