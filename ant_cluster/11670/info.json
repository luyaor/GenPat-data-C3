{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9406bedfe94a21d42712db629a742b08", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "900e8ad7201ae33732e2538a5c10d75b", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/ManifestClassPath.java", "commitBeforeChange": "65fc13760d14462f153c560c6d41392f63e19de8", "commitAfterChange": "759f97729aa8876433fc8df2cf1d9d0084e62b66", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public void execute()", "signatureAfterChange": "     public void execute()", "diff": ["+        StringBuffer tooLongSb = new StringBuffer();", "+        for (int i = 0; i < maxParentLevels + 1; i++) {", "+            tooLongSb.append(\"../\");", "+        }", "+        final String tooLongPrefix = tooLongSb.toString();", "+", "-", "-        // Create as many directory prefixes as parent levels to traverse,", "-        // in addition to the reference directory itself", "-        File currDir = dir;", "-        String[] dirs = new String[maxParentLevels + 1];", "-        for (int i = 0; i < maxParentLevels + 1; ++i) {", "-            dirs[i] = currDir.getAbsolutePath();", "-            if (!dirs[i].equals(\"\" + File.separatorChar)) {", "-                dirs[i] = dirs[i] + File.separatorChar;", "-            }", "-            currDir = currDir.getParentFile();", "-            if (currDir == null) {", "-                maxParentLevels = i + 1;", "-                break;", "-            }", "-        }", "-            pathEntry = fileUtils.normalize(pathEntry.getAbsolutePath());", "+            pathEntry = fileUtils.normalize(fullPath);", "-            // Find the longest prefix shared by the current file", "-            // and the reference directory.", "-            for (int j = 0; j <= maxParentLevels && j < dirs.length; ++j) {", "-                String dir = dirs[j];", "-                if (!fullPath.startsWith(dir)) {", "-                    continue;", "-                }", "+            String canonicalPath = null;", "+            try {", "+                relPath = FileUtils.getRelativePath(dir, pathEntry);", "-                // We have a match! Add as many ../ as parent", "-                // directory traversed to get the relative path", "-                element.setLength(0);", "-                for (int k = 0; k < j; ++k) {", "-                    element.append(\"..\");", "-                    element.append(File.separatorChar);", "+                canonicalPath = pathEntry.getCanonicalPath();", "+                // getRelativePath always uses '/' as separator, adapt", "+                if (File.separatorChar != '/') {", "+                    canonicalPath =", "+                        canonicalPath.replace(File.separatorChar, '/');", "-                element.append(fullPath.substring(dir.length()));", "-                relPath = element.toString();", "-                break;", "+            } catch (Exception e) {", "+                throw new BuildException(\"error trying to get the relative path\"", "+                                         + \" from \" + dir + \" to \" + fullPath,", "+                                         e);", "-            if (relPath == null) {", "+            if (relPath.equals(canonicalPath)", "+                || relPath.startsWith(tooLongPrefix)) {", "-            // Manifest's ClassPath: attribute always uses forward", "-            // slashes '/', and is space-separated. Ant will properly", "-            // format it on 72 columns with proper line continuation", "-            if (File.separatorChar != '/') {", "-                relPath = relPath.replace(File.separatorChar, '/');", "-            }", "-            if (pathEntry.isDirectory()) {", "+            if (pathEntry.isDirectory() && !relPath.endsWith(\"/\")) {", "+            // Manifest's ClassPath: attribute always uses forward", "+            // slashes '/', and is space-separated. Ant will properly", "+            // format it on 72 columns with proper line continuation"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cefec9a3a4733a1b64d974a4ac818b9a", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Javac.java", "commitBeforeChange": "c1a5419faf39033ffc2db1dcf8000f6a796f2dad", "commitAfterChange": "4ca5683c2a54ff4a141ed562a0f3b431b153b2c2", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 6, "signatureBeforeChange": "     protected Path getCompileClasspath(boolean addRuntime)", "signatureAfterChange": "     public Path getClasspath()", "diff": ["+    /** Gets the classpath to be used for this compilation. */", "+    public Path getClasspath() {", "+        return compileClasspath;", "-     */", "-    protected Path getCompileClasspath(boolean addRuntime) {", "-        Path classpath = new Path(project);", "-", "-        // add dest dir to classpath so that previously compiled and", "-        // untouched classes are on classpath", "-", "-        if (destDir != null) {", "-            classpath.setLocation(destDir);", "-        }", "-", "-        // Combine the build classpath with the system classpath, in an ", "-        // order determined by the value of build.classpath", "-", "-        if (compileClasspath == null) {", "-            classpath.addExisting(Path.systemClasspath);", "-        } else {", "-            classpath.addExisting(compileClasspath.concatSystemClasspath());", "-        }", "-", "-        // optionally add the runtime classes", "-", "-        if (addRuntime) {", "-            if (System.getProperty(\"java.vendor\").toLowerCase().indexOf(\"microsoft\") >= 0) {", "-                // Pull in *.zip from packages directory", "-                FileSet msZipFiles = new FileSet();", "-                msZipFiles.setDir(new File(System.getProperty(\"java.home\") + File.separator + \"Packages\"));", "-                msZipFiles.setIncludes(\"*.ZIP\");", "-                classpath.addFileset(msZipFiles);", "-            }", "-            else if (Project.getJavaVersion() == Project.JAVA_1_1) {", "-                classpath.addExisting(new Path(null,", "-                                                System.getProperty(\"java.home\")", "-                                                + File.separator + \"lib\"", "-                                                + File.separator ", "-                                                + \"classes.zip\"));", "-            } else {", "-                // JDK > 1.1 seems to set java.home to the JRE directory.", "-                classpath.addExisting(new Path(null,", "-                                                System.getProperty(\"java.home\")", "-                                                + File.separator + \"lib\"", "-                                                + File.separator + \"rt.jar\"));", "-                // Just keep the old version as well and let addExistingToPath", "-                // sort it out.", "-                classpath.addExisting(new Path(null,", "-                                                System.getProperty(\"java.home\")", "-                                                + File.separator +\"jre\"", "-                                                + File.separator + \"lib\"", "-                                                + File.separator + \"rt.jar\"));", "-            }", "-        }", "-            ", "-        return classpath;"]}]}