{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e60db97101e020c8d10544850252aa0f", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60513376bc17ccb6b559eb16b30bae77", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/antidote/org/apache/tools/ant/gui/acs/ACSTreeNodeElement.java", "commitBeforeChange": "a04027cae372928a9f757764f38c28f61e128412", "commitAfterChange": "0c852dba516bf705d62a2d53c47a7b1b1cdd5048", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     private List getCache()", "signatureAfterChange": "     private List getCache()", "diff": ["-            for(int i = 0; i < getLength(); i++) {", "-                if(item(i) instanceof TreeNode) {", "-                    _treeNodeCache.add(item(i));", "+            // XXX this crazy casting is to get around an", "+            // inconsistency between jikes and javac whereby", "+            // the call without this cast when compiled with", "+            // jikes causes an IllegalAccessException", "+            // because the implementation of getLength() and", "+            // item() are actually in a package only class", "+            // in the Sun implementation classes.", "+            int len = ((NodeList)this).getLength();", "+", "+            for(int i = 0; i < len; i++) {", "+                Object n = ((NodeList)this).item(i);", "+", "+                if(n instanceof TreeNode) {", "+                    _treeNodeCache.add(n);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b220678a6318333e71db67abebcdbd2a", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/DirectoryScanner.java", "commitBeforeChange": "e362b3b1fc28b4d9b2965708b5d5e457f21b0c9f", "commitAfterChange": "c13dba6d524fe74b1518e3442429ba6e97592edd", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": "     protected boolean couldHoldIncluded(String name)", "signatureAfterChange": "     protected boolean couldHoldIncluded(String name)", "diff": ["+        final PathPattern tokenizedName = new PathPattern(name);", "-            if (matchPatternStart(includes[i], name, isCaseSensitive())", "+            PathPattern tokenizedInclude = new PathPattern(includes[i]);", "+            if (tokenizedName.matchPatternStartOf(tokenizedInclude,", "+                                                  isCaseSensitive())", "-                && isDeeper(includes[i], name)) {", "+                && isDeeper(tokenizedInclude, tokenizedName)) {"]}]}