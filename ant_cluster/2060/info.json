{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1cc57d9309a22dc11429a9470fd14204", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b7b5b0c877d1dbea1f4511ef403f4a9", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Move.java", "commitBeforeChange": "2a713cc02adc21aa5bd5189c8a2718631e6f6a88", "commitAfterChange": "99067d060752e5a89c24d99c17b6eb7231f96380", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "      protected void doFileOperations()", "signatureAfterChange": "      protected void doFileOperations()", "diff": ["-                String toFile = (String) fileCopyMap.get(fromFile);", "-                if (fromFile.equals(toFile)) {", "-                    log(\"Skipping self-move of \" + fromFile, verbosity);", "-                    continue;", "-                }", "-", "-                boolean moved = false;", "-", "+                boolean selfMove = false;", "-                    File d = new File(toFile);", "+                    String[] toFiles = (String[]) fileCopyMap.get(fromFile);", "+                    for (int i = 0; i < toFiles.length; i++) {", "+                        String toFile = (String) toFiles[i];", "-                    try {", "-                        log(\"Attempting to rename: \" + fromFile", "-                            + \" to \" + toFile, verbosity);", "-                        moved = renameFile(f, d, filtering, forceOverwrite);", "-                    } catch (IOException ioe) {", "-                        String msg = \"Failed to rename \" + fromFile", "-                            + \" to \" + toFile", "-                            + \" due to \" + ioe.getMessage();", "-                        throw new BuildException(msg, ioe, getLocation());", "-                    }", "+                        if (fromFile.equals(toFile)) {", "+                            log(\"Skipping self-move of \" + fromFile, verbosity);", "+                            selfMove = true;", "-                    if (!moved) {", "-                        try {", "-                            log(\"Moving \" + fromFile + \" to \" + toFile,", "-                                verbosity);", "-", "-                            FilterSetCollection executionFilters =", "-                                new FilterSetCollection();", "-                            if (filtering) {", "-                                executionFilters", "-                                    .addFilterSet(getProject().getGlobalFilterSet());", "-                            }", "-                            for (Enumeration filterEnum =", "-                                     getFilterSets().elements();", "-                                 filterEnum.hasMoreElements();) {", "-                                executionFilters", "-                                    .addFilterSet((FilterSet) filterEnum", "-                                                  .nextElement());", "-                            }", "-                            getFileUtils().copyFile(f, d, executionFilters,", "-                                                    getFilterChains(),", "-                                                    forceOverwrite,", "-                                                    getPreserveLastModified(),", "-                                                    getEncoding(),", "-                                                    getOutputEncoding(),", "-                                                    getProject());", "-", "-                            f = new File(fromFile);", "-                            if (!f.delete()) {", "-                                throw new BuildException(\"Unable to delete \"", "-                                                         + \"file \"", "-                                                         + f.getAbsolutePath());", "-                            }", "-                        } catch (IOException ioe) {", "-                            String msg = \"Failed to copy \" + fromFile + \" to \"", "-                                + toFile", "-                                + \" due to \" + ioe.getMessage();", "-                            throw new BuildException(msg, ioe, getLocation());", "+                            // if this is the last time through the loop then", "+                            // move will not occur, but that's what we want", "+                            continue;", "+                        }", "+                        File d = new File(toFile);", "+                        if ((i + 1) == toFiles.length && !selfMove) {", "+                            // Only try to move if this is the last mapped file", "+                            // and one of the mappings isn't to itself", "+                            moveFile(f, d, filtering, forceOverwrite);", "+                        } else {", "+                            copyFile(f, d, filtering, forceOverwrite);", "-            int count = 0;", "+            int createCount = 0;", "-                String toDirName = (String) dirCopyMap.get(fromDirName);", "-                File fromDir = new File(fromDirName);", "-                File toDir = new File(toDirName);", "-                if (!toDir.exists()) {", "-                    if (!toDir.mkdirs()) {", "-                        log(\"Unable to create directory \"", "-                            + toDirName, Project.MSG_ERR);", "-                    } else {", "-                        count++;", "+                String[] toDirNames = (String[]) dirCopyMap.get(fromDirName);", "+                boolean selfMove = false;", "+                for (int i = 0; i < toDirNames.length; i++) {", "+", "+                    if (fromDirName.equals(toDirNames[i])) {", "+                        log(\"Skipping self-move of \" + fromDirName, verbosity);", "+                        selfMove = true;", "+                        continue;", "+                    }", "+", "+                    File d = new File(toDirNames[i]);", "+                    if (!d.exists()) {", "+                        if (!d.mkdirs()) {", "+                            log(\"Unable to create directory \"", "+                                + d.getAbsolutePath(), Project.MSG_ERR);", "+                        } else {", "+                            createCount++;", "+                        }", "-                if (okToDelete(fromDir)) {", "+", "+                File fromDir = new File(fromDirName);", "+                if (!selfMove && okToDelete(fromDir)) {", "+", "-            if (count > 0) {", "-                log(\"Moved \" + count + \" empty directories to \"", "+            if (createCount > 0) {", "+                log(\"Moved \" + dirCopyMap.size()", "+                    + \" empty director\"", "+                    + (dirCopyMap.size()== 1 ? \"y\" : \"ies\")", "+                    + \" to \" + createCount", "+                    + \" empty director\"", "+                    + (createCount == 1 ? \"y\" : \"ies\") + \" under \""]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82484d8681784956185b5a8ecfe84992", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/myrmidon/src/java/org/apache/aut/tar/TarInputStream.java", "commitBeforeChange": "0b93bdd7cdfe6a7a48f02cf125014e5d538d5381", "commitAfterChange": "1447e596aa13ca3441f24a8e163f4a255c5a7e23", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public TarEntry getNextEntry()         throws IOException", "signatureAfterChange": "     public TarEntry getNextEntry()         throws IOException", "diff": ["-        if( this.hasHitEOF )", "+        if( m_hasHitEOF )", "-        if( this.currEntry != null )", "+        if( m_currEntry != null )", "-            int numToSkip = this.entrySize - this.entryOffset;", "+            final int numToSkip = m_entrySize - m_entryOffset;", "-            if( this.debug )", "+            if( m_debug )", "-                System.err.println( \"TarInputStream: SKIP currENTRY '\"", "-                                    + this.currEntry.getName() + \"' SZ \"", "-                                    + this.entrySize + \" OFF \"", "-                                    + this.entryOffset + \"  skipping \"", "-                                    + numToSkip + \" bytes\" );", "+                final String message = \"TarInputStream: SKIP currENTRY '\" +", "+                    m_currEntry.getName() + \"' SZ \" + m_entrySize +", "+                    \" OFF \" + m_entryOffset + \"  skipping \" + numToSkip + \" bytes\";", "+                debug( message );", "-                this.skip( numToSkip );", "+                skip( numToSkip );", "-            this.readBuf = null;", "+            m_readBuf = null;", "-        byte[] headerBuf = this.buffer.readRecord();", "-", "+        final byte[] headerBuf = m_buffer.readRecord();", "-            if( this.debug )", "+            if( m_debug )", "-                System.err.println( \"READ NULL RECORD\" );", "+                debug( \"READ NULL RECORD\" );", "-            this.hasHitEOF = true;", "+            m_hasHitEOF = true;", "-        else if( this.buffer.isEOFRecord( headerBuf ) )", "+        else if( m_buffer.isEOFRecord( headerBuf ) )", "-            if( this.debug )", "+            if( m_debug )", "-                System.err.println( \"READ EOF RECORD\" );", "+                debug( \"READ EOF RECORD\" );", "-            this.hasHitEOF = true;", "+            m_hasHitEOF = true;", "-        if( this.hasHitEOF )", "+        if( m_hasHitEOF )", "-            this.currEntry = null;", "+            m_currEntry = null;", "-            this.currEntry = new TarEntry( headerBuf );", "+            m_currEntry = new TarEntry( headerBuf );", "-            if( !( headerBuf[ 257 ] == 'u' && headerBuf[ 258 ] == 's'", "-                && headerBuf[ 259 ] == 't' && headerBuf[ 260 ] == 'a'", "-                && headerBuf[ 261 ] == 'r' ) )", "+            if( !( headerBuf[ 257 ] == 'u' && headerBuf[ 258 ] == 's' &&", "+                headerBuf[ 259 ] == 't' && headerBuf[ 260 ] == 'a' &&", "+                headerBuf[ 261 ] == 'r' ) )", "-                this.entrySize = 0;", "-                this.entryOffset = 0;", "-                this.currEntry = null;", "+                m_entrySize = 0;", "+                m_entryOffset = 0;", "+                m_currEntry = null;", "-                throw new IOException( \"bad header in block \"", "-                                       + this.buffer.getCurrentBlockNum()", "-                                       + \" record \"", "-                                       + this.buffer.getCurrentRecordNum()", "-                                       + \", \" +", "-                                       \"header magic is not 'ustar', but '\"", "-                                       + headerBuf[ 257 ]", "-                                       + headerBuf[ 258 ]", "-                                       + headerBuf[ 259 ]", "-                                       + headerBuf[ 260 ]", "-                                       + headerBuf[ 261 ]", "-                                       + \"', or (dec) \"", "-                                       + ( (int)headerBuf[ 257 ] )", "-                                       + \", \"", "-                                       + ( (int)headerBuf[ 258 ] )", "-                                       + \", \"", "-                                       + ( (int)headerBuf[ 259 ] )", "-                                       + \", \"", "-                                       + ( (int)headerBuf[ 260 ] )", "-                                       + \", \"", "-                                       + ( (int)headerBuf[ 261 ] ) );", "+                final String message = \"bad header in block \" +", "+                    m_buffer.getCurrentBlockNum() +", "+                    \" record \" + m_buffer.getCurrentRecordNum() + \", \" +", "+                    \"header magic is not 'ustar', but '\" +", "+                    headerBuf[ 257 ] +", "+                    headerBuf[ 258 ] +", "+                    headerBuf[ 259 ] +", "+                    headerBuf[ 260 ] +", "+                    headerBuf[ 261 ] +", "+                    \"', or (dec) \" +", "+                    ( (int)headerBuf[ 257 ] ) + \", \" +", "+                    ( (int)headerBuf[ 258 ] ) + \", \" +", "+                    ( (int)headerBuf[ 259 ] ) + \", \" +", "+                    ( (int)headerBuf[ 260 ] ) + \", \" +", "+                    ( (int)headerBuf[ 261 ] );", "+", "+                throw new IOException( message );", "-            if( this.debug )", "+            if( m_debug )", "-                System.err.println( \"TarInputStream: SET CURRENTRY '\"", "-                                    + this.currEntry.getName()", "-                                    + \"' size = \"", "-                                    + this.currEntry.getSize() );", "+                final String message = \"TarInputStream: SET CURRENTRY '\" +", "+                    m_currEntry.getName() + \"' size = \" + m_currEntry.getSize();", "+                debug( message );", "-            this.entryOffset = 0;", "+            m_entryOffset = 0;", "-            this.entrySize = (int)this.currEntry.getSize();", "+            m_entrySize = (int)m_currEntry.getSize();", "-        if( this.currEntry != null && this.currEntry.isGNULongNameEntry() )", "+        if( null != m_currEntry && m_currEntry.isGNULongNameEntry() )", "-            StringBuffer longName = new StringBuffer();", "-            byte[] buffer = new byte[ 256 ];", "+            final StringBuffer longName = new StringBuffer();", "+            final byte[] buffer = new byte[ 256 ];", "-                longName.append( new String( buffer, 0, length ) );", "+                final String str = new String( buffer, 0, length );", "+                longName.append( str );", "-            this.currEntry.setName( longName.toString() );", "+            m_currEntry.setName( longName.toString() );", "-        return this.currEntry;", "+        return m_currEntry;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e7a53a91f8cb00b9a03e5d219889923", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Copy.java", "commitBeforeChange": "2a713cc02adc21aa5bd5189c8a2718631e6f6a88", "commitAfterChange": "99067d060752e5a89c24d99c17b6eb7231f96380", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 30, "signatureBeforeChange": "     protected void doFileOperations()", "signatureAfterChange": "     protected void doFileOperations()", "diff": ["-                String toFile = (String) fileCopyMap.get(fromFile);", "+                String[] toFiles = (String[]) fileCopyMap.get(fromFile);", "-                if (fromFile.equals(toFile)) {", "-                    log(\"Skipping self-copy of \" + fromFile, verbosity);", "-                    continue;", "-                }", "+                for (int i = 0; i < toFiles.length; i++) {", "+                    String toFile = toFiles[i];", "-                try {", "-                    log(\"Copying \" + fromFile + \" to \" + toFile, verbosity);", "+                    if (fromFile.equals(toFile)) {", "+                        log(\"Skipping self-copy of \" + fromFile, verbosity);", "+                        continue;", "+                    }", "-                    FilterSetCollection executionFilters =", "-                        new FilterSetCollection();", "-                    if (filtering) {", "-                        executionFilters", "-                            .addFilterSet(getProject().getGlobalFilterSet());", "+                    try {", "+                        log(\"Copying \" + fromFile + \" to \" + toFile, verbosity);", "+", "+                        FilterSetCollection executionFilters =", "+                            new FilterSetCollection();", "+                        if (filtering) {", "+                            executionFilters", "+                                .addFilterSet(getProject().getGlobalFilterSet());", "+                        }", "+                        for (Enumeration filterEnum = filterSets.elements();", "+                            filterEnum.hasMoreElements();) {", "+                            executionFilters", "+                                .addFilterSet((FilterSet) filterEnum.nextElement());", "+                        }", "+                        fileUtils.copyFile(fromFile, toFile, executionFilters,", "+                                           filterChains, forceOverwrite,", "+                                           preserveLastModified, inputEncoding,", "+                                           outputEncoding, getProject());", "+                    } catch (IOException ioe) {", "+                        String msg = \"Failed to copy \" + fromFile + \" to \" + toFile", "+                            + \" due to \" + ioe.getMessage();", "+                        File targetFile = new File(toFile);", "+                        if (targetFile.exists() && !targetFile.delete()) {", "+                            msg += \" and I couldn't delete the corrupt \" + toFile;", "+                        }", "+                        throw new BuildException(msg, ioe, getLocation());", "-                    for (Enumeration filterEnum = filterSets.elements();", "-                         filterEnum.hasMoreElements();) {", "-                        executionFilters", "-                            .addFilterSet((FilterSet) filterEnum.nextElement());", "-                    }", "-                    fileUtils.copyFile(fromFile, toFile, executionFilters,", "-                                       filterChains, forceOverwrite,", "-                                       preserveLastModified, inputEncoding,", "-                                       outputEncoding, getProject());", "-                } catch (IOException ioe) {", "-                    String msg = \"Failed to copy \" + fromFile + \" to \" + toFile", "-                        + \" due to \" + ioe.getMessage();", "-                    File targetFile = new File(toFile);", "-                    if (targetFile.exists() && !targetFile.delete()) {", "-                        msg += \" and I couldn't delete the corrupt \" + toFile;", "-                    }", "-                    throw new BuildException(msg, ioe, getLocation());", "-            int count = 0;", "+            int createCount = 0;", "-                File d = new File((String) e.nextElement());", "-                if (!d.exists()) {", "-                    if (!d.mkdirs()) {", "-                        log(\"Unable to create directory \"", "-                            + d.getAbsolutePath(), Project.MSG_ERR);", "-                    } else {", "-                        count++;", "+                String[] dirs = (String[]) e.nextElement();", "+                for (int i = 0; i < dirs.length; i++) {", "+                    File d = new File(dirs[i]);", "+                    if (!d.exists()) {", "+                        if (!d.mkdirs()) {", "+                            log(\"Unable to create directory \"", "+                                + d.getAbsolutePath(), Project.MSG_ERR);", "+                        } else {", "+                            createCount++;", "+                        }", "-", "-            if (count > 0) {", "-                log(\"Copied \" + count + \" empty director\"", "-                    + (count == 1 ? \"y\" : \"ies\")", "-                    + \" to \" + destDir.getAbsolutePath());", "+            if (createCount > 0) {", "+                log(\"Copied \" + dirCopyMap.size()", "+                    + \" empty director\"", "+                    + (dirCopyMap.size() == 1 ? \"y\" : \"ies\")", "+                    + \" to \" + createCount", "+                    + \" empty director\"", "+                    + (createCount == 1 ? \"y\" : \"ies\") + \" under \"", "+                    + destDir.getAbsolutePath());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "934435f00372377f25f59c046a805b96", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/PathConvert.java", "commitBeforeChange": "b5b99c769a21d3602ee35948cf004925f03464ba", "commitAfterChange": "25253f3faa839d0341bdfe9eecb06d8791fcf8ea", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 14, "signatureBeforeChange": "     public void execute() throws BuildException", "signatureAfterChange": "     public void execute() throws BuildException", "diff": ["+        Path savedPath = path;", "+        String savedPathSep = pathSep; // may be altered in validateSetup", "+        String savedDirSep = dirSep; // may be altered in validateSetup", "-        // If we are a reference, create a Path from the reference", "-        if( isReference() ) {", "-            path = new Path(getProject()).createPath();", "-", "-            Object obj = refid.getReferencedObject(getProject());", "-", "-            if( obj instanceof Path ) {", "-                path.setRefid(refid);", "-            } else if( obj instanceof FileSet ) {", "-                FileSet fs = (FileSet)obj;", "-                path.addFileset( fs );", "-            } else if( obj instanceof DirSet ) {", "-                DirSet ds = (DirSet)obj;", "-                path.addDirset( ds );", "-            } else if( obj instanceof FileList ) {", "-                FileList fl = (FileList)obj;", "-                path.addFilelist( fl );", "+        try {", "+            // If we are a reference, create a Path from the reference", "+            if( isReference() ) {", "+                path = new Path(getProject()).createPath();", "-            } else {", "-                throw new BuildException( \"'refid' does not refer to a path, fileset, dirset, or filelist.\" );", "-            }", "-        }", "-", "-        validateSetup();                    // validate our setup", "-", "-        // Currently, we deal with only two path formats: Unix and Windows", "-        // And Unix is everything that is not Windows", "-        // (with the exception for NetWare below)", "-", "-        // for NetWare and OS/2, piggy-back on Windows, since here and", "-        // in the apply code, the same assumptions can be made as with", "-        // windows - that \\\\ is an OK separator, and do comparisons", "-        // case-insensitive.", "-        onWindows = Os.isFamily(\"dos\");", "-", "-        String fromDirSep = onWindows ? \"\\\\\" : \"/\";", "-", "-        StringBuffer rslt = new StringBuffer( 100 );", "-", "-        // Get the list of path components in canonical form", "-        String[] elems = path.list();", "-", "-        for( int i=0; i < elems.length; i++ ) {", "-            String elem = elems[i];", "-", "-            elem = mapElement( elem );      // Apply the path prefix map", "-", "-", "-            // Now convert the path and file separator characters from the", "-            // current os to the target os.", "-", "-            if( i != 0 ) {", "-                rslt.append( pathSep );", "-            }", "-", "-            StringTokenizer stDirectory = ", "-                new StringTokenizer(elem, fromDirSep, true);", "-            String token = null;", "-", "-            while ( stDirectory.hasMoreTokens() ) {", "-                token = stDirectory.nextToken();", "-", "-                if (fromDirSep.equals(token)) {", "-                    rslt.append( dirSep ); ", "-                }", "-                else {", "-                    rslt.append( token );", "+                Object obj = refid.getReferencedObject(getProject());", "+                ", "+                if( obj instanceof Path ) {", "+                    path.setRefid(refid);", "+                } else if( obj instanceof FileSet ) {", "+                    FileSet fs = (FileSet)obj;", "+                    path.addFileset( fs );", "+                } else if( obj instanceof DirSet ) {", "+                    DirSet ds = (DirSet)obj;", "+                    path.addDirset( ds );", "+                } else if( obj instanceof FileList ) {", "+                    FileList fl = (FileList)obj;", "+                    path.addFilelist( fl );", "+                    ", "+                } else {", "+                    throw new BuildException( \"'refid' does not refer to a \"", "+                                              + \"path, fileset, dirset, or \"", "+                                              + \"filelist.\" );", "+            ", "+            validateSetup();                    // validate our setup", "+            ", "+            // Currently, we deal with only two path formats: Unix and Windows", "+            // And Unix is everything that is not Windows", "+            // (with the exception for NetWare and OS/2 below)", "+            ", "+            // for NetWare and OS/2, piggy-back on Windows, since here and", "+            // in the apply code, the same assumptions can be made as with", "+            // windows - that \\\\ is an OK separator, and do comparisons", "+            // case-insensitive.", "+            String fromDirSep = onWindows ? \"\\\\\" : \"/\";", "+            ", "+            StringBuffer rslt = new StringBuffer( 100 );", "+            ", "+            // Get the list of path components in canonical form", "+            String[] elems = path.list();", "+            ", "+            for( int i=0; i < elems.length; i++ ) {", "+                String elem = elems[i];", "+                ", "+                elem = mapElement( elem );      // Apply the path prefix map", "+                ", "+                ", "+                // Now convert the path and file separator characters from the", "+                // current os to the target os.", "+                ", "+                if( i != 0 ) {", "+                    rslt.append( pathSep );", "+                }", "+                ", "+                StringTokenizer stDirectory = ", "+                    new StringTokenizer(elem, fromDirSep, true);", "+                String token = null;", "+                ", "+                while ( stDirectory.hasMoreTokens() ) {", "+                    token = stDirectory.nextToken();", "+                    ", "+                    if (fromDirSep.equals(token)) {", "+                        rslt.append( dirSep ); ", "+                    }", "+                    else {", "+                        rslt.append( token );", "+                    }", "+                }", "+            }", "+", "+            // Place the result into the specified property", "+            String value = rslt.toString();", "+            ", "+            log( \"Set property \" + property + \" = \" + value, ", "+                 Project.MSG_VERBOSE );", "+            ", "+            getProject().setNewProperty( property, value );", "+        } finally {", "+            path = savedPath;", "+            dirSep = savedDirSep;", "+            pathSep = savedPathSep;", "-", "-        // Place the result into the specified property", "-        String value = rslt.toString();", "-", "-        log( \"Set property \" + property + \" = \" + value, Project.MSG_VERBOSE );", "-", "-        getProject().setNewProperty( property, value );"]}]}