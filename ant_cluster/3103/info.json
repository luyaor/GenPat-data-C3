{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f87a8fd32ea100331a24400cd4fc62d8", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09317e9345636f911e926733bd7dcc00", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java", "commitBeforeChange": "23b5b9d2ca3e35f969fa33bbcdfe55f583024c20", "commitAfterChange": "a26c94ea6a7ed1d62eccb2170a17e3cbb86c759c", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "     protected void doReplace(File f, int options)          throws IOException", "signatureAfterChange": "     protected void doReplace(File f, int options)          throws IOException", "diff": ["-                LineNumberReader lnr = new LineNumberReader(br);", "+                StringBuffer linebuf = new StringBuffer();", "+                String res = null;", "+                int c;", "+                boolean hasCR = false;", "-                while ((line = lnr.readLine()) != null) {", "-                    String res = doReplace(regex, subs, line, options);", "+                do {", "+                    c = br.read();", "-                    if (!res.equals(line)) {", "-                        changes = true;", "+                    if (c == '\\r') {", "+                        if (hasCR) {", "+                            // second CR -> EOL + possibly empty line", "+                            line = linebuf.toString();", "+                            res  = doReplace(regex, subs, line, options);", "+", "+                            if (!res.equals(line)) {", "+                                changes = true;", "+                            }", "+", "+                            pw.print(res);", "+                            pw.print('\\r');", "+", "+                            linebuf.setLength(0);", "+                            // hasCR is still true (for the second one)", "+                        } else {", "+                            // first CR in this line", "+                            hasCR = true;", "+                        }", "+                    else if (c == '\\n') {", "+                        // LF -> EOL", "+                        line = linebuf.toString();", "+                        res  = doReplace(regex, subs, line, options);", "-                    pw.println(res);", "-                }", "+                        if (!res.equals(line)) {", "+                            changes = true;", "+                        }", "+", "+                        pw.print(res);", "+                        if (hasCR) {", "+                            pw.print('\\r');", "+                            hasCR = false;", "+                        }", "+                        pw.print('\\n');", "+", "+                        linebuf.setLength(0);", "+                    } else { // any other char", "+                        if ((hasCR) || (c < 0)) {", "+                            // Mac-style linebreak or EOF (or both)", "+                            line = linebuf.toString();", "+                            res  = doReplace(regex, subs, line, options);", "+", "+                            if (!res.equals(line)) {", "+                                changes = true;", "+                            }", "+", "+                            pw.print(res);", "+                            if (hasCR) {", "+                                pw.print('\\r');", "+                                hasCR = false;", "+                            }", "+", "+                            linebuf.setLength(0);", "+                        }", "+", "+                        if (c >= 0) {", "+                            linebuf.append((char) c);", "+                        }", "+                    }", "+                } while (c >= 0);", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a89c3969a599fcb99ca812c0c278a5a9", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/util/FileUtils.java", "commitBeforeChange": "716e0cac2c969f99ad5c0f394fa176b73faced34", "commitAfterChange": "c4ad42ed39b270e1752007d643aa4499ed437ef2", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": "     public String toURI(String path)", "signatureAfterChange": "     public String toURI(String path)", "diff": ["+        int len = path.length(), ch;", "-        CharacterIterator iter = new StringCharacterIterator(path);", "-        for (char c = iter.first(); c != CharacterIterator.DONE;", "-             c = iter.next()) {", "-            if (c < 256 && isSpecial[c]) {", "+        int i = 0;", "+        for (; i < len; i++) {", "+            ch = path.charAt(i);", "+            // if it's not an ASCII character, break here, and use UTF-8 encoding", "+            if (ch >= 128)", "+                break;", "+            if (gNeedEscaping[ch]) {", "-                sb.append(escapedChar1[c]);", "-                sb.append(escapedChar2[c]);", "-            } else {", "-                sb.append(c);", "+                sb.append(gAfterEscaping1[ch]);", "+                sb.append(gAfterEscaping2[ch]);", "+                // record the fact that it's escaped", "+            }", "+            else {", "+                sb.append((char)ch);", "+", "+        // we saw some non-ascii character", "+        if (i < len) {", "+            // get UTF-8 bytes for the remaining sub-string", "+            byte[] bytes = null;", "+            byte b;", "+            try {", "+                bytes = path.substring(i).getBytes(\"UTF-8\");", "+            } catch (java.io.UnsupportedEncodingException e) {", "+                // should never happen", "+                throw new BuildException(e);", "+            }", "+            len = bytes.length;", "+", "+            // for each byte", "+            for (i = 0; i < len; i++) {", "+                b = bytes[i];", "+                // for non-ascii character: make it positive, then escape", "+                if (b < 0) {", "+                    ch = b + 256;", "+                    sb.append('%');", "+                    sb.append(gHexChs[ch >> 4]);", "+                    sb.append(gHexChs[ch & 0xf]);", "+                }", "+                else if (gNeedEscaping[b]) {", "+                    sb.append('%');", "+                    sb.append(gAfterEscaping1[b]);", "+                    sb.append(gAfterEscaping2[b]);", "+                }", "+                else {", "+                    sb.append((char)b);", "+                }", "+            }", "+        }", "+"]}]}