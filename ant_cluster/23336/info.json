{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dbad502ca067001f79a35d0f7260f481", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f24c0f7a91d2e30bea35b89dd580d38", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Property.java", "commitBeforeChange": "be12707c63314ce0314959ff551e37fe59b83943", "commitAfterChange": "4f3e4e1690289144b15872597586ed34ae92efb5", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "      private void resolveAllProperties(Hashtable props)", "signatureAfterChange": "      private void resolveAllProperties(Properties props) throws BuildException", "diff": ["-    private void resolveAllProperties(Hashtable props) {", "-        Hashtable unresolvableProperties = new Hashtable();", "-        for (Enumeration e = props.keys(); e.hasMoreElements(); ) {", "-            String name = (String) e.nextElement();", "-            String value = (String) props.get(name);", "+    private void resolveAllProperties(Properties props) throws BuildException {", "+        for (Enumeration e = props.keys(); e.hasMoreElements();) {", "+            String name = (String)e.nextElement();", "+            String value = props.getProperty(name);", "-            while (!resolved) { ", "-                Vector propsInValue = new Vector();", "-    ", "-                // assume it will be resolved", "+            while (!resolved) {", "+                Vector fragments = new Vector();", "+                Vector propertyRefs = new Vector();", "+                ProjectHelper.parsePropertyString(value, fragments, propertyRefs);", "+                ", "-                boolean unresolvable = false;", "-                if (extractProperties(value, propsInValue)) {", "-                    for (int i=0; i < propsInValue.size(); i++) {", "-                        String elem = (String) propsInValue.elementAt(i);", "-                        if (elem.equals(name) || unresolvableProperties.containsKey(elem)) {", "-                            // we won't try further resolving elements with circular ", "-                            // property dependencies or dependencies on unresolvable elements", "-                            unresolvable = true;", "-                            break;", "+                if (propertyRefs.size() != 0) {", "+                    StringBuffer sb = new StringBuffer();", "+                    Enumeration i = fragments.elements();", "+                    Enumeration j = propertyRefs.elements();", "+                    while (i.hasMoreElements()) {", "+                        String fragment = (String)i.nextElement();", "+                        if (fragment == null) {", "+                            String propertyName = (String)j.nextElement();", "+                            if (propertyName.equals(name)) {", "+                                throw new BuildException(\"Property \" + name + \" was circularly defined.\");", "+                            }", "+                            if (props.containsKey(propertyName)) {", "+                                fragment = props.getProperty(propertyName);", "+                                resolved = false;", "+                            }", "+                            else {", "+                                fragment = \"${\" + propertyName + \"}\";", "+                            }", "-                        ", "-                        if (project.getProperties().containsKey(elem) ||", "-                            props.containsKey(elem)) {", "-                            resolved = false;", "-                        }", "+                        sb.append(fragment);", "-                }", "-    ", "-                if (unresolvable) {", "-                    unresolvableProperties.put(name, value);", "-                    resolved = true;", "-                }", "-    ", "-                if (!resolved) {", "-                    value = ProjectHelper.replaceProperties(project, value,", "-                                                               project.getProperties());", "-                    value = ProjectHelper.replaceProperties(project, value, props);", "+                    value = sb.toString();", "-                }    ", "+                }", "-    }", "+    }    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9bc8efb662e7d5e75da2cd20af87f7af", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java", "commitBeforeChange": "44be0d652d306225e106ce501d4c6421d50fd8b5", "commitAfterChange": "590844e775f322377fe9d9dbb7137ed465d625d9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public void configure()", "signatureAfterChange": "     public void configure()", "diff": ["-        org.apache.tools.ant.Project project = getProject();", "+        Project project = getProject();", "+", "+            // set self as a BuildListener to delay cachefile saves", "+            getProject().addBuildListener(this);", "-            // no reference to project - e.g. during JUnit tests", "+            // no reference to project - e.g. during normal JUnit tests", "+            setDelayUpdate(false);", "-        cache = new PropertiesfileCache(cachefile);", "-        algorithm = new DigestAlgorithm();", "-        comparator = new EqualComparator();", "+        Cache      defaultCache      = new PropertiesfileCache(cachefile);", "+        Algorithm  defaultAlgorithm  = new DigestAlgorithm();", "+        Comparator defaultComparator = new EqualComparator();", "-", "-        String pkg = \"org.apache.tools.ant.types.selectors.cacheselector\";", "+        String pkg = \"org.apache.tools.ant.types.selectors.modifiedselector\";", "-        // the algorithm", "-        if (algorithm == null) {", "+        // specify the algorithm classname", "+        if (algoName != null) {", "+            // use Algorithm defined via name", "-                className = pkg + \".HashvalueAlgorithm\";", "+                algorithm = new HashvalueAlgorithm();", "-                className = pkg + \".DigestAlgorithm\";", "+                algorithm = new DigestAlgorithm();", "+            } else if (\"checksum\".equals(algoName.getValue())) {", "+                algorithm = new ChecksumAlgorithm();", "-            if (className != null) {", "-                try {", "-                    // load the specified Algorithm, save the reference and configure it", "-                    algorithm = (Algorithm) Class.forName(className).newInstance();", "-                } catch (Exception e) {", "-                    e.printStackTrace();", "-                }", "+        } else {", "+            if (algorithmClass != null) {", "+                // use Algorithm specified by classname", "+                algorithm = (Algorithm) loadClass(", "+                    algorithmClass,", "+                    \"is not an Algorithm.\",", "+                    Algorithm.class);", "+            } else {", "+                // nothing specified - use default", "+                algorithm = defaultAlgorithm;", "-        // the cache", "-        if (cache == null) {", "+        // specify the cache classname", "+        if (cacheName != null) {", "+            // use Cache defined via name", "-                className = pkg + \".PropertiesfileCache\";", "+                cache = new PropertiesfileCache();", "-            if (className != null) {", "-                try {", "-                    // load the specified Cache, save the reference and configure it", "-                    cache = (Cache) Class.forName(className).newInstance();", "-                } catch (Exception e) {", "-                    e.printStackTrace();", "-                }", "+        } else {", "+            if (cacheClass != null) {", "+                // use Cache specified by classname", "+                cache = (Cache) loadClass(cacheClass, \"is not a Cache.\", Cache.class);", "+            } else {", "+                // nothing specified - use default", "+                cache = defaultCache;", "-        // the comparator", "-        if (comparator == null) {", "+        // specify the comparator classname", "+        if (compName != null) {", "+            // use Algorithm defined via name", "-                className = pkg + \".EqualComparator\";", "-            } else if (\"role\".equals(compName.getValue())) {", "-                className = \"java.text.RuleBasedCollator\";", "+                comparator = new EqualComparator();", "+             } else if (\"rule\".equals(compName.getValue())) {", "+                // TODO there is a problem with the constructor for the RBC.", "+                // you have to provide the rules in the constructors - no setters", "+                // available.", "+                throw new BuildException(\"RuleBasedCollator not yet supported.\");", "+                // Have to think about lazy initialization here...  JHM", "+                // comparator = new java.text.RuleBasedCollator();", "-            if (className != null) {", "-                try {", "-                    // load the specified Cache, save the reference and configure it", "-                    comparator = (Comparator) Class.forName(className).newInstance();", "-                } catch (Exception e) {", "-                    e.printStackTrace();", "-                }", "+        } else {", "+            if (comparatorClass != null) {", "+                // use Algorithm specified by classname", "+                comparator = (Comparator) loadClass(", "+                    comparatorClass,", "+                    \"is not a Comparator.\",", "+                    Comparator.class);", "+            } else {", "+                // nothing specified - use default", "+                comparator = defaultComparator;"]}]}