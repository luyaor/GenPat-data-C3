{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fa706879ed9c40bb86f777638dc6db10", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1a7e2941f076380f9d86b4570233a5be", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Parallel.java", "commitBeforeChange": "2590a640ce546d8fdce8dc864f929b53e6bb1138", "commitAfterChange": "89847cdf7d0bfd13dc1431e1e7128ea587550c4b", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 8, "signatureBeforeChange": "     private void spinThreads() throws BuildException", "signatureAfterChange": "     private void spinThreads() throws BuildException", "diff": ["-        Thread[] threads = new Thread[numTasks];", "+        stillRunning = true;", "+        timedOut = false;", "+", "-            ThreadGroup group = new ThreadGroup(\"parallel\");", "-            TaskRunnable taskRunnable", "+            runnables[threadNumber]", "-            runnables[threadNumber] = taskRunnable;", "-            threads[threadNumber] = new Thread(group, taskRunnable);", "-        final int maxRunning = numThreads;", "-        Thread[] running = new Thread[maxRunning];", "+        final int maxRunning = numTasks < numThreads ? numTasks : numThreads;", "+        TaskRunnable[] running = new TaskRunnable[maxRunning];", "+", "+        ThreadGroup group = new ThreadGroup(\"parallel\");", "+        // start initial batch of threads", "+        for (int i = 0; i < maxRunning; ++i) {", "+            running[i] = runnables[threadNumber++];", "+            Thread thread =  new Thread(group, running[i]);", "+            thread.start();", "+        }", "+", "+        if (timeout != 0) {", "+            // start the timeout thread", "+            Thread timeoutThread = new Thread() {", "+                public synchronized void run() {", "+                    try {", "+                        wait(timeout);", "+                        synchronized(semaphore) {", "+                            stillRunning = false;", "+                            timedOut = true;", "+                            semaphore.notifyAll();", "+                        }", "+                    } catch (InterruptedException e) {", "+                        // ignore", "+                    }", "+                }", "+            };", "+            timeoutThread.start();", "+        }", "+", "+        // now find available running slots for the remaining threads", "-        while (threadNumber < numTasks) {", "+        while (threadNumber < numTasks && stillRunning) {", "-                    if (running[i] == null || !running[i].isAlive()) {", "-                        running[i] = threads[threadNumber++];", "-                        running[i].start();", "-                        // countinue on outer while loop in case we", "-                        // used our last thread", "+                    if (running[i] == null || running[i].finished) {", "+                        running[i] = runnables[threadNumber++];", "+                        Thread thread =  new Thread(group, running[i]);", "+                        thread.start();", "+                        // countinue on outer while loop to get another", "+                        // available slot", "-                // if we got here all are running, so sleep a little", "+", "+                // if we got here all slots in use, so sleep until", "+                // something happens", "-                    semaphore.wait(pollInterval);", "+                    semaphore.wait();", "-                    // just pretend it didn't happen and go aobut out business.", "+                    // just pretend it didn't happen and go about out business.", "-        // now join to all the threads", "-        for (int i = 0; i < maxRunning; ++i) {", "-            try {", "-                if (running[i] != null) {", "-                    running[i].join();", "+        synchronized(semaphore) {", "+            // are all threads finished", "+            outer2:", "+            while (stillRunning) {", "+                for (int i = 0; i < maxRunning; ++i) {", "+                    if (running[i] != null && !running[i].finished) {", "+                        //System.out.println(\"Thread \" + i + \" is still alive \");", "+                        // still running - wait for it", "+                        try {", "+                            semaphore.wait();", "+                        } catch (InterruptedException ie) {", "+                            // who would interrupt me at a time like this?", "+                        }", "+                        continue outer2;", "+                    }", "-            } catch (InterruptedException ie) {", "-                // who would interrupt me at a time like this?", "+                stillRunning = false;", "+        }", "+", "+        if (timedOut) {", "+            throw new BuildException(\"Parallel execution timed out\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f1ab042161fbf3303bebb2d295091080", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/FixCRLF.java", "commitBeforeChange": "14d7f3c9152c8c52501a5624e361a588f9e56367", "commitAfterChange": "6231c77d24ce79d308b50e46097851fa8dc63e93", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "     public void execute() throws BuildException", "signatureAfterChange": "     public void execute() throws BuildException", "diff": ["-            \" cr=\" + (addcr==-1 ? \"add\" : addcr==0 ? \"asis\" : \"remove\") +", "-            \" tab=\" + (addtab==-1 ? \"add\" : addtab==0 ? \"asis\" : \"remove\") +", "-            \" eof=\" + (ctrlz==-1 ? \"add\" : ctrlz==0 ? \"asis\" : \"remove\") +", "+            \" cr=\" + (addcr==1 ? \"add\" : addcr==0 ? \"asis\" : \"remove\") +", "+            \" tab=\" + (addtab==1 ? \"add\" : addtab==0 ? \"asis\" : \"remove\") +", "+            \" eof=\" + (ctrlz==1 ? \"add\" : ctrlz==0 ? \"asis\" : \"remove\") +", "+                // Determine whether it should be written,", "+                // that is if it is different than the potentially already existing file", "+                boolean write = false;", "+                byte[] existingdata = indata;", "-                if (destDir != null) destFile = new File(destDir, files[i]);", "-                FileOutputStream outStream = new FileOutputStream(destFile);", "-                outStream.write(outdata,0,o);", "-                outStream.close();", "+                if (destDir != null) {", "+                    destFile = new File(destDir, files[i]);", "+                    if(destFile.isFile()) {", "+                        int len = (int)destFile.length();", "+                        if(len != o) {", "+                            write = true;", "+                        } else {", "+                            existingdata = new byte[len];", "+                            try {", "+                                FileInputStream in = new FileInputStream(destFile);", "+                                in.read(existingdata);", "+                                in.close();", "+                            } catch (IOException e) {", "+                                throw new BuildException(e);", "+                            }", "+                        }", "+                    } else {", "+                        write = true;", "+                    }", "+                }", "+", "+                if(!write) {", "+                    if(existingdata.length != o) {", "+                        write = true;", "+                    } else {", "+                        for(int j = 0; j < o; ++j) {", "+                            if(existingdata[j] != outdata[j]) {", "+                                write = true;", "+                                break;", "+                            }", "+                        }", "+                    }", "+                }", "+", "+                if(write) {", "+                    log(destFile + \" is being written\", Project.MSG_VERBOSE);", "+                    FileOutputStream outStream = new FileOutputStream(destFile);", "+                    outStream.write(outdata,0,o);", "+                    outStream.close();", "+                } else {", "+                    log(destFile + \" is not written, as the contents are identical\",", "+                        Project.MSG_VERBOSE);", "+                }"]}]}