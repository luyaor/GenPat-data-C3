{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ae9e8c5e1f494cfb35956669ba856dd0", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a81011889f9afedeb6df39a10f94f28e", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/zip/ZipOutputStream.java", "commitBeforeChange": "aa43e37a025cdf54b8914b8283e57419a253ed59", "commitAfterChange": "dee95e3acc5154aee03ff5f91f9a56426ae79f3f", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": "     public void finish() throws IOException", "signatureAfterChange": "     public void finish() throws IOException", "diff": ["-        closeEntry();", "+        if (finished) {", "+            throw new IOException(\"This archive has already been finished\");", "+        }", "+", "+        if (entry != null) {", "+            closeEntry();", "+        }", "+", "-        for (Iterator i = entries.iterator(); i.hasNext(); ) {", "-            writeCentralFileHeader((ZipEntry) i.next());", "+        for (ZipEntry ze : entries) {", "+            writeCentralFileHeader(ze);", "+        writeZip64CentralDirectory();", "+        finished = true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d3f991b6b19aefa44d00320c556e860d", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Parallel.java", "commitBeforeChange": "9cd9731a6282f485db20727f539edf735533c19a", "commitAfterChange": "f1e7b4baf59161757ad5d81e6d7938b827ba36b0", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "     private void spinThreads() throws BuildException", "signatureAfterChange": "     private void spinThreads() throws BuildException", "diff": ["+        boolean interrupted = false;", "-            // now find available running slots for the remaining threads", "-            outer:", "-            while (threadNumber < numTasks && stillRunning) {", "-                for (int i = 0; i < maxRunning; i++) {", "-                    if (running[i] == null || running[i].isFinished()) {", "-                        running[i] = runnables[threadNumber++];", "-                        Thread thread =  new Thread(group, running[i]);", "-                        thread.start();", "-                        // continue on outer while loop to get another", "-                        // available slot", "-                        continue outer;", "-                    }", "-                }", "-", "-                // if we got here all slots in use, so sleep until", "-                // something happens", "-                try {", "-                    semaphore.wait();", "-                } catch (InterruptedException ie) {", "-                    // doesn't java know interruptions are rude?", "-                    // just pretend it didn't happen and go about out business.", "-                    // sheesh!", "-                }", "-            }", "-", "-            // are all threads finished", "-            outer2:", "-            while (stillRunning) {", "-                for (int i = 0; i < maxRunning; ++i) {", "-                    if (running[i] != null && !running[i].isFinished()) {", "-                        //System.out.println(\"Thread \" + i + \" is still alive \");", "-                        // still running - wait for it", "-                        try {", "-                            semaphore.wait();", "-                        } catch (InterruptedException ie) {", "-                            // who would interrupt me at a time like this?", "+            try {", "+                // now find available running slots for the remaining threads", "+                outer: while (threadNumber < numTasks && stillRunning) {", "+                    for (int i = 0; i < maxRunning; i++) {", "+                        if (running[i] == null || running[i].isFinished()) {", "+                            running[i] = runnables[threadNumber++];", "+                            Thread thread = new Thread(group, running[i]);", "+                            thread.start();", "+                            // continue on outer while loop to get another", "+                            // available slot", "+                            continue outer;", "-                        continue outer2;", "+", "+                    // if we got here all slots in use, so sleep until", "+                    // something happens", "+                    semaphore.wait();", "-                stillRunning = false;", "+", "+                // are all threads finished", "+                outer2: while (stillRunning) {", "+                    for (int i = 0; i < maxRunning; ++i) {", "+                        if (running[i] != null && !running[i].isFinished()) {", "+                            // System.out.println(\"Thread \" + i + \" is still", "+                            // alive \");", "+                            // still running - wait for it", "+                            semaphore.wait();", "+                            continue outer2;", "+                        }", "+                    }", "+                    stillRunning = false;", "+                }", "+            } catch (InterruptedException ie) {", "+                interrupted = true;", "+", "+            killAll(running);", "+        if (interrupted){", "+            throw new BuildException(\"Parallel execution interrupted.\");", "+        }", "+    }"]}]}