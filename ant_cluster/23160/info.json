{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "990a4436dd25435c6431bb9ed9da181f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1a7e2941f076380f9d86b4570233a5be", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Parallel.java", "commitBeforeChange": "2590a640ce546d8fdce8dc864f929b53e6bb1138", "commitAfterChange": "89847cdf7d0bfd13dc1431e1e7128ea587550c4b", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 8, "signatureBeforeChange": "     private void spinThreads() throws BuildException", "signatureAfterChange": "     private void spinThreads() throws BuildException", "diff": ["-        Thread[] threads = new Thread[numTasks];", "+        stillRunning = true;", "+        timedOut = false;", "+", "-            ThreadGroup group = new ThreadGroup(\"parallel\");", "-            TaskRunnable taskRunnable", "+            runnables[threadNumber]", "-            runnables[threadNumber] = taskRunnable;", "-            threads[threadNumber] = new Thread(group, taskRunnable);", "-        final int maxRunning = numThreads;", "-        Thread[] running = new Thread[maxRunning];", "+        final int maxRunning = numTasks < numThreads ? numTasks : numThreads;", "+        TaskRunnable[] running = new TaskRunnable[maxRunning];", "+", "+        ThreadGroup group = new ThreadGroup(\"parallel\");", "+        // start initial batch of threads", "+        for (int i = 0; i < maxRunning; ++i) {", "+            running[i] = runnables[threadNumber++];", "+            Thread thread =  new Thread(group, running[i]);", "+            thread.start();", "+        }", "+", "+        if (timeout != 0) {", "+            // start the timeout thread", "+            Thread timeoutThread = new Thread() {", "+                public synchronized void run() {", "+                    try {", "+                        wait(timeout);", "+                        synchronized(semaphore) {", "+                            stillRunning = false;", "+                            timedOut = true;", "+                            semaphore.notifyAll();", "+                        }", "+                    } catch (InterruptedException e) {", "+                        // ignore", "+                    }", "+                }", "+            };", "+            timeoutThread.start();", "+        }", "+", "+        // now find available running slots for the remaining threads", "-        while (threadNumber < numTasks) {", "+        while (threadNumber < numTasks && stillRunning) {", "-                    if (running[i] == null || !running[i].isAlive()) {", "-                        running[i] = threads[threadNumber++];", "-                        running[i].start();", "-                        // countinue on outer while loop in case we", "-                        // used our last thread", "+                    if (running[i] == null || running[i].finished) {", "+                        running[i] = runnables[threadNumber++];", "+                        Thread thread =  new Thread(group, running[i]);", "+                        thread.start();", "+                        // countinue on outer while loop to get another", "+                        // available slot", "-                // if we got here all are running, so sleep a little", "+", "+                // if we got here all slots in use, so sleep until", "+                // something happens", "-                    semaphore.wait(pollInterval);", "+                    semaphore.wait();", "-                    // just pretend it didn't happen and go aobut out business.", "+                    // just pretend it didn't happen and go about out business.", "-        // now join to all the threads", "-        for (int i = 0; i < maxRunning; ++i) {", "-            try {", "-                if (running[i] != null) {", "-                    running[i].join();", "+        synchronized(semaphore) {", "+            // are all threads finished", "+            outer2:", "+            while (stillRunning) {", "+                for (int i = 0; i < maxRunning; ++i) {", "+                    if (running[i] != null && !running[i].finished) {", "+                        //System.out.println(\"Thread \" + i + \" is still alive \");", "+                        // still running - wait for it", "+                        try {", "+                            semaphore.wait();", "+                        } catch (InterruptedException ie) {", "+                            // who would interrupt me at a time like this?", "+                        }", "+                        continue outer2;", "+                    }", "-            } catch (InterruptedException ie) {", "-                // who would interrupt me at a time like this?", "+                stillRunning = false;", "+        }", "+", "+        if (timedOut) {", "+            throw new BuildException(\"Parallel execution timed out\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d3f991b6b19aefa44d00320c556e860d", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Parallel.java", "commitBeforeChange": "9cd9731a6282f485db20727f539edf735533c19a", "commitAfterChange": "f1e7b4baf59161757ad5d81e6d7938b827ba36b0", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "     private void spinThreads() throws BuildException", "signatureAfterChange": "     private void spinThreads() throws BuildException", "diff": ["+        boolean interrupted = false;", "-            // now find available running slots for the remaining threads", "-            outer:", "-            while (threadNumber < numTasks && stillRunning) {", "-                for (int i = 0; i < maxRunning; i++) {", "-                    if (running[i] == null || running[i].isFinished()) {", "-                        running[i] = runnables[threadNumber++];", "-                        Thread thread =  new Thread(group, running[i]);", "-                        thread.start();", "-                        // continue on outer while loop to get another", "-                        // available slot", "-                        continue outer;", "-                    }", "-                }", "-", "-                // if we got here all slots in use, so sleep until", "-                // something happens", "-                try {", "-                    semaphore.wait();", "-                } catch (InterruptedException ie) {", "-                    // doesn't java know interruptions are rude?", "-                    // just pretend it didn't happen and go about out business.", "-                    // sheesh!", "-                }", "-            }", "-", "-            // are all threads finished", "-            outer2:", "-            while (stillRunning) {", "-                for (int i = 0; i < maxRunning; ++i) {", "-                    if (running[i] != null && !running[i].isFinished()) {", "-                        //System.out.println(\"Thread \" + i + \" is still alive \");", "-                        // still running - wait for it", "-                        try {", "-                            semaphore.wait();", "-                        } catch (InterruptedException ie) {", "-                            // who would interrupt me at a time like this?", "+            try {", "+                // now find available running slots for the remaining threads", "+                outer: while (threadNumber < numTasks && stillRunning) {", "+                    for (int i = 0; i < maxRunning; i++) {", "+                        if (running[i] == null || running[i].isFinished()) {", "+                            running[i] = runnables[threadNumber++];", "+                            Thread thread = new Thread(group, running[i]);", "+                            thread.start();", "+                            // continue on outer while loop to get another", "+                            // available slot", "+                            continue outer;", "-                        continue outer2;", "+", "+                    // if we got here all slots in use, so sleep until", "+                    // something happens", "+                    semaphore.wait();", "-                stillRunning = false;", "+", "+                // are all threads finished", "+                outer2: while (stillRunning) {", "+                    for (int i = 0; i < maxRunning; ++i) {", "+                        if (running[i] != null && !running[i].isFinished()) {", "+                            // System.out.println(\"Thread \" + i + \" is still", "+                            // alive \");", "+                            // still running - wait for it", "+                            semaphore.wait();", "+                            continue outer2;", "+                        }", "+                    }", "+                    stillRunning = false;", "+                }", "+            } catch (InterruptedException ie) {", "+                interrupted = true;", "+", "+            killAll(running);", "+        if (interrupted){", "+            throw new BuildException(\"Parallel execution interrupted.\");", "+        }", "+    }"]}]}