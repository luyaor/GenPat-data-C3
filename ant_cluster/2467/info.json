{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ca65f870ca1a4363ea46f031bcbdb4ae", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "97356737940aa3cc89a85ae725f759af", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/IntrospectionHelper.java", "commitBeforeChange": "0efc2f817257f69d7cdc67c016b1caac68465f1d", "commitAfterChange": "939a6bbf2fb97ec29ecf79c86013846656d8751c", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "     private AttributeSetter createAttributeSetter(final Method m,                                                   Class arg,                                                   final String attrName)", "signatureAfterChange": "     private AttributeSetter createAttributeSetter(final Method m,                                                   Class arg,                                                   final String attrName)", "diff": ["-                    m.invoke(parent, (Object[]) (new String[] {value}));", "+                    m.invoke(parent, (Object[]) new String[] { value });", "+        }", "-        } else if (java.lang.Character.class.equals(reflectedArg)) {", "+        if (java.lang.Character.class.equals(reflectedArg)) {", "-                            + \"legal value for attribute \\\"\" + attrName + \"\\\"\");", "+                                + \"legal value for attribute \\\"\" + attrName + \"\\\"\");", "-                    m.invoke(parent, (Object[])", "-                        (new Character[] {new Character(value.charAt(0))}));", "+                    m.invoke(parent, (Object[]) new Character[] { new Character(value.charAt(0)) });", "-        // boolean and Boolean get special treatment because we", "-        // have a nice method in Project", "-        } else if (java.lang.Boolean.class.equals(reflectedArg)) {", "+        }", "+        // boolean and Boolean get special treatment because we have a nice method in Project", "+        if (java.lang.Boolean.class.equals(reflectedArg)) {", "-                    m.invoke(parent, (Object[]) (", "-                         new Boolean[] {Project.toBoolean(value)", "-                                        ? Boolean.TRUE : Boolean.FALSE}));", "+                    m.invoke(parent, (Object[]) new Boolean[] {", "+                            Project.toBoolean(value) ? Boolean.TRUE : Boolean.FALSE });", "+        }", "-        } else if (java.lang.Class.class.equals(reflectedArg)) {", "+        if (java.lang.Class.class.equals(reflectedArg)) {", "-                        m.invoke(parent, new Object[] {Class.forName(value)});", "+                        m.invoke(parent, new Object[] { Class.forName(value) });", "+        }", "-        } else if (java.io.File.class.equals(reflectedArg)) {", "+        if (java.io.File.class.equals(reflectedArg)) {", "-                    m.invoke(parent, new Object[] {p.resolveFile(value)});", "+                    m.invoke(parent, new Object[] { p.resolveFile(value) });", "+        }", "-        } else if (EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {", "+        if (EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {", "-                        EnumeratedAttribute ea =", "-                            (EnumeratedAttribute) reflectedArg.newInstance();", "+                        EnumeratedAttribute ea = (EnumeratedAttribute) reflectedArg.newInstance();", "-                        m.invoke(parent, new Object[] {ea});", "+                        m.invoke(parent, new Object[] { ea });", "-        } else if (reflectedArg.getSuperclass() != null", "-                   && reflectedArg.getSuperclass().getName().equals(\"java.lang.Enum\")) {", "+        }", "+        Class enumClass = null;", "+        try {", "+            enumClass = Class.forName(\"java.lang.Enum\");", "+        } catch (ClassNotFoundException e) {", "+            //ignore", "+        }", "+        if (enumClass != null && enumClass.isAssignableFrom(reflectedArg)) {", "-                            throw new BuildException(", "-                                \"'\" + value + \"' is not a permitted value for \"", "-                                + reflectedArg.getName());", "-                        } else {", "-                            //only if the exception is not an IllegalArgument, do we hand off", "-                            //to extractBuildException() to get the buildexception from the InvocationTarget", "-                            throw extractBuildException(x);", "+                            throw new BuildException(\"'\" + value + \"' is not a permitted value for \"", "+                                    + reflectedArg.getName());", "+                        //only if the exception is not an IllegalArgument do we request the", "+                        //BuildException via extractBuildException():", "+                        throw extractBuildException(x);", "-        } else if (java.lang.Long.class.equals(reflectedArg)) {", "+        }", "+        if (java.lang.Long.class.equals(reflectedArg)) {", "-                    long ell;", "-                        ell = StringUtils.parseHumanSizes(value);", "+                        m.invoke(parent, new Object[] {", "+                                new Long(StringUtils.parseHumanSizes(value)) });", "+                    } catch (InvocationTargetException e) {", "+                        throw e;", "+                    } catch (IllegalAccessException e) {", "+                        throw e;", "-                    }", "-                    m.invoke(parent, new Object[] { new Long(ell) });", "-                }", "-            };", "-        } else {", "-        // worst case. look for a public String constructor and use it", "-        // also supports new Whatever(Project, String) as for Path or Reference", "-        // This is used (deliberately) for all primitives/wrappers other than", "-        // char, boolean, and long.", "-            boolean includeProject;", "-            Constructor c;", "-            try {", "-                // First try with Project.", "-                c = reflectedArg.getConstructor(new Class[] {Project.class, String.class});", "-                includeProject = true;", "-            } catch (NoSuchMethodException nme) {", "-                // OK, try without.", "-                try {", "-                    c = reflectedArg.getConstructor(new Class[] {String.class});", "-                    includeProject = false;", "-                } catch (NoSuchMethodException nme2) {", "-                    // Well, no matching constructor.", "-                    return null;", "-                }", "-            }", "-            final boolean finalIncludeProject = includeProject;", "-            final Constructor finalConstructor = c;", "-", "-            return new AttributeSetter(m) {", "-                public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException, BuildException {", "-                    try {", "-                        Object[] args = (finalIncludeProject)", "-                            ? new Object[] {p, value} : new Object[] {value};", "-", "-                        Object attribute = finalConstructor.newInstance(args);", "-                        if (p != null) {", "-                            p.setProjectReference(attribute);", "-                        }", "-                        m.invoke(parent, new Object[] {attribute});", "-                    } catch (InstantiationException ie) {", "-                        throw new BuildException(ie);", "+        // worst case. look for a public String constructor and use it", "+        // also supports new Whatever(Project, String) as for Path or Reference", "+        // This is used (deliberately) for all primitives/wrappers other than", "+        // char, boolean, and long.", "+        boolean includeProject;", "+        Constructor c;", "+        try {", "+            // First try with Project.", "+            c = reflectedArg.getConstructor(new Class[] {Project.class, String.class});", "+            includeProject = true;", "+        } catch (NoSuchMethodException nme) {", "+            // OK, try without.", "+            try {", "+                c = reflectedArg.getConstructor(new Class[] {String.class});", "+                includeProject = false;", "+            } catch (NoSuchMethodException nme2) {", "+                // Well, no matching constructor.", "+                return null;", "+            }", "+        }", "+        final boolean finalIncludeProject = includeProject;", "+        final Constructor finalConstructor = c;", "+", "+        return new AttributeSetter(m) {", "+            public void set(Project p, Object parent, String value)", "+                    throws InvocationTargetException, IllegalAccessException, BuildException {", "+                try {", "+                    Object[] args = finalIncludeProject", "+                            ? new Object[] {p, value} : new Object[] {value};", "+", "+                    Object attribute = finalConstructor.newInstance(args);", "+                    if (p != null) {", "+                        p.setProjectReference(attribute);", "+                    }", "+                    m.invoke(parent, new Object[] {attribute});", "+                } catch (InstantiationException ie) {", "+                    throw new BuildException(ie);", "+                }", "+            }", "+        };"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c1f1cf81eed054da90a5e14fa032951e", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/mutant/src/java/antcore/org/apache/ant/antcore/execution/Frame.java", "commitBeforeChange": "65b70febb53b077317c4d678291f9af547c3d116", "commitAfterChange": "f9d1c1691c7e9d80b793f5178f6113c949fc2441", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 45, "signatureBeforeChange": "     protected void initialize() throws ExecutionException", "signatureAfterChange": "     public void startBuild(List targets) throws AntException", "diff": ["-    protected void initialize() throws ExecutionException {", "-        configureServices();", "-        setMagicProperties();", "-        determineBaseDir();", "+    public void startBuild(List targets) throws AntException {", "+        eventSupport.fireBuildStarted(project);", "-        try {        ", "+        Throwable buildFailureCause = null;", "+        try {", "-            URL systemLibs ", "+            URL systemLibs", "-            componentManager.loadLib(systemLibs.toString(), true, true);", "-            ", "-            // execute any config tasks", "-            executeTasks(config.getTasks());", "-    ", "+            componentManager.loadLib(systemLibs, true);", "+", "+            executeTasks(config.getGlobalTasks());", "+", "-            componentManager.loadLib(antLibs.toString(), false, true);", "-            ", "-            executeTasks(project.getTasks());", "+            componentManager.loadLib(antLibs, false);", "+", "+", "+        try {", "+            runBuild(targets);", "+        } catch (RuntimeException e) {", "+            buildFailureCause = e;", "+            throw e;", "+        } catch (AntException e) {", "+            buildFailureCause = e;", "+            throw e;", "+        } finally {", "+            eventSupport.fireBuildFinished(project, buildFailureCause);", "+        }", "+    }"]}]}