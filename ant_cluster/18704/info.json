{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "feff1172c30ee38fd57e2213a378615d", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "81fb7a98aa933b864210db1ee1149b03", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/tests/junit/org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskTest.java", "commitBeforeChange": "7eab7687db21f8a0c35b66dd9fae9e7c1178d5d5", "commitAfterChange": "b61c80746dd5df73899390826e197d2656784f91", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 9, "signatureBeforeChange": "     public void testFailureRecorder()", "signatureAfterChange": "     @Test     public void testFailureRecorder()", "diff": ["+    @Test", "-                Class.forName(\"junit.framework.JUnit4TestAdapter\");", "-                System.err.println(\"skipping tests since it fails when\"", "-                                   + \" using JUnit 4\");", "-                return;", "+            \tClass<?> clazz =Class.forName(\"junit.framework.JUnit4TestAdapter\");", "+                Assume.assumeFalse(\"Skipping test since it fails with JUnit 4\", clazz != null);", "-        try {", "-            File testDir = new File(getOutputDir(), \"out\");", "-            File collectorFile = new File(getOutputDir(),", "-                                          \"out/FailedTests.java\");", "-        ", "-            // ensure that there is a clean test environment", "-            assertFalse(\"Test directory '\" + testDir.getAbsolutePath()", "-                        + \"' must not exist before the test preparation.\", ", "-                        testDir.exists());", "-            assertFalse(\"The collector file '\"", "-                        + collectorFile.getAbsolutePath()", "-                        + \"'must not exist before the test preparation.\", ", "-                        collectorFile.exists());", "+        File testDir = new File(buildRule.getOutputDir(), \"out\");", "+        File collectorFile = new File(buildRule.getOutputDir(),", "+                \"out/FailedTests.java\");", "-        ", "-            // prepare the test environment", "-            executeTarget(\"failureRecorder.prepare\");", "-            assertTrue(\"Test directory '\" + testDir.getAbsolutePath()", "-                       + \"' was not created.\", testDir.exists());", "-            assertTrue(\"There should be one class.\",", "-                       (new File(testDir, \"A.class\")).exists());", "-            assertFalse(\"The collector file '\"", "-                        + collectorFile.getAbsolutePath() ", "-                        + \"' should not exist before the 1st run.\",", "-                        collectorFile.exists());", "-        ", "-        ", "-            // 1st junit run: should do all tests - failing and not failing tests", "-            executeTarget(\"failureRecorder.runtest\");", "-            assertTrue(\"The collector file '\" + collectorFile.getAbsolutePath() ", "-                       + \"' should exist after the 1st run.\",", "-                       collectorFile.exists());", "-            // the passing test cases", "-            assertOutputContaining(\"1st run: should run A.test01\", \"A.test01\");", "-            assertOutputContaining(\"1st run: should run B.test05\", \"B.test05\");", "-            assertOutputContaining(\"1st run: should run B.test06\", \"B.test06\");", "-            assertOutputContaining(\"1st run: should run C.test07\", \"C.test07\");", "-            assertOutputContaining(\"1st run: should run C.test08\", \"C.test08\");", "-            assertOutputContaining(\"1st run: should run C.test09\", \"C.test09\");", "-            // the failing test cases", "-            assertOutputContaining(\"1st run: should run A.test02\", \"A.test02\");", "-            assertOutputContaining(\"1st run: should run A.test03\", \"A.test03\");", "-            assertOutputContaining(\"1st run: should run B.test04\", \"B.test04\");", "-            assertOutputContaining(\"1st run: should run D.test10\", \"D.test10\");", "+        // ensure that there is a clean test environment", "+        assertFalse(\"Test directory '\" + testDir.getAbsolutePath()", "+                    + \"' must not exist before the test preparation.\", ", "+                    testDir.exists());", "+        assertFalse(\"The collector file '\"", "+                    + collectorFile.getAbsolutePath()", "+                    + \"'must not exist before the test preparation.\", ", "+                    collectorFile.exists());", "-        ", "-            // 2nd junit run: should do only failing tests", "-            executeTarget(\"failureRecorder.runtest\");", "-            assertTrue(\"The collector file '\" + collectorFile.getAbsolutePath() ", "-                       + \"' should exist after the 2nd run.\",", "-                       collectorFile.exists());", "-            // the passing test cases", "-            assertOutputNotContaining(\"2nd run: should not run A.test01\",", "-                                      \"A.test01\");", "-            assertOutputNotContaining(\"2nd run: should not run A.test05\",", "-                                      \"B.test05\");", "-            assertOutputNotContaining(\"2nd run: should not run B.test06\",", "-                                      \"B.test06\");", "-            assertOutputNotContaining(\"2nd run: should not run C.test07\",", "-                                      \"C.test07\");", "-            assertOutputNotContaining(\"2nd run: should not run C.test08\",", "-                                      \"C.test08\");", "-            assertOutputNotContaining(\"2nd run: should not run C.test09\",", "-                                      \"C.test09\");", "-            // the failing test cases", "-            assertOutputContaining(\"2nd run: should run A.test02\", \"A.test02\");", "-            assertOutputContaining(\"2nd run: should run A.test03\", \"A.test03\");", "-            assertOutputContaining(\"2nd run: should run B.test04\", \"B.test04\");", "-            assertOutputContaining(\"2nd run: should run D.test10\", \"D.test10\");", "-        ", "-        ", "-            // \"fix\" errors in class A", "-            executeTarget(\"failureRecorder.fixing\");", "-        ", "-            // 3rd run: four running tests with two errors", "-            executeTarget(\"failureRecorder.runtest\");", "-            assertTrue(\"The collector file '\" + collectorFile.getAbsolutePath() ", "-                       + \"' should exist after the 3rd run.\",", "-                       collectorFile.exists());", "-            assertOutputContaining(\"3rd run: should run A.test02\", \"A.test02\");", "-            assertOutputContaining(\"3rd run: should run A.test03\", \"A.test03\");", "-            assertOutputContaining(\"3rd run: should run B.test04\", \"B.test04\");", "-            assertOutputContaining(\"3rd run: should run D.test10\", \"D.test10\");", "-        ", "-        ", "-            // 4rd run: two running tests with errors", "-            executeTarget(\"failureRecorder.runtest\");", "-            assertTrue(\"The collector file '\" + collectorFile.getAbsolutePath() ", "-                       + \"' should exist after the 4th run.\",", "-                       collectorFile.exists());", "-            //TODO: these two statements fail", "-            //assertOutputNotContaining(\"4th run: should not run A.test02\", \"A.test02\");", "-            //assertOutputNotContaining(\"4th run: should not run A.test03\", \"A.test03\");", "-            assertOutputContaining(\"4th run: should run B.test04\", \"B.test04\");", "-            assertOutputContaining(\"4th run: should run D.test10\", \"D.test10\");", "-        } catch (BuildException be) {", "-            be.printStackTrace();", "-            System.err.println(\"nested build's log: \" + getLog());", "-            System.err.println(\"nested build's System.out: \" + getOutput());", "-            System.err.println(\"nested build's System.err: \" + getError());", "-            fail(\"Ant execution failed: \" + be.getMessage());", "-        }", "+    ", "+        // prepare the test environment", "+        buildRule.executeTarget(\"failureRecorder.prepare\");", "+        assertTrue(\"Test directory '\" + testDir.getAbsolutePath()", "+                   + \"' was not created.\", testDir.exists());", "+        assertTrue(\"There should be one class.\",", "+                   (new File(testDir, \"A.class\")).exists());", "+        assertFalse(\"The collector file '\"", "+                    + collectorFile.getAbsolutePath() ", "+                    + \"' should not exist before the 1st run.\",", "+                    collectorFile.exists());", "+    ", "+    ", "+        // 1st junit run: should do all tests - failing and not failing tests", "+        buildRule.executeTarget(\"failureRecorder.runtest\");", "+        assertTrue(\"The collector file '\" + collectorFile.getAbsolutePath() ", "+                   + \"' should exist after the 1st run.\",", "+                   collectorFile.exists());", "+        // the passing test cases", "+        buildRule.executeTarget(\"A.test01\");", "+        assertContains(\"1st run: should run A.test01\", buildRule.getOutput());", "+        buildRule.executeTarget(\"B.test05\");", "+        assertContains(\"1st run: should run B.test05\", buildRule.getOutput());", "+        buildRule.executeTarget(\"B.test06\");", "+        assertContains(\"1st run: should run B.test06\", buildRule.getOutput());", "+        buildRule.executeTarget(\"C.test07\");", "+        assertContains(\"1st run: should run C.test07\", buildRule.getOutput());", "+        buildRule.executeTarget(\"C.test08\");", "+        assertContains(\"1st run: should run C.test08\", buildRule.getOutput());", "+        buildRule.executeTarget(\"C.test09\");", "+        assertContains(\"1st run: should run C.test09\", buildRule.getOutput());", "+        // the failing test cases", "+        buildRule.executeTarget(\"A.test02\");", "+        assertContains(\"1st run: should run A.test02\", buildRule.getOutput());", "+        buildRule.executeTarget(\"A.test03\");", "+        assertContains(\"1st run: should run A.test03\", buildRule.getOutput());", "+        buildRule.executeTarget(\"B.test04\");", "+        assertContains(\"1st run: should run B.test04\", buildRule.getOutput());", "+        buildRule.executeTarget(\"D.test10\");", "+        assertContains(\"1st run: should run D.test10\", buildRule.getOutput());", "+", "+    ", "+        // 2nd junit run: should do only failing tests", "+        buildRule.executeTarget(\"failureRecorder.runtest\");", "+        assertTrue(\"The collector file '\" + collectorFile.getAbsolutePath() ", "+                   + \"' should exist after the 2nd run.\",", "+                   collectorFile.exists());", "+        // the passing test cases", "+        buildRule.executeTarget(\"A.test01\");", "+        assertNotContains(\"2nd run: should not run A.test01\", buildRule.getOutput());", "+        buildRule.executeTarget(\"B.test05\");", "+        assertNotContains(\"2nd run: should not run A.test05\", buildRule.getOutput());", "+        buildRule.executeTarget(\"B.test06\");", "+        assertNotContains(\"2nd run: should not run B.test06\", buildRule.getOutput());", "+        buildRule.executeTarget(\"C.test07\");", "+        assertNotContains(\"2nd run: should not run C.test07\", buildRule.getOutput());", "+        buildRule.executeTarget(\"C.test08\");", "+        assertNotContains(\"2nd run: should not run C.test08\", buildRule.getOutput());", "+        buildRule.executeTarget(\"C.test09\");", "+        assertNotContains(\"2nd run: should not run C.test09\", buildRule.getOutput());", "+        // the failing test cases", "+        buildRule.executeTarget(\"A.test02\");", "+        assertContains(\"2nd run: should run A.test02\", buildRule.getOutput());", "+        buildRule.executeTarget(\"A.test03\");", "+        assertContains(\"2nd run: should run A.test03\", buildRule.getOutput());", "+        buildRule.executeTarget(\"B.test04\");", "+        assertContains(\"2nd run: should run B.test04\", buildRule.getOutput());", "+        buildRule.executeTarget(\"D.test10\");", "+        assertContains(\"2nd run: should run D.test10\", buildRule.getOutput());", "+    ", "+    ", "+        // \"fix\" errors in class A", "+        buildRule.executeTarget(\"failureRecorder.fixing\");", "+    ", "+        // 3rd run: four running tests with two errors", "+        buildRule.executeTarget(\"failureRecorder.runtest\");", "+        assertTrue(\"The collector file '\" + collectorFile.getAbsolutePath() ", "+                   + \"' should exist after the 3rd run.\",", "+                   collectorFile.exists());", "+        buildRule.executeTarget(\"A.test02\");", "+        assertContains(\"3rd run: should run A.test02\", buildRule.getOutput());", "+        buildRule.executeTarget(\"A.test03\");", "+        assertContains(\"3rd run: should run A.test03\", buildRule.getOutput());", "+        buildRule.executeTarget(\"B.test04\");", "+        assertContains(\"3rd run: should run B.test04\", buildRule.getOutput());", "+        buildRule.executeTarget(\"D.test10\");", "+        assertContains(\"3rd run: should run D.test10\", buildRule.getOutput());", "+    ", "+    ", "+        // 4rd run: two running tests with errors", "+        buildRule.executeTarget(\"failureRecorder.runtest\");", "+        assertTrue(\"The collector file '\" + collectorFile.getAbsolutePath() ", "+                   + \"' should exist after the 4th run.\",", "+                   collectorFile.exists());", "+        //TODO: these two statements fail", "+        //buildRule.executeTarget(\"A.test02\");assertNotContains(\"4th run: should not run A.test02\", buildRule.getOutput());", "+        //buildRule.executeTarget(\"A.test03\");assertNotContains(\"4th run: should not run A.test03\", buildRule.getOutput());", "+        buildRule.executeTarget(\"B.test04\");", "+        assertContains(\"4th run: should run B.test04\", buildRule.getOutput());", "+        buildRule.executeTarget(\"D.test10\");", "+        assertContains(\"4th run: should run D.test10\", buildRule.getOutput());", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b8b269395291c016f42d46c630a615a7", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/PropertyFile.java", "commitBeforeChange": "334ac128fea4c6e8e76c7c8af8061a47b5019bf4", "commitAfterChange": "ba37bf7991e099b567f8cd5a09178893ff55bb9c", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 17, "signatureBeforeChange": "         private void executeDate(String oldValue) throws BuildException", "signatureAfterChange": "         private void executeDate(String oldValue) throws BuildException", "diff": ["-        private void executeDate(String oldValue) throws BuildException ", "+        private void executeDate(String oldValue) throws BuildException", "-            StringBuffer dateString = new StringBuffer();", "+            GregorianCalendar value = new GregorianCalendar();", "+            GregorianCalendar newValue = new GregorianCalendar();", "-            // If value is defined then interpret what's given", "-            if (m_operation.equals(NULL_VALUE)) ", "-            {", "-                m_dateValue = null;", "-            }", "-            else ", "-            {", "-                Date now = new Date();", "-                m_dateValue.setTime(now);", "-                dateString.append(m_dateValue.get(Calendar.YEAR));", "-                dateString.append(\"/\");", "-                dateString.append((m_dateValue.get(Calendar.MONTH)+1 < 10) ? \"0\" : \"\");", "-                dateString.append(m_dateValue.get(Calendar.MONTH)+1);", "-                dateString.append(\"/\");", "-                dateString.append((m_dateValue.get(Calendar.DATE) < 10) ? \"0\" : \"\");", "-                dateString.append(m_dateValue.get(Calendar.DATE));", "-                dateString.append(\" \");", "-                dateString.append((m_dateValue.get(Calendar.HOUR_OF_DAY) < 10) ? \"0\" : \"\");", "-                dateString.append(m_dateValue.get(Calendar.HOUR_OF_DAY));", "-                dateString.append(\":\");", "-                dateString.append((m_dateValue.get(Calendar.MINUTE) < 10) ? \"0\" : \"\");", "-                dateString.append(m_dateValue.get(Calendar.MINUTE));", "-                m_value = dateString.toString();", "+            if (m_pattern == null) m_pattern = \"yyyy/MM/dd HH:mm\";", "+            DateFormat fmt = new SimpleDateFormat(m_pattern);", "+", "+            if (m_value != null) {", "+                if (NOW_VALUE_.equals(m_value.toLowerCase())) {", "+                    value.setTime(new Date());", "+                }", "+                else if (NULL_VALUE_.equals(m_value.toLowerCase())) {", "+                    value = null;", "+                }", "+                else {", "+                    try {", "+                        value.setTime(fmt.parse(m_value));", "+                    }", "+                    catch (Exception ex) {", "+                        // obviously not a date, try a simple int", "+                        try {", "+                            int offset = Integer.parseInt(m_value);", "+                            value.clear();", "+                            value.set(Calendar.DAY_OF_YEAR, offset);", "+                        }", "+                        catch (Exception ex_) {", "+                            value.clear();", "+                            value.set(Calendar.DAY_OF_YEAR, 1);", "+                        }", "+                    }", "+", "+                }", "-            m_value = dateString.toString();", "+            // special case", "+            if (m_default != null &&", "+                NOW_VALUE_.equals(m_default.toLowerCase()) &&", "+                (m_operation == Operation.INCREMENT_OPER ||", "+                 m_operation == Operation.DECREMENT_OPER) ) {", "+                oldValue = null;", "+            }", "+", "+            if (oldValue != null) {", "+                try {", "+                    newValue.setTime(fmt.parse(oldValue));", "+                }", "+                catch (ParseException pe)  { /* swollow */ }", "+            }", "+            else {", "+                if (m_default != null) {", "+                    if (NOW_VALUE_.equals(m_default.toLowerCase())) {", "+                        newValue.setTime(new Date());", "+                    }", "+                    else if (NULL_VALUE_.equals(m_default.toLowerCase())) {", "+                        newValue = null;", "+                    }", "+                    else {", "+                        try {", "+                            newValue.setTime(fmt.parse(m_default));", "+                        }", "+                        catch (ParseException pe)  { /* swollow */ }", "+                    }", "+                }", "+            }", "+", "+            if (m_operation == Operation.EQUALS_OPER) {", "+                newValue = value;", "+            }", "+            else if (m_operation == Operation.INCREMENT_OPER) {", "+                newValue.add(Calendar.SECOND, value.get(Calendar.SECOND));", "+                newValue.add(Calendar.MINUTE, value.get(Calendar.MINUTE));", "+                newValue.add(Calendar.HOUR_OF_DAY, value.get(Calendar.HOUR_OF_DAY));", "+                newValue.add(Calendar.DAY_OF_YEAR, value.get(Calendar.DAY_OF_YEAR));", "+            }", "+            else if (m_operation == Operation.DECREMENT_OPER) {", "+                newValue.add(Calendar.SECOND, -1 * value.get(Calendar.SECOND));", "+                newValue.add(Calendar.MINUTE, -1 * value.get(Calendar.MINUTE));", "+                newValue.add(Calendar.HOUR_OF_DAY, -1 * value.get(Calendar.HOUR_OF_DAY));", "+                newValue.add(Calendar.DAY_OF_YEAR, -1 * value.get(Calendar.DAY_OF_YEAR));", "+            }", "+            if (newValue != null) {", "+                m_value = fmt.format(newValue.getTime());", "+            }", "+            else {", "+                m_value = \"\";", "+            }"]}]}