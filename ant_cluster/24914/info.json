{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a545389ee98d4993d800800403ecf2fd", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "13f271a92737dfc86ecebb8944aa102a", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/DirectoryScanner.java", "commitBeforeChange": "8b162d567dc13b9ae576422744854684a6c3ceb1", "commitAfterChange": "6c7f485943c930bf2de75288e47c4bf27c63b50a", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "     public void scan() throws IllegalStateException", "signatureAfterChange": "     public void scan() throws IllegalStateException", "diff": ["-        if (basedir == null) {", "-            throw new IllegalStateException(\"No basedir set\");", "-        }", "-        if (!basedir.exists()) {", "-            throw new IllegalStateException(\"basedir \" + basedir", "-                                            + \" does not exist\");", "-        }", "-        if (!basedir.isDirectory()) {", "-            throw new IllegalStateException(\"basedir \" + basedir", "-                                            + \" is not a directory\");", "-        }", "-", "-        if (includes == null) {", "-            // No includes supplied, so set it to 'matches all'", "-            includes = new String[1];", "-            includes[0] = \"**\";", "-        }", "-        if (excludes == null) {", "-            excludes = new String[0];", "-        }", "-", "-        filesIncluded    = new Vector();", "-        filesNotIncluded = new Vector();", "-        filesExcluded    = new Vector();", "-        filesDeselected  = new Vector();", "-        dirsIncluded     = new Vector();", "-        dirsNotIncluded  = new Vector();", "-        dirsExcluded     = new Vector();", "-        dirsDeselected   = new Vector();", "-", "-        if (isIncluded(\"\")) {", "-            if (!isExcluded(\"\")) {", "-                if (isSelected(\"\", basedir)) {", "-                    dirsIncluded.addElement(\"\");", "-                } else {", "-                    dirsDeselected.addElement(\"\");", "+        synchronized (scanLock) {", "+            if (scanning) {", "+                while (scanning) {", "+                    try {", "+                        scanLock.wait();", "+                    } catch (InterruptedException e) {", "+                        continue;", "+                    }", "-            } else {", "-                dirsExcluded.addElement(\"\");", "+                if (illegal != null) {", "+                    throw illegal;", "+                }", "+                return;", "-        } else {", "-            dirsNotIncluded.addElement(\"\");", "+            scanning = true;", "-        checkIncludePatterns();", "-        clearCaches();", "+        try {", "+            synchronized (this) {", "+                illegal = null;", "+                clearResults();", "+", "+                // set in/excludes to reasonable defaults if needed:", "+                boolean nullIncludes = (includes == null);", "+                includes = nullIncludes ? new String[] {\"**\"} : includes;", "+                boolean nullExcludes = (excludes == null);", "+                excludes = nullExcludes ? new String[0] : excludes;", "+", "+                if (basedir == null) {", "+                    throw new IllegalStateException(\"No basedir set\");", "+                }", "+                if (!basedir.exists()) {", "+                    throw new IllegalStateException(\"basedir \" + basedir", "+                                                    + \" does not exist\");", "+                }", "+                if (!basedir.isDirectory()) {", "+                    throw new IllegalStateException(\"basedir \" + basedir", "+                                                    + \" is not a directory\");", "+                }", "+                if (isIncluded(\"\")) {", "+                    if (!isExcluded(\"\")) {", "+                        if (isSelected(\"\", basedir)) {", "+                            dirsIncluded.addElement(\"\");", "+                        } else {", "+                            dirsDeselected.addElement(\"\");", "+                        }", "+                    } else {", "+                        dirsExcluded.addElement(\"\");", "+                    }", "+                } else {", "+                    dirsNotIncluded.addElement(\"\");", "+                }", "+                checkIncludePatterns();", "+                clearCaches();", "+                includes = nullIncludes ? null : includes;", "+                excludes = nullExcludes ? null : excludes;", "+            }", "+        } finally {", "+            synchronized (scanLock) {", "+                scanning = false;", "+                scanLock.notifyAll();", "+            }", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "767ab0a27bcbeb06ed237daacf7c670e", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/unix/Symlink.java", "commitBeforeChange": "1331049054d53ef94674a4966e7000bbf8baf6be", "commitAfterChange": "472c46251f1e0f3c7e68528f23617f21b80366cb", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "     public static void deleteSymlink(File linkfil, Task task)         throws IOException", "signatureAfterChange": "     public static void deleteSymlink(File linkfil, Task task)         throws IOException", "diff": ["-        // rename the resource, thus breaking the link:", "-        File temp = FILE_UTILS.createTempFile(\"symlink\", \".tmp\",", "-                                              canfil.getParentFile(), false,", "-                                              false);", "+            // rename the resource, thus breaking the link:", "+            File temp = FILE_UTILS.createTempFile(\"symlink\", \".tmp\",", "+                                                  canfil.getParentFile(), false,", "+                                                  false);", "-        if (FILE_UTILS.isLeadingPath(canfil, linkfil)) {", "-            // link points to a parent directory, renaming the parent", "-            // will rename the file", "-            linkfil = new File(temp,", "-                               FILE_UTILS.removeLeadingPath(canfil, linkfil));", "-        }", "+            if (FILE_UTILS.isLeadingPath(canfil, linkfil)) {", "+                // link points to a parent directory, renaming the parent", "+                // will rename the file", "+                linkfil = new File(temp,", "+                                   FILE_UTILS.removeLeadingPath(canfil,", "+                                                                linkfil));", "+            }", "-        boolean renamedTarget = false;", "-        try {", "+            boolean renamedTarget = false;", "-                FILE_UTILS.rename(canfil, temp);", "-                renamedTarget = true;", "-            } catch (IOException e) {", "-                throw new IOException(", "-                    \"Couldn't rename resource when attempting to delete \"", "-                    + linkfil);", "-            }", "-            // delete the (now) broken link:", "-            if (!linkfil.delete()) {", "-                throw new IOException(\"Couldn't delete symlink: \" + linkfil", "-                    + \" (was it a real file? is this not a UNIX system?)\");", "-            }", "-        } finally {", "-            if (renamedTarget) {", "-                // return the resource to its original name:", "-                    FILE_UTILS.rename(temp, canfil);", "+                    FILE_UTILS.rename(canfil, temp);", "+                    renamedTarget = true;", "-                    throw new IOException(\"Couldn't return resource \" + temp", "-                                          + \" to its original name: \"", "-                                          + canfil.getAbsolutePath()", "-                                          + \"\\n THE RESOURCE'S NAME ON DISK HAS \"", "-                                          + \"BEEN CHANGED BY THIS ERROR!\\n\");", "+                    throw new IOException(\"Couldn't rename resource when \"", "+                                          + \"attempting to delete \" + linkfil);", "+                }", "+                // delete the (now) broken link:", "+                if (!linkfil.delete()) {", "+                    throw new IOException(\"Couldn't delete symlink: \"", "+                                          + linkfil", "+                                          + \" (was it a real file? is this \"", "+                                          + \"not a UNIX system?)\");", "+                }", "+            } finally {", "+                if (renamedTarget) {", "+                    // return the resource to its original name:", "+                    try {", "+                        FILE_UTILS.rename(temp, canfil);", "+                    } catch (IOException e) {", "+                        throw new IOException(\"Couldn't return resource \"", "+                                              + temp", "+                                              + \" to its original name: \"", "+                                              + canfil.getAbsolutePath()", "+                                              + \"\\n THE RESOURCE'S NAME ON DISK\"", "+                                              + \" HAS BEEN CHANGED BY THIS\"", "+                                              + \" ERROR!\\n\");", "+                    }", "-        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7d27cebdc16f702b8c148712add8c95a", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/filters/util/ChainReaderHelper.java", "commitBeforeChange": "26a42bd2034a7ecb1e5bd0f0dfbd179a2185502a", "commitAfterChange": "63eeac0b800f6797dd406a1ef109b2eacf804e1a", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "     public Reader getAssembledReader() throws BuildException", "signatureAfterChange": "     public Reader getAssembledReader() throws BuildException", "diff": ["-                    final AntFilterReader filter", "-                        = (AntFilterReader) finalFilters.elementAt(i);", "-                    final String className = filter.getClassName();", "-                    final Path classpath = filter.getClasspath();", "-                    final Project pro = filter.getProject();", "-                    if (className != null) {", "-                        try {", "-                            Class clazz = null;", "-                            if (classpath == null) {", "-                                clazz = Class.forName(className);", "-                            } else {", "-                                AntClassLoader al", "-                                    = pro.createClassLoader(classpath);", "-                                classLoadersToCleanUp.add(al);", "-                                clazz = Class.forName(className, true, al);", "-                            }", "-                            if (clazz != null) {", "-                                if (!FilterReader.class.isAssignableFrom(clazz)) {", "-                                    throw new BuildException(className", "-                                        + \" does not extend java.io.FilterReader\");", "-                                }", "-                                final Constructor[] constructors =", "-                                    clazz.getConstructors();", "-                                int j = 0;", "-                                boolean consPresent = false;", "-                                for (; j < constructors.length; j++) {", "-                                    Class[] types = constructors[j]", "-                                                      .getParameterTypes();", "-                                    if (types.length == 1", "-                                        && types[0].isAssignableFrom(Reader.class)) {", "-                                        consPresent = true;", "-                                        break;", "-                                    }", "-                                }", "-                                if (!consPresent) {", "-                                    throw new BuildException(className", "-                                        + \" does not define a public constructor\"", "-                                        + \" that takes in a Reader as its \"", "-                                        + \"single argument.\");", "-                                }", "-                                final Reader[] rdr = {instream};", "-                                instream =", "-                                    (Reader) constructors[j].newInstance((Object[]) rdr);", "-                                setProjectOnObject(instream);", "-                                if (Parameterizable.class.isAssignableFrom(clazz)) {", "-                                    final Parameter[] params = filter.getParams();", "-                                    ((Parameterizable)", "-                                        instream).setParameters(params);", "-                                }", "-                            }", "-                        } catch (final ClassNotFoundException cnfe) {", "-                            throw new BuildException(cnfe);", "-                        } catch (final InstantiationException ie) {", "-                            throw new BuildException(ie);", "-                        } catch (final IllegalAccessException iae) {", "-                            throw new BuildException(iae);", "-                        } catch (final InvocationTargetException ite) {", "-                            throw new BuildException(ite);", "-                        }", "-                    }", "+                    instream =", "+                        expandReader((AntFilterReader) finalFilters.elementAt(i),", "+                                     instream, classLoadersToCleanUp);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "97420038f274b6514e68032f216c4e31", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/mutant/src/java/antcore/org/apache/ant/antcore/antlib/AntLibManager.java", "commitBeforeChange": "65b70febb53b077317c4d678291f9af547c3d116", "commitAfterChange": "f9d1c1691c7e9d80b793f5178f6113c949fc2441", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public void addAntLibraries(Map librarySpecs, URL libURL)          throws MalformedURLException, ExecutionException", "signatureAfterChange": "     public void addAntLibraries(Map librarySpecs, URL libURL)          throws AntLibException", "diff": ["-         throws MalformedURLException, ExecutionException {", "-        URL[] libURLs = LoaderUtils.getLocationURLs(libURL, libURL.toString(),", "-            ANTLIB_EXTENSIONS);", "+         throws AntLibException {", "+        try {", "+            URL[] libURLs = LoaderUtils.getLocationURLs(libURL,", "+                libURL.toString(), ANTLIB_EXTENSIONS);", "-        if (libURLs == null) {", "-            return;", "-        }", "+            if (libURLs == null) {", "+                return;", "+            }", "-        // parse each task library to get its library definition", "-        for (int i = 0; i < libURLs.length; ++i) {", "-            URL antLibraryURL = new URL(\"jar:\" + libURLs[i]", "-                 + \"!/META-INF/antlib.xml\");", "-            try {", "-                AntLibrarySpec antLibrarySpec = parseLibraryDef(antLibraryURL);", "-                if (antLibrarySpec != null) {", "-                    String libraryId = antLibrarySpec.getLibraryId();", "-                    if (librarySpecs.containsKey(libraryId)) {", "-                        AntLibrarySpec currentSpec ", "-                            = (AntLibrarySpec) librarySpecs.get(libraryId);", "-                        throw new ExecutionException(\"Found more than one \"", "-                             + \"copy of library with id = \" + libraryId ", "-                             + \" (\" + libURLs[i] + \") + existing library at (\"", "-                             + currentSpec.getLibraryURL() + \")\");", "+            // parse each task library to get its library definition", "+            for (int i = 0; i < libURLs.length; ++i) {", "+                URL antLibraryURL = new URL(\"jar:\" + libURLs[i]", "+                     + \"!/META-INF/antlib.xml\");", "+                try {", "+                    AntLibrarySpec antLibrarySpec", "+                        = parseLibraryDef(antLibraryURL);", "+                    if (antLibrarySpec != null) {", "+                        String libraryId = antLibrarySpec.getLibraryId();", "+                        if (librarySpecs.containsKey(libraryId)) {", "+                            AntLibrarySpec currentSpec", "+                                = (AntLibrarySpec) librarySpecs.get(libraryId);", "+                            throw new AntLibException(\"Found more than one \"", "+                                 + \"copy of library with id = \" + libraryId", "+                                 + \" (\" + libURLs[i] + \") + existing library \"", "+                                 + \"at (\" + currentSpec.getLibraryURL() + \")\");", "+                        }", "+                        antLibrarySpec.setLibraryURL(libURLs[i]);", "+                        librarySpecs.put(libraryId, antLibrarySpec);", "-                    antLibrarySpec.setLibraryURL(libURLs[i]);", "-                    librarySpecs.put(libraryId, antLibrarySpec);", "-                }", "-            } catch (XMLParseException e) {", "-                Throwable t = e.getCause();", "-                // ignore file not found exceptions - means the", "-                // jar does not provide META-INF/antlib.xml", "-                if (!(t instanceof FileNotFoundException)) {", "-                    throw new ExecutionException(\"Unable to parse Ant library \"", "-                         + libURLs[i], e);", "+                } catch (XMLParseException e) {", "+                    Throwable t = e.getCause();", "+                    // ignore file not found exceptions - means the", "+                    // jar does not provide META-INF/antlib.xml", "+                    if (t instanceof AntLibException) {", "+                        throw (AntLibException) t;", "+                    } else if (!(t instanceof FileNotFoundException)) {", "+                        throw new AntLibException(\"Unable to parse Ant \"", "+                            + \"library \" + libURLs[i], e);", "+                    }", "+        } catch (MalformedURLException e) {", "+            throw new AntLibException(\"Unable to load libraries from \"", "+                + libURL, e);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a04a6ac65df75bd9bf837d30c864e58b", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java", "commitBeforeChange": "b0b920b08fae74de3fd7a7dd5efbca9e8cf379e6", "commitAfterChange": "114d55869f46b382375b6b32ddc17bb2e5fc598c", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 12, "signatureBeforeChange": "     public void run()", "signatureAfterChange": "     public void run()", "diff": ["+                final boolean testMethodsSpecified = (methods != null);", "+", "+                if (!testMethodsSpecified) {", "+                }", "+                    boolean useSingleMethodAdapter = false;", "+                    if (junit.framework.TestCase.class.isAssignableFrom(testClass)) {", "+                        // Do not use JUnit 4 API for running JUnit 3.x", "+                        // tests - it is not able to run individual test", "+                        // methods.", "+                        //", "+                        // Technical details:", "+                        // org.junit.runner.Request.method(Class, String).getRunner()", "+                        // would return a runner which always executes all", "+                        // test methods. The reason is that the Runner would be", "+                        // an instance of class", "+                        // org.junit.internal.runners.OldTestClassRunner", "+                        // that does not implement interface Filterable - so it", "+                        // is unable to filter out test methods not matching", "+                        // the requested name.", "+                    } else {", "+                            if (testMethodsSpecified) {", "+                                /*", "+                                 * We cannot try to load the JUnit4TestAdapter", "+                                 * before trying to load JUnit4TestMethodAdapter", "+                                 * because it might fail with", "+                                 * NoClassDefFoundException, instead of plain", "+                                 * ClassNotFoundException.", "+                                 */", "+                                junit4TestAdapterClass = Class.forName(", "+                                    \"org.apache.tools.ant.taskdefs.optional.junit.JUnit4TestMethodAdapter\");", "+                                useSingleMethodAdapter = true;", "+                            }", "+                            if (testMethodsSpecified) {", "+                                junit4TestAdapterClass =", "+                                    Class.forName(", "+                                        \"org.apache.tools.ant.taskdefs.optional.junit.JUnit4TestMethodAdapter\",", "+                                        true, loader);", "+                                useSingleMethodAdapter = true;", "+                            }", "+                    }", "+                        Class[] formalParams;", "+                        Object[] actualParams;", "+                        if (useSingleMethodAdapter) {", "+                            formalParams = new Class[] {Class.class, String[].class};", "+                            actualParams = new Object[] {testClass, methods};", "+                        } else {", "+                            formalParams = new Class[] {Class.class};", "+                            actualParams = new Object[] {testClass};", "+                        }", "-                            .getConstructor(new Class[] {Class.class}).", "-                            newInstance(new Object[] {testClass});", "+                            .getConstructor(formalParams).", "+                            newInstance(actualParams);", "-                        suite = new TestSuite(testClass);", "+                        if (!testMethodsSpecified) {", "+                            suite = new TestSuite(testClass);", "+                        } else if (methods.length == 1) {", "+                            suite = TestSuite.createTest(testClass, methods[0]);", "+                        } else {", "+                            TestSuite testSuite = new TestSuite(testClass.getName());", "+                            for (int i = 0; i < methods.length; i++) {", "+                                testSuite.addTest(", "+                                    TestSuite.createTest(testClass, methods[i]));", "+                            }", "+                            suite = testSuite;", "+                        }"]}]}