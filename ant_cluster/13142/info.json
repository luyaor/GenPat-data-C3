{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ab96808c952c74faba5585e5c6b7f0b9", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16fd658f33c41ed212c93e8b9b13e507", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/myrmidon/src/java/org/apache/myrmidon/components/converter/DefaultMasterConverter.java", "commitBeforeChange": "4b3e0ee2041826e51ec60af99e7bcca7024bf676", "commitAfterChange": "ed3fafb887fef0afbcd90eef7f263fef3bde95d9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      private String getConverterName( final Class originalClass,                                      final Class destination )         throws ConverterException", "signatureAfterChange": "     private String getConverterName( final Class originalClass,                                      final Class destination )         throws ConverterException", "diff": ["+     */", "-        //TODO: Maybe we should search the source classes hierarchy aswell", "-        for( Class clazz = destination;", "-             clazz != null;", "-             clazz = clazz.getSuperclass() )", "+        //TODO: Maybe we should search the destination classes hierarchy as well", "+", "+        // Recursively iterate over the super-types of the original class,", "+        // looking for a converter from source type -> destination type.", "+        // If more than one is found, choose the most specialised.", "+", "+        Class match = null;", "+        String converterName = null;", "+        ArrayList queue = new ArrayList();", "+        queue.add( originalClass );", "+", "+        while( ! queue.isEmpty() )", "-            final String name =", "-                m_registry.getConverterName( originalClass.getName(),", "-                                             clazz.getName() );", "-            if( name != null )", "+            Class clazz = (Class)queue.remove( 0 );", "+", "+            // Add superclass and all interfaces", "+            if( clazz.getSuperclass() != null )", "-                return name;", "+                queue.add( clazz.getSuperclass() );", "+            }", "+            final Class[] interfaces = clazz.getInterfaces();", "+            for( int i = 0; i < interfaces.length; i++ )", "+            {", "+                queue.add( interfaces[i ] );", "+            }", "+", "+            // Check if we can convert from current class to destination", "+            final String name = m_registry.getConverterName( clazz.getName(),", "+                                                             destination.getName() );", "+            if( name == null )", "+            {", "+                continue;", "+            }", "+", "+            // Choose the more specialised source class", "+            if( match == null || match.isAssignableFrom( clazz ) )", "+            {", "+                match = clazz;", "+                converterName = name;", "+            }", "+            else if( clazz.isAssignableFrom( clazz ) )", "+            {", "+                continue;", "+            }", "+            else", "+            {", "+                // Duplicate", "+                final String message = REZ.getString( \"ambiguous-converter.error\" );", "+                throw new ConverterException( message );", "-        final String message =", "-            REZ.getString( \"no-converter.error\",", "-                           originalClass.getName(),", "-                           destination.getName() );", "+        // TODO - should cache the (src, dest) -> converter mapping", "+        if( match != null )", "+        {", "+            return converterName;", "+        }", "+", "+        // Could not find a converter", "+        final String message = REZ.getString( \"no-converter.error\" );"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b8927f591f344fff9906d287e2c5396", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/PropertyFile.java", "commitBeforeChange": "334ac128fea4c6e8e76c7c8af8061a47b5019bf4", "commitAfterChange": "ba37bf7991e099b567f8cd5a09178893ff55bb9c", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 18, "signatureBeforeChange": "         private void executeInteger(String oldValue) throws BuildException", "signatureAfterChange": "         private void executeInteger(String oldValue) throws BuildException", "diff": ["-        private void executeInteger(String oldValue) throws BuildException ", "+        private void executeInteger(String oldValue) throws BuildException", "-            String newValue = \"\";", "-            int currentValue = 0;", "-            try ", "-            {", "-                currentValue = new Integer(oldValue).intValue();", "+            int value = 0;", "+            int newValue  = 0;", "+", "+            DecimalFormat fmt = (m_pattern != null) ? new DecimalFormat(m_pattern)", "+                                                    : new DecimalFormat();", "+", "+            if (m_value != null) {", "+                try {", "+                    value = fmt.parse(m_value).intValue();", "+                }", "+                catch (NumberFormatException nfe) { /* swollow */ }", "+                catch (ParseException pe)  { /* swollow */ }", "-            catch (NumberFormatException nfe) ", "-            {", "-                // Do nothing", "+            if (oldValue != null) {", "+                try {", "+                    newValue = fmt.parse(oldValue).intValue();", "+                }", "+                catch (NumberFormatException nfe) { /* swollow */ }", "+                catch (ParseException pe)  { /* swollow */ }", "+            }", "+            else if (m_default != null) {", "+                try {", "+                    newValue = fmt.parse(m_default).intValue();", "+                }", "+                catch (NumberFormatException nfe) { /* swollow */ }", "+                catch (ParseException pe)  { /* swollow */ }", "-            if (m_operation.equals(INCREMENT_OPER)) ", "-            {", "-                currentValue++;", "-                m_value = new String(\"\"+currentValue);", "+            if (m_operation == Operation.EQUALS_OPER) {", "+                newValue = value;", "-            else if (m_operation.equals(DECREMENT_OPER)) ", "-            {", "-                currentValue--;", "-                m_value = new String(\"\"+currentValue);", "+            else if (m_operation == Operation.INCREMENT_OPER) {", "+                newValue += value;", "+            }", "+            else if (m_operation == Operation.DECREMENT_OPER) {", "+                newValue -= value;", "+            }", "+            m_value = fmt.format(newValue);", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eb0e60e854b930563495f609f2c27729", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Sync.java", "commitBeforeChange": "13b07b313fdc7ab2620f71517ab16698be496f24", "commitAfterChange": "a799f17a4e2ff063e0d4c05d6a1be064e84d68c8", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private int[] removeOrphanFiles(Set nonOrphans, File toDir)", "signatureAfterChange": "     private int[] removeOrphanFiles(Set nonOrphans, File toDir)", "diff": ["-            syncTarget.setTargetDir(toDir);", "-            ds = syncTarget.getDirectoryScanner(getProject());", "+            FileSet fs = new FileSet();", "+            fs.setDir(toDir);", "+            fs.setCaseSensitive(syncTarget.isCaseSensitive());", "+            fs.setFollowSymlinks(syncTarget.isFollowSymlinks());", "+", "+            // preserveInTarget would find all files we want to keep,", "+            // but we need to find all that we want to delete - so the", "+            // meaning of all patterns and selectors must be inverted", "+            PatternSet ps = syncTarget.mergePatterns(getProject());", "+            String[] excludes = ps.getExcludePatterns(getProject());", "+            fs.appendExcludes(ps.getIncludePatterns(getProject()));", "+            fs.appendIncludes(ps.getExcludePatterns(getProject()));", "+            fs.setDefaultexcludes(!syncTarget.getDefaultexcludes());", "+", "+            // selectors are implicitly ANDed in DirectoryScanner.  To", "+            // revert their logic we wrap them into a <none> selector", "+            // instead.", "+            FileSelector[] s = syncTarget.getSelectors(getProject());", "+            if (s.length > 0) {", "+                NoneSelector ns = new NoneSelector();", "+                for (int i = 0; i < s.length; i++) {", "+                    ns.appendSelector(s[i]);", "+                }", "+                fs.appendSelector(ns);", "+            }", "+            ", "+            ds = fs.getDirectoryScanner(getProject());", "-        // ds returns the directories as it has visited them.", "+        // ds returns the directories in lexicographic order."]}]}