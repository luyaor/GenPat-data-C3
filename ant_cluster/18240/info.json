{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a0e1b2b46eb97b15281cac7155c7c5a3", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "23546c0a3bc6f6fd971242444c5760d2", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/xdocs/src/org/apache/tools/ant/xdoclet/TaskTagsHandler.java", "commitBeforeChange": "f19f07d6e4c72f241057ecfc32d80be21201bbf7", "commitAfterChange": "ca91f8cb7e4f2bfe1a191dea6126a32649af9565", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "     private MethodDoc[] getAttributeMethods(ClassDoc cur_class) throws XDocletException", "signatureAfterChange": "      private MethodDoc[] getAttributeMethods(ClassDoc cur_class) throws XDocletException", "diff": ["-     */", "+        Map nameTypeMap = new HashMap();", "-            if (!methods[i].name().startsWith(\"set\")) {", "+            MethodDoc method = methods[i];", "+", "+            if (!method.isPublic()) {", "+                continue;", "+            }", "+", "+            if (!method.name().startsWith(\"set\")) {", "-            if (isAntAttribute(methods[i])) {", "+            if (isAntAttribute(method)) {", "-            Parameter[] params = methods[i].parameters();", "+            Parameter[] params = method.parameters();", "-            attributeMethods.add(methods[i]);", "+            Parameter param = params[0];", "+", "+            // Screen out attribute setters if there are duplicates,", "+            // and only return the first non-String one", "+            // (this may or may not jive with IntrospectionHelper)", "+            MethodDoc oldMethod = (MethodDoc) nameTypeMap.get(method.name());", "+            if (oldMethod == null) {", "+                nameTypeMap.put(method.name(), method);", "+            }", "+            else {", "+                if (\"java.lang.String\".equals(oldMethod.parameters()[0].typeName())) {", "+                    attributeMethods.remove(oldMethod);", "+                    nameTypeMap.put(method.name(), method);", "+                }", "+            }", "+", "+            attributeMethods.add(method);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c12581e39aad52aa3bb3eddc5555d7e7", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/metamata/MAuditStreamHandler.java", "commitBeforeChange": "271e0fe6fc223253e2c24c0f0f0c4fc4d9b58410", "commitAfterChange": "8af1905a98b1e04a63ab7473d64a41bfda91f15e", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "     public void stop()", "signatureAfterChange": "     public void stop()", "diff": ["+        // make sure to flush err stream", "+        try {", "+            errThread.join();", "+        } catch (InterruptedException e) {", "+        }", "+        try {", "+            errStream.flush();", "+        } catch (IOException e) {", "+        }", "-        // this is the only code that could be needed to be overrided", "+        // this is the only code that could be needed to be overriden", "+        final Date now = new Date();", "+        rootElement.setAttribute(\"snapshot_created\", DateUtils.format(now, DateUtils.ISO8601_DATETIME_PATTERN));", "+        rootElement.setAttribute(\"elapsed_time\", String.valueOf(now.getTime() - program_start.getTime()));", "+        rootElement.setAttribute(\"program_start\", DateUtils.format(now, DateUtils.ISO8601_DATETIME_PATTERN));", "-        while (keys.hasMoreElements()){", "-            String filepath = (String)keys.nextElement();", "-            Vector v = (Vector)auditedFiles.get(filepath);", "-            String fullclassname = (String)filemapping.get(filepath);", "+        while (keys.hasMoreElements()) {", "+            String filepath = (String) keys.nextElement();", "+            Vector v = (Vector) auditedFiles.get(filepath);", "+            String fullclassname = (String) filemapping.get(filepath);", "-            clazz.setAttribute(\"violations\", String.valueOf(v.size()));", "-            errors += v.size();", "-            for (int i = 0; i < v.size(); i++){", "-                MAudit.Violation violation = (MAudit.Violation)v.elementAt(i);", "+            final int violationCount = v.size();", "+            clazz.setAttribute(\"violations\", String.valueOf(violationCount));", "+            errors += violationCount;", "+            for (int i = 0; i < violationCount; i++) {", "+                MAudit.Violation violation = (MAudit.Violation) v.elementAt(i);", "-                error.setAttribute(\"line\", String.valueOf(violation.line));", "+                error.setAttribute(\"line\", violation.line);", "-        if (xmlOut != null) {", "-            Writer wri = null;", "-            try {", "-                wri = new OutputStreamWriter(xmlOut, \"UTF-8\");", "-                wri.write(\"<?xml version=\\\"1.0\\\"?>\\n\");", "-                (new DOMElementWriter()).write(rootElement, wri, 0, \"  \");", "-                wri.flush();", "-            } catch(IOException exc) {", "-                task.log(\"Unable to write log file\", Project.MSG_ERR);", "-            } finally {", "-                if (xmlOut != System.out && xmlOut != System.err) {", "-                    if (wri != null) {", "-                        try {", "-                            wri.close();", "-                        } catch (IOException e) {}", "-                    }", "+        Writer wri = null;", "+        try {", "+            wri = new OutputStreamWriter(xmlOut, \"UTF-8\");", "+            wri.write(\"<?xml version=\\\"1.0\\\"?>\\n\");", "+            (new DOMElementWriter()).write(rootElement, wri, 0, \"  \");", "+            wri.flush();", "+        } catch (IOException exc) {", "+            task.log(\"Unable to write log file\", Project.MSG_ERR);", "+        } finally {", "+            if (wri != null) {", "+                try {", "+                    wri.close();", "+                } catch (IOException e) {", "-"]}]}