{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "020a973364cf3fb90eea433182dcae26", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "11fd22df8d1aa3ed80a29adcc192930c", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/bzip2/CBZip2OutputStream.java", "commitBeforeChange": "228fb9839c21a0a853598e114faca72c8e9340e7", "commitAfterChange": "9922008d657c72235c402343fd88847b044014ad", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 38, "signatureBeforeChange": "      private void mainSort()", "signatureAfterChange": "      private void mainSort()", "diff": ["-", "-    private void mainSort() {", "-        int i, j, ss, sb;", "-        int[] runningOrder = new int[256];", "-        int[] copy = new int[256];", "-        boolean[] bigDone = new boolean[256];", "-        int c1, c2;", "-        int numQSorted;", "-", "-        /*", "-          In the various block-sized structures, live data runs", "-          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,", "-          set up the overshoot area for block.", "-        */", "-", "-        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );", "-", "-        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {", "-            block[last + i + 2] = block[(i % (last + 1)) + 1];", "-        }", "-        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {", "-            quadrant[i] = 0;", "-        }", "-", "-        block[0] = (char) (block[last + 1]);", "-", "-        if (last < 4000) {", "-            /*", "-              Use simpleSort(), since the full sorting mechanism", "-              has quite a large constant overhead.", "-            */", "-            for (i = 0; i <= last; i++) {", "-                zptr[i] = i;", "-            }", "-            firstAttempt = false;", "-            workDone = workLimit = 0;", "-            simpleSort(0, last, 0);", "-        } else {", "-            numQSorted = 0;", "-            for (i = 0; i <= 255; i++) {", "-                bigDone[i] = false;", "-            }", "-", "-            for (i = 0; i <= 65536; i++) {", "-                ftab[i] = 0;", "-            }", "-", "-            c1 = block[0];", "-            for (i = 0; i <= last; i++) {", "-                c2 = block[i + 1];", "-                ftab[(c1 << 8) + c2]++;", "-                c1 = c2;", "-            }", "-", "-            for (i = 1; i <= 65536; i++) {", "-                ftab[i] += ftab[i - 1];", "-            }", "-", "-            c1 = block[1];", "-            for (i = 0; i < last; i++) {", "-                c2 = block[i + 2];", "-                j = (c1 << 8) + c2;", "-                c1 = c2;", "-                ftab[j]--;", "-                zptr[ftab[j]] = i;", "-            }", "-", "-            j = ((block[last + 1]) << 8) + (block[1]);", "-            ftab[j]--;", "-            zptr[ftab[j]] = last;", "-", "-            /*", "-              Now ftab contains the first loc of every small bucket.", "-              Calculate the running order, from smallest to largest", "-              big bucket.", "-            */", "-", "-            for (i = 0; i <= 255; i++) {", "-                runningOrder[i] = i;", "-            }", "-", "-            {", "-                int vv;", "-                int h = 1;", "-                do {", "-                    h = 3 * h + 1;", "-                }", "-                while (h <= 256);", "-                do {", "-                    h = h / 3;", "-                    for (i = h; i <= 255; i++) {", "-                        vv = runningOrder[i];", "-                        j = i;", "-                        while ((ftab[((runningOrder[j - h]) + 1) << 8]", "-                                - ftab[(runningOrder[j - h]) << 8])", "-                                > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {", "-                            runningOrder[j] = runningOrder[j - h];", "-                            j = j - h;", "-                            if (j <= (h - 1)) {", "-                                break;", "-                        runningOrder[j] = vv;", "-                    }", "-                } while (h != 1);", "-            }", "-            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];", "-            for (int count = 0; count < QSORT_STACK_SIZE; count++) {", "-                stack[count] = new StackElem();", "-            }", "-            /*", "-              The main sorting loop.", "-            */", "-            for (i = 0; i <= 255; i++) {", "-                /*", "-                  Process big buckets, starting with the least full.", "-                */", "-                ss = runningOrder[i];", "-                /*", "-                  Complete the big bucket [ss] by quicksorting", "-                  any unsorted small buckets [ss, j].  Hopefully", "-                  previous pointer-scanning phases have already", "-                  completed many of the small buckets [ss, j], so", "-                  we don't have to sort them at all.", "-                */", "-                for (j = 0; j <= 255; j++) {", "-                    sb = (ss << 8) + j;", "-                    if (!((ftab[sb] & SETMASK) == SETMASK)) {", "-                        int lo = ftab[sb] & CLEARMASK;", "-                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;", "-                        if (hi > lo) {", "-                            qSort3(lo, hi, 2, stack);", "-                            numQSorted += (hi - lo + 1);", "-                            if (workDone > workLimit && firstAttempt) {", "-                                return;", "-                        ftab[sb] |= SETMASK;", "-                    }", "-                /*", "-                  The ss big bucket is now done.  Record this fact,", "-                  and update the quadrant descriptors.  Remember to", "-                  update quadrants in the overshoot area too, if", "-                  necessary.  The \"if (i < 255)\" test merely skips", "-                  this updating for the last bucket processed, since", "-                  updating for the last bucket is pointless.", "-                */", "-                bigDone[ss] = true;", "-", "-                if (i < 255) {", "-                    int bbStart  = ftab[ss << 8] & CLEARMASK;", "-                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;", "-                    int shifts   = 0;", "-", "-                    while ((bbSize >> shifts) > 65534) {", "-                        shifts++;", "-                    }", "-", "-                    for (j = 0; j < bbSize; j++) {", "-                        int a2update = zptr[bbStart + j];", "-                        int qVal = (j >> shifts);", "-                        quadrant[a2update] = qVal;", "-                        if (a2update < NUM_OVERSHOOT_BYTES) {", "-                            quadrant[a2update + last + 1] = qVal;", "-                        }", "-                    }", "-", "-                    if (!(((bbSize - 1) >> shifts) <= 65535)) {", "-                        panic();", "-                    }", "-                }", "-", "-                /*", "-                  Now scan this big bucket so as to synthesise the", "-                  sorted order for small buckets [t, ss] for all t != ss.", "-                */", "-                for (j = 0; j <= 255; j++) {", "-                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;", "-                }", "-", "-                for (j = ftab[ss << 8] & CLEARMASK;", "-                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {", "-                    c1 = block[zptr[j]];", "-                    if (!bigDone[c1]) {", "-                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;", "-                        copy[c1]++;", "-                    }", "-                }", "-", "-                for (j = 0; j <= 255; j++) {", "-                    ftab[(j << 8) + ss] |= SETMASK;", "+    private void mainSort() {", "+        final Data dataShadow = this.data;", "+        final int[] runningOrder = dataShadow.mainSort_runningOrder;", "+        final int[] copy = dataShadow.mainSort_copy;", "+        final boolean[] bigDone = dataShadow.mainSort_bigDone;", "+        final int[] ftab = dataShadow.ftab;", "+        final byte[] block = dataShadow.block;", "+        final int[] fmap = dataShadow.fmap;", "+        final char[] quadrant = dataShadow.quadrant;", "+        final int lastShadow = this.last;", "+        final int workLimitShadow = this.workLimit;", "+        final boolean firstAttemptShadow = this.firstAttempt;", "+        // Set up the 2-byte frequency table", "+        for (int i = 65537; --i >= 0;) {", "+            ftab[i] = 0;", "+         * In the various block-sized structures, live data runs from 0 to", "+         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area", "+         * for block.", "+         */", "+        for (int i = 0; i < NUM_OVERSHOOT_BYTES; i++) {", "+            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];", "+        }", "+        for (int i = lastShadow + NUM_OVERSHOOT_BYTES +1; --i >= 0;) {", "+            quadrant[i] = 0;", "+        }", "+        block[0] = block[lastShadow + 1];", "+        // Complete the initial radix sort:", "+        int c1 = block[0] & 0xff;", "+        for (int i = 0; i <= lastShadow; i++) {", "+            final int c2 = block[i + 1] & 0xff;", "+            ftab[(c1 << 8) + c2]++;", "+            c1 = c2;", "+        }", "+", "+        for (int i = 1; i <= 65536; i++)", "+            ftab[i] += ftab[i - 1];", "+", "+        c1 = block[1] & 0xff;", "+        for (int i = 0; i < lastShadow; i++) {", "+            final int c2 = block[i + 2] & 0xff;", "+            fmap[--ftab[(c1 << 8) + c2]] = i;", "+            c1 = c2;", "+        }", "+", "+        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;", "+", "+        /*", "+         * Now ftab contains the first loc of every small bucket. Calculate the", "+         * running order, from smallest to largest big bucket.", "+         */", "+        for (int i = 256; --i >= 0;) {", "+            bigDone[i] = false;", "+            runningOrder[i] = i;", "+        }", "+", "+        for (int h = 364; h != 1;) {", "+            h /= 3;", "+            for (int i = h; i <= 255; i++) {", "+                final int vv = runningOrder[i];", "+                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];", "+                final int b = h - 1;", "+                int j = i;", "+                for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j", "+                                                                                                                - h]) {", "+                    runningOrder[j] = ro;", "+                    j -= h;", "+                    if (j <= b) {", "+                        break;", "+                    }", "+                }", "+                runningOrder[j] = vv;", "+            }", "+        }", "+", "+        /*", "+         * The main sorting loop.", "+         */", "+        for (int i = 0; i <= 255; i++) {", "+            /*", "+             * Process big buckets, starting with the least full.", "+             */", "+            final int ss = runningOrder[i];", "+", "+            // Step 1:", "+            /*", "+             * Complete the big bucket [ss] by quicksorting any unsorted small", "+             * buckets [ss, j]. Hopefully previous pointer-scanning phases have", "+             * already completed many of the small buckets [ss, j], so we don't", "+             * have to sort them at all.", "+             */", "+            for (int j = 0; j <= 255; j++) {", "+                final int sb = (ss << 8) + j;", "+                final int ftab_sb = ftab[sb];", "+                if ((ftab_sb & SETMASK) != SETMASK) {", "+                    final int lo = ftab_sb & CLEARMASK;", "+                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;", "+                    if (hi > lo) {", "+                        mainQSort3(dataShadow, lo, hi, 2);", "+                        if (firstAttemptShadow", "+                            && (this.workDone > workLimitShadow)) {", "+                            return;", "+                        }", "+                    }", "+                    ftab[sb] = ftab_sb | SETMASK;", "+                }", "+            }", "+", "+            // Step 2:", "+            // Now scan this big bucket so as to synthesise the", "+            // sorted order for small buckets [t, ss] for all t != ss.", "+", "+            for (int j = 0; j <= 255; j++) {", "+                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;", "+            }", "+", "+            for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {", "+                final int fmap_j = fmap[j];", "+                c1 = block[fmap_j] & 0xff;", "+                if (!bigDone[c1]) {", "+                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);", "+                    copy[c1]++;", "+                }", "+            }", "+", "+            for (int j = 256; --j >= 0;)", "+                ftab[(j << 8) + ss] |= SETMASK;", "+", "+            // Step 3:", "+            /*", "+             * The ss big bucket is now done. Record this fact, and update the", "+             * quadrant descriptors. Remember to update quadrants in the", "+             * overshoot area too, if necessary. The \"if (i < 255)\" test merely", "+             * skips this updating for the last bucket processed, since updating", "+             * for the last bucket is pointless.", "+             */", "+            bigDone[ss] = true;", "+", "+            if (i < 255) {", "+                final int bbStart = ftab[ss << 8] & CLEARMASK;", "+                final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;", "+                int shifts = 0;", "+", "+                while ((bbSize >> shifts) > 65534) {", "+                    shifts++;", "+                }", "+", "+                for (int j = 0; j < bbSize; j++) {", "+                    final int a2update = fmap[bbStart + j];", "+                    final char qVal = (char) (j >> shifts);", "+                    quadrant[a2update] = qVal;", "+                    if (a2update < NUM_OVERSHOOT_BYTES) {", "+                        quadrant[a2update + lastShadow + 1] = qVal;", "+                    }", "+                }", "+            }", "+", "+        }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac927dd7b6691be896885c81bde0db60", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/bzip2/CBZip2OutputStream.java", "commitBeforeChange": "3477bbf6474cdd2b70b12eb638e64415a4f1c2ec", "commitAfterChange": "134d95afef9b42cf08f2eccb077b97525ac38034", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 37, "signatureBeforeChange": "      private void mainSort()", "signatureAfterChange": "      private void mainSort()", "diff": ["-        int i, j, ss, sb;", "-        int[] runningOrder = new int[256];", "-        int[] copy = new int[256];", "-        boolean[] bigDone = new boolean[256];", "-        int c1, c2;", "-        int numQSorted;", "+        final Data data             = this.data;", "+        final int[] runningOrder    = data.mainSort_runningOrder;", "+        final int[] copy            = data.mainSort_copy;", "+        final boolean[] bigDone     = data.mainSort_bigDone;", "+        final int[] ftab            = data.ftab;", "+        final byte[] block          = data.block;", "+        final int[] fmap            = data.fmap;", "+        final char[] quadrant       = data.quadrant;", "+        final int last              = this.last;", "+        final int workLimit         = this.workLimit;", "+        final boolean firstAttempt  = this.firstAttempt;", "+", "+        // Set up the 2-byte frequency table", "+        for (int i = 65537; --i >= 0;) {", "+            ftab[i] = 0;", "+        }", "-", "-        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );", "-        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {", "+        for (int i = 0; i < NUM_OVERSHOOT_BYTES; i++) {", "-        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {", "+        for (int i = last + NUM_OVERSHOOT_BYTES; --i >= 0;) {", "+        block[0] = block[last + 1];", "-        block[0] = (char) (block[last + 1]);", "+        // Complete the initial radix sort:", "-        if (last < 4000) {", "-            /*", "-              Use simpleSort(), since the full sorting mechanism", "-              has quite a large constant overhead.", "-            */", "-            for (i = 0; i <= last; i++) {", "-                zptr[i] = i;", "-            }", "-            firstAttempt = false;", "-            workDone = workLimit = 0;", "-            simpleSort(0, last, 0);", "-        } else {", "-            numQSorted = 0;", "-            for (i = 0; i <= 255; i++) {", "-                bigDone[i] = false;", "-            }", "+        int c1 = block[0] & 0xff;", "+        for (int i = 0; i <= last; i++) {", "+            final int c2 = block[i + 1] & 0xff;", "+            ftab[(c1 << 8) + c2]++;", "+            c1 = c2;", "+        }", "-            for (i = 0; i <= 65536; i++) {", "-                ftab[i] = 0;", "-            }", "+        for (int i = 1; i <= 65536; i++)", "+            ftab[i] += ftab[i - 1];", "-            c1 = block[0];", "-            for (i = 0; i <= last; i++) {", "-                c2 = block[i + 1];", "-                ftab[(c1 << 8) + c2]++;", "-                c1 = c2;", "-            }", "+        c1 = block[1] & 0xff;", "+        for (int i = 0; i < last; i++) {", "+            final int c2 = block[i + 2] & 0xff;", "+            fmap[--ftab[(c1 << 8) + c2]] = i;", "+            c1 = c2;", "+        }", "-            for (i = 1; i <= 65536; i++) {", "-                ftab[i] += ftab[i - 1];", "-            }", "+        fmap[--ftab[((block[last + 1] & 0xff) << 8) + (block[1] & 0xff)]]", "+            = last;", "-            c1 = block[1];", "-            for (i = 0; i < last; i++) {", "-                c2 = block[i + 2];", "-                j = (c1 << 8) + c2;", "-                c1 = c2;", "-                ftab[j]--;", "-                zptr[ftab[j]] = i;", "-            }", "-", "-            j = ((block[last + 1]) << 8) + (block[1]);", "-            ftab[j]--;", "-            zptr[ftab[j]] = last;", "-", "-            /*", "+        /*", "-            */", "+        */", "+        for (int i = 256; --i >= 0;) {", "+            bigDone[i] = false;", "+            runningOrder[i] = i;", "+        }", "-            for (i = 0; i <= 255; i++) {", "-                runningOrder[i] = i;", "-            }", "-", "-            {", "-                int vv;", "-                int h = 1;", "-                do {", "-                    h = 3 * h + 1;", "-                }", "-                while (h <= 256);", "-                do {", "-                    h = h / 3;", "-                    for (i = h; i <= 255; i++) {", "-                        vv = runningOrder[i];", "-                        j = i;", "-                        while ((ftab[((runningOrder[j - h]) + 1) << 8]", "-                                - ftab[(runningOrder[j - h]) << 8])", "-                                > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {", "-                            runningOrder[j] = runningOrder[j - h];", "-                            j = j - h;", "-                            if (j <= (h - 1)) {", "-                                break;", "-                            }", "-                        }", "-                        runningOrder[j] = vv;", "+        for (int h = 364; h != 1;) {", "+            h /= 3;", "+            for (int i = h; i <= 255; i++) {", "+                final int vv = runningOrder[i];", "+                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];", "+                final int b = h - 1;", "+                int j = i;", "+                for (int ro = runningOrder[j - h];", "+                     (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a;", "+                     ro = runningOrder[j - h]) {", "+                    runningOrder[j] = ro;", "+                    j -= h;", "+                    if (j <= b) {", "+                        break;", "-                } while (h != 1);", "+                }", "+                runningOrder[j] = vv;", "+        }", "-            /*", "+        /*", "-            */", "-            for (i = 0; i <= 255; i++) {", "-", "-                /*", "+        */", "+        for (int i = 0; i <= 255; i++) {", "+            /*", "-                */", "-                ss = runningOrder[i];", "+            */", "+            final int ss = runningOrder[i];", "-                /*", "+            // Step 1:", "+            /*", "-                */", "-                for (j = 0; j <= 255; j++) {", "-                    sb = (ss << 8) + j;", "-                    if (!((ftab[sb] & SETMASK) == SETMASK)) {", "-                        int lo = ftab[sb] & CLEARMASK;", "-                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;", "-                        if (hi > lo) {", "-                            qSort3(lo, hi, 2);", "-                            numQSorted += (hi - lo + 1);", "-                            if (workDone > workLimit && firstAttempt) {", "-                                return;", "-                            }", "+            */", "+            for (int j = 0; j <= 255; j++) {", "+                final int sb = (ss << 8) + j;", "+                final int ftab_sb = ftab[sb];", "+                if ((ftab_sb & SETMASK) != SETMASK) {", "+                    final int lo = ftab_sb & CLEARMASK;", "+                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;", "+                    if (hi > lo) {", "+                        mainQSort3(data, lo, hi, 2);", "+                        if (firstAttempt && (this.workDone > workLimit)) {", "+                            return;", "-                        ftab[sb] |= SETMASK;", "+                    ftab[sb] = ftab_sb | SETMASK;", "+            }", "-                /*", "+            // Step 2:", "+            // Now scan this big bucket so as to synthesise the", "+            // sorted order for small buckets [t, ss] for all t != ss.", "+", "+            for (int j = 0; j <= 255; j++) {", "+                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;", "+            }", "+", "+            for (int j = ftab[ss << 8] & CLEARMASK,", "+                     hj = (ftab[(ss + 1) << 8] & CLEARMASK);", "+                 j < hj;", "+                 j++) {", "+                final int fmap_j = fmap[j];", "+                c1 = block[fmap_j] & 0xff;", "+                if (!bigDone[c1]) {", "+                    fmap[copy[c1]] = (fmap_j == 0) ? last : (fmap_j - 1);", "+                    copy[c1]++;", "+                }", "+            }", "+", "+            for (int j = 256; --j >= 0;)", "+                ftab[(j << 8) + ss] |= SETMASK;", "+", "+            // Step 3:", "+            /*", "-                */", "-                bigDone[ss] = true;", "+            */", "+            bigDone[ss] = true;", "-                if (i < 255) {", "-                    int bbStart  = ftab[ss << 8] & CLEARMASK;", "-                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;", "-                    int shifts   = 0;", "+            if (i < 255) {", "+                final int bbStart = ftab[ss << 8] & CLEARMASK;", "+                final int bbSize  = ", "+                    (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;", "+                int shifts = 0;", "-                    while ((bbSize >> shifts) > 65534) {", "-                        shifts++;", "-                    }", "-", "-                    for (j = 0; j < bbSize; j++) {", "-                        int a2update = zptr[bbStart + j];", "-                        int qVal = (j >> shifts);", "-                        quadrant[a2update] = qVal;", "-                        if (a2update < NUM_OVERSHOOT_BYTES) {", "-                            quadrant[a2update + last + 1] = qVal;", "-                        }", "-                    }", "-", "-                    if (!(((bbSize - 1) >> shifts) <= 65535)) {", "-                        panic();", "-                    }", "+                while ((bbSize >> shifts) > 65534) {", "+                    shifts++;", "-                /*", "-                  Now scan this big bucket so as to synthesise the", "-                  sorted order for small buckets [t, ss] for all t != ss.", "-                */", "-                for (j = 0; j <= 255; j++) {", "-                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;", "-                }", "-", "-                for (j = ftab[ss << 8] & CLEARMASK;", "-                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {", "-                    c1 = block[zptr[j]];", "-                    if (!bigDone[c1]) {", "-                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;", "-                        copy[c1]++;", "+                for (int j = 0; j < bbSize; j++) {", "+                    final int a2update = fmap[bbStart + j];", "+                    final char qVal = (char) (j >> shifts);", "+                    quadrant[a2update] = qVal;", "+                    if (a2update < NUM_OVERSHOOT_BYTES) {", "+                        quadrant[a2update + last + 1] = qVal;", "-                }", "-", "-                for (j = 0; j <= 255; j++) {", "-                    ftab[(j << 8) + ss] |= SETMASK;", "+"]}]}