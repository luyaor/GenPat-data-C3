{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7fb4a3ed4cc3dea914e5758ef95cc7c5", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f0084d5cd9cb07460f8eaa92afb2e1c", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Expand.java", "commitBeforeChange": "fddadc930e92238d00cad244733d3f6f2e5b9941", "commitAfterChange": "02307f7dea1fb0177a13e50d7037c0f6286de1e7", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      protected void extractFile(FileUtils fileUtils, File srcF, File dir,                                InputStream compressedInputStream,                                String entryName,                                Date entryDate, boolean isDirectory)                                throws IOException", "signatureAfterChange": "      protected void extractFile(FileUtils fileUtils, File srcF, File dir,                                InputStream compressedInputStream,                                String entryName,                                Date entryDate, boolean isDirectory)                                throws IOException", "diff": ["-            String name = entryName;", "+            String name = entryName.replace('/', File.separatorChar)", "+                .replace('\\\\', File.separatorChar);", "-                    included = DirectoryScanner.match(incls[w], name);", "+                    String pattern = incls[w].replace('/', File.separatorChar)", "+                        .replace('\\\\', File.separatorChar);", "+                    if (pattern.endsWith(File.separator)) {", "+                        pattern += \"**\";", "+                    }", "+                    ", "+                    included = SelectorUtils.matchPath(pattern, name);", "-                        included = !(DirectoryScanner.match(excls[w], name));", "+                        String pattern = excls[w]", "+                            .replace('/', File.separatorChar)", "+                            .replace('\\\\', File.separatorChar);", "+                        if (pattern.endsWith(File.separator)) {", "+                            pattern += \"**\";", "+                        }", "+                        included = !(SelectorUtils.matchPath(pattern, name));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "650f1b814f821ccc7403e266501384e4", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/PathTokenizer.java", "commitBeforeChange": "769fac83235a4c2fac00097cd26f201aa7eae534", "commitAfterChange": "a91adaf451abf4857fd8ce133757dfc3b433bf3f", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public String nextToken() throws NoSuchElementException", "signatureAfterChange": "     public String nextToken() throws NoSuchElementException", "diff": ["-        if (token.length() == 1 && Character.isLetter(token.charAt(0))", "-                                && dosStyleFilesystem", "-                                && tokenizer.hasMoreTokens()) {", "-            // we are on a dos style system so this path could be a drive", "-            // spec. We look at the next token", "-            String nextToken = tokenizer.nextToken().trim();", "-            if (nextToken.startsWith(\"\\\\\") || nextToken.startsWith(\"/\")) {", "-                // we know we are on a DOS style platform and the next path starts with a", "-                // slash or backslash, so we know this is a drive spec", "-                token += \":\" + nextToken;", "-            }", "-            else {", "-                // store the token just read for next time", "-                lookahead = nextToken;", "+        if (!onNetWare) {", "+            if (token.length() == 1 && Character.isLetter(token.charAt(0))", "+                                    && dosStyleFilesystem", "+                                    && tokenizer.hasMoreTokens()) {", "+                // we are on a dos style system so this path could be a drive", "+                // spec. We look at the next token", "+                String nextToken = tokenizer.nextToken().trim();", "+                if (nextToken.startsWith(\"\\\\\") || nextToken.startsWith(\"/\")) {", "+                    // we know we are on a DOS style platform and the next path", "+                    // starts with a slash or backslash, so we know this is a ", "+                    // drive spec", "+                    token += \":\" + nextToken;", "+                }", "+                else {", "+                    // store the token just read for next time", "+                    lookahead = nextToken;", "+                }", "-           ", "+        else {", "+            // we are on NetWare, tokenizing is handled a little differently,", "+            // due to the fact that NetWare has multiple-character volume names.", "+            if (token.equals(pathSeparatorStr)) {", "+                // ignore \";\" and get the next token", "+                token = tokenizer.nextToken().trim();", "+            }", "+            ", "+            if (tokenizer.hasMoreTokens()) {", "+                // this path could be a drive spec, so look at the next token", "+                String nextToken = tokenizer.nextToken().trim();", "+                ", "+                // make sure we aren't going to get the path separator next", "+                if (!nextToken.equals(pathSeparatorStr)) {", "+                    if (nextToken.equals(\":\")) {", "+                        if (!token.startsWith(\"/\") && !token.startsWith(\"\\\\\")){ ", "+                            // it indeed is a drive spec, get the next bit", "+                            String oneMore = tokenizer.nextToken().trim();", "+                            if (!oneMore.equals(pathSeparatorStr)) {", "+                                token += \":\" + oneMore;", "+                            }", "+                            else {", "+                                token += \":\";", "+                            }", "+                        }", "+                        // implicit else: ignore the ':' since we have either a", "+                        // UNIX or a relative path", "+                    }", "+                    else {", "+                        // store the token just read for next time", "+                        lookahead = nextToken;", "+                    }", "+                }", "+            }", "+        }"]}]}