{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e82d5e8ffba568af8f54d3505dbbd2e3", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "525978dba9641e98ed27e3afc6a70ba2", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/myrmidon/src/main/org/apache/tools/ant/IntrospectionHelper.java", "commitBeforeChange": "e854f481c9a76b41680eb0f605de524556b059ad", "commitAfterChange": "7a3448dcea316f454dd0ba470f8b0825504ae309", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "      private IntrospectionHelper( final Class bean )", "signatureAfterChange": "      private IntrospectionHelper( final Class bean )         throws TaskException", "diff": ["+        throws TaskException", "-            final Method m = methods[i];", "+            final Method m = methods[ i ];", "-                 && args.length == 1 &&", "+                && args.length == 1 &&", "-                \"setLocation\".equals( name ) && org.apache.tools.ant.Location.class.equals( args[0] )", "-                 ) || (", "-                \"setTaskType\".equals( name ) && java.lang.String.class.equals( args[0] )", "-                 )", "-                 ) )", "+                \"setLocation\".equals( name ) && org.apache.tools.ant.Location.class.equals( args[ 0 ] )", "+                ) || (", "+                \"setTaskType\".equals( name ) && java.lang.String.class.equals( args[ 0 ] )", "+                )", "+                ) )", "-                 && args.length == 1 && \"addTask\".equals( name )", "-                 && org.apache.tools.ant.Task.class.equals( args[0] ) )", "+                && args.length == 1 && \"addTask\".equals( name )", "+                && org.apache.tools.ant.Task.class.equals( args[ 0 ] ) )", "-                 && java.lang.Void.TYPE.equals( returnType )", "-                 && args.length == 1", "-                 && java.lang.String.class.equals( args[0] ) )", "+                && java.lang.Void.TYPE.equals( returnType )", "+                && args.length == 1", "+                && java.lang.String.class.equals( args[ 0 ] ) )", "-                addText = methods[i];", "+                addText = methods[ i ];", "-                 && java.lang.Void.TYPE.equals( returnType )", "-                 && args.length == 1", "-                 && !args[0].isArray() )", "+                && java.lang.Void.TYPE.equals( returnType )", "+                && args.length == 1", "+                && !args[ 0 ].isArray() )", "-                    if( java.lang.String.class.equals( args[0] ) )", "+                    if( java.lang.String.class.equals( args[ 0 ] ) )", "-                AttributeSetter as = createAttributeSetter( m, args[0] );", "+                AttributeSetter as = createAttributeSetter( m, args[ 0 ] );", "-                    attributeTypes.put( propName, args[0] );", "+                    attributeTypes.put( propName, args[ 0 ] );", "-                 && !returnType.isArray()", "-                 && !returnType.isPrimitive()", "-                 && args.length == 0 )", "+                && !returnType.isArray()", "+                && !returnType.isPrimitive()", "+                && args.length == 0 )", "-                    new NestedCreator()", "-                    {", "+                                    new NestedCreator()", "+                                    {", "-                        public Object create( Object parent )", "-                            throws InvocationTargetException,", "-                            IllegalAccessException", "-                        {", "+                                        public Object create( Object parent )", "+                                            throws InvocationTargetException,", "+                                            IllegalAccessException", "+                                        {", "-                            return m.invoke( parent, new Object[]{} );", "-                        }", "+                                            return m.invoke( parent, new Object[]{} );", "+                                        }", "-                    } );", "+                                    } );", "-                 && java.lang.Void.TYPE.equals( returnType )", "-                 && args.length == 1", "-                 && !java.lang.String.class.equals( args[0] )", "-                 && !args[0].isArray()", "-                 && !args[0].isPrimitive() )", "+                && java.lang.Void.TYPE.equals( returnType )", "+                && args.length == 1", "+                && !java.lang.String.class.equals( args[ 0 ] )", "+                && !args[ 0 ].isArray()", "+                && !args[ 0 ].isPrimitive() )", "-                        args[0].getConstructor( new Class[]{} );", "+                        args[ 0 ].getConstructor( new Class[]{} );", "-                    nestedTypes.put( propName, args[0] );", "+                    nestedTypes.put( propName, args[ 0 ] );", "-                        new NestedCreator()", "-                        {", "+                                        new NestedCreator()", "+                                        {", "-                            public Object create( Object parent )", "-                                throws InvocationTargetException, IllegalAccessException, InstantiationException", "-                            {", "+                                            public Object create( Object parent )", "+                                                throws InvocationTargetException, IllegalAccessException, InstantiationException", "+                                            {", "-                                Object o = c.newInstance( new Object[]{} );", "-                                return o;", "-                            }", "+                                                Object o = c.newInstance( new Object[]{} );", "+                                                return o;", "+                                            }", "-                        } );", "+                                        } );", "-                        new NestedStorer()", "-                        {", "+                                       new NestedStorer()", "+                                       {", "-                            public void store( Object parent, Object child )", "-                                throws InvocationTargetException, IllegalAccessException, InstantiationException", "-                            {", "+                                           public void store( Object parent, Object child )", "+                                               throws InvocationTargetException, IllegalAccessException, InstantiationException", "+                                           {", "-                                m.invoke( parent, new Object[]{child} );", "-                            }", "+                                               m.invoke( parent, new Object[]{child} );", "+                                           }", "-                        } );", "+                                       } );", "-                 && java.lang.Void.TYPE.equals( returnType )", "-                 && args.length == 1", "-                 && !java.lang.String.class.equals( args[0] )", "-                 && !args[0].isArray()", "-                 && !args[0].isPrimitive() )", "+                && java.lang.Void.TYPE.equals( returnType )", "+                && args.length == 1", "+                && !java.lang.String.class.equals( args[ 0 ] )", "+                && !args[ 0 ].isArray()", "+                && !args[ 0 ].isPrimitive() )", "-                        args[0].getConstructor( new Class[]{} );", "+                        args[ 0 ].getConstructor( new Class[]{} );", "-                    nestedTypes.put( propName, args[0] );", "+                    nestedTypes.put( propName, args[ 0 ] );", "-                        new NestedCreator()", "-                        {", "+                                        new NestedCreator()", "+                                        {", "-                            public Object create( Object parent )", "-                                throws InvocationTargetException, IllegalAccessException, InstantiationException", "-                            {", "+                                            public Object create( Object parent )", "+                                                throws InvocationTargetException, IllegalAccessException, InstantiationException", "+                                            {", "-                                Object o = c.newInstance( new Object[]{} );", "-                                m.invoke( parent, new Object[]{o} );", "-                                return o;", "-                            }", "+                                                Object o = c.newInstance( new Object[]{} );", "+                                                m.invoke( parent, new Object[]{o} );", "+                                                return o;", "+                                            }", "-                        } );", "+                                        } );"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "97356737940aa3cc89a85ae725f759af", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/IntrospectionHelper.java", "commitBeforeChange": "0efc2f817257f69d7cdc67c016b1caac68465f1d", "commitAfterChange": "939a6bbf2fb97ec29ecf79c86013846656d8751c", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "     private AttributeSetter createAttributeSetter(final Method m,                                                   Class arg,                                                   final String attrName)", "signatureAfterChange": "     private AttributeSetter createAttributeSetter(final Method m,                                                   Class arg,                                                   final String attrName)", "diff": ["-                    m.invoke(parent, (Object[]) (new String[] {value}));", "+                    m.invoke(parent, (Object[]) new String[] { value });", "+        }", "-        } else if (java.lang.Character.class.equals(reflectedArg)) {", "+        if (java.lang.Character.class.equals(reflectedArg)) {", "-                            + \"legal value for attribute \\\"\" + attrName + \"\\\"\");", "+                                + \"legal value for attribute \\\"\" + attrName + \"\\\"\");", "-                    m.invoke(parent, (Object[])", "-                        (new Character[] {new Character(value.charAt(0))}));", "+                    m.invoke(parent, (Object[]) new Character[] { new Character(value.charAt(0)) });", "-        // boolean and Boolean get special treatment because we", "-        // have a nice method in Project", "-        } else if (java.lang.Boolean.class.equals(reflectedArg)) {", "+        }", "+        // boolean and Boolean get special treatment because we have a nice method in Project", "+        if (java.lang.Boolean.class.equals(reflectedArg)) {", "-                    m.invoke(parent, (Object[]) (", "-                         new Boolean[] {Project.toBoolean(value)", "-                                        ? Boolean.TRUE : Boolean.FALSE}));", "+                    m.invoke(parent, (Object[]) new Boolean[] {", "+                            Project.toBoolean(value) ? Boolean.TRUE : Boolean.FALSE });", "+        }", "-        } else if (java.lang.Class.class.equals(reflectedArg)) {", "+        if (java.lang.Class.class.equals(reflectedArg)) {", "-                        m.invoke(parent, new Object[] {Class.forName(value)});", "+                        m.invoke(parent, new Object[] { Class.forName(value) });", "+        }", "-        } else if (java.io.File.class.equals(reflectedArg)) {", "+        if (java.io.File.class.equals(reflectedArg)) {", "-                    m.invoke(parent, new Object[] {p.resolveFile(value)});", "+                    m.invoke(parent, new Object[] { p.resolveFile(value) });", "+        }", "-        } else if (EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {", "+        if (EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {", "-                        EnumeratedAttribute ea =", "-                            (EnumeratedAttribute) reflectedArg.newInstance();", "+                        EnumeratedAttribute ea = (EnumeratedAttribute) reflectedArg.newInstance();", "-                        m.invoke(parent, new Object[] {ea});", "+                        m.invoke(parent, new Object[] { ea });", "-        } else if (reflectedArg.getSuperclass() != null", "-                   && reflectedArg.getSuperclass().getName().equals(\"java.lang.Enum\")) {", "+        }", "+        Class enumClass = null;", "+        try {", "+            enumClass = Class.forName(\"java.lang.Enum\");", "+        } catch (ClassNotFoundException e) {", "+            //ignore", "+        }", "+        if (enumClass != null && enumClass.isAssignableFrom(reflectedArg)) {", "-                            throw new BuildException(", "-                                \"'\" + value + \"' is not a permitted value for \"", "-                                + reflectedArg.getName());", "-                        } else {", "-                            //only if the exception is not an IllegalArgument, do we hand off", "-                            //to extractBuildException() to get the buildexception from the InvocationTarget", "-                            throw extractBuildException(x);", "+                            throw new BuildException(\"'\" + value + \"' is not a permitted value for \"", "+                                    + reflectedArg.getName());", "+                        //only if the exception is not an IllegalArgument do we request the", "+                        //BuildException via extractBuildException():", "+                        throw extractBuildException(x);", "-        } else if (java.lang.Long.class.equals(reflectedArg)) {", "+        }", "+        if (java.lang.Long.class.equals(reflectedArg)) {", "-                    long ell;", "-                        ell = StringUtils.parseHumanSizes(value);", "+                        m.invoke(parent, new Object[] {", "+                                new Long(StringUtils.parseHumanSizes(value)) });", "+                    } catch (InvocationTargetException e) {", "+                        throw e;", "+                    } catch (IllegalAccessException e) {", "+                        throw e;", "-                    }", "-                    m.invoke(parent, new Object[] { new Long(ell) });", "-                }", "-            };", "-        } else {", "-        // worst case. look for a public String constructor and use it", "-        // also supports new Whatever(Project, String) as for Path or Reference", "-        // This is used (deliberately) for all primitives/wrappers other than", "-        // char, boolean, and long.", "-            boolean includeProject;", "-            Constructor c;", "-            try {", "-                // First try with Project.", "-                c = reflectedArg.getConstructor(new Class[] {Project.class, String.class});", "-                includeProject = true;", "-            } catch (NoSuchMethodException nme) {", "-                // OK, try without.", "-                try {", "-                    c = reflectedArg.getConstructor(new Class[] {String.class});", "-                    includeProject = false;", "-                } catch (NoSuchMethodException nme2) {", "-                    // Well, no matching constructor.", "-                    return null;", "-                }", "-            }", "-            final boolean finalIncludeProject = includeProject;", "-            final Constructor finalConstructor = c;", "-", "-            return new AttributeSetter(m) {", "-                public void set(Project p, Object parent, String value)", "-                        throws InvocationTargetException, IllegalAccessException, BuildException {", "-                    try {", "-                        Object[] args = (finalIncludeProject)", "-                            ? new Object[] {p, value} : new Object[] {value};", "-", "-                        Object attribute = finalConstructor.newInstance(args);", "-                        if (p != null) {", "-                            p.setProjectReference(attribute);", "-                        }", "-                        m.invoke(parent, new Object[] {attribute});", "-                    } catch (InstantiationException ie) {", "-                        throw new BuildException(ie);", "+        // worst case. look for a public String constructor and use it", "+        // also supports new Whatever(Project, String) as for Path or Reference", "+        // This is used (deliberately) for all primitives/wrappers other than", "+        // char, boolean, and long.", "+        boolean includeProject;", "+        Constructor c;", "+        try {", "+            // First try with Project.", "+            c = reflectedArg.getConstructor(new Class[] {Project.class, String.class});", "+            includeProject = true;", "+        } catch (NoSuchMethodException nme) {", "+            // OK, try without.", "+            try {", "+                c = reflectedArg.getConstructor(new Class[] {String.class});", "+                includeProject = false;", "+            } catch (NoSuchMethodException nme2) {", "+                // Well, no matching constructor.", "+                return null;", "+            }", "+        }", "+        final boolean finalIncludeProject = includeProject;", "+        final Constructor finalConstructor = c;", "+", "+        return new AttributeSetter(m) {", "+            public void set(Project p, Object parent, String value)", "+                    throws InvocationTargetException, IllegalAccessException, BuildException {", "+                try {", "+                    Object[] args = finalIncludeProject", "+                            ? new Object[] {p, value} : new Object[] {value};", "+", "+                    Object attribute = finalConstructor.newInstance(args);", "+                    if (p != null) {", "+                        p.setProjectReference(attribute);", "+                    }", "+                    m.invoke(parent, new Object[] {attribute});", "+                } catch (InstantiationException ie) {", "+                    throw new BuildException(ie);", "+                }", "+            }", "+        };"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c426252c652f6827665c780a3c4313a", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/myrmidon/src/todo/org/apache/tools/ant/IntrospectionHelper.java", "commitBeforeChange": "e854f481c9a76b41680eb0f605de524556b059ad", "commitAfterChange": "7a3448dcea316f454dd0ba470f8b0825504ae309", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "      private IntrospectionHelper( final Class bean )", "signatureAfterChange": "      private IntrospectionHelper( final Class bean )         throws TaskException", "diff": ["+        throws TaskException", "-            final Method m = methods[i];", "+            final Method m = methods[ i ];", "-                 && args.length == 1 &&", "+                && args.length == 1 &&", "-                \"setLocation\".equals( name ) && org.apache.tools.ant.Location.class.equals( args[0] )", "-                 ) || (", "-                \"setTaskType\".equals( name ) && java.lang.String.class.equals( args[0] )", "-                 )", "-                 ) )", "+                \"setLocation\".equals( name ) && org.apache.tools.ant.Location.class.equals( args[ 0 ] )", "+                ) || (", "+                \"setTaskType\".equals( name ) && java.lang.String.class.equals( args[ 0 ] )", "+                )", "+                ) )", "-                 && args.length == 1 && \"addTask\".equals( name )", "-                 && org.apache.tools.ant.Task.class.equals( args[0] ) )", "+                && args.length == 1 && \"addTask\".equals( name )", "+                && org.apache.tools.ant.Task.class.equals( args[ 0 ] ) )", "-                 && java.lang.Void.TYPE.equals( returnType )", "-                 && args.length == 1", "-                 && java.lang.String.class.equals( args[0] ) )", "+                && java.lang.Void.TYPE.equals( returnType )", "+                && args.length == 1", "+                && java.lang.String.class.equals( args[ 0 ] ) )", "-                addText = methods[i];", "+                addText = methods[ i ];", "-                 && java.lang.Void.TYPE.equals( returnType )", "-                 && args.length == 1", "-                 && !args[0].isArray() )", "+                && java.lang.Void.TYPE.equals( returnType )", "+                && args.length == 1", "+                && !args[ 0 ].isArray() )", "-                    if( java.lang.String.class.equals( args[0] ) )", "+                    if( java.lang.String.class.equals( args[ 0 ] ) )", "-                AttributeSetter as = createAttributeSetter( m, args[0] );", "+                AttributeSetter as = createAttributeSetter( m, args[ 0 ] );", "-                    attributeTypes.put( propName, args[0] );", "+                    attributeTypes.put( propName, args[ 0 ] );", "-                 && !returnType.isArray()", "-                 && !returnType.isPrimitive()", "-                 && args.length == 0 )", "+                && !returnType.isArray()", "+                && !returnType.isPrimitive()", "+                && args.length == 0 )", "-                    new NestedCreator()", "-                    {", "+                                    new NestedCreator()", "+                                    {", "-                        public Object create( Object parent )", "-                            throws InvocationTargetException,", "-                            IllegalAccessException", "-                        {", "+                                        public Object create( Object parent )", "+                                            throws InvocationTargetException,", "+                                            IllegalAccessException", "+                                        {", "-                            return m.invoke( parent, new Object[]{} );", "-                        }", "+                                            return m.invoke( parent, new Object[]{} );", "+                                        }", "-                    } );", "+                                    } );", "-                 && java.lang.Void.TYPE.equals( returnType )", "-                 && args.length == 1", "-                 && !java.lang.String.class.equals( args[0] )", "-                 && !args[0].isArray()", "-                 && !args[0].isPrimitive() )", "+                && java.lang.Void.TYPE.equals( returnType )", "+                && args.length == 1", "+                && !java.lang.String.class.equals( args[ 0 ] )", "+                && !args[ 0 ].isArray()", "+                && !args[ 0 ].isPrimitive() )", "-                        args[0].getConstructor( new Class[]{} );", "+                        args[ 0 ].getConstructor( new Class[]{} );", "-                    nestedTypes.put( propName, args[0] );", "+                    nestedTypes.put( propName, args[ 0 ] );", "-                        new NestedCreator()", "-                        {", "+                                        new NestedCreator()", "+                                        {", "-                            public Object create( Object parent )", "-                                throws InvocationTargetException, IllegalAccessException, InstantiationException", "-                            {", "+                                            public Object create( Object parent )", "+                                                throws InvocationTargetException, IllegalAccessException, InstantiationException", "+                                            {", "-                                Object o = c.newInstance( new Object[]{} );", "-                                return o;", "-                            }", "+                                                Object o = c.newInstance( new Object[]{} );", "+                                                return o;", "+                                            }", "-                        } );", "+                                        } );", "-                        new NestedStorer()", "-                        {", "+                                       new NestedStorer()", "+                                       {", "-                            public void store( Object parent, Object child )", "-                                throws InvocationTargetException, IllegalAccessException, InstantiationException", "-                            {", "+                                           public void store( Object parent, Object child )", "+                                               throws InvocationTargetException, IllegalAccessException, InstantiationException", "+                                           {", "-                                m.invoke( parent, new Object[]{child} );", "-                            }", "+                                               m.invoke( parent, new Object[]{child} );", "+                                           }", "-                        } );", "+                                       } );", "-                 && java.lang.Void.TYPE.equals( returnType )", "-                 && args.length == 1", "-                 && !java.lang.String.class.equals( args[0] )", "-                 && !args[0].isArray()", "-                 && !args[0].isPrimitive() )", "+                && java.lang.Void.TYPE.equals( returnType )", "+                && args.length == 1", "+                && !java.lang.String.class.equals( args[ 0 ] )", "+                && !args[ 0 ].isArray()", "+                && !args[ 0 ].isPrimitive() )", "-                        args[0].getConstructor( new Class[]{} );", "+                        args[ 0 ].getConstructor( new Class[]{} );", "-                    nestedTypes.put( propName, args[0] );", "+                    nestedTypes.put( propName, args[ 0 ] );", "-                        new NestedCreator()", "-                        {", "+                                        new NestedCreator()", "+                                        {", "-                            public Object create( Object parent )", "-                                throws InvocationTargetException, IllegalAccessException, InstantiationException", "-                            {", "+                                            public Object create( Object parent )", "+                                                throws InvocationTargetException, IllegalAccessException, InstantiationException", "+                                            {", "-                                Object o = c.newInstance( new Object[]{} );", "-                                m.invoke( parent, new Object[]{o} );", "-                                return o;", "-                            }", "+                                                Object o = c.newInstance( new Object[]{} );", "+                                                m.invoke( parent, new Object[]{o} );", "+                                                return o;", "+                                            }", "-                        } );", "+                                        } );"]}]}