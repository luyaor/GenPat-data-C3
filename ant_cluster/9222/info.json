{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "54faa832e6fc043e107042a82f82b755", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "180c33e639d4429a3270d1f691c43301", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/script/ScriptDef.java", "commitBeforeChange": "a812b0a411cf480013ea88e0a272d82143be4702", "commitAfterChange": "e00d04fd4a3b08756835d0238168daa01cd701b0", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 11, "signatureBeforeChange": "     public void executeScript(RuntimeConfigurable scriptConfig, List elements)", "signatureAfterChange": "     public void executeScript(Map attributes, Map elements)", "diff": ["-    public void executeScript(RuntimeConfigurable scriptConfig, List elements) {", "-        ", "-        Map configAttributes = scriptConfig.getAttributeMap();", "-        for (Iterator i = configAttributes.keySet().iterator(); i.hasNext();) {", "-            String attributeName = (String) i.next();", "-            if (!attributeSet.contains(attributeName)) {", "-                throw new BuildException(\"<\" + name + \"> does not support \" ", "-                    + \"the \\\"\" + attributeName + \"\\\" attribute\");", "-            }", "-        }", "-", "-        // handle nested elements", "-        Map elementInstances = new HashMap();", "-        for (Iterator i = elements.iterator(); i.hasNext();) {", "-            UnknownElement element = (UnknownElement) i.next();", "-            String elementTag = element.getTag().toLowerCase(Locale.US);", "-            ", "-            NestedElement definition ", "-                = (NestedElement) nestedElementMap.get(elementTag);", "-            if (definition == null) {                ", "-                throw new BuildException(\"<\" + name + \"> does not support \" ", "-                    + \"the <\" + elementTag + \"> nested element\");", "-            }", "-            ", "-            // what is the type of the object to be created", "-            Object instance = null;", "-            String classname = definition.className;", "-            if (classname == null) {", "-                instance = getProject().createTask(definition.type);", "-                if (instance == null) {", "-                    instance = getProject().createDataType(definition.type);", "-                }", "-            } else {", "-                // try the context classloader", "-                ClassLoader loader ", "-                    = Thread.currentThread().getContextClassLoader();", "-                ", "-                Class instanceClass = null;", "-                try {", "-                    instanceClass = Class.forName(classname, true, loader);", "-                } catch (Throwable e) {", "-                    // try normal method", "-                    try {", "-                        instanceClass = Class.forName(classname);", "-                    } catch (Throwable e2) {", "-                        throw new BuildException(\"scriptdef: Unable to load \" ", "-                            + \"class \" + classname + \" for nested element <\" ", "-                            + elementTag + \">\", e2);", "-                    }", "-                }", "-                ", "-                try {", "-                    instance = instanceClass.newInstance();", "-                } catch (Throwable e) {", "-                    throw new BuildException(\"scriptdef: Unable to create \" ", "-                        + \"element of class \" + classname + \" for nested \" ", "-                        + \"element <\" + elementTag + \">\", e);", "-                }", "-                getProject().setProjectReference(instance);", "-            }", "-            ", "-            if (instance == null) {", "-                throw new BuildException(\"<\" + name + \"> is unable to create \" ", "-                    + \"the <\" + elementTag + \"> nested element\");", "-            }", "-", "-            element.configure(instance);", "-            ", "-            // find the appropriate list", "-            List instanceList = (List) elementInstances.get(elementTag);", "-            if (instanceList == null) {", "-                instanceList = new ArrayList();", "-                elementInstances.put(elementTag, instanceList);", "-            }", "-            instanceList.add(instance);", "-        }", "-        ", "+    public void executeScript(Map attributes, Map elements) {", "-            manager.declareBean(\"attributes\", configAttributes, ", "-                configAttributes.getClass());", "-            manager.declareBean(\"elements\", elementInstances, ", "-                elementInstances.getClass());", "+            manager.declareBean(\"attributes\", attributes, ", "+                attributes.getClass());", "+            manager.declareBean(\"elements\", elements, ", "+                elements.getClass());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "234fe495a04faa523c9be2e548a8ef91", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/filters/ReplaceTokens.java", "commitBeforeChange": "ca4d619112299ab28dd289a2e0e407ddebc6340c", "commitAfterChange": "6e88f92ead6a5f67935055661a9e8041f5ed8bae", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public int read() throws IOException", "signatureAfterChange": "     public int read() throws IOException", "diff": ["-        if (replaceIndex != -1) {", "-            final int ch = replaceData.charAt(replaceIndex++);", "-            if (replaceIndex >= replaceData.length()) {", "-                replaceIndex = -1;", "+        if (!resolvedTokensBuilt) {", "+            // build the resolved tokens tree map.", "+            for (String key : hash.keySet()) {", "+                resolvedTokens.put(beginToken + key + endToken, hash.get(key));", "-            return ch;", "+            resolvedTokensBuilt = true;", "-        int ch = getNextChar();", "-", "-        if (ch == beginToken) {", "-            final StringBuffer key = new StringBuffer(\"\");", "-            do  {", "-                ch = getNextChar();", "-                if (ch != -1) {", "-                    key.append((char) ch);", "-                } else {", "-                    break;", "-                }", "-            } while (ch != endToken);", "-", "-            if (ch == -1) {", "-                if (queuedData == null || queueIndex == -1) {", "-                    queuedData = key.toString();", "-                } else {", "-                    queuedData", "-                        = key.toString() + queuedData.substring(queueIndex);", "-                }", "-                if (queuedData.length() > 0) {", "-                    queueIndex = 0;", "-                } else {", "-                    queueIndex = -1;", "-                }", "-                return beginToken;", "+        // are we currently serving replace data?", "+        if (replaceData != null) {", "+            if (replaceIndex < replaceData.length()) {", "+                return replaceData.charAt(replaceIndex++);", "-                key.setLength(key.length() - 1);", "+                replaceData = null;", "+            }", "+        }", "-                final String replaceWith = (String) hash.get(key.toString());", "-                if (replaceWith != null) {", "-                    if (replaceWith.length() > 0) {", "-                        replaceData = replaceWith;", "-                        replaceIndex = 0;", "-                    }", "-                    return read();", "+        // is the read buffer empty?", "+        if (readBuffer.length() == 0) {", "+            int next = in.read();", "+            if (next == -1) {", "+                return next; // end of stream. all buffers empty.", "+            }", "+            readBuffer += (char)next;", "+        }", "+", "+        for (;;) {", "+            // get the closest tokens", "+            SortedMap<String,String> possibleTokens = resolvedTokens.tailMap(readBuffer);", "+            if (possibleTokens.isEmpty() || !possibleTokens.firstKey().startsWith(readBuffer)) { // if there is none, then deliver the first char from the buffer.", "+                return getFirstCharacterFromReadBuffer();", "+            } else if (readBuffer.equals(possibleTokens.firstKey())) { // there exists a nearest token - is it an exact match?", "+                // we have found a token. prepare the replaceData buffer.", "+                replaceData = resolvedTokens.get(readBuffer);", "+                replaceIndex = 0;", "+                readBuffer = \"\"; // destroy the readBuffer - it's contents are being replaced entirely.", "+                // get the first character via recursive call.", "+                return read();", "+            } else { // nearest token is not matching exactly - read one character more.", "+                int next = in.read();", "+                if (next != -1) {", "+                    readBuffer += (char)next;", "-                    String newData = key.toString() + endToken;", "-                    if (queuedData == null || queueIndex == -1) {", "-                        queuedData = newData;", "-                    } else {", "-                        queuedData = newData + queuedData.substring(queueIndex);", "-                    }", "-                    queueIndex = 0;", "-                    return beginToken;", "+                    return getFirstCharacterFromReadBuffer(); // end of stream. deliver remaining characters from buffer.", "-        return ch;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "767ab0a27bcbeb06ed237daacf7c670e", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/unix/Symlink.java", "commitBeforeChange": "1331049054d53ef94674a4966e7000bbf8baf6be", "commitAfterChange": "472c46251f1e0f3c7e68528f23617f21b80366cb", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "     public static void deleteSymlink(File linkfil, Task task)         throws IOException", "signatureAfterChange": "     public static void deleteSymlink(File linkfil, Task task)         throws IOException", "diff": ["-        // rename the resource, thus breaking the link:", "-        File temp = FILE_UTILS.createTempFile(\"symlink\", \".tmp\",", "-                                              canfil.getParentFile(), false,", "-                                              false);", "+            // rename the resource, thus breaking the link:", "+            File temp = FILE_UTILS.createTempFile(\"symlink\", \".tmp\",", "+                                                  canfil.getParentFile(), false,", "+                                                  false);", "-        if (FILE_UTILS.isLeadingPath(canfil, linkfil)) {", "-            // link points to a parent directory, renaming the parent", "-            // will rename the file", "-            linkfil = new File(temp,", "-                               FILE_UTILS.removeLeadingPath(canfil, linkfil));", "-        }", "+            if (FILE_UTILS.isLeadingPath(canfil, linkfil)) {", "+                // link points to a parent directory, renaming the parent", "+                // will rename the file", "+                linkfil = new File(temp,", "+                                   FILE_UTILS.removeLeadingPath(canfil,", "+                                                                linkfil));", "+            }", "-        boolean renamedTarget = false;", "-        try {", "+            boolean renamedTarget = false;", "-                FILE_UTILS.rename(canfil, temp);", "-                renamedTarget = true;", "-            } catch (IOException e) {", "-                throw new IOException(", "-                    \"Couldn't rename resource when attempting to delete \"", "-                    + linkfil);", "-            }", "-            // delete the (now) broken link:", "-            if (!linkfil.delete()) {", "-                throw new IOException(\"Couldn't delete symlink: \" + linkfil", "-                    + \" (was it a real file? is this not a UNIX system?)\");", "-            }", "-        } finally {", "-            if (renamedTarget) {", "-                // return the resource to its original name:", "-                    FILE_UTILS.rename(temp, canfil);", "+                    FILE_UTILS.rename(canfil, temp);", "+                    renamedTarget = true;", "-                    throw new IOException(\"Couldn't return resource \" + temp", "-                                          + \" to its original name: \"", "-                                          + canfil.getAbsolutePath()", "-                                          + \"\\n THE RESOURCE'S NAME ON DISK HAS \"", "-                                          + \"BEEN CHANGED BY THIS ERROR!\\n\");", "+                    throw new IOException(\"Couldn't rename resource when \"", "+                                          + \"attempting to delete \" + linkfil);", "+                }", "+                // delete the (now) broken link:", "+                if (!linkfil.delete()) {", "+                    throw new IOException(\"Couldn't delete symlink: \"", "+                                          + linkfil", "+                                          + \" (was it a real file? is this \"", "+                                          + \"not a UNIX system?)\");", "+                }", "+            } finally {", "+                if (renamedTarget) {", "+                    // return the resource to its original name:", "+                    try {", "+                        FILE_UTILS.rename(temp, canfil);", "+                    } catch (IOException e) {", "+                        throw new IOException(\"Couldn't return resource \"", "+                                              + temp", "+                                              + \" to its original name: \"", "+                                              + canfil.getAbsolutePath()", "+                                              + \"\\n THE RESOURCE'S NAME ON DISK\"", "+                                              + \" HAS BEEN CHANGED BY THIS\"", "+                                              + \" ERROR!\\n\");", "+                    }", "-        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "97420038f274b6514e68032f216c4e31", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/mutant/src/java/antcore/org/apache/ant/antcore/antlib/AntLibManager.java", "commitBeforeChange": "65b70febb53b077317c4d678291f9af547c3d116", "commitAfterChange": "f9d1c1691c7e9d80b793f5178f6113c949fc2441", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public void addAntLibraries(Map librarySpecs, URL libURL)          throws MalformedURLException, ExecutionException", "signatureAfterChange": "     public void addAntLibraries(Map librarySpecs, URL libURL)          throws AntLibException", "diff": ["-         throws MalformedURLException, ExecutionException {", "-        URL[] libURLs = LoaderUtils.getLocationURLs(libURL, libURL.toString(),", "-            ANTLIB_EXTENSIONS);", "+         throws AntLibException {", "+        try {", "+            URL[] libURLs = LoaderUtils.getLocationURLs(libURL,", "+                libURL.toString(), ANTLIB_EXTENSIONS);", "-        if (libURLs == null) {", "-            return;", "-        }", "+            if (libURLs == null) {", "+                return;", "+            }", "-        // parse each task library to get its library definition", "-        for (int i = 0; i < libURLs.length; ++i) {", "-            URL antLibraryURL = new URL(\"jar:\" + libURLs[i]", "-                 + \"!/META-INF/antlib.xml\");", "-            try {", "-                AntLibrarySpec antLibrarySpec = parseLibraryDef(antLibraryURL);", "-                if (antLibrarySpec != null) {", "-                    String libraryId = antLibrarySpec.getLibraryId();", "-                    if (librarySpecs.containsKey(libraryId)) {", "-                        AntLibrarySpec currentSpec ", "-                            = (AntLibrarySpec) librarySpecs.get(libraryId);", "-                        throw new ExecutionException(\"Found more than one \"", "-                             + \"copy of library with id = \" + libraryId ", "-                             + \" (\" + libURLs[i] + \") + existing library at (\"", "-                             + currentSpec.getLibraryURL() + \")\");", "+            // parse each task library to get its library definition", "+            for (int i = 0; i < libURLs.length; ++i) {", "+                URL antLibraryURL = new URL(\"jar:\" + libURLs[i]", "+                     + \"!/META-INF/antlib.xml\");", "+                try {", "+                    AntLibrarySpec antLibrarySpec", "+                        = parseLibraryDef(antLibraryURL);", "+                    if (antLibrarySpec != null) {", "+                        String libraryId = antLibrarySpec.getLibraryId();", "+                        if (librarySpecs.containsKey(libraryId)) {", "+                            AntLibrarySpec currentSpec", "+                                = (AntLibrarySpec) librarySpecs.get(libraryId);", "+                            throw new AntLibException(\"Found more than one \"", "+                                 + \"copy of library with id = \" + libraryId", "+                                 + \" (\" + libURLs[i] + \") + existing library \"", "+                                 + \"at (\" + currentSpec.getLibraryURL() + \")\");", "+                        }", "+                        antLibrarySpec.setLibraryURL(libURLs[i]);", "+                        librarySpecs.put(libraryId, antLibrarySpec);", "-                    antLibrarySpec.setLibraryURL(libURLs[i]);", "-                    librarySpecs.put(libraryId, antLibrarySpec);", "-                }", "-            } catch (XMLParseException e) {", "-                Throwable t = e.getCause();", "-                // ignore file not found exceptions - means the", "-                // jar does not provide META-INF/antlib.xml", "-                if (!(t instanceof FileNotFoundException)) {", "-                    throw new ExecutionException(\"Unable to parse Ant library \"", "-                         + libURLs[i], e);", "+                } catch (XMLParseException e) {", "+                    Throwable t = e.getCause();", "+                    // ignore file not found exceptions - means the", "+                    // jar does not provide META-INF/antlib.xml", "+                    if (t instanceof AntLibException) {", "+                        throw (AntLibException) t;", "+                    } else if (!(t instanceof FileNotFoundException)) {", "+                        throw new AntLibException(\"Unable to parse Ant \"", "+                            + \"library \" + libURLs[i], e);", "+                    }", "+        } catch (MalformedURLException e) {", "+            throw new AntLibException(\"Unable to load libraries from \"", "+                + libURL, e);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a04a6ac65df75bd9bf837d30c864e58b", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java", "commitBeforeChange": "b0b920b08fae74de3fd7a7dd5efbca9e8cf379e6", "commitAfterChange": "114d55869f46b382375b6b32ddc17bb2e5fc598c", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 12, "signatureBeforeChange": "     public void run()", "signatureAfterChange": "     public void run()", "diff": ["+                final boolean testMethodsSpecified = (methods != null);", "+", "+                if (!testMethodsSpecified) {", "+                }", "+                    boolean useSingleMethodAdapter = false;", "+                    if (junit.framework.TestCase.class.isAssignableFrom(testClass)) {", "+                        // Do not use JUnit 4 API for running JUnit 3.x", "+                        // tests - it is not able to run individual test", "+                        // methods.", "+                        //", "+                        // Technical details:", "+                        // org.junit.runner.Request.method(Class, String).getRunner()", "+                        // would return a runner which always executes all", "+                        // test methods. The reason is that the Runner would be", "+                        // an instance of class", "+                        // org.junit.internal.runners.OldTestClassRunner", "+                        // that does not implement interface Filterable - so it", "+                        // is unable to filter out test methods not matching", "+                        // the requested name.", "+                    } else {", "+                            if (testMethodsSpecified) {", "+                                /*", "+                                 * We cannot try to load the JUnit4TestAdapter", "+                                 * before trying to load JUnit4TestMethodAdapter", "+                                 * because it might fail with", "+                                 * NoClassDefFoundException, instead of plain", "+                                 * ClassNotFoundException.", "+                                 */", "+                                junit4TestAdapterClass = Class.forName(", "+                                    \"org.apache.tools.ant.taskdefs.optional.junit.JUnit4TestMethodAdapter\");", "+                                useSingleMethodAdapter = true;", "+                            }", "+                            if (testMethodsSpecified) {", "+                                junit4TestAdapterClass =", "+                                    Class.forName(", "+                                        \"org.apache.tools.ant.taskdefs.optional.junit.JUnit4TestMethodAdapter\",", "+                                        true, loader);", "+                                useSingleMethodAdapter = true;", "+                            }", "+                    }", "+                        Class[] formalParams;", "+                        Object[] actualParams;", "+                        if (useSingleMethodAdapter) {", "+                            formalParams = new Class[] {Class.class, String[].class};", "+                            actualParams = new Object[] {testClass, methods};", "+                        } else {", "+                            formalParams = new Class[] {Class.class};", "+                            actualParams = new Object[] {testClass};", "+                        }", "-                            .getConstructor(new Class[] {Class.class}).", "-                            newInstance(new Object[] {testClass});", "+                            .getConstructor(formalParams).", "+                            newInstance(actualParams);", "-                        suite = new TestSuite(testClass);", "+                        if (!testMethodsSpecified) {", "+                            suite = new TestSuite(testClass);", "+                        } else if (methods.length == 1) {", "+                            suite = TestSuite.createTest(testClass, methods[0]);", "+                        } else {", "+                            TestSuite testSuite = new TestSuite(testClass.getName());", "+                            for (int i = 0; i < methods.length; i++) {", "+                                testSuite.addTest(", "+                                    TestSuite.createTest(testClass, methods[i]));", "+                            }", "+                            suite = testSuite;", "+                        }"]}]}