{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fbbcbc0cec79e25792607480783a9a85", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c61d58184105b570649f13fa95d1118", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Zip.java", "commitBeforeChange": "b9c9d1a29c79e175c65cf22876c0cfec0e8d4ced", "commitAfterChange": "d180ff4e655f2160229d8c45dac21ab6a66d6b3b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": "      protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath)         throws IOException", "signatureAfterChange": "      protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath)         throws IOException", "diff": ["+", "+        /*", "+         * XXX ZipOutputStream.putEntry expects the ZipEntry to know its", "+         * size and the CRC sum before you start writing the data when using ", "+         * STORED mode.", "+         *", "+         * This forces us to process the data twice.", "+         *", "+         * I couldn't find any documentation on this, just found out by try ", "+         * and error.", "+         */", "+        if (!doCompress) {", "+            long size = 0;", "+            CRC32 cal = new CRC32();", "+            if (!in.markSupported()) {", "+                // Store data into a byte[]", "+                ByteArrayOutputStream bos = new ByteArrayOutputStream();", "+", "+                byte[] buffer = new byte[8 * 1024];", "+                int count = 0;", "+                do {", "+                    size += count;", "+                    cal.update(buffer, 0, count);", "+                    bos.write(buffer, 0, count);", "+                    count = in.read(buffer, 0, buffer.length);", "+                } while (count != -1);", "+                in = new ByteArrayInputStream(bos.toByteArray());", "+", "+            } else {", "+                in.mark(Integer.MAX_VALUE);", "+                byte[] buffer = new byte[8 * 1024];", "+                int count = 0;", "+                do {", "+                    size += count;", "+                    cal.update(buffer, 0, count);", "+                    count = in.read(buffer, 0, buffer.length);", "+                } while (count != -1);", "+                in.reset();", "+            }", "+            ze.setSize(size);", "+            ze.setCrc(cal.getValue());", "+        }", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e4cd287ff8cc63c1d6e054219d374896", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/tar/TarOutputStream.java", "commitBeforeChange": "b43f4224d8fe9d1e7d628e88df394a7dfed46d1b", "commitAfterChange": "2e5b53fa106b848646493cb6f6ea74616973aca0", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 14, "signatureBeforeChange": "     public void putNextEntry(TarEntry entry) throws IOException", "signatureAfterChange": "     public void putNextEntry(TarEntry entry) throws IOException", "diff": ["-        if (entry.getName().length() >= TarConstants.NAMELEN) {", "+        if(finished) {", "+            throw new IOException(\"Stream has already been finished\");", "+        }", "+        Map<String, String> paxHeaders = new HashMap<String, String>();", "+        final String entryName = entry.getName();", "+        final byte[] nameBytes = encoding.encode(entryName).array();", "+        boolean paxHeaderContainsPath = false;", "+        if (nameBytes.length >= TarConstants.NAMELEN) {", "-            if (longFileMode == LONGFILE_GNU) {", "+            if (longFileMode == LONGFILE_POSIX) {", "+                paxHeaders.put(\"path\", entryName);", "+                paxHeaderContainsPath = true;", "+            } else if (longFileMode == LONGFILE_GNU) {", "-                longLinkEntry.setSize(entry.getName().length() + 1);", "+                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL", "-                write(entry.getName().getBytes());", "-                write(0);", "+                write(nameBytes);", "+                write(0); // NUL terminator", "-                throw new RuntimeException(\"file name '\" + entry.getName()", "-                                             + \"' is too long ( > \"", "-                                             + TarConstants.NAMELEN + \" bytes)\");", "+                throw new RuntimeException(\"file name '\" + entryName", "+                                           + \"' is too long ( > \"", "+                                           + TarConstants.NAMELEN + \" bytes)\");", "-        entry.writeEntryHeader(recordBuf);", "+        if (bigNumberMode == BIGNUMBER_POSIX) {", "+            addPaxHeadersForBigNumbers(paxHeaders, entry);", "+        } else if (bigNumberMode != BIGNUMBER_STAR) {", "+            failForBigNumbers(entry);", "+        }", "+", "+        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath", "+            && !ASCII.canEncode(entryName)) {", "+            paxHeaders.put(\"path\", entryName);", "+        }", "+", "+        if (addPaxHeadersForNonAsciiNames", "+            && (entry.isLink() || entry.isSymbolicLink())", "+            && !ASCII.canEncode(entry.getLinkName())) {", "+            paxHeaders.put(\"linkpath\", entry.getLinkName());", "+        }", "+", "+        if (paxHeaders.size() > 0) {", "+            writePaxHeaders(entryName, paxHeaders);", "+        }", "+", "+        entry.writeEntryHeader(recordBuf, encoding,", "+                               bigNumberMode == BIGNUMBER_STAR);", "-        currName = entry.getName();", "+        currName = entryName;", "+        haveUnclosedEntry = true;"]}]}