{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4ec12af0a9f132a4f68284147bee6c4f", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b6a3a92ec2b765c8b13867ff56f82b48", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/IntrospectionHelper.java", "commitBeforeChange": "149ce34431423cd116e5d7175ff281c30565aa6a", "commitAfterChange": "5460755b447223e93e926e11a08e4df4f0e0ddb5", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     private IntrospectionHelper(final Class bean)", "signatureAfterChange": "     private IntrospectionHelper(final Class bean)", "diff": ["-        nestedStorers = new Hashtable();", "-                && (name.equals(\"add\") /*|| name.equals(\"addConfigured\")*/)) {", "+                && (name.equals(\"add\") || name.equals(\"addConfigured\"))) {", "-                nestedTypes.put(propName, returnType);", "-                nestedCreators.put(propName, new NestedCreator() {", "+                // Check if a create of this property is already present", "+                // add takes preference over create for CB purposes", "+                if (nestedCreators.get(propName) == null) {", "+                    nestedTypes.put(propName, returnType);", "+                    nestedCreators.put(propName, new NestedCreator() {", "-                        public Object create(Object parent)", "+                        public boolean isPolyMorphic() {", "+                            return false;", "+                        }", "+", "+                        public Class getElementClass() {", "+                            return null;", "+                        }", "+", "+                        public Object create(", "+                            Project project, Object parent, Object ignore)", "-", "+                        public void store(Object parent, Object child) {", "+                        }", "-                nestedStorers.remove(propName);", "-", "+                }", "-                    final Constructor c =", "-                        args[0].getConstructor(new Class[] {});", "+                    Constructor constructor = null;", "+                    try {", "+                        constructor =", "+                            args[0].getConstructor(new Class[] {});", "+                    } catch (NoSuchMethodException ex) {", "+                        constructor =", "+                            args[0].getConstructor(new Class[] {", "+                                Project.class});", "+                    }", "+                    final Constructor c = constructor;", "-                            public Object create(Object parent)", "-                                throws InvocationTargetException, IllegalAccessException, InstantiationException {", "-", "-                                Object o = c.newInstance(new Object[] {});", "-                                return o;", "+                            public boolean isPolyMorphic() {", "+                                return true;", "-                        });", "-                    nestedStorers.put(propName, new NestedStorer() {", "+                            public Class getElementClass() {", "+                                return c.getDeclaringClass();", "+                            }", "+", "+                            public Object create(", "+                                Project project, Object parent, Object child)", "+                                throws InvocationTargetException,", "+                                IllegalAccessException, InstantiationException {", "+                                if (child != null) {", "+                                    return child;", "+                                } else if (c.getParameterTypes().length == 0) {", "+                                    return c.newInstance(new Object[] {});", "+                                } else {", "+                                    return c.newInstance(new Object[] {", "+                                        project});", "+                                }", "+                            }", "-                                throws InvocationTargetException, IllegalAccessException, InstantiationException {", "+                                throws InvocationTargetException,", "+                                IllegalAccessException, InstantiationException {", "-                    final Constructor c =", "-                        args[0].getConstructor(new Class[] {});", "+                    Constructor constructor = null;", "+                    try {", "+                        constructor =", "+                            args[0].getConstructor(new Class[] {});", "+                    } catch (NoSuchMethodException ex) {", "+                        constructor =", "+                            args[0].getConstructor(new Class[] {", "+                                Project.class});", "+                    }", "+                    final Constructor c = constructor;", "-                            public Object create(Object parent)", "-                                throws InvocationTargetException, IllegalAccessException, InstantiationException {", "+                            public boolean isPolyMorphic() {", "+                                return true;", "+                            }", "-                                Object o = c.newInstance(new Object[] {});", "-                                m.invoke(parent, new Object[] {o});", "-                                return o;", "+                            public Class getElementClass() {", "+                                return c.getDeclaringClass();", "+                            }", "+", "+                            public Object create(", "+                                Project project, Object parent, Object child)", "+                                throws InvocationTargetException,", "+                                       IllegalAccessException, InstantiationException {", "+                                if (child != null) {", "+                                    // ignore", "+                                } else if (c.getParameterTypes().length == 0) {", "+                                    child = c.newInstance(new Object[] {});", "+                                } else {", "+                                    child = c.newInstance(new Object[] {", "+                                        project});", "+                                }", "+                                m.invoke(parent, new Object[] {child});", "+                                return child;", "+                            }", "+                            public void store(Object parent, Object child)", "+                                throws InvocationTargetException,", "+                                       IllegalAccessException, InstantiationException {", "+", "-                    nestedStorers.remove(name);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c2d8b3b8191738853c84decb552172ab", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Zip.java", "commitBeforeChange": "e5fcb123200cbdf1faccaf2a57fdf8c1e272d8bb", "commitAfterChange": "ec2d68aa71e1dfc8503b4a74f04d8ebd9bc02561", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 10, "signatureBeforeChange": "      public void execute() throws BuildException", "signatureAfterChange": "      public void execute() throws BuildException", "diff": ["+        // Renamed version of original file, if it exists", "+        File renamedFile=null;", "+        // Whether or not an actual update is required -", "+        // we don't need to update if the original file doesn't exist", "+        boolean reallyDoUpdate=false;", "+        if (doUpdate && zipFile.exists())", "+        {", "+            reallyDoUpdate=true;", "+            ", "+            int i;", "+            for (i=0; i < 1000; i++)", "+            {", "+                renamedFile = new File (zipFile.getParent(), \"tmp.\"+i);", "+                ", "+                if (!renamedFile.exists())", "+                    break;", "+            }", "+            if (i==1000)", "+                throw new BuildException ", "+                (\"Can't find temporary filename to rename old file to.\");", "+            try", "+            {", "+                if (!zipFile.renameTo (renamedFile))", "+                    throw new BuildException ", "+                    (\"Unable to rename old file to temporary file\");", "+            }", "+            catch (SecurityException e)", "+            {", "+                throw new BuildException ", "+                    (\"Not allowed to rename old file to temporary file\");", "+            }", "+        }", "+        ", "-        log(\"Building \"+ archiveType +\": \"+ zipFile.getAbsolutePath());", "+        String action=reallyDoUpdate ? \"Updating \" : \"Building \";", "+        ", "+        log(action + archiveType +\": \"+ zipFile.getAbsolutePath());", "+        boolean success = false;", "-            boolean success = false;", "+                if (reallyDoUpdate)", "+                {", "+                    ZipFileSet oldFiles = new ZipFileSet ();", "+                    oldFiles.setSrc (renamedFile);", "+                    ", "+                    StringBuffer exclusionPattern=new StringBuffer();", "+                    for (int i=0; i < addedFiles.size(); i++)", "+                    {", "+                        if (i != 0)", "+                            exclusionPattern.append (\",\");", "+                        exclusionPattern.append ", "+                            ((String) addedFiles.elementAt(i));", "+                    }", "+                    oldFiles.setExcludes (exclusionPattern.toString());", "+                    Vector tmp = new Vector();", "+                    tmp.addElement (oldFiles);", "+                    addFiles (tmp, zOut);", "+                }", "+            if (reallyDoUpdate) {", "+                if (!renamedFile.renameTo (zipFile)) {", "+                    msg+=\" (and I couldn't rename the temporary file \"+", "+                        renamedFile.getName()+\" back)\";", "+                }", "+            }", "+            ", "+        // If we've been successful on an update, delete the temporary file", "+        if (success && reallyDoUpdate)", "+            if (!renamedFile.delete())", "+                log (\"Warning: unable to delete temporary file \"+", "+                     renamedFile.getName(), Project.MSG_WARN);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c7ee1ec175b79c0345f5ad9d9c7118e3", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/tar/TarInputStream.java", "commitBeforeChange": "babc81c13536c029da523af8c7d9cb85a43521ac", "commitAfterChange": "79d125cc05d47c1e7540332740483650f38f13cf", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "     public int read(byte[] buf) throws IOException", "signatureAfterChange": "     public int read(byte[] buf, int offset, int numToRead) throws IOException", "diff": ["-     */", "-    public int read(byte[] buf) throws IOException {", "-        return this.read(buf, 0, buf.length);"]}]}