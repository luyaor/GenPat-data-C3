{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8fcc4e3401d6e785b8f1e6da1b4c055c", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "61c6f2625cca3de74095ffd0307ab722", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/bzip2/CBZip2OutputStream.java", "commitBeforeChange": "380870c2b26a9f3289569dc2451178df3f05613e", "commitAfterChange": "ad9edf5f5ea4a8f2a974726eeb8e656c177357df", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 26, "signatureBeforeChange": "     private void mainQSort3(final Data dataShadow, final int loSt, final int hiSt,                             final int dSt)", "signatureAfterChange": "      private void qSort3(int loSt, int hiSt, int dSt)", "diff": ["-     */", "-    private void mainQSort3(final Data dataShadow, final int loSt, final int hiSt,", "-                            final int dSt) {", "-        final int[] stack_ll = dataShadow.stack_ll;", "-        final int[] stack_hh = dataShadow.stack_hh;", "-        final int[] stack_dd = dataShadow.stack_dd;", "-        final int[] fmap     = dataShadow.fmap;", "-        final byte[] block   = dataShadow.block;", "-", "-        stack_ll[0] = loSt;", "-        stack_hh[0] = hiSt;", "-        stack_dd[0] = dSt;", "-", "-        for (int sp = 1; --sp >= 0;) {", "-            final int lo = stack_ll[sp];", "-            final int hi = stack_hh[sp];", "-            final int d = stack_dd[sp];", "-", "-            if ((hi - lo < SMALL_THRESH) || (d > DEPTH_THRESH)) {", "-                if (mainSimpleSort(dataShadow, lo, hi, d)) {", "-                    return;", "-                }", "-            } else {", "-                final int d1 = d + 1;", "-                final int med = med3(block[fmap[lo]              + d1],", "-                                     block[fmap[hi            ]  + d1],", "-                                     block[fmap[(lo + hi) >> 1]  + d1])", "-                    & 0xff;", "-", "-                int unLo = lo;", "-                int unHi = hi;", "-                int ltLo = lo;", "-                int gtHi = hi;", "-", "-                while (true) {", "-                    while (unLo <= unHi) {", "-                        final int n =", "-                            ((int) block[fmap[unLo] + d1] & 0xff) - med;", "-                        if (n == 0) {", "-                            final int temp = fmap[unLo];", "-                            fmap[unLo++] = fmap[ltLo];", "-                            fmap[ltLo++] = temp;", "-                        } else if (n < 0) {", "-                            unLo++;", "-                        } else {", "-                            break;", "-                        }", "-                    }", "-", "-                    while (unLo <= unHi) {", "-                        final int n =", "-                            ((int) block[fmap[unHi] + d1] & 0xff) - med;", "-                        if (n == 0) {", "-                            final int temp = fmap[unHi];", "-                            fmap[unHi--] = fmap[gtHi];", "-                            fmap[gtHi--] = temp;", "-                        } else if (n > 0) {", "-                            unHi--;", "-                        } else {", "-                            break;", "-                        }", "-                    }", "-", "-                    if (unLo <= unHi) {", "-                        final int temp = fmap[unLo];", "-                        fmap[unLo++] = fmap[unHi];", "-                        fmap[unHi--] = temp;", "-                    } else {", "-                if (gtHi < ltLo) {", "-                    stack_ll[sp] = lo;", "-                    stack_hh[sp] = hi;", "-                    stack_dd[sp] = d1;", "-                    sp++;", "-                } else {", "-                    int n = ((ltLo - lo) < (unLo - ltLo))", "-                        ? (ltLo - lo) : (unLo - ltLo);", "-                    vswap(fmap, lo, unLo - n, n);", "-                    int m = ((hi - gtHi) < (gtHi - unHi))", "-                        ? (hi - gtHi) : (gtHi - unHi);", "-                    vswap(fmap, unLo, hi - m + 1, m);", "-                    n = lo + unLo - ltLo - 1;", "-                    m = hi - (gtHi - unHi) + 1;", "-                    stack_ll[sp] = lo;", "-                    stack_hh[sp] = n;", "-                    stack_dd[sp] = d;", "-                    sp++;", "-", "-                    stack_ll[sp] = n + 1;", "-                    stack_hh[sp] = m - 1;", "-                    stack_dd[sp] = d1;", "-                    sp++;", "-", "-                    stack_ll[sp] = m;", "-                    stack_hh[sp] = hi;", "-                    stack_dd[sp] = d;", "-                    sp++;", "+", "+    private void qSort3(int loSt, int hiSt, int dSt) {", "+        int unLo, unHi, ltLo, gtHi, med, n, m;", "+        int sp, lo, hi, d;", "+        StackElem[] stack = new StackElem[QSORT_STACK_SIZE];", "+        for (int count = 0; count < QSORT_STACK_SIZE; count++) {", "+            stack[count] = new StackElem();", "+        }", "+", "+        sp = 0;", "+", "+        stack[sp].ll = loSt;", "+        stack[sp].hh = hiSt;", "+        stack[sp].dd = dSt;", "+        sp++;", "+", "+        while (sp > 0) {", "+            if (sp >= QSORT_STACK_SIZE) {", "+                panic();", "+            }", "+", "+            sp--;", "+            lo = stack[sp].ll;", "+            hi = stack[sp].hh;", "+            d = stack[sp].dd;", "+", "+            if (hi - lo < SMALL_THRESH || d > DEPTH_THRESH) {", "+                simpleSort(lo, hi, d);", "+                if (workDone > workLimit && firstAttempt) {", "+                    return;", "+                }", "+                continue;", "+            }", "+", "+            med = med3(block[zptr[lo] + d + 1],", "+                       block[zptr[hi            ] + d  + 1],", "+                       block[zptr[(lo + hi) >> 1] + d + 1]);", "+", "+            unLo = ltLo = lo;", "+            unHi = gtHi = hi;", "+", "+            while (true) {", "+                while (true) {", "+                    if (unLo > unHi) {", "+                        break;", "+                    }", "+                    n = ((int) block[zptr[unLo] + d + 1]) - med;", "+                    if (n == 0) {", "+                        int temp = 0;", "+                        temp = zptr[unLo];", "+                        zptr[unLo] = zptr[ltLo];", "+                        zptr[ltLo] = temp;", "+                        ltLo++;", "+                        unLo++;", "+                        continue;", "+                    };", "+                    if (n >  0) {", "+                        break;", "+                    }", "+                    unLo++;", "+                }", "+                while (true) {", "+                    if (unLo > unHi) {", "+                        break;", "+                    }", "+                    n = ((int) block[zptr[unHi] + d + 1]) - med;", "+                    if (n == 0) {", "+                        int temp = 0;", "+                        temp = zptr[unHi];", "+                        zptr[unHi] = zptr[gtHi];", "+                        zptr[gtHi] = temp;", "+                        gtHi--;", "+                        unHi--;", "+                        continue;", "+                    };", "+                    if (n <  0) {", "+                        break;", "+                    }", "+                    unHi--;", "+                }", "+                if (unLo > unHi) {", "+                    break;", "+                }", "+                int temp = 0;", "+                temp = zptr[unLo];", "+                zptr[unLo] = zptr[unHi];", "+                zptr[unHi] = temp;", "+                unLo++;", "+                unHi--;", "+            }", "+", "+            if (gtHi < ltLo) {", "+                stack[sp].ll = lo;", "+                stack[sp].hh = hi;", "+                stack[sp].dd = d + 1;", "+                sp++;", "+                continue;", "+            }", "+", "+            n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo) : (unLo - ltLo);", "+            vswap(lo, unLo - n, n);", "+            m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi) : (gtHi - unHi);", "+            vswap(unLo, hi - m + 1, m);", "+", "+            n = lo + unLo - ltLo - 1;", "+            m = hi - (gtHi - unHi) + 1;", "+", "+            stack[sp].ll = lo;", "+            stack[sp].hh = n;", "+            stack[sp].dd = d;", "+            sp++;", "+", "+            stack[sp].ll = n + 1;", "+            stack[sp].hh = m - 1;", "+            stack[sp].dd = d + 1;", "+            sp++;", "+", "+            stack[sp].ll = m;", "+            stack[sp].hh = hi;", "+            stack[sp].dd = d;", "+            sp++;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eea32ebf64fed0bd3920cfe6054038ca", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/bzip2/CBZip2OutputStream.java", "commitBeforeChange": "380870c2b26a9f3289569dc2451178df3f05613e", "commitAfterChange": "ad9edf5f5ea4a8f2a974726eeb8e656c177357df", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 27, "signatureBeforeChange": "      private void mainSort()", "signatureAfterChange": "      private void mainSort()", "diff": ["-        final Data dataShadow             = this.data;", "-        final int[] runningOrder    = dataShadow.mainSort_runningOrder;", "-        final int[] copy            = dataShadow.mainSort_copy;", "-        final boolean[] bigDone     = dataShadow.mainSort_bigDone;", "-        final int[] ftab            = dataShadow.ftab;", "-        final byte[] block          = dataShadow.block;", "-        final int[] fmap            = dataShadow.fmap;", "-        final char[] quadrant       = dataShadow.quadrant;", "-        final int lastShadow              = this.last;", "-        final int workLimitShadow         = this.workLimit;", "-        final boolean firstAttemptShadow  = this.firstAttempt;", "-", "-        // Set up the 2-byte frequency table", "-        for (int i = 65537; --i >= 0;) {", "-            ftab[i] = 0;", "-        }", "+        int i, j, ss, sb;", "+        int[] runningOrder = new int[256];", "+        int[] copy = new int[256];", "+        boolean[] bigDone = new boolean[256];", "+        int c1, c2;", "+        int numQSorted;", "-        for (int i = 0; i < NUM_OVERSHOOT_BYTES; i++) {", "-            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];", "+", "+        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );", "+        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {", "+            block[last + i + 2] = block[(i % (last + 1)) + 1];", "-        for (int i = lastShadow + NUM_OVERSHOOT_BYTES; --i >= 0;) {", "+        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {", "-        block[0] = block[lastShadow + 1];", "-        // Complete the initial radix sort:", "+        block[0] = (char) (block[last + 1]);", "-        int c1 = block[0] & 0xff;", "-        for (int i = 0; i <= lastShadow; i++) {", "-            final int c2 = block[i + 1] & 0xff;", "-            ftab[(c1 << 8) + c2]++;", "-            c1 = c2;", "-        }", "+        if (last < 4000) {", "+            /*", "+              Use simpleSort(), since the full sorting mechanism", "+              has quite a large constant overhead.", "+            */", "+            for (i = 0; i <= last; i++) {", "+                zptr[i] = i;", "+            }", "+            firstAttempt = false;", "+            workDone = workLimit = 0;", "+            simpleSort(0, last, 0);", "+        } else {", "+            numQSorted = 0;", "+            for (i = 0; i <= 255; i++) {", "+                bigDone[i] = false;", "+            }", "-        for (int i = 1; i <= 65536; i++)", "-            ftab[i] += ftab[i - 1];", "+            for (i = 0; i <= 65536; i++) {", "+                ftab[i] = 0;", "+            }", "-        c1 = block[1] & 0xff;", "-        for (int i = 0; i < lastShadow; i++) {", "-            final int c2 = block[i + 2] & 0xff;", "-            fmap[--ftab[(c1 << 8) + c2]] = i;", "-            c1 = c2;", "-        }", "+            c1 = block[0];", "+            for (i = 0; i <= last; i++) {", "+                c2 = block[i + 1];", "+                ftab[(c1 << 8) + c2]++;", "+                c1 = c2;", "+            }", "-        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]]", "-            = lastShadow;", "+            for (i = 1; i <= 65536; i++) {", "+                ftab[i] += ftab[i - 1];", "+            }", "-        /*", "+            c1 = block[1];", "+            for (i = 0; i < last; i++) {", "+                c2 = block[i + 2];", "+                j = (c1 << 8) + c2;", "+                c1 = c2;", "+                ftab[j]--;", "+                zptr[ftab[j]] = i;", "+            }", "+", "+            j = ((block[last + 1]) << 8) + (block[1]);", "+            ftab[j]--;", "+            zptr[ftab[j]] = last;", "+", "+            /*", "-        */", "-        for (int i = 256; --i >= 0;) {", "-            bigDone[i] = false;", "-            runningOrder[i] = i;", "-        }", "-", "-        for (int h = 364; h != 1;) {", "-            h /= 3;", "-            for (int i = h; i <= 255; i++) {", "-                final int vv = runningOrder[i];", "-                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];", "-                final int b = h - 1;", "-                int j = i;", "-                for (int ro = runningOrder[j - h];", "-                     (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a;", "-                     ro = runningOrder[j - h]) {", "-                    runningOrder[j] = ro;", "-                    j -= h;", "-                    if (j <= b) {", "-                        break;", "-                    }", "-                }", "-                runningOrder[j] = vv;", "-            }", "-        }", "-", "-        /*", "-              The main sorting loop.", "-        */", "-        for (int i = 0; i <= 255; i++) {", "-            /*", "-                  Process big buckets, starting with the least full.", "-            final int ss = runningOrder[i];", "-            // Step 1:", "+            for (i = 0; i <= 255; i++) {", "+                runningOrder[i] = i;", "+            }", "+", "+            {", "+                int vv;", "+                int h = 1;", "+                do {", "+                    h = 3 * h + 1;", "+                }", "+                while (h <= 256);", "+                do {", "+                    h = h / 3;", "+                    for (i = h; i <= 255; i++) {", "+                        vv = runningOrder[i];", "+                        j = i;", "+                        while ((ftab[((runningOrder[j - h]) + 1) << 8]", "+                                - ftab[(runningOrder[j - h]) << 8])", "+                                > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {", "+                            runningOrder[j] = runningOrder[j - h];", "+                            j = j - h;", "+                            if (j <= (h - 1)) {", "+                                break;", "+                            }", "+                        }", "+                        runningOrder[j] = vv;", "+                    }", "+                } while (h != 1);", "+            }", "+", "+              The main sorting loop.", "+            */", "+            for (i = 0; i <= 255; i++) {", "+", "+                /*", "+                  Process big buckets, starting with the least full.", "+                */", "+                ss = runningOrder[i];", "+", "+                /*", "-            */", "-            for (int j = 0; j <= 255; j++) {", "-                final int sb = (ss << 8) + j;", "-                final int ftab_sb = ftab[sb];", "-                if ((ftab_sb & SETMASK) != SETMASK) {", "-                    final int lo = ftab_sb & CLEARMASK;", "-                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;", "-                    if (hi > lo) {", "-                        mainQSort3(dataShadow, lo, hi, 2);", "-                        if (firstAttemptShadow && (this.workDone > workLimitShadow)) {", "-                            return;", "+                */", "+                for (j = 0; j <= 255; j++) {", "+                    sb = (ss << 8) + j;", "+                    if (!((ftab[sb] & SETMASK) == SETMASK)) {", "+                        int lo = ftab[sb] & CLEARMASK;", "+                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;", "+                        if (hi > lo) {", "+                            qSort3(lo, hi, 2);", "+                            numQSorted += (hi - lo + 1);", "+                            if (workDone > workLimit && firstAttempt) {", "+                                return;", "+                            }", "+                        ftab[sb] |= SETMASK;", "-                    ftab[sb] = ftab_sb | SETMASK;", "-            }", "-            // Step 2:", "-            // Now scan this big bucket so as to synthesise the", "-            // sorted order for small buckets [t, ss] for all t != ss.", "-", "-            for (int j = 0; j <= 255; j++) {", "-                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;", "-            }", "-", "-            for (int j = ftab[ss << 8] & CLEARMASK,", "-                     hj = (ftab[(ss + 1) << 8] & CLEARMASK);", "-                 j < hj;", "-                 j++) {", "-                final int fmap_j = fmap[j];", "-                c1 = block[fmap_j] & 0xff;", "-                if (!bigDone[c1]) {", "-                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);", "-                    copy[c1]++;", "-                }", "-            }", "-", "-            for (int j = 256; --j >= 0;)", "-                ftab[(j << 8) + ss] |= SETMASK;", "-", "-            // Step 3:", "-            /*", "+                /*", "-            */", "-            bigDone[ss] = true;", "+                */", "+                bigDone[ss] = true;", "-            if (i < 255) {", "-                final int bbStart = ftab[ss << 8] & CLEARMASK;", "-                final int bbSize  = ", "-                    (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;", "-                int shifts = 0;", "+                if (i < 255) {", "+                    int bbStart  = ftab[ss << 8] & CLEARMASK;", "+                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;", "+                    int shifts   = 0;", "-                while ((bbSize >> shifts) > 65534) {", "-                    shifts++;", "-                }", "+                    while ((bbSize >> shifts) > 65534) {", "+                        shifts++;", "+                    }", "-                for (int j = 0; j < bbSize; j++) {", "-                    final int a2update = fmap[bbStart + j];", "-                    final char qVal = (char) (j >> shifts);", "-                    quadrant[a2update] = qVal;", "-                    if (a2update < NUM_OVERSHOOT_BYTES) {", "-                        quadrant[a2update + lastShadow + 1] = qVal;", "+                    for (j = 0; j < bbSize; j++) {", "+                        int a2update = zptr[bbStart + j];", "+                        int qVal = (j >> shifts);", "+                        quadrant[a2update] = qVal;", "+                        if (a2update < NUM_OVERSHOOT_BYTES) {", "+                            quadrant[a2update + last + 1] = qVal;", "+                        }", "+                    }", "+", "+                    if (!(((bbSize - 1) >> shifts) <= 65535)) {", "+                        panic();", "-            }", "+                /*", "+                  Now scan this big bucket so as to synthesise the", "+                  sorted order for small buckets [t, ss] for all t != ss.", "+                */", "+                for (j = 0; j <= 255; j++) {", "+                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;", "+                }", "+", "+                for (j = ftab[ss << 8] & CLEARMASK;", "+                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {", "+                    c1 = block[zptr[j]];", "+                    if (!bigDone[c1]) {", "+                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;", "+                        copy[c1]++;", "+                    }", "+                }", "+", "+                for (j = 0; j <= 255; j++) {", "+                    ftab[(j << 8) + ss] |= SETMASK;", "+                }", "+            }"]}]}