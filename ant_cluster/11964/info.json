{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cb78fb1d9ac4264bf11e4025a8629525", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0b4f8a21890aa0ca0b25d73f034b8152", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Concat.java", "commitBeforeChange": "85875db138d8efbc050b5d34dbba19cc9c707db6", "commitAfterChange": "d53f5e961288efbb6a95db34d841b31d9571ea1b", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": "     private void catFiles(File base, String[] files)", "signatureAfterChange": "     private void catFiles(File base, String[] files)", "diff": ["-        if (destinationFile == null) {", "+        if (encoding == null) {", "+            OutputStream os = null;", "+            InputStream is = null;", "-            // No destination file, dump to stdout via Ant's logging", "-            // interface, which requires that we assume the input data", "-            // is line-oriented. Generally, this is a safe assumption,", "-            // as most users won't (intentionally) attempt to cat", "-            // binary files to the console.", "-            for (int i = 0; i < len; i++) {", "+            try {", "-                BufferedReader reader = null;", "-                try {", "-                    if (encoding == null) {", "-                        // Use default encoding.", "-                        reader = new BufferedReader(", "-                            new FileReader(input[i])", "-                        );", "-                    } else {", "-                        // Use specified encoding.", "-                        reader = new BufferedReader(", "+                if (destinationFile == null) {", "+                    // Log using WARN so it displays in 'quiet' mode.", "+                    os = new LogOutputStream(this, Project.MSG_WARN);", "+                } else {", "+                    os = ", "+                        new FileOutputStream(destinationFile.getAbsolutePath(),", "+                                             append);", "+                    ", "+                    // This flag should only be recognized for the first", "+                    // file. In the context of a single 'cat', we always", "+                    // want to append.", "+                    append = true;", "+                }", "+            ", "+                for (int i = 0; i < len; i++) {", "+", "+                    // Make sure input != output.", "+                    if (destinationFile != null &&", "+                        destinationFile.getAbsolutePath().equals(input[i])) {", "+                        log(destinationFile.getName() + \": input file is \" + ", "+                            \"output file.\", Project.MSG_WARN);", "+                    }", "+", "+                    is = new FileInputStream(input[i]);", "+                    byte[] buffer = new byte[8096];", "+                    while (true) {", "+                        int bytesRead = is.read(buffer);", "+                        if (bytesRead == -1) { // EOF", "+                            break;", "+                        }", "+                        ", "+                        // Write the read data.", "+                        os.write(buffer, 0, bytesRead);", "+                    }", "+                    os.flush();", "+                    is.close();", "+                    is = null;", "+                }", "+            } catch (IOException ioex) {", "+                throw new BuildException(\"Error while concatenating: \"", "+                                         + ioex.getMessage(), ioex);", "+            } finally {", "+                if (is != null) {", "+                    try {", "+                        is.close();", "+                    } catch (Exception ignore) {}", "+                }", "+                if (os != null) {", "+                    try {", "+                        os.close();", "+                    } catch (Exception ignore) {}", "+                }", "+            }", "+", "+        } else { // user specified encoding, assume line oriented input", "+", "+            PrintWriter out = null;", "+            BufferedReader in = null;", "+", "+            try {", "+                OutputStream os = null;", "+                if (destinationFile == null) {", "+                    // Log using WARN so it displays in 'quiet' mode.", "+                    os = new LogOutputStream(this, Project.MSG_WARN);", "+                } else {", "+                    os = ", "+                        new FileOutputStream(destinationFile.getAbsolutePath(),", "+                                             append);", "+                    ", "+                    // This flag should only be recognized for the first", "+                    // file. In the context of a single 'cat', we always", "+                    // want to append.", "+                    append = true;", "+                }", "+                out = new PrintWriter(new OutputStreamWriter(os, encoding));", "+", "+                for (int i = 0; i < len; i++) {", "+                    in = new BufferedReader(", "-                    }", "-                    while ((line = reader.readLine()) != null) {", "+                    while ((line = in.readLine()) != null) {", "-                        log(line, Project.MSG_WARN);", "+                        out.println(line);", "-", "-                } catch (IOException ioe) {", "-                    throw new BuildException(\"Error while concatenating \" + ", "-                                             \"file.\", ioe);", "-                } finally {", "-                    // Close resources.", "-                    if (reader != null) {", "-                        try {", "-                            reader.close();", "-                        } catch (Exception ignore) {}", "-                    }", "+                    in.close();", "+                    in = null;", "-            }", "-", "-        } else {", "-", "-            // Use the provided file, making no assumptions about", "-            // whether or not the file is character or line-oriented.", "-            final int bufferSize = 1024;", "-            OutputStream os = null;", "-            try {", "-                os = new FileOutputStream(destinationFile.getAbsolutePath(), ", "-                                          append);", "-", "-                // This flag should only be recognized for the first", "-                // file. In the context of a single 'cat', we always", "-                // want to append.", "-                append = true;", "-", "-                throw new BuildException(\"Unable to open destination \" + ", "-                                         \"file.\", ioe);", "-            }", "-", "-            // Concatenate the file.", "-            try {", "-", "-                for (int i = 0; i < len; i++) {", "-", "-                    // Make sure input != output.", "-                    if (destinationFile.getAbsolutePath().equals(input[i])) {", "-                        log(destinationFile.getName() + \": input file is \" + ", "-                            \"output file.\", Project.MSG_WARN);", "-                    }", "-", "-                    InputStream is = null;", "-                    try {", "-                        is = new FileInputStream(input[i]);", "-                        byte[] buffer = new byte[bufferSize];", "-                        while (true) {", "-                            int bytesRead = is.read(buffer);", "-                            if (bytesRead == -1) { // EOF", "-                                break;", "-                            }", "-", "-                            // Write the read data.", "-                            os.write(buffer, 0, bytesRead);", "-                        }", "-", "-                        os.flush();", "-", "-                    } catch (IOException ioex) {", "-                        throw new BuildException(\"Error writing file.\", ioex);", "-                    } finally {", "-                        if (is != null) {", "-                            try {", "-                                is.close();", "-                            } catch (Exception ignore) {}", "-                        }", "-                    }", "-                }", "-", "+                throw new BuildException(\"Error while concatenating: \" ", "+                                         + ioe.getMessage(), ioe);", "-                if (os != null) {", "+                // Close resources.", "+                if (in != null) {", "-                        os.close();", "+                        in.close();", "+                    } catch (Exception ignore) {}", "+                }", "+                if (out != null) {", "+                    try {", "+                        out.close();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16fd21bb2aa3a652044f34db1803201c", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Jikes.java", "commitBeforeChange": "b63d11b05127869902892020ab0faa8e83a5c55b", "commitAfterChange": "a67f5b98b5a5f57f105269882800666bfc4d74b5", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     protected void compile(String[] args)", "signatureAfterChange": "     protected void compile(String[] args)", "diff": ["-        String[] commandArray = new String[args.length+1];", "-        commandArray[0] = command;", "-        System.arraycopy(args,0,commandArray,1,args.length);", "-        ", "-        // We assume, that everything jikes writes goes to", "-        // standard output, not to standard error. The option", "-        // -Xstdout that is given to Jikes in Javac.doJikesCompile()", "-        // should guarantee this. At least I hope so. :)", "+        String[] commandArray = null;", "+        File tmpFile = null;", "+", "-            Process jikes = Runtime.getRuntime().exec(commandArray);", "-            BufferedReader reader = new BufferedReader(new InputStreamReader(jikes.getInputStream()));", "-            jop.parseOutput(reader);", "-        } catch (IOException e) {", "-            throw new BuildException(\"Error running Jikes compiler\", e);                ", "+            String myos = System.getProperty(\"os.name\");", "+", "+            // Windows has a 32k limit on total arg size, so", "+            // create a temporary file to store all the arguments", "+", "+            // There have been reports that 300 files could be compiled", "+            // so 250 is a conservative approach", "+            if (myos.toLowerCase().indexOf(\"windows\") >= 0 ", "+                && args.length > 250) {", "+                PrintWriter out = null;", "+                try {", "+                    tmpFile = new File(\"jikes\"+(new Random(System.currentTimeMillis())).nextLong());", "+                    out = new PrintWriter(new FileWriter(tmpFile));", "+                    for (int i = 0; i < args.length; i++) {", "+                        out.println(args[i]);", "+                    }", "+                    out.flush();", "+                    commandArray = new String[] { command, ", "+                                                  \"@\" + tmpFile.getAbsolutePath()};", "+                } catch (IOException e) {", "+                    throw new BuildException(\"Error creating temporary file\", e);", "+                } finally {", "+                    if (out != null) {", "+                        try {out.close();} catch (Throwable t) {}", "+                    }", "+                }", "+            } else {", "+                commandArray = new String[args.length+1];", "+                commandArray[0] = command;", "+                System.arraycopy(args,0,commandArray,1,args.length);", "+            }", "+            ", "+            // We assume, that everything jikes writes goes to", "+            // standard output, not to standard error. The option", "+            // -Xstdout that is given to Jikes in Javac.doJikesCompile()", "+            // should guarantee this. At least I hope so. :)", "+            try {", "+                Process jikes = Runtime.getRuntime().exec(commandArray);", "+                BufferedReader reader = new BufferedReader(new InputStreamReader(jikes.getInputStream()));", "+                jop.parseOutput(reader);", "+            } catch (IOException e) {", "+                throw new BuildException(\"Error running Jikes compiler\", e);", "+            }", "+        } finally {", "+            if (tmpFile != null) {", "+                tmpFile.delete();", "+            }"]}]}