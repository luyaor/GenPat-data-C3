{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d638a61f1335e3258b2e4b683818fb75", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16fd21bb2aa3a652044f34db1803201c", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Jikes.java", "commitBeforeChange": "b63d11b05127869902892020ab0faa8e83a5c55b", "commitAfterChange": "a67f5b98b5a5f57f105269882800666bfc4d74b5", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     protected void compile(String[] args)", "signatureAfterChange": "     protected void compile(String[] args)", "diff": ["-        String[] commandArray = new String[args.length+1];", "-        commandArray[0] = command;", "-        System.arraycopy(args,0,commandArray,1,args.length);", "-        ", "-        // We assume, that everything jikes writes goes to", "-        // standard output, not to standard error. The option", "-        // -Xstdout that is given to Jikes in Javac.doJikesCompile()", "-        // should guarantee this. At least I hope so. :)", "+        String[] commandArray = null;", "+        File tmpFile = null;", "+", "-            Process jikes = Runtime.getRuntime().exec(commandArray);", "-            BufferedReader reader = new BufferedReader(new InputStreamReader(jikes.getInputStream()));", "-            jop.parseOutput(reader);", "-        } catch (IOException e) {", "-            throw new BuildException(\"Error running Jikes compiler\", e);                ", "+            String myos = System.getProperty(\"os.name\");", "+", "+            // Windows has a 32k limit on total arg size, so", "+            // create a temporary file to store all the arguments", "+", "+            // There have been reports that 300 files could be compiled", "+            // so 250 is a conservative approach", "+            if (myos.toLowerCase().indexOf(\"windows\") >= 0 ", "+                && args.length > 250) {", "+                PrintWriter out = null;", "+                try {", "+                    tmpFile = new File(\"jikes\"+(new Random(System.currentTimeMillis())).nextLong());", "+                    out = new PrintWriter(new FileWriter(tmpFile));", "+                    for (int i = 0; i < args.length; i++) {", "+                        out.println(args[i]);", "+                    }", "+                    out.flush();", "+                    commandArray = new String[] { command, ", "+                                                  \"@\" + tmpFile.getAbsolutePath()};", "+                } catch (IOException e) {", "+                    throw new BuildException(\"Error creating temporary file\", e);", "+                } finally {", "+                    if (out != null) {", "+                        try {out.close();} catch (Throwable t) {}", "+                    }", "+                }", "+            } else {", "+                commandArray = new String[args.length+1];", "+                commandArray[0] = command;", "+                System.arraycopy(args,0,commandArray,1,args.length);", "+            }", "+            ", "+            // We assume, that everything jikes writes goes to", "+            // standard output, not to standard error. The option", "+            // -Xstdout that is given to Jikes in Javac.doJikesCompile()", "+            // should guarantee this. At least I hope so. :)", "+            try {", "+                Process jikes = Runtime.getRuntime().exec(commandArray);", "+                BufferedReader reader = new BufferedReader(new InputStreamReader(jikes.getInputStream()));", "+                jop.parseOutput(reader);", "+            } catch (IOException e) {", "+                throw new BuildException(\"Error running Jikes compiler\", e);", "+            }", "+        } finally {", "+            if (tmpFile != null) {", "+                tmpFile.delete();", "+            }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b5ac6548c79ff90e713f8777342efd35", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/testcases/org/apache/tools/ant/taskdefs/BZip2Test.java", "commitBeforeChange": "3477bbf6474cdd2b70b12eb638e64415a4f1c2ec", "commitAfterChange": "134d95afef9b42cf08f2eccb077b97525ac38034", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "      public void testRealTest() throws IOException", "signatureAfterChange": "      public void testRealTest() throws IOException", "diff": ["-        assertTrue(\"File content mismatch\",", "-            FILE_UTILS.contentEquals(project.resolveFile(\"expected/asf-logo-huge.tar.bz2\"),", "-                                    project.resolveFile(\"asf-logo-huge.tar.bz2\")));", "+", "+        // doesn't work: Depending on the compression engine used,", "+        // compressed bytes may differ. False errors would be", "+        // reported.", "+        // assertTrue(\"File content mismatch\",", "+        // FILE_UTILS.contentEquals(project.resolveFile(\"expected/asf-logo-huge.tar.bz2\"),", "+        // project.resolveFile(\"asf-logo-huge.tar.bz2\")));", "+", "+        // We have to compare the decompressed content instead:", "+", "+        File originalFile =", "+            project.resolveFile(\"expected/asf-logo-huge.tar.bz2\");", "+        File actualFile   = project.resolveFile(\"asf-logo-huge.tar.bz2\");", "+", "+        InputStream originalIn =", "+            new BufferedInputStream(new FileInputStream(originalFile));", "+        assertEquals((byte) 'B', originalIn.read());", "+        assertEquals((byte) 'Z', originalIn.read());", "+", "+        InputStream actualIn =", "+            new BufferedInputStream(new FileInputStream(actualFile));", "+        assertEquals((byte) 'B', actualIn.read());", "+        assertEquals((byte) 'Z', actualIn.read());", "+", "+        originalIn = new CBZip2InputStream(originalIn);", "+        actualIn   = new CBZip2InputStream(actualIn);", "+", "+        while (true) {", "+            int expected = originalIn.read();", "+            int actual   = actualIn.read();", "+            if (expected >= 0) {", "+                if (expected != actual) {", "+                    fail(\"File content mismatch\");", "+                }", "+            } else {", "+                if (actual >= 0) {", "+                    fail(\"File content mismatch\");", "+                }", "+                break;", "+            }", "+        }", "+", "+        originalIn.close();", "+        actualIn.close();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bfcbd0abf9cb295e4517e264c24d2438", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/XalanLiaison.java", "commitBeforeChange": "85344c438efab87f56ca5f4b179752852ec0aa86", "commitAfterChange": "f66cab0ea7689df54fe51f64018cd3ef8b05cd3d", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      public void transform(String infile, String outfile) throws Exception", "signatureAfterChange": "      public void transform(File infile, File outfile) throws Exception", "diff": ["-", "-    public void transform(String infile, String outfile) throws Exception {", "-        processor.process(new XSLTInputSource(normalize(infile)), xslSheet,", "-                        new XSLTResultTarget(outfile));", "+    public void transform(File infile, File outfile) throws Exception {", "+        FileInputStream fis = null;", "+        FileOutputStream fos = null;", "+        FileInputStream xslStream = null;", "+        try {", "+            xslStream = new FileInputStream(stylesheet);", "+            fis = new FileInputStream(infile);", "+            fos = new FileOutputStream(outfile);", "+            // systemid such as file:/// + getAbsolutePath() are considered", "+            // invalid here...", "+            XSLTInputSource xslSheet = new XSLTInputSource(xslStream);", "+            xslSheet.setSystemId(stylesheet.getAbsolutePath());", "+            XSLTInputSource src = new XSLTInputSource(fis);", "+            src.setSystemId(infile.getAbsolutePath());", "+            XSLTResultTarget res = new XSLTResultTarget(fos);", "+            processor.process(src, xslSheet, res);", "+        } finally {", "+            // make sure to close all handles, otherwise the garbage", "+            // collector will close them...whenever possible and", "+            // Windows may complain about not being able to delete files.", "+            try {", "+                if (xslStream != null){", "+                    xslStream.close();", "+                }", "+            } catch (IOException ignored){}", "+            try {", "+                if (fis != null){", "+                    fis.close();", "+                }", "+            } catch (IOException ignored){}", "+            try {", "+                if (fos != null){", "+                    fos.close();", "+                }", "+            } catch (IOException ignored){}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ca0eac1e0802947468b0096ad7d42524", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Cvs.java", "commitBeforeChange": "db6f84aa2239450cdbbb81a6e3b67513fab389c8", "commitAfterChange": "37ed344b385cde54ee62f2e66d347cb243dd6708", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "          public void execute() throws BuildException", "signatureAfterChange": "       public void execute() throws BuildException", "diff": ["+", "-\t// XXX: we should use JCVS (www.ice.com/JCVS) instead of command line", "-\t// execution so that we don't rely on having native CVS stuff around (SM)", "+        // XXX: we should use JCVS (www.ice.com/JCVS) instead of command line", "+        // execution so that we don't rely on having native CVS stuff around (SM)", "-\t", "+    ", "-\tif (pack != null) {", "+        if (pack != null) {", "-\t}", "+        }", "-        Execute exe = new Execute(new LogStreamHandler(this, Project.MSG_INFO,", "-                                                       Project.MSG_WARN), ", "+        ExecuteStreamHandler streamhandler = null;", "+        OutputStream outputstream = null;", "+        OutputStream errorstream = null; ", "+        if (error == null && output == null) {", "+            streamhandler = new LogStreamHandler(this, Project.MSG_INFO,", "+                                                 Project.MSG_WARN);", "+        }", "+        else {", "+            if (output != null) {", "+                try {", "+                    outputstream = new PrintStream(new BufferedOutputStream(new FileOutputStream(output)));", "+                } catch (IOException e) {", "+                    throw new BuildException(e, location);", "+                }", "+            }", "+            else {", "+                outputstream = new LogOutputStream(this, Project.MSG_INFO);", "+            }", "+            if (error != null) {", "+                try {", "+                    errorstream = new PrintStream(new BufferedOutputStream(new FileOutputStream(error)));", "+                } catch (IOException e) {", "+                    throw new BuildException(e, location);", "+                }", "+            }", "+            else {", "+                errorstream = new LogOutputStream(this, Project.MSG_WARN);", "+            }", "+            streamhandler = new PumpStreamHandler(outputstream, errorstream);", "+        }", "+", "+        Execute exe = new Execute(streamhandler, ", "+        } finally {", "+            if (output != null) {", "+                try {", "+                    outputstream.close();", "+                } catch (IOException e) {}", "+            }", "+            if (error != null) {", "+                try {", "+                    errorstream.close();", "+                } catch (IOException e) {}", "+            }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "df7aa6ab507bc63672051d0fbac63081", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Expand.java", "commitBeforeChange": "ec1437bc19cd82c489e329496bd0529d9e7eb072", "commitAfterChange": "b113154a3acb81036230d6bacbffb6ea977271b5", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     protected void expandFile(FileUtils fileUtils, File srcF, File dir)", "signatureAfterChange": "     protected void expandFile(FileUtils fileUtils, File srcF, File dir)", "diff": ["+        FileInputStream fis = null;", "+        RandomAccessFile raf = null;", "+        byte[] buff = new byte[MARKER_SIZE];", "-            // code from WarExpand", "-            zis = new ZipInputStream(new FileInputStream(srcF));", "-            ZipEntry ze = null;", "+            raf = new RandomAccessFile(srcF, \"r\");", "+            long offset = 0;", "+            int more = raf.read(buff);", "+            boolean foundMarker = false;", "+            while (more != -1 || offset < MAX_LOOKAHEAD) {", "+                if (Arrays.equals(buff, ZIPMARKER)) {", "+                    foundMarker = true;", "+                    break;", "+                }", "+                raf.seek(++offset);", "+                more = raf.read(buff);", "+            }", "+            raf.close();", "+            raf = null;", "+            fis = new FileInputStream(srcF);", "+            if (foundMarker && offset > 0) {", "+                log(\"found a preamble of \" + offset ", "+                    + \" bytes, probably a self-extracting archive\");", "+                fis.skip(offset);", "+            }", "+            ", "+            zis = new ZipInputStream(fis);", "+            ZipEntry ze = null;", "+            if (raf != null) {", "+                try {", "+                    raf.close();", "+                } catch (IOException e) {}", "+            }"]}]}