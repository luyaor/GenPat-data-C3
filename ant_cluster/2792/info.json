{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6b547b646341ed0b891c25b5b6cb1236", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c61d58184105b570649f13fa95d1118", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Zip.java", "commitBeforeChange": "b9c9d1a29c79e175c65cf22876c0cfec0e8d4ced", "commitAfterChange": "d180ff4e655f2160229d8c45dac21ab6a66d6b3b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": "      protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath)         throws IOException", "signatureAfterChange": "      protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath)         throws IOException", "diff": ["+", "+        /*", "+         * XXX ZipOutputStream.putEntry expects the ZipEntry to know its", "+         * size and the CRC sum before you start writing the data when using ", "+         * STORED mode.", "+         *", "+         * This forces us to process the data twice.", "+         *", "+         * I couldn't find any documentation on this, just found out by try ", "+         * and error.", "+         */", "+        if (!doCompress) {", "+            long size = 0;", "+            CRC32 cal = new CRC32();", "+            if (!in.markSupported()) {", "+                // Store data into a byte[]", "+                ByteArrayOutputStream bos = new ByteArrayOutputStream();", "+", "+                byte[] buffer = new byte[8 * 1024];", "+                int count = 0;", "+                do {", "+                    size += count;", "+                    cal.update(buffer, 0, count);", "+                    bos.write(buffer, 0, count);", "+                    count = in.read(buffer, 0, buffer.length);", "+                } while (count != -1);", "+                in = new ByteArrayInputStream(bos.toByteArray());", "+", "+            } else {", "+                in.mark(Integer.MAX_VALUE);", "+                byte[] buffer = new byte[8 * 1024];", "+                int count = 0;", "+                do {", "+                    size += count;", "+                    cal.update(buffer, 0, count);", "+                    count = in.read(buffer, 0, buffer.length);", "+                } while (count != -1);", "+                in.reset();", "+            }", "+            ze.setSize(size);", "+            ze.setCrc(cal.getValue());", "+        }", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e4cd287ff8cc63c1d6e054219d374896", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/tar/TarOutputStream.java", "commitBeforeChange": "b43f4224d8fe9d1e7d628e88df394a7dfed46d1b", "commitAfterChange": "2e5b53fa106b848646493cb6f6ea74616973aca0", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 14, "signatureBeforeChange": "     public void putNextEntry(TarEntry entry) throws IOException", "signatureAfterChange": "     public void putNextEntry(TarEntry entry) throws IOException", "diff": ["-        if (entry.getName().length() >= TarConstants.NAMELEN) {", "+        if(finished) {", "+            throw new IOException(\"Stream has already been finished\");", "+        }", "+        Map<String, String> paxHeaders = new HashMap<String, String>();", "+        final String entryName = entry.getName();", "+        final byte[] nameBytes = encoding.encode(entryName).array();", "+        boolean paxHeaderContainsPath = false;", "+        if (nameBytes.length >= TarConstants.NAMELEN) {", "-            if (longFileMode == LONGFILE_GNU) {", "+            if (longFileMode == LONGFILE_POSIX) {", "+                paxHeaders.put(\"path\", entryName);", "+                paxHeaderContainsPath = true;", "+            } else if (longFileMode == LONGFILE_GNU) {", "-                longLinkEntry.setSize(entry.getName().length() + 1);", "+                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL", "-                write(entry.getName().getBytes());", "-                write(0);", "+                write(nameBytes);", "+                write(0); // NUL terminator", "-                throw new RuntimeException(\"file name '\" + entry.getName()", "-                                             + \"' is too long ( > \"", "-                                             + TarConstants.NAMELEN + \" bytes)\");", "+                throw new RuntimeException(\"file name '\" + entryName", "+                                           + \"' is too long ( > \"", "+                                           + TarConstants.NAMELEN + \" bytes)\");", "-        entry.writeEntryHeader(recordBuf);", "+        if (bigNumberMode == BIGNUMBER_POSIX) {", "+            addPaxHeadersForBigNumbers(paxHeaders, entry);", "+        } else if (bigNumberMode != BIGNUMBER_STAR) {", "+            failForBigNumbers(entry);", "+        }", "+", "+        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath", "+            && !ASCII.canEncode(entryName)) {", "+            paxHeaders.put(\"path\", entryName);", "+        }", "+", "+        if (addPaxHeadersForNonAsciiNames", "+            && (entry.isLink() || entry.isSymbolicLink())", "+            && !ASCII.canEncode(entry.getLinkName())) {", "+            paxHeaders.put(\"linkpath\", entry.getLinkName());", "+        }", "+", "+        if (paxHeaders.size() > 0) {", "+            writePaxHeaders(entryName, paxHeaders);", "+        }", "+", "+        entry.writeEntryHeader(recordBuf, encoding,", "+                               bigNumberMode == BIGNUMBER_STAR);", "-        currName = entry.getName();", "+        currName = entryName;", "+        haveUnclosedEntry = true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e77785ef5b0fcd384967c66a1da712d3", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/testcases/org/apache/tools/ant/taskdefs/ManifestTest.java", "commitBeforeChange": "3e1cde904eca74dd23da0102f7a68ecc0cd1aa62", "commitAfterChange": "176b11946b0fd2fdc0f5f06d676aba72fc4fce98", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "     public void testLongLine() throws IOException, ManifestException", "signatureAfterChange": "     public void testLongLine() throws IOException, ManifestException", "diff": ["+        p.setUserProperty(\"test.long68name\" , LONG_68_NAME);", "+        p.setUserProperty(\"test.long70name\" , LONG_70_NAME);", "+        p.setUserProperty(\"test.notlongname\" , NOT_LONG_NAME);", "+        p.setUserProperty(\"test.value\", VALUE);", "+        ", "+        String value = mainSection.getAttributeValue(LONG_68_NAME);", "+        assertEquals(\"LONG_68_NAME_VALUE_MISMATCH\", VALUE, value);", "+        value = mainSection.getAttributeValue(LONG_70_NAME);", "+        assertEquals(\"LONG_70_NAME_VALUE_MISMATCH\", VALUE, value);", "+        value = mainSection.getAttributeValue(NOT_LONG_NAME);", "+        assertEquals(\"NOT_LONG_NAME_VALUE_MISMATCH\", VALUE, value);", "+        ", "+        BufferedReader in = new BufferedReader(new FileReader(EXPANDED_MANIFEST));", "+        ", "+        Set set = new HashSet();", "+        String read = in.readLine();", "+        while (read != null)", "+        {", "+            set.add(read);", "+            read = in.readLine();", "+        }", "+        ", "+        assertTrue(\"Manifest file should have contained string \", set", "+                .remove(\" NOT_LONG\"));", "+        assertTrue(\"Manifest file should have contained string \", set", "+                .remove(\" NG\"));", "+        assertTrue(\"Manifest file should have contained string \", set", "+                .remove(LONG_70_NAME + \": \"));", "+        assertTrue(\"Manifest file should have contained string \", set", "+                .remove(NOT_LONG_NAME + \": NOT_LO\"));"]}]}