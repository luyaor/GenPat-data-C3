{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b92767f7bb72f13b00311a5419ecd529", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "07184fbb9658b2016968b7dd9bf1cb81", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/Main.java", "commitBeforeChange": "e79bd24e1ace7034b743df1046eb355c8cdd3162", "commitAfterChange": "962c579f1d04d9d2264bb4757f3c01ac4e7d5f83", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private BuildListener createDefaultBuildListener()", "signatureAfterChange": "     private BuildLogger createLogger()", "diff": ["-    private BuildListener createDefaultBuildListener() {", "-        return new DefaultLogger(out, msgOutputLevel);", "+    private BuildLogger createLogger() {", "+        BuildLogger logger = null;", "+        if (loggerClassname != null) {", "+            try {", "+                logger = (BuildLogger)(Class.forName(loggerClassname).newInstance());", "+            }", "+            catch (ClassCastException e) {", "+                System.err.println(\"The specified logger class \" + loggerClassname + ", "+                                         \" does not implement the BuildLogger interface\");", "+                throw new RuntimeException();", "+            }", "+            catch (Exception e) {", "+                System.err.println(\"Unable to instantiate specified logger class \" + ", "+                                           loggerClassname + \" : \" + e.getClass().getName());", "+                throw new RuntimeException();", "+            }", "+        }", "+        else {", "+            logger = new DefaultLogger();", "+        }", "+        ", "+        logger.setMessageOutputLevel(msgOutputLevel);", "+        logger.setOutputPrintStream(out);", "+        logger.setEmacsMode(emacsMode);", "+        ", "+        return logger;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c83c24070af41286997eb186c31123e7", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "proposal/mutant/src/java/antcore/org/apache/ant/antcore/execution/Reflector.java", "commitBeforeChange": "7499c443d67445ea8fd0b8f4bd56c72251b18bf4", "commitAfterChange": "b7e43ad8c5906ae2b6d6b42f8b2715dc7d2e7a16", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 14, "signatureBeforeChange": "     public void addAttributeMethod(final Method m, String propertyName,                                          Map converters)", "signatureAfterChange": "     public void addAttributeMethod(final Method m, String propertyName,                                          Map converters)", "diff": ["-            final Converter converter = (Converter)converters.get(type);", "-            attributeSetters.put(propertyName,", "-                new AttributeSetter() {", "-                    public void set(Object obj, String value)", "-                         throws InvocationTargetException, ExecutionException,", "-                        IllegalAccessException, ConversionException {", "-                        Object convertedValue = converter.convert(value, type);", "-                        m.invoke(obj, new Object[]{convertedValue});", "-                    }", "-                });", "-        } else if (type.equals(String.class)) {", "-            attributeSetters.put(propertyName,", "+            Converter converter = (Converter)converters.get(type);", "+            addConvertingSetter(m, propertyName, converter, type);", "+            return;", "+        }", "+", "+        if (type.equals(String.class)) {", "+            attributeSetters.put(propertyName.toLowerCase(),", "-        } else {", "-            try {", "-                final Constructor c =", "-                    type.getConstructor(new Class[]{java.lang.String.class});", "-                attributeSetters.put(propertyName,", "-                    new AttributeSetter() {", "-                        public void set(Object parent, String value)", "-                             throws InvocationTargetException,", "-                            IllegalAccessException, ExecutionException {", "-                            try {", "-                                Object newValue", "-                                     = c.newInstance(new String[]{value});", "-                                m.invoke(parent, new Object[]{newValue});", "-                            } catch (InstantiationException ie) {", "-                                throw new ExecutionException(ie);", "-                            }", "+            return;", "+        }", "+", "+        try {", "+            final Constructor c =", "+                type.getConstructor(new Class[]{java.lang.String.class});", "+            attributeSetters.put(propertyName.toLowerCase(),", "+                new AttributeSetter() {", "+                    public void set(Object parent, String value)", "+                         throws InvocationTargetException,", "+                        IllegalAccessException, ExecutionException {", "+                        try {", "+                            Object newValue", "+                                 = c.newInstance(new String[]{value});", "+                            m.invoke(parent, new Object[]{newValue});", "+                        } catch (InstantiationException ie) {", "+                            throw new ExecutionException(ie);", "-                    });", "-            } catch (NoSuchMethodException nme) {", "-                // ignore", "+                    }", "+                });", "+            return;", "+        } catch (NoSuchMethodException nme) {", "+            // ignore", "+        }", "+", "+        if (converters != null) {", "+            // desparate by now - try top find a converter which handles a super", "+            // class of this type and which supports subclass instantiation", "+            for (Iterator i = converters.keySet().iterator(); i.hasNext(); ) {", "+                Class converterType = (Class)i.next();", "+                if (converterType.isAssignableFrom(type)) {", "+                    // could be a candidate", "+                    Converter converter", "+                         = (Converter)converters.get(converterType);", "+                    if (converter.canConvertSubType(type)) {", "+                        addConvertingSetter(m, propertyName, converter, type);", "+                        return;", "+                    }", "+                }"]}]}