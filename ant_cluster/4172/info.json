{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f72a25bbeff77d89e1e28f298e34bdd6", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "df7aa6ab507bc63672051d0fbac63081", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/Expand.java", "commitBeforeChange": "ec1437bc19cd82c489e329496bd0529d9e7eb072", "commitAfterChange": "b113154a3acb81036230d6bacbffb6ea977271b5", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     protected void expandFile(FileUtils fileUtils, File srcF, File dir)", "signatureAfterChange": "     protected void expandFile(FileUtils fileUtils, File srcF, File dir)", "diff": ["+        FileInputStream fis = null;", "+        RandomAccessFile raf = null;", "+        byte[] buff = new byte[MARKER_SIZE];", "-            // code from WarExpand", "-            zis = new ZipInputStream(new FileInputStream(srcF));", "-            ZipEntry ze = null;", "+            raf = new RandomAccessFile(srcF, \"r\");", "+            long offset = 0;", "+            int more = raf.read(buff);", "+            boolean foundMarker = false;", "+            while (more != -1 || offset < MAX_LOOKAHEAD) {", "+                if (Arrays.equals(buff, ZIPMARKER)) {", "+                    foundMarker = true;", "+                    break;", "+                }", "+                raf.seek(++offset);", "+                more = raf.read(buff);", "+            }", "+            raf.close();", "+            raf = null;", "+            fis = new FileInputStream(srcF);", "+            if (foundMarker && offset > 0) {", "+                log(\"found a preamble of \" + offset ", "+                    + \" bytes, probably a self-extracting archive\");", "+                fis.skip(offset);", "+            }", "+            ", "+            zis = new ZipInputStream(fis);", "+            ZipEntry ze = null;", "+            if (raf != null) {", "+                try {", "+                    raf.close();", "+                } catch (IOException e) {}", "+            }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ee303cb9605a95548db9e5ef10e2c7ec", "repository": "https://git-wip-us.apache.org/repos/asf/ant.git", "fileName": "src/main/org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java", "commitBeforeChange": "018aa8685b246a8bb269832fcbc935874eff0c1e", "commitAfterChange": "e545bf4a3695a90cc6d3645fb20d5dbacc7ec988", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 17, "signatureBeforeChange": "          public void processDescriptor(String descriptorFileName, SAXParser saxParser)", "signatureAfterChange": "          public void processDescriptor(String descriptorFileName, SAXParser saxParser)", "diff": ["+        FileInputStream descriptorStream = null;", "+", "-            saxParser.parse(new InputSource", "-                            (new FileInputStream", "-                            (new File(getDescriptorDir(), descriptorFileName))),", "-                            handler);", "+            descriptorStream = new FileInputStream(new File(getDescriptorDir(), descriptorFileName));", "+            saxParser.parse(new InputSource(descriptorStream), handler);", "-                         ", "+            ", "+            // now the vendor specific files, if any             ", "+\t\t\t", "+\t\t    // add any inherited files", "+\t\t    checkAndAddInherited(ejbFiles);", "+                    if (needBuild) {", "+                        log(\"Build needed because \" + currentFile.getPath() + \" is out of date\",", "+                            Project.MSG_VERBOSE);", "+                    }", "-                getTask().log( \"building \"", "+                log( \"building \"", "-                getTask().log(jarFile.toString() + \" is up to date.\",", "+                log(jarFile.toString() + \" is up to date.\",", "+        finally {", "+            if (descriptorStream != null) {", "+                try {", "+                    descriptorStream.close();", "+                }", "+                catch (IOException closeException) {}", "+            }", "+        }"]}]}