{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a0b7837509c55a94b2d4646f432a13ae", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d2399a6684cd3a7894f60ec517c06a0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples.paint/src/org/eclipse/swt/examples/paint/PaintSurface.java", "commitBeforeChange": "5b8ae07854adf758fece3e9edc1eb633b64c848c", "commitAfterChange": "94677a2d5391fe7be93905dbd899ee9b53a2cd09", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r\tpublic void dispose()", "signatureAfterChange": "\r\tpublic void dispose()", "diff": ["-\tprivate final Canvas      paintCanvas;\r\r\tprivate PaintSession paintSession;\r\tprivate Image image;\r\tprivate int   imageWidth, imageHeight;\r\tprivate int   visibleWidth, visibleHeight;\r\r\tprivate FigureDrawContext displayFDC = new FigureDrawContext();\r\tprivate FigureDrawContext imageFDC = new FigureDrawContext();\r\r\t/* Rubberband */\r\tprivate ContainerFigure rubberband = new ContainerFigure();\r\t\t// the active rubberband selection\r\tprivate int rubberbandHiddenNestingCount = 0;\r\t\t// always >= 0, if > 0 rubberband has been hidden\r\r\t/* Status */\r\tprivate final Text statusText;\r\tprivate String statusActionInfo, statusMessageInfo, statusCoordInfo;\r\r\t/**\r\t * Constructs a PaintSurface.\r\t * <p>\r\t * paintCanvas must have SWT.NO_REDRAW_RESIZE and SWT.NO_BACKGROUND styles,\r\t *     and may have SWT.V_SCROLL and/or SWT.H_SCROLL.\r\t * </p>\r\t * @param paintCanvas the Canvas object in which to render\r\t * @param paintStatus the PaintStatus object to use for providing user feedback\r\t */\r", "-\tpublic PaintSurface(Canvas paintCanvas, Text statusText) {\r\t\tthis.paintCanvas = paintCanvas;\r\t\tthis.statusText = statusText;\r\t\tclearStatus();\r\r\t\t/* Set up the drawing surface */\r\t\tRectangle displayRect = paintCanvas.getDisplay().getClientArea();\r\t\timageWidth = displayRect.width;\r\t\timageHeight = displayRect.height;\r\t\timage = new Image(paintCanvas.getDisplay(), imageWidth, imageHeight);\r\r\t\timageFDC.gc = new GC(image);\r\t\tdisplayFDC.gc = new GC(paintCanvas);\r\r\t\t/* Initialize the session */\r\t\tsetPaintSession(null);\r\r\t\t/* Add our listeners */\r\t\tpaintCanvas.addMouseListener(new MouseAdapter() {\r\t\t\tpublic void mouseDown(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDown(event);\r\t\t\t}\r\t\t\tpublic void mouseUp(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseUp(event);\r\t\t\t}\r\t\t\tpublic void mouseDoubleClick(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDoubleClick(event);\r\t\t\t}\t\t\t\r\t\t});\r\t\tpaintCanvas.addMouseMoveListener(new MouseMoveListener() {\r\t\t\tpublic void mouseMove(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseMove(event);\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addPaintListener(new PaintListener() {\r\t\t\tpublic void paintControl(PaintEvent event) {\r\t\t\t\tif (rubberband.isEmpty()) {\r\t\t\t\t\tevent.gc.drawImage(image,\r\t\t\t\t\t\tdisplayFDC.xOffset, displayFDC.yOffset, visibleWidth, visibleHeight,\r\t\t\t\t\t\t0, 0, visibleWidth, visibleHeight);\r\t\t\t\t} else {\r\t\t\t\t\t// avoid flicker\r\t\t\t\t\tRectangle clip = event.gc.getClipping();\r\t\t\t\t\tImage blitImage = new Image(getDisplay(), clip.width, clip.height);\r\t\t\t\t\tFigureDrawContext fdc = new FigureDrawContext();\r\t\t\t\t\tfdc.gc = new GC(blitImage);\r\t\t\t\t\tfdc.xOffset = displayFDC.xOffset + clip.x;\r\t\t\t\t\tfdc.yOffset = displayFDC.yOffset + clip.y;\r\t\t\t\t\tfdc.gc.drawImage(image,\r\t\t\t\t\t\tclip.x + displayFDC.xOffset, clip.y + displayFDC.yOffset, clip.width, clip.height,\r\t\t\t\t\t\t0, 0, clip.width, clip.height);\r\t\t\t\t\trubberband.draw(fdc);\r\t\t\t\t\tfdc.gc.dispose();\r\t\t\t\t\tevent.gc.drawImage(blitImage, clip.x, clip.y);\r\t\t\t\t\tblitImage.dispose();\r\t\t\t\t}\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addControlListener(new ControlAdapter() {\r\t\t\tpublic void controlResized(ControlEvent event) {\r\t\t\t\thandleResize();\r\t\t\t}\t\t\t\r\t\t});\r\r\t\t/* Set up the paint canvas scroll bars */\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\thorizontal.setVisible(true);\r\t\thorizontal.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollHorizontally((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tvertical.setVisible(true);\r\t\tvertical.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollVertically((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\thandleResize();\r\t}\r\t\r\t/**\r\t * Disposes of the PaintSurface's resources.\r\t */\r\tpublic void dispose() {\r\t\timageFDC.gc.dispose();\r\t\tdisplayFDC.gc.dispose();\r\t\timage.dispose();\t\t\r\t}\r\r\t/**\r\t * Called when we must grab focus.\r\t */\r\tpublic void setFocus()  {\r\t\tpaintCanvas.setFocus();\r\t}\r\r\t/**\r\t * Returns the Display on which the PaintSurface resides.\r\t * @return the Display\r\t */\r\tpublic Display getDisplay() {\r\t\treturn paintCanvas.getDisplay();\r\t}\r\r\t/**\r\t * Returns the Shell in which the PaintSurface resides.\r\t * @return the Shell\r\t */\r\tpublic Shell getShell() {\r\t\treturn paintCanvas.getShell();\r\t}\r\r\t/**\r", "+\tprivate Canvas paintCanvas;\r\r\tprivate PaintSession paintSession;\r\tprivate Image image;\r\tprivate Image paintImage; // buffer for refresh blits\r\tprivate int   imageWidth, imageHeight;\r\tprivate int   visibleWidth, visibleHeight;\r\r\tprivate FigureDrawContext displayFDC = new FigureDrawContext();\r\tprivate FigureDrawContext imageFDC = new FigureDrawContext();\r\tprivate FigureDrawContext paintFDC = new FigureDrawContext();\r\r\t/* Rubberband */\r\tprivate ContainerFigure rubberband = new ContainerFigure();\r\t\t// the active rubberband selection\r\tprivate int rubberbandHiddenNestingCount = 0;\r\t\t// always >= 0, if > 0 rubberband has been hidden\r\r\t/* Status */\r\tprivate Text statusText;\r\tprivate String statusActionInfo, statusMessageInfo, statusCoordInfo;\r\r\t/**\r\t * Constructs a PaintSurface.\r\t * <p>\r\t * paintCanvas must have SWT.NO_REDRAW_RESIZE and SWT.NO_BACKGROUND styles,\r\t *     and may have SWT.V_SCROLL and/or SWT.H_SCROLL.\r\t * </p>\r\t * @param paintCanvas the Canvas object in which to render\r\t * @param paintStatus the PaintStatus object to use for providing user feedback\r\t * @param fillColor the color to fill the canvas with initially\r\t */\r", "+\tpublic PaintSurface(Canvas paintCanvas, Text statusText, Color fillColor) {\r\t\tthis.paintCanvas = paintCanvas;\r\t\tthis.statusText = statusText;\r\t\tclearStatus();\r\r\t\t/* Set up the drawing surface */\r\t\tRectangle displayRect = paintCanvas.getDisplay().getClientArea();\r\t\timageWidth = displayRect.width;\r\t\timageHeight = displayRect.height;\r\t\timage = new Image(paintCanvas.getDisplay(), imageWidth, imageHeight);\r\r\t\timageFDC.gc = new GC(image);\r\t\timageFDC.gc.setBackground(fillColor);\r\t\timageFDC.gc.fillRectangle(0, 0, imageWidth, imageHeight);\r\t\tdisplayFDC.gc = new GC(paintCanvas);\r\r\t\t/* Initialize the session */\r\t\tsetPaintSession(null);\r\r\t\t/* Add our listeners */\r\t\tpaintCanvas.addMouseListener(new MouseAdapter() {\r\t\t\tpublic void mouseDown(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDown(event);\r\t\t\t}\r\t\t\tpublic void mouseUp(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseUp(event);\r\t\t\t}\r\t\t\tpublic void mouseDoubleClick(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDoubleClick(event);\r\t\t\t}\t\t\t\r\t\t});\r\t\tpaintCanvas.addMouseMoveListener(new MouseMoveListener() {\r\t\t\tpublic void mouseMove(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseMove(event);\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addPaintListener(new PaintListener() {\r\t\t\tpublic void paintControl(PaintEvent event) {\r\t\t\t\tSystem.out.println(\"Paint: \" + event.x + \", \" + event.y + \": \" + event.width + \", \" + event.height);\r\t\t\t\t\r\t\t\t\tif (rubberband.isEmpty()) {\r\t\t\t\t\tevent.gc.drawImage(image,\r\t\t\t\t\t\tdisplayFDC.xOffset + event.x, displayFDC.yOffset + event.y, event.width, event.height,\r\t\t\t\t\t\tevent.x, event.y, event.width, event.height);\r\t\t\t\t} else {\r\t\t\t\t\t// avoid flicker when merging overlayed objects\r\t\t\t\t\tif (paintImage != null) {\r\t\t\t\t\t\tRectangle rect = paintImage.getBounds();\r\t\t\t\t\t\tif ((event.width + event.x > rect.width) ||\r\t\t\t\t\t\t\t(event.height + event.y > rect.height)) {\r\t\t\t\t\t\t\tpaintFDC.gc.dispose();\r\t\t\t\t\t\t\tpaintImage.dispose();\r\t\t\t\t\t\t\tpaintImage = null;\r\t\t\t\t\t\t}\r\t\t\t\t\t}\r\t\t\t\t\tif (paintImage == null) {\r\t\t\t\t\t\tDisplay display = getDisplay();\r\t\t\t\t\t\tRectangle rect = display.getClientArea();\r\t\t\t\t\t\tpaintImage = new Image(display,\r\t\t\t\t\t\t\tMath.max(rect.width, event.width + event.x),\r\t\t\t\t\t\t\tMath.max(rect.height, event.height + event.y));\r\t\t\t\t\t\tpaintFDC.gc = new GC(paintImage);\r\t\t\t\t\t}\r\t\t\t\t\tRegion clipRegion = new Region();\r\t\t\t\t\tevent.gc.getClipping(clipRegion);\t\t\t\t\t\r\t\t\t\t\tpaintFDC.gc.setClipping(clipRegion);\r\t\t\t\t\tclipRegion.dispose();\r\r\t\t\t\t\tpaintFDC.xOffset = displayFDC.xOffset;\r\t\t\t\t\tpaintFDC.yOffset = displayFDC.yOffset;\r\t\t\t\t\tpaintFDC.xScale = displayFDC.xScale;\r\t\t\t\t\tpaintFDC.yScale = displayFDC.yScale;\r\t\t\t\t\tpaintFDC.gc.drawImage(image,\r\t\t\t\t\t\tdisplayFDC.xOffset + event.x, displayFDC.yOffset + event.y, event.width, event.height,\r\t\t\t\t\t\tevent.x, event.y, event.width, event.height);\r\t\t\t\t\trubberband.draw(paintFDC);\r\t\t\t\t\tevent.gc.drawImage(paintImage,\r\t\t\t\t\t\tevent.x, event.y, event.width, event.height,\r\t\t\t\t\t\tevent.x, event.y, event.width, event.height);\r\t\t\t\t}\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addControlListener(new ControlAdapter() {\r\t\t\tpublic void controlResized(ControlEvent event) {\r\t\t\t\thandleResize();\r\t\t\t}\t\t\t\r\t\t});\r\r\t\t/* Set up the paint canvas scroll bars */\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\thorizontal.setVisible(true);\r\t\thorizontal.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollHorizontally((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tvertical.setVisible(true);\r\t\tvertical.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollVertically((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\thandleResize();\r\t\tpaintCanvas.redraw();\r\t}\r\t\r\t/**\r\t * Disposes of the PaintSurface's resources.\r\t */\r\tpublic void dispose() {\r\t\timageFDC.gc.dispose();\r\t\tdisplayFDC.gc.dispose();\r\t\timage.dispose();\r\t\tif (paintImage != null) {\r\t\t\tpaintImage.dispose();\r\t\t\tpaintFDC.gc.dispose();\r\t\t}\r\r\t\tcurrentPosition = null;\r\t\tpaintCanvas = null;\r\t\tpaintSession = null;\r\t\timage = null;\r\t\tpaintImage = null;\r\t\tdisplayFDC = null;\r\t\timageFDC = null;\r\t\tpaintFDC = null;\r\t\trubberband = null;\r\t\tstatusText = null;\r\t\tstatusActionInfo = null;\r\t\tstatusMessageInfo = null;\r\t\tstatusCoordInfo = null;\r\t}\r\r\t/**\r\t * Called when we must grab focus.\r\t */\r\tpublic void setFocus()  {\r\t\tpaintCanvas.setFocus();\r\t}\r\r\t/**\r\t * Returns the Display on which the PaintSurface resides.\r\t * @return the Display\r\t */\r\tpublic Display getDisplay() {\r\t\treturn paintCanvas.getDisplay();\r\t}\r\r\t/**\r\t * Returns the Shell in which the PaintSurface resides.\r\t * @return the Shell\r\t */\r\tpublic Shell getShell() {\r\t\treturn paintCanvas.getShell();\r\t}\r\r\t/**\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "04069e1c2bc551e958db93cfcb143acc", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples.paint/org/eclipse/swt/examples/paint/PaintSurface.java", "commitBeforeChange": "5b8ae07854adf758fece3e9edc1eb633b64c848c", "commitAfterChange": "94677a2d5391fe7be93905dbd899ee9b53a2cd09", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r\tpublic void dispose()", "signatureAfterChange": "\r\tpublic void dispose()", "diff": ["-\tprivate final Canvas      paintCanvas;\r\r\tprivate PaintSession paintSession;\r\tprivate Image image;\r\tprivate int   imageWidth, imageHeight;\r\tprivate int   visibleWidth, visibleHeight;\r\r\tprivate FigureDrawContext displayFDC = new FigureDrawContext();\r\tprivate FigureDrawContext imageFDC = new FigureDrawContext();\r\r\t/* Rubberband */\r\tprivate ContainerFigure rubberband = new ContainerFigure();\r\t\t// the active rubberband selection\r\tprivate int rubberbandHiddenNestingCount = 0;\r\t\t// always >= 0, if > 0 rubberband has been hidden\r\r\t/* Status */\r\tprivate final Text statusText;\r\tprivate String statusActionInfo, statusMessageInfo, statusCoordInfo;\r\r\t/**\r\t * Constructs a PaintSurface.\r\t * <p>\r\t * paintCanvas must have SWT.NO_REDRAW_RESIZE and SWT.NO_BACKGROUND styles,\r\t *     and may have SWT.V_SCROLL and/or SWT.H_SCROLL.\r\t * </p>\r\t * @param paintCanvas the Canvas object in which to render\r\t * @param paintStatus the PaintStatus object to use for providing user feedback\r\t */\r", "-\tpublic PaintSurface(Canvas paintCanvas, Text statusText) {\r\t\tthis.paintCanvas = paintCanvas;\r\t\tthis.statusText = statusText;\r\t\tclearStatus();\r\r\t\t/* Set up the drawing surface */\r\t\tRectangle displayRect = paintCanvas.getDisplay().getClientArea();\r\t\timageWidth = displayRect.width;\r\t\timageHeight = displayRect.height;\r\t\timage = new Image(paintCanvas.getDisplay(), imageWidth, imageHeight);\r\r\t\timageFDC.gc = new GC(image);\r\t\tdisplayFDC.gc = new GC(paintCanvas);\r\r\t\t/* Initialize the session */\r\t\tsetPaintSession(null);\r\r\t\t/* Add our listeners */\r\t\tpaintCanvas.addMouseListener(new MouseAdapter() {\r\t\t\tpublic void mouseDown(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDown(event);\r\t\t\t}\r\t\t\tpublic void mouseUp(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseUp(event);\r\t\t\t}\r\t\t\tpublic void mouseDoubleClick(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDoubleClick(event);\r\t\t\t}\t\t\t\r\t\t});\r\t\tpaintCanvas.addMouseMoveListener(new MouseMoveListener() {\r\t\t\tpublic void mouseMove(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseMove(event);\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addPaintListener(new PaintListener() {\r\t\t\tpublic void paintControl(PaintEvent event) {\r\t\t\t\tif (rubberband.isEmpty()) {\r\t\t\t\t\tevent.gc.drawImage(image,\r\t\t\t\t\t\tdisplayFDC.xOffset, displayFDC.yOffset, visibleWidth, visibleHeight,\r\t\t\t\t\t\t0, 0, visibleWidth, visibleHeight);\r\t\t\t\t} else {\r\t\t\t\t\t// avoid flicker\r\t\t\t\t\tRectangle clip = event.gc.getClipping();\r\t\t\t\t\tImage blitImage = new Image(getDisplay(), clip.width, clip.height);\r\t\t\t\t\tFigureDrawContext fdc = new FigureDrawContext();\r\t\t\t\t\tfdc.gc = new GC(blitImage);\r\t\t\t\t\tfdc.xOffset = displayFDC.xOffset + clip.x;\r\t\t\t\t\tfdc.yOffset = displayFDC.yOffset + clip.y;\r\t\t\t\t\tfdc.gc.drawImage(image,\r\t\t\t\t\t\tclip.x + displayFDC.xOffset, clip.y + displayFDC.yOffset, clip.width, clip.height,\r\t\t\t\t\t\t0, 0, clip.width, clip.height);\r\t\t\t\t\trubberband.draw(fdc);\r\t\t\t\t\tfdc.gc.dispose();\r\t\t\t\t\tevent.gc.drawImage(blitImage, clip.x, clip.y);\r\t\t\t\t\tblitImage.dispose();\r\t\t\t\t}\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addControlListener(new ControlAdapter() {\r\t\t\tpublic void controlResized(ControlEvent event) {\r\t\t\t\thandleResize();\r\t\t\t}\t\t\t\r\t\t});\r\r\t\t/* Set up the paint canvas scroll bars */\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\thorizontal.setVisible(true);\r\t\thorizontal.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollHorizontally((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tvertical.setVisible(true);\r\t\tvertical.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollVertically((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\thandleResize();\r\t}\r\t\r\t/**\r\t * Disposes of the PaintSurface's resources.\r\t */\r\tpublic void dispose() {\r\t\timageFDC.gc.dispose();\r\t\tdisplayFDC.gc.dispose();\r\t\timage.dispose();\t\t\r\t}\r\r\t/**\r\t * Called when we must grab focus.\r\t */\r\tpublic void setFocus()  {\r\t\tpaintCanvas.setFocus();\r\t}\r\r\t/**\r\t * Returns the Display on which the PaintSurface resides.\r\t * @return the Display\r\t */\r\tpublic Display getDisplay() {\r\t\treturn paintCanvas.getDisplay();\r\t}\r\r\t/**\r\t * Returns the Shell in which the PaintSurface resides.\r\t * @return the Shell\r\t */\r\tpublic Shell getShell() {\r\t\treturn paintCanvas.getShell();\r\t}\r\r\t/**\r", "+\tprivate Canvas paintCanvas;\r\r\tprivate PaintSession paintSession;\r\tprivate Image image;\r\tprivate Image paintImage; // buffer for refresh blits\r\tprivate int   imageWidth, imageHeight;\r\tprivate int   visibleWidth, visibleHeight;\r\r\tprivate FigureDrawContext displayFDC = new FigureDrawContext();\r\tprivate FigureDrawContext imageFDC = new FigureDrawContext();\r\tprivate FigureDrawContext paintFDC = new FigureDrawContext();\r\r\t/* Rubberband */\r\tprivate ContainerFigure rubberband = new ContainerFigure();\r\t\t// the active rubberband selection\r\tprivate int rubberbandHiddenNestingCount = 0;\r\t\t// always >= 0, if > 0 rubberband has been hidden\r\r\t/* Status */\r\tprivate Text statusText;\r\tprivate String statusActionInfo, statusMessageInfo, statusCoordInfo;\r\r\t/**\r\t * Constructs a PaintSurface.\r\t * <p>\r\t * paintCanvas must have SWT.NO_REDRAW_RESIZE and SWT.NO_BACKGROUND styles,\r\t *     and may have SWT.V_SCROLL and/or SWT.H_SCROLL.\r\t * </p>\r\t * @param paintCanvas the Canvas object in which to render\r\t * @param paintStatus the PaintStatus object to use for providing user feedback\r\t * @param fillColor the color to fill the canvas with initially\r\t */\r", "+\tpublic PaintSurface(Canvas paintCanvas, Text statusText, Color fillColor) {\r\t\tthis.paintCanvas = paintCanvas;\r\t\tthis.statusText = statusText;\r\t\tclearStatus();\r\r\t\t/* Set up the drawing surface */\r\t\tRectangle displayRect = paintCanvas.getDisplay().getClientArea();\r\t\timageWidth = displayRect.width;\r\t\timageHeight = displayRect.height;\r\t\timage = new Image(paintCanvas.getDisplay(), imageWidth, imageHeight);\r\r\t\timageFDC.gc = new GC(image);\r\t\timageFDC.gc.setBackground(fillColor);\r\t\timageFDC.gc.fillRectangle(0, 0, imageWidth, imageHeight);\r\t\tdisplayFDC.gc = new GC(paintCanvas);\r\r\t\t/* Initialize the session */\r\t\tsetPaintSession(null);\r\r\t\t/* Add our listeners */\r\t\tpaintCanvas.addMouseListener(new MouseAdapter() {\r\t\t\tpublic void mouseDown(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDown(event);\r\t\t\t}\r\t\t\tpublic void mouseUp(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseUp(event);\r\t\t\t}\r\t\t\tpublic void mouseDoubleClick(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDoubleClick(event);\r\t\t\t}\t\t\t\r\t\t});\r\t\tpaintCanvas.addMouseMoveListener(new MouseMoveListener() {\r\t\t\tpublic void mouseMove(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseMove(event);\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addPaintListener(new PaintListener() {\r\t\t\tpublic void paintControl(PaintEvent event) {\r\t\t\t\tSystem.out.println(\"Paint: \" + event.x + \", \" + event.y + \": \" + event.width + \", \" + event.height);\r\t\t\t\t\r\t\t\t\tif (rubberband.isEmpty()) {\r\t\t\t\t\tevent.gc.drawImage(image,\r\t\t\t\t\t\tdisplayFDC.xOffset + event.x, displayFDC.yOffset + event.y, event.width, event.height,\r\t\t\t\t\t\tevent.x, event.y, event.width, event.height);\r\t\t\t\t} else {\r\t\t\t\t\t// avoid flicker when merging overlayed objects\r\t\t\t\t\tif (paintImage != null) {\r\t\t\t\t\t\tRectangle rect = paintImage.getBounds();\r\t\t\t\t\t\tif ((event.width + event.x > rect.width) ||\r\t\t\t\t\t\t\t(event.height + event.y > rect.height)) {\r\t\t\t\t\t\t\tpaintFDC.gc.dispose();\r\t\t\t\t\t\t\tpaintImage.dispose();\r\t\t\t\t\t\t\tpaintImage = null;\r\t\t\t\t\t\t}\r\t\t\t\t\t}\r\t\t\t\t\tif (paintImage == null) {\r\t\t\t\t\t\tDisplay display = getDisplay();\r\t\t\t\t\t\tRectangle rect = display.getClientArea();\r\t\t\t\t\t\tpaintImage = new Image(display,\r\t\t\t\t\t\t\tMath.max(rect.width, event.width + event.x),\r\t\t\t\t\t\t\tMath.max(rect.height, event.height + event.y));\r\t\t\t\t\t\tpaintFDC.gc = new GC(paintImage);\r\t\t\t\t\t}\r\t\t\t\t\tRegion clipRegion = new Region();\r\t\t\t\t\tevent.gc.getClipping(clipRegion);\t\t\t\t\t\r\t\t\t\t\tpaintFDC.gc.setClipping(clipRegion);\r\t\t\t\t\tclipRegion.dispose();\r\r\t\t\t\t\tpaintFDC.xOffset = displayFDC.xOffset;\r\t\t\t\t\tpaintFDC.yOffset = displayFDC.yOffset;\r\t\t\t\t\tpaintFDC.xScale = displayFDC.xScale;\r\t\t\t\t\tpaintFDC.yScale = displayFDC.yScale;\r\t\t\t\t\tpaintFDC.gc.drawImage(image,\r\t\t\t\t\t\tdisplayFDC.xOffset + event.x, displayFDC.yOffset + event.y, event.width, event.height,\r\t\t\t\t\t\tevent.x, event.y, event.width, event.height);\r\t\t\t\t\trubberband.draw(paintFDC);\r\t\t\t\t\tevent.gc.drawImage(paintImage,\r\t\t\t\t\t\tevent.x, event.y, event.width, event.height,\r\t\t\t\t\t\tevent.x, event.y, event.width, event.height);\r\t\t\t\t}\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addControlListener(new ControlAdapter() {\r\t\t\tpublic void controlResized(ControlEvent event) {\r\t\t\t\thandleResize();\r\t\t\t}\t\t\t\r\t\t});\r\r\t\t/* Set up the paint canvas scroll bars */\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\thorizontal.setVisible(true);\r\t\thorizontal.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollHorizontally((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tvertical.setVisible(true);\r\t\tvertical.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollVertically((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\thandleResize();\r\t\tpaintCanvas.redraw();\r\t}\r\t\r\t/**\r\t * Disposes of the PaintSurface's resources.\r\t */\r\tpublic void dispose() {\r\t\timageFDC.gc.dispose();\r\t\tdisplayFDC.gc.dispose();\r\t\timage.dispose();\r\t\tif (paintImage != null) {\r\t\t\tpaintImage.dispose();\r\t\t\tpaintFDC.gc.dispose();\r\t\t}\r\r\t\tcurrentPosition = null;\r\t\tpaintCanvas = null;\r\t\tpaintSession = null;\r\t\timage = null;\r\t\tpaintImage = null;\r\t\tdisplayFDC = null;\r\t\timageFDC = null;\r\t\tpaintFDC = null;\r\t\trubberband = null;\r\t\tstatusText = null;\r\t\tstatusActionInfo = null;\r\t\tstatusMessageInfo = null;\r\t\tstatusCoordInfo = null;\r\t}\r\r\t/**\r\t * Called when we must grab focus.\r\t */\r\tpublic void setFocus()  {\r\t\tpaintCanvas.setFocus();\r\t}\r\r\t/**\r\t * Returns the Display on which the PaintSurface resides.\r\t * @return the Display\r\t */\r\tpublic Display getDisplay() {\r\t\treturn paintCanvas.getDisplay();\r\t}\r\r\t/**\r\t * Returns the Shell in which the PaintSurface resides.\r\t * @return the Shell\r\t */\r\tpublic Shell getShell() {\r\t\treturn paintCanvas.getShell();\r\t}\r\r\t/**\r"]}], "num": 50684}