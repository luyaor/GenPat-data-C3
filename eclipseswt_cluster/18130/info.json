{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "38e90db3136ffa3f5e6d93a5f399b355", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f0355cc1b7b4e1ecb4c24f6e12e24e7", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/TableItem.java", "commitBeforeChange": "ed6471c0ec0d0ee0c1436d2bdeadc8ba513ab4fd", "commitAfterChange": "034d8fba7f4ca7576ddaeee539a2fb56ee664327", "methodNumberBeforeChange": 53, "methodNumberAfterChange": 39, "signatureBeforeChange": " void paint(GC gc, Point paintPosition, TableColumn column)", "signatureAfterChange": " void paint (GC gc, TableColumn column, boolean paintCellContent)", "diff": ["- */", "-void paint(GC gc, Point paintPosition, TableColumn column) {", "-\tint columnIndex = column.getIndex();", "-\tString label = getText(gc, column);", "-\tString oldLabel = getTrimmedText(columnIndex);", "-\tTable parent = getParent ();", "-\tint itemHeight = parent.getItemHeight ();", "-\t", "-\tif (label != null && label.equals(oldLabel) == false) {", "-\t\tsetTrimmedText(label, columnIndex);", "-\t\tselectionExtent = null;\t\t// force a recalculation next time the selection extent is needed", "-\t}", "-\tColor background = gc.getBackground();", "-\tif (!isSelected() || ((parent.getStyle() & SWT.HIDE_SELECTION) != 0 && !parent.isFocusControl())) {", "-\t\tint width = column.getBounds().width;", "-\t\tint height = itemHeight;", "-\t\tgc.setBackground(getBackground(columnIndex));", "-\t\tgc.fillRectangle(paintPosition.x, paintPosition.y, width, height);", "-\t\tif (columnIndex == TableColumn.FIRST) {", "-\t\t\tint width = getImageIndentPixel();", "-\t\t\tint height = itemHeight;", "-\t\t\tgc.setBackground(getBackground (columnIndex));", "-\t\t\tgc.fillRectangle(paintPosition.x, paintPosition.y, width, height);", "-\t\t\tif ((parent.getStyle() & SWT.FULL_SELECTION) == 0) {", "-\t\t\t\tint width = column.getBounds ().width;", "-\t\t\t\tint height = itemHeight;", "-\t\t\t\tgc.setBackground(getBackground (columnIndex));", "-\t\t\t\tgc.fillRectangle(paintPosition.x, paintPosition.y, width, height);", "+ */", "+void paint (GC gc, TableColumn column, boolean paintCellContent) {", "+\tif (!parent.checkData (this, true)) return;", "+\tint columnIndex = 0, x = 0;", "+\tif (column != null) {", "+\t\tcolumnIndex = column.getIndex ();", "+\t\tx = column.getX ();", "+\t}", "+\t/* if this cell is completely to the right of the client area then there's no need to paint it */", "+\tRectangle clientArea = parent.getClientArea ();", "+\tif (clientArea.x + clientArea.width < x) return;", "+", "+\tRectangle cellBounds = getCellBounds (columnIndex);", "+\tint cellRightX = 0;", "+\tif (column != null) {", "+\t\tcellRightX = column.getX () + column.width;", "+\t} else {", "+\t\tcellRightX = cellBounds.x + cellBounds.width;", "+\t}", "+", "+\t/* if this cell is completely to the left of the client area then there's no need to paint it */", "+\tif (cellRightX < 0) return;", "+", "+\t/* restrict the clipping region to the cell */", "+\tgc.setClipping (x, cellBounds.y, cellRightX - x, cellBounds.height);", "+\t", "+\tint y = parent.getItemY (this);", "+\tint padding = parent.getCellPadding ();", "+\tint itemHeight = parent.itemHeight;", "+", "+\t/* draw the background color if this item has a custom color set */", "+\tColor background = getBackground (columnIndex);", "+\tif (!background.equals (parent.getBackground ())) {", "+\t\tColor oldBackground = gc.getBackground ();", "+\t\tgc.setBackground (background);", "+\t\tif (columnIndex == 0) {", "+\t\t\tRectangle focusBounds = getFocusBounds ();", "+\t\t\tint fillWidth = 0;", "+\t\t\tif (column == null) {", "+\t\t\t\tfillWidth = focusBounds.width;", "+\t\t\t} else {", "+\t\t\t\tfillWidth = column.width - focusBounds.x;", "+\t\t\t\tif (parent.linesVisible) fillWidth--;", "+\t\t\t}", "+\t\t\tgc.fillRectangle (focusBounds.x, focusBounds.y, fillWidth, focusBounds.height);", "+\t\t} else {", "+\t\t\tint fillWidth = cellBounds.width;", "+\t\t\tif (parent.linesVisible) fillWidth--;", "+\t\t\tgc.fillRectangle (cellBounds.x, cellBounds.y + 1, fillWidth, cellBounds.height - 1);", "+\t\t}", "+\t\tgc.setBackground (oldBackground);", "+\t}", "+", "+\t/* draw the selection bar if the receiver is selected */", "+\tif (isSelected () && (columnIndex == 0 || (parent.style & SWT.FULL_SELECTION) != 0)) {", "+\t\tif (parent.hasFocus () || (parent.style & SWT.HIDE_SELECTION) == 0) {", "+\t\t\tColor oldBackground = gc.getBackground ();", "+\t\t\tgc.setBackground (display.getSystemColor (SWT.COLOR_LIST_SELECTION));", "+\t\t\tif (columnIndex == 0) {", "+\t\t\t\tRectangle focusBounds = getFocusBounds ();", "+\t\t\t\tint fillWidth = focusBounds.width;", "+\t\t\t\tif (parent.columns.length < 2 || (parent.style & SWT.FULL_SELECTION) == 0) {", "+\t\t\t\t\tfillWidth -= 2;\t/* space for right bound of focus rect */", "+\t\t\t\t}", "+\t\t\t\tgc.fillRectangle (focusBounds.x + 1, focusBounds.y + 1, fillWidth, focusBounds.height - 2);", "+\t\t\t} else {", "+\t\t\t\tint fillWidth = column.width;", "+\t\t\t\tif (columnIndex == parent.columns.length - 1) {", "+\t\t\t\t\tfillWidth -= 2;\t\t/* space for right bound of focus rect */", "+\t\t\t\t}", "+\t\t\t\tgc.fillRectangle (column.getX (), y + 2, fillWidth, itemHeight - 3);", "+\t\t\t}", "+\t\t\tgc.setBackground (oldBackground);", "+\t\t}", "+\t}", "+", "+\tif (!paintCellContent) return;", "+", "+\t/* Draw checkbox if drawing column 0 and parent has style SWT.CHECK */", "+\tif (columnIndex == 0 && (parent.style & SWT.CHECK) != 0) {", "+\t\tImage baseImage = grayed ? parent.getGrayUncheckedImage () : parent.getUncheckedImage ();", "+\t\tRectangle checkboxBounds = getCheckboxBounds ();", "+\t\tgc.drawImage (baseImage, checkboxBounds.x, checkboxBounds.y);", "+\t\t/* Draw checkmark if item is checked */", "+\t\tif (checked) {", "+\t\t\tImage checkmarkImage = parent.getCheckmarkImage ();", "+\t\t\tRectangle checkmarkBounds = checkmarkImage.getBounds ();", "+\t\t\tint xInset = (checkboxBounds.width - checkmarkBounds.width) / 2;", "+\t\t\tint yInset = (checkboxBounds.height - checkmarkBounds.height) / 2;", "+\t\t\tgc.drawImage (checkmarkImage, checkboxBounds.x + xInset, checkboxBounds.y + yInset);", "+\t\t}", "+\t}", "+", "+\tImage image = getImage (columnIndex);", "+\tString text = getDisplayText (columnIndex);", "+\tRectangle imageArea = getImageBounds (columnIndex);", "+\tint startX = imageArea.x;", "+\t", "+\t/* while painting the cell's content restrict the clipping region */", "+\tgc.setClipping (", "+\t\tstartX,", "+\t\tcellBounds.y + padding,", "+\t\tcellRightX - startX - padding,", "+\t\tcellBounds.height - (2 * padding));", "+", "+\t/* draw the image */", "+\tif (image != null) {", "+\t\tRectangle imageBounds = image.getBounds ();", "+\t\tgc.drawImage (", "+\t\t\timage,", "+\t\t\t0, 0,\t\t\t\t\t\t\t\t\t/* source x, y */", "+\t\t\timageBounds.width, imageBounds.height,\t/* source width, height */", "+\t\t\timageArea.x, imageArea.y,\t\t\t\t/* dest x, y */", "+\t\t\timageArea.width, imageArea.height);\t\t/* dest width, height */", "+\t}", "+\t", "+\t/* draw the text */", "+\tif (text.length () > 0) {", "+\t\tboolean fontChanged = false, foregroundChanged = false;", "+\t\tFont oldFont = gc.getFont ();", "+\t\tFont font = getFont (columnIndex);", "+\t\tif (!font.equals (oldFont)) {", "+\t\t\tgc.setFont (font);", "+\t\t\tfontChanged = true;", "+\t\t}", "+\t\tint fontHeight = getFontHeight (columnIndex);", "+\t\tColor oldForeground = gc.getForeground ();", "+\t\tif (isSelected () && (columnIndex == 0 || (parent.style & SWT.FULL_SELECTION) != 0)) {", "+\t\t\tif (parent.hasFocus () || (parent.style & SWT.HIDE_SELECTION) == 0) {", "+\t\t\t\tgc.setForeground (display.getSystemColor (SWT.COLOR_LIST_SELECTION_TEXT));", "+\t\t\t\tforegroundChanged = true;", "+\t\t\t}", "+\t\t} else {", "+\t\t\tColor foreground = getForeground (columnIndex);", "+\t\t\tif (!foreground.equals (oldForeground)) {", "+\t\t\t\tgc.setForeground (foreground);", "+\t\t\t\tforegroundChanged = true;", "+\t\tx = getTextX (columnIndex) + MARGIN_TEXT;", "+\t\tgc.drawString (text, x, y + (itemHeight - fontHeight) / 2, true);", "+\t\tif (foregroundChanged) gc.setForeground (oldForeground);", "+\t\tif (fontChanged) gc.setFont (oldFont);", "-\tif (columnIndex == TableColumn.FIRST) {", "-\t\tpaintPosition.x += getImageIndentPixel();", "-\t\tif (isCheckable() == true) {", "-\t\t\tpaintPosition = drawCheckbox(gc, paintPosition);", "-\t\t}\t\t", "-\t}", "-\tpaintPosition = drawImage(gc, paintPosition, columnIndex);", "-\tpaintPosition.x += getTextIndent(columnIndex);", "-\tdrawText(label, gc, paintPosition, columnIndex);", "-\tgc.setBackground(background);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "59a28854f0ebc680c6477c938be3bdcb", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/TreeItem.java", "commitBeforeChange": "ed568a606dfba062e77bacc7c7f799741b60cbf4", "commitAfterChange": "3e04f21595fe557524d009b946647c76885ec76f", "methodNumberBeforeChange": 47, "methodNumberAfterChange": 53, "signatureBeforeChange": " void paint(GC gc, int yPosition)", "signatureAfterChange": " void paint (GC gc, TreeColumn column, boolean paintCellContent)", "diff": ["- */", "-void paint(GC gc, int yPosition) {", "-\tif (isVisible() == false) {", "-\t\treturn;", "-\t}", "-\tTree parent = getParent();", "-\tFont font = getFont();", "-\tgc.setFont(font);", "-\tPoint paintPosition = new Point(getPaintStartX(), yPosition);", "-\tPoint extent = getSelectionExtent();", "-\tgc.setForeground(parent.CONNECTOR_LINE_COLOR);", "-\tpaintPosition = drawVerticalItemConnector(gc, paintPosition);", "-\tpaintPosition = drawHierarchyIndicator(gc, paintPosition);", "-\tpaintPosition = drawHorizontalItemConnector(gc, paintPosition);", "-\tgc.setForeground(parent.getForeground());", "-\t// paint the rest", "-\tif (isCheckable() == true) {", "-\t\tpaintPosition = drawCheckbox(gc, new Point(paintPosition.x, yPosition));", "-\t}", "-\tpaintPosition = drawImage(gc, new Point(paintPosition.x, yPosition));", "-\tif (isSelected() == true) {", "-\t\tgc.setBackground(getSelectionBackgroundColor());", "-\t\tgc.setForeground(getSelectionForegroundColor());", "-\t\tgc.fillRectangle(paintPosition.x, paintPosition.y, extent.x, extent.y);", "-\t} else {", "-\t\tgc.setBackground(getBackground());", "-\t\tgc.setForeground(getForeground());", "-\t\tif(getBackground() != parent.getBackground()){", "-\t\t\tgc.fillRectangle(paintPosition.x, paintPosition.y, extent.x, extent.y);\t\t", "-\t\t}", "-\t}\t", "-\tif (text != null) {\t\t", "-\t\tgc.drawString(text, getTextXPos(), paintPosition.y + getTextYPosition(gc), true);", "-\t}", "-\tif (this == parent.getInsertItem()) {", "-\t\tdrawInsertMark(gc, paintPosition);", "-\t}", "-\tdrawSelectionFocus(gc, paintPosition);", "-}", "+ */", "+void paint (GC gc, TreeColumn column, boolean paintCellContent) {", "+\tint columnIndex = 0, x = 0;", "+\tif (column != null) {", "+\t\tcolumnIndex = column.getIndex ();", "+\t\tx = column.getX ();", "+\t}", "+\t/* if this cell is completely to the right of the client area then there's no need to paint it */", "+\tRectangle clientArea = parent.getClientArea ();", "+\tif (clientArea.x + clientArea.width < x) return;", "+", "+\tRectangle cellBounds = getBounds (columnIndex);", "+\tint cellRightX = 0;", "+\tif (column != null) {", "+\t\tcellRightX = column.getX () + column.getWidth ();", "+\t} else {", "+\t\tcellRightX = cellBounds.x + cellBounds.width;", "+\t}", "+", "+\t/* if this cell is completely to the left of the client area then there's no need to paint it */", "+\tif (cellRightX < 0) return;", "+", "+\t/* restrict the clipping region to the full cell */", "+\tgc.setClipping (x, cellBounds.y, cellRightX - x, cellBounds.height);", "+\t", "+\tint y = parent.getItemY (this);", "+\tint padding = parent.getCellPadding ();", "+\tint itemHeight = parent.getItemHeight ();", "+", "+\t/* draw the background color if this item has a custom color set */", "+\tColor background = getBackground (columnIndex);", "+\tif (background != parent.getBackground ()) {", "+\t\tColor oldBackground = gc.getBackground ();", "+\t\tgc.setBackground (background);", "+\t\tif (columnIndex == 0) {", "+\t\t\tint focusX = getFocusX ();", "+\t\t\tgc.fillRectangle (focusX, parent.getItemY (this) + 1, cellRightX - focusX - 1, parent.getItemHeight () - 1);", "+\t\t} else {", "+\t\t\tgc.fillRectangle (cellBounds.x, cellBounds.y + 1, cellBounds.width - 1, cellBounds.height - 1);", "+\t\t}", "+\t\tgc.setBackground (oldBackground);", "+\t}", "+", "+\t/* draw the selection bar if the receiver is selected */", "+\tif (isSelected () && columnIndex == 0) {", "+\t\tColor oldBackground = gc.getBackground ();", "+\t\tgc.setBackground (SelectionBackgroundColor);", "+\t\tint startX = getFocusX () + 1;", "+\t\tgc.fillRectangle (", "+\t\t\tstartX,", "+\t\t\tcellBounds.y + padding,", "+\t\t\tMath.max (0, cellRightX - startX - 2),", "+\t\t\tMath.max (0, cellBounds.height - (padding * 2) + 1));", "+\t\tgc.setBackground (oldBackground);", "+\t}", "+\t\t", "+\tif (!paintCellContent) return;", "+", "+\t/* Draw column 0 decorations */", "+\tif (columnIndex == 0) {", "+\t\t/* Draw hierarchy connector lines */", "+\t\tRectangle expanderBounds = getExpanderBounds ();", "+\t\tColor oldForeground = gc.getForeground ();", "+\t\tgc.setForeground (LinesColor);", "+", "+\t\t/* Draw vertical line above expander */", "+\t\tint lineX = expanderBounds.x + expanderBounds.width / 2;", "+\t\tint itemCount = getItemCount ();", "+\t\tint y2 = expanderBounds.y;", "+\t\tif (itemCount == 0) {", "+\t\t\ty2 += expanderBounds.height / 2;", "+\t\t}", "+\t\t", "+\t\t/* Do not draw this line iff this is the very first item in the tree */ ", "+\t\tif (!isRoot () || getIndex () != 0) {", "+\t\t\tgc.drawLine (lineX, y, lineX, y2);", "+\t\t}", "+", "+\t\t/* Draw vertical line below expander if the receiver has lower siblings */", "+\t\tif (!isLastChild ()) {", "+\t\t\tif (itemCount != 0) y2 += expanderBounds.height;", "+\t\t\tgc.drawLine (lineX, y2, lineX, y + itemHeight);", "+\t\t}", "+", "+\t\t/* Draw horizontal line to right of expander */", "+\t\tPoint[] endpoints = getHconnectorEndpoints ();", "+\t\tgc.drawLine (endpoints[0].x, endpoints[0].y, endpoints[1].x - Tree.MARGIN_IMAGE, endpoints[1].y);", "+\t\t", "+\t\t/* ", "+\t\t * Draw hierarchy lines that are needed by other items that are shown below", "+\t\t * this item but whose parents are shown above.", "+\t\t */", "+\t\tTreeItem item = getParentItem ();", "+\t\twhile (item != null) {", "+\t\t\tif (!item.isLastChild ()) {", "+\t\t\t\tRectangle itemExpanderBounds = item.getExpanderBounds ();", "+\t\t\t\tlineX = itemExpanderBounds.x + itemExpanderBounds.width / 2;", "+\t\t\t\tgc.drawLine (lineX, y, lineX, y + itemHeight);", "+\t\t\t}", "+\t\t\titem = item.getParentItem ();", "+\t\t}", "+\t\tgc.setForeground (oldForeground);", "+\t\t", "+\t\t/* Draw expand/collapse image if receiver has children */", "+\t\tif (items.length > 0) {", "+\t\t\tImage image = expanded ? ExpandedImage : CollapsedImage;", "+\t\t\tgc.drawImage (image, expanderBounds.x, expanderBounds.y);", "+\t\t}", "+\t\t", "+\t\t/* Draw checkbox if parent Tree has style SWT.CHECK */", "+\t\tif ((parent.style & SWT.CHECK) != 0) {", "+\t\t\tImage baseImage = grayed ? GrayUncheckedImage : UncheckedImage;", "+\t\t\tRectangle checkboxBounds = getCheckboxBounds ();", "+\t\t\tgc.drawImage (baseImage, checkboxBounds.x, checkboxBounds.y);", "+", "+\t\t\tif (checked) {", "+\t\t\t\tRectangle checkmarkBounds = CheckmarkImage.getBounds ();", "+\t\t\t\tint xInset = (checkboxBounds.width - checkmarkBounds.width) / 2;", "+\t\t\t\tint yInset = (checkboxBounds.height - checkmarkBounds.height) / 2;", "+\t\t\t\tgc.drawImage (CheckmarkImage, checkboxBounds.x + xInset, checkboxBounds.y + yInset);", "+\t\t\t}", "+\t\t}", "+\t}", "+", "+\tImage image = internalGetImage (columnIndex);", "+\tString text = internalGetText (columnIndex);", "+\tRectangle imageArea = getImageBounds (columnIndex);", "+\tint startX = imageArea.x;", "+\t", "+\t/* while painting the cell's content restrict the clipping region */", "+\tgc.setClipping (", "+\t\tstartX,", "+\t\tcellBounds.y + padding,", "+\t\tMath.max (0, cellRightX - startX - padding),", "+\t\tMath.max (0, cellBounds.height - (2 * padding)));", "+", "+\t/* draw the image */", "+\tif (image != null) {", "+\t\tRectangle imageBounds = image.getBounds ();", "+\t\tgc.drawImage (", "+\t\t\timage,", "+\t\t\t0, 0,\t\t\t\t\t\t\t\t\t/* source x, y */", "+\t\t\timageBounds.width, imageBounds.height,\t/* source width, height */", "+\t\t\timageArea.x, imageArea.y,\t\t\t\t/* dest x, y */", "+\t\t\timageArea.width, imageArea.height);\t\t/* dest width, height */", "+\t/* draw the text */", "+\tif (text.length () > 0) {", "+\t\tboolean fontChanged = false, foregroundChanged = false;", "+\t\tint fontHeight;", "+\t\tFont oldFont = gc.getFont ();", "+\t\tFont font = getFont (columnIndex);", "+\t\tif (!font.equals (oldFont)) {", "+\t\t\tgc.setFont (font);", "+\t\t\tfontHeight = this.fontHeight;", "+\t\t\tfontChanged = true;", "+\t\t} else {", "+\t\t\tfontHeight = parent.fontHeight;", "+\t\t}", "+\t\tColor oldForeground = gc.getForeground ();", "+\t\tif (isSelected () && columnIndex == 0) {", "+\t\t\toldForeground = gc.getForeground ();", "+\t\t\tgc.setForeground (SelectionForegroundColor);", "+\t\t\tforegroundChanged = true;", "+\t\t} else {", "+\t\t\tColor foreground = getForeground (columnIndex);", "+\t\t\tif (!foreground.equals (oldForeground)) {", "+\t\t\t\tgc.setForeground (foreground);", "+\t\t\t\tforegroundChanged = true;", "+\t\t\t}", "+\t\t}", "+\t\tgc.drawString (text, getTextX (columnIndex), y + (itemHeight - fontHeight) / 2, true);", "+\t\tif (foregroundChanged) gc.setForeground (oldForeground);", "+\t\tif (fontChanged) gc.setFont (oldFont);", "+\t}", "+}"]}], "num": 18130}