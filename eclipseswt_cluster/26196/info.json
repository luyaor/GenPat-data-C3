{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "549b127660a96dc816c0003819eedd01", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36512c593cd1bd83b242daf0a0219973", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "f2afadf3ecbde81e97161d4a80435b171827f960", "commitAfterChange": "cf34d636662ca6587452948946037bfb3d522d9c", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " void createMask()", "signatureAfterChange": " void createMask()", "diff": ["+\tif (OS.USE_CAIRO_SURFACE) {", "+\t\tint width = this.width;", "+\t\tint height = this.height;", "+\t\tint stride = Cairo.cairo_format_stride_for_width(Cairo.CAIRO_FORMAT_ARGB32, width);", "+\t\tbyte[] srcData = new byte[stride * height];", "+\t\tint oa, or, og, ob, tr, tg, tb;", "+\t\tif (OS.BIG_ENDIAN) {", "+\t\t\toa = 0; or = 1; og = 2; ob = 3;", "+\t\t\ttr = (transparentPixel >> 24) & 0xFF;", "+\t\t\ttg = (transparentPixel >> 16) & 0xFF;", "+\t\t\ttb = (transparentPixel >> 8) & 0xFF;", "+\t\t} else {", "+\t\t\toa = 3; or = 2; og = 1; ob = 0;", "+\t\t\ttr = (transparentPixel >> 16) & 0xFF;", "+\t\t\ttg = (transparentPixel >> 8) & 0xFF;", "+\t\t\ttb = (transparentPixel >> 0) & 0xFF;", "+\t\t}", "+\t\tOS.memmove(srcData, this.surfaceData, srcData.length);", "+\t\tint offset = 0;", "+\t\tfor (int y = 0; y < height; y++) {", "+\t\t\tfor (int x = 0; x < width; x++, offset += 4) {", "+\t\t\t\tint a = srcData[offset + oa] & 0xFF;", "+\t\t\t\tint r = srcData[offset + or] & 0xFF;", "+\t\t\t\tint g = srcData[offset + og] & 0xFF;", "+\t\t\t\tint b = srcData[offset + ob] & 0xFF;", "+\t\t\t\tif (r == tr && g == tg && b == tb) {", "+\t\t\t\t\ta = r = g = b = 0;", "+\t\t\t\t} else {", "+\t\t\t\t\ta = 0xff;", "+\t\t\t\t}", "+\t\t\t\tsrcData[offset + oa] = (byte)a;", "+\t\t\t\tsrcData[offset + or] = (byte)r;", "+\t\t\t\tsrcData[offset + og] = (byte)g;", "+\t\t\t\tsrcData[offset + ob] = (byte)b;", "+\t\t\t}", "+\t\t}", "+\t\tOS.memmove(this.surfaceData, srcData, srcData.length);", "+\t\treturn;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34984e323b9f4fbca2a94f97f66d792d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "d089b2cf79ce87d2a82f677ea1a4ce5a5ba9d4a4", "commitAfterChange": "78b034106c080360cc188a981bb53f8356762fbe", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-", "-\tint[] w = new int[1], h = new int[1];", "- \tOS.gdk_drawable_get_size(pixmap, w, h);", "- \tint width = w[0], height = h[0]; \t", "- \tint /*long*/ pixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, width, height);", "-\tif (pixbuf == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\tint /*long*/ colormap = OS.gdk_colormap_get_system();", "-\tOS.gdk_pixbuf_get_from_drawable(pixbuf, pixmap, colormap, 0, 0, 0, 0, width, height);", "-\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "-\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "-\tbyte[] srcData = new byte[stride * height];", "-\tOS.memmove(srcData, pixels, srcData.length);", "-\tOS.g_object_unref(pixbuf);", "-", "-\tPaletteData palette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "-\tImageData data = new ImageData(width, height, 24, palette, 4, srcData);", "-\tdata.bytesPerLine = stride;", "-", "-\tif (transparentPixel == -1 && type == SWT.ICON && mask != 0) {", "-\t\t/* Get the icon mask data */", "-\t\tint /*long*/ gdkImagePtr = OS.gdk_drawable_get_image(mask, 0, 0, width, height);", "-\t\tif (gdkImagePtr == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\tGdkImage gdkImage = new GdkImage();", "-\t\tOS.memmove(gdkImage, gdkImagePtr);", "-\t\tbyte[] maskData = new byte[gdkImage.bpl * gdkImage.height];", "-\t\tOS.memmove(maskData, gdkImage.mem, maskData.length);", "-\t\tOS.g_object_unref(gdkImagePtr);", "-\t\tint maskPad;", "-\t\tfor (maskPad = 1; maskPad < 128; maskPad++) {", "-\t\t\tint bpl = (((width + 7) / 8) + (maskPad - 1)) / maskPad * maskPad;", "-\t\t\tif (gdkImage.bpl == bpl) break;", "+\tImageData data;", "+\tif (OS.USE_CAIRO_SURFACE) {", "+\t\tint width = this.width;", "+\t\tint height = this.height;", "+\t\tint stride = Cairo.cairo_format_stride_for_width(Cairo.CAIRO_FORMAT_ARGB32, width);", "+\t\tbyte[] srcData = new byte[stride * height];", "+\t\tint /*long*/ ptr = OS.malloc(4);", "+\t\tOS.memmove(ptr, new int[]{1}, 4);", "+\t\tOS.memmove(srcData, ptr, 1);", "+\t\tOS.free(ptr);", "+\t\tint oa, or, og, ob;", "+\t\tboolean bigendian = srcData[0] == 0;", "+\t\tif (bigendian) {", "+\t\t\toa = 0; or = 1; og = 2; ob = 3;", "+\t\t} else {", "+\t\t\toa = 3; or = 2; og = 1; ob = 0;", "-\t\t/* Make mask scanline pad equals to 2 */", "-\t\tdata.maskPad = 2;", "-\t\tmaskData = ImageData.convertPad(maskData, width, height, 1, maskPad, data.maskPad);", "-\t\t/* Bit swap the mask data if necessary */", "-\t\tif (gdkImage.byte_order == OS.GDK_LSB_FIRST) {", "-\t\t\tfor (int i = 0; i < maskData.length; i++) {", "-\t\t\t\tbyte b = maskData[i];", "-\t\t\t\tmaskData[i] = (byte)(((b & 0x01) << 7) | ((b & 0x02) << 5) | ", "-\t\t\t\t\t((b & 0x04) << 3) |\t((b & 0x08) << 1) | ((b & 0x10) >> 1) | ", "-\t\t\t\t\t((b & 0x20) >> 3) |\t((b & 0x40) >> 5) | ((b & 0x80) >> 7));", "+\t\tOS.memmove(srcData, this.surfaceData, srcData.length);", "+\t\tPaletteData palette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "+\t\tdata = new ImageData(width, height, 32, palette, 4, srcData);", "+\t\tint offset = 0;", "+\t\tfor (int y = 0; y < height; y++) {", "+\t\t\tfor (int x = 0; x < width; x++, offset += 4) {", "+\t\t\t\tint a = srcData[offset + oa] & 0xFF;", "+\t\t\t\tint r = srcData[offset + or] & 0xFF;", "+\t\t\t\tint g = srcData[offset + og] & 0xFF;", "+\t\t\t\tint b = srcData[offset + ob] & 0xFF;", "+\t\t\t\tsrcData[offset + 3] = (byte)a;", "+\t\t\t\tif (a != 0) {", "+\t\t\t\t\tsrcData[offset + 2] = (byte)(((r) / (float)a) * 0xFF);", "+\t\t\t\t\tsrcData[offset + 1] = (byte)(((g) / (float)a) * 0xFF);", "+\t\t\t\t\tsrcData[offset + 0] = (byte)(((b) / (float)a) * 0xFF);", "+\t\t\t\t}", "-\t\tdata.maskData = maskData;", "+\t} else {", "+\t\tint[] w = new int[1], h = new int[1];", "+\t \tOS.gdk_drawable_get_size(pixmap, w, h);", "+\t \tint width = w[0], height = h[0]; \t", "+\t \tint /*long*/ pixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, width, height);", "+\t\tif (pixbuf == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\tint /*long*/ colormap = OS.gdk_colormap_get_system();", "+\t\tOS.gdk_pixbuf_get_from_drawable(pixbuf, pixmap, colormap, 0, 0, 0, 0, width, height);", "+\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "+\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\tbyte[] srcData = new byte[stride * height];", "+\t\tOS.memmove(srcData, pixels, srcData.length);", "+\t\tOS.g_object_unref(pixbuf);", "+\t", "+\t\tPaletteData palette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "+\t\tdata = new ImageData(width, height, 24, palette, 4, srcData);", "+\t\tdata.bytesPerLine = stride;", "+\t", "+\t\tif (transparentPixel == -1 && type == SWT.ICON && mask != 0) {", "+\t\t\t/* Get the icon mask data */", "+\t\t\tint /*long*/ gdkImagePtr = OS.gdk_drawable_get_image(mask, 0, 0, width, height);", "+\t\t\tif (gdkImagePtr == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\t\tGdkImage gdkImage = new GdkImage();", "+\t\t\tOS.memmove(gdkImage, gdkImagePtr);", "+\t\t\tbyte[] maskData = new byte[gdkImage.bpl * gdkImage.height];", "+\t\t\tOS.memmove(maskData, gdkImage.mem, maskData.length);", "+\t\t\tOS.g_object_unref(gdkImagePtr);", "+\t\t\tint maskPad;", "+\t\t\tfor (maskPad = 1; maskPad < 128; maskPad++) {", "+\t\t\t\tint bpl = (((width + 7) / 8) + (maskPad - 1)) / maskPad * maskPad;", "+\t\t\t\tif (gdkImage.bpl == bpl) break;", "+\t\t\t}", "+\t\t\t/* Make mask scanline pad equals to 2 */", "+\t\t\tdata.maskPad = 2;", "+\t\t\tmaskData = ImageData.convertPad(maskData, width, height, 1, maskPad, data.maskPad);", "+\t\t\t/* Bit swap the mask data if necessary */", "+\t\t\tif (gdkImage.byte_order == OS.GDK_LSB_FIRST) {", "+\t\t\t\tfor (int i = 0; i < maskData.length; i++) {", "+\t\t\t\t\tbyte b = maskData[i];", "+\t\t\t\t\tmaskData[i] = (byte)(((b & 0x01) << 7) | ((b & 0x02) << 5) | ", "+\t\t\t\t\t\t((b & 0x04) << 3) |\t((b & 0x08) << 1) | ((b & 0x10) >> 1) | ", "+\t\t\t\t\t\t((b & 0x20) >> 3) |\t((b & 0x40) >> 5) | ((b & 0x80) >> 7));", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tdata.maskData = maskData;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9b59b86b75853b525b0453b88d21758b", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "d089b2cf79ce87d2a82f677ea1a4ce5a5ba9d4a4", "commitAfterChange": "78b034106c080360cc188a981bb53f8356762fbe", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "  static int createPixbuf(Image image)", "signatureAfterChange": "  static int createPixbuf(Image image)", "diff": ["-\tint [] w = new int [1], h = new int [1];", "- \tOS.gdk_drawable_get_size (image.pixmap, w, h);", "-\tint /*long*/ colormap = OS.gdk_colormap_get_system ();", "-\tboolean hasMask = image.mask != 0 && OS.gdk_drawable_get_depth (image.mask) == 1;", "-\tif (hasMask) {", "-\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, true, 8, w [0], h [0]);", "+\tif (OS.USE_CAIRO_SURFACE) {", "+\t\tRectangle bounds = image.getBounds();", "+\t\tint w = bounds.width, h = bounds.height;", "+\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, true, 8, w, h);", "-\t\tOS.gdk_pixbuf_get_from_drawable (pixbuf, image.pixmap, colormap, 0, 0, 0, 0, w [0], h [0]);", "-\t\tint /*long*/ maskPixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, w [0], h [0]);", "-\t\tif (maskPixbuf == 0) SWT.error (SWT.ERROR_NO_HANDLES);", "-\t\tOS.gdk_pixbuf_get_from_drawable(maskPixbuf, image.mask, 0, 0, 0, 0, 0, w [0], h [0]);", "-\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "-\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\tint stride = OS.gdk_pixbuf_get_rowstride (pixbuf);", "+\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels (pixbuf);", "-\t\tint maskStride = OS.gdk_pixbuf_get_rowstride(maskPixbuf);", "-\t\tint /*long*/ maskPixels = OS.gdk_pixbuf_get_pixels(maskPixbuf);", "-\t\tbyte[] maskLine = new byte[maskStride];", "-\t\tfor (int y=0; y<h[0]; y++) {", "-\t\t\tint /*long*/ offset = pixels + (y * stride);", "-\t\t\tOS.memmove(line, offset, stride);", "-\t\t\tint /*long*/ maskOffset = maskPixels + (y * maskStride);", "-\t\t\tOS.memmove(maskLine, maskOffset, maskStride);", "-\t\t\tfor (int x=0; x<w[0]; x++) {", "-\t\t\t\tif (maskLine[x * 3] == 0) {", "-\t\t\t\t\tline[x * 4 + 3] = 0;", "+\t\tint /*long*/ ptr = OS.malloc(4);", "+\t\tOS.memmove(ptr, new int[]{1}, 4);", "+\t\tOS.memmove(line, ptr, 1);", "+\t\tOS.free(ptr);", "+\t\tint oa, or, og, ob;", "+\t\tboolean bigendian = line[0] == 0;", "+\t\tif (bigendian) {", "+\t\t\toa = 0; or = 1; og = 2; ob = 3;", "+\t\t} else {", "+\t\t\toa = 3; or = 2; og = 1; ob = 0;", "+\t\t}", "+\t\tint /*long*/ surfaceData = image.surfaceData;", "+\t\tfor (int y = 0; y < h; y++) {", "+\t\t\tOS.memmove (line, surfaceData + (y * stride), stride);", "+\t\t\tfor (int x = 0, offset = 0; x < w; x++, offset += 4) {", "+\t\t\t\tint a = line[offset + oa] & 0xFF;", "+\t\t\t\tint r = line[offset + or] & 0xFF;", "+\t\t\t\tint g = line[offset + og] & 0xFF;", "+\t\t\t\tint b = line[offset + ob] & 0xFF;", "+\t\t\t\tline[offset + 3] = (byte)a;", "+\t\t\t\tif (a != 0) {", "+\t\t\t\t\tline[offset + 0] = (byte)(((r) / (float)a) * 0xFF);", "+\t\t\t\t\tline[offset + 1] = (byte)(((g) / (float)a) * 0xFF);", "+\t\t\t\t\tline[offset + 2] = (byte)(((b) / (float)a) * 0xFF);", "-\t\t\tOS.memmove(offset, line, stride);", "+\t\t\tOS.memmove (pixels + (y * stride), line, stride);", "-\t\tOS.g_object_unref(maskPixbuf);", "-\t\tImageData data = image.getImageData ();", "-\t\tboolean hasAlpha = data.getTransparencyType () == SWT.TRANSPARENCY_ALPHA;", "-\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, hasAlpha, 8, w [0], h [0]);", "-\t\tif (pixbuf == 0) SWT.error (SWT.ERROR_NO_HANDLES);", "-\t\tOS.gdk_pixbuf_get_from_drawable (pixbuf, image.pixmap, colormap, 0, 0, 0, 0, w [0], h [0]);", "-\t\tif (hasAlpha) {", "-\t\t\tbyte [] alpha = data.alphaData;", "-\t\t\tint stride = OS.gdk_pixbuf_get_rowstride (pixbuf);", "-\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels (pixbuf);", "-\t\t\tbyte [] line = new byte [stride];", "-\t\t\tfor (int y = 0; y < h [0]; y++) {", "+\t\tint [] w = new int [1], h = new int [1];", "+\t \tOS.gdk_drawable_get_size (image.pixmap, w, h);", "+\t\tint /*long*/ colormap = OS.gdk_colormap_get_system ();", "+\t\tboolean hasMask = image.mask != 0 && OS.gdk_drawable_get_depth (image.mask) == 1;", "+\t\tif (hasMask) {", "+\t\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, true, 8, w [0], h [0]);", "+\t\t\tif (pixbuf == 0) SWT.error (SWT.ERROR_NO_HANDLES);", "+\t\t\tOS.gdk_pixbuf_get_from_drawable (pixbuf, image.pixmap, colormap, 0, 0, 0, 0, w [0], h [0]);", "+\t\t\tint /*long*/ maskPixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, w [0], h [0]);", "+\t\t\tif (maskPixbuf == 0) SWT.error (SWT.ERROR_NO_HANDLES);", "+\t\t\tOS.gdk_pixbuf_get_from_drawable(maskPixbuf, image.mask, 0, 0, 0, 0, 0, w [0], h [0]);", "+\t\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "+\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\t\tbyte[] line = new byte[stride];", "+\t\t\tint maskStride = OS.gdk_pixbuf_get_rowstride(maskPixbuf);", "+\t\t\tint /*long*/ maskPixels = OS.gdk_pixbuf_get_pixels(maskPixbuf);", "+\t\t\tbyte[] maskLine = new byte[maskStride];", "+\t\t\tfor (int y=0; y<h[0]; y++) {", "-\t\t\t\tOS.memmove (line, offset, stride);", "-\t\t\t\tfor (int x = 0; x < w [0]; x++) {", "-\t\t\t\t\tline [x*4+3] = alpha [y*w [0]+x];", "+\t\t\t\tOS.memmove(line, offset, stride);", "+\t\t\t\tint /*long*/ maskOffset = maskPixels + (y * maskStride);", "+\t\t\t\tOS.memmove(maskLine, maskOffset, maskStride);", "+\t\t\t\tfor (int x=0; x<w[0]; x++) {", "+\t\t\t\t\tif (maskLine[x * 3] == 0) {", "+\t\t\t\t\t\tline[x * 4 + 3] = 0;", "+\t\t\t\t\t}", "-\t\t\t\tOS.memmove (offset, line, stride);", "+\t\t\t\tOS.memmove(offset, line, stride);", "+\t\t\t}", "+\t\t\tOS.g_object_unref(maskPixbuf);", "+\t\t} else {", "+\t\t\tImageData data = image.getImageData ();", "+\t\t\tboolean hasAlpha = data.getTransparencyType () == SWT.TRANSPARENCY_ALPHA;", "+\t\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, hasAlpha, 8, w [0], h [0]);", "+\t\t\tif (pixbuf == 0) SWT.error (SWT.ERROR_NO_HANDLES);", "+\t\t\tOS.gdk_pixbuf_get_from_drawable (pixbuf, image.pixmap, colormap, 0, 0, 0, 0, w [0], h [0]);", "+\t\t\tif (hasAlpha) {", "+\t\t\t\tbyte [] alpha = data.alphaData;", "+\t\t\t\tint stride = OS.gdk_pixbuf_get_rowstride (pixbuf);", "+\t\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels (pixbuf);", "+\t\t\t\tbyte [] line = new byte [stride];", "+\t\t\t\tfor (int y = 0; y < h [0]; y++) {", "+\t\t\t\t\tint /*long*/ offset = pixels + (y * stride);", "+\t\t\t\t\tOS.memmove (line, offset, stride);", "+\t\t\t\t\tfor (int x = 0; x < w [0]; x++) {", "+\t\t\t\t\t\tline [x*4+3] = alpha [y*w [0]+x];", "+\t\t\t\t\t}", "+\t\t\t\t\tOS.memmove (offset, line, stride);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b24daf61e9b6c98c16192b52d83bc758", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "d089b2cf79ce87d2a82f677ea1a4ce5a5ba9d4a4", "commitAfterChange": "78b034106c080360cc188a981bb53f8356762fbe", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  void initNative(String filename)", "signatureAfterChange": "  void initNative(String filename)", "diff": ["-\t\t\tboolean hasAlpha = OS.gdk_pixbuf_get_has_alpha(pixbuf);", "-\t\t\tif (hasAlpha) {", "-\t\t\t\t/*", "-\t\t\t\t* Bug in GTK. Depending on the image (seems to affect images that have", "-\t\t\t\t* some degree of transparency all over the image), gdk_pixbuff_render_pixmap_and_mask()", "-\t\t\t\t* will return a corrupt pixmap. To avoid this, read in and store the alpha channel data", "-\t\t\t\t* for the image and then set it to 0xFF to prevent any possible corruption from ", "-\t\t\t\t* gdk_pixbuff_render_pixmap_and_mask(). ", "-\t\t\t\t*/", "-\t\t\t\tint width = OS.gdk_pixbuf_get_width(pixbuf);", "-\t\t\t\tint height = OS.gdk_pixbuf_get_height(pixbuf);", "+\t\t\tif (OS.USE_CAIRO_SURFACE) {", "+\t\t\t\tint width = this.width = OS.gdk_pixbuf_get_width(pixbuf);", "+\t\t\t\tint height = this.height = OS.gdk_pixbuf_get_height(pixbuf);", "-\t\t\t\tbyte[] line = new byte[stride];", "-\t\t\t\talphaData = new byte[width * height];", "+\t\t\t\tint cairoStride = Cairo.cairo_format_stride_for_width(Cairo.CAIRO_FORMAT_ARGB32, width);", "+\t\t\t\tint /*long*/ data = surfaceData = OS.g_malloc(cairoStride * height);", "+\t\t\t\tif (surfaceData == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\t\t\tsurface = Cairo.cairo_image_surface_create_for_data(surfaceData, Cairo.CAIRO_FORMAT_ARGB32, width, height, cairoStride);", "+\t\t\t\tif (surface == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\t\t\tbyte[] line = new byte[Math.max(cairoStride, stride)];", "+\t\t\t\tint /*long*/ ptr = OS.malloc(4);", "+\t\t\t\tOS.memmove(ptr, new int[]{1}, 4);", "+\t\t\t\tOS.memmove(line, ptr, 1);", "+\t\t\t\tOS.free(ptr);", "+\t\t\t\tboolean bigendian = line[0] == 0;", "+\t\t\t\tint oa = 0, or = 0, og = 0, ob = 0;", "+\t\t\t\tif (bigendian) {", "+\t\t\t\t\toa = 0; or = 1; og = 2; ob = 3;", "+\t\t\t\t} else {", "+\t\t\t\t\toa = 3; or = 2; og = 1; ob = 0;", "+\t\t\t\t}", "-\t\t\t\t\tfor (int x = 0; x < width; x++) {", "-\t\t\t\t\t\talphaData[y*width+x] = line[x*4 + 3];", "-\t\t\t\t\t\tline[x*4 + 3] = (byte) 0xFF;", "+\t\t\t\t\tfor (int x = 0, offset = 0; x < width; x++, offset += 4) {", "+\t\t\t\t\t\tint a = line[offset + 3] & 0xFF;", "+\t\t\t\t\t\tint r = ((line[offset + 0] & 0xFF) * a) + 128;", "+\t\t\t\t\t\tr = (r + (r >> 8)) >> 8;", "+\t\t\t\t\t\tint g = ((line[offset + 1] & 0xFF) * a) + 128;", "+\t\t\t\t\t\tg = (g + (g >> 8)) >> 8;", "+\t\t\t\t\t\tint b = ((line[offset + 2] & 0xFF) * a) + 128;", "+\t\t\t\t\t\tb = (b + (b >> 8)) >> 8;", "+\t\t\t\t\t\tline[offset + oa] = (byte)a;", "+\t\t\t\t\t\tline[offset + or] = (byte)r;", "+\t\t\t\t\t\tline[offset + og] = (byte)g;", "+\t\t\t\t\t\tline[offset + ob] = (byte)b;", "-\t\t\t\t\tOS.memmove(pixels + (y * stride), line, stride);", "+\t\t\t\t\tOS.memmove(data + (y * cairoStride), line, cairoStride);", "-\t\t\t\tcreateAlphaMask(width, height);", "+\t\t\t\tOS.g_object_unref (pixbuf);", "+\t\t\t} else {", "+\t\t\t\tboolean hasAlpha = OS.gdk_pixbuf_get_has_alpha(pixbuf);", "+\t\t\t\tif (hasAlpha) {", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Bug in GTK. Depending on the image (seems to affect images that have", "+\t\t\t\t\t* some degree of transparency all over the image), gdk_pixbuff_render_pixmap_and_mask()", "+\t\t\t\t\t* will return a corrupt pixmap. To avoid this, read in and store the alpha channel data", "+\t\t\t\t\t* for the image and then set it to 0xFF to prevent any possible corruption from ", "+\t\t\t\t\t* gdk_pixbuff_render_pixmap_and_mask(). ", "+\t\t\t\t\t*/", "+\t\t\t\t\tint width = OS.gdk_pixbuf_get_width(pixbuf);", "+\t\t\t\t\tint height = OS.gdk_pixbuf_get_height(pixbuf);", "+\t\t\t\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "+\t\t\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\t\t\t\tbyte[] line = new byte[stride];", "+\t\t\t\t\talphaData = new byte[width * height];", "+\t\t\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\t\t\tOS.memmove(line, pixels + (y * stride), stride);", "+\t\t\t\t\t\tfor (int x = 0; x < width; x++) {", "+\t\t\t\t\t\t\talphaData[y*width+x] = line[x*4 + 3];", "+\t\t\t\t\t\t\tline[x*4 + 3] = (byte) 0xFF;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tOS.memmove(pixels + (y * stride), line, stride);", "+\t\t\t\t\t}", "+\t\t\t\t\tcreateAlphaMask(width, height);", "+\t\t\t\t}", "+\t\t\t\tint /*long*/ [] pixmap_return = new int /*long*/ [1];", "+\t\t\t\tOS.gdk_pixbuf_render_pixmap_and_mask(pixbuf, pixmap_return, null, 0);", "+\t\t\t\tOS.g_object_unref (pixbuf);", "+\t\t\t\tthis.type = SWT.BITMAP;", "+\t\t\t\tthis.pixmap = pixmap_return[0];", "+\t\t\t\tif (pixmap == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\t\tint /*long*/ [] pixmap_return = new int /*long*/ [1];", "-\t\t\tOS.gdk_pixbuf_render_pixmap_and_mask(pixbuf, pixmap_return, null, 0);", "-\t\t\tthis.type = SWT.BITMAP;", "-\t\t\tthis.pixmap = pixmap_return[0];", "-\t\t\tif (pixmap == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\t\tOS.g_object_unref (pixbuf);"]}], "num": 26196}