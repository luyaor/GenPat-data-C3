{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "31669753908de3e5928c023cf9e4cb67", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "99647a7edc9a02205eb2736f04ea33aa", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "ed6471c0ec0d0ee0c1436d2bdeadc8ba513ab4fd", "commitAfterChange": "034d8fba7f4ca7576ddaeee539a2fb56ee664327", "methodNumberBeforeChange": 86, "methodNumberAfterChange": 73, "signatureBeforeChange": " void paint(Event event)", "signatureAfterChange": " void onPaint (Event event)", "diff": ["+}", "+void onPaint (Event event) {", "+\tGC gc = event.gc;", "+\tRectangle clipping = gc.getClipping ();", "+\tint numColumns = columns.length;", "+\tint startColumn = -1, endColumn = -1;", "+\tif (numColumns > 0) {", "+\t\tstartColumn = computeColumnIntersect (clipping.x, 0);", "+\t\tif (startColumn != -1) {\t/* the clip x is within a column's bounds */", "+\t\t\tendColumn = computeColumnIntersect (clipping.x + clipping.width, startColumn);", "+\t\t\tif (endColumn == -1) endColumn = numColumns - 1;", "+\t\t}", "+\t} else {", "+\t\tstartColumn = endColumn = 0;", "+\t}", "+\t/* repaint grid lines */", "+\tif (linesVisible) {", "+\t\tColor oldForeground = gc.getForeground ();", "+\t\tgc.setForeground (display.getSystemColor (SWT.COLOR_WIDGET_LIGHT_SHADOW));", "+\t\tif (numColumns > 0 && startColumn != -1) {", "+\t\t\t/* vertical column lines */", "+\t\t\tfor (int i = startColumn; i <= endColumn; i++) {", "+\t\t\t\tint x = columns [i].getX () + columns [i].width - 1;", "+\t\t\t\tgc.drawLine (x, clipping.y, x, clipping.y + clipping.height);", "+\t\t\t}", "+\t\t}", "+\t\t/* horizontal item lines */", "+\t\tint bottomY = clipping.y + clipping.height;", "+\t\tint rightX = clipping.x + clipping.width;", "+\t\tint headerHeight = getHeaderHeight ();", "+\t\tint y = (clipping.y - headerHeight) / itemHeight * itemHeight + headerHeight;", "+\t\tif (y == headerHeight) y += itemHeight;\t\t/* do not paint line at very top */", "+\t\twhile (y <= bottomY) {", "+\t\t\tgc.drawLine (clipping.x, y, rightX, y);", "+\t\t\ty += itemHeight;", "+\t\t}", "+\t\tgc.setForeground (oldForeground);", "+\t/* Determine the TableItems to be painted */", "+\tint startIndex = (clipping.y - getHeaderHeight ()) / itemHeight + topIndex;", "+\tif (items.length < startIndex) return;\t\t/* no items to paint */", "+\tint endIndex = startIndex + Compatibility.ceil (clipping.height, itemHeight);", "+\tif (endIndex < 0) return;\t\t/* no items to paint */", "+\tstartIndex = Math.max (0, startIndex);", "+\tendIndex = Math.min (endIndex, items.length - 1);", "+\tint current = 0;", "+\tfor (int i = startIndex; i <= endIndex; i++) {", "+\t\tTableItem item = items [i];", "+\t\tif (startColumn == -1) {", "+\t\t\t/* indicates that region to paint is to the right of the last column */", "+\t\t\titem.paint (gc, null, false);", "+\t\t} else {", "+\t\t\tif (numColumns == 0) {", "+\t\t\t\titem.paint (gc, null, true);", "+\t\t\t} else {", "+\t\t\t\tfor (int j = startColumn; j <= endColumn; j++) {", "+\t\t\t\t\titem.paint (gc, columns [j], true);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (isFocusControl ()) {", "+\t\t\tif (focusItem == item) {", "+\t\t\t\tRectangle focusBounds = item.getFocusBounds ();", "+\t\t\t\tgc.setClipping (focusBounds);", "+\t\t\t\tint[] oldLineDash = gc.getLineDash ();", "+\t\t\t\tif (item.isSelected ()) {", "+\t\t\t\t\tgc.setLineDash (new int[] {2, 2});", "+\t\t\t\t} else {", "+\t\t\t\t\tgc.setLineDash (new int[] {1, 1});", "+\t\t\t\t}", "+\t\t\t\tgc.drawFocus (focusBounds.x, focusBounds.y, focusBounds.width, focusBounds.height);", "+\t\t\t\tgc.setLineDash (oldLineDash);", "+\t\t\t}", "- */", "-void paint(Event event) {", "-\tint visibleRange[];", "-\tint headerHeight = getHeaderHeight();", "-\tVector paintColumns = getPaintColumns(event.getBounds());", "-\tTableItem focusItem = null;", "-\tif (paintColumns.size() > 0) {", "-\t\tevent.y -= headerHeight;", "-\t\tvisibleRange = getIndexRange(event.getBounds());", "-\t\tevent.y += headerHeight;", "-\t\t// When the top index is > 0 and the receiver is resized ", "-\t\t// higher so that the top index becomes 0 the invalidated ", "-\t\t// rectangle doesn't start below the header widget but at ", "-\t\t// y position 0. Subtraction of the header height (it is ", "-\t\t// not above the receiver but on top) causes event.y and ", "-\t\t// subsequently visibleRange[0] to be negative.", "-\t\t// Hack to prevent visibleRange[0] from becoming negative.", "-\t\t// Need to find out why the invalidated area starts at 0", "-\t\t// in the first place.", "-\t\tif (visibleRange[0] < 0) {", "-\t\t\tvisibleRange[0] = 0;", "-\t\t// ", "-\t\tvisibleRange[1] = Math.min(visibleRange[1], getItemCount()-1-getTopIndex());", "-\t\tfocusItem = paintItems(event, visibleRange[0], visibleRange[1], paintColumns);", "-\t}", "-\tif (getLinesVisible() == true) {", "-\t\tdrawGridLines(event, paintColumns.elements());", "-\t}", "-\tif (focusItem != null) {", "-\t\t// draw focus on top of drawing grid lines so that focus rectangle ", "-\t\t// is not obscured by grid. Fixes 1G5X20B", "-\t\tdrawSelectionFocus(focusItem, event.gc);\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b21a06263ef5090e6534e0428aa8fec6", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "b41f60e899b20029f1cfe5a40036031007ced518", "commitAfterChange": "44f007d08589286b5159b2d9ba31e92bef22239b", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 67, "signatureBeforeChange": " void doPaint (Event event)", "signatureAfterChange": " void onPaint (Event event)", "diff": ["-}", "-void doPaint (Event event) {", "-\tGC gc = event.gc;", "-\tRectangle clipping = gc.getClipping ();", "-\tint numColumns = columns.length;", "-\tint startColumn = -1, endColumn = -1;", "-\tif (numColumns > 0) {", "-\t\tstartColumn = computeColumnIntersect (clipping.x, 0);", "-\t\tif (startColumn != -1) {\t/* the clip x is within a column's bounds */", "-\t\t\tendColumn = computeColumnIntersect (clipping.x + clipping.width, startColumn);", "-\t\t\tif (endColumn == -1) endColumn = numColumns - 1;", "-\t\t}", "-\t} else {", "-\t\tstartColumn = endColumn = 0;", "-\t}", "-", "-\t/* repaint grid lines */", "-\tif (linesVisible) {", "-\t\tColor oldForeground = gc.getForeground ();", "-\t\tif (numColumns > 0 && startColumn != -1) {", "-\t\t\tgc.setForeground (gridLineColor);", "-\t\t\t/* vertical column lines */", "-\t\t\tfor (int i = startColumn; i <= endColumn; i++) {", "-\t\t\t\tint x = columns [i].getX () + columns [i].width - 1;", "-\t\t\t\tgc.drawLine (x, clipping.y, x, clipping.y + clipping.height);", "-\t\t\t}", "-\t\t}", "-\t\t/* horizontal item lines */", "-\t\tint bottomY = clipping.y + clipping.height;", "-\t\tint rightX = clipping.x + clipping.width;", "-\t\tint headerHeight = getHeaderHeight ();", "-\t\tint y = (clipping.y - headerHeight) / itemHeight * itemHeight + headerHeight;", "-\t\twhile (y <= bottomY) {", "-\t\t\tgc.drawLine (clipping.x, y, rightX, y);", "-\t\t\ty += itemHeight;", "-\t\t}", "-\t\tgc.setForeground (oldForeground);", "-\t}", "-\t", "-\t/* Determine the TreeItems to be painted */", "-\tint startIndex = (clipping.y - getHeaderHeight ()) / itemHeight + topIndex;", "-\tif (availableItems.length < startIndex) return;\t\t/* no items to paint */", "-\tint endIndex = startIndex + Compatibility.ceil (clipping.height, itemHeight);", "-\tif (endIndex < 0) return;\t\t/* no items to paint */", "-\tstartIndex = Math.max (0, startIndex);", "-\tendIndex = Math.min (endIndex, availableItems.length - 1);", "-\tint current = 0;", "-\tfor (int i = startIndex; i <= endIndex; i++) {", "-\t\tTreeItem item = availableItems [i];", "-\t\tif (startColumn == -1) {", "-\t\t\t/* indicates that region to paint is to the right of the last column */", "-\t\t\titem.paint (gc, null, false);", "-\t\t} else {", "-\t\t\tif (numColumns == 0) {", "-\t\t\t\titem.paint (gc, null, true);", "-\t\t\t} else {", "-\t\t\t\tfor (int j = startColumn; j <= endColumn; j++) {", "-\t\t\t\t\titem.paint (gc, columns [j], true);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (isFocusControl ()) {", "-\t\t\tif (focusItem == item) {", "-\t\t\t\tRectangle focusBounds = item.getFocusBounds ();", "-\t\t\t\tgc.setClipping (focusBounds);", "-\t\t\t\tint oldStyle = gc.getLineStyle ();", "-\t\t\t\tgc.setLineStyle (SWT.LINE_DOT);", "-\t\t\t\tgc.drawFocus (focusBounds.x, focusBounds.y, focusBounds.width, focusBounds.height);", "-\t\t\t\tgc.setLineStyle (oldStyle);", "-\t\t\t}", "-\t\t\tif (insertMarkItem == item) {", "-\t\t\t\tRectangle focusBounds = item.getFocusBounds ();", "-\t\t\t\tgc.setClipping (focusBounds);", "-\t\t\t\tif (insertMarkPrecedes) {", "-\t\t\t\t\tgc.drawLine (focusBounds.x, focusBounds.y, focusBounds.x + focusBounds.width, focusBounds.y);", "-\t\t\t\t} else {", "-\t\t\t\t\tint y = focusBounds.y + focusBounds.height - 1;", "-\t\t\t\t\tgc.drawLine (focusBounds.x, y, focusBounds.x + focusBounds.width, y);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "-}", "+}", "+void onPaint (Event event) {", "+\tGC gc = event.gc;", "+\tRectangle clipping = gc.getClipping ();", "+\tint numColumns = columns.length;", "+\tint startColumn = -1, endColumn = -1;", "+\tif (numColumns > 0) {", "+\t\tstartColumn = computeColumnIntersect (clipping.x, 0);", "+\t\tif (startColumn != -1) {\t/* the clip x is within a column's bounds */", "+\t\t\tendColumn = computeColumnIntersect (clipping.x + clipping.width, startColumn);", "+\t\t\tif (endColumn == -1) endColumn = numColumns - 1;", "+\t\t}", "+\t} else {", "+\t\tstartColumn = endColumn = 0;", "+\t}", "+", "+\t/* repaint grid lines */", "+\tif (linesVisible) {", "+\t\tColor oldForeground = gc.getForeground ();", "+\t\tif (numColumns > 0 && startColumn != -1) {", "+\t\t\tgc.setForeground (gridLineColor);", "+\t\t\t/* vertical column lines */", "+\t\t\tfor (int i = startColumn; i <= endColumn; i++) {", "+\t\t\t\tint x = columns [i].getX () + columns [i].width - 1;", "+\t\t\t\tgc.drawLine (x, clipping.y, x, clipping.y + clipping.height);", "+\t\t\t}", "+\t\t}", "+\t\t/* horizontal item lines */", "+\t\tint bottomY = clipping.y + clipping.height;", "+\t\tint rightX = clipping.x + clipping.width;", "+\t\tint headerHeight = getHeaderHeight ();", "+\t\tint y = (clipping.y - headerHeight) / itemHeight * itemHeight + headerHeight;", "+\t\twhile (y <= bottomY) {", "+\t\t\tgc.drawLine (clipping.x, y, rightX, y);", "+\t\t\ty += itemHeight;", "+\t\t}", "+\t\tgc.setForeground (oldForeground);", "+\t}", "+\t", "+\t/* Determine the TreeItems to be painted */", "+\tint startIndex = (clipping.y - getHeaderHeight ()) / itemHeight + topIndex;", "+\tif (availableItems.length < startIndex) return;\t\t/* no items to paint */", "+\tint endIndex = startIndex + Compatibility.ceil (clipping.height, itemHeight);", "+\tif (endIndex < 0) return;\t\t/* no items to paint */", "+\tstartIndex = Math.max (0, startIndex);", "+\tendIndex = Math.min (endIndex, availableItems.length - 1);", "+\tint current = 0;", "+\tfor (int i = startIndex; i <= endIndex; i++) {", "+\t\tTreeItem item = availableItems [i];", "+\t\tif (startColumn == -1) {", "+\t\t\t/* indicates that region to paint is to the right of the last column */", "+\t\t\titem.paint (gc, null, false);", "+\t\t} else {", "+\t\t\tif (numColumns == 0) {", "+\t\t\t\titem.paint (gc, null, true);", "+\t\t\t} else {", "+\t\t\t\tfor (int j = startColumn; j <= endColumn; j++) {", "+\t\t\t\t\titem.paint (gc, columns [j], true);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (isFocusControl ()) {", "+\t\t\tif (focusItem == item) {", "+\t\t\t\tRectangle focusBounds = item.getFocusBounds ();", "+\t\t\t\tgc.setClipping (focusBounds);", "+\t\t\t\tint oldStyle = gc.getLineStyle ();", "+\t\t\t\tgc.setLineStyle (SWT.LINE_DOT);", "+\t\t\t\tgc.drawFocus (focusBounds.x, focusBounds.y, focusBounds.width, focusBounds.height);", "+\t\t\t\tgc.setLineStyle (oldStyle);", "+\t\t\t}", "+\t\t\tif (insertMarkItem == item) {", "+\t\t\t\tRectangle focusBounds = item.getFocusBounds ();", "+\t\t\t\tgc.setClipping (focusBounds);", "+\t\t\t\tif (insertMarkPrecedes) {", "+\t\t\t\t\tgc.drawLine (focusBounds.x, focusBounds.y, focusBounds.x + focusBounds.width, focusBounds.y);", "+\t\t\t\t} else {", "+\t\t\t\t\tint y = focusBounds.y + focusBounds.height - 1;", "+\t\t\t\t\tgc.drawLine (focusBounds.x, y, focusBounds.x + focusBounds.width, y);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+}"]}], "num": 46745}