/******************************************************************************* * Copyright (c) 2008 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: *     IBM Corporation - initial API and implementation *******************************************************************************/package org.eclipse.swt.tools.internal;import java.io.PrintStream;import java.util.Arrays;import java.util.Comparator;import org.w3c.dom.Attr;import org.w3c.dom.Document;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;public class DOMWriter {	static String ENCONDING = "UTF8";	PrintStream out;	boolean canonical;	public DOMWriter(PrintStream out, boolean canonical) {		this.out = new PrintStream(out);		this.canonical = canonical;	}	String nodeName(Node node) {		// TODO use getLocalName()?		return node.getNodeName();	}		void print(String str) {		out.print(str);	}	void println() {		out.println();	}	public void print(Node node) {		if (node == null)			return;		int type = node.getNodeType();		switch (type) {			case Node.DOCUMENT_NODE: {				if (!canonical) {					String Encoding = ENCONDING;					print("<?xml version=\"1.0\" encoding=\"");					print(Encoding);					print("\"?>");					println();				}				print(((Document) node).getDocumentElement());				out.flush();				break;			}			case Node.ELEMENT_NODE: {				print("<");				print(nodeName(node));				Attr attrs[] = sort(node.getAttributes());				for (int i = 0; i < attrs.length; i++) {					Attr attr = attrs[i];					print(" ");					print(nodeName(attr));					print("=\"");					print(normalize(attr.getNodeValue()));					print("\"");				}				print(">");				NodeList children = node.getChildNodes();				if (children != null) {					int len = children.getLength();					for (int i = 0; i < len; i++) {						print(children.item(i));					}				}				break;			}			case Node.ENTITY_REFERENCE_NODE: {				if (canonical) {					NodeList children = node.getChildNodes();					if (children != null) {						int len = children.getLength();						for (int i = 0; i < len; i++) {							print(children.item(i));						}					}				} else {					print("&");					print(nodeName(node));					print(";");				}				break;			}			case Node.CDATA_SECTION_NODE: {				if (canonical) {					print(normalize(node.getNodeValue()));				} else {					print("<![CDATA[");					print(node.getNodeValue());					print("]]>");				}				break;			}			case Node.TEXT_NODE: {				print(normalize(node.getNodeValue()));				break;			}			case Node.PROCESSING_INSTRUCTION_NODE: {				print("<?");				print(nodeName(node));				String data = node.getNodeValue();				if (data != null && data.length() > 0) {					print(" ");					print(data);				}				print("?>");				break;			}		}		if (type == Node.ELEMENT_NODE) {			print("</");			print(nodeName(node));			print(">");		}		out.flush();	}	Attr[] sort(NamedNodeMap attrs) {		if (attrs == null)			return new Attr[0];		Attr result[] = new Attr[attrs.getLength()];		for (int i = 0; i < result.length; i++) {			result[i] = (Attr) attrs.item(i);		}		Arrays.sort(result, new Comparator() {			public int compare(Object arg0, Object arg1) {				return nodeName((Node) arg0).compareTo(nodeName((Node) arg1));			}		});		return result;	}	String normalize(String s) {		if (s == null) return "";		StringBuffer str = new StringBuffer();		for (int i = 0, length = s.length(); i < length; i++) {			char ch = s.charAt(i);			switch (ch) {				case '"': str.append("\""); break;				case '\r':				case '\n':					if (canonical) {						str.append("&#");						str.append(Integer.toString(ch));						str.append(';');						break;					}					// FALL THROUGH				default: str.append(ch);			}		}		return str.toString();	}}