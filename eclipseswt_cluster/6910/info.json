{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1eea115ebbe32ac99a1a4fec69b96913", "detectedBy": ["DIFF_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5ed9816e2b49fd60df255c62ac4c3b5", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "tests/org.eclipse.swt.tests/JUnit Tests/org/eclipse/swt/tests/junit/Test_org_eclipse_swt_widgets_Display.java", "commitBeforeChange": "3ace99cc2cbeca175428eabbe777b2fc353f5d7d", "commitAfterChange": "38b0d2b8f58957af87b01bf2967bf37e853d55b0", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 35, "signatureBeforeChange": "  public void test_getSyncThread()", "signatureAfterChange": "  public void test_getSyncThread()", "diff": ["-\twarnUnimpl(\"Test test_getSyncThread not written\");", "+\tfinal Display display = new Display();", "+\ttry {", "+\t\tfinal boolean[] threadRan = new boolean[] {false};", "+\t\tThread nonUIThread = new Thread(new Runnable() {", "+\t\t\tpublic void run() {", "+\t\t\t\t// Assume no syncExec runnable is currently being invoked.", "+\t\t\t\tassertNull(display.getSyncThread());", "+\t\t\t\t", "+\t\t\t\t// Create a runnable and invoke with syncExec to verify that", "+\t\t\t\t// the invoking thread is the syncThread.", "+\t\t\t\tfinal Thread invokingThread = Thread.currentThread();", "+\t\t\t\tdisplay.syncExec(new Runnable() {", "+\t\t\t\t\tpublic void run() {", "+\t\t\t\t\t\tassertEquals(invokingThread, display.getSyncThread());", "+\t\t\t\t\t}", "+\t\t\t\t});", "+\t\t\t\t", "+\t\t\t\t// Create a runnable and invoke with asyncExec to verify that", "+\t\t\t\t// the syncThread is null while it's running.", "+\t\t\t\tfinal boolean[] asyncExecRan = new boolean[] {false};", "+\t\t\t\tdisplay.asyncExec(new Runnable() {", "+\t\t\t\t\tpublic void run() {", "+\t\t\t\t\t\tassertNull(display.getSyncThread());", "+\t\t\t\t\t\tasyncExecRan[0] = true;", "+\t\t\t\t\t}", "+\t\t\t\t});", "+\t\t\t\t", "+\t\t\t\ttry {", "+\t\t\t\t\twhile (!asyncExecRan[0]) {", "+\t\t\t\t\t\tThread.sleep(100);", "+\t\t\t\t\t}", "+\t\t\t\t} catch (InterruptedException ex) {", "+\t\t\t\t}", "+\t\t\t\tthreadRan[0] = true;", "+\t\t\t\tdisplay.wake();", "+\t\t\t}", "+\t\t});", "+\t\tnonUIThread.start();", "+\t\t", "+\t\twhile (!threadRan[0]) {", "+\t\t\tif (!display.readAndDispatch()) display.sleep ();", "+\t\t}", "+\t} finally {", "+\t\tdisplay.dispose();", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "108f5fd84deebb656449dbf5a58b1f35", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "tests/org.eclipse.swt.tests/JUnit Tests/org/eclipse/swt/tests/junit/Test_org_eclipse_swt_widgets_Display.java", "commitBeforeChange": "3ace99cc2cbeca175428eabbe777b2fc353f5d7d", "commitAfterChange": "38b0d2b8f58957af87b01bf2967bf37e853d55b0", "methodNumberBeforeChange": 54, "methodNumberAfterChange": 70, "signatureBeforeChange": "  public void test_sleep()", "signatureAfterChange": "  public void test_sleep()", "diff": ["-\twarnUnimpl(\"Test test_sleep not written\");", "+\tfinal Display display = new Display();", "+\ttry {", "+\t\tThread thread;", "+\t\tboolean eventQueued;", "+\t\t", "+\t\t// Ensure event queue is empty, otherwise sleep() will just return.", "+\t\twhile(display.readAndDispatch()) {}", "+\t\tthread = new Thread() {", "+\t\t\tpublic void run() {", "+\t\t\t\ttry {", "+\t\t\t\t\t// Delay to ensure the UI thread has been put to sleep.", "+\t\t\t\t\tsleep(3000);", "+\t\t\t\t} catch (InterruptedException ex) {", "+\t\t\t\t}", "+\t\t\t\t// Use wake() to revive from sleep().", "+\t\t\t\tdisplay.wake();", "+\t\t\t}", "+\t\t};", "+\t\tthread.start();", "+\t\t// Note that sleep seems to always return true, at least", "+\t\t// on Windows, since wake() uses a null event. ", "+\t\teventQueued = display.sleep();", "+\t\t", "+\t\t// Ensure event queue is empty, otherwise sleep() will just return.", "+\t\twhile(display.readAndDispatch()) {}", "+\t\tthread = new Thread() {", "+\t\t\tpublic void run() {", "+\t\t\t\ttry {", "+\t\t\t\t\t// Delay to ensure the UI thread has been put to sleep.", "+\t\t\t\t\tsleep(3000);", "+\t\t\t\t} catch (InterruptedException ex) {", "+\t\t\t\t}", "+\t\t\t\t// Cause OS to generate an event to revive from sleep().", "+\t\t\t\tdisplay.syncExec(new Runnable() {", "+\t\t\t\t\tpublic void run() {", "+\t\t\t\t\t\tShell s = new Shell(display);", "+\t\t\t\t\t\ts.open();", "+\t\t\t\t\t\ts.dispose();", "+\t\t\t\t\t}", "+\t\t\t\t});", "+\t\t\t}", "+\t\t};", "+\t\tthread.start();", "+\t\teventQueued = display.sleep();", "+\t\tassertTrue(eventQueued);", "+\t} finally {", "+\t\tdisplay.dispose();", "+\t}"]}], "num": 6910}