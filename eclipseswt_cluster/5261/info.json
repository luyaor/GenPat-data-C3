{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9dbeb8a136e8ac220a3f56f801d1c966", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3a0311547142a33a774e46922f836f28", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/ToolBar.java", "commitBeforeChange": "a99d0f7512ef64a51e058b97dfb32c83f03879ac", "commitAfterChange": "844c3cba85108b0943332ca208e3882c23f3abd9", "methodNumberBeforeChange": 49, "methodNumberAfterChange": 49, "signatureBeforeChange": "  void updateOrientation ()", "signatureAfterChange": "  void updateOrientation ()", "diff": ["-\t\tdisplay.releaseToolImageList (imageList);", "-\t\timageList = display.getImageListToolBar (style & SWT.RIGHT_TO_LEFT, size.x, size.y);", "-\t\tint /*long*/ hImageList = imageList.getHandle ();", "-\t\tOS.SendMessage (handle, OS.TB_SETIMAGELIST, 0, hImageList);", "-\t}\t", "-\tif (hotImageList != null) {", "-\t\tPoint size = hotImageList.getImageSize ();", "-\t\tdisplay.releaseToolHotImageList (hotImageList);", "-\t\thotImageList = display.getImageListToolBarHot (style & SWT.RIGHT_TO_LEFT, size.x, size.y);", "-\t\tint /*long*/ hHotImageList  = hotImageList.getHandle ();", "-\t\tOS.SendMessage (handle, OS.TB_SETHOTIMAGELIST, 0, hHotImageList);", "-\t}\t", "-\tif (disabledImageList != null) {", "-\t\tPoint size = disabledImageList.getImageSize ();", "-\t\tdisplay.releaseToolDisabledImageList (disabledImageList);", "-\t\tdisabledImageList = display.getImageListToolBarDisabled (style & SWT.RIGHT_TO_LEFT, size.x, size.y);\t", "-\t\tint /*long*/ hDisImageList  = disabledImageList.getHandle ();", "-\t\tOS.SendMessage (handle, OS.TB_SETDISABLEDIMAGELIST, 0, hDisImageList);", "-\t}", "-\tif (imageList != null) {", "-\t\tfor (int i = 0; i < items.length; i++) {", "-\t\t\tToolItem item = items[i];", "-\t\t\tif (item != null) {", "-\t\t\t\tImage image = item.image;", "-\t\t\t\tif (image != null) {", "-\t\t\t\t\tTBBUTTONINFO info = new TBBUTTONINFO ();", "-\t\t\t\t\tinfo.cbSize = TBBUTTONINFO.sizeof;", "-\t\t\t\t\tinfo.dwMask = OS.TBIF_IMAGE;", "-\t\t\t\t\tboolean enabled = getEnabled () && item.getEnabled ();", "-\t\t\t\t\tImage disabled = item.disabledImage;", "-\t\t\t\t\tif (item.disabledImage == null) {", "-\t\t\t\t\t\tif (item.disabledImage2 != null) item.disabledImage2.dispose ();", "-\t\t\t\t\t\titem.disabledImage2 = null;", "-\t\t\t\t\t\tdisabled = image;", "-\t\t\t\t\t\tif (!enabled) {", "-\t\t\t\t\t\t\tdisabled = item.disabledImage2 = new Image (display, image, SWT.IMAGE_DISABLE);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\t/*", "-\t\t\t\t\t* Bug in Windows.  When a tool item with the style", "-\t\t\t\t\t* BTNS_CHECK or BTNS_CHECKGROUP is selected and then", "-\t\t\t\t\t* disabled, the item does not draw using the disabled", "-\t\t\t\t\t* image.  The fix is to assign the disabled image in", "-\t\t\t\t\t* all image lists.", "-\t\t\t\t\t*/", "-\t\t\t\t\tImage image2 = image, hot = item.hotImage;", "-\t\t\t\t\tif ((item.style & (SWT.CHECK | SWT.RADIO)) != 0) {", "-\t\t\t\t\t\tif (!enabled) image2 = hot = disabled;", "-\t\t\t\t\t}", "-\t\t\t\t\tinfo.iImage = imageList.add (image2);", "-\t\t\t\t\tdisabledImageList.add (disabled);", "-\t\t\t\t\thotImageList.add (hot != null ? hot : image2);", "-\t\t\t\t\tOS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);", "-\t\t\t\t}", "+\t\tImageList newImageList = display.getImageListToolBar (style & SWT.RIGHT_TO_LEFT, size.x, size.y);", "+\t\tImageList newHotImageList = display.getImageListToolBarHot (style & SWT.RIGHT_TO_LEFT, size.x, size.y);", "+\t\tImageList newDisabledImageList = display.getImageListToolBarDisabled (style & SWT.RIGHT_TO_LEFT, size.x, size.y);\t", "+\t\tTBBUTTONINFO info = new TBBUTTONINFO ();", "+\t\tinfo.cbSize = TBBUTTONINFO.sizeof;", "+\t\tinfo.dwMask = OS.TBIF_IMAGE;", "+\t\tint count = (int)/*64*/OS.SendMessage (handle, OS.TB_BUTTONCOUNT, 0, 0);", "+\t\tfor (int i=0; i<count; i++) {", "+\t\t\tToolItem item = items [i];", "+\t\t\tif ((item.style & SWT.SEPARATOR) != 0) continue;", "+\t\t\tif (item.image == null) continue;", "+\t\t\tOS.SendMessage (handle, OS.TB_GETBUTTONINFO, item.id, info);", "+\t\t\tif (info.iImage != OS.I_IMAGENONE) {", "+\t\t\t\tImage image = imageList.get(info.iImage);", "+\t\t\t\tImage hot = hotImageList.get(info.iImage);", "+\t\t\t\tImage disabled = disabledImageList.get(info.iImage);", "+\t\t\t\timageList.put(info.iImage, null);", "+\t\t\t\thotImageList.put(info.iImage, null);", "+\t\t\t\tdisabledImageList.put(info.iImage, null);", "+\t\t\t\tinfo.iImage = newImageList.add(image);", "+\t\t\t\tnewHotImageList.add(hot);", "+\t\t\t\tnewDisabledImageList.add(disabled);", "+\t\t\t\tOS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);", "+\t\tdisplay.releaseToolImageList (imageList);", "+\t\tdisplay.releaseToolHotImageList (hotImageList);", "+\t\tdisplay.releaseToolDisabledImageList (disabledImageList);", "+\t\tOS.SendMessage (handle, OS.TB_SETIMAGELIST, 0, newImageList.getHandle ());", "+\t\tOS.SendMessage (handle, OS.TB_SETHOTIMAGELIST, 0, newHotImageList.getHandle ());", "+\t\tOS.SendMessage (handle, OS.TB_SETDISABLEDIMAGELIST, 0, newDisabledImageList.getHandle ());", "+\t\timageList = newImageList;", "+\t\thotImageList = newHotImageList;", "+\t\tdisabledImageList = newDisabledImageList;", "+\t\tOS.InvalidateRect (handle, null, true);", "- }", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e40ea60862527d4fc710bdfbd3b5639", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "d589019807dc8edefe4eebafacf497892e57bece", "commitAfterChange": "7ec2e420459073a76767eaf4412d2bd5b970dc99", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 21, "signatureBeforeChange": "  void createItem (TreeItem item, int hParent, int hInsertAfter)", "signatureAfterChange": "  void createItem (TreeItem item, int hParent, int hInsertAfter, int hItem)", "diff": ["-void createItem (TreeItem item, int hParent, int hInsertAfter) {", "-\tint id = lastID < items.length ? lastID : 0;", "-\twhile (id < items.length && items [id] != null) id++;", "-\tif (id == items.length) {", "-\t\t/*", "-\t\t* Grow the array faster when redraw is off or the", "-\t\t* table is not visible.  When the table is painted,", "-\t\t* the items array is resized to be smaller to reduce", "-\t\t* memory usage.", "-\t\t*/", "-\t\tint length = items.length + 4;", "-\t\tif (drawCount != 0 || !OS.IsWindowVisible (handle)) {", "-\t\t\tlength = Math.max (4, items.length * 3 / 2);", "-\t\t\tshrink = true;", "+void createItem (TreeItem item, int hParent, int hInsertAfter, int hItem) {", "+\tint id = -1;", "+\tif (item != null) {", "+\t\tid = lastID < items.length ? lastID : 0;", "+\t\twhile (id < items.length && items [id] != null) id++;", "+\t\tif (id == items.length) {", "+\t\t\t/*", "+\t\t\t* Grow the array faster when redraw is off or the", "+\t\t\t* table is not visible.  When the table is painted,", "+\t\t\t* the items array is resized to be smaller to reduce", "+\t\t\t* memory usage.", "+\t\t\t*/", "+\t\t\tint length = 0;", "+\t\t\tif (drawCount == 0 && OS.IsWindowVisible (handle)) {", "+\t\t\t\tlength = items.length + 4;", "+\t\t\t} else {", "+\t\t\t\tshrink = true;", "+\t\t\t\tlength = Math.max (4, items.length * 3 / 2);", "+\t\t\t}", "+\t\t\tTreeItem [] newItems = new TreeItem [length];", "+\t\t\tSystem.arraycopy (items, 0, newItems, 0, items.length);", "+\t\t\titems = newItems;", "-\t\tTreeItem [] newItems = new TreeItem [length + 4];", "-\t\tSystem.arraycopy (items, 0, newItems, 0, items.length);", "-\t\titems = newItems;", "+\t\tlastID = id + 1;", "-\tlastID = id + 1;", "-\tTVINSERTSTRUCT tvInsert = new TVINSERTSTRUCT ();", "-\ttvInsert.hParent = hParent;", "-\ttvInsert.hInsertAfter = hInsertAfter;", "-\ttvInsert.lParam = id;", "-\ttvInsert.pszText = OS.LPSTR_TEXTCALLBACK;", "-\ttvInsert.iImage = tvInsert.iSelectedImage = OS.I_IMAGECALLBACK;", "-\ttvInsert.mask = OS.TVIF_TEXT | OS.TVIF_IMAGE | OS.TVIF_SELECTEDIMAGE | OS.TVIF_HANDLE | OS.TVIF_PARAM;", "-\tif ((style & SWT.CHECK) != 0) {", "-\t\ttvInsert.mask = tvInsert.mask | OS.TVIF_STATE;", "-\t\ttvInsert.state = 1 << 12;", "-\t\ttvInsert.stateMask = OS.TVIS_STATEIMAGEMASK;", "+\tint hNewItem = 0;", "+\tif (hItem == 0) {", "+\t\tTVINSERTSTRUCT tvInsert = new TVINSERTSTRUCT ();", "+\t\ttvInsert.hParent = hParent;", "+\t\ttvInsert.hInsertAfter = hInsertAfter;", "+\t\ttvInsert.lParam = id;", "+\t\ttvInsert.pszText = OS.LPSTR_TEXTCALLBACK;", "+\t\ttvInsert.iImage = tvInsert.iSelectedImage = OS.I_IMAGECALLBACK;", "+\t\ttvInsert.mask = OS.TVIF_TEXT | OS.TVIF_IMAGE | OS.TVIF_SELECTEDIMAGE | OS.TVIF_HANDLE | OS.TVIF_PARAM;", "+\t\tif ((style & SWT.CHECK) != 0) {", "+\t\t\ttvInsert.mask = tvInsert.mask | OS.TVIF_STATE;", "+\t\t\ttvInsert.state = 1 << 12;", "+\t\t\ttvInsert.stateMask = OS.TVIS_STATEIMAGEMASK;", "+\t\t}", "+\t\thNewItem = OS.SendMessage (handle, OS.TVM_INSERTITEM, 0, tvInsert);", "+\t\tif (hNewItem == 0) error (SWT.ERROR_ITEM_NOT_ADDED);", "+\t\t/*", "+\t\t* This code is intentionally commented.", "+\t\t*/", "+//\t\tif (hParent != 0) {", "+//\t\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);", "+//\t\t\tbits |= OS.TVS_LINESATROOT;", "+//\t\t\tOS.SetWindowLong (handle, OS.GWL_STYLE, bits);", "+//\t\t}", "+\t} else {", "+\t\tTVITEM tvItem = new TVITEM ();", "+\t\ttvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM;", "+\t\ttvItem.hItem = hNewItem = hItem;", "+\t\ttvItem.lParam = id;", "+\t\tOS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);", "-\tint hItem = OS.SendMessage (handle, OS.TVM_INSERTITEM, 0, tvInsert);", "-\tif (hItem == 0) error (SWT.ERROR_ITEM_NOT_ADDED);", "-\titem.handle = hItem;", "-\titems [id] = item;", "-", "-\t/*", "-\t* This code is intentionally commented.", "-\t*/", "-//\tif (hParent != 0) {", "-//\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);", "-//\t\tbits |= OS.TVS_LINESATROOT;", "-//\t\tOS.SetWindowLong (handle, OS.GWL_STYLE, bits);", "-//\t}", "-", "-\t/*", "-\t* Bug in Windows.  When a child item is added to a parent item", "-\t* that has no children outside of WM_NOTIFY with control code", "-\t* TVN_ITEMEXPANDED, the tree widget does not redraw the +/-", "-\t* indicator.  The fix is to detect the case when the first", "-\t* child is added to a visible parent item and redraw the parent.", "-\t*/", "-\tif (drawCount == 0 && OS.IsWindowVisible (handle)) {", "-\t\tint hChild = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hParent);", "-\t\tif (hChild != 0 && OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hChild) == 0) {", "-\t\t\tRECT rect = new RECT ();", "-\t\t\trect.left = hParent;", "-\t\t\tif (OS.SendMessage (handle, OS.TVM_GETITEMRECT, 0, rect) != 0) {", "-\t\t\t\tOS.InvalidateRect (handle, rect, true);", "+\tif (item != null) {", "+\t\titem.handle = hNewItem;", "+\t\titems [id] = item;", "+\t}", "+\tif (hItem == 0) {", "+\t\t/*", "+\t\t* Bug in Windows.  When a child item is added to a parent item", "+\t\t* that has no children outside of WM_NOTIFY with control code", "+\t\t* TVN_ITEMEXPANDED, the tree widget does not redraw the +/-", "+\t\t* indicator.  The fix is to detect the case when the first", "+\t\t* child is added to a visible parent item and redraw the parent.", "+\t\t*/", "+\t\tif (drawCount == 0 && OS.IsWindowVisible (handle)) {", "+\t\t\tint hChild = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hParent);", "+\t\t\tif (hChild != 0 && OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hChild) == 0) {", "+\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\trect.left = hParent;", "+\t\t\t\tif (OS.SendMessage (handle, OS.TVM_GETITEMRECT, 0, rect) != 0) {", "+\t\t\t\t\tOS.InvalidateRect (handle, rect, true);", "+\t\t\t\t}", "+\t\tupdateScrollBar ();", "-\tupdateScrollBar ();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da4ff77204b27ff8aa0c6dda924402db", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/TreeItem.java", "commitBeforeChange": "2b635221beaca11b0f2782595f2f04eb08656eed", "commitAfterChange": "c964a36f72c09bd56edcd52d15c933282bfc4ef8", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 46, "signatureBeforeChange": " public void setExpanded (boolean expanded)", "signatureAfterChange": " public void setExpanded (boolean expanded)", "diff": ["+\t", "+\t/* Do nothing when the item is a leaf or already expanded */", "+\tint hwnd = parent.handle;", "+\tif (OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, handle) == 0) {", "+\t\treturn;", "+\t}", "+\tint state = 0;", "+\tif (OS.IsWinCE) {", "+\t\tTVITEM tvItem = new TVITEM ();", "+\t\ttvItem.hItem = handle;", "+\t\ttvItem.mask = OS.TVIF_STATE;", "+\t\tOS.SendMessage (hwnd, OS.TVM_GETITEM, 0, tvItem);", "+\t\tstate = tvItem.state;", "+\t} else {", "+\t\t/*", "+\t\t* Bug in Windows.  Despite the fact that TVM_GETITEMSTATE claims", "+\t\t* to return only the bits specified by the stateMask, when called", "+\t\t* with TVIS_EXPANDED, the entire state is returned.  The fix is", "+\t\t* to explicitly check for the TVIS_EXPANDED bit.", "+\t\t*/", "+\t\tstate = OS.SendMessage (hwnd, OS.TVM_GETITEMSTATE, handle, OS.TVIS_EXPANDED);", "+\t}", "+\tif (((state & OS.TVIS_EXPANDED) != 0) == expanded) return;", "+\t", "+\t/*", "+\t* Feature in Windows.  When TVM_EXPAND is used to expand", "+\t* an item, the widget scrolls to show the root item and", "+\t* the newly expanded items.  While not strictly incorrect,", "+\t* this means that application code that expands tree items", "+\t* in a background thread can scroll the widget while the", "+\t* user is interacting with it.  The fix is to remember", "+\t* the top item and the bounds of every tree item, turn", "+\t* redraw off, expand the item, scroll back to the top", "+\t* item.  If none of the rectangles have moved, then", "+\t* it is safe to turn redraw back on without redrawing", "+\t* the control.", "+\t*/", "+\tRECT [] rects = null;", "+\tboolean redraw = false, noScroll = true;", "+\tint count = 0, hTopItem = OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);", "+\tif (noScroll && hTopItem != 0) {", "+\t\tif (parent.drawCount == 0 && OS.IsWindowVisible (hwnd)) {", "+\t\t\tboolean noAnimate = true;", "+\t\t\tcount = OS.SendMessage (hwnd, OS.TVM_GETVISIBLECOUNT, 0, 0);", "+\t\t\trects = new RECT [count + 1];", "+\t\t\tint hItem = hTopItem, index = 0;", "+\t\t\twhile (hItem != 0 && (noAnimate || hItem != handle) && index < count) {", "+\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\trect.left = hItem;", "+\t\t\t\tif (OS.SendMessage (hwnd, OS.TVM_GETITEMRECT, 1, rect) != 0) {", "+\t\t\t\t\trects [index++] = rect;", "+\t\t\t\t}", "+\t\t\t\thItem = OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hItem);", "+\t\t\t}", "+\t\t\tif (noAnimate || hItem != handle) {", "+\t\t\t\tredraw = true;", "+\t\t\t\tcount = index;", "+\t\t\t\tint topHandle = parent.topHandle ();", "+\t\t\t\tOS.UpdateWindow (topHandle);", "+\t\t\t\tOS.DefWindowProc (topHandle, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t\tif (hwnd != topHandle) {", "+\t\t\t\t\tOS.UpdateWindow (hwnd);", "+\t\t\t\t\tOS.DefWindowProc (hwnd, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t\t}", "+\t\t\t\t/*", "+\t\t\t\t* This code is intentionally commented.", "+\t\t\t\t*/", "+//\t\t\t\tOS.SendMessage (hwnd, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t}", "+\t\t}", "+\t}", "+\t", "-\t* strictly wrong but is inconsistent.  The fix is to notice", "-\t* that the selection has changed and issue the event.", "+\t* strictly wrong but is inconsistent.  The fix is to", "+\t* check whether the selection has changed and issue", "+\t* the event.", "-\tint hwnd = parent.handle;", "+\t", "+\t/* Expand or collapse the item */", "+\t", "+\t/* Scroll back to the top item */", "+\tif (noScroll && hTopItem != 0) {", "+\t\tOS.SendMessage (hwnd, OS.TVM_SELECTITEM, OS.TVGN_FIRSTVISIBLE, hTopItem);", "+\t\tif (redraw) {", "+\t\t\tboolean fixRedraw = false;", "+\t\t\tif (hTopItem == OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0)) {", "+\t\t\t\tint hItem = hTopItem, index = 0;", "+\t\t\t\twhile (hItem != 0 && index < count) {", "+\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\trect.left = hItem;", "+\t\t\t\t\tif (OS.SendMessage (hwnd, OS.TVM_GETITEMRECT, 1, rect) != 0) {", "+\t\t\t\t\t\tif (!OS.EqualRect (rect, rects [index])) {", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\thItem = OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hItem);", "+\t\t\t\t\tindex++;", "+\t\t\t\t}", "+\t\t\t\tfixRedraw = index == count;", "+\t\t\t}", "+\t\t\tint topHandle = parent.topHandle ();", "+\t\t\tOS.DefWindowProc (topHandle, OS.WM_SETREDRAW, 1, 0);", "+\t\t\tif (hwnd != topHandle) {", "+\t\t\t\tOS.DefWindowProc (hwnd, OS.WM_SETREDRAW, 1, 0);", "+\t\t\t}", "+\t\t\t/*", "+\t\t\t* This code is intentionally commented.", "+\t\t\t*/", "+//\t\t\tOS.SendMessage (hwnd, OS.WM_SETREDRAW, 1, 0);", "+\t\t\tif (fixRedraw) {", "+\t\t\t\tparent.updateScrollBar ();", "+\t\t\t\tSCROLLINFO info = new SCROLLINFO ();", "+\t\t\t\tinfo.cbSize = SCROLLINFO.sizeof;", "+\t\t\t\tinfo.fMask = OS.SIF_ALL;", "+\t\t\t\tif (OS.GetScrollInfo (hwnd, OS.SB_VERT, info)) {", "+\t\t\t\t\tOS.SetScrollInfo (hwnd, OS.SB_VERT, info, true);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (OS.IsWinCE) {", "+\t\t\t\t\tOS.InvalidateRect (topHandle, null, true);", "+\t\t\t\t\tif (hwnd != topHandle) OS.InvalidateRect (hwnd, null, true);", "+\t\t\t\t} else {", "+\t\t\t\t\tint flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;", "+\t\t\t\t\tOS.RedrawWindow (topHandle, null, 0, flags);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+", "+\t/* Check for a selection event */"]}], "num": 5261}