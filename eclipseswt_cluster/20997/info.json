{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1d211c8d11d0f30bc974f4bd8da1ebba", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b45c8a91a5667e21a078687ca60a5729", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/widgets/Shell.java", "commitBeforeChange": "f58ccd83db58f36bdb07149ae18acd8b9fdb8fa7", "commitAfterChange": "d314f513a989cc3e1d28bd135c01b43b1ff1c912", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": "\r \r int processResize (int callData)", "signatureAfterChange": "\r \r int processResize (int callData)", "diff": ["-\t\t\t// fall through\r", "+\t\t\t// FALL THROUGH\r", "-\t\t\t\tsendEvent (SWT.Resize);\r", "-\t\t\t\tif (layout != null) layout (false);\r", "+\t\t\t\tXAnyEvent event = new XAnyEvent ();\r", "+\t\t\t\tdisplay.resizeWindow = xEvent.window;\r", "+\t\t\t\tdisplay.resizeWidth = xEvent.width;\r", "+\t\t\t\tdisplay.resizeHeight = xEvent.height;\r", "+\t\t\t\tdisplay.resizeCount = 0;\r", "+\t\t\t\tint checkResizeProc = display.checkResizeProc;\r", "+\t\t\t\tOS.XCheckIfEvent (xEvent.display, event, checkResizeProc, 0);\r", "+\t\t\t\tif (display.resizeCount == 0) {\r", "+\t\t\t\t\tsendEvent (SWT.Resize);\r", "+\t\t\t\t\tif (layout != null) layout (false);\r", "+\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e2b4a6979bbf51633e2bafcb75828c7d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "336c640f21f6098f84d6d6682ff7635ddf66f650", "commitAfterChange": "20f32f00170b2b5fe44ce0d2c73eb51efa55207e", "methodNumberBeforeChange": 220, "methodNumberAfterChange": 220, "signatureBeforeChange": "  LRESULT WM_SYSKEYDOWN (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_SYSKEYDOWN (int wParam, int lParam)", "diff": ["-\tif (!OS.IsWinCE) {", "-\t\tif (OS.MapVirtualKey (wParam, 2) != 0) {", "-\t\t\t/*", "-\t\t\t* Feature in Windows.  MapVirtualKey() indicates that", "-\t\t\t* a WM_SYSCHAR message will occur for Alt+Enter but", "-\t\t\t* this message never happens.  The fix is to issue the", "-\t\t\t* event from WM_SYSKEYDOWN and map VK_RETURN to '\\r'.", "-\t\t\t*/", "-\t\t\tif (wParam != OS.VK_RETURN) return null;", "-\t\t\tdisplay.lastAscii = '\\r';", "+\tint mapKey = OS.IsWinCE ? 0 : OS.MapVirtualKey (wParam, 2);", "+\tdisplay.lastVirtual = (mapKey == 0);", "+\tif (display.lastVirtual) {", "+\t \tdisplay.lastKey = wParam;", "+\t\t/*", "+\t\t* Feature in Windows.  The virtual key VK_DELETE is not", "+\t\t* treated as both a virtual key and an ASCII key by Windows.", "+\t\t* Therefore, we will not receive a WM_CHAR for this key.", "+\t\t* The fix is to treat VK_DELETE as a special case and map", "+\t\t* the ASCII value explictly (Delete is 0x7F).", "+\t\t*/", "+\t\tif (display.lastKey == OS.VK_DELETE) {", "+\t\t\tdisplay.lastVirtual = false;", "+\t\t\tdisplay.lastKey = display.lastAscii = 0x7F;", "+", "+\t\t/*", "+\t\t* It is possible to get a WM_CHAR for a virtual key when", "+\t\t* Num Lock is on.  If the user types Home while Num Lock ", "+\t\t* is down, a WM_CHAR is issued with WPARM=55 (for the", "+\t\t* character 7).  If we are going to get a WM_CHAR we need", "+\t\t* to ensure that the last key has the correct value.  Note", "+\t\t* that Ctrl+Home does not issue a WM_CHAR when Num Lock is", "+\t\t* down.", "+\t\t* ", "+\t\t* NOTE: This only happens on Windows 98.", "+\t\t*/", "+\t\tif (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {", "+\t\t\tif (display.asciiKey (display.lastKey) != 0) return null;", "+\t\t\tdisplay.lastAscii = display.numpadKey (display.lastKey);", "+\t\t}", "+\t} else {", "+\t\t/*", "+\t\t* Convert LastKey to lower case because Windows non-virtual", "+\t\t* keys that are also ASCII keys, such as like VK_A, are have", "+\t\t* upper case values in WM_KEYDOWN despite the fact that the ", "+\t\t* Shift was not pressed.", "+\t\t*/", "+\t \tdisplay.lastKey = OS.CharLower ((short) mapKey);", "+", "+\t\t/*", "+\t\t* Feature in Windows 98.  MapVirtualKey() indicates that", "+\t\t* a WM_SYSCHAR message will occur for Alt+Enter but", "+\t\t* this message never happens.  The fix is to issue the", "+\t\t* event from WM_SYSKEYDOWN and map VK_RETURN to '\\r'.", "+\t\t*/", "+\t\tif (OS.IsWinNT) return null;", "+\t\tif (wParam != OS.VK_RETURN) return null;", "+\t\tdisplay.lastAscii = '\\r';", "-\tdisplay.lastKey = wParam;", "-\tdisplay.lastVirtual = true;", "-\t\t", "-\t/*", "-\t* Feature in Windows.  The virtual key VK_DELETE is not", "-\t* treated as both a virtual key and an ASCII key by Windows.", "-\t* Therefore, we will not receive a WM_CHAR for this key.", "-\t* The fix is to treat VK_DELETE as a special case and map", "-\t* the ASCII value explictly (Delete is 0x7F).", "-\t*/", "-\tif (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;", "-\t", "-\t/*", "-\t* It is possible to get a WM_CHAR for a virtual key when", "-\t* Num Lock is on.  If the user types Home while Num Lock ", "-\t* is down, a WM_CHAR is issued with WPARM=55 (for the", "-\t* character 7).  If we are going to get a WM_CHAR we need", "-\t* to ensure that the last key has the correct value.  Note", "-\t* that Ctrl+Home does not issue a WM_CHAR when Num Lock is", "-\t* down.", "-\t*/", "-\tif (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {", "-\t\tif (display.asciiKey (display.lastKey) != 0) return null;", "-\t}", "-\t", "+"]}], "num": 20997}