{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d4d290b882b047b59432a38c1bcec1a2", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "edca1f64549d7296a033700665fc1f03", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Accessibility/gtk/org/eclipse/swt/accessibility/AccessibleObject.java", "commitBeforeChange": "0340debbaaefb8e5e03fed96b035767987fa3336", "commitAfterChange": "86c6160bde1107ec16cb8aa072081281378eb1d3", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": "  \tint atkText_get_text_at_offset (int offset, int boundary_type, int start_offset, int end_offset)", "signatureAfterChange": "  \tint atkText_get_text_at_offset (int offset, int boundary_type, int start_offset, int end_offset)", "diff": ["-\t\t// TODO", "+\t\tString text = getText ();", "+\t\tif (text != null) {", "+\t\t\tint length = text.length ();", "+\t\t\toffset = Math.min (offset, length - 1);", "+\t\t\tint startBounds = offset;", "+\t\t\tint endBounds = offset;", "+\t\t\tswitch (boundary_type) {", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_CHAR: {", "+\t\t\t\t\tif (length > offset) endBounds++;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_WORD_START: {", "+\t\t\t\t\tint wordStart1 = previousIndexOfNotChar (text, \" !?.\\n\", offset);", "+\t\t\t\t\tif (wordStart1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\twordStart1 = previousIndexOfChar (text, \" !?.\\n\", wordStart1) + 1;", "+\t\t\t\t\tif (wordStart1 == -1) {", "+\t\t\t\t\t\tstartBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tstartBounds = wordStart1;", "+\t\t\t\t\tint wordStart2 = nextIndexOfChar (text, \" !?.\\n\", wordStart1);", "+\t\t\t\t\tendBounds = nextIndexOfNotChar (text, \" !?.\\n\", wordStart2);", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_WORD_END: {", "+\t\t\t\t\tint wordEnd1 = previousIndexOfNotChar (text, \"!?.\", offset + 1);", "+\t\t\t\t\twordEnd1 = previousIndexOfChar (text, \" !?.\\n\", wordEnd1);", "+\t\t\t\t\twordEnd1 = previousIndexOfNotChar (text, \" \\n\", wordEnd1 + 1);", "+\t\t\t\t\tif (wordEnd1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tstartBounds = wordEnd1 + 1;", "+\t\t\t\t\tint wordEnd2 = nextIndexOfNotChar (text, \" \\n\", startBounds);", "+\t\t\t\t\tif (wordEnd2 == length) {", "+\t\t\t\t\t\tendBounds = startBounds;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\twordEnd2 = nextIndexOfChar (text, \" !?.\\n\", wordEnd2);", "+\t\t\t\t\tif (wordEnd2 == -1) {", "+\t\t\t\t\t\tendBounds = startBounds;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tendBounds = nextIndexOfNotChar (text, \"!?.\", wordEnd2);", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_SENTENCE_START: {", "+\t\t\t\t\tint sentenceStart1 = previousIndexOfNotChar (text, \" !?.\\n\", offset + 1);", "+\t\t\t\t\tif (sentenceStart1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tsentenceStart1 = previousIndexOfChar (text, \"!?.\", sentenceStart1) + 1;", "+\t\t\t\t\tstartBounds = nextIndexOfNotChar (text, \" \\n\", sentenceStart1);", "+\t\t\t\t\tint sentenceStart2 = nextIndexOfChar (text, \"!?.\", startBounds);", "+\t\t\t\t\tendBounds = nextIndexOfNotChar (text, \" !?.\\n\", sentenceStart2);", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_SENTENCE_END: {", "+\t\t\t\t\tint sentenceEnd1 = previousIndexOfNotChar (text, \"!?.\", offset + 1);", "+\t\t\t\t\tsentenceEnd1 = previousIndexOfChar (text, \"!?.\", sentenceEnd1);", "+\t\t\t\t\tsentenceEnd1 = previousIndexOfNotChar (text, \" \\n\", sentenceEnd1 + 1);", "+\t\t\t\t\tif (sentenceEnd1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tstartBounds = sentenceEnd1 + 1;", "+\t\t\t\t\tint sentenceEnd2 = nextIndexOfNotChar (text, \" \\n\", startBounds);", "+\t\t\t\t\tif (sentenceEnd2 == length) {", "+\t\t\t\t\t\tendBounds = startBounds;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tsentenceEnd2 = nextIndexOfChar (text, \"!?.\", sentenceEnd2);", "+\t\t\t\t\tif (sentenceEnd2 == -1) {", "+\t\t\t\t\t\tendBounds = startBounds;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tendBounds = nextIndexOfNotChar (text, \"!?.\", sentenceEnd2);", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_LINE_START: {", "+\t\t\t\t\tstartBounds = previousIndexOfChar (text, \"\\n\", offset) + 1;", "+\t\t\t\t\tint lineEnd2 = nextIndexOfChar (text, \"\\n\", startBounds);", "+\t\t\t\t\tif (lineEnd2 < length) lineEnd2++;", "+\t\t\t\t\tendBounds = lineEnd2;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_LINE_END: {", "+\t\t\t\t\tint lineEnd1 = previousIndexOfChar (text, \"\\n\", offset);", "+\t\t\t\t\tif (lineEnd1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tstartBounds = lineEnd1;", "+\t\t\t\t\tendBounds = nextIndexOfChar (text, \"\\n\", lineEnd1 + 1);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tOS.memmove (start_offset, new int[] {startBounds}, 4);", "+\t\t\tOS.memmove (end_offset, new int[] {endBounds}, 4);", "+\t\t\ttext = text.substring (startBounds, endBounds);", "+\t\t\tbyte[] bytes = Converter.wcsToMbcs (null, text, true);", "+//\t\t\tTODO gnopernicus bug? freeing previous string can cause gp", "+//\t\t\tif (textPtr != -1) OS.g_free (textPtr);", "+\t\t\ttextPtr = OS.g_malloc (bytes.length);", "+\t\t\tOS.memmove (textPtr, bytes, bytes.length);", "+\t\t\treturn textPtr;", "+\t\t} ", "-\t\t\tif (textIface.get_text_at_offset != 0) {", "-\t\t\t\treturn OS.call (textIface.get_text_at_offset, handle, offset, boundary_type, start_offset, end_offset);", "+\t\t\tif (textIface.get_text_after_offset != 0) {", "+\t\t\t\treturn OS.call (textIface.get_text_after_offset, handle, offset, boundary_type, start_offset, end_offset);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "12d7955004a2ae16e0918d89841cb6d9", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Accessibility/gtk/org/eclipse/swt/accessibility/AccessibleObject.java", "commitBeforeChange": "34066a19fa70ed4fbdac3126ec1d0ac679f3f849", "commitAfterChange": "55e256ffa6e7c89a4c4d086309d5e766d0c33961", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  \tint atkText_get_text_before_offset (int offset, int boundary_type, int start_offset, int end_offset)", "signatureAfterChange": "  \tint atkText_get_text_before_offset (int offset, int boundary_type, int start_offset, int end_offset)", "diff": ["-\t\t// TODO", "+\t\tString text = getText ();", "+\t\tif (text != null) {", "+\t\t\tint length = text.length ();", "+\t\t\toffset = Math.min (offset, length - 1);", "+\t\t\tint startBounds = offset;", "+\t\t\tint endBounds = offset;", "+\t\t\tswitch (boundary_type) {", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_CHAR: {", "+\t\t\t\t\tif (length >= offset && offset > 0) startBounds--;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_WORD_START: {", "+\t\t\t\t\tint wordStart1 = previousIndexOfChar (text, \" !?.\\n\", offset - 1);", "+\t\t\t\t\tif (wordStart1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tint wordStart2 = previousIndexOfNotChar (text, \" !?.\\n\", wordStart1);", "+\t\t\t\t\tif (wordStart2 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tendBounds = wordStart1 + 1;", "+\t\t\t\t\tstartBounds = previousIndexOfChar (text, \" !?.\\n\", wordStart2) + 1;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_WORD_END: {", "+\t\t\t\t\tint wordEnd1 = previousIndexOfChar (text, \" !?.\\n\", offset);", "+\t\t\t\t\tif (wordEnd1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\twordEnd1 = previousIndexOfNotChar (text, \" \\n\", wordEnd1 + 1);", "+\t\t\t\t\tif (wordEnd1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tendBounds = wordEnd1 + 1;", "+\t\t\t\t\tint wordEnd2 = previousIndexOfNotChar (text, \" !?.\\n\", endBounds);", "+\t\t\t\t\twordEnd2 = previousIndexOfChar (text, \" !?.\\n\", wordEnd2);", "+\t\t\t\t\tif (wordEnd2 == -1) {", "+\t\t\t\t\t\tstartBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tstartBounds = previousIndexOfNotChar (text, \" \\n\", wordEnd2 + 1) + 1;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_SENTENCE_START: {", "+\t\t\t\t\tint sentenceStart1 = previousIndexOfChar (text, \"!?.\", offset);", "+\t\t\t\t\tif (sentenceStart1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tint sentenceStart2 = previousIndexOfNotChar (text, \"!?.\", sentenceStart1);", "+\t\t\t\t\tif (sentenceStart2 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tendBounds = sentenceStart1 + 1;", "+\t\t\t\t\tstartBounds = previousIndexOfChar (text, \"!?.\", sentenceStart2) + 1;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_SENTENCE_END: {", "+\t\t\t\t\tint sentenceEnd1 = previousIndexOfChar (text, \"!?.\", offset);", "+\t\t\t\t\tif (sentenceEnd1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tsentenceEnd1 = previousIndexOfNotChar (text, \" \\n\", sentenceEnd1 + 1);", "+\t\t\t\t\tif (sentenceEnd1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tendBounds = sentenceEnd1 + 1;", "+\t\t\t\t\tint sentenceEnd2 = previousIndexOfNotChar (text, \"!?.\", endBounds);", "+\t\t\t\t\tsentenceEnd2 = previousIndexOfChar (text, \"!?.\", sentenceEnd2);", "+\t\t\t\t\tif (sentenceEnd2 == -1) {", "+\t\t\t\t\t\tstartBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tstartBounds = previousIndexOfNotChar (text, \" \\n\", sentenceEnd2 + 1) + 1;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_LINE_START: {", "+\t\t\t\t\tint lineStart1 = previousIndexOfChar (text, \"\\n\", offset);", "+\t\t\t\t\tif (lineStart1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tendBounds = lineStart1 + 1;", "+\t\t\t\t\tstartBounds = previousIndexOfChar (text, \"\\n\", lineStart1) + 1;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase ATK.ATK_TEXT_BOUNDARY_LINE_END: {", "+\t\t\t\t\tint lineEnd1 = previousIndexOfChar (text, \"\\n\", offset);", "+\t\t\t\t\tif (lineEnd1 == -1) {", "+\t\t\t\t\t\tstartBounds = endBounds = 0;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tendBounds = lineEnd1;", "+\t\t\t\t\tstartBounds = previousIndexOfChar (text, \"\\n\", lineEnd1);", "+\t\t\t\t\tif (startBounds == -1) startBounds = 0;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tOS.memmove (start_offset, new int[] {startBounds}, 4);", "+\t\t\tOS.memmove (end_offset, new int[] {endBounds}, 4);", "+\t\t\ttext = text.substring (startBounds, endBounds);", "+\t\t\tbyte[] bytes = Converter.wcsToMbcs (null, text, true);", "+\t\t\t// TODO gnopernicus bug? freeing previous string can cause gp", "+//\t\t\tif (textPtr != -1) OS.g_free (textPtr);", "+\t\t\ttextPtr = OS.g_malloc (bytes.length);", "+\t\t\tOS.memmove (textPtr, bytes, bytes.length);", "+\t\t\treturn textPtr;", "+\t\t} "]}], "num": 11239}