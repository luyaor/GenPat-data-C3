{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b7987007f5dfaa658be9314efbfbfb8a", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "18319ea17b60b705af42022a1dc627a4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "73b51de8c84174e0e99b4c04bc9fd87166a96cec", "commitAfterChange": "7df940ae424cbd3c79310d7b9bc5d657b5781f6f", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-    int srcRowBytes= rowBytes(width, srcDepth);", "-    int srcBitsPerPixel= srcDepth;", "-", "-\t/* Calculate the palette depending on the display attributes */", "-\tPaletteData palette = null;", "+    int srcRowBytes= rowBytes(width, srcDepth);", "+    int srcBitsPerPixel= srcDepth;", "-\t", "-\tswitch (srcDepth) {", "-\t\tcase 1:", "-\t\t\tpalette = new PaletteData(new RGB[] {", "-\t\t\t\tnew RGB(0, 0, 0),", "-\t\t\t\tnew RGB(255, 255, 255)", "-\t\t\t});", "-\t\t\tbreak;", "-\t\tcase 4:", "-\t\t\t/*", "-\t\t\t * We currently don't run on a 4-bit server, so 4-bit images", "-\t\t\t * should not exist.", "-\t\t\t */", "-\t\t\tSWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);", "-\t\tcase 8:", "-\t\t\t/* Normalize the pixels in the source image data (by making the", "-\t\t\t * pixel values sequential starting at pixel 0). Reserve normalized", "-\t\t\t * pixel 0 so that it maps to real pixel 0. This assumes pixel 0 is", "-\t\t\t * always used in the image.", "-\t\t\t */", "-\t\t\tbyte[] normPixel = new byte[ 256 ];", "-\t\t\tfor (int index = 0; index < normPixel.length; index++) {", "-\t\t\t\tnormPixel[ index ] = 0;", "-\t\t\t}", "-\t\t\tint numPixels = 1;", "-\t\t\tint index = 0;", "-\t\t\tfor (int y = 0; y < height; y++) {", "-\t\t\t\tfor (int x = 0; x < srcRowBytes; x++) {", "-\t\t\t\t\tint srcPixel = srcData[ index + x ] & 0xFF;", "-\t\t\t\t\tif (srcPixel != 0 && normPixel[ srcPixel ] == 0) {", "-\t\t\t\t\t\tnormPixel[ srcPixel ] = (byte)numPixels++;", "-\t\t\t\t\t}", "-\t\t\t\t\tsrcData[ index + x ] = normPixel[ srcPixel ];", "-\t\t\t\t}", "-\t\t\t\tindex += srcRowBytes;", "-\t\t\t}", "-\t\t\t", "-\t\t\tshort[] colorTable= getColorTable(pixmap);", "-\t\t\t/* Create a palette with only the RGB values used in the image. */", "-\t\t\tRGB[] rgbs = new RGB[ numPixels ];", "-\t\t\tfor (int srcPixel = 0; srcPixel < normPixel.length; srcPixel++) {", "-\t\t\t\t// If the pixel value was used in the image, get its RGB values.", "-\t\t\t\tif (srcPixel == 0 || normPixel[ srcPixel ] != 0) {", "-\t\t\t\t\tint packed= getRGB(colorTable, srcPixel);", "-\t\t\t\t\tint rgbIndex = normPixel[ srcPixel ] & 0xFF;", "-\t\t\t\t\trgbs[ rgbIndex ] = new RGB((packed >> 16) & 0xFF, (packed >> 8) & 0xFF, (packed >> 0) & 0xFF);\t\t\t\t\t", "+\t/* Build the palette */", "+\tPaletteData palette = null;", "+\tswitch (srcDepth) {", "+\tcase 1:", "+\t\tpalette = new PaletteData(new RGB[] {", "+\t\t\tnew RGB(0, 0, 0),", "+\t\t\tnew RGB(255, 255, 255)", "+\t\t});", "+\t\tbreak;", "+\tcase 4:", "+\t\tshort[] colorTable4= getColorTable(pixmap);", "+\t\tRGB[] rgbs4 = new RGB[ colorTable4.length/4 ];", "+\t\tfor (int i = 0; i < rgbs4.length; i++) {", "+\t\t\tint packed= getRGB(colorTable4, i);", "+\t\t\trgbs4[i] = new RGB((packed >> 16) & 0xFF, (packed >> 8) & 0xFF, (packed >> 0) & 0xFF);", "+\t\t}", "+\t\tpalette = new PaletteData(rgbs4);", "+\t\tbreak;", "+\tcase 8:", "+\t\t/* Normalize the pixels in the source image data (by making the", "+\t\t * pixel values sequential starting at pixel 0). Reserve normalized", "+\t\t * pixel 0 so that it maps to real pixel 0. This assumes pixel 0 is", "+\t\t * always used in the image.", "+\t\t */", "+\t\tbyte[] normPixel = new byte[ 256 ];", "+\t\tfor (int index = 0; index < normPixel.length; index++) {", "+\t\t\tnormPixel[ index ] = 0;", "+\t\t}", "+\t\tint numPixels = 1;", "+\t\tint index = 0;", "+\t\tfor (int y = 0; y < height; y++) {", "+\t\t\tfor (int x = 0; x < srcRowBytes; x++) {", "+\t\t\t\tint srcPixel = srcData[ index + x ] & 0xFF;", "+\t\t\t\tif (srcPixel != 0 && normPixel[ srcPixel ] == 0) {", "+\t\t\t\t\tnormPixel[ srcPixel ] = (byte)numPixels++;", "+\t\t\t\tsrcData[ index + x ] = normPixel[ srcPixel ];", "-\t\t\tpalette = new PaletteData(rgbs);", "-\t\t\tbreak;", "-\t\tcase 16:", "-\t\tcase 24:", "-\t\tcase 32:", "-\t\t\tpalette = new PaletteData(getRedMask(srcDepth), getGreenMask(srcDepth), getBlueMask(srcDepth));", "-\t\t\tbreak;", "-\t\tdefault:", "-\t\t\tSWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);", "+\t\t\tindex += srcRowBytes;", "+\t\t}", "+\t\t", "+\t\tshort[] colorTable= getColorTable(pixmap);", "+", "+\t\t/* Create a palette with only the RGB values used in the image. */", "+\t\tRGB[] rgbs = new RGB[ numPixels ];", "+\t\tfor (int srcPixel = 0; srcPixel < normPixel.length; srcPixel++) {", "+\t\t\t// If the pixel value was used in the image, get its RGB values.", "+\t\t\tif (srcPixel == 0 || normPixel[ srcPixel ] != 0) {", "+\t\t\t\tint packed= getRGB(colorTable, srcPixel);", "+\t\t\t\tint rgbIndex = normPixel[ srcPixel ] & 0xFF;", "+\t\t\t\trgbs[ rgbIndex ] = new RGB((packed >> 16) & 0xFF, (packed >> 8) & 0xFF, (packed >> 0) & 0xFF);\t\t\t\t\t", "+\t\t\t}", "+\t\t}", "+\t\tpalette = new PaletteData(rgbs);", "+\t\tbreak;", "+\tcase 16:", "+\tcase 24:", "+\tcase 32:", "+\t\tpalette = new PaletteData(getRedMask(srcDepth), getGreenMask(srcDepth), getBlueMask(srcDepth));", "+\t\tbreak;", "+\tdefault:", "+\t\tSWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);", "+\t", "-\tif (false && srcBitsPerPixel == 32) {", "+\tif (srcBitsPerPixel == 32) {", "-\t\tint rOffset = 0, gOffset = 1, bOffset = 2;", "-\t\t// MSBFirst:", "-\t\trOffset = 3; gOffset = 2; bOffset = 1;", "-\t\t\t\tnewData[destIndex] = oldData[srcIndex + rOffset];", "-\t\t\t\tnewData[destIndex + 1] = oldData[srcIndex + gOffset];", "-\t\t\t\tnewData[destIndex + 2] = oldData[srcIndex + bOffset];", "+\t\t\t\tnewData[destIndex] = oldData[srcIndex + 1];", "+\t\t\t\tnewData[destIndex + 1] = oldData[srcIndex + 2];", "+\t\t\t\tnewData[destIndex + 2] = oldData[srcIndex + 3];"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f4210cc6cae2dbbfb8d72d8c04879b2", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "bc0159e1f232b2994f90bfab06507bbdbd612bc8", "commitAfterChange": "4bf0b224a9caf7edd2d827277068ffb2c6e7bf23", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-    /* AW", "-\tint xDisplay = device.xDisplay;", "-\tint xSrcImagePtr = OS.XGetImage(xDisplay, pixmap, 0, 0, width, height, OS.AllPlanes, OS.ZPixmap);", "-\tif (xSrcImagePtr == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-    */", "-    int dd= OS.GetPixDepth(pixmap);", "-    if (dd < 0)", "-    \tdd= 1;", "-\tXImage xSrcImage = new XImage((short)width, (short)height, dd);", "-    /* AW", "-\tOS.memmove(xSrcImage, xSrcImagePtr, XImage.sizeof);", "-    */", "+    int srcDepth= getDepth(pixmap);", "+    int srcRowBytes= rowBytes(width, srcDepth);", "+    int srcBitsPerPixel= srcDepth;", "+", "-\tint length = xSrcImage.bytes_per_line * xSrcImage.height;", "-\tbyte[] srcData = new byte[length];", "-    /* AW", "-\tOS.memmove(srcData, xSrcImage.data, length);", "-    */", "-\tif (OS.copyPixmapData(srcData, pixmap, length) != OS.kNoErr)", "-\t\tSystem.out.println(\"Image.getImageData: copyPixmapData error\");", "+\tbyte[] srcData = new byte[srcRowBytes * height];", "+ \tOS.copyPixmapData(pixmap, srcData);", "-\tswitch (xSrcImage.depth) {", "+\tswitch (srcDepth) {", "-\t\t\tfor (int y = 0; y < xSrcImage.height; y++) {", "-\t\t\t\tfor (int x = 0; x < xSrcImage.bytes_per_line; x++) {", "+\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\tfor (int x = 0; x < srcRowBytes; x++) {", "-\t\t\t\tindex += xSrcImage.bytes_per_line;", "+\t\t\t\tindex += srcRowBytes;", "-            /* AW", "-\t\t\tint colormap = OS.XDefaultColormap(xDisplay, OS.XDefaultScreen(xDisplay));", "-\t\t\t*/", "-\t\t\t/* AW", "-\t\t\tXColor color = new XColor();", "-\t\t\t*/", "-\t\t\t\t\t/*", "-\t\t\t\t\tcolor.pixel = srcPixel;", "-\t\t\t\t\tOS.XQueryColor(xDisplay, colormap, color);", "-\t\t\t\t\t*/", "-\t\t\t\t\t/*", "-\t\t\t\t\trgbs[ rgbIndex ] = new RGB((color.red >> 8) & 0xFF, (color.green >> 8) & 0xFF, (color.blue >> 8) & 0xFF);", "-\t\t\t\t\t*/", "-\t\t\t", "-\t\t\t/*", "-\t\t\t * For some reason, the XImage does not have the mask information.", "-\t\t\t * We must get it from the visual.", "-\t\t\t */", "-            /* AW", "-\t\t\tint visual = OS.XDefaultVisual(xDisplay, OS.XDefaultScreen(xDisplay));", "-\t\t\tVisual v = new Visual();", "-\t\t\tOS.memmove(v, visual, Visual.sizeof);", "-\t\t\tpalette = new PaletteData(v.red_mask, v.green_mask, v.blue_mask);", "-            */", "-\t\t\t// AW assumes Mac", "-\t\t\tpalette = new PaletteData(0x7C00, 0x03E0, 0x001F);", "-\t\t\tbreak;", "-\t\t// AW", "-\t\t// AW", "-\t\t\t/* We always create 24-bit ImageData with the following palette */", "-\t\t\t/* AW", "-\t\t\tpalette = new PaletteData(0xFF, 0xFF00, 0xFF0000);", "-\t\t\t*/", "-\t\t\t// AW assumes Mac", "-\t\t\tpalette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "+\t\t\tpalette = new PaletteData(getRedMask(srcDepth), getGreenMask(srcDepth), getBlueMask(srcDepth));", "-\t\t\tSystem.out.println(\"unsupported depth: \" + xSrcImage.depth);", "-\tImageData data = new ImageData(width, height, xSrcImage.depth, palette);", "+\t", "+\tImageData data = new ImageData(width, height, srcDepth, palette);", "-\tif (false && xSrcImage.bits_per_pixel == 32) {", "+\tif (false && srcBitsPerPixel == 32) {", "-\t\tint bytesPerLine = (xSrcImage.width * xSrcImage.depth + 7) / 8;", "+\t\tint bytesPerLine = (width * srcDepth + 7) / 8;", "-\t\tbyte[] newData = new byte[bytesPerLine * xSrcImage.height];", "+\t\tbyte[] newData = new byte[bytesPerLine * height];", "-\t\tif (xSrcImage.byte_order == OS.MSBFirst) {", "-\t\t\trOffset = 3; gOffset = 2; bOffset = 1;", "-\t\t}", "+\t\t// MSBFirst:", "+\t\trOffset = 3; gOffset = 2; bOffset = 1;", "+\t\t", "-\t\t\tsrcIndex = y * xSrcImage.bytes_per_line;", "+\t\t\tsrcIndex = y * srcRowBytes;", "-        /* AW", "-\t\tint xMaskPtr = OS.XGetImage(xDisplay, mask, 0, 0, width, height, OS.AllPlanes, OS.ZPixmap);", "-\t\tif (xMaskPtr == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\t*/", "-\t\tint ddd= OS.GetPixDepth(mask);", "-\t\t//if (ddd < 0)", "-\t\t\tddd= 1;", "-\t\tXImage xMask = new XImage((short)width, (short)height, ddd);", "-\t\t/* AW", "-\t\tOS.memmove(xMask, xMaskPtr, XImage.sizeof);", "-\t\t*/", "-\t\tdata.maskData = new byte[xMask.bytes_per_line * xMask.height];", "-\t\tif (OS.copyPixmapData(data.maskData, mask, data.maskData.length) != OS.kNoErr)", "-\t\t\tSystem.out.println(\"Image.getImageData: copyPixmapData error\");", "-\t\t/* AW", "-\t\tOS.memmove(data.maskData, xMask.data, data.maskData.length);", "-\t\tOS.XDestroyImage(xMaskPtr);", "-        */", "-\t\t/* Bit swap the mask data if necessary */", "-\t\tif (xMask.bitmap_bit_order == OS.LSBFirst) {", "-\t\t\tbyte[] maskData = data.maskData;", "-\t\t\tfor (int i = 0; i < maskData.length; i++) {", "-\t\t\t\tbyte b = maskData[i];", "-\t\t\t\tmaskData[i] = (byte)(((b & 0x01) << 7) | ((b & 0x02) << 5) |", "-\t\t\t\t\t((b & 0x04) << 3) |\t((b & 0x08) << 1) | ((b & 0x10) >> 1) |", "-\t\t\t\t\t((b & 0x20) >> 3) |\t((b & 0x40) >> 5) | ((b & 0x80) >> 7));", "-\t\t\t}", "-\t\t}", "+\t\tint maskRowBytes= rowBytes(width, getDepth(mask));", "+\t\tdata.maskData = new byte[maskRowBytes * height];", "+\t\tOS.copyPixmapData(mask, data.maskData);", "-    /* AW", "-\tOS.XDestroyImage(xSrcImagePtr);", "-    */"]}], "num": 26408}