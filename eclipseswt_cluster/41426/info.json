{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4d8da670c332b944c2c472d93514405a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b26da13c84d0b472a302306b5414fe8f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Canvas.java", "commitBeforeChange": "c63ca636edfbea4cd55ccc07da414186be375ce0", "commitAfterChange": "e38d4aec3f79c42ea6666a7a37c026187a8aa6ea", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public void scroll (int destX, int destY, int x, int y, int width, int height, boolean all)", "signatureAfterChange": " public void scroll (int destX, int destY, int x, int y, int width, int height, boolean all)", "diff": ["-\tint flags = OS.SW_INVALIDATE | OS.SW_ERASE;", "-\t/*", "-\t* Feature in Windows.  If any child in the widget tree partially", "-\t* intersects the scrolling rectangle, Windows moves the child", "-\t* and copies the bits that intersect the scrolling rectangle but", "-\t* does not redraw the child.", "-\t* ", "-\t* Feature in Windows.  When any child in the widget tree does not", "-\t* intersect the scrolling rectangle but the parent does intersect,", "-\t* Windows does not move the child.  This is the documented (but", "-\t* strange) Windows behavior.", "-\t* ", "-\t* The fix is to not use SW_SCROLLCHILDREN and move the children", "-\t* explicitly after scrolling.  ", "-\t*/", "-//\tif (all) flags |= OS.SW_SCROLLCHILDREN;", "-\tOS.ScrollWindowEx (handle, deltaX, deltaY, sourceRect, null, 0, null, flags);", "+\tif (backgroundImage != null) {", "+\t\tif (OS.IsWinCE) {", "+\t\t\tOS.InvalidateRect (handle, sourceRect, true);", "+\t\t} else {", "+\t\t\tint flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE;", "+\t\t\tif (all) flags |= OS.RDW_ALLCHILDREN;", "+\t\t\tOS.RedrawWindow (handle, sourceRect, 0, flags);", "+\t\t}", "+\t\tOS.OffsetRect (sourceRect, deltaX, deltaY);", "+\t\tif (OS.IsWinCE) {", "+\t\t\tOS.InvalidateRect (handle, sourceRect, true);", "+\t\t} else {", "+\t\t\tint flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE;", "+\t\t\tif (all) flags |= OS.RDW_ALLCHILDREN;", "+\t\t\tOS.RedrawWindow (handle, sourceRect, 0, flags);", "+\t\t}", "+\t} else {", "+\t\tint flags = OS.SW_INVALIDATE | OS.SW_ERASE;", "+\t\t/*", "+\t\t* Feature in Windows.  If any child in the widget tree partially", "+\t\t* intersects the scrolling rectangle, Windows moves the child", "+\t\t* and copies the bits that intersect the scrolling rectangle but", "+\t\t* does not redraw the child.", "+\t\t* ", "+\t\t* Feature in Windows.  When any child in the widget tree does not", "+\t\t* intersect the scrolling rectangle but the parent does intersect,", "+\t\t* Windows does not move the child.  This is the documented (but", "+\t\t* strange) Windows behavior.", "+\t\t* ", "+\t\t* The fix is to not use SW_SCROLLCHILDREN and move the children", "+\t\t* explicitly after scrolling.  ", "+\t\t*/", "+//\t\tif (all) flags |= OS.SW_SCROLLCHILDREN;", "+\t\tOS.ScrollWindowEx (handle, deltaX, deltaY, sourceRect, null, 0, null, flags);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "203cafe201cc7877d88dcab7c38f5bc6", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Canvas.java", "commitBeforeChange": "8bd177cbeb23abde04c3e9a9b26ff34ca214ed1b", "commitAfterChange": "8c4aab30e72216e23f2c03bdb2b40776fb26240c", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public void scroll (int destX, int destY, int x, int y, int width, int height, boolean all)", "signatureAfterChange": " public void scroll (int destX, int destY, int x, int y, int width, int height, boolean all)", "diff": ["-\tRECT rect = new RECT ();", "-\tOS.SetRect (rect, x, y, x + width, y + height);", "+\tRECT lpRect = new RECT ();", "+\tOS.SetRect (lpRect, x, y, x + width, y + height);", "-\tif (all) flags |= OS.SW_SCROLLCHILDREN;", "-\tOS.ScrollWindowEx (handle, deltaX, deltaY, rect, null, 0, null, flags);", "+\t/*", "+\t* Feature in Windows.  If any child in the widget tree partially", "+\t* intersects the scrolling rectangle, Windows moves the child", "+\t* and copies the bits that intersect the scrolling rectangle but", "+\t* does not redraw the child.", "+\t* ", "+\t* Feature in Windows.  When any child in the widget tree does", "+\t* not intersect the scrolling rectangle but the parent does intersect,", "+\t* Windows does not move the child.  This is the documented (but", "+\t* strange) Windows behavior.", "+\t* ", "+\t* The fix is to not use SW_SCROLLCHILDREN and move the children", "+\t* explicitly after scrolling.  ", "+\t*/", "+\t//if (all) flags |= OS.SW_SCROLLCHILDREN;", "+\tOS.ScrollWindowEx (handle, deltaX, deltaY, lpRect, null, 0, null, flags);", "+\tif (all) {", "+\t\tControl [] children = _getChildren ();", "+\t\tfor (int i=0; i<children.length; i++) {", "+\t\t\tControl child = children [i];", "+\t\t\tRectangle rect = child.getBounds ();", "+\t\t\tif (Math.min(x + width, rect.x + rect.width) > Math.max (x, rect.x) && ", "+\t\t\t\tMath.min(y + height, rect.y + rect.height) > Math.max (y, rect.y)) {", "+\t\t\t\t\tchild.setLocation (rect.x + deltaX, rect.y + deltaY);", "+\t\t\t}", "+\t\t}", "+\t}"]}], "num": 41426}