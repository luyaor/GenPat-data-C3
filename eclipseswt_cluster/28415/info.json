{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "433a33e3fcfe98f571f8a752e28d5826", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8d8c23fbf7ec3b9bf7e813308e1dc13c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "80413969c76bb81e4c9325125446456624eddbae", "commitAfterChange": "05b465a405dddfea72f05c981497448f62e6d19c", "methodNumberBeforeChange": 55, "methodNumberAfterChange": 56, "signatureBeforeChange": " public Rectangle getClipping()", "signatureAfterChange": " public Rectangle getClipping()", "diff": ["-\tint[] width = new int[1], height = new int[1];", "-\tOS.gdk_drawable_get_size(data.drawable, width, height);", "+\t/* Calculate visible bounds in device space */", "+\tint x = 0, y = 0, width = 0, height = 0;", "+\tint[] w = new int[1], h = new int[1];", "+\tOS.gdk_drawable_get_size(data.drawable, w, h);", "+\twidth = w[0];", "+\theight = h[0];", "+\t/* Intersect visible bounds with clipping in device space and then convert then to user space */", "+\tint /*long*/ cairo = data.cairo;", "-\tif (clipRgn == 0) {", "-\t\treturn new Rectangle(0, 0, width[0], height[0]);", "-\t} else {", "+\tif (clipRgn != 0 || cairo != 0) {", "-\t\trect.width = width[0];", "-\t\trect.height = height[0];", "+\t\trect.width = width;", "+\t\trect.height = height;", "-\t\tOS.gdk_region_intersect(rgn, clipRgn);", "+\t\t/* Intersect visible bounds with clipping */", "+\t\tif (clipRgn != 0) {", "+\t\t\t/* Convert clipping to device space if needed */", "+\t\t\tif (data.clippingTransform != null) {", "+\t\t\t\tclipRgn = convertRgn(clipRgn, data.clippingTransform);", "+\t\t\t\tOS.gdk_region_intersect(rgn, clipRgn);", "+\t\t\t\tOS.gdk_region_destroy(clipRgn);", "+\t\t\t} else {", "+\t\t\t\tOS.gdk_region_intersect(rgn, clipRgn);", "+\t\t\t}", "+\t\t}", "+\t\t/* Convert to user space */", "+\t\tif (cairo != 0) {", "+\t\t\tdouble[] matrix = new double[6];", "+\t\t\tCairo.cairo_get_matrix(cairo, matrix);", "+\t\t\tCairo.cairo_matrix_invert(matrix);", "+\t\t\tclipRgn = convertRgn(rgn, matrix);", "+\t\t\tOS.gdk_region_destroy(rgn);", "+\t\t\trgn = clipRgn;", "+\t\t}", "-\t\treturn new Rectangle(rect.x, rect.y, rect.width, rect.height);", "+\t\tx = rect.x;", "+\t\ty = rect.y;", "+\t\twidth = rect.width;", "+\t\theight = rect.height;", "+\treturn new Rectangle(x, y, width, height);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3001508a4f004c896f54d10c202a2804", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "05b465a405dddfea72f05c981497448f62e6d19c", "commitAfterChange": "424cc37cc779575a1b43d2c64f6530c100e3a7e7", "methodNumberBeforeChange": 54, "methodNumberAfterChange": 55, "signatureBeforeChange": " public Rectangle getClipping()", "signatureAfterChange": " public Rectangle getClipping()", "diff": ["-\tint[] width = new int[1], height = new int[1], unused = new int[1];", "-\tOS.XGetGeometry(data.display, data.drawable, unused, unused, unused, width, height, unused, unused);", "+\t/* Calculate visible bounds in device space */", "+\tint x = 0, y = 0, width = 0, height = 0;", "+\tint[] w = new int[1], h = new int[1], unused = new int[1];", "+\tOS.XGetGeometry(data.display, data.drawable, unused, unused, unused, w, h, unused, unused);", "+\twidth = w[0];", "+\theight = h[0];", "+\t/* Intersect visible bounds with clipping in device space and then convert then to user space */", "+\tint cairo = data.cairo;", "-\tif (clipRgn == 0) {", "-\t\treturn new Rectangle(0, 0, width[0], height[0]);", "-\t} else {", "+\tif (clipRgn != 0 || cairo != 0) {", "-\t\trect.width = (short)width[0];", "-\t\trect.height = (short)height[0];", "+\t\trect.width = (short)width;", "+\t\trect.height = (short)height;", "-\t\tOS.XIntersectRegion(rgn, clipRgn, rgn);", "+\t\t/* Intersect visible bounds with clipping */", "+\t\tif (clipRgn != 0) {", "+\t\t\t/* Convert clipping to device space if needed */", "+\t\t\tif (data.clippingTransform != null) {", "+\t\t\t\tclipRgn = convertRgn(clipRgn, data.clippingTransform);", "+\t\t\t\tOS.XIntersectRegion(rgn, clipRgn, rgn);", "+\t\t\t\tOS.XDestroyRegion(clipRgn);", "+\t\t\t} else {", "+\t\t\t\tOS.XIntersectRegion(rgn, clipRgn, rgn);", "+\t\t\t}", "+\t\t}", "+\t\t/* Convert to user space */", "+\t\tif (cairo != 0) {", "+\t\t\tdouble[] matrix = new double[6];", "+\t\t\tCairo.cairo_get_matrix(cairo, matrix);", "+\t\t\tCairo.cairo_matrix_invert(matrix);", "+\t\t\tclipRgn = convertRgn(rgn, matrix);", "+\t\t\tOS.XDestroyRegion(rgn);", "+\t\t\trgn = clipRgn;", "+\t\t}", "-\t\treturn new Rectangle(rect.x, rect.y, rect.width, rect.height);", "+\t\tx = rect.x;", "+\t\ty = rect.y;", "+\t\twidth = rect.width;", "+\t\theight = rect.height;", "+\treturn new Rectangle(x, y, width, height);"]}], "num": 28415}