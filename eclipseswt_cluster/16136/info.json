{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "08be230b22efddb7b1a0fd9c93c4ef12", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d3ce95bd49f6af9d9fe6c5ac88527c67", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Cursor.java", "commitBeforeChange": "5257fe3e5c2382bbc3b51c5d746acb8fd1eb464e", "commitAfterChange": "be37fa819811929900e5dcf4ba355cc550991316", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": " public Cursor(Device device, ImageData source, int hotspotX, int hotspotY)", "signatureAfterChange": " public Cursor(Device device, ImageData source, int hotspotX, int hotspotY)", "diff": ["+", "+\tif (OS.VERSION >= 0x1040) {", "+\t\tbyte[] data = new byte[source.width * source.height * 4];", "+\t\tPaletteData palette = source.palette;", "+\t\tif (palette.isDirect) {", "+\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, palette.redMask, palette.greenMask, palette.blueMask,", "+\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0, ", "+\t\t\t\tdata, 32, source.width * 4, ImageData.MSB_FIRST, 0, 0, source.width, source.height, 0xFF0000, 0xFF00, 0xFF,", "+\t\t\t\tfalse, false);", "+\t\t} else {", "+\t\t\tRGB[] rgbs = palette.getRGBs();", "+\t\t\tint length = rgbs.length;", "+\t\t\tbyte[] srcReds = new byte[length];", "+\t\t\tbyte[] srcGreens = new byte[length];", "+\t\t\tbyte[] srcBlues = new byte[length];", "+\t\t\tfor (int i = 0; i < rgbs.length; i++) {", "+\t\t\t\tRGB rgb = rgbs[i];", "+\t\t\t\tif (rgb == null) continue;", "+\t\t\t\tsrcReds[i] = (byte)rgb.red;", "+\t\t\t\tsrcGreens[i] = (byte)rgb.green;", "+\t\t\t\tsrcBlues[i] = (byte)rgb.blue;", "+\t\t\t}", "+\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, srcReds, srcGreens, srcBlues,", "+\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "+\t\t\t\tdata, 32, source.width * 4, ImageData.MSB_FIRST, 0, 0, source.width, source.height, 0xFF0000, 0xFF00, 0xFF,", "+\t\t\t\tfalse, false);", "+\t\t}", "+\t\tif (source.maskData != null || source.transparentPixel != -1) {", "+\t\t\tImageData mask = source.getTransparencyMask();", "+\t\t\tbyte[] maskData = mask.data;", "+\t\t\tint maskBpl = mask.bytesPerLine;", "+\t\t\tint offset = 0, maskOffset = 0;", "+\t\t\tfor (int y = 0; y<source.height; y++) {", "+\t\t\t\tfor (int x = 0; x<source.width; x++) {", "+\t\t\t\t\tdata[offset] = ((maskData[maskOffset + (x >> 3)]) & (1 << (7 - (x & 0x7)))) != 0 ? (byte)0xff : 0;", "+\t\t\t\t\toffset += 4;", "+\t\t\t\t}", "+\t\t\t\tmaskOffset += maskBpl;", "+\t\t\t}", "+\t\t} else if (source.alpha != -1) {", "+\t\t\tbyte alpha = (byte)source.alpha;", "+\t\t\tfor (int i=0; i<data.length; i+=4) {", "+\t\t\t\tdata[i] = alpha;\t\t\t\t", "+\t\t\t}", "+\t\t} else if (source.alphaData != null) {", "+\t\t\tbyte[] alphaData = source.alphaData;", "+\t\t\tfor (int i=0; i<data.length; i+=4) {", "+\t\t\t\tdata[i] = alphaData[i/4];", "+\t\t\t}", "+\t\t}", "+\t\tcreateNSCursor(device, hotspotX, hotspotY, data, source.width, source.height);", "+\t\treturn;", "+\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "11eda6aec66d181ea1fd9fdaeb5f54a3", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/Cursor.java", "commitBeforeChange": "21adea3406a745f3b5dd9a42716b4efd0fc29227", "commitAfterChange": "845cd3662a4fd50dc772f1cb398e102a7c633b87", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public Cursor(Device device, ImageData source, int hotspotX, int hotspotY)", "signatureAfterChange": " public Cursor(Device device, ImageData source, int hotspotX, int hotspotY)", "diff": ["-\tImageData mask = source.getTransparencyMask();", "-\tint /*long*/ [] result = Image.init(this.device, null, source, mask);", "-\tint /*long*/ hBitmap = result[0];", "-\tint /*long*/ hMask = result[1];", "+\tint /*long*/ hBitmap = 0;", "+\tint /*long*/ hMask = 0;", "+\tif (source.maskData == null && source.transparentPixel == -1 && (source.alpha != -1 || source.alphaData != null)) {", "+\t\tPaletteData palette = source.palette;", "+\t\tPaletteData newPalette = new PaletteData(0xFF00, 0xFF0000, 0xFF000000);", "+\t\tImageData img = new ImageData(source.width, source.height, 32, newPalette);", "+\t\tif (palette.isDirect) {", "+\t\t\tImageData.blit(ImageData.BLIT_SRC, ", "+\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, palette.redMask, palette.greenMask, palette.blueMask,", "+\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "+\t\t\t\timg.data, img.depth, img.bytesPerLine, img.getByteOrder(), 0, 0, img.width, img.height, newPalette.redMask, newPalette.greenMask, newPalette.blueMask,", "+\t\t\t\tfalse, false);", "+\t\t} else {", "+\t\t\tRGB[] rgbs = palette.getRGBs();", "+\t\t\tint length = rgbs.length;", "+\t\t\tbyte[] srcReds = new byte[length];", "+\t\t\tbyte[] srcGreens = new byte[length];", "+\t\t\tbyte[] srcBlues = new byte[length];", "+\t\t\tfor (int i = 0; i < rgbs.length; i++) {", "+\t\t\t\tRGB rgb = rgbs[i];", "+\t\t\t\tif (rgb == null) continue;", "+\t\t\t\tsrcReds[i] = (byte)rgb.red;", "+\t\t\t\tsrcGreens[i] = (byte)rgb.green;", "+\t\t\t\tsrcBlues[i] = (byte)rgb.blue;", "+\t\t\t}", "+\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, srcReds, srcGreens, srcBlues,", "+\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "+\t\t\t\timg.data, img.depth, img.bytesPerLine, img.getByteOrder(), 0, 0, img.width, img.height, newPalette.redMask, newPalette.greenMask, newPalette.blueMask,", "+\t\t\t\tfalse, false);", "+\t\t}", "+\t\thBitmap = Image.createDIB(source.width, source.height, 32);", "+\t\tif (hBitmap == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\tBITMAP dibBM = new BITMAP();", "+\t\tOS.GetObject(hBitmap, BITMAP.sizeof, dibBM);", "+\t\tbyte[] srcData = img.data;", "+\t\tif (source.alpha != -1) {", "+\t\t\tfor (int i = 3, ap=0; i < srcData.length; i+=4, ap++) {", "+\t\t\t\tsrcData[i] = (byte)source.alpha;", "+\t\t\t}", "+\t\t} else if (source.alphaData != null) {", "+\t\t\tfor (int sp = 3, ap=0; sp < srcData.length; sp+=4, ap++) {", "+\t\t\t\tsrcData[sp] = source.alphaData[ap];", "+\t\t\t}", "+\t\t}", "+\t\tOS.MoveMemory(dibBM.bmBits, srcData, srcData.length);", "+\t\thMask = OS.CreateBitmap(source.width, source.height, 1, 1, new byte[(((source.width + 7) / 8) + 3) / 4 * 4 * source.height]);", "+\t\tif (hMask == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t} else {", "+\t\tImageData mask = source.getTransparencyMask();", "+\t\tint /*long*/ [] result = Image.init(this.device, null, source, mask);", "+\t\thBitmap = result[0];", "+\t\thMask = result[1];", "+\t}", "-\tif (handle == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\tif (handle == 0) SWT.error(SWT.ERROR_NO_HANDLES);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "460574bcbaaff0ea65f326938fb40c1e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Cursor.java", "commitBeforeChange": "80349400ab803a052b05e2e66d42920450d869b7", "commitAfterChange": "3c08b8580835d1415ee214b2ea3d595c752fb587", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public Cursor(Device device, ImageData source, int hotspotX, int hotspotY)", "signatureAfterChange": " public Cursor(Device device, ImageData source, int hotspotX, int hotspotY)", "diff": ["-\tImageData mask = source.getTransparencyMask();", "-", "-\t/* Ensure depth is equal to 1 */", "-\tif (source.depth > 1) {", "-\t\t/* Create a destination image with no data */", "-\t\tImageData newSource = new ImageData(", "-\t\t\tsource.width, source.height, 1, ImageData.bwPalette(),", "-\t\t\t1, null, 0, null, null, -1, -1, 0, 0, 0, 0, 0);", "-", "-\t\tbyte[] newReds = new byte[]{0, (byte)255}, newGreens = newReds, newBlues = newReds;", "-", "-\t\t/* Convert the source to a black and white image of depth 1 */", "-\t\tPaletteData palette = source.palette;", "-\t\tif (palette.isDirect) {", "-\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\tint /*long*/ display = 0;", "+\tif (OS.GTK_VERSION >= OS.VERSION(2, 4, 0) && OS.gdk_display_supports_cursor_color(display = OS.gdk_display_get_default ())) {", "+\t\tint width = source.width;", "+\t\tint height = source.height;", "+\t\tPaletteData palette = source.palette;\t", "+\t\tint /*long*/ pixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, true, 8, width, height);", "+\t\tif (pixbuf == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "+\t\tint /*long*/ data = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\tbyte[] buffer = source.data;", "+\t\tif (!palette.isDirect || source.depth != 24 || stride != source.bytesPerLine || palette.redMask != 0xFF000000 || palette.greenMask != 0xFF0000 || palette.blueMask != 0xFF00) {", "+\t\t\tbuffer = new byte[source.width * source.height * 4];", "+\t\t\tif (palette.isDirect) {", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "-\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "-\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "+\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0, ", "+\t\t\t\t\tbuffer, 32, source.width * 4, ImageData.MSB_FIRST, 0, 0, source.width, source.height, 0xFF000000, 0xFF0000, 0xFF00,", "-\t\t} else {", "-\t\t\tRGB[] rgbs = palette.getRGBs();", "-\t\t\tint length = rgbs.length;", "-\t\t\tbyte[] srcReds = new byte[length];", "-\t\t\tbyte[] srcGreens = new byte[length];", "-\t\t\tbyte[] srcBlues = new byte[length];", "-\t\t\tfor (int i = 0; i < rgbs.length; i++) {", "-\t\t\t\tRGB rgb = rgbs[i];", "-\t\t\t\tif (rgb == null) continue;", "-\t\t\t\tsrcReds[i] = (byte)rgb.red;", "-\t\t\t\tsrcGreens[i] = (byte)rgb.green;", "-\t\t\t\tsrcBlues[i] = (byte)rgb.blue;", "-\t\t\t}", "-\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t} else {", "+\t\t\t\tRGB[] rgbs = palette.getRGBs();", "+\t\t\t\tint length = rgbs.length;", "+\t\t\t\tbyte[] srcReds = new byte[length];", "+\t\t\t\tbyte[] srcGreens = new byte[length];", "+\t\t\t\tbyte[] srcBlues = new byte[length];", "+\t\t\t\tfor (int i = 0; i < rgbs.length; i++) {", "+\t\t\t\t\tRGB rgb = rgbs[i];", "+\t\t\t\t\tif (rgb == null) continue;", "+\t\t\t\t\tsrcReds[i] = (byte)rgb.red;", "+\t\t\t\t\tsrcGreens[i] = (byte)rgb.green;", "+\t\t\t\t\tsrcBlues[i] = (byte)rgb.blue;", "+\t\t\t\t}", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "-\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "+\t\t\t\t\tbuffer, 32, source.width * 4, ImageData.MSB_FIRST, 0, 0, source.width, source.height, 0xFF000000, 0xFF0000, 0xFF00,", "+\t\t\t}", "+\t\t\tif (source.maskData != null || source.transparentPixel != -1) {", "+\t\t\t\tImageData mask = source.getTransparencyMask();", "+\t\t\t\tbyte[] maskData = mask.data;", "+\t\t\t\tint maskBpl = mask.bytesPerLine;", "+\t\t\t\tint offset = 3, maskOffset = 0;", "+\t\t\t\tfor (int y = 0; y<source.height; y++) {", "+\t\t\t\t\tfor (int x = 0; x<source.width; x++) {", "+\t\t\t\t\t\tbuffer[offset] = ((maskData[maskOffset + (x >> 3)]) & (1 << (7 - (x & 0x7)))) != 0 ? (byte)0xff : 0;", "+\t\t\t\t\t\toffset += 4;", "+\t\t\t\t\t}", "+\t\t\t\t\tmaskOffset += maskBpl;", "+\t\t\t\t}", "+\t\t\t} else if (source.alpha != -1) {", "+\t\t\t\tbyte alpha = (byte)source.alpha;", "+\t\t\t\tfor (int i=3; i<buffer.length; i+=4) {", "+\t\t\t\t\tbuffer[i] = alpha;\t\t\t\t", "+\t\t\t\t}", "+\t\t\t} else if (source.alphaData != null) {", "+\t\t\t\tbyte[] alphaData = source.alphaData;", "+\t\t\t\tfor (int i=3; i<buffer.length; i+=4) {", "+\t\t\t\t\tbuffer[i] = alphaData[i/4];", "+\t\t\t\t}", "+\t\t\t}", "-\t\tsource = newSource;", "+\t\tOS.memmove(data, buffer, stride * height);", "+\t\thandle = OS.gdk_cursor_new_from_pixbuf(display, pixbuf, hotspotX, hotspotY);", "+\t\tOS.g_object_unref(pixbuf);", "+\t} else {", "+\t", "+\t\tImageData mask = source.getTransparencyMask();", "+\t", "+\t\t/* Ensure depth is equal to 1 */", "+\t\tif (source.depth > 1) {", "+\t\t\t/* Create a destination image with no data */", "+\t\t\tImageData newSource = new ImageData(", "+\t\t\t\tsource.width, source.height, 1, ImageData.bwPalette(),", "+\t\t\t\t1, null, 0, null, null, -1, -1, 0, 0, 0, 0, 0);", "+\t", "+\t\t\tbyte[] newReds = new byte[]{0, (byte)255}, newGreens = newReds, newBlues = newReds;", "+\t", "+\t\t\t/* Convert the source to a black and white image of depth 1 */", "+\t\t\tPaletteData palette = source.palette;", "+\t\t\tif (palette.isDirect) {", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, palette.redMask, palette.greenMask, palette.blueMask,", "+\t\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "+\t\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "+\t\t\t\t\t\tfalse, false);", "+\t\t\t} else {", "+\t\t\t\tRGB[] rgbs = palette.getRGBs();", "+\t\t\t\tint length = rgbs.length;", "+\t\t\t\tbyte[] srcReds = new byte[length];", "+\t\t\t\tbyte[] srcGreens = new byte[length];", "+\t\t\t\tbyte[] srcBlues = new byte[length];", "+\t\t\t\tfor (int i = 0; i < rgbs.length; i++) {", "+\t\t\t\t\tRGB rgb = rgbs[i];", "+\t\t\t\t\tif (rgb == null) continue;", "+\t\t\t\t\tsrcReds[i] = (byte)rgb.red;", "+\t\t\t\t\tsrcGreens[i] = (byte)rgb.green;", "+\t\t\t\t\tsrcBlues[i] = (byte)rgb.blue;", "+\t\t\t\t}", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, srcReds, srcGreens, srcBlues,", "+\t\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "+\t\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "+\t\t\t\t\t\tfalse, false);", "+\t\t\t}", "+\t\t\tsource = newSource;", "+\t\t}", "+\t", "+\t\t/* Swap the bits in each byte and convert to appropriate scanline pad */", "+\t\tbyte[] sourceData = new byte[source.data.length];", "+\t\tbyte[] maskData = new byte[mask.data.length];", "+\t\tbyte[] data = source.data;", "+\t\tfor (int i = 0; i < data.length; i++) {", "+\t\t\tbyte s = data[i];", "+\t\t\tsourceData[i] = (byte)(((s & 0x80) >> 7) |", "+\t\t\t\t((s & 0x40) >> 5) |", "+\t\t\t\t((s & 0x20) >> 3) |", "+\t\t\t\t((s & 0x10) >> 1) |", "+\t\t\t\t((s & 0x08) << 1) |", "+\t\t\t\t((s & 0x04) << 3) |", "+\t\t\t\t((s & 0x02) << 5) |", "+\t\t\t\t((s & 0x01) << 7));", "+\t\t}", "+\t\tsourceData = ImageData.convertPad(sourceData, source.width, source.height, source.depth, source.scanlinePad, 1);", "+\t\tdata = mask.data;", "+\t\tfor (int i = 0; i < data.length; i++) {", "+\t\t\tbyte s = data[i];", "+\t\t\tmaskData[i] = (byte)(((s & 0x80) >> 7) |", "+\t\t\t\t((s & 0x40) >> 5) |", "+\t\t\t\t((s & 0x20) >> 3) |", "+\t\t\t\t((s & 0x10) >> 1) |", "+\t\t\t\t((s & 0x08) << 1) |", "+\t\t\t\t((s & 0x04) << 3) |", "+\t\t\t\t((s & 0x02) << 5) |", "+\t\t\t\t((s & 0x01) << 7));", "+\t\t}", "+\t\tmaskData = ImageData.convertPad(maskData, mask.width, mask.height, mask.depth, mask.scanlinePad, 1);", "+\t\thandle = createCursor(sourceData, maskData, source.width, source.height, hotspotX, hotspotY, false);", "-", "-\t/* Swap the bits in each byte and convert to appropriate scanline pad */", "-\tbyte[] sourceData = new byte[source.data.length];", "-\tbyte[] maskData = new byte[mask.data.length];", "-\tbyte[] data = source.data;", "-\tfor (int i = 0; i < data.length; i++) {", "-\t\tbyte s = data[i];", "-\t\tsourceData[i] = (byte)(((s & 0x80) >> 7) |", "-\t\t\t((s & 0x40) >> 5) |", "-\t\t\t((s & 0x20) >> 3) |", "-\t\t\t((s & 0x10) >> 1) |", "-\t\t\t((s & 0x08) << 1) |", "-\t\t\t((s & 0x04) << 3) |", "-\t\t\t((s & 0x02) << 5) |", "-\t\t\t((s & 0x01) << 7));", "-\t}", "-\tsourceData = ImageData.convertPad(sourceData, source.width, source.height, source.depth, source.scanlinePad, 1);", "-\tdata = mask.data;", "-\tfor (int i = 0; i < data.length; i++) {", "-\t\tbyte s = data[i];", "-\t\tmaskData[i] = (byte)(((s & 0x80) >> 7) |", "-\t\t\t((s & 0x40) >> 5) |", "-\t\t\t((s & 0x20) >> 3) |", "-\t\t\t((s & 0x10) >> 1) |", "-\t\t\t((s & 0x08) << 1) |", "-\t\t\t((s & 0x04) << 3) |", "-\t\t\t((s & 0x02) << 5) |", "-\t\t\t((s & 0x01) << 7));", "-\t}", "-\tmaskData = ImageData.convertPad(maskData, mask.width, mask.height, mask.depth, mask.scanlinePad, 1);", "-\thandle = createCursor(sourceData, maskData, source.width, source.height, hotspotX, hotspotY, false);"]}], "num": 16136}