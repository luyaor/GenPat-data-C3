{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c6a0f5466dda3054e8c6991fc6ecee88", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a8e3380ef79fbf08ffc7ff1e7e4b915b", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/CTabFolder.java", "commitBeforeChange": "2cef3fa78da7f2885ce55fa509348982e00b2225", "commitAfterChange": "bbeab947327689cb203638e742e58f555e6c1b64", "methodNumberBeforeChange": 81, "methodNumberAfterChange": 60, "signatureBeforeChange": " private void onMouseMove(Event event)", "signatureAfterChange": " void onMouse(Event event)", "diff": ["+}", "+void onMouse(Event event) {", "+\tint x = event.x, y = event.y;", "+\tswitch (event.type) {", "+\t\tcase SWT.MouseExit: {", "+\t\t\tif (minImageState != NORMAL) {", "+\t\t\t\tminImageState = NORMAL;", "+\t\t\t\tredraw(minRect.x, minRect.y, minRect.width, minRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t}", "+\t\t\tif (maxImageState != NORMAL) {", "+\t\t\t\tmaxImageState = NORMAL;", "+\t\t\t\tredraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t}", "+\t\t\tif (chevronImageState != NORMAL) {", "+\t\t\t\tchevronImageState = NORMAL;", "+\t\t\t\tredraw(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t}", "+\t\t\tfor (int i=0; i<items.length; i++) {", "+\t\t\t\tCTabItem item = items[i];", "+\t\t\t\tif (i != selectedIndex && item.closeImageState != NONE) {", "+\t\t\t\t\titem.closeImageState = NONE;", "+\t\t\t\t\tredraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);", "+\t\t\t\t\tupdate();", "+\t\t\t\t}", "+\t\t\t\tif (i == selectedIndex && item.closeImageState != NORMAL) {", "+\t\t\t\t\titem.closeImageState = NORMAL;", "+\t\t\t\t\tredraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);", "+\t\t\t\t\tupdate();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbreak;", "+\t\t}", "+\t\tcase SWT.MouseDown: {", "+\t\t\tif (minRect.contains(x, y)) {", "+\t\t\t\tif (event.button != 1) return;", "+\t\t\t\tminImageState = SELECTED;", "+\t\t\t\tredraw(minRect.x, minRect.y, minRect.width, minRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tif (maxRect.contains(x, y)) {", "+\t\t\t\tif (event.button != 1) return;", "+\t\t\t\tmaxImageState = SELECTED;", "+\t\t\t\tredraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tif (chevronRect.contains(x, y)) {", "+\t\t\t\tif (event.button != 1) return;", "+\t\t\t\tchevronImageState = SELECTED;", "+\t\t\t\tredraw(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tfor (int i=0; i<items.length; i++) {", "+\t\t\t\tCTabItem item = items[i];", "+\t\t\t\tRectangle bounds = item.getBounds();", "+\t\t\t\tif (item.closeRect.contains(x,y)){", "+\t\t\t\t\tif (event.button != 1) return;", "+\t\t\t\t\titem.closeImageState = SELECTED;", "+\t\t\t\t\tredraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);", "+\t\t\t\t\tupdate();", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t\tif (bounds.contains(x, y)) {", "+\t\t\t\t\tif (!single && i != topTabIndex && bounds.x + bounds.width >= getRightItemEdge())return;", "+\t\t\t\t\tsetSelection(i, true);", "+\t\t\t\t\tsetFocus();", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbreak;", "+\t\t}", "+\t\tcase SWT.MouseMove: {", "+\t\t\tboolean close = false, minimize = false, maximize = false, chevron = false;", "+\t\t\tif (minRect.contains(x, y)) {", "+\t\t\t\tminimize = true;", "+\t\t\t\tif (minImageState != HOT) {", "+\t\t\t\t\tminImageState = HOT;", "+\t\t\t\t\tredraw(minRect.x, minRect.y, minRect.width, minRect.height, false);", "+\t\t\t\t\tupdate();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (maxRect.contains(x, y)) {", "+\t\t\t\tmaximize = true;", "+\t\t\t\tif (maxImageState != HOT) {", "+\t\t\t\t\tmaxImageState = HOT;", "+\t\t\t\t\tredraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);", "+\t\t\t\t\tupdate();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (chevronRect.contains(x, y)) {", "+\t\t\t\tchevron = true;", "+\t\t\t\tif (chevronImageState != HOT) {", "+\t\t\t\t\tchevronImageState = HOT;", "+\t\t\t\t\tredraw(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, false);", "+\t\t\t\t\tupdate();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (minImageState == HOT && !minimize) {", "+\t\t\t\tminImageState = NORMAL;", "+\t\t\t\tredraw(minRect.x, minRect.y, minRect.width, minRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t}", "+\t\t\tif (maxImageState == HOT && !maximize) {", "+\t\t\t\tmaxImageState = NORMAL;", "+\t\t\t\tredraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t}", "+\t\t\tif (chevronImageState == HOT && !chevron) {", "+\t\t\t\tchevronImageState = NORMAL;", "+\t\t\t\tredraw(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t}", "+\t\t\tfor (int i=0; i<items.length; i++) {", "+\t\t\t\tCTabItem item = items[i];", "+\t\t\t\tclose = false;", "+\t\t\t\tif (item.getBounds().contains(x, y)) {", "+\t\t\t\t\tclose = true;", "+\t\t\t\t\tif (item.closeRect.contains(x, y)) {", "+\t\t\t\t\t\tif (item.closeImageState != HOT) {", "+\t\t\t\t\t\t\titem.closeImageState = HOT;", "+\t\t\t\t\t\t\tredraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);", "+\t\t\t\t\t\t\tupdate();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (item.closeImageState != NORMAL) {", "+\t\t\t\t\t\t\titem.closeImageState = NORMAL;", "+\t\t\t\t\t\t\tredraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);", "+\t\t\t\t\t\t\tupdate();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} ", "+\t\t\t\tif (i != selectedIndex && item.closeImageState != NONE && !close) {", "+\t\t\t\t\titem.closeImageState = NONE;", "+\t\t\t\t\tredraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);", "+\t\t\t\t\tupdate();", "+\t\t\t\t}", "+\t\t\t\tif (i == selectedIndex && item.closeImageState != NORMAL && !close) {", "+\t\t\t\t\titem.closeImageState = NORMAL;", "+\t\t\t\t\tredraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);", "+\t\t\t\t\tupdate();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbreak;", "+\t\t}", "+\t\tcase SWT.MouseUp: {", "+\t\t\tif (event.button != 1) return;", "+\t\t\tif (chevronRect.contains(x, y)) {", "+\t\t\t\tboolean selected = chevronImageState == SELECTED;", "+\t\t\t\tchevronImageState = HOT;", "+\t\t\t\tredraw(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t\tif (!selected) return;", "+\t\t\t\tRectangle rect = new Rectangle(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height);", "+\t\t\t\tif (single && selectedIndex != -1){", "+\t\t\t\t\trect = items[selectedIndex].getBounds();\t", "+\t\t\t\t}", "+\t\t\t\trect.y += onBottom ? -HIGHLIGHT_HEADER :HIGHLIGHT_HEADER;", "+\t\t\t\tif (listListeners.length == 0) {", "+\t\t\t\t\tshowList(rect, single ? SWT.LEFT : SWT.RIGHT);", "+\t\t\t\t} else {", "+\t\t\t\t\tCTabFolderEvent e = new CTabFolderEvent(this);", "+\t\t\t\t\te.widget = this;", "+\t\t\t\t\te.time = event.time;", "+\t\t\t\t\te.rect = rect;", "+\t\t\t\t\t", "+\t\t\t\t\tfor (int i = 0; i < listListeners.length; i++) {", "+\t\t\t\t\t\tlistListeners[i].showList(e);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tif (minRect.contains(x, y)) {", "+\t\t\t\tboolean selected = minImageState == SELECTED;", "+\t\t\t\tminImageState = HOT;", "+\t\t\t\tredraw(minRect.x, minRect.y, minRect.width, minRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t\tif (!selected) return;", "+\t\t\t\tCTabFolderEvent e = new CTabFolderEvent(this);", "+\t\t\t\te.widget = this;", "+\t\t\t\te.time = event.time;", "+\t\t\t\te.doit = true;", "+\t\t\t\tboolean restore = minimized;", "+\t\t\t\tfor (int i = 0; i < minmaxListeners.length; i++) {", "+\t\t\t\t\tif (restore) {", "+\t\t\t\t\t\tminmaxListeners[i].restore(e);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tminmaxListeners[i].minimize(e);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (e.doit && !isDisposed()) setMinimized(!restore);", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tif (maxRect.contains(x, y)) {", "+\t\t\t\tboolean selected = maxImageState == SELECTED;", "+\t\t\t\tmaxImageState = HOT;", "+\t\t\t\tredraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);", "+\t\t\t\tupdate();", "+\t\t\t\tif (!selected) return;", "+\t\t\t\tCTabFolderEvent e = new CTabFolderEvent(this);", "+\t\t\t\te.widget = this;", "+\t\t\t\te.time = event.time;", "+\t\t\t\te.doit = true;", "+\t\t\t\tboolean restore = maximized;", "+\t\t\t\tfor (int i = 0; i < minmaxListeners.length; i++) {", "+\t\t\t\t\tif (restore) {", "+\t\t\t\t\t\tminmaxListeners[i].restore(e);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tminmaxListeners[i].maximize(e);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (e.doit && !isDisposed()) setMaximized(!restore);", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tfor (int i=0; i<items.length; i++) {", "+\t\t\t\tCTabItem item = items[i];", "+\t\t\t\tif (item.closeRect.contains(x,y)){", "+\t\t\t\t\tboolean selected = item.closeImageState == SELECTED;", "+\t\t\t\t\titem.closeImageState = HOT;", "+\t\t\t\t\tredraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);", "+\t\t\t\t\tupdate();", "+\t\t\t\t\tif (!selected) return;", "+\t\t\t\t\tCTabFolderEvent e = new CTabFolderEvent(this);", "+\t\t\t\t\te.widget = this;", "+\t\t\t\t\te.time = event.time;", "+\t\t\t\t\te.item = item;", "+\t\t\t\t\te.doit = true;", "+\t\t\t\t\tfor (int j = 0; j < closeListeners.length; j++) {", "+\t\t\t\t\t\tcloseListeners[j].itemClosed(e);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (e.doit) item.dispose();", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+}", "-private void onMouseMove(Event event) {", "-\tif (showToolTip) {", "-\t\tshowToolTip(event.x, event.y);", "-\t}", "-\t", "-\tif (!showClose) return;", "-\t", "-\tCTabItem item = null;", "-\tfor (int i=0; i<items.length; i++) {", "-\t\tRectangle rect = items[i].getBounds();", "-\t\tif (rect.contains(new Point(event.x, event.y))) {", "-\t\t\titem = items[i];", "-\t\t\tbreak;", "-\t\t}", "-\t}", "-\tif (item == inactiveItem) return;", "-\t", "-\tinactiveCloseBar.setVisible(false);", "-\tinactiveItem = null;", "-\t\t", "-\tif (item == null || item == getSelection()) return;", "-", "-\tint toolbarHeight = tabHeight - CTabItem.TOP_MARGIN - CTabItem.BOTTOM_MARGIN + 2; // +2 to ignore gap between focus rectangle", "-\tPoint size = inactiveCloseBar.computeSize(SWT.DEFAULT, toolbarHeight);", "-\tint x = item.x + item.width - size.x - 2; // -2 to not overlap focus rectangle and trim", "-\tint y = item.y + Math.max(0, (item.height - toolbarHeight)/2);", "-\tRectangle toolspace = getToolSpace();", "-\tPoint folderSize = getSize();", "-\tif ((toolspace.width == 0 || x < toolspace.x) && x + size.x < folderSize.x - borderRight) {", "-\t\tinactiveCloseBar.setBounds(x, y, size.x, toolbarHeight);", "-\t\tinactiveCloseBar.setVisible(true);", "-\t\tinactiveItem = item;", "-\t}", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94134bc106b5772438e9adf2e04dd4be", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "6fe853b29d6dcedf69f8209e4b19fa3cf0a85a8b", "commitAfterChange": "cc7a79cec8920b1b6175a6c2124e7f63a3823262", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 90, "signatureBeforeChange": "  LRESULT wmNotifyChild (int wParam, int lParam)", "signatureAfterChange": "  LRESULT wmNotifyChild (int wParam, int lParam)", "diff": ["-\tint code = hdr.code;", "-\tswitch (code) {", "+\tswitch (hdr.code) {", "+\t\tcase OS.TVN_GETDISPINFOA:", "+\t\tcase OS.TVN_GETDISPINFOW: {", "+\t\t\tNMTVDISPINFO lptvdi = new NMTVDISPINFO ();", "+\t\t\tOS.MoveMemory (lptvdi, lParam, NMTVDISPINFO.sizeof);", "+\t\t\t/*", "+\t\t\t* Feature in Windows.  When a new tree item is inserted", "+\t\t\t* using TVM_INSERTITEM, a TVN_GETDISPINFO is sent before", "+\t\t\t* TVM_INSERTITEM returns and before the item is added to", "+\t\t\t* the items array.  The fix is to check for null.", "+\t\t\t* ", "+\t\t\t* NOTE: This only happens on XP with the version 6.00 of", "+\t\t\t* COMCTL32.DLL,", "+\t\t\t*/", "+\t\t\tif (items == null) break;", "+\t\t\tTreeItem item = items [lptvdi.lParam];", "+\t\t\tif (item == null) break;", "+\t\t\tif ((lptvdi.mask & OS.TVIF_TEXT) != 0) {", "+\t\t\t\tString string = item.text;", "+\t\t\t\tTCHAR buffer = new TCHAR (getCodePage (), string, false);", "+\t\t\t\tint byteCount = Math.min (buffer.length (), lptvdi.cchTextMax - 1) * TCHAR.sizeof;", "+\t\t\t\tOS.MoveMemory (lptvdi.pszText, buffer, byteCount);", "+\t\t\t\tOS.MoveMemory (lptvdi.pszText + byteCount, new byte [TCHAR.sizeof], TCHAR.sizeof);", "+\t\t\t\tlptvdi.cchTextMax = Math.min (lptvdi.cchTextMax, string.length () + 1);", "+\t\t\t}", "+\t\t\tif ((lptvdi.mask & (OS.TVIF_IMAGE | OS.TVIF_SELECTEDIMAGE)) != 0) {", "+\t\t\t\tImage image = item.image;", "+\t\t\t\tlptvdi.iImage = OS.I_IMAGENONE;", "+\t\t\t\tif (image != null) {", "+\t\t\t\t\tlptvdi.iImage = lptvdi.iSelectedImage = imageIndex (image);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tOS.MoveMemory (lParam, lptvdi, NMTVDISPINFO.sizeof);", "+\t\t\tbreak;", "+\t\t}", "-\t\t\t\tcase OS.CDDS_PREPAINT: return new LRESULT (OS.CDRF_NOTIFYITEMDRAW);", "-\t\t\t\tcase OS.CDDS_ITEMPREPAINT:", "+\t\t\t\tcase OS.CDDS_PREPAINT: {", "+\t\t\t\t\treturn new LRESULT (OS.CDRF_NOTIFYITEMDRAW | OS.CDRF_NOTIFYPOSTPAINT);", "+\t\t\t\t}", "+\t\t\t\tcase OS.CDDS_POSTPAINT: {", "+\t\t\t\t\tif (linesVisible) {", "+\t\t\t\t\t\tint hDC = nmcd.hdc;", "+\t\t\t\t\t\tif (hwndHeader != 0) {", "+\t\t\t\t\t\t\tint x = 0;", "+\t\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\t\tHDITEM hdItem = new HDITEM ();", "+\t\t\t\t\t\t\thdItem.mask = OS.HDI_WIDTH;", "+\t\t\t\t\t\t\tint count = OS.SendMessage (hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);", "+\t\t\t\t\t\t\tfor (int i=0; i<count; i++) {", "+\t\t\t\t\t\t\t\tOS.SendMessage (hwndHeader, OS.HDM_GETITEM, i, hdItem);", "+\t\t\t\t\t\t\t\tOS.SetRect (rect, x, nmcd.top, x + hdItem.cxy, nmcd.bottom);", "+\t\t\t\t\t\t\t\tOS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_RIGHT);", "+\t\t\t\t\t\t\t\tx += hdItem.cxy;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\tint hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_LASTVISIBLE, 0);", "+\t\t\t\t\t\trect.left = hItem;", "+\t\t\t\t\t\tif (OS.SendMessage (handle, OS.TVM_GETITEMRECT, 0, rect) != 0) {", "+\t\t\t\t\t\t\tint height = rect.bottom - rect.top;", "+\t\t\t\t\t\t\twhile (rect.bottom < nmcd.bottom) {", "+\t\t\t\t\t\t\t\tint top = rect.top + height;", "+\t\t\t\t\t\t\t\tOS.SetRect (rect, rect.left, top, rect.right, top + height);", "+\t\t\t\t\t\t\t\tOS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\treturn new LRESULT (OS.CDRF_DODEFAULT);", "+\t\t\t\t}", "+\t\t\t\tcase OS.CDDS_ITEMPREPAINT: {", "+\t\t\t\t\tif (nmcd.left >= nmcd.right || nmcd.top >= nmcd.bottom) {", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tint hDC = nmcd.hdc;", "+\t\t\t\t\tOS.SaveDC (hDC);", "+\t\t\t\t\tif (linesVisible) {", "+\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\tOS.SetRect (rect, nmcd.left, nmcd.top, nmcd.right, nmcd.bottom);", "+\t\t\t\t\t\tOS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (hwndHeader != 0) {", "+\t\t\t\t\t\tint count = OS.SendMessage (hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);", "+\t\t\t\t\t\tif (count != 0) {", "+\t\t\t\t\t\t\tHDITEM hdItem = new HDITEM ();", "+\t\t\t\t\t\t\thdItem.mask = OS.HDI_WIDTH;", "+\t\t\t\t\t\t\tOS.SendMessage (hwndHeader, OS.HDM_GETITEM, 0, hdItem);", "+\t\t\t\t\t\t\tint hRgn = OS.CreateRectRgn (nmcd.left, nmcd.top, nmcd.left + hdItem.cxy, nmcd.bottom);", "+\t\t\t\t\t\t\tOS.SelectClipRgn (hDC, hRgn);", "+\t\t\t\t\t\t\tOS.DeleteObject (hRgn);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (item.font == -1 && item.foreground == -1 && item.background == -1) {", "+\t\t\t\t\t\tif (item.cellForeground == null && item.cellBackground == null && item.cellFont == null) {", "+\t\t\t\t\t\t\treturn new LRESULT (OS.CDRF_DODEFAULT | OS.CDRF_NOTIFYPOSTPAINT);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\t\tint hFont = item.font, clrText = item.foreground, clrTextBk = item.background;", "-\t\t\t\t\tif (hFont == -1 && clrText == -1 && clrTextBk == -1) break;", "-\t\t\t\t\tif (hFont != -1) OS.SelectObject (nmcd.hdc, hFont);", "+\t\t\t\t\tint hFont = item.cellFont != null ? item.cellFont [0] : item.font;", "+\t\t\t\t\tif (hFont != -1) OS.SelectObject (hDC, hFont);", "-\t\t\t\t\t\tnmcd.clrText = clrText == -1 ? getForegroundPixel () : clrText;", "-\t\t\t\t\t\tnmcd.clrTextBk = clrTextBk == -1 ? getBackgroundPixel () : clrTextBk;", "+\t\t\t\t\t\t\tint clrText = item.cellForeground != null ? item.cellForeground [0] : item.foreground;", "+\t\t\t\t\t\t\tnmcd.clrText = clrText == -1 ? getForegroundPixel () : clrText;", "+\t\t\t\t\t\t\tint clrTextBk = item.cellBackground != null ? item.cellBackground [0] : item.background;", "+\t\t\t\t\t\t\tnmcd.clrTextBk = clrTextBk == -1 ? getBackgroundPixel () : clrTextBk;", "-\t\t\t\t\treturn new LRESULT (OS.CDRF_NEWFONT);", "+\t\t\t\t\treturn new LRESULT (OS.CDRF_NEWFONT | OS.CDRF_NOTIFYPOSTPAINT);", "+\t\t\t\t}", "+\t\t\t\tcase OS.CDDS_ITEMPOSTPAINT: {", "+\t\t\t\t\tTreeItem item = items [nmcd.lItemlParam];", "+\t\t\t\t\tif (item == null) break;", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Feature in Windows.  Under certain circumstances, Windows", "+\t\t\t\t\t* sends CDDS_ITEMPOSTPAINT for an empty rectangle.  This is", "+\t\t\t\t\t* not a problem providing that graphics do not occur outside", "+\t\t\t\t\t* the rectangle.  The fix is to test for the rectangle and", "+\t\t\t\t\t* draw nothing.", "+\t\t\t\t\t* ", "+\t\t\t\t\t* NOTE:  This seems to happen when both I_IMAGECALLBACK", "+\t\t\t\t\t* and LPSTR_TEXTCALLBACK are used at the same time with", "+\t\t\t\t\t* TVM_SETITEM.", "+\t\t\t\t\t*/", "+\t\t\t\t\tif (nmcd.left >= nmcd.right || nmcd.top >= nmcd.bottom) {", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tint hDC = nmcd.hdc;", "+\t\t\t\t\tOS.RestoreDC (hDC, -1);", "+\t\t\t\t\tOS.SetBkMode (hDC, OS.TRANSPARENT);", "+\t\t\t\t\tif (OS.IsWindowEnabled (handle)) {", "+\t\t\t\t\t\tOS.SetTextColor (hDC, getForegroundPixel ());", "+\t\t\t\t\t}", "+\t\t\t\t\tif (hwndHeader != 0) {", "+\t\t\t\t\t\tGCData data = new GCData();", "+\t\t\t\t\t\tdata.device = display;", "+\t\t\t\t\t\tGC gc = GC.win32_new (hDC, data);", "+\t\t\t\t\t\tint x = 0;", "+\t\t\t\t\t\tPoint size = null;", "+\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\tHDITEM hdItem = new HDITEM ();", "+\t\t\t\t\t\thdItem.mask = OS.HDI_WIDTH;", "+\t\t\t\t\t\tint count = OS.SendMessage (hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);", "+\t\t\t\t\t\tfor (int i=0; i<count; i++) {", "+\t\t\t\t\t\t\tOS.SendMessage (hwndHeader, OS.HDM_GETITEM, i, hdItem);", "+\t\t\t\t\t\t\tif (i > 0) {", "+\t\t\t\t\t\t\t\tOS.SetRect (rect, x, nmcd.top, x + hdItem.cxy, nmcd.bottom - GRID_WIDTH);", "+\t\t\t\t\t\t\t\tif (OS.IsWindowEnabled (handle)) {", "+\t\t\t\t\t\t\t\t\tint clrTextBk = item.cellBackground != null ? item.cellBackground [i] : item.background;", "+\t\t\t\t\t\t\t\t\tif (clrTextBk != -1) drawBackground (hDC, clrTextBk, rect);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tImage image = item.images != null ? item.images [i] : null;", "+\t\t\t\t\t\t\t\tif (image != null) {", "+\t\t\t\t\t\t\t\t\tRectangle bounds = image.getBounds ();", "+\t\t\t\t\t\t\t\t\tif (size == null) size = getImageSize ();", "+\t\t\t\t\t\t\t\t\tgc.drawImage (image, 0, 0, bounds.width, bounds.height, rect.left, rect.top, size.x, size.y);", "+\t\t\t\t\t\t\t\t\tOS.SetRect (rect, rect.left + size.x + INSET, rect.top, rect.right - INSET, rect.bottom);", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tOS.SetRect (rect, rect.left + INSET, rect.top, rect.right - INSET, rect.bottom);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t\t* Bug in Windows.  When DrawText() is used with DT_VCENTER", "+\t\t\t\t\t\t\t\t* and DT_ENDELLIPSIS, the ellipsis can draw outside of the", "+\t\t\t\t\t\t\t\t* rectangle when the rectangle is empty.  The fix is avoid", "+\t\t\t\t\t\t\t\t* all text drawing for empty rectangles.", "+\t\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\t\tif (rect.left < rect.right) {", "+\t\t\t\t\t\t\t\t\tString string = item.strings != null ? item.strings [i] : \"\";\t\t", "+\t\t\t\t\t\t\t\t\tint hFont = item.cellFont != null ? item.cellFont [i] : item.font;", "+\t\t\t\t\t\t\t\t\thFont = hFont != -1 ? OS.SelectObject (hDC, hFont) : -1;", "+\t\t\t\t\t\t\t\t\tint clrText = -1;", "+\t\t\t\t\t\t\t\t\tif (OS.IsWindowEnabled (handle)) {", "+\t\t\t\t\t\t\t\t\t\tclrText = item.cellForeground != null ? item.cellForeground [i] : item.foreground;", "+\t\t\t\t\t\t\t\t\t\tclrText = clrText != -1? OS.SetTextColor (hDC, clrText) : -1;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tint flags = OS.DT_NOPREFIX | OS.DT_SINGLELINE | OS.DT_VCENTER | OS.DT_ENDELLIPSIS;", "+\t\t\t\t\t\t\t\t\tTreeColumn column = columns [i];", "+\t\t\t\t\t\t\t\t\tif ((column.style & SWT.LEFT) != 0) flags |= OS.DT_LEFT;", "+\t\t\t\t\t\t\t\t\tif ((column.style & SWT.CENTER) != 0) flags |= OS.DT_CENTER;", "+\t\t\t\t\t\t\t\t\tif ((column.style & SWT.RIGHT) != 0) flags |= OS.DT_RIGHT;", "+\t\t\t\t\t\t\t\t\tTCHAR buffer = new TCHAR (getCodePage (), string, false);", "+\t\t\t\t\t\t\t\t\tOS.DrawText (hDC, buffer, buffer.length (), rect, flags);", "+\t\t\t\t\t\t\t\t\tif (hFont != -1) OS.SelectObject (hDC, hFont);", "+\t\t\t\t\t\t\t\t\tif (clrText != -1) OS.SetTextColor (hDC, clrText);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tx += hdItem.cxy;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tgc.dispose ();", "+\t\t\t\t\t}", "+\t\t\t\t\tif (linesVisible) {", "+\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\trect.left = item.handle;", "+\t\t\t\t\t\tif (OS.SendMessage (handle, OS.TVM_GETITEMRECT, 1, rect) != 0) {", "+\t\t\t\t\t\t\tint hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);", "+\t\t\t\t\t\t\tif (hItem == item.handle) {", "+\t\t\t\t\t\t\t\tOS.SetRect (rect, rect.right, nmcd.top, nmcd.right, nmcd.bottom);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tTVITEM tvItem = new TVITEM ();", "+\t\t\t\t\t\t\t\ttvItem.mask = OS.TVIF_STATE;", "+\t\t\t\t\t\t\t\ttvItem.hItem = item.handle;", "+\t\t\t\t\t\t\t\tOS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);", "+\t\t\t\t\t\t\t\tif ((tvItem.state & OS.TVIS_SELECTED) != 0) {", "+\t\t\t\t\t\t\t\t\tOS.SetRect (rect, rect.right, nmcd.top, nmcd.right, nmcd.bottom);", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tOS.SetRect (rect, rect.left, nmcd.top, nmcd.right, nmcd.bottom);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tOS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);", "+\t\t\t\t\t\t} ", "+\t\t\t\t\t}", "+\t\t\t\t\treturn new LRESULT (OS.CDRF_DODEFAULT);", "+\t\t\t\t}", "+\t\t\tupdateScrollBar ();", "+\t\tcase OS.TVN_ITEMEXPANDEDA:", "+\t\tcase OS.TVN_ITEMEXPANDEDW: {", "+\t\t\tupdateScrollBar ();", "+\t\t\tbreak;", "+\t\t}", "+\t\t\t\tif (items == null) break;"]}], "num": 40954}