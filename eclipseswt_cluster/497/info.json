{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e500b90b3f5c7629a689b8715740d1a3", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1b73effa99b09e9a5ffc08e6ded83eb2", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Widget.java", "commitBeforeChange": "ca61b834d1fe41e9ab22bc5da0c47a0e76e3922e", "commitAfterChange": "cd36ba0081113965df6d101260814c54e1600a54", "methodNumberBeforeChange": 95, "methodNumberAfterChange": 97, "signatureBeforeChange": "  void setKeyState (Event event, GdkEventKey keyEvent)", "signatureAfterChange": "  boolean setKeyState (Event event, GdkEventKey keyEvent)", "diff": ["-void setKeyState (Event event, GdkEventKey keyEvent) {", "-\tif (keyEvent.length <= 1) {", "-\t\tevent.keyCode = Display.translateKey (keyEvent.keyval);", "-\t\tswitch (keyEvent.keyval) {", "-\t\t\tcase OS.GDK_BackSpace:\t\tevent.character = '\\b'; break;", "-\t\t\tcase OS.GDK_Linefeed:\t\tevent.character = '\\n'; break;", "-\t\t\tcase OS.GDK_KP_Enter:", "-\t\t\tcase OS.GDK_Return: \t\tevent.character = '\\r'; break;", "-\t\t\tcase OS.GDK_Delete:\t\tevent.character = 0x7F; break;", "-\t\t\tcase OS.GDK_Cancel:", "-\t\t\tcase OS.GDK_Escape:\t\tevent.character = 0x1B; break;", "-\t\t\tcase OS.GDK_Tab:", "-\t\t\tcase OS.GDK_ISO_Left_Tab: \tevent.character = '\\t'; break;", "-//\t\t\tcase OS.GDK_Clear:\t\t\tevent.character = 0xB; break;", "-//\t\t\tcase OS.GDK_Pause:\t\t\tevent.character = 0x13; break;", "-//\t\t\tcase OS.GDK_Scroll_Lock:\tevent.character = 0x14; break;", "-\t\t\tdefault: {", "-\t\t\t\tif (event.keyCode == 0) {", "-\t\t\t\t\tint [] keyval = new int [1], effective_group= new int [1], level = new int [1], consumed_modifiers = new int [1];", "-\t\t\t\t\tif (OS.gdk_keymap_translate_keyboard_state(OS.gdk_keymap_get_default (), keyEvent.hardware_keycode, 0, keyEvent.group, keyval, effective_group, level, consumed_modifiers)) {", "-\t\t\t\t\t\tevent.keyCode = OS.gdk_keyval_to_unicode (keyval [0]);", "-\t\t\t\t\t}", "-\t\t\t\t\tint key = keyEvent.keyval;", "-\t\t\t\t\tif ((keyEvent.state & OS.GDK_CONTROL_MASK) != 0 && (0 <= key && key <= 0x7F)) {", "-\t\t\t\t\t\tif ('a'  <= key && key <= 'z') key -= 'a' - 'A';", "-\t\t\t\t\t\tif (64 <= key && key <= 95) key -= 64;", "-\t\t\t\t\t\tevent.character = (char) key;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tevent.character = (char) OS.gdk_keyval_to_unicode (key);", "-\t\t\t\t\t}", "+boolean setKeyState (Event event, GdkEventKey keyEvent) {", "+\tif (keyEvent.length > 1) return false;", "+\tboolean isNull = false;", "+\tevent.keyCode = Display.translateKey (keyEvent.keyval);", "+\tswitch (keyEvent.keyval) {", "+\t\tcase OS.GDK_BackSpace:\t\tevent.character = '\\b'; break;", "+\t\tcase OS.GDK_Linefeed:\t\tevent.character = '\\n'; break;", "+\t\tcase OS.GDK_KP_Enter:", "+\t\tcase OS.GDK_Return: \t\tevent.character = '\\r'; break;", "+\t\tcase OS.GDK_Delete:\t\tevent.character = 0x7F; break;", "+\t\tcase OS.GDK_Cancel:", "+\t\tcase OS.GDK_Escape:\t\tevent.character = 0x1B; break;", "+\t\tcase OS.GDK_Tab:", "+\t\tcase OS.GDK_ISO_Left_Tab: \tevent.character = '\\t'; break;", "+\t\tdefault: {", "+\t\t\tif (event.keyCode == 0) {", "+\t\t\t\tint [] keyval = new int [1], effective_group= new int [1], level = new int [1], consumed_modifiers = new int [1];", "+\t\t\t\tif (OS.gdk_keymap_translate_keyboard_state(OS.gdk_keymap_get_default (), keyEvent.hardware_keycode, 0, keyEvent.group, keyval, effective_group, level, consumed_modifiers)) {", "+\t\t\t\t\tevent.keyCode = OS.gdk_keyval_to_unicode (keyval [0]);", "+\t\t\t\t}", "+\t\t\t\tint key = keyEvent.keyval;", "+\t\t\t\tif ((keyEvent.state & OS.GDK_CONTROL_MASK) != 0 && (0 <= key && key <= 0x7F)) {", "+\t\t\t\t\tif ('a'  <= key && key <= 'z') key -= 'a' - 'A';", "+\t\t\t\t\tif (64 <= key && key <= 95) key -= 64;", "+\t\t\t\t\tevent.character = (char) key;", "+\t\t\t\t\tisNull = keyEvent.keyval == '@' && key == 0;", "+\t\t\t\t} else {", "+\t\t\t\t\tevent.character = (char) OS.gdk_keyval_to_unicode (key);", "-\tsetInputState (event, keyEvent.state);", "+\tif (event.keyCode == 0 && event.character == 0) {", "+\t\tif (!isNull) return false;", "+\t}", "+\treturn setInputState (event, keyEvent.state);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f13cf3dcdd91578275f5d49403b094b1", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/widgets/Widget.java", "commitBeforeChange": "a395ac5ef4b7375980dab49db198a5f9295809be", "commitAfterChange": "192f9ca85d97804def967bfc73b208b589f58b7a", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 46, "signatureBeforeChange": " void setKeyState (Event event, XKeyEvent xEvent)", "signatureAfterChange": " boolean setKeyState (Event event, XKeyEvent xEvent)", "diff": ["-void setKeyState (Event event, XKeyEvent xEvent) {", "-\tif (xEvent.keycode != 0) {", "-\t\tbyte [] buffer = new byte [5];", "-\t\tint [] keysym = new int [1];", "-\t\tOS.XLookupString (xEvent, buffer, buffer.length, keysym, null);", "-\t\t", "-\t\t/*", "-\t\t* Bug in MOTIF.  On Solaris only, XK_F11 and XK_F12 are not", "-\t\t* translated correctly by XLookupString().  They are mapped", "-\t\t* to 0x1005FF10 and 0x1005FF11 respectively.  The fix is to", "-\t\t* look for these values explicitly and correct them.", "-\t\t*/", "-\t\tif (OS.IsSunOS && keysym [0] != 0) {", "-\t\t\tswitch (keysym [0]) {", "-\t\t\t\tcase 0x1005FF10: ", "-\t\t\t\t\tkeysym [0] = OS.XK_F11;", "-\t\t\t\t\tbuffer [0] = 0;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase 0x1005FF11:", "-\t\t\t\t\tkeysym [0] = OS.XK_F12;", "-\t\t\t\t\tbuffer [0] = 0;", "-\t\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\t/*", "-\t\t\t* Bug in MOTIF.  On Solaris only, there is garbage in the", "-\t\t\t* high 16-bits for Keysyms such as XK_Down.  Since Keysyms", "-\t\t\t* must be 16-bits to fit into a Character, mask away the", "-\t\t\t* high 16-bits on all platforms.", "-\t\t\t*/", "-\t\t\tkeysym [0] &= 0xFFFF;", "-\t\t}", "-\t\t", "-\t\t/*", "-\t\t* Bug in Motif.  On HP-UX only, Shift+F9, Shift+F10, Shift+F11", "-\t\t* and Shift+F12 are not translated correctly by XLookupString().", "-\t\t* The fix is to look for these values explicitly and correct them.", "-\t\t*/", "-\t\tif (OS.IsHPUX && keysym [0] != 0) {", "-\t\t\tswitch (keysym [0]) {", "-\t\t\t\tcase 0xFF91:", "-\t\t\t\t\tkeysym [0] = OS.XK_F9;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase 0xFF92:", "-\t\t\t\t\tkeysym [0] = OS.XK_F10;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase 0xFF93:", "-\t\t\t\t\tkeysym [0] = OS.XK_F11;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase 0xFF94:", "-\t\t\t\t\tkeysym [0] = OS.XK_F12;", "-\t\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t/*", "-\t\t* Feature in MOTIF. For some reason, XLookupString() fails ", "-\t\t* to translate both the keysym and the character when the", "-\t\t* control key is down.  For example, Ctrl+2 has the correct", "-\t\t* keysym value (50) but no character value, while Ctrl+/ has", "-\t\t* the keysym value (2F) but an invalid character value", "-\t\t* (1F).  It seems that Motif is applying the algorithm to", "-\t\t* convert a character to a control character for characters", "-\t\t* that are not valid control characters.  The fix is to test", "-\t\t* for 7-bit ASCII keysym values that fall outside of the", "-\t\t* the valid control character range and use the keysym value", "-\t\t* as the character, not the incorrect value that XLookupString()", "-\t\t* returns.  Even though lower case values are not strictly", "-\t\t* valid control characters, they are included in the range.", "-\t\t* ", "-\t\t* Some other cases include Ctrl+3..Ctr+8, Ctrl+[.", "-\t\t*/", "-\t\tint key = keysym [0];", "-\t\tif ((xEvent.state & OS.ControlMask) != 0 && (0 <= key && key <= 0x7F)) {", "-\t\t\tif ('a' <= key && key <= 'z') key -= 'a' - 'A';", "-\t\t\tif (!(64 <= key && key <= 95)) buffer [0] = (byte) key;", "-\t\t}", "-\t\t", "-\t\t/*", "-\t\t* Bug in Motif.  There are some keycodes for which ", "-\t\t* XLookupString() does not translate the character.", "-\t\t* Some of examples are Shift+Tab and Ctrl+Space.", "-\t\t*/", "+boolean setKeyState (Event event, XKeyEvent xEvent) {", "+\tif (xEvent.keycode == 0) return false;", "+\tboolean isNull = false;", "+\tbyte [] buffer = new byte [5];", "+\tint [] keysym = new int [1];", "+\tOS.XLookupString (xEvent, buffer, buffer.length, keysym, null);", "+\t", "+\t/*", "+\t* Bug in MOTIF.  On Solaris only, XK_F11 and XK_F12 are not", "+\t* translated correctly by XLookupString().  They are mapped", "+\t* to 0x1005FF10 and 0x1005FF11 respectively.  The fix is to", "+\t* look for these values explicitly and correct them.", "+\t*/", "+\tif (OS.IsSunOS && keysym [0] != 0) {", "-\t\t\tcase OS.XK_ISO_Left_Tab: buffer [0] = '\\t'; break;", "-\t\t\tcase OS.XK_space: buffer [0] = ' '; break;", "+\t\t\tcase 0x1005FF10: ", "+\t\t\t\tkeysym [0] = OS.XK_F11;", "+\t\t\t\tbuffer [0] = 0;", "+\t\t\t\tbreak;", "+\t\t\tcase 0x1005FF11:", "+\t\t\t\tkeysym [0] = OS.XK_F12;", "+\t\t\t\tbuffer [0] = 0;", "+\t\t\t\tbreak;", "-\t\t\t", "-\t\t/* Fill in the event keyCode or character */", "-\t\tif (keysym [0] != 0) {", "-\t\t\tevent.keyCode = Display.translateKey (keysym [0]);", "-\t\t}", "-\t\tif (event.keyCode == 0) {", "-\t\t\tbyte [] buffer1 = new byte [5];", "-\t\t\tint [] keysym1 = new int [1];", "-\t\t\tint oldState = xEvent.state;", "-\t\t\txEvent.state = 0;", "-\t\t\tOS.XLookupString (xEvent, buffer1, buffer1.length, keysym1, null);", "-\t\t\txEvent.state = oldState;", "-\t\t\tif (buffer1 [0] != 0) {", "-\t\t\t\tchar [] result = Converter.mbcsToWcs (null, buffer1);", "-\t\t\t\tif (result.length != 0) event.keyCode = result [0];", "-\t\t\t}", "-\t\t}", "-\t\tif (buffer [0] != 0) {", "-\t\t\tchar [] result = Converter.mbcsToWcs (null, buffer);", "-\t\t\tif (result.length != 0) event.character = result [0];", "+\t\t/*", "+\t\t* Bug in MOTIF.  On Solaris only, there is garbage in the", "+\t\t* high 16-bits for Keysyms such as XK_Down.  Since Keysyms", "+\t\t* must be 16-bits to fit into a Character, mask away the", "+\t\t* high 16-bits on all platforms.", "+\t\t*/", "+\t\tkeysym [0] &= 0xFFFF;", "+\t}", "+\t", "+\t/*", "+\t* Bug in Motif.  On HP-UX only, Shift+F9, Shift+F10, Shift+F11", "+\t* and Shift+F12 are not translated correctly by XLookupString().", "+\t* The fix is to look for these values explicitly and correct them.", "+\t*/", "+\tif (OS.IsHPUX && keysym [0] != 0) {", "+\t\tswitch (keysym [0]) {", "+\t\t\tcase 0xFF91: keysym [0] = OS.XK_F9; break;", "+\t\t\tcase 0xFF92: keysym [0] = OS.XK_F10; break;", "+\t\t\tcase 0xFF93: keysym [0] = OS.XK_F11; break;", "+\t\t\tcase 0xFF94: keysym [0] = OS.XK_F12; break;", "-\tsetInputState (event, xEvent.state);", "+\t", "+\t/*", "+\t* Feature in MOTIF. For some reason, XLookupString() fails ", "+\t* to translate both the keysym and the character when the", "+\t* control key is down.  For example, Ctrl+2 has the correct", "+\t* keysym value (50) but no character value, while Ctrl+/ has", "+\t* the keysym value (2F) but an invalid character value", "+\t* (1F).  It seems that Motif is applying the algorithm to", "+\t* convert a character to a control character for characters", "+\t* that are not valid control characters.  The fix is to test", "+\t* for 7-bit ASCII keysym values that fall outside of the", "+\t* the valid control character range and use the keysym value", "+\t* as the character, not the incorrect value that XLookupString()", "+\t* returns.  Even though lower case values are not strictly", "+\t* valid control characters, they are included in the range.", "+\t* ", "+\t* Some other cases include Ctrl+3..Ctr+8, Ctrl+[.", "+\t*/", "+\tint key = keysym [0];", "+\tif ((xEvent.state & OS.ControlMask) != 0 && (0 <= key && key <= 0x7F)) {", "+\t\tif ('a' <= key && key <= 'z') key -= 'a' - 'A';", "+\t\tif (!(64 <= key && key <= 95)) buffer [0] = (byte) key;", "+\t\tisNull = key == '@' && buffer [0] == 0;", "+\t}", "+\t", "+\t/*", "+\t* Bug in Motif.  There are some keycodes for which ", "+\t* XLookupString() does not translate the character.", "+\t* Some of examples are Shift+Tab and Ctrl+Space.", "+\t*/", "+\tswitch (keysym [0]) {", "+\t\tcase OS.XK_ISO_Left_Tab: buffer [0] = '\\t'; break;", "+\t\tcase OS.XK_space: buffer [0] = ' '; break;", "+\t}", "+\t\t", "+\t/* Fill in the event keyCode or character */", "+\tif (keysym [0] != 0) {", "+\t\tevent.keyCode = Display.translateKey (keysym [0]);", "+\t}", "+\tif (event.keyCode == 0) {", "+\t\tbyte [] buffer1 = new byte [5];", "+\t\tint [] keysym1 = new int [1];", "+\t\tint oldState = xEvent.state;", "+\t\txEvent.state = 0;", "+\t\tOS.XLookupString (xEvent, buffer1, buffer1.length, keysym1, null);", "+\t\txEvent.state = oldState;", "+\t\tif (buffer1 [0] != 0) {", "+\t\t\tchar [] result = Converter.mbcsToWcs (null, buffer1);", "+\t\t\tif (result.length != 0) event.keyCode = result [0];", "+\t\t}", "+\t}", "+\tif (buffer [0] != 0) {", "+\t\tchar [] result = Converter.mbcsToWcs (null, buffer);", "+\t\tif (result.length != 0) event.character = result [0];", "+\t}", "+\tif (event.keyCode == 0 && event.character == 0) {", "+\t\tif (!isNull) return false;", "+\t}", "+\treturn setInputState (event, xEvent.state);"]}], "num": 497}