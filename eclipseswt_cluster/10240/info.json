{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5db16acbe9bdbb988629876d726e8be5", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f4631d3c164258b3f45ac841c0834cd", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "f736dbfd5d0ce9567f1410c8e42cbad12a1935ca", "commitAfterChange": "3dc220718412431322c00e1f820c9ce0168892f5", "methodNumberBeforeChange": 90, "methodNumberAfterChange": 90, "signatureBeforeChange": "  void initializeSystemColors ()", "signatureAfterChange": "  void initializeSystemColors ()", "diff": ["-\t\tOS.gtk_style_context_get_color (context, OS.GTK_STATE_FLAG_NORMAL, rgba);", "-\t\tCOLOR_INFO_FOREGROUND = toGdkColor (rgba);", "+\t\tCOLOR_INFO_FOREGROUND = toGdkColor (styleContextGetColor (context, OS.GTK_STATE_FLAG_NORMAL, rgba));", "-\t\tOS.gtk_style_context_get_color (context, OS.GTK_STATE_FLAG_NORMAL, rgba);", "-\t\tCOLOR_WIDGET_FOREGROUND = toGdkColor (rgba);", "+\t\tCOLOR_WIDGET_FOREGROUND = toGdkColor (styleContextGetColor (context, OS.GTK_STATE_FLAG_NORMAL, rgba));", "-\t\tOS.gtk_style_context_get_color (context, OS.GTK_STATE_FLAG_NORMAL, rgba);", "-\t\tCOLOR_LIST_FOREGROUND = toGdkColor (rgba);", "+\t\tCOLOR_LIST_FOREGROUND = toGdkColor (styleContextGetColor (context, OS.GTK_STATE_FLAG_NORMAL, rgba));", "-\t\tOS.gtk_style_context_get_color (context, OS.GTK_STATE_FLAG_SELECTED, rgba);", "-\t\tCOLOR_LIST_SELECTION_TEXT = toGdkColor (rgba);", "+\t\tCOLOR_LIST_SELECTION_TEXT = toGdkColor (styleContextGetColor (context, OS.GTK_STATE_FLAG_SELECTED, rgba));", "-\t\tOS.gtk_style_context_get_color (context, OS.GTK_STATE_FLAG_ACTIVE, rgba);", "-\t\tCOLOR_LIST_SELECTION_TEXT_INACTIVE = toGdkColor (rgba);", "+\t\tCOLOR_LIST_SELECTION_TEXT_INACTIVE = toGdkColor (styleContextGetColor (context, OS.GTK_STATE_FLAG_ACTIVE, rgba));", "-\t\tOS.gtk_style_context_get_color (context, OS.GTK_STATE_FLAG_INSENSITIVE, rgba);", "-\t\tCOLOR_TITLE_INACTIVE_FOREGROUND = toGdkColor (rgba);", "+\t\tCOLOR_TITLE_INACTIVE_FOREGROUND = toGdkColor (styleContextGetColor (context, OS.GTK_STATE_FLAG_INSENSITIVE, rgba));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e7c31505fa1a5eb32dde75960ec82d5", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/StyledText2.java", "commitBeforeChange": "0eca40a26667c3712617b5dd23e67af76bcbab4d", "commitAfterChange": "c345d69dc06c2a69d5f698a12d1c7890b32841ad", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 59, "signatureBeforeChange": " void calculateTopIndex()", "signatureAfterChange": " void calculateTopIndex()", "diff": ["-\tint verticalIncrement = getVerticalIncrement();", "-\tif (verticalIncrement == 0) {", "-\t\treturn;", "-\t}", "-\ttopIndex = Compatibility.ceil(verticalScrollOffset, verticalIncrement);", "-\t// Set top index to partially visible top line if no line is fully ", "-\t// visible but at least some of the widget client area is visible.", "-\t// Fixes bug 15088.", "-\tif (topIndex > 0) {", "-\t\tint clientAreaHeight = getClientArea().height;", "-\t\tif (clientAreaHeight > 0) {", "-\t\t\tint bottomPixel = verticalScrollOffset + clientAreaHeight;", "-\t\t\tint fullLineTopPixel = topIndex * verticalIncrement;", "-\t\t\tint fullLineVisibleHeight = bottomPixel - fullLineTopPixel;", "-\t\t\t// set top index to partially visible line if no line fully fits in ", "-\t\t\t// client area or if space is available but not used (the latter should", "-\t\t\t// never happen because we use claimBottomFreeSpace)", "-\t\t\tif (fullLineVisibleHeight < verticalIncrement) {", "-\t\t\t\ttopIndex--;", "+\t", "+\tRectangle clientArea = getClientArea();", "+\ttopIndex = getLineIndex(clientArea.y);", "+\tint linePixel = getLinePixel(topIndex);", "+\tif (linePixel < 0) {", "+\t\tint lineCount = content.getLineCount();", "+\t\tif (topIndex < lineCount - 1) {", "+\t\t\tint bottom = getLinePixel(topIndex + 1);", "+\t\t\tbottom = lineCache.getLineHeight(topIndex + 1);", "+\t\t\tif (clientArea.height > bottom) {", "+\t\t\t\ttopIndex++;", "-\t\t} else if (topIndex >= content.getLineCount()) {", "-\t\t\ttopIndex = content.getLineCount() - 1;", "-\t}", "+\t} ", "+", "+//\tint verticalIncrement = getVerticalIncrement();", "+//\tif (verticalIncrement == 0) {", "+//\t\treturn;", "+//\t}", "+//\ttopIndex = Compatibility.ceil(verticalScrollOffset, verticalIncrement);", "+//\t// Set top index to partially visible top line if no line is fully ", "+//\t// visible but at least some of the widget client area is visible.", "+//\t// Fixes bug 15088.", "+//\tif (topIndex > 0) {", "+//\t\tint clientAreaHeight = getClientArea().height;", "+//\t\tif (clientAreaHeight > 0) {", "+//\t\t\tint bottomPixel = verticalScrollOffset + clientAreaHeight;", "+//\t\t\tint fullLineTopPixel = topIndex * verticalIncrement;", "+//\t\t\tint fullLineVisibleHeight = bottomPixel - fullLineTopPixel;", "+//\t\t\t// set top index to partially visible line if no line fully fits in ", "+//\t\t\t// client area or if space is available but not used (the latter should", "+//\t\t\t// never happen because we use claimBottomFreeSpace)", "+//\t\t\tif (fullLineVisibleHeight < verticalIncrement) {", "+//\t\t\t\ttopIndex--;", "+//\t\t\t}", "+//\t\t} else if (topIndex >= content.getLineCount()) {", "+//\t\t\ttopIndex = content.getLineCount() - 1;", "+//\t\t}", "+//\t}", "+\t", "-\t\tlineCache.calculate(topIndex, getPartialBottomIndex() - topIndex + 1);", "+\t\tlineCache.calculateClientArea();"]}], "num": 10240}