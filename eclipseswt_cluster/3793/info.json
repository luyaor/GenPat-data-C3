{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3604b40fb0233ee76c00abc2d57b31b4", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a7941dbafe48313b66df13c8e81e501d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "bc0159e1f232b2994f90bfab06507bbdbd612bc8", "commitAfterChange": "4bf0b224a9caf7edd2d827277068ffb2c6e7bf23", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": " public Image(Device device, Image srcImage, int flag)", "signatureAfterChange": " public Image(Device device, Image srcImage, int flag)", "diff": ["-\t", "-\t// AW", "-\t//if (flag == SWT.IMAGE_DISABLE)", "-\t\tflag= SWT.IMAGE_COPY;", "-\t// AW", "-\t\t", "-\t/* AW", "-\tint xDisplay = device.xDisplay;", "-\t*/", "+\t\t\t", "+\t", "-        /* AW", "-\t\tint mask = OS.XCreatePixmap(xDisplay, drawable, width, height, 1);", "-\t\tint gc = OS.XCreateGC(xDisplay, mask, 0, null);", "-\t\tOS.XCopyArea(xDisplay, srcImage.mask, mask, gc, 0, 0, width, height, 0, 0);", "-\t\tOS.XFreeGC(xDisplay, gc);", "-\t\t*/", "-\t\tthis.mask = OS.duplicatePixMap(srcImage.mask);", "+\t\tthis.mask = duplicate(srcImage.mask);", "+\t", "-\t\tcase SWT.IMAGE_COPY:", "-            /* AW", "-\t\t\tint[] depth = new int[1];", "-\t\t\tOS.XGetGeometry(xDisplay, srcImage.pixmap, unused, unused, unused, unused, unused, unused, depth);", "-\t\t\tint pixmap = OS.XCreatePixmap(xDisplay, drawable, width, height, depth[0]);", "-\t\t\tint gc = OS.XCreateGC(xDisplay, pixmap, 0, null);", "-\t\t\tOS.XCopyArea(xDisplay, srcImage.pixmap, pixmap, gc, 0, 0, width, height, 0, 0);", "-\t\t\tOS.XFreeGC(xDisplay, gc);", "-\t\t\t*/", "-\t\t\tthis.pixmap = OS.duplicatePixMap(srcImage.pixmap);", "-\t\t\ttransparentPixel = srcImage.transparentPixel;", "-\t\t\talpha = srcImage.alpha;", "-\t\t\tif (srcImage.alphaData != null) {", "-\t\t\t\talphaData = new byte[srcImage.alphaData.length];", "-\t\t\t\tSystem.arraycopy(srcImage.alphaData, 0, alphaData, 0, alphaData.length);", "-\t\t\t}", "-\t\t\treturn;", "-\t\tcase SWT.IMAGE_DISABLE:", "-\t\t\t/* Get src image data */", "-\t\t\tint dd= OS.GetPixDepth(srcImage.pixmap);", "-\t\t\tif (dd < 0)", "-\t\t\t\tdd= 1;", "-\t\t\tXImage srcXImage = new XImage(width, height, dd);", "-            /* AW", "-\t\t\tint srcXImagePtr = OS.XGetImage(xDisplay, srcImage.pixmap, 0, 0, width, height, OS.AllPlanes, OS.ZPixmap);", "-\t\t\tOS.memmove(srcXImage, srcXImagePtr, XImage.sizeof);", "-\t\t\t*/", "-\t\t\tbyte[] srcData = new byte[srcXImage.bytes_per_line * srcXImage.height];", "-\t\t\t/* AW", "-\t\t\tOS.memmove(srcData, srcXImage.data, srcData.length);", "-            */", "-\t\t\t/* Create destination image */", "-            /* AW", "-\t\t\tint destPixmap = OS.XCreatePixmap(xDisplay, drawable, width, height, srcXImage.depth);", "-\t\t\t*/", "-\t\t\tint destPixmap = createPixMap((short)width, (short)height, (short)srcXImage.depth, null, null, null, null);\t\t\t", "-\t\t\tXImage destXImage = new XImage(width, height, srcXImage.depth);", "-\t\t\t/* AW", "-\t\t\tint destXImagePtr = OS.XGetImage(xDisplay, drawable, 0, 0, width, height, OS.AllPlanes, OS.ZPixmap);", "-\t\t\tOS.memmove(destXImage, destXImagePtr, XImage.sizeof);", "-\t\t\t*/", "-\t\t\tbyte[] destData = new byte[destXImage.bytes_per_line * destXImage.height];", "-\t\t\t/* Find the colors to map to */", "-\t\t\tColor zeroColor = device.getSystemColor(SWT.COLOR_WIDGET_NORMAL_SHADOW);", "-\t\t\tColor oneColor = device.getSystemColor(SWT.COLOR_WIDGET_BACKGROUND);", "-\t\t\t/* AW", "-\t\t\tint zeroPixel = zeroColor.handle.pixel;", "-\t\t\tint onePixel = oneColor.handle.pixel;", "-\t\t\t*/", "-\t\t\tint zeroPixel = 0;", "-\t\t\tint onePixel = 1;", "+\t\t", "+\tcase SWT.IMAGE_COPY:", "+\t\tthis.pixmap = duplicate(srcImage.pixmap);", "+\t\ttransparentPixel = srcImage.transparentPixel;", "+\t\talpha = srcImage.alpha;", "+\t\tif (srcImage.alphaData != null) {", "+\t\t\talphaData = new byte[srcImage.alphaData.length];", "+\t\t\tSystem.arraycopy(srcImage.alphaData, 0, alphaData, 0, alphaData.length);", "+\t\t}", "+\t\treturn;", "+\t\t", "+\tcase SWT.IMAGE_DISABLE:", "+\t\t/* Get src image data */", "+\t\tint srcDepth= getDepth(srcImage.pixmap);", "+\t\tint srcRowBytes= rowBytes(width, srcDepth);", "+\t\tint srcBitsPerPixel= srcDepth;", "+\t\t", "+\t\tbyte[] srcData = new byte[srcRowBytes * height];", "+\t\tOS.copyPixmapData(srcImage.pixmap, srcData);", "-\t\t\tswitch (srcXImage.bits_per_pixel) {", "-\t\t\t\tcase 1:", "-\t\t\t\t\t/*", "-\t\t\t\t\t * Nothing we can reasonably do here except copy", "-\t\t\t\t\t * the bitmap; we can't make it a higher color depth.", "-\t\t\t\t\t * Short-circuit the rest of the code and return.", "-\t\t\t\t\t */", "-                    /* AW", "-\t\t\t\t\tgc = OS.XCreateGC(xDisplay, drawable, 0, null);", "-\t\t\t\t\tpixmap = OS.XCreatePixmap(xDisplay, drawable, width, height, 1);", "-\t\t\t\t\tOS.XCopyArea(xDisplay, srcImage.pixmap, pixmap, gc, 0, 0, width, height, 0, 0);", "-\t\t\t\t\t*/", "-\t\t\t\t\tpixmap = OS.duplicatePixMap(srcImage.pixmap);", "-\t\t\t\t\t/* AW", "-\t\t\t\t\tOS.XDestroyImage(srcXImagePtr);", "-\t\t\t\t\tOS.XDestroyImage(destXImagePtr);", "-\t\t\t\t\tOS.XFreeGC(xDisplay, gc);", "-                    */", "-\t\t\t\t\treturn;", "-\t\t\t\tcase 4:", "-\t\t\t\t\tSWT.error(SWT.ERROR_NOT_IMPLEMENTED);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase 8:", "-\t\t\t\t\tint index = 0;", "-\t\t\t\t\tint srcPixel, r, g, b;", "-                    /* AW", "-\t\t\t\t\tXColor[] colors = new XColor[256];", "-\t\t\t\t\tint colormap = OS.XDefaultColormap(xDisplay, OS.XDefaultScreen(xDisplay));", "-\t\t\t\t\tfor (int y = 0; y < srcXImage.height; y++) {", "-\t\t\t\t\t\tfor (int x = 0; x < srcXImage.bytes_per_line; x++) {", "-\t\t\t\t\t\t\tsrcPixel = srcData[index + x] & 0xFF;", "-                            */", "-\t\t\t\t\t\t\t/* Get the RGB values of srcPixel */", "-                            /* AW", "-\t\t\t\t\t\t\tif (colors[srcPixel] == null) {", "-\t\t\t\t\t\t\t\tXColor color = new XColor();", "-\t\t\t\t\t\t\t\tcolor.pixel = srcPixel;", "-\t\t\t\t\t\t\t\tOS.XQueryColor(xDisplay, colormap, color);", "-\t\t\t\t\t\t\t\tcolors[srcPixel] = color;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tXColor xColor = colors[srcPixel];", "-\t\t\t\t\t\t\tr = (xColor.red >> 8) & 0xFF;", "-\t\t\t\t\t\t\tg = (xColor.green >> 8) & 0xFF;", "-\t\t\t\t\t\t\tb = (xColor.blue >> 8) & 0xFF;", "-                            */", "-\t\t\t\t\t\t\t/* See if the rgb maps to 0 or 1 */", "-                            /* AW", "-\t\t\t\t\t\t\tif ((r * r + g * g + b * b) < 98304) {", "-                            */", "-\t\t\t\t\t\t\t\t/* Map down to 0 */", "-                                /* AW", "-\t\t\t\t\t\t\t\tdestData[index + x] = (byte)zeroPixel;", "-\t\t\t\t\t\t\t} else {", "-                            */", "-\t\t\t\t\t\t\t\t/* Map up to 1 */", "-                                /* AW", "-\t\t\t\t\t\t\t\tdestData[index + x] = (byte)onePixel;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tindex += srcXImage.bytes_per_line;", "-\t\t\t\t\t}", "-                    */", "-\t\t\t\t\tSystem.out.println(\"Image.Image(4): nyi\");", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase 16:", "-\t\t\t\t\tindex = 0;", "-\t\t\t\t\t/* Get masks */", "-                    /* AW", "-\t\t\t\t\tVisual visual = new Visual();", "-\t\t\t\t\tint screenNum = OS.XDefaultScreen(xDisplay);", "-\t\t\t\t\tint visualPtr = OS.XDefaultVisual(xDisplay, screenNum);", "-\t\t\t\t\tOS.memmove(visual, visualPtr, Visual.sizeof);", "-\t\t\t\t\tint redMask = visual.red_mask;", "-\t\t\t\t\tint greenMask = visual.green_mask;", "-\t\t\t\t\tint blueMask = visual.blue_mask;", "-                    */", "-\t\t\t\t\tint redMask = 0x7C00;", "-\t\t\t\t\tint greenMask = 0x03E0;", "-\t\t\t\t\tint blueMask = 0x001F;\t\t\t\t\t", "-\t\t\t\t\t/* Calculate mask shifts */", "-\t\t\t\t\tint[] shift = new int[1];", "-\t\t\t\t\tgetOffsetForMask(16, redMask, srcXImage.byte_order, shift);", "-\t\t\t\t\tint rShift = 24 - shift[0];", "-\t\t\t\t\tgetOffsetForMask(16, greenMask, srcXImage.byte_order, shift);", "-\t\t\t\t\tint gShift = 24 - shift[0];", "-\t\t\t\t\tgetOffsetForMask(16, blueMask, srcXImage.byte_order, shift);", "-\t\t\t\t\tint bShift = 24 - shift[0];", "-\t\t\t\t\tbyte zeroLow = (byte)(zeroPixel & 0xFF);", "-\t\t\t\t\tbyte zeroHigh = (byte)((zeroPixel >> 8) & 0xFF);", "-\t\t\t\t\tbyte oneLow = (byte)(onePixel & 0xFF);", "-\t\t\t\t\tbyte oneHigh = (byte)((onePixel >> 8) & 0xFF);", "-\t\t\t\t\tfor (int y = 0; y < srcXImage.height; y++) {", "-\t\t\t\t\t\tint xIndex = 0;", "-\t\t\t\t\t\tfor (int x = 0; x < srcXImage.bytes_per_line; x += 2) {", "-\t\t\t\t\t\t\tsrcPixel = ((srcData[index + xIndex + 1] & 0xFF) << 8) | (srcData[index + xIndex] & 0xFF);", "-\t\t\t\t\t\t\tr = (srcPixel & redMask) << rShift >> 16;", "-\t\t\t\t\t\t\tg = (srcPixel & greenMask) << gShift >> 16;", "-\t\t\t\t\t\t\tb = (srcPixel & blueMask) << bShift >> 16;", "-\t\t\t\t\t\t\t/* See if the rgb maps to 0 or 1 */", "-\t\t\t\t\t\t\tif ((r * r + g * g + b * b) < 98304) {", "-\t\t\t\t\t\t\t\t/* Map down to 0 */", "-\t\t\t\t\t\t\t\tdestData[index + xIndex] = zeroLow;", "-\t\t\t\t\t\t\t\tdestData[index + xIndex + 1] = zeroHigh;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t/* Map up to 1 */", "-\t\t\t\t\t\t\t\tdestData[index + xIndex] = oneLow;", "-\t\t\t\t\t\t\t\tdestData[index + xIndex + 1] = oneHigh;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\txIndex += srcXImage.bits_per_pixel / 8;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tindex += srcXImage.bytes_per_line;", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase 24:", "-\t\t\t\tcase 32:", "-\t\t\t\t\tindex = 0;", "-\t\t\t\t\t/* Get masks */", "-                    /* AW", "-\t\t\t\t\tvisual = new Visual();", "-\t\t\t\t\tscreenNum = OS.XDefaultScreen(xDisplay);", "-\t\t\t\t\tvisualPtr = OS.XDefaultVisual(xDisplay, screenNum);", "-\t\t\t\t\tOS.memmove(visual, visualPtr, Visual.sizeof);", "-\t\t\t\t\tredMask = visual.red_mask;", "-\t\t\t\t\tgreenMask = visual.green_mask;", "-\t\t\t\t\tblueMask = visual.blue_mask;", "-                    */", "-\t\t\t\t\tredMask = 0xff0000;", "-\t\t\t\t\tgreenMask = 0x00ff00;", "-\t\t\t\t\tblueMask = 0x0000ff;\t\t\t\t\t", "-\t\t\t\t\t/* Calculate mask shifts */", "-\t\t\t\t\tshift = new int[1];", "-\t\t\t\t\tgetOffsetForMask(srcXImage.bits_per_pixel, redMask, srcXImage.byte_order, shift);", "-\t\t\t\t\trShift = shift[0];", "-\t\t\t\t\tgetOffsetForMask(srcXImage.bits_per_pixel, greenMask, srcXImage.byte_order, shift);", "-\t\t\t\t\tgShift = shift[0];", "-\t\t\t\t\tgetOffsetForMask(srcXImage.bits_per_pixel, blueMask, srcXImage.byte_order, shift);", "-\t\t\t\t\tbShift = shift[0];", "-\t\t\t\t\tbyte zeroR = (byte)zeroColor.getRed();", "-\t\t\t\t\tbyte zeroG = (byte)zeroColor.getGreen();", "-\t\t\t\t\tbyte zeroB = (byte)zeroColor.getBlue();", "-\t\t\t\t\tbyte oneR = (byte)oneColor.getRed();", "-\t\t\t\t\tbyte oneG = (byte)oneColor.getGreen();", "-\t\t\t\t\tbyte oneB = (byte)oneColor.getBlue();", "-\t\t\t\t\tfor (int y = 0; y < srcXImage.height; y++) {", "-\t\t\t\t\t\tint xIndex = 0;", "-\t\t\t\t\t\tfor (int x = 0; x < srcXImage.width; x++) {", "-\t\t\t\t\t\t\tr = srcData[index + xIndex + rShift] & 0xFF;", "-\t\t\t\t\t\t\tg = srcData[index + xIndex + gShift] & 0xFF;", "-\t\t\t\t\t\t\tb = srcData[index + xIndex + bShift] & 0xFF;", "-\t\t\t\t\t\t\t/* See if the rgb maps to 0 or 1 */", "-\t\t\t\t\t\t\tif ((r * r + g * g + b * b) < 98304) {", "-\t\t\t\t\t\t\t\t/* Map down to 0 */", "-\t\t\t\t\t\t\t\tdestData[index + xIndex + rShift] = zeroR;", "-\t\t\t\t\t\t\t\tdestData[index + xIndex + gShift] = zeroG;", "-\t\t\t\t\t\t\t\tdestData[index + xIndex + bShift] = zeroB;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t/* Map up to 1 */", "-\t\t\t\t\t\t\t\tdestData[index + xIndex + rShift] = oneR;", "-\t\t\t\t\t\t\t\tdestData[index + xIndex + gShift] = oneG;", "-\t\t\t\t\t\t\t\tdestData[index + xIndex + bShift] = oneB;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\txIndex += destXImage.bits_per_pixel / 8;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tindex += srcXImage.bytes_per_line;", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t\t\t\tdefault:", "-\t\t\t\t\tSWT.error(SWT.ERROR_INVALID_IMAGE);", "-\t\t\t}", "-            /* AW", "-\t\t\tOS.memmove(destXImage.data, destData, destData.length);", "-\t\t\tgc = OS.XCreateGC(xDisplay, destPixmap, 0, null);", "-\t\t\tOS.XPutImage(xDisplay, destPixmap, gc, destXImagePtr, 0, 0, 0, 0, width, height);", "-\t\t\t*/", "+\t\t/* Create destination image */", "+\t\tint destPixmap = createPixMap(width, height, srcDepth);", "+\t\tint destBitsPerPixel= srcDepth;", "+\t\tbyte[] destData = new byte[srcRowBytes * height];", "+\t\t", "+\t\t/* Find the colors to map to */", "+\t\tColor zeroColor = device.getSystemColor(SWT.COLOR_WIDGET_NORMAL_SHADOW);", "+\t\tColor oneColor = device.getSystemColor(SWT.COLOR_WIDGET_BACKGROUND);", "+\t\tint zeroPixel= 0;", "+\t\tint onePixel= 1;", "+\t\tsetColorTable(destPixmap, new Color[] { zeroColor, oneColor });", "+", "+\t\tswitch (srcBitsPerPixel) {", "+\t\tcase 1:", "+\t\t\t/*", "+\t\t\t * Nothing we can reasonably do here except copy", "+\t\t\t * the bitmap; we can't make it a higher color depth.", "+\t\t\t * Short-circuit the rest of the code and return.", "+\t\t\t */", "+\t\t\tpixmap = duplicate(srcImage.pixmap);", "+\t\t\treturn;", "+\t\tcase 4:", "+\t\t\tSWT.error(SWT.ERROR_NOT_IMPLEMENTED);", "+\t\t\tbreak;", "+\t\tcase 8:", "+\t\t\tint index = 0;", "+\t\t\tint srcPixel, r, g, b;", "-\t\t\tSystem.out.println(\"Image.Image(5): nyi\");", "-\t\t\t/* AW", "-\t\t\tOS.XDestroyImage(destXImagePtr);", "-\t\t\tOS.XDestroyImage(srcXImagePtr);", "-\t\t\tOS.XFreeGC(xDisplay, gc);", "-\t\t\t*/", "-\t\t\tthis.pixmap = destPixmap;", "-\t\t\treturn;", "-", "-\t\tcase SWT.IMAGE_GRAY:", "-\t\t\tImageData data = srcImage.getImageData();", "-\t\t\tPaletteData palette = data.palette;", "-\t\t\tImageData newData = data;", "-\t\t\tif (!palette.isDirect) {", "-\t\t\t\t/* Convert the palette entries to gray. */", "-\t\t\t\tRGB [] rgbs = palette.getRGBs();", "-\t\t\t\tfor (int i=0; i<rgbs.length; i++) {", "-\t\t\t\t\tif (data.transparentPixel != i) {", "-\t\t\t\t\t\tRGB color = rgbs [i];", "-\t\t\t\t\t\tint red = color.red;", "-\t\t\t\t\t\tint green = color.green;", "-\t\t\t\t\t\tint blue = color.blue;", "-\t\t\t\t\t\tint intensity = (red+red+green+green+green+green+green+blue) >> 3;", "-\t\t\t\t\t\tcolor.red = color.green = color.blue = intensity;", "+\t\t\tint[] colors= new int[256];", "+\t\t\tfor (int i= 0; i < 256; i++)", "+\t\t\t\tcolors[i]= -1;", "+\t\t\t\t", "+\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\tfor (int x = 0; x < srcRowBytes; x++) {", "+\t\t\t\t\tsrcPixel = srcData[index + x] & 0xFF;", "+\t\t\t\t\t/* Get the RGB values of srcPixel */", "+\t\t\t\t\tint color= colors[srcPixel];", "+\t\t\t\t\tif (color == -1)\t\t\t", "+\t\t\t\t\t\tcolors[srcPixel]= color= OS.getRGB(srcImage.pixmap, srcPixel);", "+\t\t\t\t\tr = (color >> 16) & 0xFF;", "+\t\t\t\t\tg = (color >> 8) & 0xFF;", "+\t\t\t\t\tb = (color) & 0xFF;", "+\t\t\t\t\t/* See if the rgb maps to 0 or 1 */", "+\t\t\t\t\tif ((r * r + g * g + b * b) < 98304) {", "+\t\t\t\t\t\t/* Map down to 0 */", "+\t\t\t\t\t\tdestData[index + x] = (byte)zeroPixel;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t/* Map up to 1 */", "+\t\t\t\t\t\tdestData[index + x] = (byte)onePixel;", "-\t\t\t\tnewData.palette = new PaletteData(rgbs);", "-\t\t\t} else {", "-\t\t\t\t/* Create a 8 bit depth image data with a gray palette. */", "-\t\t\t\tRGB[] rgbs = new RGB[256];", "-\t\t\t\tfor (int i=0; i<rgbs.length; i++) {", "-\t\t\t\t\trgbs[i] = new RGB(i, i, i);", "-\t\t\t\t}", "-\t\t\t\tnewData = new ImageData(width, height, 8, new PaletteData(rgbs));", "-\t\t\t\tnewData.maskData = data.maskData;", "-\t\t\t\tnewData.maskPad = data.maskPad;", "-\t\t\t\t/* Convert the pixels. */", "-\t\t\t\tint[] scanline = new int[width];", "-\t\t\t\tint redMask = palette.redMask;", "-\t\t\t\tint greenMask = palette.greenMask;", "-\t\t\t\tint blueMask = palette.blueMask;", "-\t\t\t\tint redShift = palette.redShift;", "-\t\t\t\tint greenShift = palette.greenShift;", "-\t\t\t\tint blueShift = palette.blueShift;", "-\t\t\t\tfor (int y=0; y<height; y++) {", "-\t\t\t\t\tint offset = y * newData.bytesPerLine;", "-\t\t\t\t\tdata.getPixels(0, y, width, scanline, 0);", "-\t\t\t\t\tfor (int x=0; x<width; x++) {", "-\t\t\t\t\t\tint pixel = scanline[x];", "-\t\t\t\t\t\tint red = pixel & redMask;", "-\t\t\t\t\t\tred = (redShift < 0) ? red >>> -redShift : red << redShift;", "-\t\t\t\t\t\tint green = pixel & greenMask;", "-\t\t\t\t\t\tgreen = (greenShift < 0) ? green >>> -greenShift : green << greenShift;", "-\t\t\t\t\t\tint blue = pixel & blueMask;", "-\t\t\t\t\t\tblue = (blueShift < 0) ? blue >>> -blueShift : blue << blueShift;", "-\t\t\t\t\t\tnewData.data[offset++] =", "-\t\t\t\t\t\t\t(byte)((red+red+green+green+green+green+green+blue) >> 3);", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t\tindex += srcRowBytes;", "-\t\t\tinit (device, newData);", "+\t\t\tbreak;", "+\t\tcase 16:", "+\t\t\tindex = 0;", "+\t\t\t/* Get masks */", "+\t\t\tint redMask = getRedMask(16);", "+\t\t\tint greenMask = getGreenMask(16);", "+\t\t\tint blueMask = getBlueMask(16);\t\t\t\t\t", "+\t\t\t/* Calculate mask shifts */", "+\t\t\tint[] shift = new int[1];", "+\t\t\tgetOffsetForMask(16, redMask, true, shift);", "+\t\t\tint rShift = 24 - shift[0];", "+\t\t\tgetOffsetForMask(16, greenMask, true, shift);", "+\t\t\tint gShift = 24 - shift[0];", "+\t\t\tgetOffsetForMask(16, blueMask, true, shift);", "+\t\t\tint bShift = 24 - shift[0];", "+\t\t\tbyte zeroLow = (byte)(zeroPixel & 0xFF);", "+\t\t\tbyte zeroHigh = (byte)((zeroPixel >> 8) & 0xFF);", "+\t\t\tbyte oneLow = (byte)(onePixel & 0xFF);", "+\t\t\tbyte oneHigh = (byte)((onePixel >> 8) & 0xFF);", "+\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\tint xIndex = 0;", "+\t\t\t\tfor (int x = 0; x < srcRowBytes; x += 2) {", "+\t\t\t\t\tsrcPixel = ((srcData[index + xIndex + 1] & 0xFF) << 8) | (srcData[index + xIndex] & 0xFF);", "+\t\t\t\t\tr = (srcPixel & redMask) << rShift >> 16;", "+\t\t\t\t\tg = (srcPixel & greenMask) << gShift >> 16;", "+\t\t\t\t\tb = (srcPixel & blueMask) << bShift >> 16;", "+\t\t\t\t\t/* See if the rgb maps to 0 or 1 */", "+\t\t\t\t\tif ((r * r + g * g + b * b) < 98304) {", "+\t\t\t\t\t\t/* Map down to 0 */", "+\t\t\t\t\t\tdestData[index + xIndex] = zeroLow;", "+\t\t\t\t\t\tdestData[index + xIndex + 1] = zeroHigh;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t/* Map up to 1 */", "+\t\t\t\t\t\tdestData[index + xIndex] = oneLow;", "+\t\t\t\t\t\tdestData[index + xIndex + 1] = oneHigh;", "+\t\t\t\t\t}", "+\t\t\t\t\txIndex += srcBitsPerPixel / 8;", "+\t\t\t\t}", "+\t\t\t\tindex += srcRowBytes;", "+\t\t\t}", "+\t\t\tbreak;", "+\t\tcase 24:", "+\t\tcase 32:", "+\t\t\tindex = 0;", "+\t\t\t/* Get masks */", "+\t\t\tredMask = getRedMask(srcBitsPerPixel);", "+\t\t\tgreenMask = getGreenMask(srcBitsPerPixel);", "+\t\t\tblueMask = getBlueMask(srcBitsPerPixel);\t\t\t\t\t", "+\t\t\t/* Calculate mask shifts */", "+\t\t\tshift = new int[1];", "+\t\t\tgetOffsetForMask(srcBitsPerPixel, redMask, true, shift);", "+\t\t\trShift = shift[0];", "+\t\t\tgetOffsetForMask(srcBitsPerPixel, greenMask, true, shift);", "+\t\t\tgShift = shift[0];", "+\t\t\tgetOffsetForMask(srcBitsPerPixel, blueMask, true, shift);", "+\t\t\tbShift = shift[0];", "+\t\t\tbyte zeroR = (byte)zeroColor.getRed();", "+\t\t\tbyte zeroG = (byte)zeroColor.getGreen();", "+\t\t\tbyte zeroB = (byte)zeroColor.getBlue();", "+\t\t\tbyte oneR = (byte)oneColor.getRed();", "+\t\t\tbyte oneG = (byte)oneColor.getGreen();", "+\t\t\tbyte oneB = (byte)oneColor.getBlue();", "+\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\tint xIndex = 0;", "+\t\t\t\tfor (int x = 0; x < height; x++) {", "+\t\t\t\t\tr = srcData[index + xIndex + rShift] & 0xFF;", "+\t\t\t\t\tg = srcData[index + xIndex + gShift] & 0xFF;", "+\t\t\t\t\tb = srcData[index + xIndex + bShift] & 0xFF;", "+\t\t\t\t\t/* See if the rgb maps to 0 or 1 */", "+\t\t\t\t\tif ((r * r + g * g + b * b) < 98304) {", "+\t\t\t\t\t\t/* Map down to 0 */", "+\t\t\t\t\t\tdestData[index + xIndex + rShift] = zeroR;", "+\t\t\t\t\t\tdestData[index + xIndex + gShift] = zeroG;", "+\t\t\t\t\t\tdestData[index + xIndex + bShift] = zeroB;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t/* Map up to 1 */", "+\t\t\t\t\t\tdestData[index + xIndex + rShift] = oneR;", "+\t\t\t\t\t\tdestData[index + xIndex + gShift] = oneG;", "+\t\t\t\t\t\tdestData[index + xIndex + bShift] = oneB;", "+\t\t\t\t\t}", "+\t\t\t\t\txIndex += destBitsPerPixel / 8;", "+\t\t\t\t}", "+\t\t\t\tindex += srcRowBytes;", "+\t\t\t}", "-\t\t\tSWT.error(SWT.ERROR_INVALID_ARGUMENT);", "+\t\t\tSWT.error(SWT.ERROR_INVALID_IMAGE);", "+\t\t}", "+\t\tOS.setBitMapData(destPixmap, destData);", "+\t\tthis.pixmap = destPixmap;", "+\t\treturn;", "+", "+\tcase SWT.IMAGE_GRAY:", "+\t\tImageData data = srcImage.getImageData();", "+\t\tPaletteData palette = data.palette;", "+\t\tImageData newData = data;", "+\t\tif (!palette.isDirect) {", "+\t\t\t/* Convert the palette entries to gray. */", "+\t\t\tRGB [] rgbs = palette.getRGBs();", "+\t\t\tfor (int i=0; i<rgbs.length; i++) {", "+\t\t\t\tif (data.transparentPixel != i) {", "+\t\t\t\t\tRGB color = rgbs [i];", "+\t\t\t\t\tint red = color.red;", "+\t\t\t\t\tint green = color.green;", "+\t\t\t\t\tint blue = color.blue;", "+\t\t\t\t\tint intensity = (red+red+green+green+green+green+green+blue) >> 3;", "+\t\t\t\t\tcolor.red = color.green = color.blue = intensity;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tnewData.palette = new PaletteData(rgbs);", "+\t\t} else {", "+\t\t\t/* Create a 8 bit depth image data with a gray palette. */", "+\t\t\tRGB[] rgbs = new RGB[256];", "+\t\t\tfor (int i=0; i<rgbs.length; i++) {", "+\t\t\t\trgbs[i] = new RGB(i, i, i);", "+\t\t\t}", "+\t\t\tnewData = new ImageData(width, height, 8, new PaletteData(rgbs));", "+\t\t\tnewData.maskData = data.maskData;", "+\t\t\tnewData.maskPad = data.maskPad;", "+\t\t\t/* Convert the pixels. */", "+\t\t\tint[] scanline = new int[width];", "+\t\t\tint redMask = palette.redMask;", "+\t\t\tint greenMask = palette.greenMask;", "+\t\t\tint blueMask = palette.blueMask;", "+\t\t\tint redShift = palette.redShift;", "+\t\t\tint greenShift = palette.greenShift;", "+\t\t\tint blueShift = palette.blueShift;", "+\t\t\tfor (int y=0; y<height; y++) {", "+\t\t\t\tint offset = y * newData.bytesPerLine;", "+\t\t\t\tdata.getPixels(0, y, width, scanline, 0);", "+\t\t\t\tfor (int x=0; x<width; x++) {", "+\t\t\t\t\tint pixel = scanline[x];", "+\t\t\t\t\tint red = pixel & redMask;", "+\t\t\t\t\tred = (redShift < 0) ? red >>> -redShift : red << redShift;", "+\t\t\t\t\tint green = pixel & greenMask;", "+\t\t\t\t\tgreen = (greenShift < 0) ? green >>> -greenShift : green << greenShift;", "+\t\t\t\t\tint blue = pixel & blueMask;", "+\t\t\t\t\tblue = (blueShift < 0) ? blue >>> -blueShift : blue << blueShift;", "+\t\t\t\t\tnewData.data[offset++] =", "+\t\t\t\t\t\t(byte)((red+red+green+green+green+green+green+blue) >> 3);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tinit (device, newData);", "+\t\tbreak;", "+\tdefault:", "+\t\tSWT.error(SWT.ERROR_INVALID_ARGUMENT);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c133f2fda6a3bc994155f3838dd94cf8", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "tests/org.eclipse.swt.tests/JUnit Tests/org/eclipse/swt/tests/junit/performance/Test_org_eclipse_swt_graphics_GC.java", "commitBeforeChange": "3c3560a8a0694cddb84d310c44e8be981d7200ba", "commitAfterChange": "6a109d46b1134102ab2fd951d1b2441f44e33ab3", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  public void test_drawTextLjava_lang_StringIII()", "signatureAfterChange": "  public void test_drawTextLjava_lang_StringIII()", "diff": ["-public void test_drawTextLjava_lang_StringIII() {\t\t\t", "-\tgc.drawText(\"abc\", 5, 5, 0);", "-\tgc.drawText(\"abc\", 5, 5, SWT.DRAW_TRANSPARENT);", "-\tgc.drawText(\"abc\", 5, 5, SWT.DRAW_DELIMITER);", "-\tgc.drawText(\"abc\", 5, 5, SWT.DRAW_MNEMONIC);", "-\tgc.drawText(\"abc\", 5, 5, SWT.DRAW_TAB);", "-\tgc.drawText(\"\", 0, 0, 0);", "-\tgc.drawText(\"\", 0, 0, SWT.DRAW_TRANSPARENT);\t\t\t\t", "-\tgc.drawText(\"\", 0, 0, SWT.DRAW_DELIMITER);\t\t\t\t", "-\tgc.drawText(\"\", 0, 0, SWT.DRAW_MNEMONIC);\t\t\t\t", "-\tgc.drawText(\"\", 0, 0, SWT.DRAW_TAB);\t\t\t\t", "-\tgc.drawText(\"\\t\\r\\na&bc&\", 5, 5, 0);", "-\tgc.drawText(\"\\t\\r\\na&bc&\", 5, 5, SWT.DRAW_TRANSPARENT);", "-\tgc.drawText(\"\\t\\r\\na&bc&\", 5, 5, SWT.DRAW_DELIMITER);", "-\tgc.drawText(\"\\t\\r\\na&bc&\", 5, 5, SWT.DRAW_MNEMONIC);", "-\tgc.drawText(\"\\t\\r\\na&bc&\", 5, 5, SWT.DRAW_TAB);", "-\tgc.drawText(\"\\r\", 5, 5, SWT.DRAW_DELIMITER);", "-\tgc.drawText(\"\\n\", 5, 5, SWT.DRAW_DELIMITER);", "-\tgc.drawText(\"&\", 5, 5, SWT.DRAW_MNEMONIC);", "-\tgc.drawText(\"\\t\", 5, 5, SWT.DRAW_TAB);", "+public void test_drawTextLjava_lang_StringIII() {", "+\t// precompute points", "+\tRectangle bounds = gc.getClipping();", "+\tfinal int[][] coords = new int[COUNT][];", "+\tint y = 0;", "+\tfor (int i = 0; i < COUNT; i++) {", "+\t\tint x = i % bounds.width;", "+\t\tcoords[i] = new int[] {x,y};", "+\t\tif (x == 0) y += 3;", "+\t}", "+\t", "+\tPerformanceMeter meter = createMeter(\"transparent\");", "+\tmeter.start();", "+\tfor (int i = 0; i < COUNT; i++) {", "+\t\tgc.drawText(\"\\t\\r\\na&bc&\", coords[i][0], coords[i][1], SWT.DRAW_TRANSPARENT);\t\t\t\t", "+\t}", "+\tmeter.stop();", "+\t", "+\tdisposeMeter(meter);", "+", "+\tmeter = createMeter(\"delimiter\");", "+\tmeter.start();", "+\tfor (int i = 0; i < COUNT; i++) {", "+\t\tgc.drawText(\"\\t\\r\\na&bc&\", coords[i][0], coords[i][1], SWT.DRAW_DELIMITER);\t\t\t\t", "+\t}", "+\tmeter.stop();", "+\t", "+\tdisposeMeter(meter);", "+", "+\tmeter = createMeter(\"mnemonic\");", "+\tmeter.start();", "+\tfor (int i = 0; i < COUNT; i++) {", "+\t\tgc.drawText(\"\\t\\r\\na&bc&\", coords[i][0], coords[i][1], SWT.DRAW_MNEMONIC);\t\t\t\t", "+\t}", "+\tmeter.stop();", "+\t", "+\tdisposeMeter(meter);", "+", "+\tmeter = createMeter(\"tab\");", "+\tmeter.start();", "+\tfor (int i = 0; i < COUNT; i++) {", "+\t\tgc.drawText(\"\\t\\r\\na&bc&\", coords[i][0], coords[i][1], SWT.DRAW_TAB);\t\t\t\t", "+\t}", "+\tmeter.stop();", "+\t", "+\tdisposeMeter(meter);", "+\t", "+\tmeter = createMeter(\"no flags\");", "+\tmeter.start();", "+\tfor (int i = 0; i < COUNT; i++) {", "+\t\tgc.drawText(\"\\t\\r\\na&bc&\", coords[i][0], coords[i][1], SWT.NONE);\t\t\t\t", "+\t}", "+\tmeter.stop();", "+\t", "+\tdisposeMeter(meter);"]}], "num": 3793}