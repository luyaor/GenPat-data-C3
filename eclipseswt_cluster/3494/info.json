{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a9488b6ed11aa238eca50ae29af48640", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e175c981906db7400f03ccb2f9b48c50", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/TreeItem2.java", "commitBeforeChange": "ed568a606dfba062e77bacc7c7f799741b60cbf4", "commitAfterChange": "3e04f21595fe557524d009b946647c76885ec76f", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 68, "signatureBeforeChange": " public void setFont (Font value)", "signatureAfterChange": " public void setFont (Font font)", "diff": ["-public void setFont (Font value) {", "-\tcheckWidget ();", "-\tif (value != null && value.isDisposed ()) {", "-\t\tSWT.error (SWT.ERROR_INVALID_ARGUMENT);", "-\t}", "-\tif (font == value) return;", "-\tif (value != null && value.equals (font)) return;", "-\t", "-\tfont = value;", "-\t/* recompute cached values for string measurements */", "-\tGC gc = new GC (parent);", "-\tgc.setFont (getFont ());", "-\trecomputeTextWidths (gc);", "-\tfontHeight = gc.getFontMetrics ().getHeight ();", "-\tgc.dispose ();", "-\tredrawItem ();", "-}", "+ */", "+public void setFont (Font font){", "+\tcheckWidget ();", "+\tif (font != null && font.isDisposed ()) {", "+\t\tSWT.error (SWT.ERROR_INVALID_ARGUMENT);", "+\t}", "+\tif (this.font == font) return;", "+\tif (this.font != null && this.font.equals (font)) return;", "+\tthis.font = font;", "+\tredraw ();", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1cd4a07fa334a01f80d54fa8db8d53eb", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Accessibility/win32/org/eclipse/swt/accessibility/Accessible.java", "commitBeforeChange": "bd4d1f77f4b1ff6b81882d3d6af94d27dd6eef79", "commitAfterChange": "a29ead267e20209d48db539a375ce453914d2d9b", "methodNumberBeforeChange": 64, "methodNumberAfterChange": 64, "signatureBeforeChange": " \t \tint get_accRole(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pvarRole)", "signatureAfterChange": " \t \tint get_accRole(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pvarRole)", "diff": ["+\t\tevent.childID = osToChildID(varChild_lVal);", "-\t\tif (varChild_lVal == COM.CHILDID_SELF) {", "-\t\t\tevent.childID = ACC.CHILDID_SELF;", "-\t\t} else {", "-\t\t\tif (control instanceof Tree) {", "-\t\t\t\t/* Tree item childIDs are pointers (not 1-based indices). */", "-\t\t\t\tevent.childID = varChild_lVal;", "-\t\t\t\t", "-\t\t\t\t// TEMPORARY CODE", "-\t\t\t\t/* Currently our checkbox tree is emulated using state mask images,", "-\t\t\t\t * so we need to specify 'checkbox' role for the items here. */", "+\t\t// TEMPORARY CODE", "+\t\t/* Currently our checkbox table and tree are emulated using state mask", "+\t\t * images, so we need to specify 'checkbox' role for the items. */", "+\t\tif (varChild_lVal != COM.CHILDID_SELF) {", "+\t\t\tif (control instanceof Tree || control instanceof Table) {", "-\t\t\t} else if (control instanceof Table) {", "-\t\t\t\tevent.childID = varChild_lVal - 1;", "-\t\t\t\t", "-\t\t\t\t// TEMPORARY CODE", "-\t\t\t\t/* Currently our checkbox table is emulated using state mask images,", "-\t\t\t\t * so we need to specify 'checkbox' role for the items here. */", "-\t\t\t\tif ((control.getStyle() & SWT.CHECK) != 0) event.detail = ACC.ROLE_CHECKBUTTON;", "-\t\t\t} else {", "-\t\t\t\tevent.childID = varChild_lVal - 1;"]}], "num": 3494}