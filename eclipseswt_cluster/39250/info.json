{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9f68354bfdfc1120f5398c6b533fd7cb", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2b317e263a201e91eaa3307b8dddf8f4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "44290f0c2132e0d8e6042a6f2d011231dac5a128", "commitAfterChange": "bf96c511171a3f65f9ce4a22c5a5b08d1dd5d976", "methodNumberBeforeChange": 241, "methodNumberAfterChange": 241, "signatureBeforeChange": "  LRESULT WM_WINDOWPOSCHANGING (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_WINDOWPOSCHANGING (int wParam, int lParam)", "diff": ["+\t/*", "+\t* Bug in Windows.  When WM_SETREDRAW is used to turn off drawing", "+\t* for a control and the control is moved or resized, Windows does", "+\t* not redraw the area where the control once was in the parent.", "+\t* The fix is to detect this case and redraw the area.", "+\t*/", "+\tif (drawCount != 0) {", "+\t\tShell shell = getShell ();", "+\t\tif (shell != this) {", "+\t\t\tWINDOWPOS lpwp = new WINDOWPOS ();", "+\t\t\tOS.MoveMemory (lpwp, lParam, WINDOWPOS.sizeof);", "+\t\t\tif ((lpwp.flags & OS.SWP_NOMOVE) == 0 || (lpwp.flags & OS.SWP_NOSIZE) == 0) {", "+\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\tOS.GetWindowRect (topHandle (), rect);", "+\t\t\t\tint hwndParent = parent == null ? 0 : parent.handle;", "+\t\t\t\tOS.MapWindowPoints (0, hwndParent, rect, 2);", "+\t\t\t\tOS.InvalidateRect (hwndParent, rect, true);", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "42ba7aa94979810daeaccb21911c7d09", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Widget.java", "commitBeforeChange": "e170e2bc039501aa7c5918930966f5f032805092", "commitAfterChange": "110b4344af4c3f47d218fd3738d3496877c5fb78", "methodNumberBeforeChange": 140, "methodNumberAfterChange": 140, "signatureBeforeChange": "  int setBounds (int control, int x, int y, int width, int height, boolean move, boolean resize, boolean events)", "signatureAfterChange": "  int setBounds (int control, int x, int y, int width, int height, boolean move, boolean resize, boolean events)", "diff": ["+\t/*", "+\t* Bug in the Macintosh.  When HIViewSetDrawingEnabled() is used to", "+\t* turn off drawing for a control and the control is moved or resized, ", "+\t* the Mac does not redraw the area where the control once was in the", "+\t* parent.  The fix is to detect this case and redraw the area.", "+\t*/", "+\tif (!OS.HIViewIsDrawingEnabled (control)) {", "+\t\tint parent = OS.HIViewGetSuperview (control);", "+\t\tif (parent != 0 && OS.HIViewIsDrawingEnabled (parent)) {", "+\t\t\tint rgn = OS.NewRgn ();", "+\t\t\tRect rect = new Rect ();", "+\t\t\tOS.SetRect (rect, (short) oldBounds.x, (short) oldBounds.y, (short) (oldBounds.x + oldBounds.width), (short) (oldBounds.y + oldBounds.height));", "+\t\t\tOS.RectRgn (rgn, rect);", "+\t\t\tif (display.inPaint) {", "+\t\t\t\tOS.HIViewConvertRegion (rgn, parent, 0);", "+\t\t\t\tinvalWindowRgn (0, rgn);", "+\t\t\t} else {", "+\t\t\t\tOS.HIViewSetNeedsDisplayInRegion (parent, rgn, true);", "+\t\t\t}", "+\t\t\tOS.DisposeRgn (rgn);", "+\t\t}", "+\t}", "+"]}], "num": 39250}