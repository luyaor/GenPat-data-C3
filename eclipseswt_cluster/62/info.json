{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "55f8559175c04fe1f168b8593fc13088", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "81918bf2b7e0bb33e9fbe8073fdfc973", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/TreeItem.java", "commitBeforeChange": "4554e604711848107217e581c2ea19dd3a200ccc", "commitAfterChange": "943950684f8a4ea21db196bca596eabbe07db1ea", "methodNumberBeforeChange": 85, "methodNumberAfterChange": 85, "signatureBeforeChange": " public void setImage (int columnIndex, Image value)", "signatureAfterChange": " public void setImage (int columnIndex, Image value)", "diff": ["-\t", "+", "-\t/*", "-\t * If this is the first image being put into the tree then its item height", "-\t * may be adjusted, in which case a full redraw is needed.", "-\t */", "-\tif (parent.imageHeight == 0) {", "-\t\tint oldItemHeight = parent.itemHeight;", "-\t\tparent.setImageHeight (value.getBounds ().height);", "-\t\tif (oldItemHeight != parent.itemHeight) {", "-\t\t\tif (columnIndex == 0) {", "-\t\t\t\tparent.col0ImageWidth = value.getBounds ().width;", "-\t\t\t\tif (columns.length > 0) {", "-\t\t\t\t\t/* ", "-\t\t\t\t\t * All column 0 cells will now have less room available for their texts,", "-\t\t\t\t\t * so all items must now recompute their column 0 displayTexts.", "-\t\t\t\t\t */", "-\t\t\t\t\tGC gc = new GC (parent);", "-\t\t\t\t\tTreeItem[] rootItems = parent.items;", "-\t\t\t\t\tfor (int i = 0; i < rootItems.length; i++) {", "-\t\t\t\t\t\trootItems [i].updateColumnWidth (columns [0], gc);", "-\t\t\t\t\t}", "-\t\t\t\t\tgc.dispose ();", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tparent.redraw ();", "-\t\t\treturn;", "+\tif (columns.length == 0) {", "+\t\tif (parent.imageHeight == 0) {", "+\t\t\t/* this is the first image being put into the parent Tree */", "+\t\t\tRectangle bounds = value.getBounds ();", "+\t\t\tparent.orderedCol0imageWidth = bounds.width;", "+\t\t\tparent.setImageHeight (bounds.height);", "+\t\t\tparent.redrawItems (0, parent.availableItemsCount - 1, false);", "+\t\t} else {", "+\t\t\tredrawItem ();", "+\t\treturn;", "-\t/* ", "-\t * If this is the first image being put into column 0 then all cells", "-\t * in the column should also indent accordingly. ", "-\t */", "-\tif (columnIndex == 0 && parent.col0ImageWidth == 0) {", "-\t\tparent.col0ImageWidth = value.getBounds ().width;", "-\t\t/* redraw the column */", "-\t\tif (columns.length == 0) {", "-\t\t\tparent.redraw ();", "-\t\t} else {", "+\t/* there are 1+ columns */", "+\tTreeColumn column = columns [columnIndex];", "+\tint orderedIndex = column.getOrderIndex ();", "+\tRectangle bounds = value.getBounds ();", "+\tif (column.itemImageWidth == 0) column.itemImageWidth = bounds.width;", "+", "+\tif (parent.imageHeight == 0) {", "+\t\t/* this is the first image being put into the parent Tree */", "+\t\tint oldItemHeight = parent.itemHeight;", "+\t\tparent.setImageHeight (bounds.height);", "+", "+\t\tif (orderedIndex == 0) {\t/* the first ordered column */", "+\t\t\tparent.orderedCol0imageWidth = bounds.width;", "-\t\t\tGC gc = new GC (parent);", "+\t\t\tGC gc = new GC (parent);", "-\t\t\t\trootItems [i].updateColumnWidth (columns [0], gc);", "+\t\t\t\trootItems [i].updateColumnWidth (column, gc);", "-\t\t\tparent.redraw (", "-\t\t\t\tcolumns [0].getX (), 0,", "-\t\t\t\tcolumns [0].width,", "-\t\t\t\tparent.getClientArea ().height,", "-\t\t\t\ttrue);", "+\t\t\tif (oldItemHeight != parent.itemHeight) {", "+\t\t\t\t/* the item height grew as a result of the new image height, so redraw everything */", "+\t\t\t\tparent.redraw ();", "+\t\t\t} else {", "+\t\t\t\t/* redraw the column since all items should now have image space */", "+\t\t\t\tparent.redraw (column.getX (), 0, column.width, parent.getClientArea ().height, false);", "+\t\t\t}", "+\t\t} else {\t/* not the first ordered column */", "+\t\t\tif (oldItemHeight != parent.itemHeight) {", "+\t\t\t\t/* the item height grew as a result of the new image height, so redraw everything */", "+\t\t\t\tparent.redraw ();", "+\t\t\t} else {", "+\t\t\t\tredrawItem ();", "+\t\t\t}", "+", "+\tif (orderedIndex == 0 && parent.orderedCol0imageWidth == 0) {", "+\t\t/* this is the first image being put into the current ordered column 0 */", "+\t\tparent.orderedCol0imageWidth = bounds.width;", "+\t\t/* ", "+\t\t * All column 0 cells will now have less room available for their texts,", "+\t\t * so all items must now recompute their column 0 displayTexts.", "+\t\t */", "+\t\tTreeItem[] rootItems = parent.items;", "+\t\tGC gc = new GC (parent);", "+\t\tfor (int i = 0; i < rootItems.length; i++) {", "+\t\t\trootItems [i].updateColumnWidth (column, gc);", "+\t\t}", "+\t\tgc.dispose ();", "+\t\tparent.redraw (column.getX (), 0, column.width, parent.getClientArea ().height, false);", "+\t\treturn;", "+\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d3f25403d312cd5f2b57f514ba3a827", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/TableItem.java", "commitBeforeChange": "ed6471c0ec0d0ee0c1436d2bdeadc8ba513ab4fd", "commitAfterChange": "034d8fba7f4ca7576ddaeee539a2fb56ee664327", "methodNumberBeforeChange": 64, "methodNumberAfterChange": 53, "signatureBeforeChange": " public void setImage(int index, Image image)", "signatureAfterChange": " public void setImage (int columnIndex, Image value)", "diff": ["- */", "-public void setImage(int index, Image image) {", "-\tcheckWidget();\t", "-\tif (getParent().indexOf(this) != -1) {", "-\t\tinternalSetImage(index, image);", "-\t}", "-}", "+}", "+public void setImage (int columnIndex, Image value) {", "+\tcheckWidget ();", "+\tif (value != null && value.isDisposed ()) error (SWT.ERROR_INVALID_ARGUMENT);", "+", "+\tTableColumn[] columns = parent.columns;", "+\tint validColumnCount = Math.max (1, columns.length);", "+\tif (!(0 <= columnIndex && columnIndex < validColumnCount)) return;", "+\tImage image = getImage (columnIndex);", "+\tif (value == image) return;", "+\tif (value != null && value.equals (image)) return;", "+\tif (columnIndex == 0) {", "+\t\tsuper.setImage (value);", "+\t} else {", "+\t\timages [columnIndex] = value;", "+\t}", "+\t", "+\t/* ", "+\t * An image width change may affect the space available for the item text, so", "+\t * recompute the displayText if there are columns.", "+\t */", "+\tif (columns.length > 0) {", "+\t\tGC gc = new GC (parent);", "+\t\tgc.setFont (getFont (columnIndex));", "+\t\tcomputeDisplayText (columnIndex, gc);", "+\t\ttextWidths [columnIndex] = gc.textExtent (getDisplayText (columnIndex)).x;", "+\t\tgc.dispose ();", "+\t}", "+\t", "+\tif (value == null) {", "+\t\tredrawItem ();", "+\t\treturn;", "+\t}", "+", "+\t/*", "+\t * If this is the first image being put into the table then its item height", "+\t * may be adjusted, in which case a full redraw is needed.", "+\t */", "+\tif (parent.imageHeight == 0) {", "+\t\tint oldItemHeight = parent.itemHeight;", "+\t\tparent.setImageHeight (value.getBounds ().height);", "+\t\tif (oldItemHeight != parent.itemHeight) {", "+\t\t\tif (columnIndex == 0) {", "+\t\t\t\tparent.col0ImageWidth = value.getBounds ().width;", "+\t\t\t\tif (columns.length > 0) {", "+\t\t\t\t\t/* ", "+\t\t\t\t\t * All column 0 cells will now have less room available for their texts,", "+\t\t\t\t\t * so all items must now recompute their column 0 displayTexts.", "+\t\t\t\t\t */", "+\t\t\t\t\tGC gc = new GC (parent);", "+\t\t\t\t\tTableItem[] rootItems = parent.items;", "+\t\t\t\t\tfor (int i = 0; i < rootItems.length; i++) {", "+\t\t\t\t\t\trootItems [i].updateColumnWidth (columns [0], gc);", "+\t\t\t\t\t}", "+\t\t\t\t\tgc.dispose ();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tparent.redraw ();", "+\t\t\treturn;", "+\t\t}", "+\t}", "+", "+\t/* ", "+\t * If this is the first image being put into column 0 then all cells", "+\t * in the column should also indent accordingly. ", "+\t */", "+\tif (columnIndex == 0 && parent.col0ImageWidth == 0) {", "+\t\tparent.col0ImageWidth = value.getBounds ().width;", "+\t\t/* redraw the column */", "+\t\tif (columns.length == 0) {", "+\t\t\tparent.redraw ();", "+\t\t} else {", "+\t\t\t/* ", "+\t\t\t * All column 0 cells will now have less room available for their texts,", "+\t\t\t * so all items must now recompute their column 0 displayTexts.", "+\t\t\t */", "+\t\t\tGC gc = new GC (parent);", "+\t\t\tTableItem[] rootItems = parent.items;", "+\t\t\tfor (int i = 0; i < rootItems.length; i++) {", "+\t\t\t\trootItems [i].updateColumnWidth (columns [0], gc);", "+\t\t\t}", "+\t\t\tgc.dispose ();", "+\t\t\tparent.redraw (", "+\t\t\t\t0, 0,", "+\t\t\t\tcolumns [0].width,", "+\t\t\t\tparent.getClientArea ().height,", "+\t\t\t\ttrue);", "+\t\t}", "+\t\treturn;", "+\t}", "+\tredrawItem ();", "+}"]}], "num": 62}