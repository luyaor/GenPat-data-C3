{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9d94036c627bd3f015f0af8229cd3e20", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "31ed19a30a087f75f349ef30b63b27b5", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "71485db964ebcb95e375837f2ec386eabc8e1c34", "commitAfterChange": "e4de5e48d2fd11782d0a2d1c87edee6f302ca529", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 76, "signatureBeforeChange": " protected void init ()", "signatureAfterChange": " protected void init ()", "diff": ["-\t\tinitApplicationDelegate();\t", "-\t\tapplication.finishLaunching();", "+\t\tinitApplicationDelegate();", "+\t\t", "+\t\t/*", "+\t\t * Feature in Cocoa:  NSApplication.finishLaunching() adds an apple menu to the menu bar that isn't accessible via NSMenu.", "+\t\t * If Display objects are created and disposed of multiple times in a single process, another apple menu is added to the menu bar.", "+\t\t * It must be called or the dock icon will continue to bounce. So, it should only be called once per process, not just once per", "+\t\t * creation of a Display.  Use a static so creation of additional Display objects won't affect the menu bar. ", "+\t\t */", "+\t\tif (!Display.launched) {", "+\t\t\tapplication.finishLaunching();", "+\t\t\tDisplay.launched = true;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3582d43c9c08ba3a3b73528f1012b486", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Menu.java", "commitBeforeChange": "aab8dd4993a78017d2de4c49a90a757b1ca40959", "commitAfterChange": "5f3a8439f61d1979e8da01885ce0be35b7ee51d3", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": "  int kEventMenuOpening (int nextHandler, int theEvent, int userData)", "signatureAfterChange": "  int kEventMenuOpening (int nextHandler, int theEvent, int userData)", "diff": ["-\t\tsendEvent (SWT.Show);", "-\t\tmodified = false;", "+\t\t/*", "+\t\t* Feature in the Macintosh.  In order to populate the search field of", "+\t\t* the help menu, the events kEventMenuOpening, kEventMenuClosed and", "+\t\t* others are sent to sub menus even when the cascade item of the submenu", "+\t\t* is disabled.  Normally, the user can never get to these submenus.", "+\t\t* This means that application code does not expect SWT.Show and SWT.Hide", "+\t\t* events.  The fix is to avoid the events when the cascade item is", "+\t\t* disabled.", "+\t\t*/", "+\t\tboolean send = true;", "+\t\tif (cascade != null && !cascade.getEnabled ()) send = false;", "+\t\tif (send) {", "+\t\t\tsendEvent (SWT.Show);", "+\t\t\tmodified = false;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d5fd4d60b48cf66d40edb7930e73c9b0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "7385bf0701e2baaa9eb397987f631a8e3608d059", "commitAfterChange": "cabce7a504b376ba4a2bbe191acc5449e828a45a", "methodNumberBeforeChange": 79, "methodNumberAfterChange": 79, "signatureBeforeChange": "  LRESULT sendMouseDownEvent (int type, int button, int msg, int wParam, int lParam)", "signatureAfterChange": "  LRESULT sendMouseDownEvent (int type, int button, int msg, int wParam, int lParam)", "diff": ["-\tboolean dragDetect = (state & DRAG_DETECT) != 0;", "+\t/*", "+\t* Feature in Windows.  Inside WM_LBUTTONDOWN and WM_RBUTTONDOWN,", "+\t* the widget starts a modal loop to determine if the user wants", "+\t* to begin a drag/drop operation or marque select.  This modal", "+\t* loop eats mouse events until a drag is detected.  The fix is", "+\t* to avoid this behavior by only running the drag and drop when", "+\t* the event is hooked and the mouse is over an item.", "+\t*/", "+\tboolean dragDetect = (state & DRAG_DETECT) != 0 && hooks (SWT.DragDetect);", "+\tif (!dragDetect) {", "+\t\tint flags = OS.LVHT_ONITEMICON | OS.LVHT_ONITEMLABEL;", "+\t\tdragDetect = pinfo.iItem == -1 || (pinfo.flags & flags) == 0;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a382adf0e4cdc5b6031113b768c40516", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Mozilla/common/org/eclipse/swt/browser/Mozilla.java", "commitBeforeChange": "68c806c67ab749e6cce9971643b0bff5edff9d71", "commitAfterChange": "2af93dbd1644168624ca28d452a4ce599d0e9d63", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public void create (Composite parent, int style)", "signatureAfterChange": "  public void create (Composite parent, int style)", "diff": ["+", "+\t\t/*", "+\t\t* Ensure that windows that are shown during page loads are not blocked.  Firefox may", "+\t\t* try to block these by default since such windows are often unwelcome, but this", "+\t\t* assumption should not be made in the Browser's context.  Since the Browser client", "+\t\t* is responsible for creating the new Browser and Shell in an OpenWindowListener,", "+\t\t* they should decide whether the new window is unwelcome or not and act accordingly. ", "+\t\t*/", "+\t\tbuffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_DISABLEOPENDURINGLOAD, true);", "+\t\trc = prefBranch.SetBoolPref (buffer, 0);", "+\t\tif (rc != XPCOM.NS_OK) {", "+\t\t\tbrowser.dispose ();", "+\t\t\terror (rc);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7f47e1bae90357854ccdceec28c2f7be", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "65a37bcccff2e660b659ef8ed7615bbf040f19bd", "commitAfterChange": "9060990a4adbb740705acd1cea6ae47201f32a47", "methodNumberBeforeChange": 135, "methodNumberAfterChange": 135, "signatureBeforeChange": "  void setMenuBar (Menu menu)", "signatureAfterChange": "  void setMenuBar (Menu menu)", "diff": ["-\t\t\titems[i].nsItem.setMenu(null);", "-\t\t\tmenubar.addItem(items[i].nsItem);", "+\t\t\tMenuItem item = items[i];", "+\t\t\tNSMenuItem nsItem = item.nsItem;", "+\t\t\tnsItem.setMenu(null);", "+\t\t\tmenubar.addItem(nsItem);", "+\t\t\t", "+\t\t\t/*", "+\t\t\t* Bug in Cocoa: Calling NSMenuItem.setEnabled() for menu item of a menu bar only", "+\t\t\t* works when the menu bar is the current menu bar.  The underline OS menu does get", "+\t\t\t* enabled/disable when that menu is set later on.  The fix is to toggle the", "+\t\t\t* item enabled state to force the underline menu to be updated.  ", "+\t\t\t*/", "+\t\t\tboolean enabled = menu.getEnabled () && item.getEnabled ();", "+\t\t\tnsItem.setEnabled(!enabled);", "+\t\t\tnsItem.setEnabled(enabled);"]}], "num": 60055}