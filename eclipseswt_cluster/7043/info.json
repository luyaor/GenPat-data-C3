{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f2bb95873c4ca894c874263df53f8f11", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5589a248cf7899ca6d2bf9f300b262ee", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Widget.java", "commitBeforeChange": "22de0ea22c2d2d4f45ea2d42713f45532f3dae10", "commitAfterChange": "c2238720db4daf5a12590fa4578a04a7b36dabc4", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 43, "signatureBeforeChange": "  boolean setKeyState (Event event, int type)", "signatureAfterChange": "  boolean setKeyState (Event event, int type, int wParam, int lParam)", "diff": ["-boolean setKeyState (Event event, int type) {", "-\tif (display.lastAscii != 0 || display.lastNull) {", "-\t\tevent.character = mbcsToWcs ((char) display.lastAscii);", "+boolean setKeyState (Event event, int type, int wParam, int lParam) {", "+\t", "+\t/*", "+\t* Feature in Windows.  When the user presses Ctrl+Backspace", "+\t* or Ctrl+Enter, Windows sends a WM_CHAR with Delete (0x7F)", "+\t* and '\\n' instead of '\\b' and '\\r'.  This is the correct", "+\t* platform behavior but is not portable.  The fix is detect", "+\t* these cases and convert the character.", "+\t*/", "+\tswitch (display.lastAscii) {", "+\t\tcase SWT.DEL:", "+\t\t\tif (display.lastKey == SWT.BS) display.lastAscii = SWT.BS;", "+\t\t\tbreak;", "+\t\tcase SWT.LF:", "+\t\t\tif (display.lastKey == SWT.CR) display.lastAscii = SWT.CR;", "+\t\t\tbreak;", "+\t}", "+\t", "+\t/*", "+\t* Feature in Windows.  When the user presses either the Enter", "+\t* key or the numeric keypad Enter key, Windows sends a WM_KEYDOWN", "+\t* with wParam=VK_RETURN in both cases.  In order to distinguish", "+\t* between the keys, the extended key bit is tested. If the bit", "+\t* is set, assume that the numeric keypad Enter was pressed. ", "+\t*/", "+\tif (display.lastKey == SWT.CR && display.lastAscii == SWT.CR) {", "+\t\tif ((lParam & 0x1000000) != 0) display.lastKey = SWT.KEYPAD_CR;", "+\t}", "+\t", "+\tif (display.lastVirtual) {", "+\t\t/*", "+\t\t* Feature in Windows.  The virtual key VK_DELETE is not", "+\t\t* treated as both a virtual key and an ASCII key by Windows.", "+\t\t* Therefore, we will not receive a WM_CHAR for this key.", "+\t\t* The fix is to treat VK_DELETE as a special case and map", "+\t\t* the ASCII value explictly (Delete is 0x7F).", "+\t\t*/", "+\t\tif (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;", "+\t\t", "+\t\tevent.keyCode = Display.translateKey (display.lastKey);", "+\t} else {", "-\tif (display.lastVirtual) {", "-\t\tevent.keyCode = Display.translateKey (display.lastKey);", "+\tif (display.lastAscii != 0 || display.lastNull) {", "+\t\tevent.character = mbcsToWcs ((char) display.lastAscii);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d11338b33d70bf80666c876efa63c71", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "2be9e13d76720c8ac383dbac01e6474ca4b95d97", "commitAfterChange": "c5f42b132fb6ee889f8d79e00b89d2fd8962bd6f", "methodNumberBeforeChange": 203, "methodNumberAfterChange": 203, "signatureBeforeChange": "\r \r LRESULT WM_SYSKEYDOWN (int wParam, int lParam)", "signatureAfterChange": "\r \r LRESULT WM_SYSKEYDOWN (int wParam, int lParam)", "diff": ["-\tDisplay display = getDisplay ();\r", "-\r", "-\r", "-\t/* If are going to get a WM_SYSCHAR, ignore this message. */\r", "-\t/*\r", "-\t* Bug on WinCE.  MapVirtualKey() returns incorrect values.\r", "-\t* The fix is to rely on a key mappings table to determine\r", "-\t* whether the key event must be sent now or if a WM_SYSCHAR\r", "-\t* event will follow.\r", "-\t*/\r", "-\tif (!OS.IsWinCE) {\r", "-\t\tif (OS.MapVirtualKey (wParam, 2) != 0) return null;\r", "-\t}\r", "-\t/* Ignore repeating keys for modifiers by testing key down state. */\r", "+\t/* Ignore repeating modifier keys by testing key down state */\r", "+\t\r", "+\t/* Clear last key and last ascii because a new key has been typed */\r", "+\tDisplay display = getDisplay ();\r", "+\tdisplay.lastAscii = display.lastKey = 0;\r", "+\tdisplay.lastVirtual = display.lastNull = false;\r", "-\t/* Set last key and clear last ascii because a new key has been typed. */\r", "-\tdisplay.lastAscii = 0;\r", "+\t/* If are going to get a WM_SYSCHAR, ignore this message. */\r", "+\t/*\r", "+\t* Bug on WinCE.  MapVirtualKey() returns incorrect values.\r", "+\t* The fix is to rely on a key mappings table to determine\r", "+\t* whether the key event must be sent now or if a WM_SYSCHAR\r", "+\t* event will follow.\r", "+\t*/\r", "+\tif (!OS.IsWinCE) {\r", "+\t\tif (OS.MapVirtualKey (wParam, 2) != 0) {\r", "+\t\t\t/*\r", "+\t\t\t* Feature in Windows.  MapVirtualKey() indicates that\r", "+\t\t\t* a WM_SYSCHAR message will occur for Alt+Enter but\r", "+\t\t\t* this message never happens.  The fix is to issue the\r", "+\t\t\t* event from WM_SYSKEYDOWN and map VK_RETURN to '\\r'.\r", "+\t\t\t*/\r", "+\t\t\tif (wParam != OS.VK_RETURN) return null;\r", "+\t\t\tdisplay.lastAscii = '\\r';\r", "+\t\t}\r", "+\t}\r", "-\tdisplay.lastNull = false;\r", "-\r", "+\t\t\r", "+\t/*\r", "+\t* Feature in Windows.  The virtual key VK_DELETE is not\r", "+\t* treated as both a virtual key and an ASCII key by Windows.\r", "+\t* Therefore, we will not receive a WM_CHAR for this key.\r", "+\t* The fix is to treat VK_DELETE as a special case and map\r", "+\t* the ASCII value explictly (Delete is 0x7F).\r", "+\t*/\r", "+\tif (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;\r", "+\t\r", "+\t/*\r", "+\t* It is possible to get a WM_CHAR for a virtual key when\r", "+\t* Num Lock is on.  If the user types Home while Num Lock \r", "+\t* is down, a WM_CHAR is issued with WPARM=55 (for the\r", "+\t* character 7).  If we are going to get a WM_CHAR we need\r", "+\t* to ensure that the last key has the correct value.  Note\r", "+\t* that Ctrl+Home does not issue a WM_CHAR when Num Lock is\r", "+\t* down.\r", "+\t*/\r", "+\tif (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {\r", "+\t\tif (display.asciiKey (display.lastKey) != 0) return null;\r", "+\t}\r", "+\t\r"]}], "num": 7043}