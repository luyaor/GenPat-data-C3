{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a502b63720bb197d34176a79b26eadbd", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "10ab0942cdab034e246c894c4e55bd24", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples/org/eclipse/swt/examples/fileviewer/FileViewer.java", "commitBeforeChange": "b2da8a118902d606ae445a20741ea4a19a768aa3", "commitAfterChange": "47884fba258eaf32953b79a2e1cef98747fa3e4e", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 49, "signatureBeforeChange": " void notifySelectedDirectory(File dir)", "signatureAfterChange": "\r \tvoid notifySelectedDirectory(File dir)", "diff": ["-\t/* package */ void notifySelectedDirectory(File dir) {\r", "+\tvoid notifySelectedDirectory(File dir) {\r", "+\t\tnotifySelectedFiles(null);\r", "+\t\t\r", "+\t\t/* Shell:\r", "+\t\t * Sets the title to indicate the selected directory\r", "+\t\t */\r", "-\r\t\t// Notify the other components\r", "-\t\tcomboView.selectedDirectory(dir);\r", "-\t\ttreeView.selectedDirectory(dir);\r", "-\t\ttableView.selectedDirectory(dir);\r", "+\r\t\t/* Table view:\r", "+\t\t * Displays the contents of the selected directory.\r", "+\t\t */\r", "+\t\tworkerUpdate(dir, false);\r", "+\r", "+\t\t/* Combo view:\r", "+\t\t * Sets the combo box to point to the selected directory.\r", "+\t\t */\r", "+\t\tfinal File[] comboRoots = (File[]) combo.getData(COMBODATA_ROOTS);\r", "+\t\tint comboEntry = -1;\r", "+\t\tif (comboRoots != null) {\t\t\r", "+\t\t\tfor (int i = 0; i < comboRoots.length; ++i) {\r", "+\t\t\t\tif (dir.equals(comboRoots[i])) {\r", "+\t\t\t\t\tcomboEntry = i;\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (comboEntry == -1) combo.setText(dir.getPath());\r", "+\t\telse combo.select(comboEntry);\r", "+\r", "+\t\t/* Tree view:\r", "+\t\t * If not already expanded, recursively expands the parents of the specified\r", "+\t\t * directory until it is visible.\r", "+\t\t */\r", "+\t\tVector /* of File */ path = new Vector();\r", "+\t\t// Build a stack of paths from the root of the tree\r", "+\t\twhile (dir != null) {\r", "+\t\t\tpath.add(dir);\r", "+\t\t\tdir = dir.getParentFile();\r", "+\t\t}\r", "+\t\t// Recursively expand the tree to get to the specified directory\r", "+\t\tTreeItem[] items = tree.getItems();\r", "+\t\tTreeItem lastItem = null;\r", "+\t\tfor (int i = path.size() - 1; i >= 0; --i) {\r", "+\t\t\tfinal File pathElement = (File) path.elementAt(i);\r", "+\r", "+\t\t\t// Search for a particular File in the array of tree items\r", "+\t\t\t// No guarantee that the items are sorted in any recognizable fashion, so we'll\r", "+\t\t\t// just sequential scan.  There shouldn't be more than a few thousand entries.\r", "+\t\t\tTreeItem item = null;\r", "+\t\t\tfor (int k = 0; k < items.length; ++k) {\r", "+\t\t\t\titem = items[k];\r", "+\t\t\t\tif (item.isDisposed()) continue;\r", "+\t\t\t\tfinal File itemFile = (File) item.getData(TREEITEMDATA_FILE);\r", "+\t\t\t\tif (itemFile != null && itemFile.equals(pathElement)) break;\r", "+\t\t\t}\r", "+\t\t\tif (item == null) break;\r", "+\t\t\tlastItem = item;\r", "+\t\t\tif (i != 0 && !item.getExpanded()) {\r", "+\t\t\t\ttreeExpandItem(item);\r", "+\t\t\t\titem.setExpanded(true);\r", "+\t\t\t}\r", "+\t\t\titems = item.getItems();\r", "+\t\t}\r", "+\t\ttree.setSelection((lastItem != null) ? new TreeItem[] { lastItem } : new TreeItem[0]);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "23c9dde8e72271ee09d07c40309d2019", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples/src/org/eclipse/swt/examples/fileviewer/FileViewer.java", "commitBeforeChange": "b2da8a118902d606ae445a20741ea4a19a768aa3", "commitAfterChange": "47884fba258eaf32953b79a2e1cef98747fa3e4e", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 49, "signatureBeforeChange": " void notifySelectedDirectory(File dir)", "signatureAfterChange": "\r \tvoid notifySelectedDirectory(File dir)", "diff": ["-\t/* package */ void notifySelectedDirectory(File dir) {\r", "+\tvoid notifySelectedDirectory(File dir) {\r", "+\t\tnotifySelectedFiles(null);\r", "+\t\t\r", "+\t\t/* Shell:\r", "+\t\t * Sets the title to indicate the selected directory\r", "+\t\t */\r", "-\r\t\t// Notify the other components\r", "-\t\tcomboView.selectedDirectory(dir);\r", "-\t\ttreeView.selectedDirectory(dir);\r", "-\t\ttableView.selectedDirectory(dir);\r", "+\r\t\t/* Table view:\r", "+\t\t * Displays the contents of the selected directory.\r", "+\t\t */\r", "+\t\tworkerUpdate(dir, false);\r", "+\r", "+\t\t/* Combo view:\r", "+\t\t * Sets the combo box to point to the selected directory.\r", "+\t\t */\r", "+\t\tfinal File[] comboRoots = (File[]) combo.getData(COMBODATA_ROOTS);\r", "+\t\tint comboEntry = -1;\r", "+\t\tif (comboRoots != null) {\t\t\r", "+\t\t\tfor (int i = 0; i < comboRoots.length; ++i) {\r", "+\t\t\t\tif (dir.equals(comboRoots[i])) {\r", "+\t\t\t\t\tcomboEntry = i;\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (comboEntry == -1) combo.setText(dir.getPath());\r", "+\t\telse combo.select(comboEntry);\r", "+\r", "+\t\t/* Tree view:\r", "+\t\t * If not already expanded, recursively expands the parents of the specified\r", "+\t\t * directory until it is visible.\r", "+\t\t */\r", "+\t\tVector /* of File */ path = new Vector();\r", "+\t\t// Build a stack of paths from the root of the tree\r", "+\t\twhile (dir != null) {\r", "+\t\t\tpath.add(dir);\r", "+\t\t\tdir = dir.getParentFile();\r", "+\t\t}\r", "+\t\t// Recursively expand the tree to get to the specified directory\r", "+\t\tTreeItem[] items = tree.getItems();\r", "+\t\tTreeItem lastItem = null;\r", "+\t\tfor (int i = path.size() - 1; i >= 0; --i) {\r", "+\t\t\tfinal File pathElement = (File) path.elementAt(i);\r", "+\r", "+\t\t\t// Search for a particular File in the array of tree items\r", "+\t\t\t// No guarantee that the items are sorted in any recognizable fashion, so we'll\r", "+\t\t\t// just sequential scan.  There shouldn't be more than a few thousand entries.\r", "+\t\t\tTreeItem item = null;\r", "+\t\t\tfor (int k = 0; k < items.length; ++k) {\r", "+\t\t\t\titem = items[k];\r", "+\t\t\t\tif (item.isDisposed()) continue;\r", "+\t\t\t\tfinal File itemFile = (File) item.getData(TREEITEMDATA_FILE);\r", "+\t\t\t\tif (itemFile != null && itemFile.equals(pathElement)) break;\r", "+\t\t\t}\r", "+\t\t\tif (item == null) break;\r", "+\t\t\tlastItem = item;\r", "+\t\t\tif (i != 0 && !item.getExpanded()) {\r", "+\t\t\t\ttreeExpandItem(item);\r", "+\t\t\t\titem.setExpanded(true);\r", "+\t\t\t}\r", "+\t\t\titems = item.getItems();\r", "+\t\t}\r", "+\t\ttree.setSelection((lastItem != null) ? new TreeItem[] { lastItem } : new TreeItem[0]);\r"]}], "num": 30021}