{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6d0eecefd1139535f44acb688f61be08", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "74a78aa7adfd95613552323a8c4c9289", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "58383f412ad2510abd15afdf3cb00667e6c434a4", "commitAfterChange": "c53caa95e55e48c3856ff305cfe3f6f8e3107f36", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 23, "signatureBeforeChange": "  void drawLines(boolean advance, int graphics, int x, int lineBaseline, int lineUnderlinePos, int lineBottom, StyleItem[] line, int index, int color, RECT clipRect, int alpha)", "signatureAfterChange": "  RECT drawUnderlineGDIP (int graphics, int x, int baseline, int lineUnderlinePos, int lineBottom, StyleItem[] line, int index, int color, int selectionColor, RECT clipRect, RECT pRect, int selectionStart, int selectionEnd, int alpha)", "diff": ["-void drawLines(boolean advance, int /*long*/ graphics, int x, int lineBaseline, int lineUnderlinePos, int lineBottom, StyleItem[] line, int index, int /*long*/ color, RECT clipRect, int alpha) {", "-\tStyleItem run = line[index];", "-\tTextStyle style = run.style;", "-\tif (style == null) return;", "-\tif (!style.underline && !style.strikeout) return;", "-\tint runX = x + run.x;", "-\tint underlineY = lineBaseline - lineUnderlinePos;", "-\tint strikeoutY = lineBaseline - run.strikeoutPos;", "-\tif (advance) {", "-\t\tGdip.Graphics_SetPixelOffsetMode(graphics, Gdip.PixelOffsetModeNone);", "-\t\tint /*long*/ brush = color;", "-\t\tif (style.underline) {", "-\t\t\tif (style.underlineColor != null) {", "-\t\t\t\tint fg = style.underlineColor.handle;", "-\t\t\t\tint argb = ((alpha & 0xFF) << 24) | ((fg >> 16) & 0xFF) | (fg & 0xFF00) | ((fg & 0xFF) << 16);", "-\t\t\t\tint /*long*/ gdiColor = Gdip.Color_new(argb); ", "-\t\t\t\tbrush = Gdip.SolidBrush_new(gdiColor);", "-\t\t\t\tGdip.Color_delete(gdiColor);", "-\t\t\t}", "-\t\t\tswitch (style.underlineStyle) {", "-\t\t\t\tcase SWT.UNDERLINE_SQUIGGLE:", "-\t\t\t\tcase SWT.UNDERLINE_ERROR: {", "-\t\t\t\t\tint squigglyThickness = 1;", "-\t\t\t\t\tint squigglyHeight = 2 * squigglyThickness;", "-\t\t\t\t\tint squigglyY = Math.min(underlineY - squigglyHeight / 2, lineBottom - squigglyHeight - 1);", "-\t\t\t\t\tint squigglyX = runX;", "-\t\t\t\t\tfor (int i = index; i > 0 && style.isAdherentUnderline(line[i - 1].style); i--) {", "-\t\t\t\t\t\tsquigglyX = x + line[i - 1].x;", "-\t\t\t\t\t}", "-\t\t\t\t\tint gstate = 0;", "-\t\t\t\t\tif (clipRect == null) {", "-\t\t\t\t\t\tgstate = Gdip.Graphics_Save(graphics);", "-\t\t\t\t\t\tRect gdipRect = new Rect();", "-\t\t\t\t\t\tgdipRect.X = runX;", "-\t\t\t\t\t\tgdipRect.Y = squigglyY;", "-\t\t\t\t\t\tgdipRect.Width = run.width + 1;", "-\t\t\t\t\t\tgdipRect.Height = squigglyY + squigglyHeight + 1;", "-\t\t\t\t\t\tGdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeIntersect);", "-\t\t\t\t\t}", "-\t\t\t\t\tint[] points = computePolyline(squigglyX, squigglyY, runX + run.width, squigglyY + squigglyHeight);", "-\t\t\t\t\tint /*long*/ pen = Gdip.Pen_new(brush, squigglyThickness);", "-\t\t\t\t\tGdip.Graphics_DrawLines(graphics, pen, points, points.length / 2);", "-\t\t\t\t\tGdip.Pen_delete(pen);", "-\t\t\t\t\tif (gstate != 0) Gdip.Graphics_Restore(graphics, gstate);", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\tcase SWT.UNDERLINE_SINGLE:", "-\t\t\t\t\tGdip.Graphics_FillRectangle(graphics, brush, runX, underlineY, run.width, run.underlineThickness);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase SWT.UNDERLINE_DOUBLE:", "-\t\t\t\t\tGdip.Graphics_FillRectangle(graphics, brush, runX, underlineY, run.width, run.underlineThickness);", "-\t\t\t\t\tGdip.Graphics_FillRectangle(graphics, brush, runX, underlineY + run.underlineThickness * 2, run.width, run.underlineThickness);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase UNDERLINE_IME_THICK:", "-\t\t\t\t\tGdip.Graphics_FillRectangle(graphics, brush, runX - run.underlineThickness, underlineY, run.width, run.underlineThickness * 2);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase UNDERLINE_IME_DOT:", "-\t\t\t\tcase UNDERLINE_IME_DASH: {", "-\t\t\t\t\tint /*long*/ pen = Gdip.Pen_new(brush, 1);", "-\t\t\t\t\tint dashStyle = style.underlineStyle == UNDERLINE_IME_DOT ? Gdip.DashStyleDot : Gdip.DashStyleDash;", "-\t\t\t\t\tGdip.Pen_SetDashStyle(pen, dashStyle);", "-\t\t\t\t\tGdip.Graphics_DrawLine(graphics, pen, runX, underlineY, runX + run.width, underlineY);", "-\t\t\t\t\tGdip.Pen_delete(pen);", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (brush != color) Gdip.SolidBrush_delete(brush);", "-\t\t}", "-\t\tif (style.strikeout) {", "-\t\t\tif (style.strikeoutColor != null) {", "-\t\t\t\tint fg = style.strikeoutColor.handle;", "-\t\t\t\tint argb = ((alpha & 0xFF) << 24) | ((fg >> 16) & 0xFF) | (fg & 0xFF00) | ((fg & 0xFF) << 16);", "-\t\t\t\tint /*long*/ gdiColor = Gdip.Color_new(argb); ", "-\t\t\t\tbrush = Gdip.SolidBrush_new(gdiColor);", "-\t\t\t\tGdip.Color_delete(gdiColor);", "-\t\t\t}", "-\t\t\tGdip.Graphics_FillRectangle(graphics, brush, runX, strikeoutY, run.width, run.strikeoutThickness);", "-\t\t\tif (brush != color) Gdip.SolidBrush_delete(brush);", "-\t\t}", "-\t\tGdip.Graphics_SetPixelOffsetMode(graphics, Gdip.PixelOffsetModeHalf);", "-\t\tint colorRefUnderline = (int)/*64*/color;", "-\t\tint colorRefStrikeout = (int)/*64*/color;", "-\t\tint /*long*/ brushUnderline = 0;", "-\t\tint /*long*/ brushStrikeout = 0;", "-\t\tRECT rect = new RECT();", "-\t\tif (style.underline) {", "-\t\t\tif (style.underlineColor != null) {", "-\t\t\t\tcolorRefUnderline = style.underlineColor.handle;", "-\t\t\t}", "-\t\t\tswitch (style.underlineStyle) {", "-\t\t\t\tcase SWT.UNDERLINE_SQUIGGLE:", "-\t\t\t\tcase SWT.UNDERLINE_ERROR: {", "-\t\t\t\t\tint squigglyThickness = 1;", "-\t\t\t\t\tint squigglyHeight = 2 * squigglyThickness;", "-\t\t\t\t\tint squigglyY = Math.min(underlineY - squigglyHeight / 2, lineBottom - squigglyHeight - 1);", "-\t\t\t\t\tint squigglyX = runX;", "-\t\t\t\t\tfor (int i = index; i > 0 && style.isAdherentUnderline(line[i - 1].style); i--) {", "-\t\t\t\t\t\tsquigglyX = x + line[i - 1].x;", "-\t\t\t\t\t}", "-\t\t\t\t\tint state = OS.SaveDC(graphics);", "-\t\t\t\t\tif (clipRect != null) {", "-\t\t\t\t\t\tOS.IntersectClipRect(graphics, clipRect.left, clipRect.top, clipRect.right, clipRect.bottom);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tOS.IntersectClipRect(graphics, runX, squigglyY, runX + run.width + 1, squigglyY + squigglyHeight + 1);", "-\t\t\t\t\t}", "-\t\t\t\t\tint[] points = computePolyline(squigglyX, squigglyY, runX + run.width, squigglyY + squigglyHeight);", "-\t\t\t\t\tint /*long*/ pen = OS.CreatePen(OS.PS_SOLID, squigglyThickness, colorRefUnderline);", "-\t\t\t\t\tint /*long*/ oldPen = OS.SelectObject(graphics, pen);", "-\t\t\t\t\tOS.Polyline(graphics, points, points.length / 2);", "-\t\t\t\t\tint length = points.length;", "-\t\t\t\t\tif (length >= 2 && squigglyThickness <= 1) {", "-\t\t\t\t\t\tOS.SetPixel (graphics, points[length - 2], points[length - 1], colorRefUnderline);", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.RestoreDC(graphics, state);", "-\t\t\t\t\tOS.SelectObject(graphics, oldPen);", "-\t\t\t\t\tOS.DeleteObject(pen);", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\tcase SWT.UNDERLINE_SINGLE:", "-\t\t\t\t\tbrushUnderline = OS.CreateSolidBrush(colorRefUnderline);", "-\t\t\t\t\tOS.SetRect(rect, runX, underlineY, runX + run.width, underlineY + run.underlineThickness);", "-\t\t\t\t\tif (clipRect != null) {", "-\t\t\t\t\t\trect.left = Math.max(rect.left, clipRect.left);", "-\t\t\t\t\t\trect.right = Math.min(rect.right, clipRect.right);", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.FillRect(graphics, rect, brushUnderline);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase SWT.UNDERLINE_DOUBLE:", "-\t\t\t\t\tbrushUnderline = OS.CreateSolidBrush(colorRefUnderline);", "-\t\t\t\t\tOS.SetRect(rect, runX, underlineY, runX + run.width, underlineY + run.underlineThickness);", "-\t\t\t\t\tif (clipRect != null) {", "-\t\t\t\t\t\trect.left = Math.max(rect.left, clipRect.left);", "-\t\t\t\t\t\trect.right = Math.min(rect.right, clipRect.right);", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.FillRect(graphics, rect, brushUnderline);", "-\t\t\t\t\tOS.SetRect(rect, runX, underlineY + run.underlineThickness * 2, runX + run.width, underlineY + run.underlineThickness * 3);", "-\t\t\t\t\tif (clipRect != null) {", "-\t\t\t\t\t\trect.left = Math.max(rect.left, clipRect.left);", "-\t\t\t\t\t\trect.right = Math.min(rect.right, clipRect.right);", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.FillRect(graphics, rect, brushUnderline);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase UNDERLINE_IME_THICK:", "-\t\t\t\t\tbrushUnderline = OS.CreateSolidBrush(colorRefUnderline);", "-\t\t\t\t\tOS.SetRect(rect, runX, underlineY - run.underlineThickness, runX + run.width, underlineY + run.underlineThickness);", "-\t\t\t\t\tif (clipRect != null) {", "-\t\t\t\t\t\trect.left = Math.max(rect.left, clipRect.left);", "-\t\t\t\t\t\trect.right = Math.min(rect.right, clipRect.right);", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.FillRect(graphics, rect, brushUnderline);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase UNDERLINE_IME_DASH:", "-\t\t\t\tcase UNDERLINE_IME_DOT: {", "-\t\t\t\t\tunderlineY = lineBaseline + run.descent;", "-\t\t\t\t\tint penStyle = style.underlineStyle == UNDERLINE_IME_DASH ? OS.PS_DASH : OS.PS_DOT;", "-\t\t\t\t\tint /*long*/ pen = OS.CreatePen(penStyle, 1, colorRefUnderline);", "-\t\t\t\t\tint /*long*/ oldPen = OS.SelectObject(graphics, pen);", "-\t\t\t\t\tOS.SetRect(rect, runX, underlineY, runX + run.width, underlineY + run.underlineThickness);", "-\t\t\t\t\tif (clipRect != null) {", "-\t\t\t\t\t\trect.left = Math.max(rect.left, clipRect.left);", "-\t\t\t\t\t\trect.right = Math.min(rect.right, clipRect.right);", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.MoveToEx(graphics, rect.left, rect.top, 0);", "-\t\t\t\t\tOS.LineTo(graphics, rect.right, rect.top);", "-\t\t\t\t\tOS.SelectObject(graphics, oldPen);", "-\t\t\t\t\tOS.DeleteObject(pen);", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\tif (style.strikeout) {", "-\t\t\tif (style.strikeoutColor != null) {", "-\t\t\t\tcolorRefStrikeout = style.strikeoutColor.handle;", "-\t\t\t}", "-\t\t\tif (brushUnderline != 0 && colorRefStrikeout == colorRefUnderline) {", "-\t\t\t\tbrushStrikeout = brushUnderline;", "-\t\t\t} else {", "-\t\t\t\tbrushStrikeout = OS.CreateSolidBrush(colorRefStrikeout);", "-\t\t\t}", "-\t\t\tOS.SetRect(rect, runX, strikeoutY, runX + run.width, strikeoutY + run.strikeoutThickness);", "-\t\t\tif (clipRect != null) {", "-\t\t\t\trect.left = Math.max(rect.left, clipRect.left);", "-\t\t\t\trect.right = Math.min(rect.right, clipRect.right);", "-\t\t\t}", "-\t\t\tOS.FillRect(graphics, rect, brushStrikeout);", "-\t\t}", "-\t\tif (brushUnderline != 0) OS.DeleteObject(brushUnderline);", "-\t\tif (brushStrikeout != 0 && brushStrikeout != brushUnderline) OS.DeleteObject(brushStrikeout);", "+", "+RECT drawUnderlineGDIP (int /*long*/ graphics, int x, int baseline, int lineUnderlinePos, int lineBottom, StyleItem[] line, int index, int /*long*/ color, int /*long*/ selectionColor, RECT clipRect, RECT pRect, int selectionStart, int selectionEnd, int alpha) {", "+\tStyleItem run = line[index];", "+\tTextStyle style = run.style;", "+\tif (style == null) return null;", "+\tif (!style.underline) return null;", "+\tclipRect = addClipRect(run, clipRect, pRect, selectionStart, selectionEnd);", "+\tif (index + 1 >= line.length || !style.isAdherentUnderline(line[index + 1].style)) {", "+\t\tint left = run.x;", "+\t\tint start = run.start;", "+\t\tint end = run.start + run.length - 1;", "+\t\tfor (int i = index; i > 0 && style.isAdherentUnderline(line[i - 1].style); i--) {", "+\t\t\tleft = line[i - 1].x;", "+\t\t\tstart = Math.min(start, line[i - 1].start);", "+\t\t\tend = Math.max(end, line[i - 1].start + line[i - 1].length - 1);", "+\t\t}", "+\t\tboolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;", "+\t\tboolean fullSelection = hasSelection && selectionStart <= start && end <= selectionEnd;", "+\t\tint /*long*/ brush = color;", "+\t\tif (style.underlineColor != null) {", "+\t\t\tbrush = createGdipBrush(style.underlineColor, alpha);", "+\t\t\tclipRect = null;", "+\t\t} else {", "+\t\t\tif (fullSelection) {", "+\t\t\t\tbrush = selectionColor;", "+\t\t\t\tclipRect = null;", "+\t\t\t} else {", "+\t\t\t\tif (style.foreground != null) {", "+\t\t\t\t\tbrush = createGdipBrush(style.foreground, alpha);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tRECT rect = new RECT();", "+\t\tOS.SetRect(rect, x + left, baseline - lineUnderlinePos, x + run.x + run.width, baseline - lineUnderlinePos + run.underlineThickness);", "+\t\tRect gdipRect = null;", "+\t\tif (clipRect != null) {", "+\t\t\tif (clipRect.left == -1) clipRect.left = 0;", "+\t\t\tif (clipRect.right == -1) clipRect.right = 0x7ffff;", "+\t\t\tOS.SetRect(clipRect, Math.max(rect.left, clipRect.left), rect.top, Math.min(rect.right, clipRect.right), rect.bottom);", "+\t\t\tgdipRect = new Rect();", "+\t\t\tgdipRect.X = clipRect.left;", "+\t\t\tgdipRect.Y = clipRect.top;", "+\t\t\tgdipRect.Width = clipRect.right - clipRect.left;", "+\t\t\tgdipRect.Height = clipRect.bottom - clipRect.top;", "+\t\t}", "+\t\tint gstate = 0;", "+\t\tGdip.Graphics_SetPixelOffsetMode(graphics, Gdip.PixelOffsetModeNone);", "+\t\tswitch (style.underlineStyle) {", "+\t\t\tcase SWT.UNDERLINE_SQUIGGLE:", "+\t\t\tcase SWT.UNDERLINE_ERROR: {", "+\t\t\t\tint squigglyThickness = 1;", "+\t\t\t\tint squigglyHeight = 2 * squigglyThickness;", "+\t\t\t\tint squigglyY = Math.min(rect.top - squigglyHeight / 2, lineBottom - squigglyHeight - 1);", "+\t\t\t\tint[] points = computePolyline(rect.left, squigglyY, rect.right, squigglyY + squigglyHeight);", "+\t\t\t\tint /*long*/ pen = Gdip.Pen_new(brush, squigglyThickness);", "+\t\t\t\tgstate = Gdip.Graphics_Save(graphics);", "+\t\t\t\tif (gdipRect != null) {", "+\t\t\t\t\tGdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);", "+\t\t\t\t} else {", "+\t\t\t\t\tRect r = new Rect();", "+\t\t\t\t\tr.X = rect.left;", "+\t\t\t\t\tr.Y = squigglyY;", "+\t\t\t\t\tr.Width = rect.right - rect.left;", "+\t\t\t\t\tr.Height = squigglyHeight + 1;", "+\t\t\t\t\tGdip.Graphics_SetClip(graphics, r, Gdip.CombineModeIntersect);", "+\t\t\t\t}", "+\t\t\t\tGdip.Graphics_DrawLines(graphics, pen, points, points.length / 2);", "+\t\t\t\tif (gdipRect != null) {", "+\t\t\t\t\tint /*long*/ selPen = Gdip.Pen_new(selectionColor, squigglyThickness);", "+\t\t\t\t\tGdip.Graphics_Restore(graphics, gstate);", "+\t\t\t\t\tgstate = Gdip.Graphics_Save(graphics);", "+\t\t\t\t\tGdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeIntersect);", "+\t\t\t\t\tGdip.Graphics_DrawLines(graphics, selPen, points, points.length / 2);", "+\t\t\t\t\tGdip.Pen_delete(selPen);", "+\t\t\t\t}", "+\t\t\t\tGdip.Graphics_Restore(graphics, gstate);", "+\t\t\t\tGdip.Pen_delete(pen);", "+\t\t\t\tif (gstate != 0) Gdip.Graphics_Restore(graphics, gstate);", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tcase SWT.UNDERLINE_SINGLE:", "+\t\t\tcase SWT.UNDERLINE_DOUBLE:", "+\t\t\tcase UNDERLINE_IME_THICK:", "+\t\t\t\tif (style.underlineStyle == UNDERLINE_IME_THICK) {", "+\t\t\t\t\trect.top -= run.underlineThickness;", "+\t\t\t\t}", "+\t\t\t\tif (gdipRect != null) {", "+\t\t\t\t\tgstate = Gdip.Graphics_Save(graphics);", "+\t\t\t\t\tGdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);", "+\t\t\t\t}", "+\t\t\t\tGdip.Graphics_FillRectangle(graphics, brush, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);", "+\t\t\t\tif (style.underlineStyle == SWT.UNDERLINE_DOUBLE) {", "+\t\t\t\t\tGdip.Graphics_FillRectangle(graphics, brush, rect.left, rect.top + run.underlineThickness * 2, rect.right - rect.left, rect.bottom - rect.top);", "+\t\t\t\t}", "+\t\t\t\tif (gdipRect != null) {", "+\t\t\t\t\tGdip.Graphics_Restore(graphics, gstate);", "+\t\t\t\t\tgstate = Gdip.Graphics_Save(graphics);", "+\t\t\t\t\tGdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeIntersect);", "+\t\t\t\t\tGdip.Graphics_FillRectangle(graphics, selectionColor, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);", "+\t\t\t\t\tif (style.underlineStyle == SWT.UNDERLINE_DOUBLE) {", "+\t\t\t\t\t\tGdip.Graphics_FillRectangle(graphics, selectionColor, rect.left, rect.top + run.underlineThickness * 2, rect.right - rect.left, rect.bottom - rect.top);", "+\t\t\t\t\t}", "+\t\t\t\t\tGdip.Graphics_Restore(graphics, gstate);", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tcase UNDERLINE_IME_DOT:", "+\t\t\tcase UNDERLINE_IME_DASH: {", "+\t\t\t\tint /*long*/ pen = Gdip.Pen_new(brush, 1);", "+\t\t\t\tint dashStyle = style.underlineStyle == UNDERLINE_IME_DOT ? Gdip.DashStyleDot : Gdip.DashStyleDash;", "+\t\t\t\tGdip.Pen_SetDashStyle(pen, dashStyle);", "+\t\t\t\tif (gdipRect != null) {", "+\t\t\t\t\tgstate = Gdip.Graphics_Save(graphics);", "+\t\t\t\t\tGdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);", "+\t\t\t\t}", "+\t\t\t\tGdip.Graphics_DrawLine(graphics, pen, rect.left, baseline + run.descent, run.width - run.length, baseline + run.descent);", "+\t\t\t\tif (gdipRect != null) {", "+\t\t\t\t\tGdip.Graphics_Restore(graphics, gstate);", "+\t\t\t\t\tgstate = Gdip.Graphics_Save(graphics);", "+\t\t\t\t\tGdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeIntersect);", "+\t\t\t\t\tint /*long*/ selPen = Gdip.Pen_new(brush, 1);", "+\t\t\t\t\tGdip.Pen_SetDashStyle(selPen, dashStyle);", "+\t\t\t\t\tGdip.Graphics_DrawLine(graphics, selPen, rect.left, baseline + run.descent, run.width - run.length, baseline + run.descent);", "+\t\t\t\t\tGdip.Graphics_Restore(graphics, gstate);", "+\t\t\t\t\tGdip.Pen_delete(selPen);", "+\t\t\t\t}", "+\t\t\t\tGdip.Pen_delete(pen);", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\tif (brush != selectionColor && brush != color) Gdip.SolidBrush_delete(brush);", "+\t\tGdip.Graphics_SetPixelOffsetMode(graphics, Gdip.PixelOffsetModeHalf);", "+\t\treturn null;", "+\t}", "+\treturn clipRect;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5aa08e15dc056bd2d6f673ce83da0e0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public Image(Device device, Image srcImage, int flag)", "signatureAfterChange": " public Image(Device device, Image srcImage, int flag)", "diff": ["-\tthis.device = device;", "-\t\t\t", "-\tthis.type = srcImage.type;", "-\tthis.mask = 0;", "-\t\t", "-\tMacRect bounds= new MacRect();", "-\tOS.GetPixBounds(srcImage.pixmap, bounds.getData());", "- \tint width = bounds.getWidth();", "- \tint height = bounds.getHeight();", "-", "-\t/* Don't create the mask here if flag is SWT.IMAGE_GRAY. See below.*/", "-\tif (flag != SWT.IMAGE_GRAY && srcImage.mask != 0) {", "-\t\t/* Generate the mask if necessary. */", "-\t\tif (srcImage.transparentPixel != -1) srcImage.createMask();", "-\t\tthis.mask = duplicate(srcImage.mask);", "-\t\t/* Destroy the image mask if the there is a GC created on the image */", "-\t\tif (srcImage.transparentPixel != -1 && srcImage.memGC != null) srcImage.destroyMask();", "-\t}", "-\t", "-\t\t", "-\tcase SWT.IMAGE_COPY:", "-\t\tthis.pixmap = duplicate(srcImage.pixmap);", "+\t\tcase SWT.IMAGE_COPY:", "+\t\tcase SWT.IMAGE_DISABLE:", "+\t\tcase SWT.IMAGE_GRAY:", "+\t\t\tbreak;", "+\t\tdefault:", "+\t\t\tSWT.error(SWT.ERROR_INVALID_ARGUMENT);", "+\t}", "+\tthis.device = device;", "+\tthis.type = srcImage.type;", "+", "+\t/* Get source image size */", "+ \tint width = OS.CGImageGetWidth(srcImage.handle);", "+ \tint height = OS.CGImageGetHeight(srcImage.handle);", "+ \tint bpr = OS.CGImageGetBytesPerRow(srcImage.handle);", "+ \tint bpc = OS.CGImageGetBitsPerComponent(srcImage.handle);", "+ \tint bpp = OS.CGImageGetBitsPerPixel(srcImage.handle);", "+\tint colorspace = OS.CGImageGetColorSpace(srcImage.handle);", "+\tint alphaInfo = OS.kCGImageAlphaNoneSkipFirst;", "+ \t", "+\t/* Copy transparent pixel and alpha data when necessary */", "+\tif (flag != SWT.IMAGE_DISABLE) {", "+\t\talphaInfo = OS.CGImageGetAlphaInfo(srcImage.handle);", "-\t\treturn;", "-\t\t", "-\tcase SWT.IMAGE_DISABLE:", "-\t\t/* Get src image data */", "-\t\tint srcDepth= getDepth(srcImage.pixmap);", "-\t\tint srcBitsPerPixel= srcDepth;", "-\t\t", "-\t\tif (srcBitsPerPixel == 1) {", "-\t\t\t/*", "-\t\t\t * Nothing we can reasonably do here except copy", "-\t\t\t * the bitmap; we can't make it a higher color depth.", "-\t\t\t * Short-circuit the rest of the code and return.", "-\t\t\t */", "-\t\t\tpixmap = duplicate(srcImage.pixmap);", "-\t\t\treturn;", "-\t\t}", "-\t\t", "-\t\tint srcRowBytes= rowBytes(width, srcDepth);", "-\t\tbyte[] srcData = new byte[srcRowBytes * height];", "-\t\tcopyPixMapData(srcImage.pixmap, srcData);", "+\t}", "-\t\t/* Create destination image */", "-\t\tint destPixmap = createPixMap(width, height, srcDepth);", "-\t\tint destBitsPerPixel= srcDepth;", "-\t\tbyte[] destData = new byte[srcRowBytes * height];", "-\t\t", "-\t\t/* Find the colors to map to */", "-\t\tColor zeroColor = device.getSystemColor(SWT.COLOR_WIDGET_NORMAL_SHADOW);", "-\t\tColor oneColor = device.getSystemColor(SWT.COLOR_WIDGET_BACKGROUND);", "-\t\tint zeroPixel= 0;", "-\t\tint onePixel= 1;", "-\t\tsetColorTable(destPixmap, new Color[] { zeroColor, oneColor });", "-", "-\t\tswitch (srcBitsPerPixel) {", "-\t\tcase 1:", "-\t\t\t// should not happen; see above", "-\t\t\treturn;", "-\t\tcase 4:", "-\t\t\t//SWT.error(SWT.ERROR_NOT_IMPLEMENTED);", "-\t\t\tpixmap = duplicate(srcImage.pixmap);", "-\t\t\tbreak;", "-\t\tcase 8:", "-\t\t\tint index = 0;", "-\t\t\tint srcPixel, r, g, b;", "-\t\t\t", "-\t\t\tint[] colors= new int[256];", "-\t\t\tfor (int i= 0; i < 256; i++)", "-\t\t\t\tcolors[i]= -1;", "-\t\t\t\t", "-\t\t\tshort[] colorTable= getColorTable(srcImage.pixmap);", "-\t\t\t", "-\t\t\tfor (int y = 0; y < height; y++) {", "-\t\t\t\tfor (int x = 0; x < srcRowBytes; x++) {", "-\t\t\t\t\tsrcPixel = srcData[index + x] & 0xFF;", "-\t\t\t\t\t/* Get the RGB values of srcPixel */", "-\t\t\t\t\tint color= colors[srcPixel];", "-\t\t\t\t\tif (color == -1)\t\t\t", "-\t\t\t\t\t\tcolors[srcPixel]= color= getRGB(colorTable, srcPixel);", "-\t\t\t\t\tr = (color >> 16) & 0xFF;", "-\t\t\t\t\tg = (color >> 8) & 0xFF;", "-\t\t\t\t\tb = (color) & 0xFF;", "-\t\t\t\t\t/* See if the rgb maps to 0 or 1 */", "-\t\t\t\t\tif ((r * r + g * g + b * b) < 98304) {", "-\t\t\t\t\t\t/* Map down to 0 */", "-\t\t\t\t\t\tdestData[index + x] = (byte)zeroPixel;", "+\t/* Create the image */", "+\tint dataSize = height * bpr;", "+\tdata = OS.NewPtr(dataSize);", "+\tif (data == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\tint provider = OS.CGDataProviderCreateWithData(0, data, dataSize, 0);", "+\tif (provider == 0) {", "+\t\tOS.DisposePtr(data);", "+\t\tSWT.error(SWT.ERROR_NO_HANDLES);", "+\t}", "+\thandle = OS.CGImageCreate(width, height, bpc, bpp, bpr, colorspace, alphaInfo, provider, null, false, 0);", "+\tOS.CGDataProviderRelease(provider);", "+\tif (handle == 0) {", "+\t\tOS.DisposePtr(data);", "+\t\tSWT.error(SWT.ERROR_NO_HANDLES);", "+\t}", "+\t", "+\tOS.memcpy(data, srcImage.data, dataSize);", "+\tif (flag == SWT.IMAGE_COPY) return;", "+\t", "+\t/* Apply transformation */", "+\tswitch (flag) {", "+\t\tcase SWT.IMAGE_DISABLE: {", "+\t\t\tColor zeroColor = device.getSystemColor(SWT.COLOR_WIDGET_NORMAL_SHADOW);", "+\t\t\tRGB zeroRGB = zeroColor.getRGB();", "+\t\t\tbyte zeroRed = (byte)zeroRGB.red;", "+\t\t\tbyte zeroGreen = (byte)zeroRGB.green;", "+\t\t\tbyte zeroBlue = (byte)zeroRGB.blue;", "+\t\t\tColor oneColor = device.getSystemColor(SWT.COLOR_WIDGET_BACKGROUND);", "+\t\t\tRGB oneRGB = oneColor.getRGB();", "+\t\t\tbyte oneRed = (byte)oneRGB.red;", "+\t\t\tbyte oneGreen = (byte)oneRGB.green;", "+\t\t\tbyte oneBlue = (byte)oneRGB.blue;", "+\t\t\tbyte[] line = new byte[bpr];", "+\t\t\tfor (int y=0; y<height; y++) {", "+\t\t\t\tOS.memcpy(line, data + (y * bpr), bpr);", "+\t\t\t\tint offset = 0;", "+\t\t\t\tfor (int x=0; x<width; x++) {", "+\t\t\t\t\tint red = line[offset+1] & 0xFF;", "+\t\t\t\t\tint green = line[offset+2] & 0xFF;", "+\t\t\t\t\tint blue = line[offset+3] & 0xFF;", "+\t\t\t\t\tint intensity = red * red + green * green + blue * blue;", "+\t\t\t\t\tif (intensity < 98304) {", "+\t\t\t\t\t\tline[offset+1] = zeroRed;", "+\t\t\t\t\t\tline[offset+2] = zeroGreen;", "+\t\t\t\t\t\tline[offset+3] = zeroBlue;", "-\t\t\t\t\t\t/* Map up to 1 */", "-\t\t\t\t\t\tdestData[index + x] = (byte)onePixel;", "+\t\t\t\t\t\tline[offset+1] = oneRed;", "+\t\t\t\t\t\tline[offset+2] = oneGreen;", "+\t\t\t\t\t\tline[offset+3] = oneBlue;", "+\t\t\t\t\toffset += 4;", "-\t\t\t\tindex += srcRowBytes;", "+\t\t\t\tOS.memcpy(data + (y * bpr), line, bpr);", "-\t\tcase 16:", "-\t\t\tindex = 0;", "-\t\t\t/* Get masks */", "-\t\t\tint redMask = getRedMask(16);", "-\t\t\tint greenMask = getGreenMask(16);", "-\t\t\tint blueMask = getBlueMask(16);\t\t\t\t\t", "-\t\t\t/* Calculate mask shifts */", "-\t\t\tint rShift = 24 - getOffsetForMask(16, redMask, true);", "-\t\t\tint gShift = 24 - getOffsetForMask(16, greenMask, true);", "-\t\t\tint bShift = 24 - getOffsetForMask(16, blueMask, true);", "-\t\t\tbyte zeroLow = (byte)(zeroPixel & 0xFF);", "-\t\t\tbyte zeroHigh = (byte)((zeroPixel >> 8) & 0xFF);", "-\t\t\tbyte oneLow = (byte)(onePixel & 0xFF);", "-\t\t\tbyte oneHigh = (byte)((onePixel >> 8) & 0xFF);", "-\t\t\tfor (int y = 0; y < height; y++) {", "-\t\t\t\tint xIndex = 0;", "-\t\t\t\tfor (int x = 0; x < srcRowBytes; x += 2) {", "-\t\t\t\t\tint ix= index + xIndex;", "-\t\t\t\t\tsrcPixel = ((srcData[ix + 1] & 0xFF) << 8) | (srcData[ix] & 0xFF);", "-\t\t\t\t\tr = (srcPixel & redMask) << rShift >> 16;", "-\t\t\t\t\tg = (srcPixel & greenMask) << gShift >> 16;", "-\t\t\t\t\tb = (srcPixel & blueMask) << bShift >> 16;", "-\t\t\t\t\t/* See if the rgb maps to 0 or 1 */", "-\t\t\t\t\tif ((r * r + g * g + b * b) < 98304) {", "-\t\t\t\t\t\t/* Map down to 0 */", "-\t\t\t\t\t\tdestData[ix] = zeroLow;", "-\t\t\t\t\t\tdestData[ix + 1] = zeroHigh;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t/* Map up to 1 */", "-\t\t\t\t\t\tdestData[ix] = oneLow;", "-\t\t\t\t\t\tdestData[ix + 1] = oneHigh;", "-\t\t\t\t\t}", "-\t\t\t\t\txIndex += srcBitsPerPixel / 8;", "-\t\t\t\t}", "-\t\t\t\tindex += srcRowBytes;", "-\t\t\t}", "-\t\t\tbreak;", "-\t\tcase 24:", "-\t\tcase 32:", "-\t\t\tindex = 0;", "-\t\t\t/* Get masks */", "-\t\t\tredMask = getRedMask(srcBitsPerPixel);", "-\t\t\tgreenMask = getGreenMask(srcBitsPerPixel);", "-\t\t\tblueMask = getBlueMask(srcBitsPerPixel);\t\t\t\t\t", "-\t\t\t/* Calculate mask shifts */", "-\t\t\trShift = getOffsetForMask(srcBitsPerPixel, redMask, true);", "-\t\t\tgShift = getOffsetForMask(srcBitsPerPixel, greenMask, true);", "-\t\t\tbShift = getOffsetForMask(srcBitsPerPixel, blueMask, true);", "-\t\t\tbyte zeroR = (byte)zeroColor.getRed();", "-\t\t\tbyte zeroG = (byte)zeroColor.getGreen();", "-\t\t\tbyte zeroB = (byte)zeroColor.getBlue();", "-\t\t\tbyte oneR = (byte)oneColor.getRed();", "-\t\t\tbyte oneG = (byte)oneColor.getGreen();", "-\t\t\tbyte oneB = (byte)oneColor.getBlue();", "-\t\t\tfor (int y = 0; y < height; y++) {", "-\t\t\t\tint xIndex = 0;", "-\t\t\t\tfor (int x = 0; x < width; x++) {", "-\t\t\t\t\tint i= index + xIndex;", "-\t\t\t\t\tr = srcData[i + rShift] & 0xFF;", "-\t\t\t\t\tg = srcData[i + gShift] & 0xFF;", "-\t\t\t\t\tb = srcData[i + bShift] & 0xFF;", "-\t\t\t\t\t/* See if the rgb maps to 0 or 1 */", "-\t\t\t\t\tif ((r * r + g * g + b * b) < 98304) {", "-\t\t\t\t\t\t/* Map down to 0 */", "-\t\t\t\t\t\tdestData[i + rShift] = zeroR;", "-\t\t\t\t\t\tdestData[i + gShift] = zeroG;", "-\t\t\t\t\t\tdestData[i + bShift] = zeroB;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t/* Map up to 1 */", "-\t\t\t\t\t\tdestData[i + rShift] = oneR;", "-\t\t\t\t\t\tdestData[i + gShift] = oneG;", "-\t\t\t\t\t\tdestData[i + bShift] = oneB;", "-\t\t\t\t\t}", "-\t\t\t\t\txIndex += destBitsPerPixel / 8;", "-\t\t\t\t}", "-\t\t\t\tindex += srcRowBytes;", "-\t\t\t}", "-\t\t\tbreak;", "-\t\tdefault:", "-\t\t\tSWT.error(SWT.ERROR_INVALID_IMAGE);", "-\t\tsetPixMapData(destPixmap, destData);", "-\t\tthis.pixmap = destPixmap;", "-\t\treturn;", "-", "-\tcase SWT.IMAGE_GRAY:", "-\t\tImageData data = srcImage.getImageData();", "-\t\tPaletteData palette = data.palette;", "-\t\tImageData newData = data;", "-\t\tif (palette.isDirect) {", "-\t\t\t/* Create a 8 bit depth image data with a gray palette. */", "-\t\t\tRGB[] rgbs = new RGB[256];", "-\t\t\tfor (int i= 0; i < rgbs.length; i++)", "-\t\t\t\trgbs[i]= new RGB(i, i, i);", "-\t\t\t", "-\t\t\tnewData = new ImageData(width, height, 8, new PaletteData(rgbs));", "-\t\t\tnewData.maskData = data.maskData;", "-\t\t\tnewData.maskPad = data.maskPad;", "-\t\t\t/* Convert the pixels. */", "-\t\t\tint[] scanline = new int[width];", "-\t\t\tint redMask = palette.redMask;", "-\t\t\tint greenMask = palette.greenMask;", "-\t\t\tint blueMask = palette.blueMask;", "-\t\t\tint redShift = palette.redShift;", "-\t\t\tint greenShift = palette.greenShift;", "-\t\t\tint blueShift = palette.blueShift;", "-\t\t\tfor (int y= 0; y < height; y++) {", "-\t\t\t\tint offset = y * newData.bytesPerLine;", "-\t\t\t\tdata.getPixels(0, y, width, scanline, 0);", "-\t\t\t\tfor (int x= 0; x < width; x++) {", "-\t\t\t\t\tint pixel = scanline[x];", "-\t\t\t\t\tint red = pixel & redMask;", "-\t\t\t\t\tred = (redShift < 0) ? red >>> -redShift : red << redShift;", "-\t\t\t\t\tint green = pixel & greenMask;", "-\t\t\t\t\tgreen = (greenShift < 0) ? green >>> -greenShift : green << greenShift;", "-\t\t\t\t\tint blue = pixel & blueMask;", "-\t\t\t\t\tblue = (blueShift < 0) ? blue >>> -blueShift : blue << blueShift;", "-\t\t\t\t\tnewData.data[offset++] =", "-\t\t\t\t\t\t(byte)((red+red+green+green+green+green+green+blue) >> 3);", "+\t\tcase SWT.IMAGE_GRAY: {\t\t\t", "+\t\t\tbyte[] line = new byte[bpr];", "+\t\t\tfor (int y=0; y<height; y++) {", "+\t\t\t\tOS.memcpy(line, data + (y * bpr), bpr);", "+\t\t\t\tint offset = 0;", "+\t\t\t\tfor (int x=0; x<width; x++) {", "+\t\t\t\t\tint red = line[offset+1] & 0xFF;", "+\t\t\t\t\tint green = line[offset+2] & 0xFF;", "+\t\t\t\t\tint blue = line[offset+3] & 0xFF;", "+\t\t\t\t\tbyte intensity = (byte)((red+red+green+green+green+green+green+blue) >> 3);", "+\t\t\t\t\tline[offset+1] = line[offset+2] = line[offset+3] = intensity;", "+\t\t\t\t\toffset += 4;", "+\t\t\t\tOS.memcpy(data + (y * bpr), line, bpr);", "-\t\t} else {", "-\t\t\t/* Convert the palette entries to gray. */", "-\t\t\tRGB [] rgbs = palette.getRGBs();", "-\t\t\tfor (int i= 0; i < rgbs.length; i++) {", "-\t\t\t\tif (data.transparentPixel != i) {", "-\t\t\t\t\tRGB color = rgbs [i];", "-\t\t\t\t\tint red = color.red;", "-\t\t\t\t\tint green = color.green;", "-\t\t\t\t\tint blue = color.blue;", "-\t\t\t\t\tint intensity = (red+red+green+green+green+green+green+blue) >> 3;", "-\t\t\t\t\tcolor.red = color.green = color.blue = intensity;", "-\t\t\t\t}", "+\t\t\ttransparentPixel = srcImage.transparentPixel;", "+\t\t\talpha = srcImage.alpha;", "+\t\t\tif (srcImage.alphaData != null) {", "+\t\t\t\talphaData = new byte[srcImage.alphaData.length];", "+\t\t\t\tSystem.arraycopy(srcImage.alphaData, 0, alphaData, 0, alphaData.length);", "-\t\t\tnewData.palette = new PaletteData(rgbs);", "+\t\t\tbreak;", "-\t\tinit (device, newData);", "-\t\tbreak;", "-\t\t", "-\tdefault:", "-\t\tSWT.error(SWT.ERROR_INVALID_ARGUMENT);"]}], "num": 41484}