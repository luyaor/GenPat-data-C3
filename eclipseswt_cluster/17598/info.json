{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "66228c02f0b985f851deb68ae0248b94", "detectedBy": ["DIFF_DBSCAN", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "67186c32e9888ce8de173a171709010b", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "9deefd18be8de01a672cfca15620a560b1ae5f22", "commitAfterChange": "d67b8caceb3f10df6a8e238427498db262144133", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public Image(Device device, Image srcImage, int flag)", "signatureAfterChange": " public Image(Device device, Image srcImage, int flag)", "diff": ["-\t/* basic sanity */", "-\tthis.device = device;", "+\tswitch (flag) {", "+\t\tcase SWT.IMAGE_COPY:", "+\t\tcase SWT.IMAGE_DISABLE:", "+\t\tcase SWT.IMAGE_GRAY:", "+\t\t\tbreak;", "+\t\tdefault:", "+\t\t\tSWT.error(SWT.ERROR_INVALID_ARGUMENT);", "+\t}", "+\tthis.device = device;", "-\tthis.mask = 0;", "-\t/* this is somewhat ugly, because this dilutes the encapsulation", "-\t * of knowledge about what the cloning operations do (e.g., the", "-\t * following lines assume graying and disabling don't change alpha)", "-\t */", "-\tthis.alphaData = srcImage.alphaData;", "-\tthis.alpha = srcImage.alpha;", "-\tthis.transparentPixel = srcImage.transparentPixel;", "-\t// FIXME - are we sure about memGC?", "+\t/* Get source image size */", "+\tint[] w = new int[1], h = new int[1];", "+ \tOS.gdk_drawable_get_size(srcImage.pixmap, w, h);", "+ \tint width = w[0];", "+ \tint height = h[0];", "+ \t", "+ \t/* Copy the mask */", "+\tif (srcImage.mask != 0 || srcImage.transparentPixel != -1) {", "+\t\t/* Generate the mask if necessary. */", "+\t\tif (srcImage.transparentPixel != -1) srcImage.createMask();", "+\t\tint mask = OS.gdk_pixmap_new(0, width, height, 1);", "+\t\tif (mask == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\tint gdkGC = OS.gdk_gc_new(mask);", "+\t\tif (gdkGC == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\tOS.gdk_draw_drawable(mask, gdkGC, srcImage.mask, 0, 0, 0, 0, width, height);", "+\t\tOS.g_object_unref(gdkGC);", "+\t\tthis.mask = mask;", "+\t\t/* Destroy the image mask if the there is a GC created on the image */", "+\t\tif (srcImage.transparentPixel != -1 && srcImage.memGC != null) srcImage.destroyMask();", "+\t}", "-\t/* Special case:", "-\t * If all we want is just a clone of the existing pixmap, it can", "-\t * be done entirely in the X server, without copying across the net.", "-\t */", "-\tif (flag == SWT.IMAGE_COPY) {", "-\t\tint[] width = new int[1]; int[] height = new int[1];", "-\t \tOS.gdk_drawable_get_size(srcImage.pixmap, width, height);", "-\t \tint depth = OS.gdk_drawable_get_depth(srcImage.pixmap);", "-\t\tpixmap = OS.gdk_pixmap_new (0, width[0], height[0], depth);", "-", "-\t\tint gc = OS.gdk_gc_new (pixmap);", "-\t\tOS.gdk_draw_pixmap(pixmap, gc, srcImage.pixmap,", "-\t\t\t0,0,0,0, width[0], height[0]);", "-\t\tOS.gdk_gc_destroy(gc);", "+\t/* Copy transparent pixel and alpha data when necessary */", "+\tif (flag != SWT.IMAGE_DISABLE) {", "-\t\t", "-\t\t/* we are not quite done yet.  Need to copy the maskData */", "-\t\tif (srcImage.mask != 0) {", "-\t\t\t/* Generate the mask if necessary. */", "-//\t\t\tif (srcImage.transparentPixel != -1) srcImage.createMask();", "-\t\t\tmask = OS.gdk_pixmap_new(0, width[0], height[0], 1);", "-\t\t\tgc = OS.gdk_gc_new(mask);", "-\t\t\tOS.gdk_draw_pixmap(mask, gc, srcImage.mask,", "-\t\t\t\t0,0,0,0, width[0], height[0]);", "-\t\t\tOS.gdk_gc_destroy(gc);", "-\t\t\t/* Destroy the image mask if the there is a GC created on the image */", "-\t\t\tif (srcImage.transparentPixel != -1 && srcImage.memGC != null) srcImage.destroyMask();", "-\t\t}", "-", "-\t", "-\tif (pixmap==0) SWT.error(SWT.ERROR_CANNOT_BE_ZERO);", "-\t\t", "-\t\treturn;", "-", "-", "-", "-\tPixbuffer pb  = new Pixbuffer(srcImage);", "-\tPixbuffer pb2 = new Pixbuffer(pb, flag);", "-\tpb2.toImage(this);", "+\t/* Create the new pixmap */", "+\tint pixmap = OS.gdk_pixmap_new (OS.GDK_ROOT_PARENT(), width, height, -1);", "+\tif (pixmap == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\tint gdkGC = OS.gdk_gc_new(pixmap);", "+\tif (gdkGC == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\tthis.pixmap = pixmap;", "+\tif (flag == SWT.IMAGE_COPY) {", "+\t\tOS.gdk_draw_drawable(pixmap, gdkGC, srcImage.pixmap, 0, 0, 0, 0, width, height);", "+\t\tOS.g_object_unref(gdkGC);", "+\t\treturn;", "+\t}", "+\t", "+\t/* Retrieve the source pixmap data */", "+\tint pixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB(), false, 8, width, height);", "+\tif (pixbuf == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\tint colormap = OS.gdk_colormap_get_system();", "+\tOS.gdk_pixbuf_get_from_drawable(pixbuf, srcImage.pixmap, colormap, 0, 0, 0, 0, width, height);", "+\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "+\tint pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t/* Apply transformation */", "+\tswitch (flag) {", "+\t\tcase SWT.IMAGE_DISABLE: {", "+\t\t\tbyte[] line = new byte[stride];", "+\t\t\tfor (int y=0; y<height; y++) {", "+\t\t\t\tOS.memmove(line, pixels + (y * stride), stride);", "+\t\t\t\tfor (int x=0; x<width; x++) {", "+\t\t\t\t\tint offset = x*3;", "+\t\t\t\t\tint red = line[offset] & 0xFF;", "+\t\t\t\t\tint green = line[offset+1] & 0xFF;", "+\t\t\t\t\tint blue = line[offset+2] & 0xFF;", "+\t\t\t\t\tint intensity = red * red + green * green + blue * blue;", "+\t\t\t\t\tbyte value = (intensity < 9000) ? (byte)0 : (byte) 255;", "+\t\t\t\t\tline[offset] = line[offset+1] = line[offset+2] = value;", "+\t\t\t\t}", "+\t\t\t\tOS.memmove(pixels + (y * stride), line, stride);", "+\t\t\t}", "+\t\t\tbreak;", "+\t\t}", "+\t\tcase SWT.IMAGE_GRAY: {\t\t\t", "+\t\t\tbyte[] line = new byte[stride];", "+\t\t\tfor (int y=0; y<height; y++) {", "+\t\t\t\tOS.memmove(line, pixels + (y * stride), stride);", "+\t\t\t\tfor (int x=0; x<width; x++) {", "+\t\t\t\t\tint offset = x*3;", "+\t\t\t\t\tint red = line[offset] & 0xFF;", "+\t\t\t\t\tint green = line[offset+1] & 0xFF;", "+\t\t\t\t\tint blue = line[offset+2] & 0xFF;", "+\t\t\t\t\tbyte intensity = (byte)((red+red+green+green+green+green+green+blue) >> 3);", "+\t\t\t\t\tline[offset] = line[offset+1] = line[offset+2] = intensity;", "+\t\t\t\t}", "+\t\t\t\tOS.memmove(pixels + (y * stride), line, stride);", "+\t\t\t}", "+\t\t\ttransparentPixel = srcImage.transparentPixel;", "+\t\t\talpha = srcImage.alpha;", "+\t\t\tif (srcImage.alphaData != null) {", "+\t\t\t\talphaData = new byte[srcImage.alphaData.length];", "+\t\t\t\tSystem.arraycopy(srcImage.alphaData, 0, alphaData, 0, alphaData.length);", "+\t\t\t}", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+", "+\t/* Copy data back to destination pixmap */", "+\tOS.gdk_pixbuf_render_to_drawable(pixbuf, pixmap, gdkGC, 0, 0, 0, 0, width, height, OS.GDK_RGB_DITHER_NORMAL, 0, 0);", "+\t", "+\t/* Free resources */", "+\tOS.g_object_unref(pixbuf);", "+\tOS.g_object_unref(gdkGC);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "038fe03cfc29b4872ce1373064da87c8", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "c0e52cb484656d9c8fde7046773ace24dace36d1", "commitAfterChange": "536fea109939f314c8db78904a303b501123d0c7", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public Image(Device device, Image srcImage, int flag)", "signatureAfterChange": " public Image(Device device, Image srcImage, int flag)", "diff": ["-// \tint width = OS.CGImageGetWidth(srcImage.handle);", "-// \tint height = OS.CGImageGetHeight(srcImage.handle);", "-// \tint bpr = OS.CGImageGetBytesPerRow(srcImage.handle);", "-// \tint bpc = OS.CGImageGetBitsPerComponent(srcImage.handle);", "-// \tint bpp = OS.CGImageGetBitsPerPixel(srcImage.handle);", "-//\tint colorspace = OS.CGImageGetColorSpace(srcImage.handle);", "-//\tint alphaInfo = OS.kCGImageAlphaNoneSkipFirst;", "-// \t", "-//\t/* Copy transparent pixel and alpha data when necessary */", "-//\talphaInfo = OS.CGImageGetAlphaInfo(srcImage.handle);", "-//\ttransparentPixel = srcImage.transparentPixel;", "-//\talpha = srcImage.alpha;", "-//\tif (srcImage.alphaData != null) {", "-//\t\talphaData = new byte[srcImage.alphaData.length];", "-//\t\tSystem.arraycopy(srcImage.alphaData, 0, alphaData, 0, alphaData.length);", "-//\t}", "-//", "-//\t/* Create the image */", "-//\tint dataSize = height * bpr;", "-//\tdata = OS.NewPtr(dataSize);", "-//\tif (data == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-//\tint provider = OS.CGDataProviderCreateWithData(0, data, dataSize, device.releaseProc);", "-//\tif (provider == 0) {", "-//\t\tOS.DisposePtr(data);", "-//\t\tSWT.error(SWT.ERROR_NO_HANDLES);", "-//\t}", "-//\thandle = OS.CGImageCreate(width, height, bpc, bpp, bpr, colorspace, alphaInfo, provider, null, true, 0);", "-//\tOS.CGDataProviderRelease(provider);", "-//\tif (handle == 0) {", "-//\t\tOS.DisposePtr(data);", "-//\t\tSWT.error(SWT.ERROR_NO_HANDLES);", "-//\t}", "-//\t", "-//\tOS.memmove(data, srcImage.data, dataSize);", "-//\tif (flag == SWT.IMAGE_COPY) return;", "-//\t", "-//\t/* Apply transformation */", "-//\tswitch (flag) {", "-//\t\tcase SWT.IMAGE_DISABLE: {", "-//\t\t\tColor zeroColor = device.getSystemColor(SWT.COLOR_WIDGET_NORMAL_SHADOW);", "-//\t\t\tRGB zeroRGB = zeroColor.getRGB();", "-//\t\t\tbyte zeroRed = (byte)zeroRGB.red;", "-//\t\t\tbyte zeroGreen = (byte)zeroRGB.green;", "-//\t\t\tbyte zeroBlue = (byte)zeroRGB.blue;", "-//\t\t\tColor oneColor = device.getSystemColor(SWT.COLOR_WIDGET_BACKGROUND);", "-//\t\t\tRGB oneRGB = oneColor.getRGB();", "-//\t\t\tbyte oneRed = (byte)oneRGB.red;", "-//\t\t\tbyte oneGreen = (byte)oneRGB.green;", "-//\t\t\tbyte oneBlue = (byte)oneRGB.blue;", "-//\t\t\tbyte[] line = new byte[bpr];", "-//\t\t\tfor (int y=0; y<height; y++) {", "-//\t\t\t\tOS.memmove(line, data + (y * bpr), bpr);", "-//\t\t\t\tint offset = 0;", "-//\t\t\t\tfor (int x=0; x<width; x++) {", "-//\t\t\t\t\tint red = line[offset+1] & 0xFF;", "-//\t\t\t\t\tint green = line[offset+2] & 0xFF;", "-//\t\t\t\t\tint blue = line[offset+3] & 0xFF;", "-//\t\t\t\t\tint intensity = red * red + green * green + blue * blue;", "-//\t\t\t\t\tif (intensity < 98304) {", "-//\t\t\t\t\t\tline[offset+1] = zeroRed;", "-//\t\t\t\t\t\tline[offset+2] = zeroGreen;", "-//\t\t\t\t\t\tline[offset+3] = zeroBlue;", "-//\t\t\t\t\t} else {", "-//\t\t\t\t\t\tline[offset+1] = oneRed;", "-//\t\t\t\t\t\tline[offset+2] = oneGreen;", "-//\t\t\t\t\t\tline[offset+3] = oneBlue;", "-//\t\t\t\t\t}", "-//\t\t\t\t\toffset += 4;", "-//\t\t\t\t}", "-//\t\t\t\tOS.memmove(data + (y * bpr), line, bpr);", "-//\t\t\t}", "-//\t\t\tbreak;", "-//\t\t}", "-//\t\tcase SWT.IMAGE_GRAY: {\t\t\t", "-//\t\t\tbyte[] line = new byte[bpr];", "-//\t\t\tfor (int y=0; y<height; y++) {", "-//\t\t\t\tOS.memmove(line, data + (y * bpr), bpr);", "-//\t\t\t\tint offset = 0;", "-//\t\t\t\tfor (int x=0; x<width; x++) {", "-//\t\t\t\t\tint red = line[offset+1] & 0xFF;", "-//\t\t\t\t\tint green = line[offset+2] & 0xFF;", "-//\t\t\t\t\tint blue = line[offset+3] & 0xFF;", "-//\t\t\t\t\tbyte intensity = (byte)((red+red+green+green+green+green+green+blue) >> 3);", "-//\t\t\t\t\tline[offset+1] = line[offset+2] = line[offset+3] = intensity;", "-//\t\t\t\t\toffset += 4;", "-//\t\t\t\t}", "-//\t\t\t\tOS.memmove(data + (y * bpr), line, bpr);", "-//\t\t\t}", "-//\t\t\tbreak;", "-//\t\t}", "-//\t}", "+\tNSSize size = srcImage.handle.size();", "+ \tint width = (int)size.width;", "+ \tint height = (int)size.height;", "+ \tNSBitmapImageRep srcRep = srcImage.imageRep;", "+ \tint bpr = srcRep.bytesPerRow();", "+", "+\t/* Copy transparent pixel and alpha data when necessary */", "+\ttransparentPixel = srcImage.transparentPixel;", "+\talpha = srcImage.alpha;", "+\tif (srcImage.alphaData != null) {", "+\t\talphaData = new byte[srcImage.alphaData.length];", "+\t\tSystem.arraycopy(srcImage.alphaData, 0, alphaData, 0, alphaData.length);", "+\t}", "+", "+\t/* Create the image */", "+\thandle = (NSImage)new NSImage().alloc();", "+\thandle = handle.initWithSize(size);", "+\tNSBitmapImageRep rep = imageRep = (NSBitmapImageRep)new NSBitmapImageRep().alloc();", "+\trep = rep.initWithBitmapDataPlanes_pixelsWide_pixelsHigh_bitsPerSample_samplesPerPixel_hasAlpha_isPlanar_colorSpaceName_bitmapFormat_bytesPerRow_bitsPerPixel_(0, width, height, srcRep.bitsPerSample(), srcRep.samplesPerPixel(), srcRep.samplesPerPixel() == 4, srcRep.isPlanar(), new NSString(OS.NSDeviceRGBColorSpace()), OS.NSAlphaFirstBitmapFormat | OS.NSAlphaNonpremultipliedBitmapFormat, srcRep.bytesPerRow(), srcRep.bitsPerPixel());", "+\thandle.addRepresentation(rep);", "+\t", "+\tint data = rep.bitmapData();", "+\tOS.memmove(data, srcImage.imageRep.bitmapData(), width * height * 4);", "+\tif (flag == SWT.IMAGE_COPY) return;", "+\t", "+\t/* Apply transformation */", "+\tswitch (flag) {", "+\t\tcase SWT.IMAGE_DISABLE: {", "+\t\t\tColor zeroColor = device.getSystemColor(SWT.COLOR_WIDGET_NORMAL_SHADOW);", "+\t\t\tRGB zeroRGB = zeroColor.getRGB();", "+\t\t\tbyte zeroRed = (byte)zeroRGB.red;", "+\t\t\tbyte zeroGreen = (byte)zeroRGB.green;", "+\t\t\tbyte zeroBlue = (byte)zeroRGB.blue;", "+\t\t\tColor oneColor = device.getSystemColor(SWT.COLOR_WIDGET_BACKGROUND);", "+\t\t\tRGB oneRGB = oneColor.getRGB();", "+\t\t\tbyte oneRed = (byte)oneRGB.red;", "+\t\t\tbyte oneGreen = (byte)oneRGB.green;", "+\t\t\tbyte oneBlue = (byte)oneRGB.blue;", "+\t\t\tbyte[] line = new byte[bpr];", "+\t\t\tfor (int y=0; y<height; y++) {", "+\t\t\t\tOS.memmove(line, data + (y * bpr), bpr);", "+\t\t\t\tint offset = 0;", "+\t\t\t\tfor (int x=0; x<width; x++) {", "+\t\t\t\t\tint red = line[offset+1] & 0xFF;", "+\t\t\t\t\tint green = line[offset+2] & 0xFF;", "+\t\t\t\t\tint blue = line[offset+3] & 0xFF;", "+\t\t\t\t\tint intensity = red * red + green * green + blue * blue;", "+\t\t\t\t\tif (intensity < 98304) {", "+\t\t\t\t\t\tline[offset+1] = zeroRed;", "+\t\t\t\t\t\tline[offset+2] = zeroGreen;", "+\t\t\t\t\t\tline[offset+3] = zeroBlue;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tline[offset+1] = oneRed;", "+\t\t\t\t\t\tline[offset+2] = oneGreen;", "+\t\t\t\t\t\tline[offset+3] = oneBlue;", "+\t\t\t\t\t}", "+\t\t\t\t\toffset += 4;", "+\t\t\t\t}", "+\t\t\t\tOS.memmove(data + (y * bpr), line, bpr);", "+\t\t\t}", "+\t\t\tbreak;", "+\t\t}", "+\t\tcase SWT.IMAGE_GRAY: {\t\t\t", "+\t\t\tbyte[] line = new byte[bpr];", "+\t\t\tfor (int y=0; y<height; y++) {", "+\t\t\t\tOS.memmove(line, data + (y * bpr), bpr);", "+\t\t\t\tint offset = 0;", "+\t\t\t\tfor (int x=0; x<width; x++) {", "+\t\t\t\t\tint red = line[offset+1] & 0xFF;", "+\t\t\t\t\tint green = line[offset+2] & 0xFF;", "+\t\t\t\t\tint blue = line[offset+3] & 0xFF;", "+\t\t\t\t\tbyte intensity = (byte)((red+red+green+green+green+green+green+blue) >> 3);", "+\t\t\t\t\tline[offset+1] = line[offset+2] = line[offset+3] = intensity;", "+\t\t\t\t\toffset += 4;", "+\t\t\t\t}", "+\t\t\t\tOS.memmove(data + (y * bpr), line, bpr);", "+\t\t\t}", "+\t\t\tbreak;", "+\t\t}", "+\t}"]}], "num": 17598}