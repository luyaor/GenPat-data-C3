{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ecd3a3658b5056299d809acd16904427", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "337e696a91edeebd7d8d9ae5a7652192", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "5bfbfd6550d25db2695eb695eae08fb135ba96b1", "commitAfterChange": "9f3e004f4f231562877a62ca1bbca78c904abee3", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  void initNative(String filename)", "signatureAfterChange": "  void initNative(String filename)", "diff": ["-\t\t\tboolean hasAlpha = OS.gdk_pixbuf_get_has_alpha(pixbuf);", "-\t\t\tif (OS.USE_CAIRO_SURFACE) {", "-\t\t\t\tint width = this.width = OS.gdk_pixbuf_get_width(pixbuf);", "-\t\t\t\tint height = this.height = OS.gdk_pixbuf_get_height(pixbuf);", "-\t\t\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "-\t\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "-\t\t\t\tint format = hasAlpha ? Cairo.CAIRO_FORMAT_ARGB32 : Cairo.CAIRO_FORMAT_RGB24;", "-\t\t\t\tint cairoStride = Cairo.cairo_format_stride_for_width(format, width);", "-\t\t\t\tint /*long*/ data = surfaceData = OS.g_malloc(cairoStride * height);", "-\t\t\t\tif (surfaceData == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\t\t\tsurface = Cairo.cairo_image_surface_create_for_data(surfaceData, format, width, height, cairoStride);", "-\t\t\t\tif (surface == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\t\t\tbyte[] line = new byte[stride];", "-\t\t\t\tint /*long*/ ptr = OS.malloc(4);", "-\t\t\t\tOS.memmove(ptr, new int[]{1}, 4);", "-\t\t\t\tOS.memmove(line, ptr, 1);", "-\t\t\t\tOS.free(ptr);", "-\t\t\t\tboolean bigendian = line[0] == 0;", "-\t\t\t\tint oa = 0, or = 0, og = 0, ob = 0;", "-\t\t\t\tif (bigendian) {", "-\t\t\t\t\toa = 0; or = 1; og = 2; ob = 3;", "-\t\t\t\t} else {", "-\t\t\t\t\toa = 3; or = 2; og = 1; ob = 0;", "-\t\t\t\t}", "-\t\t\t\tif (hasAlpha) {", "-\t\t\t\t\tbyte[] cairoLine = new byte[cairoStride];", "-\t\t\t\t\tfor (int y = 0; y < height; y++) {", "-\t\t\t\t\t\tOS.memmove(line, pixels + (y * stride), stride);", "-\t\t\t\t\t\tfor (int x = 0, offset = 0; x < width; x++, offset += 4) {", "-\t\t\t\t\t\t\tint a = line[offset + 3] & 0xFF;", "-\t\t\t\t\t\t\tint r = ((line[offset + 0] & 0xFF) * a) + 128;", "-\t\t\t\t\t\t\tr = (r + (r >> 8)) >> 8;", "-\t\t\t\t\t\t\tint g = ((line[offset + 1] & 0xFF) * a) + 128;", "-\t\t\t\t\t\t\tg = (g + (g >> 8)) >> 8;", "-\t\t\t\t\t\t\tint b = ((line[offset + 2] & 0xFF) * a) + 128;", "-\t\t\t\t\t\t\tb = (b + (b >> 8)) >> 8;", "-\t\t\t\t\t\t\tcairoLine[offset + oa] = (byte)a;", "-\t\t\t\t\t\t\tcairoLine[offset + or] = (byte)r;", "-\t\t\t\t\t\t\tcairoLine[offset + og] = (byte)g;", "-\t\t\t\t\t\t\tcairoLine[offset + ob] = (byte)b;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tOS.memmove(data + (y * cairoStride), cairoLine, cairoStride);", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tbyte[] cairoLine = new byte[cairoStride];", "-\t\t\t\t\tfor (int y = 0; y < height; y++) {", "-\t\t\t\t\t\tOS.memmove(line, pixels + (y * stride), stride);", "-\t\t\t\t\t\tfor (int x = 0, offset = 0, cairoOffset = 0; x < width; x++, offset += 3, cairoOffset += 4) {", "-\t\t\t\t\t\t\tint r = line[offset + 0] & 0xFF;", "-\t\t\t\t\t\t\tint g = line[offset + 1] & 0xFF;", "-\t\t\t\t\t\t\tint b = line[offset + 2] & 0xFF;", "-\t\t\t\t\t\t\tcairoLine[cairoOffset + or] = (byte)r;", "-\t\t\t\t\t\t\tcairoLine[cairoOffset + og] = (byte)g;", "-\t\t\t\t\t\t\tcairoLine[cairoOffset + ob] = (byte)b;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tOS.memmove(data + (y * cairoStride), cairoLine, cairoStride);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tOS.g_object_unref (pixbuf);", "-\t\t\t} else {", "-\t\t\t\tif (hasAlpha) {", "-\t\t\t\t\t/*", "-\t\t\t\t\t* Bug in GTK. Depending on the image (seems to affect images that have", "-\t\t\t\t\t* some degree of transparency all over the image), gdk_pixbuff_render_pixmap_and_mask()", "-\t\t\t\t\t* will return a corrupt pixmap. To avoid this, read in and store the alpha channel data", "-\t\t\t\t\t* for the image and then set it to 0xFF to prevent any possible corruption from ", "-\t\t\t\t\t* gdk_pixbuff_render_pixmap_and_mask(). ", "-\t\t\t\t\t*/", "-\t\t\t\t\tint width = OS.gdk_pixbuf_get_width(pixbuf);", "-\t\t\t\t\tint height = OS.gdk_pixbuf_get_height(pixbuf);", "-\t\t\t\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "-\t\t\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "-\t\t\t\t\tbyte[] line = new byte[stride];", "-\t\t\t\t\talphaData = new byte[width * height];", "-\t\t\t\t\tfor (int y = 0; y < height; y++) {", "-\t\t\t\t\t\tOS.memmove(line, pixels + (y * stride), stride);", "-\t\t\t\t\t\tfor (int x = 0; x < width; x++) {", "-\t\t\t\t\t\t\talphaData[y*width+x] = line[x*4 + 3];", "-\t\t\t\t\t\t\tline[x*4 + 3] = (byte) 0xFF;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tOS.memmove(pixels + (y * stride), line, stride);", "-\t\t\t\t\t}", "-\t\t\t\t\tcreateAlphaMask(width, height);", "-\t\t\t\t}", "-\t\t\t\tint /*long*/ [] pixmap_return = new int /*long*/ [1];", "-\t\t\t\tOS.gdk_pixbuf_render_pixmap_and_mask(pixbuf, pixmap_return, null, 0);", "-\t\t\t\tOS.g_object_unref (pixbuf);", "-\t\t\t\tthis.type = SWT.BITMAP;", "-\t\t\t\tthis.pixmap = pixmap_return[0];", "-\t\t\t\tif (pixmap == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\t\ttry {", "+\t\t\t\tcreateFromPixbuf (pixbuf);", "+\t\t\t} finally {", "+\t\t\t\tif (pixbuf != 0) OS.g_object_unref (pixbuf);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b24daf61e9b6c98c16192b52d83bc758", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "d089b2cf79ce87d2a82f677ea1a4ce5a5ba9d4a4", "commitAfterChange": "78b034106c080360cc188a981bb53f8356762fbe", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  void initNative(String filename)", "signatureAfterChange": "  void initNative(String filename)", "diff": ["-\t\t\tboolean hasAlpha = OS.gdk_pixbuf_get_has_alpha(pixbuf);", "-\t\t\tif (hasAlpha) {", "-\t\t\t\t/*", "-\t\t\t\t* Bug in GTK. Depending on the image (seems to affect images that have", "-\t\t\t\t* some degree of transparency all over the image), gdk_pixbuff_render_pixmap_and_mask()", "-\t\t\t\t* will return a corrupt pixmap. To avoid this, read in and store the alpha channel data", "-\t\t\t\t* for the image and then set it to 0xFF to prevent any possible corruption from ", "-\t\t\t\t* gdk_pixbuff_render_pixmap_and_mask(). ", "-\t\t\t\t*/", "-\t\t\t\tint width = OS.gdk_pixbuf_get_width(pixbuf);", "-\t\t\t\tint height = OS.gdk_pixbuf_get_height(pixbuf);", "+\t\t\tif (OS.USE_CAIRO_SURFACE) {", "+\t\t\t\tint width = this.width = OS.gdk_pixbuf_get_width(pixbuf);", "+\t\t\t\tint height = this.height = OS.gdk_pixbuf_get_height(pixbuf);", "-\t\t\t\tbyte[] line = new byte[stride];", "-\t\t\t\talphaData = new byte[width * height];", "+\t\t\t\tint cairoStride = Cairo.cairo_format_stride_for_width(Cairo.CAIRO_FORMAT_ARGB32, width);", "+\t\t\t\tint /*long*/ data = surfaceData = OS.g_malloc(cairoStride * height);", "+\t\t\t\tif (surfaceData == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\t\t\tsurface = Cairo.cairo_image_surface_create_for_data(surfaceData, Cairo.CAIRO_FORMAT_ARGB32, width, height, cairoStride);", "+\t\t\t\tif (surface == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\t\t\tbyte[] line = new byte[Math.max(cairoStride, stride)];", "+\t\t\t\tint /*long*/ ptr = OS.malloc(4);", "+\t\t\t\tOS.memmove(ptr, new int[]{1}, 4);", "+\t\t\t\tOS.memmove(line, ptr, 1);", "+\t\t\t\tOS.free(ptr);", "+\t\t\t\tboolean bigendian = line[0] == 0;", "+\t\t\t\tint oa = 0, or = 0, og = 0, ob = 0;", "+\t\t\t\tif (bigendian) {", "+\t\t\t\t\toa = 0; or = 1; og = 2; ob = 3;", "+\t\t\t\t} else {", "+\t\t\t\t\toa = 3; or = 2; og = 1; ob = 0;", "+\t\t\t\t}", "-\t\t\t\t\tfor (int x = 0; x < width; x++) {", "-\t\t\t\t\t\talphaData[y*width+x] = line[x*4 + 3];", "-\t\t\t\t\t\tline[x*4 + 3] = (byte) 0xFF;", "+\t\t\t\t\tfor (int x = 0, offset = 0; x < width; x++, offset += 4) {", "+\t\t\t\t\t\tint a = line[offset + 3] & 0xFF;", "+\t\t\t\t\t\tint r = ((line[offset + 0] & 0xFF) * a) + 128;", "+\t\t\t\t\t\tr = (r + (r >> 8)) >> 8;", "+\t\t\t\t\t\tint g = ((line[offset + 1] & 0xFF) * a) + 128;", "+\t\t\t\t\t\tg = (g + (g >> 8)) >> 8;", "+\t\t\t\t\t\tint b = ((line[offset + 2] & 0xFF) * a) + 128;", "+\t\t\t\t\t\tb = (b + (b >> 8)) >> 8;", "+\t\t\t\t\t\tline[offset + oa] = (byte)a;", "+\t\t\t\t\t\tline[offset + or] = (byte)r;", "+\t\t\t\t\t\tline[offset + og] = (byte)g;", "+\t\t\t\t\t\tline[offset + ob] = (byte)b;", "-\t\t\t\t\tOS.memmove(pixels + (y * stride), line, stride);", "+\t\t\t\t\tOS.memmove(data + (y * cairoStride), line, cairoStride);", "-\t\t\t\tcreateAlphaMask(width, height);", "+\t\t\t\tOS.g_object_unref (pixbuf);", "+\t\t\t} else {", "+\t\t\t\tboolean hasAlpha = OS.gdk_pixbuf_get_has_alpha(pixbuf);", "+\t\t\t\tif (hasAlpha) {", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Bug in GTK. Depending on the image (seems to affect images that have", "+\t\t\t\t\t* some degree of transparency all over the image), gdk_pixbuff_render_pixmap_and_mask()", "+\t\t\t\t\t* will return a corrupt pixmap. To avoid this, read in and store the alpha channel data", "+\t\t\t\t\t* for the image and then set it to 0xFF to prevent any possible corruption from ", "+\t\t\t\t\t* gdk_pixbuff_render_pixmap_and_mask(). ", "+\t\t\t\t\t*/", "+\t\t\t\t\tint width = OS.gdk_pixbuf_get_width(pixbuf);", "+\t\t\t\t\tint height = OS.gdk_pixbuf_get_height(pixbuf);", "+\t\t\t\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "+\t\t\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\t\t\t\tbyte[] line = new byte[stride];", "+\t\t\t\t\talphaData = new byte[width * height];", "+\t\t\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\t\t\tOS.memmove(line, pixels + (y * stride), stride);", "+\t\t\t\t\t\tfor (int x = 0; x < width; x++) {", "+\t\t\t\t\t\t\talphaData[y*width+x] = line[x*4 + 3];", "+\t\t\t\t\t\t\tline[x*4 + 3] = (byte) 0xFF;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tOS.memmove(pixels + (y * stride), line, stride);", "+\t\t\t\t\t}", "+\t\t\t\t\tcreateAlphaMask(width, height);", "+\t\t\t\t}", "+\t\t\t\tint /*long*/ [] pixmap_return = new int /*long*/ [1];", "+\t\t\t\tOS.gdk_pixbuf_render_pixmap_and_mask(pixbuf, pixmap_return, null, 0);", "+\t\t\t\tOS.g_object_unref (pixbuf);", "+\t\t\t\tthis.type = SWT.BITMAP;", "+\t\t\t\tthis.pixmap = pixmap_return[0];", "+\t\t\t\tif (pixmap == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\t\tint /*long*/ [] pixmap_return = new int /*long*/ [1];", "-\t\t\tOS.gdk_pixbuf_render_pixmap_and_mask(pixbuf, pixmap_return, null, 0);", "-\t\t\tthis.type = SWT.BITMAP;", "-\t\t\tthis.pixmap = pixmap_return[0];", "-\t\t\tif (pixmap == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\t\tOS.g_object_unref (pixbuf);"]}], "num": 28454}