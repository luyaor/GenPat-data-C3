{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "14be92d8a81c3686845ab89d5cd2c5af", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bffb49434b5141b76b9f85af16225e5e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "7437a3d139f18294dcb7c1d3554eb760222cd876", "commitAfterChange": "eccf3f9dfad619459ad0b8e1ee4716ddc8dc2aae", "methodNumberBeforeChange": 165, "methodNumberAfterChange": 165, "signatureBeforeChange": "\r \r LRESULT WM_LBUTTONDOWN (int wParam, int lParam)", "signatureAfterChange": "\r \r LRESULT WM_LBUTTONDOWN (int wParam, int lParam)", "diff": ["-\tsendMouseEvent (SWT.MouseDown, 1, OS.WM_LBUTTONDOWN, wParam, lParam);\r", "-\tint result = callWindowProc (OS.WM_LBUTTONDOWN, wParam, lParam);\r", "-\tif (OS.GetCapture () != handle) OS.SetCapture (handle);\r", "+\tboolean dragging = false;\r", "-\t\tif (!OS.IsWinCE) {\r", "-\t\t\t/*\r", "-\t\t\t* The DragDetect function captures the mouse and tracks its movement until the user releases\r", "-\t\t\t* the left button, presses the ESC key, or moves the mouse outside the drag rectangle around \r", "-\t\t\t* the specified point.   If the user moves the mouse outside of the drag rectangle, DragDetect\r", "-\t\t\t* returns true.\r", "-\t\t\t*/\r", "-\t\t\tif (OS.DragDetect (handle, pt)) {\r", "-\t\t\t\tpostEvent (SWT.DragDetect);\r", "-\t\t\t} else {\r", "-\t\t\t\t/*\r", "-\t\t\t\t* The Mouse up event and the ESC key event have been consumed by DragDetect so \r", "-\t\t\t\t* detect the cases and send the events.\r", "-\t\t\t\t*/\r", "-\t\t\t\tif (OS.GetKeyState (OS.VK_ESCAPE) >= 0) {\r", "-\t\t\t\t\tsendMouseEvent (SWT.MouseUp, 1, OS.WM_LBUTTONUP, wParam, lParam);\r", "-\t\t\t\t\t// widget could be disposed at this point\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "+\t\tif (!OS.IsWinCE) dragging = OS.DragDetect (handle, pt);\r", "+\t}\r", "+\tsendMouseEvent (SWT.MouseDown, 1, OS.WM_LBUTTONDOWN, wParam, lParam);\r", "+\tint result = callWindowProc (OS.WM_LBUTTONDOWN, wParam, lParam);\r", "+\tif (OS.GetCapture () != handle) OS.SetCapture (handle);\r", "+\tif (dragging) {\r", "+\t\tpostEvent (SWT.DragDetect);\r", "+\t} else {\r", "+\t\t/*\r", "+\t\t* Feature in Windows.  DragDetect() captures the mouse\r", "+\t\t* and tracks its movement until the user releases the\r", "+\t\t* left mouse button, presses the ESC key, or moves the\r", "+\t\t* mouse outside the drag rectangle.  If the user moves\r", "+\t\t* the mouse outside of the drag rectangle, DragDetect\r", "+\t\t* returns true and a drag and drop operation can be\r", "+\t\t* started.  When the left mouse button is released or\r", "+\t\t* the ESC key is pressed, these events are consumed by\r", "+\t\t* DragDetect() so that application code that matches\r", "+\t\t* mouse down/up pairs or looks for the ESC key will not\r", "+\t\t* function properly.  The fix is to send these events\r", "+\t\t* when the drag has not started.\r", "+\t\t* \r", "+\t\t* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP\r", "+\t\t* events for the ESC key.  This would require computing\r", "+\t\t* wParam (the key) and lParam (the repeat count, scan code,\r", "+\t\t* extended-key flag, context code, previous key-state flag,\r", "+\t\t* and transition-state flag) which is non-trivial.\r", "+\t\t*/\r", "+\t\tif (OS.GetKeyState (OS.VK_ESCAPE) >= 0) {\r", "+\t\t\tOS.SendMessage (handle, OS.WM_LBUTTONUP, wParam, lParam);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb1952ddb77ea7183b8adb462ed1ee3d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "bd469e488bef6f88459d9c0535159f8167416d1f", "commitAfterChange": "0f22a30a5b82bfeb0c093bba732059285a8fbaba", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 30, "signatureBeforeChange": " Event dragDetect (Event event)", "signatureAfterChange": " public boolean dragDetect (int button, int stateMask, int x, int y)", "diff": ["-//TODO - Javadoc", "-/*public*/ Event dragDetect (Event event) {", "+public boolean dragDetect (int button, int stateMask, int x, int y) {", "-\tif (event == null) error (SWT.ERROR_NULL_ARGUMENT);", "-\tif (!dragDetect (handle, event.x, event.y, false, null, null)) return null;", "-\tEvent dragEvent = new Event ();", "-\tdragEvent.button = event.button;", "-\tdragEvent.x = event.x;", "-\tdragEvent.y = event.y;", "-\tdragEvent.stateMask = event.stateMask;", "-\treturn dragEvent;", "+\tif (button != 1) return false;", "+\tif (!dragDetect (handle, x, y, false, null, null)) {", "+\t\t/*", "+\t\t* Feature in Windows.  DragDetect() captures the mouse", "+\t\t* and tracks its movement until the user releases the", "+\t\t* left mouse button, presses the ESC key, or moves the", "+\t\t* mouse outside the drag rectangle.  If the user moves", "+\t\t* the mouse outside of the drag rectangle, DragDetect()", "+\t\t* returns true and a drag and drop operation can be", "+\t\t* started.  When the left mouse button is released or", "+\t\t* the ESC key is pressed, these events are consumed by", "+\t\t* DragDetect() so that application code that matches", "+\t\t* mouse down/up pairs or looks for the ESC key will not", "+\t\t* function properly.  The fix is to send the missing", "+\t\t* events when the drag has not started.", "+\t\t* ", "+\t\t* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP", "+\t\t* events for the ESC key.  This would require computing", "+\t\t* wParam (the key) and lParam (the repeat count, scan code,", "+\t\t* extended-key flag, context code, previous key-state flag,", "+\t\t* and transition-state flag) which is non-trivial.", "+\t\t*/", "+\t\tif (button == 1 && OS.GetKeyState (OS.VK_ESCAPE) >= 0) {", "+\t\t\tint wParam = 0;", "+\t\t\tif ((stateMask & SWT.CTRL) != 0) wParam |= OS.MK_CONTROL;", "+\t\t\tif ((stateMask & SWT.SHIFT) != 0) wParam |= OS.MK_SHIFT;", "+\t\t\tif ((stateMask & SWT.ALT) != 0) wParam |= OS.MK_ALT;", "+\t\t\tif ((stateMask & SWT.BUTTON1) != 0) wParam |= OS.MK_LBUTTON;", "+\t\t\tif ((stateMask & SWT.BUTTON2) != 0) wParam |= OS.MK_MBUTTON;", "+\t\t\tif ((stateMask & SWT.BUTTON3) != 0) wParam |= OS.MK_RBUTTON;", "+\t\t\tif ((stateMask & SWT.BUTTON4) != 0) wParam |= OS.MK_XBUTTON1;", "+\t\t\tif ((stateMask & SWT.BUTTON5) != 0) wParam |= OS.MK_XBUTTON2;", "+\t\t\tint lParam = (x & 0xFFFF) | ((y << 16) & 0xFFFF0000);", "+\t\t\tOS.SendMessage (handle, OS.WM_LBUTTONUP, wParam, lParam);", "+\t\t}", "+\t\treturn false;", "+\t}", "+\treturn sendDragEvent (button, stateMask, x, y);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c8ac218e27b73034e97ebc7e36e421ef", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "eccf3f9dfad619459ad0b8e1ee4716ddc8dc2aae", "commitAfterChange": "46f2ec1e17ee0fd83ca086dc9c5ef074b69e3813", "methodNumberBeforeChange": 165, "methodNumberAfterChange": 165, "signatureBeforeChange": "\r \r LRESULT WM_LBUTTONDOWN (int wParam, int lParam)", "signatureAfterChange": "\r \r LRESULT WM_LBUTTONDOWN (int wParam, int lParam)", "diff": ["-\t\t/*\r", "-\t\t* Feature in Windows.  DragDetect() captures the mouse\r", "-\t\t* and tracks its movement until the user releases the\r", "-\t\t* left mouse button, presses the ESC key, or moves the\r", "-\t\t* mouse outside the drag rectangle.  If the user moves\r", "-\t\t* the mouse outside of the drag rectangle, DragDetect\r", "-\t\t* returns true and a drag and drop operation can be\r", "-\t\t* started.  When the left mouse button is released or\r", "-\t\t* the ESC key is pressed, these events are consumed by\r", "-\t\t* DragDetect() so that application code that matches\r", "-\t\t* mouse down/up pairs or looks for the ESC key will not\r", "-\t\t* function properly.  The fix is to send these events\r", "-\t\t* when the drag has not started.\r", "-\t\t* \r", "-\t\t* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP\r", "-\t\t* events for the ESC key.  This would require computing\r", "-\t\t* wParam (the key) and lParam (the repeat count, scan code,\r", "-\t\t* extended-key flag, context code, previous key-state flag,\r", "-\t\t* and transition-state flag) which is non-trivial.\r", "-\t\t*/\r", "-\t\tif (OS.GetKeyState (OS.VK_ESCAPE) >= 0) {\r", "-\t\t\tOS.SendMessage (handle, OS.WM_LBUTTONUP, wParam, lParam);\r", "+\t\tif (hooks (SWT.DragDetect)) {\r", "+\t\t\t/*\r", "+\t\t\t* Feature in Windows.  DragDetect() captures the mouse\r", "+\t\t\t* and tracks its movement until the user releases the\r", "+\t\t\t* left mouse button, presses the ESC key, or moves the\r", "+\t\t\t* mouse outside the drag rectangle.  If the user moves\r", "+\t\t\t* the mouse outside of the drag rectangle, DragDetect\r", "+\t\t\t* returns true and a drag and drop operation can be\r", "+\t\t\t* started.  When the left mouse button is released or\r", "+\t\t\t* the ESC key is pressed, these events are consumed by\r", "+\t\t\t* DragDetect() so that application code that matches\r", "+\t\t\t* mouse down/up pairs or looks for the ESC key will not\r", "+\t\t\t* function properly.  The fix is to send these events\r", "+\t\t\t* when the drag has not started.\r", "+\t\t\t* \r", "+\t\t\t* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP\r", "+\t\t\t* events for the ESC key.  This would require computing\r", "+\t\t\t* wParam (the key) and lParam (the repeat count, scan code,\r", "+\t\t\t* extended-key flag, context code, previous key-state flag,\r", "+\t\t\t* and transition-state flag) which is non-trivial.\r", "+\t\t\t*/\r", "+\t\t\tif (OS.GetKeyState (OS.VK_ESCAPE) >= 0) {\r", "+\t\t\t\tOS.SendMessage (handle, OS.WM_LBUTTONUP, wParam, lParam);\r", "+\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bbc40908fb769c695ec784456b4a5b35", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "272967205f3824ec29456112026262c64ae69dfa", "commitAfterChange": "fc62fa389f9358a82d98c59fbeba910f7ca8c593", "methodNumberBeforeChange": 187, "methodNumberAfterChange": 185, "signatureBeforeChange": "  LRESULT WM_LBUTTONDOWN (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_LBUTTONDOWN (int wParam, int lParam)", "diff": ["-\tboolean dragging = false, mouseDown = true;", "-\tboolean dragDetect = hooks (SWT.DragDetect);", "-\tif (dragDetect) {", "-\t\tif (!OS.IsWinCE) {", "-\t\t\t/*", "-\t\t\t* Feature in Windows.  It's possible that the drag", "-\t\t\t* operation will not be started while the mouse is", "-\t\t\t* down, meaning that the mouse should be captured.", "-\t\t\t* This can happen when the user types the ESC key", "-\t\t\t* to cancel the drag.  The fix is to query the state", "-\t\t\t* of the mouse and capture the mouse accordingly.", "-\t\t\t*/", "-\t\t\tPOINT pt = new POINT ();", "-\t\t\tpt.x = (short) (lParam & 0xFFFF);", "-\t\t\tpt.y = (short) (lParam >> 16);", "-\t\t\tOS.ClientToScreen(handle, pt);", "-\t\t\tdragging = OS.DragDetect (handle, pt);", "-\t\t\tmouseDown = OS.GetKeyState (OS.VK_LBUTTON) < 0;", "-\t\t}", "-\t}", "-\tsendMouseEvent (SWT.MouseDown, 1, OS.WM_LBUTTONDOWN, wParam, lParam);", "-\tint result = callWindowProc (OS.WM_LBUTTONDOWN, wParam, lParam);\t", "-\tif (OS.IsPPC) {", "-\t\t/*", "-\t\t* Note: On WinCE PPC, only attempt to recognize the gesture for", "-\t\t* a context menu when the control contains a valid menu or there", "-\t\t* are listeners for the MenuDetect event.", "-\t\t*/", "-\t\tboolean hasMenu = menu != null && !menu.isDisposed ();", "-\t\tif (hasMenu || hooks (SWT.MenuDetect)) {", "-\t\t\tint x = (short) (lParam & 0xFFFF);", "-\t\t\tint y = (short) (lParam >> 16);", "-\t\t\tSHRGINFO shrg = new SHRGINFO ();", "-\t\t\tshrg.cbSize = SHRGINFO.sizeof;", "-\t\t\tshrg.hwndClient = handle;", "-\t\t\tshrg.ptDown_x = x;", "-\t\t\tshrg.ptDown_y = y; ", "-\t\t\tshrg.dwFlags = OS.SHRG_RETURNCMD;", "-\t\t\tint type = OS.SHRecognizeGesture (shrg);", "-\t\t\tif (type == OS.GN_CONTEXTMENU) showMenu (x, y);", "-\t\t}", "-\t}", "-\tif (mouseDown) {", "-\t\tif (OS.GetCapture () != handle) OS.SetCapture (handle);", "-\t}", "-\tif (dragging) {", "-\t\tEvent event = new Event ();", "-\t\tevent.x = (short) (lParam & 0xFFFF);", "-\t\tevent.y = (short) (lParam >> 16);", "-\t\tpostEvent (SWT.DragDetect, event);", "-\t} else {", "-\t\tif (dragDetect) {", "-\t\t\t/*", "-\t\t\t* Feature in Windows.  DragDetect() captures the mouse", "-\t\t\t* and tracks its movement until the user releases the", "-\t\t\t* left mouse button, presses the ESC key, or moves the", "-\t\t\t* mouse outside the drag rectangle.  If the user moves", "-\t\t\t* the mouse outside of the drag rectangle, DragDetect()", "-\t\t\t* returns true and a drag and drop operation can be", "-\t\t\t* started.  When the left mouse button is released or", "-\t\t\t* the ESC key is pressed, these events are consumed by", "-\t\t\t* DragDetect() so that application code that matches", "-\t\t\t* mouse down/up pairs or looks for the ESC key will not", "-\t\t\t* function properly.  The fix is to send these events", "-\t\t\t* when the drag has not started.", "-\t\t\t* ", "-\t\t\t* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP", "-\t\t\t* events for the ESC key.  This would require computing", "-\t\t\t* wParam (the key) and lParam (the repeat count, scan code,", "-\t\t\t* extended-key flag, context code, previous key-state flag,", "-\t\t\t* and transition-state flag) which is non-trivial.", "-\t\t\t*/", "-\t\t\tif (OS.GetKeyState (OS.VK_ESCAPE) >= 0) {", "-\t\t\t\tOS.SendMessage (handle, OS.WM_LBUTTONUP, wParam, lParam);", "-\t\t\t}", "-\t\t}", "-\t}", "-\treturn new LRESULT (result);", "+\treturn wmLButtonDown (handle, wParam, lParam);"]}], "num": 22990}