{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4f72ad5a1a6b03ee1c31df9c026086b9", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f7e5fd5e35f2d270a66e42b3499a932", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "25fb0cca69f4d72e15a967512c53b05f06bed688", "commitAfterChange": "67b77f899a146f36fba6d648971eea4ee205b66e", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " public void draw(GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground, int flags)", "signatureAfterChange": " public void draw(GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground, int flags)", "diff": ["-\tCallback callback = null;", "+\t\t\t\t\tOS.CGContextSaveGState(gc.handle);", "-\t\t\t\t\tOS.CGContextSaveGState(gc.handle);", "-\t\t\t\t\tif (callback == null) {", "-\t\t\t\t\t\tcallback = new Callback(this, \"regionToRects\", 4);", "-\t\t\t\t\t\tif (callback.getAddress() == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.QDRegionToRects(rgn, OS.kQDParseRegionFromTopLeft, callback.getAddress(), gc.handle);", "+\t\t\t\t\tint shape = OS.HIShapeCreateWithQDRgn(rgn);", "+\t\t\t\t\tOS.HIShapeReplacePathInCGContext(shape, gc.handle);", "+\t\t\t\t\tOS.DisposeControl(shape);", "-\tif (callback != null) callback.dispose();", "-\tcallback = null;", "-\tCallback borderCallback = null;", "+\t\t\t\t\t\tOS.CGContextSaveGState(gc.handle);", "-\t\t\t\t\t\tOS.CGContextSaveGState(gc.handle);", "+\t\t\t\t\t\tint[] count = new int[1];", "+\t\t\t\t\t\tOS.ATSUGetGlyphBounds(layout, OS.Long2Fix(x), OS.X2Fix(underlineY), highStart, highLen, (short)OS.kATSUseDeviceOrigins, 0, 0, count);", "+\t\t\t\t\t\tint trapezoidsPtr = OS.malloc(count[0] * ATSTrapezoid.sizeof);", "+\t\t\t\t\t\tOS.ATSUGetGlyphBounds(layout, OS.Long2Fix(x), OS.X2Fix(underlineY), highStart, highLen, (short)OS.kATSUseDeviceOrigins, count[0], trapezoidsPtr, count);", "+\t\t\t\t\t\tATSTrapezoid trapezoid = new ATSTrapezoid();", "+\t\t\t\t\t\tfor (int k = 0; k < count[0]; k++) {", "+\t\t\t\t\t\t\tOS.memmove(trapezoid, trapezoidsPtr + (k * ATSTrapezoid.sizeof), ATSTrapezoid.sizeof);", "+\t\t\t\t\t\t\tfloat ux, uy, lx, ly, a, b;", "+\t\t\t\t\t\t\tux = OS.Fix2Long(trapezoid.upperLeft_x);", "+\t\t\t\t\t\t\tuy = OS.Fix2Long(trapezoid.upperLeft_y);", "+\t\t\t\t\t\t\tlx = OS.Fix2Long(trapezoid.lowerLeft_x);", "+\t\t\t\t\t\t\tly = OS.Fix2Long(trapezoid.lowerLeft_y);", "+\t\t\t\t\t\t\ta = (uy - ly) / (ux - lx);", "+\t\t\t\t\t\t\tb = uy - ux * a;", "+\t\t\t\t\t\t\tfloat left = (underlineY - b) / a;", "+\t\t\t\t\t\t\tux = OS.Fix2Long(trapezoid.upperRight_x);", "+\t\t\t\t\t\t\tuy = OS.Fix2Long(trapezoid.upperRight_y);", "+\t\t\t\t\t\t\tlx = OS.Fix2Long(trapezoid.lowerRight_x);", "+\t\t\t\t\t\t\tly = OS.Fix2Long(trapezoid.lowerRight_y);", "+\t\t\t\t\t\t\ta = (uy - ly) / (ux - lx);", "+\t\t\t\t\t\t\tb = uy - ux * a;", "+\t\t\t\t\t\t\tfloat right = (underlineY - b) / a;", "+\t\t\t\t\t\t\tswitch (style.underlineStyle) {", "+\t\t\t\t\t\t\t\tcase UNDERLINE_IME_TARGET_CONVERTED:", "+\t\t\t\t\t\t\t\tcase UNDERLINE_IME_CONVERTED:", "+\t\t\t\t\t\t\t\t\tleft += 1;", "+\t\t\t\t\t\t\t\t\tright -= 1;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tOS.CGContextMoveToPoint(gc.handle, left, OS.Fix2Long(trapezoid.upperLeft_y));", "+\t\t\t\t\t\t\tOS.CGContextAddLineToPoint(gc.handle, right, OS.Fix2Long(trapezoid.upperRight_y));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tOS.free(trapezoidsPtr);", "-\t\t\t\t\t\tOS.ATSUGetTextHighlight(layout, OS.Long2Fix(x), OS.X2Fix(underlineY), highStart, highLen, rgn);", "-\t\t\t\t\t\tif (callback == null) {", "-\t\t\t\t\t\t\tcallback = new Callback(this, \"drawUnderline\", 4);", "-\t\t\t\t\t\t\tif (callback.getAddress() == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tdrawStyle = run;", "-\t\t\t\t\t\tOS.CGContextTranslateCTM (gc.handle, 0.5f, 0.5f);", "-\t\t\t\t\t\tOS.QDRegionToRects(rgn, OS.kQDParseRegionFromTopLeft, callback.getAddress(), gc.handle);", "+\t\t\t\t\t\tOS.CGContextTranslateCTM(gc.handle, 0.5f, 0.5f);", "-\t\t\t\t\t\tOS.ATSUGetTextHighlight(layout, OS.Long2Fix(x), OS.Long2Fix(y + lineY + lineAscent[i]), highStart, highLen, rgn);", "-\t\t\t\t\t\tif (borderCallback == null) {", "-\t\t\t\t\t\t\tborderCallback = new Callback(this, \"drawBorder\", 4);", "-\t\t\t\t\t\t\tif (borderCallback.getAddress() == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "+\t\t\t\t\t\tint[] count = new int[1];", "+\t\t\t\t\t\tOS.ATSUGetGlyphBounds(layout, OS.Long2Fix(x), OS.Long2Fix(y + lineY + lineAscent[i]), highStart, highLen, (short)OS.kATSUseDeviceOrigins, 0, 0, count);", "+\t\t\t\t\t\tint trapezoidsPtr = OS.malloc(count[0] * ATSTrapezoid.sizeof);", "+\t\t\t\t\t\tOS.ATSUGetGlyphBounds(layout, OS.Long2Fix(x), OS.Long2Fix(y + lineY + lineAscent[i]), highStart, highLen, (short)OS.kATSUseDeviceOrigins, count[0], trapezoidsPtr, count);", "+\t\t\t\t\t\tATSTrapezoid trapezoid = new ATSTrapezoid();", "+\t\t\t\t\t\tfor (int k = 0; k < count[0]; k++) {", "+\t\t\t\t\t\t\tOS.memmove(trapezoid, trapezoidsPtr + (k * ATSTrapezoid.sizeof), ATSTrapezoid.sizeof);", "+\t\t\t\t\t\t\tint upperY = y + lineY + 1;", "+\t\t\t\t\t\t\tint lowerY = y + lineY + lineHeight[i];", "+\t\t\t\t\t\t\tOS.CGContextMoveToPoint(gc.handle, OS.Fix2Long(trapezoid.lowerLeft_x), lowerY);", "+\t\t\t\t\t\t\tOS.CGContextAddLineToPoint(gc.handle, OS.Fix2Long(trapezoid.upperLeft_x), upperY);", "+\t\t\t\t\t\t\tOS.CGContextAddLineToPoint(gc.handle, OS.Fix2Long(trapezoid.upperRight_x) - 1, upperY);", "+\t\t\t\t\t\t\tOS.CGContextAddLineToPoint(gc.handle, OS.Fix2Long(trapezoid.lowerRight_x) - 1, lowerY);", "+\t\t\t\t\t\t\tOS.CGContextClosePath(gc.handle);", "-\t\t\t\t\t\tOS.CGContextTranslateCTM(gc.handle, 0.5f, 0.5f);", "-\t\t\t\t\t\tOS.QDRegionToRects(rgn, OS.kQDParseRegionFromTopLeft, borderCallback.getAddress(), gc.handle);", "+\t\t\t\t\t\tOS.free(trapezoidsPtr);", "+\t\t\t\t\t\tOS.CGContextTranslateCTM (gc.handle, 0.5f, 0.5f);", "-\tif (callback != null) callback.dispose();", "-\tcallback = null;", "-\tif (borderCallback != null) borderCallback.dispose();", "-\tborderCallback = null;", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "05d77ebedfa958d741373de715029fd0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void copyArea(int x, int y, int width, int height, int destX, int destY)", "signatureAfterChange": " public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY)", "diff": ["-public void copyArea(int x, int y, int width, int height, int destX, int destY) {", "-\tif (handle == 0) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);", "-\tif (width <= 0 || height <= 0) return;", "-\tint deltaX = destX - x, deltaY = destY - y;", "-\tif (deltaX == 0 && deltaY == 0) return;", "-\t\t", "-\tRectangle src= new Rectangle(x, y, width, height);", "-\tsrc= src.union(new Rectangle(destX, destY, width, height));", "-\tMacRect r= new MacRect(src);", "-\t", "-\ttry {", "-\t\tif (focus(true, null)) {", "-\t\t\tint rgn= OS.NewRgn();", "-\t\t\tOS.ScrollRect(r.getData(), (short)deltaX, (short)deltaY, rgn);", "-\t\t\tOS.InvalWindowRgn(OS.GetWindowFromPort(handle), rgn);", "-\t\t\tOS.DisposeRgn(rgn);", "-\t\t}", "-\t} finally {", "-\t\tunfocus(true);", "-\t}", "+ */", "+public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY) {", "+\tif (handle == 0) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);", "+\tif (width <= 0 || height <= 0) return;", "+\tint deltaX = destX - srcX, deltaY = destY - srcY;", "+\tif (deltaX == 0 && deltaY == 0) return;", "+\tif (data.image != null) {", "+ \t\tOS.CGContextSaveGState(handle);", "+ \t\tOS.CGContextScaleCTM(handle, 1, -1);", "+ \t\tOS.CGContextTranslateCTM(handle, 0, -(height + 2 * destY));", "+ \t\tCGRect rect = new CGRect();", "+ \t\trect.x = destX;", "+ \t\trect.y = destY;", "+ \t\trect.width = width;", "+\t\trect.height = height;", "+\t\t//NOT DONE - transparency", "+ \t\tOS.CGContextDrawImage(handle, rect, data.image.handle);", "+ \t\tOS.CGContextRestoreGState(handle);", "+ \t\treturn;", "+\t}", "+\tif (data.control != 0) {", "+\t\tint window = OS.GetControlOwner(data.control);", "+\t\tint port = OS.GetWindowPort(window);", "+", "+\t\t/* Calculate src and dest rectangles/regions */", "+\t\tRect rect = new Rect();", "+\t\tOS.GetControlBounds(data.control, rect);\t\t", "+\t\tRect srcRect = new Rect();", "+\t\tOS.GetControlBounds(data.control, srcRect);", "+\t\tint left = srcRect.left + srcX;", "+\t\tint top = srcRect.top + srcY;", "+\t\tOS.SetRect(srcRect, (short)left, (short)top, (short)(left + width), (short)(top + height));", "+\t\tint srcRgn = OS.NewRgn();", "+\t\tOS.RectRgn(srcRgn, srcRect);\t\t", "+\t\tOS.SectRect(rect, srcRect, srcRect);", "+\t\tRect destRect = new Rect ();", "+\t\tdestRect.left = srcRect.left;", "+\t\tdestRect.top = srcRect.top;", "+\t\tdestRect.right = srcRect.right;", "+\t\tdestRect.bottom = srcRect.bottom;", "+\t\tOS.OffsetRect(destRect, (short)deltaX, (short)deltaY);", "+\t\tint destRgn = OS.NewRgn();", "+\t\tOS.RectRgn(destRgn, destRect);", "+\t\t", "+\t\t/* Copy bits with appropriated clipping region */", "+\t\tif (!OS.EmptyRect(srcRect)) {", "+\t\t\tint clipRgn = data.visibleRgn;", "+\t\t\tif (data.clipRgn != 0) {", "+\t\t\t\tclipRgn = OS.NewRgn();", "+\t\t\t\tOS.SectRgn(data.clipRgn, clipRgn, clipRgn);", "+\t\t\t}", "+", "+\t\t\t/*", "+\t\t\t* Feature in the Macintosh.  ScrollRect() only copies bits", "+\t\t\t* that are inside the specified rectangle.  This means that", "+\t\t\t* it is not possible to copy non overlaping bits without", "+\t\t\t* copying the bits in between the source and destination", "+\t\t\t* rectangles.  The fix is to check if the source and", "+\t\t\t* destination rectangles are disjoint and use CopyBits()", "+\t\t\t* instead.", "+\t\t\t*/", "+\t\t\tboolean disjoint = (destX + width < srcX) || (srcX + width < destX) || (destY + height < srcY) || (srcY + height < destY);", "+\t\t\tif (!disjoint && (deltaX == 0 || deltaY == 0)) {", "+\t\t\t\tint[] currentPort = new int[1];", "+\t\t\t\tOS.GetPort(currentPort);", "+\t\t\t\tOS.SetPort(port);", "+\t\t\t\tint oldClip = OS.NewRgn();", "+\t\t\t\tOS.GetClip(oldClip);", "+\t\t\t\tOS.SetClip(clipRgn);", "+\t\t\t\tOS.UnionRect(srcRect, destRect, rect);", "+\t\t\t\tOS.ScrollRect(rect, (short)deltaX, (short)deltaY, 0);", "+\t\t\t\tOS.SetClip(oldClip);", "+\t\t\t\tOS.DisposeRgn(oldClip);", "+\t\t\t\tOS.SetPort(currentPort[0]);", "+\t\t\t} else {", "+\t\t\t\tint portBitMap = OS.GetPortBitMapForCopyBits (port);", "+\t\t\t\tOS.CopyBits(portBitMap, portBitMap, srcRect, destRect, (short)OS.srcCopy, clipRgn);", "+\t\t\t\tOS.QDFlushPortBuffer(port, destRgn);", "+\t\t\t}", "+\t\t\t", "+\t\t\tif (clipRgn != data.visibleRgn) OS.DisposeRgn(clipRgn);", "+\t\t}", "+\t\t", "+\t\t/* Invalidate src and obscured areas */", "+\t\tint invalRgn = OS.NewRgn();", "+\t\tOS.DiffRgn(srcRgn, data.visibleRgn, invalRgn);", "+\t\tOS.OffsetRgn(invalRgn, (short)deltaX, (short)deltaY);", "+\t\tOS.DiffRgn(srcRgn, destRgn, srcRgn);", "+\t\tOS.UnionRgn(srcRgn, invalRgn, invalRgn);", "+\t\tOS.SectRgn(data.visibleRgn, invalRgn, invalRgn);", "+\t\tOS.InvalWindowRgn(window, invalRgn);", "+\t\tOS.DisposeRgn(invalRgn);", "+\t\t", "+\t\t/* Dispose src and dest regions */", "+\t\tOS.DisposeRgn(destRgn);", "+\t\tOS.DisposeRgn(srcRgn);", "+\t}", "+}"]}], "num": 6271}