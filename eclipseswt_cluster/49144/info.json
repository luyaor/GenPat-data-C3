{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "42ec58ea3d5223d7208629ad64273ee9", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d861ed1ff93489d3fd27b77a44df427c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/widgets/Decorations.java", "commitBeforeChange": "4837f43ad626833e44d944849690be12f17d2c70", "commitAfterChange": "d33484b9dbd12f2a7ff228ba91793eb6670c1b90", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 35, "signatureBeforeChange": "\r void destroyAccelerators ()", "signatureAfterChange": "\r boolean translateAccelerator (int key, int keysym, XKeyEvent xEvent)", "diff": ["-}\r", "-void destroyAccelerators () {\r", "-\tif (!accelerators) return;\r", "-\tif (menuBar == null) return;\r", "-\tmenuBar.removeAccelerators ();\r", "-\taccelerators = false;\r", "+boolean translateAccelerator (int key, int keysym, XKeyEvent xEvent) {\r", "+\t/*\r", "+\t* Bug in Solaris.  When accelerators are set more\r", "+\t* than once in the same menu bar, the time it takes\r", "+\t* to set the accelerator increases exponentially.\r", "+\t* The fix is to implement our own accelerator table\r", "+\t* on Solaris.\r", "+\t*/\r", "+\tif (OS.IsSunOS) {\r", "+\t\tif (menuBar != null && menuBar.getEnabled ()) {\r", "+\t\t\t/* Ignore modifiers. */\r", "+\t\t\tswitch (keysym) {\r", "+\t\t\t\tcase OS.XK_Control_L:\r", "+\t\t\t\tcase OS.XK_Control_R:\r", "+\t\t\t\tcase OS.XK_Alt_L:\r", "+\t\t\t\tcase OS.XK_Alt_R:\r", "+\t\t\t\tcase OS.XK_Shift_L:\r", "+\t\t\t\tcase OS.XK_Shift_R:\r", "+\t\t\t\t\treturn false;\t\t\t\t\t\r", "+\t\t\t}\r", "+\t\t\t\r", "+\t\t\t/*\r", "+\t\t\t* Bug in MOTIF.  On Solaris only, XK_F11 and XK_F12 are not\r", "+\t\t\t* translated correctly by XLookupString().  They are mapped\r", "+\t\t\t* to 0x1005FF10 and 0x1005FF11 respectively.  The fix is to\r", "+\t\t\t* look for these values explicitly and correct them.\r", "+\t\t\t*/\r", "+\t\t\tif (keysym != 0) {\r", "+\t\t\t\tswitch (keysym) {\r", "+\t\t\t\t\tcase 0x1005FF10: \r", "+\t\t\t\t\t\tkeysym = OS.XK_F11;\r", "+\t\t\t\t\t\tkey = 0;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase 0x1005FF11:\r", "+\t\t\t\t\t\tkeysym = OS.XK_F12;\r", "+\t\t\t\t\t\tkey = 0;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t\t/*\r", "+\t\t\t\t* Bug in MOTIF.  On Solaris only, there is garbage in the\r", "+\t\t\t\t* high 16-bits for Keysyms such as XK_Down.  Since Keysyms\r", "+\t\t\t\t* must be 16-bits to fit into a Character, mask away the\r", "+\t\t\t\t* high 16-bits on all platforms.\r", "+\t\t\t\t*/\r", "+\t\t\t\tkeysym &= 0xFFFF;\r", "+\t\t\t}\r", "+\t\t\t\r", "+\t\t\t/*\r", "+\t\t\t* Bug in Motif.  There are some keycodes for which \r", "+\t\t\t* XLookupString() does not translate the character.\r", "+\t\t\t* Some of examples are Shift+Tab and Ctrl+Space.\r", "+\t\t\t*/\r", "+\t\t\tswitch (keysym) {\r", "+\t\t\t\tcase OS.XK_ISO_Left_Tab: key = '\\t'; break;\r", "+\t\t\t\tcase OS.XK_space: key = ' '; break;\r", "+\t\t\t}\r", "+\t\t\t\t\r", "+\t\t\tint accelerator = Display.translateKey (keysym);\r", "+\t\t\tif (accelerator == 0) accelerator = key;\r", "+\t\t\tif ((xEvent.state & OS.Mod1Mask) != 0) accelerator |= SWT.ALT;\r", "+\t\t\tif ((xEvent.state & OS.ShiftMask) != 0) accelerator |= SWT.SHIFT;\r", "+\t\t\tif ((xEvent.state & OS.ControlMask) != 0) accelerator |= SWT.CONTROL;\r", "+\t\t\treturn menuBar.translateAccelerator (accelerator);\r", "+\t\t}\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c376bcbfab74250cbdfba788f0110a9e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT WebKit/gtk/org/eclipse/swt/browser/WebKit.java", "commitBeforeChange": "8614680ae78fee56d42eb3d94f28a75f18d340b5", "commitAfterChange": "9f7ccea14bb1fb11d1071f5e85bfb64c67f560bd", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  static int JSDOMEventProc (int window, int event, int user_data)", "signatureAfterChange": "  static int JSDOMEventProc (int arg0, int event, int user_data)", "diff": ["-static int /*long*/ JSDOMEventProc (int /*long*/ window, int /*long*/ event, int /*long*/ user_data) {", "-\tLONG webViewHandle = (LONG)WindowMappings.get (new LONG (window));", "+static int /*long*/ JSDOMEventProc (int /*long*/ arg0, int /*long*/ event, int /*long*/ user_data) {", "+\tif (OS.GTK_IS_SCROLLED_WINDOW (arg0)) {", "+\t\t/*", "+\t\t * Stop the propagation of events that are not consumed by WebKit, before", "+\t\t * they reach the parent embedder.  These events have already been received.", "+\t\t */", "+\t\treturn user_data;", "+\t}", "+", "+\tif (OS.G_TYPE_CHECK_INSTANCE_TYPE (arg0, WebViewType)) {", "+\t\t/*", "+\t\t* Only consider using GDK events to create SWT events to send if JS is disabled", "+\t\t* in one or more WebKit instances (indicates that this instance may not be", "+\t\t* receiving events from the DOM).  This check is done up-front for performance.", "+\t\t*/", "+\t\tif (DisabledJSCount > 0) {", "+\t\t\tfinal Browser browser = FindBrowser (arg0);", "+\t\t\tif (browser != null && !((WebKit)browser.webBrowser).jsEnabled) {", "+\t\t\t\t/* this instance does need to use the GDK event to create an SWT event to send */", "+\t\t\t\tOS.gtk_widget_event (browser.handle, event);", "+\t\t\t\tswitch (OS.GDK_EVENT_TYPE (event)) {", "+\t\t\t\t\tcase OS.GDK_KEY_PRESS: ", "+\t\t\t\t\t\tif (browser.isFocusControl ()) {", "+\t\t\t\t\t\t\tfinal GdkEventKey gdkEvent = new GdkEventKey ();", "+\t\t\t\t\t\t\tOS.memmove (gdkEvent, event, GdkEventKey.sizeof);", "+\t\t\t\t\t\t\tif ((gdkEvent.keyval == OS.GDK_ISO_Left_Tab || gdkEvent.keyval == OS.GDK_Tab) && (gdkEvent.state & (OS.GDK_CONTROL_MASK | OS.GDK_MOD1_MASK)) == 0) {", "+\t\t\t\t\t\t\t\tbrowser.getDisplay ().asyncExec (new Runnable () {", "+\t\t\t\t\t\t\t\t\tpublic void run () {", "+\t\t\t\t\t\t\t\t\t\tif (browser.isDisposed ()) return;", "+\t\t\t\t\t\t\t\t\t\tif (browser.getDisplay ().getFocusControl () == null) {", "+\t\t\t\t\t\t\t\t\t\t\tint traversal = (gdkEvent.state & OS.GDK_SHIFT_MASK) != 0 ? SWT.TRAVERSE_TAB_PREVIOUS : SWT.TRAVERSE_TAB_NEXT;", "+\t\t\t\t\t\t\t\t\t\t\tbrowser.traverse (traversal);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t});", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\treturn 0;", "+\t}", "+", "+\tLONG webViewHandle = (LONG)WindowMappings.get (new LONG (arg0));", "-\treturn webkit.handleEvent (event, (int)user_data) ? 0 : 1;", "+\treturn webkit.handleDOMEvent (event, (int)user_data) ? 0 : STOP_PROPOGATE;"]}], "num": 49144}