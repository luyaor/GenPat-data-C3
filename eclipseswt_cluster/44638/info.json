{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "691077c91c55ca547cddc80fc617b684", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "99647a7edc9a02205eb2736f04ea33aa", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "ed6471c0ec0d0ee0c1436d2bdeadc8ba513ab4fd", "commitAfterChange": "034d8fba7f4ca7576ddaeee539a2fb56ee664327", "methodNumberBeforeChange": 86, "methodNumberAfterChange": 73, "signatureBeforeChange": " void paint(Event event)", "signatureAfterChange": " void onPaint (Event event)", "diff": ["+}", "+void onPaint (Event event) {", "+\tGC gc = event.gc;", "+\tRectangle clipping = gc.getClipping ();", "+\tint numColumns = columns.length;", "+\tint startColumn = -1, endColumn = -1;", "+\tif (numColumns > 0) {", "+\t\tstartColumn = computeColumnIntersect (clipping.x, 0);", "+\t\tif (startColumn != -1) {\t/* the clip x is within a column's bounds */", "+\t\t\tendColumn = computeColumnIntersect (clipping.x + clipping.width, startColumn);", "+\t\t\tif (endColumn == -1) endColumn = numColumns - 1;", "+\t\t}", "+\t} else {", "+\t\tstartColumn = endColumn = 0;", "+\t}", "+\t/* repaint grid lines */", "+\tif (linesVisible) {", "+\t\tColor oldForeground = gc.getForeground ();", "+\t\tgc.setForeground (display.getSystemColor (SWT.COLOR_WIDGET_LIGHT_SHADOW));", "+\t\tif (numColumns > 0 && startColumn != -1) {", "+\t\t\t/* vertical column lines */", "+\t\t\tfor (int i = startColumn; i <= endColumn; i++) {", "+\t\t\t\tint x = columns [i].getX () + columns [i].width - 1;", "+\t\t\t\tgc.drawLine (x, clipping.y, x, clipping.y + clipping.height);", "+\t\t\t}", "+\t\t}", "+\t\t/* horizontal item lines */", "+\t\tint bottomY = clipping.y + clipping.height;", "+\t\tint rightX = clipping.x + clipping.width;", "+\t\tint headerHeight = getHeaderHeight ();", "+\t\tint y = (clipping.y - headerHeight) / itemHeight * itemHeight + headerHeight;", "+\t\tif (y == headerHeight) y += itemHeight;\t\t/* do not paint line at very top */", "+\t\twhile (y <= bottomY) {", "+\t\t\tgc.drawLine (clipping.x, y, rightX, y);", "+\t\t\ty += itemHeight;", "+\t\t}", "+\t\tgc.setForeground (oldForeground);", "+\t/* Determine the TableItems to be painted */", "+\tint startIndex = (clipping.y - getHeaderHeight ()) / itemHeight + topIndex;", "+\tif (items.length < startIndex) return;\t\t/* no items to paint */", "+\tint endIndex = startIndex + Compatibility.ceil (clipping.height, itemHeight);", "+\tif (endIndex < 0) return;\t\t/* no items to paint */", "+\tstartIndex = Math.max (0, startIndex);", "+\tendIndex = Math.min (endIndex, items.length - 1);", "+\tint current = 0;", "+\tfor (int i = startIndex; i <= endIndex; i++) {", "+\t\tTableItem item = items [i];", "+\t\tif (startColumn == -1) {", "+\t\t\t/* indicates that region to paint is to the right of the last column */", "+\t\t\titem.paint (gc, null, false);", "+\t\t} else {", "+\t\t\tif (numColumns == 0) {", "+\t\t\t\titem.paint (gc, null, true);", "+\t\t\t} else {", "+\t\t\t\tfor (int j = startColumn; j <= endColumn; j++) {", "+\t\t\t\t\titem.paint (gc, columns [j], true);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (isFocusControl ()) {", "+\t\t\tif (focusItem == item) {", "+\t\t\t\tRectangle focusBounds = item.getFocusBounds ();", "+\t\t\t\tgc.setClipping (focusBounds);", "+\t\t\t\tint[] oldLineDash = gc.getLineDash ();", "+\t\t\t\tif (item.isSelected ()) {", "+\t\t\t\t\tgc.setLineDash (new int[] {2, 2});", "+\t\t\t\t} else {", "+\t\t\t\t\tgc.setLineDash (new int[] {1, 1});", "+\t\t\t\t}", "+\t\t\t\tgc.drawFocus (focusBounds.x, focusBounds.y, focusBounds.width, focusBounds.height);", "+\t\t\t\tgc.setLineDash (oldLineDash);", "+\t\t\t}", "- */", "-void paint(Event event) {", "-\tint visibleRange[];", "-\tint headerHeight = getHeaderHeight();", "-\tVector paintColumns = getPaintColumns(event.getBounds());", "-\tTableItem focusItem = null;", "-\tif (paintColumns.size() > 0) {", "-\t\tevent.y -= headerHeight;", "-\t\tvisibleRange = getIndexRange(event.getBounds());", "-\t\tevent.y += headerHeight;", "-\t\t// When the top index is > 0 and the receiver is resized ", "-\t\t// higher so that the top index becomes 0 the invalidated ", "-\t\t// rectangle doesn't start below the header widget but at ", "-\t\t// y position 0. Subtraction of the header height (it is ", "-\t\t// not above the receiver but on top) causes event.y and ", "-\t\t// subsequently visibleRange[0] to be negative.", "-\t\t// Hack to prevent visibleRange[0] from becoming negative.", "-\t\t// Need to find out why the invalidated area starts at 0", "-\t\t// in the first place.", "-\t\tif (visibleRange[0] < 0) {", "-\t\t\tvisibleRange[0] = 0;", "-\t\t// ", "-\t\tvisibleRange[1] = Math.min(visibleRange[1], getItemCount()-1-getTopIndex());", "-\t\tfocusItem = paintItems(event, visibleRange[0], visibleRange[1], paintColumns);", "-\t}", "-\tif (getLinesVisible() == true) {", "-\t\tdrawGridLines(event, paintColumns.elements());", "-\t}", "-\tif (focusItem != null) {", "-\t\t// draw focus on top of drawing grid lines so that focus rectangle ", "-\t\t// is not obscured by grid. Fixes 1G5X20B", "-\t\tdrawSelectionFocus(focusItem, event.gc);\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf2a60d15713199708f5562cfedf9f7f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "ed568a606dfba062e77bacc7c7f799741b60cbf4", "commitAfterChange": "3e04f21595fe557524d009b946647c76885ec76f", "methodNumberBeforeChange": 50, "methodNumberAfterChange": 25, "signatureBeforeChange": " void paint(Event event)", "signatureAfterChange": " void doPaint (Event event)", "diff": ["+}", "+void doPaint (Event event) {", "+\tGC gc = event.gc;", "+\tRectangle clipping = gc.getClipping ();", "+\tint numColumns = getColumnCount();", "+\tint startColumn = -1, endColumn = -1;", "+\tif (numColumns > 0) {", "+\t\tstartColumn = computeColumnIntersect(clipping.x, 0);", "+\t\tif (startColumn != -1) {\t/* the click fell within a column's bounds */", "+\t\t\tendColumn = computeColumnIntersect(clipping.x + clipping.width, startColumn);", "+\t\t\tif (endColumn == -1) endColumn = numColumns - 1;", "+\t\t}", "+\t} else {", "+\t\tstartColumn = endColumn = 0;", "+\t}", "+", "+\t/* repaint grid lines if necessary */", "+\tif (linesVisible) {", "+\t\tColor oldForeground = gc.getForeground();", "+\t\tif (numColumns > 0 && startColumn != -1) {", "+\t\t\tgc.setForeground(LineColor);", "+\t\t\t/* vertical column lines */", "+\t\t\tfor (int i = startColumn; i <= endColumn; i++) {", "+\t\t\t\tint x = columns[i].getX() + columns[i].width - 1;", "+\t\t\t\tgc.drawLine(x, clipping.y, x, clipping.y + clipping.height);", "+\t\t\t}", "+\t\t}", "+\t\t/* horizontal item lines */", "+\t\tint bottomY = clipping.y + clipping.height;", "+\t\tint rightX = clipping.x + clipping.width;", "+\t\tint headerHeight = getHeaderHeight();", "+\t\tint y = (clipping.y - headerHeight) / itemHeight * itemHeight + headerHeight;", "+\t\twhile (y <= bottomY) {", "+\t\t\tgc.drawLine(clipping.x, y, rightX, y);", "+\t\t\ty += itemHeight;", "+\t\t}", "+\t\tgc.setForeground(oldForeground);", "+\t}", "+\t", "+\t/* Determine the TreeItems to be painted */", "+\tint startIndex = (clipping.y - getHeaderHeight()) / itemHeight + topIndex;", "+\tif (!(0 <= startIndex && startIndex < availableItems.length)) return;\t/* no items to paint */", "+\tint endIndex = startIndex + Compatibility.ceil (clipping.height, itemHeight);", "+\tendIndex = Math.min (endIndex, availableItems.length - 1);", "+\tint current = 0;", "+\tfor (int i = startIndex; i <= endIndex; i++) {", "+\t\tTreeItem item = availableItems[i];", "+\t\tif (startColumn == -1) {", "+\t\t\t/* indicates that region to paint is to the right of the last column */", "+\t\t\titem.paint(gc, null, false);", "+\t\t} else {", "+\t\t\tif (numColumns == 0) {", "+\t\t\t\titem.paint(gc, null, true);", "+\t\t\t} else {", "+\t\t\t\tfor (int j = startColumn; j <= endColumn; j++) {", "+\t\t\t\t\titem.paint(gc, columns[j], true);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (isFocusControl()) {", "+\t\t\tif (focusItem == item) {", "+\t\t\t\tRectangle focusBounds = item.getFocusBounds();", "+\t\t\t\tgc.setClipping (focusBounds);", "+\t\t\t\tint oldStyle = gc.getLineStyle();", "+\t\t\t\tgc.setLineStyle(SWT.LINE_DOT);", "+\t\t\t\tgc.drawFocus(focusBounds.x, focusBounds.y, focusBounds.width, focusBounds.height);", "+\t\t\t\tgc.setLineStyle(oldStyle);", "+\t\t\t}", "+\t\t\tif (insertMarkItem == item) {", "+\t\t\t\tRectangle focusBounds = item.getFocusBounds();", "+\t\t\t\tgc.setClipping (focusBounds);", "+\t\t\t\tif (insertMarkPrecedes) {", "+\t\t\t\t\tgc.drawLine(focusBounds.x, focusBounds.y, focusBounds.x + focusBounds.width, focusBounds.y);", "+\t\t\t\t} else {", "+\t\t\t\t\tint y = focusBounds.y + focusBounds.height - 1;", "+\t\t\t\t\tgc.drawLine(focusBounds.x, y, focusBounds.x + focusBounds.width, y);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+}", "- */", "-void paint(Event event) {", "-\tint visibleRange[] = getIndexRange(event.getBounds());", "-\t", "-\tpaintItems(event.gc, visibleRange[0], visibleRange[1] + 1); // + 1 to paint the vertical line ", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// connection the last item we really ", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// want to paint with the item after that.", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fab13b04144e5c9f2fc425b08a81065e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "ab0b2d3bbe9918e6c436a9c99106bcc28d4fcea4", "commitAfterChange": "1aa76e023bb4927eb3b7cf526018017f11838086", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  void drawBorder(GC gc, int x, int y, GdkColor selectionColor)", "signatureAfterChange": "  void drawBorder(GC gc, int x, int y, GdkColor selectionColor)", "diff": ["-\t\tboolean drawUnderline = false;", "-\t\tif (style.underline && style.underlineColor != null) drawUnderline = true;", "-\t\tif (style.underline && style.underlineStyle == SWT.UNDERLINE_ERROR && OS.GTK_VERSION < OS.VERSION(2, 4, 0)) drawUnderline = true;", "-\t\tboolean drawStrikeout = false;", "-\t\tif (style.strikeout && style.strikeoutColor != null) drawStrikeout = true;", "+\t\t", "-\t\tif (!drawUnderline && !drawBorder && !drawStrikeout) continue;", "-", "-\t\tint start = translateOffset(styles[i].start);", "-\t\tint end = translateOffset(styles[i+1].start - 1);", "-\t\tint byteStart = (int)/*64*/(OS.g_utf8_offset_to_pointer(ptr, start) - ptr);", "-\t\tint byteEnd = (int)/*64*/(OS.g_utf8_offset_to_pointer(ptr, end + 1) - ptr);", "-\t\tint[] ranges = new int[]{byteStart, byteEnd};", "-\t\tint /*long*/ rgn = OS.gdk_pango_layout_get_clip_region(layout, x, y, ranges, ranges.length / 2);", "-\t\tif (rgn != 0) {", "-\t\t\tint[] nRects = new int[1];", "-\t\t\tint /*long*/[] rects = new int /*long*/[1];", "-\t\t\tOS.gdk_region_get_rectangles(rgn, rects, nRects);", "-\t\t\tGdkRectangle rect = new GdkRectangle();", "-\t\t\tif (drawBorder) {", "+\t\tif (drawBorder && !style.isAdherentBorder(styles[i+1].style)) {", "+\t\t\tint start = styles[i].start;", "+\t\t\tfor (int j = i; j > 0 && style.isAdherentBorder(styles[j-1].style); j--) {", "+\t\t\t\tstart = styles[j - 1].start;", "+\t\t\t}", "+\t\t\tstart = translateOffset(start);", "+\t\t\tint end = translateOffset(styles[i+1].start - 1);", "+\t\t\tint byteStart = (int)/*64*/(OS.g_utf8_offset_to_pointer(ptr, start) - ptr);", "+\t\t\tint byteEnd = (int)/*64*/(OS.g_utf8_offset_to_pointer(ptr, end + 1) - ptr);", "+\t\t\tint[] ranges = new int[]{byteStart, byteEnd};", "+\t\t\tint /*long*/ rgn = OS.gdk_pango_layout_get_clip_region(layout, x, y, ranges, ranges.length / 2);", "+\t\t\tif (rgn != 0) {", "+\t\t\t\tint[] nRects = new int[1];", "+\t\t\t\tint /*long*/[] rects = new int /*long*/[1];", "+\t\t\t\tOS.gdk_region_get_rectangles(rgn, rects, nRects);", "+\t\t\t\tGdkRectangle rect = new GdkRectangle();", "+\t\t\t\tint width = 1;", "+\t\t\t\tfloat[] dashes = null;", "+\t\t\t\tswitch (style.borderStyle) {", "+\t\t\t\t\tcase SWT.BORDER_SOLID: break;", "+\t\t\t\t\tcase SWT.BORDER_DASH: dashes = width != 0 ? GC.LINE_DASH : GC.LINE_DASH_ZERO; break;", "+\t\t\t\t\tcase SWT.BORDER_DOT: dashes = width != 0 ? GC.LINE_DOT : GC.LINE_DOT_ZERO; break;", "+\t\t\t\t}", "-\t\t\t\t\tint width = 1;", "-\t\t\t\t\tfloat[] dashes = null;", "-\t\t\t\t\tswitch (style.borderStyle) {", "-\t\t\t\t\t\tcase SWT.BORDER_SOLID: break;", "-\t\t\t\t\t\tcase SWT.BORDER_DASH: dashes = width != 0 ? GC.LINE_DASH : GC.LINE_DASH_ZERO; break;", "-\t\t\t\t\t\tcase SWT.BORDER_DOT: dashes = width != 0 ? GC.LINE_DOT : GC.LINE_DOT_ZERO; break;", "-\t\t\t\t\t}", "-\t\t\t\t\tint width = 1;", "-\t\t\t\t\tfloat[] dashes = null;", "-\t\t\t\t\tswitch (style.borderStyle) {", "-\t\t\t\t\t\tcase SWT.BORDER_SOLID: break;", "-\t\t\t\t\t\tcase SWT.BORDER_DASH: dashes = width != 0 ? GC.LINE_DASH : GC.LINE_DASH_ZERO; break;", "-\t\t\t\t\t\tcase SWT.BORDER_DOT: dashes = width != 0 ? GC.LINE_DOT : GC.LINE_DOT_ZERO; break;", "-\t\t\t\t\t}", "+\t\t\t\tif (rects[0] != 0) OS.g_free(rects[0]);", "+\t\t\t\tOS.gdk_region_destroy(rgn);", "-\t\t\tif (drawUnderline) {", "+\t\t}", "+\t\t", "+\t\tboolean drawUnderline = false;", "+\t\tif (style.underline && style.underlineColor != null) drawUnderline = true;", "+\t\tif (style.underline && style.underlineStyle == SWT.UNDERLINE_ERROR && OS.GTK_VERSION < OS.VERSION(2, 4, 0)) drawUnderline = true;", "+\t\tif (drawUnderline && !style.isAdherentUnderline(styles[i+1].style)) {", "+\t\t\tint start = styles[i].start;", "+\t\t\tfor (int j = i; j > 0 && style.isAdherentUnderline(styles[j-1].style); j--) {", "+\t\t\t\tstart = styles[j - 1].start;", "+\t\t\t}", "+\t\t\tstart = translateOffset(start);", "+\t\t\tint end = translateOffset(styles[i+1].start - 1);", "+\t\t\tint byteStart = (int)/*64*/(OS.g_utf8_offset_to_pointer(ptr, start) - ptr);", "+\t\t\tint byteEnd = (int)/*64*/(OS.g_utf8_offset_to_pointer(ptr, end + 1) - ptr);", "+\t\t\tint[] ranges = new int[]{byteStart, byteEnd};", "+\t\t\tint /*long*/ rgn = OS.gdk_pango_layout_get_clip_region(layout, x, y, ranges, ranges.length / 2);", "+\t\t\tif (rgn != 0) {", "+\t\t\t\tint[] nRects = new int[1];", "+\t\t\t\tint /*long*/[] rects = new int /*long*/[1];", "+\t\t\t\tOS.gdk_region_get_rectangles(rgn, rects, nRects);", "+\t\t\t\tGdkRectangle rect = new GdkRectangle();", "+\t\t\t\t\tif (gcValues == null) {", "+\t\t\t\t\t\tgcValues = new GdkGCValues();", "+\t\t\t\t\t\tOS.gdk_gc_get_values(gdkGC, gcValues);", "+\t\t\t\t\t}", "+\t\t\t\tif (rects[0] != 0) OS.g_free(rects[0]);", "+\t\t\t\tOS.gdk_region_destroy(rgn);", "-\t\t\tif (drawStrikeout) {", "+\t\t}", "+\t\t", "+\t\tboolean drawStrikeout = false;", "+\t\tif (style.strikeout && style.strikeoutColor != null) drawStrikeout = true;", "+\t\tif (drawStrikeout && !style.isAdherentStrikeout(styles[i+1].style)) {", "+\t\t\tint start = styles[i].start;", "+\t\t\tfor (int j = i; j > 0 && style.isAdherentStrikeout(styles[j-1].style); j--) {", "+\t\t\t\tstart = styles[j - 1].start;", "+\t\t\t}", "+\t\t\tstart = translateOffset(start);", "+\t\t\tint end = translateOffset(styles[i+1].start - 1);", "+\t\t\tint byteStart = (int)/*64*/(OS.g_utf8_offset_to_pointer(ptr, start) - ptr);", "+\t\t\tint byteEnd = (int)/*64*/(OS.g_utf8_offset_to_pointer(ptr, end + 1) - ptr);", "+\t\t\tint[] ranges = new int[]{byteStart, byteEnd};", "+\t\t\tint /*long*/ rgn = OS.gdk_pango_layout_get_clip_region(layout, x, y, ranges, ranges.length / 2);", "+\t\t\tif (rgn != 0) {", "+\t\t\t\tint[] nRects = new int[1];", "+\t\t\t\tint /*long*/[] rects = new int /*long*/[1];", "+\t\t\t\tOS.gdk_region_get_rectangles(rgn, rects, nRects);", "+\t\t\t\tGdkRectangle rect = new GdkRectangle();", "+\t\t\t\t\tif (gcValues == null) {", "+\t\t\t\t\t\tgcValues = new GdkGCValues();", "+\t\t\t\t\t\tOS.gdk_gc_get_values(gdkGC, gcValues);", "+\t\t\t\t\t}", "+\t\t\t\tif (rects[0] != 0) OS.g_free(rects[0]);", "+\t\t\t\tOS.gdk_region_destroy(rgn);", "-\t\t\tif (rects[0] != 0) OS.g_free(rects[0]);", "-\t\t\tOS.gdk_region_destroy(rgn);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f20336d3832bf51c2ccc725c40794c4f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/wpf/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "3528d69528935ee011372f88f680cf1c0de0fa7c", "commitAfterChange": "41106e1ba0e2dbb7b2de869492aef659f8aab194", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " public void draw (GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground, int flags)", "signatureAfterChange": " public void draw (GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground, int flags)", "diff": ["+\tfor (int i = 0; i < styles.length - 1; i++) {", "+\t\tStyleItem run = styles[i];", "+\t\tTextStyle style = run.style;", "+\t\tif (style == null) continue;", "+\t\tif (style.borderStyle != SWT.NONE && (i + 1 >= styles.length || !style.isAdherentBorder(styles[i + 1].style))) {", "+\t\t\tint start = run.start;", "+\t\t\tint end = styles[i + 1].start - 1;", "+\t\t\tfor (int j = i; j > 0 && style.isAdherentBorder(styles[j - 1].style); j--) {", "+\t\t\t\tstart = styles[j - 1].start;", "+\t\t\t}", "+\t\t\tColor color = style.borderColor;", "+\t\t\tif (color == null) color = style.foreground;", "+\t\t\tif (color == null) color = gc.getForeground();", "+\t\t\tint brush = OS.gcnew_SolidColorBrush(color.handle);", "+\t\t\tint pen = OS.gcnew_Pen(brush, 1);", "+\t\t\tOS.GCHandle_Free(brush);", "+\t\t\tint dashStyle = 0;", "+\t\t\tswitch (style.borderStyle) {", "+\t\t\t\tcase SWT.BORDER_SOLID:", "+\t\t\t\t\tdashStyle = OS.DashStyles_Solid(); break;", "+\t\t\t\tcase SWT.BORDER_DOT:", "+\t\t\t\t\tdashStyle = OS.DashStyles_Dot(); break;", "+\t\t\t\tcase SWT.BORDER_DASH:", "+\t\t\t\t\tdashStyle = OS.DashStyles_Dash(); break;", "+\t\t\t}", "+\t\t\tOS.Pen_DashStyle(pen, dashStyle);", "+\t\t\tif (dashStyle != 0) OS.GCHandle_Free(dashStyle);", "+\t\t\tint lineY = y;", "+\t\t\tlineStart = lineEnd = 0;", "+\t\t\tfor (int j = 0; j < lines.length; j++) {", "+\t\t\t\tint lineLength = OS.TextLine_Length(lines[j]);", "+\t\t\t\tlineStart = lineEnd;", "+\t\t\t\tlineEnd = lineStart + lineLength;", "+\t\t\t\tif (start < lineEnd) {", "+\t\t\t\t\tif (end < lineStart) break;", "+\t\t\t\t\tint rangeStart = Math.max(start, lineStart);", "+\t\t\t\t\tint rangLength = Math.min(end, lineEnd) - rangeStart + 1;", "+\t\t\t\t\tint rects = OS.TextLine_GetTextBounds(lines[j], rangeStart, rangLength);\t", "+\t\t\t\t\tif (rects != 0) {", "+\t\t\t\t\t\tint enumerator = OS.TextBoundsCollection_GetEnumerator(rects);", "+\t\t\t\t\t\twhile (OS.IEnumerator_MoveNext(enumerator)) {", "+\t\t\t\t\t\t\tint bounds = OS.TextBoundsCollection_Current(enumerator);", "+\t\t\t\t\t\t\tint textRect = OS.TextBounds_Rectangle(bounds);", "+\t\t\t\t\t\t\tOS.Rect_Y(textRect, OS.Rect_Y(textRect) + lineY);", "+\t\t\t\t\t\t\tOS.Rect_X(textRect, OS.Rect_X(textRect) + x);", "+\t\t\t\t\t\t\tOS.Rect_Width(textRect, OS.Rect_Width(textRect) - 1);", "+\t\t\t\t\t\t\tOS.Rect_Height(textRect, OS.Rect_Height(textRect) - 1);", "+\t\t\t\t\t\t\tOS.DrawingContext_DrawRectangle(drawingContext, 0, pen, textRect);", "+\t\t\t\t\t\t\tOS.GCHandle_Free(textRect);", "+\t\t\t\t\t\t\tOS.GCHandle_Free(bounds);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tOS.GCHandle_Free(enumerator);", "+\t\t\t\t\t}", "+\t\t\t\t\tOS.GCHandle_Free(rects);", "+\t\t\t\t}", "+\t\t\t\tint lineHeight = (int)OS.TextLine_Height(lines[j]);", "+\t\t\t\tif (ascent != -1 && descent != -1) lineHeight = Math.max(lineHeight, ascent + descent);", "+\t\t\t\tlineY += lineHeight + lineSpacing;", "+\t\t\t}", "+\t\t\tOS.GCHandle_Free(pen);", "+\t\t} ", "+\t}", "+\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd83261dce93c77622d05bf20b8f57cf", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "b99e0e369a51571b12234356a1c0332a2bed35be", "commitAfterChange": "c4ff87b5b532e9f98adbfa0d94c5d8508add0dd4", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " public void draw(GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground, int flags)", "signatureAfterChange": " public void draw(GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground, int flags)", "diff": ["-\tif (rgn != 0) OS.DisposeRgn(rgn);", "+\tcallback = null;", "+", "+\tfor (int j = 0; j < styles.length; j++) {", "+\t\tStyleItem run = styles[j];", "+\t\tTextStyle style = run.style;", "+\t\tif (style == null || !style.underline) continue;", "+\t\tif (style.underlineStyle == SWT.UNDERLINE_SINGLE || style.underlineStyle == SWT.UNDERLINE_DOUBLE) continue;", "+\t\tint start = translateOffset(run.start);", "+\t\tint end = j + 1 < styles.length ? translateOffset(styles[j + 1].start - 1) : length;", "+\t\tfor (int i=0, lineStart=0, lineY = 0; i<breaks.length; i++) {", "+\t\t\tint lineBreak = breaks[i];", "+\t\t\tint lineEnd = lineBreak - 1;", "+\t\t\tif (!(start > lineEnd || end < lineStart)) {", "+\t\t\t\tint highStart = Math.max(lineStart, start);", "+\t\t\t\tint highEnd = Math.min(lineEnd, end);", "+\t\t\t\tint highLen = highEnd - highStart + 1;", "+\t\t\t\tif (highLen > 0) {", "+\t\t\t\t\tif (rgn == 0) rgn = OS.NewRgn();", "+\t\t\t\t\tfloat underlineY = y + lineY;", "+\t\t\t\t\tfloat[] foreground = gc.data.foreground;", "+\t\t\t\t\tfloat lineWidth = 0;", "+\t\t\t\t\tOS.CGContextSaveGState(gc.handle);", "+\t\t\t\t\tswitch (style.underlineStyle) {", "+\t\t\t\t\t\tcase SWT.UNDERLINE_ERROR: {", "+\t\t\t\t\t\t\tlineWidth = 2;", "+\t\t\t\t\t\t\tunderlineY += 2 * lineAscent [i] + lineWidth;", "+\t\t\t\t\t\t\tif (style.underlineColor != null) {", "+\t\t\t\t\t\t\t\tforeground = style.underlineColor.handle;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (style.foreground != null) {", "+\t\t\t\t\t\t\t\t\tforeground = style.foreground.handle;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tOS.CGContextSetLineDash(gc.handle, 0, new float[]{1f,3}, 2);", "+\t\t\t\t\t\t\tOS.CGContextSetLineCap(gc.handle, OS.kCGLineCapRound);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcase SWT.UNDERLINE_IME_INPUT:", "+\t\t\t\t\t\tcase SWT.UNDERLINE_IME_TARGET_CONVERTED:", "+\t\t\t\t\t\tcase SWT.UNDERLINE_IME_CONVERTED:", "+\t\t\t\t\t\t\tlineWidth = 1.5f;", "+\t\t\t\t\t\t\tforeground = style.underlineStyle == SWT.UNDERLINE_IME_CONVERTED ? new float[]{0.5f, 0.5f, 0.5f, 1} : new float[]{0, 0, 0, 1};", "+\t\t\t\t\t\t\tFont font = style.font;", "+\t\t\t\t\t\t\tif (font == null) font = this.font != null ? this.font : device.systemFont;", "+\t\t\t\t\t\t\tATSFontMetrics metrics = new ATSFontMetrics();", "+\t\t\t\t\t\t\tOS.ATSFontGetHorizontalMetrics(font.handle, OS.kATSOptionFlagsDefault, metrics);", "+\t\t\t\t\t\t\tunderlineY += lineAscent [i] + lineHeight [i] + (metrics.descent * font.size);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tOS.CGContextSetStrokeColorSpace(gc.handle, device.colorspace);", "+\t\t\t\t\tOS.CGContextSetStrokeColor(gc.handle, foreground);", "+\t\t\t\t\tOS.CGContextSetLineWidth(gc.handle, lineWidth);", "+\t\t\t\t\tOS.ATSUGetTextHighlight(layout, OS.Long2Fix(x), OS.X2Fix(underlineY), highStart, highLen, rgn);", "+\t\t\t\t\tif (callback == null) {", "+\t\t\t\t\t\tcallback = new Callback(this, \"drawUnderline\", 4);", "+\t\t\t\t\t\tif (callback.getAddress() == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "+\t\t\t\t\t}", "+\t\t\t\t\tdrawStyle = run;", "+\t\t\t\t\tOS.CGContextTranslateCTM (gc.handle, 0.5f, 0.5f);", "+\t\t\t\t\tOS.QDRegionToRects(rgn, OS.kQDParseRegionFromTopLeft, callback.getAddress(), gc.handle);", "+\t\t\t\t\tOS.CGContextStrokePath(gc.handle);", "+\t\t\t\t\tOS.CGContextRestoreGState(gc.handle);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (lineEnd > end) break;", "+\t\t\tlineY += lineHeight[i];", "+\t\t\tlineStart = lineBreak;", "+\t\t}", "+\t}", "+\tif (callback != null) callback.dispose();", "+\tif (rgn != 0) OS.DisposeRgn(rgn);", "+}"]}], "num": 44638}