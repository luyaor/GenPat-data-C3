{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7dcad4d57949d5f9974028adfe0d25aa", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2a91e4c760ca74a0bb3fd6b7d25a018c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "0824c6be1a1f5c02e5a0811758feb938d6ec8c29", "commitAfterChange": "d976ddbe207f4b84af7155d1db6c5e1e64234e41", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public void copyArea(Image image, int x, int y)", "signatureAfterChange": " public void copyArea(Image image, int x, int y)", "diff": ["-//\tif (data.image != null) {", "-//\t\tcopyArea(image, x, y, data.image.handle);", "-//\t} else if (data.control != 0) {", "-//\t\tint imageHandle = image.handle;", "-//\t\tint width = OS.CGImageGetWidth(imageHandle);", "-//\t\tint height = OS.CGImageGetHeight(imageHandle);", "-//\t\tint window = OS.GetControlOwner(data.control);", "-//\t\tRect srcRect = new Rect ();", "-//\t\tCGPoint pt = new CGPoint ();", "-//\t\tint[] contentView = new int[1];", "-//\t\tOS.HIViewFindByID(OS.HIViewGetRoot(window), OS.kHIViewWindowContentID(), contentView);", "-//\t\tOS.HIViewConvertPoint (pt, data.control, contentView[0]);", "-//\t\tx += (int) pt.x;", "-//\t\ty += (int) pt.y;", "-//\t\tRect inset = data.insetRect;", "-//\t\tx -= inset.left;", "-//\t\ty -= inset.top;", "-//\t\tsrcRect.left = (short)x;", "-//\t\tsrcRect.top = (short)y;", "-//\t\tsrcRect.right = (short)(x + width);", "-//\t\tsrcRect.bottom = (short)(y + height);", "-//\t\tRect destRect = new Rect();", "-//\t\tdestRect.right = (short)width;", "-//\t\tdestRect.bottom = (short)height;", "-//\t\tint bpl = width * 4;", "-//\t\tint[] gWorld = new int[1];", "-//\t\tint port = OS.GetWindowPort(window);\t\t", "-//\t\tOS.NewGWorldFromPtr(gWorld, OS.k32ARGBPixelFormat, destRect, 0, 0, 0, image.data, bpl);", "-//\t\tOS.CopyBits(OS.GetPortBitMapForCopyBits(port), OS.GetPortBitMapForCopyBits(gWorld[0]), srcRect, destRect, (short)OS.srcCopy, 0);\t\t\t", "-//\t\tOS.DisposeGWorld(gWorld [0]);", "-//\t} else if (data.window != 0) {", "-//\t\tint imageHandle = image.handle;", "-//\t\tCGRect rect = new CGRect();", "-//\t\trect.x = x;", "-//\t\trect.y = y;", "-//\t\trect.width = OS.CGImageGetWidth(imageHandle);", "-//\t\trect.height = OS.CGImageGetHeight(imageHandle);", "-//\t\tint[] displays = new int[16];", "-//\t\tint[] count = new int[1];", "-//\t\tif (OS.CGGetDisplaysWithRect(rect, displays.length, displays, count) != 0) return;", "-//\t\tfor (int i = 0; i < count[0]; i++) {", "-//\t\t\tint display = displays[i];", "-//\t\t\tint address = OS.CGDisplayBaseAddress(display);", "-//\t\t\tif (address != 0) {", "-//\t\t\t\tint width = OS.CGDisplayPixelsWide(display);", "-//\t\t\t\tint height = OS.CGDisplayPixelsHigh(display);", "-//\t\t\t\tint bpr = OS.CGDisplayBytesPerRow(display);", "-//\t\t\t\tint bpp = OS.CGDisplayBitsPerPixel(display);", "-//\t\t\t\tint bps = OS.CGDisplayBitsPerSample(display);", "-//\t\t\t\tint bitmapInfo = OS.kCGImageAlphaNoneSkipFirst;", "-//\t\t\t\tswitch (bpp) {", "-//\t\t\t\t\tcase 16: bitmapInfo |= OS.kCGBitmapByteOrder16Host; break;", "-//\t\t\t\t\tcase 32: bitmapInfo |= OS.kCGBitmapByteOrder32Host; break;", "-//\t\t\t\t}", "-//\t\t\t\tint srcImage = 0;", "-//\t\t\t\tif (OS.__BIG_ENDIAN__() && OS.VERSION >= 0x1040) {", "-//\t\t\t\t\tint context = OS.CGBitmapContextCreate(address, width, height, bps, bpr, data.device.colorspace, bitmapInfo);", "-//\t\t\t\t\tsrcImage = OS.CGBitmapContextCreateImage(context);", "-//\t\t\t\t\tOS.CGContextRelease(context);", "-//\t\t\t\t} else {", "-//\t\t\t\t\tint provider = OS.CGDataProviderCreateWithData(0, address, bpr * height, 0);", "-//\t\t\t\t\tsrcImage = OS.CGImageCreate(width, height, bps, bpp, bpr, data.device.colorspace, bitmapInfo, provider, null, true, 0);", "-//\t\t\t\t\tOS.CGDataProviderRelease(provider);", "-//\t\t\t\t}", "-//\t\t\t\tcopyArea(image, x, y, srcImage);", "-//\t\t\t\tif (srcImage != 0) OS.CGImageRelease(srcImage);", "-//\t\t\t}", "-//\t\t}", "-//\t}\t", "-}", "+\tImage srcImage = data.image;", "+\tif (srcImage != null) {", "+\t\tint srcX = x, srcY = y, destX = 0, destY = 0;", "+\t\tNSSize srcSize = srcImage.handle.size();", "+\t\tint imgHeight = (int)srcSize.height;", "+\t\tint destWidth = (int)srcSize.width - x, destHeight = (int)srcSize.height - y;", "+\t\tint srcWidth = destWidth, srcHeight = destHeight;\t\t", "+\t\tNSGraphicsContext context = NSGraphicsContext.graphicsContextWithBitmapImageRep(image.imageRep);", "+\t\tNSGraphicsContext.static_saveGraphicsState();", "+\t\tNSGraphicsContext.setCurrentContext(context);", "+\t\tNSAffineTransform transform = NSAffineTransform.transform();", "+\t\tNSSize size = image.handle.size();", "+\t\ttransform.translateXBy(0, size.height-(destHeight + 2 * destY));", "+\t\ttransform.concat();", "+\t\tNSRect srcRect = new NSRect();", "+\t\tsrcRect.x = srcX;", "+\t\tsrcRect.y = imgHeight - (srcY + srcHeight);", "+\t\tsrcRect.width = srcWidth;", "+\t\tsrcRect.height = srcHeight;", "+\t\tNSRect destRect = new NSRect();", "+\t\tdestRect.x = destX;", "+\t\tdestRect.y = destY;", "+\t\tdestRect.width = destWidth;", "+\t\tdestRect.height = destHeight;", "+\t\tsrcImage.handle.drawInRect(destRect, srcRect, OS.NSCompositeCopy, 1);", "+ \t\tNSGraphicsContext.static_restoreGraphicsState();", "+\t\treturn;", "+\t}", "+\tif (data.view != null) {", "+\t\t//TODO implement copyArea(Image, int int) for views", "+\t\treturn;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6130483fb8aa75d613cab3528023f85c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "0824c6be1a1f5c02e5a0811758feb938d6ec8c29", "commitAfterChange": "d976ddbe207f4b84af7155d1db6c5e1e64234e41", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 9, "signatureBeforeChange": " public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY, boolean paint)", "signatureAfterChange": " public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY, boolean paint)", "diff": ["-//\tif (handle == 0) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);", "-//\tif (data.updateClip) setCGClipping();", "-//\tif (width <= 0 || height <= 0) return;", "-//\tint deltaX = destX - srcX, deltaY = destY - srcY;", "-//\tif (deltaX == 0 && deltaY == 0) return;", "-//\tif (data.image != null) {", "-// \t\tOS.CGContextSaveGState(handle);", "-// \t\tOS.CGContextScaleCTM(handle, 1, -1);", "-// \t\tOS.CGContextTranslateCTM(handle, 0, -(height + 2 * destY));", "-// \t\tCGRect rect = new CGRect();", "-// \t\trect.x = destX;", "-// \t\trect.y = destY;", "-// \t\trect.width = width;", "-//\t\trect.height = height;", "-//\t\tint h = OS.CGImageGetHeight(data.image.handle);", "-//\t\tint bpr = OS.CGImageGetBytesPerRow(data.image.handle);", "-//\t\tint provider = OS.CGDataProviderCreateWithData(0, data.image.data, bpr * h, 0);", "-//\t\tif (provider != 0) {", "-//\t\t\tint colorspace = device.colorspace;", "-//\t\t\tint img = OS.CGImageCreate(width, height, 8, 32, bpr, colorspace, OS.kCGImageAlphaNoneSkipFirst, provider, null, true, 0);", "-//\t\t\tOS.CGDataProviderRelease(provider);", "-//\t\t\tOS.CGContextDrawImage(handle, rect, img);", "-//\t\t\tOS.CGImageRelease(img);", "-//\t\t}", "-// \t\tOS.CGContextRestoreGState(handle);", "-// \t\treturn;", "-//\t}", "-//\tif (data.control != 0) {", "-//\t\tint port = data.port;", "-//\t\tint window = OS.GetControlOwner(data.control);", "-//\t\tif (port == 0) port = OS.GetWindowPort(window);", "-//", "-//\t\t/* Calculate src and dest rectangles/regions */", "-//\t\tRect rect = new Rect();", "-//\t\tOS.GetControlBounds(data.control, rect);", "-//\t\tint convertX = 0, convertY = 0;", "-//\t\tCGPoint pt = new CGPoint ();", "-//\t\tint[] contentView = new int[1];", "-//\t\tOS.HIViewFindByID(OS.HIViewGetRoot(window), OS.kHIViewWindowContentID(), contentView);", "-//\t\tOS.HIViewConvertPoint(pt, OS.HIViewGetSuperview(data.control), contentView[0]);", "-//\t\tconvertX = rect.left + (int) pt.x;", "-//\t\tconvertY = rect.top + (int) pt.y;", "-//\t\trect.left += (int) pt.x;", "-//\t\trect.top += (int) pt.y;", "-//\t\trect.right += (int) pt.x;", "-//\t\trect.bottom += (int) pt.y;", "-//\t\tRect srcRect = new Rect();", "-//\t\tint left = rect.left + srcX;", "-//\t\tint top = rect.top + srcY;", "-//\t\tOS.SetRect(srcRect, (short)left, (short)top, (short)(left + width), (short)(top + height));", "-//\t\tint srcRgn = OS.NewRgn();", "-//\t\tOS.RectRgn(srcRgn, srcRect);", "-//\t\tOS.SectRect(rect, srcRect, srcRect);", "-//\t\tRect destRect = new Rect ();", "-//\t\tOS.SetRect(destRect, srcRect.left, srcRect.top, srcRect.right, srcRect.bottom);", "-//\t\tOS.OffsetRect(destRect, (short)deltaX, (short)deltaY);", "-//\t\tint destRgn = OS.NewRgn();", "-//\t\tOS.RectRgn(destRgn, destRect);", "-//\t\t", "-//\t\t/* Copy bits with appropriated clipping region */", "-//\t\tif (!OS.EmptyRect(srcRect)) {", "-//\t\t\tif (data.visibleRgn == 0 || OS.RectInRgn(srcRect, data.visibleRgn)) {", "-//\t\t\t\tint clipRgn = data.visibleRgn;", "-//\t\t\t\tif (data.clipRgn != 0) {", "-//\t\t\t\t\tclipRgn = OS.NewRgn();", "-//\t\t\t\t\tOS.SectRgn(data.clipRgn, data.visibleRgn, clipRgn);", "-//\t\t\t\t}", "-//\t", "-//\t\t\t\t/*", "-//\t\t\t\t* Feature in the Macintosh.  ScrollRect() only copies bits", "-//\t\t\t\t* that are inside the specified rectangle.  This means that", "-//\t\t\t\t* it is not possible to copy non overlaping bits without", "-//\t\t\t\t* copying the bits in between the source and destination", "-//\t\t\t\t* rectangles.  The fix is to check if the source and", "-//\t\t\t\t* destination rectangles are disjoint and use CopyBits()", "-//\t\t\t\t* instead.", "-//\t\t\t\t*/", "-//\t\t\t\tif (!OS.EmptyRgn(clipRgn)) {", "-//\t\t\t\t\tboolean disjoint = (destX + width < srcX) || (srcX + width < destX) || (destY + height < srcY) || (srcY + height < destY);", "-//\t\t\t\t\tif (!disjoint && (deltaX == 0 || deltaY == 0)) {", "-//\t\t\t\t\t\tint[] currentPort = new int[1];", "-//\t\t\t\t\t\tOS.GetPort(currentPort);", "-//\t\t\t\t\t\tOS.SetPort(port);", "-//\t\t\t\t\t\tint oldClip = OS.NewRgn();", "-//\t\t\t\t\t\tOS.GetClip(oldClip);", "-//\t\t\t\t\t\tOS.SetClip(clipRgn);", "-//\t\t\t\t\t\tOS.UnionRect(srcRect, destRect, rect);", "-//\t\t\t\t\t\tOS.ScrollRect(rect, (short)deltaX, (short)deltaY, 0);", "-//\t\t\t\t\t\tOS.SetClip(oldClip);", "-//\t\t\t\t\t\tOS.DisposeRgn(oldClip);", "-//\t\t\t\t\t\tOS.SetPort(currentPort[0]);", "-//\t\t\t\t\t} else {", "-//\t\t\t\t\t\tint portBitMap = OS.GetPortBitMapForCopyBits (port);", "-//\t\t\t\t\t\tOS.CopyBits(portBitMap, portBitMap, srcRect, destRect, (short)OS.srcCopy, clipRgn);", "-//\t\t\t\t\t\tOS.QDFlushPortBuffer(port, destRgn);", "-//\t\t\t\t\t}", "-//\t\t\t\t}", "-//\t\t\t\t", "-//\t\t\t\tif (clipRgn != data.visibleRgn) OS.DisposeRgn(clipRgn);", "-//\t\t\t}", "-//\t\t}", "-//\t\t", "-//\t\t/* Invalidate src and obscured areas */", "-//\t\tif (paint) {", "-//\t\t\tint invalRgn = OS.NewRgn();", "-//\t\t\tOS.DiffRgn(srcRgn, data.visibleRgn, invalRgn);", "-//\t\t\tOS.OffsetRgn(invalRgn, (short)deltaX, (short)deltaY);", "-//\t\t\tOS.DiffRgn(srcRgn, destRgn, srcRgn);", "-//\t\t\tOS.UnionRgn(srcRgn, invalRgn, invalRgn);", "-//\t\t\tOS.SectRgn(data.visibleRgn, invalRgn, invalRgn);", "-//\t\t\tOS.OffsetRgn(invalRgn, (short)-convertX, (short)-convertY);", "-//\t\t\tOS.HIViewSetNeedsDisplayInRegion(data.control, invalRgn, true);", "-//\t\t\tOS.DisposeRgn(invalRgn);", "-//\t\t}", "-//\t\t", "-//\t\t/* Dispose src and dest regions */", "-//\t\tOS.DisposeRgn(destRgn);", "-//\t\tOS.DisposeRgn(srcRgn);", "-//\t}", "+\tif (handle == null) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);", "+\tif (width <= 0 || height <= 0) return;", "+\tint deltaX = destX - srcX, deltaY = destY - srcY;", "+\tif (deltaX == 0 && deltaY == 0) return;", "+\tNSAutoreleasePool pool = checkGC(TRANSFORM | CLIPPING);", "+\ttry {", "+\t\tImage image = data.image;", "+\t\tif (image != null) {", "+\t\t\tNSImage imageHandle = image.handle;", "+\t\t\tNSSize size = imageHandle.size();", "+\t\t \tint imgHeight = (int)size.height;", "+\t\t\thandle.saveGraphicsState();", "+\t\t\tNSAffineTransform transform = NSAffineTransform.transform();", "+\t\t\ttransform.scaleXBy(1, -1);", "+\t\t\ttransform.translateXBy(0, -(height + 2 * destY));", "+\t\t\ttransform.concat();", "+\t\t\tNSRect srcRect = new NSRect();", "+\t\t\tsrcRect.x = srcX;", "+\t\t\tsrcRect.y = imgHeight - (srcY + height);", "+\t\t\tsrcRect.width = width;", "+\t\t\tsrcRect.height = height;", "+\t\t\tNSRect destRect = new NSRect();", "+\t\t\tdestRect.x = destX;", "+\t\t\tdestRect.y = destY;", "+\t\t\tdestRect.width = width;", "+\t\t\tdestRect.height = height;", "+\t\t\timageHandle.drawInRect(destRect, srcRect, OS.NSCompositeCopy, 1);", "+\t\t\thandle.restoreGraphicsState();", "+\t \t\treturn;", "+\t\t}", "+\t\tif (data.view != null) {", "+\t\t\t//TODO implement copyArea(IIIIIIZ) for views", "+\t\t\treturn;", "+\t\t}\t\t", "+\t} finally {", "+\t\tuncheckGC(pool);", "+\t}"]}], "num": 43554}