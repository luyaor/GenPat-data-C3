{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e055d5b9ec7d04e27f0a51130992fa58", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "457cc64ef371966047420636344abcfd", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/List.java", "commitBeforeChange": "4b56816ed07a329f964409d0e4a8083328f0170e", "commitAfterChange": "aa954a829806c60747c6d3d072adbc875dc61bcd", "methodNumberBeforeChange": 56, "methodNumberAfterChange": 56, "signatureBeforeChange": "  long windowProc (long hwnd, int msg, long wParam, long lParam)", "signatureAfterChange": "  long windowProc (long hwnd, int msg, long wParam, long lParam)", "diff": ["-\tif (!OS.IsUnicode || handle == 0 || lParam == 0 || (state & HAS_AUTO_DIRECTION) == 0) {", "-\t\treturn callWindowProc (hwnd, msg, wParam, lParam);", "+\t/* Below code is to support auto text direction. */", "+\tif (OS.IsUnicode && handle != 0 && lParam != 0 && (state & HAS_AUTO_DIRECTION) != 0) {", "+\t\tswitch (msg) {", "+\t\t\tcase OS.LB_ADDSTRING:", "+\t\t\tcase OS.LB_INSERTSTRING:", "+\t\t\tcase OS.LB_FINDSTRINGEXACT:", "+\t\t\t\tint length = OS.wcslen (lParam); // we are always Unicode here", "+\t\t\t\tint cp = getCodePage ();", "+\t\t\t\tTCHAR buffer = new TCHAR (cp, length);", "+\t\t\t\tOS.MoveMemory (buffer, lParam, buffer.length () * TCHAR.sizeof);", "+\t\t\t\tString string = buffer.toString (0, length);", "+\t\t\t\tint direction = resolveTextDirection (string);", "+\t\t\t\tif (direction == SWT.NONE) {", "+\t\t\t\t\t/*", "+\t\t\t\t\t * Force adding a UCC even when no strong characters are found.", "+\t\t\t\t\t * Otherwise, the List items would retain the old direction,", "+\t\t\t\t\t * which might be inappropriate for the new text.", "+\t\t\t\t\t */", "+\t\t\t\t\tdirection = (style & SWT.RIGHT_TO_LEFT) != 0 ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT;", "+\t\t\t\t}", "+\t\t\t\tstring = (direction == SWT.RIGHT_TO_LEFT ? RLE : LRE) + string;", "+\t\t\t\tbuffer = new TCHAR (cp, string, true);", "+\t\t\t\tlong /*int*/ hHeap = OS.GetProcessHeap ();", "+\t\t\t\tlength = buffer.length() * TCHAR.sizeof;", "+\t\t\t\tlong /*int*/ pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, length);", "+\t\t\t\tOS.MoveMemory (pszText, buffer, length); ", "+\t\t\t\tlong /*int*/ code = super.windowProc (hwnd, msg, wParam, pszText);", "+\t\t\t\tOS.HeapFree (hHeap, 0, pszText);", "+\t\t\t\taddedUCC = true;", "+\t\t\t\treturn code;", "+\t\t}", "-\tswitch (msg) {", "-\t\tcase OS.LB_ADDSTRING:", "-\t\tcase OS.LB_INSERTSTRING:", "-\t\tcase OS.LB_FINDSTRINGEXACT:", "-\t\t\tint length = OS.wcslen (lParam); // we are always Unicode here", "-\t\t\tint cp = getCodePage ();", "-\t\t\tTCHAR buffer = new TCHAR (cp, length);", "-\t\t\tOS.MoveMemory (buffer, lParam, buffer.length () * TCHAR.sizeof);", "-\t\t\tString string = buffer.toString (0, length);", "-\t\t\tint direction = resolveTextDirection (string);", "-\t\t\tif (direction == SWT.NONE) {", "-\t\t\t\t/*", "-\t\t\t\t * Force adding a UCC even when no strong characters are found.", "-\t\t\t\t * Otherwise, the List items would retain the old direction,", "-\t\t\t\t * which might be inappropriate for the new text.", "-\t\t\t\t */", "-\t\t\t\tdirection = (style & SWT.RIGHT_TO_LEFT) != 0 ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT;", "-\t\t\t}", "-\t\t\tstring = (direction == SWT.RIGHT_TO_LEFT ? RLE : LRE) + string;", "-\t\t\tbuffer = new TCHAR (cp, string, true);", "-\t\t\tlong /*int*/ hHeap = OS.GetProcessHeap ();", "-\t\t\tlength = buffer.length() * TCHAR.sizeof;", "-\t\t\tlong /*int*/ pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, length);", "-\t\t\tOS.MoveMemory (pszText, buffer, length); ", "-\t\t\tlong /*int*/ code = super.windowProc (hwnd, msg, wParam, pszText);", "-\t\t\tOS.HeapFree (hHeap, 0, pszText);", "-\t\t\taddedUCC = true;", "-\t\t\treturn code;", "-\t}", "-\treturn callWindowProc (hwnd, msg, wParam, lParam);", "+\treturn super.windowProc (hwnd, msg, wParam, lParam);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc29330648c0d8f25e9431e1a0e027bd", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Combo.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 31, "signatureBeforeChange": " public void remove (int start, int end)", "signatureAfterChange": "  public void remove (int start, int end)", "diff": ["- */", "+", "-\tint itemCount= _getItemCount();", "-\tif (!(0 <= start && start < itemCount)) {", "-\t\terror (SWT.ERROR_INVALID_RANGE);", "-\t}", "-\tint newEnd = Math.min (end, itemCount - 1);", "-\tif (menuHandle != 0) {", "-\t\tOS.DeleteMenuItems(menuHandle, (short)(start+1), newEnd-start+1);", "-\t\tOS.SetControl32BitMaximum(handle, OS.CountMenuItems(menuHandle));", "+\tint count = getItemCount ();", "+\tif (0 > start || start >= count) error (SWT.ERROR_INVALID_RANGE);", "+\tint newEnd = Math.min (end, count - 1);", "+\tif ((style & SWT.READ_ONLY) != 0) {", "+\t\tOS.DeleteMenuItems (menuHandle, (short)(start+1), newEnd-start+1);", "+\t\tOS.SetControl32BitMaximum (handle, OS.CountMenuItems (menuHandle));", "-\t\tfor (int i= end; i >= start; i--)", "-  \t\t\tOS.HIComboBoxRemoveItemAtIndex(handle, i);", "+\t\t// NEEDS WORK", "+\t\tfor (int i=newEnd; i>=start; i--) {", "+\t\t\tOS.HIComboBoxRemoveItemAtIndex(handle, i);", "+\t\t}"]}], "num": 17571}