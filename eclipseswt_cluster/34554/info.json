{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b6940634da7b2808ad062ee5c426096f", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e4e8311957f17634ff0dbfdea5c940c6", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "a3c8e8904451b6db108629003e63438cb42170e1", "commitAfterChange": "16869ddf67c23faeefbc3dfea87ba1d07b576aa4", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "  void drawImage(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)", "signatureAfterChange": "  void drawImage(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)", "diff": ["-\t\t\t\t* Bug in Cairo.  When drawing the image streched with an interpolation", "-\t\t\t\t* alghorithm, the edges of the image are faded.  This is not a bug, but", "+\t\t\t\t* Bug in Cairo.  When drawing the image stretched with an interpolation", "+\t\t\t\t* algorithm, the edges of the image are faded.  This is not a bug, but", "-\t\t\t\t* NOTE: For some reaons, it is necessary to use CAIRO_EXTEND_PAD with", "+\t\t\t\t* NOTE: For some reason, it is necessary to use CAIRO_EXTEND_PAD with", "+\t\t\t\t* ", "+\t\t\t\t* NOTE: Cairo.CAIRO_EXTEND_PAD works on Cairo 1.8.x and greater.", "-\t\t\t\tif (Cairo.cairo_version () >= Cairo.CAIRO_VERSION_ENCODE(1, 4, 0)) {", "+\t\t\t\tint version = Cairo.cairo_version ();", "+\t\t\t\tif (version >= Cairo.CAIRO_VERSION_ENCODE(1, 4, 0) && version < Cairo.CAIRO_VERSION_ENCODE(1, 8, 0)) {", "+\t\t\t\t} else if (version >= Cairo.CAIRO_VERSION_ENCODE(1, 8, 0)) {", "+\t\t\t\t\tCairo.cairo_pattern_set_extend(pattern, Cairo.CAIRO_EXTEND_PAD);", "-//\t\t\t\tCairo.cairo_pattern_set_extend(pattern, Cairo.CAIRO_EXTEND_REFLECT);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4044cd0d68792f494e45e4343c7b467f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Mozilla/common/org/eclipse/swt/browser/Mozilla.java", "commitBeforeChange": "83784a0bd43bf551a0a4fb21e5409eeadecd384d", "commitAfterChange": "9a54c1aa04b815cd59a20141bb2dcedb14acb097", "methodNumberBeforeChange": 139, "methodNumberAfterChange": 145, "signatureBeforeChange": "  int OnStateChange (int aWebProgress, int aRequest, int aStateFlags, int aStatus)", "signatureAfterChange": "  int OnStateChange (int aWebProgress, int aRequest, int aStateFlags, int aStatus)", "diff": ["-\t\t\tisRetrievingBadCert = false;", "+\t\tif (isRetrievingBadCert) {", "+\t\t\tisRetrievingBadCert = false;", "+\t\t\treturn XPCOM.NS_OK;", "+\t\t}", "+", "+\t\t/*", "+\t\t* If a site with a bad certificate is being encountered for the first time", "+\t\t* then store the request for future reference, set the isRetrievingBadCert", "+\t\t* flag and re-navigate to the site so that notification callbacks can be", "+\t\t* hooked on it to get its certificate info.", "+\t\t*/", "+\t\tswitch (aStatus) {", "+\t\t\tcase XPCOM.SSL_ERROR_BAD_CERT_DOMAIN:", "+\t\t\tcase XPCOM.SEC_ERROR_CA_CERT_INVALID:", "+\t\t\tcase XPCOM.SEC_ERROR_EXPIRED_CERTIFICATE:", "+\t\t\tcase XPCOM.SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:", "+\t\t\tcase XPCOM.SEC_ERROR_INADEQUATE_KEY_USAGE:", "+\t\t\tcase XPCOM.SEC_ERROR_UNKNOWN_ISSUER:", "+\t\t\tcase XPCOM.SEC_ERROR_UNTRUSTED_CERT:", "+\t\t\tcase XPCOM.SEC_ERROR_UNTRUSTED_ISSUER: {", "+\t\t\t\tnew nsISupports (aRequest).AddRef ();", "+\t\t\t\tif (badCertRequest != 0) {", "+\t\t\t\t\tnew nsISupports (badCertRequest).Release ();", "+\t\t\t\t}", "+\t\t\t\tbadCertRequest = aRequest;", "+\t\t\t\tisRetrievingBadCert = true;", "+\t\t\t\tnavigate (aRequest);", "+\t\t\t\treturn XPCOM.NS_OK;", "+\t\t\t}", "+\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "05f90d5a70e1bfeed2de23ffdcb04b3e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Shell.java", "commitBeforeChange": "0e6fd9fd38f9e1fcc9f2e95d4219009e605e7ee9", "commitAfterChange": "dd7a4ef251453dc2eb3a210e467eec1edf642a27", "methodNumberBeforeChange": 68, "methodNumberAfterChange": 67, "signatureBeforeChange": "  LRESULT WM_SETCURSOR (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_SETCURSOR (int wParam, int lParam)", "diff": ["-\tint msg = lParam >> 16;", "+\tint msg = (short) (lParam >> 16);", "+\t/*", "+\t* When the shell that contains a cursor is disabled,", "+\t* WM_SETCURSOR is called with HTERROR.  Normally,", "+\t* when a control is disabled, the parent will get", "+\t* mouse and cursor events.  In the case of a disabled", "+\t* shell, there is no enabled parent.  In order to", "+\t* show the cursor when a shell is disabled, it is", "+\t* necessary to override WM_SETCURSOR when called", "+\t* with HTERROR to set the cursor but only when the", "+\t* mouse is in the client area of the shell.", "+\t*/", "+\tint hitTest = (short) (lParam & 0xFFFF);", "+\tif (hitTest == OS.HTERROR) {", "+\t\tif (!getEnabled ()) {", "+\t\t\tControl control = display.getControl (wParam);", "+\t\t\tif (control == this && cursor != null) {", "+\t\t\t\tPOINT pt = new POINT ();", "+\t\t\t\tif (OS.GetCursorPos (pt)) {", "+\t\t\t\t\tOS.ScreenToClient (handle, pt);", "+\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\tOS.GetClientRect (handle, rect);", "+\t\t\t\t\tif (OS.PtInRect (rect, pt)) {", "+\t\t\t\t\t\tOS.SetCursor (cursor.handle);", "+\t\t\t\t\t\treturn LRESULT.ONE;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0714715481f9e21fd47ab9ed1d438722", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "c51fb393ab99325d9af1d3ac8aee99c3635a0d78", "commitAfterChange": "5bb98690a54122d614fad2d467c682c2744e7690", "methodNumberBeforeChange": 149, "methodNumberAfterChange": 149, "signatureBeforeChange": "  LRESULT WM_LBUTTONDOWN (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_LBUTTONDOWN (int wParam, int lParam)", "diff": ["+\t\t/*", "+\t\t* Bug in Windows.  When a tree has no images and an item is", "+\t\t* expanded or collapsed, for some reason, Windows changes", "+\t\t* the size of the selection.  When the user expands a tree", "+\t\t* item, the selection rectangle is made a few pixels larger.", "+\t\t* When the user collapses an item, the selection rectangle", "+\t\t* is restored to the original size but the selection is not", "+\t\t* redrawn, causing pixel corruption.  The fix is to detect", "+\t\t* this case and redraw the item.", "+\t\t*/", "+\t\tif ((lpht.flags & OS.TVHT_ONITEMBUTTON) != 0) {", "+\t\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);", "+\t\t\tif ((bits & OS.TVS_FULLROWSELECT) == 0) {", "+\t\t\t\tif (OS.SendMessage (handle, OS.TVM_GETIMAGELIST, OS.TVSIL_NORMAL, 0) == 0) {", "+\t\t\t\t\tint /*long*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);", "+\t\t\t\t\tif (hItem != 0) {", "+\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\tif (OS.TreeView_GetItemRect (handle, hItem, rect, false)) {", "+\t\t\t\t\t\t\tOS.InvalidateRect (handle, rect, true);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}], "num": 34554}