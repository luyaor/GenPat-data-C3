{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0ffc108f3860dd20b87483d806fb7aa0", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "457a38a538b862540bf8abb75b4f7b8c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "533fa0b4db36012e7cdb0d4f3a9e30b894a2e049", "commitAfterChange": "5e7a786028a166f56bc468dd7558e85824bf8fbb", "methodNumberBeforeChange": 89, "methodNumberAfterChange": 92, "signatureBeforeChange": " \t \tprivate int handleMouseCallback(int nextHandler, int eRefHandle, int whichWindow)", "signatureAfterChange": " \t\t \tprivate int handleMouseCallback(int nextHandler, int eRefHandle, int whichWindow)", "diff": ["-\tprivate int handleMouseCallback(int nextHandler, int eRefHandle, int whichWindow) {", "-\t\tint eventClass= OS.GetEventClass(eRefHandle);", "-\t\tint eventKind= OS.GetEventKind(eRefHandle);", "-\t\t", "-\t\tswitch (eventClass) {", "-\t\t\t", "-\t\tcase OS.kEventClassMouse:", "-\t\t\treturn handleMouseEvent(nextHandler, eRefHandle, eventKind, whichWindow);", "-\t\t", "-\t\tdefault:", "-\t\t\tSystem.out.println(\"handleMouseCallback: unexpected event class: \" + MacUtil.toString(eventClass));", "-\t\t\tbreak;", "-\t\t}", "-\t\treturn OS.eventNotHandledErr;", "-\t}", "+\tprivate int handleMouseCallback(int nextHandler, int eRefHandle, int whichWindow) {", "+\t\tint eventClass= OS.GetEventClass(eRefHandle);", "+\t\tif (eventClass != OS.kEventClassMouse) {", "+\t\t\tSystem.out.println(\"handleMouseCallback: unexpected event class: \" + MacUtil.toString(eventClass));", "+\t\t\treturn OS.eventNotHandledErr;", "+\t\t}", "+\t\t\t\t", "+\t\tint eventKind= OS.GetEventKind(eRefHandle);", "+", "+\t\tif (eventKind == OS.kEventMouseDown) {", "+\t\t}", "+\t\t// determine control under mouse", "+\t\tshort[] cpart= new short[1];\t\t", "+\t\tint whichControl= MacUtil.findControlUnderMouse(whichWindow, me, cpart);\t\t\t\t", "+\t\tWidget widget= WidgetTable.get(whichControl);", "+\t\t", "+\t\tMacMouseEvent mme= new MacMouseEvent(me);", "+\t\t", "+\t\tcase OS.kEventMouseDown:\t\t\t", "+\t\t\t", "+\t\t\tShell shell= null;", "+\t\t\tWidget w= findWidget(whichWindow);", "+\t\t\tif (w instanceof Shell)", "+\t\t\t\tshell= (Shell) w;", "+\t\t\t\t", "+\t\t\t// first click in window -> activation", "+\t\t\tif (!OS.IsWindowActive(whichWindow)) {", "+\t\t\t\tif (shell != null && (shell.getStyle() & SWT.ON_TOP) == 0) {", "+\t\t\t\t\t// let the default handler activate the window", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\t// whatever we do, we hide the tooltip", "+\t\t\thideToolTip();", "+", "+\t\t\t// focus handling", "+\t\t\tif (shell != null && (shell.getStyle() & SWT.ON_TOP) == 0)", "+\t\t\t\tsetMacFocusHandle(whichWindow, whichControl);", "+\t\t\t\t\t\t\t\t\t", "+\t\t\tif (whichControl != 0) {", "+\t\t\t", "+\t\t\t\t// deal with the context menu", "+\t\t\t\tif (widget instanceof Control) {", "+\t\t\t\t\tMenu cm= ((Control)widget).getMenu();\t// is a context menu installed?", "+\t\t\t\t\tif (cm != null && me.isShowContextualMenuClick()) {", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tfInContextMenu= true;", "+\t\t\t\t\t\t\t// AW: not ready for primetime", "+\t\t\t\t\t\t\t// OS.ContextualMenuSelect(cm.handle, globalPos.getData(), new short[1], new short[1]);", "+\t\t\t\t\t\t\torg.eclipse.swt.internal.carbon.Point pos= me.getWhere();", "+\t\t\t\t\t\t\tOS.PopUpMenuSelect(cm.handle, pos.v, pos.h, (short)1);", "+\t\t\t\t\t\t} finally {", "+\t\t\t\t\t\t\tfInContextMenu= false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn OS.noErr;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tif (cpart[0] == 111) { \t// a user pane", "+\t\t\t\t\tif (!(widget instanceof Text)) ", "+\t\t\t\t\t\tfTrackedControl= whichControl;\t// starts mouse tracking", "+\t\t\t\t\twindowProc(whichControl, SWT.MouseDown, mme);", "+\t\t\t\t\treturn OS.noErr;", "+\t\t\t\t} else {", "+\t\t\t\t\twindowProc(whichControl, SWT.MouseDown, mme);", "+\t\t\t\t}", "+\t\t\t\twindowProc(fTrackedControl, SWT.MouseMove, mme);", "+\t\t\t\twindowProc(fTrackedControl, SWT.MouseUp, mme);", "+\t\t\t\t\t", "+\t\t\t\t\twindowProc(fCurrentControl, SWT.MouseExit, mme);", "+\t\t\t\tif (widget instanceof Control) {", "+\t\t\t\t\tControl c= (Control) widget;", "+\t\t\t\twindowProc(fCurrentControl, SWT.MouseMove, mme);", "+\t\t\t\t\twindowProc(fCurrentControl, SWT.MouseEnter, mme);", "+\t\t\t\treturn OS.noErr;", "+\t\t\t\t", "+\t\t\t\t\twindowProc(fCurrentControl, SWT.MouseMove, mme);", "+\t\t\t}", "+\t\t\tbreak;", "+\t\t\t", "+\t\tcase OS.kEventMouseWheelMoved:", "+\t\t\tif (widget instanceof Composite) {", "+\t\t\t\tScrollBar sb= ((Composite) widget).getVerticalBar();", "+\t\t\t\tif (sb != null)", "+\t\t\t\t\treturn sb.processWheel(eRefHandle);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da4ff77204b27ff8aa0c6dda924402db", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/TreeItem.java", "commitBeforeChange": "2b635221beaca11b0f2782595f2f04eb08656eed", "commitAfterChange": "c964a36f72c09bd56edcd52d15c933282bfc4ef8", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 46, "signatureBeforeChange": " public void setExpanded (boolean expanded)", "signatureAfterChange": " public void setExpanded (boolean expanded)", "diff": ["+\t", "+\t/* Do nothing when the item is a leaf or already expanded */", "+\tint hwnd = parent.handle;", "+\tif (OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, handle) == 0) {", "+\t\treturn;", "+\t}", "+\tint state = 0;", "+\tif (OS.IsWinCE) {", "+\t\tTVITEM tvItem = new TVITEM ();", "+\t\ttvItem.hItem = handle;", "+\t\ttvItem.mask = OS.TVIF_STATE;", "+\t\tOS.SendMessage (hwnd, OS.TVM_GETITEM, 0, tvItem);", "+\t\tstate = tvItem.state;", "+\t} else {", "+\t\t/*", "+\t\t* Bug in Windows.  Despite the fact that TVM_GETITEMSTATE claims", "+\t\t* to return only the bits specified by the stateMask, when called", "+\t\t* with TVIS_EXPANDED, the entire state is returned.  The fix is", "+\t\t* to explicitly check for the TVIS_EXPANDED bit.", "+\t\t*/", "+\t\tstate = OS.SendMessage (hwnd, OS.TVM_GETITEMSTATE, handle, OS.TVIS_EXPANDED);", "+\t}", "+\tif (((state & OS.TVIS_EXPANDED) != 0) == expanded) return;", "+\t", "+\t/*", "+\t* Feature in Windows.  When TVM_EXPAND is used to expand", "+\t* an item, the widget scrolls to show the root item and", "+\t* the newly expanded items.  While not strictly incorrect,", "+\t* this means that application code that expands tree items", "+\t* in a background thread can scroll the widget while the", "+\t* user is interacting with it.  The fix is to remember", "+\t* the top item and the bounds of every tree item, turn", "+\t* redraw off, expand the item, scroll back to the top", "+\t* item.  If none of the rectangles have moved, then", "+\t* it is safe to turn redraw back on without redrawing", "+\t* the control.", "+\t*/", "+\tRECT [] rects = null;", "+\tboolean redraw = false, noScroll = true;", "+\tint count = 0, hTopItem = OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);", "+\tif (noScroll && hTopItem != 0) {", "+\t\tif (parent.drawCount == 0 && OS.IsWindowVisible (hwnd)) {", "+\t\t\tboolean noAnimate = true;", "+\t\t\tcount = OS.SendMessage (hwnd, OS.TVM_GETVISIBLECOUNT, 0, 0);", "+\t\t\trects = new RECT [count + 1];", "+\t\t\tint hItem = hTopItem, index = 0;", "+\t\t\twhile (hItem != 0 && (noAnimate || hItem != handle) && index < count) {", "+\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\trect.left = hItem;", "+\t\t\t\tif (OS.SendMessage (hwnd, OS.TVM_GETITEMRECT, 1, rect) != 0) {", "+\t\t\t\t\trects [index++] = rect;", "+\t\t\t\t}", "+\t\t\t\thItem = OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hItem);", "+\t\t\t}", "+\t\t\tif (noAnimate || hItem != handle) {", "+\t\t\t\tredraw = true;", "+\t\t\t\tcount = index;", "+\t\t\t\tint topHandle = parent.topHandle ();", "+\t\t\t\tOS.UpdateWindow (topHandle);", "+\t\t\t\tOS.DefWindowProc (topHandle, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t\tif (hwnd != topHandle) {", "+\t\t\t\t\tOS.UpdateWindow (hwnd);", "+\t\t\t\t\tOS.DefWindowProc (hwnd, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t\t}", "+\t\t\t\t/*", "+\t\t\t\t* This code is intentionally commented.", "+\t\t\t\t*/", "+//\t\t\t\tOS.SendMessage (hwnd, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t}", "+\t\t}", "+\t}", "+\t", "-\t* strictly wrong but is inconsistent.  The fix is to notice", "-\t* that the selection has changed and issue the event.", "+\t* strictly wrong but is inconsistent.  The fix is to", "+\t* check whether the selection has changed and issue", "+\t* the event.", "-\tint hwnd = parent.handle;", "+\t", "+\t/* Expand or collapse the item */", "+\t", "+\t/* Scroll back to the top item */", "+\tif (noScroll && hTopItem != 0) {", "+\t\tOS.SendMessage (hwnd, OS.TVM_SELECTITEM, OS.TVGN_FIRSTVISIBLE, hTopItem);", "+\t\tif (redraw) {", "+\t\t\tboolean fixRedraw = false;", "+\t\t\tif (hTopItem == OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0)) {", "+\t\t\t\tint hItem = hTopItem, index = 0;", "+\t\t\t\twhile (hItem != 0 && index < count) {", "+\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\trect.left = hItem;", "+\t\t\t\t\tif (OS.SendMessage (hwnd, OS.TVM_GETITEMRECT, 1, rect) != 0) {", "+\t\t\t\t\t\tif (!OS.EqualRect (rect, rects [index])) {", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\thItem = OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hItem);", "+\t\t\t\t\tindex++;", "+\t\t\t\t}", "+\t\t\t\tfixRedraw = index == count;", "+\t\t\t}", "+\t\t\tint topHandle = parent.topHandle ();", "+\t\t\tOS.DefWindowProc (topHandle, OS.WM_SETREDRAW, 1, 0);", "+\t\t\tif (hwnd != topHandle) {", "+\t\t\t\tOS.DefWindowProc (hwnd, OS.WM_SETREDRAW, 1, 0);", "+\t\t\t}", "+\t\t\t/*", "+\t\t\t* This code is intentionally commented.", "+\t\t\t*/", "+//\t\t\tOS.SendMessage (hwnd, OS.WM_SETREDRAW, 1, 0);", "+\t\t\tif (fixRedraw) {", "+\t\t\t\tparent.updateScrollBar ();", "+\t\t\t\tSCROLLINFO info = new SCROLLINFO ();", "+\t\t\t\tinfo.cbSize = SCROLLINFO.sizeof;", "+\t\t\t\tinfo.fMask = OS.SIF_ALL;", "+\t\t\t\tif (OS.GetScrollInfo (hwnd, OS.SB_VERT, info)) {", "+\t\t\t\t\tOS.SetScrollInfo (hwnd, OS.SB_VERT, info, true);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (OS.IsWinCE) {", "+\t\t\t\t\tOS.InvalidateRect (topHandle, null, true);", "+\t\t\t\t\tif (hwnd != topHandle) OS.InvalidateRect (hwnd, null, true);", "+\t\t\t\t} else {", "+\t\t\t\t\tint flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;", "+\t\t\t\t\tOS.RedrawWindow (topHandle, null, 0, flags);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+", "+\t/* Check for a selection event */"]}], "num": 659}