{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f34e04575821f969a3931c3eab758c28", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "19fdc3d5e2b68bb55f817bb3bdbaa880", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "7ce594b4bb9c7af0245cbdcabf2b4eb3444323e4", "commitAfterChange": "35e16e89ccce91ccd7ae7405a9aa8da00d9bc86a", "methodNumberBeforeChange": 78, "methodNumberAfterChange": 78, "signatureBeforeChange": " public Monitor [] getMonitors ()", "signatureAfterChange": " public Monitor [] getMonitors ()", "diff": ["-\tRectangle workArea = getWorkArea();", "+\tRectangle workArea = getWorkArea ();", "-\t\t\t\tif (i == 0 && workArea != null) {", "-\t\t\t\t\tmonitor.clientX = workArea.x;", "-\t\t\t\t\tmonitor.clientY = workArea.y;", "-\t\t\t\t\tmonitor.clientWidth = workArea.width;", "-\t\t\t\t\tmonitor.clientHeight = workArea.height;", "+", "+\t\t\t\tif (OS.GTK_VERSION >= OS.VERSION (3, 4, 0)) {", "+\t\t\t\t\t// workarea was defined in GTK 3.4. If present, it will return the best results", "+\t\t\t\t\t// since it takes into account per-monitor trim", "+\t\t\t\t\tOS.gdk_screen_get_monitor_workarea (screen, i, dest);", "+\t\t\t\t\tmonitor.clientX = dest.x;", "+\t\t\t\t\tmonitor.clientY = dest.y;", "+\t\t\t\t\tmonitor.clientWidth = dest.width;", "+\t\t\t\t\tmonitor.clientHeight = dest.height;", "-\t\t\t\t\tmonitor.clientX = monitor.x;", "-\t\t\t\t\tmonitor.clientY = monitor.y;", "-\t\t\t\t\tmonitor.clientWidth = monitor.width;", "-\t\t\t\t\tmonitor.clientHeight = monitor.height;", "+\t\t\t\t\t// If we're on an older version of gtk without the workarea function, see if we can use", "+\t\t\t\t\t// the getWorkArea function. In the case of multi-monitors, this will return something that", "+\t\t\t\t\t// is approximately a bounding rectangle for the work areas of all the monitors, so intersecting", "+\t\t\t\t\t// that rectangle with the monitor boundaries will provide an approximation of the per-monitor", "+\t\t\t\t\t// work area.", "+\t\t\t\t\tif (workArea != null) {", "+\t\t\t\t\t\tmonitor.clientX = Math.max (monitor.x, workArea.x);", "+\t\t\t\t\t\tmonitor.clientY = Math.max (monitor.y, workArea.y);", "+\t\t\t\t\t\tmonitor.clientHeight = Math", "+\t\t\t\t\t\t\t\t.max(Math.min (monitor.y + monitor.height, workArea.y + workArea.height)", "+\t\t\t\t\t\t\t\t\t\t- monitor.clientY, 0);", "+\t\t\t\t\t\tmonitor.clientWidth = Math.max (", "+\t\t\t\t\t\t\t\tMath.min (monitor.x + monitor.width, workArea.x + workArea.width) - monitor.clientX,", "+\t\t\t\t\t\t\t\t0);", "+\t\t\t\t\t}", "+", "+\t\t\t\t\t// If getWorkArea is not available or it did not return a rectangle that intersects the monitor", "+\t\t\t\t\t// bounds, then use the monitor bounds itself as the work area.", "+\t\t\t\t\tif (workArea == null || monitor.clientWidth == 0 || monitor.clientHeight == 0) {", "+\t\t\t\t\t\tmonitor.clientX = monitor.x;", "+\t\t\t\t\t\tmonitor.clientY = monitor.y;", "+\t\t\t\t\t\tmonitor.clientHeight = monitor.height;", "+\t\t\t\t\t\tmonitor.clientWidth = monitor.width;", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3b38b6dd87ec008c41ea61209718d282", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "a3633e1d325297b90c35176bcd7606d33c0133a3", "commitAfterChange": "fcf035261a778f9d1a193d18b728987b0a24b5f2", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "  void drawWithFrame_inView (int id, int sel, int cellFrame, int view)", "signatureAfterChange": "  void drawWithFrame_inView (int id, int sel, int cellFrame, int view)", "diff": ["+\t\tcontext.restoreGraphicsState ();", "+\t}", "+\t", "+\tif (insertItem != null && !insertItem.isDisposed()) {", "+\t\tcontext.saveGraphicsState ();", "+\t\tNSRect contentRect = cell.titleRectForBounds (rect);", "+\t\tGCData data = new GCData ();", "+\t\tdata.paintRect = contentRect;", "+\t\tGC gc = GC.cocoa_new (this, data);", "+\t\tgc.setClipping ((int)(contentRect.x - offsetX), (int)(contentRect.y - offsetY), (int)contentRect.width, (int)contentRect.height);", "+\t\tRectangle itemRect = insertItem.getImageBounds(0).union(insertItem.getBounds());", "+\t\tRectangle clientRect = getClientArea();", "+\t\tint x = clientRect.x + clientRect.width;", "+\t\tint posY = insertBefore ? itemRect.y : itemRect.y + itemRect.height - 1;", "+\t\tgc.drawLine(itemRect.x, posY, x, posY);", "+\t\tgc.dispose ();"]}], "num": 50444}