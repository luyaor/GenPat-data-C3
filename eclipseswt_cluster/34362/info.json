{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0365cd3c021b3c7d88b83119ae034f0f", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d351f325a09e42aa3337fa22f67aa476", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "a5d8bf4a11b89f56aac32b46dedff4139fb6f012", "commitAfterChange": "e5c0f149512ead935dccc62f02bd92225ca98187", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-\t\tNSSize size = handle.size();", "-\t\tint width = (int)size.width;", "-\t\tint height = (int)size.height;", "+\t\tint /*long*/ width = imageRep.pixelsWide();", "+\t\tint /*long*/ height = imageRep.pixelsHigh();", "-\t\tbyte[] srcData = new byte[(int)/*64*/dataSize];", "+", "+\t\t// Get the bitmap data from the image representation. In the non-planar case it's easy.", "+\t\tbyte[] srcData = new byte[dataSize];", "+\t\tbyte imageData[] = new byte[dataSize];", "+\t\t", "+\t\tif (!imageRep.isPlanar()) {", "+\t\t\tOS.memmove(imageData, imageRep.bitmapData(), dataSize);", "+\t\t} else {", "+\t\t\tint bytesPerPlane = imageRep.bytesPerPlane();", "+\t\t\tint numPlanes = imageRep.numberOfPlanes();", "+\t\t\t", "+\t\t\t// getBitmapDataPlanes always returns an array of five pointers. Non-applicable", "+\t\t\t// data planes are set to NULL (0).", "+\t\t\tint nativeDataPlanes[] = new int[5];", "+\t\t\timageRep.getBitmapDataPlanes(nativeDataPlanes);", "+\t\t\t", "+\t\t\tbyte dataPlanes[][] = new byte[numPlanes][bytesPerPlane];", "+\t\t\tfor (int i = 0; i < numPlanes; i++) {", "+\t\t\t\tOS.memmove(dataPlanes[i], nativeDataPlanes[i], bytesPerPlane);", "+\t\t\t}", "+\t\t\t", "+\t\t\t// Copy the planar data into the imageData array in ARGB format if there is alpha, and RGB if not.", "+\t\t\t// All non-RGB colorspace images were rejected earlier, so planes 0, 1 and 2 have the R, G, and B", "+\t\t\t// values, respectively. Plane 3 contains alpha values, if there is alpha.", "+\t\t\tNSString colorSpace = imageRep.colorSpaceName();\t\t\t", "+\t\t\tint colorComponents = OS.NSNumberOfColorComponents(colorSpace.id);", "+\t\t\tboolean hasAlpha = false;", "+\t\t\t", "+\t\t\tif (colorComponents == 3) {", "+\t\t\t\tif (numPlanes == 4) hasAlpha = true;", "+\t\t\t\tint samplesPerPixel = (hasAlpha ? 4 : 3);", "+\t\t\t\tint firstByteOfPixel = (hasAlpha ? 1 : 0);", "+\t\t\t\t", "+\t\t\t\tfor (int j = 0, k = 0; j < bytesPerPlane; j += samplesPerPixel, k++) {", "+\t\t\t\t\timageData[j + firstByteOfPixel] = dataPlanes[0][k]; // red component", "+\t\t\t\t\timageData[j + firstByteOfPixel + 1] = dataPlanes[1][k]; // blue component", "+\t\t\t\t\timageData[j + firstByteOfPixel + 2] = dataPlanes[2][k]; // green component", "+\t\t\t\t\tif (hasAlpha) imageData[j] = dataPlanes[3][k]; // alpha component", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+", "-\t\tPaletteData palette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "+\t\t// The RGB mask depends on where the alpha was stored in the pixel data.", "+\t\tint dataFormat = imageRep.bitmapFormat();", "+\t\tPaletteData palette = null;", "+", "+\t\tint /*long*/ bps = imageRep.bitsPerSample();", "+\t\tint blueMask = (1 << bps) - 1;", "+\t\tif (imageRep.hasAlpha() && (dataFormat & OS.NSAlphaFirstBitmapFormat) == 0) blueMask <<= bps;", "+\t\tint greenMask = blueMask << bps;", "+\t\tint redMask = greenMask << bps;", "+\t\t", "+\t\tpalette = new PaletteData(redMask, greenMask, blueMask);", "+", "-\t\t\tint offset = 0, maskOffset = 0;", "+\t\t\tint startByte = ((dataFormat & OS.NSAlphaFirstBitmapFormat) == 0 ? 3 : 0);", "+\t\t\tint offset = startByte, maskOffset = 0;", "-\t\tfor (int i = 0; i < srcData.length; i+= 4) {", "-\t\t\tsrcData[i] = 0;", "+\t\t", "+\t\tif (imageRep.hasAlpha()) {", "+\t\t\tint startByte = ((dataFormat & OS.NSAlphaFirstBitmapFormat) == 0 ? 3 : 0);", "+\t\t\tfor (int i = startByte; i < srcData.length; i+= 4) {", "+\t\t\t\tsrcData[i] = 0;", "+\t\t\t}", "+\t\t\tdata.alpha = alpha;", "+\t\t\tif (alpha == -1 && alphaData != null) {", "+\t\t\t\tdata.alphaData = new byte[alphaData.length];", "+\t\t\t\tSystem.arraycopy(alphaData, 0, data.alphaData, 0, alphaData.length);", "+\t\t\t}", "-\t\tdata.alpha = alpha;", "-\t\tif (alpha == -1 && alphaData != null) {", "-\t\t\tdata.alphaData = new byte[alphaData.length];", "-\t\t\tSystem.arraycopy(alphaData, 0, data.alphaData, 0, alphaData.length);", "-\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "383db3e0baa1f86429f3a0e168aca37a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "5f543edb783691ac010cc1801defbf6238ace7aa", "commitAfterChange": "ffcd121fb7431ca67e0c96c3686d0eb26efd2568", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  void initNative(String filename)", "signatureAfterChange": "  void initNative(String filename)", "diff": ["+\tNSImage nativeImage = null;", "+\t", "-\t\thandle = new NSImage();", "-\t\thandle.alloc();", "+\t\tnativeImage = new NSImage();", "+\t\tnativeImage.alloc();", "-\t\thandle = handle.initWithContentsOfFile(NSString.stringWith(filename));", "-\t\tif (handle == null) SWT.error(SWT.ERROR_INVALID_IMAGE);", "+\t\tnativeImage = nativeImage.initWithContentsOfFile(NSString.stringWith(filename));", "+\t\tif (nativeImage == null) SWT.error(SWT.ERROR_INVALID_IMAGE);", "-\t\tNSImageRep rep = handle.bestRepresentationForDevice(null);", "-\t\tif (rep.isKindOfClass(OS.class_NSBitmapImageRep)) { ", "-\t\t\trep.retain();", "-\t\t\timageRep = new NSBitmapImageRep(rep.id);", "-\t\t} else {", "-\t\t\tNSArray reps = handle.representations();", "+\t\tNSBitmapImageRep nativeRep = null;", "+\t\tNSImageRep bestRep = nativeImage.bestRepresentationForDevice(null);", "+\t\tif (!bestRep.isKindOfClass(OS.class_NSBitmapImageRep)) { ", "+\t\t\tNSArray reps = nativeImage.representations();", "-\t\t\t\t\t\tcurrentRep.retain();", "-\t\t\t\t\t\timageRep = new NSBitmapImageRep(currentRep.id);", "+\t\t\t\t\t\tnativeRep = new NSBitmapImageRep(currentRep.id);", "-\t\t\t// If all else fails, create an NSBitmapImageRep directly from the NSImage.", "-\t\t\tif (imageRep == null) {", "-\t\t\t\timageRep = new NSBitmapImageRep(NSBitmapImageRep.imageRepWithData(handle.TIFFRepresentation()).id);", "-\t\t\t\t// Although addRepresentation will retain the imageRep, we need to retain as well because we will", "-\t\t\t\t// release it in destroy().", "-\t\t\t\timageRep.retain();", "-\t\t\t\thandle.addRepresentation(imageRep);", "+\t\t\t// If all else fails, get an NSBitmapImageRep directly from the NSImage.", "+\t\t\tif (nativeRep == null) {", "+\t\t\t\tnativeRep = new NSBitmapImageRep(NSBitmapImageRep.imageRepWithData(nativeImage.TIFFRepresentation()).id);", "+\t\t} else {", "+\t\t\tnativeRep = new NSBitmapImageRep(bestRep.id);", "-\t\tNSString colorSpace = imageRep.colorSpaceName();", "+\t\tNSString colorSpace = nativeRep.colorSpaceName();", "-\t\theight = (int)/*64*/imageRep.pixelsHigh();", "-\t\twidth = (int)/*64*/imageRep.pixelsWide();", "+\t\tint /*long*/ height = (int)/*64*/nativeRep.pixelsHigh();", "+\t\tint /*long*/ width = (int)/*64*/nativeRep.pixelsWide();", "-\t\thandle.setSize(size);", "+\t\tnativeImage.setSize(size);", "+", "+\t\t// Get the image data. For non-planar images it's easy. For planar images we will walk through", "+\t\t// each plane of data.", "+\t\tint /*long*/ bpr = nativeRep.bytesPerRow();", "+\t\tint /*long*/ dataSize = height * bpr;", "+", "+\t\tbyte imageData[] = new byte[(int)/*64*/dataSize];", "+", "+\t\tif (!nativeRep.isPlanar()) {", "+\t\t\tOS.memmove(imageData, nativeRep.bitmapData(), dataSize);", "+\t\t} else {", "+\t\t\tint /*long*/ bytesPerPlane = nativeRep.bytesPerPlane();", "+\t\t\tint /*long*/ numPlanes = nativeRep.numberOfPlanes();", "+\t\t\t", "+\t\t\t// getBitmapDataPlanes always returns an array of five pointers. Non-applicable", "+\t\t\t// data planes are set to NULL (0).", "+\t\t\tint /*long*/ nativeDataPlanes[] = new int /*long*/ [5];", "+\t\t\tnativeRep.getBitmapDataPlanes(nativeDataPlanes);", "+\t\t\t", "+\t\t\tbyte dataPlanes[][] = new byte[(int)/*64*/numPlanes][(int)/*64*/bytesPerPlane];", "+\t\t\tfor (int i = 0; i < numPlanes; i++) {", "+\t\t\t\tOS.memmove(dataPlanes[i], nativeDataPlanes[i], bytesPerPlane);", "+\t\t\t}", "+\t\t\t", "+\t\t\t// Copy the planar data into the imageData array in ARGB format if there is alpha, and RGB if not.", "+\t\t\t// All non-RGB colorspace images were rejected earlier, so planes 0, 1 and 2 have the R, G, and B", "+\t\t\t// values, respectively. Plane 3 contains alpha values, if there is alpha.", "+\t\t\tint /*long*/ colorComponents = OS.NSNumberOfColorComponents(colorSpace.id);", "+\t\t\tboolean hasAlpha = false;", "+\t\t\t", "+\t\t\tif (colorComponents == 3) {", "+\t\t\t\tif (numPlanes == 4) hasAlpha = true;", "+\t\t\t\tint samplesPerPixel = (hasAlpha ? 4 : 3);", "+\t\t\t\tint firstByteOfPixel = (hasAlpha ? 1 : 0);", "+\t\t\t\t", "+\t\t\t\tfor (int j = 0, k = 0; j < bytesPerPlane; j += samplesPerPixel, k++) {", "+\t\t\t\t\timageData[j + firstByteOfPixel] = dataPlanes[0][k]; // red component", "+\t\t\t\t\timageData[j + firstByteOfPixel + 1] = dataPlanes[1][k]; // blue component", "+\t\t\t\t\timageData[j + firstByteOfPixel + 2] = dataPlanes[2][k]; // green component", "+\t\t\t\t\tif (hasAlpha) imageData[j] = dataPlanes[3][k]; // alpha component", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+", "+\t\tbyte[] nativeAlphaData = null;", "+\t\tint nativeTransparentColor = -1;", "-\t\tbyte[] alphaData = null;", "-\t\t", "-\t\tif (imageRep.hasAlpha()) {", "+\t\tif (nativeRep.hasAlpha()) {", "-\t\t\timageRect.width = handle.size().width;", "-\t\t\timageRect.height = handle.size().height;", "+\t\t\timageRect.width = nativeImage.size().width;", "+\t\t\timageRect.height = nativeImage.size().height;", "-\t\t\thandle.drawInRect(imageRect, zeroRect, OS.NSCompositeCopy, 1.0f);", "+\t\t\tnativeImage.drawInRect(imageRect, zeroRect, OS.NSCompositeCopy, 1.0f);", "-\t\t\talphaData = new byte[(int)/*64*/bitmapByteCount];", "-\t\t\tOS.memmove(alphaData, alphaBitmapData, bitmapByteCount);", "+\t\t\tnativeAlphaData = new byte[(int)/*64*/bitmapByteCount];", "+\t\t\tOS.memmove(nativeAlphaData, alphaBitmapData, bitmapByteCount);", "-\t\t\t\t\t\tif (alphaData[alphaOffset] != 0 && alphaData[alphaOffset] != -1) {", "-\t\t\t\t\t\t\thasTransparentPixel = false;", "+\t\t\t\t\t\tif (nativeAlphaData[alphaOffset] != 0 && nativeAlphaData[alphaOffset] != -1) {", "+\t\t\t\t\t\t\thasTransparentPixel = false;\t\t\t\t\t\t", "-\t\t\t\t\t\tif (alphaData[alphaOffset] == 0) {", "-\t\t\t\t\t\t\tNSColor color = imageRep.colorAtX(x, y);", "+\t\t\t\t\t\tif (nativeAlphaData[alphaOffset] == 0) {", "+\t\t\t\t\t\t\tNSColor color = nativeRep.colorAtX(x, y);", "-\t\t\t}", "+\t\t\t}\t", "-\t\t\tif (hasTransparentPixel) this.transparentPixel = transparentColor;", "+\t\t\tif (hasTransparentPixel) nativeTransparentColor = transparentColor;", "+\t\t\t\t\t", "-\t\tthis.alphaData = alphaData;", "+\t\t// The RGB mask depends on where the alpha was stored in the pixel data.", "+\t\tint /*long*/ dataFormat = nativeRep.bitmapFormat();", "+\t\tint /*long*/ bps = nativeRep.bitsPerSample();", "+\t\tint blueMask = (1 << bps) - 1;", "+\t\tif (nativeRep.hasAlpha() && (dataFormat & OS.NSAlphaFirstBitmapFormat) == 0) blueMask <<= bps;", "+\t\tint greenMask = blueMask << bps;", "+\t\tint redMask = greenMask << bps;\t\t", "+\t\tPaletteData palette = new PaletteData(redMask, greenMask, blueMask);", "+", "+\t\t// Get the image depth.", "+\t\tint /*long*/ bpp = nativeRep.bitsPerPixel();", "+", "+\t\t// We now have everything we neeed to construct an ImageData object and initialize everything from that.", "+\t\tImageData data = new ImageData((int)/*64*/width, (int)/*64*/height, (int)/*64*/bpp, palette, 4, imageData);", "+\t\tdata.bytesPerLine = (int)/*64*/bpr;", "+\t\tdata.transparentPixel = nativeTransparentColor;", "+\t\tdata.alpha = -1;", "+\t\tdata.alphaData = nativeAlphaData;", "+\t\t", "+\t\tthis.init(data);", "+\t\tif (nativeImage != null) nativeImage.release();"]}], "num": 34362}