{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e689d5956a58c44da18604fe2c023e6c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f68c9b50896a9a7d81205ae3b3a35f4d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "bf89cd72be3086dec96af3b122001658951c21fd", "commitAfterChange": "fad88b21def05a66d8895a006e5b263380117619", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "\r public void fillArc (int x, int y, int width, int height, int startAngle, int endAngle)", "signatureAfterChange": "\r public void fillArc (int x, int y, int width, int height, int startAngle, int endAngle)", "diff": ["-\tif (OS.IsWinCE) SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\r", "-\tint x1, y1, x2, y2,tmp;\r", "-\tboolean isNegative;\r", "-\r", "+\t\t\r", "-\r", "-\tif (endAngle >= 360 || endAngle <= -360) {\r", "-\t\tx1 = x2 = x + width;\r", "-\t\ty1 = y2 = y + height / 2;\r", "-\t} else {\r", "-\t\tisNegative = endAngle < 0;\r", "-\r", "-\t\tendAngle = endAngle + startAngle;\r", "-\t\tif (isNegative) {\r", "-\t\t\t// swap angles\r", "-\t\t   \ttmp = startAngle;\r", "-\t\t\tstartAngle = endAngle;\r", "-\t\t\tendAngle = tmp;\r", "-\t\t}\r", "-\t\tx1 = Compatibility.cos(startAngle, width) + x + width/2;\r", "-\t\ty1 = -1 * Compatibility.sin(startAngle, height) + y + height/2;\r", "-\t\t\r", "-\t\tx2 = Compatibility.cos(endAngle, width) + x + width/2;\r", "-\t\ty2 = -1 * Compatibility.sin(endAngle, height) + y + height/2; \t\t\t\t\r", "-\t}\r", "-\r", "-\tint nullPen = OS.GetStockObject(OS.NULL_PEN);\r", "-\tint oldPen = OS.SelectObject(handle, nullPen);\r", "-\tOS.Pie(handle, x,y,x+width+1,y+height+1,x1,y1,x2,y2 );\r", "-\tOS.SelectObject(handle,oldPen);\r", "+\t/*\r", "+\t* Feature in WinCE.  The function Pie is not present in the\r", "+\t* WinCE SDK.  The fix is to emulate it by using Polygon.\r", "+\t*/\r", "+\tif (OS.IsWinCE) {\r", "+\t\t/* compute arc with a simple linear interpolation */\r", "+\t\tif (endAngle < 0) {\r", "+\t\t\tstartAngle += endAngle;\r", "+\t\t\tendAngle = -endAngle;\r", "+\t\t}\r", "+\t\tboolean drawSegments = true;\r", "+\t\tif (endAngle >= 360) {\r", "+\t\t\tendAngle = 360;\r", "+\t\t\tdrawSegments = false;\r", "+\t\t}\r", "+\t\tint[] points = new int[(endAngle + 1) * 2 + (drawSegments ? 4 : 0)];\t\t\r", "+\t\tint cteX = 2 * x + width;\r", "+\t\tint cteY = 2 * y + height;\r", "+\t\tint index = (drawSegments ? 2 : 0);\r", "+\t\tfor (int i = 0; i <= endAngle; i++) {\r", "+\t\t\tpoints[index++] = (Compatibility.cos(startAngle + i, width) + cteX) >> 1;\r", "+\t\t\tpoints[index++] = (cteY - Compatibility.sin(startAngle + i, height)) >> 1;\r", "+\t\t} \r", "+\t\tif (drawSegments) {\r", "+\t\t\tpoints[0] = points[points.length - 2] = cteX >> 1;\r", "+\t\t\tpoints[1] = points[points.length - 1] = cteY >> 1;\r", "+\t\t}\r", "+\t\tint nullPen = OS.GetStockObject(OS.NULL_PEN);\r", "+\t\tint oldPen = OS.SelectObject(handle, nullPen);\r", "+\t\tOS.Polygon(handle, points, points.length / 2);\r", "+\t\tOS.SelectObject(handle, oldPen);\t\r", "+\t} else {\r", "+\t \tint x1, y1, x2, y2,tmp;\r", "+\t\tboolean isNegative;\r", "+\t\tif (endAngle >= 360 || endAngle <= -360) {\r", "+\t\t\tx1 = x2 = x + width;\r", "+\t\t\ty1 = y2 = y + height / 2;\r", "+\t\t} else {\r", "+\t\t\tisNegative = endAngle < 0;\r", "+\t\r", "+\t\t\tendAngle = endAngle + startAngle;\r", "+\t\t\tif (isNegative) {\r", "+\t\t\t\t// swap angles\r", "+\t\t\t   \ttmp = startAngle;\r", "+\t\t\t\tstartAngle = endAngle;\r", "+\t\t\t\tendAngle = tmp;\r", "+\t\t\t}\r", "+\t\t\tx1 = Compatibility.cos(startAngle, width) + x + width/2;\r", "+\t\t\ty1 = -1 * Compatibility.sin(startAngle, height) + y + height/2;\r", "+\t\t\t\r", "+\t\t\tx2 = Compatibility.cos(endAngle, width) + x + width/2;\r", "+\t\t\ty2 = -1 * Compatibility.sin(endAngle, height) + y + height/2; \t\t\t\t\r", "+\t\t}\r", "+\t\r", "+\t\tint nullPen = OS.GetStockObject(OS.NULL_PEN);\r", "+\t\tint oldPen = OS.SelectObject(handle, nullPen);\r", "+\t\tOS.Pie(handle, x,y,x+width+1,y+height+1,x1,y1,x2,y2 );\r", "+\t\tOS.SelectObject(handle,oldPen);\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "87aec5f91dd9b616bad81840cc3f75a6", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "bf89cd72be3086dec96af3b122001658951c21fd", "commitAfterChange": "fad88b21def05a66d8895a006e5b263380117619", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r public void drawArc (int x, int y, int width, int height, int startAngle, int endAngle)", "signatureAfterChange": "\r public void drawArc (int x, int y, int width, int height, int startAngle, int endAngle)", "diff": ["-\tif (OS.IsWinCE) SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\r", "-\tint x1, y1, x2, y2,tmp;\r", "-\tboolean isNegative;\r", "-\tif (endAngle >= 360 || endAngle <= -360) {\r", "-\t\tx1 = x2 = x + width;\r", "-\t\ty1 = y2 = y + height / 2;\r", "-\t} else {\r", "-\t\tisNegative = endAngle < 0;\r", "-\r", "-\t\tendAngle = endAngle + startAngle;\r", "-\t\tif (isNegative) {\r", "-\t\t\t// swap angles\r", "-\t\t   \ttmp = startAngle;\r", "-\t\t\tstartAngle = endAngle;\r", "-\t\t\tendAngle = tmp;\r", "+\t/*\r", "+\t* Feature in WinCE.  The function Arc is not present in the\r", "+\t* WinCE SDK.  The fix is to emulate arc drawing by using\r", "+\t* Polyline.\r", "+\t*/\r", "+\tif (OS.IsWinCE) {\r", "+\t\t/* compute arc with a simple linear interpolation */\r", "+\t\tif (endAngle < 0) {\r", "+\t\t\tstartAngle += endAngle;\r", "+\t\t\tendAngle = -endAngle;\r", "-\t\tx1 = Compatibility.cos(startAngle, width) + x + width/2;\r", "-\t\ty1 = -1 * Compatibility.sin(startAngle, height) + y + height/2;\r", "-\t\t\r", "-\t\tx2 = Compatibility.cos(endAngle, width) + x + width/2;\r", "-\t\ty2 = -1 * Compatibility.sin(endAngle, height) + y + height/2; \t\t\r", "+\t\tif (endAngle > 360) endAngle = 360;\r", "+\t\tint[] points = new int[(endAngle + 1) * 2];\t\t\r", "+\t\tint cteX = 2 * x + width;\r", "+\t\tint cteY = 2 * y + height;\r", "+\t\tint index = 0;\r", "+\t\tfor (int i = 0; i <= endAngle; i++) {\r", "+\t\t\tpoints[index++] = (Compatibility.cos(startAngle + i, width) + cteX) >> 1;\r", "+\t\t\tpoints[index++] = (cteY - Compatibility.sin(startAngle + i, height)) >> 1;\r", "+\t\t} \r", "+\t\tOS.Polyline(handle, points, points.length / 2);\r", "+\t} else {\t\r", "+\t\tint x1, y1, x2, y2,tmp;\r", "+\t\tboolean isNegative;\r", "+\t\tif (endAngle >= 360 || endAngle <= -360) {\r", "+\t\t\tx1 = x2 = x + width;\r", "+\t\t\ty1 = y2 = y + height / 2;\r", "+\t\t} else {\r", "+\t\t\tisNegative = endAngle < 0;\r", "+\t\r", "+\t\t\tendAngle = endAngle + startAngle;\r", "+\t\t\tif (isNegative) {\r", "+\t\t\t\t// swap angles\r", "+\t\t\t   \ttmp = startAngle;\r", "+\t\t\t\tstartAngle = endAngle;\r", "+\t\t\t\tendAngle = tmp;\r", "+\t\t\t}\r", "+\t\t\tx1 = Compatibility.cos(startAngle, width) + x + width/2;\r", "+\t\t\ty1 = -1 * Compatibility.sin(startAngle, height) + y + height/2;\r", "+\t\t\t\r", "+\t\t\tx2 = Compatibility.cos(endAngle, width) + x + width/2;\r", "+\t\t\ty2 = -1 * Compatibility.sin(endAngle, height) + y + height/2; \t\t\r", "+\t\t}\r", "+\t\tint nullBrush = OS.GetStockObject(OS.NULL_BRUSH);\r", "+\t\tint oldBrush = OS.SelectObject(handle, nullBrush);\r", "+\t\tOS.Arc(handle, x,y,x+width+1,y+height+1,x1,y1,x2,y2 );\r", "+\t\tOS.SelectObject(handle,oldBrush);\r", "-\tint nullBrush = OS.GetStockObject(OS.NULL_BRUSH);\r", "-\tint oldBrush = OS.SelectObject(handle, nullBrush);\r", "-\tOS.Arc(handle, x,y,x+width+1,y+height+1,x1,y1,x2,y2 );\r", "-\tOS.SelectObject(handle,oldBrush);\r"]}], "num": 21420}