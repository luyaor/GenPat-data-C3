{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a6a34f8bcdd9d53e0dd0e93d967aec39", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c74e607cc6843ae39411f6c774f7b6c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/StyledText.java", "commitBeforeChange": "635a9e5d0a5f495ec272194dbb750eddc745876f", "commitAfterChange": "e83d77b7ddccf5500d06ea30a64ce0d090ac4b10", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 295, "signatureBeforeChange": "  \tvoid setStyleRange(StyleRange newStyle)", "signatureAfterChange": " public void setStyleRanges(int start, int length, int[] ranges, StyleRange[] styles)", "diff": ["-\t */ ", "-\tvoid setStyleRange(StyleRange newStyle) {", "-\t\tif (newStyle == null) {", "-\t\t\tstyles = new StyleRange[0];", "-\t\t\tstyleCount = 0;", "-\t\t\treturn;", "-\t\t}", "-\t\tif (newStyle.length == 0) return;", "-\t\tif (newStyle.isUnstyled()) {", "-\t\t\tclearStyle(newStyle);", "-\t\t\treturn;", "-\t\t}", "-\t\t", "-\t\tPoint pt = getOverlappingStyles(newStyle.start, newStyle.length);", "-\t\tint newStyleEnd = newStyle.start + newStyle.length - 1;", "-\t\t", "-\t\t// no styles exist", "-\t\tif (pt == null) {", "-\t\t\tinsertStyle(newStyle, 0);", "-\t\t\treturn;", "-\t\t}", "-\t\t", "-\t\t// newStyle does not overlap any other styles", "-\t\tif (pt.y == 0) {", "-\t\t\tinsertMergeStyle(newStyle, pt.x);", "-\t\t\treturn;", "-\t\t} ", "-", "-\t\t// the newStyle overlaps one or more of the existing styles", "-\t\tboolean added = false; // indicates whether or not the new style has been added", "-\t\tint count = 0;", "-\t\t// pt.x is the index of the first overlapped style, pt.y is the number of overlapped", "-\t\t// styles", "-\t\tfor (int i = pt.x; count < pt.y; i++) {", "-\t\t\tStyleRange overlap = styles[i];", "-\t\t\tint overlapEnd = overlap.start + overlap.length - 1;", "-\t\t\tif (overlap.start < newStyle.start) {", "-\t\t\t\tif (overlapEnd <= newStyleEnd) {", "-\t\t\t\t\t// the end of overlap needs to be replaced by newStyle", "-\t\t\t\t\tif (newStyle.similarTo(overlap)) {", "-\t\t\t\t\t\t// update overlap to accomodate the new style", "-\t\t\t\t\t\toverlap.length = newStyle.start + newStyle.length - overlap.start;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\toverlap.length = newStyle.start - overlap.start;", "-\t\t\t\t\t\t// see if newStyle can be merged with the style after overlap, if so,", "-\t\t\t\t\t\t// processing is done", "-\t\t\t\t\t\tif (mergeStyleAfter(newStyle, i + 1)) break;", "-\t\t\t\t\t\t// otherwise, insert the newStyle, newStyle may still overlap other", "-\t\t\t\t\t\t// styles after it so continue processing\t", "-\t\t\t\t\t\tinsertStyle(newStyle, i + 1);", "-\t\t\t\t\t\ti++;", "-\t\t\t\t\t}", "-\t\t\t\t\tadded = true;", "-\t\t\t\t} else {", "-\t\t\t\t\t// middle of overlap needs to be replaced by newStyle, this will", "-\t\t\t\t\t// cause overlap to be broken into two", "-\t\t\t\t\tif (newStyle.similarTo(overlap)) break;", "-\t\t\t\t\tStyleRange endStyle = (StyleRange)overlap.clone();", "-\t\t\t\t\tendStyle.start = newStyleEnd + 1;", "-\t\t\t\t\tendStyle.length = overlapEnd - newStyleEnd;", "-\t\t\t\t\toverlap.length = newStyle.start - overlap.start;", "-\t\t\t\t\tinsertStyle(newStyle, i + 1);", "-\t\t\t\t\ti++;", "-\t\t\t\t\tinsertStyle(endStyle, i + 1);", "-\t\t\t\t\t// when newStyle overlaps the middle of a style, this implies that", "-\t\t\t\t\t// processing is done (no more overlapped styles)", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tif (overlapEnd <= newStyleEnd) {\t", "-\t\t\t\t\t// overlap will be replaced by the newStyle, make sure newStyle", "-\t\t\t\t\t// hasn't already been added, if it has just delete overlap", "-\t\t\t\t\tif (!added) {", "-\t\t\t\t\t\tstyles[i] = newStyle;", "-\t\t\t\t\t\tadded = true;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tdeleteStyles(i, 1);", "-\t\t\t\t\t\ti--;", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\t// beginning of overlap needs to be replaced by newStyle", "-\t\t\t\t\toverlap.start = newStyleEnd + 1;", "-\t\t\t\t\toverlap.length = overlapEnd - overlap.start + 1;", "-\t\t\t\t\tif (!added) {", "-\t\t\t\t\t\tinsertMergeStyle(newStyle, i);", "-\t\t\t\t\t}", "-\t\t\t\t\t// when newStyle overlaps only the beginning of a style, this implies ", "-\t\t\t\t\t// that processing is done (no more overlapped styles)", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tcount++;", "-\t\t}", "-\t}", "+ */", "+public void setStyleRanges(int start, int length, int[] ranges, StyleRange[] styles) {", "+\tcheckWidget();", "+\tif (isListening(LineGetStyle)) return;", "+\tsetStyleRanges(start, length, ranges, styles, false);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a1f10d632e8560d42ed7154e0c7e2205", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/CTabItem.java", "commitBeforeChange": "907c4dd47a285571bf0d66e34d1a9323e15dd90b", "commitAfterChange": "e4b1a868ce731255239223c8ff6f43351c81a864", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " public void setBackground(Color[] colors, int[] percents, boolean vertical)", "signatureAfterChange": " public void setBackground(Color[] colors, int[] percents)", "diff": ["+ */", "+public void setBackground(Color[] colors, int[] percents) {", "+\tsetBackground(colors, percents, false);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "13c870f93a7019e6ed8b79bf563c4155", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt.tools/Mac Generation/org/eclipse/swt/tools/internal/DOMWriter.java", "commitBeforeChange": "8ed739aeb6bdf363f7b0e5c8d1e2c8f2b47241eb", "commitAfterChange": "37dd049635a9e27d1a8ac8a9fdb6deee1a837896", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r\r\tpublic void print(Node node)", "signatureAfterChange": "\r\r\tpublic void print(Node node)", "diff": ["-/*******************************************************************************\r * Copyright (c) 2008 IBM Corporation and others.\r * All rights reserved. This program and the accompanying materials\r * are made available under the terms of the Eclipse Public License v1.0\r * which accompanies this distribution, and is available at\r * http://www.eclipse.org/legal/epl-v10.html\r *\r * Contributors:\r *     IBM Corporation - initial API and implementation\r *******************************************************************************/\rpackage org.eclipse.swt.tools.internal;\r\rimport java.io.PrintStream;\rimport java.util.Arrays;\rimport java.util.Comparator;\r\rimport org.w3c.dom.Attr;\rimport org.w3c.dom.Document;\rimport org.w3c.dom.NamedNodeMap;\rimport org.w3c.dom.Node;\rimport org.w3c.dom.NodeList;\r\rpublic class DOMWriter {\r\r\tstatic String ENCONDING = \"UTF8\";\r\tPrintStream out;\r\tboolean canonical;\r\r\tpublic DOMWriter(PrintStream out, boolean canonical) {\r\t\tthis.out = new PrintStream(out);\r\t\tthis.canonical = canonical;\r\t}\r\r\tString nodeName(Node node) {\r\t\t// TODO use getLocalName()?\r\t\treturn node.getNodeName();\r\t}\r\t\r\tvoid print(String str) {\r\t\tout.print(str);\r\t}\r\tvoid println() {\r\t\tout.println();\r\t}\r\r\tpublic void print(Node node) {\r\t\tif (node == null)\r\t\t\treturn;\r\t\tint type = node.getNodeType();\r\t\tswitch (type) {\r\t\t\tcase Node.DOCUMENT_NODE: {\r\t\t\t\tif (!canonical) {\r\t\t\t\t\tString Encoding = ENCONDING;\r\t\t\t\t\tprint(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\r\t\t\t\t\tprint(Encoding);\r\t\t\t\t\tprint(\"\\\"?>\");\r\t\t\t\t\tprintln();\r\t\t\t\t}\r\t\t\t\tprint(((Document) node).getDocumentElement());\r\t\t\t\tout.flush();\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ELEMENT_NODE: {\r\t\t\t\tprint(\"<\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tAttr attrs[] = sort(node.getAttributes());\r\t\t\t\tfor (int i = 0; i < attrs.length; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(nodeName(attr));\r\t\t\t\t\tprint(\"=\\\"\");\r\t\t\t\t\tprint(normalize(attr.getNodeValue()));\r\t\t\t\t\tprint(\"\\\"\");\r\t\t\t\t}\r\t\t\t\tprint(\">\");\r\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\tif (children != null) {\r\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tprint(children.item(i));\r\t\t\t\t\t}\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ENTITY_REFERENCE_NODE: {\r\t\t\t\tif (canonical) {\r\t\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\t\tif (children != null) {\r\t\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\t\tprint(children.item(i));\r\t\t\t\t\t\t}\r\t\t\t\t\t}\r\t\t\t\t} else {\r\t\t\t\t\tprint(\"&\");\r\t\t\t\t\tprint(nodeName(node));\r\t\t\t\t\tprint(\";\");\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.CDATA_SECTION_NODE: {\r\t\t\t\tif (canonical) {\r\t\t\t\t\tprint(normalize(node.getNodeValue()));\r\t\t\t\t} else {\r\t\t\t\t\tprint(\"<![CDATA[\");\r\t\t\t\t\tprint(node.getNodeValue());\r\t\t\t\t\tprint(\"]]>\");\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.TEXT_NODE: {\r\t\t\t\tprint(normalize(node.getNodeValue()));\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.PROCESSING_INSTRUCTION_NODE: {\r\t\t\t\tprint(\"<?\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tString data = node.getNodeValue();\r\t\t\t\tif (data != null && data.length() > 0) {\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(data);\r\t\t\t\t}\r\t\t\t\tprint(\"?>\");\r\t\t\t\tbreak;\r\t\t\t}\r\t\t}\r\t\tif (type == Node.ELEMENT_NODE) {\r\t\t\tprint(\"</\");\r\t\t\tprint(nodeName(node));\r\t\t\tprint(\">\");\r\t\t}\r\t\tout.flush();\r\t}\r\r\tAttr[] sort(NamedNodeMap attrs) {\r\t\tif (attrs == null)\r\t\t\treturn new Attr[0];\r\t\tAttr result[] = new Attr[attrs.getLength()];\r\t\tfor (int i = 0; i < result.length; i++) {\r\t\t\tresult[i] = (Attr) attrs.item(i);\r\t\t}\r\t\tArrays.sort(result, new Comparator() {\r\t\t\tpublic int compare(Object arg0, Object arg1) {\r\t\t\t\treturn nodeName((Node) arg0).compareTo(nodeName((Node) arg1));\r\t\t\t}\r\t\t});\r\t\treturn result;\r\t}\r\r\tString normalize(String s) {\r\t\tif (s == null) return \"\";\r\t\tStringBuffer str = new StringBuffer();\r\t\tfor (int i = 0, length = s.length(); i < length; i++) {\r\t\t\tchar ch = s.charAt(i);\r\t\t\tswitch (ch) {\r\t\t\t\tcase '\"': str.append(\"\\\"\"); break;\r\t\t\t\tcase '\\r':\r\t\t\t\tcase '\\n':\r\t\t\t\t\tif (canonical) {\r\t\t\t\t\t\tstr.append(\"&#\");\r\t\t\t\t\t\tstr.append(Integer.toString(ch));\r\t\t\t\t\t\tstr.append(';');\r\t\t\t\t\t\tbreak;\r\t\t\t\t\t}\r\t\t\t\t\t// FALL THROUGH\r\t\t\t\tdefault: str.append(ch);\r\t\t\t}\r\t\t}\r\t\treturn str.toString();\r\t}\r}", "\\ No newline at end of file", "+/*******************************************************************************\r * Copyright (c) 2008 IBM Corporation and others.\r * All rights reserved. This program and the accompanying materials\r * are made available under the terms of the Eclipse Public License v1.0\r * which accompanies this distribution, and is available at\r * http://www.eclipse.org/legal/epl-v10.html\r *\r * Contributors:\r *     IBM Corporation - initial API and implementation\r *******************************************************************************/\rpackage org.eclipse.swt.tools.internal;\r\rimport java.io.PrintStream;\rimport java.util.Arrays;\rimport java.util.Comparator;\r\rimport org.w3c.dom.Attr;\rimport org.w3c.dom.Document;\rimport org.w3c.dom.NamedNodeMap;\rimport org.w3c.dom.Node;\rimport org.w3c.dom.NodeList;\r\rpublic class DOMWriter {\r\r\tstatic String ENCONDING = \"UTF8\";\r\tPrintStream out;\r\tboolean canonical, pretty = true;\r\r\tpublic DOMWriter(PrintStream out, boolean canonical) {\r\t\tthis.out = new PrintStream(out);\r\t\tthis.canonical = canonical;\r\t}\r\r\tString nodeName(Node node) {\r\t\t// TODO use getLocalName()?\r\t\treturn node.getNodeName();\r\t}\r\t\r\tvoid print(String str) {\r\t\tout.print(str);\r\t}\r\tvoid println() {\r\t\tout.println();\r\t}\r\r\tpublic void print(Node node) {\r\t\tprint(node, 0);\r\t}\r\t\r\tpublic void print(Node node, int level) {\r\t\tif (node == null)\r\t\t\treturn;\r\t\tint type = node.getNodeType();\r\t\tswitch (type) {\r\t\t\tcase Node.DOCUMENT_NODE: {\r\t\t\t\tif (!canonical) {\r\t\t\t\t\tprint(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\r\t\t\t\t\tprint(ENCONDING);\r\t\t\t\t\tprint(\"\\\"?>\");\r\t\t\t\t\tprintln();\r\t\t\t\t}\r\t\t\t\tprint(((Document) node).getDocumentElement());\r\t\t\t\tout.flush();\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ELEMENT_NODE: {\r\t\t\t\tif (!canonical && pretty) {\r\t\t\t\t\tprintln();\r\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t}\r\t\t\t\tprint(\"<\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tAttr attrs[] = sort(node.getAttributes());\r\t\t\t\tfor (int i = 0; i < attrs.length; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(nodeName(attr));\r\t\t\t\t\tprint(\"=\\\"\");\r\t\t\t\t\tprint(normalize(attr.getNodeValue()));\r\t\t\t\t\tprint(\"\\\"\");\r\t\t\t\t}\r\t\t\t\tprint(\">\");\r\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\tif (children != null) {\r\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t}\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ENTITY_REFERENCE_NODE: {\r\t\t\t\tif (canonical) {\r\t\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\t\tif (children != null) {\r\t\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t\t}\r\t\t\t\t\t}\r\t\t\t\t} else {\r\t\t\t\t\tprint(\"&\");\r\t\t\t\t\tprint(nodeName(node));\r\t\t\t\t\tprint(\";\");\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.CDATA_SECTION_NODE: {\r\t\t\t\tif (canonical) {\r\t\t\t\t\tprint(normalize(node.getNodeValue()));\r\t\t\t\t} else {\r\t\t\t\t\tprint(\"<![CDATA[\");\r\t\t\t\t\tprint(node.getNodeValue());\r\t\t\t\t\tprint(\"]]>\");\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.TEXT_NODE: {\r\t\t\t\tprint(normalize(node.getNodeValue()));\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.PROCESSING_INSTRUCTION_NODE: {\r\t\t\t\tprint(\"<?\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tString data = node.getNodeValue();\r\t\t\t\tif (data != null && data.length() > 0) {\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(data);\r\t\t\t\t}\r\t\t\t\tprint(\"?>\");\r\t\t\t\tbreak;\r\t\t\t}\r\t\t}\r\t\tif (type == Node.ELEMENT_NODE) {\r\t\t\tif (!canonical && pretty) {\r\t\t\t\tif (node.getChildNodes().getLength() > 0) {\r\t\t\t\t\tprintln();\r\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t}\t\t\t\t\r\t\t\t}\r\t\t\tprint(\"</\");\r\t\t\tprint(nodeName(node));\r\t\t\tprint(\">\");\r\t\t}\r\t\tout.flush();\r\t}\r\r\tAttr[] sort(NamedNodeMap attrs) {\r\t\tif (attrs == null)\r\t\t\treturn new Attr[0];\r\t\tAttr result[] = new Attr[attrs.getLength()];\r\t\tfor (int i = 0; i < result.length; i++) {\r\t\t\tresult[i] = (Attr) attrs.item(i);\r\t\t}\r\t\tArrays.sort(result, new Comparator() {\r\t\t\tpublic int compare(Object arg0, Object arg1) {\r\t\t\t\treturn nodeName((Node) arg0).compareTo(nodeName((Node) arg1));\r\t\t\t}\r\t\t});\r\t\treturn result;\r\t}\r\r\tString normalize(String s) {\r\t\tif (s == null) return \"\";\r\t\tStringBuffer str = new StringBuffer();\r\t\tfor (int i = 0, length = s.length(); i < length; i++) {\r\t\t\tchar ch = s.charAt(i);\r\t\t\tswitch (ch) {\r\t\t\t\tcase '\"': str.append(\"\\\"\"); break;\r\t\t\t\tcase '\\r':\r\t\t\t\tcase '\\n':\r\t\t\t\t\tif (canonical) {\r\t\t\t\t\t\tstr.append(\"&#\");\r\t\t\t\t\t\tstr.append(Integer.toString(ch));\r\t\t\t\t\t\tstr.append(';');\r\t\t\t\t\t\tbreak;\r\t\t\t\t\t}\r\t\t\t\t\t// FALL THROUGH\r\t\t\t\tdefault: str.append(ch);\r\t\t\t}\r\t\t}\r\t\treturn str.toString();\r\t}\r}", "\\ No newline at end of file"]}], "num": 31184}