{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "eabcc304985b71c5095f7301b441a43d", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "98869c387ac3f48182c7a4199378845d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "83e1dac1af837594e187e72e8d4c2cd60386743f", "commitAfterChange": "aba5823d7335842a1956cc66c799c92c1aafef99", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 40, "signatureBeforeChange": " public void setSelection (TreeItem [] items)", "signatureAfterChange": " public void setSelection (TreeItem [] items)", "diff": ["-\tint hNewItem = 0;", "+\t", "-\t\thAnchor = hNewItem = item.handle;", "+\t\tint hNewItem = hAnchor = item.handle;", "+\t\t", "+\t\t/*", "+\t\t* Bug in Windows.  When TVM_SELECTITEM is used to ensure", "+\t\t* that an item is visible and the client area of the tree is", "+\t\t* smaller that the size of one item, TVM_SELECTITEM makes", "+\t\t* the next item in the tree visible by making it the top item", "+\t\t* instead of making the desired item visible.  The fix is to", "+\t\t* detect the case when the client area is too small and make", "+\t\t* the desired visible item be the top item in the tree.", "+\t\t*/", "+\t\tboolean fixScroll = checkScroll (hNewItem);", "+\t\tif (fixScroll) OS.SendMessage (handle, OS.WM_SETREDRAW, 1, 0);", "+\t\tignoreSelect = true;", "+\t\tOS.SendMessage (handle, OS.TVM_SELECTITEM, OS.TVGN_CARET, hNewItem);", "+\t\tignoreSelect = false;", "+\t\tif (OS.SendMessage (handle, OS.TVM_GETVISIBLECOUNT, 0, 0) == 0) {", "+\t\t\tOS.SendMessage (handle, OS.TVM_SELECTITEM, OS.TVGN_FIRSTVISIBLE, hNewItem);", "+\t\t}", "+\t\tif (fixScroll) OS.SendMessage (handle, OS.WM_SETREDRAW, 0, 0);", "+\t\t", "+\t\t/*", "+\t\t* Feature in Windows.  When the old and new focused item", "+\t\t* are the same, Windows does not check to make sure that", "+\t\t* the item is actually selected, not just focused.  The", "+\t\t* fix is to force the item to draw selected by setting", "+\t\t* the state mask.", "+\t\t*/", "+\t\tif (hOldItem == hNewItem) {", "+\t\t\tTVITEM tvItem = new TVITEM ();", "+\t\t\ttvItem.mask = OS.TVIF_STATE;", "+\t\t\ttvItem.state = OS.TVIS_SELECTED;", "+\t\t\ttvItem.stateMask = OS.TVIS_SELECTED;", "+\t\t\ttvItem.hItem = hNewItem;", "+\t\t\tOS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);", "+\t\t}", "-\tboolean fixScroll = hNewItem != 0 && checkScroll (hNewItem);", "-\tif (fixScroll) OS.SendMessage (handle, OS.WM_SETREDRAW, 1, 0);", "-\tignoreSelect = true;", "-\tOS.SendMessage (handle, OS.TVM_SELECTITEM, OS.TVGN_CARET, hNewItem);", "-\tignoreSelect = false;", "-\tif (fixScroll) OS.SendMessage (handle, OS.WM_SETREDRAW, 0, 0);", "-\t/*", "-\t* Feature in Windows.  When the old and new focused item", "-\t* are the same, Windows does not check to make sure that", "-\t* the item is actually selected, not just focused.  The", "-\t* fix is to force the item to draw selected by setting", "-\t* the state mask.", "-\t*/", "-\tif (hOldItem == hNewItem) {", "-\t\tTVITEM tvItem = new TVITEM ();", "-\t\ttvItem.mask = OS.TVIF_STATE;", "-\t\ttvItem.state = OS.TVIS_SELECTED;", "-\t\ttvItem.stateMask = OS.TVIS_SELECTED;", "-\t\ttvItem.hItem = hNewItem;", "-\t\tOS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);", "-\t}", "-\tfixPinheadScroll (hNewItem);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e0e4fffe648cfe07cf5aae05a4e14068", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "c1d061ac0465366604624bdd8c1657d13f6ebb95", "commitAfterChange": "03cfb284627777881e08280991a82f2cacd918bd", "methodNumberBeforeChange": 99, "methodNumberAfterChange": 99, "signatureBeforeChange": "  public void setRedraw (boolean redraw)", "signatureAfterChange": "  public void setRedraw (boolean redraw)", "diff": ["+\t* Feature in Windows.  When WM_SETREDRAW is used to", "+\t* turn off redraw, the scroll bars are updated when", "+\t* items are added and removed.  The fix is to call", "+\t* the default window proc to stop all drawing.", "+\t* ", "-\tif (redraw && drawCount == 1) {", "-\t\tint count = OS.SendMessage (handle, OS.TVM_GETCOUNT, 0, 0);", "-\t\tif (count == 0) {", "-\t\t\tTVINSERTSTRUCT tvInsert = new TVINSERTSTRUCT ();", "-\t\t\ttvInsert.hInsertAfter = OS.TVI_FIRST;", "-\t\t\thItem = OS.SendMessage (handle, OS.TVM_INSERTITEM, 0, tvInsert);", "+\tif (redraw) {", "+\t\tif (drawCount == 1) {", "+\t\t\tint count = OS.SendMessage (handle, OS.TVM_GETCOUNT, 0, 0);", "+\t\t\tif (count == 0) {", "+\t\t\t\tTVINSERTSTRUCT tvInsert = new TVINSERTSTRUCT ();", "+\t\t\t\ttvInsert.hInsertAfter = OS.TVI_FIRST;", "+\t\t\t\thItem = OS.SendMessage (handle, OS.TVM_INSERTITEM, 0, tvInsert);", "+\t\t\t}", "+\t\t\tOS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);", "-\t/*", "-\t* Feature in Windows.  When WM_SETREDRAW is used to", "-\t* turn off redraw, the scroll bars are updated when", "-\t* items are added and removed.  The fix is to call", "-\t* the default window proc to stop all drawing.", "-\t*/", "-//\tif (redraw) {", "-//\t\tif (drawCount == 0) OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);", "-//\t} else {", "-//\t\tif (drawCount == 1) OS.DefWindowProc (handle, OS.WM_SETREDRAW, 0, 0);", "-//\t}", "+\tif (!redraw) {", "+\t\tif (drawCount == 1) OS.DefWindowProc (handle, OS.WM_SETREDRAW, 0, 0);", "+\t}"]}], "num": 28779}