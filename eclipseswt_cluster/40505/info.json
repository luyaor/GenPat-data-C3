{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "034a2b6ea9f09a5d495c1b18b82e881c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "070cd90682ab8368dc32f05245ef586e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/StyledText2.java", "commitBeforeChange": "60a9b0215b046632b51b65b9dcf0569516e0686e", "commitAfterChange": "610b674161bbe6c03029856ff3ee4570430b9973", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 63, "signatureBeforeChange": " void claimBottomFreeSpace()", "signatureAfterChange": " void claimBottomFreeSpace()", "diff": ["-\t\tif (newVerticalOffset < verticalScrollOffset) {", "+\t\tif (newVerticalOffset < getVerticalScrollOffset()) {", "-\t\t\tscrollVertical(newVerticalOffset - verticalScrollOffset, true);", "+\t\t\tscrollVertical(newVerticalOffset - getVerticalScrollOffset(), true);", "-\t\tint bottomIndex = getLineIndex(clientAreaHeight);", "-\t\tint height = getLinePixel(bottomIndex) + lineCache.getLineHeight(bottomIndex);", "+\t\tint bottomIndex = getPartialBottomIndex();", "+\t\tint height = getLinePixel(bottomIndex + 1);", "-\t\t\theight = clientAreaHeight - height;", "-\t\t\theight = Math.min(verticalScrollOffset, height);", "-\t\t\tscrollVertical(-height, true);", "+\t\t\tint delta = clientAreaHeight - height;", "+\t\t\tint maxDelta = verticalScrollOffset;", "+\t\t\tif (maxDelta == -1) {", "+\t\t\t\tint index = getPartialTopIndex();", "+\t\t\t\tmaxDelta = lineCache.getLineHeight(index) - partialHeight;", "+\t\t\t\twhile (delta > maxDelta && index > 0) {", "+\t\t\t\t\tindex--;", "+\t\t\t\t\tmaxDelta += lineCache.getLineHeight(index);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tdelta = Math.min(maxDelta, delta);", "+\t\t\tif (verticalScrollOffset != -1) {", "+\t\t\t\tscrollVertical(-delta, true);", "+\t\t\t} else {", "+\t\t\t\t// scrolling when verticalScrollOffset is invalid is a slow operation", "+\t\t\t\t// only update the top index and the caret, caller needs to invalidate the area", "+\t\t\t\t// verticalScrollOffset is valid at the end of the calculate idle", "+\t\t\t\tcalculateTopIndex(-delta);", "+\t\t\t}", "+\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8405fda130e98ad2560895988b2fef5f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/StyledText.java", "commitBeforeChange": "635a9e5d0a5f495ec272194dbb750eddc745876f", "commitAfterChange": "e83d77b7ddccf5500d06ea30a64ce0d090ac4b10", "methodNumberBeforeChange": 177, "methodNumberAfterChange": 49, "signatureBeforeChange": " \tprivate void setVisualLine(int visualLineIndex, int visualLineOffset, int visualLineLength)", "signatureAfterChange": " void claimBottomFreeSpace()", "diff": ["-\t */", "-\tprivate void setVisualLine(int visualLineIndex, int visualLineOffset, int visualLineLength) {", "-\t\tensureSize(visualLineCount + 1);", "-\t\t// is the space for the visual line already taken? can happen if ", "-\t\t// there are more visual lines for a given logical line than before", "-\t\tif (visualLines[visualLineIndex][LINE_OFFSET] != -1) {", "-\t\t\tSystem.arraycopy(visualLines, visualLineIndex, visualLines, visualLineIndex + 1, visualLineCount - visualLineIndex);", "-\t\t\tvisualLines[visualLineIndex] = new int[2];", "-\t\t}", "-\t\tvisualLines[visualLineIndex][LINE_OFFSET] = visualLineOffset;", "-\t\tvisualLines[visualLineIndex][LINE_LENGTH] = visualLineLength;", "-\t\tvisualLineCount++;", "-\t}", "+\tif (isFixedLineHeight()) {", "+\t\tint lineHeight = renderer.getLineHeight();", "+\t\tint newVerticalOffset = Math.max(0, content.getLineCount() * lineHeight - getClientArea().height);", "+\t\tif (newVerticalOffset < getVerticalScrollOffset()) {", "+\t\t\t// Scroll up so that empty lines below last text line are used.", "+\t\t\t// Fixes 1GEYJM0", "+\t\t\tscrollVertical(newVerticalOffset - getVerticalScrollOffset(), true);", "+\t\t}", "+\t} else {\t", "+\t\tint clientAreaHeight = getClientArea().height;", "+\t\tint bottomIndex = getPartialBottomIndex();", "+\t\tint height = getLinePixel(bottomIndex + 1);", "+\t\tif (clientAreaHeight > height) {", "+\t\t\tint delta = clientAreaHeight - height;", "+\t\t\tint maxDelta = verticalScrollOffset;", "+\t\t\tif (maxDelta == -1) {", "+\t\t\t\tint index = getPartialTopIndex();", "+\t\t\t\tmaxDelta = renderer.getLineHeight(index) - partialHeight;", "+\t\t\t\twhile (delta > maxDelta && index > 0) {", "+\t\t\t\t\tindex--;", "+\t\t\t\t\tmaxDelta += renderer.getLineHeight(index);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tdelta = Math.min(maxDelta, delta);", "+\t\t\tif (verticalScrollOffset != -1) {", "+\t\t\t\tscrollVertical(-delta, true);", "+\t\t\t} else {", "+\t\t\t\t// scrolling when verticalScrollOffset is invalid is a slow operation", "+\t\t\t\t// only update the top index and the caret, caller needs to invalidate the area", "+\t\t\t\t// verticalScrollOffset is valid at the end of the calculate idle", "+\t\t\t\tcalculateTopIndex(-delta);", "+\t\t\t}", "+\t\t\t", "+\t\t}"]}], "num": 40505}