{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "12b337fcb8a1d0c39d234976f2754b17", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "44d3f0582d6a452018910ae9f434d210", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Program/gtk/org/eclipse/swt/program/Program.java", "commitBeforeChange": "fddcf2f032850d3eb6550c44c0aeb80fc19a12d0", "commitAfterChange": "3ae6372c58eb26df700867f6c185ea003b6c1de1", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 14, "signatureBeforeChange": " private static String[] parseCommand(String cmd)", "signatureAfterChange": "  static String[] parseCommand(String cmd)", "diff": ["-// Private method for parsing a command line into its arguments.", "-private static String[] parseCommand(String cmd) {", "-\tVector args = new Vector();", "-\tint sIndex = 0;", "-\tint eIndex;", "-\twhile (sIndex < cmd.length()) {", "-\t\t// Trim initial white space of argument.", "-\t\twhile (sIndex < cmd.length() && Compatibility.isWhitespace(cmd.charAt(sIndex))) {", "-\t\t\tsIndex++;", "-\t\t}", "-\t\tif (sIndex < cmd.length()) {", "-\t\t\t// If the command is a quoted string", "-\t\t\tif (cmd.charAt(sIndex) == '\"' || cmd.charAt(sIndex) == '\\'') {", "-\t\t\t\t// Find the terminating quote (or end of line).", "-\t\t\t\t// This code currently does not handle escaped characters (e.g., \" a\\\"b\").", "-\t\t\t\teIndex = sIndex + 1;", "-\t\t\t\twhile (eIndex < cmd.length() && cmd.charAt(eIndex) != cmd.charAt(sIndex)) {", "-\t\t\t\t\teIndex++;", "-\t\t\t\t}", "-\t\t\t\tif (eIndex >= cmd.length()) { // the terminating quote was not found", "-\t\t\t\t\t// Add the argument as is with only one initial quote.", "-\t\t\t\t\targs.addElement(cmd.substring(sIndex, eIndex));", "-\t\t\t\t}", "-\t\t\t\t// else add the argument, trimming off the quotes.", "-\t\t\t\telse {", "-\t\t\t\t\targs.addElement(cmd.substring( sIndex+1, eIndex));", "-\t\t\t\t}", "-\t\t\t\tsIndex = eIndex + 1;", "-\t\t\t}", "-\t\t\t", "-\t\t\t// else use white space for the delimiters.", "-\t\t\telse {", "-\t\t\t\teIndex = sIndex;", "-\t\t\t\twhile (eIndex < cmd.length() && !Compatibility.isWhitespace(cmd.charAt(eIndex))) {", "-\t\t\t\t\teIndex++;", "-\t\t\t\t}", "-\t\t\t\targs.addElement(cmd.substring(sIndex, eIndex));", "-\t\t\t\tsIndex = eIndex + 1;", "-\t\t\t}", "-\t\t}", "-\t", "-\tString[] strings = new String[args.size()];", "-\tfor (int index =0; index < args.size(); index++) {", "-\t\tstrings[index] = (String)args.elementAt(index);", "-\t}", "-\treturn strings;", "+", "+static String[] parseCommand(String cmd) {", "+\tVector args = new Vector();", "+\tint sIndex = 0;", "+\tint eIndex;", "+\twhile (sIndex < cmd.length()) {", "+\t\t/* Trim initial white space of argument. */", "+\t\twhile (sIndex < cmd.length() && Compatibility.isWhitespace(cmd.charAt(sIndex))) {", "+\t\t\tsIndex++;", "+\t\t}", "+\t\tif (sIndex < cmd.length()) {", "+\t\t\t/* If the command is a quoted string */", "+\t\t\tif (cmd.charAt(sIndex) == '\"' || cmd.charAt(sIndex) == '\\'') {", "+\t\t\t\t/* Find the terminating quote (or end of line).", "+\t\t\t\t * This code currently does not handle escaped characters (e.g., \" a\\\"b\").", "+\t\t\t\t */", "+\t\t\t\teIndex = sIndex + 1;", "+\t\t\t\twhile (eIndex < cmd.length() && cmd.charAt(eIndex) != cmd.charAt(sIndex)) eIndex++;", "+\t\t\t\tif (eIndex >= cmd.length()) { ", "+\t\t\t\t\t/* The terminating quote was not found", "+\t\t\t\t\t * Add the argument as is with only one initial quote.", "+\t\t\t\t\t */", "+\t\t\t\t\targs.addElement(cmd.substring(sIndex, eIndex));", "+\t\t\t\t}", "+\t\t\t\telse {", "+\t\t\t\t\t/* Add the argument, trimming off the quotes. */", "+\t\t\t\t\targs.addElement(cmd.substring(sIndex+1, eIndex));", "+\t\t\t\t}", "+\t\t\t\tsIndex = eIndex + 1;", "+\t\t\t}\t\t\t", "+\t\t\telse {", "+\t\t\t\t/* Use white space for the delimiters. */", "+\t\t\t\teIndex = sIndex;", "+\t\t\t\twhile (eIndex < cmd.length() && !Compatibility.isWhitespace(cmd.charAt(eIndex))) eIndex++;", "+\t\t\t\targs.addElement(cmd.substring(sIndex, eIndex));", "+\t\t\t\tsIndex = eIndex + 1;", "+\t\t\t}", "+\t\t}", "+\t}", "+\t", "+\tString[] strings = new String[args.size()];", "+\tfor (int index =0; index < args.size(); index++) {", "+\t\tstrings[index] = (String)args.elementAt(index);", "+\t}", "+\treturn strings;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "934894fbec29b78c493ecc00c8cecbec", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Program/motif/org/eclipse/swt/program/Program.java", "commitBeforeChange": "5e356c18b07e7f5af1a6b17c096783ad43ee7650", "commitAfterChange": "bec9de216652a0f1829bdec4dfa5d60c81e5e090", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 20, "signatureBeforeChange": "    private static Hashtable kde_getMimeInfo()", "signatureAfterChange": "   static Hashtable kde_getMimeInfo()", "diff": ["-  ", "-private static Hashtable kde_getMimeInfo() {", "+ */  ", "+static Hashtable kde_getMimeInfo() {", "-\tVector    mimeExts = null;", "-\tString    mimeType;", "+\tVector mimeExts = null;", "+\tString mimeType;", "-\t// Get the list of all mime types available.", "+\t/* Get the list of all mime types available. */", "-\tint iterator = KDE.KMimeTypeList_begin( mimeTypeList );", "-\tint listEnd  = KDE.KMimeTypeList_end( mimeTypeList );", "-\twhile (KDE.KMimeTypeListIterator_equals( iterator, listEnd ) == 0) {", "-\t\t// Get the next KMimeType from the list.", "-\t\tint kMimeType = KDE.KMimeTypeListIterator_dereference( iterator );", "+\tint iterator = KDE.KMimeTypeList_begin(mimeTypeList);", "+\tint listEnd = KDE.KMimeTypeList_end(mimeTypeList);", "+\twhile (KDE.KMimeTypeListIterator_equals(iterator, listEnd) == 0) {", "+\t\tint kMimeType = KDE.KMimeTypeListIterator_dereference(iterator);", "+\t\tint mimeName = KDE.KMimeType_name(kMimeType);", "+\t\tmimeType = kde_convertQStringAndFree(mimeName);", "-\t\t// Get the mime type name.", "-\t\tint mimeName = KDE.KMimeType_name( kMimeType );", "-\t\tmimeType = kde_convertQStringAndFree( mimeName );", "-\t\t", "-\t\t// Get the list of extension patterns.", "+\t\t/* Get the list of extension patterns. */", "-\t\t// Add the mime type to the hash table with its extensions.", "-\t\tint patternList = KDE.KMimeType_patterns( kMimeType );", "-\t\tint patIterator = KDE.QStringList_begin( patternList );", "-\t\tint patListEnd  = KDE.QStringList_end( patternList );", "-\t\twhile (KDE.QStringListIterator_equals( patIterator, patListEnd ) == 0) {", "-\t\t\t// Get the next extension pattern from the list.", "-\t\t\tint patString = KDE.QStringListIterator_dereference( patIterator );", "-\t\t\textension = kde_convertQStringAndFree( patString );", "-\t\t\tint period = extension.indexOf( '.' );", "-\t\t\tif (period != -1) {", "-\t\t\t\tmimeExts.addElement( extension.substring( period ) );", "-\t\t\t}", "+\t\t/* Add the mime type to the hash table with its extensions. */", "+\t\tint patternList = KDE.KMimeType_patterns(kMimeType);", "+\t\tint patIterator = KDE.QStringList_begin(patternList);", "+\t\tint patListEnd  = KDE.QStringList_end(patternList);", "+\t\twhile (KDE.QStringListIterator_equals(patIterator, patListEnd) == 0) {", "+\t\t\t/* Get the next extension pattern from the list. */", "+\t\t\tint patString = KDE.QStringListIterator_dereference(patIterator);", "+\t\t\textension = kde_convertQStringAndFree(patString);", "+\t\t\tint period = extension.indexOf('.');", "+\t\t\tif (period != -1) mimeExts.addElement(extension.substring(period));", "-\t\t\t// Advance to the next pattern.\t\t", "-\t\t\tKDE.QStringListIterator_increment( patIterator );", "+\t\t\t/* Advance to the next pattern. */\t\t", "+\t\t\tKDE.QStringListIterator_increment(patIterator);", "-\t\tKDE.QStringListIterator_delete( patIterator );", "-\t\tKDE.QStringListIterator_delete( patListEnd );", "-\t\tKDE.QStringList_delete( patternList );", "+\t\tKDE.QStringListIterator_delete(patIterator);", "+\t\tKDE.QStringListIterator_delete(patListEnd);", "+\t\tKDE.QStringList_delete(patternList);", "-\t\t// If there is at least one extension, save the mime type.", "-\t\tif (mimeExts.size() > 0) {", "-\t\t\tmimeInfo.put( mimeType, mimeExts );", "-\t\t}", "+\t\t/* If there is at least one extension, save the mime type. */", "+\t\tif (mimeExts.size() > 0) mimeInfo.put(mimeType, mimeExts);", "-\t\t// Advance to the next mime type.\t\t", "-\t\tKDE.KMimeTypeListIterator_increment( iterator );", "+\t\t/* Advance to the next mime type. */\t\t", "+\t\tKDE.KMimeTypeListIterator_increment(iterator);", "-\tKDE.KMimeTypeListIterator_delete( iterator );", "-\tKDE.KMimeTypeListIterator_delete( listEnd );", "-\tKDE.KMimeTypeList_delete( mimeTypeList );", "-\t", "+\tKDE.KMimeTypeListIterator_delete(iterator);", "+\tKDE.KMimeTypeListIterator_delete(listEnd);", "+\tKDE.KMimeTypeList_delete(mimeTypeList);"]}], "num": 15002}