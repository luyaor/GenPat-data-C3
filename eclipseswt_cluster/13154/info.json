{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "80b626b944441ecbf02926db348a3ba1", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90575e7fba85c8ef19197cc2ae21cdec", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "965aecf4cb4bb3fe4dee75052118eb5b4063e4f5", "commitAfterChange": "3eef16495f54d2582a2f00d444f7f01291b26d62", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public Image(Device device, ImageData source, ImageData mask)", "signatureAfterChange": " public Image(Device device, ImageData source, ImageData mask)", "diff": ["-\t/* Create a temporary image and locate the black pixel */", "-\tImageData image;", "-\tint blackIndex = 0;", "-\tif (source.palette.isDirect) {", "-\t\timage = new ImageData(source.width, source.height, source.depth, source.palette);", "-\t} else {", "-\t\tRGB black = new RGB(0, 0, 0);", "-\t\tRGB[] rgbs = source.getRGBs();", "-\t\tif (source.transparentPixel != -1) {", "-\t\t\t/*", "-\t\t\t * The source had transparency, so we can use the transparent pixel", "-\t\t\t * for black.", "-\t\t\t */", "-\t\t\tRGB[] newRGBs = new RGB[rgbs.length];", "-\t\t\tSystem.arraycopy(rgbs, 0, newRGBs, 0, rgbs.length);", "-\t\t\tif (source.transparentPixel >= newRGBs.length) {", "-\t\t\t\t/* Grow the palette with black */", "-\t\t\t\trgbs = new RGB[source.transparentPixel + 1];", "-\t\t\t\tSystem.arraycopy(newRGBs, 0, rgbs, 0, newRGBs.length);", "-\t\t\t\tfor (int i = newRGBs.length; i <= source.transparentPixel; i++) {", "-\t\t\t\t\trgbs[i] = new RGB(0, 0, 0);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tnewRGBs[source.transparentPixel] = black;", "-\t\t\t\trgbs = newRGBs;", "-\t\t\t}", "-\t\t\tblackIndex = source.transparentPixel;", "-\t\t\timage = new ImageData(source.width, source.height, source.depth, new PaletteData(rgbs));", "-\t\t} else {", "-\t\t\twhile (blackIndex < rgbs.length) {", "-\t\t\t\tif (rgbs[blackIndex].equals(black)) break;", "-\t\t\t\tblackIndex++;", "-\t\t\t}", "-\t\t\tif (blackIndex == rgbs.length) {", "-\t\t\t\t/*", "-\t\t\t\t * We didn't find black in the palette, and there is no transparent", "-\t\t\t\t * pixel we can use.", "-\t\t\t\t */", "-\t\t\t\tif ((1 << source.depth) > rgbs.length) {", "-\t\t\t\t\t/* We can grow the palette and add black */", "-\t\t\t\t\tRGB[] newRGBs = new RGB[rgbs.length + 1];", "-\t\t\t\t\tSystem.arraycopy(rgbs, 0, newRGBs, 0, rgbs.length);", "-\t\t\t\t\tnewRGBs[rgbs.length] = black;", "-\t\t\t\t\trgbs = newRGBs;", "-\t\t\t\t} else {", "-\t\t\t\t\t/* No room to grow the palette */", "-\t\t\t\t\tblackIndex = -1;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\timage = new ImageData(source.width, source.height, source.depth, new PaletteData(rgbs));", "-\t\t}", "-\t}", "-\tif (blackIndex == -1) {", "-\t\t/* There was no black in the palette, so just copy the data over */", "-\t\tSystem.arraycopy(source.data, 0, image.data, 0, image.data.length);", "-\t} else {", "-\t\t/* Modify the source image to contain black wherever the mask is 0 */", "-\t\tint[] imagePixels = new int[image.width];", "-\t\tint[] maskPixels = new int[mask.width];", "-\t\tfor (int y = 0; y < image.height; y++) {", "-\t\t\tsource.getPixels(0, y, image.width, imagePixels, 0);", "-\t\t\tmask.getPixels(0, y, mask.width, maskPixels, 0);", "-\t\t\tfor (int i = 0; i < imagePixels.length; i++) {", "-\t\t\t\tif (maskPixels[i] == 0) imagePixels[i] = blackIndex;", "-\t\t\t}", "-\t\t\timage.setPixels(0, y, source.width, imagePixels, 0);", "-\t\t}", "-\t}", "-\t/*", "-\t * Make sure the mask is padded properly. Windows requires icon masks", "-\t * to have a scanline pad of 2.", "-\t */", "-\tint bytesPerLine = (((mask.width + 7) / 8) + 1) / 2 * 2;", "-\tbyte[] newMaskData = new byte[bytesPerLine * mask.height];", "-\tImageData newMask = new ImageData(mask.width, mask.height, 1, mask.palette, 2, newMaskData);", "-\tint[] maskPixels = new int[mask.width];", "-\tfor (int y = 0; y < mask.height; y++) {", "-\t\tmask.getPixels(0, y, mask.width, maskPixels, 0);", "-\t\tnewMask.setPixels(0, y, newMask.width, maskPixels, 0);", "-\t}", "-\t/* Set the fields and create the icon */", "-\timage.maskPad = newMask.scanlinePad;", "-\timage.maskData = newMask.data;", "-\tinit(device, image);", "+\tinit(device, this, source, mask);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "70cbd83771cf8149cb0cba7e1afbeaa2", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Drag and Drop/cocoa/org/eclipse/swt/dnd/DropTarget.java", "commitBeforeChange": "6b0a245288556e7224d3c56682401ca81ba95245", "commitAfterChange": "4dbd09dcd54c5e8b8416ccbe2fdfacc6901be61f", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 14, "signatureBeforeChange": "  boolean setEventData(int theDrag, DNDEvent event)", "signatureAfterChange": "  boolean setEventData(int theDrag, DNDEvent event)", "diff": ["-\tif (theDrag == 0) return false;", "+//\tif (theDrag == 0) return false;", "+//\t", "+//\t// get allowed operations", "+//\tint style = getStyle();", "+//\tint[] outActions = new int[1];", "+//\tOS.GetDragAllowableActions(theDrag, outActions);", "+//\tint operations = osOpToOp(outActions[0]) & style;", "+//\tif (operations == DND.DROP_NONE) return false;", "+//\t", "+//\t//get current operation", "+//\tint operation =  getOperationFromKeyState(theDrag);", "+//\tkeyOperation = operation;", "+//\tif (operation == DND.DROP_DEFAULT) {", "+//\t\t if ((style & DND.DROP_DEFAULT) == 0) {", "+//\t\t\toperation = (operations & DND.DROP_MOVE) != 0 ? DND.DROP_MOVE : DND.DROP_NONE;", "+//\t\t }", "+//\t} else {", "+//\t\tif ((operation & operations) == 0) operation = DND.DROP_NONE;", "+//\t}", "+//\t", "+//\t// get allowed transfer types", "+//\tshort[] numItems = new short[1];", "+//\tOS.CountDragItems(theDrag, numItems);", "+//\tint[] flavors = new int[10];", "+//\tint index = -1;", "+//\t//Get a unique list of flavors", "+//\tfor (short i = 0; i < numItems[0]; i++) {", "+//\t\tint[] theItemRef = new int[1];", "+//\t\tOS.GetDragItemReferenceNumber(theDrag, (short) (i+1), theItemRef);", "+//\t\tshort[] numFlavors = new short[1];", "+//\t\tOS.CountDragItemFlavors(theDrag, theItemRef[0], numFlavors);", "+//\t\tint[] theType = new int[1];", "+//\t\tfor (int j = 0; j < numFlavors[0]; j++) {", "+//\t\t\ttheType[0] = 0;", "+//\t\t\tif (OS.GetFlavorType(theDrag, theItemRef[0], (short) (j+1), theType) == OS.noErr) {", "+//\t\t\t\tboolean unique = true;", "+//\t\t\t\tfor (int k = 0; k < flavors.length; k++) {", "+//\t\t\t\t\tif (flavors[k] == theType[0]) {", "+//\t\t\t\t\t\tunique = false;", "+//\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t}", "+//\t\t\t\t}", "+//\t\t\t\tif (unique) {", "+//\t\t\t\t\tif (index == flavors.length - 1) {", "+//\t\t\t\t\t\tint[] temp = new int[flavors.length + 10];", "+//\t\t\t\t\t\tSystem.arraycopy(flavors, 0, temp, 0, flavors.length);", "+//\t\t\t\t\t\tflavors = temp;", "+//\t\t\t\t\t}", "+//\t\t\t\t\tflavors[++index] = theType[0];", "+//\t\t\t\t}", "+//\t\t\t}", "+//\t\t}", "+//\t}", "+//\tif (index == -1) return false;", "+//\t", "+//\tTransferData[] dataTypes = new TransferData[index+1];", "+//\tindex = -1;", "+//\tfor (int i = 0; i < dataTypes.length; i++) {", "+//\t\tif (flavors[i] != 0) {", "+//\t\t\tTransferData data = new TransferData();", "+//\t\t\tdata.type = flavors[i];", "+//\t\t\tfor (int j = 0; j < transferAgents.length; j++) {", "+//\t\t\t\tTransfer transfer = transferAgents[j];", "+//\t\t\t\tif (transfer != null && transfer.isSupportedType(data)) {", "+//\t\t\t\t\tdataTypes[++index] = data;", "+//\t\t\t\t\tbreak;", "+//\t\t\t\t}", "+//\t\t\t}", "+//\t\t}", "+//\t}", "+//\tif (index == -1) return false;", "+//\t", "+//\tif (index < dataTypes.length - 1) {", "+//\t\tTransferData[] temp = new TransferData[index + 1];", "+//\t\tSystem.arraycopy(dataTypes, 0, temp, 0, index + 1);", "+//\t\tdataTypes = temp;", "+//\t}", "+//", "+//\tPoint mouse = new Point();", "+//\tOS.GetDragMouse(theDrag, mouse, null);", "-\t// get allowed operations", "-\tint style = getStyle();", "-\tint[] outActions = new int[1];", "-\tOS.GetDragAllowableActions(theDrag, outActions);", "-\tint operations = osOpToOp(outActions[0]) & style;", "-\tif (operations == DND.DROP_NONE) return false;", "-\t", "-\t//get current operation", "-\tint operation =  getOperationFromKeyState(theDrag);", "-\tkeyOperation = operation;", "-\tif (operation == DND.DROP_DEFAULT) {", "-\t\t if ((style & DND.DROP_DEFAULT) == 0) {", "-\t\t\toperation = (operations & DND.DROP_MOVE) != 0 ? DND.DROP_MOVE : DND.DROP_NONE;", "-\t\t }", "-\t} else {", "-\t\tif ((operation & operations) == 0) operation = DND.DROP_NONE;", "-\t}", "-\t", "-\t// get allowed transfer types", "-\tshort[] numItems = new short[1];", "-\tOS.CountDragItems(theDrag, numItems);", "-\tint[] flavors = new int[10];", "-\tint index = -1;", "-\t//Get a unique list of flavors", "-\tfor (short i = 0; i < numItems[0]; i++) {", "-\t\tint[] theItemRef = new int[1];", "-\t\tOS.GetDragItemReferenceNumber(theDrag, (short) (i+1), theItemRef);", "-\t\tshort[] numFlavors = new short[1];", "-\t\tOS.CountDragItemFlavors(theDrag, theItemRef[0], numFlavors);", "-\t\tint[] theType = new int[1];", "-\t\tfor (int j = 0; j < numFlavors[0]; j++) {", "-\t\t\ttheType[0] = 0;", "-\t\t\tif (OS.GetFlavorType(theDrag, theItemRef[0], (short) (j+1), theType) == OS.noErr) {", "-\t\t\t\tboolean unique = true;", "-\t\t\t\tfor (int k = 0; k < flavors.length; k++) {", "-\t\t\t\t\tif (flavors[k] == theType[0]) {", "-\t\t\t\t\t\tunique = false;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (unique) {", "-\t\t\t\t\tif (index == flavors.length - 1) {", "-\t\t\t\t\t\tint[] temp = new int[flavors.length + 10];", "-\t\t\t\t\t\tSystem.arraycopy(flavors, 0, temp, 0, flavors.length);", "-\t\t\t\t\t\tflavors = temp;", "-\t\t\t\t\t}", "-\t\t\t\t\tflavors[++index] = theType[0];", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "-\tif (index == -1) return false;", "-\t", "-\tTransferData[] dataTypes = new TransferData[index+1];", "-\tindex = -1;", "-\tfor (int i = 0; i < dataTypes.length; i++) {", "-\t\tif (flavors[i] != 0) {", "-\t\t\tTransferData data = new TransferData();", "-\t\t\tdata.type = flavors[i];", "-\t\t\tfor (int j = 0; j < transferAgents.length; j++) {", "-\t\t\t\tTransfer transfer = transferAgents[j];", "-\t\t\t\tif (transfer != null && transfer.isSupportedType(data)) {", "-\t\t\t\t\tdataTypes[++index] = data;", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "-\tif (index == -1) return false;", "-\t", "-\tif (index < dataTypes.length - 1) {", "-\t\tTransferData[] temp = new TransferData[index + 1];", "-\t\tSystem.arraycopy(dataTypes, 0, temp, 0, index + 1);", "-\t\tdataTypes = temp;", "-\t}", "-", "-\tPoint mouse = new Point();", "-\tOS.GetDragMouse(theDrag, mouse, null);", "+\tint operation = DND.DROP_NONE;", "-\tevent.x = mouse.h;", "-\tevent.y = mouse.v;", "+//\tevent.x = mouse.h;", "+//\tevent.y = mouse.v;", "-\tevent.dataTypes = dataTypes;", "-\tevent.dataType = dataTypes[0];", "-\tevent.operations = operations;", "+//\tevent.dataTypes = dataTypes;", "+//\tevent.dataType = dataTypes[0];", "+//\tevent.operations = operations;"]}], "num": 13154}