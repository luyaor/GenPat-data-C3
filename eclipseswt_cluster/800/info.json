{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b654ed4831054a2c8b5c3d57693ee579", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "59c7728d7cd5ba559f181736f1d8b857", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "6b53496cc92d9034cfdb36f5c69cdbfa0683b7e0", "commitAfterChange": "2bcce671a302f3b058ae811a962859b1170d56e7", "methodNumberBeforeChange": 85, "methodNumberAfterChange": 85, "signatureBeforeChange": "  void setDeferResize (boolean defer)", "signatureAfterChange": "  void setDeferResize (boolean defer)", "diff": ["+\t\t\tif (hooks (SWT.MeasureItem) || hooks (SWT.EraseItem) || hooks (SWT.PaintItem)) {", "+\t\t\t\tif (drawCount == 0 && OS.IsWindowVisible (handle)) {", "+\t\t\t\t\tOS.UpdateWindow (handle);", "+\t\t\t\t\tOS.SendMessage (handle, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (hooks (SWT.MeasureItem) || hooks (SWT.EraseItem) || hooks (SWT.PaintItem)) {", "+\t\t\t\tif (drawCount == 0 /*&& OS.IsWindowVisible (handle)*/) {", "+\t\t\t\t\tOS.SendMessage (handle, OS.WM_SETREDRAW, 1, 0);", "+\t\t\t\t\tif (OS.IsWinCE) {", "+\t\t\t\t\t\tOS.InvalidateRect (handle, null, false);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tint flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;", "+\t\t\t\t\t\tOS.RedrawWindow (handle, null, 0, flags);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ffc3fa51e0fc9c47d8c85066fa55f71d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Combo.java", "commitBeforeChange": "fda85eb966fb188eb0abbdbc54e1ae7214c07a98", "commitAfterChange": "1b41a9845a8f4f6b85aa2f3ace4f445454666061", "methodNumberBeforeChange": 72, "methodNumberAfterChange": 72, "signatureBeforeChange": "  LRESULT WM_SIZE (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_SIZE (int wParam, int lParam)", "diff": ["+\t* Bug in Windows.  If the combo box has the CBS_SIMPLE style,", "+\t* the list portion of the combo box is not redrawn when the", "+\t* combo box is resized.  The fix is to force a redraw when", "+\t* the size has changed.", "+\t*/", "+\tif ((style & SWT.SIMPLE) != 0) {", "+\t\tLRESULT result = super.WM_SIZE (wParam, lParam);", "+\t\tif (OS.IsWindowVisible (handle)) {", "+\t\t\tif (OS.IsWinCE) {\t", "+\t\t\t\tint hwndText = OS.GetDlgItem (handle, CBID_EDIT);", "+\t\t\t\tif (hwndText != 0) OS.InvalidateRect (hwndText, null, true);", "+\t\t\t\tint hwndList = OS.GetDlgItem (handle, CBID_LIST);", "+\t\t\t\tif (hwndList != 0) OS.InvalidateRect (hwndList, null, true);", "+\t\t\t} else {", "+\t\t\t\tint uFlags = OS.RDW_ERASE | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;", "+\t\t\t\tOS.RedrawWindow (handle, null, 0, uFlags);", "+\t\t\t}", "+\t\t}", "+\t\treturn result;", "+\t}", "+\t", "+\t/*"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b26da13c84d0b472a302306b5414fe8f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Canvas.java", "commitBeforeChange": "c63ca636edfbea4cd55ccc07da414186be375ce0", "commitAfterChange": "e38d4aec3f79c42ea6666a7a37c026187a8aa6ea", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public void scroll (int destX, int destY, int x, int y, int width, int height, boolean all)", "signatureAfterChange": " public void scroll (int destX, int destY, int x, int y, int width, int height, boolean all)", "diff": ["-\tint flags = OS.SW_INVALIDATE | OS.SW_ERASE;", "-\t/*", "-\t* Feature in Windows.  If any child in the widget tree partially", "-\t* intersects the scrolling rectangle, Windows moves the child", "-\t* and copies the bits that intersect the scrolling rectangle but", "-\t* does not redraw the child.", "-\t* ", "-\t* Feature in Windows.  When any child in the widget tree does not", "-\t* intersect the scrolling rectangle but the parent does intersect,", "-\t* Windows does not move the child.  This is the documented (but", "-\t* strange) Windows behavior.", "-\t* ", "-\t* The fix is to not use SW_SCROLLCHILDREN and move the children", "-\t* explicitly after scrolling.  ", "-\t*/", "-//\tif (all) flags |= OS.SW_SCROLLCHILDREN;", "-\tOS.ScrollWindowEx (handle, deltaX, deltaY, sourceRect, null, 0, null, flags);", "+\tif (backgroundImage != null) {", "+\t\tif (OS.IsWinCE) {", "+\t\t\tOS.InvalidateRect (handle, sourceRect, true);", "+\t\t} else {", "+\t\t\tint flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE;", "+\t\t\tif (all) flags |= OS.RDW_ALLCHILDREN;", "+\t\t\tOS.RedrawWindow (handle, sourceRect, 0, flags);", "+\t\t}", "+\t\tOS.OffsetRect (sourceRect, deltaX, deltaY);", "+\t\tif (OS.IsWinCE) {", "+\t\t\tOS.InvalidateRect (handle, sourceRect, true);", "+\t\t} else {", "+\t\t\tint flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE;", "+\t\t\tif (all) flags |= OS.RDW_ALLCHILDREN;", "+\t\t\tOS.RedrawWindow (handle, sourceRect, 0, flags);", "+\t\t}", "+\t} else {", "+\t\tint flags = OS.SW_INVALIDATE | OS.SW_ERASE;", "+\t\t/*", "+\t\t* Feature in Windows.  If any child in the widget tree partially", "+\t\t* intersects the scrolling rectangle, Windows moves the child", "+\t\t* and copies the bits that intersect the scrolling rectangle but", "+\t\t* does not redraw the child.", "+\t\t* ", "+\t\t* Feature in Windows.  When any child in the widget tree does not", "+\t\t* intersect the scrolling rectangle but the parent does intersect,", "+\t\t* Windows does not move the child.  This is the documented (but", "+\t\t* strange) Windows behavior.", "+\t\t* ", "+\t\t* The fix is to not use SW_SCROLLCHILDREN and move the children", "+\t\t* explicitly after scrolling.  ", "+\t\t*/", "+//\t\tif (all) flags |= OS.SW_SCROLLCHILDREN;", "+\t\tOS.ScrollWindowEx (handle, deltaX, deltaY, sourceRect, null, 0, null, flags);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3375780a9c1d515fff90f201e9564c9c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "de70a0667de50f6f7db613d0fe91d2d42e704047", "commitAfterChange": "16d3df9b450bcf2b246d26812b5f119f6c95deb4", "methodNumberBeforeChange": 98, "methodNumberAfterChange": 98, "signatureBeforeChange": "  boolean setScrollWidth (TableItem item, boolean force)", "signatureAfterChange": "  boolean setScrollWidth (TableItem item, boolean force)", "diff": ["+\t\t\t/*", "+\t\t\t* Feature in Windows.  When LVM_SETCOLUMNWIDTH is sent,", "+\t\t\t* Windows draws right away instead of queuing a WM_PAINT.", "+\t\t\t* This can cause recursive calls when called from paint", "+\t\t\t* or from messages that are retrieving the item data,", "+\t\t\t* such as WM_NOTIFY, causing a stack overflow.  The fix", "+\t\t\t* is to turn off redraw and queue a repaint, collapsing", "+\t\t\t* the recursive calls.", "+\t\t\t*/", "+\t\t\tboolean redraw = drawCount == 0 && OS.IsWindowVisible (handle);", "+\t\t\tif (redraw) OS.DefWindowProc (handle, OS.WM_SETREDRAW, 0, 0);", "+\t\t\tif (redraw) {", "+\t\t\t\tOS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);", "+\t\t\t\tif (OS.IsWinCE) {", "+\t\t\t\t\tint hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);\t", "+\t\t\t\t\tif (hwndHeader != 0) OS.InvalidateRect (hwndHeader, null, true);", "+\t\t\t\t\tOS.InvalidateRect (handle, null, true);", "+\t\t\t\t} else {", "+\t\t\t\t\tint flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;", "+\t\t\t\t\tOS.RedrawWindow (handle, null, 0, flags);", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 800}