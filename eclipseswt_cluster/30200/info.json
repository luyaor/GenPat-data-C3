{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "51a9f36da558c06cea6e0ebcdba59cc7", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e2b4a6979bbf51633e2bafcb75828c7d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "336c640f21f6098f84d6d6682ff7635ddf66f650", "commitAfterChange": "20f32f00170b2b5fe44ce0d2c73eb51efa55207e", "methodNumberBeforeChange": 220, "methodNumberAfterChange": 220, "signatureBeforeChange": "  LRESULT WM_SYSKEYDOWN (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_SYSKEYDOWN (int wParam, int lParam)", "diff": ["-\tif (!OS.IsWinCE) {", "-\t\tif (OS.MapVirtualKey (wParam, 2) != 0) {", "-\t\t\t/*", "-\t\t\t* Feature in Windows.  MapVirtualKey() indicates that", "-\t\t\t* a WM_SYSCHAR message will occur for Alt+Enter but", "-\t\t\t* this message never happens.  The fix is to issue the", "-\t\t\t* event from WM_SYSKEYDOWN and map VK_RETURN to '\\r'.", "-\t\t\t*/", "-\t\t\tif (wParam != OS.VK_RETURN) return null;", "-\t\t\tdisplay.lastAscii = '\\r';", "+\tint mapKey = OS.IsWinCE ? 0 : OS.MapVirtualKey (wParam, 2);", "+\tdisplay.lastVirtual = (mapKey == 0);", "+\tif (display.lastVirtual) {", "+\t \tdisplay.lastKey = wParam;", "+\t\t/*", "+\t\t* Feature in Windows.  The virtual key VK_DELETE is not", "+\t\t* treated as both a virtual key and an ASCII key by Windows.", "+\t\t* Therefore, we will not receive a WM_CHAR for this key.", "+\t\t* The fix is to treat VK_DELETE as a special case and map", "+\t\t* the ASCII value explictly (Delete is 0x7F).", "+\t\t*/", "+\t\tif (display.lastKey == OS.VK_DELETE) {", "+\t\t\tdisplay.lastVirtual = false;", "+\t\t\tdisplay.lastKey = display.lastAscii = 0x7F;", "+", "+\t\t/*", "+\t\t* It is possible to get a WM_CHAR for a virtual key when", "+\t\t* Num Lock is on.  If the user types Home while Num Lock ", "+\t\t* is down, a WM_CHAR is issued with WPARM=55 (for the", "+\t\t* character 7).  If we are going to get a WM_CHAR we need", "+\t\t* to ensure that the last key has the correct value.  Note", "+\t\t* that Ctrl+Home does not issue a WM_CHAR when Num Lock is", "+\t\t* down.", "+\t\t* ", "+\t\t* NOTE: This only happens on Windows 98.", "+\t\t*/", "+\t\tif (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {", "+\t\t\tif (display.asciiKey (display.lastKey) != 0) return null;", "+\t\t\tdisplay.lastAscii = display.numpadKey (display.lastKey);", "+\t\t}", "+\t} else {", "+\t\t/*", "+\t\t* Convert LastKey to lower case because Windows non-virtual", "+\t\t* keys that are also ASCII keys, such as like VK_A, are have", "+\t\t* upper case values in WM_KEYDOWN despite the fact that the ", "+\t\t* Shift was not pressed.", "+\t\t*/", "+\t \tdisplay.lastKey = OS.CharLower ((short) mapKey);", "+", "+\t\t/*", "+\t\t* Feature in Windows 98.  MapVirtualKey() indicates that", "+\t\t* a WM_SYSCHAR message will occur for Alt+Enter but", "+\t\t* this message never happens.  The fix is to issue the", "+\t\t* event from WM_SYSKEYDOWN and map VK_RETURN to '\\r'.", "+\t\t*/", "+\t\tif (OS.IsWinNT) return null;", "+\t\tif (wParam != OS.VK_RETURN) return null;", "+\t\tdisplay.lastAscii = '\\r';", "-\tdisplay.lastKey = wParam;", "-\tdisplay.lastVirtual = true;", "-\t\t", "-\t/*", "-\t* Feature in Windows.  The virtual key VK_DELETE is not", "-\t* treated as both a virtual key and an ASCII key by Windows.", "-\t* Therefore, we will not receive a WM_CHAR for this key.", "-\t* The fix is to treat VK_DELETE as a special case and map", "-\t* the ASCII value explictly (Delete is 0x7F).", "-\t*/", "-\tif (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;", "-\t", "-\t/*", "-\t* It is possible to get a WM_CHAR for a virtual key when", "-\t* Num Lock is on.  If the user types Home while Num Lock ", "-\t* is down, a WM_CHAR is issued with WPARM=55 (for the", "-\t* character 7).  If we are going to get a WM_CHAR we need", "-\t* to ensure that the last key has the correct value.  Note", "-\t* that Ctrl+Home does not issue a WM_CHAR when Num Lock is", "-\t* down.", "-\t*/", "-\tif (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {", "-\t\tif (display.asciiKey (display.lastKey) != 0) return null;", "-\t}", "-\t", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2db8c6ebabe2e0b3541a03a8b145827c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "336c640f21f6098f84d6d6682ff7635ddf66f650", "commitAfterChange": "20f32f00170b2b5fe44ce0d2c73eb51efa55207e", "methodNumberBeforeChange": 176, "methodNumberAfterChange": 176, "signatureBeforeChange": "  LRESULT WM_KEYDOWN (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_KEYDOWN (int wParam, int lParam)", "diff": ["-\t\tfor (int i=0; i<ACCENTS.length; i++) {", "-\t\t\tint value = OS.VkKeyScan (ACCENTS [i]);", "-\t\t\tif ((value & 0xFF) == wParam && (value & 0x600) == 0x600) {", "-\t\t\t\treturn null;", "+\t\tif (OS.GetKeyState (OS.VK_CONTROL) < 0 && OS.GetKeyState (OS.VK_MENU) < 0) {", "+\t\t\tfor (int i=0; i<ACCENTS.length; i++) {", "+\t\t\t\tint value = OS.VkKeyScan (ACCENTS [i]);", "+\t\t\t\tif ((value & 0xFF) == wParam && (value & 0x600) == 0x600) {", "+\t\t\t\t\tdisplay.lastVirtual = (mapKey == 0);", "+\t\t\t\t\tdisplay.lastKey = display.lastVirtual ? wParam : mapKey;", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "-\tdisplay.lastKey = wParam;", "+\t\tdisplay.lastKey = wParam;", "-\t\tif (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;", "+\t\tif (display.lastKey == OS.VK_DELETE) {", "+\t\t\tdisplay.lastVirtual = false;", "+\t\t\tdisplay.lastKey = display.lastAscii = 0x7F;", "+\t\t}", "+", "+\t\t* ", "+\t\t* NOTE: This only happens on Windows 98.", "-\t\t* Get the shifted state or convert to lower case if necessary.", "-\t\t* If the user types Ctrl+A, LastKey should be 'a', not 'A'.  If", "-\t\t* the user types Ctrl+Shift+A, LastKey should be 'A'.  If the user ", "-\t\t* types Ctrl+Shift+6, the value of LastKey will depend on the ", "-\t\t* international keyboard.", "+\t\t* Convert LastKey to lower case because Windows non-virtual", "+\t\t* keys that are also ASCII keys, such as like VK_A, are have", "+\t\t* upper case values in WM_KEYDOWN despite the fact that the ", "+\t\t* Shift was not pressed.", "-\t \tif (OS.GetKeyState (OS.VK_SHIFT) < 0) {", "-\t\t\tdisplay.lastKey = display.shiftedKey (display.lastKey);", "-\t\t\tif (display.lastKey == 0) display.lastKey = wParam;", "-\t \t} else {", "-\t \t\tdisplay.lastKey = OS.CharLower ((short) mapKey);", "-\t \t}", "+\t \tdisplay.lastKey = OS.CharLower ((short) mapKey);", "+", "-\t\t\t* To avoid the extra SWT.KeyDown, look for VK_SPACE and", "+\t\t\t* To avoid the extra SWT.KeyDown, look for a space and", "-\t\t\tif (asciiKey == OS.VK_SPACE) {", "-\t\t\t\tdisplay.lastVirtual = true;", "-\t\t\t\treturn null;", "-\t\t\t}", "+\t\t\tif (asciiKey == 0x32) return null;", "-\t\t}", "-\t\t\t", "-\t\t/*", "-\t\t* If the control key is not down at this point, then", "-\t\t* the key that was pressed was an accent key.  In that", "-\t\t* case, do not issue the key down event.", "-\t\t*/", "-\t\tif (OS.GetKeyState (OS.VK_CONTROL) >= 0) {", "-\t\t\tdisplay.lastKey = 0;", "-\t\t\treturn null;", "-\t\t* Virtual keys such as VK_RETURN are both virtual and ASCII keys.", "-\t\t* Normally, these are marked virtual in WM_CHAR.  Since we will not", "-\t\t* be getting a WM_CHAR for the key at this point, we need to test", "-\t\t* LastKey to see if it is virtual.  This happens when the user types", "-\t\t* Ctrl+Tab.", "+\t\t* If the control key is not down at this point, then", "+\t\t* the key that was pressed was an accent key or a regular", "+\t\t* key such as 'A' or Shift+A.  In that case, issue the", "+\t\t* key event from WM_CHAR.", "-\t\tdisplay.lastVirtual = display.isVirtualKey (wParam);", "-\t\tdisplay.lastAscii = display.controlKey (display.lastKey);", "-\t\tdisplay.lastNull = display.lastAscii == 0 && display.lastKey == '@';", "+\t\tif (OS.GetKeyState (OS.VK_CONTROL) >= 0) return null;", "+\t\t", "+\t\t/*", "+\t\t* Get the shifted state or convert to lower case if necessary.", "+\t\t* If the user types Ctrl+A, LastAscii should be 'a', not 'A'. ", "+\t\t* If the user types Ctrl+Shift+A, LastAscii should be 'A'.", "+\t\t* If the user types Ctrl+Shift+6, the value of LastAscii will", "+\t\t* depend on the international keyboard.", "+\t\t*/", "+\t \tif (OS.GetKeyState (OS.VK_SHIFT) < 0) {", "+\t\t\tdisplay.lastAscii = display.shiftedKey (wParam);", "+\t\t\tif (display.lastAscii == 0) display.lastAscii = mapKey;", "+\t \t} else {", "+\t \t\tdisplay.lastAscii = OS.CharLower ((short) mapKey);", "+\t \t}", "+\t \t\t\t", "+\t\t/* Note that Ctrl+'@' is ASCII NUL and is delivered in WM_CHAR */", "+\t\tif (display.lastAscii == '@') return null;", "+\t\tdisplay.lastAscii = display.controlKey (display.lastAscii);"]}], "num": 30200}