{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "98edae2f871f5aab942d824fc7850ec6", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "704d45c71c45bc18ce70ee79a831459c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Scrollable.java", "commitBeforeChange": "c5d7cc4240fdb43b5db86ec80dd549bc69490b91", "commitAfterChange": "99d694cafa531b87692a37a5ea121c8455a1f639", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  int kEventMouseWheelMoved (int nextHandler, int theEvent, int userData)", "signatureAfterChange": "  int kEventMouseWheelMoved (int nextHandler, int theEvent, int userData)", "diff": ["-\tint result = super.kEventMouseWheelMoved (nextHandler, theEvent, userData);", "-\tif (result == OS.noErr) return result;", "-\tif ((state & CANVAS) != 0) {", "-\t\tshort [] wheelAxis = new short [1];", "-\t\tOS.GetEventParameter (theEvent, OS.kEventParamMouseWheelAxis, OS.typeMouseWheelAxis, null, 2, null, wheelAxis);", "-\t\tScrollBar bar = wheelAxis [0] == OS.kEventMouseWheelAxisX ? horizontalBar : verticalBar;", "-\t\tif (bar != null && bar.getVisible ()) {", "-\t\t\tint [] wheelDelta = new int [1];", "-\t\t\tOS.GetEventParameter (theEvent, OS.kEventParamMouseWheelDelta, OS.typeSInt32, null, 4, null, wheelDelta);", "-\t\t\tbar.setSelection (Math.max (0, bar.getSelection () - bar.getIncrement () * wheelDelta [0]));", "-\t\t\tEvent event = new Event ();", "-\t\t    event.detail = wheelDelta [0] > 0 ? SWT.PAGE_UP : SWT.PAGE_DOWN;\t", "-\t\t\tbar.sendEvent (SWT.Selection, event);", "-//\t\t\tDisplay display = getDisplay ();", "-//\t\t\tdisplay.update ();", "-\t\t\tupdate ();", "-\t\t}", "-\t\t/*", "-\t\t* Feature in the Macintosh.   For some reason, when eventNotHandledErr", "-\t\t* is returned from kEventMouseWheelMoved the event is sent twiced to", "-\t\t* the same control with the same mouse wheel data.  The fix is to return", "-\t\t* noErr to stop further event processing.", "-\t\t*/", "-\t\treturn OS.noErr;", "-\t}", "-\tresult = OS.CallNextEventHandler (nextHandler, theEvent);", "+\tint result = super.kEventMouseWheelMoved (nextHandler, theEvent, userData);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b89c38bb6d438be04e85be0de665e31a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "c5d7cc4240fdb43b5db86ec80dd549bc69490b91", "commitAfterChange": "99d694cafa531b87692a37a5ea121c8455a1f639", "methodNumberBeforeChange": 79, "methodNumberAfterChange": 79, "signatureBeforeChange": "  int kEventMouseWheelMoved (int nextHandler, int theEvent, int userData)", "signatureAfterChange": "  int kEventMouseWheelMoved (int nextHandler, int theEvent, int userData)", "diff": ["-\tint result = super.kEventMouseWheelMoved (nextHandler, theEvent, userData);", "-\tif (result == OS.noErr) return result;", "+\tif ((state & IGNORE_WHEEL) != 0) return OS.eventNotHandledErr;", "+\tshort [] wheelAxis = new short [1];", "+\tOS.GetEventParameter (theEvent, OS.kEventParamMouseWheelAxis, OS.typeMouseWheelAxis, null, 2, null, wheelAxis);", "-\tif (!sendMouseEvent (SWT.MouseWheel, (short) 0, wheelDelta [0], SWT.SCROLL_LINE, true, theEvent)) {", "-\t\treturn OS.noErr;", "+\tShell shell = getShell ();", "+\tControl control = this;", "+\twhile (control != null) {", "+\t\tif (!control.sendMouseEvent (SWT.MouseWheel, (short) 0, wheelDelta [0], SWT.SCROLL_LINE, true, theEvent)) {", "+\t\t\tbreak;", "+\t\t}", "+\t\tif (control.sendMouseWheel (wheelAxis [0], wheelDelta [0])) {", "+\t\t\tbreak;", "+\t\t}", "+\t\tif (control == this) {", "+\t\t\t/*", "+\t\t\t* Feature in the Macintosh.  For some reason, the kEventMouseWheelMoved", "+\t\t\t* event is sent twice to each application handler with the same mouse wheel", "+\t\t\t* data.  The fix is to set an ignore flag before calling the next handler ", "+\t\t\t* in the handler chain.", "+\t\t\t*/", "+\t\t\tstate |= IGNORE_WHEEL;", "+\t\t\tint result = OS.CallNextEventHandler(nextHandler, theEvent);", "+\t\t\tstate &= ~IGNORE_WHEEL;", "+\t\t\tif (result == OS.noErr) break;", "+\t\t}", "+\t\tif (control == shell) break;", "+\t\tcontrol = control.parent;", "-\treturn OS.eventNotHandledErr;", "+\treturn OS.noErr;"]}], "num": 12321}