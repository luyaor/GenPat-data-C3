{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8f345e15349e43094e177315899cb4df", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dee4be2fccb96b05338275401b130e2e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/common/org/eclipse/swt/internal/image/GIFFileFormat.java", "commitBeforeChange": "553d7364f85189cde07e065aaa5ba7380f0c1418", "commitAfterChange": "ff32f7578b312ab2cf7bee31c19161e45b3b344c", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tvoid unloadIntoByteStream(ImageData image)", "signatureAfterChange": "  \tvoid unloadIntoByteStream(ImageLoader loader)", "diff": ["-\t */", "-\tvoid unloadIntoByteStream(ImageData image) {", "-\t\tif (!((image.depth == 1) || (image.depth == 4) || (image.depth == 8))) {", "+\tvoid unloadIntoByteStream(ImageLoader loader) {", "+\t\t", "+ \t\t/* Step 1: Acquire GIF parameters */", "+\t\tImageData[] data = loader.data;", "+\t\tint frameCount = data.length;", "+\t\tboolean multi = frameCount > 1;", "+\t\tImageData firstImage = data[0];", "+\t\tint logicalScreenWidth = multi ? loader.logicalScreenWidth : firstImage.width;", "+\t\tint logicalScreenHeight = multi ? loader.logicalScreenHeight : firstImage.height;", "+\t\tint backgroundPixel = loader.backgroundPixel;", "+\t\tint depth = firstImage.depth;", "+\t\tPaletteData palette = firstImage.palette;", "+\t\tRGB[] colors = palette.getRGBs();", "+\t\tshort globalTable = 1;", "+\t\t\t\t", "+\t\t/* Step 2: Check for validity and global/local color map */", "+\t\tif (!(depth == 1 || depth == 4 || depth == 8)) {", "-\t\tbyte bitField = (byte)((0x80 & 0xF8 & 0xF7 & 0x8F) + (image.depth - 1) + ((image.depth - 1) * 16));", "+\t\tfor (int i=0; i<frameCount; i++) {", "+\t\t\tif (data[i].palette.isDirect) {", "+\t\t\t\tSWT.error(SWT.ERROR_INVALID_IMAGE);", "+\t\t\t}", "+\t\t\tif (multi) {", "+\t\t\t\tif (!(data[i].height <= logicalScreenHeight && data[i].width <= logicalScreenWidth && data[i].depth == depth)) {", "+\t\t\t\t\tSWT.error(SWT.ERROR_INVALID_IMAGE);", "+\t\t\t\t}", "+\t\t\t\tif (globalTable == 1) {", "+\t\t\t\t\tRGB rgbs[] = data[i].palette.getRGBs();", "+\t\t\t\t\tif (rgbs.length != colors.length) {", "+\t\t\t\t\t\tglobalTable = 0;", "+\t\t\t\t\t} else { ", "+\t\t\t\t\t\tfor (int j=0; j<colors.length; j++) {", "+\t\t\t\t\t\t\tif (!(rgbs[j].red == colors[j].red &&", "+\t\t\t\t\t\t\t\trgbs[j].green == colors[j].green &&", "+\t\t\t\t\t\t\t\trgbs[j].blue == colors[j].blue))", "+\t\t\t\t\t\t\t\t\tglobalTable = 0;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t", "-\t\t\toutputStream.write(new byte[] { (byte)'G', (byte)'I', (byte)'F' });", "-\t\t\toutputStream.write(new byte[] { (byte)'8', (byte)'9', (byte)'a' });", "-\t\t\toutputStream.writeShort((short)image.width);", "-\t\t\toutputStream.writeShort((short)image.height);", "-\t\t\toutputStream.writeByte(bitField);", "-\t\t\toutputStream.writeByte((byte)0);", "+ \t\t\t/* Step 3: Write the GIF89a Header and Logical Screen Descriptor */", "+\t\t\tint bits = globalTable*128 + (depth-1)*16 + depth-1;", "+\t\t\toutputStream.write(\"GIF89a\".getBytes());", "+\t\t\toutputStream.writeShort((short)logicalScreenWidth);", "+\t\t\toutputStream.writeShort((short)logicalScreenHeight);", "+\t\t\toutputStream.writeByte((byte)bits);", "+\t\t\toutputStream.writeByte((byte)backgroundPixel);", "-\t\twritePalette(image.palette, image.depth);", "-\t\tif (image.transparentPixel != -1 || image.disposalMethod != 0 || image.delayTime != 0) {", "-\t\t\twriteGraphicsControlBlock(image);", "+\t\t", "+\t\t/* Step 4: Write Global Color Table if applicable */", "+\t\tif (globalTable == 1) {", "+\t\t\twritePalette(palette, depth);", "-\t\twriteImageBlock(image);", "+", "+\t\t/* Step 5: Write Application Extension if applicable */", "+\t\tif (multi) {", "+\t\t\tint repeatCount = loader.repeatCount;", "+\t\t\ttry {", "+\t\t\t\toutputStream.write(GIF_EXTENSION_BLOCK_ID);", "+\t\t\t\toutputStream.write(GIF_APPLICATION_EXTENSION_BLOCK_ID);", "+\t\t\t\toutputStream.write((byte)11); // Eleven bytes following", "+\t\t\t\toutputStream.write(\"NETSCAPE2.0\".getBytes());", "+\t\t\t\toutputStream.write((byte)3); // Three bytes following", "+\t\t\t\toutputStream.writeByte((byte)1);", "+\t\t\t\toutputStream.write((byte) repeatCount & 0xFF);", "+\t\t\t\toutputStream.write((byte) (repeatCount >> 8) & 0xFF);", "+\t\t\t\toutputStream.writeByte((byte)0);", "+\t\t\t} catch (IOException e) {", "+\t\t\t\tSWT.error(SWT.ERROR_IO, e);", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\tfor (int frame=0; frame<frameCount; frame++) {", "+\t\t\t", "+\t\t\t/* Step 6: Write Graphics Control Block for each frame if applicable */", "+\t\t\tif (multi || data[frame].transparentPixel != -1) {", "+\t\t\t\twriteGraphicsControlBlock(data[frame]);", "+\t\t\t}", "+\t\t\t", "+\t\t\t/* Step 7: Write Image Header for each frame */", "+\t\t\tint x = data[frame].x;", "+\t\t\tint y = data[frame].y;", "+\t\t\tint width = data[frame].width;", "+\t\t\tint height = data[frame].height;", "+\t\t\ttry {", "+\t\t\t\toutputStream.write(GIF_IMAGE_BLOCK_ID);  // 0x2C", "+\t\t\t\tbyte[] block = new byte[9];", "+\t\t\t\tblock[0] = (byte)(x & 0xFF);", "+\t\t\t\tblock[1] = (byte)((x >> 8) & 0xFF);", "+\t\t\t\tblock[2] = (byte)(y & 0xFF);", "+\t\t\t\tblock[3] = (byte)((y >> 8) & 0xFF);", "+\t\t\t\tblock[4] = (byte)(width & 0xFF);", "+\t\t\t\tblock[5] = (byte)((width >> 8) & 0xFF);", "+\t\t\t\tblock[6] = (byte)(height & 0xFF);", "+\t\t\t\tblock[7] = (byte)((height >> 8) & 0xFF); ", "+\t\t\t\tblock[8] = (byte)(globalTable == 0 ? (depth-1) | 0x80 : 0x00);", "+\t\t\t\toutputStream.write(block);", "+\t\t\t} catch (IOException e) {", "+\t\t\t\tSWT.error(SWT.ERROR_IO, e);", "+\t\t\t}", "+\t\t\t", "+\t\t\t/* Step 8: Write Local Color Table for each frame if applicable */", "+\t\t\tif (globalTable == 0) {", "+\t\t\t\twritePalette(data[frame].palette, depth);", "+\t\t\t}", "+\t\t\t", "+\t\t\t/* Step 9: Write the actual data for each frame */", "+\t\t\ttry {", "+\t\t\t\toutputStream.write(depth); // minimum LZW Code size: 3 for 1 bit per pixel images and usually the number of bits per pixel plus 1 for other images.", "+\t\t\t} catch (IOException e) {", "+\t\t\t\tSWT.error(SWT.ERROR_IO, e);", "+\t\t\t}", "+\t\t\tnew LZWCodec().encode(outputStream, data[frame]);", "+\t\t}", "+", "+\t\t/* Step 10: Write GIF terminator */"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "926a784cbc4dce204abc7ce59c9043ba", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/common/org/eclipse/swt/internal/image/GIFFileFormat.java", "commitBeforeChange": "efa84085d4ec834e01920f92984f315998014d40", "commitAfterChange": "c989cfe52010cda6d22ffb748bab994a6c259406", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  \tvoid unloadIntoByteStream(ImageLoader loader)", "signatureAfterChange": "  \tvoid unloadIntoByteStream(ImageLoader loader)", "diff": ["- \t\t/* Step 1: Acquire GIF parameters */", "+ \t\t/* Step 1: Acquire GIF parameters. */", "-\t\t/* Step 2: Check for validity and global/local color map */", "+\t\t/* Step 2: Check for validity and global/local color map. */", "- \t\t\t/* Step 3: Write the GIF89a Header and Logical Screen Descriptor */", "-\t\t\tint bits = globalTable*128 + (depth-1)*16 + depth-1;", "-\t\t\toutputStream.write(\"GIF89a\".getBytes());", "+ \t\t\t/* Step 3: Write the GIF89a Header and Logical Screen Descriptor. */", "+\t\t\toutputStream.write(GIF89a);", "+\t\t\tint bitField = globalTable*128 + (depth-1)*16 + depth-1;", "-\t\t\toutputStream.writeByte((byte)bits);", "+\t\t\toutputStream.writeByte((byte)bitField);", "-\t\t\toutputStream.writeByte((byte)0);", "+\t\t\toutputStream.writeByte((byte)0); // Aspect ratio is 1:1", "-\t\t/* Step 4: Write Global Color Table if applicable */", "+\t\t/* Step 4: Write Global Color Table if applicable. */", "-\t\t/* Step 5: Write Application Extension if applicable */", "+\t\t/* Step 5: Write Application Extension if applicable. */", "-\t\t\t\toutputStream.write((byte)11); // Eleven bytes following", "-\t\t\t\toutputStream.write(\"NETSCAPE2.0\".getBytes());", "-\t\t\t\toutputStream.write((byte)3); // Three bytes following", "-\t\t\t\toutputStream.writeByte((byte)1);", "-\t\t\t\toutputStream.write((byte) repeatCount & 0xFF);", "-\t\t\t\toutputStream.write((byte) (repeatCount >> 8) & 0xFF);", "-\t\t\t\toutputStream.writeByte((byte)0);", "+\t\t\t\toutputStream.writeByte((byte)NETSCAPE2_0.length);", "+\t\t\t\toutputStream.write(NETSCAPE2_0);", "+\t\t\t\toutputStream.writeByte((byte)3); // Three bytes follow", "+\t\t\t\toutputStream.writeByte((byte)1); // Extension type", "+\t\t\t\toutputStream.writeShort((short) repeatCount);", "+\t\t\t\toutputStream.writeByte((byte)0); // Block terminator", "-\t\t\t/* Step 6: Write Graphics Control Block for each frame if applicable */", "+\t\t\t/* Step 6: Write Graphics Control Block for each frame if applicable. */", "-\t\t\t/* Step 7: Write Image Header for each frame */", "+\t\t\t/* Step 7: Write Image Header for each frame. */", "-\t\t\t\toutputStream.write(GIF_IMAGE_BLOCK_ID);  // 0x2C", "+\t\t\t\toutputStream.write(GIF_IMAGE_BLOCK_ID);", "-\t\t\t/* Step 8: Write Local Color Table for each frame if applicable */", "+\t\t\t/* Step 8: Write Local Color Table for each frame if applicable. */", "-\t\t\t/* Step 9: Write the actual data for each frame */", "+\t\t\t/* Step 9: Write the actual data for each frame. */", "-\t\t\t\toutputStream.write(depth); // minimum LZW Code size: 3 for 1 bit per pixel images and usually the number of bits per pixel plus 1 for other images.", "+\t\t\t\toutputStream.write(depth); // Minimum LZW Code size", "-\t\t/* Step 10: Write GIF terminator */", "+\t\t/* Step 10: Write GIF terminator. */"]}], "num": 29585}