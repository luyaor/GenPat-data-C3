{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a960960e84cae3c25d48b8baa78bb49b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f9398b2368aa141fbe1764a103a3767", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "cc7a79cec8920b1b6175a6c2124e7f63a3823262", "commitAfterChange": "d8f34c9ec09bc11f5d7b71293f9d378725f3146c", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 10, "signatureBeforeChange": "  void createHandle (int index)", "signatureAfterChange": "  void createHandle (int index)", "diff": ["+", "-\t/*", "-\t* Columns:", "-\t* 0 - text", "-\t* 1 - pixmap", "-\t* 2 - foreground", "-\t* 3 - background", "-\t* 4 - font", "-\t* 5 - id", "-\t* 6 - checked (if needed)", "-\t* 7 - grayed (if needed)", "-\t*/", "-\tint /*long*/ [] types = new int /*long*/ [(style & SWT.CHECK) !=0 ? 8 : 6];", "-\ttypes [TEXT_COLUMN] = OS.G_TYPE_STRING ();", "-\ttypes [PIXBUF_COLUMN] = OS.GDK_TYPE_PIXBUF ();", "-\ttypes [FOREGROUND_COLUMN] = OS.GDK_TYPE_COLOR ();", "-\ttypes [BACKGROUND_COLUMN] = OS.GDK_TYPE_COLOR ();", "-\ttypes [FONT_COLUMN] = OS.PANGO_TYPE_FONT_DESCRIPTION ();", "-\ttypes [ID_COLUMN] = OS.G_TYPE_INT ();", "-\tif ((style & SWT.CHECK) != 0) {", "-\t\ttypes [CHECKED_COLUMN] = OS.G_TYPE_BOOLEAN (); ", "-\t\ttypes [GRAYED_COLUMN] = OS.G_TYPE_BOOLEAN ();", "-\t} ", "+\tint /*long*/ [] types = getColumnTypes (1);", "-\t", "-\t/*", "-\t* Bug in ATK. For some reason, ATK segments fault if ", "-\t* the GtkTreeView has a column and does not have items.", "-\t* The fix is to insert the column only when an item is ", "-\t* created.", "-\t*/", "-\tcolumnHandle = OS.gtk_tree_view_column_new ();", "-\tif (columnHandle == 0) error (SWT.ERROR_NO_HANDLES);", "-\tOS.g_object_ref (columnHandle);", "-\t", "-\t\tOS.gtk_tree_view_column_pack_start (columnHandle, checkRenderer, false);", "-\t\tOS.gtk_tree_view_column_add_attribute (columnHandle, checkRenderer, OS.active, CHECKED_COLUMN);", "-", "-\t\t/*", "-\t\t* Feature in GTK. The inconsistent property only exists in GTK 2.2.x.", "-\t\t*/", "-\t\tif (OS.GTK_VERSION >= OS.VERSION (2, 2, 0)) {", "-\t\t\tOS.gtk_tree_view_column_add_attribute (columnHandle, checkRenderer, OS.inconsistent, GRAYED_COLUMN);", "-\t\t}", "+\t\tOS.g_object_ref (checkRenderer);", "-\tpixbufRenderer = OS.gtk_cell_renderer_pixbuf_new ();", "-\tif (pixbufRenderer == 0) error (SWT.ERROR_NO_HANDLES);", "-\tOS.gtk_tree_view_column_pack_start (columnHandle, pixbufRenderer, false);", "-\tOS.gtk_tree_view_column_add_attribute (columnHandle, pixbufRenderer, OS.pixbuf, PIXBUF_COLUMN);", "-\t/*", "-\t* Feature on GTK.  When a tree view column contains only one activatable", "-\t* cell renderer such as a toggle renderer, mouse clicks anywhere in a cell", "-\t* activate that renderer. The workaround is to set a second  cell renderer", "-\t* to be activatable.", "-\t*/", "-\tif ((style & SWT.CHECK) != 0) {", "-\t\tOS.g_object_set (pixbufRenderer, OS.mode, OS.GTK_CELL_RENDERER_MODE_ACTIVATABLE, 0);", "-\t}", "-\ttextRenderer = OS.gtk_cell_renderer_text_new ();", "-\tif (textRenderer == 0) error (SWT.ERROR_NO_HANDLES);", "-\tOS.gtk_tree_view_column_pack_start (columnHandle, textRenderer, true);", "-\tOS.gtk_tree_view_column_add_attribute (columnHandle, textRenderer, OS.text, TEXT_COLUMN);", "-\tOS.gtk_tree_view_column_add_attribute (columnHandle, textRenderer, OS.foreground_gdk, FOREGROUND_COLUMN);", "-\t", "-\t/*", "-\t * Bug on GTK. Gtk renders the background of the text renderer on top of the pixbuf renderer.", "-\t * This only happens in version 2.2.1 and earlier. The fix is not to set the background.   ", "-\t */", "-\tif (OS.GTK_VERSION > OS.VERSION (2, 2, 1)) {", "-\t\tOS.gtk_tree_view_column_add_attribute (columnHandle, textRenderer, OS.background_gdk, BACKGROUND_COLUMN);", "-\t}", "-\tOS.gtk_tree_view_column_add_attribute (columnHandle, textRenderer, OS.font_desc, FONT_COLUMN);", "+\tcreateColumn (null, 0);", "+\tif ((style & SWT.VIRTUAL) != 0) {", "+\t\t/*", "+\t\t* Feature in GTK. The fixed_height_mode property only exists in GTK 2.3.2 and greater.", "+\t\t*/", "+\t\tif (OS.GTK_VERSION >= OS.VERSION (2, 3, 2)) {", "+\t\t\tOS.g_object_set (handle, OS.fixed_height_mode, true, 0);", "+\t\t}", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "900e8bf5bd146ccf0d280553a2398d02", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "b8ad17c3d19acc6d7f92ed55bd627bbaa4689df8", "commitAfterChange": "77d858e5c6ed3ebe8fa843c1bb721ed789ee186a", "methodNumberBeforeChange": 103, "methodNumberAfterChange": 103, "signatureBeforeChange": "  void rendererRender (long cell, long cr, long window, long widget, long background_area, long cell_area, long expose_area, long flags)", "signatureAfterChange": "  void rendererRender (long cell, long cr, long window, long widget, long background_area, long cell_area, long expose_area, long flags)", "diff": ["-\t\t\t\t\t\t\tCairo.cairo_reset_clip (cr);", "+\t\t\t\t\t\t\tif (!OS.GTK3) {", "+\t\t\t\t\t\t\t\tCairo.cairo_reset_clip (cr);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t// GTK >= 3.10 sends a cairo for the window of the tree widget, but not for for the bin window.", "-\t\t\t\t\t// Besides, GTK 3.10 >= uses the same cairo for all the tree's children. SWT invalidates the cairo.", "-\t\t\t\t\t// The fix is to create a new cairo.", "-\t\t\t\t\tif (OS.GTK_VERSION >= OS.VERSION(3, 9, 0)) {", "-\t\t\t\t\t\t// A temporary fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=427480", "-\t\t\t\t\t\t// Force native painting", "-//\t\t\t\t\t\tif (window == 0) {", "-//\t\t\t\t\t\t\twindow = OS.gtk_widget_get_window(handle);", "-//\t\t\t\t\t\t}", "-//\t\t\t\t\t\tif (window != 0) {", "-//\t\t\t\t\t\t\tGdkRectangle r = new GdkRectangle();", "-//\t\t\t\t\t\t\tOS.gdk_cairo_get_clip_rectangle(cr, r);", "-//\t\t\t\t\t\t\tdrawBackground (control, window, 0, 0, rect.x, r.y, r.width, r.height);", "-//\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "+\t\t\t\t\tif (!OS.GTK3) {", "-\t\t\t\tif (OS.GTK_VERSION >= OS.VERSION(3, 9, 0)) {", "+\t\t\t\tif (OS.GTK3){", "-\t\t\t\t\tgcData.cairo = OS.gdk_cairo_create(OS.gtk_widget_get_window(handle));", "+\t\t\t\t\tgcData.cairo = cr;", "-\t\t\t\t// Since we create a new cairo, we have to clip it", "-\t\t\t\tif (OS.GTK_VERSION >= OS.VERSION(3, 9, 0) && cr != 0) {", "-\t\t\t\t\tGdkRectangle r = new GdkRectangle();", "-\t\t\t\t\tOS.gdk_cairo_get_clip_rectangle(cr, r);", "-\t\t\t\t\tgc.setClipping(rect.x, r.y, r.width, r.height);", "-\t\t\t\t} else {", "+", "+\t\t\t\tif (!OS.GTK3) {", "-\t\t\t\tif (OS.GTK_VERSION >= OS.VERSION(3, 9, 0)) {", "+\t\t\t\tif (OS.GTK3) {", "-\t\t\t\t\tif (OS.GTK3) {", "-\t\t\t\t\t if (OS.GTK_VERSION < OS.VERSION(3, 9, 0)) {", "-\t\t\t\t\t\t// GTK >= 3.10 creates a different background if we use this code", "-\t\t\t\t\t\tCairo.cairo_save (cr);", "-\t\t\t\t\t\tCairo.cairo_reset_clip (cr);", "-\t\t\t\t\t\tlong /*int*/ context = OS.gtk_widget_get_style_context (widget);", "-\t\t\t\t\t\tOS.gtk_style_context_save (context);", "-\t\t\t\t\t\tOS.gtk_style_context_add_class (context, OS.GTK_STYLE_CLASS_CELL);", "-\t\t\t\t\t\tOS.gtk_style_context_set_state (context, OS.GTK_STATE_FLAG_SELECTED);", "-\t\t\t\t\t\tOS.gtk_render_background(context, cr, rect.x, rect.y, rect.width, rect.height);", "-\t\t\t\t\t\tOS.gtk_style_context_restore (context);", "-\t\t\t\t\t\tCairo.cairo_restore (cr);", "-\t\t\t\t\t }", "-\t\t\t\t\t} else {", "+\t\t\t\t\tif (!OS.GTK3) {", "-\t\tGC gc = new GC (this);", "+", "+\t\tGC gc;", "+\t\tif (OS.GTK3){", "+\t\t\tGCData gcData = new GCData();", "+\t\t\tgcData.cairo = cr;", "+\t\t\tgc = GC.gtk_new(this, gcData );", "+\t\t} else {", "+\t\t\tgc = new GC (this);", "+\t\t}", "-\t\t\t\t// GTK >= 3.10 sends a cairo for the window of the tree widget, but not for for the bin window.", "-\t\t\t\t// Besides, GTK >= 3.10 uses the same cairo for all the tree's children. SWT invalidates the cairo.", "-\t\t\t\t// The fix is to create a new cairo.", "-\t\t\t\tif (OS.GTK_VERSION >= OS.VERSION(3, 9, 0)) {", "+\t\t\t\tif (OS.GTK3){", "-\t\t\t\t\tgcData.cairo = OS.gdk_cairo_create(OS.gtk_widget_get_window(handle));", "+\t\t\t\t\tgcData.cairo = cr;", "-\t\t\t\t// Since we create a new cairo, we have to clip it", "-\t\t\t\tif (OS.GTK_VERSION >= OS.VERSION(3, 9, 0) && (cr != 0)) {", "-\t\t\t\t\tGdkRectangle r = new GdkRectangle();", "-\t\t\t\t\tOS.gdk_cairo_get_clip_rectangle(cr, r);", "-\t\t\t\t\tgc.setClipping(clipRect.x, r.y, r.width, r.height);", "-\t\t\t\t} else {", "+", "+\t\t\t\tif (!OS.GTK3){", "+", "-\t\t\t\tif (OS.GTK_VERSION < OS.VERSION(3, 9, 0)) {", "+\t\t\t\tif (!OS.GTK3) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "030ae0a60975eb704f342051ae27d132", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "b12a0685cf8f3a3f3655b377dae11b353df34bc5", "commitAfterChange": "f86cb451dd44bdb3dd3f72edaedea4c9f49ce379", "methodNumberBeforeChange": 133, "methodNumberAfterChange": 133, "signatureBeforeChange": "  boolean applicationSendMouseEvent (NSEvent nsEvent, boolean send)", "signatureAfterChange": "  boolean applicationSendTrackingEvent (NSEvent nsEvent)", "diff": ["-boolean applicationSendMouseEvent (NSEvent nsEvent, boolean send) {", "-\tif (send) runDeferredEvents();", "-\tboolean up = false;", "+boolean applicationSendTrackingEvent (NSEvent nsEvent) {", "+\trunDeferredEvents();", "-\t\tcase OS.NSOtherMouseDown: {", "-\t\t\tControl control = findControl(nsEvent, false, true, false);", "-\t\t\tsetGrabControl (control);", "-\t\t\tconsume[0] = false;", "-\t\t\tif (control != null) {", "-\t\t\t\tif (type == OS.NSLeftMouseDown && nsEvent.clickCount() == 1 && (control.state & Widget.DRAG_DETECT) != 0 && control.hooks (SWT.DragDetect)) {", "-\t\t\t\t\tNSPoint windowLoc = nsEvent.locationInWindow();", "-\t\t\t\t\tNSPoint viewLoc = control.view.convertPoint_fromView_(windowLoc, null);", "-\t\t\t\t\tif (control.dragDetect((int)viewLoc.x, (int)viewLoc.y, false, consume)) {", "-\t\t\t\t\t\tdragging = true;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tcontrol.sendMouseEvent (nsEvent, SWT.MouseDown, send);", "-\t\t\t\tif (nsEvent.clickCount() == 2) {", "-\t\t\t\t\tcontrol.sendMouseEvent (nsEvent, SWT.MouseDoubleClick, send);", "-\t\t\t\t}", "-\t\t\t\tif (consume [0]) return true;", "-\t\t\t}", "+\t\tcase OS.NSOtherMouseDown:", "+\t\t\ttrackingControl.sendMouseEvent (nsEvent, SWT.MouseDown, true);", "-\t\t}", "-\t\tcase OS.NSOtherMouseUp: {", "-\t\t\tControl control = findControl(nsEvent, true, true, false);", "-\t\t\tif (control != null) {", "-\t\t\t\tcontrol.sendMouseEvent (nsEvent, SWT.MouseUp, send);", "-\t\t\t}", "-\t\t\tsetGrabControl (null);", "-\t\t\tup = true;", "-\t\t\t//FALL THROUGH", "-\t\t}", "+\t\tcase OS.NSOtherMouseUp:", "+\t\t\tnsEvent.window().enableCursorRects();", "+\t\t\ttrackingControl.sendMouseEvent (nsEvent, SWT.MouseUp, true);", "+\t\t\tbreak;", "-\t\tcase OS.NSMouseMoved: {", "-\t\t\tif (type == OS.NSMouseMoved) setGrabControl (null);", "-\t\t\tControl control = findControl(nsEvent, true, true, type == OS.NSMouseMoved);", "-\t\t\tif (dragging) {", "-\t\t\t\tdragging = false;", "-\t\t\t\tcontrol.sendDragEvent(nsEvent);", "-\t\t\t}", "-\t\t\tif (control != currentControl) {", "-\t\t\t\tif (currentControl != null) {", "-\t\t\t\t\tcurrentControl.sendMouseEvent (nsEvent, SWT.MouseExit, send);", "-\t\t\t\t}", "-\t\t\t\tcurrentControl = control;", "-\t\t\t\tif (control != null) {", "-\t\t\t\t\tcontrol.sendMouseEvent (nsEvent, SWT.MouseEnter, send);", "-\t\t\t\t\tif (up) timerExec (getToolTipTime (), hoverTimer);", "-\t\t\t\t}", "-\t\t\t\tsetCursor (control);", "-\t\t\t}", "-\t\t\tif (!up && control != null) {", "-\t\t\t\ttimerExec (getToolTipTime (), hoverTimer);", "-\t\t\t\tcontrol.sendMouseEvent (nsEvent, SWT.MouseMove, send);", "-\t\t\t}", "-\t\t\tif (consume [0]) return true;", "+\t\t\t//TODO hover does not happen while tracking because timer are not dispatched", "+\t\t\tcheckEnterExit (trackingControl, nsEvent, true);", "+\t\tcase OS.NSMouseMoved:", "+\t\t\ttrackingControl.sendMouseEvent (nsEvent, SWT.MouseMove, true);", "-\t\t}"]}], "num": 9383}