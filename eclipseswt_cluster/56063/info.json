{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d27838139cce2a0157d0634daac6a0f0", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0167a9a083ddadebfd803f971ed2253a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "74c0e792b346f85e2b9067f710416658485a9a3b", "commitAfterChange": "e188a1e4ca35b8a449353a5ac187e7a405693faf", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " public void draw(GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground, int flags)", "signatureAfterChange": " public void draw(GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground, int flags)", "diff": ["-\tgc.checkGC(GC.CLIPPING | GC.TRANSFORM | GC.FOREGROUND);", "-\tgc.handle.saveGraphicsState();", "-\tfloat[] fg = gc.data.foreground;", "-\tNSColor foreground = NSColor.colorWithDeviceRed(fg[0], fg[1], fg[2], fg[3]);", "-\tNSPoint pt = new NSPoint();", "-\tpt.x = x;", "-\tpt.y = y;", "-\tboolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;", "-\tNSRange selectionRange = null;", "-\tNSColor selectionColor = null;", "-\tif (hasSelection || (flags & SWT.LAST_LINE_SELECTION) != 0) {", "-\t\tif (selectionBackground == null) selectionBackground = device.getSystemColor(SWT.COLOR_LIST_SELECTION);", "-\t\tselectionColor = NSColor.colorWithDeviceRed(selectionBackground.handle[0], selectionBackground.handle[1], selectionBackground.handle[2], selectionBackground.handle[3]);", "-\t}", "-\tif (hasSelection) {", "-\t\tselectionRange = new NSRange();", "-\t\tselectionRange.location = selectionStart;", "-\t\tselectionRange.length = selectionEnd - selectionStart + 1;", "-\t\tlayoutManager.addTemporaryAttribute(OS.NSBackgroundColorAttributeName, selectionColor, selectionRange);", "-\t}", "-\t//TODO draw selection for flags (DELIMITER_SELECTION)", "-\tint numberOfGlyphs = layoutManager.numberOfGlyphs();", "-\tif (numberOfGlyphs > 0) {", "-\t\tNSRange range = new NSRange();", "-\t\tfor (int i = 0; i < styles.length - 1; i++) {", "-\t\t\tStyleItem run = styles[i];", "-\t\t\tif (run.style != null && run.style.foreground != null) continue;", "-\t\t\trange.location = length != 0 ? translateOffset(run.start) : 0;", "-\t\t\trange.length = translateOffset(styles[i + 1].start) - range.location;", "-\t\t\tlayoutManager.addTemporaryAttribute(OS.NSForegroundColorAttributeName, foreground, range);", "+\tNSAutoreleasePool pool = gc.checkGC(GC.CLIPPING | GC.TRANSFORM | GC.FOREGROUND);", "+\ttry {", "+\t\tgc.handle.saveGraphicsState();", "+\t\tfloat[] fg = gc.data.foreground;", "+\t\tNSColor foreground = NSColor.colorWithDeviceRed(fg[0], fg[1], fg[2], fg[3]);", "+\t\tNSPoint pt = new NSPoint();", "+\t\tpt.x = x;", "+\t\tpt.y = y;", "+\t\tboolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;", "+\t\tNSRange selectionRange = null;", "+\t\tNSColor selectionColor = null;", "+\t\tif (hasSelection || (flags & SWT.LAST_LINE_SELECTION) != 0) {", "+\t\t\tif (selectionBackground == null) selectionBackground = device.getSystemColor(SWT.COLOR_LIST_SELECTION);", "+\t\t\tselectionColor = NSColor.colorWithDeviceRed(selectionBackground.handle[0], selectionBackground.handle[1], selectionBackground.handle[2], selectionBackground.handle[3]);", "-\t\trange.location = 0;", "-\t\trange.length = numberOfGlyphs;", "-\t\tlayoutManager.drawBackgroundForGlyphRange(range, pt);", "-\t\tlayoutManager.drawGlyphsForGlyphRange(range, pt);", "-\t\trange.length = length;", "-\t\tlayoutManager.removeTemporaryAttribute(OS.NSForegroundColorAttributeName, range);", "-\t\tNSPoint point = new NSPoint();", "-\t\tfor (int j = 0; j < styles.length; j++) {", "-\t\t\tStyleItem run = styles[j];", "-\t\t\tTextStyle style = run.style;", "-\t\t\tif (style == null) continue;", "-\t\t\tboolean drawUnderline = style.underline && style.underlineStyle != SWT.UNDERLINE_SINGLE && style.underlineStyle != SWT.UNDERLINE_DOUBLE;", "-\t\t\tdrawUnderline = drawUnderline && (j + 1 == styles.length || !style.isAdherentUnderline(styles[j + 1].style)); ", "-\t\t\tboolean drawBorder = style.borderStyle != SWT.NONE;", "-\t\t\tdrawBorder = drawBorder && (j + 1 == styles.length || !style.isAdherentBorder(styles[j + 1].style)); ", "-\t\t\tif (!drawUnderline && !drawBorder) continue;", "-\t\t\tint end = j + 1 < styles.length ? translateOffset(styles[j + 1].start - 1) : length;", "-\t\t\tfor (int i = 0; i < lineOffsets.length - 1; i++) {", "-\t\t\t\tint lineStart = untranslateOffset(lineOffsets[i]);", "-\t\t\t\tint lineEnd = untranslateOffset(lineOffsets[i + 1] - 1);", "-\t\t\t\tif (drawUnderline) {", "-\t\t\t\t\tint start = run.start;", "-\t\t\t\t\tfor (int k = j; k > 0 && style.isAdherentUnderline(styles[k - 1].style); k--) {", "-\t\t\t\t\t\tstart = styles[k - 1].start;", "-\t\t\t\t\t}", "-\t\t\t\t\tstart = translateOffset(start);", "-\t\t\t\t\tif (!(start > lineEnd || end < lineStart)) {", "-\t\t\t\t\t\trange.location = layoutManager.glyphIndexForCharacterAtIndex(Math.max(lineStart, start));", "-\t\t\t\t\t\trange.length = layoutManager.glyphIndexForCharacterAtIndex(Math.min(lineEnd, end) + 1) - range.location;", "-\t\t\t\t\t\tif (range.length > 0) {", "-\t\t\t\t\t\t\tgc.handle.saveGraphicsState();", "-\t\t\t\t\t\t\tNSRect rect = layoutManager.boundingRectForGlyphRange(range, textContainer);", "-\t\t\t\t\t\t\tfloat baseline = layoutManager.typesetter().baselineOffsetInLayoutManager(layoutManager, lineStart);", "-\t\t\t\t\t\t\tfloat underlineX = pt.x + rect.x;", "-\t\t\t\t\t\t\tfloat underlineY = pt.y + rect.y + rect.height - baseline;", "-\t\t\t\t\t\t\tfloat[] color = null;", "-\t\t\t\t\t\t\tif (style.underlineColor != null) color = style.underlineColor.handle;", "-\t\t\t\t\t\t\tif (color == null && style.foreground != null) color = style.foreground.handle;", "-\t\t\t\t\t\t\tif (color != null) {", "-\t\t\t\t\t\t\t\tNSColor.colorWithDeviceRed(color[0], color[1], color[2], color[3]).setStroke();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tNSBezierPath path = NSBezierPath.bezierPath();", "-\t\t\t\t\t\t\tswitch (style.underlineStyle) {", "+\t\tif (hasSelection) {", "+\t\t\tselectionRange = new NSRange();", "+\t\t\tselectionRange.location = selectionStart;", "+\t\t\tselectionRange.length = selectionEnd - selectionStart + 1;", "+\t\t\tlayoutManager.addTemporaryAttribute(OS.NSBackgroundColorAttributeName, selectionColor, selectionRange);", "+\t\t}", "+\t\t//TODO draw selection for flags (DELIMITER_SELECTION)", "+\t\tint numberOfGlyphs = layoutManager.numberOfGlyphs();", "+\t\tif (numberOfGlyphs > 0) {", "+\t\t\tNSRange range = new NSRange();", "+\t\t\tfor (int i = 0; i < styles.length - 1; i++) {", "+\t\t\t\tStyleItem run = styles[i];", "+\t\t\t\tif (run.style != null && run.style.foreground != null) continue;", "+\t\t\t\trange.location = length != 0 ? translateOffset(run.start) : 0;", "+\t\t\t\trange.length = translateOffset(styles[i + 1].start) - range.location;", "+\t\t\t\tlayoutManager.addTemporaryAttribute(OS.NSForegroundColorAttributeName, foreground, range);", "+\t\t\t}", "+\t\t\trange.location = 0;", "+\t\t\trange.length = numberOfGlyphs;", "+\t\t\tlayoutManager.drawBackgroundForGlyphRange(range, pt);", "+\t\t\tlayoutManager.drawGlyphsForGlyphRange(range, pt);", "+\t\t\trange.length = length;", "+\t\t\tlayoutManager.removeTemporaryAttribute(OS.NSForegroundColorAttributeName, range);", "+\t\t\tNSPoint point = new NSPoint();", "+\t\t\tfor (int j = 0; j < styles.length; j++) {", "+\t\t\t\tStyleItem run = styles[j];", "+\t\t\t\tTextStyle style = run.style;", "+\t\t\t\tif (style == null) continue;", "+\t\t\t\tboolean drawUnderline = style.underline && style.underlineStyle != SWT.UNDERLINE_SINGLE && style.underlineStyle != SWT.UNDERLINE_DOUBLE;", "+\t\t\t\tdrawUnderline = drawUnderline && (j + 1 == styles.length || !style.isAdherentUnderline(styles[j + 1].style)); ", "+\t\t\t\tboolean drawBorder = style.borderStyle != SWT.NONE;", "+\t\t\t\tdrawBorder = drawBorder && (j + 1 == styles.length || !style.isAdherentBorder(styles[j + 1].style)); ", "+\t\t\t\tif (!drawUnderline && !drawBorder) continue;", "+\t\t\t\tint end = j + 1 < styles.length ? translateOffset(styles[j + 1].start - 1) : length;", "+\t\t\t\tfor (int i = 0; i < lineOffsets.length - 1; i++) {", "+\t\t\t\t\tint lineStart = untranslateOffset(lineOffsets[i]);", "+\t\t\t\t\tint lineEnd = untranslateOffset(lineOffsets[i + 1] - 1);", "+\t\t\t\t\tif (drawUnderline) {", "+\t\t\t\t\t\tint start = run.start;", "+\t\t\t\t\t\tfor (int k = j; k > 0 && style.isAdherentUnderline(styles[k - 1].style); k--) {", "+\t\t\t\t\t\t\tstart = styles[k - 1].start;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tstart = translateOffset(start);", "+\t\t\t\t\t\tif (!(start > lineEnd || end < lineStart)) {", "+\t\t\t\t\t\t\trange.location = layoutManager.glyphIndexForCharacterAtIndex(Math.max(lineStart, start));", "+\t\t\t\t\t\t\trange.length = layoutManager.glyphIndexForCharacterAtIndex(Math.min(lineEnd, end) + 1) - range.location;", "+\t\t\t\t\t\t\tif (range.length > 0) {", "+\t\t\t\t\t\t\t\tgc.handle.saveGraphicsState();", "+\t\t\t\t\t\t\t\tNSRect rect = layoutManager.boundingRectForGlyphRange(range, textContainer);", "+\t\t\t\t\t\t\t\tfloat baseline = layoutManager.typesetter().baselineOffsetInLayoutManager(layoutManager, lineStart);", "+\t\t\t\t\t\t\t\tfloat underlineX = pt.x + rect.x;", "+\t\t\t\t\t\t\t\tfloat underlineY = pt.y + rect.y + rect.height - baseline;", "+\t\t\t\t\t\t\t\tfloat[] color = null;", "+\t\t\t\t\t\t\t\tif (style.underlineColor != null) color = style.underlineColor.handle;", "+\t\t\t\t\t\t\t\tif (color == null && style.foreground != null) color = style.foreground.handle;", "+\t\t\t\t\t\t\t\tif (color != null) {", "+\t\t\t\t\t\t\t\t\tNSColor.colorWithDeviceRed(color[0], color[1], color[2], color[3]).setStroke();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tNSBezierPath path = NSBezierPath.bezierPath();", "+\t\t\t\t\t\t\t\tswitch (style.underlineStyle) {", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tpath.stroke();", "+\t\t\t\t\t\t\t\tgc.handle.restoreGraphicsState();", "-\t\t\t\t\t\t\tpath.stroke();", "-\t\t\t\t\t\t\tgc.handle.restoreGraphicsState();", "-\t\t\t\t}", "-\t\t\t\tif (drawBorder) {", "-\t\t\t\t\tint start = run.start;", "-\t\t\t\t\tfor (int k = j; k > 0 && style.isAdherentBorder(styles[k - 1].style); k--) {", "-\t\t\t\t\t\tstart = styles[k - 1].start;", "-\t\t\t\t\t}", "-\t\t\t\t\tstart = translateOffset(start);", "-\t\t\t\t\tif (!(start > lineEnd || end < lineStart)) {", "-\t\t\t\t\t\trange.location = layoutManager.glyphIndexForCharacterAtIndex(Math.max(lineStart, start));", "-\t\t\t\t\t\trange.length = layoutManager.glyphIndexForCharacterAtIndex(Math.min(lineEnd, end) + 1) - range.location;", "-\t\t\t\t\t\tif (range.length > 0) {", "-\t\t\t\t\t\t\tgc.handle.saveGraphicsState();", "-\t\t\t\t\t\t\tNSRect rect = layoutManager.boundingRectForGlyphRange(range, textContainer);", "-\t\t\t\t\t\t\trect.x += pt.x + 0.5f;", "-\t\t\t\t\t\t\trect.y += pt.y + 0.5f;", "-\t\t\t\t\t\t\tfloat[] color = null;", "-\t\t\t\t\t\t\tif (style.borderColor != null) color = style.borderColor.handle;", "-\t\t\t\t\t\t\tif (color == null && style.foreground != null) color = style.foreground.handle;", "-\t\t\t\t\t\t\tif (color != null) {", "-\t\t\t\t\t\t\t\tNSColor.colorWithDeviceRed(color[0], color[1], color[2], color[3]).setStroke();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tint width = 1;", "-\t\t\t\t\t\t\tfloat[] dashes = null;", "-\t\t\t\t\t\t\tswitch (style.borderStyle) {", "+\t\t\t\t\tif (drawBorder) {", "+\t\t\t\t\t\tint start = run.start;", "+\t\t\t\t\t\tfor (int k = j; k > 0 && style.isAdherentBorder(styles[k - 1].style); k--) {", "+\t\t\t\t\t\t\tstart = styles[k - 1].start;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tstart = translateOffset(start);", "+\t\t\t\t\t\tif (!(start > lineEnd || end < lineStart)) {", "+\t\t\t\t\t\t\trange.location = layoutManager.glyphIndexForCharacterAtIndex(Math.max(lineStart, start));", "+\t\t\t\t\t\t\trange.length = layoutManager.glyphIndexForCharacterAtIndex(Math.min(lineEnd, end) + 1) - range.location;", "+\t\t\t\t\t\t\tif (range.length > 0) {", "+\t\t\t\t\t\t\t\tgc.handle.saveGraphicsState();", "+\t\t\t\t\t\t\t\tNSRect rect = layoutManager.boundingRectForGlyphRange(range, textContainer);", "+\t\t\t\t\t\t\t\trect.x += pt.x + 0.5f;", "+\t\t\t\t\t\t\t\trect.y += pt.y + 0.5f;", "+\t\t\t\t\t\t\t\tfloat[] color = null;", "+\t\t\t\t\t\t\t\tif (style.borderColor != null) color = style.borderColor.handle;", "+\t\t\t\t\t\t\t\tif (color == null && style.foreground != null) color = style.foreground.handle;", "+\t\t\t\t\t\t\t\tif (color != null) {", "+\t\t\t\t\t\t\t\t\tNSColor.colorWithDeviceRed(color[0], color[1], color[2], color[3]).setStroke();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tint width = 1;", "+\t\t\t\t\t\t\t\tfloat[] dashes = null;", "+\t\t\t\t\t\t\t\tswitch (style.borderStyle) {", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tNSBezierPath path = NSBezierPath.bezierPath();", "+\t\t\t\t\t\t\t\tpath.setLineDash(dashes, dashes != null ? dashes.length : 0, 0);", "+\t\t\t\t\t\t\t\tpath.appendBezierPathWithRect(rect);", "+\t\t\t\t\t\t\t\tpath.stroke();", "+\t\t\t\t\t\t\t\tgc.handle.restoreGraphicsState();", "-\t\t\t\t\t\t\tNSBezierPath path = NSBezierPath.bezierPath();", "-\t\t\t\t\t\t\tpath.setLineDash(dashes, dashes != null ? dashes.length : 0, 0);", "-\t\t\t\t\t\t\tpath.appendBezierPathWithRect(rect);", "-\t\t\t\t\t\t\tpath.stroke();", "-\t\t\t\t\t\t\tgc.handle.restoreGraphicsState();", "+", "-\t\t\t", "+\t\tif ((flags & SWT.LAST_LINE_SELECTION) != 0) {", "+\t\t\tNSRect bounds = lineBounds[lineBounds.length - 1];", "+\t\t\tNSRect rect = new NSRect();", "+\t\t\trect.x = pt.x + bounds.x + bounds.width;", "+\t\t\trect.y = y + bounds.y;", "+\t\t\trect.width = (flags & SWT.FULL_SELECTION) != 0 ? 0x7fffffff : bounds.height / 3;", "+\t\t\trect.height = bounds.height;", "+\t\t\tselectionColor.setFill();", "+\t\t\tNSBezierPath path = NSBezierPath.bezierPath();", "+\t\t\tpath.appendBezierPathWithRect(rect);", "+\t\t\tpath.fill();", "+\t\t}", "+\t\tif (selectionRange != null) {", "+\t\t\tlayoutManager.removeTemporaryAttribute(OS.NSBackgroundColorAttributeName, selectionRange);", "+\t\t}", "+\t\tgc.handle.restoreGraphicsState();", "+\t} finally {", "+\t\tgc.uncheckGC(pool);", "-\tif ((flags & SWT.LAST_LINE_SELECTION) != 0) {", "-\t\tNSRect bounds = lineBounds[lineBounds.length - 1];", "-\t\tNSRect rect = new NSRect();", "-\t\trect.x = pt.x + bounds.x + bounds.width;", "-\t\trect.y = y + bounds.y;", "-\t\trect.width = (flags & SWT.FULL_SELECTION) != 0 ? 0x7fffffff : bounds.height / 3;", "-\t\trect.height = bounds.height;", "-\t\tselectionColor.setFill();", "-\t\tNSBezierPath path = NSBezierPath.bezierPath();", "-\t\tpath.appendBezierPathWithRect(rect);", "-\t\tpath.fill();", "-\t}", "-\tif (selectionRange != null) {", "-\t\tlayoutManager.removeTemporaryAttribute(OS.NSBackgroundColorAttributeName, selectionRange);", "-\t}", "-\tgc.handle.restoreGraphicsState();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "405fe9e2a178d0cd7170fea27cfa7482", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "74c0e792b346f85e2b9067f710416658485a9a3b", "commitAfterChange": "e188a1e4ca35b8a449353a5ac187e7a405693faf", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 16, "signatureBeforeChange": "  void drawImage(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)", "signatureAfterChange": "  void drawImage(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)", "diff": ["-\tcheckGC(CLIPPING | TRANSFORM);", "- \tif (srcImage.memGC != null) {", "- \t\tsrcImage.createAlpha();", "- \t}", "-\thandle.saveGraphicsState();", "- \tNSAffineTransform transform = NSAffineTransform.transform();", "- \ttransform.scaleXBy(1, -1);", "- \ttransform.translateXBy(0, -(destHeight + 2 * destY));", "- \ttransform.concat();", "- \tNSRect srcRect = new NSRect();", "- \tsrcRect.x = srcX;", "- \tsrcRect.y = imgHeight - (srcY + srcHeight);", "- \tsrcRect.width = srcWidth;", "- \tsrcRect.height = srcHeight;", "- \tNSRect destRect = new NSRect();", "- \tdestRect.x = destX;", "- \tdestRect.y = destY;", "- \tdestRect.width = destWidth;", "- \tdestRect.height = destHeight;", "- \timageHandle.drawInRect(destRect, srcRect, OS.NSCompositeSourceOver, 1);", "- \thandle.restoreGraphicsState();", "-\tuncheckGC();", "+\tNSAutoreleasePool pool = checkGC(CLIPPING | TRANSFORM);", "+\ttry {", "+\t\tif (srcImage.memGC != null) {", "+\t\t\tsrcImage.createAlpha();", "+\t\t}", "+\t\thandle.saveGraphicsState();", "+\t\tNSAffineTransform transform = NSAffineTransform.transform();", "+\t\ttransform.scaleXBy(1, -1);", "+\t\ttransform.translateXBy(0, -(destHeight + 2 * destY));", "+\t\ttransform.concat();", "+\t\tNSRect srcRect = new NSRect();", "+\t\tsrcRect.x = srcX;", "+\t\tsrcRect.y = imgHeight - (srcY + srcHeight);", "+\t\tsrcRect.width = srcWidth;", "+\t\tsrcRect.height = srcHeight;", "+\t\tNSRect destRect = new NSRect();", "+\t\tdestRect.x = destX;", "+\t\tdestRect.y = destY;", "+\t\tdestRect.width = destWidth;", "+\t\tdestRect.height = destHeight;", "+\t\timageHandle.drawInRect(destRect, srcRect, OS.NSCompositeSourceOver, 1);", "+\t\thandle.restoreGraphicsState();", "+\t} finally {", "+\t\tuncheckGC(pool);", "+\t}"]}], "num": 56063}