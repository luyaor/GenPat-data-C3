{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c9893cdeec652efad39b8a9b65d9e730", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "58ac39a460bd2e981c785b7de9dd75e8", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "beda5b839167b1b13e3a65b090e298b270572014", "commitAfterChange": "e83e2a14510bd4b2fede7ad0592f39a83b67fb7d", "methodNumberBeforeChange": 128, "methodNumberAfterChange": 128, "signatureBeforeChange": "  LRESULT wmNotifyChild (int wParam, int lParam)", "signatureAfterChange": "  LRESULT wmNotifyChild (int wParam, int lParam)", "diff": ["+\t\t\t\t\t/*", "+\t\t\t\t\t* Bug in Windows.  When the table has the extended style", "+\t\t\t\t\t* LVS_EX_FULLROWSELECT and LVM_SETBKCOLOR is used with", "+\t\t\t\t\t* CLR_NONE to make the table transparent, Windows fills", "+\t\t\t\t\t* a black rectangle around any column that contains an", "+\t\t\t\t\t* image.  The fix is clear LVS_EX_FULLROWSELECT during", "+\t\t\t\t\t* custom draw.", "+\t\t\t\t\t*/", "+\t\t\t\t\tif ((style & SWT.FULL_SELECTION) != 0) {", "+\t\t\t\t\t\tif (OS.SendMessage (handle, OS.LVM_GETBKCOLOR, 0, 0) == OS.CLR_NONE) {", "+\t\t\t\t\t\t\tOS.UpdateWindow (handle);", "+\t\t\t\t\t\t\tint bits = OS.LVS_EX_FULLROWSELECT;", "+\t\t\t\t\t\t\tOS.SendMessage (handle, OS.LVM_SETEXTENDEDLISTVIEWSTYLE, bits, 0);", "+\t\t\t\t\t\t\tOS.ValidateRect (handle, null);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\t\treturn new LRESULT (OS.CDRF_NOTIFYITEMDRAW);", "+\t\t\t\t\treturn new LRESULT (OS.CDRF_NOTIFYITEMDRAW | OS.CDRF_NOTIFYPOSTPAINT);", "+\t\t\t\t}", "+\t\t\t\tcase OS.CDDS_POSTPAINT: {", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Bug in Windows.  When the table has the extended style", "+\t\t\t\t\t* LVS_EX_FULLROWSELECT and LVM_SETBKCOLOR is used with", "+\t\t\t\t\t* CLR_NONE to make the table transparent, Windows fills", "+\t\t\t\t\t* a black rectangle around any column that contains an", "+\t\t\t\t\t* image.  The fix is clear LVS_EX_FULLROWSELECT during", "+\t\t\t\t\t* custom draw.", "+\t\t\t\t\t*/", "+\t\t\t\t\tif ((style & SWT.FULL_SELECTION) != 0) {", "+\t\t\t\t\t\tif (OS.SendMessage (handle, OS.LVM_GETBKCOLOR, 0, 0) == OS.CLR_NONE) {", "+\t\t\t\t\t\t\tint bits = OS.LVS_EX_FULLROWSELECT;", "+\t\t\t\t\t\t\tif (OS.IsWinCE) {", "+\t\t\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\t\t\tboolean damaged = OS.GetUpdateRect (handle, rect, true);", "+\t\t\t\t\t\t\t\tOS.SendMessage (handle, OS.LVM_SETEXTENDEDLISTVIEWSTYLE, bits, bits);", "+\t\t\t\t\t\t\t\tOS.ValidateRect (handle, null);", "+\t\t\t\t\t\t\t\tif (damaged) OS.InvalidateRect (handle, rect, true);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tint rgn = OS.CreateRectRgn (0, 0, 0, 0);", "+\t\t\t\t\t\t\t\tint result = OS.GetUpdateRgn (handle, rgn, true);", "+\t\t\t\t\t\t\t\tOS.SendMessage (handle, OS.LVM_SETEXTENDEDLISTVIEWSTYLE, bits, bits);", "+\t\t\t\t\t\t\t\tOS.ValidateRect (handle, null);", "+\t\t\t\t\t\t\t\tif (result != OS.NULLREGION) OS.InvalidateRgn (handle, rgn, true);", "+\t\t\t\t\t\t\t\tOS.DeleteObject (rgn);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t\tboolean ignoreDrawSelected = false;", "+\t\t\t\t\t\t\t\tignoreDrawSelected = true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Bug in Windows.  When the table has the extended style", "+\t\t\t\t\t* LVS_EX_FULLROWSELECT and LVM_SETBKCOLOR is used with", "+\t\t\t\t\t* CLR_NONE to make the table transparent, Windows draws", "+\t\t\t\t\t* a black rectangle around any column that contains an", "+\t\t\t\t\t* image.  The fix is emulate LVS_EX_FULLROWSELECT by", "+\t\t\t\t\t* drawing the selection.", "+\t\t\t\t\t*/", "+\t\t\t\t\tif (!ignoreDrawSelected && (style & SWT.FULL_SELECTION) != 0) {", "+\t\t\t\t\t\tint bits = OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);", "+\t\t\t\t\t\tif ((bits & OS.LVS_EX_FULLROWSELECT) == 0) {", "+\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t* Bug in Windows.  For some reason, CDIS_SELECTED always set,", "+\t\t\t\t\t\t\t* even for items that are not selected.  The fix is to get", "+\t\t\t\t\t\t\t* the selection state from the item.", "+\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\tLVITEM lvItem = new LVITEM ();", "+\t\t\t\t\t\t\tlvItem.mask = OS.LVIF_STATE;", "+\t\t\t\t\t\t\tlvItem.stateMask = OS.LVIS_SELECTED;", "+\t\t\t\t\t\t\tlvItem.iItem = nmcd.dwItemSpec;", "+\t\t\t\t\t\t\tint result = OS.SendMessage (handle, OS.LVM_GETITEM, 0, lvItem);", "+\t\t\t\t\t\t\tif ((result != 0 && (lvItem.state & OS.LVIS_SELECTED) != 0)) {", "+\t\t\t\t\t\t\t\tif (OS.GetFocus () == handle) {", "+\t\t\t\t\t\t\t\t\tclrText = OS.GetSysColor (OS.COLOR_HIGHLIGHTTEXT);", "+\t\t\t\t\t\t\t\t\tclrTextBk = OS.GetSysColor (OS.COLOR_HIGHLIGHT);", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tif ((style & SWT.HIDE_SELECTION) == 0) {", "+\t\t\t\t\t\t\t\t\t\tclrTextBk = OS.GetSysColor (OS.COLOR_3DFACE);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (clrTextBk != -1 && nmcd.iSubItem == 0) {", "+\t\t\t\t\t\t\t\t\tRECT itemRect = new RECT ();", "+\t\t\t\t\t\t\t\t\titemRect.left = OS.LVIR_SELECTBOUNDS;", "+\t\t\t\t\t\t\t\t\tif (OS.SendMessage (handle, OS. LVM_GETITEMRECT, nmcd.dwItemSpec, itemRect) != 0) {", "+\t\t\t\t\t\t\t\t\t\tRECT headerRect = new RECT ();", "+\t\t\t\t\t\t\t\t\t\tif (OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, 0, headerRect) != 0) {", "+\t\t\t\t\t\t\t\t\t\t\titemRect.left = itemRect.right;", "+\t\t\t\t\t\t\t\t\t\t\titemRect.right = headerRect.right;", "+\t\t\t\t\t\t\t\t\t\t\tfillBackground (hDC, clrTextBk, itemRect);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\trect.left = OS.LVIR_BOUNDS;", "+\t\t\t\t\t\titemRect.left = OS.LVIR_BOUNDS;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2b8090b3f8393e93bc118d4c9d4f606e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Button.java", "commitBeforeChange": "70b3c05a26d1ba0b79fb3867745857a6ef7b0bdd", "commitAfterChange": "79a568b5fdc1ca6bf2c553d9a3775288be090ca1", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": "  public Point computeSize (int wHint, int hHint, boolean changed)", "signatureAfterChange": "  public Point computeSize (int wHint, int hHint, boolean changed)", "diff": ["-\tPoint size = computeNativeSize (handle, wHint, hHint, changed);", "+\tPoint size;", "+\tboolean wrap = labelHandle != 0 && (style & SWT.WRAP) != 0 && (OS.GTK_WIDGET_FLAGS (labelHandle) & OS.GTK_VISIBLE) != 0;", "+\tif (wrap) {", "+\t\tint borderWidth = OS.gtk_container_get_border_width (handle);", "+\t\tint[] focusWidth = new int[1];", "+\t\tOS.gtk_widget_style_get (handle, OS.focus_line_width, focusWidth, 0);", "+\t\tint[] focusPadding = new int[1];", "+\t\tOS.gtk_widget_style_get (handle, OS.focus_padding, focusPadding, 0);", "+\t\tint trimWidth = 2 * (borderWidth + focusWidth [0] + focusPadding [0]), trimHeight = trimWidth;", "+\t\tint indicatorHeight = 0;", "+\t\tif ((style & (SWT.CHECK | SWT.RADIO)) != 0) {", "+\t\t\tint[] indicatorSize = new int[1];", "+\t\t\tOS.gtk_widget_style_get (handle, OS.indicator_size, indicatorSize, 0);", "+\t\t\tint[] indicatorSpacing = new int[1];", "+\t\t\tOS.gtk_widget_style_get (handle, OS.indicator_spacing, indicatorSpacing, 0);", "+\t\t\tindicatorHeight = indicatorSize [0] + 2 * indicatorSpacing [0];", "+\t\t\ttrimWidth += indicatorHeight + indicatorSpacing [0];", "+\t\t} else {", "+\t\t\tint /*long*/ style = OS.gtk_widget_get_style (handle);", "+\t\t\ttrimWidth += OS.gtk_style_get_xthickness (style) * 2;", "+\t\t\ttrimHeight += OS.gtk_style_get_ythickness (style) * 2;", "+\t\t\tGtkBorder innerBorder = getBorder (OS.inner_border, handle, INNER_BORDER);", "+\t\t\ttrimWidth += innerBorder.left + innerBorder.right;", "+\t\t\ttrimHeight += innerBorder.top + innerBorder.bottom;", "+\t\t\tif ((OS.GTK_WIDGET_FLAGS (handle) & OS.GTK_CAN_DEFAULT) != 0) {", "+\t\t\t\tGtkBorder defaultBorder = getBorder (OS.default_border, handle, DEFAULT_BORDER);", "+\t\t\t\ttrimWidth += defaultBorder.left + defaultBorder.right;", "+\t\t\t\ttrimHeight += defaultBorder.top + defaultBorder.bottom;", "+\t\t\t}", "+\t\t}", "+\t\tint imageWidth = 0, imageHeight = 0;", "+\t\tif (OS.GTK_WIDGET_VISIBLE (imageHandle)) {", "+\t\t\tGtkRequisition requisition = new GtkRequisition ();", "+\t\t\tOS.gtk_widget_size_request (imageHandle, requisition);", "+\t\t\timageWidth = requisition.width;", "+\t\t\timageHeight = requisition.height;", "+\t\t\tint [] spacing = new int [1];", "+\t\t\tOS.g_object_get (boxHandle, OS.spacing, spacing, 0);", "+\t\t\timageWidth += spacing [0];", "+\t\t}", "+\t\tint /*long*/ labelLayout = OS.gtk_label_get_layout (labelHandle);", "+\t\tint pangoWidth = OS.pango_layout_get_width (labelLayout);", "+\t\tif (wHint != SWT.DEFAULT) {", "+\t\t\tOS.pango_layout_set_width (labelLayout, Math.max (1, (wHint - imageWidth - trimWidth)) * OS.PANGO_SCALE);", "+\t\t} else {", "+\t\t\tOS.pango_layout_set_width (labelLayout, -1);", "+\t\t}", "+\t\tint [] w = new int [1], h = new int [1];", "+\t\tOS.pango_layout_get_size (labelLayout, w, h);", "+\t\tOS.pango_layout_set_width (labelLayout, pangoWidth);", "+\t\tsize = new Point(0, 0);", "+\t\tsize.x += wHint == SWT.DEFAULT ? OS.PANGO_PIXELS(w [0]) + imageWidth + trimWidth : wHint;", "+\t\tsize.y += hHint == SWT.DEFAULT ? Math.max(Math.max(imageHeight, indicatorHeight), OS.PANGO_PIXELS(h [0])) + trimHeight : hHint;", "+\t} else {", "+\t\tsize = computeNativeSize (handle, wHint, hHint, changed);", "+\t}", "-\t\t\tint /*long*/ [] buffer = new int /*long*/ [1];", "-\t\t\tGtkBorder border = new GtkBorder ();", "-\t\t\tOS.gtk_widget_style_get (handle, OS.default_border, buffer, 0);", "-\t\t\tif (buffer[0] != 0) {", "-\t\t\t\tOS.memmove (border, buffer[0], GtkBorder.sizeof);", "-\t\t\t} else {", "-\t\t\t\t/* Use the GTK+ default value of 1 for each. */", "-\t\t\t\tborder.left = border.right = border.top = border.bottom = 1;", "-\t\t\t}", "+\t\t\tGtkBorder border = getBorder (OS.default_border, handle, DEFAULT_BORDER);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b7eedf4c0d4fdac78be94b1863a88e27", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/carbon/org/eclipse/swt/browser/Safari.java", "commitBeforeChange": "e7ab60cfa38a8c3fdcd69ddcf2d3bdc3dd7d8859", "commitAfterChange": "cea7ad4f53311c6e11b8d036e80114124cd5665a", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  int handleCallback(int nextHandler, int theEvent)", "signatureAfterChange": "  int handleCallback(int nextHandler, int theEvent)", "diff": ["-\tswitch (eventKind) {", "-\t\tcase OS.kEventControlSetCursor: {", "-\t\t\treturn OS.noErr;", "-\t\t}", "-\t\tcase OS.kEventControlDraw: {", "-\t\t\t/*", "-\t\t\t* Bug on Safari. The web view cannot be obscured by other views above it.", "-\t\t\t* This problem is specified in the apple documentation for HiWebViewCreate.", "-\t\t\t* The workaround is to don't draw the web view when it is not visible.", "-\t\t\t*/", "-\t\t\tif (!browser.isVisible ()) return OS.noErr;", "-\t\t\tbreak;", "-\t\t}", "-\t\tcase OS.kEventRawKeyDown: {", "-\t\t\t/*", "-\t\t\t* Bug in Safari. The WebView blocks the propagation of certain Carbon events", "-\t\t\t* such as kEventRawKeyDown. On the Mac, Carbon events propagate from the", "-\t\t\t* Focus Target Handler to the Control Target Handler, Window Target and finally", "-\t\t\t* the Application Target Handler. It is assumed that WebView hooks its events", "-\t\t\t* on the Window Target and does not pass kEventRawKeyDown to the next handler.", "-\t\t\t* Since kEventRawKeyDown events never make it to the Application Target Handler,", "-\t\t\t* the Application Target Handler never gets to emit kEventTextInputUnicodeForKeyEvent", "-\t\t\t* used by SWT to send a SWT.KeyDown event.", "-\t\t\t* The workaround is to hook kEventRawKeyDown on the Control Target Handler which gets", "-\t\t\t* called before the WebView hook on the Window Target Handler. Then, forward this event", "-\t\t\t* directly to the Application Target Handler. Note that if in certain conditions Safari", "-\t\t\t* does not block the kEventRawKeyDown, then multiple kEventTextInputUnicodeForKeyEvent", "-\t\t\t* events might be generated as a result of this workaround.", "-\t\t\t*/", "-\t\t\t//TEMPORARY CODE", "-//\t\t\tdoit = false;", "-//\t\t\tOS.SendEventToEventTarget(theEvent, OS.GetApplicationEventTarget());", "-//\t\t\tif (!doit) return OS.noErr;", "-\t\t\tbreak;", "-\t\t}", "-\t\tcase OS.kEventTextInputUnicodeForKeyEvent: {", "-\t\t\t/*", "-\t\t\t* Note.  This event is received from the Window Target therefore after it was received", "-\t\t\t* by the Focus Target. The SWT.KeyDown event is sent by SWT on the Focus Target. If it", "-\t\t\t* is received here, then the SWT.KeyDown doit flag must have been left to the value", "-\t\t\t* true.  For package visibility reasons we cannot access the doit flag directly.", "-\t\t\t* ", "-\t\t\t* Sequence of events when the user presses a key down", "-\t\t\t* ", "-\t\t\t* .Control Target - kEventRawKeyDown", "-\t\t\t* \t.forward to ApplicationEventTarget", "-\t\t\t* \t\t.Focus Target kEventTextInputUnicodeForKeyEvent - SWT emits SWT.KeyDown - ", "-\t\t\t* \t\t\tblocks further propagation if doit false. Browser does not know directly about", "-\t\t\t* \t\t\tthe doit flag value.", "-\t\t\t* \t\t\t.Window Target kEventTextInputUnicodeForKeyEvent - if received, Browser knows ", "-\t\t\t* \t\t\tSWT.KeyDown is not blocked and event should be sent to WebKit", "-\t\t\t*  Return from Control Target - kEventRawKeyDown: let the event go to WebKit if doit true ", "-\t\t\t*  (eventNotHandledErr) or stop it (noErr).", "-\t\t\t*/", "-\t\t\t//TEMPORARY CODE", "-//\t\t\tdoit = true;", "-\t\t\tbreak;", "-\t\t}", "+\tswitch (OS.GetEventClass(theEvent)) {", "+\t\tcase OS.kEventClassControl:", "+\t\t\tswitch (eventKind) {", "+\t\t\t\tcase OS.kEventControlSetCursor: {", "+\t\t\t\t\treturn OS.noErr;", "+\t\t\t\t}", "+\t\t\t\tcase OS.kEventControlDraw: {", "+\t\t\t\t\t/*", "+\t\t\t\t\t * Bug on Safari. The web view cannot be obscured by other views above it.", "+\t\t\t\t\t * This problem is specified in the apple documentation for HiWebViewCreate.", "+\t\t\t\t\t * The workaround is to don't draw the web view when it is not visible.", "+\t\t\t\t\t */", "+\t\t\t\t\tif (!browser.isVisible ()) return OS.noErr;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase OS.kEventControlOwningWindowChanged: {", "+\t\t\t\t\t/* Reparent the web view handler */", "+\t\t\t\t\tint window = OS.GetControlOwner(browser.handle);", "+\t\t\t\t\tint[] contentView = new int[1];", "+\t\t\t\t\tOS.HIViewFindByID(OS.HIViewGetRoot(window), OS.kHIViewWindowContentID(), contentView);", "+\t\t\t\t\tOS.HIViewAddSubview(contentView[0], webViewHandle);", "+\t\t\t\t\t", "+\t\t\t\t\t/* Reset the kEventWindowBoundsChanged handler */", "+\t\t\t\t\tOS.RemoveEventHandler(windowBoundsHandler);", "+\t\t\t\t\tint[] mask2 = new int[] {", "+\t\t\t\t\t\tOS.kEventClassWindow, OS.kEventWindowBoundsChanged,", "+\t\t\t\t\t};", "+\t\t\t\t\tint[] outRef = new int[1];", "+\t\t\t\t\tOS.InstallEventHandler(OS.GetWindowEventTarget(window), Callback3.getAddress(), mask2.length / 2, mask2, browser.handle, outRef);", "+\t\t\t\t\twindowBoundsHandler = outRef[0];", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcase OS.kEventControlBoundsChanged:", "+\t\t\t\tcase OS.kEventControlVisibilityChanged: {", "+\t\t\t\t\t/*", "+\t\t\t\t\t * Bug on Safari. The web view cannot be obscured by other views above it.", "+\t\t\t\t\t * This problem is specified in the apple documentation for HiWebViewCreate.", "+\t\t\t\t\t * The workaround is to hook kEventControlVisibilityChanged on the browser", "+\t\t\t\t\t * and move the browser out of the screen when hidden and restore its bounds", "+\t\t\t\t\t * when shown.", "+\t\t\t\t\t */", "+\t\t\t\t\tCGRect bounds = new CGRect();", "+\t\t\t\t\tif (!browser.isVisible()) {", "+\t\t\t\t\t\tbounds.x = bounds.y = -MIN_SIZE;", "+\t\t\t\t\t\tbounds.width = bounds.height = MIN_SIZE;", "+\t\t\t\t\t\tOS.HIViewSetFrame(webViewHandle, bounds);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tOS.HIViewGetBounds(browser.handle, bounds);", "+\t\t\t\t\t\tint[] contentView = new int[1];", "+\t\t\t\t\t\tOS.HIViewFindByID(OS.HIViewGetRoot(OS.GetControlOwner(browser.handle)), OS.kHIViewWindowContentID(), contentView);", "+\t\t\t\t\t\tOS.HIViewConvertRect(bounds, browser.handle, contentView[0]);", "+\t\t\t\t\t\t/* ", "+\t\t\t\t\t\t* Bug in Safari.  For some reason, the web view will display incorrectly or", "+\t\t\t\t\t\t* blank depending on its contents, if its size is set to a value smaller than", "+\t\t\t\t\t\t* MIN_SIZE. It will not display properly even after the size is made larger.", "+\t\t\t\t\t\t* The fix is to avoid setting sizes smaller than MIN_SIZE. ", "+\t\t\t\t\t\t*/", "+\t\t\t\t\t\tif (bounds.width <= MIN_SIZE) bounds.width = MIN_SIZE;", "+\t\t\t\t\t\tif (bounds.height <= MIN_SIZE) bounds.height = MIN_SIZE;", "+\t\t\t\t\t\tOS.HIViewSetFrame(webViewHandle, bounds);", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\tcase OS.kEventClassWindow:", "+\t\t\tswitch (eventKind) {", "+\t\t\t\tcase OS.kEventWindowBoundsChanged:", "+\t\t\t\t\t/*", "+\t\t\t\t\t * Bug on Safari. Resizing the height of a Shell containing a Browser at", "+\t\t\t\t\t * a fixed location causes the Browser to redraw at a wrong location.", "+\t\t\t\t\t * The web view is a HIView container that internally hosts", "+\t\t\t\t\t * a Cocoa NSView that uses a coordinates system with the origin at the", "+\t\t\t\t\t * bottom left corner of a window instead of the coordinates system used", "+\t\t\t\t\t * in Carbon that starts at the top left corner. The workaround is to", "+\t\t\t\t\t * reposition the web view every time the Shell of the Browser is resized.", "+\t\t\t\t\t * ", "+\t\t\t\t\t * Note the size should not be updated if the browser is hidden.", "+\t\t\t\t\t */", "+\t\t\t\t\tif (browser.isVisible()) {", "+\t\t\t\t\t\tCGRect oldBounds = new CGRect();", "+\t\t\t\t\t\tOS.GetEventParameter (theEvent, OS.kEventParamOriginalBounds, OS.typeHIRect, null, CGRect.sizeof, null, oldBounds);", "+\t\t\t\t\t\tCGRect bounds = new CGRect();", "+\t\t\t\t\t\tOS.GetEventParameter (theEvent, OS.kEventParamCurrentBounds, OS.typeHIRect, null, CGRect.sizeof, null, bounds);", "+\t\t\t\t\t\tif (oldBounds.height == bounds.height) break;", "+\t\t\t\t\t\tOS.HIViewGetBounds(browser.handle, bounds);", "+\t\t\t\t\t\tint[] contentView = new int[1];", "+\t\t\t\t\t\tOS.HIViewFindByID(OS.HIViewGetRoot(OS.GetControlOwner(browser.handle)), OS.kHIViewWindowContentID(), contentView);", "+\t\t\t\t\t\tOS.HIViewConvertRect(bounds, browser.handle, contentView[0]);", "+\t\t\t\t\t\t/* ", "+\t\t\t\t\t\t* Bug in Safari.  For some reason, the web view will display incorrectly or", "+\t\t\t\t\t\t* blank depending on its contents, if its size is set to a value smaller than", "+\t\t\t\t\t\t* MIN_SIZE. It will not display properly even after the size is made larger.", "+\t\t\t\t\t\t* The fix is to avoid setting sizes smaller than MIN_SIZE. ", "+\t\t\t\t\t\t*/", "+\t\t\t\t\t\tif (bounds.width <= MIN_SIZE) bounds.width = MIN_SIZE;", "+\t\t\t\t\t\tif (bounds.height <= MIN_SIZE) bounds.height = MIN_SIZE;", "+\t\t\t\t\t\tbounds.x++;", "+\t\t\t\t\t\t/* Note that the bounds needs to change */", "+\t\t\t\t\t\tOS.HIViewSetFrame(webViewHandle, bounds);", "+\t\t\t\t\t\tbounds.x--;", "+\t\t\t\t\t\tOS.HIViewSetFrame(webViewHandle, bounds);", "+\t\t\t\t\t}", "+\t\t\t}", "+\t\tcase OS.kEventClassKeyboard:", "+\t\t\tswitch (eventKind) {", "+\t\t\t\tcase OS.kEventRawKeyDown: {", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Bug in Safari. The WebView blocks the propagation of certain Carbon events", "+\t\t\t\t\t* such as kEventRawKeyDown. On the Mac, Carbon events propagate from the", "+\t\t\t\t\t* Focus Target Handler to the Control Target Handler, Window Target and finally", "+\t\t\t\t\t* the Application Target Handler. It is assumed that WebView hooks its events", "+\t\t\t\t\t* on the Window Target and does not pass kEventRawKeyDown to the next handler.", "+\t\t\t\t\t* Since kEventRawKeyDown events never make it to the Application Target Handler,", "+\t\t\t\t\t* the Application Target Handler never gets to emit kEventTextInputUnicodeForKeyEvent", "+\t\t\t\t\t* used by SWT to send a SWT.KeyDown event.", "+\t\t\t\t\t* The workaround is to hook kEventRawKeyDown on the Control Target Handler which gets", "+\t\t\t\t\t* called before the WebView hook on the Window Target Handler. Then, forward this event", "+\t\t\t\t\t* directly to the Application Target Handler. Note that if in certain conditions Safari", "+\t\t\t\t\t* does not block the kEventRawKeyDown, then multiple kEventTextInputUnicodeForKeyEvent", "+\t\t\t\t\t* events might be generated as a result of this workaround.", "+\t\t\t\t\t*/", "+\t\t\t\t\t//TEMPORARY CODE", "+//\t\t\t\t\tdoit = false;", "+//\t\t\t\t\tOS.SendEventToEventTarget(theEvent, OS.GetApplicationEventTarget());", "+//\t\t\t\t\tif (!doit) return OS.noErr;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\tcase OS.kEventClassTextInput:", "+\t\t\tswitch (eventKind) {", "+\t\t\t\tcase OS.kEventTextInputUnicodeForKeyEvent: {", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Note.  This event is received from the Window Target therefore after it was received", "+\t\t\t\t\t* by the Focus Target. The SWT.KeyDown event is sent by SWT on the Focus Target. If it", "+\t\t\t\t\t* is received here, then the SWT.KeyDown doit flag must have been left to the value", "+\t\t\t\t\t* true.  For package visibility reasons we cannot access the doit flag directly.", "+\t\t\t\t\t* ", "+\t\t\t\t\t* Sequence of events when the user presses a key down", "+\t\t\t\t\t* ", "+\t\t\t\t\t* .Control Target - kEventRawKeyDown", "+\t\t\t\t\t* \t.forward to ApplicationEventTarget", "+\t\t\t\t\t* \t\t.Focus Target kEventTextInputUnicodeForKeyEvent - SWT emits SWT.KeyDown - ", "+\t\t\t\t\t* \t\t\tblocks further propagation if doit false. Browser does not know directly about", "+\t\t\t\t\t* \t\t\tthe doit flag value.", "+\t\t\t\t\t* \t\t\t.Window Target kEventTextInputUnicodeForKeyEvent - if received, Browser knows ", "+\t\t\t\t\t* \t\t\tSWT.KeyDown is not blocked and event should be sent to WebKit", "+\t\t\t\t\t*  Return from Control Target - kEventRawKeyDown: let the event go to WebKit if doit true ", "+\t\t\t\t\t*  (eventNotHandledErr) or stop it (noErr).", "+\t\t\t\t\t*/", "+\t\t\t\t\t//TEMPORARY CODE", "+//\t\t\t\t\tdoit = true;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b908ea6f94b234d5b53a7974a6a1aec5", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "c63ca636edfbea4cd55ccc07da414186be375ce0", "commitAfterChange": "e38d4aec3f79c42ea6666a7a37c026187a8aa6ea", "methodNumberBeforeChange": 128, "methodNumberAfterChange": 130, "signatureBeforeChange": "  LRESULT wmNotifyChild (int wParam, int lParam)", "signatureAfterChange": "  LRESULT wmNotifyChild (int wParam, int lParam)", "diff": ["-\t\t\tif (!customDraw) break;", "+\t\t\tif (!customDraw) {", "+\t\t\t\tif (backgroundImage == null) break;", "+\t\t\t}", "+//\t\t\t\t\tif (drawCount != 0 || !OS.IsWindowVisible (handle)) {", "+//\t\t\t\t\t\tif (!OS.IsWinCE && OS.WindowFromDC (nmcd.hdc) == handle) break;", "+//\t\t\t\t\t}", "-\t\t\t\t\tif (!printClient && (style & SWT.FULL_SELECTION) == 0) {", "+\t\t\t\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);", "+\t\t\t\t\tif (!printClient && (bits & OS.TVS_FULLROWSELECT) == 0) {", "+\t\t\t\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);", "+\t\t\t\t\tif (backgroundImage != null) OS.SetBkMode (hDC, OS.TRANSPARENT);", "-\t\t\t\t\t\tif ((style & SWT.FULL_SELECTION) != 0) {", "+\t\t\t\t\t\tif ((bits & OS.TVS_FULLROWSELECT) != 0) {", "-\t\t\t\t\t\t\tif ((tvItem.state & OS.TVIS_SELECTED) != 0) {", "+\t\t\t\t\t\t\tif ((tvItem.state & (OS.TVIS_SELECTED | OS.TVIS_DROPHILITED)) != 0) {", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tOS.SetTextColor (hDC, getForegroundPixel ());", "-\t\t\t\t\t\t\tOS.SetBkColor (hDC, getBackgroundPixel ());", "-\t\t\t\t\tif (hwndHeader != 0) {", "-\t\t\t\t\t\tGCData data = new GCData();", "-\t\t\t\t\t\tdata.device = display;", "-\t\t\t\t\t\tGC gc = GC.win32_new (hDC, data);", "-\t\t\t\t\t\tint x = 0, gridWidth = linesVisible ? GRID_WIDTH : 0;", "-\t\t\t\t\t\tPoint size = null;", "-\t\t\t\t\t\tRECT rect = new RECT ();", "-\t\t\t\t\t\tHDITEM hdItem = new HDITEM ();", "-\t\t\t\t\t\thdItem.mask = OS.HDI_WIDTH;", "-\t\t\t\t\t\tint count = OS.SendMessage (hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);", "-\t\t\t\t\t\tfor (int i=0; i<count; i++) {", "-\t\t\t\t\t\t\tint index = OS.SendMessage (hwndHeader, OS.HDM_ORDERTOINDEX, i, 0);", "+\t\t\t\t\tGCData data = new GCData();", "+\t\t\t\t\tdata.device = display;", "+\t\t\t\t\tGC gc = GC.win32_new (hDC, data);", "+\t\t\t\t\tint x = 0, gridWidth = linesVisible ? GRID_WIDTH : 0;", "+\t\t\t\t\tPoint size = null;\t", "+\t\t\t\t\tint count = hwndHeader != 0 ? OS.SendMessage (hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0) : 0;", "+\t\t\t\t\tfor (int i=0; i<Math.max (1, count); i++) {", "+\t\t\t\t\t\tboolean drawItem = true;", "+\t\t\t\t\t\tint index = i, width = nmcd.right - nmcd.left;", "+\t\t\t\t\t\tif (count > 0 && hwndHeader != 0) {", "+\t\t\t\t\t\t\tHDITEM hdItem = new HDITEM ();", "+\t\t\t\t\t\t\thdItem.mask = OS.HDI_WIDTH;", "+\t\t\t\t\t\t\tindex = OS.SendMessage (hwndHeader, OS.HDM_ORDERTOINDEX, i, 0);", "-\t\t\t\t\t\t\tif (i > 0) {", "-\t\t\t\t\t\t\t\tint clrTextBk = -1;", "-\t\t\t\t\t\t\t\tOS.SetRect (rect, x, nmcd.top, x + hdItem.cxy, nmcd.bottom - gridWidth);", "-\t\t\t\t\t\t\t\tif (useColor) {", "-\t\t\t\t\t\t\t\t\tclrTextBk = item.cellBackground != null ? item.cellBackground [index] : -1;", "-\t\t\t\t\t\t\t\t\tif (clrTextBk == -1) clrTextBk = item.background;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (clrTextBk == -1) {", "-\t\t\t\t\t\t\t\t\tif (printClient || (style & SWT.FULL_SELECTION) != 0) {", "-\t\t\t\t\t\t\t\t\t\tclrTextBk = OS.GetBkColor (hDC);", "+\t\t\t\t\t\t\twidth = hdItem.cxy;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\tif (i == 0) {", "+\t\t\t\t\t\t\tdrawItem = false;", "+\t\t\t\t\t\t\tif (useColor) {", "+\t\t\t\t\t\t\t\tif (backgroundImage != null) {", "+\t\t\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t\t\t* Feature in Windows.  When the mouse is pressed in a", "+\t\t\t\t\t\t\t\t\t* single select tree, the previous item is no longer", "+\t\t\t\t\t\t\t\t\t* selected, but the TVIS_SELECTED bits for that item", "+\t\t\t\t\t\t\t\t\t* are not set.  The fix is to test for the selection", "+\t\t\t\t\t\t\t\t\t* colors and guess that the item is selected.", "+\t\t\t\t\t\t\t\t\t* ", "+\t\t\t\t\t\t\t\t\t* NOTE: This code does not work when the foreground and", "+\t\t\t\t\t\t\t\t\t* background of the tree are set to the selection colors", "+\t\t\t\t\t\t\t\t\t* but this does not happen in a regular application.", "+\t\t\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\t\t\tboolean selected = false;", "+\t\t\t\t\t\t\t\t\tif ((style & SWT.SINGLE) != 0) {\t", "+\t\t\t\t\t\t\t\t\t\tif (OS.GetTextColor (hDC) == OS.GetSysColor (OS.COLOR_HIGHLIGHTTEXT)) {", "+\t\t\t\t\t\t\t\t\t\t\tif (OS.GetBkColor (hDC) == OS.GetSysColor (OS.COLOR_HIGHLIGHT)) {", "+\t\t\t\t\t\t\t\t\t\t\t\tselected = true;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tTVITEM tvItem = new TVITEM ();", "+\t\t\t\t\t\t\t\t\t\ttvItem.mask = OS.TVIF_STATE;", "+\t\t\t\t\t\t\t\t\t\ttvItem.hItem = item.handle;", "+\t\t\t\t\t\t\t\t\t\tOS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);", "+\t\t\t\t\t\t\t\t\t\tselected = (tvItem.state & (OS.TVIS_SELECTED | OS.TVIS_DROPHILITED)) != 0;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (!selected) {", "+\t\t\t\t\t\t\t\t\t\trect.left = item.handle;", "+\t\t\t\t\t\t\t\t\t\tif (OS.SendMessage (handle, OS.TVM_GETITEMRECT, 1, rect) != 0) {", "+\t\t\t\t\t\t\t\t\t\t\tdrawItem = true;", "+\t\t\t\t\t\t\t\t\t\t\tint right = Math.min (rect.right, width);", "+\t\t\t\t\t\t\t\t\t\t\tOS.SetRect (rect, rect.left, rect.top, right, rect.bottom);", "+\t\t\t\t\t\t\t\t\t\t\tfillBackground (hDC, backgroundImage, rect);", "+\t\t\t\t\t\t\t\t\t\t\tif (handle == OS.GetFocus ()) {", "+\t\t\t\t\t\t\t\t\t\t\t\tint uiState = OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);", "+\t\t\t\t\t\t\t\t\t\t\t\tif ((uiState & OS.UISF_HIDEFOCUS) == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tint hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (hItem == item.handle) OS.DrawFocusRect (hDC, rect);", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\trect.left = Math.min (rect.right, rect.left + 2);", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (clrTextBk != -1) drawBackground (hDC, clrTextBk, rect);", "+\t\t\t\t\t\t\t\tOS.SetTextColor (hDC, getForegroundPixel ());", "+\t\t\t\t\t\t\t\tOS.SetBkColor (hDC, getBackgroundPixel ());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tOS.SetRect (rect, x, nmcd.top, x + width, nmcd.bottom - gridWidth);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (drawItem) {", "+\t\t\t\t\t\t\tint clrTextBk = -1;", "+\t\t\t\t\t\t\tif (useColor) {", "+\t\t\t\t\t\t\t\tclrTextBk = item.cellBackground != null ? item.cellBackground [index] : -1;", "+\t\t\t\t\t\t\t\tif (clrTextBk == -1) clrTextBk = item.background;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (clrTextBk == -1) {", "+\t\t\t\t\t\t\t\tif (printClient || (bits & OS.TVS_FULLROWSELECT) != 0) {", "+\t\t\t\t\t\t\t\t\tclrTextBk = OS.GetBkColor (hDC);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (clrTextBk != -1) {", "+\t\t\t\t\t\t\t\tif (backgroundImage != null) {", "+\t\t\t\t\t\t\t\t\tfillBackground (hDC, backgroundImage, rect);", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tfillBackground (hDC, clrTextBk, rect);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (i > 0) {", "-\t\t\t\t\t\t\t\t/*", "-\t\t\t\t\t\t\t\t* Bug in Windows.  When DrawText() is used with DT_VCENTER", "-\t\t\t\t\t\t\t\t* and DT_ENDELLIPSIS, the ellipsis can draw outside of the", "-\t\t\t\t\t\t\t\t* rectangle when the rectangle is empty.  The fix is avoid", "-\t\t\t\t\t\t\t\t* all text drawing for empty rectangles.", "-\t\t\t\t\t\t\t\t*/", "-\t\t\t\t\t\t\t\tif (rect.left < rect.right) {", "-\t\t\t\t\t\t\t\t\tString string = null;", "-\t\t\t\t\t\t\t\t\tif (index == 0) {", "-\t\t\t\t\t\t\t\t\t\tstring = item.text;", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tString [] strings  = item.strings;", "-\t\t\t\t\t\t\t\t\t\tif (strings != null) string = strings [index];", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t* Bug in Windows.  When DrawText() is used with DT_VCENTER", "+\t\t\t\t\t\t\t* and DT_ENDELLIPSIS, the ellipsis can draw outside of the", "+\t\t\t\t\t\t\t* rectangle when the rectangle is empty.  The fix is avoid", "+\t\t\t\t\t\t\t* all text drawing for empty rectangles.", "+\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\tif (rect.left < rect.right) {", "+\t\t\t\t\t\t\t\tString string = null;", "+\t\t\t\t\t\t\t\tif (index == 0) {", "+\t\t\t\t\t\t\t\t\tstring = item.text;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tString [] strings  = item.strings;", "+\t\t\t\t\t\t\t\t\tif (strings != null) string = strings [index];", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (string != null) {", "+\t\t\t\t\t\t\t\t\tint hFont = item.cellFont != null ? item.cellFont [index] : -1;", "+\t\t\t\t\t\t\t\t\tif (hFont == -1) hFont = item.font;", "+\t\t\t\t\t\t\t\t\thFont = hFont != -1 ? OS.SelectObject (hDC, hFont) : -1;", "+\t\t\t\t\t\t\t\t\tint clrText = -1;", "+\t\t\t\t\t\t\t\t\tif (useColor) {", "+\t\t\t\t\t\t\t\t\t\tclrText = item.cellForeground != null ? item.cellForeground [index] : -1;", "+\t\t\t\t\t\t\t\t\t\tif (clrText == -1) clrText = item.foreground;", "+\t\t\t\t\t\t\t\t\t\tclrText = clrText != -1 ? OS.SetTextColor (hDC, clrText) : -1;", "-\t\t\t\t\t\t\t\t\tif (string != null) {", "-\t\t\t\t\t\t\t\t\t\tint hFont = item.cellFont != null ? item.cellFont [index] : -1;", "-\t\t\t\t\t\t\t\t\t\tif (hFont == -1) hFont = item.font;", "-\t\t\t\t\t\t\t\t\t\thFont = hFont != -1 ? OS.SelectObject (hDC, hFont) : -1;", "-\t\t\t\t\t\t\t\t\t\tint clrText = -1;", "-\t\t\t\t\t\t\t\t\t\tif (useColor) {", "-\t\t\t\t\t\t\t\t\t\t\tclrText = item.cellForeground != null ? item.cellForeground [index] : -1;", "-\t\t\t\t\t\t\t\t\t\t\tif (clrText == -1) clrText = item.foreground;", "-\t\t\t\t\t\t\t\t\t\t\tclrText = clrText != -1 ? OS.SetTextColor (hDC, clrText) : -1;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tint oldMode = clrTextBk != -1 ? OS.SetBkMode (hDC, OS.TRANSPARENT) : -1;", "-\t\t\t\t\t\t\t\t\t\tint flags = OS.DT_NOPREFIX | OS.DT_SINGLELINE | OS.DT_VCENTER | OS.DT_ENDELLIPSIS;", "-\t\t\t\t\t\t\t\t\t\tTreeColumn column = columns [index];", "+\t\t\t\t\t\t\t\t\tint oldMode = clrTextBk != -1 ? OS.SetBkMode (hDC, OS.TRANSPARENT) : -1;", "+\t\t\t\t\t\t\t\t\tint flags = OS.DT_NOPREFIX | OS.DT_SINGLELINE | OS.DT_VCENTER;", "+\t\t\t\t\t\t\t\t\tif (i != 0) flags |= OS.DT_ENDELLIPSIS;", "+\t\t\t\t\t\t\t\t\tflags |= OS.DT_LEFT;", "+\t\t\t\t\t\t\t\t\tTreeColumn column = columns != null ? columns [index] : null;", "+\t\t\t\t\t\t\t\t\tif (column != null) {", "-\t\t\t\t\t\t\t\t\t\tTCHAR buffer = new TCHAR (getCodePage (), string, false);", "-\t\t\t\t\t\t\t\t\t\tOS.DrawText (hDC, buffer, buffer.length (), rect, flags);", "-\t\t\t\t\t\t\t\t\t\tif (hFont != -1) OS.SelectObject (hDC, hFont);", "-\t\t\t\t\t\t\t\t\t\tif (clrText != -1) OS.SetTextColor (hDC, clrText);", "-\t\t\t\t\t\t\t\t\t\tif (oldMode != -1) OS.SetBkMode (hDC, oldMode);", "+\t\t\t\t\t\t\t\t\tTCHAR buffer = new TCHAR (getCodePage (), string, false);", "+\t\t\t\t\t\t\t\t\tOS.DrawText (hDC, buffer, buffer.length (), rect, flags);", "+\t\t\t\t\t\t\t\t\tif (hFont != -1) OS.SelectObject (hDC, hFont);", "+\t\t\t\t\t\t\t\t\tif (clrText != -1) OS.SetTextColor (hDC, clrText);", "+\t\t\t\t\t\t\t\t\tif (oldMode != -1) OS.SetBkMode (hDC, oldMode);", "-\t\t\t\t\t\t\tx += hdItem.cxy;", "-\t\t\t\t\t\tif (count > 0) {", "-\t\t\t\t\t\t\tif (printClient || (style & SWT.FULL_SELECTION) != 0) {", "-\t\t\t\t\t\t\t\tOS.SetRect (rect, x, nmcd.top, nmcd.right, nmcd.bottom - gridWidth);", "-\t\t\t\t\t\t\t\tdrawBackground (hDC, OS.GetBkColor (hDC), rect);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tgc.dispose ();", "+\t\t\t\t\t\tx += width;", "+\t\t\t\t\tif (count > 0) {", "+\t\t\t\t\t\tif (printClient || (bits & OS.TVS_FULLROWSELECT) != 0) {", "+\t\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\t\tOS.SetRect (rect, x, nmcd.top, nmcd.right, nmcd.bottom - gridWidth);", "+\t\t\t\t\t\t\tfillBackground (hDC, OS.GetBkColor (hDC), rect);", "+\t\t\t\t\t\t\t/* This code is intentionally commented */", "+\t\t\t\t\t\t\t//drawBackground (hDC, rect);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tgc.dispose ();", "-\t\t\t\t\t\tif (printClient && (style & SWT.FULL_SELECTION) == 0) {", "+\t\t\t\t\t\tif (printClient && (bits & OS.TVS_FULLROWSELECT) != 0) {", "-\t\t\t\t\t\t\t\tint count = OS.SendMessage (hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);", "-\t\t\t\t\t\t\t\tif (count != 0 && printClient) {", "+\t\t\t\t\t\t\t\tif (OS.SendMessage (hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0) != 0 && printClient) {", "-\t\t\t\t\t\tif (OS.COMCTL32_MAJOR < 6 || (style & SWT.FULL_SELECTION) != 0) {", "+\t\t\t\t\t\tif (OS.COMCTL32_MAJOR < 6 || (bits & OS.TVS_FULLROWSELECT) != 0) {", "+\t\t\tif (backgroundImage != null && drawCount == 0) {", "+\t\t\t\tOS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);", "+\t\t\t\tOS.InvalidateRect (handle, null, true);", "+\t\t\t}", "+\t\t\tif (backgroundImage != null && drawCount == 0) {", "+\t\t\t\tOS.DefWindowProc (handle, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3d02e9429cbae394299f456e8712f622", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/carbon/org/eclipse/swt/browser/Safari.java", "commitBeforeChange": "4a54739762437bd8066c9b7d36c4c3d14493b18a", "commitAfterChange": "271f940e0df4170fc833286729bdba3441aed75a", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 28, "signatureBeforeChange": "  void didFailProvisionalLoadWithError(int error, int frame)", "signatureAfterChange": "  void didFailProvisionalLoadWithError(int error, int frame)", "diff": ["+", "+\tint errorCode = Cocoa.objc_msgSend(error, Cocoa.S_code);", "+\tif (Cocoa.NSURLErrorBadURL < errorCode) return;", "+", "+\tint failingURL = 0;", "+\tint info = Cocoa.objc_msgSend(error, Cocoa.S_userInfo);", "+\tif (info != 0) {", "+\t\tint keyString = createNSString(\"NSErrorFailingURLKey\"); //$NON-NLS-1$", "+\t\tfailingURL = Cocoa.objc_msgSend(info, Cocoa.S_valueForKey, keyString);", "+\t\tOS.CFRelease(keyString);", "+\t}", "+", "+\tif (failingURL != 0 && Cocoa.NSURLErrorServerCertificateNotYetValid <= errorCode && errorCode <= Cocoa.NSURLErrorSecureConnectionFailed) {", "+\t\t/* handle invalid certificate error */", "+\t\tint keyString = createNSString(\"NSErrorPeerCertificateChainKey\"); //$NON-NLS-1$", "+\t\tint certificates = Cocoa.objc_msgSend(info, Cocoa.S_objectForKey, keyString);", "+\t\tOS.CFRelease(keyString);", "+", "+\t\tint[] policySearch = new int[1];", "+\t\tint[] policyRef = new int[1];", "+\t\tint[] trustRef = new int[1];", "+\t\tboolean success = false;", "+\t\tint result = OS.SecPolicySearchCreate(OS.CSSM_CERT_X_509v3, 0, 0, policySearch);", "+\t\tif (result == 0 && policySearch[0] != 0) {", "+\t\t\tresult = OS.SecPolicySearchCopyNext(policySearch[0], policyRef);", "+\t\t\tif (result == 0 && policyRef[0] != 0) {", "+\t\t\t\tresult = OS.SecTrustCreateWithCertificates(certificates, policyRef[0], trustRef);", "+\t\t\t\tif (result == 0 && trustRef[0] != 0) {", "+\t\t\t\t\tint panel = Cocoa.objc_msgSend(Cocoa.C_SFCertificateTrustPanel, Cocoa.S_sharedCertificateTrustPanel);", "+\t\t\t\t\tString failingUrlString = getString(Cocoa.objc_msgSend(failingURL, Cocoa.S_absoluteString));", "+\t\t\t\t\tString message = Compatibility.getMessage(\"SWT_InvalidCert_Message\", new Object[] {failingUrlString}); //$NON-NLS-1$", "+\t\t\t\t\tint nsString = createNSString(Compatibility.getMessage(\"SWT_Cancel\")); //$NON-NLS-1$", "+\t\t\t\t\tCocoa.objc_msgSend(panel, Cocoa.S_setAlternateButtonTitle, nsString);", "+\t\t\t\t\tOS.CFRelease(nsString);", "+\t\t\t\t\tCocoa.objc_msgSend(panel, Cocoa.S_setShowsHelp, 1);", "+\t\t\t\t\tCocoa.objc_msgSend(failingURL, Cocoa.S_retain);", "+\t\t\t\t\tint window = Cocoa.objc_msgSend(webView, Cocoa.S_window);", "+\t\t\t\t\tnsString = createNSString(message);", "+\t\t\t\t\tCocoa.objc_msgSend(panel, Cocoa.S_beginSheetForWindow, window, delegate, Cocoa.S_createPanelDidEnd, failingURL, trustRef[0], nsString);", "+\t\t\t\t\tOS.CFRelease(nsString);", "+\t\t\t\t\tsuccess = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+", "+\t\tif (trustRef[0] != 0) OS.CFRelease(trustRef[0]);", "+\t\tif (policyRef[0] != 0) OS.CFRelease(policyRef[0]);", "+\t\tif (policySearch[0] != 0) OS.CFRelease(policySearch[0]);", "+\t\tif (success) return;", "+\t}", "+", "+\t/* handle other types of errors */", "+\tint description = Cocoa.objc_msgSend(error, Cocoa.S_localizedDescription);", "+\tif (description != 0) {", "+\t\tString descriptionString = getString(description);", "+\t\tString message = failingURL != 0 ? getString(Cocoa.objc_msgSend(failingURL, Cocoa.S_absoluteString)) + \"\\n\\n\" : \"\"; //$NON-NLS-1$ //$NON-NLS-2$", "+\t\tmessage += Compatibility.getMessage (\"SWT_Page_Load_Failed\", new Object[] {descriptionString}); //$NON-NLS-1$", "+\t\tMessageBox messageBox = new MessageBox(browser.getShell(), SWT.OK | SWT.ICON_ERROR);", "+\t\tmessageBox.setMessage(message);", "+\t\tmessageBox.open();", "+\t}", "+}"]}], "num": 48864}