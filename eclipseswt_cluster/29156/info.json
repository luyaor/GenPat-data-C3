{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ab699cc70817122b722125a616105ce5", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d3f5c56329a76df939d8fa86907cddd", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Shell.java", "commitBeforeChange": "d62639ede6a7c1602973b824cc7101b67ed4c309", "commitAfterChange": "21edcd9179bf3e0a6f314b5d553d95c17b6bc393", "methodNumberBeforeChange": 117, "methodNumberAfterChange": 117, "signatureBeforeChange": "  void setToolTipText (long rootWidget, long tipWidget, String string)", "signatureAfterChange": "  void setToolTipText (long rootWidget, long tipWidget, String string)", "diff": ["-\tif (OS.GTK_VERSION >= OS.VERSION (2, 12, 0)) {", "-\t\tbyte [] buffer = null;", "-\t\tif (string != null && string.length () > 0) {", "-\t\t\tchar [] chars = fixMnemonic (string, false);", "-\t\t\tbuffer = Converter.wcsToMbcs (null, chars, true);", "-\t\t}", "-\t\tlong /*int*/ oldTooltip = OS.gtk_widget_get_tooltip_text (rootWidget);", "-\t\tboolean same = false;", "-\t\tif (buffer == null && oldTooltip == 0) {", "-\t\t\tsame = true;", "-\t\t} else if (buffer != null && oldTooltip != 0) {", "-\t\t\tsame = OS.strcmp (oldTooltip, buffer) == 0;", "-\t\t}", "-\t\tif (oldTooltip != 0) OS.g_free(oldTooltip);", "-\t\tif (same) return;", "-", "-\t\tlong /*int*/ eventPtr = 0;", "-\t\tif (OS.GTK_VERSION < OS.VERSION (2, 18, 0)) {", "-\t\t\tOS.gtk_widget_set_tooltip_text (rootWidget, null);", "-\t\t\t/*", "-\t\t\t * Bug in GTK. In GTK 2.12, due to a miscalculation of window", "-\t\t\t * coordinates, using gtk_tooltip_trigger_tooltip_query ()", "-\t\t\t * to update an existing a toboltip will result in the tooltip", "-\t\t\t * being displayed at a wrong position. The fix is to send out", "-\t\t\t * 2 fake GDK_MOTION_NOTIFY events (to mimic the GTK call) which", "-\t\t\t * contain the proper x and y coordinates.", "-\t\t\t */", "-\t\t\tlong /*int*/ tipWindow = gtk_widget_get_window (rootWidget);", "-\t\t\tif (tipWindow != 0) {", "-\t\t\t\tint [] x = new int [1], y = new int [1];", "-\t\t\t\tlong /*int*/ window = OS.gdk_window_at_pointer (x, y);", "-\t\t\t\tlong /*int*/ [] user_data = new long /*int*/ [1];", "-\t\t\t\tif (window != 0) OS.gdk_window_get_user_data (window, user_data);", "-\t\t\t\tif (tipWidget == user_data [0]) {", "-\t\t\t\t\teventPtr = OS.gdk_event_new (OS.GDK_MOTION_NOTIFY);", "-\t\t\t\t\tGdkEventMotion event = new GdkEventMotion ();", "-\t\t\t\t\tevent.type = OS.GDK_MOTION_NOTIFY;", "-\t\t\t\t\tevent.window = OS.g_object_ref (tipWindow);", "-\t\t\t\t\tevent.x = x [0];", "-\t\t\t\t\tevent.y = y [0];", "-\t\t\t\t\tOS.gdk_window_get_origin (window, x, y);", "-\t\t\t\t\tevent.x_root = event.x + x [0];", "-\t\t\t\t\tevent.y_root = event.y + y [0];", "-\t\t\t\t\tOS.memmove (eventPtr, event, GdkEventMotion.sizeof);", "-\t\t\t\t\tOS.gtk_main_do_event (eventPtr);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tOS.gtk_widget_set_tooltip_text (rootWidget, buffer);", "-\t\tif (eventPtr != 0) {", "-\t\t\tOS.gtk_main_do_event (eventPtr);", "-\t\t\tOS.gdk_event_free (eventPtr);", "-\t\t}", "-\t} else {", "-\t\tbyte [] buffer = null;", "-\t\tif (string != null && string.length () > 0) {", "-\t\t\tchar [] chars = fixMnemonic (string, false);", "-\t\t\tbuffer = Converter.wcsToMbcs (null, chars, true);", "-\t\t}", "-\t\tlong /*int*/ tipData = OS.gtk_tooltips_data_get(tipWidget);", "-\t\tif (tipData != 0) {", "-\t\t\tlong /*int*/ oldTooltip = OS.GTK_TOOLTIPS_GET_TIP_TEXT(tipData);", "-\t\t\tif (string == null && oldTooltip == 0) {", "-\t\t\t\treturn;", "-\t\t\t} else if (string != null && oldTooltip != 0) {", "-\t\t\t\tif (buffer != null) {", "-\t\t\t\t\tif (OS.strcmp (oldTooltip, buffer) == 0) return;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (tooltipsHandle == 0) {", "-\t\t\ttooltipsHandle = OS.gtk_tooltips_new ();", "-\t\t\tif (tooltipsHandle == 0) error (SWT.ERROR_NO_HANDLES);", "-\t\t\tOS.g_object_ref (tooltipsHandle);", "-\t\t\tOS.g_object_ref_sink (tooltipsHandle);", "-\t\t}", "-", "-\t\t/*", "-\t\t* Feature in GTK.  There is no API to position a tooltip.", "-\t\t* The fix is to connect to the size_allocate signal for", "-\t\t* the tooltip window and position it before it is mapped.", "-\t\t*", "-\t\t* Bug in Solaris-GTK.  Invoking gtk_tooltips_force_window()", "-\t\t* can cause a crash in older versions of GTK.  The fix is", "-\t\t* to avoid this call if the GTK version is older than 2.2.x.", "-\t\t* The call is to be avoided on GTK versions newer than 2.12.0", "-\t\t* where it's deprecated.", "-\t\t*/", "-\t\tOS.gtk_tooltips_force_window (tooltipsHandle);", "-\t\tlong /*int*/ tipWindow = OS.GTK_TOOLTIPS_TIP_WINDOW (tooltipsHandle);", "-\t\tif (tipWindow != 0 && tipWindow != tooltipWindow) {", "-\t\t\tOS.g_signal_connect (tipWindow, OS.size_allocate, display.sizeAllocateProc, shellHandle);", "-\t\t\ttooltipWindow = tipWindow;", "-\t\t}", "-", "-\t\t/*", "-\t\t* Bug in GTK.  If the cursor is inside the window when a new", "-\t\t* tooltip is set and the old tooltip is hidden, the new tooltip", "-\t\t* is not displayed until the mouse re-enters the window.  The", "-\t\t* fix is force the new tooltip to be active.", "-\t\t*/", "-\t\tboolean set = true;", "-\t\tif (tipWindow != 0) {", "-\t\t\tif (gtk_widget_get_visible (tipWidget) || gtk_widget_get_realized (tipWidget)) {", "-\t\t\t\tint [] x = new int [1], y = new int [1];", "-\t\t\t\tlong /*int*/ window = OS.gdk_window_at_pointer (x, y);", "-\t\t\t\tif (window != 0) {", "-\t\t\t\t\tlong /*int*/ [] user_data = new long /*int*/ [1];", "-\t\t\t\t\tOS.gdk_window_get_user_data (window, user_data);", "-\t\t\t\t\tif (tipWidget == user_data [0]) {", "-\t\t\t\t\t\t/*", "-\t\t\t\t\t\t* Feature in GTK.  Calling gtk_tooltips_set_tip() positions and", "-\t\t\t\t\t\t* shows the tooltip.  If the tooltip is already visible, moving", "-\t\t\t\t\t\t* it to a new location in the size_allocate signal causes flashing.", "-\t\t\t\t\t\t* The fix is to hide the tip window in the size_request signal", "-\t\t\t\t\t\t* and before the new tooltip is forced to be active.", "-\t\t\t\t\t\t*/", "-\t\t\t\t\t\tset = false;", "-\t\t\t\t\t\tint handler_id = OS.g_signal_connect (tipWindow, OS.size_request, display.sizeRequestProc, shellHandle);", "-\t\t\t\t\t\tOS.gtk_tooltips_set_tip (tooltipsHandle, tipWidget, buffer, null);", "-\t\t\t\t\t\tOS.gtk_widget_hide (tipWindow);", "-\t\t\t\t\t\tlong /*int*/ data = OS.gtk_tooltips_data_get (tipWidget);", "-\t\t\t\t\t\tOS.GTK_TOOLTIPS_SET_ACTIVE (tooltipsHandle, data);", "-\t\t\t\t\t\tOS.gtk_tooltips_set_tip (tooltipsHandle, tipWidget, buffer, null);", "-\t\t\t\t\t\tif (handler_id != 0) OS.g_signal_handler_disconnect (tipWindow, handler_id);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (set) OS.gtk_tooltips_set_tip (tooltipsHandle, tipWidget, buffer, null);", "+\tbyte [] buffer = null;", "+\tif (string != null && string.length () > 0) {", "+\t\tchar [] chars = fixMnemonic (string, false);", "+\t\tbuffer = Converter.wcsToMbcs (null, chars, true);", "+\tlong /*int*/ oldTooltip = OS.gtk_widget_get_tooltip_text (rootWidget);", "+\tboolean same = false;", "+\tif (buffer == null && oldTooltip == 0) {", "+\t\tsame = true;", "+\t} else if (buffer != null && oldTooltip != 0) {", "+\t\tsame = OS.strcmp (oldTooltip, buffer) == 0;", "+\t}", "+\tif (oldTooltip != 0) OS.g_free(oldTooltip);", "+\tif (same) return;", "+\tOS.gtk_widget_set_tooltip_text (rootWidget, buffer);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a2c113c35d1dda377932a985fa99444", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Shell.java", "commitBeforeChange": "b35a49da6d60208984201c1be34fa638b8bf5fdf", "commitAfterChange": "6b3f40fb94f6858bfa876ed525a9745360cf8cba", "methodNumberBeforeChange": 97, "methodNumberAfterChange": 97, "signatureBeforeChange": "  void setToolTipText (int widget, String string)", "signatureAfterChange": "  void setToolTipText (int widget, String string)", "diff": ["-\tbyte [] buffer = null;", "-\tif (string != null && string.length () > 0) {", "-\t\tchar [] chars = fixMnemonic (string, false);", "-\t\tbuffer = Converter.wcsToMbcs (null, chars, true);", "-\t}", "-\tif (tooltipsHandle == 0) {", "-\t\ttooltipsHandle = OS.gtk_tooltips_new ();", "-\t\tif (tooltipsHandle == 0) error (SWT.ERROR_NO_HANDLES);", "-\t\tOS.g_object_ref (tooltipsHandle);", "-\t\tOS.gtk_object_sink (tooltipsHandle);", "-\t}", "-", "-\t/*", "-\t* Feature in GTK.  There is no API to position a tooltip.", "-\t* The fix is to connect to the size_allocate signal for", "-\t* the tooltip window and position it before it is mapped.", "-\t*", "-\t* Bug in Solaris-GTK.  Invoking gtk_tooltips_force_window()", "-\t* can cause a crash in older versions of GTK.  The fix is", "-\t* to avoid this call if the GTK version is older than 2.2.x.", "-\t*/", "-\tif (OS.GTK_VERSION >= OS.VERSION (2, 2, 1)) {", "-\t\tOS.gtk_tooltips_force_window (tooltipsHandle);", "-\t}", "-\tint /*long*/ tipWindow = OS.GTK_TOOLTIPS_TIP_WINDOW (tooltipsHandle);", "-\tif (tipWindow != 0 && tipWindow != tooltipWindow) {", "-\t\tOS.g_signal_connect (tipWindow, OS.size_allocate, display.sizeAllocateProc, shellHandle);", "-\t\ttooltipWindow = tipWindow;", "-\t}", "+\tif (OS.GTK_VERSION >= OS.VERSION (2, 12, 0)) {", "+\t\tbyte [] buffer = null;", "+\t\tif (string != null && string.length () > 0) {", "+\t\t\tchar [] chars = fixMnemonic (string, false);", "+\t\t\tbuffer = Converter.wcsToMbcs (null, chars, true);", "+\t\t}", "+\t\tOS.gtk_widget_set_tooltip_text (widget, null);", "+\t\tOS.gtk_tooltip_trigger_tooltip_query (OS.gdk_display_get_default ());", "+\t\tOS.gtk_widget_set_tooltip_text (widget, buffer);\t", "+\t} else {", "+\t\tbyte [] buffer = null;", "+\t\tif (string != null && string.length () > 0) {", "+\t\t\tchar [] chars = fixMnemonic (string, false);", "+\t\t\tbuffer = Converter.wcsToMbcs (null, chars, true);", "+\t\t}", "+\t\tif (tooltipsHandle == 0) {", "+\t\t\ttooltipsHandle = OS.gtk_tooltips_new ();", "+\t\t\tif (tooltipsHandle == 0) error (SWT.ERROR_NO_HANDLES);", "+\t\t\tOS.g_object_ref (tooltipsHandle);", "+\t\t\tOS.gtk_object_sink (tooltipsHandle);", "+\t\t}", "-\t/*", "-\t* Bug in GTK.  If the cursor is inside the window when a new", "-\t* tooltip is set and the old tooltip is hidden, the new tooltip", "-\t* is not displayed until the mouse re-enters the window.  The", "-\t* fix is force the new tooltip to be active.", "-\t*/", "-\tboolean set = true;", "-\tif (tipWindow != 0) {", "-\t\tif ((OS.GTK_WIDGET_FLAGS (widget) & (OS.GTK_REALIZED | OS.GTK_VISIBLE)) != 0) {", "-\t\t\tint [] x = new int [1], y = new int [1];", "-\t\t\tint /*long*/ window = OS.gdk_window_at_pointer (x, y);", "-\t\t\tif (window != 0) {", "-\t\t\t\tint /*long*/ [] user_data = new int /*long*/ [1];", "-\t\t\t\tOS.gdk_window_get_user_data (window, user_data);", "-\t\t\t\tif (widget == user_data [0]) {", "-\t\t\t\t\t/* ", "-\t\t\t\t\t* Feature in GTK.  Calling gtk_tooltips_set_tip() positions and", "-\t\t\t\t\t* shows the tooltip.  If the tooltip is already visible, moving", "-\t\t\t\t\t* it to a new location in the size_allocate signal causes flashing.", "-\t\t\t\t\t* The fix is to hide the tip window in the size_request signal", "-\t\t\t\t\t* and before the new tooltip is forced to be active. ", "-\t\t\t\t\t*/", "-\t\t\t\t\tset = false;", "-\t\t\t\t\tint handler_id = OS.g_signal_connect (tipWindow, OS.size_request, display.sizeRequestProc, shellHandle);", "-\t\t\t\t\tOS.gtk_tooltips_set_tip (tooltipsHandle, widget, buffer, null);", "-\t\t\t\t\tOS.gtk_widget_hide (tipWindow);", "-\t\t\t\t\tint /*long*/ data = OS.gtk_tooltips_data_get (widget);", "-\t\t\t\t\tOS.GTK_TOOLTIPS_SET_ACTIVE (tooltipsHandle, data);", "-\t\t\t\t\tOS.gtk_tooltips_set_tip (tooltipsHandle, widget, buffer, null);", "-\t\t\t\t\tif (handler_id != 0) OS.g_signal_handler_disconnect (tipWindow, handler_id);", "+\t\t/*", "+\t\t* Feature in GTK.  There is no API to position a tooltip.", "+\t\t* The fix is to connect to the size_allocate signal for", "+\t\t* the tooltip window and position it before it is mapped.", "+\t\t*", "+\t\t* Bug in Solaris-GTK.  Invoking gtk_tooltips_force_window()", "+\t\t* can cause a crash in older versions of GTK.  The fix is", "+\t\t* to avoid this call if the GTK version is older than 2.2.x.", "+\t\t*/", "+\t\tif (OS.GTK_VERSION >= OS.VERSION (2, 2, 1)) {", "+\t\t\tOS.gtk_tooltips_force_window (tooltipsHandle);", "+\t\t}", "+\t\tint /*long*/ tipWindow = OS.GTK_TOOLTIPS_TIP_WINDOW (tooltipsHandle);", "+\t\tif (tipWindow != 0 && tipWindow != tooltipWindow) {", "+\t\t\tOS.g_signal_connect (tipWindow, OS.size_allocate, display.sizeAllocateProc, shellHandle);", "+\t\t\ttooltipWindow = tipWindow;", "+\t\t}", "+\t\t", "+\t\t/*", "+\t\t* Bug in GTK.  If the cursor is inside the window when a new", "+\t\t* tooltip is set and the old tooltip is hidden, the new tooltip", "+\t\t* is not displayed until the mouse re-enters the window.  The", "+\t\t* fix is force the new tooltip to be active.", "+\t\t*/", "+\t\tboolean set = true;", "+\t\tif (tipWindow != 0) {", "+\t\t\tif ((OS.GTK_WIDGET_FLAGS (widget) & (OS.GTK_REALIZED | OS.GTK_VISIBLE)) != 0) {", "+\t\t\t\tint [] x = new int [1], y = new int [1];", "+\t\t\t\tint /*long*/ window = OS.gdk_window_at_pointer (x, y);", "+\t\t\t\tif (window != 0) {", "+\t\t\t\t\tint /*long*/ [] user_data = new int /*long*/ [1];", "+\t\t\t\t\tOS.gdk_window_get_user_data (window, user_data);", "+\t\t\t\t\tif (widget == user_data [0]) {", "+\t\t\t\t\t\t/* ", "+\t\t\t\t\t\t* Feature in GTK.  Calling gtk_tooltips_set_tip() positions and", "+\t\t\t\t\t\t* shows the tooltip.  If the tooltip is already visible, moving", "+\t\t\t\t\t\t* it to a new location in the size_allocate signal causes flashing.", "+\t\t\t\t\t\t* The fix is to hide the tip window in the size_request signal", "+\t\t\t\t\t\t* and before the new tooltip is forced to be active. ", "+\t\t\t\t\t\t*/", "+\t\t\t\t\t\tset = false;", "+\t\t\t\t\t\tint handler_id = OS.g_signal_connect (tipWindow, OS.size_request, display.sizeRequestProc, shellHandle);", "+\t\t\t\t\t\tOS.gtk_tooltips_set_tip (tooltipsHandle, widget, buffer, null);", "+\t\t\t\t\t\tOS.gtk_widget_hide (tipWindow);", "+\t\t\t\t\t\tint /*long*/ data = OS.gtk_tooltips_data_get (widget);", "+\t\t\t\t\t\tOS.GTK_TOOLTIPS_SET_ACTIVE (tooltipsHandle, data);", "+\t\t\t\t\t\tOS.gtk_tooltips_set_tip (tooltipsHandle, widget, buffer, null);", "+\t\t\t\t\t\tif (handler_id != 0) OS.g_signal_handler_disconnect (tipWindow, handler_id);", "+\t\t\t\t\t}", "+\t\tif (set) OS.gtk_tooltips_set_tip (tooltipsHandle, widget, buffer, null);", "-\tif (set) OS.gtk_tooltips_set_tip (tooltipsHandle, widget, buffer, null);", "+\t\t"]}], "num": 29156}