{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a57ab0de706b8477c0d9f8148242cf20", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a11ae8fb7ee4ec2b69d68303f8a1ac2", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/carbon/org/eclipse/swt/browser/Safari.java", "commitBeforeChange": "a83fcf6055f867f0050aa97de300cbeb9da19a0d", "commitAfterChange": "56fb1e5d19b79846a4a91435e0ae039e4404a5a0", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  int handleCallback(int nextHandler, int theEvent)", "signatureAfterChange": "  int handleCallback(int nextHandler, int theEvent)", "diff": ["-\t\t\t\t\tbreak;", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Bug in Carbon.  OSX crashes if a HICocoaView is disposed during a key event,", "+\t\t\t\t\t* presumably as a result of attempting to use it after its refcount has reached", "+\t\t\t\t\t* 0.  The workaround is to temporarily add an extra ref to the view while the", "+\t\t\t\t\t* DOM listener is handling the event, in case the Browser gets disposed in a", "+\t\t\t\t\t* callback.", "+\t\t\t\t\t*/", "+\t\t\t\t\tint webViewHandle = this.webViewHandle;", "+\t\t\t\t\tOS.CFRetain (webViewHandle);", "+\t\t\t\t\tint result = OS.CallNextEventHandler (nextHandler, theEvent);", "+\t\t\t\t\tOS.CFRelease (webViewHandle);", "+\t\t\t\t\treturn result;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf4a9952720ab104bafa7fdfe402f734", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Shell.java", "commitBeforeChange": "53ba736f4633d3d8389e9f96e6bbede3723ea9dc", "commitAfterChange": "f7b2c9990b237c89473402d89842c681d975cc4f", "methodNumberBeforeChange": 47, "methodNumberAfterChange": 47, "signatureBeforeChange": "  int kEventWindowDeactivated (int nextHandler, int theEvent, int userData)", "signatureAfterChange": "  int kEventWindowDeactivated (int nextHandler, int theEvent, int userData)", "diff": ["-\t//TEMPORARY CODE - should be send, but causes a GP", "-\tpostEvent (SWT.Deactivate);", "-\tif (isDisposed ()) return result;", "-\tsaveFocus ();", "-\tif (savedFocus != null) {", "-\t\t/*", "-\t\t* Bug in the Macintosh.  When ClearKeyboardFocus() is called,", "-\t\t* the control that has focus gets two kEventControlSetFocus", "-\t\t* events indicating that focus was lost.  The fix is to ignore", "-\t\t* both of these and send the focus lost event explicitly.", "-\t\t*/", "-\t\tdisplay.ignoreFocus = true;", "-\t\tOS.ClearKeyboardFocus (shellHandle);", "-\t\tdisplay.ignoreFocus = false;", "-\t\t//TEMPORARY CODE - should be send, but causes a GP", "-\t\tif (!savedFocus.isDisposed ()) savedFocus.sendFocusEvent (SWT.FocusOut, true);", "+\t/*", "+\t* Bug in the Macintosh.  The default handler of kEventWindowDeactivated", "+\t* segment faults when DisposeWindow() is called in previous handlers.", "+\t* The fix is to use RetainWindow() so that the window does not get", "+\t* disposed until the handler returns.", "+\t*/", "+\tDisplay display = this.display;", "+\tOS.RetainWindow (shellHandle);", "+\tresult = OS.CallNextEventHandler (nextHandler, theEvent);", "+\tsendEvent (SWT.Deactivate);", "+\tif (!isDisposed ()) {", "+\t\tsaveFocus ();", "+\t\tif (savedFocus != null) {", "+\t\t\t/*", "+\t\t\t* Bug in the Macintosh.  When ClearKeyboardFocus() is called,", "+\t\t\t* the control that has focus gets two kEventControlSetFocus", "+\t\t\t* events indicating that focus was lost.  The fix is to ignore", "+\t\t\t* both of these and send the focus lost event explicitly.", "+\t\t\t*/", "+\t\t\tdisplay.ignoreFocus = true;", "+\t\t\tOS.ClearKeyboardFocus (shellHandle);", "+\t\t\tdisplay.ignoreFocus = false;", "+\t\t\tif (!savedFocus.isDisposed ()) {", "+\t\t\t\tsavedFocus.sendFocusEvent (SWT.FocusOut);", "+\t\t\t}", "+\t\t}", "+\tOS.ReleaseWindow (shellHandle);"]}], "num": 22632}