{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4d4e6b72d34d71630ea1ffd15cb355c7", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4edf99cb5900af95cb2514dcfc548c34", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/DateTime.java", "commitBeforeChange": "039b48a39f4743c6ab82f1863366a1f66153cff5", "commitAfterChange": "282b9b6af8b479272175bca6f47c01c481707c5e", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  public Point computeSize (int wHint, int hHint, boolean changed)", "signatureAfterChange": "  public Point computeSize (int wHint, int hHint, boolean changed)", "diff": ["+", "+\t\t\tTCHAR buffer = new TCHAR (getCodePage (), 128);", "-\t\t\tTEXTMETRIC tm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW () : new TEXTMETRICA ();", "-\t\t\tOS.GetTextMetrics (hDC, tm);", "-\t\t\theight = tm.tmHeight;", "-\t\t\tint upDownHeight = OS.GetSystemMetrics (OS.SM_CYVSCROLL);", "-\t\t\theight = Math.max (height, upDownHeight);", "-\t\t\tString string = \"00/00/0000\"; // TODO: take locale and format into account", "-\t\t\tif ((style & SWT.TIME) != 0) string = \"00:00:00 AM\";", "-\t\t\tTCHAR buffer = new TCHAR (getCodePage (), string, false);", "-\t\t\tOS.DrawText (hDC, buffer, buffer.length (), rect, flags);", "-\t\t\twidth = rect.right - rect.left;", "+\t\t\tSYSTEMTIME systime = new SYSTEMTIME ();", "+\t\t\tif ((style & SWT.DATE) != 0) {", "+\t\t\t\t/* Determine the widest/tallest year string. */", "+\t\t\t\tsystime.wMonth = 1;", "+\t\t\t\tsystime.wDay = 1;", "+\t\t\t\tint widest = 0, secondWidest = 0, thirdWidest = 0;", "+\t\t\t\tfor (int i = 0; i <= MAX_DIGIT; i++) {", "+\t\t\t\t\tsystime.wYear = (short) (2000 + i); // year 2000 + i is guaranteed to exist", "+\t\t\t\t\tint size = OS.GetDateFormat(OS.LOCALE_USER_DEFAULT, OS.DATE_SHORTDATE, systime, null, buffer, buffer.length ());", "+\t\t\t\t\tif (size == 0) {", "+\t\t\t\t\t\tbuffer = new TCHAR (getCodePage (), size);", "+\t\t\t\t\t\tOS.GetDateFormat(OS.LOCALE_USER_DEFAULT, OS.DATE_SHORTDATE, systime, null, buffer, buffer.length ());", "+\t\t\t\t\t}", "+\t\t\t\t\trect.left = rect.top = rect.right = rect.bottom = 0;", "+\t\t\t\t\tOS.DrawText (hDC, buffer, size, rect, flags);", "+\t\t\t\t\tif (rect.right - rect.left >= width) {", "+\t\t\t\t\t\twidth = rect.right - rect.left;", "+\t\t\t\t\t\tthirdWidest = secondWidest;", "+\t\t\t\t\t\tsecondWidest = widest;", "+\t\t\t\t\t\twidest = i;", "+\t\t\t\t\t}", "+\t\t\t\t\theight = Math.max(height, rect.bottom - rect.top);", "+\t\t\t\t}", "+\t\t\t\tif (widest > 1) widest = widest * 1000 + widest * 100 + widest * 10 + widest;", "+\t\t\t\telse if (secondWidest > 1) widest = secondWidest * 1000 + widest * 100 + widest * 10 + widest;", "+\t\t\t\telse widest = thirdWidest * 1000 + widest * 100 + widest * 10 + widest;", "+\t\t\t\tsystime.wYear = (short) widest;", "+", "+\t\t\t\t/* Determine the widest/tallest month name string. */", "+\t\t\t\twidth = widest = 0;", "+\t\t\t\tfor (short i = 0; i < MONTH_NAMES.length; i++) {", "+\t\t\t\t\tint name = MONTH_NAMES [i];", "+\t\t\t\t\tint size = OS.GetLocaleInfo (OS.LOCALE_USER_DEFAULT, name, buffer, buffer.length ());", "+\t\t\t\t\tif (size == 0) {", "+\t\t\t\t\t\tbuffer = new TCHAR (getCodePage (), size);", "+\t\t\t\t\t\tOS.GetLocaleInfo (OS.LOCALE_USER_DEFAULT, name, buffer, buffer.length ());", "+\t\t\t\t\t}", "+\t\t\t\t\trect.left = rect.top = rect.right = rect.bottom = 0;", "+\t\t\t\t\tOS.DrawText (hDC, buffer, size, rect, flags);", "+\t\t\t\t\tif (rect.right - rect.left > width) {", "+\t\t\t\t\t\twidth = rect.right - rect.left;", "+\t\t\t\t\t\twidest = i;", "+\t\t\t\t\t}", "+\t\t\t\t\theight = Math.max(height, rect.bottom - rect.top);", "+\t\t\t\t}", "+\t\t\t\tsystime.wMonth = (short) (widest + 1);", "+", "+\t\t\t\t/* Determine the widest/tallest date string in the widest month of the widest year. */", "+\t\t\t\tint dwFlags = ((style & SWT.MEDIUM) != 0) ? OS.DATE_SHORTDATE : ((style & SWT.SHORT) != 0) ? OS.DATE_YEARMONTH : OS.DATE_LONGDATE;", "+\t\t\t\twidth = 0;", "+\t\t\t\tfor (short i = 1; i <= MAX_DAY; i++) {", "+\t\t\t\t\tsystime.wDay = i;", "+\t\t\t\t\tint size = OS.GetDateFormat(OS.LOCALE_USER_DEFAULT, dwFlags, systime, null, buffer, buffer.length ());", "+\t\t\t\t\tif (size == 0) {", "+\t\t\t\t\t\tbuffer = new TCHAR (getCodePage (), size);", "+\t\t\t\t\t\tOS.GetDateFormat(OS.LOCALE_USER_DEFAULT, dwFlags, systime, null, buffer, buffer.length ());", "+\t\t\t\t\t}", "+\t\t\t\t\trect.left = rect.top = rect.right = rect.bottom = 0;", "+\t\t\t\t\tOS.DrawText (hDC, buffer, size, rect, flags);", "+\t\t\t\t\twidth = Math.max(width, rect.right - rect.left);", "+\t\t\t\t\theight = Math.max(height, rect.bottom - rect.top);", "+\t\t\t\t\tif ((style & SWT.SHORT) != 0) break;", "+\t\t\t\t}", "+\t\t\t} else if ((style & SWT.TIME) != 0) {", "+\t\t\t\t/* Determine the widest/tallest hour string. This code allows for the possibility of ligatures. */", "+\t\t\t\tint dwFlags = ((style & SWT.SHORT) != 0) ? OS.TIME_NOSECONDS : 0;", "+\t\t\t\tshort widest = 0;", "+\t\t\t\tint max = is24HourTime () ? MAX_24HOUR : MAX_12HOUR;", "+\t\t\t\tfor (short i = 0; i < max; i++) {", "+\t\t\t\t\tsystime.wHour = i;", "+\t\t\t\t\tint size = OS.GetTimeFormat(OS.LOCALE_USER_DEFAULT, dwFlags, systime, null, buffer, buffer.length ());", "+\t\t\t\t\tif (size == 0) {", "+\t\t\t\t\t\tbuffer = new TCHAR (getCodePage (), size);", "+\t\t\t\t\t\tOS.GetTimeFormat(OS.LOCALE_USER_DEFAULT, dwFlags, systime, null, buffer, buffer.length ());", "+\t\t\t\t\t}", "+\t\t\t\t\trect.left = rect.top = rect.right = rect.bottom = 0;", "+\t\t\t\t\tOS.DrawText (hDC, buffer, size, rect, flags);", "+\t\t\t\t\tif (rect.right - rect.left > width) {", "+\t\t\t\t\t\twidth = rect.right - rect.left;", "+\t\t\t\t\t\twidest = i;", "+\t\t\t\t\t}", "+\t\t\t\t\theight = Math.max(height, rect.bottom - rect.top);", "+\t\t\t\t}", "+\t\t\t\tsystime.wHour = widest;", "+", "+\t\t\t\t/* Determine the widest/tallest minute and second string. */", "+\t\t\t\twidth = widest = 0;", "+\t\t\t\tfor (short i = 0; i < MAX_MINUTE; i++) {", "+\t\t\t\t\tsystime.wMinute = i;", "+\t\t\t\t\tint size = OS.GetTimeFormat(OS.LOCALE_USER_DEFAULT, dwFlags, systime, null, buffer, buffer.length ());", "+\t\t\t\t\tif (size == 0) {", "+\t\t\t\t\t\tbuffer = new TCHAR (getCodePage (), size);", "+\t\t\t\t\t\tOS.GetTimeFormat(OS.LOCALE_USER_DEFAULT, dwFlags, systime, null, buffer, buffer.length ());", "+\t\t\t\t\t}", "+\t\t\t\t\trect.left = rect.top = rect.right = rect.bottom = 0;", "+\t\t\t\t\tOS.DrawText (hDC, buffer, size, rect, flags);", "+\t\t\t\t\tif (rect.right - rect.left > width) {", "+\t\t\t\t\t\twidth = rect.right - rect.left;", "+\t\t\t\t\t\twidest = i;", "+\t\t\t\t\t}", "+\t\t\t\t\theight = Math.max(height, rect.bottom - rect.top);", "+\t\t\t\t}", "+\t\t\t\tsystime.wMinute = widest;", "+\t\t\t\tsystime.wSecond = widest;", "+", "+\t\t\t\t/* Determine the widest/tallest time string for the widest hour, widest minute, and if applicable, widest second. */", "+\t\t\t\tint size = OS.GetTimeFormat(OS.LOCALE_USER_DEFAULT, dwFlags, systime, null, buffer, buffer.length ());", "+\t\t\t\tif (size == 0) {", "+\t\t\t\t\tbuffer = new TCHAR (getCodePage (), size);", "+\t\t\t\t\tOS.GetTimeFormat(OS.LOCALE_USER_DEFAULT, dwFlags, systime, null, buffer, buffer.length ());", "+\t\t\t\t}", "+\t\t\t\trect.left = rect.top = rect.right = rect.bottom = 0;", "+\t\t\t\tOS.DrawText (hDC, buffer, size, rect, flags);", "+\t\t\t\twidth = rect.right - rect.left;", "+\t\t\t\theight = Math.max(height, rect.bottom - rect.top);", "+\t\t\t}", "+\t\t\tint upDownHeight = OS.GetSystemMetrics (OS.SM_CYVSCROLL);", "+\t\t\theight = Math.max (height, upDownHeight);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "389a30c22488328ed7ddec12733e3d2a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "f5a8e8f2be872aa0f00468cbc5f2b2457a130aec", "commitAfterChange": "bbd54157efbc0546e5afb0c37a5e8c6948a88206", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 8, "signatureBeforeChange": " public void draw(GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground, int flags)", "signatureAfterChange": " public void draw(GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground, int flags)", "diff": ["+\tint length = translateOffset(text.length());", "+\tif (length == 0 && flags == 0) return;", "+\tgc.handle.saveGraphicsState();", "+\t\tNSPoint point = new NSPoint();", "+\t\tfor (int j = 0; j < styles.length; j++) {", "+\t\t\tStyleItem run = styles[j];", "+\t\t\tTextStyle style = run.style;", "+\t\t\tif (style == null) continue;", "+\t\t\tboolean drawUnderline = style.underline && style.underlineStyle != SWT.UNDERLINE_SINGLE && style.underlineStyle != SWT.UNDERLINE_DOUBLE;", "+\t\t\tdrawUnderline = drawUnderline && (j + 1 == styles.length || !style.isAdherentUnderline(styles[j + 1].style)); ", "+\t\t\tboolean drawBorder = style.borderStyle != SWT.NONE;", "+\t\t\tdrawBorder = drawBorder && (j + 1 == styles.length || !style.isAdherentBorder(styles[j + 1].style)); ", "+\t\t\tif (!drawUnderline && !drawBorder) continue;", "+\t\t\tint end = j + 1 < styles.length ? translateOffset(styles[j + 1].start - 1) : length;", "+\t\t\tfor (int i = 0; i < lineOffsets.length - 1; i++) {", "+\t\t\t\tint lineStart = untranslateOffset(lineOffsets[i]);", "+\t\t\t\tint lineEnd = untranslateOffset(lineOffsets[i + 1] - 1);", "+\t\t\t\tif (drawUnderline) {", "+\t\t\t\t\tint start = run.start;", "+\t\t\t\t\tfor (int k = j; k > 0 && style.isAdherentUnderline(styles[k - 1].style); k--) {", "+\t\t\t\t\t\tstart = styles[k - 1].start;", "+\t\t\t\t\t}", "+\t\t\t\t\tstart = translateOffset(start);", "+\t\t\t\t\tif (!(start > lineEnd || end < lineStart)) {", "+\t\t\t\t\t\trange.location = layoutManager.glyphIndexForCharacterAtIndex(Math.max(lineStart, start));", "+\t\t\t\t\t\trange.length = layoutManager.glyphIndexForCharacterAtIndex(Math.min(lineEnd, end) + 1) - range.location;", "+\t\t\t\t\t\tif (range.length > 0) {", "+\t\t\t\t\t\t\tgc.handle.saveGraphicsState();", "+\t\t\t\t\t\t\tNSRect rect = layoutManager.boundingRectForGlyphRange(range, textContainer);", "+\t\t\t\t\t\t\tfloat baseline = layoutManager.typesetter().baselineOffsetInLayoutManager(layoutManager, lineStart);", "+\t\t\t\t\t\t\tfloat underlineX = pt.x + rect.x;", "+\t\t\t\t\t\t\tfloat underlineY = pt.y + rect.y + rect.height - baseline;", "+\t\t\t\t\t\t\tfloat[] color = null;", "+\t\t\t\t\t\t\tif (style.underlineColor != null) color = style.underlineColor.handle;", "+\t\t\t\t\t\t\tif (color == null && style.foreground != null) color = style.foreground.handle;", "+\t\t\t\t\t\t\tif (color != null) {", "+\t\t\t\t\t\t\t\tNSColor.colorWithDeviceRed(color[0], color[1], color[2], color[3]).setStroke();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tNSBezierPath path = NSBezierPath.bezierPath();", "+\t\t\t\t\t\t\tswitch (style.underlineStyle) {", "+\t\t\t\t\t\t\t\tcase SWT.UNDERLINE_ERROR: {", "+\t\t\t\t\t\t\t\t\tpath.setLineWidth(2f);", "+\t\t\t\t\t\t\t\t\tpath.setLineCapStyle(OS.NSRoundLineCapStyle);", "+\t\t\t\t\t\t\t\t\tpath.setLineJoinStyle(OS.NSRoundLineJoinStyle);", "+\t\t\t\t\t\t\t\t\tpath.setLineDash(new float[]{1, 3f}, 2, 0);", "+\t\t\t\t\t\t\t\t\tpoint.x = underlineX;", "+\t\t\t\t\t\t\t\t\tpoint.y = underlineY + 0.5f;", "+\t\t\t\t\t\t\t\t\tpath.moveToPoint(point);", "+\t\t\t\t\t\t\t\t\tpoint.x = underlineX + rect.width;", "+\t\t\t\t\t\t\t\t\tpoint.y = underlineY + 0.5f;", "+\t\t\t\t\t\t\t\t\tpath.lineToPoint(point);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tcase SWT.UNDERLINE_SQUIGGLE: {", "+\t\t\t\t\t\t\t\t\tgc.handle.setShouldAntialias(false);", "+\t\t\t\t\t\t\t\t\tpath.setLineWidth(1.0f);", "+\t\t\t\t\t\t\t\t\tpath.setLineCapStyle(OS.NSButtLineCapStyle);", "+\t\t\t\t\t\t\t\t\tpath.setLineJoinStyle(OS.NSMiterLineJoinStyle);", "+\t\t\t\t\t\t\t\t\tfloat lineBottom = pt.y + rect.y + rect.height;", "+\t\t\t\t\t\t\t\t\tfloat squigglyThickness = 1;", "+\t\t\t\t\t\t\t\t\tfloat squigglyHeight = 2 * squigglyThickness;", "+\t\t\t\t\t\t\t\t\tfloat squigglyY = Math.min(underlineY - squigglyHeight / 2, lineBottom - squigglyHeight - 1);", "+\t\t\t\t\t\t\t\t\tfloat[] points = computePolyline((int)underlineX, (int)squigglyY, (int)(underlineX + rect.width), (int)(squigglyY + squigglyHeight));", "+\t\t\t\t\t\t\t\t\tpoint.x = points[0] + 0.5f;", "+\t\t\t\t\t\t\t\t\tpoint.y = points[1] + 0.5f;", "+\t\t\t\t\t\t\t\t\tpath.moveToPoint(point);", "+\t\t\t\t\t\t\t\t\tfor (int p = 2; p < points.length; p+=2) {", "+\t\t\t\t\t\t\t\t\t\tpoint.x = points[p] + 0.5f;", "+\t\t\t\t\t\t\t\t\t\tpoint.y = points[p+1] + 0.5f;", "+\t\t\t\t\t\t\t\t\t\tpath.lineToPoint(point);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tpath.stroke();", "+\t\t\t\t\t\t\tgc.handle.restoreGraphicsState();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (drawBorder) {", "+\t\t\t\t\tint start = run.start;", "+\t\t\t\t\tfor (int k = j; k > 0 && style.isAdherentBorder(styles[k - 1].style); k--) {", "+\t\t\t\t\t\tstart = styles[k - 1].start;", "+\t\t\t\t\t}", "+\t\t\t\t\tstart = translateOffset(start);", "+\t\t\t\t\tif (!(start > lineEnd || end < lineStart)) {", "+\t\t\t\t\t\trange.location = layoutManager.glyphIndexForCharacterAtIndex(Math.max(lineStart, start));", "+\t\t\t\t\t\trange.length = layoutManager.glyphIndexForCharacterAtIndex(Math.min(lineEnd, end) + 1) - range.location;", "+\t\t\t\t\t\tif (range.length > 0) {", "+\t\t\t\t\t\t\tgc.handle.saveGraphicsState();", "+\t\t\t\t\t\t\tNSRect rect = layoutManager.boundingRectForGlyphRange(range, textContainer);", "+\t\t\t\t\t\t\trect.x += pt.x + 0.5f;", "+\t\t\t\t\t\t\trect.y += pt.y + 0.5f;", "+\t\t\t\t\t\t\tfloat[] color = null;", "+\t\t\t\t\t\t\tif (style.borderColor != null) color = style.borderColor.handle;", "+\t\t\t\t\t\t\tif (color == null && style.foreground != null) color = style.foreground.handle;", "+\t\t\t\t\t\t\tif (color != null) {", "+\t\t\t\t\t\t\t\tNSColor.colorWithDeviceRed(color[0], color[1], color[2], color[3]).setStroke();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tint width = 1;", "+\t\t\t\t\t\t\tfloat[] dashes = null;", "+\t\t\t\t\t\t\tswitch (style.borderStyle) {", "+\t\t\t\t\t\t\t\tcase SWT.BORDER_SOLID:\tbreak;", "+\t\t\t\t\t\t\t\tcase SWT.BORDER_DASH: dashes = width != 0 ? GC.LINE_DASH : GC.LINE_DASH_ZERO; break;", "+\t\t\t\t\t\t\t\tcase SWT.BORDER_DOT: dashes = width != 0 ? GC.LINE_DOT : GC.LINE_DOT_ZERO; break;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tNSBezierPath path = NSBezierPath.bezierPath();", "+\t\t\t\t\t\t\tpath.setLineDash(dashes, dashes != null ? dashes.length : 0, 0);", "+\t\t\t\t\t\t\tpath.appendBezierPathWithRect(rect);", "+\t\t\t\t\t\t\tpath.stroke();", "+\t\t\t\t\t\t\tgc.handle.restoreGraphicsState();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t}", "+\tgc.handle.restoreGraphicsState();"]}], "num": 48660}