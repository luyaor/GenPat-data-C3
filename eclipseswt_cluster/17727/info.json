{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1d05c1845255d0ff04f3cc80f0a70e27", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "74e354d82632b54448d5e8b4f267366a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Cursor.java", "commitBeforeChange": "21541d1c7be3bc786f754e0d8604695c158056de", "commitAfterChange": "4e877ff6e374c0eac9d6ca011beec9646167b530", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public Cursor(Device device, ImageData source, int hotspotX, int hotspotY)", "signatureAfterChange": " public Cursor(Device device, ImageData source, int hotspotX, int hotspotY)", "diff": ["-\tif (device == null) device = Device.getDevice();", "-\tif (device == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);", "-\tthis.device = device;", "+\tsuper(device);", "-\t\tcreateNSCursor(device, hotspotX, hotspotY, data, source.width, source.height);", "-\t\treturn;", "-\t}", "-", "-\tImageData mask = source.getTransparencyMask();", "-", "-\t/* Ensure depth is equal to 1 */", "-\tif (source.depth > 1) {", "-\t\t/* Create a destination image with no data */", "-\t\tImageData newSource = new ImageData(", "-\t\t\tsource.width, source.height, 1, ImageData.bwPalette(),", "-\t\t\t1, null, 0, null, null, -1, -1, 0, 0, 0, 0, 0);", "-", "-\t\tbyte[] newReds = new byte[]{0, (byte)255}, newGreens = newReds, newBlues = newReds;", "-", "-\t\t/* Convert the source to a black and white image of depth 1 */", "-\t\tPaletteData palette = source.palette;", "-\t\tif (palette.isDirect) {", "-\t\t\tImageData.blit(ImageData.BLIT_SRC,", "-\t\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, palette.redMask, palette.greenMask, palette.blueMask,", "-\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "-\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "-\t\t\t\t\tfalse, false);", "-\t\t} else {", "-\t\t\tRGB[] rgbs = palette.getRGBs();", "-\t\t\tint length = rgbs.length;", "-\t\t\tbyte[] srcReds = new byte[length];", "-\t\t\tbyte[] srcGreens = new byte[length];", "-\t\t\tbyte[] srcBlues = new byte[length];", "-\t\t\tfor (int i = 0; i < rgbs.length; i++) {", "-\t\t\t\tRGB rgb = rgbs[i];", "-\t\t\t\tif (rgb == null) continue;", "-\t\t\t\tsrcReds[i] = (byte)rgb.red;", "-\t\t\t\tsrcGreens[i] = (byte)rgb.green;", "-\t\t\t\tsrcBlues[i] = (byte)rgb.blue;", "-\t\t\t}", "-\t\t\tImageData.blit(ImageData.BLIT_SRC,", "-\t\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, srcReds, srcGreens, srcBlues,", "-\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "-\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "-\t\t\t\t\tfalse, false);", "-\t\t}", "-\t\tsource = newSource;", "-\t}", "-", "-\t/* Find the first non transparent pixel if cursor bigger than 16x16. */", "-\tint width = source.width;", "-\tint height = source.height;", "-\tint minX = 0, minY = 0;", "-\tif (width > 16 || height > 16) {", "-\t\tminX = width;", "-\t\tminY = height;", "-\t\tint maxX = 0, maxY = 0;", "-\t\tfor (int y = 0; y < height; y++) {", "-\t\t\tfor (int x = 0; x < width; x++) {", "-\t\t\t\tif (!(source.getPixel(x, y) == 1 && mask.getPixel(x, y) == 0)) {", "-\t\t\t\t\tminX = Math.min(minX, x);", "-\t\t\t\t\tminY = Math.min(minY, y);", "-\t\t\t\t\tmaxX = Math.max(maxX, x);", "-\t\t\t\t\tmaxY = Math.max(maxY, y);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\twidth = maxX - minX + 1;", "-\t\theight = maxY - minY + 1;", "-\t\t", "-\t\t/* Stretch cursor if still bigger than 16x16. */", "-\t\tif (width > 16 || height > 16) {", "-\t\t\tint newWidth = Math.min(width, 16);", "-\t\t\tint newHeight = Math.min(height, 16);", "-\t\t\tImageData newSource =", "-\t\t\t\tnew ImageData(newWidth, newHeight, source.depth, source.palette,", "-\t\t\t\t\t1, null, 0, null, null, -1, -1, source.type,", "-\t\t\t\t\tsource.x, source.y, source.disposalMethod, source.delayTime);", "-\t\t\tImageData newMask = new ImageData(newWidth, newHeight, mask.depth,", "-\t\t\t\t\tmask.palette, 1, null, 0, null, null, -1, -1, mask.type,", "-\t\t\t\t\tmask.x, mask.y, mask.disposalMethod, mask.delayTime);", "-\t\t\tImageData.blit(ImageData.BLIT_SRC,", "-\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), minX, minY, width, height, null, null, null,", "-\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, minX, minY,", "-\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newWidth, newHeight, null, null, null,", "-\t\t\t\tfalse, false);", "-\t\t\tImageData.blit(ImageData.BLIT_SRC,", "-\t\t\t\tmask.data, mask.depth, mask.bytesPerLine, mask.getByteOrder(), minX, minY, width, height, null, null, null,", "-\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, minX, minY,", "-\t\t\t\tnewMask.data, newMask.depth, newMask.bytesPerLine, newMask.getByteOrder(), 0, 0, newWidth, newHeight, null, null, null,", "-\t\t\t\tfalse, false);", "-\t\t\twidth = newWidth;", "-\t\t\theight = newHeight;", "-\t\t\tminX = minY = 0;", "-\t\t\tsource = newSource;", "-\t\t\tmask = newMask;", "-\t\t}", "-\t}", "-", "-\t/* Create the cursor */", "-\torg.eclipse.swt.internal.carbon.Cursor cursor = new org.eclipse.swt.internal.carbon.Cursor();", "-\tbyte[] srcData = cursor.data;", "-\tbyte[] maskData = cursor.mask;", "-\tfor (int y= 0; y < height; y++) {", "-\t\tshort d = 0, m = 0;", "-\t\tfor (int x = 0; x < width; x++) {", "-\t\t\tint bit = 1 << (width - 1 - x);\t\t\t", "-\t\t\tif (source.getPixel(x + minX, y + minY) == 0) {", "-\t\t\t\tif (mask.getPixel(x + minX, y + minY) != 0) {", "-\t\t\t\t\td |= bit;", "-\t\t\t\t\tm |= bit;", "-\t\t\t\t}", "+\t\tcreateNSCursor(hotspotX, hotspotY, data, source.width, source.height);", "+\t} else {", "+\t", "+\t\tImageData mask = source.getTransparencyMask();", "+\t", "+\t\t/* Ensure depth is equal to 1 */", "+\t\tif (source.depth > 1) {", "+\t\t\t/* Create a destination image with no data */", "+\t\t\tImageData newSource = new ImageData(", "+\t\t\t\tsource.width, source.height, 1, ImageData.bwPalette(),", "+\t\t\t\t1, null, 0, null, null, -1, -1, 0, 0, 0, 0, 0);", "+\t", "+\t\t\tbyte[] newReds = new byte[]{0, (byte)255}, newGreens = newReds, newBlues = newReds;", "+\t", "+\t\t\t/* Convert the source to a black and white image of depth 1 */", "+\t\t\tPaletteData palette = source.palette;", "+\t\t\tif (palette.isDirect) {", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, palette.redMask, palette.greenMask, palette.blueMask,", "+\t\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "+\t\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "+\t\t\t\t\t\tfalse, false);", "-\t\t\t\tif (mask.getPixel(x + minX, y + minY) != 0) m |= bit;", "+\t\t\t\tRGB[] rgbs = palette.getRGBs();", "+\t\t\t\tint length = rgbs.length;", "+\t\t\t\tbyte[] srcReds = new byte[length];", "+\t\t\t\tbyte[] srcGreens = new byte[length];", "+\t\t\t\tbyte[] srcBlues = new byte[length];", "+\t\t\t\tfor (int i = 0; i < rgbs.length; i++) {", "+\t\t\t\t\tRGB rgb = rgbs[i];", "+\t\t\t\t\tif (rgb == null) continue;", "+\t\t\t\t\tsrcReds[i] = (byte)rgb.red;", "+\t\t\t\t\tsrcGreens[i] = (byte)rgb.green;", "+\t\t\t\t\tsrcBlues[i] = (byte)rgb.blue;", "+\t\t\t\t}", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, srcReds, srcGreens, srcBlues,", "+\t\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "+\t\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "+\t\t\t\t\t\tfalse, false);", "+\t\t\t}", "+\t\t\tsource = newSource;", "+\t\t}", "+\t", "+\t\t/* Find the first non transparent pixel if cursor bigger than 16x16. */", "+\t\tint width = source.width;", "+\t\tint height = source.height;", "+\t\tint minX = 0, minY = 0;", "+\t\tif (width > 16 || height > 16) {", "+\t\t\tminX = width;", "+\t\t\tminY = height;", "+\t\t\tint maxX = 0, maxY = 0;", "+\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\tfor (int x = 0; x < width; x++) {", "+\t\t\t\t\tif (!(source.getPixel(x, y) == 1 && mask.getPixel(x, y) == 0)) {", "+\t\t\t\t\t\tminX = Math.min(minX, x);", "+\t\t\t\t\t\tminY = Math.min(minY, y);", "+\t\t\t\t\t\tmaxX = Math.max(maxX, x);", "+\t\t\t\t\t\tmaxY = Math.max(maxY, y);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\twidth = maxX - minX + 1;", "+\t\t\theight = maxY - minY + 1;", "+\t\t\t", "+\t\t\t/* Stretch cursor if still bigger than 16x16. */", "+\t\t\tif (width > 16 || height > 16) {", "+\t\t\t\tint newWidth = Math.min(width, 16);", "+\t\t\t\tint newHeight = Math.min(height, 16);", "+\t\t\t\tImageData newSource =", "+\t\t\t\t\tnew ImageData(newWidth, newHeight, source.depth, source.palette,", "+\t\t\t\t\t\t1, null, 0, null, null, -1, -1, source.type,", "+\t\t\t\t\t\tsource.x, source.y, source.disposalMethod, source.delayTime);", "+\t\t\t\tImageData newMask = new ImageData(newWidth, newHeight, mask.depth,", "+\t\t\t\t\t\tmask.palette, 1, null, 0, null, null, -1, -1, mask.type,", "+\t\t\t\t\t\tmask.x, mask.y, mask.disposalMethod, mask.delayTime);", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), minX, minY, width, height, null, null, null,", "+\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, minX, minY,", "+\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newWidth, newHeight, null, null, null,", "+\t\t\t\t\tfalse, false);", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\t\tmask.data, mask.depth, mask.bytesPerLine, mask.getByteOrder(), minX, minY, width, height, null, null, null,", "+\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, minX, minY,", "+\t\t\t\t\tnewMask.data, newMask.depth, newMask.bytesPerLine, newMask.getByteOrder(), 0, 0, newWidth, newHeight, null, null, null,", "+\t\t\t\t\tfalse, false);", "+\t\t\t\twidth = newWidth;", "+\t\t\t\theight = newHeight;", "+\t\t\t\tminX = minY = 0;", "+\t\t\t\tsource = newSource;", "+\t\t\t\tmask = newMask;", "-\t\tsrcData[y * 2] = (byte)(d >> 8);", "-\t\tsrcData[y * 2 + 1] = (byte)(d & 0xFF);", "-\t\tmaskData[y * 2] = (byte)(m >> 8);", "-\t\tmaskData[y * 2 + 1] = (byte)(m & 0xFF);", "+\t", "+\t\t/* Create the cursor */", "+\t\torg.eclipse.swt.internal.carbon.Cursor cursor = new org.eclipse.swt.internal.carbon.Cursor();", "+\t\tbyte[] srcData = cursor.data;", "+\t\tbyte[] maskData = cursor.mask;", "+\t\tfor (int y= 0; y < height; y++) {", "+\t\t\tshort d = 0, m = 0;", "+\t\t\tfor (int x = 0; x < width; x++) {", "+\t\t\t\tint bit = 1 << (width - 1 - x);\t\t\t", "+\t\t\t\tif (source.getPixel(x + minX, y + minY) == 0) {", "+\t\t\t\t\tif (mask.getPixel(x + minX, y + minY) != 0) {", "+\t\t\t\t\t\td |= bit;", "+\t\t\t\t\t\tm |= bit;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tif (mask.getPixel(x + minX, y + minY) != 0) m |= bit;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tsrcData[y * 2] = (byte)(d >> 8);", "+\t\t\tsrcData[y * 2 + 1] = (byte)(d & 0xFF);", "+\t\t\tmaskData[y * 2] = (byte)(m >> 8);", "+\t\t\tmaskData[y * 2 + 1] = (byte)(m & 0xFF);", "+\t\t}", "+\t\tcursor.hotSpot_h = (short)Math.max(0, Math.min(15, hotspotX - minX));", "+\t\tcursor.hotSpot_v = (short)Math.max(0, Math.min(15, hotspotY - minY));", "+\t\thandle = OS.NewPtr(org.eclipse.swt.internal.carbon.Cursor.sizeof);", "+\t\tif (handle == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\tOS.memmove(handle, cursor, org.eclipse.swt.internal.carbon.Cursor.sizeof);", "-\tcursor.hotSpot_h = (short)Math.max(0, Math.min(15, hotspotX - minX));", "-\tcursor.hotSpot_v = (short)Math.max(0, Math.min(15, hotspotY - minY));", "-\thandle = OS.NewPtr(org.eclipse.swt.internal.carbon.Cursor.sizeof);", "-\tif (handle == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\tOS.memmove(handle, cursor, org.eclipse.swt.internal.carbon.Cursor.sizeof);", "+\tinit();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "460574bcbaaff0ea65f326938fb40c1e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Cursor.java", "commitBeforeChange": "80349400ab803a052b05e2e66d42920450d869b7", "commitAfterChange": "3c08b8580835d1415ee214b2ea3d595c752fb587", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public Cursor(Device device, ImageData source, int hotspotX, int hotspotY)", "signatureAfterChange": " public Cursor(Device device, ImageData source, int hotspotX, int hotspotY)", "diff": ["-\tImageData mask = source.getTransparencyMask();", "-", "-\t/* Ensure depth is equal to 1 */", "-\tif (source.depth > 1) {", "-\t\t/* Create a destination image with no data */", "-\t\tImageData newSource = new ImageData(", "-\t\t\tsource.width, source.height, 1, ImageData.bwPalette(),", "-\t\t\t1, null, 0, null, null, -1, -1, 0, 0, 0, 0, 0);", "-", "-\t\tbyte[] newReds = new byte[]{0, (byte)255}, newGreens = newReds, newBlues = newReds;", "-", "-\t\t/* Convert the source to a black and white image of depth 1 */", "-\t\tPaletteData palette = source.palette;", "-\t\tif (palette.isDirect) {", "-\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\tint /*long*/ display = 0;", "+\tif (OS.GTK_VERSION >= OS.VERSION(2, 4, 0) && OS.gdk_display_supports_cursor_color(display = OS.gdk_display_get_default ())) {", "+\t\tint width = source.width;", "+\t\tint height = source.height;", "+\t\tPaletteData palette = source.palette;\t", "+\t\tint /*long*/ pixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, true, 8, width, height);", "+\t\tif (pixbuf == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "+\t\tint /*long*/ data = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\tbyte[] buffer = source.data;", "+\t\tif (!palette.isDirect || source.depth != 24 || stride != source.bytesPerLine || palette.redMask != 0xFF000000 || palette.greenMask != 0xFF0000 || palette.blueMask != 0xFF00) {", "+\t\t\tbuffer = new byte[source.width * source.height * 4];", "+\t\t\tif (palette.isDirect) {", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "-\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "-\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "+\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0, ", "+\t\t\t\t\tbuffer, 32, source.width * 4, ImageData.MSB_FIRST, 0, 0, source.width, source.height, 0xFF000000, 0xFF0000, 0xFF00,", "-\t\t} else {", "-\t\t\tRGB[] rgbs = palette.getRGBs();", "-\t\t\tint length = rgbs.length;", "-\t\t\tbyte[] srcReds = new byte[length];", "-\t\t\tbyte[] srcGreens = new byte[length];", "-\t\t\tbyte[] srcBlues = new byte[length];", "-\t\t\tfor (int i = 0; i < rgbs.length; i++) {", "-\t\t\t\tRGB rgb = rgbs[i];", "-\t\t\t\tif (rgb == null) continue;", "-\t\t\t\tsrcReds[i] = (byte)rgb.red;", "-\t\t\t\tsrcGreens[i] = (byte)rgb.green;", "-\t\t\t\tsrcBlues[i] = (byte)rgb.blue;", "-\t\t\t}", "-\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t} else {", "+\t\t\t\tRGB[] rgbs = palette.getRGBs();", "+\t\t\t\tint length = rgbs.length;", "+\t\t\t\tbyte[] srcReds = new byte[length];", "+\t\t\t\tbyte[] srcGreens = new byte[length];", "+\t\t\t\tbyte[] srcBlues = new byte[length];", "+\t\t\t\tfor (int i = 0; i < rgbs.length; i++) {", "+\t\t\t\t\tRGB rgb = rgbs[i];", "+\t\t\t\t\tif (rgb == null) continue;", "+\t\t\t\t\tsrcReds[i] = (byte)rgb.red;", "+\t\t\t\t\tsrcGreens[i] = (byte)rgb.green;", "+\t\t\t\t\tsrcBlues[i] = (byte)rgb.blue;", "+\t\t\t\t}", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "-\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "+\t\t\t\t\tbuffer, 32, source.width * 4, ImageData.MSB_FIRST, 0, 0, source.width, source.height, 0xFF000000, 0xFF0000, 0xFF00,", "+\t\t\t}", "+\t\t\tif (source.maskData != null || source.transparentPixel != -1) {", "+\t\t\t\tImageData mask = source.getTransparencyMask();", "+\t\t\t\tbyte[] maskData = mask.data;", "+\t\t\t\tint maskBpl = mask.bytesPerLine;", "+\t\t\t\tint offset = 3, maskOffset = 0;", "+\t\t\t\tfor (int y = 0; y<source.height; y++) {", "+\t\t\t\t\tfor (int x = 0; x<source.width; x++) {", "+\t\t\t\t\t\tbuffer[offset] = ((maskData[maskOffset + (x >> 3)]) & (1 << (7 - (x & 0x7)))) != 0 ? (byte)0xff : 0;", "+\t\t\t\t\t\toffset += 4;", "+\t\t\t\t\t}", "+\t\t\t\t\tmaskOffset += maskBpl;", "+\t\t\t\t}", "+\t\t\t} else if (source.alpha != -1) {", "+\t\t\t\tbyte alpha = (byte)source.alpha;", "+\t\t\t\tfor (int i=3; i<buffer.length; i+=4) {", "+\t\t\t\t\tbuffer[i] = alpha;\t\t\t\t", "+\t\t\t\t}", "+\t\t\t} else if (source.alphaData != null) {", "+\t\t\t\tbyte[] alphaData = source.alphaData;", "+\t\t\t\tfor (int i=3; i<buffer.length; i+=4) {", "+\t\t\t\t\tbuffer[i] = alphaData[i/4];", "+\t\t\t\t}", "+\t\t\t}", "-\t\tsource = newSource;", "+\t\tOS.memmove(data, buffer, stride * height);", "+\t\thandle = OS.gdk_cursor_new_from_pixbuf(display, pixbuf, hotspotX, hotspotY);", "+\t\tOS.g_object_unref(pixbuf);", "+\t} else {", "+\t", "+\t\tImageData mask = source.getTransparencyMask();", "+\t", "+\t\t/* Ensure depth is equal to 1 */", "+\t\tif (source.depth > 1) {", "+\t\t\t/* Create a destination image with no data */", "+\t\t\tImageData newSource = new ImageData(", "+\t\t\t\tsource.width, source.height, 1, ImageData.bwPalette(),", "+\t\t\t\t1, null, 0, null, null, -1, -1, 0, 0, 0, 0, 0);", "+\t", "+\t\t\tbyte[] newReds = new byte[]{0, (byte)255}, newGreens = newReds, newBlues = newReds;", "+\t", "+\t\t\t/* Convert the source to a black and white image of depth 1 */", "+\t\t\tPaletteData palette = source.palette;", "+\t\t\tif (palette.isDirect) {", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, palette.redMask, palette.greenMask, palette.blueMask,", "+\t\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "+\t\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "+\t\t\t\t\t\tfalse, false);", "+\t\t\t} else {", "+\t\t\t\tRGB[] rgbs = palette.getRGBs();", "+\t\t\t\tint length = rgbs.length;", "+\t\t\t\tbyte[] srcReds = new byte[length];", "+\t\t\t\tbyte[] srcGreens = new byte[length];", "+\t\t\t\tbyte[] srcBlues = new byte[length];", "+\t\t\t\tfor (int i = 0; i < rgbs.length; i++) {", "+\t\t\t\t\tRGB rgb = rgbs[i];", "+\t\t\t\t\tif (rgb == null) continue;", "+\t\t\t\t\tsrcReds[i] = (byte)rgb.red;", "+\t\t\t\t\tsrcGreens[i] = (byte)rgb.green;", "+\t\t\t\t\tsrcBlues[i] = (byte)rgb.blue;", "+\t\t\t\t}", "+\t\t\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\t\t\t\tsource.data, source.depth, source.bytesPerLine, source.getByteOrder(), 0, 0, source.width, source.height, srcReds, srcGreens, srcBlues,", "+\t\t\t\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "+\t\t\t\t\t\tnewSource.data, newSource.depth, newSource.bytesPerLine, newSource.getByteOrder(), 0, 0, newSource.width, newSource.height, newReds, newGreens, newBlues,", "+\t\t\t\t\t\tfalse, false);", "+\t\t\t}", "+\t\t\tsource = newSource;", "+\t\t}", "+\t", "+\t\t/* Swap the bits in each byte and convert to appropriate scanline pad */", "+\t\tbyte[] sourceData = new byte[source.data.length];", "+\t\tbyte[] maskData = new byte[mask.data.length];", "+\t\tbyte[] data = source.data;", "+\t\tfor (int i = 0; i < data.length; i++) {", "+\t\t\tbyte s = data[i];", "+\t\t\tsourceData[i] = (byte)(((s & 0x80) >> 7) |", "+\t\t\t\t((s & 0x40) >> 5) |", "+\t\t\t\t((s & 0x20) >> 3) |", "+\t\t\t\t((s & 0x10) >> 1) |", "+\t\t\t\t((s & 0x08) << 1) |", "+\t\t\t\t((s & 0x04) << 3) |", "+\t\t\t\t((s & 0x02) << 5) |", "+\t\t\t\t((s & 0x01) << 7));", "+\t\t}", "+\t\tsourceData = ImageData.convertPad(sourceData, source.width, source.height, source.depth, source.scanlinePad, 1);", "+\t\tdata = mask.data;", "+\t\tfor (int i = 0; i < data.length; i++) {", "+\t\t\tbyte s = data[i];", "+\t\t\tmaskData[i] = (byte)(((s & 0x80) >> 7) |", "+\t\t\t\t((s & 0x40) >> 5) |", "+\t\t\t\t((s & 0x20) >> 3) |", "+\t\t\t\t((s & 0x10) >> 1) |", "+\t\t\t\t((s & 0x08) << 1) |", "+\t\t\t\t((s & 0x04) << 3) |", "+\t\t\t\t((s & 0x02) << 5) |", "+\t\t\t\t((s & 0x01) << 7));", "+\t\t}", "+\t\tmaskData = ImageData.convertPad(maskData, mask.width, mask.height, mask.depth, mask.scanlinePad, 1);", "+\t\thandle = createCursor(sourceData, maskData, source.width, source.height, hotspotX, hotspotY, false);", "-", "-\t/* Swap the bits in each byte and convert to appropriate scanline pad */", "-\tbyte[] sourceData = new byte[source.data.length];", "-\tbyte[] maskData = new byte[mask.data.length];", "-\tbyte[] data = source.data;", "-\tfor (int i = 0; i < data.length; i++) {", "-\t\tbyte s = data[i];", "-\t\tsourceData[i] = (byte)(((s & 0x80) >> 7) |", "-\t\t\t((s & 0x40) >> 5) |", "-\t\t\t((s & 0x20) >> 3) |", "-\t\t\t((s & 0x10) >> 1) |", "-\t\t\t((s & 0x08) << 1) |", "-\t\t\t((s & 0x04) << 3) |", "-\t\t\t((s & 0x02) << 5) |", "-\t\t\t((s & 0x01) << 7));", "-\t}", "-\tsourceData = ImageData.convertPad(sourceData, source.width, source.height, source.depth, source.scanlinePad, 1);", "-\tdata = mask.data;", "-\tfor (int i = 0; i < data.length; i++) {", "-\t\tbyte s = data[i];", "-\t\tmaskData[i] = (byte)(((s & 0x80) >> 7) |", "-\t\t\t((s & 0x40) >> 5) |", "-\t\t\t((s & 0x20) >> 3) |", "-\t\t\t((s & 0x10) >> 1) |", "-\t\t\t((s & 0x08) << 1) |", "-\t\t\t((s & 0x04) << 3) |", "-\t\t\t((s & 0x02) << 5) |", "-\t\t\t((s & 0x01) << 7));", "-\t}", "-\tmaskData = ImageData.convertPad(maskData, mask.width, mask.height, mask.depth, mask.scanlinePad, 1);", "-\thandle = createCursor(sourceData, maskData, source.width, source.height, hotspotX, hotspotY, false);"]}], "num": 17727}