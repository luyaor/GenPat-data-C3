{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "45853b7075bce693ad42bf4b9f8217f0", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7aa1f2c25a103decb35834d999f683a0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 88, "signatureBeforeChange": " public void setCursorLocation (Point point)", "signatureAfterChange": " public void setCursorLocation (Point point)", "diff": ["-\t/* AW", "-\tint x = point.x;", "-\tint y = point.y;", "-\tint xWindow = OS.XDefaultRootWindow (xDisplay);\t", "-\tOS.XWarpPointer (xDisplay, OS.None, xWindow, 0, 0, 0, 0, x, y);", "-\t*/", "-\tSystem.out.println(\"Display.setCursorLocation: nyi\");", "+\t/* Not possible on the MAC */"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7706a3f03029ac0edbd6cb220fc7b08b", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/List.java", "commitBeforeChange": "441698ecc1c76f73e590da9afb5676ceb4571947", "commitAfterChange": "7e69644e833915ee961adff3b1882f037d334978", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " public int getItemHeight ()", "signatureAfterChange": " public int getItemHeight ()", "diff": ["-    /* AW", "-\tint [] argList = {", "-\t\tOS.XmNlistSpacing, 0,", "-\t\tOS.XmNhighlightThickness, 0,", "-\t};", "-\tOS.XtGetValues (handle, argList, argList.length / 2);", "-\tint spacing = argList [1], highlight = argList [3];", "-    */", "-", "-\t/* Result is from empirical analysis on Linux and AIX */", "-    /* AW", "-\treturn getFontHeight () + spacing + highlight + 1;", "-    */", "-\tSystem.out.println(\"List.getItemHeight: nyi\");", "-    return 15;", "+    return 15;\t// AW FIXME"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b821710092bdbf2e38f1686011a7ed56", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/Browser.java", "commitBeforeChange": "8e1de6b463cb1084376d836a06e1d4f89bfc89ec", "commitAfterChange": "e4bc9c1893ead2ce8ed6f65933742cbfa25be732", "methodNumberBeforeChange": 138, "methodNumberAfterChange": 138, "signatureBeforeChange": "  int GetParentContentListener(int aParentContentListener)", "signatureAfterChange": "  int GetParentContentListener(int aParentContentListener)", "diff": ["-\tSystem.out.println(\"GetParentContentListener\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37ebf99a4fa48dbe60e1b6ec7eab4601", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt.tools/Icon Exe/org/eclipse/swt/tools/internal/IconExe.java", "commitBeforeChange": "fd29b07c522020c818f089c05b20e841a030b6ae", "commitAfterChange": "d45aeac5268f4e6f69621886a5f2ecb1c85e2e92", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " static void read(RandomAccessFile raf, BITMAPINFO bi) throws IOException", "signatureAfterChange": " static void read(RandomAccessFile raf, BITMAPINFO bi) throws IOException", "diff": ["-\tSystem.out.println(\"Reading BITMAPINFO\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "42028a048c4e48b32c7acd227f459a3f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": "  int SetDisplayDirectory (int aDisplayDirectory)", "signatureAfterChange": "  int SetDisplayDirectory (int aDisplayDirectory)", "diff": ["-\tSystem.out.println (\"setDisplayDirectory\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35975701d72e7336ca02e2eba0ee1875", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT WebKit/win32/org/eclipse/swt/browser/WebResourceLoadDelegate.java", "commitBeforeChange": "84e2194382eb044cc0a46bec2dd85e002621f923", "commitAfterChange": "75abf36cc26bfc01a3c5f0723da357390874f8e9", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "  void disposeCOMInterfaces ()", "signatureAfterChange": "  void disposeCOMInterfaces ()", "diff": ["-\tSystem.out.println (\"======== disposing iWebResourceLoadDelegate\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c08c059ada50fe77ea3414df8710e76d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "270311675f6f4cbc05a4249ece03af1024375670", "commitAfterChange": "3321329afa864a6d5f9cfdadb85b6a9464a2fcf4", "methodNumberBeforeChange": 107, "methodNumberAfterChange": 108, "signatureBeforeChange": "  void applicationSendMouseEvent (NSEvent nsEvent, boolean send)", "signatureAfterChange": "  void applicationSendMouseEvent (NSEvent nsEvent, boolean send)", "diff": ["-\t\t\t\tSystem.out.println(\"set\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "83aa1f8666d326cc2d4d5e9ce0e1c5d0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": "  int AppendFilter (int title, int filter)", "signatureAfterChange": "  int AppendFilter (int title, int filter)", "diff": ["-\tSystem.out.println (\"appendfilter\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6c5c0ca8181738877ed0d907359ec46c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Combo.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " public void deselectAll ()", "signatureAfterChange": "  public void deselectAll ()", "diff": ["- */", "+", "-\tcheckWidget();", "-    /* AW", "-\tint [] argList = {OS.XmNtextField, 0, OS.XmNlist, 0};", "-\tOS.XtGetValues (handle, argList, argList.length / 2);", "-\tDisplay display = getDisplay ();", "-\tboolean warnings = display.getWarnings ();", "-\tdisplay.setWarnings (false);", "-\tOS.XmTextSetString (argList[1], new byte[1]);", "-\tOS.XmTextSetInsertionPosition (argList[1], 0);", "-\tdisplay.setWarnings(warnings);", "-\tOS.XmListDeselectAllItems (argList[3]);", "-    */", "-\tSystem.out.println(\"Combo.deselectAll: nyi\");", "+\tcheckWidget ();", "+\t// NEEDS WORK"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "953ef6df08d6ac6ff1c7dad2196d5398", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": "  int SetFilterIndex (int aFilterIndex)", "signatureAfterChange": "  int SetFilterIndex (int aFilterIndex)", "diff": ["-int /*long*/ SetFilterIndex (int aFilterIndex) {", "-\tSystem.out.println (\"setfilterIndex\");", "+int /*long*/ SetFilterIndex (int /*long*/ aFilterIndex) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5249f10524df43c0d371b84254394dcd", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/WidgetTable.java", "commitBeforeChange": "817d020b7e5b06625624b398b21d44141fefd021", "commitAfterChange": "eb426dd094d07f2d63380874ea09a281f1204008", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tprivate static int getUserData(int handle)", "signatureAfterChange": "  \tprivate static int getUserData(int handle)", "diff": ["-\t\tSystem.out.println(\"WidgetTable.getUserData: unknown handle type\");", "+\t\t//System.out.println(\"WidgetTable.getUserData: unknown handle type\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b73076b6d1d789f8bfb7445b5b65a6cf", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "9f3483299f026e38e0d71cbf34135a72e005a99e", "commitAfterChange": "6543d4f86414a284b61a90b586d6044af5964aa4", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  void addToDisposeWindow (int control)", "signatureAfterChange": "  void addToDisposeWindow (int control)", "diff": ["-\tSystem.out.println(\"here\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "539417d8d6f26369b4e4c43f8c33ee99", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Text.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 56, "methodNumberAfterChange": 56, "signatureBeforeChange": " public void setTabs (int tabs)", "signatureAfterChange": "  public void setTabs (int tabs)", "diff": ["- */", "+", "-\tSystem.out.println(\"Text.setTabs: nyi\");", "+\t//NOT DONE"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f11cc74ee7d8b9d5c95a3245143a2657", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT WebKit/win32/org/eclipse/swt/browser/WebKit.java", "commitBeforeChange": "84e2194382eb044cc0a46bec2dd85e002621f923", "commitAfterChange": "75abf36cc26bfc01a3c5f0723da357390874f8e9", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "  boolean handleEvent (Object[] arguments)", "signatureAfterChange": "  boolean handleEvent (Object[] arguments)", "diff": ["-\t\tSystem.out.println(\"keypress\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1417d91ebd46f02ab5edb1743a090d24", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Combo.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " public void deselect (int index)", "signatureAfterChange": "  public void deselect (int index)", "diff": ["- */", "-public void deselect (int index) {", "-\tcheckWidget();", "-\tif (index == -1) return;", "-    /* AW", "-\tint [] argList = {OS.XmNtextField, 0, OS.XmNlist, 0};", "-\tOS.XtGetValues (handle, argList, argList.length / 2);", "-", "-\tif (OS.XmListPosSelected (argList[3], index + 1)) {", "-\t\tDisplay display = getDisplay ();", "-\t\tboolean warnings = display.getWarnings ();", "-\t\tdisplay.setWarnings (false);", "-\t\tOS.XmTextSetString (argList[1], new byte[1]);", "-\t\tOS.XmTextSetInsertionPosition (argList[1], 0);", "-\t\tdisplay.setWarnings (warnings);", "-\t\tOS.XmListDeselectAllItems (argList[3]);", "-    */", "-\tSystem.out.println(\"Combo.deselect: nyi\");", "+", "+public void deselect (int index) {", "+\tcheckWidget ();", "+\tif (index == -1) return;", "+\t// NEEDS WORK", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "47ca664285bc33682c1e0d595d2f70c4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Text.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 49, "methodNumberAfterChange": 50, "signatureBeforeChange": " public void setDoubleClickEnabled (boolean doubleClick)", "signatureAfterChange": "  public void setDoubleClickEnabled (boolean doubleClick)", "diff": ["- */", "+", "-\tSystem.out.println(\"Text.setDoubleClickEnabled: nyi\");", "+\t//NOT DONE"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b5d706975d1e78d62b5bf2a27bfbfe05", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT WebKit/win32/org/eclipse/swt/browser/WebFrameLoadDelegate.java", "commitBeforeChange": "84e2194382eb044cc0a46bec2dd85e002621f923", "commitAfterChange": "75abf36cc26bfc01a3c5f0723da357390874f8e9", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 28, "signatureBeforeChange": "  void disposeCOMInterfaces ()", "signatureAfterChange": "  void disposeCOMInterfaces ()", "diff": ["-\tSystem.out.println (\"======== disposing iWebResourceLoadDelegate\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ccc32e6bd512d2bc572547596ea51809", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/Browser.java", "commitBeforeChange": "8e1de6b463cb1084376d836a06e1d4f89bfc89ec", "commitAfterChange": "e4bc9c1893ead2ce8ed6f65933742cbfa25be732", "methodNumberBeforeChange": 133, "methodNumberAfterChange": 133, "signatureBeforeChange": "  int DoContent(int aContentType, int aIsContentPreferred, int aRequest, int aContentHandler, int retval)", "signatureAfterChange": "  int DoContent(int aContentType, int aIsContentPreferred, int aRequest, int aContentHandler, int retval)", "diff": ["-\tSystem.out.println(\"DoContent\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3e963255a25c36a1e0a5a78e974015f4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": "  int SetDefaultExtension (int aDefaultExtension)", "signatureAfterChange": "  int SetDefaultExtension (int aDefaultExtension)", "diff": ["-\tSystem.out.println (\"setdefaultextenstion\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5971efd98e487ba32782a7aa4b6e7f3", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 106, "methodNumberAfterChange": 93, "signatureBeforeChange": " public void setCapture (boolean capture)", "signatureAfterChange": "  public void setCapture (boolean capture)", "diff": ["- */", "+", "-\tSystem.out.println(\"Control.setCapture: nyi\");", "-    /* AW", "-\tint display = OS.XtDisplay (handle);", "-\tif (display == 0) return;", "-\tif (capture) {", "-\t\tint window = OS.XtWindow (handle);", "-\t\tif (window == 0) return;", "-\t\tOS.XGrabPointer (", "-\t\t\tdisplay,", "-\t\t\twindow,", "-\t\t\t0,", "-\t\t\tOS.ButtonPressMask | OS.ButtonReleaseMask | OS.PointerMotionMask,", "-\t\t\tOS.GrabModeAsync,", "-\t\t\tOS.GrabModeAsync,", "-\t\t\tOS.None,", "-\t\t\tOS.None,", "-\t\t\tOS.CurrentTime);", "-\t} else {", "-\t\tOS.XUngrabPointer (display, OS.CurrentTime);", "-\t}", "-    */"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64af7257847224ab1565fd6141bc66fa", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Text.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 27, "signatureBeforeChange": " public int getTabs ()", "signatureAfterChange": "  public int getTabs ()", "diff": ["- */", "+", "-\tSystem.out.println(\"Text.getTabs: nyi\");", "+\t//NOT DONE"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7b27f3f9b9ba1b8476f409b29c20edb", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "  int GetDefaultExtension (int aDefaultExtension)", "signatureAfterChange": "  int GetDefaultExtension (int aDefaultExtension)", "diff": ["-\tSystem.out.println (\"getdefaultExtension\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0e6597f54a8c50c74a9ba210703e8d7f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Program/carbon/org/eclipse/swt/program/Program.java", "commitBeforeChange": "dbaf6279fdf8d1e5c5ef2e92b28674ef4c342450", "commitAfterChange": "6ad28ad2be841d2ecf6970e35ef7f33af531b76a", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public static Program [] getPrograms ()", "signatureAfterChange": " public static Program [] getPrograms ()", "diff": ["-\tSystem.out.println(\"Program.getPrograms(): nyi\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53ed55e6a6b5e379b5d4878c526419c4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "a98503827d1aabef4c53d8f7b2a8a5c42d3bfa05", "commitAfterChange": "072c09f2419cfe4928d2b0aab5eb7ffa2e8beec6", "methodNumberBeforeChange": 82, "methodNumberAfterChange": 82, "signatureBeforeChange": " \t \tprivate int handleControlProc(int inCallRef, int inEvent, int cHandle)", "signatureAfterChange": " \t \tprivate int handleControlProc(int inCallRef, int inEvent, int cHandle)", "diff": ["-\t\t\t\tSystem.out.println(\"Display.kEventControlDraw\");", "+\t\t\t\t//System.out.println(\"Display.kEventControlDraw\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a8a5868d4c3ac7369a75335acfa17e2a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Text.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 18, "signatureBeforeChange": " public boolean getDoubleClickEnabled ()", "signatureAfterChange": "  public boolean getDoubleClickEnabled ()", "diff": ["- */", "+", "-\tSystem.out.println(\"Text.getDoubleClickEnabled: nyi\");", "+\t//NOT DONE"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e4801f5875fe1b7693da30160f7a423", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples/src/org/eclipse/swt/examples/fileviewer/TreeDropFeedbackListener.java", "commitBeforeChange": "e19f3ee2e5f1fa5577672314ef96ca3ab839cf03", "commitAfterChange": "2dab2a914e742bae70df94e0205c4aa40ea8625c", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r\t\tpublic void run()", "signatureAfterChange": "\r\t\tpublic void run()", "diff": ["-package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = tree.getItem(point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\r\t\t/*\r\t\t * Determine the candidate action for this position: nothing, scroll or expand\r\t\t */\r\t\thoverRunnable = null;\r\t\tif (hoverItem == null) return; // Nothing to do\r\r\t\t// Consider scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\t/**\r\t * Implements scrolling on a timer\r\t */\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Scroll\");\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tif (hoverItem != tree.getItem(hoverPoint)) return; // stop if we actually scrolled\r\t\t\t}\r\t\t\t\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\t/**\r\t * Implements expanding on a timer\r\t */\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Expand\");\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file", "+package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = getItem(tree, point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thandleHoverOverItem(item, point);\r\t}\r\t\t\r\tprivate void handleHoverOverItem(TreeItem item, Point point) {\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\t\thoverRunnable = null;\r\t\tif (item == null) return;\r\r\t\t// Try scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 32); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (hoverPoint.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (hoverPoint.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\t\t\r\t\t// Try expanding\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tTreeItem visibleItem = getItem(tree, hoverPoint);\t\t\t\t\r\t\t\t\tif (hoverItem != visibleItem) {\r\t\t\t\t\t// We actually scrolled, retrigger the scroll timer\r\t\t\t\t\thandleHoverOverItem(visibleItem, hoverPoint);\r\t\t\t\t\treturn;\r\t\t\t\t}\r\t\t\t}\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r\t\r\t/**\r\t * Foreign method: workaround for PR_1GG07HW\r\t */\r\tprivate TreeItem getItem(Tree tree, Point point) {\r\t\tPoint tempPoint = new Point(point.x, point.y);\r\t\treturn tree.getItem(tempPoint);\r\t}\r}\r", "\\ No newline at end of file"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f7a8c40d0c1db1c4807bff625bcb2cc6", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "  int Show (int _retval)", "signatureAfterChange": "  int Show (int _retval)", "diff": ["-\tSystem.out.println (\"show\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d66edea3b6ffef11cf8c176ed39fe5fc", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/Browser.java", "commitBeforeChange": "8e1de6b463cb1084376d836a06e1d4f89bfc89ec", "commitAfterChange": "e4bc9c1893ead2ce8ed6f65933742cbfa25be732", "methodNumberBeforeChange": 135, "methodNumberAfterChange": 135, "signatureBeforeChange": "  int CanHandleContent(int aContentType, int aIsContentPreferred, int aDesiredContentType, int retval)", "signatureAfterChange": "  int CanHandleContent(int aContentType, int aIsContentPreferred, int aDesiredContentType, int retval)", "diff": ["-\tSystem.out.println(\"CanHandleContent\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "994cea561a5dc0a7364d1f27fd7b28a8", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "  int GetFileURL (int aFileURL)", "signatureAfterChange": "  int GetFileURL (int aFileURL)", "diff": ["-\tSystem.out.println (\"GetFileURL\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2718f4e8dc5a58d5642d930285633da9", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Program/carbon/org/eclipse/swt/program/Program.java", "commitBeforeChange": "dbaf6279fdf8d1e5c5ef2e92b28674ef4c342450", "commitAfterChange": "6ad28ad2be841d2ecf6970e35ef7f33af531b76a", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public boolean execute (String fileName)", "signatureAfterChange": " public boolean execute (String fileName)", "diff": ["-\tSystem.out.println(\"Program.execute: nyi\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a051cc8e972b3465b2c93985970933c4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Drag and Drop/cocoa/org/eclipse/swt/dnd/DragSource.java", "commitBeforeChange": "94ee50f052330bf1102a0babd145601ec94d42ef", "commitAfterChange": "650b44b6ff0b7c524ca1fb3e55eadbe4126469d0", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  void drag(Event dragEvent)", "signatureAfterChange": "  void drag(Event dragEvent)", "diff": ["-\t\t\tSystem.out.println(\"Drag failed\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2c3078ce8205e3bcf997aa9b8469b3ce", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 43, "signatureBeforeChange": "  int AppendFilters (int filterMask)", "signatureAfterChange": "  int AppendFilters (int filterMask)", "diff": ["-int /*long*/ AppendFilters (int filterMask) {", "-\tSystem.out.println (\"append filters\");", "+int /*long*/ AppendFilters (int /*long*/ filterMask) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7318d52a3605f63aadffad661e3f76f6", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "af9f857dda29d2ee1989cc89928edc6e0958ebc8", "commitAfterChange": "4b24af5ef710affbf05bf5fb1df78e69400546d5", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 40, "signatureBeforeChange": " protected void init ()", "signatureAfterChange": " protected void init ()", "diff": ["-\tSystem.out.println(\"Display: Mon 3.6.2002\");", "+\t//System.out.println(\"Display: Mon 3.6.2002\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e37ff5282c19939902fd5f851fc06da7", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/wpf/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "4d0cb802366fe6174a4b8ac8db904ee38766dceb", "commitAfterChange": "3edefe918cbcf08416c7a9bed9f1094333bb75a3", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "  int GetPrecedingText(int textSourceCharacterIndexLimit)", "signatureAfterChange": "  int GetPrecedingText(int textSourceCharacterIndexLimit)", "diff": ["-\tSystem.out.println(\"GetPrecedingText\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e14ae47134f8496b0c7b474c1be60935", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples/src/org/eclipse/swt/examples/fileviewer/TreeDropFeedbackListener.java", "commitBeforeChange": "e19f3ee2e5f1fa5577672314ef96ca3ab839cf03", "commitAfterChange": "2dab2a914e742bae70df94e0205c4aa40ea8625c", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r\t\tpublic void run()", "signatureAfterChange": "\r\t\tpublic void run()", "diff": ["-package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = tree.getItem(point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\r\t\t/*\r\t\t * Determine the candidate action for this position: nothing, scroll or expand\r\t\t */\r\t\thoverRunnable = null;\r\t\tif (hoverItem == null) return; // Nothing to do\r\r\t\t// Consider scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\t/**\r\t * Implements scrolling on a timer\r\t */\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Scroll\");\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tif (hoverItem != tree.getItem(hoverPoint)) return; // stop if we actually scrolled\r\t\t\t}\r\t\t\t\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\t/**\r\t * Implements expanding on a timer\r\t */\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Expand\");\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file", "+package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = getItem(tree, point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thandleHoverOverItem(item, point);\r\t}\r\t\t\r\tprivate void handleHoverOverItem(TreeItem item, Point point) {\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\t\thoverRunnable = null;\r\t\tif (item == null) return;\r\r\t\t// Try scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 32); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (hoverPoint.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (hoverPoint.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\t\t\r\t\t// Try expanding\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tTreeItem visibleItem = getItem(tree, hoverPoint);\t\t\t\t\r\t\t\t\tif (hoverItem != visibleItem) {\r\t\t\t\t\t// We actually scrolled, retrigger the scroll timer\r\t\t\t\t\thandleHoverOverItem(visibleItem, hoverPoint);\r\t\t\t\t\treturn;\r\t\t\t\t}\r\t\t\t}\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r\t\r\t/**\r\t * Foreign method: workaround for PR_1GG07HW\r\t */\r\tprivate TreeItem getItem(Tree tree, Point point) {\r\t\tPoint tempPoint = new Point(point.x, point.y);\r\t\treturn tree.getItem(tempPoint);\r\t}\r}\r", "\\ No newline at end of file"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a9cd74d42b721beb1d00250a4ba93fc1", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Composite.java", "commitBeforeChange": "fdc9248d03d4b397469801ab1d72ab3da82e815a", "commitAfterChange": "c350a7eb9c3c08f74a866125090e4096b6706dec", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 62, "signatureBeforeChange": "  LRESULT WM_NCHITTEST (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_NCHITTEST (int wParam, int lParam)", "diff": ["-\t\t\tSystem.out.println(\"HI\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf5e1bd83fd90c31c843e3475cf9f748", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Caret.java", "commitBeforeChange": "374a9aef6d3cdbe23142c7622f439f5425ecaa80", "commitAfterChange": "ed307d3f65dabf3aa5aefbc1cbd79da8679af838", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " public void setImage (Image image)", "signatureAfterChange": " public void setImage (Image image)", "diff": ["-\tSystem.out.println(\"Caret.setImage: nyi\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1c2704a5716516ebd37d0275f364021d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 40, "signatureBeforeChange": "  int SetDefaultString (int aDefaultString)", "signatureAfterChange": "  int SetDefaultString (int aDefaultString)", "diff": ["-\tSystem.out.println (\"setdefaultstring\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fb990f3d507509a70c99e952f3053a4c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT WebKit/win32/org/eclipse/swt/browser/WebDownloadDelegate.java", "commitBeforeChange": "84e2194382eb044cc0a46bec2dd85e002621f923", "commitAfterChange": "75abf36cc26bfc01a3c5f0723da357390874f8e9", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "  void disposeCOMInterfaces ()", "signatureAfterChange": "  void disposeCOMInterfaces ()", "diff": ["-\tSystem.out.println (\"======== disposing iWebDownloadDelegate\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e478ac2037252b39ae254a982e3dd9aa", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT WebKit/win32/org/eclipse/swt/browser/WebUIDelegate.java", "commitBeforeChange": "84e2194382eb044cc0a46bec2dd85e002621f923", "commitAfterChange": "75abf36cc26bfc01a3c5f0723da357390874f8e9", "methodNumberBeforeChange": 72, "methodNumberAfterChange": 72, "signatureBeforeChange": "  protected void disposeCOMInterfaces ()", "signatureAfterChange": "  protected void disposeCOMInterfaces ()", "diff": ["-\tSystem.out.println (\"======== disposing iWebUIDelegate\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa5f5dcaa8703b0f8df631c7534adcb0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": "  int GetFile (int aFile)", "signatureAfterChange": "  int GetFile (int aFile)", "diff": ["-\tSystem.out.println (\"getFile\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "22c93f163778575d38c1f7fe8f7d2a94", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples/org/eclipse/swt/examples/fileviewer/TreeDropFeedbackListener.java", "commitBeforeChange": "e19f3ee2e5f1fa5577672314ef96ca3ab839cf03", "commitAfterChange": "2dab2a914e742bae70df94e0205c4aa40ea8625c", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r\t\tpublic void run()", "signatureAfterChange": "\r\t\tpublic void run()", "diff": ["-package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = tree.getItem(point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\r\t\t/*\r\t\t * Determine the candidate action for this position: nothing, scroll or expand\r\t\t */\r\t\thoverRunnable = null;\r\t\tif (hoverItem == null) return; // Nothing to do\r\r\t\t// Consider scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\t/**\r\t * Implements scrolling on a timer\r\t */\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Scroll\");\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tif (hoverItem != tree.getItem(hoverPoint)) return; // stop if we actually scrolled\r\t\t\t}\r\t\t\t\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\t/**\r\t * Implements expanding on a timer\r\t */\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Expand\");\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file", "+package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = getItem(tree, point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thandleHoverOverItem(item, point);\r\t}\r\t\t\r\tprivate void handleHoverOverItem(TreeItem item, Point point) {\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\t\thoverRunnable = null;\r\t\tif (item == null) return;\r\r\t\t// Try scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 32); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (hoverPoint.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (hoverPoint.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\t\t\r\t\t// Try expanding\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tTreeItem visibleItem = getItem(tree, hoverPoint);\t\t\t\t\r\t\t\t\tif (hoverItem != visibleItem) {\r\t\t\t\t\t// We actually scrolled, retrigger the scroll timer\r\t\t\t\t\thandleHoverOverItem(visibleItem, hoverPoint);\r\t\t\t\t\treturn;\r\t\t\t\t}\r\t\t\t}\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r\t\r\t/**\r\t * Foreign method: workaround for PR_1GG07HW\r\t */\r\tprivate TreeItem getItem(Tree tree, Point point) {\r\t\tPoint tempPoint = new Point(point.x, point.y);\r\t\treturn tree.getItem(tempPoint);\r\t}\r}\r", "\\ No newline at end of file"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76315599b6ed699b9a7795a4c722e7b0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "tests/org.eclipse.swt.tests/JUnit Tests/org/eclipse/swt/tests/junit/performance/PerformanceTests.java", "commitBeforeChange": "9f67525fcf8175adc34d42c0a60e179c1bc70371", "commitAfterChange": "c29a8067b2558bf41e2edb517d0d46b3ae68ff66", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public static Test suite()", "signatureAfterChange": " public static Test suite()", "diff": ["-System.out.println(\"PerformanceTests suite\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5dd9d547dab9a2e476f1e4cb0fcdbc41", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/StyledText2.java", "commitBeforeChange": "a45e2f0f4688ba8750d124e41802861dc3176c91", "commitAfterChange": "26e521309364bb658cf1c93d5815f7e3f172acfd", "methodNumberBeforeChange": 142, "methodNumberAfterChange": 142, "signatureBeforeChange": " int getLineIndex(int y)", "signatureAfterChange": " int getLineIndex(int y)", "diff": ["-\t\t\tSystem.out.println(\"Warning y of bounds!\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "73b1a52c4300f36a98baf16b504d1be8", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "tests/org.eclipse.swt.tests/JUnit Tests/org/eclipse/swt/tests/junit/performance/PerformanceTests.java", "commitBeforeChange": "9f67525fcf8175adc34d42c0a60e179c1bc70371", "commitAfterChange": "c29a8067b2558bf41e2edb517d0d46b3ae68ff66", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  public static void main(String[] args)", "signatureAfterChange": "  public static void main(String[] args)", "diff": ["-System.out.println(\"PerformanceTests main\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9929e6e8f0eab4be545bd7c4aae55aec", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 10, "signatureBeforeChange": " public Color getBackground()", "signatureAfterChange": " public Color getBackground()", "diff": ["-    /* AW", "-\tXColor xColor = new XColor();", "-\txColor.pixel = transparentPixel;", "-\tint xDisplay = device.xDisplay;", "-\tint colormap = OS.XDefaultColormap(xDisplay, OS.XDefaultScreen(xDisplay));", "-\tOS.XQueryColor(xDisplay, colormap, xColor);", "-\treturn Color.motif_new(device, xColor);", "-    */", "-    System.out.println(\"Image.getBackground: nyi\");", "-    return null;", "+\t//NOT DONE", "+\treturn null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e656202617c961f0f97f7da7463b9988", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": "  int GetFilterIndex (int aFilterIndex)", "signatureAfterChange": "  int GetFilterIndex (int aFilterIndex)", "diff": ["-int /*long*/ GetFilterIndex (int aFilterIndex) {", "-\tSystem.out.println (\"GetfilterIndex\");", "+int /*long*/ GetFilterIndex (int /*long*/ aFilterIndex) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a14b0489030f9c9e1ee92fa69b3121dc", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": "  int GetFiles (int aFiles)", "signatureAfterChange": "  int GetFiles (int aFiles)", "diff": ["-\tSystem.out.println (\"GetFiles\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6a60fb115dfeba6e1bdccdd06648a8c8", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "2a180dfeaa2951cd220771e41cafa4df4b78b6bf", "commitAfterChange": "4841a51a2075dd9993c2d9e6fd1223095bff65c5", "methodNumberBeforeChange": 69, "methodNumberAfterChange": 69, "signatureBeforeChange": " \t \tpublic int carbon_CG_focus()", "signatureAfterChange": " \t \tpublic int carbon_CG_focus()", "diff": ["-\t\t\tSystem.out.println(\"CGContext created\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "208d652ca81c9467e55d542e9763e854", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Combo.java", "commitBeforeChange": "efa431b22367daecedf319a17a6a3a2d78fe0884", "commitAfterChange": "1077b201d37c3f7adca243845580b48f6725fb47", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "  int kEventTextInputUnicodeForKeyEvent (int nextHandler, int theEvent, int userData)", "signatureAfterChange": "  int kEventTextInputUnicodeForKeyEvent (int nextHandler, int theEvent, int userData)", "diff": ["-\tSystem.out.println(\"Combo.kEventTextInputUnicode\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "38bd9e01a6c7a5485a093c16ff98c2ae", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT WebKit/win32/org/eclipse/swt/browser/WebPolicyDelegate.java", "commitBeforeChange": "84e2194382eb044cc0a46bec2dd85e002621f923", "commitAfterChange": "75abf36cc26bfc01a3c5f0723da357390874f8e9", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  protected void disposeCOMInterfaces ()", "signatureAfterChange": "  protected void disposeCOMInterfaces ()", "diff": ["-\tSystem.out.println (\"======== disposing iWebPolicyDelegate\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc5c499c29e625084c96ecbaafe8eca2", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 44, "signatureBeforeChange": " public boolean isClipped()", "signatureAfterChange": " public boolean isClipped()", "diff": ["-\tSystem.out.println(\"GC.isClipped: nyi\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e99dd15da18aeabb2123806fe1868cbb", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples/org/eclipse/swt/examples/fileviewer/TreeDropFeedbackListener.java", "commitBeforeChange": "e19f3ee2e5f1fa5577672314ef96ca3ab839cf03", "commitAfterChange": "2dab2a914e742bae70df94e0205c4aa40ea8625c", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r\t\tpublic void run()", "signatureAfterChange": "\r\t\tpublic void run()", "diff": ["-package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = tree.getItem(point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\r\t\t/*\r\t\t * Determine the candidate action for this position: nothing, scroll or expand\r\t\t */\r\t\thoverRunnable = null;\r\t\tif (hoverItem == null) return; // Nothing to do\r\r\t\t// Consider scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\t/**\r\t * Implements scrolling on a timer\r\t */\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Scroll\");\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tif (hoverItem != tree.getItem(hoverPoint)) return; // stop if we actually scrolled\r\t\t\t}\r\t\t\t\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\t/**\r\t * Implements expanding on a timer\r\t */\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Expand\");\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file", "+package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = getItem(tree, point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thandleHoverOverItem(item, point);\r\t}\r\t\t\r\tprivate void handleHoverOverItem(TreeItem item, Point point) {\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\t\thoverRunnable = null;\r\t\tif (item == null) return;\r\r\t\t// Try scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 32); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (hoverPoint.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (hoverPoint.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\t\t\r\t\t// Try expanding\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tTreeItem visibleItem = getItem(tree, hoverPoint);\t\t\t\t\r\t\t\t\tif (hoverItem != visibleItem) {\r\t\t\t\t\t// We actually scrolled, retrigger the scroll timer\r\t\t\t\t\thandleHoverOverItem(visibleItem, hoverPoint);\r\t\t\t\t\treturn;\r\t\t\t\t}\r\t\t\t}\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r\t\r\t/**\r\t * Foreign method: workaround for PR_1GG07HW\r\t */\r\tprivate TreeItem getItem(Tree tree, Point point) {\r\t\tPoint tempPoint = new Point(point.x, point.y);\r\t\treturn tree.getItem(tempPoint);\r\t}\r}\r", "\\ No newline at end of file"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6715216af5a5fbf9af0917f330f49518", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 41, "signatureBeforeChange": "  int GetDefaultString (int aDefaultString)", "signatureAfterChange": "  int GetDefaultString (int aDefaultString)", "diff": ["-\tSystem.out.println(\"getdefaultstring\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90b923d5a9f4e49a55db091f2d5648de", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT PI/carbon/org/eclipse/swt/internal/carbon/MacUtil.java", "commitBeforeChange": "817d020b7e5b06625624b398b21d44141fefd021", "commitAfterChange": "eb426dd094d07f2d63380874ea09a281f1204008", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tpublic static int getSuperControl(int cHandle)", "signatureAfterChange": " \tpublic static int getSuperControl(int cHandle)", "diff": ["-\t\t\tSystem.out.println(\"MacUtil.getSuperControl: GetControlOwner error\");", "+\t\t\t//System.out.println(\"MacUtil.getSuperControl: GetControlOwner error\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3d75e4dfd0b6cdc16a59abc8745b8ba8", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "817d020b7e5b06625624b398b21d44141fefd021", "commitAfterChange": "eb426dd094d07f2d63380874ea09a281f1204008", "methodNumberBeforeChange": 87, "methodNumberAfterChange": 87, "signatureBeforeChange": " \t\t \tprivate int handleMouseCallback(int nextHandler, int eRefHandle, int whichWindow)", "signatureAfterChange": " \t\t \tprivate int handleMouseCallback(int nextHandler, int eRefHandle, int whichWindow)", "diff": ["-\t\t\tSystem.out.println(\"Display.handleMouseCallback:  whichWindow == 0\");", "+\t\t\t//System.out.println(\"Display.handleMouseCallback:  whichWindow == 0\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b718bfa9f7ea008f21e45b48594b91de", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/FilePicker.java", "commitBeforeChange": "f04b3b9bdc281c6acde82a12d1487f0b31064c99", "commitAfterChange": "2acd7ea16c37b66b73ecb7bbb56b548418c4c393", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": "  int GetDisplayDirectory (int aDisplayDirectory)", "signatureAfterChange": "  int GetDisplayDirectory (int aDisplayDirectory)", "diff": ["-\tSystem.out.println (\"getDisplayDirectory\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7d4842ad21a8efce0dd6bb264252ec94", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public void copyArea(Image image, int x, int y)", "signatureAfterChange": " public void copyArea(Image image, int x, int y)", "diff": ["-\t/* AW", "-\tRectangle rect = image.getBounds();", "-\tint xDisplay = data.display;", "-\tint xGC = OS.XCreateGC(xDisplay, image.pixmap, 0, null);", "-\tif (xGC == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\tOS.XSetSubwindowMode (xDisplay, xGC, OS.IncludeInferiors);", "-\tOS.XCopyArea(xDisplay, data.drawable, image.pixmap, xGC, x, y, rect.width, rect.height, 0, 0);", "-\tOS.XFreeGC(xDisplay, xGC);", "-\t*/", "-\tSystem.out.println(\"GC.copyArea(Image): nyi\");", "+\t//NOT IMPLEMENTED"]}], "num": 45088}