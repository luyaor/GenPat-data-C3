{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cbd6f0e5c48013175e2055a40d8d4b30", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a0794bb8b5c4a0706e8386867759d0c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "654d64807d28d71d8b9178c15a734ad83f5bb9a1", "commitAfterChange": "119cce23f4fb44ae76326935818a1edeb3fae4b2", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 48, "signatureBeforeChange": " void shape (int hdc, StyleItem run)", "signatureAfterChange": " void shape (final int hdc, final StyleItem run)", "diff": ["-void shape (int hdc, StyleItem run) {", "-\tint[] buffer = new int[1];", "-\tchar[] chars = new char[run.length];", "+void shape (final int hdc, final StyleItem run) {", "+\tfinal int[] buffer = new int[1];", "+\tfinal char[] chars = new char[run.length];", "-\tint MAX_GLYPHS = (chars.length * 3 / 2) + 16;", "-\tint hHeap = OS.GetProcessHeap();", "-\tint pGlyphs = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, MAX_GLYPHS * 2);", "-\tint pClusters = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, MAX_GLYPHS * 2);", "-\tint psva = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, MAX_GLYPHS * SCRIPT_VISATTR_SIZEOF);", "+\tfinal int maxGlyphs = (chars.length * 3 / 2) + 16;", "+\tfinal int hHeap = OS.GetProcessHeap();", "+\trun.glyphs = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, maxGlyphs * 2);", "+\trun.clusters = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, maxGlyphs * 2);", "+\trun.visAttrs = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, maxGlyphs * SCRIPT_VISATTR_SIZEOF);", "-\tOS.ScriptShape(hdc, run.psc, chars, chars.length, MAX_GLYPHS, run.analysis, pGlyphs, pClusters, psva, buffer);", "-\t//TODO", "-//\tif (hr == E_OUTOFMEMORY)", "-//\tif (hr == USP_E_SCRIPT_NOT_IN_FONT)", "-\tdevice.addScriptCache(run.psc);", "-\trun.glyphs = pGlyphs;", "-\trun.glyphCount = buffer[0];", "-\trun.clusters = pClusters;", "-\trun.visAttrs = psva;", "+\tif (!shape(hdc, run, chars, buffer,  maxGlyphs)) {", "+\t\tfinal int script = run.analysis.eScript;", "+\t\tfinal int hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "+\t\tfinal LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "+\t\tLOGFONT cachedLogFont = device.logFontsCache != null ? device.logFontsCache[script] : null;", "+\t\tif (cachedLogFont != null) {", "+\t\t\tcachedLogFont.lfHeight = logFont.lfHeight;", "+\t\t\tcachedLogFont.lfWeight = logFont.lfWeight;", "+\t\t\tcachedLogFont.lfItalic = logFont.lfItalic;", "+\t\t\tcachedLogFont.lfWidth = logFont.lfWidth;", "+\t\t\tint newFont = OS.CreateFontIndirect(cachedLogFont);", "+\t\t\tOS.SelectObject(hdc, newFont);", "+\t\t\tint hr = OS.ScriptShape(hdc, run.psc, chars, chars.length, maxGlyphs, run.analysis, run.glyphs, run.clusters, run.visAttrs, buffer);", "+\t\t\trun.glyphCount = buffer[0];", "+\t\t\trun.fallbackFont = newFont;", "+\t\t} else {", "+\t\t\tfinal LOGFONT newLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\tint[] ppSp = new int[1];", "+\t\t\tint[] piNumScripts = new int[1];", "+\t\t\tOS.ScriptGetProperties(ppSp, piNumScripts);", "+\t\t\tint[] scripts = new int[piNumScripts[0]];", "+\t\t\tOS.MoveMemory(scripts, ppSp[0], scripts.length * 4);", "+\t\t\tif (device.logFontsCache == null) \tdevice.logFontsCache = new LOGFONT[piNumScripts[0]];", "+\t\t\tSCRIPT_PROPERTIES properties = new SCRIPT_PROPERTIES();", "+\t\t\tOS.MoveMemory(properties, scripts[script], SCRIPT_PROPERTIES.sizeof);", "+\t\t\tint charSet = properties.fAmbiguousCharSet ? OS.DEFAULT_CHARSET : properties.bCharSet;", "+\t\t\tObject object = new Object () {", "+\t\t\t\tpublic int EnumFontFamExProc(int lpelfe, int lpntme, int FontType, int lParam) {", "+\t\t\t\t\tOS.MoveMemory(newLogFont, lpelfe, LOGFONT.sizeof);", "+\t\t\t\t\tif (FontType == OS.RASTER_FONTTYPE) return 1;", "+\t\t\t\t\tnewLogFont.lfHeight = logFont.lfHeight;", "+\t\t\t\t\tnewLogFont.lfWeight = logFont.lfWeight;", "+\t\t\t\t\tnewLogFont.lfItalic = logFont.lfItalic;", "+\t\t\t\t\tnewLogFont.lfWidth = logFont.lfWidth;", "+\t\t\t\t\tint newFont = OS.CreateFontIndirect(newLogFont);", "+\t\t\t\t\tOS.SelectObject(hdc, newFont);", "+\t\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs)) {", "+\t\t\t\t\t\trun.fallbackFont = newFont;", "+\t\t\t\t\t\tLOGFONT cacheLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\t\t\t\tOS.MoveMemory(cacheLogFont, lpelfe, LOGFONT.sizeof);", "+\t\t\t\t\t\tdevice.logFontsCache[script] = cacheLogFont;", "+\t\t\t\t\t\treturn 0;", "+\t\t\t\t\t}", "+\t\t\t\t\tOS.SelectObject(hdc, hFont);", "+\t\t\t\t\tOS.DeleteObject(newFont);", "+\t\t\t\t\treturn 1;", "+\t\t\t\t}", "+\t\t\t};", "+\t\t\tCallback callback = new Callback(object, \"EnumFontFamExProc\", 4);", "+\t\t\tint address = callback.getAddress();", "+\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "+\t\t\tnewLogFont.lfCharSet = (byte)charSet;", "+\t\t\tOS.EnumFontFamiliesEx(hdc, newLogFont, address, 0, 0);", "+\t\t\tcallback.dispose();", "+\t\t\tif (run.fallbackFont == 0) {", "+\t\t\t\tOS.ScriptShape(hdc, run.psc, chars, chars.length, maxGlyphs, run.analysis, run.glyphs, run.clusters, run.visAttrs, buffer);", "+\t\t\t\tdevice.logFontsCache[script] = logFont;", "+\t\t\t\trun.glyphCount = buffer[0];", "+\t\t\t}\t\t", "+\t\t}", "+\t}", "+", "+\t/* This code is intentionaly commented. */", "+//\tdevice.addScriptCache(run.psc);", "+", "-\tint pGoffsets = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, run.glyphCount * GOFFSET_SIZEOF);", "-\tint piAdvances = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, run.glyphCount * 4);", "-\tOS.ScriptPlace(hdc, run.psc, run.glyphs, run.glyphCount, run.visAttrs, run.analysis, piAdvances, pGoffsets, abc);", "+\trun.advances = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, run.glyphCount * 4);", "+\trun.goffsets = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, run.glyphCount * GOFFSET_SIZEOF);", "+\tOS.ScriptPlace(hdc, run.psc, run.glyphs, run.glyphCount, run.visAttrs, run.analysis, run.advances, run.goffsets, abc);", "-\trun.advances = piAdvances;", "-\trun.goffsets = pGoffsets;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "210cc7693eb4922ccd919501220a81e3", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "1b2051b4e1c4270a87de4601bb08de0a28f18462", "commitAfterChange": "5f75e2dae2083c0061842ac6356ab5d489381754", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": " void shape (final int hdc, final StyleItem run)", "signatureAfterChange": " void shape (final int hdc, final StyleItem run)", "diff": ["-\tint[] buffer = new int[1];", "-\tchar[] chars = new char[run.length];", "+\tfinal int[] buffer = new int[1];", "+\tfinal char[] chars = new char[run.length];", "-\tint maxGlyphs = (chars.length * 3 / 2) + 16;", "+\tfinal int maxGlyphs = (chars.length * 3 / 2) + 16;", "-\tif (!shape(hdc, run, chars, buffer,  maxGlyphs)) {", "+\tboolean shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs);", "+\tfinal short script = run.analysis.eScript;", "+\t", "+\tif (!shapeSucceed) {", "+\t\t/* ", "+\t\t * Shape failed.", "+\t\t * Try to shape with fNoGlyphIndex when the run is in the ", "+\t\t * Private Use Area. This allows for end-user-defined character (EUDC).", "+\t\t */", "+\t\tSCRIPT_PROPERTIES properties = new SCRIPT_PROPERTIES();", "+\t\tOS.MoveMemory(properties, device.scripts[script], SCRIPT_PROPERTIES.sizeof);", "+\t\tif (properties.fPrivateUseArea) {", "+\t\t\trun.analysis.fNoGlyphIndex = true;", "+\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs);", "+\t\t}", "+\t}", "+\t", "+\tif (!shapeSucceed) {", "+\t\t/*", "+\t\t* Shape Failed.", "+\t\t* Try to use MLANG to find a suitable font to shape the run.  ", "+\t\t*/", "-\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs)) {", "+\t\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs);", "+\t\t\t\tif (shapeSucceed) {", "-\t\t\t\t\tSCRIPT_PROPERTIES properties = new SCRIPT_PROPERTIES();", "-\t\t\t\t\tOS.MoveMemory(properties, device.scripts[run.analysis.eScript], SCRIPT_PROPERTIES.sizeof);", "-\t\t\t\t\tif (properties.fPrivateUseArea) {", "-\t\t\t\t\t\trun.analysis.fNoGlyphIndex = true;", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.ScriptShape(hdc, run.psc, chars, chars.length, maxGlyphs, run.analysis, run.glyphs, run.clusters, run.visAttrs, buffer);", "-\t\t\t\t\trun.glyphCount = buffer[0];", "+\t", "+\tif (!shapeSucceed) {", "+\t\t/*", "+\t\t* Shape Failed.", "+\t\t* Try to shape the run using the LOGFONT in the cache.", "+\t\t*/", "+\t\tfinal int hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "+\t\tfinal LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "+\t\t", "+\t\tLOGFONT cachedLogFont = device.logFontsCache != null ? device.logFontsCache[script] : null;", "+\t\tif (cachedLogFont != null) {", "+\t\t\tcachedLogFont.lfHeight = logFont.lfHeight;", "+\t\t\tcachedLogFont.lfWeight = logFont.lfWeight;", "+\t\t\tcachedLogFont.lfItalic = logFont.lfItalic;", "+\t\t\tcachedLogFont.lfWidth = logFont.lfWidth;", "+\t\t\tint newFont = OS.CreateFontIndirect(cachedLogFont);", "+\t\t\tOS.SelectObject(hdc, newFont);", "+\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs);", "+\t\t\tif (shapeSucceed) {", "+\t\t\t\trun.fallbackFont = newFont;", "+\t\t\t} else {", "+\t\t\t\tOS.SelectObject(hdc, hFont);", "+\t\t\t\tOS.DeleteObject(newFont);", "+\t\t\t}", "+\t\t}", "+\t\tif (!shapeSucceed) {", "+\t\t\t/*", "+\t\t\t* Shape Failed.", "+\t\t\t* Use EnumFontFamExProc to iterate over every font in the system that supports ", "+\t\t\t* the charset of the run and try to shape it.  ", "+\t\t\t*/", "+\t\t\tif (device.logFontsCache == null) device.logFontsCache = new LOGFONT[device.scripts.length];", "+\t\t\tfinal LOGFONT newLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\tObject object = new Object () {", "+\t\t\t\tpublic int EnumFontFamExProc(int lpelfe, int lpntme, int FontType, int lParam) {", "+\t\t\t\t\tOS.MoveMemory(newLogFont, lpelfe, LOGFONT.sizeof);", "+\t\t\t\t\tif (FontType == OS.RASTER_FONTTYPE) return 1;", "+\t\t\t\t\tnewLogFont.lfHeight = logFont.lfHeight;", "+\t\t\t\t\tnewLogFont.lfWeight = logFont.lfWeight;", "+\t\t\t\t\tnewLogFont.lfItalic = logFont.lfItalic;", "+\t\t\t\t\tnewLogFont.lfWidth = logFont.lfWidth;", "+\t\t\t\t\tint newFont = OS.CreateFontIndirect(newLogFont);", "+\t\t\t\t\tOS.SelectObject(hdc, newFont);", "+\t\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs)) {", "+\t\t\t\t\t\trun.fallbackFont = newFont;", "+\t\t\t\t\t\tLOGFONT cacheLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\t\t\t\tOS.MoveMemory(cacheLogFont, lpelfe, LOGFONT.sizeof);", "+\t\t\t\t\t\tdevice.logFontsCache[script] = cacheLogFont;", "+\t\t\t\t\t\treturn 0;", "+\t\t\t\t\t}", "+\t\t\t\t\tOS.SelectObject(hdc, hFont);", "+\t\t\t\t\tOS.DeleteObject(newFont);", "+\t\t\t\t\treturn 1;", "+\t\t\t\t}", "+\t\t\t};", "+\t\t\tCallback callback = new Callback(object, \"EnumFontFamExProc\", 4);", "+\t\t\tint address = callback.getAddress();", "+\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "+\t\t\tSCRIPT_PROPERTIES properties = new SCRIPT_PROPERTIES();", "+\t\t\tOS.MoveMemory(properties, device.scripts[script], SCRIPT_PROPERTIES.sizeof);", "+\t\t\tint charSet = properties.fAmbiguousCharSet ? OS.DEFAULT_CHARSET : properties.bCharSet;", "+\t\t\tnewLogFont.lfCharSet = (byte)charSet;", "+\t\t\tOS.EnumFontFamiliesEx(hdc, newLogFont, address, 0, 0);", "+\t\t\tcallback.dispose();", "+\t\t\tshapeSucceed = run.fallbackFont != 0;", "+\t\t}", "+\t}", "+\t", "+\tif (!shapeSucceed) {", "+\t\t/*", "+\t\t* Shape Failed.", "+\t\t* Give up and shape the run with the default font. ", "+\t\t* Missing glyphs typically will be represent as black boxes in the text. ", "+\t\t*/", "+\t\tOS.ScriptShape(hdc, run.psc, chars, chars.length, maxGlyphs, run.analysis, run.glyphs, run.clusters, run.visAttrs, buffer);", "+\t\trun.glyphCount = buffer[0];", "+\t}"]}], "num": 4363}