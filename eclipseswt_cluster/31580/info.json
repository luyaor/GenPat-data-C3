{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d2779c49084c72b0165e8c341fb46b21", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "457a38a538b862540bf8abb75b4f7b8c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "533fa0b4db36012e7cdb0d4f3a9e30b894a2e049", "commitAfterChange": "5e7a786028a166f56bc468dd7558e85824bf8fbb", "methodNumberBeforeChange": 89, "methodNumberAfterChange": 92, "signatureBeforeChange": " \t \tprivate int handleMouseCallback(int nextHandler, int eRefHandle, int whichWindow)", "signatureAfterChange": " \t\t \tprivate int handleMouseCallback(int nextHandler, int eRefHandle, int whichWindow)", "diff": ["-\tprivate int handleMouseCallback(int nextHandler, int eRefHandle, int whichWindow) {", "-\t\tint eventClass= OS.GetEventClass(eRefHandle);", "-\t\tint eventKind= OS.GetEventKind(eRefHandle);", "-\t\t", "-\t\tswitch (eventClass) {", "-\t\t\t", "-\t\tcase OS.kEventClassMouse:", "-\t\t\treturn handleMouseEvent(nextHandler, eRefHandle, eventKind, whichWindow);", "-\t\t", "-\t\tdefault:", "-\t\t\tSystem.out.println(\"handleMouseCallback: unexpected event class: \" + MacUtil.toString(eventClass));", "-\t\t\tbreak;", "-\t\t}", "-\t\treturn OS.eventNotHandledErr;", "-\t}", "+\tprivate int handleMouseCallback(int nextHandler, int eRefHandle, int whichWindow) {", "+\t\tint eventClass= OS.GetEventClass(eRefHandle);", "+\t\tif (eventClass != OS.kEventClassMouse) {", "+\t\t\tSystem.out.println(\"handleMouseCallback: unexpected event class: \" + MacUtil.toString(eventClass));", "+\t\t\treturn OS.eventNotHandledErr;", "+\t\t}", "+\t\t\t\t", "+\t\tint eventKind= OS.GetEventKind(eRefHandle);", "+", "+\t\tif (eventKind == OS.kEventMouseDown) {", "+\t\t}", "+\t\t// determine control under mouse", "+\t\tshort[] cpart= new short[1];\t\t", "+\t\tint whichControl= MacUtil.findControlUnderMouse(whichWindow, me, cpart);\t\t\t\t", "+\t\tWidget widget= WidgetTable.get(whichControl);", "+\t\t", "+\t\tMacMouseEvent mme= new MacMouseEvent(me);", "+\t\t", "+\t\tcase OS.kEventMouseDown:\t\t\t", "+\t\t\t", "+\t\t\tShell shell= null;", "+\t\t\tWidget w= findWidget(whichWindow);", "+\t\t\tif (w instanceof Shell)", "+\t\t\t\tshell= (Shell) w;", "+\t\t\t\t", "+\t\t\t// first click in window -> activation", "+\t\t\tif (!OS.IsWindowActive(whichWindow)) {", "+\t\t\t\tif (shell != null && (shell.getStyle() & SWT.ON_TOP) == 0) {", "+\t\t\t\t\t// let the default handler activate the window", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\t// whatever we do, we hide the tooltip", "+\t\t\thideToolTip();", "+", "+\t\t\t// focus handling", "+\t\t\tif (shell != null && (shell.getStyle() & SWT.ON_TOP) == 0)", "+\t\t\t\tsetMacFocusHandle(whichWindow, whichControl);", "+\t\t\t\t\t\t\t\t\t", "+\t\t\tif (whichControl != 0) {", "+\t\t\t", "+\t\t\t\t// deal with the context menu", "+\t\t\t\tif (widget instanceof Control) {", "+\t\t\t\t\tMenu cm= ((Control)widget).getMenu();\t// is a context menu installed?", "+\t\t\t\t\tif (cm != null && me.isShowContextualMenuClick()) {", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tfInContextMenu= true;", "+\t\t\t\t\t\t\t// AW: not ready for primetime", "+\t\t\t\t\t\t\t// OS.ContextualMenuSelect(cm.handle, globalPos.getData(), new short[1], new short[1]);", "+\t\t\t\t\t\t\torg.eclipse.swt.internal.carbon.Point pos= me.getWhere();", "+\t\t\t\t\t\t\tOS.PopUpMenuSelect(cm.handle, pos.v, pos.h, (short)1);", "+\t\t\t\t\t\t} finally {", "+\t\t\t\t\t\t\tfInContextMenu= false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn OS.noErr;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tif (cpart[0] == 111) { \t// a user pane", "+\t\t\t\t\tif (!(widget instanceof Text)) ", "+\t\t\t\t\t\tfTrackedControl= whichControl;\t// starts mouse tracking", "+\t\t\t\t\twindowProc(whichControl, SWT.MouseDown, mme);", "+\t\t\t\t\treturn OS.noErr;", "+\t\t\t\t} else {", "+\t\t\t\t\twindowProc(whichControl, SWT.MouseDown, mme);", "+\t\t\t\t}", "+\t\t\t\twindowProc(fTrackedControl, SWT.MouseMove, mme);", "+\t\t\t\twindowProc(fTrackedControl, SWT.MouseUp, mme);", "+\t\t\t\t\t", "+\t\t\t\t\twindowProc(fCurrentControl, SWT.MouseExit, mme);", "+\t\t\t\tif (widget instanceof Control) {", "+\t\t\t\t\tControl c= (Control) widget;", "+\t\t\t\twindowProc(fCurrentControl, SWT.MouseMove, mme);", "+\t\t\t\t\twindowProc(fCurrentControl, SWT.MouseEnter, mme);", "+\t\t\t\treturn OS.noErr;", "+\t\t\t\t", "+\t\t\t\t\twindowProc(fCurrentControl, SWT.MouseMove, mme);", "+\t\t\t}", "+\t\t\tbreak;", "+\t\t\t", "+\t\tcase OS.kEventMouseWheelMoved:", "+\t\t\tif (widget instanceof Composite) {", "+\t\t\t\tScrollBar sb= ((Composite) widget).getVerticalBar();", "+\t\t\t\tif (sb != null)", "+\t\t\t\t\treturn sb.processWheel(eRefHandle);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da4ff77204b27ff8aa0c6dda924402db", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/TreeItem.java", "commitBeforeChange": "2b635221beaca11b0f2782595f2f04eb08656eed", "commitAfterChange": "c964a36f72c09bd56edcd52d15c933282bfc4ef8", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 46, "signatureBeforeChange": " public void setExpanded (boolean expanded)", "signatureAfterChange": " public void setExpanded (boolean expanded)", "diff": ["+\t", "+\t/* Do nothing when the item is a leaf or already expanded */", "+\tint hwnd = parent.handle;", "+\tif (OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, handle) == 0) {", "+\t\treturn;", "+\t}", "+\tint state = 0;", "+\tif (OS.IsWinCE) {", "+\t\tTVITEM tvItem = new TVITEM ();", "+\t\ttvItem.hItem = handle;", "+\t\ttvItem.mask = OS.TVIF_STATE;", "+\t\tOS.SendMessage (hwnd, OS.TVM_GETITEM, 0, tvItem);", "+\t\tstate = tvItem.state;", "+\t} else {", "+\t\t/*", "+\t\t* Bug in Windows.  Despite the fact that TVM_GETITEMSTATE claims", "+\t\t* to return only the bits specified by the stateMask, when called", "+\t\t* with TVIS_EXPANDED, the entire state is returned.  The fix is", "+\t\t* to explicitly check for the TVIS_EXPANDED bit.", "+\t\t*/", "+\t\tstate = OS.SendMessage (hwnd, OS.TVM_GETITEMSTATE, handle, OS.TVIS_EXPANDED);", "+\t}", "+\tif (((state & OS.TVIS_EXPANDED) != 0) == expanded) return;", "+\t", "+\t/*", "+\t* Feature in Windows.  When TVM_EXPAND is used to expand", "+\t* an item, the widget scrolls to show the root item and", "+\t* the newly expanded items.  While not strictly incorrect,", "+\t* this means that application code that expands tree items", "+\t* in a background thread can scroll the widget while the", "+\t* user is interacting with it.  The fix is to remember", "+\t* the top item and the bounds of every tree item, turn", "+\t* redraw off, expand the item, scroll back to the top", "+\t* item.  If none of the rectangles have moved, then", "+\t* it is safe to turn redraw back on without redrawing", "+\t* the control.", "+\t*/", "+\tRECT [] rects = null;", "+\tboolean redraw = false, noScroll = true;", "+\tint count = 0, hTopItem = OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);", "+\tif (noScroll && hTopItem != 0) {", "+\t\tif (parent.drawCount == 0 && OS.IsWindowVisible (hwnd)) {", "+\t\t\tboolean noAnimate = true;", "+\t\t\tcount = OS.SendMessage (hwnd, OS.TVM_GETVISIBLECOUNT, 0, 0);", "+\t\t\trects = new RECT [count + 1];", "+\t\t\tint hItem = hTopItem, index = 0;", "+\t\t\twhile (hItem != 0 && (noAnimate || hItem != handle) && index < count) {", "+\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\trect.left = hItem;", "+\t\t\t\tif (OS.SendMessage (hwnd, OS.TVM_GETITEMRECT, 1, rect) != 0) {", "+\t\t\t\t\trects [index++] = rect;", "+\t\t\t\t}", "+\t\t\t\thItem = OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hItem);", "+\t\t\t}", "+\t\t\tif (noAnimate || hItem != handle) {", "+\t\t\t\tredraw = true;", "+\t\t\t\tcount = index;", "+\t\t\t\tint topHandle = parent.topHandle ();", "+\t\t\t\tOS.UpdateWindow (topHandle);", "+\t\t\t\tOS.DefWindowProc (topHandle, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t\tif (hwnd != topHandle) {", "+\t\t\t\t\tOS.UpdateWindow (hwnd);", "+\t\t\t\t\tOS.DefWindowProc (hwnd, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t\t}", "+\t\t\t\t/*", "+\t\t\t\t* This code is intentionally commented.", "+\t\t\t\t*/", "+//\t\t\t\tOS.SendMessage (hwnd, OS.WM_SETREDRAW, 0, 0);", "+\t\t\t}", "+\t\t}", "+\t}", "+\t", "-\t* strictly wrong but is inconsistent.  The fix is to notice", "-\t* that the selection has changed and issue the event.", "+\t* strictly wrong but is inconsistent.  The fix is to", "+\t* check whether the selection has changed and issue", "+\t* the event.", "-\tint hwnd = parent.handle;", "+\t", "+\t/* Expand or collapse the item */", "+\t", "+\t/* Scroll back to the top item */", "+\tif (noScroll && hTopItem != 0) {", "+\t\tOS.SendMessage (hwnd, OS.TVM_SELECTITEM, OS.TVGN_FIRSTVISIBLE, hTopItem);", "+\t\tif (redraw) {", "+\t\t\tboolean fixRedraw = false;", "+\t\t\tif (hTopItem == OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0)) {", "+\t\t\t\tint hItem = hTopItem, index = 0;", "+\t\t\t\twhile (hItem != 0 && index < count) {", "+\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\trect.left = hItem;", "+\t\t\t\t\tif (OS.SendMessage (hwnd, OS.TVM_GETITEMRECT, 1, rect) != 0) {", "+\t\t\t\t\t\tif (!OS.EqualRect (rect, rects [index])) {", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\thItem = OS.SendMessage (hwnd, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hItem);", "+\t\t\t\t\tindex++;", "+\t\t\t\t}", "+\t\t\t\tfixRedraw = index == count;", "+\t\t\t}", "+\t\t\tint topHandle = parent.topHandle ();", "+\t\t\tOS.DefWindowProc (topHandle, OS.WM_SETREDRAW, 1, 0);", "+\t\t\tif (hwnd != topHandle) {", "+\t\t\t\tOS.DefWindowProc (hwnd, OS.WM_SETREDRAW, 1, 0);", "+\t\t\t}", "+\t\t\t/*", "+\t\t\t* This code is intentionally commented.", "+\t\t\t*/", "+//\t\t\tOS.SendMessage (hwnd, OS.WM_SETREDRAW, 1, 0);", "+\t\t\tif (fixRedraw) {", "+\t\t\t\tparent.updateScrollBar ();", "+\t\t\t\tSCROLLINFO info = new SCROLLINFO ();", "+\t\t\t\tinfo.cbSize = SCROLLINFO.sizeof;", "+\t\t\t\tinfo.fMask = OS.SIF_ALL;", "+\t\t\t\tif (OS.GetScrollInfo (hwnd, OS.SB_VERT, info)) {", "+\t\t\t\t\tOS.SetScrollInfo (hwnd, OS.SB_VERT, info, true);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (OS.IsWinCE) {", "+\t\t\t\t\tOS.InvalidateRect (topHandle, null, true);", "+\t\t\t\t\tif (hwnd != topHandle) OS.InvalidateRect (hwnd, null, true);", "+\t\t\t\t} else {", "+\t\t\t\t\tint flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;", "+\t\t\t\t\tOS.RedrawWindow (topHandle, null, 0, flags);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+", "+\t/* Check for a selection event */"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "05d77ebedfa958d741373de715029fd0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void copyArea(int x, int y, int width, int height, int destX, int destY)", "signatureAfterChange": " public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY)", "diff": ["-public void copyArea(int x, int y, int width, int height, int destX, int destY) {", "-\tif (handle == 0) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);", "-\tif (width <= 0 || height <= 0) return;", "-\tint deltaX = destX - x, deltaY = destY - y;", "-\tif (deltaX == 0 && deltaY == 0) return;", "-\t\t", "-\tRectangle src= new Rectangle(x, y, width, height);", "-\tsrc= src.union(new Rectangle(destX, destY, width, height));", "-\tMacRect r= new MacRect(src);", "-\t", "-\ttry {", "-\t\tif (focus(true, null)) {", "-\t\t\tint rgn= OS.NewRgn();", "-\t\t\tOS.ScrollRect(r.getData(), (short)deltaX, (short)deltaY, rgn);", "-\t\t\tOS.InvalWindowRgn(OS.GetWindowFromPort(handle), rgn);", "-\t\t\tOS.DisposeRgn(rgn);", "-\t\t}", "-\t} finally {", "-\t\tunfocus(true);", "-\t}", "+ */", "+public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY) {", "+\tif (handle == 0) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);", "+\tif (width <= 0 || height <= 0) return;", "+\tint deltaX = destX - srcX, deltaY = destY - srcY;", "+\tif (deltaX == 0 && deltaY == 0) return;", "+\tif (data.image != null) {", "+ \t\tOS.CGContextSaveGState(handle);", "+ \t\tOS.CGContextScaleCTM(handle, 1, -1);", "+ \t\tOS.CGContextTranslateCTM(handle, 0, -(height + 2 * destY));", "+ \t\tCGRect rect = new CGRect();", "+ \t\trect.x = destX;", "+ \t\trect.y = destY;", "+ \t\trect.width = width;", "+\t\trect.height = height;", "+\t\t//NOT DONE - transparency", "+ \t\tOS.CGContextDrawImage(handle, rect, data.image.handle);", "+ \t\tOS.CGContextRestoreGState(handle);", "+ \t\treturn;", "+\t}", "+\tif (data.control != 0) {", "+\t\tint window = OS.GetControlOwner(data.control);", "+\t\tint port = OS.GetWindowPort(window);", "+", "+\t\t/* Calculate src and dest rectangles/regions */", "+\t\tRect rect = new Rect();", "+\t\tOS.GetControlBounds(data.control, rect);\t\t", "+\t\tRect srcRect = new Rect();", "+\t\tOS.GetControlBounds(data.control, srcRect);", "+\t\tint left = srcRect.left + srcX;", "+\t\tint top = srcRect.top + srcY;", "+\t\tOS.SetRect(srcRect, (short)left, (short)top, (short)(left + width), (short)(top + height));", "+\t\tint srcRgn = OS.NewRgn();", "+\t\tOS.RectRgn(srcRgn, srcRect);\t\t", "+\t\tOS.SectRect(rect, srcRect, srcRect);", "+\t\tRect destRect = new Rect ();", "+\t\tdestRect.left = srcRect.left;", "+\t\tdestRect.top = srcRect.top;", "+\t\tdestRect.right = srcRect.right;", "+\t\tdestRect.bottom = srcRect.bottom;", "+\t\tOS.OffsetRect(destRect, (short)deltaX, (short)deltaY);", "+\t\tint destRgn = OS.NewRgn();", "+\t\tOS.RectRgn(destRgn, destRect);", "+\t\t", "+\t\t/* Copy bits with appropriated clipping region */", "+\t\tif (!OS.EmptyRect(srcRect)) {", "+\t\t\tint clipRgn = data.visibleRgn;", "+\t\t\tif (data.clipRgn != 0) {", "+\t\t\t\tclipRgn = OS.NewRgn();", "+\t\t\t\tOS.SectRgn(data.clipRgn, clipRgn, clipRgn);", "+\t\t\t}", "+", "+\t\t\t/*", "+\t\t\t* Feature in the Macintosh.  ScrollRect() only copies bits", "+\t\t\t* that are inside the specified rectangle.  This means that", "+\t\t\t* it is not possible to copy non overlaping bits without", "+\t\t\t* copying the bits in between the source and destination", "+\t\t\t* rectangles.  The fix is to check if the source and", "+\t\t\t* destination rectangles are disjoint and use CopyBits()", "+\t\t\t* instead.", "+\t\t\t*/", "+\t\t\tboolean disjoint = (destX + width < srcX) || (srcX + width < destX) || (destY + height < srcY) || (srcY + height < destY);", "+\t\t\tif (!disjoint && (deltaX == 0 || deltaY == 0)) {", "+\t\t\t\tint[] currentPort = new int[1];", "+\t\t\t\tOS.GetPort(currentPort);", "+\t\t\t\tOS.SetPort(port);", "+\t\t\t\tint oldClip = OS.NewRgn();", "+\t\t\t\tOS.GetClip(oldClip);", "+\t\t\t\tOS.SetClip(clipRgn);", "+\t\t\t\tOS.UnionRect(srcRect, destRect, rect);", "+\t\t\t\tOS.ScrollRect(rect, (short)deltaX, (short)deltaY, 0);", "+\t\t\t\tOS.SetClip(oldClip);", "+\t\t\t\tOS.DisposeRgn(oldClip);", "+\t\t\t\tOS.SetPort(currentPort[0]);", "+\t\t\t} else {", "+\t\t\t\tint portBitMap = OS.GetPortBitMapForCopyBits (port);", "+\t\t\t\tOS.CopyBits(portBitMap, portBitMap, srcRect, destRect, (short)OS.srcCopy, clipRgn);", "+\t\t\t\tOS.QDFlushPortBuffer(port, destRgn);", "+\t\t\t}", "+\t\t\t", "+\t\t\tif (clipRgn != data.visibleRgn) OS.DisposeRgn(clipRgn);", "+\t\t}", "+\t\t", "+\t\t/* Invalidate src and obscured areas */", "+\t\tint invalRgn = OS.NewRgn();", "+\t\tOS.DiffRgn(srcRgn, data.visibleRgn, invalRgn);", "+\t\tOS.OffsetRgn(invalRgn, (short)deltaX, (short)deltaY);", "+\t\tOS.DiffRgn(srcRgn, destRgn, srcRgn);", "+\t\tOS.UnionRgn(srcRgn, invalRgn, invalRgn);", "+\t\tOS.SectRgn(data.visibleRgn, invalRgn, invalRgn);", "+\t\tOS.InvalWindowRgn(window, invalRgn);", "+\t\tOS.DisposeRgn(invalRgn);", "+\t\t", "+\t\t/* Dispose src and dest regions */", "+\t\tOS.DisposeRgn(destRgn);", "+\t\tOS.DisposeRgn(srcRgn);", "+\t}", "+}"]}], "num": 31580}