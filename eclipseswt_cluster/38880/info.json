{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f0e5680e4baa9cfa8545d971df853cc6", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "43c0ec9db4f1d5034646da0097d5b046", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/internal/Converter.java", "commitBeforeChange": "48a36dcdf308b5e9a0e19f554c302e2e875b588d", "commitAfterChange": "8727d22e38059537dcc917ca55f0d6ddcedac706", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public static char [] mbcsToWcs (String codePage, byte [] buffer)", "signatureAfterChange": " public static char [] mbcsToWcs (String codePage, byte [] buffer)", "diff": ["-\t/*", "-\t * Optimize for English ASCII encoding.  If no conversion is", "-\t * performed, it is safe to return any object that will also not", "-\t * be converted if this routine is called again with the result.", "-\t * This ensures that double conversion will not be performed", "-\t * on the same bytes.  Note that this relies on the fact that", "-\t * lead bytes are never in the range 0..0x7F.", "-\t */", "-\tchar [] wideCharStr = new char [length];", "-\t/* AW", "-\tfor (int i=0; i<length; i++) {", "-\t\tif ((buffer [i] & 0xFF) <= 0x7F) {", "-\t\t\twideCharStr [i] = (char) buffer [i]; // all bytes <= 0x7F, so no ((char) (buffer[i]&0xFF)) needed", "-\t\t} else {", "-\t\t\tsynchronized (Converter.class) {", "-\t\t\t\tString cp = codePage != null ? codePage : CodePage;", "-\t\t\t\tif (LastMBToWC != 0 && !cp.equals (LastMBToWCCodePage)) {", "-\t\t\t\t\tOS.iconv_close (LastMBToWC);", "-\t\t\t\t\tLastMBToWC = 0;", "-\t\t\t\t}", "-\t\t\t\tif (LastMBToWC == 0) {", "-\t\t\t\t\tLastMBToWCCodePage = cp;", "-\t\t\t\t\tLastMBToWC = OS.iconv_open (Unicode, getAsciiBytes (cp));", "-\t\t\t\t}", "-\t\t\t\tint cd = LastMBToWC;", "-\t\t\t\tif (cd == 0) return EMPTY_CHAR_ARRAY;", "-\t\t\t\tint inBytes = length;", "-\t\t\t\tint outBytes = length * 2;", "-\t\t\t\tint ptr1, ptr2;", "-\t\t\t\tif (length <= BufferSize * 2) {", "-\t\t\t\t\tptr1 = BufferTimes2;", "-\t\t\t\t\tptr2 = BufferTimes4;", "-\t\t\t\t} else {", "-\t\t\t\t\tptr1 = OS.XtMalloc (inBytes);", "-\t\t\t\t\tptr2 = OS.XtMalloc (outBytes);", "-\t\t\t\t}", "-\t\t\t\tint [] inBuf = {ptr1};", "-\t\t\t\tint [] inBytesLeft = {inBytes};", "-\t\t\t\tint [] outBuf = {ptr2};", "-\t\t\t\tint [] outBytesLeft = {outBytes};", "-\t\t\t\tOS.memmove (ptr1, buffer, inBytes);", "-\t\t\t\tint result = OS.iconv (cd, inBuf, inBytesLeft, outBuf, outBytesLeft);", "-\t\t\t\toutBytes = outBuf [0] - ptr2;", "-\t\t\t\twideCharStr = new char [outBytes / 2];", "-\t\t\t\tOS.memmove (wideCharStr, ptr2, outBytes);", "-\t\t\t\tif (ptr1 != BufferTimes2) OS.XtFree (ptr1);", "-\t\t\t\tif (ptr2 != BufferTimes4) OS.XtFree (ptr2);", "-\t\t\t}", "-\t\t\treturn wideCharStr;", "-\t\t}", "-\t}", "-\t*/", "-\treturn wideCharStr;", "+\tString s= new String(buffer);", "+\tint n= s.length();", "+\tchar[] chars= new char[n];", "+\ts.getChars(0, n, chars, 0);", "+\treturn chars;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ddb0346142f82b4788683cd97b96b1bb", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/internal/Converter.java", "commitBeforeChange": "48a36dcdf308b5e9a0e19f554c302e2e875b588d", "commitAfterChange": "8727d22e38059537dcc917ca55f0d6ddcedac706", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public static byte [] wcsToMbcs (String codePage, char [] buffer, boolean terminate)", "signatureAfterChange": " public static byte [] wcsToMbcs (String codePage, char [] buffer, boolean terminate)", "diff": ["-\t/*", "-\t * Optimize for English ASCII encoding.  This optimization", "-\t * relies on the fact that lead bytes can never be in the", "-\t * range 0..0x7F.", "-\t */", "-\tbyte [] mbcs = new byte [(terminate) ? length + 1 : length];", "-\t/* AW", "-\tfor (int i=0; i<length; i++) {", "-\t\tif ((buffer [i] & 0xFFFF) <= 0x7F) {", "-\t\t\tmbcs [i] = (byte) buffer [i];", "-\t\t} else {", "-\t\t\tsynchronized (Converter.class) {", "-\t\t\t\tString cp = codePage != null ? codePage : CodePage;", "-\t\t\t\tif (LastWCToMB != 0 && !cp.equals (LastWCToMBCodePage)) {", "-\t\t\t\t\tOS.iconv_close (LastWCToMB);", "-\t\t\t\t\tLastWCToMB = 0;", "-\t\t\t\t}", "-\t\t\t\tif (LastWCToMB == 0) {", "-\t\t\t\t\tLastWCToMBCodePage = cp;", "-\t\t\t\t\tLastWCToMB = OS.iconv_open (getAsciiBytes (cp), Unicode);", "-\t\t\t\t}", "-\t\t\t\tint cd = LastWCToMB;", "-\t\t\t\tif (cd == 0) return (terminate) ? NULL_BYTE_ARRAY : EMPTY_BYTE_ARRAY;", "-\t\t\t\tint inBytes = length * 2;", "-\t\t\t\tint outBytes = length * 4;", "-\t\t\t\tint ptr1, ptr2;", "-\t\t\t\tif (length <= BufferSize) {", "-\t\t\t\t\tptr1 = BufferTimes2;", "-\t\t\t\t\tptr2 = BufferTimes4;", "-\t\t\t\t} else {", "-\t\t\t\t\tptr1 = OS.XtMalloc (inBytes);", "-\t\t\t\t\tptr2 = OS.XtMalloc (outBytes);", "-\t\t\t\t}", "-\t\t\t\tint [] inBuf = {ptr1};", "-\t\t\t\tint [] inBytesLeft = {inBytes};", "-\t\t\t\tint [] outBuf = {ptr2};", "-\t\t\t\tint [] outBytesLeft = {outBytes};", "-\t\t\t\tOS.memmove (ptr1, buffer, inBytes);", "-\t\t\t\tint result = OS.iconv (cd, inBuf, inBytesLeft, outBuf, outBytesLeft);", "-\t\t\t\toutBytes = outBuf [0] - ptr2;", "-\t\t\t\tmbcs = new byte [outBytes];", "-\t\t\t\tOS.memmove (mbcs, ptr2, outBytes);", "-\t\t\t\tif (ptr1 != BufferTimes2) OS.XtFree (ptr1);", "-\t\t\t\tif (ptr2 != BufferTimes4) OS.XtFree (ptr2);", "-\t\t\t}", "-\t\t\treturn mbcs;", "-\t\t}", "-\t}", "-\t*/", "-\treturn mbcs;", "+\tString s= new String(buffer);", "+\tbyte[] b= s.getBytes();", "+\tif (!terminate)", "+\t\treturn b;", "+\t\t", "+\tbyte[] b2= new byte[b.length+1];", "+\tSystem.arraycopy(b, 0, b2, 0, b.length);", "+\treturn b2;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ab6fb8a168e64ef783e67d77a18fe935", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/internal/Converter.java", "commitBeforeChange": "a2b9bca1b2547b13d86917552eeb3b52c207b9e4", "commitAfterChange": "4510458698a44cfe0ebb614544242955fbc20f7a", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r public static byte [] wcsToMbcs (String codePage, char [] buffer, boolean terminate)", "signatureAfterChange": "\r public static byte [] wcsToMbcs (String codePage, char [] buffer, boolean terminate)", "diff": ["+ */\r", "-\t//SLOW AND BOGUS\r", "-\tif (!terminate) return new String (buffer).getBytes ();\r", "-\tbyte [] buffer1 = new String (buffer).getBytes ();\r", "-\tbyte [] buffer2 = new byte [buffer1.length + 1];\r", "-\tSystem.arraycopy (buffer1, 0, buffer2, 0, buffer1.length);\r", "-\treturn buffer2;\r", "+\r", "+\t/* Check for the simple cases */\r", "+\tif (buffer == null) {\r", "+\t\treturn (terminate) ? NULL_BYTE_ARRAY : EMPTY_BYTE_ARRAY;\r", "+\t}\r", "+\tint length = buffer.length;\r", "+\tif (length == 0) {\r", "+\t\treturn (terminate) ? NULL_BYTE_ARRAY : EMPTY_BYTE_ARRAY;\r", "+\t}\r", "+\r", "+\t/*\r", "+\t * Optimize for English ASCII encoding.  This optimization\r", "+\t * relies on the fact that lead bytes can never be in the\r", "+\t * range 0..0x7F.\r", "+\t */\r", "+\tbyte [] mbcs = new byte [(terminate) ? length + 1 : length];\r", "+\tfor (int i=0; i<length; i++) {\r", "+\t\tif ((buffer [i] & 0xFFFF) <= 0x7F) {\r", "+\t\t\tmbcs [i] = (byte) buffer [i];\r", "+\t\t} else {\r", "+\t\t\tsynchronized (Converter.class) {\r", "+\t\t\t\tString cp = codePage != null ? codePage : CodePage;\r", "+\t\t\t\tif (LastWCToMB != 0 && !cp.equals (LastWCToMBCodePage)) {\r", "+\t\t\t\t\tOS.iconv_close (LastWCToMB);\r", "+\t\t\t\t\tLastWCToMB = 0;\r", "+\t\t\t\t}\r", "+\t\t\t\tif (LastWCToMB == 0) {\r", "+\t\t\t\t\tLastWCToMBCodePage = cp;\r", "+\t\t\t\t\tLastWCToMB = OS.iconv_open (getAsciiBytes (cp), Unicode);\r", "+\t\t\t\t}\r", "+\t\t\t\tint cd = LastWCToMB;\r", "+\t\t\t\tif (cd == 0) return (terminate) ? NULL_BYTE_ARRAY : EMPTY_BYTE_ARRAY;\r", "+\t\t\t\tint inBytes = length * 2;\r", "+\t\t\t\tint outBytes = length * 4;\r", "+\t\t\t\tint ptr1, ptr2;\r", "+\t\t\t\tif (length <= BufferSize) {\r", "+\t\t\t\t\tptr1 = BufferTimes2;\r", "+\t\t\t\t\tptr2 = BufferTimes4;\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tptr1 = OS.XtMalloc (inBytes);\r", "+\t\t\t\t\tptr2 = OS.XtMalloc (outBytes);\r", "+\t\t\t\t}\r", "+\t\t\t\tint [] inBuf = {ptr1};\r", "+\t\t\t\tint [] inBytesLeft = {inBytes};\r", "+\t\t\t\tint [] outBuf = {ptr2};\r", "+\t\t\t\tint [] outBytesLeft = {outBytes};\r", "+\t\t\t\t\r", "+\t\t\t\t/* Memmove can not be used because of the endianess */\r", "+//\t\t\t\tOS.memmove (ptr1, buffer, inBytes);\r", "+\t\t\t\tbyte[] b = new byte[inBytes];\r", "+\t\t\t\tfor (int j=0; j<inBytes; j+=2) {\r", "+\t\t\t\t\tint c = buffer [j >> 1];\r", "+\t\t\t\t\tb [j] = (byte)(c >> 8);\r", "+\t\t\t\t\tb [j + 1] = (byte)(c & 0xFF);\r", "+\t\t\t\t}\r", "+\t\t\t\tOS.memmove (ptr1, b, inBytes);\r", "+\t\t\t\t\r", "+\t\t\t\tint result = OS.iconv (cd, inBuf, inBytesLeft, outBuf, outBytesLeft);\r", "+\t\t\t\toutBytes = outBuf [0] - ptr2;\r", "+\t\t\t\tmbcs = new byte [outBytes];\r", "+\t\t\t\tOS.memmove (mbcs, ptr2, outBytes);\r", "+\t\t\t\tif (ptr1 != BufferTimes2) OS.XtFree (ptr1);\r", "+\t\t\t\tif (ptr2 != BufferTimes4) OS.XtFree (ptr2);\r", "+\t\t\t}\r", "+\t\t\treturn mbcs;\r", "+\t\t}\r", "+\t}\r", "+\treturn mbcs;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b48c33fb569e0278eab8cad7ecf4c2ec", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/internal/Converter.java", "commitBeforeChange": "a2b9bca1b2547b13d86917552eeb3b52c207b9e4", "commitAfterChange": "4510458698a44cfe0ebb614544242955fbc20f7a", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r public static char [] mbcsToWcs (String codePage, byte [] buffer)", "signatureAfterChange": "\r public static char [] mbcsToWcs (String codePage, byte [] buffer)", "diff": ["+ */\r", "-\t//SLOW AND BOGUS\r", "-\treturn new String (buffer).toCharArray ();\r", "+\r", "+\t/* Check for the simple cases */\r", "+\tif (buffer == null) {\r", "+\t\treturn EMPTY_CHAR_ARRAY;\r", "+\t}\r", "+\tint length = buffer.length;\r", "+\tif (length == 0) {\r", "+\t\treturn EMPTY_CHAR_ARRAY;\r", "+\t}\r", "+\t\r", "+\t/*\r", "+\t * Optimize for English ASCII encoding.  If no conversion is\r", "+\t * performed, it is safe to return any object that will also not\r", "+\t * be converted if this routine is called again with the result.\r", "+\t * This ensures that double conversion will not be performed\r", "+\t * on the same bytes.  Note that this relies on the fact that\r", "+\t * lead bytes are never in the range 0..0x7F.\r", "+\t */\t\r", "+\tchar [] wideCharStr = new char [length];\r", "+\tfor (int i=0; i<length; i++) {\r", "+\t\tif ((buffer [i] & 0xFF) <= 0x7F) {\r", "+\t\t\twideCharStr [i] = (char) buffer [i]; // all bytes <= 0x7F, so no ((char) (buffer[i]&0xFF)) needed\r", "+\t\t} else {\r", "+\t\t\tsynchronized (Converter.class) {\r", "+\t\t\t\tString cp = codePage != null ? codePage : CodePage;\r", "+\t\t\t\tif (LastMBToWC != 0 && !cp.equals (LastMBToWCCodePage)) {\r", "+\t\t\t\t\tOS.iconv_close (LastMBToWC);\r", "+\t\t\t\t\tLastMBToWC = 0;\r", "+\t\t\t\t}\r", "+\t\t\t\tif (LastMBToWC == 0) {\r", "+\t\t\t\t\tLastMBToWCCodePage = cp;\r", "+\t\t\t\t\tLastMBToWC = OS.iconv_open (Unicode, getAsciiBytes (cp));\r", "+\t\t\t\t}\r", "+\t\t\t\tint cd = LastMBToWC;\r", "+\t\t\t\tif (cd == 0) return EMPTY_CHAR_ARRAY;\r", "+\t\t\t\tint inBytes = length;\r", "+\t\t\t\tint outBytes = length * 2;\r", "+\t\t\t\tint ptr1, ptr2;\r", "+\t\t\t\tif (length <= BufferSize * 2) {\r", "+\t\t\t\t\tptr1 = BufferTimes2;\r", "+\t\t\t\t\tptr2 = BufferTimes4;\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tptr1 = OS.XtMalloc (inBytes);\r", "+\t\t\t\t\tptr2 = OS.XtMalloc (outBytes);\r", "+\t\t\t\t}\r", "+\t\t\t\tint [] inBuf = {ptr1};\r", "+\t\t\t\tint [] inBytesLeft = {inBytes};\r", "+\t\t\t\tint [] outBuf = {ptr2};\r", "+\t\t\t\tint [] outBytesLeft = {outBytes};\r", "+\t\t\t\tOS.memmove (ptr1, buffer, inBytes);\r", "+\t\t\t\tint result = OS.iconv (cd, inBuf, inBytesLeft, outBuf, outBytesLeft);\r", "+\t\t\t\toutBytes = outBuf [0] - ptr2;\r", "+\t\t\t\twideCharStr = new char [outBytes / 2];\r", "+\t\t\t\t\r", "+\t\t\t\t/* Memmove can not be used because of the endianess */\r", "+//\t\t\t\tOS.memmove (wideCharStr, ptr2, outBytesLeft [0]);\r", "+\t\t\t\tbyte[] b = new byte [outBytes];\r", "+\t\t\t\tOS.memmove (b, ptr2, outBytes);\r", "+\t\t\t\tfor (int j=0; j<outBytes; j+=2) {\r", "+\t\t\t\t\twideCharStr [j >> 1] = (char)(((b [j] & 0xFF) << 8) | (b [j + 1] & 0xFF));\r", "+\t\t\t\t}\r", "+\t\t\t\t\r", "+\t\t\t\tif (ptr1 != BufferTimes2) OS.XtFree (ptr1);\r", "+\t\t\t\tif (ptr2 != BufferTimes4) OS.XtFree (ptr2);\r", "+\t\t\t}\r", "+\t\t\treturn wideCharStr;\r", "+\t\t}\r", "+\t}\r", "+\treturn wideCharStr;\r"]}], "num": 38880}