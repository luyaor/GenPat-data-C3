{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4fae45cbc52c7a01fbcf35e97cdc5e91", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4efd6c5be5c5dbf4492f4c2354aeefac", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples.paint/org/eclipse/swt/examples/paint/PaintSurface.java", "commitBeforeChange": "4dfad5a97535c7282afa88210ebbd2164a5fb922", "commitAfterChange": "15f1eee3a8ec2620bed875ba9786fc1d8ffa28db", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r\tpublic void dispose()", "signatureAfterChange": "\r\tpublic void dispose()", "diff": ["-\tprivate Canvas       paintCanvas;\r\tprivate PaintStatus  paintStatus;\r\tprivate PaintSession paintSession;\r\tprivate Image        image;\r\tprivate Rectangle    visibleRect;\r\tprivate Rectangle    imageRect;\r\r\tprivate GC           displayGC;    // the GC used for drawing to the display\r\tprivate GC           rubberbandGC; // the GC used exclusively for rubberband drawing\r\tprivate GC           imageGC;      // the GC used as a permanent backing store\r\tprivate Color        rubberbandFGColor, rubberbandBGColor;\r\t\r\tprivate ContainerFigure rubberband; // the active rubberband selection\r\tprivate Object         rubberbandState; // the active rubberband selection previewing state\r\tprivate int rubberbandHiddenNestingCount; // always >= 0, if > 0 rubberband has been hidden\r\r\t/**\r\t * Constructs a PaintSurface.\r\t * <p>\r\t * paintCanvas must have SWT.NO_REDRAW_RESIZE style, and may have SWT.V_SCROLL and/or SWT.H_SCROLL.\r\t * </p>\r\t * @param paintCanvas the Canvas object in which to render\r\t * @param paintStatus the PaintStatus object to use for providing user feedback\r\t */\r", "-\tpublic PaintSurface(Canvas paintCanvas, PaintStatus paintStatus) {\r\t\tthis.paintCanvas = paintCanvas;\r\t\tthis.paintStatus = paintStatus;\r\r\t\t/* Set up the drawing surface */\r\t\tvisibleRect = paintCanvas.getClientArea();\r\t\timageRect = paintCanvas.getDisplay().getClientArea();\r\t\timage = new Image(paintCanvas.getDisplay(), imageRect.width, imageRect.height);\r\r\t\timageGC = new GC(image);\r\t\tdisplayGC = new GC(paintCanvas);\r\t\trubberbandGC = new GC(paintCanvas);\r\t\trubberbandGC.setXORMode(true);\r\t\trubberbandFGColor = new Color(paintCanvas.getDisplay(), 255, 255, 255);\r\t\trubberbandBGColor = new Color(paintCanvas.getDisplay(), 127, 127, 127);\r\t\trubberbandGC.setForeground(rubberbandFGColor);\r\t\trubberbandGC.setBackground(rubberbandBGColor);\r\r\t\trubberbandHiddenNestingCount = 0;\r\t\trubberbandState = null;\t\t\r\t\trubberband = new ContainerFigure();\r\r\t\t/* Initialize the session */\r\t\tsetPaintSession(null);\r\r\t\t/* Add our listeners */\r\t\tpaintCanvas.addMouseListener(new MouseAdapter() {\r\t\t\tpublic void mouseDown(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDown(event);\r\t\t\t}\r\t\t\tpublic void mouseUp(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseUp(event);\r\t\t\t}\r\t\t\tpublic void mouseDoubleClick(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDoubleClick(event);\r\t\t\t}\t\t\t\r\t\t});\r\t\tpaintCanvas.addMouseMoveListener(new MouseMoveListener() {\r\t\t\tpublic void mouseMove(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseMove(event);\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addPaintListener(new PaintListener() {\r\t\t\tpublic void paintControl(PaintEvent event) {\r\t\t\t\thideRubberband();\r\t\t\t\tdisplayGC.drawImage(image,\r\t\t\t\t\tvisibleRect.x - imageRect.x, visibleRect.y - imageRect.y,\r\t\t\t\t\tvisibleRect.width, visibleRect.height, 0, 0, visibleRect.width, visibleRect.height);\r\t\t\t\tshowRubberband();\t\t\t\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addControlListener(new ControlAdapter() {\r\t\t\tpublic void controlResized(ControlEvent event) {\r\t\t\t\thandleResize();\r\t\t\t}\t\t\t\r\t\t});\r\r\t\t/* Set up the paint canvas scroll bars */\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\thorizontal.setVisible(true);\r\t\thorizontal.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollHorizontally((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tvertical.setVisible(true);\r\t\tvertical.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollVertically((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\thandleResize();\r\t}\r\t\r\t/**\r\t * Disposes of the PaintSurface's resources.\r\t */\r\tpublic void dispose() {\r\t\timageGC.dispose();\r\t\tdisplayGC.dispose();\r\t\trubberbandGC.dispose();\r\t\trubberbandFGColor.dispose();\r\t\trubberbandBGColor.dispose();\r\t\timage.dispose();\t\t\r\t}\r\r\t/**\r\t * Called when we must grab focus.\r\t */\r\tpublic void setFocus()  {\r\t\tpaintCanvas.setFocus();\r\t}\r\r\t/**\r\t * Returns the Display on which the PaintSurface resides.\r\t * @return the Display\r\t */\r\tpublic Display getDisplay() {\r\t\treturn paintCanvas.getDisplay();\r\t}\r\r\t/**\r\t * Returns the Shell in which the PaintSurface resides.\r\t * @return the Shell\r\t */\r\tpublic Shell getShell() {\r\t\treturn paintCanvas.getShell();\r\t}\r\r\t/**\r", "+\tprivate final Canvas      paintCanvas;\r\r\tprivate PaintSession paintSession;\r\tprivate Image image;\r\tprivate int   imageWidth, imageHeight;\r\tprivate int   visibleWidth, visibleHeight;\r\r\tprivate FigureDrawContext displayFDC = new FigureDrawContext();\r\tprivate FigureDrawContext imageFDC = new FigureDrawContext();\r\r\t/* Rubberband */\r\tprivate ContainerFigure rubberband = new ContainerFigure();\r\t\t// the active rubberband selection\r\tprivate int rubberbandHiddenNestingCount = 0;\r\t\t// always >= 0, if > 0 rubberband has been hidden\r\r\t/* Status */\r\tprivate final Text statusText;\r\tprivate String statusActionInfo, statusMessageInfo, statusCoordInfo;\r\r\t/**\r\t * Constructs a PaintSurface.\r\t * <p>\r\t * paintCanvas must have SWT.NO_REDRAW_RESIZE and SWT.NO_BACKGROUND styles,\r\t *     and may have SWT.V_SCROLL and/or SWT.H_SCROLL.\r\t * </p>\r\t * @param paintCanvas the Canvas object in which to render\r\t * @param paintStatus the PaintStatus object to use for providing user feedback\r\t */\r", "+\tpublic PaintSurface(Canvas paintCanvas, Text statusText) {\r\t\tthis.paintCanvas = paintCanvas;\r\t\tthis.statusText = statusText;\r\t\tclearStatus();\r\r\t\t/* Set up the drawing surface */\r\t\tRectangle displayRect = paintCanvas.getDisplay().getClientArea();\r\t\timageWidth = displayRect.width;\r\t\timageHeight = displayRect.height;\r\t\timage = new Image(paintCanvas.getDisplay(), imageWidth, imageHeight);\r\r\t\timageFDC.gc = new GC(image);\r\t\tdisplayFDC.gc = new GC(paintCanvas);\r\r\t\t/* Initialize the session */\r\t\tsetPaintSession(null);\r\r\t\t/* Add our listeners */\r\t\tpaintCanvas.addMouseListener(new MouseAdapter() {\r\t\t\tpublic void mouseDown(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDown(event);\r\t\t\t}\r\t\t\tpublic void mouseUp(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseUp(event);\r\t\t\t}\r\t\t\tpublic void mouseDoubleClick(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDoubleClick(event);\r\t\t\t}\t\t\t\r\t\t});\r\t\tpaintCanvas.addMouseMoveListener(new MouseMoveListener() {\r\t\t\tpublic void mouseMove(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseMove(event);\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addPaintListener(new PaintListener() {\r\t\t\tpublic void paintControl(PaintEvent event) {\r\t\t\t\tif (rubberband.isEmpty()) {\r\t\t\t\t\tevent.gc.drawImage(image,\r\t\t\t\t\t\tdisplayFDC.xOffset, displayFDC.yOffset, visibleWidth, visibleHeight,\r\t\t\t\t\t\t0, 0, visibleWidth, visibleHeight);\r\t\t\t\t} else {\r\t\t\t\t\t// avoid flicker\r\t\t\t\t\tRectangle clip = event.gc.getClipping();\r\t\t\t\t\tImage blitImage = new Image(getDisplay(), event.width, event.height);\r\t\t\t\t\tFigureDrawContext fdc = new FigureDrawContext();\r\t\t\t\t\tfdc.gc = new GC(blitImage);\r\t\t\t\t\tfdc.xOffset = displayFDC.xOffset + clip.x;\r\t\t\t\t\tfdc.yOffset = displayFDC.yOffset + clip.y;\r\t\t\t\t\tfdc.gc.drawImage(image,\r\t\t\t\t\t\tclip.x + displayFDC.xOffset, clip.y + displayFDC.yOffset, clip.width, clip.height,\r\t\t\t\t\t\t0, 0, clip.width, clip.height);\r\t\t\t\t\trubberband.draw(fdc);\r\t\t\t\t\tfdc.gc.dispose();\r\t\t\t\t\tevent.gc.drawImage(blitImage, clip.x, clip.y);\r\t\t\t\t\tblitImage.dispose();\r\t\t\t\t}\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addControlListener(new ControlAdapter() {\r\t\t\tpublic void controlResized(ControlEvent event) {\r\t\t\t\thandleResize();\r\t\t\t}\t\t\t\r\t\t});\r\r\t\t/* Set up the paint canvas scroll bars */\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\thorizontal.setVisible(true);\r\t\thorizontal.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollHorizontally((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tvertical.setVisible(true);\r\t\tvertical.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollVertically((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\thandleResize();\r\t}\r\t\r\t/**\r\t * Disposes of the PaintSurface's resources.\r\t */\r\tpublic void dispose() {\r\t\timageFDC.gc.dispose();\r\t\tdisplayFDC.gc.dispose();\r\t\timage.dispose();\t\t\r\t}\r\r\t/**\r\t * Called when we must grab focus.\r\t */\r\tpublic void setFocus()  {\r\t\tpaintCanvas.setFocus();\r\t}\r\r\t/**\r\t * Returns the Display on which the PaintSurface resides.\r\t * @return the Display\r\t */\r\tpublic Display getDisplay() {\r\t\treturn paintCanvas.getDisplay();\r\t}\r\r\t/**\r\t * Returns the Shell in which the PaintSurface resides.\r\t * @return the Shell\r\t */\r\tpublic Shell getShell() {\r\t\treturn paintCanvas.getShell();\r\t}\r\r\t/**\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c6a0379fab1f166036b43fa89738200", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples.paint/org/eclipse/swt/examples/paint/PaintSurface.java", "commitBeforeChange": "4dfad5a97535c7282afa88210ebbd2164a5fb922", "commitAfterChange": "15f1eee3a8ec2620bed875ba9786fc1d8ffa28db", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "\r \tpublic PaintSurface(Canvas paintCanvas, PaintStatus paintStatus)", "signatureAfterChange": "\r \tpublic PaintSurface(Canvas paintCanvas, Text statusText)", "diff": ["-\tprivate Canvas       paintCanvas;\r\tprivate PaintStatus  paintStatus;\r\tprivate PaintSession paintSession;\r\tprivate Image        image;\r\tprivate Rectangle    visibleRect;\r\tprivate Rectangle    imageRect;\r\r\tprivate GC           displayGC;    // the GC used for drawing to the display\r\tprivate GC           rubberbandGC; // the GC used exclusively for rubberband drawing\r\tprivate GC           imageGC;      // the GC used as a permanent backing store\r\tprivate Color        rubberbandFGColor, rubberbandBGColor;\r\t\r\tprivate ContainerFigure rubberband; // the active rubberband selection\r\tprivate Object         rubberbandState; // the active rubberband selection previewing state\r\tprivate int rubberbandHiddenNestingCount; // always >= 0, if > 0 rubberband has been hidden\r\r\t/**\r\t * Constructs a PaintSurface.\r\t * <p>\r\t * paintCanvas must have SWT.NO_REDRAW_RESIZE style, and may have SWT.V_SCROLL and/or SWT.H_SCROLL.\r\t * </p>\r\t * @param paintCanvas the Canvas object in which to render\r\t * @param paintStatus the PaintStatus object to use for providing user feedback\r\t */\r", "-\tpublic PaintSurface(Canvas paintCanvas, PaintStatus paintStatus) {\r\t\tthis.paintCanvas = paintCanvas;\r\t\tthis.paintStatus = paintStatus;\r\r\t\t/* Set up the drawing surface */\r\t\tvisibleRect = paintCanvas.getClientArea();\r\t\timageRect = paintCanvas.getDisplay().getClientArea();\r\t\timage = new Image(paintCanvas.getDisplay(), imageRect.width, imageRect.height);\r\r\t\timageGC = new GC(image);\r\t\tdisplayGC = new GC(paintCanvas);\r\t\trubberbandGC = new GC(paintCanvas);\r\t\trubberbandGC.setXORMode(true);\r\t\trubberbandFGColor = new Color(paintCanvas.getDisplay(), 255, 255, 255);\r\t\trubberbandBGColor = new Color(paintCanvas.getDisplay(), 127, 127, 127);\r\t\trubberbandGC.setForeground(rubberbandFGColor);\r\t\trubberbandGC.setBackground(rubberbandBGColor);\r\r\t\trubberbandHiddenNestingCount = 0;\r\t\trubberbandState = null;\t\t\r\t\trubberband = new ContainerFigure();\r\r\t\t/* Initialize the session */\r\t\tsetPaintSession(null);\r\r\t\t/* Add our listeners */\r\t\tpaintCanvas.addMouseListener(new MouseAdapter() {\r\t\t\tpublic void mouseDown(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDown(event);\r\t\t\t}\r\t\t\tpublic void mouseUp(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseUp(event);\r\t\t\t}\r\t\t\tpublic void mouseDoubleClick(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDoubleClick(event);\r\t\t\t}\t\t\t\r\t\t});\r\t\tpaintCanvas.addMouseMoveListener(new MouseMoveListener() {\r\t\t\tpublic void mouseMove(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseMove(event);\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addPaintListener(new PaintListener() {\r\t\t\tpublic void paintControl(PaintEvent event) {\r\t\t\t\thideRubberband();\r\t\t\t\tdisplayGC.drawImage(image,\r\t\t\t\t\tvisibleRect.x - imageRect.x, visibleRect.y - imageRect.y,\r\t\t\t\t\tvisibleRect.width, visibleRect.height, 0, 0, visibleRect.width, visibleRect.height);\r\t\t\t\tshowRubberband();\t\t\t\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addControlListener(new ControlAdapter() {\r\t\t\tpublic void controlResized(ControlEvent event) {\r\t\t\t\thandleResize();\r\t\t\t}\t\t\t\r\t\t});\r\r\t\t/* Set up the paint canvas scroll bars */\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\thorizontal.setVisible(true);\r\t\thorizontal.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollHorizontally((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tvertical.setVisible(true);\r\t\tvertical.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollVertically((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\thandleResize();\r\t}\r\t\r\t/**\r\t * Disposes of the PaintSurface's resources.\r\t */\r\tpublic void dispose() {\r\t\timageGC.dispose();\r\t\tdisplayGC.dispose();\r\t\trubberbandGC.dispose();\r\t\trubberbandFGColor.dispose();\r\t\trubberbandBGColor.dispose();\r\t\timage.dispose();\t\t\r\t}\r\r\t/**\r\t * Called when we must grab focus.\r\t */\r\tpublic void setFocus()  {\r\t\tpaintCanvas.setFocus();\r\t}\r\r\t/**\r\t * Returns the Display on which the PaintSurface resides.\r\t * @return the Display\r\t */\r\tpublic Display getDisplay() {\r\t\treturn paintCanvas.getDisplay();\r\t}\r\r\t/**\r\t * Returns the Shell in which the PaintSurface resides.\r\t * @return the Shell\r\t */\r\tpublic Shell getShell() {\r\t\treturn paintCanvas.getShell();\r\t}\r\r\t/**\r", "+\tprivate final Canvas      paintCanvas;\r\r\tprivate PaintSession paintSession;\r\tprivate Image image;\r\tprivate int   imageWidth, imageHeight;\r\tprivate int   visibleWidth, visibleHeight;\r\r\tprivate FigureDrawContext displayFDC = new FigureDrawContext();\r\tprivate FigureDrawContext imageFDC = new FigureDrawContext();\r\r\t/* Rubberband */\r\tprivate ContainerFigure rubberband = new ContainerFigure();\r\t\t// the active rubberband selection\r\tprivate int rubberbandHiddenNestingCount = 0;\r\t\t// always >= 0, if > 0 rubberband has been hidden\r\r\t/* Status */\r\tprivate final Text statusText;\r\tprivate String statusActionInfo, statusMessageInfo, statusCoordInfo;\r\r\t/**\r\t * Constructs a PaintSurface.\r\t * <p>\r\t * paintCanvas must have SWT.NO_REDRAW_RESIZE and SWT.NO_BACKGROUND styles,\r\t *     and may have SWT.V_SCROLL and/or SWT.H_SCROLL.\r\t * </p>\r\t * @param paintCanvas the Canvas object in which to render\r\t * @param paintStatus the PaintStatus object to use for providing user feedback\r\t */\r", "+\tpublic PaintSurface(Canvas paintCanvas, Text statusText) {\r\t\tthis.paintCanvas = paintCanvas;\r\t\tthis.statusText = statusText;\r\t\tclearStatus();\r\r\t\t/* Set up the drawing surface */\r\t\tRectangle displayRect = paintCanvas.getDisplay().getClientArea();\r\t\timageWidth = displayRect.width;\r\t\timageHeight = displayRect.height;\r\t\timage = new Image(paintCanvas.getDisplay(), imageWidth, imageHeight);\r\r\t\timageFDC.gc = new GC(image);\r\t\tdisplayFDC.gc = new GC(paintCanvas);\r\r\t\t/* Initialize the session */\r\t\tsetPaintSession(null);\r\r\t\t/* Add our listeners */\r\t\tpaintCanvas.addMouseListener(new MouseAdapter() {\r\t\t\tpublic void mouseDown(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDown(event);\r\t\t\t}\r\t\t\tpublic void mouseUp(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseUp(event);\r\t\t\t}\r\t\t\tpublic void mouseDoubleClick(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseDoubleClick(event);\r\t\t\t}\t\t\t\r\t\t});\r\t\tpaintCanvas.addMouseMoveListener(new MouseMoveListener() {\r\t\t\tpublic void mouseMove(MouseEvent event) {\r\t\t\t\tprocessMouseEventCoordinates(event);\r\t\t\t\tif (paintSession != null) paintSession.mouseMove(event);\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addPaintListener(new PaintListener() {\r\t\t\tpublic void paintControl(PaintEvent event) {\r\t\t\t\tif (rubberband.isEmpty()) {\r\t\t\t\t\tevent.gc.drawImage(image,\r\t\t\t\t\t\tdisplayFDC.xOffset, displayFDC.yOffset, visibleWidth, visibleHeight,\r\t\t\t\t\t\t0, 0, visibleWidth, visibleHeight);\r\t\t\t\t} else {\r\t\t\t\t\t// avoid flicker\r\t\t\t\t\tRectangle clip = event.gc.getClipping();\r\t\t\t\t\tImage blitImage = new Image(getDisplay(), event.width, event.height);\r\t\t\t\t\tFigureDrawContext fdc = new FigureDrawContext();\r\t\t\t\t\tfdc.gc = new GC(blitImage);\r\t\t\t\t\tfdc.xOffset = displayFDC.xOffset + clip.x;\r\t\t\t\t\tfdc.yOffset = displayFDC.yOffset + clip.y;\r\t\t\t\t\tfdc.gc.drawImage(image,\r\t\t\t\t\t\tclip.x + displayFDC.xOffset, clip.y + displayFDC.yOffset, clip.width, clip.height,\r\t\t\t\t\t\t0, 0, clip.width, clip.height);\r\t\t\t\t\trubberband.draw(fdc);\r\t\t\t\t\tfdc.gc.dispose();\r\t\t\t\t\tevent.gc.drawImage(blitImage, clip.x, clip.y);\r\t\t\t\t\tblitImage.dispose();\r\t\t\t\t}\r\t\t\t}\r\t\t});\r\t\tpaintCanvas.addControlListener(new ControlAdapter() {\r\t\t\tpublic void controlResized(ControlEvent event) {\r\t\t\t\thandleResize();\r\t\t\t}\t\t\t\r\t\t});\r\r\t\t/* Set up the paint canvas scroll bars */\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\thorizontal.setVisible(true);\r\t\thorizontal.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollHorizontally((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tvertical.setVisible(true);\r\t\tvertical.addSelectionListener(new SelectionAdapter() {\r\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\t\t\t\tscrollVertically((ScrollBar)event.widget);\r\t\t\t}\r\t\t});\r\t\thandleResize();\r\t}\r\t\r\t/**\r\t * Disposes of the PaintSurface's resources.\r\t */\r\tpublic void dispose() {\r\t\timageFDC.gc.dispose();\r\t\tdisplayFDC.gc.dispose();\r\t\timage.dispose();\t\t\r\t}\r\r\t/**\r\t * Called when we must grab focus.\r\t */\r\tpublic void setFocus()  {\r\t\tpaintCanvas.setFocus();\r\t}\r\r\t/**\r\t * Returns the Display on which the PaintSurface resides.\r\t * @return the Display\r\t */\r\tpublic Display getDisplay() {\r\t\treturn paintCanvas.getDisplay();\r\t}\r\r\t/**\r\t * Returns the Shell in which the PaintSurface resides.\r\t * @return the Shell\r\t */\r\tpublic Shell getShell() {\r\t\treturn paintCanvas.getShell();\r\t}\r\r\t/**\r"]}], "num": 24275}