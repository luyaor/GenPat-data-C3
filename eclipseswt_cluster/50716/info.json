{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ea72ccae4a661662c9c546e57406bfc0", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e2cd1a45fc0806e2ba457793864cb0f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "5f543edb783691ac010cc1801defbf6238ace7aa", "commitAfterChange": "ffcd121fb7431ca67e0c96c3686d0eb26efd2568", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-\t\t// Get the bitmap data from the image representation. In the non-planar case it's easy.", "-\t\tbyte imageData[] = new byte[(int)/*64*/dataSize];", "-\t\t", "-\t\tif (!imageRep.isPlanar()) {", "-\t\t\tOS.memmove(imageData, imageRep.bitmapData(), dataSize);", "-\t\t} else {", "-\t\t\tint /*long*/ bytesPerPlane = imageRep.bytesPerPlane();", "-\t\t\tint /*long*/ numPlanes = imageRep.numberOfPlanes();", "-\t\t\t", "-\t\t\t// getBitmapDataPlanes always returns an array of five pointers. Non-applicable", "-\t\t\t// data planes are set to NULL (0).", "-\t\t\tint /*long*/ nativeDataPlanes[] = new int /*long*/ [5];", "-\t\t\timageRep.getBitmapDataPlanes(nativeDataPlanes);", "-\t\t\t", "-\t\t\tbyte dataPlanes[][] = new byte[(int)/*64*/numPlanes][(int)/*64*/bytesPerPlane];", "-\t\t\tfor (int i = 0; i < numPlanes; i++) {", "-\t\t\t\tOS.memmove(dataPlanes[i], nativeDataPlanes[i], bytesPerPlane);", "-\t\t\t}", "-\t\t\t", "-\t\t\t// Copy the planar data into the imageData array in ARGB format if there is alpha, and RGB if not.", "-\t\t\t// All non-RGB colorspace images were rejected earlier, so planes 0, 1 and 2 have the R, G, and B", "-\t\t\t// values, respectively. Plane 3 contains alpha values, if there is alpha.", "-\t\t\tNSString colorSpace = imageRep.colorSpaceName();\t\t\t", "-\t\t\tint /*long*/ colorComponents = OS.NSNumberOfColorComponents(colorSpace.id);", "-\t\t\tboolean hasAlpha = false;", "-\t\t\t", "-\t\t\tif (colorComponents == 3) {", "-\t\t\t\tif (numPlanes == 4) hasAlpha = true;", "-\t\t\t\tint samplesPerPixel = (hasAlpha ? 4 : 3);", "-\t\t\t\tint firstByteOfPixel = (hasAlpha ? 1 : 0);", "-\t\t\t\t", "-\t\t\t\tfor (int j = 0, k = 0; j < bytesPerPlane; j += samplesPerPixel, k++) {", "-\t\t\t\t\timageData[j + firstByteOfPixel] = dataPlanes[0][k]; // red component", "-\t\t\t\t\timageData[j + firstByteOfPixel + 1] = dataPlanes[1][k]; // blue component", "-\t\t\t\t\timageData[j + firstByteOfPixel + 2] = dataPlanes[2][k]; // green component", "-\t\t\t\t\tif (hasAlpha) imageData[j] = dataPlanes[3][k]; // alpha component", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-", "-\t\t// The RGB mask depends on where the alpha was stored in the pixel data.", "-\t\tint /*long*/ dataFormat = imageRep.bitmapFormat();", "-\t\tPaletteData palette = null;", "-", "-\t\tint /*long*/ bps = imageRep.bitsPerSample();", "-\t\tint blueMask = (1 << bps) - 1;", "-\t\tif (imageRep.hasAlpha() && (dataFormat & OS.NSAlphaFirstBitmapFormat) == 0) blueMask <<= bps;", "-\t\tint greenMask = blueMask << bps;", "-\t\tint redMask = greenMask << bps;", "-\t\t", "-\t\tpalette = new PaletteData(redMask, greenMask, blueMask);", "-", "+\t\tPaletteData palette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "-\t\t\tint startByte = ((dataFormat & OS.NSAlphaFirstBitmapFormat) == 0 ? 3 : 0);", "-\t\t\tint offset = startByte, maskOffset = 0;", "+\t\t\tint offset = 0, maskOffset = 0;", "-\t\t", "-\t\tint startByte = ((dataFormat & OS.NSAlphaFirstBitmapFormat) == 0 ? 3 : 0);", "-\t\tfor (int i = startByte; i < srcData.length; i+= 4) {", "+\t\tfor (int i = 0; i < srcData.length; i+= 4) {", "-\t\tif (imageRep.hasAlpha()) {", "-\t\t\tdata.alpha = alpha;", "-\t\t\tif (alpha == -1 && alphaData != null) {", "-\t\t\t\tdata.alphaData = new byte[alphaData.length];", "-\t\t\t\tSystem.arraycopy(alphaData, 0, data.alphaData, 0, alphaData.length);", "-\t\t\t}", "+\t\tdata.alpha = alpha;", "+\t\tif (alpha == -1 && alphaData != null) {", "+\t\t\tdata.alphaData = new byte[alphaData.length];", "+\t\t\tSystem.arraycopy(alphaData, 0, data.alphaData, 0, alphaData.length);", "-\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d351f325a09e42aa3337fa22f67aa476", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "a5d8bf4a11b89f56aac32b46dedff4139fb6f012", "commitAfterChange": "e5c0f149512ead935dccc62f02bd92225ca98187", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-\t\tNSSize size = handle.size();", "-\t\tint width = (int)size.width;", "-\t\tint height = (int)size.height;", "+\t\tint /*long*/ width = imageRep.pixelsWide();", "+\t\tint /*long*/ height = imageRep.pixelsHigh();", "-\t\tbyte[] srcData = new byte[(int)/*64*/dataSize];", "+", "+\t\t// Get the bitmap data from the image representation. In the non-planar case it's easy.", "+\t\tbyte[] srcData = new byte[dataSize];", "+\t\tbyte imageData[] = new byte[dataSize];", "+\t\t", "+\t\tif (!imageRep.isPlanar()) {", "+\t\t\tOS.memmove(imageData, imageRep.bitmapData(), dataSize);", "+\t\t} else {", "+\t\t\tint bytesPerPlane = imageRep.bytesPerPlane();", "+\t\t\tint numPlanes = imageRep.numberOfPlanes();", "+\t\t\t", "+\t\t\t// getBitmapDataPlanes always returns an array of five pointers. Non-applicable", "+\t\t\t// data planes are set to NULL (0).", "+\t\t\tint nativeDataPlanes[] = new int[5];", "+\t\t\timageRep.getBitmapDataPlanes(nativeDataPlanes);", "+\t\t\t", "+\t\t\tbyte dataPlanes[][] = new byte[numPlanes][bytesPerPlane];", "+\t\t\tfor (int i = 0; i < numPlanes; i++) {", "+\t\t\t\tOS.memmove(dataPlanes[i], nativeDataPlanes[i], bytesPerPlane);", "+\t\t\t}", "+\t\t\t", "+\t\t\t// Copy the planar data into the imageData array in ARGB format if there is alpha, and RGB if not.", "+\t\t\t// All non-RGB colorspace images were rejected earlier, so planes 0, 1 and 2 have the R, G, and B", "+\t\t\t// values, respectively. Plane 3 contains alpha values, if there is alpha.", "+\t\t\tNSString colorSpace = imageRep.colorSpaceName();\t\t\t", "+\t\t\tint colorComponents = OS.NSNumberOfColorComponents(colorSpace.id);", "+\t\t\tboolean hasAlpha = false;", "+\t\t\t", "+\t\t\tif (colorComponents == 3) {", "+\t\t\t\tif (numPlanes == 4) hasAlpha = true;", "+\t\t\t\tint samplesPerPixel = (hasAlpha ? 4 : 3);", "+\t\t\t\tint firstByteOfPixel = (hasAlpha ? 1 : 0);", "+\t\t\t\t", "+\t\t\t\tfor (int j = 0, k = 0; j < bytesPerPlane; j += samplesPerPixel, k++) {", "+\t\t\t\t\timageData[j + firstByteOfPixel] = dataPlanes[0][k]; // red component", "+\t\t\t\t\timageData[j + firstByteOfPixel + 1] = dataPlanes[1][k]; // blue component", "+\t\t\t\t\timageData[j + firstByteOfPixel + 2] = dataPlanes[2][k]; // green component", "+\t\t\t\t\tif (hasAlpha) imageData[j] = dataPlanes[3][k]; // alpha component", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+", "-\t\tPaletteData palette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "+\t\t// The RGB mask depends on where the alpha was stored in the pixel data.", "+\t\tint dataFormat = imageRep.bitmapFormat();", "+\t\tPaletteData palette = null;", "+", "+\t\tint /*long*/ bps = imageRep.bitsPerSample();", "+\t\tint blueMask = (1 << bps) - 1;", "+\t\tif (imageRep.hasAlpha() && (dataFormat & OS.NSAlphaFirstBitmapFormat) == 0) blueMask <<= bps;", "+\t\tint greenMask = blueMask << bps;", "+\t\tint redMask = greenMask << bps;", "+\t\t", "+\t\tpalette = new PaletteData(redMask, greenMask, blueMask);", "+", "-\t\t\tint offset = 0, maskOffset = 0;", "+\t\t\tint startByte = ((dataFormat & OS.NSAlphaFirstBitmapFormat) == 0 ? 3 : 0);", "+\t\t\tint offset = startByte, maskOffset = 0;", "-\t\tfor (int i = 0; i < srcData.length; i+= 4) {", "-\t\t\tsrcData[i] = 0;", "+\t\t", "+\t\tif (imageRep.hasAlpha()) {", "+\t\t\tint startByte = ((dataFormat & OS.NSAlphaFirstBitmapFormat) == 0 ? 3 : 0);", "+\t\t\tfor (int i = startByte; i < srcData.length; i+= 4) {", "+\t\t\t\tsrcData[i] = 0;", "+\t\t\t}", "+\t\t\tdata.alpha = alpha;", "+\t\t\tif (alpha == -1 && alphaData != null) {", "+\t\t\t\tdata.alphaData = new byte[alphaData.length];", "+\t\t\t\tSystem.arraycopy(alphaData, 0, data.alphaData, 0, alphaData.length);", "+\t\t\t}", "-\t\tdata.alpha = alpha;", "-\t\tif (alpha == -1 && alphaData != null) {", "-\t\t\tdata.alphaData = new byte[alphaData.length];", "-\t\t\tSystem.arraycopy(alphaData, 0, data.alphaData, 0, alphaData.length);", "-\t\t}", "+\t\t"]}], "num": 50716}