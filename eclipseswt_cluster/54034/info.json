{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c28150d14689e43242e69a933cb1bcde", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "425decc7079c2ab27279d801b5aeb509", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/mozilla/org/eclipse/swt/browser/Browser.java", "commitBeforeChange": "f63d2d89eea406485e981f9daea08c5a772ca9aa", "commitAfterChange": "37a89c226e0afdd207de782e49ef0b2912a4c1ef", "methodNumberBeforeChange": 95, "methodNumberAfterChange": 96, "signatureBeforeChange": "  int OnStateChange(int aWebProgress, int aRequest, int aStateFlags, int aStatus)", "signatureAfterChange": "  int OnStateChange(int aWebProgress, int aRequest, int aStateFlags, int aStatus)", "diff": ["-\tif (((aStateFlags & nsIWebProgressListener.STATE_STOP) != 0) && ((aStateFlags & nsIWebProgressListener.STATE_IS_DOCUMENT) != 0)) {", "-\t\t/* navigation completed */", "-\t\tProgressEvent event = new ProgressEvent(this);", "-\t\tfor (int i = 0; i < progressListeners.length; i++)", "-\t\t\tprogressListeners[i].completed(event);", "-\t\tStatusTextEvent event2 = new StatusTextEvent(this);", "-\t\tevent2.text = \"\"; //$NON-NLS-1$", "-\t\tfor (int i = 0; i < statusTextListeners.length; i++)", "-\t\t\tstatusTextListeners[i].changed(event2);\t", "-\t\t\t\t", "-\t}\t", "+\tif ((aStateFlags & nsIWebProgressListener.STATE_IS_DOCUMENT) == 0) return XPCOM.NS_OK;", "+\tif ((aStateFlags & nsIWebProgressListener.STATE_START) != 0) {", "+\t\tif (request == 0) request = aRequest;", "+\t} else if ((aStateFlags & nsIWebProgressListener.STATE_REDIRECTING) != 0) {", "+\t\tif (request == aRequest) request = 0;", "+\t} else if ((aStateFlags & nsIWebProgressListener.STATE_STOP) != 0) {", "+\t\tif (html != null) {", "+\t\t\tbyte[] data = html.getBytes();", "+\t\t\thtml = null;", "+", "+\t\t\t/* render HTML in memory */", "+\t\t\tString contentType = \"text/html\"; //$NON-NLS-1$", "+\t\t\t", "+\t\t\tInputStream inputStream = new InputStream(data);", "+\t\t\tinputStream.AddRef();", "+", "+\t\t\tint[] result = new int[1];", "+\t\t\tint rc = webBrowser.QueryInterface(nsIInterfaceRequestor.NS_IINTERFACEREQUESTOR_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_ERROR_NO_INTERFACE);", "+\t", "+\t\t\tnsIInterfaceRequestor interfaceRequestor = new nsIInterfaceRequestor(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = interfaceRequestor.GetInterface(nsIContentViewerContainer.NS_ICONTENTVIEWERCONTAINER_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_ERROR_NO_INTERFACE);", "+\t\t\tinterfaceRequestor.Release();", "+\t", "+\t\t\tnsIContentViewerContainer contentViewerContainer = new nsIContentViewerContainer(result[0]);", "+\t\t\tresult[0] = 0;", "+\t", "+\t\t\trc = XPCOM.NS_GetServiceManager(result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t", "+\t\t\tnsIServiceManager serviceManager = new nsIServiceManager(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = serviceManager.GetService(XPCOM.NS_IOSERVICE_CID, nsIIOService.NS_IIOSERVICE_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);\t\t", "+\t", "+\t\t\tnsIIOService ioService = new nsIIOService(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\tbyte[] aString = \"about:blank\".getBytes(); //$NON-NLS-1$", "+\t\t\tint aSpec = XPCOM.nsCString_new(aString, aString.length);", "+\t\t\trc = ioService.NewURI(aSpec, null, 0, result);", "+\t\t\tXPCOM.nsCString_delete(aSpec);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t\tioService.Release();", "+\t", "+\t\t\tnsIURI uri = new nsIURI(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = XPCOM.NS_GetComponentManager(result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t", "+\t\t\tnsIComponentManager componentManager = new nsIComponentManager(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = componentManager.CreateInstance(XPCOM.NS_LOADGROUP_CID, 0, nsILoadGroup.NS_ILOADGROUP_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t\tnsILoadGroup loadGroup = new nsILoadGroup(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = componentManager.CreateInstance(XPCOM.NS_INPUTSTREAMCHANNEL_CID, 0, nsIInputStreamChannel.NS_IINPUTSTREAMCHANNEL_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);\t", "+\t\t\tnsIInputStreamChannel inputStreamChannel = new nsIInputStreamChannel(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\tcomponentManager.Release();\t", "+\t\t\t", "+\t\t\trc = inputStreamChannel.SetURI(uri.getAddress());", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\trc = inputStreamChannel.SetContentStream(inputStream.getAddress());", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tbyte[] buffer = contentType.getBytes();", "+\t\t\tbyte[] contentTypeBuffer = new byte[buffer.length + 1];", "+\t\t\tSystem.arraycopy(buffer, 0, contentTypeBuffer, 0, buffer.length);", "+\t\t\tint aContentType = XPCOM.nsCString_new(contentTypeBuffer, contentTypeBuffer.length);", "+\t\t\trc = inputStreamChannel.SetContentType(aContentType);", "+\t\t\tXPCOM.nsCString_delete(aContentType);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tbyte[] contentCharsetBuffer = new byte[1];", "+\t\t\tint aContentCharset = XPCOM.nsCString_new(contentCharsetBuffer, contentCharsetBuffer.length);", "+\t\t\trc = inputStreamChannel.SetContentCharset(aContentCharset);", "+\t\t\tXPCOM.nsCString_delete(aContentCharset);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\trc = inputStreamChannel.SetLoadGroup(loadGroup.getAddress());", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t", "+\t\t\tbuffer = XPCOM.NS_CATEGORYMANAGER_CONTRACTID.getBytes();", "+\t\t\tbyte[] aContractID = new byte[buffer.length + 1];", "+\t\t\tSystem.arraycopy(buffer, 0, aContractID, 0, buffer.length);", "+\t\t\trc = serviceManager.GetServiceByContractID(aContractID, nsICategoryManager.NS_ICATEGORYMANAGER_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);\t\t", "+\t", "+\t\t\tnsICategoryManager categoryManager = new nsICategoryManager(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\tbuffer = \"Gecko-Content-Viewers\".getBytes(); //$NON-NLS-1$", "+\t\t\tbyte[] aCategory = new byte[buffer.length + 1];", "+\t\t\tSystem.arraycopy(buffer, 0, aCategory, 0, buffer.length);", "+\t\t\trc = categoryManager.GetCategoryEntry(aCategory, contentTypeBuffer, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t\tcategoryManager.Release();", "+\t", "+\t\t\tint length = XPCOM.strlen(result[0]);", "+\t\t\taContractID = new byte[length + 1];", "+\t\t\tXPCOM.memmove(aContractID, result[0], length);", "+\t\t\trc = serviceManager.GetServiceByContractID(aContractID, nsIDocumentLoaderFactory.NS_IDOCUMENTLOADERFACTORY_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);\t", "+\t", "+\t\t\tnsIDocumentLoaderFactory documentLoaderFactory = new nsIDocumentLoaderFactory(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\tbuffer = \"view\".getBytes(); //$NON-NLS-1$", "+\t\t\tbyte[] aCommand = new byte[buffer.length + 1];", "+\t\t\tSystem.arraycopy(buffer, 0, aCommand, 0, buffer.length);", "+\t\t\tint[] aDocListenerResult = new int[1];", "+\t\t\trc = documentLoaderFactory.CreateInstance(aCommand, inputStreamChannel.getAddress(), loadGroup.getAddress(),", "+\t\t\t\t\tcontentTypeBuffer, contentViewerContainer.getAddress(), 0, aDocListenerResult, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (aDocListenerResult[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t\tdocumentLoaderFactory.Release();", "+\t", "+\t\t\tnsIContentViewer contentViewer = new nsIContentViewer(result[0]);", "+\t\t\tnsIStreamListener streamListener = new nsIStreamListener(aDocListenerResult[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = contentViewer.SetContainer(contentViewerContainer.getAddress());", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\trc = contentViewerContainer.Embed(contentViewer.getAddress(), aCommand, 0);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tcontentViewer.Release();", "+\t", "+\t\t\trc = inputStreamChannel.QueryInterface(nsIRequest.NS_IREQUEST_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t", "+\t\t\tnsIRequest request = new nsIRequest(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = streamListener.OnStartRequest(request.getAddress(), 0);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t", "+\t\t\t/* append */", "+\t\t\trc = streamListener.OnDataAvailable(request.getAddress(), 0, inputStream.getAddress(), 0, data.length);", "+\t\t\t", "+\t\t\t/*", "+\t\t\t* Note.   Mozilla returns a NS_ERROR_HTMLPARSER_UNRESOLVEDDTD if the given content", "+\t\t\t* cannot be rendered as HTML.  Silently ignore this error. ", "+\t\t\t*/", "+\t\t\tif (rc != XPCOM.NS_ERROR_HTMLPARSER_UNRESOLVEDDTD && rc != XPCOM.NS_OK) error(rc);", "+\t", "+\t\t\t/* close */", "+\t\t\trc = streamListener.OnStopRequest(request.getAddress(), 0, XPCOM.NS_OK);", "+\t\t\tif (rc != XPCOM.NS_ERROR_HTMLPARSER_UNRESOLVEDDTD && rc != XPCOM.NS_OK) error(rc);", "+\t", "+\t\t\trequest.Release();", "+\t\t\tstreamListener.Release();", "+\t\t\tserviceManager.Release();", "+\t\t\tinputStreamChannel.Release();", "+\t\t\tloadGroup.Release();", "+\t\t\turi.Release();", "+\t\t\tcontentViewerContainer.Release();", "+\t\t\tinputStream.Release();", "+\t\t}", "+", "+\t\t/*", "+\t\t* Feature on Mozilla.  When a request is redirected (STATE_REDIRECTING),", "+\t\t* it never reaches the state STATE_STOP and it is replaced with a new request.", "+\t\t* The new request is received when it is in the state STATE_STOP.", "+\t\t* To handle this case,  the variable request is set to 0 when the corresponding", "+\t\t* request is redirected. The following request received with the state STATE_STOP", "+\t\t* - the new request resulting from the redirection - is used to send", "+\t\t* the ProgressListener.completed event.", "+\t\t*/", "+\t\tif (request == aRequest || request == 0) {", "+\t\t\trequest = 0;", "+\t\t\tStatusTextEvent event = new StatusTextEvent(this);", "+\t\t\tevent.text = \"\"; //$NON-NLS-1$", "+\t\t\tfor (int i = 0; i < statusTextListeners.length; i++)", "+\t\t\t\tstatusTextListeners[i].changed(event);", "+\t\t\t", "+\t\t\tProgressEvent event2 = new ProgressEvent(this);", "+\t\t\tfor (int i = 0; i < progressListeners.length; i++)", "+\t\t\t\tprogressListeners[i].completed(event2);", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d42c43c828e540aef10d4985e5710276", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Mozilla/common/org/eclipse/swt/browser/Mozilla.java", "commitBeforeChange": "9fcaeb8ee69976fa279be4d81dbb74efb586ed73", "commitAfterChange": "318109a09b77020cb8d7f8d97b41b87933157e53", "methodNumberBeforeChange": 149, "methodNumberAfterChange": 150, "signatureBeforeChange": "  int HandleEvent (int event)", "signatureAfterChange": "  int HandleEvent (int event)", "diff": ["+\tif (XPCOM.DOMEVENT_KEYDOWN.equals (typeString)) {", "+\t\tint /*long*/[] result = new int /*long*/[1];", "+\t\trc = domEvent.QueryInterface (nsIDOMKeyEvent.NS_IDOMKEYEVENT_IID, result);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\tif (result[0] == 0) error (XPCOM.NS_NOINTERFACE);", "+\t\tnsIDOMKeyEvent domKeyEvent = new nsIDOMKeyEvent (result[0]);", "+\t\tresult[0] = 0;", "+", "+\t\tint[] aKeyCode = new int[1]; /* PRUint32 */", "+\t\trc = domKeyEvent.GetKeyCode (aKeyCode);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\tint keyCode = translateKey (aKeyCode[0]);", "+", "+\t\t/*", "+\t\t* if keyCode == lastKeyCode then either a repeating key like Shift", "+\t\t* is being held or a key for which key events are not sent has been", "+\t\t* pressed.  In both of these cases a KeyDown should not be sent.", "+\t\t*/", "+\t\tif (keyCode != lastKeyCode) {", "+\t\t\tlastKeyCode = keyCode;", "+\t\t\tswitch (lastKeyCode) {", "+\t\t\t\tcase SWT.SHIFT:", "+\t\t\t\tcase SWT.CONTROL:", "+\t\t\t\tcase SWT.ALT:", "+\t\t\t\tcase SWT.CAPS_LOCK:", "+\t\t\t\tcase SWT.NUM_LOCK:", "+\t\t\t\tcase SWT.SCROLL_LOCK:", "+\t\t\t\tcase SWT.COMMAND: {", "+\t\t\t\t\t/* keypress events will not be received for these keys, so send KeyDowns for them now */", "+\t\t\t\t\tboolean[] aAltKey = new boolean[1], aCtrlKey = new boolean[1], aShiftKey = new boolean[1], aMetaKey = new boolean[1]; ", "+\t\t\t\t\trc = domKeyEvent.GetAltKey (aAltKey);", "+\t\t\t\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\t\t\t\trc = domKeyEvent.GetCtrlKey (aCtrlKey);", "+\t\t\t\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\t\t\t\trc = domKeyEvent.GetShiftKey (aShiftKey);", "+\t\t\t\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\t\t\t\trc = domKeyEvent.GetMetaKey (aMetaKey);", "+\t\t\t\t\tif (rc != XPCOM.NS_OK) error (rc);", "+", "+\t\t\t\t\tEvent keyEvent = new Event ();", "+\t\t\t\t\tkeyEvent.widget = browser;", "+\t\t\t\t\tkeyEvent.type = SWT.KeyDown;", "+\t\t\t\t\tkeyEvent.keyCode = lastKeyCode;", "+\t\t\t\t\tkeyEvent.stateMask = (aAltKey[0] ? SWT.ALT : 0) | (aCtrlKey[0] ? SWT.CTRL : 0) | (aShiftKey[0] ? SWT.SHIFT : 0) | (aMetaKey[0] ? SWT.MOD1 : 0);", "+\t\t\t\t\tkeyEvent.stateMask &= ~lastKeyCode;\t\t/* remove current keydown if it's a state key */", "+\t\t\t\t\tbrowser.notifyListeners (keyEvent.type, keyEvent);", "+\t\t\t\t}", "+\t\t\t\tdefault: {", "+\t\t\t\t\t/* do nothing, KeyDown event will be sent for this key by keypress listener */", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tdomKeyEvent.Release ();", "+\t\treturn XPCOM.NS_OK;", "+\t}", "+", "+\tif (XPCOM.DOMEVENT_KEYPRESS.equals (typeString)) {", "+\t\t/*", "+\t\t* if keydown could not determine a keycode for this key then it's a", "+\t\t* key for which key events are not sent (eg.- the Windows key)", "+\t\t*/", "+\t\tif (lastKeyCode == 0) return XPCOM.NS_OK;", "+", "+\t\t/*", "+\t\t* On linux only, unexpected keypress events are received for some", "+\t\t* modifier keys.  The workaround is to ignore these events since", "+\t\t* KeyDown events are sent for these keys in the keydown listener.  ", "+\t\t*/", "+\t\tswitch (lastKeyCode) {", "+\t\t\tcase SWT.CAPS_LOCK:", "+\t\t\tcase SWT.NUM_LOCK:", "+\t\t\tcase SWT.SCROLL_LOCK: return XPCOM.NS_OK;", "+\t\t}", "+", "+\t\tint /*long*/[] result = new int /*long*/[1];", "+\t\trc = domEvent.QueryInterface (nsIDOMKeyEvent.NS_IDOMKEYEVENT_IID, result);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\tif (result[0] == 0) error (XPCOM.NS_NOINTERFACE);", "+\t\tnsIDOMKeyEvent domKeyEvent = new nsIDOMKeyEvent (result[0]);", "+\t\tresult[0] = 0;", "+", "+\t\tboolean[] aAltKey = new boolean[1], aCtrlKey = new boolean[1], aShiftKey = new boolean[1], aMetaKey = new boolean[1]; ", "+\t\trc = domKeyEvent.GetAltKey (aAltKey);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\trc = domKeyEvent.GetCtrlKey (aCtrlKey);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\trc = domKeyEvent.GetShiftKey (aShiftKey);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\trc = domKeyEvent.GetMetaKey (aMetaKey);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\tdomKeyEvent.Release ();", "+", "+\t\tint[] aCharCode = new int[1]; /* PRUint32 */", "+\t\trc = domKeyEvent.GetCharCode (aCharCode);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\tlastCharCode = aCharCode[0];", "+\t\tif (lastCharCode == 0) {", "+\t\t\tswitch (lastKeyCode) {", "+\t\t\t\tcase SWT.TAB: lastCharCode = SWT.TAB; break;", "+\t\t\t\tcase SWT.CR: lastCharCode = SWT.CR; break;", "+\t\t\t\tcase SWT.BS: lastCharCode = SWT.BS; break;", "+\t\t\t\tcase SWT.ESC: lastCharCode = SWT.ESC; break;", "+\t\t\t\tcase SWT.DEL: lastCharCode = SWT.DEL; break;", "+\t\t\t}", "+\t\t}", "+\t\tif (aCtrlKey[0] && (0 <= lastCharCode && lastCharCode <= 0x7F)) {", "+\t\t\tif ('a'  <= lastCharCode && lastCharCode <= 'z') lastCharCode -= 'a' - 'A';", "+\t\t\tif (64 <= lastCharCode && lastCharCode <= 95) lastCharCode -= 64;", "+\t\t}", "+", "+\t\tEvent keyEvent = new Event ();", "+\t\tkeyEvent.widget = browser;", "+\t\tkeyEvent.type = SWT.KeyDown;", "+\t\tkeyEvent.keyCode = lastKeyCode;", "+\t\tkeyEvent.character = (char)lastCharCode;", "+\t\tkeyEvent.stateMask = (aAltKey[0] ? SWT.ALT : 0) | (aCtrlKey[0] ? SWT.CTRL : 0) | (aShiftKey[0] ? SWT.SHIFT : 0) | (aMetaKey[0] ? SWT.MOD1 : 0);", "+\t\tbrowser.notifyListeners (keyEvent.type, keyEvent);", "+\t\treturn XPCOM.NS_OK;", "+\t}", "+", "+\tif (XPCOM.DOMEVENT_KEYUP.equals (typeString)) {", "+\t\tint /*long*/[] result = new int /*long*/[1];", "+\t\trc = domEvent.QueryInterface (nsIDOMKeyEvent.NS_IDOMKEYEVENT_IID, result);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\tif (result[0] == 0) error (XPCOM.NS_NOINTERFACE);", "+\t\tnsIDOMKeyEvent domKeyEvent = new nsIDOMKeyEvent (result[0]);", "+\t\tresult[0] = 0;", "+", "+\t\tint[] aKeyCode = new int[1]; /* PRUint32 */", "+\t\trc = domKeyEvent.GetKeyCode (aKeyCode);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\tint keyCode = translateKey (aKeyCode[0]);", "+\t\tif (keyCode == 0) {", "+\t\t\t/* indicates a key for which key events are not sent */", "+\t\t\tdomKeyEvent.Release ();", "+\t\t\treturn XPCOM.NS_OK;", "+\t\t}", "+\t\tif (keyCode != lastKeyCode) {", "+\t\t\t/* keyup does not correspond to the last keydown */", "+\t\t\tlastKeyCode = keyCode;", "+\t\t\tlastCharCode = 0;", "+\t\t}", "+", "+\t\tboolean[] aAltKey = new boolean[1], aCtrlKey = new boolean[1], aShiftKey = new boolean[1], aMetaKey = new boolean[1]; ", "+\t\trc = domKeyEvent.GetAltKey (aAltKey);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\trc = domKeyEvent.GetCtrlKey (aCtrlKey);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\trc = domKeyEvent.GetShiftKey (aShiftKey);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\trc = domKeyEvent.GetMetaKey (aMetaKey);", "+\t\tif (rc != XPCOM.NS_OK) error (rc);", "+\t\tdomKeyEvent.Release ();", "+", "+\t\tEvent keyEvent = new Event ();", "+\t\tkeyEvent.widget = browser;", "+\t\tkeyEvent.type = SWT.KeyUp;", "+\t\tkeyEvent.keyCode = lastKeyCode;", "+\t\tkeyEvent.character = (char)lastCharCode;", "+\t\tkeyEvent.stateMask = (aAltKey[0] ? SWT.ALT : 0) | (aCtrlKey[0] ? SWT.CTRL : 0) | (aShiftKey[0] ? SWT.SHIFT : 0) | (aMetaKey[0] ? SWT.MOD1 : 0);", "+\t\tswitch (lastKeyCode) {", "+\t\t\tcase SWT.SHIFT:", "+\t\t\tcase SWT.CONTROL:", "+\t\t\tcase SWT.ALT:", "+\t\t\tcase SWT.COMMAND: {", "+\t\t\t\tkeyEvent.stateMask |= lastKeyCode;", "+\t\t\t}", "+\t\t}", "+\t\tbrowser.notifyListeners (keyEvent.type, keyEvent);", "+\t\tlastKeyCode = lastCharCode = 0;", "+\t\treturn XPCOM.NS_OK;", "+\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5aca7769820394deb5d9a89db2e8a5e0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/motif/org/eclipse/swt/browser/Browser.java", "commitBeforeChange": "012bcd5ad33eb8f874b0e882b660168d07a6e07b", "commitAfterChange": "85f8f40ad2f5a5828657483f09a47fe1554ac511", "methodNumberBeforeChange": 96, "methodNumberAfterChange": 97, "signatureBeforeChange": "  int OnStateChange(int aWebProgress, int aRequest, int aStateFlags, int aStatus)", "signatureAfterChange": "  int OnStateChange(int aWebProgress, int aRequest, int aStateFlags, int aStatus)", "diff": ["-\tif (((aStateFlags & nsIWebProgressListener.STATE_STOP) != 0) && ((aStateFlags & nsIWebProgressListener.STATE_IS_DOCUMENT) != 0)) {", "-\t\t/* navigation completed */", "-\t\tProgressEvent event = new ProgressEvent(this);", "-\t\tfor (int i = 0; i < progressListeners.length; i++)", "-\t\t\tprogressListeners[i].completed(event);", "-\t\tStatusTextEvent event2 = new StatusTextEvent(this);", "-\t\tevent2.text = \"\"; //$NON-NLS-1$", "-\t\tfor (int i = 0; i < statusTextListeners.length; i++)", "-\t\t\tstatusTextListeners[i].changed(event2);\t", "-\t\t\t\t", "-\t}\t", "+\tif ((aStateFlags & nsIWebProgressListener.STATE_IS_DOCUMENT) == 0) return XPCOM.NS_OK;", "+\tif ((aStateFlags & nsIWebProgressListener.STATE_START) != 0) {", "+\t\tif (request == 0) request = aRequest;", "+\t} else if ((aStateFlags & nsIWebProgressListener.STATE_REDIRECTING) != 0) {", "+\t\tif (request == aRequest) request = 0;", "+\t} else if ((aStateFlags & nsIWebProgressListener.STATE_STOP) != 0) {", "+\t\tif (html != null) {", "+\t\t\tbyte[] data = html.getBytes();", "+\t\t\thtml = null;", "+", "+\t\t\t/* render HTML in memory */", "+\t\t\tString contentType = \"text/html\"; //$NON-NLS-1$", "+\t\t\t", "+\t\t\tInputStream inputStream = new InputStream(data);", "+\t\t\tinputStream.AddRef();", "+", "+\t\t\tint[] result = new int[1];", "+\t\t\tint rc = webBrowser.QueryInterface(nsIInterfaceRequestor.NS_IINTERFACEREQUESTOR_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_ERROR_NO_INTERFACE);", "+\t", "+\t\t\tnsIInterfaceRequestor interfaceRequestor = new nsIInterfaceRequestor(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = interfaceRequestor.GetInterface(nsIContentViewerContainer.NS_ICONTENTVIEWERCONTAINER_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_ERROR_NO_INTERFACE);", "+\t\t\tinterfaceRequestor.Release();", "+\t", "+\t\t\tnsIContentViewerContainer contentViewerContainer = new nsIContentViewerContainer(result[0]);", "+\t\t\tresult[0] = 0;", "+\t", "+\t\t\trc = XPCOM.NS_GetServiceManager(result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t", "+\t\t\tnsIServiceManager serviceManager = new nsIServiceManager(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = serviceManager.GetService(XPCOM.NS_IOSERVICE_CID, nsIIOService.NS_IIOSERVICE_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);\t\t", "+\t", "+\t\t\tnsIIOService ioService = new nsIIOService(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\tbyte[] aString = \"about:blank\".getBytes(); //$NON-NLS-1$", "+\t\t\tint aSpec = XPCOM.nsCString_new(aString, aString.length);", "+\t\t\trc = ioService.NewURI(aSpec, null, 0, result);", "+\t\t\tXPCOM.nsCString_delete(aSpec);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t\tioService.Release();", "+\t", "+\t\t\tnsIURI uri = new nsIURI(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = XPCOM.NS_GetComponentManager(result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t", "+\t\t\tnsIComponentManager componentManager = new nsIComponentManager(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = componentManager.CreateInstance(XPCOM.NS_LOADGROUP_CID, 0, nsILoadGroup.NS_ILOADGROUP_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t\tnsILoadGroup loadGroup = new nsILoadGroup(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = componentManager.CreateInstance(XPCOM.NS_INPUTSTREAMCHANNEL_CID, 0, nsIInputStreamChannel.NS_IINPUTSTREAMCHANNEL_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);\t", "+\t\t\tnsIInputStreamChannel inputStreamChannel = new nsIInputStreamChannel(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\tcomponentManager.Release();\t", "+\t\t\t", "+\t\t\trc = inputStreamChannel.SetURI(uri.getAddress());", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\trc = inputStreamChannel.SetContentStream(inputStream.getAddress());", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tbyte[] buffer = contentType.getBytes();", "+\t\t\tbyte[] contentTypeBuffer = new byte[buffer.length + 1];", "+\t\t\tSystem.arraycopy(buffer, 0, contentTypeBuffer, 0, buffer.length);", "+\t\t\tint aContentType = XPCOM.nsCString_new(contentTypeBuffer, contentTypeBuffer.length);", "+\t\t\trc = inputStreamChannel.SetContentType(aContentType);", "+\t\t\tXPCOM.nsCString_delete(aContentType);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tbyte[] contentCharsetBuffer = new byte[1];", "+\t\t\tint aContentCharset = XPCOM.nsCString_new(contentCharsetBuffer, contentCharsetBuffer.length);", "+\t\t\trc = inputStreamChannel.SetContentCharset(aContentCharset);", "+\t\t\tXPCOM.nsCString_delete(aContentCharset);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\trc = inputStreamChannel.SetLoadGroup(loadGroup.getAddress());", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t", "+\t\t\tbuffer = XPCOM.NS_CATEGORYMANAGER_CONTRACTID.getBytes();", "+\t\t\tbyte[] aContractID = new byte[buffer.length + 1];", "+\t\t\tSystem.arraycopy(buffer, 0, aContractID, 0, buffer.length);", "+\t\t\trc = serviceManager.GetServiceByContractID(aContractID, nsICategoryManager.NS_ICATEGORYMANAGER_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);\t\t", "+\t", "+\t\t\tnsICategoryManager categoryManager = new nsICategoryManager(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\tbuffer = \"Gecko-Content-Viewers\".getBytes(); //$NON-NLS-1$", "+\t\t\tbyte[] aCategory = new byte[buffer.length + 1];", "+\t\t\tSystem.arraycopy(buffer, 0, aCategory, 0, buffer.length);", "+\t\t\trc = categoryManager.GetCategoryEntry(aCategory, contentTypeBuffer, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t\tcategoryManager.Release();", "+\t", "+\t\t\tint length = XPCOM.strlen(result[0]);", "+\t\t\taContractID = new byte[length + 1];", "+\t\t\tXPCOM.memmove(aContractID, result[0], length);", "+\t\t\trc = serviceManager.GetServiceByContractID(aContractID, nsIDocumentLoaderFactory.NS_IDOCUMENTLOADERFACTORY_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);\t", "+\t", "+\t\t\tnsIDocumentLoaderFactory documentLoaderFactory = new nsIDocumentLoaderFactory(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\tbuffer = \"view\".getBytes(); //$NON-NLS-1$", "+\t\t\tbyte[] aCommand = new byte[buffer.length + 1];", "+\t\t\tSystem.arraycopy(buffer, 0, aCommand, 0, buffer.length);", "+\t\t\tint[] aDocListenerResult = new int[1];", "+\t\t\trc = documentLoaderFactory.CreateInstance(aCommand, inputStreamChannel.getAddress(), loadGroup.getAddress(),", "+\t\t\t\t\tcontentTypeBuffer, contentViewerContainer.getAddress(), 0, aDocListenerResult, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (aDocListenerResult[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t\t\tdocumentLoaderFactory.Release();", "+\t", "+\t\t\tnsIContentViewer contentViewer = new nsIContentViewer(result[0]);", "+\t\t\tnsIStreamListener streamListener = new nsIStreamListener(aDocListenerResult[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = contentViewer.SetContainer(contentViewerContainer.getAddress());", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\trc = contentViewerContainer.Embed(contentViewer.getAddress(), aCommand, 0);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tcontentViewer.Release();", "+\t", "+\t\t\trc = inputStreamChannel.QueryInterface(nsIRequest.NS_IREQUEST_IID, result);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t\t\tif (result[0] == 0) error(XPCOM.NS_NOINTERFACE);", "+\t", "+\t\t\tnsIRequest request = new nsIRequest(result[0]);", "+\t\t\tresult[0] = 0;", "+\t\t\trc = streamListener.OnStartRequest(request.getAddress(), 0);", "+\t\t\tif (rc != XPCOM.NS_OK) error(rc);", "+\t", "+\t\t\t/* append */", "+\t\t\trc = streamListener.OnDataAvailable(request.getAddress(), 0, inputStream.getAddress(), 0, data.length);", "+\t\t\t", "+\t\t\t/*", "+\t\t\t* Note.   Mozilla returns a NS_ERROR_HTMLPARSER_UNRESOLVEDDTD if the given content", "+\t\t\t* cannot be rendered as HTML.  Silently ignore this error. ", "+\t\t\t*/", "+\t\t\tif (rc != XPCOM.NS_ERROR_HTMLPARSER_UNRESOLVEDDTD && rc != XPCOM.NS_OK) error(rc);", "+\t", "+\t\t\t/* close */", "+\t\t\trc = streamListener.OnStopRequest(request.getAddress(), 0, XPCOM.NS_OK);", "+\t\t\tif (rc != XPCOM.NS_ERROR_HTMLPARSER_UNRESOLVEDDTD && rc != XPCOM.NS_OK) error(rc);", "+\t", "+\t\t\trequest.Release();", "+\t\t\tstreamListener.Release();", "+\t\t\tserviceManager.Release();", "+\t\t\tinputStreamChannel.Release();", "+\t\t\tloadGroup.Release();", "+\t\t\turi.Release();", "+\t\t\tcontentViewerContainer.Release();", "+\t\t\tinputStream.Release();", "+\t\t}", "+", "+\t\t/*", "+\t\t* Feature on Mozilla.  When a request is redirected (STATE_REDIRECTING),", "+\t\t* it never reaches the state STATE_STOP and it is replaced with a new request.", "+\t\t* The new request is received when it is in the state STATE_STOP.", "+\t\t* To handle this case,  the variable request is set to 0 when the corresponding", "+\t\t* request is redirected. The following request received with the state STATE_STOP", "+\t\t* - the new request resulting from the redirection - is used to send", "+\t\t* the ProgressListener.completed event.", "+\t\t*/", "+\t\tif (request == aRequest || request == 0) {", "+\t\t\trequest = 0;", "+\t\t\tStatusTextEvent event = new StatusTextEvent(this);", "+\t\t\tevent.text = \"\"; //$NON-NLS-1$", "+\t\t\tfor (int i = 0; i < statusTextListeners.length; i++)", "+\t\t\t\tstatusTextListeners[i].changed(event);", "+\t\t\t", "+\t\t\tProgressEvent event2 = new ProgressEvent(this);", "+\t\t\tfor (int i = 0; i < progressListeners.length; i++)", "+\t\t\t\tprogressListeners[i].completed(event2);", "+\t\t}", "+\t}"]}], "num": 54034}