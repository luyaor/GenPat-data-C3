{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "22892825f38f5a4309603d6cb345e36b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c9653e4ecb690a6cbc44bd10377a73cb", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/ToolBar.java", "commitBeforeChange": "344495d193406fcc18fd9d953e0e7125082dc624", "commitAfterChange": "3e7cd17b0f25301421344ef85e8eac75a5a11cf2", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "  void layoutItems ()", "signatureAfterChange": "  void layoutItems ()", "diff": ["+", "+\t/*", "+\t* Feature on Windows. When SWT.WRAP or SWT.VERTICAL are set", "+\t* the separator items with control are implemented using BTNS_BUTTON ", "+\t* instead of BTNS_SEP. When that is the case and TBSTYLE_LIST is ", "+\t* set, the layout of the ToolBar recalculates the width for all ", "+\t* BTNS_BUTTON based on the text and bitmap of the item.", "+\t* This is not strictly wrong, but the user defined width for the", "+\t* separators has to be respected if set.", "+\t* The fix is to detect this case and reset the cx width for the item.  ", "+\t*/", "+\tif ((style & (SWT.WRAP | SWT.VERTICAL)) != 0) {", "+\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);", "+\t\tif ((bits & OS.TBSTYLE_LIST) != 0) {", "+\t\t\tTBBUTTONINFO info = new TBBUTTONINFO ();", "+\t\t\tinfo.cbSize = TBBUTTONINFO.sizeof;", "+\t\t\tinfo.dwMask = OS.TBIF_SIZE;", "+\t\t\tfor (int i=0; i<items.length; i++) {", "+\t\t\t\tToolItem item = items [i];", "+\t\t\t\tif (item != null && item.cx > 0) {", "+\t\t\t\t\tinfo.cx = item.cx;", "+\t\t\t\t\tOS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "540b9edcd48952b760bddcb973279401", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/ToolItem.java", "commitBeforeChange": "567a2e43969febec59a4e0ca80293dd7ec0db27d", "commitAfterChange": "7e2ba37a9ab709064fb7c30a21b2171523d931fb", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  void drawWidget (int control, int damageRgn, int visibleRgn, int theEvent)", "signatureAfterChange": "  void drawWidget (int control, int damageRgn, int visibleRgn, int theEvent)", "diff": ["-\tif ((style & SWT.SEPARATOR) != 0) {", "+\tif ((style & (SWT.DROP_DOWN | SWT.SEPARATOR)) != 0) {", "+\t\tint state = OS.IsControlEnabled(control) && OS.IsControlActive (control) ? OS.kThemeStateActive : OS.kThemeStateInactive;", "-\t\trect.top += 2;", "-\t\trect.bottom -= 2;", "-\t\tOS.DrawThemeSeparator (rect, 0);", "+\t\tif ((style & SWT.SEPARATOR) != 0) {", "+\t\t\trect.top += 2;", "+\t\t\trect.bottom -= 2;", "+\t\t\tOS.DrawThemeSeparator (rect, state);", "+\t\t}", "+\t\tif ((style & SWT.DROP_DOWN) != 0) {", "+\t\t\tint height = rect.bottom - rect.top;", "+\t\t\trect.top = (short) (rect.bottom - (height / 2) - 1);", "+\t\t\trect.left = (short) (rect.right - ARROW_WIDTH);", "+\t\t\tOS.DrawThemePopupArrow (rect, (short) OS.kThemeArrowDown, (short) OS.kThemeArrow5pt, state, 0, 0);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e294f23215bc5a0337c0738e09f2d9fd", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/carbon/org/eclipse/swt/browser/Browser.java", "commitBeforeChange": "9e78211c615b3fdcc250b7f897b095a4fea9739e", "commitAfterChange": "39a3a6bf34fff830c20658e3131c367634c85e25", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": "  void didFinishLoadForFrame(int frame)", "signatureAfterChange": "  void didFinishLoadForFrame(int frame)", "diff": ["-\t\tfinal Display display= getDisplay();", "+\t\tfinal Display display = getDisplay();", "+\t\t/*", "+\t\t* To be consistent with other platforms a title event should be fired when a", "+\t\t* page has completed loading.  A page with a <title> tag will do this", "+\t\t* automatically when the didReceiveTitle callback is received.  However a page", "+\t\t* without a <title> tag will not do this by default, so fire the event", "+\t\t* here with the page's url as the title.", "+\t\t*/", "+\t\tint dataSource = Cocoa.objc_msgSend(frame, Cocoa.S_dataSource);", "+\t\tif (dataSource != 0) {", "+\t\t\tint title = Cocoa.objc_msgSend(dataSource, Cocoa.S_pageTitle);", "+\t\t\tif (title == 0) {\t/* page has no title */", "+\t\t\t\tfinal TitleEvent newEvent = new TitleEvent(this);", "+\t\t\t\tnewEvent.display = display;", "+\t\t\t\tnewEvent.widget = this;", "+\t\t\t\tnewEvent.title = url;", "+\t\t\t\tfor (int i = 0; i < titleListeners.length; i++) {", "+\t\t\t\t\tfinal TitleListener listener = titleListeners[i];", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Note on WebKit.  Running the event loop from a Browser", "+\t\t\t\t\t* delegate callback breaks the WebKit (stop loading or", "+\t\t\t\t\t* crash).  The workaround is to invoke Display.asyncExec()", "+\t\t\t\t\t* so that the Browser does not crash if this is attempted.", "+\t\t\t\t\t*/", "+\t\t\t\t\tdisplay.asyncExec(", "+\t\t\t\t\t\tnew Runnable() {", "+\t\t\t\t\t\t\tpublic void run() {", "+\t\t\t\t\t\t\t\tif (!display.isDisposed() && !isDisposed()) {", "+\t\t\t\t\t\t\t\t\tlistener.changed(newEvent);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\tprogress.display = getDisplay();", "+\t\tprogress.display = display;", "-\t\t\t* crash).  The widget ProgressBar currently touches the", "+\t\t\t* crash).  The ProgressBar widget currently touches the", "-\t\t\t* The workaround is to invoke Display.asyncexec so that", "+\t\t\t* The workaround is to invoke Display.asyncExec() so that", "-\t\t\t\t\t\tif (!display.isDisposed() && !isDisposed())", "+\t\t\t\t\t\tif (!display.isDisposed() && !isDisposed()) {", "+\t\t\t\t\t\t}"]}], "num": 44265}