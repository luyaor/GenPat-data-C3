{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "eb2ad87f151a47eab09ee773085b1563", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "648b375fb40d693780ad09fb11b08ae8", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "5b3f573e776596c93d119b7049012295cfd086ca", "commitAfterChange": "295169585c6449ae816a4e881d86e59b789fa4e5", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  void initNative(String filename)", "signatureAfterChange": "  void initNative(String filename)", "diff": ["-\t\tNSBitmapImageRep nativeRep = null;", "-\t\tNSImageRep bestRep = nativeImage.bestRepresentationForDevice(null);", "-\t\tif (!bestRep.isKindOfClass(OS.class_NSBitmapImageRep)) { ", "-\t\t\tNSArray reps = nativeImage.representations();", "-\t\t\tif (reps != null) {", "-\t\t\t\tint /*long*/ repCount = reps.count();", "-\t\t\t\t", "-\t\t\t\tfor (int i = 0; i < repCount; i++) {", "-\t\t\t\t\tNSImageRep currentRep = new NSImageRep(reps.objectAtIndex(i).id);", "-", "-\t\t\t\t\tif (currentRep.isKindOfClass(OS.class_NSBitmapImageRep)) { ", "-\t\t\t\t\t\tnativeRep = new NSBitmapImageRep(currentRep.id);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// If all else fails, get an NSBitmapImageRep directly from the NSImage.", "-\t\t\tif (nativeRep == null) {", "-\t\t\t\tnativeRep = new NSBitmapImageRep(NSBitmapImageRep.imageRepWithData(nativeImage.TIFFRepresentation()).id);", "-\t\t\t}", "-\t\t} else {", "-\t\t\tnativeRep = new NSBitmapImageRep(bestRep.id);", "-\t\t}", "-", "-\t\t// Check the image depth now. ImageData can't handle anything over 32", "-\t\t// so if that fails fall back to emulated reading.", "-\t\tint /*long*/ bpp = nativeRep.bitsPerPixel();", "+\t\tNSImageRep nativeRep = nativeImage.bestRepresentationForDevice(null);", "+\t\twidth = (int)/*64*/nativeRep.pixelsWide();", "+\t\theight = (int)/*64*/nativeRep.pixelsHigh();", "-\t\tif (bpp > 32) {", "-\t\t\treturn;", "-\t\t}", "-", "-\t\t// Only RGB images are supported.", "-\t\tNSString colorSpace = nativeRep.colorSpaceName();", "-\t\tif (!colorSpace.isEqualToString(OS.NSCalibratedRGBColorSpace))", "-\t\t\tSWT.error(SWT.ERROR_INVALID_IMAGE);", "-\t\t", "-\t\tint /*long*/ height = (int)/*64*/nativeRep.pixelsHigh();", "-\t\tint /*long*/ width = (int)/*64*/nativeRep.pixelsWide();", "-", "+\t\tboolean hasAlpha = nativeRep.hasAlpha();", "+\t\tint bpr = width * 4;", "+\t\thandle = (NSImage)new NSImage().alloc();", "-\t\tsize.height = height;", "+\t\tsize.height = height;", "+\t\thandle = handle.initWithSize(size);", "+\t\tNSBitmapImageRep rep = imageRep = (NSBitmapImageRep)new NSBitmapImageRep().alloc();", "+\t\trep = rep.initWithBitmapDataPlanes(0, width, height, 8, hasAlpha ? 4 : 3, hasAlpha, false, OS.NSDeviceRGBColorSpace, OS.NSAlphaFirstBitmapFormat | OS.NSAlphaNonpremultipliedBitmapFormat, bpr, 32);", "+\t\thandle.addRepresentation(rep);", "+", "-", "-\t\t// Get the image data. For non-planar images it's easy. For planar images we will walk through", "-\t\t// each plane of data.", "-\t\tint /*long*/ bpr = nativeRep.bytesPerRow();", "-\t\tint /*long*/ dataSize = height * bpr;", "-", "-\t\tbyte imageData[] = new byte[(int)/*64*/dataSize];", "-", "-\t\tif (!nativeRep.isPlanar()) {", "-\t\t\tOS.memmove(imageData, nativeRep.bitmapData(), dataSize);", "-\t\t} else {", "-\t\t\tint /*long*/ bytesPerPlane = nativeRep.bytesPerPlane();", "-\t\t\tint /*long*/ numPlanes = nativeRep.numberOfPlanes();", "-\t\t\t", "-\t\t\t// getBitmapDataPlanes always returns an array of five pointers. Non-applicable", "-\t\t\t// data planes are set to NULL (0).", "-\t\t\tint /*long*/ nativeDataPlanes[] = new int /*long*/ [5];", "-\t\t\tnativeRep.getBitmapDataPlanes(nativeDataPlanes);", "-\t\t\t", "-\t\t\tbyte dataPlanes[][] = new byte[(int)/*64*/numPlanes][(int)/*64*/bytesPerPlane];", "-\t\t\tfor (int i = 0; i < numPlanes; i++) {", "-\t\t\t\tOS.memmove(dataPlanes[i], nativeDataPlanes[i], bytesPerPlane);", "-\t\t\t}", "-\t\t\t", "-\t\t\t// Copy the planar data into the imageData array in ARGB format if there is alpha, and RGB if not.", "-\t\t\t// All non-RGB colorspace images were rejected earlier, so planes 0, 1 and 2 have the R, G, and B", "-\t\t\t// values, respectively. Plane 3 contains alpha values, if there is alpha.", "-\t\t\tint /*long*/ colorComponents = OS.NSNumberOfColorComponents(colorSpace.id);", "-\t\t\tboolean hasAlpha = false;", "-\t\t\t", "-\t\t\tif (colorComponents == 3) {", "-\t\t\t\tif (numPlanes == 4) hasAlpha = true;", "-\t\t\t\tint samplesPerPixel = (hasAlpha ? 4 : 3);", "-\t\t\t\tint firstByteOfPixel = (hasAlpha ? 1 : 0);", "-\t\t\t\t", "-\t\t\t\tfor (int j = 0, k = 0; j < bytesPerPlane; j += samplesPerPixel, k++) {", "-\t\t\t\t\timageData[j + firstByteOfPixel] = dataPlanes[0][k]; // red component", "-\t\t\t\t\timageData[j + firstByteOfPixel + 1] = dataPlanes[1][k]; // blue component", "-\t\t\t\t\timageData[j + firstByteOfPixel + 2] = dataPlanes[2][k]; // green component", "-\t\t\t\t\tif (hasAlpha) imageData[j] = dataPlanes[3][k]; // alpha component", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-", "-\t\tbyte[] nativeAlphaData = null;", "-\t\tint nativeTransparentColor = -1;", "+\t\trep.setAlpha(false);", "+\t\tNSGraphicsContext context = NSGraphicsContext.graphicsContextWithBitmapImageRep(rep);", "+\t\tNSGraphicsContext.static_saveGraphicsState();", "+\t\tNSGraphicsContext.setCurrentContext(context);", "+\t\tNSRect rect = new NSRect();", "+\t\trect.width = width;", "+\t\trect.height = height;", "+\t\tnativeImage.drawInRect(rect, rect, OS.NSCompositeCopy, 1);", "+ \t\tNSGraphicsContext.static_restoreGraphicsState();", "+ \t\trep.setAlpha(hasAlpha);", "-\t\tif (nativeRep.hasAlpha()) {", "+\t\tif (hasAlpha) {", "-\t\t\tNSRect imageRect = new NSRect();", "-\t\t\timageRect.x = imageRect.y = 0;", "-\t\t\timageRect.width = nativeImage.size().width;", "-\t\t\timageRect.height = nativeImage.size().height;", "-\t\t\tNSRect zeroRect = new NSRect();", "-\t\t\tzeroRect.x = zeroRect.y = zeroRect.height = zeroRect.width = 0;", "-\t\t\tnativeImage.drawInRect(imageRect, zeroRect, OS.NSCompositeCopy, 1.0f);", "+\t\t\tnativeImage.drawInRect(rect, new NSRect(), OS.NSCompositeCopy, 1.0f);", "-\t\t\t", "-\t\t\t// The alphaBitmapBuffer now contains the alpha component as an array of bytes. ", "-\t\t\tnativeAlphaData = new byte[(int)/*64*/bitmapByteCount];", "-\t\t\tOS.memmove(nativeAlphaData, alphaBitmapData, bitmapByteCount);", "+\t\t\tbyte[] alphaData = new byte[(int)/*64*/bitmapByteCount];", "+\t\t\tOS.memmove(alphaData, alphaBitmapData, bitmapByteCount);", "-\t\t\tboolean hasTransparentPixel = true;", "-\t\t\tint transparentColor = -1;", "-\t\t\tint/*64*/ alphaOffset = 0;", "-\t\t\ttransparentScan: {", "-\t\t\t\tfor (int y = 0; y < height; y++) {", "-\t\t\t\t\tfor (int x = 0; x < width; x++) {", "-\t\t\t\t\t\tif (nativeAlphaData[alphaOffset] != 0 && nativeAlphaData[alphaOffset] != -1) {", "-\t\t\t\t\t\t\thasTransparentPixel = false;\t\t\t\t\t\t", "-\t\t\t\t\t\t\tbreak transparentScan;", "-\t\t\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tif (nativeAlphaData[alphaOffset] == 0) {", "-\t\t\t\t\t\t\tNSColor color = nativeRep.colorAtX(x, y);", "-\t\t\t\t\t\t\tint red = (int) (color.redComponent() * 255);", "-\t\t\t\t\t\t\tint green = (int) (color.greenComponent() * 255);", "-\t\t\t\t\t\t\tint blue = (int) (color.blueComponent() * 255);", "-\t\t\t\t\t\t\ttransparentColor = (red << 16) + (green << 8) + blue;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t", "-\t\t\t\t\t\talphaOffset += 1;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}\t", "-\t\t\t", "-\t\t\tif (hasTransparentPixel) nativeTransparentColor = transparentColor;", "-\t\t\t\t\t", "+\t\t\tint transparentOffset = -1, i = 0;", "+\t\t\tfor (i = 0; i < alphaData.length; i++) {", "+\t\t\t\tint alpha = alphaData[i];", "+\t\t\t\tif (transparentOffset == -1 && alpha == 0) transparentOffset = i;", "+\t\t\t\tif (!(alpha == 0 || alpha == -1)) break;", "+\t\t\t}", "+\t\t\tthis.alpha = -1;", "+\t\t\tif (i == alphaData.length) {", "+\t\t\t\tNSColor color = rep.colorAtX(transparentOffset % width, transparentOffset / width);", "+\t\t\t\tint red = (int) (color.redComponent() * 255);", "+\t\t\t\tint green = (int) (color.greenComponent() * 255);", "+\t\t\t\tint blue = (int) (color.blueComponent() * 255);", "+\t\t\t\tthis.transparentPixel = (red << 16) + (green << 8) + blue;", "+\t\t\t} else {", "+\t\t\t\tthis.alphaData = alphaData;", "+\t\t\t}", "-\t\t", "-\t\t// The RGB mask depends on where the alpha was stored in the pixel data.", "-\t\tint /*long*/ dataFormat = nativeRep.bitmapFormat();", "-\t\tint /*long*/ bps = nativeRep.bitsPerSample();", "-\t\tint blueMask = (1 << bps) - 1;", "-\t\tif (nativeRep.hasAlpha() && (dataFormat & OS.NSAlphaFirstBitmapFormat) == 0) blueMask <<= bps;", "-\t\tint greenMask = blueMask << bps;", "-\t\tint redMask = greenMask << bps;\t\t", "-\t\tPaletteData palette = new PaletteData(redMask, greenMask, blueMask);", "-", "-\t\t// We now have everything we neeed to construct an ImageData object and initialize everything from that.", "-\t\tImageData data = new ImageData((int)/*64*/width, (int)/*64*/height, (int)/*64*/bpp, palette, 4, imageData);", "-\t\tdata.bytesPerLine = (int)/*64*/bpr;", "-\t\t", "-\t\tif (nativeTransparentColor != -1) {", "-\t\t\tif ((dataFormat & OS.NSAlphaFirstBitmapFormat) == 0) nativeTransparentColor <<= bps;", "-\t\t}", "-\t\t", "-\t\tdata.transparentPixel = nativeTransparentColor;", "-\t\tdata.alpha = -1;", "-\t\tdata.alphaData = nativeAlphaData;", "-\t\t", "-\t\tthis.init(data);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "383db3e0baa1f86429f3a0e168aca37a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "5f543edb783691ac010cc1801defbf6238ace7aa", "commitAfterChange": "ffcd121fb7431ca67e0c96c3686d0eb26efd2568", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  void initNative(String filename)", "signatureAfterChange": "  void initNative(String filename)", "diff": ["+\tNSImage nativeImage = null;", "+\t", "-\t\thandle = new NSImage();", "-\t\thandle.alloc();", "+\t\tnativeImage = new NSImage();", "+\t\tnativeImage.alloc();", "-\t\thandle = handle.initWithContentsOfFile(NSString.stringWith(filename));", "-\t\tif (handle == null) SWT.error(SWT.ERROR_INVALID_IMAGE);", "+\t\tnativeImage = nativeImage.initWithContentsOfFile(NSString.stringWith(filename));", "+\t\tif (nativeImage == null) SWT.error(SWT.ERROR_INVALID_IMAGE);", "-\t\tNSImageRep rep = handle.bestRepresentationForDevice(null);", "-\t\tif (rep.isKindOfClass(OS.class_NSBitmapImageRep)) { ", "-\t\t\trep.retain();", "-\t\t\timageRep = new NSBitmapImageRep(rep.id);", "-\t\t} else {", "-\t\t\tNSArray reps = handle.representations();", "+\t\tNSBitmapImageRep nativeRep = null;", "+\t\tNSImageRep bestRep = nativeImage.bestRepresentationForDevice(null);", "+\t\tif (!bestRep.isKindOfClass(OS.class_NSBitmapImageRep)) { ", "+\t\t\tNSArray reps = nativeImage.representations();", "-\t\t\t\t\t\tcurrentRep.retain();", "-\t\t\t\t\t\timageRep = new NSBitmapImageRep(currentRep.id);", "+\t\t\t\t\t\tnativeRep = new NSBitmapImageRep(currentRep.id);", "-\t\t\t// If all else fails, create an NSBitmapImageRep directly from the NSImage.", "-\t\t\tif (imageRep == null) {", "-\t\t\t\timageRep = new NSBitmapImageRep(NSBitmapImageRep.imageRepWithData(handle.TIFFRepresentation()).id);", "-\t\t\t\t// Although addRepresentation will retain the imageRep, we need to retain as well because we will", "-\t\t\t\t// release it in destroy().", "-\t\t\t\timageRep.retain();", "-\t\t\t\thandle.addRepresentation(imageRep);", "+\t\t\t// If all else fails, get an NSBitmapImageRep directly from the NSImage.", "+\t\t\tif (nativeRep == null) {", "+\t\t\t\tnativeRep = new NSBitmapImageRep(NSBitmapImageRep.imageRepWithData(nativeImage.TIFFRepresentation()).id);", "+\t\t} else {", "+\t\t\tnativeRep = new NSBitmapImageRep(bestRep.id);", "-\t\tNSString colorSpace = imageRep.colorSpaceName();", "+\t\tNSString colorSpace = nativeRep.colorSpaceName();", "-\t\theight = (int)/*64*/imageRep.pixelsHigh();", "-\t\twidth = (int)/*64*/imageRep.pixelsWide();", "+\t\tint /*long*/ height = (int)/*64*/nativeRep.pixelsHigh();", "+\t\tint /*long*/ width = (int)/*64*/nativeRep.pixelsWide();", "-\t\thandle.setSize(size);", "+\t\tnativeImage.setSize(size);", "+", "+\t\t// Get the image data. For non-planar images it's easy. For planar images we will walk through", "+\t\t// each plane of data.", "+\t\tint /*long*/ bpr = nativeRep.bytesPerRow();", "+\t\tint /*long*/ dataSize = height * bpr;", "+", "+\t\tbyte imageData[] = new byte[(int)/*64*/dataSize];", "+", "+\t\tif (!nativeRep.isPlanar()) {", "+\t\t\tOS.memmove(imageData, nativeRep.bitmapData(), dataSize);", "+\t\t} else {", "+\t\t\tint /*long*/ bytesPerPlane = nativeRep.bytesPerPlane();", "+\t\t\tint /*long*/ numPlanes = nativeRep.numberOfPlanes();", "+\t\t\t", "+\t\t\t// getBitmapDataPlanes always returns an array of five pointers. Non-applicable", "+\t\t\t// data planes are set to NULL (0).", "+\t\t\tint /*long*/ nativeDataPlanes[] = new int /*long*/ [5];", "+\t\t\tnativeRep.getBitmapDataPlanes(nativeDataPlanes);", "+\t\t\t", "+\t\t\tbyte dataPlanes[][] = new byte[(int)/*64*/numPlanes][(int)/*64*/bytesPerPlane];", "+\t\t\tfor (int i = 0; i < numPlanes; i++) {", "+\t\t\t\tOS.memmove(dataPlanes[i], nativeDataPlanes[i], bytesPerPlane);", "+\t\t\t}", "+\t\t\t", "+\t\t\t// Copy the planar data into the imageData array in ARGB format if there is alpha, and RGB if not.", "+\t\t\t// All non-RGB colorspace images were rejected earlier, so planes 0, 1 and 2 have the R, G, and B", "+\t\t\t// values, respectively. Plane 3 contains alpha values, if there is alpha.", "+\t\t\tint /*long*/ colorComponents = OS.NSNumberOfColorComponents(colorSpace.id);", "+\t\t\tboolean hasAlpha = false;", "+\t\t\t", "+\t\t\tif (colorComponents == 3) {", "+\t\t\t\tif (numPlanes == 4) hasAlpha = true;", "+\t\t\t\tint samplesPerPixel = (hasAlpha ? 4 : 3);", "+\t\t\t\tint firstByteOfPixel = (hasAlpha ? 1 : 0);", "+\t\t\t\t", "+\t\t\t\tfor (int j = 0, k = 0; j < bytesPerPlane; j += samplesPerPixel, k++) {", "+\t\t\t\t\timageData[j + firstByteOfPixel] = dataPlanes[0][k]; // red component", "+\t\t\t\t\timageData[j + firstByteOfPixel + 1] = dataPlanes[1][k]; // blue component", "+\t\t\t\t\timageData[j + firstByteOfPixel + 2] = dataPlanes[2][k]; // green component", "+\t\t\t\t\tif (hasAlpha) imageData[j] = dataPlanes[3][k]; // alpha component", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+", "+\t\tbyte[] nativeAlphaData = null;", "+\t\tint nativeTransparentColor = -1;", "-\t\tbyte[] alphaData = null;", "-\t\t", "-\t\tif (imageRep.hasAlpha()) {", "+\t\tif (nativeRep.hasAlpha()) {", "-\t\t\timageRect.width = handle.size().width;", "-\t\t\timageRect.height = handle.size().height;", "+\t\t\timageRect.width = nativeImage.size().width;", "+\t\t\timageRect.height = nativeImage.size().height;", "-\t\t\thandle.drawInRect(imageRect, zeroRect, OS.NSCompositeCopy, 1.0f);", "+\t\t\tnativeImage.drawInRect(imageRect, zeroRect, OS.NSCompositeCopy, 1.0f);", "-\t\t\talphaData = new byte[(int)/*64*/bitmapByteCount];", "-\t\t\tOS.memmove(alphaData, alphaBitmapData, bitmapByteCount);", "+\t\t\tnativeAlphaData = new byte[(int)/*64*/bitmapByteCount];", "+\t\t\tOS.memmove(nativeAlphaData, alphaBitmapData, bitmapByteCount);", "-\t\t\t\t\t\tif (alphaData[alphaOffset] != 0 && alphaData[alphaOffset] != -1) {", "-\t\t\t\t\t\t\thasTransparentPixel = false;", "+\t\t\t\t\t\tif (nativeAlphaData[alphaOffset] != 0 && nativeAlphaData[alphaOffset] != -1) {", "+\t\t\t\t\t\t\thasTransparentPixel = false;\t\t\t\t\t\t", "-\t\t\t\t\t\tif (alphaData[alphaOffset] == 0) {", "-\t\t\t\t\t\t\tNSColor color = imageRep.colorAtX(x, y);", "+\t\t\t\t\t\tif (nativeAlphaData[alphaOffset] == 0) {", "+\t\t\t\t\t\t\tNSColor color = nativeRep.colorAtX(x, y);", "-\t\t\t}", "+\t\t\t}\t", "-\t\t\tif (hasTransparentPixel) this.transparentPixel = transparentColor;", "+\t\t\tif (hasTransparentPixel) nativeTransparentColor = transparentColor;", "+\t\t\t\t\t", "-\t\tthis.alphaData = alphaData;", "+\t\t// The RGB mask depends on where the alpha was stored in the pixel data.", "+\t\tint /*long*/ dataFormat = nativeRep.bitmapFormat();", "+\t\tint /*long*/ bps = nativeRep.bitsPerSample();", "+\t\tint blueMask = (1 << bps) - 1;", "+\t\tif (nativeRep.hasAlpha() && (dataFormat & OS.NSAlphaFirstBitmapFormat) == 0) blueMask <<= bps;", "+\t\tint greenMask = blueMask << bps;", "+\t\tint redMask = greenMask << bps;\t\t", "+\t\tPaletteData palette = new PaletteData(redMask, greenMask, blueMask);", "+", "+\t\t// Get the image depth.", "+\t\tint /*long*/ bpp = nativeRep.bitsPerPixel();", "+", "+\t\t// We now have everything we neeed to construct an ImageData object and initialize everything from that.", "+\t\tImageData data = new ImageData((int)/*64*/width, (int)/*64*/height, (int)/*64*/bpp, palette, 4, imageData);", "+\t\tdata.bytesPerLine = (int)/*64*/bpr;", "+\t\tdata.transparentPixel = nativeTransparentColor;", "+\t\tdata.alpha = -1;", "+\t\tdata.alphaData = nativeAlphaData;", "+\t\t", "+\t\tthis.init(data);", "+\t\tif (nativeImage != null) nativeImage.release();"]}], "num": 17008}