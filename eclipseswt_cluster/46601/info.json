{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f4b5738467c6ee2a7985b74a458bad86", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b69526daf34509a44df40439da128d80", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "865e3942831d3760ee7191d48e9ab4f68e79460e", "commitAfterChange": "aad8ecbff6b21f1c3be77176ac706b610032dcc6", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " public int getOffset(int x, int y, int[] trailing)", "signatureAfterChange": " public int getOffset(int x, int y, int[] trailing)", "diff": ["+\t", "+\t/*", "+\t* Feature in GTK.  pango_layout_xy_to_index() returns the ", "+\t* logical end/start offset of a line when the coordinates are outside ", "+\t* the line bounds. In SWT the correct behavior is to return the closest ", "+\t* visual offset. The fix is to clamp the coordinates inside the  ", "+\t* line bounds.", "+\t*/", "+\tint /*long*/ iter = OS.pango_layout_get_iter(layout);", "+\tif (iter == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\tPangoRectangle rect = new PangoRectangle();", "+\tdo {", "+\t\tOS.pango_layout_iter_get_line_extents(iter, null, rect);", "+\t\trect.y = OS.PANGO_PIXELS(rect.y);", "+\t\trect.height = OS.PANGO_PIXELS(rect.height);", "+\t\tif (rect.y <= y && y < rect.y + rect.height) {", "+\t\t\trect.x = OS.PANGO_PIXELS(rect.x);", "+\t\t\trect.width = OS.PANGO_PIXELS(rect.width);", "+\t\t\tif (x >= rect.x + rect.width) x = rect.x + rect.width - 1;", "+\t\t\tif (x < rect.x) x = rect.x;", "+\t\t\tbreak;", "+\t\t}", "+\t} while (OS.pango_layout_iter_next_line(iter));", "+\tOS.pango_layout_iter_free(iter);", "+\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3395f4bb6cf71663d3292f43a9d4427e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "ae8649cbc5451548c97f158ddd1902c665a55911", "commitAfterChange": "e934566bfa3f9a03488420628fca653fd296f4f2", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " public Rectangle getBounds(int start, int end)", "signatureAfterChange": " public Rectangle getBounds(int start, int end)", "diff": ["+\t", "+\t/* ", "+\t* Bug in Pango. The region returned by gdk_pango_layout_get_clip_region()", "+\t* includes areas from lines outside of the requested range.  The fix", "+\t* is to subtract these areas from the clip region.", "+\t*/", "+\tPangoRectangle pangoRect = new PangoRectangle();", "+\tint /*long*/ iter = OS.pango_layout_get_iter(layout);", "+\tif (iter == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\tint /*long*/ linesRegion = OS.gdk_region_new();", "+\tif (linesRegion == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\tint lineStart = 0, lineEnd = 0;", "+\tdo {", "+\t\tOS.pango_layout_iter_get_line_extents(iter, null, pangoRect);", "+\t\tif (OS.pango_layout_iter_next_line(iter)) {", "+\t\t\tlineEnd = OS.pango_layout_iter_get_index(iter) - 1;", "+\t\t} else {", "+\t\t\tlineEnd = OS.strlen(ptr);", "+\t\t}", "+\t\tif (lineStart <= byteStart || byteEnd <= lineEnd) {", "+\t\t\trect.x = OS.PANGO_PIXELS(pangoRect.x);", "+\t\t\trect.y = OS.PANGO_PIXELS(pangoRect.y);", "+\t\t\trect.width = OS.PANGO_PIXELS(pangoRect.width);", "+\t\t\trect.height = OS.PANGO_PIXELS(pangoRect.height);", "+\t\t\tOS.gdk_region_union_with_rect(linesRegion, rect);", "+\t\t}", "+\t\tlineStart = lineEnd + 1;", "+\t} while (lineStart <= byteEnd);", "+\tOS.gdk_region_intersect(clipRegion, linesRegion);", "+\tOS.gdk_region_destroy(linesRegion);", "+\tOS.pango_layout_iter_free(iter);", "+\t"]}], "num": 46601}