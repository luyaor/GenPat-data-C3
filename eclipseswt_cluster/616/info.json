{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3f3d526d914ae0ee8b9de6b23557a791", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4ad6659ce2c2fec4acde186dcd193893", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "965aecf4cb4bb3fe4dee75052118eb5b4063e4f5", "commitAfterChange": "3eef16495f54d2582a2f00d444f7f01291b26d62", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  void init(Device device, ImageData i)", "signatureAfterChange": "  static int[] init(Device device, Image image, ImageData source, ImageData mask)", "diff": ["+static int[] init(Device device, Image image, ImageData source, ImageData mask) {", "+\t/* Create a temporary image and locate the black pixel */", "+\tImageData imageData;", "+\tint blackIndex = 0;", "+\tif (source.palette.isDirect) {", "+\t\timageData = new ImageData(source.width, source.height, source.depth, source.palette);", "+\t} else {", "+\t\tRGB black = new RGB(0, 0, 0);", "+\t\tRGB[] rgbs = source.getRGBs();", "+\t\tif (source.transparentPixel != -1) {", "+\t\t\t/*", "+\t\t\t * The source had transparency, so we can use the transparent pixel", "+\t\t\t * for black.", "+\t\t\t */", "+\t\t\tRGB[] newRGBs = new RGB[rgbs.length];", "+\t\t\tSystem.arraycopy(rgbs, 0, newRGBs, 0, rgbs.length);", "+\t\t\tif (source.transparentPixel >= newRGBs.length) {", "+\t\t\t\t/* Grow the palette with black */", "+\t\t\t\trgbs = new RGB[source.transparentPixel + 1];", "+\t\t\t\tSystem.arraycopy(newRGBs, 0, rgbs, 0, newRGBs.length);", "+\t\t\t\tfor (int i = newRGBs.length; i <= source.transparentPixel; i++) {", "+\t\t\t\t\trgbs[i] = new RGB(0, 0, 0);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tnewRGBs[source.transparentPixel] = black;", "+\t\t\t\trgbs = newRGBs;", "+\t\t\t}", "+\t\t\tblackIndex = source.transparentPixel;", "+\t\t\timageData = new ImageData(source.width, source.height, source.depth, new PaletteData(rgbs));", "+\t\t} else {", "+\t\t\twhile (blackIndex < rgbs.length) {", "+\t\t\t\tif (rgbs[blackIndex].equals(black)) break;", "+\t\t\t\tblackIndex++;", "+\t\t\t}", "+\t\t\tif (blackIndex == rgbs.length) {", "+\t\t\t\t/*", "+\t\t\t\t * We didn't find black in the palette, and there is no transparent", "+\t\t\t\t * pixel we can use.", "+\t\t\t\t */", "+\t\t\t\tif ((1 << source.depth) > rgbs.length) {", "+\t\t\t\t\t/* We can grow the palette and add black */", "+\t\t\t\t\tRGB[] newRGBs = new RGB[rgbs.length + 1];", "+\t\t\t\t\tSystem.arraycopy(rgbs, 0, newRGBs, 0, rgbs.length);", "+\t\t\t\t\tnewRGBs[rgbs.length] = black;", "+\t\t\t\t\trgbs = newRGBs;", "+\t\t\t\t} else {", "+\t\t\t\t\t/* No room to grow the palette */", "+\t\t\t\t\tblackIndex = -1;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\timageData = new ImageData(source.width, source.height, source.depth, new PaletteData(rgbs));", "+\t\t}", "+\t}", "+\tif (blackIndex == -1) {", "+\t\t/* There was no black in the palette, so just copy the data over */", "+\t\tSystem.arraycopy(source.data, 0, image.data, 0, imageData.data.length);", "+\t} else {", "+\t\t/* Modify the source image to contain black wherever the mask is 0 */", "+\t\tint[] imagePixels = new int[imageData.width];", "+\t\tint[] maskPixels = new int[mask.width];", "+\t\tfor (int y = 0; y < imageData.height; y++) {", "+\t\t\tsource.getPixels(0, y, imageData.width, imagePixels, 0);", "+\t\t\tmask.getPixels(0, y, mask.width, maskPixels, 0);", "+\t\t\tfor (int i = 0; i < imagePixels.length; i++) {", "+\t\t\t\tif (maskPixels[i] == 0) imagePixels[i] = blackIndex;", "+\t\t\t}", "+\t\t\timageData.setPixels(0, y, source.width, imagePixels, 0);", "+\t\t}", "+\t}", "+\t/*", "+\t * Make sure the mask is padded properly. Windows requires icon masks", "+\t * to have a scanline pad of 2.", "+\t */", "+\tint bytesPerLine = (((mask.width + 7) / 8) + 1) / 2 * 2;", "+\tbyte[] newMaskData = new byte[bytesPerLine * mask.height];", "+\tImageData newMask = new ImageData(mask.width, mask.height, 1, mask.palette, 2, newMaskData);", "+\tint[] maskPixels = new int[mask.width];", "+\tfor (int y = 0; y < mask.height; y++) {", "+\t\tmask.getPixels(0, y, mask.width, maskPixels, 0);", "+\t\tnewMask.setPixels(0, y, newMask.width, maskPixels, 0);", "+\t}", "+\t/* Set the fields and create the icon */", "+\timageData.maskPad = newMask.scanlinePad;", "+\timageData.maskData = newMask.data;", "+\t", "+\treturn init(device, image, imageData);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90575e7fba85c8ef19197cc2ae21cdec", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "965aecf4cb4bb3fe4dee75052118eb5b4063e4f5", "commitAfterChange": "3eef16495f54d2582a2f00d444f7f01291b26d62", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public Image(Device device, ImageData source, ImageData mask)", "signatureAfterChange": " public Image(Device device, ImageData source, ImageData mask)", "diff": ["-\t/* Create a temporary image and locate the black pixel */", "-\tImageData image;", "-\tint blackIndex = 0;", "-\tif (source.palette.isDirect) {", "-\t\timage = new ImageData(source.width, source.height, source.depth, source.palette);", "-\t} else {", "-\t\tRGB black = new RGB(0, 0, 0);", "-\t\tRGB[] rgbs = source.getRGBs();", "-\t\tif (source.transparentPixel != -1) {", "-\t\t\t/*", "-\t\t\t * The source had transparency, so we can use the transparent pixel", "-\t\t\t * for black.", "-\t\t\t */", "-\t\t\tRGB[] newRGBs = new RGB[rgbs.length];", "-\t\t\tSystem.arraycopy(rgbs, 0, newRGBs, 0, rgbs.length);", "-\t\t\tif (source.transparentPixel >= newRGBs.length) {", "-\t\t\t\t/* Grow the palette with black */", "-\t\t\t\trgbs = new RGB[source.transparentPixel + 1];", "-\t\t\t\tSystem.arraycopy(newRGBs, 0, rgbs, 0, newRGBs.length);", "-\t\t\t\tfor (int i = newRGBs.length; i <= source.transparentPixel; i++) {", "-\t\t\t\t\trgbs[i] = new RGB(0, 0, 0);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tnewRGBs[source.transparentPixel] = black;", "-\t\t\t\trgbs = newRGBs;", "-\t\t\t}", "-\t\t\tblackIndex = source.transparentPixel;", "-\t\t\timage = new ImageData(source.width, source.height, source.depth, new PaletteData(rgbs));", "-\t\t} else {", "-\t\t\twhile (blackIndex < rgbs.length) {", "-\t\t\t\tif (rgbs[blackIndex].equals(black)) break;", "-\t\t\t\tblackIndex++;", "-\t\t\t}", "-\t\t\tif (blackIndex == rgbs.length) {", "-\t\t\t\t/*", "-\t\t\t\t * We didn't find black in the palette, and there is no transparent", "-\t\t\t\t * pixel we can use.", "-\t\t\t\t */", "-\t\t\t\tif ((1 << source.depth) > rgbs.length) {", "-\t\t\t\t\t/* We can grow the palette and add black */", "-\t\t\t\t\tRGB[] newRGBs = new RGB[rgbs.length + 1];", "-\t\t\t\t\tSystem.arraycopy(rgbs, 0, newRGBs, 0, rgbs.length);", "-\t\t\t\t\tnewRGBs[rgbs.length] = black;", "-\t\t\t\t\trgbs = newRGBs;", "-\t\t\t\t} else {", "-\t\t\t\t\t/* No room to grow the palette */", "-\t\t\t\t\tblackIndex = -1;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\timage = new ImageData(source.width, source.height, source.depth, new PaletteData(rgbs));", "-\t\t}", "-\t}", "-\tif (blackIndex == -1) {", "-\t\t/* There was no black in the palette, so just copy the data over */", "-\t\tSystem.arraycopy(source.data, 0, image.data, 0, image.data.length);", "-\t} else {", "-\t\t/* Modify the source image to contain black wherever the mask is 0 */", "-\t\tint[] imagePixels = new int[image.width];", "-\t\tint[] maskPixels = new int[mask.width];", "-\t\tfor (int y = 0; y < image.height; y++) {", "-\t\t\tsource.getPixels(0, y, image.width, imagePixels, 0);", "-\t\t\tmask.getPixels(0, y, mask.width, maskPixels, 0);", "-\t\t\tfor (int i = 0; i < imagePixels.length; i++) {", "-\t\t\t\tif (maskPixels[i] == 0) imagePixels[i] = blackIndex;", "-\t\t\t}", "-\t\t\timage.setPixels(0, y, source.width, imagePixels, 0);", "-\t\t}", "-\t}", "-\t/*", "-\t * Make sure the mask is padded properly. Windows requires icon masks", "-\t * to have a scanline pad of 2.", "-\t */", "-\tint bytesPerLine = (((mask.width + 7) / 8) + 1) / 2 * 2;", "-\tbyte[] newMaskData = new byte[bytesPerLine * mask.height];", "-\tImageData newMask = new ImageData(mask.width, mask.height, 1, mask.palette, 2, newMaskData);", "-\tint[] maskPixels = new int[mask.width];", "-\tfor (int y = 0; y < mask.height; y++) {", "-\t\tmask.getPixels(0, y, mask.width, maskPixels, 0);", "-\t\tnewMask.setPixels(0, y, newMask.width, maskPixels, 0);", "-\t}", "-\t/* Set the fields and create the icon */", "-\timage.maskPad = newMask.scanlinePad;", "-\timage.maskData = newMask.data;", "-\tinit(device, image);", "+\tinit(device, this, source, mask);"]}], "num": 616}