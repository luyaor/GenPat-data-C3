{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d082a59b1f05882a234a7ea64e29fb22", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3f065a7158bf4198fc32a6d4a776b7d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/TabFolder.java", "commitBeforeChange": "ab3a0e2212badb4230b4950583046c2765ca9b1b", "commitAfterChange": "7a333f8cd621c7ce81ccebdf86504138fdd1f158", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r \r public Point computeSize (int wHint, int hHint, boolean changed)", "signatureAfterChange": "\r \r public Point computeSize (int wHint, int hHint, boolean changed)", "diff": ["-//\tint width = OS.GTK_WIDGET_WIDTH (fixedHandle);\r", "-//\tint height = OS.GTK_WIDGET_HEIGHT (fixedHandle);\r", "-//\tOS.gtk_widget_set_size_request (handle, wHint, hHint);\r", "-//\tGtkRequisition requisition = new GtkRequisition ();\r", "-//\tOS.gtk_widget_size_request (handle, requisition);\r", "-//\tOS.gtk_widget_set_size_request (handle, width, height);\r", "-//\twidth = wHint == SWT.DEFAULT ? requisition.width : wHint;\r", "-//\theight = hHint == SWT.DEFAULT ? requisition.height : hHint;\r", "-//\tPoint size;\r", "-//\tif (layout != null) {\r", "-//\t\tsize = layout.computeSize (this, wHint, hHint, changed);\r", "-//\t} else {\r", "-//\t\tsize = minimumSize ();\r", "-//\t}\r", "-//\tif (size.x == 0) size.x = DEFAULT_WIDTH;\r", "-//\tif (size.y == 0) size.y = DEFAULT_HEIGHT;\r", "-//\tif (wHint != SWT.DEFAULT) size.x = wHint;\r", "-//\tif (hHint != SWT.DEFAULT) size.y = hHint;\r", "-//\twidth = Math.max (width, size.x);\r", "-//\theight = Math.max (height, size.y);\r", "-////\tRectangle trim = computeTrim (0, 0, width, height);\r", "-////\twidth = trim.width;  height = trim.height;\r", "-//\treturn new Point (width, height);\r", "-\treturn new Point (300, 300);\r", "+\tint width = OS.GTK_WIDGET_WIDTH (fixedHandle);\r", "+\tint height = OS.GTK_WIDGET_HEIGHT (fixedHandle);\r", "+\tOS.gtk_widget_set_size_request (handle, wHint, hHint);\r", "+\tGtkRequisition requisition = new GtkRequisition ();\r", "+\tboolean scrollable = OS.gtk_notebook_get_scrollable (handle);\r", "+\tOS.gtk_notebook_set_scrollable (handle, false);\r", "+\tOS.gtk_widget_size_request (handle, requisition);\r", "+\tOS.gtk_notebook_set_scrollable (handle, scrollable);\r", "+\tOS.gtk_widget_set_size_request (handle, width, height);\r", "+\twidth = wHint == SWT.DEFAULT ? requisition.width : wHint;\r", "+\theight = hHint == SWT.DEFAULT ? requisition.height : hHint;\r", "+\tPoint size;\r", "+\tif (layout != null) {\r", "+\t\tsize = layout.computeSize (this, wHint, hHint, changed);\r", "+\t} else {\r", "+\t\tsize = minimumSize ();\r", "+\t}\r", "+\tif (size.x == 0) size.x = DEFAULT_WIDTH;\r", "+\tif (size.y == 0) size.y = DEFAULT_HEIGHT;\r", "+\tif (wHint != SWT.DEFAULT) size.x = wHint;\r", "+\tif (hHint != SWT.DEFAULT) size.y = hHint;\r", "+\twidth = Math.max (width, size.x);\r", "+\theight = Math.max (height, size.y);\r", "+\treturn new Point (width, height);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "69112dcdbe3b5a4a610339945bb0d1c3", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/DateTime.java", "commitBeforeChange": "2187afd862fdea9fa726467ee2a9f03d0bb090e9", "commitAfterChange": "0866604db67e7f00aae199d153bb1013a37b107f", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  public Point computeSize (int wHint, int hHint, boolean changed)", "signatureAfterChange": "  public Point computeSize (int wHint, int hHint, boolean changed)", "diff": ["-\tint width = 64, height = 64;", "-\tif ((style & SWT.CALENDAR) != 0) {", "-\t\tRECT rect = new RECT ();", "-\t\tOS.SendMessage(handle, OS.MCM_GETMINREQRECT, 0, rect);", "-\t\twidth = rect.right;", "-\t\theight = rect.bottom;", "+\tint width = 0, height = 0;", "+\tif (wHint == SWT.DEFAULT || hHint == SWT.DEFAULT) {", "+\t\tif ((style & SWT.CALENDAR) != 0) {", "+\t\t\tRECT rect = new RECT ();", "+\t\t\tOS.SendMessage(handle, OS.MCM_GETMINREQRECT, 0, rect);", "+\t\t\twidth = rect.right;", "+\t\t\theight = rect.bottom;", "+\t\t} else {", "+\t\t\tint newFont, oldFont = 0;", "+\t\t\tint hDC = OS.GetDC (handle);", "+\t\t\tnewFont = OS.SendMessage (handle, OS.WM_GETFONT, 0, 0);", "+\t\t\tif (newFont != 0) oldFont = OS.SelectObject (hDC, newFont);", "+\t\t\tTEXTMETRIC tm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW () : new TEXTMETRICA ();", "+\t\t\tOS.GetTextMetrics (hDC, tm);", "+\t\t\theight = tm.tmHeight;", "+\t\t\tint upDownHeight = OS.GetSystemMetrics (OS.SM_CYVSCROLL);", "+\t\t\theight = Math.max (height, upDownHeight);", "+\t\t\tString string = \"00/00/0000\";", "+\t\t\tif ((style & SWT.TIME) != 0) string = \"00:00:00 PM\";", "+\t\t\tRECT rect = new RECT ();", "+\t\t\tTCHAR buffer = new TCHAR (getCodePage (), string, false);", "+\t\t\tint flags = OS.DT_CALCRECT | OS.DT_EDITCONTROL | OS.DT_NOPREFIX;", "+\t\t\tOS.DrawText (hDC, buffer, buffer.length (), rect, flags);", "+\t\t\twidth = rect.right - rect.left;", "+\t\t\tif (newFont != 0) OS.SelectObject (hDC, oldFont);", "+\t\t\tOS.ReleaseDC (handle, hDC);", "+\t\t\tint upDownWidth = OS.GetSystemMetrics (OS.SM_CXVSCROLL);", "+\t\t\twidth += upDownWidth + MARGIN;", "+\t\t\t// TODO: On Vista, can send DTM_GETDATETIMEPICKERINFO to ask the Edit control what its margins are", "+\t\t}", "+\tif (width == 0) width = DEFAULT_WIDTH;", "+\tif (height == 0) height = DEFAULT_HEIGHT;", "+\tif (wHint != SWT.DEFAULT) width = wHint;", "+\tif (hHint != SWT.DEFAULT) height = hHint;", "+\tint border = getBorderWidth ();", "+\twidth += border * 2; height += border * 2;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9a64da055075c204298be69099811af6", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "65777ce3d2a96099cf20830ff9a4bd6c4c860e8f", "commitAfterChange": "ba852d737724ee92cb82b3435acad91de5d9d6c7", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 63, "signatureBeforeChange": " void shape (final int hdc, final StyleItem run)", "signatureAfterChange": " void shape (final int hdc, final StyleItem run)", "diff": ["-\tif (run.style != null && run.style.metrics != null) {", "-\t\tGlyphMetrics metrics = run.style.metrics;", "-\t\t/*", "-\t\t*  Bug in Windows, on a Japanese machine, Uniscribe returns glyphcount", "-\t\t*  equals zero for FFFC (possibly other unicode code points), the fix", "-\t\t*  is to make sure the glyph is at least one pixel wide.", "-\t\t*/", "-\t\trun.width = metrics.width * Math.max (1, run.glyphCount);", "-\t\trun.ascent = metrics.ascent;", "-\t\trun.descent = metrics.descent;", "-\t\trun.leading = 0;", "+\trun.width = abc[0] + abc[1] + abc[2];", "+\tTextStyle style = run.style;", "+\tif (style != null) {", "+\t\tOUTLINETEXTMETRIC lotm = null;", "+\t\tif (style.underline || style.strikeout) {", "+\t\t\tlotm = OS.IsUnicode ? (OUTLINETEXTMETRIC)new OUTLINETEXTMETRICW() : new OUTLINETEXTMETRICA();", "+\t\t\tif (OS.GetOutlineTextMetrics(hdc, OUTLINETEXTMETRIC.sizeof, lotm) == 0) {", "+\t\t\t\tlotm = null;", "+\t\t\t}", "+\t\t}", "+\t\tif (style.metrics != null) {", "+\t\t\tGlyphMetrics metrics = style.metrics;", "+\t\t\t/*", "+\t\t\t *  Bug in Windows, on a Japanese machine, Uniscribe returns glyphcount", "+\t\t\t *  equals zero for FFFC (possibly other unicode code points), the fix", "+\t\t\t *  is to make sure the glyph is at least one pixel wide.", "+\t\t\t */", "+\t\t\trun.width = metrics.width * Math.max (1, run.glyphCount);", "+\t\t\trun.ascent = metrics.ascent;", "+\t\t\trun.descent = metrics.descent;", "+\t\t\trun.leading = 0;", "+\t\t} else {", "+\t\t\tTEXTMETRIC lptm = null;", "+\t\t\tif (lotm != null) {", "+\t\t\t\tlptm = OS.IsUnicode ? (TEXTMETRIC)((OUTLINETEXTMETRICW)lotm).otmTextMetrics : ((OUTLINETEXTMETRICA)lotm).otmTextMetrics;", "+\t\t\t} else {", "+\t\t\t\tlptm = OS.IsUnicode ? (TEXTMETRIC)new TEXTMETRICW() : new TEXTMETRICA();", "+\t\t\t\tOS.GetTextMetrics(hdc, lptm);", "+\t\t\t}", "+\t\t\trun.ascent = lptm.tmAscent;", "+\t\t\trun.descent = lptm.tmDescent;", "+\t\t\trun.leading = lptm.tmInternalLeading;", "+\t\t}", "+\t\tif (lotm != null) {", "+\t\t\trun.underlinePos = lotm.otmsUnderscorePosition;", "+\t\t\trun.underlineThickness = lotm.otmsUnderscoreSize;", "+\t\t\trun.strikeoutPos = lotm.otmsStrikeoutPosition;", "+\t\t\trun.strikeoutThickness = lotm.otmsStrikeoutSize;", "+\t\t} else {", "+\t\t\trun.underlinePos = 1;", "+\t\t\trun.underlineThickness = 1;", "+\t\t\trun.strikeoutPos = run.ascent / 2;", "+\t\t\trun.strikeoutThickness = 1;", "+\t\t}", "+\t\trun.ascent += style.rise;", "+\t\trun.descent -= style.rise;", "-\t\trun.width = abc[0] + abc[1] + abc[2];", "-\t}", "-\tif (run.style != null) {", "-\t\trun.ascent += run.style.rise;", "-\t\trun.descent -= +run.style.rise;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "89217583929eaaed14e6ccf89c8b22ba", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "a32fc984c81b11a72a38e2cc99f6583aa55cdbed", "commitAfterChange": "700ce01c41ba7df0747885e4f453df4156f4e515", "methodNumberBeforeChange": 78, "methodNumberAfterChange": 78, "signatureBeforeChange": " void shape (final int hdc, final StyleItem run)", "signatureAfterChange": " void shape (final int hdc, final StyleItem run)", "diff": ["+\tif (run.glyphs != 0) return;", "-\t\tint /*long*/ ssa = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, OS.SCRIPT_STRING_ANALYSIS_sizeof());", "-\t\tint /*long*/ metaFileDc = OS.CreateEnhMetaFile(hdc, null, null, null);", "-\t\tint /*long*/ oldMetaFont = OS.SelectObject(metaFileDc, hFont);", "-\t\tint flags = OS.SSA_METAFILE | OS.SSA_FALLBACK | OS.SSA_GLYPHS | OS.SSA_LINK;", "+\t\tint /*long*/ newFont = 0;", "-\t\tif (OS.ScriptStringAnalyse(metaFileDc, sampleChars, count, 0, -1, flags, 0, null, null, 0, 0, 0, ssa) == OS.S_OK) {", "-\t\t\tOS.ScriptStringOut(ssa, 0, 0, 0, null, 0, 0, false);", "-\t\t\tOS.ScriptStringFree(ssa);", "-\t\t}", "-\t\tOS.HeapFree(hHeap, 0, ssa);", "-\t\tOS.SelectObject(metaFileDc, oldMetaFont);", "-\t\tint /*long*/ metaFile = OS.CloseEnhMetaFile(metaFileDc);", "-\t\tfinal EMREXTCREATEFONTINDIRECTW emr = new EMREXTCREATEFONTINDIRECTW();", "-\t\tclass MetaFileEnumProc {", "-\t\t\tint /*long*/ metaFileEnumProc (int /*long*/ hDC, int /*long*/ table, int /*long*/ record, int /*long*/ nObj, int /*long*/ lpData) {", "-\t\t\t\tOS.MoveMemory(emr.emr, record, EMR.sizeof);", "-\t\t\t\tswitch (emr.emr.iType) {", "-\t\t\t\t\tcase OS.EMR_EXTCREATEFONTINDIRECTW:", "-\t\t\t\t\t\tOS.MoveMemory(emr, record, EMREXTCREATEFONTINDIRECTW.sizeof);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase OS.EMR_EXTTEXTOUTW:", "-\t\t\t\t\t\treturn 0;", "-\t\t\t\t}", "-\t\t\t\treturn 1;", "+\t\tif (count > 0) {", "+\t\t\tint /*long*/ ssa = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, OS.SCRIPT_STRING_ANALYSIS_sizeof());", "+\t\t\tint /*long*/ metaFileDc = OS.CreateEnhMetaFile(hdc, null, null, null);", "+\t\t\tint /*long*/ oldMetaFont = OS.SelectObject(metaFileDc, hFont);", "+\t\t\tint flags = OS.SSA_METAFILE | OS.SSA_FALLBACK | OS.SSA_GLYPHS | OS.SSA_LINK;", "+\t\t\tif (OS.ScriptStringAnalyse(metaFileDc, sampleChars, count, 0, -1, flags, 0, null, null, 0, 0, 0, ssa) == OS.S_OK) {", "+\t\t\t\tOS.ScriptStringOut(ssa, 0, 0, 0, null, 0, 0, false);", "+\t\t\t\tOS.ScriptStringFree(ssa);", "-\t\t};", "-\t\tMetaFileEnumProc object = new MetaFileEnumProc();", "-\t\t/* Avoid compiler warnings */", "-\t\tboolean compilerWarningWorkaround = false;", "-\t\tif (compilerWarningWorkaround) object.metaFileEnumProc(0, 0, 0, 0, 0);", "-\t\tCallback callback = new Callback(object, \"metaFileEnumProc\", 5);", "-\t\tint /*long*/ address = callback.getAddress();", "-\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "-\t\tOS.EnumEnhMetaFile(0, metaFile, address, 0, null);", "-\t\tOS.DeleteEnhMetaFile(metaFile);", "-\t\tcallback.dispose();", "-", "-\t\tint /*long*/ newFont = OS.CreateFontIndirectW(emr.elfw.elfLogFont);", "-\t\tOS.SelectObject(hdc, newFont);", "-\t\tif (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {", "-\t\t\trun.fallbackFont = newFont;", "+\t\t\tOS.HeapFree(hHeap, 0, ssa);", "+\t\t\tOS.SelectObject(metaFileDc, oldMetaFont);", "+\t\t\tint /*long*/ metaFile = OS.CloseEnhMetaFile(metaFileDc);", "+\t\t\tfinal EMREXTCREATEFONTINDIRECTW emr = new EMREXTCREATEFONTINDIRECTW();", "+\t\t\tclass MetaFileEnumProc {", "+\t\t\t\tint /*long*/ metaFileEnumProc (int /*long*/ hDC, int /*long*/ table, int /*long*/ record, int /*long*/ nObj, int /*long*/ lpData) {", "+\t\t\t\t\tOS.MoveMemory(emr.emr, record, EMR.sizeof);", "+\t\t\t\t\tswitch (emr.emr.iType) {", "+\t\t\t\t\t\tcase OS.EMR_EXTCREATEFONTINDIRECTW:", "+\t\t\t\t\t\t\tOS.MoveMemory(emr, record, EMREXTCREATEFONTINDIRECTW.sizeof);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase OS.EMR_EXTTEXTOUTW:", "+\t\t\t\t\t\t\treturn 0;", "+\t\t\t\t\t}", "+\t\t\t\t\treturn 1;", "+\t\t\t\t}", "+\t\t\t};", "+\t\t\tMetaFileEnumProc object = new MetaFileEnumProc();", "+\t\t\t/* Avoid compiler warnings */", "+\t\t\tboolean compilerWarningWorkaround = false;", "+\t\t\tif (compilerWarningWorkaround) object.metaFileEnumProc(0, 0, 0, 0, 0);", "+\t\t\tCallback callback = new Callback(object, \"metaFileEnumProc\", 5);", "+\t\t\tint /*long*/ address = callback.getAddress();", "+\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "+\t\t\tOS.EnumEnhMetaFile(0, metaFile, address, 0, null);", "+\t\t\tOS.DeleteEnhMetaFile(metaFile);", "+\t\t\tcallback.dispose();", "+\t\t\tnewFont = OS.CreateFontIndirectW(emr.elfw.elfLogFont);", "+\t\t} else {", "+\t\t\t/*", "+\t\t\t* The run is composed only by white spaces, this happens when a run is split", "+\t\t\t* by a visual style. The font fallback for the script can not be determined", "+\t\t\t* using only white spaces. The solution is to use the font fallback of the ", "+\t\t\t* previous or next run of the same script.    ", "+\t\t\t*/", "+\t\t\tint index = 0;", "+\t\t\twhile (index < allRuns.length - 1) {", "+\t\t\t\tif (allRuns[index] == run) {", "+\t\t\t\t\tif (index > 0) {", "+\t\t\t\t\t\tStyleItem pRun = allRuns[index - 1];", "+\t\t\t\t\t\tif (pRun.fallbackFont != 0 && pRun.analysis.eScript == run.analysis.eScript) {", "+\t\t\t\t\t\t\tLOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW() : new LOGFONTA();", "+\t\t\t\t\t\t\tOS.GetObject(pRun.fallbackFont, LOGFONT.sizeof, logFont);", "+\t\t\t\t\t\t\tnewFont = OS.CreateFontIndirect(logFont);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (newFont == 0) {", "+\t\t\t\t\t\tif (index + 1 < allRuns.length - 1) {", "+\t\t\t\t\t\t\tStyleItem nRun = allRuns[index + 1];", "+\t\t\t\t\t\t\tif (nRun.analysis.eScript == run.analysis.eScript) {", "+\t\t\t\t\t\t\t\tshape(hdc, nRun);", "+\t\t\t\t\t\t\t\tif (nRun.fallbackFont != 0) {", "+\t\t\t\t\t\t\t\t\tLOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW() : new LOGFONTA();", "+\t\t\t\t\t\t\t\t\tOS.GetObject(nRun.fallbackFont, LOGFONT.sizeof, logFont);", "+\t\t\t\t\t\t\t\t\tnewFont = OS.CreateFontIndirect(logFont);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tindex++;", "+\t\t\t}", "+\t\t}", "+\t\tif (newFont != 0) {", "+\t\t\tOS.SelectObject(hdc, newFont);", "+\t\t\tif (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {", "+\t\t\t\trun.fallbackFont = newFont;", "+\t\t\t}", "-\t\tif (newFont != run.fallbackFont) OS.DeleteObject(newFont);", "+\t\tif (newFont != 0 && newFont != run.fallbackFont) OS.DeleteObject(newFont);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "19c16d4561adfaf8485e1c6c29defd88", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "10946719389470f65e13f1be11fcaf6eb8e0708e", "commitAfterChange": "e42c019f2a285ee0693f813be28788620d9b1560", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": " void shape (final int hdc, final StyleItem run)", "signatureAfterChange": " void shape (final int hdc, final StyleItem run)", "diff": ["-\t", "-\t/*", "-\t* Feature in Uniscribe, the U+FEFF is not supported by", "-\t* some fonts in the system causing the remaining chars in", "-\t* the run not to draw, even though the font supports them.", "-\t* The fix is to replace U+FEFF by U+200B (ZERO-WIDTH SPACE).   ", "-\t*/", "-\tfor (int i = 0; i < chars.length; i++) {", "-\t\tif (chars[i] == '\\uFEFF') chars[i] = '\\u200B';", "-\t}", "-", "-\t\t/* ", "-\t\t * Shape failed.", "-\t\t * Try to shape with fNoGlyphIndex when the run is in the ", "-\t\t * Private Use Area. This allows for end-user-defined character (EUDC).", "-\t\t */", "-\t\tif (sp.fPrivateUseArea) {", "+\t\tboolean useGDI = !sp.fComplex;", "+\t\t/*", "+\t\t* Bug in Windows.  There are non-complex scripts that are", "+\t\t* not supported by GDI. The fix is to detect these scripts", "+\t\t* by checking the Unicode ranges and use Uniscribe instead.", "+\t\t*   ", "+\t\t* These are the scripts: ", "+\t\t* \t0x0530..0x058F is Armenian", "+\t\t*   0x10A0..0x10FF is Georgian", "+\t\t*   0xA000..0xA4CF is Yi", "+\t\t*/", "+\t\tchar c = chars[0];", "+\t\tif (0x0530 <= c && c <= 0x058F || 0x10A0 <= c && c <= 0x10FF || 0xA000 <= c && c <= 0xA4CF) {", "+\t\t\tuseGDI = false;", "+\t\t}", "+\t\tif (useGDI) {", "+\t\t\tint /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "+\t\t\tLOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "+\t\t\tLOGFONT systemLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\tOS.GetObject(device.systemFont.handle, LOGFONT.sizeof, systemLogFont);", "+\t\t\tsystemLogFont.lfHeight = logFont.lfHeight;", "+\t\t\tsystemLogFont.lfWeight = logFont.lfWeight;", "+\t\t\tsystemLogFont.lfItalic = logFont.lfItalic;", "+\t\t\tsystemLogFont.lfWidth = logFont.lfWidth;", "+\t\t\tint /*long*/ newFont = OS.CreateFontIndirect (systemLogFont);", "+\t\t\tOS.SelectObject(hdc, newFont);", "+\t\t\tif (shapeSucceed) {", "+\t\t\t\trun.fallbackFont = newFont;", "+\t\t\t} else {", "+\t\t\t\tOS.SelectObject(hdc, hFont);", "+\t\t\t\tOS.DeleteObject(newFont);", "+\t\t\t\trun.analysis.fNoGlyphIndex = false;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0477439d6ee6772297330e44da473312", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "3518dcf86c71885a55fc8e7584e113022fefcef3", "commitAfterChange": "0828fa148f6ab10bffd0dad7cb0381fa25623a9b", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 43, "signatureBeforeChange": "  boolean dragDetect (int x, int y, boolean filter, boolean [] consume)", "signatureAfterChange": "  boolean dragDetect (int x, int y, boolean filter, boolean [] consume)", "diff": ["+\t/**", "+\t * Feature in Cocoa. Mouse drag events do not account for hysteresis.", "+\t * As soon as the mouse drags a mouse dragged event is fired.  Fix is to", "+\t * check for another mouse drag event that is at least 5 pixels away ", "+\t * from the start of the drag. ", "+\t */", "-\tNSEvent event = application.nextEventMatchingMask(OS.NSLeftMouseDraggedMask, NSDate.dateWithTimeIntervalSinceNow(0.2), OS.NSDefaultRunLoopMode, false);", "-\treturn (event != null);", "+\tboolean dragging = false;", "+\tint /*long*/ eventType = OS.NSLeftMouseDown;", "+\tfloat /*double*/ dragX = x;", "+\tfloat /*double*/ dragY = y;", "+\t", "+\t/**", "+\t * To check for an actual drag we need to pull off mouse moved and mouse up events", "+\t * to detect if the user dragged outside of a 10 x 10 box centered on the mouse down location.", "+\t * We still want the view to see the events, so save them and re-post when done checking.", "+\t */", "+\tNSEvent mouseUpEvent = null;", "+\tNSMutableArray dragEvents = NSMutableArray.arrayWithCapacity(10);", "+", "+\twhile (eventType != OS.NSLeftMouseUp) {", "+\t\tNSEvent event = application.nextEventMatchingMask((OS.NSLeftMouseUpMask | OS.NSLeftMouseDraggedMask),", "+\t\t\t\tNSDate.distantFuture(), OS.NSEventTrackingRunLoopMode, true);", "+\t\teventType = event.type();", "+\t\t", "+\t\tif (eventType == OS.NSLeftMouseDragged) {", "+\t\t\tdragEvents.addObject(event);", "+\t\t\tNSPoint windowLoc = event.locationInWindow();", "+\t\t\tNSPoint viewLoc = view.convertPoint_fromView_(windowLoc, null);", "+\t\t\tif ((Math.abs(viewLoc.x - dragX) > DEFAULT_DRAG_HYSTERESIS) || (Math.abs(viewLoc.y - dragY) > DEFAULT_DRAG_HYSTERESIS)) {", "+\t\t\t\tdragging = true;", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t} else if (eventType == OS.NSLeftMouseUp) {", "+\t\t\tmouseUpEvent = event;", "+\t\t}", "+\t}", "+", "+\t// Push back any events we took out of the queue so the control can receive them. ", "+\tif (mouseUpEvent != null) application.postEvent(mouseUpEvent, true);", "+", "+\tif (dragEvents.count() > 0) {", "+\t\twhile (dragEvents.count() > 0) {", "+\t\t\tNSEvent currEvent = new NSEvent(dragEvents.objectAtIndex(dragEvents.count() - 1).id);", "+\t\t\tdragEvents.removeLastObject();", "+\t\t\tapplication.postEvent(currEvent, true);", "+\t\t}", "+\t}", "+", "+\treturn dragging;"]}], "num": 35268}