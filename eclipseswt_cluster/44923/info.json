{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "643dc8df9adaac354546f4eb77abe273", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a15d5f1fb8a703ac120a5cbd7f7ae80f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "f7e5b6517c8145c41edb4cee11eaf48a485d125a", "commitAfterChange": "9cbd0cd7c02cc05e4296cf317d9160ca8585a1f1", "methodNumberBeforeChange": 78, "methodNumberAfterChange": 78, "signatureBeforeChange": "  void initGdip()", "signatureAfterChange": "  void initGdip()", "diff": ["-\tif (gdipGraphics != 0) return ;", "+\tif (gdipGraphics != 0) return;", "+", "+\t/*", "+\t* Bug in GDI+.  GDI+ does not work when the HDC layout is RTL.  There", "+\t* are many issues like pixel corruption, but the most visible problem", "+\t* is that it does not have an effect when drawing to an bitmap.  The", "+\t* fix is to clear the bit before creating the GDI+ graphics and install", "+\t* a mirroring matrix ourselfs.", "+\t*/", "+\tif ((data.style & SWT.MIRRORED) != 0) {", "+\t\tOS.SetLayout(handle, OS.GetLayout(handle) & ~OS.LAYOUT_RTL);", "+\t}", "+", "+\tif ((data.style & SWT.MIRRORED) != 0) {", "+\t\tint matrix = identity();", "+\t\tGdip.Graphics_SetTransform(gdipGraphics, matrix);", "+\t\tGdip.Matrix_delete(matrix);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f300f368f7837e88683834684cc078f4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "1054da589c4ce7da01e9eb9d8e4e75bf9b62a2db", "commitAfterChange": "6b71999963d0165be5a5c1e361d6a8dce42a829d", "methodNumberBeforeChange": 73, "methodNumberAfterChange": 73, "signatureBeforeChange": "  void initGdip(boolean draw, boolean fill)", "signatureAfterChange": "  void initGdip(boolean draw, boolean fill)", "diff": ["-\tif (gdipGraphics == 0) gdipGraphics = data.gdipGraphics = Gdip.Graphics_new(handle);", "+\tif (gdipGraphics == 0) {", "+\t\t/*", "+\t\t* Feature in GDI+. The GDI+ clipping set with Graphics->SetClip()", "+\t\t* is always intersected with the GDI clipping at the time the", "+\t\t* GDI+ graphics is created.  This means that the clipping ", "+\t\t* cannot be reset.  The fix is to clear the clipping before", "+\t\t* the GDI+ graphics is created and reset it afterwards.", "+\t\t*/", "+\t\tint hRgn = OS.CreateRectRgn(0, 0, 0, 0);", "+\t\tint result = OS.GetClipRgn(handle, hRgn);", "+\t\tOS.SelectClipRgn(handle, 0);", "+\t\tgdipGraphics = data.gdipGraphics = Gdip.Graphics_new(handle);", "+\t\tif (result == 1) setClipping(hRgn);", "+\t\tOS.DeleteObject(hRgn);", "+\t}"]}], "num": 44923}