{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "33aa84490e9f6ddb63b1bff049090591", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f95765303bae0dae225e61e02a661d97", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "dabb371250244a42d0a102e16d31217d0a0ef72f", "commitAfterChange": "ce13f951d0206a463a1d2938b51a330c2557de6c", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-\t/* Calculate the palette depending on the display attributes */\r", "-\tPaletteData palette = null;\r", "-\t/* Get the data for the source image. */\r", "+\t/* Get the data and palette of the source image. */\r", "+\tPaletteData palette = null;\r", "-\tswitch (xSrcImage.depth) {\r", "+\tswitch (xSrcImage.bits_per_pixel) {\r", "-\t\t\t/**\r", "-\t\t\t * We currently don't run on a 4-bit server, so 4-bit images\r", "-\t\t\t * should not exist.\r", "-\t\t\t */\r", "+\t\t\t/*\r", "+\t\t\t* We currently don't run on a 4-bit server, so 4-bit images\r", "+\t\t\t* should not exist.\r", "+\t\t\t*/\r", "-\t\t\t * pixel values sequential starting at pixel 0). Reserve normalized \r", "-\t\t\t * pixel 0 so that it maps to real pixel 0. This assumes pixel 0 is \r", "-\t\t\t * always used in the image.\r", "-\t\t\t */\r", "-\t\t\tbyte[] normPixel = new byte[ 256 ];\r", "+\t\t\t* pixel values sequential starting at pixel 0). Reserve normalized \r", "+\t\t\t* pixel 0 so that it maps to real pixel 0. This assumes pixel 0 is \r", "+\t\t\t* always used in the image.\r", "+\t\t\t*/\r", "+\t\t\tbyte[] normPixel = new byte[256];\r", "-\t\t\t\tnormPixel[ index ] = 0;\r", "+\t\t\t\tnormPixel[index] = 0;\r", "-\t\t\t\t\tint srcPixel = srcData[ index + x ] & 0xFF;\r", "-\t\t\t\t\tif (srcPixel != 0 && normPixel[ srcPixel ] == 0) {\r", "-\t\t\t\t\t\tnormPixel[ srcPixel ] = (byte)numPixels++;\r", "+\t\t\t\t\tint srcPixel = srcData[index + x] & 0xFF;\r", "+\t\t\t\t\tif (srcPixel != 0 && normPixel[srcPixel] == 0) {\r", "+\t\t\t\t\t\tnormPixel[srcPixel] = (byte)numPixels++;\r", "-\t\t\t\t\tsrcData[ index + x ] = normPixel[ srcPixel ];\r", "+\t\t\t\t\tsrcData[index + x] = normPixel[srcPixel];\r", "-\t\t\tRGB[] rgbs = new RGB[ numPixels ];\r", "+\t\t\tRGB[] rgbs = new RGB[numPixels];\r", "-\t\t\t\t// If the pixel value was used in the image, get its RGB values.\r", "-\t\t\t\tif (srcPixel == 0 || normPixel[ srcPixel ] != 0) {\r", "+\t\t\t\t/* If the pixel value was used in the image, get its RGB values. */\r", "+\t\t\t\tif (srcPixel == 0 || normPixel[srcPixel] != 0) {\r", "-\t\t\t\t\tint rgbIndex = normPixel[ srcPixel ] & 0xFF;\r", "-\t\t\t\t\trgbs[ rgbIndex ] = new RGB((color.red >> 8) & 0xFF, (color.green >> 8) & 0xFF, (color.blue >> 8) & 0xFF);\r", "+\t\t\t\t\tint rgbIndex = normPixel[srcPixel] & 0xFF;\r", "+\t\t\t\t\trgbs[rgbIndex] = new RGB((color.red >> 8) & 0xFF, (color.green >> 8) & 0xFF, (color.blue >> 8) & 0xFF);\r", "-\t\t\t/**\r", "-\t\t\t * For some reason, the XImage does not have the mask information.\r", "-\t\t\t * We must get it from the visual.\r", "-\t\t\t */\r", "-\t\t\tint visual = OS.XDefaultVisual(xDisplay, OS.XDefaultScreen(xDisplay));\r", "-\t\t\tVisual v = new Visual();\r", "-\t\t\tOS.memmove(v, visual, Visual.sizeof);\r", "-\t\t\tpalette = new PaletteData(v.red_mask, v.green_mask, v.blue_mask);\r", "+\t\t\t/* Byte swap the data if necessary */\r", "+\t\t\tif (xSrcImage.byte_order == OS.MSBFirst) {\r", "+\t\t\t\tfor (int i = 0; i < srcData.length; i += 2) {\r", "+\t\t\t\t\tbyte b = srcData[i];\r", "+\t\t\t\t\tsrcData[i] = srcData[i+1];\r", "+\t\t\t\t\tsrcData[i+1] = b;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "-\t\t\t/* We always create 24-bit ImageData with the following palette */\r", "-\t\t\tpalette = new PaletteData(0xFF, 0xFF00, 0xFF0000);\r", "+\t\t\tbreak;\r", "+\t\tcase 32:\r", "+\t\t\t/* Byte swap the data if necessary */\r", "+\t\t\tif (xSrcImage.byte_order == OS.LSBFirst) {\r", "+\t\t\t\tfor (int i = 0; i < srcData.length; i += 4) {\r", "+\t\t\t\t\tbyte b = srcData[i];\r", "+\t\t\t\t\tsrcData[i] = srcData[i+3];\r", "+\t\t\t\t\tsrcData[i+3] = b;\r", "+\t\t\t\t\tb = srcData[i+1];\r", "+\t\t\t\t\tsrcData[i+1] = srcData[i+2];\r", "+\t\t\t\t\tsrcData[i+2] = b;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "-\tImageData data = new ImageData(width, height, xSrcImage.depth, palette);\r", "+\tif (palette == null) {\r", "+\t\t/*\r", "+\t\t* For some reason, the XImage does not have the mask information.\r", "+\t\t* We must get it from the defualt visual.\r", "+\t\t*/\r", "+\t\tint visual = OS.XDefaultVisual(xDisplay, OS.XDefaultScreen(xDisplay));\r", "+\t\tVisual v = new Visual();\r", "+\t\tOS.memmove(v, visual, Visual.sizeof);\r", "+\t\tpalette = new PaletteData(v.red_mask, v.green_mask, v.blue_mask);\r", "+\t}\t\r", "+\tImageData data = new ImageData(width, height, xSrcImage.bits_per_pixel, palette);\r", "-\tif (xSrcImage.bits_per_pixel == 32) {\r", "-\t\t/**\r", "-\t\t * If bits per pixel is 32, scale the data down to 24, since we do not\r", "-\t\t * support 32-bit images\r", "-\t\t */\r", "-\t\tbyte[] oldData = data.data;\r", "-\t\tint bytesPerLine = (xSrcImage.width * xSrcImage.depth + 7) / 8;\r", "-\t\tbytesPerLine = (bytesPerLine + 3) / 4 * 4;\r", "-\t\tbyte[] newData = new byte[bytesPerLine * xSrcImage.height];\r", "-\t\tint destIndex = 0;\r", "-\t\tint srcIndex = 0;\r", "-\t\tint rOffset = 0, gOffset = 1, bOffset = 2;\r", "-\t\tif (xSrcImage.byte_order == OS.MSBFirst) {\r", "-\t\t\trOffset = 3; gOffset = 2; bOffset = 1;\r", "-\t\t}\r", "-\t\tfor (int y = 0; y < height; y++) {\r", "-\t\t\tdestIndex = y * bytesPerLine;\r", "-\t\t\tsrcIndex = y * xSrcImage.bytes_per_line;\r", "-\t\t\tfor (int x = 0; x < width; x++) {\r", "-\t\t\t\tnewData[destIndex] = oldData[srcIndex + rOffset];\r", "-\t\t\t\tnewData[destIndex + 1] = oldData[srcIndex + gOffset];\r", "-\t\t\t\tnewData[destIndex + 2] = oldData[srcIndex + bOffset];\r", "-\t\t\t\tsrcIndex += 4;\r", "-\t\t\t\tdestIndex += 3;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\tdata.data = newData;\r", "-\t}\r", "-\t\t/* Get the icon data */\r", "+\t\t/* Get the icon mask data */\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1469d52faba74843b7598edb8022a53c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "ed6471c0ec0d0ee0c1436d2bdeadc8ba513ab4fd", "commitAfterChange": "034d8fba7f4ca7576ddaeee539a2fb56ee664327", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 10, "signatureBeforeChange": " public Point computeSize(int wHint, int hHint, boolean changed)", "signatureAfterChange": " public Point computeSize (int wHint, int hHint, boolean changed)", "diff": ["+public Point computeSize (int wHint, int hHint, boolean changed) {", "+\tcheckWidget ();", "+\tint width = 0, height = 0;", "+\tif (wHint != SWT.DEFAULT) {", "+\t\twidth = wHint;", "+\t} else {", "+\t\tif (columns.length == 0) {", "+\t\t\tfor (int i = 0; i < items.length; i++) {", "+\t\t\t\tRectangle itemBounds = items [i].getBounds ();", "+\t\t\t\twidth = Math.max (width, itemBounds.x + itemBounds.width);", "+\t\t} else {", "+\t\t\tTableColumn lastColumn = columns [columns.length - 1];", "+\t\t\twidth = lastColumn.getX () + lastColumn.width;", "+\tif (hHint != SWT.DEFAULT) {", "+\t\theight = hHint;", "+\t} else {", "+\t\theight = getHeaderHeight () + items.length * itemHeight;", "+\t}", "+\tRectangle result = computeTrim (0, 0, width, height);", "+\treturn new Point (result.width, result.height);", "-}", "-public Point computeSize(int wHint, int hHint, boolean changed) {", "-\tcheckWidget();", "-\tPoint size = super.computeSize(wHint, hHint, changed);", "-\tPoint headerSize;", "-\tGC gc;", "-\tfinal int WidthCalculationCount = Math.min(getItemCount(), 50);\t\t// calculate item width for the first couple of items only", "-\tTableItem item;", "-\tImage itemImage;", "-\tString itemText;", "-\tint width;", "-\tint newItemWidth = 0;", "-\t\t", "-\tif (getHeaderVisible() == true && hHint == SWT.DEFAULT) {", "-\t\theaderSize = getHeader().computeSize(SWT.DEFAULT, SWT.DEFAULT, false);", "-\t\tsize.y += headerSize.y;\t\t", "-\t}", "-\tif (getContentWidth() == 0 && WidthCalculationCount > 0) {", "-\t\tgc = new GC(this);", "-\t\tfor (int i = 0; i < WidthCalculationCount; i++) {", "-\t\t\titem = getItem(i);", "-\t\t\tif (item == null) {", "-\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t// no more items", "-\t\t\t}", "-\t\t\titemImage = item.getImage();", "-\t\t\titemText = item.getText();", "-\t\t\twidth = 0;", "-\t\t\tif (itemImage != null) {", "-\t\t\t\twidth += itemImage.getBounds().width;", "-\t\t\t}", "-\t\t\tif (itemText != null) {", "-\t\t\t\tgc.setFont(item.getFont());", "-\t\t\t\twidth += gc.stringExtent(itemText).x;", "-\t\t\t}", "-\t\t\tnewItemWidth = Math.max(newItemWidth, width);", "-\t\t}", "-\t\tif (newItemWidth > 0) {", "-\t\t\tsize.x = newItemWidth;", "-\t\t}", "-\t\tgc.dispose();", "-\t}", "-\treturn size;", "-}"]}], "num": 10637}