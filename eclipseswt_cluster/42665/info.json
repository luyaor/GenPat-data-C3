{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6aa6197cb29e9f93f370e43d25d84e94", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b415d01a54210e7ba335c177c76b9d5f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/ImageList.java", "commitBeforeChange": "1acd89a2d1e085725362a748b0102b8318356ef1", "commitAfterChange": "600117323003db9ea522ed0baf12ee909172c3dc", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  int copyBitmap (int hImage, int width, int height)", "signatureAfterChange": "  int copyBitmap (int hImage, int width, int height)", "diff": ["-\tint hBitmap = OS.CreateCompatibleBitmap (hDC, width, height);", "+\t/*", "+\t* Feature in Windows.  If a bitmap has a 32-bit depth and any", "+\t* pixel has an alpha value different than zero, common controls", "+\t* version 6.0 assumes that the bitmap should be alpha blended.", "+\t* AlphaBlend() composes the alpha channel of a destination 32-bit", "+\t* depth image with the alpha channel of the source image. This", "+\t* may cause opaque images to draw transparently.  The fix is", "+\t* remove the alpha channel of opaque images by down sampling", "+\t* it to 24-bit depth.", "+\t*/", "+\tint hBitmap;", "+\tif (bm.bmBitsPixel == 32 && OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed ()) {", "+\t\tBITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER();", "+\t\tbmiHeader.biSize = BITMAPINFOHEADER.sizeof;", "+\t\tbmiHeader.biWidth = width;", "+\t\tbmiHeader.biHeight = -height;", "+\t\tbmiHeader.biPlanes = 1;", "+\t\tbmiHeader.biBitCount = (short)24;", "+\t\tif (OS.IsWinCE) bmiHeader.biCompression = OS.BI_BITFIELDS;", "+\t\telse bmiHeader.biCompression = OS.BI_RGB;", "+\t\tbyte[] bmi = new byte[BITMAPINFOHEADER.sizeof + (OS.IsWinCE ? 12 : 0)];", "+\t\tOS.MoveMemory(bmi, bmiHeader, BITMAPINFOHEADER.sizeof);", "+\t\t/* Set the rgb colors into the bitmap info */", "+\t\tif (OS.IsWinCE) {", "+\t\t\tint redMask = 0xFF00;", "+\t\t\tint greenMask = 0xFF0000;", "+\t\t\tint blueMask = 0xFF000000;", "+\t\t\t/* big endian */", "+\t\t\tint offset = BITMAPINFOHEADER.sizeof;", "+\t\t\tbmi[offset] = (byte)((redMask & 0xFF000000) >> 24);", "+\t\t\tbmi[offset + 1] = (byte)((redMask & 0xFF0000) >> 16);", "+\t\t\tbmi[offset + 2] = (byte)((redMask & 0xFF00) >> 8);", "+\t\t\tbmi[offset + 3] = (byte)((redMask & 0xFF) >> 0);", "+\t\t\tbmi[offset + 4] = (byte)((greenMask & 0xFF000000) >> 24);", "+\t\t\tbmi[offset + 5] = (byte)((greenMask & 0xFF0000) >> 16);", "+\t\t\tbmi[offset + 6] = (byte)((greenMask & 0xFF00) >> 8);", "+\t\t\tbmi[offset + 7] = (byte)((greenMask & 0xFF) >> 0);", "+\t\t\tbmi[offset + 8] = (byte)((blueMask & 0xFF000000) >> 24);", "+\t\t\tbmi[offset + 9] = (byte)((blueMask & 0xFF0000) >> 16);", "+\t\t\tbmi[offset + 10] = (byte)((blueMask & 0xFF00) >> 8);", "+\t\t\tbmi[offset + 11] = (byte)((blueMask & 0xFF) >> 0);", "+\t\t}", "+\t\tint[] pBits = new int[1];", "+\t\thBitmap = OS.CreateDIBSection(0, bmi, OS.DIB_RGB_COLORS, pBits, 0, 0);", "+\t} else {", "+\t\thBitmap = OS.CreateCompatibleBitmap (hDC, width, height);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4186e269ffdf41cf7fdd233d51ecfe12", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "e253003f379a5077ef9bad1970e6ecd3caffe942", "commitAfterChange": "13106f1c871b402082825e5386ce5c12162603e8", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r \r void init(Device device, ImageData i)", "signatureAfterChange": "\r \r void init(Device device, ImageData i)", "diff": ["+\tboolean useBitfields = OS.IsWinCE && (i.depth == 16 || i.depth == 32);\r", "-\t\tbmi = new byte[40];\r", "+\t\tbmi = new byte[40 + (useBitfields ? 12 : 0)];\r", "-\t/* DWORD biCompression = BI_RGB = 0 */\r", "-\tbmi[16] = bmi[17] = bmi[18] = bmi[19] = 0;\r", "+\tif (useBitfields) {\r", "+\t\t/* DWORD biCompression = BI_BITFIELDS = 3 */\r", "+\t\tbmi[16] = 3; bmi[17] = bmi[18] = bmi[19] = 0;\r", "+\t} else {\r", "+\t\t/* DWORD biCompression = BI_RGB = 0 */\r", "+\t\tbmi[16] = bmi[17] = bmi[18] = bmi[19] = 0;\r", "+\t}\r", "-\tif (!i.palette.isDirect) {\r", "+\tif (i.palette.isDirect) {\r", "+\t\tif (useBitfields) {\r", "+\t\t\tPaletteData palette = i.palette;\r", "+\t\t\tint redMask = palette.redMask;\r", "+\t\t\tint greenMask = palette.greenMask;\r", "+\t\t\tint blueMask = palette.blueMask;\r", "+\t\t\tbmi[40] = (byte)((redMask & 0xFF) >> 0);\r", "+\t\t\tbmi[41] = (byte)((redMask & 0xFF00) >> 8);\r", "+\t\t\tbmi[42] = (byte)((redMask & 0xFF0000) >> 16);\r", "+\t\t\tbmi[43] = (byte)((redMask & 0xFF000000) >> 24);\r", "+\t\t\tbmi[44] = (byte)((greenMask & 0xFF) >> 0);\r", "+\t\t\tbmi[45] = (byte)((greenMask & 0xFF00) >> 8);\r", "+\t\t\tbmi[46] = (byte)((greenMask & 0xFF0000) >> 16);\r", "+\t\t\tbmi[47] = (byte)((greenMask & 0xFF000000) >> 24);\r", "+\t\t\tbmi[48] = (byte)((blueMask & 0xFF) >> 0);\r", "+\t\t\tbmi[49] = (byte)((blueMask & 0xFF00) >> 8);\r", "+\t\t\tbmi[50] = (byte)((blueMask & 0xFF0000) >> 16);\r", "+\t\t\tbmi[51] = (byte)((blueMask & 0xFF000000) >> 24);\r", "+\t\t}\r", "+\t} else {\r"]}], "num": 42665}