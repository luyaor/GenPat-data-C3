{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bba2cfc2d0c764b374bb673ac59a29e3", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5562937ae192597c484ddde3678cf95f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "9ff10cb48f82b9ae865058d0bbaabcdfd7febeca", "commitAfterChange": "74127501f3b2eceb3db2c2e14c28ae868f8a3b22", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": " void shape (final int hdc, final StyleItem run)", "signatureAfterChange": " void shape (final int hdc, final StyleItem run)", "diff": ["-\t* Feature in Uniscribe, the U+FEFF is not supported by", "+\t* Feature in Uniscribe, .. ..  the U+FEFF is not supported by", "-\tfor (int i = 0; i < chars.length; i++) {", "-\t\tif (chars[i] == '\\uFEFF') chars[i] = '\\u200B';", "-\t}", "+\tfinal short script = run.analysis.eScript;", "+\tSCRIPT_PROPERTIES sp = new SCRIPT_PROPERTIES();", "+\tOS.MoveMemory(sp, device.scripts[script], SCRIPT_PROPERTIES.sizeof);", "+\tfinal boolean useCMap = false;", "-\tfinal short script = run.analysis.eScript;", "-\tfinal SCRIPT_PROPERTIES sp = new SCRIPT_PROPERTIES();", "-\tOS.MoveMemory(sp, device.scripts[script], SCRIPT_PROPERTIES.sizeof);", "-\tboolean shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "+\tboolean shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, useCMap);", "-\tif (!shapeSucceed) {", "-\t\t/* ", "-\t\t * Shape failed.", "-\t\t * Try to shape with fNoGlyphIndex when the run is in the ", "-\t\t * Private Use Area. This allows for end-user-defined character (EUDC).", "-\t\t */", "-\t\tif (sp.fPrivateUseArea) {", "-\t\t\trun.analysis.fNoGlyphIndex = true;", "-\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-\t\t}", "-\t}", "+//\tif (!shapeSucceed) {", "+//\t\t/* ", "+//\t\t * Shape failed.", "+//\t\t * Try to shape with fNoGlyphIndex when the run is in the ", "+//\t\t * Private Use Area. This allows for end-user-defined character (EUDC).", "+//\t\t */", "+//\t\tif (sp.fPrivateUseArea) {", "+//\t\t\trun.analysis.fNoGlyphIndex = true;", "+//\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, useCMap);", "+//\t\t}", "+//\t}", "+\t", "+//\tif (!shapeSucceed) {", "+//\tint hFont = OS.bogus(hdc, chars, chars.length);", "+//\tif (hFont != 0) {", "+//\t\tSystem.out.println(script + \" FALLBACK \" + Font.win32_new(device, hFont).getFontData()[0]);", "+//\t\tint /*long*/ oldFont = OS.SelectObject(hdc, hFont);", "+//\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, false);", "+//\t\tif (shapeSucceed) {", "+//\t\t\trun.fallbackFont = hFont;", "+//\t\t\tSystem.out.println(script + \" FALLBACK SUCCED\");", "+//\t\t}", "+//\t} else {", "+//\t\tSystem.out.println(\"fallback failed\");", "+//\t}", "+//}", "+", "-\t\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "+\t\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, false);", "+\t\t\t\t\tSystem.out.println(script + \" MLANG \" + Font.win32_new(device, run.fallbackFont).getFontData()[0]);", "-\t", "+", "-\t\t/*", "-\t\t* Shape Failed.", "-\t\t* Try to shape the run using the LOGFONT in the cache.", "-\t\t*/", "-\t\tfinal int /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "-\t\tfinal LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "-\t\t", "-\t\tLOGFONT cachedLogFont = device.logFontsCache != null ? device.logFontsCache[script] : null;", "-\t\tif (cachedLogFont != null) {", "-\t\t\tcachedLogFont.lfHeight = logFont.lfHeight;", "-\t\t\tcachedLogFont.lfWeight = logFont.lfWeight;", "-\t\t\tcachedLogFont.lfItalic = logFont.lfItalic;", "-\t\t\tcachedLogFont.lfWidth = logFont.lfWidth;", "-\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(cachedLogFont);", "+\t\tif (!sp.fComplex) {", "+\t\t\tint /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "+\t\t\tLOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "+\t\t\tLOGFONT systemLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\tOS.GetObject(device.systemFont.handle, LOGFONT.sizeof, systemLogFont);", "+\t\t\tsystemLogFont.lfHeight = logFont.lfHeight;", "+\t\t\tsystemLogFont.lfWeight = logFont.lfWeight;", "+\t\t\tsystemLogFont.lfItalic = logFont.lfItalic;", "+\t\t\tsystemLogFont.lfWidth = logFont.lfWidth;", "+\t\t\tint newFont = OS.CreateFontIndirect (systemLogFont);", "-\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "+\t\t\trun.analysis.fNoGlyphIndex = true;", "+\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, false);", "+\t\t\t\tSystem.out.println(\"fNoGlyphIndex \" + script);", "+\t\t\t\trun.analysis.fNoGlyphIndex = false;", "-\t\t}", "-\t\tif (!shapeSucceed) {", "-\t\t\t/*", "-\t\t\t* Shape Failed.", "-\t\t\t* Use EnumFontFamExProc to iterate over every font in the system that supports ", "-\t\t\t* the charset of the run and try to shape it.  ", "-\t\t\t*/", "-\t\t\tif (device.logFontsCache == null) device.logFontsCache = new LOGFONT[device.scripts.length];", "-\t\t\tfinal LOGFONT newLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\tclass EnumFontFamEx {", "-\t\t\t\tint /*long*/ EnumFontFamExProc (int /*long*/ lpelfe, int /*long*/ lpntme, int /*long*/ FontType, int /*long*/ lParam) {", "-\t\t\t\t\tif (FontType == OS.RASTER_FONTTYPE) return 1;", "-\t\t\t\t\tOS.MoveMemory(newLogFont, lpelfe, LOGFONT.sizeof);", "-\t\t\t\t\tnewLogFont.lfHeight = logFont.lfHeight;", "-\t\t\t\t\tnewLogFont.lfWeight = logFont.lfWeight;", "-\t\t\t\t\tnewLogFont.lfItalic = logFont.lfItalic;", "-\t\t\t\t\tnewLogFont.lfWidth = logFont.lfWidth;", "-\t\t\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(newLogFont);", "-\t\t\t\t\tOS.SelectObject(hdc, newFont);", "-\t\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs, sp)) {", "-\t\t\t\t\t\trun.fallbackFont = newFont;", "-\t\t\t\t\t\tLOGFONT cacheLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\t\t\t\tOS.MoveMemory(cacheLogFont, lpelfe, LOGFONT.sizeof);", "-\t\t\t\t\t\tdevice.logFontsCache[script] = cacheLogFont;", "-\t\t\t\t\t\treturn 0;", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.SelectObject(hdc, hFont);", "-\t\t\t\t\tOS.DeleteObject(newFont);", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t};", "-\t\t\tEnumFontFamEx object = new EnumFontFamEx();", "-\t\t\t/* Avoid compiler warnings */", "-\t\t\tif (false) object.EnumFontFamExProc(0, 0, 0, 0);", "-\t\t\tCallback callback = new Callback(object, \"EnumFontFamExProc\", 4);", "-\t\t\tint /*long*/ address = callback.getAddress();", "-\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "-\t\t\tint charSet = sp.fAmbiguousCharSet ? OS.DEFAULT_CHARSET : sp.bCharSet;", "-\t\t\tnewLogFont.lfCharSet = (byte)charSet;", "-\t\t\tOS.EnumFontFamiliesEx(hdc, newLogFont, address, 0, 0);", "-\t\t\tcallback.dispose();", "-\t\t\tshapeSucceed = run.fallbackFont != 0;", "+//\tif (!shapeSucceed && false) {", "+//\t\t/*", "+//\t\t* Shape Failed.", "+//\t\t* Try to shape the run using the LOGFONT in the cache.", "+//\t\t*/", "+//\t\tfinal int /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "+//\t\tfinal LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+//\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "+//\t\t", "+//\t\tLOGFONT cachedLogFont = device.logFontsCache != null ? device.logFontsCache[script] : null;", "+//\t\tif (cachedLogFont != null) {", "+//\t\t\tcachedLogFont.lfHeight = logFont.lfHeight;", "+//\t\t\tcachedLogFont.lfWeight = logFont.lfWeight;", "+//\t\t\tcachedLogFont.lfItalic = logFont.lfItalic;", "+//\t\t\tcachedLogFont.lfWidth = logFont.lfWidth;", "+//\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(cachedLogFont);", "+//\t\t\tOS.SelectObject(hdc, newFont);", "+//\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, useCMap);", "+//\t\t\tif (shapeSucceed) {", "+//\t\t\t\trun.fallbackFont = newFont;", "+//\t\t\t\tSystem.out.println(script + \" CACHE \" + Font.win32_new(device, run.fallbackFont).getFontData()[0]);", "+//\t\t\t} else {", "+//\t\t\t\tOS.SelectObject(hdc, hFont);", "+//\t\t\t\tOS.DeleteObject(newFont);", "+//\t\t\t}", "+//\t\t}", "+//\t\tif (!shapeSucceed) {", "+//\t\t\t/*", "+//\t\t\t* Shape Failed.", "+//\t\t\t* Use EnumFontFamExProc to iterate over every font in the system that supports ", "+//\t\t\t* the charset of the run and try to shape it.  ", "+//\t\t\t*/", "+//\t\t\tif (device.logFontsCache == null) device.logFontsCache = new LOGFONT[device.scripts.length];", "+//\t\t\tfinal LOGFONT newLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+//\t\t\tclass EnumFontFamEx {", "+//\t\t\t\tint /*long*/ EnumFontFamExProc (int /*long*/ lpelfe, int /*long*/ lpntme, int /*long*/ FontType, int /*long*/ lParam) {", "+//\t\t\t\t\tif (FontType == OS.RASTER_FONTTYPE) return 1;", "+//\t\t\t\t\tOS.MoveMemory(newLogFont, lpelfe, LOGFONT.sizeof);", "+//\t\t\t\t\tnewLogFont.lfHeight = logFont.lfHeight;", "+//\t\t\t\t\tnewLogFont.lfWeight = logFont.lfWeight;", "+//\t\t\t\t\tnewLogFont.lfItalic = logFont.lfItalic;", "+//\t\t\t\t\tnewLogFont.lfWidth = logFont.lfWidth;", "+//\t\t\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(newLogFont);", "+//\t\t\t\t\tOS.SelectObject(hdc, newFont);", "+//\t\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs, useCMap)) {", "+//\t\t\t\t\t\trun.fallbackFont = newFont;", "+//\t\t\t\t\t\tLOGFONT cacheLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+//\t\t\t\t\t\tOS.MoveMemory(cacheLogFont, lpelfe, LOGFONT.sizeof);", "+//\t\t\t\t\t\tdevice.logFontsCache[script] = cacheLogFont;", "+//\t\t\t\t\t\tSystem.out.println(script + \" ENUM \" + Font.win32_new(device, run.fallbackFont).getFontData()[0]);", "+//\t\t\t\t\t\treturn 0;", "+//\t\t\t\t\t}", "+//\t\t\t\t\tOS.SelectObject(hdc, hFont);", "+//\t\t\t\t\tOS.DeleteObject(newFont);", "+//\t\t\t\t\treturn 1;", "+//\t\t\t\t}", "+//\t\t\t};", "+//\t\t\tEnumFontFamEx object = new EnumFontFamEx();", "+//\t\t\t/* Avoid compiler warnings */", "+//\t\t\tif (false) object.EnumFontFamExProc(0, 0, 0, 0);", "+//\t\t\tCallback callback = new Callback(object, \"EnumFontFamExProc\", 4);", "+//\t\t\tint /*long*/ address = callback.getAddress();", "+//\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "+//\t\t\tint charSet = sp.fAmbiguousCharSet ? OS.DEFAULT_CHARSET : sp.bCharSet;", "+//\t\t\tnewLogFont.lfCharSet = (byte)charSet;", "+//\t\t\tOS.EnumFontFamiliesEx(hdc, newLogFont, address, 0, 0);", "+//\t\t\tcallback.dispose();", "+//\t\t\tshapeSucceed = run.fallbackFont != 0;", "+//\t\t}", "+//\t}", "+\t", "+\t\tSystem.out.println(\"NONE \" + script);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7b8def17ab1020f0e6fc71b96dc7bc40", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "c434902e868dc31f4d87acdb50f51cbdb8752d24", "commitAfterChange": "046e0d0bfd6bae07f076caade40f57f2f865587f", "methodNumberBeforeChange": 66, "methodNumberAfterChange": 65, "signatureBeforeChange": " void shape (final int hdc, final StyleItem run)", "signatureAfterChange": " void shape (final int hdc, final StyleItem run)", "diff": ["-\t", "-\t\tboolean useGDI = !sp.fComplex;", "-\t\t/*", "-\t\t* Bug in Windows.  There are non-complex scripts that are", "-\t\t* not supported by GDI. The fix is to detect these scripts", "-\t\t* by checking the Unicode ranges and use Uniscribe instead.", "-\t\t*   ", "-\t\t* These are the scripts: ", "-\t\t* \t0x0530..0x058F is Armenian", "-\t\t*   0x10A0..0x10FF is Georgian", "-\t\t*   0xA000..0xA4CF is Yi", "-\t\t*/", "-\t\tchar c = chars[0];", "-\t\tif (0x0530 <= c && c <= 0x058F || 0x10A0 <= c && c <= 0x10FF || 0xA000 <= c && c <= 0xA4CF) {", "-\t\t\tuseGDI = false;", "+\t\tint /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "+\t\tint /*long*/ ssa = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, OS.SCRIPT_STRING_ANALYSIS_sizeof());", "+\t\tint /*long*/ metaFileDc = OS.CreateEnhMetaFile(hdc, null, null, null);", "+\t\tint /*long*/ oldMetaFont = OS.SelectObject(metaFileDc, hFont);", "+\t\tint flags = OS.SSA_METAFILE | OS.SSA_FALLBACK | OS.SSA_GLYPHS | OS.SSA_LINK;", "+\t\tif (OS.ScriptStringAnalyse(metaFileDc, chars, chars.length, 0, -1, flags, 0, null, null, 0, 0, 0, ssa) == OS.S_OK) {", "+\t\t\tOS.ScriptStringOut(ssa, 0, 0, 0, null, 0, 0, false);", "+\t\t\tOS.ScriptStringFree(ssa);", "-\t\tif (useGDI) {", "-\t\t\tint /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "-\t\t\tLOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "-\t\t\tLOGFONT systemLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\tOS.GetObject(device.systemFont.handle, LOGFONT.sizeof, systemLogFont);", "-\t\t\tsystemLogFont.lfHeight = logFont.lfHeight;", "-\t\t\tsystemLogFont.lfWeight = logFont.lfWeight;", "-\t\t\tsystemLogFont.lfItalic = logFont.lfItalic;", "-\t\t\tsystemLogFont.lfWidth = logFont.lfWidth;", "-\t\t\tint /*long*/ newFont = OS.CreateFontIndirect (systemLogFont);", "-\t\t\tOS.SelectObject(hdc, newFont);", "-\t\t\trun.analysis.fNoGlyphIndex = true;", "-\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-\t\t\tif (shapeSucceed) {", "-\t\t\t\trun.fallbackFont = newFont;", "-\t\t\t} else {", "-\t\t\t\tOS.SelectObject(hdc, hFont);", "-\t\t\t\tOS.DeleteObject(newFont);", "-\t\t\t\trun.analysis.fNoGlyphIndex = false;", "-\t\t\t}", "-\t\t}", "-\t}", "-\t", "-\tif (!shapeSucceed) {", "-\t\t/*", "-\t\t* Shape Failed.", "-\t\t* Try to use MLANG to find a suitable font to shape the run.  ", "-\t\t*/", "-\t\tif (mLangFontLink2 != 0) {", "-\t\t\tint[] dwCodePages = new int[1];", "-\t\t\tint[] cchCodePages = new int[1];", "-\t\t\t/* GetStrCodePages() */", "-\t\t\tOS.VtblCall(4, mLangFontLink2, chars, chars.length, 0, dwCodePages, cchCodePages);", "-\t\t\tint /*long*/[] hNewFont = new int /*long*/[1];", "-\t\t\t/* MapFont() */", "-\t\t\tif (OS.VtblCall(10, mLangFontLink2, hdc, dwCodePages[0], chars[0], hNewFont) == OS.S_OK) {", "-\t\t\t\tint /*long*/ hFont = OS.SelectObject(hdc, hNewFont[0]);", "-\t\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-\t\t\t\tif (shapeSucceed) {", "-\t\t\t\t\trun.fallbackFont = hNewFont[0];", "-\t\t\t\t\trun.mlang = true;", "-\t\t\t\t} else {", "-\t\t\t\t\t/* ReleaseFont() */", "-\t\t\t\t\tOS.VtblCall(8, mLangFontLink2, hNewFont[0]);", "-\t\t\t\t\tOS.SelectObject(hdc, hFont);", "+\t\tOS.HeapFree(hHeap, 0, ssa);", "+\t\tOS.SelectObject(metaFileDc, oldMetaFont);", "+\t\tint /*long*/ metaFile = OS.CloseEnhMetaFile(metaFileDc);", "+\t\tfinal EMREXTCREATEFONTINDIRECTW emr = new EMREXTCREATEFONTINDIRECTW();", "+\t\tclass MetaFileEnumProc {", "+\t\t\tint /*long*/ metaFileEnumProc (int /*long*/ hDC, int /*long*/ table, int /*long*/ record, int /*long*/ nObj, int /*long*/ lpData) {", "+\t\t\t\tOS.MoveMemory(emr.emr, record, EMR.sizeof);", "+\t\t\t\tswitch (emr.emr.iType) {", "+\t\t\t\t\tcase OS.EMR_EXTCREATEFONTINDIRECTW:", "+\t\t\t\t\t\tOS.MoveMemory(emr, record, EMREXTCREATEFONTINDIRECTW.sizeof);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase OS.EMR_EXTTEXTOUTW:", "+\t\t\t\t\t\treturn 0;", "+\t\t\t\treturn 1;", "+\t\t};", "+\t\tMetaFileEnumProc object = new MetaFileEnumProc();", "+\t\t/* Avoid compiler warnings */", "+\t\tif (false) object.metaFileEnumProc(0, 0, 0, 0, 0);", "+\t\tCallback callback = new Callback(object, \"metaFileEnumProc\", 5);", "+\t\tint /*long*/ address = callback.getAddress();", "+\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "+\t\tOS.EnumEnhMetaFile(0, metaFile, address, 0, null);", "+\t\tOS.DeleteEnhMetaFile(metaFile);", "+\t\tcallback.dispose();", "+", "+\t\tint /*long*/ newFont = OS.CreateFontIndirectW(emr.elfw.elfLogFont);", "+\t\tOS.SelectObject(hdc, newFont);", "+\t\tif (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {", "+\t\t\trun.fallbackFont = newFont;", "-\t}", "-\t", "-\tif (!shapeSucceed) {", "-\t\t/*", "-\t\t* Shape Failed.", "-\t\t* Try to shape the run using the LOGFONT in the cache.", "-\t\t*/", "-\t\tfinal int /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "-\t\tfinal LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "-\t\t", "-\t\tLOGFONT cachedLogFont = device.logFontsCache != null ? device.logFontsCache[script] : null;", "-\t\tif (cachedLogFont != null) {", "-\t\t\tcachedLogFont.lfHeight = logFont.lfHeight;", "-\t\t\tcachedLogFont.lfWeight = logFont.lfWeight;", "-\t\t\tcachedLogFont.lfItalic = logFont.lfItalic;", "-\t\t\tcachedLogFont.lfWidth = logFont.lfWidth;", "-\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(cachedLogFont);", "-\t\t\tOS.SelectObject(hdc, newFont);", "-\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-\t\t\tif (shapeSucceed) {", "-\t\t\t\trun.fallbackFont = newFont;", "-\t\t\t} else {", "-\t\t\t\tOS.SelectObject(hdc, hFont);", "-\t\t\t\tOS.DeleteObject(newFont);", "+\t\tif (!shapeSucceed) {", "+\t\t\tif (!sp.fComplex) {", "+\t\t\t\trun.analysis.fNoGlyphIndex = true;", "+\t\t\t\tif (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {", "+\t\t\t\t\trun.fallbackFont = newFont;", "+\t\t\t\t} else {", "+\t\t\t\t\trun.analysis.fNoGlyphIndex = false;", "+\t\t\t\t}", "-\t\t\t/*", "-\t\t\t* Shape Failed.", "-\t\t\t* Use EnumFontFamExProc to iterate over every font in the system that supports ", "-\t\t\t* the charset of the run and try to shape it.  ", "-\t\t\t*/", "-\t\t\tif (device.logFontsCache == null) device.logFontsCache = new LOGFONT[device.scripts.length];", "-\t\t\tfinal LOGFONT newLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\tclass EnumFontFamEx {", "-\t\t\t\tint /*long*/ EnumFontFamExProc (int /*long*/ lpelfe, int /*long*/ lpntme, int /*long*/ FontType, int /*long*/ lParam) {", "-\t\t\t\t\tif (FontType == OS.RASTER_FONTTYPE) return 1;", "-\t\t\t\t\tOS.MoveMemory(newLogFont, lpelfe, LOGFONT.sizeof);", "-\t\t\t\t\tnewLogFont.lfHeight = logFont.lfHeight;", "-\t\t\t\t\tnewLogFont.lfWeight = logFont.lfWeight;", "-\t\t\t\t\tnewLogFont.lfItalic = logFont.lfItalic;", "-\t\t\t\t\tnewLogFont.lfWidth = logFont.lfWidth;", "-\t\t\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(newLogFont);", "-\t\t\t\t\tOS.SelectObject(hdc, newFont);", "-\t\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs, sp)) {", "-\t\t\t\t\t\trun.fallbackFont = newFont;", "-\t\t\t\t\t\tLOGFONT cacheLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\t\t\t\tOS.MoveMemory(cacheLogFont, lpelfe, LOGFONT.sizeof);", "-\t\t\t\t\t\tdevice.logFontsCache[script] = cacheLogFont;", "-\t\t\t\t\t\treturn 0;", "+\t\t\tif (mLangFontLink2 != 0) {", "+\t\t\t\tint /*long*/[] hNewFont = new int /*long*/[1];", "+\t\t\t\tint[] dwCodePages = new int[1], cchCodePages = new int[1];", "+\t\t\t\t/* GetStrCodePages() */", "+\t\t\t\tOS.VtblCall(4, mLangFontLink2, chars, chars.length, 0, dwCodePages, cchCodePages);", "+\t\t\t\t/* MapFont() */", "+\t\t\t\tif (OS.VtblCall(10, mLangFontLink2, hdc, dwCodePages[0], chars[0], hNewFont) == OS.S_OK) {", "+\t\t\t\t\tLOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\t\t\tOS.GetObject(hNewFont[0], LOGFONT.sizeof, logFont);", "+\t\t\t\t\t/* ReleaseFont() */", "+\t\t\t\t\tOS.VtblCall(8, mLangFontLink2, hNewFont[0]);", "+\t\t\t\t\tint /*long*/ mLangFont = OS.CreateFontIndirect(logFont);", "+\t\t\t\t\tint /*long*/ oldFont = OS.SelectObject(hdc, mLangFont);", "+\t\t\t\t\tif (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {", "+\t\t\t\t\t\trun.fallbackFont = mLangFont;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tOS.SelectObject(hdc, oldFont);", "+\t\t\t\t\t\tOS.DeleteObject(mLangFont);", "-\t\t\t\t\tOS.SelectObject(hdc, hFont);", "-\t\t\t\t\tOS.DeleteObject(newFont);", "-\t\t\t\t\treturn 1;", "-\t\t\t};", "-\t\t\tEnumFontFamEx object = new EnumFontFamEx();", "-\t\t\t/* Avoid compiler warnings */", "-\t\t\tif (false) object.EnumFontFamExProc(0, 0, 0, 0);", "-\t\t\tCallback callback = new Callback(object, \"EnumFontFamExProc\", 4);", "-\t\t\tint /*long*/ address = callback.getAddress();", "-\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "-\t\t\tint charSet = sp.fAmbiguousCharSet ? OS.DEFAULT_CHARSET : sp.bCharSet;", "-\t\t\tnewLogFont.lfCharSet = (byte)charSet;", "-\t\t\tOS.EnumFontFamiliesEx(hdc, newLogFont, address, 0, 0);", "-\t\t\tcallback.dispose();", "-\t\t\tshapeSucceed = run.fallbackFont != 0;", "+\t\t\t}", "+\t\tif (!shapeSucceed) OS.SelectObject(hdc, hFont);", "+\t\tif (newFont != run.fallbackFont) OS.DeleteObject(newFont);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5cafe5c28901782dd6da88940b254691", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "74127501f3b2eceb3db2c2e14c28ae868f8a3b22", "commitAfterChange": "4994670aef66c143f8196f33f0e5020a1d0f1eec", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": " void shape (final int hdc, final StyleItem run)", "signatureAfterChange": " void shape (final int hdc, final StyleItem run)", "diff": ["-\t* Feature in Uniscribe, .. ..  the U+FEFF is not supported by", "+\t* Feature in Uniscribe, the U+FEFF is not supported by", "-\tfinal short script = run.analysis.eScript;", "-\tSCRIPT_PROPERTIES sp = new SCRIPT_PROPERTIES();", "-\tOS.MoveMemory(sp, device.scripts[script], SCRIPT_PROPERTIES.sizeof);", "-\tfinal boolean useCMap = false;", "+\tfor (int i = 0; i < chars.length; i++) {", "+\t\tif (chars[i] == '\\uFEFF') chars[i] = '\\u200B';", "+\t}", "-\tboolean shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, useCMap);", "+\tfinal short script = run.analysis.eScript;", "+\tfinal SCRIPT_PROPERTIES sp = new SCRIPT_PROPERTIES();", "+\tOS.MoveMemory(sp, device.scripts[script], SCRIPT_PROPERTIES.sizeof);", "+\tboolean shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-//\tif (!shapeSucceed) {", "-//\t\t/* ", "-//\t\t * Shape failed.", "-//\t\t * Try to shape with fNoGlyphIndex when the run is in the ", "-//\t\t * Private Use Area. This allows for end-user-defined character (EUDC).", "-//\t\t */", "-//\t\tif (sp.fPrivateUseArea) {", "-//\t\t\trun.analysis.fNoGlyphIndex = true;", "-//\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, useCMap);", "-//\t\t}", "-//\t}", "-\t", "-//\tif (!shapeSucceed) {", "-//\tint hFont = OS.bogus(hdc, chars, chars.length);", "-//\tif (hFont != 0) {", "-//\t\tSystem.out.println(script + \" FALLBACK \" + Font.win32_new(device, hFont).getFontData()[0]);", "-//\t\tint /*long*/ oldFont = OS.SelectObject(hdc, hFont);", "-//\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, false);", "-//\t\tif (shapeSucceed) {", "-//\t\t\trun.fallbackFont = hFont;", "-//\t\t\tSystem.out.println(script + \" FALLBACK SUCCED\");", "-//\t\t}", "-//\t} else {", "-//\t\tSystem.out.println(\"fallback failed\");", "-//\t}", "-//}", "-", "+\tif (!shapeSucceed) {", "+\t\t/* ", "+\t\t * Shape failed.", "+\t\t * Try to shape with fNoGlyphIndex when the run is in the ", "+\t\t * Private Use Area. This allows for end-user-defined character (EUDC).", "+\t\t */", "+\t\tif (sp.fPrivateUseArea) {", "+\t\t\trun.analysis.fNoGlyphIndex = true;", "+\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "+\t\t}", "+\t}", "-\t\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, false);", "+\t\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-\t\t\t\t\tSystem.out.println(script + \" MLANG \" + Font.win32_new(device, run.fallbackFont).getFontData()[0]);", "-", "+\t", "-\t\tif (!sp.fComplex) {", "-\t\t\tint /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "-\t\t\tLOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "-\t\t\tLOGFONT systemLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\tOS.GetObject(device.systemFont.handle, LOGFONT.sizeof, systemLogFont);", "-\t\t\tsystemLogFont.lfHeight = logFont.lfHeight;", "-\t\t\tsystemLogFont.lfWeight = logFont.lfWeight;", "-\t\t\tsystemLogFont.lfItalic = logFont.lfItalic;", "-\t\t\tsystemLogFont.lfWidth = logFont.lfWidth;", "-\t\t\tint newFont = OS.CreateFontIndirect (systemLogFont);", "+\t\t/*", "+\t\t* Shape Failed.", "+\t\t* Try to shape the run using the LOGFONT in the cache.", "+\t\t*/", "+\t\tfinal int /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "+\t\tfinal LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "+\t\t", "+\t\tLOGFONT cachedLogFont = device.logFontsCache != null ? device.logFontsCache[script] : null;", "+\t\tif (cachedLogFont != null) {", "+\t\t\tcachedLogFont.lfHeight = logFont.lfHeight;", "+\t\t\tcachedLogFont.lfWeight = logFont.lfWeight;", "+\t\t\tcachedLogFont.lfItalic = logFont.lfItalic;", "+\t\t\tcachedLogFont.lfWidth = logFont.lfWidth;", "+\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(cachedLogFont);", "-\t\t\trun.analysis.fNoGlyphIndex = true;", "-\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, false);", "+\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-\t\t\t\tSystem.out.println(\"fNoGlyphIndex \" + script);", "-\t\t\t\trun.analysis.fNoGlyphIndex = false;", "+\t\t}", "+\t\tif (!shapeSucceed) {", "+\t\t\t/*", "+\t\t\t* Shape Failed.", "+\t\t\t* Use EnumFontFamExProc to iterate over every font in the system that supports ", "+\t\t\t* the charset of the run and try to shape it.  ", "+\t\t\t*/", "+\t\t\tif (device.logFontsCache == null) device.logFontsCache = new LOGFONT[device.scripts.length];", "+\t\t\tfinal LOGFONT newLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\tclass EnumFontFamEx {", "+\t\t\t\tint /*long*/ EnumFontFamExProc (int /*long*/ lpelfe, int /*long*/ lpntme, int /*long*/ FontType, int /*long*/ lParam) {", "+\t\t\t\t\tif (FontType == OS.RASTER_FONTTYPE) return 1;", "+\t\t\t\t\tOS.MoveMemory(newLogFont, lpelfe, LOGFONT.sizeof);", "+\t\t\t\t\tnewLogFont.lfHeight = logFont.lfHeight;", "+\t\t\t\t\tnewLogFont.lfWeight = logFont.lfWeight;", "+\t\t\t\t\tnewLogFont.lfItalic = logFont.lfItalic;", "+\t\t\t\t\tnewLogFont.lfWidth = logFont.lfWidth;", "+\t\t\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(newLogFont);", "+\t\t\t\t\tOS.SelectObject(hdc, newFont);", "+\t\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs, sp)) {", "+\t\t\t\t\t\trun.fallbackFont = newFont;", "+\t\t\t\t\t\tLOGFONT cacheLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\t\t\t\tOS.MoveMemory(cacheLogFont, lpelfe, LOGFONT.sizeof);", "+\t\t\t\t\t\tdevice.logFontsCache[script] = cacheLogFont;", "+\t\t\t\t\t\treturn 0;", "+\t\t\t\t\t}", "+\t\t\t\t\tOS.SelectObject(hdc, hFont);", "+\t\t\t\t\tOS.DeleteObject(newFont);", "+\t\t\t\t\treturn 1;", "+\t\t\t\t}", "+\t\t\t};", "+\t\t\tEnumFontFamEx object = new EnumFontFamEx();", "+\t\t\t/* Avoid compiler warnings */", "+\t\t\tif (false) object.EnumFontFamExProc(0, 0, 0, 0);", "+\t\t\tCallback callback = new Callback(object, \"EnumFontFamExProc\", 4);", "+\t\t\tint /*long*/ address = callback.getAddress();", "+\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "+\t\t\tint charSet = sp.fAmbiguousCharSet ? OS.DEFAULT_CHARSET : sp.bCharSet;", "+\t\t\tnewLogFont.lfCharSet = (byte)charSet;", "+\t\t\tOS.EnumFontFamiliesEx(hdc, newLogFont, address, 0, 0);", "+\t\t\tcallback.dispose();", "+\t\t\tshapeSucceed = run.fallbackFont != 0;", "-//\tif (!shapeSucceed && false) {", "-//\t\t/*", "-//\t\t* Shape Failed.", "-//\t\t* Try to shape the run using the LOGFONT in the cache.", "-//\t\t*/", "-//\t\tfinal int /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "-//\t\tfinal LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-//\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "-//\t\t", "-//\t\tLOGFONT cachedLogFont = device.logFontsCache != null ? device.logFontsCache[script] : null;", "-//\t\tif (cachedLogFont != null) {", "-//\t\t\tcachedLogFont.lfHeight = logFont.lfHeight;", "-//\t\t\tcachedLogFont.lfWeight = logFont.lfWeight;", "-//\t\t\tcachedLogFont.lfItalic = logFont.lfItalic;", "-//\t\t\tcachedLogFont.lfWidth = logFont.lfWidth;", "-//\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(cachedLogFont);", "-//\t\t\tOS.SelectObject(hdc, newFont);", "-//\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, useCMap);", "-//\t\t\tif (shapeSucceed) {", "-//\t\t\t\trun.fallbackFont = newFont;", "-//\t\t\t\tSystem.out.println(script + \" CACHE \" + Font.win32_new(device, run.fallbackFont).getFontData()[0]);", "-//\t\t\t} else {", "-//\t\t\t\tOS.SelectObject(hdc, hFont);", "-//\t\t\t\tOS.DeleteObject(newFont);", "-//\t\t\t}", "-//\t\t}", "-//\t\tif (!shapeSucceed) {", "-//\t\t\t/*", "-//\t\t\t* Shape Failed.", "-//\t\t\t* Use EnumFontFamExProc to iterate over every font in the system that supports ", "-//\t\t\t* the charset of the run and try to shape it.  ", "-//\t\t\t*/", "-//\t\t\tif (device.logFontsCache == null) device.logFontsCache = new LOGFONT[device.scripts.length];", "-//\t\t\tfinal LOGFONT newLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-//\t\t\tclass EnumFontFamEx {", "-//\t\t\t\tint /*long*/ EnumFontFamExProc (int /*long*/ lpelfe, int /*long*/ lpntme, int /*long*/ FontType, int /*long*/ lParam) {", "-//\t\t\t\t\tif (FontType == OS.RASTER_FONTTYPE) return 1;", "-//\t\t\t\t\tOS.MoveMemory(newLogFont, lpelfe, LOGFONT.sizeof);", "-//\t\t\t\t\tnewLogFont.lfHeight = logFont.lfHeight;", "-//\t\t\t\t\tnewLogFont.lfWeight = logFont.lfWeight;", "-//\t\t\t\t\tnewLogFont.lfItalic = logFont.lfItalic;", "-//\t\t\t\t\tnewLogFont.lfWidth = logFont.lfWidth;", "-//\t\t\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(newLogFont);", "-//\t\t\t\t\tOS.SelectObject(hdc, newFont);", "-//\t\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs, useCMap)) {", "-//\t\t\t\t\t\trun.fallbackFont = newFont;", "-//\t\t\t\t\t\tLOGFONT cacheLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-//\t\t\t\t\t\tOS.MoveMemory(cacheLogFont, lpelfe, LOGFONT.sizeof);", "-//\t\t\t\t\t\tdevice.logFontsCache[script] = cacheLogFont;", "-//\t\t\t\t\t\tSystem.out.println(script + \" ENUM \" + Font.win32_new(device, run.fallbackFont).getFontData()[0]);", "-//\t\t\t\t\t\treturn 0;", "-//\t\t\t\t\t}", "-//\t\t\t\t\tOS.SelectObject(hdc, hFont);", "-//\t\t\t\t\tOS.DeleteObject(newFont);", "-//\t\t\t\t\treturn 1;", "-//\t\t\t\t}", "-//\t\t\t};", "-//\t\t\tEnumFontFamEx object = new EnumFontFamEx();", "-//\t\t\t/* Avoid compiler warnings */", "-//\t\t\tif (false) object.EnumFontFamExProc(0, 0, 0, 0);", "-//\t\t\tCallback callback = new Callback(object, \"EnumFontFamExProc\", 4);", "-//\t\t\tint /*long*/ address = callback.getAddress();", "-//\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "-//\t\t\tint charSet = sp.fAmbiguousCharSet ? OS.DEFAULT_CHARSET : sp.bCharSet;", "-//\t\t\tnewLogFont.lfCharSet = (byte)charSet;", "-//\t\t\tOS.EnumFontFamiliesEx(hdc, newLogFont, address, 0, 0);", "-//\t\t\tcallback.dispose();", "-//\t\t\tshapeSucceed = run.fallbackFont != 0;", "-//\t\t}", "-//\t}", "-\t", "-\t\tSystem.out.println(\"NONE \" + script);"]}], "num": 27159}