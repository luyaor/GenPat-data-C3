{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ecf5c22fcd39fae69b9c157068755f2d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7159a8fdb72b212444245e3c5cc85a19", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/FontDialog.java", "commitBeforeChange": "25e0b9cefcf6aad913e775e22fb19b1e3de2a216", "commitAfterChange": "abdb7df6c5ef7f31dd770f626e22ad0d039e1629", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  int fontProc (int nextHandler, int theEvent, int userData)", "signatureAfterChange": "  int fontProc (int nextHandler, int theEvent, int userData)", "diff": ["-\t\t\tif (fontData == null) fontData = new FontData();", "-\t\t\t\tint [] actualLength = new int [1];", "-\t\t\t\tint platformCode = OS.kFontUnicodePlatform, encoding = OS.kCFStringEncodingUnicode;", "-\t\t\t\tif (OS.ATSUFindFontName (fontID [0], OS.kFontFamilyName, platformCode, OS.kFontNoScriptCode, OS.kFontNoLanguageCode, 0, null, actualLength, null) != OS.noErr) {", "-\t\t\t\t\tplatformCode = OS.kFontNoPlatformCode;", "-\t\t\t\t\tencoding = OS.kCFStringEncodingMacRoman;", "-\t\t\t\t\tOS.ATSUFindFontName (fontID [0], OS.kFontFamilyName, platformCode, OS.kFontNoScriptCode, OS.kFontNoLanguageCode, 0, null, actualLength, null);", "-\t\t\t\t}\t", "-\t\t\t\tbyte[] buffer = new byte[actualLength[0]];", "-\t\t\t\tOS.ATSUFindFontName (fontID [0], OS.kFontFamilyName, platformCode, OS.kFontNoScriptCode, OS.kFontNoLanguageCode, buffer.length, buffer, actualLength, null);", "-\t\t\t\tString name = \"\";", "-\t\t\t\tint ptr = OS.CFStringCreateWithBytes (0, buffer, buffer.length, encoding, false);", "-\t\t\t\tif (ptr != 0) {", "-\t\t\t\t\tint length = OS.CFStringGetLength (ptr);", "-\t\t\t\t\tif (length != 0) {", "-\t\t\t\t\t\tchar[] chars = new char [length];", "-\t\t\t\t\t\tCFRange range = new CFRange ();", "-\t\t\t\t\t\trange.length = length;", "-\t\t\t\t\t\tOS.CFStringGetCharacters (ptr, range, chars);", "-\t\t\t\t\t\tname = new String (chars);", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.CFRelease (ptr);", "-\t\t\t\t}", "-\t\t\t\tfontData.setName (name);", "+\t\t\t\tthis.fontID = fontID [0];", "-\t\t\tshort [] fontStyle = new short [1];", "-\t\t\tif (OS.GetEventParameter (theEvent, OS.kEventParamFMFontStyle, OS.typeSInt16, null, 2, null, fontStyle) == OS.noErr) {", "-\t\t\t\tint style = SWT.NORMAL;", "-\t\t\t\tif ((fontStyle [0] & OS.bold) != 0) style |= SWT.BOLD;", "-\t\t\t\tif ((fontStyle [0] & OS.italic) != 0) style |= SWT.ITALIC;", "-\t\t\t\tfontData.setStyle (style);", "+\t\t\tint [] fontSize = new int [1];", "+\t\t\tif (OS.GetEventParameter (theEvent, OS.kEventParamATSUFontSize, OS.typeFixed, null, 4, null, fontSize) == OS.noErr) {", "+\t\t\t\tthis.fontSize = fontSize [0];", "-\t\t\tshort [] fontSize = new short [1];", "-\t\t\tif (OS.GetEventParameter (theEvent, OS.kEventParamFMFontSize, OS.typeSInt16, null, 2, null, fontSize) == OS.noErr) {", "-\t\t\t\tfontData.setHeight (fontSize [0]);", "-\t\t\t}", "-\t\t\t// NEEDS WORK - color not supported in native dialog for Carbon", "-\t\t\t\trgb = new RGB(red, green, blue);", "+\t\t\t\trgb = new RGB (red, green, blue);", "+\t\t\t} else {", "+\t\t\t\tint [] dict = new int [1];", "+\t\t\t\tif (OS.GetEventParameter (theEvent, OS.kEventParamDictionary, OS.typeCFDictionaryRef, null, 4, actualSize, dict) == OS.noErr) {", "+\t\t\t\t\tint [] attrib = new int [1];", "+\t\t\t\t\tif (OS.CFDictionaryGetValueIfPresent (dict [0], OS.kFontPanelAttributesKey (), attrib)) {", "+\t\t\t\t\t\tint [] tags = new int [1];", "+\t\t\t\t\t\tint [] sizes = new int [1];", "+\t\t\t\t\t\tint [] values = new int [1];", "+\t\t\t\t\t\tif (OS.CFDictionaryGetValueIfPresent (attrib [0], OS.kFontPanelAttributeTagsKey (), tags) &&", "+\t\t\t\t\t\t\tOS.CFDictionaryGetValueIfPresent (attrib [0], OS.kFontPanelAttributeSizesKey (), sizes) &&", "+\t\t\t\t\t\t\tOS.CFDictionaryGetValueIfPresent (attrib [0], OS.kFontPanelAttributeValuesKey (), values)", "+\t\t\t\t\t\t) {", "+\t\t\t\t\t\t\tint count = OS.CFDataGetLength (tags [0]) / 4;", "+\t\t\t\t\t\t\tint tagPtr = OS.CFDataGetBytePtr (tags[0]);", "+                            int sizePtr = OS.CFDataGetBytePtr (sizes [0]);", "+                            int [] tag = new int [1];", "+                            int [] size = new int [1];", "+                            int valueOffset = 0;", "+                            for (int i = 0 ; i < count ; i++) {", "+                            \tOS.memcpy (tag, tagPtr + (i * 4), 4);", "+                            \tOS.memcpy (size, sizePtr + (i * 4), 4);", "+                                if (tag [0] == OS.kATSUColorTag && size[0] == RGBColor.sizeof) {", "+                                    int valuePtr = OS.CFDataGetBytePtr (values [0]);", "+                                \tOS.memcpy (color, valuePtr + valueOffset, RGBColor.sizeof);", "+                                \tint red = (color.red >> 8) & 0xFF;", "+                    \t\t\t\tint green = (color.green >> 8) & 0xFF;", "+                    \t\t\t\tint blue =\t(color.blue >> 8) & 0xFF;", "+                    \t\t\t\trgb = new RGB (red, green, blue);", "+                                    break ;", "+                                }", "+                                valueOffset = size[0];", "+                            }", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1fccb9add808188055e33040393707fc", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 10, "signatureBeforeChange": " void drawImage(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)", "signatureAfterChange": "  void drawImage(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)", "diff": ["-void drawImage(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple) {", "-\tMacRect bounds= new MacRect();", "-\tOS.GetPixBounds(srcImage.pixmap, bounds.getData());", "- \tint imgWidth = bounds.getWidth();", "- \tint imgHeight = bounds.getHeight();", "+void drawImage(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple) {", "+ \tint imageHandle = srcImage.handle;", "+ \tint imgWidth = OS.CGImageGetWidth(imageHandle);", "+ \tint imgHeight = OS.CGImageGetHeight(imageHandle);", "+ \t\tsimple = srcX == 0 && srcY == 0 &&", "+ \t\t\tsrcWidth == destWidth && destWidth == imgWidth &&", "+ \t\t\tsrcHeight == destHeight && destHeight == imgHeight;", "-", "-\tif (srcImage.alpha == 0)\t// fully transparent", "-\t\treturn;", "-", "-\tif (srcImage.pixmap == 0)", "-\t\treturn;", "-\tint srcBits= OS.DerefHandle(srcImage.pixmap);", "-\tif (srcBits == 0)", "-\t\treturn;", "-\tint destBits= OS.GetPortBitMapForCopyBits(handle);", "-\tif (destBits == 0)", "-\t\treturn;", "-", "- \ttry {", "-\t\tif (focus(true, null)) {", "-\t", "-\t\t\tMacRect ib= new MacRect(srcX, srcY, srcWidth, srcHeight);", "-\t\t\tfRect.set(destX, destY, destWidth, destHeight);", "-\t\t", "-\t\t\tOS.RGBBackColor((short)0xFFFF, (short)0xFFFF, (short)0xFFFF);", "-\t\t\tOS.RGBForeColor((short)0x0000, (short)0x0000, (short)0x0000);", "-", "-\t\t\tif (srcImage.alpha != -1 || srcImage.alphaData != null) {", "-\t\t\t\t", "-\t\t\t\tif (srcImage.alpha == 255) {\t// fully opaque", "-\t\t\t\t\tOS.CopyBits(srcBits, destBits, ib.getData(), fRect.getData(), (short)0, 0);", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\t//OS.CopyDeepMask(srcBits, maskBits, destBits, ib.getData(), ib.getData(), fRect.getData(), (short)0, 0);", "-\t\t\t\tSystem.out.println(\"GC.drawImage: alpha drawing not nyi\");", "-", "-\t\t\t} else if (srcImage.transparentPixel != -1 || srcImage.mask != 0) {", "-\t\t\t\t/* Generate the mask if necessary. */", "-\t\t\t\tif (srcImage.transparentPixel != -1) srcImage.createMask();", "-\t", "-\t\t\t\tint maskBits= srcImage.mask != 0 ? OS.DerefHandle(srcImage.mask) : 0;", "-\t\t\t\tif (maskBits != 0)", "-\t\t\t\t\tOS.CopyMask(srcBits, maskBits, destBits, ib.getData(), ib.getData(), fRect.getData());", "-", "-\t\t\t\t/* Destroy the image mask if there is a GC created on the image */", "-\t\t\t\tif (srcImage.transparentPixel != -1 && srcImage.memGC != null) srcImage.destroyMask();", "-", "-\t\t\t} else {", "-\t\t\t\tOS.CopyBits(srcBits, destBits, ib.getData(), fRect.getData(), (short)0, 0);", "-\t\t\t}", "-\t\t}", "-\t} finally {", "-\t\tunfocus(true);", "-\t}", "+ \tOS.CGContextSaveGState(handle);", "+ \tOS.CGContextScaleCTM(handle, 1, -1);", "+ \tOS.CGContextTranslateCTM(handle, 0, -(destHeight + 2 * destY));", "+ \tCGRect rect = new CGRect();", "+ \trect.x = destX;", "+ \trect.y = destY;", "+ \trect.width = destWidth;", "+\trect.height = destHeight;", "+ \tif (simple) {", "+ \t\tOS.CGContextDrawImage(handle, rect, imageHandle);", "+ \t} else {", "+\t \tint width = OS.CGImageGetWidth(imageHandle);", "+\t\tint height = OS.CGImageGetHeight(imageHandle);", "+\t\tint bpc = OS.CGImageGetBitsPerComponent(imageHandle);", "+\t\tint bpp = OS.CGImageGetBitsPerPixel(imageHandle);", "+\t\tint bpr = OS.CGImageGetBytesPerRow(imageHandle);", "+\t\tint colorspace = OS.CGImageGetColorSpace(imageHandle);", "+\t\tint alphaInfo = OS.CGImageGetAlphaInfo(imageHandle);", "+\t\tint data = srcImage.data + (srcY * bpr) + srcX * 4;", "+\t\tint provider = OS.CGDataProviderCreateWithData(0, data, srcHeight * bpr, 0);", "+\t\tif (provider == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\tint subImage = OS.CGImageCreate(srcWidth, srcHeight, bpc, bpp, bpr, colorspace, alphaInfo, provider, null, false, 0);", "+\t\tOS.CGDataProviderRelease(provider);", "+\t\tif (subImage == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+ \t\tOS.CGContextDrawImage(handle, rect, subImage);", "+ \t\tOS.CGImageRelease(subImage);", "+ \t}", "+ \tOS.CGContextRestoreGState(handle);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7b8def17ab1020f0e6fc71b96dc7bc40", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "c434902e868dc31f4d87acdb50f51cbdb8752d24", "commitAfterChange": "046e0d0bfd6bae07f076caade40f57f2f865587f", "methodNumberBeforeChange": 66, "methodNumberAfterChange": 65, "signatureBeforeChange": " void shape (final int hdc, final StyleItem run)", "signatureAfterChange": " void shape (final int hdc, final StyleItem run)", "diff": ["-\t", "-\t\tboolean useGDI = !sp.fComplex;", "-\t\t/*", "-\t\t* Bug in Windows.  There are non-complex scripts that are", "-\t\t* not supported by GDI. The fix is to detect these scripts", "-\t\t* by checking the Unicode ranges and use Uniscribe instead.", "-\t\t*   ", "-\t\t* These are the scripts: ", "-\t\t* \t0x0530..0x058F is Armenian", "-\t\t*   0x10A0..0x10FF is Georgian", "-\t\t*   0xA000..0xA4CF is Yi", "-\t\t*/", "-\t\tchar c = chars[0];", "-\t\tif (0x0530 <= c && c <= 0x058F || 0x10A0 <= c && c <= 0x10FF || 0xA000 <= c && c <= 0xA4CF) {", "-\t\t\tuseGDI = false;", "+\t\tint /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "+\t\tint /*long*/ ssa = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, OS.SCRIPT_STRING_ANALYSIS_sizeof());", "+\t\tint /*long*/ metaFileDc = OS.CreateEnhMetaFile(hdc, null, null, null);", "+\t\tint /*long*/ oldMetaFont = OS.SelectObject(metaFileDc, hFont);", "+\t\tint flags = OS.SSA_METAFILE | OS.SSA_FALLBACK | OS.SSA_GLYPHS | OS.SSA_LINK;", "+\t\tif (OS.ScriptStringAnalyse(metaFileDc, chars, chars.length, 0, -1, flags, 0, null, null, 0, 0, 0, ssa) == OS.S_OK) {", "+\t\t\tOS.ScriptStringOut(ssa, 0, 0, 0, null, 0, 0, false);", "+\t\t\tOS.ScriptStringFree(ssa);", "-\t\tif (useGDI) {", "-\t\t\tint /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "-\t\t\tLOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "-\t\t\tLOGFONT systemLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\tOS.GetObject(device.systemFont.handle, LOGFONT.sizeof, systemLogFont);", "-\t\t\tsystemLogFont.lfHeight = logFont.lfHeight;", "-\t\t\tsystemLogFont.lfWeight = logFont.lfWeight;", "-\t\t\tsystemLogFont.lfItalic = logFont.lfItalic;", "-\t\t\tsystemLogFont.lfWidth = logFont.lfWidth;", "-\t\t\tint /*long*/ newFont = OS.CreateFontIndirect (systemLogFont);", "-\t\t\tOS.SelectObject(hdc, newFont);", "-\t\t\trun.analysis.fNoGlyphIndex = true;", "-\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-\t\t\tif (shapeSucceed) {", "-\t\t\t\trun.fallbackFont = newFont;", "-\t\t\t} else {", "-\t\t\t\tOS.SelectObject(hdc, hFont);", "-\t\t\t\tOS.DeleteObject(newFont);", "-\t\t\t\trun.analysis.fNoGlyphIndex = false;", "-\t\t\t}", "-\t\t}", "-\t}", "-\t", "-\tif (!shapeSucceed) {", "-\t\t/*", "-\t\t* Shape Failed.", "-\t\t* Try to use MLANG to find a suitable font to shape the run.  ", "-\t\t*/", "-\t\tif (mLangFontLink2 != 0) {", "-\t\t\tint[] dwCodePages = new int[1];", "-\t\t\tint[] cchCodePages = new int[1];", "-\t\t\t/* GetStrCodePages() */", "-\t\t\tOS.VtblCall(4, mLangFontLink2, chars, chars.length, 0, dwCodePages, cchCodePages);", "-\t\t\tint /*long*/[] hNewFont = new int /*long*/[1];", "-\t\t\t/* MapFont() */", "-\t\t\tif (OS.VtblCall(10, mLangFontLink2, hdc, dwCodePages[0], chars[0], hNewFont) == OS.S_OK) {", "-\t\t\t\tint /*long*/ hFont = OS.SelectObject(hdc, hNewFont[0]);", "-\t\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-\t\t\t\tif (shapeSucceed) {", "-\t\t\t\t\trun.fallbackFont = hNewFont[0];", "-\t\t\t\t\trun.mlang = true;", "-\t\t\t\t} else {", "-\t\t\t\t\t/* ReleaseFont() */", "-\t\t\t\t\tOS.VtblCall(8, mLangFontLink2, hNewFont[0]);", "-\t\t\t\t\tOS.SelectObject(hdc, hFont);", "+\t\tOS.HeapFree(hHeap, 0, ssa);", "+\t\tOS.SelectObject(metaFileDc, oldMetaFont);", "+\t\tint /*long*/ metaFile = OS.CloseEnhMetaFile(metaFileDc);", "+\t\tfinal EMREXTCREATEFONTINDIRECTW emr = new EMREXTCREATEFONTINDIRECTW();", "+\t\tclass MetaFileEnumProc {", "+\t\t\tint /*long*/ metaFileEnumProc (int /*long*/ hDC, int /*long*/ table, int /*long*/ record, int /*long*/ nObj, int /*long*/ lpData) {", "+\t\t\t\tOS.MoveMemory(emr.emr, record, EMR.sizeof);", "+\t\t\t\tswitch (emr.emr.iType) {", "+\t\t\t\t\tcase OS.EMR_EXTCREATEFONTINDIRECTW:", "+\t\t\t\t\t\tOS.MoveMemory(emr, record, EMREXTCREATEFONTINDIRECTW.sizeof);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase OS.EMR_EXTTEXTOUTW:", "+\t\t\t\t\t\treturn 0;", "+\t\t\t\treturn 1;", "+\t\t};", "+\t\tMetaFileEnumProc object = new MetaFileEnumProc();", "+\t\t/* Avoid compiler warnings */", "+\t\tif (false) object.metaFileEnumProc(0, 0, 0, 0, 0);", "+\t\tCallback callback = new Callback(object, \"metaFileEnumProc\", 5);", "+\t\tint /*long*/ address = callback.getAddress();", "+\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "+\t\tOS.EnumEnhMetaFile(0, metaFile, address, 0, null);", "+\t\tOS.DeleteEnhMetaFile(metaFile);", "+\t\tcallback.dispose();", "+", "+\t\tint /*long*/ newFont = OS.CreateFontIndirectW(emr.elfw.elfLogFont);", "+\t\tOS.SelectObject(hdc, newFont);", "+\t\tif (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {", "+\t\t\trun.fallbackFont = newFont;", "-\t}", "-\t", "-\tif (!shapeSucceed) {", "-\t\t/*", "-\t\t* Shape Failed.", "-\t\t* Try to shape the run using the LOGFONT in the cache.", "-\t\t*/", "-\t\tfinal int /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "-\t\tfinal LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "-\t\t", "-\t\tLOGFONT cachedLogFont = device.logFontsCache != null ? device.logFontsCache[script] : null;", "-\t\tif (cachedLogFont != null) {", "-\t\t\tcachedLogFont.lfHeight = logFont.lfHeight;", "-\t\t\tcachedLogFont.lfWeight = logFont.lfWeight;", "-\t\t\tcachedLogFont.lfItalic = logFont.lfItalic;", "-\t\t\tcachedLogFont.lfWidth = logFont.lfWidth;", "-\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(cachedLogFont);", "-\t\t\tOS.SelectObject(hdc, newFont);", "-\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-\t\t\tif (shapeSucceed) {", "-\t\t\t\trun.fallbackFont = newFont;", "-\t\t\t} else {", "-\t\t\t\tOS.SelectObject(hdc, hFont);", "-\t\t\t\tOS.DeleteObject(newFont);", "+\t\tif (!shapeSucceed) {", "+\t\t\tif (!sp.fComplex) {", "+\t\t\t\trun.analysis.fNoGlyphIndex = true;", "+\t\t\t\tif (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {", "+\t\t\t\t\trun.fallbackFont = newFont;", "+\t\t\t\t} else {", "+\t\t\t\t\trun.analysis.fNoGlyphIndex = false;", "+\t\t\t\t}", "-\t\t\t/*", "-\t\t\t* Shape Failed.", "-\t\t\t* Use EnumFontFamExProc to iterate over every font in the system that supports ", "-\t\t\t* the charset of the run and try to shape it.  ", "-\t\t\t*/", "-\t\t\tif (device.logFontsCache == null) device.logFontsCache = new LOGFONT[device.scripts.length];", "-\t\t\tfinal LOGFONT newLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\tclass EnumFontFamEx {", "-\t\t\t\tint /*long*/ EnumFontFamExProc (int /*long*/ lpelfe, int /*long*/ lpntme, int /*long*/ FontType, int /*long*/ lParam) {", "-\t\t\t\t\tif (FontType == OS.RASTER_FONTTYPE) return 1;", "-\t\t\t\t\tOS.MoveMemory(newLogFont, lpelfe, LOGFONT.sizeof);", "-\t\t\t\t\tnewLogFont.lfHeight = logFont.lfHeight;", "-\t\t\t\t\tnewLogFont.lfWeight = logFont.lfWeight;", "-\t\t\t\t\tnewLogFont.lfItalic = logFont.lfItalic;", "-\t\t\t\t\tnewLogFont.lfWidth = logFont.lfWidth;", "-\t\t\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(newLogFont);", "-\t\t\t\t\tOS.SelectObject(hdc, newFont);", "-\t\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs, sp)) {", "-\t\t\t\t\t\trun.fallbackFont = newFont;", "-\t\t\t\t\t\tLOGFONT cacheLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\t\t\t\tOS.MoveMemory(cacheLogFont, lpelfe, LOGFONT.sizeof);", "-\t\t\t\t\t\tdevice.logFontsCache[script] = cacheLogFont;", "-\t\t\t\t\t\treturn 0;", "+\t\t\tif (mLangFontLink2 != 0) {", "+\t\t\t\tint /*long*/[] hNewFont = new int /*long*/[1];", "+\t\t\t\tint[] dwCodePages = new int[1], cchCodePages = new int[1];", "+\t\t\t\t/* GetStrCodePages() */", "+\t\t\t\tOS.VtblCall(4, mLangFontLink2, chars, chars.length, 0, dwCodePages, cchCodePages);", "+\t\t\t\t/* MapFont() */", "+\t\t\t\tif (OS.VtblCall(10, mLangFontLink2, hdc, dwCodePages[0], chars[0], hNewFont) == OS.S_OK) {", "+\t\t\t\t\tLOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\t\t\tOS.GetObject(hNewFont[0], LOGFONT.sizeof, logFont);", "+\t\t\t\t\t/* ReleaseFont() */", "+\t\t\t\t\tOS.VtblCall(8, mLangFontLink2, hNewFont[0]);", "+\t\t\t\t\tint /*long*/ mLangFont = OS.CreateFontIndirect(logFont);", "+\t\t\t\t\tint /*long*/ oldFont = OS.SelectObject(hdc, mLangFont);", "+\t\t\t\t\tif (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {", "+\t\t\t\t\t\trun.fallbackFont = mLangFont;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tOS.SelectObject(hdc, oldFont);", "+\t\t\t\t\t\tOS.DeleteObject(mLangFont);", "-\t\t\t\t\tOS.SelectObject(hdc, hFont);", "-\t\t\t\t\tOS.DeleteObject(newFont);", "-\t\t\t\t\treturn 1;", "-\t\t\t};", "-\t\t\tEnumFontFamEx object = new EnumFontFamEx();", "-\t\t\t/* Avoid compiler warnings */", "-\t\t\tif (false) object.EnumFontFamExProc(0, 0, 0, 0);", "-\t\t\tCallback callback = new Callback(object, \"EnumFontFamExProc\", 4);", "-\t\t\tint /*long*/ address = callback.getAddress();", "-\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "-\t\t\tint charSet = sp.fAmbiguousCharSet ? OS.DEFAULT_CHARSET : sp.bCharSet;", "-\t\t\tnewLogFont.lfCharSet = (byte)charSet;", "-\t\t\tOS.EnumFontFamiliesEx(hdc, newLogFont, address, 0, 0);", "-\t\t\tcallback.dispose();", "-\t\t\tshapeSucceed = run.fallbackFont != 0;", "+\t\t\t}", "+\t\tif (!shapeSucceed) OS.SelectObject(hdc, hFont);", "+\t\tif (newFont != run.fallbackFont) OS.DeleteObject(newFont);"]}], "num": 39845}