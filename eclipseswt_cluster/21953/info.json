{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1946c0e0dd74eef6ddd8b46c60716a7d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9a99fc6c509eec2b19a845b3c0973099", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "3f8101474c4f9d64a69b780f9a29957977994c1c", "commitAfterChange": "ec9593cc82c5a72b6479eac5f3bdaf617409cb43", "methodNumberBeforeChange": 146, "methodNumberAfterChange": 148, "signatureBeforeChange": "  LRESULT wmNotify (NMHDR hdr, int wParam, int lParam)", "signatureAfterChange": "  LRESULT wmNotify (NMHDR hdr, int wParam, int lParam)", "diff": ["+\tint /*long*/ hwndToolTip = OS.SendMessage (handle, OS.LVM_GETTOOLTIPS, 0, 0);", "+\tif (hdr.hwndFrom == hwndToolTip) {", "+\t\tLRESULT result = wmNotifyToolTip (hdr, wParam, lParam);", "+\t\tif (result != null) return result;", "+\t}", "-\t\t/*", "-\t\t* Feature in Windows.  On NT, the automatically created", "-\t\t* header control is created as a UNICODE window, not an", "-\t\t* ANSI window despite the fact that the parent is created", "-\t\t* as an ANSI window.  This means that it sends UNICODE", "-\t\t* notification messages to the parent window on NT for", "-\t\t* no good reason.  The data and size in the NMHEADER and", "-\t\t* HDITEM structs is identical between the platforms so no", "-\t\t* different message is actually necessary.  Despite this,", "-\t\t* Windows sends different messages.  The fix is to look", "-\t\t* for both messages, despite the platform.  This works", "-\t\t* because only one will be sent on either platform, never", "-\t\t* both.", "-\t\t*/", "-\t\tswitch (hdr.code) {", "-\t\t\tcase OS.HDN_BEGINTRACKW:", "-\t\t\tcase OS.HDN_BEGINTRACKA:", "-\t\t\tcase OS.HDN_DIVIDERDBLCLICKW:", "-\t\t\tcase OS.HDN_DIVIDERDBLCLICKA: {", "-\t\t\t\tif (columnCount == 0) return LRESULT.ONE;", "-\t\t\t\tNMHEADER phdn = new NMHEADER ();", "-\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "-\t\t\t\tTableColumn column = columns [phdn.iItem];", "-\t\t\t\tif (column != null && !column.getResizable ()) {", "-\t\t\t\t\treturn LRESULT.ONE;", "-\t\t\t\t}", "-\t\t\t\tignoreColumnMove = true;", "-\t\t\t\tswitch (hdr.code) {", "-\t\t\t\t\tcase OS.HDN_DIVIDERDBLCLICKW:", "-\t\t\t\t\tcase OS.HDN_DIVIDERDBLCLICKA:", "-\t\t\t\t\t\t/*", "-\t\t\t\t\t\t* Bug in Windows.  When the first column of a table does not", "-\t\t\t\t\t\t* have an image and the user double clicks on the divider,", "-\t\t\t\t\t\t* Windows packs the column but does not take into account", "-\t\t\t\t\t\t* the empty space left for the image.  The fix is to measure", "-\t\t\t\t\t\t* each items ourselves rather than letting Windows do it.", "-\t\t\t\t\t\t*/", "-\t\t\t\t\t\tboolean fixPack = phdn.iItem == 0 && !firstColumnImage;", "-\t\t\t\t\t\tif (column != null && (fixPack || hooks (SWT.MeasureItem))) {", "-\t\t\t\t\t\t\tcolumn.pack ();", "-\t\t\t\t\t\t\treturn LRESULT.ONE;", "-\t\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcase OS.NM_RELEASEDCAPTURE: {", "-\t\t\t\tif (!ignoreColumnMove) {", "-\t\t\t\t\tfor (int i=0; i<columnCount; i++) {", "-\t\t\t\t\t\tTableColumn column = columns [i];", "-\t\t\t\t\t\tcolumn.updateToolTip (i);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tignoreColumnMove = false;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcase OS.HDN_BEGINDRAG: {", "-\t\t\t\tif (ignoreColumnMove) return LRESULT.ONE;", "-\t\t\t\tint bits = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);", "-\t\t\t\tif ((bits & OS.LVS_EX_HEADERDRAGDROP) == 0) break; ", "-\t\t\t\tif (columnCount == 0) return LRESULT.ONE;", "-\t\t\t\tNMHEADER phdn = new NMHEADER ();", "-\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "-\t\t\t\tif (phdn.iItem != -1) {", "-\t\t\t\t\tTableColumn column = columns [phdn.iItem];", "-\t\t\t\t\tif (column != null && !column.getMoveable ()) {", "-\t\t\t\t\t\tignoreColumnMove = true;", "-\t\t\t\t\t\treturn LRESULT.ONE;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcase OS.HDN_ENDDRAG: {", "-\t\t\t\tint bits = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);", "-\t\t\t\tif ((bits & OS.LVS_EX_HEADERDRAGDROP) == 0) break;", "-\t\t\t\tNMHEADER phdn = new NMHEADER ();", "-\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "-\t\t\t\tif (phdn.iItem != -1 && phdn.pitem != 0) {", "-\t\t\t\t\tHDITEM pitem = new HDITEM ();", "-\t\t\t\t\tOS.MoveMemory (pitem, phdn.pitem, HDITEM.sizeof);", "-\t\t\t\t\tif ((pitem.mask & OS.HDI_ORDER) != 0 && pitem.iOrder != -1) {", "-\t\t\t\t\t\tif (columnCount == 0) break;", "-\t\t\t\t\t\tint [] order = new int [columnCount];", "-\t\t\t\t\t\tOS.SendMessage (handle, OS.LVM_GETCOLUMNORDERARRAY, columnCount, order);", "-\t\t\t\t\t\tint index = 0;", "-\t\t\t\t\t\twhile (index < order.length) {", "-\t\t\t\t\t\t \tif (order [index] == phdn.iItem) break;", "-\t\t\t\t\t\t\tindex++;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (index == order.length) index = 0;", "-\t\t\t\t\t\tif (index == pitem.iOrder) break;", "-\t\t\t\t\t\tint start = Math.min (index, pitem.iOrder);", "-\t\t\t\t\t\tint end = Math.max (index, pitem.iOrder);", "-\t\t\t\t\t\tignoreColumnMove = false;", "-\t\t\t\t\t\tfor (int i=start; i<=end; i++) {", "-\t\t\t\t\t\t\tTableColumn column = columns [order [i]];", "-\t\t\t\t\t\t\tif (!column.isDisposed ()) {", "-\t\t\t\t\t\t\t\tcolumn.postEvent (SWT.Move);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcase OS.HDN_ITEMCHANGEDW:", "-\t\t\tcase OS.HDN_ITEMCHANGEDA: {", "-\t\t\t\t/*", "-\t\t\t\t* Bug in Windows.  When a table has the LVS_EX_GRIDLINES extended", "-\t\t\t\t* style and the user drags any column over the first column in the", "-\t\t\t\t* table, making the size become zero, when the user drags a column", "-\t\t\t\t* such that the size of the first column becomes non-zero, the grid", "-\t\t\t\t* lines are not redrawn.  The fix is to detect the case and force", "-\t\t\t\t* a redraw of the first column.", "-\t\t\t\t*/", "-\t\t\t\tint width = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETCOLUMNWIDTH, 0, 0);", "-\t\t\t\tif (lastWidth == 0 && width > 0) {", "-\t\t\t\t\tint bits = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);", "-\t\t\t\t\tif ((bits & OS.LVS_EX_GRIDLINES) != 0) {", "-\t\t\t\t\t\tRECT rect = new RECT ();", "-\t\t\t\t\t\tOS.GetClientRect (handle, rect);", "-\t\t\t\t\t\trect.right = rect.left + width;", "-\t\t\t\t\t\tOS.InvalidateRect (handle, rect, true);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tlastWidth = width;", "-\t\t\t\tif (!ignoreColumnResize) {", "-\t\t\t\t\tNMHEADER phdn = new NMHEADER ();", "-\t\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "-\t\t\t\t\tif (phdn.pitem != 0) {", "-\t\t\t\t\t\tHDITEM pitem = new HDITEM ();", "-\t\t\t\t\t\tOS.MoveMemory (pitem, phdn.pitem, HDITEM.sizeof);", "-\t\t\t\t\t\tif ((pitem.mask & OS.HDI_WIDTH) != 0) {", "-\t\t\t\t\t\t\tTableColumn column = columns [phdn.iItem];", "-\t\t\t\t\t\t\tif (column != null) {", "-\t\t\t\t\t\t\t\tcolumn.updateToolTip (phdn.iItem);", "-\t\t\t\t\t\t\t\tcolumn.sendEvent (SWT.Resize);", "-\t\t\t\t\t\t\t\tif (isDisposed ()) return LRESULT.ZERO;", "-\t\t\t\t\t\t\t\t/*", "-\t\t\t\t\t\t\t\t* It is possible (but unlikely), that application", "-\t\t\t\t\t\t\t\t* code could have disposed the column in the move", "-\t\t\t\t\t\t\t\t* event.  If this happens, process the move event", "-\t\t\t\t\t\t\t\t* for those columns that have not been destroyed.", "-\t\t\t\t\t\t\t\t*/", "-\t\t\t\t\t\t\t\tTableColumn [] newColumns = new TableColumn [columnCount];", "-\t\t\t\t\t\t\t\tSystem.arraycopy (columns, 0, newColumns, 0, columnCount);", "-\t\t\t\t\t\t\t\tint [] order = new int [columnCount];", "-\t\t\t\t\t\t\t\tOS.SendMessage (handle, OS.LVM_GETCOLUMNORDERARRAY, columnCount, order);", "-\t\t\t\t\t\t\t\tboolean moved = false;", "-\t\t\t\t\t\t\t\tfor (int i=0; i<columnCount; i++) {", "-\t\t\t\t\t\t\t\t\tTableColumn nextColumn = newColumns [order [i]];", "-\t\t\t\t\t\t\t\t\tif (moved && !nextColumn.isDisposed ()) {", "-\t\t\t\t\t\t\t\t\t\tnextColumn.updateToolTip (order [i]);", "-\t\t\t\t\t\t\t\t\t\tnextColumn.sendEvent (SWT.Move);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tif (nextColumn == column) moved = true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcase OS.HDN_ITEMDBLCLICKW:", "-\t\t\tcase OS.HDN_ITEMDBLCLICKA: {", "-\t\t\t\tNMHEADER phdn = new NMHEADER ();", "-\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "-\t\t\t\tTableColumn column = columns [phdn.iItem];", "-\t\t\t\tif (column != null) {", "-\t\t\t\t\tcolumn.postEvent (SWT.DefaultSelection);", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "+\t\tLRESULT result = wmNotifyHeader (hdr, wParam, lParam);", "+\t\tif (result != null) return result;", "-\tLRESULT result = super.wmNotify (hdr, wParam, lParam);", "-\tif (result != null) return result;", "-\tswitch (hdr.code) {", "-\t\tcase OS.TTN_GETDISPINFOA:", "-\t\tcase OS.TTN_GETDISPINFOW: {", "-\t\t\ttipRequested = true;", "-\t\t\tint /*long*/ code = callWindowProc (handle, OS.WM_NOTIFY, wParam, lParam);", "-\t\t\ttipRequested = false;", "-\t\t\treturn new LRESULT (code);", "-\t\t}", "-\t}", "-\treturn result;", "+\treturn super.wmNotify (hdr, wParam, lParam);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82bf84369b9c51467dd75a720c7cc49c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/Tree2.java", "commitBeforeChange": "ed568a606dfba062e77bacc7c7f799741b60cbf4", "commitAfterChange": "3e04f21595fe557524d009b946647c76885ec76f", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 49, "signatureBeforeChange": " void doMouseDown(Event event)", "signatureAfterChange": " void mouseDown(Event event)", "diff": ["-void doMouseDown(Event event) {", "-\tif (!isFocusControl()) setFocus();", "-\tint index = (event.y - getHeaderHeight()) / itemHeight + topIndex;", "-\tif (!(0 <= index && index < availableItems.length)) return;\t/* not on an available item */", "-\tTreeItem2 selectedItem = availableItems[index];", "-\t", "-\t/* if click was in expander box */", "-\tif (selectedItem.getItemCount() > 0 && selectedItem.getExpanderBounds().contains(event.x, event.y)) {", "-\t\tif (event.button != 1) return;", "-\t\tboolean expand = !selectedItem.getExpanded();", "-\t\tselectedItem.setExpanded(expand);", "-\t\tEvent newEvent = new Event();", "-\t\tnewEvent.item = selectedItem;", "-\t\tif (expand) {", "-\t\t\tinExpand = true;", "-\t\t\tsendEvent(SWT.Expand, newEvent);", "-\t\t\tinExpand = false;", "-\t\t\tif (isDisposed()) return;", "-\t\t\tif (selectedItem.getItemCount() == 0) {", "-\t\t\t\tselectedItem.expanded = false;", "-\t\t\t}", "-\t\t} else {", "-\t\t\tsendEvent(SWT.Collapse, newEvent);", "-\t\t}", "-\t\treturn;", "-\t}", "-\t/* if click was in checkbox */", "-\tif ((style & SWT.CHECK) != 0 && selectedItem.getCheckboxBounds().contains(event.x, event.y)) {", "-\t\tif (event.button != 1) return;", "-\t\tselectedItem.setChecked(!selectedItem.getChecked());", "-\t\tEvent newEvent = new Event();", "-\t\tnewEvent.item = selectedItem;", "-\t\tnewEvent.detail = SWT.CHECK;", "-\t\tsendEvent(SWT.Selection, newEvent);", "-\t\treturn;", "-\t}", "-\t", "-\tif (!selectedItem.getHitBounds().contains(event.x, event.y)) return;", "-\t", "-\tif ((event.stateMask & SWT.SHIFT) == 0 && event.keyCode != SWT.SHIFT) anchorItem = null;", "-\tif ((style & SWT.SINGLE) != 0) {", "-\t\tif (!selectedItem.isSelected()) {", "-\t\t\tif (event.button == 1) {", "-\t\t\t\tselectItem(selectedItem, false);", "-\t\t\t\tsetFocusItem(selectedItem, true);", "-\t\t\t\tredrawItem(selectedItem.availableIndex);", "-\t\t\t\tEvent newEvent = new Event();", "-\t\t\t\tnewEvent.item = selectedItem;", "-\t\t\t\tsendEvent(SWT.Selection, newEvent);", "-\t\t\t\treturn;", "-\t\t\tif ((event.stateMask & (SWT.CTRL | SWT.SHIFT)) == 0) {", "-\t\t\t\tselectItem(selectedItem, false);", "-\t\t\t\tsetFocusItem(selectedItem, true);", "-\t\t\t\tredrawItem(selectedItem.availableIndex);", "-\t\t\t\tEvent newEvent = new Event();", "-\t\t\t\tnewEvent.item = selectedItem;", "-\t\t\t\tsendEvent(SWT.Selection, newEvent);", "-\t\t\t\treturn;", "-\t\t}", "-\t\t/* item is selected */", "-\t\tif (event.button == 1) {", "-\t\t\t/* fire a selection event, though the selection did not change */", "-\t\t\tEvent newEvent = new Event();", "-\t\t\tnewEvent.item = selectedItem;", "-\t\t\tsendEvent(SWT.Selection, newEvent);", "-\t\t\treturn;", "-\t\t}", "-\t}", "-\t/* SWT.MULTI */", "-\tif (!selectedItem.isSelected()) {", "-\t\tif (event.button == 1) {", "-\t\t\tif ((event.stateMask & (SWT.CTRL | SWT.SHIFT)) == SWT.SHIFT) {", "-\t\t\t\tif (anchorItem == null) anchorItem = focusItem;", "-\t\t\t\tint anchorIndex = anchorItem.availableIndex;", "-\t\t\t\tint selectIndex = selectedItem.availableIndex;", "-\t\t\t\tTreeItem2[] newSelection = new TreeItem2 [Math.abs(anchorIndex - selectIndex) + 1];", "-\t\t\t\tint step = anchorIndex < selectIndex ? 1 : -1;", "-\t\t\t\tint writeIndex = 0;", "-\t\t\t\tfor (int i = anchorIndex; i != selectIndex; i += step) {", "-\t\t\t\t\tnewSelection[writeIndex++] = availableItems[i];", "-\t\t\t\t}", "-\t\t\t\tnewSelection[writeIndex] = availableItems[selectIndex];", "-\t\t\t\tsetSelection(newSelection);", "-\t\t\t\tsetFocusItem(selectedItem, true);", "-\t\t\t\tredrawItems(Math.min(anchorIndex, selectIndex), Math.max(anchorIndex, selectIndex));", "-\t\t\t\tEvent newEvent = new Event();", "-\t\t\t\tnewEvent.item = selectedItem;", "-\t\t\t\tsendEvent(SWT.Selection, newEvent);", "-\t\t\t\treturn;", "-\t\t\tselectItem(selectedItem, (event.stateMask & SWT.CTRL) != 0);", "-\t\t\tsetFocusItem(selectedItem, true);", "-\t\t\tredrawItem(selectedItem.availableIndex);", "-\t\t\tEvent newEvent = new Event();", "-\t\t\tnewEvent.item = selectedItem;", "-\t\t\tsendEvent(SWT.Selection, newEvent);", "-\t\t\treturn;", "-\t\t/* button 3 */", "-\t\tif ((event.stateMask & (SWT.CTRL | SWT.SHIFT)) == 0) {", "-\t\t\tselectItem(selectedItem, false);", "-\t\t\tsetFocusItem(selectedItem, true);", "-\t\t\tredrawItem(selectedItem.availableIndex);", "-\t\t\tEvent newEvent = new Event();", "-\t\t\tnewEvent.item = selectedItem;", "-\t\t\tsendEvent(SWT.Selection, newEvent);", "-\t\t\treturn;", "-\t\t}", "-\t}", "-\t/* item is selected */", "-\tif (event.button != 1) return;", "-\tif ((event.stateMask & SWT.CTRL) != 0) {", "-\t\tremoveSelectedItem(getSelectionIndex(selectedItem));", "-\t\tsetFocusItem(selectedItem, true);", "-\t\tredrawItem(selectedItem.availableIndex);", "-\t\tEvent newEvent = new Event();", "-\t\tnewEvent.item = selectedItem;", "-\t\tsendEvent(SWT.Selection, newEvent);", "-\t\treturn;", "-\t}", "-\tif ((event.stateMask & SWT.SHIFT) != 0) {", "-\t\tif (anchorItem == null) anchorItem = focusItem;", "-\t\tint anchorIndex = anchorItem.availableIndex;", "-\t\tint selectIndex = selectedItem.availableIndex;", "-\t\tTreeItem2[] newSelection = new TreeItem2 [Math.abs(anchorIndex - selectIndex) + 1];", "-\t\tint step = anchorIndex < selectIndex ? 1 : -1;", "-\t\tint writeIndex = 0;", "-\t\tfor (int i = anchorIndex; i != selectIndex; i += step) {", "-\t\t\tnewSelection[writeIndex++] = availableItems[i];", "-\t\t}", "-\t\tnewSelection[writeIndex] = availableItems[selectIndex];", "-\t\tsetSelection(newSelection);", "-\t\tsetFocusItem(selectedItem, true);", "-\t\tredrawItems(Math.min(anchorIndex, selectIndex), Math.max(anchorIndex, selectIndex));", "-\t\tEvent newEvent = new Event();", "-\t\tnewEvent.item = selectedItem;", "-\t\tsendEvent(SWT.Selection, newEvent);", "-\t\treturn;", "-\t}", "-\tselectItem(selectedItem, false);", "-\tsetFocusItem(selectedItem, true);", "-\tredrawItem(selectedItem.availableIndex);", "-\tEvent newEvent = new Event();", "-\tnewEvent.item = selectedItem;", "-\tsendEvent(SWT.Selection, newEvent);", "-}", "+ */", "+void mouseDown(Event event) {", "+\tint hitItemIndex;", "+\tTreeItem2 hitItem;", "+\tSelectableItem selectionItem = getLastSelection();", "+\tint itemAction;", "+", "+\thitItemIndex = event.y / getItemHeight();", "+\thitItem = getRoot().getVisibleItem(hitItemIndex + getTopIndex());", "+\tif (hitItem == null) {", "+\t\treturn;", "+\t}", "+\tif (!isFocusControl()) forceFocus();", "+\tswitch (itemAction = itemAction(hitItem, event.x, event.y)) {", "+\t\tcase ActionExpandCollapse:", "+\t\t\tif (event.button != 1) return;", "+\t\t\tif (hitItem.getExpanded() == true) {", "+\t\t\t\tcollapse(hitItem, true);", "+\t\t\t}", "+\t\t\telse {", "+\t\t\t\texpand(hitItem, true);", "+\t\tcase ActionSelect:", "+\t\t\tdoMouseSelect(hitItem, hitItemIndex + getTopIndex(), event.stateMask, event.button);", "+\t\t\tbreak;", "+\t\tcase ActionCheck:", "+\t\t\tif (event.button != 1) return;", "+\t\t\tdoCheckItem(hitItem);", "+\t\t\tbreak;", "+\t}", "+\tif (itemAction != ActionSelect && selectionItem == null) {", "+\t\tselectionItem = getRoot().getVisibleItem(getTopIndex());\t// select the top item if no item was selected before", "+\t\tselectNotify(selectionItem);\t\t\t\t\t\t\t\t"]}], "num": 21953}