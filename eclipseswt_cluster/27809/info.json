{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b5baebba5ff31659ec1a03a4435ecdda", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "51aae680da7be17e840c9bae898b2ade", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "cf8dd9a11f6c4a7e1a26b384bfc22781e8911949", "commitAfterChange": "d7590f51051fffa0427e416ff9c2ddc1de2b8802", "methodNumberBeforeChange": 67, "methodNumberAfterChange": 67, "signatureBeforeChange": " public Point stringExtent(String string)", "signatureAfterChange": " public Point stringExtent(String string)", "diff": ["-\tif (string.length () == 0) return new Point(0, getFontHeight());", "-\tbyte[] buffer = Converter.wcsToMbcs(getCodePage (), string, true);", "-\tint xmString = OS.XmStringCreate(buffer, OS.XmFONTLIST_DEFAULT_TAG);", "+\tif (data.stringWidth != -1) return new Point(data.stringWidth, data.stringHeight);", "+\tif (string.length () == 0) return new Point(data.stringWidth = 0, data.stringHeight = getFontHeight());", "+\tif (string != data.string) {", "+\t\tif (data.xmString != 0) OS.XmStringFree(data.xmString);", "+\t\tbyte [] buffer = Converter.wcsToMbcs (getCodePage (), string, true);", "+\t\tint xmString = OS.XmStringCreate (buffer, OS.XmFONTLIST_DEFAULT_TAG);", "+\t\tdata.string = string;", "+\t\tdata.xmString = xmString;", "+\t\tdata.stringWidth = data.stringHeight = -1;", "+\t}", "+\tint xmString = data.xmString;", "-\tOS.XmStringFree(xmString);", "-\treturn new Point(width, height);", "+\treturn new Point(data.stringWidth = width, data.stringHeight = height);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "01a7832f830022308e27468e8febe346", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT OpenGL/cocoa/org/eclipse/swt/opengl/GLCanvas.java", "commitBeforeChange": "510a9055a880b0149407b8b6f474eee88b6c1452", "commitAfterChange": "6d6e8bfdd21aebcd1012a6cbb789486aef5cbee8", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " public GLCanvas (Composite parent, int style, GLData data)", "signatureAfterChange": " public GLCanvas (Composite parent, int style, GLData data)", "diff": ["-\t//TODO use color options", "-//\tattrib [pos++] = OS.AGL_RGBA;", "+", "+\t", "-//\tif (data.redSize > 0) {", "-//\t\tattrib [pos++] = OS.AGL_RED_SIZE;", "-//\t\tattrib [pos++] = data.redSize;", "-//\t}", "-//\tif (data.greenSize > 0) {", "-//\t\tattrib [pos++] = OS.AGL_GREEN_SIZE;", "-//\t\tattrib [pos++] = data.greenSize;", "-//\t}", "-//\tif (data.blueSize > 0) {", "-//\t\tattrib [pos++] = OS.AGL_BLUE_SIZE;", "-//\t\tattrib [pos++] = data.blueSize;", "-//\t}", "+", "+\t/*", "+\t * Feature in Cocoa: NSOpenGL/CoreOpenGL only supports specifying the total number of bits", "+\t * in the size of the color component. If specified, the color size is the sum of the red, green", "+\t * and blue values in the GLData. ", "+\t */", "+\tif ((data.redSize + data.blueSize + data.greenSize) > 0) {", "+\t\tattrib [pos++] = OS.NSOpenGLPFAColorSize;", "+\t\tattrib [pos++] = data.redSize + data.greenSize + data.blueSize;", "+\t}", "+\t", "+\t", "+\t", "-//\tif (data.accumRedSize > 0) {", "-//\t\tattrib [pos++] = OS.AGL_ACCUM_RED_SIZE;", "-//\t\tattrib [pos++] = data.accumRedSize;", "-//\t}", "-//\tif (data.accumGreenSize > 0) {", "-//\t\tattrib [pos++] = OS.AGL_ACCUM_GREEN_SIZE;", "-//\t\tattrib [pos++] = data.accumGreenSize;", "-//\t}", "-//\tif (data.accumBlueSize > 0) {", "-//\t\tattrib [pos++] = OS.AGL_ACCUM_BLUE_SIZE;", "-//\t\tattrib [pos++] = data.accumBlueSize;", "-//\t}", "-//\tif (data.accumAlphaSize > 0) {", "-//\t\tattrib [pos++] = OS.AGL_ACCUM_ALPHA_SIZE;", "-//\t\tattrib [pos++] = data.accumAlphaSize;", "-//\t}", "+\t", "+\t/*", "+\t * Feature in Cocoa: NSOpenGL/CoreOpenGL only supports specifying the total number of bits", "+\t * in the size of the color accumulator component. If specified, the color size is the sum of the red, green,", "+\t * blue and alpha accum values in the GLData. ", "+\t */", "+\tif ((data.accumRedSize + data.accumBlueSize + data.accumGreenSize) > 0) {", "+\t\tattrib [pos++] = OS.NSOpenGLPFAAccumSize;", "+\t\tattrib [pos++] = data.accumRedSize + data.accumGreenSize + data.accumBlueSize + data.accumAlphaSize;", "+\t}", "+\t", "+\t", "+\t", "+\t", "+\t", "+\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c2125ea36b71e88079d803b8c037ba58", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "4b24af5ef710affbf05bf5fb1df78e69400546d5", "commitAfterChange": "fb6f593a0cdd1e265e0288d7b02a6f36c77f39f2", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " public Rectangle getClipping()", "signatureAfterChange": " public Rectangle getClipping()", "diff": ["-\tSystem.out.println(\"GC.getClipping: nyi\");", "-\treturn new Rectangle(0, 0, 100, 100);", "+\tMacRect bounds= new MacRect();", "+\tif (data.clipRgn == 0) {", "+\t\tif (data.controlHandle != 0) {", "+\t\t\tOS.GetControlBounds(data.controlHandle, bounds.getData());", "+\t\t\treturn new Rectangle(0, 0, bounds.getWidth(), bounds.getHeight());", "+\t\t}", "+\t\tif (data.image != null) {", "+\t\t\treturn data.image.getBounds();", "+\t\t}\t", "+\t\tSystem.out.println(\"GC.getClipping(): should not happen\");", "+\t\treturn new Rectangle(0, 0, 100, 100);", "+\t}", "+\tOS.GetRegionBounds(data.clipRgn, bounds.getData());", "+\treturn bounds.toRectangle();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "84f75a4c7355bfe9d4f803a7f2e5dd30", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "76b0d92e5a29445bd6714b97ad2de73ed0bf027c", "commitAfterChange": "266b760e1a4017fb0d522228c27d1d522d14e2a2", "methodNumberBeforeChange": 90, "methodNumberAfterChange": 94, "signatureBeforeChange": " public void setTransform(Transform transform)", "signatureAfterChange": " public void setTransform(Transform transform)", "diff": ["+\tif (data.forePattern != 0) {", "+\t\tOS.CGPatternRelease(data.forePattern);", "+\t\tdata.forePattern = data.foregroundPattern.createPattern(handle);", "+\t\tOS.CGContextSetStrokePattern(handle, data.forePattern, data.foreground);", "+\t}", "+\tif (data.backPattern != 0) {", "+\t\tOS.CGPatternRelease(data.backPattern);", "+\t\tdata.backPattern = data.backgroundPattern.createPattern(handle);", "+\t\tOS.CGContextSetFillPattern(handle, data.backPattern, data.background);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b7557b7f0a023bf109e42f4d00380ca", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "dfd4650fd75100a5a002cab81ff3277b16862845", "commitAfterChange": "d01fac9d213e0fa304edfed85d0f0844e9d59792", "methodNumberBeforeChange": 77, "methodNumberAfterChange": 77, "signatureBeforeChange": "  void initGdip(boolean draw, boolean fill)", "signatureAfterChange": "  void initGdip()", "diff": ["-void initGdip(boolean draw, boolean fill) {", "+void initGdip() {", "-\tif (gdipGraphics == 0) {", "-\t\t/*", "-\t\t* Feature in GDI+. The GDI+ clipping set with Graphics->SetClip()", "-\t\t* is always intersected with the GDI clipping at the time the", "-\t\t* GDI+ graphics is created.  This means that the clipping ", "-\t\t* cannot be reset.  The fix is to clear the clipping before", "-\t\t* the GDI+ graphics is created and reset it afterwards.", "-\t\t*/", "-\t\tint hRgn = OS.CreateRectRgn(0, 0, 0, 0);", "-\t\tint result = OS.GetClipRgn(handle, hRgn);", "-\t\tif (!OS.IsWinCE) {", "-\t\t\tPOINT pt = new POINT ();", "-\t\t\tOS.GetWindowOrgEx (handle, pt);", "-\t\t\tOS.OffsetRgn (hRgn, pt.x, pt.y);", "-\t\t}", "-\t\tOS.SelectClipRgn(handle, 0);", "-\t\tgdipGraphics = data.gdipGraphics = Gdip.Graphics_new(handle);", "-\t\tif (gdipGraphics == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\tGdip.Graphics_SetPageUnit(gdipGraphics, Gdip.UnitPixel);", "-\t\tGdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);", "-\t\tif (result == 1) setClipping(hRgn);", "-\t\tOS.DeleteObject(hRgn);", "+\tif (gdipGraphics != 0) return ;", "+\t/*", "+\t* Feature in GDI+. The GDI+ clipping set with Graphics->SetClip()", "+\t* is always intersected with the GDI clipping at the time the", "+\t* GDI+ graphics is created.  This means that the clipping ", "+\t* cannot be reset.  The fix is to clear the clipping before", "+\t* the GDI+ graphics is created and reset it afterwards.", "+\t*/", "+\tint hRgn = OS.CreateRectRgn(0, 0, 0, 0);", "+\tint result = OS.GetClipRgn(handle, hRgn);", "+\tif (!OS.IsWinCE) {", "+\t\tPOINT pt = new POINT ();", "+\t\tOS.GetWindowOrgEx (handle, pt);", "+\t\tOS.OffsetRgn (hRgn, pt.x, pt.y);", "-\tif (draw && data.gdipPen == 0) data.gdipPen = createGdipPen();", "-\tif (fill && data.gdipBrush == 0) data.gdipBrush = createGdipBrush();", "+\tOS.SelectClipRgn(handle, 0);", "+\tgdipGraphics = data.gdipGraphics = Gdip.Graphics_new(handle);", "+\tif (gdipGraphics == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\tGdip.Graphics_SetPageUnit(gdipGraphics, Gdip.UnitPixel);", "+\tGdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);", "+\tif (result == 1) setClipping(hRgn);", "+\tOS.DeleteObject(hRgn);\t\t", "+\tdata.state = 0;", "+\tif (data.hPen != 0) {", "+\t\tOS.SelectObject(handle, OS.GetStockObject(OS.NULL_PEN));", "+\t\tOS.DeleteObject(data.hPen);", "+\t\tdata.hPen = 0;", "+\t}", "+\tif (data.hBrush != 0) {", "+\t\tOS.SelectObject(handle, OS.GetStockObject(OS.NULL_BRUSH));", "+\t\tOS.DeleteObject(data.hBrush);", "+\t\tdata.hBrush = 0;", "+\t}"]}], "num": 27809}