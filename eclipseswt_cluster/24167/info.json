{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bf94ae2e6dc62e28c7624d0eb78ad6b8", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7ba7273db601f5f6693788c03ce6913", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Drag and Drop/gtk/org/eclipse/swt/dnd/ClipboardProxy.java", "commitBeforeChange": "0edaa156d7779c77c3eb098c1e4b0c67cdbdcf8d", "commitAfterChange": "62b017130fe8f33aca4d9e0e198193b3e6f15f0a", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  boolean setData(Clipboard owner, Object[] data, Transfer[] dataTypes, int clipboards)", "signatureAfterChange": "  boolean setData(Clipboard owner, Object[] data, Transfer[] dataTypes, int clipboards)", "diff": ["+\t\t\tif (activeClipboard != null) OS.gtk_clipboard_clear(Clipboard.GTKCLIPBOARD);", "-\t\t\tif (activeClipboard != null) {", "-\t\t\t\t/*", "-\t\t\t\t* Feature in GTK. When the contents are set again, clipboard_set_with_data() ", "-\t\t\t\t* invokes clearFunc and then, getFunc is not sequentially called. ", "-\t\t\t\t* If we clear the content before calling set_with_data(), then there is a fair ", "-\t\t\t\t* chance for other apps like Klipper to claim the ownership of the clipboard.", "-\t\t\t\t* The fix is to make sure that the content is not cleared before the data is", "-\t\t\t\t* set again. GTK does not invoke clearFunc for clipboard_set_with_owner()", "-\t\t\t\t* though we set the data again. So, this API has to be used whenever we", "-\t\t\t\t* are setting the contents again.", "-\t\t\t\t*/", "-\t\t\t\tif (!OS.gtk_clipboard_set_with_owner(Clipboard.GTKCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, clipboardOwner)) {", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tif (!OS.gtk_clipboard_set_with_data(Clipboard.GTKCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, 0)) {", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "+\t\t\tif (!OS.gtk_clipboard_set_with_data(Clipboard.GTKCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, 0)) {", "+\t\t\t\treturn false;", "+\t\t\tif (activePrimaryClipboard != null) OS.gtk_clipboard_clear(Clipboard.GTKPRIMARYCLIPBOARD);", "-\t\t\tif (activePrimaryClipboard != null) {", "-\t\t\t\tif (!OS.gtk_clipboard_set_with_owner(Clipboard.GTKPRIMARYCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, clipboardOwner)) {", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tif (!OS.gtk_clipboard_set_with_data(Clipboard.GTKPRIMARYCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, 0)) {", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "+\t\t\tif (!OS.gtk_clipboard_set_with_data(Clipboard.GTKPRIMARYCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, 0)) {", "+\t\t\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e09fc5ce2f92b1dd4deebea4457276bc", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Drag and Drop/gtk/org/eclipse/swt/dnd/ClipboardProxy.java", "commitBeforeChange": "c73d77a84e8b631033badf1fdfaa29188425a20c", "commitAfterChange": "50261a085d1b4cb75f9b4378584d51b726ffc6c9", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  boolean setData(Clipboard owner, Object[] data, Transfer[] dataTypes, int clipboards)", "signatureAfterChange": "  boolean setData(Clipboard owner, Object[] data, Transfer[] dataTypes, int clipboards)", "diff": ["-\t\t\tif (activeClipboard != null) OS.gtk_clipboard_clear(Clipboard.GTKCLIPBOARD);", "-\t\t\tif (!OS.gtk_clipboard_set_with_data(Clipboard.GTKCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, 0)) {", "-\t\t\t\treturn false;", "+\t\t\tif (activeClipboard != null) {", "+\t\t\t\t/*", "+\t\t\t\t* Feature in GTK. When the contents are set again, clipboard_set_with_data() ", "+\t\t\t\t* invokes clearFunc and then, getFunc is not sequentially called. ", "+\t\t\t\t* If we clear the content before calling set_with_data(), then there is a fair ", "+\t\t\t\t* chance for other apps like Klipper to claim the ownership of the clipboard.", "+\t\t\t\t* The fix is to make sure that the content is not cleared before the data is", "+\t\t\t\t* set again. GTK does not invoke clearFunc for clipboard_set_with_owner()", "+\t\t\t\t* though we set the data again. So, this API has to be used whenever we", "+\t\t\t\t* are setting the contents again.", "+\t\t\t\t*/", "+\t\t\t\tif (!OS.gtk_clipboard_set_with_owner(Clipboard.GTKCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, clipboardOwner)) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (!OS.gtk_clipboard_set_with_data(Clipboard.GTKCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, 0)) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "-\t\t\tif (activePrimaryClipboard != null) OS.gtk_clipboard_clear(Clipboard.GTKPRIMARYCLIPBOARD);", "-\t\t\tif (!OS.gtk_clipboard_set_with_data(Clipboard.GTKPRIMARYCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, 0)) {", "-\t\t\t\treturn false;", "+\t\t\tif (activePrimaryClipboard != null) {", "+\t\t\t\tif (!OS.gtk_clipboard_set_with_owner(Clipboard.GTKPRIMARYCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, clipboardOwner)) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (!OS.gtk_clipboard_set_with_data(Clipboard.GTKPRIMARYCLIPBOARD, pTargetsList, entries.length, getFuncProc, clearFuncProc, 0)) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}"]}], "num": 24167}