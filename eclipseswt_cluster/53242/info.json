{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1bff1b8032345623c55999623dc086c2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9b7667616e0d52e10e61e87fd1993ec", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "5aba9b6cb1ae5e0f3e35624835172a06410c3c51", "commitAfterChange": "50ffc4c89de3b9247aed5737cd70563ccc951b93", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " \t void printWindow (boolean first, Control control, int gc, int drawable, int depth, int window, int x, int y)", "signatureAfterChange": "  void printWindow (boolean first, Control control, int gc, int drawable, int depth, int window, int x, int y)", "diff": ["-\t", "+", "-\tOS.gdk_window_invalidate_rect (window, rect, false);", "-\tOS.gdk_window_process_updates (window, false);", "-\tOS.gdk_window_get_internal_paint_info (window, real_drawable, x_offset, y_offset);", "-\tif (window == paintWindow ()) {", "-\t\tif (hooks (SWT.Paint) || filters (SWT.Paint)) {", "-\t\t\tGCData data = new GCData ();", "-\t\t\tint /*long*/ gdkGC = OS.gdk_gc_new (real_drawable [0]);", "-\t\t\tif (gdkGC == 0) error (SWT.ERROR_NO_HANDLES);\t", "-\t\t\tif (data != null) {", "-\t\t\t\tint mask = SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT;", "-\t\t\t\tif ((data.style & mask) == 0) {", "-\t\t\t\t\tdata.style |= style & (mask | SWT.MIRRORED);", "-\t\t\t\t} else {", "-\t\t\t\t\tif ((data.style & SWT.RIGHT_TO_LEFT) != 0) {", "-\t\t\t\t\t\tdata.style |= SWT.MIRRORED;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tdata.realDrawable = true;", "-\t\t\t\tdata.drawable = real_drawable [0];", "-\t\t\t\tdata.device = display;", "-\t\t\t\tdata.foreground = getForegroundColor ();", "-\t\t\t\tControl backgroundControl = findBackgroundControl ();", "-\t\t\t\tif (backgroundControl == null) backgroundControl = this;", "-\t\t\t\tdata.background = backgroundControl.getBackgroundColor ();", "-\t\t\t\tdata.font = font != null ? font : defaultFont (); ", "-\t\t\t}", "-\t\t\tEvent event = new Event ();", "-\t\t\tevent.width = width [0];", "-\t\t\tevent.height = height [0];", "-\t\t\tif ((style & SWT.MIRRORED) != 0) event.x = getClientWidth () - event.width - event.x;", "-\t\t\tGC paintGC = event.gc = GC.gtk_new (gdkGC, data);", "-\t\t\tsendEvent (SWT.Paint, event);", "-\t\t\tpaintGC.dispose ();", "-\t\t\tOS.g_object_unref (gdkGC);", "-\t\t}", "+\tOS.gdk_window_get_internal_paint_info (window, real_drawable, x_offset, y_offset);\t", "+\tint /*long*/ [] userData = new int /*long*/ [1];", "+\tOS.gdk_window_get_user_data (window, userData);", "+\tif (userData [0] != 0) {", "+\t\tint /*long*/ eventPtr = OS.gdk_event_new (OS.GDK_EXPOSE);", "+\t\tGdkEventExpose event = new GdkEventExpose ();", "+\t\tevent.type = OS.GDK_EXPOSE;", "+\t\tevent.window = OS.g_object_ref (window);", "+\t\tevent.area_width = rect.width;", "+\t\tevent.area_height = rect.height;", "+\t\tevent.region = OS.gdk_region_rectangle (rect);", "+\t\tOS.memmove (eventPtr, event, GdkEventExpose.sizeof);", "+\t\tOS.gtk_widget_send_expose (userData [0], eventPtr);", "+\t\tOS.gdk_event_free (eventPtr);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "67e70e675c8d85ec2198db5239ac2c38", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/StyledText.java", "commitBeforeChange": "635a9e5d0a5f495ec272194dbb750eddc745876f", "commitAfterChange": "e83d77b7ddccf5500d06ea30a64ce0d090ac4b10", "methodNumberBeforeChange": 377, "methodNumberAfterChange": 234, "signatureBeforeChange": " void redrawLines(int firstLine, int offsetInFirstLine, int lastLine, int endOffset, boolean clearBackground)", "signatureAfterChange": " void redrawLines(int startLine, int lineCount)", "diff": ["- */", "-void redrawLines(int firstLine, int offsetInFirstLine, int lastLine, int endOffset, boolean clearBackground) {", "-\tString line = content.getLine(firstLine);", "-\tint lineCount = lastLine - firstLine + 1;", "-\tint redrawY, redrawWidth;", "-\tint lineOffset = content.getOffsetAtLine(firstLine);", "-\tboolean fullLineRedraw;", "-\tRectangle clientArea = getClientArea();", "-\t", "-\tfullLineRedraw = ((getStyle() & SWT.FULL_SELECTION) != 0 && lastLine > firstLine);", "-\t// if redraw range includes last character on the first line, ", "-\t// clear background to right widget border. fixes bug 19595.", "-\tif (clearBackground && endOffset - lineOffset >= line.length()) {", "-\t\tfullLineRedraw = true;", "-\t}\t", "-\tTextLayout layout = renderer.getTextLayout(line, lineOffset);", "-\tRectangle rect = layout.getBounds(offsetInFirstLine, Math.min(endOffset, line.length()) - 1);", "-\trenderer.disposeTextLayout(layout);", "-\trect.x -= horizontalScrollOffset;", "-\trect.intersect(clientArea);", "-\tredrawY = firstLine * lineHeight - verticalScrollOffset;", "-\tredrawWidth = fullLineRedraw ? clientArea.width - leftMargin - rightMargin : rect.width;", "-\tdraw(rect.x, redrawY, redrawWidth, lineHeight, clearBackground);", "-\t", "-\t// redraw last line if more than one line needs redrawing ", "-\tif (lineCount > 1) {", "-\t\tlineOffset = content.getOffsetAtLine(lastLine);", "-\t\tint offsetInLastLine = endOffset - lineOffset;\t", "-\t\t// no redraw necessary if redraw offset is 0", "-\t\tif (offsetInLastLine > 0) {", "-\t\t\tline = content.getLine(lastLine);", "-\t\t\t// if redraw range includes last character on the last line, ", "-\t\t\t// clear background to right widget border. fixes bug 19595.", "-\t\t\tif (clearBackground && offsetInLastLine >= line.length()) {", "-\t\t\t\tfullLineRedraw = true;", "-\t\t\t}", "-\t\t\tline = content.getLine(lastLine);", "-\t\t\tlayout = renderer.getTextLayout(line, lineOffset);", "-\t\t\trect = layout.getBounds(0, offsetInLastLine - 1);", "-\t\t\trenderer.disposeTextLayout(layout);", "-\t\t\trect.x -= horizontalScrollOffset;", "-\t\t\trect.intersect(clientArea);", "-\t\t\tredrawY = lastLine * lineHeight - verticalScrollOffset;", "-\t\t\tredrawWidth = fullLineRedraw ? clientArea.width - leftMargin - rightMargin : rect.width;", "-\t\t\tdraw(rect.x, redrawY, redrawWidth, lineHeight, clearBackground);", "-\t\t}", "+void redrawLines(int startLine, int lineCount) {", "+\t// do nothing if redraw range is completely invisible\t", "+\tint partialBottomIndex = getPartialBottomIndex();", "+\tif (startLine > partialBottomIndex || startLine + lineCount - 1 < topIndex) {", "+\t\treturn;", "-}", "+\t// only redraw visible lines", "+\tif (startLine < topIndex) {", "+\t\tlineCount -= topIndex - startLine;", "+\t\tstartLine = topIndex;", "+\tif (startLine + lineCount - 1 > partialBottomIndex) {", "+\t\tlineCount = partialBottomIndex - startLine + 1;", "+\tstartLine -= topIndex;", "+\tint redrawTop = getLinePixel(startLine);", "+\tint redrawBottom = getLinePixel(startLine + lineCount);", "+\tint redrawWidth = getClientArea().width - leftMargin - rightMargin; ", "+\tsuper.redraw(leftMargin, redrawTop, redrawWidth, redrawBottom - redrawTop, true);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f4210cc6cae2dbbfb8d72d8c04879b2", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "bc0159e1f232b2994f90bfab06507bbdbd612bc8", "commitAfterChange": "4bf0b224a9caf7edd2d827277068ffb2c6e7bf23", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-    /* AW", "-\tint xDisplay = device.xDisplay;", "-\tint xSrcImagePtr = OS.XGetImage(xDisplay, pixmap, 0, 0, width, height, OS.AllPlanes, OS.ZPixmap);", "-\tif (xSrcImagePtr == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-    */", "-    int dd= OS.GetPixDepth(pixmap);", "-    if (dd < 0)", "-    \tdd= 1;", "-\tXImage xSrcImage = new XImage((short)width, (short)height, dd);", "-    /* AW", "-\tOS.memmove(xSrcImage, xSrcImagePtr, XImage.sizeof);", "-    */", "+    int srcDepth= getDepth(pixmap);", "+    int srcRowBytes= rowBytes(width, srcDepth);", "+    int srcBitsPerPixel= srcDepth;", "+", "-\tint length = xSrcImage.bytes_per_line * xSrcImage.height;", "-\tbyte[] srcData = new byte[length];", "-    /* AW", "-\tOS.memmove(srcData, xSrcImage.data, length);", "-    */", "-\tif (OS.copyPixmapData(srcData, pixmap, length) != OS.kNoErr)", "-\t\tSystem.out.println(\"Image.getImageData: copyPixmapData error\");", "+\tbyte[] srcData = new byte[srcRowBytes * height];", "+ \tOS.copyPixmapData(pixmap, srcData);", "-\tswitch (xSrcImage.depth) {", "+\tswitch (srcDepth) {", "-\t\t\tfor (int y = 0; y < xSrcImage.height; y++) {", "-\t\t\t\tfor (int x = 0; x < xSrcImage.bytes_per_line; x++) {", "+\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\tfor (int x = 0; x < srcRowBytes; x++) {", "-\t\t\t\tindex += xSrcImage.bytes_per_line;", "+\t\t\t\tindex += srcRowBytes;", "-            /* AW", "-\t\t\tint colormap = OS.XDefaultColormap(xDisplay, OS.XDefaultScreen(xDisplay));", "-\t\t\t*/", "-\t\t\t/* AW", "-\t\t\tXColor color = new XColor();", "-\t\t\t*/", "-\t\t\t\t\t/*", "-\t\t\t\t\tcolor.pixel = srcPixel;", "-\t\t\t\t\tOS.XQueryColor(xDisplay, colormap, color);", "-\t\t\t\t\t*/", "-\t\t\t\t\t/*", "-\t\t\t\t\trgbs[ rgbIndex ] = new RGB((color.red >> 8) & 0xFF, (color.green >> 8) & 0xFF, (color.blue >> 8) & 0xFF);", "-\t\t\t\t\t*/", "-\t\t\t", "-\t\t\t/*", "-\t\t\t * For some reason, the XImage does not have the mask information.", "-\t\t\t * We must get it from the visual.", "-\t\t\t */", "-            /* AW", "-\t\t\tint visual = OS.XDefaultVisual(xDisplay, OS.XDefaultScreen(xDisplay));", "-\t\t\tVisual v = new Visual();", "-\t\t\tOS.memmove(v, visual, Visual.sizeof);", "-\t\t\tpalette = new PaletteData(v.red_mask, v.green_mask, v.blue_mask);", "-            */", "-\t\t\t// AW assumes Mac", "-\t\t\tpalette = new PaletteData(0x7C00, 0x03E0, 0x001F);", "-\t\t\tbreak;", "-\t\t// AW", "-\t\t// AW", "-\t\t\t/* We always create 24-bit ImageData with the following palette */", "-\t\t\t/* AW", "-\t\t\tpalette = new PaletteData(0xFF, 0xFF00, 0xFF0000);", "-\t\t\t*/", "-\t\t\t// AW assumes Mac", "-\t\t\tpalette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "+\t\t\tpalette = new PaletteData(getRedMask(srcDepth), getGreenMask(srcDepth), getBlueMask(srcDepth));", "-\t\t\tSystem.out.println(\"unsupported depth: \" + xSrcImage.depth);", "-\tImageData data = new ImageData(width, height, xSrcImage.depth, palette);", "+\t", "+\tImageData data = new ImageData(width, height, srcDepth, palette);", "-\tif (false && xSrcImage.bits_per_pixel == 32) {", "+\tif (false && srcBitsPerPixel == 32) {", "-\t\tint bytesPerLine = (xSrcImage.width * xSrcImage.depth + 7) / 8;", "+\t\tint bytesPerLine = (width * srcDepth + 7) / 8;", "-\t\tbyte[] newData = new byte[bytesPerLine * xSrcImage.height];", "+\t\tbyte[] newData = new byte[bytesPerLine * height];", "-\t\tif (xSrcImage.byte_order == OS.MSBFirst) {", "-\t\t\trOffset = 3; gOffset = 2; bOffset = 1;", "-\t\t}", "+\t\t// MSBFirst:", "+\t\trOffset = 3; gOffset = 2; bOffset = 1;", "+\t\t", "-\t\t\tsrcIndex = y * xSrcImage.bytes_per_line;", "+\t\t\tsrcIndex = y * srcRowBytes;", "-        /* AW", "-\t\tint xMaskPtr = OS.XGetImage(xDisplay, mask, 0, 0, width, height, OS.AllPlanes, OS.ZPixmap);", "-\t\tif (xMaskPtr == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\t*/", "-\t\tint ddd= OS.GetPixDepth(mask);", "-\t\t//if (ddd < 0)", "-\t\t\tddd= 1;", "-\t\tXImage xMask = new XImage((short)width, (short)height, ddd);", "-\t\t/* AW", "-\t\tOS.memmove(xMask, xMaskPtr, XImage.sizeof);", "-\t\t*/", "-\t\tdata.maskData = new byte[xMask.bytes_per_line * xMask.height];", "-\t\tif (OS.copyPixmapData(data.maskData, mask, data.maskData.length) != OS.kNoErr)", "-\t\t\tSystem.out.println(\"Image.getImageData: copyPixmapData error\");", "-\t\t/* AW", "-\t\tOS.memmove(data.maskData, xMask.data, data.maskData.length);", "-\t\tOS.XDestroyImage(xMaskPtr);", "-        */", "-\t\t/* Bit swap the mask data if necessary */", "-\t\tif (xMask.bitmap_bit_order == OS.LSBFirst) {", "-\t\t\tbyte[] maskData = data.maskData;", "-\t\t\tfor (int i = 0; i < maskData.length; i++) {", "-\t\t\t\tbyte b = maskData[i];", "-\t\t\t\tmaskData[i] = (byte)(((b & 0x01) << 7) | ((b & 0x02) << 5) |", "-\t\t\t\t\t((b & 0x04) << 3) |\t((b & 0x08) << 1) | ((b & 0x10) >> 1) |", "-\t\t\t\t\t((b & 0x20) >> 3) |\t((b & 0x40) >> 5) | ((b & 0x80) >> 7));", "-\t\t\t}", "-\t\t}", "+\t\tint maskRowBytes= rowBytes(width, getDepth(mask));", "+\t\tdata.maskData = new byte[maskRowBytes * height];", "+\t\tOS.copyPixmapData(mask, data.maskData);", "-    /* AW", "-\tOS.XDestroyImage(xSrcImagePtr);", "-    */"]}], "num": 53242}