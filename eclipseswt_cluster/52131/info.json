{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "69637d1113edd1dc80c6542cd9f2ec6b", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e443886e848ac54ce82fb80ddd3b9fba", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "bd7861d3f10ae5263261fadc72efba55b44f5f8c", "commitAfterChange": "5bfbfd6550d25db2695eb695eae08fb135ba96b1", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  void initNative(String filename)", "signatureAfterChange": "  void initNative(String filename)", "diff": ["+\t\t\tboolean hasAlpha = OS.gdk_pixbuf_get_has_alpha(pixbuf);", "-\t\t\t\tint cairoStride = Cairo.cairo_format_stride_for_width(Cairo.CAIRO_FORMAT_ARGB32, width);", "+\t\t\t\tint format = hasAlpha ? Cairo.CAIRO_FORMAT_ARGB32 : Cairo.CAIRO_FORMAT_RGB24;", "+\t\t\t\tint cairoStride = Cairo.cairo_format_stride_for_width(format, width);", "-\t\t\t\tsurface = Cairo.cairo_image_surface_create_for_data(surfaceData, Cairo.CAIRO_FORMAT_ARGB32, width, height, cairoStride);", "+\t\t\t\tsurface = Cairo.cairo_image_surface_create_for_data(surfaceData, format, width, height, cairoStride);", "-\t\t\t\tbyte[] line = new byte[Math.max(cairoStride, stride)];", "+\t\t\t\tbyte[] line = new byte[stride];", "-\t\t\t\tfor (int y = 0; y < height; y++) {", "-\t\t\t\t\tOS.memmove(line, pixels + (y * stride), stride);", "-\t\t\t\t\tfor (int x = 0, offset = 0; x < width; x++, offset += 4) {", "-\t\t\t\t\t\tint a = line[offset + 3] & 0xFF;", "-\t\t\t\t\t\tint r = ((line[offset + 0] & 0xFF) * a) + 128;", "-\t\t\t\t\t\tr = (r + (r >> 8)) >> 8;", "-\t\t\t\t\t\tint g = ((line[offset + 1] & 0xFF) * a) + 128;", "-\t\t\t\t\t\tg = (g + (g >> 8)) >> 8;", "-\t\t\t\t\t\tint b = ((line[offset + 2] & 0xFF) * a) + 128;", "-\t\t\t\t\t\tb = (b + (b >> 8)) >> 8;", "-\t\t\t\t\t\tline[offset + oa] = (byte)a;", "-\t\t\t\t\t\tline[offset + or] = (byte)r;", "-\t\t\t\t\t\tline[offset + og] = (byte)g;", "-\t\t\t\t\t\tline[offset + ob] = (byte)b;", "+\t\t\t\tif (hasAlpha) {", "+\t\t\t\t\tbyte[] cairoLine = new byte[cairoStride];", "+\t\t\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\t\t\tOS.memmove(line, pixels + (y * stride), stride);", "+\t\t\t\t\t\tfor (int x = 0, offset = 0; x < width; x++, offset += 4) {", "+\t\t\t\t\t\t\tint a = line[offset + 3] & 0xFF;", "+\t\t\t\t\t\t\tint r = ((line[offset + 0] & 0xFF) * a) + 128;", "+\t\t\t\t\t\t\tr = (r + (r >> 8)) >> 8;", "+\t\t\t\t\t\t\tint g = ((line[offset + 1] & 0xFF) * a) + 128;", "+\t\t\t\t\t\t\tg = (g + (g >> 8)) >> 8;", "+\t\t\t\t\t\t\tint b = ((line[offset + 2] & 0xFF) * a) + 128;", "+\t\t\t\t\t\t\tb = (b + (b >> 8)) >> 8;", "+\t\t\t\t\t\t\tcairoLine[offset + oa] = (byte)a;", "+\t\t\t\t\t\t\tcairoLine[offset + or] = (byte)r;", "+\t\t\t\t\t\t\tcairoLine[offset + og] = (byte)g;", "+\t\t\t\t\t\t\tcairoLine[offset + ob] = (byte)b;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tOS.memmove(data + (y * cairoStride), cairoLine, cairoStride);", "-\t\t\t\t\tOS.memmove(data + (y * cairoStride), line, cairoStride);", "+\t\t\t\t} else {", "+\t\t\t\t\tbyte[] cairoLine = new byte[cairoStride];", "+\t\t\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\t\t\tOS.memmove(line, pixels + (y * stride), stride);", "+\t\t\t\t\t\tfor (int x = 0, offset = 0, cairoOffset = 0; x < width; x++, offset += 3, cairoOffset += 4) {", "+\t\t\t\t\t\t\tint r = line[offset + 0] & 0xFF;", "+\t\t\t\t\t\t\tint g = line[offset + 1] & 0xFF;", "+\t\t\t\t\t\t\tint b = line[offset + 2] & 0xFF;", "+\t\t\t\t\t\t\tcairoLine[cairoOffset + or] = (byte)r;", "+\t\t\t\t\t\t\tcairoLine[cairoOffset + og] = (byte)g;", "+\t\t\t\t\t\t\tcairoLine[cairoOffset + ob] = (byte)b;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tOS.memmove(data + (y * cairoStride), cairoLine, cairoStride);", "+\t\t\t\t\t}", "-\t\t\t\tboolean hasAlpha = OS.gdk_pixbuf_get_has_alpha(pixbuf);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "95cf61202440e3bacb3b5a1ad38dfefd", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "97620fe3667502da9f174b22a0db4534a8d8f70b", "commitAfterChange": "a3c8e8904451b6db108629003e63438cb42170e1", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-\t\tint width = this.width;", "-\t\tint height = this.height;", "-\t\tint stride = Cairo.cairo_format_stride_for_width(Cairo.CAIRO_FORMAT_ARGB32, width);", "-\t\tbyte[] srcData = new byte[stride * height];", "+\t\tint format = Cairo.cairo_image_surface_get_format(surface);", "+\t\tint width = Cairo.cairo_image_surface_get_width(surface);", "+\t\tint height = Cairo.cairo_image_surface_get_height(surface);", "+\t\tint stride = Cairo.cairo_image_surface_get_stride(surface);", "+\t\tint /*long*/ surfaceData = Cairo.cairo_image_surface_get_data(surface);", "+\t\tboolean hasAlpha = format == Cairo.CAIRO_FORMAT_ARGB32;", "-\t\tOS.memmove(srcData, this.surfaceData, srcData.length);", "+\t\tbyte[] srcData = new byte[stride * height];", "+\t\tOS.memmove(srcData, surfaceData, srcData.length);", "-\t\tfor (int y = 0, offset = 0; y < height; y++) {", "-\t\t\tfor (int x = 0; x < width; x++, offset += 4) {", "-\t\t\t\tint a = srcData[offset + oa] & 0xFF;", "-\t\t\t\tint r = srcData[offset + or] & 0xFF;", "-\t\t\t\tint g = srcData[offset + og] & 0xFF;", "-\t\t\t\tint b = srcData[offset + ob] & 0xFF;", "-\t\t\t\tsrcData[offset + 0] = (byte)a;", "-\t\t\t\tif (a != 0) {", "-\t\t\t\t\tsrcData[offset + 1] = (byte)(((r) / (float)a) * 0xFF);", "-\t\t\t\t\tsrcData[offset + 2] = (byte)(((g) / (float)a) * 0xFF);", "-\t\t\t\t\tsrcData[offset + 3] = (byte)(((b) / (float)a) * 0xFF);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t/*", "-\t\t* TODO is it impossible to retrieve the RGB values when alpha is zero? If this is true", "-\t\t* then this code is necessary because the transparent pixel needs the RGB values to work. ", "-\t\t*/", "-\t\tif (transparentPixel != -1) {", "+\t\tif (hasAlpha) {", "-\t\t\tfor (int y = 0, offset = 3, alphaOffset = 0; y < height; y++) {", "+\t\t\tfor (int y = 0, offset = 0, alphaOffset = 0; y < height; y++) {", "-\t\t\t\t\talphaData[alphaOffset++] = srcData[offset];", "+\t\t\t\t\tint a = srcData[offset + oa] & 0xFF;", "+\t\t\t\t\tint r = srcData[offset + or] & 0xFF;", "+\t\t\t\t\tint g = srcData[offset + og] & 0xFF;", "+\t\t\t\t\tint b = srcData[offset + ob] & 0xFF;", "+\t\t\t\t\tsrcData[offset + 0] = 0;", "+\t\t\t\t\talphaData[alphaOffset++] = (byte)a;", "+\t\t\t\t\tif (a != 0) {", "+\t\t\t\t\t\t//TODO write this without floating point math", "+\t\t\t\t\t\tsrcData[offset + 1] = (byte)(((r) / (float)a) * 0xFF);", "+\t\t\t\t\t\tsrcData[offset + 2] = (byte)(((g) / (float)a) * 0xFF);", "+\t\t\t\t\t\tsrcData[offset + 3] = (byte)(((b) / (float)a) * 0xFF);", "+\t\t\t\t\t}", "-\t\t}", "-\t\t", "-\t\tfor (int i = 0; i < srcData.length; i+= 4) {", "-\t\t\tsrcData[i] = 0;", "+\t\t} else {", "+\t\t\tfor (int y = 0, offset = 0; y < height; y++) {", "+\t\t\t\tfor (int x = 0; x < width; x++, offset += 4) {", "+\t\t\t\t\tbyte r = srcData[offset + or];", "+\t\t\t\t\tbyte g = srcData[offset + og];", "+\t\t\t\t\tbyte b = srcData[offset + ob];", "+\t\t\t\t\tsrcData[offset + 0] = 0;", "+\t\t\t\t\tsrcData[offset + 1] = r;", "+\t\t\t\t\tsrcData[offset + 2] = g;", "+\t\t\t\t\tsrcData[offset + 3] = b;", "+\t\t\t\t}", "+\t\t\t}", "-\t}", "-\tdata.alpha = alpha;", "-\tif (alpha == -1 && alphaData != null) {", "-\t\tdata.alphaData = new byte[alphaData.length];", "-\t\tSystem.arraycopy(alphaData, 0, data.alphaData, 0, alphaData.length);", "+\t\tdata.alpha = alpha;", "+\t\tif (alpha == -1 && alphaData != null) {", "+\t\t\tdata.alphaData = new byte[alphaData.length];", "+\t\t\tSystem.arraycopy(alphaData, 0, data.alphaData, 0, alphaData.length);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1bdf01b88e8db16d01f9fab093836cd2", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/internal/ImageList.java", "commitBeforeChange": "97620fe3667502da9f174b22a0db4534a8d8f70b", "commitAfterChange": "a3c8e8904451b6db108629003e63438cb42170e1", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public static int createPixbuf(Image image)", "signatureAfterChange": "  public static int createPixbuf(Image image)", "diff": ["-\t\tRectangle bounds = image.getBounds();", "-\t\tint w = bounds.width, h = bounds.height;", "-\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, true, 8, w, h);", "+\t\tint /*long*/ surface = image.surface;", "+\t\tint format = Cairo.cairo_image_surface_get_format(surface);", "+\t\tint width = Cairo.cairo_image_surface_get_width(surface);", "+\t\tint height = Cairo.cairo_image_surface_get_height(surface);", "+\t\tboolean hasAlpha = format == Cairo.CAIRO_FORMAT_ARGB32;", "+\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, hasAlpha, 8, width, height);", "-\t\tbyte[] line = new byte[stride];", "-\t\tint /*long*/ surfaceData = image.surfaceData;", "-\t\tfor (int y = 0; y < h; y++) {", "-\t\t\tOS.memmove (line, surfaceData + (y * stride), stride);", "-\t\t\tfor (int x = 0, offset = 0; x < w; x++, offset += 4) {", "-\t\t\t\tint a = line[offset + oa] & 0xFF;", "-\t\t\t\tint r = line[offset + or] & 0xFF;", "-\t\t\t\tint g = line[offset + og] & 0xFF;", "-\t\t\t\tint b = line[offset + ob] & 0xFF;", "-\t\t\t\tline[offset + 3] = (byte)a;", "-\t\t\t\tif (a != 0) {", "-\t\t\t\t\tline[offset + 0] = (byte)(((r) / (float)a) * 0xFF);", "-\t\t\t\t\tline[offset + 1] = (byte)(((g) / (float)a) * 0xFF);", "-\t\t\t\t\tline[offset + 2] = (byte)(((b) / (float)a) * 0xFF);", "+\t\tbyte[] line = new byte[stride];", "+\t\tint /*long*/ surfaceData = Cairo.cairo_image_surface_get_data(surface);", "+\t\tif (hasAlpha) {", "+\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\tOS.memmove (line, surfaceData + (y * stride), stride);", "+\t\t\t\tfor (int x = 0, offset = 0; x < width; x++, offset += 4) {", "+\t\t\t\t\tint a = line[offset + oa] & 0xFF;", "+\t\t\t\t\tint r = line[offset + or] & 0xFF;", "+\t\t\t\t\tint g = line[offset + og] & 0xFF;", "+\t\t\t\t\tint b = line[offset + ob] & 0xFF;", "+\t\t\t\t\tline[offset + 3] = (byte)a;", "+\t\t\t\t\tif (a != 0) {", "+\t\t\t\t\t\t//TODO write this without floating point math", "+\t\t\t\t\t\tline[offset + 0] = (byte)(((r) / (float)a) * 0xFF);", "+\t\t\t\t\t\tline[offset + 1] = (byte)(((g) / (float)a) * 0xFF);", "+\t\t\t\t\t\tline[offset + 2] = (byte)(((b) / (float)a) * 0xFF);", "+\t\t\t\t\t}", "+\t\t\t\tOS.memmove (pixels + (y * stride), line, stride);", "-\t\t\tOS.memmove (pixels + (y * stride), line, stride);", "+\t\t} else {", "+\t\t\tint cairoStride = Cairo.cairo_image_surface_get_stride(surface);", "+\t\t\tbyte[] cairoLine = new byte[cairoStride];", "+\t\t\tfor (int y = 0; y < height; y++) {", "+\t\t\t\tOS.memmove (cairoLine, surfaceData + (y * cairoStride), cairoStride);", "+\t\t\t\tfor (int x = 0, offset = 0, cairoOffset = 0; x < width; x++, offset += 3, cairoOffset += 4) {", "+\t\t\t\t\tbyte r = cairoLine[cairoOffset + or];", "+\t\t\t\t\tbyte g = cairoLine[cairoOffset + og];", "+\t\t\t\t\tbyte b = cairoLine[cairoOffset + ob];", "+\t\t\t\t\tline[offset + 0] = r;", "+\t\t\t\t\tline[offset + 1] = g;", "+\t\t\t\t\tline[offset + 2] = b;", "+\t\t\t\t}", "+\t\t\t\tOS.memmove (pixels + (y * stride), line, stride);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4cc8bc2ee7c419d0b1f9318ce7dfb2e9", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "7f4f0cf91f73e42703b3ba2d8e34ae06717a0b6c", "commitAfterChange": "646f3be9e023652896aa5b793e22f943c24ca91a", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  void createSurface()", "signatureAfterChange": "  void createSurface()", "diff": ["-\t\t\tint /*long*/ maskPixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, w[0], h[0]);", "+\t\t\tint /*long*/ maskPixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, width, height);", "-\t\t\tOS.gdk_pixbuf_get_from_drawable(maskPixbuf, mask, 0, 0, 0, 0, 0, w[0], h[0]);", "+\t\t\tOS.gdk_pixbuf_get_from_drawable(maskPixbuf, mask, 0, 0, 0, 0, 0, width, height);", "+\t\t\tint /*long*/ offset = pixels, maskOffset = maskPixels;", "-\t\t\t\tint /*long*/ offset = pixels + (y * stride);", "-\t\t\t\tint /*long*/ maskOffset = maskPixels + (y * maskStride);", "-\t\t\t\tfor (int x=0; x<width; x++) {", "-\t\t\t\t\tint offset1 = x * 4;", "+\t\t\t\tfor (int x=0, offset1=0; x<width; x++, offset1 += 4) {", "+\t\t\t\toffset += stride;", "+\t\t\t\tmaskOffset += maskStride;", "+\t\t\tint /*long*/ offset = pixels;", "-\t\t\t\tint /*long*/ offset = pixels + (y * stride);", "-\t\t\t\tfor (int x=0; x<width; x++) {", "-\t\t\t\t\tint offset1 = x * 4;", "+\t\t\t\tfor (int x=0, offset1=0; x<width; x++, offset1 += 4) {", "-\t\t\t\t\tbyte temp = line[offset1];", "-\t\t\t\t\tline[offset1] = line[offset1 + 2];", "-\t\t\t\t\tline[offset1 + 2] = temp;", "+\t\t\t\t\t/* pre-multiplied alpha */", "+\t\t\t\t\tint r = ((line[offset1 + 0] & 0xFF) * alpha) + 128;", "+\t\t\t\t\tr = (r + (r >> 8)) >> 8;", "+\t\t\t\t\tint g = ((line[offset1 + 1] & 0xFF) * alpha) + 128;", "+\t\t\t\t\tg = (g + (g >> 8)) >> 8;", "+\t\t\t\t\tint b = ((line[offset1 + 2] & 0xFF) * alpha) + 128;", "+\t\t\t\t\tb = (b + (b >> 8)) >> 8;", "+\t\t\t\t\tline[offset1 + 0] = (byte)b;", "+\t\t\t\t\tline[offset1 + 1] = (byte)g;", "+\t\t\t\t\tline[offset1 + 2] = (byte)r;", "+\t\t\t\toffset += stride;", "+\t\t\t}", "+\t\t} else if (alphaData != null) {", "+\t\t\tint /*long*/ offset = pixels;", "+\t\t\tfor (int y = 0; y < h [0]; y++) {", "+\t\t\t\tOS.memmove (line, offset, stride);", "+\t\t\t\tfor (int x=0, offset1=0; x<width; x++, offset1 += 4) {", "+\t\t\t\t\tint alpha = alphaData [y*w [0]+x] & 0xFF;", "+\t\t\t\t\tline[offset1+3] = (byte)alpha;", "+\t\t\t\t\t/* pre-multiplied alpha */", "+\t\t\t\t\tint r = ((line[offset1 + 0] & 0xFF) * alpha) + 128;", "+\t\t\t\t\tr = (r + (r >> 8)) >> 8;", "+\t\t\t\t\tint g = ((line[offset1 + 1] & 0xFF) * alpha) + 128;", "+\t\t\t\t\tg = (g + (g >> 8)) >> 8;", "+\t\t\t\t\tint b = ((line[offset1 + 2] & 0xFF) * alpha) + 128;", "+\t\t\t\t\tb = (b + (b >> 8)) >> 8;", "+\t\t\t\t\tline[offset1 + 0] = (byte)b;", "+\t\t\t\t\tline[offset1 + 1] = (byte)g;", "+\t\t\t\t\tline[offset1 + 2] = (byte)r;", "+\t\t\t\t}", "+\t\t\t\tOS.memmove (offset, line, stride);", "+\t\t\t\toffset += stride;", "+\t\t\tint /*long*/ offset = pixels;", "-\t\t\t\tint /*long*/ offset = pixels + (y * stride);", "-\t\t\t\tfor (int x = 0; x < w [0]; x++) {", "-\t\t\t\t\tint offset1 = x * 4;", "-\t\t\t\t\tline[offset1+3] = alphaData [y*w [0]+x];", "+\t\t\t\tfor (int x=0, offset1=0; x<width; x++, offset1 += 4) {", "+\t\t\t\t\tline[offset1+3] = (byte)0xFF;", "+\t\t\t\toffset += stride;", "+//\t\tsurface = Cairo.cairo_image_surface_create(Cairo.CAIRO_FORMAT_ARGB32, width, height);", "+//\t\tint cr = Cairo.cairo_create(surface);", "+//\t\tCairo.cairo_set_source_rgba(cr, 1, 0, 0, 0.5);", "+////\t\tCairo.cairo_rectangle(cr, 0, 0, width, height);", "+////\t\tCairo.cairo_fill(cr);", "+//\t\tCairo.cairo_set_source_rgba(cr, 1, 0, 0, 0.5);", "+//\t\tCairo.cairo_rectangle(cr, 0, 0, width - 0, height - 0);", "+//\t\tCairo.cairo_fill(cr);", "+//\t\tCairo.cairo_destroy(cr);"]}], "num": 52131}