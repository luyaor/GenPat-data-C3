{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "78592261335fc4a301b6cbc343448d25", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "652885365d7d2456142a3c5562a03c2d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "96bcff9181554f1747903750b20f425e4fb2a380", "commitAfterChange": "2af6ea6be65a345fee5001aa033638913c47ef13", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-\tOS.copyPixmpaData(srcData, pixmap, length);", "+\tOS.copyPixmapData(srcData, pixmap, length);", "+\t\t\t*/", "+\t\t\t\t\t/*", "+\t\t\t\t\t*/", "+\t\t\t\t\tint packed= OS.getRGB(pixmap, srcPixel);", "+\t\t\t\t\trgbs[ rgbIndex ] = new RGB((packed >> 16) & 0xFF, (packed >> 8) & 0xFF, (packed >> 0) & 0xFF);\t\t\t\t\t", "+\t\t\t\t\t/*", "+\t\t\t\t\t*/", "-\t\t\t*/", "+\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "18319ea17b60b705af42022a1dc627a4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "73b51de8c84174e0e99b4c04bc9fd87166a96cec", "commitAfterChange": "7df940ae424cbd3c79310d7b9bc5d657b5781f6f", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-    int srcRowBytes= rowBytes(width, srcDepth);", "-    int srcBitsPerPixel= srcDepth;", "-", "-\t/* Calculate the palette depending on the display attributes */", "-\tPaletteData palette = null;", "+    int srcRowBytes= rowBytes(width, srcDepth);", "+    int srcBitsPerPixel= srcDepth;", "-\t", "-\tswitch (srcDepth) {", "-\t\tcase 1:", "-\t\t\tpalette = new PaletteData(new RGB[] {", "-\t\t\t\tnew RGB(0, 0, 0),", "-\t\t\t\tnew RGB(255, 255, 255)", "-\t\t\t});", "-\t\t\tbreak;", "-\t\tcase 4:", "-\t\t\t/*", "-\t\t\t * We currently don't run on a 4-bit server, so 4-bit images", "-\t\t\t * should not exist.", "-\t\t\t */", "-\t\t\tSWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);", "-\t\tcase 8:", "-\t\t\t/* Normalize the pixels in the source image data (by making the", "-\t\t\t * pixel values sequential starting at pixel 0). Reserve normalized", "-\t\t\t * pixel 0 so that it maps to real pixel 0. This assumes pixel 0 is", "-\t\t\t * always used in the image.", "-\t\t\t */", "-\t\t\tbyte[] normPixel = new byte[ 256 ];", "-\t\t\tfor (int index = 0; index < normPixel.length; index++) {", "-\t\t\t\tnormPixel[ index ] = 0;", "-\t\t\t}", "-\t\t\tint numPixels = 1;", "-\t\t\tint index = 0;", "-\t\t\tfor (int y = 0; y < height; y++) {", "-\t\t\t\tfor (int x = 0; x < srcRowBytes; x++) {", "-\t\t\t\t\tint srcPixel = srcData[ index + x ] & 0xFF;", "-\t\t\t\t\tif (srcPixel != 0 && normPixel[ srcPixel ] == 0) {", "-\t\t\t\t\t\tnormPixel[ srcPixel ] = (byte)numPixels++;", "-\t\t\t\t\t}", "-\t\t\t\t\tsrcData[ index + x ] = normPixel[ srcPixel ];", "-\t\t\t\t}", "-\t\t\t\tindex += srcRowBytes;", "-\t\t\t}", "-\t\t\t", "-\t\t\tshort[] colorTable= getColorTable(pixmap);", "-\t\t\t/* Create a palette with only the RGB values used in the image. */", "-\t\t\tRGB[] rgbs = new RGB[ numPixels ];", "-\t\t\tfor (int srcPixel = 0; srcPixel < normPixel.length; srcPixel++) {", "-\t\t\t\t// If the pixel value was used in the image, get its RGB values.", "-\t\t\t\tif (srcPixel == 0 || normPixel[ srcPixel ] != 0) {", "-\t\t\t\t\tint packed= getRGB(colorTable, srcPixel);", "-\t\t\t\t\tint rgbIndex = normPixel[ srcPixel ] & 0xFF;", "-\t\t\t\t\trgbs[ rgbIndex ] = new RGB((packed >> 16) & 0xFF, (packed >> 8) & 0xFF, (packed >> 0) & 0xFF);\t\t\t\t\t", "+\t/* Build the palette */", "+\tPaletteData palette = null;", "+\tswitch (srcDepth) {", "+\tcase 1:", "+\t\tpalette = new PaletteData(new RGB[] {", "+\t\t\tnew RGB(0, 0, 0),", "+\t\t\tnew RGB(255, 255, 255)", "+\t\t});", "+\t\tbreak;", "+\tcase 4:", "+\t\tshort[] colorTable4= getColorTable(pixmap);", "+\t\tRGB[] rgbs4 = new RGB[ colorTable4.length/4 ];", "+\t\tfor (int i = 0; i < rgbs4.length; i++) {", "+\t\t\tint packed= getRGB(colorTable4, i);", "+\t\t\trgbs4[i] = new RGB((packed >> 16) & 0xFF, (packed >> 8) & 0xFF, (packed >> 0) & 0xFF);", "+\t\t}", "+\t\tpalette = new PaletteData(rgbs4);", "+\t\tbreak;", "+\tcase 8:", "+\t\t/* Normalize the pixels in the source image data (by making the", "+\t\t * pixel values sequential starting at pixel 0). Reserve normalized", "+\t\t * pixel 0 so that it maps to real pixel 0. This assumes pixel 0 is", "+\t\t * always used in the image.", "+\t\t */", "+\t\tbyte[] normPixel = new byte[ 256 ];", "+\t\tfor (int index = 0; index < normPixel.length; index++) {", "+\t\t\tnormPixel[ index ] = 0;", "+\t\t}", "+\t\tint numPixels = 1;", "+\t\tint index = 0;", "+\t\tfor (int y = 0; y < height; y++) {", "+\t\t\tfor (int x = 0; x < srcRowBytes; x++) {", "+\t\t\t\tint srcPixel = srcData[ index + x ] & 0xFF;", "+\t\t\t\tif (srcPixel != 0 && normPixel[ srcPixel ] == 0) {", "+\t\t\t\t\tnormPixel[ srcPixel ] = (byte)numPixels++;", "+\t\t\t\tsrcData[ index + x ] = normPixel[ srcPixel ];", "-\t\t\tpalette = new PaletteData(rgbs);", "-\t\t\tbreak;", "-\t\tcase 16:", "-\t\tcase 24:", "-\t\tcase 32:", "-\t\t\tpalette = new PaletteData(getRedMask(srcDepth), getGreenMask(srcDepth), getBlueMask(srcDepth));", "-\t\t\tbreak;", "-\t\tdefault:", "-\t\t\tSWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);", "+\t\t\tindex += srcRowBytes;", "+\t\t}", "+\t\t", "+\t\tshort[] colorTable= getColorTable(pixmap);", "+", "+\t\t/* Create a palette with only the RGB values used in the image. */", "+\t\tRGB[] rgbs = new RGB[ numPixels ];", "+\t\tfor (int srcPixel = 0; srcPixel < normPixel.length; srcPixel++) {", "+\t\t\t// If the pixel value was used in the image, get its RGB values.", "+\t\t\tif (srcPixel == 0 || normPixel[ srcPixel ] != 0) {", "+\t\t\t\tint packed= getRGB(colorTable, srcPixel);", "+\t\t\t\tint rgbIndex = normPixel[ srcPixel ] & 0xFF;", "+\t\t\t\trgbs[ rgbIndex ] = new RGB((packed >> 16) & 0xFF, (packed >> 8) & 0xFF, (packed >> 0) & 0xFF);\t\t\t\t\t", "+\t\t\t}", "+\t\t}", "+\t\tpalette = new PaletteData(rgbs);", "+\t\tbreak;", "+\tcase 16:", "+\tcase 24:", "+\tcase 32:", "+\t\tpalette = new PaletteData(getRedMask(srcDepth), getGreenMask(srcDepth), getBlueMask(srcDepth));", "+\t\tbreak;", "+\tdefault:", "+\t\tSWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);", "+\t", "-\tif (false && srcBitsPerPixel == 32) {", "+\tif (srcBitsPerPixel == 32) {", "-\t\tint rOffset = 0, gOffset = 1, bOffset = 2;", "-\t\t// MSBFirst:", "-\t\trOffset = 3; gOffset = 2; bOffset = 1;", "-\t\t\t\tnewData[destIndex] = oldData[srcIndex + rOffset];", "-\t\t\t\tnewData[destIndex + 1] = oldData[srcIndex + gOffset];", "-\t\t\t\tnewData[destIndex + 2] = oldData[srcIndex + bOffset];", "+\t\t\t\tnewData[destIndex] = oldData[srcIndex + 1];", "+\t\t\t\tnewData[destIndex + 1] = oldData[srcIndex + 2];", "+\t\t\t\tnewData[destIndex + 2] = oldData[srcIndex + 3];"]}], "num": 43695}