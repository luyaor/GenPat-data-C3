{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6570cbde54bc45e5dd918d5fe4ae25cc", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a095d89844d140a04ccf71a48e1b3752", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/TreeItem.java", "commitBeforeChange": "ed568a606dfba062e77bacc7c7f799741b60cbf4", "commitAfterChange": "3e04f21595fe557524d009b946647c76885ec76f", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public void dispose()", "signatureAfterChange": " public void dispose()", "diff": ["+}", "+public void dispose() {", "+\tif (isDisposed ()) return;", "+\tint startIndex = -1, endIndex = -1;", "+\tTree parent = this.parent;", "+\tint index = getIndex ();", "+\t/* determine the indices, if any, that will need to be visually updated */", "+\tif (isAvailable ()) {", "+\t\tif (isLastChild () && index > 0) {", "+\t\t\t/* vertical connector lines no longer needed for this item */", "+\t\t\tif (parentItem != null) {", "+\t\t\t\tstartIndex = parentItem.getItems ()[index - 1].availableIndex;", "+\t\t\t} else {", "+\t\t\t\tstartIndex = parent.getItems ()[index - 1].availableIndex;", "+\t\t\t}", "+\t\t} else {", "+\t\t\tstartIndex = availableIndex;", "+\t\tendIndex = parent.availableItems.length - 1;", "+", "+\t/* for performance do this upfront for whole descendent chain */", "+\tTreeItem focusItem = parent.focusItem; ", "+\tif (focusItem != null && focusItem.hasAncestor (this)) {", "+\t\tparent.setFocusItem (this, false);", "+\t\tparent.reassignFocus ();", "+\t\tparent.redrawItem (parent.focusItem.availableIndex);", "+\t\tparentItem.removeItem (this, index);", "+\tdispose (true);", "+\tif (startIndex != -1) {", "+\t\tparent.redrawItems (startIndex, endIndex);", "+\t}", "-", "-public void dispose() {", "-\tif (isDisposed()) return;", "-\t// if the tree is being disposed don't bother collapsing the item since all ", "-\t// items in the tree will be deleted and redraws will not be processed anyway", "-\tTree parent = getParent();", "-\tif (parent.isRemovingAll() == false) {", "-\t\tparent.collapseNoRedraw(this);", "-\t}\t", "-\t", "-\t\tparentItem.removeItem(this);", "-\telse {", "-\t\tparent.removeItem(this);", "-\tsuper.dispose();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a844363258522025e3e41ab3d62fdc52", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "f0a6540ce7bf7b6b28e6ad70d90e1bca9fd84690", "commitAfterChange": "87d6ff63a606760c4c8d21e48bca9d1a0287e071", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "  void flushExposes ()", "signatureAfterChange": "  void flushExposes ()", "diff": ["-\t/*", "-\t* Feature in GTK.  Calling gdk_event_get() accumulates", "-\t* the outstanding damage for pending GTK expose events.", "-\t* In order to flush all paint events, get all of the", "-\t* events from the queue.", "-\t*/", "-\tint /*long*/ event = 0;", "-\twhile ((event = OS.gdk_event_get ()) != 0) {", "-\t\taddGdkEvent (event);", "+\tOS.gdk_flush ();", "+\tif (OS.GDK_WINDOWING_X11 ()) {", "+\t\tGdkRectangle rect = new GdkRectangle ();", "+\t\tXExposeEvent exposeEvent = new XExposeEvent ();", "+\t\tint /*long*/ xDisplay = OS.GDK_DISPLAY ();", "+\t\tint /*long*/ xEvent = OS.g_malloc (XEvent.sizeof);", "+\t\twhile (OS.XCheckMaskEvent (xDisplay, OS.ExposureMask, xEvent)) {", "+\t\t\tOS.memmove (exposeEvent, xEvent, XExposeEvent.sizeof);", "+\t\t\trect.x = exposeEvent.x;", "+\t\t\trect.y = exposeEvent.y;", "+\t\t\trect.width = exposeEvent.width;", "+\t\t\trect.height = exposeEvent.height;", "+\t\t\tint window = OS.gdk_window_lookup (exposeEvent.window);", "+\t\t\tif (window != 0) OS.gdk_window_invalidate_rect (window, rect, true);", "+\t\t}", "+\t\tOS.g_free (xEvent);"]}], "num": 41355}