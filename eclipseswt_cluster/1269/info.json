{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "55497c64ed8cf3bc8f624af7b7c73537", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a3887294a5e6c1ddd58d57b81735f965", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "21ad7e1c41ce1d63dd243622044164fd46b26ef4", "commitAfterChange": "1c5467f79f5b1c73782459594b2f72f13320a777", "methodNumberBeforeChange": 85, "methodNumberAfterChange": 88, "signatureBeforeChange": "  boolean setScrollWidth (TreeItem item)", "signatureAfterChange": "  boolean setScrollWidth (TreeItem[] items, boolean recurse, boolean callMeasureItem)", "diff": ["-boolean setScrollWidth (TreeItem item) {", "-//\tif (ignoreRedraw || drawCount != 0) return false;", "+", "+boolean setScrollWidth (TreeItem[] items, boolean recurse, boolean callMeasureItem) {", "-//\tTreeItem parentItem = item.parentItem;", "-//\tif (parentItem != null && !parentItem._getExpanded ()) return false;", "-//\tGC gc = new GC (this);", "-//\tint newWidth = item.calculateWidth (0, gc);", "-//\tgc.dispose ();", "-//\tnewWidth += getInsetWidth (column_id, false);", "-//\tshort [] width = new short [1];", "-//\tOS.GetDataBrowserTableViewNamedColumnWidth (handle, column_id, width);", "-//\tif (width [0] < newWidth) {", "-//\t\tOS.SetDataBrowserTableViewNamedColumnWidth (handle, column_id, (short) newWidth);", "-//\t\treturn true;", "+//\tif (currentItem != null) {", "+//\t\tif (currentItem != item) fixScrollWidth = true;", "+//\t\treturn false;", "-//\tfirstColumn.setWidth(400);", "+\tif (/*ignoreRedraw ||*/ drawCount != 0) return false;", "+\tint newWidth = 0;", "+\tGC gc = new GC (this);", "+\tfor (int i = 0; i < items.length; i++) {", "+\t\tTreeItem item = items[i];", "+\t\tif (item != null && !item.isDisposed ()) {", "+\t\t\tnewWidth = Math.max (newWidth, item.calculateWidth (0, gc, recurse, callMeasureItem));", "+\t\t\tif (isDisposed ()) {", "+\t\t\t\tgc.dispose ();", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t}", "+\t}", "+\tgc.dispose ();", "+\tif (firstColumn.width () < newWidth) {", "+\t\tNSOutlineView outlineView = (NSOutlineView)view;", "+\t\tint /*long*/ oldResize = outlineView.columnAutoresizingStyle ();", "+\t\toutlineView.setColumnAutoresizingStyle (OS.NSTableViewNoColumnAutoresizing);", "+\t\tfirstColumn.setWidth (newWidth);", "+\t\toutlineView.setColumnAutoresizingStyle (oldResize);", "+\t\treturn true;", "+\t}", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bd6cdc6e2deb71486422cf3cd19594fa", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "fd0c72b88d4c0c17622dd7d3179e13744eb0ddc3", "commitAfterChange": "6d400f7fdace917b46262205e4bec5b0110965c2", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": "  void destroyItem (TableColumn column)", "signatureAfterChange": "  void destroyItem (TableColumn column)", "diff": ["-\tint [] order = new int [columnCount];", "-\tOS.SendMessage (handle, OS.LVM_GETCOLUMNORDERARRAY, columnCount, order);", "+\tint [] oldOrder = new int [columnCount];", "+\tOS.SendMessage (handle, OS.LVM_GETCOLUMNORDERARRAY, columnCount, oldOrder);", "-\t\tif (order [orderIndex] == index) break;", "+\t\tif (oldOrder [orderIndex] == index) break;", "-\tif (columnCount != 0) {", "-\t\tint count = columnCount - orderIndex;", "-\t\tTableColumn [] newColumns = new TableColumn [count];", "-\t\tOS.SendMessage (handle, OS.LVM_GETCOLUMNORDERARRAY, columnCount, order);", "-\t\tfor (int i=orderIndex; i<columnCount; i++) {", "-\t\t\tnewColumns [i - orderIndex] = columns [order [i]];", "+\tif (columnCount != 0) {\t", "+\t\t/*", "+\t\t* Bug in Windows.  When LVM_DELETECOLUMN is used to delete a", "+\t\t* column zero when that column is both the first column in the", "+\t\t* table and the first column in the column order array, Windows", "+\t\t* incorrectly computes the new column order.  For example, both", "+\t\t* the orders {0, 3, 1, 2} and {0, 3, 2, 1} give a new column", "+\t\t* order of {0, 2, 1}, while {0, 2, 1, 3} gives {0, 1, 2, 3}.", "+\t\t* The fix is to compute the new order and compare it with the", "+\t\t* order that Windows is using.  If the two differ, the new order", "+\t\t* is used.", "+\t\t*/", "+\t\tint count = 0;", "+\t\tint oldIndex = oldOrder [orderIndex];", "+\t\tint [] newOrder = new int [columnCount];", "+\t\tfor (int i=0; i<oldOrder.length; i++) {", "+\t\t\tif (oldOrder [i] != oldIndex) {", "+\t\t\t\tint newIndex = oldOrder [i] <= oldIndex ? oldOrder [i] : oldOrder [i] - 1;", "+\t\t\t\tnewOrder [count++] = newIndex;", "+\t\t\t}", "+\t\tOS.SendMessage (handle, OS.LVM_GETCOLUMNORDERARRAY, columnCount, oldOrder);", "+\t\tint j = 0;", "+\t\twhile (j < newOrder.length) {", "+\t\t\tif (oldOrder [j] != newOrder [j]) break;", "+\t\t\tj++;", "+\t\t}", "+\t\tif (j != newOrder.length) {", "+\t\t\tOS.SendMessage (handle, OS.LVM_SETCOLUMNORDERARRAY, newOrder.length, newOrder);", "+\t\t\t/*", "+\t\t\t* Bug in Windows.  When LVM_SETCOLUMNORDERARRAY is used to change", "+\t\t\t* the column order, the header redraws correctly but the table does", "+\t\t\t* not.  The fix is to force a redraw.", "+\t\t\t*/", "+\t\t\tOS.InvalidateRect (handle, null, true);\t\t\t", "+\t\t}", "+\t\t", "+\t\tTableColumn [] newColumns = new TableColumn [columnCount - orderIndex];", "+\t\tfor (int i=orderIndex; i<newOrder.length; i++) {", "+\t\t\tnewColumns [i - orderIndex] = columns [newOrder [i]];", "+\t\t}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2fd7c3e72d70d9e4a025cbcb996c448d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/wpf/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "bbe34f2e9f30dc6618286a73fece569ceb79a3e8", "commitAfterChange": "e352283006dccad1eb5102d4387c1f8e07732a91", "methodNumberBeforeChange": 84, "methodNumberAfterChange": 83, "signatureBeforeChange": " public void setColumnOrder (int [] order)", "signatureAfterChange": " public void setColumnOrder (int [] order)", "diff": ["-\t//TODO", "+\tif (order.length != columnCount) error (SWT.ERROR_INVALID_ARGUMENT);", "+\tint [] oldOrder = getColumnOrder ();", "+\tboolean reorder = false;", "+\tboolean [] seen = new boolean [columnCount];", "+\tfor (int i=0; i<order.length; i++) {", "+\t\tint index = order [i];", "+\t\tif (index < 0 || index >= columnCount) error (SWT.ERROR_INVALID_ARGUMENT);", "+\t\tif (seen [index]) error (SWT.ERROR_INVALID_ARGUMENT);", "+\t\tseen [index] = true;", "+\t\tif (order [i] != oldOrder [i]) reorder = true;", "+\t}", "+\tif (!reorder) return;", "+\tfor (int i = 0; i < order.length; i++) {", "+\t\tTreeColumn column = columns [order [i]];", "+\t\tint index = OS.IList_IndexOf (gvColumns, column.handle);", "+\t\tif (index != i) OS.ObservableCollectionGridViewColumn_Move (gvColumns, index, i);\t", "+\t}"]}], "num": 1269}