{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e044653f1f1654d796258d8d134b52c8", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8c5ac96da7e0cb3d2f59aa9310329499", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "475fd80af7f44f11c184ce4e415e7e668e7066c7", "commitAfterChange": "a82cf9526e3bd01c73cdc5c3786a7972e25aa4c4", "methodNumberBeforeChange": 131, "methodNumberAfterChange": 140, "signatureBeforeChange": "  LRESULT WM_NOTIFY (int wParam, int lParam)", "signatureAfterChange": "  LRESULT wmNotify (NMHDR hdr, int wParam, int lParam)", "diff": ["-LRESULT WM_NOTIFY (int wParam, int lParam) {", "-\tNMHDR hdr = new NMHDR ();", "-\tOS.MoveMemory (hdr, lParam, NMHDR.sizeof);", "-\tint hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);", "-\tif (hdr.hwndFrom == hwndHeader) {", "-\t\t/*", "-\t\t* Feature in Windows.  On NT, the automatically created", "-\t\t* header control is created as a UNICODE window, not an", "-\t\t* ANSI window despite the fact that the parent is created", "-\t\t* as an ANSI window.  This means that it sends UNICODE", "-\t\t* notification messages to the parent window on NT for", "-\t\t* no good reason.  The data and size in the NMHEADER and", "-\t\t* HDITEM structs is identical between the platforms so no", "-\t\t* different message is actually necessary.  Despite this,", "-\t\t* Windows sends different messages.  The fix is to look", "-\t\t* for both messages, despite the platform.  This works", "-\t\t* because only one will be sent on either platform, never", "-\t\t* both.", "-\t\t*/", "-\t\tswitch (hdr.code) {", "-\t\t\tcase OS.HDN_BEGINTRACKW:", "-\t\t\tcase OS.HDN_BEGINTRACKA:", "-\t\t\tcase OS.HDN_DIVIDERDBLCLICKW:", "-\t\t\tcase OS.HDN_DIVIDERDBLCLICKA: {", "-\t\t\t\tif (columnCount == 0) return LRESULT.ONE;", "-\t\t\t\tNMHEADER phdn = new NMHEADER ();", "-\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "-\t\t\t\tTableColumn column = columns [phdn.iItem];", "-\t\t\t\tif (column != null && !column.getResizable ()) {", "-\t\t\t\t\treturn LRESULT.ONE;", "-\t\t\t\t}", "-\t\t\t\tignoreColumnMove = true;", "-\t\t\t\tswitch (hdr.code) {", "-\t\t\t\t\tcase OS.HDN_DIVIDERDBLCLICKW:", "-\t\t\t\t\tcase OS.HDN_DIVIDERDBLCLICKA:", "-\t\t\t\t\t\tif (column != null && hooks (SWT.MeasureItem)) {", "-\t\t\t\t\t\t\tcolumn.pack ();", "-\t\t\t\t\t\t\treturn LRESULT.ONE;", "-\t\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcase OS.NM_RELEASEDCAPTURE: {", "-\t\t\t\tif (!ignoreColumnMove) {", "-\t\t\t\t\tfor (int i=0; i<columnCount; i++) {", "-\t\t\t\t\t\tTableColumn column = columns [i];", "-\t\t\t\t\t\tcolumn.updateToolTip (i);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tignoreColumnMove = false;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcase OS.HDN_BEGINDRAG: {", "-\t\t\t\tif (ignoreColumnMove) return LRESULT.ONE;", "-\t\t\t\tint bits = OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);", "-\t\t\t\tif ((bits & OS.LVS_EX_HEADERDRAGDROP) == 0) break; ", "-\t\t\t\tif (columnCount == 0) return LRESULT.ONE;", "-\t\t\t\tNMHEADER phdn = new NMHEADER ();", "-\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "-\t\t\t\tif (phdn.iItem != -1) {", "-\t\t\t\t\tTableColumn column = columns [phdn.iItem];", "-\t\t\t\t\tif (column != null && !column.getMoveable ()) {", "-\t\t\t\t\t\tignoreColumnMove = true;", "-\t\t\t\t\t\treturn LRESULT.ONE;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcase OS.HDN_ENDDRAG: {", "-\t\t\t\tint bits = OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);", "-\t\t\t\tif ((bits & OS.LVS_EX_HEADERDRAGDROP) == 0) break;", "-\t\t\t\tNMHEADER phdn = new NMHEADER ();", "-\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "-\t\t\t\tif (phdn.iItem != -1 && phdn.pitem != 0) {", "-\t\t\t\t\tHDITEM pitem = new HDITEM ();", "-\t\t\t\t\tOS.MoveMemory (pitem, phdn.pitem, HDITEM.sizeof);", "-\t\t\t\t\tif ((pitem.mask & OS.HDI_ORDER) != 0 && pitem.iOrder != -1) {", "-\t\t\t\t\t\tif (columnCount == 0) break;", "-\t\t\t\t\t\tint [] order = new int [columnCount];", "-\t\t\t\t\t\tOS.SendMessage (handle, OS.LVM_GETCOLUMNORDERARRAY, columnCount, order);", "-\t\t\t\t\t\tint index = 0;", "-\t\t\t\t\t\twhile (index < order.length) {", "-\t\t\t\t\t\t \tif (order [index] == phdn.iItem) break;", "-\t\t\t\t\t\t\tindex++;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (index == order.length) index = 0;", "-\t\t\t\t\t\tif (index == pitem.iOrder) break;", "-\t\t\t\t\t\tint start = Math.min (index, pitem.iOrder);", "-\t\t\t\t\t\tint end = Math.max (index, pitem.iOrder);", "-\t\t\t\t\t\tignoreColumnMove = false;", "-\t\t\t\t\t\tfor (int i=start; i<=end; i++) {", "-\t\t\t\t\t\t\tTableColumn column = columns [order [i]];", "-\t\t\t\t\t\t\tif (!column.isDisposed ()) {", "-\t\t\t\t\t\t\t\tcolumn.postEvent (SWT.Move);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcase OS.HDN_ITEMCHANGEDW:", "-\t\t\tcase OS.HDN_ITEMCHANGEDA: {", "-\t\t\t\t/*", "-\t\t\t\t* Bug in Windows.  When a table has the LVS_EX_GRIDLINES extended", "-\t\t\t\t* style and the user drags any column over the first column in the", "-\t\t\t\t* table, making the size become zero, when the user drags a column", "-\t\t\t\t* such that the size of the first column becomes non-zero, the grid", "-\t\t\t\t* lines are not redrawn.  The fix is to detect the case and force", "-\t\t\t\t* a redraw of the first column.", "-\t\t\t\t*/", "-\t\t\t\tint width = OS.SendMessage (handle, OS.LVM_GETCOLUMNWIDTH, 0, 0);", "-\t\t\t\tif (lastWidth == 0 && width > 0) {", "-\t\t\t\t\tint bits = OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);", "-\t\t\t\t\tif ((bits & OS.LVS_EX_GRIDLINES) != 0) {", "-\t\t\t\t\t\tRECT rect = new RECT ();", "-\t\t\t\t\t\tOS.GetClientRect (handle, rect);", "-\t\t\t\t\t\trect.right = rect.left + width;", "-\t\t\t\t\t\tOS.InvalidateRect (handle, rect, true);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tlastWidth = width;", "-\t\t\t\tif (!ignoreColumnResize) {", "-\t\t\t\t\tNMHEADER phdn = new NMHEADER ();", "-\t\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "-\t\t\t\t\tif (phdn.pitem != 0) {", "-\t\t\t\t\t\tHDITEM pitem = new HDITEM ();", "-\t\t\t\t\t\tOS.MoveMemory (pitem, phdn.pitem, HDITEM.sizeof);", "-\t\t\t\t\t\tif ((pitem.mask & OS.HDI_WIDTH) != 0) {", "-\t\t\t\t\t\t\tTableColumn column = columns [phdn.iItem];", "-\t\t\t\t\t\t\tif (column != null) {", "-\t\t\t\t\t\t\t\tcolumn.updateToolTip (phdn.iItem);", "-\t\t\t\t\t\t\t\tcolumn.sendEvent (SWT.Resize);", "-\t\t\t\t\t\t\t\tif (isDisposed ()) return LRESULT.ZERO;", "-\t\t\t\t\t\t\t\t/*", "-\t\t\t\t\t\t\t\t* It is possible (but unlikely), that application", "-\t\t\t\t\t\t\t\t* code could have disposed the column in the move", "-\t\t\t\t\t\t\t\t* event.  If this happens, process the move event", "-\t\t\t\t\t\t\t\t* for those columns that have not been destroyed.", "-\t\t\t\t\t\t\t\t*/", "-\t\t\t\t\t\t\t\tTableColumn [] newColumns = new TableColumn [columnCount];", "-\t\t\t\t\t\t\t\tSystem.arraycopy (columns, 0, newColumns, 0, columnCount);", "-\t\t\t\t\t\t\t\tint [] order = new int [columnCount];", "-\t\t\t\t\t\t\t\tOS.SendMessage (handle, OS.LVM_GETCOLUMNORDERARRAY, columnCount, order);", "-\t\t\t\t\t\t\t\tboolean moved = false;", "-\t\t\t\t\t\t\t\tfor (int i=0; i<columnCount; i++) {", "-\t\t\t\t\t\t\t\t\tTableColumn nextColumn = newColumns [order [i]];", "-\t\t\t\t\t\t\t\t\tif (moved && !nextColumn.isDisposed ()) {", "-\t\t\t\t\t\t\t\t\t\tnextColumn.updateToolTip (order [i]);", "-\t\t\t\t\t\t\t\t\t\tnextColumn.sendEvent (SWT.Move);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tif (nextColumn == column) moved = true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcase OS.HDN_ITEMDBLCLICKW:", "-\t\t\tcase OS.HDN_ITEMDBLCLICKA: {", "-\t\t\t\tNMHEADER phdn = new NMHEADER ();", "-\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "-\t\t\t\tTableColumn column = columns [phdn.iItem];", "-\t\t\t\tif (column != null) {", "-\t\t\t\t\tcolumn.postEvent (SWT.DefaultSelection);", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t}", "-\tLRESULT result = super.WM_NOTIFY (wParam, lParam);", "-\tif (result != null) return result;", "-\tswitch (hdr.code) {", "-\t\tcase OS.TTN_GETDISPINFOA:", "-\t\tcase OS.TTN_GETDISPINFOW: {", "-\t\t\ttipRequested = true;", "-\t\t\tint code = callWindowProc (handle, OS.WM_NOTIFY, wParam, lParam);", "-\t\t\ttipRequested = false;", "-\t\t\treturn new LRESULT (code);", "-\t\t}", "-\t}", "-\treturn result;", "-}", "+LRESULT wmNotify (NMHDR hdr, int wParam, int lParam) {", "+\tint hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);", "+\tif (hdr.hwndFrom == hwndHeader) {", "+\t\t/*", "+\t\t* Feature in Windows.  On NT, the automatically created", "+\t\t* header control is created as a UNICODE window, not an", "+\t\t* ANSI window despite the fact that the parent is created", "+\t\t* as an ANSI window.  This means that it sends UNICODE", "+\t\t* notification messages to the parent window on NT for", "+\t\t* no good reason.  The data and size in the NMHEADER and", "+\t\t* HDITEM structs is identical between the platforms so no", "+\t\t* different message is actually necessary.  Despite this,", "+\t\t* Windows sends different messages.  The fix is to look", "+\t\t* for both messages, despite the platform.  This works", "+\t\t* because only one will be sent on either platform, never", "+\t\t* both.", "+\t\t*/", "+\t\tswitch (hdr.code) {", "+\t\t\tcase OS.HDN_BEGINTRACKW:", "+\t\t\tcase OS.HDN_BEGINTRACKA:", "+\t\t\tcase OS.HDN_DIVIDERDBLCLICKW:", "+\t\t\tcase OS.HDN_DIVIDERDBLCLICKA: {", "+\t\t\t\tif (columnCount == 0) return LRESULT.ONE;", "+\t\t\t\tNMHEADER phdn = new NMHEADER ();", "+\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "+\t\t\t\tTableColumn column = columns [phdn.iItem];", "+\t\t\t\tif (column != null && !column.getResizable ()) {", "+\t\t\t\t\treturn LRESULT.ONE;", "+\t\t\t\t}", "+\t\t\t\tignoreColumnMove = true;", "+\t\t\t\tswitch (hdr.code) {", "+\t\t\t\t\tcase OS.HDN_DIVIDERDBLCLICKW:", "+\t\t\t\t\tcase OS.HDN_DIVIDERDBLCLICKA:", "+\t\t\t\t\t\tif (column != null && hooks (SWT.MeasureItem)) {", "+\t\t\t\t\t\t\tcolumn.pack ();", "+\t\t\t\t\t\t\treturn LRESULT.ONE;", "+\t\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tcase OS.NM_RELEASEDCAPTURE: {", "+\t\t\t\tif (!ignoreColumnMove) {", "+\t\t\t\t\tfor (int i=0; i<columnCount; i++) {", "+\t\t\t\t\t\tTableColumn column = columns [i];", "+\t\t\t\t\t\tcolumn.updateToolTip (i);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tignoreColumnMove = false;", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tcase OS.HDN_BEGINDRAG: {", "+\t\t\t\tif (ignoreColumnMove) return LRESULT.ONE;", "+\t\t\t\tint bits = OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);", "+\t\t\t\tif ((bits & OS.LVS_EX_HEADERDRAGDROP) == 0) break; ", "+\t\t\t\tif (columnCount == 0) return LRESULT.ONE;", "+\t\t\t\tNMHEADER phdn = new NMHEADER ();", "+\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "+\t\t\t\tif (phdn.iItem != -1) {", "+\t\t\t\t\tTableColumn column = columns [phdn.iItem];", "+\t\t\t\t\tif (column != null && !column.getMoveable ()) {", "+\t\t\t\t\t\tignoreColumnMove = true;", "+\t\t\t\t\t\treturn LRESULT.ONE;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tcase OS.HDN_ENDDRAG: {", "+\t\t\t\tint bits = OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);", "+\t\t\t\tif ((bits & OS.LVS_EX_HEADERDRAGDROP) == 0) break;", "+\t\t\t\tNMHEADER phdn = new NMHEADER ();", "+\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "+\t\t\t\tif (phdn.iItem != -1 && phdn.pitem != 0) {", "+\t\t\t\t\tHDITEM pitem = new HDITEM ();", "+\t\t\t\t\tOS.MoveMemory (pitem, phdn.pitem, HDITEM.sizeof);", "+\t\t\t\t\tif ((pitem.mask & OS.HDI_ORDER) != 0 && pitem.iOrder != -1) {", "+\t\t\t\t\t\tif (columnCount == 0) break;", "+\t\t\t\t\t\tint [] order = new int [columnCount];", "+\t\t\t\t\t\tOS.SendMessage (handle, OS.LVM_GETCOLUMNORDERARRAY, columnCount, order);", "+\t\t\t\t\t\tint index = 0;", "+\t\t\t\t\t\twhile (index < order.length) {", "+\t\t\t\t\t\t \tif (order [index] == phdn.iItem) break;", "+\t\t\t\t\t\t\tindex++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (index == order.length) index = 0;", "+\t\t\t\t\t\tif (index == pitem.iOrder) break;", "+\t\t\t\t\t\tint start = Math.min (index, pitem.iOrder);", "+\t\t\t\t\t\tint end = Math.max (index, pitem.iOrder);", "+\t\t\t\t\t\tignoreColumnMove = false;", "+\t\t\t\t\t\tfor (int i=start; i<=end; i++) {", "+\t\t\t\t\t\t\tTableColumn column = columns [order [i]];", "+\t\t\t\t\t\t\tif (!column.isDisposed ()) {", "+\t\t\t\t\t\t\t\tcolumn.postEvent (SWT.Move);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tcase OS.HDN_ITEMCHANGEDW:", "+\t\t\tcase OS.HDN_ITEMCHANGEDA: {", "+\t\t\t\t/*", "+\t\t\t\t* Bug in Windows.  When a table has the LVS_EX_GRIDLINES extended", "+\t\t\t\t* style and the user drags any column over the first column in the", "+\t\t\t\t* table, making the size become zero, when the user drags a column", "+\t\t\t\t* such that the size of the first column becomes non-zero, the grid", "+\t\t\t\t* lines are not redrawn.  The fix is to detect the case and force", "+\t\t\t\t* a redraw of the first column.", "+\t\t\t\t*/", "+\t\t\t\tint width = OS.SendMessage (handle, OS.LVM_GETCOLUMNWIDTH, 0, 0);", "+\t\t\t\tif (lastWidth == 0 && width > 0) {", "+\t\t\t\t\tint bits = OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);", "+\t\t\t\t\tif ((bits & OS.LVS_EX_GRIDLINES) != 0) {", "+\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\tOS.GetClientRect (handle, rect);", "+\t\t\t\t\t\trect.right = rect.left + width;", "+\t\t\t\t\t\tOS.InvalidateRect (handle, rect, true);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tlastWidth = width;", "+\t\t\t\tif (!ignoreColumnResize) {", "+\t\t\t\t\tNMHEADER phdn = new NMHEADER ();", "+\t\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "+\t\t\t\t\tif (phdn.pitem != 0) {", "+\t\t\t\t\t\tHDITEM pitem = new HDITEM ();", "+\t\t\t\t\t\tOS.MoveMemory (pitem, phdn.pitem, HDITEM.sizeof);", "+\t\t\t\t\t\tif ((pitem.mask & OS.HDI_WIDTH) != 0) {", "+\t\t\t\t\t\t\tTableColumn column = columns [phdn.iItem];", "+\t\t\t\t\t\t\tif (column != null) {", "+\t\t\t\t\t\t\t\tcolumn.updateToolTip (phdn.iItem);", "+\t\t\t\t\t\t\t\tcolumn.sendEvent (SWT.Resize);", "+\t\t\t\t\t\t\t\tif (isDisposed ()) return LRESULT.ZERO;", "+\t\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t\t* It is possible (but unlikely), that application", "+\t\t\t\t\t\t\t\t* code could have disposed the column in the move", "+\t\t\t\t\t\t\t\t* event.  If this happens, process the move event", "+\t\t\t\t\t\t\t\t* for those columns that have not been destroyed.", "+\t\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\t\tTableColumn [] newColumns = new TableColumn [columnCount];", "+\t\t\t\t\t\t\t\tSystem.arraycopy (columns, 0, newColumns, 0, columnCount);", "+\t\t\t\t\t\t\t\tint [] order = new int [columnCount];", "+\t\t\t\t\t\t\t\tOS.SendMessage (handle, OS.LVM_GETCOLUMNORDERARRAY, columnCount, order);", "+\t\t\t\t\t\t\t\tboolean moved = false;", "+\t\t\t\t\t\t\t\tfor (int i=0; i<columnCount; i++) {", "+\t\t\t\t\t\t\t\t\tTableColumn nextColumn = newColumns [order [i]];", "+\t\t\t\t\t\t\t\t\tif (moved && !nextColumn.isDisposed ()) {", "+\t\t\t\t\t\t\t\t\t\tnextColumn.updateToolTip (order [i]);", "+\t\t\t\t\t\t\t\t\t\tnextColumn.sendEvent (SWT.Move);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (nextColumn == column) moved = true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tcase OS.HDN_ITEMDBLCLICKW:", "+\t\t\tcase OS.HDN_ITEMDBLCLICKA: {", "+\t\t\t\tNMHEADER phdn = new NMHEADER ();", "+\t\t\t\tOS.MoveMemory (phdn, lParam, NMHEADER.sizeof);", "+\t\t\t\tTableColumn column = columns [phdn.iItem];", "+\t\t\t\tif (column != null) {", "+\t\t\t\t\tcolumn.postEvent (SWT.DefaultSelection);", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t}", "+\tLRESULT result = super.wmNotify (hdr, wParam, lParam);", "+\tif (result != null) return result;", "+\tswitch (hdr.code) {", "+\t\tcase OS.TTN_GETDISPINFOA:", "+\t\tcase OS.TTN_GETDISPINFOW: {", "+\t\t\ttipRequested = true;", "+\t\t\tint code = callWindowProc (handle, OS.WM_NOTIFY, wParam, lParam);", "+\t\t\ttipRequested = false;", "+\t\t\treturn new LRESULT (code);", "+\t\t}", "+\t}", "+\treturn result;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34d87d380647fab1e4755daee29d97d0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "475fd80af7f44f11c184ce4e415e7e668e7066c7", "commitAfterChange": "a82cf9526e3bd01c73cdc5c3786a7972e25aa4c4", "methodNumberBeforeChange": 134, "methodNumberAfterChange": 142, "signatureBeforeChange": "  LRESULT WM_NOTIFY (int wParam, int lParam)", "signatureAfterChange": "  LRESULT wmNotify (NMHDR hdr, int wParam, int lParam)", "diff": ["-LRESULT WM_NOTIFY (int wParam, int lParam) {", "-\tNMHDR hdr = new NMHDR ();", "-\tOS.MoveMemory (hdr, lParam, NMHDR.sizeof);", "+", "+LRESULT wmNotify (NMHDR hdr, int wParam, int lParam) {", "-\treturn super.WM_NOTIFY (wParam, lParam);", "+\treturn super.wmNotify (hdr, wParam, lParam);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ebc412226e0556c3b75453fe80ab2e82", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Composite.java", "commitBeforeChange": "475fd80af7f44f11c184ce4e415e7e668e7066c7", "commitAfterChange": "a82cf9526e3bd01c73cdc5c3786a7972e25aa4c4", "methodNumberBeforeChange": 58, "methodNumberAfterChange": 66, "signatureBeforeChange": "  LRESULT WM_NOTIFY (int wParam, int lParam)", "signatureAfterChange": "  LRESULT wmNotify (NMHDR hdr, int wParam, int lParam)", "diff": ["-LRESULT WM_NOTIFY (int wParam, int lParam) {", "-\tif (!OS.IsWinCE) {", "-\t\tNMHDR hdr = new NMHDR ();", "-\t\tOS.MoveMemory (hdr, lParam, NMHDR.sizeof);", "-\t\tswitch (hdr.code) {", "-\t\t\t/*", "-\t\t\t* Feature in Windows.  When the tool tip control is", "-\t\t\t* created, the parent of the tool tip is the shell.", "-\t\t\t* If SetParent () is used to reparent the tool bar", "-\t\t\t* into a new shell, the tool tip is not reparented", "-\t\t\t* and pops up underneath the new shell.  The fix is", "-\t\t\t* to make sure the tool tip is a topmost window.", "-\t\t\t*/", "-\t\t\tcase OS.TTN_SHOW:", "-\t\t\tcase OS.TTN_POP: {", "-\t\t\t\t/*", "-\t\t\t\t* Bug in Windows 98 and NT.  Setting the tool tip to be the", "-\t\t\t\t* top most window using HWND_TOPMOST can result in a parent", "-\t\t\t\t* dialog shell being moved behind its parent if the dialog", "-\t\t\t\t* has a sibling that is currently on top.  The fix is to", "-\t\t\t\t* lock the z-order of the active window.", "-\t\t\t\t* ", "-\t\t\t\t* Feature in Windows.  Using SetWindowPos() with HWND_NOTOPMOST", "-\t\t\t\t* to clear the topmost state of a window whose parent is already", "-\t\t\t\t* topmost clears the topmost state of the parent.  The fix is to", "-\t\t\t\t* check if the parent is already on top and neither set or clear", "-\t\t\t\t* the topmost status of the tool tip.", "-\t\t\t\t*/", "-\t\t\t\tint hwndParent = hdr.hwndFrom;", "-\t\t\t\tdo {", "-\t\t\t\t\thwndParent = OS.GetParent (hwndParent);", "-\t\t\t\t\tif (hwndParent == 0) break;", "-\t\t\t\t\tint bits = OS.GetWindowLong (hwndParent, OS.GWL_EXSTYLE);", "-\t\t\t\t\tif ((bits & OS.WS_EX_TOPMOST) != 0) break;", "-\t\t\t\t} while (true);", "-\t\t\t\tif (hwndParent != 0) break;", "-\t\t\t\tdisplay.lockActiveWindow = true;", "-\t\t\t\tint flags = OS.SWP_NOACTIVATE | OS.SWP_NOMOVE | OS.SWP_NOSIZE;", "-\t\t\t\tint hwndInsertAfter = hdr.code == OS.TTN_SHOW ? OS.HWND_TOPMOST : OS.HWND_NOTOPMOST;", "-\t\t\t\tSetWindowPos (hdr.hwndFrom, hwndInsertAfter, 0, 0, 0, 0, flags);", "-\t\t\t\tdisplay.lockActiveWindow = false;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\t/*", "-\t\t\t* Bug in Windows 98.  For some reason, the tool bar control", "-\t\t\t* sends both TTN_GETDISPINFOW and TTN_GETDISPINFOA to get", "-\t\t\t* the tool tip text and the tab folder control sends only ", "-\t\t\t* TTN_GETDISPINFOW.  The fix is to handle only TTN_GETDISPINFOW,", "-\t\t\t* even though it should never be sent on Windows 98.", "-\t\t\t*", "-\t\t\t* NOTE:  Because the size of NMTTDISPINFO differs between", "-\t\t\t* Windows 98 and NT, guard against the case where the wrong", "-\t\t\t* kind of message occurs by inlining the memory moves and", "-\t\t\t* the UNICODE conversion code.", "-\t\t\t*/", "-\t\t\tcase OS.TTN_GETDISPINFOA:", "-\t\t\tcase OS.TTN_GETDISPINFOW: {", "-\t\t\t\tNMTTDISPINFO lpnmtdi;", "-\t\t\t\tif (hdr.code == OS.TTN_GETDISPINFOA) {", "-\t\t\t\t\tlpnmtdi = new NMTTDISPINFOA ();", "-\t\t\t\t\tOS.MoveMemory ((NMTTDISPINFOA)lpnmtdi, lParam, NMTTDISPINFOA.sizeof);", "-\t\t\t\t} else {", "-\t\t\t\t\tlpnmtdi = new NMTTDISPINFOW ();", "-\t\t\t\t\tOS.MoveMemory ((NMTTDISPINFOW)lpnmtdi, lParam, NMTTDISPINFOW.sizeof);", "-\t\t\t\t}", "-\t\t\t\tString string = toolTipText (lpnmtdi);", "-\t\t\t\tif (string != null) {", "-\t\t\t\t\tShell shell = getShell ();", "-\t\t\t\t\tstring = Display.withCrLf (string);", "-\t\t\t\t\tint length = string.length ();", "-\t\t\t\t\tchar [] chars = new char [length + 1];", "-\t\t\t\t\tstring.getChars (0, length, chars, 0);", "-\t\t\t\t\t", "-\t\t\t\t\t/*", "-\t\t\t\t\t* Ensure that the orientation of the tool tip matches", "-\t\t\t\t\t* the orientation of the control.", "-\t\t\t\t\t*/", "-\t\t\t\t\tint hwnd = hdr.idFrom;", "-\t\t\t\t\tif (hwnd != 0 && ((lpnmtdi.uFlags & OS.TTF_IDISHWND) != 0)) {", "-\t\t\t\t\t\tControl control = display.getControl (hwnd);", "-\t\t\t\t\t\tif (control != null) {", "-\t\t\t\t\t\t\tif ((control.getStyle () & SWT.RIGHT_TO_LEFT) != 0) {", "-\t\t\t\t\t\t\t\tlpnmtdi.uFlags |= OS.TTF_RTLREADING;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tlpnmtdi.uFlags &= ~OS.TTF_RTLREADING;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\tif (hdr.code == OS.TTN_GETDISPINFOA) {", "-\t\t\t\t\t\tbyte [] bytes = new byte [chars.length * 2];", "-\t\t\t\t\t\tOS.WideCharToMultiByte (getCodePage (), 0, chars, chars.length, bytes, bytes.length, null, null);", "-\t\t\t\t\t\tshell.setToolTipText (lpnmtdi, bytes);", "-\t\t\t\t\t\tOS.MoveMemory (lParam, (NMTTDISPINFOA)lpnmtdi, NMTTDISPINFOA.sizeof);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tshell.setToolTipText (lpnmtdi, chars);", "-\t\t\t\t\t\tOS.MoveMemory (lParam, (NMTTDISPINFOW)lpnmtdi, NMTTDISPINFOW.sizeof);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn LRESULT.ZERO;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t}", "-\treturn super.WM_NOTIFY (wParam, lParam);", "-}", "+LRESULT wmNotify (NMHDR hdr, int wParam, int lParam) {", "+\tif (!OS.IsWinCE) {", "+\t\tswitch (hdr.code) {", "+\t\t\t/*", "+\t\t\t* Feature in Windows.  When the tool tip control is", "+\t\t\t* created, the parent of the tool tip is the shell.", "+\t\t\t* If SetParent () is used to reparent the tool bar", "+\t\t\t* into a new shell, the tool tip is not reparented", "+\t\t\t* and pops up underneath the new shell.  The fix is", "+\t\t\t* to make sure the tool tip is a topmost window.", "+\t\t\t*/", "+\t\t\tcase OS.TTN_SHOW:", "+\t\t\tcase OS.TTN_POP: {", "+\t\t\t\t/*", "+\t\t\t\t* Bug in Windows 98 and NT.  Setting the tool tip to be the", "+\t\t\t\t* top most window using HWND_TOPMOST can result in a parent", "+\t\t\t\t* dialog shell being moved behind its parent if the dialog", "+\t\t\t\t* has a sibling that is currently on top.  The fix is to", "+\t\t\t\t* lock the z-order of the active window.", "+\t\t\t\t* ", "+\t\t\t\t* Feature in Windows.  Using SetWindowPos() with HWND_NOTOPMOST", "+\t\t\t\t* to clear the topmost state of a window whose parent is already", "+\t\t\t\t* topmost clears the topmost state of the parent.  The fix is to", "+\t\t\t\t* check if the parent is already on top and neither set or clear", "+\t\t\t\t* the topmost status of the tool tip.", "+\t\t\t\t*/", "+\t\t\t\tint hwndParent = hdr.hwndFrom;", "+\t\t\t\tdo {", "+\t\t\t\t\thwndParent = OS.GetParent (hwndParent);", "+\t\t\t\t\tif (hwndParent == 0) break;", "+\t\t\t\t\tint bits = OS.GetWindowLong (hwndParent, OS.GWL_EXSTYLE);", "+\t\t\t\t\tif ((bits & OS.WS_EX_TOPMOST) != 0) break;", "+\t\t\t\t} while (true);", "+\t\t\t\tif (hwndParent != 0) break;", "+\t\t\t\tdisplay.lockActiveWindow = true;", "+\t\t\t\tint flags = OS.SWP_NOACTIVATE | OS.SWP_NOMOVE | OS.SWP_NOSIZE;", "+\t\t\t\tint hwndInsertAfter = hdr.code == OS.TTN_SHOW ? OS.HWND_TOPMOST : OS.HWND_NOTOPMOST;", "+\t\t\t\tSetWindowPos (hdr.hwndFrom, hwndInsertAfter, 0, 0, 0, 0, flags);", "+\t\t\t\tdisplay.lockActiveWindow = false;", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\t/*", "+\t\t\t* Bug in Windows 98.  For some reason, the tool bar control", "+\t\t\t* sends both TTN_GETDISPINFOW and TTN_GETDISPINFOA to get", "+\t\t\t* the tool tip text and the tab folder control sends only ", "+\t\t\t* TTN_GETDISPINFOW.  The fix is to handle only TTN_GETDISPINFOW,", "+\t\t\t* even though it should never be sent on Windows 98.", "+\t\t\t*", "+\t\t\t* NOTE:  Because the size of NMTTDISPINFO differs between", "+\t\t\t* Windows 98 and NT, guard against the case where the wrong", "+\t\t\t* kind of message occurs by inlining the memory moves and", "+\t\t\t* the UNICODE conversion code.", "+\t\t\t*/", "+\t\t\tcase OS.TTN_GETDISPINFOA:", "+\t\t\tcase OS.TTN_GETDISPINFOW: {", "+\t\t\t\tNMTTDISPINFO lpnmtdi;", "+\t\t\t\tif (hdr.code == OS.TTN_GETDISPINFOA) {", "+\t\t\t\t\tlpnmtdi = new NMTTDISPINFOA ();", "+\t\t\t\t\tOS.MoveMemory ((NMTTDISPINFOA)lpnmtdi, lParam, NMTTDISPINFOA.sizeof);", "+\t\t\t\t} else {", "+\t\t\t\t\tlpnmtdi = new NMTTDISPINFOW ();", "+\t\t\t\t\tOS.MoveMemory ((NMTTDISPINFOW)lpnmtdi, lParam, NMTTDISPINFOW.sizeof);", "+\t\t\t\t}", "+\t\t\t\tString string = toolTipText (lpnmtdi);", "+\t\t\t\tif (string != null) {", "+\t\t\t\t\tShell shell = getShell ();", "+\t\t\t\t\tstring = Display.withCrLf (string);", "+\t\t\t\t\tint length = string.length ();", "+\t\t\t\t\tchar [] chars = new char [length + 1];", "+\t\t\t\t\tstring.getChars (0, length, chars, 0);", "+\t\t\t\t\t", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Ensure that the orientation of the tool tip matches", "+\t\t\t\t\t* the orientation of the control.", "+\t\t\t\t\t*/", "+\t\t\t\t\tint hwnd = hdr.idFrom;", "+\t\t\t\t\tif (hwnd != 0 && ((lpnmtdi.uFlags & OS.TTF_IDISHWND) != 0)) {", "+\t\t\t\t\t\tControl control = display.getControl (hwnd);", "+\t\t\t\t\t\tif (control != null) {", "+\t\t\t\t\t\t\tif ((control.getStyle () & SWT.RIGHT_TO_LEFT) != 0) {", "+\t\t\t\t\t\t\t\tlpnmtdi.uFlags |= OS.TTF_RTLREADING;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tlpnmtdi.uFlags &= ~OS.TTF_RTLREADING;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\tif (hdr.code == OS.TTN_GETDISPINFOA) {", "+\t\t\t\t\t\tbyte [] bytes = new byte [chars.length * 2];", "+\t\t\t\t\t\tOS.WideCharToMultiByte (getCodePage (), 0, chars, chars.length, bytes, bytes.length, null, null);", "+\t\t\t\t\t\tshell.setToolTipText (lpnmtdi, bytes);", "+\t\t\t\t\t\tOS.MoveMemory (lParam, (NMTTDISPINFOA)lpnmtdi, NMTTDISPINFOA.sizeof);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tshell.setToolTipText (lpnmtdi, chars);", "+\t\t\t\t\t\tOS.MoveMemory (lParam, (NMTTDISPINFOW)lpnmtdi, NMTTDISPINFOW.sizeof);", "+\t\t\t\t\t}", "+\t\t\t\t\treturn LRESULT.ZERO;", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn super.wmNotify (hdr, wParam, lParam);", "+}"]}], "num": 41398}