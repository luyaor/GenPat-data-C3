{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b0730dea9300a62672bea7fdd3d6f921", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "de9e54f5617ea9929c238234d6af5b6e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Program/motif/org/eclipse/swt/program/Program.java", "commitBeforeChange": "e7fb43dbb2484659429530f9cab714cb6e3de9f3", "commitAfterChange": "d69b8bce251422ebdcfdac8edd7d2bcf938dfebd", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r \r private static void gnome_parseMimeFile( Hashtable info, BufferedReader reader )", "signatureAfterChange": "  private static void gnome_parseMimeFile( Hashtable info, BufferedReader reader )", "diff": ["-\r", "-private static void gnome_parseMimeFile( Hashtable info, BufferedReader reader ) {\r", "-\tVector  mimeExts = null;\r", "-\tString  mimeType = null;\r", "-\tboolean saveType = false;\r", "-\tString  line     = \"#\";\r", "-\twhile (line != null) {\r", "-\t\t\r", "-\t\t// Determine if the line contains a mime type name.\r", "-\t\tboolean newType = (line.length() > 0 && Character.isLetter( line.charAt(0) ));\r", "-\t\t\t\t  \r", "-\t\t// If there is valid data on this line to be processed\r", "-\t\tString data = line.trim();\r", "-\t\tif (data.length() > 0 && data.charAt(0) != '#') {\r", "-\t\t\t\r", "-\t\t\t// If this line defines a new mime type\r", "-\t\t\tif (newType) {\r", "-\t\t\t\t\r", "-\t\t\t\t// If a previous mime type has not be saved yet\r", "-\t\t\t\tif (mimeType != null) {\r", "-\t\t\t\t\t// Save the type and process this line again.\r", "-\t\t\t\t\tsaveType = true;\r", "-\t\t\t\t}\r", "-\t\t\t\t// else initialize the mime type info\r", "-\t\t\t\telse {\r", "-\t\t\t\t\tint colon = data.indexOf( ':' );\r", "-\t\t\t\t\tif (colon != -1) {\r", "-\t\t\t\t\t\tmimeType = data.substring( 0, colon );\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\telse {\r", "-\t\t\t\t\t\tmimeType = data;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tmimeExts = new Vector();\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\t\r", "-\t\t\t// else if the line defines a list of extensions\r", "-\t\t\telse if (data.indexOf( \"ext\" ) == 0 && mimeType != null) {\r", "-\t\t\t\t\r", "-\t\t\t\t// Get the extensions defined on the line\r", "-\t\t\t\tString exts = \"\";\r", "-\t\t\t\tint colon = data.indexOf( ':' );\r", "-\t\t\t\tif ((colon != -1) && ((colon+1) < data.length())) {\r", "-\t\t\t\t\texts = data.substring( (colon+1) ).trim();\r", "-\t\t\t\t}\r", "-\t\t\t\t\r", "-\t\t\t\t// While there are extensions to be processed\r", "-\t\t\t\texts = exts.replace( '\\t', ' ' );\r", "-\t\t\t\twhile (exts.length() != 0) {\r", "-\t\t\t\t\t// Extract the next entension from the list\r", "-\t\t\t\t\tString newExt;\r", "-\t\t\t\t\tint  space = exts.indexOf( ' ' );\r", "-\t\t\t\t\tif (space != -1) {\r", "-\t\t\t\t\t\tnewExt = exts.substring( 0, space );\r", "-\t\t\t\t\t\texts = exts.substring( space ).trim();\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\telse {\r", "-\t\t\t\t\t\tnewExt = exts;\r", "-\t\t\t\t\t\texts = \"\";\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\t\r", "-\t\t\t\t\t// Prefix an extension with a period.\r", "-\t\t\t\t\tif (newExt.charAt(0) != '.') {\r", "-\t\t\t\t\t\tnewExt = \".\" + newExt;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tmimeExts.add( newExt );\r", "-\t\t\t\t} \r", "-\t\t\t}\r", "-\t\t\t\r", "-\t\t\t// else if the line defines a list of regular expressions\r", "-\t\t\telse if (data.indexOf( \"regex\" ) == 0 && mimeType != null) {\r", "-\t\t\t\t// Do nothing with these right now.\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t\r", "-\t\t\r", "-\t\t// If the current mime type is still being processed\r", "-\t\tif (!saveType) {\r", "-\t\t\t// Get the next line\t\t\t\r", "-\t\t\ttry {\r", "-\t\t\t\tline = reader.readLine();\r", "-\t\t\t}\r", "-\t\t\tcatch (IOException e) {\r", "-\t\t\t\tline = null;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t\r", "-\t\t// If the current type should be saved or if the end\r", "-\t\t// of the file was reached\r", "-\t\tif (saveType || (line == null)) {\r", "-\r", "-\t\t\t// If there is a mime type to be saved\r", "-\t\t\tif (mimeType != null) {\r", "-\t\t\t\r", "-\t\t\t\t// If the mime type does not exist in the map, add it.\r", "-\t\t\t\tVector prevExts = (Vector) info.get( mimeType );\r", "-\t\t\t\tif (prevExts == null) {\r", "-\t\t\t\t\tinfo.put( mimeType, mimeExts );\r", "-\t\t\t\t}\r", "-\t\t\r", "-\t\t\t\t// else append the new list of extensions.\r", "-\t\t\t\telse {\r", "-\t\t\t\t\tfor (int i = 0; i < mimeExts.size(); i++) {\r", "-\t\t\t\t\t\tprevExts.add( mimeExts.elementAt( i ) );\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t\tmimeType = null;\r", "-\t\t\t\tmimeExts = null;\r", "-\t\t\t\tsaveType = false;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r", "-}\r", "+", "+private static void gnome_parseMimeFile( Hashtable info, BufferedReader reader ) {", "+\tVector  mimeExts = null;", "+\tString  mimeType = null;", "+\tboolean saveType = false;", "+\tString  line     = \"#\";", "+\twhile (line != null) {", "+\t\t", "+\t\t// Determine if the line contains a mime type name.", "+\t\tboolean newType = (line.length() > 0 && Character.isLetter( line.charAt(0) ));", "+\t\t\t\t  ", "+\t\t// If there is valid data on this line to be processed", "+\t\tString data = line.trim();", "+\t\tif (data.length() > 0 && data.charAt(0) != '#') {", "+\t\t\t", "+\t\t\t// If this line defines a new mime type", "+\t\t\tif (newType) {", "+\t\t\t\t", "+\t\t\t\t// If a previous mime type has not be saved yet", "+\t\t\t\tif (mimeType != null) {", "+\t\t\t\t\t// Save the type and process this line again.", "+\t\t\t\t\tsaveType = true;", "+\t\t\t\t}", "+\t\t\t\t// else initialize the mime type info", "+\t\t\t\telse {", "+\t\t\t\t\tint colon = data.indexOf( ':' );", "+\t\t\t\t\tif (colon != -1) {", "+\t\t\t\t\t\tmimeType = data.substring( 0, colon );", "+\t\t\t\t\t}", "+\t\t\t\t\telse {", "+\t\t\t\t\t\tmimeType = data;", "+\t\t\t\t\t}", "+\t\t\t\t\tmimeExts = new Vector();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\t// else if the line defines a list of extensions", "+\t\t\telse if (data.indexOf( \"ext\" ) == 0 && mimeType != null) {", "+\t\t\t\t", "+\t\t\t\t// Get the extensions defined on the line", "+\t\t\t\tString exts = \"\";", "+\t\t\t\tint colon = data.indexOf( ':' );", "+\t\t\t\tif ((colon != -1) && ((colon+1) < data.length())) {", "+\t\t\t\t\texts = data.substring( (colon+1) ).trim();", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// While there are extensions to be processed (use space as separator)", "+\t\t\t\texts = exts.replace( '\\t', ' ' );", "+\t\t\t\texts = exts.replace( ',', ' ' );", "+\t\t\t\twhile (exts.length() != 0) {", "+\t\t\t\t\t// Extract the next entension from the list", "+\t\t\t\t\tString newExt;", "+\t\t\t\t\tint  space = exts.indexOf( ' ' );", "+\t\t\t\t\tif (space != -1) {", "+\t\t\t\t\t\tnewExt = exts.substring( 0, space );", "+\t\t\t\t\t\texts = exts.substring( space ).trim();", "+\t\t\t\t\t}", "+\t\t\t\t\telse {", "+\t\t\t\t\t\tnewExt = exts;", "+\t\t\t\t\t\texts = \"\";", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// Prefix an extension with a period.", "+\t\t\t\t\tif (newExt.charAt(0) != '.') {", "+\t\t\t\t\t\tnewExt = \".\" + newExt;", "+\t\t\t\t\t}", "+\t\t\t\t\tmimeExts.add( newExt );", "+\t\t\t\t} ", "+\t\t\t}", "+\t\t\t", "+\t\t\t// else if the line defines a list of regular expressions", "+\t\t\telse if (data.indexOf( \"regex\" ) == 0 && mimeType != null) {", "+\t\t\t\t// Do nothing with these right now.", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t", "+\t\t// If the current mime type is still being processed", "+\t\tif (!saveType) {", "+\t\t\t// Get the next line\t\t\t", "+\t\t\ttry {", "+\t\t\t\tline = reader.readLine();", "+\t\t\t}", "+\t\t\tcatch (IOException e) {", "+\t\t\t\tline = null;", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// If the current type should be saved or if the end", "+\t\t// of the file was reached", "+\t\tif (saveType || (line == null)) {", "+\t\t\t// If there is a mime type to be saved", "+\t\t\tif (mimeType != null) {", "+\t\t\t", "+\t\t\t\t// If the mime type does not exist in the map, add it.", "+\t\t\t\tVector prevExts = (Vector) info.get( mimeType );", "+\t\t\t\tif (prevExts == null) {", "+\t\t\t\t\tinfo.put( mimeType, mimeExts );", "+\t\t\t\t}", "+\t\t", "+\t\t\t\t// else append the new list of extensions.", "+\t\t\t\telse {", "+\t\t\t\t\tfor (int i = 0; i < mimeExts.size(); i++) {", "+\t\t\t\t\t\tprevExts.add( mimeExts.elementAt( i ) );", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tmimeType = null;", "+\t\t\tmimeExts = null;", "+\t\t\tsaveType = false;", "+\t\t}", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c13d8bfa4de32e11e4dd760a75f855ff", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "1c5467f79f5b1c73782459594b2f72f13320a777", "commitAfterChange": "177f753d5ec596f70989cac04629c9317b4bac19", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public Image (Device device, String filename)", "signatureAfterChange": " public Image (Device device, String filename)", "diff": ["-\t\t\t\t\tGdip.Bitmap_GetHICON(bitmap, hicon);", "+\t\t\t\t\tstatus = Gdip.Bitmap_GetHICON(bitmap, hicon);", "-\t\t\t\t\t\t\tGdip.Bitmap_LockBits(bitmap, 0, 0, pixelFormat, lockedBitmapData);", "-\t\t\t\t\t\t\tBitmapData bitmapData = new BitmapData();", "-\t\t\t\t\t\t\tGdip.MoveMemory(bitmapData, lockedBitmapData);", "-\t\t\t\t\t\t\tint stride = bitmapData.Stride;", "-\t\t\t\t\t\t\tint /*long*/ pixels = bitmapData.Scan0;", "-\t\t\t\t\t\t\tint depth = 0, scanlinePad = 4, transparentPixel = -1;", "-\t\t\t\t\t\t\tswitch (bitmapData.PixelFormat) {", "-\t\t\t\t\t\t\t\tcase Gdip.PixelFormat1bppIndexed: depth = 1; break;", "-\t\t\t\t\t\t\t\tcase Gdip.PixelFormat4bppIndexed: depth = 4; break;", "-\t\t\t\t\t\t\t\tcase Gdip.PixelFormat8bppIndexed: depth = 8; break;", "-\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppARGB1555:", "-\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppRGB555:", "-\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppRGB565: depth = 16; break;", "-\t\t\t\t\t\t\t\tcase Gdip.PixelFormat24bppRGB: depth = 24; break;", "-\t\t\t\t\t\t\t\tcase Gdip.PixelFormat32bppRGB:", "-\t\t\t\t\t\t\t\tcase Gdip.PixelFormat32bppARGB: depth = 32; break;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (depth != 0) {", "-\t\t\t\t\t\t\t\tPaletteData paletteData = null;", "+\t\t\t\t\t\t\tstatus = Gdip.Bitmap_LockBits(bitmap, 0, 0, pixelFormat, lockedBitmapData);", "+\t\t\t\t\t\t\tif (status == 0) {", "+\t\t\t\t\t\t\t\tBitmapData bitmapData = new BitmapData();", "+\t\t\t\t\t\t\t\tGdip.MoveMemory(bitmapData, lockedBitmapData);", "+\t\t\t\t\t\t\t\tint stride = bitmapData.Stride;", "+\t\t\t\t\t\t\t\tint /*long*/ pixels = bitmapData.Scan0;", "+\t\t\t\t\t\t\t\tint depth = 0, scanlinePad = 4, transparentPixel = -1;", "-\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat1bppIndexed:", "-\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat4bppIndexed:", "-\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat8bppIndexed:", "-\t\t\t\t\t\t\t\t\t\tint paletteSize = Gdip.Image_GetPaletteSize(bitmap);", "-\t\t\t\t\t\t\t\t\t\tint /*long*/ hHeap = OS.GetProcessHeap();", "-\t\t\t\t\t\t\t\t\t\tint /*long*/ palette = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, paletteSize);", "-\t\t\t\t\t\t\t\t\t\tif (palette == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "-\t\t\t\t\t\t\t\t\t\tGdip.Image_GetPalette(bitmap, palette, paletteSize);", "-\t\t\t\t\t\t\t\t\t\tColorPalette colorPalette = new ColorPalette();", "-\t\t\t\t\t\t\t\t\t\tGdip.MoveMemory(colorPalette, palette, ColorPalette.sizeof);", "-\t\t\t\t\t\t\t\t\t\tint[] entries = new int[colorPalette.Count];", "-\t\t\t\t\t\t\t\t\t\tOS.MoveMemory(entries, palette + 8, entries.length * 4);", "-\t\t\t\t\t\t\t\t\t\tOS.HeapFree(hHeap, 0, palette);", "-\t\t\t\t\t\t\t\t\t\tRGB[] rgbs = new RGB[colorPalette.Count];", "-\t\t\t\t\t\t\t\t\t\tpaletteData = new PaletteData(rgbs);", "-\t\t\t\t\t\t\t\t\t\tfor (int i = 0; i < entries.length; i++) {", "-\t\t\t\t\t\t\t\t\t\t\tif (((entries[i] >> 24) & 0xFF) == 0 && (colorPalette.Flags & Gdip.PaletteFlagsHasAlpha) != 0) {", "-\t\t\t\t\t\t\t\t\t\t\t\ttransparentPixel = i;", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\trgbs[i] = new RGB(((entries[i] & 0xFF0000) >> 16), ((entries[i] & 0xFF00) >> 8), ((entries[i] & 0xFF) >> 0));", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat1bppIndexed: depth = 1; break;", "+\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat4bppIndexed: depth = 4; break;", "+\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat8bppIndexed: depth = 8; break;", "-\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppRGB555: paletteData = new PaletteData(0x7C00, 0x3E0, 0x1F); break;", "-\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppRGB565: paletteData = new PaletteData(0xF800, 0x7E0, 0x1F); break;", "-\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat24bppRGB: paletteData = new PaletteData(0xFF, 0xFF00, 0xFF0000); break;", "+\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppRGB555:", "+\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppRGB565: depth = 16; break;", "+\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat24bppRGB: depth = 24; break;", "-\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat32bppARGB: paletteData = new PaletteData(0xFF00, 0xFF0000, 0xFF000000); break;", "+\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat32bppARGB: depth = 32; break;", "-\t\t\t\t\t\t\t\tbyte[] data = new byte[stride * height], alphaData = null;", "-\t\t\t\t\t\t\t\tOS.MoveMemory(data, pixels, data.length);", "-\t\t\t\t\t\t\t\tswitch (bitmapData.PixelFormat) {", "-\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppARGB1555:", "-\t\t\t\t\t\t \t\t \t\talphaData = new byte[width * height];", "-\t\t\t\t\t\t \t\t \t\tfor (int i = 1, j = 0; i < data.length; i += 2, j++) {", "-\t\t\t\t\t\t \t\t \t\t\talphaData[j] = (byte)((data[i] & 0x80) != 0 ? 255 : 0);", "-\t\t\t\t\t\t \t\t \t\t}", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat32bppARGB:", "-\t\t\t\t\t\t \t\t \t\talphaData = new byte[width * height];", "-\t\t\t\t\t\t \t\t \t\tfor (int i = 3, j = 0; i < data.length; i += 4, j++) {", "-\t\t\t\t\t\t \t\t \t\t\talphaData[j] = data[i];", "-\t\t\t\t\t\t \t\t \t\t}", "-\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tif (depth != 0) {", "+\t\t\t\t\t\t\t\t\tPaletteData paletteData = null;", "+\t\t\t\t\t\t\t\t\tswitch (bitmapData.PixelFormat) {", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat1bppIndexed:", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat4bppIndexed:", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat8bppIndexed:", "+\t\t\t\t\t\t\t\t\t\t\tint paletteSize = Gdip.Image_GetPaletteSize(bitmap);", "+\t\t\t\t\t\t\t\t\t\t\tint /*long*/ hHeap = OS.GetProcessHeap();", "+\t\t\t\t\t\t\t\t\t\t\tint /*long*/ palette = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, paletteSize);", "+\t\t\t\t\t\t\t\t\t\t\tif (palette == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\t\t\t\t\t\t\t\t\t\tGdip.Image_GetPalette(bitmap, palette, paletteSize);", "+\t\t\t\t\t\t\t\t\t\t\tColorPalette colorPalette = new ColorPalette();", "+\t\t\t\t\t\t\t\t\t\t\tGdip.MoveMemory(colorPalette, palette, ColorPalette.sizeof);", "+\t\t\t\t\t\t\t\t\t\t\tint[] entries = new int[colorPalette.Count];", "+\t\t\t\t\t\t\t\t\t\t\tOS.MoveMemory(entries, palette + 8, entries.length * 4);", "+\t\t\t\t\t\t\t\t\t\t\tOS.HeapFree(hHeap, 0, palette);", "+\t\t\t\t\t\t\t\t\t\t\tRGB[] rgbs = new RGB[colorPalette.Count];", "+\t\t\t\t\t\t\t\t\t\t\tpaletteData = new PaletteData(rgbs);", "+\t\t\t\t\t\t\t\t\t\t\tfor (int i = 0; i < entries.length; i++) {", "+\t\t\t\t\t\t\t\t\t\t\t\tif (((entries[i] >> 24) & 0xFF) == 0 && (colorPalette.Flags & Gdip.PaletteFlagsHasAlpha) != 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\ttransparentPixel = i;", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\trgbs[i] = new RGB(((entries[i] & 0xFF0000) >> 16), ((entries[i] & 0xFF00) >> 8), ((entries[i] & 0xFF) >> 0));", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppARGB1555:", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppRGB555: paletteData = new PaletteData(0x7C00, 0x3E0, 0x1F); break;", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppRGB565: paletteData = new PaletteData(0xF800, 0x7E0, 0x1F); break;", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat24bppRGB: paletteData = new PaletteData(0xFF, 0xFF00, 0xFF0000); break;", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat32bppRGB:", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat32bppARGB: paletteData = new PaletteData(0xFF00, 0xFF0000, 0xFF000000); break;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tbyte[] data = new byte[stride * height], alphaData = null;", "+\t\t\t\t\t\t\t\t\tOS.MoveMemory(data, pixels, data.length);", "+\t\t\t\t\t\t\t\t\tswitch (bitmapData.PixelFormat) {", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat16bppARGB1555:", "+\t\t\t\t\t\t\t \t\t \t\talphaData = new byte[width * height];", "+\t\t\t\t\t\t\t \t\t \t\tfor (int i = 1, j = 0; i < data.length; i += 2, j++) {", "+\t\t\t\t\t\t\t \t\t \t\t\talphaData[j] = (byte)((data[i] & 0x80) != 0 ? 255 : 0);", "+\t\t\t\t\t\t\t \t\t \t\t}", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\tcase Gdip.PixelFormat32bppARGB:", "+\t\t\t\t\t\t\t \t\t \t\talphaData = new byte[width * height];", "+\t\t\t\t\t\t\t \t\t \t\tfor (int i = 3, j = 0; i < data.length; i += 4, j++) {", "+\t\t\t\t\t\t\t \t\t \t\t\talphaData[j] = data[i];", "+\t\t\t\t\t\t\t \t\t \t\t}", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tImageData img = new ImageData(width, height, depth, paletteData, scanlinePad, data);", "+\t\t\t\t\t\t\t\t\timg.transparentPixel = transparentPixel;", "+\t\t\t\t\t\t\t\t\timg.alphaData = alphaData;", "+\t\t\t\t\t\t\t\t\tinit(img);", "-\t\t\t\t\t\t\t\tGdip.BitmapData_delete(lockedBitmapData);", "-\t\t\t\t\t\t\t\tImageData img = new ImageData(width, height, depth, paletteData, scanlinePad, data);", "-\t\t\t\t\t\t\t\timg.transparentPixel = transparentPixel;", "-\t\t\t\t\t\t\t\timg.alphaData = alphaData;", "-\t\t\t\t\t\t\t\tinit(img);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\terror = SWT.ERROR_INVALID_IMAGE;\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tGdip.BitmapData_delete(lockedBitmapData);"]}], "num": 42305}