{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d8624f7a757f52bc93057fe600e7b999", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a64ae5a83b8b63f3e5674bff88199c44", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "da556c9b17830907056468c4948706802ae67161", "commitAfterChange": "f658aef2494ee6a768d79c1b2ced077e25523979", "methodNumberBeforeChange": 102, "methodNumberAfterChange": 102, "signatureBeforeChange": "  public void update ()", "signatureAfterChange": "  public void update ()", "diff": ["-\tcheckDevice ();", "-\tint [] outEvent = new int [1];", "-\tint [] mask = new int [] {OS.kEventClassWindow, OS.kEventWindowUpdate};", "-\twhile (OS.ReceiveNextEvent (mask.length / 2, mask, OS.kEventDurationNoWait, true, outEvent) == OS.noErr) {", "-\t\t/*", "-\t\t* Bug in the Macintosh.  For some reason, when a hierarchy of", "-\t\t* windows is disposed from kEventWindowClose, despite the fact", "-\t\t* that DisposeWindow() has been called, the window is not", "-\t\t* disposed and there are outstandings kEventWindowUpdate events", "-\t\t* in the event queue.  Dispatching these events will cause a", "-\t\t* segment fault.  The fix is to dispatch events to visible", "-\t\t* windows only.", "-\t\t*/", "-\t\tint [] theWindow = new int [1];", "-\t\tOS.GetEventParameter (outEvent [0], OS.kEventParamDirectObject, OS.typeWindowRef, null, 4, null, theWindow);", "-\t\tif (OS.IsWindowVisible (theWindow [0])) OS.SendEventToEventTarget (outEvent [0], OS.GetEventDispatcherTarget ());", "-\t\tOS.ReleaseEvent (outEvent [0]);", "+\tcheckDevice ();\t", "+\tShell [] shells = getShells ();", "+\tfor (int i=0; i<shells.length; i++) {", "+\t\tShell shell = shells [i];", "+\t\tif (!shell.isDisposed ()) shell.update ();", "+\t/*", "+\t* This code is intentionally commented.", "+\t*/", "+//\tint [] outEvent = new int [1];", "+//\tint [] mask = new int [] {OS.kEventClassWindow, OS.kEventWindowUpdate};", "+//\twhile (OS.ReceiveNextEvent (mask.length / 2, mask, OS.kEventDurationNoWait, true, outEvent) == OS.noErr) {", "+//\t\t/*", "+//\t\t* Bug in the Macintosh.  For some reason, when a hierarchy of", "+//\t\t* windows is disposed from kEventWindowClose, despite the fact", "+//\t\t* that DisposeWindow() has been called, the window is not", "+//\t\t* disposed and there are outstandings kEventWindowUpdate events", "+//\t\t* in the event queue.  Dispatching these events will cause a", "+//\t\t* segment fault.  The fix is to dispatch events to visible", "+//\t\t* windows only.", "+//\t\t*/", "+//\t\tint [] theWindow = new int [1];", "+//\t\tOS.GetEventParameter (outEvent [0], OS.kEventParamDirectObject, OS.typeWindowRef, null, 4, null, theWindow);", "+//\t\tif (OS.IsWindowVisible (theWindow [0])) OS.SendEventToEventTarget (outEvent [0], OS.GetEventDispatcherTarget ());", "+//\t\tOS.ReleaseEvent (outEvent [0]);", "+//\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "51cb400883e24c1894d71d525953ede8", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/ToolItem.java", "commitBeforeChange": "be7a6b56ec36f2937282f99ce8f6d3a09d752bb5", "commitAfterChange": "388089e4bec9dc7b9e91ccd2ec44faabbba9290c", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "  int kEventControlHitTest (int nextHandler, int theEvent, int userData)", "signatureAfterChange": "  int kEventControlHitTest (int nextHandler, int theEvent, int userData)", "diff": ["-\tif (OS.HIVIEW) {", "-\t\t/*", "-\t\t* Feature in the Macintosh.  When kWindowCompositingAttribute is", "-\t\t* set in the window, controls within the window are selected when", "-\t\t* any button is pressed, not just the left one.  When the control", "-\t\t* has a menu, this causes both selection and a menu to be displayed.", "-\t\t* The fix is to check for button two and avoid setting the part", "-\t\t* code, which stops the selection from happening.", "-\t\t*/\t\t", "-\t\tif (display.clickCountButton == 2) return OS.noErr;", "-\t\tint [] theControl = new int [1];", "-\t\tOS.GetEventParameter (theEvent, OS.kEventParamDirectObject, OS.typeControlRef, null, 4, null, theControl);", "-\t\tif (theControl [0] == labelHandle) {", "-\t\t\tCGRect rect = new CGRect ();", "-\t\t\tOS.HIViewGetBounds (labelHandle, rect);", "-\t\t\tCGPoint pt = new CGPoint ();", "-\t\t\tOS.GetEventParameter (theEvent, OS.kEventParamMouseLocation, OS.typeHIPoint, null, CGPoint.sizeof, null, pt);", "-\t\t\tif (OS.CGRectContainsPoint (rect, pt) != 0) {", "-\t\t\t\tOS.SetEventParameter (theEvent, OS.kEventParamControlPart, OS.typeControlPartCode, 2, new short[]{(short)1});", "-\t\t\t\treturn OS.noErr;", "-\t\t\t}", "+\t/*", "+\t* Feature in the Macintosh.  When kWindowCompositingAttribute is", "+\t* set in the window, controls within the window are selected when", "+\t* any button is pressed, not just the left one.  When the control", "+\t* has a menu, this causes both selection and a menu to be displayed.", "+\t* The fix is to check for button two and avoid setting the part", "+\t* code, which stops the selection from happening.", "+\t*/\t\t", "+\tif (display.clickCountButton == 2) return OS.noErr;", "+\tint [] theControl = new int [1];", "+\tOS.GetEventParameter (theEvent, OS.kEventParamDirectObject, OS.typeControlRef, null, 4, null, theControl);", "+\tif (theControl [0] == labelHandle) {", "+\t\tCGRect rect = new CGRect ();", "+\t\tOS.HIViewGetBounds (labelHandle, rect);", "+\t\tCGPoint pt = new CGPoint ();", "+\t\tOS.GetEventParameter (theEvent, OS.kEventParamMouseLocation, OS.typeHIPoint, null, CGPoint.sizeof, null, pt);", "+\t\tif (OS.CGRectContainsPoint (rect, pt) != 0) {", "+\t\t\tOS.SetEventParameter (theEvent, OS.kEventParamControlPart, OS.typeControlPartCode, 2, new short[]{(short)1});", "+\t\t\treturn OS.noErr;"]}], "num": 31113}