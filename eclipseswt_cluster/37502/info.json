{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c49d19e99afe25b4407e5d1088c175c1", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f95765303bae0dae225e61e02a661d97", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "dabb371250244a42d0a102e16d31217d0a0ef72f", "commitAfterChange": "ce13f951d0206a463a1d2938b51a330c2557de6c", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-\t/* Calculate the palette depending on the display attributes */\r", "-\tPaletteData palette = null;\r", "-\t/* Get the data for the source image. */\r", "+\t/* Get the data and palette of the source image. */\r", "+\tPaletteData palette = null;\r", "-\tswitch (xSrcImage.depth) {\r", "+\tswitch (xSrcImage.bits_per_pixel) {\r", "-\t\t\t/**\r", "-\t\t\t * We currently don't run on a 4-bit server, so 4-bit images\r", "-\t\t\t * should not exist.\r", "-\t\t\t */\r", "+\t\t\t/*\r", "+\t\t\t* We currently don't run on a 4-bit server, so 4-bit images\r", "+\t\t\t* should not exist.\r", "+\t\t\t*/\r", "-\t\t\t * pixel values sequential starting at pixel 0). Reserve normalized \r", "-\t\t\t * pixel 0 so that it maps to real pixel 0. This assumes pixel 0 is \r", "-\t\t\t * always used in the image.\r", "-\t\t\t */\r", "-\t\t\tbyte[] normPixel = new byte[ 256 ];\r", "+\t\t\t* pixel values sequential starting at pixel 0). Reserve normalized \r", "+\t\t\t* pixel 0 so that it maps to real pixel 0. This assumes pixel 0 is \r", "+\t\t\t* always used in the image.\r", "+\t\t\t*/\r", "+\t\t\tbyte[] normPixel = new byte[256];\r", "-\t\t\t\tnormPixel[ index ] = 0;\r", "+\t\t\t\tnormPixel[index] = 0;\r", "-\t\t\t\t\tint srcPixel = srcData[ index + x ] & 0xFF;\r", "-\t\t\t\t\tif (srcPixel != 0 && normPixel[ srcPixel ] == 0) {\r", "-\t\t\t\t\t\tnormPixel[ srcPixel ] = (byte)numPixels++;\r", "+\t\t\t\t\tint srcPixel = srcData[index + x] & 0xFF;\r", "+\t\t\t\t\tif (srcPixel != 0 && normPixel[srcPixel] == 0) {\r", "+\t\t\t\t\t\tnormPixel[srcPixel] = (byte)numPixels++;\r", "-\t\t\t\t\tsrcData[ index + x ] = normPixel[ srcPixel ];\r", "+\t\t\t\t\tsrcData[index + x] = normPixel[srcPixel];\r", "-\t\t\tRGB[] rgbs = new RGB[ numPixels ];\r", "+\t\t\tRGB[] rgbs = new RGB[numPixels];\r", "-\t\t\t\t// If the pixel value was used in the image, get its RGB values.\r", "-\t\t\t\tif (srcPixel == 0 || normPixel[ srcPixel ] != 0) {\r", "+\t\t\t\t/* If the pixel value was used in the image, get its RGB values. */\r", "+\t\t\t\tif (srcPixel == 0 || normPixel[srcPixel] != 0) {\r", "-\t\t\t\t\tint rgbIndex = normPixel[ srcPixel ] & 0xFF;\r", "-\t\t\t\t\trgbs[ rgbIndex ] = new RGB((color.red >> 8) & 0xFF, (color.green >> 8) & 0xFF, (color.blue >> 8) & 0xFF);\r", "+\t\t\t\t\tint rgbIndex = normPixel[srcPixel] & 0xFF;\r", "+\t\t\t\t\trgbs[rgbIndex] = new RGB((color.red >> 8) & 0xFF, (color.green >> 8) & 0xFF, (color.blue >> 8) & 0xFF);\r", "-\t\t\t/**\r", "-\t\t\t * For some reason, the XImage does not have the mask information.\r", "-\t\t\t * We must get it from the visual.\r", "-\t\t\t */\r", "-\t\t\tint visual = OS.XDefaultVisual(xDisplay, OS.XDefaultScreen(xDisplay));\r", "-\t\t\tVisual v = new Visual();\r", "-\t\t\tOS.memmove(v, visual, Visual.sizeof);\r", "-\t\t\tpalette = new PaletteData(v.red_mask, v.green_mask, v.blue_mask);\r", "+\t\t\t/* Byte swap the data if necessary */\r", "+\t\t\tif (xSrcImage.byte_order == OS.MSBFirst) {\r", "+\t\t\t\tfor (int i = 0; i < srcData.length; i += 2) {\r", "+\t\t\t\t\tbyte b = srcData[i];\r", "+\t\t\t\t\tsrcData[i] = srcData[i+1];\r", "+\t\t\t\t\tsrcData[i+1] = b;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "-\t\t\t/* We always create 24-bit ImageData with the following palette */\r", "-\t\t\tpalette = new PaletteData(0xFF, 0xFF00, 0xFF0000);\r", "+\t\t\tbreak;\r", "+\t\tcase 32:\r", "+\t\t\t/* Byte swap the data if necessary */\r", "+\t\t\tif (xSrcImage.byte_order == OS.LSBFirst) {\r", "+\t\t\t\tfor (int i = 0; i < srcData.length; i += 4) {\r", "+\t\t\t\t\tbyte b = srcData[i];\r", "+\t\t\t\t\tsrcData[i] = srcData[i+3];\r", "+\t\t\t\t\tsrcData[i+3] = b;\r", "+\t\t\t\t\tb = srcData[i+1];\r", "+\t\t\t\t\tsrcData[i+1] = srcData[i+2];\r", "+\t\t\t\t\tsrcData[i+2] = b;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "-\tImageData data = new ImageData(width, height, xSrcImage.depth, palette);\r", "+\tif (palette == null) {\r", "+\t\t/*\r", "+\t\t* For some reason, the XImage does not have the mask information.\r", "+\t\t* We must get it from the defualt visual.\r", "+\t\t*/\r", "+\t\tint visual = OS.XDefaultVisual(xDisplay, OS.XDefaultScreen(xDisplay));\r", "+\t\tVisual v = new Visual();\r", "+\t\tOS.memmove(v, visual, Visual.sizeof);\r", "+\t\tpalette = new PaletteData(v.red_mask, v.green_mask, v.blue_mask);\r", "+\t}\t\r", "+\tImageData data = new ImageData(width, height, xSrcImage.bits_per_pixel, palette);\r", "-\tif (xSrcImage.bits_per_pixel == 32) {\r", "-\t\t/**\r", "-\t\t * If bits per pixel is 32, scale the data down to 24, since we do not\r", "-\t\t * support 32-bit images\r", "-\t\t */\r", "-\t\tbyte[] oldData = data.data;\r", "-\t\tint bytesPerLine = (xSrcImage.width * xSrcImage.depth + 7) / 8;\r", "-\t\tbytesPerLine = (bytesPerLine + 3) / 4 * 4;\r", "-\t\tbyte[] newData = new byte[bytesPerLine * xSrcImage.height];\r", "-\t\tint destIndex = 0;\r", "-\t\tint srcIndex = 0;\r", "-\t\tint rOffset = 0, gOffset = 1, bOffset = 2;\r", "-\t\tif (xSrcImage.byte_order == OS.MSBFirst) {\r", "-\t\t\trOffset = 3; gOffset = 2; bOffset = 1;\r", "-\t\t}\r", "-\t\tfor (int y = 0; y < height; y++) {\r", "-\t\t\tdestIndex = y * bytesPerLine;\r", "-\t\t\tsrcIndex = y * xSrcImage.bytes_per_line;\r", "-\t\t\tfor (int x = 0; x < width; x++) {\r", "-\t\t\t\tnewData[destIndex] = oldData[srcIndex + rOffset];\r", "-\t\t\t\tnewData[destIndex + 1] = oldData[srcIndex + gOffset];\r", "-\t\t\t\tnewData[destIndex + 2] = oldData[srcIndex + bOffset];\r", "-\t\t\t\tsrcIndex += 4;\r", "-\t\t\t\tdestIndex += 3;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\tdata.data = newData;\r", "-\t}\r", "-\t\t/* Get the icon data */\r", "+\t\t/* Get the icon mask data */\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7b7c9dd436a457a806fea8773cd6b10d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 12, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-\tRectangle srcBounds = getBounds();", "-\tint width = srcBounds.width;", "-\tint height = srcBounds.height;", "-    int srcDepth= getDepth(pixmap);", "-\t/* Get the data for the source image. */", "-    int srcRowBytes= rowBytes(width, srcDepth);", "-    int srcBitsPerPixel= srcDepth;", "-\tbyte[] srcData = new byte[srcRowBytes * height];", "- \tcopyPixMapData(pixmap, srcData);", "-", "-\t/* Build the palette */", "-\tPaletteData palette = null;", "-\tswitch (srcDepth) {", "-\tcase 1:", "-\t\tpalette = new PaletteData(new RGB[] {", "-\t\t\tnew RGB(0, 0, 0),", "-\t\t\tnew RGB(255, 255, 255)", "-\t\t});", "-\t\tbreak;", "-\tcase 4:", "-\t\tshort[] colorTable4= getColorTable(pixmap);", "-\t\tRGB[] rgbs4 = new RGB[ colorTable4.length/4 ];", "-\t\tfor (int i = 0; i < rgbs4.length; i++) {", "-\t\t\tint packed= getRGB(colorTable4, i);", "-\t\t\trgbs4[i] = new RGB((packed >> 16) & 0xFF, (packed >> 8) & 0xFF, (packed >> 0) & 0xFF);", "-\t\t}", "-\t\tpalette = new PaletteData(rgbs4);", "-\t\tbreak;", "-\tcase 8:", "-\t\t/* Normalize the pixels in the source image data (by making the", "-\t\t * pixel values sequential starting at pixel 0). Reserve normalized", "-\t\t * pixel 0 so that it maps to real pixel 0. This assumes pixel 0 is", "-\t\t * always used in the image.", "-\t\t */", "-\t\tbyte[] normPixel = new byte[ 256 ];", "-\t\tfor (int index = 0; index < normPixel.length; index++) {", "-\t\t\tnormPixel[ index ] = 0;", "-\t\t}", "-\t\tint numPixels = 1;", "-\t\tint index = 0;", "-\t\tfor (int y = 0; y < height; y++) {", "-\t\t\tfor (int x = 0; x < srcRowBytes; x++) {", "-\t\t\t\tint srcPixel = srcData[ index + x ] & 0xFF;", "-\t\t\t\tif (srcPixel != 0 && normPixel[ srcPixel ] == 0) {", "-\t\t\t\t\tnormPixel[ srcPixel ] = (byte)numPixels++;", "-\t\t\t\t}", "-\t\t\t\tsrcData[ index + x ] = normPixel[ srcPixel ];", "-\t\t\t}", "-\t\t\tindex += srcRowBytes;", "-\t\t}", "-\t\t", "-\t\tshort[] colorTable= getColorTable(pixmap);", "-", "-\t\t/* Create a palette with only the RGB values used in the image. */", "-\t\tRGB[] rgbs = new RGB[ numPixels ];", "-\t\tfor (int srcPixel = 0; srcPixel < normPixel.length; srcPixel++) {", "-\t\t\t// If the pixel value was used in the image, get its RGB values.", "-\t\t\tif (srcPixel == 0 || normPixel[ srcPixel ] != 0) {", "-\t\t\t\tint packed= getRGB(colorTable, srcPixel);", "-\t\t\t\tint rgbIndex = normPixel[ srcPixel ] & 0xFF;", "-\t\t\t\trgbs[ rgbIndex ] = new RGB((packed >> 16) & 0xFF, (packed >> 8) & 0xFF, (packed >> 0) & 0xFF);\t\t\t\t\t", "-\t\t\t}", "-\t\t}", "-\t\tpalette = new PaletteData(rgbs);", "-\t\tbreak;", "-\tcase 16:", "-\tcase 24:", "-\tcase 32:", "-\t\tpalette = new PaletteData(getRedMask(srcDepth), getGreenMask(srcDepth), getBlueMask(srcDepth));", "-\t\tbreak;", "-\tdefault:", "-\t\tSWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);", "-\t}", "+\tint width = OS.CGImageGetWidth(handle);", "+\tint height = OS.CGImageGetHeight(handle);", "+\tint bpr = OS.CGImageGetBytesPerRow(handle);", "+\tint bpp = OS.CGImageGetBitsPerPixel(handle);\t", "+\tint dataSize = height * bpr;", "+\tbyte[] srcData = new byte[dataSize];", "+\tOS.memcpy(srcData, data, dataSize);", "-\t", "-\tImageData data = new ImageData(width, height, srcDepth, palette);", "+\tPaletteData palette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "+\tImageData data = new ImageData(width, height, bpp, palette);", "-\tif (false && srcBitsPerPixel == 32) {", "-\t\t/*", "-\t\t * If bits per pixel is 32, scale the data down to 24, since we do not", "-\t\t * support 32-bit images", "-\t\t */", "-\t\tbyte[] oldData = data.data;", "-\t\tint bytesPerLine = (width * srcDepth + 7) / 8;", "-\t\tbytesPerLine = (bytesPerLine + 3) / 4 * 4;", "-\t\tbyte[] newData = new byte[bytesPerLine * height];", "-\t\tint destIndex = 0;", "-\t\tint srcIndex = 0;", "-\t\t", "-\t\tfor (int y = 0; y < height; y++) {", "-\t\t\tdestIndex = y * bytesPerLine;", "-\t\t\tsrcIndex = y * srcRowBytes;", "-\t\t\tfor (int x = 0; x < width; x++) {", "-\t\t\t\tnewData[destIndex] = oldData[srcIndex + 1];", "-\t\t\t\tnewData[destIndex + 1] = oldData[srcIndex + 2];", "-\t\t\t\tnewData[destIndex + 2] = oldData[srcIndex + 3];", "-\t\t\t\tsrcIndex += 4;", "-\t\t\t\tdestIndex += 3;", "-\t\t\t}", "-\t\t}", "-\t\tdata.data = newData;", "-\t}", "-\tif (transparentPixel == -1 && type == SWT.ICON && mask != 0) {", "-\t\t/* Get the icon data */", "-\t\tdata.maskPad = 4;", "-\t\tint maskRowBytes= rowBytes(width, getDepth(mask));", "-\t\tdata.maskData = new byte[maskRowBytes * height];", "-\t\tcopyPixMapData(mask, data.maskData);", "-\t}", "+\tdata.bytesPerLine = bpr;", "+", "+\tif (transparentPixel == -1 && type == SWT.ICON) {", "+\t\t/* Get the icon mask data */", "+\t\tint maskBpl = (((width + 7) / 8) + 3) / 4 * 4;", "+\t\tbyte[] maskData = new byte[height * maskBpl];", "+\t\tint offset = 0, maskOffset = 0;", "+\t\tfor (int y = 0; y<height; y++) {", "+\t\t\tfor (int x = 0; x<width; x++) {", "+\t\t\t\tif (srcData[offset] != 0) {", "+\t\t\t\t\tmaskData[maskOffset + (x >> 3)] |= (1 << (7 - (x & 0x7)));", "+\t\t\t\t} else {", "+\t\t\t\t\tmaskData[maskOffset + (x >> 3)] &= ~(1 << (7 - (x & 0x7)));", "+\t\t\t\t}", "+\t\t\t\toffset += 4;", "+\t\t\t}", "+\t\t\tmaskOffset += maskBpl;", "+\t\t}", "+\t\tdata.maskData = maskData;", "+\t\tdata.maskPad = 4;", "+\t}"]}], "num": 37502}