{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "025a57c30c94f8b6aabd0c25c2412145", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f863892cfe45c033d3598aa4ca391c0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "58170bb06a19d7661085f57b92c3ae426e201011", "commitAfterChange": "8be22dc2b78ffeb154903e0098801be64c70e841", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "\r boolean filterEvent (XAnyEvent event)", "signatureAfterChange": "\r boolean filterEvent (XAnyEvent event)", "diff": ["-\t/* Filter the event for the IME */\r", "-\tif (!OS.IsLinux) {\r", "-\t\tif (keysym == OS.XK_Return || keysym == OS.XK_KP_Enter) {\r", "+\t/* \r", "+\t* Bug in AIX.  If XFilterEvent() is called for every key event, accelerators\r", "+\t* do not work. XFilterEvent() is needed on AIX to invoke the default button.\r", "+\t* The fix is to call XFilterEvent() only for return keys. This means that an\r", "+\t* accelerator that is only a return key will not work.\r", "+\t*/\r", "+\tif (keysym == OS.XK_Return || keysym == OS.XK_KP_Enter) {\r", "+\t\t/*\r", "+\t\t* Bug in Linux. If XFilter() is called more than once for the same\r", "+\t\t* event, it causes an infinite loop.  The fix to remember the serial\r", "+\t\t* number and never call XFilterEvent() twice for the same event.\r", "+\t\t*/\r", "+\t\tif (event.serial != lastSerial) {\t\r", "+\t\t\tlastSerial = event.serial;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ee78ac929709f7d38fd1bc8c7243dbd", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "9157d9c3ce6daf2cc17d693dc5c1e738bd00ba0f", "commitAfterChange": "636645cd71825a27e2f84e61e7bf769366dad642", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 60, "signatureBeforeChange": "\r \r int messageProc (int hwnd, int msg, int wParam, int lParam)", "signatureAfterChange": "\r \r int messageProc (int hwnd, int msg, int wParam, int lParam)", "diff": ["-\t\t\tif (wParam == 1) {\r", "+\t\t\t/*\r", "+\t\t\t* Feature in Windows.  When multiple shells are\r", "+\t\t\t* disabled and one of the shells has an enabled\r", "+\t\t\t* dialog child and the user selects a disabled\r", "+\t\t\t* shell that does not have the enabled dialog\r", "+\t\t\t* child using the Task bar, Windows brings the\r", "+\t\t\t* disabled shell to the front.  As soon as the\r", "+\t\t\t* user clicks on the disabled shell, the enabled\r", "+\t\t\t* dialog child comes to the front.  This behavior\r", "+\t\t\t* is unspecified and seems strange.  Normally, a\r", "+\t\t\t* disabled shell is frozen on the screen and the\r", "+\t\t\t* user cannot change the z-order by clicking with\r", "+\t\t\t* the mouse.  The fix is to look for WM_ACTIVATEAPP\r", "+\t\t\t* and force the enabled dialog child to the front.\r", "+\t\t\t* This is typically what the user is expecting.\r", "+\t\t\t*/\r", "+\t\t\tif (wParam != 0) {\r"]}], "num": 11214}