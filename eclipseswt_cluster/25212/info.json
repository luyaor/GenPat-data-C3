{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cb58f851a466d7b06c8d08829ca036be", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "17a44075c66e047d1cbd5ca697a93bfb", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "e7fb43dbb2484659429530f9cab714cb6e3de9f3", "commitAfterChange": "d69b8bce251422ebdcfdac8edd7d2bcf938dfebd", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["+\t\r", "+\t/* Get the data for the source image. */\r", "+\tint length = xSrcImage.bytes_per_line * xSrcImage.height;\r", "+\tbyte[] srcData = new byte[length];\r", "+\tOS.memmove(srcData, xSrcImage.data, length);\r", "-\t\t\t/* Use the RGBs from the display to make the palette */\r", "-\t\t\tXColor[] xcolors = device.xcolors;\r", "-\t\t\tRGB[] rgbs = new RGB[xcolors.length];\r", "-\t\t\tfor (int i = 0; i < rgbs.length; i++) {\r", "-\t\t\t\tXColor xcolor = xcolors[i];\r", "-\t\t\t\tif (xcolor == null) rgbs[i] = new RGB(0, 0, 0);\r", "-\t\t\t\telse rgbs[i] = new RGB((xcolor.red >> 8) & 0xFF, (xcolor.green >> 8) & 0xFF, (xcolor.blue >> 8) & 0xFF);\r", "+\t\t\t/* Normalize the pixels in the source image data (by making the \r", "+\t\t\t * pixel values sequential starting at pixel 0). Reserve normalized \r", "+\t\t\t * pixel 0 so that it maps to real pixel 0. This assumes pixel 0 is \r", "+\t\t\t * always used in the image.\r", "+\t\t\t */\r", "+\t\t\tbyte[] normPixel = new byte[ 256 ];\r", "+\t\t\tfor (int index = 0; index < normPixel.length; index++) {\r", "+\t\t\t\tnormPixel[ index ] = 0;\r", "+\t\t\t}\r", "+\t\t\tint numPixels = 1;\r", "+\t\t\tint index = 0;\r", "+\t\t\tfor (int y = 0; y < xSrcImage.height; y++) {\r", "+\t\t\t\tfor (int x = 0; x < xSrcImage.bytes_per_line; x++) {\r", "+\t\t\t\t\tint srcPixel = srcData[ index + x ] & 0xFF;\r", "+\t\t\t\t\tif (srcPixel != 0 && normPixel[ srcPixel ] == 0) {\r", "+\t\t\t\t\t\tnormPixel[ srcPixel ] = (byte)numPixels++;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tsrcData[ index + x ] = normPixel[ srcPixel ];\r", "+\t\t\t\t}\r", "+\t\t\t\tindex += xSrcImage.bytes_per_line;\r", "+\t\t\t}\r", "+\t\t\t\r", "+\t\t\t/* Create a palette with only the RGB values used in the image. */\r", "+\t\t\tint colormap = OS.XDefaultColormap(xDisplay, OS.XDefaultScreen(xDisplay));\r", "+\t\t\tRGB[] rgbs = new RGB[ numPixels ];\r", "+\t\t\tXColor color = new XColor();\r", "+\t\t\tfor (int srcPixel = 0; srcPixel < normPixel.length; srcPixel++) {\r", "+\t\t\t\t// If the pixel value was used in the image, get its RGB values.\r", "+\t\t\t\tif (srcPixel == 0 || normPixel[ srcPixel ] != 0) {\r", "+\t\t\t\t\tcolor.pixel = srcPixel;\r", "+\t\t\t\t\tOS.XQueryColor(xDisplay, colormap, color);\r", "+\t\t\t\t\tint rgbIndex = normPixel[ srcPixel ] & 0xFF;\r", "+\t\t\t\t\trgbs[ rgbIndex ] = new RGB((color.red >> 8) & 0xFF, (color.green >> 8) & 0xFF, (color.blue >> 8) & 0xFF);\r", "+\t\t\t\t}\r", "-\tint length = xSrcImage.bytes_per_line * xSrcImage.height;\r", "-\tdata.data = new byte[length];\r", "-\tOS.memmove(data.data, xSrcImage.data, length);\r", "+\tdata.data = srcData;\r", "-\t\t\trOffset = 2; gOffset = 1; bOffset = 0;\r", "+\t\t\trOffset = 3; gOffset = 2; bOffset = 1;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5515b2186acd90a231ad5fd0955e91e3", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/treetable/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "ed6471c0ec0d0ee0c1436d2bdeadc8ba513ab4fd", "commitAfterChange": "034d8fba7f4ca7576ddaeee539a2fb56ee664327", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 17, "signatureBeforeChange": " void drawColumnResizeLine(int xPosition)", "signatureAfterChange": " void destroyItem (TableColumn column)", "diff": ["+void destroyItem (TableColumn column) {", "+\tint numColumns = columns.length;", "+\tint index = column.getIndex ();", "+\tTableColumn[] newColumns = new TableColumn [columns.length - 1];", "+\tSystem.arraycopy (columns, 0, newColumns, 0, index);", "+\tSystem.arraycopy (columns, index + 1, newColumns, index, newColumns.length - index);", "+\tcolumns = newColumns;", "+", "+\t/* allow all items to update their internal structures accordingly */", "+\tfor (int i = 0; i < items.length; i++) {", "+\t\titems [i].removeColumn (column, index);", "+\t/* update horizontal scrollbar */", "+\tint lastColumnIndex = columns.length - 1;", "+\tif (lastColumnIndex < 0) {\t\t/* no more columns */", "+\t\tupdateHorizontalBar ();", "+\t} else {", "+\t\tint newWidth = 0;", "+\t\tfor (int i = 0; i < columns.length; i++) {", "+\t\t\tnewWidth += columns [i].width;", "+\t\t}", "+\t\tScrollBar hBar = getHorizontalBar (); ", "+\t\thBar.setMaximum (newWidth);", "+\t\thBar.setVisible (getClientArea ().width < newWidth);", "+\t\tint selection = hBar.getSelection ();", "+\t\tif (selection != horizontalOffset) {", "+\t\t\thorizontalOffset = selection;", "+\t\t\tredraw ();", "+\tfor (int i = index; i < columns.length; i++) {", "+\t\tEvent event = new Event ();", "+\t\tevent.widget = columns [i];", "+\t\tcolumns [i].sendEvent (SWT.Move, event);", "+\t}", "- */", "-void drawColumnResizeLine(int xPosition) {", "-\tGC gc = new GC(this);", "-\tint lineHeight = getClientArea().height;", "-\tint lineWidth = getGridLineWidth();", "-\t", "-\tredraw(getColumnResizeX() - lineWidth, 0, 1, lineHeight, false);", "-\tsetColumnResizeX(xPosition);", "-\tgc.drawLine(xPosition - lineWidth, 0, xPosition - lineWidth, lineHeight);", "-\tgc.dispose();", "-}"]}], "num": 25212}