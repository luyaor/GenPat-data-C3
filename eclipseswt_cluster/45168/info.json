{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a0d227af6fb5c2f0168983349fa7d05a", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1a2ef0b53d792ea75262b2d6e3103a99", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples/src/org/eclipse/swt/examples/fileviewer/TreeDropFeedbackListener.java", "commitBeforeChange": "f49332c775fa13aa2d8bdf58dbda00cc4dbee67f", "commitAfterChange": "e19f3ee2e5f1fa5577672314ef96ca3ab839cf03", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r\tpublic void dragEnter(DropTargetEvent event)", "signatureAfterChange": "\r\tpublic void dragEnter(DropTargetEvent event)", "diff": ["-package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tpublic static final long DEFAULT_EXPAND_DELAY = 1000; // millis\r\r\tprivate Tree     tree;\r\tprivate long     hoverThreshhold = DEFAULT_EXPAND_DELAY;\t\r\tprivate long     hoverBegin = 0;\r\tprivate TreeItem hoverItem = null;\r\t\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Get the item directly under the point\r\t\tTreeItem item = tree.getItem(point);\r\t\tif (item == null) return;\r\r\t\t// Expand the item if we've been hovering over it for some time\r\t\tif (item != hoverItem) {\r\t\t\t// We just started hovering, remember this item\r\t\t\tif ((item != null) && (! item.getExpanded())) {\r\t\t\t\thoverBegin = System.currentTimeMillis();\r\t\t\t\thoverItem = item;\r\t\t\t} else {\r\t\t\t\thoverItem = null;\r\t\t\t}\r\t\t} else if (hoverItem != null) {\r\t\t\t// We've been hovering for a while, expand if our timer elapsed\r\t\t\tlong hoverCurrent = System.currentTimeMillis();\r\t\t\tif (hoverCurrent - hoverBegin >= hoverThreshhold) {\r\t\t\t\t// Fake as if the user expanded the item manually\r\t\t\t\tEvent hoverEvent = new Event();\r\t\t\t\thoverEvent.x = event.x;\r\t\t\t\thoverEvent.y = event.y;\r\t\t\t\thoverEvent.item = hoverItem;\r\t\t\t\thoverEvent.time = (int) hoverCurrent;\r\t\t\t\thoverItem.setExpanded(true);\r\t\t\t\thoverItem = null;\r\t\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t\t\treturn;\r\t\t\t}\r\t\t}\r\r\t\t// Determine scroll direction according to whether we're nearer the top, middle, or bottom\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize < 8) return; // don't scroll if the control is too small to make sense\r\t\t\r\t\tTreeItem showItem = item;\r\t\tfor(;;) {\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tshowItem = getPreviousVisibleItem(tree, showItem);\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tshowItem = getNextVisibleItem(tree, showItem, false);\r\t\t\t} else {\r\t\t\t\t// in middle region\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\t\r\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\tif (showItem == null) break;\t\t\r\t\t\ttree.showItem(showItem);\r\t\t\t\r\t\t\t// Test that we actually scrolled, if we didn't try again with the next item\r\t\t\tif (item != tree.getItem(point)) break;\r\t\t}\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file", "+package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = tree.getItem(point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\r\t\t/*\r\t\t * Determine the candidate action for this position: nothing, scroll or expand\r\t\t */\r\t\thoverRunnable = null;\r\t\tif (hoverItem == null) return; // Nothing to do\r\r\t\t// Consider scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\t/**\r\t * Implements scrolling on a timer\r\t */\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Scroll\");\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tif (hoverItem != tree.getItem(hoverPoint)) return; // stop if we actually scrolled\r\t\t\t}\r\t\t\t\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\t/**\r\t * Implements expanding on a timer\r\t */\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Expand\");\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1146da7932b738b82a654a3e84ffb6ea", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples/org/eclipse/swt/examples/fileviewer/TreeDropFeedbackListener.java", "commitBeforeChange": "f49332c775fa13aa2d8bdf58dbda00cc4dbee67f", "commitAfterChange": "e19f3ee2e5f1fa5577672314ef96ca3ab839cf03", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r\tpublic void dragEnter(DropTargetEvent event)", "signatureAfterChange": "\r\tpublic void dragEnter(DropTargetEvent event)", "diff": ["-package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tpublic static final long DEFAULT_EXPAND_DELAY = 1000; // millis\r\r\tprivate Tree     tree;\r\tprivate long     hoverThreshhold = DEFAULT_EXPAND_DELAY;\t\r\tprivate long     hoverBegin = 0;\r\tprivate TreeItem hoverItem = null;\r\t\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Get the item directly under the point\r\t\tTreeItem item = tree.getItem(point);\r\t\tif (item == null) return;\r\r\t\t// Expand the item if we've been hovering over it for some time\r\t\tif (item != hoverItem) {\r\t\t\t// We just started hovering, remember this item\r\t\t\tif ((item != null) && (! item.getExpanded())) {\r\t\t\t\thoverBegin = System.currentTimeMillis();\r\t\t\t\thoverItem = item;\r\t\t\t} else {\r\t\t\t\thoverItem = null;\r\t\t\t}\r\t\t} else if (hoverItem != null) {\r\t\t\t// We've been hovering for a while, expand if our timer elapsed\r\t\t\tlong hoverCurrent = System.currentTimeMillis();\r\t\t\tif (hoverCurrent - hoverBegin >= hoverThreshhold) {\r\t\t\t\t// Fake as if the user expanded the item manually\r\t\t\t\tEvent hoverEvent = new Event();\r\t\t\t\thoverEvent.x = event.x;\r\t\t\t\thoverEvent.y = event.y;\r\t\t\t\thoverEvent.item = hoverItem;\r\t\t\t\thoverEvent.time = (int) hoverCurrent;\r\t\t\t\thoverItem.setExpanded(true);\r\t\t\t\thoverItem = null;\r\t\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t\t\treturn;\r\t\t\t}\r\t\t}\r\r\t\t// Determine scroll direction according to whether we're nearer the top, middle, or bottom\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize < 8) return; // don't scroll if the control is too small to make sense\r\t\t\r\t\tTreeItem showItem = item;\r\t\tfor(;;) {\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tshowItem = getPreviousVisibleItem(tree, showItem);\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tshowItem = getNextVisibleItem(tree, showItem, false);\r\t\t\t} else {\r\t\t\t\t// in middle region\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\t\r\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\tif (showItem == null) break;\t\t\r\t\t\ttree.showItem(showItem);\r\t\t\t\r\t\t\t// Test that we actually scrolled, if we didn't try again with the next item\r\t\t\tif (item != tree.getItem(point)) break;\r\t\t}\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file", "+package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = tree.getItem(point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\r\t\t/*\r\t\t * Determine the candidate action for this position: nothing, scroll or expand\r\t\t */\r\t\thoverRunnable = null;\r\t\tif (hoverItem == null) return; // Nothing to do\r\r\t\t// Consider scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\t/**\r\t * Implements scrolling on a timer\r\t */\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Scroll\");\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tif (hoverItem != tree.getItem(hoverPoint)) return; // stop if we actually scrolled\r\t\t\t}\r\t\t\t\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\t/**\r\t * Implements expanding on a timer\r\t */\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Expand\");\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bed58abe5afc2cea9596c71df5d3d4f5", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples/org/eclipse/swt/examples/fileviewer/TreeDropFeedbackListener.java", "commitBeforeChange": "f49332c775fa13aa2d8bdf58dbda00cc4dbee67f", "commitAfterChange": "e19f3ee2e5f1fa5577672314ef96ca3ab839cf03", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r\tpublic void dragExit(DropTargetEvent event)", "signatureAfterChange": "\r\tpublic void dragExit(DropTargetEvent event)", "diff": ["-package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tpublic static final long DEFAULT_EXPAND_DELAY = 1000; // millis\r\r\tprivate Tree     tree;\r\tprivate long     hoverThreshhold = DEFAULT_EXPAND_DELAY;\t\r\tprivate long     hoverBegin = 0;\r\tprivate TreeItem hoverItem = null;\r\t\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Get the item directly under the point\r\t\tTreeItem item = tree.getItem(point);\r\t\tif (item == null) return;\r\r\t\t// Expand the item if we've been hovering over it for some time\r\t\tif (item != hoverItem) {\r\t\t\t// We just started hovering, remember this item\r\t\t\tif ((item != null) && (! item.getExpanded())) {\r\t\t\t\thoverBegin = System.currentTimeMillis();\r\t\t\t\thoverItem = item;\r\t\t\t} else {\r\t\t\t\thoverItem = null;\r\t\t\t}\r\t\t} else if (hoverItem != null) {\r\t\t\t// We've been hovering for a while, expand if our timer elapsed\r\t\t\tlong hoverCurrent = System.currentTimeMillis();\r\t\t\tif (hoverCurrent - hoverBegin >= hoverThreshhold) {\r\t\t\t\t// Fake as if the user expanded the item manually\r\t\t\t\tEvent hoverEvent = new Event();\r\t\t\t\thoverEvent.x = event.x;\r\t\t\t\thoverEvent.y = event.y;\r\t\t\t\thoverEvent.item = hoverItem;\r\t\t\t\thoverEvent.time = (int) hoverCurrent;\r\t\t\t\thoverItem.setExpanded(true);\r\t\t\t\thoverItem = null;\r\t\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t\t\treturn;\r\t\t\t}\r\t\t}\r\r\t\t// Determine scroll direction according to whether we're nearer the top, middle, or bottom\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize < 8) return; // don't scroll if the control is too small to make sense\r\t\t\r\t\tTreeItem showItem = item;\r\t\tfor(;;) {\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tshowItem = getPreviousVisibleItem(tree, showItem);\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tshowItem = getNextVisibleItem(tree, showItem, false);\r\t\t\t} else {\r\t\t\t\t// in middle region\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\t\r\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\tif (showItem == null) break;\t\t\r\t\t\ttree.showItem(showItem);\r\t\t\t\r\t\t\t// Test that we actually scrolled, if we didn't try again with the next item\r\t\t\tif (item != tree.getItem(point)) break;\r\t\t}\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file", "+package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = tree.getItem(point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\r\t\t/*\r\t\t * Determine the candidate action for this position: nothing, scroll or expand\r\t\t */\r\t\thoverRunnable = null;\r\t\tif (hoverItem == null) return; // Nothing to do\r\r\t\t// Consider scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\t/**\r\t * Implements scrolling on a timer\r\t */\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Scroll\");\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tif (hoverItem != tree.getItem(hoverPoint)) return; // stop if we actually scrolled\r\t\t\t}\r\t\t\t\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\t/**\r\t * Implements expanding on a timer\r\t */\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Expand\");\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "77fba7f3ed9fb502aaed497cf37dd0ea", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples/src/org/eclipse/swt/examples/fileviewer/TreeDropFeedbackListener.java", "commitBeforeChange": "f49332c775fa13aa2d8bdf58dbda00cc4dbee67f", "commitAfterChange": "e19f3ee2e5f1fa5577672314ef96ca3ab839cf03", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r\tpublic void dragExit(DropTargetEvent event)", "signatureAfterChange": "\r\tpublic void dragExit(DropTargetEvent event)", "diff": ["-package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tpublic static final long DEFAULT_EXPAND_DELAY = 1000; // millis\r\r\tprivate Tree     tree;\r\tprivate long     hoverThreshhold = DEFAULT_EXPAND_DELAY;\t\r\tprivate long     hoverBegin = 0;\r\tprivate TreeItem hoverItem = null;\r\t\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Get the item directly under the point\r\t\tTreeItem item = tree.getItem(point);\r\t\tif (item == null) return;\r\r\t\t// Expand the item if we've been hovering over it for some time\r\t\tif (item != hoverItem) {\r\t\t\t// We just started hovering, remember this item\r\t\t\tif ((item != null) && (! item.getExpanded())) {\r\t\t\t\thoverBegin = System.currentTimeMillis();\r\t\t\t\thoverItem = item;\r\t\t\t} else {\r\t\t\t\thoverItem = null;\r\t\t\t}\r\t\t} else if (hoverItem != null) {\r\t\t\t// We've been hovering for a while, expand if our timer elapsed\r\t\t\tlong hoverCurrent = System.currentTimeMillis();\r\t\t\tif (hoverCurrent - hoverBegin >= hoverThreshhold) {\r\t\t\t\t// Fake as if the user expanded the item manually\r\t\t\t\tEvent hoverEvent = new Event();\r\t\t\t\thoverEvent.x = event.x;\r\t\t\t\thoverEvent.y = event.y;\r\t\t\t\thoverEvent.item = hoverItem;\r\t\t\t\thoverEvent.time = (int) hoverCurrent;\r\t\t\t\thoverItem.setExpanded(true);\r\t\t\t\thoverItem = null;\r\t\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t\t\treturn;\r\t\t\t}\r\t\t}\r\r\t\t// Determine scroll direction according to whether we're nearer the top, middle, or bottom\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize < 8) return; // don't scroll if the control is too small to make sense\r\t\t\r\t\tTreeItem showItem = item;\r\t\tfor(;;) {\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tshowItem = getPreviousVisibleItem(tree, showItem);\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tshowItem = getNextVisibleItem(tree, showItem, false);\r\t\t\t} else {\r\t\t\t\t// in middle region\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\t\r\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\tif (showItem == null) break;\t\t\r\t\t\ttree.showItem(showItem);\r\t\t\t\r\t\t\t// Test that we actually scrolled, if we didn't try again with the next item\r\t\t\tif (item != tree.getItem(point)) break;\r\t\t}\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file", "+package org.eclipse.swt.examples.fileviewer;\r\r/*\r * (c) Copyright IBM Corp. 2000, 2001.\r * All Rights Reserved\r */\r\rimport org.eclipse.swt.*;\rimport org.eclipse.swt.dnd.*;\rimport org.eclipse.swt.graphics.*;\rimport org.eclipse.swt.widgets.*;\r\r/**\r * TreeDropFeedbackListener provides the following feedback mechanisms for Trees\r * during drag and drop operations:\r * <ul>\r * <li>Automatic Tree scrolling.\r *     <p>If the pointer drags over an item in the Tree near its upper or\r *     lower edges, the Tree will scroll so as to make previous or successive items visible\r *     onscreen.  This behaviour is consistent with that of popular GUI systems.\r *     </p>\r * <li>Automatic TreeItem expansion.\r *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been\r *     expanded, the item is expanded automatically.  This behaviour is consistent with\r *     that of popular GUI systems.\r *     </p>\r * </ul>\r * <p>\r * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget\r * object attached to the Tree.\r * </p>\r */\rpublic class TreeDropFeedbackListener extends DropTargetAdapter {\r\tprotected static final int EXPAND_DELAY = 750; // millis\r\tprotected static final int SCROLL_DELAY = 50; // millis\r\tprotected static final int MAX_SCROLL_TRIES = 3; \r\r\tprotected Tree     tree;\r\tprotected TreeItem hoverItem = null;\r\tprotected Point    hoverPoint = null;\r\tprotected Runnable hoverRunnable = null;\r\tprotected long     hoverResumeTime = 0;\r\r\t/**\r\t * Constructs a Tree scrolling Drop Listener\r\t * \r\t * @param tree the Tree that the DropTarget is attached to\r\t */\r\tpublic TreeDropFeedbackListener(Tree tree) {\r\t\tthis.tree = tree;\r\t}\r\r\t/**\r\t * Handles dragEnter events.\r\t */\r\tpublic void dragEnter(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragExit events.\r\t */\r\tpublic void dragExit(DropTargetEvent event) {\r\t\thoverItem = null;\r\t\thoverRunnable = null;\r\t}\r\r\t/**\r\t * Handles dragOver events.\r\t * <p>\r\t * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.\r\t * But we can't get timerExec()'s.<br>\r\t * <br>\r\t * On Motif, we only get dragOver()'s when the mouse has actually moved.\r\t * But timerExec()'s are processed as usual.<br>\r\t * <br>\r\t * So to ensure cross-platform UI consistency we must handle both cases!\r\t * </p>\r\t */\r\tpublic void dragOver(DropTargetEvent event) {\r\t\tPoint point = tree.toControl(new Point(event.x, event.y));\r\r\t\t// Fetch the item we're hovering over\r\t\tTreeItem item = tree.getItem(point);\r\t\tif ((hoverRunnable != null) && (item == hoverItem)) {\r\t\t\tif (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();\r\t\t\treturn;\r\t\t}\r\t\thoverItem = item;\r\t\thoverPoint = point;\r\r\t\t/*\r\t\t * Determine the candidate action for this position: nothing, scroll or expand\r\t\t */\r\t\thoverRunnable = null;\r\t\tif (hoverItem == null) return; // Nothing to do\r\r\t\t// Consider scrolling\r\t\tRectangle clientArea = tree.getClientArea();\r\t\tint scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts\r\t\tif (scrollRegionSize >= 8) {\r\t\t\t// Decide scroll direction according to whether we're nearer the top, middle, or bottom\r\t\t\tif (point.y < clientArea.y + scrollRegionSize) {\r\t\t\t\t// in upper region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(true));\r\t\t\t\treturn;\r\t\t\t} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {\r\t\t\t\t// in lower region\r\t\t\t\tsetTimer(SCROLL_DELAY, new ScrollRunnable(false));\r\t\t\t\treturn;\r\t\t\t}\r\t\t\t// else we are in middle region\r\t\t}\r\t\t// else the region is too small for scrolling\r\r\t\ttryExpand(0);\r\t}\r\tprivate void tryExpand(int recoverTime) {\r\t\t// Expand the item if it hasn't already been expanded\r\t\tif (! hoverItem.getExpanded()) {\r\t\t\tsetTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());\r\t\t}\r\t}\r\tprivate void setTimer(int delay, Runnable runnable) {\r\t\thoverRunnable = runnable;\r\t\thoverResumeTime = System.currentTimeMillis() + delay;\r\t\ttree.getDisplay().timerExec(delay, hoverRunnable);\r\t}\r\r\t/**\r\t * Implements scrolling on a timer\r\t */\r\tprivate class ScrollRunnable implements Runnable {\r\t\tboolean isScrollUp;\r\t\tpublic ScrollRunnable(boolean isScrollUp) {\r\t\t\tthis.isScrollUp = isScrollUp;\r\t\t}\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Scroll\");\r\r\t\t\t// Loop until we see a different item (abort after a few tries, just in case)\r\t\t\tTreeItem showItem = hoverItem;\r\t\t\tfor (int i = MAX_SCROLL_TRIES; i > 0; --i) {\r\t\t\t\tshowItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :\r\t\t\t\t\tgetNextVisibleItem(tree, showItem, false);\t\r\t\t\t\r\t\t\t\t// Show the item (causes a scroll if it is outside of the visible region)\r\t\t\t\tif (showItem == null) break;\r\t\t\t\ttree.showItem(showItem);\r\t\t\t\t\r\t\t\t\tif (hoverItem != tree.getItem(hoverPoint)) return; // stop if we actually scrolled\r\t\t\t}\r\t\t\t\r\t\t\t// We get here if we failed to scroll\r\t\t\ttryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed\r\t\t}\r\t}\t\t\t\r\t\r\t/**\r\t * Implements expanding on a timer\r\t */\r\tprivate class ExpandRunnable implements Runnable {\r\t\tpublic void run() {\r\t\t\tif (hoverRunnable != this) return;\r\t\t\thoverRunnable = null;\r\t\t\tif (hoverItem.isDisposed()) return; // this can happen due to other events\r\t\t\tSystem.out.println(\"Expand\");\r\r\t\t\t// Fake as if the user expanded the item manually\r\t\t\tEvent hoverEvent = new Event();\r\t\t\thoverEvent.x = hoverPoint.x;\r\t\t\thoverEvent.y = hoverPoint.y;\r\t\t\thoverEvent.item = hoverItem;\r\t\t\thoverEvent.time = (int) System.currentTimeMillis();\r\t\t\thoverItem.setExpanded(true);\r\t\t\ttree.notifyListeners(SWT.Expand, hoverEvent);\r\t\t}\r\t}\t\t\t\r\r\t/**\r\t * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose previous visible neighbour is to be found\r\t * @return the previous visible item, or null if none.\r\t */\r\tprivate TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = items.length - 1; i > 0; --i) {\r\t\t\t\tif (items[i] == item) return getLastVisibleChild(items[i - 1]);\r\t\t\t}\r\t\t}\r\t\treturn parent;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param tree the Tree containing the items\r\t * @param item the TreeItem whose next visible neighbour is to be found\r\t * @return the next visible item, or null if none.\r\t */\r\tprivate TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {\r\t\tTreeItem parent = item.getParentItem();\r\t\tTreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();\r\t\tif (items != null) {\r\t\t\tfor (int i = 0; i < items.length; ++i) {\r\t\t\t\tif (items[i] == item) {\r\t\t\t\t\tif (! ignoreChildren && items[i].getExpanded()) {\r\t\t\t\t\t\titems = items[i].getItems();\r\t\t\t\t\t\tif (items != null && items.length > 0) return items[0];\r\t\t\t\t\t}\r\t\t\t\t\tif (i + 1 < items.length) return items[i + 1];\r\t\t\t\t\tbreak;\r\t\t\t\t}\r\t\t\t}\r\t\t\tif (parent != null) return getNextVisibleItem(tree, parent, true);\r\t\t}\r\t\treturn null;\r\t}\r\r\t/**\r\t * Given a TreeItem, locates its last (lowest) visible item\r\t * <p>\r\t * Note that the item may not be actually rendered onscreen though it would be\r\t * visible were the control scrolled appropriately.\r\t * </p>\r\t * \r\t * @param item the TreeItem whose last visible child is to be found\r\t * @return the last visible child, or <code>item</code> if no visible children.\r\t */\r\tprivate TreeItem getLastVisibleChild(TreeItem item) {\r\t\tif (! item.getExpanded()) return item;\r\t\t\r\t\tTreeItem[] items = item.getItems();\r\t\tif (items == null || items.length == 0) return item;\r\t\treturn getLastVisibleChild(items[items.length - 1]);\r\t}\r}\r", "\\ No newline at end of file"]}], "num": 45168}