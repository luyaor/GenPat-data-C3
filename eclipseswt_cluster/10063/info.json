{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a6999c7b394a67a64c61f35c73cb03ca", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "05d77ebedfa958d741373de715029fd0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void copyArea(int x, int y, int width, int height, int destX, int destY)", "signatureAfterChange": " public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY)", "diff": ["-public void copyArea(int x, int y, int width, int height, int destX, int destY) {", "-\tif (handle == 0) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);", "-\tif (width <= 0 || height <= 0) return;", "-\tint deltaX = destX - x, deltaY = destY - y;", "-\tif (deltaX == 0 && deltaY == 0) return;", "-\t\t", "-\tRectangle src= new Rectangle(x, y, width, height);", "-\tsrc= src.union(new Rectangle(destX, destY, width, height));", "-\tMacRect r= new MacRect(src);", "-\t", "-\ttry {", "-\t\tif (focus(true, null)) {", "-\t\t\tint rgn= OS.NewRgn();", "-\t\t\tOS.ScrollRect(r.getData(), (short)deltaX, (short)deltaY, rgn);", "-\t\t\tOS.InvalWindowRgn(OS.GetWindowFromPort(handle), rgn);", "-\t\t\tOS.DisposeRgn(rgn);", "-\t\t}", "-\t} finally {", "-\t\tunfocus(true);", "-\t}", "+ */", "+public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY) {", "+\tif (handle == 0) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);", "+\tif (width <= 0 || height <= 0) return;", "+\tint deltaX = destX - srcX, deltaY = destY - srcY;", "+\tif (deltaX == 0 && deltaY == 0) return;", "+\tif (data.image != null) {", "+ \t\tOS.CGContextSaveGState(handle);", "+ \t\tOS.CGContextScaleCTM(handle, 1, -1);", "+ \t\tOS.CGContextTranslateCTM(handle, 0, -(height + 2 * destY));", "+ \t\tCGRect rect = new CGRect();", "+ \t\trect.x = destX;", "+ \t\trect.y = destY;", "+ \t\trect.width = width;", "+\t\trect.height = height;", "+\t\t//NOT DONE - transparency", "+ \t\tOS.CGContextDrawImage(handle, rect, data.image.handle);", "+ \t\tOS.CGContextRestoreGState(handle);", "+ \t\treturn;", "+\t}", "+\tif (data.control != 0) {", "+\t\tint window = OS.GetControlOwner(data.control);", "+\t\tint port = OS.GetWindowPort(window);", "+", "+\t\t/* Calculate src and dest rectangles/regions */", "+\t\tRect rect = new Rect();", "+\t\tOS.GetControlBounds(data.control, rect);\t\t", "+\t\tRect srcRect = new Rect();", "+\t\tOS.GetControlBounds(data.control, srcRect);", "+\t\tint left = srcRect.left + srcX;", "+\t\tint top = srcRect.top + srcY;", "+\t\tOS.SetRect(srcRect, (short)left, (short)top, (short)(left + width), (short)(top + height));", "+\t\tint srcRgn = OS.NewRgn();", "+\t\tOS.RectRgn(srcRgn, srcRect);\t\t", "+\t\tOS.SectRect(rect, srcRect, srcRect);", "+\t\tRect destRect = new Rect ();", "+\t\tdestRect.left = srcRect.left;", "+\t\tdestRect.top = srcRect.top;", "+\t\tdestRect.right = srcRect.right;", "+\t\tdestRect.bottom = srcRect.bottom;", "+\t\tOS.OffsetRect(destRect, (short)deltaX, (short)deltaY);", "+\t\tint destRgn = OS.NewRgn();", "+\t\tOS.RectRgn(destRgn, destRect);", "+\t\t", "+\t\t/* Copy bits with appropriated clipping region */", "+\t\tif (!OS.EmptyRect(srcRect)) {", "+\t\t\tint clipRgn = data.visibleRgn;", "+\t\t\tif (data.clipRgn != 0) {", "+\t\t\t\tclipRgn = OS.NewRgn();", "+\t\t\t\tOS.SectRgn(data.clipRgn, clipRgn, clipRgn);", "+\t\t\t}", "+", "+\t\t\t/*", "+\t\t\t* Feature in the Macintosh.  ScrollRect() only copies bits", "+\t\t\t* that are inside the specified rectangle.  This means that", "+\t\t\t* it is not possible to copy non overlaping bits without", "+\t\t\t* copying the bits in between the source and destination", "+\t\t\t* rectangles.  The fix is to check if the source and", "+\t\t\t* destination rectangles are disjoint and use CopyBits()", "+\t\t\t* instead.", "+\t\t\t*/", "+\t\t\tboolean disjoint = (destX + width < srcX) || (srcX + width < destX) || (destY + height < srcY) || (srcY + height < destY);", "+\t\t\tif (!disjoint && (deltaX == 0 || deltaY == 0)) {", "+\t\t\t\tint[] currentPort = new int[1];", "+\t\t\t\tOS.GetPort(currentPort);", "+\t\t\t\tOS.SetPort(port);", "+\t\t\t\tint oldClip = OS.NewRgn();", "+\t\t\t\tOS.GetClip(oldClip);", "+\t\t\t\tOS.SetClip(clipRgn);", "+\t\t\t\tOS.UnionRect(srcRect, destRect, rect);", "+\t\t\t\tOS.ScrollRect(rect, (short)deltaX, (short)deltaY, 0);", "+\t\t\t\tOS.SetClip(oldClip);", "+\t\t\t\tOS.DisposeRgn(oldClip);", "+\t\t\t\tOS.SetPort(currentPort[0]);", "+\t\t\t} else {", "+\t\t\t\tint portBitMap = OS.GetPortBitMapForCopyBits (port);", "+\t\t\t\tOS.CopyBits(portBitMap, portBitMap, srcRect, destRect, (short)OS.srcCopy, clipRgn);", "+\t\t\t\tOS.QDFlushPortBuffer(port, destRgn);", "+\t\t\t}", "+\t\t\t", "+\t\t\tif (clipRgn != data.visibleRgn) OS.DisposeRgn(clipRgn);", "+\t\t}", "+\t\t", "+\t\t/* Invalidate src and obscured areas */", "+\t\tint invalRgn = OS.NewRgn();", "+\t\tOS.DiffRgn(srcRgn, data.visibleRgn, invalRgn);", "+\t\tOS.OffsetRgn(invalRgn, (short)deltaX, (short)deltaY);", "+\t\tOS.DiffRgn(srcRgn, destRgn, srcRgn);", "+\t\tOS.UnionRgn(srcRgn, invalRgn, invalRgn);", "+\t\tOS.SectRgn(data.visibleRgn, invalRgn, invalRgn);", "+\t\tOS.InvalWindowRgn(window, invalRgn);", "+\t\tOS.DisposeRgn(invalRgn);", "+\t\t", "+\t\t/* Dispose src and dest regions */", "+\t\tOS.DisposeRgn(destRgn);", "+\t\tOS.DisposeRgn(srcRgn);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6130483fb8aa75d613cab3528023f85c", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "0824c6be1a1f5c02e5a0811758feb938d6ec8c29", "commitAfterChange": "d976ddbe207f4b84af7155d1db6c5e1e64234e41", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 9, "signatureBeforeChange": " public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY, boolean paint)", "signatureAfterChange": " public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY, boolean paint)", "diff": ["-//\tif (handle == 0) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);", "-//\tif (data.updateClip) setCGClipping();", "-//\tif (width <= 0 || height <= 0) return;", "-//\tint deltaX = destX - srcX, deltaY = destY - srcY;", "-//\tif (deltaX == 0 && deltaY == 0) return;", "-//\tif (data.image != null) {", "-// \t\tOS.CGContextSaveGState(handle);", "-// \t\tOS.CGContextScaleCTM(handle, 1, -1);", "-// \t\tOS.CGContextTranslateCTM(handle, 0, -(height + 2 * destY));", "-// \t\tCGRect rect = new CGRect();", "-// \t\trect.x = destX;", "-// \t\trect.y = destY;", "-// \t\trect.width = width;", "-//\t\trect.height = height;", "-//\t\tint h = OS.CGImageGetHeight(data.image.handle);", "-//\t\tint bpr = OS.CGImageGetBytesPerRow(data.image.handle);", "-//\t\tint provider = OS.CGDataProviderCreateWithData(0, data.image.data, bpr * h, 0);", "-//\t\tif (provider != 0) {", "-//\t\t\tint colorspace = device.colorspace;", "-//\t\t\tint img = OS.CGImageCreate(width, height, 8, 32, bpr, colorspace, OS.kCGImageAlphaNoneSkipFirst, provider, null, true, 0);", "-//\t\t\tOS.CGDataProviderRelease(provider);", "-//\t\t\tOS.CGContextDrawImage(handle, rect, img);", "-//\t\t\tOS.CGImageRelease(img);", "-//\t\t}", "-// \t\tOS.CGContextRestoreGState(handle);", "-// \t\treturn;", "-//\t}", "-//\tif (data.control != 0) {", "-//\t\tint port = data.port;", "-//\t\tint window = OS.GetControlOwner(data.control);", "-//\t\tif (port == 0) port = OS.GetWindowPort(window);", "-//", "-//\t\t/* Calculate src and dest rectangles/regions */", "-//\t\tRect rect = new Rect();", "-//\t\tOS.GetControlBounds(data.control, rect);", "-//\t\tint convertX = 0, convertY = 0;", "-//\t\tCGPoint pt = new CGPoint ();", "-//\t\tint[] contentView = new int[1];", "-//\t\tOS.HIViewFindByID(OS.HIViewGetRoot(window), OS.kHIViewWindowContentID(), contentView);", "-//\t\tOS.HIViewConvertPoint(pt, OS.HIViewGetSuperview(data.control), contentView[0]);", "-//\t\tconvertX = rect.left + (int) pt.x;", "-//\t\tconvertY = rect.top + (int) pt.y;", "-//\t\trect.left += (int) pt.x;", "-//\t\trect.top += (int) pt.y;", "-//\t\trect.right += (int) pt.x;", "-//\t\trect.bottom += (int) pt.y;", "-//\t\tRect srcRect = new Rect();", "-//\t\tint left = rect.left + srcX;", "-//\t\tint top = rect.top + srcY;", "-//\t\tOS.SetRect(srcRect, (short)left, (short)top, (short)(left + width), (short)(top + height));", "-//\t\tint srcRgn = OS.NewRgn();", "-//\t\tOS.RectRgn(srcRgn, srcRect);", "-//\t\tOS.SectRect(rect, srcRect, srcRect);", "-//\t\tRect destRect = new Rect ();", "-//\t\tOS.SetRect(destRect, srcRect.left, srcRect.top, srcRect.right, srcRect.bottom);", "-//\t\tOS.OffsetRect(destRect, (short)deltaX, (short)deltaY);", "-//\t\tint destRgn = OS.NewRgn();", "-//\t\tOS.RectRgn(destRgn, destRect);", "-//\t\t", "-//\t\t/* Copy bits with appropriated clipping region */", "-//\t\tif (!OS.EmptyRect(srcRect)) {", "-//\t\t\tif (data.visibleRgn == 0 || OS.RectInRgn(srcRect, data.visibleRgn)) {", "-//\t\t\t\tint clipRgn = data.visibleRgn;", "-//\t\t\t\tif (data.clipRgn != 0) {", "-//\t\t\t\t\tclipRgn = OS.NewRgn();", "-//\t\t\t\t\tOS.SectRgn(data.clipRgn, data.visibleRgn, clipRgn);", "-//\t\t\t\t}", "-//\t", "-//\t\t\t\t/*", "-//\t\t\t\t* Feature in the Macintosh.  ScrollRect() only copies bits", "-//\t\t\t\t* that are inside the specified rectangle.  This means that", "-//\t\t\t\t* it is not possible to copy non overlaping bits without", "-//\t\t\t\t* copying the bits in between the source and destination", "-//\t\t\t\t* rectangles.  The fix is to check if the source and", "-//\t\t\t\t* destination rectangles are disjoint and use CopyBits()", "-//\t\t\t\t* instead.", "-//\t\t\t\t*/", "-//\t\t\t\tif (!OS.EmptyRgn(clipRgn)) {", "-//\t\t\t\t\tboolean disjoint = (destX + width < srcX) || (srcX + width < destX) || (destY + height < srcY) || (srcY + height < destY);", "-//\t\t\t\t\tif (!disjoint && (deltaX == 0 || deltaY == 0)) {", "-//\t\t\t\t\t\tint[] currentPort = new int[1];", "-//\t\t\t\t\t\tOS.GetPort(currentPort);", "-//\t\t\t\t\t\tOS.SetPort(port);", "-//\t\t\t\t\t\tint oldClip = OS.NewRgn();", "-//\t\t\t\t\t\tOS.GetClip(oldClip);", "-//\t\t\t\t\t\tOS.SetClip(clipRgn);", "-//\t\t\t\t\t\tOS.UnionRect(srcRect, destRect, rect);", "-//\t\t\t\t\t\tOS.ScrollRect(rect, (short)deltaX, (short)deltaY, 0);", "-//\t\t\t\t\t\tOS.SetClip(oldClip);", "-//\t\t\t\t\t\tOS.DisposeRgn(oldClip);", "-//\t\t\t\t\t\tOS.SetPort(currentPort[0]);", "-//\t\t\t\t\t} else {", "-//\t\t\t\t\t\tint portBitMap = OS.GetPortBitMapForCopyBits (port);", "-//\t\t\t\t\t\tOS.CopyBits(portBitMap, portBitMap, srcRect, destRect, (short)OS.srcCopy, clipRgn);", "-//\t\t\t\t\t\tOS.QDFlushPortBuffer(port, destRgn);", "-//\t\t\t\t\t}", "-//\t\t\t\t}", "-//\t\t\t\t", "-//\t\t\t\tif (clipRgn != data.visibleRgn) OS.DisposeRgn(clipRgn);", "-//\t\t\t}", "-//\t\t}", "-//\t\t", "-//\t\t/* Invalidate src and obscured areas */", "-//\t\tif (paint) {", "-//\t\t\tint invalRgn = OS.NewRgn();", "-//\t\t\tOS.DiffRgn(srcRgn, data.visibleRgn, invalRgn);", "-//\t\t\tOS.OffsetRgn(invalRgn, (short)deltaX, (short)deltaY);", "-//\t\t\tOS.DiffRgn(srcRgn, destRgn, srcRgn);", "-//\t\t\tOS.UnionRgn(srcRgn, invalRgn, invalRgn);", "-//\t\t\tOS.SectRgn(data.visibleRgn, invalRgn, invalRgn);", "-//\t\t\tOS.OffsetRgn(invalRgn, (short)-convertX, (short)-convertY);", "-//\t\t\tOS.HIViewSetNeedsDisplayInRegion(data.control, invalRgn, true);", "-//\t\t\tOS.DisposeRgn(invalRgn);", "-//\t\t}", "-//\t\t", "-//\t\t/* Dispose src and dest regions */", "-//\t\tOS.DisposeRgn(destRgn);", "-//\t\tOS.DisposeRgn(srcRgn);", "-//\t}", "+\tif (handle == null) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);", "+\tif (width <= 0 || height <= 0) return;", "+\tint deltaX = destX - srcX, deltaY = destY - srcY;", "+\tif (deltaX == 0 && deltaY == 0) return;", "+\tNSAutoreleasePool pool = checkGC(TRANSFORM | CLIPPING);", "+\ttry {", "+\t\tImage image = data.image;", "+\t\tif (image != null) {", "+\t\t\tNSImage imageHandle = image.handle;", "+\t\t\tNSSize size = imageHandle.size();", "+\t\t \tint imgHeight = (int)size.height;", "+\t\t\thandle.saveGraphicsState();", "+\t\t\tNSAffineTransform transform = NSAffineTransform.transform();", "+\t\t\ttransform.scaleXBy(1, -1);", "+\t\t\ttransform.translateXBy(0, -(height + 2 * destY));", "+\t\t\ttransform.concat();", "+\t\t\tNSRect srcRect = new NSRect();", "+\t\t\tsrcRect.x = srcX;", "+\t\t\tsrcRect.y = imgHeight - (srcY + height);", "+\t\t\tsrcRect.width = width;", "+\t\t\tsrcRect.height = height;", "+\t\t\tNSRect destRect = new NSRect();", "+\t\t\tdestRect.x = destX;", "+\t\t\tdestRect.y = destY;", "+\t\t\tdestRect.width = width;", "+\t\t\tdestRect.height = height;", "+\t\t\timageHandle.drawInRect(destRect, srcRect, OS.NSCompositeCopy, 1);", "+\t\t\thandle.restoreGraphicsState();", "+\t \t\treturn;", "+\t\t}", "+\t\tif (data.view != null) {", "+\t\t\t//TODO implement copyArea(IIIIIIZ) for views", "+\t\t\treturn;", "+\t\t}\t\t", "+\t} finally {", "+\t\tuncheckGC(pool);", "+\t}"]}], "num": 10063}