{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "07383f9eae4748424e3a01dabfee177e", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2e1187f1d49983a0fef35011cd27af9b", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt.tools/Mac Generation/org/eclipse/swt/tools/internal/DOMWriter.java", "commitBeforeChange": "bede5411f9aa7de237c12e785a278e1cd528e317", "commitAfterChange": "c5a4f175f14b3b967abb14aa67050eb14ed80f82", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r\r\tString normalize(String s)", "signatureAfterChange": "\r\r\tString normalize(String s)", "diff": ["-/*******************************************************************************\r * Copyright (c) 2008 IBM Corporation and others.\r * All rights reserved. This program and the accompanying materials\r * are made available under the terms of the Eclipse Public License v1.0\r * which accompanies this distribution, and is available at\r * http://www.eclipse.org/legal/epl-v10.html\r *\r * Contributors:\r *     IBM Corporation - initial API and implementation\r *******************************************************************************/\rpackage org.eclipse.swt.tools.internal;\r\rimport java.io.PrintStream;\rimport java.util.Arrays;\rimport java.util.Comparator;\r\rimport org.w3c.dom.Attr;\rimport org.w3c.dom.Document;\rimport org.w3c.dom.NamedNodeMap;\rimport org.w3c.dom.Node;\rimport org.w3c.dom.NodeList;\r\rpublic class DOMWriter {\r\r\tstatic String ENCONDING = \"UTF8\";\r\tPrintStream out;\r\tboolean canonical, pretty = false;\r\tString[] attributeFilter;\r\r\tpublic DOMWriter(PrintStream out, boolean canonical) {\r\t\tthis.out = new PrintStream(out);\r\t\tthis.canonical = canonical;\r\t}\r\r\tString nodeName(Node node) {\r\t\t// TODO use getLocalName()?\r\t\treturn node.getNodeName();\r\t}\r\t\r\tboolean filter(Attr attr) {\r\t\tif (attributeFilter == null) return false;\r\t\tString name = attr.getNodeName();\r\t\tfor (int i = 0; i < attributeFilter.length; i++) {\r\t\t\tif (name.matches(attributeFilter[i])) return false;\r\t\t}\r\t\treturn true;\r\t}\r\t\r\tvoid print(String str) {\r\t\tout.print(str);\r\t}\r\tvoid println() {\r\t\tout.println();\r\t}\r\r\tpublic void print(Node node) {\r\t\tprint(node, 0);\r\t}\r\t\r\tpublic void print(Node node, int level) {\r\t\tif (node == null)\r\t\t\treturn;\r\t\tint type = node.getNodeType();\r\t\tswitch (type) {\r\t\t\tcase Node.DOCUMENT_NODE: {\r\t\t\t\tif (!canonical) {\r\t\t\t\t\tprint(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\r\t\t\t\t\tprint(ENCONDING);\r\t\t\t\t\tprint(\"\\\"?>\");\r\t\t\t\t\tprintln();\r\t\t\t\t}\r\t\t\t\tprint(((Document) node).getDocumentElement());\r\t\t\t\tout.flush();\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ELEMENT_NODE: {\r\t\t\t\tif (!canonical && pretty) {\r\t\t\t\t\tprintln();\r\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t}\r\t\t\t\tprint(\"<\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tAttr attrs[] = sort(node.getAttributes());\r\t\t\t\tfor (int i = 0; i < attrs.length; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tif (filter(attr)) continue;\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(nodeName(attr));\r\t\t\t\t\tprint(\"=\\\"\");\r\t\t\t\t\tprint(normalize(attr.getNodeValue()));\r\t\t\t\t\tprint(\"\\\"\");\r\t\t\t\t}\r\t\t\t\tprint(\">\");\r\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\tif (children != null) {\r\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t}\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ENTITY_REFERENCE_NODE: {\r\t\t\t\tif (canonical) {\r\t\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\t\tif (children != null) {\r\t\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t\t}\r\t\t\t\t\t}\r\t\t\t\t} else {\r\t\t\t\t\tprint(\"&\");\r\t\t\t\t\tprint(nodeName(node));\r\t\t\t\t\tprint(\";\");\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.CDATA_SECTION_NODE: {\r\t\t\t\tif (canonical) {\r\t\t\t\t\tprint(normalize(node.getNodeValue()));\r\t\t\t\t} else {\r\t\t\t\t\tprint(\"<![CDATA[\");\r\t\t\t\t\tprint(node.getNodeValue());\r\t\t\t\t\tprint(\"]]>\");\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.TEXT_NODE: {\r\t\t\t\tprint(normalize(node.getNodeValue()));\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.PROCESSING_INSTRUCTION_NODE: {\r\t\t\t\tprint(\"<?\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tString data = node.getNodeValue();\r\t\t\t\tif (data != null && data.length() > 0) {\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(data);\r\t\t\t\t}\r\t\t\t\tprint(\"?>\");\r\t\t\t\tbreak;\r\t\t\t}\r\t\t}\r\t\tif (type == Node.ELEMENT_NODE) {\r\t\t\tif (!canonical && pretty) {\r\t\t\t\tif (node.getChildNodes().getLength() > 0) {\r\t\t\t\t\tprintln();\r\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t}\t\t\t\t\r\t\t\t}\r\t\t\tprint(\"</\");\r\t\t\tprint(nodeName(node));\r\t\t\tprint(\">\");\r\t\t}\r\t\tout.flush();\r\t}\r\r\tAttr[] sort(NamedNodeMap attrs) {\r\t\tif (attrs == null)\r\t\t\treturn new Attr[0];\r\t\tAttr result[] = new Attr[attrs.getLength()];\r\t\tfor (int i = 0; i < result.length; i++) {\r\t\t\tresult[i] = (Attr) attrs.item(i);\r\t\t}\r\t\tArrays.sort(result, new Comparator() {\r\t\t\tpublic int compare(Object arg0, Object arg1) {\r\t\t\t\treturn nodeName((Node) arg0).compareTo(nodeName((Node) arg1));\r\t\t\t}\r\t\t});\r\t\treturn result;\r\t}\r\r\tString normalize(String s) {\r\t\tif (s == null) return \"\";\r\t\tStringBuffer str = new StringBuffer();\r\t\tfor (int i = 0, length = s.length(); i < length; i++) {\r\t\t\tchar ch = s.charAt(i);\r\t\t\tswitch (ch) {\r\t\t\t\tcase '\"': str.append(\"\\\"\"); break;\r\t\t\t\tcase '\\r':\r\t\t\t\tcase '\\n':\r\t\t\t\t\tif (canonical) {\r\t\t\t\t\t\tstr.append(\"&#\");\r\t\t\t\t\t\tstr.append(Integer.toString(ch));\r\t\t\t\t\t\tstr.append(';');\r\t\t\t\t\t\tbreak;\r\t\t\t\t\t}\r\t\t\t\t\t// FALL THROUGH\r\t\t\t\tdefault: str.append(ch);\r\t\t\t}\r\t\t}\r\t\treturn str.toString();\r\t}\r\t\r\tpublic void setAttributeFilter(String[] filter) {\r\t\tattributeFilter = filter;\r\t}\r}", "\\ No newline at end of file", "+/*******************************************************************************\r * Copyright (c) 2008 IBM Corporation and others.\r * All rights reserved. This program and the accompanying materials\r * are made available under the terms of the Eclipse Public License v1.0\r * which accompanies this distribution, and is available at\r * http://www.eclipse.org/legal/epl-v10.html\r *\r * Contributors:\r *     IBM Corporation - initial API and implementation\r *******************************************************************************/\rpackage org.eclipse.swt.tools.internal;\r\rimport java.io.PrintStream;\rimport java.util.Arrays;\rimport java.util.Comparator;\r\rimport org.w3c.dom.Attr;\rimport org.w3c.dom.Document;\rimport org.w3c.dom.NamedNodeMap;\rimport org.w3c.dom.Node;\rimport org.w3c.dom.NodeList;\r\rpublic class DOMWriter {\r\r\tstatic String ENCONDING = \"UTF8\";\r\tPrintStream out;\r\tString[] attributeFilter;\r\tString nodeFilter;\r\r\tpublic DOMWriter(PrintStream out) {\r\t\tthis.out = new PrintStream(out);\r\t}\r\r\tString nodeName(Node node) {\r\t\t// TODO use getLocalName()?\r\t\treturn node.getNodeName();\r\t}\r\t\r\tboolean filter(Attr attr) {\r\t\tif (attributeFilter == null) return false;\r\t\tString name = attr.getNodeName();\r\t\tfor (int i = 0; i < attributeFilter.length; i++) {\r\t\t\tif (name.matches(attributeFilter[i])) return false;\r\t\t}\r\t\treturn true;\r\t}\r\t\r\tvoid print(String str) {\r\t\tout.print(str);\r\t}\r\tvoid println() {\r\t\tout.println();\r\t}\r\r\tpublic void print(Node node) {\r\t\tprint(node, 0);\r\t}\r\t\r\tpublic void print(Node node, int level) {\r\t\tif (node == null)\r\t\t\treturn;\r\t\tint type = node.getNodeType();\r\t\tswitch (type) {\r\t\t\tcase Node.DOCUMENT_NODE: {\r\t\t\t\tprint(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\r\t\t\t\tprint(ENCONDING);\r\t\t\t\tprint(\"\\\"?>\");\r\t\t\t\tprintln();\r\t\t\t\tprint(((Document) node).getDocumentElement());\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ELEMENT_NODE: {\r\t\t\t\tAttr attrs[] = sort(node.getAttributes());\r\t\t\t\tboolean gen = false;\r\t\t\t\tfor (int i = 0; i < attrs.length && !gen; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tif (nodeName(attr).startsWith(nodeFilter)) gen = true;\r\t\t\t\t}\r\t\t\t\tif (!gen) break;\r\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\tprint(\"<\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tfor (int i = 0; i < attrs.length; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tif (filter(attr)) continue;\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(nodeName(attr));\r\t\t\t\t\tprint(\"=\\\"\");\r\t\t\t\t\tprint(normalize(attr.getNodeValue()));\r\t\t\t\t\tprint(\"\\\"\");\r\t\t\t\t}\r\t\t\t\tprint(\">\");\r\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\tint count = 0;\r\t\t\t\tif (children != null) {\r\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tif (children.item(i).getNodeType() == Node.ELEMENT_NODE) count++;\r\t\t\t\t\t}\r\t\t\t\t\tif (count > 0) println();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t}\r\t\t\t\t\tif (count > 0) {\r\t\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t\t}\r\t\t\t\t}\r\t\t\t\tprint(\"</\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tprint(\">\");\r\t\t\t\tprintln();\r\t\t\t\tbreak;\r\t\t\t}\r\t\t}\r\t\tout.flush();\r\t}\r\r\tAttr[] sort(NamedNodeMap attrs) {\r\t\tif (attrs == null)\r\t\t\treturn new Attr[0];\r\t\tAttr result[] = new Attr[attrs.getLength()];\r\t\tfor (int i = 0; i < result.length; i++) {\r\t\t\tresult[i] = (Attr) attrs.item(i);\r\t\t}\r\t\tArrays.sort(result, new Comparator() {\r\t\t\tpublic int compare(Object arg0, Object arg1) {\r\t\t\t\treturn nodeName((Node) arg0).compareTo(nodeName((Node) arg1));\r\t\t\t}\r\t\t});\r\t\treturn result;\r\t}\r\r\tString normalize(String s) {\r\t\tif (s == null) return \"\";\r\t\tStringBuffer str = new StringBuffer();\r\t\tfor (int i = 0, length = s.length(); i < length; i++) {\r\t\t\tchar ch = s.charAt(i);\r\t\t\tswitch (ch) {\r\t\t\t\tcase '\"': str.append(\"\\\"\"); break;\r\t\t\t\tcase '\\r':\r\t\t\t\tcase '\\n':\r\t\t\t\t\t// FALL THROUGH\r\t\t\t\tdefault: str.append(ch);\r\t\t\t}\r\t\t}\r\t\treturn str.toString();\r\t}\r\t\r\tpublic void setNodeFilter(String filter) {\r\t\t\r\t\tnodeFilter = filter;\r\t}\r\t\r\tpublic void setAttributeFilter(String[] filter) {\r\t\tattributeFilter = filter;\r\t}\r}", "\\ No newline at end of file"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a87743adb092ea4d40257f464ae377e4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt.tools/Mac Generation/org/eclipse/swt/tools/internal/DOMWriter.java", "commitBeforeChange": "bede5411f9aa7de237c12e785a278e1cd528e317", "commitAfterChange": "c5a4f175f14b3b967abb14aa67050eb14ed80f82", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r\t\r\tpublic void print(Node node, int level)", "signatureAfterChange": "\r\t\r\tpublic void print(Node node, int level)", "diff": ["-/*******************************************************************************\r * Copyright (c) 2008 IBM Corporation and others.\r * All rights reserved. This program and the accompanying materials\r * are made available under the terms of the Eclipse Public License v1.0\r * which accompanies this distribution, and is available at\r * http://www.eclipse.org/legal/epl-v10.html\r *\r * Contributors:\r *     IBM Corporation - initial API and implementation\r *******************************************************************************/\rpackage org.eclipse.swt.tools.internal;\r\rimport java.io.PrintStream;\rimport java.util.Arrays;\rimport java.util.Comparator;\r\rimport org.w3c.dom.Attr;\rimport org.w3c.dom.Document;\rimport org.w3c.dom.NamedNodeMap;\rimport org.w3c.dom.Node;\rimport org.w3c.dom.NodeList;\r\rpublic class DOMWriter {\r\r\tstatic String ENCONDING = \"UTF8\";\r\tPrintStream out;\r\tboolean canonical, pretty = false;\r\tString[] attributeFilter;\r\r\tpublic DOMWriter(PrintStream out, boolean canonical) {\r\t\tthis.out = new PrintStream(out);\r\t\tthis.canonical = canonical;\r\t}\r\r\tString nodeName(Node node) {\r\t\t// TODO use getLocalName()?\r\t\treturn node.getNodeName();\r\t}\r\t\r\tboolean filter(Attr attr) {\r\t\tif (attributeFilter == null) return false;\r\t\tString name = attr.getNodeName();\r\t\tfor (int i = 0; i < attributeFilter.length; i++) {\r\t\t\tif (name.matches(attributeFilter[i])) return false;\r\t\t}\r\t\treturn true;\r\t}\r\t\r\tvoid print(String str) {\r\t\tout.print(str);\r\t}\r\tvoid println() {\r\t\tout.println();\r\t}\r\r\tpublic void print(Node node) {\r\t\tprint(node, 0);\r\t}\r\t\r\tpublic void print(Node node, int level) {\r\t\tif (node == null)\r\t\t\treturn;\r\t\tint type = node.getNodeType();\r\t\tswitch (type) {\r\t\t\tcase Node.DOCUMENT_NODE: {\r\t\t\t\tif (!canonical) {\r\t\t\t\t\tprint(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\r\t\t\t\t\tprint(ENCONDING);\r\t\t\t\t\tprint(\"\\\"?>\");\r\t\t\t\t\tprintln();\r\t\t\t\t}\r\t\t\t\tprint(((Document) node).getDocumentElement());\r\t\t\t\tout.flush();\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ELEMENT_NODE: {\r\t\t\t\tif (!canonical && pretty) {\r\t\t\t\t\tprintln();\r\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t}\r\t\t\t\tprint(\"<\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tAttr attrs[] = sort(node.getAttributes());\r\t\t\t\tfor (int i = 0; i < attrs.length; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tif (filter(attr)) continue;\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(nodeName(attr));\r\t\t\t\t\tprint(\"=\\\"\");\r\t\t\t\t\tprint(normalize(attr.getNodeValue()));\r\t\t\t\t\tprint(\"\\\"\");\r\t\t\t\t}\r\t\t\t\tprint(\">\");\r\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\tif (children != null) {\r\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t}\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ENTITY_REFERENCE_NODE: {\r\t\t\t\tif (canonical) {\r\t\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\t\tif (children != null) {\r\t\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t\t}\r\t\t\t\t\t}\r\t\t\t\t} else {\r\t\t\t\t\tprint(\"&\");\r\t\t\t\t\tprint(nodeName(node));\r\t\t\t\t\tprint(\";\");\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.CDATA_SECTION_NODE: {\r\t\t\t\tif (canonical) {\r\t\t\t\t\tprint(normalize(node.getNodeValue()));\r\t\t\t\t} else {\r\t\t\t\t\tprint(\"<![CDATA[\");\r\t\t\t\t\tprint(node.getNodeValue());\r\t\t\t\t\tprint(\"]]>\");\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.TEXT_NODE: {\r\t\t\t\tprint(normalize(node.getNodeValue()));\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.PROCESSING_INSTRUCTION_NODE: {\r\t\t\t\tprint(\"<?\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tString data = node.getNodeValue();\r\t\t\t\tif (data != null && data.length() > 0) {\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(data);\r\t\t\t\t}\r\t\t\t\tprint(\"?>\");\r\t\t\t\tbreak;\r\t\t\t}\r\t\t}\r\t\tif (type == Node.ELEMENT_NODE) {\r\t\t\tif (!canonical && pretty) {\r\t\t\t\tif (node.getChildNodes().getLength() > 0) {\r\t\t\t\t\tprintln();\r\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t}\t\t\t\t\r\t\t\t}\r\t\t\tprint(\"</\");\r\t\t\tprint(nodeName(node));\r\t\t\tprint(\">\");\r\t\t}\r\t\tout.flush();\r\t}\r\r\tAttr[] sort(NamedNodeMap attrs) {\r\t\tif (attrs == null)\r\t\t\treturn new Attr[0];\r\t\tAttr result[] = new Attr[attrs.getLength()];\r\t\tfor (int i = 0; i < result.length; i++) {\r\t\t\tresult[i] = (Attr) attrs.item(i);\r\t\t}\r\t\tArrays.sort(result, new Comparator() {\r\t\t\tpublic int compare(Object arg0, Object arg1) {\r\t\t\t\treturn nodeName((Node) arg0).compareTo(nodeName((Node) arg1));\r\t\t\t}\r\t\t});\r\t\treturn result;\r\t}\r\r\tString normalize(String s) {\r\t\tif (s == null) return \"\";\r\t\tStringBuffer str = new StringBuffer();\r\t\tfor (int i = 0, length = s.length(); i < length; i++) {\r\t\t\tchar ch = s.charAt(i);\r\t\t\tswitch (ch) {\r\t\t\t\tcase '\"': str.append(\"\\\"\"); break;\r\t\t\t\tcase '\\r':\r\t\t\t\tcase '\\n':\r\t\t\t\t\tif (canonical) {\r\t\t\t\t\t\tstr.append(\"&#\");\r\t\t\t\t\t\tstr.append(Integer.toString(ch));\r\t\t\t\t\t\tstr.append(';');\r\t\t\t\t\t\tbreak;\r\t\t\t\t\t}\r\t\t\t\t\t// FALL THROUGH\r\t\t\t\tdefault: str.append(ch);\r\t\t\t}\r\t\t}\r\t\treturn str.toString();\r\t}\r\t\r\tpublic void setAttributeFilter(String[] filter) {\r\t\tattributeFilter = filter;\r\t}\r}", "\\ No newline at end of file", "+/*******************************************************************************\r * Copyright (c) 2008 IBM Corporation and others.\r * All rights reserved. This program and the accompanying materials\r * are made available under the terms of the Eclipse Public License v1.0\r * which accompanies this distribution, and is available at\r * http://www.eclipse.org/legal/epl-v10.html\r *\r * Contributors:\r *     IBM Corporation - initial API and implementation\r *******************************************************************************/\rpackage org.eclipse.swt.tools.internal;\r\rimport java.io.PrintStream;\rimport java.util.Arrays;\rimport java.util.Comparator;\r\rimport org.w3c.dom.Attr;\rimport org.w3c.dom.Document;\rimport org.w3c.dom.NamedNodeMap;\rimport org.w3c.dom.Node;\rimport org.w3c.dom.NodeList;\r\rpublic class DOMWriter {\r\r\tstatic String ENCONDING = \"UTF8\";\r\tPrintStream out;\r\tString[] attributeFilter;\r\tString nodeFilter;\r\r\tpublic DOMWriter(PrintStream out) {\r\t\tthis.out = new PrintStream(out);\r\t}\r\r\tString nodeName(Node node) {\r\t\t// TODO use getLocalName()?\r\t\treturn node.getNodeName();\r\t}\r\t\r\tboolean filter(Attr attr) {\r\t\tif (attributeFilter == null) return false;\r\t\tString name = attr.getNodeName();\r\t\tfor (int i = 0; i < attributeFilter.length; i++) {\r\t\t\tif (name.matches(attributeFilter[i])) return false;\r\t\t}\r\t\treturn true;\r\t}\r\t\r\tvoid print(String str) {\r\t\tout.print(str);\r\t}\r\tvoid println() {\r\t\tout.println();\r\t}\r\r\tpublic void print(Node node) {\r\t\tprint(node, 0);\r\t}\r\t\r\tpublic void print(Node node, int level) {\r\t\tif (node == null)\r\t\t\treturn;\r\t\tint type = node.getNodeType();\r\t\tswitch (type) {\r\t\t\tcase Node.DOCUMENT_NODE: {\r\t\t\t\tprint(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\r\t\t\t\tprint(ENCONDING);\r\t\t\t\tprint(\"\\\"?>\");\r\t\t\t\tprintln();\r\t\t\t\tprint(((Document) node).getDocumentElement());\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ELEMENT_NODE: {\r\t\t\t\tAttr attrs[] = sort(node.getAttributes());\r\t\t\t\tboolean gen = false;\r\t\t\t\tfor (int i = 0; i < attrs.length && !gen; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tif (nodeName(attr).startsWith(nodeFilter)) gen = true;\r\t\t\t\t}\r\t\t\t\tif (!gen) break;\r\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\tprint(\"<\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tfor (int i = 0; i < attrs.length; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tif (filter(attr)) continue;\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(nodeName(attr));\r\t\t\t\t\tprint(\"=\\\"\");\r\t\t\t\t\tprint(normalize(attr.getNodeValue()));\r\t\t\t\t\tprint(\"\\\"\");\r\t\t\t\t}\r\t\t\t\tprint(\">\");\r\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\tint count = 0;\r\t\t\t\tif (children != null) {\r\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tif (children.item(i).getNodeType() == Node.ELEMENT_NODE) count++;\r\t\t\t\t\t}\r\t\t\t\t\tif (count > 0) println();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t}\r\t\t\t\t\tif (count > 0) {\r\t\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t\t}\r\t\t\t\t}\r\t\t\t\tprint(\"</\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tprint(\">\");\r\t\t\t\tprintln();\r\t\t\t\tbreak;\r\t\t\t}\r\t\t}\r\t\tout.flush();\r\t}\r\r\tAttr[] sort(NamedNodeMap attrs) {\r\t\tif (attrs == null)\r\t\t\treturn new Attr[0];\r\t\tAttr result[] = new Attr[attrs.getLength()];\r\t\tfor (int i = 0; i < result.length; i++) {\r\t\t\tresult[i] = (Attr) attrs.item(i);\r\t\t}\r\t\tArrays.sort(result, new Comparator() {\r\t\t\tpublic int compare(Object arg0, Object arg1) {\r\t\t\t\treturn nodeName((Node) arg0).compareTo(nodeName((Node) arg1));\r\t\t\t}\r\t\t});\r\t\treturn result;\r\t}\r\r\tString normalize(String s) {\r\t\tif (s == null) return \"\";\r\t\tStringBuffer str = new StringBuffer();\r\t\tfor (int i = 0, length = s.length(); i < length; i++) {\r\t\t\tchar ch = s.charAt(i);\r\t\t\tswitch (ch) {\r\t\t\t\tcase '\"': str.append(\"\\\"\"); break;\r\t\t\t\tcase '\\r':\r\t\t\t\tcase '\\n':\r\t\t\t\t\t// FALL THROUGH\r\t\t\t\tdefault: str.append(ch);\r\t\t\t}\r\t\t}\r\t\treturn str.toString();\r\t}\r\t\r\tpublic void setNodeFilter(String filter) {\r\t\t\r\t\tnodeFilter = filter;\r\t}\r\t\r\tpublic void setAttributeFilter(String[] filter) {\r\t\tattributeFilter = filter;\r\t}\r}", "\\ No newline at end of file"]}], "num": 37712}