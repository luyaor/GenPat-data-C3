{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e6944691253a963ad49e0fabbaccf77b", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1f6d3704314cdded4e393dd272793009", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "600117323003db9ea522ed0baf12ee909172c3dc", "commitAfterChange": "c44dd21c1a1b0072edf7d53333363f735a817f14", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " void drawImageMask(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, int imgWidth, int imgHeight)", "signatureAfterChange": " void drawImageMask(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, int imgWidth, int imgHeight)", "diff": ["-\tif (srcWidth != destWidth || srcHeight != destHeight) {", "-\t\tint /*long*/ pixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, true, 8, srcWidth, srcHeight);", "-\t\tif (pixbuf != 0) {", "-\t\t\tint /*long*/ colormap = OS.gdk_colormap_get_system();", "-\t\t\tOS.gdk_pixbuf_get_from_drawable(pixbuf, colorPixmap, colormap, srcX, srcY, 0, 0, srcWidth, srcHeight);", "-\t\t\tint /*long*/ maskPixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, srcWidth, srcHeight);", "-\t\t\tif (maskPixbuf != 0) {", "-\t\t\t\tOS.gdk_pixbuf_get_from_drawable(maskPixbuf, maskPixmap, 0, srcX, srcY, 0, 0, srcWidth, srcHeight);", "-\t\t\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "-\t\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "-\t\t\t\tbyte[] line = new byte[stride];", "-\t\t\t\tint maskStride = OS.gdk_pixbuf_get_rowstride(maskPixbuf);", "-\t\t\t\tint /*long*/ maskPixels = OS.gdk_pixbuf_get_pixels(maskPixbuf);", "-\t\t\t\tbyte[] maskLine = new byte[maskStride];", "-\t\t\t\tfor (int y=0; y<srcHeight; y++) {", "-\t\t\t\t\tint /*long*/ offset = pixels + (y * stride);", "-\t\t\t\t\tOS.memmove(line, offset, stride);", "-\t\t\t\t\tint /*long*/ maskOffset = maskPixels + (y * maskStride);", "-\t\t\t\t\tOS.memmove(maskLine, maskOffset, maskStride);", "-\t\t\t\t\tfor (int x=0; x<srcWidth; x++) {", "-\t\t\t\t\t\tif (maskLine[x * 3] == 0) {", "-\t\t\t\t\t\t\tline[x*4+3] = 0;", "+\tif (device.useXRender) {", "+\t\tdrawImageXRender(srcImage, srcX, srcY, srcWidth, srcHeight, destX, destY, destWidth, destHeight, simple, imgWidth, imgHeight, maskPixmap, OS.PictStandardA1);", "+\t} else {", "+\t\tif (srcWidth != destWidth || srcHeight != destHeight) {", "+\t\t\tint /*long*/ pixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, true, 8, srcWidth, srcHeight);", "+\t\t\tif (pixbuf != 0) {", "+\t\t\t\tint /*long*/ colormap = OS.gdk_colormap_get_system();", "+\t\t\t\tOS.gdk_pixbuf_get_from_drawable(pixbuf, colorPixmap, colormap, srcX, srcY, 0, 0, srcWidth, srcHeight);", "+\t\t\t\tint /*long*/ maskPixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, srcWidth, srcHeight);", "+\t\t\t\tif (maskPixbuf != 0) {", "+\t\t\t\t\tOS.gdk_pixbuf_get_from_drawable(maskPixbuf, maskPixmap, 0, srcX, srcY, 0, 0, srcWidth, srcHeight);", "+\t\t\t\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "+\t\t\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\t\t\t\tbyte[] line = new byte[stride];", "+\t\t\t\t\tint maskStride = OS.gdk_pixbuf_get_rowstride(maskPixbuf);", "+\t\t\t\t\tint /*long*/ maskPixels = OS.gdk_pixbuf_get_pixels(maskPixbuf);", "+\t\t\t\t\tbyte[] maskLine = new byte[maskStride];", "+\t\t\t\t\tfor (int y=0; y<srcHeight; y++) {", "+\t\t\t\t\t\tint /*long*/ offset = pixels + (y * stride);", "+\t\t\t\t\t\tOS.memmove(line, offset, stride);", "+\t\t\t\t\t\tint /*long*/ maskOffset = maskPixels + (y * maskStride);", "+\t\t\t\t\t\tOS.memmove(maskLine, maskOffset, maskStride);", "+\t\t\t\t\t\tfor (int x=0; x<srcWidth; x++) {", "+\t\t\t\t\t\t\tif (maskLine[x * 3] == 0) {", "+\t\t\t\t\t\t\t\tline[x*4+3] = 0;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tOS.memmove(offset, line, stride);", "-\t\t\t\t\tOS.memmove(offset, line, stride);", "+\t\t\t\t\tOS.g_object_unref(maskPixbuf);", "+\t\t\t\t\tint /*long*/ scaledPixbuf = OS.gdk_pixbuf_scale_simple(pixbuf, destWidth, destHeight, OS.GDK_INTERP_BILINEAR);", "+\t\t\t\t\tif (scaledPixbuf != 0) {", "+\t\t\t\t\t\tint /*long*/[] colorBuffer = new int /*long*/[1];", "+\t\t\t\t\t\tint /*long*/[] maskBuffer = new int /*long*/[1];", "+\t\t\t\t\t\tOS.gdk_pixbuf_render_pixmap_and_mask(scaledPixbuf, colorBuffer, maskBuffer, 128);", "+\t\t\t\t\t\tcolorPixmap = colorBuffer[0];", "+\t\t\t\t\t\tmaskPixmap = maskBuffer[0];", "+\t\t\t\t\t\tOS.g_object_unref(scaledPixbuf);", "+\t\t\t\t\t}", "-\t\t\t\tOS.g_object_unref(maskPixbuf);", "-\t\t\t\tint /*long*/ scaledPixbuf = OS.gdk_pixbuf_scale_simple(pixbuf, destWidth, destHeight, OS.GDK_INTERP_BILINEAR);", "-\t\t\t\tif (scaledPixbuf != 0) {", "-\t\t\t\t\tint /*long*/[] colorBuffer = new int /*long*/[1];", "-\t\t\t\t\tint /*long*/[] maskBuffer = new int /*long*/[1];", "-\t\t\t\t\tOS.gdk_pixbuf_render_pixmap_and_mask(scaledPixbuf, colorBuffer, maskBuffer, 128);", "-\t\t\t\t\tcolorPixmap = colorBuffer[0];", "-\t\t\t\t\tmaskPixmap = maskBuffer[0];", "-\t\t\t\t\tOS.g_object_unref(scaledPixbuf);", "-\t\t\t\t}", "+\t\t\t\tOS.g_object_unref(pixbuf);", "-\t\t\tOS.g_object_unref(pixbuf);", "+\t\t\tsrcX = 0;", "+\t\t\tsrcY = 0;", "+\t\t\tsrcWidth = destWidth;", "+\t\t\tsrcHeight = destHeight;", "-\t\tsrcX = 0;", "-\t\tsrcY = 0;", "-\t\tsrcWidth = destWidth;", "-\t\tsrcHeight = destHeight;", "-\t}", "-", "-\t/* Merge clipping with mask if necessary */", "-\tif (data.clipRgn != 0)\t {", "-\t\tint newWidth =  srcX + srcWidth;", "-\t\tint newHeight = srcY + srcHeight;", "-\t\tint bytesPerLine = (newWidth + 7) / 8;", "-\t\tbyte[] maskData = new byte[bytesPerLine * newHeight];", "-\t\tint /*long*/ mask = OS.gdk_bitmap_create_from_data(0, maskData, newWidth, newHeight);", "-\t\tif (mask != 0) {", "-\t\t\tint /*long*/ gc = OS.gdk_gc_new(mask);", "-\t\t\tOS.gdk_region_offset(data.clipRgn, -destX + srcX, -destY + srcY);", "-\t\t\tOS.gdk_gc_set_clip_region(gc, data.clipRgn);", "-\t\t\tOS.gdk_region_offset(data.clipRgn, destX - srcX, destY - srcY);", "-\t\t\tGdkColor color = new GdkColor();", "-\t\t\tcolor.pixel = 1;", "-\t\t\tOS.gdk_gc_set_foreground(gc, color);", "-\t\t\tOS.gdk_draw_rectangle(mask, gc, 1, 0, 0, newWidth, newHeight);", "-\t\t\tOS.gdk_gc_set_function(gc, OS.GDK_AND);", "-\t\t\tOS.gdk_draw_drawable(mask, gc, maskPixmap, 0, 0, 0, 0, newWidth, newHeight);", "-\t\t\tOS.g_object_unref(gc);", "-\t\t\tif (maskPixmap != 0 && srcImage.mask != maskPixmap) OS.g_object_unref(maskPixmap);", "-\t\t\tmaskPixmap = mask;", "+\t", "+\t\t/* Merge clipping with mask if necessary */", "+\t\tif (data.clipRgn != 0)\t {", "+\t\t\tint newWidth =  srcX + srcWidth;", "+\t\t\tint newHeight = srcY + srcHeight;", "+\t\t\tint bytesPerLine = (newWidth + 7) / 8;", "+\t\t\tbyte[] maskData = new byte[bytesPerLine * newHeight];", "+\t\t\tint /*long*/ mask = OS.gdk_bitmap_create_from_data(0, maskData, newWidth, newHeight);", "+\t\t\tif (mask != 0) {", "+\t\t\t\tint /*long*/ gc = OS.gdk_gc_new(mask);", "+\t\t\t\tOS.gdk_region_offset(data.clipRgn, -destX + srcX, -destY + srcY);", "+\t\t\t\tOS.gdk_gc_set_clip_region(gc, data.clipRgn);", "+\t\t\t\tOS.gdk_region_offset(data.clipRgn, destX - srcX, destY - srcY);", "+\t\t\t\tGdkColor color = new GdkColor();", "+\t\t\t\tcolor.pixel = 1;", "+\t\t\t\tOS.gdk_gc_set_foreground(gc, color);", "+\t\t\t\tOS.gdk_draw_rectangle(mask, gc, 1, 0, 0, newWidth, newHeight);", "+\t\t\t\tOS.gdk_gc_set_function(gc, OS.GDK_AND);", "+\t\t\t\tOS.gdk_draw_drawable(mask, gc, maskPixmap, 0, 0, 0, 0, newWidth, newHeight);", "+\t\t\t\tOS.g_object_unref(gc);", "+\t\t\t\tif (maskPixmap != 0 && srcImage.mask != maskPixmap) OS.g_object_unref(maskPixmap);", "+\t\t\t\tmaskPixmap = mask;", "+\t\t\t}", "+\t", "+\t\t/* Blit cliping the mask */", "+\t\tGdkGCValues values = new GdkGCValues();", "+\t\tOS.gdk_gc_get_values(handle, values);", "+\t\tOS.gdk_gc_set_clip_mask(handle, maskPixmap);", "+\t\tOS.gdk_gc_set_clip_origin(handle, destX - srcX, destY - srcY);", "+\t\tOS.gdk_draw_drawable(drawable, handle, colorPixmap, srcX, srcY, destX, destY, srcWidth, srcHeight);", "+\t\tOS.gdk_gc_set_values(handle, values, OS.GDK_GC_CLIP_MASK | OS.GDK_GC_CLIP_X_ORIGIN | OS.GDK_GC_CLIP_Y_ORIGIN);", "+\t\tif (data.clipRgn != 0) OS.gdk_gc_set_clip_region(handle, data.clipRgn);", "-", "-\t/* Blit cliping the mask */", "-\tGdkGCValues values = new GdkGCValues();", "-\tOS.gdk_gc_get_values(handle, values);", "-\tOS.gdk_gc_set_clip_mask(handle, maskPixmap);", "-\tOS.gdk_gc_set_clip_origin(handle, destX - srcX, destY - srcY);", "-\tOS.gdk_draw_drawable(drawable, handle, colorPixmap, srcX, srcY, destX, destY, srcWidth, srcHeight);", "-\tOS.gdk_gc_set_values(handle, values, OS.GDK_GC_CLIP_MASK | OS.GDK_GC_CLIP_X_ORIGIN | OS.GDK_GC_CLIP_Y_ORIGIN);", "-\tif (data.clipRgn != 0) OS.gdk_gc_set_clip_region(handle, data.clipRgn);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9b59b86b75853b525b0453b88d21758b", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "d089b2cf79ce87d2a82f677ea1a4ce5a5ba9d4a4", "commitAfterChange": "78b034106c080360cc188a981bb53f8356762fbe", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "  static int createPixbuf(Image image)", "signatureAfterChange": "  static int createPixbuf(Image image)", "diff": ["-\tint [] w = new int [1], h = new int [1];", "- \tOS.gdk_drawable_get_size (image.pixmap, w, h);", "-\tint /*long*/ colormap = OS.gdk_colormap_get_system ();", "-\tboolean hasMask = image.mask != 0 && OS.gdk_drawable_get_depth (image.mask) == 1;", "-\tif (hasMask) {", "-\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, true, 8, w [0], h [0]);", "+\tif (OS.USE_CAIRO_SURFACE) {", "+\t\tRectangle bounds = image.getBounds();", "+\t\tint w = bounds.width, h = bounds.height;", "+\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, true, 8, w, h);", "-\t\tOS.gdk_pixbuf_get_from_drawable (pixbuf, image.pixmap, colormap, 0, 0, 0, 0, w [0], h [0]);", "-\t\tint /*long*/ maskPixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, w [0], h [0]);", "-\t\tif (maskPixbuf == 0) SWT.error (SWT.ERROR_NO_HANDLES);", "-\t\tOS.gdk_pixbuf_get_from_drawable(maskPixbuf, image.mask, 0, 0, 0, 0, 0, w [0], h [0]);", "-\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "-\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\tint stride = OS.gdk_pixbuf_get_rowstride (pixbuf);", "+\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels (pixbuf);", "-\t\tint maskStride = OS.gdk_pixbuf_get_rowstride(maskPixbuf);", "-\t\tint /*long*/ maskPixels = OS.gdk_pixbuf_get_pixels(maskPixbuf);", "-\t\tbyte[] maskLine = new byte[maskStride];", "-\t\tfor (int y=0; y<h[0]; y++) {", "-\t\t\tint /*long*/ offset = pixels + (y * stride);", "-\t\t\tOS.memmove(line, offset, stride);", "-\t\t\tint /*long*/ maskOffset = maskPixels + (y * maskStride);", "-\t\t\tOS.memmove(maskLine, maskOffset, maskStride);", "-\t\t\tfor (int x=0; x<w[0]; x++) {", "-\t\t\t\tif (maskLine[x * 3] == 0) {", "-\t\t\t\t\tline[x * 4 + 3] = 0;", "+\t\tint /*long*/ ptr = OS.malloc(4);", "+\t\tOS.memmove(ptr, new int[]{1}, 4);", "+\t\tOS.memmove(line, ptr, 1);", "+\t\tOS.free(ptr);", "+\t\tint oa, or, og, ob;", "+\t\tboolean bigendian = line[0] == 0;", "+\t\tif (bigendian) {", "+\t\t\toa = 0; or = 1; og = 2; ob = 3;", "+\t\t} else {", "+\t\t\toa = 3; or = 2; og = 1; ob = 0;", "+\t\t}", "+\t\tint /*long*/ surfaceData = image.surfaceData;", "+\t\tfor (int y = 0; y < h; y++) {", "+\t\t\tOS.memmove (line, surfaceData + (y * stride), stride);", "+\t\t\tfor (int x = 0, offset = 0; x < w; x++, offset += 4) {", "+\t\t\t\tint a = line[offset + oa] & 0xFF;", "+\t\t\t\tint r = line[offset + or] & 0xFF;", "+\t\t\t\tint g = line[offset + og] & 0xFF;", "+\t\t\t\tint b = line[offset + ob] & 0xFF;", "+\t\t\t\tline[offset + 3] = (byte)a;", "+\t\t\t\tif (a != 0) {", "+\t\t\t\t\tline[offset + 0] = (byte)(((r) / (float)a) * 0xFF);", "+\t\t\t\t\tline[offset + 1] = (byte)(((g) / (float)a) * 0xFF);", "+\t\t\t\t\tline[offset + 2] = (byte)(((b) / (float)a) * 0xFF);", "-\t\t\tOS.memmove(offset, line, stride);", "+\t\t\tOS.memmove (pixels + (y * stride), line, stride);", "-\t\tOS.g_object_unref(maskPixbuf);", "-\t\tImageData data = image.getImageData ();", "-\t\tboolean hasAlpha = data.getTransparencyType () == SWT.TRANSPARENCY_ALPHA;", "-\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, hasAlpha, 8, w [0], h [0]);", "-\t\tif (pixbuf == 0) SWT.error (SWT.ERROR_NO_HANDLES);", "-\t\tOS.gdk_pixbuf_get_from_drawable (pixbuf, image.pixmap, colormap, 0, 0, 0, 0, w [0], h [0]);", "-\t\tif (hasAlpha) {", "-\t\t\tbyte [] alpha = data.alphaData;", "-\t\t\tint stride = OS.gdk_pixbuf_get_rowstride (pixbuf);", "-\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels (pixbuf);", "-\t\t\tbyte [] line = new byte [stride];", "-\t\t\tfor (int y = 0; y < h [0]; y++) {", "+\t\tint [] w = new int [1], h = new int [1];", "+\t \tOS.gdk_drawable_get_size (image.pixmap, w, h);", "+\t\tint /*long*/ colormap = OS.gdk_colormap_get_system ();", "+\t\tboolean hasMask = image.mask != 0 && OS.gdk_drawable_get_depth (image.mask) == 1;", "+\t\tif (hasMask) {", "+\t\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, true, 8, w [0], h [0]);", "+\t\t\tif (pixbuf == 0) SWT.error (SWT.ERROR_NO_HANDLES);", "+\t\t\tOS.gdk_pixbuf_get_from_drawable (pixbuf, image.pixmap, colormap, 0, 0, 0, 0, w [0], h [0]);", "+\t\t\tint /*long*/ maskPixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, w [0], h [0]);", "+\t\t\tif (maskPixbuf == 0) SWT.error (SWT.ERROR_NO_HANDLES);", "+\t\t\tOS.gdk_pixbuf_get_from_drawable(maskPixbuf, image.mask, 0, 0, 0, 0, 0, w [0], h [0]);", "+\t\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "+\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\t\tbyte[] line = new byte[stride];", "+\t\t\tint maskStride = OS.gdk_pixbuf_get_rowstride(maskPixbuf);", "+\t\t\tint /*long*/ maskPixels = OS.gdk_pixbuf_get_pixels(maskPixbuf);", "+\t\t\tbyte[] maskLine = new byte[maskStride];", "+\t\t\tfor (int y=0; y<h[0]; y++) {", "-\t\t\t\tOS.memmove (line, offset, stride);", "-\t\t\t\tfor (int x = 0; x < w [0]; x++) {", "-\t\t\t\t\tline [x*4+3] = alpha [y*w [0]+x];", "+\t\t\t\tOS.memmove(line, offset, stride);", "+\t\t\t\tint /*long*/ maskOffset = maskPixels + (y * maskStride);", "+\t\t\t\tOS.memmove(maskLine, maskOffset, maskStride);", "+\t\t\t\tfor (int x=0; x<w[0]; x++) {", "+\t\t\t\t\tif (maskLine[x * 3] == 0) {", "+\t\t\t\t\t\tline[x * 4 + 3] = 0;", "+\t\t\t\t\t}", "-\t\t\t\tOS.memmove (offset, line, stride);", "+\t\t\t\tOS.memmove(offset, line, stride);", "+\t\t\t}", "+\t\t\tOS.g_object_unref(maskPixbuf);", "+\t\t} else {", "+\t\t\tImageData data = image.getImageData ();", "+\t\t\tboolean hasAlpha = data.getTransparencyType () == SWT.TRANSPARENCY_ALPHA;", "+\t\t\tpixbuf = OS.gdk_pixbuf_new (OS.GDK_COLORSPACE_RGB, hasAlpha, 8, w [0], h [0]);", "+\t\t\tif (pixbuf == 0) SWT.error (SWT.ERROR_NO_HANDLES);", "+\t\t\tOS.gdk_pixbuf_get_from_drawable (pixbuf, image.pixmap, colormap, 0, 0, 0, 0, w [0], h [0]);", "+\t\t\tif (hasAlpha) {", "+\t\t\t\tbyte [] alpha = data.alphaData;", "+\t\t\t\tint stride = OS.gdk_pixbuf_get_rowstride (pixbuf);", "+\t\t\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels (pixbuf);", "+\t\t\t\tbyte [] line = new byte [stride];", "+\t\t\t\tfor (int y = 0; y < h [0]; y++) {", "+\t\t\t\t\tint /*long*/ offset = pixels + (y * stride);", "+\t\t\t\t\tOS.memmove (line, offset, stride);", "+\t\t\t\t\tfor (int x = 0; x < w [0]; x++) {", "+\t\t\t\t\t\tline [x*4+3] = alpha [y*w [0]+x];", "+\t\t\t\t\t}", "+\t\t\t\t\tOS.memmove (offset, line, stride);", "+\t\t\t\t}"]}], "num": 50566}