{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "899fa7a7625c03e19b658a8de24012bd", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "333dff05d42f2175b76c7e1e530549a3", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/FontDialog.java", "commitBeforeChange": "25e0b9cefcf6aad913e775e22fb19b1e3de2a216", "commitAfterChange": "abdb7df6c5ef7f31dd770f626e22ad0d039e1629", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public FontData open ()", "signatureAfterChange": " public FontData open ()", "diff": ["-\tFontSelectionQDStyle qdStyle = new FontSelectionQDStyle();", "-\tqdStyle.version = OS.kFontSelectionQDStyleVersionZero;", "-\t// NEEDS WORK - color not supported in native dialog for Carbon", "-\tif (rgb != null) {", "-\t\tqdStyle.hasColor = true;", "-\t\tqdStyle.color_red = (short)(rgb.red * 257);", "-\t\tqdStyle.color_green = (short)(rgb.green * 257);", "-\t\tqdStyle.color_blue = (short)(rgb.blue * 257);", "-\t}", "+\tDisplay display = parent != null ? parent.display : Display.getCurrent ();", "-\t\tString familyName = fontData.name;", "-\t\tint[] font = new int[1];", "-\t\tbyte[] buffer = familyName.getBytes();", "-\t\tif (OS.ATSUFindFontFromName(buffer, buffer.length, OS.kFontFamilyName, OS.kFontNoPlatformCode, OS.kFontNoScriptCode, OS.kFontNoLanguageCode, font) == OS.noErr) {", "-\t\t\tshort[] family = new short[1];", "-\t\t\tOS.FMGetFontFamilyInstanceFromFont(font[0], family, new short[1]);\t\t", "-\t\t\tqdStyle.instance_fontFamily = family[0];", "-\t\t}", "-\t\tint style = fontData.style;", "-\t\tint fontStyle = OS.normal;", "-\t\tif ((style & SWT.BOLD) != 0) fontStyle |= OS.bold;", "-\t\tif ((style & SWT.ITALIC) != 0) fontStyle |= OS.italic;", "-\t\tqdStyle.instance_fontStyle = (short)fontStyle;", "-\t\tqdStyle.size = (short)fontData.height;", "+\t\tFont font = new Font (display, fontData);", "+\t\tint ptr = OS.NewPtr (4);", "+\t\tOS.memcpy (ptr, new int []{font.atsuiStyle}, 4);", "+\t\t//TODO - not sure how to set initial color in font panel", "+//\t\tif (rgb != null) {", "+//\t\t\tRGBColor color = new RGBColor ();", "+//\t\t\trgb.red = (short) (rgb.red * 0xffff);", "+//\t\t\trgb.green = (short) (rgb.green * 0xffff);", "+//\t\t\trgb.blue = (short) (rgb.blue * 0xffff);", "+//\t\t\tint ptr1 = OS.NewPtr (RGBColor.sizeof);", "+//\t\t\tOS.memcpy(ptr, color, RGBColor.sizeof); ", "+//\t\t\tint [] tags = new int []{OS.kATSUColorTag};", "+//\t\t\tint [] sizes = new int []{RGBColor.sizeof};", "+//\t\t\tint [] values = new int []{ptr1};", "+//\t\t\tOS.ATSUSetAttributes (font.atsuiStyle, tags.length, tags, sizes, values);", "+//\t\t\tOS.DisposePtr(ptr1);", "+//\t\t}\t\t", "+\t\tOS.SetFontInfoForSelection (OS.kFontSelectionATSUIType, 1, ptr, 0);", "+\t\tOS.DisposePtr (ptr);", "+\t\tfont.dispose ();", "-\tint ptr = OS.NewPtr(FontSelectionQDStyle.sizeof);", "-\tOS.memcpy (ptr, qdStyle, FontSelectionQDStyle.sizeof);", "-\tOS.SetFontInfoForSelection(OS.kFontSelectionQDType, 1, ptr, 0);", "-\tOS.DisposePtr (ptr);", "+\tfontSize = fontID = 0;", "-\tDisplay display = parent.display;", "+\tif (fontID != 0 && fontSize != 0) {", "+\t\tint atsFont = OS.FMGetATSFontRefFromFont (fontID);", "+\t\tFont font = Font.carbon_new (display, atsFont, (short) 0, (float) OS.Fix2X (fontSize));", "+\t\tfontData = font.getFontData ()[0];", "+\t\tfont.dispose();", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1e3b03196c1f6643ebe72473b870c794", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Mozilla/common/org/eclipse/swt/browser/Mozilla.java", "commitBeforeChange": "852f17f3e885ddde267886a8be3483ac6f27465d", "commitAfterChange": "3cdae47da159662ce7eb57e9a6b0f13f94eaec5c", "methodNumberBeforeChange": 146, "methodNumberAfterChange": 145, "signatureBeforeChange": "  int OnStateChange (int aWebProgress, int aRequest, int aStateFlags, int aStatus)", "signatureAfterChange": "  int OnStateChange (int aWebProgress, int aRequest, int aStateFlags, int aStatus)", "diff": ["-\t\t\tif (!IsPre_2) {", "-\t\t\t\tnsIDOMWindow domWindow = new nsIDOMWindow (window[0]);", "-\t\t\t\trc = domWindow.QueryInterface (nsIDOMEventTarget.NS_IDOMEVENTTARGET_IID, result);", "-\t\t\t\tdomWindow.Release();", "-\t\t\t} else {", "-\t\t\t\tnsIDOMWindow_1_9 domWindow = new nsIDOMWindow_1_9 (window[0]);", "-\t\t\t\trc = domWindow.QueryInterface (nsIDOMEventTarget_1_9.NS_IDOMEVENTTARGET_IID, result);", "-\t\t\t\tdomWindow.Release();", "-\t\t\t}", "+\t\t\tnsIDOMWindow domWindow = new nsIDOMWindow (window[0]);", "+\t\t\trc = domWindow.QueryInterface (!IsPre_4 ? nsIDOMEventTarget.NS_IDOMEVENTTARGET_8_IID : nsIDOMEventTarget.NS_IDOMEVENTTARGET_IID, result);", "+\t\t\tdomWindow.Release();", "-\t\t\tif (!IsPre_2) {", "-\t\t\t\tnsIDOMEventTarget target = new nsIDOMEventTarget (result[0]);", "-\t\t\t\thookDOMListeners (target, isTop);", "-\t\t\t\ttarget.Release ();", "-\t\t\t} else {", "-\t\t\t\tnsIDOMEventTarget_1_9 target = new nsIDOMEventTarget_1_9 (result[0]);", "-\t\t\t\thookDOMListeners_1_9 (target, isTop);", "-\t\t\t\ttarget.Release ();", "-\t\t\t}", "+\t\t\tnsIDOMEventTarget target = new nsIDOMEventTarget (result[0]);", "+\t\t\thookDOMListeners (target, isTop);", "+\t\t\ttarget.Release ();", "-\t\t\t\tif (!IsPre_2) {", "-\t\t\t\t\tnsIDOMWindow domWindow = new nsIDOMWindow (window[0]);", "-\t\t\t\t\trc = domWindow.QueryInterface (nsIDOMEventTarget.NS_IDOMEVENTTARGET_IID, result);", "-\t\t\t\t\tdomWindow.Release();", "-\t\t\t\t} else {", "-\t\t\t\t\tnsIDOMWindow_1_9 domWindow = new nsIDOMWindow_1_9 (window[0]);", "-\t\t\t\t\trc = domWindow.QueryInterface (nsIDOMEventTarget_1_9.NS_IDOMEVENTTARGET_IID, result);", "-\t\t\t\t\tdomWindow.Release();", "-\t\t\t\t}", "+\t\t\t\tnsIDOMWindow domWindow = new nsIDOMWindow (window[0]);", "+\t\t\t\trc = domWindow.QueryInterface (!IsPre_4 ? nsIDOMEventTarget.NS_IDOMEVENTTARGET_8_IID : nsIDOMEventTarget.NS_IDOMEVENTTARGET_IID, result);", "+\t\t\t\tdomWindow.Release();", "-\t\t\t\tif (!IsPre_2) {", "-\t\t\t\t\tnsIDOMEventTarget target = new nsIDOMEventTarget (result[0]);", "-\t\t\t\t\thookDOMListeners (target, isTop);", "-\t\t\t\t\ttarget.Release ();", "-\t\t\t\t} else {", "-\t\t\t\t\tnsIDOMEventTarget_1_9 target = new nsIDOMEventTarget_1_9 (result[0]);", "-\t\t\t\t\thookDOMListeners_1_9 (target, isTop);", "-\t\t\t\t\ttarget.Release ();", "-\t\t\t\t}", "+\t\t\t\tnsIDOMEventTarget target = new nsIDOMEventTarget (result[0]);", "+\t\t\t\thookDOMListeners (target, isTop);", "+\t\t\t\ttarget.Release ();", "-\t\t\trc = domWindow.QueryInterface (!IsPre_2 ? nsIDOMEventTarget.NS_IDOMEVENTTARGET_IID : nsIDOMEventTarget_1_9.NS_IDOMEVENTTARGET_IID, result);", "+\t\t\trc = domWindow.QueryInterface (!IsPre_4 ? nsIDOMEventTarget.NS_IDOMEVENTTARGET_8_IID : nsIDOMEventTarget.NS_IDOMEVENTTARGET_IID, result);", "-\t\t\tif (!IsPre_2) {", "-\t\t\t\tnsIDOMEventTarget target = new nsIDOMEventTarget (result[0]);", "-\t\t\t\thookDOMListeners (target, isTop);", "-\t\t\t\ttarget.Release ();", "-\t\t\t} else {", "-\t\t\t\tnsIDOMEventTarget_1_9 target = new nsIDOMEventTarget_1_9 (result[0]);", "-\t\t\t\thookDOMListeners_1_9 (target, isTop);", "-\t\t\t\ttarget.Release ();", "-\t\t\t}", "+\t\t\tnsIDOMEventTarget target = new nsIDOMEventTarget (result[0]);", "+\t\t\thookDOMListeners (target, isTop);", "+\t\t\ttarget.Release ();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "24182052fce4c502d8fae2d713583196", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/ToolItem.java", "commitBeforeChange": "9cc72cd00c181250b1f51b95a0528a6b993c1ed9", "commitAfterChange": "1c6100db3e7e2869dd9939a388c01ffe02266ae6", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  void createHandle (int index)", "signatureAfterChange": "  void createHandle (int index)", "diff": ["-\tif ((style & SWT.SEPARATOR) == 0) {", "-\t\tboxHandle = (parent.style & SWT.RIGHT) != 0 ? OS.gtk_hbox_new (false, 0) : OS.gtk_vbox_new (false, 0);", "-\t\tif (boxHandle == 0) error (SWT.ERROR_NO_HANDLES);", "-\t\tlabelHandle = OS.gtk_label_new_with_mnemonic (null);", "-\t\tif (labelHandle == 0) error (SWT.ERROR_NO_HANDLES);", "-\t\timageHandle = OS.gtk_image_new ();", "-\t\tif (imageHandle == 0) error (SWT.ERROR_NO_HANDLES);", "-\t\tOS.gtk_container_add (boxHandle, imageHandle);", "-\t\tOS.gtk_container_add (boxHandle, labelHandle);", "-\t\tif ((parent.style & SWT.VERTICAL) != 0) {", "-\t\t\t// Align text and images to the left", "-\t\t\tOS.gtk_box_set_child_packing (boxHandle, imageHandle, false, false, 0, OS.GTK_PACK_START);", "-\t\t\tOS.gtk_box_set_child_packing (boxHandle, labelHandle, false, false, 2, OS.GTK_PACK_START);", "-\t\t}", "-\t}", "-\t\t\thandle = OS.gtk_hbox_new (false, 0);", "+\t\t\thandle = OS.gtk_separator_tool_item_new ();", "-\t\t\tboolean isVertical = (parent.style & SWT.VERTICAL) != 0;", "-\t\t\tseparatorHandle = isVertical ? OS.gtk_hseparator_new() : OS.gtk_vseparator_new();", "-\t\t\tif (separatorHandle == 0) error (SWT.ERROR_NO_HANDLES);", "-\t\t\tOS.gtk_widget_set_size_request (separatorHandle, isVertical ? 15 : 6, isVertical ? 6 : 15);", "-\t\t\tOS.gtk_widget_set_size_request (handle, isVertical ? 15 : 6, isVertical ? 6 : 15);", "-\t\t\tOS.gtk_container_add (handle, separatorHandle);", "+\t\t\tOS.gtk_separator_tool_item_set_draw (handle, true);", "-\t\t\thandle = OS.gtk_button_new ();", "-\t\t\tif (handle == 0) error (SWT.ERROR_NO_HANDLES);", "-\t\t\tarrowBoxHandle = OS.gtk_hbox_new (false, 0);", "-\t\t\tif (arrowBoxHandle == 0) error(SWT.ERROR_NO_HANDLES);", "-\t\t\tarrowHandle = OS.gtk_arrow_new (OS.GTK_ARROW_DOWN, OS.GTK_SHADOW_NONE);", "-\t\t\tif (arrowHandle == 0) error (SWT.ERROR_NO_HANDLES);", "-\t\t\tOS.gtk_widget_set_size_request (arrowHandle, 8, 6);", "-\t\t\tOS.gtk_container_add (handle, arrowBoxHandle);", "-\t\t\tOS.gtk_container_add (arrowBoxHandle, boxHandle);\t", "-\t\t\tOS.gtk_container_add (arrowBoxHandle, arrowHandle);\t", "+\t\t\tif (OS.GTK_VERSION >= OS.VERSION (2, 6, 0)) {", "+\t\t\t\thandle = OS.gtk_menu_tool_button_new (0, null);", "+\t\t\t\tif (handle == 0) error (SWT.ERROR_NO_HANDLES);", "+\t\t\t\t/*", "+\t\t\t\t * Feature in GTK. The arrow button of DropDown tool-item is ", "+\t\t\t\t * disabled when it does not contain menu. The fix is to", "+\t\t\t\t * find the arrow button handle and enable it.", "+\t\t\t\t */", "+\t\t\t\tint /*long*/ child = OS.gtk_bin_get_child (handle);", "+\t\t\t\tint /*long*/ list = OS.gtk_container_get_children (child);", "+\t\t\t\tarrowHandle = OS.g_list_nth_data (list, 1);", "+\t\t\t\tOS.gtk_widget_set_sensitive (arrowHandle, true);", "+\t\t\t} else {", "+\t\t\t\t/*", "+\t\t\t\t * GTK does not support GtkMenuToolButton until 2.6.", "+\t\t\t\t * So, we try to emulate it on the un-supported version.", "+\t\t\t\t */", "+\t\t\t\thandle = OS.gtk_tool_button_new (0, null);", "+\t\t\t\tif (handle == 0) error (SWT.ERROR_NO_HANDLES);", "+\t\t\t\tlabelHandle = OS.gtk_label_new_with_mnemonic (null);", "+\t\t\t\tif (labelHandle == 0) error (SWT.ERROR_NO_HANDLES);", "+\t\t\t\tarrowBoxHandle = OS.gtk_hbox_new (false, 0);", "+\t\t\t\tif (arrowBoxHandle == 0) error(SWT.ERROR_NO_HANDLES);", "+\t\t\t\tarrowHandle = OS.gtk_arrow_new (OS.GTK_ARROW_DOWN, OS.GTK_SHADOW_NONE);", "+\t\t\t\tif (arrowHandle == 0) error (SWT.ERROR_NO_HANDLES);", "+\t\t\t\tOS.gtk_widget_set_size_request (arrowHandle, 8, 6);", "+\t\t\t\tOS.gtk_tool_button_set_label_widget (handle, arrowBoxHandle);", "+\t\t\t\tOS.gtk_container_add (arrowBoxHandle, labelHandle);\t", "+\t\t\t\tOS.gtk_container_add (arrowBoxHandle, arrowHandle);", "+\t\t\t\t/*", "+\t\t\t\t * As we are try to emulate GtkMenuToolButton and in order", "+\t\t\t\t * to display both the label and image, it is required", "+\t\t\t\t * the set the toolitem as important. This will entitle", "+\t\t\t\t * to display the label all the times.    ", "+\t\t\t\t */", "+\t\t\t\tOS.gtk_tool_item_set_is_important (handle, true);", "+\t\t\t}", "-\t\t\t* This code is intentionally commented.  Because GTK", "-\t\t\t* enforces radio behavior in a button group a radio group", "-\t\t\t* is not created for each set of contiguous buttons, each", "-\t\t\t* radio button will not draw unpressed.  The fix is to use", "-\t\t\t* toggle buttons instead.", "+\t\t\t* Because GTK enforces radio behavior in a button group ", "+\t\t\t* a radio group is not created for each set of contiguous", "+\t\t\t* buttons, each radio button will not draw unpressed.", "+\t\t\t* The fix is to use toggle buttons instead.", "-//\t\t\thandle = OS.gtk_radio_button_new (0);", "-//\t\t\tif (handle == 0) error (SWT.ERROR_NO_HANDLES);", "-//\t\t\tOS.gtk_toggle_button_set_mode (handle, false);", "-//\t\t\tOS.gtk_container_add (handle, boxHandle);\t", "-//\t\t\tbreak;", "-\t\t\thandle = OS.gtk_toggle_button_new ();", "+\t\t\thandle = OS.gtk_toggle_tool_button_new ();", "-\t\t\tOS.gtk_toggle_button_set_mode (handle, false);", "-\t\t\tOS.gtk_container_add (handle, boxHandle);\t", "-\t\t\thandle = OS.gtk_button_new ();", "+\t\t\thandle = OS.gtk_tool_button_new (0, null);", "-\t\t\tOS.gtk_container_add (handle, boxHandle);", "+\t\t\tOS.gtk_tool_button_set_label (handle, null);", "-\tif ((style & SWT.SEPARATOR) == 0) {", "-\t\tint [] relief = new int [1];", "-\t\tOS.gtk_widget_style_get (parent.handle, OS.button_relief, relief, 0);", "-\t\tOS.gtk_button_set_relief (handle, relief [0]);", "-\t}", "-\tOS.GTK_WIDGET_UNSET_FLAGS (handle, OS.GTK_CAN_FOCUS);", "-//\tThis code is intentionally commented.", "-//\tint /*long*/ fontHandle = parent.fontHandle ();", "-//\tGdkColor color = new GdkColor ();", "-//\tint /*long*/ style = OS.gtk_widget_get_style (fontHandle);", "-//\tOS.gtk_style_get_fg (style, OS.GTK_STATE_NORMAL, color);", "-//\tint /*long*/ font = OS.gtk_style_get_font_desc (style);", "-//\tsetForegroundColor (color);", "-//\tsetFontDescription (font);", "+\t/*", "+\t * Feature in GTK. GtkToolButton class uses this property to ", "+\t * determine whether to show or hide its label when the toolbar ", "+\t * style is GTK_TOOLBAR_BOTH_HORIZ (or SWT.RIGHT).", "+\t */", "+\tif ((parent.style & SWT.RIGHT) != 0) OS.gtk_tool_item_set_is_important (handle, true);", "+\tif ((style & SWT.SEPARATOR) == 0) OS.gtk_tool_button_set_use_underline (handle, true);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d69e2cb51b7ae223ce122b6cba717372", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Mozilla/common/org/eclipse/swt/browser/Mozilla.java", "commitBeforeChange": "07959d909e8636c9d0fc8d0533ebc814870527be", "commitAfterChange": "2e018166adf3de407abb1d59b1d6d286fc16acc0", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public void create (Composite parent, int style)", "signatureAfterChange": "  public void create (Composite parent, int style)", "diff": ["+\t\t\tLocationProvider = new AppFileLocProvider (mozillaPath);", "+\t\t\tLocationProvider.AddRef ();", "+", "-\t\t\trc = XPCOM.NS_InitXPCOM2 (0, localFile.getAddress(), 0);", "+\t\t\trc = XPCOM.NS_InitXPCOM2 (0, localFile.getAddress(), LocationProvider.getAddress ());", "-\t\t\t", "+", "-\t\t/* compute the root profile directory */", "+\t\t/* compute the profile directory and set it on the AppFileLocProvider */", "-\t\tprofileRootDirectory = new String (MozillaDelegate.mbcsToWcs (null, buffer)) + PROFILE_DIR;", "+\t\tString profilePath = new String (MozillaDelegate.mbcsToWcs (null, buffer)) + PROFILE_DIR;", "+\t\tLocationProvider.setProfilePath (profilePath);", "+", "+\t\t/* notify observers of a new profile directory being used */", "+\t\tbuffer = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_OBSERVER_CONTRACTID, true);", "+\t\trc = serviceManager.GetServiceByContractID (buffer, nsIObserverService.NS_IOBSERVERSERVICE_IID, result);", "+\t\tif (rc != XPCOM.NS_OK) {", "+\t\t\tbrowser.dispose ();", "+\t\t\terror (rc);", "+\t\t}", "+\t\tif (result[0] == 0) {", "+\t\t\tbrowser.dispose ();", "+\t\t\terror (XPCOM.NS_NOINTERFACE);", "+\t\t}", "+", "+\t\tnsIObserverService observerService = new nsIObserverService (result[0]);", "+\t\tresult[0] = 0;", "+\t\tbuffer = MozillaDelegate.wcsToMbcs (null, PROFILE_DO_CHANGE, true);", "+\t\tlength = STARTUP.length ();", "+\t\tchar[] chars = new char [length + 1];", "+\t\tSTARTUP.getChars (0, length, chars, 0);", "+\t\trc = observerService.NotifyObservers (0, buffer, chars);", "+\t\tif (rc != XPCOM.NS_OK) {", "+\t\t\tbrowser.dispose ();", "+\t\t\terror (rc);", "+\t\t}", "+\t\tbuffer = MozillaDelegate.wcsToMbcs (null, PROFILE_AFTER_CHANGE, true);", "+\t\trc = observerService.NotifyObservers (0, buffer, chars);", "+\t\tif (rc != XPCOM.NS_OK) {", "+\t\t\tbrowser.dispose ();", "+\t\t\terror (rc);", "+\t\t}", "+\t\tobserverService.Release ();", "-\trc = XPCOM.NS_GetServiceManager (result);", "-\tif (rc != XPCOM.NS_OK) {", "-\t\tbrowser.dispose ();", "-\t\terror (rc);", "-\t}", "-\tif (result[0] == 0) {", "-\t\tbrowser.dispose ();", "-\t\terror (XPCOM.NS_NOINTERFACE);", "-\t}", "-", "-\tnsIServiceManager serviceManager = new nsIServiceManager (result[0]);", "-\tresult[0] = 0;\t\t", "-\tbyte[] buffer = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_DIRECTORYSERVICE_CONTRACTID, true);", "-\trc = serviceManager.GetServiceByContractID (buffer, nsIDirectoryService.NS_IDIRECTORYSERVICE_IID, result);", "-\tif (rc != XPCOM.NS_OK) {", "-\t\tbrowser.dispose ();", "-\t\terror (rc);", "-\t}", "-\tif (result[0] == 0) {", "-\t\tbrowser.dispose ();", "-\t\terror (XPCOM.NS_NOINTERFACE);", "-\t}", "-", "-\tnsIDirectoryService directoryService = new nsIDirectoryService (result[0]);", "-\tresult[0] = 0;", "-\trc = directoryService.RegisterProvider(directoryServiceProviderListener.getAddress ());", "-\tif (rc != XPCOM.NS_OK) {", "-\t\tbrowser.dispose ();", "-\t\terror (rc);", "-\t}", "-\tdirectoryService.Release ();", "-", "-\tbuffer = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_OBSERVER_CONTRACTID, true);", "-\trc = serviceManager.GetServiceByContractID (buffer, nsIObserverService.NS_IOBSERVERSERVICE_IID, result);", "-\tif (rc != XPCOM.NS_OK) {", "-\t\tbrowser.dispose ();", "-\t\terror (rc);", "-\t}", "-\tif (result[0] == 0) {", "-\t\tbrowser.dispose ();", "-\t\terror (XPCOM.NS_NOINTERFACE);", "-\t}", "-\tserviceManager.Release ();", "-", "-\tnsIObserverService observerService = new nsIObserverService (result[0]);", "-\tresult[0] = 0;", "-\tbuffer = MozillaDelegate.wcsToMbcs (null, PROFILE_DO_CHANGE, true);", "-\tint length = STARTUP.length ();", "-\tchar[] chars = new char [length + 1];", "-\tSTARTUP.getChars (0, length, chars, 0);", "-\trc = observerService.NotifyObservers (0, buffer, chars);", "-\tif (rc != XPCOM.NS_OK) {", "-\t\tbrowser.dispose ();", "-\t\terror (rc);", "-\t}", "-\tbuffer = MozillaDelegate.wcsToMbcs (null, PROFILE_AFTER_CHANGE, true);", "-\trc = observerService.NotifyObservers (0, buffer, chars);", "-\tif (rc != XPCOM.NS_OK) {", "-\t\tbrowser.dispose ();", "-\t\terror (rc);", "-\t}", "-\tobserverService.Release ();", "-"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5562937ae192597c484ddde3678cf95f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "9ff10cb48f82b9ae865058d0bbaabcdfd7febeca", "commitAfterChange": "74127501f3b2eceb3db2c2e14c28ae868f8a3b22", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": " void shape (final int hdc, final StyleItem run)", "signatureAfterChange": " void shape (final int hdc, final StyleItem run)", "diff": ["-\t* Feature in Uniscribe, the U+FEFF is not supported by", "+\t* Feature in Uniscribe, .. ..  the U+FEFF is not supported by", "-\tfor (int i = 0; i < chars.length; i++) {", "-\t\tif (chars[i] == '\\uFEFF') chars[i] = '\\u200B';", "-\t}", "+\tfinal short script = run.analysis.eScript;", "+\tSCRIPT_PROPERTIES sp = new SCRIPT_PROPERTIES();", "+\tOS.MoveMemory(sp, device.scripts[script], SCRIPT_PROPERTIES.sizeof);", "+\tfinal boolean useCMap = false;", "-\tfinal short script = run.analysis.eScript;", "-\tfinal SCRIPT_PROPERTIES sp = new SCRIPT_PROPERTIES();", "-\tOS.MoveMemory(sp, device.scripts[script], SCRIPT_PROPERTIES.sizeof);", "-\tboolean shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "+\tboolean shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, useCMap);", "-\tif (!shapeSucceed) {", "-\t\t/* ", "-\t\t * Shape failed.", "-\t\t * Try to shape with fNoGlyphIndex when the run is in the ", "-\t\t * Private Use Area. This allows for end-user-defined character (EUDC).", "-\t\t */", "-\t\tif (sp.fPrivateUseArea) {", "-\t\t\trun.analysis.fNoGlyphIndex = true;", "-\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "-\t\t}", "-\t}", "+//\tif (!shapeSucceed) {", "+//\t\t/* ", "+//\t\t * Shape failed.", "+//\t\t * Try to shape with fNoGlyphIndex when the run is in the ", "+//\t\t * Private Use Area. This allows for end-user-defined character (EUDC).", "+//\t\t */", "+//\t\tif (sp.fPrivateUseArea) {", "+//\t\t\trun.analysis.fNoGlyphIndex = true;", "+//\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, useCMap);", "+//\t\t}", "+//\t}", "+\t", "+//\tif (!shapeSucceed) {", "+//\tint hFont = OS.bogus(hdc, chars, chars.length);", "+//\tif (hFont != 0) {", "+//\t\tSystem.out.println(script + \" FALLBACK \" + Font.win32_new(device, hFont).getFontData()[0]);", "+//\t\tint /*long*/ oldFont = OS.SelectObject(hdc, hFont);", "+//\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, false);", "+//\t\tif (shapeSucceed) {", "+//\t\t\trun.fallbackFont = hFont;", "+//\t\t\tSystem.out.println(script + \" FALLBACK SUCCED\");", "+//\t\t}", "+//\t} else {", "+//\t\tSystem.out.println(\"fallback failed\");", "+//\t}", "+//}", "+", "-\t\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "+\t\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, false);", "+\t\t\t\t\tSystem.out.println(script + \" MLANG \" + Font.win32_new(device, run.fallbackFont).getFontData()[0]);", "-\t", "+", "-\t\t/*", "-\t\t* Shape Failed.", "-\t\t* Try to shape the run using the LOGFONT in the cache.", "-\t\t*/", "-\t\tfinal int /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "-\t\tfinal LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "-\t\t", "-\t\tLOGFONT cachedLogFont = device.logFontsCache != null ? device.logFontsCache[script] : null;", "-\t\tif (cachedLogFont != null) {", "-\t\t\tcachedLogFont.lfHeight = logFont.lfHeight;", "-\t\t\tcachedLogFont.lfWeight = logFont.lfWeight;", "-\t\t\tcachedLogFont.lfItalic = logFont.lfItalic;", "-\t\t\tcachedLogFont.lfWidth = logFont.lfWidth;", "-\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(cachedLogFont);", "+\t\tif (!sp.fComplex) {", "+\t\t\tint /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "+\t\t\tLOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "+\t\t\tLOGFONT systemLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+\t\t\tOS.GetObject(device.systemFont.handle, LOGFONT.sizeof, systemLogFont);", "+\t\t\tsystemLogFont.lfHeight = logFont.lfHeight;", "+\t\t\tsystemLogFont.lfWeight = logFont.lfWeight;", "+\t\t\tsystemLogFont.lfItalic = logFont.lfItalic;", "+\t\t\tsystemLogFont.lfWidth = logFont.lfWidth;", "+\t\t\tint newFont = OS.CreateFontIndirect (systemLogFont);", "-\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp);", "+\t\t\trun.analysis.fNoGlyphIndex = true;", "+\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, false);", "+\t\t\t\tSystem.out.println(\"fNoGlyphIndex \" + script);", "+\t\t\t\trun.analysis.fNoGlyphIndex = false;", "-\t\t}", "-\t\tif (!shapeSucceed) {", "-\t\t\t/*", "-\t\t\t* Shape Failed.", "-\t\t\t* Use EnumFontFamExProc to iterate over every font in the system that supports ", "-\t\t\t* the charset of the run and try to shape it.  ", "-\t\t\t*/", "-\t\t\tif (device.logFontsCache == null) device.logFontsCache = new LOGFONT[device.scripts.length];", "-\t\t\tfinal LOGFONT newLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\tclass EnumFontFamEx {", "-\t\t\t\tint /*long*/ EnumFontFamExProc (int /*long*/ lpelfe, int /*long*/ lpntme, int /*long*/ FontType, int /*long*/ lParam) {", "-\t\t\t\t\tif (FontType == OS.RASTER_FONTTYPE) return 1;", "-\t\t\t\t\tOS.MoveMemory(newLogFont, lpelfe, LOGFONT.sizeof);", "-\t\t\t\t\tnewLogFont.lfHeight = logFont.lfHeight;", "-\t\t\t\t\tnewLogFont.lfWeight = logFont.lfWeight;", "-\t\t\t\t\tnewLogFont.lfItalic = logFont.lfItalic;", "-\t\t\t\t\tnewLogFont.lfWidth = logFont.lfWidth;", "-\t\t\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(newLogFont);", "-\t\t\t\t\tOS.SelectObject(hdc, newFont);", "-\t\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs, sp)) {", "-\t\t\t\t\t\trun.fallbackFont = newFont;", "-\t\t\t\t\t\tLOGFONT cacheLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "-\t\t\t\t\t\tOS.MoveMemory(cacheLogFont, lpelfe, LOGFONT.sizeof);", "-\t\t\t\t\t\tdevice.logFontsCache[script] = cacheLogFont;", "-\t\t\t\t\t\treturn 0;", "-\t\t\t\t\t}", "-\t\t\t\t\tOS.SelectObject(hdc, hFont);", "-\t\t\t\t\tOS.DeleteObject(newFont);", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t};", "-\t\t\tEnumFontFamEx object = new EnumFontFamEx();", "-\t\t\t/* Avoid compiler warnings */", "-\t\t\tif (false) object.EnumFontFamExProc(0, 0, 0, 0);", "-\t\t\tCallback callback = new Callback(object, \"EnumFontFamExProc\", 4);", "-\t\t\tint /*long*/ address = callback.getAddress();", "-\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "-\t\t\tint charSet = sp.fAmbiguousCharSet ? OS.DEFAULT_CHARSET : sp.bCharSet;", "-\t\t\tnewLogFont.lfCharSet = (byte)charSet;", "-\t\t\tOS.EnumFontFamiliesEx(hdc, newLogFont, address, 0, 0);", "-\t\t\tcallback.dispose();", "-\t\t\tshapeSucceed = run.fallbackFont != 0;", "+//\tif (!shapeSucceed && false) {", "+//\t\t/*", "+//\t\t* Shape Failed.", "+//\t\t* Try to shape the run using the LOGFONT in the cache.", "+//\t\t*/", "+//\t\tfinal int /*long*/ hFont = OS.GetCurrentObject(hdc, OS.OBJ_FONT);", "+//\t\tfinal LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+//\t\tOS.GetObject(hFont, LOGFONT.sizeof, logFont);", "+//\t\t", "+//\t\tLOGFONT cachedLogFont = device.logFontsCache != null ? device.logFontsCache[script] : null;", "+//\t\tif (cachedLogFont != null) {", "+//\t\t\tcachedLogFont.lfHeight = logFont.lfHeight;", "+//\t\t\tcachedLogFont.lfWeight = logFont.lfWeight;", "+//\t\t\tcachedLogFont.lfItalic = logFont.lfItalic;", "+//\t\t\tcachedLogFont.lfWidth = logFont.lfWidth;", "+//\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(cachedLogFont);", "+//\t\t\tOS.SelectObject(hdc, newFont);", "+//\t\t\tshapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, useCMap);", "+//\t\t\tif (shapeSucceed) {", "+//\t\t\t\trun.fallbackFont = newFont;", "+//\t\t\t\tSystem.out.println(script + \" CACHE \" + Font.win32_new(device, run.fallbackFont).getFontData()[0]);", "+//\t\t\t} else {", "+//\t\t\t\tOS.SelectObject(hdc, hFont);", "+//\t\t\t\tOS.DeleteObject(newFont);", "+//\t\t\t}", "+//\t\t}", "+//\t\tif (!shapeSucceed) {", "+//\t\t\t/*", "+//\t\t\t* Shape Failed.", "+//\t\t\t* Use EnumFontFamExProc to iterate over every font in the system that supports ", "+//\t\t\t* the charset of the run and try to shape it.  ", "+//\t\t\t*/", "+//\t\t\tif (device.logFontsCache == null) device.logFontsCache = new LOGFONT[device.scripts.length];", "+//\t\t\tfinal LOGFONT newLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+//\t\t\tclass EnumFontFamEx {", "+//\t\t\t\tint /*long*/ EnumFontFamExProc (int /*long*/ lpelfe, int /*long*/ lpntme, int /*long*/ FontType, int /*long*/ lParam) {", "+//\t\t\t\t\tif (FontType == OS.RASTER_FONTTYPE) return 1;", "+//\t\t\t\t\tOS.MoveMemory(newLogFont, lpelfe, LOGFONT.sizeof);", "+//\t\t\t\t\tnewLogFont.lfHeight = logFont.lfHeight;", "+//\t\t\t\t\tnewLogFont.lfWeight = logFont.lfWeight;", "+//\t\t\t\t\tnewLogFont.lfItalic = logFont.lfItalic;", "+//\t\t\t\t\tnewLogFont.lfWidth = logFont.lfWidth;", "+//\t\t\t\t\tint /*long*/ newFont = OS.CreateFontIndirect(newLogFont);", "+//\t\t\t\t\tOS.SelectObject(hdc, newFont);", "+//\t\t\t\t\tif (shape(hdc, run, chars, buffer, maxGlyphs, useCMap)) {", "+//\t\t\t\t\t\trun.fallbackFont = newFont;", "+//\t\t\t\t\t\tLOGFONT cacheLogFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW () : new LOGFONTA ();", "+//\t\t\t\t\t\tOS.MoveMemory(cacheLogFont, lpelfe, LOGFONT.sizeof);", "+//\t\t\t\t\t\tdevice.logFontsCache[script] = cacheLogFont;", "+//\t\t\t\t\t\tSystem.out.println(script + \" ENUM \" + Font.win32_new(device, run.fallbackFont).getFontData()[0]);", "+//\t\t\t\t\t\treturn 0;", "+//\t\t\t\t\t}", "+//\t\t\t\t\tOS.SelectObject(hdc, hFont);", "+//\t\t\t\t\tOS.DeleteObject(newFont);", "+//\t\t\t\t\treturn 1;", "+//\t\t\t\t}", "+//\t\t\t};", "+//\t\t\tEnumFontFamEx object = new EnumFontFamEx();", "+//\t\t\t/* Avoid compiler warnings */", "+//\t\t\tif (false) object.EnumFontFamExProc(0, 0, 0, 0);", "+//\t\t\tCallback callback = new Callback(object, \"EnumFontFamExProc\", 4);", "+//\t\t\tint /*long*/ address = callback.getAddress();", "+//\t\t\tif (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);", "+//\t\t\tint charSet = sp.fAmbiguousCharSet ? OS.DEFAULT_CHARSET : sp.bCharSet;", "+//\t\t\tnewLogFont.lfCharSet = (byte)charSet;", "+//\t\t\tOS.EnumFontFamiliesEx(hdc, newLogFont, address, 0, 0);", "+//\t\t\tcallback.dispose();", "+//\t\t\tshapeSucceed = run.fallbackFont != 0;", "+//\t\t}", "+//\t}", "+\t", "+\t\tSystem.out.println(\"NONE \" + script);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ee9b1f22a05443612a64cb2b073a1d8f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/StyledTextRenderer.java", "commitBeforeChange": "4862a25e5d82327325fbe4d7e3507daf3c19785e", "commitAfterChange": "2067e0ae09764d86e67e032bb852a5c292b109a1", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " int drawLine(int lineIndex, int paintX, int paintY, GC gc, Color widgetBackground, Color widgetForeground)", "signatureAfterChange": " int drawLine(int lineIndex, int paintX, int paintY, GC gc, Color widgetBackground, Color widgetForeground)", "diff": ["-\tif (!fullSelection || selectionStart > lineOffset || selectionEnd <= lineOffset + lineLength) {", "-\t\t// draw background if full selection is off or if line is not completely selected", "-\t\tgc.setBackground(lineBackground);", "-\t\tstyledText.drawBackground(gc, client.x, paintY, client.width, layout.getBounds().height);", "-\t}", "-\tif (selectionStart != selectionEnd) {", "-\t\tint y = paintY;", "+\tboolean isWPF = StyledText.IS_WPF;", "+\tgc.setBackground(lineBackground);", "+\tint height = layout.getBounds().height;", "+\tstyledText.drawBackground(gc, client.x, paintY, client.width, height);", "+\t", "+\tif (!isWPF && selectionStart != selectionEnd) {", "-\t\tint lineCount = layout.getLineCount();", "-\t\tif (fullSelection) {", "-\t\t\tint[] offsets = layout.getLineOffsets();", "-\t\t\tfor (int i = 0; i < lineCount - 1; i++) {", "-\t\t\t\tint lineStart = offsets[i];", "-\t\t\t\tif (lineStart >= selectionEnd - lineOffset) break;", "-\t\t\t\tint lineEnd = offsets[i + 1];", "-\t\t\t\tRectangle lineBounds = layout.getLineBounds(i);", "-\t\t\t\tif (selectionStart - lineOffset <= lineEnd && lineEnd <= selectionEnd - lineOffset) {", "-\t\t\t\t\tint x = paintX + lineBounds.x + lineBounds.width;", "-\t\t\t\t\tgc.fillRectangle(x, y, client.width - x, lineBounds.height);", "-\t\t\t\t}", "-\t\t\t\ty += lineBounds.height + layout.getSpacing();", "-\t\t\t}", "-\t\t}", "-\t\tif (selectionStart - lineOffset <= lineLength && lineLength < selectionEnd - lineOffset) {", "-\t\t\tRectangle lineBounds = layout.getLineBounds(lineCount - 1);", "-\t\t\tint x = paintX + lineBounds.x + lineBounds.width;", "-\t\t\tif (fullSelection) {", "-\t\t\t\tgc.fillRectangle(x, paintY + lineBounds.y, client.width - styledText.rightMargin - x, lineBounds.height);", "-\t\t\t} else {", "-\t\t\t\tgc.fillRectangle(x, paintY + lineBounds.y, lineEndSpaceWidth, lineBounds.height);", "-\t\t\t}", "-\t\t}", "+\t\tint selStart = selectionStart - lineOffset;", "+\t\tint selEnd = selectionEnd - lineOffset;", "+\t\tdrawLineSelection(paintX, paintY, gc, layout, lineLength, selStart, selEnd, client.width, fullSelection);", "+\t}", "+\t", "+\tif (isWPF && selectionStart != selectionEnd) {", "+\t\tint alpha = gc.getAlpha();", "+\t\tgc.setAlpha(102);", "+\t\tgc.setBackground(styledText.getSelectionBackground());", "+\t\tint selStart = selectionStart - lineOffset;", "+\t\tint selEnd = selectionEnd - lineOffset;", "+\t\tdrawLineSelection(paintX, paintY, gc, layout, lineLength, selStart, selEnd, client.width, fullSelection);", "+\t\tgc.setAlpha(alpha);", "-\tint height = layout.getBounds().height;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a87743adb092ea4d40257f464ae377e4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt.tools/Mac Generation/org/eclipse/swt/tools/internal/DOMWriter.java", "commitBeforeChange": "bede5411f9aa7de237c12e785a278e1cd528e317", "commitAfterChange": "c5a4f175f14b3b967abb14aa67050eb14ed80f82", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r\t\r\tpublic void print(Node node, int level)", "signatureAfterChange": "\r\t\r\tpublic void print(Node node, int level)", "diff": ["-/*******************************************************************************\r * Copyright (c) 2008 IBM Corporation and others.\r * All rights reserved. This program and the accompanying materials\r * are made available under the terms of the Eclipse Public License v1.0\r * which accompanies this distribution, and is available at\r * http://www.eclipse.org/legal/epl-v10.html\r *\r * Contributors:\r *     IBM Corporation - initial API and implementation\r *******************************************************************************/\rpackage org.eclipse.swt.tools.internal;\r\rimport java.io.PrintStream;\rimport java.util.Arrays;\rimport java.util.Comparator;\r\rimport org.w3c.dom.Attr;\rimport org.w3c.dom.Document;\rimport org.w3c.dom.NamedNodeMap;\rimport org.w3c.dom.Node;\rimport org.w3c.dom.NodeList;\r\rpublic class DOMWriter {\r\r\tstatic String ENCONDING = \"UTF8\";\r\tPrintStream out;\r\tboolean canonical, pretty = false;\r\tString[] attributeFilter;\r\r\tpublic DOMWriter(PrintStream out, boolean canonical) {\r\t\tthis.out = new PrintStream(out);\r\t\tthis.canonical = canonical;\r\t}\r\r\tString nodeName(Node node) {\r\t\t// TODO use getLocalName()?\r\t\treturn node.getNodeName();\r\t}\r\t\r\tboolean filter(Attr attr) {\r\t\tif (attributeFilter == null) return false;\r\t\tString name = attr.getNodeName();\r\t\tfor (int i = 0; i < attributeFilter.length; i++) {\r\t\t\tif (name.matches(attributeFilter[i])) return false;\r\t\t}\r\t\treturn true;\r\t}\r\t\r\tvoid print(String str) {\r\t\tout.print(str);\r\t}\r\tvoid println() {\r\t\tout.println();\r\t}\r\r\tpublic void print(Node node) {\r\t\tprint(node, 0);\r\t}\r\t\r\tpublic void print(Node node, int level) {\r\t\tif (node == null)\r\t\t\treturn;\r\t\tint type = node.getNodeType();\r\t\tswitch (type) {\r\t\t\tcase Node.DOCUMENT_NODE: {\r\t\t\t\tif (!canonical) {\r\t\t\t\t\tprint(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\r\t\t\t\t\tprint(ENCONDING);\r\t\t\t\t\tprint(\"\\\"?>\");\r\t\t\t\t\tprintln();\r\t\t\t\t}\r\t\t\t\tprint(((Document) node).getDocumentElement());\r\t\t\t\tout.flush();\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ELEMENT_NODE: {\r\t\t\t\tif (!canonical && pretty) {\r\t\t\t\t\tprintln();\r\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t}\r\t\t\t\tprint(\"<\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tAttr attrs[] = sort(node.getAttributes());\r\t\t\t\tfor (int i = 0; i < attrs.length; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tif (filter(attr)) continue;\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(nodeName(attr));\r\t\t\t\t\tprint(\"=\\\"\");\r\t\t\t\t\tprint(normalize(attr.getNodeValue()));\r\t\t\t\t\tprint(\"\\\"\");\r\t\t\t\t}\r\t\t\t\tprint(\">\");\r\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\tif (children != null) {\r\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t}\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ENTITY_REFERENCE_NODE: {\r\t\t\t\tif (canonical) {\r\t\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\t\tif (children != null) {\r\t\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t\t}\r\t\t\t\t\t}\r\t\t\t\t} else {\r\t\t\t\t\tprint(\"&\");\r\t\t\t\t\tprint(nodeName(node));\r\t\t\t\t\tprint(\";\");\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.CDATA_SECTION_NODE: {\r\t\t\t\tif (canonical) {\r\t\t\t\t\tprint(normalize(node.getNodeValue()));\r\t\t\t\t} else {\r\t\t\t\t\tprint(\"<![CDATA[\");\r\t\t\t\t\tprint(node.getNodeValue());\r\t\t\t\t\tprint(\"]]>\");\r\t\t\t\t}\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.TEXT_NODE: {\r\t\t\t\tprint(normalize(node.getNodeValue()));\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.PROCESSING_INSTRUCTION_NODE: {\r\t\t\t\tprint(\"<?\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tString data = node.getNodeValue();\r\t\t\t\tif (data != null && data.length() > 0) {\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(data);\r\t\t\t\t}\r\t\t\t\tprint(\"?>\");\r\t\t\t\tbreak;\r\t\t\t}\r\t\t}\r\t\tif (type == Node.ELEMENT_NODE) {\r\t\t\tif (!canonical && pretty) {\r\t\t\t\tif (node.getChildNodes().getLength() > 0) {\r\t\t\t\t\tprintln();\r\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t}\t\t\t\t\r\t\t\t}\r\t\t\tprint(\"</\");\r\t\t\tprint(nodeName(node));\r\t\t\tprint(\">\");\r\t\t}\r\t\tout.flush();\r\t}\r\r\tAttr[] sort(NamedNodeMap attrs) {\r\t\tif (attrs == null)\r\t\t\treturn new Attr[0];\r\t\tAttr result[] = new Attr[attrs.getLength()];\r\t\tfor (int i = 0; i < result.length; i++) {\r\t\t\tresult[i] = (Attr) attrs.item(i);\r\t\t}\r\t\tArrays.sort(result, new Comparator() {\r\t\t\tpublic int compare(Object arg0, Object arg1) {\r\t\t\t\treturn nodeName((Node) arg0).compareTo(nodeName((Node) arg1));\r\t\t\t}\r\t\t});\r\t\treturn result;\r\t}\r\r\tString normalize(String s) {\r\t\tif (s == null) return \"\";\r\t\tStringBuffer str = new StringBuffer();\r\t\tfor (int i = 0, length = s.length(); i < length; i++) {\r\t\t\tchar ch = s.charAt(i);\r\t\t\tswitch (ch) {\r\t\t\t\tcase '\"': str.append(\"\\\"\"); break;\r\t\t\t\tcase '\\r':\r\t\t\t\tcase '\\n':\r\t\t\t\t\tif (canonical) {\r\t\t\t\t\t\tstr.append(\"&#\");\r\t\t\t\t\t\tstr.append(Integer.toString(ch));\r\t\t\t\t\t\tstr.append(';');\r\t\t\t\t\t\tbreak;\r\t\t\t\t\t}\r\t\t\t\t\t// FALL THROUGH\r\t\t\t\tdefault: str.append(ch);\r\t\t\t}\r\t\t}\r\t\treturn str.toString();\r\t}\r\t\r\tpublic void setAttributeFilter(String[] filter) {\r\t\tattributeFilter = filter;\r\t}\r}", "\\ No newline at end of file", "+/*******************************************************************************\r * Copyright (c) 2008 IBM Corporation and others.\r * All rights reserved. This program and the accompanying materials\r * are made available under the terms of the Eclipse Public License v1.0\r * which accompanies this distribution, and is available at\r * http://www.eclipse.org/legal/epl-v10.html\r *\r * Contributors:\r *     IBM Corporation - initial API and implementation\r *******************************************************************************/\rpackage org.eclipse.swt.tools.internal;\r\rimport java.io.PrintStream;\rimport java.util.Arrays;\rimport java.util.Comparator;\r\rimport org.w3c.dom.Attr;\rimport org.w3c.dom.Document;\rimport org.w3c.dom.NamedNodeMap;\rimport org.w3c.dom.Node;\rimport org.w3c.dom.NodeList;\r\rpublic class DOMWriter {\r\r\tstatic String ENCONDING = \"UTF8\";\r\tPrintStream out;\r\tString[] attributeFilter;\r\tString nodeFilter;\r\r\tpublic DOMWriter(PrintStream out) {\r\t\tthis.out = new PrintStream(out);\r\t}\r\r\tString nodeName(Node node) {\r\t\t// TODO use getLocalName()?\r\t\treturn node.getNodeName();\r\t}\r\t\r\tboolean filter(Attr attr) {\r\t\tif (attributeFilter == null) return false;\r\t\tString name = attr.getNodeName();\r\t\tfor (int i = 0; i < attributeFilter.length; i++) {\r\t\t\tif (name.matches(attributeFilter[i])) return false;\r\t\t}\r\t\treturn true;\r\t}\r\t\r\tvoid print(String str) {\r\t\tout.print(str);\r\t}\r\tvoid println() {\r\t\tout.println();\r\t}\r\r\tpublic void print(Node node) {\r\t\tprint(node, 0);\r\t}\r\t\r\tpublic void print(Node node, int level) {\r\t\tif (node == null)\r\t\t\treturn;\r\t\tint type = node.getNodeType();\r\t\tswitch (type) {\r\t\t\tcase Node.DOCUMENT_NODE: {\r\t\t\t\tprint(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\r\t\t\t\tprint(ENCONDING);\r\t\t\t\tprint(\"\\\"?>\");\r\t\t\t\tprintln();\r\t\t\t\tprint(((Document) node).getDocumentElement());\r\t\t\t\tbreak;\r\t\t\t}\r\t\t\tcase Node.ELEMENT_NODE: {\r\t\t\t\tAttr attrs[] = sort(node.getAttributes());\r\t\t\t\tboolean gen = false;\r\t\t\t\tfor (int i = 0; i < attrs.length && !gen; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tif (nodeName(attr).startsWith(nodeFilter)) gen = true;\r\t\t\t\t}\r\t\t\t\tif (!gen) break;\r\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\tprint(\"<\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tfor (int i = 0; i < attrs.length; i++) {\r\t\t\t\t\tAttr attr = attrs[i];\r\t\t\t\t\tif (filter(attr)) continue;\r\t\t\t\t\tprint(\" \");\r\t\t\t\t\tprint(nodeName(attr));\r\t\t\t\t\tprint(\"=\\\"\");\r\t\t\t\t\tprint(normalize(attr.getNodeValue()));\r\t\t\t\t\tprint(\"\\\"\");\r\t\t\t\t}\r\t\t\t\tprint(\">\");\r\t\t\t\tNodeList children = node.getChildNodes();\r\t\t\t\tint count = 0;\r\t\t\t\tif (children != null) {\r\t\t\t\t\tint len = children.getLength();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tif (children.item(i).getNodeType() == Node.ELEMENT_NODE) count++;\r\t\t\t\t\t}\r\t\t\t\t\tif (count > 0) println();\r\t\t\t\t\tfor (int i = 0; i < len; i++) {\r\t\t\t\t\t\tprint(children.item(i), level + 1);\r\t\t\t\t\t}\r\t\t\t\t\tif (count > 0) {\r\t\t\t\t\t\tfor (int i = 0; i < level; i++) print(\"\\t\");\r\t\t\t\t\t}\r\t\t\t\t}\r\t\t\t\tprint(\"</\");\r\t\t\t\tprint(nodeName(node));\r\t\t\t\tprint(\">\");\r\t\t\t\tprintln();\r\t\t\t\tbreak;\r\t\t\t}\r\t\t}\r\t\tout.flush();\r\t}\r\r\tAttr[] sort(NamedNodeMap attrs) {\r\t\tif (attrs == null)\r\t\t\treturn new Attr[0];\r\t\tAttr result[] = new Attr[attrs.getLength()];\r\t\tfor (int i = 0; i < result.length; i++) {\r\t\t\tresult[i] = (Attr) attrs.item(i);\r\t\t}\r\t\tArrays.sort(result, new Comparator() {\r\t\t\tpublic int compare(Object arg0, Object arg1) {\r\t\t\t\treturn nodeName((Node) arg0).compareTo(nodeName((Node) arg1));\r\t\t\t}\r\t\t});\r\t\treturn result;\r\t}\r\r\tString normalize(String s) {\r\t\tif (s == null) return \"\";\r\t\tStringBuffer str = new StringBuffer();\r\t\tfor (int i = 0, length = s.length(); i < length; i++) {\r\t\t\tchar ch = s.charAt(i);\r\t\t\tswitch (ch) {\r\t\t\t\tcase '\"': str.append(\"\\\"\"); break;\r\t\t\t\tcase '\\r':\r\t\t\t\tcase '\\n':\r\t\t\t\t\t// FALL THROUGH\r\t\t\t\tdefault: str.append(ch);\r\t\t\t}\r\t\t}\r\t\treturn str.toString();\r\t}\r\t\r\tpublic void setNodeFilter(String filter) {\r\t\t\r\t\tnodeFilter = filter;\r\t}\r\t\r\tpublic void setAttributeFilter(String[] filter) {\r\t\tattributeFilter = filter;\r\t}\r}", "\\ No newline at end of file"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c562c1abe2875ce09c129e4fdb3e241a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Combo.java", "commitBeforeChange": "819094da718c6570c737d38a3e41a8a9970cd886", "commitAfterChange": "22e2cb42dd6bedfa7c3ae2b39a3d0b4bdbc30df8", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 40, "signatureBeforeChange": " public void remove (int start, int end)", "signatureAfterChange": "  void remove (int index, boolean notify)", "diff": ["+", "+void remove (int index, boolean notify) {", "+\tif (notify && length != OS.GetWindowTextLength (handle)) {"]}], "num": 59580}