{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2d901dd00111cb1d472e8366ecd7a476", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e6e9984f21fe06b27c58b3fa6dc5e767", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/Device.java", "commitBeforeChange": "d44e6ad71ddc6d2ea423047bbf915ead29e37349", "commitAfterChange": "b8354fd802ecc1bae30ac0f2ca28060addfc2768", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r protected void init ()", "signatureAfterChange": "\r protected void init ()", "diff": ["-\tinternal_dispose_GC (hDC, null);\r", "-\tif ((rc & OS.RC_PALETTE) == 0 || bits != 8) return;\r", "-\r", "-\t/*\r", "-\t * The following colors are listed in the Windows\r", "-\t * Programmer's Reference as the colors guaranteed\r", "-\t * to be in the default system palette.\r", "-\t */\r", "-\tRGB [] rgbs = new RGB [] {\r", "-\t\tnew RGB (0,0,0),\r", "-\t\tnew RGB (0x80,0,0),\r", "-\t\tnew RGB (0,0x80,0),\r", "-\t\tnew RGB (0x80,0x80,0),\r", "-\t\tnew RGB (0,0,0x80),\r", "-\t\tnew RGB (0x80,0,0x80),\r", "-\t\tnew RGB (0,0x80,0x80),\r", "-\t\tnew RGB (0xC0,0xC0,0xC0),\r", "-\t\tnew RGB (0x80,0x80,0x80),\r", "-\t\tnew RGB (0xFF,0,0),\r", "-\t\tnew RGB (0,0xFF,0),\r", "-\t\tnew RGB (0xFF,0xFF,0),\r", "-\t\tnew RGB (0,0,0xFF),\r", "-\t\tnew RGB (0xFF,0,0xFF),\r", "-\t\tnew RGB (0,0xFF,0xFF),\r", "-\t\tnew RGB (0xFF,0xFF,0xFF),\r", "-\t};\r", "+\tif ((rc & OS.RC_PALETTE) == 0 || bits != 8) {\r", "+\t\tinternal_dispose_GC (hDC, null);\r", "+\t\treturn;\r", "+\t}\r", "-\t/* 4 bytes header + 4 bytes per entry * 256 entries */\r", "-\tbyte [] logPalette = new byte [4 + 4 * 256];\r", "+\tint numReserved = OS.GetDeviceCaps (hDC, OS.NUMRESERVED);\r", "+\tint numEntries = OS.GetDeviceCaps (hDC, OS.SIZEPALETTE);\r", "+\r", "+\tif (OS.IsWinCE) {\r", "+\t\t/*\r", "+\t\t* Feature on WinCE.  For some reason, certain 8 bit WinCE\r", "+\t\t* devices return 0 for the number of reserved entries in\r", "+\t\t* the system palette.  Their system palette correctly contains\r", "+\t\t* the usual 20 system colors.  The workaround is to assume\r", "+\t\t* there are 20 reserved system colors instead of 0.\r\t\t*/\r", "+\t\tif (numReserved == 0 && numEntries >= 20) numReserved = 20;\r", "+\t}\r", "+\r", "+\t/* Create the palette and reference counter */\r", "+\tcolorRefCount = new int [numEntries];\r", "+\r", "+\t/* 4 bytes header + 4 bytes per entry * numEntries entries */\r", "+\tbyte [] logPalette = new byte [4 + 4 * numEntries];\r", "-\t\r", "-\t/* Create the palette and reference counter */\r", "-\tcolorRefCount = new int [256];\r", "-\tfor (int i = 0; i < rgbs.length; i++) {\r", "+\r", "+\t/* \r", "+\t* Create a palette which contains the system entries\r", "+\t* as they are located in the system palette.  The\r", "+\t* MSDN article 'Memory Device Contexts' describes\r", "+\t* where system entries are located.  On an 8 bit\r", "+\t* display with 20 reserved colors, the system colors\r", "+\t* will be the first 10 entries and the last 10 ones.\r", "+\t*/\r", "+\tbyte[] lppe = new byte [4 * numEntries];\r", "+\tOS.GetSystemPaletteEntries (hDC, 0, numEntries, lppe);\r", "+\t/* Copy all entries from the system palette */\r", "+\tSystem.arraycopy (lppe, 0, logPalette, 4, 4 * numEntries);\r", "+\t/* Lock the indices corresponding to the system entries */\r", "+\tfor (int i = 0; i < numReserved / 2; i++) {\r", "-\t\tint offset = i * 4 + 4;\r", "-\t\tlogPalette [offset] = (byte) rgbs[i].red;\r", "-\t\tlogPalette [offset + 1] = (byte) rgbs[i].green;\r", "-\t\tlogPalette [offset + 2] = (byte) rgbs[i].blue;\r", "+\t\tcolorRefCount [numEntries - 1 - i] = 1;\r", "+\tinternal_dispose_GC (hDC, null);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5bc3e74d5f7d8cf06b3e05aa3a8edaee", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/widgets/Menu.java", "commitBeforeChange": "e4692e5cbd7a1c3e2c445a2649b50a1fdba6d571", "commitAfterChange": "7c0714d2b96ea5373a8249de1d951780e6fa9ffd", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "\r public void setVisible (boolean visible)", "signatureAfterChange": "\r public void setVisible (boolean visible)", "diff": ["+\t\tint xDisplay = OS.XtDisplay (handle);\r", "+\t\tif (xDisplay == 0) return;\r", "+\t\tint xWindow = OS.XDefaultRootWindow (xDisplay);\r", "+\t\tif (xWindow == 0) return;\r", "+\t\tint [] rootX = new int [1], rootY = new int [1], unused = new int [1], mask = new int [1];\r", "+\t\tif (OS.XQueryPointer (xDisplay, xWindow, unused, unused, rootX, rootY, unused, unused, mask) == 0) {\r", "+\t\t\treturn;\r", "+\t\t}\r", "-\t\t\tint xDisplay = OS.XtDisplay (handle);\r", "-\t\t\tif (xDisplay == 0) return;\r", "-\t\t\tint xWindow = OS.XDefaultRootWindow (xDisplay);\r", "-\t\t\tif (xWindow == 0) return;\r", "-\t\t\tint [] unused = new int [1];\r", "-\t\t\tint [] rootX = new int [1], rootY = new int [1];\r", "-\t\t\tif (OS.XQueryPointer (\r", "-\t\t\t\txDisplay, xWindow, unused, unused,\r", "-\t\t\t\trootX, rootY,\r", "-\t\t\t\tunused, unused, unused) == 0) return;\r", "-\t\t\t\t\r", "-\t\t\t/* Bug in Motif: \r", "-\t\t\t * You *must* start outside the menu or it will not show you\r", "-\t\t\t * highlighting until you move the cursor out of and back into\r", "-\t\t\t * the menu. By offsetting the start location by a pixel, it\r", "-\t\t\t * causes highlighting to work if you wait for the menu to\r", "-\t\t\t * pop up before you start moving.(Except for the bottom\r", "-\t\t\t * right corner.)\r", "-\t\t\t */\r", "-\t\t\trootX[0] += 1;\r", "-\t\t\trootY[0] += 1;\r", "-\r", "+\t\t\t/*\r", "+\t\t\t* Bug in Motif.  For some reason, when a menu is popped up\r", "+\t\t\t* under the mouse, the menu will not highlight until the\r", "+\t\t\t* mouse exits and then enters the menu again.  The fix is\r", "+\t\t\t* to pop the menu up outside the current mouse position\r", "+\t\t\t* causing highlighting to work properly when the user\r", "+\t\t\t* waits for the menu to appear.\r", "+\t\t\t*/\r", "+\t\t\trootX[0] += 1;  rootY[0] += 1;\r", "+\t\t/*\r", "+\t\t* Feature in Motif.  There is no API to force the menu\r", "+\t\t* to accept keyboard traversal when popped up using\r", "+\t\t* XtManageChild.  The fix is to call undocumented API\r", "+\t\t* to do this.\r", "+\t\t*/\r", "+\t\tint flags = OS.Button1Mask | OS.Button2Mask | OS.Button3Mask;\r", "+\t\tif ((mask [0] & flags) == 0) OS._XmSetMenuTraversal (handle, true);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cabf384b0d98f562f68ed3592a685ebd", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/widgets/Menu.java", "commitBeforeChange": "e7472be62a35d340ded1ff8e0de89ae6506d1723", "commitAfterChange": "c65bd10509fc4e3f55dcb1376fcd8c5e65786199", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "\r public void setVisible (boolean visible)", "signatureAfterChange": "\r public void setVisible (boolean visible)", "diff": ["-\t\tint xDisplay = OS.XtDisplay (handle);\r", "-\t\tif (xDisplay == 0) return;\r", "-\t\tint xWindow = OS.XDefaultRootWindow (xDisplay);\r", "-\t\tif (xWindow == 0) return;\r", "-\t\tint [] rootX = new int [1], rootY = new int [1], unused = new int [1], mask = new int [1];\r", "-\t\tif (OS.XQueryPointer (xDisplay, xWindow, unused, unused, rootX, rootY, unused, unused, mask) == 0) {\r", "-\t\t\treturn;\r", "-\t\t}\r", "-\t\tif (!hasLocation) {\r", "+\t\tsendEvent (SWT.Show);\r", "+\t\tif (getItemCount () != 0) {\r", "+\t\t\tint xDisplay = OS.XtDisplay (handle);\r", "+\t\t\tif (xDisplay == 0) return;\r", "+\t\t\tint xWindow = OS.XDefaultRootWindow (xDisplay);\r", "+\t\t\tif (xWindow == 0) return;\r", "+\t\t\tint [] rootX = new int [1], rootY = new int [1], unused = new int [1], mask = new int [1];\r", "+\t\t\tif (OS.XQueryPointer (xDisplay, xWindow, unused, unused, rootX, rootY, unused, unused, mask) == 0) {\r", "+\t\t\t\treturn;\r", "+\t\t\t}\r", "+\t\t\tif (!hasLocation) {\r", "+\t\t\t\t/*\r", "+\t\t\t\t* Bug in Motif.  For some reason, when a menu is popped up\r", "+\t\t\t\t* under the mouse, the menu will not highlight until the\r", "+\t\t\t\t* mouse exits and then enters the menu again.  The fix is\r", "+\t\t\t\t* to pop the menu up outside the current mouse position\r", "+\t\t\t\t* causing highlighting to work properly when the user\r", "+\t\t\t\t* waits for the menu to appear.\r", "+\t\t\t\t*/\r", "+\t\t\t\trootX[0] += 1;  rootY[0] += 1;\r", "+\t\t\t\tint [] argList = {OS.XmNx, rootX [0], OS.XmNy, rootY [0]};\r", "+\t\t\t\tOS.XtSetValues (handle, argList, argList.length / 2);\r", "+\t\t\t}\r", "+\t\t\tOS.XtManageChild (handle);\r", "-\t\t\t* Bug in Motif.  For some reason, when a menu is popped up\r", "-\t\t\t* under the mouse, the menu will not highlight until the\r", "-\t\t\t* mouse exits and then enters the menu again.  The fix is\r", "-\t\t\t* to pop the menu up outside the current mouse position\r", "-\t\t\t* causing highlighting to work properly when the user\r", "-\t\t\t* waits for the menu to appear.\r", "+\t\t\t* Feature in Motif.  There is no API to force the menu\r", "+\t\t\t* to accept keyboard traversal when popped up using\r", "+\t\t\t* XtManageChild.  The fix is to call undocumented API\r", "+\t\t\t* to do this.\r", "-\t\t\trootX[0] += 1;  rootY[0] += 1;\r", "-\t\t\tint [] argList = {OS.XmNx, rootX [0], OS.XmNy, rootY [0]};\r", "-\t\t\tOS.XtSetValues (handle, argList, argList.length / 2);\r", "+\t\t\tint flags = OS.Button1Mask | OS.Button2Mask | OS.Button3Mask;\r", "+\t\t\tif ((mask [0] & flags) == 0) OS._XmSetMenuTraversal (handle, true);\r", "+\t\t} else {\r", "+\t\t\tsendEvent (SWT.Hide);\r", "-\t\tOS.XtManageChild (handle);\r", "-\t\t/*\r", "-\t\t* Feature in Motif.  There is no API to force the menu\r", "-\t\t* to accept keyboard traversal when popped up using\r", "-\t\t* XtManageChild.  The fix is to call undocumented API\r", "-\t\t* to do this.\r", "-\t\t*/\r", "-\t\tint flags = OS.Button1Mask | OS.Button2Mask | OS.Button3Mask;\r", "-\t\tif ((mask [0] & flags) == 0) OS._XmSetMenuTraversal (handle, true);\r"]}], "num": 21480}