{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a28ea8debb1ca5fa2a7553530e455129", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "69def7217c88ca03595cba79c631f479", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "28611873c812080da03092456ee7cc4c93ef80a3", "commitAfterChange": "e657e76e5131e900496ccd41899277450879646c", "methodNumberBeforeChange": 180, "methodNumberAfterChange": 180, "signatureBeforeChange": "  LRESULT WM_KEYDOWN (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_KEYDOWN (int wParam, int lParam)", "diff": ["-\t", "-\t/* Ignore repeating modifier keys by testing key down state */", "-\tswitch (wParam) {", "-\t\tcase OS.VK_SHIFT:", "-\t\tcase OS.VK_MENU:", "-\t\tcase OS.VK_CONTROL:", "-\t\tcase OS.VK_CAPITAL:", "-\t\tcase OS.VK_NUMLOCK:", "-\t\tcase OS.VK_SCROLL:", "-\t\t\tif ((lParam & 0x40000000) != 0) return null;", "-\t}", "-\t", "-\t/* Clear last key and last ascii because a new key has been typed */", "-\tdisplay.lastAscii = display.lastKey = 0;", "-\tdisplay.lastVirtual = display.lastNull = display.lastDead = false;", "-\t", "-\t/*", "-\t* Do not report a lead byte as a key pressed.", "-\t*/", "-\tif (!OS.IsUnicode && OS.IsDBLocale) {", "-\t\tbyte lead = (byte) (wParam & 0xFF);", "-\t\tif (OS.IsDBCSLeadByte (lead)) return null;", "-\t}", "-\t", "-\t/* Map the virtual key */", "-\t/*", "-\t* Bug in WinCE.  MapVirtualKey() returns incorrect values.", "-\t* The fix is to rely on a key mappings table to determine", "-\t* whether the key event must be sent now or if a WM_CHAR", "-\t* event will follow.  The key mappings table maps virtual", "-\t* keys to SWT key codes and does not contain mappings for", "-\t* Windows virtual keys like VK_A.  Virtual keys that are", "-\t* both virtual and ASCII are a special case.", "-\t*/", "-\tint mapKey = 0;", "-\tif (OS.IsWinCE) {", "-\t\tswitch (wParam) {", "-\t\t\tcase OS.VK_BACK: mapKey = SWT.BS; break;", "-\t\t\tcase OS.VK_RETURN: mapKey = SWT.CR; break;", "-\t\t\tcase OS.VK_DELETE: mapKey = SWT.DEL; break;", "-\t\t\tcase OS.VK_ESCAPE: mapKey = SWT.ESC; break;", "-\t\t\tcase OS.VK_TAB: mapKey = SWT.TAB; break;", "-\t\t}", "-\t} else {", "-\t\tmapKey = OS.MapVirtualKey (wParam, 2);", "-\t}", "-", "-\t/*", "-\t* Bug in Windows 95 and NT.  When the user types an accent key such", "-\t* as ^ to get an accented character on a German keyboard, the accent", "-\t* key should be ignored and the next key that the user types is the", "-\t* accented key.  The fix is to detect the accent key stroke (called", "-\t* a dead key) by testing the high bit of the value returned by", "-\t* MapVirtualKey().  A further problem is that the high bit on", "-\t* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.", "-\t* They should both be bit 32.", "-\t*", "-\t* When the user types an accent key that does not correspond to a", "-\t* virtual key, MapVirtualKey() won't set the high bit to indicate", "-\t* a dead key.  This happens when an accent key, such as '^' is the", "-\t* result of a modifier such as Shift key and MapVirtualKey() always", "-\t* returns the unshifted key.  The fix is to peek for a WM_DEADCHAR", "-\t* and avoid issuing the event. ", "-\t*/", "-\tif (OS.IsWinNT) {", "-\t\tif ((mapKey & 0x80000000) != 0) return null;", "-\t} else {", "-\t\tif ((mapKey & 0x8000) != 0) return null;", "-\t}", "-\tMSG msg = new MSG ();", "-\tint flags = OS.PM_NOREMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;", "-\tif (OS.PeekMessage (msg, handle, OS.WM_DEADCHAR, OS.WM_DEADCHAR, flags)) {", "-\t\tdisplay.lastDead = true;", "-\t\tdisplay.lastVirtual = mapKey == 0;", "-\t\tdisplay.lastKey = display.lastVirtual ? wParam : mapKey;", "-\t\treturn null;", "-\t}", "-\t", "-\t/*", "-\t* If we are going to get a WM_CHAR, ensure that last key has", "-\t* the correct character value for the key down and key up", "-\t* events.  It is not sufficient to ignore the WM_KEYDOWN", "-\t* (when we know we are going to get a WM_CHAR) and compute", "-\t* the key in WM_CHAR because there is not enough information", "-\t* by the time we get the WM_CHAR.  For example, when the user", "-\t* types Ctrl+Shift+6 on a US keyboard, we get a WM_CHAR with ", "-\t* wParam=30.  When the user types Ctrl+Shift+6 on a German ", "-\t* keyboard, we also get a WM_CHAR with wParam=30.  On the US", "-\t* keyboard Shift+6 is ^, on the German keyboard Shift+6 is &.", "-\t* There is no way to map wParam=30 in WM_CHAR to the correct", "-\t* value.  Also, on international keyboards, the control key", "-\t* may be down when the user has not entered a control character.", "-\t* ", "-\t* NOTE: On Windows 98, keypad keys are virtual despite the", "-\t* fact that a WM_CHAR is issued.  On Windows 2000 and XP,", "-\t* they are not virtual.  Therefore it is necessary to force", "-\t* numeric keypad keys to be virtual.", "-\t*/", "-\tdisplay.lastVirtual = mapKey == 0 || display.numpadKey (wParam) != 0;", "-\tif (display.lastVirtual) {", "-\t\tdisplay.lastKey = wParam;", "-\t\t/*", "-\t\t* Feature in Windows.  The virtual key VK_DELETE is not", "-\t\t* treated as both a virtual key and an ASCII key by Windows.", "-\t\t* Therefore, we will not receive a WM_CHAR for this key.", "-\t\t* The fix is to treat VK_DELETE as a special case and map", "-\t\t* the ASCII value explictly (Delete is 0x7F).", "-\t\t*/", "-\t\tif (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;", "-", "-\t\t/*", "-\t\t* It is possible to get a WM_CHAR for a virtual key when", "-\t\t* Num Lock is on.  If the user types Home while Num Lock ", "-\t\t* is down, a WM_CHAR is issued with WPARM=55 (for the", "-\t\t* character 7).  If we are going to get a WM_CHAR we need", "-\t\t* to ensure that the last key has the correct value.  Note", "-\t\t* that Ctrl+Home does not issue a WM_CHAR when Num Lock is", "-\t\t* down.", "-\t\t*/", "-\t\tif (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {", "-\t\t\t/*", "-\t\t\t* Feature in Windows.  Calling to ToAscii() or ToUnicode(), clears", "-\t\t\t* the accented state such that the next WM_CHAR loses the accent.", "-\t\t\t* This makes is critical that the accent key is detected.  Also,", "-\t\t\t* these functions clear the character that is entered using the", "-\t\t\t* special Windows keypad sequence when NumLock is down (ie. typing ", "-\t\t\t* ALT+0231 should gives 'c' with a cedilla when NumLock is down).", "-\t\t\t*/", "-\t\t\tif (display.asciiKey (display.lastKey) != 0) return null;", "-\t\t\tdisplay.lastAscii = display.numpadKey (display.lastKey);", "-\t\t}", "-\t} else {", "-\t\t/*", "-\t\t* Convert LastKey to lower case because Windows non-virtual", "-\t\t* keys that are also ASCII keys, such as like VK_A, are have", "-\t\t* upper case values in WM_KEYDOWN despite the fact that the ", "-\t\t* Shift was not pressed.", "-\t\t*/", "-\t \tdisplay.lastKey = OS.CharLower ((short) mapKey);", "-", "-\t\t/*", "-\t\t* Feature in Windows. The virtual key VK_CANCEL is treated", "-\t\t* as both a virtual key and ASCII key by Windows.  This", "-\t\t* means that a WM_CHAR with WPARAM=3 will be issued for", "-\t\t* this key.  In order to distinguish between this key and", "-\t\t* Ctrl+C, mark the key as virtual.", "-\t\t*/", "-\t\tif (wParam == OS.VK_CANCEL) display.lastVirtual = true;", "-\t\t", "-\t\t/*", "-\t\t* Some key combinations map to Windows ASCII keys depending", "-\t\t* on the keyboard.  For example, Ctrl+Alt+Q maps to @ on a", "-\t\t* German keyboard.  If the current key combination is special,", "-\t\t* the correct character is placed in wParam for processing in", "-\t\t* WM_CHAR.  If this is the case, issue the key down event from", "-\t\t* inside WM_CHAR.", "-\t\t*/", "-\t\tint asciiKey = display.asciiKey (wParam);", "-\t\tif (asciiKey != 0) {", "-\t\t\t/*", "-\t\t\t* When the user types Ctrl+Space, ToAscii () maps this to", "-\t\t\t* Space.  Normally, ToAscii () maps a key to a different", "-\t\t\t* key if both a WM_KEYDOWN and a WM_CHAR will be issued.", "-\t\t\t* To avoid the extra SWT.KeyDown, look for a space and", "-\t\t\t* issue the event from WM_CHAR.", "-\t\t\t*/", "-\t\t\tif (asciiKey == ' ') return null;", "-\t\t\tif (asciiKey != wParam) return null;", "-\t\t\t/*", "-\t\t\t* Feature in Windows. The virtual key VK_CANCEL is treated", "-\t\t\t* as both a virtual key and ASCII key by Windows.  This", "-\t\t\t* means that a WM_CHAR with WPARAM=3 will be issued for", "-\t\t\t* this key. To avoid the extra SWT.KeyDown, look for", "-\t\t\t* VK_CANCEL and issue the event from WM_CHAR.", "-\t\t\t*/", "-\t\t\tif (wParam == OS.VK_CANCEL) return null;", "-\t\t}", "-\t\t", "-\t\t/*", "-\t\t* If the control key is not down at this point, then", "-\t\t* the key that was pressed was an accent key or a regular", "-\t\t* key such as 'A' or Shift+A.  In that case, issue the", "-\t\t* key event from WM_CHAR.", "-\t\t*/", "-\t\tif (OS.GetKeyState (OS.VK_CONTROL) >= 0) return null;", "-\t\t", "-\t\t/*", "-\t\t* Get the shifted state or convert to lower case if necessary.", "-\t\t* If the user types Ctrl+A, LastAscii should be 'a', not 'A'. ", "-\t\t* If the user types Ctrl+Shift+A, LastAscii should be 'A'.", "-\t\t* If the user types Ctrl+Shift+6, the value of LastAscii will", "-\t\t* depend on the international keyboard.", "-\t\t*/", "-\t \tif (OS.GetKeyState (OS.VK_SHIFT) < 0) {", "-\t\t\tdisplay.lastAscii = display.shiftedKey (wParam);", "-\t\t\tif (display.lastAscii == 0) display.lastAscii = mapKey;", "-\t \t} else {", "-\t \t\tdisplay.lastAscii = OS.CharLower ((short) mapKey);", "-\t \t}", "-\t \t\t\t", "-\t\t/* Note that Ctrl+'@' is ASCII NUL and is delivered in WM_CHAR */", "-\t\tif (display.lastAscii == '@') return null;", "-\t\tdisplay.lastAscii = display.controlKey (display.lastAscii);", "-\t}", "-\tif (!sendKeyEvent (SWT.KeyDown, OS.WM_KEYDOWN, wParam, lParam)) {", "-\t\treturn LRESULT.ONE;", "-\t}", "-\t// widget could be disposed at this point", "-\treturn null;", "+\treturn wmKeyDown (handle, wParam, lParam);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ebc412226e0556c3b75453fe80ab2e82", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Composite.java", "commitBeforeChange": "475fd80af7f44f11c184ce4e415e7e668e7066c7", "commitAfterChange": "a82cf9526e3bd01c73cdc5c3786a7972e25aa4c4", "methodNumberBeforeChange": 58, "methodNumberAfterChange": 66, "signatureBeforeChange": "  LRESULT WM_NOTIFY (int wParam, int lParam)", "signatureAfterChange": "  LRESULT wmNotify (NMHDR hdr, int wParam, int lParam)", "diff": ["-LRESULT WM_NOTIFY (int wParam, int lParam) {", "-\tif (!OS.IsWinCE) {", "-\t\tNMHDR hdr = new NMHDR ();", "-\t\tOS.MoveMemory (hdr, lParam, NMHDR.sizeof);", "-\t\tswitch (hdr.code) {", "-\t\t\t/*", "-\t\t\t* Feature in Windows.  When the tool tip control is", "-\t\t\t* created, the parent of the tool tip is the shell.", "-\t\t\t* If SetParent () is used to reparent the tool bar", "-\t\t\t* into a new shell, the tool tip is not reparented", "-\t\t\t* and pops up underneath the new shell.  The fix is", "-\t\t\t* to make sure the tool tip is a topmost window.", "-\t\t\t*/", "-\t\t\tcase OS.TTN_SHOW:", "-\t\t\tcase OS.TTN_POP: {", "-\t\t\t\t/*", "-\t\t\t\t* Bug in Windows 98 and NT.  Setting the tool tip to be the", "-\t\t\t\t* top most window using HWND_TOPMOST can result in a parent", "-\t\t\t\t* dialog shell being moved behind its parent if the dialog", "-\t\t\t\t* has a sibling that is currently on top.  The fix is to", "-\t\t\t\t* lock the z-order of the active window.", "-\t\t\t\t* ", "-\t\t\t\t* Feature in Windows.  Using SetWindowPos() with HWND_NOTOPMOST", "-\t\t\t\t* to clear the topmost state of a window whose parent is already", "-\t\t\t\t* topmost clears the topmost state of the parent.  The fix is to", "-\t\t\t\t* check if the parent is already on top and neither set or clear", "-\t\t\t\t* the topmost status of the tool tip.", "-\t\t\t\t*/", "-\t\t\t\tint hwndParent = hdr.hwndFrom;", "-\t\t\t\tdo {", "-\t\t\t\t\thwndParent = OS.GetParent (hwndParent);", "-\t\t\t\t\tif (hwndParent == 0) break;", "-\t\t\t\t\tint bits = OS.GetWindowLong (hwndParent, OS.GWL_EXSTYLE);", "-\t\t\t\t\tif ((bits & OS.WS_EX_TOPMOST) != 0) break;", "-\t\t\t\t} while (true);", "-\t\t\t\tif (hwndParent != 0) break;", "-\t\t\t\tdisplay.lockActiveWindow = true;", "-\t\t\t\tint flags = OS.SWP_NOACTIVATE | OS.SWP_NOMOVE | OS.SWP_NOSIZE;", "-\t\t\t\tint hwndInsertAfter = hdr.code == OS.TTN_SHOW ? OS.HWND_TOPMOST : OS.HWND_NOTOPMOST;", "-\t\t\t\tSetWindowPos (hdr.hwndFrom, hwndInsertAfter, 0, 0, 0, 0, flags);", "-\t\t\t\tdisplay.lockActiveWindow = false;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\t/*", "-\t\t\t* Bug in Windows 98.  For some reason, the tool bar control", "-\t\t\t* sends both TTN_GETDISPINFOW and TTN_GETDISPINFOA to get", "-\t\t\t* the tool tip text and the tab folder control sends only ", "-\t\t\t* TTN_GETDISPINFOW.  The fix is to handle only TTN_GETDISPINFOW,", "-\t\t\t* even though it should never be sent on Windows 98.", "-\t\t\t*", "-\t\t\t* NOTE:  Because the size of NMTTDISPINFO differs between", "-\t\t\t* Windows 98 and NT, guard against the case where the wrong", "-\t\t\t* kind of message occurs by inlining the memory moves and", "-\t\t\t* the UNICODE conversion code.", "-\t\t\t*/", "-\t\t\tcase OS.TTN_GETDISPINFOA:", "-\t\t\tcase OS.TTN_GETDISPINFOW: {", "-\t\t\t\tNMTTDISPINFO lpnmtdi;", "-\t\t\t\tif (hdr.code == OS.TTN_GETDISPINFOA) {", "-\t\t\t\t\tlpnmtdi = new NMTTDISPINFOA ();", "-\t\t\t\t\tOS.MoveMemory ((NMTTDISPINFOA)lpnmtdi, lParam, NMTTDISPINFOA.sizeof);", "-\t\t\t\t} else {", "-\t\t\t\t\tlpnmtdi = new NMTTDISPINFOW ();", "-\t\t\t\t\tOS.MoveMemory ((NMTTDISPINFOW)lpnmtdi, lParam, NMTTDISPINFOW.sizeof);", "-\t\t\t\t}", "-\t\t\t\tString string = toolTipText (lpnmtdi);", "-\t\t\t\tif (string != null) {", "-\t\t\t\t\tShell shell = getShell ();", "-\t\t\t\t\tstring = Display.withCrLf (string);", "-\t\t\t\t\tint length = string.length ();", "-\t\t\t\t\tchar [] chars = new char [length + 1];", "-\t\t\t\t\tstring.getChars (0, length, chars, 0);", "-\t\t\t\t\t", "-\t\t\t\t\t/*", "-\t\t\t\t\t* Ensure that the orientation of the tool tip matches", "-\t\t\t\t\t* the orientation of the control.", "-\t\t\t\t\t*/", "-\t\t\t\t\tint hwnd = hdr.idFrom;", "-\t\t\t\t\tif (hwnd != 0 && ((lpnmtdi.uFlags & OS.TTF_IDISHWND) != 0)) {", "-\t\t\t\t\t\tControl control = display.getControl (hwnd);", "-\t\t\t\t\t\tif (control != null) {", "-\t\t\t\t\t\t\tif ((control.getStyle () & SWT.RIGHT_TO_LEFT) != 0) {", "-\t\t\t\t\t\t\t\tlpnmtdi.uFlags |= OS.TTF_RTLREADING;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tlpnmtdi.uFlags &= ~OS.TTF_RTLREADING;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\tif (hdr.code == OS.TTN_GETDISPINFOA) {", "-\t\t\t\t\t\tbyte [] bytes = new byte [chars.length * 2];", "-\t\t\t\t\t\tOS.WideCharToMultiByte (getCodePage (), 0, chars, chars.length, bytes, bytes.length, null, null);", "-\t\t\t\t\t\tshell.setToolTipText (lpnmtdi, bytes);", "-\t\t\t\t\t\tOS.MoveMemory (lParam, (NMTTDISPINFOA)lpnmtdi, NMTTDISPINFOA.sizeof);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tshell.setToolTipText (lpnmtdi, chars);", "-\t\t\t\t\t\tOS.MoveMemory (lParam, (NMTTDISPINFOW)lpnmtdi, NMTTDISPINFOW.sizeof);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn LRESULT.ZERO;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t}", "-\treturn super.WM_NOTIFY (wParam, lParam);", "-}", "+LRESULT wmNotify (NMHDR hdr, int wParam, int lParam) {", "+\tif (!OS.IsWinCE) {", "+\t\tswitch (hdr.code) {", "+\t\t\t/*", "+\t\t\t* Feature in Windows.  When the tool tip control is", "+\t\t\t* created, the parent of the tool tip is the shell.", "+\t\t\t* If SetParent () is used to reparent the tool bar", "+\t\t\t* into a new shell, the tool tip is not reparented", "+\t\t\t* and pops up underneath the new shell.  The fix is", "+\t\t\t* to make sure the tool tip is a topmost window.", "+\t\t\t*/", "+\t\t\tcase OS.TTN_SHOW:", "+\t\t\tcase OS.TTN_POP: {", "+\t\t\t\t/*", "+\t\t\t\t* Bug in Windows 98 and NT.  Setting the tool tip to be the", "+\t\t\t\t* top most window using HWND_TOPMOST can result in a parent", "+\t\t\t\t* dialog shell being moved behind its parent if the dialog", "+\t\t\t\t* has a sibling that is currently on top.  The fix is to", "+\t\t\t\t* lock the z-order of the active window.", "+\t\t\t\t* ", "+\t\t\t\t* Feature in Windows.  Using SetWindowPos() with HWND_NOTOPMOST", "+\t\t\t\t* to clear the topmost state of a window whose parent is already", "+\t\t\t\t* topmost clears the topmost state of the parent.  The fix is to", "+\t\t\t\t* check if the parent is already on top and neither set or clear", "+\t\t\t\t* the topmost status of the tool tip.", "+\t\t\t\t*/", "+\t\t\t\tint hwndParent = hdr.hwndFrom;", "+\t\t\t\tdo {", "+\t\t\t\t\thwndParent = OS.GetParent (hwndParent);", "+\t\t\t\t\tif (hwndParent == 0) break;", "+\t\t\t\t\tint bits = OS.GetWindowLong (hwndParent, OS.GWL_EXSTYLE);", "+\t\t\t\t\tif ((bits & OS.WS_EX_TOPMOST) != 0) break;", "+\t\t\t\t} while (true);", "+\t\t\t\tif (hwndParent != 0) break;", "+\t\t\t\tdisplay.lockActiveWindow = true;", "+\t\t\t\tint flags = OS.SWP_NOACTIVATE | OS.SWP_NOMOVE | OS.SWP_NOSIZE;", "+\t\t\t\tint hwndInsertAfter = hdr.code == OS.TTN_SHOW ? OS.HWND_TOPMOST : OS.HWND_NOTOPMOST;", "+\t\t\t\tSetWindowPos (hdr.hwndFrom, hwndInsertAfter, 0, 0, 0, 0, flags);", "+\t\t\t\tdisplay.lockActiveWindow = false;", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\t/*", "+\t\t\t* Bug in Windows 98.  For some reason, the tool bar control", "+\t\t\t* sends both TTN_GETDISPINFOW and TTN_GETDISPINFOA to get", "+\t\t\t* the tool tip text and the tab folder control sends only ", "+\t\t\t* TTN_GETDISPINFOW.  The fix is to handle only TTN_GETDISPINFOW,", "+\t\t\t* even though it should never be sent on Windows 98.", "+\t\t\t*", "+\t\t\t* NOTE:  Because the size of NMTTDISPINFO differs between", "+\t\t\t* Windows 98 and NT, guard against the case where the wrong", "+\t\t\t* kind of message occurs by inlining the memory moves and", "+\t\t\t* the UNICODE conversion code.", "+\t\t\t*/", "+\t\t\tcase OS.TTN_GETDISPINFOA:", "+\t\t\tcase OS.TTN_GETDISPINFOW: {", "+\t\t\t\tNMTTDISPINFO lpnmtdi;", "+\t\t\t\tif (hdr.code == OS.TTN_GETDISPINFOA) {", "+\t\t\t\t\tlpnmtdi = new NMTTDISPINFOA ();", "+\t\t\t\t\tOS.MoveMemory ((NMTTDISPINFOA)lpnmtdi, lParam, NMTTDISPINFOA.sizeof);", "+\t\t\t\t} else {", "+\t\t\t\t\tlpnmtdi = new NMTTDISPINFOW ();", "+\t\t\t\t\tOS.MoveMemory ((NMTTDISPINFOW)lpnmtdi, lParam, NMTTDISPINFOW.sizeof);", "+\t\t\t\t}", "+\t\t\t\tString string = toolTipText (lpnmtdi);", "+\t\t\t\tif (string != null) {", "+\t\t\t\t\tShell shell = getShell ();", "+\t\t\t\t\tstring = Display.withCrLf (string);", "+\t\t\t\t\tint length = string.length ();", "+\t\t\t\t\tchar [] chars = new char [length + 1];", "+\t\t\t\t\tstring.getChars (0, length, chars, 0);", "+\t\t\t\t\t", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Ensure that the orientation of the tool tip matches", "+\t\t\t\t\t* the orientation of the control.", "+\t\t\t\t\t*/", "+\t\t\t\t\tint hwnd = hdr.idFrom;", "+\t\t\t\t\tif (hwnd != 0 && ((lpnmtdi.uFlags & OS.TTF_IDISHWND) != 0)) {", "+\t\t\t\t\t\tControl control = display.getControl (hwnd);", "+\t\t\t\t\t\tif (control != null) {", "+\t\t\t\t\t\t\tif ((control.getStyle () & SWT.RIGHT_TO_LEFT) != 0) {", "+\t\t\t\t\t\t\t\tlpnmtdi.uFlags |= OS.TTF_RTLREADING;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tlpnmtdi.uFlags &= ~OS.TTF_RTLREADING;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\tif (hdr.code == OS.TTN_GETDISPINFOA) {", "+\t\t\t\t\t\tbyte [] bytes = new byte [chars.length * 2];", "+\t\t\t\t\t\tOS.WideCharToMultiByte (getCodePage (), 0, chars, chars.length, bytes, bytes.length, null, null);", "+\t\t\t\t\t\tshell.setToolTipText (lpnmtdi, bytes);", "+\t\t\t\t\t\tOS.MoveMemory (lParam, (NMTTDISPINFOA)lpnmtdi, NMTTDISPINFOA.sizeof);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tshell.setToolTipText (lpnmtdi, chars);", "+\t\t\t\t\t\tOS.MoveMemory (lParam, (NMTTDISPINFOW)lpnmtdi, NMTTDISPINFOW.sizeof);", "+\t\t\t\t\t}", "+\t\t\t\t\treturn LRESULT.ZERO;", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn super.wmNotify (hdr, wParam, lParam);", "+}"]}], "num": 17064}