{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "acd71e7ef0de663022d7ff9035e7d45d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3bacaa7ad874c8a4ebb2afe0a0f1b04b", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "d063aea08192e0213a4b6532b27dc31f9dce6e1b", "commitAfterChange": "48ef0056097e65cbe2f990bf125c93e76b95da33", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 16, "signatureBeforeChange": " void init(Device device, ImageData image)", "signatureAfterChange": "  void init(Device device, ImageData image)", "diff": ["-}", "-void init(Device device, ImageData image) {", "-\tif (device == null) device = Device.getDevice();", "-\tif (device == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);", "-\tthis.device = device;", "-\tif (image == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);", "-", "-\tint pixmap= createPixMap(image.width, image.height, image.depth);", "-", "-\tint[] transPixel= null;", "-\tif (image.transparentPixel != -1) transPixel= new int[]{ image.transparentPixel };", "-\t", "-\tint error= putImage(image, transPixel, pixmap);", "-\tif (error != 0) {", "-\t\tdisposeBitmapOrPixmap(pixmap);", "-\t\tSWT.error(error);", "-\tif (image.getTransparencyType() == SWT.TRANSPARENCY_MASK || image.transparentPixel != -1) {", "-\t\tif (image.transparentPixel != -1) transparentPixel = transPixel[0];", "-\t\tint mask= createMaskImage(image.getTransparencyMask());", "-\t\tif (mask == 0) {", "-\t\t\tdisposeBitmapOrPixmap(pixmap);", "-\t\t\tSWT.error(error);", "+", "+void init(Device device, ImageData image) {", "+\tif (image == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);", "+\tthis.device = device;", "+\tint width = image.width;", "+\tint height = image.height;", "+\t", "+\t/* Create the image */", "+\tint dataSize = width * height * 4;", "+\tdata = OS.NewPtr(dataSize);", "+\tif (data == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\tint provider = OS.CGDataProviderCreateWithData(0, data, dataSize, 0);", "+\tif (provider == 0) {", "+\t\tOS.DisposePtr(data);", "+\t\tSWT.error(SWT.ERROR_NO_HANDLES);", "+\t}", "+\tint colorspace = device.colorspace;", "+\tint transparency = image.getTransparencyType(); ", "+\tint alphaInfo = transparency == SWT.TRANSPARENCY_NONE ? OS.kCGImageAlphaNoneSkipFirst : OS.kCGImageAlphaFirst;", "+\thandle = OS.CGImageCreate(width, height, 8, 32, width * 4, colorspace, alphaInfo, provider, null, false, 0);", "+\tOS.CGDataProviderRelease(provider);", "+\tif (handle == 0) {", "+\t\tOS.DisposePtr(data);", "+\t\tSWT.error(SWT.ERROR_NO_HANDLES);", "+\t}", "+\t", "+\t/* Initialize data */", "+\tint bpr = width * 4;", "+\tPaletteData palette = image.palette;", "+\tPaletteData newPalette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "+\tbyte[] buffer = new byte[dataSize];", "+\tif (palette.isDirect) {", "+\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\timage.data, image.depth, image.bytesPerLine, image.getByteOrder(), 0, 0, width, height, palette.redMask, palette.greenMask, palette.blueMask,", "+\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0, ", "+\t\t\tbuffer, 32, bpr, ImageData.MSB_FIRST, 0, 0, width, height, 0xFF0000, 0xFF00, 0xFF,", "+\t\t\tfalse, false);", "+\t} else {", "+\t\tRGB[] rgbs = palette.getRGBs();", "+\t\tint length = rgbs.length;", "+\t\tbyte[] srcReds = new byte[length];", "+\t\tbyte[] srcGreens = new byte[length];", "+\t\tbyte[] srcBlues = new byte[length];", "+\t\tfor (int i = 0; i < rgbs.length; i++) {", "+\t\t\tRGB rgb = rgbs[i];", "+\t\t\tif (rgb == null) continue;", "+\t\t\tsrcReds[i] = (byte)rgb.red;", "+\t\t\tsrcGreens[i] = (byte)rgb.green;", "+\t\t\tsrcBlues[i] = (byte)rgb.blue;", "-\t\tthis.mask = mask;", "-\t\tif (image.getTransparencyType() == SWT.TRANSPARENCY_MASK) {", "-\t\t\tthis.type = SWT.ICON;", "-\t\t} else {", "-\t\t\tthis.type = SWT.BITMAP;", "+\t\tImageData.blit(ImageData.BLIT_SRC,", "+\t\t\timage.data, image.depth, image.bytesPerLine, image.getByteOrder(), 0, 0, width, height, srcReds, srcGreens, srcBlues,", "+\t\t\tImageData.ALPHA_OPAQUE, null, 0, 0, 0,", "+\t\t\tbuffer, 32, bpr, ImageData.MSB_FIRST, 0, 0, width, height, newPalette.redMask, newPalette.greenMask, newPalette.blueMask,", "+\t\t\tfalse, false);", "+\t}", "+\t", "+\t/* Initialize transparency */", "+\tif (transparency == SWT.TRANSPARENCY_MASK || image.transparentPixel != -1) {", "+\t\tthis.type = image.transparentPixel != -1 ? SWT.BITMAP : SWT.ICON;", "+\t\tif (image.transparentPixel != -1) {}", "+\t\tImageData maskImage = image.getTransparencyMask();", "+\t\tbyte[] maskData = maskImage.data;", "+\t\tint maskBpl = maskImage.bytesPerLine;", "+\t\tint offset = 0, maskOffset = 0;", "+\t\tfor (int y = 0; y<height; y++) {", "+\t\t\tfor (int x = 0; x<width; x++) {", "+\t\t\t\tbuffer[offset] = ((maskData[maskOffset + (x >> 3)]) & (1 << (7 - (x & 0x7)))) != 0 ? (byte)0xff : 0;", "+\t\t\t\toffset += 4;", "+\t\t\t}", "+\t\t\tmaskOffset += maskBpl;", "-\t\tthis.mask = 0;", "-\t\tthis.alpha = image.alpha;", "-\t\tif (image.alpha == -1 && image.alphaData != null) {", "+\t\tif (image.alpha != -1) {", "+\t\t\tthis.alpha = image.alpha;", "+\t\t\tbyte a = (byte)this.alpha;", "+\t\t\tfor (int dataIndex=0; dataIndex<buffer.length; dataIndex+=4) {", "+\t\t\t\tbuffer[dataIndex] = a;\t\t\t\t", "+\t\t\t}", "+\t\t} else if (image.alphaData != null) {", "+\t\t\tint offset = 0, alphaOffset = 0;", "+\t\t\tfor (int y = 0; y<height; y++) {", "+\t\t\t\tfor (int x = 0; x<width; x++) {", "+\t\t\t\t\tbuffer[offset] = alphaData[alphaOffset];", "+\t\t\t\t\toffset += 4;", "+\t\t\t\t\talphaOffset += 1;", "+\t\t\t\t}", "+\t\t\t}", "-\tthis.pixmap = pixmap;", "+\t", "+\tOS.memcpy(data, buffer, dataSize);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dee4be2fccb96b05338275401b130e2e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/common/org/eclipse/swt/internal/image/GIFFileFormat.java", "commitBeforeChange": "553d7364f85189cde07e065aaa5ba7380f0c1418", "commitAfterChange": "ff32f7578b312ab2cf7bee31c19161e45b3b344c", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tvoid unloadIntoByteStream(ImageData image)", "signatureAfterChange": "  \tvoid unloadIntoByteStream(ImageLoader loader)", "diff": ["-\t */", "-\tvoid unloadIntoByteStream(ImageData image) {", "-\t\tif (!((image.depth == 1) || (image.depth == 4) || (image.depth == 8))) {", "+\tvoid unloadIntoByteStream(ImageLoader loader) {", "+\t\t", "+ \t\t/* Step 1: Acquire GIF parameters */", "+\t\tImageData[] data = loader.data;", "+\t\tint frameCount = data.length;", "+\t\tboolean multi = frameCount > 1;", "+\t\tImageData firstImage = data[0];", "+\t\tint logicalScreenWidth = multi ? loader.logicalScreenWidth : firstImage.width;", "+\t\tint logicalScreenHeight = multi ? loader.logicalScreenHeight : firstImage.height;", "+\t\tint backgroundPixel = loader.backgroundPixel;", "+\t\tint depth = firstImage.depth;", "+\t\tPaletteData palette = firstImage.palette;", "+\t\tRGB[] colors = palette.getRGBs();", "+\t\tshort globalTable = 1;", "+\t\t\t\t", "+\t\t/* Step 2: Check for validity and global/local color map */", "+\t\tif (!(depth == 1 || depth == 4 || depth == 8)) {", "-\t\tbyte bitField = (byte)((0x80 & 0xF8 & 0xF7 & 0x8F) + (image.depth - 1) + ((image.depth - 1) * 16));", "+\t\tfor (int i=0; i<frameCount; i++) {", "+\t\t\tif (data[i].palette.isDirect) {", "+\t\t\t\tSWT.error(SWT.ERROR_INVALID_IMAGE);", "+\t\t\t}", "+\t\t\tif (multi) {", "+\t\t\t\tif (!(data[i].height <= logicalScreenHeight && data[i].width <= logicalScreenWidth && data[i].depth == depth)) {", "+\t\t\t\t\tSWT.error(SWT.ERROR_INVALID_IMAGE);", "+\t\t\t\t}", "+\t\t\t\tif (globalTable == 1) {", "+\t\t\t\t\tRGB rgbs[] = data[i].palette.getRGBs();", "+\t\t\t\t\tif (rgbs.length != colors.length) {", "+\t\t\t\t\t\tglobalTable = 0;", "+\t\t\t\t\t} else { ", "+\t\t\t\t\t\tfor (int j=0; j<colors.length; j++) {", "+\t\t\t\t\t\t\tif (!(rgbs[j].red == colors[j].red &&", "+\t\t\t\t\t\t\t\trgbs[j].green == colors[j].green &&", "+\t\t\t\t\t\t\t\trgbs[j].blue == colors[j].blue))", "+\t\t\t\t\t\t\t\t\tglobalTable = 0;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t", "-\t\t\toutputStream.write(new byte[] { (byte)'G', (byte)'I', (byte)'F' });", "-\t\t\toutputStream.write(new byte[] { (byte)'8', (byte)'9', (byte)'a' });", "-\t\t\toutputStream.writeShort((short)image.width);", "-\t\t\toutputStream.writeShort((short)image.height);", "-\t\t\toutputStream.writeByte(bitField);", "-\t\t\toutputStream.writeByte((byte)0);", "+ \t\t\t/* Step 3: Write the GIF89a Header and Logical Screen Descriptor */", "+\t\t\tint bits = globalTable*128 + (depth-1)*16 + depth-1;", "+\t\t\toutputStream.write(\"GIF89a\".getBytes());", "+\t\t\toutputStream.writeShort((short)logicalScreenWidth);", "+\t\t\toutputStream.writeShort((short)logicalScreenHeight);", "+\t\t\toutputStream.writeByte((byte)bits);", "+\t\t\toutputStream.writeByte((byte)backgroundPixel);", "-\t\twritePalette(image.palette, image.depth);", "-\t\tif (image.transparentPixel != -1 || image.disposalMethod != 0 || image.delayTime != 0) {", "-\t\t\twriteGraphicsControlBlock(image);", "+\t\t", "+\t\t/* Step 4: Write Global Color Table if applicable */", "+\t\tif (globalTable == 1) {", "+\t\t\twritePalette(palette, depth);", "-\t\twriteImageBlock(image);", "+", "+\t\t/* Step 5: Write Application Extension if applicable */", "+\t\tif (multi) {", "+\t\t\tint repeatCount = loader.repeatCount;", "+\t\t\ttry {", "+\t\t\t\toutputStream.write(GIF_EXTENSION_BLOCK_ID);", "+\t\t\t\toutputStream.write(GIF_APPLICATION_EXTENSION_BLOCK_ID);", "+\t\t\t\toutputStream.write((byte)11); // Eleven bytes following", "+\t\t\t\toutputStream.write(\"NETSCAPE2.0\".getBytes());", "+\t\t\t\toutputStream.write((byte)3); // Three bytes following", "+\t\t\t\toutputStream.writeByte((byte)1);", "+\t\t\t\toutputStream.write((byte) repeatCount & 0xFF);", "+\t\t\t\toutputStream.write((byte) (repeatCount >> 8) & 0xFF);", "+\t\t\t\toutputStream.writeByte((byte)0);", "+\t\t\t} catch (IOException e) {", "+\t\t\t\tSWT.error(SWT.ERROR_IO, e);", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\tfor (int frame=0; frame<frameCount; frame++) {", "+\t\t\t", "+\t\t\t/* Step 6: Write Graphics Control Block for each frame if applicable */", "+\t\t\tif (multi || data[frame].transparentPixel != -1) {", "+\t\t\t\twriteGraphicsControlBlock(data[frame]);", "+\t\t\t}", "+\t\t\t", "+\t\t\t/* Step 7: Write Image Header for each frame */", "+\t\t\tint x = data[frame].x;", "+\t\t\tint y = data[frame].y;", "+\t\t\tint width = data[frame].width;", "+\t\t\tint height = data[frame].height;", "+\t\t\ttry {", "+\t\t\t\toutputStream.write(GIF_IMAGE_BLOCK_ID);  // 0x2C", "+\t\t\t\tbyte[] block = new byte[9];", "+\t\t\t\tblock[0] = (byte)(x & 0xFF);", "+\t\t\t\tblock[1] = (byte)((x >> 8) & 0xFF);", "+\t\t\t\tblock[2] = (byte)(y & 0xFF);", "+\t\t\t\tblock[3] = (byte)((y >> 8) & 0xFF);", "+\t\t\t\tblock[4] = (byte)(width & 0xFF);", "+\t\t\t\tblock[5] = (byte)((width >> 8) & 0xFF);", "+\t\t\t\tblock[6] = (byte)(height & 0xFF);", "+\t\t\t\tblock[7] = (byte)((height >> 8) & 0xFF); ", "+\t\t\t\tblock[8] = (byte)(globalTable == 0 ? (depth-1) | 0x80 : 0x00);", "+\t\t\t\toutputStream.write(block);", "+\t\t\t} catch (IOException e) {", "+\t\t\t\tSWT.error(SWT.ERROR_IO, e);", "+\t\t\t}", "+\t\t\t", "+\t\t\t/* Step 8: Write Local Color Table for each frame if applicable */", "+\t\t\tif (globalTable == 0) {", "+\t\t\t\twritePalette(data[frame].palette, depth);", "+\t\t\t}", "+\t\t\t", "+\t\t\t/* Step 9: Write the actual data for each frame */", "+\t\t\ttry {", "+\t\t\t\toutputStream.write(depth); // minimum LZW Code size: 3 for 1 bit per pixel images and usually the number of bits per pixel plus 1 for other images.", "+\t\t\t} catch (IOException e) {", "+\t\t\t\tSWT.error(SWT.ERROR_IO, e);", "+\t\t\t}", "+\t\t\tnew LZWCodec().encode(outputStream, data[frame]);", "+\t\t}", "+", "+\t\t/* Step 10: Write GIF terminator */"]}], "num": 26626}