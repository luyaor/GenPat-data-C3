{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2551c657ecea3f850b8ebbe0a843d692", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3bc7bab8f4fb99a315adf9d187202618", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/ToolBar.java", "commitBeforeChange": "5c71c160828b856065885beff06af81ccfac684f", "commitAfterChange": "1692fbe72737d57ce7a28edd69b8de45d624b6dc", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 45, "signatureBeforeChange": "  LRESULT WM_SIZE (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_SIZE (int wParam, int lParam)", "diff": ["+\t/*", "+\t* Bug in Windows.  The code in Windows that determines", "+\t* when tool items should wrap seems to use the window", "+\t* bounds rather than the client area.  Unfortunately,", "+\t* tool bars with the style TBSTYLE_EX_HIDECLIPPEDBUTTONS", "+\t* use the client area.  This means that buttons which", "+\t* overlap the border are hidden before they are wrapped.", "+\t* The fix is to compute TBSTYLE_EX_HIDECLIPPEDBUTTONS", "+\t* and set it each time the tool bar is resized.", "+\t*/", "+\tif ((style & SWT.BORDER) != 0 && (style & SWT.WRAP) != 0) {", "+\t\tRECT windowRect = new RECT ();", "+\t\tOS.GetWindowRect (handle, windowRect);", "+\t\tint index = 0, border = getBorderWidth () * 2; ", "+\t\tRECT rect = new RECT ();", "+\t\tint count = OS.SendMessage (handle, OS.TB_BUTTONCOUNT, 0, 0);", "+\t\twhile (index < count) {", "+\t\t\tOS.SendMessage (handle, OS.TB_GETITEMRECT, index, rect);", "+\t\t\tOS.MapWindowPoints (handle, 0, rect, 2);", "+\t\t\tif (rect.right > windowRect.right - border * 2) break;", "+\t\t\tindex++;", "+\t\t}", "+\t\tint bits = OS.SendMessage (handle, OS.TB_GETEXTENDEDSTYLE, 0, 0);", "+\t\tif (index == count) {", "+\t\t\tbits |= OS.TBSTYLE_EX_HIDECLIPPEDBUTTONS;", "+\t\t} else {", "+\t\t\tbits &= ~OS.TBSTYLE_EX_HIDECLIPPEDBUTTONS;", "+\t\t}", "+\t\tOS.SendMessage (handle, OS.TB_SETEXTENDEDSTYLE, 0, bits);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d2a5264c995219b94e299a1ed6afcc63", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "fcad395d7da1b4363faafa06975ec35422a8ea3a", "commitAfterChange": "d7427cebf50028bab5e6b28bb9e84910376870e1", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "  void createItem (TreeItem item, int hParent, int hInsertAfter, int hItem)", "signatureAfterChange": "  void createItem (TreeItem item, int hParent, int hInsertAfter, int hItem)", "diff": ["+\t\t/*", "+\t\t* Bug in Windows.  When a new item is added while Windows", "+\t\t* is requesting data a tree item using TVN_GETDISPINFO,", "+\t\t* outstanding damage for items that are below the new item", "+\t\t* is not scrolled.  The fix is to explicitly damage the", "+\t\t* new area.", "+\t\t*/", "+\t\tif ((style & SWT.VIRTUAL) != 0) {", "+\t\t\tif (currentItem != null) {", "+\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\trect.left = hNewItem;", "+\t\t\t\tif (OS.SendMessage (handle, OS.TVM_GETITEMRECT, 0, rect) != 0) {", "+\t\t\t\t\tRECT damageRect = new RECT ();", "+\t\t\t\t\tboolean damaged = OS.GetUpdateRect (handle, damageRect, true);", "+\t\t\t\t\tif (damaged && damageRect.top < rect.bottom) {", "+\t\t\t\t\t\tif (OS.IsWinCE) {", "+\t\t\t\t\t\t\tOS.OffsetRect (damageRect, 0, rect.bottom - rect.top);", "+\t\t\t\t\t\t\tOS.InvalidateRect (handle, damageRect, true);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tint rgn = OS.CreateRectRgn (0, 0, 0, 0);", "+\t\t\t\t\t\t\tint result = OS.GetUpdateRgn (handle, rgn, true);", "+\t\t\t\t\t\t\tif (result != OS.NULLREGION) {", "+\t\t\t\t\t\t\t\tOS.OffsetRgn (rgn, 0, rect.bottom - rect.top);", "+\t\t\t\t\t\t\t\tOS.InvalidateRgn (handle, rgn, true);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tOS.DeleteObject (rgn);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "399666699a19264b4267b96a500e2070", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/TableTree.java", "commitBeforeChange": "a7f55348122e685e185be79f1e61c482f210f9b0", "commitAfterChange": "7b9bd176a3b0bcedf3e37bac78e4b0ee77698321", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 21, "signatureBeforeChange": "\r \t\tpublic void handleEvent(Event e)", "signatureAfterChange": "\r \r void onTraverse(Event e)", "diff": ["-\taddListener(SWT.Resize, new Listener() {\r", "-\t\tpublic void handleEvent(Event e) {\r", "-\t\t\tonResize();\r", "-\t\t}\r", "+void onTraverse(Event e) {\r", "+\tif (e.stateMask != SWT.SHIFT) return;\r", "+\tif (e.detail == SWT.TRAVERSE_ARROW_PREVIOUS || e.detail == SWT.TRAVERSE_ARROW_NEXT) {\r", "+\t\tTableTreeItem[] selection = getSelection();\r", "+\t\tif (selection.length > 0) {\r", "+\t\t\tTableTreeItem item = selection[0];\r", "+\t\t\tif (item.getItemCount() == 0) return;\r", "+\t\t\tint type;\r", "+\t\t\tif (e.detail == SWT.TRAVERSE_ARROW_NEXT) {\r", "+\t\t\t\tif (item.getExpanded()) return;\r", "+\t\t\t\titem.setExpanded(true);\r", "+\t\t\t\ttable.setTopIndex(table.indexOf(item.tableItem));\r", "+\t\t\t\ttype = SWT.Expand;\r", "+\t\t\t} else {\r", "+\t\t\t\tif (!item.getExpanded()) return;\r", "+\t\t\t\titem.setExpanded(false);\r", "+\t\t\t\ttype = SWT.Collapse;\r", "+\t\t\t}\r", "+\t\t\tEvent event = new Event();\r", "+\t\t\tevent.item = item;\r", "+\t\t\tnotifyListeners(type, event);\r", "+\t\t}\r", "+\t}\r", "+}\r"]}], "num": 14023}