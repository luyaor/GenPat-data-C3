{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9bb82b631bed982352ab1537b7d3f328", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e2cd1a45fc0806e2ba457793864cb0f", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "5f543edb783691ac010cc1801defbf6238ace7aa", "commitAfterChange": "ffcd121fb7431ca67e0c96c3686d0eb26efd2568", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " public ImageData getImageData()", "signatureAfterChange": " public ImageData getImageData()", "diff": ["-\t\t// Get the bitmap data from the image representation. In the non-planar case it's easy.", "-\t\tbyte imageData[] = new byte[(int)/*64*/dataSize];", "-\t\t", "-\t\tif (!imageRep.isPlanar()) {", "-\t\t\tOS.memmove(imageData, imageRep.bitmapData(), dataSize);", "-\t\t} else {", "-\t\t\tint /*long*/ bytesPerPlane = imageRep.bytesPerPlane();", "-\t\t\tint /*long*/ numPlanes = imageRep.numberOfPlanes();", "-\t\t\t", "-\t\t\t// getBitmapDataPlanes always returns an array of five pointers. Non-applicable", "-\t\t\t// data planes are set to NULL (0).", "-\t\t\tint /*long*/ nativeDataPlanes[] = new int /*long*/ [5];", "-\t\t\timageRep.getBitmapDataPlanes(nativeDataPlanes);", "-\t\t\t", "-\t\t\tbyte dataPlanes[][] = new byte[(int)/*64*/numPlanes][(int)/*64*/bytesPerPlane];", "-\t\t\tfor (int i = 0; i < numPlanes; i++) {", "-\t\t\t\tOS.memmove(dataPlanes[i], nativeDataPlanes[i], bytesPerPlane);", "-\t\t\t}", "-\t\t\t", "-\t\t\t// Copy the planar data into the imageData array in ARGB format if there is alpha, and RGB if not.", "-\t\t\t// All non-RGB colorspace images were rejected earlier, so planes 0, 1 and 2 have the R, G, and B", "-\t\t\t// values, respectively. Plane 3 contains alpha values, if there is alpha.", "-\t\t\tNSString colorSpace = imageRep.colorSpaceName();\t\t\t", "-\t\t\tint /*long*/ colorComponents = OS.NSNumberOfColorComponents(colorSpace.id);", "-\t\t\tboolean hasAlpha = false;", "-\t\t\t", "-\t\t\tif (colorComponents == 3) {", "-\t\t\t\tif (numPlanes == 4) hasAlpha = true;", "-\t\t\t\tint samplesPerPixel = (hasAlpha ? 4 : 3);", "-\t\t\t\tint firstByteOfPixel = (hasAlpha ? 1 : 0);", "-\t\t\t\t", "-\t\t\t\tfor (int j = 0, k = 0; j < bytesPerPlane; j += samplesPerPixel, k++) {", "-\t\t\t\t\timageData[j + firstByteOfPixel] = dataPlanes[0][k]; // red component", "-\t\t\t\t\timageData[j + firstByteOfPixel + 1] = dataPlanes[1][k]; // blue component", "-\t\t\t\t\timageData[j + firstByteOfPixel + 2] = dataPlanes[2][k]; // green component", "-\t\t\t\t\tif (hasAlpha) imageData[j] = dataPlanes[3][k]; // alpha component", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-", "-\t\t// The RGB mask depends on where the alpha was stored in the pixel data.", "-\t\tint /*long*/ dataFormat = imageRep.bitmapFormat();", "-\t\tPaletteData palette = null;", "-", "-\t\tint /*long*/ bps = imageRep.bitsPerSample();", "-\t\tint blueMask = (1 << bps) - 1;", "-\t\tif (imageRep.hasAlpha() && (dataFormat & OS.NSAlphaFirstBitmapFormat) == 0) blueMask <<= bps;", "-\t\tint greenMask = blueMask << bps;", "-\t\tint redMask = greenMask << bps;", "-\t\t", "-\t\tpalette = new PaletteData(redMask, greenMask, blueMask);", "-", "+\t\tPaletteData palette = new PaletteData(0xFF0000, 0xFF00, 0xFF);", "-\t\t\tint startByte = ((dataFormat & OS.NSAlphaFirstBitmapFormat) == 0 ? 3 : 0);", "-\t\t\tint offset = startByte, maskOffset = 0;", "+\t\t\tint offset = 0, maskOffset = 0;", "-\t\t", "-\t\tint startByte = ((dataFormat & OS.NSAlphaFirstBitmapFormat) == 0 ? 3 : 0);", "-\t\tfor (int i = startByte; i < srcData.length; i+= 4) {", "+\t\tfor (int i = 0; i < srcData.length; i+= 4) {", "-\t\tif (imageRep.hasAlpha()) {", "-\t\t\tdata.alpha = alpha;", "-\t\t\tif (alpha == -1 && alphaData != null) {", "-\t\t\t\tdata.alphaData = new byte[alphaData.length];", "-\t\t\t\tSystem.arraycopy(alphaData, 0, data.alphaData, 0, alphaData.length);", "-\t\t\t}", "+\t\tdata.alpha = alpha;", "+\t\tif (alpha == -1 && alphaData != null) {", "+\t\t\tdata.alphaData = new byte[alphaData.length];", "+\t\t\tSystem.arraycopy(alphaData, 0, data.alphaData, 0, alphaData.length);", "-\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd79b08d15c2dec3ca602dc0972cd272", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/CLabel.java", "commitBeforeChange": "375f170984f806358459eddfb9d90890a149bea6", "commitAfterChange": "74c146fa2d02aeede60f17f32016c04f01c3b944", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "\r public void setBackground(Color[] colors, int[] percents)", "signatureAfterChange": "\r \r public void setBackground (Color color)", "diff": ["+\r", "+public void setBackground (Color color) {\r", "+\tsuper.setBackground (color);\r", "+\tbackgroundImage = null;\r", "+\tgradientColors = null;\r", "+\tgradientPercents = null;\r", "+\tredraw ();\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9fcd8cb0e336f324e1f8b4e07c743105", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Custom Widgets/common/org/eclipse/swt/custom/CLabel.java", "commitBeforeChange": "1a5db4d0ac13c4a375470f5649e534ab44f499f8", "commitAfterChange": "f4b24ed8afb282f7031daa35f99df80c4954629f", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": " public void setBackground(Color[] colors, int[] percents)", "signatureAfterChange": " public void setBackground(Color[] colors, int[] percents)", "diff": ["-public void setBackground(Color[] colors, int[] percents) {\t", "+public void setBackground(Color[] colors, int[] percents) {", "+\tsetBackground(colors, percents, false);", "+}", "-\t\t\tif (same) return;"]}], "num": 52733}