{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3094c82565b32616ed90792e55564af9", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "de9e54f5617ea9929c238234d6af5b6e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Program/motif/org/eclipse/swt/program/Program.java", "commitBeforeChange": "e7fb43dbb2484659429530f9cab714cb6e3de9f3", "commitAfterChange": "d69b8bce251422ebdcfdac8edd7d2bcf938dfebd", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r \r private static void gnome_parseMimeFile( Hashtable info, BufferedReader reader )", "signatureAfterChange": "  private static void gnome_parseMimeFile( Hashtable info, BufferedReader reader )", "diff": ["-\r", "-private static void gnome_parseMimeFile( Hashtable info, BufferedReader reader ) {\r", "-\tVector  mimeExts = null;\r", "-\tString  mimeType = null;\r", "-\tboolean saveType = false;\r", "-\tString  line     = \"#\";\r", "-\twhile (line != null) {\r", "-\t\t\r", "-\t\t// Determine if the line contains a mime type name.\r", "-\t\tboolean newType = (line.length() > 0 && Character.isLetter( line.charAt(0) ));\r", "-\t\t\t\t  \r", "-\t\t// If there is valid data on this line to be processed\r", "-\t\tString data = line.trim();\r", "-\t\tif (data.length() > 0 && data.charAt(0) != '#') {\r", "-\t\t\t\r", "-\t\t\t// If this line defines a new mime type\r", "-\t\t\tif (newType) {\r", "-\t\t\t\t\r", "-\t\t\t\t// If a previous mime type has not be saved yet\r", "-\t\t\t\tif (mimeType != null) {\r", "-\t\t\t\t\t// Save the type and process this line again.\r", "-\t\t\t\t\tsaveType = true;\r", "-\t\t\t\t}\r", "-\t\t\t\t// else initialize the mime type info\r", "-\t\t\t\telse {\r", "-\t\t\t\t\tint colon = data.indexOf( ':' );\r", "-\t\t\t\t\tif (colon != -1) {\r", "-\t\t\t\t\t\tmimeType = data.substring( 0, colon );\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\telse {\r", "-\t\t\t\t\t\tmimeType = data;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tmimeExts = new Vector();\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\t\r", "-\t\t\t// else if the line defines a list of extensions\r", "-\t\t\telse if (data.indexOf( \"ext\" ) == 0 && mimeType != null) {\r", "-\t\t\t\t\r", "-\t\t\t\t// Get the extensions defined on the line\r", "-\t\t\t\tString exts = \"\";\r", "-\t\t\t\tint colon = data.indexOf( ':' );\r", "-\t\t\t\tif ((colon != -1) && ((colon+1) < data.length())) {\r", "-\t\t\t\t\texts = data.substring( (colon+1) ).trim();\r", "-\t\t\t\t}\r", "-\t\t\t\t\r", "-\t\t\t\t// While there are extensions to be processed\r", "-\t\t\t\texts = exts.replace( '\\t', ' ' );\r", "-\t\t\t\twhile (exts.length() != 0) {\r", "-\t\t\t\t\t// Extract the next entension from the list\r", "-\t\t\t\t\tString newExt;\r", "-\t\t\t\t\tint  space = exts.indexOf( ' ' );\r", "-\t\t\t\t\tif (space != -1) {\r", "-\t\t\t\t\t\tnewExt = exts.substring( 0, space );\r", "-\t\t\t\t\t\texts = exts.substring( space ).trim();\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\telse {\r", "-\t\t\t\t\t\tnewExt = exts;\r", "-\t\t\t\t\t\texts = \"\";\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\t\r", "-\t\t\t\t\t// Prefix an extension with a period.\r", "-\t\t\t\t\tif (newExt.charAt(0) != '.') {\r", "-\t\t\t\t\t\tnewExt = \".\" + newExt;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tmimeExts.add( newExt );\r", "-\t\t\t\t} \r", "-\t\t\t}\r", "-\t\t\t\r", "-\t\t\t// else if the line defines a list of regular expressions\r", "-\t\t\telse if (data.indexOf( \"regex\" ) == 0 && mimeType != null) {\r", "-\t\t\t\t// Do nothing with these right now.\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t\r", "-\t\t\r", "-\t\t// If the current mime type is still being processed\r", "-\t\tif (!saveType) {\r", "-\t\t\t// Get the next line\t\t\t\r", "-\t\t\ttry {\r", "-\t\t\t\tline = reader.readLine();\r", "-\t\t\t}\r", "-\t\t\tcatch (IOException e) {\r", "-\t\t\t\tline = null;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t\r", "-\t\t// If the current type should be saved or if the end\r", "-\t\t// of the file was reached\r", "-\t\tif (saveType || (line == null)) {\r", "-\r", "-\t\t\t// If there is a mime type to be saved\r", "-\t\t\tif (mimeType != null) {\r", "-\t\t\t\r", "-\t\t\t\t// If the mime type does not exist in the map, add it.\r", "-\t\t\t\tVector prevExts = (Vector) info.get( mimeType );\r", "-\t\t\t\tif (prevExts == null) {\r", "-\t\t\t\t\tinfo.put( mimeType, mimeExts );\r", "-\t\t\t\t}\r", "-\t\t\r", "-\t\t\t\t// else append the new list of extensions.\r", "-\t\t\t\telse {\r", "-\t\t\t\t\tfor (int i = 0; i < mimeExts.size(); i++) {\r", "-\t\t\t\t\t\tprevExts.add( mimeExts.elementAt( i ) );\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t\tmimeType = null;\r", "-\t\t\t\tmimeExts = null;\r", "-\t\t\t\tsaveType = false;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r", "-}\r", "+", "+private static void gnome_parseMimeFile( Hashtable info, BufferedReader reader ) {", "+\tVector  mimeExts = null;", "+\tString  mimeType = null;", "+\tboolean saveType = false;", "+\tString  line     = \"#\";", "+\twhile (line != null) {", "+\t\t", "+\t\t// Determine if the line contains a mime type name.", "+\t\tboolean newType = (line.length() > 0 && Character.isLetter( line.charAt(0) ));", "+\t\t\t\t  ", "+\t\t// If there is valid data on this line to be processed", "+\t\tString data = line.trim();", "+\t\tif (data.length() > 0 && data.charAt(0) != '#') {", "+\t\t\t", "+\t\t\t// If this line defines a new mime type", "+\t\t\tif (newType) {", "+\t\t\t\t", "+\t\t\t\t// If a previous mime type has not be saved yet", "+\t\t\t\tif (mimeType != null) {", "+\t\t\t\t\t// Save the type and process this line again.", "+\t\t\t\t\tsaveType = true;", "+\t\t\t\t}", "+\t\t\t\t// else initialize the mime type info", "+\t\t\t\telse {", "+\t\t\t\t\tint colon = data.indexOf( ':' );", "+\t\t\t\t\tif (colon != -1) {", "+\t\t\t\t\t\tmimeType = data.substring( 0, colon );", "+\t\t\t\t\t}", "+\t\t\t\t\telse {", "+\t\t\t\t\t\tmimeType = data;", "+\t\t\t\t\t}", "+\t\t\t\t\tmimeExts = new Vector();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\t// else if the line defines a list of extensions", "+\t\t\telse if (data.indexOf( \"ext\" ) == 0 && mimeType != null) {", "+\t\t\t\t", "+\t\t\t\t// Get the extensions defined on the line", "+\t\t\t\tString exts = \"\";", "+\t\t\t\tint colon = data.indexOf( ':' );", "+\t\t\t\tif ((colon != -1) && ((colon+1) < data.length())) {", "+\t\t\t\t\texts = data.substring( (colon+1) ).trim();", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// While there are extensions to be processed (use space as separator)", "+\t\t\t\texts = exts.replace( '\\t', ' ' );", "+\t\t\t\texts = exts.replace( ',', ' ' );", "+\t\t\t\twhile (exts.length() != 0) {", "+\t\t\t\t\t// Extract the next entension from the list", "+\t\t\t\t\tString newExt;", "+\t\t\t\t\tint  space = exts.indexOf( ' ' );", "+\t\t\t\t\tif (space != -1) {", "+\t\t\t\t\t\tnewExt = exts.substring( 0, space );", "+\t\t\t\t\t\texts = exts.substring( space ).trim();", "+\t\t\t\t\t}", "+\t\t\t\t\telse {", "+\t\t\t\t\t\tnewExt = exts;", "+\t\t\t\t\t\texts = \"\";", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// Prefix an extension with a period.", "+\t\t\t\t\tif (newExt.charAt(0) != '.') {", "+\t\t\t\t\t\tnewExt = \".\" + newExt;", "+\t\t\t\t\t}", "+\t\t\t\t\tmimeExts.add( newExt );", "+\t\t\t\t} ", "+\t\t\t}", "+\t\t\t", "+\t\t\t// else if the line defines a list of regular expressions", "+\t\t\telse if (data.indexOf( \"regex\" ) == 0 && mimeType != null) {", "+\t\t\t\t// Do nothing with these right now.", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t", "+\t\t// If the current mime type is still being processed", "+\t\tif (!saveType) {", "+\t\t\t// Get the next line\t\t\t", "+\t\t\ttry {", "+\t\t\t\tline = reader.readLine();", "+\t\t\t}", "+\t\t\tcatch (IOException e) {", "+\t\t\t\tline = null;", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// If the current type should be saved or if the end", "+\t\t// of the file was reached", "+\t\tif (saveType || (line == null)) {", "+\t\t\t// If there is a mime type to be saved", "+\t\t\tif (mimeType != null) {", "+\t\t\t", "+\t\t\t\t// If the mime type does not exist in the map, add it.", "+\t\t\t\tVector prevExts = (Vector) info.get( mimeType );", "+\t\t\t\tif (prevExts == null) {", "+\t\t\t\t\tinfo.put( mimeType, mimeExts );", "+\t\t\t\t}", "+\t\t", "+\t\t\t\t// else append the new list of extensions.", "+\t\t\t\telse {", "+\t\t\t\t\tfor (int i = 0; i < mimeExts.size(); i++) {", "+\t\t\t\t\t\tprevExts.add( mimeExts.elementAt( i ) );", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tmimeType = null;", "+\t\t\tmimeExts = null;", "+\t\t\tsaveType = false;", "+\t\t}", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4e6d5e3e731b91b35cbd9470fdbe5ca3", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "dd11d932221c358c44e83cdb9ee36bc7594323b4", "commitAfterChange": "8b896c8f1d8f2340e6910ed5d99ab3f39a66e8c2", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " protected void init ()", "signatureAfterChange": " protected void init ()", "diff": ["+\tCOLOR_INFO_FOREGROUND = \t\tColor.carbon_new(this, 0x000000, true);"]}], "num": 52059}