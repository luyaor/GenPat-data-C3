{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7ab3a5fd40861b77818b17cb94d585de", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a38e053c469c2f47f745f70276c78963", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/GC.java", "commitBeforeChange": "62bfd83b9f7c798916f986e294f941ecd8738afe", "commitAfterChange": "d7ebcefb1d0b8f363be13e76e2ce239acc725ff5", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  void drawIcon(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)", "signatureAfterChange": "  void drawIcon(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)", "diff": ["+\tboolean drawIcon = true;", "+\tint flags = OS.DI_NORMAL;", "+\tif (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(5, 1)) {", "+\t\tflags |= OS.DI_NOMIRROR;", "+\t} else {", "+\t\tdrawIcon = (data.style & SWT.MIRRORED) == 0;", "+\t}", "+", "-\tif (simple && technology != OS.DT_RASPRINTER) {", "-\t\tOS.DrawIconEx(handle, destX, destY, srcImage.handle, 0, 0, 0, 0, OS.DI_NORMAL | OS.DI_NOMIRROR);", "+\tif (simple && technology != OS.DT_RASPRINTER && drawIcon) {", "+\t\tOS.DrawIconEx(handle, destX, destY, srcImage.handle, 0, 0, 0, 0, flags);", "-\t\tif (simple && technology != OS.DT_RASPRINTER)\t{", "+\t\tif (!drawIcon) {", "+\t\t\tint srcHdc = OS.CreateCompatibleDC(handle);", "+\t\t\tint srcColorY = srcY;", "+\t\t\tint srcColor = srcIconInfo.hbmColor;", "+\t\t\tif (srcColor == 0) {", "+\t\t\t\tsrcColor = srcIconInfo.hbmMask;", "+\t\t\t\tsrcColorY += iconHeight;", "+\t\t\t}", "+\t\t\tint srcMask = srcIconInfo.hbmMask;", "+\t\t\tint oldSrcBitmap = OS.SelectObject(srcHdc, srcColor);", "+\t\t\tif (!simple && (srcWidth != destWidth || srcHeight != destHeight)) {", "+\t\t\t\tint mode = 0;", "+\t\t\t\tif (!OS.IsWinCE) mode = OS.SetStretchBltMode(handle, OS.COLORONCOLOR);", "+\t\t\t\tOS.StretchBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcColorY, srcWidth, srcHeight, OS.SRCINVERT);", "+\t\t\t\tOS.SelectObject(srcHdc, srcMask);", "+\t\t\t\tOS.StretchBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcY, srcWidth, srcHeight, OS.SRCAND);", "+\t\t\t\tOS.SelectObject(srcHdc, srcColor);", "+\t\t\t\tOS.StretchBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcColorY, srcWidth, srcHeight, OS.SRCINVERT);", "+\t\t\t\tif (!OS.IsWinCE) OS.SetStretchBltMode(handle, mode);", "+\t\t\t} else {", "+\t\t\t\tOS.BitBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcColorY, OS.SRCINVERT);", "+\t\t\t\tOS.SelectObject(srcHdc, srcMask);", "+\t\t\t\tOS.BitBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcY, OS.SRCAND);", "+\t\t\t\tOS.SelectObject(srcHdc, srcColor);", "+\t\t\t\tOS.BitBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcColorY, OS.SRCINVERT);", "+\t\t\t}", "+\t\t\tOS.SelectObject(srcHdc, oldSrcBitmap);", "+\t\t\tOS.DeleteDC(srcHdc);", "+\t\t} else if (simple && technology != OS.DT_RASPRINTER) {", "-\t\t\tOS.DrawIconEx(handle, destX, destY, srcImage.handle, 0, 0, 0, 0, OS.DI_NORMAL | OS.DI_NOMIRROR);", "+\t\t\tOS.DrawIconEx(handle, destX, destY, srcImage.handle, 0, 0, 0, 0, flags);", "-\t\t\t\tOS.DrawIconEx(handle, destX, destY, hIcon, destWidth, destHeight, 0, 0, OS.DI_NORMAL | OS.DI_NOMIRROR);", "+\t\t\t\tOS.DrawIconEx(handle, destX, destY, hIcon, destWidth, destHeight, 0, 0, flags);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "819e3b86bbe774f2e8f8223888e00bf3", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/win32/org/eclipse/swt/browser/IE.java", "commitBeforeChange": "2ef2e709c4c31aa7b46fb0d933d3fc8c2c2d5682", "commitAfterChange": "1558841b1896e9e706af6006087cd106ba6d2af3", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  public void create(Composite parent, int style)", "signatureAfterChange": "  public void create(Composite parent, int style)", "diff": ["-\t\t\t\t\tlastNavigateURL = null;", "+\t\t\t\t\tlastNavigateURL = uncRedirect = null;", "+", "+\t\t\t\t\t\tif (uncRedirect != null) {", "+\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t* Silently allow the navigate to proceed if the url is the first segment of a", "+\t\t\t\t\t\t\t* UNC path being navigated to (initiated by the NavigateError listener to show", "+\t\t\t\t\t\t\t* a name/password prompter), or if the url is the full UNC path (initiated by", "+\t\t\t\t\t\t\t* the NavigateComplete listener to redirect from the UNC's first segment to its", "+ \t\t\t\t\t\t\t* full path).", "+\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\tif (uncRedirect.equals(url) || (uncRedirect.startsWith(url) && uncRedirect.indexOf('\\\\', 2) == url.length())) {", "+\t\t\t\t\t\t\t\tVariant cancel = event.arguments[6];", "+\t\t\t\t\t\t\t\tif (cancel != null) {", "+\t\t\t\t\t\t\t\t\tint /*long*/ pCancel = cancel.getByRef();", "+\t\t\t\t\t\t\t\t\tCOM.MoveMemory(pCancel, new short[] {COM.VARIANT_FALSE}, 2);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t\t* This navigate does not correspond to the previously-initiated", "+\t\t\t\t\t\t\t\t* UNC navigation so clear this state since it's no longer valid.", "+\t\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\t\tuncRedirect = null;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+", "-\t\t\t\t\t\tVariant varResult = event.arguments[0];", "+\t\t\t\t\t\tVariant varResult = event.arguments[1];", "+\t\t\t\t\t\tString url = varResult.getString();", "+\t\t\t\t\t\tif (uncRedirect != null) {", "+\t\t\t\t\t\t\tif (uncRedirect.equals(url)) {", "+\t\t\t\t\t\t\t\t/* full UNC path has been successfully navigated */", "+\t\t\t\t\t\t\t\tuncRedirect = null;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (uncRedirect.startsWith(url)) {", "+\t\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t\t* UNC first segment has been successfully navigated,", "+\t\t\t\t\t\t\t\t* now redirect to the full UNC path.", "+\t\t\t\t\t\t\t\t*/ ", "+\t\t\t\t\t\t\t\tnavigate(uncRedirect, true);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tuncRedirect = null;", "+\t\t\t\t\t\t}", "+", "+\t\t\t\t\t\tvarResult = event.arguments[0];", "-\t\t\t\t\t\tvarResult = event.arguments[1];", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tcase NavigateError: {", "+\t\t\t\t\t\tif (uncRedirect != null) {", "+\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t* This is the second error attempting to reach this UNC path, so", "+\t\t\t\t\t\t\t* it does not exist.  Don't override the default error handling.", "+\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\tuncRedirect = null;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tVariant varResult = event.arguments[1];", "+\t\t\t\t\t\tfinal String url = varResult.getString();", "+\t\t\t\t\t\tif (url.startsWith(\"\\\\\\\\\")) { //$NON-NLS-1$", "+\t\t\t\t\t\t\tvarResult = event.arguments[3];", "+\t\t\t\t\t\t\tint statusCode = varResult.getInt();", "+\t\t\t\t\t\t\tif (statusCode == INET_E_RESOURCE_NOT_FOUND) {", "+\t\t\t\t\t\t\t\tint index = url.indexOf('\\\\', 2);", "+\t\t\t\t\t\t\t\tif (index != -1) {", "+\t\t\t\t\t\t\t\t\tfinal String host = url.substring(0, index);", "+\t\t\t\t\t\t\t\t\tVariant cancel = event.arguments[4];", "+\t\t\t\t\t\t\t\t\tif (cancel != null) {", "+\t\t\t\t\t\t\t\t\t\tint /*long*/ pCancel = cancel.getByRef();", "+\t\t\t\t\t\t\t\t\t\tCOM.MoveMemory(pCancel, new short[] {COM.VARIANT_TRUE}, 2);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tbrowser.getDisplay().asyncExec(new Runnable() {", "+\t\t\t\t\t\t\t\t\t\tpublic void run() {", "+\t\t\t\t\t\t\t\t\t\t\tif (browser.isDisposed()) return;", "+\t\t\t\t\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t\t\t\t\t* Feature of IE.  When a UNC path ends with a '\\' character IE", "+\t\t\t\t\t\t\t\t\t\t\t* drops this character when providing the path as an argument", "+\t\t\t\t\t\t\t\t\t\t\t* to some IE listeners.  Remove this character here too in", "+\t\t\t\t\t\t\t\t\t\t\t* order to match these other listener argument values.", "+\t\t\t\t\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\t\t\t\t\tif (url.endsWith(\"\\\\\")) { //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\t\t\t\tuncRedirect = url.substring(0, url.length() - 1);", "+\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\tuncRedirect = url;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tnavigate(host, true);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t});", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\tsite.addEventListener(NavigateError, oleListener);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "beeaba216293f83c5b8d9639209d8171", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "62b114225776c09f8a6570dde053dd94358f28d9", "commitAfterChange": "88d0b371a82ed8f1081c2933382ac5c0ad56880e", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  void computeRuns ()", "signatureAfterChange": "  void computeRuns ()", "diff": ["-\tbyte[] buffer = Converter.wcsToMbcs(null, getSegmentsText(), false);", "+\tString segmentsText = getSegmentsText();", "+\tbyte[] buffer = Converter.wcsToMbcs(null, segmentsText, false);", "-\tif (styles.length == 2 && styles[0].style == null) return;", "+\tif (styles.length == 2 && styles[0].style == null && ascent == -1 && descent == -1) return;", "-\tPangoAttribute attribute = new PangoAttribute();\t", "+\tPangoAttribute attribute = new PangoAttribute();", "+\tif ((ascent != -1  || descent != -1) && segmentsText.length() > 0) {", "+\t\tint /*long*/ iter = OS.pango_layout_get_iter(layout);", "+\t\tif (iter == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\tPangoRectangle rect = new PangoRectangle();", "+\t\tif (ascent != -1) rect.y =  -(ascent  * OS.PANGO_SCALE);", "+\t\trect.height = (Math.max(0, ascent) + Math.max(0, descent)) * OS.PANGO_SCALE;", "+\t\tint lineCount = OS.pango_layout_get_line_count(layout);", "+\t\tchar[] chars = new char[segmentsText.length() + lineCount];", "+\t\tint oldPos = 0, count = 0;", "+\t\tdo {", "+\t\t\tint /*long*/ attr = OS.pango_attr_shape_new (rect, rect);", "+\t\t\tOS.memmove (attribute, attr, PangoAttribute.sizeof);", "+\t\t\tint bytePos = OS.pango_layout_iter_get_index(iter);", "+\t\t\tattribute.start_index = bytePos + (count * 3);", "+\t\t\tattribute.end_index = bytePos+ 3 + (count * 3);", "+\t\t\tOS.memmove (attr, attribute, PangoAttribute.sizeof);", "+\t\t\tOS.pango_attr_list_insert(attrList, attr);", "+\t\t\tint pos = (int)/*64*/OS.g_utf8_pointer_to_offset(ptr, ptr + bytePos);", "+\t\t\tchars[pos + count] = OBJECT_REPLACEMENT_CHARACTER;", "+\t\t\tsegmentsText.getChars(oldPos, pos, chars,  oldPos + count);", "+\t\t\toldPos = pos;", "+\t\t\tcount++;", "+\t\t} while (OS.pango_layout_iter_next_line(iter));", "+\t\tOS.pango_layout_iter_free (iter);", "+\t\tsegmentsText.getChars(oldPos, segmentsText.length(), chars,  oldPos + count);", "+\t\tbuffer = Converter.wcsToMbcs(null, chars, false);", "+\t\tOS.pango_layout_set_text (layout, buffer, buffer.length);", "+\t\tptr = OS.pango_layout_get_text(layout);", "+\t}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e56a7dabac9e6268d81423a13efd577a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Tracker.java", "commitBeforeChange": "9a7a23f05c644cb62fddfb0991fcc9f64f0514a5", "commitAfterChange": "37c77a940ee262e41e745195024a2482e016f15b", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r public boolean open ()", "signatureAfterChange": "\r public boolean open ()", "diff": ["-\t* Create a transparent window that fills the whole screen\r", "-\t* so that we will get mouse/keyboard events that occur\r", "-\t* outside of our visible windows (ie.- \"over\" the desktop)\r", "+\t* If this tracker is being created without a mouse drag then\r", "+\t* we need to create a transparent window that fills the screen\r", "+\t* in order to get all mouse/keyboard events that occur\r", "+\t* outside of our visible windows (ie.- over the desktop).\r", "-\tint displayWidth = OS.GetSystemMetrics (OS.SM_CXSCREEN);\r", "-\tint displayHeight = OS.GetSystemMetrics (OS.SM_CYSCREEN);\r", "-//\tint hwndTransparent = OS.CreateWindowEx (\r", "-//\t\tOS.WS_EX_TRANSPARENT,\r", "-//\t\tdisplay.windowClass,\r", "-//\t\tnull,\r", "-//\t\tOS.WS_POPUP | OS.WS_VISIBLE,\r", "-//\t\t0,0,\r", "-//\t\tdisplayWidth, displayHeight,\r", "-//\t\t0,\r", "-//\t\t0,\r", "-//\t\tOS.GetModuleHandle (null),\r", "-//\t\tnull);\r", "+\tint hwndTransparent = 0;\r", "+\tCallback newProc = null;\r", "+\tboolean mouseDown = OS.GetKeyState(OS.VK_LBUTTON) < 0;\r", "+\tif (!mouseDown) {\r", "+\t\tint width = OS.GetSystemMetrics (OS.SM_CXSCREEN);\r", "+\t\tint height = OS.GetSystemMetrics (OS.SM_CYSCREEN);\r", "+\t\thwndTransparent = OS.CreateWindowEx (\r", "+\t\t\tOS.WS_EX_TRANSPARENT,\r", "+\t\t\tdisplay.windowClass,\r", "+\t\t\tnull,\r", "+\t\t\tOS.WS_POPUP | OS.WS_VISIBLE,\r", "+\t\t\t0, 0,\r", "+\t\t\twidth, height,\r", "+\t\t\t0,\r", "+\t\t\t0,\r", "+\t\t\tOS.GetModuleHandle (null),\r", "+\t\t\tnull);\r", "+\t\tfinal int oldProc = OS.GetWindowLong (hwndTransparent, OS.GWL_WNDPROC);\r", "+\t\tObject windowProc = new Object () {\r", "+\t\t\tpublic int windowProc (int hwnd, int msg, int wParam, int lParam) {\r", "+\t\t\t\tswitch (msg) {\r", "+\t\t\t\t\tcase OS.WM_MOVE:\r", "+\t\t\t\t\t/*\r", "+\t\t\t\t\t* We typically do not want to answer that the transparent window is\r", "+\t\t\t\t\t* transparent to hits since doing so negates the effect of having it\r", "+\t\t\t\t\t* to grab events.  However, clients of the tracker should not be aware\r", "+\t\t\t\t\t* of this transparent window.  Therefore if there is a hit query\r", "+\t\t\t\t\t* performed as a result of client code then answer that the transparent\r", "+\t\t\t\t\t* window is transparent to hits so that its existence will not impact\r", "+\t\t\t\t\t* the client.\r", "+\t\t\t\t\t*/\r", "+\t\t\t\t\tcase OS.WM_NCHITTEST:\r", "+\t\t\t\t\t\tif (inEvent) {\r", "+\t\t\t\t\t\t\treturn OS.HTTRANSPARENT;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase OS.WM_SIZE:\r", "+\t\t\t\t\t\tOS.InvalidateRect (hwnd, null, true);\r", "+\t\t\t\t\t\tOS.UpdateWindow (hwnd);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase OS.WM_SETCURSOR:\r", "+\t\t\t\t\t\tif (cursor != 0) {\r", "+\t\t\t\t\t\t\tOS.SetCursor(cursor);\r", "+\t\t\t\t\t\t\treturn LRESULT.ONE.value;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\treturn OS.CallWindowProc (oldProc, hwnd, msg, wParam, lParam);\r", "+\t\t\t}\r", "+\t\t};\r", "+\t\tnewProc = new Callback (windowProc, \"windowProc\", 4);\r", "+\t\tOS.SetWindowLong (hwndTransparent, OS.GWL_WNDPROC, newProc.getAddress ());\r", "+\t}\r", "+\r", "-\tif ((style & SWT.MENU) != 0) {\r", "+\tif (mouseDown) {\r", "+\t\tPOINT pt = new POINT ();\r", "+\t\tOS.GetCursorPos (pt);\r", "+\t\tcursorPos = new Point (pt.x, pt.y);\r", "+\t} else {\r", "-\t} else {\r", "-\t\tPOINT pt = new POINT ();\r", "-\t\tOS.GetCursorPos (pt);\r", "-\t\tcursorPos = new Point (pt.x, pt.y);\r", "+\t\r", "-\tRectangle screenBounds = new Rectangle (0, 0, displayWidth, displayHeight);\r", "-\t\t\t\tsetCursor ();\r", "-\t\t\t\t\t\tresizeRectangles (newX - oldX, newY - oldY, screenBounds);\r", "-\t\t\t\t\t\tsendEvent (SWT.Resize, event);\r", "+\t\t\t\t\t\tresizeRectangles (newX - oldX, newY - oldY);\r", "+\t\t\t\t\t\tinEvent = true;\r", "+\t\t\t\t\t\tsendEvent (SWT.Resize, event);\r", "-\t\t\t\t\t\tmoveRectangles (newX - oldX, newY - oldY, screenBounds);\r", "+\t\t\t\t\t\tmoveRectangles (newX - oldX, newY - oldY);\r", "+\t\t\t\t\t\tinEvent = true;\r", "+\t\t\t\t\tinEvent = false;\r", "-\t\t\t\tsetCursor ();\r", "-\t\t\t\t\t\tresizeRectangles (xChange, yChange, screenBounds);\r", "-\t\t\t\t\t\tsendEvent (SWT.Resize, event);\r", "+\t\t\t\t\t\tresizeRectangles (xChange, yChange);\r", "+\t\t\t\t\t\tinEvent = true;\r", "+\t\t\t\t\t\tsendEvent (SWT.Resize, event);\r", "-\t\t\t\t\t\tmoveRectangles (xChange, yChange, screenBounds);\r", "-\t\t\t\t\t\tsendEvent (SWT.Move, event);\r", "+\t\t\t\t\t\tmoveRectangles (xChange, yChange);\r", "+\t\t\t\t\t\tinEvent = true;\r", "+\t\t\t\t\t\tsendEvent (SWT.Move, event);\r", "+\t\t\t\t\tinEvent = false;\r", "-//\tOS.DestroyWindow (hwndTransparent);\r", "+\t/*\r", "+\t* Cleanup: If a transparent window was created in order to capture events then\r", "+\t* destroy it and its callback object now.\r", "+\t*/\r", "+\tif (hwndTransparent != 0) {\r", "+\t\tOS.DestroyWindow (hwndTransparent);\r", "+\t}\r", "+\tif (newProc != null) {\r", "+\t\tnewProc.dispose();\r", "+\t}\r", "+\t/*\r", "+\t* Cleanup: If this tracker was resizing then the last cursor that it created\r", "+\t* needs to be destroyed.\r", "+\t*/\r", "+\tif ((style & SWT.RESIZE) != 0 && cursor != 0) {\r", "+\t\tOS.DestroyCursor (cursor);\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dc0ebda60e34de245a829f6d7a563d18", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "fc59b19065f60bbcb485c797c7ff1561e9bb73f6", "commitAfterChange": "6079b58ee7045c020f911594524a48a4bc5cb888", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  void createSurface()", "signatureAfterChange": "  void createSurface()", "diff": ["-\tif (mask != 0) {", "+\t/* Generate the mask if necessary. */", "+\tif (transparentPixel != -1) createMask();", "+\tif (mask != 0 || alpha != -1 || alphaData != null) {", "-\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "-\t\tint /*long*/ gdkImagePtr = OS.gdk_drawable_get_image(mask, 0, 0, width, height);", "+\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);\t\t", "-\t\tfor (int y=0; y<height; y++) {", "-\t\t\tint /*long*/ offset = pixels + (y * stride);", "-\t\t\tOS.memmove(line, offset, stride);", "-\t\t\tfor (int x=0; x<width; x++) {", "-\t\t\t\tint offset1 = x * 4;", "-\t\t\t\tif (gdkImagePtr != 0) {", "-\t\t\t\t\tif (OS.gdk_image_get_pixel(gdkImagePtr, x, y) == 0) {", "-\t\t\t\t\t\tline[offset1+3] = 0;", "+\t\tif (mask != 0) {", "+\t\t\tint /*long*/ maskPixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, false, 8, w[0], h[0]);", "+\t\t\tif (maskPixbuf == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\t\tOS.gdk_pixbuf_get_from_drawable(maskPixbuf, mask, 0, 0, 0, 0, 0, w[0], h[0]);", "+\t\t\tint maskStride = OS.gdk_pixbuf_get_rowstride(maskPixbuf);", "+\t\t\tint /*long*/ maskPixels = OS.gdk_pixbuf_get_pixels(maskPixbuf);", "+\t\t\tbyte[] maskLine = new byte[maskStride];", "+\t\t\tfor (int y=0; y<height; y++) {", "+\t\t\t\tint /*long*/ offset = pixels + (y * stride);", "+\t\t\t\tOS.memmove(line, offset, stride);", "+\t\t\t\tint /*long*/ maskOffset = maskPixels + (y * maskStride);", "+\t\t\t\tOS.memmove(maskLine, maskOffset, maskStride);", "+\t\t\t\tfor (int x=0; x<width; x++) {", "+\t\t\t\t\tint offset1 = x * 4;", "+\t\t\t\t\tif (maskLine[x * 3] == 0) {", "+\t\t\t\t\t\tline[offset1 + 3] = 0;", "+\t\t\t\t\tbyte temp = line[offset1];", "+\t\t\t\t\tline[offset1] = line[offset1 + 2];", "+\t\t\t\t\tline[offset1 + 2] = temp;", "-\t\t\t\tbyte temp = line[offset1];", "-\t\t\t\tline[offset1] = line[offset1 + 2];", "-\t\t\t\tline[offset1 + 2] = temp;", "+\t\t\t\tOS.memmove(offset, line, stride);", "-\t\t\tOS.memmove(offset, line, stride);", "+\t\t\tOS.g_object_unref(maskPixbuf);", "+\t\t} else if (alpha != -1) {", "+\t\t\tfor (int y=0; y<height; y++) {", "+\t\t\t\tint /*long*/ offset = pixels + (y * stride);", "+\t\t\t\tOS.memmove(line, offset, stride);", "+\t\t\t\tfor (int x=0; x<width; x++) {", "+\t\t\t\t\tint offset1 = x * 4;", "+\t\t\t\t\tline[offset1+3] = (byte)alpha;", "+\t\t\t\t\tbyte temp = line[offset1];", "+\t\t\t\t\tline[offset1] = line[offset1 + 2];", "+\t\t\t\t\tline[offset1 + 2] = temp;", "+\t\t\t\t}", "+\t\t\t\tOS.memmove(offset, line, stride);", "+\t\t\t}", "+\t\t} else {", "+\t\t\tfor (int y = 0; y < h [0]; y++) {", "+\t\t\t\tint /*long*/ offset = pixels + (y * stride);", "+\t\t\t\tOS.memmove (line, offset, stride);", "+\t\t\t\tfor (int x = 0; x < w [0]; x++) {", "+\t\t\t\t\tint offset1 = x * 4;", "+\t\t\t\t\tline[offset1+3] = alphaData [y*w [0]+x];", "+\t\t\t\t\tbyte temp = line[offset1];", "+\t\t\t\t\tline[offset1] = line[offset1 + 2];", "+\t\t\t\t\tline[offset1 + 2] = temp;", "+\t\t\t\t}", "+\t\t\t\tOS.memmove (offset, line, stride);", "+\t\t\t}", "-\t\tif (gdkImagePtr != 0) OS.g_object_unref(gdkImagePtr);", "-\t\treturn;", "-\t}\t", "-\tint /*long*/ xDisplay = OS.GDK_DISPLAY();", "-\tint /*long*/ xDrawable = OS.GDK_PIXMAP_XID(pixmap);", "-\tint /*long*/ xVisual = OS.gdk_x11_visual_get_xvisual(OS.gdk_visual_get_system());", "-\tint /*long*/ xColormap = OS.gdk_x11_colormap_get_xcolormap(OS.gdk_colormap_get_system());", "-\tsurface = Cairo.cairo_xlib_surface_create(xDisplay, xDrawable, xVisual, 0, xColormap);", "+\t} else {", "+\t\tint /*long*/ xDisplay = OS.GDK_DISPLAY();", "+\t\tint /*long*/ xDrawable = OS.GDK_PIXMAP_XID(pixmap);", "+\t\tint /*long*/ xVisual = OS.gdk_x11_visual_get_xvisual(OS.gdk_visual_get_system());", "+\t\tint /*long*/ xColormap = OS.gdk_x11_colormap_get_xcolormap(OS.gdk_colormap_get_system());", "+\t\tsurface = Cairo.cairo_xlib_surface_create(xDisplay, xDrawable, xVisual, 0, xColormap);", "+\t}", "+\t/* Destroy the image mask if the there is a GC created on the image */", "+\tif (transparentPixel != -1 && memGC != null) destroyMask();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dc204c2a8b291f4c48e8b447e61bef75", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "374a9aef6d3cdbe23142c7622f439f5425ecaa80", "commitAfterChange": "ed307d3f65dabf3aa5aefbc1cbd79da8679af838", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 95, "signatureBeforeChange": " boolean filters (int eventType)", "signatureAfterChange": " \t\t\t \tprivate boolean handleContentClick(MacEvent me, int whichWindow)", "diff": ["-}", "-boolean filters (int eventType) {", "-\tif (filterTable == null) return false;", "-\treturn filterTable.hooks (eventType);", "+\t\t\t", "+\tprivate boolean handleContentClick(MacEvent me, int whichWindow) {", "+\t", "+\t\tMacPoint where= me.getWhere();", "+\t\tMacPoint globalPos= me.getWhere();", "+\t\t\t\t", "+\t\tOS.QDGlobalToLocalPoint(OS.GetWindowPort(whichWindow), where.getData());", "+\t\t", "+\t\tshort[] cpart= new short[1];\t\t", "+\t\tint whichControl= 0;", "+\t\tif (MacUtil.HIVIEW) {", "+\t\t\tint[] ov= new int[1];", "+\t\t\tint root= OS.HIViewGetRoot(whichWindow);", "+\t\t\tOS.HIViewGetViewForMouseEvent(root, me.getEventRef(), ov);", "+\t\t\twhichControl= ov[0];", "+\t\t} else {", "+\t\t\twhichControl= MacUtil.findControlUnderMouse(where, whichWindow, cpart);\t\t\t\t", "+\t\t}", "+\t\t", "+\t\t// focus change", "+\t\tsetMacFocusHandle(whichWindow, whichControl);", "+\t\t\t\t\t\t\t\t", "+\t\tif (whichControl != 0) {", "+\t\t", "+\t\t\t// deal with the context menu", "+\t\t\tWidget wc= WidgetTable.get(whichControl);", "+\t\t\tif (wc instanceof Control) {", "+\t\t\t\tMenu cm= ((Control)wc).getMenu();\t// is a context menu installed?", "+\t\t\t\tif (cm != null && me.isShowContextualMenuClick()) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tfInContextMenu= true;", "+\t\t\t\t\t\t// AW: not ready for primetime", "+\t\t\t\t\t\t// OS.ContextualMenuSelect(cm.handle, globalPos.getData(), new short[1], new short[1]);", "+\t\t\t\t\t\tOS.PopUpMenuSelect(cm.handle, (short)globalPos.getY(), (short)globalPos.getX(), (short)1);", "+\t\t\t\t\t} finally {", "+\t\t\t\t\t\tfInContextMenu= false;", "+\t\t\t\t\t}", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\tif (MacUtil.HIVIEW) {", "+\t\t\t\tOS.HIViewClick(whichControl, me.getEventRef());", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t", "+\t\t\tswitch (cpart[0]) {", "+\t\t\tcase 0:", "+\t\t\t\tbreak;", "+", "+\t\t\tcase 111:\t// User pane", "+\t\t\t\tfTrackedControl= whichControl;\t// starts mouse tracking", "+\t\t\t\twindowProc(whichControl, SWT.MouseDown, new MacMouseEvent(me));", "+\t\t\t\tbreak;", "+", "+\t\t\tcase 112:\t// User pane", "+\t\t\t\twindowProc(whichControl, SWT.MouseDown, new MacMouseEvent(me));", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tdefault:", "+\t\t\t\twindowProc(whichControl, SWT.MouseDown, new MacMouseEvent(me));", "+\t\t\t\t", "+\t\t\t\tif (MacUtil.HIVIEW) {", "+\t\t\t\t\t// AW: Jaguar:", "+\t\t\t\t\tOS.HIViewClick(whichControl, me.getEventRef());", "+\t\t\t\t} else {", "+\t\t\t\t\tint cpart2= OS.HandleControlClick(whichControl, where.getData(), me.getModifiers(), -1);", "+\t\t\t\t\tif (cpart2 != 0) {", "+\t\t\t\t\t\twindowProc(whichControl, SWT.Selection, new MacControlEvent(whichControl, cpart2, false));", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82dfefa2fa9d861ead988f8e2004492a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/motif/org/eclipse/swt/widgets/FileDialog.java", "commitBeforeChange": "f13bd9400fedc174bad61b02e297f54dcefc8695", "commitAfterChange": "dc7272eeeee95074eb6b23ed3ac3ab956c23492c", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r void extractValues()", "signatureAfterChange": "\r void extractValues()", "diff": ["-\tint [] argList2 = {OS.XmNdirectory, 0, OS.XmNdirSpec, 0};\r", "-\tOS.XtGetValues (dialog, argList2, argList2.length / 2);\r", "+\tint [] argList = {OS.XmNdirectory, 0, OS.XmNdirSpec, 0};\r", "+\tOS.XtGetValues (dialog, argList, argList.length / 2);\r", "-\tint xmString3 = argList2 [1];\r", "+\tint xmString1 = argList [1];\r", "-\t\txmString3,\r", "+\t\txmString1,\r", "-\tOS.XmStringFree (xmString3);\r", "+\tOS.XmStringFree (xmString1);\r", "+\tif (filterPath.endsWith(\"/\")) {\r", "+\t\tfilterPath = filterPath.substring (0, filterPath.length() - 1);\r", "+\t}\r", "-\tint xmString4 = argList2 [3];\r", "+\tint xmString2 = argList [3];\r", "-\t\txmString4,\r", "+\t\txmString2,\r", "-\t\tfullPath = new String (Converter.mbcsToWcs (null, buffer));\r", "+\t\tfullPath = new String (Converter.mbcsToWcs (null, buffer)).trim();\r", "-\tOS.XmStringFree (xmString4);\r", "+\tOS.XmStringFree (xmString2);\r", "-\tint length = filterPath.length ();\r", "-\tif (length != 0 && filterPath.charAt (length - 1) == '/') {\r", "-\t\tfilterPath = filterPath.substring (0, length - 1);\r", "+\tif ((style & SWT.MULTI) != 0) {\r", "+\t\tint fileList = OS.XmFileSelectionBoxGetChild (dialog, OS.XmDIALOG_LIST);\r", "+\t\tif (fileList == 0) return;\r", "+\t\tint [] argList2 = {OS.XmNselectedItems, 0, OS.XmNselectedItemCount, 0};\r", "+\t\tOS.XtGetValues (fileList, argList2, argList2.length / 2);\r", "+\t\tint items = argList2 [1], itemCount = argList2 [3];\r", "+\t\tint [] buffer1 = new int [1];\r", "+\t\tfileNames = new String [itemCount];\r", "+\t\tboolean match = false;\r", "+\t\tfor (int i = 0; i < itemCount; i++) {\r", "+\t\t\tOS.memmove (buffer1, items, 4);\r", "+\t\t\tptr = buffer1 [0];\r", "+\t\t\tint address = OS.XmStringUnparse (\r", "+\t\t\t\tptr,\r", "+\t\t\t\tnull,\r", "+\t\t\t\tOS.XmCHARSET_TEXT,\r", "+\t\t\t\tOS.XmCHARSET_TEXT,\r", "+\t\t\t\tnull,\r", "+\t\t\t\t0,\r", "+\t\t\t\tOS.XmOUTPUT_ALL);\r", "+\t\t\tif (address == 0) error (SWT.ERROR_CANNOT_GET_ITEM);\r", "+\t\t\tint length = OS.strlen (address);\r", "+\t\t\tbyte [] buffer = new byte [length];\r", "+\t\t\tOS.memmove (buffer, address, length);\r", "+\t\t\tOS.XtFree (address);\r", "+\t\t\t/* Use the character encoding for the default locale */\r", "+\t\t\tString fullFilename = new String (Converter.mbcsToWcs (null, buffer));\r", "+\t\t\tint index = fullFilename.lastIndexOf ('/');\r", "+\t\t\tfileNames [i] = fullFilename.substring (index + 1, fullFilename.length ());\r", "+\t\t\titems += 4;\r", "+\t\t\tif (fullFilename.equals(fullPath)) match = true;\r", "+\t\t}\r", "+\t\tif (!match) {\r", "+\t\t\t/* The user has modified the text field such that it doesn't match any\r", "+\t\t\t * of the selected files, so use this value instead\r", "+\t\t\t */\r", "+\t\t\tfileNames = new String [1];\r", "+\t\t\tint index = fullPath.lastIndexOf ('/');\r", "+\t\t\tfileNames [0] = fullPath.substring (index + 1, fullPath.length ());\r", "+\t\t}\r", "+\t} else {\r", "-\t\tfileName = fullPath.substring (index + 1, fullPath.length ());\r", "+\t\tfileNames [0] = fullPath.substring (index + 1, fullPath.length ());\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "10cd1cd25f6165a34a4ac382c8c53c98", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/graphics/Image.java", "commitBeforeChange": "4b21419a582289fce72ef15bfe70049085b3c772", "commitAfterChange": "b2343fc03843d983cdbcf528d75f7e9524819b07", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  void createSurface()", "signatureAfterChange": "  void createSurface()", "diff": ["+\tif (mask != 0) {", "+\t\tint[] w = new int[1], h = new int[1];", "+\t \tOS.gdk_drawable_get_size(pixmap, w, h);", "+\t \tint width = w[0], height = h[0]; \t", "+\t \tint /*long*/ pixbuf = OS.gdk_pixbuf_new(OS.GDK_COLORSPACE_RGB, true, 8, width, height);", "+\t\tif (pixbuf == 0) SWT.error(SWT.ERROR_NO_HANDLES);", "+\t\tint /*long*/ colormap = OS.gdk_colormap_get_system();", "+\t\tOS.gdk_pixbuf_get_from_drawable(pixbuf, pixmap, colormap, 0, 0, 0, 0, width, height);", "+\t\tint stride = OS.gdk_pixbuf_get_rowstride(pixbuf);", "+\t\tint /*long*/ pixels = OS.gdk_pixbuf_get_pixels(pixbuf);", "+\t\tint /*long*/ gdkImagePtr = OS.gdk_drawable_get_image(mask, 0, 0, width, height);", "+\t\tbyte[] line = new byte[stride];", "+\t\tfor (int y=0; y<height; y++) {", "+\t\t\tint /*long*/ offset = pixels + (y * stride);", "+\t\t\tOS.memmove(line, offset, stride);", "+\t\t\tfor (int x=0; x<width; x++) {", "+\t\t\t\tint offset1 = x * 4;", "+\t\t\t\tif (gdkImagePtr != 0) {", "+\t\t\t\t\tif (OS.gdk_image_get_pixel(gdkImagePtr, x, y) == 0) {", "+\t\t\t\t\t\tline[offset1+3] = 0;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbyte temp = line[offset1];", "+\t\t\t\tline[offset1] = line[offset1 + 2];", "+\t\t\t\tline[offset1 + 2] = temp;", "+\t\t\t}", "+\t\t\tOS.memmove(offset, line, stride);", "+\t\t}", "+\t\tif (gdkImagePtr != 0) OS.g_object_unref(gdkImagePtr);", "+\t\tsurfaceData = OS.g_malloc(stride * height);", "+\t\tOS.memmove(surfaceData, pixels, stride * height);", "+\t\tsurface = Cairo.cairo_surface_create_for_image(surfaceData, Cairo.CAIRO_FORMAT_ARGB32, width, height, stride);", "+\t\tOS.g_object_unref(pixbuf);", "+\t\treturn;", "+\t}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9022ec13f53fa5e4dffbead6d3207fa4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/graphics/TextLayout.java", "commitBeforeChange": "dbb867f00ae35fdce66baf48ea942146496b4f1b", "commitAfterChange": "a79b48a96506f5d7be70bc5cf8ee067cbbd5d771", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  void drawLines(boolean advance, int graphics, int x, int y, StyleItem run, int color)", "signatureAfterChange": "  void drawLines(boolean advance, int graphics, int x, int y, StyleItem run, int color, boolean selection)", "diff": ["-void drawLines(boolean advance, int /*long*/ graphics, int x, int y, StyleItem run, int /*long*/ color) {", "+void drawLines(boolean advance, int /*long*/ graphics, int x, int y, StyleItem run, int /*long*/ color, boolean selection) {", "+\t\tint /*long*/ brush = color;", "-\t\t\tGdip.Graphics_FillRectangle(graphics, color, x, underlineY, run.width, run.underlineThickness);", "+\t\t\tif (!selection && run.style.underlineColor != null) {", "+\t\t\t\tint c = run.style.underlineColor.handle;", "+\t\t\t\tint argb = (0xFF << 24) | ((c >> 16) & 0xFF) | (c & 0xFF00) | ((c & 0xFF) << 16);", "+\t\t\t\tint /*long*/ gdiColor = Gdip.Color_new(argb); ", "+\t\t\t\tbrush = Gdip.SolidBrush_new(gdiColor);", "+\t\t\t\tGdip.Color_delete(gdiColor);", "+\t\t\t}", "+\t\t\tGdip.Graphics_FillRectangle(graphics, brush, x, underlineY, run.width, run.underlineThickness);", "+\t\t\tif (brush != color) Gdip.SolidBrush_delete(brush);", "-\t\t\tGdip.Graphics_FillRectangle(graphics, color, x, strikeoutY, run.width, run.strikeoutThickness);", "+\t\t\tif (!selection && run.style.strikeoutColor != null) {", "+\t\t\t\tint c = run.style.strikeoutColor.handle;", "+\t\t\t\tint argb = (0xFF << 24) | ((c >> 16) & 0xFF) | (c & 0xFF00) | ((c & 0xFF) << 16);", "+\t\t\t\tint /*long*/ gdiColor = Gdip.Color_new(argb); ", "+\t\t\t\tbrush = Gdip.SolidBrush_new(gdiColor);", "+\t\t\t\tGdip.Color_delete(gdiColor);", "+\t\t\t}", "+\t\t\tGdip.Graphics_FillRectangle(graphics, brush, x, strikeoutY, run.width, run.strikeoutThickness);", "+\t\t\tif (brush != color) Gdip.SolidBrush_delete(brush);", "-\t\tint /*long*/ brush = OS.CreateSolidBrush((int)/*64*/color);", "+\t\tint colorRefUnderline = (int)/*64*/color;", "+\t\tint colorRefStrikeout = (int)/*64*/color;", "+\t\tint /*long*/ brushUnderline = 0;", "+\t\tint /*long*/ brushStrikeout = 0;", "+\t\t\tif (!selection && run.style.underlineColor != null) {", "+\t\t\t\tcolorRefUnderline = run.style.underlineColor.handle;", "+\t\t\t}", "+\t\t\tbrushUnderline = OS.CreateSolidBrush(colorRefUnderline);", "-\t\t\tOS.FillRect(graphics, rect, brush);", "+\t\t\tOS.FillRect(graphics, rect, brushUnderline);", "+\t\t\tif (!selection && run.style.strikeoutColor != null) {", "+\t\t\t\tcolorRefStrikeout = run.style.strikeoutColor.handle;", "+\t\t\t}", "+\t\t\tif (brushUnderline != 0 && colorRefStrikeout == colorRefUnderline) {", "+\t\t\t\tbrushStrikeout = brushUnderline;", "+\t\t\t} else {", "+\t\t\t\tbrushStrikeout = OS.CreateSolidBrush(colorRefStrikeout);", "+\t\t\t}", "-\t\t\tOS.FillRect(graphics, rect, brush);", "+\t\t\tOS.FillRect(graphics, rect, brushStrikeout);", "-\t\tOS.DeleteObject(brush);", "+\t\tif (brushUnderline != 0) OS.DeleteObject(brushUnderline);", "+\t\tif (brushStrikeout != 0 && brushStrikeout != brushUnderline) OS.DeleteObject(brushStrikeout);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "25aa08275f8b6f017ab5775bd4986e1d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Button.java", "commitBeforeChange": "c926aa683b725b279c6c7318e19d80650c45580f", "commitAfterChange": "35e1ba894deda696191ae79f0f2eca2ead117007", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  void _setImage (Image image)", "signatureAfterChange": "  void _setImage (Image image)", "diff": ["+\t\t\t", "+\t\t\t/*", "+\t\t\t* Feature in Windows.  The button control mirrors its image when the", "+\t\t\t* flag WS_EX_LAYOUTRTL is set. This behaviour is not desirable in SWT.", "+\t\t\t* The fix is to set a mirrored version of real image in the button.", "+\t\t\t*/", "+\t\t\tif ((style & SWT.RIGHT_TO_LEFT) != 0) {", "+\t\t\t\tif (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (4, 10)) {", "+\t\t\t\t\tRectangle rect = image.getBounds ();", "+\t\t\t\t\tint hDC = OS.GetDC (handle);", "+\t\t\t\t\tint dstHdc = OS.CreateCompatibleDC (hDC);", "+\t\t\t\t\tint hBitmap = OS.CreateCompatibleBitmap (hDC, rect.width, rect.height);", "+\t\t\t\t\tint oldBitmap = OS.SelectObject (dstHdc, hBitmap);", "+\t\t\t\t\tOS.SetLayout (dstHdc, OS.LAYOUT_RTL);", "+\t\t\t\t\tif (fImageType == OS.IMAGE_BITMAP) {", "+\t\t\t\t\t\tint srcHdc = OS.CreateCompatibleDC (hDC);", "+\t\t\t\t\t\tint oldSrcBitmap = OS.SelectObject (srcHdc, hImage);", "+\t\t\t\t\t\tOS.SetLayout (dstHdc, 0);", "+\t\t\t\t\t\tOS.BitBlt (dstHdc, 0, 0, rect.width, rect.height, srcHdc, 0, 0, OS.SRCCOPY);", "+\t\t\t\t\t\tOS.SelectObject (srcHdc, oldSrcBitmap);", "+\t\t\t\t\t\tOS.DeleteDC (srcHdc);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tint newBrush = OS.CreateSolidBrush (getBackgroundPixel ());", "+\t\t\t\t\t\tint oldBrush = OS.SelectObject (dstHdc, newBrush);", "+\t\t\t\t\t\tOS.PatBlt (dstHdc, 0, 0, rect.width, rect.height, OS.PATCOPY);", "+\t\t\t\t\t\tOS.DrawIconEx (dstHdc, 0, 0, hImage, 0, 0, 0, 0, OS.DI_NORMAL);", "+\t\t\t\t\t\tOS.SelectObject (dstHdc, oldBrush);", "+\t\t\t\t\t\tOS.DeleteObject (newBrush);", "+\t\t\t\t\t}", "+\t\t\t\t\tOS.SelectObject (dstHdc, oldBitmap);", "+\t\t\t\t\tOS.DeleteDC (dstHdc);", "+\t\t\t\t\tOS.ReleaseDC (handle, hDC);", "+\t\t\t\t\tif (image2 != null) image2.dispose ();", "+\t\t\t\t\timage2 = Image.win32_new (display, SWT.BITMAP, hBitmap);", "+\t\t\t\t\timageBits = OS.BS_BITMAP;", "+\t\t\t\t\tfImageType = OS.IMAGE_BITMAP;", "+\t\t\t\t\thImage = hBitmap;", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5fca08e4b0c03d47428c72ffa6791d90", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Text.java", "commitBeforeChange": "a3933d2bb483ba60f5140d79e7e6aae57a4f2172", "commitAfterChange": "6fcbcc55b433d3a443e04296f4c46435879366f4", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  int callWindowProc (int hwnd, int msg, int wParam, int lParam)", "signatureAfterChange": "  int callWindowProc (int hwnd, int msg, int wParam, int lParam)", "diff": ["-\t\t\tif (findImageControl () != null) {", "+\t\t\tboolean doubleBuffer = findImageControl () != null;", "+\t\t\tboolean drawMessage = false;", "+\t\t\tif ((style & SWT.SEARCH) != 0) {", "+\t\t\t\tif (!OS.IsWinCE && OS.WIN32_VERSION < OS.VERSION (6, 0)) {", "+\t\t\t\t\tdrawMessage = hwnd != OS.GetFocus () && OS.GetWindowTextLength (handle) == 0;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (doubleBuffer || drawMessage) {", "-\t\t\t\t\tint /*long*/ hDC = OS.CreateCompatibleDC (paintDC);", "-\t\t\t\t\tPOINT lpPoint1 = new POINT (), lpPoint2 = new POINT ();", "-\t\t\t\t\tOS.SetWindowOrgEx (hDC, ps.left, ps.top, lpPoint1);", "-\t\t\t\t\tOS.SetBrushOrgEx (hDC, ps.left, ps.top, lpPoint2);", "-\t\t\t\t\tint /*long*/ hBitmap = OS.CreateCompatibleBitmap (paintDC, width, height);", "-\t\t\t\t\tint /*long*/ hOldBitmap = OS.SelectObject (hDC, hBitmap);", "-\t\t\t\t\tRECT rect = new RECT ();", "-\t\t\t\t\tOS.SetRect (rect, ps.left, ps.top, ps.right, ps.bottom);", "-\t\t\t\t\tdrawBackground (hDC, rect);", "+\t\t\t\t\tint /*long*/ hDC = paintDC, hBitmap = 0, hOldBitmap = 0;", "+\t\t\t\t\tPOINT lpPoint1 = null, lpPoint2 = null;", "+\t\t\t\t\tif (doubleBuffer) {", "+\t\t\t\t\t\thDC = OS.CreateCompatibleDC (paintDC);", "+\t\t\t\t\t\tlpPoint1 = new POINT ();", "+\t\t\t\t\t\tlpPoint2 = new POINT ();", "+\t\t\t\t\t\tOS.SetWindowOrgEx (hDC, ps.left, ps.top, lpPoint1);", "+\t\t\t\t\t\tOS.SetBrushOrgEx (hDC, ps.left, ps.top, lpPoint2);", "+\t\t\t\t\t\thBitmap = OS.CreateCompatibleBitmap (paintDC, width, height);", "+\t\t\t\t\t\thOldBitmap = OS.SelectObject (hDC, hBitmap);", "+\t\t\t\t\t\tRECT rect = new RECT ();", "+\t\t\t\t\t\tOS.SetRect (rect, ps.left, ps.top, ps.right, ps.bottom);", "+\t\t\t\t\t\tdrawBackground (hDC, rect);", "+\t\t\t\t\t}", "+\t\t\t\t\t", "-\t\t\t\t\tOS.SetWindowOrgEx (hDC, lpPoint1.x, lpPoint1.y, null);", "-\t\t\t\t\tOS.SetBrushOrgEx (hDC, lpPoint2.x, lpPoint2.y, null);", "-\t\t\t\t\tOS.BitBlt (paintDC, ps.left, ps.top, width, height, hDC, 0, 0, OS.SRCCOPY);", "-\t\t\t\t\tOS.SelectObject (hDC, hOldBitmap);", "-\t\t\t\t\tOS.DeleteObject (hBitmap);", "-\t\t\t\t\tOS.DeleteObject (hDC);", "+\t\t\t\t\t/*", "+\t\t\t\t\t* Bug in XP. Windows does not draw the cue message on XP when", "+\t\t\t\t\t* East Asian language pack is installed. The fix is to draw", "+\t\t\t\t\t* the cue messages ourselves.", "+\t\t\t\t\t* Note:  This bug is fixed on Vista.", "+\t\t\t\t\t*/", "+\t\t\t\t\tif (drawMessage) {", "+\t\t\t\t\t\tRECT rect = new RECT();", "+\t\t\t\t\t\tOS.GetClientRect(handle, rect);", "+\t\t\t\t\t\tint margins = OS.SendMessage (handle, OS.EM_GETMARGINS, 0, 0);", "+\t\t\t\t\t\trect.left += OS.LOWORD (margins);", "+\t\t\t\t\t\trect.right -= OS.HIWORD (margins);", "+\t\t\t\t\t\tif ((style & SWT.BORDER) != 0) {", "+\t\t\t\t\t\t\trect.left++;", "+\t\t\t\t\t\t\trect.top++;", "+\t\t\t\t\t\t\trect.right--;", "+\t\t\t\t\t\t\trect.bottom--;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tTCHAR buffer = new TCHAR (getCodePage (), message, false);", "+\t\t\t\t\t\tint uFormat = OS.DT_EDITCONTROL;", "+\t\t\t\t\t\tif ((style & SWT.RIGHT_TO_LEFT) != 0) {", "+\t\t\t\t\t\t\tuFormat |= OS.DT_RTLREADING | OS.DT_RIGHT;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tint /*long*/ hFont = OS.SendMessage (hwnd, OS.WM_GETFONT, 0, 0);", "+\t\t\t\t\t\tint /*long*/ hOldFont = OS.SelectObject (hDC, hFont);", "+\t\t\t\t\t\tOS.SetTextColor (hDC, OS.GetSysColor (OS.COLOR_GRAYTEXT));", "+\t\t\t\t\t\tOS.SetBkMode (hDC, OS.TRANSPARENT);", "+\t\t\t\t\t\tOS.DrawText (hDC, buffer, buffer.length (), rect, uFormat);", "+\t\t\t\t\t\tOS.SelectObject (hDC, hOldFont);", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\tif (doubleBuffer) {", "+\t\t\t\t\t\tOS.SetWindowOrgEx (hDC, lpPoint1.x, lpPoint1.y, null);", "+\t\t\t\t\t\tOS.SetBrushOrgEx (hDC, lpPoint2.x, lpPoint2.y, null);", "+\t\t\t\t\t\tOS.BitBlt (paintDC, ps.left, ps.top, width, height, hDC, 0, 0, OS.SRCCOPY);", "+\t\t\t\t\t\tOS.SelectObject (hDC, hOldBitmap);", "+\t\t\t\t\t\tOS.DeleteObject (hBitmap);", "+\t\t\t\t\t\tOS.DeleteObject (hDC);", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7fc411a774a41412787896f316b3433", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Printing/win32/org/eclipse/swt/printing/PrintDialog.java", "commitBeforeChange": "3aa6e5684bd78cc24966d6287af63ae36f7fadb9", "commitAfterChange": "df61f40633a365af9813cad5cd26654bf724165c", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " public PrinterData open()", "signatureAfterChange": " public PrinterData open()", "diff": ["-\t* Feature in Windows.  There is no API to set the orientation of a", "-\t* file dialog.  It is always inherited from the parent.  The fix is", "-\t* to create a hidden parent and set the orientation in the hidden", "+\t* Feature in Windows.  There is no API to set the BIDI orientation", "+\t* of a print dialog.  It is always inherited from the parent.  The fix", "+\t* is to create a hidden parent and set the orientation in the hidden", "-\t/* Initialize PRINTDLG fields, including DEVMODE. */", "-\tpd.Flags = OS.PD_RETURNDEFAULT;", "-\tif (OS.PrintDlg(pd)) {", "-\t\tif (pd.hDevNames != 0) {", "-\t\t\tOS.GlobalFree(pd.hDevNames);", "-\t\t\tpd.hDevNames = 0;", "+\tboolean success = true;", "+\tif (printerData.name != null) {", "+\t\t/* Initialize PRINTDLG DEVNAMES for the specified printer. */", "+\t\tTCHAR buffer = new TCHAR(0, printerData.name, true);", "+\t\tint size = buffer.length() * TCHAR.sizeof;", "+\t\tshort[] offsets = new short[4]; // DEVNAMES (4 offsets)", "+\t\tint offsetsSize = offsets.length * 2; // 2 bytes each", "+\t\toffsets[1] = (short) offsets.length; // offset 1 points to wDeviceOffset", "+\t\tint /*long*/ hMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, offsetsSize + size);", "+\t\tint /*long*/ ptr = OS.GlobalLock(hMem);", "+\t\tOS.MoveMemory(ptr, offsets, offsetsSize);", "+\t\tOS.MoveMemory(ptr + offsetsSize, buffer, size);", "+\t\tOS.GlobalUnlock(hMem);", "+\t\tpd.hDevNames = hMem;", "+\t} else {", "+\t\t/* Initialize PRINTDLG fields, including DEVMODE, for the default printer. */", "+\t\tpd.Flags = OS.PD_RETURNDEFAULT;", "+\t\tif (success = OS.PrintDlg(pd)) {", "+\t\t\tif (pd.hDevNames != 0) {", "+\t\t\t\tOS.GlobalFree(pd.hDevNames);", "+\t\t\t\tpd.hDevNames = 0;", "+\t\t\t}", "+\t}", "+\tif (success) {", "-\t\t\tint /*long*/ lpInitData = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, devmodeData.length);", "-\t\t\tOS.MoveMemory(lpInitData, devmodeData, devmodeData.length);", "+\t\t\tint /*long*/ hMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, devmodeData.length);", "+\t\t\tint /*long*/ ptr = OS.GlobalLock(hMem);", "+\t\t\tOS.MoveMemory(ptr, devmodeData, devmodeData.length);", "+\t\t\tOS.GlobalUnlock(hMem);", "-\t\t\tpd.hDevMode = lpInitData;", "+\t\t\tpd.hDevMode = hMem;", "+\t\tif (hMem == 0) {", "+\t\t\thMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, DEVMODE.sizeof);", "+\t\t\tpd.hDevMode = hMem;", "+\t\t}", "+\t\tif (printerData.name != null) {", "+\t\t\t/* Copy PRINTDLG DEVNAMES into DEVMODE dmDeviceName (truncate if necessary). */", "+\t\t\tint max = Math.min(printerData.name.length(), OS.CCHDEVICENAME - 1);", "+\t\t\tif (OS.IsUnicode) {", "+\t\t\t\tfor (int i = 0; i < max; i++) {", "+\t\t\t\t\t((DEVMODEW) devmode).dmDeviceName[i] = printerData.name.charAt(i);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tbyte[] bytes = printerData.name.getBytes();", "+\t\t\t\tfor (int i = 0; i < max; i++) {", "+\t\t\t\t\t((DEVMODEA) devmode).dmDeviceName[i] = bytes[i];", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\tboolean success = OS.PrintDlg(pd);", "+\t\tsuccess = OS.PrintDlg(pd);", "-\t", "-\t\t\tint outputOffset = offsets[2];", "-\t\t\ti = 0;", "-\t\t\twhile (outputOffset + i < size) {", "-\t\t\t\tif (buffer.tcharAt(outputOffset + i) == 0) break;", "-\t\t\t\ti++;", "-\t\t\t}", "-\t\t\tString output = buffer.toString(outputOffset, i);", "-\t\t\t", "+", "-\t\t\tif (data.printToFile) data.fileName = output;", "+\t\t\tif (data.printToFile) data.fileName = printerData.fileName;", "+\t\t\t", "+\t\t\t/* Set PrinterData fields from DEVMODE */"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "783c563bb22163669c2e5d735e76c156", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Combo.java", "commitBeforeChange": "091e36b96050b89d4e91c682d15c94c651865f88", "commitAfterChange": "c8dd5b3da6b7a6916253d606e26594090c7a78b4", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public Point computeSize (int wHint, int hHint, boolean changed)", "signatureAfterChange": "  public Point computeSize (int wHint, int hHint, boolean changed)", "diff": ["-\treturn computeNativeSize (handle, wHint, hHint, changed);", "+\tif ((style & SWT.READ_ONLY) != 0) {", "+\t\treturn computeNativeSize (handle, wHint, hHint, changed);", "+\t}", "+\tif (wHint != SWT.DEFAULT && wHint < 0) wHint = 0;", "+\tif (hHint != SWT.DEFAULT && hHint < 0) hHint = 0;", "+\tint[] w = new int [1], h = new int [1];", "+\tOS.gtk_widget_realize (entryHandle);", "+\tint /*long*/ layout = OS.gtk_entry_get_layout (entryHandle);", "+\tOS.pango_layout_get_size (layout, w, h);", "+\tint xborder = Display.INNER_BORDER, yborder = Display.INNER_BORDER;", "+\tint /*long*/ style = OS.gtk_widget_get_style (entryHandle);", "+\txborder += OS.gtk_style_get_xthickness (style);", "+\tyborder += OS.gtk_style_get_ythickness (style);", "+\tint [] property = new int [1];", "+\tOS.gtk_widget_style_get (entryHandle, OS.interior_focus, property, 0);", "+\tif (property [0] == 0) {", "+\t\tOS.gtk_widget_style_get (entryHandle, OS.focus_line_width, property, 0);", "+\t\txborder += property [0];", "+\t\tyborder += property [0];", "+\t}", "+\tint width = OS.PANGO_PIXELS (w [0]) + xborder * 2;", "+\tint height = OS.PANGO_PIXELS (h [0]) + yborder * 2;", "+\tGtkRequisition arrowRequesition = new GtkRequisition ();", "+\tOS.gtk_widget_size_request (buttonHandle, arrowRequesition);", "+\tGtkRequisition listRequesition = new GtkRequisition ();", "+\tint /*long*/ listParent = OS.gtk_bin_get_child(popupHandle);", "+\tOS.gtk_widget_size_request (listParent, listRequesition);", "+\twidth = Math.max (listRequesition.width, width) + arrowRequesition.width;", "+\twidth = wHint == SWT.DEFAULT ? width : wHint;", "+\theight = hHint == SWT.DEFAULT ? height : hHint;", "+\treturn new Point (width, height);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "107a9b64214ff6cdea93df0c4fd1ce89", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Table.java", "commitBeforeChange": "8549b1db39ac8fd4bb7564c61e5b9a04b5efde6f", "commitAfterChange": "2b3120470b46968368044df3f94129d586bc41d5", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 64, "signatureBeforeChange": "  void setScrollWidth (boolean force)", "signatureAfterChange": "  boolean setScrollWidth (TableItem item, boolean force)", "diff": ["-void setScrollWidth (boolean force) {", "+boolean setScrollWidth (TableItem item, boolean force) {", "+\tif (ignoreRedraw) return false;", "-\t\treturn;", "+\t\treturn false;", "-\t\tOS.SendMessage (handle, OS.LVM_SETCOLUMNWIDTH, 0, OS.LVSCW_AUTOSIZE);", "-\t\t//NOT DONE", "-//\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);", "-//\t\tif ((bits & OS.LVS_OWNERDATA) != 0) {", "-//\t\t\tint width = OS.SendMessage (handle, OS.LVM_GETCOLUMNWIDTH, 0, 0);", "-//\t\t\tOS.SendMessage (handle, OS.LVM_SETCOLUMNWIDTH, 0, width + 2);", "-//\t\t}", "+\t\tif ((style & SWT.VIRTUAL) != 0) {", "+\t\t\tint newWidth = 0;", "+\t\t\tcount = OS.SendMessage (handle, OS.LVM_GETITEMCOUNT, 0, 0);", "+\t\t\tint index = 0;", "+\t\t\twhile (index < count) {", "+\t\t\t\tString string = item != null ? item.text : items [index].text;", "+\t\t\t\tif (string.length () != 0) {", "+\t\t\t\t\tTCHAR buffer = new TCHAR (getCodePage (), string, true);", "+\t\t\t\t\tnewWidth = Math.max (newWidth, OS.SendMessage (handle, OS.LVM_GETSTRINGWIDTH, 0, buffer));", "+\t\t\t\t}", "+\t\t\t\tif (item != null) break;", "+\t\t\t\tindex++;", "+\t\t\t}", "+\t\t\tint hStateList = OS.SendMessage (handle, OS.LVM_GETIMAGELIST, OS.LVSIL_STATE, 0);", "+\t\t\tif (hStateList != 0) {", "+\t\t\t\tint [] cx = new int [1], cy = new int [1];", "+\t\t\t\tOS.ImageList_GetIconSize (hStateList, cx, cy);", "+\t\t\t\tnewWidth += cx [0] + 4;", "+\t\t\t}", "+\t\t\tint hImageList = OS.SendMessage (handle, OS.LVM_GETIMAGELIST, OS.LVSIL_SMALL, 0);", "+\t\t\tif (hImageList != 0) {", "+\t\t\t\tint [] cx = new int [1], cy = new int [1];", "+\t\t\t\tOS.ImageList_GetIconSize (hImageList, cx, cy);", "+\t\t\t\tnewWidth += cx [0];", "+\t\t\t}", "+\t\t\tnewWidth += 8;", "+\t\t\tint oldWidth = OS.SendMessage (handle, OS.LVM_GETCOLUMNWIDTH, 0, 0);", "+\t\t\tif (newWidth > oldWidth) {", "+\t\t\t\tOS.SendMessage (handle, OS.LVM_SETCOLUMNWIDTH, 0, newWidth);", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t} else {", "+\t\t\t/*", "+\t\t\t* Bug in Windows.  When the table is dislaying check boxes without", "+\t\t\t* icons the width computed by LVM_SETCOLUMNWIDTH with LVSCW_AUTOSIZE", "+\t\t\t* is too small causing the longest item to be truncated with '...'.", "+\t\t\t* The fix is to increase the size by a small amount.", "+\t\t\t*/", "+\t\t\tOS.SendMessage (handle, OS.LVM_SETCOLUMNWIDTH, 0, OS.LVSCW_AUTOSIZE);", "+\t\t\tif ((style & SWT.CHECK) != 0 && imageList != null) {", "+\t\t\t\tint width = OS.SendMessage (handle, OS.LVM_GETCOLUMNWIDTH, 0, 0);", "+\t\t\t\tOS.SendMessage (handle, OS.LVM_SETCOLUMNWIDTH, 0, width + 2);", "+\t\t\t}", "+\t\t\treturn true;", "+\t\t}", "+\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ec8a1745515f34345e1a1f7115539a2", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "cc7a79cec8920b1b6175a6c2124e7f63a3823262", "commitAfterChange": "d8f34c9ec09bc11f5d7b71293f9d378725f3146c", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 9, "signatureBeforeChange": "  void removeColumn ()", "signatureAfterChange": " void createColumn (TreeColumn column, int index)", "diff": ["+}", "+void createColumn (TreeColumn column, int index) {", "+/*", "+* Bug in ATK. For some reason, ATK segments fault if ", "+* the GtkTreeView has a column and does not have items.", "+* The fix is to insert the column only when an item is ", "+* created.", "+*/", "+\t", "+\tint modelIndex = FIRST_COLUMN;", "+\tif (columnCount != 0) {", "+\t\tint modelLength = OS.gtk_tree_model_get_n_columns (modelHandle);", "+\t\tboolean [] usedColumns = new boolean [modelLength];", "+\t\tfor (int i=0; i<columnCount; i++) {", "+\t\t\tint columnIndex = columns [i].modelIndex;", "+\t\t\tfor (int j = 0; j < CELL_TYPES; j++) {", "+\t\t\t\tusedColumns [columnIndex + j] = true;", "+\t\t\t}", "+\t\t}", "+\t\twhile (modelIndex < modelLength) {", "+\t\t\tif (!usedColumns [modelIndex]) break;", "+\t\t\tmodelIndex++;", "+\t\t}", "+\t\tif (modelIndex == modelLength) {", "+\t\t\tint /*long*/ oldModel = modelHandle;", "+\t\t\tint /*long*/[] types = getColumnTypes (columnCount + 4); // grow by 4 rows at a time", "+\t\t\tint /*long*/ newModel = OS.gtk_tree_store_newv (types.length, types);", "+\t\t\tif (newModel == 0) error (SWT.ERROR_NO_HANDLES);", "+\t\t\tcopyModel (oldModel, FIRST_COLUMN, newModel, FIRST_COLUMN, types, (int /*long*/)0, (int /*long*/)0, modelLength);", "+\t\t\tOS.gtk_tree_view_set_model (handle, newModel);", "+\t\t\tOS.g_object_unref (oldModel);", "+\t\t\tmodelHandle = newModel;", "+\t\t}", "+\t}", "+\tint /*long*/ columnHandle = OS.gtk_tree_view_column_new ();", "+\tif (columnHandle == 0) error (SWT.ERROR_NO_HANDLES);", "+\tif (index == 0 && columnCount > 0) {", "+\t\tTreeColumn checkColumn = columns [0];", "+\t\tcreateRenderers (checkColumn.handle, checkColumn.modelIndex, false, checkColumn.style);", "+\t}", "+\tcreateRenderers (columnHandle, modelIndex, index == 0, column == null ? 0 : column.style);", "+\tif ((style & SWT.VIRTUAL) == 0 && columnCount == 0) {", "+\t\tOS.gtk_tree_view_column_set_sizing (columnHandle, OS.GTK_TREE_VIEW_COLUMN_AUTOSIZE);", "+\t} else {", "+\t\tOS.gtk_tree_view_column_set_sizing (columnHandle, OS.GTK_TREE_VIEW_COLUMN_FIXED);", "+\t\tOS.gtk_tree_view_column_set_fixed_width (columnHandle, 10);", "+\t}", "+\tOS.gtk_tree_view_column_set_resizable (columnHandle, true);", "+\tOS.gtk_tree_view_column_set_clickable (columnHandle, true);", "+\tOS.gtk_tree_view_insert_column (handle, columnHandle, index);", "+\tif (column != null) {", "+\t\tcolumn.handle = columnHandle;", "+\t\tcolumn.modelIndex = modelIndex;", "+\t}", "+}", "-", "-void removeColumn () {", "-\tint /*long*/ column = OS.gtk_tree_view_get_column (handle, 0);", "-\tif (column == 0) return;", "-\tOS.gtk_tree_view_remove_column (handle, column);"]}], "num": 49907}