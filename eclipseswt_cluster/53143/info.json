{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bb7cd6c7ab66cffbc2ef2ef2832ff1fe", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d11338b33d70bf80666c876efa63c71", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "2be9e13d76720c8ac383dbac01e6474ca4b95d97", "commitAfterChange": "c5f42b132fb6ee889f8d79e00b89d2fd8962bd6f", "methodNumberBeforeChange": 203, "methodNumberAfterChange": 203, "signatureBeforeChange": "\r \r LRESULT WM_SYSKEYDOWN (int wParam, int lParam)", "signatureAfterChange": "\r \r LRESULT WM_SYSKEYDOWN (int wParam, int lParam)", "diff": ["-\tDisplay display = getDisplay ();\r", "-\r", "-\r", "-\t/* If are going to get a WM_SYSCHAR, ignore this message. */\r", "-\t/*\r", "-\t* Bug on WinCE.  MapVirtualKey() returns incorrect values.\r", "-\t* The fix is to rely on a key mappings table to determine\r", "-\t* whether the key event must be sent now or if a WM_SYSCHAR\r", "-\t* event will follow.\r", "-\t*/\r", "-\tif (!OS.IsWinCE) {\r", "-\t\tif (OS.MapVirtualKey (wParam, 2) != 0) return null;\r", "-\t}\r", "-\t/* Ignore repeating keys for modifiers by testing key down state. */\r", "+\t/* Ignore repeating modifier keys by testing key down state */\r", "+\t\r", "+\t/* Clear last key and last ascii because a new key has been typed */\r", "+\tDisplay display = getDisplay ();\r", "+\tdisplay.lastAscii = display.lastKey = 0;\r", "+\tdisplay.lastVirtual = display.lastNull = false;\r", "-\t/* Set last key and clear last ascii because a new key has been typed. */\r", "-\tdisplay.lastAscii = 0;\r", "+\t/* If are going to get a WM_SYSCHAR, ignore this message. */\r", "+\t/*\r", "+\t* Bug on WinCE.  MapVirtualKey() returns incorrect values.\r", "+\t* The fix is to rely on a key mappings table to determine\r", "+\t* whether the key event must be sent now or if a WM_SYSCHAR\r", "+\t* event will follow.\r", "+\t*/\r", "+\tif (!OS.IsWinCE) {\r", "+\t\tif (OS.MapVirtualKey (wParam, 2) != 0) {\r", "+\t\t\t/*\r", "+\t\t\t* Feature in Windows.  MapVirtualKey() indicates that\r", "+\t\t\t* a WM_SYSCHAR message will occur for Alt+Enter but\r", "+\t\t\t* this message never happens.  The fix is to issue the\r", "+\t\t\t* event from WM_SYSKEYDOWN and map VK_RETURN to '\\r'.\r", "+\t\t\t*/\r", "+\t\t\tif (wParam != OS.VK_RETURN) return null;\r", "+\t\t\tdisplay.lastAscii = '\\r';\r", "+\t\t}\r", "+\t}\r", "-\tdisplay.lastNull = false;\r", "-\r", "+\t\t\r", "+\t/*\r", "+\t* Feature in Windows.  The virtual key VK_DELETE is not\r", "+\t* treated as both a virtual key and an ASCII key by Windows.\r", "+\t* Therefore, we will not receive a WM_CHAR for this key.\r", "+\t* The fix is to treat VK_DELETE as a special case and map\r", "+\t* the ASCII value explictly (Delete is 0x7F).\r", "+\t*/\r", "+\tif (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;\r", "+\t\r", "+\t/*\r", "+\t* It is possible to get a WM_CHAR for a virtual key when\r", "+\t* Num Lock is on.  If the user types Home while Num Lock \r", "+\t* is down, a WM_CHAR is issued with WPARM=55 (for the\r", "+\t* character 7).  If we are going to get a WM_CHAR we need\r", "+\t* to ensure that the last key has the correct value.  Note\r", "+\t* that Ctrl+Home does not issue a WM_CHAR when Num Lock is\r", "+\t* down.\r", "+\t*/\r", "+\tif (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {\r", "+\t\tif (display.asciiKey (display.lastKey) != 0) return null;\r", "+\t}\r", "+\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e2b4a6979bbf51633e2bafcb75828c7d", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Control.java", "commitBeforeChange": "336c640f21f6098f84d6d6682ff7635ddf66f650", "commitAfterChange": "20f32f00170b2b5fe44ce0d2c73eb51efa55207e", "methodNumberBeforeChange": 220, "methodNumberAfterChange": 220, "signatureBeforeChange": "  LRESULT WM_SYSKEYDOWN (int wParam, int lParam)", "signatureAfterChange": "  LRESULT WM_SYSKEYDOWN (int wParam, int lParam)", "diff": ["-\tif (!OS.IsWinCE) {", "-\t\tif (OS.MapVirtualKey (wParam, 2) != 0) {", "-\t\t\t/*", "-\t\t\t* Feature in Windows.  MapVirtualKey() indicates that", "-\t\t\t* a WM_SYSCHAR message will occur for Alt+Enter but", "-\t\t\t* this message never happens.  The fix is to issue the", "-\t\t\t* event from WM_SYSKEYDOWN and map VK_RETURN to '\\r'.", "-\t\t\t*/", "-\t\t\tif (wParam != OS.VK_RETURN) return null;", "-\t\t\tdisplay.lastAscii = '\\r';", "+\tint mapKey = OS.IsWinCE ? 0 : OS.MapVirtualKey (wParam, 2);", "+\tdisplay.lastVirtual = (mapKey == 0);", "+\tif (display.lastVirtual) {", "+\t \tdisplay.lastKey = wParam;", "+\t\t/*", "+\t\t* Feature in Windows.  The virtual key VK_DELETE is not", "+\t\t* treated as both a virtual key and an ASCII key by Windows.", "+\t\t* Therefore, we will not receive a WM_CHAR for this key.", "+\t\t* The fix is to treat VK_DELETE as a special case and map", "+\t\t* the ASCII value explictly (Delete is 0x7F).", "+\t\t*/", "+\t\tif (display.lastKey == OS.VK_DELETE) {", "+\t\t\tdisplay.lastVirtual = false;", "+\t\t\tdisplay.lastKey = display.lastAscii = 0x7F;", "+", "+\t\t/*", "+\t\t* It is possible to get a WM_CHAR for a virtual key when", "+\t\t* Num Lock is on.  If the user types Home while Num Lock ", "+\t\t* is down, a WM_CHAR is issued with WPARM=55 (for the", "+\t\t* character 7).  If we are going to get a WM_CHAR we need", "+\t\t* to ensure that the last key has the correct value.  Note", "+\t\t* that Ctrl+Home does not issue a WM_CHAR when Num Lock is", "+\t\t* down.", "+\t\t* ", "+\t\t* NOTE: This only happens on Windows 98.", "+\t\t*/", "+\t\tif (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {", "+\t\t\tif (display.asciiKey (display.lastKey) != 0) return null;", "+\t\t\tdisplay.lastAscii = display.numpadKey (display.lastKey);", "+\t\t}", "+\t} else {", "+\t\t/*", "+\t\t* Convert LastKey to lower case because Windows non-virtual", "+\t\t* keys that are also ASCII keys, such as like VK_A, are have", "+\t\t* upper case values in WM_KEYDOWN despite the fact that the ", "+\t\t* Shift was not pressed.", "+\t\t*/", "+\t \tdisplay.lastKey = OS.CharLower ((short) mapKey);", "+", "+\t\t/*", "+\t\t* Feature in Windows 98.  MapVirtualKey() indicates that", "+\t\t* a WM_SYSCHAR message will occur for Alt+Enter but", "+\t\t* this message never happens.  The fix is to issue the", "+\t\t* event from WM_SYSKEYDOWN and map VK_RETURN to '\\r'.", "+\t\t*/", "+\t\tif (OS.IsWinNT) return null;", "+\t\tif (wParam != OS.VK_RETURN) return null;", "+\t\tdisplay.lastAscii = '\\r';", "-\tdisplay.lastKey = wParam;", "-\tdisplay.lastVirtual = true;", "-\t\t", "-\t/*", "-\t* Feature in Windows.  The virtual key VK_DELETE is not", "-\t* treated as both a virtual key and an ASCII key by Windows.", "-\t* Therefore, we will not receive a WM_CHAR for this key.", "-\t* The fix is to treat VK_DELETE as a special case and map", "-\t* the ASCII value explictly (Delete is 0x7F).", "-\t*/", "-\tif (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;", "-\t", "-\t/*", "-\t* It is possible to get a WM_CHAR for a virtual key when", "-\t* Num Lock is on.  If the user types Home while Num Lock ", "-\t* is down, a WM_CHAR is issued with WPARM=55 (for the", "-\t* character 7).  If we are going to get a WM_CHAR we need", "-\t* to ensure that the last key has the correct value.  Note", "-\t* that Ctrl+Home does not issue a WM_CHAR when Num Lock is", "-\t* down.", "-\t*/", "-\tif (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {", "-\t\tif (display.asciiKey (display.lastKey) != 0) return null;", "-\t}", "-\t", "+"]}], "num": 53143}