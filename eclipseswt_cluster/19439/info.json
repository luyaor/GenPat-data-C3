{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c33c9b2aaccda98a283332f996ec27b4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "41b7a28c0db0e7677968b7c8b1c1f7cb", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Label.java", "commitBeforeChange": "bcbab027b782a219051696a27ecb1edbc29136c2", "commitAfterChange": "e7b19311f8b1c1c9ab3f1840b1542b88b76728a7", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  public Point computeSize (int wHint, int hHint, boolean changed)", "signatureAfterChange": "  public Point computeSize (int wHint, int hHint, boolean changed)", "diff": ["-\tboolean fixWrap = labelHandle != 0 && (style & SWT.WRAP) != 0;", "-\tif (fixWrap || frameHandle != 0) forceResize ();", "-\tint [] labelWidth = new int [1], labelHeight = new int [1];", "-\tif (fixWrap) {", "-\t\tOS.gtk_widget_get_size_request (labelHandle, labelWidth, labelHeight);", "-\t\tOS.gtk_widget_set_size_request (labelHandle, wHint, hHint);", "-\t}\t", "-\tif (frameHandle != 0) {", "-\t\tint [] reqWidth = new int [1], reqHeight = new int [1];", "-\t\tOS.gtk_widget_get_size_request (handle, reqWidth, reqHeight);", "-\t\tOS.gtk_widget_set_size_request (handle, wHint, hHint);", "-\t\tsize = computeNativeSize (frameHandle, -1, -1, changed);", "-\t\tOS.gtk_widget_set_size_request (handle, reqWidth [0], reqHeight [0]);", "-\t} else {", "-\t\tsize = computeNativeSize (handle, wHint, hHint, changed);", "-\t}", "+\t/* ", "+\t* Feature in GTK. GTK has a predetermined maximum width for wrapping text. ", "+\t* The fix is to use pango layout directly instead of the label size request ", "+\t* to calculate its preferred size.", "+\t*/", "+\tboolean fixWrap = labelHandle != 0 && (style & SWT.WRAP) != 0 && (OS.GTK_WIDGET_FLAGS (labelHandle) & OS.GTK_VISIBLE) != 0;", "-\t\tOS.gtk_widget_set_size_request (labelHandle, labelWidth [0], labelHeight [0]);", "+\t\tint /*long*/ labelLayout = OS.gtk_label_get_layout (labelHandle);", "+\t\tint pangoWidth = OS.pango_layout_get_width (labelLayout);", "+\t\tif (wHint != SWT.DEFAULT) {", "+\t\t\tOS.pango_layout_set_width (labelLayout, wHint * OS.PANGO_SCALE);", "+\t\t} else {", "+\t\t\tOS.pango_layout_set_width (labelLayout, -1);", "+\t\t}", "+\t\tint [] w = new int [1], h = new int [1];", "+\t\tOS.pango_layout_get_size (labelLayout, w, h);", "+\t\tOS.pango_layout_set_width (labelLayout, pangoWidth);", "+\t\tif (frameHandle != 0) {", "+\t\t\tint [] labelWidth = new int [1], labelHeight = new int [1];", "+\t\t\tOS.gtk_widget_get_size_request (labelHandle, labelWidth, labelHeight);", "+\t\t\tOS.gtk_widget_set_size_request (labelHandle, 1, 1);", "+\t\t\tsize = computeNativeSize (frameHandle, -1, -1, changed);", "+\t\t\tOS.gtk_widget_set_size_request (labelHandle, labelWidth [0], labelHeight [0]);", "+\t\t\tsize.x = size.x - 1;", "+\t\t\tsize.y = size.y - 1;", "+\t\t} else { ", "+\t\t\tsize = new Point (0,0);", "+\t\t}", "+\t\tsize.x += wHint == SWT.DEFAULT ? OS.PANGO_PIXELS(w [0]) : wHint;", "+\t\tsize.y += hHint == SWT.DEFAULT ? OS.PANGO_PIXELS(h [0]) : hHint;", "+\t} else {", "+\t\tif (frameHandle != 0) {", "+\t\t\tint [] reqWidth = new int [1], reqHeight = new int [1];", "+\t\t\tOS.gtk_widget_get_size_request (handle, reqWidth, reqHeight);", "+\t\t\tOS.gtk_widget_set_size_request (handle, wHint, hHint);", "+\t\t\tsize = computeNativeSize (frameHandle, -1, -1, changed);", "+\t\t\tOS.gtk_widget_set_size_request (handle, reqWidth [0], reqHeight [0]);", "+\t\t} else {", "+\t\t\tsize = computeNativeSize (handle, wHint, hHint, changed);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ddf094d0ccfbf5fae9e048fb9156a34a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Program/motif/org/eclipse/swt/program/Program.java", "commitBeforeChange": "e7fb43dbb2484659429530f9cab714cb6e3de9f3", "commitAfterChange": "d69b8bce251422ebdcfdac8edd7d2bcf938dfebd", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 22, "signatureBeforeChange": "\r public boolean execute (String fileName)", "signatureAfterChange": " public boolean execute (String fileName)", "diff": ["- */\r", "-public boolean execute (String fileName) {\r", "-\tif (fileName == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);\r", "-\t\r", "-\t// Parse the command into its individual arguments.\r", "-\tString[]  args = parseCommand( command );\r", "-\tint       fileArg = -1;\r", "-\tint       index;\r", "-\tfor (index=0; index < args.length; index++) {\r", "-\t\tint j = args[ index ].indexOf( \"%f\" );\r", "-\t\tif (j != -1) {\r", "-\t\t\tString value = args[ index ];\r", "-\t\t\tfileArg = index;\r", "-\t\t\targs[ index ] = value.substring(0,j) + fileName + value.substring(j+2);\r", "-\t\t}\r", "-\t}\r", "-\t\r", "-\t// If a file name was given but the command did not have \"%f\"\r", "-\tif ((fileName.length() > 0) && (fileArg < 0)) {\r", "-\t\tString[] newArgs = new String[ args.length + 1 ];\r", "-\t\tfor (index=0; index < args.length; index++)\r", "-\t\t\tnewArgs[ index ] = args[ index ];\r", "-\t\tnewArgs[ args.length ] = fileName;\r", "-\t\targs = newArgs;\r", "-\t}\r", "-\t\r", "-\t// Execute the command.\r", "-\ttry {\r", "-\t\tRuntime.getRuntime().exec( args );\r", "-\t} catch (IOException e) {\r", "-\t\treturn false;\r", "-\t}\r", "-\r", "-\treturn true;\r", "-}\r", "+ */", "+public boolean execute (String fileName) {", "+\tif (fileName == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);", "+\t", "+\tswitch (getDesktop( display )) {", "+\t\tcase DESKTOP_KDE: {", "+\t\t\tString urlString = \"file://\" + fileName;", "+\t\t\tbyte[] buffer = Converter.wcsToMbcs( null, urlString, true );", "+\t\t\tint qString = KDE.QString_new( buffer );", "+\t\t\tint url = KDE.KURL_new( qString );", "+\t\t\tKDE.QString_delete( qString );", "+\t\t\tbuffer = Converter.wcsToMbcs (null, name, true);", "+\t\t\tint mimeTypeName = KDE.QString_new( buffer );", "+\t\t\tint pid = KDE.KRun_runURL( url, mimeTypeName );", "+\t\t\tKDE.KURL_delete( url );", "+\t\t\tKDE.QString_delete( mimeTypeName );", "+\t\t\treturn (pid != 0);", "+\t\t}", "+\t\t", "+\t\tcase DESKTOP_GNOME: {", "+\t\t\t// Parse the command into its individual arguments.", "+\t\t\tString[]  args = parseCommand( command );", "+\t\t\tint       fileArg = -1;", "+\t\t\tint       index;", "+\t\t\tfor (index=0; index < args.length; index++) {", "+\t\t\t\tint j = args[ index ].indexOf( \"%f\" );", "+\t\t\t\tif (j != -1) {", "+\t\t\t\t\tString value = args[ index ];", "+\t\t\t\t\tfileArg = index;", "+\t\t\t\t\targs[ index ] = value.substring(0,j) + fileName + value.substring(j+2);", "+\t\t\t\t}", "+\t\t\t}", "+\t", "+\t\t\t// If a file name was given but the command did not have \"%f\"", "+\t\t\tif ((fileName.length() > 0) && (fileArg < 0)) {", "+\t\t\t\tString[] newArgs = new String[ args.length + 1 ];", "+\t\t\t\tfor (index=0; index < args.length; index++)", "+\t\t\t\t\tnewArgs[ index ] = args[ index ];", "+\t\t\t\tnewArgs[ args.length ] = fileName;", "+\t\t\t\targs = newArgs;", "+\t\t\t}", "+\t", "+\t\t\t// Execute the command.", "+\t\t\ttry {", "+\t\t\t\tRuntime.getRuntime().exec( args );", "+\t\t\t} catch (IOException e) {", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t\treturn true;", "+\t\t}", "+\t\t", "+\t\tcase DESKTOP_CDE: {", "+\t\t\tbyte[] action = Converter.wcsToMbcs( null, command, true );", "+\t\t\tbyte[] fileArg = Converter.wcsToMbcs( null, fileName, true );", "+\t\t\tInteger shell = (Integer) display.getData( cdeShell );", "+\t\t\tint actionID = 0;", "+\t\t\tif (shell != null) {", "+\t\t\t\tactionID = CDE.DtActionInvoke( shell.intValue(), action, fileArg, 1, null, null, null, 1, 0, 0 );", "+\t\t\t}", "+\t\t\treturn (actionID != 0);", "+\t\t}", "+\t}", "+", "+\treturn false;", "+}"]}], "num": 19439}