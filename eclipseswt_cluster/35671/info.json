{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0022b8c300a8348dc43086ae47d024e5", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5ed9816e2b49fd60df255c62ac4c3b5", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "tests/org.eclipse.swt.tests/JUnit Tests/org/eclipse/swt/tests/junit/Test_org_eclipse_swt_widgets_Display.java", "commitBeforeChange": "3ace99cc2cbeca175428eabbe777b2fc353f5d7d", "commitAfterChange": "38b0d2b8f58957af87b01bf2967bf37e853d55b0", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 35, "signatureBeforeChange": "  public void test_getSyncThread()", "signatureAfterChange": "  public void test_getSyncThread()", "diff": ["-\twarnUnimpl(\"Test test_getSyncThread not written\");", "+\tfinal Display display = new Display();", "+\ttry {", "+\t\tfinal boolean[] threadRan = new boolean[] {false};", "+\t\tThread nonUIThread = new Thread(new Runnable() {", "+\t\t\tpublic void run() {", "+\t\t\t\t// Assume no syncExec runnable is currently being invoked.", "+\t\t\t\tassertNull(display.getSyncThread());", "+\t\t\t\t", "+\t\t\t\t// Create a runnable and invoke with syncExec to verify that", "+\t\t\t\t// the invoking thread is the syncThread.", "+\t\t\t\tfinal Thread invokingThread = Thread.currentThread();", "+\t\t\t\tdisplay.syncExec(new Runnable() {", "+\t\t\t\t\tpublic void run() {", "+\t\t\t\t\t\tassertEquals(invokingThread, display.getSyncThread());", "+\t\t\t\t\t}", "+\t\t\t\t});", "+\t\t\t\t", "+\t\t\t\t// Create a runnable and invoke with asyncExec to verify that", "+\t\t\t\t// the syncThread is null while it's running.", "+\t\t\t\tfinal boolean[] asyncExecRan = new boolean[] {false};", "+\t\t\t\tdisplay.asyncExec(new Runnable() {", "+\t\t\t\t\tpublic void run() {", "+\t\t\t\t\t\tassertNull(display.getSyncThread());", "+\t\t\t\t\t\tasyncExecRan[0] = true;", "+\t\t\t\t\t}", "+\t\t\t\t});", "+\t\t\t\t", "+\t\t\t\ttry {", "+\t\t\t\t\twhile (!asyncExecRan[0]) {", "+\t\t\t\t\t\tThread.sleep(100);", "+\t\t\t\t\t}", "+\t\t\t\t} catch (InterruptedException ex) {", "+\t\t\t\t}", "+\t\t\t\tthreadRan[0] = true;", "+\t\t\t\tdisplay.wake();", "+\t\t\t}", "+\t\t});", "+\t\tnonUIThread.start();", "+\t\t", "+\t\twhile (!threadRan[0]) {", "+\t\t\tif (!display.readAndDispatch()) display.sleep ();", "+\t\t}", "+\t} finally {", "+\t\tdisplay.dispose();", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e03ff18b3285e6e85503ed3eab85138e", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "tests/org.eclipse.swt.tests/JUnit Tests/org/eclipse/swt/tests/junit/Test_org_eclipse_swt_widgets_Display.java", "commitBeforeChange": "3ace99cc2cbeca175428eabbe777b2fc353f5d7d", "commitAfterChange": "38b0d2b8f58957af87b01bf2967bf37e853d55b0", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 76, "signatureBeforeChange": "  public void test_timerExecILjava_lang_Runnable()", "signatureAfterChange": "  public void test_timerExecILjava_lang_Runnable()", "diff": ["-\twarnUnimpl(\"Test test_timerExecILjava_lang_Runnable not written\");", "+\tfinal Display display = new Display();", "+\ttry {", "+\t\tfinal boolean[] timerExecRan = new boolean[] {false};", "+\t\tfinal boolean[] threadRan = new boolean[] {false};", "+\t\t", "+\t\ttry {", "+\t\t\tdisplay.timerExec(0, null);", "+\t\t\tfail(\"No exception thrown for timerExec with null runnable\");", "+\t\t} catch (IllegalArgumentException e) {", "+\t\t\tassertEquals(\"Incorrect exception thrown for timerExec with null runnable\", SWT.ERROR_NULL_ARGUMENT, e);", "+\t\t}", "+\t\t", "+\t\tdisplay.timerExec(-100, new Runnable() {", "+\t\t\tpublic void run() {", "+\t\t\t\ttimerExecRan[0] = true;", "+\t\t\t}", "+\t\t});", "+\t\t\t\t", "+\t\tfinal int delay = 3000;", "+\t\tfinal long startTime = System.currentTimeMillis();", "+\t\tdisplay.timerExec(delay, new Runnable() {", "+\t\t\tpublic void run() {", "+\t\t\t\tlong endTime = System.currentTimeMillis();", "+\t\t\t\tassertTrue(endTime >= (startTime + delay));", "+\t\t\t\tthreadRan[0] = true;", "+\t\t\t}", "+\t\t});", "+\t\twhile (!threadRan[0]) {", "+\t\t\t// The read and dispatch loop must be running in order", "+\t\t\t// for the runnable in the timer exec to be executed.", "+\t\t\tdisplay.readAndDispatch();", "+\t\t}", "+\t\t", "+\t\t// Verify the timerExec with less than zero milliseconds didn't execute.", "+\t\tassertFalse(timerExecRan[0]);", "+\t} finally {", "+\t\tdisplay.dispose();", "+\t}"]}], "num": 35671}