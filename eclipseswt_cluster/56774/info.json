{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5fb8fd16742089d146b8e72f085a595c", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0eaac5d9b54be94d2ed1af27c863331", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/cocoa/org/eclipse/swt/widgets/Display.java", "commitBeforeChange": "d4ce2fe3631bc060a94000536e7454e9ee602a3d", "commitAfterChange": "be954920b3bf51c2767d57c5bc9db3ba96994f28", "methodNumberBeforeChange": 91, "methodNumberAfterChange": 91, "signatureBeforeChange": " protected void init ()", "signatureAfterChange": " protected void init ()", "diff": ["-\tif (!isEmbedded) {", "-\t\t/*", "-\t\t * Feature in Cocoa:  NSApplication.finishLaunching() adds an apple menu to the menu bar that isn't accessible via NSMenu.", "-\t\t * If Display objects are created and disposed of multiple times in a single process, another apple menu is added to the menu bar.", "-\t\t * It must be called or the dock icon will continue to bounce. So, it should only be called once per process, not just once per", "-\t\t * creation of a Display.  Use a static so creation of additional Display objects won't affect the menu bar. ", "-\t\t */", "-\t\tif (!Display.launched) {", "-\t\t\tapplication.finishLaunching();", "-\t\t\tDisplay.launched = true;", "-\t\t\t", "-\t\t\t/* only add the shutdown hook once */", "-\t\t\tRuntime.getRuntime().addShutdownHook(new Thread() {", "-\t\t\t\tpublic void run() {", "-\t\t\t\t\tNSApplication.sharedApplication().terminate(null);", "+\t/*", "+\t * Create an application delegate for app-level notifications.  The AWT may have already set a delegate;", "+\t * if so, hold on to it so messages can be forwarded to it.", "+\t */", "+\tif (applicationDelegate == null) {", "+\t\tapplicationDelegate = (SWTApplicationDelegate)new SWTApplicationDelegate().alloc().init();", "+\t\t", "+\t\tif (currAppDelegate == null) {", "+\t\t\tif (OS.class_JRSAppKitAWT != 0) {", "+\t\t\t\tint /*long*/ currDelegatePtr = OS.objc_msgSend(OS.class_JRSAppKitAWT, OS.sel_awtAppDelegate);", "+\t\t\t\tif (currDelegatePtr != 0) {", "+\t\t\t\t\tcurrAppDelegate = new NSObject(currDelegatePtr);", "+\t\t\t\t\tcurrAppDelegate.retain();", "-\t\t\t});", "+\t\t\t}", "+\t\t\tapplication.setDelegate(applicationDelegate);", "+\t\t} else {", "+\t\t\t// TODO: register for notification to find out when AWT finishes loading.  Waiting on new value from Apple.", "+\t", "+\t/*", "+\t * Feature in Cocoa:  NSApplication.finishLaunching() adds an apple menu to the menu bar that isn't accessible via NSMenu.", "+\t * If Display objects are created and disposed of multiple times in a single process, another apple menu is added to the menu bar.", "+\t * It must be called or the dock icon will continue to bounce. So, it should only be called once per process, not just once per", "+\t * creation of a Display.  Use a static so creation of additional Display objects won't affect the menu bar. ", "+\t */", "+\tif (!Display.launched) {", "+\t\tapplication.finishLaunching();", "+\t\tDisplay.launched = true;", "+", "+\t\t/* only add the shutdown hook once */", "+\t\tRuntime.getRuntime().addShutdownHook(new Thread() {", "+\t\t\tpublic void run() {", "+\t\t\t\tNSApplication.sharedApplication().terminate(null);", "+\t\t\t}", "+\t\t});", "+\t}", "+\t", "+\t/*", "+\t * Call init to force the AWT delegate to re-attach itself to the application menu. ", "+\t */", "+\tif (currAppDelegate != null) {", "+\t\tcurrAppDelegate.init();", "+\t} "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c1ce6b2310bc51d66cb45097ef999f0", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Shell.java", "commitBeforeChange": "19051ffe4fd662e4376e9ef3523424e6764f8cc9", "commitAfterChange": "fec0d691465789ed5f8cc6a20256c17056f52d4b", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 19, "signatureBeforeChange": "  void createHandle (int index)", "signatureAfterChange": "  void createHandle (int index)", "diff": ["-\tif (handle == 0) {", "-\t\tint type = OS.GTK_WINDOW_TOPLEVEL;", "-\t\tif ((style & SWT.ON_TOP) != 0) type = OS.GTK_WINDOW_POPUP;", "-\t\tshellHandle = OS.gtk_window_new (type);", "-\t} else {", "-\t\tshellHandle = OS.gtk_plug_new (handle);", "-\t}", "-\tif (shellHandle == 0) error (SWT.ERROR_NO_HANDLES);", "-\tif (parent != null) {", "-\t\tOS.gtk_window_set_transient_for (shellHandle, parent.topHandle ());", "-\t\tOS.gtk_window_set_destroy_with_parent (shellHandle, true);", "-\t\tif (!isUndecorated ()) {", "-\t\t\tOS.gtk_window_set_type_hint (shellHandle, OS.GDK_WINDOW_TYPE_HINT_DIALOG);", "+\tif (shellHandle == 0) {", "+\t\tif (handle == 0) {", "+\t\t\tint type = OS.GTK_WINDOW_TOPLEVEL;", "+\t\t\tif ((style & SWT.ON_TOP) != 0) type = OS.GTK_WINDOW_POPUP;", "+\t\t\tshellHandle = OS.gtk_window_new (type);", "+\t\t} else {", "+\t\t\tshellHandle = OS.gtk_plug_new (handle);", "-\t}", "-\t/*", "-\t* Feature in GTK.  The window size must be set when the window", "-\t* is created or it will not be allowed to be resized smaller that the", "-\t* initial size by the user.  The fix is to set the size to zero.", "-\t*/", "-\tif ((style & SWT.RESIZE) != 0) {", "-\t\tOS.gtk_widget_set_size_request (shellHandle, 0, 0);", "-\t\tOS.gtk_window_set_resizable (shellHandle, true);", "+\t\tif (shellHandle == 0) error (SWT.ERROR_NO_HANDLES);", "+\t\tif (parent != null) {", "+\t\t\tOS.gtk_window_set_transient_for (shellHandle, parent.topHandle ());", "+\t\t\tOS.gtk_window_set_destroy_with_parent (shellHandle, true);", "+\t\t\tif (!isUndecorated ()) {", "+\t\t\t\tOS.gtk_window_set_type_hint (shellHandle, OS.GDK_WINDOW_TYPE_HINT_DIALOG);", "+\t\t\t}", "+\t\t}", "+\t\t/*", "+\t\t* Feature in GTK.  The window size must be set when the window", "+\t\t* is created or it will not be allowed to be resized smaller that the", "+\t\t* initial size by the user.  The fix is to set the size to zero.", "+\t\t*/", "+\t\tif ((style & SWT.RESIZE) != 0) {", "+\t\t\tOS.gtk_widget_set_size_request (shellHandle, 0, 0);", "+\t\t\tOS.gtk_window_set_resizable (shellHandle, true);", "+\t\t} else {", "+\t\t\tOS.gtk_window_set_resizable (shellHandle, false);", "+\t\t}", "+\t\tvboxHandle = OS.gtk_vbox_new (false, 0);", "+\t\tif (vboxHandle == 0) error (SWT.ERROR_NO_HANDLES);", "+\t\tcreateHandle (index, false, true);", "+\t\tOS.gtk_container_add (vboxHandle, scrolledHandle);", "+\t\tOS.gtk_box_set_child_packing (vboxHandle, scrolledHandle, true, true, 0, OS.GTK_PACK_END);", "-\t\tOS.gtk_window_set_resizable (shellHandle, false);", "+\t\tvboxHandle = OS.gtk_bin_get_child (shellHandle);", "+\t\tif (vboxHandle == 0) error (SWT.ERROR_NO_HANDLES);", "+\t\tint children = OS.gtk_container_get_children (vboxHandle);", "+\t\tif (OS.g_list_length (children) > 0) {", "+\t\t\tscrolledHandle = OS.g_list_data (children);", "+\t\t}", "+\t\tOS.g_list_free (children);", "+\t\tif (scrolledHandle == 0) error (SWT.ERROR_NO_HANDLES);", "+\t\thandle = OS.gtk_bin_get_child (scrolledHandle);", "+\t\tif (handle == 0) error (SWT.ERROR_NO_HANDLES);", "-\tvboxHandle = OS.gtk_vbox_new (false, 0);", "-\tif (vboxHandle == 0) error (SWT.ERROR_NO_HANDLES);", "-\tcreateHandle (index, false, true);", "-\tOS.gtk_container_add (vboxHandle, scrolledHandle);", "-\tOS.gtk_box_set_child_packing (vboxHandle, scrolledHandle, true, true, 0, OS.GTK_PACK_END);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf18573ee9e47d94d4a250cafa7d6f51", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/carbon/org/eclipse/swt/widgets/ScrollBar.java", "commitBeforeChange": "f1a5ab498a02ea2b6c3775c919b87767d3133145", "commitAfterChange": "da6ef9699dc92690440332045fea4fe9c5860d53", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " public void setVisible (boolean visible)", "signatureAfterChange": " public void setVisible (boolean visible)", "diff": ["-\t/*", "-\t* Feature in Motif.  Hiding or showing a scroll bar", "-\t* can cause the widget to automatically resize in", "-\t* the OS.  This behavior is unwanted.  The fix is", "-\t* to force the widget to resize to original size.", "-\t*/", "-    /* AW", "-\tint scrolledHandle = parent.scrolledHandle;", "-\tint [] argList = {OS.XmNwidth, 0, OS.XmNheight, 0};", "-\tOS.XtGetValues (scrolledHandle, argList, argList.length / 2);", "-    */", "-", "-\t/* Hide or show the scroll bar */", "-\t/* AW", "-\tif (visible) {", "-\t\tOS.XtManageChild (handle);", "-\t} else {", "-\t\tOS.XtUnmanageChild (handle);", "+    ", "+    if (WORKS) {", "+\t\tfVisible= visible;", "+\t\tif (OS.IsControlVisible(handle) != visible) {", "+\t\t\tOS.SetControlVisibility(handle, visible, true);", "+\t\t\t", "+\t\t\tparent.relayout123();", "+\t", "+\t\t\tsendEvent(visible ? SWT.Show : SWT.Hide);", "+\t\t}", "+    } else {", "+\t\tif (visible != fVisible) {", "+\t\t    fVisible= visible;", "+\t\t\tint topHandle = topHandle ();", "+\t\t\tif (OS.IsControlVisible(topHandle) != visible) {", "+\t\t\t\tif (visible) {", "+\t\t\t\t\tOS.SetControlVisibility(topHandle, true, false);", "+\t\t\t\t\tparent.relayout123();", "+\t\t\t\t\tsendEvent(SWT.Show);", "+\t\t\t\t\tredrawHandle (0, 0, 0, 0, topHandle, true);", "+\t\t\t\t} else {", "+\t\t\t\t\tOS.SetControlVisibility(topHandle, false, true);", "+\t\t\t\t\tparent.relayout123();", "+\t\t\t\t\tsendEvent(SWT.Hide);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-    */", "-\tif (OS.IsControlVisible(handle) != visible) {", "-\t\tOS.SetControlVisibility(handle, visible, true);", "-\t\t", "-\t\tparent.relayout123(parent.topHandle());", "-", "-\t\tsendEvent(visible ? SWT.Show : SWT.Hide);", "-\t}", "-", "-\t/* Restore the size */", "-    /* AW", "-\tOS.XtSetValues (scrolledHandle, argList, argList.length / 2);", "-    */"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "65cd60d30289ed74afca0500d7dadb26", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/win32/org/eclipse/swt/widgets/Tree.java", "commitBeforeChange": "e6fd36b834853dbd7a2f4ea5d3f6a3490b642f43", "commitAfterChange": "68774e9fa7ffb588d4e87074e9abdf86ba978259", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  LRESULT CDDS_ITEMPOSTPAINT (int wParam, int lParam)", "signatureAfterChange": "  LRESULT CDDS_ITEMPOSTPAINT (int wParam, int lParam)", "diff": ["+\t\t\t\ttextColor = -1;", "+\t\t\tif (textColor != -1) clrText = textColor;", "+\t\t\t\t\t\tint newTextClr = OS.GetTextColor (hDC);", "+\t\t\t\t\t\tif (event.doit) {", "+\t\t\t\t\t\t\tif ((event.detail & SWT.SELECTED) != 0) {", "+\t\t\t\t\t\t\t\tif (!selected) {", "+\t\t\t\t\t\t\t\t\ttextColor = OS.GetSysColor (OS.COLOR_HIGHLIGHTTEXT);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (selected) textColor = newTextClr;", "+\t\t\t\t\t\t\t\tignoreDrawSelected = true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\tif (textColor != -1) clrText = textColor;", "+\t\t\tif (textColor != -1) clrText = textColor;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "abc08bc9c0494a8b6d0dd62acd0ef707", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT Browser/cocoa/org/eclipse/swt/browser/Safari.java", "commitBeforeChange": "a3eda06a7a4c290420b73156206fa1800c9178ee", "commitAfterChange": "9837bb695405327b535c2924659cef1a3a71f994", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 28, "signatureBeforeChange": "  void webView_didFinishLoadForFrame(int sender, int frameID)", "signatureAfterChange": "  void webView_didFinishLoadForFrame(int sender, int frameID)", "diff": ["-\t\tProgressEvent progress = new ProgressEvent(browser);", "-\t\tprogress.display = display;", "-\t\tprogress.widget = browser;", "-\t\tprogress.current = MAX_PROGRESS;", "-\t\tprogress.total = MAX_PROGRESS;", "-\t\tfor (int i = 0; i < progressListeners.length; i++) {", "-\t\t\tprogressListeners[i].completed(progress);", "+", "+\t\t/*", "+\t\t * If html is not null then there is html from a previous setText() call", "+\t\t * waiting to be set into the about:blank page once it has completed loading. ", "+\t\t */", "+\t\tif (html != null) {", "+\t\t\tif (url.startsWith(ABOUT_BLANK)) {", "+\t\t\t\tloadingText = true;", "+\t\t\t\tNSString string = NSString.stringWith(html);", "+\t\t\t\tNSString URLString;", "+\t\t\t\tif (untrustedText) {", "+\t\t\t\t\tURLString = NSString.stringWith(ABOUT_BLANK);", "+\t\t\t\t} else {", "+\t\t\t\t\tURLString = NSString.stringWith(URI_FILEROOT);", "+\t\t\t\t}", "+\t\t\t\tNSURL URL = NSURL.URLWithString(URLString);", "+\t\t\t\tWebFrame mainFrame = webView.mainFrame();", "+\t\t\t\tmainFrame.loadHTMLString(string, URL);", "+\t\t\t\thtml = null;", "+\t\t\t}", "+\t\t/*", "+\t\t* The loadHTMLString() invocation above will trigger a second webView_didFinishLoadForFrame", "+\t\t* callback when it is completed.  Wait for this second callback to come before sending the", "+\t\t* completed event.", "+\t\t*/", "+\t\tif (!loadingText) {", "+\t\t\tProgressEvent progress = new ProgressEvent(browser);", "+\t\t\tprogress.display = display;", "+\t\t\tprogress.widget = browser;", "+\t\t\tprogress.current = MAX_PROGRESS;", "+\t\t\tprogress.total = MAX_PROGRESS;", "+\t\t\tfor (int i = 0; i < progressListeners.length; i++) {", "+\t\t\t\tprogressListeners[i].completed(progress);", "+\t\t\t}", "+\t\t}", "+\t\tloadingText = false;"]}], "num": 56774}