{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9cd23abbea4285028b86c22450a23233", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9ddcd2699dfb4f983d00d9d369a30d6a", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/coolbar/org/eclipse/swt/widgets/CoolBar.java", "commitBeforeChange": "527e849a2526f3d8802def278cb1e6f6d555176e", "commitAfterChange": "732b93a3746a83c09a87316a75d0a62edeb31a1a", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 25, "signatureBeforeChange": "\r Point layout (int width, boolean resize)", "signatureAfterChange": "\r int layout (int width)", "diff": ["+int layout (int width) {\r", "+\tint y = 0, maxWidth = 0;\r", "+\tfor (int row = 0; row < items.length; row++) {\r", "+\t\tint count = items[row].length;\r", "+\t\tint available = width - count * CoolItem.MINIMUM_WIDTH;\r", "+\t\tif (available < 0) available = count * CoolItem.MINIMUM_WIDTH;\r", "+\t\tint x = 0;\r", "+\r", "+\t\t/* determine the height of the row */\r", "+\t\tint rowHeight = 0;\r", "+\t\tfor (int i = 0; i < items[row].length; i++) {\r", "+\t\t\tCoolItem item = items[row][i];\r", "+\t\t\tif (item.control != null) {\r", "+\t\t\t\trowHeight = Math.max(rowHeight, item.control.getSize().y);\r", "-}\r", "-Point layout (int width, boolean resize) {\r", "-\tint y = ROW_SPACING, maxWidth = 0;\r", "-\tfor (int i = 0; i < rows.size(); i++) {\r", "-\t\tVector row = (Vector) rows.elementAt(i);\r", "-\t\tint count = row.size();\r", "-\t\tif (count > 0) {\r", "-\t\t\tint available = width - count * CoolItem.MINIMUM_WIDTH;\r", "-\t\t\tif (available < 0) available = count * CoolItem.MINIMUM_WIDTH;\r", "-\t\t\tint x = 0, rowHeight = getRowHeight(i);\r", "-\t\t\tfor (int j = 0; j < count; j++) {\r", "-\t\t\t\tCoolItem child = (CoolItem) row.elementAt(j);\r", "-\t\t\t\tint newWidth = available + CoolItem.MINIMUM_WIDTH;\r", "-\t\t\t\tif (j + 1 < count) {\r", "-\t\t\t\t\tnewWidth = Math.min(newWidth, child.requestedWidth);\r", "-\t\t\t\t\tavailable -= (newWidth - CoolItem.MINIMUM_WIDTH);\r", "+\t\trowHeight += 2 * CoolItem.MARGIN_HEIGHT;\r", "+\t\tif (row > 0) y += ROW_SPACING;\r", "+\t\r", "+\t\t/* lay the items out */\r", "+\t\tfor (int i = 0; i < count; i++) {\r", "+\t\t\tCoolItem child = items[row][i];\r", "+\t\t\tint newWidth = available + CoolItem.MINIMUM_WIDTH;\r", "+\t\t\tif (i + 1 < count) {\r", "+\t\t\t\tnewWidth = Math.min(newWidth, child.requestedWidth);\r", "+\t\t\t\tavailable -= (newWidth - CoolItem.MINIMUM_WIDTH);\r", "+\t\t\t}\r", "+\t\t\tRectangle oldBounds = child.getBounds();\r", "+\t\t\tRectangle newBounds = new Rectangle(x, y, newWidth, rowHeight);\r", "+\t\t\tif (!oldBounds.equals(newBounds)) {\r", "+\t\t\t\tchild.setBounds(newBounds.x, newBounds.y, newBounds.width, newBounds.height);\r", "+\t\t\t\tRectangle damage = new Rectangle(0, 0, 0, 0);\r", "+\t\t\t\t/* Cases are in descending order from most area to redraw to least. */\r", "+\t\t\t\tif (oldBounds.y != newBounds.y) {\r", "+\t\t\t\t\tdamage = newBounds;\r", "+\t\t\t\t\tdamage.add(oldBounds);\r", "+\t\t\t\t\t/* Redraw the row separator as well. */\r", "+\t\t\t\t\tdamage.y -= ROW_SPACING;\r", "+\t\t\t\t\tdamage.height += 2 * ROW_SPACING;\r", "-\t\t\t\tif (resize) child.setBounds(x, y, newWidth, rowHeight);\r", "-\t\t\t\tx += resize ? newWidth : child.preferredWidth;\r", "-\t\t\t}\t\t\r", "-\t\t\tmaxWidth = Math.max(maxWidth, x);\r", "-\t\t\ty += ROW_SPACING + rowHeight;\r", "+\t\t\t\telse if (oldBounds.height != newBounds.height) {\r", "+\t\t\t\t\t/* \r", "+\t\t\t\t\t * Draw from the bottom of the gripper to the bottom of the new area.\r", "+\t\t\t\t\t * (Bottom of the gripper is -3 from the bottom of the item).\r", "+\t\t\t\t\t */\r", "+\t\t\t\t\tdamage.y = newBounds.y + Math.min(oldBounds.height, newBounds.height) - 3;\r", "+\t\t\t\t\tdamage.height = newBounds.y + newBounds.height + ROW_SPACING;\r", "+\t\t\t\t\tdamage.x = oldBounds.x;\r", "+\t\t\t\t\tdamage.width = oldBounds.width;\r", "+\t\t\t\t}\r", "+\t\t\t\telse if (oldBounds.x != newBounds.x) {\r", "+\t\t\t\t\t/* Redraw only the difference between the separators. */\r", "+\t\t\t\t\tdamage.x = Math.min(oldBounds.x, newBounds.x);\r", "+\t\t\t\t\tdamage.width = Math.abs(oldBounds.x - newBounds.x) + CoolItem.MINIMUM_WIDTH;\r", "+\t\t\t\t\tdamage.y = oldBounds.y;\r", "+\t\t\t\t\tdamage.height = oldBounds.height;\r", "+\t\t\t\t}\r", "+\t\t\t\tredraw(damage.x, damage.y, damage.width, damage.height, false);\r", "+\t\t\t}\r", "+\t\t\tx += newWidth;\r", "+\t\tmaxWidth = Math.max(maxWidth, x);\r", "+\t\ty += rowHeight;\r", "-\treturn new Point(maxWidth, y);\r", "+\treturn y;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "19b481da4c7b888c36a2ce306f0b2b95", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "bundles/org.eclipse.swt/Eclipse SWT/emulated/coolbar/org/eclipse/swt/widgets/CoolBar.java", "commitBeforeChange": "df0f80ff8a78c112a82532d9d0b7052a1a5c953a", "commitAfterChange": "23e8e8964dd4f5d4f3dad5c0108120b1e7e71698", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 27, "signatureBeforeChange": " void onMouseDoubleClick(Event event)", "signatureAfterChange": " void onMouseDoubleClick(Event event)", "diff": ["+\tfixEvent(event);", "-\t\treturn;\t", "-\t}", "-", "-\tPoint location = findItem(target);", "-\tint row = location.y;", "-\tint index = location.x;", "-\tif (items[row].length > 1) {", "-\t\tPoint size = target.getSize();", "-\t\tint maxSize = getSize().x;", "-\t\tfor (int i = 0; i < items[row].length; i++) {", "-\t\t\tif (i != index) {", "-\t\t\t\tmaxSize -= items[row][i].internalGetMinimumWidth();\t", "-\t\t\t}", "-\t\t}", "-\t\tif (size.x == maxSize) {", "-\t\t\t/* The item is at its maximum width. It should be resized to its minimum width. */", "-\t\t\tint distance = size.x - target.internalGetMinimumWidth();", "-\t\t\tif (index + 1 < items[row].length) {", "-\t\t\t\t/* There is an item to the right. Maximize it. */", "-\t\t\t\tCoolItem right = items[row][index + 1];", "-\t\t\t\tmoveLeft(right, distance);", "-\t\t\t} else {", "-\t\t\t\t/* There is no item to the right. Move the item all the way right. */", "-\t\t\t\tmoveRight(target, distance);", "-\t\t\t}", "-\t\t} else if (size.x < target.preferredWidth) {", "-\t\t\t/* The item is less than its preferredWidth. Resize to preferredWidth. */", "-\t\t\tint distance = target.preferredWidth - size.x;", "-\t\t\tif (index + 1 < items[row].length) {", "-\t\t\t\tCoolItem right = items[row][index + 1];", "-\t\t\t\tmoveRight(right, distance);\t", "-\t\t\t\tdistance = target.preferredWidth - target.getSize().x;", "-\t\t\t}", "-\t\t\tif (distance > 0) {", "-\t\t\t\tmoveLeft(target, distance);", "-\t\t\t}", "-\t\t} else {", "-\t\t\t/* The item is at its minimum width. Maximize it. */", "+\t} else {", "+\t\tPoint location = findItem(target);", "+\t\tint row = location.y;", "+\t\tint index = location.x;", "+\t\tif (items[row].length > 1) {", "+\t\t\tRectangle  bounds = target.internalGetBounds();", "+\t\t\tint maxSize = getWidth ();", "-\t\t\t\t\tCoolItem item = items[row][i];", "-\t\t\t\t\titem.requestedWidth = Math.max(item.internalGetMinimumWidth(), CoolItem.MINIMUM_WIDTH); ", "+\t\t\t\t\tmaxSize -= items[row][i].internalGetMinimumWidth();\t", "-\t\t\ttarget.requestedWidth = maxSize;", "-\t\t\tlayoutItems();", "+\t\t\tif (bounds.width == maxSize) {", "+\t\t\t\t/* The item is at its maximum width. It should be resized to its minimum width. */", "+\t\t\t\tint distance = bounds.width - target.internalGetMinimumWidth();", "+\t\t\t\tif (index + 1 < items[row].length) {", "+\t\t\t\t\t/* There is an item to the right. Maximize it. */", "+\t\t\t\t\tCoolItem right = items[row][index + 1];", "+\t\t\t\t\tmoveLeft(right, distance);", "+\t\t\t\t} else {", "+\t\t\t\t\t/* There is no item to the right. Move the item all the way right. */", "+\t\t\t\t\tmoveRight(target, distance);", "+\t\t\t\t}", "+\t\t\t} else if (bounds.width < target.preferredWidth) {", "+\t\t\t\t/* The item is less than its preferredWidth. Resize to preferredWidth. */", "+\t\t\t\tint distance = target.preferredWidth - bounds.width;", "+\t\t\t\tif (index + 1 < items[row].length) {", "+\t\t\t\t\tCoolItem right = items[row][index + 1];", "+\t\t\t\t\tmoveRight(right, distance);\t", "+\t\t\t\t\tdistance = target.preferredWidth - target.internalGetBounds().width;", "+\t\t\t\t}", "+\t\t\t\tif (distance > 0) {", "+\t\t\t\t\tmoveLeft(target, distance);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\t/* The item is at its minimum width. Maximize it. */", "+\t\t\t\tfor (int i = 0; i < items[row].length; i++) {", "+\t\t\t\t\tif (i != index) {", "+\t\t\t\t\t\tCoolItem item = items[row][i];", "+\t\t\t\t\t\titem.requestedWidth = Math.max(item.internalGetMinimumWidth(), CoolItem.MINIMUM_WIDTH); ", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\ttarget.requestedWidth = maxSize;", "+\t\t\t\tlayoutItems();", "+\t\t\t}", "+\t\t\tsetCursor(hoverCursor);", "-\t\tsetCursor(hoverCursor);", "+\tfixEvent(event);"]}], "num": 57788}