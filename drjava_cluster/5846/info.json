{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "49235d1d29b1b63fc8a62b49155e057f", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "070db3b84df509f7cadbb8379190ffe2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/jpda/JPDADebugger.java", "commitBeforeChange": "5293cb4cfbc2f45d6061ba4101ad60348aa251ed", "commitAfterChange": "f68f43e5a680bb235f87f6125c6c0de6d15a12f4", "methodNumberBeforeChange": 87, "methodNumberAfterChange": 79, "signatureBeforeChange": "   private void _copyBack(ThreadReference threadRef) throws IncompatibleThreadStateException, AbsentInformationException,       InvocationException, DebugException", "signatureAfterChange": "   private void _copyVariablesFromInterpreter() throws DebugException", "diff": ["-  /** Copies the variables in the current interpreter back into the Threaf it refers to. */", "-  private void _copyBack(ThreadReference threadRef) throws IncompatibleThreadStateException, AbsentInformationException,", "-      InvocationException, DebugException {", "-    _log.log(\"Getting debug interpreter\");", "-    _log.log(\"Getting variables\");", "-    StackFrame frame = threadRef.frame(0);", "-    List<LocalVariable> vars = frame.visibleVariables();  // Added <LocalVariable> type argument; warning will go away in JDK 1.5", "-    Iterator<LocalVariable> varsIterator = vars.iterator();", "-", "-    // Get each variable from the stack frame", "-    while(varsIterator.hasNext()) {", "-      _log.log(\"Iterating through vars\");", "-      LocalVariable localVar = varsIterator.next();", "-", "-      try {", "-        Value v = _getValueOfLocalVariable(localVar, threadRef);", "-        frame = threadRef.frame(0);", "-        frame.setValue(localVar, v);", "-      }", "-      catch (ClassNotLoadedException cnle) {", "-        printMessage(\"Could not update the value of '\" + localVar.name() + \"' (class not loaded)\");", "-      }", "-      catch (InvalidTypeException ite) {", "-        printMessage(\"Could not update the value of '\" + localVar.name() + \"' (invalid type exception)\");", "-      }", "-    }", "-  }", "+    // copy variables' values out of interpreter's environment and", "+    // into the relevant stack frame", "+    List<ObjectReference> toRelease = new LinkedList<ObjectReference>();", "+      // we don't store _runningThread.frame(0) anywhere because it is invalidated", "+      // every time we invoke a method in the thread (getVariable, for example)", "+      for (LocalVariable var : _runningThread.frame(0).visibleVariables()) {", "+        Value oldVal = _runningThread.frame(0).getValue(var);", "+        StringReference name = _mirrorString(var.name(), toRelease);", "+        ArrayReference wrappedVal =", "+          (ArrayReference) _invokeMethod(_runningThread, _interpreterJVM, \"getVariable\",", "+                                         GET_VARIABLE_SIG, name);", "+        if (wrappedVal.length() == 1) { // if it can't be found (length is 0), just ignore it", "+          try {", "+            Value val = wrappedVal.getValue(0);", "+            if (var.type() instanceof PrimitiveType) {", "+              try { val = _unbox((ObjectReference) val, _runningThread); }", "+              catch (DebugException e) { error.log(\"Can't unbox variable\", e); }", "+            }", "+            if (!oldVal.equals(val)) {", "+              try { _runningThread.frame(0).setValue(var, val); }", "+              catch (InvalidTypeException e) { error.log(\"Can't set variable\", e); }", "+              catch (ClassNotLoadedException e) { error.log(\"Can't set variable\", e); }", "+            }", "+          }", "+          catch (ClassNotLoadedException e) { /* just ignore -- val must be null anyway */ }", "+        }", "+      }", "+    catch (AbsentInformationException e) { /* can't see local variables -- just ignore */ }", "+    catch (IncompatibleThreadStateException e) { throw new DebugException(e); }", "+    finally {", "+      for (ObjectReference ref : toRelease) { ref.enableCollection(); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e501be6d2e0b2db19fc1982937928cf3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/junit/DefaultJUnitModel.java", "commitBeforeChange": "771a0aee635c62bc6d0a2000fe605dc1113ef2b9", "commitAfterChange": "d1e56ac5c281c4b03c498f59138895f0f26350fa", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "      private void junitOpenDefDocs(List<OpenDefinitionsDocument> lod, boolean allTests)", "signatureAfterChange": "      private void junitOpenDefDocs(List<OpenDefinitionsDocument> lod, boolean allTests)", "diff": ["-    // if a test is running, don't start another one, but make sure someone's not", "-    // trying to notify that the previous test had finished.", "+    // If a test is running, don't start another one.", "-    synchronized(this) { if (_isTestInProgress) return; }", "-    ", "+    // Set _testInProgress flag", "+    synchronized (this) { ", "+      if (_testInProgress) return; ", "+      _testInProgress = true;", "+    }", "+      ", "-    HashMap<String,OpenDefinitionsDocument> classNamesToODDs =", "-      new HashMap<String,OpenDefinitionsDocument>();", "-    ArrayList<String> classNames = new ArrayList<String>();", "-    ArrayList<File> files = new ArrayList<File>();", "-    ", "-    // start here.", "-      ", "+    ", "+    // new ScrollableDialog(null, \"classpaths assembled in junitOpenDefDocs: \" + classpaths, \"\", \"\").show();", "+    // new ScrollableDialog(null, \"builtDir \" + builtDir + \" added to classpath\", \"\", \"\").show();", "-   for (OpenDefinitionsDocument doc: lod) {", "+    for (OpenDefinitionsDocument doc: lod) {", "-          File temp = new File (new File(classpath).getCanonicalPath());", "+          File temp = new File(new File(classpath).getCanonicalPath());", "-    for (File dir: classDirs){", "-      // foreach built directory", "-      File[] listing = dir.listFiles();", "-      ", "-      if (listing != null) {", "-        for (File entry : listing) {", "-          // for each class file in the built directory", "-          if (entry.isFile() && entry.getPath().endsWith(\".class\")) {", "-            try {", "-              JavaClass clazz = new ClassParser(entry.getCanonicalPath()).parse();", "-              String classname = clazz.getClassName(); // get classname", "-              //              System.out.println(\"looking for file for: \" + classname);", "-              int index_of_dot = classname.lastIndexOf('.');", "-              String filenameFromClassfile = classname.substring(0, index_of_dot+1);", "-              filenameFromClassfile = filenameFromClassfile.replace('.', File.separatorChar);", "-              filenameFromClassfile = filenameFromClassfile + clazz.getSourceFileName();", "-              // filenameFromClassfile now contains the location of a file with it's package directories attached", "-              // now i need to strip off the filetype (in case the dj0 file is open in drjava, the class file would point to a .java file...)", "-              index_of_dot = filenameFromClassfile.lastIndexOf('.');", "-              filenameFromClassfile = filenameFromClassfile.substring(0, index_of_dot);", "-              // now the filenameFromClassfile contains the package/filename without the extension.", "-              ", "-              for (OpenDefinitionsDocument doc: lod) {", "-                try{", "-                  File f = doc.getFile();", "-                  ", "-                  String filename = doc.getSourceRoot().getCanonicalPath() + File.separator + filenameFromClassfile;", "-                  int index = f.getCanonicalPath().lastIndexOf('.');", "-                  String filenameFromDoc = f.getCanonicalPath().substring(0, index);", "-                  String ext = f.getCanonicalPath().substring(index, f.getCanonicalPath().length());", "-                  // filenameFromDoc now contains the filename minus the extension", "-                  ", "-                  if (filenameFromDoc.equals(filename) && ", "-                      (ext.equals(\".java\") || ext.equals(\".dj0\") || ext.equals(\".dj1\")  || ext.equals(\".dj2\"))) {", "-                    //                    System.out.println(\"testing: \" + classname + \" from \" + f.getCanonicalPath());", "-                    //                    Method methods[] = clazz.getMethods();", "-                    //                    for(Method d : methods){", "-                    //                      System.out.println(\" method: \" + d);", "-                    //                    }", "-                    classNames.add(classname);", "-                    files.add(f);", "-                    classNamesToODDs.put(classname, doc);", "-                    break;", "+    // new ScrollableDialog(null, \"classDirs assembled\", \"\", classDirs.toString()).show();", "+    ", "+    ArrayList<File> files = new ArrayList<File>();", "+    ArrayList<String> classNames = new ArrayList<String>();", "+    HashMap<String, OpenDefinitionsDocument> classNamesToODDs =", "+      new HashMap<String, OpenDefinitionsDocument>();", "+    ", "+    try {", "+      for (File dir: classDirs) { // foreach built directory", "+        File[] listing = dir.listFiles();", "+        ", "+        if (listing != null) {", "+          for (File entry : listing) {", "+            // for each class file in the built directory", "+            if (entry.isFile() && entry.getPath().endsWith(\".class\")) {", "+              try {", "+                JavaClass clazz = new ClassParser(entry.getCanonicalPath()).parse();", "+                String classname = clazz.getClassName(); // get classname", "+                //                System.out.println(\"looking for file for: \" + classname);", "+                int indexOfDot = classname.lastIndexOf('.');", "+                ", "+                /** The prefix preceding the unqualified name of the class (either empty or ends with dot). */", "+                String prefixString = classname.substring(0, indexOfDot + 1);  ", "+                /** The prefix as a file system path name. */", "+                String prefixPath = prefixString.replace('.', File.separatorChar);", "+                /** The pathname (from a classpath root) for the file (including the file name) */", "+                String filePath = prefixPath + clazz.getSourceFileName();", "+                //                System.out.println(\"Class file is:  \" + filePath);", "+                /** The index in filePath of the dot preceding the class extension \"class\". */", "+                int indexOfExtDot = filePath.lastIndexOf('.');", "+                if (indexOfExtDot == -1) break;  // RMI stub class files return source file names without extensions", "+                /** The (relative) path name for the class. */", "+                String pathName = filePath.substring(0, indexOfExtDot);", "+                ", "+                for (OpenDefinitionsDocument doc: lod) {", "+                  try {", "+                    ", "+                    /** The file for the next document in lod. */", "+                    File f = doc.getFile();", "+                    ", "+                    /** The full path name for the class file (without extension) for entr--assuming it has same root as doc. */", "+                    String fullPathName = doc.getSourceRoot().getCanonicalPath() + File.separator + pathName;", "+                    ", "+                    /** The full path name for file f (including extension) */", "+                    String pathForF = f.getCanonicalPath();", "+                    ", "+                    /** The index of the last dot in the full path name for f (the file for doc). */", "+                    int index = pathForF.lastIndexOf('.');", "+                    if (index == -1) break; // the file for doc does not have an extension", "+                    ", "+                    String fullPathNameFromDoc = pathForF.substring(0, index);", "+                    String ext = pathForF.substring(index, pathForF.length());", "+                    // filenameFromDoc now contains the filename minus the extension", "+                    ", "+                    if (fullPathNameFromDoc.equals(fullPathName) && ", "+                        (ext.equals(\".java\") || ext.equals(\".dj0\") || ext.equals(\".dj1\")  || ext.equals(\".dj2\"))) {", "+                      if (classNamesToODDs.containsKey(classname)) break;  // class already added to classNames", "+                      classNames.add(classname);", "+                      files.add(f);", "+                      classNamesToODDs.put(classname, doc);", "+                      // new ScrollableDialog(null, \"Ready to break\", classname, f.toString()).show();", "+                      break;", "+                    }", "+                  catch(InvalidPackageException e) { /* do nothing */ }", "+                  catch(IOException e) { /* do nothing */ }", "+                  catch(IllegalStateException e) { /* do nothing; doc is untitled */ }", "-                catch(InvalidPackageException e) { /* do nothing */ }", "-                catch(IOException e) { /* do nothing */ }", "-                catch(IllegalStateException e) { /* do nothing; doc is untitled */ }", "+              catch(IOException e) { ", "+           ", "+              /* can't read class file */ }", "+              catch(ClassFormatException e) { ", "+              /* class file is bad */ }", "+              // match source file to odd (if possible)", "+              // if match, add clasname to test suite", "-            catch(IOException e) { /* can't read class file */ }", "-            catch(ClassFormatException e) { /* class file is bad */ }", "-            // match source file to odd (if possible)", "-            // if match, add clasname to test suite", "-    ", "-    _isTestInProgress = true;", "+    catch(Throwable t) {", "+//      new ScrollableDialog(null, \"UnexceptedExceptionThrown\", t.toString(), \"\").show();", "+      throw new UnexpectedException(t); ", "+    }", "+    finally { ", "+//      new ScrollableDialog(null, \"junit setup loop terminated\", classNames.toString(), \"\").show();", "+    }", "-    // synchronized over this so that junitStarted is ensured to be ", "+    // synchronized over this so that junitStarted is ", "+//    new ScrollableDialog(null, \"Candidate test class names are:\", \"\", classNames.toString()).show();", "-      synchronized (this) {", "-        List<String> tests = _jvm.runTestSuite(classNames, files, allTests);", "-        ArrayList<OpenDefinitionsDocument> odds = new ArrayList<OpenDefinitionsDocument>();", "-        for (String name: tests) { odds.add(classNamesToODDs.get(name)); }", "-        _notifier.junitStarted(odds);", "-      }", "+//        new ScrollableDialog(null, \"DefaultJunitModel: holding _compileModel lock\", \"\", \"\").show();", "+        /** Set up junit test suite on slave JVM; get TestCase classes forming that suite */", "+        try {", "+          List<String> tests = _jvm.findTestClasses(classNames, files);", "+          if (tests == null || tests.isEmpty()) {", "+            nonTestCase(allTests);", "+            return;", "+          }", "+          ", "+          ArrayList<OpenDefinitionsDocument> odds = new ArrayList<OpenDefinitionsDocument>();", "+          for (String name: tests) { odds.add(classNamesToODDs.get(name)); }", "+   ", "+          try {", "+            /** Run the junit test suite that has already been set up on the slave JVM */", "+            _notifier.junitStarted(odds);", "+            //          new ScrollableDialog(null, \"junitStarted executed in DefaultJunitModel\", \"\", \"\").show();", "+            _jvm.runTestSuite();", "+            ", "+          }", "+          catch(IOException e) { ", "+            _notifier.junitEnded();  // balances junitStarted()", "+            throw new UnexpectedException(e); ", "+          }", "+        }", "+        catch(IOException e) { throw new UnexpectedException(e); }", "+          "]}], "num": 5846}