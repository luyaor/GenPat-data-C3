{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "12b8c786dd8f967b61c735c65c156c5b", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "91108c173ecb7aa9ecc35d70657e6262", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 310, "methodNumberAfterChange": 239, "signatureBeforeChange": "   public StaticMethodInvocation lookupStaticMethod(Type t, final String name,                                                     final Iterable<? extends Type> typeArgs,                                                     final Iterable<? extends Expression> args,                                                    final Option<Type> expected)     throws InvalidTargetException, InvalidTypeArgumentException, UnmatchedLookupException", "signatureAfterChange": "      public StaticMethodInvocation lookupStaticMethod(Type t, String name,                                                     final Iterable<? extends Type> typeArgs,                                                     final Iterable<? extends Expression> args,                                                    final Option<Type> expected)     throws InvalidTypeArgumentException, UnmatchedLookupException", "diff": ["+  ", "+  public StaticMethodInvocation lookupStaticMethod(Type t, String name, ", "+                                                   final Iterable<? extends Type> typeArgs, ", "+                                                   final Iterable<? extends Expression> args,", "+                                                   final Option<Type> expected)", "+    throws InvalidTypeArgumentException, UnmatchedLookupException {", "+    MethodFinder<StaticMethodInvocation> finder = new MethodFinder<StaticMethodInvocation>(name, true) {", "+      public StaticMethodInvocationCandidate makeInvocationCandidate(DJMethod m, ClassType declaringType) {", "+        return new StaticMethodInvocationCandidate(m, declaringType, typeArgs, args, expected);", "+      }", "+    };", "+    return finder.findSingleMethod(t);", "+  }", "-   */", "-  public StaticMethodInvocation lookupStaticMethod(Type t, final String name, ", "-                                                   final Iterable<? extends Type> typeArgs, ", "-                                                   final Iterable<? extends Expression> args,", "-                                                   final Option<Type> expected)", "-    throws InvalidTargetException, InvalidTypeArgumentException, UnmatchedLookupException {", "-    debug.logStart(new String[]{\"t\",\"name\",\"typeArgs\",\"arg types\",\"expected\"},", "-                   wrap(t), name, wrap(typeArgs), wrap(IterUtil.map(args, NodeProperties.NODE_TYPE)),", "-                   wrap(expected)); try {", "-                     ", "-    class LookupMethod extends TypeAbstractVisitor<Iterable<StaticMethodInvocation>> {", "-      ", "-      private Predicate<? super DJMethod> _matchMethod;", "-      ", "-      public LookupMethod(final boolean includePrivate) {", "-        _matchMethod = new Predicate<DJMethod>() {", "-          public boolean contains(DJMethod m) {", "-            if (m.declaredName().equals(name)) {", "-              if (includePrivate) { return m.isStatic(); }", "-              else { return m.isStatic() && !m.accessibility().equals(Access.PRIVATE); }", "-            }", "-            else { return false; }", "-          }", "-        };", "-      }", "-      ", "-      public Iterable<StaticMethodInvocation> defaultCase(Type t) { return IterUtil.empty(); }", "-      ", "-      @Override public Iterable<StaticMethodInvocation> forSimpleClassType(SimpleClassType t) {", "-        Iterable<DJMethod> methods = IterUtil.filter(t.ofClass().declaredMethods(), _matchMethod);", "-//        System.out.println(\"Matching methods in type \" + userRepresentation(t) + \": \" +", "-//                           IterUtil.multilineToString(matchingMethods));", "-        Lambda<DJMethod, SignatureChecker> makeChecker = new Lambda<DJMethod, SignatureChecker>() {", "-          public SignatureChecker value(DJMethod m) {", "-            return makeChecker(m.declaredTypeParameters(), typeArgs, SymbolUtil.declaredParameterTypes(m),", "-                               args, m.returnType(), expected);", "-          }", "-        };", "-        Lambda2<DJMethod, SignatureChecker, StaticMethodInvocation> makeResult = ", "-          new Lambda2<DJMethod, SignatureChecker, StaticMethodInvocation>() {", "-          public StaticMethodInvocation value(DJMethod m, SignatureChecker checker) {", "-            SubstitutionMap sigma = new SubstitutionMap(checker.typeParameters(), checker.typeArguments());", "-            Type returned = substitute(m.returnType(), sigma);", "-            // TODO: Handle the thrown types", "-            return new StaticMethodInvocation(m, returned, checker.typeArguments(), checker.arguments(),", "-                                              m.thrownTypes());", "-          }", "-        };", "-        return findSignatureMatches(methods, makeChecker, makeResult);", "-      }", "-      ", "-      @Override public Iterable<StaticMethodInvocation> forRawClassType(RawClassType t) {", "-        // TODO: Handle raw member access warnings; make sure this is correct", "-        Iterable<DJMethod> methods = IterUtil.filter(t.ofClass().declaredMethods(), _matchMethod);", "-//        System.out.println(\"Matching methods in type \" + userRepresentation(t) + \": \" +", "-//                           IterUtil.multilineToString(matchingMethods));", "-        Lambda<DJMethod, SignatureChecker> makeChecker = new Lambda<DJMethod, SignatureChecker>() {", "-          public SignatureChecker value(DJMethod m) {", "-            return makeChecker(IterUtil.<VariableType>empty(), typeArgs, ", "-                               IterUtil.map(SymbolUtil.declaredParameterTypes(m), ERASE_LAMBDA),", "-                               args, m.returnType(), expected);", "-          }", "-        };", "-        Lambda2<DJMethod, SignatureChecker, StaticMethodInvocation> makeResult = ", "-          new Lambda2<DJMethod, SignatureChecker, StaticMethodInvocation>() {", "-          public StaticMethodInvocation value(DJMethod m, SignatureChecker checker) {", "-            Type returned = erase(m.returnType());", "-            // TODO: Handle the thrown types", "-            return new StaticMethodInvocation(m, returned, checker.typeArguments(), checker.arguments(),", "-                                              m.thrownTypes());", "-          }", "-        };", "-        return findSignatureMatches(methods, makeChecker, makeResult);", "-      }", "-      ", "-      @Override public Iterable<StaticMethodInvocation> forParameterizedClassType(ParameterizedClassType t) {", "-        final SubstitutionMap classSigma = ", "-          new SubstitutionMap(SymbolUtil.allTypeParameters(t.ofClass()), t.typeArguments());", "-        Iterable<DJMethod> methods = IterUtil.filter(t.ofClass().declaredMethods(), _matchMethod);", "-//        System.out.println(\"Matching methods in type \" + userRepresentation(t) + \": \" +", "-//                           IterUtil.multilineToString(matchingMethods));", "-        Lambda<DJMethod, SignatureChecker> makeChecker = new Lambda<DJMethod, SignatureChecker>() {", "-          public SignatureChecker value(DJMethod m) {", "-            // TODO: substitute out class type parameters from the method's parameters' bounds", "-            //       (how does the JLS handle this?)", "-            return makeChecker(m.declaredTypeParameters(), typeArgs, ", "-                               substitute(SymbolUtil.declaredParameterTypes(m), classSigma),", "-                               args, m.returnType(), expected);", "-          }", "-        };", "-        Lambda2<DJMethod, SignatureChecker, StaticMethodInvocation> makeResult = ", "-          new Lambda2<DJMethod, SignatureChecker, StaticMethodInvocation>() {", "-          public StaticMethodInvocation value(DJMethod m, SignatureChecker checker) {", "-            SubstitutionMap sigma = new SubstitutionMap(checker.typeParameters(), ", "-                                                        checker.typeArguments());", "-            Type rawReturned = m.returnType();", "-            Type returned = substitute(substitute(rawReturned, classSigma), sigma);", "-            // TODO: Handle the thrown types", "-            return new StaticMethodInvocation(m, returned, checker.typeArguments(), ", "-                                              checker.arguments(), m.thrownTypes());", "-          }", "-        };", "-        return findSignatureMatches(methods, makeChecker, makeResult);", "-      }", "-      ", "-    }", "-    Iterable<? extends StaticMethodInvocation> results = lookupMember(t, new LookupMethod(true), ", "-                                                                      new LookupMethod(false));", "-    // TODO: provide more error-message information", "-    int matches = IterUtil.sizeOf(results);", "-    if (matches != 1) { throw new UnmatchedLookupException(matches); }", "-    else { return IterUtil.first(results); }", "-    ", "-    } finally { debug.logEnd(); }", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c484df9f70cc7e3fdcab0f316602869f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 297, "methodNumberAfterChange": 237, "signatureBeforeChange": "   public ObjectMethodInvocation lookupMethod(final Expression object, final String name,                                               final Iterable<? extends Type> typeArgs,                                               final Iterable<? extends Expression> args,                                              final Option<Type> expected)     throws InvalidTargetException, InvalidTypeArgumentException, UnmatchedLookupException", "signatureAfterChange": "      public ObjectMethodInvocation lookupMethod(final Expression object, String name,                                               final Iterable<? extends Type> typeArgs,                                               final Iterable<? extends Expression> args,                                              final Option<Type> expected)       throws InvalidTypeArgumentException, UnmatchedLookupException", "diff": ["+  ", "+  public ObjectMethodInvocation lookupMethod(final Expression object, String name, ", "+                                             final Iterable<? extends Type> typeArgs, ", "+                                             final Iterable<? extends Expression> args,", "+                                             final Option<Type> expected)", "+      throws InvalidTypeArgumentException, UnmatchedLookupException {", "+    MethodFinder<ObjectMethodInvocation> finder = new MethodFinder<ObjectMethodInvocation>(name, false) {", "+      public ObjectMethodInvocationCandidate makeInvocationCandidate(DJMethod m, ClassType declaringType) {", "+        return new ObjectMethodInvocationCandidate(m, declaringType, object, typeArgs, args, expected);", "+      }", "+    };", "+    return finder.findSingleMethod(NodeProperties.getType(object));", "+  }", "-   */", "-  public ObjectMethodInvocation lookupMethod(final Expression object, final String name, ", "-                                             final Iterable<? extends Type> typeArgs, ", "-                                             final Iterable<? extends Expression> args,", "-                                             final Option<Type> expected)", "-    throws InvalidTargetException, InvalidTypeArgumentException, UnmatchedLookupException {", "-    debug.logStart(new String[]{\"t\",\"name\", \"typeArgs\",\"arg types\",\"expected\"},", "-                   wrap(NodeProperties.getType(object)), name, wrap(typeArgs),", "-                   wrap(IterUtil.map(args, NodeProperties.NODE_TYPE)), wrap(expected)); try {", "-", "-    class LookupMethod extends TypeAbstractVisitor<Iterable<ObjectMethodInvocation>> {", "-      ", "-      private Predicate<? super DJMethod> _matchMethod;", "-      ", "-      public LookupMethod(final boolean includePrivate) {", "-        _matchMethod = new Predicate<DJMethod>() {", "-          public boolean contains(DJMethod m) {", "-            if (m.declaredName().equals(name)) {", "-              return includePrivate || !m.accessibility().equals(Access.PRIVATE);", "-            }", "-            else { return false; }", "-          }", "-        };", "-      }", "-      ", "-      public Iterable<ObjectMethodInvocation> defaultCase(Type t) { return IterUtil.empty(); }", "-      ", "-      @Override public Iterable<ObjectMethodInvocation> forSimpleClassType(final SimpleClassType t) {", "-        Iterable<DJMethod> methods = IterUtil.filter(t.ofClass().declaredMethods(), _matchMethod);", "-//        System.out.println(\"Matching methods in type \" + userRepresentation(t) + \": \" +", "-//                           IterUtil.multilineToString(matchingMethods));", "-        Lambda<DJMethod, SignatureChecker> makeChecker = new Lambda<DJMethod, SignatureChecker>() {", "-          public SignatureChecker value(DJMethod m) {", "-            return makeChecker(m.declaredTypeParameters(), typeArgs, SymbolUtil.declaredParameterTypes(m),", "-                               args, m.returnType(), expected);", "-          }", "-        };", "-        Lambda2<DJMethod, SignatureChecker, ObjectMethodInvocation> makeResult = ", "-          new Lambda2<DJMethod, SignatureChecker, ObjectMethodInvocation>() {", "-          public ObjectMethodInvocation value(DJMethod m, SignatureChecker checker) {", "-            SubstitutionMap sigma = new SubstitutionMap(checker.typeParameters(), checker.typeArguments());", "-            Type returned = substitute(m.returnType(), sigma);", "-            // TODO: Handle the thrown types", "-            return new ObjectMethodInvocation(m, returned, makeCast(t, object), checker.typeArguments(), ", "-                                              checker.arguments(), m.thrownTypes());", "-          }", "-        };", "-        return findSignatureMatches(methods, makeChecker, makeResult);", "-      }", "-      ", "-      @Override public Iterable<ObjectMethodInvocation> forRawClassType(final RawClassType t) {", "-        // TODO: Handle raw member access warnings; make sure this is correct", "-        Iterable<DJMethod> methods = IterUtil.filter(t.ofClass().declaredMethods(), _matchMethod);", "-//        System.out.println(\"Matching methods in type \" + userRepresentation(t) + \": \" +", "-//                           IterUtil.multilineToString(matchingMethods));", "-        Lambda<DJMethod, SignatureChecker> makeChecker = new Lambda<DJMethod, SignatureChecker>() {", "-          public SignatureChecker value(DJMethod m) {", "-            return makeChecker(IterUtil.<VariableType>empty(), typeArgs, ", "-                               IterUtil.map(SymbolUtil.declaredParameterTypes(m), ERASE_LAMBDA),", "-                               args, m.returnType(), expected);", "-          }", "-        };", "-        Lambda2<DJMethod, SignatureChecker, ObjectMethodInvocation> makeResult = ", "-          new Lambda2<DJMethod, SignatureChecker, ObjectMethodInvocation>() {", "-          public ObjectMethodInvocation value(DJMethod m, SignatureChecker checker) {", "-            Type returned = erase(m.returnType());", "-            // TODO: Handle the thrown types", "-            return new ObjectMethodInvocation(m, returned, makeCast(t, object), checker.typeArguments(), ", "-                                              checker.arguments(), m.thrownTypes());", "-          }", "-        };", "-        return findSignatureMatches(methods, makeChecker, makeResult);", "-      }", "-      ", "-      @Override public Iterable<ObjectMethodInvocation> forParameterizedClassType(final ParameterizedClassType t) {", "-        final SubstitutionMap classSigma =", "-          new SubstitutionMap(SymbolUtil.allTypeParameters(t.ofClass()), t.typeArguments());", "-        Iterable<DJMethod> methods = IterUtil.filter(t.ofClass().declaredMethods(), _matchMethod);", "-//        System.out.println(\"Matching methods in type \" + userRepresentation(t) + \": \" +", "-//                           IterUtil.multilineToString(matchingMethods));", "-        Lambda<DJMethod, SignatureChecker> makeChecker = new Lambda<DJMethod, SignatureChecker>() {", "-          public SignatureChecker value(DJMethod m) {", "-            // TODO: substitute out class type parameters from the method's parameters' bounds", "-            //       (how does the JLS handle this?)", "-            return makeChecker(m.declaredTypeParameters(), typeArgs, ", "-                               substitute(SymbolUtil.declaredParameterTypes(m), classSigma),", "-                               args, m.returnType(), expected);", "-          }", "-        };", "-        Lambda2<DJMethod, SignatureChecker, ObjectMethodInvocation> makeResult = ", "-          new Lambda2<DJMethod, SignatureChecker, ObjectMethodInvocation>() {", "-          public ObjectMethodInvocation value(DJMethod m, SignatureChecker checker) {", "-            SubstitutionMap sigma = new SubstitutionMap(checker.typeParameters(), checker.typeArguments());", "-            Type rawReturned = m.returnType();", "-            Type returned = substitute(substitute(rawReturned, classSigma), sigma);", "-            // TODO: Handle the thrown types", "-            return new ObjectMethodInvocation(m, returned, makeCast(t, object), checker.typeArguments(), ", "-                                              checker.arguments(), m.thrownTypes());", "-          }", "-        };", "-        return findSignatureMatches(methods, makeChecker, makeResult);", "-      }", "-      ", "-    }", "-    Iterable<? extends ObjectMethodInvocation> results = lookupMember(NodeProperties.getType(object), ", "-                                                                      new LookupMethod(true), ", "-                                                                      new LookupMethod(false));", "-    // TODO: provide more error-message information", "-    int matches = IterUtil.sizeOf(results);", "-    if (matches != 1) { throw new UnmatchedLookupException(matches); }", "-    else { return IterUtil.first(results); }", "-    ", "-    } finally { debug.logEnd(); }", "-  }"]}], "num": 21230}