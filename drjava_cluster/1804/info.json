{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f995afc838ffcba5dfc186c9e776eff9", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "80de2a6dc877ba07c329898f8835fc05", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "69a380647f3d586f130ea02ad1e8381a390045e3", "commitAfterChange": "739371db1261b11c3be5fd70233012a49b45b7ca", "methodNumberBeforeChange": 202, "methodNumberAfterChange": 202, "signatureBeforeChange": "   private Expression makeCast(Type target, Expression e)", "signatureAfterChange": "   private Expression makeCast(Type target, Expression e)", "diff": ["-        NodeProperties.setConvertedType(e, erasedClass(target));", "+        NodeProperties.setConvertedType(result, erasedClass(target));", "+        if (NodeProperties.hasValue(e)) {", "+          Object orig = NodeProperties.getValue(e);", "+          Class<?> t = NodeProperties.getConvertedType(result).value();", "+          NodeProperties.setValue(result, ExpressionEvaluator.convert(orig, t));", "+        }", "+      }", "+      else {", "+        if (NodeProperties.hasValue(e)) { NodeProperties.setValue(result, NodeProperties.getValue(e)); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b1829c4323409bd321488b1b44cc48b8", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/DefaultCompilerModel.java", "commitBeforeChange": "c8a7a8a9d3d089ab42661ede7d141969c6ed2339", "commitAfterChange": "edb148d96e488bb5de94fe3df6063e44425ab166", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "   private synchronized void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "signatureAfterChange": "   private synchronized void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "diff": ["+    ClasspathVector extraClasspath = new ClasspathVector();", "+    if (_getter.getFileGroupingState().isProjectActive()) ", "+      extraClasspath.addAll(_getter.getFileGroupingState().getExtraClasspath());", "+    for(File f : DrJava.getConfig().getSetting(OptionConstants.EXTRA_CLASSPATH)) {", "+      extraClasspath.add(f);", "+    }", "+//    System.out.println(\"Extra classpath passed to compiler: \" + extraClasspath.toString());", "+    compiler.setExtraClassPath(extraClasspath);", "-      files = javaFileSet.toArray(new File[0]);", "+      files = javaFileSet.toArray(new File[javaFileSet.size()]);", "-      CompilerError[] compilerErrorsArray = (CompilerError[]) compilerErrors.toArray(new CompilerError[0]);", "+      CompilerError[] compilerErrorsArray = (CompilerError[]) compilerErrors.toArray(new CompilerError[compilerErrors.size()]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "edbac51b9da95c50120e36624842f2a0", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/DefinitionsPane.java", "commitBeforeChange": "ff27298276d0b205036fe4b017017ca3896e9890", "commitAfterChange": "4ddb555fbb20c498ee5f44bc087ce9c848b2e79c", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "   public void processKeyEvent(KeyEvent e)", "signatureAfterChange": "   public void processKeyEvent(KeyEvent e)", "diff": ["-      // The following conditional fixes bug 676586 by ignoring typed events when the meta key is down", "-      if (((e.getModifiers() & InputEvent.META_MASK) != 0) && e.getKeyCode() == KeyEvent.VK_UNDEFINED) {", "-        return;", "+      // Allows one step undoing of the keystrokes defined on the keymap (e.g. enter, tab, '{', '}', ':').", "+      Keymap km = getKeymap();", "+      if (km.isLocallyDefined(ks) || km.isLocallyDefined(KeyStroke.getKeyStroke(ks.getKeyChar()))) {  ", "+        CompoundUndoManager undoMan = _doc.getDocument().getUndoManager();", "+        int key = undoMan.startCompoundEdit();        ", "+        super.processKeyEvent(e);", "+        undoMan.endCompoundEdit(key);", "+        e.consume();", "-      ", "-      // The following conditional fixes ease of use issue 693253 by checking if a typed event is", "-      // shift-delete or shift-backspace and then performing a delete or backspace operation,", "-      // respectively", "-      if ((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) {", "-        int newModifiers = e.getModifiers() & ~(InputEvent.SHIFT_MASK);", "-        ", "-        KeyStroke newKs = KeyStroke.getKeyStroke(ks.getKeyCode(), newModifiers, ks.isOnKeyRelease());", "-        String name = KeyBindingManager.Singleton.getName(newKs);", "-        ", "-        if (name != null && (name.equals(\"Delete Previous\") || name.equals(\"Delete Next\"))) {", "-          // We are unsure about the third and fourth arguments (e and e.getSource()); we simply", "-            // reuse the original values", "-          SwingUtilities.notifyAction(KeyBindingManager.Singleton.get(newKs), newKs, e, e.getSource(), newModifiers);", "-          e.consume();", "+      else {", "+        // The following conditional fixes bug 676586 by ignoring typed events when the meta key is down", "+        if (((e.getModifiers() & InputEvent.META_MASK) != 0) && e.getKeyCode() == KeyEvent.VK_UNDEFINED) {", "-      }", "-      ", "-      // backspace deletes twice without this check, overrides other keystrokes", "-      // that use the mask modifier", "-      if (((ks.getModifiers() & mask) == 0) && ks.getKeyChar() != '\\010') {", "-        super.processKeyEvent(e);", "-      }", "-    }    ", "+        ", "+        // The following conditional fixes ease of use issue 693253 by checking if a typed event is", "+        // shift-delete or shift-backspace and then performing a delete or backspace operation,", "+        // respectively", "+        if ((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) {", "+          int newModifiers = e.getModifiers() & ~(InputEvent.SHIFT_MASK);", "+          ", "+          KeyStroke newKs = KeyStroke.getKeyStroke(ks.getKeyCode(), newModifiers, ks.isOnKeyRelease());", "+          String name = KeyBindingManager.Singleton.getName(newKs);", "+          ", "+          if (name != null && (name.equals(\"Delete Previous\") || name.equals(\"Delete Next\"))) {", "+            // We are unsure about the third and fourth arguments (e and e.getSource()); we simply", "+            // reuse the original values", "+            SwingUtilities.notifyAction(KeyBindingManager.Singleton.get(newKs), newKs, e, e.getSource(), newModifiers);", "+            e.consume();", "+            return;", "+          }", "+        }", "+        ", "+        // backspace deletes twice without this check, overrides other keystrokes", "+        // that use the mask modifier", "+        if (((ks.getModifiers() & mask) == 0) && ks.getKeyChar() != '\\010') {", "+          super.processKeyEvent(e);", "+        }", "+      }    ", "+    }"]}], "num": 1804}