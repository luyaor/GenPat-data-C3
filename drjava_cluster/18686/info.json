{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7bc209c56b4268e0a117759666fc24ba", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2430446c5b8b3d9a911cb22f63da2c36", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 135, "methodNumberAfterChange": 135, "signatureBeforeChange": "          public void testForIncrementExpression()", "signatureAfterChange": "          public void testForIncrementExpression()", "diff": ["-      ComplexNameReference nf = new ComplexNameReference(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"Ned\")), new Word(SourceInfo.NO_INFO, \"Flanders\"));", "-      PositivePrefixIncrementExpression ppi = new PositivePrefixIncrementExpression(SourceInfo.NO_INFO, nf);", "+      ComplexNameReference nf = ", "+        new ComplexNameReference(SourceInfo.NONE, ", "+                                 new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"Ned\")), ", "+                                 new Word(SourceInfo.NONE, \"Flanders\"));", "+      PositivePrefixIncrementExpression ppi = new PositivePrefixIncrementExpression(SourceInfo.NONE, nf);", "-      PositivePrefixIncrementExpression ppi2 = new PositivePrefixIncrementExpression(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"int\")));", "+      PositivePrefixIncrementExpression ppi2 = ", "+        new PositivePrefixIncrementExpression(SourceInfo.NONE, ", "+                                              new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"int\")));", "-      PositivePrefixIncrementExpression ppi3 = new PositivePrefixIncrementExpression(SourceInfo.NO_INFO, new Parenthesized(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"int\"))));", "+      Parenthesized p1 = ", "+        new Parenthesized(SourceInfo.NONE, new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"int\")));", "+      PositivePrefixIncrementExpression ppi3 = new PositivePrefixIncrementExpression(SourceInfo.NONE, p1);", "-      assertEquals(\"There should now be 4 errors\", 4, errors.size());  // For some reason, generated error is not a duplicate", "+      assertEquals(\"There should now be 4 errors\", 4, errors.size());  // Generated error is not a duplicate", "-      //test that words with a post-decrement operator afterwards only work if they already have a value and aren't final.", "+      // Test that words with post-decrement operator only work if they already have a value and aren't final.", "-      NegativePostfixIncrementExpression npi = new NegativePostfixIncrementExpression(SourceInfo.NO_INFO, nf);", "+      NegativePostfixIncrementExpression npi = new NegativePostfixIncrementExpression(SourceInfo.NONE, nf);", "-      // test that attempting to decrement the value of a field that doesn't have a value will throw an error", "+      // Test that attempting to decrement the value of a field that doesn't have a value will throw an error", "-        new NegativePostfixIncrementExpression(SourceInfo.NO_INFO, ", "-                                               new SimpleNameReference(SourceInfo.NO_INFO, ", "-                                                                       new Word(SourceInfo.NO_INFO, \"int\")));", "+        new NegativePostfixIncrementExpression(SourceInfo.NONE, ", "+                                               new SimpleNameReference(SourceInfo.NONE, ", "+                                                                       new Word(SourceInfo.NONE, \"int\")));", "-      NegativePostfixIncrementExpression npi3 = ", "-        new NegativePostfixIncrementExpression(SourceInfo.NO_INFO, ", "-                                               new Parenthesized(SourceInfo.NO_INFO, ", "-                                                                 new SimpleNameReference(SourceInfo.NO_INFO, ", "-                                                                                         new Word(SourceInfo.NO_INFO, \"int\"))));", "+      Parenthesized p2 = ", "+        new Parenthesized(SourceInfo.NONE, new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"int\")));", "+      NegativePostfixIncrementExpression npi3 = new NegativePostfixIncrementExpression(SourceInfo.NONE, p2);", "-      PositivePrefixIncrementExpression ppi4 = ", "-        new PositivePrefixIncrementExpression(SourceInfo.NO_INFO, ", "-                                              new Parenthesized(SourceInfo.NO_INFO, ", "-                                                                new NegativePrefixIncrementExpression(SourceInfo.NO_INFO, nf)));", "+      Parenthesized p3 = new Parenthesized(SourceInfo.NONE, new NegativePrefixIncrementExpression(SourceInfo.NONE, nf));", "+      PositivePrefixIncrementExpression ppi4 = new PositivePrefixIncrementExpression(SourceInfo.NONE, p3);", "-        new PositivePrefixIncrementExpression(SourceInfo.NO_INFO, ", "-                                              new SimpleNameReference(SourceInfo.NO_INFO, ", "-                                                                      new Word(SourceInfo.NO_INFO, \"s\")));", "+        new PositivePrefixIncrementExpression(SourceInfo.NONE, ", "+                                              new SimpleNameReference(SourceInfo.NONE, ", "+                                                                      new Word(SourceInfo.NONE, \"s\")));", "-      PositivePrefixIncrementExpression ppi6 = new PositivePrefixIncrementExpression(SourceInfo.NO_INFO, new Parenthesized(SourceInfo.NO_INFO, new Parenthesized(SourceInfo.NO_INFO, nf)));", "+      PositivePrefixIncrementExpression ppi6 = ", "+        new PositivePrefixIncrementExpression(SourceInfo.NONE, new Parenthesized(SourceInfo.NONE, ", "+                                                                                 new Parenthesized(SourceInfo.NONE, nf)));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f771d23263bc2e045d8b56d8f84e70c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/tree/EnumDeclaration.java", "commitBeforeChange": "73d8f0963e3941f0992013e94dd38c610fad8320", "commitAfterChange": "79f5d66e5d12491f568b49d5064798e6d989d102", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "    static List<Node> AddValues(String enumTypeName, List<Node> body, List<EnumConstant> consts)", "signatureAfterChange": "    static List<Node> AddValues(String enumTypeName, List<Node> body, List<EnumConstant> consts)", "diff": ["-    String[] consts_names = new String[consts.size()];", "-    for(int i = 0; i < consts_names.length; i++)", "-      consts_names[i] = consts.get(i).getName();", "-", "-    int accessFlags  = java.lang.reflect.Modifier.PRIVATE | java.lang.reflect.Modifier.STATIC | java.lang.reflect.Modifier.FINAL;", "-", "+    // public static Foo[] values() { return new Foo[]{ Foo.FIRST, Foo.SECOND, Foo.THIRD }; }", "-    TypeName valuesType = new ArrayTypeName(enumType, 1, false);", "-    List<Expression> sizes = new LinkedList<Expression>();", "-    sizes.add(new IntegerLiteral(String.valueOf(consts_names.length)));", "-    for( int i = 0; i < consts_names.length; i++ )", "-      cells.add(new StaticFieldAccess(enumType, consts_names[i]));", "-    ArrayAllocation allocExpr = new ArrayAllocation(enumType, new ArrayAllocation.TypeDescriptor(sizes, 1, new ArrayInitializer(cells), 0, 0));", "-    newbody.add(new FieldDeclaration(accessFlags, valuesType, \"$VALUES\", allocExpr));", "-", "-    accessFlags  = java.lang.reflect.Modifier.PUBLIC | java.lang.reflect.Modifier.STATIC | java.lang.reflect.Modifier.FINAL;", "-    List<FormalParameter> vparams = new LinkedList<FormalParameter>();", "-    ///*for testing jlugo code*/vparams.add(new FormalParameter(false, new ReferenceTypeName(\"String\"), \"s\"));", "-    List<Node> stmts = new LinkedList<Node>();", "-    stmts.add(new ReturnStatement(new CastExpression(enumType, new ObjectMethodCall(new StaticFieldAccess(enumType, \"$VALUES\"), \"clone\", null))));", "-    newbody.add(new MethodDeclaration(accessFlags, valuesType, \"values\", vparams, new LinkedList<ReferenceTypeName>(), new BlockStatement(stmts)));", "-", "-    List<FormalParameter> voparams = new LinkedList<FormalParameter>();", "-    voparams.add(new FormalParameter(false, new ReferenceTypeName(\"String\"), \"s\"));", "-    accessFlags  = java.lang.reflect.Modifier.PUBLIC | java.lang.reflect.Modifier.STATIC;", "+    for(EnumConstant c : consts) {", "+      cells.add(new StaticFieldAccess(enumType, c.getName()));", "+    }", "-    //  for( int i = 0; i < $VALUES.length; i++ )", "-    //    if($VALUES[i].name().equals(s))", "-    //      return $VALUES[i];", "-    //  throw new IllegalArgumentException(s);", "-    List<Node> stmtsOf = new LinkedList<Node>();", "-    List<Node> init = new LinkedList<Node>();", "-    init.add(new VariableDeclaration(false, new IntTypeName(), \"i\", new IntegerLiteral(\"0\")));", "-    AmbiguousName iId = new AmbiguousName(\"i\");", "-    Expression cond = new LessExpression(iId, new ObjectFieldAccess(new StaticFieldAccess(enumType, \"$VALUES\"), \"length\"));", "-    List<Node> updt = new LinkedList<Node>();", "-    updt.add(new PostIncrement(iId));", "-    ArrayAccess arrCell = new ArrayAccess(new StaticFieldAccess(enumType, \"$VALUES\"), iId);", "-    List<Expression> args = new LinkedList<Expression>();", "-    AmbiguousName sId = new AmbiguousName(\"s\");", "-    args.add(new AmbiguousName(\"s\"));", "-    IfThenStatement bodyOf = new IfThenStatement(new ObjectMethodCall(new ObjectMethodCall(arrCell, \"name\", null), \"equals\", args), new ReturnStatement(arrCell));", "-    stmtsOf.add(new ForStatement(init, cond, updt, bodyOf));", "-    stmtsOf.add(new ThrowStatement(new SimpleAllocation(new ReferenceTypeName(\"IllegalArgumentException\"), args)));", "-    newbody.add(new MethodDeclaration(accessFlags, enumType, \"valueOf\", voparams, new LinkedList<ReferenceTypeName>(), new BlockStatement(stmtsOf)));", "-", "+    Expression alloc = new ArrayAllocation(enumType,", "+                                           new ArrayAllocation.TypeDescriptor(Collections.<Expression>emptyList(), 1,", "+                                                                              new ArrayInitializer(cells), 0, 0));", "+    Statement valuesBody = new ReturnStatement(alloc);", "+    newbody.add(new MethodDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "+                                      new ArrayTypeName(enumType, 1, false),", "+                                      \"values\",", "+                                      Collections.<FormalParameter>emptyList(),", "+                                      Collections.<ReferenceTypeName>emptyList(),", "+                                      new BlockStatement(Collections.<Node>singletonList(valuesBody))));", "+               ", "+    // public static Foo valueOf(String name) {", "+    //   if (\"FIRST\".equals(name)) return Foo.FIRST;", "+    //   if (\"SECOND\".equals(name)) return Foo.SECOND;", "+    //   if (\"THIRD\".equals(name)) return Foo.THIRD;", "+    //   throw new IllegalArgumentException();", "+    // }", "+    FormalParameter nameParam = new FormalParameter(false, new ReferenceTypeName(\"java\", \"lang\", \"String\"), \"name\");", "+    List<Node> valueOfBody = new LinkedList<Node>();", "+    for (EnumConstant c : consts) {", "+      String cn = c.getName();", "+      Expression cond = new ObjectMethodCall(new StringLiteral(\"\\\"\" + cn + \"\\\"\"), \"equals\",", "+                                             Collections.singletonList(new VariableAccess(\"name\")));", "+      Statement ret = new ReturnStatement(new StaticFieldAccess(enumType, cn));", "+      valueOfBody.add(new IfThenStatement(cond, ret));", "+    }", "+    valueOfBody.add(new ThrowStatement(new SimpleAllocation(new ReferenceTypeName(\"IllegalArgumentException\"),", "+                                                            Collections.<Expression>emptyList())));", "+    newbody.add(new MethodDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "+                                      enumType,", "+                                      \"valueOf\",", "+                                      Collections.singletonList(nameParam),", "+                                      Collections.<ReferenceTypeName>emptyList(),", "+                                      new BlockStatement(valueOfBody)));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90a34507dec3b1d76701c1f8732271e6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 132, "methodNumberAfterChange": 132, "signatureBeforeChange": "               public void testForSimpleAssignment()", "signatureAfterChange": "               public void testForSimpleAssignment()", "diff": ["-      ComplexNameReference nf = new ComplexNameReference(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"Ned\")), new Word(SourceInfo.NO_INFO, \"Flanders\"));", "-      SimpleAssignmentExpression sa = new SimpleAssignmentExpression(SourceInfo.NO_INFO, nf, new IntegerLiteral(SourceInfo.NO_INFO, 5));", "-      ", "+      ComplexNameReference nf =", "+        new ComplexNameReference(SourceInfo.NONE, ", "+                                 new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"Ned\")), ", "+                                 new Word(SourceInfo.NONE, \"Flanders\"));", "+      SimpleAssignmentExpression sa = ", "+        new SimpleAssignmentExpression(SourceInfo.NONE, nf, new IntegerLiteral(SourceInfo.NONE, 5));", "-      assertEquals(\"Error message should be correct\", \"You cannot assign a value to Flanders because it is immutable and has already been given a value\",", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot assign a value to Flanders because it is immutable and has already been given a value\",", "-      SimpleAssignmentExpression sa2 = new SimpleAssignmentExpression(SourceInfo.NO_INFO, nf, nf);", "+      SimpleAssignmentExpression sa2 = new SimpleAssignmentExpression(SourceInfo.NONE, nf, nf);", "-      assertEquals(\"The error message should be correct\", \"You cannot use Flanders here, because it may not have been given a value\", errors.getLast().getFirst());", "+      assertEquals(\"The error message should be correct\", ", "+                   \"You cannot use Flanders here, because it may not have been given a value\", ", "+                   errors.getLast().getFirst());", "-      //Test that a value cannot be assigned to a type", "-      SimpleAssignmentExpression sa3 = new SimpleAssignmentExpression(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"int\")), new IntegerLiteral(SourceInfo.NO_INFO, 5));", "+      // Test that a value cannot be assigned to a type", "+      SimpleAssignmentExpression sa3 = ", "+        new SimpleAssignmentExpression(SourceInfo.NONE, ", "+                                       new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"int\")), ", "+                                       new IntegerLiteral(SourceInfo.NONE, 5));", "-      assertEquals(\"Error message should be correct\", \"You cannot assign a value to the type int.  Perhaps you meant to create a new instance of int\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot assign a value to the type int.  Perhaps you meant to create a new instance of int\", ", "+                   errors.getLast().getFirst());", "-      SimpleAssignmentExpression sa4 = new SimpleAssignmentExpression(SourceInfo.NO_INFO, nf, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"int\")));", "+      SimpleAssignmentExpression sa4 = ", "+        new SimpleAssignmentExpression(SourceInfo.NONE, nf, ", "+                                       new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"int\")));", "-      assertEquals(\"Error message should be correct\", \"You cannot use the type name int on the right hand side of an assignment.  Perhaps you meant to create a new instance of int\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot use the type name int on the right hand side of an assignment.  Perhaps you meant to \"", "+                     + \"create a new instance of int\", ", "+                   errors.getLast().getFirst());", "-      ArrayData boolArray = new ArrayData(SymbolData.BOOLEAN_TYPE, llv, SourceInfo.NO_INFO);", "+      ArrayData boolArray = new ArrayData(SymbolData.BOOLEAN_TYPE, llv, SourceInfo.NONE);", "-      SimpleAssignmentExpression sa5 = new SimpleAssignmentExpression(SourceInfo.NO_INFO, new ArrayAccess(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"myArray\")), new IntegerLiteral(SourceInfo.NO_INFO, 5)), new BooleanLiteral(SourceInfo.NO_INFO, true));", "+      SimpleNameReference snr = new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"myArray\"));", "+      SimpleAssignmentExpression sa5 = ", "+        new SimpleAssignmentExpression(SourceInfo.NONE, ", "+                                       new ArrayAccess(SourceInfo.NONE, snr, new IntegerLiteral(SourceInfo.NONE, 5)), ", "+                                       new BooleanLiteral(SourceInfo.NONE, true));"]}], "num": 18686}