{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9e6b54cc15a35e56ff129717c7ef0911", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53a9893ed07c9904a26a97fecfe9ae7b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/jpda/JPDADebugger.java", "commitBeforeChange": "5293cb4cfbc2f45d6061ba4101ad60348aa251ed", "commitAfterChange": "f68f43e5a680bb235f87f6125c6c0de6d15a12f4", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 68, "signatureBeforeChange": "   private void _dumpVariablesIntoInterpreterAndSwitch() throws DebugException, AbsentInformationException", "signatureAfterChange": "   private void _dumpVariablesIntoInterpreterAndSwitch() throws DebugException", "diff": ["-  private void _dumpVariablesIntoInterpreterAndSwitch() throws DebugException, AbsentInformationException {", "+  private void _dumpVariablesIntoInterpreterAndSwitch() throws DebugException {", "+    List<ObjectReference> toRelease = new LinkedList<ObjectReference>();", "-      ThreadReference suspendedThreadRef = _suspendedThreads.peek();", "-      StackFrame frame = suspendedThreadRef.frame(0);", "-      Location l = frame.location();", "-      ReferenceType rt = l.declaringType();", "-      String className = rt.name();", "+      ThreadReference thread = _suspendedThreads.peek();", "-      String interpreterName = _getUniqueThreadName(suspendedThreadRef);", "-      // TODO: allow creation of the appropriate context for the new interpreter", "-      _model.getInteractionsModel().addInterpreter(interpreterName);", "-      ObjectReference debugInterpreter = _getDebugInterpreter();", "-      _log.log(this + \" executing: frame = suspendedThreadRef.frame(0);\");", "-      frame = suspendedThreadRef.frame(0);", "-", "-      List<LocalVariable> vars = frame.visibleVariables();  // JDK 1.5 will eliminate this warning", "-      Iterator<LocalVariable> varsIterator = vars.iterator();", "-", "-      _log.log(this + \" got visibleVariables\");", "-", "-      // Define each variable", "-      while(varsIterator.hasNext()) {", "-        LocalVariable localVar = varsIterator.next();", "-        _log.log(this + \" defined local variable: \" + localVar);", "-        // Have to update the frame each time", "-        frame = suspendedThreadRef.frame(0);", "-        Value val = frame.getValue(localVar);", "-        Type type;", "-        if (val != null) {", "-          type = val.type();", "-        }", "-        else {", "+      String interpreterName = _getUniqueThreadName(thread);", "+      ObjectReference mirroredName = _mirrorString(interpreterName, toRelease);", "+      ObjectReference thisVal = thread.frame(0).thisObject();", "+      ClassObjectReference thisClass = thread.frame(0).location().declaringType().classObject();", "+      ", "+      List<ObjectReference> localVars = new LinkedList<ObjectReference>();", "+      List<StringReference> localVarNames = new LinkedList<StringReference>();", "+      List<ClassObjectReference> localVarClasses = new LinkedList<ClassObjectReference>();", "+      try {", "+        // we don't store the value thread.frame(0) anywhere, because it is invalidated", "+        // each time we invoke a method in thread (as in _box)", "+        for (LocalVariable v : thread.frame(0).visibleVariables()) {", "-            type = localVar.type();", "-          }", "-          catch(ClassNotLoadedException e) {", "-            List<ReferenceType> classes = _vm.classesByName(localVar.typeName());  //JDK 1.5 will eliminate this warning", "-            if (!classes.isEmpty()) {", "-              type = classes.get(0);", "+            // Get the type first, so that if an error occurs, we haven't mutated the lists.", "+            Type t = v.type();", "+            if (t instanceof ReferenceType) {", "+              localVarClasses.add(((ReferenceType) t).classObject());", "-              type = null;", "+              // primitive types are represented by null", "+              localVarClasses.add(null);", "+            localVarNames.add(_mirrorString(v.name(), toRelease));", "+            Value val = thread.frame(0).getValue(v);", "+            if (val == null || val instanceof ObjectReference) { localVars.add((ObjectReference) val); }", "+            else { localVars.add(_box((PrimitiveValue) val, thread, toRelease)); }", "+          }", "+          catch (ClassNotLoadedException e) {", "+            // This is a real possibility, as documented in the ClassNotLoadedException", "+            // javadocs.  We'll just ignore the exception, treating the variable as", "+            // out-of-scope, since we can't talk about values of its type.", "-        _defineVariable(suspendedThreadRef, debugInterpreter,", "-                        localVar.name(), val, type);", "-", "-      // Update the frame", "-      frame = suspendedThreadRef.frame(0);", "-", "-      // Define \"this\"", "-      Value thisVal = frame.thisObject();", "-      if (thisVal != null) {", "-        _defineVariable(suspendedThreadRef, debugInterpreter,", "-                        \"this\", thisVal, thisVal.type());", "-        //_setThisInInterpreter(suspendedThreadRef, debugInterpreter, thisVal);", "-      }", "-", "+      catch (AbsentInformationException e) { /* ignore -- we just won't include any local variables */ }", "+      ArrayReference mirroredVars = _mirrorArray(\"java.lang.Object\", localVars, thread, toRelease);", "+      ArrayReference mirroredVarNames = _mirrorArray(\"java.lang.String\", localVarNames, thread, toRelease);", "+      ArrayReference mirroredVarClasses = _mirrorArray(\"java.lang.Class\", localVarClasses, thread, toRelease);", "+      ", "+      _invokeMethod(thread, _interpreterJVM, \"addInterpreter\", ADD_INTERPRETER_SIG,", "+                    mirroredName, thisVal, thisClass, mirroredVars, mirroredVarNames, mirroredVarClasses);", "+    ", "-      String prompt = _getPromptString(suspendedThreadRef);", "+      String prompt = _getPromptString(thread);", "-    catch(InvalidTypeException exc) {", "-      throw new DebugException(exc.toString());", "-    }", "-    catch(IncompatibleThreadStateException e2) {", "-      throw new DebugException(e2.toString());", "-    }", "-    catch(ClassNotLoadedException e3) {", "-      throw new DebugException(e3.toString());", "-    }", "-    catch(InvocationException e4) {", "-      throw new DebugException(e4.toString());", "+    catch (IncompatibleThreadStateException e) { throw new DebugException(e); }", "+    finally {", "+      for (ObjectReference ref : toRelease) { ref.enableCollection(); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b1a2858a5309b2d99a5409772b31db84", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "plt/src/edu/rice/cs/plt/concurrent/ProcessIncrementalTaskController.java", "commitBeforeChange": "ba3f1737bae917eb057a0651ee7d4f727a22cab6", "commitAfterChange": "d28ad1c0de8862f820b20e04c9a78fc9e0194666", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      protected void doStart()", "signatureAfterChange": "         protected void doStart()", "diff": ["+  ", "-    if (_t != null) { writeCommand(Command.RUN); }", "-    else {", "-      _executor.execute(new Runnable() {", "-        public void run() {", "-          _t = Thread.currentThread();", "+    _executor.execute(new Runnable() {", "+      public void run() {", "+        _t = Thread.currentThread();", "+        try {", "+          // stop if the task was canceled before starting", "+          if (Thread.interrupted()) { throw new InterruptedException(); }", "+          Process p = _jvmBuilder.start(Runner.class.getName(), IterUtil.<String>empty());", "-            // stop if the task was canceled before starting", "-            if (Thread.interrupted()) { throw new InterruptedException(); }", "-            Process p = _jvmBuilder.start(Runner.class.getName(), IterUtil.<String>empty());", "+            InputStream in = p.getInputStream();", "+            // skip prefix", "+            int matching = 0;", "+            while (matching < Runner.PREFIX.length) {", "+              int read = in.read();", "+              if (read == -1) { throw new EOFException(\"Data prefix not found\"); }", "+              else if ((byte) read == Runner.PREFIX[matching]) { matching++; } // cast handles negatives", "+              else if ((byte) read == Runner.PREFIX[0]) { matching = 1; } // cast handles negatives", "+              else { matching = 0; }", "+            }", "+            // prefix has been matched", "+            ObjectInputStream objIn = new ObjectInputStream(in);", "-              InputStream in = p.getInputStream();", "-              // skip prefix", "-              int matching = 0;", "-              while (matching < Runner.PREFIX.length) {", "-                int read = in.read();", "-                if (read == -1) { throw new EOFException(\"Data prefix not found\"); }", "-                else if ((byte) read == Runner.PREFIX[matching]) { matching++; } // cast handles negatives", "-                else if ((byte) read == Runner.PREFIX[0]) { matching = 1; } // cast handles negatives", "-                else { matching = 0; }", "-              }", "-              // prefix has been matched", "-              ObjectInputStream objIn = new ObjectInputStream(in);", "+              ObjectOutputStream objOut = new ObjectOutputStream(p.getOutputStream());", "-                ObjectOutputStream objOut = new ObjectOutputStream(p.getOutputStream());", "-                try {", "-                  objOut.writeObject(_task);", "-                  objOut.writeObject(Command.RUN);", "-                  objOut.flush();", "-                  _commandSink = objOut;", "-                  ", "-                  Result r;", "-                  do {", "-                    r = (Result) objIn.readObject();", "-                    r.handle(ProcessIncrementalTaskController.this);", "-                  } while (!(r instanceof FinishResult));", "-                  if (r instanceof CleanFinishResult) {", "-                    // let the process run if we finished cleanly", "-                    Runnable1<? super Process> onExit = _onExit; // keep local copy so it can be discarded", "-                    if (onExit != null) { p.waitFor(); onExit.run(p); }", "-                  }", "-                  else { p.destroy(); }", "+                objOut.writeObject(_task);", "+                objOut.writeObject(Command.RUN);", "+                objOut.flush();", "+                _commandSink = objOut;", "+                ", "+                Result r;", "+                do {", "+                  r = (Result) objIn.readObject();", "+                  r.handle(ProcessIncrementalTaskController.this);", "+                } while (!(r instanceof FinishResult));", "+                if (r instanceof CleanFinishResult) {", "+                  // let the process run if we finished cleanly", "+                  Runnable1<? super Process> onExit = _onExit; // keep local copy so it can be discarded", "+                  if (onExit != null) { p.waitFor(); onExit.run(p); }", "-                finally { objOut.close(); }", "+                else { p.destroy(); }", "-              finally { objIn.close(); }", "+              finally { objOut.close(); }", "-            catch (EOFException e) {", "-              p.destroy();", "-              throw new IOException(\"Unable to run process; class path may need to be adjusted\");", "-            }", "-            // destroy the process on an exception, but let it run if we completed cleanly", "-            catch (Throwable e) { p.destroy(); throw e; }", "+            finally { objIn.close(); }", "-          catch (InterruptedException e) { /* ignore -- indicates error occurred in another thread */ }", "-          catch (InterruptedIOException e) { /* ignore -- indicates error occurred in another thread */ }", "-          catch (RuntimeException e) { finishedWithImplementationException(e); }", "-          catch (Throwable t) { finishedWithImplementationException(new WrappedException(t)); }", "+          catch (EOFException e) {", "+            p.destroy();", "+            throw new IOException(\"Unable to run process; class path may need to be adjusted\");", "+          }", "+          // destroy the process on an exception, but let it run if we completed cleanly", "+          catch (Throwable e) { p.destroy(); throw e; }", "-      });", "-    }", "+        catch (InterruptedException e) { /* ignore -- indicates error occurred in another thread */ }", "+        catch (InterruptedIOException e) { /* ignore -- indicates error occurred in another thread */ }", "+        catch (RuntimeException e) { finishedWithImplementationException(e); }", "+        catch (Throwable t) { finishedWithImplementationException(new WrappedException(t)); }", "+      }", "+    });"]}], "num": 7719}