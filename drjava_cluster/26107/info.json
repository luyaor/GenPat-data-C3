{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "12d86fadd70dafaebeed60c578548820", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39feea6dc4d2006f82916656e8222547", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/swing/FindReplaceMachine.java", "commitBeforeChange": "20a2512e394be5865ddd8dc1ebd648c5dfb08d0c", "commitAfterChange": "832e5dfbee9301c0432d02f86eab2d13af7f51bc", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 20, "signatureBeforeChange": "   public FindResult findNext()", "signatureAfterChange": "   public FindResult findNext()", "diff": ["+      FindResult tempFr = new FindResult(_doc, -1, false);", "+      // If the user just found and toggled the \"Search Backwards\"", "+      // option, we should skip the first find.", "-        _wrapped = true;", "-        //When we wrap, we need to include some text that was already searched before wrapping.", "-        //Otherwise, we won't find an only match that has the caret in it already.", "-        if(!_searchBackwards){", "-          start = 0;", "-          len = _start.getOffset() + (_findWord.length() - 1);", "-          if(len > _doc.getLength()){", "-            len = _doc.getLength();", "-          }", "-        } else {", "-          start = _start.getOffset() - (_findWord.length() - 1);", "-          if (start < 0){", "+        if (_searchAllDocuments) {", "+          tempFr = _findNextInAllDocs(!_searchBackwards ? _docIterator.getNextDocument(_doc) :", "+                                        _docIterator.getPrevDocument(_doc));", "+          foundOffset = tempFr.getFoundOffset();", "+        }", "+        // we still haven't found it", "+        if (foundOffset == -1) {", "+          _wrapped = true;", "+          //When we wrap, we need to include some text that was already searched before wrapping.", "+          //Otherwise, we won't find an only match that has the caret in it already.", "+          if(!_searchBackwards){", "+            len = _current.getOffset() + (_findWord.length() - 1);", "+            if(len > _doc.getLength()){", "+              len = _doc.getLength();", "+            }", "+          } ", "+          else {", "+            start = _current.getOffset() - (_findWord.length() - 1);", "+            if (start < 0){", "+              start = 0;", "+            }", "+            len = _doc.getLength() - start;", "-          len = _doc.getLength() - start;", "-        }", "-        findSpace = _doc.getText(start, len);", "-", "-        if (!_matchCase) {", "-          findSpace = findSpace.toLowerCase();", "-        }", "-", "-        foundOffset = !_searchBackwards ? findSpace.indexOf(findWord)", "-          : findSpace.lastIndexOf(findWord);", "-", "-        if (foundOffset >= 0) {", "-          foundOffset += start;", "-          if (!_searchBackwards) {", "-            foundOffset += findWord.length();", "+          findSpace = _doc.getText(start, len);", "+          ", "+          if (!_matchCase) {", "+            findSpace = findSpace.toLowerCase();", "-          _current = _doc.createPosition(foundOffset);", "+          foundOffset = !_searchBackwards ? findSpace.indexOf(findWord)", "+            : findSpace.lastIndexOf(findWord);", "+          ", "+          if (foundOffset >= 0) {", "+            foundOffset += start;", "+            if (!_searchBackwards) {", "+              foundOffset += findWord.length();", "+            }", "+            _current = _doc.createPosition(foundOffset);", "+          }", "-      if(foundOffset == -1 && _found) {", "-        _current = _start;", "-        _found = false;", "-        return findNext();", "-      }", "-      else {", "-        FindResult fr = new FindResult(foundOffset, _wrapped);", "-        _wrapped = false;", "-        return fr;", "-      }", "+//      if(foundOffset == -1 && _found) {", "+//        _current = _start;", "+//        _found = false;", "+//        return findNext();", "+//      }", "+//      else {", "+      FindResult fr = new FindResult(tempFr.getDocument(), foundOffset, _wrapped);", "+      _wrapped = false;", "+      return fr;", "+//      }", "+    }", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "71c8cd016460aa093bd01d9040af878e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Augmentor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": "   public void forMethodDef(MethodDef that)", "signatureAfterChange": "   public void forMethodDef(MethodDef that)", "diff": ["-   */", "+    */", "-    _readAndWriteThroughIndex(that.getSourceInfo().getStartLine(), that.getSourceInfo().getStartColumn() - 1);", "-    if (_isElementaryFile()) { ", "-      _writeToFileOut(\"public \");", "-    }", "+    SourceInfo mdSourceInfo = that.getSourceInfo();", "+    _readAndWriteThroughIndex(mdSourceInfo.getStartLine(), mdSourceInfo.getStartColumn() - 1);", "-    if (_isIntermediateFile()) { //if this is an Intermediate level file, want to check and see if the method has modifiers.  If not,", "-                                 //make it public by default", "+    if (_isElementaryFile()) _writeToFileOut(\"public \");", "+    ", "+    if (_isIntermediateFile()) { ", "+      /* Check if the method has explicit modifiers.  Unfortunately, the information in that.getMav().getModifiers() ", "+       * is not reliable regarding what modifiers EXPLICITLY appear in the .dj1 file, so we have to do additional work. */", "+      ", "-      boolean hasVisibilityModifier = false;", "-      for (int i = 0; i<modifiers.length; i++) {", "-        if ((modifiers[i].equals(\"private\")) || (modifiers[i].equals(\"public\")) || (modifiers[i].equals(\"protected\"))) {", "-          hasVisibilityModifier = true;", "+      String visibilityModifier = null;", "+      for (int i = 0; i < modifiers.length; i++) {", "+        if (modifiers[i].equals(\"private\") || modifiers[i].equals(\"public\") || modifiers[i].equals(\"protected\")) {", "+          visibilityModifier = modifiers[i];", "+", "+//  This patch was created in an attempt to fix an augmentation bug by brute force; it didn't work      ", "+//      if (visibilityModifier != null) {", "+//        // Check for explicit appearance in text", "+//        String text = _peek(mdSourceInfo.getEndLine(), mdSourceInfo.getEndColumn());", "+//        _log.log(\"Checking for presence of visibility modifier \" + visibilityModifier + \" in file \" + _fileIn +  \" on line \" + _fileInLine + \":\\n'\" + text + \"'\");", "+//        int len = text.length();", "+//        // This analysis can be broken by deviously constructed comments", "+//        int startModifier = text.indexOf(visibilityModifier);  // offset of modifier", "+//        if (startModifier < 0) startModifier = len;  // This should never happen", "+//        int startName = text.indexOf(that.getName().getText());  // offset of method name", "+//        if (startName < 0) startName = len;  // This should never happen", "+//        if (startName <= startModifier) { ", "+//          visibilityModifier = null; // modifier does not explicitlly appear in text", "+//          _log.log(\"No modifier was found\");", "+//        }", "+//        else _log.log(\"Modifier was found\");", "+//      }", "-      if (!hasVisibilityModifier) {", "+      if (visibilityModifier == null) {", "+//  A continuation of the preceding unsucessful patch", "+//        MethodData md = ", "+//          _enclosingData.getSymbolData().getMethod(that.getName().getText(), ", "+//                                                   formalParameters2TypeDatas(that.getParams(), _enclosingData));", "+//        if (md == null) { ", "+//          throw new RuntimeException(\"Internal Program Error: Can't find method data for \" + that.getName() + ", "+//                                     \" Please report this bug.\"); ", "+//        }", "+//        md.addModifier(\"public\");  // this operation is idempotent", "-      ", "+        ", "+    "]}], "num": 26107}