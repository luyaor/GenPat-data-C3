{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "96627a90a5ab0f484bc10743072df307", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "78d6445077f33bab2485efad1f49792e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "e2abbf01d6f3b23be51f493f663daa5ce8abf706", "commitAfterChange": "d7bd3eaf7514715e375acabd9bf0f41e4281985a", "methodNumberBeforeChange": 223, "methodNumberAfterChange": 223, "signatureBeforeChange": "   public ConstructorInvocation lookupConstructor(final Type t, final Iterable<? extends Type> typeArgs,                                                   final Iterable<? extends Expression> args,                                                  final Option<Type> expected)     throws InvalidTypeArgumentException, UnmatchedLookupException", "signatureAfterChange": "   public ConstructorInvocation lookupConstructor(final Type t, final Iterable<? extends Type> typeArgs,                                                   final Iterable<? extends Expression> args,                                                  final Option<Type> expected)     throws InvalidTypeArgumentException, UnmatchedLookupException", "diff": ["-    Iterable<ConstructorInvocationCandidate> constructors = ", "-      t.apply(new TypeAbstractVisitor<Iterable<ConstructorInvocationCandidate>>() {", "-        @Override public Iterable<ConstructorInvocationCandidate> defaultCase(Type t) { return IterUtil.empty(); }", "-        @Override public Iterable<ConstructorInvocationCandidate> forClassType(final ClassType t) {", "-          return IterUtil.mapSnapshot(t.ofClass().declaredConstructors(),", "-                                       new Lambda<DJConstructor, ConstructorInvocationCandidate>() {", "-            public ConstructorInvocationCandidate value(DJConstructor k) {", "-              return new ConstructorInvocationCandidate(k, t, typeArgs, args, expected);", "+    Iterable<DJConstructor> constructors = ", "+      t.apply(new TypeAbstractVisitor<Iterable<DJConstructor>>() {", "+        @Override public Iterable<DJConstructor> defaultCase(Type t) { return IterUtil.empty(); }", "+        @Override public Iterable<DJConstructor> forSimpleClassType(SimpleClassType t) {", "+          return t.ofClass().declaredConstructors();", "+        }", "+        @Override public Iterable<DJConstructor> forRawClassType(RawClassType t) {", "+          return IterUtil.mapSnapshot(t.ofClass().declaredConstructors(), new Lambda<DJConstructor, DJConstructor>() {", "+            public DJConstructor value(DJConstructor k) {", "+              // TODO: raw member access warnings", "+              return new ErasedConstructor(k);", "+            }", "+          });", "+        }", "+        @Override public Iterable<DJConstructor> forParameterizedClassType(ParameterizedClassType t) {", "+          final Iterable<VariableType> classTParams = SymbolUtil.allTypeParameters(t.ofClass());", "+          final Iterable<? extends Type> classTArgs = capture(t).typeArguments();", "+          return IterUtil.mapSnapshot(t.ofClass().declaredConstructors(), new Lambda<DJConstructor, DJConstructor>() {", "+            public DJConstructor value(DJConstructor k) {", "+              return new InstantiatedConstructor(k, classTParams, classTArgs);", "-    Iterable<ConstructorInvocationCandidate> results = bestMatches(constructors);", "+      ", "+    Iterable<FunctionInvocationCandidate<DJConstructor>> cs = bestInvocations(constructors, typeArgs, args, expected);", "-    int matches = IterUtil.sizeOf(results);", "-    if (matches != 1) { throw new UnmatchedLookupException(matches); }", "-    else { return IterUtil.first(results).invocation(); }", "+    int matches = IterUtil.sizeOf(cs);", "+    if (matches == 0) { throw new UnmatchedFunctionLookupException(constructors); }", "+    else if (matches > 1) {", "+      Iterable<DJConstructor> ks = IterUtil.map(cs, new Lambda<FunctionInvocationCandidate<DJConstructor>,", "+                                                               DJConstructor>() {", "+        public DJConstructor value(FunctionInvocationCandidate<DJConstructor> c) { return c.function(); }", "+      });", "+      throw new AmbiguousFunctionLookupException(ks);", "+    }", "+    else {", "+      FunctionInvocationCandidate<DJConstructor> c = IterUtil.first(cs);", "+      DJConstructor k = c.function();", "+      SubstitutionMap sigma = c.substitution();", "+      return new ConstructorInvocation(k, c.typeArguments(), c.arguments(), substitute(k.thrownTypes(), sigma));", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ec4aef97379f58c4197509d4b2bb4661", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 338, "methodNumberAfterChange": 264, "signatureBeforeChange": "              @Override public Iterable<ObjectFieldReference> forParameterizedClassType(ParameterizedClassType t)", "signatureAfterChange": "           private PredicateSet<T> find(final Type t, final boolean findAll)", "diff": ["+    ", "+    private PredicateSet<T> find(final Type t, final boolean findAll) {", "+      debug.logStart(\"t\", wrap(t)); try {", "+        ", "+      final PredicateSet<T> childMatches = CollectUtil.asPredicateSet(declaredMatches(t));", "+      if (!findAll && !IterUtil.isEmpty(childMatches)) {", "+        // take snapshot of lazily-constructed set", "+        return CollectUtil.makeSet(childMatches);", "+      }", "+      else {", "+        PredicateSet<T> fromSupers = t.apply(new TypeAbstractVisitor<PredicateSet<T>>() {", "+          ", "+          public PredicateSet<T> defaultCase(Type t) { return CollectUtil.emptySet(); }", "+          ", "+          @Override public PredicateSet<T> forArrayType(ArrayType t) {", "+            return find(CLONEABLE_AND_SERIALIZABLE, findAll);", "+          }", "+          ", "+          @Override public PredicateSet<T> forClassType(ClassType t) {", "+            Type superT = immediateSupertype(t);", "+            if (superT == null) { return CollectUtil.emptySet(); }", "+            else { return find(superT, findAll); }", "+          }", "+          ", "+          @Override public PredicateSet<T> forVariableType(VariableType t) {", "+            return find(t.symbol().upperBound(), findAll);", "+          }", "+          ", "+          @Override public PredicateSet<T> forIntersectionType(IntersectionType t) {", "+            PredicateSet<T> result = CollectUtil.emptySet();", "+            for (Type tSup : t.ofTypes()) {", "+              PredicateSet<T> forSup = find(tSup, findAll);", "+              result = CollectUtil.union(result, forSup);", "+            }", "+            return result;", "+          }", "+          ", "+          @Override public PredicateSet<T> forUnionType(UnionType t) {", "+            Iterable<? extends Type> sups = t.ofTypes();", "+            if (IterUtil.isEmpty(sups)) { return CollectUtil.emptySet(); }", "+            else {", "+              PredicateSet<T> result = find(IterUtil.first(sups), findAll);", "+              for (Type tSup : IterUtil.skipFirst(sups)) {", "+                PredicateSet<T> forSup = find(tSup, findAll);", "+                result = CollectUtil.intersection(result, forSup);", "+                // don't short-circuit when empty, because the empty test is expensive", "+              }", "+              return result;", "+            }", "+          }", "+          ", "+        });", "+        PredicateSet<T> result = CollectUtil.union(childMatches, CollectUtil.filter(fromSupers, new Predicate<T>() {", "+          public boolean contains(T match) { return inherits(t, childMatches, match); }", "+        }));", "+        // take snapshot of lazily-constructed sets", "+        return CollectUtil.makeSet(result);", "+      }", "+      ", "+      } finally { debug.logEnd(); }", "+    }", "-      ", "-      @Override public Iterable<ObjectFieldReference> forParameterizedClassType(ParameterizedClassType t) {", "-        for (DJField f : t.ofClass().declaredFields()) {", "-          if (f.declaredName().equals(name) && validField(f)) {", "-            Type fieldType = substitute(f.type(), SymbolUtil.allTypeParameters(t.ofClass()), ", "-                                        t.typeArguments());", "-            return IterUtil.make(new ObjectFieldReference(f, fieldType, makeCast(t, object)));", "-          }", "-        }", "-        return IterUtil.empty();", "-      }"]}], "num": 20582}