{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a0d8db607b2a0aaeac1068b52332cfc3", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2898d7c5b0606f70006bc95612de0fbc", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "476f4df6ab63cd1004cb7cc36238fad228ab6d80", "commitAfterChange": "2df7289d55456372fbaf4e3ab78549d8571648f8", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 78, "signatureBeforeChange": "   public ClassPathVector getClassPath()", "signatureAfterChange": "   public ClassPathVector getClassPath()", "diff": ["-  public ClassPathVector getClassPath() { return _jvm.getClassPath(); }", "+   */", "+  public ClassPathVector getClassPath() {", "+    ClassPathVector result = new ClassPathVector();", "+    ", "+    if (isProjectActive()) {", "+      File buildDir = getBuildDirectory();", "+      if (buildDir != null) { _addFileToClassPath(buildDir, result); }", "+      ", "+      /* We prefer to assume the project root is the project's source root, rather than", "+       * checking *every* file in the project for its source root.  This is a bit problematic,", "+       * because \"Compile Project\" won't care if the user has multiple source roots (or even just a", "+       * single \"src\" subdirectory), and the user in this situation (assuming the build dir is ", "+       * null) wouldn't notice a problem until trying to access the compiled classes in the ", "+       * Interactions.", "+       */", "+      File projRoot = getProjectRoot();", "+      if (projRoot != null) { _addFileToClassPath(projRoot, result); }", "+      ", "+      ClassPathVector projectExtras = getExtraClassPath();", "+      if (projectExtras != null) { result.addAll(projectExtras); }", "+    }", "+    else {", "+      for (File f : getSourceRootSet()) { _addFileToClassPath(f, result); }", "+    }", "+      ", "+    Vector<File> globalExtras = DrJava.getConfig().getSetting(EXTRA_CLASSPATH);", "+    if (globalExtras != null) {", "+      for (File f : globalExtras) { _addFileToClassPath(f, result); }", "+    }", "+    ", "+    /* We must add JUnit to the class path.  We do so by including the current JVM's class path.", "+     * This is not ideal, because all other classes on the current class path (including all of DrJava's", "+     * internal classes) are also included.  But we're probably stuck doing something like this if we", "+     * want to continue bundling JUnit with DrJava.", "+     */", "+    String currentClassPath = System.getProperty(\"java.class.path\");", "+    if (currentClassPath != null) {", "+      // TODO: Parsing this string needs to only happen once, not every time this method is invoked.", "+      StringTokenizer tokens = new StringTokenizer(currentClassPath, File.pathSeparator);", "+      while (tokens.hasMoreTokens()) {", "+        _addFileToClassPath(new File(tokens.nextToken()), result);", "+      }", "+    }", "+    ", "+    return result;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "441a0825ad5ccb89ece9b2a0d9639dbf", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/StatementChecker.java", "commitBeforeChange": "b125d4a35b225e9cc738f569b062e7e7bd7cf031", "commitAfterChange": "9ce155a1f3e34352032d821032cb2dc70024460f", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "   @Override public TypeContext visit(TryStatement node)", "signatureAfterChange": "   @Override public TypeContext visit(TryStatement node)", "diff": ["-    node.getTryBlock().acceptVisitor(this);", "-    for (CatchStatement c : node.getCatchStatements()) { c.acceptVisitor(this); }", "-    if (node.getFinallyBlock() != null) { node.getFinallyBlock().acceptVisitor(this); }", "-    return context;", "-  }", "+    List<Type> caughtTypes = new LinkedList<Type>();", "+    for (CatchStatement c : node.getCatchStatements()) {", "+      FormalParameter p = c.getException();", "+      Type caughtT = checkTypeName(p.getType());", "+      if (!ts.isAssignable(TypeSystem.THROWABLE, caughtT)) {", "+        setErrorStrings(c, ts.userRepresentation(caughtT));", "+        throw new ExecutionError(\"catch.type\", c);", "+      }", "+      if (!ts.isReifiable(caughtT)) {", "+        throw new ExecutionError(\"reifiable.type\", c);", "+      }", "+      setVariable(p, new LocalVariable(p.getName(), caughtT, p.isFinal()));", "+      setErasedType(c, ts.erasedClass(caughtT));", "+      caughtTypes.add(caughtT);", "+    TypeContext tryContext = new TryBlockContext(context, caughtTypes);", "+    node.getTryBlock().acceptVisitor(new StatementChecker(tryContext, opt));", "+    ", "+    for (CatchStatement c : node.getCatchStatements()) {", "+      TypeContext catchContext = new LocalContext(context, getVariable(c.getException()));", "+      c.getBlock().acceptVisitor(new StatementChecker(catchContext, opt));", "+    }", "+    ", "+    if (node.getFinallyBlock() != null) { node.getFinallyBlock().acceptVisitor(this); }", "+    "]}], "num": 15342}