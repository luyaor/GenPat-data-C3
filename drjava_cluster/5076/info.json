{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3d6aee5a00b4f6ce173cff919fb2d9be", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "871773d72b59cc8f5e7d88f4c795fe4c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic Object visit(StaticMethodCall node)", "signatureAfterChange": "     public Object visit(StaticMethodCall node)", "diff": ["-\t */", "-\tpublic Object visit(StaticMethodCall node) {", "-\t    // Do the type checking of the arguments", "-\t    List args = node.getArguments();", "-\t    ClassInfo[] cargs = new ClassInfo[0];", "-\t    if (args != null) {", "-\t\tcheckList(args, \"malformed.argument\", node);", "-", "-\t\tcargs = new ClassInfo[args.size()];", "-\t\tListIterator it = args.listIterator();", "-\t\tint      i  = 0;", "-\t\twhile (it.hasNext()) {", "-\t\t    cargs[i++] = NodeProperties.getClassInfo((Node)it.next());", "-\t\t}", "-\t    }", "-\t    MethodInfo m = null;", "-\t    Node       n = node.getMethodType();", "-\t    ClassInfo  c = NodeProperties.getClassInfo(n);", "-\t    try {", "-\t\tm = ClassInfoUtilities.lookupMethod(c, node.getMethodName(), cargs);", "-\t    } catch (NoSuchMethodException e) {", "-\t\tif (n.getBeginLine() == n.getEndLine() &&", "-\t\t    n.getBeginColumn() == n.getEndLine()) {", "-\t\t    // Look for a method in the outerclasses", "-\t\t    try {", "-\t\t\tm = ClassInfoUtilities.lookupOuterMethod(c,", "-\t\t\t\t\t\t\t\t node.getMethodName(),", "-\t\t\t\t\t\t\t\t cargs);", "-\t\t    } catch (NoSuchMethodException ex) {", "-\t\t\tthrow new CatchedExceptionError(ex, node);", "-\t\t    }", "-\t\t} else {", "-\t\t    throw new CatchedExceptionError(e, node);", "-\t\t}", "-\t\tthrow new CatchedExceptionError(e, node);", "-\t    }", "-", "-\t    // Set the node properties", "-\t    node.setProperty(NodeProperties.TYPE, m.getReturnType());", "-\t    return null;", "-\t}", "+     */", "+    public Object visit(StaticMethodCall node) {", "+      // Do the type checking of the arguments", "+      List<Expression> args = node.getArguments();", "+      ClassInfo[] cargs = new ClassInfo[0];", "+      if (args != null) {", "+        checkList(args, \"malformed.argument\", node);", "+        ", "+        cargs = new ClassInfo[args.size()];", "+        ListIterator<Expression> it = args.listIterator();", "+        int      i  = 0;", "+        while (it.hasNext()) {", "+          cargs[i++] = NodeProperties.getClassInfo(it.next());", "+        }", "+      }", "+      MethodInfo m = null;", "+      Node       n = node.getMethodType();", "+      ClassInfo  c = NodeProperties.getClassInfo(n);", "+      try {", "+        m = ClassInfoUtilities.lookupMethod(c, node.getMethodName(), cargs);", "+      } catch (NoSuchMethodException e) {", "+        SourceInfo si = n.getSourceInfo();", "+        if (si.getStartLine() == si.getEndLine() &&", "+            si.getStartColumn() == si.getEndLine()) {", "+          // Look for a method in the outerclasses", "+          try {", "+            m = ClassInfoUtilities.lookupOuterMethod(c,", "+                                                     node.getMethodName(),", "+                                                     cargs);", "+          } catch (NoSuchMethodException ex) {", "+            throw new CatchedExceptionError(ex, node);", "+          }", "+        } else {", "+          throw new CatchedExceptionError(e, node);", "+        }", "+        throw new CatchedExceptionError(e, node);", "+      }", "+      ", "+      // Set the node properties", "+      node.setProperty(NodeProperties.TYPE, m.getReturnType());", "+      return null;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9055495044b9b84285df290985086104", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/EvaluationVisitor.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public Object visit(ForStatement node)", "signatureAfterChange": "   public Object visit(ForStatement node)", "diff": ["-     */", "-    public Object visit(ForStatement node) {", "-\ttry {", "-\t    Set vars = (Set)node.getProperty(NodeProperties.VARIABLES);", "-\t    context.enterScope(vars);", "-", "-\t    // Interpret the initialization expressions", "-\t    if (node.getInitialization() != null) {", "-\t\tIterator it = node.getInitialization().iterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    ((Node)it.next()).acceptVisitor(this);", "-\t\t}", "-\t    }", "-", "-\t    // Interpret the loop", "-\t    try {", "-\t\tExpression cond   = node.getCondition();", "-\t\tList       update = node.getUpdate();", "-\t\twhile (cond == null ||", "-\t\t       ((Boolean)cond.acceptVisitor(this)).booleanValue()) {", "-\t\t    try {", "-\t\t\tnode.getBody().acceptVisitor(this);", "-\t\t    } catch (ContinueException e) {", "-\t\t\t// 'continue' statement management", "-\t\t\tif (e.isLabeled() && !node.hasLabel(e.getLabel())) {", "-\t\t\t    throw e;", "-\t\t\t}", "-\t\t    }", "-\t\t    // Interpret the update statements", "-\t\t    if (update != null) {", "-\t\t\tIterator it = update.iterator();", "-\t\t\twhile (it.hasNext()) {", "-\t\t\t    ((Node)it.next()).acceptVisitor(this);", "-\t\t\t}", "-\t\t    }", "-\t\t}", "-\t    } catch (BreakException e) {", "-\t\t// 'break' statement management", "-\t\tif (e.isLabeled() && !node.hasLabel(e.getLabel())) {", "-\t\t    throw e;", "-\t\t}", "-\t    }", "-\t} finally {", "-\t    // Always leave the current scope", "-\t    context.leaveScope();", "-\t}", "-\treturn null;", "-    }", "+   */", "+  public Object visit(ForStatement node) {", "+    try {", "+      Set vars = (Set)node.getProperty(NodeProperties.VARIABLES);", "+      context.enterScope(vars);", "+      ", "+      // Interpret the initialization expressions", "+      if (node.getInitialization() != null) {", "+        Iterator<Node> it = node.getInitialization().iterator();", "+        while (it.hasNext()) {", "+          it.next().acceptVisitor(this);", "+        }", "+      }", "+      ", "+      // Interpret the loop", "+      try {", "+        Expression cond   = node.getCondition();", "+        List<Node>  update = node.getUpdate();", "+        while (cond == null ||", "+               ((Boolean)cond.acceptVisitor(this)).booleanValue()) {", "+          try {", "+            node.getBody().acceptVisitor(this);", "+          } catch (ContinueException e) {", "+            // 'continue' statement management", "+            if (e.isLabeled() && !node.hasLabel(e.getLabel())) {", "+              throw e;", "+            }", "+          }", "+          // Interpret the update statements", "+          if (update != null) {", "+            Iterator<Node> it = update.iterator();", "+            while (it.hasNext()) {", "+              it.next().acceptVisitor(this);", "+            }", "+          }", "+        }", "+      } catch (BreakException e) {", "+        // 'break' statement management", "+        if (e.isLabeled() && !node.hasLabel(e.getLabel())) {", "+          throw e;", "+        }", "+      }", "+    } finally {", "+      // Always leave the current scope", "+      context.leaveScope();", "+    }", "+    return null;", "+  }"]}], "num": 5076}