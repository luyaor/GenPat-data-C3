{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6c08de36f953feb33884b7909c35fc4b", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0146734045fa0c4c16cd1e1c2fed8ff2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/JarOptionsDialog.java", "commitBeforeChange": "297435705dbd8bf9d631995d57ce87c743b50405", "commitAfterChange": "1baaca56848b77e4ea889da1ec6855791456c263", "methodNumberBeforeChange": 48, "methodNumberAfterChange": 48, "signatureBeforeChange": "   private void _ok()", "signatureAfterChange": "   private void _ok()", "diff": ["+      HashSet<String> _exceptions = new HashSet<String>();", "-            if(files[i].isDirectory()){", "-              jarFile.addDirectoryRecursive(files[i], files[i].getName(), allFilter);", "-            }else{", "-              jarFile.addFile(files[i], \"\", files[i].getName());", "+            try {", "+              if(files[i].isDirectory()){", "+                LOG.log(\"jarFile.addDirectoryRecursive(\"+files[i]+\")\");", "+                jarFile.addDirectoryRecursive(files[i], files[i].getName(), allFilter);", "+              }else{", "+                LOG.log(\"jarFile.addFile(\"+files[i]+\")\");", "+                jarFile.addFile(files[i], \"\", files[i].getName());", "+              }", "+            catch(IOException ioe) { _exceptions.add(ioe.getMessage()); }", "-            if (files[i].isDirectory()) {", "-              jarFile.addDirectoryRecursive(files[i], files[i].getName(), classFilter);", "+            try {", "+              if (files[i].isDirectory()) {", "+                LOG.log(\"jarFile.addDirectoryRecursive(\"+files[i]+\")\");", "+                jarFile.addDirectoryRecursive(files[i], files[i].getName(), classFilter);", "+              }", "+              else {", "+                LOG.log(\"jarFile.addFile(\"+files[i]+\")\");", "+                jarFile.addFile(files[i], \"\", files[i].getName());", "+              }", "-            else {", "-              jarFile.addFile(files[i], \"\", files[i].getName());", "-            }", "+            catch(IOException ioe) { _exceptions.add(ioe.getMessage()); }", "-            catch (IOException e) {", "-              e.printStackTrace();", "-              throw new UnexpectedException(e);", "-            }", "+            catch(IOException ioe) { _exceptions.add(ioe.getMessage()); }", "+            LOG.log(\"(_jarClasses.isSelected() && _jarSources.isSelected()) || _jarAll.isSelected()\");", "+              LOG.log(\"jarAll\");", "+              LOG.log(\"binRoot=\"+binRoot);", "+              LOG.log(\"root=\"+_model.getProjectRoot());", "+              LOG.log(\"FileOps.isAncestorOf(_model.getProjectRoot(),binRoot)=\"+FileOps.isAncestorOf(_model.getProjectRoot(),binRoot));", "+              LOG.log(\"mainJar=\"+mainJar);", "+              LOG.log(\"jarOut=\"+jarOut);", "-              if(!(binRoot.equals(_model.getProjectRoot())))", "+              if(!_model.getProjectRoot().equals(binRoot))", "+                LOG.log(\"jarBuildDirectory\");", "-          e.printStackTrace();", "-          ", "+          // e.printStackTrace();", "-          if (_jarClasses.isSelected() && _makeExecutable.isSelected()) {", "+          if (_exceptions.size()>0) {", "+            ScrollableListDialog<String> dialog = new ScrollableListDialog.Builder<String>()", "+              .setOwner(JarOptionsDialog.this)", "+              .setTitle(\"Problems Creating Jar\")", "+              .setText(\"There were problems creating this jar file, but DrJava was probably able to recover.\")", "+              .setItems(new ArrayList<String>(_exceptions))", "+              .setMessageType(JOptionPane.ERROR_MESSAGE)", "+              .build();", "+            ", "+            Utilities.setPopupLoc(dialog, JarOptionsDialog.this);", "+            dialog.showDialog();", "+          }", "+          if ((_jarAll.isSelected() || _jarClasses.isSelected()) && _makeExecutable.isSelected()) {", "-            JOptionPane.showMessageDialog(JarOptionsDialog.this, \"An error occured while creating the jar file. This could be because the file that you are writing to or the file you are reading from could not be opened.\", \"Error: File Access\", JOptionPane.ERROR_MESSAGE);", "-            JarOptionsDialog.this.setVisible(false);", "-          }else{", "-            JOptionPane.showMessageDialog(JarOptionsDialog.this, \"The supplied manifest does not conform to the 1.0 Manifest format specification.\", \"Error: Malformed Manifest\", JOptionPane.ERROR_MESSAGE);", "+            if (_exceptions.size()>0) {", "+              ScrollableListDialog<String> dialog = new ScrollableListDialog.Builder<String>()", "+                .setOwner(JarOptionsDialog.this)", "+                .setTitle(\"Error Creating Jar\")", "+                .setText(\"<html>An error occured while creating the jar file. This could be because the file<br>\"+", "+                         \"that you are writing to or the file you are reading from could not be opened.</html>\")", "+                .setItems(new ArrayList<String>(_exceptions))", "+                .setMessageType(JOptionPane.ERROR_MESSAGE)", "+                .build();", "+              ", "+              Utilities.setPopupLoc(dialog, JarOptionsDialog.this);", "+              dialog.showDialog();", "+            }", "+            else {", "+              JOptionPane.showMessageDialog(JarOptionsDialog.this, ", "+                                            \"An error occured while creating the jar file. This could be because the file that you \"+", "+                                            \"are writing to or the file you are reading from could not be opened.\", ", "+                                            \"Error Creating Jar\",", "+                                            JOptionPane.ERROR_MESSAGE);", "+            }", "-          ", "+          else {", "+            if (_exceptions.size()>0) {", "+              ScrollableListDialog<String> dialog = new ScrollableListDialog.Builder<String>()", "+                .setOwner(JarOptionsDialog.this)", "+                .setTitle(\"Error Creating Jar\")", "+                .setText(\"The supplied manifest does not conform to the 1.0 Manifest format specification\")", "+                .setItems(new ArrayList<String>(_exceptions))", "+                .setMessageType(JOptionPane.ERROR_MESSAGE)", "+                .build();", "+              ", "+              Utilities.setPopupLoc(dialog, JarOptionsDialog.this);", "+              dialog.showDialog();", "+            }", "+            else {", "+              JOptionPane.showMessageDialog(JarOptionsDialog.this, \"The supplied manifest does not conform to the 1.0 Manifest format specification.\",", "+                                            \"Error Creating Jar\",", "+                                            JOptionPane.ERROR_MESSAGE);", "+            }", "+          }", "+          JarOptionsDialog.this.setVisible(false);  "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa4c6a29a6d4f34ae0fd64c5a5201bbf", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/JLSTypeSystem.java", "commitBeforeChange": "80debf5b9716524c576a71fc4929233c9637cd68", "commitAfterChange": "0dc6c4e6c51f7a1991368187e63e0eff0d7150ef", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 42, "signatureBeforeChange": "          public boolean contains(final Type subT, final Type superT)", "signatureAfterChange": "          public boolean contains(final Type subT, final Type superT)", "diff": ["-      //debug.logStart(new String[]{\"subT\", \"superT\"}, subT, superT); try {", "+      debug.logStart(new String[]{\"subT\", \"superT\"}, wrap(subT), wrap(superT)); try {", "-        public Boolean forClassType(final ClassType subT) {", "+        @Override public Boolean forSimpleClassType(final SimpleClassType subT) {", "-            public Boolean defaultCase(Type superT) { return false; }", "+            @Override public Boolean defaultCase(Type superT) { return false; }", "-        public Boolean forParameterizedClassType(final ParameterizedClassType subT) {", "+        @Override public Boolean forRawClassType(final RawClassType subT) {", "-            public Boolean defaultCase(Type superT) { return false; }", "-            ", "+            @Override public Boolean defaultCase(Type superT) { return false; }", "+            @Override public Boolean forClassType(final ClassType superT) {", "+              Type newSub = immediateSupertype(subT);", "+              if (newSub == null) { return false; }", "+              else { return Subtyper.this.contains(newSub, superT); }", "+            }", "-                ", "-                Thunk<Boolean> containedArgs = new Thunk<Boolean>() {", "-                  public Boolean value() {", "-                    boolean result = true;", "-                    ParameterizedClassType subCapT = capture(subT);", "-                    for (final Triple<Type, Type, Type> args : zip(subT.typeArguments(),", "-                                                                   subCapT.typeArguments(), ", "-                                                                   superT.typeArguments())) {", "-                      result &= args.third().apply(new TypeAbstractVisitor<Boolean>() {", "-                        public Boolean defaultCase(Type superArg) {", "-                          return isEqual(args.second(), superArg);", "-                        }", "-                        @Override public Boolean forWildcard(final Wildcard superArg) {", "-                          Thunk<Boolean> inBounds = new Thunk<Boolean>() {", "-                            public Boolean value() {", "-                              Type subArg = args.second();", "-                              return Subtyper.this.contains(superArg.symbol().lowerBound(), subArg) &&", "-                                     Subtyper.this.contains(subArg, superArg.symbol().upperBound());", "-                            }", "-                          };", "-                          // if we've seen this sub arg/super arg combo before, we can prove subtyping inductively", "-                          // (assuming superArg appears in a valid context -- checked by isWellFormed)", "-                          // Put the pre-capture sub arg on the stack, because post-capture it may be a fresh var", "-                          return _stack.apply(inBounds, true, args.first(), superArg);", "-                        }", "-                      });", "-                      if (!result) { break; }", "-                    }", "-                    return result;", "-                  }", "-                };", "-                ", "-                return _stack.apply(containedArgs, false, subT, superT) || forClassType(superT);", "+                return Subtyper.this.contains(parameterize(subT), superT) || forClassType(superT);", "+          });", "+        }", "+        ", "+        public Boolean forParameterizedClassType(final ParameterizedClassType subT) {", "+          return superT.apply(new TypeAbstractVisitor<Boolean>() {", "+            @Override public Boolean defaultCase(Type superT) { return false; }", "-              else {", "-                return Subtyper.this.contains(newSub, superT) || Subtyper.this.contains(erase(subT), superT);", "+              else { return Subtyper.this.contains(newSub, superT); }", "+            }", "+            ", "+            @Override public Boolean forParameterizedClassType(final ParameterizedClassType superT) {", "+              if (subT.ofClass().equals(superT.ofClass())) {", "+                boolean result = true;", "+                ParameterizedClassType subCapT = capture(subT);", "+                for (final Triple<Type, Type, Type> args : zip(subT.typeArguments(),", "+                                                               subCapT.typeArguments(), ", "+                                                               superT.typeArguments())) {", "+                  result &= args.third().apply(new TypeAbstractVisitor<Boolean>() {", "+                    public Boolean defaultCase(Type superArg) {", "+                      return isEqual(args.second(), superArg);", "+                    }", "+                    @Override public Boolean forWildcard(final Wildcard superArg) {", "+                      Thunk<Boolean> inBounds = new Thunk<Boolean>() {", "+                        public Boolean value() {", "+                          Type subArg = args.second();", "+                          return Subtyper.this.contains(superArg.symbol().lowerBound(), subArg) &&", "+                                 Subtyper.this.contains(subArg, superArg.symbol().upperBound());", "+                        }", "+                      };", "+                      // if we've seen this sub arg/super arg combo before, we can prove subtyping inductively", "+                      // (assuming superArg appears in a valid context -- checked by isWellFormed)", "+                      // Put the pre-capture sub arg on the stack, because post-capture it may be a fresh var", "+                      return _stack.apply(inBounds, true, args.first(), superArg);", "+                    }", "+                  });", "+                  if (!result) { break; }", "+                }", "+                return result || forClassType(superT);", "+              else { return forClassType(superT); }", "+            }", "+            ", "+            @Override public Boolean forRawClassType(RawClassType superT) {", "+              if (subT.ofClass().equals(superT.ofClass())) {", "+                return Subtyper.this.contains(erase(subT), superT);", "+              }", "+              else { return forClassType(superT); }", "-      //} finally { debug.logEnd(); }", "+      } finally { debug.logEnd(); }"]}], "num": 12062}