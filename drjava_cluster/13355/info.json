{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a5ff81a6b5c9c9c388f569414e478aa5", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26d9fce65bbad57c77ea417829bc96a6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 24, "signatureBeforeChange": "   @Override public Type visit(SuperMethodCall node)", "signatureAfterChange": "     @Override public Type visit(SuperMethodCall node)", "diff": ["-   */", "-  @Override public Type visit(SuperMethodCall node) {", "-    Type t = context.getSuperType(ts);", "-    if (t == null) {", "-      throw new ExecutionError(\"super.undefined\", node);", "-    }", "-", "-    Iterable<? extends Expression> args = IterUtil.empty();", "-    if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "-    ", "-    Iterable<Type> targs = IterUtil.empty();", "-    if (node instanceof PolymorphicSuperMethodCall) {", "-      targs = checkTypeNameList(((PolymorphicSuperMethodCall) node).getTypeArguments());", "-    }", "-    ", "-    Expression obj = TypeUtil.makeEmptyExpression(node);", "-    setType(obj, t);", "-    try {", "-      TypeSystem.MethodInvocation inv = ts.lookupMethod(obj, node.getMethodName(), targs, args);", "-      // TODO: Check accessibility of method", "-      checkThrownExceptions(inv.thrown(), node);", "-      node.setArguments(CollectUtil.makeList(inv.args()));", "-      setMethod(node, inv.method());", "-      setDJClass(node, context.getThis());", "-      Type result = ts.capture(inv.returnType());", "-      debug.logValue(\"Type of method call \" + node.getMethodName(), ts.wrap(result));", "-      addRuntimeCheck(node, result, inv.method().returnType());", "-      return setType(node, result);", "-    }", "-    catch (InvalidTypeArgumentException e) {", "-      throw new ExecutionError(\"type.argument\", node);", "-    }", "-    catch (TypeSystemException e) {", "-      setErrorStrings(node, ts.userRepresentation(t), node.getMethodName(), nodeTypesString(args));", "-      throw new ExecutionError(\"no.such.method\", node);", "-    }", "-  }", "+     */", "+    @Override public Type visit(SuperMethodCall node) {", "+      Type t = context.getSuperType(ts);", "+      if (t == null) {", "+        throw new ExecutionError(\"super.undefined\", node);", "+      }", "+      ", "+      Iterable<? extends Expression> args = IterUtil.empty();", "+      if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "+      ", "+      Iterable<Type> targs = IterUtil.empty();", "+      if (node instanceof PolymorphicSuperMethodCall) {", "+        targs = checkTypeNameList(((PolymorphicSuperMethodCall) node).getTypeArguments());", "+      }", "+      ", "+      Expression obj = TypeUtil.makeEmptyExpression(node);", "+      setType(obj, t);", "+      try {", "+        MethodInvocation inv = ts.lookupMethod(obj, node.getMethodName(), targs, args, expected);", "+        // TODO: Check accessibility of method", "+        checkThrownExceptions(inv.thrown(), node);", "+        node.setArguments(CollectUtil.makeList(inv.args()));", "+        setMethod(node, inv.method());", "+        setDJClass(node, context.getThis());", "+        Type result = ts.capture(inv.returnType());", "+        debug.logValue(\"Type of method call \" + node.getMethodName(), ts.wrap(result));", "+        addRuntimeCheck(node, result, inv.method().returnType());", "+        return setType(node, result);", "+      }", "+      catch (InvalidTypeArgumentException e) {", "+        throw new ExecutionError(\"type.argument\", node);", "+      }", "+      catch (TypeSystemException e) {", "+        setErrorStrings(node, ts.userRepresentation(t), node.getMethodName(), nodeTypesString(args));", "+        throw new ExecutionError(\"no.such.method\", node);", "+      }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3490c32a32df26a5ba055a2f93c6c565", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 33, "signatureBeforeChange": "   @Override public Type visit(ConstructorCall node)", "signatureAfterChange": "     @Override public Type visit(ConstructorCall node)", "diff": ["+     */", "+    @Override public Type visit(ConstructorCall node) {", "+      if (node.getExpression() != null) {", "+        throw new IllegalArgumentException(\"Qualified constructor call not implemented\");", "+      }", "+      ", "+      Iterable<? extends Expression> args = IterUtil.empty();", "+      if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "+      ", "+      // TODO: implement explict type arguments in constructor calls", "+      Iterable<Type> targs = IterUtil.empty();", "+      ", "+      Type result;", "+      if (node.isSuper()) { result = context.getSuperType(ts); }", "+      else { result = SymbolUtil.thisType(context.getThis()); }", "+      if (result == null) {", "+        throw new IllegalArgumentException(\"Can't check a ConstructorCall in this context\");", "+      }", "+      ", "+      try {", "+        ConstructorInvocation inv = ts.lookupConstructor(result, targs, args, expected);", "+        ", "+        // TODO: Check accessibility of constructor", "+        // Note that super constructor calls *have to* be accessible, even if accessibility", "+        // checking is turned off -- a call to a private constructor cannot be compiled", "+        // in a way that it will run successfully (since constructor calls are the only code", "+        // that is directly compiled rather than being interpreted, we don't have this problem", "+        // elsewhere)", "+        checkThrownExceptions(inv.thrown(), node);", "+        node.setArguments(CollectUtil.makeList(inv.args()));", "+        setConstructor(node, inv.constructor());", "+        return setType(node, result);", "+      }", "+      catch (InvalidTypeArgumentException e) {", "+        throw new ExecutionError(\"type.argument\", node);", "+      }", "+      catch (TypeSystemException e) {", "+        setErrorStrings(node, ts.userRepresentation(result), nodeTypesString(args));", "-   */", "-  @Override public Type visit(ConstructorCall node) {", "-    if (node.getExpression() != null) {", "-      throw new IllegalArgumentException(\"Qualified constructor call not implemented\");", "-    }", "-    ", "-    Iterable<? extends Expression> args = IterUtil.empty();", "-    if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "-    ", "-    // TODO: implement explict type arguments in constructor calls", "-    Iterable<Type> targs = IterUtil.empty();", "-    ", "-    Type result;", "-    if (node.isSuper()) { result = context.getSuperType(ts); }", "-    else { result = SymbolUtil.thisType(context.getThis()); }", "-    if (result == null) {", "-      throw new IllegalArgumentException(\"Can't check a ConstructorCall in this context\");", "-    }", "-    ", "-    try {", "-      TypeSystem.ConstructorInvocation inv = ts.lookupConstructor(result, targs, args);", "-      ", "-      // TODO: Check accessibility of constructor", "-      // Note that super constructor calls *have to* be accessible, even if accessibility", "-      // checking is turned off -- a call to a private constructor cannot be compiled", "-      // in a way that it will run successfully (since constructor calls are the only code", "-      // that is directly compiled rather than being interpreted, we don't have this problem", "-      // elsewhere)", "-      checkThrownExceptions(inv.thrown(), node);", "-      node.setArguments(CollectUtil.makeList(inv.args()));", "-      setConstructor(node, inv.constructor());", "-      return setType(node, result);", "-    }", "-    catch (InvalidTypeArgumentException e) {", "-      throw new ExecutionError(\"type.argument\", node);", "-    }", "-    catch (TypeSystemException e) {", "-      setErrorStrings(node, ts.userRepresentation(result), nodeTypesString(args));", "-      throw new ExecutionError(\"no.such.constructor\", node);", "-    }", "-  }"]}], "num": 13355}