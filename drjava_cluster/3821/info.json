{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "aa5005b3250b7ade0880dd4115f2aa98", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7838648016c77323d35667050637f196", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyIntermediateVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": "\r \r \r     public void testForInnerInterfaceDef()", "signatureAfterChange": "       public void testForInnerInterfaceDef()", "diff": ["-\r", "-    public void testForInnerInterfaceDef() {\r", "-      SymbolData obj = new SymbolData(\"java.lang.Object\");\r", "-      symbolTable.put(\"java.lang.Object\", obj);\r", "-      InnerInterfaceDef cd1 = new InnerInterfaceDef(JExprParser.NO_SOURCE_INFO, _packageMav, new Word(JExprParser.NO_SOURCE_INFO, \"Bart\"),\r", "-                                       new TypeParameter[0], new ReferenceType[0], \r", "-                                       new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));\r", "-      \r", "-      InnerInterfaceDef cd0 = new InnerInterfaceDef(JExprParser.NO_SOURCE_INFO, _packageMav, new Word(JExprParser.NO_SOURCE_INFO, \"Lisa\"),\r", "-                                       new TypeParameter[0], new ReferenceType[0], \r", "-                                            new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {cd1}));\r", "-      \r", "-      SymbolData sd0 = new SymbolData(_cbiv._symbolData.getName() + \"$Lisa\", _packageMav, new TypeParameter[0], new LinkedList<SymbolData>(), null); \r", "-      SymbolData sd1 = new SymbolData(_cbiv._symbolData.getName() + \"$Lisa$Bart\", _packageMav, new TypeParameter[0], new LinkedList<SymbolData>(), null);\r", "-      sd0.addInnerInterface(sd1);\r", "-      sd0.setIsContinuation(true);\r", "-      sd1.setIsContinuation(true);\r", "-      \r", "-      symbolTable.put(_cbiv._symbolData.getName() + \"$Lisa\", sd0);\r", "-      symbolTable.put(_cbiv._symbolData.getName() + \"$Lisa$Bart\", sd1);\r", "-\r", "-      cd0.visit(_cbiv);\r", "-\r", "-      SymbolData sd = _cbiv._symbolData.getInnerClassOrInterface(\"Lisa\");\r", "-\r", "-      // NOTE: No longer allowing inner interfaces at the intermediate level\r", "-      assertEquals(\"There should be one error\", 1, errors.size());\r", "-      assertEquals(\"The error message should be correct\", \"Nested interfaces cannot be used at the Intermediate level\", errors.get(0).getFirst());\r", "-    }\r", "+", "+    public void testForInnerInterfaceDef() {", "+      SymbolData obj = new SymbolData(\"java.lang.Object\");", "+      symbolTable.put(\"java.lang.Object\", obj);", "+      InnerInterfaceDef cd1 = new InnerInterfaceDef(JExprParser.NO_SOURCE_INFO, _packageMav, ", "+                                                    new Word(JExprParser.NO_SOURCE_INFO, \"Bart\"),", "+                                       new TypeParameter[0], new ReferenceType[0], ", "+                                       new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));", "+      ", "+      InnerInterfaceDef cd0 = new InnerInterfaceDef(JExprParser.NO_SOURCE_INFO, _packageMav, ", "+                                                    new Word(JExprParser.NO_SOURCE_INFO, \"Lisa\"),", "+                                       new TypeParameter[0], new ReferenceType[0], ", "+                                            new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {cd1}));", "+      ", "+      SymbolData sd0 = new SymbolData(_cbiv._classData.getName() + \"$Lisa\", _packageMav, new TypeParameter[0], ", "+                                      new LinkedList<SymbolData>(), null); ", "+      SymbolData sd1 = new SymbolData(_cbiv._classData.getName() + \"$Lisa$Bart\", _packageMav, new TypeParameter[0], ", "+                                      new LinkedList<SymbolData>(), null);", "+      sd0.addInnerInterface(sd1);", "+      sd0.setIsContinuation(true);", "+      sd1.setIsContinuation(true);", "+      ", "+      symbolTable.put(_cbiv._classData.getName() + \"$Lisa\", sd0);", "+      symbolTable.put(_cbiv._classData.getName() + \"$Lisa$Bart\", sd1);", "+", "+      cd0.visit(_cbiv);", "+", "+      SymbolData sd = _cbiv._classData.getInnerClassOrInterface(\"Lisa\");", "+", "+      // NOTE: No longer allowing inner interfaces at the intermediate level", "+      assertEquals(\"There should be one error\", 1, errors.size());", "+      assertEquals(\"The error message should be correct\", ", "+                   \"Nested interfaces cannot be used at the Intermediate level\", errors.get(0).getFirst());", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "befb5d255e28375dacdc3b1b3aa32bf2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyIntermediateVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": "\r     \r     public void testForAbstractMethodDef()", "signatureAfterChange": "          public void testForAbstractMethodDef()", "diff": ["-    \r", "-    public void testForAbstractMethodDef() {\r", "-      // Test one that works but needs to be augmented with public.\r", "-      MethodDef mdef = new AbstractMethodDef(JExprParser.NO_SOURCE_INFO, \r", "-                                             _abstractMav, \r", "-                                             new TypeParameter[0], \r", "-                                             new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), \r", "-                                             new Word(JExprParser.NO_SOURCE_INFO, \"methodName\"),\r", "-                                             new FormalParameter[0],\r", "-                                             new ReferenceType[0]);\r", "-      _cbiv._symbolData.setMav(_abstractMav);\r", "-\r", "-      mdef.visit(_cbiv);\r", "-      assertEquals(\"There should not be any errors\", 0, errors.size());\r", "-      assertEquals(\"_sd1 should contain 1 methods\", 1, _sd1.getMethods().size());\r", "-      assertTrue(\"The method should be public\", _sd1.getMethods().getFirst().hasModifier(\"public\"));\r", "-\r", "-      \r", "-      \r", "-      \r", "-      // Test one that doesn't work.\r", "-      mdef = new AbstractMethodDef(JExprParser.NO_SOURCE_INFO, \r", "-                                             _abstractMav, \r", "-                                             new TypeParameter[0], \r", "-                                             new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), \r", "-                                             new Word(JExprParser.NO_SOURCE_INFO, \"monkey\"),\r", "-                                             new FormalParameter[0],\r", "-                                             new ReferenceType[0]);\r", "-      mdef.visit(_cbiv);\r", "-      assertEquals(\"There should be one error.\", 1, errors.size());\r", "-      assertEquals(\"The error message should be correct.\", \r", "-                   \"Only constructors can have the same name as the class they appear in, and constructors do not have an explicit return type\",\r", "-                   errors.get(0).getFirst());\r", "-    }\r", "+    ", "+    public void testForAbstractMethodDef() {", "+      // Test one that works but needs to be augmented with public.", "+      MethodDef mdef = new AbstractMethodDef(JExprParser.NO_SOURCE_INFO, ", "+                                             _abstractMav, ", "+                                             new TypeParameter[0], ", "+                                             new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), ", "+                                             new Word(JExprParser.NO_SOURCE_INFO, \"methodName\"),", "+                                             new FormalParameter[0],", "+                                             new ReferenceType[0]);", "+      _cbiv._classData.setMav(_abstractMav);", "+", "+      mdef.visit(_cbiv);", "+      assertEquals(\"There should not be any errors\", 0, errors.size());", "+      assertEquals(\"_sd1 should contain 1 methods\", 1, _sd1.getMethods().size());", "+      assertTrue(\"The method should be default public\", _sd1.getMethods().getFirst().hasModifier(\"public\"));", "+", "+      ", "+      ", "+      ", "+      // Test one that doesn't work.", "+      mdef = new AbstractMethodDef(JExprParser.NO_SOURCE_INFO, ", "+                                             _abstractMav, ", "+                                             new TypeParameter[0], ", "+                                             new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), ", "+                                             new Word(JExprParser.NO_SOURCE_INFO, \"monkey\"),", "+                                             new FormalParameter[0],", "+                                             new ReferenceType[0]);", "+      mdef.visit(_cbiv);", "+      assertEquals(\"There should be one error.\", 1, errors.size());", "+      assertEquals(\"The error message should be correct.\", ", "+                   \"Only constructors can have the same name as the class they appear in, \" +", "+                   \"and constructors do not have an explicit return type\",", "+                   errors.get(0).getFirst());", "+    }"]}], "num": 3821}