{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "69f26ea944337f87ccd59b3bbe714912", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "33d0deab44a54222c4d61e0e1aabd011", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 292, "methodNumberAfterChange": 228, "signatureBeforeChange": "      private boolean containsMethod(Type t, final String name, final boolean requireStatic)", "signatureAfterChange": "   private boolean containsMethod(Type t, String name, boolean onlyStatic)", "diff": ["+  public boolean containsStaticMethod(Type t, String name) { return containsMethod(t, name, true); }", "+  private boolean containsMethod(Type t, String name, boolean onlyStatic) {", "+    MethodFinder<MethodInvocation> finder = new MethodFinder<MethodInvocation>(name, onlyStatic) {", "+      protected MethodInvocationCandidate<MethodInvocation> makeInvocationCandidate(DJMethod m,", "+                                                                                    ClassType declaringType) {", "+        // a version of the method that depends on no type information (which may not be available)", "+        DJMethod noSignatureMethod = new DelegatingMethod(m) {", "+          public Iterable<VariableType> declaredTypeParameters() { return IterUtil.empty(); }", "+          public Type returnType() { return BOTTOM; }", "+          public Iterable<Type> thrownTypes() { return IterUtil.empty(); }", "+          @Override public Iterable<LocalVariable> declaredParameters() { return IterUtil.empty(); }", "+          protected Iterable<? extends Type> parameterTypes() { return IterUtil.empty(); }", "+        };", "+        // anonymous stub used only for inheritance checking", "+        return new MethodInvocationCandidate<MethodInvocation>(noSignatureMethod, OBJECT, EMPTY_TYPE_ITERABLE,", "+                                                                 IterUtil.<Expression>empty(), NONE_TYPE_OPTION) {", "+          public MethodInvocation invocation() { throw new UnsupportedOperationException(); }", "+          @Override public boolean overrides(FunctionInvocationCandidate<MethodInvocation> c) { return false; }", "+        };", "+      }", "+    };", "+    return finder.hasMatch(t);", "+  }", "-  ", "-  private boolean containsMethod(Type t, final String name, final boolean requireStatic) {", "-    debug.logStart(new String[]{\"t\",\"name\",\"requireStatic\"}, wrap(t), name, requireStatic); try {", "-    ", "-    class LookupMethod extends TypeAbstractVisitor<Iterable<Object>> {", "-      ", "-      private boolean _includePrivate;", "-      ", "-      public LookupMethod(boolean includePrivate) {", "-        _includePrivate = includePrivate;", "-      }", "-      ", "-      private boolean validMethod(DJMethod m) { ", "-        return", "-          (_includePrivate || !m.accessibility().equals(Access.PRIVATE)) &&", "-          (!requireStatic || m.isStatic());", "-      }", "-      ", "-      public Iterable<Object> defaultCase(Type t) { return IterUtil.empty(); }", "-      ", "-      @Override public Iterable<Object> forClassType(ClassType t) {", "-        debug.logValues(new String[]{\"t\",\"methods\"}, wrap(t), t.ofClass().declaredMethods());", "-        for (DJMethod m : t.ofClass().declaredMethods()) {", "-          if (m.declaredName().equals(name) && validMethod(m)) {", "-            return IterUtil.singleton(null);", "-          }", "-        }", "-        return IterUtil.empty();", "-      }", "-    }", "-    Iterable<? extends Object> results = lookupMember(t, new LookupMethod(true), new LookupMethod(false));", "-    return !IterUtil.isEmpty(results);", "-    ", "-    } finally { debug.logEnd(); }", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9ba511ff3c3af0fe0d9ea6f3f9c111c3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "plt/src/edu/rice/cs/plt/collect/DictionaryMap.java", "commitBeforeChange": "b479db0ddd970ef8169038bb251244ba6cce33f8", "commitAfterChange": "1f5f4df3d6b832b8f29758517ad3b40ec22b5426", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 2, "signatureBeforeChange": "      public Set<K> keySet()", "signatureAfterChange": "      public PredicateSet<K> keySet()", "diff": ["+  public PredicateSet<K> keySet() {", "+    return new AbstractPredicateSet<K>() {", "+      public boolean contains(Object o) { return _d.get(o) != null; }", "+      public Iterator<K> iterator() { return IterUtil.asIterator(_d.keys()); }", "+      public boolean isInfinite() { return false; }", "+      public boolean hasFixedSize() { return false; }", "+      public boolean isStatic() { return false; }", "+      @Override public int size() { return _d.size(); }", "+      @Override public int size(int b) { int s = _d.size(); return (s < b) ? s : b; }", "+      @Override public boolean isEmpty() { return _d.isEmpty(); }", "+      @Override public boolean remove(Object o) { return _d.remove(o) != null; }", "+    };", "-  public Set<K> keySet() { return _keys.value(); }"]}], "num": 7076}