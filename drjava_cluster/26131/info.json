{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "75d9275248751e685a72f63bb8b7c515", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1afdb6fe6a8b11ba7c96747d967a2e2f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/KeyBindingManager.java", "commitBeforeChange": "7100bfae3584eff8b8b1993fd999385d8f88ea13", "commitAfterChange": "6bcdef7d4202e06be1c5717fc181a0fdfcc7756a", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 14, "signatureBeforeChange": "      public void optionChanged(OptionEvent<KeyStroke> oce)", "signatureAfterChange": "      public void optionChanged(OptionEvent<Vector<KeyStroke>> oce)", "diff": ["+    public void optionChanged(OptionEvent<Vector<KeyStroke>> oce) {", "+      Set<KeyStroke> newKeys = new LinkedHashSet<KeyStroke>(oce.value);", "+      Set<KeyStroke> removed = new LinkedHashSet<KeyStroke>(_oldKeys);", "+      removed.removeAll(newKeys); // the keys that were removed", "+      Set<KeyStroke> added = new LinkedHashSet<KeyStroke>(newKeys);", "+      added.removeAll(_oldKeys); // the keys that were added", "+      Set<KeyStroke> retained = new LinkedHashSet<KeyStroke>(_oldKeys);", "+      retained.retainAll(newKeys); // the keys that were kept the same", "+      boolean update = false;", "+      KeyStrokeData data = _actionToDataMap.get(_a);", "+      if (data == null) {", "+        // Nothing to change", "+        return;", "-", "-    public void optionChanged(OptionEvent<KeyStroke> oce) {", "-      if (shouldUpdate(oce.value, _a)) {", "-        KeyStrokeData data = _actionToDataMap.get(_a);", "-        if (data == null) {", "-          // Nothing to change", "-          return;", "-        }", "-", "+      ", "+      // check for removed keys", "+      for(KeyStroke ks: removed) {", "-        //  keystroke has already been redefined and should not be removed!", "-        if (data.equals(_keyToDataMap.get(_ks))) {", "-          _keyToDataMap.remove(_ks);", "+        // keystroke has already been redefined and should not be removed!", "+        if (data.equals(_keyToDataMap.get(ks))) {", "+          _keyToDataMap.remove(ks);", "+          update = true;", "-", "-        //check for conflicting key binding", "-        if (_keyToDataMap.containsKey(oce.value) && _shouldCheckConflict) {", "-          //if new key in map, and shouldUpdate returns true, we are overwriting it", "-          KeyStrokeData conflictKSD = _keyToDataMap.get(oce.value);", "-          conflictKSD.setKeyStroke(KeyStrokeOption.NULL_KEYSTROKE);", "-          _updateMenuItem(conflictKSD);", "-          _keyToDataMap.remove(oce.value);", "-          DrJava.getConfig().setSetting(conflictKSD.getOption(), KeyStrokeOption.NULL_KEYSTROKE);", "-        }", "-", "-        if (oce.value != KeyStrokeOption.NULL_KEYSTROKE) {", "-          _keyToDataMap.put(oce.value,data);", "-        }", "-        data.setKeyStroke(oce.value);", "-        _updateMenuItem(data);", "-", "-        //Check associated shift-version's binding", "-        Action shiftAction = data.getShiftAction();", "-        if (shiftAction != null) {", "-          //_keyToActionMap.remove(addShiftModifier(_ks));", "-          KeyStrokeData shiftKSD = _actionToDataMap.get(shiftAction);", "-          _keyToDataMap.remove(shiftKSD.getKeyStroke());", "-          shiftKSD.setKeyStroke(addShiftModifier(oce.value));", "-          _keyToDataMap.put(shiftKSD.getKeyStroke(), shiftKSD);", "-          //mapInsert(addShiftModifier(oce.value), shiftAction);", "-        }", "-", "-        _ks = oce.value;", "-      else if (_ks != oce.value) {", "-        DrJava.getConfig().setSetting(oce.option, _ks);", "+      ", "+      // check added keys for conflicts", "+      for(KeyStroke ks: added) {", "+        if (shouldUpdate(ks, _a)) {          ", "+          _keyToDataMap.put(ks,data);", "+          retained.add(ks);", "+          update = true;", "+        }", "+      }", "+      ", "+      if (update) {        ", "+        Vector<KeyStroke> v = new Vector<KeyStroke>(retained);", "+        data.setKeyStrokes(v);", "+        updateMenuItem(data);", "+        _oldKeys = retained;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f5cb69fc5de6a4a5c58fda25835282b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "45afdf26640d7e2a166ed67c249ba6fd207b1d2b", "commitAfterChange": "e7a6b9c5a51a2cf7b9cfb5a10d90c24a3c7c3844", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "diff": ["-    /* The visitedFiles returned by any pass may include another file which is already scheduled for compilation.", "-     In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "-     already been done.  (An error is thrown if we do since it thinks the class has already been defined). */", "-    // WHAT visitedFiles are RETURNED?  HOW?  The return type is a Pair containing NO files!  I SMELL GLOBAL VARIABLES!", "-    LinkedList<File> filesNotToCheck = new LinkedList<File>();", "+//    /* The visitedFiles returned by any pass may include another file which is already scheduled for compilation.", "+//     In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "+//     already been done.  (An error is thrown if we do since it thinks the class has already been defined). */", "+//    // WHAT visitedFiles are RETURNED?  HOW?  The return type is a Pair containing NO files!  I SMELL GLOBAL VARIABLES!", "+//    LinkedList<File> filesNotToCheck = new LinkedList<File>();", "-    /* The number of files to compile may change if one file references another one.", "-     We don't want to visit these newly referenced files because they've already", "-     been visited. */", "-    // WHAT DOES VISIT MEAN?", "-    int originalNumOfFiles = files.length;", "+//    /* The number of files to compile may change if one file references another one.", "+//     We don't want to visit these newly referenced files because they've already", "+//     been visited. */", "+//    // WHAT DOES VISIT MEAN?", "+//    int originalNumOfFiles = files.length;", "-    /* Find the files in the File[] array files that are LL files. Do the parsing, conformance checking, and ", "-     * type-checking passes first for ALL files before proceeding to code augmentation.  Otherwise if one class's", "-     * superclass get augmented first, then it sees a lot of illegal constructs (e.g. public and constructors). */", "+    /* Find the files in the File[] array files that are LL, advanced or Full Java files. Do the parsing and conformance ", "+     * checking passes first for ALL files before proceeding to type-checking (for LL files) and code augmentation.  ", "+     * Type-checking and class augmentation require a complete symbol table. */", "-    /* Maintains the files we visit along with their visitors (for type checking step). */", "-    LinkedList<Pair<LanguageLevelVisitor, SourceFile>> visited = ", "-      new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>();", "+    /* Maintains the files we visit along with their visitors (for type checking and augmentation steps). */", "+    LinkedList<Triple<LanguageLevelVisitor, SourceFile, File>> visited = ", "+      new LinkedList<Triple<LanguageLevelVisitor, SourceFile, File>>();", "-    /* Maintains the list of advanced files, which are no longer parsed and checked; they are simply converted to .java", "-     * files unchanged and unchecked (except for nullity). */", "+    /* Maintains the files to be augmented along with their visitors (for augmentation step). */", "+    LinkedList<Triple<LanguageLevelVisitor, SourceFile, File>> toAugment = ", "+      new LinkedList<Triple<LanguageLevelVisitor, SourceFile, File>>();", "+    ", "+    /* Maintains the list of advanced files, which are converted to .java files and treated like .java files. */", "+    /* Maintains the list of Full Java files, which are parsed for symbols and checked for gross errors. */", "+    LinkedList<File> javaFiles = new LinkedList<File>();", "+    ", "+    /** First pass: classfication and conformance checking */", "-        if (filesNotToCheck.contains(f)) continue;  // Detects equal Files objects", "+//        if (filesNotToCheck.contains(f)) continue;  // Detects equal File objects", "-        if (isAdvancedFile(f)) advanced.addLast(f);", "+        if (isAdvancedFile(f))  advanced.addLast(f);", "+        else if (isFullJavaFile(f)) javaFiles.addLast(f);", "-        else if (_isLanguageLevelFile(f)) {  /* a .dj0 or .dj1 or .dj file */", "+        if (isJavaFile(f)) {  /* a .dj0, .dj1, .dj2,, .dj, or .java file */", "-          LanguageLevelVisitor llv = new IntermediateVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(),", "-                                                             new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "-                                                             languageLevelVisitedFiles);", "+          LanguageLevelVisitor llv;", "+          if (isLanguageLevelFile(f)) {", "+            llv = new IntermediateVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(),", "+                                          new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "+                                          languageLevelVisitedFiles);", "+          }", "+          else {", "+            assert isAdvancedFile(f) || isFullJavaFile(f);", "+            llv = new FullJavaVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(),", "+                                      new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "+                                      languageLevelVisitedFiles);", "+          }", "-          // First pass", "+          // Conformance checking pass", "-          visited.add(new Pair<LanguageLevelVisitor, SourceFile>(llv, sf));", "+          visited.add(new Triple<LanguageLevelVisitor, SourceFile, File>(llv, sf, f));", "-    ", "-//    Utilities.show(\"Visited \" + visited + \" in first pass\");", "-    // Resolve continuations and create constructors.  Also accumulate errors.", "+", "+    /* Resolve continuations created in conformance pass and log any generated errors. */", "-    ", "-    //Resolve continuations", "-    //Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>> continuations = llv.continuations;", "-//          System.err.println(\"Could not find SymbolData for '\" + className + \"'\");", "+//          if (className.equals(\"listFW.IList\")) {", "+//            System.err.println(\"Cannot resolve listFW.List\\nsymbolTable is:\\n\" + symbolTable);", "+//          }", "-    // Create any constructors.", "+    /* Create any constructors identified in the conformance pass and log any errors encountered. */", "-    }", "+    } ", "+    /* Add any errors that accumulated during the continuation resolving/constructor generation. */", "-    languageLevelVisitorErrors.addAll(LanguageLevelVisitor.errors); //add any errors that accumulated during the continuation resolving/constructor generation", "+    languageLevelVisitorErrors.addAll(LanguageLevelVisitor.errors); ", "-    // Check for errors; don't type-check if there are errors.", "+    ", "+    /* If there are no errors, perform type-checking on LL files. */", "-    else { //Let's TYPE CHECK!!!", "-      ", "-      ", "-      for (int ind = 0; ind < visited.size(); ind++) {", "+    else  { /* Perform type-checking on visited LL files and build list of files toAugment. */", "+      for (Triple<LanguageLevelVisitor, SourceFile, File> triple: visited) {", "-        LanguageLevelVisitor llv = visited.get(ind).getFirst();", "-        SourceFile sf = visited.get(ind).getSecond();", "+        LanguageLevelVisitor llv = triple.getFirst();", "+        SourceFile sf = triple.getSecond();", "+        File f = triple.getThird();", "-        ", "-        //TODO: This is a terrible hack to get around the following problem.  Basically, when we autobox in isAssignableTo in SymbolData, ", "-        //we look through the object hierarchy for the primitive.  If its corresponding boxed object isn't in the symboltable, we're in trouble.", "-        //So, for those special cases, go ahead and make sure the object types are in the symbol table before we start type checking.", "-        //I'd like to make this better, but at least it works for now.", "-        ", "-        // Note: \"llv.\" formerly preceded symbolTable and getSymbolData", "-        ", "-        //Before you type check, make sure that all boxed types of primitives are in the symbol table", "-        if (symbolTable.get(\"java.lang.Integer\") == null)   { llv.getSymbolData(\"java.lang.Integer\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Double\") == null)    { llv.getSymbolData(\"java.lang.Double\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Character\") == null) { llv.getSymbolData(\"java.lang.Character\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Boolean\") == null)   { llv.getSymbolData(\"java.lang.Boolean\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Long\") == null)      { llv.getSymbolData(\"java.lang.Long\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Byte\") == null)      { llv.getSymbolData(\"java.lang.Byte\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Short\") == null)     { llv.getSymbolData(\"java.lang.Short\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Float\") == null)     { llv.getSymbolData(\"java.lang.Float\", SourceInfo.NO_INFO);}", "-        ", "-        ", "-        // Type check.", "-        TypeChecker btc = ", "-          new TypeChecker(llv._file, llv._package, llv.errors, symbolTable, llv._importedFiles, llv._importedPackages);", "+        if (isAdvancedFile(f)) { toAugment.addLast(triple); }", "+        else if (isLanguageLevelFile(f)) {", "+          // This is a hack to get around the following problem.  Basically, when we autobox in isAssignableTo in ", "+          // SymbolData, we look through the object hierarchy for the primitive.  If its corresponding", "+          // boxed object isn't in the symboltable, we're in trouble.  So, for those special cases, go ahead and make ", "+          // sure the object types are in the symbol table before we start type checking", "+          ", "+          //Before you type check, make sure that all boxed types of primitives are in the symbol table", "+          ", "+          if (symbolTable.get(\"java.lang.Integer\") == null) llv.getSymbolData(\"java.lang.Integer\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Double\") == null)  llv.getSymbolData(\"java.lang.Double\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Boolean\") == null) llv.getSymbolData(\"java.lang.Boolean\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Long\") == null)    llv.getSymbolData(\"java.lang.Long\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Byte\") == null)    llv.getSymbolData(\"java.lang.Byte\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Short\") == null)   llv.getSymbolData(\"java.lang.Short\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Float\") == null)   llv.getSymbolData(\"java.lang.Float\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Character\") == null) ", "+            llv.getSymbolData(\"java.lang.Character\", SourceInfo.NO_INFO);", "+          ", "+          // Type check.", "+          TypeChecker btc = ", "+            new TypeChecker(llv._file, llv._package, llv.errors, symbolTable, llv._importedFiles, llv._importedPackages);", "-        sf.visit(btc);", "-        if (btc.errors.size() > 0) _visitorErrors.addAll(btc.errors);", "-      }", "-      ", "-      /* Set up code augmentation.  We will NOT try to augment files unless they appear in the visited List.  Unlisted", "-       * LL files cannot be found reliably during type checking because there is no naming convention that tells the ", "-       * type checker what files to look for. */", "-      ", "-      Iterator<Pair<LanguageLevelVisitor, SourceFile>> iter = visited.iterator();", "-      LinkedList<File> newFiles = new LinkedList<File>();", "-      for (int ind = 0; iter.hasNext(); ind++) { // Note unusual loop termination condition; iter, ind in lock step", "-        Pair<LanguageLevelVisitor, SourceFile> currPair = iter.next();", "-        File fileToAdd = currPair.getFirst()._file;", "-        ", "-        if (_isLanguageLevelFile(fileToAdd)) { // fileToAdd is a visited LL file", "-//          Utilities.show(fileToAdd + \" is a LL file for augmentation\");", "-          newFiles.addLast(fileToAdd);", "-          mediator.put(ind, new Pair<SourceFile, LanguageLevelVisitor>(currPair.getSecond(), currPair.getFirst())); ", "+          sf.visit(btc);", "+          toAugment.addLast(triple);", "+          if (btc.errors.size() > 0) _visitorErrors.addAll(btc.errors);", "-        ", "-        // Also make sure not to re-check these files whether we visited source or class file. ", "-        // We only want to perform code augmentation since these files have already been visited.", "-        if (! filesNotToCheck.contains(fileToAdd)) filesNotToCheck.addLast(fileToAdd);", "-      newFiles.addAll(advanced);", "-      files = newFiles.toArray(new File[newFiles.size()]);  // include advanced files", "-//      Utilities.show(\"Created files array: \" + Arrays.toString(files));", "+//      /* Set up code augmentation.  We will NOT try to augment files unless they appear in the visited List and are not", "+//       * already Full Java (.java) files.  Unlisted LL files cannot be found reliably during type checking because there", "+//       * is no naming convention that tells the type checker what files to look for. */", "+      ", "+//      Iterator<Pair<LanguageLevelVisitor, SourceFile>> iter = visited.iterator();", "+//      LinkedList<File> filesToAugment = new LinkedList<File>();", "+//      for (int ind = 0; iter.hasNext(); ind++) { // Note unusual loop termination condition; iter, ind in lock step", "+//        Pair<LanguageLevelVisitor, SourceFile> currPair = iter.next();", "+//        File fileToAdd = currPair.getFirst()._file;", "+//        ", "+//        if (isLanguageLevelFile(fileToAdd)) { // fileToAdd is a visited LL file", "+////          Utilities.show(fileToAdd + \" is a LL file for augmentation\");", "+//          filesToAugment.addLast(fileToAdd);", "+//          mediator.put(ind, new Pair<SourceFile, LanguageLevelVisitor>(currPair.getSecond(), currPair.getFirst())); ", "+//        }", "+//        ", "+//        // Also make sure not to re-check these files whether we visited source or class file. ", "+//        // We only want to perform code augmentation since these files have already been visited.", "+////        if (! filesNotToCheck.contains(fileToAdd)) filesNotToCheck.addLast(fileToAdd);", "+//      }", "+//      ", "+//      filesToAugment.addAll(advanced);  // include advanced files in files to augment", "+//      files = filesToAugment.toArray(new File[filesToAugment.size()]); ", "+////      Utilities.show(\"Created files array: \" + Arrays.toString(files));", "-      return new Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions, _visitorErrors);", "+      return new Pair<LinkedList<JExprParseException>, ", "+        LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions, _visitorErrors);", "-    // Now do code augmentation.", "-    for (int ind = 0; ind < files.length; ind++) {", "-      File f = files[ind];", "+    ", "+    /* Perform code augmentation. */   ", "+    for (Triple<LanguageLevelVisitor, SourceFile, File> triple: toAugment) ", "+      ", "+      LanguageLevelVisitor llv = triple.getFirst();", "+      SourceFile sf = triple.getSecond();", "+      File f = triple.getThird();", "+      ", "+      File augmentedFile = getJavaForLLFile(f); // create  empty .java file for .dj? file", "+      ", "+      if (isAdvancedFile(f)) { Utilities.copyFile(f, augmentedFile); }", "+      else {", "+        BufferedReader tempBr = new BufferedReader(new FileReader(f));", "+        String firstLine = tempBr.readLine();", "+        tempBr.close(); // Important to close the reader, otherwise Windows will not allow the renameTo call later.", "+        if (firstLine == null) continue;", "-        // Set up augmented file", "-        File augmentedFile = getJavaForLLFile(f); //replace .dj? with .java", "-        ", "-        if (isAdvancedFile(f)) {", "-          Utilities.copyFile(f, augmentedFile);", "-        }", "-        else {", "-//        Utilities.show(\"File is: \" + f + \" mediator is: \" + mediator.get(ind));", "-          BufferedReader tempBr = new BufferedReader(new FileReader(f));", "-          String firstLine = tempBr.readLine();", "-          tempBr.close(); // Important to close the reader, otherwise Windows will not allow the renameTo call later.", "-          if (firstLine == null) continue;", "-          ", "-          // If the file has an appropriate LL extension, then parse it.", "-          if (_isLanguageLevelFile(f)) {", "-            Pair<SourceFile, LanguageLevelVisitor> pair = mediator.get(new Integer(ind));", "-            if (pair == null) {", "-              // _log.log(\"Not augmenting \" + f + \" no mediator\");", "-//            Utilities.show(\"Not augmenting \" + f + \" no mediator\");", "-            }", "+        // If the file has an appropriate LL extension, then parse it.", "+        if (isLanguageLevelFile(f)) {", "+          if (triple != null) {  // if triple is null, we do not actually need to augment this file--it wasn't visited.", "-            if (pair != null) { //if pair is null, we do not actually need to augment this file--it wasn't visited.  Maybe we used the class file?", "-              SourceFile sf = pair.getFirst();", "-              LanguageLevelVisitor llv = pair.getSecond();", "-//            File f = files[ind];", "-              ", "-              // Do code augmentation", "-              BufferedReader br = new BufferedReader(new FileReader(f), INPUT_BUFFER_SIZE);", "-              StringWriter sw = new StringWriter();", "-              BufferedWriter bw = new BufferedWriter(sw);", "-              ", "-              // _log.log(\"Augmenting the source file \" + sf);", "+            // Do code augmentation", "+            BufferedReader br = new BufferedReader(new FileReader(f), INPUT_BUFFER_SIZE);", "+            StringWriter sw = new StringWriter();", "+            BufferedWriter bw = new BufferedWriter(sw);", "+            ", "+            // _log.log(\"Augmenting the source file \" + sf);", "-              Augmentor a = new Augmentor(SAFE_SUPPORT_CODE, br, bw, llv);", "-              sf.visit(a);", "-              ", "-              br.close();", "-              bw.close();", "-              ", "-              // write out the line number map and the augmented java file", "-              PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(augmentedFile)));", "-              SortedMap<Integer,Integer> lineNumberMap = a.getLineNumberMap();", "-              pw.println(\"// Language Level Converter line number map: dj*->java. Entries: \"+lineNumberMap.size());", "-              // We print out LINE_NUM_MAPPINGS_PER_LINE mappings per line, so we need numLines", "-              // at the top of the file, and one more for a descriptive comment.", "-              // That means we need to increase the line numbers in the generated java file by numLines+1", "-              int numLines = (int)Math.ceil(((double)lineNumberMap.size())/LINE_NUM_MAPPINGS_PER_LINE);", "-              int mapCount = 0;", "-              for(Map.Entry<Integer,Integer> e: lineNumberMap.entrySet()) {", "-                // e.getKey(): dj* line number; e.getValue(): java line number (must be increased by numLines)", "-                if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==0) pw.print(\"//\");", "-                pw.printf(\" %5d->%-5d\", e.getKey(), (e.getValue()+numLines+1));", "-                if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==LINE_NUM_MAPPINGS_PER_LINE-1) pw.println();", "-                ++mapCount;", "-              }", "-              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE!=0) pw.println(); // print a newline unless we just printed one", "-              ", "-              String augmented = sw.toString();", "-              pw.write(augmented, 0, augmented.length());", "-              pw.close();", "+            Augmentor a = new Augmentor(SAFE_SUPPORT_CODE, br, bw, llv);", "+            sf.visit(a);", "+            ", "+            br.close();", "+            bw.close();", "+            ", "+            // write out the line number map and the augmented java file", "+            PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(augmentedFile)));", "+            SortedMap<Integer,Integer> lineNumberMap = a.getLineNumberMap();", "+            pw.println(\"// Language Level Converter line number map: dj*->java. Entries: \"+lineNumberMap.size());", "+            // We print out LINE_NUM_MAPPINGS_PER_LINE mappings per line, so we need numLines", "+            // at the top of the file, and one more for a descriptive comment.", "+            // That means we need to increase the line numbers in the generated java file by numLines+1", "+            int numLines = (int)Math.ceil(((double)lineNumberMap.size())/LINE_NUM_MAPPINGS_PER_LINE);", "+            int mapCount = 0;", "+            for(Map.Entry<Integer,Integer> e: lineNumberMap.entrySet()) {", "+              // e.getKey(): dj* line number; e.getValue(): java line number (must be increased by numLines)", "+              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==0) pw.print(\"//\");", "+              pw.printf(\" %5d->%-5d\", e.getKey(), (e.getValue()+numLines+1));", "+              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==LINE_NUM_MAPPINGS_PER_LINE-1) pw.println();", "+              ++mapCount;", "+            if (mapCount%LINE_NUM_MAPPINGS_PER_LINE!=0) pw.println(); // print a newline unless we just printed one", "+            ", "+            String augmented = sw.toString();", "+            pw.write(augmented, 0, augmented.length());", "+            pw.close();", "-      catch (Augmentor.Exception ae) {", "-        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-        _addVisitorError(new Pair<String, JExpressionIF>(ae.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "-      }", "-      catch (IOException ioe) {", "-        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-        _addVisitorError(new Pair<String, JExpressionIF>(ioe.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "-      }", "-    return new Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions,", "-                                                                                              _visitorErrors);", "+    catch (Augmentor.Exception ae) {", "+      // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "+      _addVisitorError(new Pair<String, JExpressionIF>(ae.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "+    }", "+    catch (IOException ioe) {", "+      // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "+      _addVisitorError(new Pair<String, JExpressionIF>(ioe.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "+    }", "+    return new Pair<LinkedList<JExprParseException>, ", "+      LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions, _visitorErrors);"]}], "num": 26131}