{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4ddcb9a15d01494957fa4ec2ae0703fd", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c4e8584e72c0fe74714abb1f77251d41", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/newjvm/InterpreterJVM.java", "commitBeforeChange": "43f41a369ae2fab400ffccc265d57e86cf8989d7", "commitAfterChange": "e0e957550963e046bdbb3a11cc062ff5ce5c9c2b", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 28, "signatureBeforeChange": "   protected void quitFailed(Exception e)", "signatureAfterChange": "   protected void quitFailed(Throwable th)", "diff": ["-  protected void quitFailed(Exception e) {    ", "-    javax.swing.JOptionPane.showMessageDialog(null, ", "-                                              \"DrJava's interpreterJVM could not be exited:\\n\" + e);", "+  protected void quitFailed(Throwable th) {", "+    if (_messageOnResetFailure) {", "+      String msg = \"The interactions pane could not be reset:\\n\" + th;", "+      javax.swing.JOptionPane.showMessageDialog(null, msg);", "+    }", "+    ", "+    try {", "+      _mainJVM.quitFailed(th);", "+    }", "+    catch (RemoteException re) {", "+      // nothing to do", "+      _log.logTime(\"quitFailed: \" + re.toString());", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fe0f6f8c8b97150500d3f057b3894988", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/newjvm/InterpreterJVM.java", "commitBeforeChange": "0126ea99e5c318f1f9907f0c07d77641969ffef5", "commitAfterChange": "fa54651cc7ac0d03884ebcafd7e8520df74651a1", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 8, "signatureBeforeChange": "   public void interpret(final String input, final InterpreterData interpreter)", "signatureAfterChange": "   public void interpret(final String input, final InterpreterData interpreter)", "diff": ["-//    Utilities.showDebug(\"InterpreterJVM.interpret(\" + input + \", ...) called\");", "-    Thread thread = new Thread(\"interpret thread: \" + input) {", "-      public void run() {", "-        String s = input;", "-        try {", "-          interpreter.setInProgress(true);", "-          try {", "-            _dialog(\"to interp: \" + s);", "-            ", "-            String s1 = s;  //_interactionsProcessor.preProcess(s);", "-//            Utilities.showDebug(\"Preparing to invoke interpret method on \" + s1);", "-            Object result = interpreter.getInterpreter().interpret(s1);", "-            String resultString = String.valueOf(result);", "-//            Utilities.showDebug(\"Result string is: \" + resultString);", "-            ", "-            if (result == Interpreter.NO_RESULT) {", "-              //return new VoidResult();", "-              //_dialog(\"void interp ret: \" + resultString);", "-              _mainJVM.interpretResult(new VoidResult());", "-            }", "-            else {", "-              // we use String.valueOf because it deals with result = null!", "-              //_dialog(\"about to tell main result was \" + resultString);", "-              //return new ValueResult(resultString);", "-              String style = InteractionsDocument.OBJECT_RETURN_STYLE;", "-              if (result instanceof String) {", "-                style = InteractionsDocument.STRING_RETURN_STYLE;", "-                //Single quotes have already been added to chars by now, so they are read as strings", "-                String possibleChar = (String)result;", "-                ", "-                if (possibleChar.startsWith(\"\\'\") && possibleChar.endsWith(\"\\'\") && possibleChar.length()==3)", "-                  style = InteractionsDocument.CHARACTER_RETURN_STYLE;                ", "-              }", "-              if (result instanceof Number) style = InteractionsDocument.NUMBER_RETURN_STYLE;", "-              _mainJVM.interpretResult(new ValueResult(resultString, style));", "-              ", "-            }", "-          }", "-          catch (ExceptionReturnedException e) {", "-            Throwable t = e.getContainedException();", "-//            Utilities.showStackTrace(t);", "-            _dialog(\"interp exception: \" + t);", "-            // TODO: replace the following if ladder by dynamic dispatch.  Create a visitor for DynamicJava errors?", "-            if (t instanceof ParseException)", "-              _mainJVM.interpretResult(new SyntaxErrorResult((ParseException) t, input));", "-            else if (t instanceof TokenMgrError)", "-              _mainJVM.interpretResult(new SyntaxErrorResult((TokenMgrError) t, input));", "-            else if (t instanceof ParseError)", "-              _mainJVM.interpretResult(new SyntaxErrorResult((ParseError) t, input));", "-            else {", "-              //Other exceptions are non lexical/parse related exceptions. These include arithmetic exceptions, ", "-              //wrong version exceptions, etc.", "-              ", "-              _mainJVM.interpretResult(new ExceptionResult(t.getClass().getName(), t.getMessage(),", "-                                                           InterpreterJVM.getStackTrace(t), null));", "-            }                                                                                                                                        ", "-          }", "-          catch (Throwable t) {", "-            // A user's toString method might throw anything, so we need to be careful", "-            _dialog(\"irregular interp exception: \" + t);", "-//            Utilities.showStackTrace(t);", "-            String shortMsg = null;", "-            if ((t instanceof ParseError) &&  ((ParseError) t).getParseException() != null) ", "-              shortMsg = ((ParseError) t).getMessage(); // in this case, getMessage is equivalent to getShortMessage", "-            _mainJVM.interpretResult(new ExceptionResult(t.getClass().getName(), t.getMessage(),", "-                                                         InterpreterJVM.getStackTrace(t), shortMsg));", "-          }          ", "+    try {", "+      synchronized(this) { ", "+        if (interpretationInProgress) {", "+            _mainJVM.interpretResult(new InterpreterBusy());", "+          return;", "-        catch (RemoteException re) {", "-          // Can't communicate with MainJVM?  Nothing to do...", "-          _log.logTime(\"interpret: \" + re.toString());", "-        }", "-        finally {", "-          interpreter.setInProgress(false);", "-        }", "+      interpretationInProgress = true; ", "+      interpreter.setInProgress(true);  // records that a given interpreter is in progress (used by debugger?)", "-    };", "-    ", "-    thread.setDaemon(true);", "-    thread.start();", "+      // The following code is NOT synchronized on this. Mutual exclusion is guaranteed by preceding synchronized block.", "+//        Utilities.showDebug(\"InterpreterJVM.interpret(\" + input + \", ...) called\");", "+      Thread thread = new Thread(\"interpret thread: \" + input) {", "+        public void run() {", "+          String s = input;", "+          try {  // Delimiting a catch for RemoteExceptions that might be thrown in catch clauses of enclosed try", "+            try {", "+              _dialog(\"to interp: \" + s);", "+              ", "+//            Utilities.showDebug(\"Preparing to invoke interpret method on \" + s);", "+              Object result = interpreter.getInterpreter().interpret(s);", "+              String resultString = String.valueOf(result);", "+//            Utilities.showDebug(\"Result string is: \" + resultString);", "+              ", "+              if (result == Interpreter.NO_RESULT) {", "+                //return new VoidResult();", "+                //_dialog(\"void interp ret: \" + resultString);", "+                _mainJVM.interpretResult(new VoidResult());", "+              }", "+              else {", "+                // we use String.valueOf because it deals with result = null!", "+                //_dialog(\"about to tell main result was \" + resultString);", "+                //return new ValueResult(resultString);", "+                String style = InteractionsDocument.OBJECT_RETURN_STYLE;", "+                if (result instanceof String) {", "+                  style = InteractionsDocument.STRING_RETURN_STYLE;", "+                  //Single quotes have already been added to chars by now, so they are read as strings", "+                  String possibleChar = (String)result;", "+                  ", "+                  if (possibleChar.startsWith(\"\\'\") && possibleChar.endsWith(\"\\'\") && possibleChar.length()==3)", "+                    style = InteractionsDocument.CHARACTER_RETURN_STYLE;                ", "+                }", "+                if (result instanceof Number) style = InteractionsDocument.NUMBER_RETURN_STYLE;", "+                _mainJVM.interpretResult(new ValueResult(resultString, style));", "+              }", "+            }", "+            catch (ExceptionReturnedException e) {", "+              Throwable t = e.getContainedException();", "+//            Utilities.showStackTrace(t);", "+              _dialog(\"interp exception: \" + t);", "+              // TODO: replace the following if ladder by dynamic dispatch.  Create a visitor for DynamicJava errors?", "+              if (t instanceof ParseException)", "+                _mainJVM.interpretResult(new SyntaxErrorResult((ParseException) t, input));", "+              else if (t instanceof TokenMgrError)", "+                _mainJVM.interpretResult(new SyntaxErrorResult((TokenMgrError) t, input));", "+              else if (t instanceof ParseError)", "+                _mainJVM.interpretResult(new SyntaxErrorResult((ParseError) t, input));", "+              else {", "+                //Other exceptions are non lexical/parse related exceptions. These include arithmetic exceptions, ", "+                //wrong version exceptions, etc.", "+                ", "+                _mainJVM.interpretResult(new ExceptionResult(t.getClass().getName(), t.getMessage(),", "+                                                             InterpreterJVM.getStackTrace(t), null));", "+              }                                                                                                                                        ", "+            }", "+            catch (Throwable t) {", "+              // A user's toString method might throw anything, so we need to be careful", "+              _dialog(\"irregular interp exception: \" + t);", "+//            Utilities.showStackTrace(t);", "+              String shortMsg = null;", "+              if ((t instanceof ParseError) &&  ((ParseError) t).getParseException() != null) ", "+                shortMsg = ((ParseError) t).getMessage(); // in this case, getMessage is equivalent to getShortMessage", "+              _mainJVM.interpretResult(new ExceptionResult(t.getClass().getName(), t.getMessage(),", "+                                                           InterpreterJVM.getStackTrace(t), shortMsg));", "+            }", "+          }", "+          catch(RemoteException re) { /* MainJVM no longer accessible.  Cannot recover. */  ", "+            _log.log(\"MainJVM.interpret threw \" + re.toString());", "+          }", "+        }", "+      }; // end of Thread definition", "+      ", "+      thread.setDaemon(true);", "+      thread.start();", "+    } // end of interpretation block including synchronized prelude ", "+    catch(RemoteException re) { /* MainJVM not accessible.  Cannot recover. */  ", "+      _log.log(\"MainJVM.interpret threw\" + re.toString());", "+    }", "+    finally { // fields are volatile so no synchronization is necessary", "+      interpretationInProgress = false;", "+      interpreter.setInProgress(false); ", "+    }"]}], "num": 14626}