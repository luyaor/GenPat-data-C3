{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "32562509a596288d706aca4bf54f313d", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35fa5238bbf48d72bca4862533d8a32f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/jpda/JPDADebugger.java", "commitBeforeChange": "5293cb4cfbc2f45d6061ba4101ad60348aa251ed", "commitAfterChange": "f68f43e5a680bb235f87f6125c6c0de6d15a12f4", "methodNumberBeforeChange": 71, "methodNumberAfterChange": 67, "signatureBeforeChange": "   private synchronized void _updateWatches() throws DebugException", "signatureAfterChange": "   private synchronized void _updateWatches()", "diff": ["-  private synchronized void _updateWatches() throws DebugException {", "+  private synchronized void _updateWatches() {", "-    if (_suspendedThreads.size() <= 0) {", "-      // Not suspended, get values in interpreter", "-      for (int i = 0; i < _watches.size(); i++) {", "-        DebugWatchData currWatch = _watches.get(i);", "-        if (!_getWatchFromInterpreter(currWatch)) currWatch.hideValueAndType();", "-      }", "-      return;", "-//      for (int i = 0; i < _watches.size(); i++) {", "-//        DebugWatchData currWatch = _watches.get(i);", "-//        currWatch.hideValueAndType();", "-//      }", "-//      return;", "-    }", "-", "-    try {", "-      StackFrame currFrame;", "-      List<StackFrame> frames;", "-      ThreadReference thread = _suspendedThreads.peek();", "-      if (thread.frameCount() <= 0 ) {", "-        printMessage(\"Could not update watch values. The current thread had no stack frames.\");", "-        return;", "-      }", "-      frames = thread.frames(); // JDK 1.5 will eliminate this warning", "-      currFrame = frames.get(0);", "-      Location location = currFrame.location();", "-", "-      ReferenceType rt = location.declaringType();", "-      ObjectReference obj = currFrame.thisObject();", "-      // note: obj is null if we're in a static context", "-", "-      // Get the name to determine how many $'s there are", "-      String rtName = rt.name();", "-      int numDollars = 0;", "-      int dollarIndex = rtName.indexOf(\"$\", 0);", "-      while (dollarIndex != -1) {", "-        numDollars++;", "-        dollarIndex = rtName.indexOf(\"$\", dollarIndex+1);", "-      }", "-", "-      for (int i = 0; i < _watches.size(); i++) {", "-        DebugWatchData currWatch = _watches.get(i);", "-        String currName = currWatch.getName();", "-        if (_getWatchFromInterpreter(currWatch)) {", "-          continue;", "-        }", "-//        // check for \"this\"", "-//        if (currName.equals(\"this\")) {", "-//          if (obj != null) {", "-//            currWatch.setValue(_getValue(obj));", "-//            currWatch.setType(String.valueOf(obj.type()));", "-//          }", "-//          else {", "-//            // \"this\" is not defined in a static context", "-//            currWatch.setNoValue();", "-//            currWatch.setNoType();", "-//          }", "-//          continue;", "-//        }", "-", "-//        // Look for a variable with this name", "-//        LocalVariable localVar = null;", "-//        try {", "-//          frames = thread.frames();", "-//          currFrame = (StackFrame) frames.get(0);", "-//          localVar = currFrame.visibleVariableByName(currName);", "-//        }", "-//        catch (AbsentInformationException aie) {", "-//          // Not compiled with debug flag.... ignore", "-//        }", "-//        catch (InvalidStackFrameException isfe) {", "-//          currWatch.setNoValue();", "-//          currWatch.setNoType();", "-//          _log(\"Failed to get local var from stack frame\", isfe);", "-//          continue;", "-//        }", "-//", "-//        if (localVar != null) {", "-//          // currWatch.setValue(_getValue(currFrame.getValue(localVar)));", "-//          try {", "-//            Value v = _getValueOfLocalVariable(localVar, thread);", "-//            if (v == null) {", "-//              currWatch.setValue(_getValue(null));", "-//              try {", "-//                currWatch.setType(localVar.type().name());", "-//              }", "-//              catch (ClassNotLoadedException cnle) {", "-//                List classes = _vm.classesByName(localVar.typeName());", "-//                if (!classes.isEmpty()) {", "-//                  currWatch.setType(((Type)classes.get(0)).name());", "-//                }", "-//                else {", "-//                  currWatch.setTypeNotLoaded();", "-//                }", "-//              }", "-//            }", "-//            else {", "-//              currWatch.setValue(_getValue(v));", "-//              currWatch.setType(v.type().name());", "-//            }", "-//          }", "-//          catch (Exception ex) {", "-//            _log(\"Exception when getting the value of a local variable\", ex);", "-//            currWatch.setNoValue();", "-//            currWatch.setNoType();", "-//          }", "-//        }", "-        // if the variable being watched is not a local variable,", "-        //  check if it's a field", "-        ReferenceType outerRt = rt;", "-        ObjectReference outer = obj;  // (null if static context)", "-        Field field = outerRt.fieldByName(currName);", "-", "-        if (obj != null) {", "-          // We're not in a static context", "-", "-          // If we don't find it in this class, loop through any enclosing", "-          // classes. Start at this$N, where N is the number of dollar signs in", "-          // the reference type's name, minus one.", "-          int outerIndex = numDollars - 1;", "-          if (hasAnonymous(outerRt)) {", "-            // We don't know the appropriate this$N to look for so we have to", "-            // search for a field that begins with this$.", "-            List<Field> fields = outerRt.allFields();  // This type warning will go away in JDK 1.5", "-            Iterator<Field> iter = fields.iterator();", "-            while (iter.hasNext()) {", "-              Field f = iter.next();", "-              String name = f.name();", "-              if (name.startsWith(\"this$\")) {", "-                int lastIndex = name.lastIndexOf(\"$\");", "-                outerIndex = Integer.valueOf(name.substring(lastIndex+1, name.length())).intValue();", "-                break;", "-              }", "-            }", "-          }", "-          Field outerThis = outerRt.fieldByName(\"this$\" + outerIndex);", "-          if (field == null) {", "-            // Try concatenating \"val$\" to the beginning of the field in", "-            // case it's a final local variable of the outer class", "-            field = outerRt.fieldByName(\"val$\" + currName);", "-          }", "-", "-          while ((field == null) && (outerThis != null)) {", "-            outer = (ObjectReference) outer.getValue(outerThis);", "-            if (outer == null) {", "-              // We're probably in the constructor and this$N has", "-              // not yet been initialized. We can't do anything, so just", "-              // break display no value.", "-              break;", "-            }", "-            outerRt = outer.referenceType();", "-            field = outerRt.fieldByName(currName);", "-", "-            if (field == null) {", "-              // Try concatenating \"val$\" to the beginning of the field in", "-              // case it's a final local variable of the outer class", "-              field = outerRt.fieldByName(\"val$\" + currName);", "-", "-              if (field == null) {", "-                // Enter the loop again with the next outer enclosing class", "-                outerIndex--;", "-                outerThis = outerRt.fieldByName(\"this$\" + outerIndex);", "-              }", "-            }", "-          }", "-        }", "-        else {", "-          // We're in a static context", "-", "-          // If we don't find it in this class, loop through any enclosing", "-          // classes. Do this by loading any outer classes by invoking the", "-          // method on the class loader that loaded this class and passing", "-          // it the class name with the last class removed each time.", "-          String rtClassName = outerRt.name();", "-          int index = rtClassName.lastIndexOf(\"$\");", "-          while ((field == null) && (index != -1)) {", "-            rtClassName = rtClassName.substring(0, index);", "-            List<ReferenceType> l = _vm.classesByName(rtClassName); // JDK 1.5 will eliminate this warning", "-            if (l.isEmpty()) {", "-              // field is null, we will end up setting", "-              // the value to no value", "-              break;", "-            }", "-            outerRt = l.get(0);", "-            field = outerRt.fieldByName(currName);", "-", "-            if (field == null) {", "-              // Enter the loop again with the next outer enclosing class", "-              index = rtClassName.lastIndexOf(\"$\");", "-            }", "-          }", "-        }", "-", "-        // Try to set the value and type of the field.", "-        //  If the field is not static and we are in a static context", "-        //  (outer==null), we have to setNoValue.", "-        if ((field != null) &&", "-            (field.isStatic() || (outer != null))) {", "-          Value v = (field.isStatic()) ?", "-            outerRt.getValue(field) :", "-            outer.getValue(field);", "-          currWatch.setValue(_getValue(v));", "-          try {", "-            currWatch.setType(field.type().name());", "-          }", "-          catch (ClassNotLoadedException cnle) {", "-            List<ReferenceType> classes = _vm.classesByName(field.typeName());  // JDK 1.5 will eliminate this warning", "-            if (!classes.isEmpty()) {", "-              currWatch.setType(classes.get(0).name());", "-            }", "-            else {", "-              currWatch.setTypeNotLoaded();", "-            }", "-          }", "-        }", "-        else {", "-          currWatch.setNoValue();", "-          currWatch.setNoType();", "-        }", "-", "-      }", "-    }", "-    catch (IncompatibleThreadStateException itse) {", "-      _log(\"Exception updating watches.\", itse);", "-    }", "-    catch (InvalidStackFrameException isfe) {", "-      _log(\"Exception updating watches.\", isfe);", "-    }", "-    catch (VMDisconnectedException vmde) {", "-      _log(\"Exception updating watches.\", vmde);", "-      shutdown();", "+    for (DebugWatchData w : _watches) {", "+      String val = _model.getInteractionsModel().getVariableToString(w.getName());", "+      if (val == null) { w.setNoValue(); }", "+      else { w.setValue(val); }", "+      String type = _model.getInteractionsModel().getVariableType(w.getName());", "+      if (type == null) { w.setNoType(); }", "+      else { w.setType(type); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3d6e73becf2611801ebf78605e2fc07", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 76, "signatureBeforeChange": " \tpublic Object visit(FieldDeclaration node)", "signatureAfterChange": "     public Void visit(FieldDeclaration node)", "diff": ["-\t */", "-\tpublic Object visit(FieldDeclaration node) {", "-\t    FieldInfo fi = classInfo.getField(node);", "-\t    int       af = node.getAccessFlags();", "-\t    String    rt = fi.getType().getName();", "-\t    String    fn = node.getName();", "-", "-\t    if (isInterface) {", "-\t\tif (Modifier.isPrivate(af) || Modifier.isProtected(af)) {", "-\t\t    node.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t     new String[] { fn, classInfo.getName() });", "-\t\t    throw new ExecutionError(\"interface.field.modifier\", node);", "-\t\t}", "-\t\taf |= Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL;", "-\t    }", "-", "-\t    Expression init = node.getInitializer();", "-\t    if (init != null) {", "-\t\tif ((init instanceof Literal) &&", "-\t\t    Modifier.isFinal(af) &&", "-\t\t    Modifier.isStatic(af)) {", "-\t\t    if (init instanceof IntegerLiteral) {", "-\t\t\tInteger val = (Integer)((Literal)init).getValue();", "-\t\t\tif (rt.equals(\"byte\")) {", "-\t\t\t    if (val.intValue() != val.byteValue()) {", "-\t\t\t\tthrow new ExecutionError(\"invalid.constant\", node);", "-\t\t\t    }", "-\t\t\t    classFactory.addConstantIntField", "-\t\t\t\t(af, rt, fn, val);", "-\t\t\t} else if (rt.equals(\"short\")) {", "-\t\t\t    if (val.intValue() != val.shortValue()) {", "-\t\t\t\tthrow new ExecutionError(\"invalid.constant\", node);", "-\t\t\t    }", "-\t\t\t    classFactory.addConstantIntField", "-\t\t\t\t(af, rt, fn, val);", "-\t\t\t} else if (rt.equals(\"int\")) {", "-\t\t\t    classFactory.addConstantIntField", "-\t\t\t\t(af, rt, fn, val);", "-\t\t\t} else if (rt.equals(\"long\")) {", "-\t\t\t    classFactory.addConstantLongField", "-\t\t\t\t(af, rt, fn, new Long(val.longValue()));", "-\t\t\t} else if (rt.equals(\"float\")) {", "-\t\t\t    classFactory.addConstantFloatField", "-\t\t\t\t(af, rt, fn, new Float(val.floatValue()));", "-\t\t\t} else if (rt.equals(\"double\")) {", "-\t\t\t    classFactory.addConstantDoubleField", "-\t\t\t\t(af, rt, fn, new Double(val.doubleValue()));", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"invalid.constant\", node);", "-\t\t\t}", "-\t\t    } else if (init instanceof LongLiteral) {", "-\t\t\tLong val = (Long)((Literal)init).getValue();", "-\t\t\tif (rt.equals(\"long\")) {", "-\t\t\t    classFactory.addConstantLongField", "-\t\t\t\t(af, rt, fn, new Long(val.longValue()));", "-\t\t\t} else if (rt.equals(\"float\")) {", "-\t\t\t    classFactory.addConstantFloatField", "-\t\t\t\t(af, rt, fn, new Float(val.floatValue()));", "-\t\t\t} else if (rt.equals(\"double\")) {", "-\t\t\t    classFactory.addConstantDoubleField", "-\t\t\t\t(af, rt, fn, new Double(val.doubleValue()));", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"invalid.constant\", node);", "-\t\t\t}", "-\t\t    } else if (init instanceof FloatLiteral) {", "-\t\t\tFloat val = (Float)((Literal)init).getValue();", "-\t\t\tif (rt.equals(\"float\")) {", "-\t\t\t    classFactory.addConstantFloatField", "-\t\t\t\t(af, rt, fn, new Float(val.floatValue()));", "-\t\t\t} else if (rt.equals(\"double\")) {", "-\t\t\t    classFactory.addConstantDoubleField", "-\t\t\t\t(af, rt, fn, new Double(val.doubleValue()));", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"invalid.constant\", node);", "-\t\t\t}", "-\t\t    } else if (init instanceof DoubleLiteral) {", "-\t\t\tDouble val = (Double)((Literal)init).getValue();", "-\t\t\tif (rt.equals(\"double\")) {", "-\t\t\t    classFactory.addConstantDoubleField", "-\t\t\t\t(af, rt, fn, new Double(val.doubleValue()));", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"invalid.constant\", node);", "-\t\t\t}", "-\t\t\t", "-\t\t    } else if (init instanceof BooleanLiteral) {", "-\t\t\tBoolean val = (Boolean)((Literal)init).getValue();", "-\t\t\tif (rt.equals(\"boolean\")) {", "-\t\t\t    classFactory.addConstantBooleanField", "-\t\t\t\t(af, rt, fn, val);", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"invalid.constant\", node);", "-\t\t\t}", "-\t\t    } else {", "-\t\t\tString val = (String)((Literal)init).getValue();", "-\t\t\tclassFactory.addConstantStringField(af, rt, fn, val);", "-\t\t    }", "-\t\t} else {", "-\t\t    classFactory.addField(af & ~Modifier.FINAL, rt, fn);", "-", "-\t\t    Expression var = null;", "-\t\t    if (Modifier.isStatic(af)) {", "-\t\t\tReferenceType typ = new ReferenceType(classInfo.getName());", "-\t\t\tvar = new StaticFieldAccess(typ, fn);", "-\t\t    } else {", "-\t\t\tIdentifier t = new Identifier(\"this\");", "-\t\t\tList  l  = new LinkedList();", "-\t\t\tl.add(t);", "-\t\t\tvar = new QualifiedName(l);", "-\t\t\tvar = new ObjectFieldAccess(var, fn);", "-\t\t    }", "-\t\t    Expression exp = new SimpleAssignExpression(var, init);", "-\t\t    if (Modifier.isStatic(af)) {", "-\t\t\taddToClassInitializer(exp);", "-\t\t    } else {", "-\t\t\texp.setProperty(NodeProperties.INSTANCE_INITIALIZER, null);", "-\t\t\taddToInstanceInitializer(exp);", "-\t\t    }", "-\t\t}", "-\t    } else {", "-\t\tclassFactory.addField(af, rt, fn);", "-\t    }", "-\t    return null;", "-\t}", "+     */", "+    public Void visit(FieldDeclaration node) {", "+      FieldInfo fi = classInfo.getField(node);", "+      int       af = node.getAccessFlags();", "+      String    rt = fi.getType().getName();", "+      String    fn = node.getName();", "+      ", "+      if (isInterface) {", "+        if (Modifier.isPrivate(af) || Modifier.isProtected(af)) {", "+          node.setProperty(NodeProperties.ERROR_STRINGS,", "+                           new String[] { fn, classInfo.getName() });", "+          throw new ExecutionError(\"interface.field.modifier\", node);", "+        }", "+        af |= Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL;", "+      }", "+      ", "+      Expression init = node.getInitializer();", "+      if (init != null) {", "+        if ((init instanceof Literal) &&", "+            Modifier.isFinal(af) &&", "+            Modifier.isStatic(af)) {", "+          if (init instanceof IntegerLiteral) {", "+            Integer val = (Integer)((Literal)init).getValue();", "+            if (rt.equals(\"byte\")) {", "+              if (val.intValue() != val.byteValue()) {", "+                throw new ExecutionError(\"invalid.constant\", node);", "+              }", "+              classFactory.addConstantIntField", "+                (af, rt, fn, val);", "+            } else if (rt.equals(\"short\")) {", "+              if (val.intValue() != val.shortValue()) {", "+                throw new ExecutionError(\"invalid.constant\", node);", "+              }", "+              classFactory.addConstantIntField", "+                (af, rt, fn, val);", "+            } else if (rt.equals(\"int\")) {", "+              classFactory.addConstantIntField", "+                (af, rt, fn, val);", "+            } else if (rt.equals(\"long\")) {", "+              classFactory.addConstantLongField", "+                (af, rt, fn, new Long(val.longValue()));", "+            } else if (rt.equals(\"float\")) {", "+              classFactory.addConstantFloatField", "+                (af, rt, fn, new Float(val.floatValue()));", "+            } else if (rt.equals(\"double\")) {", "+              classFactory.addConstantDoubleField", "+                (af, rt, fn, new Double(val.doubleValue()));", "+            } else {", "+              throw new ExecutionError(\"invalid.constant\", node);", "+            }", "+          } else if (init instanceof LongLiteral) {", "+            Long val = (Long)((Literal)init).getValue();", "+            if (rt.equals(\"long\")) {", "+              classFactory.addConstantLongField", "+                (af, rt, fn, new Long(val.longValue()));", "+            } else if (rt.equals(\"float\")) {", "+              classFactory.addConstantFloatField", "+                (af, rt, fn, new Float(val.floatValue()));", "+            } else if (rt.equals(\"double\")) {", "+              classFactory.addConstantDoubleField", "+                (af, rt, fn, new Double(val.doubleValue()));", "+            } else {", "+              throw new ExecutionError(\"invalid.constant\", node);", "+            }", "+          } else if (init instanceof FloatLiteral) {", "+            Float val = (Float)((Literal)init).getValue();", "+            if (rt.equals(\"float\")) {", "+              classFactory.addConstantFloatField", "+                (af, rt, fn, new Float(val.floatValue()));", "+            } else if (rt.equals(\"double\")) {", "+              classFactory.addConstantDoubleField", "+                (af, rt, fn, new Double(val.doubleValue()));", "+            } else {", "+              throw new ExecutionError(\"invalid.constant\", node);", "+            }", "+          } else if (init instanceof DoubleLiteral) {", "+            Double val = (Double)((Literal)init).getValue();", "+            if (rt.equals(\"double\")) {", "+              classFactory.addConstantDoubleField", "+                (af, rt, fn, new Double(val.doubleValue()));", "+            } else {", "+              throw new ExecutionError(\"invalid.constant\", node);", "+            }", "+            ", "+          } else if (init instanceof BooleanLiteral) {", "+            Boolean val = (Boolean)((Literal)init).getValue();", "+            if (rt.equals(\"boolean\")) {", "+              classFactory.addConstantBooleanField", "+                (af, rt, fn, val);", "+            } else {", "+              throw new ExecutionError(\"invalid.constant\", node);", "+            }", "+          } else {", "+            String val = (String)((Literal)init).getValue();", "+            classFactory.addConstantStringField(af, rt, fn, val);", "+          }", "+        } else {", "+          classFactory.addField(af & ~Modifier.FINAL, rt, fn);", "+          ", "+          Expression var = null;", "+          if (Modifier.isStatic(af)) {", "+            ReferenceType typ = new ReferenceType(classInfo.getName());", "+            var = new StaticFieldAccess(typ, fn);", "+          } else {", "+            Identifier t = new Identifier(\"this\");", "+            List<IdentifierToken> l = new LinkedList<IdentifierToken>();", "+            l.add(t);", "+            var = new QualifiedName(l);", "+            var = new ObjectFieldAccess(var, fn);", "+          }", "+          Expression exp = new SimpleAssignExpression(var, init);", "+          if (Modifier.isStatic(af)) {", "+            addToClassInitializer(exp);", "+          } else {", "+            exp.setProperty(NodeProperties.INSTANCE_INITIALIZER, null);", "+            addToInstanceInitializer(exp);", "+          }", "+        }", "+      } else {", "+        classFactory.addField(af, rt, fn);", "+      }", "+      return null;", "+    }"]}], "num": 24028}