{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "71cfa14af60c4ee003ba5ecedea0dec9", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3b5e79eabb541cd166920592c6153374", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 78, "methodNumberAfterChange": 82, "signatureBeforeChange": "   @Override public Type visit(ConditionalExpression node)", "signatureAfterChange": "     @Override public Type visit(ConditionalExpression node)", "diff": ["-   */", "-  @Override public Type visit(ConditionalExpression node) {", "-    node.getConditionExpression().acceptVisitor(this);", "-    node.getIfTrueExpression().acceptVisitor(this);", "-    node.getIfFalseExpression().acceptVisitor(this);", "-", "-    try {", "-      Expression cond = ts.makePrimitive(node.getConditionExpression());", "-      if (!(getType(cond) instanceof BooleanType)) {", "+     */", "+    @Override public Type visit(ConditionalExpression node) {", "+      check(node.getConditionExpression(), TypeSystem.BOOLEAN);", "+      check(node.getIfTrueExpression(), expected);", "+      check(node.getIfFalseExpression(), expected);", "+      ", "+      try {", "+        Expression cond = ts.makePrimitive(node.getConditionExpression());", "+        if (!(getType(cond) instanceof BooleanType)) {", "+          throw new ExecutionError(\"condition.type\", node);", "+        }", "+        node.setConditionExpression(cond);", "+      }", "+      catch (UnsupportedConversionException e) {", "-      node.setConditionExpression(cond);", "-    }", "-    catch (UnsupportedConversionException e) {", "-      throw new ExecutionError(\"condition.type\", node);", "-    }", "-    ", "-    try {", "-      Pair<Expression, Expression> joined = ts.join(node.getIfTrueExpression(),", "-                                                    node.getIfFalseExpression());", "-      node.setIfTrueExpression(joined.first());", "-      node.setIfFalseExpression(joined.second());", "-      return setType(node, ts.capture(getType(joined.first())));", "-    }", "-    catch (UnsupportedConversionException e) {", "-      throw new ExecutionError(\"conditional.type\", node);", "-    }", "-  }", "+      try {", "+        Pair<Expression, Expression> joined = ts.join(node.getIfTrueExpression(),", "+                                                      node.getIfFalseExpression());", "+        node.setIfTrueExpression(joined.first());", "+        node.setIfFalseExpression(joined.second());", "+        return setType(node, ts.capture(getType(joined.first())));", "+      }", "+      catch (UnsupportedConversionException e) {", "+        throw new ExecutionError(\"conditional.type\", node);", "+      }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa06c95c934e9ac0a08bab10be69f306", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 42, "signatureBeforeChange": "   @Override public Type visit(AddExpression node)", "signatureAfterChange": "     @Override public Type visit(AddExpression node)", "diff": ["-   */", "-  @Override public Type visit(AddExpression node) {", "-    Type leftT = node.getLeftExpression().acceptVisitor(this);", "-    Type rightT = node.getRightExpression().acceptVisitor(this);", "-    if (ts.isSubtype(leftT, TypeSystem.STRING) || ts.isSubtype(rightT, TypeSystem.STRING)) {", "-        Expression left = ts.makeReference(node.getLeftExpression());", "-        Expression right = ts.makeReference(node.getRightExpression());", "-        node.setLeftExpression(left);", "-        node.setRightExpression(right);", "-        setOperation(node, ExpressionEvaluator.CONCATENATE);", "-        return setType(node, TypeSystem.STRING);", "-        throw new ExecutionError(\"addition.type\", node);", "-    else {", "+     */", "+    @Override public Type visit(AddExpression node) {", "+      Type leftT = check(node.getLeftExpression());", "+      Type rightT = check(node.getRightExpression());", "+      if (ts.isSubtype(leftT, TypeSystem.STRING) || ts.isSubtype(rightT, TypeSystem.STRING)) {", "+        try {", "+          Expression left = ts.makeReference(node.getLeftExpression());", "+          Expression right = ts.makeReference(node.getRightExpression());", "+          node.setLeftExpression(left);", "+          node.setRightExpression(right);", "+          setOperation(node, ExpressionEvaluator.CONCATENATE);", "+          return setType(node, TypeSystem.STRING);", "+        }", "+        catch (UnsupportedConversionException e) {", "+          throw new ExecutionError(\"addition.type\", node);", "+        }", "+      }", "+      else {", "+        try {", "+          Expression left = ts.makePrimitive(node.getLeftExpression());", "+          Expression right = ts.makePrimitive(node.getRightExpression());", "+          Pair<Expression, Expression> promoted = ts.binaryPromote(left, right);", "+          node.setLeftExpression(promoted.first());", "+          node.setRightExpression(promoted.second());", "+          setOperation(node, ExpressionEvaluator.ADD);", "+          return setType(node, getType(promoted.first()));", "+        }", "+        catch (UnsupportedConversionException e) {", "+          throw new ExecutionError(\"addition.type\", node);", "+        }", "+      }", "+    }", "-        setOperation(node, ExpressionEvaluator.ADD);", "-        throw new ExecutionError(\"addition.type\", node);", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "caade94c142d326176c796372fbc97ab", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 43, "signatureBeforeChange": "   @Override public Type visit(AddAssignExpression node)", "signatureAfterChange": "     @Override public Type visit(AddAssignExpression node)", "diff": ["+     */", "+    @Override public Type visit(AddAssignExpression node) { ", "+      Type leftT = check(node.getLeftExpression());", "+      Type rightT = check(node.getRightExpression());", "+      if (ts.isEqual(leftT, TypeSystem.STRING)) {", "+        try {", "+          Expression right = ts.makeReference(node.getRightExpression());", "+          node.setRightExpression(right);", "+          setOperation(node, ExpressionEvaluator.CONCATENATE);", "+        }", "+        catch (UnsupportedConversionException e) {", "+          throw new ExecutionError(\"addition.type\", node);", "+        }", "+      }", "+      else if (ts.isSubtype(leftT, TypeSystem.STRING) || ts.isSubtype(rightT, TypeSystem.STRING)) {", "+        throw new ExecutionError(\"addition.type\", node);", "+      }", "+      else {", "+        try {", "+          Expression left = ts.makePrimitive(node.getLeftExpression());", "+          Expression right = ts.makePrimitive(node.getRightExpression());", "+          Pair<Expression, Expression> promoted = ts.binaryPromote(left, right);", "+          setLeftExpression(node, promoted.first()); // not to be confused with node.setLeftExpression(...)", "+          node.setRightExpression(promoted.second());", "+          setOperation(node, ExpressionEvaluator.ADD);", "+        }", "+        catch (UnsupportedConversionException e) {", "+          throw new ExecutionError(\"addition.type\", node);", "+        }", "+      }", "+      ", "+      if (!hasVariableType(node.getLeftExpression())) {", "+        throw new ExecutionError(\"addition.type\", node);", "+      }", "+      ", "+      return setType(node, leftT);", "+    }", "-   */", "-  @Override public Type visit(AddAssignExpression node) { ", "-    Type leftT = node.getLeftExpression().acceptVisitor(this);", "-    Type rightT = node.getRightExpression().acceptVisitor(this);", "-    if (ts.isEqual(leftT, TypeSystem.STRING)) {", "-      try {", "-        Expression right = ts.makeReference(node.getRightExpression());", "-        node.setRightExpression(right);", "-        setOperation(node, ExpressionEvaluator.CONCATENATE);", "-      }", "-      catch (UnsupportedConversionException e) {", "-        throw new ExecutionError(\"addition.type\", node);", "-      }", "-    }", "-    else if (ts.isSubtype(leftT, TypeSystem.STRING) || ts.isSubtype(rightT, TypeSystem.STRING)) {", "-      throw new ExecutionError(\"addition.type\", node);", "-    }", "-    else {", "-        setOperation(node, ExpressionEvaluator.ADD);", "-        throw new ExecutionError(\"addition.type\", node);", "-      }", "-    }", "-", "-    if (!hasVariableType(node.getLeftExpression())) {", "-      throw new ExecutionError(\"addition.type\", node);", "-    }", "-    ", "-    return setType(node, leftT);", "-  }"]}], "num": 27622}