{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9123c4c152ace7ac009957488c7c434c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a5a12c05684a74a05cdda4d97e600fc", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/FindReplaceMachine.java", "commitBeforeChange": "db8f0cb26e31432f350747ff5cceb39c84bddf2e", "commitAfterChange": "09ee5df535fa7711165b559136b85b4d08379671", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 33, "signatureBeforeChange": "   private FindResult _findNextInAllDocs(AbstractDocumentInterface docToSearch, int start, int end) throws BadLocationException", "signatureAfterChange": "   private FindResult      _findNextInDocSegment(OpenDefinitionsDocument doc, int start, int len, boolean wrapped, boolean allWrapped)", "diff": ["+  private FindResult ", "+    _findNextInDocSegment(OpenDefinitionsDocument doc, int start, int len, boolean wrapped, boolean allWrapped) {  ", "+//    Utilities.show(\"called _findNextInDocSegment(\" + doc.getText() + \",\\n\" + start + \", \" + len + \", \" + wrapped + \" ...)\");", "+    ", "+    if (len == 0 || doc.getLength() == 0) return new FindResult(doc, -1, wrapped, allWrapped);", "+    ", "+    int docLen;     // The length of the segment to be searched", "+    String text;    // The text segment to be searched", "+    ", "+    String findWord = _findWord;       // copy of word being searched (so it can converted to lower case if necessary", "+    int wordLen = findWord.length();   // length of search key (word being searched fo  ", "+    ", "+    doc.readLock();", "+    try { ", "+      docLen = doc.getLength();", "+//      if (wrapped && allWrapped) Utilities.show(start +\", \" + len + \", \" + docLen + \", doc = '\" + doc.getText() + \"'\");", "+      text = doc.getText(start, len);", "+      ", "+      if (! _matchCase) {", "+        text = text.toLowerCase();", "+        findWord = findWord.toLowerCase();  // does not affect wordLen", "+      }", "+      ", "+//       if (wrapped && allWrapped) Utilities.show(\"Executing loop with findWord = \" + findWord + \"; text = \" + text + \"; len = \" + len);     ", "+      ", "+      // loop to find first valid (not ignored) occurrence of findWord", "+      // loop carried variables are text, len, start; ", "+      // loop invariant variables are _doc, docLen, _isForward, findWord, wordLen.", "+      // On forward search, (start + len) is invariant; on backward search start is invariant.", "+      // loop exits by returning match (as FindResult) or by falling through with no match.", "+      // if match is returned, _current has been updated to match location", "+      while (len >= wordLen) {", "+        // Find next match in text", "+        int foundOffset = _isForward ? text.indexOf(findWord) : text.lastIndexOf(findWord);", "+        if (foundOffset < 0) break;  // no valid match in this document", "+        ", "+        int foundLocation = start + foundOffset;", "+        int matchLocation;", "+        ", "+        if (_isForward) {", "+          int adjustedOffset = foundOffset + wordLen;", "+          start += adjustedOffset;                       // start is moved to match", "+          text = text.substring(adjustedOffset, len);    // len is length of text before update", "+          len = len - adjustedOffset;                    // len is updated to length of text after update", "+          matchLocation = start;                         // matchLocation is index in _doc of right edge of match", "+//            _current = docToSearch.createPosition(start);          // put caret at beginning of found word", "+        }", "+        else {", "+          len = foundOffset;                             // start is left invariant; len is moved to match", "+          matchLocation = start + foundOffset;           // matchLocation is index in _doc of left edge of match", "+          text = text.substring(0, len);                 // len is length of text after update", "+//            _current = docToSearch.createPosition(foundLocation);  // put caret at end of found word", "+        doc.setCurrentLocation(foundLocation);           // _shouldIgnore below uses reduced model", "+//        Utilities.show(\"Finished iteration with text = \" + text + \"; len = \" + len);", "+        if (_shouldIgnore(foundLocation, doc)) continue;", "+        _current = doc.createPosition(matchLocation);   ", "+//        System.err.println(\"Returning result = \" + new FindResult(doc, matchLocation, wrapped, allWrapped));", "+        return new FindResult(doc, matchLocation, wrapped, allWrapped);  // return valid match", "+    finally { doc.readUnlock(); }", "+    ", "+    // loop fell through; search failed in doc segment", "+    return new FindResult(doc, -1, wrapped, allWrapped);", "-  private FindResult _findNextInAllDocs(AbstractDocumentInterface docToSearch, int start, int end) throws BadLocationException {", "-    boolean stillSearching = true;", "-    while(stillSearching) {", "-      stillSearching = false;", "-      _checkAllDocsWrapped = true;    ", "-      while (docToSearch != _doc) {", "-        if (docToSearch == _firstDoc) {", "-          _allDocsWrapped = true;", "-          _checkAllDocsWrapped = false;", "-        }", "-        ", "-        String text;", "-        int docLen;", "-        docToSearch.acquireReadLock();", "-        try { ", "-          docLen = docToSearch.getLength();", "-          text = docToSearch.getText(start, end);", "-        }", "-        finally { docToSearch.releaseReadLock(); }", "-        String findWord = _findWord;", "-        if (!_matchCase) {", "-          text = text.toLowerCase();", "-          findWord = findWord.toLowerCase();", "-        }", "-        int foundOffset = !_searchBackwards ? text.indexOf(findWord) : text.lastIndexOf(findWord);", "-        if (foundOffset >= 0) {", "-          int locationToIgnore = start + foundOffset;", "-          _model.getODDForDocument(docToSearch).setCurrentLocation(locationToIgnore);", "-          if (_shouldIgnore(locationToIgnore, docToSearch)) {", "-            foundOffset += start;", "-            if (!_searchBackwards) {", "-              foundOffset += findWord.length();", "-              _current = _doc.createPosition(foundOffset);", "-              start = foundOffset;", "-              end = docLen-foundOffset;", "-              stillSearching = true;", "-              break;", "-              // return _findNextInAllDocs(docToSearch, foundOffset, docLen-foundOffset);", "-            }", "-            _current = _doc.createPosition(foundOffset);", "-            end = foundOffset-start;", "-            stillSearching = true;", "-            break;", "-            // return _findNextInAllDocs(docToSearch, start, foundOffset-start);", "-          }       ", "-          ", "-          // We found it in a different document, put the caret at the end of the found word (if we're going forward).", "-          foundOffset += start;", "-          if (!_searchBackwards) foundOffset += findWord.length();", "-          return new FindResult(docToSearch, foundOffset, false, _allDocsWrapped);", "-        }", "-        docToSearch = !_searchBackwards ? _docIterator.getNextDocument(docToSearch) :", "-          _docIterator.getPrevDocument(docToSearch);", "-        start = 0;", "-        end = docToSearch.getLength();", "-      }", "-    return new FindResult(docToSearch, -1, false, _allDocsWrapped);", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b34b4859b7e99c13fa5529defde68c3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/FindReplaceMachine.java", "commitBeforeChange": "db8f0cb26e31432f350747ff5cceb39c84bddf2e", "commitAfterChange": "09ee5df535fa7711165b559136b85b4d08379671", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": "   private int _findWrapped(int start, int end)", "signatureAfterChange": "     private FindResult _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)", "diff": ["+   */  ", "+  private FindResult _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped) {", "+    int newLen, newStart;", "+    ", "+    assert (_isForward && start + len == doc.getLength()) || (! _isForward && start == 0);", "+    ", "+//    System.err.println(\"_findWrapped(\" + doc + \", \" + start + \", \" + len + \", \" + allWrapped + \")  docLength = \" +", "+//                       doc.getLength() + \", _isForward = \" + _isForward);", "+", "+    doc.readLock();", "+    try {", "+      if (doc.getLength() == 0) return new FindResult(doc, -1, true, allWrapped);", "+      if (_isForward) {", "+        newLen = start;", "+        newStart = 0;", "+      }", "+      else {", "+        newStart = len;", "+        newLen = doc.getLength() - len;", "+      }", "+//      System.err.println(\"Calling _findNextInDocSegment(\" + doc.getText() + \", newStart = \" + newStart + \", newLen = \" + ", "+//                     newLen + \", allWrapped = \" + allWrapped + \") and _isForward = \" + _isForward);", "+      return _findNextInDocSegment(doc, newStart, newLen, true, allWrapped);", "+    }", "+    finally { doc.readUnlock(); }", "+  } ", "-   */", "-  private int _findWrapped(int start, int end) {", "-    int foundOffset = -1;", "-    try{", "-      boolean stillSearching = true;", "-      while(stillSearching) {", "-        stillSearching = false;", "-        _wrapped = true;", "-        int docLen;", "-        String findSpace;", "-        _doc.acquireReadLock();  ", "-        try { ", "-          docLen = _doc.getLength(); ", "-          if (!_searchBackwards) {", "-            if (end > docLen) end = docLen;", "-          }", "-          ", "-          else {  // searching backwards", "-            if (start < 0){ ", "-              start = 0;", "-              end = docLen;", "-            }", "-          }", "-          findSpace = _doc.getText(start, end);", "-        }", "-        finally { _doc.releaseReadLock(); }", "-        String findWord = _findWord;", "-        ", "-        if (!_matchCase) {", "-          findSpace = findSpace.toLowerCase();", "-          findWord = findWord.toLowerCase();", "-        }", "-        ", "-        foundOffset = !_searchBackwards ? findSpace.indexOf(findWord)", "-          : findSpace.lastIndexOf(findWord);", "-        ", "-        if (foundOffset >= 0) {", "-          int locationToIgnore = start + foundOffset;", "-          _model.getODDForDocument(_doc).setCurrentLocation(locationToIgnore);", "-          if (_shouldIgnore(locationToIgnore, _doc)) {", "-            foundOffset += start;", "-            if (!_searchBackwards) {", "-              foundOffset += findWord.length();", "-              start = foundOffset;", "-              end = docLen-foundOffset;", "-              stillSearching = true;", "-              continue;", "-              // return _findWrapped(foundOffset, docLen-foundOffset);", "-            }", "-            end = foundOffset-start;", "-            stillSearching = true;", "-            continue;", "-            // return _findWrapped(start, foundOffset-start);", "-          }       ", "-          // otherwise we have found it", "-//        _found = true;", "-          foundOffset += start;", "-          if (!_searchBackwards) foundOffset += findWord.length();", "-          _current = _doc.createPosition(foundOffset);  // thread-safe operation on _doc", "-        }", "-    return foundOffset;"]}], "num": 14185}