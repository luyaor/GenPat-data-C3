{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d6347c5fe789ee42bb31e491c26a661f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa638f562ad792ca9d3e4aaad4ea7254", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractDJDocument.java", "commitBeforeChange": "b552f36a1d45e65c0515c4425e1954dc75014315", "commitAfterChange": "4f7118cfc181d6dc991cba376f6e7b8942d8b8fc", "methodNumberBeforeChange": 51, "methodNumberAfterChange": 49, "signatureBeforeChange": "   public int _getIndentOfCurrStmt(final int pos, final char[] delims, final char[] whitespace)", "signatureAfterChange": "   public int _getIndentOfCurrStmt(final int pos, final char[] delims, final char[] whitespace)", "diff": ["-//      synchronized(_reduced) {", "-        // Check cache", "-        int lineStart = _getLineStartPos(pos);  // returns 0 for initial line", "-        ", "-        final Query key = new Query.IndentOfCurrStmt(lineStart, delims, whitespace);", "-        final Integer cached = (Integer) _checkCache(key);", "-        if (cached != null) return cached;  // relying on auto-unboxing", "-        ", "-        // Find the previous delimiter (typically an enclosing brace or closing symbol) skipping over balanced braces", "-        // that are not delims", "-        boolean reachedStart = false;", "-        int prevDelim = _findPrevDelimiter(lineStart, delims, /* skipBracePhrases */ true);", "-        ", "-        if (prevDelim == -1) reachedStart = true; // no delimiter found", "-        ", "-        // From the previous delimiter or start, find the next non-whitespace character (why?)", "-        int nextNonWSChar;", "-        if (reachedStart) nextNonWSChar = _getFirstNonWSCharPos(0);", "-        else nextNonWSChar = _getFirstNonWSCharPos(prevDelim + 1, whitespace, false);", "-        ", "-        // If the end of the document was reached", "-        if (nextNonWSChar == -1) nextNonWSChar = getLength();", "-        ", "-        // The following statement looks right; otherwise, the indenting of the current line depends on how it is indented", "+      // Check cache", "+      int lineStart = _getLineStartPos(pos);  // returns 0 for initial line", "+      ", "+      final Query key = new Query.IndentOfCurrStmt(lineStart, delims, whitespace);", "+      final Integer cached = (Integer) _checkCache(key);", "+      if (cached != null) return cached;  // relying on auto-unboxing", "+      ", "+      // Find the previous delimiter (typically an enclosing brace or closing symbol) skipping over balanced braces", "+      // that are not delims", "+      boolean reachedStart = false;", "+      int prevDelim = findPrevDelimiter(lineStart, delims, /* skipBracePhrases */ true);", "+      ", "+      if (prevDelim == -1) reachedStart = true; // no delimiter found", "+      ", "+      // From the previous delimiter or start, find the next non-whitespace character (why?)", "+      int nextNonWSChar;", "+      if (reachedStart) nextNonWSChar = getFirstNonWSCharPos(0);", "+      else nextNonWSChar = getFirstNonWSCharPos(prevDelim + 1, whitespace, false);", "+      ", "+      // If the end of the document was reached", "+      if (nextNonWSChar == -1) nextNonWSChar = getLength();", "+      ", "+      // The following statement looks right; otherwise, the indenting of the current line depends on how it is indented", "-        ", "-        // Get the start of the line of the non-ws char", "-        int newLineStart = _getLineStartPos(nextNonWSChar);", "-        ", "-        // Get the position of the first non-ws character on this line (or end of line if no such char", "-        int firstNonWS = _getLineFirstCharPos(newLineStart);", "-        int wSPrefix = firstNonWS - newLineStart;", "-        _storeInCache(key, wSPrefix, firstNonWS);  // relying on autoboxing", "-        return wSPrefix;", "-//      }", "+      ", "+      // Get the start of the line of the non-ws char", "+      int newLineStart = _getLineStartPos(nextNonWSChar);", "+      ", "+      // Get the position of the first non-ws character on this line (or end of line if no such char", "+      int firstNonWS = _getLineFirstCharPos(newLineStart);", "+      int wSPrefix = firstNonWS - newLineStart;", "+      _storeInCache(key, wSPrefix, firstNonWS);  // relying on autoboxing", "+      return wSPrefix;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cdaf8e8b3441e22ead4678eb6de4855f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractDJDocument.java", "commitBeforeChange": "a8db062e8dfd667df6324c059f7a6725afc99a1b", "commitAfterChange": "35da9b77b7d75aca3d6277e27e3ba3dc86f3eaa9", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 45, "signatureBeforeChange": "   public String getIndentOfCurrStmt(int pos, char[] delims, char[] whitespace) throws BadLocationException", "signatureAfterChange": "   public String getIndentOfCurrStmt(int pos, char[] delims, char[] whitespace) throws BadLocationException", "diff": ["-    ", "-    //long start = System.currentTimeMillis();", "-    // Get the start of the current line", "-    int lineStart = getLineStartPos(pos);", "-    ", "-    // Find the previous delimiter that closes a statement", "-    boolean reachedStart = false;", "-    int prevDelimiter = lineStart;", "-    boolean ignoreParens = posInParenPhrase(prevDelimiter);", "-    ", "-    //long mid = System.currentTimeMillis();  // START STAGE 2", "-    do {", "-      prevDelimiter = findPrevDelimiter(prevDelimiter, delims, ignoreParens);", "-      try {", "-        if (prevDelimiter > 0 && prevDelimiter < getLength() && getText(prevDelimiter,1).charAt(0) == '{')", "-          break;", "-      }", "-      catch (BadLocationException e) { throw new UnexpectedException(e); }", "-      ", "-      // Check delimiter found was start of document", "-      if (prevDelimiter == ERROR_INDEX) {", "-        reachedStart = true;", "-        break;", "-      }", "-      ignoreParens = posInParenPhrase(prevDelimiter);", "-    } while (ignoreParens);  ", "-    ", "-    //long mid2 = System.currentTimeMillis();  // START STAGE 3", "-    ", "-    // From the previous delimiter, find the next non-whitespace character", "-    int nextNonWSChar;", "-    if (reachedStart) nextNonWSChar = getFirstNonWSCharPos(DOCSTART);", "-    else", "-      nextNonWSChar = getFirstNonWSCharPos(prevDelimiter+1, whitespace, false);", "-    ", "-    //long mid3 = System.currentTimeMillis();  // START STAGE 4", "-    ", "-    // If the end of the document was reached", "-    if (nextNonWSChar == ERROR_INDEX) nextNonWSChar = getLength();", "-    ", "-    // Get the start of the line of the non-ws char", "-    int lineStartStmt = getLineStartPos(nextNonWSChar);", "-    ", "-    // Get the position of the first non-ws character on this line", "-    int lineFirstNonWS = getLineFirstCharPos(lineStartStmt);", "-    try { lineText = getText(lineStartStmt, lineFirstNonWS - lineStartStmt); }", "-    catch(BadLocationException e) { throw new UnexpectedException(e); }", "+    ", "+    readLock();", "+    try {", "+      synchronized (_reduced) {", "+        // Get the start of the current line", "+        int lineStart = getLineStartPos(pos);", "+        ", "+        // Find the previous delimiter that closes a statement", "+        boolean reachedStart = false;", "+        int prevDelim = lineStart;", "+        boolean ignoreParens = posInParenPhrase(prevDelim);", "+        ", "+        do {", "+          prevDelim = findPrevDelimiter(prevDelim, delims, ignoreParens);", "+          if (prevDelim > 0 && prevDelim < getLength() && getText(prevDelim,1).charAt(0) == '{') break;", "+          if (prevDelim == ERROR_INDEX) { // no delimiter found", "+            reachedStart = true;", "+            break;", "+          }", "+          ignoreParens = posInParenPhrase(prevDelim);", "+        } while (ignoreParens);  ", "+    ", "+        // From the previous delimiter, find the next non-whitespace character", "+        int nextNonWSChar;", "+        if (reachedStart) nextNonWSChar = getFirstNonWSCharPos(DOCSTART);", "+        else nextNonWSChar = getFirstNonWSCharPos(prevDelim+1, whitespace, false);", "+        ", "+        // If the end of the document was reached", "+        if (nextNonWSChar == ERROR_INDEX) nextNonWSChar = getLength();", "+        ", "+        // Get the start of the line of the non-ws char", "+        int lineStartStmt = getLineStartPos(nextNonWSChar);", "+        ", "+        // Get the position of the first non-ws character on this line", "+        int lineFirstNonWS = getLineFirstCharPos(lineStartStmt);", "+        lineText = getText(lineStartStmt, lineFirstNonWS - lineStartStmt); ", "+      }", "+    }", "+    catch(Throwable t) { throw new UnexpectedException(t); }", "+    finally { readUnlock(); }", "-    /*", "-     long end = System.currentTimeMillis();", "-     if (maxKey.equals(key)) {", "-     DrJava.consoleOut().print(\"     getIndent: [\" + (mid-start));", "-     DrJava.consoleOut().print(\"] (\" + (mid2-start));", "-     DrJava.consoleOut().print(\") [\" + (mid3-start));", "-     DrJava.consoleOut().println(\"] total: \" + (end-start) + \"ms\");", "-     }", "-     */"]}], "num": 27460}