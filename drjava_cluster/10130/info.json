{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7e16f98ddbd9d52e5249442fac187a9e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "428497152ffcc5c973f03b1b68303a14", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/newjvm/AbstractMasterJVM.java", "commitBeforeChange": "0126ea99e5c318f1f9907f0c07d77641969ffef5", "commitAfterChange": "fa54651cc7ac0d03884ebcafd7e8520df74651a1", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "   protected final void invokeSlave(String[] jvmArgs, String cp, File workDir) throws IOException, RemoteException", "signatureAfterChange": "   protected final void invokeSlave(String[] jvmArgs, String cp, File workDir) throws IOException, RemoteException", "diff": ["+    _log.log(this + \".invokeSlave(\" + Arrays.toString(jvmArgs) + \", \" + cp + \", \" + workDir + \") called\");", "+    ", "-      if (_startupInProgress) throw new IllegalStateException(\"startup is in progress in invokeSlave\");", "-      if (_slave != null) throw new IllegalStateException(\"slave nonnull in invoke: \" + _slave);", "+      if (_startupInProgress) throw new IllegalStateException(\"startup is in progress in invokeSlave\");      ", "+      if (_slave != null) throw new IllegalStateException(\"slave non-null in invoke: \" + _slave);", "+      ", "+      _stub = null;", "-          synchronized(_exportLock) {", "-            try {", "-              _stub = UnicastRemoteObject.exportObject(AbstractMasterJVM.this);", "-              ", "-              // Debug: check that the IP address is 127.0.0.1", "-              // javax.swing.JOptionPane.showMessageDialog(null, _stub.toString());", "-            }", "-            catch (RemoteException re) {", "-              // javax.swing.JOptionPane.showMessageDialog(null, edu.rice.cs.util.StringOps.getStackTrace(re));", "-              throw new edu.rice.cs.util.UnexpectedException(re);", "-            }", "-            _exportLock.notify();", "+          _log.log(AbstractMasterJVM.this + \" starting creation of RMI stub for AbstractMasterJVM\");", "+          try { _stub = UnicastRemoteObject.exportObject(AbstractMasterJVM.this); }", "+          ", "+          // Debug: check that the IP address is 127.0.0.1", "+          // javax.swing.JOptionPane.showMessageDialog(null, _stub.toString());", "+          ", "+          catch (RemoteException re) {", "+            // javax.swing.JOptionPane.showMessageDialog(null, edu.rice.cs.util.StringOps.getStackTrace(re));", "+            throw new UnexpectedException(re);  // should never happen", "+          synchronized(_exportLock) { _exportLock.notify(); }", "+      ", "+      t.start();", "-        t.start();", "-        try { while (_stub == null) { _exportLock.wait(); } }", "-        catch (InterruptedException ie) { throw new edu.rice.cs.util.UnexpectedException(ie); }", "+        try {", "+          while (_stub == null) { ", "+            _log.log(\"invokeSlave thread in \" + this + \" waiting for creation of AbstractMasterJVM RMI stub to complete\");", "+            _exportLock.wait(); ", "+          } ", "+        }", "+        catch (InterruptedException ie) { throw new UnexpectedException(ie); }  // should never happen", "+      ", "+      _log.log(this + \" completed creation of RMI stub for AbstractMasterJVM\");", "+    ", "+      ostream.close();", "+      ", "+      _log.log(this + \" completed writing RMI stub for AbstractMasterJVM to a file\");", "-      final RemoteClassLoader rClassLoader = new RemoteClassLoader(getClass().getClassLoader());", "+      final RemoteClassLoader _classLoader = new RemoteClassLoader(getClass().getClassLoader());", "+      _classLoaderStub = null;", "-          synchronized(_exportLock) {", "-            try {", "-              _classLoaderStub = UnicastRemoteObject.exportObject(rClassLoader);", "-              ", "-              // Debug: check that the IP address is 127.0.0.1", "-              //javax.swing.JOptionPane.showMessageDialog(null, _stub.toString());", "-            }", "-            catch (RemoteException re) {", "-              //javax.swing.JOptionPane.showMessageDialog(null, edu.rice.cs.util.StringOps.getStackTrace(re));", "-              throw new edu.rice.cs.util.UnexpectedException(re);", "-            }", "-            _exportLock.notify();", "+          _log.log(AbstractMasterJVM.this + \" starting creation of RMI stub for RemoteClassLoader\");", "+          try {  _classLoaderStub = UnicastRemoteObject.exportObject(_classLoader); }", "+          ", "+          // Debug: check that the IP address is 127.0.0.1", "+          //javax.swing.JOptionPane.showMessageDialog(null, _stub.toString());", "+          ", "+          catch (RemoteException re) {", "+            //javax.swing.JOptionPane.showMessageDialog(null, edu.rice.cs.util.StringOps.getStackTrace(re));", "+            throw new UnexpectedException(re);  // should never happen", "+          synchronized(_exportLock) { _exportLock.notify(); }", "+      ", "+      t.start();", "-        t.start();", "-        try { while (_classLoaderStub == null) { _exportLock.wait(); } }", "-        catch (InterruptedException ie) { throw new edu.rice.cs.util.UnexpectedException(ie); }", "+        try { ", "+          while (_classLoaderStub == null) { ", "+            _log.log(\"invokeSlave thread in \" + this + \" waiting for creation of RemoteClassLoader RMI stub to complete\");", "+            _exportLock.wait(); ", "+          } ", "+        }", "+        catch (InterruptedException ie) { throw new UnexpectedException(ie); }  // should never happen", "+      ", "+      _log.log(this + \" completed creation of RMI stub for RemoteClassLoader\");", "+      ostream.close();", "+      _log.log(this + \" completed writing RMI stub for RemoteClassLoader to a file\");", "+        ", "-      /* Create the slave JVM. */      ", "+      /* Create the slave JVM. */  ", "+      _log.log(this + \" is starting a slave JVM\");", "-      // Start a thread to wait for the slave to die.  When it dies, restart it.", "-      Thread thread = new Thread(_waitForQuitThreadName) {", "+      // Start a thread to wait for the slave to die.  When it dies, delegate what to do (restart?) to subclass", "+      Thread restartThread = new Thread(_waitForQuitThreadName) {", "+          _log.log(this + \"has started a Slave monitor thread waiting on process \" + process);", "-            ", "-            synchronized(AbstractMasterJVM.this) {", "+            _log.log(\"Process \" + process + \" died under control of \" + AbstractMasterJVM.this + \" with status \" + status);", "+            synchronized(_masterJVMLock) {", "-                // If we get here, the process died without registering.", "-                //  (This might be the case if something was wrong with the", "-                //   classpath, or if the new JVM couldn't acquire a port", "-                //   for debugging.)", "-                //", "-                // Proper behavior in this case is unclear, so we'll let", "-                //  our subclasses decide.  By default, we print a stack", "-                //  trace and do not proceed, to avoid going into a loop.", "+                _log.log(\"Process \" + process + \" died while starting up\");", "+                /* If we get here, the process died without registering. (This might be the case if something was wrong", "+                 * with the classpath, or if the new JVM couldn't acquire a port for debugging.)  Proper behavior in ", "+                 * this case is unclear, so we'll let our subclasses decide.  By default, we print a stack trace and ", "+                 * do not proceed, to avoid going into a loop. */", "-              UnicastRemoteObject.unexportObject(AbstractMasterJVM.this, true);", "-//              Utilities.showDebug(\"calling handleSlaveQuit(\" + status + \")\");", "+              final boolean masterWithdrawn = UnicastRemoteObject.unexportObject(AbstractMasterJVM.this, true);", "+              final boolean loaderWithdrawn = UnicastRemoteObject.unexportObject(_classLoader, true);", "+              if (! masterWithdrawn || ! loaderWithdrawn) {", "+                _log.log(\"unexport step failed in \" + AbstractMasterJVM.this);", "+                throw new UnexpectedException(\"remote objects exported by Master JVM could not be withdrawn!\");", "+              }", "+              ", "+              _log.log(AbstractMasterJVM.this + \" calling handleSlaveQuit(\" + status + \")\");", "-          catch (NoSuchObjectException e) {", "-            throw new edu.rice.cs.util.UnexpectedException(e);", "-          }", "-          catch (InterruptedException ie) {", "-            throw new edu.rice.cs.util.UnexpectedException(ie);", "-          }", "+          catch (NoSuchObjectException e) { throw new UnexpectedException(e); }", "+          catch (InterruptedException ie) { throw new UnexpectedException(ie); }", "-      thread.start();", "+      _log.log(this + \" is starting a slave monitor thread to detect when the Slave JVM dies\");", "+      restartThread.start();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f75f04a5bfcc15f583134374bedebef0", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 13, "signatureBeforeChange": "     protected Pair<LinkedList<MethodData>, LinkedList<MethodData>>      _getMatchingMethods(String methodName, SymbolData enclosingSD, InstanceData[] arguments, JExpression jexpr,                          boolean isConstructor, SymbolData thisSD)", "signatureAfterChange": "     protected Pair<LinkedList<MethodData>, LinkedList<MethodData>>      _getMatchingMethods(String methodName, SymbolData enclosingSD, InstanceData[] arguments, JExpression jexpr,                          boolean isConstructor, SymbolData thisSD)", "diff": ["+    if (enclosingSD.getName().equals(\"NonEmpty\"))", "+      System.err.println(\"Starting search for method \" + methodName + \" in \" + enclosingSD);", "+//      System.err.println(\"Testing method \" + md.getName());", "+      if (md.getName().equals(\"NonEmpty\")) {", "+        System.err.println(\"*** for NonEmpty(), params length = \" + md.getParams().length + \"; args length = \" + arguments.length);", "+      }", "+        ", "-          matches = matches && _isAssignableFromWithoutAutoboxing(vds[i].getType().getSymbolData(), arguments[i].getSymbolData());", "+          matches = matches && ", "+            _isAssignableFromWithoutAutoboxing(vds[i].getType().getSymbolData(), arguments[i].getSymbolData());", "+          if (enclosingSD.getName().equals(\"NonEmpty\")) {", "+            System.err.println(\"*** Looking for autoboxing match for NonEmpty\");", "+            System.err.println(\"vds = \" + Arrays.toString(vds) + \" arguments = \" + Arrays.toString(arguments));", "+          }", "+            if  (enclosingSD.getName().equals(\"NonEmpty\")) {", "+              SymbolData parmSD = vds[i].getType().getSymbolData();", "+              System.err.println(\"vds[\" + i + \"].getType().getSymbolData() = \" + parmSD);", "+              SymbolData argSD = arguments[i].getSymbolData();", "+              System.err.println(\"arguments[\" + i + \"].getSymbolData() = \" + argSD);", "+              if (argSD.equals(SymbolData.INT_TYPE) && parmSD.equals(symbolTable.get(\"java.lang.Object\")))", "+                assert _isAssignableFrom(parmSD, argSD);", "+            }", "-            if (matches == false) break;", "+            if (matches == false) {", "+              if (enclosingSD.getName().equals(\"NonEmpty\"))", "+                System.err.println(\"No match found for NonEmpty using autoboxing\");", "+              break;", "+            }", "+    if (methodName.equals(\"NonEmpty\")) {", "+      System.err.println(\"***** enclosingSD = \" + enclosingSD + \"; thisSD = \" + thisSD + \"; matching methods: \" + matching);", "+      System.err.println(\"***** matching methods with autoboxing: \" + matchingWithAutoBoxing);", "+    }", "+    "]}], "num": 10130}