{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1b3b513096f35b60c1ce1f45aacb7da8", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "33d258c82e9de26ca565939296a08172", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/TypeChecker.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": "     public Object visit(ObjectMethodCall node)", "signatureAfterChange": "   public Class visit(ObjectMethodCall node)", "diff": ["-     */", "-    public Object visit(ObjectMethodCall node) {", "-        // Check the receiver", "-\tExpression exp = node.getExpression();", "-\tClass      c   = (Class)exp.acceptVisitor(this);", "-\tString     mn  = node.getMethodName();", "-", "-        if (!c.isArray() || (c.isArray() && !mn.equals(\"clone\"))) {", "-            // Do the type checking of the arguments", "-            List args = node.getArguments();", "-            Class[] cargs = Constants.EMPTY_CLASS_ARRAY;", "-            if (args != null) {", "-                cargs = new Class[args.size()];", "-                Iterator it = args.iterator();", "-                int i  = 0;", "-                while (it.hasNext()) {", "-                    cargs[i++] = (Class)((Node)it.next()).acceptVisitor(this);", "-                }", "-            }", "-            Method m = null;", "-            try {", "-                m = context.lookupMethod(exp, mn, cargs);", "-            } catch (NoSuchMethodException e) {", "-\t\tString s = c.getName();", "-\t\tnode.setProperty(NodeProperties.ERROR_STRINGS, new String[] { mn, s });", "-                throw new ExecutionError(\"no.such.method\", node);", "-\t    } catch (MethodModificationError e) {", "-\t\tExpression expr = e.getExpression();", "-\t\texpr.acceptVisitor(this);", "-\t\tnode.setExpression(expr);", "-\t\tm = e.getMethod();", "-\t    }", "-", "-            // Set the node properties", "-            node.setProperty(NodeProperties.METHOD, m);", "-            node.setProperty(NodeProperties.TYPE,   c = m.getReturnType());", "-\t    return c;", "-\t} else {", "-            if (!mn.equals(\"clone\") || node.getArguments() != null) {", "-\t\tString s0 = \"clone\";", "-\t\tString s1 = c.getComponentType().getName() + \" array\";", "-\t\tnode.setProperty(NodeProperties.ERROR_STRINGS, new String[] { s0, s1 });", "-                throw new ExecutionError(\"no.such.method\", node);", "-            }", "-            node.setProperty(NodeProperties.TYPE, c = Object.class);", "-\t    return c;", "-\t}", "-    }", "+   */", "+  public Class visit(ObjectMethodCall node) {", "+    // Check the receiver", "+    Expression exp = node.getExpression();", "+    Class      c   = (Class)exp.acceptVisitor(this);", "+    String     mn  = node.getMethodName();", "+    ", "+    if (!c.isArray() || (c.isArray() && !mn.equals(\"clone\"))) {", "+      // Do the type checking of the arguments", "+      List args = node.getArguments();", "+      Class[] cargs = Constants.EMPTY_CLASS_ARRAY;", "+      if (args != null) {", "+        cargs = new Class[args.size()];", "+        Iterator it = args.iterator();", "+        int i  = 0;", "+          cargs[i++] = (Class)((Node)it.next()).acceptVisitor(this);", "+      }", "+      Method m = null;", "+      try {", "+        m = context.lookupMethod(exp, mn, cargs);", "+      } catch (NoSuchMethodException e) {", "+        String s = c.getName();", "+        node.setProperty(NodeProperties.ERROR_STRINGS, new String[] { mn, s });", "+        throw new ExecutionError(\"no.such.method\", node);", "+      } catch (MethodModificationError e) {", "+        Expression expr = e.getExpression();", "+        expr.acceptVisitor(this);", "+        node.setExpression(expr);", "+        m = e.getMethod();", "+      }", "+      ", "+      // Set the node properties", "+      node.setProperty(NodeProperties.METHOD, m);", "+      node.setProperty(NodeProperties.TYPE,   c = m.getReturnType());", "+      return c;", "+    } else {", "+      if (!mn.equals(\"clone\") || node.getArguments() != null) {", "+        String s0 = \"clone\";", "+        String s1 = c.getComponentType().getName() + \" array\";", "+        node.setProperty(NodeProperties.ERROR_STRINGS, new String[] { s0, s1 });", "+        throw new ExecutionError(\"no.such.method\", node);", "+      }", "+      node.setProperty(NodeProperties.TYPE, c = Object.class);", "+      return c;", "+    }", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e09b1cac7c1d32d7616e562b409b8759", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/EvaluationVisitor.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "     public Object visit(ObjectMethodCall node)", "signatureAfterChange": "   public Object visit(ObjectMethodCall node)", "diff": ["-     */", "-    public Object visit(ObjectMethodCall node) {", "-\tExpression exp = node.getExpression();", "-", "-        // Evaluate the receiver first", "-        Object obj  = exp.acceptVisitor(this);", "-", "-        if (node.hasProperty(NodeProperties.METHOD)) {", "-            Method   m    = (Method)node.getProperty(NodeProperties.METHOD);", "-            Class[]  typs = m.getParameterTypes();", "-", "-            // Relax the protection for members?", "-            if (context.getAccessible()) {", "-                m.setAccessible(true);", "-            }", "-", "-            List     larg = node.getArguments();", "-            Object[] args = Constants.EMPTY_OBJECT_ARRAY;", "-", "-            // Fill the arguments", "-            if (larg != null) {", "-                args = new Object[larg.size()];", "-                Iterator it = larg.iterator();", "-                int      i  = 0;", "-                while (it.hasNext()) {", "-                    Object p  = ((Expression)it.next()).acceptVisitor(this);", "-                    args[i] = performCast(typs[i], p);", "-                    i++;", "-                }", "-            }", "-            // Invoke the method", "-            try {", "-                return m.invoke(obj, args);", "-            } catch (InvocationTargetException e) {", "-                if (e.getTargetException() instanceof Error) {", "-                    throw (Error)e.getTargetException();", "-                } else if (e.getTargetException() instanceof RuntimeException) {", "-                    throw (RuntimeException)e.getTargetException();", "-                }", "-                throw new ThrownException(e.getTargetException(), node);", "-            } catch (Exception e) {", "-                throw new CatchedExceptionError(e, node);", "-            }", "-        } else {", "-            // If the 'method' property is not set, the object must be", "-            // an array and the called method must be 'clone'.", "-            // Since the 'clone' method of an array is not a normal", "-            // method, the only way to invoke it is to simulate its", "-            // behaviour.", "-\t    Class c = NodeProperties.getType(exp);", "-            int len = Array.getLength(obj);", "-            Object result = Array.newInstance(c.getComponentType(), len);", "-            for (int i = 0; i < len; i++) {", "-                Array.set(result, i, Array.get(obj, i));", "-            }", "-            return result;", "-        }", "-    }", "+   */", "+  public Object visit(ObjectMethodCall node) {", "+    Expression exp = node.getExpression();", "+    ", "+    // Evaluate the receiver first", "+    Object obj  = exp.acceptVisitor(this);", "+    ", "+    if (node.hasProperty(NodeProperties.METHOD)) {", "+      Method   m    = (Method)node.getProperty(NodeProperties.METHOD);", "+      Class[]  typs = m.getParameterTypes();", "+      ", "+      // Relax the protection for members?", "+      if (context.getAccessible()) {", "+        m.setAccessible(true);", "+      }", "+      ", "+      List<Expression> larg = node.getArguments();", "+      Object[] args = Constants.EMPTY_OBJECT_ARRAY;", "+      ", "+      // Fill the arguments", "+      if (larg != null) {", "+        args = new Object[larg.size()];", "+        Iterator<Expression> it = larg.iterator();", "+        int      i  = 0;", "+        while (it.hasNext()) {", "+          Object p  = ((Expression)it.next()).acceptVisitor(this);", "+          args[i] = performCast(typs[i], p);", "+          i++;", "+        }", "+      }", "+      // Invoke the method", "+      try {", "+        return m.invoke(obj, args);", "+      } catch (InvocationTargetException e) {", "+        if (e.getTargetException() instanceof Error) {", "+          throw (Error)e.getTargetException();", "+        } else if (e.getTargetException() instanceof RuntimeException) {", "+          throw (RuntimeException)e.getTargetException();", "+        }", "+        throw new ThrownException(e.getTargetException(), node);", "+      } catch (Exception e) {", "+        throw new CatchedExceptionError(e, node);", "+      }", "+    } else {", "+      // If the 'method' property is not set, the object must be", "+      // an array and the called method must be 'clone'.", "+      // Since the 'clone' method of an array is not a normal", "+      // method, the only way to invoke it is to simulate its", "+      // behaviour.", "+      Class c = NodeProperties.getType(exp);", "+      int len = Array.getLength(obj);", "+      Object result = Array.newInstance(c.getComponentType(), len);", "+      for (int i = 0; i < len; i++) {", "+        Array.set(result, i, Array.get(obj, i));", "+      }", "+      return result;", "+    }", "+  }"]}], "num": 6846}