{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d9fe91634dede6476691e12a6b163544", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "917a4604337d5db28c01f9f0d3c7dd7e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocumentTest.java", "commitBeforeChange": "54ea28bb82d3e1f546423de8d56e416e257bade5", "commitAfterChange": "d11247645bb07934951554afdf566907fa77ed82", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 57, "signatureBeforeChange": "   public void testExactClassName() throws BadLocationException, ClassNameNotFoundException", "signatureAfterChange": "   public void testExactClassName() throws BadLocationException, ClassNameNotFoundException", "diff": ["-    ", "-    //", "-//    assertEquals(\"class name at \"+substr+\" exp=`\"+exp1+\"`, act=`\"+act1+\"`\", exp1, act1);", "-//    assertEquals(\"class name at \"+substr+\" exp=`\"+exp2+\"`, act=`\"+act2+\"`\", exp2, act2);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp1+\"`, act=`\"+act1+\"`\", exp1, act1);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp2+\"`, act=`\"+act2+\"`\", exp2, act2);", "-//    assertEquals(\"class name at \"+substr+\" exp=`\"+exp1+\"`, act=`\"+act1+\"`\", exp1, act1);", "-//    assertEquals(\"class name at \"+substr+\" exp=`\"+exp2+\"`, act=`\"+act2+\"`\", exp2, act2);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp1+\"`, act=`\"+act1+\"`\", exp1, act1);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp2+\"`, act=`\"+act2+\"`\", exp2, act2);", "+", "+    substr = \"/*Test$Outer$Middle$1*/\";", "+    exp1   = \"Temp.Test$Outer$Middle$1\";", "+    exp2   = \"1\";", "+    act1   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), true);", "+    act2   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), false);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp1+\"`, act=`\"+act1+\"`\", exp1, act1);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp2+\"`, act=`\"+act2+\"`\", exp2, act2);", "+", "+    substr = \"\\\"Test$Outer$Middle$1\\\"\";", "+    exp1   = \"Temp.Test$Outer$Middle$1\";", "+    exp2   = \"1\";", "+    act1   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), true);", "+    act2   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), false);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp1+\"`, act=`\"+act1+\"`\", exp1, act1);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp2+\"`, act=`\"+act2+\"`\", exp2, act2);", "+", "+    substr = \"/*Test$9*/\";", "+    exp1   = \"Temp.Test$9\";", "+    exp2   = \"9\";", "+    act1   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), true);", "+    act2   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), false);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp1+\"`, act=`\"+act1+\"`\", exp1, act1);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp2+\"`, act=`\"+act2+\"`\", exp2, act2);", "+", "+    substr = \"\\\"Test$9\\\"\";", "+    exp1   = \"Temp.Test$9\";", "+    exp2   = \"9\";", "+    act1   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), true);", "+    act2   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), false);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp1+\"`, act=`\"+act1+\"`\", exp1, act1);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp2+\"`, act=`\"+act2+\"`\", exp2, act2);", "+", "+    substr = \"/*Test$10*/\";", "+    exp1   = \"Temp.Test$10\";", "+    exp2   = \"10\";", "+    act1   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), true);", "+    act2   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), false);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp1+\"`, act=`\"+act1+\"`\", exp1, act1);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp2+\"`, act=`\"+act2+\"`\", exp2, act2);", "+", "+    substr = \"\\\"Test$10\\\"\";", "+    exp1   = \"Temp.Test$10\";", "+    exp2   = \"10\";", "+    act1   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), true);", "+    act2   = _defModel.getEnclosingClassName(NESTED_CLASSES_TEXT.indexOf(substr), false);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp1+\"`, act=`\"+act1+\"`\", exp1, act1);", "+    assertEquals(\"class name at \"+substr+\" exp=`\"+exp2+\"`, act=`\"+act2+\"`\", exp2, act2);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c356b10290fef82689db075f619d2e21", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/EvaluationVisitor.java", "commitBeforeChange": "7f334b2431ad2a57c508d4ce8fe5d18ce3fccebf", "commitAfterChange": "43a2124ad4386a02628eedfc537948ebb05ea232", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "   public Object visit(ForEachStatement node)", "signatureAfterChange": "   public Object visit(ForEachStatement node)", "diff": ["-    /* to be filled in shortly */", "+    Set vars = (Set)node.getProperty(NodeProperties.VARIABLES);", "+      context.enterScope(vars);", "+        ", "+    FormalParameter formalparam = node.getParameter();", "+    Expression collection = node.getCollection();", "+    Class collTypeClass = NodeProperties.getType(collection);", "+    Node body = node.getBody();", "+    ", "+    /*examples*/", "+    /*", "+     * Collection<String> c = ... ;", "+     * for(String s: c){", "+     *   ...", "+     * }", "+     * translates to:", "+     * for(Iterator<E> #i = Expression.iterator(); #i.hasNext(); ){", "+     *    FormalParameter = #i.next();", "+     *    statement...", "+     * }", "+     * Collection c = ... ;", "+     * for(Object o: c){", "+     *   String s = (String) o;", "+     *   ...", "+     * }", "+     * translates to:", "+     * for(Iterator #i = Expression.iterator(); #i.hasNext(); ){", "+     *    FormalParameter = #i.next();", "+     *    statement...", "+     * }", "+     * ", "+     * int sum(int[] a){", "+     *    int sum = 0;", "+     *    for(int i:a){", "+     *      sum+=i;", "+     *    return sum", "+     * }", "+     * translates to:", "+     * for(int #i=0; #i<a.length; #i++){", "+     *   FormalParameter=a[#i];", "+     *   statement...", "+     * }", "+     * ============================================================================", "+     */", "+    Method m;", "+    Class c;", "+    Expression exp;", "+    /************************************************************************************/", "+    /**  create an initialization  ******************************************************/", "+    /************************************************************************************/", "+", "+    VariableDeclaration init;", "+    if(collTypeClass.isArray()){", "+      exp = new IntegerLiteral(\"0\");", "+", "+      exp.setProperty(NodeProperties.TYPE, int.class);", "+      ", "+      init = new VariableDeclaration(false,", "+                                     new IntType(),", "+                                     node.getVars().get(0),", "+                                     exp);", "+      ", "+      c = NodeProperties.getType(exp);", "+      init.setProperty(NodeProperties.TYPE, c);", "+      init.getType().setProperty(NodeProperties.TYPE, c);", "+    }else{", "+      exp = new ObjectMethodCall(node.getCollection(), \"iterator\", null,", "+                                                  \"\", 0, 0, 0, 0);", "+      /* these next fields refer to fileame and row/col of source", "+       * but there isn't any source, b/c i'm making it... */", "+      ", "+      /* set properties of exp */", "+      m = null;", "+      try {", "+        m = context.lookupMethod(((ObjectMethodCall)exp).getExpression(), \"iterator\", Constants.EMPTY_CLASS_ARRAY);", "+      }catch(NoSuchMethodException e){", "+        /* this is very bad */", "+        /* should never happen, b/c everything has typechecked etc and been ok'd */", "+      }catch(MethodModificationError e){", "+        /* ths is very bad */", "+        /* should never happen, b/c everything has typechecked etc and been ok'd */", "+      } ", "+      exp.setProperty(NodeProperties.METHOD, m);", "+      exp.setProperty(NodeProperties.TYPE,   m.getReturnType());", "+      ", "+      /* done setting properties */", "+      IdentifierToken javaId = new Identifier(\"java\");", "+      IdentifierToken utilId = new Identifier(\"util\");", "+      IdentifierToken iteratorId = new Identifier(\"Iterator\");", "+      List<IdentifierToken> ids = new LinkedList<IdentifierToken>();", "+      ids.add(javaId); ids.add(utilId); ids.add(iteratorId);", "+      ", "+      ", "+      ", "+      List<List<? extends koala.dynamicjava.tree.Type>> typeArgs = new LinkedList<List<? extends koala.dynamicjava.tree.Type>>();", "+      List<koala.dynamicjava.tree.Type> arg1 = new LinkedList<koala.dynamicjava.tree.Type>();", "+      arg1.add(formalparam.getType());", "+      typeArgs.add(arg1);", "+      init = new VariableDeclaration(false,", "+                                     new GenericReferenceType(ids,typeArgs),", "+                                     node.getVars().get(0),", "+                                     exp);", "+      ", "+      c = NodeProperties.getType(exp);", "+      init.setProperty(NodeProperties.TYPE, c);", "+      init.getType().setProperty(NodeProperties.TYPE, c);", "+      ", "+    }", "+      ", "+      ", "+    /************************************************************************************/", "+    /**  visit initialization  **********************************************************/", "+    /************************************************************************************/", "+    init.acceptVisitor(this);", "+    //everything is initialzized", "+    ", "+", "+    ", "+    ", "+    ", "+    ", "+    ", "+    ", "+    /************************************************************************************/", "+    /**  create a condition  ************************************************************/", "+    /************************************************************************************/", "+    Node condition;", "+    if(collTypeClass.isArray()){", "+      // make lhs", "+      IdentifierToken newforcounter = new Identifier(node.getVars().get(0));", "+      List<IdentifierToken> listForQualifiedName = new LinkedList<IdentifierToken>();", "+      listForQualifiedName.add(newforcounter);", "+      QualifiedName lhs = new QualifiedName(listForQualifiedName);", "+      ", "+      ", "+      ", "+      // make rhs", "+      LinkedList<Expression> argsToGetLength = new LinkedList<Expression>();", "+      argsToGetLength.add(collection);", "+", "+      /*", "+      newforcounter = new Identifier(\"Array\");", "+      listForQualifiedName = new LinkedList<IdentifierToken>();", "+      listForQualifiedName.add(newforcounter);", "+      QualifiedName qf = new QualifiedName(listForQualifiedName);", "+      qf.setProperty(NodeProperties.TYPE, Array.class);", "+      ObjectMethodCall rhs = new ObjectMethodCall(qf, \"getLength\", argsToGetLength,", "+                                       \"\", 0, 0, 0, 0);", "+      */", "+", "+      ", "+      /* since we're finding the length of the array, the dimension is always 1 */", "+      ArrayType art = new ArrayType(formalparam.getType(), 1);", "+      ", "+      StaticMethodCall rhs = new StaticMethodCall(art, \"getLength\", argsToGetLength);", "+      ", "+      ", "+      m = null;", "+      try {", "+        Class[] lookupArgs= {Object.class};", "+        m = Array.class.getMethod(\"getLength\", lookupArgs);", "+      }catch(NoSuchMethodException e){", "+        /* this is very bad */", "+        /* should never happen, b/c everything has typechecked etc and been ok'd */", "+      }catch(MethodModificationError e){", "+        /* ths is very bad */", "+        /* should never happen, b/c everything has typechecked etc and been ok'd */", "+      } ", "+      ", "+      rhs.setProperty(NodeProperties.METHOD, m);", "+      rhs.setProperty(NodeProperties.TYPE,   m.getReturnType());", "+      ", "+      ", "+      ", "+      condition = new LessExpression(lhs, rhs);", "+      condition.setProperty(NodeProperties.TYPE,   new BooleanType());", "+      ", "+      /* 4-17-04 */", "+      /* maybe i need to set the type of hte condition node? */", "+      ", "+      ", "+      ", "+    }else{", "+      IdentifierToken newforcounter = new Identifier(node.getVars().get(0));", "+      List<IdentifierToken> listForQualifiedName = new LinkedList<IdentifierToken>();", "+      listForQualifiedName.add(newforcounter);", "+      QualifiedName qf = new QualifiedName(listForQualifiedName);", "+      condition = new ObjectMethodCall(qf, \"hasNext\", null,", "+                                       \"\", 0, 0, 0, 0);", "+      /* these next fields refer to fileame and row/col of source", "+       * but there isn't any source, b/c i'm making it... */", "+      /* set properties of condition */", "+      Method m2 = null;", "+      try {", "+        m2 = context.lookupMethod(exp, \"hasNext\", Constants.EMPTY_CLASS_ARRAY);", "+      }catch(NoSuchMethodException e){", "+        /* this is very bad */", "+        /* should never happen, b/c everything has typechecked etc and been ok'd */", "+      }catch(MethodModificationError e){", "+        /* ths is very bad */", "+        /* should never happen, b/c everything has typechecked etc and been ok'd */", "+      }", "+      condition.setProperty(NodeProperties.METHOD, m2);", "+      condition.setProperty(NodeProperties.TYPE,   m2.getReturnType());", "+      /* done setting properties */", "+    }", "+", "+    ", "+    ", "+    /************************************************************************************/", "+    /**  create an update statement  ****************************************************/", "+    /************************************************************************************/", "+    Node statement1;", "+    Expression assignment = null;", "+    if(collTypeClass.isArray()){", "+      Identifier counterName = new Identifier(node.getVars().get(0));", "+      LinkedList<IdentifierToken> listForQualifiedName = new LinkedList<IdentifierToken>();", "+      listForQualifiedName.add(counterName);", "+      QualifiedName arg = new QualifiedName(listForQualifiedName);", "+      VariableModifier mod = new VariableModifier(arg, int.class);", "+      arg.setProperty(NodeProperties.MODIFIER, mod);", "+      statement1 = new AddAssignExpression(arg, new IntegerLiteral(\"1\"));", "+      statement1.setProperty(NodeProperties.TYPE, int.class);", "+      ", "+      Expression arrayaccess = new ArrayAccess(collection, arg);", "+", "+      listForQualifiedName = new LinkedList<IdentifierToken>();", "+      listForQualifiedName.add(new Identifier(formalparam.getName()));", "+      arg = new QualifiedName(listForQualifiedName);", "+      mod = new VariableModifier(arg, collTypeClass.getComponentType());", "+      arg.setProperty(NodeProperties.MODIFIER, mod);", "+      assignment  = new SimpleAssignExpression(arg, arrayaccess);", "+      assignment.setProperty(NodeProperties.TYPE, collTypeClass.getComponentType());", "+    }else{", "+      IdentifierToken newforcounter = new Identifier(node.getVars().get(0));", "+      List<IdentifierToken> listForQualifiedName = new LinkedList<IdentifierToken>();", "+      listForQualifiedName.add(newforcounter);", "+      QualifiedName qf = new QualifiedName(listForQualifiedName);", "+      ObjectMethodCall next = new ObjectMethodCall(qf, \"next\", null,", "+                                                   \"\", 0, 0, 0, 0);", "+      /* these next fields refer to fileame and row/col of source", "+       * but there isn't any source, b/c i'm making it... */", "+      /* set properties of next */", "+      Method m3 = null;", "+      try {", "+        m3 = context.lookupMethod(exp, \"next\", Constants.EMPTY_CLASS_ARRAY);", "+      }catch(NoSuchMethodException e){", "+        /* this is very bad */", "+        /* should never happen, b/c everything has typechecked etc and been ok'd */", "+      }catch(MethodModificationError e){", "+        /* ths is very bad */", "+        /* should never happen, b/c everything has typechecked etc and been ok'd */", "+      }", "+      next.setProperty(NodeProperties.METHOD, m3);", "+      next.setProperty(NodeProperties.TYPE,   m3.getReturnType());", "+      /* done setting properties */", "+      ", "+      ", "+      statement1 = new VariableDeclaration(formalparam.isFinal(), ", "+                                              formalparam.getType(), ", "+                                              formalparam.getName(), ", "+                                              next);", "+      statement1.setProperty(NodeProperties.TYPE, NodeProperties.getType(next));", "+      c = NodeProperties.getType(next);", "+      statement1.setProperty(NodeProperties.TYPE, c);", "+      ((VariableDeclaration)statement1).getType().setProperty(NodeProperties.TYPE, c);", "+    }", "+    ", "+    ", "+    ", "+    ", "+    /************************************************************************************/", "+    /**  evaluate the foreach  **********************************************************/", "+    /************************************************************************************/", "+    ", "+    ", "+    ", "+    while(((Boolean)condition.acceptVisitor(this)).booleanValue()){", "+      /* if the foreach uses an array, then it will have an assignment instruction that must be run */", "+      /* otherwise it will be null */", "+      if(assignment != null){", "+        assignment.acceptVisitor(this);", "+      }", "+      statement1.acceptVisitor(this);", "+      body.acceptVisitor(this);", "+    }", "+    ", "+    context.leaveScope();", "+    "]}], "num": 27172}