{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cb79d7f0494c20c0deb65e4e21f65898", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "713a3052278edf40c7048c54a7f8c094", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractGlobalModel.java", "commitBeforeChange": "b555b0cfcc7bbb9f082899ce815305f8a985343e", "commitAfterChange": "aafaf7b848d738e58eee48a6cbc4b800c8027685", "methodNumberBeforeChange": 211, "methodNumberAfterChange": 213, "signatureBeforeChange": "     public boolean saveFileAs(FileSaveSelector com) throws IOException", "signatureAfterChange": "     public boolean saveFileAs(FileSaveSelector com) throws IOException", "diff": ["+//        System.err.println(\"saveFileAs called\");", "+//        System.err.println(\"saveFileAs called on \" + file);", "-        boolean shouldSave = false;", "-        boolean openInOtherDoc = ((otherDoc != null) && (openDoc != otherDoc));", "+", "-        if (openInOtherDoc) shouldSave = com.warnFileOpen(file);", "-          // Can't save over an open document", "+        boolean openInOtherDoc = ((otherDoc != null) && (openDoc != otherDoc));", "-        // If the file exists, make sure it's ok to overwrite it", "-        if ((shouldSave && openInOtherDoc) || ", "-            (!openInOtherDoc && (!file.exists() || com.verifyOverwrite()))) {", "+        // If the file is open in another document, abort if user does not confirm overwriting it", "+        if (openInOtherDoc) {", "+          boolean shouldOverwrite = com.warnFileOpen(file);", "+          if (! shouldOverwrite) return true; // operation not cancelled?  Strange", "+        }", "+        ", "+        if (! file.exists() || com.verifyOverwrite()) {  // confirm that existing file can be overwritten", "+          ", "+//          System.err.println(\"Writing file \" + file);", "+//          System.err.println(\"Calling FileOps.saveFile to save it\");", "-              try { _editorKit.write(os, doc, 0, doc.getLength()); } ", "+              try { ", "+                doc.acquireReadLock();  // Technically required, but looks like overkill.", "+                _editorKit.write(os, doc, 0, doc.getLength());", "+                doc.releaseReadLock();", "+//                Utilities.show(\"Wrote file containing:\\n\" + doc.getText());", "+              } "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8677f8ef5748f39b293f3aedd0ed88d7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/JPDADebugger.java", "commitBeforeChange": "81f7bc68ef7285bacd5689ea0a54ea5647d9a1d8", "commitAfterChange": "12384109e03448701c98d404f37be617f6e32fee", "methodNumberBeforeChange": 81, "methodNumberAfterChange": 81, "signatureBeforeChange": "      private Value _getValueOfLocalVariable(LocalVariable var, ThreadReference thread)     throws InvalidTypeException, ClassNotLoadedException, AbsentInformationException,     IncompatibleThreadStateException, InvocationException, DebugException", "signatureAfterChange": "      private Value _getValueOfLocalVariable(LocalVariable var, ThreadReference thread)     throws InvalidTypeException, ClassNotLoadedException, AbsentInformationException,     IncompatibleThreadStateException, InvocationException, DebugException", "diff": ["-    // invokeMethod could execute. This happened infrequently so by trying this", "-    // multiple times, the chance of failure each time should be acceptably low.", "-    int tries = 0;", "-    while (tries < MAXINVOKETRIES) {", "-      try {", "-        List args = new LinkedList();", "-        args.add(_vm.mirrorOf(var.name()));", "-        v = interpreter.invokeMethod(thread, method2Call, args,", "-                                           ObjectReference.INVOKE_SINGLE_THREADED);", "-        break;", "+    // invokeMethod could execute. We now just disable collection until after the", "+    // method is invoked.", "+    List args = new LinkedList();", "+    String varName = var.name();", "+    StringReference sr = _vm.mirrorOf(varName);", "+    sr.disableCollection();", "+    args.add(sr);", "+    try {", "+      v = interpreter.invokeMethod(thread, method2Call, args,", "+                                   ObjectReference.INVOKE_SINGLE_THREADED);", "+      if (v != null) {", "+        v = _convertToActualType(thread, var, v);", "-      catch (ObjectCollectedException oce) {", "-        if (printMessages) System.out.println(\"Got ObjectCollectedException\");", "-        tries++;      ", "-      }", "+      ", "+      return v;", "-    if (v != null) {", "-      v = _convertToActualType(thread, var, v);", "+    catch (ObjectCollectedException oce) {", "+      throw new DebugException(\"The value of variable: \" + varName +", "+                               \" could not be obtained from the debug interpreter\");", "-", "-    return v;", "+    finally {", "+      sr.enableCollection();", "+    }"]}], "num": 25244}