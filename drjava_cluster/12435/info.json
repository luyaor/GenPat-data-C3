{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7c204b0f48a595c8da1670b0e482ef72", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3bb0f5743173119db75b9b3c29c08b2a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "3e22080f0d9650b7b802f9b713065e47d1a0ce19", "commitAfterChange": "1bbb44dda9ccbed1420a315a25ace5ab1cf20f80", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 28, "signatureBeforeChange": "   private SymbolData _getSymbolData_FromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,                                                    boolean addError)", "signatureAfterChange": "   private SymbolData _getSymbolData_FromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,                                                    boolean addError)", "diff": ["-    // Is qualifiedClassName in _classesToBeParsed, saving the time it would take to parse", "-    // all the java files in this package.", "-    Pair<TypeDefBase, LanguageLevelVisitor> pair = _classesToBeParsed.get(qualifiedClassName);", "+    // If qualifiedClassName is already defined (and not a continuation to resolve), return", "+    SymbolData sd = symbolTable.get(qualifiedClassName);", "+    if (sd != null && (! resolve || ! sd.isContinuation())) { return sd; }", "+    // Is qualifiedClassName in _classesToBeParsed, look it up directly in the parsed ASTs", "+    Pair<TypeDefBase, LanguageLevelVisitor> pair = _classesToBeParsed.get(qualifiedClassName);", "-    // First look for the .class file", "-    File classFile = new File(path + \".class\");", "-    // Then look for the most recently modified .java, .djx file.    ", "+    // Find class file and matching source file for qualifiedClassName -- if they exist", "+    ", "+    File classFile = new File(path + \".class\");  // create File object for class file", "+    ", "+    // Then look for the most recently modified matching source (.djx or .java) file.    ", "+", "+    // Claim: sourceFile is not the current file.  Otherwise, className would have been in _classNamesInThisFile.", "-    // Check if sourceFile is the current file.  If so, there's an error because if the class to look for", "-    // is in the current file, it would've been in _classNamesInThisFile.", "-    //TODO: it is possible this should be an error.  But I am no longer positive.", "-    ", "-    // Then check the corresponding class file to see if it's up to date.", "-    SymbolData sd = symbolTable.get(qualifiedClassName);", "-    if (sd != null && ! sd.isContinuation()) { return sd; }", "+    // If sourceFile exists, we have identified the class corresponding to qualifiedClassName.  If resolve is false, ", "+    // simply create and return the appropriate continuation, deferring the loading of class information until reolution", "+    // time.  If there is no corresponding class file or the class file is not ", "+    // up-to-date, signal an error.  Otherwise load the symbol table information from the class file", "+", "-      if (! resolve) {", "-        if (sd != null) { return sd; }", "-        else {", "-          sd = new SymbolData(qualifiedClassName);", "-          continuations.put(qualifiedClassName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));", "-          symbolTable.put(qualifiedClassName, sd);", "-          return sd;", "+      if (! resolve) { ", "+        assert sd == null;", "+        sd = addSymbolData(si, qualifiedClassName); // defer loading class file information", "+        return sd;", "+//        else {", "+//          sd = new SymbolData(qualifiedClassName);", "+//          continuations.put(qualifiedClassName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));", "+//          symbolTable.put(qualifiedClassName, sd);", "+//          return sd;", "-      }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "631b645be48cd3ae49bbd1fce8a4fc9d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 14, "signatureBeforeChange": "   private SymbolData _getSymbolData_FromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,                                                    boolean addError)", "signatureAfterChange": "   protected SymbolData _getSymbolDataFromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,                                                     boolean addError)", "diff": ["-  private SymbolData _getSymbolData_FromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,", "-                                                   boolean addError) {", "+  protected SymbolData _getSymbolDataFromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,", "+                                                    boolean addError) {", "-    if (sd != null && (! resolve || ! sd.isContinuation())) { return sd; }", "+    if (sd != null && (! sd.isContinuation() || ! resolve)) return sd;  ", "+    // Note: sd != null && ! sd.isContinuation => sd has already been resolved", "-    // Is qualifiedClassName in _classesToBeParsed, look it up directly in the parsed ASTs", "-    Pair<TypeDefBase, LanguageLevelVisitor> pair = _classesToBeParsed.get(qualifiedClassName);", "-    if (pair != null) return _lookupFromClassesToBeParsed(qualifiedClassName, si, resolve);", "+//    // Is qualifiedClassName in _classesInThisFile, look it up directly in the parsed ASTs", "+//    boolean present = _classesInThisFile.contains(qualifiedClassName);", "+//    if (present) return _identifyTypeFromClassNamesInThisfile(qualifiedClassName, si, resolve);", "-          return new File(path + \".dj0\").getCanonicalFile().equals(f) ||", "+          return new File(path + \".dj\").getCanonicalFile().equals(f) ||", "+            new File(path + \".dj0\").getCanonicalFile().equals(f) ||", "-    // Claim: sourceFile is not the current file.  Otherwise, className would have been in _classNamesInThisFile.", "+//    // Claim: sourceFile is not the current file or sd is an inner class.  Otherwise, className would have been in ", "+//    // _classesInThisFile.", "-        sd = addSymbolData(si, qualifiedClassName); // defer loading class file information", "+        sd = makeContinuation(si, qualifiedClassName); // create a continuation for qualifiedClassName; defer resolution", "-//          continuations.put(qualifiedClassName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));", "+//          continuations.put(qualifiedClassName, ", "+//                            new Triple<SourceInfo, LanguageLevelVisitor, SymbolData>(si, this, sd));", "-    // if source file exists, the corresponding class file is up to date", "+    // if source file exists, confirm that the corresponding class file is up to date", "+    // if source file does not exist, confirm that a class file does exist", "-      sd = _classFile2SymbolData(qualifiedClassName, programRoot);", "+      sd = LanguageLevelConverter._classFile2SymbolData(qualifiedClassName, programRoot);", "-          _addAndIgnoreError(\"File \" + classFile + \" is not a valid class file.\", null);", "+          _addAndIgnoreError(\"File \" + classFile + \" is not a valid class file.\",  new NullLiteral(si));"]}], "num": 12435}