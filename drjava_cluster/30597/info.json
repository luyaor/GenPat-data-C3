{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dad4dccd3cfe6cc05e61619845d6cb28", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "518fccb5e0b7354ed5be650537b07c39", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/FindReplacePanel.java", "commitBeforeChange": "5d8a3bdb2b4d5525535575f357c7961c2851e09a", "commitAfterChange": "2d393792d3779835588c185ebb45db67c3e34dc4", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "   public void findAll(String searchStr, final boolean searchAll, final boolean matchCase,                       final boolean wholeWord, final boolean noComments, final boolean noTestCases,                       final OpenDefinitionsDocument startDoc, final RegionManager<MovingDocumentRegion> rm,                       final FindResultsPanel panel)", "signatureAfterChange": "   public void findAll(String searchStr, final boolean searchAll, final boolean matchCase,                       final boolean wholeWord, final boolean noComments, final boolean noTestCases,                       final OpenDefinitionsDocument startDoc, final RegionManager<MovingDocumentRegion> rm,                       final FindResultsPanel panel)", "diff": ["-        final StringBuilder sb = new StringBuilder();", "-        int endSel = fr.getFoundOffset();", "-        int startSel = endSel - searchLen;", "+        int end = fr.getFoundOffset();", "+        int start = end - searchLen;", "-          final Position startPos = doc.createPosition(startSel);", "-          final Position endPos = doc.createPosition(endSel);", "+          final Position startPos = doc.createPosition(start);", "+          final Position endPos = doc.createPosition(end);", "-          // create excerpt string", "+          // lazily create excerpt string", "-          // The following were commented out because they require doc to be loaded as a Definitions (Swing) Document,", "-          // but results processing presumes this access in many places", "-          int excerptEndSel = doc._getLineEndPos(endSel);", "-          int excerptStartSel = doc._getLineStartPos(startSel);", "-// Text only alternative to preceding two statements commented out          ", "-//          String text = doc.getText();", "-//          final int len = text.length();", "-//          int i = endSel;", "-//          while (i < len && text.charAt(i) != '\\n') ++i;", "-//          final int excerptEndSel = i;", "-//          ", "-//          i = startSel;", "-//          while (i >= 0 && text.charAt(i) != '\\n') --i; // the end of the line", "-//          final int excerptStartSel = i + 1;              // either 0 or the beginning of the line", "+          StringSuspension ss = new StringSuspension() {", "+            public String eval() {", "+              try {", "+                int endSel = endPos.getOffset();", "+                int startSel = startPos.getOffset();", "+                int excerptEndSel = doc._getLineEndPos(endSel);", "+                int excerptStartSel = doc._getLineStartPos(startSel);", "+                ", "+                int length = Math.min(120, excerptEndSel - excerptStartSel);", "+                ", "+                // this highlights the actual region in red", "+                int startRed = startSel - excerptStartSel;", "+                int endRed = endSel - excerptStartSel;", "+                ", "+                String text = doc.getText(excerptStartSel, length);", "+                String s = text.trim();  // trims both front and end", "+                int sLength = s.length();", "+                ", "+                // We need a global invariant concerning non-displayable characters.  Why filter them here but not elsewhere?", "+//              // change control characters and ones that may not be displayed to spaces", "+//              for (int j = 0; j < s.length(); ++j) {", "+//                sb.append((s.charAt(j) < ' ' || s.charAt(j) > 127) ? ' ' :  s.charAt(j));", "+//              }", "+//              s = sb.toString();", "+//              ", "+//              trim the front", "+//                for (int j = 0; j < s.length(); ++j) {", "+//                if (! Character.isWhitespace(s.charAt(j))) break;", "+//                --startRed;", "+//                --endRed;", "+//              }", "+//              ", "+//              // trim the end", "+//              s = s.trim();", "+                ", "+                int trimLeftCt = text.indexOf(s.charAt(0));", "+                int trimRightCt = text.length() - sLength;", "+                // bound startRed and endRed", "+                startRed = startRed - trimLeftCt;  // offset in s rather than in text", "+                endRed = endRed - trimRightCt;", "+                if (startRed < 0) { startRed = 0; }", "+                if (startRed > sLength) { startRed = sLength; }", "+                if (endRed < startRed) { endRed = startRed; }", "+                if (endRed > sLength) { endRed = sLength; }", "+                ", "+                // create the excerpt string", "+                StringBuilder sb = new StringBuilder(StringOps.encodeHTML(s.substring(0, startRed)));", "+                sb.append(\"<font color=#ff0000>\");", "+                sb.append(StringOps.encodeHTML(s.substring(startRed, endRed)));", "+                sb.append(\"</font>\");", "+                sb.append(StringOps.encodeHTML(s.substring(endRed)));", "+//                sb.append(StringOps.encodeHTML(AbstractDJDocument.getBlankString(120 - sLength)));", "+                return sb.toString();", "+              }", "+              catch(BadLocationException e) { return \"***BadLocationException in StringSuspension.eval()***\"; }", "+            }", "+          };", "-          int length = Math.min(120, excerptEndSel - excerptStartSel);", "-          ", "-          // this highlights the actual region in red", "-          int startRed = startSel - excerptStartSel;", "-          int endRed = endSel - excerptStartSel;", "-          String s = doc.getText(excerptStartSel, length);", "-          ", "-          // change control characters and ones that may not be displayed to spaces", "-          for (int j = 0; j < s.length(); ++j) {", "-            sb.append((s.charAt(j) < ' ' || s.charAt(j) > 127) ? ' ' :  s.charAt(j));", "-          }", "-          s = sb.toString();", "-          ", "-          // trim the front", "-          for (int j = 0; j < s.length(); ++j) {", "-            if (! Character.isWhitespace(s.charAt(j))) break;", "-            --startRed;", "-            --endRed;", "-          }", "-          ", "-          // trim the end", "-          s = s.trim();", "-          ", "-          // bound startRed and endRed", "-          if (startRed < 0) { startRed = 0; }", "-          if (startRed > s.length()) { startRed = s.length(); }", "-          if (endRed < startRed) { endRed = startRed; }", "-          if (endRed > s.length()) { endRed = s.length(); }", "-          ", "-          // create the excerpt string", "-          sb.setLength(0);", "-          sb.append(StringOps.encodeHTML(s.substring(0, startRed)));", "-          sb.append(\"<font color=#ff0000>\");", "-          sb.append(StringOps.encodeHTML(s.substring(startRed, endRed)));", "-          sb.append(\"</font>\");", "-          sb.append(StringOps.encodeHTML(s.substring(endRed)));", "-          rm.addRegion(new MovingDocumentRegion(doc, doc.getFile(), startPos, endPos, sb.toString()));", "+          rm.addRegion(new MovingDocumentRegion(doc, doc.getFile(), startPos, endPos, ss));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c239a5f412dfb9b58764eeab00f811c5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocument.java", "commitBeforeChange": "a8db062e8dfd667df6324c059f7a6725afc99a1b", "commitAfterChange": "35da9b77b7d75aca3d6277e27e3ba3dc86f3eaa9", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 43, "signatureBeforeChange": "   public String getNextTopLevelClassName(int startPos, int endPos)     throws ClassNameNotFoundException", "signatureAfterChange": "   public String getNextTopLevelClassName(int startPos, int endPos) throws ClassNameNotFoundException", "diff": ["-  public String getNextTopLevelClassName(int startPos, int endPos)", "-    throws ClassNameNotFoundException {", "-    // throwErrorHuh();", "+  public String getNextTopLevelClassName(int startPos, int endPos) throws ClassNameNotFoundException {", "-    int oldLocation = getCurrentLocation();", "-", "-    try {", "-      setCurrentLocation(startPos);", "-      final int textLength = endPos - startPos;", "-      final String text = getText(startPos, textLength);", "-", "-      boolean done;", "-      int index;", "-", "-      int indexOfClass = _findKeywordAtToplevel(\"class\", text, startPos);", "-      int indexOfInterface = _findKeywordAtToplevel(\"interface\", text, startPos);", "-      int indexOfEnum = _findKeywordAtToplevel(\"enum\",text,startPos);", "-        ", "-      //If class exists at top level AND either there is no interface at top level or the index of class precedes the index of the top", "-      //level interface, AND the same for top level enum, then the class is the first top level declaration", "-      if( (indexOfClass > -1) ", "-           && (indexOfInterface <= -1 || indexOfClass < indexOfInterface) ", "-           && (indexOfEnum <= -1 || indexOfClass < indexOfEnum) ) {", "-        index = indexOfClass + \"class\".length();", "-      }", "-      else if( (indexOfInterface > -1) ", "-                && (indexOfClass <= -1 || indexOfInterface < indexOfClass) ", "-                && (indexOfEnum <= -1 || indexOfInterface < indexOfEnum) ) {", "-        index = indexOfInterface + \"interface\".length();", "-      }", "-      else if( (indexOfEnum > -1)", "-                && (indexOfClass <= -1 || indexOfEnum < indexOfClass)   ", "-                && (indexOfInterface <= -1 || indexOfEnum < indexOfInterface)) {", "-        index = indexOfEnum + \"enum\".length();", "-      }", "-      else {", "-        // no index was valid", "-        throw new ClassNameNotFoundException(\"No top level class name found\");", "-      }", "-        ", "-      ", "-//      if (indexOfClass > -1) {", "-//", "-//        if (indexOfInterface > -1) {", "-//          // compare indices to find the lesser", "-//          index = (indexOfClass < indexOfInterface) ?", "-//            indexOfClass + \"class\".length() :", "-//            indexOfInterface + \"interface\".length();", "-//        }", "-//        else {", "-//          //top level class declaration found", "-//          index = indexOfClass + \"class\".length();", "-//        }", "-//      }", "-//      else {", "-//        if (indexOfInterface > -1) {", "-//          index = indexOfInterface + \"interface\".length();", "-//        }", "-//        else {", "-//          // neither index was valid", "-//          throw new ClassNameNotFoundException(\"No top level class name found\");", "-//        }", "-//      }", "-", "-      //if we make it here we have a valid index", "-", "-      //first find index of first non whitespace (from the index in document)", "-      index = getFirstNonWSCharPos(startPos + index) - startPos;", "-      if (index == -1) throw new ClassNameNotFoundException(\"No top level class name found\");", "-", "-      int endIndex = textLength; //just in case no whitespace at end of file", "-", "-      //find index of next delimiter or whitespace", "-      char c;", "-      for (int i = index; i < textLength; i++) {", "-        c = text.charAt(i);", "-        if (!Character.isJavaIdentifierPart(c)) {", "-          endIndex = i;", "-          break;", "-        }", "-      }", "-", "-      setCurrentLocation(oldLocation);", "-      return text.substring(index,endIndex);", "-    }", "-    catch (BadLocationException ble) { throw new UnexpectedException(ble); }", "-    finally { setCurrentLocation(oldLocation); }", "-  }", "+    int oldLocation = _currentLocation;", "+    readLock();", "+      try {", "+        setCurrentLocation(startPos);", "+        final int textLength = endPos - startPos;", "+        final String text = getText(startPos, textLength);", "+        ", "+        boolean done;", "+        int index;", "+        ", "+        int indexOfClass = _findKeywordAtToplevel(\"class\", text, startPos);", "+        int indexOfInterface = _findKeywordAtToplevel(\"interface\", text, startPos);", "+        int indexOfEnum = _findKeywordAtToplevel(\"enum\",text,startPos);", "+        ", "+        //If class exists at top level AND either there is no interface at top level or the index of class precedes the index of the top", "+        //level interface, AND the same for top level enum, then the class is the first top level declaration", "+        if (indexOfClass > -1 && (indexOfInterface <= -1 || indexOfClass < indexOfInterface) ", "+              && (indexOfEnum <= -1 || indexOfClass < indexOfEnum)) {", "+          index = indexOfClass + \"class\".length();", "+        }", "+        else if (indexOfInterface > -1 && (indexOfClass <= -1 || indexOfInterface < indexOfClass) ", "+                  && (indexOfEnum <= -1 || indexOfInterface < indexOfEnum)) {", "+          index = indexOfInterface + \"interface\".length();", "+        }", "+        else if (indexOfEnum > -1 && (indexOfClass <= -1 || indexOfEnum < indexOfClass)   ", "+                   && (indexOfInterface <= -1 || indexOfEnum < indexOfInterface)) {", "+          index = indexOfEnum + \"enum\".length();", "+        }", "+          // no index was valid", "+          throw new ClassNameNotFoundException(\"No top level class name found\");", "+        }", "+        //if we make it here we have a valid index", "+        ", "+        //first find index of first non whitespace (from the index in document)", "+        index = getFirstNonWSCharPos(startPos + index) - startPos;", "+        if (index == -1) throw new ClassNameNotFoundException(\"No top level class name found\");", "+        ", "+        int endIndex = textLength; //just in case no whitespace at end of file", "+        ", "+        //find index of next delimiter or whitespace", "+        char c;", "+        for (int i = index; i < textLength; i++) {", "+          c = text.charAt(i);", "+          if (!Character.isJavaIdentifierPart(c)) {", "+            endIndex = i;", "+        ", "+        setCurrentLocation(oldLocation);", "+        return text.substring(index,endIndex);", "+      catch (BadLocationException ble) { throw new UnexpectedException(ble); }", "+      finally { ", "+        setCurrentLocation(oldLocation);", "+        readUnlock();", "+      }"]}], "num": 30597}