{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "121c09803c10e39c5ca913e9de430ec4", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "71ff7a539eb3c9e5735b0657c8a859ae", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/StringOps.java", "commitBeforeChange": "e02b291d62bdaa0ea7b37dd3f2ab84515aaa6d58", "commitAfterChange": "8d09927a54fdf6b15f8ba5f6b7e80366b0cf24be", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "   public static String replaceVariables(String str, PropertyMaps props, Lambda<String,DrJavaProperty> getter)", "signatureAfterChange": "   public static String replaceVariables(String str, PropertyMaps props, Lambda<String,DrJavaProperty> getter)", "diff": ["-    int pos = str.indexOf(\"${\");", "-    int bsPos = str.indexOf('\\\\');", "-    if ((bsPos!=-1) && (bsPos<pos)) { pos = bsPos; }", "-    // find every ${", "-    // LOG.log(\"========================\");", "-    while(pos>=0) {", "-      // LOG.log(\"str = '\"+str+\"', pos = \"+pos);", "-      // see if this is an escaped \\ (\\\\)", "-      if ((str.charAt(pos)=='\\\\') &&", "-          (pos<str.length()-1) &&", "-          (str.charAt(pos+1)=='\\\\')) {", "-        // change the \\\\ into a single \\", "-        // LOG.log(\"\\t\\\\\\\\\");", "-        str = str.substring(0, pos) + str.substring(pos+1);", "-      }", "-      // see if this is an escaped $ (\\$)", "-      else if ((str.charAt(pos)=='\\\\') &&", "-               (pos<str.length()-1) &&", "-               (str.charAt(pos+1)=='$')) {", "-        // change the \\$ into a single $", "-        // LOG.log(\"\\t\\\\$\");", "-        str = str.substring(0, pos) + str.substring(pos+1);", "-        // and skip", "-        ++pos;", "-      }", "-      else if ((str.charAt(pos)=='$')) {", "-        // LOG.log(\"\\t$\");", "-        // look if this is str property name enclosed by ${...}, e.g. \"${user.home}\"", "-        if ((pos<str.length()-1) && (str.charAt(pos+1)=='{')) {", "-          int nextClose = str.indexOf('}',pos+1);", "-          if (nextClose>=0) {", "-            String key = str.substring(pos+2, nextClose);", "-            // LOG.log(\"\\tkey = '\"+key+\"'\");", "-            for(String category: props.getCategories()) {", "-              // LOG.log(\"\\ttrying category '\"+category+\"'\");", "-              DrJavaProperty p = props.getProperty(category, key);", "-              if (p!=null) {", "-                // found property name", "-                // replace \"${property.name}\" with the value of the property, e.g. /home/user", "-                String s = getter.apply(p);", "-                str = str.substring(0, pos) + s + str.substring(nextClose+1);", "-                // advance to the last character of the value", "-                pos = nextClose;", "-                break;", "+    BalancingStreamTokenizer tok = new BalancingStreamTokenizer(new StringReader(str));", "+    tok.wordRange(0,255);", "+    tok.addQuotes(\"${\", \"}\");", "+    ", "+    // LOG.log(\"---------\");", "+    // LOG.log(\"Replacing: \"+str);", "+    StringBuilder sb = new StringBuilder();", "+    String next = null;", "+    try {", "+      while((next=tok.getNextToken())!=null) {", "+        if ((next.startsWith(\"${\")) &&", "+             (next.endsWith(\"}\"))) {", "+          // LOG.log(\"Found property: \"+next);", "+          String key;", "+          String attrList = \"\";", "+          int firstCurly = next.indexOf('}');", "+          int firstSemi = next.indexOf(';');", "+          if (firstSemi<0) {", "+            // format: ${property.name}", "+            // for key, cut off ${ and }", "+            key = next.substring(2,firstCurly);", "+          }", "+          else {", "+            // format: {$property.name;...}", "+            // for key, cut off ${ and ;...}", "+            key = next.substring(2,firstSemi);", "+            // for attribute list, cut off ${propertyname; and }", "+            attrList = next.substring(firstSemi+1,next.length()-1).trim();", "+          }", "+          // LOG.log(\"\\tKey      = '\"+key+\"'\");", "+          // LOG.log(\"\\tAttrList = '\"+attrList+\"'\");", "+          boolean found = false;", "+          for(String category: props.getCategories()) {", "+            DrJavaProperty p = props.getProperty(category, key);", "+            if (p!=null) {", "+              // found property name", "+              p.resetAttributes();", "+              ", "+              // if we have a list of attributes", "+              try {", "+                if (attrList.length()>0) {", "+                  BalancingStreamTokenizer atok = new BalancingStreamTokenizer(new StringReader(attrList));", "+                  atok.wordRange(0,255);", "+                  atok.whitespaceRange(0,32);", "+                  atok.addQuotes(\"\\\"\", \"\\\"\");", "+                  atok.addKeyword(\";\");", "+                  atok.addKeyword(\"=\");", "+                  // LOG.log(\"\\tProcessing AttrList\");", "+                  String n = null;", "+                  while((n=atok.getNextToken())!=null) {", "+                    if ((n==null) || n.equals(\";\") || n.equals(\"=\") || n.startsWith(\"\\\"\")) {", "+                      throw new IllegalArgumentException(\"Unknown attribute list format for property \"+key);", "+                    }", "+                    String name = n;", "+                    // LOG.log(\"\\t\\tname = '\"+name+\"'\");", "+                    n = atok.getNextToken();", "+                    if ((n==null) || (!n.equals(\"=\"))) {", "+                      throw new IllegalArgumentException(\"Unknown attribute list format for property \"+key);", "+                    }", "+                    // LOG.log(\"\\t\\tread '='\");", "+                    n = atok.getNextToken();", "+                    if ((n==null) || (!n.startsWith(\"\\\"\"))) {", "+                      throw new IllegalArgumentException(\"Unknown attribute list format for property \"+key);", "+                    }", "+                    String value = \"\";", "+                    if (n.length()>1) {", "+                      value = n.substring(1,n.length()-1);", "+                      // LOG.log(\"\\t\\tvalue = '\"+value+\"'\");", "+                    }", "+                    n = atok.getNextToken();", "+                    if ((n!=null) && (!n.equals(\";\"))) {", "+                      throw new IllegalArgumentException(\"Unknown attribute list format for property \"+key);", "+                    }", "+                    // LOG.log(\"\\t\\tread ';' or EOF\");", "+                    // processed correctly", "+                    // LOG.log(\"\\t\\treplacing variables in '\"+value+\"'...\");", "+                    String replacedValue = replaceVariables(value, props, getter);", "+                    // LOG.log(\"\\t\\treplaced value is '\"+replacedValue+\"'\");", "+                    ", "+                    p.setAttribute(name, replacedValue);", "+                    ", "+                    if (n==null) { break; }", "+                  }", "+                }", "+                // append the value of the property, e.g. /home/user instead of \"${property.name}\"", "+                String finalValue = getter.apply(p);", "+                // LOG.log(\"\\tfinal value: '\"+finalValue+\"'\");", "+                found = true;", "+                sb.append(finalValue);", "+              }              ", "+              catch(IllegalArgumentException e) {", "+                sb.append(\"<-- Error: \"+e.getMessage()+\" -->\");", "+              if (found) { break; }", "+              continue;", "+            if (found) { break; }", "+          }", "+          if (!found) {", "+            // unknown property", "+            sb.append(next);", "+        else {", "+          sb.append(next);", "+        }", "-      pos = str.indexOf(\"${\", pos+1);", "-      bsPos = str.indexOf(\"\\\\\\\\\", pos+1);", "-      if ((bsPos!=-1) && (bsPos<pos)) { pos = bsPos; }", "-    // LOG.log(\"end str = '\"+str+\"'\");", "-    return str;", "+    catch(IllegalArgumentException e) {", "+      return \"<-- Error: \"+e.getMessage()+\" -->\";", "+    }", "+    catch(IOException e) {", "+      return \"<-- Error: \"+e.getMessage()+\" -->\";", "+    }", "+    ", "+    // LOG.log(\"Returning '\"+sb.toString()+\"'\");", "+    // LOG.log(\"---------\");", "+    ", "+    return sb.toString();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa4c6a29a6d4f34ae0fd64c5a5201bbf", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/JLSTypeSystem.java", "commitBeforeChange": "80debf5b9716524c576a71fc4929233c9637cd68", "commitAfterChange": "0dc6c4e6c51f7a1991368187e63e0eff0d7150ef", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 42, "signatureBeforeChange": "          public boolean contains(final Type subT, final Type superT)", "signatureAfterChange": "          public boolean contains(final Type subT, final Type superT)", "diff": ["-      //debug.logStart(new String[]{\"subT\", \"superT\"}, subT, superT); try {", "+      debug.logStart(new String[]{\"subT\", \"superT\"}, wrap(subT), wrap(superT)); try {", "-        public Boolean forClassType(final ClassType subT) {", "+        @Override public Boolean forSimpleClassType(final SimpleClassType subT) {", "-            public Boolean defaultCase(Type superT) { return false; }", "+            @Override public Boolean defaultCase(Type superT) { return false; }", "-        public Boolean forParameterizedClassType(final ParameterizedClassType subT) {", "+        @Override public Boolean forRawClassType(final RawClassType subT) {", "-            public Boolean defaultCase(Type superT) { return false; }", "-            ", "+            @Override public Boolean defaultCase(Type superT) { return false; }", "+            @Override public Boolean forClassType(final ClassType superT) {", "+              Type newSub = immediateSupertype(subT);", "+              if (newSub == null) { return false; }", "+              else { return Subtyper.this.contains(newSub, superT); }", "+            }", "-                ", "-                Thunk<Boolean> containedArgs = new Thunk<Boolean>() {", "-                  public Boolean value() {", "-                    boolean result = true;", "-                    ParameterizedClassType subCapT = capture(subT);", "-                    for (final Triple<Type, Type, Type> args : zip(subT.typeArguments(),", "-                                                                   subCapT.typeArguments(), ", "-                                                                   superT.typeArguments())) {", "-                      result &= args.third().apply(new TypeAbstractVisitor<Boolean>() {", "-                        public Boolean defaultCase(Type superArg) {", "-                          return isEqual(args.second(), superArg);", "-                        }", "-                        @Override public Boolean forWildcard(final Wildcard superArg) {", "-                          Thunk<Boolean> inBounds = new Thunk<Boolean>() {", "-                            public Boolean value() {", "-                              Type subArg = args.second();", "-                              return Subtyper.this.contains(superArg.symbol().lowerBound(), subArg) &&", "-                                     Subtyper.this.contains(subArg, superArg.symbol().upperBound());", "-                            }", "-                          };", "-                          // if we've seen this sub arg/super arg combo before, we can prove subtyping inductively", "-                          // (assuming superArg appears in a valid context -- checked by isWellFormed)", "-                          // Put the pre-capture sub arg on the stack, because post-capture it may be a fresh var", "-                          return _stack.apply(inBounds, true, args.first(), superArg);", "-                        }", "-                      });", "-                      if (!result) { break; }", "-                    }", "-                    return result;", "-                  }", "-                };", "-                ", "-                return _stack.apply(containedArgs, false, subT, superT) || forClassType(superT);", "+                return Subtyper.this.contains(parameterize(subT), superT) || forClassType(superT);", "+          });", "+        }", "+        ", "+        public Boolean forParameterizedClassType(final ParameterizedClassType subT) {", "+          return superT.apply(new TypeAbstractVisitor<Boolean>() {", "+            @Override public Boolean defaultCase(Type superT) { return false; }", "-              else {", "-                return Subtyper.this.contains(newSub, superT) || Subtyper.this.contains(erase(subT), superT);", "+              else { return Subtyper.this.contains(newSub, superT); }", "+            }", "+            ", "+            @Override public Boolean forParameterizedClassType(final ParameterizedClassType superT) {", "+              if (subT.ofClass().equals(superT.ofClass())) {", "+                boolean result = true;", "+                ParameterizedClassType subCapT = capture(subT);", "+                for (final Triple<Type, Type, Type> args : zip(subT.typeArguments(),", "+                                                               subCapT.typeArguments(), ", "+                                                               superT.typeArguments())) {", "+                  result &= args.third().apply(new TypeAbstractVisitor<Boolean>() {", "+                    public Boolean defaultCase(Type superArg) {", "+                      return isEqual(args.second(), superArg);", "+                    }", "+                    @Override public Boolean forWildcard(final Wildcard superArg) {", "+                      Thunk<Boolean> inBounds = new Thunk<Boolean>() {", "+                        public Boolean value() {", "+                          Type subArg = args.second();", "+                          return Subtyper.this.contains(superArg.symbol().lowerBound(), subArg) &&", "+                                 Subtyper.this.contains(subArg, superArg.symbol().upperBound());", "+                        }", "+                      };", "+                      // if we've seen this sub arg/super arg combo before, we can prove subtyping inductively", "+                      // (assuming superArg appears in a valid context -- checked by isWellFormed)", "+                      // Put the pre-capture sub arg on the stack, because post-capture it may be a fresh var", "+                      return _stack.apply(inBounds, true, args.first(), superArg);", "+                    }", "+                  });", "+                  if (!result) { break; }", "+                }", "+                return result || forClassType(superT);", "+              else { return forClassType(superT); }", "+            }", "+            ", "+            @Override public Boolean forRawClassType(RawClassType superT) {", "+              if (subT.ofClass().equals(superT.ofClass())) {", "+                return Subtyper.this.contains(erase(subT), superT);", "+              }", "+              else { return forClassType(superT); }", "-      //} finally { debug.logEnd(); }", "+      } finally { debug.logEnd(); }"]}], "num": 8760}