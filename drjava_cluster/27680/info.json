{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c031083428943aa6ccd57921b7d3651a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "84614fcfa551de63bbe97dce5c7d253a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/util/ReflectionUtilities.java", "commitBeforeChange": "1ef951d20d276f3c46e1cf20ba51ab4b6ce00f53", "commitAfterChange": "fe7c222597b4c2632fd01caf1fa72f992186277e", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public static Method lookupMethod(Class cl, String name, Class[] ac)     throws NoSuchMethodException", "signatureAfterChange": "   public static Method lookupMethod(Class cl, String name, Class[] ac)     throws NoSuchMethodException", "diff": ["-    List<Method> ms = getMethods(cl, name, ac.length);", "-    List<Method> mm = new LinkedList<Method>();", "+    List<Method> all = getMethods(cl, name, ac.length);", "+    List<Method> compatible = new LinkedList<Method>();", "-    // put them in 'mm'", "-    Iterator<Method> it = ms.iterator();", "+    // put them in 'compatible'", "+    Iterator<Method> it = all.iterator();", "-        mm.add(m);", "+        compatible.add(m);", "-    if (mm.isEmpty()) {", "-      boolean compatibleVersion = Float.valueOf(System.getProperty(\"java.specification.version\")) >= 1.5;", "-      ", "-      // Autoboxing handled in the isCompatible method called by the hasVarArgsCompatibleSignatures method", "-      ", "-      // Do second pass for finding a varargs method that matches given method call", "-      ", "-      ms = getVarArgsMethods(cl, name, ac.length);", "-      ", "-      // Search for the methods with good parameter types and", "-      // put them in 'mm'", "-      it = ms.iterator();", "-      while (it.hasNext()) {", "-        Method m = it.next();", "-        ", "-        if (hasVarArgsCompatibleSignatures(m.getParameterTypes(), ac)) {", "-          if (!compatibleVersion) {", "-            throw new WrongVersionException(\"Variable arguments are only supported in Java 1.5 or better\");", "-          }", "-          mm.add(m);", "-        }", "-      }", "-      ", "-      if(mm.isEmpty()){", "-        throw new NoSuchMethodException(name);", "-      }", "+    // Select the most specific method if any were found", "+    if (!compatible.isEmpty()) {", "+      return selectTheMostSpecificMethod(compatible);", "-    // Select the most specific method", "-    it = mm.iterator();", "-    Method result = it.next();", "+    // Do a second pass to search for methods with autoboxing", "+    it = all.iterator();", "-      result = selectTheMostSpecificMethod(result, it.next()); /**/// may be confused by mm having varargs and need to be changed", "+      Method m = it.next();", "+      TigerUsage tu = new TigerUsage();", "+      if (hasAutoBoxingCompatibleSignatures(m.getParameterTypes(), ac, tu)) {", "+        tu.checkForCompatibleUsage();", "+        compatible.add(m);", "+      }", "+    }", "+      ", "+    if (!compatible.isEmpty()) {", "+      return selectTheMostSpecificBoxingMethod(compatible);", "-    return result;", "-  }", "+    // Do third pass for finding a varargs method that matches given method call", "+    ", "+    it = all.iterator();", "+    while (it.hasNext()) {", "+      Method m = it.next();", "+      TigerUsage tu = new TigerUsage();", "+      if (hasVarArgsCompatibleSignatures(m.getParameterTypes(), ac, tu)) {", "+        tu.checkForCompatibleUsage();", "+        compatible.add(m);", "+      }", "+    }", "+    ", "+    if(compatible.isEmpty()){", "+      throw new NoSuchMethodException(generateNotFoundMsg(\"method\", cl.getName()+\".\"+name, ac));", "+    }", "+    else if (compatible.size() > 1) {", "+      // It is ambiguous if more than one variable-argument ", "+      // method matches the given parameter type list.", "+      throw new AmbiguousMethodException(\"both methods match: \" + ", "+                                         compatible.get(0) + \", and \" +", "+                                         compatible.get(1));", "+    }", "+    else {", "+      return compatible.get(0);", "+    }", "+  ", "+  } // end method: lookupMethod "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1ba353b16fab3df8c7f5594cde8e220", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/util/ReflectionUtilities.java", "commitBeforeChange": "1ef951d20d276f3c46e1cf20ba51ab4b6ce00f53", "commitAfterChange": "fe7c222597b4c2632fd01caf1fa72f992186277e", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "   public static Constructor lookupConstructor(Class cl, Class [] ac)     throws NoSuchMethodException", "signatureAfterChange": "   public static Constructor lookupConstructor(Class cl, Class [] ac)     throws NoSuchMethodException", "diff": ["-    List<Constructor> ms = getConstructors(cl, ac.length);", "-    List<Constructor> mm = new LinkedList<Constructor>();", "+    List<Constructor> all = getConstructors(cl, ac.length);", "+    List<Constructor> compatible = new LinkedList<Constructor>();", "-    // Search for the constructors with good parameter types and", "-    // put them in 'mm'", "-    Iterator<Constructor> it = ms.iterator();", "+    // Search for the methods with good parameter types and", "+    // put them in 'compatible'", "+    Iterator<Constructor> it = all.iterator();", "-      Constructor m = it.next();", "-      if (hasCompatibleSignatures(m.getParameterTypes(), ac)) {", "-        mm.add(m);", "+      Constructor c = it.next();", "+      if (hasCompatibleSignatures(c.getParameterTypes(), ac)) {", "+        compatible.add(c);", "-    if (mm.isEmpty()) {", "-      boolean compatibleVersion = Float.valueOf(System.getProperty(\"java.specification.version\")) >= 1.5;", "-      ", "-      // Autoboxing handled in the isCompatible method called by the hasVarArgsCompatibleSignatures method", "-      ", "-      // Do second pass for finding a varargs method that matches given method call", "-      ", "-      ms = getVarArgsConstructors(cl, ac.length);", "-      ", "-      // Search for the methods with good parameter types and", "-      // put them in 'mm'", "-      it = ms.iterator();", "-      while (it.hasNext()) {", "-        Constructor m = it.next();", "-        if (hasVarArgsCompatibleSignatures(m.getParameterTypes(), ac)) {", "-          if (!compatibleVersion) {", "-            throw new WrongVersionException(\"Variable arguments are only supported in Java 1.5 or better\");", "-          }", "-          mm.add(m);", "-        }", "-      }", "-      ", "-      if(mm.isEmpty()){", "-        throw new NoSuchMethodException(cl.getName()+\" constructor\");", "-      }", "+    // Select the most specific method if any were found", "+    if (!compatible.isEmpty()) {", "+      return selectTheMostSpecificConstructor(compatible);", "-    // Select the most specific constructor", "-    it = mm.iterator();", "-    Constructor result = it.next();", "+    // Do a second pass to search for methods with autoboxing", "+    it = all.iterator();", "-      result = selectTheMostSpecificConstructor(result, it.next());", "+      Constructor c = it.next();", "+      TigerUsage tu = new TigerUsage();", "+      if (hasAutoBoxingCompatibleSignatures(c.getParameterTypes(), ac, tu)) {", "+        tu.checkForCompatibleUsage();", "+        compatible.add(c);", "+      }", "+    }", "+      ", "+    if (!compatible.isEmpty()) {", "+      return selectTheMostSpecificBoxingConstructor(compatible);", "-    return result;", "+    // Do third pass for finding a varargs method that matches given method call", "+    ", "+    it = all.iterator();", "+    while (it.hasNext()) {", "+      Constructor c = it.next();", "+      TigerUsage tu = new TigerUsage();", "+      if (hasVarArgsCompatibleSignatures(c.getParameterTypes(), ac, tu)) {", "+        tu.checkForCompatibleUsage();", "+        compatible.add(c);", "+      }", "+    }", "+    ", "+    if(compatible.isEmpty()){", "+      throw new NoSuchMethodException(generateNotFoundMsg(\"constructor\", cl.getName(), ac));", "+    }", "+    else if (compatible.size() > 1) {", "+      // It is ambiguous if more than one variable-argument ", "+      // method matches the given parameter type list.", "+      throw new AmbiguousMethodException(\"both methods match: \" + ", "+                                         compatible.get(0) + \", and \" +", "+                                         compatible.get(1));", "+    }", "+    else {", "+      return compatible.get(0);", "+    }"]}], "num": 27680}