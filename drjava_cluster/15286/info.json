{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c622899259b1f9bf284e864f8a84dc50", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a9bd3eff9f0d994097626d3227aca92a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 371, "methodNumberAfterChange": 283, "signatureBeforeChange": "   private <T> Iterable<? extends T>     lookupMember(Type t, final Set<Type> alreadyChecked,                  TypeVisitor<? extends Iterable<? extends T>> baseCase,                   final TypeVisitor<? extends Iterable<? extends T>> recursiveBaseCase)", "signatureAfterChange": "          protected Iterable<T> declaredMatches(Type t)", "diff": ["+    ", "+    protected Iterable<T> declaredMatches(Type t) {", "+      Iterable<T> result = t.apply(new TypeAbstractVisitor<Iterable<T>>() {", "+        private boolean matches(DJField f) {", "+          return f.declaredName().equals(_name) && !(_onlyStatic && !f.isStatic());", "+        }", "+        @Override public Iterable<T> defaultCase(Type t) { return IterUtil.empty(); }", "+        @Override public Iterable<T> forArrayType(ArrayType t) {", "+          if (_name.equals(\"length\") && !_onlyStatic) {", "+            return IterUtil.make(makeFieldReference(t, ArrayLengthField.INSTANCE));", "+          }", "+          else { return IterUtil.empty(); }", "+        }", "+        @Override public Iterable<T> forClassType(ClassType t) {", "+          for (DJField f : t.ofClass().declaredFields()) {", "+            if (matches(f)) { return IterUtil.make(makeFieldReference(t, f)); }", "+          }", "+          return IterUtil.empty();", "+        }", "+      });", "+      return result;", "+    }", "-   */", "-  private <T> Iterable<? extends T>", "-    lookupMember(Type t, final Set<Type> alreadyChecked,", "-                 TypeVisitor<? extends Iterable<? extends T>> baseCase, ", "-                 final TypeVisitor<? extends Iterable<? extends T>> recursiveBaseCase) {", "-    debug.logStart(\"t\", wrap(t)); try {", "-      ", "-    if (alreadyChecked.contains(t)) { return IterUtil.empty(); }", "-    ", "-    final Iterable<? extends T> baseResult = t.apply(baseCase);", "-    alreadyChecked.add(t);", "-    if (!IterUtil.isEmpty(baseResult)) { return baseResult; }", "-    else {", "-      return t.apply(new TypeAbstractVisitor<Iterable<? extends T>>() {", "-        ", "-        public Iterable<? extends T> defaultCase(Type t) { return baseResult; }", "-        ", "-        @Override public Iterable<? extends T> forArrayType(ArrayType t) {", "-          return lookupMember(CLONEABLE_AND_SERIALIZABLE, alreadyChecked, recursiveBaseCase, recursiveBaseCase);", "-        }", "-        ", "-        @Override public Iterable<? extends T> forSimpleClassType(SimpleClassType t) {", "-          Type superT = immediateSupertype(t);", "-          if (superT == null) { return baseResult; }", "-          else { return lookupMember(superT, alreadyChecked, recursiveBaseCase, recursiveBaseCase); }", "-        }", "-        ", "-        @Override public Iterable<? extends T> forRawClassType(RawClassType t) {", "-          Type superT = immediateSupertype(t);", "-          if (superT == null) { return baseResult; }", "-          else { return lookupMember(superT, alreadyChecked, recursiveBaseCase, recursiveBaseCase); }", "-        }", "-        ", "-        @Override public Iterable<? extends T> forParameterizedClassType(ParameterizedClassType t) {", "-          Type superT = immediateSupertype(t);", "-          if (superT == null) { return baseResult; }", "-          else { return lookupMember(superT, alreadyChecked, recursiveBaseCase, recursiveBaseCase); }", "-        }", "-        ", "-        @Override public Iterable<? extends T> forVariableType(VariableType t) {", "-          return lookupMember(t.symbol().upperBound(), alreadyChecked, recursiveBaseCase, recursiveBaseCase);", "-        }", "-        ", "-        @Override public Iterable<? extends T> forIntersectionType(IntersectionType t) {", "-          Iterable<? extends T> result = IterUtil.empty();", "-          for (Type tSup : t.ofTypes()) {", "-            Iterable<? extends T> forSup = lookupMember(tSup, alreadyChecked, recursiveBaseCase, ", "-                                                        recursiveBaseCase);", "-            result = IterUtil.compose(result, forSup);", "-          }", "-          return result;", "-        }", "-        ", "-      });", "-    }", "-    ", "-    } finally { debug.logEnd(); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d52e7332081d56d09df2bec079ecb38a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "be902882edd6ee8f5b7260e86997569bf07255e2", "commitAfterChange": "ead43466202abb204c90f7ee2c316fec230d4415", "methodNumberBeforeChange": 161, "methodNumberAfterChange": 173, "signatureBeforeChange": "   public Pair<Expression, Expression> binaryPromote(final Expression e1, final Expression e2)      throws UnsupportedConversionException", "signatureAfterChange": "   public Pair<Expression, Expression> binaryPromote(final Expression e1, final Expression e2)      throws UnsupportedConversionException", "diff": ["-    Pair<Expression, Expression> result =", "-      join(t1, t2).apply(new TypeAbstractVisitor<Pair<Expression, Expression>>() {", "-      public Pair<Expression, Expression> defaultCase(Type commonT) {", "-        if (!(t1 instanceof NumericType) || !(t2 instanceof NumericType)) {", "-          return null;", "-        }", "-        else { throw new IllegalArgumentException(\"Unexpected join result\"); }", "+    final Type t1Promoted = t1.apply(new TypeAbstractVisitor<Type>() {", "+      @Override public Type defaultCase(Type t) { return null; }", "+      @Override public Type forNumericType(NumericType t) { return INT; }", "+      @Override public Type forFloatingPointType(FloatingPointType t) { return t; }", "+      @Override public Type forLongType(LongType t) { return t; }", "+    });", "+    if (t1Promoted == null) { throw new UnsupportedConversionException(); }", "+    final Type promoted = t2.apply(new TypeAbstractVisitor<Type>() {", "+      @Override public Type defaultCase(Type t) { return null; }", "+      @Override public Type forNumericType(NumericType t) { return t1Promoted; }", "+      @Override public Type forDoubleType(DoubleType t) { return t; }", "+      @Override public Type forFloatType(FloatType t) {", "+        return (t1Promoted instanceof DoubleType) ? t1Promoted : t;", "-      ", "-      @Override public Pair<Expression, Expression> forDoubleType(DoubleType commonT) {", "-        return Pair.make(t1 instanceof DoubleType ? e1 :makeCast(DOUBLE, e1),", "-                         t2 instanceof DoubleType ? e2 : makeCast(DOUBLE, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forFloatType(FloatType commonT) {", "-        return Pair.make(t1 instanceof FloatType ? e1 : makeCast(FLOAT, e1),", "-                         t2 instanceof FloatType ? e2 : makeCast(FLOAT, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forLongType(LongType commonT) {", "-        return Pair.make(t1 instanceof LongType ? e1 : makeCast(LONG, e1),", "-                         t2 instanceof LongType ? e2 : makeCast(LONG, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forIntType(IntType commonT) {", "-        return Pair.make(t1 instanceof IntType ? e1 : makeCast(INT, e1),", "-                         t2 instanceof IntType ? e2 : makeCast(INT, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forShortType(ShortType commonT) {", "-        return Pair.make(makeCast(INT, e1), makeCast(INT, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forByteType(ByteType commonT) {", "-        return Pair.make(makeCast(INT, e1), makeCast(INT, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forCharType(CharType commonT) {", "-        return Pair.make(makeCast(INT, e1), makeCast(INT, e2));", "+      @Override public Type forLongType(LongType t) {", "+        return (t1Promoted instanceof FloatingPointType) ? t1Promoted : t;", "-    if (result == null) { throw new UnsupportedConversionException(); }", "-    else { return result; }", "+    if (promoted == null) { throw new UnsupportedConversionException(); }", "+    ", "+    return Pair.make(t1.equals(promoted) ? e1 : makeCast(promoted, e1),", "+                     t2.equals(promoted) ? e2 : makeCast(promoted, e2));"]}], "num": 15286}