{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9bd13a9c8db256d83155118f303525be", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "05626f7f8c329756a429cfc4a619064c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/indent/QuestionCurrLineStartsWithSkipComments.java", "commitBeforeChange": "7800062ae81518c3396891f7a26a405437cbcbf7", "commitAfterChange": "b552f36a1d45e65c0515c4425e1954dc75014315", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "   boolean applyRule(AbstractDJDocument doc, Indenter.IndentReason reason)", "signatureAfterChange": "   boolean applyRule(AbstractDJDocument doc, Indenter.IndentReason reason)", "diff": ["-    try {", "-      // Find the first non-whitespace character on the current line.", "-      ", "-      int origPos = doc.getCurrentLocation();", "-      int startPos   = doc._getLineFirstCharPos(origPos);", "-      int endPos     = doc._getLineEndPos(origPos);", "-      int lineLength = endPos - startPos;", "-      int prefixLen = _prefix.length();", "-      ", "-      char prevChar = '\\0';", "-      String text = doc.getText(startPos, lineLength);", "-      ", "-//      System.err.println(\"line is: '\" + text + \"'\");", "-      ", "-      doc._setCurrentLocation(startPos);", "-      try { ", "-        for (int i = 0; i < lineLength; i++, doc._move(1)) {", "-          ", "-          ReducedModelState state = doc._getStateAtCurrent();", "-          ", "-          if (state.equals(INSIDE_BLOCK_COMMENT)) {  // Handle case: ...*/*", "-            assert prevChar == '\\0'; ", "-            continue;", "-          }", "-          char currentChar = text.charAt(i);", "-//          System.err.println(\"Iteration \" + i + \": ch = \" + currentChar + \" prevCh = \" + prevChar);", "-          ", "-          if (currentChar == '/') {", "-            if (prevChar == '/') return false;  // opened a LINE_COMMENT", "-            if (prevChar == '\\0') {", "-              prevChar = currentChar;", "-              continue;     // leading char in line is '/'", "-            }", "-          }", "-          else if (currentChar == '*' && prevChar == '/') { // opened a BLOCK_COMMENT, subsequent chars will be inside", "-            prevChar = '\\0';", "-            continue;      ", "-          }", "-          else if (currentChar == ' ' || currentChar == '\\t') {  ", "-            if (prevChar == '\\0') {", "-              continue;  // consume opening whitespace", "-            }", "-          }", "-          return text.startsWith(_prefix, i);   // special cases have already been eliminated", "+    // Find the first non-whitespace character on the current line.", "+    ", "+    int origPos = doc.getCurrentLocation();", "+    int startPos   = doc._getLineFirstCharPos(origPos);", "+    int endPos     = doc._getLineEndPos(origPos);", "+    int lineLength = endPos - startPos;", "+    int prefixLen = _prefix.length();", "+    ", "+    char prevChar = '\\0';", "+    String text = doc._getText(startPos, lineLength);", "+//    System.err.println(\"line is: '\" + text + \"'\");", "+    ", "+    doc._setCurrentLocation(startPos);", "+    try { ", "+      for (int i = 0; i < lineLength; i++, doc.move(1)) {", "+        ", "+        ReducedModelState state = doc._getStateAtCurrent();", "+        ", "+        if (state.equals(INSIDE_BLOCK_COMMENT)) {  // Handle case: ...*/*", "+          assert prevChar == '\\0'; ", "+          continue;", "+        char currentChar = text.charAt(i);", "+//        System.err.println(\"Iteration \" + i + \": ch = \" + currentChar + \" prevCh = \" + prevChar);", "+        ", "+        if (currentChar == '/') {", "+          if (prevChar == '/') return false;  // opened a LINE_COMMENT", "+          if (prevChar == '\\0') {", "+            prevChar = '/';", "+            continue;     // leading char in line is '/'", "+          }", "+        }", "+        else if (currentChar == '*' && prevChar == '/') { // opened a BLOCK_COMMENT, subsequent chars will be inside", "+          prevChar = '\\0';", "+          continue;      ", "+        }", "+        else if (currentChar == ' ' || currentChar == '\\t') {  ", "+          if (prevChar == '\\0') {", "+            continue;  // consume opening whitespace", "+          }", "+        }", "+        return text.startsWith(_prefix, i);   // special cases have already been eliminated", "-      finally { doc._setCurrentLocation(origPos); }", "-    catch (BadLocationException e) {", "-      // Control flow should never reach this point!", "-      throw new UnexpectedException(new RuntimeException(\"Bug in QuestionCurrLineStartsWithSkipComments\"));", "-    }", "+    finally { doc._setCurrentLocation(origPos); }", "+    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0be2f3cddac28e13e6613167a6e836d0", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/indent/QuestionCurrLineStartsWithSkipComments.java", "commitBeforeChange": "de9f1fb322a5a5fa0f403e2f2803a6e71b1430f2", "commitAfterChange": "d866156ff3eb9397e3a97a5afc2e43aedd357f8a", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "   boolean applyRule(AbstractDJDocument doc, Indenter.IndentReason reason)", "signatureAfterChange": "   boolean applyRule(AbstractDJDocument doc, Indenter.IndentReason reason)", "diff": ["-      int currentPos = doc.getCurrentLocation(),", "-        startPos   = doc.getLineFirstCharPos(currentPos),", "-        endPos     = doc.getLineEndPos(currentPos),", "-        lineLength = endPos - startPos;", "+      int origPos = doc.getCurrentLocation();", "+      int startPos   = doc.getLineFirstCharPos(origPos);", "+      int endPos     = doc.getLineEndPos(origPos);", "+      int lineLength = endPos - startPos;", "+      int prefixLen = _prefix.length();", "-      char currentChar, previousChar = '\\0';", "+      char prevChar = '\\0';", "-      for (int i = 0; i < lineLength; i++) {", "-        // Get state for walker position.", "-        ", "-        doc.move( startPos - currentPos + i);", "-        ReducedModelState state = doc.getStateAtCurrent();", "-        doc.move(-startPos + currentPos - i);", "-        ", "-        ", "-        currentChar = text.charAt(i);", "-        ", "-        if (state.equals(INSIDE_LINE_COMMENT)) return false;", "-        if (state.equals(INSIDE_BLOCK_COMMENT)) {  // Handle case: ...*/*", "-          previousChar = '\\0'; ", "-          continue;", "-        }", "-        if (state.equals(FREE)) { // Can prefix still fit on the current line?", "-          if (_prefix.length() > lineLength - i) return false;", "-          else if (text.substring(i, i+_prefix.length()).equals(_prefix) && previousChar != '/') {", "-            // '/' is the only non-WS character that we consume without", "-            // immediately returning false. When we try to match the prefix,", "-            // we also need to reflect this implicit lookahead mechanism.", "-            return true;", "+//      System.err.println(\"line is: '\" + text + \"'\");", "+      ", "+      doc.setCurrentLocation(startPos);", "+      try { ", "+        for (int i = 0; i < lineLength; i++, doc.move(1)) {", "+          ", "+          ReducedModelState state = doc.getStateAtCurrent();", "+          ", "+          if (state.equals(INSIDE_BLOCK_COMMENT)) {  // Handle case: ...*/*", "+            assert prevChar == '\\0'; ", "+            continue;", "-          else if (currentChar == '/') {", "-            if (previousChar == '/') return false;", "+          char currentChar = text.charAt(i);", "+//          System.err.println(\"Iteration \" + i + \": ch = \" + currentChar + \" prevCh = \" + prevChar);", "+          ", "+          if (currentChar == '/') {", "+            if (prevChar == '/') return false;  // opened a LINE_COMMENT", "+            if (prevChar == '\\0') {", "+              prevChar = currentChar;", "+              continue;     // leading char in line is '/'", "+            }", "-          else if (currentChar == ' ' || currentChar == '\\t') {  }", "-          else if (!(currentChar == '*' && previousChar == '/')) return false;", "+          else if (currentChar == '*' && prevChar == '/') { // opened a BLOCK_COMMENT, subsequent chars will be inside", "+            prevChar = '\\0';", "+            continue;      ", "+          }", "+          else if (currentChar == ' ' || currentChar == '\\t') {  ", "+            if (prevChar == '\\0') {", "+              continue;  // consume opening whitespace", "+            }", "+          }", "+          return text.startsWith(_prefix, i);   // special cases have already been eliminated", "-        if (previousChar == '/' && currentChar != '*') return false;", "-        previousChar = currentChar;", "-      return false;", "+      finally { doc.setCurrentLocation(origPos); }", "+    return false;"]}], "num": 1155}