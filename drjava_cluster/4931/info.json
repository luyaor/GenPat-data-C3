{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7fcd5e01df183f7d3e92c26ef004f8e4", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53a9893ed07c9904a26a97fecfe9ae7b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/jpda/JPDADebugger.java", "commitBeforeChange": "5293cb4cfbc2f45d6061ba4101ad60348aa251ed", "commitAfterChange": "f68f43e5a680bb235f87f6125c6c0de6d15a12f4", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 68, "signatureBeforeChange": "   private void _dumpVariablesIntoInterpreterAndSwitch() throws DebugException, AbsentInformationException", "signatureAfterChange": "   private void _dumpVariablesIntoInterpreterAndSwitch() throws DebugException", "diff": ["-  private void _dumpVariablesIntoInterpreterAndSwitch() throws DebugException, AbsentInformationException {", "+  private void _dumpVariablesIntoInterpreterAndSwitch() throws DebugException {", "+    List<ObjectReference> toRelease = new LinkedList<ObjectReference>();", "-      ThreadReference suspendedThreadRef = _suspendedThreads.peek();", "-      StackFrame frame = suspendedThreadRef.frame(0);", "-      Location l = frame.location();", "-      ReferenceType rt = l.declaringType();", "-      String className = rt.name();", "+      ThreadReference thread = _suspendedThreads.peek();", "-      String interpreterName = _getUniqueThreadName(suspendedThreadRef);", "-      // TODO: allow creation of the appropriate context for the new interpreter", "-      _model.getInteractionsModel().addInterpreter(interpreterName);", "-      ObjectReference debugInterpreter = _getDebugInterpreter();", "-      _log.log(this + \" executing: frame = suspendedThreadRef.frame(0);\");", "-      frame = suspendedThreadRef.frame(0);", "-", "-      List<LocalVariable> vars = frame.visibleVariables();  // JDK 1.5 will eliminate this warning", "-      Iterator<LocalVariable> varsIterator = vars.iterator();", "-", "-      _log.log(this + \" got visibleVariables\");", "-", "-      // Define each variable", "-      while(varsIterator.hasNext()) {", "-        LocalVariable localVar = varsIterator.next();", "-        _log.log(this + \" defined local variable: \" + localVar);", "-        // Have to update the frame each time", "-        frame = suspendedThreadRef.frame(0);", "-        Value val = frame.getValue(localVar);", "-        Type type;", "-        if (val != null) {", "-          type = val.type();", "-        }", "-        else {", "+      String interpreterName = _getUniqueThreadName(thread);", "+      ObjectReference mirroredName = _mirrorString(interpreterName, toRelease);", "+      ObjectReference thisVal = thread.frame(0).thisObject();", "+      ClassObjectReference thisClass = thread.frame(0).location().declaringType().classObject();", "+      ", "+      List<ObjectReference> localVars = new LinkedList<ObjectReference>();", "+      List<StringReference> localVarNames = new LinkedList<StringReference>();", "+      List<ClassObjectReference> localVarClasses = new LinkedList<ClassObjectReference>();", "+      try {", "+        // we don't store the value thread.frame(0) anywhere, because it is invalidated", "+        // each time we invoke a method in thread (as in _box)", "+        for (LocalVariable v : thread.frame(0).visibleVariables()) {", "-            type = localVar.type();", "-          }", "-          catch(ClassNotLoadedException e) {", "-            List<ReferenceType> classes = _vm.classesByName(localVar.typeName());  //JDK 1.5 will eliminate this warning", "-            if (!classes.isEmpty()) {", "-              type = classes.get(0);", "+            // Get the type first, so that if an error occurs, we haven't mutated the lists.", "+            Type t = v.type();", "+            if (t instanceof ReferenceType) {", "+              localVarClasses.add(((ReferenceType) t).classObject());", "-              type = null;", "+              // primitive types are represented by null", "+              localVarClasses.add(null);", "+            localVarNames.add(_mirrorString(v.name(), toRelease));", "+            Value val = thread.frame(0).getValue(v);", "+            if (val == null || val instanceof ObjectReference) { localVars.add((ObjectReference) val); }", "+            else { localVars.add(_box((PrimitiveValue) val, thread, toRelease)); }", "+          }", "+          catch (ClassNotLoadedException e) {", "+            // This is a real possibility, as documented in the ClassNotLoadedException", "+            // javadocs.  We'll just ignore the exception, treating the variable as", "+            // out-of-scope, since we can't talk about values of its type.", "-        _defineVariable(suspendedThreadRef, debugInterpreter,", "-                        localVar.name(), val, type);", "-", "-      // Update the frame", "-      frame = suspendedThreadRef.frame(0);", "-", "-      // Define \"this\"", "-      Value thisVal = frame.thisObject();", "-      if (thisVal != null) {", "-        _defineVariable(suspendedThreadRef, debugInterpreter,", "-                        \"this\", thisVal, thisVal.type());", "-        //_setThisInInterpreter(suspendedThreadRef, debugInterpreter, thisVal);", "-      }", "-", "+      catch (AbsentInformationException e) { /* ignore -- we just won't include any local variables */ }", "+      ArrayReference mirroredVars = _mirrorArray(\"java.lang.Object\", localVars, thread, toRelease);", "+      ArrayReference mirroredVarNames = _mirrorArray(\"java.lang.String\", localVarNames, thread, toRelease);", "+      ArrayReference mirroredVarClasses = _mirrorArray(\"java.lang.Class\", localVarClasses, thread, toRelease);", "+      ", "+      _invokeMethod(thread, _interpreterJVM, \"addInterpreter\", ADD_INTERPRETER_SIG,", "+                    mirroredName, thisVal, thisClass, mirroredVars, mirroredVarNames, mirroredVarClasses);", "+    ", "-      String prompt = _getPromptString(suspendedThreadRef);", "+      String prompt = _getPromptString(thread);", "-    catch(InvalidTypeException exc) {", "-      throw new DebugException(exc.toString());", "-    }", "-    catch(IncompatibleThreadStateException e2) {", "-      throw new DebugException(e2.toString());", "-    }", "-    catch(ClassNotLoadedException e3) {", "-      throw new DebugException(e3.toString());", "-    }", "-    catch(InvocationException e4) {", "-      throw new DebugException(e4.toString());", "+    catch (IncompatibleThreadStateException e) { throw new DebugException(e); }", "+    finally {", "+      for (ObjectReference ref : toRelease) { ref.enableCollection(); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b5aaa3d121b1e1419be1d269ebfb99d5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/util/ReflectionUtilities.java", "commitBeforeChange": "1ef951d20d276f3c46e1cf20ba51ab4b6ce00f53", "commitAfterChange": "fe7c222597b4c2632fd01caf1fa72f992186277e", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 8, "signatureBeforeChange": "   public static List<Method> getVarArgsMethods(Class cl, String name, int params)", "signatureAfterChange": "   protected static Method selectTheMostSpecificMethod(List<Method> list)", "diff": ["-   */", "-  public static List<Method> getVarArgsMethods(Class cl, String name, int params) {", "-    List<Method>  result = new LinkedList<Method>();", "-    ", "-    if (cl.isInterface()) {", "-      Method[] ms = cl.getDeclaredMethods();", "-      for (int i = 0; i < ms.length; i++) {", "-        if (ms[i].getName().equals(name) &&", "-            ms[i].isVarArgs() &&  // Use new 1.5 API", "-            ms[i].getParameterTypes().length <= params) {", "-          result.add(ms[i]);", "-        }", "-      }", "-      Class[] cs = cl.getInterfaces();", "-      for (int i = 0; i < cs.length; i++) {", "-        result.addAll(getVarArgsMethods(cs[i], name, params));", "-      }", "-      if (cs.length == 0) {", "-        result.addAll(getVarArgsMethods(Object.class, name, params));", "-      }", "-    } ", "-              ms[i].isVarArgs() &&  // Use new 1.5 API", "-              ms[i].getParameterTypes().length <= params) {", "+  protected static Method selectTheMostSpecificMethod(List<Method> list) {", "+    if (list.isEmpty()) return null;", "+    Iterator<Method> it = list.iterator();", "+    Method best = it.next();", "+    Method ambiguous = null; // there is no ambiguous other method at first", "+    while (it.hasNext()) {", "+      Method curr = it.next();", "+      Class[] a1 = best.getParameterTypes();", "+      Class[] a2 = curr.getParameterTypes();", "+      ", "+      boolean better1 = false; // whether 'best' is better than 'curr'", "+      boolean better2 = false; // whether 'curr' is better than 'best'", "+      for (int i = 0; i < a1.length; i++) {", "+        boolean from2to1 = isCompatible(a1[i], a2[i]);", "+        boolean from1to2 = isCompatible(a2[i], a1[i]);", "+        ", "+        if (from1to2 && !from2to1) {// best's parameter[i] is more specific than curr's", "+          better1 = true; // so best is better than curr", "+        }", "+        if (from2to1 && !from1to2) {// curr's parameter[i] is more specific than best's", "+          better2 = true; // so curr is better than best", "+        }", "+      }", "+      ", "+      // decide which is more specific or whether they are ambiguous", "+      if ( !(better1 ^ better2) ) { // neither is better than the other", "+        // Handle overridden methods", "+        if (Arrays.equals(a1, a2)) {", "+          Class c1 = best.getDeclaringClass();", "+          Class c2 = curr.getDeclaringClass();", "+          boolean c1IsSuperOrSame = c1.isAssignableFrom(c2);", "+          boolean c2IsSuperOrSame = c2.isAssignableFrom(c1);", "+          if (c1IsSuperOrSame && !c2IsSuperOrSame) { // c2 is more specific", "+            best = curr;", "+            continue;", "+          }", "+          else if (c2IsSuperOrSame && !c1IsSuperOrSame) { // c1 is more specific", "+            continue;", "+          }", "+        }", "+        ambiguous = curr;", "+      }", "+      else if (better2) {", "+        best = curr;", "+        ambiguous = null; // no more ambiguity", "+    if (ambiguous != null) {", "+      throw new AmbiguousMethodException(\"Both methods match: \" + best + \", and \" + ambiguous);", "+    }", "+    return best;"]}], "num": 4931}