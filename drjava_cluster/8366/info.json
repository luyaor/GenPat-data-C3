{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ef4351897aa529d74380a4e9d0f61ba5", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4eeb6d8e64ce239f32429bf8c8c4d05a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/DefinitionsPaneTest.java", "commitBeforeChange": "7363b79c6228b3bbffbaa22283c3045a27a3cedc", "commitAfterChange": "74a15c017d574b2ee2a0cdeaaedeea00825a0c5e", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "   public void testMultilineCommentOrUncommentAfterScroll() throws BadLocationException", "signatureAfterChange": "   public void testMultilineCommentOrUncommentAfterScroll() throws BadLocationException", "diff": ["-    String commented =", "+    final String commented =", "-    final int newPos = 20;", "-    ", "-    // The following statement hung when run in the main test thread.  There must be a pending access to doc in a", "-    // task on the event queue that sometimes has not yet executed.", "-    ", "-    Utilities.invokeAndWait(new Runnable() { public void run() { doc.append(text, null); } });", "-    Utilities.clearEventQueue();", "-    ", "-    assertEquals(\"insertion\", text, doc.getText());", "-    // I can't run the test here because I'm not sure how to select the text so that we can comment it.", "-", "-    Utilities.invokeAndWait(new Runnable() { public void run() { pane.endCompoundEdit(); } });", "-     ", "-    doc.acquireWriteLock();", "-    try { doc.commentLines(0, doc.getLength()); }", "-    finally { doc.releaseWriteLock(); }", "-    ", "-    //    pane.endCompoundEdit();", "-    assertEquals(\"commenting\", commented, doc.getText());", "-    ", "-    int oldPos = pane.getCaretPosition();", "+    // I can't run the test here because I'm not sure how to select the text so that we can comment it", "-        pane.setCaretPosition(newPos); ", "-        _frame.validate();", "-      } ", "+        doc.append(text, null);", "+        assertEquals(\"insertion\", text, doc.getText());", "+//        System.err.println(\"Compound? \" + pane._inCompoundEdit);", "+//        System.err.println(\"After append, loc = \" + doc.getCurrentLocation());", "+        pane.endCompoundEdit();", "+        doc.commentLines(0, doc.getLength()); ", "+", "+        assertEquals(\"commenting\", commented, doc.getText());", "+        int newPos = doc.getCurrentLocation();", "+//        System.err.println(\"newPos = \" + newPos);", "+", "+        doc.getUndoManager().undo(); ", "+//        System.err.println(\"cursor pos = \" + doc.getCurrentLocation());", "+//        int pos = doc.getCurrentLocation();", "+        assertEquals(\"undo commenting\", text, doc.getText());", "+//        System.err.println(\"cursor pos = \" + pos + \"\\n\");", "+//        // doc.commentLines moves the cursor to 0 before inserting wing comment chars", "+//", "+//        assertTrue(\"dummy test\", true);", "+//        System.err.println(\"undone text = '\" + doc.getText() + \"'\");", "+//        assertTrue(\"dummy test\", true);", "+", "+        assertEquals(\"undoing commenting restores cursor position\", 0, doc.getCurrentLocation());", "+        ", "+        doc.getUndoManager().redo();", "+        assertEquals(\"redo commenting\", commented, doc.getText());", "+        assertEquals(\"redoing commenting restores cursor position\", newPos, doc.getCurrentLocation());", "+", "+        pane.endCompoundEdit(); ", "+        doc.uncommentLines(0, doc.getLength()); ", "+        assertEquals(\"uncommenting\", text, doc.getText());", "+", "+        _redoPos = doc.getCurrentLocation();  ", "+    ", "+        doc.getUndoManager().undo();", "+        ", "+      } });", "+    ", "+    // undo may spawn new events that fix up the value of _currentLocation; must break our of invokeAndWait to let", "+    // them execute", "+", "+    Utilities.invokeAndWait(new Runnable() {", "+      public void run() {", "+        ", "+//        System.err.println(\"cursor pos = \" + doc.getCurrentLocation());", "+    ", "+        assertEquals(\"undo uncommenting\", commented, doc.getText());", "+//        System.err.println(\"cursor pos = \" + doc.getCurrentLocation());", "+", "+        // doc.uncommentLines moves the cursor to 0 before removing the wing comment chars", "+        assertEquals(\"undoing uncommenting restores cursor position\", 0, doc.getCurrentLocation());", "+    ", "+        doc.getUndoManager().redo();", "+        assertEquals(\"redo uncommenting\",text, doc.getText());", "+        assertEquals(\"redoing uncommenting restores cursor position\", _redoPos, doc.getCurrentLocation());", "+                                                        ", "+//        fail(\"print System.err\");", "+      }", "-    Utilities.clearEventQueue();", "-    ", "-    doc.getUndoManager().undo();  ", "-    assertEquals(\"undo commenting\", text, doc.getText());", "-    assertEquals(\"undoing commenting restores caret position\", oldPos, pane.getCaretPosition());", "-    ", "-    // Perturb the caret position and redo", "-    Utilities.invokeAndWait(new Runnable() { public void run() { pane.setCaretPosition(newPos); } });", "-    Utilities.clearEventQueue();", "-    ", "-    doc.getUndoManager().redo();", "-    assertEquals(\"redo commenting\", commented, doc.getText());", "-    assertEquals(\"redoing commenting restores caret position\", oldPos, pane.getCaretPosition());", "-    ", "-    // Need to do this here since the commentLines action in MainFrame usually takes care of this.  ", "-    // I can't simulate a keystroke here because I'm not sure how to select the text so that we can comment it.", "-    Utilities.invokeAndWait(new Runnable() { public void run() { pane.endCompoundEdit(); } });", "-    Utilities.clearEventQueue();", "-    ", "-    doc.acquireWriteLock();", "-    try { doc.uncommentLines(0, doc.getLength()); }", "-    finally { doc.releaseWriteLock(); }", "-    ", "-    //    pane.endCompoundEdit();", "-    assertEquals(\"uncommenting\", text, doc.getText());", "-    ", "-    oldPos = pane.getCaretPosition();  // executing this method call outside of the event thread is borderline", "-    ", "-    Utilities.invokeAndWait(new Runnable() { public void run() { pane.setCaretPosition(newPos);  } });", "-    Utilities.clearEventQueue();", "-    ", "-    doc.getUndoManager().undo();", "-    ", "-    assertEquals(\"undo uncommenting\", commented, doc.getText());", "-    assertEquals(\"undoing uncommenting restores caret position\", oldPos, pane.getCaretPosition());", "-    ", "-    Utilities.invokeAndWait(new Runnable() { public void run() { pane.setCaretPosition(newPos); } });", "-    Utilities.clearEventQueue();", "-    ", "-    doc.getUndoManager().redo();", "-    assertEquals(\"redo uncommenting\",text, doc.getText());", "-    assertEquals(\"redoing uncommenting restores caret position\", oldPos, pane.getCaretPosition());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dc024bf0dc906173b90a85a333f3fae3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/junit/JUnitTestManager.java", "commitBeforeChange": "771a0aee635c62bc6d0a2000fe605dc1113ef2b9", "commitAfterChange": "d1e56ac5c281c4b03c498f59138895f0f26350fa", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public List<String> runTest(final List<String> classNames, final List<File> files,                               final boolean isTestAll)", "signatureAfterChange": "   public synchronized boolean runTestSuite()", "diff": ["-  public List<String> runTest(final List<String> classNames, final List<File> files,", "-                              final boolean isTestAll) {", "-    final ArrayList<String> testClassNames = new ArrayList<String>();", "-    synchronized (testClassNames) {", "-      _testRunner = new JUnitTestRunner(_jmc);", "-      new Thread(\"JUnit Test Thread\") {", "-        public void run() {", "-          try {", "-            boolean noJUnitTests = true;", "-            TestSuite suite = new TestSuite();", "-            synchronized (testClassNames) {", "-              try {", "-                for (int i = 0; i < classNames.size(); i++) {", "-                  String className = classNames.get(i);", "-                  if (_isTestCase(className)) {", "-                    Test test = _testRunner.getTest(className);", "-                    suite.addTest(test);", "-                    testClassNames.add(className);", "-                    noJUnitTests = false;", "-                  }", "-                }", "-              }", "-              finally { testClassNames.notify(); }", "-            }", "-            if (noJUnitTests) {", "-              _jmc.nonTestCase(isTestAll);", "-              //            _jmc.testSuiteEnded(new JUnitError[] {new JUnitError(null, \"No JUnit tests open!\", false, \"\")});", "-              return;", "-            }", "-            TestResult result = _testRunner.doRun(suite);", "-", "-            JUnitError[] errors = new JUnitError[result.errorCount() + result.failureCount()];", "-", "-            Enumeration failures = result.failures();", "-            Enumeration errEnum = result.errors();", "-", "-            int i = 0;", "-", "-            while (errEnum.hasMoreElements()) {", "-              TestFailure tErr = (TestFailure) errEnum.nextElement();", "-              errors[i] = _makeJUnitError(tErr, classNames, true, files);", "-              i++;", "-            }", "-            while (failures.hasMoreElements()) {", "-              TestFailure tFail = (TestFailure) failures.nextElement();", "-              errors[i] = _makeJUnitError(tFail, classNames, false, files);", "-              i++;", "-            }", "-            _jmc.testSuiteEnded(errors);", "-          }", "-          catch (Throwable t) {", "-            _failedWithError(t);", "-          }", "-        }", "-      }.start();", "-      try {", "-        testClassNames.wait();", "-      }", "-      catch (InterruptedException ex) {", "-    return testClassNames;", "+   */", "+  public synchronized boolean runTestSuite() {", "+    ", "+    if (_testClassNames == null || _testClassNames.isEmpty()) return false;", "+    ", "+//    new ScrollableDialog(null, \"runTestSuite() in SlaveJVM called\", \"\", \"\").show();", "+    try {", "+      TestResult result = _testRunner.doRun(_suite);", "+    ", "+      JUnitError[] errors = new JUnitError[result.errorCount() + result.failureCount()];", "+      ", "+      Enumeration failures = result.failures();", "+      Enumeration errEnum = result.errors();", "+      ", "+      int i = 0;", "+      ", "+      while (errEnum.hasMoreElements()) {", "+        TestFailure tErr = (TestFailure) errEnum.nextElement();", "+        errors[i] = _makeJUnitError(tErr, _testClassNames, true, _testFiles);", "+        i++;", "+      }", "+      ", "+      while (failures.hasMoreElements()) {", "+        TestFailure tFail = (TestFailure) failures.nextElement();", "+        errors[i] = _makeJUnitError(tFail, _testClassNames, false, _testFiles);", "+        i++;", "+      }", "+//      new ScrollableDialog(null, \"Slave JVM: testSuite ended with errors\", \"\", Arrays.toString(errors)).show();", "+      ", "+      _jmc.testSuiteEnded(errors);", "+    }", "+    catch(Throwable t) { ", "+      JUnitError[] errors = new JUnitError[1];", "+      errors[0] = new JUnitError(null, -1, -1, t.getMessage(),", "+                                 false, \"\", \"\", StringOps.getStackTrace(t));", "+      _jmc.testSuiteEnded(errors);", "+       // new ScrollableDialog(null, \"Slave JVM: testSuite ended with errors\", \"\", Arrays.toString(errors)).show();", "+      ", "+    }", "+    finally {", "+      _suite = null;", "+      _testClassNames = null;", "+      _testFiles = null;", "+    }", "+    return true;"]}], "num": 8366}