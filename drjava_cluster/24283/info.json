{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2bc908a814ef939a981c630ff127f306", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "631b645be48cd3ae49bbd1fce8a4fc9d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 14, "signatureBeforeChange": "   private SymbolData _getSymbolData_FromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,                                                    boolean addError)", "signatureAfterChange": "   protected SymbolData _getSymbolDataFromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,                                                     boolean addError)", "diff": ["-  private SymbolData _getSymbolData_FromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,", "-                                                   boolean addError) {", "+  protected SymbolData _getSymbolDataFromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,", "+                                                    boolean addError) {", "-    if (sd != null && (! resolve || ! sd.isContinuation())) { return sd; }", "+    if (sd != null && (! sd.isContinuation() || ! resolve)) return sd;  ", "+    // Note: sd != null && ! sd.isContinuation => sd has already been resolved", "-    // Is qualifiedClassName in _classesToBeParsed, look it up directly in the parsed ASTs", "-    Pair<TypeDefBase, LanguageLevelVisitor> pair = _classesToBeParsed.get(qualifiedClassName);", "-    if (pair != null) return _lookupFromClassesToBeParsed(qualifiedClassName, si, resolve);", "+//    // Is qualifiedClassName in _classesInThisFile, look it up directly in the parsed ASTs", "+//    boolean present = _classesInThisFile.contains(qualifiedClassName);", "+//    if (present) return _identifyTypeFromClassNamesInThisfile(qualifiedClassName, si, resolve);", "-          return new File(path + \".dj0\").getCanonicalFile().equals(f) ||", "+          return new File(path + \".dj\").getCanonicalFile().equals(f) ||", "+            new File(path + \".dj0\").getCanonicalFile().equals(f) ||", "-    // Claim: sourceFile is not the current file.  Otherwise, className would have been in _classNamesInThisFile.", "+//    // Claim: sourceFile is not the current file or sd is an inner class.  Otherwise, className would have been in ", "+//    // _classesInThisFile.", "-        sd = addSymbolData(si, qualifiedClassName); // defer loading class file information", "+        sd = makeContinuation(si, qualifiedClassName); // create a continuation for qualifiedClassName; defer resolution", "-//          continuations.put(qualifiedClassName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));", "+//          continuations.put(qualifiedClassName, ", "+//                            new Triple<SourceInfo, LanguageLevelVisitor, SymbolData>(si, this, sd));", "-    // if source file exists, the corresponding class file is up to date", "+    // if source file exists, confirm that the corresponding class file is up to date", "+    // if source file does not exist, confirm that a class file does exist", "-      sd = _classFile2SymbolData(qualifiedClassName, programRoot);", "+      sd = LanguageLevelConverter._classFile2SymbolData(qualifiedClassName, programRoot);", "-          _addAndIgnoreError(\"File \" + classFile + \" is not a valid class file.\", null);", "+          _addAndIgnoreError(\"File \" + classFile + \" is not a valid class file.\",  new NullLiteral(si));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dcbe4e09344719c501b3997135326ab8", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/util/ReflectionUtilities.java", "commitBeforeChange": "1ef951d20d276f3c46e1cf20ba51ab4b6ce00f53", "commitAfterChange": "fe7c222597b4c2632fd01caf1fa72f992186277e", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 16, "signatureBeforeChange": "   public static boolean isBoxCompatible(Class c1, Class c2, boolean autoBoxEnabled)", "signatureAfterChange": "   public static boolean isBoxCompatible(Class c1, Class c2, TigerUsage tu)", "diff": ["-  }", "-  public static boolean isBoxCompatible(Class c1, Class c2, boolean autoBoxEnabled) {", "+  public static boolean isBoxCompatible(Class c1, Class c2, TigerUsage tu) {", "-        ", "-      if (!c2.isPrimitive() && !autoBoxEnabled) {", "-        // We know autoboxing/unboxing is required but", "-        // the version of java doesn't support it", "-        throw new WrongVersionException(\"Auto-unboxing only supported in Java 1.5 or better\");", "+      if (!c2.isPrimitive()) {", "+        tu.autoBoxingIsUsed();", "+        //        throw new RuntimeException(\"autoboxing used1:\" + tu);", "-      else {", "-        // unbox the second type (may not change)", "-        c2 = _correspondingPrimType(c2);", "-      }", "+      ", "+      // unbox the second type (may not change)", "+      c2 = TigerUtilities.correspondingPrimType(c2);", "+      ", "-        if (!autoBoxEnabled) {", "-           throw new WrongVersionException(\"Auto-boxing/unboxing is only supported in Java 1.5 or better\");", "-        }", "-        c2 = _correspondingBoxingType(c2);", "+        tu.autoBoxingIsUsed();", "+        c2 = TigerUtilities.correspondingBoxingType(c2);", "+        //        throw new RuntimeException(\"autoboxing 2:\" + tu);"]}], "num": 24283}