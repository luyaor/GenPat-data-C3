{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fc65fe5a0b9a3420620a1c4b26d26a47", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1079cc2d085d33336baa41869b389cc5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocument.java", "commitBeforeChange": "8cfaf2efb8ae59b79b9538e0bd5eaf251c6db08b", "commitAfterChange": "b732820bc2f8849bda78001b782e555a753cad1e", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 41, "signatureBeforeChange": "   public String getPackageName() throws InvalidPackageException", "signatureAfterChange": "   public String getPackageName() throws InvalidPackageException", "diff": ["-    // throwErrorHuh();", "-    // Where we'll build up the package name we find", "+    /* Buffer for constructing the package name. */", "+      final int docLength = text.length();", "+      if (docLength == 0) return \"\";", "+      ", "-        int firstNormalLocation;", "-        ", "-        setCurrentLocation(0);", "-        ", "-        final int docLength = text.length();", "-        // The location of the first non-whitespace character that is not inside a string or comment.", "-        firstNormalLocation = 0;", "-        while (firstNormalLocation < docLength) {", "-          setCurrentLocation(firstNormalLocation);", "+        try {", "+          setCurrentLocation(0);", "-          if (_reduced.currentToken().getHighlightState() == HighlightStatus.NORMAL) {", "-            // OK, it's normal -- so if it's not whitespace, we found the spot", "-            char curChar = text.charAt(firstNormalLocation);", "-            if (! Character.isWhitespace(curChar)) break;", "+          /* The location of the first non-whitespace character that is not inside a string or comment. */", "+          int firstNormalLocation = 0;", "+          while (firstNormalLocation < docLength) {", "+            setCurrentLocation(firstNormalLocation);", "+            ", "+            if (_reduced.currentToken().getHighlightState() == HighlightStatus.NORMAL) {", "+              // OK, it's normal -- so if it's not whitespace, we found the spot", "+              char curChar = text.charAt(firstNormalLocation);", "+              if (! Character.isWhitespace(curChar)) break;", "+            }", "+            firstNormalLocation++;", "-          firstNormalLocation++;", "-        }", "-        ", "-        // Now there are two possibilities: firstNormalLocation is at", "-        // the first spot of a non-whitespace character that's NORMAL,", "-        // or it's at the end of the document.", "-        if (firstNormalLocation == docLength) return \"\";", "-        ", "-        final int strlen = \"package\".length();", "-        ", "-        final int endLocation = firstNormalLocation + strlen;", "-        ", "-        if ((firstNormalLocation + strlen > docLength) ||", "-            ! text.substring(firstNormalLocation, endLocation).equals(\"package\")) {", "-          // The first normal text is not \"package\" or there is not enough text for there to be a package statement.", "-          // Thus, there is no valid package statement.", "-          return \"\";", "-        }", "-        ", "-        // OK, we must have found a package statement.", "-        // Now let's find the semicolon. Again, the semicolon must be free.", "-        int afterPackage = firstNormalLocation + strlen;", "-        ", "-        int semicolonLocation = afterPackage;", "-        do {", "-          semicolonLocation = text.indexOf(\";\", semicolonLocation + 1);", "-          if (semicolonLocation == -1)", "+          // Now there are two possibilities: firstNormalLocation is at the first spot of a non-whitespace character ", "+          // that's NORMAL, or it's at the end of the document.", "+          ", "+          if (firstNormalLocation == docLength) return \"\";", "+          ", "+          final int strlen = \"package\".length();", "+          ", "+          final int endLocation = firstNormalLocation + strlen;", "+          ", "+          if ((firstNormalLocation + strlen > docLength) ||", "+              ! text.substring(firstNormalLocation, endLocation).equals(\"package\")) {", "+            // The first normal text is not \"package\" or there is not enough text for there to be a package statement.", "+            // Thus, there is no valid package statement.", "+            return \"\";", "+          }", "+          ", "+          // OK, we must have found a package statement.", "+          // Now let's find the semicolon. Again, the semicolon must be free.", "+          int afterPackage = firstNormalLocation + strlen;", "+          ", "+          int semicolonLocation = afterPackage;", "+          do {", "+            semicolonLocation = text.indexOf(\";\", semicolonLocation + 1);", "+            if (semicolonLocation == -1)", "+              throw new InvalidPackageException(firstNormalLocation,", "+                                                \"No semicolon found to terminate package statement!\");", "+            setCurrentLocation(semicolonLocation);", "+          }", "+          while (_reduced.currentToken().getHighlightState() != HighlightStatus.NORMAL);", "+          ", "+          // Now we have semicolon location. We'll gather text in between one character at a time for simplicity. ", "+          for (int walk = afterPackage + 1; walk < semicolonLocation; walk++) {", "+            setCurrentLocation(walk);", "+            if (_reduced.currentToken().getHighlightState() == HighlightStatus.NORMAL) {", "+              char curChar = text.charAt(walk);", "+              if (! Character.isWhitespace(curChar)) buf.append(curChar);", "+            }", "+          }", "+          ", "+          String toReturn = buf.toString();", "+          if (toReturn.equals(\"\"))", "-                                              \"No semicolon found to terminate package statement!\");", "-          setCurrentLocation(semicolonLocation);", "+                                              \"Package name was not specified after the package keyword!\");", "+          return toReturn;", "-        while (_reduced.currentToken().getHighlightState() != HighlightStatus.NORMAL);", "-        ", "-        // Now we have semicolon location. We'll gather text in between one", "-        // character at a time for simplicity. It's inefficient (I think?)", "-        // but it's easy, and there shouldn't be much text between", "-        // \"package\" and \";\" anyhow.", "-        for (int walk = afterPackage + 1; walk < semicolonLocation; walk++) {", "-          setCurrentLocation(walk);", "-          ", "-          if (_reduced.currentToken().getHighlightState() == HighlightStatus.NORMAL) {", "-            char curChar = text.charAt(walk);", "-            if (! Character.isWhitespace(curChar)) buf.append(curChar);", "-          }", "+        finally { // reset oldLocation", "+          setCurrentLocation(0);  // Why?", "+          setCurrentLocation(oldLocation);", "-        ", "-        String toReturn = buf.toString();", "-        if (toReturn.equals(\"\"))", "-          throw new InvalidPackageException(firstNormalLocation,", "-                                            \"Package name was not specified after the package keyword!\");", "-        return toReturn;", "-    finally {", "-      setCurrentLocation(0);  // Why?", "-      setCurrentLocation(oldLocation);", "-      readUnlock();", "-    }", "+    finally { readUnlock(); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f94b45b7e203b9d56c8259c659fe9fd1", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocument.java", "commitBeforeChange": "69d4590eff40914052a36cc82d8a74c43211028e", "commitAfterChange": "46bddad84804814dd0241cc4f939b2c8bb524e79", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 41, "signatureBeforeChange": "   public synchronized String getPackageName() throws InvalidPackageException", "signatureAfterChange": "   public String getPackageName() throws InvalidPackageException", "diff": ["-  public synchronized String getPackageName() throws InvalidPackageException {", "-    throwErrorHuh();", "+  public String getPackageName() throws InvalidPackageException {", "+    // throwErrorHuh();", "-", "-    int oldLocation = getCurrentLocation();", "-", "-    try {", "-      setCurrentLocation(0);", "-      final int docLength = getLength();", "-      final String text = getText(0, docLength);", "-//      System.out.println(\"oldlocation: \" + oldLocation + \", doclength: \" + docLength + \", text: \\\"\" + text + \"\\\"\");", "-      // The location of the first non-whitespace character that", "-      // is not inside quote or comment.", "-      int firstNormalLocation = 0;", "-      while ((firstNormalLocation < docLength)) {", "-        setCurrentLocation(firstNormalLocation);", "-", "-        if (_reduced.currentToken().getHighlightState() ==", "-            HighlightStatus.NORMAL)", "+    ", "+    synchronized (_reduced) {", "+      int oldLocation = getCurrentLocation();", "+      ", "+      try {", "+        ", "+        setCurrentLocation(0);", "+        final int docLength = getLength();", "+        final String text = getText(0, docLength);", "+        //      System.out.println(\"oldlocation: \" + oldLocation + \", doclength: \" + docLength + \", text: \\\"\" + text + \"\\\"\");", "+        // The location of the first non-whitespace character that", "+        // is not inside quote or comment.", "+        int firstNormalLocation = 0;", "+        while ((firstNormalLocation < docLength)) {", "+          setCurrentLocation(firstNormalLocation);", "+          ", "+          if (_reduced.currentToken().getHighlightState() == HighlightStatus.NORMAL) {", "+            // OK, it's normal -- so if it's not whitespace, we found the spot", "+            char curChar = text.charAt(firstNormalLocation);", "+            if (!Character.isWhitespace(curChar)) {", "+              break;", "+            }", "+          }", "+          ", "+          firstNormalLocation++;", "+        }", "+        ", "+        // Now there are two possibilities: firstNormalLocation is at", "+        // the first spot of a non-whitespace character that's NORMAL,", "+        // or it's at the end of the document.", "+        if (firstNormalLocation == docLength) return \"\";", "+        ", "+        final int strlen = \"package\".length();", "+        ", "+        final int endLocation = firstNormalLocation + strlen;", "+        ", "+        if ((firstNormalLocation + strlen > docLength) ||", "+            ! text.substring(firstNormalLocation, endLocation).equals(\"package\"))", "-          // OK, it's normal -- so if it's not whitespace, we found the spot", "-          char curChar = text.charAt(firstNormalLocation);", "-          if (!Character.isWhitespace(curChar)) {", "-            break;", "+          // the first normal text is not \"package\" or there is not enough", "+          // text for there to be a package statement.", "+          // thus, there is no valid package statement.", "+          return \"\";", "+        }", "+        ", "+        // OK, we must have found a package statement.", "+        // Now let's find the semicolon. Again, the semicolon must be free.", "+        int afterPackage = firstNormalLocation + strlen;", "+        ", "+        int semicolonLocation = afterPackage;", "+        do {", "+          semicolonLocation = text.indexOf(\";\", semicolonLocation + 1);", "+          ", "+          if (semicolonLocation == -1) {", "+            throw new InvalidPackageException(firstNormalLocation,", "+                                              \"No semicolon found to terminate \" +", "+                                              \"package statement!\");", "+          }", "+          ", "+          setCurrentLocation(semicolonLocation);", "+        }", "+        while (_reduced.currentToken().getHighlightState() !=", "+               HighlightStatus.NORMAL);", "+        ", "+        // Now we have semicolon location. We'll gather text in between one", "+        // character at a time for simplicity. It's inefficient (I think?)", "+        // but it's easy, and there shouldn't be much text between", "+        // \"package\" and \";\" anyhow.", "+        for (int walk = afterPackage + 1; walk < semicolonLocation; walk++) {", "+          setCurrentLocation(walk);", "+          ", "+          if (_reduced.currentToken().getHighlightState() ==", "+              HighlightStatus.NORMAL)", "+          {", "+            char curChar = text.charAt(walk);", "+            ", "+            if (! Character.isWhitespace(curChar)) {", "+              buf.append(curChar);", "+            }", "-", "-        firstNormalLocation++;", "-      }", "-", "-      // Now there are two possibilities: firstNormalLocation is at", "-      // the first spot of a non-whitespace character that's NORMAL,", "-      // or it's at the end of the document.", "-      if (firstNormalLocation == docLength) {", "-        return \"\";", "-      }", "-", "-      final int strlen = \"package\".length();", "-", "-      final int endLocation = firstNormalLocation + strlen;", "-", "-      if ((firstNormalLocation + strlen > docLength) ||", "-          ! text.substring(firstNormalLocation, endLocation).equals(\"package\"))", "-      {", "-        // the first normal text is not \"package\" or there is not enough", "-        // text for there to be a package statement.", "-        // thus, there is no valid package statement.", "-        return \"\";", "-      }", "-", "-      // OK, we must have found a package statement.", "-      // Now let's find the semicolon. Again, the semicolon must be free.", "-      int afterPackage = firstNormalLocation + strlen;", "-", "-      int semicolonLocation = afterPackage;", "-      do {", "-        semicolonLocation = text.indexOf(\";\", semicolonLocation + 1);", "-", "-        if (semicolonLocation == -1) {", "+        ", "+        String toReturn = buf.toString();", "+        if (toReturn.equals(\"\")) {", "-                                            \"No semicolon found to terminate \" +", "-                                            \"package statement!\");", "+                                            \"Package name was not specified \" +", "+                                            \"after the package keyword!\");", "-", "-        setCurrentLocation(semicolonLocation);", "+        ", "+        return toReturn;", "-      while (_reduced.currentToken().getHighlightState() !=", "-             HighlightStatus.NORMAL);", "-", "-      // Now we have semicolon location. We'll gather text in between one", "-      // character at a time for simplicity. It's inefficient (I think?)", "-      // but it's easy, and there shouldn't be much text between", "-      // \"package\" and \";\" anyhow.", "-      for (int walk = afterPackage + 1; walk < semicolonLocation; walk++) {", "-        setCurrentLocation(walk);", "-", "-        if (_reduced.currentToken().getHighlightState() ==", "-            HighlightStatus.NORMAL)", "-        {", "-          char curChar = text.charAt(walk);", "-", "-          if (! Character.isWhitespace(curChar)) {", "-            buf.append(curChar);", "-          }", "-        }", "+      catch (BadLocationException ble) {", "+        throw new UnexpectedException(ble);", "-", "-      String toReturn = buf.toString();", "-      if (toReturn.equals(\"\")) {", "-        throw new InvalidPackageException(firstNormalLocation,", "-                                          \"Package name was not specified \" +", "-                                          \"after the package keyword!\");", "+      finally {", "+        setCurrentLocation(0);", "+        setCurrentLocation(oldLocation);", "-", "-      return toReturn;", "-    }", "-    catch (BadLocationException ble) {", "-      throw new UnexpectedException(ble);", "-    }", "-    finally {", "-      setCurrentLocation(0);", "-      setCurrentLocation(oldLocation);"]}], "num": 1948}