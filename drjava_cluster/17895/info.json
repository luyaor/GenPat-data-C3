{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "110b8b0c54b358f623694f9284b0466b", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "01bbcd3ee91f3f419bbf4a51dd52a7a8", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/docnavigation/JTreeSortNavigator.java", "commitBeforeChange": "ea3de3bd50de8d728bdb5d615bd9b8838d2e94b4", "commitAfterChange": "c8bdd45b172c9714aba30b2edf20a9a7463e66ab", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 47, "signatureBeforeChange": "   public String getNameOfSelectedTopLevelGroup() throws GroupNotSelectedException", "signatureAfterChange": "   public java.util.Set<String> getNamesOfSelectedTopLevelGroup() throws GroupNotSelectedException", "diff": ["-  /** Returns the name of the top level group that the selected item descends from.  Only runs in event thread. */", "-  public String getNameOfSelectedTopLevelGroup() throws GroupNotSelectedException {", "-    assert EventQueue.isDispatchThread();", "-    ", "-      TreePath p = getSelectionPath();", "-      ", "-      if (n == _model.getRoot())", "-        throw new GroupNotSelectedException(\"there is no top level group for the root of the tree\");", "-      ", "-      while (! _roots.contains(n)) { n = n.getParent(); }", "-      ", "-      return ((GroupNode<?>)n).getData();", "+  /** Returns the names of the top level groups that the selected items descend from.  Only runs in event thread. */", "+  public java.util.Set<String> getNamesOfSelectedTopLevelGroup() throws GroupNotSelectedException {", "+    assert (EventQueue.isDispatchThread() || Utilities.TEST_MODE);", "+    ", "+    HashSet<String> names = new HashSet<String>();", "+    LinkedList<GroupNode<ItemT>> roots = new LinkedList<GroupNode<ItemT>>(_roots);", "+    ", "+    TreePath[] ps = getSelectionPaths();", "+    if (ps!=null) {", "+      for(TreePath p: ps) {", "+        if (p.getLastPathComponent() instanceof DefaultMutableTreeNode) {", "+          DefaultMutableTreeNode n = (DefaultMutableTreeNode) p.getLastPathComponent();", "+          ", "+          for(GroupNode<ItemT> gn: roots) {", "+            if (gn.isNodeDescendant(n)) {", "+              // n is a descendent of gn; add the name of the group node", "+              names.add(gn.getData());", "+              // this group node definitely contains selected items, no need to check it again;", "+              // remove it from the list of roots to consider", "+              roots.remove(gn);", "+              break;", "+            }", "+          }", "+        }", "+      }", "+    }", "+    ", "+    if (names.isEmpty()) { throw new GroupNotSelectedException(\"there is no top level group for the root of the tree\"); }", "+    ", "+    return names;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dcb8547db836b7431e79070a4862c0d5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/config/ConfigFrame.java", "commitBeforeChange": "54a2d5af359edd99cce3e2b74ded93b4c8c0d9e9", "commitAfterChange": "7c8486700bb21647b6fbe2818464471123c8ab80", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "   private void _setupKeyBindingsPanel(ConfigPanel panel)", "signatureAfterChange": "   private void _setupKeyBindingsPanel(ConfigPanel panel)", "diff": ["-    // using a treeset because it automatically sorts element upon insertion", "-    TreeSet<VectorKeyStrokeOptionComponent> _comps = new TreeSet<VectorKeyStrokeOptionComponent>();", "+    // using a treemap because it automatically sorts element upon insertion", "+    TreeMap<String,VectorKeyStrokeOptionComponent> _comps = new TreeMap<String,VectorKeyStrokeOptionComponent>();", "-        String desc = (String) a.getValue(Action.SHORT_DESCRIPTION);", "-        if (desc == null || desc.equals(\"\")) desc = ksd.getName();", "-        vksoc = new VectorKeyStrokeOptionComponent(ksd.getOption(), ksd.getName(), this, desc);", "-        if (vksoc != null) _comps.add(vksoc);", "+        // pick the short description as name, if available", "+        String name = (String) a.getValue(Action.SHORT_DESCRIPTION);", "+        // if not available, pick the KeyStrokeData name instead", "+        if (name == null || name.trim().equals(\"\")) name = ksd.getName();", "+        // pick the long description as name, if available", "+        String desc = (String) a.getValue(Action.LONG_DESCRIPTION);", "+        // if not available, pick the name from above instead", "+        if (desc == null || desc.trim().equals(\"\")) desc = name;", "+        // if the map already contains this name, use the description instead", "+        if (_comps.containsKey(name)) {", "+          name = desc;", "+          // if the map already contains the description as well (bad developers!), then use the option's name", "+          if (_comps.containsKey(name)) {", "+            name = ksd.getOption().getName();", "+          }", "+        }", "+        vksoc = new VectorKeyStrokeOptionComponent(ksd.getOption(), name, this, desc);", "+        if (vksoc != null) _comps.put(name, vksoc);", "-    Iterator<VectorKeyStrokeOptionComponent> iter = _comps.iterator();", "+    Iterator<VectorKeyStrokeOptionComponent> iter = _comps.values().iterator();"]}], "num": 17895}