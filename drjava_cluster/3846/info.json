{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f1de22a1c34bb6e83037610768a45adf", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "15fcf3e5c469438960fad924fd2a60af", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "9c6f88c259086ee69c4d958032e8427e6f011b12", "commitAfterChange": "9437c2299622c109c03b30ccc782cae5639dae6e", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 13, "signatureBeforeChange": "             public boolean contains(Type t)", "signatureAfterChange": "          public boolean contains(final Type subT, final Type superT)", "diff": ["-          return IterUtil.and(superT.ofTypes(), new Predicate<Type>() {", "-            public boolean contains(Type t) { return isSubtype(subT, t, stack); }", "+    ", "+    public boolean contains(final Type subT, final Type superT) {", "+      //debug.logStart(new String[]{\"subT\", \"superT\"}, subT, superT); try {", "+      if (subT.equals(superT)) { return true; } // what follows assumes the types are not syntactically equal", "+      ", "+      // Handle easy superT cases; return null if subT cases need to be considered, too", "+      Boolean result = superT.apply(new TypeAbstractVisitor<Boolean>() {", "+        public Boolean defaultCase(Type superT) { return null; }", "+        ", "+        @Override public Boolean forVariableType(final VariableType superT) {", "+          return subT.apply(new TypeAbstractVisitor<Boolean>() {", "+            public Boolean defaultCase(final Type subT) {", "+              Thunk<Boolean> checkLowerBound = new Thunk<Boolean>() {", "+                  Type bound = NORMALIZE.value(superT.symbol().lowerBound());", "+                  return NormSubtype.this.contains(subT, bound);", "+              Thunk<Boolean> checkInfinite = new Thunk<Boolean>() {", "+                public Boolean value() { return NormSubtype.this.contains(subT, NULL); }", "+              };", "+              return _stack.apply(checkLowerBound, checkInfinite, subT, superT);", "+            @Override public Boolean forVariableType(VariableType subT) {", "+              return defaultCase(subT) ? true : null;", "+            }", "+            @Override public Boolean forIntersectionType(IntersectionType subT) {", "+              return defaultCase(subT) ? true : null;", "+            }", "+            @Override public Boolean forBottomType(BottomType subT) { return true; }", "+          });", "+        }", "+        ", "+        @Override public Boolean forIntersectionType(IntersectionType superT) {", "+          if (subT instanceof BottomType) { return true; }", "+          else { return IterUtil.and(superT.ofTypes(), supertypes(subT)); }", "+        }", "+        ", "+        @Override public Boolean forUnionType(final UnionType superT) {", "+          return subT.apply(new TypeAbstractVisitor<Boolean>() {", "+            @Override public Boolean defaultCase(Type t) {", "+              return IterUtil.or(superT.ofTypes(), supertypes(subT)); ", "+            }", "+            public Boolean forVariableType(VariableType t) { return defaultCase(subT) ? true : null; }", "+            public Boolean forUnionType(UnionType t) { return null; }", "+            public Boolean forBottomType(BottomType t) { return true; }", "+          });", "+        }", "+        ", "+        @Override public Boolean forTopType(TopType superT) { return true; }", "+      });", "+      ", "+      if (result != null) { return result; }", "+      ", "+      // Handle subT-based cases:", "+      return subT.apply(new TypeAbstractVisitor<Boolean>() {", "+        ", "+        public Boolean defaultCase(Type t) { return false; }", "+        ", "+        public Boolean forCharType(CharType subT) {", "+          return superT.apply(new TypeAbstractVisitor<Boolean>() {", "+            public Boolean defaultCase(Type superT) { return false; }", "+            @Override public Boolean forCharType(CharType superT) { return true; }", "+            @Override public Boolean forIntType(IntType superT) { return true; }", "+            @Override public Boolean forLongType(LongType superT) { return true; }", "+            @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "+          });", "+        }", "+        ", "+        public Boolean forByteType(ByteType subT) {", "+          return superT.apply(new TypeAbstractVisitor<Boolean>() {", "+            public Boolean defaultCase(Type superT) { return false; }", "+            @Override public Boolean forIntegerType(IntegerType superT) { return true; }", "+            @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "+          });", "+        }", "+        ", "+        public Boolean forShortType(ShortType subT) {", "+          return superT.apply(new TypeAbstractVisitor<Boolean>() {", "+            public Boolean defaultCase(Type superT) { return false; }", "+            @Override public Boolean forShortType(ShortType superT) { return true; }", "+            @Override public Boolean forIntType(IntType superT) { return true; }", "+            @Override public Boolean forLongType(LongType superT) { return true; }", "+            @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "+          });", "+        }", "+        ", "+        public Boolean forIntType(IntType subT) {", "+          return superT.apply(new TypeAbstractVisitor<Boolean>() {", "+            public Boolean defaultCase(Type superT) { return false; }", "+            @Override public Boolean forIntType(IntType superT) { return true; }", "+            @Override public Boolean forLongType(LongType superT) { return true; }", "+            @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "+          });", "+        }", "+        ", "+        public Boolean forLongType(LongType subT) {", "+          return superT.apply(new TypeAbstractVisitor<Boolean>() {", "+            public Boolean defaultCase(Type superT) { return false; }", "+            @Override public Boolean forLongType(LongType superT) { return true; }", "+            @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "+          });", "+        }", "+        ", "+        public Boolean forFloatType(FloatType subT) { return superT instanceof FloatingPointType; }", "+        ", "+        public Boolean forNullType(NullType subT) { return isReference(superT); }", "+        ", "+        public Boolean forSimpleArrayType(SimpleArrayType subT) { return handleArrayType(subT); }", "+        ", "+        public Boolean forVarargArrayType(VarargArrayType subT) { return handleArrayType(subT); }", "+        ", "+        private Boolean handleArrayType(final ArrayType subT) {", "+          return superT.apply(new TypeAbstractVisitor<Boolean>() {", "+            public Boolean defaultCase(Type superT) { return false; }", "+            ", "+            @Override public Boolean forArrayType(ArrayType superT) {", "+              if (isPrimitive(subT.ofType())) {", "+                // types may be inequal if one is vararg and the other is not", "+                return subT.ofType().equals(superT.ofType());", "+              }", "+              else { return NormSubtype.this.contains(subT.ofType(), superT.ofType()); }", "+            }", "+            ", "+            @Override public Boolean forClassType(ClassType superT) { ", "+              return NormSubtype.this.contains(CLONEABLE_AND_SERIALIZABLE, superT);", "+            }", "+            ", "+          });", "+        }", "+        ", "+        public Boolean forClassType(final ClassType subT) {", "+          return superT.apply(new TypeAbstractVisitor<Boolean>() {", "+            public Boolean defaultCase(Type superT) { return false; }", "+            @Override public Boolean forClassType(ClassType superT) {", "+              Type newSub = immediateSupertype(subT);", "+              if (newSub == null) { return false; }", "+              // immediateSupertype() always returns a normalized type", "+              else { return NormSubtype.this.contains(newSub, superT); }", "+            }", "+          });", "+        }", "+        ", "+        public Boolean forParameterizedClassType(final ParameterizedClassType subT) {", "+          return superT.apply(new TypeAbstractVisitor<Boolean>() {", "+            public Boolean defaultCase(Type superT) { return false; }", "+            ", "+            @Override public Boolean forParameterizedClassType(final ParameterizedClassType superT) {", "+              if (subT.ofClass().equals(superT.ofClass())) {", "+                ", "+                Thunk<Boolean> containedArgs = new Thunk<Boolean>() {", "+                  public Boolean value() {", "+                    boolean result = true;", "+                    ParameterizedClassType subCapT = capture(subT);", "+                    for (final Pair<Type, Type> args : IterUtil.zip(subCapT.typeArguments(), ", "+                                                                    superT.typeArguments())) {", "+                      result &= args.second().apply(new TypeAbstractVisitor<Boolean>() {", "+                        public Boolean defaultCase(Type superArg) {", "+                          Type subArg = args.first();", "+                          return NormSubtype.this.contains(subArg, superArg) &&", "+                                 NormSubtype.this.contains(superArg, subArg);", "+                        }", "+                        @Override public Boolean forWildcard(Wildcard superArg) {", "+                          Type subArg = args.first();", "+                          return NormSubtype.this.contains(superArg.symbol().lowerBound(), subArg) &&", "+                                 NormSubtype.this.contains(subArg, superArg.symbol().upperBound());", "+                        }", "+                      });", "+                      if (!result) { break; }", "+                    }", "+                    return result;", "+                  }", "+                };", "+                ", "+                return _stack.apply(containedArgs, false, subT, superT) || forClassType(superT);", "+              }", "+              else { return forClassType(superT); }", "+            }", "+            ", "+            @Override public Boolean forClassType(ClassType superT) {", "+              Type newSub = immediateSupertype(subT);", "+              if (newSub == null) { return false; }", "+              else {", "+                // results of immediateSupertype() and erase() are always normalized", "+                return NormSubtype.this.contains(newSub, superT) || NormSubtype.this.contains(erase(subT), superT);", "+              }", "+            }", "+            ", "+          });", "+        }", "+        ", "+        public Boolean forVariableType(final VariableType subT) {", "+          Thunk<Boolean> checkUpperBound = new Thunk<Boolean>() {", "+            public Boolean value() {", "+              Type bound = NORMALIZE.value(subT.symbol().upperBound());", "+              return NormSubtype.this.contains(bound, superT);", "+            }", "+          };", "+          Thunk<Boolean> checkInfinite = new Thunk<Boolean>() {", "+            public Boolean value() { return NormSubtype.this.contains(OBJECT, superT); }", "+          };", "+          return _stack.apply(checkUpperBound, checkInfinite, subT, superT);", "+        }", "+        ", "+        public Boolean forIntersectionType(IntersectionType subT) {", "+          return IterUtil.or(subT.ofTypes(), subtypes(superT)); ", "+        }", "+        ", "+        public Boolean forUnionType(UnionType subT) {", "+          return IterUtil.and(subT.ofTypes(), subtypes(superT)); ", "+        }", "+        ", "+        public Boolean forBottomType(BottomType subT) { return true; }", "+      });", "+      //} finally { debug.logEnd(); }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "50c74573a73aff17dea9b24ba1fbc92b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "9c6f88c259086ee69c4d958032e8427e6f011b12", "commitAfterChange": "9437c2299622c109c03b30ccc782cae5639dae6e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 12, "signatureBeforeChange": "      private boolean isSubtype(final Type subT, final Type superT, final RecursionStack2<Type, Type> stack)", "signatureAfterChange": "          public Predicate<Type> subtypes(Type sup)", "diff": ["-  private boolean isSubtype(final Type subT, final Type superT, final RecursionStack2<Type, Type> stack) {", "-    //debug.logStart(new String[]{\"subT\", \"superT\"}, subT, superT); try {", "-            ", "-    if (subT.equals(superT)) { return true; } // what follows assumes the types are not syntactically equal", "-    // Handle easy superT cases:", "-    Boolean result = superT.apply(new TypeAbstractVisitor<Boolean>() {", "-      public Boolean defaultCase(Type superT) { return null; }", "-      ", "-      @Override public Boolean forVariableType(final VariableType superT) {", "-        return subT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(final Type subT) {", "-            Thunk<Boolean> checkLowerBound = new Thunk<Boolean>() {", "-              public Boolean value() { return isSubtype(subT, superT.symbol().lowerBound(), stack); }", "-            };", "-            return stack.apply(checkLowerBound, false, subT, superT);", "-          }", "-          @Override public Boolean forVariableType(VariableType subT) {", "-            return defaultCase(subT) ? true : null;", "-          }", "-          @Override public Boolean forIntersectionType(IntersectionType subT) {", "-            return defaultCase(subT) ? true : null;", "-          }", "-          @Override public Boolean forBottomType(BottomType subT) { return true; }", "-        });", "-      }", "-      ", "-      @Override public Boolean forIntersectionType(IntersectionType superT) {", "-        if (subT instanceof BottomType) { return true; }", "-        else {", "-          return IterUtil.and(superT.ofTypes(), new Predicate<Type>() {", "-            public boolean contains(Type t) { return isSubtype(subT, t, stack); }", "-          });", "-        }", "-      }", "-      ", "-      @Override public Boolean forUnionType(final UnionType superT) {", "-        return subT.apply(new TypeAbstractVisitor<Boolean>() {", "-          @Override public Boolean defaultCase(Type t) {", "-            return IterUtil.or(superT.ofTypes(), new Predicate<Type>() {", "-              public boolean contains(Type t) { return isSubtype(subT, t, stack); }", "-            });", "-          }", "-          public Boolean forVariableType(VariableType t) { return defaultCase(subT) ? true : null; }", "-          public Boolean forUnionType(UnionType t) { return null; }", "-          public Boolean forBottomType(BottomType t) { return true; }", "-        });", "-      }", "-      ", "-      @Override public Boolean forTopType(TopType superT) { return true; }", "-    });", "-    if (result != null) { return result; }", "-    // Handle subT-based cases:", "-    return subT.apply(new TypeAbstractVisitor<Boolean>() {", "-      ", "-      public Boolean defaultCase(Type t) { return false; }", "-      ", "-      public Boolean forCharType(CharType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forCharType(CharType superT) { return true; }", "-          @Override public Boolean forIntType(IntType superT) { return true; }", "-          @Override public Boolean forLongType(LongType superT) { return true; }", "-          @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "-        });", "-      }", "-      ", "-      public Boolean forByteType(ByteType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forIntegerType(IntegerType superT) { return true; }", "-          @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "-        });", "-      }", "-      ", "-      public Boolean forShortType(ShortType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forShortType(ShortType superT) { return true; }", "-          @Override public Boolean forIntType(IntType superT) { return true; }", "-          @Override public Boolean forLongType(LongType superT) { return true; }", "-          @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "-        });", "-      }", "-      ", "-      public Boolean forIntType(IntType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forIntType(IntType superT) { return true; }", "-          @Override public Boolean forLongType(LongType superT) { return true; }", "-          @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "-        });", "-      }", "-      ", "-      public Boolean forLongType(LongType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forLongType(LongType superT) { return true; }", "-          @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "-        });", "-      }", "-      ", "-      public Boolean forFloatType(FloatType subT) { return superT instanceof FloatingPointType; }", "-      ", "-      public Boolean forNullType(NullType subT) { return isReference(superT); }", "-      ", "-      public Boolean forSimpleArrayType(SimpleArrayType subT) { return handleArrayType(subT); }", "-      ", "-      public Boolean forVarargArrayType(VarargArrayType subT) { return handleArrayType(subT); }", "-      ", "-      private Boolean handleArrayType(final ArrayType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          ", "-          @Override public Boolean forArrayType(ArrayType superT) {", "-            if (isPrimitive(subT.ofType())) {", "-              // types may be inequal if one is vararg and the other is not", "-              return subT.ofType().equals(superT.ofType());", "-            }", "-            else { return isSubtype(subT.ofType(), superT.ofType(), stack); }", "-          }", "-          ", "-          @Override public Boolean forClassType(ClassType superT) { ", "-            return isSubtype(CLONEABLE_AND_SERIALIZABLE, superT, stack);", "-          }", "-          ", "-        });", "-      }", "-      ", "-      public Boolean forClassType(final ClassType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forClassType(ClassType superT) {", "-            Type newSub = immediateSupertype(subT);", "-            if (newSub == null) { return false; }", "-            else { return isSubtype(newSub, superT, stack); }", "-          }", "-        });", "-      }", "-      ", "-      public Boolean forParameterizedClassType(final ParameterizedClassType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          ", "-          @Override public Boolean forParameterizedClassType(final ParameterizedClassType superT) {", "-            if (subT.ofClass().equals(superT.ofClass())) {", "+    public Predicate<Type> subtypes(Type sup) { return LambdaUtil.bindSecond((Order<Type>) this, sup); }", "-              Thunk<Boolean> containedArgs = new Thunk<Boolean>() {", "-                  boolean result = true;", "-                  ParameterizedClassType subCapT = capture(subT);", "-                  for (final Pair<Type, Type> args : IterUtil.zip(subCapT.typeArguments(), ", "-                                                                  superT.typeArguments())) {", "-                    result &= args.second().apply(new TypeAbstractVisitor<Boolean>() {", "-                      public Boolean defaultCase(Type superArg) { return isEqual(args.first(), superArg); }", "-                      @Override public Boolean forWildcard(Wildcard superArg) {", "-                        return isSubtype(superArg.symbol().lowerBound(), args.first(), stack) &&", "-                          isSubtype(args.first(), superArg.symbol().upperBound(), stack);", "-                      }", "-                    });", "-                    if (!result) { break; }", "-                  }", "-                  return result;", "-              ", "-              return stack.apply(containedArgs, true, subT, superT) || forClassType(superT);", "-            else { return forClassType(superT); }", "-          ", "-          @Override public Boolean forClassType(ClassType superT) {", "-            Type newSub = immediateSupertype(subT);", "-            if (newSub == null) { return false; }", "-            else { return isSubtype(meet(newSub, erase(subT)), superT, stack); }", "-          }", "-          ", "-      ", "-      public Boolean forVariableType(final VariableType subT) {", "-        // If variables are always Objects, we should test that superT is Object in the infinite case", "-        Thunk<Boolean> checkUpperBound = new Thunk<Boolean>() {", "-          public Boolean value() { return isSubtype(subT.symbol().upperBound(), superT, stack); }", "-        };", "-        return stack.apply(checkUpperBound, false, subT, superT);", "-      }", "-      ", "-      public Boolean forIntersectionType(IntersectionType subT) {", "-        return IterUtil.or(subT.ofTypes(), new Predicate<Type>() {", "-          public boolean contains(Type t) { return isSubtype(t, superT, stack); }", "-        });", "-      }", "-      ", "-      public Boolean forUnionType(UnionType subT) {", "-        return IterUtil.and(subT.ofTypes(), new Predicate<Type>() {", "-          public boolean contains(Type t) { return isSubtype(t, superT, stack); }", "-        });", "-      }", "-      ", "-      public Boolean forBottomType(BottomType subT) { return true; }", "-    });", "-    //} finally { debug.logEnd(); }", "-  }"]}], "num": 3846}