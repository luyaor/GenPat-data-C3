{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "01ebb7095b6e7d30a0b5a34ab0da8674", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "45baf30f0b88f42adabd4f8b543757fb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 23, "signatureBeforeChange": "   @Override public Type visit(ObjectMethodCall node)", "signatureAfterChange": "     @Override public Type visit(ObjectMethodCall node)", "diff": ["-   */", "-  @Override public Type visit(ObjectMethodCall node) {", "-    Expression receiver = node.getExpression();", "-    if (receiver instanceof AmbiguousName) {", "-      Node resolved = resolveAmbiguousName((AmbiguousName) receiver);", "-      if (resolved instanceof ReferenceTypeName) {", "-        // this is actually a StaticMethodCall", "-        Expression translation;", "-        if (node instanceof PolymorphicObjectMethodCall) {", "-          translation =", "-            new PolymorphicStaticMethodCall((ReferenceTypeName) resolved, node.getMethodName(), node.getArguments(),", "-                                            ((PolymorphicObjectMethodCall) node).getTypeArguments(),", "-                                            node.getFilename(), node.getBeginLine(), node.getBeginColumn(),", "-                                            node.getEndLine(), node.getEndColumn());", "-          translation = new StaticMethodCall((ReferenceTypeName) resolved, node.getMethodName(),", "-                                             node.getArguments(), node.getFilename(), node.getBeginLine(),", "-                                             node.getBeginColumn(), node.getEndLine(), node.getEndColumn());", "-        translation.acceptVisitor(this);", "-        setTranslation(node, translation);", "-        return setType(node, getType(translation));", "-      }", "-      else { receiver = (Expression) resolved; }", "-    }", "-    ", "-    Type receiverT = receiver.acceptVisitor(this);", "-    ", "-    Iterable<? extends Expression> args = IterUtil.empty();", "-    if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "-    ", "-    Iterable<Type> targs = IterUtil.empty();", "-    if (node instanceof PolymorphicObjectMethodCall) {", "-      targs = checkTypeNameList(((PolymorphicObjectMethodCall) node).getTypeArguments());", "-    }", "-    ", "-    try {", "-      // Note: Changes made below may also need to be made in the TypeSystem's boxing & unboxing implementations", "-      TypeSystem.ObjectMethodInvocation inv = ts.lookupMethod(receiver, node.getMethodName(), targs, args);", "-      // TODO: Check accessibility of method", "-      checkThrownExceptions(inv.thrown(), node);", "-      node.setExpression(inv.object());", "-      node.setArguments(CollectUtil.makeList(inv.args()));", "-      setMethod(node, inv.method());", "-      Type result = ts.capture(inv.returnType());", "-      debug.logValue(\"Type of method call \" + node.getMethodName(), ts.wrap(result));", "-      addRuntimeCheck(node, result, inv.method().returnType());", "-      return setType(node, result);", "-    }", "-    catch (InvalidTypeArgumentException e) {", "-      throw new ExecutionError(\"type.argument\", node);", "-    }", "-    catch (TypeSystemException e) {", "-      setErrorStrings(node, ts.userRepresentation(receiverT), node.getMethodName(), nodeTypesString(args));", "-      throw new ExecutionError(\"no.such.method\", node);", "-    }", "-  }", "+     */", "+    @Override public Type visit(ObjectMethodCall node) {", "+      Expression receiver = node.getExpression();", "+      if (receiver instanceof AmbiguousName) {", "+        Node resolved = resolveAmbiguousName((AmbiguousName) receiver);", "+        if (resolved instanceof ReferenceTypeName) {", "+          // this is actually a StaticMethodCall", "+          Expression translation;", "+          if (node instanceof PolymorphicObjectMethodCall) {", "+            translation =", "+              new PolymorphicStaticMethodCall((ReferenceTypeName) resolved, node.getMethodName(), node.getArguments(),", "+                                              ((PolymorphicObjectMethodCall) node).getTypeArguments(),", "+                                              node.getFilename(), node.getBeginLine(), node.getBeginColumn(),", "+                                              node.getEndLine(), node.getEndColumn());", "+          }", "+          else {", "+            translation = new StaticMethodCall((ReferenceTypeName) resolved, node.getMethodName(),", "+                                               node.getArguments(), node.getFilename(), node.getBeginLine(),", "+                                               node.getBeginColumn(), node.getEndLine(), node.getEndColumn());", "+          }", "+          translation.acceptVisitor(this);", "+          setTranslation(node, translation);", "+          return setType(node, getType(translation));", "+        }", "+        else { receiver = (Expression) resolved; }", "+      }", "+      ", "+      Type receiverT = check(receiver);", "+      ", "+      Iterable<? extends Expression> args = IterUtil.empty();", "+      if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "+      ", "+      Iterable<Type> targs = IterUtil.empty();", "+      if (node instanceof PolymorphicObjectMethodCall) {", "+        targs = checkTypeNameList(((PolymorphicObjectMethodCall) node).getTypeArguments());", "+      }", "+      ", "+      try {", "+        // Note: Changes made below may also need to be made in the TypeSystem's boxing & unboxing implementations", "+        ObjectMethodInvocation inv = ts.lookupMethod(receiver, node.getMethodName(), targs, args, expected);", "+        // TODO: Check accessibility of method", "+        checkThrownExceptions(inv.thrown(), node);", "+        node.setExpression(inv.object());", "+        node.setArguments(CollectUtil.makeList(inv.args()));", "+        setMethod(node, inv.method());", "+        Type result = ts.capture(inv.returnType());", "+        debug.logValue(\"Type of method call \" + node.getMethodName(), ts.wrap(result));", "+        addRuntimeCheck(node, result, inv.method().returnType());", "+        return setType(node, result);", "+      }", "+      catch (InvalidTypeArgumentException e) {", "+        throw new ExecutionError(\"type.argument\", node);", "+      }", "+      catch (TypeSystemException e) {", "+        setErrorStrings(node, ts.userRepresentation(receiverT), node.getMethodName(), nodeTypesString(args));", "+        throw new ExecutionError(\"no.such.method\", node);", "+      }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c3b4f9d53d278ccaf8b5fa28e96fbfb7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tpublic Object visit(ObjectMethodCall node)", "signatureAfterChange": "     public Object visit(ObjectMethodCall node)", "diff": ["-\t */", "-\tpublic Object visit(ObjectMethodCall node) {", "-\t    // Check the receiver", "-\t    if (node.getExpression() != null) {", "-\t\tObject o = node.getExpression().acceptVisitor(this);", "-\t\tif (o != null) {", "-\t\t    if (o instanceof Expression) {", "-\t\t\tnode.setExpression((Expression)o);", "-\t\t    } else {", "-\t\t\tNode result =  new StaticMethodCall((ReferenceType)o,", "-\t\t\t\t\t\t\t    node.getMethodName(),", "-\t\t\t\t\t\t\t    node.getArguments(),", "-\t\t\t\t\t\t\t    node.getFilename(),", "-\t\t\t\t\t\t\t    node.getBeginLine(),", "-\t\t\t\t\t\t\t    node.getBeginColumn(),", "-\t\t\t\t\t\t\t    node.getEndLine(),", "-\t\t\t\t\t\t\t    node.getEndColumn());", "-\t\t\tresult.acceptVisitor(this);", "-\t\t\treturn result;", "-\t\t    }", "-\t\t}", "-\t    } else {", "-\t\tIdentifier t = new Identifier(classInfo.getName());", "-\t\tList l = new LinkedList();", "-\t\tl.add(t);", "-\t\tReferenceType rt = new ReferenceType(l);", "-\t\trt.acceptVisitor(this);", "-\t\tNode result =  new StaticMethodCall(rt,", "-\t\t\t\t\t\t    node.getMethodName(),", "-\t\t\t\t\t\t    node.getArguments(),", "-\t\t\t\t\t\t    node.getFilename(),", "-\t\t\t\t\t\t    node.getBeginLine(),", "-\t\t\t\t\t\t    node.getBeginColumn(),", "-\t\t\t\t\t\t    node.getEndLine(),", "-\t\t\t\t\t\t    node.getEndColumn());", "-\t\tresult.acceptVisitor(this);", "-\t\treturn result;", "-\t    }", "-", "-\t    ClassInfo c = NodeProperties.getClassInfo(node.getExpression());", "-", "-\t    if (!c.isArray() || (c.isArray() && !node.getMethodName().equals(\"clone\"))) {", "-\t\t// Do the type checking of the arguments", "-\t\tClassInfo[] cargs = new ClassInfo[0];", "-\t\tList args = node.getArguments();", "-\t\tif (args != null) {", "-\t\t    checkList(args, \"malformed.argument\", node);", "-", "-\t\t    cargs = new ClassInfo[args.size()];", "-\t\t    ListIterator it = args.listIterator();", "-\t\t    int i  = 0;", "-\t\t    while (it.hasNext()) {", "-\t\t\tcargs[i++] = NodeProperties.getClassInfo((Node)it.next());", "-\t\t    }", "-\t\t}", "-\t\tMethodInfo m = null;", "-\t\ttry {", "-\t\t    m = ClassInfoUtilities.lookupMethod(c, node.getMethodName(), cargs);", "-\t\t} catch (NoSuchMethodException e) {", "-\t\t    throw new CatchedExceptionError(e, node);", "-\t\t}", "-", "-\t\t// Set the node properties", "-\t\tnode.setProperty(NodeProperties.TYPE, m.getReturnType());", "-\t    } else {", "-\t\tif (!node.getMethodName().equals(\"clone\") ||", "-\t\t    node.getArguments() != null) {", "-\t\t    String s0 = \"clone\";", "-\t\t    String s1 = c.getComponentType().getName() + \" array\";", "-\t\t    node.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t     new String[] { s0, s1 });", "-\t\t    throw new ExecutionError(\"no.such.method\", node);", "-\t\t}", "-\t\tnode.setProperty(NodeProperties.TYPE, new JavaClassInfo(Object.class));", "-\t    }", "-\t    return null;", "-\t}", "+     */", "+    public Object visit(ObjectMethodCall node) {", "+      // Check the receiver", "+      if (node.getExpression() != null) {", "+        Object o = node.getExpression().acceptVisitor(this);", "+        if (o != null) {", "+          if (o instanceof Expression) {", "+            node.setExpression((Expression)o);", "+          } else {", "+            Node result =  new StaticMethodCall((ReferenceType)o,", "+                                                node.getMethodName(),", "+                                                node.getArguments(),", "+                                                node.getFilename(),", "+                                                node.getBeginLine(),", "+                                                node.getBeginColumn(),", "+                                                node.getEndLine(),", "+                                                node.getEndColumn()", "+          );", "+            ", "+            result.acceptVisitor(this);", "+            return result;", "+          }", "+        }", "+      } else {", "+        Identifier t = new Identifier(classInfo.getName());", "+        List<IdentifierToken> l = new LinkedList<IdentifierToken>();", "+        l.add(t);", "+        ReferenceType rt = new ReferenceType(l);", "+        rt.acceptVisitor(this);", "+        Node result =  new StaticMethodCall(rt,", "+                                            node.getMethodName(),", "+                                            node.getArguments(),", "+                                            node.getFilename(),", "+                                            node.getBeginLine(),", "+                                            node.getBeginColumn(),", "+                                            node.getEndLine(),", "+                                            node.getEndColumn()", "+        );", "+        result.acceptVisitor(this);", "+        return result;", "+      }", "+      ", "+      ClassInfo c = NodeProperties.getClassInfo(node.getExpression());", "+      ", "+      if (!c.isArray() || (c.isArray() && !node.getMethodName().equals(\"clone\"))) {", "+        // Do the type checking of the arguments", "+        ClassInfo[] cargs = new ClassInfo[0];", "+        List<Expression> args = node.getArguments();", "+        if (args != null) {", "+          checkList(args, \"malformed.argument\", node);", "+          ", "+          cargs = new ClassInfo[args.size()];", "+          ListIterator<Expression> it = args.listIterator();", "+          int i  = 0;", "+          while (it.hasNext()) {", "+            cargs[i++] = NodeProperties.getClassInfo(it.next());", "+          }", "+        }", "+        MethodInfo m = null;", "+        try {", "+          m = ClassInfoUtilities.lookupMethod(c, node.getMethodName(), cargs);", "+        } catch (NoSuchMethodException e) {", "+          throw new CatchedExceptionError(e, node);", "+        }", "+        ", "+        // Set the node properties", "+        node.setProperty(NodeProperties.TYPE, m.getReturnType());", "+      } else {", "+        if (!node.getMethodName().equals(\"clone\") ||", "+            node.getArguments() != null) {", "+          String s0 = \"clone\";", "+          String s1 = c.getComponentType().getName() + \" array\";", "+          node.setProperty(NodeProperties.ERROR_STRINGS,", "+                           new String[] { s0, s1 });", "+          throw new ExecutionError(\"no.such.method\", node);", "+        }", "+        node.setProperty(NodeProperties.TYPE, new JavaClassInfo(Object.class));", "+      }", "+      return null;", "+    }"]}], "num": 29362}