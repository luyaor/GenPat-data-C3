{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "540ad8098905782d2b24d51754835170", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6008c1bb30ef0c03abafe27d2ff81971", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/ConcreteRegionManager.java", "commitBeforeChange": "d884ae55e9471d604870827048329b58394dd950", "commitAfterChange": "28bca5adabaaf178bdf954808155389f93ed51fa", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 5, "signatureBeforeChange": "   public R getRegionAt(OpenDefinitionsDocument odd, int start, int end)", "signatureAfterChange": "     public R getRegionAt(OpenDefinitionsDocument odd, int offset)", "diff": ["-    */", "-  public R getRegionAt(OpenDefinitionsDocument odd, int start, int end) {", "-    final int lineStartOffset = odd.getLineStartPos(start);", "-    final int lineEndOffset = odd.getLineEndPos(end);", "-    // get all the regions after the beginning of the start line and before the end of the end line", "-    @SuppressWarnings(\"unchecked\")", "-    SortedSet<R> range = getRangeSet((R) newDocumentRegion(odd, lineStartOffset, lineStartOffset),", "-                                     (R) newDocumentRegion(odd, lineEndOffset+1, lineEndOffset+1));", "-    if (range.isEmpty()) return null;", "-    // now see if there is a region that overlaps with the region [start,end]", "-    for(R r: range) {", "-      final int rStart = r.getStartOffset();", "-      final int rEnd = r.getEndOffset();", "-      // is rStart not past the [start,end] region?", "-      if  (rStart<=end) {", "-        // is rEnd inside [start,end]?", "-        if ((rEnd>=start) && (rEnd<=end)) {", "-//          // r contained? [start...<rStart...rEnd>...end]", "-//          if (rStart>=start) { return r; }", "-          // r overlaps left? <rStart...[start...rEnd>...end]", "-          if (rStart<=start) { return r; }", "-        }", "-        // is rEnd on the right side of [start,end]?", "-        else if ((rEnd>=start) && (rEnd>=end)) {", "-          // r encloses? <rStart...[start...end]...rEnd>", "-          if (rStart<=start) { return r; }", "-          // r overlaps right? [start...<rStart...end]...rEnd>", "-          if (rStart>=start) { return r; }", "-        }", "-      }", "-    }", "-    return null;", "-  }", "+      */", "+    public R getRegionAt(OpenDefinitionsDocument odd, int offset) { return getRegionContaining(odd, offset, offset); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "df9b9b74978290a8a153b86dba75ab83", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "a6b0a623369310bca609596a45d42dfc11ddae97", "commitAfterChange": "f0c06f4ecb55d3ad2147a0571c9f9cb7a469ab29", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": "   private boolean javadoc_1_3(String[] args)        throws IOException, ClassNotFoundException, InterruptedException", "signatureAfterChange": "   private boolean javadoc_1_3(String[] args)        throws IOException, ClassNotFoundException, InterruptedException", "diff": ["-    System.err.println(\"javadoc started with args:\\n\" + Arrays.asList(args));", "+//    System.err.println(\"javadoc started with args:\\n\" + Arrays.asList(args));", "-    System.err.println(\"got past first waitFor.\");", "+//    System.err.println(\"got past first waitFor.\");", "-    ", "-    ", "-//     if (value != 0) {", "-//       // If we get here, we will just have to try using the javadoc program", "-//       // which is hopefully on the system path", "-//       if (CodeStatus.DEVELOPMENT) {", "-//         String msg = (\"Launching Javadoc with ExecJVM failed.  Messages:\");", "-//         printProcessOutput(javadocProcess, msg, \"ExecJVM\");", "-//         ", "-//         System.err.println(\"Attempting to launch Javadoc from command path.\");", "-//       }", "-//       ", "-//       String[] fullArgs = new String[args.length + 1];", "-//       fullArgs[0] = \"javadoc\";", "-//       //TODO: Use System.arraycopy() here.", "-//       for(int a = 0; a < args.length; a++) {", "-//         fullArgs[a + 1] = args[a];", "-//       }", "-//       javadocProcess =  Runtime.getRuntime().exec(fullArgs);", "-//       ", "-//       // TODO: try/catch the previous line and prompt for javadoc's location", "-//       // on failure....and even keep the location in the drjava config", "-//       // DON'T USE waitFor! (See above.)", "-// //       value = javadocProcess.waitFor();", "-//       ", "-//       if (value != 0) {", "-//         if (CodeStatus.DEVELOPMENT) {", "-//           String msg = (\"Launching Javadoc with Runtime.Exec failed.  Messages:\");", "-//           printProcessOutput(javadocProcess, msg, \"Runtime.Exec\");", "-//         }", "-//         ", "-//         // Handle the error condition at the caller!", "-//         CompilerError err = new CompilerError((\"finished with exit code \" + value), false);", "-//         _javadocErrorModel = new CompilerErrorModel(new CompilerError[] { err }, this);", "-//       }", "-//       // else we have a valid javadocProcess from Runtime.Exec - fall through.", "-//     }", "-//     // else or fall-through means we have a valid javadocProcess from ExecJVM or Runtime.Exec", "-    ", "-    ", "-    ArrayList errors = new ArrayList(0);", "-    ", "-    // We already know javadoc is done => process its error messages", "-//     String output;", "-    ", "-//     jdOut = new BufferedReader(new InputStreamReader(javadocProcess.getInputStream()));", "-//     jdErr = new BufferedReader(new InputStreamReader(javadocProcess.getErrorStream()));", "-    ", "-    // Ignore all of javadoc's inane jabber to stdout.", "-    // Maybe dump this to console while debugging?", "-//     output = jdOut.readLine();", "-//     System.out.println(\"[Javadoc stdout] \" + output);", "-//     while (output != null) {", "-//       System.out.println(\"[Javadoc stdout] \" + output);", "-//       output = jdOut.readLine();", "-//     }", "-    ", "-    // By this point, the Javadoc process is dead, so we can't block on reads.", "-//     output = jdErr.readLine();", "-//     while (output != null) {", "-//       final String EXCEPTION_INDICATOR = \"Exception: \";", "-// //         System.out.println(\"[javadoc raw error] \" + output);", "-//       ", "-//       int errStart;", "-//       // Check for the telltale signs of a thrown exception.", "-//       errStart = output.indexOf(EXCEPTION_INDICATOR);", "-//       if (errStart != -1) {", "-//         // If we found one, put the entirety of stderr in one CompilerError.", "-//         StringBuffer buf = new StringBuffer(2000);", "-//         do {", "-//           buf.append(output);", "-//           output = jdErr.readLine();", "-//         } while (output != null);", "-//         errors.add(new CompilerError(buf.toString(), false));", "-//       }", "-//       else {", "-//         CompilerError error = parseJavadocErrorLine(output);", "-//         if (error != null) {", "-//           errors.add(error);", "-// //           System.err.println(\"[javadoc err]\" + error);", "-//         }", "-//       }", "-//       output = jdErr.readLine();", "-//     }", "-    ", "-    final String EXCEPTION_INDICATOR = \"Exception: \";", "-    while (errLines.size() > 0) {", "-//         System.out.println(\"[javadoc raw error] \" + output);", "-      ", "-      output = (String) errLines.removeFirst();", "-      ", "-      int errStart;", "-      // Check for the telltale signs of a thrown exception.", "-      errStart = output.indexOf(EXCEPTION_INDICATOR);", "-      if (errStart != -1) {", "-        // If we found one, put the entirety of stderr in one CompilerError.", "-        StringBuffer buf = new StringBuffer(60 * errLines.size());", "-        do {", "-          buf.append(output);", "-          output = (String) errLines.removeFirst();", "-        } while (errLines.size() > 0);", "-        errors.add(new CompilerError(buf.toString(), false));", "-      }", "-      else {", "-        // Otherwise, parser for a normal error message.", "-        CompilerError error = parseJavadocErrorLine(output);", "-        if (error != null) {", "-          errors.add(error);", "-//           System.err.println(\"[javadoc err]\" + error);", "-        }", "-      }", "-    }", "+", "+    ArrayList errors = extractErrors(outLines);", "+    errors.addAll(extractErrors(errLines));", "-    System.out.println(\"built javadoc error model\");", "+//    System.out.println(\"built javadoc error model\");"]}], "num": 10741}