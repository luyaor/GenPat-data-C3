{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f60d948d38635ca82200429faa6439c2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "079290f69c0b137d949cd175fe9b6121", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/jpda/JPDADebugger.java", "commitBeforeChange": "b2d820b253c15b02ecb50e43e9a336a56dadd45e", "commitAfterChange": "a80c6de11e537b6579c447ea812ef2f4f98b5f2f", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 37, "signatureBeforeChange": "   public OpenDefinitionsDocument preloadDocument(Location location)", "signatureAfterChange": "   public OpenDefinitionsDocument preloadDocument(Location location)", "diff": ["-    // No stored doc, look on the source root set (later, also the sourcepath)", "-    ReferenceType rt = location.declaringType();", "-    try { fileName = getPackageDir(rt.name()) + rt.sourceName(); }", "-    catch (AbsentInformationException aie) {", "-      // Don't know real source name:", "-      //   assume source name is same as file name", "-      String className = rt.name().replace('.', File.separatorChar);", "+    try {", "+      final List<File> files = new ArrayList<File>();", "+      for(OpenDefinitionsDocument odd: _model.getLLOpenDefinitionsDocuments()){ files.add(odd.getRawFile()); }", "+      Location lll = getLLLocation(location, files);", "-      // crop off the $ if there is one and anything after it", "-      int indexOfDollar = className.indexOf('$');", "-      if (indexOfDollar > -1) {", "-        className = className.substring(0, indexOfDollar);", "+      fileName = lll.sourcePath();", "+", "+      // Check source root set (open files)", "+      File f = _model.getSourceFile(fileName);", "+      if (f != null) {", "+        // Get a document for this file, forcing it to open", "+        try { doc = _model.getDocumentForFile(f); }", "+        catch (IOException ioe) {", "+          doc = null;", "+        }", "+      }", "+", "+    }", "+    catch(AbsentInformationException e) {", "+      // No stored doc, look on the source root set (later, also the sourcepath)", "+      final List<File> files = new ArrayList<File>();", "+      for(OpenDefinitionsDocument odd: _model.getLLOpenDefinitionsDocuments()){ files.add(odd.getRawFile()); }", "+", "+      ReferenceType rt = location.declaringType();", "+      fileName = null;", "+      try { fileName = getPackageDir(rt.name()) + rt.sourceName(); }", "+      catch (AbsentInformationException aie) {", "+        // Don't know real source name:", "+        //   assume source name is same as file name", "+        fileName = null;", "+        String className = rt.name().replace('.', File.separatorChar);", "+        ", "+        // crop off the $ if there is one and anything after it", "+        int indexOfDollar = className.indexOf('$');", "+        if (indexOfDollar > -1) {", "+          className = className.substring(0, indexOfDollar);", "+        }", "+        ", "+        for(File f: files) {", "+          if (f.getName().equals(className+\".java\") ||", "+              f.getName().equals(className+\".dj0\") ||", "+              f.getName().equals(className+\".dj1\") ||", "+              f.getName().equals(className+\".dj2\")) {", "+            fileName = f.getName();", "+            break;", "+          }", "+        }", "+        if (fileName==null) {", "+          fileName = className + \".java\";", "+        }", "-      fileName = className + \".java\";", "+      if (fileName!=null) {", "+        // Check source root set (open files)", "+        File f = _model.getSourceFile(fileName);", "+        if (f != null) {", "+          // Get a document for this file, forcing it to open", "+          try { doc = _model.getDocumentForFile(f); }", "+          catch (IOException ioe) {", "+            // No doc, so don't notify listener", "+          }", "+        }", "+      }", "-    // Check source root set (open files)", "-    File f = _model.getSourceFile(fileName);", "-    if (f != null) {", "-      // Get a document for this file, forcing it to open", "-      try { doc = _model.getDocumentForFile(f); }", "-      catch (IOException ioe) {", "-        // No doc, so don't notify listener", "-      }", "-    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a3d800e15a83fba914faf09b88c014a6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/util/ReflectionUtilities.java", "commitBeforeChange": "1ef951d20d276f3c46e1cf20ba51ab4b6ce00f53", "commitAfterChange": "fe7c222597b4c2632fd01caf1fa72f992186277e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 9, "signatureBeforeChange": "   protected static Constructor selectTheMostSpecificConstructor(Constructor c1,                                                                 Constructor c2)", "signatureAfterChange": "   protected static Constructor selectTheMostSpecificConstructor(List<Constructor> list)", "diff": ["-  protected static Constructor selectTheMostSpecificConstructor(Constructor c1,", "-                                                                Constructor c2) {", "-    Class [] a1 = c1.getParameterTypes();", "-    Class [] a2 = c2.getParameterTypes();", "+  protected static Constructor selectTheMostSpecificConstructor(List<Constructor> list) {", "+    if (list.isEmpty()) return null;", "+    Iterator<Constructor> it = list.iterator();", "+    Constructor best = it.next();", "+    Constructor ambiguous = null; // there is no ambiguous other method at first", "+    while (it.hasNext()) {", "+      Constructor curr = it.next();", "+      Class[] a1 = best.getParameterTypes();", "+      Class[] a2 = curr.getParameterTypes();", "+      ", "+      boolean better1 = false; // whether 'best' is better than 'curr'", "+      boolean better2 = false; // whether 'curr' is better than 'best'", "+      for (int i = 0; i < a1.length; i++) {", "+        boolean from2to1 = isCompatible(a1[i], a2[i]);", "+        boolean from1to2 = isCompatible(a2[i], a1[i]);", "+        ", "+        if (from1to2 && !from2to1) {// best's parameter[i] is more specific than curr's", "+          better1 = true; // so best is better than curr", "+        }", "+        if (from2to1 && !from1to2) {// curr's parameter[i] is more specific than best's", "+          better2 = true; // so curr is better than best", "+        }", "+      }", "+      ", "+      // decide which is more specific or whether they are ambiguous", "+      if ( !(better1 ^ better2) ) { // neither is better than the other", "+        // Handle overridden methods", "+        if (Arrays.equals(a1, a2)) {", "+          Class c1 = best.getDeclaringClass();", "+          Class c2 = curr.getDeclaringClass();", "+          boolean c1IsSuperOrSame = c1.isAssignableFrom(c2);", "+          boolean c2IsSuperOrSame = c2.isAssignableFrom(c1);", "+          if (c1IsSuperOrSame && !c2IsSuperOrSame) { // c2 is more specific", "+            best = curr;", "+            continue;", "+          }", "+          else if (c2IsSuperOrSame && !c1IsSuperOrSame) { // c1 is more specific", "+            continue;", "+          }", "+        }", "+        ambiguous = curr;", "+      }", "+      else if (better2) {", "+        best = curr;", "+        ambiguous = null; // no more ambiguity", "+      }", "+    }", "+    if (ambiguous != null) {", "+      throw new AmbiguousMethodException(\"Both contructors match: \" + best + \", and \" + ambiguous);", "+    }", "+    return best;", "+  }", "-      if (a1[i] != a2[i]) {", "-        if (isCompatible(a1[i], a2[i])) {", "-          return c2;", "-        } else {", "-          return c1;", "-    ", "-    return c1;", "-  }"]}], "num": 19431}