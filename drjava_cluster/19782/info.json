{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5867bc5b5e07fe0cb85833b3ed09d118", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c1ce1183a499b8741bbf58363f4cdb96", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/InterfaceBodyIntermediateVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r   public void forAbstractMethodDef(AbstractMethodDef that)", "signatureAfterChange": "   public void forAbstractMethodDef(AbstractMethodDef that)", "diff": ["-   */\r", "-  public void forAbstractMethodDef(AbstractMethodDef that) {\r", "-    forAbstractMethodDefDoFirst(that);\r", "-    if (_checkError()) {\r", "-      return;\r", "-    }\r", "-    \r", "-    MethodData md = createMethodData(that, _symbolData);\r", "-    \r", "-    //All interface methods are considered public by default: enforce this.\r", "-    if (md.hasModifier(\"private\")) {\r", "-      _addAndIgnoreError(\"Interface methods cannot be made private.  They must be public.\", that.getMav());\r", "-    }\r", "-    if (md.hasModifier(\"protected\")) {\r", "-      _addAndIgnoreError(\"Interface methods cannot be made protected.  They must be public.\", that.getMav());\r", "-    }\r", "-    \r", "- //All interface methods are considered public by default.\r", "-    md.addModifier(\"public\"); //(if it was already public, won't be added)\r", "-    md.addModifier(\"abstract\"); //and all interface methods are abstract. \r", "-    String className = getUnqualifiedClassName(_symbolData.getName());\r", "-    if (className.equals(md.getName())) {\r", "-      _addAndIgnoreError(\"Only constructors can have the same name as the class they appear in, and constructors cannot appear in interfaces.\",\r", "-                         that);\r", "-    }\r", "-    else {\r", "-      _symbolData.addMethod(md);\r", "-    }\r", "-  }\r", "+   */", "+  public void forAbstractMethodDef(AbstractMethodDef that) {", "+    forAbstractMethodDefDoFirst(that);", "+    if (_checkError()) return;", "+    ", "+    MethodData md = createMethodData(that, _symbolData);", "+    ", "+    //All interface methods are considered public by default: enforce this.", "+    if (md.hasModifier(\"private\")) {", "+      _addAndIgnoreError(\"Interface methods cannot be made private.  They must be public.\", that.getMav());", "+    }", "+    if (md.hasModifier(\"protected\")) {", "+      _addAndIgnoreError(\"Interface methods cannot be made protected.  They must be public.\", that.getMav());", "+    }", "+    ", "+ // All interface methods are considered public by default.", "+    md.addModifier(\"public\");", "+    md.addModifier(\"abstract\"); //and all interface methods are abstract. ", "+    String className = getUnqualifiedClassName(_symbolData.getName());", "+    if (className.equals(md.getName())) {", "+      _addAndIgnoreError(\"Only constructors can have the same name as the class they appear in, \" + ", "+                         \"and constructors cannot appear in interfaces.\", that);", "+    }", "+    else _symbolData.addMethod(md);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f9c67dcb0f98ed9b776229df4e206ff6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/InterfaceBodyAdvancedVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r   public void forAbstractMethodDef(AbstractMethodDef that)", "signatureAfterChange": "   public void forAbstractMethodDef(AbstractMethodDef that)", "diff": ["-   */\r", "-  public void forAbstractMethodDef(AbstractMethodDef that) {\r", "-    forAbstractMethodDefDoFirst(that);\r", "-    if (prune(that)) { return; }\r", "-    \r", "-    MethodData md = createMethodData(that, _symbolData);\r", "-    \r", "-    //All interface methods are considered public by default: enforce this.\r", "-    if (md.hasModifier(\"private\")) {\r", "-      _addAndIgnoreError(\"Interface methods cannot be made private.  They must be public.\", that.getMav());\r", "-    }\r", "-    if (md.hasModifier(\"protected\")) {\r", "-      _addAndIgnoreError(\"Interface methods cannot be made protected.  They must be public.\", that.getMav());\r", "-    }\r", "-    \r", "- //All interface methods are considered public by default.\r", "-    md.addModifier(\"public\"); //(if it was already public, won't be added)\r", "-    md.addModifier(\"abstract\"); //and all interface methods are abstract. \r", "-    String className = getUnqualifiedClassName(_symbolData.getName());\r", "-    if (className.equals(md.getName())) {\r", "-      _addAndIgnoreError(\"Only constructors can have the same name as the class they appear in, and constructors cannot appear in interfaces.\",\r", "-                         that);\r", "-    }\r", "-    else {\r", "-      _symbolData.addMethod(md);\r", "-    }\r", "-//    forAbstractMethodDefOnly(that);\r", "-  }\r", "+   */", "+  public void forAbstractMethodDef(AbstractMethodDef that) {", "+    forAbstractMethodDefDoFirst(that);", "+    if (prune(that)) return;", "+    ", "+    MethodData md = createMethodData(that, _symbolData);", "+    ", "+    //All interface methods are considered public by default: enforce this.", "+    if (md.hasModifier(\"private\")) {", "+      _addAndIgnoreError(\"Interface methods cannot be made private.  They must be public.\", that.getMav());", "+    }", "+    if (md.hasModifier(\"protected\")) {", "+      _addAndIgnoreError(\"Interface methods cannot be made protected.  They must be public.\", that.getMav());", "+    }", "+    ", "+ // All interface methods are considered public by default.", "+    md.addModifier(\"public\"); //(if it was already public, won't be added)", "+    md.addModifier(\"abstract\"); //and all interface methods are abstract. ", "+    String className = getUnqualifiedClassName(_symbolData.getName());", "+    if (className.equals(md.getName())) {", "+      _addAndIgnoreError(\"Only constructors can have the same name as the class they appear in, and constructors cannot appear in interfaces.\",", "+                         that);", "+    }", "+    else _symbolData.addMethod(md);", "+//    forAbstractMethodDefOnly(that);", "+  }"]}], "num": 19782}