{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cec2ca6517793c9e2c6d33283ffa3c72", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "04a566e1c2d75d7868cfafead36c1503", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyTypeChecker.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r     \r     public void testForConcreteMethodDef()", "signatureAfterChange": "          public void testForConcreteMethodDef()", "diff": ["-    \r", "-    public void testForConcreteMethodDef() {\r", "-      FormalParameter[] fps = new FormalParameter[] {\r", "-        new FormalParameter(JExprParser.NO_SOURCE_INFO, \r", "-                            new UninitializedVariableDeclarator(JExprParser.NO_SOURCE_INFO, \r", "-                                                              new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"double\"), \r", "-                                                              new Word (JExprParser.NO_SOURCE_INFO, \"field1\")),\r", "-                            false),\r", "-        new FormalParameter(JExprParser.NO_SOURCE_INFO, \r", "-                            new UninitializedVariableDeclarator(JExprParser.NO_SOURCE_INFO, \r", "-                                                              new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"boolean\"), \r", "-                                                              new Word (JExprParser.NO_SOURCE_INFO, \"field2\")),\r", "-                            false)};\r", "-      ConcreteMethodDef cmd = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, \r", "-                                                    _packageMav, \r", "-                                                    new TypeParameter[0], \r", "-                                                    new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), \r", "-                                                    new Word(JExprParser.NO_SOURCE_INFO, \"methodName\"),\r", "-                                                    fps,\r", "-                                                    new ReferenceType[0], \r", "-                                                    new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {\r", "-        new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5) )}));\r", "-      MethodData md = new MethodData(\"methodName\", \r", "-                                     _packageMav, \r", "-                                     new TypeParameter[0], \r", "-                                     SymbolData.INT_TYPE, \r", "-                                     new VariableData[] { new VariableData(SymbolData.DOUBLE_TYPE), new VariableData(SymbolData.BOOLEAN_TYPE) },\r", "-                                     new String[0],\r", "-                                     _sd1,\r", "-                                     null); // no SourceInfo\r", "-      _sd1.addMethod(md);\r", "-      cmd.visit(_cbbtc);\r", "-      assertEquals(\"There should be no errors.\", 0, errors.size());\r", "-      \r", "-      cmd = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, \r", "-                                                    _packageMav, \r", "-                                                    new TypeParameter[0], \r", "-                                                    new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), \r", "-                                                    new Word(JExprParser.NO_SOURCE_INFO, \"Selma\"),\r", "-                                                    fps,\r", "-                                                    new ReferenceType[0], \r", "-                                                    new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {\r", "-                                                          new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, \r", "-                                                                                   new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5))}));\r", "-      \r", "-      try {\r", "-        cmd.visit(_cbbtc);\r", "-        fail(\"Should have thrown a RuntimeException because there's no method named Selma.\");\r", "-      }\r", "-      catch (RuntimeException re) {\r", "-        assertEquals(\"The error message should be correct.\", \"Internal Program Error: The method Selma was not in the class i.like.monkey.  Please report this bug.\", re.getMessage());\r", "-      }\r", "-      \r", "-      \r", "-      //Check that an uninitialized variable is caught:\r", "-      PrimitiveType intt = new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\");\r", "-      UninitializedVariableDeclarator uvd = new UninitializedVariableDeclarator(JExprParser.NO_SOURCE_INFO, intt, new Word(JExprParser.NO_SOURCE_INFO, \"i\"));\r", "-\r", "-      Statement s = new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")));\r", "-      ConcreteMethodDef cmd0 = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, _publicMav, new TypeParameter[0], intt,\r", "-                                                    new Word(JExprParser.NO_SOURCE_INFO, \"invalidMethod\"), new FormalParameter[0],\r", "-                                                    new ReferenceType[0], new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {new VariableDeclaration(JExprParser.NO_SOURCE_INFO,  _packageMav, new UninitializedVariableDeclarator[]{uvd}), s}));\r", "-      VariableData vd = new VariableData(\"i\", _packageMav, SymbolData.INT_TYPE, false, null);\r", "-      MethodData md0 = new MethodData(\"invalidMethod\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE,\r", "-                                     new VariableData[0], new String[0], _sd1, cmd0);\r", "-      _sd1.addMethod(md0);\r", "-      vd.setEnclosingData(md0);\r", "-      md0.addVar(vd);\r", "-      \r", "-      _cbbtc = new ClassBodyTypeChecker(_sd1, _cbbtc._file, _cbbtc._package, _cbbtc._importedFiles, _cbbtc._importedPackages, new LinkedList<VariableData>(), new LinkedList<Pair<SymbolData, JExpression>>());\r", "-      _cbbtc._targetVersion= JavaVersion.JAVA_5;\r", "-      cmd0.visit(_cbbtc);\r", "-      assertEquals(\"There should be 1 error\", 1, errors.size());\r", "-      assertEquals(\"The error message should be correct\", \"You cannot use i because it may not have been given a value\", errors.get(0).getFirst());\r", "-\r", "-\r", "-      \r", "-      //Check that the lexical scope of an if then statement is handled correctly.\r", "-      Expression te = new LessThanExpression(JExprParser.NO_SOURCE_INFO,\r", "-                                             new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"j\")),\r", "-                                             new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5));\r", "-      Statement ts = new ExpressionStatement(JExprParser.NO_SOURCE_INFO, new SimpleAssignmentExpression(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")), new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 10)));\r", "-      IfThenStatement ift = new IfThenStatement(JExprParser.NO_SOURCE_INFO, te, ts);\r", "-      \r", "-      \r", "-      FormalParameter param = new FormalParameter(JExprParser.NO_SOURCE_INFO, new UninitializedVariableDeclarator(JExprParser.NO_SOURCE_INFO, intt, new Word(JExprParser.NO_SOURCE_INFO, \"j\")), false);\r", "-      BracedBody bb = new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {new VariableDeclaration(JExprParser.NO_SOURCE_INFO,  _packageMav, new UninitializedVariableDeclarator[]{uvd}), ift,\r", "-        new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")))});\r", "-      \r", "-      ConcreteMethodDef cmd1 = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, _publicMav, new TypeParameter[0], \r", "-                                   intt, new Word(JExprParser.NO_SOURCE_INFO, \"myMethod\"), new FormalParameter[] {param}, \r", "-                                                     new ReferenceType[0], bb);\r", "-\r", "-      VariableData vd1 = new VariableData(\"j\", _packageMav, SymbolData.INT_TYPE, true, null);\r", "-      VariableData vd2 = new VariableData(\"i\", _packageMav, SymbolData.INT_TYPE, false, null);\r", "-      MethodData md1 = new MethodData(\"myMethod\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE,\r", "-                                     new VariableData[] {vd1}, new String[0], _sd1, cmd1);\r", "-      _sd1.addMethod(md1);\r", "-      vd1.setEnclosingData(md1);\r", "-      vd2.setEnclosingData(md1);\r", "-      md1.addVar(vd1);\r", "-      md1.addVar(vd2);\r", "-      \r", "-      _cbbtc = new ClassBodyTypeChecker(_sd1, _cbbtc._file, _cbbtc._package, _cbbtc._importedFiles, _cbbtc._importedPackages, new LinkedList<VariableData>(), new LinkedList<Pair<SymbolData, JExpression>>());\r", "-      cmd1.visit(_cbbtc);\r", "-      \r", "-      assertEquals(\"There should be 2 errors\", 2, errors.size());\r", "-      assertEquals(\"The error message should be correct\", \"You cannot use i because it may not have been given a value\", errors.get(1).getFirst());\r", "-      \r", "-      //Check that a final variable cannot be reassigned to\r", "-      s = new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")));\r", "-      VariableDeclaration i = new VariableDeclaration(JExprParser.NO_SOURCE_INFO,  _packageMav, new UninitializedVariableDeclarator[]{uvd});\r", "-      ExpressionStatement se = new ExpressionStatement(JExprParser.NO_SOURCE_INFO, new SimpleAssignmentExpression(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")), new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 2)));\r", "-      ExpressionStatement se2 = new ExpressionStatement(JExprParser.NO_SOURCE_INFO, new SimpleAssignmentExpression(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")), new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5)));\r", "-      \r", "-      BracedBody b = new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {i, se, se2, s});\r", "-      ConcreteMethodDef cmd2 = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, _publicMav, new TypeParameter[0], intt,\r", "-                                                    new Word(JExprParser.NO_SOURCE_INFO, \"doubleAssignmentMethod\"), new FormalParameter[0],\r", "-                                                    new ReferenceType[0], b);\r", "-      \r", "-      VariableData vdi = new VariableData(\"i\", _finalMav, SymbolData.INT_TYPE, false, null);\r", "-      MethodData md2 = new MethodData(\"doubleAssignmentMethod\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE,\r", "-                                     new VariableData[0], new String[0], _sd1, cmd2);\r", "-      _sd1.addMethod(md2);\r", "-      vdi.setEnclosingData(md2);\r", "-\r", "-      md2.addVar(vdi);\r", "-\r", "-      _cbbtc = new ClassBodyTypeChecker(_sd1, _cbbtc._file, _cbbtc._package, _cbbtc._importedFiles, _cbbtc._importedPackages, new LinkedList<VariableData>(), new LinkedList<Pair<SymbolData, JExpression>>());\r", "-      cmd2.visit(_cbbtc);\r", "-      assertEquals(\"There should be 3 errors\", 3, errors.size());\r", "-      assertEquals(\"The error message should be correct\", \"You cannot assign a value to i because it is immutable and has already been given a value\", errors.get(2).getFirst());\r", "- \r", "-       \r", "-      //test that if a variable is assigned in a branch of the if, and then returned, it is okay.\r", "-      te = new LessThanExpression(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"j\")),\r", "-       new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5));\r", "-      Statement assignStatement = new ExpressionStatement(JExprParser.NO_SOURCE_INFO, new SimpleAssignmentExpression(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")), new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 10)));\r", "-      Statement returnStatement = new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")));\r", "-      ts = new Block(JExprParser.NO_SOURCE_INFO, new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {assignStatement, returnStatement}));\r", "-      ift = new IfThenStatement(JExprParser.NO_SOURCE_INFO, te, ts);\r", "-      \r", "-      bb = new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {new VariableDeclaration(JExprParser.NO_SOURCE_INFO,  _packageMav, new UninitializedVariableDeclarator[]{uvd}), \r", "-        ift, \r", "-        new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, \r", "-                                 new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5))});\r", "-      \r", "-      ConcreteMethodDef cmd4 = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, _publicMav, new TypeParameter[0], \r", "-                                   intt, new Word(JExprParser.NO_SOURCE_INFO, \"myMethod3\"), new FormalParameter[] {param}, \r", "-                                   new ReferenceType[0], bb);\r", "-\r", "-      vd1 = new VariableData(\"j\", _packageMav, SymbolData.INT_TYPE, true, null);\r", "-      vd2 = new VariableData(\"i\", _packageMav, SymbolData.INT_TYPE, false, null);\r", "-      md1 = new MethodData(\"myMethod3\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE,\r", "-                           new VariableData[] {vd1}, new String[0], _sd1, cmd4);\r", "-      md1.addVar(vd1);\r", "-      md1.addVar(vd2);\r", "-      \r", "-      vd1.setEnclosingData(md1);\r", "-      vd2.setEnclosingData(md1);\r", "-\r", "-      \r", "-      _sd1.addMethod(md1);\r", "-      _cbbtc = new ClassBodyTypeChecker(_sd1, _cbbtc._file, _cbbtc._package, _cbbtc._importedFiles, _cbbtc._importedPackages, new LinkedList<VariableData>(), new LinkedList<Pair<SymbolData, JExpression>>());\r", "-      \r", "-\r", "-      md1.addBlock(new BlockData(md1));\r", "-      cmd4.visit(_cbbtc);\r", "-      assertEquals(\"There should be 3 errors\", 3, errors.size());\r", "-    }\r", "+    ", "+    public void testForConcreteMethodDef() {", "+      FormalParameter[] fps = new FormalParameter[] {", "+        new FormalParameter(JExprParser.NO_SOURCE_INFO, ", "+                            new UninitializedVariableDeclarator(JExprParser.NO_SOURCE_INFO, ", "+                                                              new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"double\"), ", "+                                                              new Word (JExprParser.NO_SOURCE_INFO, \"field1\")),", "+                            false),", "+        new FormalParameter(JExprParser.NO_SOURCE_INFO, ", "+                            new UninitializedVariableDeclarator(JExprParser.NO_SOURCE_INFO, ", "+                                                              new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"boolean\"), ", "+                                                              new Word (JExprParser.NO_SOURCE_INFO, \"field2\")),", "+                            false)};", "+      ConcreteMethodDef cmd = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, ", "+                                                    _packageMav, ", "+                                                    new TypeParameter[0], ", "+                                                    new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), ", "+                                                    new Word(JExprParser.NO_SOURCE_INFO, \"methodName\"),", "+                                                    fps,", "+                                                    new ReferenceType[0], ", "+                                                    new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {", "+        new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5) )}));", "+      MethodData md = new MethodData(\"methodName\", ", "+                                     _packageMav, ", "+                                     new TypeParameter[0], ", "+                                     SymbolData.INT_TYPE, ", "+                                     new VariableData[] { new VariableData(SymbolData.DOUBLE_TYPE), new VariableData(SymbolData.BOOLEAN_TYPE) },", "+                                     new String[0],", "+                                     _sd1,", "+                                     null); // no SourceInfo", "+      _sd1.addMethod(md);", "+      cmd.visit(_cbbtc);", "+      assertEquals(\"There should be no errors.\", 0, errors.size());", "+      ", "+      cmd = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, ", "+                                                    _packageMav, ", "+                                                    new TypeParameter[0], ", "+                                                    new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), ", "+                                                    new Word(JExprParser.NO_SOURCE_INFO, \"Selma\"),", "+                                                    fps,", "+                                                    new ReferenceType[0], ", "+                                                    new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {", "+                                                          new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, ", "+                                                                                   new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5))}));", "+      ", "+      try {", "+        cmd.visit(_cbbtc);", "+        fail(\"Should have thrown a RuntimeException because there's no method named Selma.\");", "+      }", "+      catch (RuntimeException re) {", "+        assertEquals(\"The error message should be correct.\", \"Internal Program Error: The method Selma was not in the class i.like.monkey.  Please report this bug.\", re.getMessage());", "+      }", "+      ", "+      ", "+      //Check that an uninitialized variable is caught:", "+      PrimitiveType intt = new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\");", "+      UninitializedVariableDeclarator uvd = new UninitializedVariableDeclarator(JExprParser.NO_SOURCE_INFO, intt, new Word(JExprParser.NO_SOURCE_INFO, \"i\"));", "+", "+      Statement s = new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")));", "+      ConcreteMethodDef cmd0 = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, _publicMav, new TypeParameter[0], intt,", "+                                                    new Word(JExprParser.NO_SOURCE_INFO, \"invalidMethod\"), new FormalParameter[0],", "+                                                    new ReferenceType[0], new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {new VariableDeclaration(JExprParser.NO_SOURCE_INFO,  _packageMav, new UninitializedVariableDeclarator[]{uvd}), s}));", "+      VariableData vd = new VariableData(\"i\", _packageMav, SymbolData.INT_TYPE, false, null);", "+      MethodData md0 = new MethodData(\"invalidMethod\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE,", "+                                     new VariableData[0], new String[0], _sd1, cmd0);", "+      _sd1.addMethod(md0);", "+      vd.setEnclosingData(md0);", "+      md0.addVar(vd);", "+      ", "+      _cbbtc = new ClassBodyTypeChecker(_sd1, _cbbtc._file, _cbbtc._package, _cbbtc._importedFiles, _cbbtc._importedPackages, new LinkedList<VariableData>(), new LinkedList<Pair<SymbolData, JExpression>>());", "+      cmd0.visit(_cbbtc);", "+      assertEquals(\"There should be 1 error\", 1, errors.size());", "+      assertEquals(\"The error message should be correct\", \"You cannot use i because it may not have been given a value\", errors.get(0).getFirst());", "+", "+", "+      ", "+      //Check that the lexical scope of an if then statement is handled correctly.", "+      Expression te = new LessThanExpression(JExprParser.NO_SOURCE_INFO,", "+                                             new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"j\")),", "+                                             new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5));", "+      Statement ts = new ExpressionStatement(JExprParser.NO_SOURCE_INFO, new SimpleAssignmentExpression(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")), new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 10)));", "+      IfThenStatement ift = new IfThenStatement(JExprParser.NO_SOURCE_INFO, te, ts);", "+      ", "+      ", "+      FormalParameter param = new FormalParameter(JExprParser.NO_SOURCE_INFO, new UninitializedVariableDeclarator(JExprParser.NO_SOURCE_INFO, intt, new Word(JExprParser.NO_SOURCE_INFO, \"j\")), false);", "+      BracedBody bb = new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {new VariableDeclaration(JExprParser.NO_SOURCE_INFO,  _packageMav, new UninitializedVariableDeclarator[]{uvd}), ift,", "+        new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")))});", "+      ", "+      ConcreteMethodDef cmd1 = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, _publicMav, new TypeParameter[0], ", "+                                   intt, new Word(JExprParser.NO_SOURCE_INFO, \"myMethod\"), new FormalParameter[] {param}, ", "+                                                     new ReferenceType[0], bb);", "+", "+      VariableData vd1 = new VariableData(\"j\", _packageMav, SymbolData.INT_TYPE, true, null);", "+      VariableData vd2 = new VariableData(\"i\", _packageMav, SymbolData.INT_TYPE, false, null);", "+      MethodData md1 = new MethodData(\"myMethod\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE,", "+                                     new VariableData[] {vd1}, new String[0], _sd1, cmd1);", "+      _sd1.addMethod(md1);", "+      vd1.setEnclosingData(md1);", "+      vd2.setEnclosingData(md1);", "+      md1.addVar(vd1);", "+      md1.addVar(vd2);", "+      ", "+      _cbbtc = new ClassBodyTypeChecker(_sd1, _cbbtc._file, _cbbtc._package, _cbbtc._importedFiles, _cbbtc._importedPackages, new LinkedList<VariableData>(), new LinkedList<Pair<SymbolData, JExpression>>());", "+      cmd1.visit(_cbbtc);", "+      ", "+      assertEquals(\"There should be 2 errors\", 2, errors.size());", "+      assertEquals(\"The error message should be correct\", \"You cannot use i because it may not have been given a value\", errors.get(1).getFirst());", "+      ", "+      //Check that a final variable cannot be reassigned to", "+      s = new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")));", "+      VariableDeclaration i = new VariableDeclaration(JExprParser.NO_SOURCE_INFO,  _packageMav, new UninitializedVariableDeclarator[]{uvd});", "+      ExpressionStatement se = new ExpressionStatement(JExprParser.NO_SOURCE_INFO, new SimpleAssignmentExpression(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")), new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 2)));", "+      ExpressionStatement se2 = new ExpressionStatement(JExprParser.NO_SOURCE_INFO, new SimpleAssignmentExpression(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")), new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5)));", "+      ", "+      BracedBody b = new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {i, se, se2, s});", "+      ConcreteMethodDef cmd2 = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, _publicMav, new TypeParameter[0], intt,", "+                                                    new Word(JExprParser.NO_SOURCE_INFO, \"doubleAssignmentMethod\"), new FormalParameter[0],", "+                                                    new ReferenceType[0], b);", "+      ", "+      VariableData vdi = new VariableData(\"i\", _finalMav, SymbolData.INT_TYPE, false, null);", "+      MethodData md2 = new MethodData(\"doubleAssignmentMethod\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE,", "+                                     new VariableData[0], new String[0], _sd1, cmd2);", "+      _sd1.addMethod(md2);", "+      vdi.setEnclosingData(md2);", "+", "+      md2.addVar(vdi);", "+", "+      _cbbtc = new ClassBodyTypeChecker(_sd1, _cbbtc._file, _cbbtc._package, _cbbtc._importedFiles, _cbbtc._importedPackages, new LinkedList<VariableData>(), new LinkedList<Pair<SymbolData, JExpression>>());", "+      cmd2.visit(_cbbtc);", "+      assertEquals(\"There should be 3 errors\", 3, errors.size());", "+      assertEquals(\"The error message should be correct\", \"You cannot assign a value to i because it is immutable and has already been given a value\", errors.get(2).getFirst());", "+ ", "+       ", "+      //test that if a variable is assigned in a branch of the if, and then returned, it is okay.", "+      te = new LessThanExpression(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"j\")),", "+       new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5));", "+      Statement assignStatement = new ExpressionStatement(JExprParser.NO_SOURCE_INFO, new SimpleAssignmentExpression(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")), new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 10)));", "+      Statement returnStatement = new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, new SimpleNameReference(JExprParser.NO_SOURCE_INFO, new Word(JExprParser.NO_SOURCE_INFO, \"i\")));", "+      ts = new Block(JExprParser.NO_SOURCE_INFO, new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {assignStatement, returnStatement}));", "+      ift = new IfThenStatement(JExprParser.NO_SOURCE_INFO, te, ts);", "+      ", "+      bb = new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[] {new VariableDeclaration(JExprParser.NO_SOURCE_INFO,  _packageMav, new UninitializedVariableDeclarator[]{uvd}), ", "+        ift, ", "+        new ValueReturnStatement(JExprParser.NO_SOURCE_INFO, ", "+                                 new IntegerLiteral(JExprParser.NO_SOURCE_INFO, 5))});", "+      ", "+      ConcreteMethodDef cmd4 = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, _publicMav, new TypeParameter[0], ", "+                                   intt, new Word(JExprParser.NO_SOURCE_INFO, \"myMethod3\"), new FormalParameter[] {param}, ", "+                                   new ReferenceType[0], bb);", "+", "+      vd1 = new VariableData(\"j\", _packageMav, SymbolData.INT_TYPE, true, null);", "+      vd2 = new VariableData(\"i\", _packageMav, SymbolData.INT_TYPE, false, null);", "+      md1 = new MethodData(\"myMethod3\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE,", "+                           new VariableData[] {vd1}, new String[0], _sd1, cmd4);", "+      md1.addVar(vd1);", "+      md1.addVar(vd2);", "+      ", "+      vd1.setEnclosingData(md1);", "+      vd2.setEnclosingData(md1);", "+", "+      ", "+      _sd1.addMethod(md1);", "+      _cbbtc = new ClassBodyTypeChecker(_sd1, _cbbtc._file, _cbbtc._package, _cbbtc._importedFiles, _cbbtc._importedPackages, new LinkedList<VariableData>(), new LinkedList<Pair<SymbolData, JExpression>>());", "+      ", "+", "+      md1.addBlock(new BlockData(md1));", "+      cmd4.visit(_cbbtc);", "+      assertEquals(\"There should be 3 errors\", 3, errors.size());", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6ae1e0a62b728625f39b10a1b865b79a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "c7ce54f2435a198c543bef7b35866738d8690d46", "commitAfterChange": "f9b3ce896f60a5fa583a421b5b2bb827822b30df", "methodNumberBeforeChange": 100, "methodNumberAfterChange": 99, "signatureBeforeChange": "               public void testGetSymbolDataHelper()", "signatureAfterChange": "               public void testGetSymbolDataHelper()", "diff": ["+      sd2.setIsContinuation(false);", "-      assertEquals(\"should find the resolved symbol data in the symbol table\", sd2, ", "-                   _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "+      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true);", "+//      System.err.println(\"result for 'fully.qualifed.Woah' is \" + result);", "+      assertEquals(\"should find the resolved symbol data in the symbol table\", sd2, result);", "-      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, true, true, true);", "+//      System.err.println(\"_llv.getSymbolData for fully.qualified.Woah = \" +", "+//                         _llv.getSymbolDataHelper(\"fully.qualified.Woah\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "+     ", "+      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, false, true, true);", "-      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, true, true, true);", "+      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, false, true, true);", "-      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, true, true, true);", "-      assertEquals(\"Should return sd2, now resolved.\", sd2, result);", "-      assertFalse(\"sd2 should now be resolved\", sd2.isContinuation());", "+      // The following \"test\" forces the definition of \"Woah\" to be retrieved from the file system but THERE IS NO CLASS", "+      // FILE so the file system search returns null!", "+//      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true);", "+//      assertEquals(\"Should return sd2, now resolved.\", sd2, result);", "+//      assertFalse(\"sd2 should now be resolved\", sd2.isContinuation());", "+      ", "+      sd2.setIsContinuation(false);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9336dae399740327b85d3701aa74b9bb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/indent/Indenter.java", "commitBeforeChange": "cdec0e83ccb73131518824857180629f938997fc", "commitAfterChange": "a661a8e595eaba533f043d38dbbb891fcd8bf32f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "   public void buildTree()", "signatureAfterChange": "   public void buildTree()", "diff": ["+      rule35 = new ActionStartCurrStmtPlus(oneLevel),", "+      rule34 = new ActionStartStmtOfBracePlus(oneLevel),", "+      rule33 = rule35,", "+      rule32 = new QuestionExistsCharInStmt('?', ':', rule33, rule34),", "+      rule31 = new QuestionLineContains(':', rule32, rule35),", "+      rule30 = new ActionStartCurrStmtPlus(\"\"),", "+      rule29 = new QuestionCurrLineStartsWithSkipComments(\"{\", rule30, rule31),", "+      rule28 = new ActionStartPrevStmtPlus(\"\"),", "+      rule27 = rule34,", "+      rule26 = rule28,", "+      rule25 = new QuestionExistsCharInStmt('?', ':', rule26, rule27),", "+      rule24 = new QuestionLineContains(':', rule25, rule28),", "+      rule23 = new QuestionStartingNewStmt(rule24, rule29),", "+      rule22 = rule23,", "+      rule21 = rule34,", "+      rule20 = new QuestionStartAfterOpenBrace(rule21, rule22),", "+      rule19 = new ActionStartStmtOfBracePlus(\"\"),", "+      rule18 = new QuestionCurrLineStartsWithSkipComments(\"}\", rule19, rule20),", "+      rule17 = new QuestionBraceIsCurly(rule18, rule23),", "+      rule16 = new ActionBracePlus(\" \" + oneLevel),", "+      rule15 = new ActionBracePlus(\" \"),", "+      rule14 = new QuestionNewParenPhrase(rule15, rule16),", "+      rule13 = new QuestionBraceIsParenOrBracket(rule14, rule17),", "+      rule12 = new ActionStartPrevLinePlus(\"\"),", "+      rule11 = rule12,", "+      rule10 = new ActionStartPrevLinePlus(\"* \"),", "+      rule09 = new QuestionCurrLineEmpty(rule10, rule11),", "+      rule08 = rule12,          ", "+      rule07 = new QuestionCurrLineStartsWith(\"*\", rule08, rule09),", "+      rule06 = new QuestionPrevLineStartsWith(\"*\", rule07, rule12),", "-      rule03 = new QuestionCurrLineEmpty(rule04, rule05);", "-    ", "-    IndentRule ", "-      rule33 = new ActionStartCurrStmtPlus(oneLevel),", "-      rule32 = new ActionStartStmtOfBracePlus(oneLevel),", "-      rule31 = rule33,", "-      rule30 = new QuestionExistsCharInStmt('?', ':', rule31, rule32),", "-      rule29 = new QuestionLineContains(':', rule30, rule33),", "-      rule28 = new ActionStartCurrStmtPlus(\"\"),", "-      rule27 = new QuestionCurrLineStartsWithSkipComments(\"{\", rule28, rule29),", "-      rule26 = new ActionStartPrevStmtPlus(\"\"),", "-      rule25 = rule32,", "-      rule24 = rule26,", "-      rule23 = new QuestionExistsCharInStmt('?', ':', rule24, rule25),", "-      rule22 = new QuestionLineContains(':', rule23, rule26),", "-      rule21 = new ActionStartStmtOfBracePlus(\"\"),", "-      rule19 = new QuestionStartingNewStmt(rule22, rule27),", "-      rule18 = rule19,", "-      rule17 = rule32,", "-      rule16 = new QuestionStartAfterOpenBrace(rule17, rule18),", "-      rule20 = new QuestionCurrLineStartsWithSkipComments(\"}\", rule21, rule16),", "-      rule15 = new QuestionBraceIsCurly(rule20, rule19),", "-      rule14 = new ActionBracePlus(\" \" + oneLevel),", "-      rule13 = new ActionBracePlus(\" \"),", "-      rule12 = new QuestionNewParenPhrase(rule13, rule14),", "-      rule11 = new QuestionBraceIsParenOrBracket(rule12, rule15),", "-      rule10 = new ActionStartPrevLinePlus(\"\"),", "-      rule9b = rule10,", "-      rule9a = new ActionStartPrevLinePlus(\"* \"),", "-      rule09 = new QuestionCurrLineEmpty(rule9a, rule9b),", "-      rule08 = rule10,          ", "-      rule07 = new QuestionCurrLineStartsWith(\"*\", rule08, rule09),", "-      rule06 = new QuestionPrevLineStartsWith(\"*\", rule07, rule10),", "+      rule03 = new QuestionCurrLineEmpty(rule04, rule05),", "-      rule01 = new QuestionInsideComment(rule02, rule11);", "+      rule01 = new QuestionInsideComment(rule02, rule13);"]}], "num": 26831}