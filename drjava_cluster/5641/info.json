{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4e5349aaa3c41dce029f5930f0bd1940", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "01b83260d84aa3c78a46e849be101041", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/MainFrame.java", "commitBeforeChange": "5c83f089e25fccbca0e9bbad3fc54a6c66548714", "commitAfterChange": "5a2afd347f47a6bc08b7f21fb8ab49faa2b374ae", "methodNumberBeforeChange": 554, "methodNumberAfterChange": 555, "signatureBeforeChange": "   private JMenu _setUpDebugMenu(int mask)", "signatureAfterChange": "   private JMenu _setUpDebugMenu(int mask)", "diff": ["-    _debuggerEnabledMenuItem = _newCheckBoxMenuItem(_toggleDebuggerAction);", "-    _debuggerEnabledMenuItem.setSelected(false);", "-    _setMenuShortcut(_debuggerEnabledMenuItem, _toggleDebuggerAction, KEY_DEBUG_MODE_TOGGLE);", "-    debugMenu.add(_debuggerEnabledMenuItem);", "+    JMenuItem tempDebuggerEnabledMenuItem = _newCheckBoxMenuItem(_toggleDebuggerAction);", "+    tempDebuggerEnabledMenuItem.setSelected(false);", "+    _setMenuShortcut(tempDebuggerEnabledMenuItem, _toggleDebuggerAction, KEY_DEBUG_MODE_TOGGLE);", "+    debugMenu.add(tempDebuggerEnabledMenuItem);", "+    if (_debuggerEnabledMenuItem==null) {", "+      // assign the first time", "+      _debuggerEnabledMenuItem = tempDebuggerEnabledMenuItem;", "+    }", "+    else {", "+      // otherwise link this item to the first item", "+      final WeakReference<JMenuItem> weakRef = new WeakReference<JMenuItem>(tempDebuggerEnabledMenuItem);", "+      _debuggerEnabledMenuItem.addItemListener(new ItemListener() {", "+        public void itemStateChanged(ItemEvent e) {", "+          JMenuItem temp = weakRef.get();", "+          if (temp!=null) {", "+            temp.setSelected(_debuggerEnabledMenuItem.isSelected());", "+          }", "+          else {", "+            // weak reference cleared, remove this listener", "+            _debuggerEnabledMenuItem.removeItemListener(this);", "+          }", "+        }", "+      });", "+    }", "+    ", "-    _automaticTraceMenuItem = _newCheckBoxMenuItem(_automaticTraceDebugAction);", "-    _setMenuShortcut(_automaticTraceMenuItem, _automaticTraceDebugAction, KEY_DEBUG_AUTOMATIC_TRACE);", "-    debugMenu.add(_automaticTraceMenuItem);", "+    ", "+    JMenuItem tempAutomaticTraceMenuItem = _newCheckBoxMenuItem(_automaticTraceDebugAction);", "+    _setMenuShortcut(tempAutomaticTraceMenuItem, _automaticTraceDebugAction, KEY_DEBUG_AUTOMATIC_TRACE);", "+    debugMenu.add(tempAutomaticTraceMenuItem);", "+    if (_automaticTraceMenuItem==null) {", "+      // assign the first time", "+      _automaticTraceMenuItem = tempAutomaticTraceMenuItem;", "+    }", "+    else {", "+      // otherwise link this item to the first item", "+      final WeakReference<JMenuItem> weakRef = new WeakReference<JMenuItem>(tempAutomaticTraceMenuItem);", "+      _automaticTraceMenuItem.addItemListener(new ItemListener() {", "+        public void itemStateChanged(ItemEvent e) {", "+          JMenuItem temp = weakRef.get();", "+          if (temp!=null) {", "+            temp.setSelected(_automaticTraceMenuItem.isSelected());", "+          }", "+          else {", "+            // weak reference cleared, remove this listener", "+            _automaticTraceMenuItem.removeItemListener(this);", "+          }", "+        }", "+      });", "+    }", "-    _detachDebugFrameMenuItem = _newCheckBoxMenuItem(_detachDebugFrameAction);", "-    _detachDebugFrameMenuItem.setSelected(DrJava.getConfig().getSetting(DETACH_DEBUGGER));", "-    _setMenuShortcut(_detachDebugFrameMenuItem, _detachDebugFrameAction, KEY_DETACH_DEBUGGER);", "-    debugMenu.add(_detachDebugFrameMenuItem);", "-    ", "+    JMenuItem tempDetachDebugFrameMenuItem = _newCheckBoxMenuItem(_detachDebugFrameAction);", "+    tempDetachDebugFrameMenuItem.setSelected(DrJava.getConfig().getSetting(DETACH_DEBUGGER));", "+    _setMenuShortcut(tempDetachDebugFrameMenuItem, _detachDebugFrameAction, KEY_DETACH_DEBUGGER);", "+    debugMenu.add(tempDetachDebugFrameMenuItem);", "+    if (_detachDebugFrameMenuItem==null) {", "+      // assign the first time", "+      _detachDebugFrameMenuItem = tempDetachDebugFrameMenuItem;", "+    }", "+    else {", "+      // otherwise link this item to the first item", "+      final WeakReference<JMenuItem> weakRef = new WeakReference<JMenuItem>(tempDetachDebugFrameMenuItem);", "+      _detachDebugFrameMenuItem.addItemListener(new ItemListener() {", "+        public void itemStateChanged(ItemEvent e) {", "+          JMenuItem temp = weakRef.get();", "+          if (temp!=null) {", "+            temp.setSelected(_detachDebugFrameMenuItem.isSelected());", "+          }", "+          else {", "+            // weak reference cleared, remove this listener", "+            _detachDebugFrameMenuItem.removeItemListener(this);", "+          }", "+        }", "+      });", "+    }", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7e038f0fce6d6d3d0049f6d2eef31737", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "4b21424812450d42c0dde2aef3c483c11b298e24", "commitAfterChange": "ede26ceaad5c407d940ac773a5e7f457dc1f5187", "methodNumberBeforeChange": 53, "methodNumberAfterChange": 53, "signatureBeforeChange": "   public boolean isCastable(Type target, Type expT)", "signatureAfterChange": "   public boolean isDisjoint(final Type s, final Type t)", "diff": ["-  /** Determine if {@link #cast} would succeed given an expression of the given type */", "-  public boolean isCastable(Type target, Type expT) {", "-    try {", "-      Expression e = TypeUtil.makeEmptyExpression();", "-      NodeProperties.setType(e, expT);", "-      cast(target, e);", "-      return true;", "+  /** Whether two types are known to be disjoint.  (Standard version is implicitly defined in JLS 5.5.)  */", "+  public boolean isDisjoint(final Type s, final Type t) {", "+    // By default, returns null for arrays and classes", "+    abstract class Visitor extends TypeAbstractVisitor<Boolean> {", "+      private final Type _other;", "+      public Visitor(Type other) { _other = other; }", "+      public abstract boolean recur(Type that);", "+      @Override public Boolean forPrimitiveType(PrimitiveType that) {", "+        return !isSubtype(that, _other) && !isSubtype(_other, that);", "+      }", "+      @Override public Boolean forNullType(NullType that) {", "+        return !isSubtype(that, _other);", "+      }", "+      @Override public Boolean forArrayType(ArrayType that) { return null; }", "+      @Override public Boolean forClassType(ClassType that) { return null; }", "+      @Override public Boolean forIntersectionType(IntersectionType that) {", "+        for (Type elt : that.ofTypes()) { if (recur(elt)) return true; }", "+        return false;", "+      }", "+      @Override public Boolean forUnionType(UnionType that) {", "+        for (Type elt : that.ofTypes()) { if (!recur(elt)) return false; }", "+        return true;", "+      }", "+      @Override public Boolean forVariableType(VariableType that) {", "+        // TODO: to be correct, we would need to recur (checked by a RecursionStack)", "+        return false;", "+      }", "+      @Override public Boolean forTopType(TopType s) { return false; }", "+      @Override public Boolean forBottomType(BottomType s) { return true; }", "-    catch (UnsupportedConversionException e) { return false; }", "+    ", "+    Boolean sResult = s.apply(new Visitor(t) {", "+      public boolean recur(Type that) { return isDisjoint(that, t); }", "+    });", "+    if (sResult != null) { return sResult; }", "+    else {", "+      return t.apply(new Visitor(s) {", "+        public boolean recur(Type that) { return isDisjoint(s, that); }", "+        @Override public Boolean forArrayType(ArrayType t) {", "+          if (s instanceof ArrayType) { return isDisjoint(((ArrayType) s).ofType(), t.ofType()); }", "+          else { return !isSubtype(t, s); }", "+        }", "+        @Override public Boolean forClassType(ClassType t) {", "+          if (s instanceof ArrayType) { return !isSubtype(s, t); }", "+          else {", "+            ClassType sAsClass = (ClassType) s;", "+            if (sAsClass.ofClass().isFinal() || t.ofClass().isFinal() ||", "+                (!sAsClass.ofClass().isInterface() && !t.ofClass().isInterface())) {", "+              // either one of them is a final class or both are non-final classes", "+              if (!isSubtype(s, erase(t)) && !isSubtype(t, erase(s))) { return true; }", "+            }", "+            // TODO: The JLS also checks for disjoint type arguments (comparing *all* common superclasses)", "+            return false;", "+          }", "+        }", "+      });", "+    }"]}], "num": 5641}