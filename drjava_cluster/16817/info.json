{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4f3aac6fdf7bb102f94de5417b90438d", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "307b9bbc239b4658e879140f27a0f3f0", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "24e790b85d3a1a29de15955ca1ba9200a6865f83", "commitAfterChange": "4ceb386773fd5eb837ddcd34820c563b6c3c20cb", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 65, "signatureBeforeChange": "   private void  javadoc_1_3(String[] args) throws IOException, JavadocException", "signatureAfterChange": "   private boolean javadoc_1_3(String[] args)        throws IOException, ClassNotFoundException, InterruptedException", "diff": ["-  private void  javadoc_1_3(String[] args) throws IOException, JavadocException {", "-    final String JAVADOC_CLASS = \"com.sun.tools.javadoc.Main\" ;", "-    Process javadocProcess = null;", "-    boolean failed = true;", "-    try {", "-      Class.forName(JAVADOC_CLASS);", "-      javadocProcess =  ExecJVM.runJVMPropogateClassPath(JAVADOC_CLASS, args);", "-      failed = false;", "-    }", "-    catch (ClassNotFoundException cnfe) {", "-    }", "-    catch (UnsupportedClassVersionError ucve) {", "-    }", "+  private boolean javadoc_1_3(String[] args) ", "+      throws IOException, ClassNotFoundException, InterruptedException {", "+    final String JAVADOC_CLASS = \"com.sun.tools.javadoc.Main\";", "+    Process javadocProcess;", "+    BufferedReader jdOut;", "+    BufferedReader jdErr;", "-    if (failed) {", "-      //If we get here, we will just have to try using the javadoc program", "-      //which is hopefully on the system path", "-      String[] fullArgs = new String[args.length + 1];", "-      fullArgs[0] = \"javadoc\";", "-      for(int a = 0; a < args.length; a++) {", "-        fullArgs[a + 1] = args[a];", "-      }", "-      javadocProcess =  Runtime.getRuntime().exec(fullArgs);", "-      //TODO: try/catch the previous line and prompt for javadoc's location", "-      //on failure....and even keep the location in the drjava config", "-    }", "+    Class.forName(JAVADOC_CLASS);", "+    javadocProcess =  ExecJVM.runJVMPropogateClassPath(JAVADOC_CLASS, args);", "-    //Get a handle on the streams that the process produces", "-    BufferedReader jdOut =", "-      new BufferedReader(new InputStreamReader(javadocProcess.getInputStream()));", "-    BufferedReader jdErr =", "-      new BufferedReader(new InputStreamReader (javadocProcess.getErrorStream()));", "+    System.err.println(\"javadoc started with args:\\n\" + Arrays.asList(args));", "+    // getInputStream actually gives us the stdout from the Process.", "+    jdOut = new BufferedReader(new InputStreamReader(javadocProcess.getInputStream()));", "+    jdErr = new BufferedReader(new InputStreamReader(javadocProcess.getErrorStream()));", "+    String sourceName = \"ExecJVM\";", "+    int value = -1;", "+    /* waitFor() call appears to block indefinitely in 1.4.1, because", "+     * the process will block if output buffers get full.", "+     * Yes, this is extremely retarded.", "+     */ ", "+//     value = javadocProcess.waitFor();", "+    ", "+    // We have to use a busy-wait and vent output buffers.", "+    LinkedList outLines = new LinkedList();", "+    LinkedList errLines = new LinkedList();", "+    String output;", "-    ", "-    //Loop until javadoc is done, putting its output on the console", "-      String output = jdOut.readLine();", "-      while (output != null){", "-        System.out.println(\"[javadoc] \" + output);", "-        output = jdOut.readLine();", "-      }", "-      ", "-      do {", "-        System.err.println(\"[javadoc] \" + output);", "-        output = jdErr.readLine();", "-      } while(output!= null);", "-", "-        int value = javadocProcess.exitValue();", "+        value = javadocProcess.exitValue();", "-        System.out.println(\"Javadoc finished with exit code \" + value);", "-        if (value != 0) {", "-          throw new JavadocException(\"Javadoc error:  finished with exit code \" + value);", "+      }", "+      catch (IllegalThreadStateException e) {", "+//          printProcessOutput(javadocProcess, \"debug!\", \"ExecJVM\");", "+        ventBuffers(jdOut, jdErr, outLines, errLines);", "+      }", "+    }", "+    ventBuffers(jdOut, jdErr, outLines, errLines);", "+    System.err.println(\"got past first waitFor.\");", "+     ", "+    // Unfortunately, javadoc returns 1 for normal errors and for exceptions.", "+    // We cannot tell them apart without parsing.", "+    ", "+    ", "+//     if (value != 0) {", "+//       // If we get here, we will just have to try using the javadoc program", "+//       // which is hopefully on the system path", "+//       if (CodeStatus.DEVELOPMENT) {", "+//         String msg = (\"Launching Javadoc with ExecJVM failed.  Messages:\");", "+//         printProcessOutput(javadocProcess, msg, \"ExecJVM\");", "+//         ", "+//         System.err.println(\"Attempting to launch Javadoc from command path.\");", "+//       }", "+//       ", "+//       String[] fullArgs = new String[args.length + 1];", "+//       fullArgs[0] = \"javadoc\";", "+//       //TODO: Use System.arraycopy() here.", "+//       for(int a = 0; a < args.length; a++) {", "+//         fullArgs[a + 1] = args[a];", "+//       }", "+//       javadocProcess =  Runtime.getRuntime().exec(fullArgs);", "+//       ", "+//       // TODO: try/catch the previous line and prompt for javadoc's location", "+//       // on failure....and even keep the location in the drjava config", "+//       // DON'T USE waitFor! (See above.)", "+// //       value = javadocProcess.waitFor();", "+//       ", "+//       if (value != 0) {", "+//         if (CodeStatus.DEVELOPMENT) {", "+//           String msg = (\"Launching Javadoc with Runtime.Exec failed.  Messages:\");", "+//           printProcessOutput(javadocProcess, msg, \"Runtime.Exec\");", "+//         }", "+//         ", "+//         // Handle the error condition at the caller!", "+//         CompilerError err = new CompilerError((\"finished with exit code \" + value), false);", "+//         _javadocErrorModel = new CompilerErrorModel(new CompilerError[] { err }, this);", "+//       }", "+//       // else we have a valid javadocProcess from Runtime.Exec - fall through.", "+//     }", "+//     // else or fall-through means we have a valid javadocProcess from ExecJVM or Runtime.Exec", "+    ", "+    ", "+    ArrayList errors = new ArrayList(0);", "+    ", "+    // We already know javadoc is done => process its error messages", "+//     String output;", "+    ", "+//     jdOut = new BufferedReader(new InputStreamReader(javadocProcess.getInputStream()));", "+//     jdErr = new BufferedReader(new InputStreamReader(javadocProcess.getErrorStream()));", "+    ", "+    // Ignore all of javadoc's inane jabber to stdout.", "+    // Maybe dump this to console while debugging?", "+//     output = jdOut.readLine();", "+//     System.out.println(\"[Javadoc stdout] \" + output);", "+//     while (output != null) {", "+//       System.out.println(\"[Javadoc stdout] \" + output);", "+//       output = jdOut.readLine();", "+//     }", "+    ", "+    // By this point, the Javadoc process is dead, so we can't block on reads.", "+//     output = jdErr.readLine();", "+//     while (output != null) {", "+//       final String EXCEPTION_INDICATOR = \"Exception: \";", "+// //         System.out.println(\"[javadoc raw error] \" + output);", "+//       ", "+//       int errStart;", "+//       // Check for the telltale signs of a thrown exception.", "+//       errStart = output.indexOf(EXCEPTION_INDICATOR);", "+//       if (errStart != -1) {", "+//         // If we found one, put the entirety of stderr in one CompilerError.", "+//         StringBuffer buf = new StringBuffer(2000);", "+//         do {", "+//           buf.append(output);", "+//           output = jdErr.readLine();", "+//         } while (output != null);", "+//         errors.add(new CompilerError(buf.toString(), false));", "+//       }", "+//       else {", "+//         CompilerError error = parseJavadocErrorLine(output);", "+//         if (error != null) {", "+//           errors.add(error);", "+// //           System.err.println(\"[javadoc err]\" + error);", "+//         }", "+//       }", "+//       output = jdErr.readLine();", "+//     }", "+    ", "+    final String EXCEPTION_INDICATOR = \"Exception: \";", "+    while (errLines.size() > 0) {", "+//         System.out.println(\"[javadoc raw error] \" + output);", "+      ", "+      output = (String) errLines.removeFirst();", "+      ", "+      int errStart;", "+      // Check for the telltale signs of a thrown exception.", "+      errStart = output.indexOf(EXCEPTION_INDICATOR);", "+      if (errStart != -1) {", "+        // If we found one, put the entirety of stderr in one CompilerError.", "+        StringBuffer buf = new StringBuffer(60 * errLines.size());", "+        do {", "+          buf.append(output);", "+          output = (String) errLines.removeFirst();", "+        } while (errLines.size() > 0);", "+        errors.add(new CompilerError(buf.toString(), false));", "+      }", "+      else {", "+        // Otherwise, parser for a normal error message.", "+        CompilerError error = parseJavadocErrorLine(output);", "+        if (error != null) {", "+          errors.add(error);", "+//           System.err.println(\"[javadoc err]\" + error);", "-      catch (IllegalThreadStateException itse) {", "-        done = false;", "-      }", "+    }", "+  ", "+    _javadocErrorModel = new CompilerErrorModel((CompilerError[])(errors.toArray(new CompilerError[0])), this);", "+    System.out.println(\"built javadoc error model\");", "+    return (errors.size() == 0);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c813170ab2debe628f9c08a82941296c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/DrJava.java", "commitBeforeChange": "47c398bb655e51c115c8c0eb3d0935db42834771", "commitAfterChange": "62776e907e3e6dddd6b4161559ae3b70f27cc2e5", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "    private static void createAndShowGUI(final String[] args)", "signatureAfterChange": "      public static void configureAndLoadDrJavaRoot(String[] args)", "diff": ["-", "-  private static void createAndShowGUI(final String[] args) {", "+  ", "+  public static void configureAndLoadDrJavaRoot(String[] args) {", "-      // handleCommandLineArgs will return true if the program should load", "+      // handleCommandLineArgs will return true if the DrJava should be loaded", "-        String configLAFName = _config.getSetting(LOOK_AND_FEEL);", "-        String currLAFName = UIManager.getLookAndFeel().getClass().getName();", "-        if (!configLAFName.equals(currLAFName)) UIManager.setLookAndFeel(configLAFName);", "-        ", "-        // Install L&F upgrades for windows XP from winlaf-0.5.1.jar", "-        // For more information see: https://winlaf.dev.java.net/release_0.5.html", "-//       net.java.plaf.LookAndFeelPatchManager.initialize();  ", "-                ", "-        // Don't use JSR14v20 if running with Java 1.5 because putting it on the bootclasspath causes DrJava to", "-        // hang on startup.", "-        _usingJSR14v20 = checkForJSR14v20() && ! System.getProperty(\"java.specification.version\").equals(\"1.5\");", "-", "+        // Check that compiler and debugger are available on classpath (including tools.jar location)", "- ", "-        // The MainFrame *must* be constructed after the compiler setup process has", "-        // occurred; otherwise, the list of compilers in the UI will be wrong.", "-        // At some point this should be fixed, which would involve making the", "-        // CompilerRegistry notify listeners when there is a change in the list of", "-        // available compilers.", "-", "-        final MainFrame mf = new MainFrame();", "-        // Make sure all uncaught exceptions are shown in an AWTExceptionHandler", "-        AWTExceptionHandler.setFrame(mf);", "-        System.setProperty(\"sun.awt.exception.handler\", \"edu.rice.cs.drjava.ui.AWTExceptionHandler\");", "-                ", "-        _openCommandLineFiles(mf, _filesToOpen);", "+        // Start the DrJava master JVM", "+        String pathSep = System.getProperty(\"path.separator\");", "+        String classPath = edu.rice.cs.util.FileOps.convertToAbsolutePathEntries(System.getProperty(\"java.class.path\"));", "-        /* setVibible is moved to the end of the eventqueue to be sure all files has finished loading and added to the", "-         * fileview before the MainFrame is set visible.  When this was not done, occassionally a NullPointerException ", "-         * was encountered on startup when specifying a file (ex: java -jar drjava.jar somefile.java)", "-         */", "-        SwingUtilities.invokeLater(new Runnable(){ public void run(){mf.setVisible(true);}});", "+        // Add tools.jar from preferences if specified", "+        classPath += pathSep;", "+        File toolsFromConfig = getConfig().getSetting(JAVAC_LOCATION);", "+        if (toolsFromConfig != FileOption.NULL_FILE) {", "+          classPath += toolsFromConfig.getAbsolutePath() + pathSep;", "+        }", "-        // redirect stdout to DrJava's console", "-        System.setOut(new PrintStream(new OutputStreamRedirector() {", "-          public void print(String s) { mf.getModel().systemOutPrint(s); }", "-        }));", "-", "-        // redirect stderr to DrJava's console", "-        System.setErr(new PrintStream(new OutputStreamRedirector() {", "-          public void print(String s) { mf.getModel().systemErrPrint(s); }", "-        }));", "-", "-        // Show debug console if enabled", "-        if (_showDrJavaDebugConsole) showDrJavaDebugConsole(mf);", "+        // Fall back on guesses from ToolsJarClassLoader", "+        classPath += ToolsJarClassLoader.getToolsJarClassPath();", "+        ", "+        File workDir = getConfig().getSetting(WORKING_DIRECTORY);", "+        if (workDir == null) workDir = FileOption.NULL_FILE;", "+        ", "+        // Add the string pathSep to _filesToOpen if _showDebugConsole is true", "+        if (_showDebugConsole) _filesToOpen.add(pathSep);  // THIS IS A KLUDGE TO PASS THIS BOOLEAN FLAG TO DrJava", "+        ", "+        String[] jvmArgs = _jmvArgs.toArray(new String[0]);", "+        String[] classArgs = _filesToOpen.toArray(new String[0]);", "+        ", "+        // Run a new copy of DrJava and exit", "+        try {", "+//          Utilities.showDebug(\"Starting DrJavaRoot with classArgs = \" + Arrays.toString(classArgs) + \"; classPath = \" + classPath + ", "+//                             \"; jvmArgs = \" + Arrays.toString(jvmArgs) + \"; workDir = \" + workDir);", "+          ExecJVM.runJVM(\"edu.rice.cs.drjava.DrJavaRoot\", classArgs, classPath, jvmArgs, workDir);", "+        }", "+        catch (IOException ioe) {", "+          // Display error", "+          final String[] text = {", "+            \"DrJava was unable to load its compiler and debugger.  Would you \",", "+            \"like to start DrJava without a compiler and debugger?\", \"\\nReason: \" + ioe.toString()", "+          };", "+          int result = JOptionPane.showConfirmDialog(null, text, \"Could Not Load Compiler and Debugger\",", "+                                                     JOptionPane.YES_NO_OPTION);", "+          if (result != JOptionPane.YES_OPTION) { System.exit(0); }", "+        }", "-      // Show any errors to the real System.err and in an AWTExceptionHandler", "-      _consoleErr.println(t.getClass().getName() + \": \" + t.getMessage());", "-      t.printStackTrace(_consoleErr);System.out.println(\"error thrown\");", "+      // Show any errors to the System.err and in an AWTExceptionHandler", "+      System.err.println(t.getClass().getName() + \": \" + t.getMessage());", "+      t.printStackTrace(System.err);System.out.println(\"error thrown\");"]}], "num": 16817}