{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "63e3e9983bc8e231d550e984a84fce49", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "302f28319529d3bc2e71ed968e88147f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/AdvancedLevelTest.java", "commitBeforeChange": "c7ce54f2435a198c543bef7b35866738d8690d46", "commitAfterChange": "f9b3ce896f60a5fa583a421b5b2bb827822b30df", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public void testSuccessful()", "signatureAfterChange": "   public void testSuccessful()", "diff": ["-   */", "+  /** Try some example files and make sure they can be converted without errors and that the resulting conversions are correct. */", "-    File[] testFiles = directory.listFiles(new FileFilter() {", "-      public boolean accept(File pathName) {", "-        return pathName.getAbsolutePath().endsWith(\".dj2\");", "-      }", "-    });", "-    ", "-    ", "+", "+    _log.log(\"Running testSuccessful\");", "+    File[] files1 = dir1.listFiles(dj2Filter);", "+    File[] files2 = dir2.listFiles(dj2Filter);", "+    File[] files3 = dir3.listFiles(dj2Filter);", "+", "+    // testFiles = files1 || files2 || files3; this computation is ugly in Java because Java has no functional lists", "+    int len1 = files1.length;", "+    int len2 = files2.length;", "+    int len3 = files3.length;", "+    File[] testFiles = new File[len1 + len2 + len3];", "+    for (int i = 0; i < len1; i++) { testFiles[i] = files1[i]; }", "+    for (int i = 0; i < len2; i++) { testFiles[len1 + i] = files2[i]; }", "+    for (int i = 0; i < len3; i++) { testFiles[len1 + len2 + i] = files3[i]; }", "+        ", "+    ", "+    System.err.println(\"testFiles = \" + Arrays.toString(testFiles));", "-    File newDirectory = new File(directory.getAbsolutePath() + System.getProperty(\"file.separator\") + \"importedFiles\");", "-    testFiles = newDirectory.listFiles(new FileFilter() {", "+    File dir2 = new File(dir1.getAbsolutePath() + System.getProperty(\"file.separator\") + \"importedFiles\");", "+    testFiles = dir2.listFiles(new FileFilter() {", "-      ", "-      //And make sure that no java file was generated for ToReference2.dj1", "-      //(This is testing that we correctly handled what could have been an ambiguous name reference, but wasn't)", "-      File f = new File(newDirectory, \"ToReference2.java\");", "-      assertFalse(\"ToReference2.java should not exist\", f.exists());", "+//      //And make sure that no java file was generated for ToReference2.dj1", "+//      //(This is testing that we correctly handled what could have been an ambiguous name reference, but wasn't)", "+//      File f = new File(dir2, \"ToReference2.java\");", "+//      assertFalse(\"ToReference2.java should not exist\", f.exists());", "-      newDirectory = new File(directory.getAbsolutePath() + System.getProperty(\"file.separator\") + \"importedFiles2\");", "-      testFiles = newDirectory.listFiles(new FileFilter() {", "+      File f;", "+      dir2 = new File(dir1.getAbsolutePath() + System.getProperty(\"file.separator\") + \"importedFiles2\");", "+      testFiles = dir2.listFiles(new FileFilter() {", "-        ", "-        ", "-        //And make sure that no java file was generated for ToReference.dj1", "-        f = new File(newDirectory, \"ToReference.java\");", "-        assertFalse(\"ToReference.java should not exist\", f.exists());", "+//        //And make sure that no java file was generated for ToReference.dj1", "+//        f = new File(dir2, \"ToReference.java\");", "+//        assertFalse(\"ToReference.java should not exist\", f.exists());", "+//        fail(\"Ensure that System.err is dumped\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4dd99335ccbb799a801cc39f50abd4fd", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/AdvancedLevelTest.java", "commitBeforeChange": "c7ce54f2435a198c543bef7b35866738d8690d46", "commitAfterChange": "f9b3ce896f60a5fa583a421b5b2bb827822b30df", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": "   public void testPackageError()", "signatureAfterChange": "   public void testPackageError()", "diff": ["-   */", "+  /** Test that if a package and a class have the same name, an error is given. */", "-    directory = new File(directory.getAbsolutePath() + \"/shouldBreak/noBreak\");", "-    File[] testFiles = directory.listFiles(new FileFilter() {", "-      public boolean accept(File pathName) {", "-        return pathName.getAbsolutePath().endsWith(\".dj2\");", "-      }});", "-      LanguageLevelConverter llc = new LanguageLevelConverter();", "-      Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>> result;", "-      for (int i = 0; i<testFiles.length; i++) {", "-        result = llc.convert(new File[]{testFiles[i]}, new Options(JavaVersion.JAVA_5, IterUtil.<File>empty()));", "-        assertTrue(\"should be parse exceptions or visitor exceptions\", !result.getFirst().isEmpty() || !result.getSecond().isEmpty());", "-      }", "+    _log.log(\"Running testPackageError\");", "+    String base = dir1.getAbsolutePath();", "+    dir1 = new File(base + \"/shouldBreak/noBreak\");", "+    dir2 = new File(base + \"/shouldBreak\");", "+        ", "+    File[] files1 = dir1.listFiles(dj2Filter);", "+    File[] files2 = dir2.listFiles(dj2Filter);", "-      ", "+    int len1 = files1.length;", "+    int len2 = files2.length;", "+    File[] testFiles = new File[len1 + len2];", "+    for (int i = 0; i < len1; i++) { testFiles[i] = files1[i]; }", "+    for (int i = 0; i < len2; i++) { testFiles[len1 + i] = files2[i]; }", "+", "+    LanguageLevelConverter llc = new LanguageLevelConverter();", "+    Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>> result;", "+    result = llc.convert(testFiles, new Options(JavaVersion.JAVA_5, IterUtil.<File>empty()));", "+    assertTrue(\"should be parse exceptions or visitor exceptions\", !result.getFirst().isEmpty() || !result.getSecond().isEmpty());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6368a27c9ea9af355578c1a4ce9345fb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/RecentFileManager.java", "commitBeforeChange": "5c952c5847e3008cec3ed5ff89d03d335c050f54", "commitAfterChange": "e3e56a8c058b51612dfa6f1f21259a37eadcdcbb", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "          public void removeIfInList(File file)", "signatureAfterChange": "   public void removeIfInList(File file)", "diff": ["-    ", "-    public void removeIfInList(File file) {", "-      int index = _recentFiles.indexOf(file);", "-      ", "-      if (index >= 0) {", "-        _recentFiles.removeElementAt(index);", "-        JMenuItem delItem = _recentMenuItems.elementAt(index);", "-        _fileMenu.remove(delItem);", "-        _recentMenuItems.removeElementAt(index);", "-      }", "-    }", "+   */", "+  public void removeIfInList(File file) {", "+    // Use canonical path if possible", "+    File canonical = null;", "+    try {", "+      canonical = file.getCanonicalFile();", "+    }", "+    catch (IOException ioe) {", "+      // Oh well, compare against the file as is", "+    }", "+    ", "+    for (int i = 0; i < _recentFiles.size(); i++) {", "+      File currFile = _recentFiles.elementAt(i);", "+      boolean match = false;", "+      if (canonical != null) {", "+        try {", "+          match = currFile.getCanonicalFile().equals(canonical);", "+        }", "+        catch (IOException ioe) {", "+          // Oh well, compare the files themselves", "+          match = currFile.equals(file);", "+        }", "+      }", "+      else {", "+        // (couldn't find canonical for file; compare as is)", "+        match = currFile.equals(file);", "+      }", "+      ", "+      if (match) {", "+        _recentFiles.removeElementAt(i);", "+        JMenuItem menuItem = _recentMenuItems.elementAt(i);", "+        _fileMenu.remove(menuItem);", "+        _recentMenuItems.removeElementAt(i);", "+        break;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "98a42a0c7f308b08afeb8e77674d2955", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/MainFrame.java", "commitBeforeChange": "24e790b85d3a1a29de15955ca1ba9200a6865f83", "commitAfterChange": "4ceb386773fd5eb837ddcd34820c563b6c3c20cb", "methodNumberBeforeChange": 109, "methodNumberAfterChange": 110, "signatureBeforeChange": "   private void _javadocAll()", "signatureAfterChange": "   private void _javadocAll()", "diff": ["+    // This should really be in DefaultGlobalModel.", "+    ", "+    // Make sure that there is at least one saved document.", "+    ListModel docs = _model.getDefinitionsDocuments();", "+    ", "+    boolean noneYet = true;", "+    int numDocs = docs.getSize();", "+    for (int i = 0; (noneYet && (i < numDocs)); i++) {", "+      OpenDefinitionsDocument doc = (OpenDefinitionsDocument) docs.getElementAt(i);", "+      noneYet = doc.isUntitled();", "+    }", "+    ", "+    // If there are no saved files, ignore the javadoc command.", "+    if (noneYet) {", "+      return;", "+    }", "-      _model.javadocAll(destDir.getAbsolutePath());", "+      final File destDirF = destDir;", "+      final SwingWorker worker = new SwingWorker() {", "+        public Object construct() {", "+          try {", "+            boolean success = _model.javadocAll(destDirF.getAbsolutePath());", "-      // Display the results.", "-      _javadocFrame = new JavadocFrame(destDir);", "-      _javadocFrame.show();", "-    }", "-    catch (IOException ioe) {", "-      _showIOError(ioe);", "+            // Display the results.", "+//             System.out.println(\"did we get this far?\");", "+            if (success) {", "+              _javadocFrame = new JavadocFrame(destDirF);", "+              _javadocFrame.show();", "+            }", "+          }", "+          catch (InvalidPackageException ipe) {", "+            _showError(ipe, \"Javadoc Error\",", "+                       \"Javadoc encountered an invalid package name.\");", "+          }", "+//           catch (JavadocException jde) {", "+//             _showError(jde, \"JavaDoc Error\",", "+//                        \"There was an error generating the javadoc.\");", "+//           }", "+          catch (MalformedURLException me) {", "+            throw new UnexpectedException(me);", "+          }", "+          catch (IOException ioe) {", "+            _showIOError(ioe);", "+          }", "+          return \"XXX: Unused return value!\";", "+        }", "+      };", "+      worker.start();", "-    }", "-    catch (InvalidPackageException ipe) {", "-      _showError(ipe, \"JavaDoc Error\",", "-                 \"JavaDoc encountered an invalid package name.\");", "-    }", "-    catch (JavadocException jde) {", "-      _showError(jde, \"JavaDoc Error\",", "-                 \"There was an error generating the javadoc.\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4f38c5a155ada80aaa0d1c4847a7087", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/JarJDKToolsLibrary.java", "commitBeforeChange": "36e86519fec0be37255f092c8ef3144003d9d925", "commitAfterChange": "24a4bd9b5af47fdf2b927852ef0f4a564c73861b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r   \r   public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model)", "signatureAfterChange": "   public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model)", "diff": ["-  \r", "-  public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model) {\r", "-    FullVersion version = guessVersion(f);\r", "-    CompilerInterface compiler = NoCompilerAvailable.ONLY;\r", "-    Debugger debugger = NoDebuggerAvailable.ONLY;\r", "-    JavadocModel javadoc = new NoJavadocAvailable(model);\r", "-    \r", "-    if (JavaVersion.CURRENT.supports(version.majorVersion())) {\r", "-      // block tools.jar classes, so that references don't point to a different version of the classes\r", "-      ClassLoader loader = new ShadowingClassLoader(JarJDKToolsLibrary.class.getClassLoader(), TOOLS_PACKAGES);\r", "-      Iterable<File> path = IterUtil.singleton(IOUtil.attemptAbsoluteFile(f));\r", "-      \r", "-      String compilerAdapter = adapterForCompiler(version.majorVersion());\r", "-      if (compilerAdapter != null) {\r", "-        List<File> bootClassPath = null;\r", "-        if (f.getName().equals(\"classes.jar\")) { bootClassPath = Arrays.asList(f); }\r", "-        else if (f.getName().equals(\"tools.jar\")) {\r", "-          File rtJar = new File(f.getParentFile(), \"../jre/lib/rt.jar\");\r", "-          if (!rtJar.exists()) { rtJar = new File(f.getParentFile(), \"rt.jar\"); }\r", "-          if (rtJar.exists()) {\r", "-            rtJar = IOUtil.attemptCanonicalFile(rtJar);\r", "-            bootClassPath = Arrays.asList(rtJar);\r", "-          }\r", "-        }\r", "-        try {\r", "-          Class[] sig = new Class[]{ FullVersion.class, String.class, List.class };\r", "-          Object[] args = new Object[]{ version, f.toString(), bootClassPath };\r", "-          CompilerInterface attempt = (CompilerInterface) ReflectUtil.loadLibraryAdapter(loader, path, compilerAdapter, \r", "-                                                                                         sig, args);\r", "-          if (attempt.isAvailable()) { compiler = attempt; }\r", "-        }\r", "-        catch (ReflectException e) { /* can't load */ }\r", "-        catch (LinkageError e) { /* can't load */ }\r", "-      }\r", "-      \r", "-      String debuggerAdapter = adapterForDebugger(version.majorVersion());\r", "-      String debuggerPackage = \"edu.rice.cs.drjava.model.debug.jpda\";\r", "-      if (debuggerAdapter != null) {\r", "-        try {\r", "-          Class[] sig = new Class[]{ GlobalModel.class };\r", "-          // can't use loadLibraryAdapter because we need to preempt the whole package\r", "-          ClassLoader debugLoader = new PreemptingClassLoader(new PathClassLoader(loader, path), debuggerPackage);\r", "-          Debugger attempt = (Debugger) ReflectUtil.loadObject(debugLoader, debuggerAdapter, sig, model);        \r", "-          if (attempt.isAvailable()) { debugger = attempt; }\r", "-        }\r", "-        catch (ReflectException e) { /* can't load */ }\r", "-        catch (LinkageError e) { /* can't load */ }\r", "-      }\r", "-      \r", "-      try {\r", "-        new PathClassLoader(loader, path).loadClass(\"com.sun.tools.javadoc.Main\");\r", "-        File bin = new File(f.getParentFile(), \"../bin\");\r", "-        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(f.getParentFile(), \"../Home/bin\"); }\r", "-        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(System.getProperty(\"java.home\", f.getParent())); }\r", "-        javadoc = new DefaultJavadocModel(model, bin, path);\r", "-      }\r", "-      catch (ClassNotFoundException e) { /* can't load */ }\r", "-      catch (LinkageError e) { /* can't load (probably not necessary, but might as well catch it) */ }\r", "-        \r", "-    }\r", "-    \r", "-    return new JarJDKToolsLibrary(f, version, compiler, debugger, javadoc);\r", "-  }\r", "+  /** Create a JarJDKToolsLibrary from a specific {@code \"tools.jar\"} or {@code \"classes.jar\"} file. */", "+  public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model) {", "+    FullVersion version = guessVersion(f);", "+    CompilerInterface compiler = NoCompilerAvailable.ONLY;", "+    Debugger debugger = NoDebuggerAvailable.ONLY;", "+    JavadocModel javadoc = new NoJavadocAvailable(model);", "+    ", "+    // We can't execute code that was possibly compiled for a later Java API version.", "+    if (JavaVersion.CURRENT.supports(version.majorVersion())) {", "+      // block tools.jar classes, so that references don't point to a different version of the classes", "+      ClassLoader loader = new ShadowingClassLoader(JarJDKToolsLibrary.class.getClassLoader(), TOOLS_PACKAGES);", "+      Iterable<File> path = IterUtil.singleton(IOUtil.attemptAbsoluteFile(f));", "+      ", "+      String compilerAdapter = adapterForCompiler(version.majorVersion());", "+      if (compilerAdapter != null) {", "+        ", "+        // determine boot class path", "+        File libDir = null;", "+        if (f.getName().equals(\"classes.jar\")) { libDir = f.getParentFile(); }", "+        else if (f.getName().equals(\"tools.jar\")) {", "+          File jdkLibDir = f.getParentFile();", "+          if (jdkLibDir != null) {", "+            File jdkRoot = jdkLibDir.getParentFile();", "+            if (jdkRoot != null) {", "+              File jreLibDir = new File(jdkRoot, \"jre/lib\");", "+              if (IOUtil.attemptExists(new File(jreLibDir, \"rt.jar\"))) { libDir = jreLibDir; }", "+            }", "+            if (libDir == null) {", "+              if (IOUtil.attemptExists(new File(jdkLibDir, \"rt.jar\"))) { libDir = jdkLibDir; }", "+            }", "+          }", "+        }", "+        List<File> bootClassPath = null; // null defers to the compiler's default behavior", "+        if (libDir != null) {", "+          File[] jars = IOUtil.attemptListFiles(libDir, IOUtil.extensionFileFilter(\"jar\"));", "+          if (jars != null) { bootClassPath = Arrays.asList(jars); }", "+        }", "+", "+        try {", "+          Class[] sig = new Class[]{ FullVersion.class, String.class, List.class };", "+          Object[] args = new Object[]{ version, f.toString(), bootClassPath };", "+          CompilerInterface attempt = (CompilerInterface) ReflectUtil.loadLibraryAdapter(loader, path, compilerAdapter, ", "+                                                                                         sig, args);", "+          if (attempt.isAvailable()) { compiler = attempt; }", "+        }", "+        catch (ReflectException e) { /* can't load */ }", "+        catch (LinkageError e) { /* can't load */ }", "+      }", "+      ", "+      String debuggerAdapter = adapterForDebugger(version.majorVersion());", "+      String debuggerPackage = \"edu.rice.cs.drjava.model.debug.jpda\";", "+      if (debuggerAdapter != null) {", "+        try {", "+          Class[] sig = new Class[]{ GlobalModel.class };", "+          // can't use loadLibraryAdapter because we need to preempt the whole package", "+          ClassLoader debugLoader = new PreemptingClassLoader(new PathClassLoader(loader, path), debuggerPackage);", "+          Debugger attempt = (Debugger) ReflectUtil.loadObject(debugLoader, debuggerAdapter, sig, model);        ", "+          if (attempt.isAvailable()) { debugger = attempt; }", "+        }", "+        catch (ReflectException e) { /* can't load */ }", "+        catch (LinkageError e) { /* can't load */ }", "+      }", "+      ", "+      try {", "+        new PathClassLoader(loader, path).loadClass(\"com.sun.tools.javadoc.Main\");", "+        File bin = new File(f.getParentFile(), \"../bin\");", "+        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(f.getParentFile(), \"../Home/bin\"); }", "+        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(System.getProperty(\"java.home\", f.getParent())); }", "+        javadoc = new DefaultJavadocModel(model, bin, path);", "+      }", "+      catch (ClassNotFoundException e) { /* can't load */ }", "+      catch (LinkageError e) { /* can't load (probably not necessary, but might as well catch it) */ }", "+        ", "+    }", "+    ", "+    return new JarJDKToolsLibrary(f, version, compiler, debugger, javadoc);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac8872ea5261896e79892f060c2ba52b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/StringOps.java", "commitBeforeChange": "2e0841eedc488bc59bd976576cad4ea91d3f46bd", "commitAfterChange": "910d746e63f304ca12ddaf504f429a40f31bf858", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 24, "signatureBeforeChange": "   public static List<String> commandLineToList(String cmdline)", "signatureAfterChange": "   public static List<String> commandLineToList(String cmdline)", "diff": ["-  /** Convert a command line into a list of individual arguments. */", "+    * It does not allow escaping of the quote characters. */", "-    tok.wordChars(0,255);", "-    tok.whitespaceChars(0,32);", "+    tok.ordinaryChars(0,255);", "+    boolean justEscape = false;", "+    StringBuilder sb = new StringBuilder();", "+          case '\\u001b':", "+            if (justEscape) {", "+              sb.append('\\u001b');", "+              justEscape = false;", "+            }", "+            else {", "+              justEscape = true;", "+            }", "+            break;", "+          case ' ':", "+            if (justEscape) {", "+              sb.append(' ');", "+            }", "+            else {", "+              cmds.add(sb.toString());", "+              sb = new StringBuilder();", "+            }", "+            justEscape = false;", "+            break;", "-            cmds.add(\"\"+((char)next)+tok.sval+((char)next));", "-            break;", "-          case StreamTokenizer.TT_WORD:", "-            cmds.add(tok.sval);", "-            break;", "-          case StreamTokenizer.TT_NUMBER:", "-            cmds.add(\"\"+tok.nval);", "+            sb.append(\"\"+((char)next)+tok.sval+((char)next));", "+            justEscape = false;", "-            return new ArrayList<String>();", "+            sb.append(\"\"+((char)next));", "+            break;", "+      if (sb.length()>0) { cmds.add(sb.toString()); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b7a64153f329f2f75f023df90a604d71", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/NameVisitor.java", "commitBeforeChange": "71879d695be61a14cdd93b2ece27fb14682043fb", "commitAfterChange": "e70766c672e058ab37ae5757bf5008b997a8ff63", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 23, "signatureBeforeChange": "   public Node visit(ObjectMethodCall node)", "signatureAfterChange": "   public Node visit(ObjectMethodCall node)", "diff": ["+    if(o == null) {", "+      try {", "+        //Get fully qualified name for Object o if the methodCall is to a staticly imported method", "+        //The full class name is given as if the user gave a call using the entire fully qualified name", "+        Class[] params = new Class[args!=null? args.size() : 0];", "+        if(args != null) {", "+          for(int i = 0; i < args.size(); i++) {", "+            String toParse = args.get(i).toString();", "+            params[i]=(args.get(i).acceptVisitor(AbstractTypeChecker.makeTypeChecker(typeCheckerContext)));", "+          }", "+        }   ", "+        List<IdentifierToken> ids = context.getQualifiedName(node.getMethodName(),params);", "+        o = new ReferenceType(ids);", "+      }      ", "+      catch(Exception e){", "+        //If the class type of one of the parameters can't be found, throws an exception", "+        //Also, if no method found to have been imported, throws an exception", "+        //This will occur every time the user calls a method that has not been staticly imported", "+        //As this section is new code, this is being caught to prevent breaking old code", "+      }     ", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e965806bc2a9e8dddc11553cb2ca2e62", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/error/ThrownException.java", "commitBeforeChange": "33efe2539ca216fb14c21fb7ac7310d7b150d7ef", "commitAfterChange": "88de5f3657d6901624a99592baa687fe5666eed7", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "   public ThrownException(Throwable e, Node n)", "signatureAfterChange": "   public ThrownException(Throwable e, StackTraceElement[] filteredElements)", "diff": ["+   */", "+  public ThrownException(Throwable e, StackTraceElement[] filteredElements) {", "+    super(\"uncaught.exception\");", "+    StackTraceElement[] original = e.getStackTrace();", "+    int startMatch = original.length - filteredElements.length;", "+    boolean matches = startMatch >= 0;", "+    for (int i = 0; matches && i < filteredElements.length; i++) {", "+      matches &= original[startMatch+i].equals(filteredElements[i]);", "+    }", "+    if (matches) {", "+      StackTraceElement[] newStackTrace = new StackTraceElement[startMatch];", "+      for (int i = 0; i < startMatch; i++) { newStackTrace[i] = original[i]; }", "+      e.setStackTrace(newStackTrace);", "+    }", "+    thrown = e;    ", "+  }"]}], "num": 27153}