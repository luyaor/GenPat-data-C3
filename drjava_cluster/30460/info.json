{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5a4480b98f051122a047c62c3a8f9973", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb22c52919ba3f6c5ee6f50d659ec9b2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyIntermediateVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r     \r \r     \r \r     \r     public void testForConcreteMethodDef()", "signatureAfterChange": "                      public void testForConcreteMethodDef()", "diff": ["-    \r", "-    public void testForConcreteMethodDef() {\r", "-      // Test one that works.\r", "-      MethodDef mdef = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, \r", "-                                             _privateMav, \r", "-                                             new TypeParameter[0], \r", "-                                             new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), \r", "-                                             new Word(JExprParser.NO_SOURCE_INFO, \"methodName\"),\r", "-                                             new FormalParameter[0],\r", "-                                             new ReferenceType[0], \r", "-                                             new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));\r", "-      mdef.visit(_cbiv);\r", "-      assertEquals(\"There should not be any errors.\", 0, errors.size());\r", "-\r", "-      \r", "-      //Check one that works but needs to be augmented with public\r", "-      ConcreteMethodDef cmd1 = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO,\r", "-                                                    _packageMav,\r", "-                                                    new TypeParameter[0],\r", "-                                                    new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"),\r", "-                                                    new Word(JExprParser.NO_SOURCE_INFO, \"noMavMethod\"),\r", "-                                                    new FormalParameter[0],\r", "-                                                    new ReferenceType[0],\r", "-                                                    new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));\r", "-      \r", "-      cmd1.visit(_cbiv);\r", "-      assertEquals(\"There should not be any errors\", 0, errors.size());\r", "-      assertEquals(\"_sd1 should contain 2 methods\", 2, _sd1.getMethods().size());\r", "-      assertTrue(\"The second method should be public\", _sd1.getMethods().get(1).hasModifier(\"public\"));\r", "-\r", "-      \r", "-      \r", "-      // Test one that doesn't work.\r", "-      mdef = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, \r", "-                                             _packageMav, \r", "-                                             new TypeParameter[0], \r", "-                                             new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), \r", "-                                             new Word(JExprParser.NO_SOURCE_INFO, \"monkey\"),\r", "-                                             new FormalParameter[0],\r", "-                                             new ReferenceType[0], \r", "-                                             new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));\r", "-      mdef.visit(_cbiv);\r", "-      assertEquals(\"There should be one error.\", 1, errors.size());\r", "-      assertEquals(\"The error message should be correct.\", \r", "-                   \"Only constructors can have the same name as the class they appear in, and constructors do not have an explicit return type\",\r", "-                   errors.get(0).getFirst());\r", "-    }\r", "+    ", "+    public void testForConcreteMethodDef() {", "+      // Test one that works.", "+      MethodDef mdef = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, ", "+                                             _privateMav, ", "+                                             new TypeParameter[0], ", "+                                             new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), ", "+                                             new Word(JExprParser.NO_SOURCE_INFO, \"methodName\"),", "+                                             new FormalParameter[0],", "+                                             new ReferenceType[0], ", "+                                             new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));", "+      mdef.visit(_cbiv);", "+      assertEquals(\"There should not be any errors.\", 0, errors.size());", "+", "+      ", "+      //Check one that works but needs to be augmented with public", "+      ConcreteMethodDef cmd1 = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO,", "+                                                    _packageMav,", "+                                                    new TypeParameter[0],", "+                                                    new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"),", "+                                                    new Word(JExprParser.NO_SOURCE_INFO, \"noMavMethod\"),", "+                                                    new FormalParameter[0],", "+                                                    new ReferenceType[0],", "+                                                    new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));", "+      ", "+      cmd1.visit(_cbiv);", "+      assertEquals(\"There should not be any errors\", 0, errors.size());", "+      assertEquals(\"_sd1 should contain 2 methods\", 2, _sd1.getMethods().size());", "+      assertTrue(\"The second method should be default public\", _sd1.getMethods().get(1).hasModifier(\"public\"));", "+", "+      ", "+      ", "+      // Test one that doesn't work.", "+      mdef = new ConcreteMethodDef(JExprParser.NO_SOURCE_INFO, ", "+                                             _packageMav, ", "+                                             new TypeParameter[0], ", "+                                             new PrimitiveType(JExprParser.NO_SOURCE_INFO, \"int\"), ", "+                                             new Word(JExprParser.NO_SOURCE_INFO, \"monkey\"),", "+                                             new FormalParameter[0],", "+                                             new ReferenceType[0], ", "+                                             new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));", "+      mdef.visit(_cbiv);", "+      assertEquals(\"There should be one error.\", 1, errors.size());", "+      assertEquals(\"The error message should be correct.\", ", "+                   \"Only constructors can have the same name as the class they appear in, and constructors do not have an explicit return type\",", "+                   errors.get(0).getFirst());", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f8e9027e1716ba69c419f948abc24015", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "4ebe3c86a9c7402a414ee21bfa81b87bb3fb5032", "commitAfterChange": "a80c90b8428392cd32bdf80517cd25701896680b", "methodNumberBeforeChange": 100, "methodNumberAfterChange": 100, "signatureBeforeChange": "               public void testGetSymbolDataHelper()", "signatureAfterChange": "               public void testGetSymbolDataHelper()", "diff": ["-      assertEquals(\"should return the int SymbolData\", SymbolData.INT_TYPE, _llv.getSymbolDataHelper(\"int\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "-      assertEquals(\"should return the byte SymbolData\", SymbolData.BYTE_TYPE, _llv.getSymbolDataHelper(\"byte\", JExprParser.NO_SOURCE_INFO, false, false, false, true));", "+      assertEquals(\"should return the int SymbolData\", SymbolData.INT_TYPE, ", "+                   _llv.getSymbolDataHelper(\"int\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "+      assertEquals(\"should return the byte SymbolData\", SymbolData.BYTE_TYPE, ", "+                   _llv.getSymbolDataHelper(\"byte\", JExprParser.NO_SOURCE_INFO, false, false, false, true));", "-      ad.getVars().get(0).setEnclosingData(result);  //This is a hack, because .equals() on variable datas compares their enclosing datas with ==.", "+      ad.getVars().get(0).setEnclosingData(result);  //.equals(...) on VariableData compares enclosing datas with ==.", "-      assertEquals(\"should return the same sd\", sd, _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "+      assertEquals(\"should return the same sd\", sd, ", "+                   _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "-      assertEquals(\"should return the now resolved sd\", sd, _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "+      assertEquals(\"should return the now resolved sd\", sd, ", "+                   _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "-      ElementaryVisitor bv = new ElementaryVisitor(new File(\"\"), errors, symbolTable, continuations, new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>(), _newSDs);", "+      ElementaryVisitor bv = new ElementaryVisitor(new File(\"\"), errors, symbolTable, continuations, ", "+                                                   new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>(), _newSDs);", "-      _llv._classesToBeParsed.put(\"fully.qualified.Qwerty\", ", "-                                  new Pair<TypeDefBase, LanguageLevelVisitor>(", "-                                                                              new ClassDef(JExprParser.NO_SOURCE_INFO, ", "-                                                                                           _packageMav, ", "-                                                                                           new Word(JExprParser.NO_SOURCE_INFO, \"Qwerty\"),", "-                                                                                           new TypeParameter[0],", "-                                                                                           new ClassOrInterfaceType(JExprParser.NO_SOURCE_INFO, \"Object\", new Type[0]),", "-                                                                                           new ReferenceType[0], ", "-                                                                                           new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0])),", "-                                                                              bv));", "-      assertEquals(\"should return sd the continuation\", sd, bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "+      ClassDef cd = new ClassDef(JExprParser.NO_SOURCE_INFO, ", "+                                 _packageMav, ", "+                                 new Word(JExprParser.NO_SOURCE_INFO, \"Qwerty\"),", "+                                 new TypeParameter[0],", "+                                 new ClassOrInterfaceType(JExprParser.NO_SOURCE_INFO, \"Object\", new Type[0]),", "+                                 new ReferenceType[0], ", "+                                 new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));", "+      _llv._classesToBeParsed.put(\"fully.qualified.Qwerty\", new Pair<TypeDefBase, LanguageLevelVisitor>(cd, bv));", "+      assertEquals(\"should return sd the continuation\", sd, ", "+                   bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "-      assertEquals(\"should return sd, now resolved\", sd, bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "+      assertEquals(\"should return sd, now resolved\", sd, ", "+                   bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "-      assertEquals(\"should find the continuation in the symbol table\", sd, _llv.getSymbolDataHelper(\"c\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "+      assertEquals(\"should find the continuation in the symbol table\", sd, ", "+                   _llv.getSymbolDataHelper(\"c\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "-      assertEquals(\"should find the resolved symbol data in the symbol table\", sd2, _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "+      assertEquals(\"should find the resolved symbol data in the symbol table\", sd2, ", "+                   _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "-      assertEquals(\"should find the unresolved symbol data in the symbol table\", sd2, _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, false, true, true));", "+      assertEquals(\"should find the unresolved symbol data in the symbol table\", sd2, ", "+                   _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, false, true, true));", "-      //Test that if class name is ambiguous (i.e. it is unqualified, and matches unqualified names in 2 or more packages.", "+      // Test ambiguous class name (i.e. it is unqualified, and matches unqualified names in 2 or more packages.", "-      assertEquals(\"The error message should be correct\", \"The class name String is ambiguous.  It could be java.lang.String or random.package.String\", errors.get(0).getFirst());", "+      assertEquals(\"The error message should be correct\", \"The class name String is ambiguous.\" + ", "+                   \"  It could be java.lang.String or random.package.String\", ", "+                   errors.get(0).getFirst());"]}], "num": 30460}