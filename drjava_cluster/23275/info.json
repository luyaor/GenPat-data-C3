{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0caadbbe74cae29c9d872fef2dcb0112", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "946ab53268a5f675504a06ee3be22e07", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ConstructorBodyTypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "   private void implicitSuperConstructor(BracedBody that)", "signatureAfterChange": "   private void implicitSuperConstructor(BracedBody that)", "diff": ["-   */", "+    */", "+//    System.err.println(\"implicitSuperConstructor called for \" + _data.getSymbolData());", "-      _addError(\"There is an implicit call to the constructor of \" + superClass.getName() + \" here, but \" + superClass.getName() + \" is a non-static inner class of \" + superClass.getOuterData().getName() + \".  Thus, you must explicitly invoke its constructor from an instance of its outer class\", that);", "+      _addError(\"There is an implicit call to the constructor of \" + superClass.getName() + \" here, but \" + ", "+                superClass.getName() + \" is a non-static inner class of \" + superClass.getOuterData().getName() + ", "+                \".  Thus, you must explicitly invoke its constructor from an instance of its outer class\", ", "+                that);", "-    //Look in this's super class and try to match the invocation.  If no match is found, the method invocation will add an error.", "+    // Look in this's super class and try to match the invocation.  If no match is found, the method invocation will ", "+    // add an error.", "-    //There must be a default constructor with no arguments, or an error is thrown.", "-    //(Note--if there were no constructors in the super class at all, the default no arguments constructor would exist.  However, a constructor is always", "-    //generated for a LanguageLevel file, and any class file that relied on the default constructor would already have it.  Therefore, we can assume", "-    //that all classes have at least one constructor).", "-    MethodData cd = _lookupMethod(name, superClass, new InstanceData[0], that, ", "-                           \"You must invoke one of \" + superClass.getName() + \"'s constructors here.  You can either explicitly invoke one of its exisitng constructors or add a constructor with signature: \", ", "-                           true, superClass);", "+    // There must be a default constructor with no arguments, or an error is thrown.", "+    // (Note--if there were no constructors in the super class at all, the default no arguments constructor would exist.  ", "+    // However, a constructor is always generated for a LanguageLevel file, and any class file that relied on the ", "+    // default constructor would already have it.  Therefore, we can assume that all classes have at least one constructor).", "+    ", "+    MethodData cd = ", "+      _lookupMethod(name, ", "+                    superClass, ", "+                    new InstanceData[0], ", "+                    that, ", "+                    \"You must invoke one of \" + superClass.getName() + ", "+                    \"'s constructors here.  You can either explicitly invoke one of its exisitng constructors or \"", "+                      + \"add a constructor with signature: \", ", "+                    true, superClass);", "-    //if constructor is declared to throw exceptions, add them to thrown list:", "-    //add BracedBody as the JExpression corresponding to the error", "+    // if constructor is declared to throw exceptions, add them to thrown list:", "+    // add BracedBody as the JExpression corresponding to the error"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c06ba5a10ef6fb964d0b47e0f974e88f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "5e7a16013fcb5945eddc036e2d2d0ce3e14ba2d0", "commitAfterChange": "e1389ddb9dcb8a7d3a230cc1be322481e1c8fd6a", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "diff": ["+    //  WHAT IS THE FOLLOWING STATIC FIELD REFERNCE DOING HERE?  THIS IS ABOMINABLE CODE!", "-    //and the newSDs we've created", "+    //and the new SDs (symbol table entries) we've created", "-    // We are doing two passes on the files, and the second pass needs the first's corresponding", "-    // SourceFile and ElementaryVisitor so we'll keep them around in a Hashtable.", "+    /* We are doing two passes on the files, and the second pass needs the first's corresponding", "+       SourceFile and LanguageLevelVisitor so we'll keep them around in a Hashtable. */", "-    // The visitedFiles returned by any pass may include another file which is already scheduled for compilation.", "-    // In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "-    // already been done.  (An error is thrown if we do since it thinks the class has already been defined).", "+    /* The visitedFiles returned by any pass may include another file which is already scheduled for compilation.", "+       In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "+       already been done.  (An error is thrown if we do since it thinks the class has already been defined). */", "+    // WHAT visitedFiles are RETURNED?  HOW?  The return type is a Pair containing NO files!  I SMELL GLOBAL VARIABLES!", "-    // The number of files to compile may change if one file references another one.", "-    // We don't want to visit these newly referenced files because they've already", "-    // been visited.", "+    /* The number of files to compile may change if one file references another one.", "+       We don't want to visit these newly referenced files because they've already", "+       been visited. */", "+    // WHAT DOES VISIT MEAN?", "-    // Find the ones (of what?) that are LL files.", "-    // Do the passes first for ALL files before proceeding to code augmentation.", "-    // Otherwise if one class' superclass get augmented first, then it sees a lot", "-    // of illegal constructs (e.g. public and constructors).", "+    /* Find the ones (of what?) that are LL files.", "+       Do the passes first for ALL files before proceeding to code augmentation.", "+       Otherwise if one class' superclass get augmented first, then it sees a lot", "+       of illegal constructs (e.g. public and constructors). */", "-    //will maintain the files we visit along with their visitors (for type checking step).", "+    /* will maintain the files we visit along with their visitors (for type checking step). */", "-    ", "-    for (int ind = 0; ind < originalNumOfFiles; ind++) {", "-      File f = files[ind];", "+    for (File f : files) {", "-              t.visit(new JExpressionIFAbstractVisitor_void() {", "-                public void forClassDef(ClassDef that) { topLevelClasses.add(that.getName().getText()); }", "+              t.visit(new JExpressionIFAbstractVisitor<Void>() {", "+                public Void forClassDef(ClassDef that) { topLevelClasses.add(that.getName().getText()); return null; }", "+                public Void defaultCase(JExpressionIF that) { return null; }", "-    //Resolve continuations and create constructors.  Also accumulate errors.", "+    // Resolve continuations and create constructors.  Also accumulate errors."]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c24b7b755f27f37a9c3a61dca73fea40", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ConstructorBodyTypeChecker.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r   private void implicitSuperConstructor(BracedBody that)", "signatureAfterChange": "   private void implicitSuperConstructor(BracedBody that)", "diff": ["-   */\r", "-  private void implicitSuperConstructor(BracedBody that) {\r", "-    SymbolData superClass = _data.getSymbolData().getSuperClass();\r", "-    \r", "-    if (superClass == null) {  //This should never happen, but if it does, no reason to throw an error.\r", "-      return;\r", "-    }\r", "-\r", "-    //If the super class is an inner class, there cannot be an implicit constructor call\r", "-    if (superClass.getOuterData() != null && !(superClass.hasModifier(\"static\"))) {\r", "-      _addError(\"There is an implicit call to the constructor of \" + superClass.getName() + \" here, but \" + superClass.getName() + \" is a non-static inner class of \" + superClass.getOuterData().getName() + \".  Thus, you must explicitly invoke its constructor from an instance of its outer class\", that);\r", "-      return;\r", "-    }\r", "-\r", "-    \r", "-    //Look in this's super class and try to match the invocation.  If no match is found, the method invocation will add an error.\r", "-    String name = LanguageLevelVisitor.getUnqualifiedClassName(superClass.getName());\r", "-    \r", "-    //There must be a default constructor with no arguments, or an error is thrown.\r", "-    //(Note--if there were no constructors in the super class at all, the default no arguments constructor would exist.  However, a constructor is always\r", "-    //generated for a LanguageLevel file, and any class file that relied on the default constructor would already have it.  Therefore, we can assume\r", "-    //that all classes have at least one constructor).\r", "-    MethodData cd = _lookupMethod(name, superClass, new InstanceData[0], that, \r", "-                           \"You must invoke one of \" + superClass.getName() + \"'s constructors here.  You can either explicitly invoke one of its exisitng constructors or add a constructor with signature: \", \r", "-                           true, superClass);\r", "-\r", "-    if (cd == null) {return;}\r", "-    //if constructor is declared to throw exceptions, add them to thrown list:\r", "-    //add BracedBody as the JExpression corresponding to the error\r", "-    String[] thrown = cd.getThrown();\r", "-    for (int i = 0; i<thrown.length; i++) {\r", "-      _thrown.addLast(new Pair<SymbolData, JExpression>(getSymbolData(thrown[i], _getData(), that), that));\r", "-    }\r", "-    \r", "-    \r", "-    return;\r", "-  }\r", "+   */", "+  private void implicitSuperConstructor(BracedBody that) {", "+    SymbolData superClass = _data.getSymbolData().getSuperClass();", "+    ", "+    if (superClass == null) {  //This should never happen, but if it does, no reason to throw an error.", "+      return;", "+    }", "+", "+    //If the super class is an inner class, there cannot be an implicit constructor call", "+    if (superClass.getOuterData() != null && !(superClass.hasModifier(\"static\"))) {", "+      _addError(\"There is an implicit call to the constructor of \" + superClass.getName() + \" here, but \" + superClass.getName() + \" is a non-static inner class of \" + superClass.getOuterData().getName() + \".  Thus, you must explicitly invoke its constructor from an instance of its outer class\", that);", "+      return;", "+    }", "+", "+    ", "+    //Look in this's super class and try to match the invocation.  If no match is found, the method invocation will add an error.", "+    String name = LanguageLevelVisitor.getUnqualifiedClassName(superClass.getName());", "+    ", "+    //There must be a default constructor with no arguments, or an error is thrown.", "+    //(Note--if there were no constructors in the super class at all, the default no arguments constructor would exist.  However, a constructor is always", "+    //generated for a LanguageLevel file, and any class file that relied on the default constructor would already have it.  Therefore, we can assume", "+    //that all classes have at least one constructor).", "+    MethodData cd = _lookupMethod(name, superClass, new InstanceData[0], that, ", "+                           \"You must invoke one of \" + superClass.getName() + \"'s constructors here.  You can either explicitly invoke one of its exisitng constructors or add a constructor with signature: \", ", "+                           true, superClass);", "+", "+    if (cd == null) return;", "+    //if constructor is declared to throw exceptions, add them to thrown list:", "+    //add BracedBody as the JExpression corresponding to the error", "+    String[] thrown = cd.getThrown();", "+    for (int i = 0; i<thrown.length; i++) {", "+      _thrown.addLast(new Pair<SymbolData, JExpression>(getSymbolData(thrown[i], _getData(), that), that));", "+    }", "+    ", "+    ", "+    return;", "+  }"]}], "num": 23275}