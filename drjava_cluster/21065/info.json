{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "053e1becf0ba4de829ddf347c85e3d4c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5233fce0e86bd9959e28374c57a05171", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/newjvm/AbstractMasterJVM.java", "commitBeforeChange": "3ae33096a45a4dc4990b95b1565bd0aeaf9084da", "commitAfterChange": "e69a4c60c625d52f9ba6a18669f0f6846846e463", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 14, "signatureBeforeChange": "   protected final void quitSlave() throws RemoteException", "signatureAfterChange": "   protected final void quitSlave() throws RemoteException", "diff": ["-    _log.log(this + \".quitSlave() called\");", "+    SlaveRemote dyingSlave;", "-      if (isStartupInProgress())", "-        /* There is a slave to be quit, but we don't have a handle to it yet. Instead we set this flag, which makes it", "-         * quit immediately after it registers in registerSlave. */", "+      if (isStartupInProgress()) {", "+        /* There is a slave to be quit, but _slave == null, so we cannot contact it yet. Instead we set _quitOnStartup", "+         * and tell the slave to quit when it registers in registerSlave. */", "-      ", "+        return;", "+      }", "-        System.out.println(\"Slave JVM quit operation invoked when no slave running\");", "-//        throw new IllegalStateException(\"tried to quit when no slave running and startup not in progress\");", "+        return;", "-        _slave.quit();", "-        _slave = null;  // Remove reference to Slave JVM", "+        dyingSlave = _slave;", "+        _slave = null;", "+    dyingSlave.quit();  // remote operation is not synchronized!"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a3e3297cf22068ed2304ba8e0aa555ec", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/newjvm/AbstractMasterJVM.java", "commitBeforeChange": "0126ea99e5c318f1f9907f0c07d77641969ffef5", "commitAfterChange": "fa54651cc7ac0d03884ebcafd7e8520df74651a1", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "   protected final void quitSlave() throws RemoteException", "signatureAfterChange": "   protected final void quitSlave() throws RemoteException", "diff": ["-//    Utilities.showDebug(\"quitSlave() called\");", "+    _log.log(this + \".quitSlave() called\");", "-        // There is a slave to be quit, but we don't have a handle to it yet.", "-        // Instead we set this flag, which makes it quit immediately after it", "-        // registers in registerSlave.", "+        /* There is a slave to be quit, but we don't have a handle to it yet. Instead we set this flag, which makes it", "+         * quit immediately after it registers in registerSlave. */", "-      else if (_slave == null)  System.out.println(\"slave JVM quit invoked when no slave running\");", "+      else if (_slave == null)  {", "+        System.out.println(\"Slave JVM quit operation invoked when no slave running\");", "+        _log.log(this + \" called quitSlave() when no slave was running\");", "-      else _slave.quit();", "+      }", "+      else {", "+        _slave.quit();", "+        _slave = null;  // Remove reference to Slave JVM", "+      }"]}], "num": 21065}