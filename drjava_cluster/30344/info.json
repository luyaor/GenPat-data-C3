{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4de1f1ec47228e8273602b76de61a131", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "497ea05d2951dc33f8a7c59d9438cb18", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/TreeCompiler.java", "commitBeforeChange": "41fd33d17362a9b484003b73b5562d87a9b206fa", "commitAfterChange": "1c816952b5b8421dc41f789510e8d7ee742c6828", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "         private void compileClass(Node ast)", "signatureAfterChange": "         private void compileClass(Node ast)", "diff": ["+    DJClass declaring = _treeClass.declaringClass();", "+    if (declaring != null) {", "+      // visitOuter corresponds to Class.getEnclosingClass(), visitInner to Class.getDeclaringClass()", "+      _classWriter.visitOuterClass(className(declaring), null, null); ", "+      _classWriter.visitInnerClass(_name, className(declaring), _treeClass.declaredName(), accessFlags);", "+    }", "-      _classWriter.visitField(ACC_PRIVATE | ACC_FINAL | ACC_SYNTHETIC, BINDINGS_FACTORY_FIELD,", "+      // to be accessible to inner classes, must not be private", "+      _classWriter.visitField(ACC_FINAL | ACC_SYNTHETIC, BINDINGS_FACTORY_FIELD,", "+        }", "+        @Override public Void visit(ClassDeclaration member) {", "+          recordInnerClass(member, isInterface); return null;", "+        }", "+        @Override public Void visit(InterfaceDeclaration member) {", "+          recordInnerClass(member, isInterface); return null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e63825b89d6ccb0724af5698c4847211", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/TreeCompiler.java", "commitBeforeChange": "73d8f0963e3941f0992013e94dd38c610fad8320", "commitAfterChange": "79f5d66e5d12491f568b49d5064798e6d989d102", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "         private void compileClass(Node ast)", "signatureAfterChange": "         private void compileClass(Node ast)", "diff": ["+    final boolean isInterface;", "+      isInterface = false;", "-      accessFlags = id.getAccessFlags();", "+      accessFlags = id.getAccessFlags() | Modifier.INTERFACE;", "+      isInterface = true;", "+      isInterface = false;", "+      isInterface = false;", "+    else { throw new RuntimeException(\"Unexpected class AST node type: \" + ast); }", "-    _classWriter.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL | ACC_SYNTHETIC, ADAPTER_FIELD,", "-                            EVALUATION_ADAPTER_DESCRIPTOR, null, null).visitEnd();", "-    if (!(ast instanceof InterfaceDeclaration)) {", "+    if (isInterface) {", "+      // interface fields must be public (adapter is necessary to interpret declared field initializers)", "+      _classWriter.visitField(ACC_PUBLIC | ACC_STATIC | ACC_FINAL | ACC_SYNTHETIC, ADAPTER_FIELD,", "+                              EVALUATION_ADAPTER_DESCRIPTOR, null, null).visitEnd();", "+    }", "+    else {", "+      _classWriter.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL | ACC_SYNTHETIC, ADAPTER_FIELD,", "+                              EVALUATION_ADAPTER_DESCRIPTOR, null, null).visitEnd();", "-          compileMethod(member); return null;", "+          compileMethod(member, isInterface); return null;", "-          compileField(member); return null;", "+          compileField(member, isInterface); return null;"]}], "num": 30344}