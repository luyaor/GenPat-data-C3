{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9a43b4982e3b1dfb15641a635444e2c6", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "91dd561d3ab231d8cd8962674b58ae19", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Augmentor.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": "\r   \r   private static LinkedList<MethodData> _getVariableAccessorListHelper(SymbolData currClass)", "signatureAfterChange": "      private static LinkedList<MethodData> _getVariableAccessorListHelper(SymbolData currClass)", "diff": ["-  \r", "-  private static LinkedList<MethodData> _getVariableAccessorListHelper(SymbolData currClass) {\r", "-    List<Pair<VariableData, MethodData>> accessorMappings = new Vector<Pair<VariableData, MethodData>>();\r", "-    LinkedList<SymbolData> classes = new LinkedList<SymbolData>();\r", "-    classes.add(currClass);\r", "-    \r", "-    // Gather all accessor methods that have a matching signature with their variables\r", "-    while (classes.size() > 0) {\r", "-      SymbolData tempSd = classes.removeFirst();\r", "-      if (LanguageLevelVisitor.isJavaLibraryClass(tempSd.getName())) { break; }\r", "-      \r", "-      for (int i = 0; i<tempSd.getVars().size(); i++) {\r", "-        VariableData tempVd = tempSd.getVars().get(i);\r", "-        MethodData md = tempSd.getMethod(tempVd.getName(), new TypeData[0]);\r", "-        if (md != null)\r", "-          accessorMappings.add(new Pair<VariableData, MethodData>(tempVd, md));\r", "-      }\r", "-      // Note that we don't need to check interface fields, because they are always static.\r", "-      \r", "-      SymbolData superClass = tempSd.getSuperClass();\r", "-      if (superClass != null) classes.addFirst(superClass); // Insure that we traverse the superclass hierarchy before we traverse the outer class hierarchy\r", "-      Data outerData = tempSd.getOuterData();\r", "-      if (outerData != null) { classes.addLast(outerData.getSymbolData()); }\r", "-    }\r", "-  \r", "-    // Eliminate those accessors that are inaccessible, that throw exceptions, that are static, that are shadowed, or that have a different return type\r", "-    LinkedList<MethodData> allMethods = new LinkedList<MethodData>();\r", "-    for (int i = accessorMappings.size() - 1; i >= 0; i--) {\r", "-      VariableData vd = accessorMappings.get(i).getFirst();\r", "-      MethodData md = accessorMappings.get(i).getSecond();\r", "-      boolean canSeeMethod = TypeChecker.checkAccessibility(new NullLiteral(JExprParser.NO_SOURCE_INFO), md.getMav(), md.getName(), md.getSymbolData(), currClass, \"method\", false);\r", "-      //TODO: it is okay to throw Runtime exceptions or Errors) {\r", "-      if (canSeeMethod && (! md.hasModifier(\"static\")) && (md.getThrown().length == 0) && vd.getType().getSymbolData().isAssignableTo(md.getReturnType(), _targetVersion)) {\r", "-        boolean isShadowed = false;\r", "-        for (int j = i - 1; j >= 0; j--) {\r", "-          if (accessorMappings.get(j).getSecond().getName().equals(md.getName())) { isShadowed = true; break; }\r", "-        }\r", "-        if (!isShadowed) { allMethods.addFirst(md); }\r", "-      }\r", "-    }\r", "-    return allMethods;\r", "-  }\r", "+  ", "+  private static LinkedList<MethodData> _getVariableAccessorListHelper(SymbolData currClass) {", "+    List<Pair<VariableData, MethodData>> accessorMappings = new Vector<Pair<VariableData, MethodData>>();", "+    LinkedList<SymbolData> classes = new LinkedList<SymbolData>();", "+    classes.add(currClass);", "+    ", "+    // Gather all accessor methods that have a matching signature with their variables", "+    while (classes.size() > 0) {", "+      SymbolData tempSd = classes.removeFirst();", "+      if (LanguageLevelVisitor.isJavaLibraryClass(tempSd.getName())) { break; }", "+      ", "+      for (int i = 0; i<tempSd.getVars().size(); i++) {", "+        VariableData tempVd = tempSd.getVars().get(i);", "+        MethodData md = tempSd.getMethod(tempVd.getName(), new TypeData[0]);", "+        if (md != null)", "+          accessorMappings.add(new Pair<VariableData, MethodData>(tempVd, md));", "+      }", "+      // Note that we don't need to check interface fields, because they are always static.", "+      ", "+      SymbolData superClass = tempSd.getSuperClass();", "+      if (superClass != null) classes.addFirst(superClass); // Insure that we traverse the superclass hierarchy before we traverse the outer class hierarchy", "+      Data outerData = tempSd.getOuterData();", "+      if (outerData != null) { classes.addLast(outerData.getSymbolData()); }", "+    }", "+  ", "+    // Eliminate those accessors that are inaccessible, that throw exceptions, that are static, that are shadowed, or that have a different return type", "+    LinkedList<MethodData> allMethods = new LinkedList<MethodData>();", "+    for (int i = accessorMappings.size() - 1; i >= 0; i--) {", "+      VariableData vd = accessorMappings.get(i).getFirst();", "+      MethodData md = accessorMappings.get(i).getSecond();", "+      boolean canSeeMethod = TypeChecker.checkAccessibility(new NullLiteral(JExprParser.NO_SOURCE_INFO), md.getMav(), md.getName(), md.getSymbolData(), currClass, \"method\", false);", "+      //TODO: it is okay to throw Runtime exceptions or Errors) {", "+      if (canSeeMethod && (! md.hasModifier(\"static\")) && (md.getThrown().length == 0) && vd.getType().getSymbolData().isAssignableTo(md.getReturnType(), LanguageLevelConverter.OPT.javaVersion())) {", "+        boolean isShadowed = false;", "+        for (int j = i - 1; j >= 0; j--) {", "+          if (accessorMappings.get(j).getSecond().getName().equals(md.getName())) { isShadowed = true; break; }", "+        }", "+        if (!isShadowed) { allMethods.addFirst(md); }", "+      }", "+    }", "+    return allMethods;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf7290d255a5f78ece003037b317f229", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 77, "methodNumberAfterChange": 77, "signatureBeforeChange": "         public Object visit(MethodDeclaration node)", "signatureAfterChange": "     public Void visit(MethodDeclaration node)", "diff": ["-         */", "-        public Object visit(MethodDeclaration node) {", "-\t    MethodInfo mi         = classInfo.getMethod(node);", "-\t    int        af         = mi.getModifiers();", "-\t    String     mn         = node.getName();", "-\t    String     rt         = mi.getReturnType().getName();", "-\t    boolean    isAbstract;", "-", "-\t    // Check the modifiers", "-\t    if (isInterface) {", "-\t\tif (Modifier.isPrivate(af)   ||", "-\t\t    Modifier.isProtected(af) ||", "-\t\t    Modifier.isFinal(af)     ||", "-\t\t    Modifier.isStatic(af)) {", "-\t\t    node.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t     new String[] { node.getName(), classInfo.getName() });", "-\t\t    throw new ExecutionError(\"interface.method.modifier\", node);", "-\t\t}", "-\t\taf |= Modifier.PUBLIC | Modifier.ABSTRACT;", "-\t\tisAbstract = true;", "-\t    } else {", "-\t\tisAbstract = Modifier.isAbstract(af);", "-\t    }", "-\t    hasAbstractMethod |= isAbstract;", "-", "-\t    // Create the parameter array", "-\t    ClassInfo[] cia = mi.getParameterTypes();", "-\t    String[] params = new String[cia.length];", "-\t    for (int i = 0; i < cia.length; i++) {", "-\t\tparams[i] = cia[i].getName();", "-\t    }", "-", "-\t    // Create the exception array", "-\t    cia = mi.getExceptionTypes();", "-\t    String[] except = new String[cia.length];", "-\t    for (int i = 0; i < cia.length; i++) {", "-\t\texcept[i] = cia[i].getName();", "-\t    }", "-", "-\t    // Create the method", "-\t    classFactory.addMethod(af, rt, mn, params, except);", "-", "-\t    // Create the super method accessor", "-\t    if (!isInterface &&", "-\t\t!isAbstract &&", "-\t\tisRedefinedMethod(mi)) {", "-\t\tclassFactory.addSuperMethodAccessor(af, rt, mn, params, except);", "-\t    }", "-", "-\t    // Check the method", "-\t    Node body = node.getBody();", "-\t    if ((isAbstract && body != null) ||", "-\t\t(isInterface && body != null)) {", "-\t\tnode.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t new String[] { node.getName() });", "-\t\tthrow new ExecutionError(\"abstract.method.body\", node);", "-\t    }", "-", "-\t    if (!isAbstract && body == null) {", "-\t\tnode.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t new String[] { node.getName() });", "-\t\tthrow new ExecutionError(\"missing.method.body\", node);", "-\t    }", "-", "-\t    // Register the body", "-            if (body != null) {", "-                // Register the method", "-                String sig = ClassFactory.getMethodIdentifier", "-\t\t    (classInfo.getName(),", "-\t\t     mn,", "-\t\t     params,", "-\t\t     interpreter.getClassLoader().toString());", "-                interpreter.registerMethod(sig, node, importationManager);", "-            }", "-\t    return null;", "-\t}", "+     */", "+    public Void visit(MethodDeclaration node) {", "+      MethodInfo mi         = classInfo.getMethod(node);", "+      int        af         = mi.getModifiers();", "+      String     mn         = node.getName();", "+      String     rt         = mi.getReturnType().getName();", "+      boolean    isAbstract;", "+      ", "+      // Check the modifiers", "+      if (isInterface) {", "+        if (Modifier.isPrivate(af)   ||", "+            Modifier.isProtected(af) ||", "+            Modifier.isFinal(af)     ||", "+            Modifier.isStatic(af)) {", "+          node.setProperty(NodeProperties.ERROR_STRINGS,", "+                           new String[] { node.getName(), classInfo.getName() });", "+          throw new ExecutionError(\"interface.method.modifier\", node);", "+        }", "+        af |= Modifier.PUBLIC | Modifier.ABSTRACT;", "+        isAbstract = true;", "+      } else {", "+        isAbstract = Modifier.isAbstract(af);", "+      }", "+      hasAbstractMethod |= isAbstract;", "+      ", "+      // Create the parameter array", "+      ClassInfo[] cia = mi.getParameterTypes();", "+      String[] params = new String[cia.length];", "+      for (int i = 0; i < cia.length; i++) {", "+        params[i] = cia[i].getName();", "+      }", "+      ", "+      // Create the exception array", "+      cia = mi.getExceptionTypes();", "+      String[] except = new String[cia.length];", "+      for (int i = 0; i < cia.length; i++) {", "+        except[i] = cia[i].getName();", "+      }", "+      ", "+      // Create the method", "+      classFactory.addMethod(af, rt, mn, params, except);", "+      ", "+      // Create the super method accessor", "+      if (!isInterface &&", "+          !isAbstract &&", "+          isRedefinedMethod(mi)) {", "+        classFactory.addSuperMethodAccessor(af, rt, mn, params, except);", "+      }", "+      ", "+      // Check the method", "+      Node body = node.getBody();", "+      if ((isAbstract && body != null) ||", "+          (isInterface && body != null)) {", "+        node.setProperty(NodeProperties.ERROR_STRINGS,", "+                         new String[] { node.getName() });", "+        throw new ExecutionError(\"abstract.method.body\", node);", "+      }", "+      ", "+      if (!isAbstract && body == null) {", "+        node.setProperty(NodeProperties.ERROR_STRINGS,", "+                         new String[] { node.getName() });", "+        throw new ExecutionError(\"missing.method.body\", node);", "+      }", "+      ", "+      // Register the body", "+      if (body != null) {", "+        // Register the method", "+        String sig = ClassFactory.getMethodIdentifier", "+          (classInfo.getName(),", "+           mn,", "+           params,", "+           interpreter.getClassLoader().toString());", "+        interpreter.registerMethod(sig, node, importationManager);", "+      }", "+      return null;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd31007be70aef6f2dac0f6aeee1e7e7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public Class compile()", "signatureAfterChange": "   public Class compile()", "diff": ["+   */", "+  public Class compile() {", "+    // Create a class factory", "+    ClassInfo dc = classInfo.getDeclaringClass();", "+    String outer = (dc != null) ? dc.getName() : null;", "+    int       af = typeDeclaration.getAccessFlags();", "+    String  name = classInfo.getName();", "+    ", "+    if (isInterface) {", "+      af |= Modifier.INTERFACE;", "-     */", "-    public Class compile() {", "-\t// Create a class factory", "-\tClassInfo dc = classInfo.getDeclaringClass();", "-\tString outer = (dc != null) ? dc.getName() : null;", "-\tint       af = typeDeclaration.getAccessFlags();", "-\tString  name = classInfo.getName();", "-", "-\tif (isInterface) {", "-\t    af |= Modifier.INTERFACE;", "-\t}", "-", "-\tclassFactory = new ClassFactory(af,", "-\t\t\t\t\tname,", "-\t\t\t\t\tclassInfo.getSuperclass().getName(),", "-\t\t\t\t\tinterpreter.getClass(),", "-\t\t\t\t\tinterpreter.getExceptionClass(),", "-\t\t\t\t\tinterpreter.getClassLoader().toString());", "-", "-\t// Add the innerclass attributes", "-\tif (dc != null) {", "-\t    addInnerClassesAttribute(classInfo);", "-\t}", "-", "-\tClassInfo[] inners = classInfo.getDeclaredClasses();", "-\tfor (int i = 0; i < inners.length; i++) {", "-\t    String ciname = inners[i].getName();", "-", "-\t    InnerClassesEntry ice = classFactory.addInnerClassesEntry();", "-\t    ice.setInnerClassInfo(ciname);", "-\t    ice.setOuterClassInfo(name);", "-\t    ice.setInnerName(ciname.substring(name.length() + 1, ciname.length()));", "-\t    ice.setInnerClassAccessFlags((short)inners[i].getModifiers());", "-\t}", "-", "-\t// Add the interfaces", "-\tClassInfo[] ci = classInfo.getInterfaces();", "-\tfor (int i = 0; i < ci.length; i++) {", "-\t    classFactory.addInterface(ci[i].getName());", "-\t}", "-", "-\t// Check and create the members", "-\tIterator it = typeDeclaration.getMembers().iterator();", "-\twhile (it.hasNext()) {", "-\t    ((Node)it.next()).acceptVisitor(membersVisitor);", "-\t}", "-", "-\tif (!isInterface &&", "-\t    hasAbstractMethod &&", "-\t    !Modifier.isAbstract(af)) {", "-\t    typeDeclaration.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t\tnew String[] { name });", "-\t    throw new ExecutionError(\"misplaced.abstract\", typeDeclaration );", "-\t}", "-", "-\t// Create the constructor(s)", "-\tif (!isInterface) {", "-\t    ConstructorInfo[] cons = classInfo.getConstructors();", "-\t    for (int i = 0; i < cons.length; i++) {", "-\t\taddConstructor((TreeConstructorInfo)cons[i]);", "-\t    }", "-\t}", "-", "-\t// Create the class initializer", "-\tif (classInitializer.size() > 0) {", "-\t    interpreter.registerMethod", "-\t\t(classFactory.createClassInitializer(),", "-\t\t new MethodDeclaration(Modifier.PUBLIC,", "-\t\t\t\t       new VoidType(),", "-\t\t\t\t       \"<clinit>\",", "-\t\t\t\t       new LinkedList(),", "-\t\t\t\t       new LinkedList(),", "-\t\t\t\t       new BlockStatement(classInitializer)),", "-\t\t importationManager);", "-\t}", "-", "-\t// Define the class", "-\tTreeClassLoader classLoader = (TreeClassLoader)interpreter.getClassLoader();", "-\treturn classLoader.defineClass(name, classFactory.getByteCode());", "+    ", "+    classFactory = new ClassFactory(af,", "+                                    name,", "+                                    classInfo.getSuperclass().getName(),", "+                                    interpreter.getClass(),", "+                                    interpreter.getExceptionClass(),", "+                                    interpreter.getClassLoader().toString());", "+    ", "+    // Add the innerclass attributes", "+    if (dc != null) {", "+      addInnerClassesAttribute(classInfo);", "+    ", "+    ClassInfo[] inners = classInfo.getDeclaredClasses();", "+    for (int i = 0; i < inners.length; i++) {", "+      String ciname = inners[i].getName();", "+      ", "+      InnerClassesEntry ice = classFactory.addInnerClassesEntry();", "+      ice.setInnerClassInfo(ciname);", "+      ice.setOuterClassInfo(name);", "+      ice.setInnerName(ciname.substring(name.length() + 1, ciname.length()));", "+      ice.setInnerClassAccessFlags((short)inners[i].getModifiers());", "+    ", "+    // Add the interfaces", "+    ClassInfo[] ci = classInfo.getInterfaces();", "+    for (int i = 0; i < ci.length; i++) {", "+      classFactory.addInterface(ci[i].getName());", "+    ", "+    // Check and create the members", "+    Iterator it = typeDeclaration.getMembers().iterator();", "+    while (it.hasNext()) {", "+      ((Node)it.next()).acceptVisitor(membersVisitor);", "+    }", "+    ", "+    if (!isInterface &&", "+        hasAbstractMethod &&", "+        !Modifier.isAbstract(af)) {", "+      typeDeclaration.setProperty(NodeProperties.ERROR_STRINGS,", "+                                  new String[] { name });", "+      throw new ExecutionError(\"misplaced.abstract\", typeDeclaration );", "+    }", "+    ", "+    // Create the constructor(s)", "+    if (!isInterface) {", "+      ConstructorInfo[] cons = classInfo.getConstructors();", "+      for (int i = 0; i < cons.length; i++) {", "+        addConstructor((TreeConstructorInfo)cons[i]);", "+      }", "+    }", "+    ", "+    // Create the class initializer", "+    if (classInitializer.size() > 0) {", "+      interpreter.registerMethod", "+        (classFactory.createClassInitializer(),", "+         new MethodDeclaration(Modifier.PUBLIC,", "+                               new VoidType(),", "+                               \"<clinit>\",", "+                               new LinkedList<FormalParameter>(),", "+                               new LinkedList<List<IdentifierToken>>(),", "+                               new BlockStatement(classInitializer)),", "+         importationManager);", "+    }", "+    ", "+    // Define the class", "+    TreeClassLoader classLoader = (TreeClassLoader)interpreter.getClassLoader();", "+    return classLoader.defineClass(name, classFactory.getByteCode());", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eaba410404e5e8bb109abbb2378f26b5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     protected void addConstructor(TreeConstructorInfo ci)", "signatureAfterChange": "   protected void addConstructor(TreeConstructorInfo ci)", "diff": ["-     */", "-    protected void addConstructor(TreeConstructorInfo ci) {", "-\t// Get the parameter types", "-\tClassInfo[] cinf   = ci.getParameterTypes();", "-\tString[]    params = new String[cinf.length];", "-\tfor (int i = 0; i < cinf.length; i++) {", "-\t    params[i] = cinf[i].getName();", "-\t}", "-", "-\t// Get the exceptions", "-\tcinf = ci.getExceptionTypes();", "-\tString[] ex = new String[cinf.length];", "-\tfor (int i = 0; i < cinf.length; i++) {", "-\t    ex[i] = cinf[i].getName();", "-\t}", "-", "-\tString sig = ClassFactory.getMethodIdentifier", "-\t    (classInfo.getName(),", "-\t     \"<init>\",", "-\t     params,", "-\t     interpreter.getClassLoader().toString());", "-\tConstructorDeclaration cd = ci.getConstructorDeclaration();", "-", "-\t// Check the constructor's name", "-\tif (!cd.getName().equals(typeDeclaration.getName())) {", "-\t    cd.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t   new String[] { cd.getName() });", "-           throw new ExecutionError(\"constructor.name\", cd);", "-\t}", "-", "-\t// Register the constructor", "-\tConstructorInvocation civ = cd.getConstructorInvocation();", "-\tConstructorVisitor    cv = new ConstructorVisitor();", "-", "-\tif (civ != null) {", "-\t    Iterator it = cd.getParameters().iterator();", "-\t    while (it.hasNext()) {", "-\t\t((Node)it.next()).acceptVisitor(cv);", "-\t    }", "-\t    civ.acceptVisitor(cv);", "-", "-\t    interpreter.registerConstructorArguments", "-\t\t(sig,", "-\t\t cd.getParameters(),", "-\t\t civ.getArguments(),", "-\t\t importationManager);", "-\t} else {", "-\t    interpreter.registerConstructorArguments", "-\t\t(sig,", "-\t\t new LinkedList(),", "-\t\t new LinkedList(),", "-\t\t importationManager);", "-\t}", "-", "-\tMethodDeclaration md =", "-\t    new MethodDeclaration(cd.getAccessFlags(),", "-\t\t\t\t  new VoidType(),", "-\t\t\t\t  \"<init>\",", "-\t\t\t\t  cd.getParameters(),", "-\t\t\t\t  new LinkedList(),", "-\t\t\t\t  new BlockStatement(cd.getStatements()));", "-\tinterpreter.registerMethod(sig, md, importationManager);", "-\t", "-\t// Add the instance initialization statement to the constructor statement", "-\tif (!cv.superConstructor.equals(classInfo.getName())) {", "-\t    ListIterator lit = cd.getStatements().listIterator();", "-\t    Iterator it = instanceInitializer.iterator();", "-\t    while (it.hasNext()) {", "-\t\tlit.add(it.next());", "-\t    }", "-\t}", "-", "-\t// Create the constructor", "-\tclassFactory.addConstructor(cd.getAccessFlags(), params, ex,", "-\t\t\t\t    cv.superConstructor,", "-\t\t\t\t    cv.constructorParameters);", "+   */", "+  protected void addConstructor(TreeConstructorInfo ci) {", "+    // Get the parameter types", "+    ClassInfo[] cinf   = ci.getParameterTypes();", "+    String[]    params = new String[cinf.length];", "+    for (int i = 0; i < cinf.length; i++) {", "+      params[i] = cinf[i].getName();", "+    }", "+    ", "+    // Get the exceptions", "+    cinf = ci.getExceptionTypes();", "+    String[] ex = new String[cinf.length];", "+    for (int i = 0; i < cinf.length; i++) {", "+      ex[i] = cinf[i].getName();", "+    }", "+    ", "+    String sig = ClassFactory.getMethodIdentifier", "+      (classInfo.getName(),", "+       \"<init>\",", "+       params,", "+       interpreter.getClassLoader().toString());", "+    ConstructorDeclaration cd = ci.getConstructorDeclaration();", "+    ", "+    // Check the constructor's name", "+    if (!cd.getName().equals(typeDeclaration.getName())) {", "+      cd.setProperty(NodeProperties.ERROR_STRINGS,", "+                     new String[] { cd.getName() });", "+      throw new ExecutionError(\"constructor.name\", cd);", "+    }", "+    ", "+    // Register the constructor", "+    ConstructorInvocation civ = cd.getConstructorInvocation();", "+    ConstructorVisitor    cv = new ConstructorVisitor();", "+    ", "+    if (civ != null) {", "+      Iterator it = cd.getParameters().iterator();", "+      while (it.hasNext()) {", "+        ((Node)it.next()).acceptVisitor(cv);", "+      }", "+      civ.acceptVisitor(cv);", "+      ", "+      interpreter.registerConstructorArguments", "+        (sig,", "+         cd.getParameters(),", "+         civ.getArguments(),", "+         importationManager);", "+    } else {", "+      interpreter.registerConstructorArguments", "+        (sig,", "+         new LinkedList<FormalParameter>(),", "+         new LinkedList<Expression>(),", "+         importationManager);", "+    }", "+    ", "+    MethodDeclaration md =", "+      new MethodDeclaration(cd.getAccessFlags(),", "+                            new VoidType(),", "+                            \"<init>\",", "+                            cd.getParameters(),", "+                            new LinkedList<List<IdentifierToken>>(),", "+                            new BlockStatement(cd.getStatements()));", "+    interpreter.registerMethod(sig, md, importationManager);", "+    ", "+    // Add the instance initialization statement to the constructor statement", "+    if (!cv.superConstructor.equals(classInfo.getName())) {", "+      ListIterator<Node> lit = cd.getStatements().listIterator();", "+      Iterator<Node> it = instanceInitializer.iterator();", "+      while (it.hasNext()) {", "+        lit.add(it.next());", "+      }", "+    }", "+    ", "+    // Create the constructor", "+    classFactory.addConstructor(cd.getAccessFlags(), params, ex,", "+                                cv.superConstructor,", "+                                cv.constructorParameters);", "+  }"]}], "num": 13141}