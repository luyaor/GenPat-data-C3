{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1b99f907f1d602192a129c7371f6c6fe", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "406b31b2de2a5a2302aaf852ac7afec4", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/RegionsTreePanel.java", "commitBeforeChange": "b9f87cd074abdafacdb2719b29e0803fd0f81cf0", "commitAfterChange": "04d7824a20eb03ad17793ba3198be21442313bdc", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "\r   public void addRegion(final R r)", "signatureAfterChange": "   public void addRegion(final R r)", "diff": ["-    */\r", "-  public void addRegion(final R r) {\r", "-    File file = r.getDocument().getRawFile();\r", "-//    try { name = r.getDocument().getQualifiedClassName(); }\r", "-//    catch (ClassNameNotFoundException cnnfe) { name = r.getDocument().toString(); }\r", "-    \r", "-    DefaultMutableTreeNode regDocNode = new DefaultMutableTreeNode(file);\r", "-    \r", "-    // Look for matching document node\r", "-    // Raw type here due to Swing's use of raw types.\r", "-    Enumeration documents = _regionRootNode.children();\r", "-    boolean done = false;\r", "-    while (! done && (documents.hasMoreElements())) {\r", "-      DefaultMutableTreeNode doc = (DefaultMutableTreeNode)documents.nextElement();\r", "-      if (doc.getUserObject().equals(regDocNode.getUserObject())) {\r", "-        \r", "-        // Create a new region in this node\r", "-        // Sort regions by start offset.\r", "-        // Raw type here due to Swing's use of raw types.\r", "-        Enumeration existingRegions = doc.children();\r", "-        while (existingRegions.hasMoreElements()) {\r", "-          DefaultMutableTreeNode existing = (DefaultMutableTreeNode)existingRegions.nextElement();\r", "-          \r", "-          // if start offset of indexed regions is less than new region, continue\r", "-          int ofs = r.getStartOffset();\r", "-          if (((RegionTreeUserObj)existing.getUserObject()).region().getStartOffset() == ofs) {\r", "-            _changeState.scrollPathToVisible(new TreePath(existing));\r", "-            _changeState.setLastAdded(existing);\r", "-            done = true;\r", "-            break;\r", "-          }\r", "-          else if (((RegionTreeUserObj)existing.getUserObject()).region().getStartOffset() > ofs) {\r", "-            \r", "-            // else, add to the list\r", "-            DefaultMutableTreeNode newRegion = new DefaultMutableTreeNode(makeRegionTreeUserObj(r));\r", "-            _regTreeModel.insertNodeInto(newRegion, doc, doc.getIndex(existing));\r", "-\r", "-            // Make sure this node is visible\r", "-            _changeState.scrollPathToVisible(new TreePath(newRegion.getPath()));\r", "-            _changeState.setLastAdded(newRegion);\r", "-            done = true;\r", "-            break;\r", "-          }\r", "-        }\r", "-        if (done) { break; }\r", "-        \r", "-        // if none are greater, add at the end\r", "-        DefaultMutableTreeNode newRegion = new DefaultMutableTreeNode(makeRegionTreeUserObj(r));\r", "-        _regTreeModel.insertNodeInto(newRegion, doc, doc.getChildCount());\r", "-        \r", "-        // Make sure this node is visible\r", "-        _changeState.scrollPathToVisible(new TreePath(newRegion.getPath()));\r", "-        _changeState.setLastAdded(newRegion);\r", "-        done = true;\r", "-        break;\r", "-      }\r", "-    }\r", "-    \r", "-    if (! done) {\r", "-      // No matching document node was found, so create one\r", "-      _regTreeModel.insertNodeInto(regDocNode, _regionRootNode, _regionRootNode.getChildCount());\r", "-      DefaultMutableTreeNode newRegion = new DefaultMutableTreeNode(makeRegionTreeUserObj(r));\r", "-      _regTreeModel.insertNodeInto(newRegion, regDocNode, regDocNode.getChildCount());\r", "-      \r", "-      // Make visible\r", "-      _changeState.scrollPathToVisible(new TreePath(newRegion.getPath()));\r", "-      _changeState.setLastAdded(newRegion);\r", "-    }\r", "-    \r", "-    _changeState.updateButtons();\r", "-  }\r", "+    */", "+  public void addRegion(final R r) {", "+    OpenDefinitionsDocument doc = r.getDocument();", "+    File file = doc.getRawFile();", "+    ", "+    DefaultMutableTreeNode docNode = _regionManager.getTreeNode(doc);", "+    if (docNode == null) {", "+      // No matching document node was found, so create one", "+      docNode = new DefaultMutableTreeNode(file);", "+      _regTreeModel.insertNodeInto(docNode, _rootNode, _rootNode.getChildCount());", "+      _regionManager.setTreeNode(doc, docNode);", "+    }", "+    ", "+    @SuppressWarnings(\"unchecked\")", "+    Enumeration<DefaultMutableTreeNode> regionNodes = (Enumeration<DefaultMutableTreeNode>) docNode.children();", "+    ", "+    // Create a new region node in this document node list, where regions are sorted by start offset.", "+    int offset = r.getStartOffset();", "+    ", "+    for (int index = 0; true ; index++) {  // infinite loop incrementing index on each iteration", "+  ", "+      if (! regionNodes.hasMoreElements()) { // exhausted all elements; insert new region node at end", "+        insertNewRegionNode(r, docNode, index);", "+        break;", "+      }", "+      DefaultMutableTreeNode node = regionNodes.nextElement();", "+      ", "+      @SuppressWarnings(\"unchecked\")", "+      RegionTreeUserObj<R> userObject = (RegionTreeUserObj<R>) node.getUserObject();", "+      R nodeRegion = userObject.region();", "+      int nodeOffset = nodeRegion.getStartOffset();", "+      ", "+      if (nodeOffset == offset) {", "+        // region with same start offset already exists", "+        if (nodeRegion.getEndOffset() == r.getEndOffset()) {", "+          // silently suppress inserting region; can this happen?  Caller should suppress it.", "+          _changeState.scrollPathToVisible(new TreePath(node));", "+          _changeState.setLastAdded(node);", "+          break;", "+        }", "+        else { // new region is distinct from nodeRegion", "+          insertNewRegionNode(r, docNode, index);", "+          break;", "+        }", "+      }", "+      else if (nodeOffset > offset) {", "+        insertNewRegionNode(r, docNode, index);", "+        break;", "+      }", "+    }    ", "+    _changeState.updateButtons();", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f5cb69fc5de6a4a5c58fda25835282b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "45afdf26640d7e2a166ed67c249ba6fd207b1d2b", "commitAfterChange": "e7a6b9c5a51a2cf7b9cfb5a10d90c24a3c7c3844", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "diff": ["-    /* The visitedFiles returned by any pass may include another file which is already scheduled for compilation.", "-     In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "-     already been done.  (An error is thrown if we do since it thinks the class has already been defined). */", "-    // WHAT visitedFiles are RETURNED?  HOW?  The return type is a Pair containing NO files!  I SMELL GLOBAL VARIABLES!", "-    LinkedList<File> filesNotToCheck = new LinkedList<File>();", "+//    /* The visitedFiles returned by any pass may include another file which is already scheduled for compilation.", "+//     In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "+//     already been done.  (An error is thrown if we do since it thinks the class has already been defined). */", "+//    // WHAT visitedFiles are RETURNED?  HOW?  The return type is a Pair containing NO files!  I SMELL GLOBAL VARIABLES!", "+//    LinkedList<File> filesNotToCheck = new LinkedList<File>();", "-    /* The number of files to compile may change if one file references another one.", "-     We don't want to visit these newly referenced files because they've already", "-     been visited. */", "-    // WHAT DOES VISIT MEAN?", "-    int originalNumOfFiles = files.length;", "+//    /* The number of files to compile may change if one file references another one.", "+//     We don't want to visit these newly referenced files because they've already", "+//     been visited. */", "+//    // WHAT DOES VISIT MEAN?", "+//    int originalNumOfFiles = files.length;", "-    /* Find the files in the File[] array files that are LL files. Do the parsing, conformance checking, and ", "-     * type-checking passes first for ALL files before proceeding to code augmentation.  Otherwise if one class's", "-     * superclass get augmented first, then it sees a lot of illegal constructs (e.g. public and constructors). */", "+    /* Find the files in the File[] array files that are LL, advanced or Full Java files. Do the parsing and conformance ", "+     * checking passes first for ALL files before proceeding to type-checking (for LL files) and code augmentation.  ", "+     * Type-checking and class augmentation require a complete symbol table. */", "-    /* Maintains the files we visit along with their visitors (for type checking step). */", "-    LinkedList<Pair<LanguageLevelVisitor, SourceFile>> visited = ", "-      new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>();", "+    /* Maintains the files we visit along with their visitors (for type checking and augmentation steps). */", "+    LinkedList<Triple<LanguageLevelVisitor, SourceFile, File>> visited = ", "+      new LinkedList<Triple<LanguageLevelVisitor, SourceFile, File>>();", "-    /* Maintains the list of advanced files, which are no longer parsed and checked; they are simply converted to .java", "-     * files unchanged and unchecked (except for nullity). */", "+    /* Maintains the files to be augmented along with their visitors (for augmentation step). */", "+    LinkedList<Triple<LanguageLevelVisitor, SourceFile, File>> toAugment = ", "+      new LinkedList<Triple<LanguageLevelVisitor, SourceFile, File>>();", "+    ", "+    /* Maintains the list of advanced files, which are converted to .java files and treated like .java files. */", "+    /* Maintains the list of Full Java files, which are parsed for symbols and checked for gross errors. */", "+    LinkedList<File> javaFiles = new LinkedList<File>();", "+    ", "+    /** First pass: classfication and conformance checking */", "-        if (filesNotToCheck.contains(f)) continue;  // Detects equal Files objects", "+//        if (filesNotToCheck.contains(f)) continue;  // Detects equal File objects", "-        if (isAdvancedFile(f)) advanced.addLast(f);", "+        if (isAdvancedFile(f))  advanced.addLast(f);", "+        else if (isFullJavaFile(f)) javaFiles.addLast(f);", "-        else if (_isLanguageLevelFile(f)) {  /* a .dj0 or .dj1 or .dj file */", "+        if (isJavaFile(f)) {  /* a .dj0, .dj1, .dj2,, .dj, or .java file */", "-          LanguageLevelVisitor llv = new IntermediateVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(),", "-                                                             new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "-                                                             languageLevelVisitedFiles);", "+          LanguageLevelVisitor llv;", "+          if (isLanguageLevelFile(f)) {", "+            llv = new IntermediateVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(),", "+                                          new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "+                                          languageLevelVisitedFiles);", "+          }", "+          else {", "+            assert isAdvancedFile(f) || isFullJavaFile(f);", "+            llv = new FullJavaVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(),", "+                                      new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "+                                      languageLevelVisitedFiles);", "+          }", "-          // First pass", "+          // Conformance checking pass", "-          visited.add(new Pair<LanguageLevelVisitor, SourceFile>(llv, sf));", "+          visited.add(new Triple<LanguageLevelVisitor, SourceFile, File>(llv, sf, f));", "-    ", "-//    Utilities.show(\"Visited \" + visited + \" in first pass\");", "-    // Resolve continuations and create constructors.  Also accumulate errors.", "+", "+    /* Resolve continuations created in conformance pass and log any generated errors. */", "-    ", "-    //Resolve continuations", "-    //Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>> continuations = llv.continuations;", "-//          System.err.println(\"Could not find SymbolData for '\" + className + \"'\");", "+//          if (className.equals(\"listFW.IList\")) {", "+//            System.err.println(\"Cannot resolve listFW.List\\nsymbolTable is:\\n\" + symbolTable);", "+//          }", "-    // Create any constructors.", "+    /* Create any constructors identified in the conformance pass and log any errors encountered. */", "-    }", "+    } ", "+    /* Add any errors that accumulated during the continuation resolving/constructor generation. */", "-    languageLevelVisitorErrors.addAll(LanguageLevelVisitor.errors); //add any errors that accumulated during the continuation resolving/constructor generation", "+    languageLevelVisitorErrors.addAll(LanguageLevelVisitor.errors); ", "-    // Check for errors; don't type-check if there are errors.", "+    ", "+    /* If there are no errors, perform type-checking on LL files. */", "-    else { //Let's TYPE CHECK!!!", "-      ", "-      ", "-      for (int ind = 0; ind < visited.size(); ind++) {", "+    else  { /* Perform type-checking on visited LL files and build list of files toAugment. */", "+      for (Triple<LanguageLevelVisitor, SourceFile, File> triple: visited) {", "-        LanguageLevelVisitor llv = visited.get(ind).getFirst();", "-        SourceFile sf = visited.get(ind).getSecond();", "+        LanguageLevelVisitor llv = triple.getFirst();", "+        SourceFile sf = triple.getSecond();", "+        File f = triple.getThird();", "-        ", "-        //TODO: This is a terrible hack to get around the following problem.  Basically, when we autobox in isAssignableTo in SymbolData, ", "-        //we look through the object hierarchy for the primitive.  If its corresponding boxed object isn't in the symboltable, we're in trouble.", "-        //So, for those special cases, go ahead and make sure the object types are in the symbol table before we start type checking.", "-        //I'd like to make this better, but at least it works for now.", "-        ", "-        // Note: \"llv.\" formerly preceded symbolTable and getSymbolData", "-        ", "-        //Before you type check, make sure that all boxed types of primitives are in the symbol table", "-        if (symbolTable.get(\"java.lang.Integer\") == null)   { llv.getSymbolData(\"java.lang.Integer\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Double\") == null)    { llv.getSymbolData(\"java.lang.Double\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Character\") == null) { llv.getSymbolData(\"java.lang.Character\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Boolean\") == null)   { llv.getSymbolData(\"java.lang.Boolean\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Long\") == null)      { llv.getSymbolData(\"java.lang.Long\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Byte\") == null)      { llv.getSymbolData(\"java.lang.Byte\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Short\") == null)     { llv.getSymbolData(\"java.lang.Short\", SourceInfo.NO_INFO);}", "-        if (symbolTable.get(\"java.lang.Float\") == null)     { llv.getSymbolData(\"java.lang.Float\", SourceInfo.NO_INFO);}", "-        ", "-        ", "-        // Type check.", "-        TypeChecker btc = ", "-          new TypeChecker(llv._file, llv._package, llv.errors, symbolTable, llv._importedFiles, llv._importedPackages);", "+        if (isAdvancedFile(f)) { toAugment.addLast(triple); }", "+        else if (isLanguageLevelFile(f)) {", "+          // This is a hack to get around the following problem.  Basically, when we autobox in isAssignableTo in ", "+          // SymbolData, we look through the object hierarchy for the primitive.  If its corresponding", "+          // boxed object isn't in the symboltable, we're in trouble.  So, for those special cases, go ahead and make ", "+          // sure the object types are in the symbol table before we start type checking", "+          ", "+          //Before you type check, make sure that all boxed types of primitives are in the symbol table", "+          ", "+          if (symbolTable.get(\"java.lang.Integer\") == null) llv.getSymbolData(\"java.lang.Integer\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Double\") == null)  llv.getSymbolData(\"java.lang.Double\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Boolean\") == null) llv.getSymbolData(\"java.lang.Boolean\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Long\") == null)    llv.getSymbolData(\"java.lang.Long\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Byte\") == null)    llv.getSymbolData(\"java.lang.Byte\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Short\") == null)   llv.getSymbolData(\"java.lang.Short\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Float\") == null)   llv.getSymbolData(\"java.lang.Float\", SourceInfo.NO_INFO);", "+          if (symbolTable.get(\"java.lang.Character\") == null) ", "+            llv.getSymbolData(\"java.lang.Character\", SourceInfo.NO_INFO);", "+          ", "+          // Type check.", "+          TypeChecker btc = ", "+            new TypeChecker(llv._file, llv._package, llv.errors, symbolTable, llv._importedFiles, llv._importedPackages);", "-        sf.visit(btc);", "-        if (btc.errors.size() > 0) _visitorErrors.addAll(btc.errors);", "-      }", "-      ", "-      /* Set up code augmentation.  We will NOT try to augment files unless they appear in the visited List.  Unlisted", "-       * LL files cannot be found reliably during type checking because there is no naming convention that tells the ", "-       * type checker what files to look for. */", "-      ", "-      Iterator<Pair<LanguageLevelVisitor, SourceFile>> iter = visited.iterator();", "-      LinkedList<File> newFiles = new LinkedList<File>();", "-      for (int ind = 0; iter.hasNext(); ind++) { // Note unusual loop termination condition; iter, ind in lock step", "-        Pair<LanguageLevelVisitor, SourceFile> currPair = iter.next();", "-        File fileToAdd = currPair.getFirst()._file;", "-        ", "-        if (_isLanguageLevelFile(fileToAdd)) { // fileToAdd is a visited LL file", "-//          Utilities.show(fileToAdd + \" is a LL file for augmentation\");", "-          newFiles.addLast(fileToAdd);", "-          mediator.put(ind, new Pair<SourceFile, LanguageLevelVisitor>(currPair.getSecond(), currPair.getFirst())); ", "+          sf.visit(btc);", "+          toAugment.addLast(triple);", "+          if (btc.errors.size() > 0) _visitorErrors.addAll(btc.errors);", "-        ", "-        // Also make sure not to re-check these files whether we visited source or class file. ", "-        // We only want to perform code augmentation since these files have already been visited.", "-        if (! filesNotToCheck.contains(fileToAdd)) filesNotToCheck.addLast(fileToAdd);", "-      newFiles.addAll(advanced);", "-      files = newFiles.toArray(new File[newFiles.size()]);  // include advanced files", "-//      Utilities.show(\"Created files array: \" + Arrays.toString(files));", "+//      /* Set up code augmentation.  We will NOT try to augment files unless they appear in the visited List and are not", "+//       * already Full Java (.java) files.  Unlisted LL files cannot be found reliably during type checking because there", "+//       * is no naming convention that tells the type checker what files to look for. */", "+      ", "+//      Iterator<Pair<LanguageLevelVisitor, SourceFile>> iter = visited.iterator();", "+//      LinkedList<File> filesToAugment = new LinkedList<File>();", "+//      for (int ind = 0; iter.hasNext(); ind++) { // Note unusual loop termination condition; iter, ind in lock step", "+//        Pair<LanguageLevelVisitor, SourceFile> currPair = iter.next();", "+//        File fileToAdd = currPair.getFirst()._file;", "+//        ", "+//        if (isLanguageLevelFile(fileToAdd)) { // fileToAdd is a visited LL file", "+////          Utilities.show(fileToAdd + \" is a LL file for augmentation\");", "+//          filesToAugment.addLast(fileToAdd);", "+//          mediator.put(ind, new Pair<SourceFile, LanguageLevelVisitor>(currPair.getSecond(), currPair.getFirst())); ", "+//        }", "+//        ", "+//        // Also make sure not to re-check these files whether we visited source or class file. ", "+//        // We only want to perform code augmentation since these files have already been visited.", "+////        if (! filesNotToCheck.contains(fileToAdd)) filesNotToCheck.addLast(fileToAdd);", "+//      }", "+//      ", "+//      filesToAugment.addAll(advanced);  // include advanced files in files to augment", "+//      files = filesToAugment.toArray(new File[filesToAugment.size()]); ", "+////      Utilities.show(\"Created files array: \" + Arrays.toString(files));", "-      return new Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions, _visitorErrors);", "+      return new Pair<LinkedList<JExprParseException>, ", "+        LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions, _visitorErrors);", "-    // Now do code augmentation.", "-    for (int ind = 0; ind < files.length; ind++) {", "-      File f = files[ind];", "+    ", "+    /* Perform code augmentation. */   ", "+    for (Triple<LanguageLevelVisitor, SourceFile, File> triple: toAugment) ", "+      ", "+      LanguageLevelVisitor llv = triple.getFirst();", "+      SourceFile sf = triple.getSecond();", "+      File f = triple.getThird();", "+      ", "+      File augmentedFile = getJavaForLLFile(f); // create  empty .java file for .dj? file", "+      ", "+      if (isAdvancedFile(f)) { Utilities.copyFile(f, augmentedFile); }", "+      else {", "+        BufferedReader tempBr = new BufferedReader(new FileReader(f));", "+        String firstLine = tempBr.readLine();", "+        tempBr.close(); // Important to close the reader, otherwise Windows will not allow the renameTo call later.", "+        if (firstLine == null) continue;", "-        // Set up augmented file", "-        File augmentedFile = getJavaForLLFile(f); //replace .dj? with .java", "-        ", "-        if (isAdvancedFile(f)) {", "-          Utilities.copyFile(f, augmentedFile);", "-        }", "-        else {", "-//        Utilities.show(\"File is: \" + f + \" mediator is: \" + mediator.get(ind));", "-          BufferedReader tempBr = new BufferedReader(new FileReader(f));", "-          String firstLine = tempBr.readLine();", "-          tempBr.close(); // Important to close the reader, otherwise Windows will not allow the renameTo call later.", "-          if (firstLine == null) continue;", "-          ", "-          // If the file has an appropriate LL extension, then parse it.", "-          if (_isLanguageLevelFile(f)) {", "-            Pair<SourceFile, LanguageLevelVisitor> pair = mediator.get(new Integer(ind));", "-            if (pair == null) {", "-              // _log.log(\"Not augmenting \" + f + \" no mediator\");", "-//            Utilities.show(\"Not augmenting \" + f + \" no mediator\");", "-            }", "+        // If the file has an appropriate LL extension, then parse it.", "+        if (isLanguageLevelFile(f)) {", "+          if (triple != null) {  // if triple is null, we do not actually need to augment this file--it wasn't visited.", "-            if (pair != null) { //if pair is null, we do not actually need to augment this file--it wasn't visited.  Maybe we used the class file?", "-              SourceFile sf = pair.getFirst();", "-              LanguageLevelVisitor llv = pair.getSecond();", "-//            File f = files[ind];", "-              ", "-              // Do code augmentation", "-              BufferedReader br = new BufferedReader(new FileReader(f), INPUT_BUFFER_SIZE);", "-              StringWriter sw = new StringWriter();", "-              BufferedWriter bw = new BufferedWriter(sw);", "-              ", "-              // _log.log(\"Augmenting the source file \" + sf);", "+            // Do code augmentation", "+            BufferedReader br = new BufferedReader(new FileReader(f), INPUT_BUFFER_SIZE);", "+            StringWriter sw = new StringWriter();", "+            BufferedWriter bw = new BufferedWriter(sw);", "+            ", "+            // _log.log(\"Augmenting the source file \" + sf);", "-              Augmentor a = new Augmentor(SAFE_SUPPORT_CODE, br, bw, llv);", "-              sf.visit(a);", "-              ", "-              br.close();", "-              bw.close();", "-              ", "-              // write out the line number map and the augmented java file", "-              PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(augmentedFile)));", "-              SortedMap<Integer,Integer> lineNumberMap = a.getLineNumberMap();", "-              pw.println(\"// Language Level Converter line number map: dj*->java. Entries: \"+lineNumberMap.size());", "-              // We print out LINE_NUM_MAPPINGS_PER_LINE mappings per line, so we need numLines", "-              // at the top of the file, and one more for a descriptive comment.", "-              // That means we need to increase the line numbers in the generated java file by numLines+1", "-              int numLines = (int)Math.ceil(((double)lineNumberMap.size())/LINE_NUM_MAPPINGS_PER_LINE);", "-              int mapCount = 0;", "-              for(Map.Entry<Integer,Integer> e: lineNumberMap.entrySet()) {", "-                // e.getKey(): dj* line number; e.getValue(): java line number (must be increased by numLines)", "-                if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==0) pw.print(\"//\");", "-                pw.printf(\" %5d->%-5d\", e.getKey(), (e.getValue()+numLines+1));", "-                if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==LINE_NUM_MAPPINGS_PER_LINE-1) pw.println();", "-                ++mapCount;", "-              }", "-              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE!=0) pw.println(); // print a newline unless we just printed one", "-              ", "-              String augmented = sw.toString();", "-              pw.write(augmented, 0, augmented.length());", "-              pw.close();", "+            Augmentor a = new Augmentor(SAFE_SUPPORT_CODE, br, bw, llv);", "+            sf.visit(a);", "+            ", "+            br.close();", "+            bw.close();", "+            ", "+            // write out the line number map and the augmented java file", "+            PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(augmentedFile)));", "+            SortedMap<Integer,Integer> lineNumberMap = a.getLineNumberMap();", "+            pw.println(\"// Language Level Converter line number map: dj*->java. Entries: \"+lineNumberMap.size());", "+            // We print out LINE_NUM_MAPPINGS_PER_LINE mappings per line, so we need numLines", "+            // at the top of the file, and one more for a descriptive comment.", "+            // That means we need to increase the line numbers in the generated java file by numLines+1", "+            int numLines = (int)Math.ceil(((double)lineNumberMap.size())/LINE_NUM_MAPPINGS_PER_LINE);", "+            int mapCount = 0;", "+            for(Map.Entry<Integer,Integer> e: lineNumberMap.entrySet()) {", "+              // e.getKey(): dj* line number; e.getValue(): java line number (must be increased by numLines)", "+              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==0) pw.print(\"//\");", "+              pw.printf(\" %5d->%-5d\", e.getKey(), (e.getValue()+numLines+1));", "+              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==LINE_NUM_MAPPINGS_PER_LINE-1) pw.println();", "+              ++mapCount;", "+            if (mapCount%LINE_NUM_MAPPINGS_PER_LINE!=0) pw.println(); // print a newline unless we just printed one", "+            ", "+            String augmented = sw.toString();", "+            pw.write(augmented, 0, augmented.length());", "+            pw.close();", "-      catch (Augmentor.Exception ae) {", "-        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-        _addVisitorError(new Pair<String, JExpressionIF>(ae.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "-      }", "-      catch (IOException ioe) {", "-        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-        _addVisitorError(new Pair<String, JExpressionIF>(ioe.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "-      }", "-    return new Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions,", "-                                                                                              _visitorErrors);", "+    catch (Augmentor.Exception ae) {", "+      // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "+      _addVisitorError(new Pair<String, JExpressionIF>(ae.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "+    }", "+    catch (IOException ioe) {", "+      // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "+      _addVisitorError(new Pair<String, JExpressionIF>(ioe.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "+    }", "+    return new Pair<LinkedList<JExprParseException>, ", "+      LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions, _visitorErrors);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f00b9dca4e33931cf23df0ba30d2c04", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/newjvm/AbstractMasterJVM.java", "commitBeforeChange": "3ae33096a45a4dc4990b95b1565bd0aeaf9084da", "commitAfterChange": "e69a4c60c625d52f9ba6a18669f0f6846846e463", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "   protected final void invokeSlave(String[] jvmArgs, String cp, File workDir) throws IOException, RemoteException", "signatureAfterChange": "   protected final void invokeSlave(final String[] jvmArgs, final String cp, final File workDir) throws IOException,      RemoteException", "diff": ["-  protected final void invokeSlave(String[] jvmArgs, String cp, File workDir) throws IOException, RemoteException {", "+  protected final void invokeSlave(final String[] jvmArgs, final String cp, final File workDir) throws IOException, ", "+    RemoteException {", "-    _log.log(this + \".invokeSlave(\" + edu.rice.cs.util.StringOps.toString(jvmArgs) + \", \" + cp + \", \" + workDir + \") called\");", "-    ", "-    synchronized(_masterJVMLock) {", "+    synchronized(_masterJVMLock) { // synchronization prelude only lets one thread at a time execute the sequel", "-      if (_startupInProgress) throw new IllegalStateException(\"startup is in progress in invokeSlave\");      ", "-      if (_slave != null) throw new IllegalStateException(\"slave non-null in invoke: \" + _slave);", "-      ", "+      try { while (_startupInProgress || _monitorThread != null) _masterJVMLock.wait(); }", "+      catch(InterruptedException e) { throw new UnexpectedException(e); }", "-      _stub = null;", "-    /**********************************************", "-     * First, we we export ourselves to a file... *", "-     **********************************************/", "-//      Thread t = new Thread(_exportMasterThreadName) {", "-//        public void run() {", "-    _log.log(AbstractMasterJVM.this + \" starting creation of RMI stub for AbstractMasterJVM\");", "-    try { _stub = UnicastRemoteObject.exportObject(AbstractMasterJVM.this); }", "+    _log.log(this + \".invokeSlave(...) called\");", "+    assert (_slave != null);", "-    // Debug: check that the IP address is 127.0.0.1", "-    // javax.swing.JOptionPane.showMessageDialog(null, _stub.toString());", "-    ", "-    catch (RemoteException re) {", "-      // javax.swing.JOptionPane.showMessageDialog(null, edu.rice.cs.util.StringOps.getStackTrace(re));", "-      throw new UnexpectedException(re);  // should never happen", "+    /******************************************************************************************************", "+     * First, we we export ourselves to a file, if it has not already been done on a previous invocation. *", "+     *****************************************************************************************************/", "+", "+    if (_masterStub == null) {", "+      try { _masterStub = (MasterRemote) UnicastRemoteObject.exportObject(this); }", "+      catch (RemoteException re) {", "+        javax.swing.JOptionPane.showMessageDialog(null, edu.rice.cs.util.StringOps.getStackTrace(re));", "+        _log.log(this + \" threw \" + re);", "+        throw new UnexpectedException(re);  // should never happen", "+      }", "+      _log.log(this + \" EXPORTed Master JVM\");", "+      ", "+      _masterStubFile = File.createTempFile(\"DrJava-remote-stub\", \".tmp\");", "+      _masterStubFile.deleteOnExit();", "+      ", "+      // serialize stub to _masterStubFile", "+      FileOutputStream fstream = new FileOutputStream(_masterStubFile);", "+      ObjectOutputStream ostream = new ObjectOutputStream(fstream);", "+      ostream.writeObject(_masterStub);", "+      ostream.flush();", "+      fstream.close();", "+      ostream.close();", "-//          synchronized(_exportLock) { _exportLock.notify(); }", "-//        }", "-//      };", "-//      t.start();", "-//      synchronized(_exportLock) {", "-//        try {", "-//          while (_stub == null) { ", "-//            _log.log(\"invokeSlave thread in \" + this + \" waiting for creation of AbstractMasterJVM RMI stub to complete\");", "-//            _exportLock.wait(); ", "-//          } ", "-//        }", "-//        catch (InterruptedException ie) { throw new UnexpectedException(ie); }  // should never happen", "-    ", "-    _log.log(this + \" completed creation of RMI stub for AbstractMasterJVM\");", "-    _stubFile = File.createTempFile(\"DrJava-remote-stub\", \".tmp\");", "-    _stubFile.deleteOnExit();", "-    ", "-    // serialize stub to _stubFile", "-    FileOutputStream fstream = new FileOutputStream(_stubFile);", "-    ObjectOutputStream ostream = new ObjectOutputStream(fstream);", "-    ostream.writeObject(_stub);", "-    ostream.flush();", "-    fstream.close();", "-//      ostream.close();", "-    ", "-    _log.log(this + \" completed writing RMI stub for AbstractMasterJVM to a file\");", "-    ", "-    /***********************************************************************************", "-     * Done exporting ourselves to a file ...  Now let's export our classloader        *", "-     * This will be used to handle classloading requests from the slave jvm.           *", "-     ***********************************************************************************/", "-    ", "-    final RemoteClassLoader _classLoader = new RemoteClassLoader(getClass().getClassLoader());", "-    _classLoaderStub = null;", "-//      t = new Thread(_exportMasterThreadName) {", "-//        public void run() {", "-    _log.log(AbstractMasterJVM.this + \" starting creation of RMI stub for RemoteClassLoader\");", "-    try {  _classLoaderStub = UnicastRemoteObject.exportObject(_classLoader); }", "-    ", "-    // Debug: check that the IP address is 127.0.0.1", "-    //javax.swing.JOptionPane.showMessageDialog(null, _stub.toString());", "-    ", "-    catch (RemoteException re) {", "-      //javax.swing.JOptionPane.showMessageDialog(null, edu.rice.cs.util.StringOps.getStackTrace(re));", "-      throw new UnexpectedException(re);  // should never happen", "-    }", "-//          synchronized(_exportLock) { _exportLock.notify(); }", "-//        }", "-//      };", "-    ", "-//      t.start();", "-//      synchronized(_exportLock) {", "-//        try { ", "-//          while (_classLoaderStub == null) { ", "-//            _log.log(\"invokeSlave thread in \" + this + \" waiting for creation of RemoteClassLoader RMI stub to complete\");", "-//            _exportLock.wait(); ", "-//          } ", "-//        }", "-//        catch (InterruptedException ie) { throw new UnexpectedException(ie); }  // should never happen", "-//      }", "-    ", "-    _log.log(this + \" completed creation of RMI stub for RemoteClassLoader\");", "-    _classLoaderStubFile = File.createTempFile(\"DrJava-remote-stub\", \".tmp\");", "-    _classLoaderStubFile.deleteOnExit();", "-    // serialize stub to _classLoaderStubFile", "-    fstream = new FileOutputStream(_classLoaderStubFile);", "-    ostream = new ObjectOutputStream(fstream);", "-    ostream.writeObject(_classLoaderStub);", "-    ostream.flush();", "-    fstream.close();", "-    ostream.close();", "-    ", "-    _log.log(this + \" completed writing RMI stub for RemoteClassLoader to a file\");", "-    ", "-    String[] args = ", "-      new String[] { _stubFile.getAbsolutePath(), _slaveClassName, _classLoaderStubFile.getAbsolutePath() };", "-    ", "-    /* Create the slave JVM. */  ", "-    _log.log(this + \" is starting a slave JVM\");", "-    final Process process = ExecJVM.runJVM(RUNNER, args, cp, jvmArgs, workDir);", "+    final String[] args = ", "+      new String[] { _masterStubFile.getAbsolutePath(), _slaveClassName };", "-    Thread restartThread = new Thread(_waitForQuitThreadName) {", "+    _monitorThread = new Thread(_waitForQuitThreadName) {", "-        _log.log(this + \"has started a Slave monitor thread waiting on process \" + process);", "-        try {", "+        try { /* Create the slave JVM. */ ", "+          ", "+          _log.log(AbstractMasterJVM.this + \" is STARTING a Slave JVM with args \" + Arrays.toString(args));", "+          ", "+          final Process process = ExecJVM.runJVM(RUNNER, args, cp, jvmArgs, workDir);", "+          _log.log(AbstractMasterJVM.this + \" CREATED Slave JVM process \" + process + \" with \" + asString());", "+          ", "-          _log.log(\"Process \" + process + \" died under control of \" + AbstractMasterJVM.this + \" with status \" + status);", "+          _log.log(process + \" DIED under control of \" + asString() + \" with status \" + status);", "-              /* If we get here, the process died without registering. (This might be the case if something was wrong", "-               * with the classpath, or if the new JVM couldn't acquire a port for debugging.)  Proper behavior in ", "-               * this case is unclear, so we'll let our subclasses decide.  By default, we print a stack trace and ", "-               * do not proceed, to avoid going into a loop. */", "+              /* If we get here, the process died without registering.  One possible cause is the intermittent funky 3 minute", "+               * pause in readObject in RUNNER.  Other possible causes are errors in the classpath or the absence of a ", "+               * debug port.  Proper behavior in this case is unclear, so we'll let our subclasses decide. */", "-            _slave = null;", "-            final boolean masterWithdrawn = UnicastRemoteObject.unexportObject(AbstractMasterJVM.this, true);", "-            final boolean loaderWithdrawn = UnicastRemoteObject.unexportObject(_classLoader, true);", "-            if (! masterWithdrawn || ! loaderWithdrawn) {", "-              _log.log(\"unexport step failed in \" + AbstractMasterJVM.this);", "-              throw new UnexpectedException(\"remote objects exported by Master JVM could not be withdrawn!\");", "+            if (_slave != null) { // Slave JVM quit spontaneously", "+              _slave = null; ", "-            ", "-            _log.log(AbstractMasterJVM.this + \" calling handleSlaveQuit(\" + status + \")\");", "-            handleSlaveQuit(status);", "+            _monitorThread = null;", "+            _masterJVMLock.notifyAll();  // signal that Slave JVM died to any thread waiting for _monitorThread == null", "+            ", "+//          _log.log(asString() + \" calling handleSlaveQuit(\" + status + \")\");", "+          handleSlaveQuit(status);", "+", "-        catch (NoSuchObjectException e) { throw new UnexpectedException(e); }", "-        catch (InterruptedException ie) { throw new UnexpectedException(ie); }", "+        catch(NoSuchObjectException e) { throw new UnexpectedException(e); }", "+        catch(InterruptedException e) { throw new UnexpectedException(e); }", "+        catch(IOException e) { throw new UnexpectedException(e); }", "+      private String asString() { return \"MonitorThread@\" + Integer.toHexString(hashCode()); }", "-    _log.log(this + \" is starting a slave monitor thread to detect when the Slave JVM dies\");", "-    restartThread.start();", "+//    _log.log(this + \" is starting a slave monitor thread to detect when the Slave JVM dies\");", "+    _monitorThread.start();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d41706c153c4efcdcf64563e54e64d84", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/InsertVariableDialog.java", "commitBeforeChange": "91d926f5e8557085503ecb402ffa610f4022f505", "commitAfterChange": "97f4d18b1b96ab5f6fef892b2420a830c7869018", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "   private void initComponents()", "signatureAfterChange": "   private void initComponents()", "diff": ["-    _varValueField.setEditable(false);", "-    ", "-    JPanel bottom = new JPanel(new BorderLayout());    ", "-    bottom.add(_varValueField, BorderLayout.CENTER);    ", "-    bottom.add(buttons, BorderLayout.SOUTH);", "+    for (Map.Entry<String, Properties> p: _props.entrySet()) {", "+      _tabbedPane.addTab(p.getKey(), createPane(p.getKey(), p.getValue()));", "+    }", "+    _tabbedPane.addChangeListener(new ChangeListener() {", "+      public void stateChanged(ChangeEvent e) {", "+        String panelName = _props.keySet().toArray(new String[0])[_tabbedPane.getSelectedIndex()];", "+        String key = _varTableModel.get(panelName).getValueAt(_varTable.get(panelName).getSelectedRow(),0).toString();", "+        _varValueField.setText(_props.get(panelName).getProperty(key));", "+        _selected = new edu.rice.cs.plt.tuple.Pair<String,String>(key, _props.get(panelName).getProperty(key));", "+      }", "+    });", "+", "+    JPanel bottom = new JPanel(new BorderLayout());", "+    bottom.add(_varValueField, BorderLayout.CENTER);    ", "+    bottom.add(buttons, BorderLayout.SOUTH);", "+    new JPanel(new BorderLayout());", "-        ", "-    _varTableModel = new DefaultTableModel(0,1) {", "+    ", "+    String panelName = _props.keySet().toArray(new String[0])[0];", "+    String key = _varTableModel.get(panelName).getValueAt(_varTable.get(panelName).getSelectedRow(),0).toString();", "+    _varValueField.setText(_props.get(panelName).getProperty(key));", "+    _selected = new edu.rice.cs.plt.tuple.Pair<String,String>(key, _props.get(panelName).getProperty(key));", "+    ", "+    main.add(_tabbedPane, BorderLayout.CENTER);", "+    ", "+    //The following line enables to use scrolling tabs.", "+    _tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);", "+", "+    // do not allow preview to have focus", "+    _tabbedPane.addFocusListener(new FocusAdapter() {", "+      public void focusLost(FocusEvent e) {", "+        if (e.getOppositeComponent() == _varValueField) {", "+          _tabbedPane.getSelectedComponent().requestFocus();", "+        }", "+      }", "+    });", "+", "+    super.getContentPane().add(main);", "+    super.setResizable(false);", "+    pack();", "+", "+    MainFrame.setPopupLoc(this, _mainFrame);    ", "+  }", "-    };", "-    _varTable = new JTable(_varTableModel);", "-    JScrollPane varTableSP = new JScrollPane(_varTable);", "-    _varTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);", "-    _varTable.putClientProperty(\"JTable.autoStartsEdit\", Boolean.FALSE);", "-    ListSelectionModel lsm = _varTable.getSelectionModel();", "-        String key = _varTableModel.getValueAt(_varTable.getSelectedRow(),0).toString();", "-        _selected = new edu.rice.cs.plt.tuple.Pair<String,String>(key, _props.getProperty(key));", "-        _varValueField.setText(_props.getProperty(key));", "-    _varTable.setSelectionModel(lsm);", "-    // do not allow preview to have focus", "-    _varTable.addFocusListener(new FocusAdapter() {", "-      public void focusLost(FocusEvent e) {", "-        if (e.getOppositeComponent() == _varValueField) {", "-          _varTable.requestFocus();", "-        }", "-      }", "-    });", "-", "-    for(Object o: _props.keySet()) {", "-      _varTableModel.addRow(row);", "-    _varTable.setRowSelectionInterval(0,0);", "-    String key = _varTableModel.getValueAt(_varTable.getSelectedRow(),0).toString();", "-    _varValueField.setText(_props.getProperty(key));", "-    _selected = new edu.rice.cs.plt.tuple.Pair<String,String>(key, _props.getProperty(key));", "-    main.add(varTableSP, BorderLayout.CENTER);", "-    ", "-    super.getContentPane().add(main);", "-    super.setResizable(false);", "-    pack();", "-", "-    MainFrame.setPopupLoc(this, _mainFrame);    "]}], "num": 19449}