{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7f93f03acfb3ac57b217acad102dfe3a", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "12280782140eac110a9cf2ff63375e5c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/newjvm/AbstractMasterJVM.java", "commitBeforeChange": "ab54ffeb9782712c65269bca65fea798aa2c5712", "commitAfterChange": "beead1fa2c7ee24ed59761a6b295b4aa1355139e", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 7, "signatureBeforeChange": "   protected final void invokeSlave(final String[] jvmArgs, final String cp, final File workDir) throws IOException,      RemoteException", "signatureAfterChange": "   protected final void invokeSlave(JVMBuilder jvmBuilder)", "diff": ["-    */", "-  protected final void invokeSlave(final String[] jvmArgs, final String cp, final File workDir) throws IOException, ", "-    RemoteException {", "+   */", "+  protected final void invokeSlave(JVMBuilder jvmBuilder) {", "+    if (isDisposed()) { throw new IllegalStateException(); }", "-    synchronized(_masterJVMLock) { // synchronization prelude only lets one thread at a time execute the sequel", "-      ", "-      try { while (_startupInProgress || _monitorThread != null) _masterJVMLock.wait(); }", "-      catch(InterruptedException e) { throw new UnexpectedException(e); }", "-      _startupInProgress = true;", "+    // verify that we're in the right state, and that only one thread will start at a time", "+    while (!_monitor.compareAndSet(State.FRESH, State.STARTING)) {", "+      debug.logValue(\"Waiting for FRESH state\", \"current state\", _monitor.value());", "+      try { _monitor.ensureState(State.FRESH); }", "+      catch (InterruptedException e) { throw new UnexpectedException(e); }", "+    debug.log(\"Entered STARTING state\");", "-    _log.log(this + \".invokeSlave(...) called\");", "-    ", "-    /******************************************************************************************************", "-      * First, we we export ourselves to a file, if it has not already been done on a previous invocation. *", "-      *****************************************************************************************************/", "-    ", "-    if (_masterStub == null) {", "-      try { _masterStub = (MasterRemote) UnicastRemoteObject.exportObject(this, 0); }", "-      catch (RemoteException re) {", "-        javax.swing.JOptionPane.showMessageDialog(null, edu.rice.cs.util.StringOps.getStackTrace(re));", "-        _log.log(this + \" threw \" + re);", "-        throw new UnexpectedException(re);  // should never happen", "-      }", "-      _log.log(this + \" EXPORTed Master JVM\");", "-      ", "-      _masterStubFile = File.createTempFile(\"DrJava-remote-stub\", \".tmp\");", "-      _masterStubFile.deleteOnExit();", "-      ", "-      // serialize stub to _masterStubFile", "-      FileOutputStream fstream = new FileOutputStream(_masterStubFile);", "-      ObjectOutputStream ostream = new ObjectOutputStream(fstream);", "-      ostream.writeObject(_masterStub);", "-      ostream.flush();", "-      fstream.close();", "-      ostream.close();", "+    // update jvmBuilder with any special properties", "+    Map<String, String> props = ConcurrentUtil.getPropertiesAsMap(\"plt.\", \"drjava.\", \"edu.rice.cs.\");", "+    props.put(\"java.rmi.server.hostname\", \"127.0.0.1\"); // Make sure RMI doesn't use an IP address that might change", "+    if (!props.containsKey(\"plt.log.working.dir\") && // Set plt.log.working.dir, in case the working dir changes", "+        (props.containsKey(\"plt.debug.log\") || props.containsKey(\"plt.error.log\") || ", "+            props.containsKey(\"plt.log.factory\"))) {", "+      props.put(\"plt.log.working.dir\", System.getProperty(\"user.dir\", \"\"));", "-    ", "-    final String[] args = new String[] { _masterStubFile.getAbsolutePath(), _slaveClassName };", "-    ", "-    LinkedList<String> fullJVMArgs = new LinkedList<String>(Arrays.asList(jvmArgs));", "-    Properties propagate = ConcurrentUtil.getProperties(\"plt.\", \"drjava.\", \"edu.rice.cs.\");", "-    if (!propagate.containsKey(\"plt.log.working.dir\") &&", "-        (propagate.containsKey(\"plt.debug.log\") || propagate.containsKey(\"plt.error.log\") || ", "-         propagate.containsKey(\"plt.log.factory\"))) {", "-      propagate.put(\"plt.log.working.dir\", System.getProperty(\"user.dir\", \"\"));", "-    }", "-    for (Map.Entry<Object, Object> entry : propagate.entrySet()) {", "-      fullJVMArgs.addFirst(\"-D\" + entry.getKey() + \"=\" + entry.getValue());", "-    }", "-    final String[] jvmArgsArray = fullJVMArgs.toArray(new String[0]);", "-    ", "-    // Start a thread to create the slave JVM and wait for it to die.  When it dies, delegate what to do (restart?) ", "-    // to subclass", "-    _monitorThread = new Thread(_waitForQuitThreadName) {", "-      public void run() {", "-        try { /* Create the slave JVM. */ ", "-          ", "-          debug.logValues(\"Starting slave JVM\",", "-                          new String[]{\"RUNNER\", \"args\", \"cp\", \"jvmArgsArray\", \"workDir\"},", "-                          RUNNER, args, cp, jvmArgsArray, workDir);", "-          _log.log(AbstractMasterJVM.this + \" is STARTING a Slave JVM with args \" + Arrays.asList(args));", "-          ", "-          final Process process = ExecJVM.runJVM(RUNNER, args, cp, jvmArgsArray, workDir);", "-          _log.log(AbstractMasterJVM.this + \" CREATED Slave JVM process \" + process + \" with \" + asString());", "-          ", "-          int status = process.waitFor();", "-//          System.err.println(process + \" DIED under control of \" + asString() + \" with status \" + status);", "-          synchronized(_masterJVMLock) {", "-            if (_startupInProgress) {", "-              error.log(\"Slave process died without registering\");", "-//              System.err.println(\"Process \" + process + \" died while starting up\");", "-              /* If we get here, the process died without registering.  One possible cause is the intermittent funky 3 minute", "-               * pause in readObject in RUNNER.  Other possible causes are errors in the classpath or the absence of a ", "-               * debug port.  Proper behavior in this case is unclear, so we'll let our subclasses decide. */", "-              slaveQuitDuringStartup(status);", "-            }", "-            if (_slave != null) { // Slave JVM quit spontaneously", "-              _slave = null; ", "-            }", "-            _monitorThread = null;", "-            _masterJVMLock.notifyAll();  // signal that Slave JVM died to any thread waiting for _monitorThread == null", "+    // include props, but shadow them with any definitions in jvmBuilder", "+    final JVMBuilder tweakedJVMBuilder = jvmBuilder.properties(CollectUtil.union(props, jvmBuilder.properties()));", "+", "+    SlaveRemote newSlave = null;", "+    try {", "+      debug.logStart(\"invoking remote JVM process\");", "+      newSlave =", "+        (SlaveRemote) ConcurrentUtil.exportInProcess(_slaveFactory, tweakedJVMBuilder, new Runnable1<Process>() {", "+          public void run(Process p) {", "+            debug.log(\"Remote JVM quit\");", "+            _monitor.set(State.FRESH);", "+            debug.logStart(\"handleSlaveQuit\");", "+            handleSlaveQuit(p.exitValue());", "+            debug.logEnd(\"handleSlaveQuit\");", "-          ", "-//          _log.log(asString() + \" calling handleSlaveQuit(\" + status + \")\");", "-          handleSlaveQuit(status);", "-        }", "-        catch(NoSuchObjectException e) { throw new UnexpectedException(e); }", "-        catch(InterruptedException e) { throw new UnexpectedException(e); }", "-        catch(IOException e) { throw new UnexpectedException(e); }", "+        });", "+      debug.logEnd(\"invoking remote JVM process\");", "+    }", "+    catch (Exception e) {", "+      debug.log(e);", "+      debug.logEnd(\"invoking remote JVM process (failed)\");", "+      _monitor.set(State.FRESH);", "+      handleSlaveWontStart(e);", "+    }", "+", "+    if (newSlave != null) {", "+      try { newSlave.start(_masterStub.value()); }", "+      catch (RemoteException e) {", "+        debug.log(e);", "+        attemptQuit(newSlave);", "+        _monitor.set(State.FRESH);", "+        handleSlaveWontStart(e);", "+        return;", "-      private String asString() { return \"MonitorThread@\" + Integer.toHexString(hashCode()); }", "-    };", "-//    _log.log(this + \" is starting a slave monitor thread to detect when the Slave JVM dies\");", "-    _monitorThread.start();", "+      ", "+      handleSlaveConnected(newSlave);", "+      _slave = newSlave;", "+      _monitor.set(State.RUNNING);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d61c50a84bbfc22ec53ba3ec1d3a949", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "72c953c3c4f509998630ec89f0f6ab473b5c78c1", "commitAfterChange": "b04c072cc6c2afa2120f5e98663d5a900c3a128f", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 61, "signatureBeforeChange": "   public boolean javadocAll(String destDir) throws IOException, InvalidPackageException", "signatureAfterChange": "   public void javadocAll(DirectorySelector select, final FileSaveSelector saver) throws IOException, InvalidPackageException", "diff": ["-  public boolean javadocAll(String destDir) throws IOException, InvalidPackageException {", "-    ", "-    // Notify all listeners that Javadoc is starting.", "-    this.javadocStarted();", "+  public void javadocAll(DirectorySelector select, final FileSaveSelector saver) throws IOException, InvalidPackageException {", "+    // Only javadoc if all are saved.", "+    saveAllBeforeProceeding(GlobalModelListener.JAVADOC_REASON);", "-      return false;", "+      return;", "+    // Make sure that there is at least one saved document.", "+    ListModel docs = _definitionsDocs;", "+    ", "+    boolean noneYet = true;", "+    int numDocs = docs.getSize();", "+    for (int i = 0; (noneYet && (i < numDocs)); i++) {", "+      OpenDefinitionsDocument doc = (OpenDefinitionsDocument) docs.getElementAt(i);", "+      noneYet = doc.isUntitled();", "+    }", "+    ", "+    // If there are no saved files, ignore the javadoc command.", "+    if (noneYet) {", "+      return;", "+    }", "+    ", "+    int returnVal;", "+    Configuration config = DrJava.getConfig();", "+    File destDir = config.getSetting(OptionConstants.JAVADOC_DESTINATION);", "+    boolean ask = config.getSetting(OptionConstants.JAVADOC_PROMPT_FOR_DESTINATION).booleanValue();", "+    ", "+    // Get the destination directory via the DirectorySelector, if appropriate.", "+    try {", "+      // If we no destination is set, or the user has asked for prompts,", "+      // ask the user for a destination directory.", "+      if (destDir.equals(FileOption.NULL_FILE) || ask) {", "+        if (!destDir.equals(FileOption.NULL_FILE)) {", "+          destDir = select.getDirectory(destDir);", "+        }", "+        else {", "+          destDir = select.getDirectory(null);", "+        }", "+      }", "+        ", "+      // Make sure the destination is writable.", "+      while (!destDir.exists() || !destDir.canWrite()) {", "+        // If the choice was rejected, tell the user and ask again.", "+        select.warnUser(\"The destination directory you have chosen\\n\"", "+                          + \"does not exist or is not readable. Please\\n\"", "+                          + \"choose another directory.\",", "+                        \"Bad Destination\");", "+        destDir = select.getDirectory(null);", "+      }", "+    }", "+    catch (OperationCanceledException oce) {", "+      // If the user cancels the dialog, silently return.", "+      return;", "+    }", "+    ", "+    // Start a new thread to do the work.", "+    final File destDirF = destDir;", "+    new Thread() {", "+      public void run() {", "+        _javadocWorker(destDirF, saver);", "+      }", "+    }.start();", "+  }", "-    HashSet docUnits = new HashSet();", "-    HashSet sourceRootSet = new HashSet();", "-    HashSet defaultRoots = new HashSet();", "-    HashSet topLevelPacks = new HashSet();", "-    boolean docAll = DrJava.getConfig().getSetting(JAVADOC_ALL_PACKAGES).booleanValue();", "-        // This call will abort the iteration if there is no file.", "-        File file = doc.getFile();", "-        if (pack.equals(\"\") && !defaultRoots.contains(sourceRoot)) {", "-          // This file uses the default package.", "-          // Look for other source files at the source root.", "-          // But don't do it if we've already done it for this directory.", "-          defaultRoots.add(sourceRoot);", "-          File[] javaFiles = sourceRoot.listFiles(FileOps.JAVA_FILE_FILTER);", "-", "-          for (int j = 0; j < javaFiles.length; j++) {", "-            docUnits.add(javaFiles[j].getAbsolutePath());", "-          String topLevelPack = pack;", "-          File searchRoot = new File(sourceRoot,", "-                                     topLevelPack.replace('.', File.separatorChar));", "-    if (docUnits.size() == 0) { ", "-      return false;", "-    args.add(\"-private\");", "-    boolean result;", "-      result = javadoc_1_3((String[]) args.toArray(new String[0]));", "-      this.javadocEnded();", "-    }", "-    return result;", "-  }"]}], "num": 30416}