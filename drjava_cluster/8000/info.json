{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e4b95b514a5dd6083ef8e71e0eafa8f4", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7e038f0fce6d6d3d0049f6d2eef31737", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "4b21424812450d42c0dde2aef3c483c11b298e24", "commitAfterChange": "ede26ceaad5c407d940ac773a5e7f457dc1f5187", "methodNumberBeforeChange": 53, "methodNumberAfterChange": 53, "signatureBeforeChange": "   public boolean isCastable(Type target, Type expT)", "signatureAfterChange": "   public boolean isDisjoint(final Type s, final Type t)", "diff": ["-  /** Determine if {@link #cast} would succeed given an expression of the given type */", "-  public boolean isCastable(Type target, Type expT) {", "-    try {", "-      Expression e = TypeUtil.makeEmptyExpression();", "-      NodeProperties.setType(e, expT);", "-      cast(target, e);", "-      return true;", "+  /** Whether two types are known to be disjoint.  (Standard version is implicitly defined in JLS 5.5.)  */", "+  public boolean isDisjoint(final Type s, final Type t) {", "+    // By default, returns null for arrays and classes", "+    abstract class Visitor extends TypeAbstractVisitor<Boolean> {", "+      private final Type _other;", "+      public Visitor(Type other) { _other = other; }", "+      public abstract boolean recur(Type that);", "+      @Override public Boolean forPrimitiveType(PrimitiveType that) {", "+        return !isSubtype(that, _other) && !isSubtype(_other, that);", "+      }", "+      @Override public Boolean forNullType(NullType that) {", "+        return !isSubtype(that, _other);", "+      }", "+      @Override public Boolean forArrayType(ArrayType that) { return null; }", "+      @Override public Boolean forClassType(ClassType that) { return null; }", "+      @Override public Boolean forIntersectionType(IntersectionType that) {", "+        for (Type elt : that.ofTypes()) { if (recur(elt)) return true; }", "+        return false;", "+      }", "+      @Override public Boolean forUnionType(UnionType that) {", "+        for (Type elt : that.ofTypes()) { if (!recur(elt)) return false; }", "+        return true;", "+      }", "+      @Override public Boolean forVariableType(VariableType that) {", "+        // TODO: to be correct, we would need to recur (checked by a RecursionStack)", "+        return false;", "+      }", "+      @Override public Boolean forTopType(TopType s) { return false; }", "+      @Override public Boolean forBottomType(BottomType s) { return true; }", "-    catch (UnsupportedConversionException e) { return false; }", "+    ", "+    Boolean sResult = s.apply(new Visitor(t) {", "+      public boolean recur(Type that) { return isDisjoint(that, t); }", "+    });", "+    if (sResult != null) { return sResult; }", "+    else {", "+      return t.apply(new Visitor(s) {", "+        public boolean recur(Type that) { return isDisjoint(s, that); }", "+        @Override public Boolean forArrayType(ArrayType t) {", "+          if (s instanceof ArrayType) { return isDisjoint(((ArrayType) s).ofType(), t.ofType()); }", "+          else { return !isSubtype(t, s); }", "+        }", "+        @Override public Boolean forClassType(ClassType t) {", "+          if (s instanceof ArrayType) { return !isSubtype(s, t); }", "+          else {", "+            ClassType sAsClass = (ClassType) s;", "+            if (sAsClass.ofClass().isFinal() || t.ofClass().isFinal() ||", "+                (!sAsClass.ofClass().isInterface() && !t.ofClass().isInterface())) {", "+              // either one of them is a final class or both are non-final classes", "+              if (!isSubtype(s, erase(t)) && !isSubtype(t, erase(s))) { return true; }", "+            }", "+            // TODO: The JLS also checks for disjoint type arguments (comparing *all* common superclasses)", "+            return false;", "+          }", "+        }", "+      });", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d52e7332081d56d09df2bec079ecb38a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "be902882edd6ee8f5b7260e86997569bf07255e2", "commitAfterChange": "ead43466202abb204c90f7ee2c316fec230d4415", "methodNumberBeforeChange": 161, "methodNumberAfterChange": 173, "signatureBeforeChange": "   public Pair<Expression, Expression> binaryPromote(final Expression e1, final Expression e2)      throws UnsupportedConversionException", "signatureAfterChange": "   public Pair<Expression, Expression> binaryPromote(final Expression e1, final Expression e2)      throws UnsupportedConversionException", "diff": ["-    Pair<Expression, Expression> result =", "-      join(t1, t2).apply(new TypeAbstractVisitor<Pair<Expression, Expression>>() {", "-      public Pair<Expression, Expression> defaultCase(Type commonT) {", "-        if (!(t1 instanceof NumericType) || !(t2 instanceof NumericType)) {", "-          return null;", "-        }", "-        else { throw new IllegalArgumentException(\"Unexpected join result\"); }", "+    final Type t1Promoted = t1.apply(new TypeAbstractVisitor<Type>() {", "+      @Override public Type defaultCase(Type t) { return null; }", "+      @Override public Type forNumericType(NumericType t) { return INT; }", "+      @Override public Type forFloatingPointType(FloatingPointType t) { return t; }", "+      @Override public Type forLongType(LongType t) { return t; }", "+    });", "+    if (t1Promoted == null) { throw new UnsupportedConversionException(); }", "+    final Type promoted = t2.apply(new TypeAbstractVisitor<Type>() {", "+      @Override public Type defaultCase(Type t) { return null; }", "+      @Override public Type forNumericType(NumericType t) { return t1Promoted; }", "+      @Override public Type forDoubleType(DoubleType t) { return t; }", "+      @Override public Type forFloatType(FloatType t) {", "+        return (t1Promoted instanceof DoubleType) ? t1Promoted : t;", "-      ", "-      @Override public Pair<Expression, Expression> forDoubleType(DoubleType commonT) {", "-        return Pair.make(t1 instanceof DoubleType ? e1 :makeCast(DOUBLE, e1),", "-                         t2 instanceof DoubleType ? e2 : makeCast(DOUBLE, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forFloatType(FloatType commonT) {", "-        return Pair.make(t1 instanceof FloatType ? e1 : makeCast(FLOAT, e1),", "-                         t2 instanceof FloatType ? e2 : makeCast(FLOAT, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forLongType(LongType commonT) {", "-        return Pair.make(t1 instanceof LongType ? e1 : makeCast(LONG, e1),", "-                         t2 instanceof LongType ? e2 : makeCast(LONG, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forIntType(IntType commonT) {", "-        return Pair.make(t1 instanceof IntType ? e1 : makeCast(INT, e1),", "-                         t2 instanceof IntType ? e2 : makeCast(INT, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forShortType(ShortType commonT) {", "-        return Pair.make(makeCast(INT, e1), makeCast(INT, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forByteType(ByteType commonT) {", "-        return Pair.make(makeCast(INT, e1), makeCast(INT, e2));", "-      }", "-      ", "-      @Override public Pair<Expression, Expression> forCharType(CharType commonT) {", "-        return Pair.make(makeCast(INT, e1), makeCast(INT, e2));", "+      @Override public Type forLongType(LongType t) {", "+        return (t1Promoted instanceof FloatingPointType) ? t1Promoted : t;", "-    if (result == null) { throw new UnsupportedConversionException(); }", "-    else { return result; }", "+    if (promoted == null) { throw new UnsupportedConversionException(); }", "+    ", "+    return Pair.make(t1.equals(promoted) ? e1 : makeCast(promoted, e1),", "+                     t2.equals(promoted) ? e2 : makeCast(promoted, e2));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ec4aef97379f58c4197509d4b2bb4661", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 338, "methodNumberAfterChange": 264, "signatureBeforeChange": "              @Override public Iterable<ObjectFieldReference> forParameterizedClassType(ParameterizedClassType t)", "signatureAfterChange": "           private PredicateSet<T> find(final Type t, final boolean findAll)", "diff": ["+    ", "+    private PredicateSet<T> find(final Type t, final boolean findAll) {", "+      debug.logStart(\"t\", wrap(t)); try {", "+        ", "+      final PredicateSet<T> childMatches = CollectUtil.asPredicateSet(declaredMatches(t));", "+      if (!findAll && !IterUtil.isEmpty(childMatches)) {", "+        // take snapshot of lazily-constructed set", "+        return CollectUtil.makeSet(childMatches);", "+      }", "+      else {", "+        PredicateSet<T> fromSupers = t.apply(new TypeAbstractVisitor<PredicateSet<T>>() {", "+          ", "+          public PredicateSet<T> defaultCase(Type t) { return CollectUtil.emptySet(); }", "+          ", "+          @Override public PredicateSet<T> forArrayType(ArrayType t) {", "+            return find(CLONEABLE_AND_SERIALIZABLE, findAll);", "+          }", "+          ", "+          @Override public PredicateSet<T> forClassType(ClassType t) {", "+            Type superT = immediateSupertype(t);", "+            if (superT == null) { return CollectUtil.emptySet(); }", "+            else { return find(superT, findAll); }", "+          }", "+          ", "+          @Override public PredicateSet<T> forVariableType(VariableType t) {", "+            return find(t.symbol().upperBound(), findAll);", "+          }", "+          ", "+          @Override public PredicateSet<T> forIntersectionType(IntersectionType t) {", "+            PredicateSet<T> result = CollectUtil.emptySet();", "+            for (Type tSup : t.ofTypes()) {", "+              PredicateSet<T> forSup = find(tSup, findAll);", "+              result = CollectUtil.union(result, forSup);", "+            }", "+            return result;", "+          }", "+          ", "+          @Override public PredicateSet<T> forUnionType(UnionType t) {", "+            Iterable<? extends Type> sups = t.ofTypes();", "+            if (IterUtil.isEmpty(sups)) { return CollectUtil.emptySet(); }", "+            else {", "+              PredicateSet<T> result = find(IterUtil.first(sups), findAll);", "+              for (Type tSup : IterUtil.skipFirst(sups)) {", "+                PredicateSet<T> forSup = find(tSup, findAll);", "+                result = CollectUtil.intersection(result, forSup);", "+                // don't short-circuit when empty, because the empty test is expensive", "+              }", "+              return result;", "+            }", "+          }", "+          ", "+        });", "+        PredicateSet<T> result = CollectUtil.union(childMatches, CollectUtil.filter(fromSupers, new Predicate<T>() {", "+          public boolean contains(T match) { return inherits(t, childMatches, match); }", "+        }));", "+        // take snapshot of lazily-constructed sets", "+        return CollectUtil.makeSet(result);", "+      }", "+      ", "+      } finally { debug.logEnd(); }", "+    }", "-      ", "-      @Override public Iterable<ObjectFieldReference> forParameterizedClassType(ParameterizedClassType t) {", "-        for (DJField f : t.ofClass().declaredFields()) {", "-          if (f.declaredName().equals(name) && validField(f)) {", "-            Type fieldType = substitute(f.type(), SymbolUtil.allTypeParameters(t.ofClass()), ", "-                                        t.typeArguments());", "-            return IterUtil.make(new ObjectFieldReference(f, fieldType, makeCast(t, object)));", "-          }", "-        }", "-        return IterUtil.empty();", "-      }"]}], "num": 8000}