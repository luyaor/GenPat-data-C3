{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "37d9af256c012b3c8f25d74eda1409e2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2712f4e73ec7ba9ab63ddca7f11faf11", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractGlobalModel.java", "commitBeforeChange": "b555b0cfcc7bbb9f082899ce815305f8a985343e", "commitAfterChange": "aafaf7b848d738e58eee48a6cbc4b800c8027685", "methodNumberBeforeChange": 230, "methodNumberAfterChange": 232, "signatureBeforeChange": "     private File _locateClassFile()", "signatureAfterChange": "     private File _locateClassFile()", "diff": ["-      try {", "-        String className = getDocument().getQualifiedClassName();", "-        String ps = System.getProperty(\"file.separator\");", "-        // replace periods with the System's file separator", "-        className = StringOps.replace(className, \".\", ps);", "-        String filename = className + \".class\";", "-", "-        // Check source root set (open files)", "-        File[] sourceRoots = { };", "-        Vector<File> roots = new Vector<File>();", "-        ", "-        if (getBuildDirectory() != null) roots.add(getBuildDirectory());", "-        ", "-        // Add the current document to the beginning of the roots list", "-        try { roots.add(getSourceRoot()); }", "-        catch (InvalidPackageException ipe) {", "-          try {", "-            File f = getFile().getParentFile();", "-            if (f != null) roots.add(f);", "-          }", "-          catch (IllegalStateException ise) { /* No file; do nothing */ }", "-          catch (FileMovedException fme) {", "-            // Moved, but we'll add the old file to the set anyway", "-            File root = fme.getFile().getParentFile();", "-            if (root != null)  roots.add(root);", "-          }", "+      if (isUntitled()) return null;", "+      ", "+      String className;", "+      try { className = getDocument().getQualifiedClassName(); }", "+      catch (ClassNameNotFoundException cnnfe) { return null;  /* No source class name */ }", "+      ", "+      String ps = System.getProperty(\"file.separator\");", "+      // replace periods with the System's file separator", "+      className = StringOps.replace(className, \".\", ps);", "+      String fileName = className + \".class\";", "+      ", "+      // Check source root set (open files)", "+      ArrayList<File> roots = new ArrayList<File>();", "+      ", "+      if (getBuildDirectory() != null) roots.add(getBuildDirectory());", "+      ", "+      // Add the current document to the beginning of the roots list", "+      try { roots.add(getSourceRoot()); }", "+      catch (InvalidPackageException ipe) {", "+        try {", "+          File root = getFile().getParentFile();", "+          if (root != null) roots.add(root);", "-", "-        for (int i = 0; i < sourceRoots.length; i++) roots.add(sourceRoots[i]);", "-        ", "-        File classFile = getSourceFileFromPaths(filename, roots);", "-", "-        if (classFile == null) {", "-          // Class not on source root set, check system classpath", "-          String cp = System.getProperty(\"java.class.path\");", "-          String pathSeparator = System.getProperty(\"path.separator\");", "-          Vector<File> cpVector = new Vector<File>();", "-          for (int i = 0; i < cp.length();) {", "-            int nextSeparator = cp.indexOf(pathSeparator, i);", "-            if (nextSeparator == -1) {", "-              cpVector.add(new File(cp.substring(i, cp.length())));", "-              break;", "-            }", "-            cpVector.add(new File(cp.substring(i, nextSeparator)));", "-            i = nextSeparator + 1;", "-          }", "-          classFile = getSourceFileFromPaths(filename, cpVector);", "+        catch(NullPointerException e) { throw new UnexpectedException(e); }", "+        catch(FileMovedException fme) {", "+          // Moved, but we'll add the old file to the set anyway", "+          File root = fme.getFile().getParentFile();", "+          if (root != null) roots.add(root);", "-        if (classFile == null) {", "-          // not on system classpath, check interactions classpath", "-          classFile = getSourceFileFromPaths(filename, DrJava.getConfig().getSetting(EXTRA_CLASSPATH));", "-        }", "-        return classFile;", "-      catch (ClassNameNotFoundException cnnfe) {", "-        // No class name found, so we can't find a class file", "-        return null;", "+      ", "+      File classFile = getSourceFileFromPaths(fileName, roots);", "+      if (classFile != null) return classFile;", "+      ", "+      // Class not on source root set, check system classpath", "+      String cp = System.getProperty(\"java.class.path\");", "+      String pathSeparator = System.getProperty(\"path.separator\");", "+      Vector<File> cpVector = new Vector<File>();", "+      int i = 0;", "+      while (i < cp.length()) {", "+        int nextSeparator = cp.indexOf(pathSeparator, i);", "+        if (nextSeparator == -1) {", "+          cpVector.add(new File(cp.substring(i, cp.length())));", "+          break;", "+        }", "+        cpVector.add(new File(cp.substring(i, nextSeparator)));", "+        i = nextSeparator + 1;", "+      classFile = getSourceFileFromPaths(fileName, cpVector);", "+      ", "+      if (classFile != null) return classFile;", "+      ", "+      // not on system classpath, check interactions classpath", "+      return getSourceFileFromPaths(fileName, DrJava.getConfig().getSetting(EXTRA_CLASSPATH));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93fa3aa2a6feef9943ddab5f2edd18ac", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "3e22080f0d9650b7b802f9b713065e47d1a0ce19", "commitAfterChange": "1bbb44dda9ccbed1420a315a25ace5ab1cf20f80", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": "   protected SymbolData getSymbolData(String className, SourceInfo si, boolean resolve, boolean fromClassFile,                                       boolean addError, boolean checkImportedStuff)", "signatureAfterChange": "   protected SymbolData getSymbolData(String className, SourceInfo si, boolean resolve, boolean fromClassFile,                                       boolean addError, boolean checkImportedStuff)", "diff": ["-    ", "-//    if (className.equals(\"Constant\")) throw new RuntimeException(\"getSymbol called on Constant\");", "-    ", "-//    if (className.equals(\"Object\")) ", "-//      System.err.println(\"getSymbolData(\" + className + \", \" + si + \", \" + resolve + \", \" + fromClassFile + \", \" + addError +", "-//             \", \" + checkImportedStuff);", "-    ", "-    int indexOfNextDot = className.indexOf(\".\");", "-    /* we don't think this is necessay, but as a safety percausion, check the $ that denotes anonymous inner classes ", "-     * and inner classes. */", "-    int indexOfNextDollar = className.indexOf(\"$\");  ", "-    if (indexOfNextDot == -1 && indexOfNextDollar == -1) {", "-      return getSymbolDataHelper(className, si, resolve, fromClassFile, addError, checkImportedStuff);", "+ ", "+    if (className.endsWith(\"[]\")) { // className refers to an array type", "+      SymbolData sd = ", "+        getSymbolData(className.substring(0, className.length() - 2), si, resolve, fromClassFile, addError, ", "+                      checkImportedStuff);", "+      if (sd == null) return null; // Should not happen", "+      ArrayData ad = new ArrayData(sd, this, si);", "+      symbolTable.put(ad.getName(), ad);", "+      return ad;", "-    else { indexOfNextDot = 0; }  // ABOMINABLE CODING", "-    SymbolData whatever;", "+    ", "+    // First, handle classNames that clearly do NOT refer to inner classes", "+    int indexOfNextDot = className.indexOf(\".\");", "+    int indexOfNextDollar = className.indexOf(\"$\");   // '$' is assumed not to appear in source program type names", "+    if (indexOfNextDot == -1 && indexOfNextDollar == -1)", "+      return getSymbolDataHelper(className, si, resolve, fromClassFile, addError, checkImportedStuff);", "+    ", "+    // Try to decompose className into an inner class reference, but name may simply be fully qualified", "+    indexOfNextDot = 0;   ", "+    SymbolData sd;", "-      String s = className.substring(0, indexOfNextDot);", "+      String prefix = className.substring(0, indexOfNextDot);", "-      boolean newResolve = resolve || (indexOfNextDot != length);", "-      whatever = getSymbolDataHelper(s, si, newResolve, fromClassFile, false, checkImportedStuff);", "-//      if (s.equals(\"fully.qualified.Woah\")) throw new RuntimeException(s + \" passed to helper and newResolve = \" + resolve );", "-      if (whatever != null) {", "+//      boolean newResolve = resolve || (indexOfNextDot != length);", "+      sd = getSymbolDataHelper(prefix, si, resolve, fromClassFile, false, checkImportedStuff);", "+//      if (prefix.equals(\"fully.qualified.Woah\")) throw new RuntimeException(prefix + \" passed to helper and newResolve = \" + resolve );", "+      if (sd != null) { // prefix matches an extant symbol", "+        String outerClassName = prefix;", "-        SymbolData outerClass = whatever;", "-        if (whatever != null && indexOfNextDot != length) {", "-          outerClass = whatever;", "+        if (indexOfNextDot != length) {", "+          SymbolData outerClassSD = sd;", "-          whatever = outerClass.getInnerClassOrInterface(innerClassName);", "+//          System.err.println(\"Outer class prefix found: \" + prefix + \" inner class extension: \" + innerClassName);", "+          sd = outerClassSD.getInnerClassOrInterface(innerClassName);", "+//          System.err.println(\"Corresponding symbol = \" + sd);", "+          if (sd == null) { // create continuation for inner class; we are forbidding some ambiguities Java may permit", "+            sd = addInnerSymbolData(si, outerClassName + \".\" + innerClassName, outerClassSD);", "+          }", "+          return sd;", "-        if (whatever == SymbolData.AMBIGUOUS_REFERENCE) {", "+        else if (sd == SymbolData.AMBIGUOUS_REFERENCE) {", "-        if (whatever != null && whatever != SymbolData.NOT_FOUND) { return whatever; }", "-        else { ", "-          //perhaps this was an array type--try to resolve it without the [], and then put it in the symbol table", "-          if (className.endsWith(\"[]\")) { ", "-            SymbolData sd = ", "-              getSymbolData(className.substring(0, className.length() - 2), si, resolve, fromClassFile, addError, ", "-                            checkImportedStuff);", "-            if (sd != null) {", "-              ArrayData ad = new ArrayData(sd, this, si);", "-              symbolTable.put(ad.getName(), ad);", "-              return ad;", "-            }", "-            return sd;", "-          }", "-        }", "+        else if (sd != null && sd != SymbolData.NOT_FOUND) { return sd; }", "+      // sd may be null or an error element of SymbolData", "+    ", "+    // No match was found", "+//      throw new RuntimeException(\"Invalid class name \" + newName + \" encountered in file \" + _file);"]}], "num": 8585}