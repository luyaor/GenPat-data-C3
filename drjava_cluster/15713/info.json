{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "63f489846560cfb1d69ba8204eef48f5", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "927bef4b510fa9b8c8d0c30c4413ec55", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 11, "signatureBeforeChange": "   protected SymbolData getSymbolDataHelper(String className, SourceInfo si, boolean resolve, boolean fromClassFile,                                             boolean addError, boolean checkImportedStuff)", "signatureAfterChange": "    private SymbolData getArraySymbolData(String eltClassName, SourceInfo si, boolean addError, boolean checkImports)", "diff": ["+  /* Convenience method used in testing. */ ", "+  private SymbolData getArraySymbolData(String eltClassName, SourceInfo si, boolean addError, boolean checkImports) {", "+    return _getArraySymbolData(eltClassName, si, addError, checkImports /*, _classesInThisFile*/);", "+  }", "-  protected SymbolData getSymbolDataHelper(String className, SourceInfo si, boolean resolve, boolean fromClassFile, ", "-                                           boolean addError, boolean checkImportedStuff) {", "-    // Check for primitive types.    ", "-    SymbolData sd = _getSymbolData_Primitive(className);", "-    if (sd != null) { return sd; }", "-    ", "-    // Check for array types.", "-    if (className.endsWith(\"[]\")) {", "-      return _getArraySymbolData(className, si, resolve, fromClassFile, addError, checkImportedStuff);", "-    }", "-    ", "-    // Check for qualified types. (FAILS for inner classes).  This invocation may be the result of a recursive call.", "-    if (className.indexOf(\".\") != -1) return _getQualifiedSymbolData(className, si, resolve, fromClassFile, addError);", "-    ", "-    String name = null; // name of the SymbolData to be returned", "-    String qualifiedClassName = getQualifiedClassName(className);  // Fails for inner class references", "-//    if (className.equals(\"MyInnerClass\")) ", "-//      System.err.println(\"QualifiedClassName for MyInnerClass = \" + qualifiedClassName);", "-//    System.err.println(\"qualifiedClassName for \" + className + \" is \" + qualifiedClassName);", "-    // Check if className is defined in this file.", "-    if (_classNamesInThisFile.contains(qualifiedClassName)) {", "-      return _getSymbolData_FromCurrFile(qualifiedClassName, si, resolve);", "-    }", "-   ", "-    // Check if className was specifically imported -- Not done at elementary level.", "-    // At this point, we know that class name is not qualified.", "-    // We will not check that the package is correct here, because it is caught in the type checker.", "-    Iterator<String> iter = _importedFiles.iterator();", "-    if (checkImportedStuff) {", "-      while (iter.hasNext()) {", "-        String s = iter.next();", "-        if (s.endsWith(className)) {", "-          // All imported files should be in the symbol table.", "-          SymbolData tempSd = symbolTable.get(s);", "-          // Only need to fully resolve if resolve is on and the imported file is a continuation.", "-//          if (tempSd == null) System.err.println(\"Symbol lookup failed for \" + s);", "-          if (resolve && tempSd != null && tempSd.isContinuation()) {", "-//            if (className.equals(\"Woah\")) System.err.println(\"Calling getSymbolData for Woah\");", "-            return getSymbolData(s, si, resolve, fromClassFile, addError, false);  // POTENTIAL INFINITE RECURSION!", "-          }", "-          else return tempSd;", "-        }", "-      }", "-    }", "-    ", "-    // Check if the qualified class name is already in the symbol table at this package level.", "-    // Skip checking if this class is in the package if it's qualified and not qualified with this", "-    // package.", "-    if (className.indexOf(\".\") == -1 || (!_package.equals(\"\") && className.startsWith(_package))) {", "-      sd = symbolTable.get(qualifiedClassName);", "-//      if (className.equals(\"Woah\")) ", "-//        System.err.println(\"Potentially calling getSymbolData_FromFileSystem for Woah; sd = \" + sd);", "-      if (sd == null || (sd.isContinuation() && resolve)) {", "-        sd = _getSymbolData_FromFileSystem(qualifiedClassName, si, resolve, addError);", "-//        if (className.equals(\"Woah\")) ", "-//          System.err.println(\"getSymbolData_FromFileSystem for Woah returned = \" + sd);", "-        if (sd != null && sd != SymbolData.NOT_FOUND) return sd;", "-      }      ", "-      else {", "-        // Either we're in the default package and we found the unqualified name or we found a continuation and don't", "-        // need to resolve it.", "-        return sd;", "-      }", "-    SymbolData resultSd = null;", "-    // Check if the className's package was imported.", "-    if (checkImportedStuff) {", "-//      if (className.equals(\"Object\")) System.err.println(\"Checking import packages for Object\");", "-      iter = _importedPackages.iterator();", "-      while (iter.hasNext()) {", "-        String s = iter.next() + \".\" + className;", "-//        if (className.equals(\"Object\")) System.err.println(\"Looking up: \" + s);", "-        SymbolData tempSd;", "-        tempSd = getSymbolDataHelper(s, si, resolve, fromClassFile, false, false);", "-//        if (className.equals(\"Object\")) ", "-//          System.err.println(\"matching sd is: \" + tempSd + \"\\nsymbolTable.get(\\\"\" + s + \"\\\") = \"+ symbolTable.get(s));", "-        if (tempSd != null) {", "-          if (resultSd == null) resultSd = tempSd;", "-          else {  // tempSd is NOT the first match; flag an error", "-            if (addError) {", "-              _addAndIgnoreError(\"The class name \" + className + \" is ambiguous.  It could be \" + resultSd.getName() + ", "-                                 \" or \" + tempSd.getName(), new NullLiteral(si));", "-              return null;", "-            }", "-          }", "-        }", "-    return resultSd;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b7eb68d0f099e4dc7a35d29fded86889", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "    private SymbolData _getQualifiedSymbolData(String className, SourceInfo si, boolean resolve, boolean fromClassFile,                                               boolean addError)", "signatureAfterChange": "   protected SymbolData getQualifiedSymbolData(String qualClassName, SourceInfo si, boolean resolve, boolean fromClassFile,                                             boolean addError)", "diff": ["-    */ ", "-  private SymbolData _getQualifiedSymbolData(String className, SourceInfo si, boolean resolve, boolean fromClassFile, ", "-                                             boolean addError) {", "-    _log.log(\"_getQualifiedSymbolData called on '\" + className + \"'\");", "-   ", "-    // We assume a period in a class name means it is qualified, make sure it's either in", "-    // this package, is imported specifically, is in an imported package, or is in java.lang.", "-    // We can't directly check it, because parsing class files adds every class that is recursively", "-    // referenced by that class file, and we shouldn't be allowed to see some of them.", "-    SymbolData sd = symbolTable.get(className);", "-//    if (className.equals(\"fully.qualified.Woah\")) System.err.println(\"_getQualifiedSymbolData(\" + className + \", ...) called\" +", "-//                                                                    \"\\nsd = \" + sd);", "-    /* If sd is not null then return it unless it is a continuation that we are resolving.", "-     * If we're from a class file, then a continuation is ok because we assume", "-     * that we'll find it later. (?)  If you don't return here, you can get into", "-     * an infinite loop if there's a self-referencing class.", "-     */", "-    _log.log(\"Corresponding symbolTable entry = \" + sd);", "-    if (sd != null && (! resolve || ! sd.isContinuation() || fromClassFile)) { ", "-      _log.log(\"Returning \" + sd);", "-      return sd; ", "-    }", "-    ", "-    // Look it up in the symbol table, see if it's a Java library class, look it up from the filesystem.", "-    if (isJavaLibraryClass(className)) {", "-      _log.log(\"Calling  _classFile2SymbolData\");", "-      return _classFile2SymbolData(className, null);", "-    }", "-    else if (resolve) {  // Look for class file if resolving a continuation", "-      SymbolData newSd = _getSymbolData_FromFileSystem(className, si, resolve, addError);", "-      if (newSd != SymbolData.NOT_FOUND) {", "-        _log.log(\"Returning \" + sd + \" from file system\");", "-        return newSd;", "-      }", "-      else if (sd != null && sd.isContinuation()) return sd;", "-      if (addError) {", "-        _addAndIgnoreError(\"The class \" + className + \" was not found.\", new NullLiteral(si));", "-      }", "-    }", "-    _log.log(\"Returning null\");", "-    return null;", "-  }", "+  protected SymbolData getQualifiedSymbolData(String qualClassName, SourceInfo si, boolean resolve, boolean fromClassFile, ", "+                                           boolean addError) {", "+    assert qualClassName != null;", "+//    if (qualClassName.startsWith(\"RefInnerClassCrazy\")) ", "+//      System.err.println(\"ALARM: getQualifiedSymbolData called for '\" + qualClassName + \"'\");", "+//    ", "+    if (qualClassName.equals(\"java.lang.Throwable\")) {", "+      System.err.println(\"***ALARM: getQualifiedSymbolData called for '\" + qualClassName + \"'\");", "+      if (symbolTable.get(qualClassName) != null) System.err.println(\"***ALARM: java.lang.Throwable already exists\");", "+    assert (qualClassName != null && ! qualClassName.equals(\"\"));", "+    ", "+    // Check for primitive types.", "+    SymbolData sd = LanguageLevelConverter._getPrimitiveSymbolData(qualClassName);", "+    if (sd != null) { return sd; }", "+    ", "+    // Check for already defined types", "+    SymbolData existingSD = symbolTable.get(qualClassName);", "+    if (existingSD != null && (! resolve || ! existingSD.isContinuation())) return existingSD;", "+    ", "+    // Check for array types.", "+    if (qualClassName.endsWith(\"[]\"))", "+      return _getQualifiedArraySymbolData(qualClassName.substring(0, qualClassName.length() - 2), si, resolve, ", "+                                       fromClassFile);", "+    // If qualClassName is a library file, resolve it immediately by reading its class file.", "+    if (isJavaLibraryClass(qualClassName)) {", "+      _log.log(\"Calling  _classFile2SymbolData\");", "+      SymbolData cfSD = LanguageLevelConverter._classFile2SymbolData(qualClassName, null);", "+      if (! qualClassName.startsWith(\"java.\") && ! qualClassName.startsWith(\"sun.\"))", "+        System.err.println(\"Defining class file symbol \" + qualClassName);", "+      assert cfSD == null || symbolTable.contains(cfSD);", "+      return cfSD;", "+    }", "+    ", "+    if (_classesInThisFile.contains(qualClassName))  // Make continuation for top level class not yet parsed in this file", "+      return makeContinuation(si, qualClassName);", "+    ", "+    // If performing post-visit resolution, read the signature info for this symbol from a class file", "+    if (resolve) {  // Look for up-to-date class file", "+      SymbolData newSd = _getSymbolDataFromFileSystem(qualClassName, si, true, true);  // resolve, addError = true", "+      if (newSd != null && newSd != SymbolData.NOT_FOUND) {", "+        _log.log(\"Returning \" + sd + \" from file system\");", "+        return newSd;", "+      }", "+      else {", "+        System.err.println(\"***ALARM*** The class \" + qualClassName + \" was not found.\");", "+        _addAndIgnoreError(\"The class \" + qualClassName + \" was not found.\", new NullLiteral(si));", "+        assert false;", "+    return null;    // qualClassName not found"]}], "num": 15713}