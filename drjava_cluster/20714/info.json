{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a421a84eacd27ecf71a64be07232d590", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3daba28aefa9ada4702c3a3a1a88a6e3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/EvaluationVisitor.java", "commitBeforeChange": "c34979036dca11c3afc06b42fcb087eaf85bc790", "commitAfterChange": "65d5646e82c85892c2ff64d6a2d537b4dc36c473", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 76, "signatureBeforeChange": "   public Object visit(FunctionCall node)", "signatureAfterChange": "   public Object visit(FunctionCall node)", "diff": ["+    List<Expression> larg = node.getArguments();", "+    ", "+    //If the invoked method is a varargs method the parameters must be packaged in an array", "+    if(md.isVarArgs())", "+    {", "+      if(larg == null) //A varargs function was called with no parameters", "+      {", "+        ArrayInitializer array = new ArrayInitializer(new LinkedList<Expression>());", "+        List<Expression> le = new LinkedList<Expression>();", "+        List<FormalParameter> lfp = md.getParameters();", "+        Iterator<FormalParameter> itfp = lfp.iterator();", "+        if(!itfp.hasNext())", "+          throw new IllegalStateException(\"Variable Arguments function does not have a formal parameter list\");", "+        array.setElementType(itfp.next().getType());", "+        ", "+        le.add(array);", "+        node.setArguments(le);", "+      }", "+      else //A varargs function was called with parameters", "+      {", "+        Iterator<FormalParameter> params = md.getParameters().iterator();", "+        Iterator<Expression> args = larg.iterator();", "+        LinkedList<Expression> le = new LinkedList<Expression>();", "+        FormalParameter fp = null;", "+        while(params.hasNext())", "+        {", "+         fp = params.next();", "+         if(params.hasNext())", "+           le.add(args.next());", "+        }", "+        ", "+        LinkedList<Expression> cells = new LinkedList<Expression>();", "+        while(args.hasNext())", "+        {", "+          cells.add(args.next());", "+        }", "+        ", "+        ArrayInitializer array = new ArrayInitializer(cells);", "+        koala.dynamicjava.tree.Type t = fp.getType();", "+        if(!(t instanceof ArrayType))", "+          throw new IllegalStateException(\"Varargs method does not have an array type for its final parameter\");", "+        array.setElementType(((ArrayType)t).getElementType());", "+        le.add(array);", "+        node.setArguments(le);", "+      } ", "+    }", "+", "-", "+    ", "+    List<FormalParameter> params = md.getParameters();", "+    Iterator<FormalParameter> itParam = params.iterator();", "+    Class<?>[] typs = new Class<?>[params.size()];", "+    ", "+    //Get the types of parameters that this function accepts", "+    int i = 0;", "+    while(itParam.hasNext()){", "+      typs[i++] = (Class<?>)itParam.next().getProperty(NodeProperties.TYPE);", "+    }", "+    ", "+      "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f56b6731a0c038cc6e66092a82753708", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/context/GlobalContext.java", "commitBeforeChange": "c34979036dca11c3afc06b42fcb087eaf85bc790", "commitAfterChange": "65d5646e82c85892c2ff64d6a2d537b4dc36c473", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 43, "signatureBeforeChange": "   public MethodDeclaration lookupFunction(String mname, Class<?>[] params)     throws NoSuchFunctionException", "signatureAfterChange": "   public MethodDeclaration lookupFunction(String mname, Class<?>[] params)     throws NoSuchFunctionException", "diff": ["-", "+    List<MethodDeclaration> compatible = new LinkedList<MethodDeclaration>();", "+    ", "+    //Do a first pass to find basic methods that match the parameters", "-        continue;", "+        //continue;", "-      if (ReflectionUtilities.hasCompatibleSignatures(p, params)) {", "-        return md;", "+      if(ReflectionUtilities.hasCompatibleSignatures(p, params)) {", "+        compatible.add(md);", "-       ", "-    throw new NoSuchFunctionException(mname);", "+    if(!compatible.isEmpty())", "+    {", "+      return ReflectionUtilities.selectTheMostSpecificFunction(compatible);", "+    }", "+    ", "+    //Do a second pass to find methods that match using autoboxing", "+    ", "+    it = f.iterator();", "+    ", "+    while(it.hasNext()) {", "+      MethodDeclaration md = it.next();", "+      List<FormalParameter> l = md.getParameters();", "+      ", "+      //With autoboxing the arguments must still be the same length", "+      if(l.size() != params.length)", "+        continue;", "+      ", "+      Class<?>[] p = new Class<?>[l.size()];", "+      Iterator<FormalParameter> it2 = l.iterator();", "+      int i = 0;", "+      while(it2.hasNext()) {", "+        p[i++] = NodeProperties.getType(it2.next());", "+      }", "+      ", "+      ReflectionUtilities.TigerUsage tu = new ReflectionUtilities.TigerUsage();", "+     ", "+      if(ReflectionUtilities.hasAutoBoxingCompatibleSignatures(p, params, tu)) {", "+        compatible.add(md);", "+        //throw new RuntimeException(\"Found a function that matches using Autoboxing!\");", "+      }", "+    }", "+    ", "+    //Select the most specific function using autoboxing", "+    if (!compatible.isEmpty()) {", "+      return ReflectionUtilities.selectTheMostSpecificBoxingFunction(compatible);", "+    }", "+    ", "+    //Do a third pass now trying to find methods that match using varArgs constructs", "+    ", "+    it = f.iterator();", "+    while(it.hasNext()) {", "+      MethodDeclaration md = it.next();", "+      List<FormalParameter> l = md.getParameters();", "+     ", "+      Class<?>[] p = new Class<?>[l.size()];", "+      Iterator<FormalParameter> it2 = l.iterator();", "+      int i = 0;", "+      while(it2.hasNext()) {", "+        p[i++] = NodeProperties.getType(it2.next());", "+      }", "+      ReflectionUtilities.TigerUsage tu = new ReflectionUtilities.TigerUsage();", "+      ", "+      if (ReflectionUtilities.hasVarArgsCompatibleSignatures(p, params, tu)) {", "+        tu.checkForCompatibleUsage();", "+        compatible.add(md);", "+      }", "+    }", "+    ", "+    if(compatible.isEmpty()){", "+      throw new NoSuchFunctionException(\"No such function: \" + mname);", "+    }", "+    else if (compatible.size() == 1) {", "+      return compatible.get(0); ", "+    }", "+    else {", "+      // It is ambiguous if more than one variable-argument ", "+      // method matches the given parameter type list.", "+      throw new NoSuchFunctionException(\"Ambiguous Methods: \" + mname + \" \" + compatible.get(0).getParameters() + \",  \" +  compatible.get(1).getParameters());", "+    }"]}], "num": 20714}