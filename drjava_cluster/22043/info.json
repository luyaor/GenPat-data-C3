{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "017eee5a190db8de7af9bf468ce1be51", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1f57f5cb2569b5b22d1f48d8ebf347a7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tpublic Object visit(QualifiedName node)", "signatureAfterChange": "     public Object visit(QualifiedName node)", "diff": ["-\t */", "-\tpublic Object visit(QualifiedName node) {", "-\t    List  ids = node.getIdentifiers();", "-\t    IdentifierToken t = (IdentifierToken)ids.get(0);", "-\t    ", "-\t    if (context.isDefinedVariable(t.image()) ||", "-\t\tfieldExists(classInfo, t.image())) {", "-\t\t// The name starts with a reference to a local variable,", "-\t\t// the end of the name is a sequence of field access", "-\t\tExpression result = null;", "-\t\tif (context.isDefinedVariable(t.image())) {", "-\t\t    if (ids.size() == 1) {", "-\t\t\tClassInfo c = (ClassInfo)context.get(t.image());", "-\t\t\tnode.setProperty(NodeProperties.TYPE, c);", "-\t\t\treturn null;", "-\t\t    }", "-\t\t    List l = new LinkedList();", "-\t\t    l.add(t);", "-\t\t    result = new QualifiedName(l);", "-\t\t} else {", "-\t\t    result = new StaticFieldAccess", "-\t\t\t(new ReferenceType(classInfo.getName()),", "-\t\t\t t.image());", "-\t\t}", "-", "-\t\tIterator it = ids.iterator();", "-\t\tit.next();", "-\t\t", "-\t\tIdentifierToken t2;", "-\t\twhile (it.hasNext()) {", "-\t\t    result = new ObjectFieldAccess", "-\t\t\t(result,", "-\t\t\t (t2 = (IdentifierToken)it.next()).image(),", "-\t\t\t node.getFilename(),", "-\t\t\t t.beginLine(), t.beginColumn(),", "-\t\t\t t2.endLine(),  t2.endColumn());", "-\t\t}", "-\t\tresult.acceptVisitor(this);", "-\t\treturn result;", "-\t    } ", "-\t    ", "-\t    // The name must be, or starts with, a class name", "-\t    List      l = (List)((LinkedList)ids).clone();", "-\t    boolean   b = false;", "-", "-\t    while (l.size() > 0) {", "-\t\tString s = TreeUtilities.listToName(l);", "-\t\ttry {", "-\t\t    classFinder.lookupClass(s, classInfo);", "-\t\t    b = true;", "-\t\t    break;", "-\t\t} catch (ClassNotFoundException e) {", "-\t\t}", "-\t\tl.remove(l.size()-1);", "-\t    }", "-\t    if (!b) {", "-\t\t// It is an error if no matching class or field was found", "-\t\tnode.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t new String[] { t.image() });", "-\t\tthrow new ExecutionError(\"undefined.class\", node);", "-\t    }", "-", "-\t    // Creates a ReferenceType node", "-\t    IdentifierToken t2 = (IdentifierToken)l.get(l.size()-1);", "-\t    ReferenceType rt = new ReferenceType(l,", "-\t\t\t\t\t\t node.getFilename(),", "-\t\t\t\t\t\t t.beginLine(), t.beginColumn(),", "-\t\t\t\t\t\t t2.endLine(),  t2.endColumn());", "-\t", "-\t    if (l.size() != ids.size()) {", "-\t\t// The end of the name is a sequence of field access", "-\t\tListIterator it = ids.listIterator(l.size());", "-\t\tExpression result =", "-\t\t    new StaticFieldAccess(rt,", "-\t\t\t\t\t  (t2 = (IdentifierToken)it.next()).image(),", "-\t\t\t\t\t  node.getFilename(),", "-\t\t\t\t\t  t.beginLine(), t.beginColumn(),", "-\t\t\t\t\t  t2.endLine(),  t2.endColumn());", "-\t\twhile (it.hasNext()) {", "-\t\t    result = new ObjectFieldAccess", "-\t\t\t(result,", "-\t\t\t (t2 = (IdentifierToken)it.next()).image(),", "-\t\t\t node.getFilename(),", "-\t\t\t t.beginLine(), t.beginColumn(),", "-\t\t\t t2.endLine(),  t2.endColumn());", "-\t\t}", "-\t\tresult.acceptVisitor(this);", "-\t\treturn result;", "-\t    } else { ", "-\t\trt.acceptVisitor(this);", "-\t\treturn rt;", "-\t    }", "-\t}", "+     */", "+    public Object visit(QualifiedName node) {", "+      List<IdentifierToken> ids = node.getIdentifiers();", "+      IdentifierToken t = ids.get(0);", "+      ", "+      if (context.isDefinedVariable(t.image()) ||", "+          fieldExists(classInfo, t.image())) {", "+        // The name starts with a reference to a local variable,", "+        // the end of the name is a sequence of field access", "+        Expression result = null;", "+        if (context.isDefinedVariable(t.image())) {", "+          if (ids.size() == 1) {", "+            ClassInfo c = (ClassInfo)context.get(t.image());", "+            node.setProperty(NodeProperties.TYPE, c);", "+            return null;", "+          }", "+          List<IdentifierToken> l = new LinkedList<IdentifierToken>();", "+          l.add(t);", "+          result = new QualifiedName(l);", "+        } else {", "+          result = new StaticFieldAccess", "+            (new ReferenceType(classInfo.getName()),", "+             t.image());", "+        }", "+        ", "+        Iterator<IdentifierToken> it = ids.iterator();", "+        it.next();", "+        ", "+        IdentifierToken t2;", "+        while (it.hasNext()) {", "+          result = new ObjectFieldAccess", "+            (result,", "+             (t2 = it.next()).image(),", "+             node.getFilename(),", "+             t.beginLine(), t.beginColumn(),", "+             t2.endLine(),  t2.endColumn());", "+        }", "+        result.acceptVisitor(this);", "+        return result;", "+      } ", "+      ", "+      // The name must be, or starts with, a class name", "+      List<IdentifierToken> l = ListUtilities.listCopy(ids);", "+      boolean   b = false;", "+      ", "+      while (l.size() > 0) {", "+        String s = TreeUtilities.listToName(l);", "+        try {", "+          classFinder.lookupClass(s, classInfo);", "+          b = true;", "+          break;", "+        } catch (ClassNotFoundException e) {", "+        }", "+        l.remove(l.size()-1);", "+      }", "+      if (!b) {", "+        // It is an error if no matching class or field was found", "+        node.setProperty(NodeProperties.ERROR_STRINGS,", "+                         new String[] { t.image() });", "+        throw new ExecutionError(\"undefined.class\", node);", "+      }", "+      ", "+      // Creates a ReferenceType node", "+      IdentifierToken t2 = (IdentifierToken)l.get(l.size()-1);", "+      ReferenceType rt = new ReferenceType(l,", "+                                           node.getFilename(),", "+                                           t.beginLine(), t.beginColumn(),", "+                                           t2.endLine(),  t2.endColumn());", "+      ", "+      if (l.size() != ids.size()) {", "+        // The end of the name is a sequence of field access", "+        ListIterator it = ids.listIterator(l.size());", "+        Expression result =", "+          new StaticFieldAccess(rt,", "+                                (t2 = (IdentifierToken)it.next()).image(),", "+                                node.getFilename(),", "+                                t.beginLine(), t.beginColumn(),", "+                                t2.endLine(),  t2.endColumn());", "+        while (it.hasNext()) {", "+          result = new ObjectFieldAccess", "+            (result,", "+             (t2 = (IdentifierToken)it.next()).image(),", "+             node.getFilename(),", "+             t.beginLine(), t.beginColumn(),", "+             t2.endLine(),  t2.endColumn());", "+        }", "+        result.acceptVisitor(this);", "+        return result;", "+      } else { ", "+        rt.acceptVisitor(this);", "+        return rt;", "+      }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e913f3f0e9cfecb2da4558f4609c167", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/NameVisitor.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 24, "signatureBeforeChange": "     public Object visit(QualifiedName node)", "signatureAfterChange": "   public Node visit(QualifiedName node)", "diff": ["+   */", "+  public Node visit(QualifiedName node) {", "+    List<IdentifierToken>  ids = node.getIdentifiers();", "+    IdentifierToken t = ids.get(0);", "+    ", "+    if (context.isDefined(t.image())) {", "+      // The name starts with a reference to a local variable,", "+      // end of the name is a sequence of field access", "+      Expression result = context.createName(node, t);", "+      Iterator<IdentifierToken> it = ids.iterator();", "+      it.next();", "+      ", "+      IdentifierToken t2;", "+      while (it.hasNext()) {", "+        t2 = it.next();", "+        result = new ObjectFieldAccess(result, t2.image(),", "+                                       node.getFilename(),", "+                                       t.beginLine(), t.beginColumn(),", "+                                       t2.endLine(), t2.endColumn());", "+      }", "+      return result;", "+    } ", "+    ", "+    // The name must be, or starts with, a class name", "+    List<IdentifierToken> l = ListUtilities.listCopy(ids);", "+    boolean b = false;", "+    ", "+    while (l.size() > 0) {", "+      String s = TreeUtilities.listToName(l);", "+      if (b = context.classExists(s)) {", "+        break;", "+      }", "+      l.remove(l.size()-1);", "+    }", "+    ", "+    if (!b) {", "+      // It is an error if no matching class or field was found", "+      node.setProperty(NodeProperties.ERROR_STRINGS, new String[] { t.image() });", "+      throw new ExecutionError(\"undefined.class\", node);", "+    }", "+    ", "+    // Creates a ReferenceType node", "+    IdentifierToken t2 = l.get(l.size()-1);", "+    ReferenceType rt = new ReferenceType(l,", "+                                         node.getFilename(),", "+                                         t.beginLine(), t.beginColumn(),", "+                                         t2.endLine(),  t2.endColumn());", "+    ", "+    if (l.size() != ids.size()) {", "+      // The end of the name is a sequence of field access", "+      ListIterator<IdentifierToken> it = ids.listIterator(l.size());", "+      t2 = it.next();", "+      Expression result =", "+        new StaticFieldAccess(rt, t2.image(), node.getFilename(),", "+                              t.beginLine(), t.beginColumn(),", "+                              t2.endLine(), t2.endColumn());", "+      while (it.hasNext()) {", "+        t2 = it.next();", "+        result = new ObjectFieldAccess(result, t2.image(),", "+                                       node.getFilename(),", "+                                       t.beginLine(), t.beginColumn(),", "+                                       t2.endLine(), t2.endColumn());", "+      }", "+      return result;", "+    } ", "+    else", "+      return rt;", "+  }", "-     */", "-    public Object visit(QualifiedName node) {", "-        List  ids = node.getIdentifiers();", "-        IdentifierToken t = (IdentifierToken)ids.get(0);", "-", "-        if (context.isDefined(t.image())) {", "-            // The name starts with a reference to a local variable,", "-            // end of the name is a sequence of field access", "-\t    Expression result = context.createName(node, t);", "-            Iterator it = ids.iterator();", "-            it.next();", "-", "-            IdentifierToken t2;", "-            while (it.hasNext()) {", "-                result = new ObjectFieldAccess(result,", "-                                               (t2 = (IdentifierToken)it.next()).image(),", "-                                               node.getFilename(),", "-                                               t.beginLine(), t.beginColumn(),", "-                                               t2.endLine(),  t2.endColumn());", "-            }", "-            return result;", "-        } ", "-\t    ", "-        // The name must be, or starts with, a class name", "-        List      l = (List)((LinkedList)ids).clone();", "-\tboolean   b = false;", "-", "-\twhile (l.size() > 0) {", "-\t    String s = TreeUtilities.listToName(l);", "-\t    if (b = context.classExists(s)) {", "-\t\tbreak;", "-\t    }", "-\t    l.remove(l.size()-1);", "-\t}", "-", "-        if (!b) {", "-            // It is an error if no matching class or field was found", "-\t    node.setProperty(NodeProperties.ERROR_STRINGS, new String[] { t.image() });", "-           throw new ExecutionError(\"undefined.class\", node);", "-        }", "-", "-        // Creates a ReferenceType node", "-        IdentifierToken t2 = (IdentifierToken)l.get(l.size()-1);", "-        ReferenceType rt = new ReferenceType(l,", "-\t\t\t\t\t     node.getFilename(),", "-\t\t\t\t\t     t.beginLine(), t.beginColumn(),", "-\t\t\t\t\t     t2.endLine(),  t2.endColumn());", "-\t", "-        if (l.size() != ids.size()) {", "-            // The end of the name is a sequence of field access", "-            ListIterator it = ids.listIterator(l.size());", "-            Expression result =", "-\t\tnew StaticFieldAccess(rt,", "-\t\t\t\t      (t2 = (IdentifierToken)it.next()).image(),", "-\t\t\t\t      node.getFilename(),", "-\t\t\t\t      t.beginLine(), t.beginColumn(),", "-\t\t\t\t      t2.endLine(),  t2.endColumn());", "-            while (it.hasNext()) {", "-                result = new ObjectFieldAccess(result,", "-                                               (t2 = (IdentifierToken)it.next()).image(),", "-                                               node.getFilename(),", "-                                               t.beginLine(), t.beginColumn(),", "-                                               t2.endLine(),  t2.endColumn());", "-            }", "-            return result;", "-        } else { ", "-            return rt;", "-        }", "-    }"]}], "num": 22043}