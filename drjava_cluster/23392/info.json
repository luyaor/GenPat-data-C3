{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "22ef992fa902109f5905fc5accd9455c", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "711fe998281a411274c9a8a904b59d7b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "093f33e43dd3de7d97364f410a0a58ca1448a1ce", "commitAfterChange": "51703b3c111cc35e01e35a5e289226f6da1c1962", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 43, "signatureBeforeChange": "   protected SymbolData addInnerSymbolData(TypeDefBase typeDefBase,                                            String qualifiedTypeName,                                            String partialName,                                            Data enclosing,                                            boolean isClass)", "signatureAfterChange": "   protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String qualifiedTypeName, Data enclosing)", "diff": ["-    */", "-  protected SymbolData addInnerSymbolData(TypeDefBase typeDefBase, ", "-                                          String qualifiedTypeName, ", "-                                          String partialName, ", "-                                          Data enclosing, ", "-                                          boolean isClass) {", "-    //try to look up in symbol table, in case it has already been defined", "-    SymbolData sd = symbolTable.get(qualifiedTypeName);", "-    ", "-    //try to look up in enclosing's list of inner classes", "-    if (sd == null) { sd = enclosing.getInnerClassOrInterface(partialName); }", "-    ", "-    if (sd != null && !sd.isContinuation()) {", "-//      Utilities.show(\"This class has already been defined sd = \" + sd);", "-      _addAndIgnoreError(\"This class has already been defined.\", typeDefBase);", "-//      throw new RuntimeException(\"ALREADY DEFINED CLASS ERROR; THROWING EXCEPTION\");", "-      return null;", "-    }", "-    ", "-    if (sd != null) {", "-      //make sure it is a direct inner class or interface of this data.", "-      if (sd.getOuterData() != enclosing) { sd = null; }", "-    }", "-    ", "-    // create a new symbolData for it--this is the first time we've seen it", "-    if (sd == null) { ", "-      sd = new SymbolData(qualifiedTypeName);", "-      sd.setOuterData(enclosing);", "-      if (isClass) { enclosing.getSymbolData().addInnerClass(sd); }", "-      else { enclosing.getSymbolData().addInnerInterface(sd); }", "-    }", "-    ", "-    // create the LinkedList for the SymbolDatas of the interfaces", "-    LinkedList<SymbolData> interfaces = new LinkedList<SymbolData>();", "-    SymbolData tempSd;", "-    ReferenceType[] rts = typeDefBase.getInterfaces();", "-    for (int i = 0; i < rts.length; i++) {", "-      SourceInfo si = rts[i].getSourceInfo();", "-      String tempName = rts[i].getName();", "-      tempSd = getSymbolData(tempName, si, false, false, false);", "-      ", "-      if (tempSd != null) { interfaces.addLast(tempSd); }", "-      ", "-      else if (enclosing instanceof SymbolData) {", "-        // Check to see if this is an inner class referencing an inner interface", "-        tempSd = enclosing.getInnerClassOrInterface(tempName);", "-        if (tempSd == null) {", "-          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "-          String qualifiedTempName = qualifyingPart + \".\" + tempName;", "-          // Should we introduce addInnerInterfaceSymbol ?", "-          tempSd = new SymbolData(qualifiedTempName);", "-          tempSd.setInterface(true);", "-          enclosing.getSymbolData().addInnerInterface(tempSd); //interfaces can only be defined in symbol datas", "-          tempSd.setOuterData(enclosing);", "-//          System.err.println(\"Creating inner interface continuation for \" + qualifiedTempName + \" at LLV: 1042\");", "-          continuations.put(qualifiedTempName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));          ", "-        }", "-        interfaces.addLast(tempSd);", "-      }", "-      ", "-      else {", "-        _addAndIgnoreError(\"Cannot resolve interface \" + rts[i].getName(), rts[i]);", "-        return null;", "-      }", "-    }", "-    ", "-    //Set the package to be the current package", "-    sd.setPackage(_package);", "-    ", "-    SymbolData superClass = null;", "-    ", "-    if (typeDefBase instanceof InterfaceDef) {", "-      //add Object as the super class of this, so that it will know it implements Object's methods.", "-      superClass = getSymbolData(\"Object\", typeDefBase.getSourceInfo(), false);", "-      sd.setInterface(true);", "-    }", "-    ", "-    else if (typeDefBase instanceof ClassDef) {", "-      ClassDef cd = (ClassDef) typeDefBase;", "-      ReferenceType rt = cd.getSuperclass();", "-      String superClassName = rt.getName();", "-      superClass = getSymbolData(superClassName, rt.getSourceInfo(), false, false, false);", "-      ", "-      if (superClass == null) {", "-        superClass = enclosing.getInnerClassOrInterface(superClassName);", "-        if (superClass == null) {", "-          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "-          superClass = new SymbolData(qualifyingPart + \".\" + superClassName);", "-          enclosing.addInnerClass(superClass);", "-          superClass.setOuterData(enclosing);", "-//          System.err.println(\"Creating continuation for \" + superClassName + \" at LLV:1079\");", "-          continuations.put(superClassName, new Pair<SourceInfo, LanguageLevelVisitor>(rt.getSourceInfo(), this)); ", "-        }", "-      }", "-      sd.setInterface(false);", "-    }", "-    ", "-    else {throw new RuntimeException(\"Internal Program Error: typeDefBase was not a ClassDef or InterfaceDef.\" + ", "-                                     \"  Please report this bug.\");}", "-    ", "-    // get the SymbolData of the superclass which must be in the symbol table", "-    // since we visited the type in forClassDef() although it may be a continuation. ", "-    ", "-    // there is a continuation in the symbol table, update the fields", "-    sd.setMav(typeDefBase.getMav());", "-    sd.setTypeParameters(typeDefBase.getTypeParameters());", "-    sd.setSuperClass(superClass);", "-    sd.setInterfaces(interfaces);", "-    sd.setIsContinuation(false);", "-    continuations.remove(sd.getName());", "-    if (sd != null && !sd.isInterface()) {_newSDs.put(sd, this); }", "-    return sd;", "-  }", "+    */", "+  protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String qualifiedTypeName, Data enclosing) { ", "+        /* IMPORTANT: this is defineSymbol for inner classes! */", "+    String name = qualifiedTypeName;  // may be an interface", "+    SymbolData sd = symbolTable.get(name);", "+    if (sd != null && ! sd.isContinuation()) {", "+      _addAndIgnoreError(\"The class or interface \" + name + \" has already been defined.\", typeDefBase);", "+      return null;", "+    }", "+    ", "+    // create the LinkedList for the SymbolDatas of the interfaces", "+    LinkedList<SymbolData> interfaces = new LinkedList<SymbolData>();", "+    SymbolData tempSd;", "+    ReferenceType[] rts = typeDefBase.getInterfaces();", "+    for (int i = 0; i < rts.length; i++) {", "+      SourceInfo si = rts[i].getSourceInfo();", "+      String tempName = rts[i].getName();", "+      tempSd = getSymbolData(tempName, si, false, false, false);", "+      ", "+      if (tempSd != null) { interfaces.addLast(tempSd); }", "+      ", "+      else if (enclosing instanceof SymbolData) {", "+        // Check to see if this is an inner class referencing an inner interface", "+        tempSd = enclosing.getInnerClassOrInterface(tempName);", "+        if (tempSd == null) {", "+          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "+          String qualifiedTempName = qualifyingPart + \".\" + tempName;", "+          // Should we introduce addInnerInterfaceSymbol ?", "+          tempSd = new SymbolData(qualifiedTempName);", "+          tempSd.setInterface(true);", "+          enclosing.getSymbolData().addInnerInterface(tempSd); //interfaces can only be defined in symbol datas", "+          tempSd.setOuterData(enclosing);", "+//          System.err.println(\"Creating inner interface continuation for \" + qualifiedTempName + \" at LLV: 1042\");", "+          continuations.put(qualifiedTempName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));          ", "+        }", "+        interfaces.addLast(tempSd);", "+      }", "+      ", "+      else {", "+        _addAndIgnoreError(\"Cannot resolve interface \" + rts[i].getName(), rts[i]);", "+        return null;", "+      }", "+    }", "+        ", "+    // create a new symbolData for this inner class or interface if not seen before", "+    if (sd == null) { ", "+      sd = new SymbolData(qualifiedTypeName);", "+      sd.setOuterData(enclosing);", "+      if (typeDefBase instanceof ClassDef) { enclosing.getSymbolData().addInnerClass(sd); }", "+      else { ", "+        enclosing.getSymbolData().addInnerInterface(sd); ", "+      }", "+    }", "+    //Set the package to be the current package", "+    sd.setPackage(_package);", "+    ", "+    SymbolData superClass = null;", "+    ", "+    if (typeDefBase instanceof InterfaceDef) {", "+      // Add Object as the super class of this, so that it will know it implements Object's methods.", "+      superClass = getSymbolData(\"Object\", typeDefBase.getSourceInfo(), false);", "+      sd.setInterface(true);", "+    }", "+    else if (typeDefBase instanceof ClassDef) {", "+      ClassDef cd = (ClassDef) typeDefBase;", "+      ReferenceType rt = cd.getSuperclass();", "+      String superClassName = rt.getName();", "+      superClass = getSymbolData(superClassName, rt.getSourceInfo(), false, false, false);", "+      ", "+      if (superClass == null) {  // Why is this necessary?  Forward reference to another inner class?", "+        superClass = enclosing.getInnerClassOrInterface(superClassName);", "+        if (superClass == null) {", "+          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "+          superClass = new SymbolData(qualifyingPart + \".\" + superClassName);", "+          enclosing.addInnerClass(superClass);", "+          superClass.setOuterData(enclosing);", "+//          System.err.println(\"Creating continuation for \" + superClassName + \" at LLV:1079\");", "+          continuations.put(superClassName, new Pair<SourceInfo, LanguageLevelVisitor>(rt.getSourceInfo(), this)); ", "+        }", "+    if (! sd.isInterface()) { LanguageLevelConverter._newSDs.put(sd, this); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a49fa0af5ffe2945699cc7caed9fda73", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "c68bda7492524887225ee8f4963e9d7935485197", "commitAfterChange": "7e14052430c5a0fbe8641ad3a0f464f6b201c49d", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "   private SymbolData _classFile2SymbolData(String qualifiedClassName, String directoryName)", "signatureAfterChange": "   private SymbolData _classFile2SymbolData(String qualifiedClassName, String directoryName)", "diff": ["-    if (directoryName != null) {", "-      // Add the current directory to the class path bcel uses to find class files.", "-      ClassPath cp = new ClassPath(ClassPath.SYSTEM_CLASS_PATH + System.getProperty(\"path.separator\") + directoryName);", "-      SyntheticRepository sr = SyntheticRepository.getInstance(cp);", "-      Repository.setRepository(sr);", "-    }", "+    Iterable<File> searchPath = IterUtil.compose(LanguageLevelConverter.OPT.bootClassPath(),", "+                                                 LanguageLevelConverter.OPT.classPath());", "+    if (directoryName != null) { searchPath = IterUtil.compose(searchPath, new File(directoryName)); }", "-    JavaClass jc = Repository.lookupClass(qualifiedClassName);", "-    if (jc == null) {", "-      return null;", "+    ClassReader reader = null;", "+    try {", "+      /** We'll use this class loader to look up resources (*not* to load classes) */", "+      PathClassLoader loader = new PathClassLoader(EmptyClassLoader.INSTANCE, searchPath);", "+      InputStream stream = loader.getResourceAsStream(qualifiedClassName.replace('.', '/') + \".class\");", "+      if (stream == null) { return null; }", "+      // Let IOUtil handle the stream here, because it closes it when it's done, unlike ASM.", "+      reader = new ClassReader(IOUtil.toByteArray(stream));", "-    ", "+    catch (IOException e) { return null; }", "-    SymbolData sd = symbolTable.get(qualifiedClassName); ", "-    if (sd == null) {", "+    final SymbolData sd;", "+    SymbolData sdLookup = symbolTable.get(qualifiedClassName); ", "+    if (sdLookup == null) {", "+    else { sd = sdLookup; }", "-    // Set the modifiers and visibility", "-    sd.setMav(_createMav(jc));", "+    final SourceInfo lookupInfo = _makeSourceInfo(qualifiedClassName);", "+    final String unqualifiedClassName = getUnqualifiedClassName(qualifiedClassName);", "-    // Set the fields", "-    Field[] fields = jc.getFields();", "-    for (int i = 0; i < fields.length; i++) {", "-      String typeString = fields[i].getType().toString();", "-      SymbolData type;", "-      type = getSymbolDataForClassFile(typeString, _makeSourceInfo(qualifiedClassName));", "+    ClassVisitor extractData = new ClassVisitor() {", "-      // I assume we do not have to check for duplicate field names here since we're in a class file.", "-      // Pass in true for the second argument because we don't want to generate an accessor if it's from a class file.", "-      sd.addVar(new VariableData(fields[i].getName(), _createMav(fields[i]), type, true, sd)); //True by default", "-    }", "-    ", "-    // Set the methods", "-    String unqualifiedClassName = getUnqualifiedClassName(qualifiedClassName);", "-    Method[] methods = jc.getMethods();", "-    //We use a label here so that if a parameter's type can't be resolved, we skip this method.", "-    methodLoop: for (int i = 0; i < methods.length; i++) {", "-      SymbolData returnType;", "-      String methodName = methods[i].getName();", "-      // Check for a constructor, BCEL has them as void methods named <init>.", "-      if (methodName.equals(\"<init>\")) {", "-        // rename the name of the method to the unqualified class name and the return type to this SymbolData.", "-        methodName = unqualifiedClassName;", "-        returnType = sd;", "-      }", "-      else {", "-        //System.out.println(\"Trying to resolve method return type.\");", "-        returnType = getSymbolDataForClassFile(methods[i].getReturnType().toString(), _makeSourceInfo(qualifiedClassName));", "-      }", "-      ExceptionTable eTable = methods[i].getExceptionTable();", "-      // Get parameters", "-      org.apache.bcel.generic.Type[] paramTypes = methods[i].getArgumentTypes();", "-      LinkedList<VariableData> vdsList = new LinkedList<VariableData>();", "-      for (int j = 0; j < paramTypes.length; j++) {", "-        SymbolData tempSd = getSymbolDataForClassFile(paramTypes[j].toString(), _makeSourceInfo(qualifiedClassName));", "-        if (tempSd == null) {", "-", "-          // see getSymbolDataForClassFile's comments to see why this check is necessary.", "-          continue methodLoop;", "+      public void visit(int version, int access, String name, String sig, String sup, String[] interfaces) {", "+        sd.setMav(_createMav(access));", "+        sd.setInterface(Modifier.isInterface(access));", "+        ", "+        int slash = name.lastIndexOf('/');", "+        if (slash == -1) { sd.setPackage(\"\"); }", "+        else { sd.setPackage(name.substring(0, slash).replace('/', '.')); }", "+        ", "+        if (sup == null) { sd.setSuperClass(null); }", "+        else { sd.setSuperClass(getSymbolDataForClassFile(sup.replace('/', '.'), lookupInfo)); }", "+        ", "+        if (interfaces != null) {", "+          for (String iName : interfaces) {", "+            SymbolData superInterface = getSymbolDataForClassFile(iName.replace('/', '.'), lookupInfo);", "+            if (superInterface != null) { sd.addInterface(superInterface); }", "+          }", "-        vdsList.addLast(new VariableData(tempSd)); // a VariableData with only one argument is a parameter", "-      VariableData[] vds = (VariableData[]) vdsList.toArray(new VariableData[vdsList.size()]);", "+      public FieldVisitor visitField(int access, String name, String desc, String sig, Object value) {", "+        String typeString = org.objectweb.asm.Type.getType(desc).getClassName();", "+        SymbolData type = getSymbolDataForClassFile(typeString, lookupInfo);", "+        if (type != null) { sd.addVar(new VariableData(name, _createMav(access), type, true, sd)); }", "+        return null;", "+      }", "-      // Get thrown exceptions", "-      String[] throwStrings;", "-      if (eTable != null) { ", "-        throwStrings = eTable.getExceptionNames();", "+      public MethodVisitor visitMethod(int access, String name, String desc, String sig, String[] exceptions) {", "+        boolean valid = true;", "+        String methodName;", "+        SymbolData returnType;", "+        if (name.equals(\"<init>\")) {", "+          methodName = unqualifiedClassName;", "+          returnType = sd;", "+        }", "+        else {", "+          methodName = name;", "+          String returnString = org.objectweb.asm.Type.getReturnType(desc).getClassName();", "+          returnType = getSymbolDataForClassFile(returnString, lookupInfo);", "+          valid = valid && (returnType != null);", "+        }", "+        org.objectweb.asm.Type[] argTypes = org.objectweb.asm.Type.getArgumentTypes(desc);", "+        VariableData[] args = new VariableData[argTypes.length]; ", "+        for (int i = 0; i < argTypes.length; i++) {", "+          SymbolData argType = getSymbolDataForClassFile(argTypes[i].getClassName(), lookupInfo);", "+          if (argType == null) { valid = false; }", "+          else { args[i] = new VariableData(argType); }", "+        }", "+        if (exceptions == null) { exceptions = new String[0]; }", "+        for (int i = 0; i < exceptions.length; i++) {", "+          exceptions[i] = exceptions[i].replace('/', '.');", "+        }", "+        ", "+        if (valid) {", "+          MethodData m = new MethodData(methodName, _createMav(access), new TypeParameter[0], returnType,", "+                                        args, exceptions, sd, null);", "+          for (VariableData arg : args) { arg.setEnclosingData(m); }", "+          sd.addMethod(m, false, true);", "+        }", "+        return null;", "-      else {", "-        throwStrings = new String[0];", "-      }", "-      MethodData newMethod = new MethodData(methodName, ", "-                                  _createMav(methods[i]), ", "-                                  new TypeParameter[0], ", "-                                  returnType, ", "-                                  vds,", "-                                  throwStrings,", "-                                  sd,", "-                                  null); // no SourceInfo", "+      ", "+      public void visitSource(String source, String debug) {}", "+      public void visitOuterClass(String owner, String name, String desc) {}", "+      public AnnotationVisitor visitAnnotation(String desc, boolean visible) { return null; }", "+      public void visitAttribute(Attribute attr) {}", "+      public void visitInnerClass(String name, String outerName, String innerName, int access) {}", "+      public void visitEnd() {}", "-      ", "-      for (int k = 0; k<newMethod.getParams().length; k++) {", "-        newMethod.getParams()[k].setEnclosingData(newMethod);", "-      }", "-", "-      ", "-      sd.addMethod(newMethod, false, true);", "-      ", "-", "-    }", "- ", "-    // Set the superclass", "-    JavaClass superClass = jc.getSuperClass();", "-    if (superClass == null) {", "-      sd.setSuperClass(null);", "-    }", "-    else {", "-      sd.setSuperClass(getSymbolDataForClassFile(superClass.getClassName(), _makeSourceInfo(qualifiedClassName)));", "-    }", "+    };", "+    reader.accept(extractData, ClassReader.SKIP_CODE);", "-    // Set the interfaces", "-    JavaClass[] interfaces = jc.getInterfaces();", "-    if (interfaces != null) {", "-      for (int i = 0; i < interfaces.length; i++) {", "-        sd.addInterface(getSymbolDataForClassFile(interfaces[i].getClassName(), _makeSourceInfo(qualifiedClassName)));", "-      }", "-    }", "-    ", "-    //Set the package", "-    String pakage = jc.getPackageName();", "-    sd.setPackage(pakage);", "-    ", "-    //set the isInterface field  (if it's not a class, then it is an interface)", "-    sd.setInterface(!jc.isClass());"]}], "num": 23392}