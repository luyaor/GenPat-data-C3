{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f227a83735a121889f47253c2596e5a1", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "18163c8b201b8ddccb50ee3d16eac2b3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 127, "methodNumberAfterChange": 127, "signatureBeforeChange": "               public void testForParenthesizedOnly()", "signatureAfterChange": "               public void testForParenthesizedOnly()", "diff": ["-      Parenthesized p = new Parenthesized(SourceInfo.NO_INFO, new NullLiteral(SourceInfo.NO_INFO));", "+      Parenthesized p = new Parenthesized(SourceInfo.NONE, NULL_LITERAL);", "-      //if value_result is an intance data, no problems", "-      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), _etc.forParenthesizedOnly(p, SymbolData.BOOLEAN_TYPE.getInstanceData()));", "+      // if valueRes is an intance data, no problems", "+      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), ", "+                   _etc.forParenthesizedOnly(p, SymbolData.BOOLEAN_TYPE.getInstanceData()));", "-      //if value_result null, just return null", "+      // if valueRes null, just return null", "-      //if value_result is package data, add error", "+      // if valueRes is package data, add error", "-      ", "-      ", "-      //if value result not instance type, give error", "-      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), _etc.forParenthesizedOnly(p, SymbolData.INT_TYPE));", "+", "+      // if value result not instance type, give error", "+      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forParenthesizedOnly(p, SymbolData.INT_TYPE));", "-      assertEquals(\"Error message should be correct\",\"This class or interface name cannot appear in parentheses.  Perhaps you meant to create a new instance of int\" , errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\",", "+                   \"This class or interface name cannot appear in parentheses.  Perhaps you meant to create a new \"", "+                     + \"instance of int\" , ", "+                   errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1f30e69aaff2243c6d50c02f0d3fc2de", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 108, "methodNumberAfterChange": 108, "signatureBeforeChange": "          public void testForIncrementExpressionOnly()", "signatureAfterChange": "          public void testForIncrementExpressionOnly()", "diff": ["-      IncrementExpression ie = new PositivePrefixIncrementExpression(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"i\")));", "+      IncrementExpression ie = ", "+        new PositivePrefixIncrementExpression(SourceInfo.NONE, ", "+                                              new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"i\")));", "-      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), _etc.forIncrementExpressionOnly(ie, SymbolData.INT_TYPE.getInstanceData()));", "+      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forIncrementExpressionOnly(ie, SymbolData.INT_TYPE.getInstanceData()));", "-      //if value_result is null, return null but do not give error", "+      //if valueRes is null, return null but do not give error", "-      //if value_result is PackageData, give error and return null", "+      //if valueRes is PackageData, give error and return null", "-      //if value_result is not an instance type, give an error", "-      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), _etc.forIncrementExpressionOnly(ie, SymbolData.INT_TYPE));", "+      // if valueRes is not an instance type, give an error", "+      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forIncrementExpressionOnly(ie, SymbolData.INT_TYPE));", "-      assertEquals(\"Error message should be correct\", \"You cannot increment or decrement int, because it is a class name not an instance.  Perhaps you meant to create a new instance of int\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot increment or decrement int, because it is a class name not an instance.  \"", "+                     + \"Perhaps you meant to create a new instance of int\", errors.getLast().getFirst());", "-      //if value result is not a number type, give an error", "-      assertEquals(\"Should return sd2 instance\", _sd2.getInstanceData(), _etc.forIncrementExpressionOnly(ie, _sd2.getInstanceData()));", "+      // if value result is not a number type, give an error", "+      assertEquals(\"Should return sd2 instance\", _sd2.getInstanceData(), ", "+                   _etc.forIncrementExpressionOnly(ie, _sd2.getInstanceData()));", "-      assertEquals(\"Error message should be correct\", \"You cannot increment or decrement something that is not a number type.  You have specified something of type \" + _sd2.getName(), errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot increment or decrement something that is not a number type.  You have specified \"", "+                     + \"something of type \" + _sd2.getName(), ", "+                   errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "38d977b9d18512316b125ab759951680", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Bob.java", "commitBeforeChange": "fda8ed09ab1fd83aa0718b8a14f03f9745835af9", "commitAfterChange": "f82cbb172a00c2d57ed2feb202b1bece43cc7ef2", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": "          public void testForInitializedVariableDeclaratorOnly()", "signatureAfterChange": "          public void testForInitializedVariableDeclaratorOnly()", "diff": ["-      InitializedVariableDeclarator ivd = new InitializedVariableDeclarator(JExprParser.NO_SOURCE_INFO,", "-                                                                            JExprParser.NO_TYPE,", "-                                                                            new Word(JExprParser.NO_SOURCE_INFO, \"j\"),", "-                                                                            new DoubleLiteral(JExprParser.NO_SOURCE_INFO, 1.0));", "+      InitializedVariableDeclarator ivd = ", "+        new InitializedVariableDeclarator(SourceInfo.NO_INFO,", "+                                          JExprParser.NO_TYPE,", "+                                          new Word(SourceInfo.NO_INFO, \"j\"),", "+                                          new DoubleLiteral(SourceInfo.NO_INFO, 1.0));", "-      assertEquals(\"Two assignable types should not throw an error; return null.\", null, _b.forInitializedVariableDeclaratorOnly(ivd, sd1, sd1, sd3.getInstanceData()));", "+      assertEquals(\"Two assignable types should not throw an error; return null.\", null, ", "+                   _b.forInitializedVariableDeclaratorOnly(ivd, sd1, sd1, sd3.getInstanceData()));", "-      assertEquals(\"Two unassignable types should throw an error; return null.\", null, _b.forInitializedVariableDeclaratorOnly(ivd, sd1, sd1, sd2.getInstanceData()));", "+      assertEquals(\"Two unassignable types should throw an error; return null.\", null, ", "+                   _b.forInitializedVariableDeclaratorOnly(ivd, sd1, sd1, sd2.getInstanceData()));", "-      assertEquals(\"Error message should be correct:\", \"Type: \\\"double\\\" expected, instead found type: \\\"boolean\\\".\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct:\", \"Type: \\\"double\\\" expected, instead found type: \\\"boolean\\\".\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"An initialization from a SymbolData should return null\", null, _b.forInitializedVariableDeclaratorOnly(ivd, sd1, null, foo));", "+      assertEquals(\"An initialization from a SymbolData should return null\", null, ", "+                   _b.forInitializedVariableDeclaratorOnly(ivd, sd1, null, foo));", "-      assertEquals(\"Error message should be correct:\", \"Field or variable j cannot be initialized with the class or interface name Foo.  Perhaps you meant to create an instance or use Foo.class\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct:\", ", "+                   \"Field or variable j cannot be initialized with the class or interface name Foo.  \" + ", "+                   \"Perhaps you meant to create an instance or use Foo.class\", errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "59f27b3ec2344ce070a924ac45920756", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 125, "methodNumberAfterChange": 125, "signatureBeforeChange": "          public void testForArrayAccessOnly()", "signatureAfterChange": "          public void testForArrayAccessOnly()", "diff": ["-        new ArrayAccess(SourceInfo.NO_INFO, new NullLiteral(SourceInfo.NO_INFO), new NullLiteral(SourceInfo.NO_INFO));", "+        new ArrayAccess(SourceInfo.NONE, NULL_LITERAL, NULL_LITERAL);", "-      ArrayData ad = new ArrayData(SymbolData.INT_TYPE, testLLVisitor, SourceInfo.NO_INFO);             ", "+      ArrayData ad = new ArrayData(SymbolData.INT_TYPE, testLLVisitor, SourceInfo.NONE);             ", "-      assertEquals(\"should return int\", SymbolData.INT_TYPE.getInstanceData(), _etc.forArrayAccessOnly(aa, ad.getInstanceData(), SymbolData.INT_TYPE.getInstanceData()));", "-      assertEquals(\"should return int\", SymbolData.INT_TYPE.getInstanceData(), _etc.forArrayAccessOnly(aa, ad.getInstanceData(), SymbolData.CHAR_TYPE.getInstanceData()));", "+      assertEquals(\"should return int\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forArrayAccessOnly(aa, ad.getInstanceData(), SymbolData.INT_TYPE.getInstanceData()));", "+      assertEquals(\"should return int\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forArrayAccessOnly(aa, ad.getInstanceData(), SymbolData.CHAR_TYPE.getInstanceData()));", "-      //if type is not an array data, give appropriate error:", "-      assertEquals(\"Should return char\", SymbolData.CHAR_TYPE.getInstanceData(), _etc.forArrayAccessOnly(aa, SymbolData.CHAR_TYPE.getInstanceData(), SymbolData.INT_TYPE.getInstanceData()));", "+      // if type is not an array data, give appropriate error:", "+      assertEquals(\"Should return char\", SymbolData.CHAR_TYPE.getInstanceData(), ", "+                   _etc.forArrayAccessOnly(aa, SymbolData.CHAR_TYPE.getInstanceData(), ", "+                                           SymbolData.INT_TYPE.getInstanceData()));", "-      //If the array index is not an instance type, give error", "-      assertEquals(\"should return int\", SymbolData.INT_TYPE.getInstanceData(), _etc.forArrayAccessOnly(aa, ad.getInstanceData(), SymbolData.INT_TYPE));", "+      // If the array index is not an instance type, give error", "+      assertEquals(\"should return int\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forArrayAccessOnly(aa, ad.getInstanceData(), SymbolData.INT_TYPE));", "-      assertEquals(\"should return int\", SymbolData.INT_TYPE.getInstanceData(), _etc.forArrayAccessOnly(aa, ad.getInstanceData(), SymbolData.DOUBLE_TYPE.getInstanceData()));", "+      assertEquals(\"should return int\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forArrayAccessOnly(aa, ad.getInstanceData(), SymbolData.DOUBLE_TYPE.getInstanceData()));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "67842f6be883aa3b88b4dbc3f8cd4bbb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "dd97c2983de18f5d46f596ce3c536a3b581f0ec4", "commitAfterChange": "e5b59097570657040bcd74f7a31c6db7f03359ce", "methodNumberBeforeChange": 113, "methodNumberAfterChange": 113, "signatureBeforeChange": "         public void testForInstanceOfExpressionOnly()", "signatureAfterChange": "            public void testForInstanceOfExpressionOnly()", "diff": ["-", "-    public void testForInstanceOfExpressionOnly() {", "-      InstanceofExpression ioe = new InstanceofExpression(SourceInfo.NO_INFO, ", "-                                                          new BooleanLiteral(SourceInfo.NO_INFO, true),", "-                                                          new PrimitiveType(SourceInfo.NO_INFO, \"int\"));", "-      try {", "-        _etc.forInstanceofExpressionOnly(ioe, SymbolData.BOOLEAN_TYPE.getInstanceData(), SymbolData.INT_TYPE.getInstanceData());", "-        fail(\"Should have thrown an exception.\");", "-      }", "-      catch (Exception e) {", "-        assertEquals(\"Exception message should be correct\", \"Internal Program Error: instanceof is not currently supported.  This should have been caught before the Type Checker.  Please report this bug.\", e.getMessage());", "-        ", "-      }", "-    }", "+    public void testForInstanceOfExpressionOnly() {", "+      SymbolData sd1 = SymbolData.DOUBLE_TYPE;", "+      SymbolData sd2 = SymbolData.BOOLEAN_TYPE;", "+      SymbolData sd3 = SymbolData.INT_TYPE;", "+      InstanceofExpression ioe = new InstanceofExpression(SourceInfo.NO_INFO,          ", "+                                                          new NullLiteral(SourceInfo.NO_INFO),", "+                                                          JExprParser.NO_TYPE);  // Object type", "+      ", "+      assertEquals(\"When value_result is subtype of type_result, return BOOLEAN type_result.\", sd2.getInstanceData(), ", "+                   _etc.forInstanceofExpressionOnly(ioe, sd1, sd3.getInstanceData()));", "+      assertEquals(\"Should not throw an error.\", 0, errors.size());", "+      assertEquals(\"When type_result is subtype of value_result, return BOOLEAN type_result.\", sd2.getInstanceData(), ", "+                   _etc.forInstanceofExpressionOnly(ioe, sd3, sd1.getInstanceData()));", "+      assertEquals(\"Should not throw an error.\", 0, errors.size());", "+      assertEquals(\"When type_result and value_result are not subtypes of each other, return BOOLEAN type_result\", ", "+                   sd2.getInstanceData(),", "+                   _etc.forInstanceofExpressionOnly(ioe, sd2, sd1.getInstanceData()));", "+      assertEquals(\"Should now be one error.\", 1, errors.size());", "+      assertEquals(\"Error message should be correct.\", \"You cannot test whether an expression of type \" + sd1.getName() ", "+                     + \" belongs to type \" + sd2.getName() + \" because they are not related\", ", "+                   errors.getLast().getFirst());     ", "+      SymbolData foo = new SymbolData(\"Foo\");", "+      SymbolData fooMama = new SymbolData(\"FooMama\");", "+      foo.setSuperClass(fooMama);", "+      assertEquals(\"When value_result is a SymbolData, return BOOLEAN type_result\",  sd2.getInstanceData(), ", "+                   _etc.forInstanceofExpressionOnly(ioe, foo, fooMama));", "+      assertEquals(\"There should be 2 errors.\", 2, errors.size());", "+      assertEquals(\"Error message should be correct.\", ", "+                   \"You are trying to test if FooMama belongs to type, but it is a class or interface type, \"", "+                     + \"not an instance.  Perhaps you meant to create a new instance of FooMama\",", "+                   errors.getLast().getFirst());", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "963e8230b74a4b240e82b8465de1f365", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "dd97c2983de18f5d46f596ce3c536a3b581f0ec4", "commitAfterChange": "e5b59097570657040bcd74f7a31c6db7f03359ce", "methodNumberBeforeChange": 85, "methodNumberAfterChange": 85, "signatureBeforeChange": "               public void testForCastExpressionOnly()", "signatureAfterChange": "          public void testForCastExpressionOnly()", "diff": ["-", "-      assertEquals(\"When value_result is subtype of type_result, return type_result.\", sd1.getInstanceData(), _etc.forCastExpressionOnly(cd, sd1, sd3.getInstanceData()));", "+      ", "+      assertEquals(\"When value_result is subtype of type_result, return type_result.\", sd1.getInstanceData(), ", "+                   _etc.forCastExpressionOnly(cd, sd1, sd3.getInstanceData()));", "-      assertEquals(\"When type_result is subtype of value_result, return type_result.\", sd3.getInstanceData(), _etc.forCastExpressionOnly(cd, sd3, sd1.getInstanceData()));", "+      assertEquals(\"When type_result is subtype of value_result, return type_result.\", sd3.getInstanceData(), ", "+                   _etc.forCastExpressionOnly(cd, sd3, sd1.getInstanceData()));", "-      assertEquals(\"When type_result and value_result are not subtypes of each other, return type_result\", sd2.getInstanceData(), _etc.forCastExpressionOnly(cd, sd2, sd1.getInstanceData()));", "+      assertEquals(\"When type_result and value_result are not subtypes of each other, return type_result\", ", "+                   sd2.getInstanceData(), _etc.forCastExpressionOnly(cd, sd2, sd1.getInstanceData()));", "-      assertEquals(\"Error message should be correct.\", \"You cannot cast an expression of type \" + sd1.getName() + \" to type \" + sd2.getName() + \" because they are not related\", errors.getLast().getFirst());     ", "+      assertEquals(\"Error message should be correct.\", \"You cannot cast an expression of type \" + sd1.getName() ", "+                     + \" to type \" + sd2.getName() + \" because they are not related\", ", "+                   errors.getLast().getFirst());     ", "-      assertEquals(\"When value_result is a SymbolData, return type_result\", fooMama.getInstanceData(), _etc.forCastExpressionOnly(cd, fooMama, foo));", "+      assertEquals(\"When value_result is a SymbolData, return type_result\", fooMama.getInstanceData(), ", "+                   _etc.forCastExpressionOnly(cd, fooMama, foo));", "-      assertEquals(\"Error message should be correct.\", \"You are trying to cast Foo, which is a class or interface type, not an instance.  Perhaps you meant to create a new instance of Foo\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct.\", ", "+                   \"You are trying to cast Foo, which is a class or interface type, not an instance.  \" ", "+                     + \"Perhaps you meant to create a new instance of Foo\",", "+                   errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f212924f35a27a82c7b99d699edf3ac", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 111, "methodNumberAfterChange": 111, "signatureBeforeChange": "               public void testForNotExpressionOnly()", "signatureAfterChange": "               public void testForNotExpressionOnly()", "diff": ["-      NotExpression ne = new NotExpression(SourceInfo.NO_INFO, new NullLiteral(SourceInfo.NO_INFO));", "+      NotExpression ne = new NotExpression(SourceInfo.NONE, NULL_LITERAL);", "-      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), _etc.forNotExpressionOnly(ne, SymbolData.BOOLEAN_TYPE.getInstanceData()));", "+      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), ", "+                   _etc.forNotExpressionOnly(ne, SymbolData.BOOLEAN_TYPE.getInstanceData()));", "-      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), _etc.forNotExpressionOnly(ne, SymbolData.BOOLEAN_TYPE));", "+      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), ", "+                   _etc.forNotExpressionOnly(ne, SymbolData.BOOLEAN_TYPE));", "-      assertEquals(\"Error message should be correct\",\"You cannot use the not (!) operator with boolean, because it is a class name, not an instance.  Perhaps you meant to create a new instance of boolean\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\",", "+                   \"You cannot use the not (!) operator with boolean, because it is a class name, not an instance.  \"", "+                     + \"Perhaps you meant to create a new instance of boolean\", errors.getLast().getFirst());", "-      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), _etc.forNotExpressionOnly(ne, SymbolData.INT_TYPE.getInstanceData()));", "+      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), ", "+                   _etc.forNotExpressionOnly(ne, SymbolData.INT_TYPE.getInstanceData()));", "-      assertEquals(\"Error message should be correct\", \"You cannot use the not (!) operator with something of type int. Instead, it should be used with an expression of boolean type\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot use the not (!) operator with something of type int. Instead, it should be used \"", "+                     + \"with an expression of boolean type\", errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d6738e051580aabeda61c6dd2f216419", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Bob.java", "commitBeforeChange": "c7ce54f2435a198c543bef7b35866738d8690d46", "commitAfterChange": "f9b3ce896f60a5fa583a421b5b2bb827822b30df", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": "                          public void testForThrowStatementOnly()", "signatureAfterChange": "                          public void testForThrowStatementOnly()", "diff": ["-      SymbolData exception = new SymbolData(\"java.lang.Throwable\");", "+      ThrowStatement s = new ThrowStatement(JExprParser.NO_SOURCE_INFO, new NullLiteral(JExprParser.NO_SOURCE_INFO));", "+      SymbolData exception = _b.getSymbolData(\"java.lang.Throwable\", s, false, true); // new SymbolData(\"java.lang.Throwable\");", "-      symbolTable.put(\"java.lang.Throwable\", exception);", "+//      symbolTable.put(\"java.lang.Throwable\", exception);", "-      ThrowStatement s = new ThrowStatement(JExprParser.NO_SOURCE_INFO, new NullLiteral(JExprParser.NO_SOURCE_INFO));", "-      assertEquals(\"When a SymbolData is the thrown type, return its InstanceData\", exceptionInstance, _b.forThrowStatementOnly(s, exception));", "+      assertEquals(\"When a SymbolData is the thrown type, return its InstanceData\", exceptionInstance, ", "+                   _b.forThrowStatementOnly(s, exception));", "-      assertEquals(\"Error message should be correct\", \"You cannot throw a class or interface name.  Perhaps you mean to instantiate the exception java.lang.Throwable that you are throwing\", errors.getLast().getFirst());", "+      ", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot throw a class or interface name.  \" + ", "+                   \"Perhaps you mean to instantiate the exception class java.lang.Throwable that you are throwing\", ", "+                   errors.get(0).getFirst());", "-      assertEquals(\"When a thrown type does not implement Throwable, return the type anyway\", naeInstance, _b.forThrowStatementOnly(s, naeInstance));", "+      assertEquals(\"When a thrown type does not implement Throwable, return the type anyway\", naeInstance, ", "+                   _b.forThrowStatementOnly(s, naeInstance));", "-      assertEquals(\"Error message should be correct\", \"You are attempting to throw bob, which does not implement the Throwable interface\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You are attempting to throw bob, which does not implement the Throwable interface\", errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eb47b315d240048e5558e64e8e30c399", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 109, "methodNumberAfterChange": 109, "signatureBeforeChange": "                    public void testForNumericUnaryExpressionOnly()", "signatureAfterChange": "                    public void testForNumericUnaryExpressionOnly()", "diff": ["-      NumericUnaryExpression nue = new PositiveExpression(SourceInfo.NO_INFO, new IntegerLiteral(SourceInfo.NO_INFO, 5));", "+      NumericUnaryExpression nue = new PositiveExpression(SourceInfo.NONE, new IntegerLiteral(SourceInfo.NONE, 5));", "-      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), _etc.forNumericUnaryExpressionOnly(nue, SymbolData.CHAR_TYPE.getInstanceData()));", "-      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), _etc.forNumericUnaryExpressionOnly(nue, SymbolData.BYTE_TYPE.getInstanceData()));", "+      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forNumericUnaryExpressionOnly(nue, SymbolData.CHAR_TYPE.getInstanceData()));", "+      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forNumericUnaryExpressionOnly(nue, SymbolData.BYTE_TYPE.getInstanceData()));", "-      assertEquals(\"Should return double instance\", SymbolData.DOUBLE_TYPE.getInstanceData(), _etc.forNumericUnaryExpressionOnly(nue, SymbolData.DOUBLE_TYPE.getInstanceData()));", "+      assertEquals(\"Should return double instance\", SymbolData.DOUBLE_TYPE.getInstanceData(), ", "+                   _etc.forNumericUnaryExpressionOnly(nue, SymbolData.DOUBLE_TYPE.getInstanceData()));", "-      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), _etc.forNumericUnaryExpressionOnly(nue, SymbolData.INT_TYPE));", "+      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forNumericUnaryExpressionOnly(nue, SymbolData.INT_TYPE));", "-      assertEquals(\"Error message should be correct\", \"You cannot use a numeric unary operator (+, -) with int, because it is a class name, not an instance.  Perhaps you meant to create a new instance of int\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot use a numeric unary operator (+, -) with int, because it is a class name, \"", "+                     + \"not an instance.  Perhaps you meant to create a new instance of int\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), _etc.forNumericUnaryExpressionOnly(nue, SymbolData.BOOLEAN_TYPE.getInstanceData()));", "+      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), ", "+                   _etc.forNumericUnaryExpressionOnly(nue, SymbolData.BOOLEAN_TYPE.getInstanceData()));", "-      assertEquals(\"Error message should be correct\", \"You cannot apply this unary operator to something of type boolean.  You can only apply it to a numeric type such as double, int, or char\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot apply this unary operator to something of type boolean.  You can only apply it \"", "+                     + \"to a numeric type such as double, int, or char\", errors.getLast().getFirst());"]}], "num": 6447}