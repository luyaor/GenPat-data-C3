{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6ee4543f9342ab50ba68c74d192c2705", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1fc1e869aa0363d4facb5ba28ec02c0e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/DefaultCompilerModel.java", "commitBeforeChange": "0e6d6d4c130043dfa8d569e24f0f6f9c1f824f96", "commitAfterChange": "ccb8831468d9c146526d6431dd0a2aea7a5182b5", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 8, "signatureBeforeChange": "   protected void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "signatureAfterChange": "   protected void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "diff": ["-    CompilerError[] errors = new CompilerError[0];", "+//    CompilerError[] errors = new CompilerError[0];", "+    Pair<LinkedList<ParseException>, LinkedList<Pair<String, JExpression>>> errors;", "+    LinkedList<ParseException> parseExceptions;", "+    LinkedList<Pair<String, JExpression>> visitorErrors;", "+      LinkedList<CompilerError> compilerErrors = new LinkedList<CompilerError>();", "-      errors = compiler.compile(sourceRoots, files);", "+//      if (DrJava.getConfig().getSetting(OptionConstants.LANGUAGE_LEVEL) == DrJava.ELEMENTARY_LEVEL) {", "+      LanguageLevelConverter llc = new LanguageLevelConverter();", "+      // Language level files are moved to another file, copied back", "+      // in augmented form to be compiled.  This compiled version", "+      // is also copied to another file with the same path with the ", "+      // \".augmented\" suffix on the end.", "+      // We have to copy the original back to its original spot so the", "+      // user doesn't have to do anything funny.", "+      //      LinkedList<File> filesToRestore = new LinkedList<File>();", "+      //      System.out.println(\"Calling convert!\");", "+      errors = llc.convert(files);//, filesToRestore);", "+      ", "+      /**Rename any .dj0 files in files to be .java files, so the correct thing is compiled.*/", "+      for (int i = 0; i<files.length; i++) {", "+        String fileName = files[i].getAbsolutePath();", "+        int lastIndex = fileName.lastIndexOf(\".dj\");", "+        if (lastIndex != -1) {", "+          files[i]=new File(fileName.substring(0, lastIndex) + \".java\");", "+        }", "+      }", "+      parseExceptions = errors.getFirst();", "+      compilerErrors.addAll(_parseExceptions2CompilerErrors(parseExceptions));", "+      visitorErrors = errors.getSecond();", "+      compilerErrors.addAll(_visitorErrors2CompilerErrors(visitorErrors));", "+//      }", "+//      System.out.println(\"Got back \" + errors.length + \" errors\");", "+      CompilerError[] compilerErrorsArray = (CompilerError[]) compilerErrors.toArray(new CompilerError[0]);", "+      if (compilerErrorsArray.length == 0) {", "+        compilerErrorsArray = compiler.compile(sourceRoots, files);", "+      }", "+//      Iterator<File> iter = filesToRestore.iterator();", "+//      while (iter.hasNext()) {", "+//        _getter.getDocumentForFile(iter.next()).revertFile();", "+//      }", "+      _distributeErrors(compilerErrorsArray);", "+      // Restore the files that were moved.", "+//      Iterator<File> iter = filesToRestore.iterator();", "+//      while (iter.hasNext()) {", "+//        File f = iter.next();", "+//        File sourceFile = new File(f.getAbsolutePath() + \".beginner\");", "+//        // Windows needs this since otherwise rename won't work.", "+//        if (f.exists()) {", "+//          f.delete();", "+//        }", "+//        sourceFile.renameTo(f);", "+//      }", "-    _distributeErrors(errors);", "+    else {", "+      _distributeErrors(new CompilerError[0]);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dfb2700aa909436a1e89337289ff8413", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ElementaryLevelTest.java", "commitBeforeChange": "c7ce54f2435a198c543bef7b35866738d8690d46", "commitAfterChange": "f9b3ce896f60a5fa583a421b5b2bb827822b30df", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "   public void testRequiresAutoboxing()", "signatureAfterChange": "   public void testRequiresAutoboxing()", "diff": ["-", "-      LanguageLevelConverter llc14 = new LanguageLevelConverter();", "-      LanguageLevelConverter llc5 = new LanguageLevelConverter();", "-      Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>> result;", "+    ", "+    Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>> result;", "+    ", "+    for (int i = 0; i <testFiles.length; i++) {", "+      LanguageLevelConverter llc4 = new LanguageLevelConverter();", "+      result = llc4.convert(new File[]{testFiles[i]}, new Options(JavaVersion.JAVA_1_4, IterUtil.<File>empty()));", "+      assertTrue(\"should be parse exceptions or visitor exceptions\", !result.getFirst().isEmpty() || !result.getSecond().isEmpty());", "+    }", "+    ", "+    LanguageLevelConverter llc = new LanguageLevelConverter();", "+    ", "+    result = llc.convert(testFiles, new Options(JavaVersion.JAVA_5, IterUtil.<File>empty()));", "+    ", "+    assertEquals(\"should be no parse exceptions\", new LinkedList<JExprParseException>(), result.getFirst());", "+    assertEquals(\"should be no visitor exceptions\", new LinkedList<Pair<String, JExpressionIF>>(), result.getSecond());", "+    ", "+    /**Now make sure that the resulting java files are correct.*/", "+    for(int i = 0; i < testFiles.length; i++) {", "+      File currFile = testFiles[i];", "+      String fileName = currFile.getAbsolutePath();", "+      fileName = fileName.substring(0, fileName.length() -4);", "+      File resultingFile = new File(fileName + \".java\");", "+      File correctFile = new File(fileName + \".expected\");", "-      for (int i = 0; i<testFiles.length; i++) {", "-        result = llc14.convert(new File[]{testFiles[i]}, new Options(JavaVersion.JAVA_1_4, IterUtil.<File>empty()));", "-        assertTrue(\"should be parse exceptions or visitor exceptions\", !result.getFirst().isEmpty() || !result.getSecond().isEmpty());", "-      }", "-      ", "-      result = llc5.convert(testFiles, new Options(JavaVersion.JAVA_5, IterUtil.<File>empty()));", "-", "-      assertEquals(\"should be no parse exceptions\", new LinkedList<JExprParseException>(), result.getFirst());", "-      assertEquals(\"should be no visitor exceptions\", new LinkedList<Pair<String, JExpressionIF>>(), result.getSecond());", "-", "-      /**Now make sure that the resulting java files are correct.*/", "-      for(int i = 0; i < testFiles.length; i++) {", "-        File currFile = testFiles[i];", "-        String fileName = currFile.getAbsolutePath();", "-        fileName = fileName.substring(0, fileName.length() -4);", "-        File resultingFile = new File(fileName + \".java\");", "-        File correctFile = new File(fileName + \".expected\");", "-        ", "-        try {", "+      try {", "-        }", "-        catch (IOException ioe) {", "-          fail(ioe.getMessage());", "-          // let JUnit throw the exception", "-        }", "-      ", "+      catch (IOException ioe) {", "+        fail(ioe.getMessage());", "+        // let JUnit throw the exception", "+      }", "+    }"]}], "num": 8163}