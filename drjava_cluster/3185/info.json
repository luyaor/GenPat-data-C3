{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "65bbc2ff37e875b72d2eda2e253184c7", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "33d258c82e9de26ca565939296a08172", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/TypeChecker.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": "     public Object visit(ObjectMethodCall node)", "signatureAfterChange": "   public Class visit(ObjectMethodCall node)", "diff": ["-     */", "-    public Object visit(ObjectMethodCall node) {", "-        // Check the receiver", "-\tExpression exp = node.getExpression();", "-\tClass      c   = (Class)exp.acceptVisitor(this);", "-\tString     mn  = node.getMethodName();", "-", "-        if (!c.isArray() || (c.isArray() && !mn.equals(\"clone\"))) {", "-            // Do the type checking of the arguments", "-            List args = node.getArguments();", "-            Class[] cargs = Constants.EMPTY_CLASS_ARRAY;", "-            if (args != null) {", "-                cargs = new Class[args.size()];", "-                Iterator it = args.iterator();", "-                int i  = 0;", "-                while (it.hasNext()) {", "-                    cargs[i++] = (Class)((Node)it.next()).acceptVisitor(this);", "-                }", "-            }", "-            Method m = null;", "-            try {", "-                m = context.lookupMethod(exp, mn, cargs);", "-            } catch (NoSuchMethodException e) {", "-\t\tString s = c.getName();", "-\t\tnode.setProperty(NodeProperties.ERROR_STRINGS, new String[] { mn, s });", "-                throw new ExecutionError(\"no.such.method\", node);", "-\t    } catch (MethodModificationError e) {", "-\t\tExpression expr = e.getExpression();", "-\t\texpr.acceptVisitor(this);", "-\t\tnode.setExpression(expr);", "-\t\tm = e.getMethod();", "-\t    }", "-", "-            // Set the node properties", "-            node.setProperty(NodeProperties.METHOD, m);", "-            node.setProperty(NodeProperties.TYPE,   c = m.getReturnType());", "-\t    return c;", "-\t} else {", "-            if (!mn.equals(\"clone\") || node.getArguments() != null) {", "-\t\tString s0 = \"clone\";", "-\t\tString s1 = c.getComponentType().getName() + \" array\";", "-\t\tnode.setProperty(NodeProperties.ERROR_STRINGS, new String[] { s0, s1 });", "-                throw new ExecutionError(\"no.such.method\", node);", "-            }", "-            node.setProperty(NodeProperties.TYPE, c = Object.class);", "-\t    return c;", "-\t}", "-    }", "+   */", "+  public Class visit(ObjectMethodCall node) {", "+    // Check the receiver", "+    Expression exp = node.getExpression();", "+    Class      c   = (Class)exp.acceptVisitor(this);", "+    String     mn  = node.getMethodName();", "+    ", "+    if (!c.isArray() || (c.isArray() && !mn.equals(\"clone\"))) {", "+      // Do the type checking of the arguments", "+      List args = node.getArguments();", "+      Class[] cargs = Constants.EMPTY_CLASS_ARRAY;", "+      if (args != null) {", "+        cargs = new Class[args.size()];", "+        Iterator it = args.iterator();", "+        int i  = 0;", "+          cargs[i++] = (Class)((Node)it.next()).acceptVisitor(this);", "+      }", "+      Method m = null;", "+      try {", "+        m = context.lookupMethod(exp, mn, cargs);", "+      } catch (NoSuchMethodException e) {", "+        String s = c.getName();", "+        node.setProperty(NodeProperties.ERROR_STRINGS, new String[] { mn, s });", "+        throw new ExecutionError(\"no.such.method\", node);", "+      } catch (MethodModificationError e) {", "+        Expression expr = e.getExpression();", "+        expr.acceptVisitor(this);", "+        node.setExpression(expr);", "+        m = e.getMethod();", "+      }", "+      ", "+      // Set the node properties", "+      node.setProperty(NodeProperties.METHOD, m);", "+      node.setProperty(NodeProperties.TYPE,   c = m.getReturnType());", "+      return c;", "+    } else {", "+      if (!mn.equals(\"clone\") || node.getArguments() != null) {", "+        String s0 = \"clone\";", "+        String s1 = c.getComponentType().getName() + \" array\";", "+        node.setProperty(NodeProperties.ERROR_STRINGS, new String[] { s0, s1 });", "+        throw new ExecutionError(\"no.such.method\", node);", "+      }", "+      node.setProperty(NodeProperties.TYPE, c = Object.class);", "+      return c;", "+    }", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "833178902bb8306812fa80f8d46f5cd7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/TypeChecker.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": "     public Object visit(InnerAllocation node)", "signatureAfterChange": "   public Class visit(InnerAllocation node)", "diff": ["-     */", "-    public Object visit(InnerAllocation node) {", "-        // Visit the expression", "-        Class ec = (Class)node.getExpression().acceptVisitor(this);", "-", "-        // Check the type to declare", "-        Node type = node.getCreationType();", "-        if (type instanceof ReferenceType) {", "-            ReferenceType rt = (ReferenceType)type;", "-            rt.setRepresentation(ec.getName() + \"$\" + rt.getRepresentation());", "-        } else {", "-            throw new ExecutionError(\"allocation.type\", node);", "-        }", "-        Class c = (Class)type.acceptVisitor(this);", "-\tClass dc = InterpreterUtilities.getDeclaringClass(c);", "-", "-        // Do the type checking of the arguments", "-        List args = node.getArguments();", "-        Class[] cargs = null;", "-", "-        if (dc != null && dc.isAssignableFrom(ec)) {", "-            // Adds an argument if the class to build is an innerclass", "-            if (args != null) {", "-                cargs = new Class[args.size() + 1];", "-                ", "-                cargs[0] = ec;", "-                ListIterator it = args.listIterator();", "-                int i  = 1;", "-                while (it.hasNext()) {", "-                    cargs[i++] = (Class)((Node)it.next()).acceptVisitor(this);", "-                }", "-                cargs = new Class[] { ec };", "-        } else {", "-            throw new ExecutionError(\"allocation.type\", node);", "-        Constructor cons = null;", "-        try {", "-            cons = context.lookupConstructor(c, cargs);", "-        } catch (Exception e) {", "-            throw new CatchedExceptionError(e, node);", "-        }", "-        ", "-        // Set the properties of this node", "-        node.setProperty(NodeProperties.TYPE,        c);", "-        node.setProperty(NodeProperties.CONSTRUCTOR, cons);", "-", "-        return c;", "+   */", "+  public Class visit(InnerAllocation node) {", "+    // Visit the expression", "+    Class ec = (Class)node.getExpression().acceptVisitor(this);", "+    ", "+    // Check the type to declare", "+    Node type = node.getCreationType();", "+    if (type instanceof ReferenceType) {", "+      ReferenceType rt = (ReferenceType)type;", "+      rt.setRepresentation(ec.getName() + \"$\" + rt.getRepresentation());", "+    } else {", "+      throw new ExecutionError(\"allocation.type\", node);", "+    }", "+    Class c = (Class)type.acceptVisitor(this);", "+    Class dc = InterpreterUtilities.getDeclaringClass(c);", "+    ", "+    // Do the type checking of the arguments", "+    List args = node.getArguments();", "+    Class[] cargs = null;", "+    ", "+    if (dc != null && dc.isAssignableFrom(ec)) {", "+      // Adds an argument if the class to build is an innerclass", "+      if (args != null) {", "+        cargs = new Class[args.size() + 1];", "+        cargs[0] = ec;", "+        ListIterator it = args.listIterator();", "+        int i  = 1;", "+        while (it.hasNext()) {", "+          cargs[i++] = (Class)((Node)it.next()).acceptVisitor(this);", "+      } else {", "+        cargs = new Class[] { ec };", "+      }", "+    } else {", "+      throw new ExecutionError(\"allocation.type\", node);", "+    Constructor cons = null;", "+    try {", "+      cons = context.lookupConstructor(c, cargs);", "+    } catch (Exception e) {", "+      throw new CatchedExceptionError(e, node);", "+    ", "+    // Set the properties of this node", "+    node.setProperty(NodeProperties.TYPE,        c);", "+    node.setProperty(NodeProperties.CONSTRUCTOR, cons);", "+    ", "+    return c;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e09b1cac7c1d32d7616e562b409b8759", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/EvaluationVisitor.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "     public Object visit(ObjectMethodCall node)", "signatureAfterChange": "   public Object visit(ObjectMethodCall node)", "diff": ["-     */", "-    public Object visit(ObjectMethodCall node) {", "-\tExpression exp = node.getExpression();", "-", "-        // Evaluate the receiver first", "-        Object obj  = exp.acceptVisitor(this);", "-", "-        if (node.hasProperty(NodeProperties.METHOD)) {", "-            Method   m    = (Method)node.getProperty(NodeProperties.METHOD);", "-            Class[]  typs = m.getParameterTypes();", "-", "-            // Relax the protection for members?", "-            if (context.getAccessible()) {", "-                m.setAccessible(true);", "-            }", "-", "-            List     larg = node.getArguments();", "-            Object[] args = Constants.EMPTY_OBJECT_ARRAY;", "-", "-            // Fill the arguments", "-            if (larg != null) {", "-                args = new Object[larg.size()];", "-                Iterator it = larg.iterator();", "-                int      i  = 0;", "-                while (it.hasNext()) {", "-                    Object p  = ((Expression)it.next()).acceptVisitor(this);", "-                    args[i] = performCast(typs[i], p);", "-                    i++;", "-                }", "-            }", "-            // Invoke the method", "-            try {", "-                return m.invoke(obj, args);", "-            } catch (InvocationTargetException e) {", "-                if (e.getTargetException() instanceof Error) {", "-                    throw (Error)e.getTargetException();", "-                } else if (e.getTargetException() instanceof RuntimeException) {", "-                    throw (RuntimeException)e.getTargetException();", "-                }", "-                throw new ThrownException(e.getTargetException(), node);", "-            } catch (Exception e) {", "-                throw new CatchedExceptionError(e, node);", "-            }", "-        } else {", "-            // If the 'method' property is not set, the object must be", "-            // an array and the called method must be 'clone'.", "-            // Since the 'clone' method of an array is not a normal", "-            // method, the only way to invoke it is to simulate its", "-            // behaviour.", "-\t    Class c = NodeProperties.getType(exp);", "-            int len = Array.getLength(obj);", "-            Object result = Array.newInstance(c.getComponentType(), len);", "-            for (int i = 0; i < len; i++) {", "-                Array.set(result, i, Array.get(obj, i));", "-            }", "-            return result;", "-        }", "-    }", "+   */", "+  public Object visit(ObjectMethodCall node) {", "+    Expression exp = node.getExpression();", "+    ", "+    // Evaluate the receiver first", "+    Object obj  = exp.acceptVisitor(this);", "+    ", "+    if (node.hasProperty(NodeProperties.METHOD)) {", "+      Method   m    = (Method)node.getProperty(NodeProperties.METHOD);", "+      Class[]  typs = m.getParameterTypes();", "+      ", "+      // Relax the protection for members?", "+      if (context.getAccessible()) {", "+        m.setAccessible(true);", "+      }", "+      ", "+      List<Expression> larg = node.getArguments();", "+      Object[] args = Constants.EMPTY_OBJECT_ARRAY;", "+      ", "+      // Fill the arguments", "+      if (larg != null) {", "+        args = new Object[larg.size()];", "+        Iterator<Expression> it = larg.iterator();", "+        int      i  = 0;", "+        while (it.hasNext()) {", "+          Object p  = ((Expression)it.next()).acceptVisitor(this);", "+          args[i] = performCast(typs[i], p);", "+          i++;", "+        }", "+      }", "+      // Invoke the method", "+      try {", "+        return m.invoke(obj, args);", "+      } catch (InvocationTargetException e) {", "+        if (e.getTargetException() instanceof Error) {", "+          throw (Error)e.getTargetException();", "+        } else if (e.getTargetException() instanceof RuntimeException) {", "+          throw (RuntimeException)e.getTargetException();", "+        }", "+        throw new ThrownException(e.getTargetException(), node);", "+      } catch (Exception e) {", "+        throw new CatchedExceptionError(e, node);", "+      }", "+    } else {", "+      // If the 'method' property is not set, the object must be", "+      // an array and the called method must be 'clone'.", "+      // Since the 'clone' method of an array is not a normal", "+      // method, the only way to invoke it is to simulate its", "+      // behaviour.", "+      Class c = NodeProperties.getType(exp);", "+      int len = Array.getLength(obj);", "+      Object result = Array.newInstance(c.getComponentType(), len);", "+      for (int i = 0; i < len; i++) {", "+        Array.set(result, i, Array.get(obj, i));", "+      }", "+      return result;", "+    }", "+  }"]}], "num": 3185}