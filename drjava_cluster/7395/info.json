{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "88aecb830ef96e8e32e477abb76202c5", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4dc8557227f6b0c6249394935da29e95", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 35, "signatureBeforeChange": "   protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String qualifiedTypeName, Data enclosing)", "signatureAfterChange": "   protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String relName, String qualifiedTypeName,                                               Data enclosing)", "diff": ["-  protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String qualifiedTypeName, Data enclosing) { ", "-        /* IMPORTANT: this is defineSymbol for inner classes! */", "-    String name = qualifiedTypeName;  // may be an interface", "-    SymbolData sd = symbolTable.get(name);", "-    if (sd != null && ! sd.isContinuation()) {", "-      _addAndIgnoreError(\"The class or interface \" + name + \" has already been defined.\", typeDefBase);", "-      return null;", "-    }", "+  protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String relName, String qualifiedTypeName, ", "+                                             Data enclosing) {", "+    assert (enclosing instanceof SymbolData) || (enclosing instanceof MethodData);", "+    /* IMPORTANT: this is defineSymbolData for inner classes! */", "+//    if (qualifiedTypeName.startsWith(\"RefInnerClass\")) {", "+    System.err.println(\"*** defineInnerSymbolData called for '\" + relName + \" with full name \" + qualifiedTypeName + ", "+                       \"' in '\" + enclosing + \"'\");", "+//    }", "+    SymbolData sd = defineSymbolData(typeDefBase, qualifiedTypeName /*, _classesInThisFile*/); ", "+    if (sd == null) System.err.println(\"defineSymbolData failed for \" + qualifiedTypeName);", "+    assert sd != null;", "+    // Set fields of sd that are required for innerSymbols", "+", "+    sd.setOuterData(enclosing);", "-    // create the LinkedList for the SymbolDatas of the interfaces", "-    LinkedList<SymbolData> interfaces = new LinkedList<SymbolData>();", "-    SymbolData tempSd;", "-    ReferenceType[] rts = typeDefBase.getInterfaces();", "-    for (int i = 0; i < rts.length; i++) {", "-      SourceInfo si = rts[i].getSourceInfo();", "-      String tempName = rts[i].getName();", "-      tempSd = getSymbolData(tempName, si, false, false, false);", "-      ", "-      if (tempSd != null) { interfaces.addLast(tempSd); }", "-      ", "-      else if (enclosing instanceof SymbolData) {", "-        // Check to see if this is an inner class referencing an inner interface", "-        tempSd = enclosing.getInnerClassOrInterface(tempName);", "-        if (tempSd == null) {", "-          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "-          String qualifiedTempName = qualifyingPart + \".\" + tempName;", "-          // Should we introduce addInnerInterfaceSymbol ?", "-          tempSd = new SymbolData(qualifiedTempName);", "-          tempSd.setInterface(true);", "-          enclosing.getSymbolData().addInnerInterface(tempSd); //interfaces can only be defined in symbol datas", "-          tempSd.setOuterData(enclosing);", "-//          System.err.println(\"Creating inner interface continuation for \" + qualifiedTempName + \" at LLV: 1042\");", "-          continuations.put(qualifiedTempName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));          ", "-        }", "-        interfaces.addLast(tempSd);", "+//    if (enclosing instanceof SymbolData) { // sd is an inner class or interface of an enclosing class (not a method)", "+    if (sd.isInterface()) {", "+//      assert enclosing instanceof SymbolData;", "+//      assert enclosing.getName().equals(_enclosingClassName):", "+      ((SymbolData) enclosing).addInnerInterface(sd); ", "+    }", "+    else if (! enclosing.getName().equals(_enclosingClassName)) {  ", "+      // sd is a local class embedded in a method.  We need to add sd to  the innerclasses of _enclosingClassName", "+      if (! (enclosing instanceof MethodData))", "+        System.err.println(\"***** In defineInnerSymbolData, enclosing = \" + enclosing ", "+                             + \" but _enclosingClassName = \" + _enclosingClassName);", "+      assert enclosing instanceof MethodData;", "+      SymbolData enclosingClassSD = getQualifiedSymbolData(_enclosingClassName);", "+      assert enclosingClassSD != null;", "+      enclosingClassSD.addInnerClass(sd);", "+      enclosing.addInnerClass(sd);  // adds innerClass to list for the enclosing MethodData ", "+    }", "+    else {", "+      // sd is a non-local inner class", "+      assert enclosing.getName().equals(_enclosingClassName);", "+      enclosing.addInnerClass(sd);", "+//    _innerClassesInThisBody.remove(sd);  // a no-op if _innerClassesInThisBody is empty", "+    }", "+    return sd;", "+  }", "-      else {", "-        _addAndIgnoreError(\"Cannot resolve interface \" + rts[i].getName(), rts[i]);", "-        return null;", "-      }", "-    // create a new symbolData for this inner class or interface if not seen before", "-    if (sd == null) { ", "-      sd = new SymbolData(qualifiedTypeName);", "-      sd.setOuterData(enclosing);", "-      if (typeDefBase instanceof ClassDef) { enclosing.getSymbolData().addInnerClass(sd); }", "-      else { ", "-        enclosing.getSymbolData().addInnerInterface(sd); ", "-    //Set the package to be the current package", "-    sd.setPackage(_package);", "-    ", "-    SymbolData superClass = null;", "-    ", "-    if (typeDefBase instanceof InterfaceDef) {", "-      // Add Object as the super class of this, so that it will know it implements Object's methods.", "-      superClass = getSymbolData(\"Object\", typeDefBase.getSourceInfo(), false);", "-      sd.setInterface(true);", "-    }", "-    else if (typeDefBase instanceof ClassDef) {", "-      ClassDef cd = (ClassDef) typeDefBase;", "-      ReferenceType rt = cd.getSuperclass();", "-      String superClassName = rt.getName();", "-      superClass = getSymbolData(superClassName, rt.getSourceInfo(), false, false, false);", "-      ", "-      if (superClass == null) {  // Why is this necessary?  Forward reference to another inner class?", "-        superClass = enclosing.getInnerClassOrInterface(superClassName);", "-        if (superClass == null) {", "-          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "-          superClass = new SymbolData(qualifyingPart + \".\" + superClassName);", "-          enclosing.addInnerClass(superClass);", "-          superClass.setOuterData(enclosing);", "-//          System.err.println(\"Creating continuation for \" + superClassName + \" at LLV:1079\");", "-          continuations.put(superClassName, new Pair<SourceInfo, LanguageLevelVisitor>(rt.getSourceInfo(), this)); ", "-      }", "-      sd.setInterface(false);", "-    ", "-    else throw new RuntimeException(\"Internal Program Error: typeDefBase was not a ClassDef or InterfaceDef.\" + ", "-                                     \"  Please report this bug.\");", "-    ", "-    // get the SymbolData of the superclass which must be in the symbol table", "-    // since we visited the type in forClassDef() although it may be a continuation. ", "-    ", "-    // there is a continuation in the symbol table, update the fields", "-    sd.setMav(typeDefBase.getMav());", "-    sd.setTypeParameters(typeDefBase.getTypeParameters());", "-    sd.setSuperClass(superClass);", "-    sd.setInterfaces(interfaces);", "-    sd.setIsContinuation(false);", "-    _log.log(\"REMOVING continuation \" + sd.getName());", "-    continuations.remove(sd.getName());", "-    if (! sd.isInterface()) { LanguageLevelConverter._newSDs.put(sd, this); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ca4480080830869f4c49b33ab82314d8", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "3e22080f0d9650b7b802f9b713065e47d1a0ce19", "commitAfterChange": "1bbb44dda9ccbed1420a315a25ace5ab1cf20f80", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "   protected SymbolData addInnerSymbolData(TypeDefBase typeDefBase, String qualifiedClassName, String partialName,                                            Data enclosing, boolean isClass)", "signatureAfterChange": "   protected SymbolData addInnerSymbolData(SourceInfo si, String qualifiedTypeName, Data enclosing)", "diff": ["+  // Creates a continuation for an inner class or interface", "+  protected SymbolData addInnerSymbolData(SourceInfo si, String qualifiedTypeName, Data enclosing) {", "+    SymbolData sd = new SymbolData(qualifiedTypeName); // create continuation", "+    SymbolData enclosingSD = enclosing.getSymbolData();", "+    symbolTable.put(qualifiedTypeName, sd);  // if qualifiedTypeName refers to an external inner class, this will likely fail", "+    enclosing.getSymbolData().addInnerClass(sd);", "+    sd.setOuterData(enclosingSD);", "+    continuations.put(qualifiedTypeName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));", "+//    System.err.println(\"Creating continuation for inner type \" + qualifiedTypeName);", "+    return sd;", "+  }", "-  protected SymbolData addInnerSymbolData(TypeDefBase typeDefBase, String qualifiedClassName, String partialName, ", "-                                          Data enclosing, boolean isClass) {", "-    SymbolData sd = symbolTable.get(qualifiedClassName);", "-      if (sd.getOuterData() != enclosing) {sd = null;}", "-      sd = new SymbolData(qualifiedClassName);", "-      if (isClass) {enclosing.getSymbolData().addInnerClass(sd);}", "-      else {(enclosing.getSymbolData()).addInnerInterface(sd);}", "-      tempSd = getSymbolData(rts[i].getName(), rts[i].getSourceInfo(), false, false, false);", "-      if (tempSd != null) {", "-        interfaces.addLast(tempSd);  ", "-      }", "-        //check to see if this is an inner class referencing an inner interface", "-        tempSd = enclosing.getInnerClassOrInterface(rts[i].getName());", "-          String qualifyingPart = qualifiedClassName.substring(0, qualifiedClassName.lastIndexOf(\"$\"));", "-          tempSd = new SymbolData(qualifyingPart + \"$\" + rts[i].getName());", "-          continuations.put(rts[i].getName(), new Pair<SourceInfo, LanguageLevelVisitor>(rts[i].getSourceInfo(), this));          ", "-          String qualifyingPart = qualifiedClassName.substring(0, qualifiedClassName.lastIndexOf(\"$\"));", "-          superClass = new SymbolData(qualifyingPart + \"$\" + superClassName);"]}], "num": 7395}