{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "095571c7549cb96ebd5e41edfebf7417", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c100d815bebeef1924c8c21a00d7110", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 325, "methodNumberAfterChange": 243, "signatureBeforeChange": "      private boolean containsField(Type t, final String name, final boolean requireStatic)", "signatureAfterChange": "   private boolean containsField(Type t, String name, boolean onlyStatic)", "diff": ["+  public boolean containsStaticField(Type t, String name) { return containsField(t, name, true); }", "+  private boolean containsField(Type t, String name, boolean onlyStatic) {", "+    FieldFinder<FieldReference> finder = new FieldFinder<FieldReference>(name, onlyStatic) {", "+      protected FieldReference makeFieldReference(Type t, DJField f) {", "+        return new FieldReference(f, BOTTOM) {}; // anonymous stub just used for inheritance checking", "+      }", "+    };", "+    return finder.hasMatch(t);", "+  }", "-  ", "-  private boolean containsField(Type t, final String name, final boolean requireStatic) {", "-    debug.logStart(new String[]{\"t\", \"name\", \"requireStatic\"}, wrap(t), name, requireStatic); try {", "-    ", "-    class LookupField extends TypeAbstractVisitor<Iterable<Object>> {", "-      ", "-      private boolean _includePrivate;", "-      ", "-      public LookupField(boolean includePrivate) {", "-        _includePrivate = includePrivate;", "-      }", "-      ", "-      private boolean validField(DJField f) { ", "-        return", "-          (_includePrivate || !f.accessibility().equals(Access.PRIVATE)) &&", "-          (!requireStatic || f.isStatic());", "-      }", "-      ", "-      public Iterable<Object> defaultCase(Type t) { return IterUtil.empty(); }", "-      ", "-      @Override public Iterable<Object> forArrayType(ArrayType t) {", "-        return name.equals(\"length\") ? IterUtil.singleton(null) : IterUtil.empty();", "-      }", "-      ", "-      @Override public Iterable<Object> forClassType(ClassType t) {", "-        for (DJField f : t.ofClass().declaredFields()) {", "-          if (f.declaredName().equals(name) && validField(f)) {", "-            return IterUtil.singleton(null);", "-          }", "-        }", "-        return IterUtil.empty();", "-      }", "-      ", "-    }", "-    Iterable<? extends Object> results = lookupMember(t, new LookupField(true), new LookupField(false));", "-    return !IterUtil.isEmpty(results);", "-    ", "-    } finally { debug.logEnd(); }", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b70957d6f3f00742a7bad7b4f9a4a95b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/TopLevelContext.java", "commitBeforeChange": "512658e6d0ae282068e705a86d988618e9ce9c5f", "commitAfterChange": "7d708b4318d2a7ffa9f01174e54dfcf52e139a3d", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "   @Override public ClassType typeContainingMethod(String name, TypeSystem ts) throws AmbiguousNameException", "signatureAfterChange": "   @Override public Type typeContainingMethod(String name, final TypeSystem ts)", "diff": ["-  @Override public ClassType typeContainingMethod(String name, TypeSystem ts) throws AmbiguousNameException {", "-    DJClass explicitImport = _importedMethods.get(name);", "-    ClassType result = explicitImport == null ? null : ts.makeClassType(explicitImport);", "-    if (result == null) {", "+  @Override public Type typeContainingMethod(String name, final TypeSystem ts) {", "+    Iterable<ClassType> matches;", "+    Iterable<DJClass> explicitImports = _importedMethods.matchFirst(name);", "+    if (!IterUtil.isEmpty(explicitImports)) {", "+      matches = IterUtil.mapSnapshot(explicitImports, new Lambda<DJClass, ClassType>() {", "+        public ClassType value(DJClass c) { return ts.makeClassType(c); }", "+      });", "+    }", "+    else {", "-      if (onDemandMatches.size() > 1) { throw new AmbiguousNameException(); }", "-      else if (onDemandMatches.size() == 1) { result = onDemandMatches.getFirst(); }", "-      if (result == null) {", "-        result = super.typeContainingMethod(name, ts);", "-      }", "+      matches = onDemandMatches;", "-    return result;", "+    ", "+    switch (IterUtil.sizeOf(matches, 2)) {", "+      case 0: return null;", "+      case 1: return IterUtil.first(matches);", "+      default: return new IntersectionType(matches);", "+    }"]}], "num": 6061}