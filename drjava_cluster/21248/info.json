{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5927ba74a8a2f1666511c8006097b9d0", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2fffd3f64960753ccd331a8fd6405179", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/AbstractTypeChecker.java", "commitBeforeChange": "18a9f2cc3ae6f0d537d5b99c2f47d401bf5d764e", "commitAfterChange": "1e89570173a057456dfaafaaf0fe0900c92c74a8", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": "   public Class visit(ClassAllocation node)", "signatureAfterChange": "   public Class<?> visit(ClassAllocation node)", "diff": ["-  public Class visit(ClassAllocation node) {", "+  public Class<?> visit(ClassAllocation node) {", "-      Class   ct   = ctn.acceptVisitor(this);", "-      List   largs = node.getArguments();", "+      Class<?>   ct   = ctn.acceptVisitor(this);", "+      List<Expression>   largs = node.getArguments();", "-        Iterator it = largs.iterator();", "+        Iterator<Expression> it = largs.iterator();", "-          args[i++] = ((Node)it.next()).acceptVisitor(this);", "+          args[i++] = it.next().acceptVisitor(this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4af32e9a774831d1076650bcc659addc", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/AbstractTypeChecker.java", "commitBeforeChange": "18a9f2cc3ae6f0d537d5b99c2f47d401bf5d764e", "commitAfterChange": "1e89570173a057456dfaafaaf0fe0900c92c74a8", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": "   public Class visit(SuperMethodCall node)", "signatureAfterChange": "   public Class<?> visit(SuperMethodCall node)", "diff": ["-  public Class visit(SuperMethodCall node) {", "+  public Class<?> visit(SuperMethodCall node) {", "-    List args = node.getArguments();", "+    List<Expression> args = node.getArguments();", "-      Iterator it = args.iterator();", "+      Iterator<Expression> it = args.iterator();", "-        pt[i++] = ((Node)it.next()).acceptVisitor(this);", "+        pt[i++] = it.next().acceptVisitor(this);", "-    Class c;", "+    Class<?> c;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93276063cdeb92c9cc6f8287eef1c327", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/AbstractTypeChecker.java", "commitBeforeChange": "18a9f2cc3ae6f0d537d5b99c2f47d401bf5d764e", "commitAfterChange": "1e89570173a057456dfaafaaf0fe0900c92c74a8", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": "   public Class visit(StaticMethodCall node)", "signatureAfterChange": "   public Class<?> visit(StaticMethodCall node)", "diff": ["-  public Class visit(StaticMethodCall node) {", "+  public Class<?> visit(StaticMethodCall node) {", "-    List args = node.getArguments();", "+    List<Expression> args = node.getArguments();", "-      Iterator it = args.iterator();", "+      Iterator<Expression> it = args.iterator();", "-        cargs[i++] = ((Node)it.next()).acceptVisitor(this);", "+        cargs[i++] = it.next().acceptVisitor(this);", "-    Class  c = n.acceptVisitor(this);", "+    Class<?>  c = n.acceptVisitor(this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9ecca60920fed940f503ffcc3cc0c93c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/AbstractTypeChecker.java", "commitBeforeChange": "18a9f2cc3ae6f0d537d5b99c2f47d401bf5d764e", "commitAfterChange": "1e89570173a057456dfaafaaf0fe0900c92c74a8", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "   public Class visit(FunctionCall node)", "signatureAfterChange": "   public Class<?> visit(FunctionCall node)", "diff": ["-  public Class visit(FunctionCall node) {", "+  public Class<?> visit(FunctionCall node) {", "-    List args = node.getArguments();", "+    List<Expression> args = node.getArguments();", "-      Iterator it = args.iterator();", "+      Iterator<Expression> it = args.iterator();", "-        cargs[i++] = ((Node)it.next()).acceptVisitor(this);", "+        cargs[i++] = it.next().acceptVisitor(this);", "-    Class c;", "+    Class<?> c;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c3b4f9d53d278ccaf8b5fa28e96fbfb7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tpublic Object visit(ObjectMethodCall node)", "signatureAfterChange": "     public Object visit(ObjectMethodCall node)", "diff": ["-\t */", "-\tpublic Object visit(ObjectMethodCall node) {", "-\t    // Check the receiver", "-\t    if (node.getExpression() != null) {", "-\t\tObject o = node.getExpression().acceptVisitor(this);", "-\t\tif (o != null) {", "-\t\t    if (o instanceof Expression) {", "-\t\t\tnode.setExpression((Expression)o);", "-\t\t    } else {", "-\t\t\tNode result =  new StaticMethodCall((ReferenceType)o,", "-\t\t\t\t\t\t\t    node.getMethodName(),", "-\t\t\t\t\t\t\t    node.getArguments(),", "-\t\t\t\t\t\t\t    node.getFilename(),", "-\t\t\t\t\t\t\t    node.getBeginLine(),", "-\t\t\t\t\t\t\t    node.getBeginColumn(),", "-\t\t\t\t\t\t\t    node.getEndLine(),", "-\t\t\t\t\t\t\t    node.getEndColumn());", "-\t\t\tresult.acceptVisitor(this);", "-\t\t\treturn result;", "-\t\t    }", "-\t\t}", "-\t    } else {", "-\t\tIdentifier t = new Identifier(classInfo.getName());", "-\t\tList l = new LinkedList();", "-\t\tl.add(t);", "-\t\tReferenceType rt = new ReferenceType(l);", "-\t\trt.acceptVisitor(this);", "-\t\tNode result =  new StaticMethodCall(rt,", "-\t\t\t\t\t\t    node.getMethodName(),", "-\t\t\t\t\t\t    node.getArguments(),", "-\t\t\t\t\t\t    node.getFilename(),", "-\t\t\t\t\t\t    node.getBeginLine(),", "-\t\t\t\t\t\t    node.getBeginColumn(),", "-\t\t\t\t\t\t    node.getEndLine(),", "-\t\t\t\t\t\t    node.getEndColumn());", "-\t\tresult.acceptVisitor(this);", "-\t\treturn result;", "-\t    }", "-", "-\t    ClassInfo c = NodeProperties.getClassInfo(node.getExpression());", "-", "-\t    if (!c.isArray() || (c.isArray() && !node.getMethodName().equals(\"clone\"))) {", "-\t\t// Do the type checking of the arguments", "-\t\tClassInfo[] cargs = new ClassInfo[0];", "-\t\tList args = node.getArguments();", "-\t\tif (args != null) {", "-\t\t    checkList(args, \"malformed.argument\", node);", "-", "-\t\t    cargs = new ClassInfo[args.size()];", "-\t\t    ListIterator it = args.listIterator();", "-\t\t    int i  = 0;", "-\t\t    while (it.hasNext()) {", "-\t\t\tcargs[i++] = NodeProperties.getClassInfo((Node)it.next());", "-\t\t    }", "-\t\t}", "-\t\tMethodInfo m = null;", "-\t\ttry {", "-\t\t    m = ClassInfoUtilities.lookupMethod(c, node.getMethodName(), cargs);", "-\t\t} catch (NoSuchMethodException e) {", "-\t\t    throw new CatchedExceptionError(e, node);", "-\t\t}", "-", "-\t\t// Set the node properties", "-\t\tnode.setProperty(NodeProperties.TYPE, m.getReturnType());", "-\t    } else {", "-\t\tif (!node.getMethodName().equals(\"clone\") ||", "-\t\t    node.getArguments() != null) {", "-\t\t    String s0 = \"clone\";", "-\t\t    String s1 = c.getComponentType().getName() + \" array\";", "-\t\t    node.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t     new String[] { s0, s1 });", "-\t\t    throw new ExecutionError(\"no.such.method\", node);", "-\t\t}", "-\t\tnode.setProperty(NodeProperties.TYPE, new JavaClassInfo(Object.class));", "-\t    }", "-\t    return null;", "-\t}", "+     */", "+    public Object visit(ObjectMethodCall node) {", "+      // Check the receiver", "+      if (node.getExpression() != null) {", "+        Object o = node.getExpression().acceptVisitor(this);", "+        if (o != null) {", "+          if (o instanceof Expression) {", "+            node.setExpression((Expression)o);", "+          } else {", "+            Node result =  new StaticMethodCall((ReferenceType)o,", "+                                                node.getMethodName(),", "+                                                node.getArguments(),", "+                                                node.getFilename(),", "+                                                node.getBeginLine(),", "+                                                node.getBeginColumn(),", "+                                                node.getEndLine(),", "+                                                node.getEndColumn()", "+          );", "+            ", "+            result.acceptVisitor(this);", "+            return result;", "+          }", "+        }", "+      } else {", "+        Identifier t = new Identifier(classInfo.getName());", "+        List<IdentifierToken> l = new LinkedList<IdentifierToken>();", "+        l.add(t);", "+        ReferenceType rt = new ReferenceType(l);", "+        rt.acceptVisitor(this);", "+        Node result =  new StaticMethodCall(rt,", "+                                            node.getMethodName(),", "+                                            node.getArguments(),", "+                                            node.getFilename(),", "+                                            node.getBeginLine(),", "+                                            node.getBeginColumn(),", "+                                            node.getEndLine(),", "+                                            node.getEndColumn()", "+        );", "+        result.acceptVisitor(this);", "+        return result;", "+      }", "+      ", "+      ClassInfo c = NodeProperties.getClassInfo(node.getExpression());", "+      ", "+      if (!c.isArray() || (c.isArray() && !node.getMethodName().equals(\"clone\"))) {", "+        // Do the type checking of the arguments", "+        ClassInfo[] cargs = new ClassInfo[0];", "+        List<Expression> args = node.getArguments();", "+        if (args != null) {", "+          checkList(args, \"malformed.argument\", node);", "+          ", "+          cargs = new ClassInfo[args.size()];", "+          ListIterator<Expression> it = args.listIterator();", "+          int i  = 0;", "+          while (it.hasNext()) {", "+            cargs[i++] = NodeProperties.getClassInfo(it.next());", "+          }", "+        }", "+        MethodInfo m = null;", "+        try {", "+          m = ClassInfoUtilities.lookupMethod(c, node.getMethodName(), cargs);", "+        } catch (NoSuchMethodException e) {", "+          throw new CatchedExceptionError(e, node);", "+        }", "+        ", "+        // Set the node properties", "+        node.setProperty(NodeProperties.TYPE, m.getReturnType());", "+      } else {", "+        if (!node.getMethodName().equals(\"clone\") ||", "+            node.getArguments() != null) {", "+          String s0 = \"clone\";", "+          String s1 = c.getComponentType().getName() + \" array\";", "+          node.setProperty(NodeProperties.ERROR_STRINGS,", "+                           new String[] { s0, s1 });", "+          throw new ExecutionError(\"no.such.method\", node);", "+        }", "+        node.setProperty(NodeProperties.TYPE, new JavaClassInfo(Object.class));", "+      }", "+      return null;", "+    }"]}], "num": 21248}