{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "49900d76ffe4de6fbc469973b07722e7", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "021f38f7af0aca59fe9f9a37b21148fb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/classinfo/TreeClassInfo.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": "         public Object visit(ConstructorDeclaration node)", "signatureAfterChange": "     public Void visit(ConstructorDeclaration node)", "diff": ["+    public Void visit(ConstructorDeclaration node) {", "+      if (node.getConstructorInvocation() == null) {", "+        ConstructorInvocation ci;", "+        ci = new ConstructorInvocation(null, null, true);", "+        node.setConstructorInvocation(ci);", "+      }", "+      ", "+      // Add the outer parameter if needed", "+      ClassInfo dc = getDeclaringClass();", "+      if (!classTree.hasProperty(TREE_VISITED)) {", "+        if (dc != null && !Modifier.isStatic(getModifiers())) {", "+          ReferenceType t = new ReferenceType(dc.getName());", "+          node.getParameters().add(0,", "+                                   new FormalParameter(false, t, \"param$0\"));", "+      }", "+      ", "+      if (dc != null && !Modifier.isStatic(getModifiers())) {", "+        // Add the initialization of the outer instance reference", "+        SimpleAssignExpression sae;", "+        List<IdentifierToken> l1 = new LinkedList<IdentifierToken>();", "+        l1.add(new Identifier(\"this$\" + getNestingLevel()));", "+        List<IdentifierToken> l2 = new LinkedList<IdentifierToken>();", "+        l2.add(new Identifier(\"param$0\"));", "+        sae = new SimpleAssignExpression", "+          (new QualifiedName(l1),", "+           new QualifiedName(l2));", "+        node.getStatements().add(0, sae);", "+      }", "+      ", "+      constructors.add(new TreeConstructorInfo(node,", "+                                               classFinder,", "+                                               TreeClassInfo.this));", "+      return null;", "-         */", "-        public Object visit(ConstructorDeclaration node) {", "-\t    if (node.getConstructorInvocation() == null) {", "-\t\tConstructorInvocation ci;", "-\t\tci = new ConstructorInvocation(null, null, true);", "-\t\tnode.setConstructorInvocation(ci);", "-\t    }", "-", "-\t    // Add the outer parameter if needed", "-\t    ClassInfo dc = getDeclaringClass();", "-\t    if (!classTree.hasProperty(TREE_VISITED)) {", "-\t\tif (dc != null && !Modifier.isStatic(getModifiers())) {", "-\t\t    ReferenceType t = new ReferenceType(dc.getName());", "-\t\t    node.getParameters().add(0,", "-\t\t\t\t\t     new FormalParameter(false, t, \"param$0\"));", "-\t\t}", "-\t    }", "-", "-\t    if (dc != null && !Modifier.isStatic(getModifiers())) {", "-\t\t// Add the initialization of the outer instance reference", "-\t\tSimpleAssignExpression sae;", "-\t\tList l1 = new LinkedList();", "-\t\tl1.add(new Identifier(\"this$\" + getNestingLevel()));", "-\t\tList l2 = new LinkedList();", "-\t\tl2.add(new Identifier(\"param$0\"));", "-\t\tsae = new SimpleAssignExpression", "-\t\t    (new QualifiedName(l1),", "-\t\t     new QualifiedName(l2));", "-\t\tnode.getStatements().add(0, sae);", "-\t    }", "-", "-\t    constructors.add(new TreeConstructorInfo(node,", "-\t\t\t\t\t\t     classFinder,", "-\t\t\t\t\t\t     TreeClassInfo.this));", "-            return null;", "-        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3d6e73becf2611801ebf78605e2fc07", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 76, "signatureBeforeChange": " \tpublic Object visit(FieldDeclaration node)", "signatureAfterChange": "     public Void visit(FieldDeclaration node)", "diff": ["-\t */", "-\tpublic Object visit(FieldDeclaration node) {", "-\t    FieldInfo fi = classInfo.getField(node);", "-\t    int       af = node.getAccessFlags();", "-\t    String    rt = fi.getType().getName();", "-\t    String    fn = node.getName();", "-", "-\t    if (isInterface) {", "-\t\tif (Modifier.isPrivate(af) || Modifier.isProtected(af)) {", "-\t\t    node.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t     new String[] { fn, classInfo.getName() });", "-\t\t    throw new ExecutionError(\"interface.field.modifier\", node);", "-\t\t}", "-\t\taf |= Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL;", "-\t    }", "-", "-\t    Expression init = node.getInitializer();", "-\t    if (init != null) {", "-\t\tif ((init instanceof Literal) &&", "-\t\t    Modifier.isFinal(af) &&", "-\t\t    Modifier.isStatic(af)) {", "-\t\t    if (init instanceof IntegerLiteral) {", "-\t\t\tInteger val = (Integer)((Literal)init).getValue();", "-\t\t\tif (rt.equals(\"byte\")) {", "-\t\t\t    if (val.intValue() != val.byteValue()) {", "-\t\t\t\tthrow new ExecutionError(\"invalid.constant\", node);", "-\t\t\t    }", "-\t\t\t    classFactory.addConstantIntField", "-\t\t\t\t(af, rt, fn, val);", "-\t\t\t} else if (rt.equals(\"short\")) {", "-\t\t\t    if (val.intValue() != val.shortValue()) {", "-\t\t\t\tthrow new ExecutionError(\"invalid.constant\", node);", "-\t\t\t    }", "-\t\t\t    classFactory.addConstantIntField", "-\t\t\t\t(af, rt, fn, val);", "-\t\t\t} else if (rt.equals(\"int\")) {", "-\t\t\t    classFactory.addConstantIntField", "-\t\t\t\t(af, rt, fn, val);", "-\t\t\t} else if (rt.equals(\"long\")) {", "-\t\t\t    classFactory.addConstantLongField", "-\t\t\t\t(af, rt, fn, new Long(val.longValue()));", "-\t\t\t} else if (rt.equals(\"float\")) {", "-\t\t\t    classFactory.addConstantFloatField", "-\t\t\t\t(af, rt, fn, new Float(val.floatValue()));", "-\t\t\t} else if (rt.equals(\"double\")) {", "-\t\t\t    classFactory.addConstantDoubleField", "-\t\t\t\t(af, rt, fn, new Double(val.doubleValue()));", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"invalid.constant\", node);", "-\t\t\t}", "-\t\t    } else if (init instanceof LongLiteral) {", "-\t\t\tLong val = (Long)((Literal)init).getValue();", "-\t\t\tif (rt.equals(\"long\")) {", "-\t\t\t    classFactory.addConstantLongField", "-\t\t\t\t(af, rt, fn, new Long(val.longValue()));", "-\t\t\t} else if (rt.equals(\"float\")) {", "-\t\t\t    classFactory.addConstantFloatField", "-\t\t\t\t(af, rt, fn, new Float(val.floatValue()));", "-\t\t\t} else if (rt.equals(\"double\")) {", "-\t\t\t    classFactory.addConstantDoubleField", "-\t\t\t\t(af, rt, fn, new Double(val.doubleValue()));", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"invalid.constant\", node);", "-\t\t\t}", "-\t\t    } else if (init instanceof FloatLiteral) {", "-\t\t\tFloat val = (Float)((Literal)init).getValue();", "-\t\t\tif (rt.equals(\"float\")) {", "-\t\t\t    classFactory.addConstantFloatField", "-\t\t\t\t(af, rt, fn, new Float(val.floatValue()));", "-\t\t\t} else if (rt.equals(\"double\")) {", "-\t\t\t    classFactory.addConstantDoubleField", "-\t\t\t\t(af, rt, fn, new Double(val.doubleValue()));", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"invalid.constant\", node);", "-\t\t\t}", "-\t\t    } else if (init instanceof DoubleLiteral) {", "-\t\t\tDouble val = (Double)((Literal)init).getValue();", "-\t\t\tif (rt.equals(\"double\")) {", "-\t\t\t    classFactory.addConstantDoubleField", "-\t\t\t\t(af, rt, fn, new Double(val.doubleValue()));", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"invalid.constant\", node);", "-\t\t\t}", "-\t\t\t", "-\t\t    } else if (init instanceof BooleanLiteral) {", "-\t\t\tBoolean val = (Boolean)((Literal)init).getValue();", "-\t\t\tif (rt.equals(\"boolean\")) {", "-\t\t\t    classFactory.addConstantBooleanField", "-\t\t\t\t(af, rt, fn, val);", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"invalid.constant\", node);", "-\t\t\t}", "-\t\t    } else {", "-\t\t\tString val = (String)((Literal)init).getValue();", "-\t\t\tclassFactory.addConstantStringField(af, rt, fn, val);", "-\t\t    }", "-\t\t} else {", "-\t\t    classFactory.addField(af & ~Modifier.FINAL, rt, fn);", "-", "-\t\t    Expression var = null;", "-\t\t    if (Modifier.isStatic(af)) {", "-\t\t\tReferenceType typ = new ReferenceType(classInfo.getName());", "-\t\t\tvar = new StaticFieldAccess(typ, fn);", "-\t\t    } else {", "-\t\t\tIdentifier t = new Identifier(\"this\");", "-\t\t\tList  l  = new LinkedList();", "-\t\t\tl.add(t);", "-\t\t\tvar = new QualifiedName(l);", "-\t\t\tvar = new ObjectFieldAccess(var, fn);", "-\t\t    }", "-\t\t    Expression exp = new SimpleAssignExpression(var, init);", "-\t\t    if (Modifier.isStatic(af)) {", "-\t\t\taddToClassInitializer(exp);", "-\t\t    } else {", "-\t\t\texp.setProperty(NodeProperties.INSTANCE_INITIALIZER, null);", "-\t\t\taddToInstanceInitializer(exp);", "-\t\t    }", "-\t\t}", "-\t    } else {", "-\t\tclassFactory.addField(af, rt, fn);", "-\t    }", "-\t    return null;", "-\t}", "+     */", "+    public Void visit(FieldDeclaration node) {", "+      FieldInfo fi = classInfo.getField(node);", "+      int       af = node.getAccessFlags();", "+      String    rt = fi.getType().getName();", "+      String    fn = node.getName();", "+      ", "+      if (isInterface) {", "+        if (Modifier.isPrivate(af) || Modifier.isProtected(af)) {", "+          node.setProperty(NodeProperties.ERROR_STRINGS,", "+                           new String[] { fn, classInfo.getName() });", "+          throw new ExecutionError(\"interface.field.modifier\", node);", "+        }", "+        af |= Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL;", "+      }", "+      ", "+      Expression init = node.getInitializer();", "+      if (init != null) {", "+        if ((init instanceof Literal) &&", "+            Modifier.isFinal(af) &&", "+            Modifier.isStatic(af)) {", "+          if (init instanceof IntegerLiteral) {", "+            Integer val = (Integer)((Literal)init).getValue();", "+            if (rt.equals(\"byte\")) {", "+              if (val.intValue() != val.byteValue()) {", "+                throw new ExecutionError(\"invalid.constant\", node);", "+              }", "+              classFactory.addConstantIntField", "+                (af, rt, fn, val);", "+            } else if (rt.equals(\"short\")) {", "+              if (val.intValue() != val.shortValue()) {", "+                throw new ExecutionError(\"invalid.constant\", node);", "+              }", "+              classFactory.addConstantIntField", "+                (af, rt, fn, val);", "+            } else if (rt.equals(\"int\")) {", "+              classFactory.addConstantIntField", "+                (af, rt, fn, val);", "+            } else if (rt.equals(\"long\")) {", "+              classFactory.addConstantLongField", "+                (af, rt, fn, new Long(val.longValue()));", "+            } else if (rt.equals(\"float\")) {", "+              classFactory.addConstantFloatField", "+                (af, rt, fn, new Float(val.floatValue()));", "+            } else if (rt.equals(\"double\")) {", "+              classFactory.addConstantDoubleField", "+                (af, rt, fn, new Double(val.doubleValue()));", "+            } else {", "+              throw new ExecutionError(\"invalid.constant\", node);", "+            }", "+          } else if (init instanceof LongLiteral) {", "+            Long val = (Long)((Literal)init).getValue();", "+            if (rt.equals(\"long\")) {", "+              classFactory.addConstantLongField", "+                (af, rt, fn, new Long(val.longValue()));", "+            } else if (rt.equals(\"float\")) {", "+              classFactory.addConstantFloatField", "+                (af, rt, fn, new Float(val.floatValue()));", "+            } else if (rt.equals(\"double\")) {", "+              classFactory.addConstantDoubleField", "+                (af, rt, fn, new Double(val.doubleValue()));", "+            } else {", "+              throw new ExecutionError(\"invalid.constant\", node);", "+            }", "+          } else if (init instanceof FloatLiteral) {", "+            Float val = (Float)((Literal)init).getValue();", "+            if (rt.equals(\"float\")) {", "+              classFactory.addConstantFloatField", "+                (af, rt, fn, new Float(val.floatValue()));", "+            } else if (rt.equals(\"double\")) {", "+              classFactory.addConstantDoubleField", "+                (af, rt, fn, new Double(val.doubleValue()));", "+            } else {", "+              throw new ExecutionError(\"invalid.constant\", node);", "+            }", "+          } else if (init instanceof DoubleLiteral) {", "+            Double val = (Double)((Literal)init).getValue();", "+            if (rt.equals(\"double\")) {", "+              classFactory.addConstantDoubleField", "+                (af, rt, fn, new Double(val.doubleValue()));", "+            } else {", "+              throw new ExecutionError(\"invalid.constant\", node);", "+            }", "+            ", "+          } else if (init instanceof BooleanLiteral) {", "+            Boolean val = (Boolean)((Literal)init).getValue();", "+            if (rt.equals(\"boolean\")) {", "+              classFactory.addConstantBooleanField", "+                (af, rt, fn, val);", "+            } else {", "+              throw new ExecutionError(\"invalid.constant\", node);", "+            }", "+          } else {", "+            String val = (String)((Literal)init).getValue();", "+            classFactory.addConstantStringField(af, rt, fn, val);", "+          }", "+        } else {", "+          classFactory.addField(af & ~Modifier.FINAL, rt, fn);", "+          ", "+          Expression var = null;", "+          if (Modifier.isStatic(af)) {", "+            ReferenceType typ = new ReferenceType(classInfo.getName());", "+            var = new StaticFieldAccess(typ, fn);", "+          } else {", "+            Identifier t = new Identifier(\"this\");", "+            List<IdentifierToken> l = new LinkedList<IdentifierToken>();", "+            l.add(t);", "+            var = new QualifiedName(l);", "+            var = new ObjectFieldAccess(var, fn);", "+          }", "+          Expression exp = new SimpleAssignExpression(var, init);", "+          if (Modifier.isStatic(af)) {", "+            addToClassInitializer(exp);", "+          } else {", "+            exp.setProperty(NodeProperties.INSTANCE_INITIALIZER, null);", "+            addToInstanceInitializer(exp);", "+          }", "+        }", "+      } else {", "+        classFactory.addField(af, rt, fn);", "+      }", "+      return null;", "+    }"]}], "num": 8655}