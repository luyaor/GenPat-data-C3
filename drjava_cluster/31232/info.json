{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9e93a4844159810bc24510a2cc5e7fe8", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "871773d72b59cc8f5e7d88f4c795fe4c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic Object visit(StaticMethodCall node)", "signatureAfterChange": "     public Object visit(StaticMethodCall node)", "diff": ["-\t */", "-\tpublic Object visit(StaticMethodCall node) {", "-\t    // Do the type checking of the arguments", "-\t    List args = node.getArguments();", "-\t    ClassInfo[] cargs = new ClassInfo[0];", "-\t    if (args != null) {", "-\t\tcheckList(args, \"malformed.argument\", node);", "-", "-\t\tcargs = new ClassInfo[args.size()];", "-\t\tListIterator it = args.listIterator();", "-\t\tint      i  = 0;", "-\t\twhile (it.hasNext()) {", "-\t\t    cargs[i++] = NodeProperties.getClassInfo((Node)it.next());", "-\t\t}", "-\t    }", "-\t    MethodInfo m = null;", "-\t    Node       n = node.getMethodType();", "-\t    ClassInfo  c = NodeProperties.getClassInfo(n);", "-\t    try {", "-\t\tm = ClassInfoUtilities.lookupMethod(c, node.getMethodName(), cargs);", "-\t    } catch (NoSuchMethodException e) {", "-\t\tif (n.getBeginLine() == n.getEndLine() &&", "-\t\t    n.getBeginColumn() == n.getEndLine()) {", "-\t\t    // Look for a method in the outerclasses", "-\t\t    try {", "-\t\t\tm = ClassInfoUtilities.lookupOuterMethod(c,", "-\t\t\t\t\t\t\t\t node.getMethodName(),", "-\t\t\t\t\t\t\t\t cargs);", "-\t\t    } catch (NoSuchMethodException ex) {", "-\t\t\tthrow new CatchedExceptionError(ex, node);", "-\t\t    }", "-\t\t} else {", "-\t\t    throw new CatchedExceptionError(e, node);", "-\t\t}", "-\t\tthrow new CatchedExceptionError(e, node);", "-\t    }", "-", "-\t    // Set the node properties", "-\t    node.setProperty(NodeProperties.TYPE, m.getReturnType());", "-\t    return null;", "-\t}", "+     */", "+    public Object visit(StaticMethodCall node) {", "+      // Do the type checking of the arguments", "+      List<Expression> args = node.getArguments();", "+      ClassInfo[] cargs = new ClassInfo[0];", "+      if (args != null) {", "+        checkList(args, \"malformed.argument\", node);", "+        ", "+        cargs = new ClassInfo[args.size()];", "+        ListIterator<Expression> it = args.listIterator();", "+        int      i  = 0;", "+        while (it.hasNext()) {", "+          cargs[i++] = NodeProperties.getClassInfo(it.next());", "+        }", "+      }", "+      MethodInfo m = null;", "+      Node       n = node.getMethodType();", "+      ClassInfo  c = NodeProperties.getClassInfo(n);", "+      try {", "+        m = ClassInfoUtilities.lookupMethod(c, node.getMethodName(), cargs);", "+      } catch (NoSuchMethodException e) {", "+        SourceInfo si = n.getSourceInfo();", "+        if (si.getStartLine() == si.getEndLine() &&", "+            si.getStartColumn() == si.getEndLine()) {", "+          // Look for a method in the outerclasses", "+          try {", "+            m = ClassInfoUtilities.lookupOuterMethod(c,", "+                                                     node.getMethodName(),", "+                                                     cargs);", "+          } catch (NoSuchMethodException ex) {", "+            throw new CatchedExceptionError(ex, node);", "+          }", "+        } else {", "+          throw new CatchedExceptionError(e, node);", "+        }", "+        throw new CatchedExceptionError(e, node);", "+      }", "+      ", "+      // Set the node properties", "+      node.setProperty(NodeProperties.TYPE, m.getReturnType());", "+      return null;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a7ee54182d1941999b6f66714cf7f681", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/parser/wrapper/ParserTest.java", "commitBeforeChange": "f5712545338ec09fefb321f9e27396d8fb91a646", "commitAfterChange": "1676fcce81c19c5d647ee9a67867801bec666091", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "      public void verifyErrorLocation(ParseException ex,                                   int startLine, int startColumn,                                    int endLine, int endColumn)", "signatureAfterChange": "      public void verifyErrorLocation(ParseException ex,                                   int startLine, int startColumn,                                    int endLine, int endColumn)", "diff": ["-    CustomParseException custom = CustomParseException.makeCustom(ex);", "-    assertEquals(\"Wrong begin line of error\", startLine, custom.getBeginLine());", "-    assertEquals(\"Wrong begin column of error\", startColumn, custom.getBeginColumn());", "-    assertEquals(\"Wrong end line of error\", endLine, custom.getEndLine());", "-    assertEquals(\"Wrong end column of error\", endColumn, custom.getEndColumn());", "+    SourceInfo si = new ParseError(ex, (File) null).getSourceInfo();", "+    assertEquals(\"Wrong begin line of error\", startLine, si.getStartLine());", "+    assertEquals(\"Wrong begin column of error\", startColumn, si.getStartColumn());", "+    assertEquals(\"Wrong end line of error\", endLine, si.getEndLine());", "+    assertEquals(\"Wrong end column of error\", endColumn, si.getEndColumn());"]}], "num": 31232}