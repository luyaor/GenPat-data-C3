{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b491fb79230998d1ebc7885f39534413", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "667a213d0d7b8c93d6470bd9240823d5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/DynamicJavaAdapter.java", "commitBeforeChange": "405bec7d97445f0020939e0560dc10393430aac1", "commitAfterChange": "070ce5905e33fc289f79bfc0035862d6493d03f5", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 28, "signatureBeforeChange": "   public TypeChecker makeTypeChecker(Context context)", "signatureAfterChange": "   public TypeChecker makeTypeChecker(Context context)", "diff": ["-    return new TypeChecker(context) {", "-      /**", "-       * Overrides TypeChecker's default behavior on an InstanceOfExpression,", "-       * since it caused a NullPointerException on \"null instanceof Object\"", "-       * @param node the node to visit", "-       */", "-      public Object visit(InstanceOfExpression node) {", "-        node.getReferenceType().acceptVisitor(this);", "-        ", "-        // The expression must not have a primitive type", "-        Class c = (Class) node.getExpression().acceptVisitor(this);", "-        if ((c != null) && c.isPrimitive()) {", "-          throw new ExecutionError(\"left.expression\", node);", "-        }", "-        ", "-        // Set the type property", "-        node.setProperty(NodeProperties.TYPE, boolean.class);", "-        return boolean.class;", "-      }", "-      ", "-      public Object visit(MethodDeclaration node) {", "-        super.visit(node);", "-        Class c = (Class)node.getProperty(NodeProperties.TYPE);", "-        BlockStatement bs = node.getBody();", "-        List l = bs.getStatements();", "-        Iterator iter = l.iterator();", "-        boolean foundCorrectType = false;", "-        while(iter.hasNext()) {", "-          Statement s = (Statement)iter.next();", "-          if (s instanceof ReturnStatement) {", "-            Class returnExpClass;", "-            Expression expression = ((ReturnStatement)s).getExpression();", "-            if (expression == null) {", "-              returnExpClass = null;", "-            }", "-            else {", "-              returnExpClass = (Class)expression.acceptVisitor(this);", "-            }", "-            // will void return type mean c is null?", "-            if (c == null) {", "-              if (returnExpClass != null) {", "-                // returning a value in a void method", "-                throw new ExecutionError(\"assignment.types\", node);", "-              }", "-            }", "-            else if (returnExpClass == null) {", "-              // returning nothing in a non-void method", "-                throw new ExecutionError(\"assignment.types\", node);    ", "-            }", "-            else if (!c.isAssignableFrom(returnExpClass)) {", "-              // returning an unassignable type", "-              throw new ExecutionError(\"assignment.types\", node);", "-            }", "-            else {", "-              // returning an assignable type", "-              foundCorrectType = true;", "-            }", "-          }", "-        }", "-        if (c != null) {", "-          if (!foundCorrectType) {", "-            // we were supposed to return a type, but did not", "-            throw new ExecutionError(\"assignment.types\", node);", "-          }", "-        }", "-        return null;", "-      }", "-      ", "-      public Object visit(ReturnStatement node) {", "-        Expression e = node.getExpression();", "-        if (e != null) {", "-          return e.acceptVisitor(this);", "-        }", "-        return null;", "-      }     ", "-    };", "+    return new TypeCheckerExtension(context);      "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9286e778acc035e5a1a77a076996d018", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/JLSTypeSystem.java", "commitBeforeChange": "80debf5b9716524c576a71fc4929233c9637cd68", "commitAfterChange": "0dc6c4e6c51f7a1991368187e63e0eff0d7150ef", "methodNumberBeforeChange": 102, "methodNumberAfterChange": 108, "signatureBeforeChange": "      private Type join(final Iterable<? extends Type> ts, final PrecomputedRecursionStack<Set<Type>, Wildcard> joinStack)", "signatureAfterChange": "      private Type join(Iterable<? extends Type> ts, final PrecomputedRecursionStack<Set<Type>, Wildcard> joinStack)", "diff": ["-  private Type join(final Iterable<? extends Type> ts, final PrecomputedRecursionStack<Set<Type>, Wildcard> joinStack) {", "+  private Type join(Iterable<? extends Type> ts, final PrecomputedRecursionStack<Set<Type>, Wildcard> joinStack) {", "+    if (_packCaptureVars) {", "+      ts = IterUtil.mapSnapshot(ts, new Lambda<Type, Type>() {", "+        public Type value(Type t) {", "+          while (t instanceof VariableType && ((VariableType) t).symbol().generated()) {", "+            t = ((VariableType) t).symbol().upperBound();", "+          }", "+          return t;", "+        }", "+      });", "+    }", "-        Set<Type> erasedTypes = IterUtil.first(ts).apply(new ErasedSuperAccumulator()).result();", "-        for (Type t : IterUtil.skipFirst(ts)) {", "-          erasedTypes.retainAll(t.apply(new ErasedSuperAccumulator()).result());", "+        boolean hasNonReference = false;", "+        boolean hasReference = false;", "+        for (Type t : ts) {", "+          if (isReference(t)) { hasReference = true; }", "+          else { hasNonReference = true; }", "-        List<Type> minimalSupers = minList(erasedTypes, new Subtyper());", "-        Iterable<Type> conjuncts = mapSnapshot(minimalSupers, new Lambda<Type, Type>() {", "-          public Type value(Type erasedT) {", "-            if (erasedT instanceof RawClassType) {", "-              TypeArgumentMerger merger = new TypeArgumentMerger((RawClassType) erasedT);", "-              IterUtil.run(ts, asRunnable(merger));", "-              return merger.result(joinStack);", "-            }", "-            else { return erasedT; }", "+        if (hasNonReference && hasReference) { return TOP; }", "+        else {", "+          final Set<Type> toJoin = CollectUtil.asSet(filter(ts, bindFirst(LambdaUtil.NOT_EQUAL, NULL)));", "+          switch (toJoin.size()) {", "+            case 0: return NULL;", "+            case 1: return IterUtil.first(toJoin);", "+            default:", "+              Set<Type> erasedTypes = IterUtil.first(toJoin).apply(new ErasedSuperAccumulator()).result();", "+              for (Type t : IterUtil.skipFirst(toJoin)) {", "+                erasedTypes.retainAll(t.apply(new ErasedSuperAccumulator()).result());", "+              }", "+              List<Type> minimalSupers = minList(erasedTypes, new Subtyper());", "+              Iterable<Type> conjuncts = mapSnapshot(minimalSupers, new Lambda<Type, Type>() {", "+                public Type value(Type erasedT) {", "+                  if (erasedT instanceof RawClassType) {", "+                    TypeArgumentMerger merger = new TypeArgumentMerger((RawClassType) erasedT);", "+                    IterUtil.run(toJoin, asRunnable(merger));", "+                    return merger.result(joinStack);", "+                  }", "+                  else { return erasedT; }", "+                }", "+              });", "+              return meet(conjuncts);", "-        });", "-        return meet(conjuncts);", "+        }"]}], "num": 23384}