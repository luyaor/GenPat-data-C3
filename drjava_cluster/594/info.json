{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5535f61709ff10e760b461671d2ef02a", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3ff6188fb5dbc33b416728fe8c1126d2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/newjvm/SlaveJVMRunner.java", "commitBeforeChange": "3ae33096a45a4dc4990b95b1565bd0aeaf9084da", "commitAfterChange": "e69a4c60c625d52f9ba6a18669f0f6846846e463", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "   public static void main(String[] args)", "signatureAfterChange": "   public synchronized static void main(String[] args)", "diff": ["-  public static void main(String[] args) {", "-    ", "-    _log.log(\"Slave JVM has started with args \" + edu.rice.cs.util.StringOps.toString(args));", "+  public synchronized static void main(String[] args) {", "+        ", "+      _main = Thread.currentThread();", "-      // if we have a remote classloader to use", "-      if (args.length == 3) {", "-        //get the classloader", "-        IRemoteClassLoader remoteLoader = null;", "-        FileInputStream fstream = new FileInputStream(args[2]);", "-        ObjectInputStream ostream = new ObjectInputStream(new BufferedInputStream(fstream));", "-        _log.log(\"Slave JVM reading remote loader object\");", "-        remoteLoader = (IRemoteClassLoader) ostream.readObject();", "-        _log.log(\"remote loader read\");", "-        if (ClassLoader.getSystemClassLoader() instanceof CustomSystemClassLoader) {", "-          CustomSystemClassLoader loader = (CustomSystemClassLoader) ClassLoader.getSystemClassLoader();", "-          loader.setMasterRemote(remoteLoader);", "-        }", "-        _log.log(\"remote loader installed\");", "-      }", "-", "+//      // Loading the class that intermittently hangs first readObject(...) call below", "+//      Class psi = Class.forName(\"java.net.PlainSocketImpl\");", "+      ", "-      _log.log(\"Slave JVM reading the remote master object\");", "-      FileInputStream fstream = new FileInputStream(args[0]);", "-      ObjectInputStream ostream = new ObjectInputStream(new BufferedInputStream(fstream));", "-      MasterRemote master = (MasterRemote) ostream.readObject();", "-      _log.log(\"remote master read\");", "+      final FileInputStream fstream = new FileInputStream(args[0]);", "+      final ObjectInputStream ostream = new ObjectInputStream(new BufferedInputStream(fstream));", "+      ", "+      _log.log(\"Slave JVM reading master remote stub from file \" + args[0] + \" with \" + ", "+                 fstream.getChannel().size() + \" bytes\");", "+      ", "+/* The following code currently breaks unit tests (and perhaps DrJava) when it detects the hanging", "+ * of readObject(...).  It can be commented back if the calling code is revised to handle this form", "+ * of exit. */", "+      ", "+//      Thread timeout = new Thread(\"RMI Timeout Thread\") {", "+//        public void run() {", "+//          _log.log(\"RMI timer started\");", "+//          final Object lock = new Object();", "+//          try { synchronized(lock) { lock.wait(RMI_TIMEOUT); } }", "+//          catch(InterruptedException e) { throw new UnexpectedException(e); }", "+//          // Abort starting this slave JVM if readObject has hung", "+//          if (_remoteLoader == null) {", "+//            StackTraceElement[] trace = Thread.getAllStackTraces().get(_main);", "+//            _log.log(\"DUMP of hung deserializing thread:\", trace);", "+//            System.exit(9);", "+//          }", "+//          else _log.log(this + \" TERMINATED normally\");", "+//        }", "+//      };", "+//      ", "+//      timeout.setDaemon(true);", "+//      timeout.start();", "+      ", "+//      // if we have a remote classloader to use, load it", "+//      if (args.length == 3) _installRemoteLoader(args[2]);", "+", "+      final MasterRemote masterRemote = (MasterRemote) ostream.readObject();", "+      _log.log(\"Slave JVM completed reading \" + masterRemote);", "+  ", "-        _log.log(\"Slave JVM creating singleton instance of slave class \" + args[1]);", "-        SlaveRemote slave = _getInstance(slaveClass);", "+//        _log.log(\"Slave JVM created singleton of \" + args[1]);", "+        AbstractSlaveJVM slave = _getInstance(slaveClass);", "-        // Must export slave object to RMI so we can pass stub to the master", "-        _log.log(\"Slave JVM creaing RMI stub for slave class instance \" + slave);", "-        SlaveRemote stub = (SlaveRemote) UnicastRemoteObject.exportObject(slave);  ", "-        _log.log(\"Exported stub \" + stub + \" for \" + slaveClass);", "-        ", "-        // Debug: check that the IP address is 127.0.0.1", "-        //javax.swing.JOptionPane.showMessageDialog(null, stub.toString());", "+        //Export slave object to RMI, passing stub to the master JVM (how does stub get there?  Transitivity?", "+//        _log.log(\"Slave JVM exporting \" + slave + \" to RMI\");", "+        SlaveRemote slaveRemote = (SlaveRemote) UnicastRemoteObject.exportObject(slave);  ", "+        _log.log(\"Slave JVM exported stub \" + slaveRemote);", "-        _log.log(\"Slave JVM invoking the method start(\" + master + \") in the Slave JVM class\");", "-        slave.start(master);", "+//        _log.log(\"Slave JVM invoking the method \" + slave + \".start(\" + masterRemote + \")\");", "+        slave.start(masterRemote);", "-        master.registerSlave(slave);", "+        masterRemote.registerSlave(slaveRemote);", "-      catch (Throwable t) {", "+      catch (Exception e) {", "-        _log.log(\"Slave JVM could not intstantiate slave class and will exit\");", "+        _log.log(\"Slave JVM could not intstantiate slave class.  Threw exception: \" + e);", "-          master.errorStartingSlave(t);", "+          masterRemote.errorStartingSlave(e);", "-          _showErrorMessage(msg, t);", "+          _showErrorMessage(msg, e);", "-    catch (Throwable t) {", "+    catch (Exception e) { // IOException, ClassNotFoundException", "-      _showErrorMessage(\"Couldn't deserialize remote stub for the master JVM.\", t);", "+      _showErrorMessage(\"Could not set up the Slave JVM.\", e);", "+      _log.log(\"Could not set up the Slave JVM. Calling System.exit(2) in response to: \" + e);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b1a2858a5309b2d99a5409772b31db84", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "plt/src/edu/rice/cs/plt/concurrent/ProcessIncrementalTaskController.java", "commitBeforeChange": "ba3f1737bae917eb057a0651ee7d4f727a22cab6", "commitAfterChange": "d28ad1c0de8862f820b20e04c9a78fc9e0194666", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "      protected void doStart()", "signatureAfterChange": "         protected void doStart()", "diff": ["+  ", "-    if (_t != null) { writeCommand(Command.RUN); }", "-    else {", "-      _executor.execute(new Runnable() {", "-        public void run() {", "-          _t = Thread.currentThread();", "+    _executor.execute(new Runnable() {", "+      public void run() {", "+        _t = Thread.currentThread();", "+        try {", "+          // stop if the task was canceled before starting", "+          if (Thread.interrupted()) { throw new InterruptedException(); }", "+          Process p = _jvmBuilder.start(Runner.class.getName(), IterUtil.<String>empty());", "-            // stop if the task was canceled before starting", "-            if (Thread.interrupted()) { throw new InterruptedException(); }", "-            Process p = _jvmBuilder.start(Runner.class.getName(), IterUtil.<String>empty());", "+            InputStream in = p.getInputStream();", "+            // skip prefix", "+            int matching = 0;", "+            while (matching < Runner.PREFIX.length) {", "+              int read = in.read();", "+              if (read == -1) { throw new EOFException(\"Data prefix not found\"); }", "+              else if ((byte) read == Runner.PREFIX[matching]) { matching++; } // cast handles negatives", "+              else if ((byte) read == Runner.PREFIX[0]) { matching = 1; } // cast handles negatives", "+              else { matching = 0; }", "+            }", "+            // prefix has been matched", "+            ObjectInputStream objIn = new ObjectInputStream(in);", "-              InputStream in = p.getInputStream();", "-              // skip prefix", "-              int matching = 0;", "-              while (matching < Runner.PREFIX.length) {", "-                int read = in.read();", "-                if (read == -1) { throw new EOFException(\"Data prefix not found\"); }", "-                else if ((byte) read == Runner.PREFIX[matching]) { matching++; } // cast handles negatives", "-                else if ((byte) read == Runner.PREFIX[0]) { matching = 1; } // cast handles negatives", "-                else { matching = 0; }", "-              }", "-              // prefix has been matched", "-              ObjectInputStream objIn = new ObjectInputStream(in);", "+              ObjectOutputStream objOut = new ObjectOutputStream(p.getOutputStream());", "-                ObjectOutputStream objOut = new ObjectOutputStream(p.getOutputStream());", "-                try {", "-                  objOut.writeObject(_task);", "-                  objOut.writeObject(Command.RUN);", "-                  objOut.flush();", "-                  _commandSink = objOut;", "-                  ", "-                  Result r;", "-                  do {", "-                    r = (Result) objIn.readObject();", "-                    r.handle(ProcessIncrementalTaskController.this);", "-                  } while (!(r instanceof FinishResult));", "-                  if (r instanceof CleanFinishResult) {", "-                    // let the process run if we finished cleanly", "-                    Runnable1<? super Process> onExit = _onExit; // keep local copy so it can be discarded", "-                    if (onExit != null) { p.waitFor(); onExit.run(p); }", "-                  }", "-                  else { p.destroy(); }", "+                objOut.writeObject(_task);", "+                objOut.writeObject(Command.RUN);", "+                objOut.flush();", "+                _commandSink = objOut;", "+                ", "+                Result r;", "+                do {", "+                  r = (Result) objIn.readObject();", "+                  r.handle(ProcessIncrementalTaskController.this);", "+                } while (!(r instanceof FinishResult));", "+                if (r instanceof CleanFinishResult) {", "+                  // let the process run if we finished cleanly", "+                  Runnable1<? super Process> onExit = _onExit; // keep local copy so it can be discarded", "+                  if (onExit != null) { p.waitFor(); onExit.run(p); }", "-                finally { objOut.close(); }", "+                else { p.destroy(); }", "-              finally { objIn.close(); }", "+              finally { objOut.close(); }", "-            catch (EOFException e) {", "-              p.destroy();", "-              throw new IOException(\"Unable to run process; class path may need to be adjusted\");", "-            }", "-            // destroy the process on an exception, but let it run if we completed cleanly", "-            catch (Throwable e) { p.destroy(); throw e; }", "+            finally { objIn.close(); }", "-          catch (InterruptedException e) { /* ignore -- indicates error occurred in another thread */ }", "-          catch (InterruptedIOException e) { /* ignore -- indicates error occurred in another thread */ }", "-          catch (RuntimeException e) { finishedWithImplementationException(e); }", "-          catch (Throwable t) { finishedWithImplementationException(new WrappedException(t)); }", "+          catch (EOFException e) {", "+            p.destroy();", "+            throw new IOException(\"Unable to run process; class path may need to be adjusted\");", "+          }", "+          // destroy the process on an exception, but let it run if we completed cleanly", "+          catch (Throwable e) { p.destroy(); throw e; }", "-      });", "-    }", "+        catch (InterruptedException e) { /* ignore -- indicates error occurred in another thread */ }", "+        catch (InterruptedIOException e) { /* ignore -- indicates error occurred in another thread */ }", "+        catch (RuntimeException e) { finishedWithImplementationException(e); }", "+        catch (Throwable t) { finishedWithImplementationException(new WrappedException(t)); }", "+      }", "+    });"]}], "num": 594}