{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3636c6c8b2e02f6e388d0b93b812cbd6", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "975ad0670fd4bbc77c37a2f846e9b3d3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/newjvm/MainJVM.java", "commitBeforeChange": "bd0c5f6fb57379a8699a4cf01148b0c907e9220d", "commitAfterChange": "1fded97fdeda420f1a00832b34fbad92ca8d6567", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 28, "signatureBeforeChange": "   private void _startNameServiceIfNeeded()", "signatureAfterChange": "   private synchronized void _startNameServiceIfNeeded()", "diff": ["-  private void _startNameServiceIfNeeded() {", "-      Naming.list(\"\");", "-    catch (Exception e) {", "-      // Get a safe port to use.", "-      //  If each copy of DrJava used the same port (or the same port as", "-      //  another program's rmiregistry), then when the previous copy/program", "-      //  quit, we would lose our registry and not be able to reset!", "+   */", "+  private synchronized void _startNameServiceIfNeeded() {", "+    Exception exception = null;", "+    boolean success = false;", "+    for (int i=0; i < 2; i++) {", "-        ServerSocket socket = new ServerSocket(0);", "-        _rmiPort = socket.getLocalPort();", "-        socket.close();", "-        LocateRegistry.createRegistry(_rmiPort);", "+        // See if our registry already exists", "+        Naming.list(\"//127.0.0.1:\" + _rmiPort);", "+        //DrJava.consoleOut().println(\"registry exists\");", "+        success = true;", "+        break;", "-      catch (Exception e2) {", "-        throw new UnexpectedException(new RuntimeException(", "-          \"Could not find a usable RMI Port: \" + e2.toString()));", "+      catch (Exception e) {", "+        // Didn't already exist, so try to create it", "+        //e.printStackTrace(DrJava.consoleOut());", "+        try {", "+          //DrJava.consoleOut().println(\"trying to create registry on port: \" + _rmiPort);", "+          LocateRegistry.createRegistry(_rmiPort);", "+        }", "+        catch (Exception e2) {", "+          // Failed to create.  Try again on another port", "+          _rmiPort = _generateSafeRMIPort();", "+          exception = e2;", "+        }", "-      //DrJava.consoleOut().println(\"Created rmiregistry on port: \" + _rmiPort);", "+    }", "+    if (!success) {", "+      throw new UnexpectedException(new RuntimeException(", "+          \"Could not find a usable RMI Port: \" + exception.toString()));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9827d9945e7f054d93e09ff8b41c7440", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/FindReplaceMachine.java", "commitBeforeChange": "45f938e0ac0aa62921f2e8d3dd3a1115a8868aaf", "commitAfterChange": "f1270b4a562e0ecd61507987f82e57d121a23edd", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": "   private FindResult _findNext(int start, int end)", "signatureAfterChange": "   private FindResult _findNext(int start, int end)", "diff": ["+    int foundOffset = -1;", "+    FindResult tempFr = new FindResult(_doc, -1, false, false);      ", "+      boolean stillSearching = true;", "+      while(stillSearching) {", "+        foundOffset = -1;", "+        tempFr = new FindResult(_doc, -1, false, false);      ", "+        stillSearching = false;", "-      FindResult tempFr = new FindResult(_doc, -1, false, false);      ", "-      int docLen;", "-      String findWord = _findWord;", "-      // get the search space in the document", "-      String findSpace;", "-      _doc.acquireReadLock();", "-      try {", "-        docLen = _doc.getLength();", "-        findSpace = _doc.getText(start, end);", "-      }", "-      finally { _doc.releaseReadLock(); }", "-      ", "-      if (!_matchCase) {", "-        findSpace = findSpace.toLowerCase();", "-        findWord = findWord.toLowerCase();", "-      }", "-      ", "-      // find the first occurrence of findWord", "-      int foundOffset;", "-      foundOffset = !_searchBackwards ? findSpace.indexOf(findWord) : findSpace.lastIndexOf(findWord);", "-          ", "-      if (foundOffset >= 0) {", "-        int locationToIgnore = foundOffset + start;", "-        _model.getODDForDocument(_doc).setCurrentLocation(locationToIgnore);", "-        if (_shouldIgnore(locationToIgnore, _doc)) {", "-          foundOffset += start;", "-          if (!_searchBackwards) {", "-            foundOffset += findWord.length();", "-            return _findNext(foundOffset, docLen-foundOffset);", "-          }", "-          return _findNext(start, foundOffset); //searching backwards", "-        }       ", "-        // otherwise we have found it", "-//        _found = true;", "-        foundOffset += start;", "-        if (!_searchBackwards) foundOffset += findWord.length();", "-        _current = _doc.createPosition(foundOffset);  // thread-safe operation on _doc", "-      }", "-      else { // we haven't found it yet", "-        if (_searchAllDocuments) {", "-          AbstractDocumentInterface nextDocToSearch;", "-          ", "-          nextDocToSearch = ", "-            (!_searchBackwards ? _docIterator.getNextDocument(_doc) : _docIterator.getPrevDocument(_doc));", "-          ", "-          tempFr = _findNextInAllDocs(nextDocToSearch, 0, nextDocToSearch.getLength());", "-          foundOffset = tempFr.getFoundOffset();", "+        int docLen;", "+        String findWord = _findWord;", "+        // get the search space in the document", "+        String findSpace;", "+        _doc.acquireReadLock();", "+        try {", "+          docLen = _doc.getLength();", "+          findSpace = _doc.getText(start, end);", "-        else { ", "-          _checkAllDocsWrapped = false;", "-          _allDocsWrapped = false;", "+        finally { _doc.releaseReadLock(); }", "+        ", "+        if (!_matchCase) {", "+          findSpace = findSpace.toLowerCase();", "+          findWord = findWord.toLowerCase();", "-        if (foundOffset == -1) {   // we still haven't found it            ", "-          if (!_searchBackwards) foundOffset = _findWrapped(0, _current.getOffset() + (_findWord.length() - 1));", "-          else {", "-            int startBackOffset = _current.getOffset() - (_findWord.length() - 1);", "-            foundOffset = _findWrapped(startBackOffset, docLen - startBackOffset);", "+        // find the first occurrence of findWord", "+        foundOffset = !_searchBackwards ? findSpace.indexOf(findWord) : findSpace.lastIndexOf(findWord);", "+        ", "+        if (foundOffset >= 0) {", "+          int locationToIgnore = foundOffset + start;", "+          _model.getODDForDocument(_doc).setCurrentLocation(locationToIgnore);", "+          if (_shouldIgnore(locationToIgnore, _doc)) {", "+            foundOffset += start;", "+            if (!_searchBackwards) {", "+              foundOffset += findWord.length();", "+              start = foundOffset;", "+              end = docLen-foundOffset;", "+              stillSearching = true;", "+              continue; ", "+              // return _findNext(foundOffset, docLen-foundOffset);", "+            }", "+            end = foundOffset;", "+            stillSearching = true;", "+            continue;", "+            // return _findNext(start, foundOffset); //searching backwards", "+          }       ", "+          // otherwise we have found it", "+//        _found = true;", "+          foundOffset += start;", "+          if (!_searchBackwards) foundOffset += findWord.length();", "+          _current = _doc.createPosition(foundOffset);  // thread-safe operation on _doc", "+        }", "+        else { // we haven't found it yet", "+          if (_searchAllDocuments) {", "+            AbstractDocumentInterface nextDocToSearch;", "+            ", "+            nextDocToSearch = ", "+              (!_searchBackwards ? _docIterator.getNextDocument(_doc) : _docIterator.getPrevDocument(_doc));", "+            ", "+            tempFr = _findNextInAllDocs(nextDocToSearch, 0, nextDocToSearch.getLength());", "+            foundOffset = tempFr.getFoundOffset();", "+          }", "+          else { ", "+            _checkAllDocsWrapped = false;", "+            _allDocsWrapped = false;", "+          }", "+          ", "+          if (foundOffset == -1) {   // we still haven't found it            ", "+            if (!_searchBackwards) foundOffset = _findWrapped(0, _current.getOffset() + (_findWord.length() - 1));", "+            else {", "+              int startBackOffset = _current.getOffset() - (_findWord.length() - 1);", "+              foundOffset = _findWrapped(startBackOffset, docLen - startBackOffset);", "+            }", "-      }", "-      ", "-      if (_checkAllDocsWrapped && tempFr.getDocument() == _firstDoc) {", "-        _allDocsWrapped = true;", "-        _checkAllDocsWrapped = false;", "-      }", "-      ", "-      FindResult fr = new FindResult(tempFr.getDocument(), foundOffset, _wrapped, _allDocsWrapped);", "-      _wrapped = false;", "-      if (_allDocsWrapped = true) _allDocsWrapped = false;", "-      return fr;", "+        ", "+        if (_checkAllDocsWrapped && tempFr.getDocument() == _firstDoc) {", "+          _allDocsWrapped = true;", "+          _checkAllDocsWrapped = false;", "+        }", "+      }        ", "+    FindResult fr = new FindResult(tempFr.getDocument(), foundOffset, _wrapped, _allDocsWrapped);", "+    _wrapped = false;", "+    _allDocsWrapped = false;", "+    return fr;"]}], "num": 24891}