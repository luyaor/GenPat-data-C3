{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dcb729b13263e5c5cb719c3ebfd4887f", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4102573187aec06afbadfd01dfc22fe7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocument.java", "commitBeforeChange": "6d23d799552cf55313f22433cb12915906b19690", "commitAfterChange": "8a04e8e94a35e432777ebd444cf5fc70868fe9e4", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 24, "signatureBeforeChange": "   public int findPrevDelimiter(int pos, char[] delims) throws BadLocationException", "signatureAfterChange": "   public int findPrevDelimiter(int pos, char[] delims, boolean skipParenPhrases)     throws BadLocationException", "diff": ["-    ", "+   */", "+  public int findPrevDelimiter(int pos, char[] delims, boolean skipParenPhrases)", "+    throws BadLocationException", "+  {", "-", "+    ", "-          if((_reduced.getStateAtCurrent().equals(ReducedModelState.INSIDE_LINE_COMMENT)) ||", "-             (_reduced.getStateAtCurrent().equals(ReducedModelState.INSIDE_BLOCK_COMMENT)) ||", "-             (_reduced.getStateAtCurrent().equals(ReducedModelState.INSIDE_SINGLE_QUOTE)) ||", "-             (_reduced.getStateAtCurrent().equals(ReducedModelState.INSIDE_DOUBLE_QUOTE))) {", "-\t    // Ignore matching char", "-\t  } else {", "-\t    // Return position of matching char", "-\t    _reduced.move(origLocation - i);", "-\t    return i;", "-\t  }", "+          ReducedModelState state = _reduced.getStateAtCurrent();", "+          if((state.equals(ReducedModelState.INSIDE_LINE_COMMENT)) ||", "+             (state.equals(ReducedModelState.INSIDE_BLOCK_COMMENT)) ||", "+             (state.equals(ReducedModelState.INSIDE_SINGLE_QUOTE)) ||", "+             (state.equals(ReducedModelState.INSIDE_DOUBLE_QUOTE))) {", "+               // Ignore matching char", "+             } else {", "+               // Found a matching char, check if we should ignore it", "+               if (skipParenPhrases && posInParenPhrase(i)) {", "+                 // In a paren phrase, so ignore", "+               }", "+               else {", "+                 // Return position of matching char", "+                 _reduced.move(origLocation - i);", "+                 return i;", "+               }", "+             }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "71c8cd016460aa093bd01d9040af878e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Augmentor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": "   public void forMethodDef(MethodDef that)", "signatureAfterChange": "   public void forMethodDef(MethodDef that)", "diff": ["-   */", "+    */", "-    _readAndWriteThroughIndex(that.getSourceInfo().getStartLine(), that.getSourceInfo().getStartColumn() - 1);", "-    if (_isElementaryFile()) { ", "-      _writeToFileOut(\"public \");", "-    }", "+    SourceInfo mdSourceInfo = that.getSourceInfo();", "+    _readAndWriteThroughIndex(mdSourceInfo.getStartLine(), mdSourceInfo.getStartColumn() - 1);", "-    if (_isIntermediateFile()) { //if this is an Intermediate level file, want to check and see if the method has modifiers.  If not,", "-                                 //make it public by default", "+    if (_isElementaryFile()) _writeToFileOut(\"public \");", "+    ", "+    if (_isIntermediateFile()) { ", "+      /* Check if the method has explicit modifiers.  Unfortunately, the information in that.getMav().getModifiers() ", "+       * is not reliable regarding what modifiers EXPLICITLY appear in the .dj1 file, so we have to do additional work. */", "+      ", "-      boolean hasVisibilityModifier = false;", "-      for (int i = 0; i<modifiers.length; i++) {", "-        if ((modifiers[i].equals(\"private\")) || (modifiers[i].equals(\"public\")) || (modifiers[i].equals(\"protected\"))) {", "-          hasVisibilityModifier = true;", "+      String visibilityModifier = null;", "+      for (int i = 0; i < modifiers.length; i++) {", "+        if (modifiers[i].equals(\"private\") || modifiers[i].equals(\"public\") || modifiers[i].equals(\"protected\")) {", "+          visibilityModifier = modifiers[i];", "+", "+//  This patch was created in an attempt to fix an augmentation bug by brute force; it didn't work      ", "+//      if (visibilityModifier != null) {", "+//        // Check for explicit appearance in text", "+//        String text = _peek(mdSourceInfo.getEndLine(), mdSourceInfo.getEndColumn());", "+//        _log.log(\"Checking for presence of visibility modifier \" + visibilityModifier + \" in file \" + _fileIn +  \" on line \" + _fileInLine + \":\\n'\" + text + \"'\");", "+//        int len = text.length();", "+//        // This analysis can be broken by deviously constructed comments", "+//        int startModifier = text.indexOf(visibilityModifier);  // offset of modifier", "+//        if (startModifier < 0) startModifier = len;  // This should never happen", "+//        int startName = text.indexOf(that.getName().getText());  // offset of method name", "+//        if (startName < 0) startName = len;  // This should never happen", "+//        if (startName <= startModifier) { ", "+//          visibilityModifier = null; // modifier does not explicitlly appear in text", "+//          _log.log(\"No modifier was found\");", "+//        }", "+//        else _log.log(\"Modifier was found\");", "+//      }", "-      if (!hasVisibilityModifier) {", "+      if (visibilityModifier == null) {", "+//  A continuation of the preceding unsucessful patch", "+//        MethodData md = ", "+//          _enclosingData.getSymbolData().getMethod(that.getName().getText(), ", "+//                                                   formalParameters2TypeDatas(that.getParams(), _enclosingData));", "+//        if (md == null) { ", "+//          throw new RuntimeException(\"Internal Program Error: Can't find method data for \" + that.getName() + ", "+//                                     \" Please report this bug.\"); ", "+//        }", "+//        md.addModifier(\"public\");  // this operation is idempotent", "-      ", "+        ", "+    "]}], "num": 26911}