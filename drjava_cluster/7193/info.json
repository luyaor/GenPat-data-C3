{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "651ee03ed5d51d1344e40c372d524016", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "938bccb8ac796815439e3a03c0efd4fd", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/javadoc/DefaultJavadocModel.java", "commitBeforeChange": "4827c31f832b0b658b5049b701f441bcd4cd2853", "commitAfterChange": "c9a582a01c4727c2040c438bfb469bb6c612160b", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "   private void _javadocAllWorker(File destDirFile, FileSaveSelector saver)", "signatureAfterChange": "   private void _javadocAllWorker(final File destDirFile, FileSaveSelector saver)", "diff": ["-  private void _javadocAllWorker(File destDirFile, FileSaveSelector saver) {", "+  private void _javadocAllWorker(final File destDirFile, FileSaveSelector saver) {", "-    List<String> docFiles = new ArrayList<String>(); // files to send to Javadoc", "-    ", "+    final List<String> docFiles = new ArrayList<String>(); // files to send to Javadoc", "+", "+    final List<OpenDefinitionsDocument> llDocs = new ArrayList<OpenDefinitionsDocument>();", "-        File file = _getFileFromDocument(doc, saver);", "-        docFiles.add(file.getPath());", "+        File docFile = _getFileFromDocument(doc, saver);", "+        final File file = IOUtil.attemptCanonicalFile(docFile);", "+", "+        // If this is a language level file, make sure it has been compiled", "+        if (isLLFile(file)) {", "+          // Utilities.showDebug(\"isLLFile=true: \"+file);", "+          llDocs.add(doc);", "+          docFiles.add(getJavaForLLFile(file).getPath());", "+        }", "+        else {", "+          docFiles.add(file.getPath());", "+        }", "-    if (docFiles.size() == 0) return;", "+    if (docFiles.size() == 0) {", "+      // Use EventQueue.invokeLater so that notification is deferred when running in the event thread.", "+      EventQueue.invokeLater(new Runnable() { public void run() { _notifier.javadocEnded(false, destDirFile, true); } });", "+      return;", "+    }", "-    // Run the actual Javadoc process", "-    _runJavadoc(docFiles, destDirFile, IterUtil.<String>empty(), true);", "+    Utilities.invokeLater(new Runnable() { public void run() {", "+      if (_model.hasOutOfSyncDocuments(llDocs)) {", "+        // Utilities.showDebug(\"out of date\");", "+        CompilerListener javadocAfterCompile = new DummyCompilerListener() {", "+          @Override public void compileAborted(Exception e) {", "+            // gets called if there are modified files and the user chooses NOT to save the files", "+            // see bug report 2582488: Hangs If Testing Modified File, But Choose \"No\" for Saving", "+            final CompilerListener listenerThis = this;", "+            // Utilities.showDebug(\"compile aborted\");", "+            // always remove this listener after its first execution", "+            EventQueue.invokeLater(new Runnable() { ", "+              public void run() {", "+                _model.getCompilerModel().removeListener(listenerThis);", "+                // fail Javadoc", "+                _notifier.javadocEnded(false, destDirFile, true);", "+              }", "+            });", "+          }", "+          @Override public void compileEnded(File workDir, List<? extends File> excludedFiles) {", "+            final CompilerListener listenerThis = this;", "+            try {", "+              // Utilities.showDebug(\"compile ended\");", "+              if (_model.hasOutOfSyncDocuments(llDocs) || _model.getNumCompErrors() > 0) {", "+                // Utilities.showDebug(\"still out of date, fail\");", "+                // fail Javadoc", "+                EventQueue.invokeLater(new Runnable() { public void run() { _notifier.javadocEnded(false, destDirFile, true); } });", "+                return;", "+              }", "+              EventQueue.invokeLater(new Runnable() {  // defer running this code; would prefer to waitForInterpreter", "+                public void run() {", "+                  // Utilities.showDebug(\"running Javadoc\");", "+                  // Run the actual Javadoc process", "+                  _runJavadoc(docFiles, destDirFile, IterUtil.<String>empty(), true);", "+                }", "+              });", "+            }", "+            finally {  // always remove this listener after its first execution", "+              EventQueue.invokeLater(new Runnable() { ", "+                public void run() { _model.getCompilerModel().removeListener(listenerThis); }", "+              });", "+            }", "+          }", "+        };", "+        ", "+        _notifyCompileBeforeJavadoc(javadocAfterCompile);", "+        return;", "+      }", "+      ", "+      // Run the actual Javadoc process", "+      _runJavadoc(docFiles, destDirFile, IterUtil.<String>empty(), true);", "+    } });"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3e6ee2eadbbf59a287054f43e82748e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/javadoc/DefaultJavadocModel.java", "commitBeforeChange": "4827c31f832b0b658b5049b701f441bcd4cd2853", "commitAfterChange": "c9a582a01c4727c2040c438bfb469bb6c612160b", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 18, "signatureBeforeChange": "   public void javadocDocument(final OpenDefinitionsDocument doc, final FileSaveSelector saver) throws IOException", "signatureAfterChange": "   public void javadocDocument(final OpenDefinitionsDocument doc, final FileSaveSelector saver) throws IOException", "diff": ["-    final File file = _getFileFromDocument(doc, saver);", "+    File docFile = _getFileFromDocument(doc, saver);", "+    final File file = IOUtil.attemptCanonicalFile(docFile);", "+    final File javaFile = getJavaForLLFile(file);", "+", "+    Utilities.invokeLater(new Runnable() { public void run() {", "+      // If this is a language level file, make sure it has been compiled", "+      if (isLLFile(file)) {", "+        // Utilities.showDebug(\"isLLFile = true\");", "+        final List<OpenDefinitionsDocument> singleton = new ArrayList<OpenDefinitionsDocument>();", "+        singleton.add(doc);", "+        if (_model.hasOutOfSyncDocuments(singleton)) {", "+          // Utilities.showDebug(\"out of date\");", "+          CompilerListener javadocAfterCompile = new DummyCompilerListener() {", "+            @Override public void compileAborted(Exception e) {", "+              // gets called if there are modified files and the user chooses NOT to save the files", "+              // see bug report 2582488: Hangs If Testing Modified File, But Choose \"No\" for Saving", "+              final CompilerListener listenerThis = this;", "+              // always remove this listener after its first execution", "+              EventQueue.invokeLater(new Runnable() { ", "+                public void run() { ", "+                  _model.getCompilerModel().removeListener(listenerThis);", "+                  // fail Javadoc", "+                  _notifier.javadocEnded(false, null, false);", "+                }", "+              });", "+            }", "+            @Override public void compileEnded(File workDir, List<? extends File> excludedFiles) {", "+              final CompilerListener listenerThis = this;", "+              try {", "+                // Utilities.showDebug(\"compile ended\");", "+                if (_model.hasOutOfSyncDocuments(singleton) || _model.getNumCompErrors() > 0) {", "+                  // Utilities.showDebug(\"still out of date, fail\");", "+                  // fail Javadoc", "+                  EventQueue.invokeLater(new Runnable() { public void run() { _notifier.javadocEnded(false, null, false); } });", "+                  return;", "+                }", "+                EventQueue.invokeLater(new Runnable() {  // defer running this code; would prefer to waitForInterpreter", "+                  public void run() {", "+                    try {", "+                      // Utilities.showDebug(\"running Javadoc\");", "+                      _rawJavadocDocument(javaFile);", "+                    }", "+                    catch(IOException ioe) {", "+                      // fail Javadoc", "+                      EventQueue.invokeLater(new Runnable() { public void run() { _notifier.javadocEnded(false, null, false); } });", "+                    }", "+                  }", "+                });", "+              }", "+              finally {  // always remove this listener after its first execution", "+                EventQueue.invokeLater(new Runnable() { ", "+                  public void run() { _model.getCompilerModel().removeListener(listenerThis); }", "+                });", "+              }", "+            }", "+          };", "+          ", "+          _notifyCompileBeforeJavadoc(javadocAfterCompile);", "+          return;", "+        }", "+      }", "+      try {", "+        _rawJavadocDocument(javaFile);", "+      }", "+      catch(IOException ioe) {", "+        // fail Javadoc", "+        EventQueue.invokeLater(new Runnable() { public void run() { _notifier.javadocEnded(false, null, false); } });", "+      }", "+    } });", "+  }"]}], "num": 7193}