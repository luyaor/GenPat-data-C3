{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cd057434c0f6b77cfba9909188b7c922", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "806cfc5bd0a58c7190637f8862608b0f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/MovingDocumentRegion.java", "commitBeforeChange": "50372cdcb0e3a8db5661a31f5825b5dc9f07a9e9", "commitAfterChange": "3049ab1c03c6212f738bc13f7b01e843f39da3a7", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 1, "signatureBeforeChange": "   public MovingDocumentRegion(OpenDefinitionsDocument doc, File file, Position sp, Position ep, Thunk<String> ss)", "signatureAfterChange": "   public MovingDocumentRegion(final OpenDefinitionsDocument doc, int start, int end, int lineStart, int lineEnd)", "diff": ["-  public MovingDocumentRegion(OpenDefinitionsDocument doc, File file, Position sp, Position ep, Thunk<String> ss) {", "-    super(doc, sp, ep);", "+  public MovingDocumentRegion(final OpenDefinitionsDocument doc, int start, int end, int lineStart, int lineEnd) {", "+", "+    super(doc, start, end);", "+    try {", "+      _lineStartPos = doc.createPosition(lineStart);", "+      _lineEndPos  = doc.createPosition(lineEnd);", "+    }", "+    catch (BadLocationException ble) { throw new UnexpectedException(ble); }  // should never happen", "+    ", "-    _stringSuspension = ss;", "+    _stringSuspension = new Thunk<String>() {", "+      public String value() {", "+        try {", "+          int endSel = getEndOffset();", "+          int startSel = getStartOffset();", "+          int selLength = endSel - startSel;", "+          ", "+          int excerptEnd = _lineEndPos.getOffset();", "+          int excerptStart = _lineStartPos.getOffset();", "+          int exceptLength = excerptEnd - excerptStart;", "+          ", "+          // the offsets within the excerpted string of the selection (figuratively in \"Red\")", "+          int startRed = startSel - excerptStart;", "+          int endRed = endSel - excerptStart;", "+          ", "+          int excerptLength = Math.min(120, excerptEnd - excerptStart);", "+          String text = doc.getText(excerptStart, excerptLength);", "+          ", "+          // Construct the matching string and compressed selection prefix and suffix strings within text", "+          String prefix = StringOps.compress(text.substring(0, startRed));", "+          String match, suffix;", "+          if (excerptLength < startRed + selLength) { // selection extends beyond excerpt", "+            match = text.substring(startRed) + \" ...\";", "+            suffix = \"\";", "+          }", "+          else {", "+            match = text.substring(startRed, endRed);", "+            suffix = StringOps.compress(text.substring(endRed, excerptLength));", "+          }", "+          ", "+          // COMMENT: We need a global invariant concerning non-displayable characters.  ", "+          ", "+          // create the excerpt string", "+          StringBuilder sb = new StringBuilder(edu.rice.cs.plt.text.TextUtil.htmlEscape(prefix));", "+          sb.append(\"<font color=#ff0000>\");", "+//                sb.append(LEFT);", "+          sb.append(edu.rice.cs.plt.text.TextUtil.htmlEscape(match));", "+          sb.append(\"</font>\");", "+//                sb.append(RIGHT);", "+          sb.append(edu.rice.cs.plt.text.TextUtil.htmlEscape(suffix));", "+//                sb.append(\"</html>\");", "+//                sb.append(StringOps.getBlankString(120 - sLength));  // move getBank to StringOps", "+          return sb.toString();", "+        }", "+        catch(BadLocationException e) { return \"\";  /* Ignore the exception. */ }", "+      }", "+    };"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f75f04a5bfcc15f583134374bedebef0", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 13, "signatureBeforeChange": "     protected Pair<LinkedList<MethodData>, LinkedList<MethodData>>      _getMatchingMethods(String methodName, SymbolData enclosingSD, InstanceData[] arguments, JExpression jexpr,                          boolean isConstructor, SymbolData thisSD)", "signatureAfterChange": "     protected Pair<LinkedList<MethodData>, LinkedList<MethodData>>      _getMatchingMethods(String methodName, SymbolData enclosingSD, InstanceData[] arguments, JExpression jexpr,                          boolean isConstructor, SymbolData thisSD)", "diff": ["+    if (enclosingSD.getName().equals(\"NonEmpty\"))", "+      System.err.println(\"Starting search for method \" + methodName + \" in \" + enclosingSD);", "+//      System.err.println(\"Testing method \" + md.getName());", "+      if (md.getName().equals(\"NonEmpty\")) {", "+        System.err.println(\"*** for NonEmpty(), params length = \" + md.getParams().length + \"; args length = \" + arguments.length);", "+      }", "+        ", "-          matches = matches && _isAssignableFromWithoutAutoboxing(vds[i].getType().getSymbolData(), arguments[i].getSymbolData());", "+          matches = matches && ", "+            _isAssignableFromWithoutAutoboxing(vds[i].getType().getSymbolData(), arguments[i].getSymbolData());", "+          if (enclosingSD.getName().equals(\"NonEmpty\")) {", "+            System.err.println(\"*** Looking for autoboxing match for NonEmpty\");", "+            System.err.println(\"vds = \" + Arrays.toString(vds) + \" arguments = \" + Arrays.toString(arguments));", "+          }", "+            if  (enclosingSD.getName().equals(\"NonEmpty\")) {", "+              SymbolData parmSD = vds[i].getType().getSymbolData();", "+              System.err.println(\"vds[\" + i + \"].getType().getSymbolData() = \" + parmSD);", "+              SymbolData argSD = arguments[i].getSymbolData();", "+              System.err.println(\"arguments[\" + i + \"].getSymbolData() = \" + argSD);", "+              if (argSD.equals(SymbolData.INT_TYPE) && parmSD.equals(symbolTable.get(\"java.lang.Object\")))", "+                assert _isAssignableFrom(parmSD, argSD);", "+            }", "-            if (matches == false) break;", "+            if (matches == false) {", "+              if (enclosingSD.getName().equals(\"NonEmpty\"))", "+                System.err.println(\"No match found for NonEmpty using autoboxing\");", "+              break;", "+            }", "+    if (methodName.equals(\"NonEmpty\")) {", "+      System.err.println(\"***** enclosingSD = \" + enclosingSD + \"; thisSD = \" + thisSD + \"; matching methods: \" + matching);", "+      System.err.println(\"***** matching methods with autoboxing: \" + matchingWithAutoBoxing);", "+    }", "+    "]}], "num": 25529}