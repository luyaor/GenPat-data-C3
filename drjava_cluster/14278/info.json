{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b3687bf176c95e8566f57e6ee17543c7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4614078fc66bd454287cb37ecfcdcb98", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/JarJDKToolsLibrary.java", "commitBeforeChange": "e9b6b2fb912f9bb858bd9b4e8c93160bab9b774c", "commitAfterChange": "9d83c5e72c3c3a4b777224dfc83ca830e4a2d380", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "      public static FullVersion guessVersion(File f, JDKDescriptor desc)", "signatureAfterChange": "      public static FullVersion guessVersion(File f, JDKDescriptor desc)", "diff": ["-    if (result == null || result.majorVersion().equals(JavaVersion.UNRECOGNIZED)) {", "+    System.out.println(f+\" After walking directories: \"+result);", "+    if (result == null || result.majorVersion().equals(JavaVersion.UNRECOGNIZED) ||", "+        result.majorVersion().equals(JavaVersion.FUTURE)) {", "+      System.out.println(f+\" null or UNRECOGNIZED or FUTURE\");", "+        ", "+        System.out.println(f+\" After manifest: \"+result);", "+        ", "+        // still unknown or future", "+        if (result == null || result.majorVersion().equals(JavaVersion.UNRECOGNIZED) ||", "+            result.majorVersion().equals(JavaVersion.FUTURE)) {", "+          System.out.println(f+\" null or UNRECOGNIZED or FUTURE\");", "+          // look for the first class file", "+          Enumeration<JarEntry> jes = jf.entries();", "+          while(jes.hasMoreElements()) {", "+            JarEntry je = jes.nextElement();", "+            if (je.getName().endsWith(\".class\")) {", "+              result = JavaVersion.parseClassVersion(jf.getInputStream(je)).fullVersion();", "+              break;", "+            }", "+          }", "+        }", "+      ", "+      System.out.println(f+\" After all: \"+result);", "+      ", "+        System.out.println(f+\" null or UNRECOGNIZED or FUTURE\");", "-        parsedVersion = result.versionString();", "+      ", "+      parsedVersion = result.versionString();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f81d08ca5a3665f6dece654e3f331c6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/sourcechecker/SourceChecker.java", "commitBeforeChange": "be902882edd6ee8f5b7260e86997569bf07255e2", "commitAfterChange": "ead43466202abb204c90f7ee2c316fec230d4415", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 41, "signatureBeforeChange": "      public static void main(String... args)", "signatureAfterChange": "      public static void main(String... args)", "diff": ["-      Iterator<String> optNames = _options.keySet().iterator();", "-      String canonicalName = optNames.next();", "-      Iterable<CompilationUnit> canonical = processFiles(sources, cp, _options.get(canonicalName));", "-      Map<String, Iterable<CompilationUnit>> others = new LinkedHashMap<String, Iterable<CompilationUnit>>();", "-      while (optNames.hasNext()) {", "-        String n = optNames.next();", "-        others.put(n, processFiles(sources, cp, _options.get(n)));", "+      String canonical = IterUtil.first(_options.keySet());", "+      Map<String, Iterable<CompilationUnit>> results = new LinkedHashMap<String, Iterable<CompilationUnit>>();", "+      for (String n : _options.keySet()) {", "+        System.out.println(\"============ Checking with type system \" + n + \" ============\");", "+        results.put(n, processFiles(sources, cp, _options.get(n)));", "-      for (Map.Entry<String, Iterable<CompilationUnit>> e : others.entrySet()) {", "-        NodeDiffLog log = new NodeDiffLog(canonicalName, _options.get(canonicalName).typeSystem(),", "+      for (Map.Entry<String, Iterable<CompilationUnit>> e : results.entrySet()) {", "+        if (e.getKey().equals(canonical)) continue;", "+        String compareTo;", "+        if (e.getKey().endsWith(\"-inferred\")) {", "+          compareTo = e.getKey().substring(0, e.getKey().length() - \"-inferred\".length());", "+        }", "+        else { compareTo = canonical; }", "+        ", "+        NodeDiffLog log = new NodeDiffLog(compareTo, _options.get(compareTo).typeSystem(),", "-        new NodeDiff(log).compare(canonical, e.getValue());", "+        new NodeDiff(log).compare(results.get(compareTo), e.getValue());", "+        ", "+        String firstInferred = compareTo + \"-inferred\";", "+        String secondInferred = e.getKey() + \"-inferred\";", "+        if (results.containsKey(firstInferred) && results.containsKey(secondInferred)) {", "+          NodeDiffLog log2 = new NodeDiffLog(firstInferred, _options.get(firstInferred).typeSystem(),", "+                                             secondInferred, _options.get(secondInferred).typeSystem(), verbose);", "+          new NodeDiff(log2).compare(results.get(firstInferred), results.get(secondInferred));", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf960948b6a35fa77964e976676b2cdf", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 19, "signatureBeforeChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "diff": ["+    System.err.println(\"LanguageLevelConverter.convert called on files:  \" + Arrays.toString(files));", "+    System.err.println(\"Options = \" + options);", "-    //keep track of the continuations to resolve  // What precisely is a continuation?", "-    Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>> continuations = ", "-      new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>();", "+    // Keep track of the continuations to resolve.  A continuation is a fully qualified type name with no attributes.", "+    Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>> continuations = ", "+      new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>();", "+    ", "+    // Keep track of the fixups to peform.  A fixup is a command that must be executed (after all continuations are", "+    // resolved to fully update the symbolTable.", "+    LinkedList<Command> fixUps = new LinkedList<Command>();", "-    for (File f : files) {", "-      ", "+    for (File f : files) {    ", "+          LinkedList<String> importedPackageBase = new LinkedList<String>();", "+          importedPackageBase.add(\"java.lang\");", "+            ", "-            llv = new IntermediateVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(),", "-                                          new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "+            llv = new IntermediateVisitor(f,", "+                                          importedPackageBase,", "+                                          new LinkedList<Pair<String, JExpressionIF>>(),", "+                                          new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>(),", "+                                          new LinkedList<Command>(),", "-            llv = new FullJavaVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(),", "-                                      new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "+            llv = new FullJavaVisitor(f,", "+                                      importedPackageBase,", "+                                      new LinkedList<Pair<String, JExpressionIF>>(),", "+                                      new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>(), ", "+                                      new LinkedList<Command>(),", "+          fixUps.addAll(llv.fixUps);", "-    /* Resolve continuations created in conformance pass and log any generated errors. */", "+    /* Resolve continuations created in conformance pass and log any generated errors.  TODO: refactor use of ", "+     * getSymbolData with a flag; create a new method for resolving continuations.  Use a common helper.  */", "-        String className = en.nextElement();", "-        Pair<SourceInfo, LanguageLevelVisitor> pair = continuations.remove(className);", "-        SymbolData returnedSd = pair.getSecond().getSymbolData(className, pair.getFirst(), true);", "-        _log.log(\"Attempting to resolve \" + className + \"\\n  Result = \" + returnedSd);", "-//        System.err.println(\"Attempting to resolve \" + className + \"\\n  Result = \" + returnedSd);", "-        if (returnedSd == null) {", "-//          if (className.equals(\"listFW.IList\")) {", "+        String name = en.nextElement();   // name referenced in continuation", "+        Triple<SourceInfo, LanguageLevelVisitor, SymbolData> triple = continuations.remove(name);", "+        /* Resolving this continuation updates all references to symbol of this continuation. */", "+        SourceInfo si = triple.getFirst();   // SourceInfo in continuation", "+        LanguageLevelVisitor llv = triple.getSecond();", "+        SymbolData sD = triple.getThird();  // SymbolData in continuation", "+        SymbolData newSD = sD.resolve(si, llv);", "+        _log.log(\"Attempting to resolve \" + sD + \" with source info \" + si + \"\\n  Result = \" + newSD);", "+//        System.err.println(\"Attempting to resolve \" + name + \" with source info \" + si + \"\\n  Result = \" + newSD);", "+        if (newSD == null) {", "+//          if (name.equals(\"listFW.IList\")) {", "-          LanguageLevelVisitor.errors.add(new Pair<String, JExpressionIF>(\"Converter could not resolve \" + className, ", "-                                                                          new NullLiteral(pair.getFirst())));", "+          LanguageLevelVisitor.errors.add(new Pair<String, JExpressionIF>(\"Converter could not resolve \" + name,                                                                    new NullLiteral(triple.getFirst())));", "+        ", "+    // Execute fixups; must be done before creating constructors because some symbols required for constructor", "+    // definition may be missing", "+    for (Command c: fixUps) { c.execute(); }", "+    ", "-      if (sdlv != null) sdlv.createConstructor(key);  // Bug fix is a kludge! Deletes (key,sdlv) from _newSDs!", "+      if (sdlv != null) {", "+        System.err.println(\"*** Creating constructor for \" + key);", "+        sdlv.createConstructor(key);  // Bug fix is a kludge! Deletes (key,sdlv) from _newSDs!", "+      }", "-    ", "-    else  { /* Perform type-checking on visited LL files and build list of files toAugment. */", "+    else  {", "+      /* Perform type-checking on visited LL files and build list of files toAugment. */", "-        LanguageLevelVisitor llv = triple.first();", "-        SourceFile sf = triple.second();", "-        File f = triple.third();", "+        LanguageLevelVisitor llv = triple.getFirst();", "+        SourceFile sf = triple.getSecond();", "+        File f = triple.getThird();", "+          System.err.println(\"**** Type checking \" + f);", "-    for (Triple<LanguageLevelVisitor, SourceFile, File> triple: toAugment) ", "+    for (Triple<LanguageLevelVisitor, SourceFile, File> triple: toAugment)  {", "-      ", "-      LanguageLevelVisitor llv = triple.first();", "-      SourceFile sf = triple.second();", "-      File f = triple.third();", "-      ", "-      File augmentedFile = getJavaForLLFile(f); // create  empty .java file for .dj? file", "-      ", "-      if (isAdvancedFile(f)) { Utilities.copyFile(f, augmentedFile); }", "-      else {", "-        BufferedReader tempBr = new BufferedReader(new FileReader(f));", "-        String firstLine = tempBr.readLine();", "-        tempBr.close(); // Important to close the reader, otherwise Windows will not allow the renameTo call later.", "-        if (firstLine == null) continue;", "+        LanguageLevelVisitor llv = triple.getFirst();", "+        SourceFile sf = triple.getSecond();", "+        File f = triple.getThird();", "-        // If the file has an appropriate LL extension, then parse it.", "-        if (isLanguageLevelFile(f)) {", "-          if (triple != null) {  // if triple is null, we do not actually need to augment this file--it wasn't visited.", "-            ", "-            // Do code augmentation", "-            BufferedReader br = new BufferedReader(new FileReader(f), INPUT_BUFFER_SIZE);", "-            StringWriter sw = new StringWriter();", "-            BufferedWriter bw = new BufferedWriter(sw);", "-            ", "-            // _log.log(\"Augmenting the source file \" + sf);", "+        File augmentedFile = getJavaForLLFile(f);   // create  empty .java file for .dj? file", "+        ", "+        if (isAdvancedFile(f)) { Utilities.copyFile(f, augmentedFile); }", "+        else {", "+          BufferedReader tempBr = new BufferedReader(new FileReader(f));", "+          String firstLine = tempBr.readLine();", "+          tempBr.close(); // Important to close the reader, otherwise Windows will not allow the renameTo call later.", "+          if (firstLine == null) continue;", "+          ", "+          // If the file has an appropriate LL extension, then parse it.", "+          if (isLanguageLevelFile(f)) {", "+            if (triple != null) {  // if triple is null, we do not actually need to augment this file--it wasn't visited.", "+              ", "+              // Do code augmentation", "+              BufferedReader br = new BufferedReader(new FileReader(f), INPUT_BUFFER_SIZE);", "+              StringWriter sw = new StringWriter();", "+              BufferedWriter bw = new BufferedWriter(sw);", "+              ", "+              // _log.log(\"Augmenting the source file \" + sf);", "-            Augmentor a = new Augmentor(SAFE_SUPPORT_CODE, br, bw, llv);", "-            sf.visit(a);", "-            ", "-            br.close();", "-            bw.close();", "-            ", "-            // write out the line number map and the augmented java file", "-            PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(augmentedFile)));", "-            SortedMap<Integer,Integer> lineNumberMap = a.getLineNumberMap();", "-            pw.println(\"// Language Level Converter line number map: dj*->java. Entries: \"+lineNumberMap.size());", "-            // We print out LINE_NUM_MAPPINGS_PER_LINE mappings per line, so we need numLines", "-            // at the top of the file, and one more for a descriptive comment.", "-            // That means we need to increase the line numbers in the generated java file by numLines+1", "-            int numLines = (int)Math.ceil(((double)lineNumberMap.size())/LINE_NUM_MAPPINGS_PER_LINE);", "-            int mapCount = 0;", "-            for(Map.Entry<Integer,Integer> e: lineNumberMap.entrySet()) {", "-              // e.getKey(): dj* line number; e.getValue(): java line number (must be increased by numLines)", "-              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==0) pw.print(\"//\");", "-              pw.printf(\" %5d->%-5d\", e.getKey(), (e.getValue()+numLines+1));", "-              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==LINE_NUM_MAPPINGS_PER_LINE-1) pw.println();", "-              ++mapCount;", "+              Augmentor a = new Augmentor(SAFE_SUPPORT_CODE, br, bw, llv);", "+              sf.visit(a);", "+              ", "+              br.close();", "+              bw.close();", "+              ", "+              // write out the line number map and the augmented java file", "+              PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(augmentedFile)));", "+              SortedMap<Integer,Integer> lineNumberMap = a.getLineNumberMap();", "+              pw.println(\"// Language Level Converter line number map: dj*->java. Entries: \"+lineNumberMap.size());", "+              // We print out LINE_NUM_MAPPINGS_PER_LINE mappings per line, so we need numLines", "+              // at the top of the file, and one more for a descriptive comment.", "+              // That means we need to increase the line numbers in the generated java file by numLines+1", "+              int numLines = (int)Math.ceil(((double)lineNumberMap.size())/LINE_NUM_MAPPINGS_PER_LINE);", "+              int mapCount = 0;", "+              for(Map.Entry<Integer,Integer> e: lineNumberMap.entrySet()) {", "+                // e.getKey(): dj* line number; e.getValue(): java line number (must be increased by numLines)", "+                if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==0) pw.print(\"//\");", "+                pw.printf(\" %5d->%-5d\", e.getKey(), (e.getValue()+numLines+1));", "+                if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==LINE_NUM_MAPPINGS_PER_LINE-1) pw.println();", "+                ++mapCount;", "+              }", "+              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE!=0) pw.println(); // print a newline unless we just printed one", "+              ", "+              String augmented = sw.toString();", "+              pw.write(augmented, 0, augmented.length());", "+              pw.close();", "-            if (mapCount%LINE_NUM_MAPPINGS_PER_LINE!=0) pw.println(); // print a newline unless we just printed one", "-            ", "-            String augmented = sw.toString();", "-            pw.write(augmented, 0, augmented.length());", "-            pw.close();", "-    }", "-    catch (Augmentor.Exception ae) {", "-      // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-      _addVisitorError(new Pair<String, JExpressionIF>(ae.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "-    }", "-    catch (IOException ioe) {", "-      // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-      _addVisitorError(new Pair<String, JExpressionIF>(ioe.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "+      catch (Augmentor.Exception ae) {", "+        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "+        _addVisitorError(new Pair<String, JExpressionIF>(ae.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "+      }", "+      catch (IOException ioe) {", "+        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "+        _addVisitorError(new Pair<String, JExpressionIF>(ioe.getMessage(), new NullLiteral(SourceInfo.NO_INFO)));", "+      }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "db4e7be2a75762d093351db8ee5588eb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocument.java", "commitBeforeChange": "2fb658b48f226ac294dbfa5245389f7e3e0f2a45", "commitAfterChange": "3be5538aa61c0f185dfcafebfa9cbad2c0b1e6d6", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 23, "signatureBeforeChange": "   public int findPrevDelimiter(int pos, char[] delims)", "signatureAfterChange": "   public int findPrevDelimiter(int pos, char[] delims) throws BadLocationException", "diff": ["-  public int findPrevDelimiter(int pos, char[] delims) {", "-    // Not implemented...", "-    return 0;", "+  public int findPrevDelimiter(int pos, char[] delims) throws BadLocationException {", "+    ", "+    int j, i;", "+    char c;", "+    String text = getText(DOCSTART, pos);", "+", "+    // Move reduced model to location pos", "+    _reduced.move(pos - _currentLocation);", "+", "+    // Walk backwards from specificed position", "+    for (i = pos-1; i != DOCSTART-1; i--) {", "+      c = text.charAt(i);", "+      // Check if character is one of the delimiters", "+      for (j = 0; j < delims.length; j++) {", "+\tif (c == delims[j]) {", "+\t  // Move reduced model to walker's location", "+\t  _reduced.move(i - pos);", "+\t  // Check if matching char is in comment or quotes", "+\t  if((_reduced.getStateAtCurrent().equals(ReducedModelState.INSIDE_LINE_COMMENT)) ||", "+\t     (_reduced.getStateAtCurrent().equals(ReducedModelState.INSIDE_BLOCK_COMMENT)) ||", "+\t     (_reduced.getStateAtCurrent().equals(ReducedModelState.INSIDE_SINGLE_QUOTE)) ||", "+\t     (_reduced.getStateAtCurrent().equals(ReducedModelState.INSIDE_DOUBLE_QUOTE))) {", "+\t    // Ignore matching char", "+\t  } else {", "+\t    // Return position of matching char", "+\t    _reduced.move(_currentLocation - i);", "+\t    return i;", "+\t  }", "+\t  _reduced.move(pos - i);", "+\t}", "+      }", "+    }", "+    _reduced.move(_currentLocation - pos);", "+    return ERROR_INDEX;"]}], "num": 14278}