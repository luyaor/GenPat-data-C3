{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e482c4a55f2f7bb75e3402247e8ec3c2", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "65005354a874808ae74622bd6dce933f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "b4cb953a15f76465c4fdfdd0a3efe47737f78efc", "commitAfterChange": "da8b20243b85298aada190df10fa721e07aae787", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "   private ExecutionError unmatchedFunctionError(String kind, UnmatchedLookupException e, Node node, Type type,                                                 String name, Iterable<? extends Type> targs,                                                 Iterable<? extends Expression> args, Option<Type> expected,                                                 boolean onlyStatic)", "signatureAfterChange": "   private ExecutionError unmatchedFunctionError(String kind, UnmatchedLookupException e, Node node, Type type,                                                 String name, Iterable<? extends Type> targs,                                                 Iterable<? extends Expression> args, Option<Type> expected,                                                 boolean onlyStatic)", "diff": ["+    boolean noMatch = false;", "+      if (IterUtil.isEmpty(candidates)) { noMatch = true; }", "-    if (!IterUtil.isEmpty(targs)) { error += \".poly\"; }", "-    if (expected.isSome()) { error += \".expected\"; }", "-    if (!IterUtil.isEmpty(candidates)) { error += \".candidates\"; }", "+    if (error.equals(\"no.such.method\") && noMatch) { error += \".name\"; }", "+    else {", "+      if (!IterUtil.isEmpty(targs)) { error += \".poly\"; }", "+      if (expected.isSome()) { error += \".expected\"; }", "+      if (!IterUtil.isEmpty(candidates)) { error += \".candidates\"; }", "+    }", "-      candidatesS = IterUtil.toString(IterUtil.map(candidates, SIGNATURE_STRING), prefix, \",\" + prefix, \"\");", "+      candidatesS = IterUtil.toString(IterUtil.map(candidates, SIGNATURE_STRING), prefix, prefix, \"\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "869963c0d437dd4fbbad23d8a1397e7c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/CompilerErrorModel.java", "commitBeforeChange": "44ddda83470592c7bd9b1642405bd9ef5785367f", "commitAfterChange": "f3cec878a36c37903881e7e5ebc712640ce9c55f", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "   private void _calculatePositions()", "signatureAfterChange": "   private void _calculatePositions()", "diff": ["-", "-          // create new positions for all errors on this line", "-          while ((curError < _numErrors) && file.equals(_errors[curError].file()) &&  // we are still in this file", "-                 (_errors[curError].lineNumber() == curLine)) {", "-            _positions[curError] = document.createPosition(offset + _errors[curError].startColumn());", "-            curError++;", "+          // create new positions for all errors on this line          ", "+          boolean didNotAdvance = false;", "+          if (_errors[curError].lineNumber() != curLine) {", "+            // if this happens, then we will not advance to the next error in the loop below.", "+            // that means we have to advance curError when we reach the end of the document", "+            // or we get stuck in an infinite loop (bug 1679178)", "+            // this seems to be a problem with incompatible line endings (Windows vs. Unix)", "+            didNotAdvance = true;", "+          }", "+          else {", "+            while ((curError < _numErrors) &&", "+                   file.equals(_errors[curError].file()) &&  // we are still in this file", "+                   (_errors[curError].lineNumber() == curLine)) {", "+              _positions[curError] = document.createPosition(offset + _errors[curError].startColumn());", "+              curError++;", "+            }", "+              else {", "+                // we're at the end of the document", "+                if (didNotAdvance) {", "+                  // we did not advance to the next error above, so unless we want to", "+                  // get stuck in an infinite loop (bug 1679178), we have to advance now.", "+                  // otherwise we would never leave the while loop and keep processing", "+                  // the same error.", "+                  // this situation probably means that the line number information of the", "+                  // compiler is different from our line number information;", "+                  // probably a Windows vs. Unix line ending problem", "+                  _positions[curError] = null;", "+                  curError++;", "+                }", "+              }"]}], "num": 12764}