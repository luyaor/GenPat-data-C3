{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0c75a235379b7c60c85756207c8faadd", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6b7a7de54f36c47c5be5dddf10ec20f0", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 82, "methodNumberAfterChange": 82, "signatureBeforeChange": "\r     \r     public void testLookupFromClassesToBeParsed()", "signatureAfterChange": "          public void testLookupFromClassesToBeParsed()", "diff": ["-    \r", "-    public void testLookupFromClassesToBeParsed() {\r", "-      // Create a ClassDef.  Recreate the ClassOrInterfaceType for Object instead of using \r", "-      // JExprParser.NO_TYPE since otherwise the ElementaryVisitor will complain that the\r", "-      // user must explicitly extend Object.\r", "-      ClassDef cd = new ClassDef(JExprParser.NO_SOURCE_INFO, _publicMav, new Word(JExprParser.NO_SOURCE_INFO, \"Lisa\"),\r", "-                                 new TypeParameter[0], new ClassOrInterfaceType(JExprParser.NO_SOURCE_INFO, \"Object\", new Type[0]), new ReferenceType[0], \r", "-                                 new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));\r", "-      \r", "-      // Use a ElementaryVisitor so lookupFromClassesToBeParsed will actually visit the ClassDef.\r", "-      ElementaryVisitor bv = new ElementaryVisitor(new File(\"\"), errors, symbolTable, continuations, new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>(), new Hashtable<SymbolData, LanguageLevelVisitor>(), targetVersion);\r", "-      \r", "-      // Test that passing resolve equals false returns a continuation.\r", "-      assertTrue(\"Should return a continuation\", _llv._lookupFromClassesToBeParsed(\"Lisa\", JExprParser.NO_SOURCE_INFO, false).isContinuation());\r", "-      // Put Lisa in the hierarchy and test that there is one error and that the message\r", "-      // says that there is cyclic inheritance.\r", "-//      _hierarchy.put(\"Lisa\", cd);\r", "-//      _classesToBeParsed.put(\"Lisa\", new Pair<TypeDefBase, LanguageLevelVisitor>(cd, bv));\r", "-//      assertEquals(\"Should return null because Lisa is in the hierarchy\", \r", "-//                   null,\r", "-//                   _llv._lookupFromClassesToBeParsed(\"Lisa\", JExprParser.NO_SOURCE_INFO, true));\r", "-//      assertEquals(\"Should be one error\", 1, errors.size());\r", "-//      assertEquals(\"Error message should be correct\", \"Cyclic inheritance involving Lisa\", errors.get(0).getFirst());\r", "-//      _hierarchy.remove(\"Lisa\");\r", "-      //Re-add Lisa because the first call with resolve set to true removed it and\r", "-      // test that Lisa is actually visited and added to the symbolTable.\r", "-      _classesToBeParsed.put(\"Lisa\", new Pair<TypeDefBase, LanguageLevelVisitor>(cd, bv));\r", "-      assertFalse(\"Should return a non-continuation\", \r", "-                  _llv._lookupFromClassesToBeParsed(\"Lisa\", \r", "-                                                    JExprParser.NO_SOURCE_INFO,\r", "-                                                    true).isContinuation());\r", "-    }\r", "+    ", "+    public void testLookupFromClassesToBeParsed() {", "+      // Create a ClassDef.  Recreate the ClassOrInterfaceType for Object instead of using ", "+      // JExprParser.NO_TYPE since otherwise the ElementaryVisitor will complain that the", "+      // user must explicitly extend Object.", "+      ClassDef cd = new ClassDef(JExprParser.NO_SOURCE_INFO, _publicMav, new Word(JExprParser.NO_SOURCE_INFO, \"Lisa\"),", "+                                 new TypeParameter[0], new ClassOrInterfaceType(JExprParser.NO_SOURCE_INFO, \"Object\", new Type[0]), new ReferenceType[0], ", "+                                 new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));", "+      ", "+      // Use a ElementaryVisitor so lookupFromClassesToBeParsed will actually visit the ClassDef.", "+      ElementaryVisitor bv = new ElementaryVisitor(new File(\"\"), errors, symbolTable, continuations, new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>(), new Hashtable<SymbolData, LanguageLevelVisitor>());", "+      ", "+      // Test that passing resolve equals false returns a continuation.", "+      assertTrue(\"Should return a continuation\", _llv._lookupFromClassesToBeParsed(\"Lisa\", JExprParser.NO_SOURCE_INFO, false).isContinuation());", "+      // Put Lisa in the hierarchy and test that there is one error and that the message", "+      // says that there is cyclic inheritance.", "+//      _hierarchy.put(\"Lisa\", cd);", "+//      _classesToBeParsed.put(\"Lisa\", new Pair<TypeDefBase, LanguageLevelVisitor>(cd, bv));", "+//      assertEquals(\"Should return null because Lisa is in the hierarchy\", ", "+//                   null,", "+//                   _llv._lookupFromClassesToBeParsed(\"Lisa\", JExprParser.NO_SOURCE_INFO, true));", "+//      assertEquals(\"Should be one error\", 1, errors.size());", "+//      assertEquals(\"Error message should be correct\", \"Cyclic inheritance involving Lisa\", errors.get(0).getFirst());", "+//      _hierarchy.remove(\"Lisa\");", "+      //Re-add Lisa because the first call with resolve set to true removed it and", "+      // test that Lisa is actually visited and added to the symbolTable.", "+      _classesToBeParsed.put(\"Lisa\", new Pair<TypeDefBase, LanguageLevelVisitor>(cd, bv));", "+      assertFalse(\"Should return a non-continuation\", ", "+                  _llv._lookupFromClassesToBeParsed(\"Lisa\", ", "+                                                    JExprParser.NO_SOURCE_INFO,", "+                                                    true).isContinuation());", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "813aa3d817fe8fd28c62e8bf8431051b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 97, "methodNumberAfterChange": 22, "signatureBeforeChange": "          public void testLookupFromClassesToBeParsed()", "signatureAfterChange": "   protected SymbolData getQualifiedSymbolData(String qualClassName)", "diff": ["+    * searches imported files, primitive types, as well as types in the symbol table. */", "+  protected SymbolData getQualifiedSymbolData(String qualClassName) {", "+    return getQualifiedSymbolData(qualClassName, SourceInfo.NO_INFO);", "+  }", "-    public void testLookupFromClassesToBeParsed() {", "-      // Create a ClassDef.  Recreate the ClassOrInterfaceType for Object instead of using ", "-      // JExprParser.NO_TYPE since otherwise the ElementaryVisitor will complain that the", "-      // user must explicitly extend Object.", "-      ClassDef cd = ", "-        new ClassDef(SourceInfo.NO_INFO, _publicMav, ", "-                     new Word(SourceInfo.NO_INFO, \"Lisa\"),", "-                     new TypeParameter[0], ", "-                     new ClassOrInterfaceType(SourceInfo.NO_INFO, \"Object\", new Type[0]), ", "-                     new ReferenceType[0], ", "-                     new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "-      ", "-      // Use a ElementaryVisitor so lookupFromClassesToBeParsed will actually visit the ClassDef.", "-      IntermediateVisitor bv = new IntermediateVisitor(new File(\"\"), ", "-                                                       errors, ", "-                                                       continuations, ", "-                                                       new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>());", "-      ", "-      // Test that passing resolve equals false returns a continuation.", "-      assertTrue(\"Should return a continuation\", ", "-                 testLLVisitor._lookupFromClassesToBeParsed(\"Lisa\", SourceInfo.NO_INFO, false).isContinuation());", "-      // Put Lisa in the hierarchy and test that there is one error and that the message", "-      // says that there is cyclic inheritance.", "-//      _hierarchy.put(\"Lisa\", cd);", "-//      _classesToBeParsed.put(\"Lisa\", new Pair<TypeDefBase, LanguageLevelVisitor>(cd, bv));", "-//      assertEquals(\"Should return null because Lisa is in the hierarchy\", ", "-//                   null,", "-//                   _llv._lookupFromClassesToBeParsed(\"Lisa\", SourceInfo.NO_INFO, true));", "-//      assertEquals(\"Should be one error\", 1, errors.size());", "-//      assertEquals(\"Error message should be correct\", \"Cyclic inheritance involving Lisa\", errors.get(0).getFirst());", "-//      _hierarchy.remove(\"Lisa\");", "-      //Re-add Lisa because the first call with resolve set to true removed it and", "-      // test that Lisa is actually visited and added to the symbolTable.", "-      testLLVisitor._classesToBeParsed.put(\"Lisa\", new Pair<TypeDefBase, LanguageLevelVisitor>(cd, bv));", "-      assertFalse(\"Should return a non-continuation\", ", "-                  testLLVisitor._lookupFromClassesToBeParsed(\"Lisa\", ", "-                                                    SourceInfo.NO_INFO,", "-                                                    true).isContinuation());", "-    }"]}], "num": 25074}