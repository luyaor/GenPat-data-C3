{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9ae8fe052052c6c40b90e34fff13e4db", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "818da24ecac92bb4abd4025ed4229039", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/indent/ActionStartStmtOfBracePlus.java", "commitBeforeChange": "a33dd9cdb6eaad3925dbd0230d8fd4013b8f8126", "commitAfterChange": "345a82c54e3e67af4bf9681fbb22f96d3e1754eb", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "   public boolean indentLine(AbstractDJDocument doc, Indenter.IndentReason reason)", "signatureAfterChange": "   public boolean indentLine(AbstractDJDocument doc, Indenter.IndentReason reason)", "diff": ["-    boolean supResult = super.indentLine(doc, reason);", "+    boolean supResult = super.indentLine(doc, reason); // This call does nothing other than record some indent tracing", "-    // If there is no brace, align to left margin", "+    // If there is no brace, align to left margin; can't happen when called from rule 19", "-    // Get the absolute position of the brace", "-    int bracePos = pos - distToLineEnclosingBrace;", "-", "-    String indent = \"\";", "-    try {", "-      indent = doc.getIndentOfCurrStmt(bracePos);", "-    } catch (BadLocationException e) {", "-      // Should not happen", "-      throw new UnexpectedException(e);", "-    }", "-    indent = indent + _suffix;", "+    // Get the absolute position of the (left edge of the) brace", "+    final int bracePos = pos - distToLineEnclosingBrace;", "+    final String indent = doc.getIndentOfCurrStmt(bracePos) + _suffix;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a54e35800b711b96c7ea3637eef391a6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/indent/QuestionCurrLineEmpty.java", "commitBeforeChange": "42669dc5656697beebfecb16842ba181e2bab301", "commitAfterChange": "ab72ce86901addf5fe2a66f48b9dc4c5f7db818b", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "   boolean applyRule(DefinitionsDocument doc)", "signatureAfterChange": "   boolean applyRule(DefinitionsDocument doc)", "diff": ["-    // one solution: if startOfLine somehow tells you when ", "-    //   there's no first WS char on this line", "-    //   (i.e. the line is empty), just use that.", "-    // otherwise:", "-    // START = findPrevDelimiter(start of statement)   --START", "-    // END = go forward to find first \\n or EOF", "-    // return true if there's only WS between START and END    ", "-", "-    throw new RuntimeException(\"Not yet implemented!\");", "+    try {", "+      // Determine if there are only whitespace chars by seeing if the", "+      //  first non-WS char is the endOfLine", "+      int here = doc.getCurrentLocation();", "+      int endOfLine = doc.getLineEndPos(here);", "+      int firstNonWS = doc.getLineFirstCharPos(here);", "+      return (endOfLine == firstNonWS);", "+    }", "+    catch (BadLocationException e) {", "+      // Shouldn't happen", "+      throw new UnexpectedException(e);", "+    }"]}], "num": 15505}