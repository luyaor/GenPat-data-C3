{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "878a4f94bbab3bad511998cb2dc0d53c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "59cdba55172d2cd2675cf66268dcedac", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/jpda/JPDADebugger.java", "commitBeforeChange": "5293cb4cfbc2f45d6061ba4101ad60348aa251ed", "commitAfterChange": "f68f43e5a680bb235f87f6125c6c0de6d15a12f4", "methodNumberBeforeChange": 78, "methodNumberAfterChange": 74, "signatureBeforeChange": "   private void _defineVariable(ThreadReference suspendedThreadRef,                                ObjectReference debugInterpreter,                                String name, Value val, Type type)     throws InvalidTypeException, IncompatibleThreadStateException,       ClassNotLoadedException, InvocationException, DebugException", "signatureAfterChange": "   private ReferenceType _getClass(String name) throws DebugException", "diff": ["-   */", "-  private void _defineVariable(ThreadReference suspendedThreadRef,", "-                               ObjectReference debugInterpreter,", "-                               String name, Value val, Type type)", "-    throws InvalidTypeException, IncompatibleThreadStateException,", "-      ClassNotLoadedException, InvocationException, DebugException", "-  {", "-    ReferenceType rtDebugInterpreter = debugInterpreter.referenceType();", "-    Method method2Call = _getDefineVariableMethod(rtDebugInterpreter,  val);", "-", "-    // invokeMethod would throw an ObjectCollectedException if the StringReference", "-    // declared by _vm.mirrorOf(name) had been garbage collected before", "-    // invokeMethod could execute. We now just disable collection until after the", "-    // method is invoked.", "-", "-    int tries = 0;", "-    StringReference sr = null;", "-    while (tries < OBJECT_COLLECTED_TRIES) {", "-        //Added parameterization <Value>.", "-        List<Value> args = new LinkedList<Value>();  ", "-        /* Mirror is the common supertype of StringReference, Value, and ReferenceType.  Changed from Mirror to Value ", "-         * because invokeMethod requires a List of Value type. It does not need to be a Mirror because neither sr nor ", "-         * val can be a ReferenceType */", "-        sr = _vm.mirrorOf(name);", "-        sr.disableCollection();", "-        args.add(sr);", "-        args.add(val);", "-        if (type == null) args.add(null);", "-        else if (type instanceof ReferenceType) {", "-          args.add(((ReferenceType)type).classObject());", "-", "-        /* System.out.println(\"Calling \" + method2Call.toString() + \"with \" + args.get(0).toString()); */", "-        debugInterpreter.invokeMethod(suspendedThreadRef, method2Call, args, ObjectReference.INVOKE_SINGLE_THREADED);", "-        return;", "-      catch (ObjectCollectedException oce) {", "-        tries++;", "-      }", "-      finally {", "-        sr.enableCollection();", "-      }", "-    throw new DebugException(\"The variable: \" + name +", "-                             \" could not be defined in the debug interpreter\");", "+    */", "+  private ReferenceType _getClass(String name) throws DebugException {", "+    List<ReferenceType> classes = _vm.classesByName(name);", "+    if (classes.isEmpty()) {", "+      throw new DebugException(\"Class '\" + name + \"' is not loaded\");", "+    }", "+    else {", "+      for (ReferenceType t : classes) {", "+        // class loader is null iff it comes from the bootstrap loader", "+        if (t.classLoader() == null) { return t; }", "+      }", "+      return classes.get(0);", "+    }", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9867ece44f5e185f033151b3b8ce2db2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/jpda/JPDADebugger.java", "commitBeforeChange": "5293cb4cfbc2f45d6061ba4101ad60348aa251ed", "commitAfterChange": "f68f43e5a680bb235f87f6125c6c0de6d15a12f4", "methodNumberBeforeChange": 75, "methodNumberAfterChange": 97, "signatureBeforeChange": "   private ObjectReference _getDebugInterpreter(String interpreterName, ThreadReference threadRef) throws      InvalidTypeException, ClassNotLoadedException, IncompatibleThreadStateException, InvocationException,      DebugException", "signatureAfterChange": "   private static Value _invokeMethod(ThreadReference thread, ObjectReference receiver, String name,                               String signature, Value... args) throws DebugException", "diff": ["-   */", "-  private ObjectReference _getDebugInterpreter(String interpreterName, ThreadReference threadRef) throws ", "-    InvalidTypeException, ClassNotLoadedException, IncompatibleThreadStateException, InvocationException, ", "-    DebugException {", "-    ", "-    if (!threadRef.isSuspended()) {", "-      throw new IllegalStateException(\"threadRef must be suspended to get a debug interpreter.\");", "-    }", "-", "-    // Get the method to return the interpreter", "-    Method m = _getMethod(_interpreterJVM.referenceType(), \"getJavaInterpreter\");", "-", "-    // invokeMethod would throw an ObjectCollectedException if the StringReference", "-    // declared by _vm.mirrorOf(name) had been garbage collected before", "-    // invokeMethod could execute. We now just disable collection until after the", "-    // method is invoked.", "-", "-    int tries = 0;", "-    StringReference sr = null;", "-    while (tries < OBJECT_COLLECTED_TRIES) {", "-      try{", "-        LinkedList<StringReference> args = new LinkedList<StringReference>(); //Added parameterization <StringReference>.", "-        sr = _vm.mirrorOf(interpreterName);", "-        sr.disableCollection();", "-        args.add(sr); // make the String a JDI Value", "-        _log.log(\"Invoking \" + m.toString() + \" on \" + args.toString());", "-        _log.log(\"Thread is \" + threadRef.toString() + \" <suspended = \" + threadRef.isSuspended() + \">\");", "-", "-        ObjectReference tmpInterpreter = ", "-          (ObjectReference) _interpreterJVM.invokeMethod(threadRef, m, args, ObjectReference.INVOKE_SINGLE_THREADED);", "-", "-        _log.log(\"Returning...\");", "-        return tmpInterpreter;", "-      }", "-      catch (ObjectCollectedException e) { tries++; }", "-      finally { sr.enableCollection(); }", "-    }", "-    throw new DebugException(\"The debugInterpreter: \" + interpreterName + \" could not be obtained from interpreterJVM\");", "-  }", "+    */", "+  private static Value _invokeMethod(ThreadReference thread, ObjectReference receiver, String name,", "+                              String signature, Value... args) throws DebugException {", "+    try {", "+      ClassType c = (ClassType) receiver.referenceType();", "+      Method m = c.concreteMethodByName(name, signature);", "+      if (m == null) { throw new DebugException(\"Cannot find method '\" + name + \"'\"); }", "+      return receiver.invokeMethod(thread, m, Arrays.asList(args),", "+                                   ObjectReference.INVOKE_SINGLE_THREADED);", "+    }", "+    catch (ClassNotPreparedException e) { throw new DebugException(e); }", "+    catch (IllegalArgumentException e) { throw new DebugException(e); }", "+    catch (ClassNotLoadedException e) { throw new DebugException(e); }", "+    catch (IncompatibleThreadStateException e) { throw new DebugException(e); }", "+    catch (InvocationException e) { throw new DebugException(e); }", "+    catch (InvalidTypeException e) { throw new DebugException(e); }", "+  }"]}], "num": 26691}