{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2bac349e285b8b9c8c6020f24e38f3c6", "detectedBy": ["DIFF_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a82db1fc525213d3d0ca47435b278405", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/FullJavaVisitor.java", "commitBeforeChange": "ce0ecf66ce1ecec7e4abe0bd534cf2fbbb576f91", "commitAfterChange": "4e52eec7688cbd5ec3584417f424923ba61a75e0", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": "   protected void handleInnerInterfaceDef(InnerInterfaceDef that, Data data, String relName, String name)", "signatureAfterChange": "   protected void handleInnerInterfaceDef(InnerInterfaceDef that, Data data, String relName, String name)", "diff": ["-     // The following assert should be true because interfaces can't have fields!", "-    assert that.getTypeParameters().length == 0;", "+    // Create a new generic types table for visiting this inner class.", "+    // TODO: refactor this code to combine common code patterns in this method and forInnerClassDef", "+    HashMap<String, SymbolData> genericTypes = (HashMap<String, SymbolData>) _genericTypes.clone();", "+    TypeParameter[] tps = that.getTypeParameters();", "+    for (TypeParameter tp: tps) {", "+      final String typeName = tp.getVariable().getName();", "+      final String boundName = tp.getBound().getName();", "+      SymbolData boundSD = _identifyType(boundName, that.getSourceInfo(), _enclosingClassName);", "+      if (boundSD == null) { // create a dummy SymbolData ", "+        boundSD = SymbolData.NOT_FOUND; //  TODO: could create a separate SymbolData.NOT_BOUND singleton class?", "+//        System.err.println(\"Creating dummy SymbolData for bounding type \" + typeName + \" in inner class \" + name);", "+      }", "+      genericTypes.put(typeName, boundSD);", "+    }", "+    /* The following line apparently does nothing.  Note that it is NOT in the scope of the new generic types", "+     * table.  TODO: confirm that this line does nothing and eliminate it. */", "-    SymbolData sd = defineInnerSymbolData(that, relName, name, data);", "-    if (sd != null) {", "-      that.getBody().visit(new InterfaceBodyFullJavaVisitor(sd, _file, _package, _importedFiles, _importedPackages,", "-                                                            _classesInThisFile, continuations, fixUps));", "+    /* The following line is NOT in the scope of the new generic type table but should be.  Since we are not", "+     * performing generic type checking, we may get away with the error.  TODO: refactor this code to", "+     * create a new LLV for processing a generic class. */", "+    SymbolData sd = defineInnerSymbolData(that, relName, name, data);  // only returns null if error is encountered", "+    ", "+    if (sd != null) { // We have a symbol data to work with, so visit the body using the new generic types table", "+      sd.setInterface(true);", "+      identifyInnerClasses(that);", "+      InterfaceBodyFullJavaVisitor ibfjv = ", "+        new InterfaceBodyFullJavaVisitor(sd, _file, _package, _importedFiles, _importedPackages, _classesInThisFile, ", "+                                         continuations, fixUps, genericTypes);", "+      that.getBody().visit(ibfjv);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3963ff3b1f1e660f87649fca989571a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/FullJavaVisitor.java", "commitBeforeChange": "ce0ecf66ce1ecec7e4abe0bd534cf2fbbb576f91", "commitAfterChange": "4e52eec7688cbd5ec3584417f424923ba61a75e0", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 26, "signatureBeforeChange": "   public Void forInterfaceDef(InterfaceDef that)", "signatureAfterChange": "   public Void forInterfaceDef(InterfaceDef that)", "diff": ["-    // The following assert should be true because interfaces can't have fields!", "-    assert that.getTypeParameters().length == 0;", "+    // Create a new generic types table for visiting this inner class.", "+    // TODO: refactor this code to combine common code patterns in this method and forInnerClassDef", "+    HashMap<String, SymbolData> genericTypes = (HashMap<String, SymbolData>) _genericTypes.clone();", "+    TypeParameter[] tps = that.getTypeParameters();", "+    for (TypeParameter tp: tps) {", "+      final String typeName = tp.getVariable().getName();", "+      final String boundName = tp.getBound().getName();", "+      SymbolData boundSD = _identifyType(boundName, that.getSourceInfo(), _enclosingClassName);", "+      if (boundSD == null) { // create a dummy SymbolData ", "+        boundSD = SymbolData.NOT_FOUND; //  TODO: could create a separate SymbolData.NOT_BOUND singleton class?", "+//        System.err.println(\"Creating dummy SymbolData for bounding type \" + typeName + \" in inner class \" + name);", "+      }", "+      genericTypes.put(typeName, boundSD);", "+    }", "+    /* The following line apparently does nothing.  Note that it is NOT in the scope of the new generic types", "+     * table.  TODO: confirm that this line does nothing and eliminate it. */", "-      identifyInnerClasses(that);  // inner interfaces??", "-      that.getBody().visit(new InterfaceBodyFullJavaVisitor(sd, _file, _package, _importedFiles, _importedPackages,", "-                                                            _classesInThisFile, continuations, fixUps));", "+      identifyInnerClasses(that);", "+      InterfaceBodyFullJavaVisitor ibfjv =", "+        new InterfaceBodyFullJavaVisitor(sd, _file, _package, _importedFiles, _importedPackages, _classesInThisFile, ", "+                                         continuations, fixUps, genericTypes);", "+      that.getBody().visit(ibfjv);"]}], "num": 7883}