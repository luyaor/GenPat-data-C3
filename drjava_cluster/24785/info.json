{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "80f6c634a84e69d02e43278c4492a84d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a135470c6f83ab2f177af617c382c216", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/config/VectorOptionComponent.java", "commitBeforeChange": "893c07e82b5df8a5ee457745ae613e9f4f3395b7", "commitAfterChange": "e7565df68be50967f0383d34df0b493ae42a4e83", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public VectorOptionComponent(VectorOption<T> opt, String text, SwingFrame parent, String[] colNames)", "signatureAfterChange": "   public VectorOptionComponent(VectorOption<T> opt, String text, SwingFrame parent, String[] colNames,                                String description, boolean moveButtonEnabled)", "diff": ["+    */", "+  public VectorOptionComponent(VectorOption<T> opt, String text, SwingFrame parent, String[] colNames,", "+                               String description, boolean moveButtonEnabled) {", "+    _moveButtonEnabled = moveButtonEnabled;", "-    _tableModel = _makeTableModel();", "+    _tableModel = _makeDecoratedTableModel(_makeTableModel());", "-        final TableCellRenderer renderer = getTableHeader().getDefaultRenderer();", "-        ", "-        for (int i=0;i<getColumnCount(); ++i) {", "-          int w = renderer.getTableCellRendererComponent(this,getModel().getColumnName(i), false, false, 0, i).getPreferredSize().width;", "-          getColumnModel().getColumn(i).setPreferredWidth(w);", "-        }", "+        // set the column with the \"remove\" buttons to width 18 (icon is width 16)", "+        getColumnModel().getColumn(getColumnCount()-1).setMinWidth(18);", "+        getColumnModel().getColumn(getColumnCount()-1).setMaxWidth(18);", "+      // auto size the columns", "+    // if moving up and down is enabled, allow column drag and drop", "+    if (_moveButtonEnabled) {", "+      _table.setUI(new DragDropRowTableUI());", "+    }", "+    _table.setColumnSelectionAllowed(false);", "-", "-    _addButton = new JButton(_getAddAction());", "-    _removeButton = new JButton(new AbstractAction(\"Remove\") {", "-      public void actionPerformed(ActionEvent ae) {", "-        int[] rows = _table.getSelectedRows();", "-        if (rows.length>0) {", "-          // remove starting from the back so the indices don't have to be adjusted", "-          for(int i=rows.length-1; i>=0; --i) {", "-            _removeIndex(rows[i]);", "-          }", "-          int last = rows[rows.length-1];", "-          if (last==_data.size()) { // we removed the last element", "-            if (last>0) { // and there's more than one element in the list", "-              _table.getSelectionModel().setSelectionInterval(last-1,last-1);", "-            }", "-          }", "-          else {", "-            _table.getSelectionModel().setSelectionInterval(last,last);", "-          }", "-          notifyChangeListeners();", "-        }", "+    _table.getTableHeader().setReorderingAllowed(false);", "+    ", "+    // create the remove button", "+    final JButton removeButton = new CommonCloseButton();", "+    ButtonEditor buttonEditor = new ButtonEditor(removeButton);", "+    removeButton.addActionListener(new ActionListener() {", "+      public void actionPerformed(ActionEvent e) {", "+        _removeAction();", "-    ", "-    /* Only used in VectorFileOptionComponent subclass */", "+    // add remove button as default renderer/editor for buttons", "+    _table.setDefaultRenderer(JButton.class, new ComponentCellRenderer());", "+    _table.setDefaultEditor(JButton.class, buttonEditor);", "+", "+    // create other buttons", "+    _addButton = new JButton(_getAddAction());    ", "-        int[] rows = _table.getSelectedRows();", "-        if (rows.length>0) {", "-          _table.getSelectionModel().clearSelection();", "-          for(int i=0; i<rows.length; ++i) {", "-            if (rows[i]>0) {", "-              T el = _data.remove(rows[i]);", "-              _data.insertElementAt(el, rows[i]-1);", "-              _table.getSelectionModel().addSelectionInterval(rows[i]-1,rows[i]-1);", "-              _tableModel.fireTableRowsUpdated(rows[i]-1,rows[i]);", "-            }", "-          }", "-          notifyChangeListeners();", "-        }", "+        _moveUpAction();", "-", "-    /* Only used in VectorFileOptionComponent subclass */", "-        int[] rows = _table.getSelectedRows();", "-        if (rows.length>0) {", "-          _table.getSelectionModel().clearSelection();", "-          for(int i=0; i<rows.length; ++i) {", "-            if (rows[i]<_data.size()-1) {", "-              T el = _data.remove(rows[i]);", "-              _data.insertElementAt(el, rows[i]+1);", "-              _table.getSelectionModel().addSelectionInterval(rows[i]+1,rows[i]+1);", "-              _tableModel.fireTableRowsUpdated(rows[i],rows[i]+1);", "-            }", "-          }", "-          notifyChangeListeners();", "-        }", "+        _moveDownAction();", "-    _buttonPanel = new JPanel();", "-    _buttonPanel.setBorder(new EmptyBorder(5,5,5,5));", "-    _buttonPanel.setLayout(new BoxLayout(_buttonPanel, BoxLayout.X_AXIS));", "-    ", "-    _buttonPanel.add(Box.createHorizontalGlue());", "-    _addButtons(); // all buttons needs to be added consecutively as a group for glue to work properly               ", "-    _buttonPanel.add(Box.createHorizontalGlue());", "+    // list of buttons", "+    final java.util.List<JButton> buttons = getButtons();", "+    // table model of buttons, for the table situated under the values table", "+    // one row, n buttons", "+    _buttonTableModel = new AbstractTableModel() {", "+      public String getColumnName(int col) { return \"\"; }", "+      public int getRowCount() { return 1; }", "+      public int getColumnCount() { return buttons.size(); }", "+      public Object getValueAt(int row, int column) { return buttons.get(column); }", "+      public Class getColumnClass(int col) { return JButton.class; }", "+      public boolean isCellEditable(int row, int col) { return true; }", "+      public void setValueAt(Object value, int row, int col) { fireTableCellUpdated(row, col); }", "+    };", "+    // button table", "+    _buttonTable = new JTable(_buttonTableModel);", "+    _buttonTable.setColumnSelectionAllowed(false);", "+    _buttonTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);", "+    _buttonTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);", "+    _buttonTable.getTableHeader().setReorderingAllowed(false);", "+    // add button editors/renderers to the button table", "+    for(int i=0; i<_buttonTable.getColumnCount(); ++i) {      ", "+      buttonEditor = new ButtonEditor(buttons.get(i));", "+      _buttonTable.getColumnModel().getColumn(i).setCellEditor(buttonEditor);", "+    }", "+    _buttonTable.setDefaultRenderer(JButton.class, new ComponentCellRenderer());", "+    _buttonTable.setTableHeader(null);", "+    ", "+    // if moving up and down is enabled, add a selection listener that", "+    // enabled and disables the move up/down buttons if we have enough elements", "+    // in the table and a row is selected", "+    if (_moveButtonEnabled) {", "+      ListSelectionListener selListener = new ListSelectionListener() {", "+        public void valueChanged(ListSelectionEvent e) {", "+          updateButtons();", "+        }", "+      };", "+      _table.getSelectionModel().addListSelectionListener(selListener);", "+      _table.getColumnModel().getSelectionModel().addListSelectionListener(selListener);    ", "+    }", "+    ", "+    // add components", "+    JPanel tablesPanel = new JPanel(new BorderLayout());", "+    tablesPanel.add(_tableScrollPane, BorderLayout.CENTER);", "+    tablesPanel.add(_buttonTable, BorderLayout.SOUTH);", "+", "-    _panel.add(_tableScrollPane, BorderLayout.CENTER);", "-    _panel.add(_buttonPanel, BorderLayout.SOUTH);", "+    _panel.add(tablesPanel, BorderLayout.CENTER);", "+    _panel.add(Box.createRigidArea(new Dimension(0,10)), BorderLayout.SOUTH);", "+", "+    setDescription(description);", "+    updateButtons();", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a49fa0af5ffe2945699cc7caed9fda73", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "c68bda7492524887225ee8f4963e9d7935485197", "commitAfterChange": "7e14052430c5a0fbe8641ad3a0f464f6b201c49d", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "   private SymbolData _classFile2SymbolData(String qualifiedClassName, String directoryName)", "signatureAfterChange": "   private SymbolData _classFile2SymbolData(String qualifiedClassName, String directoryName)", "diff": ["-    if (directoryName != null) {", "-      // Add the current directory to the class path bcel uses to find class files.", "-      ClassPath cp = new ClassPath(ClassPath.SYSTEM_CLASS_PATH + System.getProperty(\"path.separator\") + directoryName);", "-      SyntheticRepository sr = SyntheticRepository.getInstance(cp);", "-      Repository.setRepository(sr);", "-    }", "+    Iterable<File> searchPath = IterUtil.compose(LanguageLevelConverter.OPT.bootClassPath(),", "+                                                 LanguageLevelConverter.OPT.classPath());", "+    if (directoryName != null) { searchPath = IterUtil.compose(searchPath, new File(directoryName)); }", "-    JavaClass jc = Repository.lookupClass(qualifiedClassName);", "-    if (jc == null) {", "-      return null;", "+    ClassReader reader = null;", "+    try {", "+      /** We'll use this class loader to look up resources (*not* to load classes) */", "+      PathClassLoader loader = new PathClassLoader(EmptyClassLoader.INSTANCE, searchPath);", "+      InputStream stream = loader.getResourceAsStream(qualifiedClassName.replace('.', '/') + \".class\");", "+      if (stream == null) { return null; }", "+      // Let IOUtil handle the stream here, because it closes it when it's done, unlike ASM.", "+      reader = new ClassReader(IOUtil.toByteArray(stream));", "-    ", "+    catch (IOException e) { return null; }", "-    SymbolData sd = symbolTable.get(qualifiedClassName); ", "-    if (sd == null) {", "+    final SymbolData sd;", "+    SymbolData sdLookup = symbolTable.get(qualifiedClassName); ", "+    if (sdLookup == null) {", "+    else { sd = sdLookup; }", "-    // Set the modifiers and visibility", "-    sd.setMav(_createMav(jc));", "+    final SourceInfo lookupInfo = _makeSourceInfo(qualifiedClassName);", "+    final String unqualifiedClassName = getUnqualifiedClassName(qualifiedClassName);", "-    // Set the fields", "-    Field[] fields = jc.getFields();", "-    for (int i = 0; i < fields.length; i++) {", "-      String typeString = fields[i].getType().toString();", "-      SymbolData type;", "-      type = getSymbolDataForClassFile(typeString, _makeSourceInfo(qualifiedClassName));", "+    ClassVisitor extractData = new ClassVisitor() {", "-      // I assume we do not have to check for duplicate field names here since we're in a class file.", "-      // Pass in true for the second argument because we don't want to generate an accessor if it's from a class file.", "-      sd.addVar(new VariableData(fields[i].getName(), _createMav(fields[i]), type, true, sd)); //True by default", "-    }", "-    ", "-    // Set the methods", "-    String unqualifiedClassName = getUnqualifiedClassName(qualifiedClassName);", "-    Method[] methods = jc.getMethods();", "-    //We use a label here so that if a parameter's type can't be resolved, we skip this method.", "-    methodLoop: for (int i = 0; i < methods.length; i++) {", "-      SymbolData returnType;", "-      String methodName = methods[i].getName();", "-      // Check for a constructor, BCEL has them as void methods named <init>.", "-      if (methodName.equals(\"<init>\")) {", "-        // rename the name of the method to the unqualified class name and the return type to this SymbolData.", "-        methodName = unqualifiedClassName;", "-        returnType = sd;", "-      }", "-      else {", "-        //System.out.println(\"Trying to resolve method return type.\");", "-        returnType = getSymbolDataForClassFile(methods[i].getReturnType().toString(), _makeSourceInfo(qualifiedClassName));", "-      }", "-      ExceptionTable eTable = methods[i].getExceptionTable();", "-      // Get parameters", "-      org.apache.bcel.generic.Type[] paramTypes = methods[i].getArgumentTypes();", "-      LinkedList<VariableData> vdsList = new LinkedList<VariableData>();", "-      for (int j = 0; j < paramTypes.length; j++) {", "-        SymbolData tempSd = getSymbolDataForClassFile(paramTypes[j].toString(), _makeSourceInfo(qualifiedClassName));", "-        if (tempSd == null) {", "-", "-          // see getSymbolDataForClassFile's comments to see why this check is necessary.", "-          continue methodLoop;", "+      public void visit(int version, int access, String name, String sig, String sup, String[] interfaces) {", "+        sd.setMav(_createMav(access));", "+        sd.setInterface(Modifier.isInterface(access));", "+        ", "+        int slash = name.lastIndexOf('/');", "+        if (slash == -1) { sd.setPackage(\"\"); }", "+        else { sd.setPackage(name.substring(0, slash).replace('/', '.')); }", "+        ", "+        if (sup == null) { sd.setSuperClass(null); }", "+        else { sd.setSuperClass(getSymbolDataForClassFile(sup.replace('/', '.'), lookupInfo)); }", "+        ", "+        if (interfaces != null) {", "+          for (String iName : interfaces) {", "+            SymbolData superInterface = getSymbolDataForClassFile(iName.replace('/', '.'), lookupInfo);", "+            if (superInterface != null) { sd.addInterface(superInterface); }", "+          }", "-        vdsList.addLast(new VariableData(tempSd)); // a VariableData with only one argument is a parameter", "-      VariableData[] vds = (VariableData[]) vdsList.toArray(new VariableData[vdsList.size()]);", "+      public FieldVisitor visitField(int access, String name, String desc, String sig, Object value) {", "+        String typeString = org.objectweb.asm.Type.getType(desc).getClassName();", "+        SymbolData type = getSymbolDataForClassFile(typeString, lookupInfo);", "+        if (type != null) { sd.addVar(new VariableData(name, _createMav(access), type, true, sd)); }", "+        return null;", "+      }", "-      // Get thrown exceptions", "-      String[] throwStrings;", "-      if (eTable != null) { ", "-        throwStrings = eTable.getExceptionNames();", "+      public MethodVisitor visitMethod(int access, String name, String desc, String sig, String[] exceptions) {", "+        boolean valid = true;", "+        String methodName;", "+        SymbolData returnType;", "+        if (name.equals(\"<init>\")) {", "+          methodName = unqualifiedClassName;", "+          returnType = sd;", "+        }", "+        else {", "+          methodName = name;", "+          String returnString = org.objectweb.asm.Type.getReturnType(desc).getClassName();", "+          returnType = getSymbolDataForClassFile(returnString, lookupInfo);", "+          valid = valid && (returnType != null);", "+        }", "+        org.objectweb.asm.Type[] argTypes = org.objectweb.asm.Type.getArgumentTypes(desc);", "+        VariableData[] args = new VariableData[argTypes.length]; ", "+        for (int i = 0; i < argTypes.length; i++) {", "+          SymbolData argType = getSymbolDataForClassFile(argTypes[i].getClassName(), lookupInfo);", "+          if (argType == null) { valid = false; }", "+          else { args[i] = new VariableData(argType); }", "+        }", "+        if (exceptions == null) { exceptions = new String[0]; }", "+        for (int i = 0; i < exceptions.length; i++) {", "+          exceptions[i] = exceptions[i].replace('/', '.');", "+        }", "+        ", "+        if (valid) {", "+          MethodData m = new MethodData(methodName, _createMav(access), new TypeParameter[0], returnType,", "+                                        args, exceptions, sd, null);", "+          for (VariableData arg : args) { arg.setEnclosingData(m); }", "+          sd.addMethod(m, false, true);", "+        }", "+        return null;", "-      else {", "-        throwStrings = new String[0];", "-      }", "-      MethodData newMethod = new MethodData(methodName, ", "-                                  _createMav(methods[i]), ", "-                                  new TypeParameter[0], ", "-                                  returnType, ", "-                                  vds,", "-                                  throwStrings,", "-                                  sd,", "-                                  null); // no SourceInfo", "+      ", "+      public void visitSource(String source, String debug) {}", "+      public void visitOuterClass(String owner, String name, String desc) {}", "+      public AnnotationVisitor visitAnnotation(String desc, boolean visible) { return null; }", "+      public void visitAttribute(Attribute attr) {}", "+      public void visitInnerClass(String name, String outerName, String innerName, int access) {}", "+      public void visitEnd() {}", "-      ", "-      for (int k = 0; k<newMethod.getParams().length; k++) {", "-        newMethod.getParams()[k].setEnclosingData(newMethod);", "-      }", "-", "-      ", "-      sd.addMethod(newMethod, false, true);", "-      ", "-", "-    }", "- ", "-    // Set the superclass", "-    JavaClass superClass = jc.getSuperClass();", "-    if (superClass == null) {", "-      sd.setSuperClass(null);", "-    }", "-    else {", "-      sd.setSuperClass(getSymbolDataForClassFile(superClass.getClassName(), _makeSourceInfo(qualifiedClassName)));", "-    }", "+    };", "+    reader.accept(extractData, ClassReader.SKIP_CODE);", "-    // Set the interfaces", "-    JavaClass[] interfaces = jc.getInterfaces();", "-    if (interfaces != null) {", "-      for (int i = 0; i < interfaces.length; i++) {", "-        sd.addInterface(getSymbolDataForClassFile(interfaces[i].getClassName(), _makeSourceInfo(qualifiedClassName)));", "-      }", "-    }", "-    ", "-    //Set the package", "-    String pakage = jc.getPackageName();", "-    sd.setPackage(pakage);", "-    ", "-    //set the isInterface field  (if it's not a class, then it is an interface)", "-    sd.setInterface(!jc.isClass());"]}], "num": 24785}