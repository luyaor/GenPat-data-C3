{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0e8348b6f99ab6891ca4d34a6a69fed7", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2a85491f38bed3fc9c34c90aa60ab9b5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "commitAfterChange": "65fb8db1fb3e7570ae4fa352a26deb0e151b48ac", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "     protected Pair<LinkedList<MethodData>, LinkedList<MethodData>>      _getMatchingMethods(String methodName, SymbolData enclosingSD, InstanceData[] arguments, JExpression jexpr,                          boolean isConstructor, SymbolData thisSD)", "signatureAfterChange": "     protected Pair<LinkedList<MethodData>, LinkedList<MethodData>>      _getMatchingMethods(String methodName, SymbolData enclosingSD, InstanceData[] arguments, JExpression jexpr,                          boolean isConstructor, SymbolData thisSD)", "diff": ["-    if (enclosingSD.getName().equals(\"NonEmpty\"))", "-      System.err.println(\"Starting search for method \" + methodName + \" in \" + enclosingSD);", "+//    if (enclosingSD.getName().equals(\"NonEmpty\"))", "+//      System.err.println(\"Starting search for method \" + methodName + \" in \" + enclosingSD);", "-      if (md.getName().equals(\"NonEmpty\")) {", "-        System.err.println(\"*** for NonEmpty(), params length = \" + md.getParams().length + \"; args length = \" + arguments.length);", "-      }", "+//      if (md.getName().equals(\"NonEmpty\")) {", "+//        System.err.println(\"*** for NonEmpty(), params length = \" + md.getParams().length + \"; args length = \" + arguments.length);", "+//      }", "-          if (enclosingSD.getName().equals(\"NonEmpty\")) {", "-            System.err.println(\"*** Looking for autoboxing match for NonEmpty\");", "-            System.err.println(\"vds = \" + Arrays.toString(vds) + \" arguments = \" + Arrays.toString(arguments));", "-          }", "+//          if (enclosingSD.getName().equals(\"NonEmpty\")) {", "+//            System.err.println(\"*** Looking for autoboxing match for NonEmpty\");", "+//            System.err.println(\"vds = \" + Arrays.toString(vds) + \" arguments = \" + Arrays.toString(arguments));", "+//          }", "-              System.err.println(\"vds[\" + i + \"].getType().getSymbolData() = \" + parmSD);", "+//              System.err.println(\"vds[\" + i + \"].getType().getSymbolData() = \" + parmSD);", "-              System.err.println(\"arguments[\" + i + \"].getSymbolData() = \" + argSD);", "+//              System.err.println(\"arguments[\" + i + \"].getSymbolData() = \" + argSD);", "-                System.err.println(\"No match found for NonEmpty using autoboxing\");", "+//                System.err.println(\"No match found for NonEmpty using autoboxing\");", "-    if (methodName.equals(\"NonEmpty\")) {", "-      System.err.println(\"***** enclosingSD = \" + enclosingSD + \"; thisSD = \" + thisSD + \"; matching methods: \" + matching);", "-      System.err.println(\"***** matching methods with autoboxing: \" + matchingWithAutoBoxing);", "-    }", "+//    if (methodName.equals(\"NonEmpty\")) {", "+//      System.err.println(\"***** enclosingSD = \" + enclosingSD + \"; thisSD = \" + thisSD + \"; matching methods: \" + matching);", "+//      System.err.println(\"***** matching methods with autoboxing: \" + matchingWithAutoBoxing);", "+//    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f75f04a5bfcc15f583134374bedebef0", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 13, "signatureBeforeChange": "     protected Pair<LinkedList<MethodData>, LinkedList<MethodData>>      _getMatchingMethods(String methodName, SymbolData enclosingSD, InstanceData[] arguments, JExpression jexpr,                          boolean isConstructor, SymbolData thisSD)", "signatureAfterChange": "     protected Pair<LinkedList<MethodData>, LinkedList<MethodData>>      _getMatchingMethods(String methodName, SymbolData enclosingSD, InstanceData[] arguments, JExpression jexpr,                          boolean isConstructor, SymbolData thisSD)", "diff": ["+    if (enclosingSD.getName().equals(\"NonEmpty\"))", "+      System.err.println(\"Starting search for method \" + methodName + \" in \" + enclosingSD);", "+//      System.err.println(\"Testing method \" + md.getName());", "+      if (md.getName().equals(\"NonEmpty\")) {", "+        System.err.println(\"*** for NonEmpty(), params length = \" + md.getParams().length + \"; args length = \" + arguments.length);", "+      }", "+        ", "-          matches = matches && _isAssignableFromWithoutAutoboxing(vds[i].getType().getSymbolData(), arguments[i].getSymbolData());", "+          matches = matches && ", "+            _isAssignableFromWithoutAutoboxing(vds[i].getType().getSymbolData(), arguments[i].getSymbolData());", "+          if (enclosingSD.getName().equals(\"NonEmpty\")) {", "+            System.err.println(\"*** Looking for autoboxing match for NonEmpty\");", "+            System.err.println(\"vds = \" + Arrays.toString(vds) + \" arguments = \" + Arrays.toString(arguments));", "+          }", "+            if  (enclosingSD.getName().equals(\"NonEmpty\")) {", "+              SymbolData parmSD = vds[i].getType().getSymbolData();", "+              System.err.println(\"vds[\" + i + \"].getType().getSymbolData() = \" + parmSD);", "+              SymbolData argSD = arguments[i].getSymbolData();", "+              System.err.println(\"arguments[\" + i + \"].getSymbolData() = \" + argSD);", "+              if (argSD.equals(SymbolData.INT_TYPE) && parmSD.equals(symbolTable.get(\"java.lang.Object\")))", "+                assert _isAssignableFrom(parmSD, argSD);", "+            }", "-            if (matches == false) break;", "+            if (matches == false) {", "+              if (enclosingSD.getName().equals(\"NonEmpty\"))", "+                System.err.println(\"No match found for NonEmpty using autoboxing\");", "+              break;", "+            }", "+    if (methodName.equals(\"NonEmpty\")) {", "+      System.err.println(\"***** enclosingSD = \" + enclosingSD + \"; thisSD = \" + thisSD + \"; matching methods: \" + matching);", "+      System.err.println(\"***** matching methods with autoboxing: \" + matchingWithAutoBoxing);", "+    }", "+    "]}], "num": 3339}