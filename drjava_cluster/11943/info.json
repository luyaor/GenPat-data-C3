{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6611a70eaa7f8663785dff2ace760164", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "89bda89f6206cae971f1a60299fc1426", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/FullJavaVisitor.java", "commitBeforeChange": "ce0ecf66ce1ecec7e4abe0bd534cf2fbbb576f91", "commitAfterChange": "4e52eec7688cbd5ec3584417f424923ba61a75e0", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": "   protected void handleInnerClassDef(InnerClassDef that, Data data, String relName, String name)", "signatureAfterChange": "   protected void handleInnerClassDef(InnerClassDef that, Data data, String relName, String name)", "diff": ["-//    System.err.println(\"Processing InnerClassDef for \" + name + \" defined in \" + data.getName());", "+//    if (_file.getName().endsWith(\"MultipleNested.dj2\")) ", "+//      System.err.println(\"********** Processing InnerClassDef for \" + name + \" defined in \" + data.getName());", "-    for (int i = 0; i < that.getTypeParameters().length; i++) that.getTypeParameters()[i].visit(this);", "-    that.getSuperclass().visit(this);  // formerly commented out.  Why?", "+    // Create a new generic types table for visiting this inner class.", "+    HashMap<String, SymbolData> genericTypes = (HashMap<String, SymbolData>) _genericTypes.clone();", "+    TypeParameter[] tps = that.getTypeParameters();", "+    for (TypeParameter tp: tps) {", "+      final String typeName = tp.getVariable().getName();", "+      final String boundName = tp.getBound().getName();", "+      SymbolData boundSD = _identifyType(boundName, that.getSourceInfo(), _enclosingClassName);", "+      if (boundSD == null) { // create a dummy SymbolData ", "+        boundSD = SymbolData.NOT_FOUND; //  TODO: could create a separate SymbolData.NOT_BOUND singleton class?", "+//        System.err.println(\"Creating dummy SymbolData for bounding type \" + typeName + \" in inner class \" + name);", "+      }", "+      genericTypes.put(typeName, boundSD);", "+    }", "+    ", "+    /* The following two lines apparently do nothing.  Note that they are NOT in the scope of the new generic types", "+     * table.  TODO: confirm that these two lines do nothing and eliminate them. */", "+    that.getSuperclass().visit(this);", "-        ", "+    ", "+    /* The following line is NOT in the scope of the new generic type table but should be.  Since we are not", "+     * performing generic type checking, we may get away with the error.  TODO: refactor this code to", "+     * create a new LLV for processing a generic class. */", "-    if (sd != null) { // We have a symbol data to work with, so visit the body and augment", "-", "-      that.getBody().visit(new ClassBodyFullJavaVisitor(sd, sd.getName(), _file, _package, _importedFiles,", "-                                                        _importedPackages, _classesInThisFile, continuations, fixUps));", "+    // The preceding only fails if there is an error in the program", "+    ", "+    if (sd != null) { // We have a symbol data to work with, so visit the body using the new generic types table", "+      identifyInnerClasses(that);", "+      ClassBodyFullJavaVisitor cbfjv =", "+        new ClassBodyFullJavaVisitor(sd, _file, _package, _importedFiles, _importedPackages, _classesInThisFile, ", "+                                     continuations, fixUps, genericTypes);", "+      that.getBody().visit(cbfjv);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a82db1fc525213d3d0ca47435b278405", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/FullJavaVisitor.java", "commitBeforeChange": "ce0ecf66ce1ecec7e4abe0bd534cf2fbbb576f91", "commitAfterChange": "4e52eec7688cbd5ec3584417f424923ba61a75e0", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": "   protected void handleInnerInterfaceDef(InnerInterfaceDef that, Data data, String relName, String name)", "signatureAfterChange": "   protected void handleInnerInterfaceDef(InnerInterfaceDef that, Data data, String relName, String name)", "diff": ["-     // The following assert should be true because interfaces can't have fields!", "-    assert that.getTypeParameters().length == 0;", "+    // Create a new generic types table for visiting this inner class.", "+    // TODO: refactor this code to combine common code patterns in this method and forInnerClassDef", "+    HashMap<String, SymbolData> genericTypes = (HashMap<String, SymbolData>) _genericTypes.clone();", "+    TypeParameter[] tps = that.getTypeParameters();", "+    for (TypeParameter tp: tps) {", "+      final String typeName = tp.getVariable().getName();", "+      final String boundName = tp.getBound().getName();", "+      SymbolData boundSD = _identifyType(boundName, that.getSourceInfo(), _enclosingClassName);", "+      if (boundSD == null) { // create a dummy SymbolData ", "+        boundSD = SymbolData.NOT_FOUND; //  TODO: could create a separate SymbolData.NOT_BOUND singleton class?", "+//        System.err.println(\"Creating dummy SymbolData for bounding type \" + typeName + \" in inner class \" + name);", "+      }", "+      genericTypes.put(typeName, boundSD);", "+    }", "+    /* The following line apparently does nothing.  Note that it is NOT in the scope of the new generic types", "+     * table.  TODO: confirm that this line does nothing and eliminate it. */", "-    SymbolData sd = defineInnerSymbolData(that, relName, name, data);", "-    if (sd != null) {", "-      that.getBody().visit(new InterfaceBodyFullJavaVisitor(sd, _file, _package, _importedFiles, _importedPackages,", "-                                                            _classesInThisFile, continuations, fixUps));", "+    /* The following line is NOT in the scope of the new generic type table but should be.  Since we are not", "+     * performing generic type checking, we may get away with the error.  TODO: refactor this code to", "+     * create a new LLV for processing a generic class. */", "+    SymbolData sd = defineInnerSymbolData(that, relName, name, data);  // only returns null if error is encountered", "+    ", "+    if (sd != null) { // We have a symbol data to work with, so visit the body using the new generic types table", "+      sd.setInterface(true);", "+      identifyInnerClasses(that);", "+      InterfaceBodyFullJavaVisitor ibfjv = ", "+        new InterfaceBodyFullJavaVisitor(sd, _file, _package, _importedFiles, _importedPackages, _classesInThisFile, ", "+                                         continuations, fixUps, genericTypes);", "+      that.getBody().visit(ibfjv);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b0deb3e47c0b32c6c29ecd6cca1f2c1d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/FullJavaVisitor.java", "commitBeforeChange": "ce0ecf66ce1ecec7e4abe0bd534cf2fbbb576f91", "commitAfterChange": "4e52eec7688cbd5ec3584417f424923ba61a75e0", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 22, "signatureBeforeChange": "   public Void forClassDef(ClassDef that)", "signatureAfterChange": "   public Void forClassDef(ClassDef that)", "diff": ["-", "-    String className = getQualifiedClassName(that.getName().getText());", "-//    System.err.println(\"Processing class \" + className);", "-    SymbolData sd = defineSymbolData(that, className);", "-    assert getQualifiedSymbolData(className, SourceInfo.NO_INFO, false) != null;", "-//    _enclosingClassName = className;", "-//    System.err.println(\"Setting _enclosingClassName to \" + className);", "-    that.getSuperclass().visit(this);  // formerly commented out.  Why?", "+", "+    String className = getQualifiedClassName(that.getName().getText());", "+", "+    // Create a new generic types table for visiting this inner class.", "+    // TODO: refactor this code to combine common code patterns in this method and forInnerClassDef", "+    HashMap<String, SymbolData> genericTypes = (HashMap<String, SymbolData>) _genericTypes.clone();", "+    TypeParameter[] tps = that.getTypeParameters();", "+    for (TypeParameter tp: tps) {", "+      final String typeName = tp.getVariable().getName();", "+      final String boundName = tp.getBound().getName();", "+      SymbolData boundSD = _identifyType(boundName, that.getSourceInfo(), _enclosingClassName);", "+      if (boundSD == null) { // create a dummy SymbolData ", "+        boundSD = SymbolData.NOT_FOUND; //  TODO: could create a separate SymbolData.NOT_BOUND singleton class?", "+//        System.err.println(\"Creating dummy SymbolData for bounding type \" + typeName + \" in inner class \" + name);", "+      }", "+      genericTypes.put(typeName, boundSD);", "+    }", "+    /* The following line is NOT in the scope of the new generic type table but should be.  Since we are not", "+     * performing generic type checking, we may get away with the error.  TODO: refactor this code to", "+     * create a new LLV for processing a generic class. */", "+    SymbolData sd = defineSymbolData(that, className);", "-    if (sd != null) identifyInnerClasses(that);", "-    ", "-    // Process fields of this ClassDef (the get method is misnamed!)", "-    for (int i = 0; i < that.getTypeParameters().length; i++) that.getTypeParameters()[i].visit(this);", "-    ", "+    /* The following two lines apparently do nothing. They are in the wrong generic type scope. */", "+    that.getSuperclass().visit(this);", "-      that.getBody().visit(new ClassBodyFullJavaVisitor(sd, className, _file, _package, _importedFiles, ", "-                                                        _importedPackages, _classesInThisFile, continuations, fixUps));", "+//      System.err.println(\"********** Calling identifyInnerClasses for SymbolData \" + sd.getName());", "+      identifyInnerClasses(that);", "+      ClassBodyFullJavaVisitor cbfjv = ", "+        new ClassBodyFullJavaVisitor(sd, _file, _package, _importedFiles, _importedPackages, _classesInThisFile, ", "+                                     continuations, fixUps, genericTypes);", "+      that.getBody().visit(cbfjv);", "+    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3963ff3b1f1e660f87649fca989571a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/FullJavaVisitor.java", "commitBeforeChange": "ce0ecf66ce1ecec7e4abe0bd534cf2fbbb576f91", "commitAfterChange": "4e52eec7688cbd5ec3584417f424923ba61a75e0", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 26, "signatureBeforeChange": "   public Void forInterfaceDef(InterfaceDef that)", "signatureAfterChange": "   public Void forInterfaceDef(InterfaceDef that)", "diff": ["-    // The following assert should be true because interfaces can't have fields!", "-    assert that.getTypeParameters().length == 0;", "+    // Create a new generic types table for visiting this inner class.", "+    // TODO: refactor this code to combine common code patterns in this method and forInnerClassDef", "+    HashMap<String, SymbolData> genericTypes = (HashMap<String, SymbolData>) _genericTypes.clone();", "+    TypeParameter[] tps = that.getTypeParameters();", "+    for (TypeParameter tp: tps) {", "+      final String typeName = tp.getVariable().getName();", "+      final String boundName = tp.getBound().getName();", "+      SymbolData boundSD = _identifyType(boundName, that.getSourceInfo(), _enclosingClassName);", "+      if (boundSD == null) { // create a dummy SymbolData ", "+        boundSD = SymbolData.NOT_FOUND; //  TODO: could create a separate SymbolData.NOT_BOUND singleton class?", "+//        System.err.println(\"Creating dummy SymbolData for bounding type \" + typeName + \" in inner class \" + name);", "+      }", "+      genericTypes.put(typeName, boundSD);", "+    }", "+    /* The following line apparently does nothing.  Note that it is NOT in the scope of the new generic types", "+     * table.  TODO: confirm that this line does nothing and eliminate it. */", "-      identifyInnerClasses(that);  // inner interfaces??", "-      that.getBody().visit(new InterfaceBodyFullJavaVisitor(sd, _file, _package, _importedFiles, _importedPackages,", "-                                                            _classesInThisFile, continuations, fixUps));", "+      identifyInnerClasses(that);", "+      InterfaceBodyFullJavaVisitor ibfjv =", "+        new InterfaceBodyFullJavaVisitor(sd, _file, _package, _importedFiles, _importedPackages, _classesInThisFile, ", "+                                         continuations, fixUps, genericTypes);", "+      that.getBody().visit(ibfjv);"]}], "num": 11943}