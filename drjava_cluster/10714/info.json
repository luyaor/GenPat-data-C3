{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "511dd687325e7d2efdae2e2b0f64b301", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0ab30549213f599c61bb7ac0098fd454", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/JarJDKToolsLibrary.java", "commitBeforeChange": "b7d4cb04f4bb848380a14b3825abe047db8dc58f", "commitAfterChange": "101c103fed282ea73966b5bc0dce7152a188fba5", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 12, "signatureBeforeChange": "   public static Iterable<JarJDKToolsLibrary> search(GlobalModel model)", "signatureAfterChange": "   public static Iterable<JarJDKToolsLibrary> search(GlobalModel model)", "diff": ["-   */", "-  public static Iterable<JarJDKToolsLibrary> search(GlobalModel model) {", "-    ", "-    /* roots is a list of possible parent directories of Java installations; we want to eliminate duplicates & ", "-     * remember insertion order", "-     */", "-    LinkedHashMap<File,Set<JDKDescriptor>> roots = new LinkedHashMap<File,Set<JDKDescriptor>>();", "-    ", "-", "-    /* jars is a list of possible tools.jar (or classes.jar) files; we want to eliminate duplicates & ", "-     * remember insertion order", "-     */", "-    LinkedHashMap<File,Set<JDKDescriptor>> jars = new LinkedHashMap<File,Set<JDKDescriptor>>();", "-", "-    // Search for all compound JDK descriptors in the drjava.jar file", "-    Iterable<JDKDescriptor> descriptors = searchForJDKDescriptors(); ", "-    for(JDKDescriptor desc: descriptors) {", "-      // add the specific search directories and files", "-      for(File f: desc.getSearchDirectories()) { addIfDir(f, desc, roots); }", "-      for(File f: desc.getSearchFiles()) { addIfFile(f, desc, jars); }", "-      // add to the set of packages that need to be shadowed", "-      TOOLS_PACKAGES.addAll(desc.getToolsPackages());", "-    }", "-    ", "-    // We store everything in reverse order, since that's the natural order of the versions", "-    Map<FullVersion, Iterable<JarJDKToolsLibrary>> results = ", "-      new TreeMap<FullVersion, Iterable<JarJDKToolsLibrary>>();", "-    Map<FullVersion, Iterable<JarJDKToolsLibrary>> compoundResults =", "-      new TreeMap<FullVersion, Iterable<JarJDKToolsLibrary>>();", "-    ", "-    ", "-    Iterable<JarJDKToolsLibrary> collapsed = IterUtil.reverse(IterUtil.collapse(results.values()));", "-    Iterable<JarJDKToolsLibrary> compoundCollapsed = IterUtil.reverse(IterUtil.collapse(compoundResults.values()));", "-    ", "-    Map<FullVersion, Iterable<JarJDKToolsLibrary>> allResults =", "-          if (allResults.containsKey(v)) { allResults.put(v, IterUtil.compose(lib, allResults.get(v))); }", "-          else { allResults.put(v, IterUtil.singleton(lib)); }", "+   */", "+  public static Iterable<JarJDKToolsLibrary> search(GlobalModel model) {", "+    /* roots is a list of possible parent directories of Java installations; we want to eliminate duplicates & ", "+     * remember insertion order", "+     */", "+    LinkedHashMap<File,Set<JDKDescriptor>> roots = getDefaultSearchRoots();", "+", "+    /* jars is a list of possible tools.jar (or classes.jar) files; we want to eliminate duplicates & ", "+     * remember insertion order", "+     */", "+    LinkedHashMap<File,Set<JDKDescriptor>> jars = new LinkedHashMap<File,Set<JDKDescriptor>>();", "+", "+    // Search for all compound JDK descriptors in the drjava.jar file", "+    Iterable<JDKDescriptor> descriptors = searchForJDKDescriptors(); ", "+    for(JDKDescriptor desc: descriptors) {", "+      // add the specific search directories and files", "+      for(File f: desc.getSearchDirectories()) { addIfDir(f, desc, roots); }", "+      for(File f: desc.getSearchFiles()) { addIfFile(f, desc, jars); }", "+      // add to the set of packages that need to be shadowed", "+      TOOLS_PACKAGES.addAll(desc.getToolsPackages());", "+    }", "+    ", "+    // search for jar files in roots and, if found, transfer them to the jars collection", "+    searchRootsForJars(roots, jars);", "+", "+    // check which jars are valid JDKs, and determine if they are compound or full (non-compound) JDKs", "+    Map<FullVersion, Iterable<JarJDKToolsLibrary>> results = ", "+      new TreeMap<FullVersion, Iterable<JarJDKToolsLibrary>>();", "+    Map<FullVersion, Iterable<JarJDKToolsLibrary>> compoundResults =", "+      new TreeMap<FullVersion, Iterable<JarJDKToolsLibrary>>();", "+    ", "+    collectValidResults(model, jars, results, compoundResults);", "+    ", "+    // We store everything in reverse order, since that's the natural order of the versions", "+    Iterable<JarJDKToolsLibrary> collapsed = IterUtil.reverse(IterUtil.collapse(results.values()));", "+    Iterable<JarJDKToolsLibrary> compoundCollapsed = IterUtil.reverse(IterUtil.collapse(compoundResults.values()));", "+    ", "+    // Get completed compound JDKs by going through the list of compound JDKs and finding full JDKs that", "+    // complete them", "+    Map<FullVersion, Iterable<JarJDKToolsLibrary>> completedResults =", "+      getCompletedCompoundResults(model, collapsed, compoundCollapsed);", "+    ", "-      compose(collapsed,IterUtil.reverse(IterUtil.collapse(allResults.values())));", "+      compose(collapsed,IterUtil.reverse(IterUtil.collapse(completedResults.values())));", "+    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa290294b71a48bc4f8619811a4b40b4", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "c7ce54f2435a198c543bef7b35866738d8690d46", "commitAfterChange": "f9b3ce896f60a5fa583a421b5b2bb827822b30df", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 28, "signatureBeforeChange": "   private SymbolData _getSymbolData_FromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,                                                    boolean addError)", "signatureAfterChange": "   private SymbolData _getSymbolData_FromFileSystem(final String qualifiedClassName, SourceInfo si, boolean resolve,                                                    boolean addError)", "diff": ["-    // Check is the qualified class name is in _classesToBeParsed to save the time it would take to parse", "+    // Is qualifiedClassName in _classesToBeParsed, saving the time it would take to parse", "-    if (pair != null) {", "-      return _lookupFromClassesToBeParsed(qualifiedClassName, si, resolve);", "-    }", "+    if (pair != null) return _lookupFromClassesToBeParsed(qualifiedClassName, si, resolve);", "-    // If it's not in the symbol table or list of classes to be parsed, ", "-    // check if the class is defined in one of the files in this package.", "-    // We have to begin looking for files at the source root of the current _file.", "-    File parent = _file.getParentFile();", "-    String directoryName = \"\";", "-    if (parent != null) {", "-      directoryName = parent.getAbsolutePath();", "-    }", "+    /* If qualifiedClassName is not in the symbol table or list of classes to be parsed, check if the class is defined", "+     * in this package tree.", "+     */", "+    String qualifiedClassNameWithSlashes = ", "+      qualifiedClassName.replace('.', System.getProperty(\"file.separator\").charAt(0));", "+    File _fileParent = _file.getParentFile();", "+    String programRoot = (_fileParent == null) ? \"\" : _fileParent.getAbsolutePath();  // Eventually set to root of package (for _file)", "+    assert (programRoot != null); // parent != null => parent exists.", "-    final String path;", "-    String qualifiedClassNameWithSlashes = qualifiedClassName.replace('.', System.getProperty(\"file.separator\").charAt(0));", "-    if (directoryName != null) {      ", "-      String newPackage = _package.replace('.', System.getProperty(\"file.separator\").charAt(0));", "-      int indexOfPackage = directoryName.length();", "-      if (newPackage.length() > 0) {", "-        // Removes the slash after the package", "-        indexOfPackage = directoryName.indexOf(newPackage) - 1;", "-      }", "-      ", "-      //this should only be necessary when testing. ", "-      if (indexOfPackage < 0) {", "-        indexOfPackage = directoryName.length();", "-      }", "-      ", "-      directoryName = directoryName.substring(0, indexOfPackage);", "-      ", "-      path = directoryName + System.getProperty(\"file.separator\") + qualifiedClassNameWithSlashes;", "-    }", "-    else {", "-      path = qualifiedClassName;", "-    }", "-    ", "-    ", "-    /* newPath is the directory of the file we're trying to resolve */", "-    String newPath;", "-    /* newPackage is the package of the file we're trying to resolve */", "-    String newPackage = \"\";", "-    int lastSlash = qualifiedClassNameWithSlashes.lastIndexOf(System.getProperty(\"file.separator\"));", "-    if (lastSlash != -1) {", "-      newPackage = qualifiedClassNameWithSlashes.substring(0, lastSlash);", "-      newPath = directoryName + System.getProperty(\"file.separator\") + newPackage;", "-      newPackage = newPackage.replace(System.getProperty(\"file.separator\").charAt(0), '.');", "-    }", "-    else {", "-      int lastSlashInPath = path.lastIndexOf(System.getProperty(\"file.separator\"));", "-      if (lastSlashInPath != -1) {", "-        newPath = path.substring(0, lastSlashInPath);", "-      }", "+    final String path;  // The expected path name of the class file (less .class) for qualifiedClassName", "+", "+    if (programRoot.length() > 0) {      ", "+      String packageWithSlashes = _package.replace('.', System.getProperty(\"file.separator\").charAt(0));", "+      int indexOfPackage = programRoot.lastIndexOf(packageWithSlashes); // index of slash preceding first char of package name", "+      if (indexOfPackage < 0) path = qualifiedClassName;", "-        newPath = \"\";", "+        programRoot = programRoot.substring(0, indexOfPackage);", "+        path = programRoot + System.getProperty(\"file.separator\") + qualifiedClassNameWithSlashes;", "+    else {", "+      path = qualifiedClassNameWithSlashes;  // Using file system root for programRoot", "+    }", "-    ", "+    String dirPath; /* the expected directory of the file we're trying to resolve */", "+    String newPackage = \"\"; /* the package of the file we're trying to resolve */", "+    int lastSlashIndex = qualifiedClassNameWithSlashes.lastIndexOf(System.getProperty(\"file.separator\"));", "+    if (lastSlashIndex != -1) {", "+      String newPackageWithSlashes = qualifiedClassNameWithSlashes.substring(0, lastSlashIndex);", "+      dirPath = programRoot + System.getProperty(\"file.separator\") + newPackageWithSlashes;", "+      newPackage = newPackageWithSlashes.replace(System.getProperty(\"file.separator\").charAt(0), '.');", "+    }", "+    else {", "+      int lastPathSlashIndex = path.lastIndexOf(System.getProperty(\"file.separator\"));", "+      if (lastPathSlashIndex != -1) dirPath = path.substring(0, lastPathSlashIndex);", "+      else dirPath = \"\";", "+    }", "-    File[] sourceFiles = new File(newPath).listFiles(new FileFilter() {", "+    File[] sourceFiles = new File(dirPath).listFiles(new FileFilter() {", "-            new File(path + \".dj2\").getCanonicalFile().equals(f);", "+            new File(path + \".dj2\").getCanonicalFile().equals(f) ||", "+            new File(path + \".java\").getCanonicalFile().equals(f);", "-        // TODO: Do something with Java files.", "-    ", "-//    if (sourceFile.equals(_file)) {", "-//      if (addError) {", "-//        _addAndIgnoreError(\"The class \" + qualifiedClassName + \" was not found in the file \" + sourceFile, ", "-//                           new NullLiteral(si));", "-//      }", "-//      System.out.println(\"Just added an error. returning null.  class should have been in current file.\");", "-//      return null;", "-//    }", "-//    if (qualifiedClassName.contains(\"List\")) {System.out.println(\"Line 777: There are \" + continuations.size() + ", "-//      \" continuations \" + continuations);}", "-          continuations.put(qualifiedClassName, ", "-                            new Pair<SourceInfo, LanguageLevelVisitor>(si, createANewInstanceOfMe(sourceFile)));//this));", "-          ", "+          continuations.put(qualifiedClassName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));", "+      // Get last modified time of corresponding class file", "+      long classModTime = classFile.lastModified();", "+      if (classModTime == 0L) return null;  // if classFile does not exist, return", "-      // Get the last modified times of the java file and class file.", "-      // if the classfile doesn't exist, classFileLastModified will get 0, and we will parse it.", "-      if (sourceFile.lastModified() > classFile.lastModified()) {", "-        // the class file is out of date, parse the java file", "-        //First, make sure the java file is readable:", "-        if (!sourceFile.canRead()) {", "-          if (addError) {", "-            _addAndIgnoreError(\"The file \" + sourceFile.getAbsolutePath() + ", "-                               \" is present, but does not have proper read permissions\", new NullLiteral(si));", "-          }", "-          return null;", "+      if (sourceFile.lastModified() > classModTime) { // the class file is out of date", "+        if (addError) {", "+          _addAndIgnoreError(\"The file \" + sourceFile.getAbsolutePath() + ", "+                             \" needs to be recompiled; it's class files either do not exist or are out of date.\",", "+                             new NullLiteral(si));", "-        ", "-        //Also make sure the directory where the new class file will eventually be written is writable.", "-        if (!new File(newPath).canWrite()) {", "-          if (addError) {", "-            _addAndIgnoreError(\"The file \" + sourceFile.getAbsolutePath() + ", "-                               \" needs to be recompiled, but its directory does not have proper write permissions\", ", "-                               new NullLiteral(si));", "-          }", "-          return null;", "-        }", "-        ", "-        /** Insure that this file hasn't already been processed */", "-        try { ", "-          File canonicalSource = sourceFile.getCanonicalFile();", "-          boolean alreadyVisited = false;", "-          try { alreadyVisited |= _file.getCanonicalFile().equals(canonicalSource); }", "-          catch (IOException e) { /* ignore */ }", "-          if (!alreadyVisited) {", "-            for (Pair<LanguageLevelVisitor, SourceFile> p : visitedFiles) {", "-              try { ", "-                alreadyVisited |= p.getFirst()._file.getCanonicalFile().equals(canonicalSource);", "-                if (alreadyVisited) { break; }", "-              }", "-              catch (IOException e) { /* ignore */ }", "-            }", "-          }", "-          ", "-          if (alreadyVisited) { return SymbolData.KEEP_GOING; }", "-        }", "-        catch (IOException e) {", "-          if (addError) {", "-            _addAndIgnoreError(\"The file \" + sourceFile.getAbsolutePath() + ", "-                               \" is present, but its full path cannot be resolved \" + ", "-                               \"(symbolic links may not have proper permissions)\", ", "-                               new NullLiteral(si));", "-          }", "-          return null;", "-        }", "-        ", "-        LanguageLevelVisitor lv;", "-        ", "-        if (LanguageLevelConverter.isElementaryFile(sourceFile)) {", "-          lv = new ElementaryVisitor(sourceFile, errors, symbolTable, continuations, visitedFiles, _newSDs);", "-        }", "-        else if (LanguageLevelConverter.isIntermediateFile(sourceFile)) {", "-          lv = new IntermediateVisitor(sourceFile, errors, symbolTable, continuations, visitedFiles, _newSDs);", "-        }", "-        else if (LanguageLevelConverter.isAdvancedFile(sourceFile)) {", "-          lv = new AdvancedVisitor(sourceFile, errors, symbolTable, continuations, visitedFiles, _newSDs);", "-        }", "-        else {", "-          throw new RuntimeException(\"Internal Program Error: Invalid file format not caught initially\" + ", "-                                     sourceFile.getName() + \". Please report this bug\");", "-        }", "-        ", "-        SourceFile sf;", "-        try {", "-          JExprParser jep = new JExprParser(sourceFile);", "-          sf = jep.SourceFile();", "-        }", "-        catch(ParseException pe) {", "-          if (addError) {", "-            // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-            _addAndIgnoreError(pe.getMessage(), ", "-                               new NullLiteral(new SourceInfo(sourceFile,", "-                                                              pe.currentToken.beginLine,", "-                                                              pe.currentToken.beginColumn,", "-                                                              pe.currentToken.endLine,", "-                                                              pe.currentToken.endColumn)));", "-          }", "-          return null;", "-        }", "-        catch (FileNotFoundException fnfe) {", "-          // This should never happen.", "-          if (addError) {", "-            _addAndIgnoreError(\"File \" + sourceFile + \" could not be found.\", new NullLiteral(si));", "-          }", "-          return null;", "-        }", "-        // See if there were any errors caused by the first pass on the java file.", "-        int numErrors = errors.size();", "-        sf.visit(lv);", "-        if (numErrors != errors.size()) {", "-          return null;", "-        }", "-        else {", "-          //Resolve any continuations.", "-          while (!lv.continuations.isEmpty()) {", "-            Enumeration<String> en = lv.continuations.keys();", "-            ", "-            while (en.hasMoreElements()) {", "-              String className = en.nextElement();", "-              Pair<SourceInfo, LanguageLevelVisitor> p = lv.continuations.remove(className);", "-              SymbolData returnedSd = p.getSecond().getSymbolData(className, p.getFirst(), true);", "-              //if (returnedSd == null) {", "-              //  errors.add(new Pair<String, JExpressionIF>(\"Could not resolve \" + className, ", "-              //                                             new NullLiteral(p.getFirst())));", "-              //}", "-            }", "-          }", "-          ", "-          // Create any constructors.", "-          Hashtable<SymbolData, LanguageLevelVisitor> newSDs = lv._newSDs;", "-          ", "-          Enumeration<SymbolData> keys = newSDs.keys();", "-          while (keys.hasMoreElements()) {", "-            SymbolData key = keys.nextElement();", "-            LanguageLevelVisitor sdlv = newSDs.get(key);    // Can return null because of silly side effects!", "-            if (sdlv != null) sdlv.createConstructor(key);  // Null test is a kludge! Deletes (key,sdlv) from _newSDs!", "-          }", "-          assert LanguageLevelVisitor._newSDs.isEmpty();", "-          ", "-          sf.visit(new TypeChecker(sourceFile, newPackage, errors, symbolTable, lv._importedFiles, lv._importedPackages));", "-        }", "-        ", "-        // will this put entries into the symbol table that this class shouldn't be able to see?", "-        ", "-        // The symbol table should now contain the SymbolData of the class we're looking for.", "-        sd = symbolTable.get(qualifiedClassName);", "-        if (sd == null || sd.isContinuation()) {", "-          if (addError) {", "-            _addAndIgnoreError(\"File \" + sourceFile + \" does not contain class \" + qualifiedClassName, sf);", "-          }", "-          return null;", "-        }", "-        else {", "-          visitedFiles.add(new Pair<LanguageLevelVisitor, SourceFile>(lv, sf));", "-          return sd;", "-        }", "+        return null;", "+    ", "+    // if source file exists, the corresponding class file is up to date", "-      sd = _classFile2SymbolData(qualifiedClassName, directoryName);", "+      sd = _classFile2SymbolData(qualifiedClassName, programRoot);", "-      else {", "-        if (sourceFile != null) {", "-          // Visit the sourceFile anyway even though the classFile is up to date so we", "-          // can pass the SourceFile to the LanguageLevelConverter.", "-          SourceFile sf;", "-          try {", "-            sf = new JExprParser(sourceFile).SourceFile();", "-          }", "-          catch(ParseException pe) {", "-            if (addError) {", "-              // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-              _addAndIgnoreError(pe.getMessage(), ", "-                                 new NullLiteral(new SourceInfo(sourceFile,", "-                                                                pe.currentToken.beginLine,", "-                                                                pe.currentToken.beginColumn,", "-                                                                pe.currentToken.endLine,", "-                                                                pe.currentToken.endColumn)));", "-            }", "-            return null;", "-          }", "-          catch (FileNotFoundException fnfe) {", "-            // This should never happen.", "-            if (addError) {", "-              _addAndIgnoreError(\"File \" + sourceFile + \" could not be found.\", new NullLiteral(si));", "-            }", "-            return null;", "-          }", "-          ", "-          LanguageLevelVisitor lv = createANewInstanceOfMe(sourceFile);", "-          lv._package = newPackage;", "-          visitedFiles.add(new Pair<LanguageLevelVisitor, SourceFile>(lv, null));//lv, sf));", "-          ", "-          ", "-        }", "-        ", "-        return sd;", "-      }", "+      return sd;", "-    return SymbolData.KEEP_GOING;", "+    return SymbolData.NOT_FOUND;"]}], "num": 10714}