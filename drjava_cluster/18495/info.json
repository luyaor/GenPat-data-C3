{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7d3d02ca689eed57a9ed7566315c4cbc", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "18657faf68e4629ce0d9da836d6dd6fd", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 30, "signatureBeforeChange": "   @Override public Type visit(AnonymousAllocation node)", "signatureAfterChange": "     @Override public Type visit(AnonymousAllocation node)", "diff": ["-   */", "-  @Override public Type visit(AnonymousAllocation node) {", "-    Type t = node.getCreationType().acceptVisitor(this);", "-    // TODO: Allow a simple allocation of a dynamic inner class defined in the current context (as above)", "-    if (!ts.isStatic(t) || (!ts.isExtendable(t) && !ts.isImplementable(t))) {", "-      throw new ExecutionError(\"allocation.type\", node);", "-    }", "-    ", "-    Iterable<? extends Expression> args = IterUtil.empty();", "-    if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "-    ", "-    Iterable<Type> targs = IterUtil.empty();", "-    if (node instanceof PolymorphicAnonymousAllocation) {", "-      targs = checkTypeNameList(((PolymorphicAnonymousAllocation) node).getTypeArguments());", "-    }", "-    ", "-    if (!(IterUtil.isEmpty(args) && IterUtil.isEmpty(targs) && ts.isImplementable(t))) {", "-      // Super constructor invocation is something besides Object()", "-      try {", "-        TypeSystem.ConstructorInvocation inv = ts.lookupConstructor(t, targs, args);", "-        // TODO: Check accessibility of constructor", "-        setErrorStrings(node, ts.userRepresentation(t), nodeTypesString(args));", "-        throw new ExecutionError(\"no.such.constructor\", node);", "-", "-    TreeClass c = new TreeClass(context.makeAnonymousClassName(), null, node,", "-                                new TreeClassLoader(context.getClassLoader(), opt), opt);", "-    setDJClass(node, c);", "-    new ClassMemberChecker(new ClassContext(context, c), opt).checkMembers(node.getMembers());", "-    setConstructor(node, IterUtil.first(c.declaredConstructors()));", "-    return setType(node, ts.makeClassType(c));", "-  }", "+     */", "+    @Override public Type visit(AnonymousAllocation node) {", "+      Type t = checkTypeName(node.getCreationType());", "+      // TODO: Allow a simple allocation of a dynamic inner class defined in the current context (as above)", "+      if (!ts.isStatic(t) || (!ts.isExtendable(t) && !ts.isImplementable(t))) {", "+      if (node instanceof PolymorphicAnonymousAllocation) {", "+        targs = checkTypeNameList(((PolymorphicAnonymousAllocation) node).getTypeArguments());", "+      }", "+      ", "+      if (!(IterUtil.isEmpty(args) && IterUtil.isEmpty(targs) && ts.isImplementable(t))) {", "+        // Super constructor invocation is something besides Object()", "+        try {", "+          ConstructorInvocation inv = ts.lookupConstructor(t, targs, args, expected);", "+          // TODO: Check accessibility of constructor", "+          checkThrownExceptions(inv.thrown(), node);", "+          node.setArguments(CollectUtil.makeList(inv.args()));", "+        }", "+        catch (InvalidTypeArgumentException e) {", "+          throw new ExecutionError(\"type.argument\", node);", "+        }", "+        catch (TypeSystemException e) {", "+          setErrorStrings(node, ts.userRepresentation(t), nodeTypesString(args));", "+          throw new ExecutionError(\"no.such.constructor\", node);", "+        }", "+      }", "+      ", "+      TreeClass c = new TreeClass(context.makeAnonymousClassName(), null, node,", "+                                  new TreeClassLoader(context.getClassLoader(), opt), opt);", "+      setDJClass(node, c);", "+      new ClassMemberChecker(new ClassContext(context, c), opt).checkMembers(node.getMembers());", "+      ", "+      setConstructor(node, IterUtil.first(c.declaredConstructors()));", "+      return setType(node, ts.makeClassType(c));", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5b52d3cbf0a3c2348c4e588b4347f64e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 32, "signatureBeforeChange": "   @Override public Type visit(AnonymousInnerAllocation node)", "signatureAfterChange": "     @Override public Type visit(AnonymousInnerAllocation node)", "diff": ["-   */", "-  @Override public Type visit(AnonymousInnerAllocation node) {", "-    Type enclosing = node.getExpression().acceptVisitor(this);", "-    Iterable<Type> classTargs = IterUtil.empty();", "-    if (node.getClassTypeArguments() != null) {", "-      classTargs = checkTypeNameList(node.getClassTypeArguments());", "-    }", "-    ", "-    try {", "-      Type t = ts.lookupClass(node.getExpression(), node.getClassName(), classTargs);", "-      // TODO: Check that t is not a static member of enclosing", "-      if (!ts.isExtendable(t)) {", "-      setSuperType(node, t);", "-      if (node instanceof PolymorphicAnonymousInnerAllocation) {", "-        targs = checkTypeNameList(((PolymorphicAnonymousInnerAllocation) node).getTypeArguments());", "-        TypeSystem.ConstructorInvocation inv = ts.lookupConstructor(t, targs, args);", "-        // TODO: Check accessibility of constructor", "-        checkThrownExceptions(inv.thrown(), node);", "-        node.setArguments(CollectUtil.makeList(inv.args()));", "-        setErrorStrings(node, ts.userRepresentation(t), nodeTypesString(args));", "+     */", "+    @Override public Type visit(AnonymousInnerAllocation node) {", "+      Type enclosing = check(node.getExpression());", "+      ", "+      Iterable<Type> classTargs = IterUtil.empty();", "+      if (node.getClassTypeArguments() != null) {", "+        classTargs = checkTypeNameList(node.getClassTypeArguments());", "+      }", "+      ", "+      try {", "+        Type t = ts.lookupClass(node.getExpression(), node.getClassName(), classTargs);", "+        // TODO: Check that t is not a static member of enclosing", "+        if (!ts.isExtendable(t)) {", "+          throw new ExecutionError(\"allocation.type\", node);", "+        }", "+        setSuperType(node, t);", "+        ", "+        Iterable<? extends Expression> args = IterUtil.empty();", "+        if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "+        ", "+        Iterable<Type> targs = IterUtil.empty();", "+        if (node instanceof PolymorphicAnonymousInnerAllocation) {", "+          targs = checkTypeNameList(((PolymorphicAnonymousInnerAllocation) node).getTypeArguments());", "+        }", "+        ", "+        try {", "+          ConstructorInvocation inv = ts.lookupConstructor(t, targs, args, expected);", "+          // TODO: Check accessibility of constructor", "+          checkThrownExceptions(inv.thrown(), node);", "+          node.setArguments(CollectUtil.makeList(inv.args()));", "+        }", "+        catch (InvalidTypeArgumentException e) {", "+          throw new ExecutionError(\"type.argument\", node);", "+        }", "+        catch (TypeSystemException e) {", "+          setErrorStrings(node, ts.userRepresentation(t), nodeTypesString(args));", "+          throw new ExecutionError(\"no.such.constructor\", node);", "+        }", "+      }", "+      catch (InvalidTypeArgumentException e) {", "+        throw new ExecutionError(\"type.argument\", node);", "+      }", "+      catch (TypeSystemException e) {", "+        setErrorStrings(node, ts.userRepresentation(enclosing), node.getClassName());", "+        throw new ExecutionError(\"no.such.inner.class\", node);", "+      }", "+      ", "+      TreeClass c = new TreeClass(context.makeAnonymousClassName(), null, node,", "+                                  new TreeClassLoader(context.getClassLoader(), opt), opt);", "+      setDJClass(node, c);", "+      new ClassMemberChecker(new ClassContext(context, c), opt).checkMembers(node.getMembers());", "+      ", "+      setConstructor(node, IterUtil.first(c.declaredConstructors()));", "+      return setType(node, ts.makeClassType(c));", "+    }", "-    catch (InvalidTypeArgumentException e) {", "-      throw new ExecutionError(\"type.argument\", node);", "-    }", "-    catch (TypeSystemException e) {", "-      setErrorStrings(node, ts.userRepresentation(enclosing), node.getClassName());", "-      throw new ExecutionError(\"no.such.inner.class\", node);", "-    }", "-", "-    TreeClass c = new TreeClass(context.makeAnonymousClassName(), null, node,", "-                                new TreeClassLoader(context.getClassLoader(), opt), opt);", "-    setDJClass(node, c);", "-    new ClassMemberChecker(new ClassContext(context, c), opt).checkMembers(node.getMembers());", "-    setConstructor(node, IterUtil.first(c.declaredConstructors()));", "-    return setType(node, ts.makeClassType(c));", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f9d419514cc5d03f404279e18412c6a1", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 31, "signatureBeforeChange": "   @Override public Type visit(InnerAllocation node)", "signatureAfterChange": "     @Override public Type visit(InnerAllocation node)", "diff": ["-   */", "-  @Override public Type visit(InnerAllocation node) {", "-    Type enclosing = node.getExpression().acceptVisitor(this);", "-    ", "-    Iterable<Type> classTargs = IterUtil.empty();", "-    if (node.getClassTypeArguments() != null) {", "-      classTargs = checkTypeNameList(node.getClassTypeArguments());", "-    try {", "-      Type t = ts.lookupClass(node.getExpression(), node.getClassName(), classTargs);", "-      // TODO: Check that t is not a static member of enclosing", "-      if (!ts.isConcrete(t)) {", "-      if (node instanceof PolymorphicInnerAllocation) {", "-        targs = checkTypeNameList(((PolymorphicInnerAllocation) node).getTypeArguments());", "-    ", "-        TypeSystem.ConstructorInvocation inv = ts.lookupConstructor(t, targs, args);", "-    catch (InvalidTypeArgumentException e) {", "-      throw new ExecutionError(\"type.argument\", node);", "-    }", "-    catch (TypeSystemException e) {", "-      setErrorStrings(node, ts.userRepresentation(enclosing), node.getClassName());", "-      throw new ExecutionError(\"no.such.inner.class\", node);", "-    }", "-  }", "+     */", "+    @Override public Type visit(InnerAllocation node) {", "+      Type enclosing = check(node.getExpression());", "+      ", "+      Iterable<Type> classTargs = IterUtil.empty();", "+      if (node.getClassTypeArguments() != null) {", "+        classTargs = checkTypeNameList(node.getClassTypeArguments());", "+        Type t = ts.lookupClass(node.getExpression(), node.getClassName(), classTargs);", "+        // TODO: Check that t is not a static member of enclosing", "+        if (!ts.isConcrete(t)) {", "+          throw new ExecutionError(\"allocation.type\", node);", "+        }", "+        ", "+        Iterable<? extends Expression> args = IterUtil.empty();", "+        if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "+        ", "+        Iterable<Type> targs = IterUtil.empty();", "+        if (node instanceof PolymorphicInnerAllocation) {", "+          targs = checkTypeNameList(((PolymorphicInnerAllocation) node).getTypeArguments());", "+        }", "+        ", "+        try {", "+          ConstructorInvocation inv = ts.lookupConstructor(t, targs, args, expected);", "+          // TODO: Check accessibility of constructor", "+          checkThrownExceptions(inv.thrown(), node);", "+          node.setArguments(CollectUtil.makeList(inv.args()));", "+          setConstructor(node, inv.constructor());", "+          return setType(node, t);", "+        }", "+        catch (InvalidTypeArgumentException e) {", "+          throw new ExecutionError(\"type.argument\", node);", "+        }", "+        catch (TypeSystemException e) {", "+          setErrorStrings(node, ts.userRepresentation(t), nodeTypesString(args));", "+          throw new ExecutionError(\"no.such.constructor\", node);", "+        }", "+        setErrorStrings(node, ts.userRepresentation(enclosing), node.getClassName());", "+        throw new ExecutionError(\"no.such.inner.class\", node);", "+      }", "+    }"]}], "num": 18495}