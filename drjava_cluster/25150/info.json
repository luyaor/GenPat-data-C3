{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "003be7533955a8067d8e3e37f0087c74", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "191b38b4288f04a3db0f7cab951044ea", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "   public static boolean checkAccessibility(JExpression piece, ModifiersAndVisibility mav, String name,                                             SymbolData enclosingSD, SymbolData thisSD, String dataType, boolean addError)", "signatureAfterChange": "   public static boolean checkAccess(JExpression piece, ModifiersAndVisibility mav, String name,                                      SymbolData enclosingSD, SymbolData thisSD, String dataType, boolean addError)", "diff": ["-  /**Can you reference name from thisSD where name isdefined in enclosingSD */", "-  public static boolean checkAccessibility(JExpression piece, ModifiersAndVisibility mav, String name, ", "-                                           SymbolData enclosingSD, SymbolData thisSD, String dataType, boolean addError) {", "-", "-      if (thisSD.isOuterData(enclosingSD) || enclosingSD.isOuterData(thisSD) || thisSD==enclosingSD) {", "-        return true;", "-      }", "-    ", "-    String[] modifiers = mav.getModifiers();", "-    // Check for the public modifier.", "-    for (int i = 0; i < modifiers.length; i++) {", "-      if (modifiers[i].equals(\"public\")) {", "-        Data enclosingOuter = enclosingSD.getOuterData();", "-        if (enclosingOuter == null) {return true;}", "-        if (enclosingOuter instanceof SymbolData) {", "-          return checkAccessibility(piece, mav, name, enclosingSD.getOuterData().getSymbolData(), thisSD, dataType, addError); //true;", "-        }", "-        throw new RuntimeException(\"Internal Program Error: Trying to reference \" + name + \"which is a member of something other than a class from outside of that thing.  Please report this bug.\");", "-      }", "+    */", "+  public static boolean checkAccess(JExpression piece, ModifiersAndVisibility mav, String name, ", "+                                    SymbolData enclosingSD, SymbolData thisSD, String dataType, boolean addError) {", "+//    if (piece instanceof VariableReference) System.err.println(\"**** Checking access of \" + piece + \"\\nin \" + enclosingSD);", "+    if (thisSD.isOuterData(enclosingSD) || enclosingSD.isOuterData(thisSD) || thisSD.equals(enclosingSD)) {", "+      return true;", "-    // Check for the private modifier.", "-    for (int i = 0; i < modifiers.length; i++) {", "-      if (modifiers[i].equals(\"private\")) {", "-        //As long as one of the symbol datas is the outer data of the other one (at some point down the data chain), private classes/methods/fields can be seen.", "-        //Since we would have already returned, just throw the error and return false.", "-", "-        if (addError) { _addError(\"The \" + dataType + \" \" + Data.dollarSignsToDots(name) + \" is private and cannot be accessed from \" + Data.dollarSignsToDots(thisSD.getName()), piece); }", "-        return false;", "+    // Check for the public modifier.", "+    if (Utilities.isPublic(mav)) {", "+      Data enclosingOuter = enclosingSD.getOuterData();", "+      if (enclosingOuter == null) return true;", "+      if (enclosingOuter instanceof SymbolData) {", "+        return checkAccess(piece, mav, name, enclosingSD.getOuterData().getSymbolData(), thisSD, dataType, addError); ", "+      throw new RuntimeException(\"Internal Program Error: Trying to reference \" + name + ", "+                                 \"which is a member of something other than a class from outside of that thing.  \" +", "+                                 \"Please report this bug.\");", "+    }", "+    ", "+    // Check for the private modifier.", "+    if (Utilities.isPrivate(mav)) {", "+      /* As long as one of the symbol datas is the outer data of the other one (at some point down the data chain), ", "+       * private classes/methods/fields can be seen. Since we would have already returned, just throw the error and ", "+       * return false. */", "+//      Utilities.show(thisSD + \" cannot access symbol '\"  + name + \"' within \" + enclosingSD + \" from '\" + thisSD ", "+//                       + \"' in file \" + piece.getSourceInfo().getFile());", "+//      if (name.equals(\"evalVisitor\")) throw new UnexpectedException(\"evalVisitor BUG\");", "+      String nameWithDots = Data.dollarSignsToDots(name);", "+      String enclosingWithDots = Data.dollarSignsToDots(enclosingSD.getName());", "+      ", "+      // The following is a kludge to eliminate SOME spurious results.", "+      if (nameWithDots.equals(enclosingWithDots) && enclosingSD.isPrimitiveType()) return true;", "+          ", "+      String siteName = Data.dollarSignsToDots(thisSD.getName());", "+      if (addError) { ", "+        _addError(\"The \" + dataType + \" \" + nameWithDots + \" in \" + enclosingWithDots +", "+                  \" is private and cannot be accessed from \" + siteName, ", "+                  piece);", "+//        throw new UnexpectedException(\"Generate Debugging Trace for access failure to \" + nameWithDots + \" in \" ", "+//                                        + enclosingWithDots + \" from \" + siteName);  // DEBUG", "+      }", "+//      Utilities.show(\"enclosingSD = \" + enclosingSD + \" thisSD = \" + thisSD);", "+      return false;", "-    for (int i = 0; i < modifiers.length; i++) {", "-      if (modifiers[i].equals(\"protected\")) {", "-        // Compare the package names. Remember that inner classes have '$' in their names.  NO! TODO: Fix this !!!", "-        if (_areInSamePackage(enclosingSD, thisSD)) {", "-          return true;", "-        }", "-        // Check if thisSD is a subclass of enclosingSD.", "-        //If they are in the same file, they are in the same package, so this does not need to check outer classes, only super classes and interfaces.", "-        if (thisSD.isSubClassOf(enclosingSD)) {", "-          return true;", "-        }", "-        else {", "-          if (addError) { _addError(\"The \" + dataType + \" \" + Data.dollarSignsToDots(name) + \" is protected and cannot be accessed from \" + Data.dollarSignsToDots(thisSD.getName()), piece); }", "-          return false;", "-        }", "+    if (Utilities.isProtected(mav)) {", "+      // Compare the package names. Remember that inner classes have '$' in their names.  NO! TODO: Fix this !!!", "+      if (_areInSamePackage(enclosingSD, thisSD)) {", "+        return true;", "+      }", "+      // Check if thisSD is a subclass of enclosingSD.", "+      // If they are in the same file, they are in the same package, so this does not need to check outer classes, ", "+      // only super classes and interfaces.", "+      if (thisSD.isSubClassOf(enclosingSD)) {", "+        return true;", "+      }", "+      else {", "+        if (addError) _addError(\"The \" + dataType + \" \" + Data.dollarSignsToDots(name) + ", "+                                \" is protected and cannot be accessed from \" + Data.dollarSignsToDots(thisSD.getName()), ", "+                                piece);", "+        return false;", "+", "-    if (_areInSamePackage(enclosingSD, thisSD)) {", "-      return true;", "-    }", "+    if (_areInSamePackage(enclosingSD, thisSD)) return true;", "-      if (addError) { _addError(\"The \" + dataType + \" \" + Data.dollarSignsToDots(name) + \" is package protected because there is no access specifier and cannot be accessed from \" + Data.dollarSignsToDots(thisSD.getName()), piece); }", "+      if (addError) _addError(\"The \" + dataType + \" \" + Data.dollarSignsToDots(name) + ", "+                              \" is package protected because there is no access specifier and cannot be accessed from \" ", "+                                + Data.dollarSignsToDots(thisSD.getName()), ", "+                              piece); "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd1bd72833d296be4f27042270967bfa", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/InteractionsModel.java", "commitBeforeChange": "771a0aee635c62bc6d0a2000fe605dc1113ef2b9", "commitAfterChange": "d1e56ac5c281c4b03c498f59138895f0f26350fa", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "   protected ArrayList<String> _getHistoryText(FileOpenSelector selector)     throws IOException, OperationCanceledException", "signatureAfterChange": "   protected ArrayList<String> _getHistoryText(FileOpenSelector selector)     throws IOException, OperationCanceledException", "diff": ["-    throws IOException, OperationCanceledException", "-  {", "+    throws IOException, OperationCanceledException {", "+    if (files == null) throw new IOException(\"No Files returned from FileSelector\");", "+    ", "-    if (files == null) {", "-      throw new IOException(\"No Files returned from FileSelector\");", "-    }", "-", "-    for (int i=0; i < files.length; i++) {", "-      if (files[i] == null) {", "-        throw new IOException(\"File name returned from FileSelector is null\");", "-      }", "-      File c = files[i];", "-      if (c != null) {", "-        try {", "-          FileInputStream fis = new FileInputStream(c);", "-          InputStreamReader isr = new InputStreamReader(fis);", "-          BufferedReader br = new BufferedReader(isr);", "-          String currLine;", "-          while ((currLine = br.readLine()) != null) {", "-            strings.add(currLine);", "-          }", "-          br.close(); // win32 needs readers closed explicitly!", "+    ", "+    for (File f: files) {", "+      if (f == null) throw new IOException(\"File name returned from FileSelector is null\");", "+      try {", "+        FileInputStream fis = new FileInputStream(f);", "+        InputStreamReader isr = new InputStreamReader(fis);", "+        BufferedReader br = new BufferedReader(isr);", "+        while (true) {", "+          String line = br.readLine();", "+          if (line == null) break;", "+          strings.add(line);", "-        catch (IOException ioe) {", "-          throw new IOException(\"File name returned from FileSelector is null\");", "-          //_showIOError(ioe);", "-        }", "+        br.close(); // win32 needs readers closed explicitly!", "-", "+      catch (IOException ioe) { throw new IOException(\"File name returned from FileSelector is null\"); }", "+    ", "-      String text = \"\";", "-      String currString;", "+      StringBuffer text = new StringBuffer();", "-      for (int j = 0; j < strings.size(); j++) {", "-        currString = strings.get(j);", "-        if (currString.length() > 0) {", "+      for (String s: strings) {", "+        int sl = s.length();", "+        if (sl > 0) {", "+          ", "-          if (firstLine && (currString.trim().equals(History.HISTORY_FORMAT_VERSION_2.trim()))) {", "-            formatVersion = 2;", "-          }", "+          if (firstLine && (s.trim().equals(History.HISTORY_FORMAT_VERSION_2.trim()))) formatVersion = 2;", "+          ", "-              if (currString.charAt(currString.length() - 1) == ';') {", "-                text += currString + _newLine;", "-              }", "-              else {", "-                text += currString + \";\" + _newLine;", "-              }", "+              text.append(s);", "+              if (s.charAt(sl - 1) != ';') text.append(';');", "+              text.append(_newLine);", "-              if (!firstLine) { // don't include format version string in output", "-                text += currString + _newLine;", "-              }", "+              if (!firstLine) text.append(s).append(_newLine); // omit version string from output", "-", "+      ", "-      histories.add(text);", "+      histories.add(text.toString());"]}], "num": 25150}