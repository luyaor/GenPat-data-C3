{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0fec10dbb36a2c941b6cbe102280bf1a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c100d815bebeef1924c8c21a00d7110", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 325, "methodNumberAfterChange": 243, "signatureBeforeChange": "      private boolean containsField(Type t, final String name, final boolean requireStatic)", "signatureAfterChange": "   private boolean containsField(Type t, String name, boolean onlyStatic)", "diff": ["+  public boolean containsStaticField(Type t, String name) { return containsField(t, name, true); }", "+  private boolean containsField(Type t, String name, boolean onlyStatic) {", "+    FieldFinder<FieldReference> finder = new FieldFinder<FieldReference>(name, onlyStatic) {", "+      protected FieldReference makeFieldReference(Type t, DJField f) {", "+        return new FieldReference(f, BOTTOM) {}; // anonymous stub just used for inheritance checking", "+      }", "+    };", "+    return finder.hasMatch(t);", "+  }", "-  ", "-  private boolean containsField(Type t, final String name, final boolean requireStatic) {", "-    debug.logStart(new String[]{\"t\", \"name\", \"requireStatic\"}, wrap(t), name, requireStatic); try {", "-    ", "-    class LookupField extends TypeAbstractVisitor<Iterable<Object>> {", "-      ", "-      private boolean _includePrivate;", "-      ", "-      public LookupField(boolean includePrivate) {", "-        _includePrivate = includePrivate;", "-      }", "-      ", "-      private boolean validField(DJField f) { ", "-        return", "-          (_includePrivate || !f.accessibility().equals(Access.PRIVATE)) &&", "-          (!requireStatic || f.isStatic());", "-      }", "-      ", "-      public Iterable<Object> defaultCase(Type t) { return IterUtil.empty(); }", "-      ", "-      @Override public Iterable<Object> forArrayType(ArrayType t) {", "-        return name.equals(\"length\") ? IterUtil.singleton(null) : IterUtil.empty();", "-      }", "-      ", "-      @Override public Iterable<Object> forClassType(ClassType t) {", "-        for (DJField f : t.ofClass().declaredFields()) {", "-          if (f.declaredName().equals(name) && validField(f)) {", "-            return IterUtil.singleton(null);", "-          }", "-        }", "-        return IterUtil.empty();", "-      }", "-      ", "-    }", "-    Iterable<? extends Object> results = lookupMember(t, new LookupField(true), new LookupField(false));", "-    return !IterUtil.isEmpty(results);", "-    ", "-    } finally { debug.logEnd(); }", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "33d0deab44a54222c4d61e0e1aabd011", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 292, "methodNumberAfterChange": 228, "signatureBeforeChange": "      private boolean containsMethod(Type t, final String name, final boolean requireStatic)", "signatureAfterChange": "   private boolean containsMethod(Type t, String name, boolean onlyStatic)", "diff": ["+  public boolean containsStaticMethod(Type t, String name) { return containsMethod(t, name, true); }", "+  private boolean containsMethod(Type t, String name, boolean onlyStatic) {", "+    MethodFinder<MethodInvocation> finder = new MethodFinder<MethodInvocation>(name, onlyStatic) {", "+      protected MethodInvocationCandidate<MethodInvocation> makeInvocationCandidate(DJMethod m,", "+                                                                                    ClassType declaringType) {", "+        // a version of the method that depends on no type information (which may not be available)", "+        DJMethod noSignatureMethod = new DelegatingMethod(m) {", "+          public Iterable<VariableType> declaredTypeParameters() { return IterUtil.empty(); }", "+          public Type returnType() { return BOTTOM; }", "+          public Iterable<Type> thrownTypes() { return IterUtil.empty(); }", "+          @Override public Iterable<LocalVariable> declaredParameters() { return IterUtil.empty(); }", "+          protected Iterable<? extends Type> parameterTypes() { return IterUtil.empty(); }", "+        };", "+        // anonymous stub used only for inheritance checking", "+        return new MethodInvocationCandidate<MethodInvocation>(noSignatureMethod, OBJECT, EMPTY_TYPE_ITERABLE,", "+                                                                 IterUtil.<Expression>empty(), NONE_TYPE_OPTION) {", "+          public MethodInvocation invocation() { throw new UnsupportedOperationException(); }", "+          @Override public boolean overrides(FunctionInvocationCandidate<MethodInvocation> c) { return false; }", "+        };", "+      }", "+    };", "+    return finder.hasMatch(t);", "+  }", "-  ", "-  private boolean containsMethod(Type t, final String name, final boolean requireStatic) {", "-    debug.logStart(new String[]{\"t\",\"name\",\"requireStatic\"}, wrap(t), name, requireStatic); try {", "-    ", "-    class LookupMethod extends TypeAbstractVisitor<Iterable<Object>> {", "-      ", "-      private boolean _includePrivate;", "-      ", "-      public LookupMethod(boolean includePrivate) {", "-        _includePrivate = includePrivate;", "-      }", "-      ", "-      private boolean validMethod(DJMethod m) { ", "-        return", "-          (_includePrivate || !m.accessibility().equals(Access.PRIVATE)) &&", "-          (!requireStatic || m.isStatic());", "-      }", "-      ", "-      public Iterable<Object> defaultCase(Type t) { return IterUtil.empty(); }", "-      ", "-      @Override public Iterable<Object> forClassType(ClassType t) {", "-        debug.logValues(new String[]{\"t\",\"methods\"}, wrap(t), t.ofClass().declaredMethods());", "-        for (DJMethod m : t.ofClass().declaredMethods()) {", "-          if (m.declaredName().equals(name) && validMethod(m)) {", "-            return IterUtil.singleton(null);", "-          }", "-        }", "-        return IterUtil.empty();", "-      }", "-    }", "-    Iterable<? extends Object> results = lookupMember(t, new LookupMethod(true), new LookupMethod(false));", "-    return !IterUtil.isEmpty(results);", "-    ", "-    } finally { debug.logEnd(); }", "-  }"]}], "num": 29492}