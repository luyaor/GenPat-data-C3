{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "74d60a6fe10c3a2179dca2935ffdf825", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a166a7f411d027aa922c5dbc58bf3f94", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "65fb8db1fb3e7570ae4fa352a26deb0e151b48ac", "commitAfterChange": "d933be24919e2ab110f61a795910708e74f868c4", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "   protected SymbolData defineSymbolData(final TypeDefBase typeDefBase, final String qualifiedTypeName,                                         final String enclosingClassName)", "signatureAfterChange": "   protected SymbolData defineSymbolData(final TypeDefBase typeDefBase, final String qualifiedTypeName,                                         final String enclosingClassName)", "diff": ["-    // Get or create SymbolDatas (continuations) for the interfaces", "+    // Get or create SymbolDatas for the interfaces", "-    for (final ReferenceType rt: rts) {", "-      SymbolData sD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "-      if (sD != null && ! sD.isInterface()) {", "-        sD.setInterface(true);", "-//        System.err.println(\"Interface type = \" + sD);", "-//        assert false;", "+    for (int i = 0; i < rts.length; i++) {", "+      final ReferenceType rt = rts[i];", "+      final String rtName = rt.getName();", "+      boolean forwardRef = false;", "+      SymbolData iD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "+      if (iD != null && ! iD.isContinuation() && ! iD.isInterface()) {", "+        _addError(\"The symbol \" + rtName + \" is not an interface\", typeDefBase);", "-      interfaces.add(sD);                     // Note: confirm that null can be added to an ArrayList", "-      if (sD == null) { ", "-        // create a fixup for this interface reference", "+      if (iD == null || iD.isContinuation())  { // create a dummy symbol pending fixUp TODO: is this necessary?", "+        iD = new SymbolData(rtName);", "+        forwardRef = true;", "+      }", "+      ", "+      interfaces.add(iD);                     ", "+      if (forwardRef) { ", "+        // create a fixup for this interface slot", "+        final int j = i;", "-            SymbolData newSD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "-            assert newSD != null && newSD.isInterface();  // EXPAND", "-            int lastIndex = interfaces.size() - 1;", "-            interfaces.set(lastIndex, newSD);", "+            SymbolData newID = _lookupTypeFromWithinClass(rt, enclosingClassName);", "+            if (newID == null) _addError(\"The symbol \" + rtName + \" is not defined\", typeDefBase);", "+            else if (! newID.isInterface()) ", "+              _addError(\"The symbol \" + rtName + \" is not an interface\", typeDefBase);", "+            interfaces.set(j, newID);", "+            sd.addEnclosingData(newID);", "+      ", "+    // Set the inferfaces; fixups will be done on the elements of the interface ArrayList, but this does not", "+    // add the found interface to the enclosing data of sd.", "+    sd.setInterfaces(interfaces);", "-      superSD = getSymbolData(\"java.lang.Object\", typeDefBase.getSourceInfo(), false);", "+      SymbolData objectSD = getSymbolData(\"java.lang.Object\", typeDefBase.getSourceInfo(), false);", "-      sd.setSuperClass(superSD);", "+      sd.setSuperClass(objectSD);", "+      sd.setInterface(false);", "-      superSD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "-//      if (superSD == null && rt.getName().equals(\"Object\"))  {", "-//        System.err.println(\"ALARM: _lookupTypeFromWithinClass for 'Object' returned null\");", "-//      }", "-      sd.setInterface(false);", "+      superSD = _lookupTypeFromWithinClass(rt, enclosingClassName);    ", "-//            System.err.println(\"***** In a FIXUP, looking up type \" + rt + \" from within \" + enclosingClassName);", "-//              newSuperSD = getSymbolData(\"java.lang.Object\", typeDefBase.getSourceInfo(), false);", "-              _addAndIgnoreError(\"The class \" + sd + \" has an undefined superclass \" + rt, typeDefBase);", "-            else", "+              _addError(\"The class \" + sd + \" has an undefined superclass \" + rt, typeDefBase);", "+            else  // TODO: Does not check that newSuperSD is not an interace  ", "-    ", "-    // Set the inferfaces; fixups will be done on the elements of the interface ArrayList", "-    sd.setInterfaces(interfaces);", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "baf260563450c9ffee215c4cfa9f6f8a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/TreeClass.java", "commitBeforeChange": "a139a9e69c4b7dea4b85588b3ff50e2c7a8a902f", "commitAfterChange": "482d47c4f5e2278590cc3b5fe2d773412c0b60da", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "   public TreeClass(String fullName, DJClass declaring, Access.Module accessModule, Node ast,                    final TreeClassLoader loader, Options opt)", "signatureAfterChange": "   public TreeClass(String fullName, DJClass declaring, Access.Module accessModule, final Node ast,                    final TreeClassLoader loader, Options opt)", "diff": ["-  public TreeClass(String fullName, DJClass declaring, Access.Module accessModule, Node ast,", "+  public TreeClass(String fullName, DJClass declaring, Access.Module accessModule, final Node ast,", "-        catch (LinkageError e) { throw new RuntimeException(\"Error loading class\", e); }", "+        catch (LinkageError e) {", "+          // bugfix for bug 2674112: Error loading class in Interpreter", "+          // maybe this isn't the best place", "+          if (e instanceof IllegalAccessError) {", "+            // catch this particular error and provide a better error message", "+            String msg = e.getMessage();", "+            final String PREFIX = \"class \";", "+            final String[] INFIX = new String[] { \" cannot access its superclass \",", "+              \" cannot access its superinterface \" };", "+            final String[] ERROR_MSGS = new String[] { \"class.cannot.access.superclass\",", "+              \"class.cannot.access.superinterface\" };", "+            if (msg.startsWith(PREFIX)) {", "+              for (int i=0; i<INFIX.length; ++i) {", "+                final String infix = INFIX[i];", "+                int infixPos = msg.indexOf(infix);", "+                if ((infixPos>=0) && (infixPos>=PREFIX.length())) {", "+                  String className0 = msg.substring(PREFIX.length(), infixPos).trim();", "+                  String className1 = msg.substring(infixPos+infix.length()).trim();", "+                  koala.dynamicjava.interpreter.NodeProperties.setErrorStrings(ast, className0, className1);", "+                  ExecutionError ee = new ExecutionError(ERROR_MSGS[i], ast);", "+                  throw new WrappedException(new CheckerException(ee));", "+                }", "+              }", "+            }", "+          }", "+          throw new RuntimeException(\"Error loading class\", e);", "+        }"]}], "num": 19336}