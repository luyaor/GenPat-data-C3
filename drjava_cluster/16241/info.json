{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "53274da54d8b45ca181e94015d50898e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7c7eef769eb3011d6870712c47b463ff", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/CompilerErrorModel.java", "commitBeforeChange": "24e790b85d3a1a29de15955ca1ba9200a6865f83", "commitAfterChange": "4ceb386773fd5eb837ddcd34820c563b6c3c20cb", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "   private void _calculatePositions()", "signatureAfterChange": "   private void _calculatePositions()", "diff": ["-    _positions = new Position[_errors.length];", "-      int numProcessed = 0;", "-", "-      //first skip errors with no file", "-      while(numProcessed < _errors.length && _errors[numProcessed].file() == null){", "-        _positions[numProcessed] = null;", "-        numProcessed++;", "-      }", "-", "-      while ((numProcessed < _errors.length)) {", "-        //skip errors with no position", "-        while(numProcessed < _errors.length && _errors[numProcessed].hasNoLocation()){", "-          _positions[numProcessed] = null;", "-          numProcessed++;", "-        }", "-        if (numProcessed >= _errors.length){", "+      int curError = 0;", "+      ", "+      // for(; numProcessed < _numErrors; numProcessed++) {", "+      while ((curError < _numErrors)) {", "+        ", "+        // find the next error with a line number (skipping others)", "+        curError = nextErrorWithLine(curError);", "+        if (curError >= _numErrors){", "-        File file = _errors[numProcessed].file();", "+        File file = _errors[curError].file();", "-        } catch (IOException e) {", "-          //skip positions for these errors if the document couldn't be loaded", "-         do {", "-            _positions[numProcessed] = null;", "-            numProcessed++;", "-          } while(numProcessed < _errors.length && _errors[numProcessed].file().equals(file));", "-        } catch (OperationCanceledException e) {", "-          //skip positions for these errors if the document couldn't be loaded", "-         do {", "-            _positions[numProcessed] = null;", "-            numProcessed++;", "-          } while(numProcessed < _errors.length && _errors[numProcessed].file().equals(file));", "+        } ", "+        catch (Exception e) {", "+          // This is intended to catch IOException or OperationCanceledException", "+          if ((e instanceof IOException) || (e instanceof OperationCanceledException)) {", "+            // skip positions for these errors if the document couldn't be loaded", "+            do {", "+              curError++;", "+            } while ((curError < _numErrors) && (_errors[curError].file().equals(file)));", "+            ", "+            //If the document couldn't be loaded, start the loop over at the top", "+            continue;", "+          }", "+          else {", "+            throw new UnexpectedException(e);", "+          }", "-        if (numProcessed >= _errors.length){", "+        if (curError >= _numErrors){", "-        //If the document couldn't be loaded, start the loop over at the top", "-        if (document == null){", "-          continue;", "-        }", "-", "-        int fileStartIndex = numProcessed;", "-        String defsText = document.getText(0, document.getLength());", "+        // curError is the first error in a file, and its document is open.", "+        final int fileStartIndex = curError;", "+        final int defsLength = document.getLength();", "+        final String defsText = document.getText(0, defsLength);", "-        // at the top of the loop", "-        while(numProcessed < _errors.length &&", "-          file.equals(_errors[numProcessed].file()) &&", "-          (offset <= defsText.length())) {", "+        // at the top of this loop", "+        while ((curError < _numErrors) && // we still have errors to find", "+               file.equals(_errors[curError].file()) &&  // the next error is in this file", "+               (offset <= defsLength)) { // we haven't gone past the end of the file", "-          // first figure out if we need to create any new positions on this line", "-          for (int i = numProcessed;", "-               (i < _errors.length) && (_errors[i].lineNumber() == curLine);", "-               i++){", "-            _positions[i] = document.createPosition(offset +  _errors[i].startColumn());", "-            numProcessed++;", "+          // create new positions for all errors on this line", "+          while ((curError < _numErrors)", "+                 && (_errors[curError].lineNumber() == curLine))", "+          {", "+            _positions[curError] =", "+              document.createPosition(offset +  _errors[curError].startColumn());", "+            curError++;", "-          int nextNewline = defsText.indexOf('\\n', offset);", "-          if (nextNewline == -1) {", "-            break;", "-          }", "-          else {", "-            curLine++;", "-            offset = nextNewline + 1;", "+          // At this point, offset is the starting index of the previous error's line.", "+          // Update offset to be appropriate for the current error.", "+          // ... but don't bother looking if it isn't in this file.", "+          // ... or if we're done with all errors already.", "+          if (curError < _numErrors) {", "+            int curErrorLine = _errors[curError].lineNumber();", "+            int nextNewline = 0;", "+            while ((curLine != curErrorLine) ", "+                     && (nextNewline != -1)", "+                     && (file.equals(_errors[curError].file()))) {", "+              nextNewline = defsText.indexOf('\\n', offset);", "+              if (nextNewline != -1) {", "+                curLine++;", "+                offset = nextNewline + 1;", "+              }", "+            }", "-        int fileEndIndex = numProcessed;", "+        int fileEndIndex = curError;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f48b875e57339a3f75afccf9e0970be", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/jpda/JPDADebugger.java", "commitBeforeChange": "5293cb4cfbc2f45d6061ba4101ad60348aa251ed", "commitAfterChange": "f68f43e5a680bb235f87f6125c6c0de6d15a12f4", "methodNumberBeforeChange": 85, "methodNumberAfterChange": 73, "signatureBeforeChange": "   private Value _convertToActualType(ThreadReference threadRef, LocalVariable localVar,                                      Value v)     throws InvalidTypeException, ClassNotLoadedException,     IncompatibleThreadStateException, InvocationException", "signatureAfterChange": "   private PrimitiveValue _unbox(ObjectReference val, ThreadReference thread) throws DebugException", "diff": ["+   */", "+  private PrimitiveValue _unbox(ObjectReference val, ThreadReference thread) throws DebugException {", "+    if (val == null) { throw new DebugException(\"Value can't be unboxed\"); }", "+    String type = val.referenceType().name();", "+    String m = null;", "+    String sig = null;", "+    if (type.equals(\"java.lang.Boolean\")) { m = \"booleanValue\"; sig = \"()Z\"; }", "+    else if (type.equals(\"java.lang.Integer\")) { m = \"intValue\"; sig = \"()I\"; }", "+    else if (type.equals(\"java.lang.Double\")) { m = \"doubleValue\"; sig = \"()D\"; }", "+    else if (type.equals(\"java.lang.Character\")) { m = \"charValue\"; sig = \"()C\"; }", "+    else if (type.equals(\"java.lang.Byte\")) { m = \"byteValue\"; sig = \"()B\"; }", "+    else if (type.equals(\"java.lang.Short\")) { m = \"shortValue\"; sig = \"()S\"; }", "+    else if (type.equals(\"java.lang.Long\")) { m = \"longValue\"; sig = \"()J\"; }", "+    else if (type.equals(\"java.lang.Float\")) { m = \"floatValue\"; sig = \"()F\"; }", "+    ", "+    if (m == null) { throw new DebugException(\"Value can't be unboxed\"); }", "+    else { return (PrimitiveValue) _invokeMethod(thread, val, m, sig); }", "+  }", "-   */", "-  private Value _convertToActualType(ThreadReference threadRef, LocalVariable localVar,", "-                                     Value v)", "-    throws InvalidTypeException, ClassNotLoadedException,", "-    IncompatibleThreadStateException, InvocationException", "-  {", "-    String typeSignature;", "-    try {", "-      typeSignature = localVar.type().signature();", "-    }", "-    catch (ClassNotLoadedException cnle) {", "-      return v;", "-    }", "-    Method m;", "-    ObjectReference ref = (ObjectReference)v;", "-    ReferenceType rt = ref.referenceType();", "-", "-    if ( typeSignature.equals(\"Z\") ) {", "-      m = _getMethod(rt, \"booleanValue\");", "-    }", "-    else if ( typeSignature.equals(\"B\") ) {", "-      m = _getMethod(rt, \"byteValue\");", "-    }", "-    else if ( typeSignature.equals(\"C\") ) {", "-      m = _getMethod(rt, \"charValue\");", "-    }", "-    else if ( typeSignature.equals(\"S\") ) {", "-      m = _getMethod(rt, \"shortValue\");", "-    }", "-    else if ( typeSignature.equals(\"I\") ) {", "-      m = _getMethod(rt, \"intValue\");", "-    }", "-    else if ( typeSignature.equals(\"J\") ) {", "-      m = _getMethod(rt, \"longValue\");", "-    }", "-    else if ( typeSignature.equals(\"F\") ) {", "-      m = _getMethod(rt, \"floatValue\");", "-    }", "-    else if ( typeSignature.equals(\"D\") ) {", "-      m = _getMethod(rt, \"doubleValue\");", "-    }", "-    else{", "-      return v;", "-    }", "-", "-    return ref.invokeMethod(threadRef, m, new LinkedList<Value>(), ObjectReference.INVOKE_SINGLE_THREADED);", "-  }"]}], "num": 16241}