{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c4bce5b3a9cd9f242d5602e847cf04d4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36f3bf7f0a7e838dff514d78ae100e57", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 60, "signatureBeforeChange": "   public TypeData forSimpleMethodInvocation(SimpleMethodInvocation that)", "signatureAfterChange": "   public TypeData forSimpleMethodInvocation(SimpleMethodInvocation that)", "diff": ["-    if (inStaticMethod()) { context = context.getSymbolData();} //Because it is static, want the SymbolData corresponding to the context, not the instance data.", "+    if (inStaticMethod()) context = context.getSymbolData();  // Need SymbolData for context, not instance data."]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "443ec9f23f54ea4019db8d059ec88625", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyElementaryVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r   public void forConcreteMethodDef(ConcreteMethodDef that)", "signatureAfterChange": "   public void forConcreteMethodDef(ConcreteMethodDef that)", "diff": ["-   */\r", "-  public void forConcreteMethodDef(ConcreteMethodDef that) {\r", "-    forConcreteMethodDefDoFirst(that);\r", "-    if (prune(that)) { return; }\r", "-    MethodData md = createMethodData(that, _symbolData);\r", "-    md.addPublicMav(); //All methods are automatically public at the Elementary level.\r", "-    String className = getUnqualifiedClassName(_symbolData.getName());\r", "-    if (className.equals(md.getName())) {\r", "-      _addAndIgnoreError(\"Constructors are they only methods that can have the same name as the class they appear in, and they are not allowed at the Elementary level\",\r", "-                         that);\r", "-    }\r", "-    else {\r", "-      _symbolData.addMethod(md);\r", "-    }\r", "-    that.getBody().visit(new BodyBodyElementaryVisitor(md, _file, _package, _importedFiles, _importedPackages, _classNamesInThisFile, continuations));\r", "-    forConcreteMethodDefOnly(that);\r", "-  }\r", "+   */", "+  public void forConcreteMethodDef(ConcreteMethodDef that) {", "+    forConcreteMethodDefDoFirst(that);", "+    if (prune(that)) return;", "+    MethodData md = createMethodData(that, _symbolData);", "+    md.addPublicMav(); // All methods are automatically public at the Elementary level.", "+    String className = getUnqualifiedClassName(_symbolData.getName());", "+    if (className.equals(md.getName())) {", "+      _addAndIgnoreError(\"Constructors are they only methods that can have the same name as the class they appear in, and they are not allowed at the Elementary level\",", "+                         that);", "+    }", "+    else {", "+      _symbolData.addMethod(md);", "+    }", "+    that.getBody().visit(new BodyBodyElementaryVisitor(md, _file, _package, _importedFiles, _importedPackages, _classNamesInThisFile, continuations));", "+    forConcreteMethodDefOnly(that);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "55d641ef8c75cbe223295bb0afe35c75", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyAdvancedVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r   public void forAbstractMethodDef(AbstractMethodDef that)", "signatureAfterChange": "   public void forAbstractMethodDef(AbstractMethodDef that)", "diff": ["-   */\r", "-  public void forAbstractMethodDef(AbstractMethodDef that) {\r", "-    forAbstractMethodDefDoFirst(that);\r", "-    if (prune(that)) { return; }\r", "-\r", "-    MethodData md = createMethodData(that, _symbolData);\r", "-    String className = getUnqualifiedClassName(_symbolData.getName());\r", "-    if (className.equals(md.getName())) {\r", "-      _addAndIgnoreError(\"Only constructors can have the same name as the class they appear in, and constructors do not have an explicit return type\",\r", "-                         that);\r", "-    }\r", "-    else {\r", "-      _symbolData.addMethod(md);\r", "-    }\r", "-  }\r", "+   */", "+  public void forAbstractMethodDef(AbstractMethodDef that) {", "+    forAbstractMethodDefDoFirst(that);", "+    if (prune(that)) return;", "+", "+    MethodData md = createMethodData(that, _symbolData);", "+    String className = getUnqualifiedClassName(_symbolData.getName());", "+    if (className.equals(md.getName())) {", "+      _addAndIgnoreError(\"Only constructors can have the same name as the class they appear in, and constructors do not have an explicit return type\",", "+                         that);", "+    }", "+    else {", "+      _symbolData.addMethod(md);", "+    }", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a808bb3adb182b847281a76d9951662", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyElementaryVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r   public void forAbstractMethodDef(AbstractMethodDef that)", "signatureAfterChange": "   public void forAbstractMethodDef(AbstractMethodDef that)", "diff": ["-   */\r", "-  public void forAbstractMethodDef(AbstractMethodDef that) {\r", "-    forAbstractMethodDefDoFirst(that);\r", "-    if (prune(that)) { return; }\r", "-    MethodData md = createMethodData(that, _symbolData);\r", "-    String className = getUnqualifiedClassName(_symbolData.getName());\r", "-    if (className.equals(md.getName())) {\r", "-      _addAndIgnoreError(\"Constructors are they only methods that can have the same name as the class they appear in, and they are not allowed at the Elementary level\",\r", "-                         that);\r", "-    }\r", "-    else {\r", "-      _symbolData.addMethod(md);\r", "-    }\r", "-    forAbstractMethodDefOnly(that);\r", "-  }\r", "+   */", "+  public void forAbstractMethodDef(AbstractMethodDef that) {", "+    forAbstractMethodDefDoFirst(that);", "+    if (prune(that)) return;", "+    MethodData md = createMethodData(that, _symbolData);", "+    String className = getUnqualifiedClassName(_symbolData.getName());", "+    if (className.equals(md.getName())) {", "+      _addAndIgnoreError(\"Constructors are they only methods that can have the same name as the class they appear in, and they are not allowed at the Elementary level\",", "+                         that);", "+    }", "+    else {", "+      _symbolData.addMethod(md);", "+    }", "+    forAbstractMethodDefOnly(that);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6a6bdaff1a9908909f3d1cce73020a1e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/IntermediateVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public void forModifiersAndVisibilityDoFirst(ModifiersAndVisibility that)", "signatureAfterChange": "   public void forModifiersAndVisibilityDoFirst(ModifiersAndVisibility that)", "diff": ["-      if (!(temp.equals(\"abstract\") || temp.equals(\"public\") || temp.equals(\"private\") || temp.equals(\"protected\") || temp.equals(\"static\"))) {", "+      if (! (temp.equals(\"abstract\") || temp.equals(\"public\") || temp.equals(\"private\") || temp.equals(\"protected\") || temp.equals(\"static\"))) {", "-      if (count > 1) {", "-        temp = temp + \"s\";", "-      }", "+      if (count > 1)  temp = temp + \"s\";"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bec6560a8dd832e3387c291022a1e82d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/IntermediateVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "   public void forInterfaceDef(InterfaceDef that)", "signatureAfterChange": "   public void forInterfaceDef(InterfaceDef that)", "diff": ["-    if (prune(that)) { return; }", "+    if (prune(that)) return;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c24b7b755f27f37a9c3a61dca73fea40", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ConstructorBodyTypeChecker.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r   private void implicitSuperConstructor(BracedBody that)", "signatureAfterChange": "   private void implicitSuperConstructor(BracedBody that)", "diff": ["-   */\r", "-  private void implicitSuperConstructor(BracedBody that) {\r", "-    SymbolData superClass = _data.getSymbolData().getSuperClass();\r", "-    \r", "-    if (superClass == null) {  //This should never happen, but if it does, no reason to throw an error.\r", "-      return;\r", "-    }\r", "-\r", "-    //If the super class is an inner class, there cannot be an implicit constructor call\r", "-    if (superClass.getOuterData() != null && !(superClass.hasModifier(\"static\"))) {\r", "-      _addError(\"There is an implicit call to the constructor of \" + superClass.getName() + \" here, but \" + superClass.getName() + \" is a non-static inner class of \" + superClass.getOuterData().getName() + \".  Thus, you must explicitly invoke its constructor from an instance of its outer class\", that);\r", "-      return;\r", "-    }\r", "-\r", "-    \r", "-    //Look in this's super class and try to match the invocation.  If no match is found, the method invocation will add an error.\r", "-    String name = LanguageLevelVisitor.getUnqualifiedClassName(superClass.getName());\r", "-    \r", "-    //There must be a default constructor with no arguments, or an error is thrown.\r", "-    //(Note--if there were no constructors in the super class at all, the default no arguments constructor would exist.  However, a constructor is always\r", "-    //generated for a LanguageLevel file, and any class file that relied on the default constructor would already have it.  Therefore, we can assume\r", "-    //that all classes have at least one constructor).\r", "-    MethodData cd = _lookupMethod(name, superClass, new InstanceData[0], that, \r", "-                           \"You must invoke one of \" + superClass.getName() + \"'s constructors here.  You can either explicitly invoke one of its exisitng constructors or add a constructor with signature: \", \r", "-                           true, superClass);\r", "-\r", "-    if (cd == null) {return;}\r", "-    //if constructor is declared to throw exceptions, add them to thrown list:\r", "-    //add BracedBody as the JExpression corresponding to the error\r", "-    String[] thrown = cd.getThrown();\r", "-    for (int i = 0; i<thrown.length; i++) {\r", "-      _thrown.addLast(new Pair<SymbolData, JExpression>(getSymbolData(thrown[i], _getData(), that), that));\r", "-    }\r", "-    \r", "-    \r", "-    return;\r", "-  }\r", "+   */", "+  private void implicitSuperConstructor(BracedBody that) {", "+    SymbolData superClass = _data.getSymbolData().getSuperClass();", "+    ", "+    if (superClass == null) {  //This should never happen, but if it does, no reason to throw an error.", "+      return;", "+    }", "+", "+    //If the super class is an inner class, there cannot be an implicit constructor call", "+    if (superClass.getOuterData() != null && !(superClass.hasModifier(\"static\"))) {", "+      _addError(\"There is an implicit call to the constructor of \" + superClass.getName() + \" here, but \" + superClass.getName() + \" is a non-static inner class of \" + superClass.getOuterData().getName() + \".  Thus, you must explicitly invoke its constructor from an instance of its outer class\", that);", "+      return;", "+    }", "+", "+    ", "+    //Look in this's super class and try to match the invocation.  If no match is found, the method invocation will add an error.", "+    String name = LanguageLevelVisitor.getUnqualifiedClassName(superClass.getName());", "+    ", "+    //There must be a default constructor with no arguments, or an error is thrown.", "+    //(Note--if there were no constructors in the super class at all, the default no arguments constructor would exist.  However, a constructor is always", "+    //generated for a LanguageLevel file, and any class file that relied on the default constructor would already have it.  Therefore, we can assume", "+    //that all classes have at least one constructor).", "+    MethodData cd = _lookupMethod(name, superClass, new InstanceData[0], that, ", "+                           \"You must invoke one of \" + superClass.getName() + \"'s constructors here.  You can either explicitly invoke one of its exisitng constructors or add a constructor with signature: \", ", "+                           true, superClass);", "+", "+    if (cd == null) return;", "+    //if constructor is declared to throw exceptions, add them to thrown list:", "+    //add BracedBody as the JExpression corresponding to the error", "+    String[] thrown = cd.getThrown();", "+    for (int i = 0; i<thrown.length; i++) {", "+      _thrown.addLast(new Pair<SymbolData, JExpression>(getSymbolData(thrown[i], _getData(), that), that));", "+    }", "+    ", "+    ", "+    return;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d12998b28b4db5937e4bef2fbcbe9671", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": "   void reassignVariableDatas(LinkedList<VariableData> l1, LinkedList<VariableData> l2)", "signatureAfterChange": "   void reassignVariableDatas(LinkedList<VariableData> l1, LinkedList<VariableData> l2)", "diff": ["-   */", "+    */", "-      if (l2.contains(l1.get(i))) {", "-        l1.get(i).gotValue();", "-      }", "+      if (l2.contains(l1.get(i))) l1.get(i).gotValue();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f22a0dfb862812eded5f918f5772f224", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/IntermediateVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "   public void forClassDef(ClassDef that)", "signatureAfterChange": "   public void forClassDef(ClassDef that)", "diff": ["-    if (prune(that)) { return; }", "+    if (prune(that)) return;"]}], "num": 19972}