{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "008e52592babe683b2b4d9db296d31c2", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "011e224d2c8ac2b8d59fc023ccd989ba", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/newjvm/MainJVM.java", "commitBeforeChange": "ab54ffeb9782712c65269bca65fea798aa2c5712", "commitAfterChange": "beead1fa2c7ee24ed59761a6b295b4aa1355139e", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 43, "signatureBeforeChange": "   protected void slaveQuitDuringStartup(int status)", "signatureAfterChange": "   private void _doStartup()", "diff": ["+  /** Call invokeSlave with the appropriate JVMBuilder.  Defined here to allow for multiple attempts. */", "+  private void _doStartup() {", "+    Iterable<File> classPath;", "+    List<String> jvmArgs = new ArrayList<String>();", "+    File dir;", "+    synchronized (_startupLock) {", "+      if (_allowAssertions) { jvmArgs.add(\"-ea\"); }", "+      classPath = _startupClassPath;", "+      dir = _workingDir;", "+    }", "+    // TODO: Eliminate NULL_FILE.  It is a bad idea!  The correct behavior when it is used always depends on", "+    // context, so it can never be treated transparently.  In this case, the process won't start.", "+    if (dir == FileOps.NULL_FILE) { dir = IOUtil.WORKING_DIRECTORY; }", "+    int debugPort = _getDebugPort();", "+    String slaveMemory = DrJava.getConfig().getSetting(OptionConstants.SLAVE_JVM_XMX);", "+    if (!\"\".equals(slaveMemory) && !OptionConstants.heapSizeChoices.get(0).equals(slaveMemory)) {", "+      jvmArgs.add(\"-Xmx\" + slaveMemory + \"M\");", "+    String slaveArgs = DrJava.getConfig().getSetting(OptionConstants.SLAVE_JVM_ARGS);", "+    if (PlatformFactory.ONLY.isMacPlatform()) {", "+      jvmArgs.add(\"-Xdock:name=Interactions\");", "+    jvmArgs.addAll(ArgumentTokenizer.tokenize(slaveArgs));", "+    invokeSlave(new JVMBuilder(classPath).directory(dir).jvmArguments(jvmArgs));", "-    */", "-  protected void slaveQuitDuringStartup(int status) {", "-    super.slaveQuitDuringStartup(status);", "-    _numAttempts++;  // no synchronization since this is the only place that _numAttempts is modified", "-    if (Utilities.TEST_MODE || _numAttempts < MAX_COUNT) return;  // Some tests kill the slave immediately after it starts.", "-    ", "-    // The slave JVM is not enabled after this to prevent an infinite loop of attempted startups", "-    _restart = false;", "-    ", "-    // Signal that an internal error occurred", "-    String msg = \"Interpreter JVM exited before registering, status: \" + status;", "-    IllegalStateException e = new IllegalStateException(msg);", "-    new edu.rice.cs.drjava.ui.DrJavaErrorHandler().handle(e);", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dbf805030aef3f9818988ae3841ca4e2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/sourcechecker/SourceChecker.java", "commitBeforeChange": "80debf5b9716524c576a71fc4929233c9637cd68", "commitAfterChange": "0dc6c4e6c51f7a1991368187e63e0eff0d7150ef", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 39, "signatureBeforeChange": "              public static void main(String... args)", "signatureAfterChange": "      public static void main(String... args)", "diff": ["-    ", "-  public static void main(String... args) {", "-    ArgumentParser argParser = new ArgumentParser();", "-    argParser.supportOption(\"classpath\", \"\");", "-    argParser.supportAlias(\"cp\", \"classpath\");", "-    argParser.supportOption(\"jls\");", "-    argParser.requireParams(1);", "-    final ArgumentParser.Result parsedArgs = argParser.parse(args);", "-    ", "-    Options opt = new Options() {", "-        TypeSystem result = parsedArgs.hasOption(\"jls\") ? new JLSTypeSystem(this) : new ExtendedTypeSystem(this);", "-    };", "+  ", "+  public static void main(String... args) {", "+    debug.logStart();", "+", "+    ArgumentParser argParser = new ArgumentParser();", "+    argParser.supportOption(\"classpath\", \"\");", "+    argParser.supportAlias(\"cp\", \"classpath\");", "+    argParser.supportOption(\"opt\", 1);", "+    argParser.requireParams(1);", "+    final ArgumentParser.Result parsedArgs = argParser.parse(args);", "+    if (parsedArgs.hasOption(\"opt\")) {", "+      Options opt = _options.get(parsedArgs.getUnaryOption(\"opt\"));", "+      if (opt == null) { System.out.println(\"Unrecognized options name: \" + parsedArgs.getUnaryOption(\"opt\")); }", "+      else { processFiles(sources, cp, opt); }", "+    }", "+      ", "+    else {", "+      Iterator<String> optNames = _options.keySet().iterator();", "+      String canonicalName = optNames.next();", "+      Iterable<CompilationUnit> canonical = processFiles(sources, cp, _options.get(canonicalName));", "+      Map<String, Iterable<CompilationUnit>> others = new LinkedHashMap<String, Iterable<CompilationUnit>>();", "+      while (optNames.hasNext()) {", "+        String n = optNames.next();", "+        others.put(n, processFiles(sources, cp, _options.get(n)));", "+      }", "+      NodeDiff diff = new NodeDiff();", "+      for (Map.Entry<String, Iterable<CompilationUnit>> e : others.entrySet()) {", "+        diff.compare(canonicalName, canonical, e.getKey(), e.getValue());", "+      }", "+    }", "+    ", "+    debug.logEnd();", "+  }", "-      new SourceChecker(opt, false).check(sources, cp);"]}], "num": 6351}