{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ea89da83000cec1bb24104aecda39411", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a6a252ca5e7a4ce7827b10f2faab924", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "c7ce54f2435a198c543bef7b35866738d8690d46", "commitAfterChange": "f9b3ce896f60a5fa583a421b5b2bb827822b30df", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 36, "signatureBeforeChange": "   protected SymbolData getSymbolDataHelper(String className, SourceInfo si, boolean resolve, boolean fromClassFile,                                             boolean addError, boolean checkImportedStuff)", "signatureAfterChange": "   protected SymbolData getSymbolDataHelper(String className, SourceInfo si, boolean resolve, boolean fromClassFile,                                             boolean addError, boolean checkImportedStuff)", "diff": ["-   */", "+    */", "-      return _getSymbolData_ArrayType(className, si, resolve, fromClassFile, addError, checkImportedStuff);", "+      return _getArraySymbolData(className, si, resolve, fromClassFile, addError, checkImportedStuff);", "-    if (className.indexOf(\".\") != -1) {", "-      return _getSymbolData_IsQualified(className, si, resolve, fromClassFile, addError);", "-    }", "+    if (className.indexOf(\".\") != -1) return _getQualifiedSymbolData(className, si, resolve, fromClassFile, addError);", "+//    if (className.equals(\"Object\")) System.err.println(\"QualifiedClassName for Object = \" + qualifiedClassName);", "+//    System.err.println(\"qualifiedClassName for \" + className + \" is \" + qualifiedClassName);", "-    ", "-    // Check if className was specifically imported. --Not done at elementary level.", "+   ", "+    // Check if className was specifically imported -- Not done at elementary level.", "-    //We will not check that the package is correct here, because it is caught in the type checker.", "+    // We will not check that the package is correct here, because it is caught in the type checker.", "-            return getSymbolData(s, si, resolve, fromClassFile, addError, false); // addError??", "+//            if (className.equals(\"Woah\")) System.err.println(\"Calling getSymbolData for Woah\");", "+            return getSymbolData(s, si, resolve, fromClassFile, addError, false);  // POTENTIAL INFINITE RECURSION!", "+//      if (className.equals(\"Woah\")) ", "+//        System.err.println(\"Potentially calling getSymbolData_FromFileSystem for Woah; sd = \" + sd);", "-        if (sd != SymbolData.KEEP_GOING) {", "-          return sd;", "-        }", "+//        if (className.equals(\"Woah\")) ", "+//          System.err.println(\"getSymbolData_FromFileSystem for Woah returned = \" + sd);", "+        if (sd != null && sd != SymbolData.NOT_FOUND) return sd;", "-    ", "-    ", "+", "+//      if (className.equals(\"Object\")) System.err.println(\"Checking import packages for Object\");", "+//        if (className.equals(\"Object\")) System.err.println(\"Looking up: \" + s);", "-        if (s.indexOf(\"$\") != -1) {", "-          tempSd = getSymbolData(s, si, resolve, fromClassFile, false, false);", "-        }", "-        else {", "-          tempSd = getSymbolDataHelper(s, si, resolve, fromClassFile, false, false);", "-        }", "+        tempSd = getSymbolDataHelper(s, si, resolve, fromClassFile, false, false);", "+//        if (className.equals(\"Object\")) ", "+//          System.err.println(\"matching sd is: \" + tempSd + \"\\nsymbolTable.get(\\\"\" + s + \"\\\") = \"+ symbolTable.get(s));", "-          if (resultSd == null) { resultSd = tempSd; }", "-          else {", "+          if (resultSd == null) resultSd = tempSd;", "+          else {  // tempSd is NOT the first match; flag an error"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93fa3aa2a6feef9943ddab5f2edd18ac", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "3e22080f0d9650b7b802f9b713065e47d1a0ce19", "commitAfterChange": "1bbb44dda9ccbed1420a315a25ace5ab1cf20f80", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": "   protected SymbolData getSymbolData(String className, SourceInfo si, boolean resolve, boolean fromClassFile,                                       boolean addError, boolean checkImportedStuff)", "signatureAfterChange": "   protected SymbolData getSymbolData(String className, SourceInfo si, boolean resolve, boolean fromClassFile,                                       boolean addError, boolean checkImportedStuff)", "diff": ["-    ", "-//    if (className.equals(\"Constant\")) throw new RuntimeException(\"getSymbol called on Constant\");", "-    ", "-//    if (className.equals(\"Object\")) ", "-//      System.err.println(\"getSymbolData(\" + className + \", \" + si + \", \" + resolve + \", \" + fromClassFile + \", \" + addError +", "-//             \", \" + checkImportedStuff);", "-    ", "-    int indexOfNextDot = className.indexOf(\".\");", "-    /* we don't think this is necessay, but as a safety percausion, check the $ that denotes anonymous inner classes ", "-     * and inner classes. */", "-    int indexOfNextDollar = className.indexOf(\"$\");  ", "-    if (indexOfNextDot == -1 && indexOfNextDollar == -1) {", "-      return getSymbolDataHelper(className, si, resolve, fromClassFile, addError, checkImportedStuff);", "+ ", "+    if (className.endsWith(\"[]\")) { // className refers to an array type", "+      SymbolData sd = ", "+        getSymbolData(className.substring(0, className.length() - 2), si, resolve, fromClassFile, addError, ", "+                      checkImportedStuff);", "+      if (sd == null) return null; // Should not happen", "+      ArrayData ad = new ArrayData(sd, this, si);", "+      symbolTable.put(ad.getName(), ad);", "+      return ad;", "-    else { indexOfNextDot = 0; }  // ABOMINABLE CODING", "-    SymbolData whatever;", "+    ", "+    // First, handle classNames that clearly do NOT refer to inner classes", "+    int indexOfNextDot = className.indexOf(\".\");", "+    int indexOfNextDollar = className.indexOf(\"$\");   // '$' is assumed not to appear in source program type names", "+    if (indexOfNextDot == -1 && indexOfNextDollar == -1)", "+      return getSymbolDataHelper(className, si, resolve, fromClassFile, addError, checkImportedStuff);", "+    ", "+    // Try to decompose className into an inner class reference, but name may simply be fully qualified", "+    indexOfNextDot = 0;   ", "+    SymbolData sd;", "-      String s = className.substring(0, indexOfNextDot);", "+      String prefix = className.substring(0, indexOfNextDot);", "-      boolean newResolve = resolve || (indexOfNextDot != length);", "-      whatever = getSymbolDataHelper(s, si, newResolve, fromClassFile, false, checkImportedStuff);", "-//      if (s.equals(\"fully.qualified.Woah\")) throw new RuntimeException(s + \" passed to helper and newResolve = \" + resolve );", "-      if (whatever != null) {", "+//      boolean newResolve = resolve || (indexOfNextDot != length);", "+      sd = getSymbolDataHelper(prefix, si, resolve, fromClassFile, false, checkImportedStuff);", "+//      if (prefix.equals(\"fully.qualified.Woah\")) throw new RuntimeException(prefix + \" passed to helper and newResolve = \" + resolve );", "+      if (sd != null) { // prefix matches an extant symbol", "+        String outerClassName = prefix;", "-        SymbolData outerClass = whatever;", "-        if (whatever != null && indexOfNextDot != length) {", "-          outerClass = whatever;", "+        if (indexOfNextDot != length) {", "+          SymbolData outerClassSD = sd;", "-          whatever = outerClass.getInnerClassOrInterface(innerClassName);", "+//          System.err.println(\"Outer class prefix found: \" + prefix + \" inner class extension: \" + innerClassName);", "+          sd = outerClassSD.getInnerClassOrInterface(innerClassName);", "+//          System.err.println(\"Corresponding symbol = \" + sd);", "+          if (sd == null) { // create continuation for inner class; we are forbidding some ambiguities Java may permit", "+            sd = addInnerSymbolData(si, outerClassName + \".\" + innerClassName, outerClassSD);", "+          }", "+          return sd;", "-        if (whatever == SymbolData.AMBIGUOUS_REFERENCE) {", "+        else if (sd == SymbolData.AMBIGUOUS_REFERENCE) {", "-        if (whatever != null && whatever != SymbolData.NOT_FOUND) { return whatever; }", "-        else { ", "-          //perhaps this was an array type--try to resolve it without the [], and then put it in the symbol table", "-          if (className.endsWith(\"[]\")) { ", "-            SymbolData sd = ", "-              getSymbolData(className.substring(0, className.length() - 2), si, resolve, fromClassFile, addError, ", "-                            checkImportedStuff);", "-            if (sd != null) {", "-              ArrayData ad = new ArrayData(sd, this, si);", "-              symbolTable.put(ad.getName(), ad);", "-              return ad;", "-            }", "-            return sd;", "-          }", "-        }", "+        else if (sd != null && sd != SymbolData.NOT_FOUND) { return sd; }", "+      // sd may be null or an error element of SymbolData", "+    ", "+    // No match was found", "+//      throw new RuntimeException(\"Invalid class name \" + newName + \" encountered in file \" + _file);"]}], "num": 24670}