{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2225857d3150118c64d0616acb451cb3", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e3cdee824fbb3adcb101e16171b5c29", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/ConcreteRegionManager.java", "commitBeforeChange": "b552f36a1d45e65c0515c4425e1954dc75014315", "commitAfterChange": "4f7118cfc181d6dc991cba376f6e7b8942d8b8fc", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "      public ArrayList<R> getRegionsNear(OpenDefinitionsDocument odd, int offset)", "signatureAfterChange": "   public Pair<R, R> getRegionInterval(OpenDefinitionsDocument odd, int offset)", "diff": ["-  public ArrayList<R> getRegionsNear(OpenDefinitionsDocument odd, int offset) {", "+  /** Finds the interval of regions in odd such that the line label (excerpt) for the region contains offset. */", "+  public Pair<R, R> getRegionInterval(OpenDefinitionsDocument odd, int offset) {", "-    /* Get the tailSet consisting of the ordered set of regions [start, end) such that end > offset - 120.  The maximium", "-     * size of the excerpt enclosing a region is 120 characters. */", "+    /* Get the interval of regions whose line label (excerpts) contain offset. The maximium size of the excerpt ", "+     * enclosing a region is 120 characters; it begins at the start of the line containing the start of the region. ", "+     * Since empty regions are ignore (and deleted as soon as they are found), the end of a containing region must be ", "+     * less than 120 characters from offset.  Find the tail set of all regions [start, end) where offset - 120 < end.", "+     */", "-    SortedSet<R> tail = getTailSet((R) newDocumentRegion(odd, 0, offset - 119));", "+    SortedSet<R> tail = getTailSet((R) new DocumentRegion(odd, 0, offset - 119));", "-    /* Search tail, selecting each region r such that r.getLineEnd() > offset and r.getLineStart < offset.  The tail is", "-     * totally order on BOTH getLineStart() and getLineEnd() because the functions mapping start to lineStart and end to", "-     * lineEnd are monotonic and the tail is totally ordered on BOTH start and end.  Hence, we can abandon the search as", "-     * soon as we reach a region r such that r.getLineStart() >= offset.  tail may be empty. */", "+    /* Search tail, selecting first and last regions r such that r.getLineEnd() >= offset and r.getLineStart <= offset.", "+     * The tail is totally order on BOTH getLineStart() and getLineEnd() because the functions mapping start to lineStart", "+     * and end to lineEnd are monotonic and the tail is totally ordered on BOTH start and end (since regions do not ", "+     * overlap).  Hence, we can abandon the search as soon as we reach a region r such that r.getLineStart() > offset.  ", "+     * tail may be empty. */", "-    ArrayList<R> result = new ArrayList<R>(0);  // For most edits, there is no match. Should we use a LinkedList?", "-    for (R r: tail) {", "+    // Find the first and last regions whose bounds (using line boundaries) contain offset", "+    Iterator<R> it = tail.iterator();", "+    R first = null;", "+    R last = null;", "+    ", "+    // Find first", "+    while (it.hasNext()) {", "+      R r = it.next();", "+//      System.err.println(\"Testing region '\" + r.getString() + \"'\");", "+//      System.err.println(\"lineStart = \" + lineStart + \" offset = \" + offset);", "+      if (lineStart > offset) break;  // first == null implying test following loop will return", "-      if (lineStart - 1 <= offset && lineEnd >= offset) {", "-        result.add(r);", "-//        System.err.println(\"Adding tail set region \" + r + \" to update list\");", "+//      System.err.println(\"lineEnd = \" + lineEnd);", "+      if (lineStart - 1 <= offset && lineEnd >= offset) {  // - 1 required to handle inserting wing comment chars", "+        first = r;", "+//        System.err.println(\"Found first region in getRegionInterval = '\" + r.getString() +  \"'\");", "+        break;", "-      else if (lineStart > offset) break;", "+    if (first == null) return null;", "-    return result;", "+    // Find last", "+    last = first;", "+    while (it.hasNext()) {", "+      R r = it.next();", "+      int lineStart = r.getLineStartOffset();", "+      if (lineStart > offset) break;", "+      int lineEnd = r.getLineEndOffset();", "+      if (lineStart <= offset && lineEnd >= offset) {", "+        last = r;", "+      }", "+    }", "+//    System.err.println(\"Found last region in getRegionInterval = '\" + last +  \"'\");", "+    return new Pair<R, R>(first, last);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dcbcd1014980b0cc1d3e7af631b29eb2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/reducedmodel/ReducedModelBrace.java", "commitBeforeChange": "c36376a479e48347a90a7534812768b74b033816", "commitAfterChange": "1018be24b33ba74b1be6da8d72dc97e6545e20b1", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "   public int balanceForward()", "signatureAfterChange": "   public int balanceForward()", "diff": ["+    //System.out.println(\"-------------------------------------------\");", "+    resetWalkerLocationToCursor();", "-    ", "-    resetLocation(); //resets location of ReducedModelComment", "-    ", "-    if (iter.atStart())", "-      iter.next();", "-    ", "+    if (iter.atStart() ||", "+        iter.atFirstItem() ||", "+        !openBraceImmediatelyLeft())", "+    {", "+//      System.out.println(\"openBraceImmediatelyLeft(): \"+openBraceImmediatelyLeft());", "+      iter.dispose();", "+//      System.out.println(\"! atStart, atFirstItem, or no closed brace\");", "+      return -1;", "+    }", "+", "+    iter.prev();", "+    relDistance = -iter.current().getSize();", "-    // immediately to the right of the cursor", "-    if (!iter.atEnd() && openBraceImmediatelyRight()) {", "-      if (stateAtRelLocation(relDistance) == FREE) {", "-        relDistance = 0;", "-        // initialize the distance and the stack with the first brace,", "-        // the one we are balancing", "-        ", "+    // immediately to the left of the cursor", "+    if (iter.current().isOpenBrace()) {", "+      if(moveWalkerGetState(relDistance) == FREE) {", "+        // initialize the stack with the first brace, the one we are balancing", "-        distance += iter.current().getSize();", "+", "+        // reset the walker and iter to where we started", "-        ", "-        // either we get a match and the stack is empty", "-        // or we reach the end of a file and haven't found a match", "-        // or we have a closed brace that doesn't have a match,", "-        //    so we abort", "-        while (!iter.atEnd() && !braceStack.isEmpty()) {", "-          if (!iter.current().isGap()) {", "-            if (stateAtRelLocation(relDistance) == FREE) {", "+        moveWalkerGetState(-relDistance);", "+        relDistance = 0;", "+      }", "+      else {", "+        // the open brace is in a comment or quotation => ignore it", "+        iter.dispose();", "+//        System.out.println(\"! state at relative location != FREE\");", "+        return -1;", "+      }", "+    }", "+    else {", "+      // this isn't an open brace => ignore it", "+      iter.dispose();", "+//      System.out.println(\"! no open brace to immediate left of cursor\");", "+      return -1;", "+    }", "+    // either we get a match and the stack is empty", "+    // or we reach the end of a file and haven't found a match", "+    // or we have a close brace that doesn't have a match,", "+    // so we abort", "+    while (!iter.atEnd() && !braceStack.isEmpty()) {", "+      if (!iter.current().isGap()) {", "+        if (moveWalkerGetState(relDistance) == FREE) {", "+              // check for closed brace", "-                if (!iter.current().isMatch(popped)) {", "+                if (!iter.current().isMatch(popped)){", "+//                  System.out.println(\"! encountered closed brace that didn't match\");", "-              //open", "-              else{", "+              // otherwise, this must be an open brace", "+              else {", "-            relDistance = 0;", "-          }", "-          // no matter what, we always want to increase the distance", "-          // by the size of the token we have just gone over", "-          distance += iter.current().getSize();", "-          relDistance += iter.current().getSize();", "-          iter.next();", "-        }", "-        ", "-        // we couldn't find a match", "-        if (!braceStack.isEmpty()) {", "-          iter.dispose();", "-          return -1;", "-        }", "-        // success", "-        else {", "-          iter.dispose();", "-          return distance;", "-        }", "+        relDistance = 0;", "-      // not the right initial conditions ", "+      // no matter what, we always want to increase the distance", "+      // by the size of the token we have just gone over", "+        distance += iter.current().getSize();", "+        relDistance += iter.current().getSize();", "+        iter.next();", "-    iter.dispose();", "-    return -1;", "+", "+    // we couldn't find a match", "+    if (!braceStack.isEmpty()) {", "+      iter.dispose();", "+//      System.out.println(\"! ran to end of file. distance: \" + distance);", "+      return -1;", "+    }", "+    // success", "+    else {", "+      iter.dispose();", "+      return distance;", "+    }"]}], "num": 26548}