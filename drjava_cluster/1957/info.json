{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "34d7a73018db0824167a02de8dff4e91", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f6f45f46fa31818dcdcfa89a6a75a73", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/predictive/PredictiveInputFrame.java", "commitBeforeChange": "a0485f85335f36c90789dfb389fcf6d34d6ebb24", "commitAfterChange": "bdfe950dc400d21dc2bdd8774632b12854b9f66c", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "   private void init(boolean info)", "signatureAfterChange": "   private void init(boolean info)", "diff": ["-    Dimension parentDim = (_owner !=null) ? _owner.getSize() : getToolkit().getScreenSize();", "-    //int xs = (int)parentDim.getWidth()/3;", "-    int ys = (int)parentDim.getHeight()/4;", "-    setSize(new Dimension((int)getSize().getWidth(), (int)Math.min(_owner.getSize().getHeight(), Math.max(ys, 300))));", "+    Dimension parentDim = (_owner != null) ? _owner.getSize() : getToolkit().getScreenSize();", "+    //int xs = (int) parentDim.getWidth()/3;", "+    int ys = (int) parentDim.getHeight()/4;", "+    // in line below, parentDim was _owner.getSize(); changed because former could generate NullPointerException", "+    setSize(new Dimension((int) getSize().getWidth(), (int)Math.min(parentDim.getHeight(), Math.max(ys, 300)))); "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e65b7d0e1986967b566a6a028244f6ce", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 90, "methodNumberAfterChange": 90, "signatureBeforeChange": "\r   \r     \r     public void testGetSymbolDataHelper()", "signatureAfterChange": "             public void testGetSymbolDataHelper()", "diff": ["-    \r", "-    public void testGetSymbolDataHelper() {\r", "-      // Primitive types\r", "-      assertEquals(\"should return the int SymbolData\", SymbolData.INT_TYPE, _llv.getSymbolDataHelper(\"int\", JExprParser.NO_SOURCE_INFO, true, true, true, true));\r", "-      assertEquals(\"should return the byte SymbolData\", SymbolData.BYTE_TYPE, _llv.getSymbolDataHelper(\"byte\", JExprParser.NO_SOURCE_INFO, false, false, false, true));\r", "-\r", "-      // Array types\r", "-      ArrayData ad = new ArrayData(SymbolData.INT_TYPE, _llv, JExprParser.NO_SOURCE_INFO);\r", "-      SymbolData result = _llv.getSymbolDataHelper(\"int[]\", JExprParser.NO_SOURCE_INFO, true, true, true, true);\r", "-      ad.getVars().get(0).setEnclosingData(result);  //This is a hack, because .equals() on variable datas compares their enclosing datas with ==.\r", "-      ad.getMethods().get(0).setEnclosingData(result.getMethods().get(0).getEnclosingData()); //similar hack\r", "-      assertEquals(\"should return the array type\", ad, result);\r", "-      \r", "-      // Qualified types\r", "-      SymbolData sd = new SymbolData(\"java.lang.System\");\r", "-      symbolTable.put(\"java.lang.System\", sd);\r", "-      assertEquals(\"should return the same sd\", sd, _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, false, true, true, true));\r", "-      assertTrue(\"should be a continuation\", sd.isContinuation());\r", "-      assertEquals(\"should return the now resolved sd\", sd, _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, true, false, true, true));\r", "-      assertFalse(\"should not be a continuation\", sd.isContinuation());\r", "-      \r", "-      // In this file\r", "-      sd = new SymbolData(\"fully.qualified.Qwerty\");\r", "-      symbolTable.put(\"fully.qualified.Qwerty\", sd);\r", "-      _llv._classNamesInThisFile.addLast(\"fully.qualified.Qwerty\");\r", "-      // Use a ElementaryVisitor so lookupFromClassesToBeParsed will actually visit the ClassDef.\r", "-      ElementaryVisitor bv = new ElementaryVisitor(new File(\"\"), errors, symbolTable, continuations, new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>(), _newSDs, targetVersion);\r", "-      bv._package = \"fully.qualified\";\r", "-      bv._file = new File(\"testFiles/fully/qualified/Fake.dj0\");\r", "-      _llv._classesToBeParsed.put(\"fully.qualified.Qwerty\", \r", "-                                  new Pair<TypeDefBase, LanguageLevelVisitor>(\r", "-                                              new ClassDef(JExprParser.NO_SOURCE_INFO, \r", "-                                                        _packageMav, \r", "-                                                        new Word(JExprParser.NO_SOURCE_INFO, \"Qwerty\"),\r", "-                                                        new TypeParameter[0],\r", "-                                                        new ClassOrInterfaceType(JExprParser.NO_SOURCE_INFO, \"Object\", new Type[0]),\r", "-                                                        new ReferenceType[0], \r", "-                                                        new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0])),\r", "-                                           bv));\r", "-      assertEquals(\"should return sd the continuation\", sd, bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, false, true, true, true));\r", "-      assertTrue(\"should be a continuation\", sd.isContinuation());\r", "-      assertEquals(\"should return sd, now resolved\", sd, bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, true, true, true, true));\r", "-      assertFalse(\"should not be a continuation\", sd.isContinuation());\r", "-      \r", "-      // Imported files\r", "-      _llv._importedFiles.addLast(\"a.b.c\");\r", "-      sd = new SymbolData(\"a.b.c\");\r", "-      symbolTable.put(\"a.b.c.\", sd);\r", "-      assertEquals(\"should find the continuation in the symbol table\", sd, _llv.getSymbolDataHelper(\"c\", JExprParser.NO_SOURCE_INFO, false, true, true, true));\r", "-      assertTrue(\"should be a continuation\", sd.isContinuation());\r", "-      \r", "-      _llv._package=\"fully.qualified\";\r", "-      _llv._file = new File(\"testFiles/fully/qualified/Fake.dj0\");\r", "-      _llv._importedFiles.addLast(\"fully.qualified.Woah\");\r", "-      SymbolData sd2 = new SymbolData(\"fully.qualified.Woah\");\r", "-      symbolTable.put(\"fully.qualified.Woah\", sd2);\r", "-      assertEquals(\"should find the resolved symbol data in the symbol table\", sd2, _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true));\r", "-      assertFalse(\"should not be a continuation\", sd2.isContinuation());\r", "-      \r", "-      // File System\r", "-      _llv._importedFiles.clear();\r", "-      _llv.visitedFiles.clear();\r", "-      symbolTable.remove(\"fully.qualified.Woah\");\r", "-      sd2 = new SymbolData(\"fully.qualified.Woah\");\r", "-      _llv.symbolTable.put(\"fully.qualified.Woah\", sd2);\r", "-      \r", "-      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, true, true, true);\r", "-      \r", "-      assertEquals(\"Should return sd2, unresolved.\", sd2, result);\r", "-      assertTrue(\"sd2 should still be unresolved\", sd2.isContinuation());\r", "-      \r", "-      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, true, true, true);\r", "-      assertEquals(\"Should return sd2, now unresolved.\", sd2, result);\r", "-      assertTrue(\"sd2 should not be resolved\", sd2.isContinuation());\r", "-      \r", "-      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, true, true, true);\r", "-      assertEquals(\"Should return sd2, now resolved.\", sd2, result);\r", "-      assertFalse(\"sd2 should now be resolved\", sd2.isContinuation());\r", "-      \r", "-      // Imported Packages\r", "-      symbolTable.remove(\"fully.qualified.Woah\");\r", "-      _llv.visitedFiles.clear();\r", "-      _llv._file = new File(\"testFiles/Fake.dj0\");\r", "-      _llv._package = \"\";\r", "-      _llv._importedPackages.addLast(\"fully.qualified\");\r", "-      sd2 = new SymbolData(\"fully.qualified.Woah\");\r", "-      symbolTable.put(\"fully.qualified.Woah\", sd2);\r", "-      assertEquals(\"should find the unresolved symbol data in the symbol table\", sd2, _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, false, true, true));\r", "-      assertTrue(\"should not be a continuation\", sd2.isContinuation());\r", "-      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true);\r", "-      assertEquals(\"should find the resolved symbol data in the symbol table\", sd2, result);\r", "-      assertFalse(\"should not be a continuation\", sd2.isContinuation());\r", "-      \r", "-      //test java.lang classes that need to be looked up\r", "-      //want to resolve\r", "-      SymbolData stringSD = new SymbolData(\"java.lang.String\");\r", "-      SymbolData newsd1 = _llv.getSymbolDataHelper(\"String\", JExprParser.NO_SOURCE_INFO, true, true, true, true);\r", "-      assertEquals(\"should have correct name.\", stringSD.getName(), newsd1.getName());\r", "-      assertFalse(\"should not be a continuation\", newsd1.isContinuation());\r", "-\r", "-      //Test that if class name is ambiguous (i.e. it is unqualified, and matches unqualified names in 2 or more packages.\r", "-      symbolTable.put(\"random.package.String\", new SymbolData(\"random.package.String\"));\r", "-      symbolTable.put(\"java.lang.Object\", new SymbolData(\"java.lang.Object\"));\r", "-      _llv._importedPackages.addLast(\"random.package\");\r", "-      result = _llv.getSymbolDataHelper(\"String\", JExprParser.NO_SOURCE_INFO, true, true, true, true);\r", "-      assertEquals(\"Result should be null\", null, result);\r", "-      assertEquals(\"There should be 1 error\", 1, errors.size());\r", "-      assertEquals(\"The error message should be correct\", \"The class name String is ambiguous.  It could be java.lang.String or random.package.String\", errors.get(0).getFirst());\r", "-      \r", "-      symbolTable.remove(\"random.package.String\");\r", "-      \r", "-    }\r", "+    ", "+    public void testGetSymbolDataHelper() {", "+      // Primitive types", "+      assertEquals(\"should return the int SymbolData\", SymbolData.INT_TYPE, _llv.getSymbolDataHelper(\"int\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "+      assertEquals(\"should return the byte SymbolData\", SymbolData.BYTE_TYPE, _llv.getSymbolDataHelper(\"byte\", JExprParser.NO_SOURCE_INFO, false, false, false, true));", "+", "+      // Array types", "+      ArrayData ad = new ArrayData(SymbolData.INT_TYPE, _llv, JExprParser.NO_SOURCE_INFO);", "+      SymbolData result = _llv.getSymbolDataHelper(\"int[]\", JExprParser.NO_SOURCE_INFO, true, true, true, true);", "+      ad.getVars().get(0).setEnclosingData(result);  //This is a hack, because .equals() on variable datas compares their enclosing datas with ==.", "+      ad.getMethods().get(0).setEnclosingData(result.getMethods().get(0).getEnclosingData()); //similar hack", "+      assertEquals(\"should return the array type\", ad, result);", "+      ", "+      // Qualified types", "+      SymbolData sd = new SymbolData(\"java.lang.System\");", "+      symbolTable.put(\"java.lang.System\", sd);", "+      assertEquals(\"should return the same sd\", sd, _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "+      assertTrue(\"should be a continuation\", sd.isContinuation());", "+      assertEquals(\"should return the now resolved sd\", sd, _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "+      assertFalse(\"should not be a continuation\", sd.isContinuation());", "+      ", "+      // In this file", "+      sd = new SymbolData(\"fully.qualified.Qwerty\");", "+      symbolTable.put(\"fully.qualified.Qwerty\", sd);", "+      _llv._classNamesInThisFile.addLast(\"fully.qualified.Qwerty\");", "+      // Use a ElementaryVisitor so lookupFromClassesToBeParsed will actually visit the ClassDef.", "+      ElementaryVisitor bv = new ElementaryVisitor(new File(\"\"), errors, symbolTable, continuations, new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>(), _newSDs);", "+      bv._package = \"fully.qualified\";", "+      bv._file = new File(\"testFiles/fully/qualified/Fake.dj0\");", "+      _llv._classesToBeParsed.put(\"fully.qualified.Qwerty\", ", "+                                  new Pair<TypeDefBase, LanguageLevelVisitor>(", "+                                              new ClassDef(JExprParser.NO_SOURCE_INFO, ", "+                                                        _packageMav, ", "+                                                        new Word(JExprParser.NO_SOURCE_INFO, \"Qwerty\"),", "+                                                        new TypeParameter[0],", "+                                                        new ClassOrInterfaceType(JExprParser.NO_SOURCE_INFO, \"Object\", new Type[0]),", "+                                                        new ReferenceType[0], ", "+                                                        new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0])),", "+                                           bv));", "+      assertEquals(\"should return sd the continuation\", sd, bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "+      assertTrue(\"should be a continuation\", sd.isContinuation());", "+      assertEquals(\"should return sd, now resolved\", sd, bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "+      assertFalse(\"should not be a continuation\", sd.isContinuation());", "+      ", "+      // Imported files", "+      _llv._importedFiles.addLast(\"a.b.c\");", "+      sd = new SymbolData(\"a.b.c\");", "+      symbolTable.put(\"a.b.c.\", sd);", "+      assertEquals(\"should find the continuation in the symbol table\", sd, _llv.getSymbolDataHelper(\"c\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "+      assertTrue(\"should be a continuation\", sd.isContinuation());", "+      ", "+      _llv._package=\"fully.qualified\";", "+      _llv._file = new File(\"testFiles/fully/qualified/Fake.dj0\");", "+      _llv._importedFiles.addLast(\"fully.qualified.Woah\");", "+      SymbolData sd2 = new SymbolData(\"fully.qualified.Woah\");", "+      symbolTable.put(\"fully.qualified.Woah\", sd2);", "+      assertEquals(\"should find the resolved symbol data in the symbol table\", sd2, _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "+      assertFalse(\"should not be a continuation\", sd2.isContinuation());", "+      ", "+      // File System", "+      _llv._importedFiles.clear();", "+      _llv.visitedFiles.clear();", "+      symbolTable.remove(\"fully.qualified.Woah\");", "+      sd2 = new SymbolData(\"fully.qualified.Woah\");", "+      _llv.symbolTable.put(\"fully.qualified.Woah\", sd2);", "+      ", "+      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, true, true, true);", "+      ", "+      assertEquals(\"Should return sd2, unresolved.\", sd2, result);", "+      assertTrue(\"sd2 should still be unresolved\", sd2.isContinuation());", "+      ", "+      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, true, true, true);", "+      assertEquals(\"Should return sd2, now unresolved.\", sd2, result);", "+      assertTrue(\"sd2 should not be resolved\", sd2.isContinuation());", "+      ", "+      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, true, true, true);", "+      assertEquals(\"Should return sd2, now resolved.\", sd2, result);", "+      assertFalse(\"sd2 should now be resolved\", sd2.isContinuation());", "+      ", "+      // Imported Packages", "+      symbolTable.remove(\"fully.qualified.Woah\");", "+      _llv.visitedFiles.clear();", "+      _llv._file = new File(\"testFiles/Fake.dj0\");", "+      _llv._package = \"\";", "+      _llv._importedPackages.addLast(\"fully.qualified\");", "+      sd2 = new SymbolData(\"fully.qualified.Woah\");", "+      symbolTable.put(\"fully.qualified.Woah\", sd2);", "+      assertEquals(\"should find the unresolved symbol data in the symbol table\", sd2, _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, false, true, true));", "+      assertTrue(\"should not be a continuation\", sd2.isContinuation());", "+      result = _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true);", "+      assertEquals(\"should find the resolved symbol data in the symbol table\", sd2, result);", "+      assertFalse(\"should not be a continuation\", sd2.isContinuation());", "+      ", "+      //test java.lang classes that need to be looked up", "+      //want to resolve", "+      SymbolData stringSD = new SymbolData(\"java.lang.String\");", "+      SymbolData newsd1 = _llv.getSymbolDataHelper(\"String\", JExprParser.NO_SOURCE_INFO, true, true, true, true);", "+      assertEquals(\"should have correct name.\", stringSD.getName(), newsd1.getName());", "+      assertFalse(\"should not be a continuation\", newsd1.isContinuation());", "+", "+      //Test that if class name is ambiguous (i.e. it is unqualified, and matches unqualified names in 2 or more packages.", "+      symbolTable.put(\"random.package.String\", new SymbolData(\"random.package.String\"));", "+      symbolTable.put(\"java.lang.Object\", new SymbolData(\"java.lang.Object\"));", "+      _llv._importedPackages.addLast(\"random.package\");", "+      result = _llv.getSymbolDataHelper(\"String\", JExprParser.NO_SOURCE_INFO, true, true, true, true);", "+      assertEquals(\"Result should be null\", null, result);", "+      assertEquals(\"There should be 1 error\", 1, errors.size());", "+      assertEquals(\"The error message should be correct\", \"The class name String is ambiguous.  It could be java.lang.String or random.package.String\", errors.get(0).getFirst());", "+      ", "+      symbolTable.remove(\"random.package.String\");", "+      ", "+    }"]}], "num": 1957}