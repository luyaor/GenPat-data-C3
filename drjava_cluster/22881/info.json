{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1ab537fdba5999952394cfd867d43ddc", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ace8ec10196f6bb9cf27cc6b37b76cc3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/JPDADebugger.java", "commitBeforeChange": "7b90d9227a34693633b434e1d2773067e65a70e5", "commitAfterChange": "1b1a2ff927caf38a8f2ba21780232fcbeb4319bb", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 57, "signatureBeforeChange": "   private void _updateWatches() throws DebugException", "signatureAfterChange": "   private void _updateWatches() throws DebugException", "diff": ["+      ObjectReference obj = currFrame.thisObject();", "+      ", "+        ", "-          ObjectReference obj = currFrame.thisObject();", "+          // Not compiled with debug flag.... ignore", "+        ObjectReference outer = obj;", "-          String className = outerRt.name();", "-          while (field == null) {", "+          Field outerThis = outerRt.fieldByName(\"this$0\");", "+          ", "+          while ((field == null) && (outerThis != null)) {", "+            outer = (ObjectReference) outer.getValue(outerThis);", "+            //outer = (ObjectReference)outer.getValue(outerThis);//currFrame.getValue(var);", "+            outerRt = outer.referenceType();", "+            field = outerRt.fieldByName(currName);", "+            ", "+            if (field == null) {", "+              // Enter the loop again with the next outer enclosing class", "+              outerThis = outerRt.fieldByName(\"this$0\");                ", "+            }    ", "+          }", "+          ", "+          if (field != null) {", "+            currWatch.setValue(_getValue(outer.getValue(field)));", "+            try {", "+              currWatch.setType(field.type());", "+            }", "+            catch (ClassNotLoadedException cnle) {", "+              currWatch.setType(null);", "+            }", "+          }", "+          /*", "+              LocalVariable var;", "+              ObjectReference outer;", "+              do {", "+                // get the object reference for outer classes", "+                var = currFrame.visibleVariableByName(\"this$0\");", "+                outer = (ObjectReference)currFrame.getValue(var);", "+              }", "+              while (!outer.referenceType().equals(outerRt));", "+                 ", "+              */", "+          ", "+              /*", "-            }", "-          }", "+              ", "+            }*/"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0adffac9f11bf8e582f846203f168b7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "c2534d285c076411f44905ccf9cea4fb321903a1", "commitAfterChange": "6c7308b28231f013064e2caac6c40346905e6204", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>   convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "diff": ["-  convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap) {", "+    convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap) {", "-", "-    //And a linked list thing to share visited files.", "+    ", "+    //And a linked list to share visited files.", "-", "+    ", "+      File f = files[ind];", "-        BufferedReader tempBr = new BufferedReader(new FileReader(files[ind]));", "+        BufferedReader tempBr = new BufferedReader(new FileReader(f));", "-        ", "+        ", "-        boolean foundFile = false;", "-        for (int i = 0; i < filesNotToCheck.size(); i++) {", "-          if (filesNotToCheck.get(i).getAbsolutePath().equals(files[ind].getAbsolutePath())) {", "-            foundFile = true;", "+//        boolean foundFile = false;", "+        ", "+        for (File fntc: files) {", "+          if (fntc.getAbsolutePath().equals(f.getAbsolutePath())) {", "+//            foundFile = true;", "-", "-        if (_isLanguageLevelFile(files[ind]) && ! foundFile) {", "+        ", "+        if (_isLanguageLevelFile(f) /* && ! foundFile*/) {", "-          File f = files[ind];", "+//          File f = files[ind];", "-", "+          ", "-", "+      ", "-    ", "+//    Utilities.show(\"Visited \" + visited + \" in first pass\");", "-        //Resolve continuations", "+    //Resolve continuations", "-    while (!continuations.isEmpty()) {", "+    while (! continuations.isEmpty()) {", "-    if (languageLevelVisitorErrors.size() > 0) {", "-      _visitorErrors.addAll(languageLevelVisitorErrors);", "+    if (languageLevelVisitorErrors.size() > 0)  _visitorErrors.addAll(languageLevelVisitorErrors);", "+    ", "+    else { //Let's TYPE CHECK!!!", "+      ", "+      ", "+      for (int ind = 0; ind < visited.size(); ind++) {", "+        ", "+        LanguageLevelVisitor llv = visited.get(ind).getFirst();", "+        SourceFile sf = visited.get(ind).getSecond();", "+        ", "+        //TODO: This is a terrible hack to get around the following problem.  Basically, when we autobox in isAssignableTo in SymbolData, ", "+        //we look through the object hierarchy for the primitive.  If its corresponding boxed object isn't in the symboltable, we're in trouble.", "+        //So, for those special cases, go ahead and make sure the object types are in the symbol table before we start type checking.", "+        //I'd like to make this better, but at least it works for now.", "+        ", "+        ", "+        //Before you type check, make sure that all boxed types of primitives are in the symbol table", "+        if (llv.symbolTable.get(\"java.lang.Integer\") == null) {llv.getSymbolData(\"java.lang.Integer\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Double\")==null) {llv.getSymbolData(\"java.lang.Double\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Character\")==null) {llv.getSymbolData(\"java.lang.Character\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Boolean\")==null) {llv.getSymbolData(\"java.lang.Boolean\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Long\")==null) {llv.getSymbolData(\"java.lang.Long\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Byte\")==null) {llv.getSymbolData(\"java.lang.Byte\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Short\")==null) {llv.getSymbolData(\"java.lang.Short\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Float\")==null) {llv.getSymbolData(\"java.lang.Float\", JExprParser.NO_SOURCE_INFO);}", "+        ", "+        ", "+        // Type check.", "+        TypeChecker btc = new TypeChecker(llv._file, llv._package, llv.errors, llv.symbolTable, llv._importedFiles, llv._importedPackages);", "+        sf.visit(btc);", "+        if (btc.errors.size() > 0) _visitorErrors.addAll(btc.errors);", "+      }", "+      ", "+      // Set up code augmentation.  We will NOT try to augment files unless they appear in the visited List.  Unlisted LL files cannot be found", "+      // reliably during type checking because there is no naming convention that tells the type checker what files to look for.", "+      ", "+      Iterator<Pair<LanguageLevelVisitor, SourceFile>> iter = visited.iterator();", "+      LinkedList<File> newFiles = new LinkedList<File>();", "+      for (int ind = 0; iter.hasNext(); ind++) { // Note unusual loop termination condition; iter, ind in lock step", "+        Pair<LanguageLevelVisitor, SourceFile> currPair = iter.next();", "+        File fileToAdd = currPair.getFirst()._file;", "+        ", "+        if (_isLanguageLevelFile(fileToAdd)) { // fileToAdd is a visited LL file", "+//          Utilities.show(fileToAdd + \" is a LL file for augmentation\");", "+          newFiles.addLast(fileToAdd);", "+          mediator.put(ind, new Pair<SourceFile, LanguageLevelVisitor>(currPair.getSecond(), currPair.getFirst())); ", "+        }", "+        ", "+        // Also make sure not to re-check these files whether we visited source or class file. ", "+        // We only want to perform code augmentation since these files have already been visited.", "+        if (! filesNotToCheck.contains(fileToAdd)) filesNotToCheck.addLast(fileToAdd);", "+      }", "+      files = newFiles.toArray(new File[newFiles.size()]);", "+//      Utilities.show(\"Created files array: \" + Arrays.toString(files));", "-    ", "-    //Let's TYPE CHECK!!!", "-          ", "-          else {", "-            ", "-            for (int ind = 0; ind<visited.size(); ind++) {", "-  ", "-              LanguageLevelVisitor llv = visited.get(ind).getFirst();", "-              SourceFile sf = visited.get(ind).getSecond();", "-              ", "-              //TODO: This is a terrible hack to get around the following problem.  Basically, when we autobox in isAssignableTo in SymbolData, ", "-              //we look through the object hierarchy for the primitive.  If its corresponding boxed object isn't in the symboltable, we're in trouble.", "-              //So, for those special cases, go ahead and make sure the object types are in the symbol table before we start type checking.", "-              //I'd like to make this better, but at least it works for now.", "-              ", "-              ", "-              //Before you type check, make sure that all boxed types of primitives are in the symbol table", "-              if (llv.symbolTable.get(\"java.lang.Integer\") == null) {llv.getSymbolData(\"java.lang.Integer\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Double\")==null) {llv.getSymbolData(\"java.lang.Double\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Character\")==null) {llv.getSymbolData(\"java.lang.Character\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Boolean\")==null) {llv.getSymbolData(\"java.lang.Boolean\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Long\")==null) {llv.getSymbolData(\"java.lang.Long\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Byte\")==null) {llv.getSymbolData(\"java.lang.Byte\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Short\")==null) {llv.getSymbolData(\"java.lang.Short\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Float\")==null) {llv.getSymbolData(\"java.lang.Float\", JExprParser.NO_SOURCE_INFO);}", "-              ", "-              ", "-              // Type check.", "-              TypeChecker btc = new TypeChecker(llv._file, llv._package, llv.errors, llv.symbolTable, llv._importedFiles, llv._importedPackages);", "-              sf.visit(btc);", "-              if (btc.errors.size() > 0) {", "-                _visitorErrors.addAll(btc.errors);", "-              }", "-              ", "-              // Add those files to be compiled to the array of files.", "-              if (llv.visitedFiles.size() > 0) {            ", "-                LinkedList<File> newFiles = new LinkedList<File>();", "-                for (int i = 0; i < files.length; i++) {", "-                  newFiles.addLast(files[i]);", "-                }", "-                Iterator<Pair<LanguageLevelVisitor, SourceFile>> iter = llv.visitedFiles.iterator();", "-                while (iter.hasNext()) {", "-                  Pair<LanguageLevelVisitor,SourceFile> currPair = iter.next();", "-                  File fileToAdd = currPair.getFirst()._file;", "-                  // if currSf is not null, then this visitedFile came from visiting the source file, not the class file. ", "-                  // We want to compile this source file; add it to the list of files after creating the mediator entry", "-                  // if necessary.", "-                  SourceFile currSf = currPair.getSecond();", "-                  if (currSf != null) {", "-                    if (newFiles.contains(fileToAdd)) {", "-                      // Messy, but we must make a mediator entry so that code augmentation has all the data it needs", "-                      // since we will skip visiting this file here.  ", "-                      // Can just pass llv since it will contain the correct symbolTable.", "-                      mediator.put(new Integer(newFiles.indexOf(fileToAdd)), new Pair<SourceFile, LanguageLevelVisitor>(currSf, currPair.getFirst())); ", "-                    }", "-                    // Now, if we aren't already compiling this file, and we visited the source, add it to the list of", "-                    // files to be compiled.", "-                    if (!newFiles.contains(fileToAdd) && currSf != null) {", "-                      mediator.put(new Integer(newFiles.size()), new Pair<SourceFile, LanguageLevelVisitor>(currSf, currPair.getFirst()));", "-                      newFiles.addLast(fileToAdd);", "-                    }", "-                    ", "-                  }", "-                  // Also make sure not to re-check these files whether we visited source or class file. ", "-                  // We only want to perform code augmentation since these files have already been visited.", "-                  if (!filesNotToCheck.contains(fileToAdd)) {", "-                    filesNotToCheck.addLast(fileToAdd);", "-                  }", "-                }", "-                files = newFiles.toArray(new File[newFiles.size()]);", "-              }", "-              ", "-              mediator.put(new Integer(ind), new Pair<SourceFile, LanguageLevelVisitor>(sf, llv));", "-            }", "-          }", "+//        mediator.put(new Integer(ind), new Pair<SourceFile, LanguageLevelVisitor>(sf, llv));", "+//      }", "+//  }", "-    ", "+//    Utilities.show(\"Processed LL files: \" + Arrays.toString(files));", "+//    Utilities.show(\"mediator is: \" + mediator);", "+      File f = files[ind];", "-        BufferedReader tempBr = new BufferedReader(new FileReader(files[ind]));", "+//        Utilities.show(\"File is: \" + f + \" mediator is: \" + mediator.get(ind));", "+        BufferedReader tempBr = new BufferedReader(new FileReader(f));", "-        if (firstLine == null) {", "-          continue;", "-        }", "-", "-        // If the file has the correct beginner tag at the beginning, then parse it.", "-        // It should not end in .beginner since that's just a temporary copy which gets", "-        // deleted after the compile.", "-        if (_isLanguageLevelFile(files[ind])) {", "+        if (firstLine == null) continue;", "+        ", "+        // If the file has an appropriate LL extension, then parse it.", "+        if (_isLanguageLevelFile(f)) {", "+          if (pair == null) {", "+            _log.log(\"Not augmenting \" + f + \" no mediator\");", "+//            Utilities.show(\"Not augmenting \" + f + \" no mediator\");", "+          }", "+          ", "-            File f = files[ind];", "+//            File f = files[ind];", "-//            _log.log(\"Augmenting the source file \" + sf);", "+            _log.log(\"Augmenting the source file \" + sf);", "+//            Utilities.show(\"Augmenting the source file \" + sf.getSourceInfo().getFile());", "-                                                                                       _visitorErrors);", "+                                                                                              _visitorErrors);"]}], "num": 22881}