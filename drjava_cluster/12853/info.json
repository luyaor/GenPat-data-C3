{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d745d8effa317420a0dbd290c2a21c12", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39192182fcdfc24380b99e366ab2b2df", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/Java5Class.java", "commitBeforeChange": "ede26ceaad5c407d940ac773a5e7f457dc1f5187", "commitAfterChange": "734866577ba652e258c158eef25bcbc68a43749a", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "          private static Type convertParameterizedType(ParameterizedType paramT,                                                 final PrecomputedRecursionStack<java.lang.reflect.Type, Type> stack)", "signatureAfterChange": "          private static Type convertParameterizedType(ParameterizedType paramT,                                                 final PrecomputedRecursionStack<java.lang.reflect.Type, Type> stack)", "diff": ["-    Iterable<Type> targsBuilder = IterUtil.empty();", "-    boolean raw = false; // true iff an enclosing type is raw, and so this type must also be raw", "+    // assumes getRawType and getOwnerType return class types", "+    ClassType rawT = (ClassType) convertType(paramT.getRawType(), stack);", "+    ClassType ownerT = (paramT.getOwnerType() == null) ? null : (ClassType) convertType(paramT.getOwnerType(), stack);", "+    ClassType enclosingT = rawT.ofClass().isStatic() ? SymbolUtil.dynamicOuterClassType(ownerT) : ownerT;", "-    if (paramT.getOwnerType() != null) {", "-      Type ownerT = convertType(paramT.getOwnerType(), stack);", "-      Iterable<? extends Type> outerArgs = ownerT.apply(new TypeAbstractVisitor<Iterable<? extends Type>>() {", "-        ", "-        public Iterable<? extends Type> defaultCase(Type ownerT) { ", "-          throw new IllegalArgumentException(\"Owner of ParameterizedType must be a class type\");", "-        }", "-        ", "-        @Override public Iterable<? extends Type> forSimpleClassType(SimpleClassType ownerT) { ", "+    Iterable<? extends Type> outerArgs = IterUtil.empty();", "+    boolean raw = false; // true iff an enclosing type is raw, and so this type must also be raw", "+    if (enclosingT != null) {", "+      Iterable<? extends Type> ts = enclosingT.apply(new TypeAbstractVisitor<Iterable<? extends Type>>() {", "+        @Override public Iterable<? extends Type> forSimpleClassType(SimpleClassType enclosingT) { ", "-        ", "-        @Override public Iterable<? extends Type> forRawClassType(RawClassType ownerT) { return null; }", "-        ", "-        @Override public Iterable<? extends Type> forParameterizedClassType(ParameterizedClassType ownerT) { ", "-          return ownerT.typeArguments();", "+        @Override public Iterable<? extends Type> forRawClassType(RawClassType enclosingT) { return null; }", "+        @Override public Iterable<? extends Type> forParameterizedClassType(ParameterizedClassType enclosingT) { ", "+          return enclosingT.typeArguments();", "-      if (outerArgs == null) { raw = true; }", "-      else { targsBuilder = IterUtil.compose(targsBuilder, outerArgs); }", "+      if (ts == null) { raw = true; }", "+      else { outerArgs = ts; }", "-    targsBuilder = IterUtil.compose(targsBuilder, convertTypes(paramT.getActualTypeArguments(), stack));", "-    ", "-    Type rawT = convertType(paramT.getRawType(), stack);", "-    final Iterable<Type> targs = targsBuilder; // targsBuilder must be redeclared as final", "+    Iterable<Type> directArgs = convertTypes(paramT.getActualTypeArguments(), stack);", "+    final Iterable<Type> targs = IterUtil.compose(outerArgs, directArgs);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6bd94c056c400cf475d12755160c6513", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 470, "methodNumberAfterChange": 479, "signatureBeforeChange": "   public ConstructorInvocation lookupConstructor(final Type t, final Iterable<? extends Type> typeArgs,                                                   final Iterable<? extends Expression> args)     throws InvalidTargetException, InvalidTypeArgumentException, UnmatchedLookupException", "signatureAfterChange": "   public ConstructorInvocation lookupConstructor(final Type t, final Iterable<? extends Type> typeArgs,                                                   final Iterable<? extends Expression> args,                                                  final Option<Type> expected)     throws InvalidTargetException, InvalidTypeArgumentException, UnmatchedLookupException", "diff": ["-                                                 final Iterable<? extends Expression> args)", "+                                                 final Iterable<? extends Expression> args,", "+                                                 final Option<Type> expected)", "-//    System.out.println(\"\\nLooking up constructor in type \" + userRepresentation(t) +", "-//                       \" with typeArgs (\" + userRepresentation(typeArgs) + \") and args (\" +", "-//                       userRepresentation(IterUtil.map(args, TYPE_OF_EXPRESSION)) + \")\");", "+    debug.logValues(\"Looking up constructor\",", "+                    new String[]{\"t\", \"typeArgs\", \"arg types\", \"expected\"},", "+                    wrap(t), wrap(typeArgs), wrap(IterUtil.map(args, NodeProperties.NODE_TYPE)),", "+                    expected);", "-      @Override public Iterable<ConstructorInvocation> forSimpleClassType(SimpleClassType t) {", "+      @Override public Iterable<ConstructorInvocation> forSimpleClassType(final SimpleClassType t) {", "-//        System.out.println(\"All constructors in type \" + userRepresentation(t) + \": \" +", "-//                           IterUtil.multilineToString(allConstructors));", "-            return makeChecker(k.declaredTypeParameters(), typeArgs, SymbolUtil.declaredParameterTypes(k), args);", "+            debug.logValues(new String[]{\"k\", \"declaredParameterTypes\"}, k, SymbolUtil.declaredParameterTypes(k));", "+            return makeChecker(k.declaredTypeParameters(), typeArgs, SymbolUtil.declaredParameterTypes(k),", "+                               args, t, expected);", "-      @Override public Iterable<ConstructorInvocation> forRawClassType(RawClassType t) {", "+      @Override public Iterable<ConstructorInvocation> forRawClassType(final RawClassType t) {", "-                               IterUtil.map(SymbolUtil.declaredParameterTypes(k), ERASE_LAMBDA), args);", "+                               IterUtil.map(SymbolUtil.declaredParameterTypes(k), ERASE_LAMBDA),", "+                               args, t, expected);", "-      @Override public Iterable<ConstructorInvocation> forParameterizedClassType(ParameterizedClassType t) {", "+      @Override public Iterable<ConstructorInvocation> forParameterizedClassType(final ParameterizedClassType t) {", "-                               substitute(SymbolUtil.declaredParameterTypes(k), classSigma), args);", "+                               substitute(SymbolUtil.declaredParameterTypes(k), classSigma),", "+                               args, t, expected);"]}], "num": 12853}