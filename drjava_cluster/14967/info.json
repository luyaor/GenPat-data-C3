{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9736dc40d1f9facaa457c4a68c1b6171", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ebf48a3d7f5367c38dcfa2d0892845d2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 28, "signatureBeforeChange": "   @Override public Type visit(ArrayInitializer node)", "signatureAfterChange": "     @Override public Type visit(ArrayInitializer node)", "diff": ["-   */", "-  @Override public Type visit(ArrayInitializer node) {", "-    Type elementType = node.getElementType().acceptVisitor(this);", "-    // TODO: Store the *Type* as an attribute on the initializer, instead of a *TypeName*", "-    checkList(node.getCells());", "-    List<Expression> newCells = new ArrayList<Expression>(node.getCells().size());", "-    for (Expression exp : node.getCells()) {", "-      Type expT = exp.acceptVisitor(this);", "-      try { newCells.add(ts.assign(elementType, exp)); }", "-      catch (UnsupportedConversionException e) {", "-        setErrorStrings(exp, ts.userRepresentation(expT), ts.userRepresentation(elementType));", "-        throw new ExecutionError(\"assignment.types\", exp);", "-      }", "-    }", "-    node.setCells(newCells);", "-    Type result = new SimpleArrayType(elementType);", "-    setErasedType(node, ts.erasedClass(result));", "-    return setType(node, result);", "-  }", "+     */", "+    @Override public Type visit(ArrayInitializer node) {", "+      // there's some redundancy between \"expected\" and \"node.getElementType()\"", "+      // but while \"expected\" is a suggestion that can lead to no errors", "+      // (and that can be turned on or off depending on preferences),", "+      // the stated element type is always required and checked", "+      // TODO: Store the *Type* as an attribute on the initializer, instead of a *TypeName*?", "+      Type elementType = checkTypeName(node.getElementType());", "+      if (expected.isSome() && ts.isArray(expected.unwrap())) {", "+        checkList(node.getCells(), ts.arrayElementType(expected.unwrap()));", "+      }", "+      else {", "+        checkList(node.getCells());", "+      }", "+      List<Expression> newCells = new ArrayList<Expression>(node.getCells().size());", "+      for (Expression exp : node.getCells()) {", "+        try { newCells.add(ts.assign(elementType, exp)); }", "+        catch (UnsupportedConversionException e) {", "+          Type expT = getType(exp);", "+          setErrorStrings(exp, ts.userRepresentation(expT), ts.userRepresentation(elementType));", "+          throw new ExecutionError(\"assignment.types\", exp);", "+        }", "+      }", "+      node.setCells(newCells);", "+      Type result = new SimpleArrayType(elementType);", "+      setErasedType(node, ts.erasedClass(result));", "+      return setType(node, result);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f647519f5e73a99cfaf216a932e1b317", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 27, "signatureBeforeChange": "   @Override public Type visit(ArrayAllocation node)", "signatureAfterChange": "     @Override public Type visit(ArrayAllocation node)", "diff": ["-    */", "-  @Override public Type visit(ArrayAllocation node) {", "-    Type elementType = node.getElementType().acceptVisitor(this);", "-    if (! ts.isReifiable(elementType)) {", "-      throw new ExecutionError(\"reifiable.type\", node);", "-    }", "-    ", "-    checkList(node.getSizes());", "-    List<Expression> newSizes = new ArrayList<Expression>(node.getSizes().size());", "-    for (Expression exp : node.getSizes()) {", "-      try {", "-        Expression newExp = ts.unaryPromote(ts.makePrimitive(exp));", "-        if (!(getType(newExp) instanceof IntType)) {", "-          throw new ExecutionError(\"array.dimension.type\", node);", "-        }", "-        newSizes.add(newExp);", "-      }", "-      catch (UnsupportedConversionException e) {", "-        throw new ExecutionError(\"array.dimension.type\", node);", "-      }", "-    }", "-    node.setSizes(newSizes);", "-    ", "-    if (node.getInitialization() != null) { node.getInitialization().acceptVisitor(this); }", "-    ", "-    Type result = elementType;", "-    for (int i = 0; i < node.getDimension(); i++) {", "-      result = new SimpleArrayType(result);", "-    }", "-    setErasedType(node, ts.erasedClass(result));", "-    return setType(node, result);", "-  }", "+      */", "+    @Override public Type visit(ArrayAllocation node) {", "+      Type elementType = checkTypeName(node.getElementType());", "+      if (! ts.isReifiable(elementType)) {", "+        throw new ExecutionError(\"reifiable.type\", node);", "+      }", "+      Type result = elementType;", "+      for (int i = 0; i < node.getDimension(); i++) {", "+        result = new SimpleArrayType(result);", "+      }", "+      ", "+      checkList(node.getSizes(), TypeSystem.INT);", "+      List<Expression> newSizes = new ArrayList<Expression>(node.getSizes().size());", "+      for (Expression exp : node.getSizes()) {", "+        try {", "+          Expression newExp = ts.unaryPromote(ts.makePrimitive(exp));", "+          if (!(getType(newExp) instanceof IntType)) {", "+            throw new ExecutionError(\"array.dimension.type\", node);", "+          }", "+          newSizes.add(newExp);", "+        }", "+        catch (UnsupportedConversionException e) {", "+          throw new ExecutionError(\"array.dimension.type\", node);", "+        }", "+      }", "+      node.setSizes(newSizes);", "+      ", "+      if (node.getInitialization() != null) { check(node.getInitialization(), result); }", "+      ", "+      setErasedType(node, ts.erasedClass(result));", "+      return setType(node, result);", "+    }"]}], "num": 14967}