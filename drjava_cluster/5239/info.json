{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8bab6cd30c10c80184a817723ed3fc7f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4ede3f4c53c3f3936f97c377d0614acb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/CompilerErrorModel.java", "commitBeforeChange": "962cae132b304832e8ad8ca23872798ac7d84d3c", "commitAfterChange": "8958ac741e416ecbae85abc43f8b198196076bac", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 7, "signatureBeforeChange": "   private void _createPositionsArray()", "signatureAfterChange": "   private void _calculatePositions()", "diff": ["-   */", "-  private void _createPositionsArray() {", "-    _positions = new Position[_errors.length];", "-    //DrJava.consoleErr().println(\"created pos arr: \" + _positions.length);", "-", "-    // don't bother with anything else if there are no errors", "-    if (_positions.length == 0)", "-      return;", "-", "-    try {", "-      String defsText = _document.getText(0, _document.getLength());", "-      //DrJava.consoleErr().println(\"got defs text, len=\" + defsText.length());", "-", "-      int curLine = 0;", "-      int offset = 0; // offset is number of chars from beginning of file", "-      int numProcessed = 0;", "-      ", "-      // offset is always pointing to the first character in a line", "-      // at the top of the loop", "-      while ((numProcessed < _errors.length) &&", "-             (offset <= defsText.length()))", "-      {", "-        //DrJava.consoleErr().println(\"num processed: \" + numProcessed);", "-", "-        // first figure out if we need to create any new positions on this line", "-        for (int i = numProcessed;", "-             (i < _errors.length) && (_errors[i].lineNumber() == curLine);", "-             i++)", "-        {", "-          _positions[i] = _document.createPosition(offset +", "-                                                   _errors[i].startColumn());", "-          numProcessed++;", "-        }", "-", "-        int nextNewline = defsText.indexOf('\\n', offset);", "-        if (nextNewline == -1) {", "-          break;", "-        }", "-        else {", "-          curLine++;", "-          offset = nextNewline + 1;", "-        }", "-      }", "-    }", "-    catch (BadLocationException ble) {", "-      throw new UnexpectedException(ble);", "-    }", "+   */", "+  private void _calculatePositions() {", "+    _positions = new Position[_errors.length];", "+    try {", "+      int numProcessed = 0;", "+", "+      //first skip errors with no file", "+      while(numProcessed < _errors.length && _errors[numProcessed].file() == null){", "+        _positions[numProcessed] = null;", "+        numProcessed++;", "+      }", "+", "+      while ((numProcessed < _errors.length)) {", "+        //skip errors with no position", "+        while(numProcessed < _errors.length && _errors[numProcessed].hasNoLocation()){", "+          _positions[numProcessed] = null;", "+          numProcessed++;", "+        }", "+        if (numProcessed >= _errors.length){", "+          break;", "+        }", "+", "+        //Now find the file and document we are working on", "+        File file = _errors[numProcessed].file();", "+        Document document = null;", "+        try {", "+          document = _model.getDocumentForFile(file).getDocument();", "+        } catch (IOException e) {", "+          //skip positions for these errors if the document couldn't be loaded", "+         do {", "+            _positions[numProcessed] = null;", "+            numProcessed++;", "+          } while(numProcessed < _errors.length && _errors[numProcessed].file().equals(file));", "+        } catch (OperationCanceledException e) {", "+          //skip positions for these errors if the document couldn't be loaded", "+         do {", "+            _positions[numProcessed] = null;", "+            numProcessed++;", "+          } while(numProcessed < _errors.length && _errors[numProcessed].file().equals(file));", "+        }", "+", "+        if (numProcessed >= _errors.length){", "+          break;", "+        }", "+", "+        //If the document couldn't be loaded, start the loop over at the top", "+        if (document == null){", "+          continue;", "+        }", "+", "+        int fileStartIndex = numProcessed;", "+        String defsText = document.getText(0, document.getLength());", "+        int curLine = 0;", "+        int offset = 0; // offset is number of chars from beginning of file", "+", "+        // offset is always pointing to the first character in a line", "+        // at the top of the loop", "+        while(numProcessed < _errors.length &&", "+          file.equals(_errors[numProcessed].file()) &&", "+          (offset <= defsText.length())) {", "+", "+          // first figure out if we need to create any new positions on this line", "+          for (int i = numProcessed;", "+               (i < _errors.length) && (_errors[i].lineNumber() == curLine);", "+               i++){", "+            _positions[i] = document.createPosition(offset +  _errors[i].startColumn());", "+            numProcessed++;", "+          }", "+", "+          int nextNewline = defsText.indexOf('\\n', offset);", "+          if (nextNewline == -1) {", "+            break;", "+          }", "+          else {", "+            curLine++;", "+            offset = nextNewline + 1;", "+          }", "+        }", "+", "+        //Remember the indexes in the _errors and _positions arrays that are for errors in this file", "+        int fileEndIndex = numProcessed;", "+        if (fileEndIndex != fileStartIndex){", "+          _filesToIndexes.put(file, new StartAndEndIndex(fileStartIndex, fileEndIndex));", "+        }", "+      }", "+    } catch (BadLocationException ble) {", "+       throw new UnexpectedException(ble);", "+    }", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7c7eef769eb3011d6870712c47b463ff", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/CompilerErrorModel.java", "commitBeforeChange": "24e790b85d3a1a29de15955ca1ba9200a6865f83", "commitAfterChange": "4ceb386773fd5eb837ddcd34820c563b6c3c20cb", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "   private void _calculatePositions()", "signatureAfterChange": "   private void _calculatePositions()", "diff": ["-    _positions = new Position[_errors.length];", "-      int numProcessed = 0;", "-", "-      //first skip errors with no file", "-      while(numProcessed < _errors.length && _errors[numProcessed].file() == null){", "-        _positions[numProcessed] = null;", "-        numProcessed++;", "-      }", "-", "-      while ((numProcessed < _errors.length)) {", "-        //skip errors with no position", "-        while(numProcessed < _errors.length && _errors[numProcessed].hasNoLocation()){", "-          _positions[numProcessed] = null;", "-          numProcessed++;", "-        }", "-        if (numProcessed >= _errors.length){", "+      int curError = 0;", "+      ", "+      // for(; numProcessed < _numErrors; numProcessed++) {", "+      while ((curError < _numErrors)) {", "+        ", "+        // find the next error with a line number (skipping others)", "+        curError = nextErrorWithLine(curError);", "+        if (curError >= _numErrors){", "-        File file = _errors[numProcessed].file();", "+        File file = _errors[curError].file();", "-        } catch (IOException e) {", "-          //skip positions for these errors if the document couldn't be loaded", "-         do {", "-            _positions[numProcessed] = null;", "-            numProcessed++;", "-          } while(numProcessed < _errors.length && _errors[numProcessed].file().equals(file));", "-        } catch (OperationCanceledException e) {", "-          //skip positions for these errors if the document couldn't be loaded", "-         do {", "-            _positions[numProcessed] = null;", "-            numProcessed++;", "-          } while(numProcessed < _errors.length && _errors[numProcessed].file().equals(file));", "+        } ", "+        catch (Exception e) {", "+          // This is intended to catch IOException or OperationCanceledException", "+          if ((e instanceof IOException) || (e instanceof OperationCanceledException)) {", "+            // skip positions for these errors if the document couldn't be loaded", "+            do {", "+              curError++;", "+            } while ((curError < _numErrors) && (_errors[curError].file().equals(file)));", "+            ", "+            //If the document couldn't be loaded, start the loop over at the top", "+            continue;", "+          }", "+          else {", "+            throw new UnexpectedException(e);", "+          }", "-        if (numProcessed >= _errors.length){", "+        if (curError >= _numErrors){", "-        //If the document couldn't be loaded, start the loop over at the top", "-        if (document == null){", "-          continue;", "-        }", "-", "-        int fileStartIndex = numProcessed;", "-        String defsText = document.getText(0, document.getLength());", "+        // curError is the first error in a file, and its document is open.", "+        final int fileStartIndex = curError;", "+        final int defsLength = document.getLength();", "+        final String defsText = document.getText(0, defsLength);", "-        // at the top of the loop", "-        while(numProcessed < _errors.length &&", "-          file.equals(_errors[numProcessed].file()) &&", "-          (offset <= defsText.length())) {", "+        // at the top of this loop", "+        while ((curError < _numErrors) && // we still have errors to find", "+               file.equals(_errors[curError].file()) &&  // the next error is in this file", "+               (offset <= defsLength)) { // we haven't gone past the end of the file", "-          // first figure out if we need to create any new positions on this line", "-          for (int i = numProcessed;", "-               (i < _errors.length) && (_errors[i].lineNumber() == curLine);", "-               i++){", "-            _positions[i] = document.createPosition(offset +  _errors[i].startColumn());", "-            numProcessed++;", "+          // create new positions for all errors on this line", "+          while ((curError < _numErrors)", "+                 && (_errors[curError].lineNumber() == curLine))", "+          {", "+            _positions[curError] =", "+              document.createPosition(offset +  _errors[curError].startColumn());", "+            curError++;", "-          int nextNewline = defsText.indexOf('\\n', offset);", "-          if (nextNewline == -1) {", "-            break;", "-          }", "-          else {", "-            curLine++;", "-            offset = nextNewline + 1;", "+          // At this point, offset is the starting index of the previous error's line.", "+          // Update offset to be appropriate for the current error.", "+          // ... but don't bother looking if it isn't in this file.", "+          // ... or if we're done with all errors already.", "+          if (curError < _numErrors) {", "+            int curErrorLine = _errors[curError].lineNumber();", "+            int nextNewline = 0;", "+            while ((curLine != curErrorLine) ", "+                     && (nextNewline != -1)", "+                     && (file.equals(_errors[curError].file()))) {", "+              nextNewline = defsText.indexOf('\\n', offset);", "+              if (nextNewline != -1) {", "+                curLine++;", "+                offset = nextNewline + 1;", "+              }", "+            }", "-        int fileEndIndex = numProcessed;", "+        int fileEndIndex = curError;"]}], "num": 5239}