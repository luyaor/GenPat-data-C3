{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ef3c1dcef5871b076fbe54540fffe5c3", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85e703c20d74197232b3a9337b50ec43", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/sourcechecker/SourceChecker.java", "commitBeforeChange": "488e3f877c7f7a8647e0d3f7fb5faea712ac20ce", "commitAfterChange": "35470e88ca153d8164d45d018c673900eac06ea2", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 59, "signatureBeforeChange": "          private void compare(Node left, Node right)", "signatureAfterChange": "          private void compare(String context, Node left, Node right)", "diff": ["-    private void compare(Node left, Node right) {", "+    ", "+    private void compare(String context, Node left, Node right) {", "+        if (left instanceof Statement || left instanceof VariableDeclaration || left instanceof Expression) {", "+          if (hasNestedError(left) || hasNestedError(right)) {", "+            _log.statementWithError(context, left, right);", "+            return;", "+          }", "+        }", "+        if (NodeProperties.hasMethod(left)) {", "+          DJMethod m = NodeProperties.getMethod(left);", "+          if (left instanceof MethodCall && !IterUtil.isEmpty(m.typeParameters())) {", "+            _log.polymorphicInvocation(context, left, right, ((MethodCall) left).getTypeArgs().isNone());", "+          }", "+        }", "+        if (NodeProperties.hasConstructor(left)) {", "+          DJConstructor k = NodeProperties.getConstructor(left);", "+          if (!IterUtil.isEmpty(k.typeParameters())) {", "+            Boolean inferred = null;", "+            if (left instanceof ConstructorCall) { inferred = true; } // doesn't support targs for now", "+            else if (left instanceof SimpleAllocation) { inferred = ((SimpleAllocation) left).getTypeArgs().isNone(); }", "+            else if (left instanceof InnerAllocation) { inferred = ((InnerAllocation) left).getTypeArgs().isNone(); }", "+            if (inferred != null) { _log.polymorphicInvocation(context, left, right, inferred); }", "+          }", "+        }", "+        Field props;", "+        try { props = Node.class.getDeclaredField(\"properties\"); }", "+        catch (NoSuchFieldException e) { throw new RuntimeException(e); }", "+        compareProperties(left.getClass(), (Map<?,?>) fieldValue(props, left), left,", "+                          (Map<?,?>) fieldValue(props, right), right);", "-        mismatch(\"Different node classes\", left.getClass().getName(), left, right.getClass().getName(), right);", "+        _log.mismatch(\"Different classes\", context, left.getClass().getName(), left,", "+                      right.getClass().getName(), right);", "-      Field props;", "-      try { props = Node.class.getDeclaredField(\"properties\"); }", "-      catch (NoSuchFieldException e) { throw new RuntimeException(e); }", "-      compareProperties((Map<?,?>) fieldValue(props, left), left, (Map<?,?>) fieldValue(props, right), right);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e9d71f42911ae19c90b41a2ec5cd0c00", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 18, "signatureBeforeChange": "   @Override public Type visit(SimpleFieldAccess node)", "signatureAfterChange": "     @Override public Type visit(SimpleFieldAccess node)", "diff": ["+     */", "+    @Override public Type visit(SimpleFieldAccess node) {", "+      try {", "+        ClassType t = context.typeContainingField(node.getFieldName(), ts);", "+        if (t == null) {", "+          setErrorStrings(node, node.getFieldName());", "+          throw new ExecutionError(\"undefined.name\", node);", "+        }", "+        FieldReference ref;", "+        if (context.getThis() == null) {", "+          ref = ts.lookupStaticField(t, node.getFieldName());", "+        }", "+        else {", "+          Expression obj = TypeUtil.makeEmptyExpression(node);", "+          setType(obj, t);", "+          ref = ts.lookupField(obj, node.getFieldName());", "+        }", "+        ", "+        // TODO: Check accessibility of field", "+        setField(node, ref.field());", "+        setVariableType(node, ref.type());", "+        if (!ref.field().isStatic()) {", "+          setDJClass(node, t.ofClass());", "+        }", "+        Type result = ts.capture(ref.type());", "+        addRuntimeCheck(node, result, ref.field().type());", "+        return setType(node, result);", "+    }", "-   */", "-  @Override public Type visit(SimpleFieldAccess node) {", "-    try {", "-      ClassType t = context.typeContainingField(node.getFieldName(), ts);", "-        setErrorStrings(node, node.getFieldName());", "-        throw new ExecutionError(\"undefined.name\", node);", "-      TypeSystem.FieldReference ref;", "-      if (context.getThis() == null) {", "-        ref = ts.lookupStaticField(t, node.getFieldName());", "-      }", "-      else {", "-        Expression obj = TypeUtil.makeEmptyExpression(node);", "-        setType(obj, t);", "-        ref = ts.lookupField(obj, node.getFieldName());", "-      }", "-      ", "-      // TODO: Check accessibility of field", "-      setField(node, ref.field());", "-      setVariableType(node, ref.type());", "-      if (!ref.field().isStatic()) {", "-        setDJClass(node, t.ofClass());", "-      }", "-      Type result = ts.capture(ref.type());", "-      addRuntimeCheck(node, result, ref.field().type());", "-      return setType(node, result);", "-    }", "-    catch (AmbiguousNameException e) { throw new ExecutionError(\"ambiguous.name\", node); }", "-    catch (InvalidTargetException e) { throw new RuntimeException(\"context produced bad type\"); }", "-    catch (UnmatchedLookupException e) {", "-      if (e.matches() == 0) { throw new ExecutionError(\"undefined.name.noinfo\", node); }", "-      else { throw new ExecutionError(\"ambiguous.name\", node); }", "-    }", "-  }"]}], "num": 24568}