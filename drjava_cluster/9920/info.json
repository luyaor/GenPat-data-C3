{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c69b4cce341491090e408f46e3994e03", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5bf48539476d1449c76cbfd552977ce1", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "f835199d645f480bb352cc51cff6dc5ae32e7dc4", "commitAfterChange": "f25bc20d2dd4058b4cf2bf5f693569e62fb40d6b", "methodNumberBeforeChange": 204, "methodNumberAfterChange": 203, "signatureBeforeChange": "   private ConstraintSet inferFromEqual(final Type arg, final Type param,                                        final Set<? extends VariableType> vars,                                         final RecursionStack3<Type, Type, InferenceMode> stack)", "signatureAfterChange": "              private Boolean checkBoundedSymbol(Type t, final BoundedSymbol s)", "diff": ["-   */", "-  private ConstraintSet inferFromEqual(final Type arg, final Type param,", "-                                       final Set<? extends VariableType> vars, ", "-                                       final RecursionStack3<Type, Type, InferenceMode> stack) {", "-    //debug.logValues(new String[]{ \"arg\", \"param\" }, wrap(arg), wrap(param));", "-    if (vars.contains(param)) {", "-      return param.apply(new TypeAbstractVisitor<ConstraintSet>() {", "-        public ConstraintSet defaultCase(Type param) { return UNSATISFIABLE_CONSTRAINTS; }", "-        ", "-        @Override public ConstraintSet forArrayType(ArrayType param) {", "-          if (arg instanceof ArrayType) { ", "-            return inferFromEqual(((ArrayType) arg).ofType(), param.ofType(), vars, stack);", "-          }", "-          else { return UNSATISFIABLE_CONSTRAINTS; }", "-        }", "-        ", "-        @Override public ConstraintSet forParameterizedClassType(ParameterizedClassType param) {", "-          if (arg instanceof ParameterizedClassType) {", "-            ParameterizedClassType argCast = (ParameterizedClassType) arg;", "-            if (param.ofClass().equals(argCast.ofClass())) {", "-              ConstraintSet result = EMPTY_CONSTRAINTS;", "-              for (Pair<Type, Type> pair : IterUtil.zip(argCast.typeArguments(), param.typeArguments())) {", "-                result = result.and(inferFromEqual(pair.first(), pair.second(), vars, stack));", "-            else { return UNSATISFIABLE_CONSTRAINTS; }", "-          else { return UNSATISFIABLE_CONSTRAINTS; }", "-        }", "-        ", "-        @Override public ConstraintSet forVariableType(VariableType param) {", "-          if (vars.contains(param)) {", "-            return EMPTY_CONSTRAINTS.andLowerBound(param, arg).andUpperBound(param, arg);", "-          else { return UNSATISFIABLE_CONSTRAINTS; }", "-        }", "-        ", "-        @Override public ConstraintSet forIntersectionType(IntersectionType param) {", "-          if (arg instanceof IntersectionType) {", "-            Iterable<? extends Type> argSups = ((IntersectionType) arg).ofTypes();", "-            if (IterUtil.sizeOf(argSups) != IterUtil.sizeOf(param.ofTypes())) {", "-              return UNSATISFIABLE_CONSTRAINTS;", "-            }", "-            else {", "-              ConstraintSet result = UNSATISFIABLE_CONSTRAINTS;", "-              for (Iterable<Type> paramSups : PermutationIterable.make(param.ofTypes())) {", "-                ConstraintSet thisPerm = EMPTY_CONSTRAINTS;", "-                for (Pair<Type, Type> pair : IterUtil.zip(argSups, paramSups)) {", "-                  thisPerm = thisPerm.and(inferFromEqual(pair.first(), pair.second(), vars, stack));", "-                  if (!thisPerm.isSatisfiable()) { break; }", "-                result = result.or(thisPerm);", "-          else { return UNSATISFIABLE_CONSTRAINTS; }", "-        }", "-        ", "-        @Override public ConstraintSet forWildcard(final Wildcard param) {", "-          if (arg instanceof Wildcard) {", "-            Thunk<ConstraintSet> recurOnBounds = new Thunk<ConstraintSet>() {", "-              public ConstraintSet value() {", "-                Wildcard argCast = (Wildcard) arg;", "-                ConstraintSet result = inferFromEqual(argCast.symbol().upperBound(), param.symbol().upperBound(),", "-                                                      vars, stack);", "-                if (result.isSatisfiable()) { ", "-                  result = result.and(inferFromEqual(argCast.symbol().lowerBound(), param.symbol().lowerBound(),", "-                                                     vars, stack));", "-            };", "-            return stack.apply(recurOnBounds, EMPTY_CONSTRAINTS, arg, param, InferenceMode.EQUAL);", "-          else { return UNSATISFIABLE_CONSTRAINTS; }", "-      });", "-    }", "-    else {", "-      return (isEqual(arg, param)) ? EMPTY_CONSTRAINTS : UNSATISFIABLE_CONSTRAINTS;", "-    }", "+      ", "+      private Boolean checkBoundedSymbol(Type t, final BoundedSymbol s) {", "+        final TypeVisitor<Boolean> visitor = this; // handles this shadowing", "+        // wildcards here aren't recursive, so don't need to be handled with a stack,", "+        // but it doesn't hurt to cover the more general case", "+        Thunk<Boolean> handleBounds = new Thunk<Boolean>() {", "+          public Boolean value() {", "+            return s.lowerBound().apply(visitor) || s.upperBound().apply(visitor);", "+          }", "+        };", "+        return _stack.apply(handleBounds, false, t);", "+      }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aed557f8e4289ac52a5e4df5830225f2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 274, "methodNumberAfterChange": 306, "signatureBeforeChange": "         private SignatureChecker makeChecker(Iterable<? extends VariableType> tparams, Iterable<? extends Type> targs,                                        Iterable<? extends Type> params, Iterable<? extends Expression> args,                                        Type returned, Option<Type> expected)", "signatureAfterChange": "          private SignatureMatcher makeMatcher(Iterable<? extends VariableType> tparams,                                          Iterable<? extends Type> targs,                                          Iterable<? extends Type> params,                                          Iterable<? extends Expression> args,                                          Type returned, Option<Type> expected)", "diff": ["+    ", "+    private SignatureMatcher makeMatcher(Iterable<? extends VariableType> tparams,", "+                                         Iterable<? extends Type> targs,", "+                                         Iterable<? extends Type> params,", "+                                         Iterable<? extends Expression> args,", "+                                         Type returned, Option<Type> expected) {", "+      // Note: per the JLS, we allow the presence of (ignored) targs when tparams is empty", "+      int argCount = IterUtil.sizeOf(args);", "+      int paramCount = IterUtil.sizeOf(params);", "+      if (argCount == paramCount - 1) {", "+        if (IterUtil.isEmpty(tparams)) {", "+          return new EmptyVarargMatcher(params, args, tparams, EMPTY_TYPE_ITERABLE);", "+        }", "+        else if (IterUtil.isEmpty(targs)) {", "+          return new EmptyVarargInferenceMatcher(params, args, tparams, returned, expected);", "+        }", "+        else if (IterUtil.sizeOf(tparams) == IterUtil.sizeOf(targs) && inBounds(tparams, targs)) {", "+          return new EmptyVarargMatcher(substitute(params, tparams, targs), args, tparams, targs);", "+        }", "+        else { return NullMatcher.INSTANCE; }", "+      }", "+      else if (argCount == paramCount) {", "+        if (IterUtil.isEmpty(tparams)) { ", "+          return new SimpleMatcher(params, args, tparams, EMPTY_TYPE_ITERABLE);", "+        }", "+        else if (IterUtil.isEmpty(targs)) {", "+          return new InferenceMatcher(params, args, tparams, returned, expected);", "+        }", "+        else if (IterUtil.sizeOf(tparams) == IterUtil.sizeOf(targs) && inBounds(tparams, targs)) { ", "+          return new SimpleMatcher(substitute(params, tparams, targs), args, tparams, targs);", "+        }", "+        else { return NullMatcher.INSTANCE; }", "+      }", "+      else if (argCount > paramCount && paramCount >= 1) {", "+        if (IterUtil.isEmpty(tparams)) { ", "+          return new MultiVarargMatcher(params, args, tparams, EMPTY_TYPE_ITERABLE);", "+        }", "+        else if (IterUtil.isEmpty(targs)) {", "+          return new MultiVarargInferenceMatcher(params, args, tparams, returned, expected);", "+        }", "+        else if (IterUtil.sizeOf(tparams) == IterUtil.sizeOf(targs) && inBounds(tparams, targs)) {", "+          return new MultiVarargMatcher(substitute(params, tparams, targs), args, tparams, targs);", "+        }", "+        else { return NullMatcher.INSTANCE; }", "+      }", "+      else { return NullMatcher.INSTANCE; }", "+    }", "-  ", "-  private SignatureChecker makeChecker(Iterable<? extends VariableType> tparams, Iterable<? extends Type> targs,", "-                                       Iterable<? extends Type> params, Iterable<? extends Expression> args,", "-                                       Type returned, Option<Type> expected) {", "-    // Note: per the JLS, we allow the presense of (ignored) targs when tparams is empty", "-    int argCount = IterUtil.sizeOf(args);", "-    int paramCount = IterUtil.sizeOf(params);", "-    if (argCount == paramCount - 1) {", "-      if (IterUtil.isEmpty(tparams)) {", "-        return new EmptyVarargChecker(params, args, tparams, EMPTY_TYPE_ITERABLE);", "-      }", "-      else if (IterUtil.isEmpty(targs)) {", "-        return new EmptyVarargInferenceChecker(params, args, tparams, returned, expected);", "-      }", "-      else if (IterUtil.sizeOf(tparams) == IterUtil.sizeOf(targs) && inBounds(tparams, targs)) {", "-        return new EmptyVarargChecker(substitute(params, tparams, targs), args, tparams, targs);", "-      }", "-      else { return NullChecker.INSTANCE; }", "-    }", "-    else if (argCount == paramCount) {", "-      if (IterUtil.isEmpty(tparams)) { ", "-        return new SimpleChecker(params, args, tparams, EMPTY_TYPE_ITERABLE);", "-      }", "-      else if (IterUtil.isEmpty(targs)) {", "-        return new InferenceChecker(params, args, tparams, returned, expected);", "-      }", "-      else if (IterUtil.sizeOf(tparams) == IterUtil.sizeOf(targs) && inBounds(tparams, targs)) { ", "-        return new SimpleChecker(substitute(params, tparams, targs), args, tparams, targs);", "-      }", "-      else { return NullChecker.INSTANCE; }", "-    }", "-    else if (argCount > paramCount && paramCount >= 1) {", "-      if (IterUtil.isEmpty(tparams)) { ", "-        return new MultiVarargChecker(params, args, tparams, EMPTY_TYPE_ITERABLE);", "-      }", "-      else if (IterUtil.isEmpty(targs)) {", "-        return new MultiVarargInferenceChecker(params, args, tparams, returned, expected);", "-      }", "-      else if (IterUtil.sizeOf(tparams) == IterUtil.sizeOf(targs) && inBounds(tparams, targs)) {", "-        return new MultiVarargChecker(substitute(params, tparams, targs), args, tparams, targs);", "-      }", "-      else { return NullChecker.INSTANCE; }", "-    }", "-    else { return NullChecker.INSTANCE; }", "-  }"]}], "num": 9920}