{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "81b09cec1a2ac1393378d9f68788d623", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0698a9e96da10b3d5fec321cd4cb2088", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/KeyBindingManager.java", "commitBeforeChange": "7100bfae3584eff8b8b1993fd999385d8f88ea13", "commitAfterChange": "6bcdef7d4202e06be1c5717fc181a0fdfcc7756a", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 10, "signatureBeforeChange": "     public Action getShiftAction()", "signatureAfterChange": "      private void removeExistingKeyStroke(KeyStroke ks)", "diff": ["+  ", "+  private void removeExistingKeyStroke(KeyStroke ks) {", "+    // check for conflicting key binding", "+    if (_keyToDataMap.containsKey(ks) && _shouldCheckConflict) {", "+      // if new key in map, and shouldUpdate returns true, we are overwriting it", "+      KeyStrokeData conflictKSD = _keyToDataMap.get(ks);", "+      // remove ks from the conflicting keystroke data", "+      Set<KeyStroke> conflictKeys = new LinkedHashSet<KeyStroke>(conflictKSD.getKeyStrokes());", "+      conflictKeys.remove(ks);", "+      conflictKSD.setKeyStrokes(new Vector<KeyStroke>(conflictKeys));", "+      updateMenuItem(conflictKSD);", "+      _keyToDataMap.remove(ks);", "+      DrJava.getConfig().setSetting(conflictKSD.getOption(), conflictKSD.getKeyStrokes());", "+    }", "+  }", "-    public Option<KeyStroke> getOption() { return _kso; }", "-    public Action getShiftAction() { return _shiftA; }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0bc060f23d0533f4785b5874caf8c149", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/newjvm/ExecJVM.java", "commitBeforeChange": "f6fc0c2918885b86d7588893e1a025f2fac926cd", "commitAfterChange": "1cb938b1998dc1cd68c3e4689c986e43001ea1ec", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "   private static Process _runJVM(String mainClass, String[] classParams, String[] jvmParams, File workDir) throws IOException", "signatureAfterChange": "   private static Process _runJVM(String mainClass, String[] classParams, String[] jvmParams, File workDir) throws IOException", "diff": ["-", "-    if (workDir != FileOption.NULL_FILE) {", "+    Process p;", "+    if ((workDir != null) && (workDir != FileOption.NULL_FILE)) {", "-      return Runtime.getRuntime().exec(argArray, null, workDir);", "+      if (workDir.exists()) {", "+        p = Runtime.getRuntime().exec(argArray, null, workDir);", "+      }", "+      else {", "+        edu.rice.cs.util.swing.Utilities.showMessageBox(\"Work directory does not exist:\\n\"+workDir+", "+                                                        \"\\nClearing work directory setting. Press OK to continue.\",", "+                                                        \"Configuration Error\");", "+        edu.rice.cs.drjava.DrJava.getConfig().setSetting(OptionConstants.WORKING_DIRECTORY, FileOption.NULL_FILE);", "+        p = Runtime.getRuntime().exec(argArray);", "+      }", "-      return Runtime.getRuntime().exec(argArray);", "+      p = Runtime.getRuntime().exec(argArray);", "+    return p;"]}], "num": 13765}