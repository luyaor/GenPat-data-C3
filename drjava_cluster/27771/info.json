{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a35864c348a02db6b46a7695764fbf6a", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "391029ee38521625b3ad1bf766ea31f2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/JPDADebugger.java", "commitBeforeChange": "fb8ddcbfd71bd75d2b307b4e83f7a834ec364082", "commitAfterChange": "be84679bc73e85f88d6958fbfdf8b35be73855ab", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 61, "signatureBeforeChange": "   private ObjectReference _getDebugInterpreter(String interpreterName,                                                 ThreadReference threadRef)      throws InvalidTypeException, ClassNotLoadedException,     IncompatibleThreadStateException, InvocationException, DebugException", "signatureAfterChange": "   private ObjectReference _getDebugInterpreter(String interpreterName,                                                 ThreadReference threadRef)      throws InvalidTypeException, ClassNotLoadedException,     IncompatibleThreadStateException, InvocationException, DebugException", "diff": ["-    LinkedList args = new LinkedList();", "-    args.add(_vm.mirrorOf(interpreterName)); // make the String a JDI Value", "-    if( printMessages ) { ", "-      System.out.println(\"Invoking \" + m.toString() + \" on \" + args.toString());", "-      System.out.println(\"Thread is \" + threadRef.toString() + \" <suspended = \" + threadRef.isSuspended() + \">\");", "-    }", "-    ObjectReference tmpInterpreter = (ObjectReference)", "-      _interpreterJVM.invokeMethod(threadRef, m, args, ", "-                                   ObjectReference.INVOKE_SINGLE_THREADED);", "-    if( printMessages ) System.out.println(\"Returning...\");", "-    return tmpInterpreter;", "+    // invokeMethod would throw an ObjectCollectedException if the StringReference ", "+    // declared by _vm.mirrorOf(name) had been garbage collected before ", "+    // invokeMethod could execute. This happened infrequently so by trying this", "+    // multiple times, the chance of failure each time should be acceptably low.", "+    ", "+    int tries = 0;", "+    while (tries < MAXINVOKETRIES) {      ", "+      LinkedList args = new LinkedList();", "+      args.add(_vm.mirrorOf(interpreterName)); // make the String a JDI Value", "+      if( printMessages ) { ", "+        System.out.println(\"Invoking \" + m.toString() + \" on \" + args.toString());", "+        System.out.println(\"Thread is \" + threadRef.toString() + \" <suspended = \" + threadRef.isSuspended() + \">\");", "+      }", "+      ", "+      try {", "+        ObjectReference tmpInterpreter = (ObjectReference) _interpreterJVM.invokeMethod(threadRef, m, args, ", "+                                     ObjectReference.INVOKE_SINGLE_THREADED);", "+        if( printMessages ) System.out.println(\"Returning...\");        ", "+        return tmpInterpreter;", "+      }", "+      catch (ObjectCollectedException oce) {", "+        tries++;", "+      }", "+    }", "+    throw new DebugException(\"The debugInterpreter: \" + interpreterName + \" could not be obtained from interpreterJVM\");", "+    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "695e03fedf195f1bc5a10a546eeccc4f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/JPDADebugger.java", "commitBeforeChange": "fb8ddcbfd71bd75d2b307b4e83f7a834ec364082", "commitAfterChange": "be84679bc73e85f88d6958fbfdf8b35be73855ab", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 64, "signatureBeforeChange": "   private void _defineVariable(ThreadReference suspendedThreadRef,                                 ObjectReference debugInterpreter,                                String name, Value val)      throws InvalidTypeException, AbsentInformationException, IncompatibleThreadStateException,     ClassNotLoadedException, InvocationException, DebugException", "signatureAfterChange": "   private void _defineVariable(ThreadReference suspendedThreadRef,                                 ObjectReference debugInterpreter,                                String name, Value val)      throws InvalidTypeException, AbsentInformationException, IncompatibleThreadStateException,     ClassNotLoadedException, InvocationException, DebugException", "diff": ["-    List args = new LinkedList();", "-    args.add(_vm.mirrorOf(name));", "-    args.add(val);", "-    /* System.out.println(\"Calling \" + method2Call.toString() + \"with \" + args.get(0).toString()); */", "-    debugInterpreter.invokeMethod(suspendedThreadRef, method2Call, args, ", "-                                  ObjectReference.INVOKE_SINGLE_THREADED);", "+    // invokeMethod would throw an ObjectCollectedException if the StringReference ", "+    // declared by _vm.mirrorOf(name) had been garbage collected before ", "+    // invokeMethod could execute. This happened infrequently so by trying this", "+    // multiple times, the chance of failure each time should be acceptably low.", "+     ", "+    int tries = 0;", "+    while (tries < MAXINVOKETRIES) {", "+      List args = new LinkedList();", "+      args.add(_vm.mirrorOf(name));", "+      args.add(val);", "+      ", "+      /* System.out.println(\"Calling \" + method2Call.toString() + \"with \" + args.get(0).toString()); */", "+      try {", "+        debugInterpreter.invokeMethod(suspendedThreadRef, method2Call, args, ", "+                                      ObjectReference.INVOKE_SINGLE_THREADED);", "+        return;", "+      }", "+      catch (ObjectCollectedException oce) {", "+        tries++;", "+      }", "+    }", "+    throw new DebugException(\"The variable: \" + name + \" could not be defined in the debug interpreter\");"]}], "num": 27771}