{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a1c9f0abdd69abe71cfbfe604056f7d8", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "92d357b4aa7e5e9c90849038c15ed6df", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ReducedModel.java", "commitBeforeChange": "fa3002b037df55391c4f74b18fce7cb5d20b82f3", "commitAfterChange": "5f12d16bf856e43a5e3999099b39d12f17d7ad32", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 57, "signatureBeforeChange": "   public int balanceBackward()", "signatureAfterChange": "    public int balanceBackward()", "diff": ["+", "-\t\t\treturn _balance(false);", "-    }", "+\t\t\tStack<ReducedToken> braceStack = new Stack<ReducedToken>();", "+\t\t\tModelList<ReducedToken>.Iterator iter = _cursor.copy();", "+\t\t\tif (iter.atStart() || iter.atFirstItem())", "+\t\t\t\treturn -1;", "+\t\t\t", "+\t\t\titer.prev();", "+\t\t\t// here we check to make sure there is an open significant brace", "+\t\t\t// immediately to the right of the cursor", "+\t\t\tif (_isCurrentBraceMatchable(iter) &&", "+\t\t\t\t\titer.current().isClosed() &&", "+\t\t\t\t\t_offset == 0)", "+\t\t\t\t{", "+\t\t\t\t\t// initialize the distance and the stack with the first brace,", "+\t\t\t\t\t// the one we are balancing", "+\t\t\t\t\tint distance = 0;", "+\t\t\t\t\tbraceStack.push(iter.current());", "+\t\t\t\t\tdistance += iter.current().getSize();", "+\t\t\t\t\titer.prev();", "+", "+\t\t\t\t\t// either we get a match and the stack is empty", "+\t\t\t\t\t// or we reach the start of a file and haven't found a match", "+\t\t\t\t\t// or we have a open brace that doesn't have a match,", "+\t\t\t\t\t//    so we abort", "+\t\t\t\t\twhile (!iter.atStart() && !braceStack.isEmpty())", "+\t\t\t\t\t\t{", "+\t\t\t\t\t\t\tif (_isCurrentBraceMatchable(iter)) {", "+\t\t\t\t\t\t\t\t// open", "+\t\t\t\t\t\t\t\tif (iter.current().isOpen()) {", "+\t\t\t\t\t\t\t\t\tReducedToken popped = braceStack.pop();", "+\t\t\t\t\t\t\t\t\tif (!iter.current().isMatch(popped))", "+\t\t\t\t\t\t\t\t\t\treturn -1;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t// closed", "+\t\t\t\t\t\t\t\telse {", "+\t\t\t\t\t\t\t\t\tbraceStack.push(iter.current());", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// no matter what, we always want to increase the distance", "+\t\t\t\t\t\t\t// by the size of the token we have just gone over", "+\t\t\t\t\t\t\tdistance += iter.current().getSize();", "+\t\t\t\t\t\t\titer.prev();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// we couldn't find a match", "+\t\t\t\t\tif (!braceStack.isEmpty())", "+\t\t\t\t\t\treturn -1;", "+\t\t\t\t\t// success", "+\t\t\t\t\telse", "+\t\t\t\t\t\treturn distance;", "+\t\t\t\t}", "+\t\t\t// not the right initial conditions ", "+\t\t\telse", "+\t\t\t\treturn -1;\t\t\t\t", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d5984b9e68b0ce978332c6bdca5e264b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ReducedModel.java", "commitBeforeChange": "fa3002b037df55391c4f74b18fce7cb5d20b82f3", "commitAfterChange": "5f12d16bf856e43a5e3999099b39d12f17d7ad32", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 56, "signatureBeforeChange": "   public int balanceForward()", "signatureAfterChange": "   public int balanceForward()", "diff": ["-      return _balance(true);", "+\t\t\tStack<ReducedToken> braceStack = new Stack<ReducedToken>();", "+\t\t\tModelList<ReducedToken>.Iterator iter = _cursor.copy();", "+", "+\t\t\tif (iter.atStart())", "+\t\t\t\titer.next();", "+", "+\t\t\t// here we check to make sure there is an open significant brace", "+\t\t\t// immediately to the right of the cursor", "+\t\t\tif (!iter.atEnd() &&", "+\t\t\t\t\t_isCurrentBraceMatchable(iter) &&", "+\t\t\t\t\titer.current().isOpen() &&", "+\t\t\t\t\t_offset == 0)", "+\t\t\t\t{", "+\t\t\t\t\t// initialize the distance and the stack with the first brace,", "+\t\t\t\t\t// the one we are balancing", "+\t\t\t\t\tint distance = 0;", "+\t\t\t\t\tbraceStack.push(iter.current());", "+\t\t\t\t\tdistance += iter.current().getSize();", "+\t\t\t\t\titer.next();", "+", "+\t\t\t\t\t// either we get a match and the stack is empty", "+\t\t\t\t\t// or we reach the end of a file and haven't found a match", "+\t\t\t\t\t// or we have a closed brace that doesn't have a match,", "+\t\t\t\t\t//    so we abort", "+\t\t\t\t\twhile (!iter.atEnd() && !braceStack.isEmpty())", "+\t\t\t\t\t\t{", "+\t\t\t\t\t\t\tif (_isCurrentBraceMatchable(iter)) {", "+\t\t\t\t\t\t\t\t// closed", "+\t\t\t\t\t\t\t\tif (iter.current().isClosed()) {", "+\t\t\t\t\t\t\t\t\tReducedToken popped = braceStack.pop();", "+\t\t\t\t\t\t\t\t\tif (!iter.current().isMatch(popped))", "+\t\t\t\t\t\t\t\t\t\treturn -1;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t// open", "+\t\t\t\t\t\t\t\telse {", "+\t\t\t\t\t\t\t\t\tbraceStack.push(iter.current());", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// no matter what, we always want to increase the distance", "+\t\t\t\t\t\t\t// by the size of the token we have just gone over", "+\t\t\t\t\t\t\tdistance += iter.current().getSize();", "+\t\t\t\t\t\t\titer.next();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// we couldn't find a match", "+\t\t\t\t\tif (!braceStack.isEmpty())", "+\t\t\t\t\t\treturn -1;", "+\t\t\t\t\t// success", "+\t\t\t\t\telse", "+\t\t\t\t\t\treturn distance;", "+\t\t\t\t}", "+\t\t\t// not the right initial conditions ", "+\t\t\telse", "+\t\t\t\treturn -1;\t\t\t"]}], "num": 640}