{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "acca3a94112b6587899199a8eab5cc14", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "428f37c9b94c7040957c1afa8deb2b39", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/JPDADebugger.java", "commitBeforeChange": "0ef216d80b2e9cc63f2ef7b2c23490480ef77851", "commitAfterChange": "c5aaf72fbd7fa889788e2cd72fe646345421a547", "methodNumberBeforeChange": 69, "methodNumberAfterChange": 69, "signatureBeforeChange": "   private void _dumpVariablesIntoInterpreterAndSwitch() throws DebugException, AbsentInformationException", "signatureAfterChange": "   private void _dumpVariablesIntoInterpreterAndSwitch() throws DebugException, AbsentInformationException", "diff": ["+        Type type;", "+        if (val != null) {", "+          type = val.type();", "+        }", "+        else {", "+          try {", "+            type = localVar.type();", "+          }", "+          catch(ClassNotLoadedException e) {", "+            List classes = _vm.classesByName(localVar.typeName());", "+            if (!classes.isEmpty()) {", "+              type = (Type)classes.get(0);", "+            }", "+            else {", "+              type = null;", "+            }", "+          }", "+        }", "-                        localVar.name(), val);", "+                        localVar.name(), val, type);", "-                        \"this\", thisVal);", "+                        \"this\", thisVal, thisVal.type());", "+      if (printMessages) {", "+        System.out.println(\"setting active interpreter\");", "+      }", "+      if (printMessages) {", "+        System.out.println(\"got active interpreter\");", "+      }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf246ffe62435de6ff43a691e151daf0", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/TypeChecker.java", "commitBeforeChange": "9a249358791ef18c654eafdb246c8cfb93a3ab2d", "commitAfterChange": "4dc5ace86e9b2c575f2b09ebb783f4d8d9db5e9a", "methodNumberBeforeChange": 85, "methodNumberAfterChange": 85, "signatureBeforeChange": "   private static void checkEqualityStaticRules(Class lc, Class rc, Node n)", "signatureAfterChange": "   private static void checkEqualityStaticRules(Class lc, Class rc, BinaryExpression n)", "diff": ["-  private static void checkEqualityStaticRules(Class lc, Class rc, Node n) {", "+  private static void checkEqualityStaticRules(Class lc, Class rc, BinaryExpression n) {", "+    Expression leftExp = n.getLeftExpression();", "+    Expression rightExp = n.getRightExpression();", "+", "+    // Auto-unbox, if necessary", "+    /**", "+     * We have not decided what the correct semantics", "+     * for the == operator is for boxed/primitive types", "+     */", "+    if (lc != null && rc != null) {", "+      if (_isBoxingType(lc) && rc.isPrimitive()) {", "+        ObjectMethodCall methodCall = _unbox(leftExp, lc);", "+        n.setLeftExpression(methodCall);", "+        lc = (Class) methodCall.getProperty(NodeProperties.TYPE);", "+      }", "+      if (_isBoxingType(rc) && lc.isPrimitive()) {", "+        ObjectMethodCall methodCall = _unbox(rightExp, rc);", "+        n.setRightExpression(methodCall);", "+        rc = (Class) methodCall.getProperty(NodeProperties.TYPE);", "+      }", "+    }", "+", "-      if (lc == void.class    || rc == void.class     ||", "+      if (lc == void.class    || rc == void.class ||", "-      } else if ((lc == null && rc.isPrimitive()) ||", "-                 (rc == null && lc.isPrimitive())) {", "+      } ", "+      else if ((lc == null && rc.isPrimitive()) ||", "+               (rc == null && lc.isPrimitive())) {", "-      } else if (lc != null && rc != null) {", "+      } ", "+      else if (lc != null && rc != null) {", "-        } else if (!lc.isPrimitive() && !rc.isPrimitive()) {", "+        }", "+        else if (!lc.isPrimitive() && !rc.isPrimitive()) {  "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "faa038ba9da245f3eabed08fbc0c9638", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "plt/src/edu/rice/cs/plt/concurrent/IncrementalTaskController.java", "commitBeforeChange": "b23111eb475b92740f35af8853527f4b3b92f815", "commitAfterChange": "3ea6a37aa7347e12727171dd92a2bb3861e3967f", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 5, "signatureBeforeChange": "   public void pause()", "signatureAfterChange": "   public void pause()", "diff": ["-    switch (_status) {", "-      case RUNNING: doPause(); break;", "-      case CANCELED: throw new IllegalStateException(\"Task is cancelled\");", "-    }", "+    // ideally, this would be implemented as part of the state, but we can't do that without", "+    // redefining the entire hierarchy of state classes", "+    boolean success = false;", "+    do {", "+      State s = state.get();", "+      if (s instanceof TaskController.RunningState) {", "+        success = state.compareAndSet(s, new FreshPausingState());", "+        if (success) { doPause(); }", "+      }", "+      else if (s instanceof TaskController.FreshStartingState) {", "+        success = state.compareAndSet(s, new PausedStartingState());", "+      }", "+      else if (s instanceof IncrementalTaskController.StartedPausingState) {", "+        success = state.compareAndSet(s, new FreshPausingState());", "+      }", "+      else if (s instanceof TaskController.CanceledState) {", "+        throw new CancellationException(\"Task is canceled\");", "+      }", "+      else { // ignore other fresh, finished, pausing, or canceling states", "+        success = true;", "+      }", "+    } while (!success);"]}], "num": 15249}