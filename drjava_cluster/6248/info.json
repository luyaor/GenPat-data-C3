{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e59a5e9db9f5b8facd2f0389f2f084ed", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39192182fcdfc24380b99e366ab2b2df", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/Java5Class.java", "commitBeforeChange": "ede26ceaad5c407d940ac773a5e7f457dc1f5187", "commitAfterChange": "734866577ba652e258c158eef25bcbc68a43749a", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "          private static Type convertParameterizedType(ParameterizedType paramT,                                                 final PrecomputedRecursionStack<java.lang.reflect.Type, Type> stack)", "signatureAfterChange": "          private static Type convertParameterizedType(ParameterizedType paramT,                                                 final PrecomputedRecursionStack<java.lang.reflect.Type, Type> stack)", "diff": ["-    Iterable<Type> targsBuilder = IterUtil.empty();", "-    boolean raw = false; // true iff an enclosing type is raw, and so this type must also be raw", "+    // assumes getRawType and getOwnerType return class types", "+    ClassType rawT = (ClassType) convertType(paramT.getRawType(), stack);", "+    ClassType ownerT = (paramT.getOwnerType() == null) ? null : (ClassType) convertType(paramT.getOwnerType(), stack);", "+    ClassType enclosingT = rawT.ofClass().isStatic() ? SymbolUtil.dynamicOuterClassType(ownerT) : ownerT;", "-    if (paramT.getOwnerType() != null) {", "-      Type ownerT = convertType(paramT.getOwnerType(), stack);", "-      Iterable<? extends Type> outerArgs = ownerT.apply(new TypeAbstractVisitor<Iterable<? extends Type>>() {", "-        ", "-        public Iterable<? extends Type> defaultCase(Type ownerT) { ", "-          throw new IllegalArgumentException(\"Owner of ParameterizedType must be a class type\");", "-        }", "-        ", "-        @Override public Iterable<? extends Type> forSimpleClassType(SimpleClassType ownerT) { ", "+    Iterable<? extends Type> outerArgs = IterUtil.empty();", "+    boolean raw = false; // true iff an enclosing type is raw, and so this type must also be raw", "+    if (enclosingT != null) {", "+      Iterable<? extends Type> ts = enclosingT.apply(new TypeAbstractVisitor<Iterable<? extends Type>>() {", "+        @Override public Iterable<? extends Type> forSimpleClassType(SimpleClassType enclosingT) { ", "-        ", "-        @Override public Iterable<? extends Type> forRawClassType(RawClassType ownerT) { return null; }", "-        ", "-        @Override public Iterable<? extends Type> forParameterizedClassType(ParameterizedClassType ownerT) { ", "-          return ownerT.typeArguments();", "+        @Override public Iterable<? extends Type> forRawClassType(RawClassType enclosingT) { return null; }", "+        @Override public Iterable<? extends Type> forParameterizedClassType(ParameterizedClassType enclosingT) { ", "+          return enclosingT.typeArguments();", "-      if (outerArgs == null) { raw = true; }", "-      else { targsBuilder = IterUtil.compose(targsBuilder, outerArgs); }", "+      if (ts == null) { raw = true; }", "+      else { outerArgs = ts; }", "-    targsBuilder = IterUtil.compose(targsBuilder, convertTypes(paramT.getActualTypeArguments(), stack));", "-    ", "-    Type rawT = convertType(paramT.getRawType(), stack);", "-    final Iterable<Type> targs = targsBuilder; // targsBuilder must be redeclared as final", "+    Iterable<Type> directArgs = convertTypes(paramT.getActualTypeArguments(), stack);", "+    final Iterable<Type> targs = IterUtil.compose(outerArgs, directArgs);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5addd67313ddacd3613330482159552", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 219, "methodNumberAfterChange": 249, "signatureBeforeChange": "   protected Type immediateSupertype(ClassType t)", "signatureAfterChange": "      private Type fieldType(final DJField f, Type declaringType)", "diff": ["-  /** Get a class's immediate supertype.  The result is either null or the result of a {@link #meet} call. */", "-    return t.apply(new TypeAbstractVisitor<Type>() {", "-      public Type defaultCase(Type t) { throw new IllegalArgumentException(); }", "-      public Type forSimpleClassType(SimpleClassType t) { return immediateSupertype(t); }", "-      public Type forRawClassType(RawClassType t) { return immediateSupertype(t); }", "-      public Type forParameterizedClassType(ParameterizedClassType t) { return immediateSupertype(t); }", "-    });", "-  }", "+  ", "+  private Type fieldType(final DJField f, Type declaringType) {", "+    return declaringType.apply(new TypeAbstractVisitor<Type>() {", "+      @Override public Type defaultCase(Type declaringType) { return f.type(); }", "+      @Override public Type forRawClassType(RawClassType declaringType) { return erase(f.type()); }", "+      @Override public Type forParameterizedClassType(ParameterizedClassType declaringType) {", "+        ParameterizedClassType cap = capture(declaringType);", "+        return substitute(f.type(), SymbolUtil.allTypeParameters(cap.ofClass()), cap.typeArguments());", "+      }"]}], "num": 6248}