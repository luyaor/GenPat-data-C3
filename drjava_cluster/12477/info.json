{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "07283a53f327c3e5caaa5bf2f045dcba", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3751a875391f5a390375c1b0804f5f52", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 49, "methodNumberAfterChange": 53, "signatureBeforeChange": "   private Type handleNumericAssignmentExpression(BinaryExpression node)", "signatureAfterChange": "     private Type handleNumericAssignmentExpression(BinaryExpression node)", "diff": ["+     */", "+    private Type handleNumericAssignmentExpression(BinaryExpression node) {", "+      Type result = check(node.getLeftExpression());", "+      check(node.getRightExpression());", "+        ", "+        if (!hasVariableType(node.getLeftExpression())) {", "+          throw new ExecutionError(\"numeric.expression.type\", node);", "+        }", "+        return setType(node, result);", "-   */", "-  private Type handleNumericAssignmentExpression(BinaryExpression node) {", "-    Type result = node.getLeftExpression().acceptVisitor(this);", "-    node.getRightExpression().acceptVisitor(this);", "-    try {", "-      Expression left = ts.makePrimitive(node.getLeftExpression());", "-      Expression right = ts.makePrimitive(node.getRightExpression());", "-      Pair<Expression, Expression> promoted = ts.binaryPromote(left, right);", "-      ", "-      if (!hasVariableType(node.getLeftExpression())) {", "-      setLeftExpression(node, promoted.first()); // not to be confused with node.setLeftExpression(...)", "-      node.setRightExpression(promoted.second());", "-      return setType(node, result);", "-    catch (UnsupportedConversionException e) {", "-      throw new ExecutionError(\"numeric.expression.type\", node);", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4312caa0e2bb0daaf2bcf5891de6f586", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 69, "signatureBeforeChange": "   private Type handleBitwiseAssignmentExpression(BinaryExpression node)", "signatureAfterChange": "     private Type handleBitwiseAssignmentExpression(BinaryExpression node)", "diff": ["-   */", "-  private Type handleBitwiseAssignmentExpression(BinaryExpression node) {", "-    Type result = node.getLeftExpression().acceptVisitor(this);", "-    node.getRightExpression().acceptVisitor(this);", "-    try {", "-      Expression left = ts.makePrimitive(node.getLeftExpression());", "-      Expression right = ts.makePrimitive(node.getRightExpression());", "-      if (getType(left) instanceof BooleanType && getType(right) instanceof BooleanType) {", "-        // Do nothing", "-      }", "-      else if (getType(left) instanceof IntegralType && getType(right) instanceof IntegralType) {", "-        Pair<Expression, Expression> promoted = ts.binaryPromote(left, right);", "-        left = promoted.first();", "-        right = promoted.second();", "-      }", "-      else {", "-        throw new ExecutionError(\"bitwise.expression.type\", node);", "-      }", "-      ", "-      if (!hasVariableType(node.getLeftExpression())) {", "-        throw new ExecutionError(\"bitwise.expression.type\", node);", "-      }", "-      setLeftExpression(node, left); // not to be confused with node.setLeftExpression(...)", "-      node.setRightExpression(right);", "-      return setType(node, result);", "-    }", "-    catch (UnsupportedConversionException e) {", "-      throw new ExecutionError(\"bitwise.expression.type\", node);", "-    }", "-  }", "+     */", "+    private Type handleBitwiseAssignmentExpression(BinaryExpression node) {", "+      Type result = check(node.getLeftExpression());", "+      check(node.getRightExpression());", "+      try {", "+        Expression left = ts.makePrimitive(node.getLeftExpression());", "+        Expression right = ts.makePrimitive(node.getRightExpression());", "+        if (getType(left) instanceof BooleanType && getType(right) instanceof BooleanType) {", "+          // Do nothing", "+        }", "+        else if (getType(left) instanceof IntegralType && getType(right) instanceof IntegralType) {", "+          Pair<Expression, Expression> promoted = ts.binaryPromote(left, right);", "+          left = promoted.first();", "+          right = promoted.second();", "+        }", "+        else {", "+          throw new ExecutionError(\"bitwise.expression.type\", node);", "+        }", "+        ", "+        if (!hasVariableType(node.getLeftExpression())) {", "+          throw new ExecutionError(\"bitwise.expression.type\", node);", "+        }", "+        setLeftExpression(node, left); // not to be confused with node.setLeftExpression(...)", "+        node.setRightExpression(right);", "+        return setType(node, result);", "+      }", "+      catch (UnsupportedConversionException e) {", "+        throw new ExecutionError(\"bitwise.expression.type\", node);", "+      }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "640894372c551a7afadfee37083dfcb6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 56, "signatureBeforeChange": "   private Type handleEqualityExpression(BinaryExpression node, Lambda2<Object, Object, Object> objectCase,                                         Lambda2<Object, Object, Object>  primitiveCase)", "signatureAfterChange": "     private Type handleEqualityExpression(BinaryExpression node, Lambda2<Object, Object, Object> objectCase,                                           Lambda2<Object, Object, Object>  primitiveCase)", "diff": ["-   */", "-  private Type handleEqualityExpression(BinaryExpression node, Lambda2<Object, Object, Object> objectCase,", "-                                        Lambda2<Object, Object, Object>  primitiveCase) {", "-    Type leftT = node.getLeftExpression().acceptVisitor(this);", "-    Type rightT = node.getRightExpression().acceptVisitor(this);", "-    if (ts.isReference(leftT) && ts.isReference(rightT)) {", "-      if (!ts.isCastable(leftT, rightT) && !ts.isCastable(rightT, leftT)) {", "+     */", "+    private Type handleEqualityExpression(BinaryExpression node, Lambda2<Object, Object, Object> objectCase,", "+                                          Lambda2<Object, Object, Object>  primitiveCase) {", "+      Type leftT = check(node.getLeftExpression());", "+      Type rightT = check(node.getRightExpression());", "+      if (ts.isReference(leftT) && ts.isReference(rightT)) {", "+        if (!ts.isCastable(leftT, rightT) && !ts.isCastable(rightT, leftT)) {", "+          throw new ExecutionError(\"compare.type\", node);", "+        }", "+        setOperation(node, objectCase);", "+      }", "+      else {", "+        try {", "+          Expression left = ts.makePrimitive(node.getLeftExpression());", "+          Expression right = ts.makePrimitive(node.getRightExpression());", "+          ", "+          if (getType(left) instanceof BooleanType && getType(right) instanceof BooleanType) {", "+            node.setLeftExpression(left);", "+            node.setRightExpression(right);", "+          }", "+          else if (getType(left) instanceof NumericType && getType(right) instanceof NumericType) {", "+            Pair<Expression, Expression> promoted = ts.binaryPromote(left, right);", "+            left = promoted.first();", "+            right = promoted.second();", "+            node.setLeftExpression(promoted.first());", "+            node.setRightExpression(promoted.second());", "+          }", "+          else {", "+            throw new ExecutionError(\"compare.type\", node);", "+          }", "+          setOperation(node, primitiveCase);", "+        }", "+        catch (UnsupportedConversionException e) {", "+          throw new ExecutionError(\"compare.type\", node);", "+        }", "+      }", "+      return setType(node, TypeSystem.BOOLEAN);", "+    }", "-      setOperation(node, objectCase);", "-    else {", "-          node.setLeftExpression(left);", "-          node.setRightExpression(right);", "-        else if (getType(left) instanceof NumericType && getType(right) instanceof NumericType) {", "-          node.setLeftExpression(promoted.first());", "-          node.setRightExpression(promoted.second());", "-          throw new ExecutionError(\"compare.type\", node);", "-        setOperation(node, primitiveCase);", "-        throw new ExecutionError(\"compare.type\", node);", "-      }", "-    }", "-    return setType(node, TypeSystem.BOOLEAN);", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6707fa8663dd4f810111afc04ad4a6c9", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 65, "signatureBeforeChange": "   private Type handleBitwiseExpression(BinaryExpression node)", "signatureAfterChange": "     private Type handleBitwiseExpression(BinaryExpression node)", "diff": ["+     */", "+    private Type handleBitwiseExpression(BinaryExpression node) {", "+      check(node.getLeftExpression());", "+      check(node.getRightExpression());", "+          // Do nothing", "+        else if (getType(left) instanceof IntegralType && getType(right) instanceof IntegralType) {", "+          throw new ExecutionError(\"bitwise.expression.type\", node);", "+        ", "+        node.setLeftExpression(left);", "+        node.setRightExpression(right);", "+        ", "+        return setType(node, getType(left));", "-   */", "-  private Type handleBitwiseExpression(BinaryExpression node) {", "-    node.getLeftExpression().acceptVisitor(this);", "-    node.getRightExpression().acceptVisitor(this);", "-    try {", "-      Expression left = ts.makePrimitive(node.getLeftExpression());", "-      Expression right = ts.makePrimitive(node.getRightExpression());", "-      ", "-      if (getType(left) instanceof BooleanType && getType(right) instanceof BooleanType) {", "-        // Do nothing", "-      }", "-      else if (getType(left) instanceof IntegralType && getType(right) instanceof IntegralType) {", "-        Pair<Expression, Expression> promoted = ts.binaryPromote(left, right);", "-        left = promoted.first();", "-        right = promoted.second();", "-      }", "-      else {", "-      ", "-      node.setLeftExpression(left);", "-      node.setRightExpression(right);", "-      ", "-      return setType(node, getType(left));", "-    catch (UnsupportedConversionException e) {", "-      throw new ExecutionError(\"bitwise.expression.type\", node);", "-    }", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7f948e84d615361d996abf1fb4a1c801", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 69, "methodNumberAfterChange": 73, "signatureBeforeChange": "   private Type handleShiftExpression(BinaryExpression node)", "signatureAfterChange": "     private Type handleShiftExpression(BinaryExpression node)", "diff": ["-   */", "-  private Type handleShiftExpression(BinaryExpression node) {", "-    node.getLeftExpression().acceptVisitor(this);", "-    node.getRightExpression().acceptVisitor(this);", "-    try {", "-      Expression left = ts.unaryPromote(ts.makePrimitive(node.getLeftExpression()));", "-      Expression right = ts.unaryPromote(ts.makePrimitive(node.getRightExpression()));", "-      node.setLeftExpression(left);", "-      node.setRightExpression(right);", "-      ", "-      if (!(getType(left) instanceof IntegralType) || !(getType(right) instanceof IntegralType)) {", "-        throw new ExecutionError(\"shift.expression.type\", node);", "-      }", "-      ", "-      return setType(node, getType(left));", "-    }", "-    catch (UnsupportedConversionException e) {", "-      throw new ExecutionError(\"shift.expression.type\", node);", "-    }", "-  }", "+     */", "+    private Type handleShiftExpression(BinaryExpression node) {", "+      check(node.getLeftExpression());", "+      check(node.getRightExpression());", "+      try {", "+        Expression left = ts.unaryPromote(ts.makePrimitive(node.getLeftExpression()));", "+        Expression right = ts.unaryPromote(ts.makePrimitive(node.getRightExpression()));", "+        node.setLeftExpression(left);", "+        node.setRightExpression(right);", "+        ", "+        if (!(getType(left) instanceof IntegralType) || !(getType(right) instanceof IntegralType)) {", "+          throw new ExecutionError(\"shift.expression.type\", node);", "+        }", "+        ", "+        return setType(node, getType(left));", "+      }", "+      catch (UnsupportedConversionException e) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c08a28eb3766d67147b3eba7ad87f6d3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 73, "methodNumberAfterChange": 77, "signatureBeforeChange": "   private Type handleShiftAssignmentExpression(BinaryExpression node)", "signatureAfterChange": "     private Type handleShiftAssignmentExpression(BinaryExpression node)", "diff": ["-   */", "-  private Type handleShiftAssignmentExpression(BinaryExpression node) {", "-    Type result = node.getLeftExpression().acceptVisitor(this);", "-    node.getRightExpression().acceptVisitor(this);", "-    try {", "-      Expression left = ts.unaryPromote(ts.makePrimitive(node.getLeftExpression()));", "-      Expression right = ts.unaryPromote(ts.makePrimitive(node.getRightExpression()));", "-      ", "-      if (!(getType(left) instanceof IntegralType) || !(getType(right) instanceof IntegralType) || ", "-          !hasVariableType(node.getLeftExpression())) {", "-      ", "-      setLeftExpression(node, left); // not to be confused with node.setLeftExpression(...)", "-      node.setRightExpression(right);", "-      return setType(node, result);", "-    catch (UnsupportedConversionException e) {", "-      throw new ExecutionError(\"shift.expression.type\", node);", "+     */", "+    private Type handleShiftAssignmentExpression(BinaryExpression node) {", "+      Type result = check(node.getLeftExpression());", "+      check(node.getRightExpression());", "+      try {", "+        Expression left = ts.unaryPromote(ts.makePrimitive(node.getLeftExpression()));", "+        Expression right = ts.unaryPromote(ts.makePrimitive(node.getRightExpression()));", "+        ", "+        if (!(getType(left) instanceof IntegralType) || !(getType(right) instanceof IntegralType) || ", "+            !hasVariableType(node.getLeftExpression())) {", "+          throw new ExecutionError(\"shift.expression.type\", node);", "+        }", "+        ", "+        setLeftExpression(node, left); // not to be confused with node.setLeftExpression(...)", "+        node.setRightExpression(right);", "+        return setType(node, result);", "+      }", "+      catch (UnsupportedConversionException e) {", "+        throw new ExecutionError(\"shift.expression.type\", node);", "+      }", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0ed943be76ffea32a0107b5d826a689", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 44, "methodNumberAfterChange": 48, "signatureBeforeChange": "   private Type handleNumericExpression(BinaryExpression node)", "signatureAfterChange": "     private Type handleNumericExpression(BinaryExpression node)", "diff": ["+     */", "+    private Type handleNumericExpression(BinaryExpression node) {", "+      check(node.getLeftExpression());", "+      check(node.getRightExpression());", "+        throw new ExecutionError(\"numeric.expression.type\", node);", "-   */", "-  private Type handleNumericExpression(BinaryExpression node) {", "-    node.getLeftExpression().acceptVisitor(this);", "-    node.getRightExpression().acceptVisitor(this);", "-    try {", "-      Expression left = ts.makePrimitive(node.getLeftExpression());", "-      Expression right = ts.makePrimitive(node.getRightExpression());", "-      Pair<Expression, Expression> promoted = ts.binaryPromote(left, right);", "-      node.setLeftExpression(promoted.first());", "-      node.setRightExpression(promoted.second());", "-      return setType(node, getType(promoted.first()));", "-    }", "-    catch (UnsupportedConversionException e) {", "-      throw new ExecutionError(\"numeric.expression.type\", node);", "-    }", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cef8072cb015f458d2de469927087f4a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 61, "signatureBeforeChange": "   private Type handleRelationalExpression(BinaryExpression node)", "signatureAfterChange": "     private Type handleRelationalExpression(BinaryExpression node)", "diff": ["+     */", "+    private Type handleRelationalExpression(BinaryExpression node) {", "+      check(node.getLeftExpression());", "+      check(node.getRightExpression());", "+      try {", "+        Expression left = ts.makePrimitive(node.getLeftExpression());", "+        Expression right = ts.makePrimitive(node.getRightExpression());", "+        Pair<Expression, Expression> promoted = ts.binaryPromote(left, right);", "+        node.setLeftExpression(promoted.first());", "+        node.setRightExpression(promoted.second());", "+        return setType(node, TypeSystem.BOOLEAN);", "+      }", "+      catch (UnsupportedConversionException e) {", "-   */", "-  private Type handleRelationalExpression(BinaryExpression node) {", "-    node.getLeftExpression().acceptVisitor(this);", "-    node.getRightExpression().acceptVisitor(this);", "-    try {", "-      Expression left = ts.makePrimitive(node.getLeftExpression());", "-      Expression right = ts.makePrimitive(node.getRightExpression());", "-      Pair<Expression, Expression> promoted = ts.binaryPromote(left, right);", "-      node.setLeftExpression(promoted.first());", "-      node.setRightExpression(promoted.second());", "-      return setType(node, TypeSystem.BOOLEAN);", "-    }", "-    catch (UnsupportedConversionException e) {", "-      throw new ExecutionError(\"compare.type\", node);", "-    }", "-  }"]}], "num": 12477}