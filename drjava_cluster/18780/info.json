{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4d673d826b1b8e5b881900e8e1d9d16b", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "07d828fd9e99f59487afd01633c3c31d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/IntermediateVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 34, "signatureBeforeChange": "          public void testCreateConstructor()", "signatureAfterChange": "     public void testCreateConstructor()", "diff": ["-    ", "+    /** Tests createConstructor.  Must ensure that no fixups remain pending before invoking this method. */", "-      SymbolData sd = new SymbolData(\"ClassName\", _publicMav, new TypeParameter[0], null, new LinkedList<SymbolData>(), null);", "-      VariableData v1 = new VariableData(\"i\", _publicMav, SymbolData.INT_TYPE, false, sd);", "-      VariableData v2 = new VariableData(\"j\", _publicMav, SymbolData.CHAR_TYPE, false, sd);", "-      VariableData v3 = new VariableData(\"var\", _publicMav, SymbolData.DOUBLE_TYPE, false, sd);", "+      SymbolData sd =", "+        new SymbolData(\"ClassName\", PUBLIC_MAV, new TypeParameter[0], null, new ArrayList<SymbolData>(), null);", "+      VariableData v1 = new VariableData(\"i\", PUBLIC_MAV, SymbolData.INT_TYPE, false, sd);", "+      VariableData v2 = new VariableData(\"j\", PUBLIC_MAV, SymbolData.CHAR_TYPE, false, sd);", "+      sd.setIsContinuation(false);", "+", "+      System.err.println(\"****** Creating constructor for \" + _sd1);", "+      _iv.createConstructor(_sd1);  // Cannot create constructor for s1 without creating one for its superclass.", "-      MethodData md = new MethodData(\"ClassName\", _publicMav, new TypeParameter[0], sd, ", "-                                     sd.getVars().toArray(new VariableData[0]), ", "+      /* Construct expected MethodData */", "+      // Copy vars without visibility", "+      LinkedList<VariableData> params = new LinkedList<VariableData>();", "+      for (VariableData vd: sd.getVars()) {", "+        VariableData newParam = vd.copyWithoutVisibility();", "+        newParam.setGenerated(true);", "+        params.add(newParam);", "+      };", "+        ", "+      MethodData md = new MethodData(\"ClassName\", ", "+                                     PUBLIC_MAV, ", "+                                     new TypeParameter[0], ", "+                                     sd, ", "+                                     params.toArray(new VariableData[params.size()]), ", "-      md.addVars(md.getParams());", "+      md.addVars(md.getParams());     ", "+      md.setGenerated(true);", "+      ", "+      System.err.println(\"****** Before creating Classname constructor, ClassName methods = \" + sd.getMethods());", "+      System.err.println(\"****** Creating constructor for \" + sd);", "+      System.err.println(\"****** After creating constructor, ClassName method = \" + sd.getMethods());", "+", "+      MethodData conSD = sd.getMethods().getFirst();", "+          ", "+      System.err.println(\"****** Generated MethodData: \" + conSD.toBigString());", "+      System.err.println(\"****** Expectred MethodData: \" + md.toBigString());", "+      assertEquals(\"sd should have 1 method: its own constructor\", md, conSD);", "-      assertEquals(\"sd should have 1 method: its own constructor\", md, sd.getMethods().getFirst());", "-      ", "-      //since this is the only constructor in the symbol data, all the fields should be assigned to have a value after visiting sd.", "-      v1 = new VariableData(\"i\", _publicMav, SymbolData.INT_TYPE, true, sd);", "-      v2 = new VariableData(\"j\", _publicMav, SymbolData.CHAR_TYPE, true, sd);", "+//      // Since this is the only constructor in the SymbolData, all the fields should be assigned after visiting sd.", "+//      v1 = new VariableData(\"i\", PUBLIC_MAV, SymbolData.INT_TYPE, true, sd);", "+//      v2 = new VariableData(\"j\", PUBLIC_MAV, SymbolData.CHAR_TYPE, true, sd);", "+", "+      // Now test a subclass of sd:", "+", "+      SymbolData subSD = ", "+        new SymbolData(\"Subclass\", PUBLIC_MAV, new TypeParameter[0], null, new ArrayList<SymbolData>(), null);", "+      VariableData v3 = new VariableData(\"var\", PUBLIC_MAV, SymbolData.DOUBLE_TYPE, false, subSD);", "+      subSD.addVar(v3);", "+//      // Revise params rather than recreating them, because they contain hidden fields like enclosingData that", "+//      // must be right for equality testing to succeeed", "+//      params.get(0).setName(\"super_i\");", "+//      params.get(1).setName(\"super_j\");", "+//      VariableData v3Param = v3.copyWithoutVisibility();", "+//      v3Param.setGenerated(true);", "+//      params.add(v3Param);", "+      subSD.setSuperClass(sd);", "-      //now test a subclass of sd:", "-      SymbolData subSd = new SymbolData(\"Subclass\",_publicMav, new TypeParameter[0], null, new LinkedList<SymbolData>(), null);", "-      subSd.addVar(v3);", "-      subSd.setSuperClass(sd);", "+      // Create copies of v1, v2. v3 with Package MAV", "+      VariableData v1Param = new VariableData(\"super_i\", PACKAGE_MAV, SymbolData.INT_TYPE, true, subSD);", "+      VariableData v2Param = new VariableData(\"super_j\", PACKAGE_MAV, SymbolData.CHAR_TYPE, true, subSD);", "+      VariableData v3Param = new VariableData(\"var\", PACKAGE_MAV, SymbolData.DOUBLE_TYPE, true, subSD);", "+          ", "+      v1Param.setGenerated(true);", "+      v2Param.setGenerated(true);", "+      v3Param.setGenerated(true);", "-      VariableData v1Param = new VariableData(\"super_i\", _packageMav, SymbolData.INT_TYPE, true, null);", "-      VariableData v2Param = new VariableData(\"super_j\", _packageMav, SymbolData.CHAR_TYPE, true, null);", "-      VariableData[] vars = {v1Param, v2Param, v3};", "-      MethodData md2 = new MethodData(\"Subclass\", _publicMav, new TypeParameter[0], subSd,", "-                                      vars, new String[0], subSd, null);", "+      VariableData[] newParams = new VariableData[] { v1Param, v2Param, v3Param };", "+      ", "+//      VariableData[] newParams = params.toArray(new VariableData[params.size()]);", "+      ", "+      MethodData md2 = ", "+        new MethodData(\"Subclass\", ", "+                       PUBLIC_MAV, ", "+                       new TypeParameter[0], ", "+                       subSD, ", "+                       newParams,", "+                       new String[0], ", "+                       subSD, ", "+                       null);", "+      ", "+      md2.setGenerated(true);", "-      _iv.createConstructor(subSd);", "-      v1Param.setEnclosingData(subSd.getMethods().getFirst());", "-      v2Param.setEnclosingData(subSd.getMethods().getFirst());", "-      assertEquals(\"subSd should have 1 method: its own constructor.\", md2, subSd.getMethods().getFirst());", "+      _iv.createConstructor(subSD);", "+      ", "+      conSD = subSD.getMethods().getFirst();  // Reusing conSD local variable", "+      System.err.println(\"****** Expected params = \" + Arrays.toString(md2.getParams()));", "+      System.err.println(\"****** Results  params = \" + Arrays.toString(conSD.getParams()));", "+      ", "+      System.err.println(\"****** Expected vars = \" + md2.getVars());", "+      System.err.println(\"****** Results  vars = \" + conSD.getVars());", "+      ", "+      System.err.println(\"****** Constructor for Subclass is: \" + conSD.toBigString());", "+      System.err.println(\"****** Expected MethodData is: \" + md2.toBigString());", "+      ", "+      assert md2.getName().equals(conSD.getName());", "+      assert md2.getMav().equals(conSD.getMav());", "+      assert arrayEquals(md2.getTypeParameters(), conSD.getTypeParameters());", "+      assert arrayEquals(md2.getThrown(), conSD.getThrown());", "+      assert md2.getEnclosingData().equals(conSD.getEnclosingData());", "+      LinkedList<VariableData> mVars = md2.getVars();", "+      LinkedList<VariableData> cVars = conSD.getVars();", "+      assert mVars.size() == cVars.size();", "+      for (int i = 0; i < mVars.size(); i++) {", "+        System.err.println(\"****** EnclosingData of mVars \" + i + \" = \" + mVars.get(i).getEnclosingData());", "+        System.err.println(\"****** EnclosingData of cVars \" + i + \" = \" + cVars.get(i).getEnclosingData());", "+        assertEquals(\"Var Test\" + i, mVars.get(i), cVars.get(i));", "+      }", "+        ", "+      assert md2.getVars().equals(conSD.getVars());", "+      assert arrayEquals(md2.getParams(), conSD.getParams());", "+", "+      assertEquals(\"subSD should have 1 method: its own constructor.\", md2, conSD);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "40ee5977f3bcb8546a26e940ebdce2b9", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/JarJDKToolsLibrary.java", "commitBeforeChange": "ecec455630699fb47e48815ed0e8ff7ef49584c1", "commitAfterChange": "09b707cda41d2d3c82d34a50c8dbebc9d7cd95a2", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r   public static Iterable<JarJDKToolsLibrary> search(GlobalModel model)", "signatureAfterChange": "\r   public static Iterable<JarJDKToolsLibrary> search(GlobalModel model)", "diff": ["-    \r", "+\r", "-                                                 LambdaUtil.or(IOUtil.regexCanonicalCaseFilePredicate(\"\\\\d+\\\\.\\\\d+\\\\.\\\\d + \"),\r", "+                                                 LambdaUtil.or(IOUtil.regexCanonicalCaseFilePredicate(\"\\\\d+\\\\.\\\\d+\\\\.\\\\d+\"),\r", "+      msg(\"root: \"+root);\r", "+        msg(\"\\tsubdir: \"+subdir);\r", "+    // JavaMint\r", "+    addIfFile(new File(\"/C:/Program Files/JavaMint/langtools/dist/lib/classes.jar\"), jars);\r", "+    addIfFile(new File(\"/C:/Program Files/JavaMint/langtools/dist/lib/tools.jar\"), jars);\r", "+    addIfFile(new File(\"/usr/local/soylatte/lib/classes.jar\"), jars);\r", "+    addIfFile(new File(\"/usr/local/soylatte/lib/tools.jar\"), jars);\r", "+    addIfFile(new File(\"/usr/local/JavaMint/langtools/dist/lib/classes.jar\"), jars);\r", "+    addIfFile(new File(\"/usr/local/JavaMint/langtools/dist/lib/tools.jar\"), jars);\r", "+    try {\r", "+      String mint_home = System.getenv(\"MINT_HOME\");\r", "+      if (mint_home!=null) {\r", "+        addIfFile(new File(new File(mint_home), \"dist/lib/classes.jar\"), jars);\r", "+        addIfFile(new File(new File(mint_home), \"dist/lib/tools.jar\"), jars);\r", "+      }\r", "+    }\r", "+    catch(Exception e) { /* ignore MINT_HOME variable */ }\r", "+    \r", "+    Map<FullVersion, Iterable<JarJDKToolsLibrary>> mintResults =\r", "+      new TreeMap<FullVersion, Iterable<JarJDKToolsLibrary>>();\r", "+    \r", "-        if (results.containsKey(v)) { results.put(v, IterUtil.compose(lib, results.get(v))); }\r", "-        else { results.put(v, IterUtil.singleton(lib)); }\r", "+        Map<FullVersion, Iterable<JarJDKToolsLibrary>> mapToAddTo = results;\r", "+        if (v.vendor().equals(JavaVersion.VendorType.MINT)) { mapToAddTo = mintResults; }\r", "+        \r", "+        if (mapToAddTo.containsKey(v)) { mapToAddTo.put(v, IterUtil.compose(lib, mapToAddTo.get(v))); }\r", "+        else { mapToAddTo.put(v, IterUtil.singleton(lib)); }\r", "-    return IterUtil.reverse(IterUtil.collapse(results.values()));\r", "+    \r", "+    Iterable<JarJDKToolsLibrary> collapsed = IterUtil.reverse(IterUtil.collapse(results.values()));\r", "+    Iterable<JarJDKToolsLibrary> mintCollapsed = IterUtil.reverse(IterUtil.collapse(mintResults.values()));\r", "+    \r", "+    for(JarJDKToolsLibrary javaLib: collapsed) {\r", "+      msg(\"JDK: \"+javaLib.version());\r", "+    }\r", "+    for(JarJDKToolsLibrary mintLib: mintCollapsed) {\r", "+      msg(\"Mint: \"+mintLib.version());\r", "+    }\r", "+    \r", "+    Map<FullVersion, Iterable<JarJDKToolsLibrary>> javaMintResults =\r", "+      new TreeMap<FullVersion, Iterable<JarJDKToolsLibrary>>();\r", "+    // now we have the JDK libraries in collapsed and the Mint libraries in mintCollapsed\r", "+    for(JarJDKToolsLibrary mintLib: mintCollapsed) {\r", "+      FullVersion mintVersion = mintLib.version();\r", "+      msg(\"Mint version \"+mintVersion.majorVersion()+\": \"+mintVersion);\r", "+      JarJDKToolsLibrary found = null;\r", "+      // try to find a JDK in results that matches mintVersion exactly, except for vendor\r", "+      for(JarJDKToolsLibrary javaLib: collapsed) {\r", "+        FullVersion javaVersion = javaLib.version();\r", "+        msg(\"\\tlooking for exact version: Java version \"+javaVersion.majorVersion()+\": \"+javaVersion);\r", "+        if ((javaVersion.majorVersion().equals(mintVersion.majorVersion())) &&\r", "+            (javaVersion.maintenance()==mintVersion.maintenance()) &&\r", "+            (javaVersion.update()==mintVersion.update()) &&\r", "+            (javaVersion.release()==mintVersion.release())) {\r", "+          found = javaLib;\r", "+          break;\r", "+        }\r", "+      }\r", "+      // if we didn't find one, take the best JDK that matches the major version\r", "+      if (found==null) {\r", "+        for(JarJDKToolsLibrary javaLib: collapsed) {\r", "+          FullVersion javaVersion = javaLib.version();\r", "+          msg(\"\\tlooking for major version Java version \"+javaVersion.majorVersion()+\": \"+javaVersion);\r", "+          if (javaVersion.majorVersion().equals(mintVersion.majorVersion())) {\r", "+            found = javaLib;\r", "+            break;\r", "+          }\r", "+        }\r", "+      }\r", "+      // if we found a JDK, then create a new Mint library\r", "+      if (found!=null) {\r", "+        msg(\"\\t#### picked \"+found.version());\r", "+        JarJDKToolsLibrary lib = makeFromFile(mintLib.location(), model, found.bootClassPath());\r", "+        if (lib.isValid()) {\r", "+          FullVersion v = lib.version();\r", "+          if (javaMintResults.containsKey(v)) { javaMintResults.put(v, IterUtil.compose(lib, javaMintResults.get(v))); }\r", "+          else { javaMintResults.put(v, IterUtil.singleton(lib)); }\r", "+        }\r", "+      }\r", "+    }\r", "+    Iterable<JarJDKToolsLibrary> composed =\r", "+      IterUtil.compose(collapsed,IterUtil.reverse(IterUtil.collapse(javaMintResults.values())));\r", "+\r", "+    for(JarJDKToolsLibrary composedLib: composed) {\r", "+      msg(\"Composed: \"+composedLib.version());\r", "+    }\r", "+    return composed;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8744726432364dace9ac90c00522bc26", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/config/DrJavaPropertySetupTest.java", "commitBeforeChange": "df4d53f84d17cf3ec7ad461e0706b30f84e9362b", "commitAfterChange": "c5aac5c6295f0f62821cacd426fa94832d9a11b1", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "      public void testFile() throws CloneNotSupportedException, IOException", "signatureAfterChange": "      public void testFile() throws CloneNotSupportedException, IOException", "diff": ["-    assertTrue(s.startsWith(System.getProperty(\"java.io.tmpdir\")+File.separator+\"DrJava-Execute-\"));", "+    assertTrue(s.startsWith(TMPDIR+\"DrJava-Execute-\"));", "-    assertTrue(s2.startsWith(System.getProperty(\"java.io.tmpdir\")+File.separator+\"DrJava-Execute-\"));", "+    assertTrue(s2.startsWith(TMPDIR+\"DrJava-Execute-\"));", "-    assertEquals(System.getProperty(\"java.io.tmpdir\")+File.separator+\"foo\", s);", "+    assertEquals(TMPDIR+\"foo\", s);", "-    p.setAttribute(\"file\",StringOps.escapeFileName(dir.getAbsolutePath()));", "-    assertEquals(dir.getParentFile().getAbsolutePath(), p.getCurrent(pm));", "+    p.setAttribute(\"file\",StringOps.escapeFileName(dir .getAbsolutePath()));", "+    assertEquals(dir.getParentFile().getAbsolutePath(), StringOps.unescapeFileName(p.getCurrent(pm)));", "-    assertEquals(fil.getParentFile().getAbsolutePath(), p.getCurrent(pm));", "+    assertEquals(fil.getParentFile().getAbsolutePath(), StringOps.unescapeFileName(p.getCurrent(pm)));", "-    assertEquals(new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath(), p.getCurrent(pm));", "+    assertEquals(new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath(),", "+                 StringOps.unescapeFileName(p.getCurrent(pm)));", "-                 new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath(), p.getCurrent(pm));", "+                 new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath(),", "+                 StringOps.unescapeFileName(p.getCurrent(pm)));", "-    assertEquals(dir.getAbsolutePath(), p.getCurrent(pm));", "+    assertEquals(dir.getAbsolutePath(), StringOps.unescapeFileName(p.getCurrent(pm)));", "-    assertEquals(fil.getAbsolutePath(), p.getCurrent(pm));", "+    assertEquals(fil.getAbsolutePath(), StringOps.unescapeFileName(p.getCurrent(pm)));", "-    assertEquals(notFound.getAbsolutePath(), p.getCurrent(pm));", "+    assertEquals(notFound.getAbsolutePath(), StringOps.unescapeFileName(p.getCurrent(pm)));", "-                 notFound.getAbsolutePath(), p.getCurrent(pm));", "+                 notFound.getAbsolutePath(), StringOps.unescapeFileName(p.getCurrent(pm)));", "-    ", "+    dir = FileOps.createTempDirectory(\"DrJavaPropertySetupTest\");", "+    p.setAttribute(\"file\",StringOps.escapeFileName(dir.getAbsolutePath()));", "+    assertTrue(p.getCurrent(pm).startsWith(\"(file.rel Error\"));", "+    p.resetAttributes();", "+    p.setAttribute(\"base\",StringOps.escapeFileName(dir.getAbsolutePath()));", "+    assertTrue(p.getCurrent(pm).startsWith(\"(file.rel Error\"));", "+    p.setAttribute(\"file\",StringOps.escapeFileName(dir.getAbsolutePath()));", "+    p.setAttribute(\"base\",StringOps.escapeFileName(dir.getAbsolutePath()));", "+    assertEquals(\".\", StringOps.unescapeFileName(p.getCurrent(pm)));", "+    p.setAttribute(\"file\",StringOps.escapeFileName(dir.getAbsolutePath()));", "+    p.setAttribute(\"base\",StringOps.escapeFileName(dir.getParentFile().getAbsolutePath()));", "+    assertEquals(dir.getName(), StringOps.unescapeFileName(p.getCurrent(pm)));", "+    dir = edu.rice.cs.plt.io.IOUtil.createAndMarkTempDirectory(\"DrJavaPropertySetupTest\",\"\");", "+    File dir1 = edu.rice.cs.plt.io.IOUtil.createAndMarkTempDirectory(\"DrJavaPropertySetupTest\",\"\",dir);", "+    File dir2 = edu.rice.cs.plt.io.IOUtil.createAndMarkTempDirectory(\"DrJavaPropertySetupTest\",\"\",dir);", "+    fil = edu.rice.cs.plt.io.IOUtil.createAndMarkTempFile(\"DrJavaPropertySetupTest\",\".txt\",dir1);", "+    p.setAttribute(\"file\",StringOps.escapeFileName(fil.getAbsolutePath()));", "+    p.setAttribute(\"base\",StringOps.escapeFileName(dir2.getAbsolutePath()));", "+    assertEquals(\"..\"+FS+dir1.getName()+FS+fil.getName(), StringOps.unescapeFileName(p.getCurrent(pm)));    ", "+        "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d32627f3df3c39090f8795ad07c5dd5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/cache/DocumentCacheTest.java", "commitBeforeChange": "0b7f9842c42a34509d077a5e1d655daf0b8192d6", "commitAfterChange": "736bd820b2cec64b47667921b5d5c82d9c502af8", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 10, "signatureBeforeChange": "      public void testDocumentsInAndOutOfTheCache() throws BadLocationException, IOException", "signatureAfterChange": "      public void testDocumentsInAndOutOfTheCache() throws BadLocationException, IOException", "diff": ["-    // The model already has an active empty document", "-    OpenDefinitionsDocument doc1 =  _model.newFile();", "-    assertTrue(\"The document should start out in the cache\", _cache.isDDocInCache(doc1));", "-    assertEquals(\"There should be 2 documents in the cache\", 2, _cache.getNumInCache());", "-    OpenDefinitionsDocument doc2 =  _model.newFile();", "-    assertTrue(\"The document should start out in the cache\", _cache.isDDocInCache(doc2));", "-    assertEquals(\"There should be 3 documents in the cache\", 3, _cache.getNumInCache());", "-    OpenDefinitionsDocument doc3 =  _model.newFile();", "-    assertTrue(\"The document should start out in the cache\", _cache.isDDocInCache(doc3));", "-    assertEquals(\"There should be 4 documents in the cache\", 4, _cache.getNumInCache());", "-    OpenDefinitionsDocument doc4 =  _model.newFile();", "-    assertTrue(\"The document should start out in the cache\", _cache.isDDocInCache(doc4));", "-    assertEquals(\"There should be 4 documents in the cache\", 4, _cache.getNumInCache());", "-    OpenDefinitionsDocument doc5 =  _model.newFile();", "-    assertTrue(\"The document should start out in the cache\", _cache.isDDocInCache(doc5));", "-    assertEquals(\"There should be 4 documents in the cache\", 4, _cache.getNumInCache());", "-    OpenDefinitionsDocument doc6 =  _model.newFile();", "-    assertTrue(\"The document should start out in the cache\", _cache.isDDocInCache(doc6));", "-    assertEquals(\"There should be 4 documents in the cache\", 4, _cache.getNumInCache());", "+    // The documents should not be activated upon creation ", "-    // checkin isModifiedSinceSave shouldn't activate the documents", "+    OpenDefinitionsDocument doc1 =  _model.newFile();", "+    assertEquals(\"There should be 0 documents in the cache\", 0, _cache.getNumInCache()); // was 0", "+    ", "+    OpenDefinitionsDocument doc2 =  _model.newFile();", "+    assertEquals(\"There should be 0 documents in the cache\", 0, _cache.getNumInCache()); // was 0", "+    ", "+    OpenDefinitionsDocument doc3 =  _model.newFile();", "+    assertEquals(\"There should be 0 documents in the cache\", 0, _cache.getNumInCache()); // was 0", "+    ", "+    OpenDefinitionsDocument doc4 =  _model.newFile();", "+    assertEquals(\"There should be 0 documents in the cache\", 0, _cache.getNumInCache()); // was 0", "+    ", "+    OpenDefinitionsDocument doc5 =  _model.newFile();", "+    assertEquals(\"There should be 0 documents in the cache\", 0, _cache.getNumInCache()); // was 0", "+    ", "+    OpenDefinitionsDocument doc6 =  _model.newFile();", "+    assertEquals(\"There should be 0 documents in the cache\", 0, _cache.getNumInCache()); // was 0", "+    ", "+    // This tests that isModifiedSinceSave does not cause the document to load into the cache,", "+    // so the two that should have been kicked out, 1 & 2 should not be loaded uppon calling isModified.", "+", "+    assertEquals(\"There should be 4 documents in the cache\", 0, _cache.getNumInCache());", "-    assertEquals(\"There should still be 4 documents in the cache\", 4, _cache.getNumInCache());", "+    assertFalse(\"Document 1 shouldn't be ready\", _adapterTable.get(doc1).isReady());", "+    assertFalse(\"Document 2 shouldn't be ready\", _adapterTable.get(doc2).isReady());", "+    assertFalse(\"Document 3 shouldn't be ready\", _adapterTable.get(doc3).isReady());", "+    assertFalse(\"Document 4 shouldn't be ready\", _adapterTable.get(doc4).isReady());", "+    assertFalse(\"Document 5 shouldn't be ready\", _adapterTable.get(doc5).isReady());", "+    assertFalse(\"Document 6 shouldn't be ready\", _adapterTable.get(doc6).isReady());", "+    ", "+    // Front of LRU -> a b c d | e f <- out of LRU", "-    doc1.getLength();", "-    doc2.getLength();", "-    doc3.getLength();", "-    doc4.getLength();", "-    assertFalse(\"The document 5 should have been kicked out of the cache\", _cache.isDDocInCache(doc5));", "-    assertFalse(\"The document 6 should have been kicked out of the cache\", _cache.isDDocInCache(doc6));", "+    ", "+    // 6 5 4 3 | 2 1", "+    assertFalse(\"Document 1 shouldn't be ready\", _adapterTable.get(doc1).isReady());", "+    assertFalse(\"Document 2 shouldn't be ready\", _adapterTable.get(doc2).isReady());", "+    assertTrue(\"Document 3 shouldn't be ready\", _adapterTable.get(doc3).isReady());", "+    assertTrue(\"Document 4 shouldn't be ready\", _adapterTable.get(doc4).isReady());", "+    assertTrue(\"Document 5 shouldn't be ready\", _adapterTable.get(doc5).isReady());", "+    assertTrue(\"Document 6 shouldn't be ready\", _adapterTable.get(doc6).isReady());", "+        ", "+    doc1.getLength(); // 1 6 5 4 | 3 2", "+    assertTrue(\"The document 1 should should now be in the cache\", _adapterTable.get(doc1).isReady());    ", "+    assertEquals(\"There should still be 1 documents in the cache\", 4, _cache.getNumInCache()); ", "+    assertFalse(\"The document 3 should have been kicked out of the cache\", _adapterTable.get(doc3).isReady());", "+    ", "+    doc2.getLength(); // 2 1 6 5 | 4 3", "+    assertTrue(\"The document 2 should should now be in the cache\", _adapterTable.get(doc2).isReady());", "+    assertEquals(\"There should still be 2 documents in the cache\", 4, _cache.getNumInCache());", "+    assertFalse(\"The document 4 should have been kicked out of the cache\", _adapterTable.get(doc4).isReady());", "+    ", "+    doc3.getLength(); // 3 2 1 6 | 5 4", "+    assertTrue(\"The document 3 should should now be in the cache\", _adapterTable.get(doc3).isReady());", "+    assertEquals(\"There should still be 3 documents in the cache\", 4, _cache.getNumInCache());", "+    assertFalse(\"The document 5 should have been kicked out of the cache\", _adapterTable.get(doc5).isReady());", "+    ", "+    doc4.getLength(); // 4 3 2 1 | 6 5", "+    assertTrue(\"The document 4 should should now be in the cache\", _adapterTable.get(doc4).isReady());", "+    assertEquals(\"There should still be 4 documents in the cache\", 4, _cache.getNumInCache());", "+    assertFalse(\"The document 6 should have been kicked out of the cache\", _adapterTable.get(doc6).isReady());", "+    ", "+    doc5.getLength(); // 5 4 3 2 | 1 6", "+    assertTrue(\"The document 5 should should now be in the cache\", _adapterTable.get(doc5).isReady());", "+    assertEquals(\"There should still be 4 documents in the cache\", 4, _cache.getNumInCache());", "+    assertFalse(\"The document 1 should have been kicked out of the cache\", _adapterTable.get(doc1).isReady());", "+    ", "+    doc6.getLength(); // 6 5 4 3 | 2 1", "+    assertTrue(\"The document 6 should should now be in the cache\", _adapterTable.get(doc6).isReady());", "+    assertEquals(\"There should still be 4 documents in the cache\", 4, _cache.getNumInCache());", "+    assertFalse(\"The document 2 should have been kicked out of the cache\", _adapterTable.get(doc2).isReady());", "+    ", "+    // Load documents out of order", "+    doc4.getLength(); // 4 6 5 3 | 2 1", "+    assertTrue(\"The document 3 should should still be in the cache\", _adapterTable.get(doc3).isReady());    ", "+    assertEquals(\"There should still be 4 documents in the cache\", 4, _cache.getNumInCache());", "+    doc5.getLength(); // 5 4 6 3 | 2 1", "+    assertTrue(\"The document 3 should should still be in the cache\", _adapterTable.get(doc3).isReady());    ", "+    assertEquals(\"There should still be 4 documents in the cache\", 4, _cache.getNumInCache());", "+    doc3.getLength(); // 3 5 4 6 | 2 1", "+    assertTrue(\"The document 6 should should still be in the cache\", _adapterTable.get(doc6).isReady());    ", "+    assertEquals(\"There should still be 4 documents in the cache\", 4, _cache.getNumInCache());", "+    doc4.getLength(); // 4 3 5 6 | 2 1", "+    assertTrue(\"The document 6 should should still be in the cache\", _adapterTable.get(doc6).isReady());    ", "+    assertFalse(\"The document 1 should still be out of the cache\", _adapterTable.get(doc1).isReady());", "+    assertFalse(\"The document 2 should still be out of the cache\", _adapterTable.get(doc2).isReady());", "-    // Test the LRU to make sure the documents are kicked out in the right order", "-    doc5.getLength();", "-    assertFalse(\"doc1 should have been kicked out first\", _cache.isDDocInCache(doc1));", "-    doc6.getLength();", "-    assertFalse(\"doc2 should have been kicked out first\", _cache.isDDocInCache(doc2));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b2ff77c924fc0c1940baec138503b498", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/DefinitionsPaneTest.java", "commitBeforeChange": "0707afe81b4d2dfe9c2f27d4ef0cf8fcb3dfd8ff", "commitAfterChange": "a2ecf7f1dd3c4baa5e86a7675beca418200c8154", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 28, "signatureBeforeChange": "      public void testDocumentPaneMemoryLeak()  throws InterruptedException, java.io.IOException", "signatureAfterChange": "      public void testDocumentPaneMemoryLeak()  throws InterruptedException, IOException", "diff": ["-  public void testDocumentPaneMemoryLeak()  throws InterruptedException, java.io.IOException {", "+  public void testDocumentPaneMemoryLeak()  throws InterruptedException, IOException {", "+", "+    // print identity hash codes into a StringBuilder in case we need them later;", "+    // this does not create any references", "+    StringBuilder sbIdHashCodes = new StringBuilder();", "+    sbIdHashCodes.append(\"_frame = \"+_frame.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(_frame))+\"\\n\");", "+    sbIdHashCodes.append(\"_model = \"+_model.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(_frame))+\"\\n\");", "+    sbIdHashCodes.append(\"p1     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(p1))+\"\\n\");", "+    sbIdHashCodes.append(\"p2     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(p2))+\"\\n\");", "+    sbIdHashCodes.append(\"p3     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(p3))+\"\\n\");", "+    sbIdHashCodes.append(\"p4     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(p4))+\"\\n\");", "+    sbIdHashCodes.append(\"p5     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(p5))+\"\\n\");", "+    sbIdHashCodes.append(\"p6     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(p6))+\"\\n\");", "+    sbIdHashCodes.append(\"d1     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(d1))+\"\\n\");", "+    sbIdHashCodes.append(\"d2     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(d2))+\"\\n\");", "+    sbIdHashCodes.append(\"d3     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(d3))+\"\\n\");", "+    sbIdHashCodes.append(\"d4     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(d4))+\"\\n\");", "+    sbIdHashCodes.append(\"d5     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(d5))+\"\\n\");", "+    sbIdHashCodes.append(\"d6     = \"+p1.getClass().getName()+\"@0x\"+Integer.toHexString(System.identityHashCode(d6)));", "+", "-    ", "-    if (ct == 10) fail(\"Failed to reclaim all documents; panes left = \" + (6 - _finalPaneCt) + \"; docs left = \" + ", "-                       (6 - _finalDocCt));", "-    ", "+", "+    if (ct == 10) {", "+      // if we fail with a garbage collection problem, dump heap", "+      LOG.setEnabled(true);", "+      LOG.log(sbIdHashCodes.toString());", "+      try { LOG.log(\"heap dump in \"+dumpHeap()); }", "+      catch(Exception e) {", "+        System.err.println(\"Could not dump heap.\");", "+        e.printStackTrace(System.err);", "+      }", "+      ", "+      fail(\"Failed to reclaim all documents; panes left = \" + (6 - _finalPaneCt) + \"; docs left = \" + ", "+           (6 - _finalDocCt));", "+    }", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc3bb3df5b7385917cd5bb770e1807d6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/InteractionsPaneTest.java", "commitBeforeChange": "451a8ef10dd808c32bb1dec2a41dbfe38542794f", "commitAfterChange": "fd372db787cedeccdc43d382b7e2999ff5184943", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "   public void testCaretUpdatedOnInsert() throws EditDocumentException", "signatureAfterChange": "   public void testCaretUpdatedOnInsert() throws EditDocumentException", "diff": ["-    _doc.append(\"typed text\", InteractionsDocument.DEFAULT_STYLE);", "+    Utilities.invokeAndWait(new Runnable() {", "+      public void run() {", "+        ", "+        // Type 'T'", "+        _pane.processKeyEvent(new KeyEvent(_pane, PRESSED, (new Date()).getTime(), SHIFT, KeyEvent.VK_T, UNDEFINED));", "+        _pane.processKeyEvent(new KeyEvent(_pane, TYPED, (new Date()).getTime(), 0, VK_UNDEF, 'T'));", "+        _pane.processKeyEvent(new KeyEvent(_pane, RELEASED, (new Date()).getTime(), SHIFT, KeyEvent.VK_T, UNDEFINED));", "+        ", "+        // Type 'Y'", "+        _pane.processKeyEvent(new KeyEvent(_pane, PRESSED, (new Date()).getTime(), SHIFT, KeyEvent.VK_Y, UNDEFINED));", "+        _pane.processKeyEvent(new KeyEvent(_pane, TYPED, (new Date()).getTime(), 0, VK_UNDEF, 'Y'));", "+        _pane.processKeyEvent(new KeyEvent(_pane, RELEASED, (new Date()).getTime(), SHIFT, KeyEvent.VK_Y, UNDEFINED));", "+        ", "+         // Type 'P'", "+        _pane.processKeyEvent(new KeyEvent(_pane, PRESSED, (new Date()).getTime(), SHIFT, KeyEvent.VK_P, UNDEFINED));", "+        _pane.processKeyEvent(new KeyEvent(_pane, TYPED, (new Date()).getTime(), 0, VK_UNDEF, 'P'));", "+        _pane.processKeyEvent(new KeyEvent(_pane, RELEASED, (new Date()).getTime(), SHIFT, KeyEvent.VK_P, UNDEFINED));", "+        ", "+         // Type 'E'", "+        _pane.processKeyEvent(new KeyEvent(_pane, PRESSED, (new Date()).getTime(), SHIFT, KeyEvent.VK_E, UNDEFINED));", "+        _pane.processKeyEvent(new KeyEvent(_pane, TYPED, (new Date()).getTime(), 0, VK_UNDEF, 'E'));", "+        _pane.processKeyEvent(new KeyEvent(_pane, RELEASED, (new Date()).getTime(), SHIFT, KeyEvent.VK_E, UNDEFINED));", "+        ", "+         // Type 'D'", "+        _pane.processKeyEvent(new KeyEvent(_pane, PRESSED, (new Date()).getTime(), SHIFT, KeyEvent.VK_D, UNDEFINED));", "+        _pane.processKeyEvent(new KeyEvent(_pane, TYPED, (new Date()).getTime(), 0, VK_UNDEF, 'D'));", "+        _pane.processKeyEvent(new KeyEvent(_pane, RELEASED, (new Date()).getTime(), SHIFT, KeyEvent.VK_D, UNDEFINED));", "+      }", "+    });", "+//    System.err.println(\"Document = '\" + _doc.getText() + \"'\");", "+//    System.err.println(\"docLength = \" +  _doc.getLength() + \" caretPos = \" + _pane.getCaretPosition());", "+    ", "+//    System.err.println(\"Document = '\" + _doc.getText() + \"'\");", "-    Utilities.invokeAndWait(new Runnable() { public void run() { _pane.setCaretPosition(newPos + 1); } });", "+    _pane.setCaretPosition(newPos + 1);", "+    Utilities.invokeAndWait(new Runnable() { ", "+      public void run() { ", "+        // Type 'D'", "+        _pane.processKeyEvent(new KeyEvent(_pane, PRESSED, (new Date()).getTime(), SHIFT, KeyEvent.VK_D, UNDEFINED));", "+        _pane.processKeyEvent(new KeyEvent(_pane, TYPED, (new Date()).getTime(), 0, VK_UNDEF, 'D'));", "+        _pane.processKeyEvent(new KeyEvent(_pane, RELEASED, (new Date()).getTime(), SHIFT, KeyEvent.VK_D, UNDEFINED));", "+      } ", "+    });", "-    _doc.insertText(newPos, \"d\", InteractionsDocument.DEFAULT_STYLE);", "-    Utilities.clearEventQueue();", "-    assertEquals(\"caret should be one char after the d\", newPos + 2, _pane.getCaretPosition());", "+    assertEquals(\"caret should be one char after the inserted D\", newPos + 2, _pane.getCaretPosition());"]}], "num": 18780}