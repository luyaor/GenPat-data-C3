{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a425b75dd13175c64d85aadb0359235d", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "75e1087ef6767eb017aeeb94580786db", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "commitAfterChange": "608d05e2a10d21cbc190b09334cd60b3c39fbc37", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "      private String nodeTypesString(Iterable<? extends Node> nodes)", "signatureAfterChange": "      private String nodeTypesString(Iterable<? extends Node> nodes)", "diff": ["-    Lambda<Node, String> typeString = new Lambda<Node, String>() {", "-      public String value(Node n) { return ts.userRepresentation(getType(n)); }", "-    };", "-    return IterUtil.toString(IterUtil.map(nodes, typeString), \"\", \", \", \"\");", "+    return ts.userRepresentation(IterUtil.map(nodes, NODE_TYPE));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c440c525071d50e460f7041113ddad98", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 8, "signatureBeforeChange": "      private Iterable<Type> checkTypeNameList(Iterable<? extends TypeName> l)", "signatureAfterChange": "      private Iterable<Type> checkTypeNameList(Iterable<? extends TypeName> l)", "diff": ["-    // TypeNames should be handled in a separate visitor, but I don't want to risk messing", "-    // things up...  On the other, hand, I don't want this class to implement Lambda<Node, Type>,", "-    // because then it's more likely to be used incorrectly.", "-    return IterUtil.mapSnapshot(l, new Lambda<TypeName, Type>() {", "-      public Type value(TypeName n) { return n.acceptVisitor(ExpressionChecker.this); }", "-    });", "-  }", "+    return new TypeNameChecker(context, opt).checkList(l);"]}], "num": 25735}