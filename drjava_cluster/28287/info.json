{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5c1d5451377bf29828e01f545e5a48fb", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0698a9e96da10b3d5fec321cd4cb2088", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/KeyBindingManager.java", "commitBeforeChange": "7100bfae3584eff8b8b1993fd999385d8f88ea13", "commitAfterChange": "6bcdef7d4202e06be1c5717fc181a0fdfcc7756a", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 10, "signatureBeforeChange": "     public Action getShiftAction()", "signatureAfterChange": "      private void removeExistingKeyStroke(KeyStroke ks)", "diff": ["+  ", "+  private void removeExistingKeyStroke(KeyStroke ks) {", "+    // check for conflicting key binding", "+    if (_keyToDataMap.containsKey(ks) && _shouldCheckConflict) {", "+      // if new key in map, and shouldUpdate returns true, we are overwriting it", "+      KeyStrokeData conflictKSD = _keyToDataMap.get(ks);", "+      // remove ks from the conflicting keystroke data", "+      Set<KeyStroke> conflictKeys = new LinkedHashSet<KeyStroke>(conflictKSD.getKeyStrokes());", "+      conflictKeys.remove(ks);", "+      conflictKSD.setKeyStrokes(new Vector<KeyStroke>(conflictKeys));", "+      updateMenuItem(conflictKSD);", "+      _keyToDataMap.remove(ks);", "+      DrJava.getConfig().setSetting(conflictKSD.getOption(), conflictKSD.getKeyStrokes());", "+    }", "+  }", "-    public Option<KeyStroke> getOption() { return _kso; }", "-    public Action getShiftAction() { return _shiftA; }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3320318ae4f12a4c0d94220018f16b50", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultSingleDisplayModel.java", "commitBeforeChange": "4276346051c6ab89c146c0041be28826e7dfbe12", "commitAfterChange": "86bed99990f6eb7fff2cb31d595e17b49135df26", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 23, "signatureBeforeChange": "   public boolean isClosingAllFiles()", "signatureAfterChange": "   private void _ensureNotActive(List<OpenDefinitionsDocument> docs)", "diff": ["-   */", "-  public boolean isClosingAllFiles() {", "-    return _isClosingAllDocs;", "-  }", "+   */", "+  private void _ensureNotActive(List<OpenDefinitionsDocument> docs) {", "+    if (docs.contains(getActiveDocument())) {", "+      // Find the one that should be the new active document", "+      IDocumentNavigator nav = getDocumentNavigator();", "+      ", "+      INavigatorItem item = getIDocGivenODD(docs.get(docs.size()-1));", "+      INavigatorItem nextActive = nav.getNext(item);", "+      if (!nextActive.equals(item)) {", "+        nav.setActiveDoc(nextActive); ", "+        return;", "+      }", "+      ", "+      item = getIDocGivenODD(docs.get(0));", "+      nextActive = nav.getPrevious(item);", "+      if (!nextActive.equals(item)) { ", "+        nav.setActiveDoc(nextActive);", "+        return;", "+      }", "+      ", "+      throw new RuntimeException(\"No document to set active before closing\");", "+    }", "+  }"]}], "num": 28287}