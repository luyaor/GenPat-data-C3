{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "847751f37921d40682e582477ee504db", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8064b59e31d6cd08c7d7c07187e7ab85", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/AdvancedLevelTest.java", "commitBeforeChange": "e17ce492a90f16c44e47a7ccfb4b5860ab80d4db", "commitAfterChange": "4df0ed95b0ba954b76dde43842a3396880fb20d5", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "   public void testShouldBeErrors()", "signatureAfterChange": "   public void testShouldBeErrors()", "diff": ["-    LanguageLevelConverter llc = new LanguageLevelConverter();", "+    boolean accum = true;", "+      // need to create a new LLC for every file we compile as a test", "+      // otherwise the failures from the previous file will count towards the current", "+      LanguageLevelConverter llc = new LanguageLevelConverter();", "-      assertTrue(\"should be parse exceptions or visitor exceptions\", !result.getFirst().isEmpty() || !result.getSecond().isEmpty());", "+      boolean err = !result.getFirst().isEmpty() || !result.getSecond().isEmpty();", "+      if (!err) {", "+        System.out.println(\"Unexpectedly converted without errors: \"+testFiles[i]);", "+      }", "+      accum &= err;", "+    assertTrue(\"should be parse exceptions or visitor exceptions\", accum);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bcecddd59d57e56fdbc1c1aa33ec4025", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/newjvm/MainJVM.java", "commitBeforeChange": "ab54ffeb9782712c65269bca65fea798aa2c5712", "commitAfterChange": "beead1fa2c7ee24ed59761a6b295b4aa1355139e", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 5, "signatureBeforeChange": "   protected void handleSlaveQuit(int status)", "signatureAfterChange": "   protected void handleSlaveQuit(int status)", "diff": ["+   */", "+  protected void handleSlaveQuit(int status) {", "+    debug.logValue(\"Slave quit\", \"status\", status);", "+    boolean wasRestarting;", "+    boolean doRestart;", "+    synchronized (_startupLock) {", "+      wasRestarting = _cleanlyRestarting;", "+      _cleanlyRestarting = false;", "+      doRestart = _restart;", "+      _interpreterJVM.set(null);", "+    }", "+    if (!wasRestarting) { _interactionsModel.replCalledSystemExit(status); }", "+    if (doRestart) {", "+      // We have already fired this event if we are cleanly restarting", "+      if (!wasRestarting) { _interactionsModel.interpreterResetting(); }", "+      startInterpreterJVM();", "+    }", "+  }", "-    */", "-  protected void handleSlaveQuit(int status) {", "-    debug.logStart();", "-    // Only restart the slave if _restart is true", "-//    Utilities.showDebug(\"MainJVM: slaveJVM has quit with status \" + status + \" _workDir = \" + _workDir + ", "-//      \" _cleanlyRestarting = \" + _cleanlyRestarting);", "-    if (_restart) {", "-      // We have already fired this event if we are cleanly restarting", "-      if (! _cleanlyRestarting) _interactionsModel.interpreterResetting();", "-//      Utilities.showDebug(\"MainJVM: calling startInterpreterJVM()\");", "-      startInterpreterJVM();", "-    if (!_cleanlyRestarting) _interactionsModel.replCalledSystemExit(status);", "-    _cleanlyRestarting = false;", "-    debug.logEnd();"]}], "num": 3093}