{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "14849060f62475871672ef7bf23cec09", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a5a12c05684a74a05cdda4d97e600fc", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/FindReplaceMachine.java", "commitBeforeChange": "db8f0cb26e31432f350747ff5cceb39c84bddf2e", "commitAfterChange": "09ee5df535fa7711165b559136b85b4d08379671", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 33, "signatureBeforeChange": "   private FindResult _findNextInAllDocs(AbstractDocumentInterface docToSearch, int start, int end) throws BadLocationException", "signatureAfterChange": "   private FindResult      _findNextInDocSegment(OpenDefinitionsDocument doc, int start, int len, boolean wrapped, boolean allWrapped)", "diff": ["+  private FindResult ", "+    _findNextInDocSegment(OpenDefinitionsDocument doc, int start, int len, boolean wrapped, boolean allWrapped) {  ", "+//    Utilities.show(\"called _findNextInDocSegment(\" + doc.getText() + \",\\n\" + start + \", \" + len + \", \" + wrapped + \" ...)\");", "+    ", "+    if (len == 0 || doc.getLength() == 0) return new FindResult(doc, -1, wrapped, allWrapped);", "+    ", "+    int docLen;     // The length of the segment to be searched", "+    String text;    // The text segment to be searched", "+    ", "+    String findWord = _findWord;       // copy of word being searched (so it can converted to lower case if necessary", "+    int wordLen = findWord.length();   // length of search key (word being searched fo  ", "+    ", "+    doc.readLock();", "+    try { ", "+      docLen = doc.getLength();", "+//      if (wrapped && allWrapped) Utilities.show(start +\", \" + len + \", \" + docLen + \", doc = '\" + doc.getText() + \"'\");", "+      text = doc.getText(start, len);", "+      ", "+      if (! _matchCase) {", "+        text = text.toLowerCase();", "+        findWord = findWord.toLowerCase();  // does not affect wordLen", "+      }", "+      ", "+//       if (wrapped && allWrapped) Utilities.show(\"Executing loop with findWord = \" + findWord + \"; text = \" + text + \"; len = \" + len);     ", "+      ", "+      // loop to find first valid (not ignored) occurrence of findWord", "+      // loop carried variables are text, len, start; ", "+      // loop invariant variables are _doc, docLen, _isForward, findWord, wordLen.", "+      // On forward search, (start + len) is invariant; on backward search start is invariant.", "+      // loop exits by returning match (as FindResult) or by falling through with no match.", "+      // if match is returned, _current has been updated to match location", "+      while (len >= wordLen) {", "+        // Find next match in text", "+        int foundOffset = _isForward ? text.indexOf(findWord) : text.lastIndexOf(findWord);", "+        if (foundOffset < 0) break;  // no valid match in this document", "+        ", "+        int foundLocation = start + foundOffset;", "+        int matchLocation;", "+        ", "+        if (_isForward) {", "+          int adjustedOffset = foundOffset + wordLen;", "+          start += adjustedOffset;                       // start is moved to match", "+          text = text.substring(adjustedOffset, len);    // len is length of text before update", "+          len = len - adjustedOffset;                    // len is updated to length of text after update", "+          matchLocation = start;                         // matchLocation is index in _doc of right edge of match", "+//            _current = docToSearch.createPosition(start);          // put caret at beginning of found word", "+        }", "+        else {", "+          len = foundOffset;                             // start is left invariant; len is moved to match", "+          matchLocation = start + foundOffset;           // matchLocation is index in _doc of left edge of match", "+          text = text.substring(0, len);                 // len is length of text after update", "+//            _current = docToSearch.createPosition(foundLocation);  // put caret at end of found word", "+        doc.setCurrentLocation(foundLocation);           // _shouldIgnore below uses reduced model", "+//        Utilities.show(\"Finished iteration with text = \" + text + \"; len = \" + len);", "+        if (_shouldIgnore(foundLocation, doc)) continue;", "+        _current = doc.createPosition(matchLocation);   ", "+//        System.err.println(\"Returning result = \" + new FindResult(doc, matchLocation, wrapped, allWrapped));", "+        return new FindResult(doc, matchLocation, wrapped, allWrapped);  // return valid match", "+    finally { doc.readUnlock(); }", "+    ", "+    // loop fell through; search failed in doc segment", "+    return new FindResult(doc, -1, wrapped, allWrapped);", "-  private FindResult _findNextInAllDocs(AbstractDocumentInterface docToSearch, int start, int end) throws BadLocationException {", "-    boolean stillSearching = true;", "-    while(stillSearching) {", "-      stillSearching = false;", "-      _checkAllDocsWrapped = true;    ", "-      while (docToSearch != _doc) {", "-        if (docToSearch == _firstDoc) {", "-          _allDocsWrapped = true;", "-          _checkAllDocsWrapped = false;", "-        }", "-        ", "-        String text;", "-        int docLen;", "-        docToSearch.acquireReadLock();", "-        try { ", "-          docLen = docToSearch.getLength();", "-          text = docToSearch.getText(start, end);", "-        }", "-        finally { docToSearch.releaseReadLock(); }", "-        String findWord = _findWord;", "-        if (!_matchCase) {", "-          text = text.toLowerCase();", "-          findWord = findWord.toLowerCase();", "-        }", "-        int foundOffset = !_searchBackwards ? text.indexOf(findWord) : text.lastIndexOf(findWord);", "-        if (foundOffset >= 0) {", "-          int locationToIgnore = start + foundOffset;", "-          _model.getODDForDocument(docToSearch).setCurrentLocation(locationToIgnore);", "-          if (_shouldIgnore(locationToIgnore, docToSearch)) {", "-            foundOffset += start;", "-            if (!_searchBackwards) {", "-              foundOffset += findWord.length();", "-              _current = _doc.createPosition(foundOffset);", "-              start = foundOffset;", "-              end = docLen-foundOffset;", "-              stillSearching = true;", "-              break;", "-              // return _findNextInAllDocs(docToSearch, foundOffset, docLen-foundOffset);", "-            }", "-            _current = _doc.createPosition(foundOffset);", "-            end = foundOffset-start;", "-            stillSearching = true;", "-            break;", "-            // return _findNextInAllDocs(docToSearch, start, foundOffset-start);", "-          }       ", "-          ", "-          // We found it in a different document, put the caret at the end of the found word (if we're going forward).", "-          foundOffset += start;", "-          if (!_searchBackwards) foundOffset += findWord.length();", "-          return new FindResult(docToSearch, foundOffset, false, _allDocsWrapped);", "-        }", "-        docToSearch = !_searchBackwards ? _docIterator.getNextDocument(docToSearch) :", "-          _docIterator.getPrevDocument(docToSearch);", "-        start = 0;", "-        end = docToSearch.getLength();", "-      }", "-    return new FindResult(docToSearch, -1, false, _allDocsWrapped);", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c6566a1d6c3f5f427c0c2c06f8ee93e7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/FindReplaceMachine.java", "commitBeforeChange": "e7660fffdb51451a3d4a61981945f6529addb874", "commitAfterChange": "ceeb43b0cd71a090481b6c99329a86882de7136d", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 40, "signatureBeforeChange": "   private FindResult _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len,                                             final boolean wrapped, final boolean allWrapped)", "signatureAfterChange": "   private FindResult _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len,                                             final boolean wrapped, final boolean allWrapped)", "diff": ["+    boolean inTestCase = (_doc.getFileName().endsWith(\"Test.java\"));", "-    final int docLen = doc.getLength();;     // The length of the segment to be searched", "-    final int wordLen = _findWord.length();   // length of search key (word being searched for)", "-    ", "-    assert (start >= 0 && start <= docLen) && (len >= 0 && len <= docLen);", "-    ", "-    if (len == 0 || docLen == 0) return new FindResult(doc, -1, wrapped, allWrapped);", "-    ", "-    if (start + len > docLen) len = docLen - start;", "-    ", "+    if (!_ignoreTestCases || !inTestCase) {", "+      final int docLen = doc.getLength();;     // The length of the segment to be searched", "+      final int wordLen = _findWord.length();   // length of search key (word being searched for)", "+      ", "+      assert (start >= 0 && start <= docLen) && (len >= 0 && len <= docLen);", "+      ", "+      if (len == 0 || docLen == 0) return new FindResult(doc, -1, wrapped, allWrapped);", "+      ", "+      if (start + len > docLen) len = docLen - start;", "+      ", "-    ", "-    String text;             // The text segment to be searched", "-    final String findWord;   // copy of word being searched (so it can converted to lower case if necessary", "-    ", "-    try { ", "+      String text;             // The text segment to be searched", "+      final String findWord;   // copy of word being searched (so it can converted to lower case if necessary", "+      ", "+      try { ", "+        ", "-      //doc.acquireReadLock(); ", "-      text = doc.getText(start, len);", "-      //finally { doc.releaseReadLock(); }", "-      ", "-      if (! _matchCase) {", "-        text = text.toLowerCase();", "-        findWord = _findWord.toLowerCase();  // does not affect wordLen", "-      }", "-      else findWord = _findWord;", "-//       if (wrapped && allWrapped) Utilities.show(\"Executing loop with findWord = \" + findWord + \"; text = \" + text + \"; len = \" + len);     ", "-      ", "-      // loop to find first valid (not ignored) occurrence of findWord", "-      // loop carried variables are rem, foundOffset; ", "-      // loop invariant variables are _doc, docLen, _isForward, findWord, wordLen, start, len.", "-      // Invariant:  on forwardsearch, foundOffset + rem == len; on backward search foundOffset == rem.", "-      // loop exits by returning match (as FindResult) or by falling through with no match.", "-      // if match is returned, _current has been updated to match location", "-      int foundOffset = _isForward? 0 : len;", "-      int rem = len;", "-//      _log.log(\"Starting search loop; text = '\" + text + \"' findWord = '\" + findWord + \"' forward? = \" + _isForward + \" rem = \" + rem + \" foundOffset = \" + foundOffset);", "-      while (rem >= wordLen) {", "+        //doc.acquireReadLock(); ", "+        text = doc.getText(start, len);", "+        //finally { doc.releaseReadLock(); }", "-        // Find next match in text", "-        foundOffset = _isForward ? text.indexOf(findWord, foundOffset) : text.lastIndexOf(findWord, foundOffset);", "-//        _log.log(\"foundOffset = \" + foundOffset);", "-        if (foundOffset < 0) break;  // no valid match in this document", "-        int foundLocation = start + foundOffset;", "-        int matchLocation;", "-        ", "-        if (_isForward) {", "-          foundOffset += wordLen;                          // skip over matched word", "-//          text = text.substring(adjustedOffset, len);    // len is length of text before update", "-          rem = len - foundOffset;                         // len is updated to length of remaining text to search", "-          matchLocation = foundLocation + wordLen;         // matchLocation is index in _doc of right edge of match", "-//            _current = docToSearch.createPosition(start);          // put caret at beginning of found word", "+        if (! _matchCase) {", "+          text = text.toLowerCase();", "+          findWord = _findWord.toLowerCase();  // does not affect wordLen", "-        else { ", "+        else findWord = _findWord;", "+//       if (wrapped && allWrapped) Utilities.show(\"Executing loop with findWord = \" + findWord + \"; text = \" + text + \"; len = \" + len);     ", "+        ", "+        // loop to find first valid (not ignored) occurrence of findWord", "+        // loop carried variables are rem, foundOffset; ", "+        // loop invariant variables are _doc, docLen, _isForward, findWord, wordLen, start, len.", "+        // Invariant:  on forwardsearch, foundOffset + rem == len; on backward search foundOffset == rem.", "+        // loop exits by returning match (as FindResult) or by falling through with no match.", "+        // if match is returned, _current has been updated to match location", "+        int foundOffset = _isForward? 0 : len;", "+        int rem = len;", "+//      _log.log(\"Starting search loop; text = '\" + text + \"' findWord = '\" + findWord + \"' forward? = \" + _isForward + \" rem = \" + rem + \" foundOffset = \" + foundOffset);", "+        while (rem >= wordLen) {", "-          foundOffset -= wordLen;                        // skip over matched word        ", "-          rem = foundOffset;                             // rem is adjusted to match foundOffset", "-          matchLocation = foundLocation;                 // matchLocation is index in _doc of left edge of match", "+          // Find next match in text", "+          foundOffset = _isForward ? text.indexOf(findWord, foundOffset) : text.lastIndexOf(findWord, foundOffset);", "+//        _log.log(\"foundOffset = \" + foundOffset);", "+          if (foundOffset < 0) break;  // no valid match in this document", "+          int foundLocation = start + foundOffset;", "+          int matchLocation;", "+          ", "+          if (_isForward) {", "+            foundOffset += wordLen;                          // skip over matched word", "+//          text = text.substring(adjustedOffset, len);    // len is length of text before update", "+            rem = len - foundOffset;                         // len is updated to length of remaining text to search", "+            matchLocation = foundLocation + wordLen;         // matchLocation is index in _doc of right edge of match", "+//            _current = docToSearch.createPosition(start);          // put caret at beginning of found word", "+          }", "+          else { ", "+            ", "+            foundOffset -= wordLen;                        // skip over matched word        ", "+            rem = foundOffset;                             // rem is adjusted to match foundOffset", "+            matchLocation = foundLocation;                 // matchLocation is index in _doc of left edge of match", "-        }", "+          }", "-        ", "+          ", "-        assert foundLocation > -1;", "-        if (_shouldIgnore(foundLocation, doc)) continue;", "-        ", "-        //_current = doc.createPosition(matchLocation);   // formerly doc.createPosition(...)", "-        setPosition(matchLocation);", "-        ", "+          assert foundLocation > -1;", "+          if (_shouldIgnore(foundLocation, doc)) continue;", "+          ", "+          //_current = doc.createPosition(matchLocation);   // formerly doc.createPosition(...)", "+          setPosition(matchLocation);", "+          ", "-        ", "-        return new FindResult(doc, matchLocation, wrapped, allWrapped);  // return valid match", "+          ", "+          return new FindResult(doc, matchLocation, wrapped, allWrapped);  // return valid match", "+        }", "-    }", "-    catch (BadLocationException e) { throw new UnexpectedException(e); }", "-    ", "+      catch (BadLocationException e) { throw new UnexpectedException(e); }", "+    }      "]}], "num": 17894}