{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2d051fa78ea8c2f56065fb8dc2eec9ee", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "051760dd38243e1e42950df3c1564239", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractGlobalModel.java", "commitBeforeChange": "b555b0cfcc7bbb9f082899ce815305f8a985343e", "commitAfterChange": "aafaf7b848d738e58eee48a6cbc4b800c8027685", "methodNumberBeforeChange": 210, "methodNumberAfterChange": 212, "signatureBeforeChange": "     public boolean saveFile(FileSaveSelector com) throws IOException", "signatureAfterChange": "     public boolean saveFile(FileSaveSelector com) throws IOException", "diff": ["-      FileSaveSelector realCommand;", "-      final File file;", "+//      System.err.println(\"saveFile called on \" + this);", "+//      System.err.println(this + \" is untitled? \" + isUntitled());", "+      if (isUntitled()) return saveFileAs(com);", "-      if (!isModifiedSinceSave() && !isUntitled()) return true;", "-        // Don't need to save; return true, since the save wasn't \"canceled\"", "+      if (! isModifiedSinceSave()) return true;", "+      // Didn't need to save since file is named and unmodified; return true, since the save wasn't \"canceled\"", "+      FileSaveSelector realCommand = com;", "-        if (isUntitled()) realCommand = com;", "-        else", "-          try {", "-          file = getFile();", "+        final File file = getFile();", "+//        System.err.println(\"file name for doc to be saved is: \" + file);", "+        if (file != null) {", "+//          System.err.println(\"TrivialFSS set up\");", "-        catch (FileMovedException fme) {", "-          // getFile() failed, prompt the user if a new one should be selected", "-          if (com.shouldSaveAfterFileMoved(this, fme.getFile())) realCommand = com;", "-          else return false;", "-            // User declines to save as a new file, so don't save ", "-        }", "-        return saveFileAs(realCommand);", "-      catch (IllegalStateException ise) {", "-        // No file--  this should have been caught by isUntitled()", "-        throw new UnexpectedException(ise);", "+      catch (FileMovedException fme) {", "+        // getFile() failed, prompt the user if a new one should be selected", "+        if (com.shouldSaveAfterFileMoved(this, fme.getFile())) realCommand = com;", "+        else return false;", "+        // User declines to save as a new file, so don't save ", "+//      System.err.println(\"Calling saveFileAs\");", "+      return saveFileAs(realCommand);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5ef7c599d357545bee1fa68f5e031eb3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/BodyTypeChecker.java", "commitBeforeChange": "dd97c2983de18f5d46f596ce3c536a3b581f0ec4", "commitAfterChange": "e5b59097570657040bcd74f7a31c6db7f03359ce", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "   public TypeData forSwitchStatement(SwitchStatement that)", "signatureAfterChange": "   public TypeData forSwitchStatement(SwitchStatement that)", "diff": ["-            if (labels.contains(toCheck)) {", "+            if (labels.contains(toCheck))", "-            }", "-            else {", "-              labels.add(toCheck);", "-            }", "+            else labels.add(toCheck);", "-        if (seenDefault) {", "-          _addError(\"A switch statement can only have one default case\", sc);", "-        }", "+        if (seenDefault) _addError(\"A switch statement can only have one default case\", sc);", "-      //compare the variables assigned, and let variablesAssigned store the variables that have been assigned in every case ", "-      // that returns or breaks up to this one and are also assigned in this one", "+      // Compare the variables assigned, and let variablesAssigned store the variables that have been assigned in every ", "+      // case that returns or breaks up to this one and are also assigned in this one", "-        if (!hadCaseReturn) {", "+        if (! hadCaseReturn) {", "-", "-", "-      for (VariableData vd : variablesAssigned) {", "-        vd.gotValue();", "-      }", "+      for (VariableData vd : variablesAssigned) vd.gotValue();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "772e12d863555382abb54b995c6cab18", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "e1389ddb9dcb8a7d3a230cc1be322481e1c8fd6a", "commitAfterChange": "77b08b2c2aecee48e010895d99d03539a1aa19da", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "diff": ["+        if (filesNotToCheck.contains(f)) continue;  // Detects equal files; earlier code versions claimed it failed", "+        // Check for a null file", "-        if (firstLine == null) continue;", "+        if (firstLine == null) continue;", "-        /* If the file has the correct suffix, then parse it. Ignore files in filesNotToCheck.  contains on ", "-         * filesNotToCheck failed to return desired result. So it is done manually, matching AbsolutePath. */", "-//        boolean foundFile = false;", "-        ", "-        for (File fntc: files) {", "-          if (fntc.getAbsolutePath().equals(f.getAbsolutePath())) {", "-//            foundFile = true;", "-            break;", "-          }", "-        }", "-        ", "-        if (_isLanguageLevelFile(f) /* && ! foundFile*/) {", "+        if (_isLanguageLevelFile(f)) {", "-//          File f = files[ind];", "-          //Now create a LanguageLevelVisitor to do the first pass over the file.", "+          // Now create a LanguageLevelVisitor to do the first pass over the file."]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "89388b0ef4979d7fb0a49263c37e7513", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "688e157c7573e27d29048be4b5c2986e80d14e52", "commitAfterChange": "b8ed4d4bbe5cb36f7fb86bf02c301a4f948a603e", "methodNumberBeforeChange": 47, "methodNumberAfterChange": 47, "signatureBeforeChange": "     public void runMain() throws ClassNameNotFoundException, IOException", "signatureAfterChange": "     public void runMain() throws ClassNameNotFoundException, IOException", "diff": ["+        private boolean alreadyRun = false;", "+          // prevent listener from running twice", "+          if (alreadyRun) return; else alreadyRun = true;", "-          SwingUtilities.invokeLater(new Runnable() {", "-            public void run() { ", "-              /* Remove _runMain listener AFTER this interpreterReady listener completes and DROPS it acquireReadLock on", "-               * _interactionsModel._notifier. */", "-              _interactionsModel.removeListener(_runMain);", "-            }", "-          });", "+          // This used to be called using invokeLater, so that the listener would be removed", "+          // after the read lock of the notifier had been released, but that was not always", "+          // safe; the removal could still happen before the read lock was released", "+          // Now removeListener has been rewritten and can be called even when the lock is", "+          // held. In that case, the removal will be done as soon as possible.", "+          _interactionsModel.removeListener(_runMain);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8eeb8ca4b7b57a8f5149975234eb9b1e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "plt/src/edu/rice/cs/plt/iter/ComposedIterable.java", "commitBeforeChange": "274f7defc49003e66c942e814c9ce22958b3814c", "commitAfterChange": "f2730b22a0cb99532fc26d3fe0cc1ef03dc2fb33", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "   public ComposedIterable(Iterable<? extends T> i1, Iterable<? extends T> i2)", "signatureAfterChange": "   public ComposedIterable(Iterable<? extends T> i1, Iterable<? extends T> i2)", "diff": ["-    ", "-    if (IterUtil.isFixed(i1)) {", "-      if (IterUtil.isFixed(i2)) {", "-        _fixed = true;", "-        _size = LambdaUtil.valueThunk(IterUtil.sizeOf(_i1) + IterUtil.sizeOf(_i2));", "-      }", "-      else {", "-        _fixed = false;", "-        final int size1 = IterUtil.sizeOf(_i1);", "-        _size = new Thunk<Integer>() { ", "-          public Integer value() { return size1 + IterUtil.sizeOf(_i2); }", "-        };", "-      }", "-    }", "-    else if (IterUtil.isFixed(i2)) {", "-      _fixed = false;", "-      final int size2 = IterUtil.sizeOf(_i2);", "-      _size = new Thunk<Integer>() {", "-        public Integer value() { return IterUtil.sizeOf(_i1) + size2; }", "-      };", "-    }", "-    else {", "-      _fixed = false;", "-      _size = new Thunk<Integer>() {", "-        public Integer value() { return IterUtil.sizeOf(_i1) + IterUtil.sizeOf(_i2); }", "-      };", "-    }", "+    if (IterUtil.isFixed(i1)) { _i1Size = IterUtil.sizeOf(_i1); }", "+    else { _i1Size = -1; }", "+    if (IterUtil.isFixed(i2)) { _i2Size = IterUtil.sizeOf(_i2); }", "+    else { _i2Size = -1; }"]}], "num": 11892}