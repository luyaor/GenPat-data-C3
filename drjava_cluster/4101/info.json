{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d28dd52f66297c63e5ab46dc371b625b", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1a5780a71530d1b72c9d96080c9abab8", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/TreeInterpreter.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": "     protected Object interpretMethod(Class c, \t\t\t\t   MethodDescriptor md, \t\t\t\t   Object obj, \t\t\t\t   Object[] params)", "signatureAfterChange": "   protected Object interpretMethod(Class c,                                    MethodDescriptor md,                                    Object obj,                                    Object[] params)", "diff": ["+   */", "+  protected Object interpretMethod(Class c,", "+                                   MethodDescriptor md,", "+                                   Object obj,", "+                                   Object[] params) {", "+    MethodDeclaration        meth = md.method;", "+    List<FormalParameter> mparams = meth.getParameters();", "+    List<Node>              stmts = meth.getBody().getStatements();", "+    String                   name = meth.getName();", "+    Context               context = null;", "+    if (Modifier.isStatic(md.method.getAccessFlags())) {", "+      if (md.variables == null) {", "+        md.importationManager.setClassLoader(classLoader);", "+        ", "+        // pass 1: names resolution", "+        Context ctx = new StaticContext(this, c, md.importationManager);", "+        ctx.setAdditionalClassLoaderContainer(classLoader);", "+        NameVisitor nv = new NameVisitor(ctx);", "+        ", "+        ListIterator<FormalParameter> it1 = mparams.listIterator();", "+        while (it1.hasNext()) {", "+          it1.next().acceptVisitor(nv);", "+        }", "+        ", "+        ListIterator<Node> it2 = stmts.listIterator();", "+        while (it2.hasNext()) {", "+          Node o = it2.next().acceptVisitor(nv);", "+          if (o != null) it2.set(o);", "+        }", "+        ", "+        // pass 2: type checking", "+        ctx = new StaticContext(this, c, md.importationManager);", "+        ctx.setAdditionalClassLoaderContainer(classLoader);", "+        TypeChecker tc = new TypeChecker(ctx);", "+        ", "+        it1 = mparams.listIterator();", "+        while (it1.hasNext()) {", "+          it1.next().acceptVisitor(tc);", "+        }", "+        ", "+        it2 = stmts.listIterator();", "+        while (it2.hasNext()) {", "+          it2.next().acceptVisitor(tc);", "+        }", "+        ", "+        md.variables = ctx.getCurrentScopeVariables();", "+        ", "+        // Test of the additional context existence", "+        if (!name.equals(\"<clinit>\") &&", "+            !name.equals(\"<init>\")) {", "+          try {", "+            md.contextField = c.getField(\"local$Variables$Reference$0\");", "+          } catch (NoSuchFieldException e) {", "+          }", "+        }", "+      }", "+      ", "+      // pass 3: evaluation", "+      context = new StaticContext(this, c, md.variables);", "+    } else {", "+      if (md.variables == null) {", "+        md.importationManager.setClassLoader(classLoader);", "+        ", "+        // pass 1: names resolution", "+        Context ctx1 = new MethodContext(this, c, c, md.importationManager);", "+        ctx1.setAdditionalClassLoaderContainer(classLoader);", "+        NameVisitor nv1 = new NameVisitor(ctx1);", "+        ", "+        Context ctx2 = new MethodContext(this, c, c, md.importationManager);", "+        ctx2.setAdditionalClassLoaderContainer(classLoader);", "+        NameVisitor nv2 = new NameVisitor(ctx2);", "+        ", "+        // Initializes the context with the outerclass variables", "+        Object[][] cc = null;", "+          Field f = c.getField(\"local$Variables$Class$0\");", "+          cc = (Object[][])f.get(obj);", "+          for (int i = 0; i < cc.length; i++) {", "+            Object[] cell = cc[i];", "+            if (!((String)cell[0]).equals(\"this\")) {", "+              ctx1.defineConstant((String)cell[0], cell[1]);", "+          }", "+        } catch (Exception e) {", "+        ", "+        // Visit the parameters and the body of the method", "+        ListIterator<FormalParameter> it1 = mparams.listIterator();", "+        while (it1.hasNext()) {", "+          it1.next().acceptVisitor(nv1);", "+        }", "+        ", "+        ListIterator<Node> it2 = stmts.listIterator();", "+        while (it2.hasNext()) {", "+          Node n = it2.next();", "+          Node o = null;", "+          if (n.hasProperty(NodeProperties.INSTANCE_INITIALIZER)) {", "+            o = n.acceptVisitor(nv2);", "+          } else {", "+            o = n.acceptVisitor(nv1);", "+          }", "+          if (o != null) it2.set(o);", "+        }", "+        ", "+        // pass 2: type checking", "+        ctx1 = new MethodContext(this, c, c, md.importationManager);", "+        ctx1.setAdditionalClassLoaderContainer(classLoader);", "+        TypeChecker tc1 = new TypeChecker(ctx1);", "+        ", "+        ctx2 = new MethodContext(this, c, c, md.importationManager);", "+        ctx2.setAdditionalClassLoaderContainer(classLoader);", "+        TypeChecker tc2 = new TypeChecker(ctx2);", "+        ", "+        // Initializes the context with outerclass variables", "+        if (cc != null) {", "+          for (int i = 0; i < cc.length; i++) {", "+            Object[] cell = cc[i];", "+            if (!((String)cell[0]).equals(\"this\")) {", "+              ctx1.defineConstant((String)cell[0], cell[1]);", "+            }", "+          }", "+        }", "+        ", "+        // Visit the parameters and the body of the method", "+        it1 = mparams.listIterator();", "+        while (it1.hasNext()) {", "+          it1.next().acceptVisitor(tc1);", "+        }", "+        ", "+        it2 = stmts.listIterator();", "+        while (it2.hasNext()) {", "+          Node n = (Node)it2.next();", "+          if (n.hasProperty(NodeProperties.INSTANCE_INITIALIZER)) {", "+            n.acceptVisitor(tc2);", "+          } else {", "+            n.acceptVisitor(tc1);", "+          }", "+        }", "+        ", "+        md.variables = ctx1.getCurrentScopeVariables();", "+        ", "+        // Test of the additional context existence", "+        if (!name.equals(\"<clinit>\") &&", "+            !name.equals(\"<init>\")) {", "+          try {", "+            md.contextField = c.getField(\"local$Variables$Reference$0\");", "+          } catch (NoSuchFieldException e) {", "+          }", "+        }", "+      }", "+      ", "+      // pass 3: evaluation", "+      context = new MethodContext(this, c, obj, md.variables);", "+    context.setAdditionalClassLoaderContainer(classLoader);", "+    ", "+    // Set the arguments values", "+    Iterator<FormalParameter> it1  = mparams.iterator();", "+    int i = 0;", "+    while (it1.hasNext()) {", "+      context.set(it1.next().getName(), params[i++]);", "+    // Set the final local variables values", "+    if (md.contextField != null) {", "+      Map vars = null;", "+      try {", "+        vars = (Map)md.contextField.get(obj);", "+      } catch (IllegalAccessException e) {", "+      }", "+      if (vars != null) {", "+        Iterator it2 = vars.keySet().iterator();", "+        while (it2.hasNext()) {", "+          String s = (String) it2.next();", "+          if (!s.equals(\"this\")) {", "+            context.setConstant(s, vars.get(s));", "+          }", "+      }", "-     */", "-    protected Object interpretMethod(Class c,", "-\t\t\t\t   MethodDescriptor md,", "-\t\t\t\t   Object obj,", "-\t\t\t\t   Object[] params) {", "-\tMethodDeclaration meth    = md.method;", "-\tList              mparams = meth.getParameters();", "-\tList              stmts   = meth.getBody().getStatements();", "-\tString            name    = meth.getName();", "-", "-\tContext           context = null;", "-", "-\tif (Modifier.isStatic(md.method.getAccessFlags())) {", "-\t    if (md.variables == null) {", "-\t\tmd.importationManager.setClassLoader(classLoader);", "-", "-\t\t// pass 1: names resolution", "-\t\tContext ctx = new StaticContext(this, c, md.importationManager);", "-\t\tctx.setAdditionalClassLoaderContainer(classLoader);", "-\t\tVisitor v = new NameVisitor(ctx);", "-", "-\t\tListIterator it = mparams.listIterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    ((Node)it.next()).acceptVisitor(v);", "-\t\t}", "-", "-\t\tit = stmts.listIterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    Object o = ((Node)it.next()).acceptVisitor(v);", "-\t\t    if (o != null) {", "-\t\t\tit.set(o);", "-\t\t    }", "-\t\t}", "-", "-\t\t// pass 2: type checking", "-\t\tctx = new StaticContext(this, c, md.importationManager);", "-\t\tctx.setAdditionalClassLoaderContainer(classLoader);", "-\t\tv = new TypeChecker(ctx);", "-", "-\t\tit = mparams.listIterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    ((Node)it.next()).acceptVisitor(v);", "-\t\t}", "-", "-\t\tit = stmts.listIterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    ((Node)it.next()).acceptVisitor(v);", "-\t\t}", "-", "-\t\tmd.variables = ctx.getCurrentScopeVariables();", "-", "-\t\t// Test of the additional context existence", "-\t\tif (!name.equals(\"<clinit>\") &&", "-\t\t    !name.equals(\"<init>\")) {", "-\t\t    try {", "-\t\t\tmd.contextField = c.getField(\"local$Variables$Reference$0\");", "-\t\t    } catch (NoSuchFieldException e) {", "-\t\t    }", "-\t\t}", "-\t    }", "-", "-\t    // pass 3: evaluation", "-\t    context = new StaticContext(this, c, md.variables);", "-\t} else {", "-\t    if (md.variables == null) {", "-\t\tmd.importationManager.setClassLoader(classLoader);", "-", "-\t\t// pass 1: names resolution", "-\t\tContext ctx = new MethodContext(this, c, c, md.importationManager);", "-\t\tctx.setAdditionalClassLoaderContainer(classLoader);", "-\t\tVisitor v = new NameVisitor(ctx);", "-", "-\t\tContext ctx2 = new MethodContext(this, c, c, md.importationManager);", "-\t\tctx2.setAdditionalClassLoaderContainer(classLoader);", "-\t\tVisitor v2 = new NameVisitor(ctx2);", "-", "-\t\t// Initializes the context with the outerclass variables", "-\t\tObject[][] cc = null;", "-                try {", "-                    Field f = c.getField(\"local$Variables$Class$0\");", "-                    cc = (Object[][])f.get(obj);", "-                    for (int i = 0; i < cc.length; i++) {", "-                        Object[] cell = cc[i];", "-\t\t\tif (!((String)cell[0]).equals(\"this\")) {", "-\t\t\t    ctx.defineConstant((String)cell[0], cell[1]);", "-\t\t\t}", "-                    }", "-                } catch (Exception e) {", "-                }", "- ", "-\t\t// Visit the parameters and the body of the method", "-\t\tListIterator it = mparams.listIterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    ((Node)it.next()).acceptVisitor(v);", "-\t\t}", "-", "-\t\tit = stmts.listIterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    Node n = (Node)it.next();", "-\t\t    Object o = null;", "-\t\t    if (n.hasProperty(NodeProperties.INSTANCE_INITIALIZER)) {", "-\t\t\to = n.acceptVisitor(v2);", "-\t\t    } else {", "-\t\t\to = n.acceptVisitor(v);", "-\t\t    }", "-\t\t    if (o != null) {", "-\t\t\tit.set(o);", "-\t\t    }", "-\t\t}", "-", "-\t\t// pass 2: type checking", "-\t\tctx = new MethodContext(this, c, c, md.importationManager);", "-\t\tctx.setAdditionalClassLoaderContainer(classLoader);", "-\t\tv = new TypeChecker(ctx);", "-", "-\t\tctx2 = new MethodContext(this, c, c, md.importationManager);", "-\t\tctx2.setAdditionalClassLoaderContainer(classLoader);", "-\t\tv2 = new TypeChecker(ctx2);", "-", "-\t\t// Initializes the context with outerclass variables", "-\t\tif (cc != null) {", "-                    for (int i = 0; i < cc.length; i++) {", "-                        Object[] cell = cc[i];", "-\t\t\tif (!((String)cell[0]).equals(\"this\")) {", "-\t\t\t    ctx.defineConstant((String)cell[0], cell[1]);", "-\t\t\t}", "-                    }", "-                }", "-\t\t", "-\t\t// Visit the parameters and the body of the method", "-\t\tit = mparams.listIterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    ((Node)it.next()).acceptVisitor(v);", "-\t\t}", "-", "-\t\tit = stmts.listIterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    Node n = (Node)it.next();", "-\t\t    if (n.hasProperty(NodeProperties.INSTANCE_INITIALIZER)) {", "-\t\t\tn.acceptVisitor(v2);", "-\t\t    } else {", "-\t\t\tn.acceptVisitor(v);", "-\t\t    }", "-\t\t}", "-", "-\t\tmd.variables = ctx.getCurrentScopeVariables();", "-", "-\t\t// Test of the additional context existence", "-\t\tif (!name.equals(\"<clinit>\") &&", "-\t\t    !name.equals(\"<init>\")) {", "-\t\t    try {", "-\t\t\tmd.contextField = c.getField(\"local$Variables$Reference$0\");", "-\t\t    } catch (NoSuchFieldException e) {", "-\t\t    }", "-\t\t}", "-\t    }", "-", "-\t    // pass 3: evaluation", "-\t    context = new MethodContext(this, c, obj, md.variables);", "-\t}", "-", "-\tcontext.setAdditionalClassLoaderContainer(classLoader);", "-", "-\t// Set the arguments values", "-\tIterator it  = mparams.iterator();", "-\tint      i   = 0;", "-\twhile (it.hasNext()) {", "-\t    context.set(((FormalParameter)it.next()).getName(), params[i++]);", "-\t}", "-", "-\t// Set the final local variables values", "-\tif (md.contextField != null) {", "-\t    Map vars = null;", "-\t    try {", "-\t\tvars = (Map)md.contextField.get(obj);", "-\t    } catch (IllegalAccessException e) {", "-\t    }", "-\t    if (vars != null) {", "-\t\tit = vars.keySet().iterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    String s = (String)it.next();", "-\t\t    if (!s.equals(\"this\")) {", "-\t\t\tcontext.setConstant(s, vars.get(s));", "-\t\t    }", "-\t\t}", "-\t    }", "-\t}", "-", "-\tVisitor v = new EvaluationVisitor(context);", "-\tit = stmts.iterator();", "-\t    ", "-\ttry {", "-\t    while (it.hasNext()) {", "-\t\t((Node)it.next()).acceptVisitor(v);", "-\t    }", "-\t} catch (ReturnException e) {", "-\t    return e.getValue();", "-\t}", "-\treturn null;", "+    ", "+    EvaluationVisitor ev = new EvaluationVisitor(context);", "+    Iterator<Node> it3 = stmts.iterator();", "+    ", "+    try {", "+      while (it3.hasNext()) {", "+        it3.next().acceptVisitor(ev);", "+      }", "+    } catch (ReturnException e) {", "+      return e.getValue();", "+    return null;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "40b1b53efdabc82e9a7766b71ad31489", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/sourcechecker/CompilationUnitChecker.java", "commitBeforeChange": "e664df55ae0a7bd09b3050ad4027139ea59836cd", "commitAfterChange": "41fd33d17362a9b484003b73b5562d87a9b206fa", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 1, "signatureBeforeChange": "          private BodyChecker handleTypeDeclaration(TypeDeclaration node)", "signatureAfterChange": "   public Relation<TypeDeclaration, ClassChecker> extractDeclarations(CompilationUnit u) throws InterpreterException", "diff": ["+   */", "+  public Relation<TypeDeclaration, ClassChecker> extractDeclarations(CompilationUnit u) throws InterpreterException {", "+    TypeContext c = _context;", "+    PackageDeclaration pkg = u.getPackage();", "+    if (pkg != null) { c = c.setPackage(pkg.getName()); }", "+    List<CheckerException> errors = new LinkedList<CheckerException>();", "+    for (ImportDeclaration imp : u.getImports()) {", "+      try { c = imp.acceptVisitor(new StatementChecker(c, _opt)); }", "+      catch (ExecutionError e) { errors.add(new CheckerException(e)); }", "+    if (!errors.isEmpty()) { throw new CompositeException(errors); }", "+    ", "+    Relation<TypeDeclaration, ClassChecker> results = UnindexedRelation.makeLinkedHashBased();", "+    ClassLoader loader = _context.getClassLoader(); // assumes a single ClassLoader was used for all top-level classes ", "+    for (Node decl : u.getDeclarations()) {", "+      if (decl instanceof TypeDeclaration) {", "+        ClassChecker checker = new ClassChecker(NodeProperties.getDJClass(decl), loader, c, _opt);", "+        results.add(Pair.make((TypeDeclaration) decl, checker));", "+      }", "+      else { throw new RuntimeException(\"Unrecognized compilation unit declaration\"); }", "+    }", "+    return results;", "-    ", "-    private BodyChecker handleTypeDeclaration(TypeDeclaration node) {", "-      DJClass c = NodeProperties.getDJClass(node);", "-      ", "-      TypeContext sigContext = new ClassSignatureContext(_context, c, _context.getClassLoader());", "-      TypeNameChecker sigChecker = new TypeNameChecker(sigContext, _opt);", "-", "-      final TypeParameter[] tparams;", "-      if (node instanceof GenericClassDeclaration) {", "-        tparams = ((GenericClassDeclaration) node).getTypeParameters();", "-      }", "-      else if (node instanceof GenericInterfaceDeclaration) {", "-        tparams = ((GenericInterfaceDeclaration) node).getTypeParameters();", "-      }", "-      else { tparams = new TypeParameter[0]; }", "-      sigChecker.checkTypeParameters(tparams);", "-", "-      if (node instanceof ClassDeclaration) {", "-        sigChecker.check(((ClassDeclaration) node).getSuperclass());", "-      }", "-      if (node.getInterfaces() != null) {", "-        for (TypeName tn : node.getInterfaces()) { sigChecker.check(tn); }", "-      }", "-", "-      ClassMemberChecker classChecker = new ClassMemberChecker(new ClassContext(sigContext, c), _opt); ", "-      if (node instanceof InterfaceDeclaration) {", "-        classChecker.checkInterfaceSignatures(node.getMembers());", "-      }", "-      else {", "-        classChecker.checkClassSignatures(node.getMembers());", "-      }", "-      return new BodyChecker(classChecker, node.getMembers());", "-    }"]}], "num": 4101}