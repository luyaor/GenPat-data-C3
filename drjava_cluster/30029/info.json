{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f5bbad87bc90b999336f0168cb062fb2", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53d9c2568e9cbfa2564cb9a2950cf16e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/TypeChecker.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": "     public Object visit(ConditionalExpression node)", "signatureAfterChange": "   public Class visit(ConditionalExpression node)", "diff": ["+   */", "+  public Class visit(ConditionalExpression node) {", "+    // Check the condition", "+    if (node.getConditionExpression().acceptVisitor(this) != boolean.class) {", "+      throw new ExecutionError(\"condition.type\", node);", "+    }", "+    ", "+    // Determine the type of the expression", "+    Node  n1 = node.getIfTrueExpression();", "+    Node  n2 = node.getIfFalseExpression();", "+    Class c1 = (Class)n1.acceptVisitor(this);", "+    Class c2 = (Class)n2.acceptVisitor(this);", "+    Class ec = null;", "+    ", "+    if (c1 == c2) {", "+      ec = c1;", "+    } else if (c1 == null) {", "+      ec = c2;", "+    } else if (c2 == null) {", "+      ec = c1;", "+    } else if (!c1.isPrimitive() && !c2.isPrimitive()) {", "+      if (c1.isAssignableFrom(c2)) {", "+        ec = c1;", "+      } else if (c2.isAssignableFrom(c1)) {", "+        ec = c2;", "+      } else {", "+        throw new ExecutionError(\"incompatible.types\", node);", "+      }", "+    } else if (c1 == boolean.class || c2 == boolean.class ||", "+               c1 == void.class    || c2 == void.class) {", "+      throw new ExecutionError(\"incompatible.types\", node);", "+    } else if ((c1 == short.class && c2 == byte.class) ||", "+               (c1 == byte.class  && c2 == short.class)) {", "+      ec = short.class;", "+    } else if ((c2 == byte.class || c2 == short.class || c2 == char.class) &&", "+               n1.hasProperty(NodeProperties.VALUE) && c1 == int.class) {", "+      Number n = (Number)n1.getProperty(NodeProperties.VALUE);", "+      if (c2 == byte.class) {", "+        if (n.intValue() == n.byteValue()) {", "+          ec = byte.class;", "+        } else {", "+          ec = int.class;", "+      } else if (n.intValue() == n.shortValue()) {", "+        ec = (c2 == char.class) ? char.class : short.class;", "+      } else {", "+        ec = int.class;", "+      }", "+    } else if ((c1 == byte.class || c1 == short.class || c1 == char.class) &&", "+               n2.hasProperty(NodeProperties.VALUE) && c2 == int.class) {", "+      Number n = (Number)n2.getProperty(NodeProperties.VALUE);", "+      if (c1 == byte.class) {", "+        if (n.intValue() == n.byteValue()) {", "+          ec = byte.class;", "+        } else {", "+          ec = int.class;", "+      } else if (n.intValue() == n.shortValue()) {", "+        ec = (c1 == char.class) ? char.class : short.class;", "+      } else {", "+        ec = int.class;", "+      }       ", "+    } else if (c1 == double.class || c2 == double.class) {", "+      ec = double.class;", "+    } else if (c1 == float.class || c2 == float.class) {", "+      ec = float.class;", "+    } else if (c1 == long.class || c2 == long.class) {", "+      ec = long.class;", "+    } else {", "+      ec = int.class;", "+    }", "+    node.setProperty(NodeProperties.TYPE, ec);", "+    ", "+    return ec;", "+  }", "-     */", "-    public Object visit(ConditionalExpression node) {", "-        // Check the condition", "-        if (node.getConditionExpression().acceptVisitor(this) != boolean.class) {", "-            throw new ExecutionError(\"condition.type\", node);", "-        }", "-", "-        // Determine the type of the expression", "-        Node  n1 = node.getIfTrueExpression();", "-        Node  n2 = node.getIfFalseExpression();", "-        Class c1 = (Class)n1.acceptVisitor(this);", "-        Class c2 = (Class)n2.acceptVisitor(this);", "-        Class ec = null;", "-", "-        if (c1 == c2) {", "-            ec = c1;", "-        } else if (c1 == null) {", "-            ec = c2;", "-        } else if (c2 == null) {", "-            ec = c1;", "-        } else if (!c1.isPrimitive() && !c2.isPrimitive()) {", "-            if (c1.isAssignableFrom(c2)) {", "-                ec = c1;", "-            } else if (c2.isAssignableFrom(c1)) {", "-                ec = c2;", "-                throw new ExecutionError(\"incompatible.types\", node);", "-        } else if (c1 == boolean.class || c2 == boolean.class ||", "-                   c1 == void.class    || c2 == void.class) {", "-            throw new ExecutionError(\"incompatible.types\", node);", "-        } else if ((c1 == short.class && c2 == byte.class) ||", "-                   (c1 == byte.class  && c2 == short.class)) {", "-            ec = short.class;", "-        } else if ((c2 == byte.class || c2 == short.class || c2 == char.class) &&", "-                   n1.hasProperty(NodeProperties.VALUE) && c1 == int.class) {", "-            Number n = (Number)n1.getProperty(NodeProperties.VALUE);", "-            if (c2 == byte.class) {", "-                if (n.intValue() == n.byteValue()) {", "-                    ec = byte.class;", "-                } else {", "-                    ec = int.class;", "-                }", "-            } else if (n.intValue() == n.shortValue()) {", "-                ec = (c2 == char.class) ? char.class : short.class;", "-            } else {", "-                ec = int.class;", "-        } else if ((c1 == byte.class || c1 == short.class || c1 == char.class) &&", "-                   n2.hasProperty(NodeProperties.VALUE) && c2 == int.class) {", "-            Number n = (Number)n2.getProperty(NodeProperties.VALUE);", "-            if (c1 == byte.class) {", "-                if (n.intValue() == n.byteValue()) {", "-                    ec = byte.class;", "-                } else {", "-                    ec = int.class;", "-                }", "-            } else if (n.intValue() == n.shortValue()) {", "-                ec = (c1 == char.class) ? char.class : short.class;", "-            } else {", "-                ec = int.class;", "-            }       ", "-        } else if (c1 == double.class || c2 == double.class) {", "-            ec = double.class;", "-        } else if (c1 == float.class || c2 == float.class) {", "-            ec = float.class;", "-        } else if (c1 == long.class || c2 == long.class) {", "-            ec = long.class;", "-        } else {", "-            ec = int.class;", "-        }", "-        node.setProperty(NodeProperties.TYPE, ec);", "-", "-        return ec;", "-    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5697860b20b52e9fc7c290d6558cab09", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/TypeChecker.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "     public Object visit(SwitchStatement node)", "signatureAfterChange": "   public Class visit(SwitchStatement node)", "diff": ["+   */", "+  public Class visit(SwitchStatement node) {", "+    // Visits the components of this node", "+    Class c = (Class)node.getSelector().acceptVisitor(this);", "+    if (c != char.class && c != byte.class && c != short.class && c != int.class) {", "+      node.setProperty(NodeProperties.ERROR_STRINGS,", "+                       new String[] { c.getName() });", "+      throw new ExecutionError(\"selector.type\", node);", "+    }", "+    ", "+    // Check the type of the case labels", "+    Iterator it = node.getBindings().iterator();", "+    while (it.hasNext()) {", "+      SwitchBlock sb = (SwitchBlock)it.next();", "+      sb.acceptVisitor(this);", "+      Expression exp = sb.getExpression();", "+      if (exp != null) {", "+        Class lc = NodeProperties.getType(exp);", "+        if (lc != char.class &&  lc != byte.class &&", "+            lc != short.class && lc != int.class) {", "+          node.setProperty(NodeProperties.ERROR_STRINGS,", "+                           new String[] { lc.getName() });", "+          throw new ExecutionError(\"switch.label.type\", node);", "-     */", "-    public Object visit(SwitchStatement node) {", "-        // Visits the components of this node", "-        Class c = (Class)node.getSelector().acceptVisitor(this);", "-        if (c != char.class && c != byte.class && c != short.class && c != int.class) {", "-\t    node.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t     new String[] { c.getName() });", "-            throw new ExecutionError(\"selector.type\", node);", "-        }", "-", "-        // Check the type of the case labels", "-        Iterator it = node.getBindings().iterator();", "-        while (it.hasNext()) {", "-\t    SwitchBlock sb = (SwitchBlock)it.next();", "-\t    sb.acceptVisitor(this);", "-            Expression exp = sb.getExpression();", "-            if (exp != null) {", "-                Class lc = NodeProperties.getType(exp);", "-                if (lc != char.class &&  lc != byte.class &&", "-                    lc != short.class && lc != int.class) {", "-\t\t    node.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t     new String[] { lc.getName() });", "-                    throw new ExecutionError(\"switch.label.type\", node);", "-                }", "-                if (c != lc) {", "-                    Number n = null;", "-                    if (exp.hasProperty(NodeProperties.VALUE)) {", "-                        Object cst = exp.getProperty(NodeProperties.VALUE);", "-                        if (lc == char.class) {", "-                            n = new Integer(((Character)cst).charValue());", "-                        } else {", "-                            n = (Number)cst;", "-                        }", "-                    }", "-                    if (c == byte.class) {", "-                        if (exp.hasProperty(NodeProperties.VALUE)) {", "-                            if (n.byteValue() != n.intValue()) {", "-\t\t\t\tnode.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t\t\t new String[] { c.getName() });", "-\t\t\t\tthrow new ExecutionError", "-                                    (\"switch.label.type\", node);", "-                            }", "-                        } else {", "-                            throw new ExecutionError(\"switch.label.type\", node);", "-                        }", "-                    } else if (c == short.class || c == char.class) {", "-                        if (exp.hasProperty(NodeProperties.VALUE)) {", "-                            if (n.shortValue() != n.intValue()) {", "-\t\t\t\tnode.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t\t\t new String[] { c.getName() });", "-                                throw new ExecutionError", "-                                    (\"switch.label.type\", node);", "-                            }", "-                        } else if (lc == int.class) {", "-\t\t\t    node.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t\t     new String[] { c.getName() });", "-                            throw new ExecutionError(\"switch.label.type\", node);", "-                        }", "-                    }", "-                }", "-            }", "-        }", "-        return null;", "-    }", "+        if (c != lc) {", "+          Number n = null;", "+          if (exp.hasProperty(NodeProperties.VALUE)) {", "+            Object cst = exp.getProperty(NodeProperties.VALUE);", "+            if (lc == char.class) {", "+              n = new Integer(((Character)cst).charValue());", "+              n = (Number)cst;", "+          }", "+          if (c == byte.class) {", "+            if (exp.hasProperty(NodeProperties.VALUE)) {", "+              if (n.byteValue() != n.intValue()) {", "+                node.setProperty(NodeProperties.ERROR_STRINGS,", "+                                 new String[] { c.getName() });", "+                throw new ExecutionError", "+                  (\"switch.label.type\", node);", "+              }", "+            } else {", "+              throw new ExecutionError(\"switch.label.type\", node);", "+            }", "+          } else if (c == short.class || c == char.class) {", "+            if (exp.hasProperty(NodeProperties.VALUE)) {", "+              if (n.shortValue() != n.intValue()) {", "+                node.setProperty(NodeProperties.ERROR_STRINGS,", "+                                 new String[] { c.getName() });", "+                throw new ExecutionError", "+                  (\"switch.label.type\", node);", "+              }", "+            } else if (lc == int.class) {", "+              node.setProperty(NodeProperties.ERROR_STRINGS,", "+                               new String[] { c.getName() });", "+              throw new ExecutionError(\"switch.label.type\", node);", "+            }", "+          }", "+      }", "+    return null;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf7290d255a5f78ece003037b317f229", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 77, "methodNumberAfterChange": 77, "signatureBeforeChange": "         public Object visit(MethodDeclaration node)", "signatureAfterChange": "     public Void visit(MethodDeclaration node)", "diff": ["-         */", "-        public Object visit(MethodDeclaration node) {", "-\t    MethodInfo mi         = classInfo.getMethod(node);", "-\t    int        af         = mi.getModifiers();", "-\t    String     mn         = node.getName();", "-\t    String     rt         = mi.getReturnType().getName();", "-\t    boolean    isAbstract;", "-", "-\t    // Check the modifiers", "-\t    if (isInterface) {", "-\t\tif (Modifier.isPrivate(af)   ||", "-\t\t    Modifier.isProtected(af) ||", "-\t\t    Modifier.isFinal(af)     ||", "-\t\t    Modifier.isStatic(af)) {", "-\t\t    node.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t     new String[] { node.getName(), classInfo.getName() });", "-\t\t    throw new ExecutionError(\"interface.method.modifier\", node);", "-\t\t}", "-\t\taf |= Modifier.PUBLIC | Modifier.ABSTRACT;", "-\t\tisAbstract = true;", "-\t    } else {", "-\t\tisAbstract = Modifier.isAbstract(af);", "-\t    }", "-\t    hasAbstractMethod |= isAbstract;", "-", "-\t    // Create the parameter array", "-\t    ClassInfo[] cia = mi.getParameterTypes();", "-\t    String[] params = new String[cia.length];", "-\t    for (int i = 0; i < cia.length; i++) {", "-\t\tparams[i] = cia[i].getName();", "-\t    }", "-", "-\t    // Create the exception array", "-\t    cia = mi.getExceptionTypes();", "-\t    String[] except = new String[cia.length];", "-\t    for (int i = 0; i < cia.length; i++) {", "-\t\texcept[i] = cia[i].getName();", "-\t    }", "-", "-\t    // Create the method", "-\t    classFactory.addMethod(af, rt, mn, params, except);", "-", "-\t    // Create the super method accessor", "-\t    if (!isInterface &&", "-\t\t!isAbstract &&", "-\t\tisRedefinedMethod(mi)) {", "-\t\tclassFactory.addSuperMethodAccessor(af, rt, mn, params, except);", "-\t    }", "-", "-\t    // Check the method", "-\t    Node body = node.getBody();", "-\t    if ((isAbstract && body != null) ||", "-\t\t(isInterface && body != null)) {", "-\t\tnode.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t new String[] { node.getName() });", "-\t\tthrow new ExecutionError(\"abstract.method.body\", node);", "-\t    }", "-", "-\t    if (!isAbstract && body == null) {", "-\t\tnode.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t new String[] { node.getName() });", "-\t\tthrow new ExecutionError(\"missing.method.body\", node);", "-\t    }", "-", "-\t    // Register the body", "-            if (body != null) {", "-                // Register the method", "-                String sig = ClassFactory.getMethodIdentifier", "-\t\t    (classInfo.getName(),", "-\t\t     mn,", "-\t\t     params,", "-\t\t     interpreter.getClassLoader().toString());", "-                interpreter.registerMethod(sig, node, importationManager);", "-            }", "-\t    return null;", "-\t}", "+     */", "+    public Void visit(MethodDeclaration node) {", "+      MethodInfo mi         = classInfo.getMethod(node);", "+      int        af         = mi.getModifiers();", "+      String     mn         = node.getName();", "+      String     rt         = mi.getReturnType().getName();", "+      boolean    isAbstract;", "+      ", "+      // Check the modifiers", "+      if (isInterface) {", "+        if (Modifier.isPrivate(af)   ||", "+            Modifier.isProtected(af) ||", "+            Modifier.isFinal(af)     ||", "+            Modifier.isStatic(af)) {", "+          node.setProperty(NodeProperties.ERROR_STRINGS,", "+                           new String[] { node.getName(), classInfo.getName() });", "+          throw new ExecutionError(\"interface.method.modifier\", node);", "+        }", "+        af |= Modifier.PUBLIC | Modifier.ABSTRACT;", "+        isAbstract = true;", "+      } else {", "+        isAbstract = Modifier.isAbstract(af);", "+      }", "+      hasAbstractMethod |= isAbstract;", "+      ", "+      // Create the parameter array", "+      ClassInfo[] cia = mi.getParameterTypes();", "+      String[] params = new String[cia.length];", "+      for (int i = 0; i < cia.length; i++) {", "+        params[i] = cia[i].getName();", "+      }", "+      ", "+      // Create the exception array", "+      cia = mi.getExceptionTypes();", "+      String[] except = new String[cia.length];", "+      for (int i = 0; i < cia.length; i++) {", "+        except[i] = cia[i].getName();", "+      }", "+      ", "+      // Create the method", "+      classFactory.addMethod(af, rt, mn, params, except);", "+      ", "+      // Create the super method accessor", "+      if (!isInterface &&", "+          !isAbstract &&", "+          isRedefinedMethod(mi)) {", "+        classFactory.addSuperMethodAccessor(af, rt, mn, params, except);", "+      }", "+      ", "+      // Check the method", "+      Node body = node.getBody();", "+      if ((isAbstract && body != null) ||", "+          (isInterface && body != null)) {", "+        node.setProperty(NodeProperties.ERROR_STRINGS,", "+                         new String[] { node.getName() });", "+        throw new ExecutionError(\"abstract.method.body\", node);", "+      }", "+      ", "+      if (!isAbstract && body == null) {", "+        node.setProperty(NodeProperties.ERROR_STRINGS,", "+                         new String[] { node.getName() });", "+        throw new ExecutionError(\"missing.method.body\", node);", "+      }", "+      ", "+      // Register the body", "+      if (body != null) {", "+        // Register the method", "+        String sig = ClassFactory.getMethodIdentifier", "+          (classInfo.getName(),", "+           mn,", "+           params,", "+           interpreter.getClassLoader().toString());", "+        interpreter.registerMethod(sig, node, importationManager);", "+      }", "+      return null;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd31007be70aef6f2dac0f6aeee1e7e7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "     public Class compile()", "signatureAfterChange": "   public Class compile()", "diff": ["+   */", "+  public Class compile() {", "+    // Create a class factory", "+    ClassInfo dc = classInfo.getDeclaringClass();", "+    String outer = (dc != null) ? dc.getName() : null;", "+    int       af = typeDeclaration.getAccessFlags();", "+    String  name = classInfo.getName();", "+    ", "+    if (isInterface) {", "+      af |= Modifier.INTERFACE;", "-     */", "-    public Class compile() {", "-\t// Create a class factory", "-\tClassInfo dc = classInfo.getDeclaringClass();", "-\tString outer = (dc != null) ? dc.getName() : null;", "-\tint       af = typeDeclaration.getAccessFlags();", "-\tString  name = classInfo.getName();", "-", "-\tif (isInterface) {", "-\t    af |= Modifier.INTERFACE;", "-\t}", "-", "-\tclassFactory = new ClassFactory(af,", "-\t\t\t\t\tname,", "-\t\t\t\t\tclassInfo.getSuperclass().getName(),", "-\t\t\t\t\tinterpreter.getClass(),", "-\t\t\t\t\tinterpreter.getExceptionClass(),", "-\t\t\t\t\tinterpreter.getClassLoader().toString());", "-", "-\t// Add the innerclass attributes", "-\tif (dc != null) {", "-\t    addInnerClassesAttribute(classInfo);", "-\t}", "-", "-\tClassInfo[] inners = classInfo.getDeclaredClasses();", "-\tfor (int i = 0; i < inners.length; i++) {", "-\t    String ciname = inners[i].getName();", "-", "-\t    InnerClassesEntry ice = classFactory.addInnerClassesEntry();", "-\t    ice.setInnerClassInfo(ciname);", "-\t    ice.setOuterClassInfo(name);", "-\t    ice.setInnerName(ciname.substring(name.length() + 1, ciname.length()));", "-\t    ice.setInnerClassAccessFlags((short)inners[i].getModifiers());", "-\t}", "-", "-\t// Add the interfaces", "-\tClassInfo[] ci = classInfo.getInterfaces();", "-\tfor (int i = 0; i < ci.length; i++) {", "-\t    classFactory.addInterface(ci[i].getName());", "-\t}", "-", "-\t// Check and create the members", "-\tIterator it = typeDeclaration.getMembers().iterator();", "-\twhile (it.hasNext()) {", "-\t    ((Node)it.next()).acceptVisitor(membersVisitor);", "-\t}", "-", "-\tif (!isInterface &&", "-\t    hasAbstractMethod &&", "-\t    !Modifier.isAbstract(af)) {", "-\t    typeDeclaration.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t\t\tnew String[] { name });", "-\t    throw new ExecutionError(\"misplaced.abstract\", typeDeclaration );", "-\t}", "-", "-\t// Create the constructor(s)", "-\tif (!isInterface) {", "-\t    ConstructorInfo[] cons = classInfo.getConstructors();", "-\t    for (int i = 0; i < cons.length; i++) {", "-\t\taddConstructor((TreeConstructorInfo)cons[i]);", "-\t    }", "-\t}", "-", "-\t// Create the class initializer", "-\tif (classInitializer.size() > 0) {", "-\t    interpreter.registerMethod", "-\t\t(classFactory.createClassInitializer(),", "-\t\t new MethodDeclaration(Modifier.PUBLIC,", "-\t\t\t\t       new VoidType(),", "-\t\t\t\t       \"<clinit>\",", "-\t\t\t\t       new LinkedList(),", "-\t\t\t\t       new LinkedList(),", "-\t\t\t\t       new BlockStatement(classInitializer)),", "-\t\t importationManager);", "-\t}", "-", "-\t// Define the class", "-\tTreeClassLoader classLoader = (TreeClassLoader)interpreter.getClassLoader();", "-\treturn classLoader.defineClass(name, classFactory.getByteCode());", "+    ", "+    classFactory = new ClassFactory(af,", "+                                    name,", "+                                    classInfo.getSuperclass().getName(),", "+                                    interpreter.getClass(),", "+                                    interpreter.getExceptionClass(),", "+                                    interpreter.getClassLoader().toString());", "+    ", "+    // Add the innerclass attributes", "+    if (dc != null) {", "+      addInnerClassesAttribute(classInfo);", "+    ", "+    ClassInfo[] inners = classInfo.getDeclaredClasses();", "+    for (int i = 0; i < inners.length; i++) {", "+      String ciname = inners[i].getName();", "+      ", "+      InnerClassesEntry ice = classFactory.addInnerClassesEntry();", "+      ice.setInnerClassInfo(ciname);", "+      ice.setOuterClassInfo(name);", "+      ice.setInnerName(ciname.substring(name.length() + 1, ciname.length()));", "+      ice.setInnerClassAccessFlags((short)inners[i].getModifiers());", "+    ", "+    // Add the interfaces", "+    ClassInfo[] ci = classInfo.getInterfaces();", "+    for (int i = 0; i < ci.length; i++) {", "+      classFactory.addInterface(ci[i].getName());", "+    ", "+    // Check and create the members", "+    Iterator it = typeDeclaration.getMembers().iterator();", "+    while (it.hasNext()) {", "+      ((Node)it.next()).acceptVisitor(membersVisitor);", "+    }", "+    ", "+    if (!isInterface &&", "+        hasAbstractMethod &&", "+        !Modifier.isAbstract(af)) {", "+      typeDeclaration.setProperty(NodeProperties.ERROR_STRINGS,", "+                                  new String[] { name });", "+      throw new ExecutionError(\"misplaced.abstract\", typeDeclaration );", "+    }", "+    ", "+    // Create the constructor(s)", "+    if (!isInterface) {", "+      ConstructorInfo[] cons = classInfo.getConstructors();", "+      for (int i = 0; i < cons.length; i++) {", "+        addConstructor((TreeConstructorInfo)cons[i]);", "+      }", "+    }", "+    ", "+    // Create the class initializer", "+    if (classInitializer.size() > 0) {", "+      interpreter.registerMethod", "+        (classFactory.createClassInitializer(),", "+         new MethodDeclaration(Modifier.PUBLIC,", "+                               new VoidType(),", "+                               \"<clinit>\",", "+                               new LinkedList<FormalParameter>(),", "+                               new LinkedList<List<IdentifierToken>>(),", "+                               new BlockStatement(classInitializer)),", "+         importationManager);", "+    }", "+    ", "+    // Define the class", "+    TreeClassLoader classLoader = (TreeClassLoader)interpreter.getClassLoader();", "+    return classLoader.defineClass(name, classFactory.getByteCode());", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eaba410404e5e8bb109abbb2378f26b5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     protected void addConstructor(TreeConstructorInfo ci)", "signatureAfterChange": "   protected void addConstructor(TreeConstructorInfo ci)", "diff": ["-     */", "-    protected void addConstructor(TreeConstructorInfo ci) {", "-\t// Get the parameter types", "-\tClassInfo[] cinf   = ci.getParameterTypes();", "-\tString[]    params = new String[cinf.length];", "-\tfor (int i = 0; i < cinf.length; i++) {", "-\t    params[i] = cinf[i].getName();", "-\t}", "-", "-\t// Get the exceptions", "-\tcinf = ci.getExceptionTypes();", "-\tString[] ex = new String[cinf.length];", "-\tfor (int i = 0; i < cinf.length; i++) {", "-\t    ex[i] = cinf[i].getName();", "-\t}", "-", "-\tString sig = ClassFactory.getMethodIdentifier", "-\t    (classInfo.getName(),", "-\t     \"<init>\",", "-\t     params,", "-\t     interpreter.getClassLoader().toString());", "-\tConstructorDeclaration cd = ci.getConstructorDeclaration();", "-", "-\t// Check the constructor's name", "-\tif (!cd.getName().equals(typeDeclaration.getName())) {", "-\t    cd.setProperty(NodeProperties.ERROR_STRINGS,", "-\t\t\t   new String[] { cd.getName() });", "-           throw new ExecutionError(\"constructor.name\", cd);", "-\t}", "-", "-\t// Register the constructor", "-\tConstructorInvocation civ = cd.getConstructorInvocation();", "-\tConstructorVisitor    cv = new ConstructorVisitor();", "-", "-\tif (civ != null) {", "-\t    Iterator it = cd.getParameters().iterator();", "-\t    while (it.hasNext()) {", "-\t\t((Node)it.next()).acceptVisitor(cv);", "-\t    }", "-\t    civ.acceptVisitor(cv);", "-", "-\t    interpreter.registerConstructorArguments", "-\t\t(sig,", "-\t\t cd.getParameters(),", "-\t\t civ.getArguments(),", "-\t\t importationManager);", "-\t} else {", "-\t    interpreter.registerConstructorArguments", "-\t\t(sig,", "-\t\t new LinkedList(),", "-\t\t new LinkedList(),", "-\t\t importationManager);", "-\t}", "-", "-\tMethodDeclaration md =", "-\t    new MethodDeclaration(cd.getAccessFlags(),", "-\t\t\t\t  new VoidType(),", "-\t\t\t\t  \"<init>\",", "-\t\t\t\t  cd.getParameters(),", "-\t\t\t\t  new LinkedList(),", "-\t\t\t\t  new BlockStatement(cd.getStatements()));", "-\tinterpreter.registerMethod(sig, md, importationManager);", "-\t", "-\t// Add the instance initialization statement to the constructor statement", "-\tif (!cv.superConstructor.equals(classInfo.getName())) {", "-\t    ListIterator lit = cd.getStatements().listIterator();", "-\t    Iterator it = instanceInitializer.iterator();", "-\t    while (it.hasNext()) {", "-\t\tlit.add(it.next());", "-\t    }", "-\t}", "-", "-\t// Create the constructor", "-\tclassFactory.addConstructor(cd.getAccessFlags(), params, ex,", "-\t\t\t\t    cv.superConstructor,", "-\t\t\t\t    cv.constructorParameters);", "+   */", "+  protected void addConstructor(TreeConstructorInfo ci) {", "+    // Get the parameter types", "+    ClassInfo[] cinf   = ci.getParameterTypes();", "+    String[]    params = new String[cinf.length];", "+    for (int i = 0; i < cinf.length; i++) {", "+      params[i] = cinf[i].getName();", "+    }", "+    ", "+    // Get the exceptions", "+    cinf = ci.getExceptionTypes();", "+    String[] ex = new String[cinf.length];", "+    for (int i = 0; i < cinf.length; i++) {", "+      ex[i] = cinf[i].getName();", "+    }", "+    ", "+    String sig = ClassFactory.getMethodIdentifier", "+      (classInfo.getName(),", "+       \"<init>\",", "+       params,", "+       interpreter.getClassLoader().toString());", "+    ConstructorDeclaration cd = ci.getConstructorDeclaration();", "+    ", "+    // Check the constructor's name", "+    if (!cd.getName().equals(typeDeclaration.getName())) {", "+      cd.setProperty(NodeProperties.ERROR_STRINGS,", "+                     new String[] { cd.getName() });", "+      throw new ExecutionError(\"constructor.name\", cd);", "+    }", "+    ", "+    // Register the constructor", "+    ConstructorInvocation civ = cd.getConstructorInvocation();", "+    ConstructorVisitor    cv = new ConstructorVisitor();", "+    ", "+    if (civ != null) {", "+      Iterator it = cd.getParameters().iterator();", "+      while (it.hasNext()) {", "+        ((Node)it.next()).acceptVisitor(cv);", "+      }", "+      civ.acceptVisitor(cv);", "+      ", "+      interpreter.registerConstructorArguments", "+        (sig,", "+         cd.getParameters(),", "+         civ.getArguments(),", "+         importationManager);", "+    } else {", "+      interpreter.registerConstructorArguments", "+        (sig,", "+         new LinkedList<FormalParameter>(),", "+         new LinkedList<Expression>(),", "+         importationManager);", "+    }", "+    ", "+    MethodDeclaration md =", "+      new MethodDeclaration(cd.getAccessFlags(),", "+                            new VoidType(),", "+                            \"<init>\",", "+                            cd.getParameters(),", "+                            new LinkedList<List<IdentifierToken>>(),", "+                            new BlockStatement(cd.getStatements()));", "+    interpreter.registerMethod(sig, md, importationManager);", "+    ", "+    // Add the instance initialization statement to the constructor statement", "+    if (!cv.superConstructor.equals(classInfo.getName())) {", "+      ListIterator<Node> lit = cd.getStatements().listIterator();", "+      Iterator<Node> it = instanceInitializer.iterator();", "+      while (it.hasNext()) {", "+        lit.add(it.next());", "+      }", "+    }", "+    ", "+    // Create the constructor", "+    classFactory.addConstructor(cd.getAccessFlags(), params, ex,", "+                                cv.superConstructor,", "+                                cv.constructorParameters);", "+  }"]}], "num": 30029}