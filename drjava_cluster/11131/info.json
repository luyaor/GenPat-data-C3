{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ce1d6bf50d0f76612867141d5f5b2001", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3ba64d5d3448a819797ee91072c17343", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 20, "signatureBeforeChange": "   @Override public Type visit(SuperFieldAccess node)", "signatureAfterChange": "     @Override public Type visit(SuperFieldAccess node)", "diff": ["+     */", "+    @Override public Type visit(SuperFieldAccess node) {", "+      Type t = context.getSuperType(ts);", "+        throw new ExecutionError(\"super.undefined\", node);", "-   */", "-  @Override public Type visit(SuperFieldAccess node) {", "-    Type t = context.getSuperType(ts);", "-    if (t == null) {", "-      throw new ExecutionError(\"super.undefined\", node);", "-    }", "-    Expression obj = TypeUtil.makeEmptyExpression(node);", "-    setType(obj, t);", "-    try {", "-      TypeSystem.FieldReference ref = ts.lookupField(obj, node.getFieldName());", "-      // TODO: Check accessibility of field", "-      setField(node, ref.field());", "-      setDJClass(node, context.getThis());", "-      setVariableType(node, ref.type());", "-      Type result = ts.capture(ref.type());", "-      addRuntimeCheck(node, result, ref.field().type());", "-      return setType(node, result);", "-    }", "-    catch (TypeSystemException e) {", "-      setErrorStrings(node, ts.userRepresentation(t), node.getFieldName());", "-      throw new ExecutionError(\"no.such.field\", node);", "-    }", "-  }", "+      Expression obj = TypeUtil.makeEmptyExpression(node);", "+      setType(obj, t);", "+        FieldReference ref = ts.lookupField(obj, node.getFieldName());", "+        // TODO: Check accessibility of field", "+        setField(node, ref.field());", "+        setDJClass(node, context.getThis());", "+        setVariableType(node, ref.type());", "+        Type result = ts.capture(ref.type());", "+        addRuntimeCheck(node, result, ref.field().type());", "+        return setType(node, result);", "+      catch (TypeSystemException e) {", "+        setErrorStrings(node, ts.userRepresentation(t), node.getFieldName());", "+        throw new ExecutionError(\"no.such.field\", node);", "+      }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e9d71f42911ae19c90b41a2ec5cd0c00", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 18, "signatureBeforeChange": "   @Override public Type visit(SimpleFieldAccess node)", "signatureAfterChange": "     @Override public Type visit(SimpleFieldAccess node)", "diff": ["+     */", "+    @Override public Type visit(SimpleFieldAccess node) {", "+      try {", "+        ClassType t = context.typeContainingField(node.getFieldName(), ts);", "+        if (t == null) {", "+          setErrorStrings(node, node.getFieldName());", "+          throw new ExecutionError(\"undefined.name\", node);", "+        }", "+        FieldReference ref;", "+        if (context.getThis() == null) {", "+          ref = ts.lookupStaticField(t, node.getFieldName());", "+        }", "+        else {", "+          Expression obj = TypeUtil.makeEmptyExpression(node);", "+          setType(obj, t);", "+          ref = ts.lookupField(obj, node.getFieldName());", "+        }", "+        ", "+        // TODO: Check accessibility of field", "+        setField(node, ref.field());", "+        setVariableType(node, ref.type());", "+        if (!ref.field().isStatic()) {", "+          setDJClass(node, t.ofClass());", "+        }", "+        Type result = ts.capture(ref.type());", "+        addRuntimeCheck(node, result, ref.field().type());", "+        return setType(node, result);", "+    }", "-   */", "-  @Override public Type visit(SimpleFieldAccess node) {", "-    try {", "-      ClassType t = context.typeContainingField(node.getFieldName(), ts);", "-        setErrorStrings(node, node.getFieldName());", "-        throw new ExecutionError(\"undefined.name\", node);", "-      TypeSystem.FieldReference ref;", "-      if (context.getThis() == null) {", "-        ref = ts.lookupStaticField(t, node.getFieldName());", "-      }", "-      else {", "-        Expression obj = TypeUtil.makeEmptyExpression(node);", "-        setType(obj, t);", "-        ref = ts.lookupField(obj, node.getFieldName());", "-      }", "-      ", "-      // TODO: Check accessibility of field", "-      setField(node, ref.field());", "-      setVariableType(node, ref.type());", "-      if (!ref.field().isStatic()) {", "-        setDJClass(node, t.ofClass());", "-      }", "-      Type result = ts.capture(ref.type());", "-      addRuntimeCheck(node, result, ref.field().type());", "-      return setType(node, result);", "-    }", "-    catch (AmbiguousNameException e) { throw new ExecutionError(\"ambiguous.name\", node); }", "-    catch (InvalidTargetException e) { throw new RuntimeException(\"context produced bad type\"); }", "-    catch (UnmatchedLookupException e) {", "-      if (e.matches() == 0) { throw new ExecutionError(\"undefined.name.noinfo\", node); }", "-      else { throw new ExecutionError(\"ambiguous.name\", node); }", "-    }", "-  }"]}], "num": 11131}