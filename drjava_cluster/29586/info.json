{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2be15cfbdefbced5a772b294b4e195c7", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "59a7c6e62a5e3cd841003b551a0c2bd6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/reducedmodel/ReducedModelControl.java", "commitBeforeChange": "9aa0c6bec51662a685ea4b86bc02a52c9e593d8a", "commitAfterChange": "691bffe1c74bde71a4cf5e7ed44b9a42c3c86fd0", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "   void prev()", "signatureAfterChange": "   void prev()", "diff": ["-    int size = 0;", "-    if (rmc._cursor.atEnd()){", "+    int size;", "+    if (rmc._cursor.atEnd()) {", "-      if (rmc._cursor.atStart()) //because in place now.", "-        return;", "+      if (rmc._cursor.atStart()) {", "+        return; // because in place now.", "+      }", "-      if (rmc.current().getSize() < rmb.current().getSize())", "+      if (rmc.current().getSize() < rmb.current().getSize()) {", "-      else", "+      }", "+      else {", "+      }", "-      move (size);", "-      return;", "+      move(size);", "-", "-    if (rmb.getBlockOffset() < rmc.getBlockOffset()) {", "+    else if (rmb.getBlockOffset() < rmc.getBlockOffset()) {", "-      if (size < rmc.getBlockOffset())", "+      if (size < rmc.getBlockOffset()) {", "-      else", "+      }", "+      else {", "+      }", "-      if (size < rmb.getBlockOffset())", "+      if (size < rmb.getBlockOffset()) {", "-      else", "+      }", "+      else {", "+      }", "-"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6eb69f5ce3b029b1f903c9f7e2b0d075", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/reducedmodel/ReducedModelComment.java", "commitBeforeChange": "fa2aa8dc78d037bc99ec51d48049f6b3df0aecfb", "commitAfterChange": "0d5978f95b9d81515ff8908c4d2b74c1df5a1255", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 45, "signatureBeforeChange": " \tprivate int _calculateOffset(int delToSizePrev, String delToTypePrev, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t int delToSizeCurr, String delToTypeCurr, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ModelList<ReducedToken>.Iterator delTo)", "signatureAfterChange": "   private int _calculateOffset(int delToSizePrev, String delToTypePrev,                                int delToSizeCurr, String delToTypeCurr,                                ModelList<ReducedToken>.Iterator delTo)", "diff": ["+  */", "+  private int _calculateOffset(int delToSizePrev, String delToTypePrev,", "+                               int delToSizeCurr, String delToTypeCurr,", "+                               ModelList<ReducedToken>.Iterator delTo)", "+  {      ", "+    int delToSizeChange = delTo.current().getSize();", "+    String delToTypeChange = delTo.current().getType();", "+    ", "+    //1)if there was a gap previous to the gap at delTo delTo should be", "+    //augmented by its size, and that size is the offset.", "+    //2)if the gap was not preceeded by a gap then it would not need to", "+    //be shrunk", "+    if (delTo.atEnd()) {", "+      throw new IllegalArgumentException(\"Shouldn't happen\");", "+    }", "+    if (delTo.current().isGap()) {", "+      return delToSizeChange - delToSizeCurr;", "+    }", "+    //this means that the item at the end formed a double brace with the", "+    //item that the delete left preceeding it. /dddddd*", "+    ", "+    //the final item shrunk. This can only happen if the starting item", "+    //stole one of its braces: /ddddd*/", "+    //or if it was a double brace that had to get broken because it was", "+    //now commented or no longer has an open block", "+    ", "+    //EXAMPLES: /*___*/  becoming */", "+    //          /*___*/  delete the first star, through the spaces to get", "+    //                   /*/", "+    //         //*__\\n// becoming //*__//, the // is broken", "+    //         //*__\\n// becoming ////   , the // is broken", "+    //THIS MUST HAVE THE previous items size and type passed in from", "+    //before the update. This way we know how it's changing too.", "+    ", "+    // case of /", "+    if (delToTypePrev.equals(\"/\")) {", "+      //  /-/* becoming //-*", "+      if(delToTypeCurr.equals(\"/*\") && ", "+         _checkPrevEquals(delTo,\"//\")) { //because pointer will be at *", "+           delTo.prev();", "+           return 1;", "+         }", "+      else if (delToTypeCurr.equals(\"//\") &&", "+               _checkPrevEquals(delTo,\"//\")) {", "+                 delTo.prev();", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"*/\") && //changed", "+               delTo.current().getType().equals(\"/*\")) {                    ", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"*\") &&", "+               delTo.current().getType().equals(\"/*\")) {", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"/\") &&", "+               delTo.current().getType().equals(\"//\")) {", "+                 return 1;", "+               }", "+    }", "+    //case of *", "+    else if (delToTypePrev.equals(\"*\")) {", "+      //  /-/* becoming //-*", "+      if(delToTypeCurr.equals(\"/*\") && ", "+         _checkPrevEquals(delTo,\"*/\")) { //because pointer will be at *", "+           delTo.prev();", "+           return 1;", "+         }", "+      else if (delToTypeCurr.equals(\"//\") &&", "+               _checkPrevEquals(delTo,\"*/\")) {", "+                 delTo.prev();", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"/\") &&", "+               delTo.current().getType().equals(\"*/\")) {", "+                 return 1;              ", "+               }", "+    }", "+    else if (delToTypePrev.equals(\"\\\\\")){", "+      if(delToTypeCurr.equals(\"\\\\\\\\\") && ", "+         _checkPrevEquals(delTo,\"\\\\\")) { //because pointer will be at *", "+           delTo.prev();", "+           return 1;", "+         }", "+      else if (delToTypeCurr.equals(\"\\\\\\\"\") &&", "+               _checkPrevEquals(delTo,\"\\\"\")) {", "+                 delTo.prev();", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"\\\\\") &&", "+               delTo.current().getType().equals(\"\\\\\\\\\")) ", "+               {", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"\\\"\") &&", "+               delTo.current().getType().equals(\"\\\\\\\"\"))", "+               {", "+                 return 1;", "+               }", "+      ", "+    }", "+    ", "+    return 0;", "+  }", "-\t */", "-\tprivate int _calculateOffset(int delToSizePrev, String delToTypePrev,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t int delToSizeCurr, String delToTypeCurr,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ModelList<ReducedToken>.Iterator delTo)", "-\t\t{\t\t\t", "-\t\t\tint delToSizeChange = delTo.current().getSize();", "-\t\t\tString delToTypeChange = delTo.current().getType();", "-", "-\t\t\t//1)if there was a gap previous to the gap at delTo delTo should be", "-\t\t\t//augmented by its size, and that size is the offset.", "-\t\t\t//2)if the gap was not preceeded by a gap then it would not need to", "-\t\t\t//be shrunk", "-\t\t\tif (delTo.atEnd())", "-\t\t\t\tthrow new IllegalArgumentException(\"Shouldn't happen\");", "-\t\t\tif (delTo.current().isGap())", "-\t\t\t\treturn delToSizeChange - delToSizeCurr;", "-\t\t\t//this means that the item at the end formed a double brace with the", "-\t\t\t//item that the delete left preceeding it. /dddddd*", "-", "-\t\t\t//the final item shrunk. This can only happen if the starting item", "-\t\t\t//stole one of its braces: /ddddd*/", "-\t\t\t//or if it was a double brace that had to get broken because it was", "-\t\t\t//now commented or no longer has an open block", "-", "-\t\t\t//EXAMPLES: /*___*/  becoming */", "-\t\t\t//          /*___*/  delete the first star, through the spaces to get", "-\t\t\t//                   /*/", "-\t\t\t//         //*__\\n// becoming //*__//, the // is broken", "-\t\t\t//         //*__\\n// becoming ////   , the // is broken", "-\t\t\t//THIS MUST HAVE THE previous items size and type passed in from", "-\t\t\t//before the update. This way we know how it's changing too.", "-\t\t\t\t", "-\t\t\t// case of /", "-\t\t\tif (delToTypePrev.equals(\"/\")){", "-\t\t\t\t//  /-/* becoming //-*", "-\t\t\t\tif(delToTypeCurr.equals(\"/*\") && ", "-\t\t\t\t\t _checkPrevEquals(delTo,\"//\")){ //because pointer will be at *", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"//\") &&", "-\t\t\t\t\t\t\t\t _checkPrevEquals(delTo,\"//\")){", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"*/\") && //changed", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"/*\")){\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"*\") &&", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"/*\"))", "-\t\t\t\t\treturn 1;", "-\t\t\t\telse if (delToTypeCurr.equals(\"/\") &&", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"//\"))", "-\t\t\t\t\treturn 1;", "-\t\t\t}", "-\t\t\t//case of *", "-\t\t\telse if (delToTypePrev.equals(\"*\")){", "-\t\t\t\t//  /-/* becoming //-*", "-\t\t\t\tif(delToTypeCurr.equals(\"/*\") && ", "-\t\t\t\t\t _checkPrevEquals(delTo,\"*/\")){ //because pointer will be at *", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"//\") &&", "-\t\t\t\t\t\t\t\t _checkPrevEquals(delTo,\"*/\")){", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"/\") &&", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"*/\"))", "-\t\t\t\t\treturn 1;\t\t\t\t\t\t\t", "-\t\t\t}", "-\t\t\telse if (delToTypePrev.equals(\"\\\\\")){", "-\t\t\t\tif(delToTypeCurr.equals(\"\\\\\\\\\") && ", "-\t\t\t\t\t _checkPrevEquals(delTo,\"\\\\\")){ //because pointer will be at *", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"\\\\\\\"\") &&", "-\t\t\t\t\t\t\t\t _checkPrevEquals(delTo,\"\\\"\")){", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"\\\\\") &&", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"\\\\\\\\\"))", "-\t\t\t\t\treturn 1;", "-\t\t\t\telse if (delToTypeCurr.equals(\"\\\"\") &&", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"\\\\\\\"\"))", "-\t\t\t\t\treturn 1;", "-\t\t\t\t", "-\t\t\t\t", "-\t\t\t}", "-\t\t\t\t", "-\t\t\treturn 0;", "-\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e800a2910f2a4557dc70a019adbc8878", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ReducedModelComment.java", "commitBeforeChange": "fa2aa8dc78d037bc99ec51d48049f6b3df0aecfb", "commitAfterChange": "0d5978f95b9d81515ff8908c4d2b74c1df5a1255", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 45, "signatureBeforeChange": " \tprivate int _calculateOffset(int delToSizePrev, String delToTypePrev, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t int delToSizeCurr, String delToTypeCurr, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ModelList<ReducedToken>.Iterator delTo)", "signatureAfterChange": "   private int _calculateOffset(int delToSizePrev, String delToTypePrev,                                int delToSizeCurr, String delToTypeCurr,                                ModelList<ReducedToken>.Iterator delTo)", "diff": ["+  */", "+  private int _calculateOffset(int delToSizePrev, String delToTypePrev,", "+                               int delToSizeCurr, String delToTypeCurr,", "+                               ModelList<ReducedToken>.Iterator delTo)", "+  {      ", "+    int delToSizeChange = delTo.current().getSize();", "+    String delToTypeChange = delTo.current().getType();", "+    ", "+    //1)if there was a gap previous to the gap at delTo delTo should be", "+    //augmented by its size, and that size is the offset.", "+    //2)if the gap was not preceeded by a gap then it would not need to", "+    //be shrunk", "+    if (delTo.atEnd()) {", "+      throw new IllegalArgumentException(\"Shouldn't happen\");", "+    }", "+    if (delTo.current().isGap()) {", "+      return delToSizeChange - delToSizeCurr;", "+    }", "+    //this means that the item at the end formed a double brace with the", "+    //item that the delete left preceeding it. /dddddd*", "+    ", "+    //the final item shrunk. This can only happen if the starting item", "+    //stole one of its braces: /ddddd*/", "+    //or if it was a double brace that had to get broken because it was", "+    //now commented or no longer has an open block", "+    ", "+    //EXAMPLES: /*___*/  becoming */", "+    //          /*___*/  delete the first star, through the spaces to get", "+    //                   /*/", "+    //         //*__\\n// becoming //*__//, the // is broken", "+    //         //*__\\n// becoming ////   , the // is broken", "+    //THIS MUST HAVE THE previous items size and type passed in from", "+    //before the update. This way we know how it's changing too.", "+    ", "+    // case of /", "+    if (delToTypePrev.equals(\"/\")) {", "+      //  /-/* becoming //-*", "+      if(delToTypeCurr.equals(\"/*\") && ", "+         _checkPrevEquals(delTo,\"//\")) { //because pointer will be at *", "+           delTo.prev();", "+           return 1;", "+         }", "+      else if (delToTypeCurr.equals(\"//\") &&", "+               _checkPrevEquals(delTo,\"//\")) {", "+                 delTo.prev();", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"*/\") && //changed", "+               delTo.current().getType().equals(\"/*\")) {                    ", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"*\") &&", "+               delTo.current().getType().equals(\"/*\")) {", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"/\") &&", "+               delTo.current().getType().equals(\"//\")) {", "+                 return 1;", "+               }", "+    }", "+    //case of *", "+    else if (delToTypePrev.equals(\"*\")) {", "+      //  /-/* becoming //-*", "+      if(delToTypeCurr.equals(\"/*\") && ", "+         _checkPrevEquals(delTo,\"*/\")) { //because pointer will be at *", "+           delTo.prev();", "+           return 1;", "+         }", "+      else if (delToTypeCurr.equals(\"//\") &&", "+               _checkPrevEquals(delTo,\"*/\")) {", "+                 delTo.prev();", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"/\") &&", "+               delTo.current().getType().equals(\"*/\")) {", "+                 return 1;              ", "+               }", "+    }", "+    else if (delToTypePrev.equals(\"\\\\\")){", "+      if(delToTypeCurr.equals(\"\\\\\\\\\") && ", "+         _checkPrevEquals(delTo,\"\\\\\")) { //because pointer will be at *", "+           delTo.prev();", "+           return 1;", "+         }", "+      else if (delToTypeCurr.equals(\"\\\\\\\"\") &&", "+               _checkPrevEquals(delTo,\"\\\"\")) {", "+                 delTo.prev();", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"\\\\\") &&", "+               delTo.current().getType().equals(\"\\\\\\\\\")) ", "+               {", "+                 return 1;", "+               }", "+      else if (delToTypeCurr.equals(\"\\\"\") &&", "+               delTo.current().getType().equals(\"\\\\\\\"\"))", "+               {", "+                 return 1;", "+               }", "+      ", "+    }", "+    ", "+    return 0;", "+  }", "-\t */", "-\tprivate int _calculateOffset(int delToSizePrev, String delToTypePrev,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t int delToSizeCurr, String delToTypeCurr,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ModelList<ReducedToken>.Iterator delTo)", "-\t\t{\t\t\t", "-\t\t\tint delToSizeChange = delTo.current().getSize();", "-\t\t\tString delToTypeChange = delTo.current().getType();", "-", "-\t\t\t//1)if there was a gap previous to the gap at delTo delTo should be", "-\t\t\t//augmented by its size, and that size is the offset.", "-\t\t\t//2)if the gap was not preceeded by a gap then it would not need to", "-\t\t\t//be shrunk", "-\t\t\tif (delTo.atEnd())", "-\t\t\t\tthrow new IllegalArgumentException(\"Shouldn't happen\");", "-\t\t\tif (delTo.current().isGap())", "-\t\t\t\treturn delToSizeChange - delToSizeCurr;", "-\t\t\t//this means that the item at the end formed a double brace with the", "-\t\t\t//item that the delete left preceeding it. /dddddd*", "-", "-\t\t\t//the final item shrunk. This can only happen if the starting item", "-\t\t\t//stole one of its braces: /ddddd*/", "-\t\t\t//or if it was a double brace that had to get broken because it was", "-\t\t\t//now commented or no longer has an open block", "-", "-\t\t\t//EXAMPLES: /*___*/  becoming */", "-\t\t\t//          /*___*/  delete the first star, through the spaces to get", "-\t\t\t//                   /*/", "-\t\t\t//         //*__\\n// becoming //*__//, the // is broken", "-\t\t\t//         //*__\\n// becoming ////   , the // is broken", "-\t\t\t//THIS MUST HAVE THE previous items size and type passed in from", "-\t\t\t//before the update. This way we know how it's changing too.", "-\t\t\t\t", "-\t\t\t// case of /", "-\t\t\tif (delToTypePrev.equals(\"/\")){", "-\t\t\t\t//  /-/* becoming //-*", "-\t\t\t\tif(delToTypeCurr.equals(\"/*\") && ", "-\t\t\t\t\t _checkPrevEquals(delTo,\"//\")){ //because pointer will be at *", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"//\") &&", "-\t\t\t\t\t\t\t\t _checkPrevEquals(delTo,\"//\")){", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"*/\") && //changed", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"/*\")){\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"*\") &&", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"/*\"))", "-\t\t\t\t\treturn 1;", "-\t\t\t\telse if (delToTypeCurr.equals(\"/\") &&", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"//\"))", "-\t\t\t\t\treturn 1;", "-\t\t\t}", "-\t\t\t//case of *", "-\t\t\telse if (delToTypePrev.equals(\"*\")){", "-\t\t\t\t//  /-/* becoming //-*", "-\t\t\t\tif(delToTypeCurr.equals(\"/*\") && ", "-\t\t\t\t\t _checkPrevEquals(delTo,\"*/\")){ //because pointer will be at *", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"//\") &&", "-\t\t\t\t\t\t\t\t _checkPrevEquals(delTo,\"*/\")){", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"/\") &&", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"*/\"))", "-\t\t\t\t\treturn 1;\t\t\t\t\t\t\t", "-\t\t\t}", "-\t\t\telse if (delToTypePrev.equals(\"\\\\\")){", "-\t\t\t\tif(delToTypeCurr.equals(\"\\\\\\\\\") && ", "-\t\t\t\t\t _checkPrevEquals(delTo,\"\\\\\")){ //because pointer will be at *", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"\\\\\\\"\") &&", "-\t\t\t\t\t\t\t\t _checkPrevEquals(delTo,\"\\\"\")){", "-\t\t\t\t\tdelTo.prev();", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-\t\t\t\telse if (delToTypeCurr.equals(\"\\\\\") &&", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"\\\\\\\\\"))", "-\t\t\t\t\treturn 1;", "-\t\t\t\telse if (delToTypeCurr.equals(\"\\\"\") &&", "-\t\t\t\t\t\t\t\t delTo.current().getType().equals(\"\\\\\\\"\"))", "-\t\t\t\t\treturn 1;", "-\t\t\t\t", "-\t\t\t\t", "-\t\t\t}", "-\t\t\t\t", "-\t\t\treturn 0;", "-\t\t}"]}], "num": 29586}