{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "784ce6a1d4569b0e7aa5ca504686b749", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "151c04ec1d0d7fe99886b8d8266ef15f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/AdvancedVisitor.java", "commitBeforeChange": "3e22080f0d9650b7b802f9b713065e47d1a0ce19", "commitAfterChange": "1bbb44dda9ccbed1420a315a25ace5ab1cf20f80", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "   protected VariableData[] formalParameters2VariableData(FormalParameter[] fps, Data d)", "signatureAfterChange": "   protected VariableData[] formalParameters2VariableData(FormalParameter[] fps, Data d)", "diff": ["+//    Utilities.show(\"formalParameters2VariableData called on \" + fps);", "-    //This is something of a hack.  The parameters to a static method can be referened within the method itself,", "-    //even though they are not declared to be static fields.  Since making them static has no effect on any other processing, go", "-    //ahead and make them static so that the type checking stage will be easier.", "+    // This is something of a hack.  The parameters to a static method can be referened within the method itself,", "+    // even though they are not declared to be static fields.  Since making them static has no effect on any other processing, go", "+    // ahead and make them static so that the type checking stage will be easier.", "-    ", "+", "-      SymbolData type = getSymbolData(vd.getType().getName(), si);", "+      String typeName = vd.getType().getName();", "+      SymbolData type = getSymbolData(typeName, si);", "-        type = d.getInnerClassOrInterface(vd.getType().getName());", "+        type = d.getInnerClassOrInterface(typeName);", "-        //if we still couldn't resolve sd, create a continuation for it.", "-        type = new SymbolData(d.getSymbolData().getName() + \"$\" + vd.getType().getName());", "-        d.getSymbolData().addInnerClass(type);", "-        type.setOuterData(d.getSymbolData());", "+        // If we still couldn't resolve sd, create a continuation for it.", "+        String qualifiedTypeName = d.getSymbolData().getName() + \".\" + typeName;", "+//        type.setOuterData(d.getSymbolData());", "+        if (_innerClassesToBeParsed.contains(qualifiedTypeName))", "+          type = addInnerSymbolData(si, qualifiedTypeName, d);", "+        else type = addSymbolData(si, typeName);", "-"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d78133c6511cc107bdc4d9965790f408", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "3e22080f0d9650b7b802f9b713065e47d1a0ce19", "commitAfterChange": "1bbb44dda9ccbed1420a315a25ace5ab1cf20f80", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 43, "signatureBeforeChange": "   protected VariableData[] formalParameters2VariableData(FormalParameter[] fps, Data enclosing)", "signatureAfterChange": "   protected VariableData[] formalParameters2VariableData(FormalParameter[] fps, Data enclosing)", "diff": ["+//    Utilities.show(\"formalParameters2VariableData called on \" + fps);", "-      String name = vd.getName().getText();", "+      String name = vd.getName().getText();  // getName returns a Word", "+      String typeName = vd.getType().getName();", "-      SymbolData type = getSymbolData(vd.getType().getName(), si);", "-      ", "-      if (type == null) {  // should add && ! elementary level here ?  What about library types?", "-        //see if this is a partially qualified field reference", "-        type = enclosing.getInnerClassOrInterface(vd.getType().getName());", "-      }", "+      SymbolData type = getSymbolData(typeName, si);", "-        //if we still couldn't resolve sd, create a continuation for it.", "-        type = new SymbolData(enclosing.getSymbolData().getName() + \"$\" + vd.getType().getName());", "-        enclosing.getSymbolData().addInnerClass(type);", "-        type.setOuterData(enclosing.getSymbolData());", "+        // See if this is a partially qualified field reference in the symbol table", "+        type = enclosing.getInnerClassOrInterface(typeName);", "+//        System.err.println(\"For inner class/interface \" + typeName + \" found type \" + type);", "+      }", "+      ", "+      if (type == null) { // create a continuation for it", "+        String qualifiedTypeName = enclosing.getSymbolData().getName() + \".\" + typeName;", "+        if (_innerClassesToBeParsed.contains(qualifiedTypeName)) {  // reference to an inner class. Exclude .dj1 and .dj0 files?", "+          type = addInnerSymbolData(si, qualifiedTypeName, enclosing);", "+        }", "+        else { // reference to a top level class or an external class", "+          type = addSymbolData(si, typeName);", "+        }"]}], "num": 6586}