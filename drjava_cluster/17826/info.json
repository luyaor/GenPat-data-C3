{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "619efa991c94b503fa0760d986326208", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a3d800e15a83fba914faf09b88c014a6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/util/ReflectionUtilities.java", "commitBeforeChange": "1ef951d20d276f3c46e1cf20ba51ab4b6ce00f53", "commitAfterChange": "fe7c222597b4c2632fd01caf1fa72f992186277e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 9, "signatureBeforeChange": "   protected static Constructor selectTheMostSpecificConstructor(Constructor c1,                                                                 Constructor c2)", "signatureAfterChange": "   protected static Constructor selectTheMostSpecificConstructor(List<Constructor> list)", "diff": ["-  protected static Constructor selectTheMostSpecificConstructor(Constructor c1,", "-                                                                Constructor c2) {", "-    Class [] a1 = c1.getParameterTypes();", "-    Class [] a2 = c2.getParameterTypes();", "+  protected static Constructor selectTheMostSpecificConstructor(List<Constructor> list) {", "+    if (list.isEmpty()) return null;", "+    Iterator<Constructor> it = list.iterator();", "+    Constructor best = it.next();", "+    Constructor ambiguous = null; // there is no ambiguous other method at first", "+    while (it.hasNext()) {", "+      Constructor curr = it.next();", "+      Class[] a1 = best.getParameterTypes();", "+      Class[] a2 = curr.getParameterTypes();", "+      ", "+      boolean better1 = false; // whether 'best' is better than 'curr'", "+      boolean better2 = false; // whether 'curr' is better than 'best'", "+      for (int i = 0; i < a1.length; i++) {", "+        boolean from2to1 = isCompatible(a1[i], a2[i]);", "+        boolean from1to2 = isCompatible(a2[i], a1[i]);", "+        ", "+        if (from1to2 && !from2to1) {// best's parameter[i] is more specific than curr's", "+          better1 = true; // so best is better than curr", "+        }", "+        if (from2to1 && !from1to2) {// curr's parameter[i] is more specific than best's", "+          better2 = true; // so curr is better than best", "+        }", "+      }", "+      ", "+      // decide which is more specific or whether they are ambiguous", "+      if ( !(better1 ^ better2) ) { // neither is better than the other", "+        // Handle overridden methods", "+        if (Arrays.equals(a1, a2)) {", "+          Class c1 = best.getDeclaringClass();", "+          Class c2 = curr.getDeclaringClass();", "+          boolean c1IsSuperOrSame = c1.isAssignableFrom(c2);", "+          boolean c2IsSuperOrSame = c2.isAssignableFrom(c1);", "+          if (c1IsSuperOrSame && !c2IsSuperOrSame) { // c2 is more specific", "+            best = curr;", "+            continue;", "+          }", "+          else if (c2IsSuperOrSame && !c1IsSuperOrSame) { // c1 is more specific", "+            continue;", "+          }", "+        }", "+        ambiguous = curr;", "+      }", "+      else if (better2) {", "+        best = curr;", "+        ambiguous = null; // no more ambiguity", "+      }", "+    }", "+    if (ambiguous != null) {", "+      throw new AmbiguousMethodException(\"Both contructors match: \" + best + \", and \" + ambiguous);", "+    }", "+    return best;", "+  }", "-      if (a1[i] != a2[i]) {", "-        if (isCompatible(a1[i], a2[i])) {", "-          return c2;", "-        } else {", "-          return c1;", "-    ", "-    return c1;", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b5aaa3d121b1e1419be1d269ebfb99d5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/util/ReflectionUtilities.java", "commitBeforeChange": "1ef951d20d276f3c46e1cf20ba51ab4b6ce00f53", "commitAfterChange": "fe7c222597b4c2632fd01caf1fa72f992186277e", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 8, "signatureBeforeChange": "   public static List<Method> getVarArgsMethods(Class cl, String name, int params)", "signatureAfterChange": "   protected static Method selectTheMostSpecificMethod(List<Method> list)", "diff": ["-   */", "-  public static List<Method> getVarArgsMethods(Class cl, String name, int params) {", "-    List<Method>  result = new LinkedList<Method>();", "-    ", "-    if (cl.isInterface()) {", "-      Method[] ms = cl.getDeclaredMethods();", "-      for (int i = 0; i < ms.length; i++) {", "-        if (ms[i].getName().equals(name) &&", "-            ms[i].isVarArgs() &&  // Use new 1.5 API", "-            ms[i].getParameterTypes().length <= params) {", "-          result.add(ms[i]);", "-        }", "-      }", "-      Class[] cs = cl.getInterfaces();", "-      for (int i = 0; i < cs.length; i++) {", "-        result.addAll(getVarArgsMethods(cs[i], name, params));", "-      }", "-      if (cs.length == 0) {", "-        result.addAll(getVarArgsMethods(Object.class, name, params));", "-      }", "-    } ", "-              ms[i].isVarArgs() &&  // Use new 1.5 API", "-              ms[i].getParameterTypes().length <= params) {", "+  protected static Method selectTheMostSpecificMethod(List<Method> list) {", "+    if (list.isEmpty()) return null;", "+    Iterator<Method> it = list.iterator();", "+    Method best = it.next();", "+    Method ambiguous = null; // there is no ambiguous other method at first", "+    while (it.hasNext()) {", "+      Method curr = it.next();", "+      Class[] a1 = best.getParameterTypes();", "+      Class[] a2 = curr.getParameterTypes();", "+      ", "+      boolean better1 = false; // whether 'best' is better than 'curr'", "+      boolean better2 = false; // whether 'curr' is better than 'best'", "+      for (int i = 0; i < a1.length; i++) {", "+        boolean from2to1 = isCompatible(a1[i], a2[i]);", "+        boolean from1to2 = isCompatible(a2[i], a1[i]);", "+        ", "+        if (from1to2 && !from2to1) {// best's parameter[i] is more specific than curr's", "+          better1 = true; // so best is better than curr", "+        }", "+        if (from2to1 && !from1to2) {// curr's parameter[i] is more specific than best's", "+          better2 = true; // so curr is better than best", "+        }", "+      }", "+      ", "+      // decide which is more specific or whether they are ambiguous", "+      if ( !(better1 ^ better2) ) { // neither is better than the other", "+        // Handle overridden methods", "+        if (Arrays.equals(a1, a2)) {", "+          Class c1 = best.getDeclaringClass();", "+          Class c2 = curr.getDeclaringClass();", "+          boolean c1IsSuperOrSame = c1.isAssignableFrom(c2);", "+          boolean c2IsSuperOrSame = c2.isAssignableFrom(c1);", "+          if (c1IsSuperOrSame && !c2IsSuperOrSame) { // c2 is more specific", "+            best = curr;", "+            continue;", "+          }", "+          else if (c2IsSuperOrSame && !c1IsSuperOrSame) { // c1 is more specific", "+            continue;", "+          }", "+        }", "+        ambiguous = curr;", "+      }", "+      else if (better2) {", "+        best = curr;", "+        ambiguous = null; // no more ambiguity", "+    if (ambiguous != null) {", "+      throw new AmbiguousMethodException(\"Both methods match: \" + best + \", and \" + ambiguous);", "+    }", "+    return best;"]}], "num": 17826}