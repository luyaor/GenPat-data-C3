{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e14364074cbb1e6b1208b2904fcea501", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "18c647c492c56a6a725811b143494401", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/config/VectorOption.java", "commitBeforeChange": "ef7dc3345b6835fe8ebb574f1a9119ee4c786794", "commitAfterChange": "21836dcccd81c2207652ee85b319b723ac9ff10b", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "   public String format(Vector<T> v)", "signatureAfterChange": "   public String format(Vector<T> v)", "diff": ["+    if (v.size()==0) { return \"\"; }", "+    ", "+    String d = String.valueOf(delim);", "-      res.append(formatter.format(v.get(i)));", "+      String str = formatter.format(v.get(i));", "+      str = str.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\");", "+      str = str.replaceAll(\",\",\"\\\\\\\\,\");", "+      res.append(str);", "-    return res.append(footer).toString();", "+    String str = res.append(footer).toString();", "+    return str;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2c6269f517f5810cf64b3cd8e13ba53a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/Interpreter.java", "commitBeforeChange": "b125d4a35b225e9cc738f569b062e7e7bd7cf031", "commitAfterChange": "9ce155a1f3e34352032d821032cb2dc70024460f", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "      private Pair<RuntimeBindings, Option<Object>> evaluate(Iterable<Node> tree) throws InterpreterException", "signatureAfterChange": "      private Pair<RuntimeBindings, Option<Object>> evaluate(Iterable<Node> tree) throws InterpreterException", "diff": ["-        if (n instanceof Expression) { val = Option.some(new ExpressionEvaluator(newBindings, _opt).value(n)); }", "+        // TODO: eliminate hacks that support inferred assignment and void returns", "+        if (n.hasProperty(\"assignmentAsDeclaration\")) {", "+          n = (Node) n.getProperty(\"assignmentAsDeclaration\");", "+        }", "+        if (n instanceof Expression) {", "+          Object evalResult = new ExpressionEvaluator(newBindings, _opt).value(n);", "+          if (evalResult == null && NodeProperties.getType(n).equals(TypeSystem.VOID)) {", "+            val = Option.none();", "+          }", "+          else { val = Option.some(evalResult); }", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "efdd81565edb259d20c3ce3c80eea89e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/StatementChecker.java", "commitBeforeChange": "b125d4a35b225e9cc738f569b062e7e7bd7cf031", "commitAfterChange": "9ce155a1f3e34352032d821032cb2dc70024460f", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "   @Override public TypeContext visit(VariableDeclaration node)", "signatureAfterChange": "   @Override public TypeContext visit(VariableDeclaration node)", "diff": ["-    Type t = checkTypeName(node.getType());", "-    LocalVariable v = new LocalVariable(node.getName(), t, node.isFinal());", "-    setVariable(node, v);", "-    TypeContext newContext = new LocalContext(context, v);", "-    ", "-    if (node.getInitializer() != null) {", "-      Type initT = checkType(node.getInitializer(), t);", "-      try {", "-        Expression newInit = ts.assign(t, node.getInitializer());", "-        node.setInitializer(newInit);", "-      }", "-      catch (UnsupportedConversionException e) {", "-        setErrorStrings(node, ts.userRepresentation(initT), ts.userRepresentation(t));", "-        throw new ExecutionError(\"assignment.types\", node);", "-      }", "+    if (node.getType() == null) {", "+      // We infer the variable's type.  We can assume the initializer is non-null.", "+      Type initT = checkType(node.getInitializer());", "+      LocalVariable v = new LocalVariable(node.getName(), initT, node.isFinal());", "+      setVariable(node, v);", "+      return new LocalContext(context, v);", "-    ", "-    return newContext;", "+    else {", "+      Type t = checkTypeName(node.getType());", "+      LocalVariable v = new LocalVariable(node.getName(), t, node.isFinal());", "+      setVariable(node, v);", "+      TypeContext newContext = new LocalContext(context, v);", "+      ", "+      if (node.getInitializer() != null) {", "+        Type initT = checkType(node.getInitializer(), t);", "+        try {", "+          Expression newInit = ts.assign(t, node.getInitializer());", "+          node.setInitializer(newInit);", "+        }", "+        catch (UnsupportedConversionException e) {", "+          setErrorStrings(node, ts.userRepresentation(initT), ts.userRepresentation(t));", "+          throw new ExecutionError(\"assignment.types\", node);", "+        }", "+      }", "+      return newContext;", "+    }"]}], "num": 29788}