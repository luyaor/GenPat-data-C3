{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1341ed9b74d8bef3e46818d28a8b688b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f8e9027e1716ba69c419f948abc24015", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "4ebe3c86a9c7402a414ee21bfa81b87bb3fb5032", "commitAfterChange": "a80c90b8428392cd32bdf80517cd25701896680b", "methodNumberBeforeChange": 100, "methodNumberAfterChange": 100, "signatureBeforeChange": "               public void testGetSymbolDataHelper()", "signatureAfterChange": "               public void testGetSymbolDataHelper()", "diff": ["-      assertEquals(\"should return the int SymbolData\", SymbolData.INT_TYPE, _llv.getSymbolDataHelper(\"int\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "-      assertEquals(\"should return the byte SymbolData\", SymbolData.BYTE_TYPE, _llv.getSymbolDataHelper(\"byte\", JExprParser.NO_SOURCE_INFO, false, false, false, true));", "+      assertEquals(\"should return the int SymbolData\", SymbolData.INT_TYPE, ", "+                   _llv.getSymbolDataHelper(\"int\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "+      assertEquals(\"should return the byte SymbolData\", SymbolData.BYTE_TYPE, ", "+                   _llv.getSymbolDataHelper(\"byte\", JExprParser.NO_SOURCE_INFO, false, false, false, true));", "-      ad.getVars().get(0).setEnclosingData(result);  //This is a hack, because .equals() on variable datas compares their enclosing datas with ==.", "+      ad.getVars().get(0).setEnclosingData(result);  //.equals(...) on VariableData compares enclosing datas with ==.", "-      assertEquals(\"should return the same sd\", sd, _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "+      assertEquals(\"should return the same sd\", sd, ", "+                   _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "-      assertEquals(\"should return the now resolved sd\", sd, _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "+      assertEquals(\"should return the now resolved sd\", sd, ", "+                   _llv.getSymbolDataHelper(\"java.lang.System\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "-      ElementaryVisitor bv = new ElementaryVisitor(new File(\"\"), errors, symbolTable, continuations, new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>(), _newSDs);", "+      ElementaryVisitor bv = new ElementaryVisitor(new File(\"\"), errors, symbolTable, continuations, ", "+                                                   new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>(), _newSDs);", "-      _llv._classesToBeParsed.put(\"fully.qualified.Qwerty\", ", "-                                  new Pair<TypeDefBase, LanguageLevelVisitor>(", "-                                                                              new ClassDef(JExprParser.NO_SOURCE_INFO, ", "-                                                                                           _packageMav, ", "-                                                                                           new Word(JExprParser.NO_SOURCE_INFO, \"Qwerty\"),", "-                                                                                           new TypeParameter[0],", "-                                                                                           new ClassOrInterfaceType(JExprParser.NO_SOURCE_INFO, \"Object\", new Type[0]),", "-                                                                                           new ReferenceType[0], ", "-                                                                                           new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0])),", "-                                                                              bv));", "-      assertEquals(\"should return sd the continuation\", sd, bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "+      ClassDef cd = new ClassDef(JExprParser.NO_SOURCE_INFO, ", "+                                 _packageMav, ", "+                                 new Word(JExprParser.NO_SOURCE_INFO, \"Qwerty\"),", "+                                 new TypeParameter[0],", "+                                 new ClassOrInterfaceType(JExprParser.NO_SOURCE_INFO, \"Object\", new Type[0]),", "+                                 new ReferenceType[0], ", "+                                 new BracedBody(JExprParser.NO_SOURCE_INFO, new BodyItemI[0]));", "+      _llv._classesToBeParsed.put(\"fully.qualified.Qwerty\", new Pair<TypeDefBase, LanguageLevelVisitor>(cd, bv));", "+      assertEquals(\"should return sd the continuation\", sd, ", "+                   bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "-      assertEquals(\"should return sd, now resolved\", sd, bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "+      assertEquals(\"should return sd, now resolved\", sd, ", "+                   bv.getSymbolDataHelper(\"Qwerty\", JExprParser.NO_SOURCE_INFO, true, true, true, true));", "-      assertEquals(\"should find the continuation in the symbol table\", sd, _llv.getSymbolDataHelper(\"c\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "+      assertEquals(\"should find the continuation in the symbol table\", sd, ", "+                   _llv.getSymbolDataHelper(\"c\", JExprParser.NO_SOURCE_INFO, false, true, true, true));", "-      assertEquals(\"should find the resolved symbol data in the symbol table\", sd2, _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "+      assertEquals(\"should find the resolved symbol data in the symbol table\", sd2, ", "+                   _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, true, false, true, true));", "-      assertEquals(\"should find the unresolved symbol data in the symbol table\", sd2, _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, false, true, true));", "+      assertEquals(\"should find the unresolved symbol data in the symbol table\", sd2, ", "+                   _llv.getSymbolDataHelper(\"Woah\", JExprParser.NO_SOURCE_INFO, false, false, true, true));", "-      //Test that if class name is ambiguous (i.e. it is unqualified, and matches unqualified names in 2 or more packages.", "+      // Test ambiguous class name (i.e. it is unqualified, and matches unqualified names in 2 or more packages.", "-      assertEquals(\"The error message should be correct\", \"The class name String is ambiguous.  It could be java.lang.String or random.package.String\", errors.get(0).getFirst());", "+      assertEquals(\"The error message should be correct\", \"The class name String is ambiguous.\" + ", "+                   \"  It could be java.lang.String or random.package.String\", ", "+                   errors.get(0).getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ff5ac2f8e08b5b9b96b34d6eb326ca02", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "95fc34f702728d19ab12beabcddae9a69d422c00", "commitAfterChange": "5607cf775ad2ef70ccd49a101fe31fb06f6903bb", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 76, "signatureBeforeChange": "          public void testForClassDef()", "signatureAfterChange": "          public void testForClassDef()", "diff": ["-      assertEquals(\"The tenth error message should be correct\", \"Hspia extends TestCase and thus must be explicitly declared public\" , errors.get(9).getFirst());", "-      assertEquals(\"The eleventh error message should be correct\", \"Class Hspia does not have any valid test methods.  Test methods must be declared public, must return void, and must start with the word \\\"test\\\"\" , errors.get(10).getFirst());", "+      assertEquals(\"The tenth error message should be correct\", ", "+                   \"Hspia extends TestCase and thus must be explicitly declared public\" , ", "+                   errors.get(9).getFirst());", "+      assertEquals(\"The eleventh error message should be correct\", ", "+                   \"Class Hspia does not have any valid test methods.  Test methods must be declared public, \" +", "+                   \"must return void, and must start with the word \\\"test\\\"\" , ", "+                   errors.get(10).getFirst());", "-      assertEquals(\"There should now be 12 errors\", 12, errors.size());", "-      assertEquals(\"The 12th error message should be correct\", \"Class Hspia does not have any valid test methods.  Test methods must be declared public, must return void, and must start with the word \\\"test\\\"\" , errors.get(11).getFirst());", "+      assertEquals(\"There should still be 11 errors\", 11, errors.size());  // Generated duplicate error message", "+      assertEquals(\"The 12th error message should be correct\", ", "+                   \"Class Hspia does not have any valid test methods.  Test methods must be declared public, \" +", "+                   \"must return void, and must start with the word \\\"test\\\"\" , ", "+                   errors.get(10).getFirst());"]}], "num": 10682}