{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "23fe0a242b0541f6aeba1d75b127539a", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39be69d15629c5e03c9cacbcacbf0f2b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "f835199d645f480bb352cc51cff6dc5ae32e7dc4", "commitAfterChange": "f25bc20d2dd4058b4cf2bf5f693569e62fb40d6b", "methodNumberBeforeChange": 163, "methodNumberAfterChange": 162, "signatureBeforeChange": "   private ConstraintSet inferFromSupertype(final Type arg, final Type param,                                            final Set<? extends VariableType> vars,                                             final RecursionStack3<Type, Type, InferenceMode> stack)", "signatureAfterChange": "          public ConstraintFormula supertypeNorm(final Type arg, final Type param)", "diff": ["-   */", "-  private ConstraintSet inferFromSupertype(final Type arg, final Type param,", "-                                           final Set<? extends VariableType> vars, ", "-                                           final RecursionStack3<Type, Type, InferenceMode> stack) {", "-    //debug.logValues(new String[]{ \"arg\", \"param\" }, wrap(arg), wrap(param));", "-    if (containsInferenceVariable(param, vars)) {", "-      return param.apply(new TypeAbstractVisitor<ConstraintSet>() {", "-        public ConstraintSet defaultCase(Type param) { throw new IllegalArgumentException(); }", "-        ", "-        @Override public ConstraintSet forArrayType(final ArrayType param) {", "-          return arg.apply(new TypeAbstractVisitor<ConstraintSet>() {", "-            public ConstraintSet defaultCase(Type arg) { return UNSATISFIABLE_CONSTRAINTS; }", "-            @Override public ConstraintSet forVariableType(VariableType arg) { return handleVariableArg(arg); }", "-            @Override public ConstraintSet forIntersectionType(IntersectionType arg) { return handleIntersectionArg(arg); }", "-            @Override public ConstraintSet forTopType(TopType arg) { return EMPTY_CONSTRAINTS; }", "-            @Override public ConstraintSet forArrayType(ArrayType arg) {", "-              if (isPrimitive(arg.ofType())) { ", "-                return inferFromEqual(arg.ofType(), param.ofType(), vars, stack);", "-              }", "-              else { return inferFromSupertype(arg.ofType(), param.ofType(), vars, stack); }", "-            }", "-            ", "-            @Override public ConstraintSet forClassType(ClassType arg) {", "-              return inferFromSupertype(arg, CLONEABLE_AND_SERIALIZABLE, vars, stack);", "-            }", "-          });", "-        }", "-        ", "-        @Override public ConstraintSet forParameterizedClassType(final ParameterizedClassType param) {", "-          return arg.apply(new TypeAbstractVisitor<ConstraintSet>() {", "-            public ConstraintSet defaultCase(Type arg) { return UNSATISFIABLE_CONSTRAINTS; }", "-            @Override public ConstraintSet forVariableType(VariableType arg) { return handleVariableArg(arg); }", "-            @Override public ConstraintSet forIntersectionType(IntersectionType arg) { return handleIntersectionArg(arg); }", "-            @Override public ConstraintSet forTopType(TopType arg) { return EMPTY_CONSTRAINTS; }", "-            ", "-            @Override public ConstraintSet forSimpleClassType(SimpleClassType arg) {", "-              Type paramSuper = immediateSupertype(param);", "-              if (paramSuper == null) { return UNSATISFIABLE_CONSTRAINTS; }", "-              else { return inferFromSupertype(arg, paramSuper, vars, stack); }", "-            }", "-            ", "-            @Override public ConstraintSet forRawClassType(RawClassType arg) {", "-              Type paramSuper = immediateSupertype(param);", "-              if (paramSuper == null) { return UNSATISFIABLE_CONSTRAINTS; }", "-              else { return inferFromSupertype(arg, paramSuper, vars, stack); }", "-            }", "-            ", "-            @Override public ConstraintSet forParameterizedClassType(final ParameterizedClassType arg) {", "-              ConstraintSet matchConstraints = UNSATISFIABLE_CONSTRAINTS;", "-              if (param.ofClass().equals(arg.ofClass())) {", "-                Thunk<ConstraintSet> recurOnTargs = new Thunk<ConstraintSet>() {", "-                  public ConstraintSet value() {", "-                    ParameterizedClassType paramCap = capture(param);", "-                    ConstraintSet result = EMPTY_CONSTRAINTS;", "-                    for (Pair<Type, Type> pair : IterUtil.zip(arg.typeArguments(), paramCap.typeArguments())) {", "-                      Type argArg = pair.first();", "-                      final Type paramArg = pair.second();", "-                      result = result.and(argArg.apply(new TypeAbstractVisitor<ConstraintSet>() {", "-                        public ConstraintSet defaultCase(Type argArg) {", "-                          ConstraintSet nonWildS = inferFromEqual(argArg, paramArg, vars, stack);", "-                          return nonWildS;", "-                        }", "-                        @Override public ConstraintSet forWildcard(Wildcard argArg) {", "-                          ConstraintSet cs = inferFromSubtype(argArg.symbol().lowerBound(), paramArg, vars, stack);", "-                          if (cs.isSatisfiable()) {", "-                            cs = cs.and(inferFromSupertype(argArg.symbol().upperBound(), paramArg, vars, stack));", "-                          }", "-                          return cs;", "-                        }", "-                      }));", "-                      if (!result.isSatisfiable()) { break; }", "-                    }", "-                    return result;", "-                  }", "-                };", "-                matchConstraints = stack.apply(recurOnTargs, EMPTY_CONSTRAINTS, arg, param, ", "-                                               InferenceMode.SUPERTYPE);", "-              }", "-              ", "-              ConstraintSet superConstraints = UNSATISFIABLE_CONSTRAINTS;", "-              Type paramSuper = immediateSupertype(param);", "-              if (paramSuper != null) { superConstraints = inferFromSupertype(arg, paramSuper, vars, stack); }", "-              ", "-              return matchConstraints.or(superConstraints);", "-            }", "-          });", "-        }", "-        ", "-        @Override public ConstraintSet forVariableType(final VariableType param) {", "-          // Note that this might be a capture variable with an inference-variable bound", "-          if (vars.contains(param)) {", "-            return EMPTY_CONSTRAINTS.andUpperBound(param, arg);", "-          }", "-          else {", "-            Thunk<ConstraintSet> recurOnUpperBound = new Thunk<ConstraintSet>() {", "-              public ConstraintSet value() {", "-                return arg.apply(new TypeAbstractVisitor<ConstraintSet>() {", "-                  public ConstraintSet defaultCase(Type arg) {", "-                    return inferFromSupertype(arg, param.symbol().upperBound(), vars, stack);", "-                  }", "-                  ", "-                  @Override public ConstraintSet forVariableType(VariableType arg) {", "-                    ConstraintSet cs1 = inferFromSupertype(arg, param.symbol().upperBound(), vars, stack);", "-                    ConstraintSet cs2 = inferFromSupertype(arg.symbol().lowerBound(), param, vars, stack);", "-                    return cs1.or(cs2);", "-                  }", "-                  ", "-                  @Override public ConstraintSet forIntersectionType(IntersectionType arg) { ", "-                    return handleIntersectionArg(arg);", "-                  }", "-                  ", "-                  @Override public ConstraintSet forTopType(TopType arg) { return EMPTY_CONSTRAINTS; }", "-                });", "-              }", "-            };", "-            return stack.apply(recurOnUpperBound, UNSATISFIABLE_CONSTRAINTS, arg, param, ", "-                               InferenceMode.SUPERTYPE);", "-          }", "-        }", "-        ", "-        @Override public ConstraintSet forIntersectionType(final IntersectionType param) {", "-          return arg.apply(new TypeAbstractVisitor<ConstraintSet>() {", "-            ", "-            public ConstraintSet defaultCase(Type arg) {", "-              ConstraintSet result = UNSATISFIABLE_CONSTRAINTS;", "-              for (Type supParam : param.ofTypes()) {", "-                result = result.or(inferFromSupertype(arg, supParam, vars, stack));", "-                if (result.isEmpty()) { break; }", "-              }", "-              return result;", "-            }", "-            ", "-            @Override public ConstraintSet forVariableType(final VariableType arg) {", "-              Thunk<ConstraintSet> recurOnBound = new Thunk<ConstraintSet>() {", "-                public ConstraintSet value() {", "-                  return inferFromSupertype(arg.symbol().lowerBound(), param, vars, stack);", "-              ConstraintSet result = stack.apply(recurOnBound, UNSATISFIABLE_CONSTRAINTS, arg, param,", "-                                                 InferenceMode.SUPERTYPE);", "-              for (Type supParam : param.ofTypes()) {", "-                result = result.or(inferFromSupertype(arg, supParam, vars, stack));", "-            @Override public ConstraintSet forIntersectionType(IntersectionType arg) { return handleIntersectionArg(arg); }", "-            ", "-            @Override public ConstraintSet forTopType(TopType arg) { return EMPTY_CONSTRAINTS; }", "-          });", "-        }", "-        ", "-        @Override public ConstraintSet forWildcard(final Wildcard param) {", "-          return arg.apply(new TypeAbstractVisitor<ConstraintSet>() {", "-            public ConstraintSet defaultCase(Type arg) { return UNSATISFIABLE_CONSTRAINTS; }", "-            @Override public ConstraintSet forVariableType(VariableType arg) { return handleVariableArg(arg); }", "-            @Override public ConstraintSet forIntersectionType(IntersectionType arg) { return handleIntersectionArg(arg); }", "-            @Override public ConstraintSet forWildcard(Wildcard arg) { ", "-              return inferFromEqual(arg, param, vars, stack);", "-            }", "-            @Override public ConstraintSet forTopType(TopType arg) { return EMPTY_CONSTRAINTS; }", "-          });", "-        }", "-        ", "-        private ConstraintSet handleVariableArg(final VariableType arg) {", "-          Thunk<ConstraintSet> recurOnBound = new Thunk<ConstraintSet>() {", "-            public ConstraintSet value() {", "-              return inferFromSupertype(arg.symbol().lowerBound(), param, vars, stack);", "-            }", "-          };", "-          return stack.apply(recurOnBound, UNSATISFIABLE_CONSTRAINTS, arg, param, InferenceMode.SUPERTYPE);", "-        }", "-        ", "-        private ConstraintSet handleIntersectionArg(IntersectionType arg) {", "-          ConstraintSet result = EMPTY_CONSTRAINTS;", "-          for (Type supArg : arg.ofTypes()) { ", "-            result = result.and(inferFromSupertype(supArg, param, vars, stack));", "-            if (!result.isSatisfiable()) { break; }", "-          }", "-          return result;", "-        }", "-      });", "-    }", "-    else {", "-      return (isSubtype(param, arg)) ? EMPTY_CONSTRAINTS : UNSATISFIABLE_CONSTRAINTS;", "-    }", "-  }", "+    ", "+    public ConstraintFormula supertypeNorm(final Type arg, final Type param) {", "+      //debug.logValues(new String[]{ \"arg\", \"param\" }, wrap(arg), wrap(param));", "+      if (!param.apply(_containsVar)) { return new NormSubtype().contains(param, arg) ? TRUE : FALSE; }", "+      else {", "+        return param.apply(new TypeAbstractVisitor<ConstraintFormula>() {", "+          ", "+          class ArgVisitor extends TypeAbstractVisitor<ConstraintFormula> {", "+            @Override public ConstraintFormula defaultCase(Type arg) { return FALSE; }", "+            @Override public ConstraintFormula forTopType(TopType arg) { return TRUE; }", "+            ", "+            @Override public ConstraintFormula forVariableType(final VariableType arg) {", "+              Thunk<ConstraintFormula> recurOnBound = new Thunk<ConstraintFormula>() {", "+                public ConstraintFormula value() {", "+                  return supertypeNorm(NORMALIZE.value(arg.symbol().lowerBound()), param);", "+                }", "+              };", "+              Thunk<ConstraintFormula> infiniteCase = new Thunk<ConstraintFormula>() {", "+                public ConstraintFormula value() { return supertypeNorm(NULL, param); }", "+              };", "+              return _subStack.apply(recurOnBound, infiniteCase, arg, param);", "+            }", "+            ", "+            @Override public ConstraintFormula forIntersectionType(IntersectionType arg) {", "+              ConstraintFormula result = TRUE;", "+              for (Type supArg : arg.ofTypes()) {", "+                result = result.and(supertypeNorm(supArg, param));", "+                if (!result.isSatisfiable()) { break; }", "+              }", "+              return result;", "+            }", "+            ", "+            @Override public ConstraintFormula forUnionType(UnionType arg) {", "+              ConstraintFormula result = FALSE;", "+              for (Type subArg : arg.ofTypes()) {", "+                result = result.or(supertypeNorm(subArg, param));", "+          ", "+          public ConstraintFormula defaultCase(Type param) { throw new IllegalArgumentException(); }", "+          ", "+          @Override public ConstraintFormula forArrayType(final ArrayType param) {", "+            return arg.apply(new ArgVisitor() {", "+              @Override public ConstraintFormula forArrayType(ArrayType arg) {", "+                if (isPrimitive(arg.ofType())) { return equivalentNorm(arg.ofType(), param.ofType()); }", "+                else { return supertypeNorm(arg.ofType(), param.ofType()); }", "+              }", "+              @Override public ConstraintFormula forClassType(ClassType arg) {", "+                return supertypeNorm(arg, CLONEABLE_AND_SERIALIZABLE);", "+              }", "+            });", "+          }", "+          ", "+          @Override public ConstraintFormula forParameterizedClassType(final ParameterizedClassType param) {", "+            return arg.apply(new ArgVisitor() {", "+              ", "+              @Override public ConstraintFormula forClassType(ClassType arg) {", "+                Type paramSuper = immediateSupertype(param);", "+                if (paramSuper == null) { return FALSE; }", "+                else { return supertypeNorm(arg, paramSuper); }", "+              }", "+              ", "+              @Override public ConstraintFormula forParameterizedClassType(final ParameterizedClassType arg) {", "+                ConstraintFormula cf = FALSE;", "+                if (param.ofClass().equals(arg.ofClass())) {", "+                  Thunk<ConstraintFormula> recurOnTargs = new Thunk<ConstraintFormula>() {", "+                    public ConstraintFormula value() {", "+                      ParameterizedClassType paramCap = capture(param);", "+                      ConstraintFormula result = TRUE;", "+                      for (Pair<Type, Type> pair : IterUtil.zip(arg.typeArguments(), paramCap.typeArguments())) {", "+                        final Type argArg = pair.first();", "+                        final Type paramArg = pair.second();", "+                        result = result.and(argArg.apply(new TypeAbstractVisitor<ConstraintFormula>() {", "+                          public ConstraintFormula defaultCase(Type argArg) { ", "+                            return equivalentNorm(argArg, paramArg);", "+                          }", "+                          @Override public ConstraintFormula forWildcard(Wildcard argArg) {", "+                            ConstraintFormula wildResult = subtypeNorm(argArg.symbol().lowerBound(), paramArg);", "+                            if (wildResult.isSatisfiable()) {", "+                              wildResult = wildResult.and(supertypeNorm(argArg.symbol().upperBound(), paramArg));", "+                            }", "+                            return wildResult;", "+                          }", "+                        }));", "+                        if (!result.isSatisfiable()) { break; }", "+                      }", "+                      return result;", "+                    }", "+                  };", "+                  cf = _supStack.apply(recurOnTargs, FALSE, arg, param);", "+                }", "+                if (!cf.isEmpty()) { cf = cf.or(forClassType(arg)); }", "+                return cf;", "+              }", "+", "+            });", "+          }", "+          ", "+          @Override public ConstraintFormula forVariableType(final VariableType param) {", "+            // Note that this might be a capture variable with an inference-variable bound", "+            if (_vars.contains(param)) { return upperBound(param, arg); }", "+            else {", "+              return arg.apply(new ArgVisitor() {", "+                ", "+                @Override public ConstraintFormula defaultCase(final Type arg) {", "+                  Thunk<ConstraintFormula> recurOnBound = new Thunk<ConstraintFormula>() {", "+                    public ConstraintFormula value() {", "+                      return supertypeNorm(arg, NORMALIZE.value(param.symbol().upperBound()));", "+                    }", "+                  };", "+                  Thunk<ConstraintFormula> infiniteCase = new Thunk<ConstraintFormula>() {", "+                    public ConstraintFormula value() { return supertypeNorm(arg, OBJECT); }", "+                  };", "+                  return _supStack.apply(recurOnBound, infiniteCase, arg, param);", "+                }", "+                ", "+                @Override public ConstraintFormula forVariableType(VariableType arg) {", "+                  ConstraintFormula result = defaultCase(arg);", "+                  if (!result.isEmpty()) { result = result.or(super.forVariableType(arg)); }", "+                  return result;", "+                }", "+                ", "+                @Override public ConstraintFormula forUnionType(UnionType arg) {", "+                  ConstraintFormula result = defaultCase(arg);", "+                  if (!result.isEmpty()) { result = result.or(super.forUnionType(arg)); }", "+                  return result;", "+                }", "+                ", "+              });", "+            }", "+          }", "+          ", "+          @Override public ConstraintFormula forIntersectionType(final IntersectionType param) {", "+            return arg.apply(new ArgVisitor() {", "+              @Override public ConstraintFormula defaultCase(Type arg) {", "+                ConstraintFormula result = FALSE;", "+                for (Type supParam : param.ofTypes()) {", "+                  result = result.or(supertypeNorm(arg, supParam));", "+                  if (result.isEmpty()) { break; }", "+              @Override public ConstraintFormula forVariableType(VariableType arg) {", "+                ConstraintFormula result = defaultCase(arg);", "+                if (!result.isEmpty()) { result = result.or(super.forVariableType(arg)); }", "+                return result;", "+              }", "+              @Override public ConstraintFormula forUnionType(UnionType arg) { return defaultCase(arg); }", "+            });", "+          ", "+          @Override public ConstraintFormula forUnionType(final UnionType param) {", "+            return arg.apply(new ArgVisitor() {", "+              @Override public ConstraintFormula defaultCase(Type arg) {", "+                ConstraintFormula result = TRUE;", "+                for (Type subParam : param.ofTypes()) {", "+                  result = result.and(supertypeNorm(arg, subParam));", "+                  if (!result.isSatisfiable()) { break; }", "+                }", "+                return result;", "+              }", "+              @Override public ConstraintFormula forVariableType(VariableType arg) { return defaultCase(arg); }", "+              @Override public ConstraintFormula forIntersectionType(IntersectionType arg) { return defaultCase(arg); }", "+              @Override public ConstraintFormula forUnionType(UnionType arg) { return defaultCase(arg); }", "+            });", "+          }", "+          ", "+        });", "+      }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "570b2c4bd536dd4348dfa5067433a175", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DocumentRegionTest.java", "commitBeforeChange": "1ff154e9eb4de7b8f07ce9a8120997b76e53aa3f", "commitAfterChange": "50372cdcb0e3a8db5661a31f5825b5dc9f07a9e9", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "   public void testRegionManager() throws BadLocationException", "signatureAfterChange": "   public void testRegionManager() throws BadLocationException", "diff": ["-    assertNull(rm.getRegionContaining(_doc, 5, 5));", "-    assertNull(rm.getRegionContaining(_doc, 4, 6));", "-    assertNull(rm.getRegionContaining(_doc, 3, 7));", "-    assertNull(rm.getRegionContaining(_doc, 2, 8));", "-    assertNull(rm.getRegionContaining(_doc, 2, 5));", "-    assertNull(rm.getRegionContaining(_doc, 5, 8));", "+    ", "+    assertTrue(\"Empty overlapping regions\", rm.getRegionsOverlapping(_doc, 5, 5).size() == 0);", "+    assertTrue(\"Empty overlapping regions\", rm.getRegionsOverlapping(_doc, 4, 6).size() == 0);", "+    assertTrue(\"Empty overlapping regions\", rm.getRegionsOverlapping(_doc, 3, 7).size() == 0);", "+    assertTrue(\"Empty overlapping regions\", rm.getRegionsOverlapping(_doc, 2, 8).size() == 0);", "+    assertTrue(\"Empty overlapping regions\", rm.getRegionsOverlapping(_doc, 2, 5).size() == 0);", "+    assertTrue(\"Empty overlapping regions\", rm.getRegionsOverlapping(_doc, 5, 8).size() == 0);", "-    assertTrue(r1==rm.getRegionAt(_doc, 5));", "-    assertTrue(r1==rm.getRegionAt(_doc, 3));", "-    assertTrue(r1==rm.getRegionAt(_doc, 7));", "+    assertTrue(\"Region found\", r1 == rm.getRegionAt(_doc, 5));", "+    assertTrue(\"Region found\", r1 == rm.getRegionAt(_doc, 3));", "+    assertTrue(\"Region found\", r1 == rm.getRegionAt(_doc, 4));", "+    assertTrue(\"Region found\", r1 == rm.getRegionAt(_doc, 6));", "+    ", "+    assertNull(rm.getRegionAt(_doc, 7));", "-    assertTrue(r1==rm.getRegionContaining(_doc, 5, 5));", "-    assertTrue(r1==rm.getRegionContaining(_doc, 4, 6));", "-    assertTrue(r1==rm.getRegionContaining(_doc, 3, 7));", "-    assertNull(rm.getRegionContaining(_doc, 2, 8));", "-    assertNull(rm.getRegionContaining(_doc, 2, 5));", "-    assertNull(rm.getRegionContaining(_doc, 5, 8));", "+    ", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 5, 6).contains(r1));", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 4, 6).contains(r1));", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 3, 7).contains(r1));", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 2, 3).size() == 0);", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 5, 5).size() == 0);", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 5, 8).contains(r1));", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 15, 18).size() == 0);", "-    assertNull(rm.getRegionContaining(_doc, 15, 15));", "-    assertNull(rm.getRegionContaining(_doc, 14, 16));", "-    assertNull(rm.getRegionContaining(_doc, 13, 17));", "-    assertNull(rm.getRegionContaining(_doc, 12, 18));", "-    assertNull(rm.getRegionContaining(_doc, 12, 15));", "-    assertNull(rm.getRegionContaining(_doc, 15, 18));", "+", "-    assertTrue(r2==rm.getRegionAt(_doc, 15));", "-    assertTrue(r2==rm.getRegionAt(_doc, 13));", "-    assertTrue(r2==rm.getRegionAt(_doc, 17));", "+    assertTrue(r2 == rm.getRegionAt(_doc, 15));", "+    assertTrue(r2 == rm.getRegionAt(_doc, 13));", "+    assertNull(rm.getRegionAt(_doc, 17));", "-    assertTrue(r2==rm.getRegionContaining(_doc, 15, 15));", "-    assertTrue(r2==rm.getRegionContaining(_doc, 14, 16));", "-    assertTrue(r2==rm.getRegionContaining(_doc, 13, 17));", "-    assertNull(rm.getRegionContaining(_doc, 12, 18));", "-    assertNull(rm.getRegionContaining(_doc, 12, 15));", "-    assertNull(rm.getRegionContaining(_doc, 15, 18)); ", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 15, 15).size() == 0);", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 0, 14).contains(r2));", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 14, 16).contains(r2));", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 10, 17).contains(r2));", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 10, 20).contains(r2));", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 16, 17).contains(r2));", "+", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 17, 18).size() == 0);", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 10, 13).size() == 0); ", "-    // r2 and r3 are the same region, so the region will be reused", "-    // and we get r2 back", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 6, 14).contains(r1)); ", "+    assertTrue(\"Region found\", rm.getRegionsOverlapping(_doc, 6, 14).contains(r2));", "+    ", "+//    // r2 and r3 are the same region, so the region will be reused", "+//    // and we get r2 back", "-    rm.addRegion(r3);", "-    assertTrue(r2==rm.getRegionAt(_doc, 15));", "-    assertTrue(r2==rm.getRegionAt(_doc, 13));", "-    assertTrue(r2==rm.getRegionAt(_doc, 17));", "-    assertNull(rm.getRegionAt(_doc, 12));", "-    assertNull(rm.getRegionAt(_doc, 18));", "-    assertTrue(r2==rm.getRegionContaining(_doc, 15, 15));", "-    assertTrue(r2==rm.getRegionContaining(_doc, 14, 16));", "-    assertTrue(r2==rm.getRegionContaining(_doc, 13, 17));", "-    assertNull(rm.getRegionContaining(_doc, 12, 18));", "-    assertNull(rm.getRegionContaining(_doc, 12, 15));", "-    assertNull(rm.getRegionContaining(_doc, 15, 18)); ", "+//    rm.addRegion(r3);", "+//    assertTrue(r2==rm.getRegionAt(_doc, 15));", "+//    assertTrue(r2==rm.getRegionAt(_doc, 13));", "+//    assertTrue(r2==rm.getRegionAt(_doc, 17));", "+//    assertNull(rm.getRegionAt(_doc, 12));", "+//    assertNull(rm.getRegionAt(_doc, 18));", "+//    assertTrue(r2==rm.getRegionsOverlapping(_doc, 15, 15));", "+//    assertTrue(r2==rm.getRegionsOverlapping(_doc, 14, 16));", "+//    assertTrue(r2==rm.getRegionsOverlapping(_doc, 13, 17));", "+//    assertNull(rm.getRegionsOverlapping(_doc, 12, 18));", "+//    assertNull(rm.getRegionsOverlapping(_doc, 12, 15));", "+//    assertNull(rm.getRegionsOverlapping(_doc, 15, 18)); ", "-    assertNull(rm.getRegionContaining(_doc, 15, 15));", "-    assertNull(rm.getRegionContaining(_doc, 14, 16));", "-    assertNull(rm.getRegionContaining(_doc, 13, 17));", "-    assertNull(rm.getRegionContaining(_doc, 12, 18));", "-    assertNull(rm.getRegionContaining(_doc, 12, 15));", "-    assertNull(rm.getRegionContaining(_doc, 15, 18)); ", "-", "-    assertNull(rm.getRegionAt(_doc, 15));", "-    assertNull(rm.getRegionAt(_doc, 13));", "-    assertNull(rm.getRegionAt(_doc, 17));", "-    assertNull(rm.getRegionAt(_doc, 12));", "-    assertNull(rm.getRegionAt(_doc, 18));", "-    assertNull(rm.getRegionContaining(_doc, 15, 15));", "-    assertNull(rm.getRegionContaining(_doc, 14, 16));", "-    assertNull(rm.getRegionContaining(_doc, 13, 17));", "-    assertNull(rm.getRegionContaining(_doc, 12, 18));", "-    assertNull(rm.getRegionContaining(_doc, 12, 15));", "-    assertNull(rm.getRegionContaining(_doc, 15, 18));", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 13, 15).size() == 0);", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 14, 16).size() == 0);", "+//    assertNull(rm.getRegionsOverlapping(_doc, 13, 17));", "+//    assertNull(rm.getRegionsOverlapping(_doc, 12, 18));", "+//    assertNull(rm.getRegionsOverlapping(_doc, 12, 15));", "+//    assertNull(rm.getRegionsOverlapping(_doc, 15, 18)); ", "-    assertNull(rm.getRegionContaining(_doc, 5, 5));", "-    assertNull(rm.getRegionContaining(_doc, 4, 6));", "-    assertNull(rm.getRegionContaining(_doc, 3, 7));", "-    assertNull(rm.getRegionContaining(_doc, 2, 8));", "-    assertNull(rm.getRegionContaining(_doc, 2, 5));", "-    assertNull(rm.getRegionContaining(_doc, 5, 8));", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 5, 5).size() == 0);", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 4, 6).size() == 0);", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 3, 7).size() == 0);", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 2, 8).size() == 0);", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 2, 5).size() == 0);", "+    assertTrue(\"No region found\", rm.getRegionsOverlapping(_doc, 5, 8).size() == 0);"]}], "num": 10775}