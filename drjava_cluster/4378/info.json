{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0bd459c0b46df5a956498097458075b8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ca6fcc85023c666978959fb88cf37963", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/InteractionsController.java", "commitBeforeChange": "d187ef0ae751d72da55c4bc4f82be93731c1e46f", "commitAfterChange": "d8ed07c181201a238142caf2537f1e0f6da8bb42", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "     public void insertUpdate(DocumentEvent e)", "signatureAfterChange": "   protected boolean _busy()", "diff": ["-  class CaretUpdateListener implements DocumentListener {", "-    public void insertUpdate(DocumentEvent e) {", "-      int caretPos = _pane.getCaretPosition();", "-      int promptPos = _doc.getPromptPos();", "-      int length = _doc.getDocLength();", "-      ", "-      // Figure out where the prompt was before the update", "-      int prevPromptPos = promptPos;", "-      if (e.getOffset() < promptPos) {", "-        // Insert happened before prompt,", "-        //  so previous position was further back", "-        prevPromptPos = promptPos - e.getLength();", "-      }", "-      if (_doc.inProgress()) {", "-        // Scroll to the end of the document, since output has been", "-        // inserted after the prompt.", "-        moveToEnd();", "-      }", "-      // (Be careful not to move caret during a reset, when the", "-      //  prompt pos is temporarily far greater than the length.)", "-      else if (promptPos <= length) {", "-        if (caretPos < prevPromptPos) {", "-          // Caret has fallen behind prompt, so make it catch up so", "-          //  the new input is visible.", "-          moveToPrompt();", "-        }", "-        else {", "-          // Caret was on or after prompt, so move it right by the size", "-          //  of the insert.", "-          int size = promptPos - prevPromptPos;", "-          if (size > 0) {", "-            moveTo(caretPos + size);", "-          }", "-        }", "-      }", "-    }", "+   */", "+  protected boolean _busy() {", "+    // should also check to see if we are resetting the interactions pane", "+    return _doc.inProgress();", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e975e0877d6e7a57c8046d83a3947a02", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/AbstractConsoleController.java", "commitBeforeChange": "29a551202c3bf7e5f026aad6d43ca029448c562d", "commitAfterChange": "eb5a40b971e537c8a9ca6a30686e2583abec6b86", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "     public void insertUpdate(final DocumentEvent e)", "signatureAfterChange": "     public void insertUpdate(final DocumentEvent e)", "diff": ["-      // Update caret position when text is inserted in document.  Fixes (?) bug #1571405.", "-          ", "+      /* Update caret position when text is inserted at end of document.  Fixes (?) bug #1571405.  The promptPos is", "+       * before the insertion is made so that this listener will see the udpated position. NOTE: The promptPos is NOT", "+       * a Swing Position; it is an int offset maintianed by ConsoleDocument.", "+       */", "-          int pos;", "-          final int docLen = doc.getLength();", "-          // if document has no prompt, place caret at end", "-          if (! doc.hasPrompt()) pos = docLen;", "-          else {", "-            ", "-            final int caretPos = _pane.getCaretPosition();", "-            final int promptPos = doc.getPromptPos();", "-            final int insertPos = e.getOffset();", "-            final int insertLen = e.getLength();", "-            final int prevPromptPos = (insertPos < promptPos) ? promptPos - insertLen : promptPos;", "-            // Figure out where the prompt was before the insertion", "-", "-          ", "-            if (caretPos < prevPromptPos /* || insertPos < promptPos */) {", "-              // Caret was behind prompt before insertion or insertion preceded the prompt  (why check for former?)", "-              pos = promptPos;  // place caret at prompt", "-            }", "-            else {", "-              // Caret and insertion were on or after prompt", "-              pos = Math.min(caretPos + insertLen, docLen);  // advance cursor by insertion size (but within document)", "-            }", "-          }", "-", "-          final int newPos = pos;  // make a final copy of pos that can appear in a closure", "+          final int newPos = getNewCaretPos(e, doc);", "+          // Update the caret position as part of the insertion if possible (running in event thread)", "-          else EventQueue.invokeLater(new Runnable() { public void run() { ", "-//            System.err.println(\"Deferred setting caretPos to \" + newPos);", "-            _pane.setCaretPos(newPos); ", "-          } });", "-            ", "-//          System.err.println(\"insertUpdate called; caretPos = \" + caretPos + \" docLength = \" + length);", "-          ", "-          /* Old Code: */", "-//      // Queue an asynchronous task in the event thread to update the document pane; Use SwingUtilities to ensure that", "-//      // the caret update is performed after the document update listeners have run.  Fixes (?) bug #1571405.", "-//      SwingUtilities.invokeLater(new Runnable() { ", "-//        public void run() {", "-//          ", "-//          ConsoleDocument doc = getConsoleDoc();", "-//          doc.acquireReadLock(); // Grab read lock because this code is NOT run as part of document listener!", "-//          try {", "-//            int caretPos = _pane.getCaretPosition();", "-//            int promptPos = doc.getPromptPos();", "-//            int len = doc.getLength();", "-//            ", "-////          System.err.println(\"insertUpdate called; caretPos = \" + caretPos + \" docLength = \" + length);", "-//            ", "-//            // Figure out where the prompt was before the update", "-//            int prevPromptPos = promptPos;", "-//            if (e.getOffset() < promptPos) {", "-//              // Insert happened before prompt,", "-//              //  so previous position was further back", "-//              prevPromptPos = promptPos - e.getLength();", "-//            }", "-//            ", "-//            if (! doc.hasPrompt()) {", "-////            System.err.println(\"Scrolling to end of document\");", "-//              // Scroll to the end of the document, since output has been inserted after the prompt.", "-//              moveToEnd();", "-//            }", "-//            // Do not to move caret during a reset, when the prompt pos is temporarily far greater than the length.", "-//            else if (promptPos <= len) {", "-//              if (caretPos < prevPromptPos) {", "-//                // Caret has fallen behind prompt, so make it catch up so", "-//                //  the new input is visible.", "-//                moveToPrompt();", "-//              }", "-//              else {", "-//                // Caret was on or after prompt, so move it right by the size", "-//                //  of the insert.", "-//                int size = promptPos - prevPromptPos;", "-//                if (size > 0) {", "-//                  int newCaretPos = caretPos + size;", "-//                  if (newCaretPos > len) newCaretPos = len;", "-//                  _pane.setCaretPosition(newCaretPos);", "-//                }", "-//              }", "-//            }", "-//          }", "-//          finally { doc.releaseReadLock(); }", "-//        }", "-//      });", "+          // Otherwise update it with a length filter in case the document has been shortedn (as in resetInteractions)", "+          else EventQueue.invokeLater(new Runnable() { public void run() { _pane.setCaretPos(newPos); } });", "+    }"]}], "num": 4378}