{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "22ac2fe5c3e479e5944a774321c04cdc", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "481911fa0eaa3a9a70729b15682cbb73", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/ClassInfoCompiler.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic Object visit(ConstructorInvocation node)", "signatureAfterChange": "     public Object visit(ConstructorInvocation node)", "diff": ["+    public Object visit(ConstructorInvocation node) {", "+      Expression exp = node.getExpression();", "+      if (exp == null) {", "+        ClassInfo sc  = classInfo.getSuperclass();", "+        ClassInfo sdc = sc.getDeclaringClass();", "+        ClassInfo dc  = classInfo.getDeclaringClass();", "+        ", "+        if (dc != null && dc.equals(sdc) &&", "+            !Modifier.isStatic(sc.getModifiers())) {", "+          List<IdentifierToken> l = new LinkedList<IdentifierToken>();", "+          l.add(new Identifier(\"param$0\"));", "+          exp = new QualifiedName(l);", "+          node.setExpression(exp);", "+        } else if (sdc != null &&", "+                   sdc.equals(classInfo.getAnonymousDeclaringClass()) &&", "+                   !Modifier.isStatic(sc.getModifiers())) {", "+          List<IdentifierToken> l = new LinkedList<IdentifierToken>();", "+          l.add(new Identifier(\"param$0\"));", "+          exp = new QualifiedName(l);", "+          node.setExpression(exp);", "+        }", "+      }", "+      ", "+      List<Expression> args = node.getArguments();", "+      if (exp != null) {", "+        if (args == null) {", "+          args = new LinkedList<Expression>();", "+          node.setArguments(args);", "+        }", "+        args.add(0, exp);", "+      }", "+      ", "+      if (args != null) {", "+        ListIterator<Expression> it = args.listIterator();", "+        while (it.hasNext()) {", "+          Object o = it.next().acceptVisitor(this);", "+          if (o != null) {", "+            if (o instanceof Expression) {", "+              it.set((Expression)o);", "+            } else {", "+              throw new ExecutionError(\"malformed.argument\", node);", "+            }", "+          }", "+        }", "+        ", "+        ConstructorInfo cons = null;", "+        try {", "+          ClassInfo[] params = null;", "+          it = args.listIterator();", "+          ", "+          int i = 0;", "+          params = new ClassInfo[args.size()];", "+          ", "+          while (it.hasNext()) {", "+            params[i++] = NodeProperties.getClassInfo((Expression)it.next());", "+          }", "+          if (node.isSuper()) {", "+            ClassInfo sc = classInfo.getSuperclass();", "+            cons = ClassInfoUtilities.lookupConstructor(sc, params);", "+            superConstructor = sc.getName();", "+          } else {", "+            cons = ClassInfoUtilities.lookupConstructor(classInfo, params);", "+            superConstructor = classInfo.getName();", "+          }", "+        } catch (NoSuchMethodException e) {", "+          throw new CatchedExceptionError(e, node);", "+        }", "+        ", "+        ClassInfo[] pt = cons.getParameterTypes();", "+        constructorParameters = new String[pt.length];", "+        for (int i = 0; i < pt.length; i++) {", "+          constructorParameters[i] = pt[i].getName();", "+        }", "+      }", "+      ", "+      if (superConstructor == null) {", "+        ClassInfo sc = classInfo.getSuperclass();", "+        superConstructor = sc.getName();", "+      }", "+      return null;", "-\t */", "-\tpublic Object visit(ConstructorInvocation node) {", "-\t    Expression exp = node.getExpression();", "-\t    if (exp == null) {", "-\t\tClassInfo sc  = classInfo.getSuperclass();", "-\t\tClassInfo sdc = sc.getDeclaringClass();", "-\t\tClassInfo dc  = classInfo.getDeclaringClass();", "-", "-\t\tif (dc != null && dc.equals(sdc) &&", "-\t\t    !Modifier.isStatic(sc.getModifiers())) {", "-\t\t    List l = new LinkedList();", "-\t\t    l.add(new Identifier(\"param$0\"));", "-\t\t    exp = new QualifiedName(l);", "-\t\t    node.setExpression(exp);", "-\t\t} else if (sdc != null &&", "-\t\t\t   sdc.equals(classInfo.getAnonymousDeclaringClass()) &&", "-\t\t\t   !Modifier.isStatic(sc.getModifiers())) {", "-\t\t    List l = new LinkedList();", "-\t\t    l.add(new Identifier(\"param$0\"));", "-\t\t    exp = new QualifiedName(l);", "-\t\t    node.setExpression(exp);", "-\t\t}", "-\t    }", "-", "-\t    List args = node.getArguments();", "-\t    if (exp != null) {", "-\t\tif (args == null) {", "-\t\t    args = new LinkedList();", "-\t\t    node.setArguments(args);", "-\t\t}", "-\t\targs.add(0, exp);", "-\t    }", "-", "-\t    if (args != null) {", "-\t\tListIterator it = args.listIterator();", "-\t\twhile (it.hasNext()) {", "-\t\t    Object o = ((Expression)it.next()).acceptVisitor(this);", "-\t\t    if (o != null) {", "-\t\t\tif (o instanceof Expression) {", "-\t\t\t    it.set(o);", "-\t\t\t} else {", "-\t\t\t    throw new ExecutionError(\"malformed.argument\", node);", "-\t\t\t}", "-\t\t    }", "-\t\t}", "-", "-\t\tConstructorInfo cons = null;", "-\t\ttry {", "-\t\t    ClassInfo[] params = null;", "-\t\t    it = args.listIterator();", "-", "-\t\t    int i = 0;", "-\t\t    params = new ClassInfo[args.size()];", "-", "-\t\t    while (it.hasNext()) {", "-\t\t\tparams[i++] = NodeProperties.getClassInfo((Expression)it.next());", "-\t\t    }", "-\t\t    if (node.isSuper()) {", "-\t\t\tClassInfo sc = classInfo.getSuperclass();", "-\t\t\tcons = ClassInfoUtilities.lookupConstructor(sc, params);", "-\t\t\tsuperConstructor = sc.getName();", "-\t\t    } else {", "-\t\t\tcons = ClassInfoUtilities.lookupConstructor(classInfo, params);", "-\t\t\tsuperConstructor = classInfo.getName();", "-\t\t    }", "-\t\t} catch (NoSuchMethodException e) {", "-\t\t    throw new CatchedExceptionError(e, node);", "-\t\t}", "-", "-\t\tClassInfo[] pt = cons.getParameterTypes();", "-\t\tconstructorParameters = new String[pt.length];", "-\t\tfor (int i = 0; i < pt.length; i++) {", "-\t\t    constructorParameters[i] = pt[i].getName();", "-\t\t}", "-\t    }", "-", "-\t    if (superConstructor == null) {", "-\t\tClassInfo sc = classInfo.getSuperclass();", "-\t\tsuperConstructor = sc.getName();", "-\t    }", "-\t    return null;", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eafb185b555a519ffc6677222fb94855", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/util/ImportationManager.java", "commitBeforeChange": "7d7f71637ac82cabd526a44e6c766574f76fc311", "commitAfterChange": "33c99bc453e2b8a224944d7334183adb0010fc32", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "     public Class lookupClass(String cname, String ccname) \tthrows ClassNotFoundException", "signatureAfterChange": "   public Class lookupClass(String cname, String ccname)     throws ClassNotFoundException", "diff": ["+   */", "+  public Class lookupClass(String cname, String ccname)", "+    throws ClassNotFoundException {", "+    String str = cname.replace('.', '$');", "+    ", "+    // Search for the full name ...", "+    ", "+    // ... in the current package ...", "+    String t = (currentPackage.equals(\"\"))", "+      ? cname", "+      : currentPackage + \".\" + cname; ", "+    try {", "+      return Class.forName(t, false, classLoader);", "+    } catch (ClassNotFoundException e) {", "+    ", "+    if (cname.indexOf('.') != -1) {", "+      try {", "+        return Class.forName(cname, false, classLoader);", "+      } catch (ClassNotFoundException e) {", "+      }", "+    ", "+    // try to find an inner class with this name", "+    try {", "+      return findInnerClass(t);", "+    } catch (ClassNotFoundException e) {", "+    ", "+    // ... in the single-type-import clauses ...", "+    Iterator<String> it = singleTypeImportClauses.iterator();", "+    while (it.hasNext()) {", "+      String s = it.next();", "+      if (hasSuffix(s, cname) || hasSuffix(s, str)) {", "+        return Class.forName(s, false, classLoader);", "+      }", "+      // It is perhaps an innerclass of an imported class", "+      // ie. a.b.C and C$D", "+      int i = str.indexOf('$');", "+      if (i != -1) {", "+        try {", "+          if (hasSuffix(s, str.substring(0, i))) {", "+            return Class.forName(s + str.substring(i, str.length()),", "+                                 false, classLoader);", "+          }", "+        } catch (ClassNotFoundException e) {", "+        }", "+      }", "+    ", "+    if (ccname != null) {", "+      // ... in the current class ...", "+      try {", "+        return Class.forName(ccname + \"$\" + str, false, classLoader);", "+      } catch (ClassNotFoundException e) {", "+      }", "+      ", "+      // ... it is perhaps an outer class", "+      it = getOuterNames(ccname).iterator();", "+      String tmp = ccname;", "+      while (it.hasNext()) {", "+        String s = it.next();", "+        int i = tmp.lastIndexOf(s) + s.length();", "+        tmp = tmp.substring(0, i);", "+        if (s.equals(cname)) {", "+          return Class.forName(tmp, false, classLoader);", "+        }", "+      }", "+      ", "+      // ... or the class itself", "+      if (ccname.endsWith(cname)) {", "+        int i = ccname.lastIndexOf(cname);", "+        if (i > 0 && ccname.charAt(i - 1) == '$') {", "+          return Class.forName(ccname, false, classLoader);", "+        }", "+      }", "+    ", "+    // ... with the import-on-demand clauses as prefix", "+    it = importOnDemandClauses.iterator();", "+    while (it.hasNext()) {", "+      String s = it.next();", "+      try {", "+        return Class.forName(s+\".\"+str, false, classLoader);", "+      } catch (ClassNotFoundException e) {", "+      }", "+    ", "+    throw new ClassNotFoundException(cname);", "+  }", "-     */", "-    public Class lookupClass(String cname, String ccname)", "-\tthrows ClassNotFoundException {", "-\tString str = cname.replace('.', '$');", "-", "-\t// Search for the full name ...", "-\t", "-\t// ... in the current package ...", "-\tString t = (currentPackage.equals(\"\"))", "-\t    ? cname", "-\t    : currentPackage + \".\" + cname;\t", "-\ttry {", "-\t    return Class.forName(t, false, classLoader);", "-\t} catch (ClassNotFoundException e) {", "-\t}", "-", "-\tif (cname.indexOf('.') != -1) {", "-\t    try {", "-\t\treturn Class.forName(cname, false, classLoader);", "-\t    } catch (ClassNotFoundException e) {", "-\t    }", "-\t}", "-", "-\t// try to find an inner class with this name", "-\ttry {", "-\t    return findInnerClass(t);", "-\t} catch (ClassNotFoundException e) {", "-\t}", "-", "-\t// ... in the single-type-import clauses ...", "-\tIterator it = singleTypeImportClauses.iterator();", "-\twhile (it.hasNext()) {", "-\t    String s = (String)it.next();", "-\t    if (hasSuffix(s, cname) || hasSuffix(s, str)) {", "-\t\treturn Class.forName(s, false, classLoader);", "-\t    }", "-\t    // It is perhaps an innerclass of an imported class", "-\t    // ie. a.b.C and C$D", "-\t    int i = str.indexOf('$');", "-\t    if (i != -1) {", "-\t\ttry {", "-\t\t    if (hasSuffix(s, str.substring(0, i))) {", "-\t\t\treturn Class.forName(s + str.substring(i, str.length()),", "-\t\t\t\t\t     false, classLoader);", "-\t\t    }", "-\t\t} catch (ClassNotFoundException e) {", "-\t\t}", "-\t    }", "-\t}", "-", "-\tif (ccname != null) {", "-\t    // ... in the current class ...", "-\t    try {", "-\t\treturn Class.forName(ccname + \"$\" + str, false, classLoader);", "-\t    } catch (ClassNotFoundException e) {", "-\t    }", "-", "-\t    // ... it is perhaps an outer class", "-\t    it = getOuterNames(ccname).iterator();", "-\t    String tmp = ccname;", "-\t    while (it.hasNext()) {", "-\t\tString s = (String)it.next();", "-\t\tint i = tmp.lastIndexOf(s) + s.length();", "-\t\ttmp = tmp.substring(0, i);", "-\t\tif (s.equals(cname)) {", "-\t\t    return Class.forName(tmp, false, classLoader);", "-\t\t}", "-\t    }", "-", "-\t    // ... or the class itself", "-\t    if (ccname.endsWith(cname)) {", "-\t\tint i = ccname.lastIndexOf(cname);", "-\t\tif (i > 0 && ccname.charAt(i - 1) == '$') {", "-\t\t    return Class.forName(ccname, false, classLoader);", "-\t\t}", "-\t    }", "-\t}", "-\t", "-\t// ... with the import-on-demand clauses as prefix", "-\tit = importOnDemandClauses.iterator();", "-\twhile (it.hasNext()) {", "-\t    String s = (String)it.next();", "-\t    try {", "-\t        return Class.forName(s+\".\"+str, false, classLoader);", "-\t    } catch (ClassNotFoundException e) {", "-\t    }", "-\t}", "-", "-\tthrow new ClassNotFoundException(cname);"]}], "num": 26584}