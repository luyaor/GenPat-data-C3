{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "50319eb077c9d5ab845f5f711bf02264", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0f8d005f2a37f145be4363aecd4b660d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 45, "signatureBeforeChange": "   protected VariableData[] _variableDeclaration2VariableData(VariableDeclaration vd, Data enclosing)", "signatureAfterChange": "   protected VariableData[] _variableDeclaration2VariableData(VariableDeclaration vd, final Data enclosing)", "diff": ["-  protected VariableData[] _variableDeclaration2VariableData(VariableDeclaration vd, Data enclosing) {", "+  protected VariableData[] _variableDeclaration2VariableData(VariableDeclaration vd, final Data enclosing) {", "+    assert enclosing != null;", "+    System.err.println(\"*** 2Var called for \\n\" + declaratorsToString(vd.getDeclarators()) + \"\\nin \" + enclosing);", "-    for (VariableDeclarator declarator: declarators) {", "+    for (final VariableDeclarator declarator: declarators) {", "-      Type type = declarator.getType();", "-      String name = declarator.getName().getText();", "-      SymbolData sd = handleDeclarator(type, name, enclosing);", "-      if (sd != null) {", "-        boolean initialized = declarator instanceof InitializedVariableDeclarator;", "-        // want hasBeenAssigned to be true if this variable declaration is initialized, and false otherwise.", "-//        System.err.println(\"creating new VariableData for \" + name);", "-        VariableData vdata = new VariableData(name, mav, sd, initialized, enclosing); ", "-        vdata.setHasInitializer(initialized);", "+      final Type type = declarator.getType();", "+      final String name = declarator.getName().getText();", "+      final String typeName = type.getName();", "+//      assert enclosing == getQualifiedSymbolData(_enclosingClassName, SourceInfo.NO_INFO);", "+      // TODO: if enclosing is a MethodData, we should first look for a local class!!!  This search will always", "+      // succeed if a matching local class exists because no forward reference is possible. (Confirm this!) !!!", "+      /* TODO: do we need to worry about case when enclosing is a MethodData?  Yes. defineInnerSymbolData ", "+       * already treats local classes specially, but it doesn't help.  References to local types use relative", "+       * class names. */", "+      SymbolData sd = _identifyType(typeName, declarator.getSourceInfo(), _enclosingClassName);  // may be null", "+      boolean initialized = declarator instanceof InitializedVariableDeclarator;", "+      // want hasBeenAssigned to be true if this variable declaration is initialized, and false otherwise.", "+      System.err.println(\"Creating new VariableData \" + name + \" : \" + typeName + \" within \" + _enclosingClassName);", "+      final VariableData vdata = new VariableData(name, mav, sd, initialized, enclosing); ", "+      vdata.setHasInitializer(initialized);", "-        vds.addLast(vdata); ", "-      }", "-      else {", "-//        System.err.println(\"handleDeclarator(\" + type + \", \" + name + \", \" + enclosing + \") returned null\");", "-        _addAndIgnoreError(\"Class or Interface \" + name + \" not found\", type);", "+      vds.addLast(vdata); ", "+//        System.err.println(\"identifyReturnType(\" + type + \", \" + name + \", \" + enclosing + \") returned null\");", "+      if (sd == null) { // TODO !!! Can this really happen?", "+        // Create fixup", "+        final String enclosingName = _enclosingClassName;  // Grab the current enclosing class name", "+        System.err.println(\"**** Creating fixup for preceding VariableData\");", "+        Command fixup = new Command() {", "+          public void execute() {", "+            System.err.println(\"**** Executing fixup for \" + typeName + \" within \" + enclosingName);", "+            SymbolData newSd = _identifyType(typeName, declarator.getSourceInfo(), enclosingName);", "+            if (newSd != null) vdata.setType(newSd);", "+            else _addAndIgnoreError(\"Class or Interface \" + typeName + \" not found\", type);", "+          }", "+        };", "+        fixUps.add(fixup);       ", "-  }", "+  }                       "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a166a7f411d027aa922c5dbc58bf3f94", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "65fb8db1fb3e7570ae4fa352a26deb0e151b48ac", "commitAfterChange": "d933be24919e2ab110f61a795910708e74f868c4", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "   protected SymbolData defineSymbolData(final TypeDefBase typeDefBase, final String qualifiedTypeName,                                         final String enclosingClassName)", "signatureAfterChange": "   protected SymbolData defineSymbolData(final TypeDefBase typeDefBase, final String qualifiedTypeName,                                         final String enclosingClassName)", "diff": ["-    // Get or create SymbolDatas (continuations) for the interfaces", "+    // Get or create SymbolDatas for the interfaces", "-    for (final ReferenceType rt: rts) {", "-      SymbolData sD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "-      if (sD != null && ! sD.isInterface()) {", "-        sD.setInterface(true);", "-//        System.err.println(\"Interface type = \" + sD);", "-//        assert false;", "+    for (int i = 0; i < rts.length; i++) {", "+      final ReferenceType rt = rts[i];", "+      final String rtName = rt.getName();", "+      boolean forwardRef = false;", "+      SymbolData iD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "+      if (iD != null && ! iD.isContinuation() && ! iD.isInterface()) {", "+        _addError(\"The symbol \" + rtName + \" is not an interface\", typeDefBase);", "-      interfaces.add(sD);                     // Note: confirm that null can be added to an ArrayList", "-      if (sD == null) { ", "-        // create a fixup for this interface reference", "+      if (iD == null || iD.isContinuation())  { // create a dummy symbol pending fixUp TODO: is this necessary?", "+        iD = new SymbolData(rtName);", "+        forwardRef = true;", "+      }", "+      ", "+      interfaces.add(iD);                     ", "+      if (forwardRef) { ", "+        // create a fixup for this interface slot", "+        final int j = i;", "-            SymbolData newSD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "-            assert newSD != null && newSD.isInterface();  // EXPAND", "-            int lastIndex = interfaces.size() - 1;", "-            interfaces.set(lastIndex, newSD);", "+            SymbolData newID = _lookupTypeFromWithinClass(rt, enclosingClassName);", "+            if (newID == null) _addError(\"The symbol \" + rtName + \" is not defined\", typeDefBase);", "+            else if (! newID.isInterface()) ", "+              _addError(\"The symbol \" + rtName + \" is not an interface\", typeDefBase);", "+            interfaces.set(j, newID);", "+            sd.addEnclosingData(newID);", "+      ", "+    // Set the inferfaces; fixups will be done on the elements of the interface ArrayList, but this does not", "+    // add the found interface to the enclosing data of sd.", "+    sd.setInterfaces(interfaces);", "-      superSD = getSymbolData(\"java.lang.Object\", typeDefBase.getSourceInfo(), false);", "+      SymbolData objectSD = getSymbolData(\"java.lang.Object\", typeDefBase.getSourceInfo(), false);", "-      sd.setSuperClass(superSD);", "+      sd.setSuperClass(objectSD);", "+      sd.setInterface(false);", "-      superSD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "-//      if (superSD == null && rt.getName().equals(\"Object\"))  {", "-//        System.err.println(\"ALARM: _lookupTypeFromWithinClass for 'Object' returned null\");", "-//      }", "-      sd.setInterface(false);", "+      superSD = _lookupTypeFromWithinClass(rt, enclosingClassName);    ", "-//            System.err.println(\"***** In a FIXUP, looking up type \" + rt + \" from within \" + enclosingClassName);", "-//              newSuperSD = getSymbolData(\"java.lang.Object\", typeDefBase.getSourceInfo(), false);", "-              _addAndIgnoreError(\"The class \" + sd + \" has an undefined superclass \" + rt, typeDefBase);", "-            else", "+              _addError(\"The class \" + sd + \" has an undefined superclass \" + rt, typeDefBase);", "+            else  // TODO: Does not check that newSuperSD is not an interace  ", "-    ", "-    // Set the inferfaces; fixups will be done on the elements of the interface ArrayList", "-    sd.setInterfaces(interfaces);", "+"]}], "num": 1001}