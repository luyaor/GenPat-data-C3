{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9372c2af5ae2a9e8a6d149a64398af6f", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b91177950750a9bdf4ac6c0cfa48399c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/DefinitionsPane.java", "commitBeforeChange": "3c18a1d03b53a699adfbc2df00845e9d60f9d1f5", "commitAfterChange": "4ec6eda5e5d4bd8e2b6e61afae08eb8548f8c4b5", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "   public void processKeyEvent(KeyEvent e)", "signatureAfterChange": "   public void processKeyEvent(KeyEvent e)", "diff": ["-    KeyStroke ks = KeyStroke.getKeyStrokeForEvent(e);", "-    Action a = KeyBindingManager.Singleton.get(ks);", "-    // Don't perform the action if the keystroke is NULL_KEYSTROKE,", "-    //  which can get generated by some Windows keys", "-    if ((ks != KeyStrokeOption.NULL_KEYSTROKE) && (a != null)) {", "-//      System.out.println(\"Keystroke was null\");", "-      endCompoundEdit();", "-      // Performs the action a", "-      SwingUtilities.notifyAction(a, ks, e, e.getSource(), e.getModifiers());", "-", "-      // Make sure we don't consume it again", "-      e.consume();", "-    }", "-    else {", "-      // Allows one step undoing of the keystrokes defined on the keymap (e.g. enter, tab, '{', '}', ':').", "-      Keymap km = getKeymap();", "-", "-      if (km.isLocallyDefined(ks) || km.isLocallyDefined(KeyStroke.getKeyStroke(ks.getKeyChar()))) {", "-        // We're breaking up compound edits at the granularity of \"enter\"'s.", "-        if (e.getKeyCode() == KeyEvent.VK_ENTER) {", "-          endCompoundEdit();", "-        }", "-", "-        CompoundUndoManager undoMan = _doc.getUndoManager();", "-        int key = undoMan.startCompoundEdit();", "-//        System.out.println(\"supering 1 \" + isAltF4);", "-        super.processKeyEvent(e);", "-        undoMan.endCompoundEdit(key);", "-//        e.consume();", "+    if(_mainFrame.getAllowKeyEvents()){", "+      KeyStroke ks = KeyStroke.getKeyStrokeForEvent(e);", "+      Action a = KeyBindingManager.Singleton.get(ks);", "+      // Don't perform the action if the keystroke is NULL_KEYSTROKE,", "+      //  which can get generated by some Windows keys", "+      if ((ks != KeyStrokeOption.NULL_KEYSTROKE) && (a != null)) {", "+        //      System.out.println(\"Keystroke was null\");", "+        endCompoundEdit();", "+        // Performs the action a", "+        SwingUtilities.notifyAction(a, ks, e, e.getSource(), e.getModifiers());", "+        ", "+        // Make sure we don't consume it again", "+        e.consume();", "-        // The following conditional fixes bug #676586 by ignoring typed events when the meta key is down", "-        // and fixes bug #905405 \"Undo Alt+Anything Causes Exception\" by ignoring typed events when", "-        // the alt key is down.", "-        if ((((e.getModifiers() & InputEvent.META_MASK) != 0) || ((e.getModifiers() & InputEvent.ALT_MASK) != 0))", "-              && e.getKeyCode() == KeyEvent.VK_UNDEFINED) {", "-//          System.out.println(\"not supering 1 \" + isAltF4);", "-          return;", "-        }", "-", "-        // The following conditional fixes ease of use issue 693253 by checking if a typed event is", "-        // shift-delete or shift-backspace and then performing a delete or backspace operation,", "-        // respectively", "-        if ((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) {", "-          int newModifiers = e.getModifiers() & ~(InputEvent.SHIFT_MASK);", "-", "-          KeyStroke newKs = KeyStroke.getKeyStroke(ks.getKeyCode(), newModifiers, ks.isOnKeyRelease());", "-          String name = KeyBindingManager.Singleton.getName(newKs);", "-", "-          if (name != null && (name.equals(\"Delete Previous\") || name.equals(\"Delete Next\"))) {", "+        // Allows one step undoing of the keystrokes defined on the keymap (e.g. enter, tab, '{', '}', ':').", "+        Keymap km = getKeymap();", "+        ", "+        if (km.isLocallyDefined(ks) || km.isLocallyDefined(KeyStroke.getKeyStroke(ks.getKeyChar()))) {", "+          // We're breaking up compound edits at the granularity of \"enter\"'s.", "+          if (e.getKeyCode() == KeyEvent.VK_ENTER) {", "-            // We are unsure about the third and fourth arguments (e and e.getSource()); we simply", "-            // reuse the original values", "-            SwingUtilities.notifyAction(KeyBindingManager.Singleton.get(newKs), newKs, e, e.getSource(), newModifiers);", "-            e.consume();", "-//            System.out.println(\"not supering 2 \" + isAltF4);", "+          }", "+          ", "+          CompoundUndoManager undoMan = _doc.getUndoManager();", "+          int key = undoMan.startCompoundEdit();", "+          //        System.out.println(\"supering 1 \" + isAltF4);", "+          super.processKeyEvent(e);", "+          undoMan.endCompoundEdit(key);", "+          //        e.consume();", "+        }", "+        else {", "+          // The following conditional fixes bug #676586 by ignoring typed events when the meta key is down", "+          // and fixes bug #905405 \"Undo Alt+Anything Causes Exception\" by ignoring typed events when", "+          // the alt key is down.", "+          if ((((e.getModifiers() & InputEvent.META_MASK) != 0) || ((e.getModifiers() & InputEvent.ALT_MASK) != 0))", "+                && e.getKeyCode() == KeyEvent.VK_UNDEFINED) {", "+            //          System.out.println(\"not supering 1 \" + isAltF4);", "-        }", "-", "-        // If the KeyEvent is not a pressed event, process it before we do", "-        // granular undo or _inCompoundEdit may get set incorrectly.", "-        // This code breaks Alt-F4, and may break other system keybindings", "-        // since the event is consumed by us.  For now, just check Alt-F4.", "-        if (e.getID() != KeyEvent.KEY_TYPED) {", "-//          System.out.println(\"supering 2 \" + isAltF4);", "-//          boolean isAltF4 = e.getKeyCode() == KeyEvent.VK_F4 && (KeyEvent.ALT_MASK & e.getModifiers()) != 0;", "-//          if (!isAltF4) {", "-          super.processKeyEvent(e);", "-//            e.consume();", "-//          }", "-          return;", "-        }", "-", "-        // backspace deletes twice without this check, overrides other keystrokes", "-        // that use the mask modifier", "-        if (((ks.getModifiers() & mask) == 0) && ks.getKeyChar() != '\\b') {", "-          int _keyval = (int) e.getKeyChar();", "-          if (_keyval >= 32 && _keyval <= 126) {", "-            CompoundUndoManager undoMan = _doc.getUndoManager();", "-            if (!_inCompoundEdit) {", "-              _inCompoundEdit = true;", "-              _compoundEditKey = undoMan.startCompoundEdit();", "-              getUndoAction().updateUndoState();", "-              getRedoAction().updateRedoState();", "-              //super.processKeyEvent(e);", "+          ", "+          // The following conditional fixes ease of use issue 693253 by checking if a typed event is", "+          // shift-delete or shift-backspace and then performing a delete or backspace operation,", "+          // respectively", "+          if ((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) {", "+            int newModifiers = e.getModifiers() & ~(InputEvent.SHIFT_MASK);", "+            ", "+            KeyStroke newKs = KeyStroke.getKeyStroke(ks.getKeyCode(), newModifiers, ks.isOnKeyRelease());", "+            String name = KeyBindingManager.Singleton.getName(newKs);", "+            ", "+            if (name != null && (name.equals(\"Delete Previous\") || name.equals(\"Delete Next\"))) {", "+              endCompoundEdit();", "+              // We are unsure about the third and fourth arguments (e and e.getSource()); we simply", "+              // reuse the original values", "+              SwingUtilities.notifyAction(KeyBindingManager.Singleton.get(newKs), newKs, e, e.getSource(), newModifiers);", "+              e.consume();", "+              //            System.out.println(\"not supering 2 \" + isAltF4);", "+              return;", "-//            else {", "-//              UndoableEdit lastEdit = undoMan.getNextUndo();", "-//              lastEdit.die();", "-//              _compoundEditKey = undoMan.startCompoundEdit();", "-//              super.processKeyEvent(e);", "-//              undoMan.addEdit(lastEdit);", "-//              undoMan.endCompoundEdit(_compoundEditKey);", "-//            }", "-//          System.out.println(\"supering 3 \" + isAltF4);", "-          super.processKeyEvent(e);", "+          ", "+          // If the KeyEvent is not a pressed event, process it before we do", "+          // granular undo or _inCompoundEdit may get set incorrectly.", "+          // This code breaks Alt-F4, and may break other system keybindings", "+          // since the event is consumed by us.  For now, just check Alt-F4.", "+          if (e.getID() != KeyEvent.KEY_TYPED) {", "+            //          System.out.println(\"supering 2 \" + isAltF4);", "+            //          boolean isAltF4 = e.getKeyCode() == KeyEvent.VK_F4 && (KeyEvent.ALT_MASK & e.getModifiers()) != 0;", "+            //          if (!isAltF4) {", "+            super.processKeyEvent(e);", "+            //            e.consume();", "+            //          }", "+            return;", "+          }", "+          ", "+          // backspace deletes twice without this check, overrides other keystrokes", "+          // that use the mask modifier", "+          if (((ks.getModifiers() & mask) == 0) && ks.getKeyChar() != '\\b') {", "+            int _keyval = (int) e.getKeyChar();", "+            if (_keyval >= 32 && _keyval <= 126) {", "+              CompoundUndoManager undoMan = _doc.getUndoManager();", "+              if (!_inCompoundEdit) {", "+                _inCompoundEdit = true;", "+                _compoundEditKey = undoMan.startCompoundEdit();", "+                getUndoAction().updateUndoState();", "+                getRedoAction().updateRedoState();", "+                //super.processKeyEvent(e);", "+              }", "+              //            else {", "+              //              UndoableEdit lastEdit = undoMan.getNextUndo();", "+              //              lastEdit.die();", "+              //              _compoundEditKey = undoMan.startCompoundEdit();", "+              //              super.processKeyEvent(e);", "+              //              undoMan.addEdit(lastEdit);", "+              //              undoMan.endCompoundEdit(_compoundEditKey);", "+              //            }", "+            }", "+            //          System.out.println(\"supering 3 \" + isAltF4);", "+            super.processKeyEvent(e);", "+          }", "+          //        else {", "+          //          e.consume();", "+          //          _inCompoundEdit = false;", "+          //        }", "-//        else {", "-//          e.consume();", "-//          _inCompoundEdit = false;", "-//        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d05810d1c1db3ae71e1520f1703fc66e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultJavadocModel.java", "commitBeforeChange": "e3e56a8c058b51612dfa6f1f21259a37eadcdcbb", "commitAfterChange": "71f0cebe149c327097ea40ca09774e0c57cdec3a", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "   private boolean _javadoc_1_3(String[] args, String[] classpath)     throws IOException, ClassNotFoundException, InterruptedException", "signatureAfterChange": "   private boolean _javadoc_1_3(String[] args, String[] classpath)     throws IOException, ClassNotFoundException, InterruptedException", "diff": ["-      ((CompilerError[])(errors.toArray(new CompilerError[0])), getter);", "+      ((CompilerError[])(errors.toArray(new CompilerError[errors.size()])), getter);", "-    return (errors.size() == 0);", "+    return _javadocErrorModel.hasOnlyWarnings();"]}], "num": 4528}