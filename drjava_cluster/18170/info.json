{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e1987fdd37467abc987afeb9004512d3", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2898d7c5b0606f70006bc95612de0fbc", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "476f4df6ab63cd1004cb7cc36238fad228ab6d80", "commitAfterChange": "2df7289d55456372fbaf4e3ab78549d8571648f8", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 78, "signatureBeforeChange": "   public ClassPathVector getClassPath()", "signatureAfterChange": "   public ClassPathVector getClassPath()", "diff": ["-  public ClassPathVector getClassPath() { return _jvm.getClassPath(); }", "+   */", "+  public ClassPathVector getClassPath() {", "+    ClassPathVector result = new ClassPathVector();", "+    ", "+    if (isProjectActive()) {", "+      File buildDir = getBuildDirectory();", "+      if (buildDir != null) { _addFileToClassPath(buildDir, result); }", "+      ", "+      /* We prefer to assume the project root is the project's source root, rather than", "+       * checking *every* file in the project for its source root.  This is a bit problematic,", "+       * because \"Compile Project\" won't care if the user has multiple source roots (or even just a", "+       * single \"src\" subdirectory), and the user in this situation (assuming the build dir is ", "+       * null) wouldn't notice a problem until trying to access the compiled classes in the ", "+       * Interactions.", "+       */", "+      File projRoot = getProjectRoot();", "+      if (projRoot != null) { _addFileToClassPath(projRoot, result); }", "+      ", "+      ClassPathVector projectExtras = getExtraClassPath();", "+      if (projectExtras != null) { result.addAll(projectExtras); }", "+    }", "+    else {", "+      for (File f : getSourceRootSet()) { _addFileToClassPath(f, result); }", "+    }", "+      ", "+    Vector<File> globalExtras = DrJava.getConfig().getSetting(EXTRA_CLASSPATH);", "+    if (globalExtras != null) {", "+      for (File f : globalExtras) { _addFileToClassPath(f, result); }", "+    }", "+    ", "+    /* We must add JUnit to the class path.  We do so by including the current JVM's class path.", "+     * This is not ideal, because all other classes on the current class path (including all of DrJava's", "+     * internal classes) are also included.  But we're probably stuck doing something like this if we", "+     * want to continue bundling JUnit with DrJava.", "+     */", "+    String currentClassPath = System.getProperty(\"java.class.path\");", "+    if (currentClassPath != null) {", "+      // TODO: Parsing this string needs to only happen once, not every time this method is invoked.", "+      StringTokenizer tokens = new StringTokenizer(currentClassPath, File.pathSeparator);", "+      while (tokens.hasMoreTokens()) {", "+        _addFileToClassPath(new File(tokens.nextToken()), result);", "+      }", "+    }", "+    ", "+    return result;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4faa86a3226014671e3673091717e251", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "add4ca7a51e78cf47efc30384ae6f244b7e78f21", "commitAfterChange": "bd6440967d1d2ae8c864e064182d820c7f6849ce", "methodNumberBeforeChange": 79, "methodNumberAfterChange": 79, "signatureBeforeChange": "   public ClassPathVector getClassPath()", "signatureAfterChange": "   public Iterable<File> getClassPath()", "diff": ["-  public ClassPathVector getClassPath() {", "-    ClassPathVector result = new ClassPathVector();", "+  public Iterable<File> getClassPath() {", "+    Iterable<File> result = IterUtil.empty();", "-      if (buildDir != null) { _addFileToClassPath(buildDir, result); }", "+      if (buildDir != null) { result = IterUtil.compose(result, buildDir); }", "-      if (projRoot != null) { _addFileToClassPath(projRoot, result); }", "+      if (projRoot != null) { result = IterUtil.compose(result, projRoot); }", "-      ClassPathVector projectExtras = getExtraClassPath();", "-      if (projectExtras != null) { result.addAll(projectExtras); }", "+      Iterable<File> projectExtras = getExtraClassPath();", "+      if (projectExtras != null) { result = IterUtil.compose(result, projectExtras); }", "-    else {", "-      for (File f : getSourceRootSet()) { _addFileToClassPath(f, result); }", "-    }", "-      ", "+    else { result = IterUtil.compose(result, getSourceRootSet()); }", "+    ", "-    if (globalExtras != null) {", "-      for (File f : globalExtras) { _addFileToClassPath(f, result); }", "-    }", "+    if (globalExtras != null) { result = IterUtil.compose(result, globalExtras); }", "-    String currentClassPath = System.getProperty(\"java.class.path\");", "-    if (currentClassPath != null) {", "-      // TODO: Parsing this string needs to only happen once, not every time this method is invoked.", "-      StringTokenizer tokens = new StringTokenizer(currentClassPath, File.pathSeparator);", "-      while (tokens.hasMoreTokens()) {", "-        _addFileToClassPath(new File(tokens.nextToken()), result);", "-      }", "-    }", "+    // TODO: Parsing this string needs to only happen once, not every time this method is invoked.", "+    String systemPath = System.getProperty(\"java.class.path\", \"\");", "+    result = IterUtil.compose(result, IOUtil.attemptAbsoluteFiles(IOUtil.parsePath(systemPath)));"]}], "num": 18170}