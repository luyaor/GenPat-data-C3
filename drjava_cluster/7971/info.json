{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2394833fa1919e1dc5cc1ea157c1a0bc", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "24c7b7a48bdf367449f11ff642eacb57", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/BodyTypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 82, "methodNumberAfterChange": 82, "signatureBeforeChange": "          public void testForBracedBody()", "signatureAfterChange": "          public void testForBracedBody()", "diff": ["-                                 \"\", ", "+                                 \"\",", "+                                 null, // enclosingClassName for top level traversal", "-                                 new LinkedList<String>(), ", "-                                 new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>());", "+                                 new HashSet<String>(), ", "+                                 new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>(),", "+                                 new LinkedList<Command>());", "-      llv.continuations = new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>();", "+      llv.continuations = new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>();", "-      llv._hierarchy = new Hashtable<String, TypeDefBase>();", "-      llv._classesToBeParsed = new Hashtable<String, Pair<TypeDefBase, LanguageLevelVisitor>>();", "+//      llv._hierarchy = new Hashtable<String, TypeDefBase>();", "+      llv._classesInThisFile = new HashSet<String>();", "-      SymbolData eb = llv.getSymbolData(\"java.util.prefs.BackingStoreException\", SourceInfo.NO_INFO, true);", "-      SymbolData re = llv.getSymbolData(\"java.lang.RuntimeException\", SourceInfo.NO_INFO, true);", "-//      LanguageLevelConverter.symbolTable = symbolTable = llv.symbolTable;", "-", "+      // preload symbolTable", "+      SymbolData throwable = llv.getQualifiedSymbolData(\"java.lang.Throwable\");", "+      SymbolData exception = llv.getQualifiedSymbolData(\"java.lang.Exception\");", "+      SymbolData string = llv.getQualifiedSymbolData(\"java.lang.String\");", "+      SymbolData eb = llv.getQualifiedSymbolData(\"java.util.prefs.BackingStoreException\");", "+      SymbolData re = llv.getQualifiedSymbolData(\"java.lang.RuntimeException\");", "+      assert symbolTable.contains(throwable);", "+      assert symbolTable.contains(exception);", "+      assert symbolTable.contains(string);", "+", "+      System.err.println(\"Interfaces for java.lang.RuntimeException = \" + re.getInterfaces());", "-      BracedBody plainBody = new BracedBody(SourceInfo.NO_INFO, new BodyItemI[] {new UnlabeledBreakStatement(SourceInfo.NO_INFO)});", "+      BracedBody plainBody = ", "+        new BracedBody(SourceInfo.NO_INFO, new BodyItemI[] {new UnlabeledBreakStatement(SourceInfo.NO_INFO)});", "-      "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "744749cfeafa4ef09c6b933ef9f05f2e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/BodyTypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 84, "methodNumberAfterChange": 84, "signatureBeforeChange": "      public void testForNormalTryCatchStatement()", "signatureAfterChange": "      public void testForNormalTryCatchStatement()", "diff": ["+                                 null, // enclosingClassName for top level traversal", "-                                 new LinkedList<String>(), ", "-                                 new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>());", "+                                 new HashSet<String>(), ", "+                                 new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>(),", "+                                 new LinkedList<Command>());", "-      llv.continuations = new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>();", "+      llv.continuations = new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>();", "-      llv._hierarchy = new Hashtable<String, TypeDefBase>();", "-      llv._classesToBeParsed = new Hashtable<String, Pair<TypeDefBase, LanguageLevelVisitor>>();", "+//      llv._hierarchy = new Hashtable<String, TypeDefBase>();", "+      llv._classesInThisFile = new HashSet<String>();", "-      SymbolData eb = llv.getSymbolData(\"java.util.prefs.BackingStoreException\", SourceInfo.NO_INFO, true);", "-      SymbolData re = llv.getSymbolData(\"java.lang.RuntimeException\", SourceInfo.NO_INFO, true);", "+      // preload symbolTable", "+      SymbolData throwable = llv.getQualifiedSymbolData(\"java.lang.Throwable\");", "+      SymbolData exception = llv.getQualifiedSymbolData(\"java.lang.Exception\");", "+      SymbolData string = llv.getQualifiedSymbolData(\"java.lang.String\");", "+      SymbolData eb = llv.getQualifiedSymbolData(\"java.util.prefs.BackingStoreException\");", "+      SymbolData re = llv.getQualifiedSymbolData(\"java.lang.RuntimeException\");", "+           ", "+      assert symbolTable.contains(throwable);", "+      assert symbolTable.contains(exception);", "+      assert symbolTable.contains(string);", "-      assertEquals(\"Error message should be correct\", \"This statement throws the exception java.util.prefs.BackingStoreException which needs to be caught or declared to be thrown\", errors.get(0).getFirst());", "+      assertEquals(\"Error message should be correct\",", "+                   \"This statement throws the exception java.util.prefs.BackingStoreException \" + ", "+                   \"which needs to be caught or declared to be thrown\", ", "+//                   \"You are attempting to throw java.util.prefs.BackingStoreException, which does not implement the \"", "+//                     + \"Throwable interface\",", "+                   errors.getLast().getFirst());", "+//                   \"You are attempting to throw java.util.prefs.BackingStoreException, which does not implement the\"", "+//                     + \" Throwable interface\",", "+      System.err.println(\"Last error is: \" + errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa32e846e9bf3095c19f81bf9ed4bd29", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ConstructorBodyTypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "          public void testForBracedBody()", "signatureAfterChange": "          public void testForBracedBody()", "diff": ["+                                 null, // enclosingClassName for top level traversal", "-                                 new LinkedList<String>(), ", "-                                 new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>());", "+                                 new HashSet<String>(), ", "+                                 new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>(),", "+                                 new LinkedList<Command>());", "-      llv.continuations = new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>();", "+      llv.continuations = new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>();", "-      llv._hierarchy = new Hashtable<String, TypeDefBase>();", "-      llv._classesToBeParsed = new Hashtable<String, Pair<TypeDefBase, LanguageLevelVisitor>>();", "-", "+//      llv._hierarchy = new Hashtable<String, TypeDefBase>();", "+      llv._classesInThisFile = new HashSet<String>();", "+      ", "+      // TODO: The next line should be unnecessary because the subsequent two lines should force its loading", "+      SymbolData throwable = llv.getSymbolData(\"java.lang.Exception\", SourceInfo.NO_INFO, true);  ", "-", "+      assert symbolTable.contains(eb);", "+      assert symbolTable.contains(re);", "+      assert symbolTable.containsKey(\"java.lang.Throwable\");", "+      assert symbolTable.containsKey(\"java.lang.Exception\");", "+", "-      //make sure that it is not okay to invoke a super constructor that throws an exception if the enclosing method is not declared to throw it", "+      // Make sure that it is not okay to invoke a super constructor that throws an exception if the enclosing method ", "+      // is not declared to throw it", "-      MethodData constructor = new MethodData(\"zebra\", _publicMav, new TypeParameter[0], _sd3, new VariableData[0], new String[] {\"java.util.prefs.BackingStoreException\"}, _sd3, null);", "+      MethodData constructor = new MethodData(\"zebra\", ", "+                                              _publicMav, ", "+                                              new TypeParameter[0], ", "+                                              _sd3, ", "+                                              new VariableData[0], ", "+                                              new String[] {\"java.util.prefs.BackingStoreException\"}, ", "+                                              _sd3, ", "+                                              null);", "-      BracedBody supConstr = new BracedBody(SourceInfo.NO_INFO, new BodyItemI[]{new ExpressionStatement(SourceInfo.NO_INFO, new SimpleSuperConstructorInvocation(SourceInfo.NO_INFO, new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0])))});", "+      SimpleSuperConstructorInvocation ssci = ", "+        new SimpleSuperConstructorInvocation(SourceInfo.NO_INFO, ", "+                                             new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]));", "+      BracedBody supConstr = ", "+        new BracedBody(SourceInfo.NO_INFO, new BodyItemI[]{new ExpressionStatement(SourceInfo.NO_INFO, ssci)});", "-      assertEquals(\"The error message should be correct\", \"The constructor of this class's super class could throw the exception java.util.prefs.BackingStoreException, so the enclosing constructor needs to be declared to throw it\", errors.getLast().getFirst());", "+      assertEquals(\"The error message should be correct\", ", "+                   \"The constructor of this class's super class could throw the exception \" +", "+                   \"java.util.prefs.BackingStoreException, so the enclosing constructor needs to be declared to throw it\", ", "+                   errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "df3b0210705f67edf0db481a18a468d7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/BodyTypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 83, "methodNumberAfterChange": 83, "signatureBeforeChange": "          public void testForTryCatchFinallyStatement()", "signatureAfterChange": "          public void testForTryCatchFinallyStatement()", "diff": ["+                                 null, // enclosingClassName for top level traversal", "-                                 new LinkedList<String>(), ", "-                                 new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>());", "+                                 new HashSet<String>(), ", "+                                 new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>(),", "+                                 new LinkedList<Command>());", "-      llv.continuations = new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>();", "+      llv.continuations = new Hashtable<String, Triple<SourceInfo, LanguageLevelVisitor, SymbolData>>();", "-      llv._hierarchy = new Hashtable<String, TypeDefBase>();", "-      llv._classesToBeParsed = new Hashtable<String, Pair<TypeDefBase, LanguageLevelVisitor>>();", "+//      llv._hierarchy = new Hashtable<String, TypeDefBase>();", "+      llv._classesInThisFile = new HashSet<String>();", "+      // preload symbolTable", "+      SymbolData throwable = llv.getQualifiedSymbolData(\"java.lang.Throwable\");", "+      SymbolData exception = llv.getQualifiedSymbolData(\"java.lang.Exception\");", "+      SymbolData string = llv.getQualifiedSymbolData(\"java.lang.String\");", "+      ", "+      assert symbolTable.contains(throwable);", "+      assert symbolTable.contains(exception);", "+      assert symbolTable.contains(string);", "-", "-", "-      assertEquals(\"Error message should be correct\", \"This statement throws the exception java.util.prefs.BackingStoreException which needs to be caught or declared to be thrown\", errors.get(0).getFirst());", "-            ", "+      assertEquals(\"Error message should be correct\", ", "+                   \"This statement throws the exception java.util.prefs.BackingStoreException which needs to be caught\"", "+                     + \" or declared to be thrown\",", "+                   errors.getLast().getFirst());", "+                   ", "-      assertEquals(\"Error message should be correct\", ", "-                   \"This statement throws the exception java.util.prefs.BackingStoreException \" +", "-                   \"which needs to be caught or declared to be thrown\", ", "+      assertEquals(\"Error message should be correct\",", "+                   \"This statement throws the exception java.util.prefs.BackingStoreException which needs to be caught\"", "+                     + \" or declared to be thrown\", ", "-      assertEquals(\"Error message should be correct\", \"This statement throws the exception java.util.prefs.BackingStoreException \" +", "-                   \"which needs to be caught or declared to be thrown\", errors.get(0).getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"This statement throws the exception java.util.prefs.BackingStoreException which needs to be caught\"", "+                     + \" or declared to be thrown\", ", "+                   errors.get(0).getFirst());", "-      assertEquals(\"There should still be 1 errors\", 1, errors.size());", "+      System.err.println(\"Last error was \" + errors.getLast().getFirst());", "+      assertEquals(\"There should still be 1 error\", 1, errors.size());"]}], "num": 7971}