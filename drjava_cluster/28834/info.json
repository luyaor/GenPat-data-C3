{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a1d14469fb295b9015083c736577c328", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4f38c5a155ada80aaa0d1c4847a7087", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/JarJDKToolsLibrary.java", "commitBeforeChange": "36e86519fec0be37255f092c8ef3144003d9d925", "commitAfterChange": "24a4bd9b5af47fdf2b927852ef0f4a564c73861b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r   \r   public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model)", "signatureAfterChange": "   public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model)", "diff": ["-  \r", "-  public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model) {\r", "-    FullVersion version = guessVersion(f);\r", "-    CompilerInterface compiler = NoCompilerAvailable.ONLY;\r", "-    Debugger debugger = NoDebuggerAvailable.ONLY;\r", "-    JavadocModel javadoc = new NoJavadocAvailable(model);\r", "-    \r", "-    if (JavaVersion.CURRENT.supports(version.majorVersion())) {\r", "-      // block tools.jar classes, so that references don't point to a different version of the classes\r", "-      ClassLoader loader = new ShadowingClassLoader(JarJDKToolsLibrary.class.getClassLoader(), TOOLS_PACKAGES);\r", "-      Iterable<File> path = IterUtil.singleton(IOUtil.attemptAbsoluteFile(f));\r", "-      \r", "-      String compilerAdapter = adapterForCompiler(version.majorVersion());\r", "-      if (compilerAdapter != null) {\r", "-        List<File> bootClassPath = null;\r", "-        if (f.getName().equals(\"classes.jar\")) { bootClassPath = Arrays.asList(f); }\r", "-        else if (f.getName().equals(\"tools.jar\")) {\r", "-          File rtJar = new File(f.getParentFile(), \"../jre/lib/rt.jar\");\r", "-          if (!rtJar.exists()) { rtJar = new File(f.getParentFile(), \"rt.jar\"); }\r", "-          if (rtJar.exists()) {\r", "-            rtJar = IOUtil.attemptCanonicalFile(rtJar);\r", "-            bootClassPath = Arrays.asList(rtJar);\r", "-          }\r", "-        }\r", "-        try {\r", "-          Class[] sig = new Class[]{ FullVersion.class, String.class, List.class };\r", "-          Object[] args = new Object[]{ version, f.toString(), bootClassPath };\r", "-          CompilerInterface attempt = (CompilerInterface) ReflectUtil.loadLibraryAdapter(loader, path, compilerAdapter, \r", "-                                                                                         sig, args);\r", "-          if (attempt.isAvailable()) { compiler = attempt; }\r", "-        }\r", "-        catch (ReflectException e) { /* can't load */ }\r", "-        catch (LinkageError e) { /* can't load */ }\r", "-      }\r", "-      \r", "-      String debuggerAdapter = adapterForDebugger(version.majorVersion());\r", "-      String debuggerPackage = \"edu.rice.cs.drjava.model.debug.jpda\";\r", "-      if (debuggerAdapter != null) {\r", "-        try {\r", "-          Class[] sig = new Class[]{ GlobalModel.class };\r", "-          // can't use loadLibraryAdapter because we need to preempt the whole package\r", "-          ClassLoader debugLoader = new PreemptingClassLoader(new PathClassLoader(loader, path), debuggerPackage);\r", "-          Debugger attempt = (Debugger) ReflectUtil.loadObject(debugLoader, debuggerAdapter, sig, model);        \r", "-          if (attempt.isAvailable()) { debugger = attempt; }\r", "-        }\r", "-        catch (ReflectException e) { /* can't load */ }\r", "-        catch (LinkageError e) { /* can't load */ }\r", "-      }\r", "-      \r", "-      try {\r", "-        new PathClassLoader(loader, path).loadClass(\"com.sun.tools.javadoc.Main\");\r", "-        File bin = new File(f.getParentFile(), \"../bin\");\r", "-        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(f.getParentFile(), \"../Home/bin\"); }\r", "-        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(System.getProperty(\"java.home\", f.getParent())); }\r", "-        javadoc = new DefaultJavadocModel(model, bin, path);\r", "-      }\r", "-      catch (ClassNotFoundException e) { /* can't load */ }\r", "-      catch (LinkageError e) { /* can't load (probably not necessary, but might as well catch it) */ }\r", "-        \r", "-    }\r", "-    \r", "-    return new JarJDKToolsLibrary(f, version, compiler, debugger, javadoc);\r", "-  }\r", "+  /** Create a JarJDKToolsLibrary from a specific {@code \"tools.jar\"} or {@code \"classes.jar\"} file. */", "+  public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model) {", "+    FullVersion version = guessVersion(f);", "+    CompilerInterface compiler = NoCompilerAvailable.ONLY;", "+    Debugger debugger = NoDebuggerAvailable.ONLY;", "+    JavadocModel javadoc = new NoJavadocAvailable(model);", "+    ", "+    // We can't execute code that was possibly compiled for a later Java API version.", "+    if (JavaVersion.CURRENT.supports(version.majorVersion())) {", "+      // block tools.jar classes, so that references don't point to a different version of the classes", "+      ClassLoader loader = new ShadowingClassLoader(JarJDKToolsLibrary.class.getClassLoader(), TOOLS_PACKAGES);", "+      Iterable<File> path = IterUtil.singleton(IOUtil.attemptAbsoluteFile(f));", "+      ", "+      String compilerAdapter = adapterForCompiler(version.majorVersion());", "+      if (compilerAdapter != null) {", "+        ", "+        // determine boot class path", "+        File libDir = null;", "+        if (f.getName().equals(\"classes.jar\")) { libDir = f.getParentFile(); }", "+        else if (f.getName().equals(\"tools.jar\")) {", "+          File jdkLibDir = f.getParentFile();", "+          if (jdkLibDir != null) {", "+            File jdkRoot = jdkLibDir.getParentFile();", "+            if (jdkRoot != null) {", "+              File jreLibDir = new File(jdkRoot, \"jre/lib\");", "+              if (IOUtil.attemptExists(new File(jreLibDir, \"rt.jar\"))) { libDir = jreLibDir; }", "+            }", "+            if (libDir == null) {", "+              if (IOUtil.attemptExists(new File(jdkLibDir, \"rt.jar\"))) { libDir = jdkLibDir; }", "+            }", "+          }", "+        }", "+        List<File> bootClassPath = null; // null defers to the compiler's default behavior", "+        if (libDir != null) {", "+          File[] jars = IOUtil.attemptListFiles(libDir, IOUtil.extensionFileFilter(\"jar\"));", "+          if (jars != null) { bootClassPath = Arrays.asList(jars); }", "+        }", "+", "+        try {", "+          Class[] sig = new Class[]{ FullVersion.class, String.class, List.class };", "+          Object[] args = new Object[]{ version, f.toString(), bootClassPath };", "+          CompilerInterface attempt = (CompilerInterface) ReflectUtil.loadLibraryAdapter(loader, path, compilerAdapter, ", "+                                                                                         sig, args);", "+          if (attempt.isAvailable()) { compiler = attempt; }", "+        }", "+        catch (ReflectException e) { /* can't load */ }", "+        catch (LinkageError e) { /* can't load */ }", "+      }", "+      ", "+      String debuggerAdapter = adapterForDebugger(version.majorVersion());", "+      String debuggerPackage = \"edu.rice.cs.drjava.model.debug.jpda\";", "+      if (debuggerAdapter != null) {", "+        try {", "+          Class[] sig = new Class[]{ GlobalModel.class };", "+          // can't use loadLibraryAdapter because we need to preempt the whole package", "+          ClassLoader debugLoader = new PreemptingClassLoader(new PathClassLoader(loader, path), debuggerPackage);", "+          Debugger attempt = (Debugger) ReflectUtil.loadObject(debugLoader, debuggerAdapter, sig, model);        ", "+          if (attempt.isAvailable()) { debugger = attempt; }", "+        }", "+        catch (ReflectException e) { /* can't load */ }", "+        catch (LinkageError e) { /* can't load */ }", "+      }", "+      ", "+      try {", "+        new PathClassLoader(loader, path).loadClass(\"com.sun.tools.javadoc.Main\");", "+        File bin = new File(f.getParentFile(), \"../bin\");", "+        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(f.getParentFile(), \"../Home/bin\"); }", "+        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(System.getProperty(\"java.home\", f.getParent())); }", "+        javadoc = new DefaultJavadocModel(model, bin, path);", "+      }", "+      catch (ClassNotFoundException e) { /* can't load */ }", "+      catch (LinkageError e) { /* can't load (probably not necessary, but might as well catch it) */ }", "+        ", "+    }", "+    ", "+    return new JarJDKToolsLibrary(f, version, compiler, debugger, javadoc);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da82d5612e0a6fe320d388b828473672", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/JarJDKToolsLibrary.java", "commitBeforeChange": "06c097879b27ffb8ca08a54a4961265ba5907f07", "commitAfterChange": "cb297201cc08624c537abfd29974e65bdfd2f397", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model)", "signatureAfterChange": "\r   public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model)", "diff": ["-  /** Create a JarJDKToolsLibrary from a specific {@code \"tools.jar\"} or {@code \"classes.jar\"} file. */", "-  public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model) {", "-    FullVersion version = guessVersion(f);", "-    CompilerInterface compiler = NoCompilerAvailable.ONLY;", "-    Debugger debugger = NoDebuggerAvailable.ONLY;", "-    JavadocModel javadoc = new NoJavadocAvailable(model);", "-    ", "-    // We can't execute code that was possibly compiled for a later Java API version.", "-    if (JavaVersion.CURRENT.supports(version.majorVersion())) {", "-      // block tools.jar classes, so that references don't point to a different version of the classes", "-      ClassLoader loader =", "-        new ShadowingClassLoader(JarJDKToolsLibrary.class.getClassLoader(), true, TOOLS_PACKAGES, true);", "-      Iterable<File> path = IterUtil.singleton(IOUtil.attemptAbsoluteFile(f));", "-      ", "-      String compilerAdapter = adapterForCompiler(version.majorVersion());", "-      if (compilerAdapter != null) {", "-        ", "-        // determine boot class path", "-        File libDir = null;", "-        if (f.getName().equals(\"classes.jar\")) { libDir = f.getParentFile(); }", "-        else if (f.getName().equals(\"tools.jar\")) {", "-          File jdkLibDir = f.getParentFile();", "-          if (jdkLibDir != null) {", "-            File jdkRoot = jdkLibDir.getParentFile();", "-            if (jdkRoot != null) {", "-              File jreLibDir = new File(jdkRoot, \"jre/lib\");", "-              if (IOUtil.attemptExists(new File(jreLibDir, \"rt.jar\"))) { libDir = jreLibDir; }", "-            }", "-            if (libDir == null) {", "-              if (IOUtil.attemptExists(new File(jdkLibDir, \"rt.jar\"))) { libDir = jdkLibDir; }", "-            }", "-          }", "-        }", "-        List<File> bootClassPath = null; // null defers to the compiler's default behavior", "-        if (libDir != null) {", "-          File[] jars = IOUtil.attemptListFiles(libDir, IOUtil.extensionFilePredicate(\"jar\"));", "-          if (jars != null) { bootClassPath = Arrays.asList(jars); }", "-        }", "-", "-        try {", "-          Class<?>[] sig = { FullVersion.class, String.class, List.class };", "-          Object[] args = { version, f.toString(), bootClassPath };", "-          CompilerInterface attempt = (CompilerInterface) ReflectUtil.loadLibraryAdapter(loader, path, compilerAdapter, ", "-                                                                                         sig, args);", "-          if (attempt.isAvailable()) { compiler = attempt; }", "-        }", "-        catch (ReflectException e) { /* can't load */ }", "-        catch (LinkageError e) { /* can't load */ }", "-      }", "-      ", "-      String debuggerAdapter = adapterForDebugger(version.majorVersion());", "-      String debuggerPackage = \"edu.rice.cs.drjava.model.debug.jpda\";", "-      if (debuggerAdapter != null) {", "-        try {", "-          Class<?>[] sig = { GlobalModel.class };", "-          // can't use loadLibraryAdapter because we need to preempt the whole package", "-          ClassLoader debugLoader = new PreemptingClassLoader(new PathClassLoader(loader, path), debuggerPackage);", "-          Debugger attempt = (Debugger) ReflectUtil.loadObject(debugLoader, debuggerAdapter, sig, model);        ", "-          if (attempt.isAvailable()) { debugger = attempt; }", "-        }", "-        catch (ReflectException e) { /* can't load */ }", "-        catch (LinkageError e) { /* can't load */ }", "-      }", "-      ", "-      try {", "-        new PathClassLoader(loader, path).loadClass(\"com.sun.tools.javadoc.Main\");", "-        File bin = new File(f.getParentFile(), \"../bin\");", "-        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(f.getParentFile(), \"../Home/bin\"); }", "-        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(System.getProperty(\"java.home\", f.getParent())); }", "-        javadoc = new DefaultJavadocModel(model, bin, path);", "-      }", "-      catch (ClassNotFoundException e) { /* can't load */ }", "-      catch (LinkageError e) { /* can't load (probably not necessary, but might as well catch it) */ }", "-        ", "-    }", "-    ", "-    return new JarJDKToolsLibrary(f, version, compiler, debugger, javadoc);", "-  }", "+  /** Create a JarJDKToolsLibrary from a specific {@code \"tools.jar\"} or {@code \"classes.jar\"} file. */\r", "+  public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model) {\r", "+    FullVersion version = guessVersion(f);\r", "+    CompilerInterface compiler = NoCompilerAvailable.ONLY;\r", "+    Debugger debugger = NoDebuggerAvailable.ONLY;\r", "+    JavadocModel javadoc = new NoJavadocAvailable(model);\r", "+    \r", "+    // We can't execute code that was possibly compiled for a later Java API version.\r", "+    if (JavaVersion.CURRENT.supports(version.majorVersion())) {\r", "+      // block tools.jar classes, so that references don't point to a different version of the classes\r", "+      ClassLoader loader =\r", "+        new ShadowingClassLoader(JarJDKToolsLibrary.class.getClassLoader(), true, TOOLS_PACKAGES, true);\r", "+      Iterable<File> path = IterUtil.singleton(IOUtil.attemptAbsoluteFile(f));\r", "+      \r", "+      String compilerAdapter = adapterForCompiler(version);\r", "+      if (compilerAdapter != null) {\r", "+        \r", "+        // determine boot class path\r", "+        File libDir = null;\r", "+        if (f.getName().equals(\"classes.jar\")) { libDir = f.getParentFile(); }\r", "+        else if (f.getName().equals(\"tools.jar\")) {\r", "+          File jdkLibDir = f.getParentFile();\r", "+          if (jdkLibDir != null) {\r", "+            File jdkRoot = jdkLibDir.getParentFile();\r", "+            if (jdkRoot != null) {\r", "+              File jreLibDir = new File(jdkRoot, \"jre/lib\");\r", "+              if (IOUtil.attemptExists(new File(jreLibDir, \"rt.jar\"))) { libDir = jreLibDir; }\r", "+            }\r", "+            if (libDir == null) {\r", "+              if (IOUtil.attemptExists(new File(jdkLibDir, \"rt.jar\"))) { libDir = jdkLibDir; }\r", "+            }\r", "+          }\r", "+        }\r", "+        List<File> bootClassPath = null; // null defers to the compiler's default behavior\r", "+        if (libDir != null) {\r", "+          File[] jars = IOUtil.attemptListFiles(libDir, IOUtil.extensionFilePredicate(\"jar\"));\r", "+          if (jars != null) { bootClassPath = Arrays.asList(jars); }\r", "+        }\r", "+\r", "+        try {\r", "+          Class<?>[] sig = { FullVersion.class, String.class, List.class };\r", "+          Object[] args = { version, f.toString(), bootClassPath };\r", "+          CompilerInterface attempt = (CompilerInterface) ReflectUtil.loadLibraryAdapter(loader, path, compilerAdapter, \r", "+                                                                                         sig, args);\r", "+          if (attempt.isAvailable()) { compiler = attempt; }\r", "+        }\r", "+        catch (ReflectException e) { /* can't load */ }\r", "+        catch (LinkageError e) { /* can't load */ }\r", "+      }\r", "+      \r", "+      String debuggerAdapter = adapterForDebugger(version);\r", "+      String debuggerPackage = \"edu.rice.cs.drjava.model.debug.jpda\";\r", "+      if (debuggerAdapter != null) {\r", "+        try {\r", "+          Class<?>[] sig = { GlobalModel.class };\r", "+          // can't use loadLibraryAdapter because we need to preempt the whole package\r", "+          ClassLoader debugLoader = new PreemptingClassLoader(new PathClassLoader(loader, path), debuggerPackage);\r", "+          Debugger attempt = (Debugger) ReflectUtil.loadObject(debugLoader, debuggerAdapter, sig, model);        \r", "+          if (attempt.isAvailable()) { debugger = attempt; }\r", "+        }\r", "+        catch (ReflectException e) { /* can't load */ }\r", "+        catch (LinkageError e) { /* can't load */ }\r", "+      }\r", "+      \r", "+      try {\r", "+        new PathClassLoader(loader, path).loadClass(\"com.sun.tools.javadoc.Main\");\r", "+        File bin = new File(f.getParentFile(), \"../bin\");\r", "+        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(f.getParentFile(), \"../Home/bin\"); }\r", "+        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(System.getProperty(\"java.home\", f.getParent())); }\r", "+        javadoc = new DefaultJavadocModel(model, bin, path);\r", "+      }\r", "+      catch (ClassNotFoundException e) { /* can't load */ }\r", "+      catch (LinkageError e) { /* can't load (probably not necessary, but might as well catch it) */ }\r", "+        \r", "+    }\r", "+    \r", "+    return new JarJDKToolsLibrary(f, version, compiler, debugger, javadoc);\r", "+  }\r"]}], "num": 28834}