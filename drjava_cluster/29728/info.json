{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "73db5a86d4d40fba7e1eb63768aa3644", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e27bc6b75d1407f5c384c02aae59320", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "9c6f88c259086ee69c4d958032e8427e6f011b12", "commitAfterChange": "9437c2299622c109c03b30ccc782cae5639dae6e", "methodNumberBeforeChange": 80, "methodNumberAfterChange": 84, "signatureBeforeChange": "   public Type meet(Type t1, Type t2)", "signatureAfterChange": "      public Type meet(Iterable<? extends Type> ts)", "diff": ["+  ", "+  public Type meet(Iterable<? extends Type> ts) {", "+    return MEET_NORM.value(map(ts, NORMALIZE));", "+  }", "-  /** Compute a common subtype of {@code t1} and {@code t2}. */", "-  public Type meet(Type t1, Type t2) {", "-    if (isSubtype(t1, t2)) { return t1; }", "-    else if (isSubtype(t2, t1)) { return t2; }", "-    else { return new IntersectionType(IterUtil.make(t1, t2)); }", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e8210e3ae8fe9beb2aca4295dadf57cf", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "9c6f88c259086ee69c4d958032e8427e6f011b12", "commitAfterChange": "9437c2299622c109c03b30ccc782cae5639dae6e", "methodNumberBeforeChange": 79, "methodNumberAfterChange": 82, "signatureBeforeChange": "   public Type join(Type t1, Type t2)", "signatureAfterChange": "      public Type join(Iterable<? extends Type> ts)", "diff": ["+  ", "+  public Type join(Iterable<? extends Type> ts) {", "+    return JOIN_NORM.value(map(ts, NORMALIZE));", "+  }", "-  /** Compute a common supertype of {@code t1} and {@code t2}. */", "-  public Type join(Type t1, Type t2) {", "-    //debug.logValues(new String[]{ \"t1\", \"t2\" }, wrap(t1), wrap(t2));", "-    if (isSubtype(t1, t2)) { return t2; }", "-    else if (isSubtype(t2, t1)) { return t1; }", "-    else { return new UnionType(IterUtil.make(t1, t2)); }", "-    // TODO: This solution ignores the possibility that neither is a subtype of the other,", "-    // but that some of the types of two unions are identical or subtypes", "-  }"]}], "num": 29728}