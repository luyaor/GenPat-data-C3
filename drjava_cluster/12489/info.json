{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "87382d1b431e9e23c6ff05d892f31f99", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "191b38b4288f04a3db0f7cab951044ea", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "   public static boolean checkAccessibility(JExpression piece, ModifiersAndVisibility mav, String name,                                             SymbolData enclosingSD, SymbolData thisSD, String dataType, boolean addError)", "signatureAfterChange": "   public static boolean checkAccess(JExpression piece, ModifiersAndVisibility mav, String name,                                      SymbolData enclosingSD, SymbolData thisSD, String dataType, boolean addError)", "diff": ["-  /**Can you reference name from thisSD where name isdefined in enclosingSD */", "-  public static boolean checkAccessibility(JExpression piece, ModifiersAndVisibility mav, String name, ", "-                                           SymbolData enclosingSD, SymbolData thisSD, String dataType, boolean addError) {", "-", "-      if (thisSD.isOuterData(enclosingSD) || enclosingSD.isOuterData(thisSD) || thisSD==enclosingSD) {", "-        return true;", "-      }", "-    ", "-    String[] modifiers = mav.getModifiers();", "-    // Check for the public modifier.", "-    for (int i = 0; i < modifiers.length; i++) {", "-      if (modifiers[i].equals(\"public\")) {", "-        Data enclosingOuter = enclosingSD.getOuterData();", "-        if (enclosingOuter == null) {return true;}", "-        if (enclosingOuter instanceof SymbolData) {", "-          return checkAccessibility(piece, mav, name, enclosingSD.getOuterData().getSymbolData(), thisSD, dataType, addError); //true;", "-        }", "-        throw new RuntimeException(\"Internal Program Error: Trying to reference \" + name + \"which is a member of something other than a class from outside of that thing.  Please report this bug.\");", "-      }", "+    */", "+  public static boolean checkAccess(JExpression piece, ModifiersAndVisibility mav, String name, ", "+                                    SymbolData enclosingSD, SymbolData thisSD, String dataType, boolean addError) {", "+//    if (piece instanceof VariableReference) System.err.println(\"**** Checking access of \" + piece + \"\\nin \" + enclosingSD);", "+    if (thisSD.isOuterData(enclosingSD) || enclosingSD.isOuterData(thisSD) || thisSD.equals(enclosingSD)) {", "+      return true;", "-    // Check for the private modifier.", "-    for (int i = 0; i < modifiers.length; i++) {", "-      if (modifiers[i].equals(\"private\")) {", "-        //As long as one of the symbol datas is the outer data of the other one (at some point down the data chain), private classes/methods/fields can be seen.", "-        //Since we would have already returned, just throw the error and return false.", "-", "-        if (addError) { _addError(\"The \" + dataType + \" \" + Data.dollarSignsToDots(name) + \" is private and cannot be accessed from \" + Data.dollarSignsToDots(thisSD.getName()), piece); }", "-        return false;", "+    // Check for the public modifier.", "+    if (Utilities.isPublic(mav)) {", "+      Data enclosingOuter = enclosingSD.getOuterData();", "+      if (enclosingOuter == null) return true;", "+      if (enclosingOuter instanceof SymbolData) {", "+        return checkAccess(piece, mav, name, enclosingSD.getOuterData().getSymbolData(), thisSD, dataType, addError); ", "+      throw new RuntimeException(\"Internal Program Error: Trying to reference \" + name + ", "+                                 \"which is a member of something other than a class from outside of that thing.  \" +", "+                                 \"Please report this bug.\");", "+    }", "+    ", "+    // Check for the private modifier.", "+    if (Utilities.isPrivate(mav)) {", "+      /* As long as one of the symbol datas is the outer data of the other one (at some point down the data chain), ", "+       * private classes/methods/fields can be seen. Since we would have already returned, just throw the error and ", "+       * return false. */", "+//      Utilities.show(thisSD + \" cannot access symbol '\"  + name + \"' within \" + enclosingSD + \" from '\" + thisSD ", "+//                       + \"' in file \" + piece.getSourceInfo().getFile());", "+//      if (name.equals(\"evalVisitor\")) throw new UnexpectedException(\"evalVisitor BUG\");", "+      String nameWithDots = Data.dollarSignsToDots(name);", "+      String enclosingWithDots = Data.dollarSignsToDots(enclosingSD.getName());", "+      ", "+      // The following is a kludge to eliminate SOME spurious results.", "+      if (nameWithDots.equals(enclosingWithDots) && enclosingSD.isPrimitiveType()) return true;", "+          ", "+      String siteName = Data.dollarSignsToDots(thisSD.getName());", "+      if (addError) { ", "+        _addError(\"The \" + dataType + \" \" + nameWithDots + \" in \" + enclosingWithDots +", "+                  \" is private and cannot be accessed from \" + siteName, ", "+                  piece);", "+//        throw new UnexpectedException(\"Generate Debugging Trace for access failure to \" + nameWithDots + \" in \" ", "+//                                        + enclosingWithDots + \" from \" + siteName);  // DEBUG", "+      }", "+//      Utilities.show(\"enclosingSD = \" + enclosingSD + \" thisSD = \" + thisSD);", "+      return false;", "-    for (int i = 0; i < modifiers.length; i++) {", "-      if (modifiers[i].equals(\"protected\")) {", "-        // Compare the package names. Remember that inner classes have '$' in their names.  NO! TODO: Fix this !!!", "-        if (_areInSamePackage(enclosingSD, thisSD)) {", "-          return true;", "-        }", "-        // Check if thisSD is a subclass of enclosingSD.", "-        //If they are in the same file, they are in the same package, so this does not need to check outer classes, only super classes and interfaces.", "-        if (thisSD.isSubClassOf(enclosingSD)) {", "-          return true;", "-        }", "-        else {", "-          if (addError) { _addError(\"The \" + dataType + \" \" + Data.dollarSignsToDots(name) + \" is protected and cannot be accessed from \" + Data.dollarSignsToDots(thisSD.getName()), piece); }", "-          return false;", "-        }", "+    if (Utilities.isProtected(mav)) {", "+      // Compare the package names. Remember that inner classes have '$' in their names.  NO! TODO: Fix this !!!", "+      if (_areInSamePackage(enclosingSD, thisSD)) {", "+        return true;", "+      }", "+      // Check if thisSD is a subclass of enclosingSD.", "+      // If they are in the same file, they are in the same package, so this does not need to check outer classes, ", "+      // only super classes and interfaces.", "+      if (thisSD.isSubClassOf(enclosingSD)) {", "+        return true;", "+      }", "+      else {", "+        if (addError) _addError(\"The \" + dataType + \" \" + Data.dollarSignsToDots(name) + ", "+                                \" is protected and cannot be accessed from \" + Data.dollarSignsToDots(thisSD.getName()), ", "+                                piece);", "+        return false;", "+", "-    if (_areInSamePackage(enclosingSD, thisSD)) {", "-      return true;", "-    }", "+    if (_areInSamePackage(enclosingSD, thisSD)) return true;", "-      if (addError) { _addError(\"The \" + dataType + \" \" + Data.dollarSignsToDots(name) + \" is package protected because there is no access specifier and cannot be accessed from \" + Data.dollarSignsToDots(thisSD.getName()), piece); }", "+      if (addError) _addError(\"The \" + dataType + \" \" + Data.dollarSignsToDots(name) + ", "+                              \" is package protected because there is no access specifier and cannot be accessed from \" ", "+                                + Data.dollarSignsToDots(thisSD.getName()), ", "+                              piece); "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ae163a89b401e06004eed3f17a4ae49b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/JPDADebugger.java", "commitBeforeChange": "5c952c5847e3008cec3ed5ff89d03d335c050f54", "commitAfterChange": "e3e56a8c058b51612dfa6f1f21259a37eadcdcbb", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 61, "signatureBeforeChange": "   private void _updateWatches() throws DebugException", "signatureAfterChange": "   private void _updateWatches() throws DebugException", "diff": ["-      throw new IllegalStateException(\"Cannot update watches if there \" +", "-                                      \"are no suspended threads.\");", "+      // Not suspended, so all watches are blank", "+      for (int i = 0; i < _watches.size(); i++) {", "+        DebugWatchData currWatch = _watches.elementAt(i);", "+        currWatch.hideValueAndType();", "+      }", "+      return;", "+      // note: obj is null if we're in a static context", "+      ", "+      // Get the name to determine how many $'s there are", "+      String rtName = rt.name();", "+      int numDollars = 0;", "+      int dollarIndex = rtName.indexOf(\"$\", 0);", "+      while (dollarIndex != -1) {", "+        numDollars++;", "+        dollarIndex = rtName.indexOf(\"$\", dollarIndex+1);", "+      }", "-            currWatch.setType(obj.type());", "+            currWatch.setType(String.valueOf(obj.type()));", "-            currWatch.setValue(DebugWatchUndefinedValue.ONLY);", "-            currWatch.setType(null);", "+            // \"this\" is not defined in a static context", "+            currWatch.setNoValue();", "+            currWatch.setNoType();", "-        //List frames = null;", "+        ", "+        // Look for a variable with this name", "-        ", "-        ReferenceType outerRt = rt;", "-        ObjectReference outer = obj;", "-        // if the variable being watched is not a local variable, check if it's a field", "-        if (localVar == null) {", "+", "+        if (localVar != null) {", "+          currWatch.setValue(_getValue(currFrame.getValue(localVar)));", "+          try {", "+            currWatch.setType(String.valueOf(localVar.type()));", "+          }", "+          catch (ClassNotLoadedException cnle) {", "+            currWatch.setNoType();", "+          }", "+        }", "+        // if the variable being watched is not a local variable,", "+        //  check if it's a field", "+        else {", "+          ReferenceType outerRt = rt;", "+          ObjectReference outer = obj;  // (null if static context)", "-          ", "-          // if the variable is not a field either, it's not defined in this", "-          // ReferenceType's scope, keep going further out in scope.", "-          Field outerThis = outerRt.fieldByName(\"this$0\");", "-          ", "+", "+          // If we don't find it here, loop through any enclosing classes", "+          //  Start at this$N, where N is the number of dollar signs in", "+          //  the reference type's name, minus one.", "+          int outerIndex = numDollars - 1;", "+          Field outerThis = outerRt.fieldByName(\"this$\" + outerIndex);", "-            //outer = (ObjectReference)outer.getValue(outerThis);//currFrame.getValue(var);", "-              outerThis = outerRt.fieldByName(\"this$0\");", "+              outerIndex--;", "+              outerThis = outerRt.fieldByName(\"this$\" + outerIndex);", "-          if (field != null) {", "-            currWatch.setValue(_getValue(outer.getValue(field)));", "+          // Try to set the value and type of the field.", "+          //  If the field is not static and we are in a static context", "+          //  (outer==null), we have to setNoValue.", "+          if ((field != null) &&", "+              (field.isStatic() || (outer != null))) {", "+            Value v = (field.isStatic()) ?", "+              outerRt.getValue(field) :", "+              outer.getValue(field);", "+            currWatch.setValue(_getValue(v));", "-              currWatch.setType(field.type());", "+              currWatch.setType(String.valueOf(field.type()));", "-              currWatch.setType(null);", "+              currWatch.setNoType();", "-          /*", "-            ", "-            // crop off the $ if there is one and anything after it", "-            int indexOfDollar = className.lastIndexOf('$');", "-            if (indexOfDollar > -1) {", "-              className = className.substring(0, indexOfDollar);", "-            }", "-            else {", "-              // There is no $ in the className, we're at the outermost class and the", "-              // field still was not found", "-              break;", "-            }", "-            outerRt = (ReferenceType)_vm.classesByName(className).get(0);", "-            if (outerRt == null) {", "-              break;", "-            }", "-            field = outerRt.fieldByName(currName);", "-          }", "-          if (field != null) {", "-            // check if the field is static", "-            if (field.isStatic()) {", "-              currWatch.setValue(_getValue(outerRt.getValue(field)));", "-              try {", "-                currWatch.setType(field.type());", "-              }", "-              catch (ClassNotLoadedException cnle) {", "-                currWatch.setType(null);", "-              }", "-            }", "-            else {", "-              LocalVariable var;", "-              ObjectReference outer;", "-              do {", "-                // get the object reference for outer classes", "-                var = currFrame.visibleVariableByName(\"this$0\");", "-                outer = (ObjectReference)currFrame.getValue(var);", "-              }", "-              while (!outer.referenceType().equals(outerRt));", "-                 ", "-              */", "-          ", "-              /*", "-              StackFrame outerFrame = currFrame;", "-              // the field is not static", "-              // Check if the frame represents a native or static method and", "-              // keep going down the stack frame looking for the frame that", "-              // has the same ReferenceType that we found the Field in.", "-              // This is a hack, remove it to slightly improve performance but", "-              // at the loss of ever being able to watch outer instance", "-              // fields. If unremoved, this will work sometimes, but not always.", "-              while (outerFrame.thisObject() != null &&", "-                     !outerFrame.thisObject().referenceType().equals(outerRt) &&", "-                     stackIndex < frames.size()) {", "-                outerFrame = (StackFrame) frames.get(stackIndex);", "-                stackIndex++;", "-              }", "-              if (stackIndex < frames.size() && outerFrame.thisObject() != null) {", "-                // then we found the right stack frame", "-                currWatch.setValue(_getValue(outerFrame.thisObject().getValue(field)));", "-                try {", "-                  currWatch.setType(field.type());", "-                }", "-                catch (ClassNotLoadedException cnle) {", "-                  currWatch.setType(null);", "-                }", "-              }", "-              else {", "-                currWatch.setValue(DebugWatchUndefinedValue.ONLY);", "-                currWatch.setType(null);", "-              }", "-              ", "-            }*/", "-            currWatch.setValue(DebugWatchUndefinedValue.ONLY);", "-            currWatch.setType(null);", "+            currWatch.setNoValue();", "+            currWatch.setNoType();", "-        else {", "-          currWatch.setValue(_getValue(currFrame.getValue(localVar)));", "-          try {", "-            currWatch.setType(localVar.type());", "-          }", "-          catch (ClassNotLoadedException cnle) {", "-            currWatch.setType(null);", "-          }", "-        }", "+        "]}], "num": 12489}