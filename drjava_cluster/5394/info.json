{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d0f349be863e5002a400d1a63e18b508", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "257c82f99f1bc204f1370b0bb7523105", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 48, "methodNumberAfterChange": 48, "signatureBeforeChange": "   protected SymbolData _identifyType(String name, SourceInfo si, String enclosingClassName)", "signatureAfterChange": "   protected SymbolData _identifyType(String name, SourceInfo si, String enclosingClassName)", "diff": ["-    * datas.  We need to use the relative inner class name to do this. */", "+    * inner classes of the chain of enclosing datas.  We need to use the relative inner class name to do this. */", "-//    System.err.println(\"Calling _identifyType(\" + name  + \") within \" + enclosingClassName);", "+//    System.err.println(\"***** Calling _identifyType(\" + name  + \") within \" + enclosingClassName);", "+    ", "+    // If name is a type variable, return the binding", "+    if (_genericTypes.containsKey(name)) return _genericTypes.get(name);", "-    SymbolData enclosingSD = getQualifiedSymbolData(enclosingClassName, SourceInfo.NO_INFO);", "-    if (enclosingSD == null) {", "+//    if (name.equals(\"ResType\") && sd == null) ", "+//      Utilities.show(\"_genericTypes = \" + _genericTypes + \"Trace follows.\\n\" + Utilities.getStackTrace());", "+        ", "+//    if (enclosingClassName == null) Utilities.show(\"_identifyType called with null enclosingClassName. Trace follows.\\n\" +", "+//                                                   Utilities.getStackTrace());", "+   ", "-      return null;  // should only happen in tests", "-    }", "+    if (enclosingClassName == null) return null;  // happens for binding occurrences of type variables?", "+    ", "+    SymbolData enclosingSD = getQualifiedSymbolData(enclosingClassName, SourceInfo.NONE);   ", "+    if (enclosingSD == null) return null;", "+    ", "-    ", "+   ", "+//    System.err.println(\"***** _identifyType(\" + name  + \") within \" + enclosingClassName + \" RETURNED \" + sd);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c187ae0a0fa37437be630a417e9f390", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 58, "signatureBeforeChange": "              public FieldVisitor visitField(int access, String name, String desc, String sig, Object value)", "signatureAfterChange": "   protected void identifyInnerClasses(TypeDefBase that)", "diff": ["-      ", "-      public FieldVisitor visitField(int access, String name, String desc, String sig, Object value) {", "-        /* Private fields cannot be ignored because they are used in code augmentation for generating constructors,", "-         * equals, and hashCode. */", "-        String typeString = org.objectweb.asm.Type.getType(desc).getClassName();", "-        SymbolData type = getSymbolDataForClassFile(typeString, lookupInfo);", "-        if (type != null) { sd.addVar(new VariableData(name, _createMav(access), type, true, sd)); }", "-        return null;", "-      }", "+  /** Processes the class body that. */", "+  protected void identifyInnerClasses(TypeDefBase that) {", "+    String enclosingType = getQualifiedClassName(that.getName().getText());", "+    assert enclosingType != null;", "+    // Process the members of this class", "+    System.err.println(\"Finding inner classes in \" + enclosingType);", "+    SymbolData sd = getSymbolData(enclosingType, SourceInfo.NO_INFO);", "+    BracedBody body = that.getBody();", "+    for (BodyItemI bi: body.getStatements()) {", "+      if (bi instanceof TypeDefBase) {", "+        TypeDefBase type = (TypeDefBase) bi;", "+        String rawClassName = type.getName().getText();", "+        System.err.println(\"Adding \" + rawClassName + \" to inner classes of \" + enclosingType + \"\\n\");", "+        String fullClassName = enclosingType + '.' + rawClassName;", "+//        System.err.println(\"Adding \" + rawClassName + \" to _innerClassesInThisBody inside \" + that + \"\\n\");", "+        ", "+//          _innerClassesInThisBody.add(fullClassName);", "+        SymbolData innerSD = makeContinuation(bi.getSourceInfo(), fullClassName);", "+        sd.addInnerClass(innerSD);", "+      }", "+    }", "+//    System.err.println(\"_innerClassesInThisBody = \" + _innerClassesInThisBody);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "67b761fdac1c5966e0b80f8019071ee8", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 47, "signatureBeforeChange": "   protected SymbolData getSymbolDataForClassFile(String className, SourceInfo si)", "signatureAfterChange": "   private SymbolData _identifyType(String name, SourceInfo si, String enclosingClassName)", "diff": ["-    */", "-  protected SymbolData getSymbolDataForClassFile(String className, SourceInfo si) {", "-    SymbolData sd = getSymbolDataHelper(className, si, true, true, true, false);", "-    ", "-    if (sd == null) {", "-      // This is an error in the user's class file so throw an error.", "-      // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-      _addAndIgnoreError(\"Class \" + className + \" not found.\", new NullLiteral(si));", "-      return null;", "-    }", "-    sd.setIsContinuation(false);", "-    ", "-    continuations.remove(sd.getName());", "-    return sd;", "-  }", "+    * datas.  We need to use the relative inner class name to do this. */", "+  private SymbolData _identifyType(String name, SourceInfo si, String enclosingClassName) {", "+    System.err.println(\"Calling _identifyType(\" + name  + \") within \" + enclosingClassName);", "+    SymbolData sd = getSymbolData(name, si);  // TODO: uses wrong enclosingClassName!!!", "+    if (sd != null) return sd;", "+    SymbolData enclosingSD = getQualifiedSymbolData(enclosingClassName, SourceInfo.NO_INFO);", "+    if (enclosingSD == null) {", "+      System.err.println(\"***ERROR*** in _identifyType \" + enclosingClassName + \" NOT FOUND\");", "+      return null;  // should only happen in tests", "+    sd = enclosingSD.getInnerClassOrInterface(name);", "+     ", "+    if (sd != null) return sd;", "+//    ", "+//    // Create continuation for new type", "+//    String qualifiedTypeName = enclosingClassName + '.' + name;", "+//    if (_innerClassesInThisBody.contains(qualifiedTypeName)) {  ", "+//      // reference to an inner class that will subsequently be defined", "+//      sd = addInnerSymbolData(si, qualifiedTypeName, enclosingSD);", "+//    }", "+    ", "+    return sd;  // Note: sd is null if name is not identified."]}], "num": 5394}