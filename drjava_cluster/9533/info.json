{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cd1f856b7c82eceace619ded6a50c5b9", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a66307bcc32313c352423ebb343e91e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 57, "signatureBeforeChange": "   private SymbolData _lookupFromClassesToBeParsed(String qualifiedClassName, SourceInfo si, boolean resolve)", "signatureAfterChange": "   public void anonymousClassInstantiationHelper(AnonymousClassInstantiation that, SymbolData enclosing, String superName)", "diff": ["-    */", "-  private SymbolData _lookupFromClassesToBeParsed(String qualifiedClassName, SourceInfo si, boolean resolve) {", "-    if (resolve) {", "-      Pair<TypeDefBase, LanguageLevelVisitor> p = _classesToBeParsed.get(qualifiedClassName);", "-      if (p == null) {", "-        // This occurs when a class depends upon another class in the same file that has a bogus super class.", "-        // Perhaps occurs elsewhere...?", "-        return null;", "-      }", "-      // Check for cyclic inheritance.", "-      TypeDefBase cd = p.getFirst();", "-      LanguageLevelVisitor llv = p.getSecond();", "-      cd.visit(llv);", "-      return symbolTable.get(qualifiedClassName);", "-    }", "-    else {", "-      // Return a continuation, since it shouldn't be in the symbolTable yet based on where we call this method from.", "-      // The visitor we pair here doesn't matter because it should always get removed from the continuations list before", "-      // it is visited.", "-//      System.err.println(\"Creating continuation for class to be parsed: \" + qualifiedClassName);", "-      SymbolData sd = addSymbolData(si, qualifiedClassName);", "-      return sd;", "-    }", "-  }", "+    */", "+  public void anonymousClassInstantiationHelper(AnonymousClassInstantiation that, SymbolData enclosing, String superName) {", "+    that.getArguments().visit(this);", "+    SymbolData enclosingSD = enclosing.getSymbolData();", "+    String enclosingSDName = enclosingSD.getName();", "+    assert enclosingSDName.equals(_enclosingClassName);", "+    String anonName = getQualifiedClassName(enclosingSDName) + \"$\" +  enclosingSD.preincrementAnonymousInnerClassNum();", "+    ", "+    System.err.println(\"****** In anonymousCIH the anonName = \" + anonName + \" superName = \" + superName ", "+                         + \" enclosing = \" + enclosing);", "+    ", "+    // Define the SymbolData that will correspond to this anonymous class", "+    SymbolData anonSD = defineAnonymousSymbolData(that, anonName, superName);", "+    ", "+//    if (this instanceof IntermediateVisitor) {", "+    // These methods are no-ops in FullJavaVisitor", "+    createToString(anonSD);", "+    createHashCode(anonSD);", "+    createEquals(anonSD);", "+    // Accessors will be filled in in typeChecker pass", "+//    }", "+    ", "+    // Visit the body (with the appropritate class body visitor to get it all nice and resolved.", "+    System.err.println(\"Calling appropriate class body visitor for \" + anonName);", "+    that.getBody().visit(newClassBodyVisitor(anonSD, anonName));", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9800985d4977b64e78aacc378775595e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "093f33e43dd3de7d97364f410a0a58ca1448a1ce", "commitAfterChange": "51703b3c111cc35e01e35a5e289226f6da1c1962", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": "   protected SymbolData addSymbolData(TypeDefBase typeDefBase, String qualifiedClassName)", "signatureAfterChange": "   protected SymbolData defineSymbolData(TypeDefBase typeDefBase, String qualifiedClassName)", "diff": ["-  protected SymbolData addSymbolData(TypeDefBase typeDefBase, String qualifiedClassName) {", "-    String name = qualifiedClassName;", "+  protected SymbolData defineSymbolData(TypeDefBase typeDefBase, String qualifiedClassName) {", "+    String name = qualifiedClassName;  // may be an interface", "-    if (sd != null && !sd.isContinuation()) {", "-      _addAndIgnoreError(\"This class has already been defined.\", typeDefBase);", "+    if (sd != null && ! sd.isContinuation()) {", "+      _addAndIgnoreError(\"The class or interface \" + name + \" has already been defined.\", typeDefBase);", "+    ", "+    // Create SymbolDatas (continuations) for the interfaces if they do not already exist", "+    // Create a SymbolData for the superclass of typeDefBase", "+    ", "+//      if (superClassName.equals(\"TestCase\") || superClassName.equals(\"junit.framework.TestCase\")) {", "+//            System.out.println(\"WARNING! \" + superClassName + \" encountered as superclass\");", "+//            assert false;", "+//      }", "-      superClass = getSymbolData(superClassName, si, false); //TODO: change this back to true?", "+      // The following line generates an infinite recursion in some cases if resolve (the 3rd parm) is true.  Yet", "+      // when superclass is TestCase and TestCase is not imported", "+      superClass = getSymbolData(superClassName, si, false); //TODO: if true can generate infinite loop in helper", "+      }", "+      sd.setInterface(false);", "+    }", "+    ", "+    else { throw new RuntimeException(\"Internal Program Error: typeDefBase was not a ClassDef or InterfaceDef.\" + ", "+                                      \"  Please report this bug.\"); }", "+    ", "+    // get the SymbolData of the superclass which must be in the symbol table", "+    // since we visited the type in forClassDef() although it may be a continuation. ", "+    ", "+    // there is a continuation in the symbol table, update the fields", "+    sd.setMav(typeDefBase.getMav());", "+    sd.setTypeParameters(typeDefBase.getTypeParameters());", "+    sd.setSuperClass(superClass);", "+    sd.setInterfaces(interfaces);", "+    sd.setIsContinuation(false);", "+    _log.log(\"REMOVING continuation \" + sd.getName());", "+    continuations.remove(sd.getName());", "+    ", "+    if (! sd.isInterface()) { LanguageLevelConverter._newSDs.put(sd, this); }", "+    return sd;", "+  }", "-    ", "-    if (! sd.isInterface()) {_newSDs.put(sd, this); }"]}], "num": 9533}