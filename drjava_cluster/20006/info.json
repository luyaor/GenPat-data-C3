{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ec409ea5a81dc36e1a0990e4e6514def", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e8e1b5ac37619a3c665ab64efce8bb0b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 364, "methodNumberAfterChange": 261, "signatureBeforeChange": "   private Iterable<? extends ClassType>      lookupClasses(Type t, Lambda<? super Boolean, ? extends Predicate<? super DJClass>> makePred,                   final Iterable<? extends Type> typeArgs)", "signatureAfterChange": "     public PredicateSet<T> findAll(Type t)", "diff": ["+    /** Produce all matching members of t (both declared and inherited). */", "+    public PredicateSet<T> findAll(Type t) { return find(t, true); }", "-   */", "-  private Iterable<? extends ClassType> ", "-    lookupClasses(Type t, Lambda<? super Boolean, ? extends Predicate<? super DJClass>> makePred,", "-                  final Iterable<? extends Type> typeArgs) {", "-    /** Produces a type for the inner class; note that no checks are made on the type arguments */", "-    class LookupClass extends TypeAbstractVisitor<Iterable<ClassType>> {", "-      ", "-      private final Predicate<? super DJClass> _matchInner;", "-      ", "-      public LookupClass(Predicate<? super DJClass> matchInner) {", "-        _matchInner = matchInner;", "-      }", "-      ", "-      public Iterable<ClassType> defaultCase(Type t) { return IterUtil.empty(); }", "-      ", "-      @Override public Iterable<ClassType> forClassType(final ClassType t) {", "-        debug.logStart(\"t\", wrap(t)); try {", "-          ", "-        Lambda<DJClass, ClassType> makeType = new Lambda<DJClass, ClassType>() {", "-          public ClassType value(DJClass c) {", "-            ClassType dynamicOuter; // may be null", "-            if (c.isStatic()) { dynamicOuter = SymbolUtil.dynamicOuterClassType(t); }", "-            else { dynamicOuter = t; }", "-            if (dynamicOuter instanceof ParameterizedClassType) {", "-              Iterable<? extends Type> outerTypeArgs = ((ParameterizedClassType) dynamicOuter).typeArguments();", "-              return new ParameterizedClassType(c, IterUtil.compose(outerTypeArgs, typeArgs));", "-            }", "-            else if (dynamicOuter instanceof RawClassType) {", "-              // malformed if type args is nonempty -- that should be caught by the caller", "-              return IterUtil.isEmpty(typeArgs) ? new RawClassType(c) : new ParameterizedClassType(c, typeArgs);", "-            }", "-            else {", "-              return IterUtil.isEmpty(typeArgs) ? new SimpleClassType(c) : new ParameterizedClassType(c, typeArgs);", "-            }", "-          }", "-        };", "-        debug.logValue(\"declaredClasses\", t.ofClass().declaredClasses());", "-        return IterUtil.mapSnapshot(IterUtil.filter(t.ofClass().declaredClasses(), _matchInner), makeType);", "-        ", "-        } finally { debug.logEnd(); }", "-      }", "-      ", "-    }", "-    return lookupMember(t, new LookupClass(makePred.value(true)), new LookupClass(makePred.value(false)));", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f2c44595699d033a320f5af398fbf886", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "e8c00117275c4794f9b044ac36c056a72d163888", "commitAfterChange": "615ff23a704e8a18c51abf1bd9015de115551141", "methodNumberBeforeChange": 331, "methodNumberAfterChange": 331, "signatureBeforeChange": "     public boolean moreSpecificThan(FunctionInvocationCandidate<F> c)", "signatureAfterChange": "     public boolean moreSpecificThan(FunctionInvocationCandidate<F> c)", "diff": ["-      SignatureMatcher m = makeMatcher(c._f.typeParameters(), EMPTY_TYPE_ITERABLE, SymbolUtil.parameterTypes(c._f), ", "-                                       IterUtil.mapSnapshot(SymbolUtil.parameterTypes(_f), EMPTY_EXPRESSION_FOR_TYPE),", "+      Iterable<Type> supParams = SymbolUtil.parameterTypes(c._f);", "+      Iterable<Type> subParams = SymbolUtil.parameterTypes(_f);", "+      if (SymbolUtil.isVararg(c._f)) {", "+        // Adjust param type lists to match arities, if possible.  Can't use SignatureMatcher.matchesWithVarargs()", "+        // because it uses boxing, which is not allowed here.", "+        int supArity = IterUtil.sizeOf(supParams);", "+        int subArity = IterUtil.sizeOf(subParams);", "+        if (SymbolUtil.isVararg(_f)) {", "+          if (subArity < supArity) { // fill in extra sub args", "+            Iterable<Type> prefixSubs = IterUtil.skipLast(subParams);", "+            Type lastSub = IterUtil.last(subParams);", "+            Iterable<Type> subExtras = IterUtil.copy(((ArrayType) lastSub).ofType(), supArity-subArity);", "+            subParams = IterUtil.compose(IterUtil.compose(prefixSubs, subExtras), lastSub);", "+          }", "+          else if (subArity > supArity) {", "+            Iterable<Type> prefixSups = IterUtil.skipLast(supParams);", "+            Type lastSup = IterUtil.last(supParams);", "+            Iterable<Type> supExtras = IterUtil.copy(((ArrayType) lastSup).ofType(), subArity-supArity);", "+            supParams = IterUtil.compose(IterUtil.compose(prefixSups, supExtras), lastSup);", "+          }", "+          // if they're equal, no adjustments are needed", "+        }", "+        else {", "+          // This case doesn't occur in practice, because \"more specific\" is only used to compare", "+          // methods that all match in the same phase (directly, with boxing, or with varargs).", "+          if (subArity < supArity) { supParams = IterUtil.skipLast(supParams); } // allow sub to elide the vararg param", "+          else if (subArity > supArity) {", "+            Iterable<Type> prefixSups = IterUtil.skipLast(supParams);", "+            Type lastSup = IterUtil.last(supParams);", "+            int varargArgs = subArity-(supArity-1); // expect this many args of the vararg type", "+            supParams = IterUtil.compose(prefixSups, IterUtil.copy(((ArrayType) lastSup).ofType(), varargArgs));", "+          }", "+          // if they're equal, no adjustments are needed", "+          // (If lastSup is T..., lastSub might be a subtype of T or of T[].  For the purposes of", "+          // \"more specific\", we arbitrarily require it to be a subtype of T[].)", "+        }", "+      }", "+      SignatureMatcher m = makeMatcher(c._f.typeParameters(), EMPTY_TYPE_ITERABLE, supParams, ", "+                                       IterUtil.mapSnapshot(subParams, EMPTY_EXPRESSION_FOR_TYPE),"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f6a71cc7f09481b5648cf32014d77e46", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "e2abbf01d6f3b23be51f493f663daa5ce8abf706", "commitAfterChange": "d7bd3eaf7514715e375acabd9bf0f41e4281985a", "methodNumberBeforeChange": 308, "methodNumberAfterChange": 274, "signatureBeforeChange": "     public boolean overrides(FunctionInvocationCandidate<I> c)", "signatureAfterChange": "     private boolean overrides(DJMethod child, DJMethod parent)", "diff": ["+    /** True iff child is override-compatible with the parent.  (See JLS 8.4.2.) */", "+    private boolean overrides(DJMethod child, DJMethod parent) {", "+      if (child.declaredName().equals(parent.declaredName())) {", "+        Iterable<Type> subParams = SymbolUtil.parameterTypes(child);", "+        Iterable<Type> supParams = SymbolUtil.parameterTypes(parent);", "+        Iterable<VariableType> subTParams = child.typeParameters();", "+        Iterable<VariableType> supTParams = parent.typeParameters();", "+        if (IterUtil.sizeOf(subParams) == IterUtil.sizeOf(supParams)) {", "+          Iterable<? extends Type> supParamsToCompare;", "+          if (IterUtil.isEmpty(subTParams) && !IterUtil.isEmpty(supTParams)) {", "+            supParamsToCompare = IterUtil.map(supParams, ERASE);", "+          }", "+          else if (IterUtil.sizeOf(subTParams) == IterUtil.sizeOf(supTParams)) {", "+            supParamsToCompare = substitute(supParams, supTParams, subTParams);", "+          }", "+          else { return false; }", "+          for (Pair<Type, Type> p : IterUtil.zip(subParams, supParamsToCompare)) {", "+            if (!isEqual(p.first(), p.second())) { return false; }", "+          }", "+          return true;", "+        }", "+        else { return false; }", "+      }", "+      else { return false; }", "+    }", "-     */", "-    public boolean overrides(FunctionInvocationCandidate<I> c) {", "-      if (_f.declaredName().equals(c._f.declaredName())) {", "-        Iterable<Type> subParams = parameterTypes();", "-        Iterable<Type> supParams = c.parameterTypes();", "-        Iterable<VariableType> subTParams = typeParameters();", "-        Iterable<VariableType> supTParams = c.typeParameters();", "-        if (IterUtil.sizeOf(subParams) == IterUtil.sizeOf(supParams)) {", "-          Iterable<? extends Type> supParamsToCompare;", "-          if (IterUtil.isEmpty(subTParams) && !IterUtil.isEmpty(supTParams)) {", "-            supParamsToCompare = IterUtil.map(supParams, ERASE);", "-          }", "-          else if (IterUtil.sizeOf(subTParams) == IterUtil.sizeOf(supTParams)) {", "-            supParamsToCompare = substitute(supParams, supTParams, subTParams);", "-          }", "-          else { return false; }", "-          for (Pair<Type, Type> p : IterUtil.zip(subParams, supParamsToCompare)) {", "-            if (!isEqual(p.first(), p.second())) { return false; }", "-          }", "-          return true;", "-        }", "-        else { return false; }", "-      }", "-      else { return false; }", "-    }"]}], "num": 20006}