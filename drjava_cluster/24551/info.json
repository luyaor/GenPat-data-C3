{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "52a034672b5c516bd3eb7df867829863", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2898d7c5b0606f70006bc95612de0fbc", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "476f4df6ab63cd1004cb7cc36238fad228ab6d80", "commitAfterChange": "2df7289d55456372fbaf4e3ab78549d8571648f8", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 78, "signatureBeforeChange": "   public ClassPathVector getClassPath()", "signatureAfterChange": "   public ClassPathVector getClassPath()", "diff": ["-  public ClassPathVector getClassPath() { return _jvm.getClassPath(); }", "+   */", "+  public ClassPathVector getClassPath() {", "+    ClassPathVector result = new ClassPathVector();", "+    ", "+    if (isProjectActive()) {", "+      File buildDir = getBuildDirectory();", "+      if (buildDir != null) { _addFileToClassPath(buildDir, result); }", "+      ", "+      /* We prefer to assume the project root is the project's source root, rather than", "+       * checking *every* file in the project for its source root.  This is a bit problematic,", "+       * because \"Compile Project\" won't care if the user has multiple source roots (or even just a", "+       * single \"src\" subdirectory), and the user in this situation (assuming the build dir is ", "+       * null) wouldn't notice a problem until trying to access the compiled classes in the ", "+       * Interactions.", "+       */", "+      File projRoot = getProjectRoot();", "+      if (projRoot != null) { _addFileToClassPath(projRoot, result); }", "+      ", "+      ClassPathVector projectExtras = getExtraClassPath();", "+      if (projectExtras != null) { result.addAll(projectExtras); }", "+    }", "+    else {", "+      for (File f : getSourceRootSet()) { _addFileToClassPath(f, result); }", "+    }", "+      ", "+    Vector<File> globalExtras = DrJava.getConfig().getSetting(EXTRA_CLASSPATH);", "+    if (globalExtras != null) {", "+      for (File f : globalExtras) { _addFileToClassPath(f, result); }", "+    }", "+    ", "+    /* We must add JUnit to the class path.  We do so by including the current JVM's class path.", "+     * This is not ideal, because all other classes on the current class path (including all of DrJava's", "+     * internal classes) are also included.  But we're probably stuck doing something like this if we", "+     * want to continue bundling JUnit with DrJava.", "+     */", "+    String currentClassPath = System.getProperty(\"java.class.path\");", "+    if (currentClassPath != null) {", "+      // TODO: Parsing this string needs to only happen once, not every time this method is invoked.", "+      StringTokenizer tokens = new StringTokenizer(currentClassPath, File.pathSeparator);", "+      while (tokens.hasMoreTokens()) {", "+        _addFileToClassPath(new File(tokens.nextToken()), result);", "+      }", "+    }", "+    ", "+    return result;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36f0bc6a0fee98f2c45c6dbf348d73cc", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "74f78a37f662a82d90e6d47182c226ff9314be8c", "commitAfterChange": "56fdc380f0aee79a90c160b06fcb5549f8bb95f4", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "diff": ["-\t    // _log.log(\"Not augmenting \" + f + \" no mediator\");", "+     // _log.log(\"Not augmenting \" + f + \" no mediator\");", "-            BufferedWriter bw = new BufferedWriter(new FileWriter(augmentedFile));", "+            StringWriter sw = new StringWriter();", "+            BufferedWriter bw = new BufferedWriter(sw);", "+            ", "+            // write out the line number map and the augmented java file", "+            PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(augmentedFile)));", "+            SortedMap<Integer,Integer> lineNumberMap = a.getLineNumberMap();", "+            pw.println(\"// Language Level Converter line number map: dj*->java. Entries: \"+lineNumberMap.size());", "+            // We print out LINE_NUM_MAPPINGS_PER_LINE mappings per line, so we need numLines", "+            // at the top of the file, and one more for a descriptive comment.", "+            // That means we need to increase the line numbers in the generated java file by numLines+1", "+            int numLines = (int)Math.ceil(((double)lineNumberMap.size())/LINE_NUM_MAPPINGS_PER_LINE);", "+            int mapCount = 0;", "+            for(Map.Entry<Integer,Integer> e: lineNumberMap.entrySet()) {", "+              // e.getKey(): dj* line number; e.getValue(): java line number (must be increased by numLines)", "+              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==0) pw.print(\"//\");", "+              pw.printf(\" %5d->%-5d\", e.getKey(), (e.getValue()+numLines+1));", "+              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==LINE_NUM_MAPPINGS_PER_LINE-1) pw.println();", "+              ++mapCount;", "+            }", "+            if (mapCount%LINE_NUM_MAPPINGS_PER_LINE!=0) pw.println(); // print a newline unless we just printed one", "+            ", "+            String augmented = sw.toString();", "+            pw.write(augmented, 0, augmented.length());", "+            pw.close();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "441a0825ad5ccb89ece9b2a0d9639dbf", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/StatementChecker.java", "commitBeforeChange": "b125d4a35b225e9cc738f569b062e7e7bd7cf031", "commitAfterChange": "9ce155a1f3e34352032d821032cb2dc70024460f", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "   @Override public TypeContext visit(TryStatement node)", "signatureAfterChange": "   @Override public TypeContext visit(TryStatement node)", "diff": ["-    node.getTryBlock().acceptVisitor(this);", "-    for (CatchStatement c : node.getCatchStatements()) { c.acceptVisitor(this); }", "-    if (node.getFinallyBlock() != null) { node.getFinallyBlock().acceptVisitor(this); }", "-    return context;", "-  }", "+    List<Type> caughtTypes = new LinkedList<Type>();", "+    for (CatchStatement c : node.getCatchStatements()) {", "+      FormalParameter p = c.getException();", "+      Type caughtT = checkTypeName(p.getType());", "+      if (!ts.isAssignable(TypeSystem.THROWABLE, caughtT)) {", "+        setErrorStrings(c, ts.userRepresentation(caughtT));", "+        throw new ExecutionError(\"catch.type\", c);", "+      }", "+      if (!ts.isReifiable(caughtT)) {", "+        throw new ExecutionError(\"reifiable.type\", c);", "+      }", "+      setVariable(p, new LocalVariable(p.getName(), caughtT, p.isFinal()));", "+      setErasedType(c, ts.erasedClass(caughtT));", "+      caughtTypes.add(caughtT);", "+    TypeContext tryContext = new TryBlockContext(context, caughtTypes);", "+    node.getTryBlock().acceptVisitor(new StatementChecker(tryContext, opt));", "+    ", "+    for (CatchStatement c : node.getCatchStatements()) {", "+      TypeContext catchContext = new LocalContext(context, getVariable(c.getException()));", "+      c.getBlock().acceptVisitor(new StatementChecker(catchContext, opt));", "+    }", "+    ", "+    if (node.getFinallyBlock() != null) { node.getFinallyBlock().acceptVisitor(this); }", "+    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7d8cf8585270321cef1e198105820f4e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/DefaultCompilerModel.java", "commitBeforeChange": "7b462e5cdfbc488a99d67df352bda94ace89024b", "commitAfterChange": "885cfecca904bc390539dbda728502710df6c2d9", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 17, "signatureBeforeChange": "   private List<File>      _compileLanguageLevelsFiles(List<File> files, List<DJError> errors,                                 Iterable<File> classPath, Iterable<File> bootClassPath) throws IOException", "signatureAfterChange": "   private List<File> _compileLanguageLevelsFiles(List<File> files, List<DJError> errors,                                                            Iterable<File> classPath, Iterable<File> bootClassPath)", "diff": ["-  private List<File> ", "-    _compileLanguageLevelsFiles(List<File> files, List<DJError> errors,", "-                                Iterable<File> classPath, Iterable<File> bootClassPath) throws IOException {", "+  private List<File> _compileLanguageLevelsFiles(List<File> files, List<DJError> errors,", "+                                                           Iterable<File> classPath, Iterable<File> bootClassPath) {", "+    LinkedList<File> newFiles = new LinkedList<File>();  // Used to record the LL files that must be converted", "+    LinkedList<File> filesToBeClosed = new LinkedList<File>(); // Used to record .java files that are open at the same time as their .dj? files.", "+        ", "-        if (javaFileSet.contains(javaFile)) { _showConflictingFilesMessage(javaFile); }", "+        ", "+        //checks if .dj? file has a matching .java file open in project. Eventually warns user (later on in code)", "+        if(files.contains(javaFile)){", "+          ", "+          filesToBeClosed.add(javaFile);", "+          ", "+        } ", "-", "+        newFiles.add(javaFile);", "+        ", "+      }   ", "+      else{  ", "+        javaFileSet.add(canonicalFile);", "-      else {", "-        if (javaFileSet.contains(canonicalFile)) { // canonicalFile was already added for a corresponding .dj* file", "-          _showConflictingFilesMessage(canonicalFile); }  ", "-        javaFileSet.add(canonicalFile); ", "+    }", "+    ", "+    for(File f: filesToBeClosed) {", "+      ", "+      File canonicalFile = IOUtil.attemptCanonicalFile(f);", "+      String fileName = canonicalFile.getPath();", "+      ", "+      if(files.contains(new File(fileName.substring(0,fileName.lastIndexOf(\".java\"))+\".dj0\")) ||", "+         files.contains(new File(fileName.substring(0,fileName.lastIndexOf(\".java\"))+\".dj1\")) ||", "+         files.contains(new File(fileName.substring(0,fileName.lastIndexOf(\".java\"))+\".dj2\"))", "+        ) {", "+        files.remove(new File(fileName));", "+      ", "+      ", "+    }", "+    ", "+    if(!filesToBeClosed.isEmpty()){", "+      new edu.rice.cs.drjava.ui.DrJavaScrollableDialog(null, \"Warning: Files need to be closed\",", "+                                                       \"The following files have matching .dj? files open.\", ", "+                                                       \"These .java files need to be closed for proper compiling. \\n \\n \\n\" +", "+                                                       filesToBeClosed.toString().replace(\", \",\"\\n\"),true).show();", "+      ", "+//      // Confirm that the .java files corresponding to .dj* files exist.", "+//      for (File f: newFiles)", "+//        if (! f.exists()) Utilities.show(f + \" does not exist\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b5ba022617a094e32a718cbc96a61774", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/MainFrame.java", "commitBeforeChange": "6a170ab14316cceed86d0cd5eef7d1a5e1482088", "commitAfterChange": "8de007bf6be2b43ee2e0404f529aa96c640a30ed", "methodNumberBeforeChange": 545, "methodNumberAfterChange": 545, "signatureBeforeChange": "          public void interactionEnded()", "signatureAfterChange": "          public void interactionEnded()", "diff": ["+      InteractionsModel im = _model.getInteractionsModel();", "+      edu.rice.cs.plt.tuple.Pair<String,String> lastError = im.getLastError();", "+      if (DrJava.getConfig().getSetting(edu.rice.cs.drjava.config.OptionConstants.DIALOG_AUTOIMPORT_ENABLED)) {", "+        if (lastError!=null) {", "+          // the interaction ended and there was an error", "+          String exceptionClass = lastError.first();", "+          String message = lastError.second();", "+          edu.rice.cs.plt.tuple.Pair<String,String> secondToLastError = im.getSecondToLastError();", "+          if ((secondToLastError==null) || // either there was no 2nd to last error", "+              (!secondToLastError.first().equals(exceptionClass)) || // or it is different", "+              (!secondToLastError.second().equals(message))) {", "+            // this aborts the auto-importing if the same class comes up twice in a row", "+            if (\"koala.dynamicjava.interpreter.error.ExecutionError\".equals(exceptionClass) &&", "+                message != null &&", "+                message.startsWith(\"Undefined class '\") &&", "+                message.endsWith(\"'\")) {", "+              // it was an \"undefined class\" exception", "+              // show auto-import dialog", "+              String undefinedClassName = message.substring(message.indexOf('\\'')+1,message.lastIndexOf('\\''));", "+              _showAutoImportDialog(undefinedClassName);          ", "+            }", "+          }", "+        }", "+      } else {", "+        // reset the last errors, so the dialog works again if it is re-enabled", "+        im.resetLastErrors();", "+      }", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb238e8a70f1573d72201d9e09413483", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractGlobalModel.java", "commitBeforeChange": "0d5df6cd7df2851aa927f5b2af952c4c284e3a43", "commitAfterChange": "d809f0c0466409ce32ae91b0868974eef6e3d031", "methodNumberBeforeChange": 159, "methodNumberAfterChange": 159, "signatureBeforeChange": "   private void _loadProject(final ProjectFileIR ir) throws IOException", "signatureAfterChange": "   private void _loadProject(final ProjectFileIR ir) throws IOException", "diff": ["+    ArrayList<DocumentRegion> expiredBookmarks = new ArrayList<DocumentRegion>();", "+    ArrayList<Breakpoint> expiredBreakpoints = new ArrayList<Breakpoint>();", "-      if (f.lastModified() > f.getSavedModDate()) f.setSavedModDate (f.lastModified());", "+      if (f.lastModified() > f.getSavedModDate()) {", "+        for (DocumentRegion r: getBookmarkManager().getRegions())", "+          if (r.getFile().equals( f )) expiredBookmarks.add( r );", "+        for (Breakpoint r: getBreakpointManager().getRegions())", "+          if (r.getFile().equals( f )) expiredBreakpoints.add( r );", "+        f.setSavedModDate (f.lastModified());", "+      }", "-      if (f.lastModified() > f.getSavedModDate()) f.setSavedModDate (f.lastModified());", "+      if (f.lastModified() > f.getSavedModDate()) {", "+        for (DocumentRegion r: getBookmarkManager().getRegions())", "+          if (r.getFile().equals( f )) expiredBookmarks.add( r );", "+        for (Breakpoint r: getBreakpointManager().getRegions())", "+          if (r.getFile().equals( f )) expiredBreakpoints.add( r );", "+        f.setSavedModDate (f.lastModified());", "+      }", "+    // Remove bookmarks and breakpoints for files that were modified outside of DrJava", "+    for (DocumentRegion r: expiredBookmarks) getBookmarkManager().removeRegion( r );", "+    for (Breakpoint r: expiredBreakpoints) getBreakpointManager().removeRegion( r );", "+    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d78ab4823efd2d5fcfea66ff75c5a118", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 354, "methodNumberAfterChange": 309, "signatureBeforeChange": "       public Predicate<DJClass> value(final Boolean includePrivate)", "signatureAfterChange": "   private static <I extends FunctionInvocation, T extends FunctionInvocationCandidate<I>>       Iterable<T> bestMatches(Iterable<T> candidates)", "diff": ["+   */", "+  private static <I extends FunctionInvocation, T extends FunctionInvocationCandidate<I>>", "+      Iterable<T> bestMatches(Iterable<T> candidates) {", "+    // This would be a static member of FunctionInvocationCandidate if that were legal;", "+    // it accesses the _matcher field as if it were.", "+    List<T> matches = new LinkedList<T>();", "+    for (T c : candidates) {", "+      if (c._matcher.matches()) { matches.add(c); }", "+    }", "+    if (matches.isEmpty()) {", "+      for (T c : candidates) {", "+        if (c._matcher.matchesWithBoxing()) { matches.add(c); }", "+      }", "+    }", "+    if (matches.isEmpty()) {", "+      for (T c : candidates) {", "+        if (c._matcher.matchesWithVarargs()) { matches.add(c); }", "+      }", "+    }", "+    return CollectUtil.minList(matches, new Order<T>() {", "+      public boolean contains(T c1, T c2) {", "+        return c1.moreSpecificThan(c2);", "+      }", "+    });", "+  }", "-    Lambda<Boolean, Predicate<DJClass>> makePred = new Lambda<Boolean, Predicate<DJClass>>() {", "-      public Predicate<DJClass> value(final Boolean includePrivate) {", "-        return new Predicate<DJClass>() {", "-          public boolean contains(DJClass c) {", "-            if (c.declaredName().equals(name)) {", "-              return includePrivate || !c.accessibility().equals(Access.PRIVATE);", "-            }", "-            else { return false; }", "-          }", "-        };", "-      }"]}], "num": 24551}