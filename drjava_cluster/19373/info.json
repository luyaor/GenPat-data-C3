{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "558bf1254e5f407b404ddb729c102a1e", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "307b9bbc239b4658e879140f27a0f3f0", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "24e790b85d3a1a29de15955ca1ba9200a6865f83", "commitAfterChange": "4ceb386773fd5eb837ddcd34820c563b6c3c20cb", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 65, "signatureBeforeChange": "   private void  javadoc_1_3(String[] args) throws IOException, JavadocException", "signatureAfterChange": "   private boolean javadoc_1_3(String[] args)        throws IOException, ClassNotFoundException, InterruptedException", "diff": ["-  private void  javadoc_1_3(String[] args) throws IOException, JavadocException {", "-    final String JAVADOC_CLASS = \"com.sun.tools.javadoc.Main\" ;", "-    Process javadocProcess = null;", "-    boolean failed = true;", "-    try {", "-      Class.forName(JAVADOC_CLASS);", "-      javadocProcess =  ExecJVM.runJVMPropogateClassPath(JAVADOC_CLASS, args);", "-      failed = false;", "-    }", "-    catch (ClassNotFoundException cnfe) {", "-    }", "-    catch (UnsupportedClassVersionError ucve) {", "-    }", "+  private boolean javadoc_1_3(String[] args) ", "+      throws IOException, ClassNotFoundException, InterruptedException {", "+    final String JAVADOC_CLASS = \"com.sun.tools.javadoc.Main\";", "+    Process javadocProcess;", "+    BufferedReader jdOut;", "+    BufferedReader jdErr;", "-    if (failed) {", "-      //If we get here, we will just have to try using the javadoc program", "-      //which is hopefully on the system path", "-      String[] fullArgs = new String[args.length + 1];", "-      fullArgs[0] = \"javadoc\";", "-      for(int a = 0; a < args.length; a++) {", "-        fullArgs[a + 1] = args[a];", "-      }", "-      javadocProcess =  Runtime.getRuntime().exec(fullArgs);", "-      //TODO: try/catch the previous line and prompt for javadoc's location", "-      //on failure....and even keep the location in the drjava config", "-    }", "+    Class.forName(JAVADOC_CLASS);", "+    javadocProcess =  ExecJVM.runJVMPropogateClassPath(JAVADOC_CLASS, args);", "-    //Get a handle on the streams that the process produces", "-    BufferedReader jdOut =", "-      new BufferedReader(new InputStreamReader(javadocProcess.getInputStream()));", "-    BufferedReader jdErr =", "-      new BufferedReader(new InputStreamReader (javadocProcess.getErrorStream()));", "+    System.err.println(\"javadoc started with args:\\n\" + Arrays.asList(args));", "+    // getInputStream actually gives us the stdout from the Process.", "+    jdOut = new BufferedReader(new InputStreamReader(javadocProcess.getInputStream()));", "+    jdErr = new BufferedReader(new InputStreamReader(javadocProcess.getErrorStream()));", "+    String sourceName = \"ExecJVM\";", "+    int value = -1;", "+    /* waitFor() call appears to block indefinitely in 1.4.1, because", "+     * the process will block if output buffers get full.", "+     * Yes, this is extremely retarded.", "+     */ ", "+//     value = javadocProcess.waitFor();", "+    ", "+    // We have to use a busy-wait and vent output buffers.", "+    LinkedList outLines = new LinkedList();", "+    LinkedList errLines = new LinkedList();", "+    String output;", "-    ", "-    //Loop until javadoc is done, putting its output on the console", "-      String output = jdOut.readLine();", "-      while (output != null){", "-        System.out.println(\"[javadoc] \" + output);", "-        output = jdOut.readLine();", "-      }", "-      ", "-      do {", "-        System.err.println(\"[javadoc] \" + output);", "-        output = jdErr.readLine();", "-      } while(output!= null);", "-", "-        int value = javadocProcess.exitValue();", "+        value = javadocProcess.exitValue();", "-        System.out.println(\"Javadoc finished with exit code \" + value);", "-        if (value != 0) {", "-          throw new JavadocException(\"Javadoc error:  finished with exit code \" + value);", "+      }", "+      catch (IllegalThreadStateException e) {", "+//          printProcessOutput(javadocProcess, \"debug!\", \"ExecJVM\");", "+        ventBuffers(jdOut, jdErr, outLines, errLines);", "+      }", "+    }", "+    ventBuffers(jdOut, jdErr, outLines, errLines);", "+    System.err.println(\"got past first waitFor.\");", "+     ", "+    // Unfortunately, javadoc returns 1 for normal errors and for exceptions.", "+    // We cannot tell them apart without parsing.", "+    ", "+    ", "+//     if (value != 0) {", "+//       // If we get here, we will just have to try using the javadoc program", "+//       // which is hopefully on the system path", "+//       if (CodeStatus.DEVELOPMENT) {", "+//         String msg = (\"Launching Javadoc with ExecJVM failed.  Messages:\");", "+//         printProcessOutput(javadocProcess, msg, \"ExecJVM\");", "+//         ", "+//         System.err.println(\"Attempting to launch Javadoc from command path.\");", "+//       }", "+//       ", "+//       String[] fullArgs = new String[args.length + 1];", "+//       fullArgs[0] = \"javadoc\";", "+//       //TODO: Use System.arraycopy() here.", "+//       for(int a = 0; a < args.length; a++) {", "+//         fullArgs[a + 1] = args[a];", "+//       }", "+//       javadocProcess =  Runtime.getRuntime().exec(fullArgs);", "+//       ", "+//       // TODO: try/catch the previous line and prompt for javadoc's location", "+//       // on failure....and even keep the location in the drjava config", "+//       // DON'T USE waitFor! (See above.)", "+// //       value = javadocProcess.waitFor();", "+//       ", "+//       if (value != 0) {", "+//         if (CodeStatus.DEVELOPMENT) {", "+//           String msg = (\"Launching Javadoc with Runtime.Exec failed.  Messages:\");", "+//           printProcessOutput(javadocProcess, msg, \"Runtime.Exec\");", "+//         }", "+//         ", "+//         // Handle the error condition at the caller!", "+//         CompilerError err = new CompilerError((\"finished with exit code \" + value), false);", "+//         _javadocErrorModel = new CompilerErrorModel(new CompilerError[] { err }, this);", "+//       }", "+//       // else we have a valid javadocProcess from Runtime.Exec - fall through.", "+//     }", "+//     // else or fall-through means we have a valid javadocProcess from ExecJVM or Runtime.Exec", "+    ", "+    ", "+    ArrayList errors = new ArrayList(0);", "+    ", "+    // We already know javadoc is done => process its error messages", "+//     String output;", "+    ", "+//     jdOut = new BufferedReader(new InputStreamReader(javadocProcess.getInputStream()));", "+//     jdErr = new BufferedReader(new InputStreamReader(javadocProcess.getErrorStream()));", "+    ", "+    // Ignore all of javadoc's inane jabber to stdout.", "+    // Maybe dump this to console while debugging?", "+//     output = jdOut.readLine();", "+//     System.out.println(\"[Javadoc stdout] \" + output);", "+//     while (output != null) {", "+//       System.out.println(\"[Javadoc stdout] \" + output);", "+//       output = jdOut.readLine();", "+//     }", "+    ", "+    // By this point, the Javadoc process is dead, so we can't block on reads.", "+//     output = jdErr.readLine();", "+//     while (output != null) {", "+//       final String EXCEPTION_INDICATOR = \"Exception: \";", "+// //         System.out.println(\"[javadoc raw error] \" + output);", "+//       ", "+//       int errStart;", "+//       // Check for the telltale signs of a thrown exception.", "+//       errStart = output.indexOf(EXCEPTION_INDICATOR);", "+//       if (errStart != -1) {", "+//         // If we found one, put the entirety of stderr in one CompilerError.", "+//         StringBuffer buf = new StringBuffer(2000);", "+//         do {", "+//           buf.append(output);", "+//           output = jdErr.readLine();", "+//         } while (output != null);", "+//         errors.add(new CompilerError(buf.toString(), false));", "+//       }", "+//       else {", "+//         CompilerError error = parseJavadocErrorLine(output);", "+//         if (error != null) {", "+//           errors.add(error);", "+// //           System.err.println(\"[javadoc err]\" + error);", "+//         }", "+//       }", "+//       output = jdErr.readLine();", "+//     }", "+    ", "+    final String EXCEPTION_INDICATOR = \"Exception: \";", "+    while (errLines.size() > 0) {", "+//         System.out.println(\"[javadoc raw error] \" + output);", "+      ", "+      output = (String) errLines.removeFirst();", "+      ", "+      int errStart;", "+      // Check for the telltale signs of a thrown exception.", "+      errStart = output.indexOf(EXCEPTION_INDICATOR);", "+      if (errStart != -1) {", "+        // If we found one, put the entirety of stderr in one CompilerError.", "+        StringBuffer buf = new StringBuffer(60 * errLines.size());", "+        do {", "+          buf.append(output);", "+          output = (String) errLines.removeFirst();", "+        } while (errLines.size() > 0);", "+        errors.add(new CompilerError(buf.toString(), false));", "+      }", "+      else {", "+        // Otherwise, parser for a normal error message.", "+        CompilerError error = parseJavadocErrorLine(output);", "+        if (error != null) {", "+          errors.add(error);", "+//           System.err.println(\"[javadoc err]\" + error);", "-      catch (IllegalThreadStateException itse) {", "-        done = false;", "-      }", "+    }", "+  ", "+    _javadocErrorModel = new CompilerErrorModel((CompilerError[])(errors.toArray(new CompilerError[0])), this);", "+    System.out.println(\"built javadoc error model\");", "+    return (errors.size() == 0);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "df9b9b74978290a8a153b86dba75ab83", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "a6b0a623369310bca609596a45d42dfc11ddae97", "commitAfterChange": "f0c06f4ecb55d3ad2147a0571c9f9cb7a469ab29", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": "   private boolean javadoc_1_3(String[] args)        throws IOException, ClassNotFoundException, InterruptedException", "signatureAfterChange": "   private boolean javadoc_1_3(String[] args)        throws IOException, ClassNotFoundException, InterruptedException", "diff": ["-    System.err.println(\"javadoc started with args:\\n\" + Arrays.asList(args));", "+//    System.err.println(\"javadoc started with args:\\n\" + Arrays.asList(args));", "-    System.err.println(\"got past first waitFor.\");", "+//    System.err.println(\"got past first waitFor.\");", "-    ", "-    ", "-//     if (value != 0) {", "-//       // If we get here, we will just have to try using the javadoc program", "-//       // which is hopefully on the system path", "-//       if (CodeStatus.DEVELOPMENT) {", "-//         String msg = (\"Launching Javadoc with ExecJVM failed.  Messages:\");", "-//         printProcessOutput(javadocProcess, msg, \"ExecJVM\");", "-//         ", "-//         System.err.println(\"Attempting to launch Javadoc from command path.\");", "-//       }", "-//       ", "-//       String[] fullArgs = new String[args.length + 1];", "-//       fullArgs[0] = \"javadoc\";", "-//       //TODO: Use System.arraycopy() here.", "-//       for(int a = 0; a < args.length; a++) {", "-//         fullArgs[a + 1] = args[a];", "-//       }", "-//       javadocProcess =  Runtime.getRuntime().exec(fullArgs);", "-//       ", "-//       // TODO: try/catch the previous line and prompt for javadoc's location", "-//       // on failure....and even keep the location in the drjava config", "-//       // DON'T USE waitFor! (See above.)", "-// //       value = javadocProcess.waitFor();", "-//       ", "-//       if (value != 0) {", "-//         if (CodeStatus.DEVELOPMENT) {", "-//           String msg = (\"Launching Javadoc with Runtime.Exec failed.  Messages:\");", "-//           printProcessOutput(javadocProcess, msg, \"Runtime.Exec\");", "-//         }", "-//         ", "-//         // Handle the error condition at the caller!", "-//         CompilerError err = new CompilerError((\"finished with exit code \" + value), false);", "-//         _javadocErrorModel = new CompilerErrorModel(new CompilerError[] { err }, this);", "-//       }", "-//       // else we have a valid javadocProcess from Runtime.Exec - fall through.", "-//     }", "-//     // else or fall-through means we have a valid javadocProcess from ExecJVM or Runtime.Exec", "-    ", "-    ", "-    ArrayList errors = new ArrayList(0);", "-    ", "-    // We already know javadoc is done => process its error messages", "-//     String output;", "-    ", "-//     jdOut = new BufferedReader(new InputStreamReader(javadocProcess.getInputStream()));", "-//     jdErr = new BufferedReader(new InputStreamReader(javadocProcess.getErrorStream()));", "-    ", "-    // Ignore all of javadoc's inane jabber to stdout.", "-    // Maybe dump this to console while debugging?", "-//     output = jdOut.readLine();", "-//     System.out.println(\"[Javadoc stdout] \" + output);", "-//     while (output != null) {", "-//       System.out.println(\"[Javadoc stdout] \" + output);", "-//       output = jdOut.readLine();", "-//     }", "-    ", "-    // By this point, the Javadoc process is dead, so we can't block on reads.", "-//     output = jdErr.readLine();", "-//     while (output != null) {", "-//       final String EXCEPTION_INDICATOR = \"Exception: \";", "-// //         System.out.println(\"[javadoc raw error] \" + output);", "-//       ", "-//       int errStart;", "-//       // Check for the telltale signs of a thrown exception.", "-//       errStart = output.indexOf(EXCEPTION_INDICATOR);", "-//       if (errStart != -1) {", "-//         // If we found one, put the entirety of stderr in one CompilerError.", "-//         StringBuffer buf = new StringBuffer(2000);", "-//         do {", "-//           buf.append(output);", "-//           output = jdErr.readLine();", "-//         } while (output != null);", "-//         errors.add(new CompilerError(buf.toString(), false));", "-//       }", "-//       else {", "-//         CompilerError error = parseJavadocErrorLine(output);", "-//         if (error != null) {", "-//           errors.add(error);", "-// //           System.err.println(\"[javadoc err]\" + error);", "-//         }", "-//       }", "-//       output = jdErr.readLine();", "-//     }", "-    ", "-    final String EXCEPTION_INDICATOR = \"Exception: \";", "-    while (errLines.size() > 0) {", "-//         System.out.println(\"[javadoc raw error] \" + output);", "-      ", "-      output = (String) errLines.removeFirst();", "-      ", "-      int errStart;", "-      // Check for the telltale signs of a thrown exception.", "-      errStart = output.indexOf(EXCEPTION_INDICATOR);", "-      if (errStart != -1) {", "-        // If we found one, put the entirety of stderr in one CompilerError.", "-        StringBuffer buf = new StringBuffer(60 * errLines.size());", "-        do {", "-          buf.append(output);", "-          output = (String) errLines.removeFirst();", "-        } while (errLines.size() > 0);", "-        errors.add(new CompilerError(buf.toString(), false));", "-      }", "-      else {", "-        // Otherwise, parser for a normal error message.", "-        CompilerError error = parseJavadocErrorLine(output);", "-        if (error != null) {", "-          errors.add(error);", "-//           System.err.println(\"[javadoc err]\" + error);", "-        }", "-      }", "-    }", "+", "+    ArrayList errors = extractErrors(outLines);", "+    errors.addAll(extractErrors(errLines));", "-    System.out.println(\"built javadoc error model\");", "+//    System.out.println(\"built javadoc error model\");"]}], "num": 19373}