{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1740395116f1c70bc0d212896ad29aa8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "14333a2c3a7f2f4956d9d90a31aff672", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/config/ConfigFrame.java", "commitBeforeChange": "9b3324f219a69f8658c0756bfd83fb666ede6986", "commitAfterChange": "23d353b1918dd9a63de161a6fc91f2e819d09fc5", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 40, "signatureBeforeChange": "   private void _setupColorPanel(ConfigPanel panel)", "signatureAfterChange": "   private void _setupColorPanel(ConfigPanel panel)", "diff": ["-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_NORMAL_COLOR, \"Normal Color\", this,", "-                                                \"The default color for text in the Definitions Pane.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_KEYWORD_COLOR, \"Keyword Color\", this,", "-                                                \"The color for Java keywords in the Definitions Pane.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_TYPE_COLOR, \"Type Color\", this,", "-                                                \"The color for classes and types in the Definitions Pane.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_COMMENT_COLOR, \"Comment Color\", this,", "-                                                \"The color for comments in the Definitions Pane.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_DOUBLE_QUOTED_COLOR, \"Double-quoted Color\", this,", "-                                                \"The color for quoted strings (eg. \\\"...\\\") in the Definitions Pane.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_SINGLE_QUOTED_COLOR, \"Single-quoted Color\", this,", "-                                                \"The color for quoted characters (eg. 'a') in the Definitions Pane.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_NUMBER_COLOR, \"Number Color\", this,", "-                                                \"The color for numbers in the Definitions Pane.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_BACKGROUND_COLOR, \"Background Color\", this,", "-                                                \"The background color of the Definitions Pane.\", true));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_LINE_NUMBER_COLOR, \"Line Number Color\", this,", "-                                                \"The color for line numbers in the Definitions Pane.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_LINE_NUMBER_BACKGROUND_COLOR, \"Line Number Background Color\", this,", "-                                                \"The background color for line numbers in the Definitions Pane.\", true));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEFINITIONS_MATCH_COLOR, \"Brace-matching Color\", this,", "-                                                \"The color for matching brace highlights in the Definitions Pane.\", true));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.COMPILER_ERROR_COLOR, \"Compiler Error Color\", this,", "-                                                \"The color for compiler error highlights in the Definitions Pane.\", true));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.BOOKMARK_COLOR, \"Bookmark Color\", this,", "-                                                \"The color for bookmarks in the Definitions Pane.\", true));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_NORMAL_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_KEYWORD_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_TYPE_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_COMMENT_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_DOUBLE_QUOTED_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_SINGLE_QUOTED_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_NUMBER_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_BACKGROUND_COLOR, true));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_LINE_NUMBER_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_LINE_NUMBER_BACKGROUND_COLOR, true));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEFINITIONS_MATCH_COLOR,true));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.COMPILER_ERROR_COLOR, true));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.BOOKMARK_COLOR, true));", "-      addOptionComponent(panel, new ColorOptionComponent(OptionConstants.FIND_RESULTS_COLORS[i], \"Find Results Color \"+(i+1), this,", "-                                                         \"A color for highlighting find results in the Definitions Pane.\", true));", "+      addOptionComponent(panel, newColorOptionComponent(OptionConstants.FIND_RESULTS_COLORS[i], true));", "-                       new ColorOptionComponent(OptionConstants.DEBUG_BREAKPOINT_COLOR, \"Debugger Breakpoint Color\", this,", "-                                                \"The color for breakpoints in the Definitions Pane.\", true));", "+                       newColorOptionComponent(OptionConstants.DEBUG_BREAKPOINT_COLOR, true));", "-                       new ColorOptionComponent(OptionConstants.DEBUG_BREAKPOINT_DISABLED_COLOR, \"Disabled Debugger Breakpoint Color\", this,", "-                                                \"The color for disabled breakpoints in the Definitions Pane.\", true));", "+                       newColorOptionComponent(OptionConstants.DEBUG_BREAKPOINT_DISABLED_COLOR, true));", "-                       new ColorOptionComponent(OptionConstants.DEBUG_THREAD_COLOR, \"Debugger Location Color\", this,", "-                                                \"The color for the location of the current suspended thread in the Definitions Pane.\", true));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.SYSTEM_OUT_COLOR, \"System.out Color\", this,", "-                                                       \"The color for System.out in the Interactions and Console Panes.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.SYSTEM_ERR_COLOR, \"System.err Color\", this,", "-                                                       \"The color for System.err in the Interactions and Console Panes.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.SYSTEM_IN_COLOR, \"System.in Color\", this,", "-                                                       \"The color for System.in in the Interactions Pane.\"));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.INTERACTIONS_ERROR_COLOR, \"Interactions Error Color\", this,", "-                                                       \"The color for interactions errors in the Interactions Pane.\", false, true));", "-    addOptionComponent(panel, new ColorOptionComponent(OptionConstants.DEBUG_MESSAGE_COLOR, \"Debug Message Color\", this,", "-                                                       \"The color for debugger messages in the Interactions Pane.\", false, true));", "+                       newColorOptionComponent(OptionConstants.DEBUG_THREAD_COLOR, true));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.SYSTEM_OUT_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.SYSTEM_ERR_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.SYSTEM_IN_COLOR));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.INTERACTIONS_ERROR_COLOR, false, true));", "+    addOptionComponent(panel, newColorOptionComponent(OptionConstants.DEBUG_MESSAGE_COLOR, false, true));", "-                       new ColorOptionComponent(OptionConstants.DRJAVA_ERRORS_BUTTON_COLOR, \"DrJava Errors Button Background Color\", this,", "-                                                \"The background color of the \\\"Errors\\\" button used to show internal DrJava errors.\", true));", "+                       newColorOptionComponent(OptionConstants.DRJAVA_ERRORS_BUTTON_COLOR, true));", "-                       new ColorOptionComponent(OptionConstants.RIGHT_MARGIN_COLOR, \"Right Margin Color\", this,", "-                                                \"The color of the right margin line, if displayed.\", true));", "+                       newColorOptionComponent(OptionConstants.RIGHT_MARGIN_COLOR, true));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5809fab1e9c71c68257e15eecff76224", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "093f33e43dd3de7d97364f410a0a58ca1448a1ce", "commitAfterChange": "51703b3c111cc35e01e35a5e289226f6da1c1962", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "diff": ["-    OPT = options;", "-    LanguageLevelVisitor.symbolTable = symbolTable = new Symboltable();  // redundant?", "-    LanguageLevelVisitor._newSDs = new Hashtable<SymbolData, LanguageLevelVisitor>(); /**initialize so we don't get null pointer exception*/", "+    _log.log(\"LanguageLevelConverter.convert called on files:  \" + Arrays.toString(files));", "+    OPT = options;", "+    assert symbolTable != null;", "+    symbolTable.clear();", "+    _newSDs.clear();", "+    ", "+    /**initialize so we don't get null pointer exception*/", "-    Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>> continuations = new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>();", "-    ", "-    //and the new SDs (symbol table entries) we've created", "-    Hashtable<SymbolData, LanguageLevelVisitor> languageLevelNewSDs = new Hashtable<SymbolData, LanguageLevelVisitor>();", "+    Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>> continuations = ", "+      new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>();", "-    LinkedList<Pair<LanguageLevelVisitor, SourceFile>> languageLevelVisitedFiles = new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>();", "+    LinkedList<Pair<LanguageLevelVisitor, SourceFile>> languageLevelVisitedFiles =  ", "+      new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>();", "-       SourceFile and LanguageLevelVisitor so we'll keep them around in a Hashtable. */", "-    Hashtable<Integer, Pair<SourceFile, LanguageLevelVisitor>> mediator = new Hashtable<Integer, Pair<SourceFile, LanguageLevelVisitor>>();", "+     SourceFile and LanguageLevelVisitor so we'll keep them around in a Hashtable. */", "+    Hashtable<Integer, Pair<SourceFile, LanguageLevelVisitor>> mediator = ", "+      new Hashtable<Integer, Pair<SourceFile, LanguageLevelVisitor>>();", "-       In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "-       already been done.  (An error is thrown if we do since it thinks the class has already been defined). */", "+     In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "+     already been done.  (An error is thrown if we do since it thinks the class has already been defined). */", "-       We don't want to visit these newly referenced files because they've already", "-       been visited. */", "+     We don't want to visit these newly referenced files because they've already", "+     been visited. */", "-    /* Find the ones (of what?) that are LL files.", "-       Do the passes first for ALL files before proceeding to code augmentation.", "-       Otherwise if one class' superclass get augmented first, then it sees a lot", "-       of illegal constructs (e.g. public and constructors). */", "+    /* Find the files in the File[] array files that are LL files. Do the parsing, conformance checking, and ", "+     * type-checking passes first for ALL files before proceeding to code augmentation.  Otherwise if one class's", "+     * superclass get augmented first, then it sees a lot of illegal constructs (e.g. public and constructors). */", "-    /* will maintain the files we visit along with their visitors (for type checking step). */", "-    LinkedList<Pair<LanguageLevelVisitor, SourceFile>> visited = new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>();", "+    /* Maintains the files we visit along with their visitors (for type checking step). */", "+    LinkedList<Pair<LanguageLevelVisitor, SourceFile>> visited = ", "+      new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>();", "+    ", "+    /* Maintains the list of advanced files, which are no longer parsed and checked; they are simply converted to .java", "+     * files unchanged and unchecked (except for nullity). */", "+    LinkedList<File> advanced = new LinkedList<File>();", "-        if (filesNotToCheck.contains(f)) continue;  // Detects equal files; earlier code versions claimed it failed", "+        if (filesNotToCheck.contains(f)) continue;  // Detects equal Files objects", "+        ", "-        if (_isLanguageLevelFile(f)) {", "+        if (isAdvancedFile(f)) advanced.addLast(f);", "+        ", "+        else if (_isLanguageLevelFile(f)) {  /* a .dj0 or .dj1 file */  // WARNING: no support for .dj files here", "+            _log.log(\"Parsing \" + f);", "-          LanguageLevelVisitor llv = null;", "-          if (isElementaryFile(f)) {", "-            llv = ", "-              new ElementaryVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(), symbolTable, ", "-                                    new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "-                                    languageLevelVisitedFiles, languageLevelNewSDs);", "-          }", "-          else if (isIntermediateFile(f)) {", "-            llv = ", "-              new IntermediateVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(), symbolTable,", "-                                      new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "-                                      languageLevelVisitedFiles, languageLevelNewSDs);", "-          }", "-          else if (isAdvancedFile(f)) {", "-            llv = ", "-              new AdvancedVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(), symbolTable, ", "-                                  new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "-                                  languageLevelVisitedFiles, languageLevelNewSDs);", "-          }", "-          else {", "-            throw new RuntimeException(\"Internal Bug: Invalid file format not caught initially.  Please report this bug.\");", "-          }", "+          LanguageLevelVisitor llv = new IntermediateVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(),", "+                                                             new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), ", "+                                                             languageLevelVisitedFiles);", "- ", "+    ", "+          System.err.println(\"Could not find SymbolData for '\" + className + \"'\");", "-     ", "+    ", "-", "+    ", "-    Hashtable<SymbolData, LanguageLevelVisitor> newSDs = LanguageLevelVisitor._newSDs;", "-    Enumeration<SymbolData> keys = newSDs.keys();", "+    Enumeration<SymbolData> keys = _newSDs.keys();", "-      LanguageLevelVisitor sdlv = newSDs.get(key);    // Can return null because of silly side effects!", "+      LanguageLevelVisitor sdlv = _newSDs.get(key);   // Can return null because of silly side effects!", "-    assert LanguageLevelVisitor._newSDs.isEmpty();", "+    ", "+//    assert _newSDs.isEmpty();", "+        ", "+        // Note: \"llv.\" formerly preceded symbolTable and getSymbolData", "-        if (llv.symbolTable.get(\"java.lang.Integer\") == null) {llv.getSymbolData(\"java.lang.Integer\", SourceInfo.NO_INFO);}", "-        if (llv.symbolTable.get(\"java.lang.Double\")==null) {llv.getSymbolData(\"java.lang.Double\", SourceInfo.NO_INFO);}", "-        if (llv.symbolTable.get(\"java.lang.Character\")==null) {llv.getSymbolData(\"java.lang.Character\", SourceInfo.NO_INFO);}", "-        if (llv.symbolTable.get(\"java.lang.Boolean\")==null) {llv.getSymbolData(\"java.lang.Boolean\", SourceInfo.NO_INFO);}", "-        if (llv.symbolTable.get(\"java.lang.Long\")==null) {llv.getSymbolData(\"java.lang.Long\", SourceInfo.NO_INFO);}", "-        if (llv.symbolTable.get(\"java.lang.Byte\")==null) {llv.getSymbolData(\"java.lang.Byte\", SourceInfo.NO_INFO);}", "-        if (llv.symbolTable.get(\"java.lang.Short\")==null) {llv.getSymbolData(\"java.lang.Short\", SourceInfo.NO_INFO);}", "-        if (llv.symbolTable.get(\"java.lang.Float\")==null) {llv.getSymbolData(\"java.lang.Float\", SourceInfo.NO_INFO);}", "+        if (symbolTable.get(\"java.lang.Integer\") == null)   { llv.getSymbolData(\"java.lang.Integer\", SourceInfo.NO_INFO);}", "+        if (symbolTable.get(\"java.lang.Double\") == null)    { llv.getSymbolData(\"java.lang.Double\", SourceInfo.NO_INFO);}", "+        if (symbolTable.get(\"java.lang.Character\") == null) { llv.getSymbolData(\"java.lang.Character\", SourceInfo.NO_INFO);}", "+        if (symbolTable.get(\"java.lang.Boolean\") == null)   { llv.getSymbolData(\"java.lang.Boolean\", SourceInfo.NO_INFO);}", "+        if (symbolTable.get(\"java.lang.Long\") == null)      { llv.getSymbolData(\"java.lang.Long\", SourceInfo.NO_INFO);}", "+        if (symbolTable.get(\"java.lang.Byte\") == null)      { llv.getSymbolData(\"java.lang.Byte\", SourceInfo.NO_INFO);}", "+        if (symbolTable.get(\"java.lang.Short\") == null)     { llv.getSymbolData(\"java.lang.Short\", SourceInfo.NO_INFO);}", "+        if (symbolTable.get(\"java.lang.Float\") == null)     { llv.getSymbolData(\"java.lang.Float\", SourceInfo.NO_INFO);}", "-        TypeChecker btc = new TypeChecker(llv._file, llv._package, llv.errors, symbolTable, llv._importedFiles, llv._importedPackages);", "+        TypeChecker btc = ", "+          new TypeChecker(llv._file, llv._package, llv.errors, symbolTable, llv._importedFiles, llv._importedPackages);", "+        System.err.println(\"Visiting source file \" + sf.getSourceInfo ());", "-      // Set up code augmentation.  We will NOT try to augment files unless they appear in the visited List.  Unlisted LL files cannot be found", "-      // reliably during type checking because there is no naming convention that tells the type checker what files to look for.", "+      /* Set up code augmentation.  We will NOT try to augment files unless they appear in the visited List.  Unlisted", "+       * LL files cannot be found reliably during type checking because there is no naming convention that tells the ", "+       * type checker what files to look for. */", "-      files = newFiles.toArray(new File[newFiles.size()]);", "+      ", "+      newFiles.addAll(advanced);", "+      files = newFiles.toArray(new File[newFiles.size()]);  // include advanced files", "-    ", "-    //If there were any errors in the llv pass or the type checking pass, just return them.", "+    // If there were any errors in the llv pass or the type checking pass, just return them.", "-//        Utilities.show(\"File is: \" + f + \" mediator is: \" + mediator.get(ind));", "-        BufferedReader tempBr = new BufferedReader(new FileReader(f));", "-        String firstLine = tempBr.readLine();", "-        tempBr.close(); // Important to close the reader, otherwise Windows will not allow the renameTo call later.", "-        if (firstLine == null) continue;", "-        // If the file has an appropriate LL extension, then parse it.", "-        if (_isLanguageLevelFile(f)) {", "-          Pair<SourceFile, LanguageLevelVisitor> pair = mediator.get(new Integer(ind));", "-          if (pair == null) {", "-     // _log.log(\"Not augmenting \" + f + \" no mediator\");", "-//            Utilities.show(\"Not augmenting \" + f + \" no mediator\");", "-          }", "+        // Set up augmented file  WARNING: DOES NOT WORK FOR .DJ EXTENSION", "+        String augmentedFilePath = f.getAbsolutePath();", "+        augmentedFilePath = augmentedFilePath.substring(0, augmentedFilePath.length() - 4); //remove the .dj# extension", "+        ", "+        File augmentedFile = new File(augmentedFilePath + \".java\"); //replace it with .java", "+        ", "+        if (isAdvancedFile(f)) {", "+          Utilities.copyFile(f, augmentedFile);", "+        }", "+        else {", "+//        Utilities.show(\"File is: \" + f + \" mediator is: \" + mediator.get(ind));", "+          BufferedReader tempBr = new BufferedReader(new FileReader(f));", "+          String firstLine = tempBr.readLine();", "+          tempBr.close(); // Important to close the reader, otherwise Windows will not allow the renameTo call later.", "+          if (firstLine == null) continue;", "-          if (pair != null) { //if pair is null, we do not actually need to augment this file--it wasn't visited.  Maybe we used the class file?", "-            SourceFile sf = pair.getFirst();", "-            LanguageLevelVisitor llv = pair.getSecond();", "-//            File f = files[ind];", "-            ", "-            // Do code augmentation.  This will involve a line-by-line copy, editing lines as appropriate.", "-            String augmentedFilePath = f.getAbsolutePath();", "-            augmentedFilePath = augmentedFilePath.substring(0, augmentedFilePath.length() - 4); //remove the .dj# extension", "-            File augmentedFile = new File(augmentedFilePath + \".java\"); //replace it with .java", "-            BufferedReader br = new BufferedReader(new FileReader(f), INPUT_BUFFER_SIZE);", "-            StringWriter sw = new StringWriter();", "-            BufferedWriter bw = new BufferedWriter(sw);", "-            ", "-            // _log.log(\"Augmenting the source file \" + sf);", "-//            Utilities.show(\"Augmenting the source file \" + sf.getSourceInfo().getFile());", "-            Augmentor a = new Augmentor(SAFE_SUPPORT_CODE, br, bw, llv);", "-            sf.visit(a);", "-            ", "-            br.close();", "-            bw.close();", "-            ", "-            // write out the line number map and the augmented java file", "-            PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(augmentedFile)));", "-            SortedMap<Integer,Integer> lineNumberMap = a.getLineNumberMap();", "-            pw.println(\"// Language Level Converter line number map: dj*->java. Entries: \"+lineNumberMap.size());", "-            // We print out LINE_NUM_MAPPINGS_PER_LINE mappings per line, so we need numLines", "-            // at the top of the file, and one more for a descriptive comment.", "-            // That means we need to increase the line numbers in the generated java file by numLines+1", "-            int numLines = (int)Math.ceil(((double)lineNumberMap.size())/LINE_NUM_MAPPINGS_PER_LINE);", "-            int mapCount = 0;", "-            for(Map.Entry<Integer,Integer> e: lineNumberMap.entrySet()) {", "-              // e.getKey(): dj* line number; e.getValue(): java line number (must be increased by numLines)", "-              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==0) pw.print(\"//\");", "-              pw.printf(\" %5d->%-5d\", e.getKey(), (e.getValue()+numLines+1));", "-              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==LINE_NUM_MAPPINGS_PER_LINE-1) pw.println();", "-              ++mapCount;", "+          // If the file has an appropriate LL extension, then parse it.", "+          if (_isLanguageLevelFile(f)) {", "+            Pair<SourceFile, LanguageLevelVisitor> pair = mediator.get(new Integer(ind));", "+            if (pair == null) {", "+              // _log.log(\"Not augmenting \" + f + \" no mediator\");", "+//            Utilities.show(\"Not augmenting \" + f + \" no mediator\");", "-            if (mapCount%LINE_NUM_MAPPINGS_PER_LINE!=0) pw.println(); // print a newline unless we just printed one", "-            String augmented = sw.toString();", "-            pw.write(augmented, 0, augmented.length());", "-            pw.close();", "+            if (pair != null) { //if pair is null, we do not actually need to augment this file--it wasn't visited.  Maybe we used the class file?", "+              SourceFile sf = pair.getFirst();", "+              LanguageLevelVisitor llv = pair.getSecond();", "+//            File f = files[ind];", "+              ", "+              // Do code augmentation", "+              BufferedReader br = new BufferedReader(new FileReader(f), INPUT_BUFFER_SIZE);", "+              StringWriter sw = new StringWriter();", "+              BufferedWriter bw = new BufferedWriter(sw);", "+              ", "+              // _log.log(\"Augmenting the source file \" + sf);", "+//            Utilities.show(\"Augmenting the source file \" + sf.getSourceInfo().getFile());", "+              Augmentor a = new Augmentor(SAFE_SUPPORT_CODE, br, bw, llv);", "+              sf.visit(a);", "+              ", "+              br.close();", "+              bw.close();", "+              ", "+              // write out the line number map and the augmented java file", "+              PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(augmentedFile)));", "+              SortedMap<Integer,Integer> lineNumberMap = a.getLineNumberMap();", "+              pw.println(\"// Language Level Converter line number map: dj*->java. Entries: \"+lineNumberMap.size());", "+              // We print out LINE_NUM_MAPPINGS_PER_LINE mappings per line, so we need numLines", "+              // at the top of the file, and one more for a descriptive comment.", "+              // That means we need to increase the line numbers in the generated java file by numLines+1", "+              int numLines = (int)Math.ceil(((double)lineNumberMap.size())/LINE_NUM_MAPPINGS_PER_LINE);", "+              int mapCount = 0;", "+              for(Map.Entry<Integer,Integer> e: lineNumberMap.entrySet()) {", "+                // e.getKey(): dj* line number; e.getValue(): java line number (must be increased by numLines)", "+                if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==0) pw.print(\"//\");", "+                pw.printf(\" %5d->%-5d\", e.getKey(), (e.getValue()+numLines+1));", "+                if (mapCount%LINE_NUM_MAPPINGS_PER_LINE==LINE_NUM_MAPPINGS_PER_LINE-1) pw.println();", "+                ++mapCount;", "+              }", "+              if (mapCount%LINE_NUM_MAPPINGS_PER_LINE!=0) pw.println(); // print a newline unless we just printed one", "+              ", "+              String augmented = sw.toString();", "+              pw.write(augmented, 0, augmented.length());", "+              pw.close();", "+            }"]}], "num": 15182}