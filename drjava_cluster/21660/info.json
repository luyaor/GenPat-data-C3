{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "511ce22d5e47da3a7ae4cefeb91689f6", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3e70b23c304442e19358fd0ee7af9e37", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "dd97c2983de18f5d46f596ce3c536a3b581f0ec4", "commitAfterChange": "e5b59097570657040bcd74f7a31c6db7f03359ce", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": "   public TypeData forSimpleNameReference(SimpleNameReference that)", "signatureAfterChange": "   public TypeData forSimpleNameReference(SimpleNameReference that)", "diff": ["-    //first, try to resolve this name as a field or variable reference", "+    // first, try to resolve this name as a field or variable reference", "-      if (!reference.hasValue()) {", "+      if (! reference.hasValue()) {", "-      //if reference is non-static, but context is static, give error", "-      if (!reference.hasModifier(\"static\") && inStaticMethod()) {", "-        _addError(\"Non static field or variable \" + reference.getName() + \" cannot be referenced from a static context\", that);", "+      // if reference is non-static (and not a local variable), but context is static, give error", "+      if (inStaticMethod() && ! reference.hasModifier(\"static\")  && ! reference.isLocalVariable()) {", "+        _addError(\"Non-static variable or field \" + reference.getName() + \" cannot be referenced from a static context\", that);", "-      return reference.getType().getInstanceData();", "-        ", "+      return reference.getType().getInstanceData();  ", "-      ", "+    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1cf4b55b67d936300a3df85e3d6d44f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyIntermediateVisitor.java", "commitBeforeChange": "d63224548fc8865b0ab459659b530c0d39d21fc7", "commitAfterChange": "d8eee91536a378507eadfac2f106d06ff2703bff", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "   public Void forAbstractMethodDefDoFirst(AbstractMethodDef that)", "signatureAfterChange": "   public Void forAbstractMethodDefDoFirst(AbstractMethodDef that)", "diff": ["-  /* Make sure that this abstract method def is declared to be abstract*/", "+  /** Ignore AbstractMake sure that this abstract method def is declared to be abstract. */", "-    if (! _classData.hasModifier(\"abstract\")) {", "-      _addError(\"Abstract methods can only be declared in abstract classes\", that);", "-    }", "+", "-//    // Concrete methods can now be public, private, protected at the Intermediate level.  They still cannot be static.", "-//    for (int i = 0; i < modifiers.length; i++) {", "-//      if (modifiers[i].equals(\"static\")) {", "-//        _addError(\"Static methods cannot be used at the Intermediate level\", that);", "-//        break;", "-//      }", "-//    }", "+    if (! _classData.isInterface() && ! _classData.hasModifier(\"abstract\")) { // interfaces not yet marked abstract", "+      _addError(\"Abstract methods can only be declared in abstract classes\", that);", "+    }"]}], "num": 21660}