{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e25a0649a36bbc071e2031af2da48c6b", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5084475fe91107b25cfe9c671f05ca0f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/ConcreteRegionManager.java", "commitBeforeChange": "50372cdcb0e3a8db5661a31f5825b5dc9f07a9e9", "commitAfterChange": "3049ab1c03c6212f738bc13f7b01e843f39da3a7", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "   public R getRegionAt(OpenDefinitionsDocument odd, int offset)", "signatureAfterChange": "   public R getRegionAt(OpenDefinitionsDocument odd, int offset)", "diff": ["-    /* If tail contains a match, it must be the first non-degenerate region, since all regions in a document are ", "-     * disjoint. (Every degenerate region is disjoint from every other region because it is empty.) tail is sorted by ", "-     * [endOffset, startOffset]; tail may be empty.  We use a loop because the number of degenerate regions is ", "-     * unbounded. */", "+    /* If tail contains a match, it must be the first region, since all regions in a document are disjoint and no", "+     * degenerate region in tail can contain offset. (Every degenerate region is disjoint from every other region ", "+     * because it is empty.) tail is sorted by [endOffset, startOffset]; tail may be empty. */", "-    for (R r: tail) {", "-      int start = r.getStartOffset();", "-      int end = r.getEndOffset();", "-      if (start == end) continue;", "-      if (start <= offset) return r;", "-      else break;", "-    }", "-    return null;", "+    if (tail.size() == 0) return null;", "+    R r = tail.first();", "+    int start = r.getStartOffset();", "+    int end = r.getEndOffset();", "+    ", "+    if (start <= offset) return r;", "+    else return null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1281517541c71a84b18122d1f82101d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/ConcreteRegionManager.java", "commitBeforeChange": "1ff154e9eb4de7b8f07ce9a8120997b76e53aa3f", "commitAfterChange": "50372cdcb0e3a8db5661a31f5825b5dc9f07a9e9", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 5, "signatureBeforeChange": "   public R getRegionAt(OpenDefinitionsDocument odd, int offset)", "signatureAfterChange": "   public R getRegionAt(OpenDefinitionsDocument odd, int offset)", "diff": ["+    */", "+  public R getRegionAt(OpenDefinitionsDocument odd, int offset) { ", "+//    assert EventQueue.isDispatchThread();", "+    ", "+    /* Get the tailSet consisting of the ordered set of regions [start, end) such that end > offset. */", "+    @SuppressWarnings(\"unchecked\")", "+    SortedSet<R> tail = getTailSet((R) newDocumentRegion(odd, 0, offset + 1));", "+    ", "+    /* If tail contains a match, it must be the first non-degenerate region, since all regions in a document are ", "+     * disjoint. (Every degenerate region is disjoint from every other region because it is empty.) tail is sorted by ", "+     * [endOffset, startOffset]; tail may be empty.  We use a loop because the number of degenerate regions is ", "+     * unbounded. */", "+", "+    for (R r: tail) {", "+      int start = r.getStartOffset();", "+      int end = r.getEndOffset();", "+      if (start == end) continue;", "+      if (start <= offset) return r;", "+      else break;", "+    }", "+    return null;", "-    */", "-  public R getRegionAt(OpenDefinitionsDocument odd, int offset) { return getRegionContaining(odd, offset, offset); }"]}], "num": 673}