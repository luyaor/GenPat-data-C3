{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "30635660daff60f445056db8ceb62074", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5835814b62c0374e5c77135be3708ba", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocument.java", "commitBeforeChange": "69d4590eff40914052a36cc82d8a74c43211028e", "commitAfterChange": "46bddad84804814dd0241cc4f939b2c8bb524e79", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 40, "signatureBeforeChange": "   public synchronized void gotoLine(int line)", "signatureAfterChange": "   public void gotoLine(int line)", "diff": ["-  public synchronized void gotoLine(int line) {", "-    throwErrorHuh();", "+  public void gotoLine(int line) {", "+    // throwErrorHuh();", "-    if (line < 0) {", "-     return;", "-    }", "+    if (line < 0) return;", "-    setCurrentLocation(0);", "-    for (int i = 1; (i < line) && (_currentLocation < getLength()); i++) {", "-      dist = _reduced.getDistToNextNewline();", "-      if (_currentLocation + dist < getLength()) {", "-        dist++;", "+    ", "+    synchronized (_reduced) {", "+      setCurrentLocation(0);", "+      for (int i = 1; (i < line) && (_currentLocation < getLength()); i++) {", "+        dist = _reduced.getDistToNextNewline();", "+        if (_currentLocation + dist < getLength()) {", "+          dist++;", "+        }", "+        actualLine++;", "+        move(dist);", "-      actualLine++;", "-      move(dist);", "+      _cachedLineNum = actualLine;", "+      _cachedLocation = _currentLocation;", "+      _cachedPrevLineLoc = getLineStartPos(_currentLocation);", "+      _cachedNextLineLoc = getLineEndPos(_currentLocation);", "-    _cachedLineNum = actualLine;", "-    _cachedLocation = _currentLocation;", "-    _cachedPrevLineLoc = getLineStartPos(_currentLocation);", "-    _cachedNextLineLoc = getLineEndPos(_currentLocation);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f94b45b7e203b9d56c8259c659fe9fd1", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocument.java", "commitBeforeChange": "69d4590eff40914052a36cc82d8a74c43211028e", "commitAfterChange": "46bddad84804814dd0241cc4f939b2c8bb524e79", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 41, "signatureBeforeChange": "   public synchronized String getPackageName() throws InvalidPackageException", "signatureAfterChange": "   public String getPackageName() throws InvalidPackageException", "diff": ["-  public synchronized String getPackageName() throws InvalidPackageException {", "-    throwErrorHuh();", "+  public String getPackageName() throws InvalidPackageException {", "+    // throwErrorHuh();", "-", "-    int oldLocation = getCurrentLocation();", "-", "-    try {", "-      setCurrentLocation(0);", "-      final int docLength = getLength();", "-      final String text = getText(0, docLength);", "-//      System.out.println(\"oldlocation: \" + oldLocation + \", doclength: \" + docLength + \", text: \\\"\" + text + \"\\\"\");", "-      // The location of the first non-whitespace character that", "-      // is not inside quote or comment.", "-      int firstNormalLocation = 0;", "-      while ((firstNormalLocation < docLength)) {", "-        setCurrentLocation(firstNormalLocation);", "-", "-        if (_reduced.currentToken().getHighlightState() ==", "-            HighlightStatus.NORMAL)", "+    ", "+    synchronized (_reduced) {", "+      int oldLocation = getCurrentLocation();", "+      ", "+      try {", "+        ", "+        setCurrentLocation(0);", "+        final int docLength = getLength();", "+        final String text = getText(0, docLength);", "+        //      System.out.println(\"oldlocation: \" + oldLocation + \", doclength: \" + docLength + \", text: \\\"\" + text + \"\\\"\");", "+        // The location of the first non-whitespace character that", "+        // is not inside quote or comment.", "+        int firstNormalLocation = 0;", "+        while ((firstNormalLocation < docLength)) {", "+          setCurrentLocation(firstNormalLocation);", "+          ", "+          if (_reduced.currentToken().getHighlightState() == HighlightStatus.NORMAL) {", "+            // OK, it's normal -- so if it's not whitespace, we found the spot", "+            char curChar = text.charAt(firstNormalLocation);", "+            if (!Character.isWhitespace(curChar)) {", "+              break;", "+            }", "+          }", "+          ", "+          firstNormalLocation++;", "+        }", "+        ", "+        // Now there are two possibilities: firstNormalLocation is at", "+        // the first spot of a non-whitespace character that's NORMAL,", "+        // or it's at the end of the document.", "+        if (firstNormalLocation == docLength) return \"\";", "+        ", "+        final int strlen = \"package\".length();", "+        ", "+        final int endLocation = firstNormalLocation + strlen;", "+        ", "+        if ((firstNormalLocation + strlen > docLength) ||", "+            ! text.substring(firstNormalLocation, endLocation).equals(\"package\"))", "-          // OK, it's normal -- so if it's not whitespace, we found the spot", "-          char curChar = text.charAt(firstNormalLocation);", "-          if (!Character.isWhitespace(curChar)) {", "-            break;", "+          // the first normal text is not \"package\" or there is not enough", "+          // text for there to be a package statement.", "+          // thus, there is no valid package statement.", "+          return \"\";", "+        }", "+        ", "+        // OK, we must have found a package statement.", "+        // Now let's find the semicolon. Again, the semicolon must be free.", "+        int afterPackage = firstNormalLocation + strlen;", "+        ", "+        int semicolonLocation = afterPackage;", "+        do {", "+          semicolonLocation = text.indexOf(\";\", semicolonLocation + 1);", "+          ", "+          if (semicolonLocation == -1) {", "+            throw new InvalidPackageException(firstNormalLocation,", "+                                              \"No semicolon found to terminate \" +", "+                                              \"package statement!\");", "+          }", "+          ", "+          setCurrentLocation(semicolonLocation);", "+        }", "+        while (_reduced.currentToken().getHighlightState() !=", "+               HighlightStatus.NORMAL);", "+        ", "+        // Now we have semicolon location. We'll gather text in between one", "+        // character at a time for simplicity. It's inefficient (I think?)", "+        // but it's easy, and there shouldn't be much text between", "+        // \"package\" and \";\" anyhow.", "+        for (int walk = afterPackage + 1; walk < semicolonLocation; walk++) {", "+          setCurrentLocation(walk);", "+          ", "+          if (_reduced.currentToken().getHighlightState() ==", "+              HighlightStatus.NORMAL)", "+          {", "+            char curChar = text.charAt(walk);", "+            ", "+            if (! Character.isWhitespace(curChar)) {", "+              buf.append(curChar);", "+            }", "-", "-        firstNormalLocation++;", "-      }", "-", "-      // Now there are two possibilities: firstNormalLocation is at", "-      // the first spot of a non-whitespace character that's NORMAL,", "-      // or it's at the end of the document.", "-      if (firstNormalLocation == docLength) {", "-        return \"\";", "-      }", "-", "-      final int strlen = \"package\".length();", "-", "-      final int endLocation = firstNormalLocation + strlen;", "-", "-      if ((firstNormalLocation + strlen > docLength) ||", "-          ! text.substring(firstNormalLocation, endLocation).equals(\"package\"))", "-      {", "-        // the first normal text is not \"package\" or there is not enough", "-        // text for there to be a package statement.", "-        // thus, there is no valid package statement.", "-        return \"\";", "-      }", "-", "-      // OK, we must have found a package statement.", "-      // Now let's find the semicolon. Again, the semicolon must be free.", "-      int afterPackage = firstNormalLocation + strlen;", "-", "-      int semicolonLocation = afterPackage;", "-      do {", "-        semicolonLocation = text.indexOf(\";\", semicolonLocation + 1);", "-", "-        if (semicolonLocation == -1) {", "+        ", "+        String toReturn = buf.toString();", "+        if (toReturn.equals(\"\")) {", "-                                            \"No semicolon found to terminate \" +", "-                                            \"package statement!\");", "+                                            \"Package name was not specified \" +", "+                                            \"after the package keyword!\");", "-", "-        setCurrentLocation(semicolonLocation);", "+        ", "+        return toReturn;", "-      while (_reduced.currentToken().getHighlightState() !=", "-             HighlightStatus.NORMAL);", "-", "-      // Now we have semicolon location. We'll gather text in between one", "-      // character at a time for simplicity. It's inefficient (I think?)", "-      // but it's easy, and there shouldn't be much text between", "-      // \"package\" and \";\" anyhow.", "-      for (int walk = afterPackage + 1; walk < semicolonLocation; walk++) {", "-        setCurrentLocation(walk);", "-", "-        if (_reduced.currentToken().getHighlightState() ==", "-            HighlightStatus.NORMAL)", "-        {", "-          char curChar = text.charAt(walk);", "-", "-          if (! Character.isWhitespace(curChar)) {", "-            buf.append(curChar);", "-          }", "-        }", "+      catch (BadLocationException ble) {", "+        throw new UnexpectedException(ble);", "-", "-      String toReturn = buf.toString();", "-      if (toReturn.equals(\"\")) {", "-        throw new InvalidPackageException(firstNormalLocation,", "-                                          \"Package name was not specified \" +", "-                                          \"after the package keyword!\");", "+      finally {", "+        setCurrentLocation(0);", "+        setCurrentLocation(oldLocation);", "-", "-      return toReturn;", "-    }", "-    catch (BadLocationException ble) {", "-      throw new UnexpectedException(ble);", "-    }", "-    finally {", "-      setCurrentLocation(0);", "-      setCurrentLocation(oldLocation);"]}], "num": 2771}