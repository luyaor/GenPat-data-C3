{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3a8e4793c8db422d60fb8b282cf5e461", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7d8cf8585270321cef1e198105820f4e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/DefaultCompilerModel.java", "commitBeforeChange": "7b462e5cdfbc488a99d67df352bda94ace89024b", "commitAfterChange": "885cfecca904bc390539dbda728502710df6c2d9", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 17, "signatureBeforeChange": "   private List<File>      _compileLanguageLevelsFiles(List<File> files, List<DJError> errors,                                 Iterable<File> classPath, Iterable<File> bootClassPath) throws IOException", "signatureAfterChange": "   private List<File> _compileLanguageLevelsFiles(List<File> files, List<DJError> errors,                                                            Iterable<File> classPath, Iterable<File> bootClassPath)", "diff": ["-  private List<File> ", "-    _compileLanguageLevelsFiles(List<File> files, List<DJError> errors,", "-                                Iterable<File> classPath, Iterable<File> bootClassPath) throws IOException {", "+  private List<File> _compileLanguageLevelsFiles(List<File> files, List<DJError> errors,", "+                                                           Iterable<File> classPath, Iterable<File> bootClassPath) {", "+    LinkedList<File> newFiles = new LinkedList<File>();  // Used to record the LL files that must be converted", "+    LinkedList<File> filesToBeClosed = new LinkedList<File>(); // Used to record .java files that are open at the same time as their .dj? files.", "+        ", "-        if (javaFileSet.contains(javaFile)) { _showConflictingFilesMessage(javaFile); }", "+        ", "+        //checks if .dj? file has a matching .java file open in project. Eventually warns user (later on in code)", "+        if(files.contains(javaFile)){", "+          ", "+          filesToBeClosed.add(javaFile);", "+          ", "+        } ", "-", "+        newFiles.add(javaFile);", "+        ", "+      }   ", "+      else{  ", "+        javaFileSet.add(canonicalFile);", "-      else {", "-        if (javaFileSet.contains(canonicalFile)) { // canonicalFile was already added for a corresponding .dj* file", "-          _showConflictingFilesMessage(canonicalFile); }  ", "-        javaFileSet.add(canonicalFile); ", "+    }", "+    ", "+    for(File f: filesToBeClosed) {", "+      ", "+      File canonicalFile = IOUtil.attemptCanonicalFile(f);", "+      String fileName = canonicalFile.getPath();", "+      ", "+      if(files.contains(new File(fileName.substring(0,fileName.lastIndexOf(\".java\"))+\".dj0\")) ||", "+         files.contains(new File(fileName.substring(0,fileName.lastIndexOf(\".java\"))+\".dj1\")) ||", "+         files.contains(new File(fileName.substring(0,fileName.lastIndexOf(\".java\"))+\".dj2\"))", "+        ) {", "+        files.remove(new File(fileName));", "+      ", "+      ", "+    }", "+    ", "+    if(!filesToBeClosed.isEmpty()){", "+      new edu.rice.cs.drjava.ui.DrJavaScrollableDialog(null, \"Warning: Files need to be closed\",", "+                                                       \"The following files have matching .dj? files open.\", ", "+                                                       \"These .java files need to be closed for proper compiling. \\n \\n \\n\" +", "+                                                       filesToBeClosed.toString().replace(\", \",\"\\n\"),true).show();", "+      ", "+//      // Confirm that the .java files corresponding to .dj* files exist.", "+//      for (File f: newFiles)", "+//        if (! f.exists()) Utilities.show(f + \" does not exist\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb238e8a70f1573d72201d9e09413483", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractGlobalModel.java", "commitBeforeChange": "0d5df6cd7df2851aa927f5b2af952c4c284e3a43", "commitAfterChange": "d809f0c0466409ce32ae91b0868974eef6e3d031", "methodNumberBeforeChange": 159, "methodNumberAfterChange": 159, "signatureBeforeChange": "   private void _loadProject(final ProjectFileIR ir) throws IOException", "signatureAfterChange": "   private void _loadProject(final ProjectFileIR ir) throws IOException", "diff": ["+    ArrayList<DocumentRegion> expiredBookmarks = new ArrayList<DocumentRegion>();", "+    ArrayList<Breakpoint> expiredBreakpoints = new ArrayList<Breakpoint>();", "-      if (f.lastModified() > f.getSavedModDate()) f.setSavedModDate (f.lastModified());", "+      if (f.lastModified() > f.getSavedModDate()) {", "+        for (DocumentRegion r: getBookmarkManager().getRegions())", "+          if (r.getFile().equals( f )) expiredBookmarks.add( r );", "+        for (Breakpoint r: getBreakpointManager().getRegions())", "+          if (r.getFile().equals( f )) expiredBreakpoints.add( r );", "+        f.setSavedModDate (f.lastModified());", "+      }", "-      if (f.lastModified() > f.getSavedModDate()) f.setSavedModDate (f.lastModified());", "+      if (f.lastModified() > f.getSavedModDate()) {", "+        for (DocumentRegion r: getBookmarkManager().getRegions())", "+          if (r.getFile().equals( f )) expiredBookmarks.add( r );", "+        for (Breakpoint r: getBreakpointManager().getRegions())", "+          if (r.getFile().equals( f )) expiredBreakpoints.add( r );", "+        f.setSavedModDate (f.lastModified());", "+      }", "+    // Remove bookmarks and breakpoints for files that were modified outside of DrJava", "+    for (DocumentRegion r: expiredBookmarks) getBookmarkManager().removeRegion( r );", "+    for (Breakpoint r: expiredBreakpoints) getBreakpointManager().removeRegion( r );", "+    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d78ab4823efd2d5fcfea66ff75c5a118", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 354, "methodNumberAfterChange": 309, "signatureBeforeChange": "       public Predicate<DJClass> value(final Boolean includePrivate)", "signatureAfterChange": "   private static <I extends FunctionInvocation, T extends FunctionInvocationCandidate<I>>       Iterable<T> bestMatches(Iterable<T> candidates)", "diff": ["+   */", "+  private static <I extends FunctionInvocation, T extends FunctionInvocationCandidate<I>>", "+      Iterable<T> bestMatches(Iterable<T> candidates) {", "+    // This would be a static member of FunctionInvocationCandidate if that were legal;", "+    // it accesses the _matcher field as if it were.", "+    List<T> matches = new LinkedList<T>();", "+    for (T c : candidates) {", "+      if (c._matcher.matches()) { matches.add(c); }", "+    }", "+    if (matches.isEmpty()) {", "+      for (T c : candidates) {", "+        if (c._matcher.matchesWithBoxing()) { matches.add(c); }", "+      }", "+    }", "+    if (matches.isEmpty()) {", "+      for (T c : candidates) {", "+        if (c._matcher.matchesWithVarargs()) { matches.add(c); }", "+      }", "+    }", "+    return CollectUtil.minList(matches, new Order<T>() {", "+      public boolean contains(T c1, T c2) {", "+        return c1.moreSpecificThan(c2);", "+      }", "+    });", "+  }", "-    Lambda<Boolean, Predicate<DJClass>> makePred = new Lambda<Boolean, Predicate<DJClass>>() {", "-      public Predicate<DJClass> value(final Boolean includePrivate) {", "-        return new Predicate<DJClass>() {", "-          public boolean contains(DJClass c) {", "-            if (c.declaredName().equals(name)) {", "-              return includePrivate || !c.accessibility().equals(Access.PRIVATE);", "-            }", "-            else { return false; }", "-          }", "-        };", "-      }"]}], "num": 4618}