{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a81e658df071d5079ecc6f973960f9f5", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "41f06b690f957202966c7f1a77e292cf", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 116, "methodNumberAfterChange": 116, "signatureBeforeChange": "          public void testForComplexNamedClassInstantiation()", "signatureAfterChange": "          public void testForComplexNamedClassInstantiation()", "diff": ["+      ParenthesizedExpressionList pel1 = ", "+        new ParenthesizedExpressionList(SourceInfo.NONE, new Expression[] { new IntegerLiteral(SourceInfo.NONE, 5)});", "-        new ComplexNamedClassInstantiation(SourceInfo.NO_INFO, ", "-                                           new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"o\")), ", "-                                           new ClassOrInterfaceType(SourceInfo.NO_INFO, \"innerClass\", new Type[0]),                                  ", "-                                           new ParenthesizedExpressionList(SourceInfo.NO_INFO, ", "-                                                                           new Expression[] { new IntegerLiteral(SourceInfo.NO_INFO, 5)}));", "+        new ComplexNamedClassInstantiation(SourceInfo.NONE, ", "+                                           new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"o\")), ", "+                                           new ClassOrInterfaceType(SourceInfo.NONE, \"innerClass\", new Type[0]),                                  ", "+                                           pel1);", "-        new ComplexNamedClassInstantiation(SourceInfo.NO_INFO, ", "-                                           new SimpleNameReference(SourceInfo.NO_INFO, ", "-                                                                   new Word(SourceInfo.NO_INFO, \"o\")), ", "-                                           new ClassOrInterfaceType(SourceInfo.NO_INFO, \"innerClass\", new Type[0]), ", "-                                           new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]));", "+        new ComplexNamedClassInstantiation(SourceInfo.NONE, ", "+                                           new SimpleNameReference(SourceInfo.NONE, ", "+                                                                   new Word(SourceInfo.NONE, \"o\")), ", "+                                           new ClassOrInterfaceType(SourceInfo.NONE, \"innerClass\", new Type[0]), ", "+                                           new ParenthesizedExpressionList(SourceInfo.NONE, new Expression[0]));", "-      //if outer class is in symbol table and visible, but there is not a matching inner constructor, should give an error but still return instance of type", "+      // if outer class is in symbol table and visible, but there is not a matching inner constructor, should give ", "+      // an error but still return instance of type", "-      outerClass.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-      innerClass.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "+      outerClass.setMav(new ModifiersAndVisibility(SourceInfo.NONE, new String[] {\"public\"}));", "+      innerClass.setMav(new ModifiersAndVisibility(SourceInfo.NONE, new String[] {\"public\"}));", "-      assertEquals(\"Should return innerClass even though it could not find constructor\", innerClass.getInstanceData(), ci1.visit(_etc));", "+      assertEquals(\"Should return innerClass even though it could not find constructor\", innerClass.getInstanceData(), ", "+                   ci1.visit(_etc));", "-      assertEquals(\"Error message should be correct\", \"No constructor found in class outer.innerClass with signature: innerClass(int).\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\",", "+                   \"No constructor found in class outer.innerClass with signature: innerClass(int).\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"Should return innerClass even though it cannot really be instantiated\", innerClass.getInstanceData(), ci1.visit(_etc));", "+      assertEquals(\"Should return innerClass even though it cannot really be instantiated\", innerClass.getInstanceData(), ", "+                   ci1.visit(_etc));", "-      assertEquals(\"Error message should be correct\", \"outer.innerClass is abstract and thus cannot be instantiated\", errors.getLast().getFirst());              ", "+      assertEquals(\"Error message should be correct\", \"outer.innerClass is abstract and thus cannot be instantiated\", ", "+                   errors.getLast().getFirst());              ", "-      ComplexNamedClassInstantiation ci3 = new ComplexNamedClassInstantiation(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"outer\")), new ClassOrInterfaceType(SourceInfo.NO_INFO, \"innerClass\", new Type[0]), ", "-                                                                              new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]));             ", "-      outerClass.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-      innerClass.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-      assertEquals(\"Should return innerClass even though the syntax was wrong\", innerClass.getInstanceData(), ci3.visit(_etc));", "+      ComplexNamedClassInstantiation ci3 = ", "+        new ComplexNamedClassInstantiation(SourceInfo.NONE, ", "+                                           new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"outer\")), ", "+                                           new ClassOrInterfaceType(SourceInfo.NONE, \"innerClass\", new Type[0]), ", "+                                           new ParenthesizedExpressionList(SourceInfo.NONE, new Expression[0]));             ", "+      outerClass.setMav(new ModifiersAndVisibility(SourceInfo.NONE, new String[] {\"public\"}));", "+      innerClass.setMav(new ModifiersAndVisibility(SourceInfo.NONE, new String[] {\"public\"}));", "+      assertEquals(\"Should return innerClass even though the syntax was wrong\", innerClass.getInstanceData(), ", "+                   ci3.visit(_etc));", "-                   \"The constructor of a non-static inner class can only be called on an instance of its containing class (e.g. new outer().new innerClass())\", errors.getLast().getFirst());", "+                   \"The constructor of a non-static inner class can only be called on an instance of its containing \"", "+                     + \"class (e.g. new outer().new innerClass())\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"Should return innerClass even though the syntax was wrong\", innerClass.getInstanceData(), ci1.visit(_etc));", "+      assertEquals(\"Should return innerClass even though the syntax was wrong\", ", "+                   innerClass.getInstanceData(), ci1.visit(_etc));", "-                   \"You cannot instantiate a static inner class or interface with this syntax.  Instead, try new outer.innerClass()\",", "+                   \"You cannot instantiate a static inner class or interface with this syntax.  Instead, \"", "+                     + \"try new outer.innerClass()\",", "-      ComplexNamedClassInstantiation ci4 = new ComplexNamedClassInstantiation(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"o\")), new ClassOrInterfaceType(SourceInfo.NO_INFO, \"notInnerClass\", new Type[0]), ", "-                                                                              new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[] {new IntegerLiteral(SourceInfo.NO_INFO, 5)}));", "+      ParenthesizedExpressionList pel2 = ", "+        new ParenthesizedExpressionList(SourceInfo.NONE, new Expression[] {new IntegerLiteral(SourceInfo.NONE, 5)});", "+      ComplexNamedClassInstantiation ci4 = ", "+        new ComplexNamedClassInstantiation(SourceInfo.NONE, ", "+                                           new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"o\")), ", "+                                           new ClassOrInterfaceType(SourceInfo.NONE, \"notInnerClass\", new Type[0]), ", "+                                           pel2);", "-      assertEquals(\"Error message should be correct\", \"Class or variable notInnerClass not found.\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", \"Class or variable notInnerClass not found.\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"Error message should be correct\", \"The class or interface outer.innerClass is private and cannot be accessed from i.like.monkey\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"The class or interface outer.innerClass in outer.innerClass is private and cannot be accessed from i.like.monkey\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"Error message should be correct\", \"The class or interface outer is private and cannot be accessed from i.like.monkey\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"The class or interface outer in outer is private and cannot be accessed from i.like.monkey\", ", "+                   errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e39a3b138f57b6f8bb7fa2d1dab1fb06", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/BodyBodyIntermediateVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "          public void testForTryCatchStatement()", "signatureAfterChange": "                   public void testForTryCatchStatement()", "diff": ["+      ", "-      //make sure that if there is an error in one of the bodies, it is caught:", "-      BracedBody errorBody = new BracedBody(SourceInfo.NO_INFO, new BodyItemI[] {", "-        new ExpressionStatement(SourceInfo.NO_INFO, ", "-                                new BitwiseOrExpression(SourceInfo.NO_INFO, ", "-                                                        new SimpleNameReference(SourceInfo.NO_INFO, ", "-                                                                                new Word(SourceInfo.NO_INFO, \"i\")), ", "-                                                        new IntegerLiteral(SourceInfo.NO_INFO, 10)))});", "-      Block errorBlock = new Block(SourceInfo.NO_INFO, errorBody);", "+//      //make sure that if there is an error in one of the bodies, it is caught:", "+//      BracedBody errorBody = new BracedBody(SourceInfo.NO_INFO, new BodyItemI[] {", "+//        new ExpressionStatement(SourceInfo.NO_INFO, ", "+//                                new BitwiseOrExpression(SourceInfo.NO_INFO, ", "+//                                                        new SimpleNameReference(SourceInfo.NO_INFO, ", "+//                                                                                new Word(SourceInfo.NO_INFO, \"i\")), ", "+//                                                        new IntegerLiteral(SourceInfo.NO_INFO, 10)))});", "+//      Block errorBlock = new Block(SourceInfo.NO_INFO, errorBody);", "-      ntcs = new NormalTryCatchStatement(SourceInfo.NO_INFO, errorBlock, new CatchBlock[0]);", "+//      assert ! SourceInfo.TEST_0.equals(SourceInfo.TEST_1);", "+      ntcs = new NormalTryCatchStatement(SourceInfo.TEST_0, _generateErrorBlock(0), new CatchBlock[0]);", "-                   \"Bitwise or expressions cannot be used at any language level.  \" ", "+                   \"Bitwise or expressions cannot be used in the functional language level.  \" ", "-      UninitializedVariableDeclarator uvd = new UninitializedVariableDeclarator(SourceInfo.NO_INFO, new PrimitiveType(SourceInfo.NO_INFO, \"int\"), new Word(SourceInfo.NO_INFO, \"i\"));", "-      FormalParameter fp = new FormalParameter(SourceInfo.NO_INFO, uvd, false);", "+      UninitializedVariableDeclarator uvd = ", "+        new UninitializedVariableDeclarator(SourceInfo.TEST_1, ", "+                                            new PrimitiveType(SourceInfo.TEST_1, \"int\"), ", "+                                            new Word(SourceInfo.TEST_1, \"i\"));", "+      FormalParameter fp = new FormalParameter(SourceInfo.TEST_1, uvd, false);", "-      tcfs = new TryCatchFinallyStatement(SourceInfo.NO_INFO, b, new CatchBlock[] {", "-        new CatchBlock(SourceInfo.NO_INFO, fp, errorBlock)}, b);", "-        ", "+      tcfs = new TryCatchFinallyStatement(SourceInfo.TEST_1, b, new CatchBlock[] {", "+        new CatchBlock(SourceInfo.TEST_1, fp, _generateErrorBlock(1))", "+      }, b);", "+      ", "+     assertEquals(\"Should be one error\", 1, errors.size());", "-     assertEquals(\"Error message should be correct\", \"Bitwise or expressions cannot be used at any language level.  Perhaps you meant to compare two values using regular or (||)\", errors.getLast().getFirst());", "+     assertEquals(\"Error message should be correct\", ", "+                  \"Bitwise or expressions cannot be used in the functional language level.\"", "+                  + \"  Perhaps you meant to compare two values using regular or (||)\", ", "+                  errors.getLast().getFirst());"]}], "num": 30180}