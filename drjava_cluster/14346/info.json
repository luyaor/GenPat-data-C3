{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7e1b3bdb9606eddd8d776f56e9c9cdf9", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1c0351b682b4d5c085865b06bc82d88f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "f5712545338ec09fefb321f9e27396d8fb91a646", "commitAfterChange": "1676fcce81c19c5d647ee9a67867801bec666091", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 35, "signatureBeforeChange": "     @Override public Type visit(ConstructorCall node)", "signatureAfterChange": "          @Override public Type visit(ConstructorCall node)", "diff": ["-     */", "-      if (node.getExpression() != null) {", "-        throw new ExecutionError(\"not.implemented\", node);", "-      }", "-      ", "-      Iterable<? extends Expression> args = IterUtil.empty();", "-      if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "-      ", "-      // TODO: implement explict type arguments in constructor calls", "-      Iterable<Type> targs = IterUtil.empty();", "-      ", "-      Type result;", "-      if (node.isSuper()) { result = context.getSuperType(ts); }", "-      else { result = SymbolUtil.thisType(context.getThis()); }", "-      if (result == null) {", "-        throw new IllegalArgumentException(\"Can't check a ConstructorCall in this context\");", "-      }", "-      ", "-      try {", "-        ConstructorInvocation inv = ts.lookupConstructor(result, targs, args, expected);", "-        ", "-        // TODO: Check accessibility of constructor", "-        // Note that super constructor calls *have to* be accessible, even if accessibility", "-        // checking is turned off -- a call to a private constructor cannot be compiled", "-        // in a way that it will run successfully (since constructor calls are the only code", "-        // that is directly compiled rather than being interpreted, we don't have this problem", "-        // elsewhere)", "-        checkThrownExceptions(inv.thrown(), node);", "-        node.setArguments(CollectUtil.makeList(inv.args()));", "-        setConstructor(node, inv.constructor());", "-        return setType(node, result);", "-      }", "-      catch (InvalidTypeArgumentException e) {", "-        throw new ExecutionError(\"type.argument\", node);", "-      }", "-      catch (TypeSystemException e) {", "-        setErrorStrings(node, ts.userRepresentation(result), nodeTypesString(args));", "-        throw new ExecutionError(\"no.such.constructor\", node);", "-      }", "+      throw new ExecutionError(\"constructor.call\", node);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "df0e4a0f3c146937dc2b892ff3ef4994", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 29, "signatureBeforeChange": "   @Override public Type visit(SimpleAllocation node)", "signatureAfterChange": "     @Override public Type visit(SimpleAllocation node)", "diff": ["-   */", "-  @Override public Type visit(SimpleAllocation node) {", "-    Type t = node.getCreationType().acceptVisitor(this);", "-    // TODO: Allow a simple allocation of a dynamic inner class defined in the current context", "-    //       (where \"new Inner()\" is the equivalent of \"this.new Inner()\" or \"SomeOuter.this.new Inner()\")", "-    if (!ts.isConcrete(t) || !ts.isStatic(t)) {", "-      throw new ExecutionError(\"allocation.type\", node);", "-    }", "-    ", "-    Iterable<? extends Expression> args = IterUtil.empty();", "-    if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "-    ", "-    Iterable<Type> targs = IterUtil.empty();", "-    if (node instanceof PolymorphicSimpleAllocation) {", "-      targs = checkTypeNameList(((PolymorphicSimpleAllocation) node).getTypeArguments());", "-    }", "-    ", "-    try {", "-      TypeSystem.ConstructorInvocation inv = ts.lookupConstructor(t, targs, args);", "-      // TODO: Check accessibility of constructor", "-      checkThrownExceptions(inv.thrown(), node);", "-      node.setArguments(CollectUtil.makeList(inv.args()));", "-      setConstructor(node, inv.constructor());", "-      return setType(node, t);", "-    }", "-    catch (InvalidTypeArgumentException e) {", "-      throw new ExecutionError(\"type.argument\", node);", "-    }", "-    catch (TypeSystemException e) {", "-      setErrorStrings(node, ts.userRepresentation(t), nodeTypesString(args));", "-      throw new ExecutionError(\"no.such.constructor\", node);", "-    }", "-  }", "+     */", "+    @Override public Type visit(SimpleAllocation node) {", "+      Type t = checkTypeName(node.getCreationType());", "+      // TODO: Allow a simple allocation of a dynamic inner class defined in the current context", "+      //       (where \"new Inner()\" is the equivalent of \"this.new Inner()\" or \"SomeOuter.this.new Inner()\")", "+      if (!ts.isConcrete(t) || !ts.isStatic(t)) {", "+      if (node instanceof PolymorphicSimpleAllocation) {", "+        targs = checkTypeNameList(((PolymorphicSimpleAllocation) node).getTypeArguments());", "+      ", "+        ConstructorInvocation inv = ts.lookupConstructor(t, targs, args, expected);"]}], "num": 14346}