{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7cf03e09a73f134d5ac66f701ee59462", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dea0a616c05d4adfe7ca9c65bde4efe6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/FindReplaceMachine.java", "commitBeforeChange": "14164b6a15fd606e897810fd89f2e7edec0280c4", "commitAfterChange": "52c187d5d51895f0b58a56680e35117f80ff45ef", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 28, "signatureBeforeChange": "   private FindResult findNext(boolean searchAll)", "signatureAfterChange": "   private FindResult findNext(boolean searchAll)", "diff": ["-  private FindResult findNext(boolean searchAll) {  ", "- ", "-    // If the user just found a match and toggled the \"Search Backwards\" option, we should skip the matched text.", "-    if (_skipText) {  // adjust position (offset)", "+  private FindResult findNext(boolean searchAll) {", "+    ", "+    // Find next match, if any, in _doc. ", "+    _doc.readLock();", "+    FindResult fr;", "+    int start;", "+    int len;", "+    try {", "+      ", "+      // If the user just found a match and toggled the \"Search Backwards\" option, we should skip the matched text.", "+      if (_skipText) {  // adjust position (offset)", "-      int wordLen = _lastFindWord.length();", "-      if (_isForward) setPosition(getCurrentOffset() + wordLen);", "-      else setPosition(getCurrentOffset() - wordLen);", "-      positionChanged();", "-    }", "-    ", "+        int wordLen = _lastFindWord.length();", "+        if (_isForward) setPosition(getCurrentOffset() + wordLen);", "+        else setPosition(getCurrentOffset() - wordLen);", "+        positionChanged();", "+      }", "+      ", "-    ", "-    int offset = getCurrentOffset();", "+      ", "+      int offset = getCurrentOffset();", "-    if (_isForward) return _findNext(_doc, offset, _doc.getLength() - offset, searchAll);", "-    return _findNext(_doc, 0, offset, searchAll);", "-  } ", "+      if (_isForward) { ", "+        start = offset; ", "+        len = _doc.getLength() - offset; ", "+      }", "+      else { ", "+        start = 0; ", "+        len = offset; ", "+      }", "+      fr = _findNextInDoc(_doc, start, len, searchAll);", "+    }", "+    finally { _doc.readUnlock(); }", "+    if ((fr.getFoundOffset() >= 0) || ! searchAll) return fr;  // match found in _doc", "+    // find match in other docs", "+    return _findNextInOtherDocs(_doc, start, len);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1281517541c71a84b18122d1f82101d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/ConcreteRegionManager.java", "commitBeforeChange": "1ff154e9eb4de7b8f07ce9a8120997b76e53aa3f", "commitAfterChange": "50372cdcb0e3a8db5661a31f5825b5dc9f07a9e9", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 5, "signatureBeforeChange": "   public R getRegionAt(OpenDefinitionsDocument odd, int offset)", "signatureAfterChange": "   public R getRegionAt(OpenDefinitionsDocument odd, int offset)", "diff": ["+    */", "+  public R getRegionAt(OpenDefinitionsDocument odd, int offset) { ", "+//    assert EventQueue.isDispatchThread();", "+    ", "+    /* Get the tailSet consisting of the ordered set of regions [start, end) such that end > offset. */", "+    @SuppressWarnings(\"unchecked\")", "+    SortedSet<R> tail = getTailSet((R) newDocumentRegion(odd, 0, offset + 1));", "+    ", "+    /* If tail contains a match, it must be the first non-degenerate region, since all regions in a document are ", "+     * disjoint. (Every degenerate region is disjoint from every other region because it is empty.) tail is sorted by ", "+     * [endOffset, startOffset]; tail may be empty.  We use a loop because the number of degenerate regions is ", "+     * unbounded. */", "+", "+    for (R r: tail) {", "+      int start = r.getStartOffset();", "+      int end = r.getEndOffset();", "+      if (start == end) continue;", "+      if (start <= offset) return r;", "+      else break;", "+    }", "+    return null;", "-    */", "-  public R getRegionAt(OpenDefinitionsDocument odd, int offset) { return getRegionContaining(odd, offset, offset); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f8c48fbba57c8a078377e3eccd1fa00b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/MainFrame.java", "commitBeforeChange": "b2ad80c49aaa09f293a5bc1f6664d4cc5243219e", "commitAfterChange": "492227e53d4f60169465f2fd7192a458815ea62f", "methodNumberBeforeChange": 50, "methodNumberAfterChange": 50, "signatureBeforeChange": "   private void _setUpDocumentSelector()", "signatureAfterChange": "   private void _setUpDocumentSelector()", "diff": ["-    _docList = new JList(_model.getDefinitionsDocuments());// {", "-      //public String getToolTipText(MouseEvent event) {", "-      //  return \"tool tip\";", "-      //}", "-    //};", "+    _docList = new JList(_model.getDefinitionsDocuments()) {", "+      public String getToolTipText(MouseEvent event) {", "+        Point location = event.getPoint();", "+        int index = locationToIndex(location);", "+        String tip = null;", "+        if (index >= 0) {", "+          tip = _model.getDisplayFullPath(index);", "+        }", "+        return tip;", "+      }", "+    };", "+    _docList.setToolTipText(\"Document List\");"]}], "num": 27605}