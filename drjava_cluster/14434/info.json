{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "31cf90009ce96cb6f1c931ab1d6b750f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "098db0cdf2c025b4aa1ee6eedcf1fda5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyAdvancedVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r   public void forConstructorDef(ConstructorDef that)", "signatureAfterChange": "   public void forConstructorDef(ConstructorDef that)", "diff": ["-   */\r", "-  public void forConstructorDef(ConstructorDef that) {\r", "-    forConstructorDefDoFirst(that);\r", "-    if (prune(that)) { return; }\r", "-    \r", "-    that.getMav().visit(this);\r", "-    String name = getUnqualifiedClassName(that.getName().getText());\r", "-    if ((that.getName().getText().indexOf(\".\") != -1 && !that.getName().getText().equals(_symbolData.getName())) || !name.equals(getUnqualifiedClassName(_symbolData.getName()))) {\r", "-      _addAndIgnoreError(\"The constructor return type and class name must match\", that);\r", "-    }\r", "-\r", "-    // Turn the thrown exceptions from a ReferenceType[] to a String[]\r", "-    String[] throwStrings = referenceType2String(that.getThrows());\r", "-    \r", "-    SymbolData returnType = _symbolData;\r", "-    MethodData md = new MethodData(name, that.getMav(), new TypeParameter[0], returnType, \r", "-                                   new VariableData[0], throwStrings, _symbolData, that);\r", "-\r", "-    _checkError(); // reset check flag\r", "-    // Turn the parameters from a FormalParameterList to a VariableData[]\r", "-    VariableData[] vds = formalParameters2VariableData(that.getParameters(), md);\r", "-    if (! _checkError()) {  //if there was an error converting the formalParameters, don't use them.\r", "-      md.setParams(vds);\r", "-      if (!md.addFinalVars(vds)) {\r", "-        _addAndIgnoreError(\"You cannot have two method parameters with the same name\", that);\r", "-      }\r", "-    }\r", "-    \r", "-    _symbolData.addMethod(md);\r", "-    that.getStatements().visit(new BodyBodyAdvancedVisitor(md, _file, _package, _importedFiles, _importedPackages, _classNamesInThisFile, continuations));\r", "-\r", "-    //note that we have seen a constructor.\r", "-    _symbolData.incrementConstructorCount();\r", "-  }\r", "+   */", "+  public void forConstructorDef(ConstructorDef that) {", "+    forConstructorDefDoFirst(that);", "+    if (prune(that)) return;", "+    ", "+    that.getMav().visit(this);", "+    String name = getUnqualifiedClassName(that.getName().getText());", "+    if ((that.getName().getText().indexOf(\".\") != -1 && !that.getName().getText().equals(_symbolData.getName())) || !name.equals(getUnqualifiedClassName(_symbolData.getName()))) {", "+      _addAndIgnoreError(\"The constructor return type and class name must match\", that);", "+    }", "+", "+    // Turn the thrown exceptions from a ReferenceType[] to a String[]", "+    String[] throwStrings = referenceType2String(that.getThrows());", "+    ", "+    SymbolData returnType = _symbolData;", "+    MethodData md = MethodData.make(name, that.getMav(), new TypeParameter[0], returnType, ", "+                                   new VariableData[0], throwStrings, _symbolData, that);", "+", "+    _checkError(); // reset check flag", "+    // Turn the parameters from a FormalParameterList to a VariableData[]", "+    VariableData[] vds = formalParameters2VariableData(that.getParameters(), md);", "+    if (! _checkError()) {  //if there was an error converting the formalParameters, don't use them.", "+      md.setParams(vds);", "+      if (!md.addFinalVars(vds)) {", "+        _addAndIgnoreError(\"You cannot have two method parameters with the same name\", that);", "+      }", "+    }", "+    ", "+    _symbolData.addMethod(md);", "+    that.getStatements().visit(new BodyBodyAdvancedVisitor(md, _file, _package, _importedFiles, _importedPackages, _classNamesInThisFile, continuations));", "+", "+    //note that we have seen a constructor.", "+    _symbolData.incrementConstructorCount();", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "171d90f0760f4a3d262edd5bee1fa3ac", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyIntermediateVisitor.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r   public void forConstructorDef(ConstructorDef that)", "signatureAfterChange": "   public void forConstructorDef(ConstructorDef that)", "diff": ["-   */\r", "-  public void forConstructorDef(ConstructorDef that) {\r", "-    forConstructorDefDoFirst(that);\r", "-    if (prune(that)) { return; }\r", "-\r", "-    that.getMav().visit(this);\r", "-    String name = getUnqualifiedClassName(that.getName().getText());\r", "-    if (!name.equals(getUnqualifiedClassName(_symbolData.getName()))) {\r", "-      _addAndIgnoreError(\"The constructor return type and class name must match\", that);\r", "-    }\r", "-\r", "-    // Turn the thrown exceptions from a ReferenceType[] to a String[]\r", "-    String[] throwStrings = referenceType2String(that.getThrows());\r", "-    \r", "-    SymbolData returnType = _symbolData;\r", "-    MethodData md = new MethodData(name, that.getMav(), new TypeParameter[0], returnType, \r", "-                                   new VariableData[0], throwStrings, _symbolData, that);\r", "-    \r", "-    //At Intermediate Level, constructors are still public by default.\r", "-    if (!md.hasModifier(\"public\") && !md.hasModifier(\"private\") && !md.hasModifier(\"protected\")) {\r", "-      md.addModifier(\"public\");\r", "-    }\r", "-    \r", "-    _checkError(); // reset check flag\r", "-    // Turn the parameters from a FormalParameterList to a VariableData[]\r", "-    VariableData[] vds = formalParameters2VariableData(that.getParameters(), md);\r", "-    if (! _checkError()) {  //if there was an error converting the formalParameters, don't use them.\r", "-      md.setParams(vds);\r", "-      if (!md.addFinalVars(vds)) {\r", "-        _addAndIgnoreError(\"You cannot have two method parameters with the same name\", that);\r", "-      }\r", "-    }\r", "-    \r", "-    _symbolData.addMethod(md);\r", "-    that.getStatements().visit(new BodyBodyIntermediateVisitor(md, _file, _package, _importedFiles, _importedPackages, _classNamesInThisFile, continuations));\r", "-    //note that we have seen a constructor.\r", "-    _symbolData.incrementConstructorCount();\r", "-    forConstructorDefOnly(that);\r", "-  }\r", "+  /** Create a constructor corresponding to the specifications in the ConstructorDef.  */", "+  public void forConstructorDef(ConstructorDef that) {", "+    forConstructorDefDoFirst(that);", "+    if (prune(that)) return;", "+", "+    that.getMav().visit(this);", "+    String name = getUnqualifiedClassName(that.getName().getText());", "+    if (!name.equals(getUnqualifiedClassName(_classData.getName()))) {", "+      _addAndIgnoreError(\"The constructor return type and class name must match\", that);", "+    }", "+", "+    // Turn the thrown exceptions from a ReferenceType[] to a String[]", "+    String[] throwStrings = referenceType2String(that.getThrows());", "+    ", "+    SymbolData returnType = _classData;", "+    MethodData md = new MethodData(name, that.getMav(), new TypeParameter[0], returnType, ", "+                                   new VariableData[0], throwStrings, _classData, that);", "+    ", "+    // At Intermediate Level, constructors are still public by default.", "+    if (! md.hasModifier(\"public\") && ! md.hasModifier(\"private\") && ! md.hasModifier(\"protected\")) {", "+      md.addModifier(\"public\");", "+    }", "+    ", "+    _checkError(); // reset check flag", "+    // Turn the parameters from a FormalParameterList to a VariableData[]", "+    VariableData[] vds = formalParameters2VariableData(that.getParameters(), md);", "+    if (! _checkError()) {  //if there was an error converting the formalParameters, don't use them.", "+      md.setParams(vds);", "+      if (!md.addFinalVars(vds)) {", "+        _addAndIgnoreError(\"You cannot have two method parameters with the same name\", that);", "+      }", "+    }", "+    ", "+    _classData.addMethod(md);", "+    that.getStatements().visit(new BodyBodyIntermediateVisitor(md, _file, _package, _importedFiles, _importedPackages, _classNamesInThisFile, continuations));", "+    //note that we have seen a constructor.", "+    _classData.incrementConstructorCount();", "+    forConstructorDefOnly(that);", "+  }"]}], "num": 14434}