{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "460be524b3fee0b2d4af95e157963292", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0f8d005f2a37f145be4363aecd4b660d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 45, "signatureBeforeChange": "   protected VariableData[] _variableDeclaration2VariableData(VariableDeclaration vd, Data enclosing)", "signatureAfterChange": "   protected VariableData[] _variableDeclaration2VariableData(VariableDeclaration vd, final Data enclosing)", "diff": ["-  protected VariableData[] _variableDeclaration2VariableData(VariableDeclaration vd, Data enclosing) {", "+  protected VariableData[] _variableDeclaration2VariableData(VariableDeclaration vd, final Data enclosing) {", "+    assert enclosing != null;", "+    System.err.println(\"*** 2Var called for \\n\" + declaratorsToString(vd.getDeclarators()) + \"\\nin \" + enclosing);", "-    for (VariableDeclarator declarator: declarators) {", "+    for (final VariableDeclarator declarator: declarators) {", "-      Type type = declarator.getType();", "-      String name = declarator.getName().getText();", "-      SymbolData sd = handleDeclarator(type, name, enclosing);", "-      if (sd != null) {", "-        boolean initialized = declarator instanceof InitializedVariableDeclarator;", "-        // want hasBeenAssigned to be true if this variable declaration is initialized, and false otherwise.", "-//        System.err.println(\"creating new VariableData for \" + name);", "-        VariableData vdata = new VariableData(name, mav, sd, initialized, enclosing); ", "-        vdata.setHasInitializer(initialized);", "+      final Type type = declarator.getType();", "+      final String name = declarator.getName().getText();", "+      final String typeName = type.getName();", "+//      assert enclosing == getQualifiedSymbolData(_enclosingClassName, SourceInfo.NO_INFO);", "+      // TODO: if enclosing is a MethodData, we should first look for a local class!!!  This search will always", "+      // succeed if a matching local class exists because no forward reference is possible. (Confirm this!) !!!", "+      /* TODO: do we need to worry about case when enclosing is a MethodData?  Yes. defineInnerSymbolData ", "+       * already treats local classes specially, but it doesn't help.  References to local types use relative", "+       * class names. */", "+      SymbolData sd = _identifyType(typeName, declarator.getSourceInfo(), _enclosingClassName);  // may be null", "+      boolean initialized = declarator instanceof InitializedVariableDeclarator;", "+      // want hasBeenAssigned to be true if this variable declaration is initialized, and false otherwise.", "+      System.err.println(\"Creating new VariableData \" + name + \" : \" + typeName + \" within \" + _enclosingClassName);", "+      final VariableData vdata = new VariableData(name, mav, sd, initialized, enclosing); ", "+      vdata.setHasInitializer(initialized);", "-        vds.addLast(vdata); ", "-      }", "-      else {", "-//        System.err.println(\"handleDeclarator(\" + type + \", \" + name + \", \" + enclosing + \") returned null\");", "-        _addAndIgnoreError(\"Class or Interface \" + name + \" not found\", type);", "+      vds.addLast(vdata); ", "+//        System.err.println(\"identifyReturnType(\" + type + \", \" + name + \", \" + enclosing + \") returned null\");", "+      if (sd == null) { // TODO !!! Can this really happen?", "+        // Create fixup", "+        final String enclosingName = _enclosingClassName;  // Grab the current enclosing class name", "+        System.err.println(\"**** Creating fixup for preceding VariableData\");", "+        Command fixup = new Command() {", "+          public void execute() {", "+            System.err.println(\"**** Executing fixup for \" + typeName + \" within \" + enclosingName);", "+            SymbolData newSd = _identifyType(typeName, declarator.getSourceInfo(), enclosingName);", "+            if (newSd != null) vdata.setType(newSd);", "+            else _addAndIgnoreError(\"Class or Interface \" + typeName + \" not found\", type);", "+          }", "+        };", "+        fixUps.add(fixup);       ", "-  }", "+  }                       "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c187ae0a0fa37437be630a417e9f390", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 58, "signatureBeforeChange": "              public FieldVisitor visitField(int access, String name, String desc, String sig, Object value)", "signatureAfterChange": "   protected void identifyInnerClasses(TypeDefBase that)", "diff": ["-      ", "-      public FieldVisitor visitField(int access, String name, String desc, String sig, Object value) {", "-        /* Private fields cannot be ignored because they are used in code augmentation for generating constructors,", "-         * equals, and hashCode. */", "-        String typeString = org.objectweb.asm.Type.getType(desc).getClassName();", "-        SymbolData type = getSymbolDataForClassFile(typeString, lookupInfo);", "-        if (type != null) { sd.addVar(new VariableData(name, _createMav(access), type, true, sd)); }", "-        return null;", "-      }", "+  /** Processes the class body that. */", "+  protected void identifyInnerClasses(TypeDefBase that) {", "+    String enclosingType = getQualifiedClassName(that.getName().getText());", "+    assert enclosingType != null;", "+    // Process the members of this class", "+    System.err.println(\"Finding inner classes in \" + enclosingType);", "+    SymbolData sd = getSymbolData(enclosingType, SourceInfo.NO_INFO);", "+    BracedBody body = that.getBody();", "+    for (BodyItemI bi: body.getStatements()) {", "+      if (bi instanceof TypeDefBase) {", "+        TypeDefBase type = (TypeDefBase) bi;", "+        String rawClassName = type.getName().getText();", "+        System.err.println(\"Adding \" + rawClassName + \" to inner classes of \" + enclosingType + \"\\n\");", "+        String fullClassName = enclosingType + '.' + rawClassName;", "+//        System.err.println(\"Adding \" + rawClassName + \" to _innerClassesInThisBody inside \" + that + \"\\n\");", "+        ", "+//          _innerClassesInThisBody.add(fullClassName);", "+        SymbolData innerSD = makeContinuation(bi.getSourceInfo(), fullClassName);", "+        sd.addInnerClass(innerSD);", "+      }", "+    }", "+//    System.err.println(\"_innerClassesInThisBody = \" + _innerClassesInThisBody);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f145565b9615ff6d1ed67f1896793d4", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 42, "signatureBeforeChange": "   protected MethodData createMethodData(MethodDef that, SymbolData sd)", "signatureAfterChange": "   protected MethodData createMethodData(final MethodDef that, final SymbolData sd)", "diff": ["-  /** Create a MethodData corresponding to the MethodDef within the context of the SymbolData sd. */", "-  protected MethodData createMethodData(MethodDef that, SymbolData sd) {", "-//    Utilities.show(\"createMethodData called on \" + that);", "+  /** Creates a MethodData corresponding to the MethodDef within the context of the SymbolData sd. */", "+  protected MethodData createMethodData(final MethodDef that, final SymbolData sd) {", "+    ", "+    assert _enclosingClassName != null && getQualifiedSymbolData(_enclosingClassName).equals(sd);", "+    ", "+    System.err.println(\"createMethodData(\" + that.getName().getText() + \", \" + sd + \") called.\");", "+    System.err.println(\"_enclosingClassName = \" + _enclosingClassName);", "+       ", "+    final String rtString = that.getResult().getName();", "+", "+    // Identify the return type", "+    final SourceInfo si = that.getResult().getSourceInfo();", "+//    if (! sd.equals(getQualifiedSymbolData(_enclosingClassName, SourceInfo.NO_INFO))) {", "+//      System.err.println(\"sd = \" + sd);", "+//      System.err.println(\"other = \" + getQualifiedSymbolData(_enclosingClassName, SourceInfo.NO_INFO));", "+//      assert false;", "+//    }", "+    // Note: rtString cannot be a local type; no such type is in scope", "+    SymbolData returnType = _identifyType(rtString, si, _enclosingClassName);", "-    // Turn the ReturnTypeI into a SymbolData    ", "-    String rtString = that.getResult().getName();", "-    SymbolData returnType;", "-    //TODO: Overwrite this at the Advanced level (or maybe not)", "-    if (rtString.equals(\"void\"))  returnType = SymbolData.VOID_TYPE;", "-    else returnType = getSymbolData(rtString, that.getResult().getSourceInfo());", "+    final String name = that.getName().getText();", "+    System.err.println(\"Creating MethodData for \" + name + \" in type \" + sd);", "+    final MethodData md = ", "+      MethodData.make(name, that.getMav(), that.getTypeParams(), returnType, null, throwStrings, sd, that);", "+    VariableData[] vds = formalParameters2VariableData(that.getParams(), sd);", "+        ", "+    if (returnType == null) {", "+      System.err.println(\"Creating return type fixup for \" + rtString + \" in method \" + name + \" in class \" + sd);", "+      final String enclosingClassName = _enclosingClassName;", "+      Command fixUp = new Command() {", "+        public void execute() {", "+          SymbolData newReturnType = _identifyType(rtString, si, enclosingClassName);", "+          if (newReturnType == null) ", "+            _addAndIgnoreError(\"The return type \" + rtString + \" for method \" + name + \" in type \" + sd + \" is undefined.\", ", "+                               that);", "+          else md.setReturnType(newReturnType);", "+        }", "+      };", "+      fixUps.add(fixUp);", "+    }", "-    MethodData md = MethodData.make(that.getName().getText(), that.getMav(), that.getTypeParams(), returnType, ", "-                                    new VariableData[0], throwStrings, sd, that);", "+    System.err.println(\"Called createMethodData(\" + name + \", \" + sd.getName() + \")\");", "-    VariableData[] vds = formalParameters2VariableData(that.getParams(), md);", "+"]}], "num": 2753}