{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0bd1d41d10f03030cbf68fae45365278", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "07d828fd9e99f59487afd01633c3c31d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/IntermediateVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 34, "signatureBeforeChange": "          public void testCreateConstructor()", "signatureAfterChange": "     public void testCreateConstructor()", "diff": ["-    ", "+    /** Tests createConstructor.  Must ensure that no fixups remain pending before invoking this method. */", "-      SymbolData sd = new SymbolData(\"ClassName\", _publicMav, new TypeParameter[0], null, new LinkedList<SymbolData>(), null);", "-      VariableData v1 = new VariableData(\"i\", _publicMav, SymbolData.INT_TYPE, false, sd);", "-      VariableData v2 = new VariableData(\"j\", _publicMav, SymbolData.CHAR_TYPE, false, sd);", "-      VariableData v3 = new VariableData(\"var\", _publicMav, SymbolData.DOUBLE_TYPE, false, sd);", "+      SymbolData sd =", "+        new SymbolData(\"ClassName\", PUBLIC_MAV, new TypeParameter[0], null, new ArrayList<SymbolData>(), null);", "+      VariableData v1 = new VariableData(\"i\", PUBLIC_MAV, SymbolData.INT_TYPE, false, sd);", "+      VariableData v2 = new VariableData(\"j\", PUBLIC_MAV, SymbolData.CHAR_TYPE, false, sd);", "+      sd.setIsContinuation(false);", "+", "+      System.err.println(\"****** Creating constructor for \" + _sd1);", "+      _iv.createConstructor(_sd1);  // Cannot create constructor for s1 without creating one for its superclass.", "-      MethodData md = new MethodData(\"ClassName\", _publicMav, new TypeParameter[0], sd, ", "-                                     sd.getVars().toArray(new VariableData[0]), ", "+      /* Construct expected MethodData */", "+      // Copy vars without visibility", "+      LinkedList<VariableData> params = new LinkedList<VariableData>();", "+      for (VariableData vd: sd.getVars()) {", "+        VariableData newParam = vd.copyWithoutVisibility();", "+        newParam.setGenerated(true);", "+        params.add(newParam);", "+      };", "+        ", "+      MethodData md = new MethodData(\"ClassName\", ", "+                                     PUBLIC_MAV, ", "+                                     new TypeParameter[0], ", "+                                     sd, ", "+                                     params.toArray(new VariableData[params.size()]), ", "-      md.addVars(md.getParams());", "+      md.addVars(md.getParams());     ", "+      md.setGenerated(true);", "+      ", "+      System.err.println(\"****** Before creating Classname constructor, ClassName methods = \" + sd.getMethods());", "+      System.err.println(\"****** Creating constructor for \" + sd);", "+      System.err.println(\"****** After creating constructor, ClassName method = \" + sd.getMethods());", "+", "+      MethodData conSD = sd.getMethods().getFirst();", "+          ", "+      System.err.println(\"****** Generated MethodData: \" + conSD.toBigString());", "+      System.err.println(\"****** Expectred MethodData: \" + md.toBigString());", "+      assertEquals(\"sd should have 1 method: its own constructor\", md, conSD);", "-      assertEquals(\"sd should have 1 method: its own constructor\", md, sd.getMethods().getFirst());", "-      ", "-      //since this is the only constructor in the symbol data, all the fields should be assigned to have a value after visiting sd.", "-      v1 = new VariableData(\"i\", _publicMav, SymbolData.INT_TYPE, true, sd);", "-      v2 = new VariableData(\"j\", _publicMav, SymbolData.CHAR_TYPE, true, sd);", "+//      // Since this is the only constructor in the SymbolData, all the fields should be assigned after visiting sd.", "+//      v1 = new VariableData(\"i\", PUBLIC_MAV, SymbolData.INT_TYPE, true, sd);", "+//      v2 = new VariableData(\"j\", PUBLIC_MAV, SymbolData.CHAR_TYPE, true, sd);", "+", "+      // Now test a subclass of sd:", "+", "+      SymbolData subSD = ", "+        new SymbolData(\"Subclass\", PUBLIC_MAV, new TypeParameter[0], null, new ArrayList<SymbolData>(), null);", "+      VariableData v3 = new VariableData(\"var\", PUBLIC_MAV, SymbolData.DOUBLE_TYPE, false, subSD);", "+      subSD.addVar(v3);", "+//      // Revise params rather than recreating them, because they contain hidden fields like enclosingData that", "+//      // must be right for equality testing to succeeed", "+//      params.get(0).setName(\"super_i\");", "+//      params.get(1).setName(\"super_j\");", "+//      VariableData v3Param = v3.copyWithoutVisibility();", "+//      v3Param.setGenerated(true);", "+//      params.add(v3Param);", "+      subSD.setSuperClass(sd);", "-      //now test a subclass of sd:", "-      SymbolData subSd = new SymbolData(\"Subclass\",_publicMav, new TypeParameter[0], null, new LinkedList<SymbolData>(), null);", "-      subSd.addVar(v3);", "-      subSd.setSuperClass(sd);", "+      // Create copies of v1, v2. v3 with Package MAV", "+      VariableData v1Param = new VariableData(\"super_i\", PACKAGE_MAV, SymbolData.INT_TYPE, true, subSD);", "+      VariableData v2Param = new VariableData(\"super_j\", PACKAGE_MAV, SymbolData.CHAR_TYPE, true, subSD);", "+      VariableData v3Param = new VariableData(\"var\", PACKAGE_MAV, SymbolData.DOUBLE_TYPE, true, subSD);", "+          ", "+      v1Param.setGenerated(true);", "+      v2Param.setGenerated(true);", "+      v3Param.setGenerated(true);", "-      VariableData v1Param = new VariableData(\"super_i\", _packageMav, SymbolData.INT_TYPE, true, null);", "-      VariableData v2Param = new VariableData(\"super_j\", _packageMav, SymbolData.CHAR_TYPE, true, null);", "-      VariableData[] vars = {v1Param, v2Param, v3};", "-      MethodData md2 = new MethodData(\"Subclass\", _publicMav, new TypeParameter[0], subSd,", "-                                      vars, new String[0], subSd, null);", "+      VariableData[] newParams = new VariableData[] { v1Param, v2Param, v3Param };", "+      ", "+//      VariableData[] newParams = params.toArray(new VariableData[params.size()]);", "+      ", "+      MethodData md2 = ", "+        new MethodData(\"Subclass\", ", "+                       PUBLIC_MAV, ", "+                       new TypeParameter[0], ", "+                       subSD, ", "+                       newParams,", "+                       new String[0], ", "+                       subSD, ", "+                       null);", "+      ", "+      md2.setGenerated(true);", "-      _iv.createConstructor(subSd);", "-      v1Param.setEnclosingData(subSd.getMethods().getFirst());", "-      v2Param.setEnclosingData(subSd.getMethods().getFirst());", "-      assertEquals(\"subSd should have 1 method: its own constructor.\", md2, subSd.getMethods().getFirst());", "+      _iv.createConstructor(subSD);", "+      ", "+      conSD = subSD.getMethods().getFirst();  // Reusing conSD local variable", "+      System.err.println(\"****** Expected params = \" + Arrays.toString(md2.getParams()));", "+      System.err.println(\"****** Results  params = \" + Arrays.toString(conSD.getParams()));", "+      ", "+      System.err.println(\"****** Expected vars = \" + md2.getVars());", "+      System.err.println(\"****** Results  vars = \" + conSD.getVars());", "+      ", "+      System.err.println(\"****** Constructor for Subclass is: \" + conSD.toBigString());", "+      System.err.println(\"****** Expected MethodData is: \" + md2.toBigString());", "+      ", "+      assert md2.getName().equals(conSD.getName());", "+      assert md2.getMav().equals(conSD.getMav());", "+      assert arrayEquals(md2.getTypeParameters(), conSD.getTypeParameters());", "+      assert arrayEquals(md2.getThrown(), conSD.getThrown());", "+      assert md2.getEnclosingData().equals(conSD.getEnclosingData());", "+      LinkedList<VariableData> mVars = md2.getVars();", "+      LinkedList<VariableData> cVars = conSD.getVars();", "+      assert mVars.size() == cVars.size();", "+      for (int i = 0; i < mVars.size(); i++) {", "+        System.err.println(\"****** EnclosingData of mVars \" + i + \" = \" + mVars.get(i).getEnclosingData());", "+        System.err.println(\"****** EnclosingData of cVars \" + i + \" = \" + cVars.get(i).getEnclosingData());", "+        assertEquals(\"Var Test\" + i, mVars.get(i), cVars.get(i));", "+      }", "+        ", "+      assert md2.getVars().equals(conSD.getVars());", "+      assert arrayEquals(md2.getParams(), conSD.getParams());", "+", "+      assertEquals(\"subSD should have 1 method: its own constructor.\", md2, conSD);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "890b0409124cdaf0ef913cb7a08bf60b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 79, "methodNumberAfterChange": 82, "signatureBeforeChange": "   public void createConstructor(SymbolData sd)", "signatureAfterChange": "   public void createConstructor(SymbolData sd)", "diff": ["-    ", "-    SymbolData superSd = sd.getSuperClass();", "-    ", "-    //there was an error somewhere else.  just return.", "-    if (sd.isContinuation()) return;", "-    ", "-    LinkedList<MethodData> superMethods = superSd.getMethods();", "-    String superUnqualifiedName = getUnqualifiedClassName(superSd.getName());", "-    ", "-    LanguageLevelVisitor sslv = LanguageLevelConverter._newSDs.remove(superSd);", "-    if (sslv != null) {sslv.createConstructor(superSd);}", "-    ", "-    // Find the super's smallest constructor.", "-    MethodData superConstructor = null;", "-    Iterator<MethodData> iter = superMethods.iterator();", "-    while (iter.hasNext()) {", "-      MethodData superMd = iter.next();", "-      if (superMd.getName().equals(superUnqualifiedName)) {", "-        if (superConstructor == null || superMd.getParams().length < superConstructor.getParams().length) {", "-          superConstructor = superMd;", "-        }", "-      }", "+ ", "+    System.err.println(\"**** createConstructor called for \" + sd);", "+        ", "+//    if (sd == null) {", "+//      System.err.println(\"**** Error **** After fixups, SymbolData \" + sd + \" has null for a super class\");", "+//      assert false;", "+//    }", "+//    ", "+    if (sd.isContinuation()) {", "+      _addError(\"Could not generate constructor for class \" + sd + \" because it has no definition\", ", "+                new NullLiteral(SourceInfo.NO_INFO));", "+      return;", "-    String name = getUnqualifiedClassName(sd.getName());", "-    MethodData md = new MethodData(name,", "-                                   new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}), ", "-                                   new TypeParameter[0], ", "-                                   sd, ", "-                                   new VariableData[0], // Parameters to be filled in later. ", "-                                   new String[0], ", "-                                   sd,", "-                                   null);", "+    SymbolData superSd = sd.getSuperClass();", "+    if (superSd == null) {", "+      _addError(\"Could not generate constructor for class \" + sd + \" because it has no superclass\", ", "+                new NullLiteral(SourceInfo.NO_INFO));", "+      return;", "+    }", "-    LinkedList<VariableData> params = new LinkedList<VariableData>();", "-    if (superConstructor != null) {", "+    else {", "+      LinkedList<MethodData> superMethods = superSd.getMethods();", "+      String superUnqualifiedName = getUnqualifiedClassName(superSd.getName());", "+      ", "+      LanguageLevelVisitor sslv = LanguageLevelConverter._newSDs.remove(superSd);", "+      ", "+      // if sslv == null, the superclass constructor has already been generated or we are caught in a cyclic", "+      // inheritance hierarchy", "+      if (sslv != null) {", "+        sslv.createConstructor(superSd);", "+        System.err.println(\"Creating constructor for superclass \" + superSd);", "+      }", "+      ", "+      // Find the super's smallest constructor.", "+      MethodData superConstructor = null;", "+      for (MethodData superMd: superMethods) {", "+//      Iterator<MethodData> iter = superMethods.iterator();", "+//      while (iter.hasNext()) {", "+//        MethodData superMd = iter.next();", "+        if (superMd.getName().equals(superUnqualifiedName)) {", "+          if (superConstructor == null || superMd.getParams().length < superConstructor.getParams().length) {", "+            superConstructor = superMd;", "+          }", "+        }", "+      }", "+      if (superConstructor == null) {", "+        _addAndIgnoreError(\"Could not generate constructor for class \" + sd + \" superclass has no constructor, perhaps\"", "+                           + \" because the class hierarchy is cyclic.\",", "+                           new NullLiteral(SourceInfo.NO_INFO));", "+        return;", "+      }", "+//      if (superConstructor == null) {", "+//        System.err.println(\"**** Error **** The superclass \" + superSd + \" has no constructors \");", "+//      }", "+      String name = getUnqualifiedClassName(sd.getName());", "+      MethodData md = new MethodData(name,", "+                                     PUBLIC_MAV, ", "+                                     new TypeParameter[0], ", "+                                     sd, ", "+                                     new VariableData[0], // Parameters to be filled in later. ", "+                                     new String[0], ", "+                                     sd,", "+                                     null);", "+      ", "+      LinkedList<VariableData> params = new LinkedList<VariableData>();", "+//      if (superConstructor != null) {", "-        VariableData newParam = ", "-          new VariableData(paramName, new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[0]), ", "-                           superParam.getType().getSymbolData(), true, md);", "+        SymbolData superParamSD = superParam.getType();", "+        assert superParamSD != null;", "+        VariableData newParam = new VariableData(paramName, PACKAGE_MAV, superParamSD, true, sd);  // Note: sd was md", "-        md.addVar(newParam); ", "+        md.addVar(newParam);  // Fixups have already been executed", "-    }", "+//      }", "-    // only add in those fields that do not have a value and are not static.", "-    boolean hasOtherConstructor = sd.hasMethod(name);", "-    ", "-    for (VariableData field : sd.getVars()) {", "+      // only add in those fields that do not have a value and are not static.", "+      boolean hasOtherConstructor = sd.hasMethod(name);", "-      if (! field.hasInitializer() && ! field.hasModifier(\"static\")) {", "-        if (! hasOtherConstructor) { field.gotValue(); } // Set hasValue if no other constructors need to be visited", "-        // Rather than creating a new parameter, we use the field, since all the important data is the same in both of", "-        // them.", "-        params.add(field);", "+      for (VariableData field : sd.getVars()) {", "+        ", "+        if (! field.hasInitializer() && ! field.hasModifier(\"static\")) {", "+          if (! hasOtherConstructor) { field.gotValue(); } // Set hasValue if no other constructors need to be visited", "+          // Rather than creating a new parameter, we use the field, since all the important data is the same in both of", "+          // them.", "+          VariableData param = field.copyWithoutVisibility();", "+          params.add(param);", "+        }", "+      // Some fields may be declared private, but parameters cannot be; unprivatize the ", "+      ", "+      md.setParams(params.toArray(new VariableData[params.size()]));", "+      md.setVars(params);", "+      ", "+      System.err.println(\"**** Adding constructor \" + md + \" **** to symbol \" + sd);", "+//      if (md.getName().equals(\"ClassName\"))", "+//        System.err.println(\"****** constructor visibility = \" + md.getMav());", "+      addGeneratedMethod(sd, md);", "-    md.setParams(params.toArray(new VariableData[params.size()]));", "-    md.setVars(params);", "-    ", "-    addGeneratedMethod(sd, md);"]}], "num": 18747}