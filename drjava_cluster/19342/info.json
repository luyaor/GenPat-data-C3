{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "07856f21187b3cddfe4c9364e34d80d6", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1bc0d330e552170041f7e708de34976a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/SplashScreen.java", "commitBeforeChange": "dd4842ca8ba89600798d5ff08666825edfadfb74", "commitAfterChange": "3e6dcdfe0dc2a3a2b00da441b478134258a2740f", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "   public SplashScreen()", "signatureAfterChange": "   public SplashScreen()", "diff": ["-    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();", "+    //for multi-monitor support", "+    //Question: do we want it to popup on the first monitor always?", "+    GraphicsDevice[] dev = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();", "+    Rectangle rec = dev[0].getDefaultConfiguration().getBounds();", "+    Point ownerLoc = rec.getLocation();", "+    Dimension ownerSize = rec.getSize();", "-    setLocation((screenSize.width - frameSize.width) / 2,", "-                (screenSize.height - frameSize.height) / 2);", "+    setLocation(ownerLoc.x + (ownerSize.width - frameSize.width) / 2,", "+                ownerLoc.y + (ownerSize.height - frameSize.height) / 2);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "96f8cdb245c9f636cbca2d0723d93914", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/AbstractConsoleController.java", "commitBeforeChange": "8468328336764977b1a392d354ad9fa8332d6cf0", "commitAfterChange": "b5065bdb57d50a5108c714db64f9cb4417931362", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "     public void insertUpdate(final DocumentEvent e)", "signatureAfterChange": "     public void insertUpdate(final DocumentEvent e)", "diff": ["-      /* Update caret position when text is inserted at end of document.  Fixes (?) bug #1571405.  The promptPos is", "+      /* Update caret position when text is inserted in the document.  Fixes (?) bug #1571405.  The promptPos is", "+      int insertPos = e.getOffset();", "+      int insertLen = e.getLength();", "-      final int newPos = getNewCaretPos(e, doc);", "+      int promptPos = doc.getPromptPos();", "+      if (EventQueue.isDispatchThread())  { // insert was generated by keyboard input; do not move caret", "+        _cachedCaretPos = insertPos + insertLen;", "+        _cachedPromptPos = promptPos;", "+//        EventQueue.invokeLater(new Runnable() { public void run() { _pane.setCaretPos(insertEnd); } });", "+        return;", "+      }", "+      ", "+      final int newPos = getNewCaretPos(doc, promptPos, insertPos, insertLen);", "-//      System.err.println(\"Setting cached caretpos to \" + newPos);  // uncommented this creates deadlock!", "-      // Update the caret position as part of the insertion if possible (running in event thread)", "-//      if (EventQueue.isDispatchThread()) _pane.setCaretPosition(newPos);", "-//      // Otherwise update it with a length filter in case the document has been shortened (as in resetInteractions)", "-//      else ", "-      EventQueue.invokeLater(new Runnable() { public void run() { _pane.setCaretPos(newPos); } });", "+      _cachedPromptPos = promptPos;", "+//      System.err.println(\"Setting cached caretpos to \" + newPos); ", "+      /* Immediately update the caret position as part of the insertion, ignoring event thread only convention.  As", "+       * soon as the exclusive ReadLock is dropped on exiting this listener, a background thread running in the ", "+       * interpreter could write to the console, which is echoed in the interactions pane.  If the caret position is", "+       * not immediately updated, there could be a race because keyboard input events may already be queued in the", "+       * event queue. */", "+      _pane.setCaretPos(newPos); "]}], "num": 19342}