{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3ca1b03aa655be14abd416d3f979767c", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3845e4b30d19b3fe2df6ae8d5593f485", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "dd97c2983de18f5d46f596ce3c536a3b581f0ec4", "commitAfterChange": "e5b59097570657040bcd74f7a31c6db7f03359ce", "methodNumberBeforeChange": 136, "methodNumberAfterChange": 136, "signatureBeforeChange": "       public void testForSimpleAnonymousClassInstantiation()", "signatureAfterChange": "               public void testForSimpleAnonymousClassInstantiation()", "diff": ["-", "-    public void testForSimpleAnonymousClassInstantiation() {", "-     AnonymousClassInstantiation basic = new SimpleAnonymousClassInstantiation(SourceInfo.NO_INFO, new ClassOrInterfaceType(SourceInfo.NO_INFO, \"Object\", new Type[0]), ", "-                                                                        new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]),", "-                                                                        new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "-     ", "-     SymbolData object = new SymbolData(\"java.lang.Object\");", "-     object.setIsContinuation(false);", "-     object.setPackage(\"java.lang\");", "-     object.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-     MethodData cdObj = ", "-       new MethodData(\"Object\", _publicMav, new TypeParameter[0], object, new VariableData[0], new String[0], object, basic);", "-     object.addMethod(cdObj);", "-", "-     ", "-     symbolTable.put(\"java.lang.Object\", object);", "-     ", "-     /* This erroneous configuration now throws an error message asserting anonymous inner classes cannot be nested in LL. */", "+    ", "+    public void testForSimpleAnonymousClassInstantiation() {", "+      AnonymousClassInstantiation basic = new SimpleAnonymousClassInstantiation(SourceInfo.NO_INFO, new ClassOrInterfaceType(SourceInfo.NO_INFO, \"Object\", new Type[0]), ", "+                                                                                new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]),", "+                                                                                new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "+      ", "+      ", "+      SymbolData object = new SymbolData(\"java.lang.Object\");", "+      object.setIsContinuation(false);", "+      object.setPackage(\"java.lang\");", "+      object.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "+      MethodData cdObj = ", "+        new MethodData(\"Object\", _publicMav, new TypeParameter[0], object, new VariableData[0], new String[0], object, basic);", "+      object.addMethod(cdObj);", "+      ", "+      ", "+      symbolTable.put(\"java.lang.Object\", object);", "+      ", "+      /* This erroneous configuration now throws an error message asserting anonymous inner classes cannot be nested in LL. */", "-     ", "-     _sd1.setAnonymousInnerClassNum(0);", "-     ", "-     //once our enclosing data does have an anonymous inner class, it's okay to look it up", "-     SymbolData anon1 = new SymbolData(\"i.like.monkey$1\");", "-     anon1.setIsContinuation(false);", "-     anon1.setPackage(\"i.like\");", "-     anon1.setMav(_publicMav);", "-     anon1.setOuterData(_sd1);", "-     _sd1.addInnerClass(anon1);", "-     ", "-     assertEquals(\"Should return anon1 instance\", anon1.getInstanceData(), basic.visit(_etc));", "-", "-     assertEquals(\"Should be no errors\", 0, errors.size());", "-     ", "-     ", "-     VariableDeclaration vdecl = new VariableDeclaration(SourceInfo.NO_INFO,", "+      ", "+      _sd1.setAnonymousInnerClassNum(0);", "+      ", "+      //once our enclosing data does have an anonymous inner class, it's okay to look it up", "+      SymbolData anon1 = new SymbolData(\"i.like.monkey$1\");", "+      anon1.setIsContinuation(false);", "+      anon1.setPackage(\"i.like\");", "+      anon1.setMav(_publicMav);", "+      anon1.setOuterData(_sd1);", "+      _sd1.addInnerClass(anon1);", "+      ", "+      assertEquals(\"Should return anon1 instance\", anon1.getInstanceData(), basic.visit(_etc));", "+      ", "+      assertEquals(\"Should be no errors\", 0, errors.size());", "+      ", "+      ", "+      VariableDeclaration vdecl = new VariableDeclaration(SourceInfo.NO_INFO,", "-       new UninitializedVariableDeclarator(SourceInfo.NO_INFO, ", "+        new UninitializedVariableDeclarator(SourceInfo.NO_INFO, ", "-         new UninitializedVariableDeclarator(SourceInfo.NO_INFO, ", "+          new UninitializedVariableDeclarator(SourceInfo.NO_INFO, ", "-           ", "+      ", "-      ", "-      MethodData md = new MethodData(\"myMethod\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE, new VariableData[] {new VariableData(\"j\", _finalMav, SymbolData.INT_TYPE, true, null)}, new String[0], sd, cmd1);", "+      MethodData md = ", "+        new MethodData(\"myMethod\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE, new VariableData[] {", "+        new VariableData(\"j\", _finalMav, SymbolData.INT_TYPE, true, null)}, new String[0], sd, cmd1);", "-      MethodData cd = new MethodData(\"name\", _publicMav, new TypeParameter[0], sd, new VariableData[0], new String[0], sd, cmd1);", "+      MethodData cd = ", "+        new MethodData(\"name\", _publicMav, new TypeParameter[0], sd, new VariableData[0], new String[0], sd, cmd1);", "-      //check that this complicated one still returns correct type: overwriting fields in super class and method in super class", "+      // check that this complex expression returns correct type, overwriting fields and method in super class", "-", "+      ", "-      VariableDeclaration vd = new VariableDeclaration(SourceInfo.NO_INFO, _publicMav, new VariableDeclarator[] { new InitializedVariableDeclarator(SourceInfo.NO_INFO, new ClassOrInterfaceType(SourceInfo.NO_INFO, \"name\", new Type[0]), new Word(SourceInfo.NO_INFO, \"myAnon\"), complicated)});", "+      VariableDeclaration vd =", "+        new VariableDeclaration(SourceInfo.NO_INFO, _publicMav, new VariableDeclarator[] { ", "+        new InitializedVariableDeclarator(SourceInfo.NO_INFO, ", "+                                          new ClassOrInterfaceType(SourceInfo.NO_INFO, \"name\", new Type[0]), ", "+                                          new Word(SourceInfo.NO_INFO, \"myAnon\"), complicated)});", "-      MethodInvocation mie = new ComplexMethodInvocation(SourceInfo.NO_INFO, complicated, new Word(SourceInfo.NO_INFO, \"myMethod\"), new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[] { new IntegerLiteral(SourceInfo.NO_INFO, 5)}));", "+      MethodInvocation mie = ", "+        new ComplexMethodInvocation(SourceInfo.NO_INFO, ", "+                                    complicated, ", "+                                    new Word(SourceInfo.NO_INFO, \"myMethod\"),", "+                                    new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[] { ", "+        new IntegerLiteral(SourceInfo.NO_INFO, 5)}));", "-      sd.addMethod(new MethodData(\"yeah\", _abstractMav, new TypeParameter[0], SymbolData.BOOLEAN_TYPE, new VariableData[0], new String[0], sd, cmd1));", "+      sd.addMethod(new MethodData(\"yeah\", _abstractMav, new TypeParameter[0], SymbolData.BOOLEAN_TYPE, ", "+                                  new VariableData[0], new String[0], sd, cmd1));", "-      assertEquals(\"The error message should be correct\", \"This anonymous inner class must override the abstract method: yeah() in name\", errors.get(0).getFirst());", "+      assertEquals(\"The error message should be correct\", ", "+                   \"This anonymous inner class must override the abstract method: yeah() in name\", ", "+                   errors.get(0).getFirst());", "-     SimpleAnonymousClassInstantiation nestedNonStatic = new SimpleAnonymousClassInstantiation(SourceInfo.NO_INFO, new ClassOrInterfaceType(SourceInfo.NO_INFO, \"A.B\", new Type[0]), ", "-                                                                            new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]), new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "-     ", "-     SymbolData a = new SymbolData(\"A\");", "-     a.setIsContinuation(false);", "-     SymbolData b = new SymbolData(\"A$B\");", "-     b.setIsContinuation(false);", "-     b.setOuterData(a);", "-     a.addInnerClass(b);", "-     MethodData consb = new MethodData(\"B\", _publicMav, new TypeParameter[0], b, ", "-                                       new VariableData[0], ", "-                                       new String[0], ", "-                                       b,", "-                                       null);", "-     b.addMethod(consb);", "-    symbolTable.put(\"A\", a);", "-    a.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-    b.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-    ", "-    SymbolData anon3 = new SymbolData(\"i.like.monkey$3\");", "-    anon3.setIsContinuation(false);", "-    anon3.setMav(_publicMav);", "-    _sd1.addInnerClass(anon3);", "-    anon3.setOuterData(_sd1);", "-", "-    //if inner part is not static, give error", "-    assertEquals(\"Should return anon3\", anon3.getInstanceData(), nestedNonStatic.visit(_etc));", "-    assertEquals(\"Should be 2 errors\", 2, errors.size());", "-    ", "-    assertEquals(\"Error message should be correct\", \"A.B is not a static inner class, and thus cannot be instantiated from this context.  Perhaps you meant to use an instantiation of the form new A().new B()\", errors.getLast().getFirst());", "-", "-    _sd1.setAnonymousInnerClassNum(2);", "-    //if inner part is static, no problem", "-    b.addModifier(\"static\");", "-    assertEquals(\"Should return anon3\", anon3.getInstanceData(), nestedNonStatic.visit(_etc));", "-    assertEquals(\"Should still be just 2 errors\", 2, errors.size());", "-    ", "+      SimpleAnonymousClassInstantiation nestedNonStatic = ", "+        new SimpleAnonymousClassInstantiation(SourceInfo.NO_INFO, ", "+                                              new ClassOrInterfaceType(SourceInfo.NO_INFO, \"A.B\", new Type[0]), ", "+                                              new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]), ", "+                                              new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "+      ", "+      SymbolData a = new SymbolData(\"A\");", "+      a.setIsContinuation(false);", "+      SymbolData b = new SymbolData(\"A$B\");", "+      b.setIsContinuation(false);", "+      b.setOuterData(a);", "+      a.addInnerClass(b);", "+      MethodData consb = new MethodData(\"B\", _publicMav, new TypeParameter[0], b, ", "+                                        new VariableData[0], ", "+                                        new String[0], ", "+                                        b,", "+                                        null);", "+      b.addMethod(consb);", "+      symbolTable.put(\"A\", a);", "+      a.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "+      b.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "+      ", "+      SymbolData anon3 = new SymbolData(\"i.like.monkey$3\");", "+      anon3.setIsContinuation(false);", "+      anon3.setMav(_publicMav);", "+      _sd1.addInnerClass(anon3);", "+      anon3.setOuterData(_sd1);", "+      ", "+      //if inner part is not static, give error", "+      assertEquals(\"Should return anon3\", anon3.getInstanceData(), nestedNonStatic.visit(_etc));", "+      assertEquals(\"Should be 2 errors\", 2, errors.size());", "+      ", "+      assertEquals(\"Error message should be correct\", ", "+                   \"A.B is not a static inner class, and thus cannot be instantiated from this context.  \"", "+                     + \"Perhaps you meant to use an instantiation of the form new A().new B()\",", "+                   errors.getLast().getFirst());", "+      ", "+      _sd1.setAnonymousInnerClassNum(2);", "+      //if inner part is static, no problem", "+      b.addModifier(\"static\");", "+      assertEquals(\"Should return anon3\", anon3.getInstanceData(), nestedNonStatic.visit(_etc));", "+      assertEquals(\"Should still be just 2 errors\", 2, errors.size());", "+      "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f7b12a3340f220fe7f70758dbeaa1e6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "dd97c2983de18f5d46f596ce3c536a3b581f0ec4", "commitAfterChange": "e5b59097570657040bcd74f7a31c6db7f03359ce", "methodNumberBeforeChange": 137, "methodNumberAfterChange": 137, "signatureBeforeChange": "          public void testForComplexAnonymousClassInstantiation()", "signatureAfterChange": "          public void testForComplexAnonymousClassInstantiation()", "diff": ["-     AnonymousClassInstantiation basic = ", "-       new ComplexAnonymousClassInstantiation(SourceInfo.NO_INFO, ", "-                                              new SimpleNameReference(SourceInfo.NO_INFO, ", "-                                                                      new Word(SourceInfo.NO_INFO, \"bob\")),", "-                                              new ClassOrInterfaceType(SourceInfo.NO_INFO, \"Object\", new Type[0]), ", "-                                              new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]),", "-                                              new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "-     ", "-     VariableData bob = new VariableData(\"bob\", _publicMav, _sd2, true, _sd1);", "-     _etc._vars.add(bob);", "-", "-     SymbolData object = new SymbolData(\"java.lang.Object\");", "-     object.setIsContinuation(false);", "-     object.setPackage(\"java.lang\");", "-     object.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-     MethodData cdObj = ", "-       new MethodData(\"Object\", _publicMav, new TypeParameter[0], object, new VariableData[0], new String[0], object, basic);", "-     object.addMethod(cdObj);", "-", "-     _sd2.addInnerClass(object);", "-     object.setOuterData(_sd2);", "- ", "-     /* The code base now interprets the following situation as nesting an anonymous class in an anonymous class and ", "-      * classifies it as a LL syntax error. */", "+      AnonymousClassInstantiation basic = ", "+        new ComplexAnonymousClassInstantiation(SourceInfo.NO_INFO, ", "+                                               new SimpleNameReference(SourceInfo.NO_INFO, ", "+                                                                       new Word(SourceInfo.NO_INFO, \"bob\")),", "+                                               new ClassOrInterfaceType(SourceInfo.NO_INFO, \"Object\", new Type[0]), ", "+                                               new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]),", "+                                               new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "+      ", "+      VariableData bob = new VariableData(\"bob\", _publicMav, _sd2, true, _sd1);", "+      _etc._vars.add(bob);", "+      ", "+      SymbolData object = new SymbolData(\"java.lang.Object\");", "+      object.setIsContinuation(false);", "+      object.setPackage(\"java.lang\");", "+      object.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "+      MethodData cdObj = ", "+        new MethodData(\"Object\", _publicMav, new TypeParameter[0], object, new VariableData[0], new String[0], object, basic);", "+      object.addMethod(cdObj);", "+      ", "+      _sd2.addInnerClass(object);", "+      object.setOuterData(_sd2);", "+      ", "+      /* The code base now interprets the following situation as nesting an anonymous class in an anonymous class and ", "+       * classifies it as a LL syntax error. */", "-//     catch(RuntimeException e) {", "-//       assertEquals(\"Should throw correct exception\", \"Internal Program Error: Couldn't find the SymbolData for the anonymous inner class.  Please report this bug.\", e.getMessage());", "-//     }", "-     ", "-     _sd1.setAnonymousInnerClassNum(0);", "-     ", "-     //once our enclosing data does have an anonymous inner class, it's okay to look it up", "-     SymbolData anon1 = new SymbolData(\"i.like.monkey$1\");", "-     anon1.setIsContinuation(false);", "-     anon1.setPackage(\"i.like\");", "-     anon1.setMav(_publicMav);", "-     anon1.setOuterData(_sd1);", "-     _sd1.addInnerClass(anon1);", "-     ", "-     assertEquals(\"Should return anon1 instance\", anon1.getInstanceData(), basic.visit(_etc));", "-", "-     assertEquals(\"Should be no errors\", 0, errors.size());", "-     ", "-     ", "-     VariableDeclaration vdecl = new VariableDeclaration(SourceInfo.NO_INFO,", "+//      catch(RuntimeException e) {", "+//        assertEquals(\"Should throw correct exception\", ", "+//                     \"Internal Program Error: Couldn't find the SymbolData for the anonymous inner class.  \"", "+//                       + \"Please report this bug.\", ", "+//                     e.getMessage());", "+//      }", "+      ", "+      _sd1.setAnonymousInnerClassNum(0);", "+      ", "+      //once our enclosing data does have an anonymous inner class, it's okay to look it up", "+      SymbolData anon1 = new SymbolData(\"i.like.monkey$1\");", "+      anon1.setIsContinuation(false);", "+      anon1.setPackage(\"i.like\");", "+      anon1.setMav(_publicMav);", "+      anon1.setOuterData(_sd1);", "+      _sd1.addInnerClass(anon1);", "+      ", "+      assertEquals(\"Should return anon1 instance\", anon1.getInstanceData(), basic.visit(_etc));", "+      ", "+      assertEquals(\"Should be no errors\", 0, errors.size());", "+      ", "+      ", "+      VariableDeclaration vdecl = new VariableDeclaration(SourceInfo.NO_INFO,", "-       new UninitializedVariableDeclarator(SourceInfo.NO_INFO, ", "+        new UninitializedVariableDeclarator(SourceInfo.NO_INFO, ", "-         new UninitializedVariableDeclarator(SourceInfo.NO_INFO, ", "+          new UninitializedVariableDeclarator(SourceInfo.NO_INFO, ", "-           ", "-      PrimitiveType intt = new PrimitiveType(SourceInfo.NO_INFO, \"int\");", "-      UninitializedVariableDeclarator uvd = new UninitializedVariableDeclarator(SourceInfo.NO_INFO, intt, new Word(SourceInfo.NO_INFO, \"i\"));", "-      FormalParameter param = new FormalParameter(SourceInfo.NO_INFO, new UninitializedVariableDeclarator(SourceInfo.NO_INFO, intt, new Word(SourceInfo.NO_INFO, \"j\")), false);", "-      BracedBody bb = new BracedBody(SourceInfo.NO_INFO, new BodyItemI[] {new VariableDeclaration(SourceInfo.NO_INFO,  _packageMav, new UninitializedVariableDeclarator[]{uvd}), new ValueReturnStatement(SourceInfo.NO_INFO, new IntegerLiteral(SourceInfo.NO_INFO, 5))});", "-      ConcreteMethodDef cmd1 = new ConcreteMethodDef(SourceInfo.NO_INFO, _publicMav, new TypeParameter[0], ", "-                                                     intt, new Word(SourceInfo.NO_INFO, \"myMethod\"), new FormalParameter[] {param}, ", "-                                                     new ReferenceType[0], bb);", "+      PrimitiveType intt = new PrimitiveType(SourceInfo.NO_INFO, \"int\");", "+      UninitializedVariableDeclarator uvd = ", "+        new UninitializedVariableDeclarator(SourceInfo.NO_INFO, intt, new Word(SourceInfo.NO_INFO, \"i\"));", "+      FormalParameter param = ", "+        new FormalParameter(SourceInfo.NO_INFO, ", "+                            new UninitializedVariableDeclarator(SourceInfo.NO_INFO, intt, ", "+                                                                new Word(SourceInfo.NO_INFO, \"j\")), false);", "+      BracedBody bb = ", "+        new BracedBody(SourceInfo.NO_INFO, new BodyItemI[] {", "+        new VariableDeclaration(SourceInfo.NO_INFO, _packageMav, new UninitializedVariableDeclarator[]{uvd}), ", "+          new ValueReturnStatement(SourceInfo.NO_INFO, new IntegerLiteral(SourceInfo.NO_INFO, 5))});", "+      ", "+      ConcreteMethodDef cmd1 = ", "+        new ConcreteMethodDef(SourceInfo.NO_INFO, _publicMav, new TypeParameter[0], ", "+                              intt, new Word(SourceInfo.NO_INFO, \"myMethod\"), new FormalParameter[] {param}, ", "+                              new ReferenceType[0], bb);", "-      ComplexAnonymousClassInstantiation  complicated = new ComplexAnonymousClassInstantiation(SourceInfo.NO_INFO, ", "-                                                                                               new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"bob\")),", "-                                                                                               new ClassOrInterfaceType(SourceInfo.NO_INFO, \"name\", new Type[0]), ", "-                                                                                               new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]), ", "-                                                                                               classBb);", "+      ComplexAnonymousClassInstantiation  complicated = ", "+        new ComplexAnonymousClassInstantiation(SourceInfo.NO_INFO, ", "+                                               new SimpleNameReference(SourceInfo.NO_INFO, ", "+                                                                       new Word(SourceInfo.NO_INFO, \"bob\")),", "+                                               new ClassOrInterfaceType(SourceInfo.NO_INFO, \"name\", new Type[0]), ", "+                                               new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]), ", "+                                               classBb);", "-      ", "-      MethodData md = new MethodData(\"myMethod\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE, new VariableData[] {new VariableData(\"j\", _finalMav, SymbolData.INT_TYPE, true, null)}, new String[0], sd, cmd1);", "+      MethodData md = ", "+        new MethodData(\"myMethod\", _publicMav, new TypeParameter[0], SymbolData.INT_TYPE, new VariableData[] {", "+        new VariableData(\"j\", _finalMav, SymbolData.INT_TYPE, true, null)}, new String[0], sd, cmd1);", "-      MethodData cd = new MethodData(\"name\", _publicMav, new TypeParameter[0], sd, new VariableData[0], new String[0], sd, cmd1);", "+      MethodData cd = ", "+        new MethodData(\"name\", _publicMav, new TypeParameter[0], sd, new VariableData[0], new String[0], sd, cmd1);", "-      //check that this complicated one still returns correct type: overwriting fields in super class and method in super class", "+      // check that this complex expression returns correct type, overwriting fields in super class and method in ", "+      // super class", "-", "+      ", "-      VariableDeclaration vd = new VariableDeclaration(SourceInfo.NO_INFO, _publicMav, new VariableDeclarator[] { new InitializedVariableDeclarator(SourceInfo.NO_INFO, new ClassOrInterfaceType(SourceInfo.NO_INFO, \"name\", new Type[0]), new Word(SourceInfo.NO_INFO, \"myAnon\"), complicated)});", "+      VariableDeclaration vd = ", "+        new VariableDeclaration(SourceInfo.NO_INFO, _publicMav, new VariableDeclarator[] { ", "+        new InitializedVariableDeclarator(SourceInfo.NO_INFO, ", "+                                          new ClassOrInterfaceType(SourceInfo.NO_INFO, \"name\", new Type[0]),", "+                                          new Word(SourceInfo.NO_INFO, \"myAnon\"), ", "+                                          complicated)});", "-      MethodInvocation mie = new ComplexMethodInvocation(SourceInfo.NO_INFO, complicated, new Word(SourceInfo.NO_INFO, \"myMethod\"), new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[] { new IntegerLiteral(SourceInfo.NO_INFO, 5)}));", "+      MethodInvocation mie = ", "+        new ComplexMethodInvocation(SourceInfo.NO_INFO, complicated, ", "+                                    new Word(SourceInfo.NO_INFO, \"myMethod\"),", "+                                    new ParenthesizedExpressionList(SourceInfo.NO_INFO, ", "+                                                                    new Expression[] { ", "+        new IntegerLiteral(SourceInfo.NO_INFO, 5)}));", "-//      // Now, what if the implemented sd is abstract, and it has an abstract method that our instantiation doesn't override.  Should throw an error.", "+      // If the implemented sd is abstract and it isn't overriden, type-checking should throw an error.", "-      sd.addMethod(new MethodData(\"yeah\", _abstractMav, new TypeParameter[0], SymbolData.BOOLEAN_TYPE, new VariableData[0], new String[0], sd, cmd1));", "+      sd.addMethod(new MethodData(\"yeah\", _abstractMav, new TypeParameter[0], SymbolData.BOOLEAN_TYPE, ", "+                                  new VariableData[0], new String[0], sd, cmd1));", "-      assertEquals(\"The error message should be correct\", \"This anonymous inner class must override the abstract method: yeah() in name\", errors.get(0).getFirst());", "+      assertEquals(\"The error message should be correct\", ", "+                   \"This anonymous inner class must override the abstract method: yeah() in name\", ", "+                   errors.get(0).getFirst());", "-     ComplexAnonymousClassInstantiation nestedNonStatic = new ComplexAnonymousClassInstantiation(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"a\")),", "-                                                                                                 new ClassOrInterfaceType(SourceInfo.NO_INFO, \"B\", new Type[0]), ", "-                                                                            new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]), new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "-     ", "-     SymbolData a = new SymbolData(\"A\");", "-     a.setIsContinuation(false);", "-     SymbolData b = new SymbolData(\"A$B\");", "-     b.setIsContinuation(false);", "-     b.setOuterData(a);", "-     a.addInnerClass(b);", "-     MethodData consb = new MethodData(\"B\", _publicMav, new TypeParameter[0], b, ", "-                                       new VariableData[0], ", "-                                       new String[0], ", "-                                       b,", "-                                       null);", "-     b.addMethod(consb);", "-    symbolTable.put(\"A\", a);", "-    a.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-    b.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-    ", "-    SymbolData anon3 = new SymbolData(\"i.like.monkey$3\");", "-    anon3.setIsContinuation(false);", "-    anon3.setMav(_publicMav);", "-    _sd1.addInnerClass(anon3);", "-    anon3.setOuterData(_sd1);", "-    VariableData aVar = new VariableData(\"a\", _publicMav, a, true, _sd1);", "-    _etc._vars.add(aVar);", "-", "-    //if inner part is not static, no problem", "-    assertEquals(\"Should return anon3\", anon3.getInstanceData(), nestedNonStatic.visit(_etc));", "-    assertEquals(\"Should still be just 1 error\", 1, errors.size());      ", "-    ", "-    //if outer part is private, should break", "-    _sd1.setAnonymousInnerClassNum(2);", "-    a.setMav(_privateMav);", "-    assertEquals(\"Should return anon3\", anon3.getInstanceData(), nestedNonStatic.visit(_etc));", "-    assertEquals(\"Should be 2 errors\", 2, errors.size());", "-    assertEquals(\"Error message should be correct\", \"The class or interface A is private and cannot be accessed from i.like.monkey\", errors.getLast().getFirst());", "-    a.setMav(_publicMav);", "-    ", "-    //if inner part is static, give error", "-    _sd1.setAnonymousInnerClassNum(2);", "-    b.setMav(_publicStaticMav);", "-    assertEquals(\"Should return anon3\", anon3.getInstanceData(), nestedNonStatic.visit(_etc));", "-    assertEquals(\"Should be 3 errors\", 3, errors.size());", "-    assertEquals(\"Error message should be correct\", \"You cannot instantiate a static inner class or interface with this syntax.  Instead, try new A.B()\", errors.getLast().getFirst());", "-", "-    //if inner part is not static, but outer part is type name, give error", "-    ComplexAnonymousClassInstantiation nested = new ComplexAnonymousClassInstantiation(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"A\")),", "-                                                                                                new ClassOrInterfaceType(SourceInfo.NO_INFO, \"B\", new Type[0]), ", "-                                                                                                new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]), new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "-", "-    _sd1.setAnonymousInnerClassNum(2);", "-    b.setMav(_publicMav);", "-    assertEquals(\"Should return anon3\", anon3.getInstanceData(), nested.visit(_etc));", "-    assertEquals(\"Should be 4 errors\", 4, errors.size());", "-    assertEquals(\"Error message should be correct\", \"The constructor of a non-static inner class can only be called on an instance of its containing class (e.g. new A().new B())\", errors.getLast().getFirst());", "-    ", "+      ComplexAnonymousClassInstantiation nestedNonStatic = ", "+        new ComplexAnonymousClassInstantiation(SourceInfo.NO_INFO, ", "+                                               new SimpleNameReference(SourceInfo.NO_INFO, ", "+                                                                       new Word(SourceInfo.NO_INFO, \"a\")),", "+                                               new ClassOrInterfaceType(SourceInfo.NO_INFO, \"B\", new Type[0]), ", "+                                               new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]), ", "+                                               new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "+      ", "+      SymbolData a = new SymbolData(\"A\");", "+      a.setIsContinuation(false);", "+      SymbolData b = new SymbolData(\"A$B\");", "+      b.setIsContinuation(false);", "+      b.setOuterData(a);", "+      a.addInnerClass(b);", "+      MethodData consb = ", "+        new MethodData(\"B\", _publicMav, new TypeParameter[0], b, new VariableData[0], new String[0], b, null);", "+      b.addMethod(consb);", "+      symbolTable.put(\"A\", a);", "+      a.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "+      b.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "+      ", "+      SymbolData anon3 = new SymbolData(\"i.like.monkey$3\");", "+      anon3.setIsContinuation(false);", "+      anon3.setMav(_publicMav);", "+      _sd1.addInnerClass(anon3);", "+      anon3.setOuterData(_sd1);", "+      VariableData aVar = new VariableData(\"a\", _publicMav, a, true, _sd1);", "+      _etc._vars.add(aVar);", "+      ", "+      //if inner part is not static, no problem", "+      assertEquals(\"Should return anon3\", anon3.getInstanceData(), nestedNonStatic.visit(_etc));", "+      assertEquals(\"Should still be just 1 error\", 1, errors.size());      ", "+      ", "+      //if outer part is private, should break", "+      _sd1.setAnonymousInnerClassNum(2);", "+      a.setMav(_privateMav);", "+      assertEquals(\"Should return anon3\", anon3.getInstanceData(), nestedNonStatic.visit(_etc));", "+      assertEquals(\"Should be 2 errors\", 2, errors.size());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"The class or interface A is private and cannot be accessed from i.like.monkey\", ", "+                   errors.getLast().getFirst());", "+      a.setMav(_publicMav);", "+      ", "+      //if inner part is static, give error", "+      _sd1.setAnonymousInnerClassNum(2);", "+      b.setMav(_publicStaticMav);", "+      assertEquals(\"Should return anon3\", anon3.getInstanceData(), nestedNonStatic.visit(_etc));", "+      assertEquals(\"Should be 3 errors\", 3, errors.size());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot instantiate a static inner class or interface with this syntax.  Instead, try new A.B()\", ", "+                   errors.getLast().getFirst());", "+      ", "+      //if inner part is not static, but outer part is type name, give error", "+      ComplexAnonymousClassInstantiation nested = ", "+        new ComplexAnonymousClassInstantiation(SourceInfo.NO_INFO, ", "+                                               new SimpleNameReference(SourceInfo.NO_INFO, ", "+                                                                       new Word(SourceInfo.NO_INFO, \"A\")),", "+                                               new ClassOrInterfaceType(SourceInfo.NO_INFO, \"B\", new Type[0]), ", "+                                               new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]), ", "+                                               new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "+      _sd1.setAnonymousInnerClassNum(2);", "+      b.setMav(_publicMav);", "+      assertEquals(\"Should return anon3\", anon3.getInstanceData(), nested.visit(_etc));", "+      assertEquals(\"Should be 4 errors\", 4, errors.size());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"The constructor of a non-static inner class can only be called on an instance of its \"", "+                     + \"containing class (e.g. new A().new B())\", ", "+                   errors.getLast().getFirst());", "+      "]}], "num": 20700}