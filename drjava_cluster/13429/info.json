{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "331e1b5595f4e6a51cb12e4e1f93c63f", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "45b2b977a43492acb7a4b19cdde690f6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/TypeChecker15.java", "commitBeforeChange": "7f334b2431ad2a57c508d4ce8fe5d18ce3fccebf", "commitAfterChange": "43a2124ad4386a02628eedfc537948ebb05ea232", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "   public Class visit(ForEachStatement node)", "signatureAfterChange": "   public Class visit(ForEachStatement node)", "diff": ["-    /* to be filled in shortly */", "+    // Enter a new scope", "+    context.enterScope();", "+    context.define(node.getVars().get(0), null);", "+    context.define(node.getVars().get(1), null);", "+    ", "+    Class paramTypeClass;", "+    Class collTypeClass;", "-  ", "-        /*examples*/", "-    /*", "-     * Collection<String> c = ... ;", "-     * for(String s: c){", "-     *   ...", "-     * }", "-     * translates to:", "-     * for(Iterator<E> #i = Expression.iterator(); #i.hasNext(); ){", "-     *    FormalParameter = #i.next();", "-     *    statement...", "-     * }", "-     * ", "-     * ", "-     * create a variable name #i", "-     * get the generic type of the collection and create an iterator with the", "-     *   same generic type and give it the name #i", "-     * create an expressio for #i.iterator();", "-     * create an AssignmentExpression for the iterator and the expression.iterator", "-     * create an expression for #i.hasNext();", "-     * create an expression for #i.next();", "-     * create an assignemntExpression for FormalParameter = #i.next();", "-     * create a new for body expression and add the assigment to it's first", "-     * create a new for statement.", "-     * ", "-     * ============================================================================", "-     * ", "-     * Collection c = ... ;", "-     * for(Object o: c){", "-     *   String s = (String) o;", "-     *   ...", "-     * }", "-     * translates to:", "-     * for(Iterator #i = Expression.iterator(); #i.hasNext(); ){", "-     *    FormalParameter = #i.next();", "-     *    statement...", "-     * }", "-     * ", "-     * int sum(int[] a){", "-     *    int sum = 0;", "-     *    for(int i:a){", "-     *      sum+=i;", "-     *    return sum", "-     * }", "-     * translates to:", "-     * for(int #i=0; #i<a.length; #i++){", "-     *   FormalParameter=a[#i];", "-     *   statement...", "-     * }", "-     */", "-return null;", "+    FormalParameter param = node.getParameter();", "+    Expression coll = node.getCollection();", "+    Node body = node.getBody();", "+    Class component;", "+    ", "+    paramTypeClass = param.acceptVisitor(this);", "+    collTypeClass = coll.acceptVisitor(this);", "+    body.acceptVisitor(this);", "+    ", "+    /*for array access */", "+    /* remember to type check potential unbox/box situations */", "+    /* ie, an array of ints -> Integer or array of Integers -> int */", "+    if(collTypeClass.isArray()){", "+      component = collTypeClass.getComponentType();", "+      if(paramTypeClass.isAssignableFrom(component)){", "+        // noop, we typed checked ok.", "+      }else{", "+        // error, the parameter is not the same type as the collection items", "+        throw new ExecutionError(\"collection.type\", node);", "+      }", "+      ", "+    }else if(java.util.Collection.class.isAssignableFrom(collTypeClass)){", "+      // the collection is a Collection.", "+      // we still need to check it's component type", "+      ", "+    }else{", "+      throw new ExecutionError(\"collection.type\", node);", "+    }", "+    ", "+    ", "+    //---------------------------------------------", "+    ", "+    node.getBody().acceptVisitor(this);", "+", "+    // Leave the current scope and store the defined variables", "+    // (a map of String-Class mappings) in the \"variables\" property", "+    node.setProperty(NodeProperties.VARIABLES, context.leaveScope());", "+    ", "+    ", "+  return null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "833178902bb8306812fa80f8d46f5cd7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/TypeChecker.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": "     public Object visit(InnerAllocation node)", "signatureAfterChange": "   public Class visit(InnerAllocation node)", "diff": ["-     */", "-    public Object visit(InnerAllocation node) {", "-        // Visit the expression", "-        Class ec = (Class)node.getExpression().acceptVisitor(this);", "-", "-        // Check the type to declare", "-        Node type = node.getCreationType();", "-        if (type instanceof ReferenceType) {", "-            ReferenceType rt = (ReferenceType)type;", "-            rt.setRepresentation(ec.getName() + \"$\" + rt.getRepresentation());", "-        } else {", "-            throw new ExecutionError(\"allocation.type\", node);", "-        }", "-        Class c = (Class)type.acceptVisitor(this);", "-\tClass dc = InterpreterUtilities.getDeclaringClass(c);", "-", "-        // Do the type checking of the arguments", "-        List args = node.getArguments();", "-        Class[] cargs = null;", "-", "-        if (dc != null && dc.isAssignableFrom(ec)) {", "-            // Adds an argument if the class to build is an innerclass", "-            if (args != null) {", "-                cargs = new Class[args.size() + 1];", "-                ", "-                cargs[0] = ec;", "-                ListIterator it = args.listIterator();", "-                int i  = 1;", "-                while (it.hasNext()) {", "-                    cargs[i++] = (Class)((Node)it.next()).acceptVisitor(this);", "-                }", "-                cargs = new Class[] { ec };", "-        } else {", "-            throw new ExecutionError(\"allocation.type\", node);", "-        Constructor cons = null;", "-        try {", "-            cons = context.lookupConstructor(c, cargs);", "-        } catch (Exception e) {", "-            throw new CatchedExceptionError(e, node);", "-        }", "-        ", "-        // Set the properties of this node", "-        node.setProperty(NodeProperties.TYPE,        c);", "-        node.setProperty(NodeProperties.CONSTRUCTOR, cons);", "-", "-        return c;", "+   */", "+  public Class visit(InnerAllocation node) {", "+    // Visit the expression", "+    Class ec = (Class)node.getExpression().acceptVisitor(this);", "+    ", "+    // Check the type to declare", "+    Node type = node.getCreationType();", "+    if (type instanceof ReferenceType) {", "+      ReferenceType rt = (ReferenceType)type;", "+      rt.setRepresentation(ec.getName() + \"$\" + rt.getRepresentation());", "+    } else {", "+      throw new ExecutionError(\"allocation.type\", node);", "+    }", "+    Class c = (Class)type.acceptVisitor(this);", "+    Class dc = InterpreterUtilities.getDeclaringClass(c);", "+    ", "+    // Do the type checking of the arguments", "+    List args = node.getArguments();", "+    Class[] cargs = null;", "+    ", "+    if (dc != null && dc.isAssignableFrom(ec)) {", "+      // Adds an argument if the class to build is an innerclass", "+      if (args != null) {", "+        cargs = new Class[args.size() + 1];", "+        cargs[0] = ec;", "+        ListIterator it = args.listIterator();", "+        int i  = 1;", "+        while (it.hasNext()) {", "+          cargs[i++] = (Class)((Node)it.next()).acceptVisitor(this);", "+      } else {", "+        cargs = new Class[] { ec };", "+      }", "+    } else {", "+      throw new ExecutionError(\"allocation.type\", node);", "+    Constructor cons = null;", "+    try {", "+      cons = context.lookupConstructor(c, cargs);", "+    } catch (Exception e) {", "+      throw new CatchedExceptionError(e, node);", "+    ", "+    // Set the properties of this node", "+    node.setProperty(NodeProperties.TYPE,        c);", "+    node.setProperty(NodeProperties.CONSTRUCTOR, cons);", "+    ", "+    return c;", "+  }"]}], "num": 13429}