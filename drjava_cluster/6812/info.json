{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "757da1e2ca6ae6c47895529bbc1a7c84", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "69c51e8e8a8f1f0fed7eefb2adaa9bff", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "4ebe3c86a9c7402a414ee21bfa81b87bb3fb5032", "commitAfterChange": "a80c90b8428392cd32bdf80517cd25701896680b", "methodNumberBeforeChange": 113, "methodNumberAfterChange": 113, "signatureBeforeChange": "          public void testForPackageImportStatementOnly()", "signatureAfterChange": "          public void testForPackageImportStatementOnly()", "diff": ["-      Word[] words3 = new Word[] {new Word(JExprParser.NO_SOURCE_INFO, \"myPackage\"), new Word(JExprParser.NO_SOURCE_INFO, \"cookie\")};", "+      Word[] words3 = new Word[] {new Word(JExprParser.NO_SOURCE_INFO, \"myPackage\"), new Word(JExprParser.NO_SOURCE_INFO, ", "+                                                                                              \"cookie\")};", "-      assertTrue(\"Imported Packages should now contain myPackage.cookie\", _llv._importedPackages.contains(\"myPackage.cookie\"));", "+      assertTrue(\"Imported Packages should now contain myPackage.cookie\", ", "+                 _llv._importedPackages.contains(\"myPackage.cookie\"));", "-      assertEquals(\"The error message should be correct\", \"You do not need to import package myPackage. It is your package so all public classes in it are already visible.\", errors.get(0).getFirst());", "+      assertEquals(\"The error message should be correct\", \"You do not need to import package myPackage.\" + ", "+                   \" It is your package so all public classes in it are already visible.\", errors.get(0).getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b931f9b46fc3a70555e6159fd0db7af9", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "4ebe3c86a9c7402a414ee21bfa81b87bb3fb5032", "commitAfterChange": "a80c90b8428392cd32bdf80517cd25701896680b", "methodNumberBeforeChange": 112, "methodNumberAfterChange": 112, "signatureBeforeChange": "          public void testForClassImportStatementOnly()", "signatureAfterChange": "          public void testForClassImportStatementOnly()", "diff": ["-      //Test one that should throw an error: Class has already been imported.", "-      //alpha.beta should now be in the symbolTable, and alpha should be in the list of packages, so this will throw an error", "+      // Test one that should throw an error: Class has already been imported. alpha.beta should now be in the ", "+      // symbolTable, and alpha should be in the list of packages, so this will throw an error", "-      assertEquals(\"The error message should be correct\", \"The class beta has already been imported.\", errors.get(0).getFirst());", "+      assertEquals(\"The error message should be correct\", \"The class beta has already been imported.\", ", "+                   errors.get(0).getFirst());", "-      Word[] words3 = new Word[] {new Word(JExprParser.NO_SOURCE_INFO, \"myPackage\"), new Word(JExprParser.NO_SOURCE_INFO, \"cookie\")};", "+      Word[] words3 = ", "+        new Word[] { new Word(JExprParser.NO_SOURCE_INFO, \"myPackage\"), new Word(JExprParser.NO_SOURCE_INFO, \"cookie\")};", "-      assertEquals(\"The second error message should be correct\", \"You do not need to import myPackage.cookie.  It is in your package so it is already visible\", errors.get(1).getFirst());", "+      assertEquals(\"The second error message should be correct\", \"You do not need to import myPackage.cookie.\" + ", "+                   \"  It is in your package so it is already visible\", errors.get(1).getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ca7307998842744fa44ced57e5525ddf", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/SymbolData.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 112, "methodNumberAfterChange": 112, "signatureBeforeChange": "\r     \r     public void testCheckDifferentReturnTypes()", "signatureAfterChange": "          public void testCheckDifferentReturnTypes()", "diff": ["-    \r", "-    public void testCheckDifferentReturnTypes() {\r", "-      \r", "-      TypeChecker.errors = new LinkedList<Pair<String, JExpressionIF>>();\r", "-      \r", "-      // Create a super class and give it a method.\r", "-      SymbolData superSd = new SymbolData(\"superClass\");\r", "-      MethodData md = new MethodData(\"methodName\",\r", "-                                     _publicMav,\r", "-                                     new TypeParameter[0],\r", "-                                     SymbolData.INT_TYPE,\r", "-                                     new VariableData[0],\r", "-                                     new String[0],\r", "-                                     superSd,\r", "-                                     null);\r", "-      superSd.addMethod(md);\r", "-      _sd.setSuperClass(superSd);\r", "-      // Test with an exact copy of the method.\r", "-      MethodData md2 = new MethodData(\"methodName\",\r", "-                                      _publicMav,\r", "-                                      new TypeParameter[0],\r", "-                                      SymbolData.INT_TYPE,\r", "-                                      new VariableData[0],\r", "-                                      new String[0],\r", "-                                      _sd,\r", "-                                      null);\r", "-      assertFalse(\"There should not be a conflict.\", checkDifferentReturnTypes(md2, _sd, JavaVersion.JAVA_5));\r", "-      assertEquals(\"There should not be an error.\", 0, TypeChecker.errors.size());\r", "-      // Test with an exact copy of the method except for differing return types.\r", "-      MethodData md3 = new MethodData(\"methodName\",\r", "-                                      _publicMav,\r", "-                                      new TypeParameter[0],\r", "-                                      SymbolData.CHAR_TYPE,\r", "-                                      new VariableData[0],\r", "-                                      new String[0],\r", "-                                      _sd,\r", "-                                      null);\r", "-      assertTrue(\"There should be a conflict.\", checkDifferentReturnTypes(md3, _sd, JavaVersion.JAVA_5));\r", "-      assertEquals(\"There should be one error.\", 1, TypeChecker.errors.size());\r", "-      assertEquals(\"The error message should be correct.\", \r", "-                   \"methodName() in i.like.monkey cannot override methodName() in superClass; attempting to use different return types\",\r", "-                   TypeChecker.errors.get(0).getFirst());\r", "-      // Create a super super class and give it a method.\r", "-      SymbolData superSuperSd = new SymbolData(\"superSuperClass\");\r", "-      MethodData md4 = new MethodData(\"superSuperMethodName\",\r", "-                                      _publicMav,\r", "-                                      new TypeParameter[0],\r", "-                                      SymbolData.INT_TYPE,\r", "-                                      new VariableData[] { new VariableData(SymbolData.CHAR_TYPE) },\r", "-                                      new String[0],\r", "-                                      superSuperSd,\r", "-                                      null);\r", "-      md4.getParams()[0].setEnclosingData(md4);\r", "-      superSuperSd.addMethod(md4);\r", "-      superSd.setSuperClass(superSuperSd);\r", "-      // Test with an exact copy except for differing parameters.\r", "-      MethodData md5 = new MethodData(\"superSuperMethodName\",\r", "-                                      _publicMav,\r", "-                                      new TypeParameter[0],\r", "-                                      SymbolData.INT_TYPE,\r", "-                                      new VariableData[0],\r", "-                                      new String[0],\r", "-                                      null,\r", "-                                      null);\r", "-      assertFalse(\"There should not be a conflict.\", checkDifferentReturnTypes(md5, _sd, JavaVersion.JAVA_5));\r", "-      assertEquals(\"There should still be one error.\", 1, TypeChecker.errors.size());\r", "-      // Test with an exact copy except for diffeing return types.\r", "-      MethodData md6 = new MethodData(\"superSuperMethodName\",\r", "-                                      _publicMav,\r", "-                                      new TypeParameter[0],\r", "-                                      SymbolData.BYTE_TYPE,\r", "-                                      new VariableData[] { new VariableData(SymbolData.CHAR_TYPE) },\r", "-                                      new String[0],\r", "-                                      null,\r", "-                                      null);\r", "-      md6.getParams()[0].setEnclosingData(md6);\r", "-      assertTrue(\"There should be a conflict.\", checkDifferentReturnTypes(md6, _sd, JavaVersion.JAVA_5));\r", "-      assertEquals(\"There should be two errors.\", 2, TypeChecker.errors.size());\r", "-      \r", "-      //Test a method that restricts the mav of the super class's method\r", "-      MethodData md7 = new MethodData(\"superSuperMethodName\",\r", "-                                      _privateMav,\r", "-                                      new TypeParameter[0],\r", "-                                      SymbolData.INT_TYPE,\r", "-                                      new VariableData[] { new VariableData(SymbolData.CHAR_TYPE) },\r", "-                                      new String[0],\r", "-                                      new SymbolData(\"myData\"),\r", "-                                      null);\r", "-\r", "-      md7.getParams()[0].setEnclosingData(md7);\r", "-      assertTrue(\"There should be a conflict\", checkDifferentReturnTypes(md7, _sd, JavaVersion.JAVA_5));\r", "-      assertEquals(\"There should be three errors\", 3, TypeChecker.errors.size());\r", "-      assertEquals(\"The error message should be correct\", \"superSuperMethodName in myData cannot override superSuperMethodName in \" + superSuperSd.getName() + \".  You are attempting to assign weaker access priviledges. In \" + superSuperSd.getName() + \", superSuperMethodName was public\", TypeChecker.errors.get(2).getFirst());\r", "-                                      \r", "-      \r", "-      //Test a method that narrows the return type of the super class's method\r", "-      SymbolData stringSd = new SymbolData(\"java.lang.String\");\r", "-      stringSd.setIsContinuation(false);\r", "-      stringSd.setSuperClass(SymbolData.INT_TYPE);\r", "-      \r", "-      MethodData md8 = new MethodData(\"superSuperMethodName\",\r", "-                                      _publicMav,\r", "-                                      new TypeParameter[0],\r", "-                                      stringSd,\r", "-                                      new VariableData[] {new VariableData(SymbolData.CHAR_TYPE)},\r", "-                                      new String[0],\r", "-                                      new SymbolData(\"myData\"),\r", "-                                      null);\r", "-                                      \r", "-      assertFalse(\"There should be no conflict\", checkDifferentReturnTypes(md8, _sd, JavaVersion.JAVA_5));\r", "-      assertEquals(\"There should still be 3 errors\", 3, TypeChecker.errors.size());\r", "-      assertTrue(\"There should be a conflict in 1.4\", checkDifferentReturnTypes(md8, _sd, JavaVersion.JAVA_1_4));\r", "-      assertEquals(\"There should now be 4 errors\", 4, TypeChecker.errors.size());\r", "-      assertEquals(\"The error message should be correct\", TypeChecker.errors.getLast().getFirst(), \"superSuperMethodName(char) in superClass cannot override superSuperMethodName(char) in \" + superSuperSd.getName() + \"; attempting to use different return types\");\r", "-    }\r", "+    ", "+    public void testCheckDifferentReturnTypes() {", "+      ", "+      TypeChecker.errors = new LinkedList<Pair<String, JExpressionIF>>();", "+      ", "+      // Create a super class and give it a method.", "+      SymbolData superSd = new SymbolData(\"superClass\");", "+      MethodData md = new MethodData(\"methodName\",", "+                                     _publicMav,", "+                                     new TypeParameter[0],", "+                                     SymbolData.INT_TYPE,", "+                                     new VariableData[0],", "+                                     new String[0],", "+                                     superSd,", "+                                     null);", "+      superSd.addMethod(md);", "+      _sd.setSuperClass(superSd);", "+      // Test with an exact copy of the method.", "+      MethodData md2 = new MethodData(\"methodName\",", "+                                      _publicMav,", "+                                      new TypeParameter[0],", "+                                      SymbolData.INT_TYPE,", "+                                      new VariableData[0],", "+                                      new String[0],", "+                                      _sd,", "+                                      null);", "+      assertFalse(\"There should not be a conflict.\", checkDifferentReturnTypes(md2, _sd, JavaVersion.JAVA_5));", "+      assertEquals(\"There should not be an error.\", 0, TypeChecker.errors.size());", "+      // Test with an exact copy of the method except for differing return types.", "+      MethodData md3 = new MethodData(\"methodName\",", "+                                      _publicMav,", "+                                      new TypeParameter[0],", "+                                      SymbolData.CHAR_TYPE,", "+                                      new VariableData[0],", "+                                      new String[0],", "+                                      _sd,", "+                                      null);", "+      assertTrue(\"There should be a conflict.\", checkDifferentReturnTypes(md3, _sd, JavaVersion.JAVA_5));", "+      assertEquals(\"There should be one error.\", 1, TypeChecker.errors.size());", "+      assertEquals(\"The error message should be correct.\", ", "+                   \"methodName() in i.like.monkey cannot override methodName() in superClass;\" + ", "+                   \" attempting to use different return types\",", "+                   TypeChecker.errors.get(0).getFirst());", "+      // Create a super super class and give it a method.", "+      SymbolData superSuperSd = new SymbolData(\"superSuperClass\");", "+      MethodData md4 = new MethodData(\"superSuperMethodName\",", "+                                      _publicMav,", "+                                      new TypeParameter[0],", "+                                      SymbolData.INT_TYPE,", "+                                      new VariableData[] { new VariableData(SymbolData.CHAR_TYPE) },", "+                                      new String[0],", "+                                      superSuperSd,", "+                                      null);", "+      md4.getParams()[0].setEnclosingData(md4);", "+      superSuperSd.addMethod(md4);", "+      superSd.setSuperClass(superSuperSd);", "+      // Test with an exact copy except for differing parameters.", "+      MethodData md5 = new MethodData(\"superSuperMethodName\",", "+                                      _publicMav,", "+                                      new TypeParameter[0],", "+                                      SymbolData.INT_TYPE,", "+                                      new VariableData[0],", "+                                      new String[0],", "+                                      null,", "+                                      null);", "+      assertFalse(\"There should not be a conflict.\", checkDifferentReturnTypes(md5, _sd, JavaVersion.JAVA_5));", "+      assertEquals(\"There should still be one error.\", 1, TypeChecker.errors.size());", "+      // Test with an exact copy except for diffeing return types.", "+      MethodData md6 = new MethodData(\"superSuperMethodName\",", "+                                      _publicMav,", "+                                      new TypeParameter[0],", "+                                      SymbolData.BYTE_TYPE,", "+                                      new VariableData[] { new VariableData(SymbolData.CHAR_TYPE) },", "+                                      new String[0],", "+                                      null,", "+                                      null);", "+      md6.getParams()[0].setEnclosingData(md6);", "+      assertTrue(\"There should be a conflict.\", checkDifferentReturnTypes(md6, _sd, JavaVersion.JAVA_5));", "+      assertEquals(\"There should be two errors.\", 2, TypeChecker.errors.size());", "+      ", "+      //Test a method that restricts the mav of the super class's method", "+      MethodData md7 = new MethodData(\"superSuperMethodName\",", "+                                      _privateMav,", "+                                      new TypeParameter[0],", "+                                      SymbolData.INT_TYPE,", "+                                      new VariableData[] { new VariableData(SymbolData.CHAR_TYPE) },", "+                                      new String[0],", "+                                      new SymbolData(\"myData\"),", "+                                      null);", "+", "+      md7.getParams()[0].setEnclosingData(md7);", "+      assertTrue(\"There should be a conflict\", checkDifferentReturnTypes(md7, _sd, JavaVersion.JAVA_5));", "+      assertEquals(\"There should be three errors\", 3, TypeChecker.errors.size());", "+      assertEquals(\"The error message should be correct\", ", "+                   \"superSuperMethodName in myData cannot override superSuperMethodName in \" + superSuperSd.getName() + ", "+                   \".  You are attempting to assign weaker access priviledges. In \" + superSuperSd.getName() + ", "+                   \", superSuperMethodName was public\", TypeChecker.errors.get(2).getFirst());", "+                                      ", "+      ", "+      //Test a method that narrows the return type of the super class's method", "+      SymbolData stringSd = new SymbolData(\"java.lang.String\");", "+      stringSd.setIsContinuation(false);", "+      stringSd.setSuperClass(SymbolData.INT_TYPE);", "+      ", "+      MethodData md8 = new MethodData(\"superSuperMethodName\",", "+                                      _publicMav,", "+                                      new TypeParameter[0],", "+                                      stringSd,", "+                                      new VariableData[] {new VariableData(SymbolData.CHAR_TYPE)},", "+                                      new String[0],", "+                                      new SymbolData(\"myData\"),", "+                                      null);", "+                                      ", "+      assertFalse(\"There should be no conflict\", checkDifferentReturnTypes(md8, _sd, JavaVersion.JAVA_5));", "+      assertEquals(\"There should still be 3 errors\", 3, TypeChecker.errors.size());", "+      assertTrue(\"There should be a conflict in 1.4\", checkDifferentReturnTypes(md8, _sd, JavaVersion.JAVA_1_4));", "+      assertEquals(\"There should now be 4 errors\", 4, TypeChecker.errors.size());", "+      assertEquals(\"The error message should be correct\", TypeChecker.errors.getLast().getFirst(), ", "+                   \"superSuperMethodName(char) in superClass cannot override superSuperMethodName(char) in \" + ", "+                   superSuperSd.getName() + \"; attempting to use different return types\");", "+    }"]}], "num": 6812}