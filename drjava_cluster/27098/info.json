{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "eeeafd009b88f609b1c0bd9740cb6970", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "18163c8b201b8ddccb50ee3d16eac2b3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 127, "methodNumberAfterChange": 127, "signatureBeforeChange": "               public void testForParenthesizedOnly()", "signatureAfterChange": "               public void testForParenthesizedOnly()", "diff": ["-      Parenthesized p = new Parenthesized(SourceInfo.NO_INFO, new NullLiteral(SourceInfo.NO_INFO));", "+      Parenthesized p = new Parenthesized(SourceInfo.NONE, NULL_LITERAL);", "-      //if value_result is an intance data, no problems", "-      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), _etc.forParenthesizedOnly(p, SymbolData.BOOLEAN_TYPE.getInstanceData()));", "+      // if valueRes is an intance data, no problems", "+      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), ", "+                   _etc.forParenthesizedOnly(p, SymbolData.BOOLEAN_TYPE.getInstanceData()));", "-      //if value_result null, just return null", "+      // if valueRes null, just return null", "-      //if value_result is package data, add error", "+      // if valueRes is package data, add error", "-      ", "-      ", "-      //if value result not instance type, give error", "-      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), _etc.forParenthesizedOnly(p, SymbolData.INT_TYPE));", "+", "+      // if value result not instance type, give error", "+      assertEquals(\"Should return int instance\", SymbolData.INT_TYPE.getInstanceData(), ", "+                   _etc.forParenthesizedOnly(p, SymbolData.INT_TYPE));", "-      assertEquals(\"Error message should be correct\",\"This class or interface name cannot appear in parentheses.  Perhaps you meant to create a new instance of int\" , errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\",", "+                   \"This class or interface name cannot appear in parentheses.  Perhaps you meant to create a new \"", "+                     + \"instance of int\" , ", "+                   errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ddca4202b51b9ac107a84cd2df43e8b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 113, "methodNumberAfterChange": 113, "signatureBeforeChange": "            public void testForInstanceOfExpressionOnly()", "signatureAfterChange": "            public void testForInstanceOfExpressionOnly()", "diff": ["-      InstanceofExpression ioe = new InstanceofExpression(SourceInfo.NO_INFO,          ", "-                                                          new NullLiteral(SourceInfo.NO_INFO),", "-                                                          JExprParser.NO_TYPE);  // Object type", "-      ", "-      assertEquals(\"When value_result is subtype of type_result, return BOOLEAN type_result.\", sd2.getInstanceData(), ", "+      InstanceofExpression ioe = new InstanceofExpression(SourceInfo.NONE, NULL_LITERAL, JExprParser.NO_TYPE);", "+      assertEquals(\"When valueRes is subtype of typeRes, return BOOLEAN typeRes.\", sd2.getInstanceData(), ", "-      assertEquals(\"When type_result is subtype of value_result, return BOOLEAN type_result.\", sd2.getInstanceData(), ", "+      assertEquals(\"When typeRes is subtype of valueRes, return BOOLEAN typeRes.\", sd2.getInstanceData(), ", "-      assertEquals(\"When type_result and value_result are not subtypes of each other, return BOOLEAN type_result\", ", "+      assertEquals(\"When typeRes and valueRes are not subtypes of each other, return BOOLEAN typeRes\", ", "-      assertEquals(\"When value_result is a SymbolData, return BOOLEAN type_result\",  sd2.getInstanceData(), ", "+      assertEquals(\"When valueRes is a SymbolData, return BOOLEAN typeRes\",  sd2.getInstanceData(), "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f212924f35a27a82c7b99d699edf3ac", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 111, "methodNumberAfterChange": 111, "signatureBeforeChange": "               public void testForNotExpressionOnly()", "signatureAfterChange": "               public void testForNotExpressionOnly()", "diff": ["-      NotExpression ne = new NotExpression(SourceInfo.NO_INFO, new NullLiteral(SourceInfo.NO_INFO));", "+      NotExpression ne = new NotExpression(SourceInfo.NONE, NULL_LITERAL);", "-      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), _etc.forNotExpressionOnly(ne, SymbolData.BOOLEAN_TYPE.getInstanceData()));", "+      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), ", "+                   _etc.forNotExpressionOnly(ne, SymbolData.BOOLEAN_TYPE.getInstanceData()));", "-      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), _etc.forNotExpressionOnly(ne, SymbolData.BOOLEAN_TYPE));", "+      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), ", "+                   _etc.forNotExpressionOnly(ne, SymbolData.BOOLEAN_TYPE));", "-      assertEquals(\"Error message should be correct\",\"You cannot use the not (!) operator with boolean, because it is a class name, not an instance.  Perhaps you meant to create a new instance of boolean\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\",", "+                   \"You cannot use the not (!) operator with boolean, because it is a class name, not an instance.  \"", "+                     + \"Perhaps you meant to create a new instance of boolean\", errors.getLast().getFirst());", "-      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), _etc.forNotExpressionOnly(ne, SymbolData.INT_TYPE.getInstanceData()));", "+      assertEquals(\"Should return boolean instance\", SymbolData.BOOLEAN_TYPE.getInstanceData(), ", "+                   _etc.forNotExpressionOnly(ne, SymbolData.INT_TYPE.getInstanceData()));", "-      assertEquals(\"Error message should be correct\", \"You cannot use the not (!) operator with something of type int. Instead, it should be used with an expression of boolean type\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot use the not (!) operator with something of type int. Instead, it should be used \"", "+                     + \"with an expression of boolean type\", errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd89af75c1f6ed3d30607eb90e780e0b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 85, "methodNumberAfterChange": 85, "signatureBeforeChange": "          public void testForCastExpressionOnly()", "signatureAfterChange": "          public void testForCastExpressionOnly()", "diff": ["-      CastExpression cd = new CastExpression(SourceInfo.NO_INFO, ", "-                                             JExprParser.NO_TYPE, ", "-                                             new NullLiteral(SourceInfo.NO_INFO));", "-      ", "-      assertEquals(\"When value_result is subtype of type_result, return type_result.\", sd1.getInstanceData(), ", "+      CastExpression cd = new CastExpression(SourceInfo.NONE, JExprParser.NO_TYPE, NULL_LITERAL);", "+      assertEquals(\"When valueRes is subtype of typeRes, return typeRes.\", sd1.getInstanceData(), ", "-      assertEquals(\"When type_result is subtype of value_result, return type_result.\", sd3.getInstanceData(), ", "+      assertEquals(\"When typeRes is subtype of valueRes, return typeRes.\", sd3.getInstanceData(), ", "-      assertEquals(\"When type_result and value_result are not subtypes of each other, return type_result\", ", "+      assertEquals(\"When typeRes and valueRes are not subtypes of each other, return typeRes\", ", "-      assertEquals(\"When value_result is a SymbolData, return type_result\", fooMama.getInstanceData(), ", "+      assertEquals(\"When valueRes is a SymbolData, return typeRes\", fooMama.getInstanceData(), "]}], "num": 27098}