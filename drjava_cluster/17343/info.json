{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "969f0dd489ccdb64bbd3c0fbb751eb53", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "18657faf68e4629ce0d9da836d6dd6fd", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 30, "signatureBeforeChange": "   @Override public Type visit(AnonymousAllocation node)", "signatureAfterChange": "     @Override public Type visit(AnonymousAllocation node)", "diff": ["-   */", "-  @Override public Type visit(AnonymousAllocation node) {", "-    Type t = node.getCreationType().acceptVisitor(this);", "-    // TODO: Allow a simple allocation of a dynamic inner class defined in the current context (as above)", "-    if (!ts.isStatic(t) || (!ts.isExtendable(t) && !ts.isImplementable(t))) {", "-      throw new ExecutionError(\"allocation.type\", node);", "-    }", "-    ", "-    Iterable<? extends Expression> args = IterUtil.empty();", "-    if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "-    ", "-    Iterable<Type> targs = IterUtil.empty();", "-    if (node instanceof PolymorphicAnonymousAllocation) {", "-      targs = checkTypeNameList(((PolymorphicAnonymousAllocation) node).getTypeArguments());", "-    }", "-    ", "-    if (!(IterUtil.isEmpty(args) && IterUtil.isEmpty(targs) && ts.isImplementable(t))) {", "-      // Super constructor invocation is something besides Object()", "-      try {", "-        TypeSystem.ConstructorInvocation inv = ts.lookupConstructor(t, targs, args);", "-        // TODO: Check accessibility of constructor", "-        setErrorStrings(node, ts.userRepresentation(t), nodeTypesString(args));", "-        throw new ExecutionError(\"no.such.constructor\", node);", "-", "-    TreeClass c = new TreeClass(context.makeAnonymousClassName(), null, node,", "-                                new TreeClassLoader(context.getClassLoader(), opt), opt);", "-    setDJClass(node, c);", "-    new ClassMemberChecker(new ClassContext(context, c), opt).checkMembers(node.getMembers());", "-    setConstructor(node, IterUtil.first(c.declaredConstructors()));", "-    return setType(node, ts.makeClassType(c));", "-  }", "+     */", "+    @Override public Type visit(AnonymousAllocation node) {", "+      Type t = checkTypeName(node.getCreationType());", "+      // TODO: Allow a simple allocation of a dynamic inner class defined in the current context (as above)", "+      if (!ts.isStatic(t) || (!ts.isExtendable(t) && !ts.isImplementable(t))) {", "+      if (node instanceof PolymorphicAnonymousAllocation) {", "+        targs = checkTypeNameList(((PolymorphicAnonymousAllocation) node).getTypeArguments());", "+      }", "+      ", "+      if (!(IterUtil.isEmpty(args) && IterUtil.isEmpty(targs) && ts.isImplementable(t))) {", "+        // Super constructor invocation is something besides Object()", "+        try {", "+          ConstructorInvocation inv = ts.lookupConstructor(t, targs, args, expected);", "+          // TODO: Check accessibility of constructor", "+          checkThrownExceptions(inv.thrown(), node);", "+          node.setArguments(CollectUtil.makeList(inv.args()));", "+        }", "+        catch (InvalidTypeArgumentException e) {", "+          throw new ExecutionError(\"type.argument\", node);", "+        }", "+        catch (TypeSystemException e) {", "+          setErrorStrings(node, ts.userRepresentation(t), nodeTypesString(args));", "+          throw new ExecutionError(\"no.such.constructor\", node);", "+        }", "+      }", "+      ", "+      TreeClass c = new TreeClass(context.makeAnonymousClassName(), null, node,", "+                                  new TreeClassLoader(context.getClassLoader(), opt), opt);", "+      setDJClass(node, c);", "+      new ClassMemberChecker(new ClassContext(context, c), opt).checkMembers(node.getMembers());", "+      ", "+      setConstructor(node, IterUtil.first(c.declaredConstructors()));", "+      return setType(node, ts.makeClassType(c));", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9a2dc97864e7388d0070fb650c392309", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/newjvm/InterpreterJVM.java", "commitBeforeChange": "68fac9302e6b2358c3b67dbd6346f2e01189b049", "commitAfterChange": "844c5b5a76f593d88002386f7e1c5749ae206027", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 34, "signatureBeforeChange": "   public void addInterpreter(String name, Object thisVal, Class<?> thisClass, Object[] localVars,                              String[] localVarNames, Class<?>[] localVarClasses)", "signatureAfterChange": "   public void addInterpreter(String name, Object thisVal, Class<?> thisClass, Object[] localVars,                              String[] localVarNames, Class<?>[] localVarClasses)", "diff": ["-    debug.logValues(new String[]{ \"name\", \"thisVal\", \"thisClass\", \"localVars\", \"localVarNames\",", "-      \"localVarClasses\" }, name, thisVal, thisClass, localVars, localVarNames, localVarClasses);", "-    if (_interpreters.containsKey(name)) {", "-      throw new IllegalArgumentException(\"'\" + name + \"' is not a unique interpreter name\");", "-    }", "-    if (localVars.length != localVarNames.length || localVars.length != localVarClasses.length) {", "-      throw new IllegalArgumentException(\"Local variable arrays are inconsistent\");", "-    }", "-    ", "-    // TODO: handle inner classes", "-    // TODO: enforce final vars?", "-    Package pkg = thisClass.getPackage();", "-    DJClass c = SymbolUtil.wrapClass(thisClass);", "-    List<LocalVariable> vars = new LinkedList<LocalVariable>();", "-    for (int i = 0; i < localVars.length; i++) {", "-      if (localVarClasses[i] == null) {", "-        try { localVarClasses[i] = (Class<?>) localVars[i].getClass().getField(\"TYPE\").get(null); }", "-        catch (IllegalAccessException e) { throw new IllegalArgumentException(e); }", "-        catch (NoSuchFieldException e) { throw new IllegalArgumentException(e); }", "+    synchronized(_stateLock) {", "+      debug.logValues(new String[]{ \"name\", \"thisVal\", \"thisClass\", \"localVars\", \"localVarNames\",", "+        \"localVarClasses\" }, name, thisVal, thisClass, localVars, localVarNames, localVarClasses);", "+      if (isInterpreterName(name)) {", "+        throw new IllegalArgumentException(\"'\" + name + \"' is not a unique interpreter name\");", "-      Type varT = SymbolUtil.typeOfGeneralClass(localVarClasses[i], _interpreterOptions.typeSystem());", "-      vars.add(new LocalVariable(localVarNames[i], varT, false));", "+      if (localVars.length != localVarNames.length || localVars.length != localVarClasses.length) {", "+        throw new IllegalArgumentException(\"Local variable arrays are inconsistent\");", "+      }", "+      ", "+      // TODO: handle inner classes", "+      // TODO: enforce final vars?", "+      Package pkg = thisClass.getPackage();", "+      DJClass c = SymbolUtil.wrapClass(thisClass);", "+      List<LocalVariable> vars = new LinkedList<LocalVariable>();", "+      for (int i = 0; i < localVars.length; i++) {", "+        if (localVarClasses[i] == null) {", "+          try { localVarClasses[i] = (Class<?>) localVars[i].getClass().getField(\"TYPE\").get(null); }", "+          catch (IllegalAccessException e) { throw new IllegalArgumentException(e); }", "+          catch (NoSuchFieldException e) { throw new IllegalArgumentException(e); }", "+        }", "+        Type varT = SymbolUtil.typeOfGeneralClass(localVarClasses[i], _interpreterOptions.typeSystem());", "+        vars.add(new LocalVariable(localVarNames[i], varT, false));", "+      }", "+      ", "+      TypeContext ctx = new ImportContext(_interpreterLoader, _interpreterOptions);", "+      if (pkg != null) { ctx = ctx.setPackage(pkg.getName()); }", "+      ctx = new ClassSignatureContext(ctx, c, _interpreterLoader);", "+      ctx = new ClassContext(ctx, c);", "+      ctx = new DebugMethodContext(ctx, thisVal == null);", "+      ctx = new LocalContext(ctx, vars);", "+      ", "+      RuntimeBindings bindings = RuntimeBindings.EMPTY;", "+      if (thisVal != null) { bindings = new RuntimeBindings(bindings, c, thisVal); }", "+      bindings = new RuntimeBindings(bindings, vars, IterUtil.asIterable(localVars));", "+      ", "+      Interpreter i = new Interpreter(_interpreterOptions, ctx, bindings);", "+//      _environments.put(name, Pair.make(ctx, bindings));", "+      putInterpreter(name, i);", "-    ", "-    TypeContext ctx = new ImportContext(_interpreterLoader, _interpreterOptions);", "-    if (pkg != null) { ctx = ctx.setPackage(pkg.getName()); }", "-    ctx = new ClassSignatureContext(ctx, c, _interpreterLoader);", "-    ctx = new ClassContext(ctx, c);", "-    ctx = new DebugMethodContext(ctx, thisVal == null);", "-    ctx = new LocalContext(ctx, vars);", "-    ", "-    RuntimeBindings bindings = RuntimeBindings.EMPTY;", "-    if (thisVal != null) { bindings = new RuntimeBindings(bindings, c, thisVal); }", "-    bindings = new RuntimeBindings(bindings, vars, IterUtil.asIterable(localVars));", "-    ", "-    Interpreter i = new Interpreter(_interpreterOptions, ctx, bindings);", "-    _environments.put(name, Pair.make(ctx, bindings));", "-    _interpreters.put(name, i);"]}], "num": 17343}