{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "99485ab601aabdc94324b60bec6f2b48", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "41c318f2caf5474b04f757419201ec9f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r   private static MethodData _selectTheMostSpecificMethod(List<MethodData> list, InstanceData[] arguments, JExpression jexpr)", "signatureAfterChange": "   private static MethodData _selectTheMostSpecificMethod(List<MethodData> list, InstanceData[] arguments, JExpression jexpr)", "diff": ["-   */\r", "-  private static MethodData _selectTheMostSpecificMethod(List<MethodData> list, InstanceData[] arguments, JExpression jexpr) {\r", "-    if (list.isEmpty()) return null;\r", "-    Iterator<MethodData> it = list.iterator();\r", "-    MethodData best = it.next();\r", "-    MethodData ambiguous = null; // there is no ambiguous other method at first\r", "-    while (it.hasNext()) {\r", "-      MethodData curr = it.next();\r", "-      SymbolData[] bestParams = new SymbolData[best.getParams().length];\r", "-      SymbolData[] currParams = new SymbolData[curr.getParams().length];\r", "-      \r", "-      boolean better1 = false; // whether 'best' is better than 'curr'\r", "-      boolean better2 = false; // whether 'curr' is better than 'best'\r", "-      for (int i = 0; i < bestParams.length; i++) {\r", "-        SymbolData bp = best.getParams()[i].getType().getSymbolData();\r", "-        SymbolData cp = curr.getParams()[i].getType().getSymbolData();\r", "-        boolean fromCurrToBest = cp.isAssignableTo(bp, _targetVersion);\r", "-        boolean fromBestToCurr = bp.isAssignableTo(cp, _targetVersion);\r", "-        bestParams[i] = bp;\r", "-        currParams[i] = cp;\r", "-                  \r", "-        if (fromBestToCurr && !fromCurrToBest) {// best's parameter[i] is more specific than curr's\r", "-          better1 = true; // so best is better than curr\r", "-        }\r", "-        if (fromCurrToBest && !fromBestToCurr) {// curr's parameter[i] is more specific than best's\r", "-          better2 = true; // so curr is better than best\r", "-        }\r", "-      }\r", "-      \r", "-      // decide which is more specific or whether they are ambiguous\r", "-      if (better1 == better2) { // neither is better than the other\r", "-        // Handle overridden methods\r", "-        if (Arrays.equals(bestParams, currParams)) {\r", "-          SymbolData c1 = best.getSymbolData();\r", "-          SymbolData c2 = curr.getSymbolData();\r", "-          boolean c1IsSuperOrSame = c2.isAssignableTo(c1, _targetVersion);\r", "-          boolean c2IsSuperOrSame = c1.isAssignableTo(c2, _targetVersion);\r", "-          if (c1IsSuperOrSame && !c2IsSuperOrSame) { // c2 is more specific\r", "-            best = curr;\r", "-            continue;\r", "-          }\r", "-          else if (c2IsSuperOrSame && !c1IsSuperOrSame) { // c1 is more specific\r", "-            continue;\r", "-          }\r", "-        }\r", "-        ambiguous = curr;\r", "-      }\r", "-      else if (better2) {\r", "-        best = curr;\r", "-        ambiguous = null; // no more ambiguity\r", "-      }\r", "-    }\r", "-    if (ambiguous != null) {\r", "-      StringBuffer invokeArgs = new StringBuffer(\"(\");\r", "-      StringBuffer ambigArgs = new StringBuffer(\"(\");\r", "-      StringBuffer bestArgs = new StringBuffer(\"(\");\r", "-      for (int i = 0; i<arguments.length; i++) {\r", "-        if (i>0) {\r", "-          invokeArgs.append(\", \");\r", "-          ambigArgs.append(\", \");\r", "-          bestArgs.append(\", \");\r", "-        }\r", "-        invokeArgs.append(arguments[i].getSymbolData().getName());\r", "-        ambigArgs.append(ambiguous.getParams()[i].getType().getSymbolData().getName());\r", "-        bestArgs.append(best.getParams()[i].getType().getSymbolData().getName());\r", "-      }\r", "-      invokeArgs.append(\")\");\r", "-      ambigArgs.append(\")\");\r", "-      bestArgs.append(\")\");\r", "-      _addError(best.getName() + invokeArgs.toString() + \" is an ambiguous invocation.  It matches both \" + best.getName() + bestArgs.toString() + \" and \" + ambiguous.getName() + ambigArgs.toString(), jexpr);\r", "-    }\r", "-    return best;\r", "-  }\r", "+   */", "+  private static MethodData _selectTheMostSpecificMethod(List<MethodData> list, InstanceData[] arguments, JExpression jexpr) {", "+    if (list.isEmpty()) return null;", "+    Iterator<MethodData> it = list.iterator();", "+    MethodData best = it.next();", "+    MethodData ambiguous = null; // there is no ambiguous other method at first", "+    while (it.hasNext()) {", "+      MethodData curr = it.next();", "+      SymbolData[] bestParams = new SymbolData[best.getParams().length];", "+      SymbolData[] currParams = new SymbolData[curr.getParams().length];", "+      ", "+      boolean better1 = false; // whether 'best' is better than 'curr'", "+      boolean better2 = false; // whether 'curr' is better than 'best'", "+      for (int i = 0; i < bestParams.length; i++) {", "+        SymbolData bp = best.getParams()[i].getType().getSymbolData();", "+        SymbolData cp = curr.getParams()[i].getType().getSymbolData();", "+        boolean fromCurrToBest = cp.isAssignableTo(bp, LanguageLevelConverter.OPT.javaVersion());", "+        boolean fromBestToCurr = bp.isAssignableTo(cp, LanguageLevelConverter.OPT.javaVersion());", "+        bestParams[i] = bp;", "+        currParams[i] = cp;", "+                  ", "+        if (fromBestToCurr && !fromCurrToBest) {// best's parameter[i] is more specific than curr's", "+          better1 = true; // so best is better than curr", "+        }", "+        if (fromCurrToBest && !fromBestToCurr) {// curr's parameter[i] is more specific than best's", "+          better2 = true; // so curr is better than best", "+        }", "+      }", "+      ", "+      // decide which is more specific or whether they are ambiguous", "+      if (better1 == better2) { // neither is better than the other", "+        // Handle overridden methods", "+        if (Arrays.equals(bestParams, currParams)) {", "+          SymbolData c1 = best.getSymbolData();", "+          SymbolData c2 = curr.getSymbolData();", "+          boolean c1IsSuperOrSame = c2.isAssignableTo(c1, LanguageLevelConverter.OPT.javaVersion());", "+          boolean c2IsSuperOrSame = c1.isAssignableTo(c2, LanguageLevelConverter.OPT.javaVersion());", "+          if (c1IsSuperOrSame && !c2IsSuperOrSame) { // c2 is more specific", "+            best = curr;", "+            continue;", "+          }", "+          else if (c2IsSuperOrSame && !c1IsSuperOrSame) { // c1 is more specific", "+            continue;", "+          }", "+        }", "+        ambiguous = curr;", "+      }", "+      else if (better2) {", "+        best = curr;", "+        ambiguous = null; // no more ambiguity", "+      }", "+    }", "+    if (ambiguous != null) {", "+      StringBuffer invokeArgs = new StringBuffer(\"(\");", "+      StringBuffer ambigArgs = new StringBuffer(\"(\");", "+      StringBuffer bestArgs = new StringBuffer(\"(\");", "+      for (int i = 0; i<arguments.length; i++) {", "+        if (i>0) {", "+          invokeArgs.append(\", \");", "+          ambigArgs.append(\", \");", "+          bestArgs.append(\", \");", "+        }", "+        invokeArgs.append(arguments[i].getSymbolData().getName());", "+        ambigArgs.append(ambiguous.getParams()[i].getType().getSymbolData().getName());", "+        bestArgs.append(best.getParams()[i].getType().getSymbolData().getName());", "+      }", "+      invokeArgs.append(\")\");", "+      ambigArgs.append(\")\");", "+      bestArgs.append(\")\");", "+      _addError(best.getName() + invokeArgs.toString() + \" is an ambiguous invocation.  It matches both \" + best.getName() + bestArgs.toString() + \" and \" + ambiguous.getName() + ambigArgs.toString(), jexpr);", "+    }", "+    return best;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "864d12567990bc2c3431da9788529330", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/SymbolData.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 83, "methodNumberAfterChange": 83, "signatureBeforeChange": "\r   protected static boolean checkDifferentReturnTypes(MethodData md, SymbolData sd, boolean addError, JavaVersion version)", "signatureAfterChange": "   protected static boolean checkDifferentReturnTypes(MethodData md, SymbolData sd, boolean addError, JavaVersion version)", "diff": ["-   */\r", "-  protected static boolean checkDifferentReturnTypes(MethodData md, SymbolData sd, boolean addError, JavaVersion version) {\r", "-    // We only want to check the super class and interfaces, not outer classes.\r", "-    LinkedList<SymbolData> interfaces = sd.getInterfaces();    \r", "-    LinkedList<SymbolData> enclosingData = new LinkedList<SymbolData>();\r", "-    enclosingData.addAll(interfaces);\r", "-    SymbolData superClass = sd.getSuperClass();\r", "-    if (superClass != null) {\r", "-      enclosingData.add(superClass);\r", "-    }\r", "-    Iterator<SymbolData> iter = enclosingData.iterator();\r", "-    while (iter.hasNext()) {\r", "-      SymbolData currSd = iter.next();\r", "-      MethodData matchingMd = repeatedSignature(currSd.getMethods(), md);\r", "-      if (matchingMd != null) {\r", "-        boolean subclass = md.getReturnType().isSubClassOf(matchingMd.getReturnType());\r", "-        if (matchingMd.getReturnType() != md.getReturnType() && !(subclass && LanguageLevelConverter.versionIs15(version))) {\r", "-          StringBuffer methodSignature = new StringBuffer(md.getName() + \"(\");\r", "-          VariableData[] params = md.getParams();\r", "-          for (int i = 0; i < params.length; i++) {\r", "-            if (i > 0) {\r", "-              methodSignature.append(\", \");\r", "-            }\r", "-            methodSignature.append(params[i].getType().getName());\r", "-          }\r", "-          methodSignature.append(\")\");\r", "-          String methodSigString = methodSignature.toString();\r", "-          // This entire method is only called from the type checker, so add an error to its error list.\r", "-          if (addError) { TypeChecker.errors.addLast(new Pair<String, JExpressionIF>(methodSigString + \" in \" + sd.getName() + \r", "-                             \" cannot override \" + methodSigString + \" in \" +\r", "-                             currSd.getName() + \"; attempting to use different return types\",\r", "-                                                                                   md.getJExpression())); }\r", "-          return true;\r", "-        }\r", "-        if (!_isAssignable(matchingMd, md)) {\r", "-          String access = \"package\";\r", "-          if (matchingMd.hasModifier(\"private\")) {access = \"private\";}\r", "-          if (matchingMd.hasModifier(\"public\")) {access = \"public\";}\r", "-          if (matchingMd.hasModifier(\"protected\")) {access = \"protected\";}\r", "-          if (addError) {TypeChecker.errors.addLast(new Pair<String, JExpressionIF>(md.getName() + \" in \" + md.getSymbolData().getName() + \" cannot override \" + matchingMd.getName() + \" in \" + matchingMd.getSymbolData().getName() + \".  You are attempting to assign weaker access priviledges. In \" + matchingMd.getSymbolData().getName() + \", \"  + matchingMd.getName() + \" was \" + access, md.getJExpression()));} \r", "-          return true;\r", "-        }\r", "-      }\r", "-      else {\r", "-        if (checkDifferentReturnTypes(md, currSd, version)) {\r", "-          return true;\r", "-        }\r", "-      }\r", "-    }\r", "-    return false;\r", "-  }\r", "+   */", "+  protected static boolean checkDifferentReturnTypes(MethodData md, SymbolData sd, boolean addError, JavaVersion version) {", "+    // We only want to check the super class and interfaces, not outer classes.", "+    LinkedList<SymbolData> interfaces = sd.getInterfaces();    ", "+    LinkedList<SymbolData> enclosingData = new LinkedList<SymbolData>();", "+    enclosingData.addAll(interfaces);", "+    SymbolData superClass = sd.getSuperClass();", "+    if (superClass != null) {", "+      enclosingData.add(superClass);", "+    }", "+    Iterator<SymbolData> iter = enclosingData.iterator();", "+    while (iter.hasNext()) {", "+      SymbolData currSd = iter.next();", "+      MethodData matchingMd = repeatedSignature(currSd.getMethods(), md);", "+      if (matchingMd != null) {", "+        boolean subclass = md.getReturnType().isSubClassOf(matchingMd.getReturnType());", "+        if (matchingMd.getReturnType() != md.getReturnType() && !(subclass && LanguageLevelConverter.versionIs15(version))) {", "+          StringBuffer methodSignature = new StringBuffer(md.getName() + \"(\");", "+          VariableData[] params = md.getParams();", "+          for (int i = 0; i < params.length; i++) {", "+            if (i > 0) {", "+              methodSignature.append(\", \");", "+            }", "+            methodSignature.append(params[i].getType().getName());", "+          }", "+          methodSignature.append(\")\");", "+          String methodSigString = methodSignature.toString();", "+          // This entire method is only called from the type checker, so add an error to its error list.", "+          if (addError) { ", "+            TypeChecker.errors.addLast(new Pair<String, JExpressionIF>(methodSigString + \" in \" + sd.getName() + ", "+                                                                       \" cannot override \" + methodSigString + \" in \" +", "+                                                                       currSd.getName() + ", "+                                                                       \"; attempting to use different return types\",", "+                                                                       md.getJExpression())); }", "+          return true;", "+        }", "+        ", "+        if (! _isCompatible(matchingMd, md)) {  // check compatibility of visiblity modifiers", "+          String access = \"package\";", "+          if (matchingMd.hasModifier(\"private\")) access = \"private\";", "+          if (matchingMd.hasModifier(\"public\")) access = \"public\";", "+          if (matchingMd.hasModifier(\"protected\")) access = \"protected\";", "+          if (addError) {", "+            TypeChecker.errors.", "+              addLast(new Pair<String, JExpressionIF>(md.getName() + \" in \" + md.getSymbolData().getName() +", "+                                                      \" cannot override \" + matchingMd.getName() + \" in \" +", "+                                                      matchingMd.getSymbolData().getName() + ", "+                                                      \".  You are attempting to assign weaker access priviledges. In \" +", "+                                                      matchingMd.getSymbolData().getName() + \", \" + matchingMd.getName() +", "+                                                      \" was \" + access, md.getJExpression())); } ", "+          return true;", "+        }", "+      }", "+      else if (checkDifferentReturnTypes(md, currSd, version)) return true;", "+    }", "+    return false;", "+  }"]}], "num": 17998}