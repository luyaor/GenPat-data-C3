{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c00b0371bccd7a38990cf9e80dfad372", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5cf72fa7da1b04edc2be107ead6916bb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/BidirectionalHashMapTest.java", "commitBeforeChange": "847de6f16db308c08c4f40834dd2bb712c7ddd07", "commitAfterChange": "7159df222d88dee270188fe2cbffe74bb173d159", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "   public void testPut()", "signatureAfterChange": "   public void testPut()", "diff": ["-    String dog = \"dog\";", "-    String cat = \"cat\";", "-    String mouse = \"mouse\";", "+    String one = \"1\";", "+    String two = \"2\";", "+    String three = \"3\";", "-    Vector<String> vdog = new Vector<String>();", "-    Vector<String> vcat = new Vector<String>();", "-    Vector<String> vmouse = new Vector<String>();", "+    Integer int1 = new Integer(1);", "+    Integer int2 = new Integer(2);", "+    Integer int3 = new Integer(3);", "-    vdog.add(dog);", "-    vcat.add(cat);", "-    vmouse.add(mouse);", "+    BidirectionalHashMap<String, Integer> myhash = new BidirectionalHashMap<String, Integer>();", "-    BidirectionalHashMap<String, Vector<String>> myhash = new BidirectionalHashMap<String, Vector<String>>();", "+    assertEquals(\"Expected null\", null, myhash.getValue(one));", "+    assertEquals(\"Expected null\", null, myhash.getValue(two));", "+    assertEquals(\"Expected null\", null, myhash.getValue(three));", "-    assertEquals(\"Expected null\", null, myhash.getValue(dog));", "-    assertEquals(\"Expected null\", null, myhash.getValue(cat));", "-    assertEquals(\"Expected null\", null, myhash.getValue(mouse));", "-    ", "-    assertEquals(\"Expected null\", null, myhash.getKey(vdog));", "-    assertEquals(\"Expected null\", null, myhash.getKey(vcat));", "-    assertEquals(\"Expected null\", null, myhash.getKey(vmouse));", "+    assertEquals(\"Expected null\", null, myhash.getKey(int1));", "+    assertEquals(\"Expected null\", null, myhash.getKey(int2));", "+    assertEquals(\"Expected null\", null, myhash.getKey(int3));", "-    myhash.put(dog, vdog);", "-    myhash.put(cat, vcat);", "-    myhash.put(mouse, vmouse);", "+    myhash.put(one, int1);", "+    myhash.put(two, int2);", "+    myhash.put(three, int3);", "-    assertTrue(\"Given dog, should get vdog\", myhash.getValue(dog) == vdog);", "-    assertTrue(\"Given cat, should get vcat\", myhash.getValue(cat) == vcat);", "-    assertTrue(\"Given mouse, get vmouse\", myhash.getValue(mouse) == vmouse);", "+    assertTrue(\"Given one, should get 1\", myhash.getValue(one) == int1);", "+    assertTrue(\"Given two, should get 2\", myhash.getValue(two) == int2);", "+    assertTrue(\"Given three, should get 3\", myhash.getValue(three) == int3);", "+    assertTrue(\"Given 1, should get one\", myhash.getKey(int1) == one);", "+    assertTrue(\"Given 2, should get two\", myhash.getKey(int2) == two);", "+    assertTrue(\"Given 3, should get three\", myhash.getKey(int3) == three);", "+    ", "+    Iterator<Integer> it = myhash.valuesIterator();", "+    try { ", "+      it.remove();", "+      fail(\"Removing non-existent element should generate IllegalStateException\");", "+    } catch(IllegalStateException e) {}", "+    ", "+    Integer value = it.next();", "+    String key = myhash.getKey(value);", "+    assertEquals(\"key and value should match\", value.toString(), key);", "+    it.remove();", "+    assertEquals(\"After removing key, it should not appear in map\", null, myhash.getValue(key));", "+    assertEquals(\"After removing value, it should not appear in map\", null, myhash.getKey(value));", "+    ", "+    value = it.next();", "+    key = myhash.getKey(value);", "+    assertEquals(\"key and value should match\", value.toString(), key);", "+    it.remove();", "+    assertEquals(\"After removing key, it should not appear in map\", null, myhash.getValue(key));", "+    assertEquals(\"After removing value, it should not appear in map\", null, myhash.getKey(value));", "+    ", "+    value = it.next();", "+    key = myhash.getKey(value);", "+    assertEquals(\"key and value should match\", value.toString(), key);", "+    it.remove();", "+    assertEquals(\"After removing key, it should not appear in map\", null, myhash.getValue(key));", "+    assertEquals(\"After removing value, it should not appear in map\", null, myhash.getKey(value));", "+    ", "+    /* myhash should be empty now */", "+    it = myhash.valuesIterator();", "+    assertFalse(\"Map should be empty\", it.hasNext());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0467dc10ab85e305519cc27002838d5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 20, "signatureBeforeChange": "   protected SymbolData getSymbolData(String className, SourceInfo si, boolean resolve, boolean fromClassFile,                                       boolean addError, boolean checkImportedStuff)", "signatureAfterChange": "   protected SymbolData getSymbolData(File file,                                      String pkg,                                      LinkedList<String> importedFiles,                                      LinkedList<String> importedPackages,                                      String enclosingClassName,                                      String className,                                       SourceInfo si,                                       boolean addError,                                       boolean checkImports)", "diff": ["-  protected SymbolData getSymbolData(String className, SourceInfo si, boolean resolve, boolean fromClassFile, ", "-                                     boolean addError, boolean checkImportedStuff) {", "- ", "+    */", "+  protected SymbolData getSymbolData(File file,", "+                                     String pkg,", "+                                     LinkedList<String> importedFiles,", "+                                     LinkedList<String> importedPackages,", "+                                     String enclosingClassName,", "+                                     String className, ", "+                                     SourceInfo si, ", "+                                     boolean addError, ", "+                                     boolean checkImports) {", "+    ", "+    if (className == null) {", "+      System.err.println(\"***ERROR*** getSymbolData called with null className\");", "+      assert false;", "+    }", "+//    if (className.equals(\"Object\")) System.err.println(\"getSymbol called for 'Object'\");", "+//    if (className.equals(\"String\")) System.err.println(\"getSymbol called for 'String'\");", "+    ", "+    /** Check to see if type with className (as is) can be found. */", "+    SymbolData existingSD = getQualifiedSymbolData(className, si, false, false, addError);", "+    if (existingSD != null) return existingSD;", "+        ", "-      String rawClassName = className.substring(0, className.length() - 2);", "-      SymbolData sd = getSymbolData(rawClassName, si, resolve, fromClassFile, addError, checkImportedStuff);", "-      if (sd == null) return null;   // Should only happen in tests.", "-      ArrayData ad = new ArrayData(sd, this, si);", "-      symbolTable.put(ad.getName(), ad);", "-      return ad;", "+      String eltClassName = className.substring(0, className.length() - 2);  // may not be fully qualified", "+      if (eltClassName.equals(\"String\")) System.err.println(\"getSymbolData called for String[]\");", "+      return getArraySymbolData(/* file, pkg, importedFiles, importedPackages, enclosingClassName, */", "+                                eltClassName, si, addError, checkImports);", "-    // First, handle classNames that do NOT manifestly refer to inner classes", "-    int indexOfNextDot = className.indexOf(\".\");", "-    int indexOfNextDollar = className.indexOf(\"$\");   // '$' is assumed not to appear in source program type names", "-    if (indexOfNextDot == -1 && indexOfNextDollar == -1)", "-      return getSymbolDataHelper(className, si, resolve, fromClassFile, addError, checkImportedStuff);", "+    // Try matching the className against current package", "+    String qualClassName = getQualifiedClassName(pkg, className);  // TODO: make this work for an inner class", "+    existingSD = getQualifiedSymbolData(qualClassName, si);", "+    if (existingSD != null) return existingSD; ", "-    // Try to decompose className into an inner class reference, but name may simply be fully qualified", "-    indexOfNextDot = 0;   ", "+    // Check for relative inner class reference", "+    if (enclosingClassName != null) {", "+      // Assume that className is an inner class relative to _enclosingClassName (which always holds for local ", "+      // classes and often holds for immediate inner class references.  Fortunately, local class references cannot be", "+      // forward references.", "+      SymbolData enclosingSD = getQualifiedSymbolData(enclosingClassName, si);", "+      if (enclosingSD != null) {", "+        SymbolData sd = enclosingSD.getInnerClassOrInterface(className);", "+        if (sd != null) return sd;", "+//        // NOTE: the following should be unnecessary since the forward referenced inner symbol should be sd above ", "+//        // Check for forward reference to an inner class of the enclosing class", "+//        String qualifiedName = enclosingSD + '.' + className;", "+//        if (_innerClassesInThisBody.contains(qualifiedName))  // forward reference to inner class/interface", "+//          return getQualifiedSymbolData(qualifiedName, si);   // return continuation", "+      }", "+    }", "+    ", "+    // TODO: imported inner class can have qualification so the following logic is broken.  The following logic", "+    // ignores the possibility of importing an inner class.  Fix this !!!", "+    if (className.indexOf('.') == -1) { // className has no qualification; may be imported", "+    ", "+      // Check if the className's package was imported.", "+      if (checkImports) {", "+//        if (className.equals(\"Object\")) System.err.println(\"***SHOUT*** checking imports for 'Object'\");", "+        ", "+        // Check if className was specifically imported.", "+        // We will not check that the package is correct here, because it is caught in the type checker.", "+        Iterator<String> iter = importedFiles.iterator();", "+        while (iter.hasNext()) {", "+          String s = iter.next();", "+          if (s.endsWith(className)) {", "+            SymbolData importSD = symbolTable.get(s); // All imported files should be in the symbol table.", "+            if (importSD == null) System.err.println(\"***ALARM*** Imported symbol lookup failed for \" + s);", "+            // if importSD is a continuation it will be subsequently be resolved", "+            return importSD;", "+          }", "+        }", "+      }", "+     ", "+      // Look for a match against imported packages", "+      // TODO:  Within a relative class name the separators must be converted from '.' to '$'", "+      SymbolData resultSD = null;", "+      assert importedPackages.contains(\"java.lang\");", "+//      assert symbolTable.containsKey(\"java.lang.Object\");", "+      for (String prefix: importedPackages) {", "+        String s = prefix + '.' + className;", "+        if (className.equals(\"java.lang.Object\")) System.err.println(\"***ALARM*** Looking up: \" + s);", "+        SymbolData sD = getQualifiedSymbolData(s, si, false, false, false);", "+//        if (qualClassName.equals(\"java.lang.Object\")) ", "+//          System.err.println(\"matching sd is: \" + sD + \"\\nsymbolTable.get(\\\"\" + s + \"\\\") = \"+ symbolTable.get(s));", "+        if (sD != null) {", "+          if (resultSD == null || resultSD.equals(sD)) resultSD = sD;", "+          else {  // sD is NOT the first match; flag an error", "+            if (addError) {", "+              _addAndIgnoreError(\"The class name \" + qualClassName + \" is ambiguous.  It could be \" + resultSD.getName()", "+                                   + \" or \" + sD.getName(), new NullLiteral(si));", "+              return null;", "+            }", "+          }", "+        }", "+      }", "+      if (resultSD != null) return resultSD;", "+      else return null;  // subsequent searching assumes that className is qualified.", "+    }", "+    ", "+    // Decompose class name as fully qualified name followed by an inner class reference", "+    // TODO: the separator within inner class names is '$'", "+    int indexOfNextDot = 0;", "+//    int indexOfNextDollar = className.indexOf(\"$\");   // '$' only appears as separator for inner class names  ", "-      indexOfNextDot = className.indexOf(\".\", indexOfNextDot + 1);", "+      indexOfNextDot = className.indexOf('.', indexOfNextDot + 1);", "-      /* We want to resolve after every piece until the last one because we need to know when we actually have a class", "-       * so that we can tell that the rest of the pieces are inner classes.  We use the resolve parameter's value for ", "-       * the last piece since that means there are no inner classes", "-       */", "-//      boolean newResolve = resolve || (indexOfNextDot != length);", "-      sd = getSymbolDataHelper(prefix, si, resolve, fromClassFile, false, checkImportedStuff);", "-//      if (prefix.equals(\"fully.qualified.Woah\")) ", "-//        throw new RuntimeException(prefix + \" passed to helper and newResolve = \" + resolve );", "-      if (sd != null) { // prefix matches an extant symbol", "+      ", "+      /* We want to try finding each prefix in the symbol table; the decomposition is putative. */", "+      sd = getQualifiedSymbolData(prefix, si, false, false, false);", "+      if (sd != null && sd != SymbolData.AMBIGUOUS_REFERENCE) { // prefix matches an existing symbol", "-          innerClassName = className.substring(indexOfNextDot + 1);", "+          innerClassName = className.substring(indexOfNextDot + 1);  // putative relative name of inner class", "+          // NOTE: should be able to search symbolTable using getSymbolData", "+          if (sd != null) return sd;", "-          if (sd == null) { // create continuation for inner class; we are forbidding some ambiguities Java may permit", "-            sd = addInnerSymbolData(si, outerClassName + \".\" + innerClassName, outerClassSD);", "-          }", "-          return sd;", "+//          if (sd == null) { // create continuation for inner class; we are forbidding some ambiguities Java may permit", "+//            sd = addInnerSymbolData(si, outerClassName + '.' + innerClassName, outerClassSD);", "+//          }", "+          /* otherwise try another decomposition. */", "-        else if (sd == SymbolData.AMBIGUOUS_REFERENCE) {", "-          _addAndIgnoreError(\"Ambiguous reference to class or interface \" + className, new NullLiteral(si));", "-          return null;", "-        }", "-        else if (sd != null && sd != SymbolData.NOT_FOUND) { return sd; }", "-      // sd may be null or an error element of SymbolData", "-    }", "-    ", "-    // No match was found", "-    if (! fromClassFile && addError) {", "-      // _log.log(\"Returning an Invalid class name for \" + className);", "-      String newName = className;", "-      int lastDollar = newName.lastIndexOf(\"$\");", "-      newName = newName.substring(lastDollar + 1, newName.length());", "-//      Utilities.show(\"Invalid class name \" + newName + \" and \" + className);", "-      _addAndIgnoreError(\"Invalid class name \" + newName, new NullLiteral(si));", "-//      throw new RuntimeException(\"Invalid class name \" + newName + \" encountered in file \" + _file);"]}], "num": 28438}