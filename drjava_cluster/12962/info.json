{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5167269e1a2b3767dd53a0f61bcc0785", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16179ccf8846dbd13c7e9340f708cb9a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/DefaultCompilerModel.java", "commitBeforeChange": "dffeb55b275906c40458f2a767d0f62b0845e9e5", "commitAfterChange": "b1aa79fb7a1aab3c0f34f51e168c7e7a945d8cf6", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "   private synchronized void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "signatureAfterChange": "   private synchronized void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "diff": ["-      for (int i = 0; i < files.length; i++) {", "-        String fileName = files[i].getAbsolutePath();", "+      // The hashset is used to make sure we never send in duplicate files. This can happen if", "+      // the java file was sent in allong with the corresponding .dj* file. The dj* file", "+      // is renamed to a .java file and thus we have two of the same file in the list.  By", "+      // adding the renamed file to the hashset, the hashset efficiently removes duplicates.", "+      HashSet<File> javaFileSet = new HashSet<File>();", "+      for (File f : files) {", "+        File canonicalFile;", "+        try {", "+          canonicalFile = f.getCanonicalFile();", "+        } catch(IOException e) {", "+          canonicalFile = f.getAbsoluteFile();", "+        }", "+        String fileName = canonicalFile.getPath();", "-          files[i] = new File(fileName.substring(0, lastIndex) + \".java\");", "+          javaFileSet.add(new File(fileName.substring(0, lastIndex) + \".java\"));", "+        }", "+        else {", "+          javaFileSet.add(canonicalFile);", "+      files = javaFileSet.toArray(new File[0]);", "+        "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2259017535f7d98dd3d8799a990119ff", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/cache/DocumentCache.java", "commitBeforeChange": "d95e05b94bb85b9fefc27bcb5d21a4779fe83bf0", "commitAfterChange": "1b9869851f567b7b6474eabaac96584b4771f5f3", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 10, "signatureBeforeChange": "     public synchronized DefinitionsDocument getDocument()        throws IOException, FileMovedException", "signatureAfterChange": "     public DefinitionsDocument getDocument() throws IOException, FileMovedException", "diff": ["-    public synchronized DefinitionsDocument getDocument() ", "-      throws IOException, FileMovedException {", "-        ", "-      if (_stat != FIRST_IN_LRU && _stat != UNMANAGED) makeMeFirst();", "-      else if (_stat == UNMANAGED && _doc !=null && !_doc.isModifiedSinceSave()) _stat = NOT_IN_LRU;", "-", "-      if (_doc != null) return _doc;", "-  ", "-      try {", "-        _doc = _rec.make();", "-        if (_doc == null) throw new IllegalStateException(\"the reconstructor made a null document\");", "+    public DefinitionsDocument getDocument() throws IOException, FileMovedException {", "+      boolean isResident = false;", "+      boolean makeUnmanaged = false;  // makeUnmanaged -> isResident", "+      synchronized (this) {", "+        isResident = _doc != null;", "+        if (isResident) {  // Document is in queue or \"unmanaged\" (a modified doc or a new doc with no file)", "+          if (isUnmanaged() || isUntitled()) return _doc;", "+          makeUnmanaged = _doc.isModifiedSinceSave();", "+          if (makeUnmanaged)  { setUnmanaged(); }", "+        }", "-      catch(BadLocationException e) { throw new UnexpectedException(e); }", "+      if (makeUnmanaged) synchronized (DocumentCache.this) {  _residentQueue.remove(this); }", "+      if (isResident) return _doc;", "+        ", "+      boolean isUntitled = false;", "+      synchronized (this) {", "+        isUntitled = isUntitled();  // This locking may be overkill; once titled, always titled", "+        try { // _doc is not in memory", "+          _doc = _rec.make();", "+          if (_doc == null) throw new IllegalStateException(\"the reconstructor made a null document\");", "+        }", "+        catch(BadLocationException e) { throw new UnexpectedException(e); }", "+      }", "+//      Utilities.showDebug(\"Document \" + _doc + \" reconstructed; _stat = \" + _stat);", "+      if (! isUntitled) synchronized (DocumentCache.this) { addToQueue(); }"]}], "num": 12962}