{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5f8ea673e009a20e506cca8aa1eb48a4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7e29ed7ffc29047dbe5cf52b4379bd3d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/sourcechecker/SourceChecker.java", "commitBeforeChange": "be902882edd6ee8f5b7260e86997569bf07255e2", "commitAfterChange": "ead43466202abb204c90f7ee2c316fec230d4415", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 45, "signatureBeforeChange": "          public void end()", "signatureAfterChange": "          public void end()", "diff": ["-      System.out.println(\"Statements with errors: \" + sizeString(_errors));", "-      if (_verbose) { dump(_errors.secondSet()); }", "+      System.out.println(\"Common statements with errors: \" + sizeString(_commonErrors));", "+      if (_verbose) { dump(_commonErrors.secondSet()); }", "+      System.out.println(\"Left statements with errors: \" + sizeString(_leftErrors));", "+      if (_verbose) { dump(_leftErrors.secondSet()); }", "+      System.out.println(\"Right statements with errors: \" + sizeString(_rightErrors));", "+      if (_verbose) { dump(_rightErrors.secondSet()); }", "+      System.out.println(\"Polymorphic declarations: \" + sizeString(_polymorphicDeclarations));", "+      if (_verbose) { dump(_polymorphicDeclarations.secondSet()); }", "+      System.out.println(\"Simple wildcards: \" + sizeString(_simpleWildcards));", "+      if (_verbose) { dump(_simpleWildcards.secondSet()); }", "+      System.out.println(\"Upper-bounded wildcards: \" + sizeString(_extendsWildcards));", "+      if (_verbose) { dump(_extendsWildcards.secondSet()); }", "+      System.out.println(\"Lower-bounded wildcards: \" + sizeString(_superWildcards));", "+      if (_verbose) { dump(_superWildcards.secondSet()); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "890b0409124cdaf0ef913cb7a08bf60b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 79, "methodNumberAfterChange": 82, "signatureBeforeChange": "   public void createConstructor(SymbolData sd)", "signatureAfterChange": "   public void createConstructor(SymbolData sd)", "diff": ["-    ", "-    SymbolData superSd = sd.getSuperClass();", "-    ", "-    //there was an error somewhere else.  just return.", "-    if (sd.isContinuation()) return;", "-    ", "-    LinkedList<MethodData> superMethods = superSd.getMethods();", "-    String superUnqualifiedName = getUnqualifiedClassName(superSd.getName());", "-    ", "-    LanguageLevelVisitor sslv = LanguageLevelConverter._newSDs.remove(superSd);", "-    if (sslv != null) {sslv.createConstructor(superSd);}", "-    ", "-    // Find the super's smallest constructor.", "-    MethodData superConstructor = null;", "-    Iterator<MethodData> iter = superMethods.iterator();", "-    while (iter.hasNext()) {", "-      MethodData superMd = iter.next();", "-      if (superMd.getName().equals(superUnqualifiedName)) {", "-        if (superConstructor == null || superMd.getParams().length < superConstructor.getParams().length) {", "-          superConstructor = superMd;", "-        }", "-      }", "+ ", "+    System.err.println(\"**** createConstructor called for \" + sd);", "+        ", "+//    if (sd == null) {", "+//      System.err.println(\"**** Error **** After fixups, SymbolData \" + sd + \" has null for a super class\");", "+//      assert false;", "+//    }", "+//    ", "+    if (sd.isContinuation()) {", "+      _addError(\"Could not generate constructor for class \" + sd + \" because it has no definition\", ", "+                new NullLiteral(SourceInfo.NO_INFO));", "+      return;", "-    String name = getUnqualifiedClassName(sd.getName());", "-    MethodData md = new MethodData(name,", "-                                   new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}), ", "-                                   new TypeParameter[0], ", "-                                   sd, ", "-                                   new VariableData[0], // Parameters to be filled in later. ", "-                                   new String[0], ", "-                                   sd,", "-                                   null);", "+    SymbolData superSd = sd.getSuperClass();", "+    if (superSd == null) {", "+      _addError(\"Could not generate constructor for class \" + sd + \" because it has no superclass\", ", "+                new NullLiteral(SourceInfo.NO_INFO));", "+      return;", "+    }", "-    LinkedList<VariableData> params = new LinkedList<VariableData>();", "-    if (superConstructor != null) {", "+    else {", "+      LinkedList<MethodData> superMethods = superSd.getMethods();", "+      String superUnqualifiedName = getUnqualifiedClassName(superSd.getName());", "+      ", "+      LanguageLevelVisitor sslv = LanguageLevelConverter._newSDs.remove(superSd);", "+      ", "+      // if sslv == null, the superclass constructor has already been generated or we are caught in a cyclic", "+      // inheritance hierarchy", "+      if (sslv != null) {", "+        sslv.createConstructor(superSd);", "+        System.err.println(\"Creating constructor for superclass \" + superSd);", "+      }", "+      ", "+      // Find the super's smallest constructor.", "+      MethodData superConstructor = null;", "+      for (MethodData superMd: superMethods) {", "+//      Iterator<MethodData> iter = superMethods.iterator();", "+//      while (iter.hasNext()) {", "+//        MethodData superMd = iter.next();", "+        if (superMd.getName().equals(superUnqualifiedName)) {", "+          if (superConstructor == null || superMd.getParams().length < superConstructor.getParams().length) {", "+            superConstructor = superMd;", "+          }", "+        }", "+      }", "+      if (superConstructor == null) {", "+        _addAndIgnoreError(\"Could not generate constructor for class \" + sd + \" superclass has no constructor, perhaps\"", "+                           + \" because the class hierarchy is cyclic.\",", "+                           new NullLiteral(SourceInfo.NO_INFO));", "+        return;", "+      }", "+//      if (superConstructor == null) {", "+//        System.err.println(\"**** Error **** The superclass \" + superSd + \" has no constructors \");", "+//      }", "+      String name = getUnqualifiedClassName(sd.getName());", "+      MethodData md = new MethodData(name,", "+                                     PUBLIC_MAV, ", "+                                     new TypeParameter[0], ", "+                                     sd, ", "+                                     new VariableData[0], // Parameters to be filled in later. ", "+                                     new String[0], ", "+                                     sd,", "+                                     null);", "+      ", "+      LinkedList<VariableData> params = new LinkedList<VariableData>();", "+//      if (superConstructor != null) {", "-        VariableData newParam = ", "-          new VariableData(paramName, new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[0]), ", "-                           superParam.getType().getSymbolData(), true, md);", "+        SymbolData superParamSD = superParam.getType();", "+        assert superParamSD != null;", "+        VariableData newParam = new VariableData(paramName, PACKAGE_MAV, superParamSD, true, sd);  // Note: sd was md", "-        md.addVar(newParam); ", "+        md.addVar(newParam);  // Fixups have already been executed", "-    }", "+//      }", "-    // only add in those fields that do not have a value and are not static.", "-    boolean hasOtherConstructor = sd.hasMethod(name);", "-    ", "-    for (VariableData field : sd.getVars()) {", "+      // only add in those fields that do not have a value and are not static.", "+      boolean hasOtherConstructor = sd.hasMethod(name);", "-      if (! field.hasInitializer() && ! field.hasModifier(\"static\")) {", "-        if (! hasOtherConstructor) { field.gotValue(); } // Set hasValue if no other constructors need to be visited", "-        // Rather than creating a new parameter, we use the field, since all the important data is the same in both of", "-        // them.", "-        params.add(field);", "+      for (VariableData field : sd.getVars()) {", "+        ", "+        if (! field.hasInitializer() && ! field.hasModifier(\"static\")) {", "+          if (! hasOtherConstructor) { field.gotValue(); } // Set hasValue if no other constructors need to be visited", "+          // Rather than creating a new parameter, we use the field, since all the important data is the same in both of", "+          // them.", "+          VariableData param = field.copyWithoutVisibility();", "+          params.add(param);", "+        }", "+      // Some fields may be declared private, but parameters cannot be; unprivatize the ", "+      ", "+      md.setParams(params.toArray(new VariableData[params.size()]));", "+      md.setVars(params);", "+      ", "+      System.err.println(\"**** Adding constructor \" + md + \" **** to symbol \" + sd);", "+//      if (md.getName().equals(\"ClassName\"))", "+//        System.err.println(\"****** constructor visibility = \" + md.getMav());", "+      addGeneratedMethod(sd, md);", "-    md.setParams(params.toArray(new VariableData[params.size()]));", "-    md.setVars(params);", "-    ", "-    addGeneratedMethod(sd, md);"]}], "num": 11112}