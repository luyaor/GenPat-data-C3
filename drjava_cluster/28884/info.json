{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5987a5e23561210cb99aa3943d081105", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2e33deeaeca854d6638cb1c767556df2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/InteractionsDJDocumentTest.java", "commitBeforeChange": "66cf5c18c85c49dd4268e6eb5e205df7e4243a71", "commitAfterChange": "f6fc0c2918885b86d7588893e1a025f2fac926cd", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "   public void testStylesListContentAndReset() throws EditDocumentException", "signatureAfterChange": "   public void testStylesListContentAndReset() throws EditDocumentException, InterruptedException", "diff": ["+  /** Tests that the styles list is updated and reset properly */", "+  public void testStylesListContentAndReset() throws EditDocumentException, InterruptedException {", "+    /* The banner and the prompt are inserted in the styles list when the document is constructed; the corresponding", "+       offsets are computed in the tests below. ", "+     */", "+    ", "+    final Object _restartLock = new Object();", "+    ", "+    assertEquals(\"StylesList before insert should contain 2 pairs\", 2, _adapter.getStylesList().size());", "+    ", "+    int blen = InteractionsModel.getStartUpBanner().length();", "+    ", "+    /** Elt1, Elt2 are first two elements pushed on the StylesList stack */", "+    String styleElt1 = \"((0, \" + blen + \"), object.return.style)\";", "+    String styleElt2 = \"((\" + blen + \", \" + (blen + 2) + \"), default)\";", "-   */", "-  public void testStylesListContentAndReset() throws EditDocumentException {", "-    // the banner and the prompt are inserted in the styles list when the document is constructed", "-    assertEquals(\"StylesList before insert should contain 2 pairs\",", "-                 2, _adapter.getStylesList().size());", "-", "+    assertEquals(\"The first element pushed on StylesList before insertion should be\", styleElt1,", "+                 _adapter.getStylesList().get(1).toString());", "+    assertEquals(\"The second element pushed on StylesList before insertion should be\", styleElt2,", "+                 _adapter.getStylesList().get(0).toString());", "+    ", "+    ", "+    /* Third element pushed StylesList stack before reset */", "+    String styleElt3 = \"((\" + (blen + 2) + \", \" + (blen + 3) + \"), number.return.style)\";", "-    assertEquals(\"StylesList before reset should contain 3 pairs\",", "-                 3, _adapter.getStylesList().size());", "+    assertEquals(\"StylesList before reset should contain 3 pairs\", 3, _adapter.getStylesList().size());", "+    ", "+    assertEquals(\"The first element pushed on StylesList before reset should be\", styleElt1,", "+                 _adapter.getStylesList().get(2).toString());", "+    assertEquals(\"The second element pushed on StylesList before reset should be\", styleElt2,", "+                 _adapter.getStylesList().get(1).toString());", "+    assertEquals(\"The last element pushed on StylesList before reset should be\", styleElt3,", "+                 _adapter.getStylesList().get(0).toString());", "+    ", "+//    System.err.println(\"Doc text: \" + _adapter.getText());", "+//    System.err.println(\"The styles list is: \" + _adapter.getStylesList());", "+//    System.err.println(\"The length of the startup banner is: \" + InteractionsModel.getStartUpBanner().length());", "+    ", "+    /* Reset interactions and wait until it completes */", "-    assertEquals(\"The first element of StylesList before reset should be\",", "-                 \"((21, 22), number.return.style)\", _adapter.getStylesList().get(0).toString());", "-    assertEquals(\"The second element of StylesList before reset should be\",", "-                 \"((19, 21), default)\", _adapter.getStylesList().get(1).toString());", "-    assertEquals(\"The third element of StylesList before reset should be\",", "-                 \"((0, 19), object.return.style)\", _adapter.getStylesList().get(2).toString());", "-//    System.out.println(_doc); ", "-    synchronized(_model) {", "-      // Reset should clear", "-      _model.setWaitingForFirstInterpreter(false);", "-      //this adds the \"Resetting Interactions\"", "-      _model.resetInterpreter();", "-      Utilities.clearEventQueue();", "-      _model.interpreterResetting();", "-      Utilities.clearEventQueue();", "-//      Utilities.clearEventQueue();", "- ", "-      assertEquals(\"StylesList after reset should contain 1 pair\", 1, _adapter.getStylesList().size());", "-      //Resetting Interactions piece", "-//      int returnNum = System.getProperty(\"line.separator\").length();", "-//      assertEquals(\"The only element of the StylesList after reset should be\",", "-//                   \"((\"+(47+returnNum)+\", \"+(72+returnNum*2)+\"), error)\", _adapter.getStylesList().get(0).toString());", "-      assertTrue(\"The only element of the StylesList after reset should be similar to ((48, 74), error)\",", "-                 _adapter.getStylesList().get(0).toString().matches(\"\\\\(\\\\(4\\\\d, 7\\\\d\\\\)\\\\, error\\\\)\"));", "-    }", "+    InteractionsListener restartCommand = new DummyGlobalModelListener() {", "+      public void interpreterReady(File wd) {", "+        synchronized (_restartLock) {", "+          _interpreterRestarted = true;", "+          _restartLock.notify();", "+        }", "+      }};", "+    _model.addListener(restartCommand);", "+                                   ", "+    // Reset should clear", "+    _model.setWaitingForFirstInterpreter(false);", "+    ", "+    synchronized(_restartLock) { _interpreterRestarted = false; }", "+      ", "+    // Reset the interactions pane, restarting the interpreter", "+    File f = new File(System.getProperty(\"user.dir\"));", "+    _model.resetInterpreter(f);  ", "+", "+    //. Wait until interpreter has restarted", "+    synchronized(_restartLock) { while (! _interpreterRestarted) _restartLock.wait(); }", "+    _model.removeListener(restartCommand);", "+    ", "+//    System.err.println(\"Doc text: \" + _adapter.getText());", "+//    System.err.println(\"Text length: \" + _adapter.getLength());", "+//    System.err.println(\"The styles list is: \" + _adapter.getStylesList());", "+   ", "+    assertEquals(\"StylesList after reset should contain 2 pairs\", 2, _adapter.getStylesList().size());", "+    ", "+    assertEquals(\"The first element pushed on StylesList after reset should be\", styleElt1,", "+                 _adapter.getStylesList().get(1).toString());", "+    assertEquals(\"The second element pushed on StylesList after reset should be\", styleElt2,", "+                 _adapter.getStylesList().get(0).toString());", "+    ", "+    ", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4eeb6d8e64ce239f32429bf8c8c4d05a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/DefinitionsPaneTest.java", "commitBeforeChange": "7363b79c6228b3bbffbaa22283c3045a27a3cedc", "commitAfterChange": "74a15c017d574b2ee2a0cdeaaedeea00825a0c5e", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "   public void testMultilineCommentOrUncommentAfterScroll() throws BadLocationException", "signatureAfterChange": "   public void testMultilineCommentOrUncommentAfterScroll() throws BadLocationException", "diff": ["-    String commented =", "+    final String commented =", "-    final int newPos = 20;", "-    ", "-    // The following statement hung when run in the main test thread.  There must be a pending access to doc in a", "-    // task on the event queue that sometimes has not yet executed.", "-    ", "-    Utilities.invokeAndWait(new Runnable() { public void run() { doc.append(text, null); } });", "-    Utilities.clearEventQueue();", "-    ", "-    assertEquals(\"insertion\", text, doc.getText());", "-    // I can't run the test here because I'm not sure how to select the text so that we can comment it.", "-", "-    Utilities.invokeAndWait(new Runnable() { public void run() { pane.endCompoundEdit(); } });", "-     ", "-    doc.acquireWriteLock();", "-    try { doc.commentLines(0, doc.getLength()); }", "-    finally { doc.releaseWriteLock(); }", "-    ", "-    //    pane.endCompoundEdit();", "-    assertEquals(\"commenting\", commented, doc.getText());", "-    ", "-    int oldPos = pane.getCaretPosition();", "+    // I can't run the test here because I'm not sure how to select the text so that we can comment it", "-        pane.setCaretPosition(newPos); ", "-        _frame.validate();", "-      } ", "+        doc.append(text, null);", "+        assertEquals(\"insertion\", text, doc.getText());", "+//        System.err.println(\"Compound? \" + pane._inCompoundEdit);", "+//        System.err.println(\"After append, loc = \" + doc.getCurrentLocation());", "+        pane.endCompoundEdit();", "+        doc.commentLines(0, doc.getLength()); ", "+", "+        assertEquals(\"commenting\", commented, doc.getText());", "+        int newPos = doc.getCurrentLocation();", "+//        System.err.println(\"newPos = \" + newPos);", "+", "+        doc.getUndoManager().undo(); ", "+//        System.err.println(\"cursor pos = \" + doc.getCurrentLocation());", "+//        int pos = doc.getCurrentLocation();", "+        assertEquals(\"undo commenting\", text, doc.getText());", "+//        System.err.println(\"cursor pos = \" + pos + \"\\n\");", "+//        // doc.commentLines moves the cursor to 0 before inserting wing comment chars", "+//", "+//        assertTrue(\"dummy test\", true);", "+//        System.err.println(\"undone text = '\" + doc.getText() + \"'\");", "+//        assertTrue(\"dummy test\", true);", "+", "+        assertEquals(\"undoing commenting restores cursor position\", 0, doc.getCurrentLocation());", "+        ", "+        doc.getUndoManager().redo();", "+        assertEquals(\"redo commenting\", commented, doc.getText());", "+        assertEquals(\"redoing commenting restores cursor position\", newPos, doc.getCurrentLocation());", "+", "+        pane.endCompoundEdit(); ", "+        doc.uncommentLines(0, doc.getLength()); ", "+        assertEquals(\"uncommenting\", text, doc.getText());", "+", "+        _redoPos = doc.getCurrentLocation();  ", "+    ", "+        doc.getUndoManager().undo();", "+        ", "+      } });", "+    ", "+    // undo may spawn new events that fix up the value of _currentLocation; must break our of invokeAndWait to let", "+    // them execute", "+", "+    Utilities.invokeAndWait(new Runnable() {", "+      public void run() {", "+        ", "+//        System.err.println(\"cursor pos = \" + doc.getCurrentLocation());", "+    ", "+        assertEquals(\"undo uncommenting\", commented, doc.getText());", "+//        System.err.println(\"cursor pos = \" + doc.getCurrentLocation());", "+", "+        // doc.uncommentLines moves the cursor to 0 before removing the wing comment chars", "+        assertEquals(\"undoing uncommenting restores cursor position\", 0, doc.getCurrentLocation());", "+    ", "+        doc.getUndoManager().redo();", "+        assertEquals(\"redo uncommenting\",text, doc.getText());", "+        assertEquals(\"redoing uncommenting restores cursor position\", _redoPos, doc.getCurrentLocation());", "+                                                        ", "+//        fail(\"print System.err\");", "+      }", "-    Utilities.clearEventQueue();", "-    ", "-    doc.getUndoManager().undo();  ", "-    assertEquals(\"undo commenting\", text, doc.getText());", "-    assertEquals(\"undoing commenting restores caret position\", oldPos, pane.getCaretPosition());", "-    ", "-    // Perturb the caret position and redo", "-    Utilities.invokeAndWait(new Runnable() { public void run() { pane.setCaretPosition(newPos); } });", "-    Utilities.clearEventQueue();", "-    ", "-    doc.getUndoManager().redo();", "-    assertEquals(\"redo commenting\", commented, doc.getText());", "-    assertEquals(\"redoing commenting restores caret position\", oldPos, pane.getCaretPosition());", "-    ", "-    // Need to do this here since the commentLines action in MainFrame usually takes care of this.  ", "-    // I can't simulate a keystroke here because I'm not sure how to select the text so that we can comment it.", "-    Utilities.invokeAndWait(new Runnable() { public void run() { pane.endCompoundEdit(); } });", "-    Utilities.clearEventQueue();", "-    ", "-    doc.acquireWriteLock();", "-    try { doc.uncommentLines(0, doc.getLength()); }", "-    finally { doc.releaseWriteLock(); }", "-    ", "-    //    pane.endCompoundEdit();", "-    assertEquals(\"uncommenting\", text, doc.getText());", "-    ", "-    oldPos = pane.getCaretPosition();  // executing this method call outside of the event thread is borderline", "-    ", "-    Utilities.invokeAndWait(new Runnable() { public void run() { pane.setCaretPosition(newPos);  } });", "-    Utilities.clearEventQueue();", "-    ", "-    doc.getUndoManager().undo();", "-    ", "-    assertEquals(\"undo uncommenting\", commented, doc.getText());", "-    assertEquals(\"undoing uncommenting restores caret position\", oldPos, pane.getCaretPosition());", "-    ", "-    Utilities.invokeAndWait(new Runnable() { public void run() { pane.setCaretPosition(newPos); } });", "-    Utilities.clearEventQueue();", "-    ", "-    doc.getUndoManager().redo();", "-    assertEquals(\"redo uncommenting\",text, doc.getText());", "-    assertEquals(\"redoing uncommenting restores caret position\", oldPos, pane.getCaretPosition());"]}], "num": 28884}