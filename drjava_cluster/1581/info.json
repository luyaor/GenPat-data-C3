{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "19f8978f53f826931b5d351b7e2b63b1", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1fc1e869aa0363d4facb5ba28ec02c0e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/DefaultCompilerModel.java", "commitBeforeChange": "0e6d6d4c130043dfa8d569e24f0f6f9c1f824f96", "commitAfterChange": "ccb8831468d9c146526d6431dd0a2aea7a5182b5", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 8, "signatureBeforeChange": "   protected void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "signatureAfterChange": "   protected void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "diff": ["-    CompilerError[] errors = new CompilerError[0];", "+//    CompilerError[] errors = new CompilerError[0];", "+    Pair<LinkedList<ParseException>, LinkedList<Pair<String, JExpression>>> errors;", "+    LinkedList<ParseException> parseExceptions;", "+    LinkedList<Pair<String, JExpression>> visitorErrors;", "+      LinkedList<CompilerError> compilerErrors = new LinkedList<CompilerError>();", "-      errors = compiler.compile(sourceRoots, files);", "+//      if (DrJava.getConfig().getSetting(OptionConstants.LANGUAGE_LEVEL) == DrJava.ELEMENTARY_LEVEL) {", "+      LanguageLevelConverter llc = new LanguageLevelConverter();", "+      // Language level files are moved to another file, copied back", "+      // in augmented form to be compiled.  This compiled version", "+      // is also copied to another file with the same path with the ", "+      // \".augmented\" suffix on the end.", "+      // We have to copy the original back to its original spot so the", "+      // user doesn't have to do anything funny.", "+      //      LinkedList<File> filesToRestore = new LinkedList<File>();", "+      //      System.out.println(\"Calling convert!\");", "+      errors = llc.convert(files);//, filesToRestore);", "+      ", "+      /**Rename any .dj0 files in files to be .java files, so the correct thing is compiled.*/", "+      for (int i = 0; i<files.length; i++) {", "+        String fileName = files[i].getAbsolutePath();", "+        int lastIndex = fileName.lastIndexOf(\".dj\");", "+        if (lastIndex != -1) {", "+          files[i]=new File(fileName.substring(0, lastIndex) + \".java\");", "+        }", "+      }", "+      parseExceptions = errors.getFirst();", "+      compilerErrors.addAll(_parseExceptions2CompilerErrors(parseExceptions));", "+      visitorErrors = errors.getSecond();", "+      compilerErrors.addAll(_visitorErrors2CompilerErrors(visitorErrors));", "+//      }", "+//      System.out.println(\"Got back \" + errors.length + \" errors\");", "+      CompilerError[] compilerErrorsArray = (CompilerError[]) compilerErrors.toArray(new CompilerError[0]);", "+      if (compilerErrorsArray.length == 0) {", "+        compilerErrorsArray = compiler.compile(sourceRoots, files);", "+      }", "+//      Iterator<File> iter = filesToRestore.iterator();", "+//      while (iter.hasNext()) {", "+//        _getter.getDocumentForFile(iter.next()).revertFile();", "+//      }", "+      _distributeErrors(compilerErrorsArray);", "+      // Restore the files that were moved.", "+//      Iterator<File> iter = filesToRestore.iterator();", "+//      while (iter.hasNext()) {", "+//        File f = iter.next();", "+//        File sourceFile = new File(f.getAbsolutePath() + \".beginner\");", "+//        // Windows needs this since otherwise rename won't work.", "+//        if (f.exists()) {", "+//          f.delete();", "+//        }", "+//        sourceFile.renameTo(f);", "+//      }", "-    _distributeErrors(errors);", "+    else {", "+      _distributeErrors(new CompilerError[0]);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ae163a89b401e06004eed3f17a4ae49b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/JPDADebugger.java", "commitBeforeChange": "5c952c5847e3008cec3ed5ff89d03d335c050f54", "commitAfterChange": "e3e56a8c058b51612dfa6f1f21259a37eadcdcbb", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 61, "signatureBeforeChange": "   private void _updateWatches() throws DebugException", "signatureAfterChange": "   private void _updateWatches() throws DebugException", "diff": ["-      throw new IllegalStateException(\"Cannot update watches if there \" +", "-                                      \"are no suspended threads.\");", "+      // Not suspended, so all watches are blank", "+      for (int i = 0; i < _watches.size(); i++) {", "+        DebugWatchData currWatch = _watches.elementAt(i);", "+        currWatch.hideValueAndType();", "+      }", "+      return;", "+      // note: obj is null if we're in a static context", "+      ", "+      // Get the name to determine how many $'s there are", "+      String rtName = rt.name();", "+      int numDollars = 0;", "+      int dollarIndex = rtName.indexOf(\"$\", 0);", "+      while (dollarIndex != -1) {", "+        numDollars++;", "+        dollarIndex = rtName.indexOf(\"$\", dollarIndex+1);", "+      }", "-            currWatch.setType(obj.type());", "+            currWatch.setType(String.valueOf(obj.type()));", "-            currWatch.setValue(DebugWatchUndefinedValue.ONLY);", "-            currWatch.setType(null);", "+            // \"this\" is not defined in a static context", "+            currWatch.setNoValue();", "+            currWatch.setNoType();", "-        //List frames = null;", "+        ", "+        // Look for a variable with this name", "-        ", "-        ReferenceType outerRt = rt;", "-        ObjectReference outer = obj;", "-        // if the variable being watched is not a local variable, check if it's a field", "-        if (localVar == null) {", "+", "+        if (localVar != null) {", "+          currWatch.setValue(_getValue(currFrame.getValue(localVar)));", "+          try {", "+            currWatch.setType(String.valueOf(localVar.type()));", "+          }", "+          catch (ClassNotLoadedException cnle) {", "+            currWatch.setNoType();", "+          }", "+        }", "+        // if the variable being watched is not a local variable,", "+        //  check if it's a field", "+        else {", "+          ReferenceType outerRt = rt;", "+          ObjectReference outer = obj;  // (null if static context)", "-          ", "-          // if the variable is not a field either, it's not defined in this", "-          // ReferenceType's scope, keep going further out in scope.", "-          Field outerThis = outerRt.fieldByName(\"this$0\");", "-          ", "+", "+          // If we don't find it here, loop through any enclosing classes", "+          //  Start at this$N, where N is the number of dollar signs in", "+          //  the reference type's name, minus one.", "+          int outerIndex = numDollars - 1;", "+          Field outerThis = outerRt.fieldByName(\"this$\" + outerIndex);", "-            //outer = (ObjectReference)outer.getValue(outerThis);//currFrame.getValue(var);", "-              outerThis = outerRt.fieldByName(\"this$0\");", "+              outerIndex--;", "+              outerThis = outerRt.fieldByName(\"this$\" + outerIndex);", "-          if (field != null) {", "-            currWatch.setValue(_getValue(outer.getValue(field)));", "+          // Try to set the value and type of the field.", "+          //  If the field is not static and we are in a static context", "+          //  (outer==null), we have to setNoValue.", "+          if ((field != null) &&", "+              (field.isStatic() || (outer != null))) {", "+            Value v = (field.isStatic()) ?", "+              outerRt.getValue(field) :", "+              outer.getValue(field);", "+            currWatch.setValue(_getValue(v));", "-              currWatch.setType(field.type());", "+              currWatch.setType(String.valueOf(field.type()));", "-              currWatch.setType(null);", "+              currWatch.setNoType();", "-          /*", "-            ", "-            // crop off the $ if there is one and anything after it", "-            int indexOfDollar = className.lastIndexOf('$');", "-            if (indexOfDollar > -1) {", "-              className = className.substring(0, indexOfDollar);", "-            }", "-            else {", "-              // There is no $ in the className, we're at the outermost class and the", "-              // field still was not found", "-              break;", "-            }", "-            outerRt = (ReferenceType)_vm.classesByName(className).get(0);", "-            if (outerRt == null) {", "-              break;", "-            }", "-            field = outerRt.fieldByName(currName);", "-          }", "-          if (field != null) {", "-            // check if the field is static", "-            if (field.isStatic()) {", "-              currWatch.setValue(_getValue(outerRt.getValue(field)));", "-              try {", "-                currWatch.setType(field.type());", "-              }", "-              catch (ClassNotLoadedException cnle) {", "-                currWatch.setType(null);", "-              }", "-            }", "-            else {", "-              LocalVariable var;", "-              ObjectReference outer;", "-              do {", "-                // get the object reference for outer classes", "-                var = currFrame.visibleVariableByName(\"this$0\");", "-                outer = (ObjectReference)currFrame.getValue(var);", "-              }", "-              while (!outer.referenceType().equals(outerRt));", "-                 ", "-              */", "-          ", "-              /*", "-              StackFrame outerFrame = currFrame;", "-              // the field is not static", "-              // Check if the frame represents a native or static method and", "-              // keep going down the stack frame looking for the frame that", "-              // has the same ReferenceType that we found the Field in.", "-              // This is a hack, remove it to slightly improve performance but", "-              // at the loss of ever being able to watch outer instance", "-              // fields. If unremoved, this will work sometimes, but not always.", "-              while (outerFrame.thisObject() != null &&", "-                     !outerFrame.thisObject().referenceType().equals(outerRt) &&", "-                     stackIndex < frames.size()) {", "-                outerFrame = (StackFrame) frames.get(stackIndex);", "-                stackIndex++;", "-              }", "-              if (stackIndex < frames.size() && outerFrame.thisObject() != null) {", "-                // then we found the right stack frame", "-                currWatch.setValue(_getValue(outerFrame.thisObject().getValue(field)));", "-                try {", "-                  currWatch.setType(field.type());", "-                }", "-                catch (ClassNotLoadedException cnle) {", "-                  currWatch.setType(null);", "-                }", "-              }", "-              else {", "-                currWatch.setValue(DebugWatchUndefinedValue.ONLY);", "-                currWatch.setType(null);", "-              }", "-              ", "-            }*/", "-            currWatch.setValue(DebugWatchUndefinedValue.ONLY);", "-            currWatch.setType(null);", "+            currWatch.setNoValue();", "+            currWatch.setNoType();", "-        else {", "-          currWatch.setValue(_getValue(currFrame.getValue(localVar)));", "-          try {", "-            currWatch.setType(localVar.type());", "-          }", "-          catch (ClassNotLoadedException cnle) {", "-            currWatch.setType(null);", "-          }", "-        }", "+        "]}], "num": 1581}