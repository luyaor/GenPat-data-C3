{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b45549faaef4ddd2a4dba40eafadc169", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "011e224d2c8ac2b8d59fc023ccd989ba", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/newjvm/MainJVM.java", "commitBeforeChange": "ab54ffeb9782712c65269bca65fea798aa2c5712", "commitAfterChange": "beead1fa2c7ee24ed59761a6b295b4aa1355139e", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 43, "signatureBeforeChange": "   protected void slaveQuitDuringStartup(int status)", "signatureAfterChange": "   private void _doStartup()", "diff": ["+  /** Call invokeSlave with the appropriate JVMBuilder.  Defined here to allow for multiple attempts. */", "+  private void _doStartup() {", "+    Iterable<File> classPath;", "+    List<String> jvmArgs = new ArrayList<String>();", "+    File dir;", "+    synchronized (_startupLock) {", "+      if (_allowAssertions) { jvmArgs.add(\"-ea\"); }", "+      classPath = _startupClassPath;", "+      dir = _workingDir;", "+    }", "+    // TODO: Eliminate NULL_FILE.  It is a bad idea!  The correct behavior when it is used always depends on", "+    // context, so it can never be treated transparently.  In this case, the process won't start.", "+    if (dir == FileOps.NULL_FILE) { dir = IOUtil.WORKING_DIRECTORY; }", "+    int debugPort = _getDebugPort();", "+    String slaveMemory = DrJava.getConfig().getSetting(OptionConstants.SLAVE_JVM_XMX);", "+    if (!\"\".equals(slaveMemory) && !OptionConstants.heapSizeChoices.get(0).equals(slaveMemory)) {", "+      jvmArgs.add(\"-Xmx\" + slaveMemory + \"M\");", "+    String slaveArgs = DrJava.getConfig().getSetting(OptionConstants.SLAVE_JVM_ARGS);", "+    if (PlatformFactory.ONLY.isMacPlatform()) {", "+      jvmArgs.add(\"-Xdock:name=Interactions\");", "+    jvmArgs.addAll(ArgumentTokenizer.tokenize(slaveArgs));", "+    invokeSlave(new JVMBuilder(classPath).directory(dir).jvmArguments(jvmArgs));", "-    */", "-  protected void slaveQuitDuringStartup(int status) {", "-    super.slaveQuitDuringStartup(status);", "-    _numAttempts++;  // no synchronization since this is the only place that _numAttempts is modified", "-    if (Utilities.TEST_MODE || _numAttempts < MAX_COUNT) return;  // Some tests kill the slave immediately after it starts.", "-    ", "-    // The slave JVM is not enabled after this to prevent an infinite loop of attempted startups", "-    _restart = false;", "-    ", "-    // Signal that an internal error occurred", "-    String msg = \"Interpreter JVM exited before registering, status: \" + status;", "-    IllegalStateException e = new IllegalStateException(msg);", "-    new edu.rice.cs.drjava.ui.DrJavaErrorHandler().handle(e);", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f45d1648813f73bcb96cfd79db771b37", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/repl/newjvm/MainJVM.java", "commitBeforeChange": "ab54ffeb9782712c65269bca65fea798aa2c5712", "commitAfterChange": "beead1fa2c7ee24ed59761a6b295b4aa1355139e", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 1, "signatureBeforeChange": "   public void startInterpreterJVM()", "signatureAfterChange": "   public void startInterpreterJVM()", "diff": ["+  /** Starts the interpreter if it's not running already. */", "+  public void startInterpreterJVM() {", "+    debug.logStart();", "+", "+    boolean alreadyStarted;", "+    synchronized (_startupLock) {", "+      alreadyStarted = (_interpreterJVM.value() != null || !_startupComplete.isSignaled());", "+      if (!alreadyStarted) {", "+        _startupComplete.reset();", "+        _startupAttempts = 1;", "+      }", "+    }", "+    if (alreadyStarted) { debug.log(\"Already started\"); }", "+    else { _doStartup(); }", "+    debug.logEnd();", "+  }", "-  /** Starts the interpreter if it's not running already. */", "-  public void startInterpreterJVM() {", "-    _log.log(this + \".startInterpreterJVM() called\");", "-//    synchronized(_masterJVMLock) {  // synch is unnecessary", "-    if (isStartupInProgress() || isInterpreterRunning())  return;  // These predicates simply check volatile boolean flags", "-//    }", "-    // Pass assertion and debug port information as JVM arguments", "-    ArrayList<String> jvmArgs = new ArrayList<String>();", "-    if (allowAssertions())  jvmArgs.add(\"-ea\");", "-    int debugPort = getDebugPort();", "-    _log.log(\"Main JVM starting with debug port: \" + debugPort);", "-    // Cannot do the following line because it causes an error on Macs in the Eclipse plug-in.", "-    // By instantiating the config, somehow the Apple JVM tries to start up AWT, which seems", "-    // to be prohibited by Eclipse.  Badness ensues.", "-    //    String optionArgString = DrJava.getConfig().getSetting(OptionConstants.JVM_ARGS);", "-    //    List<String> optionArgs = ArgumentTokenizer.tokenize(optionArgString);", "-    jvmArgs.addAll(_optionArgs);", "-    String[] jvmArgsArray = new String[jvmArgs.size()];", "-    for (int i = 0; i < jvmArgs.size(); i++) { jvmArgsArray[i] = jvmArgs.get(i); }", "-    ", "-    // Create and invoke the Interpreter JVM", "-    _numAttempts = 0;", "-    try {", "-      // _startupClasspath is sent in as the interactions classpath", "-//      Utilities.show(\"Calling invokeSlave(\" + jvmArgs + \", \" + _startupClassPath + \", \" +  _workDir +\")\");", "-      invokeSlave(jvmArgsArray, IOUtil.pathToString(_startupClassPath), _workDir);", "-      _slaveJVMUsed = false;", "-    catch (RemoteException re) { _threwException(re); }", "-    catch (IOException ioe) { _threwException(ioe); }", "-  }"]}], "num": 24241}