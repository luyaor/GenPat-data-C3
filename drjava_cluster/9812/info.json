{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "de1a8e0289ad5086593d05dba5191d6e", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a9227edec3a2356fe8ad6592b38eb909", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 359, "methodNumberAfterChange": 290, "signatureBeforeChange": "   private ClassType lookupClass(Type t, Lambda<? super Boolean, ? extends Predicate<? super DJClass>> makePred,                                 Iterable<? extends Type> typeArgs, String name)     throws InvalidTargetException, InvalidTypeArgumentException, UnmatchedLookupException", "signatureAfterChange": "     public ClassType findSingleClass(Type t) throws InvalidTypeArgumentException, UnmatchedLookupException", "diff": ["+     */", "+    public ClassType findSingleClass(Type t) throws InvalidTypeArgumentException, UnmatchedLookupException {", "+      debug.logStart(new String[]{\"t\",\"name\",\"typeArgs\", \"onlyStatic\"},", "+                     wrap(t), _name, wrap(_typeArgs), _onlyStatic); try {", "+                       ", "+      Iterable<ClassType> results = findFirst(t);", "+      // TODO: provide more error-message information", "+      int matches = IterUtil.sizeOf(results);", "+      if (matches != 1) { throw new UnmatchedLookupException(matches); }", "+      else {", "+        ClassType result = IterUtil.first(results);", "+        final Iterable<VariableType> params = SymbolUtil.allTypeParameters(result.ofClass());", "+        try {", "+          return result.apply(new TypeAbstractVisitor<ClassType>() {", "+            public ClassType defaultCase(Type t) { throw new IllegalArgumentException(); }", "+            ", "+            @Override public ClassType forSimpleClassType(SimpleClassType t) {", "+              if (IterUtil.isEmpty(params)) { return t; }", "+              else { return new RawClassType(t.ofClass()); }", "+            }", "+            ", "+            @Override public ClassType forRawClassType(RawClassType t) {", "+              return t;", "+            }", "+            ", "+            @Override public ClassType forParameterizedClassType(ParameterizedClassType t) {", "+              try {", "+                if (IterUtil.sizeOf(params) != IterUtil.sizeOf(t.typeArguments())) {", "+                  throw new InvalidTypeArgumentException();", "+                }", "+                return t;", "+              }", "+              catch (InvalidTypeArgumentException e) { throw new WrappedException(e); }", "+            }", "+          });", "+        }", "+        catch (WrappedException e) {", "+          if (e.getCause() instanceof InvalidTypeArgumentException) {", "+            throw (InvalidTypeArgumentException) e.getCause();", "+          }", "+          else { throw e; }", "+        }", "+      }", "+      ", "+      } finally { debug.logEnd(); }", "+    }", "-  /** Look up an inner class based on the given predicate. */", "-  private ClassType lookupClass(Type t, Lambda<? super Boolean, ? extends Predicate<? super DJClass>> makePred,", "-                                Iterable<? extends Type> typeArgs, String name)", "-    throws InvalidTargetException, InvalidTypeArgumentException, UnmatchedLookupException {", "-    Iterable<? extends ClassType> results = lookupClasses(t, makePred, typeArgs);", "-    // TODO: provide more error-message information", "-    int matches = IterUtil.sizeOf(results);", "-    if (matches != 1) { throw new UnmatchedLookupException(matches); }", "-    else {", "-      ClassType result = IterUtil.first(results);", "-      final Iterable<VariableType> params = SymbolUtil.allTypeParameters(result.ofClass());", "-      try {", "-        return result.apply(new TypeAbstractVisitor<ClassType>() {", "-          public ClassType defaultCase(Type t) { throw new IllegalArgumentException(); }", "-          ", "-          @Override public ClassType forSimpleClassType(SimpleClassType t) {", "-            if (IterUtil.isEmpty(params)) { return t; }", "-            else { return new RawClassType(t.ofClass()); }", "-          }", "-          ", "-          @Override public ClassType forRawClassType(RawClassType t) {", "-            return t;", "-          }", "-          ", "-          @Override public ClassType forParameterizedClassType(ParameterizedClassType t) {", "-            try {", "-              if (IterUtil.sizeOf(params) != IterUtil.sizeOf(t.typeArguments())) {", "-                throw new InvalidTypeArgumentException();", "-              }", "-              return t;", "-            }", "-            catch (InvalidTypeArgumentException e) { throw new WrappedException(e); }", "-          }", "-        });", "-      }", "-      catch (WrappedException e) {", "-        if (e.getCause() instanceof InvalidTypeArgumentException) {", "-          throw (InvalidTypeArgumentException) e.getCause();", "-        }", "-        else { throw e; }", "-      }", "-    }", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dc024bf0dc906173b90a85a333f3fae3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/junit/JUnitTestManager.java", "commitBeforeChange": "771a0aee635c62bc6d0a2000fe605dc1113ef2b9", "commitAfterChange": "d1e56ac5c281c4b03c498f59138895f0f26350fa", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public List<String> runTest(final List<String> classNames, final List<File> files,                               final boolean isTestAll)", "signatureAfterChange": "   public synchronized boolean runTestSuite()", "diff": ["-  public List<String> runTest(final List<String> classNames, final List<File> files,", "-                              final boolean isTestAll) {", "-    final ArrayList<String> testClassNames = new ArrayList<String>();", "-    synchronized (testClassNames) {", "-      _testRunner = new JUnitTestRunner(_jmc);", "-      new Thread(\"JUnit Test Thread\") {", "-        public void run() {", "-          try {", "-            boolean noJUnitTests = true;", "-            TestSuite suite = new TestSuite();", "-            synchronized (testClassNames) {", "-              try {", "-                for (int i = 0; i < classNames.size(); i++) {", "-                  String className = classNames.get(i);", "-                  if (_isTestCase(className)) {", "-                    Test test = _testRunner.getTest(className);", "-                    suite.addTest(test);", "-                    testClassNames.add(className);", "-                    noJUnitTests = false;", "-                  }", "-                }", "-              }", "-              finally { testClassNames.notify(); }", "-            }", "-            if (noJUnitTests) {", "-              _jmc.nonTestCase(isTestAll);", "-              //            _jmc.testSuiteEnded(new JUnitError[] {new JUnitError(null, \"No JUnit tests open!\", false, \"\")});", "-              return;", "-            }", "-            TestResult result = _testRunner.doRun(suite);", "-", "-            JUnitError[] errors = new JUnitError[result.errorCount() + result.failureCount()];", "-", "-            Enumeration failures = result.failures();", "-            Enumeration errEnum = result.errors();", "-", "-            int i = 0;", "-", "-            while (errEnum.hasMoreElements()) {", "-              TestFailure tErr = (TestFailure) errEnum.nextElement();", "-              errors[i] = _makeJUnitError(tErr, classNames, true, files);", "-              i++;", "-            }", "-            while (failures.hasMoreElements()) {", "-              TestFailure tFail = (TestFailure) failures.nextElement();", "-              errors[i] = _makeJUnitError(tFail, classNames, false, files);", "-              i++;", "-            }", "-            _jmc.testSuiteEnded(errors);", "-          }", "-          catch (Throwable t) {", "-            _failedWithError(t);", "-          }", "-        }", "-      }.start();", "-      try {", "-        testClassNames.wait();", "-      }", "-      catch (InterruptedException ex) {", "-    return testClassNames;", "+   */", "+  public synchronized boolean runTestSuite() {", "+    ", "+    if (_testClassNames == null || _testClassNames.isEmpty()) return false;", "+    ", "+//    new ScrollableDialog(null, \"runTestSuite() in SlaveJVM called\", \"\", \"\").show();", "+    try {", "+      TestResult result = _testRunner.doRun(_suite);", "+    ", "+      JUnitError[] errors = new JUnitError[result.errorCount() + result.failureCount()];", "+      ", "+      Enumeration failures = result.failures();", "+      Enumeration errEnum = result.errors();", "+      ", "+      int i = 0;", "+      ", "+      while (errEnum.hasMoreElements()) {", "+        TestFailure tErr = (TestFailure) errEnum.nextElement();", "+        errors[i] = _makeJUnitError(tErr, _testClassNames, true, _testFiles);", "+        i++;", "+      }", "+      ", "+      while (failures.hasMoreElements()) {", "+        TestFailure tFail = (TestFailure) failures.nextElement();", "+        errors[i] = _makeJUnitError(tFail, _testClassNames, false, _testFiles);", "+        i++;", "+      }", "+//      new ScrollableDialog(null, \"Slave JVM: testSuite ended with errors\", \"\", Arrays.toString(errors)).show();", "+      ", "+      _jmc.testSuiteEnded(errors);", "+    }", "+    catch(Throwable t) { ", "+      JUnitError[] errors = new JUnitError[1];", "+      errors[0] = new JUnitError(null, -1, -1, t.getMessage(),", "+                                 false, \"\", \"\", StringOps.getStackTrace(t));", "+      _jmc.testSuiteEnded(errors);", "+       // new ScrollableDialog(null, \"Slave JVM: testSuite ended with errors\", \"\", Arrays.toString(errors)).show();", "+      ", "+    }", "+    finally {", "+      _suite = null;", "+      _testClassNames = null;", "+      _testFiles = null;", "+    }", "+    return true;"]}], "num": 9812}