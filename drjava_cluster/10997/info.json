{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "590b3ff17afa549c2f0411e92c04f834", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c359a49dfe635ef7703b077055c05640", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/DefaultCompilerModel.java", "commitBeforeChange": "2df0898882e5e96efc3a0e1f26666331fe161926", "commitAfterChange": "149da2b3620a4f7e40666414f25f32856665a055", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "   private List<? extends File> _compileLanguageLevelsFiles(List<? extends File> files, List<DJError> errors,                                                            Iterable<File> classPath, Iterable<File> bootClassPath)", "signatureAfterChange": "   private List<? extends File> _compileLanguageLevelsFiles(List<? extends File> files, List<DJError> errors,                                                            Iterable<File> classPath, Iterable<File> bootClassPath)", "diff": ["-    LanguageLevelConverter llc = new LanguageLevelConverter();", "-    Options llOpts;", "-    if (bootClassPath == null) { llOpts = new Options(getActiveCompiler().version(), classPath); }", "-    else { llOpts = new Options(getActiveCompiler().version(), classPath, bootClassPath); }", "-    Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>> llErrors = ", "-      llc.convert(files.toArray(new File[0]), llOpts);", "-    ", "-        javaFileSet.add(new File(fileName.substring(0, lastIndex) + \".java\"));", "+        File javaFile = new File( fileName.substring(0, lastIndex) + \".java\");", "+        javaFileSet.add(javaFile);", "+", "+        // Delete the .java file, it will be regenerated later", "+        javaFile.delete();", "+    ", "+    LanguageLevelConverter llc = new LanguageLevelConverter();", "+    Options llOpts;", "+    if (bootClassPath == null) { llOpts = new Options(getActiveCompiler().version(), classPath); }", "+    else { llOpts = new Options(getActiveCompiler().version(), classPath, bootClassPath); }", "+    Map<File,Set<String>> sourceToTopLevelClassMap = new HashMap<File,Set<String>>();", "+    Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>> llErrors = ", "+      llc.convert(files.toArray(new File[0]), llOpts, sourceToTopLevelClassMap);", "+    ", "+    if (containsLanguageLevels) {", "+      final File buildDir = _model.getBuildDirectory();", "+      final File sourceDir = _model.getProjectRoot();", "+//      System.out.println(\"Build dir  : \"+buildDir);", "+//      System.out.println(\"Source root: \"+sourceDir);", "+      // Delete the .class files that match the following pattern:", "+      // XXX.dj? --> XXX.class", "+      //             XXX$*.class", "+      // Accessing the disk is the most costly part; therefore, we want to scan each directory only once.", "+      // We create a map from parent directory to class names in that directory.", "+      // Then we scan the files in each directory and delete files that match the class names listed for it.", "+      // dirToClassNameMap: key=parent directory, value=set of classes in this directory", "+      Map<File,Set<String>> dirToClassNameMap = new HashMap<File,Set<String>>();", "+      for(Map.Entry<File,Set<String>> e: sourceToTopLevelClassMap.entrySet()) {", "+        try {", "+          File dir = e.getKey().getParentFile();", "+          if ((buildDir!=null)&&(buildDir!=FileOps.NULL_FILE)&&", "+              (sourceDir!=null)&&(sourceDir!=FileOps.NULL_FILE)) {", "+            // build directory set", "+            String rel = edu.rice.cs.util.FileOps.stringMakeRelativeTo(dir,sourceDir);", "+            dir = new File(buildDir,rel);", "+          }", "+          Set<String> classNames = dirToClassNameMap.get(dir);", "+          if (classNames==null) classNames = new HashSet<String>();", "+          classNames.addAll(e.getValue());", "+          dirToClassNameMap.put(dir,classNames);", "+//          System.out.println(e.getKey()+\" --> \"+dir);", "+//          for(String name: e.getValue()) {", "+//            System.out.println(\"\\t\"+name);", "+//          }", "+        }", "+        catch(IOException ioe) { /* we'll fail to delete this, but that's better than deleting something we shouldn't */ }", "+      }", "+      // Now that we have a map from parent directories to the class names that should be deleted", "+      // in them, we scan the files in each directory, then check if the names match the class names.      ", "+      for(final Map.Entry<File,Set<String>> e: dirToClassNameMap.entrySet()) {", "+//        System.out.println(\"Processing dir: \"+e.getKey());", "+//        System.out.println(\"\\t\"+java.util.Arrays.toString(e.getValue().toArray(new String[0])));", "+        e.getKey().listFiles(new java.io.FilenameFilter() {", "+          public boolean accept(File dir, String name) {", "+//            System.out.println(\"\\t\"+name);", "+            int endPos = name.lastIndexOf(\".class\");", "+            if (endPos<0) return false; // can't be a class file", "+            int dollarPos = name.indexOf('$');", "+            if ((dollarPos>=0) && (dollarPos<endPos)) endPos = dollarPos;", "+            // class name goes to the .class or the first $, whichever comes first", "+            Set<String> classNames = e.getValue();", "+            if (classNames.contains(name.substring(0,endPos))) { ", "+              // this is a class file that is generated from a .dj? file", "+              new File(dir,name).delete();", "+              // don't need to return true, we're deleting the file here already", "+//              System.out.println(\"\\t\\tDeleted\");", "+            }", "+            return false;", "+          }", "+        });", "+      }", "+    }", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "df90e8148083b1c2226d0c176719806d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/DefaultCompilerModel.java", "commitBeforeChange": "34cf34867ac9dce276fc29b1ebccbc3b04558150", "commitAfterChange": "a84367d6c7dd279d0237f04d04b6df32e0ca3dea", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "   private List<File> _compileLanguageLevelsFiles(List<File> files, List<DJError> errors,                                                            Iterable<File> classPath, Iterable<File> bootClassPath)", "signatureAfterChange": "   private List<File> _compileLanguageLevelsFiles(List<File> files, List<DJError> errors,                                                            Iterable<File> classPath, Iterable<File> bootClassPath)", "diff": ["-        ", "-      Map<File,Set<String>> sourceToTopLevelClassMap = new HashMap<File,Set<String>>();", "+      /* Check if we should delete class files in directories with language level files. */", "-//      System.out.println(\"Build dir  : \"+buildDir);", "-//      System.out.println(\"Source root: \"+sourceDir);", "-      // Delete the .class files that match the following pattern:", "-      // XXX.dj? --> XXX.class", "-      //             XXX$*.class", "-      // Accessing the disk is the most costly part; therefore, we want to scan each directory only once.", "-      // We create a map from parent directory to class names in that directory.", "-      // Then we scan the files in each directory and delete files that match the class names listed for it.", "-      // dirToClassNameMap: key=parent directory, value=set of classes in this directory", "-      Map<File,Set<String>> dirToClassNameMap = new HashMap<File,Set<String>>();", "-      for(Map.Entry<File,Set<String>> e: sourceToTopLevelClassMap.entrySet()) {", "-        try {", "-          File dir = e.getKey().getParentFile();", "-          if (buildDir != null && buildDir != FileOps.NULL_FILE &&", "-              sourceDir != null && sourceDir != FileOps.NULL_FILE) {", "-            // build directory set", "-            String rel = edu.rice.cs.util.FileOps.stringMakeRelativeTo(dir,sourceDir);", "-            dir = new File(buildDir,rel);", "+      if (!DrJava.getConfig().getSetting(OptionConstants.DELETE_LL_CLASS_FILES)", "+            .equals(OptionConstants.DELETE_LL_CLASS_FILES_CHOICES.get(0))) {", "+        // not \"never\"", "+        final HashSet<File> dirsWithLLFiles = new HashSet<File>();", "+        for(File f: newFiles) {", "+          try {", "+            File dir = f.getParentFile();", "+            if (buildDir != null && buildDir != FileOps.NULL_FILE &&", "+                sourceDir != null && sourceDir != FileOps.NULL_FILE) {", "+              // build directory set", "+              String rel = edu.rice.cs.util.FileOps.stringMakeRelativeTo(dir,sourceDir);", "+              dir = new File(buildDir,rel);", "+            }            ", "+            dirsWithLLFiles.add(dir);", "-          Set<String> classNames = dirToClassNameMap.get(dir);", "-          if (classNames == null) classNames = new HashSet<String>();", "-          classNames.addAll(e.getValue());", "-          dirToClassNameMap.put(dir,classNames);", "-//          System.out.println(e.getKey()+\" --> \"+dir);", "-//          for(String name: e.getValue()) {", "-//            System.out.println(\"\\t\"+name);", "-//          }", "+          catch(IOException ioe) { /* just don't add this directory */ }", "-        catch(IOException ioe) { /* we'll fail to delete this, but that's better than deleting something we shouldn't */ }", "-      }", "-      // Now that we have a map from parent directories to the class names that should be deleted", "-      // in them, we scan the files in each directory, then check if the names match the class names.      ", "-      for(final Map.Entry<File,Set<String>> e: dirToClassNameMap.entrySet()) {", "-//        System.out.println(\"Processing dir: \"+e.getKey());", "-//        System.out.println(\"\\t\"+java.util.Arrays.toString(e.getValue().toArray(new String[0])));", "-        e.getKey().listFiles(new java.io.FilenameFilter() {", "-          public boolean accept(File dir, String name) {", "-//            System.out.println(\"\\t\"+name);", "-            int endPos = name.lastIndexOf(\".class\");", "-            if (endPos < 0) return false; // can't be a class file", "-            int dollarPos = name.indexOf('$');", "-            if ((dollarPos >= 0) && (dollarPos < endPos)) endPos = dollarPos;", "-            // class name goes to the .class or the first $, whichever comes first", "-            Set<String> classNames = e.getValue();", "-            if (classNames.contains(name.substring(0,endPos))) { ", "-              // this is a class file that is generated from a .dj? file", "+        ", "+        if (DrJava.getConfig().getSetting(OptionConstants.DELETE_LL_CLASS_FILES)", "+            .equals(OptionConstants.DELETE_LL_CLASS_FILES_CHOICES.get(1))) {", "+          // \"ask me\"", "+          final JButton deleteButton = new JButton(new AbstractAction(\"Delete Class Files\") {", "+            public void actionPerformed(ActionEvent e) {", "+              // no op", "+            }", "+          });", "+          final JButton keepButton = new JButton(new AbstractAction(\"Keep Class Files\") {", "+            public void actionPerformed(ActionEvent e) {", "+              // clear the set, i.e. do not delete anything", "+              dirsWithLLFiles.clear();", "+            }", "+          });", "+          ScrollableListDialog<File> dialog = new ScrollableListDialog.Builder<File>()", "+            .setTitle(\"Delete Class Files\")", "+            .setText(\"We suggest that you delete all class files in the directories with language\\n\"+", "+                     \"level files. Do you want to delete the class files in the following directories?\")", "+            .setItems(new ArrayList<File>(dirsWithLLFiles))", "+            .setMessageType(JOptionPane.QUESTION_MESSAGE)", "+            .setFitToScreen(true)", "+            .clearButtons()", "+            .addButton(deleteButton)", "+            .addButton(keepButton)", "+            .build();", "+          ", "+          dialog.showDialog();", "+        }", "+        ", "+        // Delete all class files in the directories listed. If the user was asked and said \"keep\",", "+        // then the set will be empty", "+        for(File f: dirsWithLLFiles) {", "+          f.listFiles(new java.io.FilenameFilter() {", "+            public boolean accept(File dir, String name) {", "+              int endPos = name.lastIndexOf(\".class\");", "+              if (endPos < 0) return false; // can't be a class file", "-//              System.out.println(\"\\t\\tDeleted\");", "+              return false;", "-            return false;", "-          }", "-        });", "+          });", "+        }", "+      ", "+      Map<File,Set<String>> sourceToTopLevelClassMap = new HashMap<File,Set<String>>();", "-//      // Confirm that the .java files corresponding to .dj* files exist.", "-//      for (File f: newFiles)", "-//        if (! f.exists()) Utilities.show(f + \" does not exist\");", "-", "+      // Since we (optionally) delete all class files in LL directories, we don't need the code", "+      // to smart-delete class files anymore.", "+      // smartDeleteClassFiles(sourceToTopLevelClassMap);"]}], "num": 10997}