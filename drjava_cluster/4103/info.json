{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9184babeed74be4c35c4c7607357bdd7", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "55318447a2a12227e7883c65134a68ca", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/project/ProjectFileParser.java", "commitBeforeChange": "e99723007606c50032c4a82ba80b9d94aaabe6bc", "commitAfterChange": "958f548f8cc751514e1497672b492b70657c4b6e", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "   private void evaluateExpression(SEList e, ProjectFileIR pfir, DocFileListVisitor flv) throws IOException", "signatureAfterChange": "   private void evaluateExpression(SEList e, ProjectFileIR pfir, DocFileListVisitor flv) throws IOException", "diff": ["-      List<DocFile> fList = exp.getRest().accept(flv);", "-      if (fList.size() > 1) throw new PrivateProjectException(\"Cannot have multiple main classes\");", "-      else if (fList.size() == 0) pfir.setMainClass(null);", "-      else pfir.setMainClass(fList.get(0));", "+      try{", "+        List<DocFile> fList = exp.getRest().accept(flv);", "+        if(fList.size() == 1){", "+          String main = fList.get(0).getPath().replace(File.separatorChar,'.');", "+          main = main.substring(0, main.length() - 5);", "+          ", "+          pfir.setMainClass(main);", "+          ", "+          return;", "+        }", "+      }catch(Exception exc){}", "+      ", "+      String mainClass = exp.getRest().accept(NameVisitor.ONLY);", "+      pfir.setMainClass(mainClass);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "df0f33784c851515a573f277708b17eb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/DefinitionsPaneMemoryLeakTest.java", "commitBeforeChange": "1591118711b9174a5cd4314e14319296b969ee78", "commitAfterChange": "deb4bbe3644e2d17508378353337903e5f2c956b", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 10, "signatureBeforeChange": "           public void testDocumentPaneMemoryLeak() throws InterruptedException, IOException", "signatureAfterChange": "           public void testDocumentPaneMemoryLeak() throws InterruptedException, IOException", "diff": ["+    println(\"---- testDocumentPaneMemoryLeak ----\");", "+", "-    while (ct < 10 && (_finalDocCt < 6 || _finalPaneCt < 6));", "+    while (ct < 10 && (_finalDocCt < PANE_COUNT || _finalPaneCt < PANE_COUNT));", "-//    if (ct == 10) {", "-//      // if we fail with a garbage collection problem, dump heap", "-//      LOG.setEnabled(true);", "-////      LOG.log(sbIdHashCodes.toString());", "-//      try { LOG.log(\"heap dump in \"+dumpHeap()); }", "-//      catch(Exception e) {", "-//        System.err.println(\"Could not dump heap.\");", "-//        e.printStackTrace(System.err);", "-//      }", "-//      ", "-//      fail(\"Failed to reclaim all documents; panes left = \" + (6 - _finalPaneCt) + \"; docs left = \" + ", "-//           (6 - _finalDocCt));", "-//    }", "+    if (DUMP_STACK && (ct == 10)) {", "+      // if we fail with a garbage collection problem, dump heap", "+      boolean isEnabled = LOG.isEnabled();", "+      LOG.setEnabled(true);", "+      LOG.log(sbIdHashCodes.toString());", "+      try { LOG.log(\"heap dump in \"+dumpHeap()); }", "+      catch(Exception e) {", "+        println(\"Could not dump heap.\");", "+        e.printStackTrace(System.err);", "+      }", "+      LOG.setEnabled(isEnabled);", "+      ", "+      // Note: see http://www.concurrentaffair.org/2010/06/03/not-a-memory-leak-but-not-finalized/", "+      //", "+      // We are not using finalization to check for memory leaks anymore. We are using the assertGC", "+      // method instead. Finalization is a fundamentally flawed way of checking for garbage collection.", "+      // ", "+      // The creation context stores the stack trace when the instance is created, and I can tell", "+      // that one of these documents was created when DrJava was initially started, and the other after", "+      // all documents have been closed. These aren't the documents that need to be garbage-collected.", "+      //", "+      // --Mathias", "+      ", "+//      assertEquals(\"Failed to reclaim all panes; panes left = \" + (PANE_COUNT - _finalPaneCt) + \"; docs left = \" + ", "+//                   (PANE_COUNT - _finalDocCt), PANE_COUNT, _finalPaneCt);", "+//      assertEquals(\"Failed to reclaim all documents; panes left = \" + (PANE_COUNT - _finalPaneCt) + \"; docs left = \" + ", "+//                   (PANE_COUNT - _finalDocCt), PANE_COUNT, _finalDocCt);", "+    }", "-    if (ct > 1) System.out.println(\"testDocumentPaneMemoryLeak required \" + ct + \" iterations\");", "+    if (ct > 1) println(\"testDocumentPaneMemoryLeak required \" + ct + \" iterations\");", "-    assertEquals(\"all the defdocs should have been garbage collected\", 6, _finalDocCt);", "-    assertEquals(\"all the defpanes should have been garbage collected\", 6,  _finalPaneCt);    ", "+//    assertEquals(\"all the defdocs should have been garbage collected\", PANE_COUNT, _finalDocCt);", "+//    assertEquals(\"all the defpanes should have been garbage collected\", PANE_COUNT,  _finalPaneCt);    "]}], "num": 4103}