{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1f114ab1b17ecb4b4b67e4cc5b04efe7", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "27db64b3cef4f62b2edb01fc0f222e00", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/context/StaticContext.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "     public Class setProperties(ClassAllocation node, Class c, Class[] args, List memb)", "signatureAfterChange": "   public Class setProperties(ClassAllocation node, Class c, Class[] args, List<Node> memb)", "diff": ["-     */", "-    public Class setProperties(ClassAllocation node, Class c, Class[] args, List memb) {", "-\tString dname = declaringClass.getName();", "-\tString cname = dname + \"$\" + classCount++;", "-\tFieldDeclaration fd;", "-\tConstructorDeclaration csd;", "-\t", "-\t// Create the reference to the declaring class", "-\tfd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "-\t\t\t\t  CLASS_TYPE,", "-\t\t\t\t  \"declaring$Class$Reference$0\",", "-\t\t\t\t  new TypeExpression(new ReferenceType(dname)));", "-\tmemb.add(fd);", "-", "-\t// Add the reference to the final local variables map", "-\tmemb.add(LOCALS);", "-", "-\t// Create the reference to the final local variables map", "-\tfd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "-\t\t\t\t  OBJECT_ARRAY_ARRAY,", "-\t\t\t\t  \"local$Variables$Class$0\",", "-\t\t\t\t  createClassArrayInitializer());", "-\tmemb.add(fd);", "-", "-\t// Create the constructor", "-\tList params = new LinkedList();", "-\tList stmts = new LinkedList();", "-", "-\t// Add the final local variables map parameter", "-\tparams.add(new FormalParameter(false, MAP_TYPE, \"param$0\"));", "-", "-\t// Add the other parameters", "-\tList superArgs = new LinkedList();", "-\tfor (int i = 0; i < args.length; i++) {", "-\t    params.add(new FormalParameter(false, ", "-\t\t\t\t\t   TreeUtilities.classToType(args[i]),", "-\t\t\t\t\t   \"param$\" + (i + 1)));", "-\t    List l = new LinkedList();", "-\t    l.add(new Identifier(\"param$\" + (i + 1)));", "-\t    superArgs.add(new QualifiedName(l));", "-\t}", "-", "-\t// Create the explicit constructor invocation", "-        ConstructorInvocation ci = null;", "-        if (superArgs.size() > 0) {", "-            ci = new ConstructorInvocation(null, superArgs, true);", "-\t", "-\t// Add the outer instance reference initialization statement", "-\tList p1 = new LinkedList();", "-\tp1.add(new Identifier(\"local$Variables$Reference$0\"));", "-\tList p2 = new LinkedList();", "-\tp2.add(new Identifier(\"param$0\"));", "-\tstmts.add(new SimpleAssignExpression(new QualifiedName(p1),", "-\t\t\t\t\t     new QualifiedName(p2)));", "-\t", "-\tcsd = new ConstructorDeclaration(Modifier.PUBLIC,", "-\t\t\t\t\t cname,", "-\t\t\t\t\t params,", "-\t\t\t\t\t new LinkedList(),", "-\t\t\t\t\t ci,", "-\t\t\t\t\t stmts);", "-\tmemb.add(csd);", "-", "-\t// Set the inheritance", "-\tList ext = null;", "-\tList impl = null;", "-\tif (c.isInterface()) {", "-\t    impl = new LinkedList();", "-\t    List intf = new LinkedList();", "-\t    intf.add(new Identifier(c.getName()));", "-\t    impl.add(intf);", "-\t} else {", "-\t    ext = new LinkedList();", "-\t    ext.add(new Identifier(c.getName()));", "-\t}", "-\t", "-\t// Create the class", "-\tTypeDeclaration type = new ClassDeclaration(Modifier.PUBLIC,", "-\t\t\t\t\t\t    cname,", "-\t\t\t\t\t\t    ext,", "-\t\t\t\t\t\t    impl,", "-\t\t\t\t\t\t    memb);", "-", "-\ttype.setProperty(TreeClassInfo.ANONYMOUS_DECLARING_CLASS,", "-\t\t\t new JavaClassInfo(declaringClass));", "-", "-\tClass cl = new TreeCompiler(interpreter).compileTree(this, type);", "-", "-\t// Update the argument types", "-\tClass[] tmp = new Class[args.length+1];", "-\ttmp[0] = Map.class;", "-\tfor (int i = 1; i < tmp.length; i++) {", "-\t    tmp[i] = args[i - 1];", "-\t}", "-\targs = tmp;", "-\ttry {", "-\t    node.setProperty(NodeProperties.CONSTRUCTOR, lookupConstructor(cl, args));", "-\t} catch (NoSuchMethodException e) {", "-\t    // Never get here", "-\t    e.printStackTrace();", "-\t}", "-\tnode.setProperty(NodeProperties.TYPE, cl);", "-\treturn cl;", "+   */", "+  public Class setProperties(ClassAllocation node, Class c, Class[] args, List<Node> memb) {", "+    String dname = declaringClass.getName();", "+    String cname = dname + \"$\" + classCount++;", "+    FieldDeclaration fd;", "+    ConstructorDeclaration csd;", "+    ", "+    // Create the reference to the declaring class", "+    fd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "+                              CLASS_TYPE,", "+                              \"declaring$Class$Reference$0\",", "+                              new TypeExpression(new ReferenceType(dname)));", "+    memb.add(fd);", "+    ", "+    // Add the reference to the final local variables map", "+    memb.add(LOCALS);", "+    ", "+    // Create the reference to the final local variables map", "+    fd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "+                              OBJECT_ARRAY_ARRAY,", "+                              \"local$Variables$Class$0\",", "+                              createClassArrayInitializer());", "+    memb.add(fd);", "+    ", "+    // Create the constructor", "+    List<FormalParameter> params = new LinkedList<FormalParameter>();", "+    List<Node> stmts = new LinkedList<Node>();", "+    ", "+    // Add the final local variables map parameter", "+    params.add(new FormalParameter(false, MAP_TYPE, \"param$0\"));", "+    ", "+    // Add the other parameters", "+    List<Expression> superArgs = new LinkedList<Expression>();", "+    for (int i = 0; i < args.length; i++) {", "+      params.add(new FormalParameter(false, ", "+                                     TreeUtilities.classToType(args[i]),", "+                                     \"param$\" + (i + 1)));", "+      List<IdentifierToken> l = new LinkedList<IdentifierToken>();", "+      l.add(new Identifier(\"param$\" + (i + 1)));", "+      superArgs.add(new QualifiedName(l));", "+    // Create the explicit constructor invocation", "+    ConstructorInvocation ci = null;", "+    if (superArgs.size() > 0) {", "+      ci = new ConstructorInvocation(null, superArgs, true);", "+    ", "+    // Add the outer instance reference initialization statement", "+    List<IdentifierToken> p1 = new LinkedList<IdentifierToken>();", "+    p1.add(new Identifier(\"local$Variables$Reference$0\"));", "+    List<IdentifierToken> p2 = new LinkedList<IdentifierToken>();", "+    p2.add(new Identifier(\"param$0\"));", "+    stmts.add(new SimpleAssignExpression(new QualifiedName(p1),", "+                                         new QualifiedName(p2)));", "+    ", "+    csd = new ConstructorDeclaration(Modifier.PUBLIC,", "+                                     cname,", "+                                     params,", "+                                     new LinkedList<List<IdentifierToken>>(),", "+                                     ci,", "+                                     stmts);", "+    memb.add(csd);", "+    ", "+    // Set the inheritance", "+    List<IdentifierToken> ext = null;", "+    List<List<IdentifierToken>> impl = null;", "+    if (c.isInterface()) {", "+      impl = new LinkedList<List<IdentifierToken>>();", "+      List<IdentifierToken> intf = new LinkedList<IdentifierToken>();", "+      intf.add(new Identifier(c.getName()));", "+      impl.add(intf);", "+    } else {", "+      ext = new LinkedList<IdentifierToken>();", "+      ext.add(new Identifier(c.getName()));", "+    ", "+    // Create the class", "+    TypeDeclaration type = new ClassDeclaration(Modifier.PUBLIC,", "+                                                cname,", "+                                                ext,", "+                                                impl,", "+                                                memb);", "+    ", "+    type.setProperty(TreeClassInfo.ANONYMOUS_DECLARING_CLASS,", "+                     new JavaClassInfo(declaringClass));", "+    ", "+    Class cl = new TreeCompiler(interpreter).compileTree(this, type);", "+    ", "+    // Update the argument types", "+    Class[] tmp = new Class[args.length+1];", "+    tmp[0] = Map.class;", "+    for (int i = 1; i < tmp.length; i++) {", "+      tmp[i] = args[i - 1];", "+    }", "+    args = tmp;", "+    try {", "+      node.setProperty(NodeProperties.CONSTRUCTOR, lookupConstructor(cl, args));", "+    } catch (NoSuchMethodException e) {", "+      // Never get here", "+      e.printStackTrace();", "+    }", "+    node.setProperty(NodeProperties.TYPE, cl);", "+    return cl;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34c4643333f27d0eef824890bc2fd83e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/context/GlobalContext.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "     public Class setProperties(ClassAllocation node, Class c, Class[] args, List memb)", "signatureAfterChange": "   public Class setProperties(ClassAllocation node, Class c, Class[] args, List<Node> memb)", "diff": ["+   */", "+  public Class setProperties(ClassAllocation node, Class c, Class[] args, List<Node> memb) {", "+    String cname = \"TopLevel\" + \"$\" + classCount++;", "+    FieldDeclaration fd;", "+    ConstructorDeclaration csd;", "+    ", "+    // Create the reference to the declaring class", "+    fd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "+                              CLASS_TYPE,", "+                              \"declaring$Class$Reference$0\",", "+                              OBJECT_CLASS);", "+    memb.add(fd);", "+    ", "+    // Add the reference to the final local variables map", "+    memb.add(LOCALS);", "+    ", "+    // Create the reference to the final local variables map", "+    fd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "+                              OBJECT_ARRAY_ARRAY,", "+                              \"local$Variables$Class$0\",", "+                              createClassArrayInitializer());", "+    memb.add(fd);", "+    ", "+    // Create the constructor", "+    List<FormalParameter> params = new LinkedList<FormalParameter>();", "+    List<Node> stmts = new LinkedList<Node>();", "+    ", "+    // Add the final local variables map parameter", "+    params.add(new FormalParameter(false, MAP_TYPE, \"param$0\"));", "+    ", "+    // Add the other parameters", "+    List<Expression> superArgs = new LinkedList<Expression>();", "+    for (int i = 0; i < args.length; i++) {", "+      params.add(new FormalParameter(false, ", "+                                     TreeUtilities.classToType(args[i]),", "+                                     \"param$\" + (i + 1)));", "+      List<IdentifierToken> l = new LinkedList<IdentifierToken>();", "+      l.add(new Identifier(\"param$\" + (i + 1)));", "+      superArgs.add(new QualifiedName(l));", "+    }", "+    ", "+    // Create the explicit constructor invocation", "+    ConstructorInvocation ci = null;", "+    if (superArgs.size() > 0) {", "+      ci = new ConstructorInvocation(null, superArgs, true);", "+    }", "+    ", "+    // Add the outer instance reference initialization statement", "+    List<IdentifierToken> p1 = new LinkedList<IdentifierToken>();", "+    p1.add(new Identifier(\"local$Variables$Reference$0\"));", "+    List<IdentifierToken> p2 = new LinkedList<IdentifierToken>();", "+    p2.add(new Identifier(\"param$0\"));", "+    stmts.add(new SimpleAssignExpression(new QualifiedName(p1),", "+                                         new QualifiedName(p2)));", "+    ", "+    csd = new ConstructorDeclaration(Modifier.PUBLIC,", "+                                     cname,", "+                                     params,", "+                                     new LinkedList<List<IdentifierToken>>(),", "+                                     ci,", "+                                     stmts);", "+    memb.add(csd);", "+    ", "+    // Set the inheritance", "+    List<IdentifierToken> ext = null;", "+    List<List<IdentifierToken>> impl = null;", "+    if (c.isInterface()) {", "+      impl = new LinkedList<List<IdentifierToken>>();", "+      List<IdentifierToken> intf = new LinkedList<IdentifierToken>();", "+      intf.add(new Identifier(c.getName()));", "+      impl.add(intf);", "+    } else {", "+      ext = new LinkedList<IdentifierToken>();", "+      ext.add(new Identifier(c.getName()));", "+    }", "+    ", "+    // Create the class", "+    TypeDeclaration type = new ClassDeclaration(Modifier.PUBLIC,", "+                                                cname,", "+                                                ext,", "+                                                impl,", "+                                                memb);", "+    ", "+    type.setProperty(TreeClassInfo.ANONYMOUS_DECLARING_CLASS,", "+                     new JavaClassInfo(Object.class));", "+    ", "+    Class cl = new TreeCompiler(interpreter).compileTree(this, type);", "+    ", "+    // Update the argument types", "+    Class[] tmp = new Class[args.length+1];", "+    tmp[0] = Map.class;", "+    for (int i = 1; i < tmp.length; i++) {", "+      tmp[i] = args[i - 1];", "+    }", "+    args = tmp;", "+    try {", "+      node.setProperty(NodeProperties.CONSTRUCTOR, lookupConstructor(cl, args));", "+    } catch (NoSuchMethodException e) {", "+      // Never get here", "+      e.printStackTrace();", "+    }", "+    node.setProperty(NodeProperties.TYPE, cl);", "+    return cl;", "+  }", "-     */", "-    public Class setProperties(ClassAllocation node, Class c, Class[] args, List memb) {", "- String cname = \"TopLevel\" + \"$\" + classCount++;", "- FieldDeclaration fd;", "- ConstructorDeclaration csd;", "- ", "- // Create the reference to the declaring class", "- fd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "-      CLASS_TYPE,", "-      \"declaring$Class$Reference$0\",", "-      OBJECT_CLASS);", "- memb.add(fd);", "-", "- // Add the reference to the final local variables map", "- memb.add(LOCALS);", "-", "- // Create the reference to the final local variables map", "- fd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "-      OBJECT_ARRAY_ARRAY,", "-      \"local$Variables$Class$0\",", "-      createClassArrayInitializer());", "- memb.add(fd);", "-", "- // Create the constructor", "- List params = new LinkedList();", "- List stmts = new LinkedList();", "-", "- // Add the final local variables map parameter", "- params.add(new FormalParameter(false, MAP_TYPE, \"param$0\"));", "-", "- // Add the other parameters", "- List superArgs = new LinkedList();", "- for (int i = 0; i < args.length; i++) {", "-     params.add(new FormalParameter(false, ", "-        TreeUtilities.classToType(args[i]),", "-        \"param$\" + (i + 1)));", "-     List l = new LinkedList();", "-     l.add(new Identifier(\"param$\" + (i + 1)));", "-     superArgs.add(new QualifiedName(l));", "- }", "-", "- // Create the explicit constructor invocation", "-        ConstructorInvocation ci = null;", "-        if (superArgs.size() > 0) {", "-            ci = new ConstructorInvocation(null, superArgs, true);", "-        }", "- ", "- // Add the outer instance reference initialization statement", "- List p1 = new LinkedList();", "- p1.add(new Identifier(\"local$Variables$Reference$0\"));", "- List p2 = new LinkedList();", "- p2.add(new Identifier(\"param$0\"));", "- stmts.add(new SimpleAssignExpression(new QualifiedName(p1),", "-          new QualifiedName(p2)));", "-", "- csd = new ConstructorDeclaration(Modifier.PUBLIC,", "-      cname,", "-      params,", "-      new LinkedList(),", "-      ci,", "-      stmts);", "- memb.add(csd);", "-", "- // Set the inheritance", "- List ext = null;", "- List impl = null;", "- if (c.isInterface()) {", "-     impl = new LinkedList();", "-     List intf = new LinkedList();", "-     intf.add(new Identifier(c.getName()));", "-     impl.add(intf);", "- } else {", "-     ext = new LinkedList();", "-     ext.add(new Identifier(c.getName()));", "- }", "- ", "- // Create the class", "- TypeDeclaration type = new ClassDeclaration(Modifier.PUBLIC,", "-          cname,", "-          ext,", "-          impl,", "-          memb);", "-", "- type.setProperty(TreeClassInfo.ANONYMOUS_DECLARING_CLASS,", "-    new JavaClassInfo(Object.class));", "-", "- Class cl = new TreeCompiler(interpreter).compileTree(this, type);", "-", "- // Update the argument types", "- Class[] tmp = new Class[args.length+1];", "- tmp[0] = Map.class;", "- for (int i = 1; i < tmp.length; i++) {", "-     tmp[i] = args[i - 1];", "- }", "- args = tmp;", "- try {", "-     node.setProperty(NodeProperties.CONSTRUCTOR, lookupConstructor(cl, args));", "- } catch (NoSuchMethodException e) {", "-     // Never get here", "-     e.printStackTrace();", "- }", "- node.setProperty(NodeProperties.TYPE, cl);", "- return cl;", "-    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "de0c333b3baf3f9aadd753a4aec8ab81", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/context/MethodContext.java", "commitBeforeChange": "5df4e785713703c5888db4cb5ec4317420920fff", "commitAfterChange": "14b25d4149524a90a31159ece6ef4294e14d0609", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "     public Class setProperties(ClassAllocation node, Class c, Class[] args, List memb)", "signatureAfterChange": "   public Class setProperties(ClassAllocation node, Class c, Class[] args, List<Node> memb)", "diff": ["-     */", "-    public Class setProperties(ClassAllocation node, Class c, Class[] args, List memb) {", "-\tString                 dname = declaringClass.getName();", "-\tString                 cname = dname + \"$\" + classCount++;", "-\tFieldDeclaration       fd;", "-\tConstructorDeclaration csd;", "-\tReferenceType          otype = new ReferenceType(dname);", "-", "-\t// Create the reference to the declaring class", "-\tfd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "-\t\t\t\t  CLASS_TYPE,", "-\t\t\t\t  \"declaring$Class$Reference$0\",", "-\t\t\t\t  new TypeExpression(otype));", "-\tmemb.add(fd);", "-", "-\t// create the reference to the declaring instance", "-\tfd = new FieldDeclaration(Modifier.PUBLIC, otype, \"this$0\", null);", "-\tmemb.add(fd);", "-", "-\t// Add the reference to the final local variables map", "-\tmemb.add(LOCALS);", "-", "-\t// Create the reference to the final local variables map", "-\tfd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "-\t\t\t\t  OBJECT_ARRAY_ARRAY,", "-\t\t\t\t  \"local$Variables$Class$0\",", "-\t\t\t\t  createClassArrayInitializer());", "-\tmemb.add(fd);", "-", "-\t// Create the constructor", "-\tList params = new LinkedList();", "-\tList stmts = new LinkedList();", "-", "-\t// Add the outer instance parameter", "-\tparams.add(new FormalParameter(false, otype, \"param$0\"));", "-", "-\t// Add the final local variables map parameter", "-\tparams.add(new FormalParameter(false, MAP_TYPE, \"param$1\"));", "-", "-\t// Add the other parameters", "-\tList superArgs = new LinkedList();", "-\tfor (int i = 0; i < args.length; i++) {", "-\t    params.add(new FormalParameter(false, ", "-\t\t\t\t\t   TreeUtilities.classToType(args[i]),", "-\t\t\t\t\t   \"param$\" + (i + 2)));", "-\t    List l = new LinkedList();", "-\t    l.add(new Identifier(\"param$\" + (i + 2)));", "-\t    superArgs.add(new QualifiedName(l));", "-\t}", "-", "-\t// Create the explicit constructor invocation", "-        ConstructorInvocation ci = null;", "-        if (superArgs.size() > 0) {", "-            ci = new ConstructorInvocation(null, superArgs, true);", "+   */", "+  public Class setProperties(ClassAllocation node, Class c, Class[] args, List<Node> memb) {", "+    String                 dname = declaringClass.getName();", "+    String                 cname = dname + \"$\" + classCount++;", "+    FieldDeclaration       fd;", "+    ConstructorDeclaration csd;", "+    ReferenceType          otype = new ReferenceType(dname);", "+    ", "+    // Create the reference to the declaring class", "+    fd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "+                              CLASS_TYPE,", "+                              \"declaring$Class$Reference$0\",", "+                              new TypeExpression(otype));", "+    memb.add(fd);", "+    ", "+    // create the reference to the declaring instance", "+    fd = new FieldDeclaration(Modifier.PUBLIC, otype, \"this$0\", null);", "+    memb.add(fd);", "+    ", "+    // Add the reference to the final local variables map", "+    memb.add(LOCALS);", "+    ", "+    // Create the reference to the final local variables map", "+    fd = new FieldDeclaration(Modifier.PUBLIC | Modifier.STATIC,", "+                              OBJECT_ARRAY_ARRAY,", "+                              \"local$Variables$Class$0\",", "+                              createClassArrayInitializer());", "+    memb.add(fd);", "+    ", "+    // Create the constructor", "+    List<FormalParameter> params = new LinkedList<FormalParameter>();", "+    List<Node> stmts = new LinkedList<Node>();", "+    ", "+    // Add the outer instance parameter", "+    params.add(new FormalParameter(false, otype, \"param$0\"));", "+    ", "+    // Add the final local variables map parameter", "+    params.add(new FormalParameter(false, MAP_TYPE, \"param$1\"));", "+    ", "+    // Add the other parameters", "+    List<Expression> superArgs = new LinkedList<Expression>();", "+    for (int i = 0; i < args.length; i++) {", "+      params.add(new FormalParameter(false, ", "+                                     TreeUtilities.classToType(args[i]),", "+                                     \"param$\" + (i + 2)));", "+      List<IdentifierToken> l = new LinkedList<IdentifierToken>();", "+      l.add(new Identifier(\"param$\" + (i + 2)));", "+      superArgs.add(new QualifiedName(l));", "+    }", "+    ", "+    // Create the explicit constructor invocation", "+    ConstructorInvocation ci = null;", "+    if (superArgs.size() > 0) {", "+      ci = new ConstructorInvocation(null, superArgs, true);", "+    }", "+    ", "+    ", "+    // Add the outer instance reference initialization statement", "+    List<IdentifierToken> p1 = new LinkedList<IdentifierToken>();", "+    p1.add(new Identifier(\"this$0\"));", "+    List<IdentifierToken> p2 = new LinkedList<IdentifierToken>();", "+    p2.add(new Identifier(\"param$0\"));", "+    stmts.add(new SimpleAssignExpression(new QualifiedName(p1),", "+                                         new QualifiedName(p2)));", "+    ", "+    // Add the outer instance reference initialization statement", "+    p1 = new LinkedList<IdentifierToken>();", "+    p1.add(new Identifier(\"local$Variables$Reference$0\"));", "+    p2 = new LinkedList<IdentifierToken>();", "+    p2.add(new Identifier(\"param$1\"));", "+    stmts.add(new SimpleAssignExpression(new QualifiedName(p1),", "+                                         new QualifiedName(p2)));", "+    ", "+    csd = new ConstructorDeclaration(Modifier.PUBLIC,", "+                                     cname,", "+                                     params,", "+                                     new LinkedList<List<IdentifierToken>>(),", "+                                     ci,", "+                                     stmts);", "+    memb.add(csd);", "+    ", "+    // Set the inheritance clause", "+    List<IdentifierToken> ext = null;", "+    List<List<IdentifierToken>> impl = null;", "+    if (c.isInterface()) {", "+      impl = new LinkedList<List<IdentifierToken>>();", "+      List<IdentifierToken> intf = new LinkedList<IdentifierToken>();", "+      intf.add(new Identifier(c.getName()));", "+      impl.add(intf);", "+    } else {", "+      ext = new LinkedList<IdentifierToken>();", "+      ext.add(new Identifier(c.getName()));", "+    }", "+    ", "+    // Create the class", "+    TypeDeclaration type = new ClassDeclaration(Modifier.PUBLIC,", "+                                                cname,", "+                                                ext,", "+                                                impl,", "+                                                memb);", "+    ", "+    type.setProperty(TreeClassInfo.ANONYMOUS_DECLARING_CLASS,", "+                     new JavaClassInfo(declaringClass));", "+    ", "+    Class cl = new TreeCompiler(interpreter).compileTree(this, type);", "+    ", "+    // Update the argument types", "+    Class[] tmp = new Class[args.length+2];", "+    tmp[0] = declaringClass;", "+    tmp[1] = Map.class;", "+    for (int i = 2; i < tmp.length; i++) {", "+      tmp[i] = args[i - 2];", "+    }", "+    args = tmp;", "+    try {", "+      node.setProperty(NodeProperties.CONSTRUCTOR, lookupConstructor(cl, args));", "+    } catch (NoSuchMethodException e) {", "+      // Never get here", "+      e.printStackTrace();", "+    }", "+    node.setProperty(NodeProperties.TYPE, cl);", "+    return cl;", "+  }", "-\t", "-", "-\t// Add the outer instance reference initialization statement", "-\tList p1 = new LinkedList();", "-\tp1.add(new Identifier(\"this$0\"));", "-\tList p2 = new LinkedList();", "-\tp2.add(new Identifier(\"param$0\"));", "-\tstmts.add(new SimpleAssignExpression(new QualifiedName(p1),", "-\t\t\t\t\t     new QualifiedName(p2)));", "-", "-\t// Add the outer instance reference initialization statement", "-\tp1 = new LinkedList();", "-\tp1.add(new Identifier(\"local$Variables$Reference$0\"));", "-\tp2 = new LinkedList();", "-\tp2.add(new Identifier(\"param$1\"));", "-\tstmts.add(new SimpleAssignExpression(new QualifiedName(p1),", "-\t\t\t\t\t     new QualifiedName(p2)));", "-", "-\tcsd = new ConstructorDeclaration(Modifier.PUBLIC,", "-\t\t\t\t\t cname,", "-\t\t\t\t\t params,", "-\t\t\t\t\t new LinkedList(),", "-\t\t\t\t\t ci,", "-\t\t\t\t\t stmts);", "-\tmemb.add(csd);", "-", "-\t// Set the inheritance clause", "-\tList ext = null;", "-\tList impl = null;", "-\tif (c.isInterface()) {", "-\t    impl = new LinkedList();", "-\t    List intf = new LinkedList();", "-\t    intf.add(new Identifier(c.getName()));", "-\t    impl.add(intf);", "-\t} else {", "-\t    ext = new LinkedList();", "-\t    ext.add(new Identifier(c.getName()));", "-\t}", "-\t", "-\t// Create the class", "-\tTypeDeclaration type = new ClassDeclaration(Modifier.PUBLIC,", "-\t\t\t\t\t\t    cname,", "-\t\t\t\t\t\t    ext,", "-\t\t\t\t\t\t    impl,", "-\t\t\t\t\t\t    memb);", "-", "-\ttype.setProperty(TreeClassInfo.ANONYMOUS_DECLARING_CLASS,", "-\t\t\t new JavaClassInfo(declaringClass));", "-", "-\tClass cl = new TreeCompiler(interpreter).compileTree(this, type);", "-", "-\t// Update the argument types", "-\tClass[] tmp = new Class[args.length+2];", "-\ttmp[0] = declaringClass;", "-\ttmp[1] = Map.class;", "-\tfor (int i = 2; i < tmp.length; i++) {", "-\t    tmp[i] = args[i - 2];", "-\t}", "-\targs = tmp;", "-\ttry {", "-\t    node.setProperty(NodeProperties.CONSTRUCTOR, lookupConstructor(cl, args));", "-\t} catch (NoSuchMethodException e) {", "-\t    // Never get here", "-\t    e.printStackTrace();", "-\t}", "-\tnode.setProperty(NodeProperties.TYPE, cl);", "-\treturn cl;"]}], "num": 30006}