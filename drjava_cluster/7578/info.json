{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "196a2b04515532218fd6ef4e3c5a6ba2", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "254980fc07482c89dbe71fca95760dbd", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 79, "methodNumberAfterChange": 83, "signatureBeforeChange": "   @Override public Type visit(SimpleAssignExpression node)", "signatureAfterChange": "     @Override public Type visit(SimpleAssignExpression node)", "diff": ["-   */", "-  @Override public Type visit(SimpleAssignExpression node) {", "-    Expression left = node.getLeftExpression();", "-    Type result = left.acceptVisitor(this);", "-    Type rightT = node.getRightExpression().acceptVisitor(this);", "-    ", "-    if (!hasVariableType(left)) {", "-      throw new ExecutionError(\"left.expression\", node);", "-    }", "-    if (hasVariable(left) && getVariable(left).isFinal() ||", "-        hasField(left) && getField(left).isFinal()) {", "-      throw new ExecutionError(\"cannot.modify\", node);", "-    }", "-", "-    try {", "-      Expression newRight = ts.assign(getVariableType(left),", "-                                      node.getRightExpression());", "-      node.setRightExpression(newRight);", "-      return setType(node, result);", "-    }", "-    catch (UnsupportedConversionException e) {", "-      setErrorStrings(node, ts.userRepresentation(rightT),", "-                      ts.userRepresentation(getVariableType(left)));", "-      throw new ExecutionError(\"assignment.types\", node);", "-    }", "-  }", "+     */", "+    @Override public Type visit(SimpleAssignExpression node) {", "+      Expression left = node.getLeftExpression();", "+      Type result = check(left);", "+", "+      if (!hasVariableType(left)) {", "+        throw new ExecutionError(\"left.expression\", node);", "+      }", "+      if (hasVariable(left) && getVariable(left).isFinal() ||", "+          hasField(left) && getField(left).isFinal()) {", "+        throw new ExecutionError(\"cannot.modify\", node);", "+      }", "+      ", "+      Type target = getVariableType(left);", "+      Type rightT = check(node.getRightExpression(), target);", "+      try {", "+        Expression newRight = ts.assign(target, node.getRightExpression());", "+        node.setRightExpression(newRight);", "+        return setType(node, result);", "+      }", "+      catch (UnsupportedConversionException e) {", "+        setErrorStrings(node, ts.userRepresentation(rightT),", "+                        ts.userRepresentation(target));", "+        throw new ExecutionError(\"assignment.types\", node);", "+      }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "efdd81565edb259d20c3ce3c80eea89e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/StatementChecker.java", "commitBeforeChange": "b125d4a35b225e9cc738f569b062e7e7bd7cf031", "commitAfterChange": "9ce155a1f3e34352032d821032cb2dc70024460f", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "   @Override public TypeContext visit(VariableDeclaration node)", "signatureAfterChange": "   @Override public TypeContext visit(VariableDeclaration node)", "diff": ["-    Type t = checkTypeName(node.getType());", "-    LocalVariable v = new LocalVariable(node.getName(), t, node.isFinal());", "-    setVariable(node, v);", "-    TypeContext newContext = new LocalContext(context, v);", "-    ", "-    if (node.getInitializer() != null) {", "-      Type initT = checkType(node.getInitializer(), t);", "-      try {", "-        Expression newInit = ts.assign(t, node.getInitializer());", "-        node.setInitializer(newInit);", "-      }", "-      catch (UnsupportedConversionException e) {", "-        setErrorStrings(node, ts.userRepresentation(initT), ts.userRepresentation(t));", "-        throw new ExecutionError(\"assignment.types\", node);", "-      }", "+    if (node.getType() == null) {", "+      // We infer the variable's type.  We can assume the initializer is non-null.", "+      Type initT = checkType(node.getInitializer());", "+      LocalVariable v = new LocalVariable(node.getName(), initT, node.isFinal());", "+      setVariable(node, v);", "+      return new LocalContext(context, v);", "-    ", "-    return newContext;", "+    else {", "+      Type t = checkTypeName(node.getType());", "+      LocalVariable v = new LocalVariable(node.getName(), t, node.isFinal());", "+      setVariable(node, v);", "+      TypeContext newContext = new LocalContext(context, v);", "+      ", "+      if (node.getInitializer() != null) {", "+        Type initT = checkType(node.getInitializer(), t);", "+        try {", "+          Expression newInit = ts.assign(t, node.getInitializer());", "+          node.setInitializer(newInit);", "+        }", "+        catch (UnsupportedConversionException e) {", "+          setErrorStrings(node, ts.userRepresentation(initT), ts.userRepresentation(t));", "+          throw new ExecutionError(\"assignment.types\", node);", "+        }", "+      }", "+      return newContext;", "+    }"]}], "num": 7578}