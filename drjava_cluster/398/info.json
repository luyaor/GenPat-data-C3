{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "adf690b02785ce50aaeb361e4bd13f3d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "028186a559a972b9b89e16d6f29ae08b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/project/ProjectFileBuilder.java", "commitBeforeChange": "314c962d7f6ed2c6b00f5edc6e764b582b016016", "commitAfterChange": "3b2b8c4279d3d3c19a0254256362d4d46aeeddaf", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 8, "signatureBeforeChange": "      public void addResourceFile(File sf)", "signatureAfterChange": "   public void write() throws IOException", "diff": ["-  public void addResourceFile(File sf)", "-  {", "-    _resourceFiles.add(sf);", "-  }", "+   */", "+  public void write() throws IOException {", "+    FileWriter fw = new FileWriter(_projectFile);", "+    ", "+    // write opening comment line", "+    fw.write(\";; DrJava project file, written by build \" + Version.getBuildTimeString());", "+    ", "+    // write source files", "+    if (!_sourceFiles.isEmpty()) {", "+      fw.write(\"\\n(source\");", "+      for(DocFile df: _sourceFiles) {", "+        fw.write(\"\\n\" + encodeDocFile(df, \"  \"));", "+      }", "+      fw.write(\")\"); // close the source expression", "+    }", "+    ", "+    // write aux files", "+    if (!_auxFiles.isEmpty()) {", "+      fw.write(\"\\n(auxiliary\");", "+      for(DocFile df: _auxFiles) {", "+        fw.write(\"\\n\" + encodeDocFile(df, \"  \", false));", "+      }", "+      fw.write(\")\"); // close the auxiliary expression", "+    }", "+    ", "+    // write collapsed paths", "+    if (!_collapsedPaths.isEmpty()){", "+      fw.write(\"\\n(collapsed\");", "+      for(File f: _collapsedPaths) {", "+        fw.write(\"\\n\" + encodeFile(f, \"  \"));", "+      }", "+      fw.write(\")\"); // close the collapsed expression", "+    }", "+    ", "+    // write classpaths", "+    if (!_classpathFiles.isEmpty()) {", "+      fw.write(\"\\n(classpaths\");", "+      for(File f: _classpathFiles) {", "+        fw.write(\"\\n\" + encodeFile(f, \"  \"));", "+      }", "+      fw.write(\")\"); // close the classpaths expression", "+    }", "+    ", "+    // write the build directory", "+    if (_buildDir != null) {", "+      fw.write(\"\\n(build-dir\");", "+      fw.write(\"\\n\" + encodeFile(_buildDir, \"  \"));", "+      fw.write(\")\");", "+    }", "+    ", "+    // write the main class", "+    if (_mainClass != null) {", "+      fw.write(\"\\n(main-class\");", "+      fw.write(\"\\n\" + encodeFile(_mainClass, \"  \"));", "+      fw.write(\")\");", "+    }", "+    ", "+    fw.close();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "22dae11f0e8163114bdb9ce60bbd4952", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "f835199d645f480bb352cc51cff6dc5ae32e7dc4", "commitAfterChange": "f25bc20d2dd4058b4cf2bf5f693569e62fb40d6b", "methodNumberBeforeChange": 112, "methodNumberAfterChange": 126, "signatureBeforeChange": "   protected Iterable<Type> inferTypeArguments(Iterable<? extends VariableType> tparams,                                              Iterable<? extends Type> params, Type returned,                                             Iterable<? extends Type> args, Option<Type> expected)", "signatureAfterChange": "   protected Iterable<Type> inferTypeArguments(Iterable<? extends VariableType> tparams,                                              Iterable<? extends Type> params, Type returned,                                             Iterable<? extends Type> args, Option<Type> expected)", "diff": ["-    RecursionStack3<Type, Type, InferenceMode> stack = RecursionStack3.make();", "-    Set<? extends VariableType> tparamSet = CollectUtil.makeSet(tparams);", "-    ConstraintSet constraintsBuilder = EMPTY_CONSTRAINTS;", "-    for (Pair<Type, Type> pair : IterUtil.zip(args, params)) {", "-      constraintsBuilder = constraintsBuilder.and(inferFromSubtype(pair.first(), pair.second(), ", "-                                                                   tparamSet, stack));", "-      if (!constraintsBuilder.isSatisfiable()) { break; }", "+    Inferencer inf = new Inferencer(CollectUtil.makeSet(tparams));", "+    ", "+    // perform inference for args and returned", "+    ConstraintFormula constraints = TRUE;", "+    for (Pair<Type, Type> pair : IterUtil.zip(IterUtil.map(args, NORMALIZE), IterUtil.map(params, NORMALIZE))) {", "+      constraints = constraints.and(inf.subtypeNorm(pair.first(), pair.second()));", "+      if (!constraints.isSatisfiable()) { break; }", "-    if (expected.isSome() && constraintsBuilder.isSatisfiable()) {", "-      constraintsBuilder = constraintsBuilder.and(inferFromSupertype(expected.unwrap(), returned,", "-                                                                     tparamSet, stack));", "+    if (expected.isSome() && constraints.isSatisfiable()) {", "+      constraints = constraints.and(inf.supertypeNorm(NORMALIZE.value(expected.unwrap()), NORMALIZE.value(returned)));", "-    final ConstraintSet constraints = constraintsBuilder; // constraints must be redeclared as final", "+    // transitivity constraints: inferred bounds must be sub/super-types of declared bounds", "+    // (used to improve results where the variable has a self-referencing bound)", "+    ConstraintFormula transConstraints = FALSE;", "+    for (ConstraintScenario s : constraints.scenarios()) {", "+      ConstraintFormula cf = s;", "+      for (VariableType param : tparams) {", "+        cf = cf.and(inf.subtypeNorm(s.lowerBound(param), NORMALIZE.value(param.symbol().upperBound())));", "+        if (!cf.isSatisfiable()) { break; }", "+        cf = cf.and(inf.supertypeNorm(s.upperBound(param), NORMALIZE.value(param.symbol().lowerBound())));", "+        if (!cf.isSatisfiable()) { break; }", "+      }", "+      transConstraints = transConstraints.or(cf);", "+      if (transConstraints.isEmpty()) { break; }", "+    }", "+    ", "-//    System.out.println(\"Final inference result: \" + constraints);", "-    if (!constraints.isSatisfiable()) { return null; }", "+    if (!transConstraints.isSatisfiable()) { return null; }", "-    Iterable<Type> result = IterUtil.mapSnapshot(tparams, new Lambda<VariableType, Type>() {", "-      public Type value(VariableType param) { return constraints.lowerBound(param); }", "-    });", "-    if (inBounds(tparams, result)) { return result; }", "-    ", "-    List<Wildcard> constraintWs = new LinkedList<Wildcard>();", "-    for (VariableType param : tparams) {", "-      BoundedSymbol s = new BoundedSymbol(new Object(), constraints.upperBound(param), constraints.lowerBound(param));", "-      constraintWs.add(new Wildcard(s));", "+    // try to use lower bounds", "+    for (final ConstraintScenario s : transConstraints.scenarios()) {", "+      Iterable<Type> result = IterUtil.mapSnapshot(tparams, new Lambda<VariableType, Type>() {", "+        public Type value(VariableType param) { return s.lowerBound(param); }", "+      });", "+      if (inBounds(tparams, result)) { return result; }", "-    result = captureTypeArgs(constraintWs, tparams);", "-    if (IterUtil.and(result, WELL_FORMED)) { return result; }", "-", "+    ", "+    // lower bounds don't work, try to use capture variables", "+    for (ConstraintScenario s : transConstraints.scenarios()) {", "+      List<Wildcard> constraintWs = new LinkedList<Wildcard>();", "+      for (VariableType param : tparams) {", "+        BoundedSymbol sym = new BoundedSymbol(new Object(), s.upperBound(param), s.lowerBound(param));", "+        constraintWs.add(new Wildcard(sym));", "+      }", "+      Iterable<Type> result = captureTypeArgs(constraintWs, tparams);", "+      if (IterUtil.and(result, WELL_FORMED)) { return result; }", "+    }", "+    ", "+    // give up"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "399faa76ba027ce7b656f5d6f771e44b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/JLSTypeSystem.java", "commitBeforeChange": "80debf5b9716524c576a71fc4929233c9637cd68", "commitAfterChange": "0dc6c4e6c51f7a1991368187e63e0eff0d7150ef", "methodNumberBeforeChange": 127, "methodNumberAfterChange": 141, "signatureBeforeChange": "   protected Iterable<Type> inferTypeArguments(Iterable<? extends VariableType> tparams,                                              Iterable<? extends Type> params, Type returned,                                             Iterable<? extends Type> args, Option<Type> expected)", "signatureAfterChange": "   protected Iterable<Type> inferTypeArguments(Iterable<? extends VariableType> tparams,                                              Iterable<? extends Type> params, Type returned,                                             Iterable<? extends Type> args, Option<Type> expected)", "diff": ["-    ", "-    // perform inference for expected type (JLS is not clear on whether these should be combined with", "-    // previous bounds; Eclipse does use the previous bounds)", "-    SubstitutionMap firstPhaseSigma = new SubstitutionMap(instantiations);", "-    if (expected.isSome()) {", "-      inf.supertype(expected.unwrap(), substitute(returned, firstPhaseSigma));", "+    if (!_alwaysUseArgumentConstraints) {", "+      inf = new Inferencer(CollectUtil.makeSet(toInfer));", "+      constraints = inf.constraints();", "-    // handle upper bounds", "-    for (VariableType var : toInfer) {", "-      Set<Type> upperBounds = union(constraints.upperBounds(var),", "-                                    substitute(var.symbol().upperBound(), firstPhaseSigma));", "-      instantiations.put(var, meet(upperBounds));", "+    // perform inference for expected type", "+    if (expected.isSome()) {", "+      inf.supertype(expected.unwrap(), substitute(returned, new SubstitutionMap(instantiations)));", "+      for (VariableType var : toInfer) {", "+        Set<Type> eqBounds = constraints.equalBounds(var);", "+        if (!eqBounds.isEmpty()) { instantiations.put(var, IterUtil.first(eqBounds)); }", "+      }", "+    }", "+    ", "+    // use upper bounds (may be inferred from args or expected, and may be declared)", "+    if (_waitToUseDeclaredBounds) {", "+      for (VariableType var : toInfer) {", "+        Set<Type> upperBounds = constraints.upperBounds(var);", "+        if (!upperBounds.isEmpty()) { instantiations.put(var, meet(upperBounds)); }", "+      }", "+      for (VariableType var : toInfer) {", "+        instantiations.put(var, substitute(var.symbol().upperBound(), new SubstitutionMap(instantiations)));", "+      }", "+    }", "+    else {", "+      for (VariableType var : toInfer) {", "+        Set<Type> upperBounds = constraints.upperBounds(var);", "+        Type declared = var.symbol().upperBound();", "+        if (!declared.equals(OBJECT)) {", "+          upperBounds = union(upperBounds, substitute(declared, new SubstitutionMap(instantiations)));", "+        }", "+        instantiations.put(var, meet(upperBounds));", "+      }", "-    if (inBounds(tparams, result)) { return result; }", "-    else { return null; }", "+    SubstitutionMap sigma = new SubstitutionMap(tparams, result);", "+    boolean valid = inBounds(tparams, result);", "+    for (Pair<Type, Type> pair : zip(args, params)) {", "+      if (!valid) { break; }", "+      valid &= isSubtype(pair.first(), substitute(pair.second(), sigma));", "+    }", "+    return valid ? result : null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64aacb8bc22b9b73b386f93e664c7bbd", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/config/VectorOption.java", "commitBeforeChange": "ef7dc3345b6835fe8ebb574f1a9119ee4c786794", "commitAfterChange": "21836dcccd81c2207652ee85b319b723ac9ff10b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Vector<T> parse(String s)", "signatureAfterChange": "   public Vector<T> parse(String s)", "diff": ["+    Vector<T> res = new Vector<T>();", "+    if (s.equals(\"\")) { return res; }", "+", "-    String d = String.valueOf(delim);", "-    StringTokenizer st = new StringTokenizer(s,d,true);", "-", "-    Vector<T> res = new Vector<T>();", "-    boolean sawDelim = st.hasMoreTokens();", "-", "-    while(st.hasMoreTokens()) {", "-      String token = st.nextToken();", "-      boolean isDelim = token.equals(d);", "-", "-      if (!isDelim) {", "-        res.add(parser.parse(token));", "-      } else if (sawDelim) { // isDelim & sawDelim (two delims in a row)", "-        throw new OptionParseException(name, s, \"Argument contains delimiter with no preceding list element.\");", "-      }", "-      sawDelim = isDelim;", "+    if (s.equals(\"\")) {", "+      res.add(parser.parse(\"\"));", "+      return res;", "-    if (sawDelim) throw new OptionParseException(name, s, \"Value shouldn't end with a delimiter.\");", "+    ", "+    String d = String.valueOf(delim);", "+", "+    StreamTokenizer st = new StreamTokenizer(new StringReader(s));", "+    st.resetSyntax();", "+    st.wordChars(0,255);", "+    st.ordinaryChar('\\\\');", "+    st.ordinaryChar(delim);", "+    try {", "+      int tok = st.nextToken();", "+      int prevtok = -4;", "+      StringBuilder sb = new StringBuilder();", "+      while (tok!=StreamTokenizer.TT_EOF) {", "+        if (tok=='\\\\') {", "+          if (prevtok=='\\\\') {", "+            // second backslash in a row, append a backslash to string builder", "+            sb.append('\\\\');", "+            prevtok = tok = -4;", "+          }", "+          else {", "+            // first backslash, next token decides", "+            prevtok = tok;", "+          }", "+        }", "+        else if (tok==delim) {", "+          if (prevtok=='\\\\') {", "+            // backslash followed by delimiter --> escaped delimiter", "+            // append delimiter to string builder", "+            sb.append(delim);", "+            prevtok = tok = -4;", "+          }", "+          else {", "+            // no preceding backslash --> real delimiter", "+            res.add(parser.parse(sb.toString()));", "+            sb.setLength(0); // clear string builder", "+            prevtok = tok;", "+          }", "+        }", "+        else {", "+          // not a backslash or delimiter", "+          if (prevtok=='\\\\') {", "+            // backslash followed by neither a backslash nor a delimiter", "+            // invalid", "+            throw new OptionParseException(name, s, \"A backslash was discovered before the token '\" + st.sval +", "+                                           \"'. A backslash is only allowed in front of another backslash \" +", "+                                           \"or the delimiter \"+delim+\".\");", "+          }", "+          sb.append(st.sval);", "+          prevtok = tok;", "+        }", "+        ", "+        tok = st.nextToken();", "+      }", "+      ", "+      res.add(parser.parse(sb.toString()));      ", "+    }", "+    catch(IOException ioe) {", "+      throw new OptionParseException(name, s, \"An IOException occurred while parsing a vector.\");", "+    }", "+"]}], "num": 398}