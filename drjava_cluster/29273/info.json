{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d12c7d110f1c6eb56539e20bd3e42c85", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "257c82f99f1bc204f1370b0bb7523105", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 48, "methodNumberAfterChange": 48, "signatureBeforeChange": "   protected SymbolData _identifyType(String name, SourceInfo si, String enclosingClassName)", "signatureAfterChange": "   protected SymbolData _identifyType(String name, SourceInfo si, String enclosingClassName)", "diff": ["-    * datas.  We need to use the relative inner class name to do this. */", "+    * inner classes of the chain of enclosing datas.  We need to use the relative inner class name to do this. */", "-//    System.err.println(\"Calling _identifyType(\" + name  + \") within \" + enclosingClassName);", "+//    System.err.println(\"***** Calling _identifyType(\" + name  + \") within \" + enclosingClassName);", "+    ", "+    // If name is a type variable, return the binding", "+    if (_genericTypes.containsKey(name)) return _genericTypes.get(name);", "-    SymbolData enclosingSD = getQualifiedSymbolData(enclosingClassName, SourceInfo.NO_INFO);", "-    if (enclosingSD == null) {", "+//    if (name.equals(\"ResType\") && sd == null) ", "+//      Utilities.show(\"_genericTypes = \" + _genericTypes + \"Trace follows.\\n\" + Utilities.getStackTrace());", "+        ", "+//    if (enclosingClassName == null) Utilities.show(\"_identifyType called with null enclosingClassName. Trace follows.\\n\" +", "+//                                                   Utilities.getStackTrace());", "+   ", "-      return null;  // should only happen in tests", "-    }", "+    if (enclosingClassName == null) return null;  // happens for binding occurrences of type variables?", "+    ", "+    SymbolData enclosingSD = getQualifiedSymbolData(enclosingClassName, SourceInfo.NONE);   ", "+    if (enclosingSD == null) return null;", "+    ", "-    ", "+   ", "+//    System.err.println(\"***** _identifyType(\" + name  + \") within \" + enclosingClassName + \" RETURNED \" + sd);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "67b761fdac1c5966e0b80f8019071ee8", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 47, "signatureBeforeChange": "   protected SymbolData getSymbolDataForClassFile(String className, SourceInfo si)", "signatureAfterChange": "   private SymbolData _identifyType(String name, SourceInfo si, String enclosingClassName)", "diff": ["-    */", "-  protected SymbolData getSymbolDataForClassFile(String className, SourceInfo si) {", "-    SymbolData sd = getSymbolDataHelper(className, si, true, true, true, false);", "-    ", "-    if (sd == null) {", "-      // This is an error in the user's class file so throw an error.", "-      // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-      _addAndIgnoreError(\"Class \" + className + \" not found.\", new NullLiteral(si));", "-      return null;", "-    }", "-    sd.setIsContinuation(false);", "-    ", "-    continuations.remove(sd.getName());", "-    return sd;", "-  }", "+    * datas.  We need to use the relative inner class name to do this. */", "+  private SymbolData _identifyType(String name, SourceInfo si, String enclosingClassName) {", "+    System.err.println(\"Calling _identifyType(\" + name  + \") within \" + enclosingClassName);", "+    SymbolData sd = getSymbolData(name, si);  // TODO: uses wrong enclosingClassName!!!", "+    if (sd != null) return sd;", "+    SymbolData enclosingSD = getQualifiedSymbolData(enclosingClassName, SourceInfo.NO_INFO);", "+    if (enclosingSD == null) {", "+      System.err.println(\"***ERROR*** in _identifyType \" + enclosingClassName + \" NOT FOUND\");", "+      return null;  // should only happen in tests", "+    sd = enclosingSD.getInnerClassOrInterface(name);", "+     ", "+    if (sd != null) return sd;", "+//    ", "+//    // Create continuation for new type", "+//    String qualifiedTypeName = enclosingClassName + '.' + name;", "+//    if (_innerClassesInThisBody.contains(qualifiedTypeName)) {  ", "+//      // reference to an inner class that will subsequently be defined", "+//      sd = addInnerSymbolData(si, qualifiedTypeName, enclosingSD);", "+//    }", "+    ", "+    return sd;  // Note: sd is null if name is not identified."]}], "num": 29273}