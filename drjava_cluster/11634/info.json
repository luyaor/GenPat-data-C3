{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9429edd82359fd2afeb54dff71284483", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "711fe998281a411274c9a8a904b59d7b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "093f33e43dd3de7d97364f410a0a58ca1448a1ce", "commitAfterChange": "51703b3c111cc35e01e35a5e289226f6da1c1962", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 43, "signatureBeforeChange": "   protected SymbolData addInnerSymbolData(TypeDefBase typeDefBase,                                            String qualifiedTypeName,                                            String partialName,                                            Data enclosing,                                            boolean isClass)", "signatureAfterChange": "   protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String qualifiedTypeName, Data enclosing)", "diff": ["-    */", "-  protected SymbolData addInnerSymbolData(TypeDefBase typeDefBase, ", "-                                          String qualifiedTypeName, ", "-                                          String partialName, ", "-                                          Data enclosing, ", "-                                          boolean isClass) {", "-    //try to look up in symbol table, in case it has already been defined", "-    SymbolData sd = symbolTable.get(qualifiedTypeName);", "-    ", "-    //try to look up in enclosing's list of inner classes", "-    if (sd == null) { sd = enclosing.getInnerClassOrInterface(partialName); }", "-    ", "-    if (sd != null && !sd.isContinuation()) {", "-//      Utilities.show(\"This class has already been defined sd = \" + sd);", "-      _addAndIgnoreError(\"This class has already been defined.\", typeDefBase);", "-//      throw new RuntimeException(\"ALREADY DEFINED CLASS ERROR; THROWING EXCEPTION\");", "-      return null;", "-    }", "-    ", "-    if (sd != null) {", "-      //make sure it is a direct inner class or interface of this data.", "-      if (sd.getOuterData() != enclosing) { sd = null; }", "-    }", "-    ", "-    // create a new symbolData for it--this is the first time we've seen it", "-    if (sd == null) { ", "-      sd = new SymbolData(qualifiedTypeName);", "-      sd.setOuterData(enclosing);", "-      if (isClass) { enclosing.getSymbolData().addInnerClass(sd); }", "-      else { enclosing.getSymbolData().addInnerInterface(sd); }", "-    }", "-    ", "-    // create the LinkedList for the SymbolDatas of the interfaces", "-    LinkedList<SymbolData> interfaces = new LinkedList<SymbolData>();", "-    SymbolData tempSd;", "-    ReferenceType[] rts = typeDefBase.getInterfaces();", "-    for (int i = 0; i < rts.length; i++) {", "-      SourceInfo si = rts[i].getSourceInfo();", "-      String tempName = rts[i].getName();", "-      tempSd = getSymbolData(tempName, si, false, false, false);", "-      ", "-      if (tempSd != null) { interfaces.addLast(tempSd); }", "-      ", "-      else if (enclosing instanceof SymbolData) {", "-        // Check to see if this is an inner class referencing an inner interface", "-        tempSd = enclosing.getInnerClassOrInterface(tempName);", "-        if (tempSd == null) {", "-          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "-          String qualifiedTempName = qualifyingPart + \".\" + tempName;", "-          // Should we introduce addInnerInterfaceSymbol ?", "-          tempSd = new SymbolData(qualifiedTempName);", "-          tempSd.setInterface(true);", "-          enclosing.getSymbolData().addInnerInterface(tempSd); //interfaces can only be defined in symbol datas", "-          tempSd.setOuterData(enclosing);", "-//          System.err.println(\"Creating inner interface continuation for \" + qualifiedTempName + \" at LLV: 1042\");", "-          continuations.put(qualifiedTempName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));          ", "-        }", "-        interfaces.addLast(tempSd);", "-      }", "-      ", "-      else {", "-        _addAndIgnoreError(\"Cannot resolve interface \" + rts[i].getName(), rts[i]);", "-        return null;", "-      }", "-    }", "-    ", "-    //Set the package to be the current package", "-    sd.setPackage(_package);", "-    ", "-    SymbolData superClass = null;", "-    ", "-    if (typeDefBase instanceof InterfaceDef) {", "-      //add Object as the super class of this, so that it will know it implements Object's methods.", "-      superClass = getSymbolData(\"Object\", typeDefBase.getSourceInfo(), false);", "-      sd.setInterface(true);", "-    }", "-    ", "-    else if (typeDefBase instanceof ClassDef) {", "-      ClassDef cd = (ClassDef) typeDefBase;", "-      ReferenceType rt = cd.getSuperclass();", "-      String superClassName = rt.getName();", "-      superClass = getSymbolData(superClassName, rt.getSourceInfo(), false, false, false);", "-      ", "-      if (superClass == null) {", "-        superClass = enclosing.getInnerClassOrInterface(superClassName);", "-        if (superClass == null) {", "-          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "-          superClass = new SymbolData(qualifyingPart + \".\" + superClassName);", "-          enclosing.addInnerClass(superClass);", "-          superClass.setOuterData(enclosing);", "-//          System.err.println(\"Creating continuation for \" + superClassName + \" at LLV:1079\");", "-          continuations.put(superClassName, new Pair<SourceInfo, LanguageLevelVisitor>(rt.getSourceInfo(), this)); ", "-        }", "-      }", "-      sd.setInterface(false);", "-    }", "-    ", "-    else {throw new RuntimeException(\"Internal Program Error: typeDefBase was not a ClassDef or InterfaceDef.\" + ", "-                                     \"  Please report this bug.\");}", "-    ", "-    // get the SymbolData of the superclass which must be in the symbol table", "-    // since we visited the type in forClassDef() although it may be a continuation. ", "-    ", "-    // there is a continuation in the symbol table, update the fields", "-    sd.setMav(typeDefBase.getMav());", "-    sd.setTypeParameters(typeDefBase.getTypeParameters());", "-    sd.setSuperClass(superClass);", "-    sd.setInterfaces(interfaces);", "-    sd.setIsContinuation(false);", "-    continuations.remove(sd.getName());", "-    if (sd != null && !sd.isInterface()) {_newSDs.put(sd, this); }", "-    return sd;", "-  }", "+    */", "+  protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String qualifiedTypeName, Data enclosing) { ", "+        /* IMPORTANT: this is defineSymbol for inner classes! */", "+    String name = qualifiedTypeName;  // may be an interface", "+    SymbolData sd = symbolTable.get(name);", "+    if (sd != null && ! sd.isContinuation()) {", "+      _addAndIgnoreError(\"The class or interface \" + name + \" has already been defined.\", typeDefBase);", "+      return null;", "+    }", "+    ", "+    // create the LinkedList for the SymbolDatas of the interfaces", "+    LinkedList<SymbolData> interfaces = new LinkedList<SymbolData>();", "+    SymbolData tempSd;", "+    ReferenceType[] rts = typeDefBase.getInterfaces();", "+    for (int i = 0; i < rts.length; i++) {", "+      SourceInfo si = rts[i].getSourceInfo();", "+      String tempName = rts[i].getName();", "+      tempSd = getSymbolData(tempName, si, false, false, false);", "+      ", "+      if (tempSd != null) { interfaces.addLast(tempSd); }", "+      ", "+      else if (enclosing instanceof SymbolData) {", "+        // Check to see if this is an inner class referencing an inner interface", "+        tempSd = enclosing.getInnerClassOrInterface(tempName);", "+        if (tempSd == null) {", "+          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "+          String qualifiedTempName = qualifyingPart + \".\" + tempName;", "+          // Should we introduce addInnerInterfaceSymbol ?", "+          tempSd = new SymbolData(qualifiedTempName);", "+          tempSd.setInterface(true);", "+          enclosing.getSymbolData().addInnerInterface(tempSd); //interfaces can only be defined in symbol datas", "+          tempSd.setOuterData(enclosing);", "+//          System.err.println(\"Creating inner interface continuation for \" + qualifiedTempName + \" at LLV: 1042\");", "+          continuations.put(qualifiedTempName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));          ", "+        }", "+        interfaces.addLast(tempSd);", "+      }", "+      ", "+      else {", "+        _addAndIgnoreError(\"Cannot resolve interface \" + rts[i].getName(), rts[i]);", "+        return null;", "+      }", "+    }", "+        ", "+    // create a new symbolData for this inner class or interface if not seen before", "+    if (sd == null) { ", "+      sd = new SymbolData(qualifiedTypeName);", "+      sd.setOuterData(enclosing);", "+      if (typeDefBase instanceof ClassDef) { enclosing.getSymbolData().addInnerClass(sd); }", "+      else { ", "+        enclosing.getSymbolData().addInnerInterface(sd); ", "+      }", "+    }", "+    //Set the package to be the current package", "+    sd.setPackage(_package);", "+    ", "+    SymbolData superClass = null;", "+    ", "+    if (typeDefBase instanceof InterfaceDef) {", "+      // Add Object as the super class of this, so that it will know it implements Object's methods.", "+      superClass = getSymbolData(\"Object\", typeDefBase.getSourceInfo(), false);", "+      sd.setInterface(true);", "+    }", "+    else if (typeDefBase instanceof ClassDef) {", "+      ClassDef cd = (ClassDef) typeDefBase;", "+      ReferenceType rt = cd.getSuperclass();", "+      String superClassName = rt.getName();", "+      superClass = getSymbolData(superClassName, rt.getSourceInfo(), false, false, false);", "+      ", "+      if (superClass == null) {  // Why is this necessary?  Forward reference to another inner class?", "+        superClass = enclosing.getInnerClassOrInterface(superClassName);", "+        if (superClass == null) {", "+          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "+          superClass = new SymbolData(qualifyingPart + \".\" + superClassName);", "+          enclosing.addInnerClass(superClass);", "+          superClass.setOuterData(enclosing);", "+//          System.err.println(\"Creating continuation for \" + superClassName + \" at LLV:1079\");", "+          continuations.put(superClassName, new Pair<SourceInfo, LanguageLevelVisitor>(rt.getSourceInfo(), this)); ", "+        }", "+    if (! sd.isInterface()) { LanguageLevelConverter._newSDs.put(sd, this); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "af20bdd312763ed447129f9e36222b6f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/CompilerRegistry.java", "commitBeforeChange": "3ae33096a45a4dc4990b95b1565bd0aeaf9084da", "commitAfterChange": "e69a4c60c625d52f9ba6a18669f0f6846846e463", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public CompilerInterface[] getAvailableCompilers()", "signatureAfterChange": "   public CompilerInterface[] getAvailableCompilers()", "diff": ["-    String[] candidateCompilers = null;", "-    ", "-    String version = CompilerProxy.VERSION; // version of executing JVM: 1.4, 1.5, 1.6", "-    ", "-    if (version.equals(\"1.4\")) candidateCompilers = JAVA_14_COMPILERS;", "-    else if (version.equals(\"1.5\")) candidateCompilers = JAVA_15_COMPILERS;", "-    else if (version.equals(\"1.6\")) candidateCompilers = JAVA_16_COMPILERS;", "-    else throw new ", "-      UnexpectedException(\"Java specification version \" + version + \"is not supported.  Must be 1.4, 1.5, or 1.6\");", "+    if (_candidateCompilers == null) throw new ", "+      UnexpectedException(\"Java specification version \" + CompilerProxy.VERSION + \"is not supported.  Must be 1.4, 1.5, or 1.6\");", "-    for (String name : candidateCompilers) {", "-//      DrJava.consoleOut().print(\"REGISTRY:  Checking compiler: \" + name + \": \");", "-      try { if (_createCompiler(name, availableCompilers)) break; }", "+    for (String name : _candidateCompilers) {", "+      _log.log(\"CompilerRegistry.getAvailableCompilers is checking compiler: \" + name);", "+      try { if (_createCompiler(name, availableCompilers)) continue; }", "-//        DrJava.consoleOut().println(\"failed to load:\");", "+        _log.log(\"Compiler \" + name + \" failed to load:\");", "+   _log.log(\"CompilerRegistry.getAvailableCompilers() returning \" + availableCompilers);", "+    "]}], "num": 11634}