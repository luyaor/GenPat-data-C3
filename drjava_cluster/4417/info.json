{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a7e28adab286676f394426b384723479", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c52aac7fa5c6e35e81cbdca1a9b6c42", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/util/TigerUtilitiesTest.java", "commitBeforeChange": "8f229bab538b43dd12abaa1c01f1cf3b469a6628", "commitAfterChange": "dc0befa68595a5c499b8803df615b4dd1cb06eb6", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "   public void testBoxesTo()", "signatureAfterChange": "   public void testBoxesTo()", "diff": ["-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(int.class,Long.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(int.class,Double.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(int.class,Float.class),true);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(int.class,Long.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(int.class,Double.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(int.class,Float.class),false);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(float.class,Double.class),true);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(float.class,Double.class),false);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(long.class,Double.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(long.class,Float.class),true);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(long.class,Double.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(long.class,Float.class),false);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(byte.class,Integer.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(byte.class,Short.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(byte.class,Long.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(byte.class,Float.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(byte.class,Double.class),true);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(byte.class,Integer.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(byte.class,Short.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(byte.class,Long.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(byte.class,Float.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(byte.class,Double.class),false);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(char.class,Integer.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(char.class,Long.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(char.class,Double.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(char.class,Float.class),true);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(char.class,Integer.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(char.class,Long.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(char.class,Double.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(char.class,Float.class),false);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(short.class,Integer.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(short.class,Long.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(short.class,Double.class),true);", "-    assertEquals(\"Should be able to box primitive to reference type\",TigerUtilities.boxesTo(short.class,Float.class),true);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(short.class,Integer.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(short.class,Long.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(short.class,Double.class),false);", "+    assertEquals(\"Should not be able to box primitive to reference type\",TigerUtilities.boxesTo(short.class,Float.class),false);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1dea40da0c8e971981c7b2492ab527f5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/util/ImportationManagerTest.java", "commitBeforeChange": "6730b2e413a99565d4307ad95e1ac5e98eebdf83", "commitAfterChange": "e174f3f9eb19ef8a7530f2c7ad04a839e38770be", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "             public void testDeclareMemberStaticImport()", "signatureAfterChange": "             public void testDeclareMemberStaticImport()", "diff": ["-      im.declareMemberStaticImport(\"java.lang.Integer.valueOf\");", "+      im.declareMemberStaticImport(\"java.lang.Integer.parseInt\");", "-    assertEquals(\"List of staticly imported methods should contain all three valueOf methods\",3,methods.size());", "+    assertEquals(\"List of staticly imported methods should contain both parseint methods\",2,methods.size());", "-    assertEquals(\"List of staticly imported fields should contain all three valueOf methods\",", "-                 \"public static java.lang.Integer java.lang.Integer.valueOf(int)\",methods.get(0).toString());", "-    assertEquals(\"List of staticly imported fields should contain all three valueOf methods\",", "-                 \"public static java.lang.Integer java.lang.Integer.valueOf(java.lang.String) throws java.lang.NumberFormatException\",methods.get(1).toString());", "-    assertEquals(\"List of staticly imported fields should contain all three valueOf methods\",", "-                 \"public static java.lang.Integer java.lang.Integer.valueOf(java.lang.String,int) throws java.lang.NumberFormatException\",methods.get(2).toString());", "+    if(TigerUtilities.isTigerEnabled()) {      ", "+      assertEquals(\"List of staticly imported fields should contain both parseInt methods\",", "+                   \"public static int java.lang.Integer.parseInt(java.lang.String) throws java.lang.NumberFormatException\",methods.get(0).toString());", "+      assertEquals(\"List of staticly imported fields should contain both parseInt methods\",", "+                   \"public static int java.lang.Integer.parseInt(java.lang.String,int) throws java.lang.NumberFormatException\",methods.get(1).toString());", "+    }", "+    else {", "+      //When running 1.4, the methods returned by java.lang.reflect.Class.getMethods() are in the array in reverse order from the way they are returned in 1.5.", "+      //This will not affect the program but does affect these assertions", "+      assertEquals(\"List of staticly imported fields should contain both parseInt methods\",", "+                   \"public static int java.lang.Integer.parseInt(java.lang.String,int) throws java.lang.NumberFormatException\",methods.get(0).toString());", "+      assertEquals(\"List of staticly imported fields should contain both parseInt methods\",", "+                   \"public static int java.lang.Integer.parseInt(java.lang.String) throws java.lang.NumberFormatException\",methods.get(1).toString());", "+    }", "+      ", "-    assertEquals(\"List of staticly imported methods should not have changed\",3,methods.size());", "+    assertEquals(\"List of staticly imported methods should not have changed\",2,methods.size());", "-    assertEquals(\"List of staticly imported methods should not have changed\",3,methods.size());", "+    assertEquals(\"List of staticly imported methods should not have changed\",2,methods.size());", "-    assertEquals(\"List of staticly imported methods should contain the two static toString methods in the Integer class\",5,methods.size());", "-    assertEquals(\"List of staticly imported methods should contain the two static toString methods in the Integer class as its first two entries\",", "-                 \"public static java.lang.String java.lang.Integer.toString(int)\",methods.get(0).toString());", "-    assertEquals(\"List of staticly imported methods should contain the two static toString methods in the Integer class as its first two entries\",", "-                 \"public static java.lang.String java.lang.Integer.toString(int,int)\",methods.get(1).toString());", "-    ", "+    assertEquals(\"List of staticly imported methods should contain the two static toString methods in the Integer class\",4,methods.size());", "+    if(TigerUtilities.isTigerEnabled()) {", "+      assertEquals(\"List of staticly imported methods should contain the two static toString methods in the Integer class as its first two entries\",", "+                   \"public static java.lang.String java.lang.Integer.toString(int)\",methods.get(0).toString());", "+      assertEquals(\"List of staticly imported methods should contain the two static toString methods in the Integer class as its first two entries\",", "+                   \"public static java.lang.String java.lang.Integer.toString(int,int)\",methods.get(1).toString());", "+    }", "+    else {", "+      //When running 1.4, the methods returned by java.lang.reflect.Class.getMethods() are in the array in reverse order from the way they are returned in 1.5.", "+      //This will not affect the program but does affect these assertions", "+      assertEquals(\"List of staticly imported methods should contain the two static toString methods in the Integer class as its first two entries\",", "+                   \"public static java.lang.String java.lang.Integer.toString(int,int)\",methods.get(0).toString());", "+      assertEquals(\"List of staticly imported methods should contain the two static toString methods in the Integer class as its first two entries\",", "+                   \"public static java.lang.String java.lang.Integer.toString(int)\",methods.get(1).toString());", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3c64ac8a56c2f67fc9de1534b855bb00", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "95fc34f702728d19ab12beabcddae9a69d422c00", "commitAfterChange": "5607cf775ad2ef70ccd49a101fe31fb06f6903bb", "methodNumberBeforeChange": 133, "methodNumberAfterChange": 133, "signatureBeforeChange": "          public void testForPlusAssignmentExpression()", "signatureAfterChange": "          public void testForPlusAssignmentExpression()", "diff": ["-      //Plus Assignment with numbers:", "+      // Plus Assignment with numbers:", "-      //if variable does not have value, cannot be plus assigned", "+      // if variable does not have value, cannot be plus assigned", "-      assertEquals(\"Error message should be correct\", \"You cannot use Flanders here, because it may not have been given a value\",", "-                   errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot use Flanders here, because it may not have been given a value\",", "+                   errors.get(0).getFirst());", "-      //if variable is final, with a value cannot be reassigned", "+      // if variable is final, with a value cannot be reassigned", "-      assertEquals(\"Error message should be correct\", \"You cannot assign a new value to Flanders because it is immutable and has already been given a value\",", "-                   errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You cannot assign a new value to Flanders because it is immutable and has already been given a value\",", "+                   errors.get(1).getFirst());", "-      assertEquals(\"There should be 2 errors\", 2, errors.size());", "+      assertEquals(\"There should still be 2 errors\", 2, errors.size());", "-      assertEquals(\"There should be 4 errors\", 4, errors.size());", "-      assertEquals(\"The first error message should be correct\", \"You cannot use Flanders here, because it may not have been given a value\", errors.get(2).getFirst());", "-      assertEquals(\"The second error message should be correct\", \"You cannot use Flanders here, because it may not have been given a value\", errors.getLast().getFirst());", "-", "-      ", "-      ", "+      assertEquals(\"There should still be 2 errors\", 2, errors.size());  // Generated two duplicate messages.", "+      assertEquals(\"The first error message should be correct\", ", "+                   \"You cannot use Flanders here, because it may not have been given a value\", ", "+                   errors.get(0).getFirst());", "-      PlusAssignmentExpression pa3 = new PlusAssignmentExpression(SourceInfo.NO_INFO, sRef, new BooleanLiteral(SourceInfo.NO_INFO, true));", "+      PlusAssignmentExpression pa3 = ", "+        new PlusAssignmentExpression(SourceInfo.NO_INFO, sRef, new BooleanLiteral(SourceInfo.NO_INFO, true));", "-      assertEquals(\"string concatenation with string at the front.  Should return String type\", stringSD.getInstanceData(), pa3.visit(_etc));", "-      assertEquals(\"Should be 4 errors\", 4, errors.size());", "+      assertEquals(\"string concatenation with string at the front.  Should return String type\", ", "+                   stringSD.getInstanceData(), ", "+                   pa3.visit(_etc));", "+      assertEquals(\"Should still be 2 errors\", 2, errors.size());", "-      //when both sides are strings", "-      PlusAssignmentExpression pa4 = new PlusAssignmentExpression(SourceInfo.NO_INFO, sRef, new StringLiteral(SourceInfo.NO_INFO, \"cat\"));", "-      assertEquals(\"string concatenation with string on both sides.  Should return String type\", stringSD.getInstanceData(), pa4.visit(_etc));", "-      assertEquals(\"Should be 4 errors\", 4, errors.size());", "+      // when both sides are strings", "+      PlusAssignmentExpression pa4 = ", "+        new PlusAssignmentExpression(SourceInfo.NO_INFO, sRef, new StringLiteral(SourceInfo.NO_INFO, \"cat\"));", "+      assertEquals(\"string concatenation with string on both sides.  Should return String type\", ", "+                   stringSD.getInstanceData(), pa4.visit(_etc));", "+      assertEquals(\"Should still be 2 errors\", 2, errors.size());", "-      //when string is second", "+      // when string is second", "-      PlusAssignmentExpression pa5 = new PlusAssignmentExpression(SourceInfo.NO_INFO, nf, new StringLiteral(SourceInfo.NO_INFO, \"house \"));", "-      assertEquals(\"string + concatenation with string at back.  Should give error\", stringSD.getInstanceData(), pa5.visit(_etc));", "-      assertEquals(\"Should be 5 errors\", 5, errors.size());", "-      assertEquals(\"Error message should be correct\", \"The arguments to the Plus Assignment Operator (+=) must either include an instance of a String or both be numbers.  You have specified arguments of type int and java.lang.String\", errors.getLast().getFirst());", "-      ", "-", "-      ", "+      PlusAssignmentExpression pa5 = ", "+        new PlusAssignmentExpression(SourceInfo.NO_INFO, nf, new StringLiteral(SourceInfo.NO_INFO, \"house \"));", "+      assertEquals(\"string + concatenation with string at back.  Should give error\", ", "+                   stringSD.getInstanceData(), ", "+                   pa5.visit(_etc));", "+      assertEquals(\"Should now be 3 errors\", 3, errors.size());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"The arguments to the Plus Assignment Operator (+=) must either include an instance of a String \" + ", "+                   \"or both be numbers.  You have specified arguments of type int and java.lang.String\", ", "+                   errors.get(2).getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4170fc401863012945070d0179bd27f8", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/FileOpsTest.java", "commitBeforeChange": "8958ac741e416ecbae85abc43f8b198196076bac", "commitAfterChange": "9fa6d06a5ecc75a8eda4a5bc78f492dd1b318059", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "   public void testSaveFile() throws IOException", "signatureAfterChange": "   public void testSaveFile() throws IOException", "diff": ["-", "+    ", "+    FileOps.saveFile(new FileOps.DefaultFileSaver(writeTo) {", "+      public void saveTo(OutputStream os) throws IOException {", "+        String output = \"version 1\";", "+        os.write(output.getBytes());", "+      }", "+      public boolean shouldBackup() {", "+        return false;", "+      }", "+    });", "+    assertEquals(\"save w/o backup\", \"version 1\", FileOps.readFileAsString(writeTo));", "+    assertEquals(\"save w/o backup did not backup\", false, backup.exists());", "+    ", "+    FileOps.saveFile(new FileOps.DefaultFileSaver(writeTo) {", "+      public void saveTo(OutputStream os) throws IOException {", "+        String output = \"version 2\";", "+        os.write(output.getBytes());", "+      }", "+    });", "+    assertEquals(\"save2 w backup\", \"version 2\", FileOps.readFileAsString(writeTo));", "+    assertEquals(\"save2 w backup did backup\", \"version 1\",", "+                 FileOps.readFileAsString(backup));", "+    ", "+    FileOps.saveFile(new FileOps.DefaultFileSaver(writeTo) {", "+      public void saveTo(OutputStream os) throws IOException {", "+        String output =  \"version 3\";", "+        os.write(output.getBytes());", "+      }", "+    });", "+    assertEquals(\"save3 w backup on\", \"version 3\", FileOps.readFileAsString(writeTo));", "+    assertEquals(\"save3 w backup on did not backup\", \"version 1\",", "+                 FileOps.readFileAsString(backup));", "+    ", "+    ", "+    /* Now see what happens when saving fails and we were not making a backup", "+     * Nothing should change. */", "-   public void saveTo(File file) throws IOException {", "-     FileOps.writeStringToFile(file, \"version 1\");", "-   }", "-   public boolean shouldBackup() {", "-     return false;", "-   }", "- });", "-      assertEquals(\"save w/o backup\", \"version 1\", FileOps.readFileAsString(writeTo));", "-      assertEquals(\"save w/o backup did not backup\", false, backup.exists());", "+        public void saveTo(OutputStream os) throws IOException {", "+          String output = \"version 4\";", "+          os.write(output.getBytes());", "+          throw new IOException();", "+        }", "+      });", "+      fail(\"IOException not propagated\");", "+    } catch (IOException ioe){}//do nothing, this is expected", "+    assertEquals(\"failed save4 w/o backup\", \"version 3\",", "+                 FileOps.readFileAsString(writeTo));", "+    assertEquals(\"failed save4 w/o backup check original backup\", \"version 1\",", "+                 FileOps.readFileAsString(backup));", "+    /* Now see what happens when saving fails and we were making a backup */", "+    try {", "-   public void saveTo(File file) throws IOException {", "-     FileOps.writeStringToFile(file, \"version 2\");", "-   }", "- });", "-      assertEquals(\"save2 w backup\", \"version 2\", FileOps.readFileAsString(writeTo));", "-      assertEquals(\"save2 w backup did backup\", \"version 1\",", "-     FileOps.readFileAsString(backup));", "-    ", "-      FileOps.saveFile(new FileOps.DefaultFileSaver(writeTo) {", "-   public void saveTo(File file) throws IOException {", "-     FileOps.writeStringToFile(file, \"version 3\");", "-   }", "- });", "-      assertEquals(\"save3 w backup on\", \"version 3\", FileOps.readFileAsString(writeTo));", "-      assertEquals(\"save3 w backup on did not backup\", \"version 1\",", "-     FileOps.readFileAsString(backup));", "-", "-    ", "-      /* Now see what happens when saving fails and we were not making a backup", "-  Nothing should change. */", "-      try {", "- FileOps.saveFile(new FileOps.DefaultFileSaver(writeTo) {", "-     public void saveTo(File file) throws IOException {", "-       FileOps.writeStringToFile(file, \"version 4\");", "-       throw new IOException();", "-     }", "-   });", "- fail(\"IOException not propagated\");", "-      } catch (IOException ioe){}//do nothing, this is expected", "-      assertEquals(\"failed save4 w/o backup\", \"version 3\",", "-     FileOps.readFileAsString(writeTo));", "-      assertEquals(\"failed save4 w/o backup check original backup\", \"version 1\",", "-     FileOps.readFileAsString(backup));", "-", "-      /* Now see what happens when saving fails and we were making a backup */", "-      try {", "- FileOps.saveFile(new FileOps.DefaultFileSaver(writeTo) {", "-     public boolean shouldBackup () {", "-       return true;", "-     }", "-     public void saveTo(File file) throws IOException {", "-       FileOps.writeStringToFile(file, \"version 5\");", "-       throw new IOException();", "-     }", "-   });", "- fail(\"IOException not propagated spot 2\");", "-      } catch(IOException ioe){} //do nothing, we expected this", "-      assertEquals(\"failed save5 w backup\", \"version 3\",", "-     FileOps.readFileAsString(writeTo));", "-    } finally {", "-      /* This finally makes sure our test files are deleted */", "-      writeTo.delete();", "-      backup.delete();", "-    }", "+        public boolean shouldBackup () {", "+          return true;", "+        }", "+        public void saveTo(OutputStream os) throws IOException {", "+          String output =  \"version 5\";", "+          os.write(output.getBytes());", "+          throw new IOException();", "+        }", "+      });", "+      fail(\"IOException not propagated spot 2\");", "+    } catch(IOException ioe){} //do nothing, we expected this", "+    assertEquals(\"failed save5 w backup\", \"version 3\",", "+                 FileOps.readFileAsString(writeTo));"]}], "num": 4417}