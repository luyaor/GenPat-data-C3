{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5494960042c8247f3c9ac595ed2caac6", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b62849ebdc63b840a74059a4433906ed", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/DefaultCompilerModel.java", "commitBeforeChange": "476f4df6ab63cd1004cb7cc36238fad228ab6d80", "commitAfterChange": "2df7289d55456372fbaf4e3ab78549d8571648f8", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 13, "signatureBeforeChange": "   private void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "signatureAfterChange": "   private void _compileFiles(List<? extends File> files, File buildDir) throws IOException", "diff": ["-  private void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException {", "-", "-//    CompilerError[] errors = new CompilerError[0];", "-    ", "-//    System.err.println(\"Compiling files: \" + Arrays.toString(files) + \" to \" + buildDir);", "+  private void _compileFiles(List<? extends File> files, File buildDir) throws IOException {", "+    if (!files.isEmpty()) {", "+      /* Canonicalize buildDir */", "+      if (buildDir != null) buildDir = FileOps.getCanonicalFile(buildDir);", "-    Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>> errors;", "-    LinkedList<JExprParseException> parseExceptions;", "-", "-    LinkedList<Pair<String, JExpressionIF>> visitorErrors;", "-    LinkedList<CompilerError> compilerErrors = new LinkedList<CompilerError>();", "-    CompilerInterface compiler = CompilerRegistry.ONLY.getActiveCompiler();", "-    ", "-    /* Canonicalize buildDir */", "-    if (buildDir != null) buildDir = FileOps.getCanonicalFile(buildDir);", "-", "-    compiler.setBuildDirectory(buildDir);", "-    ClassPathVector extraClassPath = new ClassPathVector();", "-    if (_model.isProjectActive()) ", "-      extraClassPath.addAll(_model.getExtraClassPath());", "-//    Utilities.showDebug(\"extra class path is: \" + extraClasspath);", "-    for (File f : DrJava.getConfig().getSetting(OptionConstants.EXTRA_CLASSPATH)) extraClassPath.add(f);", "-    ", "-//    Utilities.showDebug(\"Extra classpath passed to compiler: \" + extraClasspath.toString());", "-    compiler.setExtraClassPath(extraClassPath);", "-    if (files.length > 0) {", "-//      if (DrJava.getConfig().getSetting(OptionConstants.LANGUAGE_LEVEL) == DrJava.ELEMENTARY_LEVEL) {", "-      LanguageLevelConverter llc = new LanguageLevelConverter(getActiveCompiler().getName());", "-//      System.err.println(getActiveCompiler().getName());", "-      /* Language level files are moved to another file, copied back in augmented form to be compiled.  This", "-       * compiled version is also copied to another file with the same path with the \".augmented\" suffix on the ", "-       * end.  We have to copy the original back to its original spot so the user doesn't have to do anything funny.", "-       */", "-//      Utilities.showDebug(\"Getting ready to call LL converter on \" + Arrays.toString(files));", "-      errors = llc.convert(files);", "-//      Utilities.showDebug(\"Conversion complete\");", "+      List<File> classPath = _model.getClassPath().asFileVector();", "-      compiler.setWarningsEnabled(true);", "-      ", "-      /* Rename any .dj0 files in files to be .java files, so the correct thing is compiled.  The hashset is used to ", "-       * make sure we never send in duplicate files. This can happen if the java file was sent in along with the ", "-       * corresponding .dj* file. The dj* file is renamed to a .java file and thus we have two of the same file in ", "-       * the list.  By adding the renamed file to the hashset, the hashset efficiently removes duplicates.", "-      */", "-      HashSet<File> javaFileSet = new HashSet<File>();", "-      for (File f : files) {", "-        File canonicalFile;", "-        try { canonicalFile = f.getCanonicalFile(); } ", "-        catch(IOException e) { canonicalFile = f.getAbsoluteFile(); }", "-        String fileName = canonicalFile.getPath();", "-        int lastIndex = fileName.lastIndexOf(\".dj\");", "-        if (lastIndex != -1) {", "-          /** If compiling a language level file, do not show warnings, as these are not caught by the language level parser */", "-          compiler.setWarningsEnabled(false);", "-          javaFileSet.add(new File(fileName.substring(0, lastIndex) + \".java\"));", "+      // Temporary hack to allow a boot class path to be specified", "+      List<File> bootClassPath = null;", "+      if (System.getProperty(\"drjava.bootclasspath\") != null) {", "+        bootClassPath = new LinkedList<File>();", "+        StringTokenizer st = new StringTokenizer(System.getProperty(\"drjava.bootclasspath\"), File.pathSeparator);", "+        while (st.hasMoreTokens()) {", "+          bootClassPath.add(new File(st.nextToken()));", "-        else javaFileSet.add(canonicalFile);", "-      files = javaFileSet.toArray(new File[javaFileSet.size()]);", "-        ", "-      parseExceptions = errors.getFirst();", "-      compilerErrors.addAll(_parseExceptions2CompilerErrors(parseExceptions));", "-      visitorErrors = errors.getSecond();", "-      compilerErrors.addAll(_visitorErrors2CompilerErrors(visitorErrors));", "-      CompilerError[] compilerErrorsArray = null;", "-      compilerErrorsArray = compilerErrors.toArray(new CompilerError[compilerErrors.size()]);", "-", "-      /** Compile the files in specified sourceRoots and files */", "-    ", "-      if (compilerErrorsArray.length == 0) ", "-        synchronized(_compilerLock) { compilerErrorsArray = compiler.compile(sourceRoots, files); }", "-", "-      _distributeErrors(compilerErrorsArray);", "+      List<CompilerError> errors = new LinkedList<CompilerError>();", "+      ", "+      List<? extends File> preprocessedFiles = _compileLanguageLevelsFiles(files, errors);", "+      ", "+      if (errors.isEmpty()) {", "+        CompilerInterface compiler = CompilerRegistry.ONLY.getActiveCompiler();", "+        ", "+        synchronized(_compilerLock) {", "+          if (preprocessedFiles == null) {", "+            errors.addAll(compiler.compile(files, classPath, null, buildDir, bootClassPath, null, true));", "+          }", "+          else {", "+            /** If compiling a language level file, do not show warnings, as these are not caught by the language level parser */", "+            errors.addAll(compiler.compile(preprocessedFiles, classPath, null, buildDir, bootClassPath, null, false));", "+          }", "+        }", "+      }", "+      _distributeErrors(errors);", "-    else _distributeErrors(new CompilerError[0]);", "+    else { ", "+      // TODO: Is this necessary?", "+      _distributeErrors(Collections.<CompilerError>emptyList());", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5bf748100cf49015347d0920fd470d3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractGlobalModel.java", "commitBeforeChange": "35ca78e33b0503c2a6070986170dae99ba9dcb1a", "commitAfterChange": "6136e4c5753a47e4bcb40afa831b9c58e353fd69", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 13, "signatureBeforeChange": "         public FileGroupingState _makeProjectFileGroupingState(final File jarMainClass,                                                           final File buildDir,                                                           final File projectFile,                                                           final File[] projectFiles,                                                          final ClasspathVector classpath)", "signatureAfterChange": "      protected FileGroupingState      makeProjectFileGroupingState(File main, File dir, File project, File[] files, ClasspathVector cp)", "diff": ["+  protected FileGroupingState ", "+    makeProjectFileGroupingState(File main, File dir, File project, File[] files, ClasspathVector cp) {", "+    return new ProjectFileGroupingState(main, dir, project, files, cp);", "+  }", "-  ", "-  public FileGroupingState _makeProjectFileGroupingState(final File jarMainClass, ", "-                                                         final File buildDir, ", "-                                                         final File projectFile, ", "-                                                         final File[] projectFiles,", "-                                                         final ClasspathVector classpath) {", "-    return new FileGroupingState() {", "-      private File _builtDir = buildDir;", "-      private File _mainFile = jarMainClass;", "-      ", "-      private volatile boolean _isProjectChanged = false;", "-      ", "-      //private ArrayList<File> _auxFiles = new ArrayList<File>();", "-      ", "-      HashSet<String> _projFilePaths = new HashSet<String>();", "-      ", "-      private ClasspathVector _projExtraClasspath = classpath;", "-      ", "-      /** Initialization Block */", "-      { ", "-        try {  for (File file : projectFiles) { _projFilePaths.add(file.getCanonicalPath()); } }", "-        catch(IOException e) { }", "-      }", "-      ", "-      public boolean isProjectActive() { return true; }", "-      ", "-      /** Determines whether the specified doc in within the project file tree.", "-       *  No synchronization is required because only immutable data is accessed.", "-       */", "-      public boolean isInProjectPath(OpenDefinitionsDocument doc) {", "-        if (doc.isUntitled()) return false;", "-        ", "-        // If the file does not exist, we still want to tell if it's in the correct", "-        // path.  The file may have been in at one point and had been removed, in which", "-        // case we should treat it as an untitled project file that should be resaved.", "-        try {", "-          File f;", "-          try { f = doc.getFile(); } ", "-          catch(FileMovedException fme) { f = fme.getFile(); }", "-          ", "-          String filePath = f.getParentFile().getCanonicalPath() + File.separator;", "-          String projectPath = projectRoot.getCanonicalPath() + File.separator;", "-          return (filePath.startsWith(projectPath));", "-        }", "-        catch(IOException e) {", "-          //          System.out.println(e); // What should we do in this case?", "-          return false;", "-        }", "-      /** @return the absolute path to the project file.  Since projectFile is final, no synchronization", "-       *   is necessary.", "-       */", "-      public File getProjectFile() { return projectFile; }", "-      public boolean isProjectFile(File f) {", "-        String path;", "-        ", "-        if (f == null) return false;", "-        ", "-        try { ", "-          path = f.getCanonicalPath();", "-          return _projFilePaths.contains(path);", "-        }", "-        catch(IOException ioe) { return false; }", "-        /*", "-         for (File file : projectFiles) {", "-         try {", "-         if (file.getCanonicalPath().equals(path))", "-         return true;", "-         }", "-         catch(IOException ioe) {", "-         //continue", "-         }", "-         }", "-         return false;*/", "-        ", "-      public File[] getProjectFiles() { return projectFiles; }", "-      public File getBuildDirectory() { return _builtDir; }", "-      public void setBuildDirectory(File f) { _builtDir = f; }", "-      ", "-      public File getMainClass() { return _mainFile; }", "-      ", "-      public void setJarMainClass(File f) { _mainFile = f; }", "-      ", "-      public boolean isProjectChanged() { return _isProjectChanged; }", "-      ", "-      public void setProjectChanged(boolean changed) { _isProjectChanged = changed; }", "-      ", "-      public boolean isAuxiliaryFile(File f) {", "-        String path;", "-        if (f == null) return false;", "-        ", "-        try { path = f.getCanonicalPath();}", "-        catch(IOException ioe) { return false; }", "-        ", "-        synchronized(_auxiliaryFiles) {", "-          for (File file : _auxiliaryFiles) {", "-            try { if (file.getCanonicalPath().equals(path)) return true; }", "-            catch(IOException ioe) { /* ignore file */ }", "-          return false;", "-        }", "-      }", "-      ", "-      public void cleanBuildDirectory() throws FileMovedException, IOException{", "-        File dir = this.getBuildDirectory();", "-        cleanHelper(dir);", "-        if (! dir.exists()) dir.mkdirs();", "-      }", "-      ", "-      private void cleanHelper(File f) {", "-        if (f.isDirectory()) {", "-          ", "-          File fs[] = f.listFiles(new FilenameFilter() {", "-            public boolean accept(File parent, String name) {", "-              return new File(parent, name).isDirectory() || name.endsWith(\".class\");", "-            }", "-          });", "-          ", "-          for (File kid: fs) { cleanHelper(kid); }", "-          ", "-          if (f.listFiles().length == 0)  f.delete();", "-          ", "-        } else if (f.getName().endsWith(\".class\")) f.delete();", "-      }", "-      ", "-      ", "-      /**", "-       * returns the name of the package from a fully qualified classname", "-       */", "-      ", "-      //throws UnsupportedOperationException", "-      public void compileAll() throws IOException{", "-        throw new UnsupportedOperationException(\"AbstractGlobalModel does not support compilation\");", "-        }", "-      ", "-      // ----- FIND ALL DEFINED CLASSES IN FOLDER ---", "-      //throws UnsupportedOperationException", "-      public void junitAll() {", "-        throw new UnsupportedOperationException(\"AbstractGlobalModel does not support JUnit testing\");", "-      }", "-//      ", "-//      /**", "-//       * Jars all the files in this project", "-//       * throws UnsupportedOperationException", "-//       */", "-      public void jarAll() {", "-        throw new UnsupportedOperationException(\"AbstractGlobaModel does not support jarring\");", "-      }", "-      ", "-      public ClasspathVector getExtraClasspath() {", "-        return _projExtraClasspath;", "-      }", "-      ", "-      public void setExtraClasspath(ClasspathVector cp) {", "-        _projExtraClasspath = cp;", "-      }", "-    };"]}], "num": 1560}