{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "be2c3b7f265734798f6c301400c89e04", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1fc1e869aa0363d4facb5ba28ec02c0e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/compiler/DefaultCompilerModel.java", "commitBeforeChange": "0e6d6d4c130043dfa8d569e24f0f6f9c1f824f96", "commitAfterChange": "ccb8831468d9c146526d6431dd0a2aea7a5182b5", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 8, "signatureBeforeChange": "   protected void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "signatureAfterChange": "   protected void _compileFiles(File[] sourceRoots, File[] files, File buildDir) throws IOException", "diff": ["-    CompilerError[] errors = new CompilerError[0];", "+//    CompilerError[] errors = new CompilerError[0];", "+    Pair<LinkedList<ParseException>, LinkedList<Pair<String, JExpression>>> errors;", "+    LinkedList<ParseException> parseExceptions;", "+    LinkedList<Pair<String, JExpression>> visitorErrors;", "+      LinkedList<CompilerError> compilerErrors = new LinkedList<CompilerError>();", "-      errors = compiler.compile(sourceRoots, files);", "+//      if (DrJava.getConfig().getSetting(OptionConstants.LANGUAGE_LEVEL) == DrJava.ELEMENTARY_LEVEL) {", "+      LanguageLevelConverter llc = new LanguageLevelConverter();", "+      // Language level files are moved to another file, copied back", "+      // in augmented form to be compiled.  This compiled version", "+      // is also copied to another file with the same path with the ", "+      // \".augmented\" suffix on the end.", "+      // We have to copy the original back to its original spot so the", "+      // user doesn't have to do anything funny.", "+      //      LinkedList<File> filesToRestore = new LinkedList<File>();", "+      //      System.out.println(\"Calling convert!\");", "+      errors = llc.convert(files);//, filesToRestore);", "+      ", "+      /**Rename any .dj0 files in files to be .java files, so the correct thing is compiled.*/", "+      for (int i = 0; i<files.length; i++) {", "+        String fileName = files[i].getAbsolutePath();", "+        int lastIndex = fileName.lastIndexOf(\".dj\");", "+        if (lastIndex != -1) {", "+          files[i]=new File(fileName.substring(0, lastIndex) + \".java\");", "+        }", "+      }", "+      parseExceptions = errors.getFirst();", "+      compilerErrors.addAll(_parseExceptions2CompilerErrors(parseExceptions));", "+      visitorErrors = errors.getSecond();", "+      compilerErrors.addAll(_visitorErrors2CompilerErrors(visitorErrors));", "+//      }", "+//      System.out.println(\"Got back \" + errors.length + \" errors\");", "+      CompilerError[] compilerErrorsArray = (CompilerError[]) compilerErrors.toArray(new CompilerError[0]);", "+      if (compilerErrorsArray.length == 0) {", "+        compilerErrorsArray = compiler.compile(sourceRoots, files);", "+      }", "+//      Iterator<File> iter = filesToRestore.iterator();", "+//      while (iter.hasNext()) {", "+//        _getter.getDocumentForFile(iter.next()).revertFile();", "+//      }", "+      _distributeErrors(compilerErrorsArray);", "+      // Restore the files that were moved.", "+//      Iterator<File> iter = filesToRestore.iterator();", "+//      while (iter.hasNext()) {", "+//        File f = iter.next();", "+//        File sourceFile = new File(f.getAbsolutePath() + \".beginner\");", "+//        // Windows needs this since otherwise rename won't work.", "+//        if (f.exists()) {", "+//          f.delete();", "+//        }", "+//        sourceFile.renameTo(f);", "+//      }", "-    _distributeErrors(errors);", "+    else {", "+      _distributeErrors(new CompilerError[0]);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "baf260563450c9ffee215c4cfa9f6f8a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/TreeClass.java", "commitBeforeChange": "a139a9e69c4b7dea4b85588b3ff50e2c7a8a902f", "commitAfterChange": "482d47c4f5e2278590cc3b5fe2d773412c0b60da", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "   public TreeClass(String fullName, DJClass declaring, Access.Module accessModule, Node ast,                    final TreeClassLoader loader, Options opt)", "signatureAfterChange": "   public TreeClass(String fullName, DJClass declaring, Access.Module accessModule, final Node ast,                    final TreeClassLoader loader, Options opt)", "diff": ["-  public TreeClass(String fullName, DJClass declaring, Access.Module accessModule, Node ast,", "+  public TreeClass(String fullName, DJClass declaring, Access.Module accessModule, final Node ast,", "-        catch (LinkageError e) { throw new RuntimeException(\"Error loading class\", e); }", "+        catch (LinkageError e) {", "+          // bugfix for bug 2674112: Error loading class in Interpreter", "+          // maybe this isn't the best place", "+          if (e instanceof IllegalAccessError) {", "+            // catch this particular error and provide a better error message", "+            String msg = e.getMessage();", "+            final String PREFIX = \"class \";", "+            final String[] INFIX = new String[] { \" cannot access its superclass \",", "+              \" cannot access its superinterface \" };", "+            final String[] ERROR_MSGS = new String[] { \"class.cannot.access.superclass\",", "+              \"class.cannot.access.superinterface\" };", "+            if (msg.startsWith(PREFIX)) {", "+              for (int i=0; i<INFIX.length; ++i) {", "+                final String infix = INFIX[i];", "+                int infixPos = msg.indexOf(infix);", "+                if ((infixPos>=0) && (infixPos>=PREFIX.length())) {", "+                  String className0 = msg.substring(PREFIX.length(), infixPos).trim();", "+                  String className1 = msg.substring(infixPos+infix.length()).trim();", "+                  koala.dynamicjava.interpreter.NodeProperties.setErrorStrings(ast, className0, className1);", "+                  ExecutionError ee = new ExecutionError(ERROR_MSGS[i], ast);", "+                  throw new WrappedException(new CheckerException(ee));", "+                }", "+              }", "+            }", "+          }", "+          throw new RuntimeException(\"Error loading class\", e);", "+        }"]}], "num": 1784}