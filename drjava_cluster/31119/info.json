{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2e9a5c3186126d1749835685203a4d61", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0d294fa5336c3c8c77df1aa7088cf407", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/JPDADebugger.java", "commitBeforeChange": "81f7bc68ef7285bacd5689ea0a54ea5647d9a1d8", "commitAfterChange": "12384109e03448701c98d404f37be617f6e32fee", "methodNumberBeforeChange": 72, "methodNumberAfterChange": 72, "signatureBeforeChange": "   private void _defineVariable(ThreadReference suspendedThreadRef,                                ObjectReference debugInterpreter,                                String name, Value val, Type type)     throws InvalidTypeException, AbsentInformationException, IncompatibleThreadStateException,     ClassNotLoadedException, InvocationException, DebugException", "signatureAfterChange": "   private void _defineVariable(ThreadReference suspendedThreadRef,                                ObjectReference debugInterpreter,                                String name, Value val, Type type)     throws InvalidTypeException, AbsentInformationException, IncompatibleThreadStateException,     ClassNotLoadedException, InvocationException, DebugException", "diff": ["-    // invokeMethod could execute. This happened infrequently so by trying this", "-    // multiple times, the chance of failure each time should be acceptably low.", "-     ", "-    int tries = 0;", "-    while (tries < MAXINVOKETRIES) {", "-      List args = new LinkedList();", "-      args.add(_vm.mirrorOf(name));", "-      args.add(val);", "-      if (type == null) {", "-        args.add(null);", "-      }", "-      else if (type instanceof ReferenceType) {", "-        args.add(((ReferenceType)type).classObject());", "-      }", "-      ", "-      /* System.out.println(\"Calling \" + method2Call.toString() + \"with \" + args.get(0).toString()); */", "-      try {", "-        debugInterpreter.invokeMethod(suspendedThreadRef, method2Call, args,", "-                                      ObjectReference.INVOKE_SINGLE_THREADED);", "-        return;", "-      }", "-      catch (ObjectCollectedException oce) {", "-        tries++;", "-      }", "+    // invokeMethod could execute. We now just disable collection until after the", "+    // method is invoked.", "+    ", "+    List args = new LinkedList();", "+    StringReference sr = _vm.mirrorOf(name);", "+    sr.disableCollection();", "+    args.add(sr);", "+    args.add(val);", "+    if (type == null) {", "+      args.add(null);", "-    throw new DebugException(\"The variable: \" + name +", "-                             \" could not be defined in the debug interpreter\");", "-  }  ", "+    else if (type instanceof ReferenceType) {", "+      args.add(((ReferenceType)type).classObject());", "+    }", "+    ", "+    /* System.out.println(\"Calling \" + method2Call.toString() + \"with \" + args.get(0).toString()); */", "+    try {", "+      debugInterpreter.invokeMethod(suspendedThreadRef, method2Call, args,", "+                                    ObjectReference.INVOKE_SINGLE_THREADED);", "+      return;", "+    }", "+    catch (ObjectCollectedException oce) {", "+      throw new DebugException(\"The variable: \" + name +", "+                               \" could not be defined in the debug interpreter\");", "+    }", "+    finally {", "+      sr.enableCollection();", "+    } ", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "abc2a20d4a8c288e83e9baa9e049c5d2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/JPDADebugger.java", "commitBeforeChange": "81f7bc68ef7285bacd5689ea0a54ea5647d9a1d8", "commitAfterChange": "12384109e03448701c98d404f37be617f6e32fee", "methodNumberBeforeChange": 69, "methodNumberAfterChange": 69, "signatureBeforeChange": "   private ObjectReference _getDebugInterpreter(String interpreterName,                                                ThreadReference threadRef)     throws InvalidTypeException, ClassNotLoadedException,     IncompatibleThreadStateException, InvocationException, DebugException", "signatureAfterChange": "   private ObjectReference _getDebugInterpreter(String interpreterName,                                                ThreadReference threadRef)     throws InvalidTypeException, ClassNotLoadedException,     IncompatibleThreadStateException, InvocationException, DebugException", "diff": ["-    // invokeMethod could execute. This happened infrequently so by trying this", "-    // multiple times, the chance of failure each time should be acceptably low.", "+    // invokeMethod could execute. We now just disable collection until after the", "+    // method is invoked.", "-    int tries = 0;", "-    while (tries < MAXINVOKETRIES) {", "-      LinkedList args = new LinkedList();", "-      args.add(_vm.mirrorOf(interpreterName)); // make the String a JDI Value", "-      if( printMessages ) {", "-        System.out.println(\"Invoking \" + m.toString() + \" on \" + args.toString());", "-        System.out.println(\"Thread is \" + threadRef.toString() + \" <suspended = \" + threadRef.isSuspended() + \">\");", "-      }", "+    ", "+    LinkedList args = new LinkedList();", "+    StringReference sr = _vm.mirrorOf(interpreterName);", "+    sr.disableCollection();", "+    args.add(sr); // make the String a JDI Value", "+    if( printMessages ) {", "+      System.out.println(\"Invoking \" + m.toString() + \" on \" + args.toString());", "+      System.out.println(\"Thread is \" + threadRef.toString() + \" <suspended = \" + threadRef.isSuspended() + \">\");", "+    }    ", "+    ", "+    try {", "+      ObjectReference tmpInterpreter = (ObjectReference) _interpreterJVM.invokeMethod(threadRef, m, args,", "+                                                                                      ObjectReference.INVOKE_SINGLE_THREADED);", "-      try {", "-        ObjectReference tmpInterpreter = (ObjectReference) _interpreterJVM.invokeMethod(threadRef, m, args,", "-                                     ObjectReference.INVOKE_SINGLE_THREADED);", "-        if( printMessages ) System.out.println(\"Returning...\");", "-        return tmpInterpreter;", "-      }", "-      catch (ObjectCollectedException oce) {", "-        tries++;", "-      }", "+      ", "+      if( printMessages ) System.out.println(\"Returning...\");", "+      return tmpInterpreter;", "-    throw new DebugException(\"The debugInterpreter: \" + interpreterName + \" could not be obtained from interpreterJVM\");", "-    ", "+    catch (ObjectCollectedException e) {", "+      throw new DebugException(\"The debugInterpreter: \" + interpreterName + \" could not be obtained from interpreterJVM\");", "+    }    ", "+    finally {", "+      sr.enableCollection();", "+    }"]}], "num": 31119}