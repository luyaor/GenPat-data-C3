{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6c53adee04412cd511910ced4b1e0712", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0002ffa2776c33d45c57be9129138924", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/TypeNameChecker.java", "commitBeforeChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "commitAfterChange": "30059ed25163a0d152720ce9c2edb44f030e5f3b", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "     @Override public Type visit(HookTypeName node)", "signatureAfterChange": "     @Override public Type visit(HookTypeName node)", "diff": ["-      Type bound = check(node.getHookedType());", "-      if (node.isSupered()) {", "-        return setType(node, new Wildcard(new BoundedSymbol(node, TypeSystem.OBJECT, bound)));", "+      Type upper = TypeSystem.OBJECT;", "+      if (node.getUpperBound().isSome()) {", "+        upper = check(node.getUpperBound().unwrap());", "+        if (!ts.isReference(upper)) {", "+          setErrorStrings(node, ts.userRepresentation(upper));", "+          throw new ExecutionError(\"wildcard.bound\", node);", "+        }", "-      else { return setType(node, new Wildcard(new BoundedSymbol(node, bound, TypeSystem.NULL))); }", "+      ", "+      Type lower = TypeSystem.NULL;", "+      if (node.getLowerBound().isSome()) {", "+        lower = check(node.getLowerBound().unwrap());", "+        if (!ts.isReference(lower)) {", "+          setErrorStrings(node, ts.userRepresentation(lower));", "+          throw new ExecutionError(\"wildcard.bound\", node);", "+        }", "+      }", "+", "+      if (!ts.isSubtype(lower, upper)) {", "+        setErrorStrings(node, ts.userRepresentation(upper), ts.userRepresentation(lower));", "+        throw new ExecutionError(\"wildcard.bounds\", node);", "+      }", "+      ", "+      return setType(node, new Wildcard(new BoundedSymbol(node, upper, lower)));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "72da6400de54296209c269bb5cb8b6b2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/StatementChecker.java", "commitBeforeChange": "b125d4a35b225e9cc738f569b062e7e7bd7cf031", "commitAfterChange": "9ce155a1f3e34352032d821032cb2dc70024460f", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 26, "signatureBeforeChange": "   @Override public TypeContext visit(ReturnStatement node)", "signatureAfterChange": "   @Override public TypeContext visit(ReturnStatement node)", "diff": ["-    // TODO: Check that the return type is correct (including the void case)", "-    if (node.getExpression() != null) { checkType(node.getExpression()); }", "+    Type expected = context.getReturnType();", "+    if (expected == null) { throw new ExecutionError(\"return.not.allowed\", node); }", "+", "+    if (node.getExpression() == null) {", "+      if (!expected.equals(TypeSystem.VOID)) {", "+        setErrorStrings(node, ts.userRepresentation(TypeSystem.VOID),", "+                        ts.userRepresentation(expected));", "+        throw new ExecutionError(\"return.type\", node);", "+      }", "+    }", "+    else {", "+      checkType(node.getExpression(), expected);", "+      try {", "+        Expression newExp = ts.assign(expected, node.getExpression());", "+        node.setExpression(newExp);", "+      }", "+      catch (UnsupportedConversionException e) {", "+        setErrorStrings(node, ts.userRepresentation(getType(node.getExpression())),", "+                        ts.userRepresentation(expected));", "+        throw new ExecutionError(\"return.type\", node);", "+      }", "+    }", "+    "]}], "num": 26448}