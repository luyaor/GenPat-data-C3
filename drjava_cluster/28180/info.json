{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5531ffcec97e196f69cdb776055b5b68", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "41c318f2caf5474b04f757419201ec9f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r   private static MethodData _selectTheMostSpecificMethod(List<MethodData> list, InstanceData[] arguments, JExpression jexpr)", "signatureAfterChange": "   private static MethodData _selectTheMostSpecificMethod(List<MethodData> list, InstanceData[] arguments, JExpression jexpr)", "diff": ["-   */\r", "-  private static MethodData _selectTheMostSpecificMethod(List<MethodData> list, InstanceData[] arguments, JExpression jexpr) {\r", "-    if (list.isEmpty()) return null;\r", "-    Iterator<MethodData> it = list.iterator();\r", "-    MethodData best = it.next();\r", "-    MethodData ambiguous = null; // there is no ambiguous other method at first\r", "-    while (it.hasNext()) {\r", "-      MethodData curr = it.next();\r", "-      SymbolData[] bestParams = new SymbolData[best.getParams().length];\r", "-      SymbolData[] currParams = new SymbolData[curr.getParams().length];\r", "-      \r", "-      boolean better1 = false; // whether 'best' is better than 'curr'\r", "-      boolean better2 = false; // whether 'curr' is better than 'best'\r", "-      for (int i = 0; i < bestParams.length; i++) {\r", "-        SymbolData bp = best.getParams()[i].getType().getSymbolData();\r", "-        SymbolData cp = curr.getParams()[i].getType().getSymbolData();\r", "-        boolean fromCurrToBest = cp.isAssignableTo(bp, _targetVersion);\r", "-        boolean fromBestToCurr = bp.isAssignableTo(cp, _targetVersion);\r", "-        bestParams[i] = bp;\r", "-        currParams[i] = cp;\r", "-                  \r", "-        if (fromBestToCurr && !fromCurrToBest) {// best's parameter[i] is more specific than curr's\r", "-          better1 = true; // so best is better than curr\r", "-        }\r", "-        if (fromCurrToBest && !fromBestToCurr) {// curr's parameter[i] is more specific than best's\r", "-          better2 = true; // so curr is better than best\r", "-        }\r", "-      }\r", "-      \r", "-      // decide which is more specific or whether they are ambiguous\r", "-      if (better1 == better2) { // neither is better than the other\r", "-        // Handle overridden methods\r", "-        if (Arrays.equals(bestParams, currParams)) {\r", "-          SymbolData c1 = best.getSymbolData();\r", "-          SymbolData c2 = curr.getSymbolData();\r", "-          boolean c1IsSuperOrSame = c2.isAssignableTo(c1, _targetVersion);\r", "-          boolean c2IsSuperOrSame = c1.isAssignableTo(c2, _targetVersion);\r", "-          if (c1IsSuperOrSame && !c2IsSuperOrSame) { // c2 is more specific\r", "-            best = curr;\r", "-            continue;\r", "-          }\r", "-          else if (c2IsSuperOrSame && !c1IsSuperOrSame) { // c1 is more specific\r", "-            continue;\r", "-          }\r", "-        }\r", "-        ambiguous = curr;\r", "-      }\r", "-      else if (better2) {\r", "-        best = curr;\r", "-        ambiguous = null; // no more ambiguity\r", "-      }\r", "-    }\r", "-    if (ambiguous != null) {\r", "-      StringBuffer invokeArgs = new StringBuffer(\"(\");\r", "-      StringBuffer ambigArgs = new StringBuffer(\"(\");\r", "-      StringBuffer bestArgs = new StringBuffer(\"(\");\r", "-      for (int i = 0; i<arguments.length; i++) {\r", "-        if (i>0) {\r", "-          invokeArgs.append(\", \");\r", "-          ambigArgs.append(\", \");\r", "-          bestArgs.append(\", \");\r", "-        }\r", "-        invokeArgs.append(arguments[i].getSymbolData().getName());\r", "-        ambigArgs.append(ambiguous.getParams()[i].getType().getSymbolData().getName());\r", "-        bestArgs.append(best.getParams()[i].getType().getSymbolData().getName());\r", "-      }\r", "-      invokeArgs.append(\")\");\r", "-      ambigArgs.append(\")\");\r", "-      bestArgs.append(\")\");\r", "-      _addError(best.getName() + invokeArgs.toString() + \" is an ambiguous invocation.  It matches both \" + best.getName() + bestArgs.toString() + \" and \" + ambiguous.getName() + ambigArgs.toString(), jexpr);\r", "-    }\r", "-    return best;\r", "-  }\r", "+   */", "+  private static MethodData _selectTheMostSpecificMethod(List<MethodData> list, InstanceData[] arguments, JExpression jexpr) {", "+    if (list.isEmpty()) return null;", "+    Iterator<MethodData> it = list.iterator();", "+    MethodData best = it.next();", "+    MethodData ambiguous = null; // there is no ambiguous other method at first", "+    while (it.hasNext()) {", "+      MethodData curr = it.next();", "+      SymbolData[] bestParams = new SymbolData[best.getParams().length];", "+      SymbolData[] currParams = new SymbolData[curr.getParams().length];", "+      ", "+      boolean better1 = false; // whether 'best' is better than 'curr'", "+      boolean better2 = false; // whether 'curr' is better than 'best'", "+      for (int i = 0; i < bestParams.length; i++) {", "+        SymbolData bp = best.getParams()[i].getType().getSymbolData();", "+        SymbolData cp = curr.getParams()[i].getType().getSymbolData();", "+        boolean fromCurrToBest = cp.isAssignableTo(bp, LanguageLevelConverter.OPT.javaVersion());", "+        boolean fromBestToCurr = bp.isAssignableTo(cp, LanguageLevelConverter.OPT.javaVersion());", "+        bestParams[i] = bp;", "+        currParams[i] = cp;", "+                  ", "+        if (fromBestToCurr && !fromCurrToBest) {// best's parameter[i] is more specific than curr's", "+          better1 = true; // so best is better than curr", "+        }", "+        if (fromCurrToBest && !fromBestToCurr) {// curr's parameter[i] is more specific than best's", "+          better2 = true; // so curr is better than best", "+        }", "+      }", "+      ", "+      // decide which is more specific or whether they are ambiguous", "+      if (better1 == better2) { // neither is better than the other", "+        // Handle overridden methods", "+        if (Arrays.equals(bestParams, currParams)) {", "+          SymbolData c1 = best.getSymbolData();", "+          SymbolData c2 = curr.getSymbolData();", "+          boolean c1IsSuperOrSame = c2.isAssignableTo(c1, LanguageLevelConverter.OPT.javaVersion());", "+          boolean c2IsSuperOrSame = c1.isAssignableTo(c2, LanguageLevelConverter.OPT.javaVersion());", "+          if (c1IsSuperOrSame && !c2IsSuperOrSame) { // c2 is more specific", "+            best = curr;", "+            continue;", "+          }", "+          else if (c2IsSuperOrSame && !c1IsSuperOrSame) { // c1 is more specific", "+            continue;", "+          }", "+        }", "+        ambiguous = curr;", "+      }", "+      else if (better2) {", "+        best = curr;", "+        ambiguous = null; // no more ambiguity", "+      }", "+    }", "+    if (ambiguous != null) {", "+      StringBuffer invokeArgs = new StringBuffer(\"(\");", "+      StringBuffer ambigArgs = new StringBuffer(\"(\");", "+      StringBuffer bestArgs = new StringBuffer(\"(\");", "+      for (int i = 0; i<arguments.length; i++) {", "+        if (i>0) {", "+          invokeArgs.append(\", \");", "+          ambigArgs.append(\", \");", "+          bestArgs.append(\", \");", "+        }", "+        invokeArgs.append(arguments[i].getSymbolData().getName());", "+        ambigArgs.append(ambiguous.getParams()[i].getType().getSymbolData().getName());", "+        bestArgs.append(best.getParams()[i].getType().getSymbolData().getName());", "+      }", "+      invokeArgs.append(\")\");", "+      ambigArgs.append(\")\");", "+      bestArgs.append(\")\");", "+      _addError(best.getName() + invokeArgs.toString() + \" is an ambiguous invocation.  It matches both \" + best.getName() + bestArgs.toString() + \" and \" + ambiguous.getName() + ambigArgs.toString(), jexpr);", "+    }", "+    return best;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "864d12567990bc2c3431da9788529330", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/SymbolData.java", "commitBeforeChange": "e30b4e4c8e80ae8b71c5491615e19a1fcef8844f", "commitAfterChange": "b0ebef930df36d2e563113951e5589e519a9b2a8", "methodNumberBeforeChange": 83, "methodNumberAfterChange": 83, "signatureBeforeChange": "\r   protected static boolean checkDifferentReturnTypes(MethodData md, SymbolData sd, boolean addError, JavaVersion version)", "signatureAfterChange": "   protected static boolean checkDifferentReturnTypes(MethodData md, SymbolData sd, boolean addError, JavaVersion version)", "diff": ["-   */\r", "-  protected static boolean checkDifferentReturnTypes(MethodData md, SymbolData sd, boolean addError, JavaVersion version) {\r", "-    // We only want to check the super class and interfaces, not outer classes.\r", "-    LinkedList<SymbolData> interfaces = sd.getInterfaces();    \r", "-    LinkedList<SymbolData> enclosingData = new LinkedList<SymbolData>();\r", "-    enclosingData.addAll(interfaces);\r", "-    SymbolData superClass = sd.getSuperClass();\r", "-    if (superClass != null) {\r", "-      enclosingData.add(superClass);\r", "-    }\r", "-    Iterator<SymbolData> iter = enclosingData.iterator();\r", "-    while (iter.hasNext()) {\r", "-      SymbolData currSd = iter.next();\r", "-      MethodData matchingMd = repeatedSignature(currSd.getMethods(), md);\r", "-      if (matchingMd != null) {\r", "-        boolean subclass = md.getReturnType().isSubClassOf(matchingMd.getReturnType());\r", "-        if (matchingMd.getReturnType() != md.getReturnType() && !(subclass && LanguageLevelConverter.versionIs15(version))) {\r", "-          StringBuffer methodSignature = new StringBuffer(md.getName() + \"(\");\r", "-          VariableData[] params = md.getParams();\r", "-          for (int i = 0; i < params.length; i++) {\r", "-            if (i > 0) {\r", "-              methodSignature.append(\", \");\r", "-            }\r", "-            methodSignature.append(params[i].getType().getName());\r", "-          }\r", "-          methodSignature.append(\")\");\r", "-          String methodSigString = methodSignature.toString();\r", "-          // This entire method is only called from the type checker, so add an error to its error list.\r", "-          if (addError) { TypeChecker.errors.addLast(new Pair<String, JExpressionIF>(methodSigString + \" in \" + sd.getName() + \r", "-                             \" cannot override \" + methodSigString + \" in \" +\r", "-                             currSd.getName() + \"; attempting to use different return types\",\r", "-                                                                                   md.getJExpression())); }\r", "-          return true;\r", "-        }\r", "-        if (!_isAssignable(matchingMd, md)) {\r", "-          String access = \"package\";\r", "-          if (matchingMd.hasModifier(\"private\")) {access = \"private\";}\r", "-          if (matchingMd.hasModifier(\"public\")) {access = \"public\";}\r", "-          if (matchingMd.hasModifier(\"protected\")) {access = \"protected\";}\r", "-          if (addError) {TypeChecker.errors.addLast(new Pair<String, JExpressionIF>(md.getName() + \" in \" + md.getSymbolData().getName() + \" cannot override \" + matchingMd.getName() + \" in \" + matchingMd.getSymbolData().getName() + \".  You are attempting to assign weaker access priviledges. In \" + matchingMd.getSymbolData().getName() + \", \"  + matchingMd.getName() + \" was \" + access, md.getJExpression()));} \r", "-          return true;\r", "-        }\r", "-      }\r", "-      else {\r", "-        if (checkDifferentReturnTypes(md, currSd, version)) {\r", "-          return true;\r", "-        }\r", "-      }\r", "-    }\r", "-    return false;\r", "-  }\r", "+   */", "+  protected static boolean checkDifferentReturnTypes(MethodData md, SymbolData sd, boolean addError, JavaVersion version) {", "+    // We only want to check the super class and interfaces, not outer classes.", "+    LinkedList<SymbolData> interfaces = sd.getInterfaces();    ", "+    LinkedList<SymbolData> enclosingData = new LinkedList<SymbolData>();", "+    enclosingData.addAll(interfaces);", "+    SymbolData superClass = sd.getSuperClass();", "+    if (superClass != null) {", "+      enclosingData.add(superClass);", "+    }", "+    Iterator<SymbolData> iter = enclosingData.iterator();", "+    while (iter.hasNext()) {", "+      SymbolData currSd = iter.next();", "+      MethodData matchingMd = repeatedSignature(currSd.getMethods(), md);", "+      if (matchingMd != null) {", "+        boolean subclass = md.getReturnType().isSubClassOf(matchingMd.getReturnType());", "+        if (matchingMd.getReturnType() != md.getReturnType() && !(subclass && LanguageLevelConverter.versionIs15(version))) {", "+          StringBuffer methodSignature = new StringBuffer(md.getName() + \"(\");", "+          VariableData[] params = md.getParams();", "+          for (int i = 0; i < params.length; i++) {", "+            if (i > 0) {", "+              methodSignature.append(\", \");", "+            }", "+            methodSignature.append(params[i].getType().getName());", "+          }", "+          methodSignature.append(\")\");", "+          String methodSigString = methodSignature.toString();", "+          // This entire method is only called from the type checker, so add an error to its error list.", "+          if (addError) { ", "+            TypeChecker.errors.addLast(new Pair<String, JExpressionIF>(methodSigString + \" in \" + sd.getName() + ", "+                                                                       \" cannot override \" + methodSigString + \" in \" +", "+                                                                       currSd.getName() + ", "+                                                                       \"; attempting to use different return types\",", "+                                                                       md.getJExpression())); }", "+          return true;", "+        }", "+        ", "+        if (! _isCompatible(matchingMd, md)) {  // check compatibility of visiblity modifiers", "+          String access = \"package\";", "+          if (matchingMd.hasModifier(\"private\")) access = \"private\";", "+          if (matchingMd.hasModifier(\"public\")) access = \"public\";", "+          if (matchingMd.hasModifier(\"protected\")) access = \"protected\";", "+          if (addError) {", "+            TypeChecker.errors.", "+              addLast(new Pair<String, JExpressionIF>(md.getName() + \" in \" + md.getSymbolData().getName() +", "+                                                      \" cannot override \" + matchingMd.getName() + \" in \" +", "+                                                      matchingMd.getSymbolData().getName() + ", "+                                                      \".  You are attempting to assign weaker access priviledges. In \" +", "+                                                      matchingMd.getSymbolData().getName() + \", \" + matchingMd.getName() +", "+                                                      \" was \" + access, md.getJExpression())); } ", "+          return true;", "+        }", "+      }", "+      else if (checkDifferentReturnTypes(md, currSd, version)) return true;", "+    }", "+    return false;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "890b0409124cdaf0ef913cb7a08bf60b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 79, "methodNumberAfterChange": 82, "signatureBeforeChange": "   public void createConstructor(SymbolData sd)", "signatureAfterChange": "   public void createConstructor(SymbolData sd)", "diff": ["-    ", "-    SymbolData superSd = sd.getSuperClass();", "-    ", "-    //there was an error somewhere else.  just return.", "-    if (sd.isContinuation()) return;", "-    ", "-    LinkedList<MethodData> superMethods = superSd.getMethods();", "-    String superUnqualifiedName = getUnqualifiedClassName(superSd.getName());", "-    ", "-    LanguageLevelVisitor sslv = LanguageLevelConverter._newSDs.remove(superSd);", "-    if (sslv != null) {sslv.createConstructor(superSd);}", "-    ", "-    // Find the super's smallest constructor.", "-    MethodData superConstructor = null;", "-    Iterator<MethodData> iter = superMethods.iterator();", "-    while (iter.hasNext()) {", "-      MethodData superMd = iter.next();", "-      if (superMd.getName().equals(superUnqualifiedName)) {", "-        if (superConstructor == null || superMd.getParams().length < superConstructor.getParams().length) {", "-          superConstructor = superMd;", "-        }", "-      }", "+ ", "+    System.err.println(\"**** createConstructor called for \" + sd);", "+        ", "+//    if (sd == null) {", "+//      System.err.println(\"**** Error **** After fixups, SymbolData \" + sd + \" has null for a super class\");", "+//      assert false;", "+//    }", "+//    ", "+    if (sd.isContinuation()) {", "+      _addError(\"Could not generate constructor for class \" + sd + \" because it has no definition\", ", "+                new NullLiteral(SourceInfo.NO_INFO));", "+      return;", "-    String name = getUnqualifiedClassName(sd.getName());", "-    MethodData md = new MethodData(name,", "-                                   new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}), ", "-                                   new TypeParameter[0], ", "-                                   sd, ", "-                                   new VariableData[0], // Parameters to be filled in later. ", "-                                   new String[0], ", "-                                   sd,", "-                                   null);", "+    SymbolData superSd = sd.getSuperClass();", "+    if (superSd == null) {", "+      _addError(\"Could not generate constructor for class \" + sd + \" because it has no superclass\", ", "+                new NullLiteral(SourceInfo.NO_INFO));", "+      return;", "+    }", "-    LinkedList<VariableData> params = new LinkedList<VariableData>();", "-    if (superConstructor != null) {", "+    else {", "+      LinkedList<MethodData> superMethods = superSd.getMethods();", "+      String superUnqualifiedName = getUnqualifiedClassName(superSd.getName());", "+      ", "+      LanguageLevelVisitor sslv = LanguageLevelConverter._newSDs.remove(superSd);", "+      ", "+      // if sslv == null, the superclass constructor has already been generated or we are caught in a cyclic", "+      // inheritance hierarchy", "+      if (sslv != null) {", "+        sslv.createConstructor(superSd);", "+        System.err.println(\"Creating constructor for superclass \" + superSd);", "+      }", "+      ", "+      // Find the super's smallest constructor.", "+      MethodData superConstructor = null;", "+      for (MethodData superMd: superMethods) {", "+//      Iterator<MethodData> iter = superMethods.iterator();", "+//      while (iter.hasNext()) {", "+//        MethodData superMd = iter.next();", "+        if (superMd.getName().equals(superUnqualifiedName)) {", "+          if (superConstructor == null || superMd.getParams().length < superConstructor.getParams().length) {", "+            superConstructor = superMd;", "+          }", "+        }", "+      }", "+      if (superConstructor == null) {", "+        _addAndIgnoreError(\"Could not generate constructor for class \" + sd + \" superclass has no constructor, perhaps\"", "+                           + \" because the class hierarchy is cyclic.\",", "+                           new NullLiteral(SourceInfo.NO_INFO));", "+        return;", "+      }", "+//      if (superConstructor == null) {", "+//        System.err.println(\"**** Error **** The superclass \" + superSd + \" has no constructors \");", "+//      }", "+      String name = getUnqualifiedClassName(sd.getName());", "+      MethodData md = new MethodData(name,", "+                                     PUBLIC_MAV, ", "+                                     new TypeParameter[0], ", "+                                     sd, ", "+                                     new VariableData[0], // Parameters to be filled in later. ", "+                                     new String[0], ", "+                                     sd,", "+                                     null);", "+      ", "+      LinkedList<VariableData> params = new LinkedList<VariableData>();", "+//      if (superConstructor != null) {", "-        VariableData newParam = ", "-          new VariableData(paramName, new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[0]), ", "-                           superParam.getType().getSymbolData(), true, md);", "+        SymbolData superParamSD = superParam.getType();", "+        assert superParamSD != null;", "+        VariableData newParam = new VariableData(paramName, PACKAGE_MAV, superParamSD, true, sd);  // Note: sd was md", "-        md.addVar(newParam); ", "+        md.addVar(newParam);  // Fixups have already been executed", "-    }", "+//      }", "-    // only add in those fields that do not have a value and are not static.", "-    boolean hasOtherConstructor = sd.hasMethod(name);", "-    ", "-    for (VariableData field : sd.getVars()) {", "+      // only add in those fields that do not have a value and are not static.", "+      boolean hasOtherConstructor = sd.hasMethod(name);", "-      if (! field.hasInitializer() && ! field.hasModifier(\"static\")) {", "-        if (! hasOtherConstructor) { field.gotValue(); } // Set hasValue if no other constructors need to be visited", "-        // Rather than creating a new parameter, we use the field, since all the important data is the same in both of", "-        // them.", "-        params.add(field);", "+      for (VariableData field : sd.getVars()) {", "+        ", "+        if (! field.hasInitializer() && ! field.hasModifier(\"static\")) {", "+          if (! hasOtherConstructor) { field.gotValue(); } // Set hasValue if no other constructors need to be visited", "+          // Rather than creating a new parameter, we use the field, since all the important data is the same in both of", "+          // them.", "+          VariableData param = field.copyWithoutVisibility();", "+          params.add(param);", "+        }", "+      // Some fields may be declared private, but parameters cannot be; unprivatize the ", "+      ", "+      md.setParams(params.toArray(new VariableData[params.size()]));", "+      md.setVars(params);", "+      ", "+      System.err.println(\"**** Adding constructor \" + md + \" **** to symbol \" + sd);", "+//      if (md.getName().equals(\"ClassName\"))", "+//        System.err.println(\"****** constructor visibility = \" + md.getMav());", "+      addGeneratedMethod(sd, md);", "-    md.setParams(params.toArray(new VariableData[params.size()]));", "-    md.setVars(params);", "-    ", "-    addGeneratedMethod(sd, md);"]}], "num": 28180}