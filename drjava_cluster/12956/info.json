{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6b81f7e9a8f4ecacdc1ebdf566504b91", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "61678da6f975fa238c3f20d66c6a8367", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/MainFrame.java", "commitBeforeChange": "634bad3816e5a89c71c174f08f33c3f80727cfeb", "commitAfterChange": "d1ffac675273323f7a1b9777462d16896d09a1af", "methodNumberBeforeChange": 383, "methodNumberAfterChange": 388, "signatureBeforeChange": "          public void activeDocumentChanged(final OpenDefinitionsDocument active)", "signatureAfterChange": "          public void activeDocumentChanged(final OpenDefinitionsDocument active)", "diff": ["-      // Only change GUI from event-dispatching thread", "-      // (This can be called from other threads...)", "-      Utilities.invokeAndWait(new Runnable() {  // invokeAndWait is arguably better but it may create occasional deadlocks.", "+//      Utilities.showDebug(\"MainFrame Listener: ActiveDocument changed to \" + active);", "+      // code that accesses the GUI must run in the event-dispatching thread. ", "+      Utilities.invokeLater(new Runnable() {  // invokeAndWait is arguably better but it may create occasional deadlocks.", "-          "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7658772762bfeea3d11e63c389e3d322", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/MainFrame.java", "commitBeforeChange": "3fffab849ca2a182947577f4918deb05255be914", "commitAfterChange": "37e723fa34df1bc3afa5f0896241b32a56e4dde5", "methodNumberBeforeChange": 369, "methodNumberAfterChange": 372, "signatureBeforeChange": "      public void activeDocumentChanged(final OpenDefinitionsDocument active)", "signatureAfterChange": "          public void activeDocumentChanged(final OpenDefinitionsDocument active)", "diff": ["-", "+    ", "-//      try {  // used or invokeAndWait variation", "-      Utilities.invokeLater(new Runnable() {  // invokeAndWait is arguably better but it may create occasional deadlocks.", "+      try {  // used or invokeAndWait variation", "+      Utilities.invokeAndWait(new Runnable() {  // invokeAndWait is arguably better but it may create occasional deadlocks.", "-          ", "+        ", "-//      }  // used for invokeAndWait variation", "-//      catch(InterruptedException e) { throw new UnexpectedException(e); }", "+      }  // used for invokeAndWait variation", "+      catch(InterruptedException e) { throw new UnexpectedException(e); }"]}], "num": 12956}