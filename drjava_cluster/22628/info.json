{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b9ab24a7a07f37b2af8be11372b6e1b2", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0e9f07e31449b77726103f431aaedbe3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 32, "signatureBeforeChange": "   protected SymbolData defineSymbolData(TypeDefBase typeDefBase, String qualifiedClassName)", "signatureAfterChange": "   protected SymbolData defineSymbolData(final TypeDefBase typeDefBase, final String qualifiedTypeName,                                         final String enclosingClassName)", "diff": ["-  protected SymbolData defineSymbolData(TypeDefBase typeDefBase, String qualifiedClassName) {", "-    String name = qualifiedClassName;  // may be an interface", "-    SymbolData sd = symbolTable.get(name);", "-    if (sd != null && ! sd.isContinuation()) {", "+  protected SymbolData defineSymbolData(final TypeDefBase typeDefBase, final String qualifiedTypeName,", "+                                        final String enclosingClassName /*, final HashSet<String> classesInThisFile*/) {", "+    assert (typeDefBase instanceof InterfaceDef) || (typeDefBase instanceof ClassDef);", "+    assert ! qualifiedTypeName.startsWith(\"null.\");", "+    String name = qualifiedTypeName;  // may be an interface", "+    SymbolData contSd = symbolTable.get(qualifiedTypeName);", "+    System.err.println(\"In defineSymbolData call for \" + qualifiedTypeName + \", contSd = \" + contSd);", "+    if (contSd != null && ! contSd.isContinuation()) {", "-//    if (qualifiedClassName.equals(\"listFW.IList\")) System.err.println(\"**** listFW.Ilist is being defined!\");", "+    // If no continuation exists, create a SymbolData for this definition", "+    final SymbolData sd = (contSd == null) ? new SymbolData(qualifiedTypeName) : contSd;", "+    symbolTable.put(qualifiedTypeName, sd);", "-    // create the LinkedList for the SymbolDatas of the interfaces", "-    LinkedList<SymbolData> interfaces = new LinkedList<SymbolData>();", "-    SymbolData tempSd;", "+//    // Save _enclosingClassName in a final var; may be null if called at the top level, e.g. defining a", "+//    // top level class or interface.", "+//    final String enclosingClassName = _enclosingClassName; ", "-    // Create SymbolDatas (continuations) for the interfaces if they do not already exist", "-    ReferenceType[] rts = typeDefBase.getInterfaces();", "-    for (ReferenceType rt: rts) {", "-      tempSd = getSymbolData(rt.getName(), rt.getSourceInfo(), false, false, false);", "-      ", "-      if (tempSd != null) interfaces.addLast(tempSd);  ", "-      else if (qualifiedClassName.indexOf(\".\") != -1) { // class is inner", "-        // Check to see if this is an inner class referencing an inner interface", "-        String qualifyingPart = qualifiedClassName.substring(0, qualifiedClassName.lastIndexOf(\".\"));", "-        tempSd = getSymbolData(qualifyingPart + \".\" + rt.getName(), rt.getSourceInfo(), false, false, false);", "-        if (tempSd == null) {", "-          String tempName = qualifyingPart + \".\" + rt.getName();", "-          tempSd = new SymbolData(tempName);", "-          tempSd.setInterface(true);", "-//          System.err.println(\"Creating continuation for \" + tempName  + \" at LLV: 1144\");", "-          continuations.put(tempName, new Pair<SourceInfo, LanguageLevelVisitor>(rt.getSourceInfo(), this));          ", "-        }", "-        interfaces.addLast(tempSd);", "-      }", "-      else if (tempSd == null) {  // class is not inner; ith superinterface not yet defined", "-        String tempName = rt.getName();", "-        _log.log(\"CREATING continuation \" + tempName + \" with SourceInfo \" + rt.getSourceInfo());", "-//        System.err.println(\"CREATING continuation for \" + tempName + \" at LLV: 1154\");", "-        tempSd = new SymbolData(tempName);", "-        tempSd.setInterface(true);", "-        continuations.put(tempName, new Pair<SourceInfo, LanguageLevelVisitor>(rt.getSourceInfo(), this));    ", "-      }", "-    }", "-    ", "-    if (sd == null) { // create a new SymbolData.", "-      sd = new SymbolData(name);", "-      symbolTable.put(name, sd);", "-    }", "-    ", "+    // Make this SymbolData as a non-continuation", "+    sd.setIsContinuation(false);", "-     ", "-    SymbolData superClass = null;", "+    // Set the MAV and type parameters (the latter are not used currently)", "+    sd.setMav(typeDefBase.getMav());", "+    sd.setTypeParameters(typeDefBase.getTypeParameters());", "-    // Create a SymbolData for the superclass of typeDefBase", "+    // Create the LinkedList for the SymbolDatas of the interfaces", "+    final ArrayList<SymbolData> interfaces = new ArrayList<SymbolData>();", "+    ", "+    // Get or create SymbolDatas (continuations) for the interfaces", "+    ReferenceType[] rts = typeDefBase.getInterfaces();", "+    for (final ReferenceType rt: rts) {", "+      SymbolData sD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "+      if (sD != null && ! sD.isInterface()) {", "+        sD.setInterface(true);", "+//        System.err.println(\"Interface type = \" + sD);", "+//        assert false;", "+      }", "+      interfaces.add(sD);                     // Note: confirm that null can be added to an ArrayList", "+      if (sD == null) { ", "+        // create a fixup for this interface reference", "+        Command fixUp = new Command() {", "+          public void execute() {", "+            SymbolData newSD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "+            assert newSD != null && newSD.isInterface();  // EXPAND", "+            int lastIndex = interfaces.size() - 1;", "+            interfaces.set(lastIndex, newSD);", "+          }", "+        };", "+        fixUps.add(fixUp);", "+      }", "+    }", "+     ", "+    // Create SymbolData variable for superclass", "+    SymbolData superSD = null;", "+    ", "+    // Get or create the SymbolData for the superclass/interface; setInterface and setSuperClass", "-      //add Object as the super class of this, so that it will know it implements Object's methods.", "-      superClass = getSymbolData(\"Object\", typeDefBase.getSourceInfo(), false);", "+      // set Object as the super class of this, so that it will know it implements Object's methods.", "+      superSD = getSymbolData(\"java.lang.Object\", typeDefBase.getSourceInfo(), false);", "+      sd.setSuperClass(superSD);", "-      ReferenceType rt = cd.getSuperclass();", "-      // rt cannot be null because every user-defined class extends something.  We must resolve", "-      // the superclass before proceeding in order to properly identify words as", "-      // fields or static references to classes.", "-      String superClassName = rt.getName();", "-//      if (superClassName.equals(\"TestCase\") || superClassName.equals(\"junit.framework.TestCase\")) {", "-//            System.out.println(\"WARNING! \" + superClassName + \" encountered as superclass\");", "-//            assert false;", "-//      }", "-      SourceInfo si = rt.getSourceInfo();", "-      // The following line generates an infinite recursion in some cases if resolve (the 3rd parm) is true.  Yet", "-      // when superclass is TestCase and TestCase is not imported", "-      superClass = getSymbolData(superClassName, si, false); //TODO: if true can generate infinite loop in helper", "-      ", "-      if (superClass == null) {", "-        // Couldn't resolve the super class: make it Object by default", "-        superClass = addSymbolData(si, superClassName);", "+      final ReferenceType rt = cd.getSuperclass();", "+      superSD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "+      if (superSD == null && rt.getName().equals(\"Object\"))  {", "+        System.err.println(\"ALARM: _lookupTypeFromWithinClass for 'Object' returned null\");", "+      ", "+      if (superSD != null) sd.setSuperClass(superSD);", "+      else {", "+        Command fixUp = new Command() {", "+          public void execute() { ", "+            SymbolData newSuperSD = _lookupTypeFromWithinClass(rt, enclosingClassName);", "+            System.err.println(\"***** In a FIXUP, looking up type \" + rt + \" from within \" + enclosingClassName);", "+            if (newSuperSD == null)", "+//              newSuperSD = getSymbolData(\"java.lang.Object\", typeDefBase.getSourceInfo(), false);", "+              _addAndIgnoreError(\"The class \" + sd + \" has an undefined superclass \" + rt, typeDefBase);", "+            else", "+              sd.setSuperClass(newSuperSD); ", "+          }", "+        };", "+        fixUps.add(fixUp);", "+      }", "-    else { throw new RuntimeException(\"Internal Program Error: typeDefBase was not a ClassDef or InterfaceDef.\" + ", "-                                      \"  Please report this bug.\"); }", "-    ", "-    // get the SymbolData of the superclass which must be in the symbol table", "-    // since we visited the type in forClassDef() although it may be a continuation. ", "-    ", "-    // there is a continuation in the symbol table, update the fields", "-    sd.setMav(typeDefBase.getMav());", "-    sd.setTypeParameters(typeDefBase.getTypeParameters());", "-    sd.setSuperClass(superClass);", "+    // Set the inferfaces; fixups will be done on the elements of the interface ArrayList", "-    sd.setIsContinuation(false);", "-    _log.log(\"REMOVING continuation \" + sd.getName());", "-    continuations.remove(sd.getName());", "+", "+    // Remove symbol name from continuation table.", "+    _log.log(\"REMOVING continuation \" + qualifiedTypeName);", "+    continuations.remove(qualifiedTypeName);", "+    // Add sd to the list of classes defined in program text; used to generate constructors. TODO: What about Full Java?", "+    ", "+    _classesInThisFile.remove(qualifiedTypeName);  // a no-op if qualifiedClassName is an inner class"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4dc8557227f6b0c6249394935da29e95", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 35, "signatureBeforeChange": "   protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String qualifiedTypeName, Data enclosing)", "signatureAfterChange": "   protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String relName, String qualifiedTypeName,                                               Data enclosing)", "diff": ["-  protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String qualifiedTypeName, Data enclosing) { ", "-        /* IMPORTANT: this is defineSymbol for inner classes! */", "-    String name = qualifiedTypeName;  // may be an interface", "-    SymbolData sd = symbolTable.get(name);", "-    if (sd != null && ! sd.isContinuation()) {", "-      _addAndIgnoreError(\"The class or interface \" + name + \" has already been defined.\", typeDefBase);", "-      return null;", "-    }", "+  protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String relName, String qualifiedTypeName, ", "+                                             Data enclosing) {", "+    assert (enclosing instanceof SymbolData) || (enclosing instanceof MethodData);", "+    /* IMPORTANT: this is defineSymbolData for inner classes! */", "+//    if (qualifiedTypeName.startsWith(\"RefInnerClass\")) {", "+    System.err.println(\"*** defineInnerSymbolData called for '\" + relName + \" with full name \" + qualifiedTypeName + ", "+                       \"' in '\" + enclosing + \"'\");", "+//    }", "+    SymbolData sd = defineSymbolData(typeDefBase, qualifiedTypeName /*, _classesInThisFile*/); ", "+    if (sd == null) System.err.println(\"defineSymbolData failed for \" + qualifiedTypeName);", "+    assert sd != null;", "+    // Set fields of sd that are required for innerSymbols", "+", "+    sd.setOuterData(enclosing);", "-    // create the LinkedList for the SymbolDatas of the interfaces", "-    LinkedList<SymbolData> interfaces = new LinkedList<SymbolData>();", "-    SymbolData tempSd;", "-    ReferenceType[] rts = typeDefBase.getInterfaces();", "-    for (int i = 0; i < rts.length; i++) {", "-      SourceInfo si = rts[i].getSourceInfo();", "-      String tempName = rts[i].getName();", "-      tempSd = getSymbolData(tempName, si, false, false, false);", "-      ", "-      if (tempSd != null) { interfaces.addLast(tempSd); }", "-      ", "-      else if (enclosing instanceof SymbolData) {", "-        // Check to see if this is an inner class referencing an inner interface", "-        tempSd = enclosing.getInnerClassOrInterface(tempName);", "-        if (tempSd == null) {", "-          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "-          String qualifiedTempName = qualifyingPart + \".\" + tempName;", "-          // Should we introduce addInnerInterfaceSymbol ?", "-          tempSd = new SymbolData(qualifiedTempName);", "-          tempSd.setInterface(true);", "-          enclosing.getSymbolData().addInnerInterface(tempSd); //interfaces can only be defined in symbol datas", "-          tempSd.setOuterData(enclosing);", "-//          System.err.println(\"Creating inner interface continuation for \" + qualifiedTempName + \" at LLV: 1042\");", "-          continuations.put(qualifiedTempName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));          ", "-        }", "-        interfaces.addLast(tempSd);", "+//    if (enclosing instanceof SymbolData) { // sd is an inner class or interface of an enclosing class (not a method)", "+    if (sd.isInterface()) {", "+//      assert enclosing instanceof SymbolData;", "+//      assert enclosing.getName().equals(_enclosingClassName):", "+      ((SymbolData) enclosing).addInnerInterface(sd); ", "+    }", "+    else if (! enclosing.getName().equals(_enclosingClassName)) {  ", "+      // sd is a local class embedded in a method.  We need to add sd to  the innerclasses of _enclosingClassName", "+      if (! (enclosing instanceof MethodData))", "+        System.err.println(\"***** In defineInnerSymbolData, enclosing = \" + enclosing ", "+                             + \" but _enclosingClassName = \" + _enclosingClassName);", "+      assert enclosing instanceof MethodData;", "+      SymbolData enclosingClassSD = getQualifiedSymbolData(_enclosingClassName);", "+      assert enclosingClassSD != null;", "+      enclosingClassSD.addInnerClass(sd);", "+      enclosing.addInnerClass(sd);  // adds innerClass to list for the enclosing MethodData ", "+    }", "+    else {", "+      // sd is a non-local inner class", "+      assert enclosing.getName().equals(_enclosingClassName);", "+      enclosing.addInnerClass(sd);", "+//    _innerClassesInThisBody.remove(sd);  // a no-op if _innerClassesInThisBody is empty", "+    }", "+    return sd;", "+  }", "-      else {", "-        _addAndIgnoreError(\"Cannot resolve interface \" + rts[i].getName(), rts[i]);", "-        return null;", "-      }", "-    // create a new symbolData for this inner class or interface if not seen before", "-    if (sd == null) { ", "-      sd = new SymbolData(qualifiedTypeName);", "-      sd.setOuterData(enclosing);", "-      if (typeDefBase instanceof ClassDef) { enclosing.getSymbolData().addInnerClass(sd); }", "-      else { ", "-        enclosing.getSymbolData().addInnerInterface(sd); ", "-    //Set the package to be the current package", "-    sd.setPackage(_package);", "-    ", "-    SymbolData superClass = null;", "-    ", "-    if (typeDefBase instanceof InterfaceDef) {", "-      // Add Object as the super class of this, so that it will know it implements Object's methods.", "-      superClass = getSymbolData(\"Object\", typeDefBase.getSourceInfo(), false);", "-      sd.setInterface(true);", "-    }", "-    else if (typeDefBase instanceof ClassDef) {", "-      ClassDef cd = (ClassDef) typeDefBase;", "-      ReferenceType rt = cd.getSuperclass();", "-      String superClassName = rt.getName();", "-      superClass = getSymbolData(superClassName, rt.getSourceInfo(), false, false, false);", "-      ", "-      if (superClass == null) {  // Why is this necessary?  Forward reference to another inner class?", "-        superClass = enclosing.getInnerClassOrInterface(superClassName);", "-        if (superClass == null) {", "-          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "-          superClass = new SymbolData(qualifyingPart + \".\" + superClassName);", "-          enclosing.addInnerClass(superClass);", "-          superClass.setOuterData(enclosing);", "-//          System.err.println(\"Creating continuation for \" + superClassName + \" at LLV:1079\");", "-          continuations.put(superClassName, new Pair<SourceInfo, LanguageLevelVisitor>(rt.getSourceInfo(), this)); ", "-      }", "-      sd.setInterface(false);", "-    ", "-    else throw new RuntimeException(\"Internal Program Error: typeDefBase was not a ClassDef or InterfaceDef.\" + ", "-                                     \"  Please report this bug.\");", "-    ", "-    // get the SymbolData of the superclass which must be in the symbol table", "-    // since we visited the type in forClassDef() although it may be a continuation. ", "-    ", "-    // there is a continuation in the symbol table, update the fields", "-    sd.setMav(typeDefBase.getMav());", "-    sd.setTypeParameters(typeDefBase.getTypeParameters());", "-    sd.setSuperClass(superClass);", "-    sd.setInterfaces(interfaces);", "-    sd.setIsContinuation(false);", "-    _log.log(\"REMOVING continuation \" + sd.getName());", "-    continuations.remove(sd.getName());", "-    if (! sd.isInterface()) { LanguageLevelConverter._newSDs.put(sd, this); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "711fe998281a411274c9a8a904b59d7b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "093f33e43dd3de7d97364f410a0a58ca1448a1ce", "commitAfterChange": "51703b3c111cc35e01e35a5e289226f6da1c1962", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 43, "signatureBeforeChange": "   protected SymbolData addInnerSymbolData(TypeDefBase typeDefBase,                                            String qualifiedTypeName,                                            String partialName,                                            Data enclosing,                                            boolean isClass)", "signatureAfterChange": "   protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String qualifiedTypeName, Data enclosing)", "diff": ["-    */", "-  protected SymbolData addInnerSymbolData(TypeDefBase typeDefBase, ", "-                                          String qualifiedTypeName, ", "-                                          String partialName, ", "-                                          Data enclosing, ", "-                                          boolean isClass) {", "-    //try to look up in symbol table, in case it has already been defined", "-    SymbolData sd = symbolTable.get(qualifiedTypeName);", "-    ", "-    //try to look up in enclosing's list of inner classes", "-    if (sd == null) { sd = enclosing.getInnerClassOrInterface(partialName); }", "-    ", "-    if (sd != null && !sd.isContinuation()) {", "-//      Utilities.show(\"This class has already been defined sd = \" + sd);", "-      _addAndIgnoreError(\"This class has already been defined.\", typeDefBase);", "-//      throw new RuntimeException(\"ALREADY DEFINED CLASS ERROR; THROWING EXCEPTION\");", "-      return null;", "-    }", "-    ", "-    if (sd != null) {", "-      //make sure it is a direct inner class or interface of this data.", "-      if (sd.getOuterData() != enclosing) { sd = null; }", "-    }", "-    ", "-    // create a new symbolData for it--this is the first time we've seen it", "-    if (sd == null) { ", "-      sd = new SymbolData(qualifiedTypeName);", "-      sd.setOuterData(enclosing);", "-      if (isClass) { enclosing.getSymbolData().addInnerClass(sd); }", "-      else { enclosing.getSymbolData().addInnerInterface(sd); }", "-    }", "-    ", "-    // create the LinkedList for the SymbolDatas of the interfaces", "-    LinkedList<SymbolData> interfaces = new LinkedList<SymbolData>();", "-    SymbolData tempSd;", "-    ReferenceType[] rts = typeDefBase.getInterfaces();", "-    for (int i = 0; i < rts.length; i++) {", "-      SourceInfo si = rts[i].getSourceInfo();", "-      String tempName = rts[i].getName();", "-      tempSd = getSymbolData(tempName, si, false, false, false);", "-      ", "-      if (tempSd != null) { interfaces.addLast(tempSd); }", "-      ", "-      else if (enclosing instanceof SymbolData) {", "-        // Check to see if this is an inner class referencing an inner interface", "-        tempSd = enclosing.getInnerClassOrInterface(tempName);", "-        if (tempSd == null) {", "-          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "-          String qualifiedTempName = qualifyingPart + \".\" + tempName;", "-          // Should we introduce addInnerInterfaceSymbol ?", "-          tempSd = new SymbolData(qualifiedTempName);", "-          tempSd.setInterface(true);", "-          enclosing.getSymbolData().addInnerInterface(tempSd); //interfaces can only be defined in symbol datas", "-          tempSd.setOuterData(enclosing);", "-//          System.err.println(\"Creating inner interface continuation for \" + qualifiedTempName + \" at LLV: 1042\");", "-          continuations.put(qualifiedTempName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));          ", "-        }", "-        interfaces.addLast(tempSd);", "-      }", "-      ", "-      else {", "-        _addAndIgnoreError(\"Cannot resolve interface \" + rts[i].getName(), rts[i]);", "-        return null;", "-      }", "-    }", "-    ", "-    //Set the package to be the current package", "-    sd.setPackage(_package);", "-    ", "-    SymbolData superClass = null;", "-    ", "-    if (typeDefBase instanceof InterfaceDef) {", "-      //add Object as the super class of this, so that it will know it implements Object's methods.", "-      superClass = getSymbolData(\"Object\", typeDefBase.getSourceInfo(), false);", "-      sd.setInterface(true);", "-    }", "-    ", "-    else if (typeDefBase instanceof ClassDef) {", "-      ClassDef cd = (ClassDef) typeDefBase;", "-      ReferenceType rt = cd.getSuperclass();", "-      String superClassName = rt.getName();", "-      superClass = getSymbolData(superClassName, rt.getSourceInfo(), false, false, false);", "-      ", "-      if (superClass == null) {", "-        superClass = enclosing.getInnerClassOrInterface(superClassName);", "-        if (superClass == null) {", "-          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "-          superClass = new SymbolData(qualifyingPart + \".\" + superClassName);", "-          enclosing.addInnerClass(superClass);", "-          superClass.setOuterData(enclosing);", "-//          System.err.println(\"Creating continuation for \" + superClassName + \" at LLV:1079\");", "-          continuations.put(superClassName, new Pair<SourceInfo, LanguageLevelVisitor>(rt.getSourceInfo(), this)); ", "-        }", "-      }", "-      sd.setInterface(false);", "-    }", "-    ", "-    else {throw new RuntimeException(\"Internal Program Error: typeDefBase was not a ClassDef or InterfaceDef.\" + ", "-                                     \"  Please report this bug.\");}", "-    ", "-    // get the SymbolData of the superclass which must be in the symbol table", "-    // since we visited the type in forClassDef() although it may be a continuation. ", "-    ", "-    // there is a continuation in the symbol table, update the fields", "-    sd.setMav(typeDefBase.getMav());", "-    sd.setTypeParameters(typeDefBase.getTypeParameters());", "-    sd.setSuperClass(superClass);", "-    sd.setInterfaces(interfaces);", "-    sd.setIsContinuation(false);", "-    continuations.remove(sd.getName());", "-    if (sd != null && !sd.isInterface()) {_newSDs.put(sd, this); }", "-    return sd;", "-  }", "+    */", "+  protected SymbolData defineInnerSymbolData(TypeDefBase typeDefBase, String qualifiedTypeName, Data enclosing) { ", "+        /* IMPORTANT: this is defineSymbol for inner classes! */", "+    String name = qualifiedTypeName;  // may be an interface", "+    SymbolData sd = symbolTable.get(name);", "+    if (sd != null && ! sd.isContinuation()) {", "+      _addAndIgnoreError(\"The class or interface \" + name + \" has already been defined.\", typeDefBase);", "+      return null;", "+    }", "+    ", "+    // create the LinkedList for the SymbolDatas of the interfaces", "+    LinkedList<SymbolData> interfaces = new LinkedList<SymbolData>();", "+    SymbolData tempSd;", "+    ReferenceType[] rts = typeDefBase.getInterfaces();", "+    for (int i = 0; i < rts.length; i++) {", "+      SourceInfo si = rts[i].getSourceInfo();", "+      String tempName = rts[i].getName();", "+      tempSd = getSymbolData(tempName, si, false, false, false);", "+      ", "+      if (tempSd != null) { interfaces.addLast(tempSd); }", "+      ", "+      else if (enclosing instanceof SymbolData) {", "+        // Check to see if this is an inner class referencing an inner interface", "+        tempSd = enclosing.getInnerClassOrInterface(tempName);", "+        if (tempSd == null) {", "+          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "+          String qualifiedTempName = qualifyingPart + \".\" + tempName;", "+          // Should we introduce addInnerInterfaceSymbol ?", "+          tempSd = new SymbolData(qualifiedTempName);", "+          tempSd.setInterface(true);", "+          enclosing.getSymbolData().addInnerInterface(tempSd); //interfaces can only be defined in symbol datas", "+          tempSd.setOuterData(enclosing);", "+//          System.err.println(\"Creating inner interface continuation for \" + qualifiedTempName + \" at LLV: 1042\");", "+          continuations.put(qualifiedTempName, new Pair<SourceInfo, LanguageLevelVisitor>(si, this));          ", "+        }", "+        interfaces.addLast(tempSd);", "+      }", "+      ", "+      else {", "+        _addAndIgnoreError(\"Cannot resolve interface \" + rts[i].getName(), rts[i]);", "+        return null;", "+      }", "+    }", "+        ", "+    // create a new symbolData for this inner class or interface if not seen before", "+    if (sd == null) { ", "+      sd = new SymbolData(qualifiedTypeName);", "+      sd.setOuterData(enclosing);", "+      if (typeDefBase instanceof ClassDef) { enclosing.getSymbolData().addInnerClass(sd); }", "+      else { ", "+        enclosing.getSymbolData().addInnerInterface(sd); ", "+      }", "+    }", "+    //Set the package to be the current package", "+    sd.setPackage(_package);", "+    ", "+    SymbolData superClass = null;", "+    ", "+    if (typeDefBase instanceof InterfaceDef) {", "+      // Add Object as the super class of this, so that it will know it implements Object's methods.", "+      superClass = getSymbolData(\"Object\", typeDefBase.getSourceInfo(), false);", "+      sd.setInterface(true);", "+    }", "+    else if (typeDefBase instanceof ClassDef) {", "+      ClassDef cd = (ClassDef) typeDefBase;", "+      ReferenceType rt = cd.getSuperclass();", "+      String superClassName = rt.getName();", "+      superClass = getSymbolData(superClassName, rt.getSourceInfo(), false, false, false);", "+      ", "+      if (superClass == null) {  // Why is this necessary?  Forward reference to another inner class?", "+        superClass = enclosing.getInnerClassOrInterface(superClassName);", "+        if (superClass == null) {", "+          String qualifyingPart = qualifiedTypeName.substring(0, qualifiedTypeName.lastIndexOf(\".\"));", "+          superClass = new SymbolData(qualifyingPart + \".\" + superClassName);", "+          enclosing.addInnerClass(superClass);", "+          superClass.setOuterData(enclosing);", "+//          System.err.println(\"Creating continuation for \" + superClassName + \" at LLV:1079\");", "+          continuations.put(superClassName, new Pair<SourceInfo, LanguageLevelVisitor>(rt.getSourceInfo(), this)); ", "+        }", "+    if (! sd.isInterface()) { LanguageLevelConverter._newSDs.put(sd, this); }"]}], "num": 22628}