{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2e0824d90683759a8822a276b3d4629b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1079cc2d085d33336baa41869b389cc5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocument.java", "commitBeforeChange": "8cfaf2efb8ae59b79b9538e0bd5eaf251c6db08b", "commitAfterChange": "b732820bc2f8849bda78001b782e555a753cad1e", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 41, "signatureBeforeChange": "   public String getPackageName() throws InvalidPackageException", "signatureAfterChange": "   public String getPackageName() throws InvalidPackageException", "diff": ["-    // throwErrorHuh();", "-    // Where we'll build up the package name we find", "+    /* Buffer for constructing the package name. */", "+      final int docLength = text.length();", "+      if (docLength == 0) return \"\";", "+      ", "-        int firstNormalLocation;", "-        ", "-        setCurrentLocation(0);", "-        ", "-        final int docLength = text.length();", "-        // The location of the first non-whitespace character that is not inside a string or comment.", "-        firstNormalLocation = 0;", "-        while (firstNormalLocation < docLength) {", "-          setCurrentLocation(firstNormalLocation);", "+        try {", "+          setCurrentLocation(0);", "-          if (_reduced.currentToken().getHighlightState() == HighlightStatus.NORMAL) {", "-            // OK, it's normal -- so if it's not whitespace, we found the spot", "-            char curChar = text.charAt(firstNormalLocation);", "-            if (! Character.isWhitespace(curChar)) break;", "+          /* The location of the first non-whitespace character that is not inside a string or comment. */", "+          int firstNormalLocation = 0;", "+          while (firstNormalLocation < docLength) {", "+            setCurrentLocation(firstNormalLocation);", "+            ", "+            if (_reduced.currentToken().getHighlightState() == HighlightStatus.NORMAL) {", "+              // OK, it's normal -- so if it's not whitespace, we found the spot", "+              char curChar = text.charAt(firstNormalLocation);", "+              if (! Character.isWhitespace(curChar)) break;", "+            }", "+            firstNormalLocation++;", "-          firstNormalLocation++;", "-        }", "-        ", "-        // Now there are two possibilities: firstNormalLocation is at", "-        // the first spot of a non-whitespace character that's NORMAL,", "-        // or it's at the end of the document.", "-        if (firstNormalLocation == docLength) return \"\";", "-        ", "-        final int strlen = \"package\".length();", "-        ", "-        final int endLocation = firstNormalLocation + strlen;", "-        ", "-        if ((firstNormalLocation + strlen > docLength) ||", "-            ! text.substring(firstNormalLocation, endLocation).equals(\"package\")) {", "-          // The first normal text is not \"package\" or there is not enough text for there to be a package statement.", "-          // Thus, there is no valid package statement.", "-          return \"\";", "-        }", "-        ", "-        // OK, we must have found a package statement.", "-        // Now let's find the semicolon. Again, the semicolon must be free.", "-        int afterPackage = firstNormalLocation + strlen;", "-        ", "-        int semicolonLocation = afterPackage;", "-        do {", "-          semicolonLocation = text.indexOf(\";\", semicolonLocation + 1);", "-          if (semicolonLocation == -1)", "+          // Now there are two possibilities: firstNormalLocation is at the first spot of a non-whitespace character ", "+          // that's NORMAL, or it's at the end of the document.", "+          ", "+          if (firstNormalLocation == docLength) return \"\";", "+          ", "+          final int strlen = \"package\".length();", "+          ", "+          final int endLocation = firstNormalLocation + strlen;", "+          ", "+          if ((firstNormalLocation + strlen > docLength) ||", "+              ! text.substring(firstNormalLocation, endLocation).equals(\"package\")) {", "+            // The first normal text is not \"package\" or there is not enough text for there to be a package statement.", "+            // Thus, there is no valid package statement.", "+            return \"\";", "+          }", "+          ", "+          // OK, we must have found a package statement.", "+          // Now let's find the semicolon. Again, the semicolon must be free.", "+          int afterPackage = firstNormalLocation + strlen;", "+          ", "+          int semicolonLocation = afterPackage;", "+          do {", "+            semicolonLocation = text.indexOf(\";\", semicolonLocation + 1);", "+            if (semicolonLocation == -1)", "+              throw new InvalidPackageException(firstNormalLocation,", "+                                                \"No semicolon found to terminate package statement!\");", "+            setCurrentLocation(semicolonLocation);", "+          }", "+          while (_reduced.currentToken().getHighlightState() != HighlightStatus.NORMAL);", "+          ", "+          // Now we have semicolon location. We'll gather text in between one character at a time for simplicity. ", "+          for (int walk = afterPackage + 1; walk < semicolonLocation; walk++) {", "+            setCurrentLocation(walk);", "+            if (_reduced.currentToken().getHighlightState() == HighlightStatus.NORMAL) {", "+              char curChar = text.charAt(walk);", "+              if (! Character.isWhitespace(curChar)) buf.append(curChar);", "+            }", "+          }", "+          ", "+          String toReturn = buf.toString();", "+          if (toReturn.equals(\"\"))", "-                                              \"No semicolon found to terminate package statement!\");", "-          setCurrentLocation(semicolonLocation);", "+                                              \"Package name was not specified after the package keyword!\");", "+          return toReturn;", "-        while (_reduced.currentToken().getHighlightState() != HighlightStatus.NORMAL);", "-        ", "-        // Now we have semicolon location. We'll gather text in between one", "-        // character at a time for simplicity. It's inefficient (I think?)", "-        // but it's easy, and there shouldn't be much text between", "-        // \"package\" and \";\" anyhow.", "-        for (int walk = afterPackage + 1; walk < semicolonLocation; walk++) {", "-          setCurrentLocation(walk);", "-          ", "-          if (_reduced.currentToken().getHighlightState() == HighlightStatus.NORMAL) {", "-            char curChar = text.charAt(walk);", "-            if (! Character.isWhitespace(curChar)) buf.append(curChar);", "-          }", "+        finally { // reset oldLocation", "+          setCurrentLocation(0);  // Why?", "+          setCurrentLocation(oldLocation);", "-        ", "-        String toReturn = buf.toString();", "-        if (toReturn.equals(\"\"))", "-          throw new InvalidPackageException(firstNormalLocation,", "-                                            \"Package name was not specified after the package keyword!\");", "-        return toReturn;", "-    finally {", "-      setCurrentLocation(0);  // Why?", "-      setCurrentLocation(oldLocation);", "-      readUnlock();", "-    }", "+    finally { readUnlock(); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc2d26cff55229c85af3e1df5cad1fa1", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/EvaluationVisitorTest.java", "commitBeforeChange": "0b6da37c0a798afe2afb46cf4cce8524728787cf", "commitAfterChange": "1488cfa1471a9b7ff0b87e0f4602a34d07f0dde9", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": "   public void testVarArgsWithMethodInvocation() throws InterpreterException", "signatureAfterChange": "   public void testVarArgsWithMethodInvocation() throws InterpreterException", "diff": ["+    ", "-    text = \"Arrays.asList(1,2,3,4)\";", "-    res = interpret(text);", "-    assertTrue(\"res should be an instance of a List\", res instanceof java.util.List);", "-    assertEquals(\"size should be 4\", 4, ((java.util.List)res).size());", "-    assertEquals(\"last element should be 4\", new Integer(4), ((java.util.List)res).get(3));", "+    /**/", "+    /* INSERTED FOR NOW, WANNA CHECK WITH CORKY */", "+    ", "+    if(Float.parseFloat(System.getProperty(\"java.specification.version\"))>=1.5){    ", "+      text = \"Arrays.asList(1,2,3,4)\";", "+      res = interpret(text);", "+      assertTrue(\"res should be an instance of a List\", res instanceof java.util.List);", "+      assertEquals(\"size should be 4\", 4, ((java.util.List)res).size());", "+      assertEquals(\"last element should be 4\", new Integer(4), ((java.util.List)res).get(3));", "-        ", "+", "-    ", "+    }        "]}], "num": 26308}