{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2d5df290ffa77f8129f080645aa78b9a", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6daffeba4bffd5e5cf95a04c90b138ab", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/SymbolData.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 40, "signatureBeforeChange": "    public boolean isCastableTo(SymbolData castTo, JavaVersion version)", "signatureAfterChange": "    public boolean isCastableTo(SymbolData castTo, JavaVersion version)", "diff": ["-         if (LanguageLevelConverter.versionSupportsAutoboxing(version)) { //You never box the left, so see if this can be unboxed to be a primitive.", "+         if (LanguageLevelConverter.versionSupportsAutoboxing(version)) { ", "+           //You never box the left, so see if this can be unboxed to be a primitive.", "-       else { //this is an interface", "+       else { // this is an interface", "-         else { //castTo is an interface", "-           //return false if this and castTo contain one or more methods with the same signature but different return types.", "-           if (LanguageLevelConverter.versionSupportsAutoboxing(version)) {return true;} //this check is no longer done in 1.5", "+         else { // castTo is an interface", "+           // return false if this and castTo contain methods with the same signature but different return types.", "+           if (LanguageLevelConverter.versionSupportsAutoboxing(version)) return true; ", "-               //TypeChecker._addError(\"Types \" + this.getName() + \" and \" + castTo.getName() + \" are incompatible.  Both implement \" + md.getName() + \" but have different return types\", md.getSourceInfo());", "+               /* TypeChecker._addError(\"Types \" + this.getName() + \" and \" + castTo.getName() + \" are incompatible.  ", "+                  Both implement \" + md.getName() + \" but have different return types\", md.getSourceInfo()); */"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ab072dc74edb1f2ce0064e9ebc663f3a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "c68bda7492524887225ee8f4963e9d7935485197", "commitAfterChange": "7e14052430c5a0fbe8641ad3a0f464f6b201c49d", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 23, "signatureBeforeChange": "   protected SymbolData getSymbolDataForClassFile(String className, SourceInfo si)", "signatureAfterChange": "   protected SymbolData getSymbolDataForClassFile(String className, SourceInfo si)", "diff": ["-      // This should typically never happen.  However, I am getting a case where bcel finds that", "-      // java.net.URL has a method called openConnection which takes in a java.net.Proxy.", "-      // This method and class Proxy don't appear in any API I can find.  This causes a NoClassDefFoundError.", "-      // For now, the offending method will be skipped if it came from a java class file but an error will", "-      // be thrown otherwise since a user may have deleted a class file and should be notified.      ", "-      // We know that className is already qualified because it's coming from a class file.", "-      // Adding sun.* because we can't find sun.reflect.ConstantPool for some reason 3.28.2004 JH", "-      if (isJavaLibraryClass(className)) {", "-        // don't throw an error", "-      }", "-      else {", "-        // This is an error in the user's class file so throw an error.", "-        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-        _addAndIgnoreError(\"Class \" + className + \" not found.\", new NullLiteral(si));", "-      }", "-      // return null to tell _classFile2SymbolData to skip this method.", "+      // This is an error in the user's class file so throw an error.", "+      // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "+      _addAndIgnoreError(\"Class \" + className + \" not found.\", new NullLiteral(si));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b87fcba87f2a3c1855861aeca3ca1da6", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocument.java", "commitBeforeChange": "8a099b753fcfb83be248d39f70edd5788e8b1222", "commitAfterChange": "4701dc92d8eb3da9b7f829b98cf858de261361f6", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "   public void insertString(int offset, String str, AttributeSet a)     throws BadLocationException", "signatureAfterChange": "   public void insertString(int offset, String str, AttributeSet a)     throws BadLocationException", "diff": ["-    throws BadLocationException {", "-      // If _removeTabs is set to true, remove all tabs from str.", "-      // It is a current invariant of the tabification`functionality that", "-      // the document contains no tabs, but we want to allow the user", "-      // to override this functionality.", "-      if (_tabsRemoved) {", "-        str = _removeTabs(str);", "-      }", "-", "-      int locationChange = offset - _currentLocation;", "-      int strLength = str.length();", "-      int prevSize;     //stores the size of the item prev when insert begins.", "-      int reducedOffset;", "-      // adjust location", "-      _reduced.move(locationChange);", "-      // loop over string, inserting characters into reduced model", "-      for (int i = 0; i < str.length(); i++) {", "-        char curChar = str.charAt(i);", "-        _addCharToReducedModel(curChar);", "-      }", "-      _currentLocation = offset + strLength;", "-      super.insertString(offset, str, a);", "-      _modifiedSinceSave = true;", "-      _styleChanged();", "+    throws BadLocationException", "+  {", "+    // If _removeTabs is set to true, remove all tabs from str.", "+    // It is a current invariant of the tabification functionality that", "+    // the document contains no tabs, but we want to allow the user", "+    // to override this functionality.", "+    if (_tabsRemoved) {", "+      str = _removeTabs(str);", "+", "+    _modifiedSinceSave = true;", "+", "+    super.insertString(offset, str, a);", "+  }"]}], "num": 2716}