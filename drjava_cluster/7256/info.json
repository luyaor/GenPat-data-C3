{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "52830c8155cfddebdda7d5bfbfbcc346", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0358a6c19a02d4fc2dceb89c8f8e35ea", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/AbstractConsoleController.java", "commitBeforeChange": "92062677ca813cb9ab44428a0d2d54f0c3309b04", "commitAfterChange": "274f7defc49003e66c942e814c9ce22958b3814c", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "     public void insertUpdate(final DocumentEvent e)", "signatureAfterChange": "     public void insertUpdate(final DocumentEvent e)", "diff": ["-      // Queue an asynchronous task in the event thread to update the document pane; Use SwingUtilities to ensure that", "-      // the caret update is performed after the document update listeners have run.  Fixes (?) bug #1571405.", "-      SwingUtilities.invokeLater(new Runnable() { ", "-        public void run() {", "+      // Update caret position when text is inserted in document.  Fixes (?) bug #1571405.", "-          doc.acquireReadLock(); // Grab read lock because this code is NOT run as part of document listener!", "-          try {", "-            int caretPos = _pane.getCaretPosition();", "-            int promptPos = doc.getPromptPos();", "-            int len = doc.getLength();", "+          int pos;", "+          final int docLen = doc.getLength();", "+          // if document has no prompt, place caret at end", "+          if (! doc.hasPrompt()) pos = docLen;", "+          else {", "-//          System.err.println(\"insertUpdate called; caretPos = \" + caretPos + \" docLength = \" + length);", "-            ", "-            // Figure out where the prompt was before the update", "-            int prevPromptPos = promptPos;", "-            if (e.getOffset() < promptPos) {", "-              // Insert happened before prompt,", "-              //  so previous position was further back", "-              prevPromptPos = promptPos - e.getLength();", "+            final int caretPos = _pane.getCaretPosition();", "+            final int promptPos = doc.getPromptPos();", "+            final int insertPos = e.getOffset();", "+            final int insertLen = e.getLength();", "+            final int prevPromptPos = (insertPos < promptPos) ? promptPos - insertLen : promptPos;", "+            // Figure out where the prompt was before the insertion", "+", "+          ", "+            if (caretPos < prevPromptPos /* || insertPos < promptPos */) {", "+              // Caret was behind prompt before insertion or insertion preceded the prompt  (why check for former?)", "+              pos = promptPos;  // place caret at prompt", "-            ", "-            if (! doc.hasPrompt()) {", "-//            System.err.println(\"Scrolling to end of document\");", "-              // Scroll to the end of the document, since output has been inserted after the prompt.", "-              moveToEnd();", "-            }", "-            // Do not to move caret during a reset, when the prompt pos is temporarily far greater than the length.", "-            else if (promptPos <= len) {", "-              if (caretPos < prevPromptPos) {", "-                // Caret has fallen behind prompt, so make it catch up so", "-                //  the new input is visible.", "-                moveToPrompt();", "-              }", "-              else {", "-                // Caret was on or after prompt, so move it right by the size", "-                //  of the insert.", "-                int size = promptPos - prevPromptPos;", "-                if (size > 0) {", "-                  int newCaretPos = caretPos + size;", "-                  if (newCaretPos > len) newCaretPos = len;", "-                  _pane.setCaretPosition(newCaretPos);", "-                }", "-              }", "+            else {", "+              // Caret and insertion were on or after prompt", "+              pos = Math.min(caretPos + insertLen, docLen);  // advance cursor by insertion size (but within document)", "-          finally { doc.releaseReadLock(); }", "-        }", "-      });", "+", "+          final int newPos = pos;  // make a final copy of pos that can appear in a closure", "+          if (EventQueue.isDispatchThread()) _pane.setCaretPosition(newPos);", "+          else EventQueue.invokeLater(new Runnable() { public void run() { ", "+//            System.err.println(\"Deferred setting caretPos to \" + newPos);", "+            _pane.setCaretPos(newPos); ", "+          } });", "+            ", "+//          System.err.println(\"insertUpdate called; caretPos = \" + caretPos + \" docLength = \" + length);", "+          ", "+          /* Old Code: */", "+//      // Queue an asynchronous task in the event thread to update the document pane; Use SwingUtilities to ensure that", "+//      // the caret update is performed after the document update listeners have run.  Fixes (?) bug #1571405.", "+//      SwingUtilities.invokeLater(new Runnable() { ", "+//        public void run() {", "+//          ", "+//          ConsoleDocument doc = getConsoleDoc();", "+//          doc.acquireReadLock(); // Grab read lock because this code is NOT run as part of document listener!", "+//          try {", "+//            int caretPos = _pane.getCaretPosition();", "+//            int promptPos = doc.getPromptPos();", "+//            int len = doc.getLength();", "+//            ", "+////          System.err.println(\"insertUpdate called; caretPos = \" + caretPos + \" docLength = \" + length);", "+//            ", "+//            // Figure out where the prompt was before the update", "+//            int prevPromptPos = promptPos;", "+//            if (e.getOffset() < promptPos) {", "+//              // Insert happened before prompt,", "+//              //  so previous position was further back", "+//              prevPromptPos = promptPos - e.getLength();", "+//            }", "+//            ", "+//            if (! doc.hasPrompt()) {", "+////            System.err.println(\"Scrolling to end of document\");", "+//              // Scroll to the end of the document, since output has been inserted after the prompt.", "+//              moveToEnd();", "+//            }", "+//            // Do not to move caret during a reset, when the prompt pos is temporarily far greater than the length.", "+//            else if (promptPos <= len) {", "+//              if (caretPos < prevPromptPos) {", "+//                // Caret has fallen behind prompt, so make it catch up so", "+//                //  the new input is visible.", "+//                moveToPrompt();", "+//              }", "+//              else {", "+//                // Caret was on or after prompt, so move it right by the size", "+//                //  of the insert.", "+//                int size = promptPos - prevPromptPos;", "+//                if (size > 0) {", "+//                  int newCaretPos = caretPos + size;", "+//                  if (newCaretPos > len) newCaretPos = len;", "+//                  _pane.setCaretPosition(newCaretPos);", "+//                }", "+//              }", "+//            }", "+//          }", "+//          finally { doc.releaseReadLock(); }", "+//        }", "+//      });"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d38e4c291984bc8cddc59c7e92d8d361", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/swing/FindReplaceMachine.java", "commitBeforeChange": "20a2512e394be5865ddd8dc1ebd648c5dfb08d0c", "commitAfterChange": "832e5dfbee9301c0432d02f86eab2d13af7f51bc", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 23, "signatureBeforeChange": "   public int replaceAll()", "signatureAfterChange": "   public int replaceAll()", "diff": ["+    if (_searchAllDocuments) {", "+      Document startDoc = _doc;", "+      _searchAllDocuments = false;", "+      int count = _replaceAllInCurrentDoc();", "+      _doc = _docIterator.getNextDocument(_doc);", "+      while (startDoc != _doc) {", "+        count += _replaceAllInCurrentDoc();", "+        _doc = _docIterator.getNextDocument(_doc);", "+      }", "+      _searchAllDocuments = true;", "+      return count;", "+    }", "+    else {", "+      return _replaceAllInCurrentDoc();", "+    }", "+  }", "-    } catch (BadLocationException e) {", "-//    int found = fr.getFoundOffset();", "-    int wrapped = 0;", "-    if (fr.getWrapped())", "-      wrapped++;", "-    while(wrapped == 0) {", "-//      found = fr.getFoundOffset();", "-      if (fr.getWrapped())", "-        wrapped++;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fbf2f635c160fb95a89201a1b19a6914", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/StatementEvaluator.java", "commitBeforeChange": "15e62c4c6cc17bdc9cb202b4c5c58df163a8f8cf", "commitAfterChange": "6b388fb1877469cd91350296fabdf9fe8d522b74", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "    @Override public Result visit(WhileStatement node)", "signatureAfterChange": "      @Override public Result visit(ExpressionStatement node)", "diff": ["+  ", "+  @Override public Result visit(ExpressionStatement node) {", "+    if (hasStatementTranslation(node)) {", "+      return getStatementTranslation(node).acceptVisitor(this);", "+    }", "+    else {", "+      Object val = new ExpressionEvaluator(_bindings, _opt).value(node.getExpression());", "+      if (node.getHasSemicolon() || getType(node.getExpression()).equals(TypeSystem.VOID)) {", "+        return new Result(_bindings);", "+      }", "+      else { return new Result(val, _bindings); }", "+    }", "+  }"]}], "num": 7256}