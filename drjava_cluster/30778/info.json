{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cfbdf61d95d35e7e8a54fc6aac0cddaa", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "75ec7df91b87316e776565c942190c73", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/BreakpointsPanel.java", "commitBeforeChange": "f31b25b6bce1143f413461b3f80cdf7629bea1c5", "commitAfterChange": "733b3cf4d974c1c6ea9506fe8718b272fd7a917d", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "   protected void enableDisableBreakpoint()", "signatureAfterChange": "   protected void enableDisableBreakpoint()", "diff": ["-      r.setEnabled(!(r.isEnabled()));", "-      updateButtons();", "+      _model.getBreakpointManager().changeRegion(r, new Lambda<Object, Breakpoint>() {", "+        public Object apply(Breakpoint bp) {", "+          bp.setEnabled(!bp.isEnabled());", "+          return null;", "+        }", "+      });"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "84e8fe7e07c596bb2e0a4111fd85a231", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/junit/DrJavaTestCaseClassLoader.java", "commitBeforeChange": "771a0aee635c62bc6d0a2000fe605dc1113ef2b9", "commitAfterChange": "d1e56ac5c281c4b03c498f59138895f0f26350fa", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  private void readExcludedPackages()", "signatureAfterChange": "   private void readExcludedPackages()", "diff": ["-  */", "- private void readExcludedPackages() {  ", "-  fExcluded= new Vector<String>(10);", "-  for (int i= 0; i < defaultExclusions.length; i++)", "-   fExcluded.addElement(defaultExclusions[i]);", "-   ", "-  InputStream is= getClass().getResourceAsStream(EXCLUDED_FILE);", "-  if (is == null) ", "-   return;", "-  Properties p= new Properties();", "-  try {", "-   p.load(is);", "-  catch (IOException e) {", "-   return;", "-  } finally {", "-   try {", "-    is.close();", "-   } catch (IOException e) {", "-   }", "-  for (Enumeration e= p.propertyNames(); e.hasMoreElements(); ) {", "-   String key= (String)e.nextElement();", "-   if (key.startsWith(\"excluded.\")) {", "-    String path= p.getProperty(key);", "-    path= path.trim();", "-    if (path.endsWith(\"*\"))", "-     path= path.substring(0, path.length()-1);", "-    if (path.length() > 0) ", "-     fExcluded.addElement(path);    ", "-   }", "- }", "+   */", "+  private void readExcludedPackages() {  ", "+    fExcluded = new Vector<String>(10);", "+    for (String de: defaultExclusions) fExcluded.addElement(de);", "+    ", "+    InputStream is = getClass().getResourceAsStream(EXCLUDED_FILE);", "+    if (is == null) return;", "+    Properties p = new Properties();", "+    try { p.load(is); }", "+    catch (IOException e) { return; } ", "+    finally {", "+      try { is.close(); } ", "+      catch (IOException e) {", "+        /* do nothing */", "+      }", "+    }", "+    Enumeration<String> pnames = (Enumeration<String>) p.propertyNames();", "+    while (pnames.hasMoreElements()) {", "+      String key = pnames.nextElement();", "+      if (key.startsWith(\"excluded.\")) {", "+        String path = p.getProperty(key);", "+        path = path.trim();", "+        if (path.endsWith(\"*\")) path= path.substring(0, path.length()-1);", "+        if (path.length() > 0) fExcluded.addElement(path);    ", "+      }", "+    }", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c06ba5a10ef6fb964d0b47e0f974e88f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "5e7a16013fcb5945eddc036e2d2d0ce3e14ba2d0", "commitAfterChange": "e1389ddb9dcb8a7d3a230cc1be322481e1c8fd6a", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "diff": ["+    //  WHAT IS THE FOLLOWING STATIC FIELD REFERNCE DOING HERE?  THIS IS ABOMINABLE CODE!", "-    //and the newSDs we've created", "+    //and the new SDs (symbol table entries) we've created", "-    // We are doing two passes on the files, and the second pass needs the first's corresponding", "-    // SourceFile and ElementaryVisitor so we'll keep them around in a Hashtable.", "+    /* We are doing two passes on the files, and the second pass needs the first's corresponding", "+       SourceFile and LanguageLevelVisitor so we'll keep them around in a Hashtable. */", "-    // The visitedFiles returned by any pass may include another file which is already scheduled for compilation.", "-    // In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "-    // already been done.  (An error is thrown if we do since it thinks the class has already been defined).", "+    /* The visitedFiles returned by any pass may include another file which is already scheduled for compilation.", "+       In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "+       already been done.  (An error is thrown if we do since it thinks the class has already been defined). */", "+    // WHAT visitedFiles are RETURNED?  HOW?  The return type is a Pair containing NO files!  I SMELL GLOBAL VARIABLES!", "-    // The number of files to compile may change if one file references another one.", "-    // We don't want to visit these newly referenced files because they've already", "-    // been visited.", "+    /* The number of files to compile may change if one file references another one.", "+       We don't want to visit these newly referenced files because they've already", "+       been visited. */", "+    // WHAT DOES VISIT MEAN?", "-    // Find the ones (of what?) that are LL files.", "-    // Do the passes first for ALL files before proceeding to code augmentation.", "-    // Otherwise if one class' superclass get augmented first, then it sees a lot", "-    // of illegal constructs (e.g. public and constructors).", "+    /* Find the ones (of what?) that are LL files.", "+       Do the passes first for ALL files before proceeding to code augmentation.", "+       Otherwise if one class' superclass get augmented first, then it sees a lot", "+       of illegal constructs (e.g. public and constructors). */", "-    //will maintain the files we visit along with their visitors (for type checking step).", "+    /* will maintain the files we visit along with their visitors (for type checking step). */", "-    ", "-    for (int ind = 0; ind < originalNumOfFiles; ind++) {", "-      File f = files[ind];", "+    for (File f : files) {", "-              t.visit(new JExpressionIFAbstractVisitor_void() {", "-                public void forClassDef(ClassDef that) { topLevelClasses.add(that.getName().getText()); }", "+              t.visit(new JExpressionIFAbstractVisitor<Void>() {", "+                public Void forClassDef(ClassDef that) { topLevelClasses.add(that.getName().getText()); return null; }", "+                public Void defaultCase(JExpressionIF that) { return null; }", "-    //Resolve continuations and create constructors.  Also accumulate errors.", "+    // Resolve continuations and create constructors.  Also accumulate errors."]}], "num": 30778}