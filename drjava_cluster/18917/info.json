{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "eaf5275657653ab6633a4b0f419ee9ff", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "59cdba55172d2cd2675cf66268dcedac", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/jpda/JPDADebugger.java", "commitBeforeChange": "5293cb4cfbc2f45d6061ba4101ad60348aa251ed", "commitAfterChange": "f68f43e5a680bb235f87f6125c6c0de6d15a12f4", "methodNumberBeforeChange": 78, "methodNumberAfterChange": 74, "signatureBeforeChange": "   private void _defineVariable(ThreadReference suspendedThreadRef,                                ObjectReference debugInterpreter,                                String name, Value val, Type type)     throws InvalidTypeException, IncompatibleThreadStateException,       ClassNotLoadedException, InvocationException, DebugException", "signatureAfterChange": "   private ReferenceType _getClass(String name) throws DebugException", "diff": ["-   */", "-  private void _defineVariable(ThreadReference suspendedThreadRef,", "-                               ObjectReference debugInterpreter,", "-                               String name, Value val, Type type)", "-    throws InvalidTypeException, IncompatibleThreadStateException,", "-      ClassNotLoadedException, InvocationException, DebugException", "-  {", "-    ReferenceType rtDebugInterpreter = debugInterpreter.referenceType();", "-    Method method2Call = _getDefineVariableMethod(rtDebugInterpreter,  val);", "-", "-    // invokeMethod would throw an ObjectCollectedException if the StringReference", "-    // declared by _vm.mirrorOf(name) had been garbage collected before", "-    // invokeMethod could execute. We now just disable collection until after the", "-    // method is invoked.", "-", "-    int tries = 0;", "-    StringReference sr = null;", "-    while (tries < OBJECT_COLLECTED_TRIES) {", "-        //Added parameterization <Value>.", "-        List<Value> args = new LinkedList<Value>();  ", "-        /* Mirror is the common supertype of StringReference, Value, and ReferenceType.  Changed from Mirror to Value ", "-         * because invokeMethod requires a List of Value type. It does not need to be a Mirror because neither sr nor ", "-         * val can be a ReferenceType */", "-        sr = _vm.mirrorOf(name);", "-        sr.disableCollection();", "-        args.add(sr);", "-        args.add(val);", "-        if (type == null) args.add(null);", "-        else if (type instanceof ReferenceType) {", "-          args.add(((ReferenceType)type).classObject());", "-", "-        /* System.out.println(\"Calling \" + method2Call.toString() + \"with \" + args.get(0).toString()); */", "-        debugInterpreter.invokeMethod(suspendedThreadRef, method2Call, args, ObjectReference.INVOKE_SINGLE_THREADED);", "-        return;", "-      catch (ObjectCollectedException oce) {", "-        tries++;", "-      }", "-      finally {", "-        sr.enableCollection();", "-      }", "-    throw new DebugException(\"The variable: \" + name +", "-                             \" could not be defined in the debug interpreter\");", "+    */", "+  private ReferenceType _getClass(String name) throws DebugException {", "+    List<ReferenceType> classes = _vm.classesByName(name);", "+    if (classes.isEmpty()) {", "+      throw new DebugException(\"Class '\" + name + \"' is not loaded\");", "+    }", "+    else {", "+      for (ReferenceType t : classes) {", "+        // class loader is null iff it comes from the bootstrap loader", "+        if (t.classLoader() == null) { return t; }", "+      }", "+      return classes.get(0);", "+    }", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6b40e4d5bfcefed557810955be384158", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "d933be24919e2ab110f61a795910708e74f868c4", "commitAfterChange": "e58ae584c79a105cf065f585a2d99664f4ef8788", "methodNumberBeforeChange": 78, "methodNumberAfterChange": 78, "signatureBeforeChange": "          public void testForInterfaceDef()", "signatureAfterChange": "          public void testForInterfaceDef()", "diff": ["-      ", "-      //Test that if the interface extends java.lang.Runnable, then an error is thrown.", "-      InterfaceDef id3 = new InterfaceDef(SourceInfo.NO_INFO, _publicMav, new Word(SourceInfo.NO_INFO, \"JimesH\"),", "-                                  new TypeParameter[0], new ReferenceType[] {new ClassOrInterfaceType(SourceInfo.NO_INFO, \"java.lang.Runnable\", new Type[0])}, new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "-      SymbolData sd = new SymbolData(\"JimesH\");", "-      sd.setIsContinuation(false);", "-      sd.setInterface(true);", "-      ", "-      symbolTable.clear();", "-      SymbolData runnableSd = new SymbolData(\"java.lang.Runnable\");", "-      runnableSd.setMav(_publicMav);", "-      runnableSd.setIsContinuation(false);", "-      runnableSd.setPackage(\"java.lang\");", "-      runnableSd.setInterface(true);", "-      sd.addInterface(runnableSd);", "-      symbolTable.put(\"JimesH\", sd);", "-      symbolTable.remove(\"java.lang.Runnable\");", "-      symbolTable.put(\"java.lang.Runnable\", runnableSd);", "+      /* The Runnable restriction has been dropped. */", "+//      //Test that if the interface extends java.lang.Runnable, then an error is thrown.", "+//      InterfaceDef id3 = new InterfaceDef(SourceInfo.NO_INFO, _publicMav, new Word(SourceInfo.NO_INFO, \"JimesH\"),", "+//                                  new TypeParameter[0], new ReferenceType[] {new ClassOrInterfaceType(SourceInfo.NO_INFO, \"java.lang.Runnable\", new Type[0])}, new BracedBody(SourceInfo.NO_INFO, new BodyItemI[0]));", "+//      SymbolData sd = new SymbolData(\"JimesH\");", "+//      sd.setIsContinuation(false);", "+//      sd.setInterface(true);", "+//      ", "+//      symbolTable.clear();", "+//      SymbolData runnableSd = new SymbolData(\"java.lang.Runnable\");", "+//      runnableSd.setMav(_publicMav);", "+//      runnableSd.setIsContinuation(false);", "+//      runnableSd.setPackage(\"java.lang\");", "+//      runnableSd.setInterface(true);", "+//      sd.addInterface(runnableSd);", "+//      symbolTable.put(\"JimesH\", sd);", "+//      symbolTable.remove(\"java.lang.Runnable\");", "+//      symbolTable.put(\"java.lang.Runnable\", runnableSd);", "+//", "+//      id3.visit(_btc);", "+//      assertEquals(\"There should be 3 errors now\", 3, errors.size());", "+//      assertEquals(\"The error message should be correct\", \"JimesH extends the Runnable interface, which is not allowed at any language level\", errors.get(2).getFirst());", "-      id3.visit(_btc);", "-      assertEquals(\"There should be 3 errors now\", 3, errors.size());", "-      assertEquals(\"The error message should be correct\", \"JimesH extends the Runnable interface, which is not allowed at any language level\", errors.get(2).getFirst());", "-", "-      //Test that an error is thrown if you implement a class", "+      // Test that an error is thrown if you implement a class", "-      assertEquals(\"There should be 4 errors now \", 4, errors.size());", "-      assertEquals(\"The error message should be correct\", \"superC is not an interface and thus cannot appear after the keyword 'extends' here\", errors.get(3).getFirst());", "+      assertEquals(\"There should be 3 errors now \", 3, errors.size());", "+      assertEquals(\"The error message should be correct\", ", "+                   \"superC is not an interface and thus cannot appear after the keyword 'extends' here\", ", "+                   errors.getLast().getFirst());", "-      //Test that no error is thrown if you implement an interface", "+      // Test that no error is thrown if you implement an interface", "-      assertEquals(\"There should still just be 4 errors\", 4, errors.size());", "+      assertEquals(\"There should still just be 3 errors\", 3, errors.size());", "-      //Test that if a public interface is in a file of the wrong name, an error is thrown.", "+      // Test that if a public interface is in a file of the wrong name, an error is thrown.", "-      assertEquals(\"There should be 5 errorrs\", 5, errors.size());", "-      assertEquals(\"The error message should be correct\", \"Bart is public thus must be defined in a file with the same name.\", errors.get(4).getFirst());", "+      assertEquals(\"There should be 4 errorrs\", 4, errors.size());", "+      assertEquals(\"The error message should be correct\", ", "+                   \"Bart is public thus must be defined in a file with the same name.\", ", "+                   errors.getLast().getFirst());", "-      //Test that if a public interface is in a file of the right name, no error is thrown.", "+      // Test that if a public interface is in a file of the right name, no error is thrown.", "-      assertEquals(\"There should still just be 5 errors\", 5, errors.size());", "+      assertEquals(\"There should still just be 4 errors\", 4, errors.size());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c146e88ca28b7be766cdb7681f759569", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/ConcreteRegionManager.java", "commitBeforeChange": "1ff154e9eb4de7b8f07ce9a8120997b76e53aa3f", "commitAfterChange": "50372cdcb0e3a8db5661a31f5825b5dc9f07a9e9", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 6, "signatureBeforeChange": "   public R getRegionContaining(OpenDefinitionsDocument odd, int startOffset, int endOffset)", "signatureAfterChange": "   public Collection<R> getRegionsOverlapping(OpenDefinitionsDocument odd, int startOffset, int endOffset)", "diff": ["-  public R getRegionContaining(OpenDefinitionsDocument odd, int startOffset, int endOffset) {", "+  public Collection<R> getRegionsOverlapping(OpenDefinitionsDocument odd, int startOffset, int endOffset) {", "-    /* First try finding the rightmost region on the same line containing the selection. Unnecessary in Java 6.0. */", "-    int lineStart = odd._getLineStartPos(startOffset);", "+//    assert EventQueue.isDispatchThread();", "+    LinkedList<R> result = new LinkedList<R>();", "+    if (startOffset == endOffset) return result;", "+    ", "+    /* Find all regions with an endPoint greater than startOffset. */", "-    SortedSet<R> tail = getTailSet((R) newDocumentRegion(odd, lineStart, endOffset));", "+    SortedSet<R> tail = getTailSet((R) newDocumentRegion(odd, 0, startOffset + 1));", "+    ", "-    R match = null;", "-    for (R r: tail) {", "-      if (r.getStartOffset() <= startOffset) {", "-        if (r.getEndOffset() >= endOffset) match = r;", "-      }", "-      else break;  // for all remaining r : R (r.getStartOffset() > offset)", "-    }", "-    if (match != null) return match;", "-    ", "-    /* No match found starting on same line; look for best match starting on preceding lines. */", "-    @SuppressWarnings(\"unchecked\")", "-    SortedSet<R> revHead = reverse(getHeadSet((R) newDocumentRegion(odd, lineStart, lineStart))); // linear cost! Ugh!", "-    ", "-    /* Find first match in revHead */", "-    Iterator<R> it = revHead.iterator();  // In Java 6.0, it is computable in constant time from headSet using reverseIterator", "-    ", "-    R next;", "-    while (it.hasNext()) {", "-      next = it.next();", "-      if (next.getEndOffset() >= endOffset) { match = next; break; }", "-    }", "-    ", "-    if (match == null) return null; // no match found", "-   ", "-    /* Try to improve the match by narrowing endOffset. */", "-    while (it.hasNext()) { ", "-      next = it.next();", "-      if (next.getStartOffset() < match.getStartOffset()) return match;  // no more improvement possible", "-      assert next.getStartOffset() == match.getStartOffset();", "-      if (next.getEndOffset() >= endOffset) match = next;  // improvement because next precedes match in getRegions(odd)", "-    }", "-    return match;  // last region in revHead was the best match", "+    for (R r: tail) {", "+      if (r.getStartOffset() >= endOffset) break;", "+      else result.add(r);", "+    }", "+    return result;"]}], "num": 18917}