{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c6201a235b7fd60757457db7ebcf079a", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "104883248b20d01975bb6995ea2e9203", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ExpressionChecker.java", "commitBeforeChange": "875709ea758d694dda7555b8eeb2e15fa58e98c5", "commitAfterChange": "d29db164117e7452d6023bc6a73abe9d53f7d65b", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 25, "signatureBeforeChange": "   @Override public Type visit(StaticMethodCall node)", "signatureAfterChange": "     @Override public Type visit(StaticMethodCall node)", "diff": ["-   */", "-  @Override public Type visit(StaticMethodCall node) {", "-    Type t = node.getMethodType().acceptVisitor(this);", "-    ", "-    Iterable<? extends Expression> args = IterUtil.empty();", "-    if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "-    ", "-    Iterable<Type> targs = IterUtil.empty();", "-    if (node instanceof PolymorphicStaticMethodCall) {", "-      targs = checkTypeNameList(((PolymorphicStaticMethodCall) node).getTypeArguments());", "-    }", "-    ", "-    try {", "-      // Note: Changes made below may also need to be made in the TypeSystem's boxing & unboxing implementations", "-      TypeSystem.MethodInvocation inv = ts.lookupStaticMethod(t, node.getMethodName(), targs, args);", "-      // TODO: Check accessibility of method", "-      checkThrownExceptions(inv.thrown(), node);", "-      node.setArguments(CollectUtil.makeList(inv.args()));", "-      setMethod(node, inv.method());", "-      Type result = ts.capture(inv.returnType());", "-      debug.logValue(\"Type of method call \" + node.getMethodName(), ts.wrap(result));", "-      addRuntimeCheck(node, result, inv.method().returnType());", "-      return setType(node, result);", "-    }", "-    catch (InvalidTypeArgumentException e) {", "-      throw new ExecutionError(\"type.argument\", node);", "-    }", "-    catch (TypeSystemException e) {", "-      setErrorStrings(node, ts.userRepresentation(t), node.getMethodName(), nodeTypesString(args));", "-      throw new ExecutionError(\"no.such.method\", node);", "-    }", "-  }", "+     */", "+    @Override public Type visit(StaticMethodCall node) {", "+      Type t = checkTypeName(node.getMethodType());", "+      ", "+      Iterable<? extends Expression> args = IterUtil.empty();", "+      if (node.getArguments() != null) { args = node.getArguments(); checkList(args); }", "+      ", "+      Iterable<Type> targs = IterUtil.empty();", "+      if (node instanceof PolymorphicStaticMethodCall) {", "+        targs = checkTypeNameList(((PolymorphicStaticMethodCall) node).getTypeArguments());", "+      }", "+      ", "+      try {", "+        // Note: Changes made below may also need to be made in the TypeSystem's boxing & unboxing implementations", "+        MethodInvocation inv = ts.lookupStaticMethod(t, node.getMethodName(), targs, args, expected);", "+        // TODO: Check accessibility of method", "+        checkThrownExceptions(inv.thrown(), node);", "+        node.setArguments(CollectUtil.makeList(inv.args()));", "+        setMethod(node, inv.method());", "+        Type result = ts.capture(inv.returnType());", "+        debug.logValue(\"Type of method call \" + node.getMethodName(), ts.wrap(result));", "+        addRuntimeCheck(node, result, inv.method().returnType());", "+        return setType(node, result);", "+      }", "+      catch (InvalidTypeArgumentException e) {", "+        throw new ExecutionError(\"type.argument\", node);", "+      }", "+      catch (TypeSystemException e) {", "+        setErrorStrings(node, ts.userRepresentation(t), node.getMethodName(), nodeTypesString(args));", "+        throw new ExecutionError(\"no.such.method\", node);", "+      }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7fab70310e531ace23fb64608ee111e2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "commitAfterChange": "608d05e2a10d21cbc190b09334cd60b3c39fbc37", "methodNumberBeforeChange": 100, "methodNumberAfterChange": 100, "signatureBeforeChange": "    protected Iterable<Type> captureTypeArgs(Iterable<? extends Type> targs,                                            Iterable<? extends VariableType> params)", "signatureAfterChange": "    protected Iterable<Type> captureTypeArgs(Iterable<? extends Type> targs,                                            Iterable<? extends VariableType> params)", "diff": ["-    List<BoundedSymbol> captureVars = new LinkedList<BoundedSymbol>();", "+    // Create uninitialized placeholders for capture variables and normalized capture variables", "+    List<VariableType> captureVars = new LinkedList<VariableType>();", "+    List<VariableType> normCaptureVars = new LinkedList<VariableType>();", "+    List<Type> normNewArgs = new LinkedList<Type>();", "-        BoundedSymbol s = new BoundedSymbol(new Object());", "-        captureVars.add(s);", "-        newArgs.add(new VariableType(s));", "+        VariableType var = new VariableType(new BoundedSymbol(new Object()));", "+        VariableType normVar = new VariableType(new BoundedSymbol(new Object()));", "+        captureVars.add(var);", "+        newArgs.add(var);", "+        normCaptureVars.add(normVar);", "+        normNewArgs.add(normVar);", "-      else { captureVars.add(null); newArgs.add(arg); }", "+      else { newArgs.add(arg); normNewArgs.add(arg); }", "+    // Initialize bounds of captureVars", "-    for (Triple<BoundedSymbol, Type, VariableType> triple : IterUtil.zip(captureVars, targs, params)) {", "-      Type arg = triple.second();", "+    Iterator<VariableType> captureVarsI = captureVars.iterator();", "+    for (Pair<VariableType, Type> p : IterUtil.zip(params, targs)) {", "+      Type arg = p.second();", "-        VariableType param = triple.third();", "+        VariableType param = p.first();", "-        Type captureU = argU.equals(paramU) ? argU : new IntersectionType(IterUtil.make(argU, paramU));", "-        Type captureL = argL.equals(paramL) ? argL : new UnionType(IterUtil.make(argL, paramL));", "-        // These bounds aren't normalized because we can't perform subtype checks on uninstantiated variables.", "-        // That's okay, though, because we don't assume anywhere that variable bounds are normalized.", "-        triple.first().initializeUpperBound(captureU);", "-        triple.first().initializeLowerBound(captureL);", "+        Type captureU = new IntersectionType(IterUtil.make(argU, paramU));", "+        Type captureL = new UnionType(IterUtil.make(argL, paramL));", "+        VariableType captureVar = captureVarsI.next();", "+        captureVar.symbol().initializeUpperBound(captureU);", "+        captureVar.symbol().initializeLowerBound(captureL);", "-    return newArgs;", "+    ", "+    // Initialize bounds of normCaptureVars by normalizing captureVars bounds (must be done", "+    // in a second stage because we can't perform subtype checks on uninstantiated variables).", "+    Normalizer norm = new Normalizer(new NormSubtyper());", "+    SubstitutionMap sigmaNorm = new SubstitutionMap(captureVars, normCaptureVars);", "+    for (Pair<VariableType, VariableType> p : IterUtil.zip(captureVars, normCaptureVars)) {", "+      Type upper = substitute(norm.value(p.first().symbol().upperBound()), sigmaNorm);", "+      Type lower = substitute(norm.value(p.first().symbol().lowerBound()), sigmaNorm);", "+      p.second().symbol().initializeUpperBound(upper);", "+      p.second().symbol().initializeLowerBound(lower);", "+    }", "+    ", "+    return normNewArgs;"]}], "num": 19646}