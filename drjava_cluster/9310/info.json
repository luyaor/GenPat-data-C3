{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "37f6058195cd4cf88f20314c92e20b3b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "210d03afb2e6e9d0e284fe7a39ad174e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>> convert(File[] files)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>   convert(File[] files, Options options)", "diff": ["-  /**Parse, Visit, Type Check, and Convert any language level files in the array of files*/\r", "-  public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>> convert(File[] files) {\r", "-    LanguageLevelVisitor._newSDs=new Hashtable<SymbolData, LanguageLevelVisitor>(); /**initialize so we don't get null pointer exception*/\r", "-    // We need a LinkedList for errors to be shared by the visitors to each file.\r", "-    LinkedList<Pair<String, JExpressionIF>> languageLevelVisitorErrors = new LinkedList<Pair<String, JExpressionIF>>();\r", "-    \r", "-    //keep track of the continuations to resolve\r", "-    Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>> continuations = new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>();\r", "-    \r", "-    //and the newSDs we've created\r", "-    Hashtable<SymbolData, LanguageLevelVisitor> languageLevelNewSDs = new Hashtable<SymbolData, LanguageLevelVisitor>();\r", "-    \r", "-    // Similarly, we need a Hashtable for a shared symbolTable.\r", "-    Symboltable languageLevelVisitorSymbolTable = new Symboltable();\r", "-\r", "-    //And a linked list thing to share visited files.\r", "-    LinkedList<Pair<LanguageLevelVisitor, SourceFile>> languageLevelVisitedFiles = new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>();\r", "-    \r", "-    // We are doing two passes on the files, and the second pass needs the first's corresponding\r", "-    // SourceFile and ElementaryVisitor so we'll keep them around in a Hashtable.\r", "-    Hashtable<Integer, Pair<SourceFile, LanguageLevelVisitor>> mediator = new Hashtable<Integer, Pair<SourceFile, LanguageLevelVisitor>>();\r", "-    \r", "-    // The visitedFiles returned by any pass may include another file which is already scheduled for compilation.\r", "-    // In this case, we don't want to reparse, or perform either the first pass or the type check since it has\r", "-    // already been done.  (An error is thrown if we do since it thinks the class has already been defined).\r", "-    LinkedList<File> filesNotToCheck = new LinkedList<File>();\r", "-    \r", "-    // The number of files to compile may change if one file references another one.\r", "-    // We don't want to visit these newly referenced files because they've already\r", "-    // been visited.\r", "-    int originalNumOfFiles = files.length;\r", "-    \r", "-    // Find the ones that are LL files.\r", "-    // Do the passes first for ALL files before proceeding to code augmentation.\r", "-    // Otherwise if one class' superclass get augmented first, then it sees a lot\r", "-    // of illegal constructs (e.g. public and constructors).\r", "-    \r", "-    //will maintain the files we visit along with their visitors (for type checking step).\r", "-    LinkedList<Pair<LanguageLevelVisitor, SourceFile>> visited = new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>();\r", "-\r", "-    \r", "-    for (int ind = 0; ind < originalNumOfFiles; ind++) {\r", "-      \r", "-      try {\r", "-        BufferedReader tempBr = new BufferedReader(new FileReader(files[ind]));\r", "-        String firstLine = tempBr.readLine();\r", "-        if (firstLine == null) {\r", "-          continue;\r", "-        }\r", "-        tempBr.close();\r", "-        // If the file has the correct suffix, then parse it.\r", "-        // Also ignore files which are in filesNotToCheck.\r", "-        //for some reason, doing .contains on filesNotToCheck was not returning what we wanted.\r", "-        //So do this manually, trying to match the Absolute path.\r", "-        boolean foundFile = false;\r", "-        for (int i = 0; i<filesNotToCheck.size(); i++) {\r", "-          if (filesNotToCheck.get(i).getAbsolutePath().equals(files[ind].getAbsolutePath())) {\r", "-            foundFile = true;\r", "-            break;\r", "-          }\r", "-        }\r", "-\r", "-        if (_isLanguageLevelFile(files[ind]) && !foundFile) {\r", "-          System.out.flush();\r", "-          SourceFile sf;\r", "-          File f = files[ind];\r", "-          JExprParser jep = new JExprParser(f);\r", "-          try { \r", "-            sf = jep.SourceFile();\r", "-          }\r", "-          catch (ParseException pe) {\r", "-            // If there is a ParseException, go to next file.\r", "-            _addParseException(pe);\r", "-            continue;\r", "-          }\r", "-          \r", "-          //Now create a LanguageLevelVisitor to do the first pass over the file.\r", "-          LanguageLevelVisitor llv = null;\r", "-          if (isElementaryFile(f)) {\r", "-            llv = new ElementaryVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(), languageLevelVisitorSymbolTable, new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), languageLevelVisitedFiles, languageLevelNewSDs, _targetVersion);\r", "-          }\r", "-          else if (isIntermediateFile(f)) {\r", "-            llv = new IntermediateVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(), languageLevelVisitorSymbolTable, new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), languageLevelVisitedFiles, languageLevelNewSDs, _targetVersion);\r", "-          }\r", "-          else if (isAdvancedFile(f)) {\r", "-            llv = new AdvancedVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(), languageLevelVisitorSymbolTable, new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), languageLevelVisitedFiles, languageLevelNewSDs, _targetVersion);\r", "-          }\r", "-          else {\r", "-            throw new RuntimeException(\"Internal Bug: Invalid file format not caught initially.  Please report this bug.\");\r", "-          }\r", "-\r", "-          \r", "-          // First pass\r", "-          sf.visit(llv);\r", "-          visited.add(new Pair<LanguageLevelVisitor, SourceFile>(llv, sf));\r", "-          //add the continuations to the hash table.\r", "-          continuations.putAll(llv.continuations);\r", "-          languageLevelVisitorErrors.addAll(llv.errors);\r", "-        }\r", "-      }\r", "-      catch (IOException ioe) {\r", "-        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.\r", "-        _addVisitorError(new Pair<String, JExpressionIF>(ioe.getMessage(), new NullLiteral(JExprParser.NO_SOURCE_INFO)));\r", "-      }\r", "-\r", "-    }\r", "-    \r", "-    \r", "-    //Resolve continuations and create constructors.  Also accumulate errors.\r", "-    LanguageLevelVisitor.errors = new LinkedList<Pair<String, JExpressionIF>>(); //clear out error list\r", "-    \r", "-    \r", "-        //Resolve continuations\r", "-    //Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>> continuations = llv.continuations;\r", "-    \r", "-    while (!continuations.isEmpty()) {\r", "-      Enumeration<String> en = continuations.keys();\r", "-      \r", "-      while (en.hasMoreElements()) {\r", "-        String className = en.nextElement();\r", "-        Pair<SourceInfo, LanguageLevelVisitor> pair = continuations.remove(className);\r", "-        SymbolData returnedSd = pair.getSecond().getSymbolData(className, pair.getFirst(), true);\r", "-        if (returnedSd == null) {\r", "-          LanguageLevelVisitor.errors.add(new Pair<String, JExpressionIF>(\"Could not resolve \" + className, new NullLiteral(pair.getFirst())));\r", "-        }\r", "-      }\r", "-    }\r", "-    \r", "-    //now create any constructors.\r", "-    while (!LanguageLevelVisitor._newSDs.isEmpty()) {\r", "-        Enumeration<SymbolData> en = LanguageLevelVisitor._newSDs.keys();\r", "-      while (en.hasMoreElements()) {\r", "-        SymbolData first = en.nextElement();\r", "-        LanguageLevelVisitor sdlv = LanguageLevelVisitor._newSDs.remove(first);\r", "-        sdlv.createConstructor(first);\r", "-      }\r", "-    }\r", "-    \r", "-    languageLevelVisitorErrors.addAll(LanguageLevelVisitor.errors); //add any errors that accumulated during the continuation resolving/constructor generation\r", "-    \r", "-    // At this point, there should be no continuations and visitedFiles should be completely populated.\r", "-    // Check for errors; don't type-check if there are errors.\r", "-    if (languageLevelVisitorErrors.size() > 0) {\r", "-      _visitorErrors.addAll(languageLevelVisitorErrors);\r", "-    }\r", "-    \r", "-    \r", "-    //Let's TYPE CHECK!!!\r", "-          \r", "-          else {\r", "-            \r", "-            for (int ind = 0; ind<visited.size(); ind++) {\r", "-  \r", "-              LanguageLevelVisitor llv = visited.get(ind).getFirst();\r", "-              SourceFile sf = visited.get(ind).getSecond();\r", "-              \r", "-              //TODO: This is a terrible hack to get around the following problem.  Basically, when we autobox in isAssignableTo in SymbolData, \r", "-              //we look through the object hierarchy for the primitive.  If its corresponding boxed object isn't in the symboltable, we're in trouble.\r", "-              //So, for those special cases, go ahead and make sure the object types are in the symbol table before we start type checking.\r", "-              //I'd like to make this better, but at least it works for now.\r", "-              \r", "-              \r", "-              //Before you type check, make sure that all boxed types of primitives are in the symbol table\r", "-              if (llv.symbolTable.get(\"java.lang.Integer\") == null) {llv.getSymbolData(\"java.lang.Integer\", JExprParser.NO_SOURCE_INFO);}\r", "-              if (llv.symbolTable.get(\"java.lang.Double\")==null) {llv.getSymbolData(\"java.lang.Double\", JExprParser.NO_SOURCE_INFO);}\r", "-              if (llv.symbolTable.get(\"java.lang.Character\")==null) {llv.getSymbolData(\"java.lang.Character\", JExprParser.NO_SOURCE_INFO);}\r", "-              if (llv.symbolTable.get(\"java.lang.Boolean\")==null) {llv.getSymbolData(\"java.lang.Boolean\", JExprParser.NO_SOURCE_INFO);}\r", "-              if (llv.symbolTable.get(\"java.lang.Long\")==null) {llv.getSymbolData(\"java.lang.Long\", JExprParser.NO_SOURCE_INFO);}\r", "-              if (llv.symbolTable.get(\"java.lang.Byte\")==null) {llv.getSymbolData(\"java.lang.Byte\", JExprParser.NO_SOURCE_INFO);}\r", "-              if (llv.symbolTable.get(\"java.lang.Short\")==null) {llv.getSymbolData(\"java.lang.Short\", JExprParser.NO_SOURCE_INFO);}\r", "-              if (llv.symbolTable.get(\"java.lang.Float\")==null) {llv.getSymbolData(\"java.lang.Float\", JExprParser.NO_SOURCE_INFO);}\r", "-              \r", "-              \r", "-              // Type check.\r", "-              TypeChecker btc = new TypeChecker(llv._file, llv._package, llv.errors, llv.symbolTable, llv._importedFiles, llv._importedPackages, _targetVersion);\r", "-              sf.visit(btc);\r", "-              if (btc.errors.size() > 0) {\r", "-                _visitorErrors.addAll(btc.errors);\r", "-              }\r", "-              \r", "-              // Add those files to be compiled to the array of files.\r", "-              if (llv.visitedFiles.size() > 0) {            \r", "-                LinkedList<File> newFiles = new LinkedList<File>();\r", "-                for (int i = 0; i < files.length; i++) {\r", "-                  newFiles.addLast(files[i]);\r", "-                }\r", "-                Iterator<Pair<LanguageLevelVisitor, SourceFile>> iter = llv.visitedFiles.iterator();\r", "-                while (iter.hasNext()) {\r", "-                  Pair<LanguageLevelVisitor,SourceFile> currPair = iter.next();\r", "-                  File fileToAdd = currPair.getFirst()._file;\r", "-                  // if currSf is not null, then this visitedFile came from visiting the source file, not the class file. \r", "-                  // We want to compile this source file; add it to the list of files after creating the mediator entry\r", "-                  // if necessary.\r", "-                  SourceFile currSf = currPair.getSecond();\r", "-                  if (currSf != null) {\r", "-                    if (newFiles.contains(fileToAdd)) {\r", "-                      // Messy, but we must make a mediator entry so that code augmentation has all the data it needs\r", "-                      // since we will skip visiting this file here.  \r", "-                      // Can just pass llv since it will contain the correct symbolTable.\r", "-                      mediator.put(new Integer(newFiles.indexOf(fileToAdd)), new Pair<SourceFile, LanguageLevelVisitor>(currSf, currPair.getFirst())); \r", "-                    }\r", "-                    // Now, if we aren't already compiling this file, and we visited the source, add it to the list of\r", "-                    // files to be compiled.\r", "-                    if (!newFiles.contains(fileToAdd) && currSf != null) {\r", "-                      mediator.put(new Integer(newFiles.size()), new Pair<SourceFile, LanguageLevelVisitor>(currSf, currPair.getFirst()));\r", "-                      newFiles.addLast(fileToAdd);\r", "-                    }\r", "-                    \r", "-                  }\r", "-                  // Also make sure not to re-check these files whether we visited source or class file. \r", "-                  // We only want to perform code augmentation since these files have already been visited.\r", "-                  if (!filesNotToCheck.contains(fileToAdd)) {\r", "-                    filesNotToCheck.addLast(fileToAdd);\r", "-                  }\r", "-                }\r", "-                files = (File[]) newFiles.toArray(new File[newFiles.size()]);\r", "-              }\r", "-              \r", "-              mediator.put(new Integer(ind), new Pair<SourceFile, LanguageLevelVisitor>(sf, llv));\r", "-            }\r", "-          }\r", "-    \r", "-    \r", "-    //If there were any errors in the llv pass or the type checking pass, just return them.\r", "-    if (_parseExceptions.size() > 0 || _visitorErrors.size() > 0) {\r", "-      return new Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions, _visitorErrors);\r", "-    }\r", "-    \r", "-    // Now do code augmentation.\r", "-    for (int ind = 0; ind < files.length; ind++) {\r", "-      try {\r", "-        BufferedReader tempBr = new BufferedReader(new FileReader(files[ind]));\r", "-        String firstLine = tempBr.readLine();\r", "-        tempBr.close(); // Important to close the reader, otherwise Windows will not allow the renameTo call later.\r", "-        if (firstLine == null) {\r", "-          continue;\r", "-        }\r", "-\r", "-        // If the file has the correct beginner tag at the beginning, then parse it.\r", "-        // It should not end in .beginner since that's just a temporary copy which gets\r", "-        // deleted after the compile.\r", "-        if (_isLanguageLevelFile(files[ind])) {\r", "-          Pair<SourceFile, LanguageLevelVisitor> pair = mediator.get(new Integer(ind));\r", "-          if (pair != null) { //if pair is null, we do not actually need to augment this file--it wasn't visited.  Maybe we used the class file?\r", "-            SourceFile sf = pair.getFirst();\r", "-            LanguageLevelVisitor llv = pair.getSecond();\r", "-            File f = files[ind];\r", "-            // Do code augmentation.  This will involve a line-by-line copy, editing\r", "-            // lines as appropriate.\r", "-            String augmentedFilePath = f.getAbsolutePath();\r", "-            augmentedFilePath = augmentedFilePath.substring(0, augmentedFilePath.length() - 4); //remove the .dj# extension\r", "-            File augmentedFile = new File(augmentedFilePath + \".java\"); //replace it with .java\r", "-            BufferedReader br = new BufferedReader(new FileReader(f));\r", "-            BufferedWriter bw = new BufferedWriter(new FileWriter(augmentedFile));\r", "-            \r", "-            Augmentor a = new Augmentor(_targetVersion, SAFE_SUPPORT_CODE, br, bw, llv);\r", "-            sf.visit(a);\r", "-            \r", "-            br.close();\r", "-            bw.close();\r", "-          }\r", "-        }\r", "-      }\r", "-      catch (Augmentor.Exception ae) {\r", "-        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.\r", "-        _addVisitorError(new Pair<String, JExpressionIF>(ae.getMessage(), new NullLiteral(JExprParser.NO_SOURCE_INFO)));\r", "-      }\r", "-      catch (IOException ioe) {\r", "-        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.\r", "-        _addVisitorError(new Pair<String, JExpressionIF>(ioe.getMessage(), new NullLiteral(JExprParser.NO_SOURCE_INFO)));\r", "-      }\r", "-    }\r", "-    return new Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions,\r", "-                                                                                       _visitorErrors);\r", "-  }\r", "+  /**Parse, Visit, Type Check, and Convert any language level files in the array of files*/", "+  public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>", "+  convert(File[] files, Options options) {", "+    OPT = options;", "+    LanguageLevelVisitor._newSDs=new Hashtable<SymbolData, LanguageLevelVisitor>(); /**initialize so we don't get null pointer exception*/", "+    // We need a LinkedList for errors to be shared by the visitors to each file.", "+    LinkedList<Pair<String, JExpressionIF>> languageLevelVisitorErrors = new LinkedList<Pair<String, JExpressionIF>>();", "+    ", "+    //keep track of the continuations to resolve", "+    Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>> continuations = new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>();", "+    ", "+    //and the newSDs we've created", "+    Hashtable<SymbolData, LanguageLevelVisitor> languageLevelNewSDs = new Hashtable<SymbolData, LanguageLevelVisitor>();", "+    ", "+    // Similarly, we need a Hashtable for a shared symbolTable.", "+    Symboltable languageLevelVisitorSymbolTable = new Symboltable();", "+", "+    //And a linked list thing to share visited files.", "+    LinkedList<Pair<LanguageLevelVisitor, SourceFile>> languageLevelVisitedFiles = new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>();", "+    ", "+    // We are doing two passes on the files, and the second pass needs the first's corresponding", "+    // SourceFile and ElementaryVisitor so we'll keep them around in a Hashtable.", "+    Hashtable<Integer, Pair<SourceFile, LanguageLevelVisitor>> mediator = new Hashtable<Integer, Pair<SourceFile, LanguageLevelVisitor>>();", "+    ", "+    // The visitedFiles returned by any pass may include another file which is already scheduled for compilation.", "+    // In this case, we don't want to reparse, or perform either the first pass or the type check since it has", "+    // already been done.  (An error is thrown if we do since it thinks the class has already been defined).", "+    LinkedList<File> filesNotToCheck = new LinkedList<File>();", "+    ", "+    // The number of files to compile may change if one file references another one.", "+    // We don't want to visit these newly referenced files because they've already", "+    // been visited.", "+    int originalNumOfFiles = files.length;", "+    ", "+    // Find the ones that are LL files.", "+    // Do the passes first for ALL files before proceeding to code augmentation.", "+    // Otherwise if one class' superclass get augmented first, then it sees a lot", "+    // of illegal constructs (e.g. public and constructors).", "+    ", "+    //will maintain the files we visit along with their visitors (for type checking step).", "+    LinkedList<Pair<LanguageLevelVisitor, SourceFile>> visited = new LinkedList<Pair<LanguageLevelVisitor, SourceFile>>();", "+", "+    ", "+    for (int ind = 0; ind < originalNumOfFiles; ind++) {", "+      ", "+      try {", "+        BufferedReader tempBr = new BufferedReader(new FileReader(files[ind]));", "+        String firstLine = tempBr.readLine();", "+        if (firstLine == null) {", "+          continue;", "+        }", "+        tempBr.close();", "+        // If the file has the correct suffix, then parse it.", "+        // Also ignore files which are in filesNotToCheck.", "+        //for some reason, doing .contains on filesNotToCheck was not returning what we wanted.", "+        //So do this manually, trying to match the Absolute path.", "+        boolean foundFile = false;", "+        for (int i = 0; i<filesNotToCheck.size(); i++) {", "+          if (filesNotToCheck.get(i).getAbsolutePath().equals(files[ind].getAbsolutePath())) {", "+            foundFile = true;", "+            break;", "+          }", "+        }", "+", "+        if (_isLanguageLevelFile(files[ind]) && !foundFile) {", "+          System.out.flush();", "+          SourceFile sf;", "+          File f = files[ind];", "+          JExprParser jep = new JExprParser(f);", "+          try { ", "+            sf = jep.SourceFile();", "+          }", "+          catch (ParseException pe) {", "+            // If there is a ParseException, go to next file.", "+            _addParseException(pe);", "+            continue;", "+          }", "+          ", "+          //Now create a LanguageLevelVisitor to do the first pass over the file.", "+          LanguageLevelVisitor llv = null;", "+          if (isElementaryFile(f)) {", "+            llv = new ElementaryVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(), languageLevelVisitorSymbolTable, new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), languageLevelVisitedFiles, languageLevelNewSDs);", "+          }", "+          else if (isIntermediateFile(f)) {", "+            llv = new IntermediateVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(), languageLevelVisitorSymbolTable, new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), languageLevelVisitedFiles, languageLevelNewSDs);", "+          }", "+          else if (isAdvancedFile(f)) {", "+            llv = new AdvancedVisitor(f, new LinkedList<Pair<String, JExpressionIF>>(), languageLevelVisitorSymbolTable, new Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>>(), languageLevelVisitedFiles, languageLevelNewSDs);", "+          }", "+          else {", "+            throw new RuntimeException(\"Internal Bug: Invalid file format not caught initially.  Please report this bug.\");", "+          }", "+", "+          ", "+          // First pass", "+          sf.visit(llv);", "+          visited.add(new Pair<LanguageLevelVisitor, SourceFile>(llv, sf));", "+          //add the continuations to the hash table.", "+          continuations.putAll(llv.continuations);", "+          languageLevelVisitorErrors.addAll(llv.errors);", "+        }", "+      }", "+      catch (IOException ioe) {", "+        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "+        _addVisitorError(new Pair<String, JExpressionIF>(ioe.getMessage(), new NullLiteral(JExprParser.NO_SOURCE_INFO)));", "+      }", "+", "+    }", "+    ", "+    ", "+    //Resolve continuations and create constructors.  Also accumulate errors.", "+    LanguageLevelVisitor.errors = new LinkedList<Pair<String, JExpressionIF>>(); //clear out error list", "+    ", "+    ", "+        //Resolve continuations", "+    //Hashtable<String, Pair<SourceInfo, LanguageLevelVisitor>> continuations = llv.continuations;", "+    ", "+    while (!continuations.isEmpty()) {", "+      Enumeration<String> en = continuations.keys();", "+      ", "+      while (en.hasMoreElements()) {", "+        String className = en.nextElement();", "+        Pair<SourceInfo, LanguageLevelVisitor> pair = continuations.remove(className);", "+        SymbolData returnedSd = pair.getSecond().getSymbolData(className, pair.getFirst(), true);", "+        if (returnedSd == null) {", "+          LanguageLevelVisitor.errors.add(new Pair<String, JExpressionIF>(\"Could not resolve \" + className, new NullLiteral(pair.getFirst())));", "+        }", "+      }", "+    }", "+    ", "+    //now create any constructors.", "+    while (!LanguageLevelVisitor._newSDs.isEmpty()) {", "+        Enumeration<SymbolData> en = LanguageLevelVisitor._newSDs.keys();", "+      while (en.hasMoreElements()) {", "+        SymbolData first = en.nextElement();", "+        LanguageLevelVisitor sdlv = LanguageLevelVisitor._newSDs.remove(first);", "+        sdlv.createConstructor(first);", "+      }", "+    }", "+    ", "+    languageLevelVisitorErrors.addAll(LanguageLevelVisitor.errors); //add any errors that accumulated during the continuation resolving/constructor generation", "+    ", "+    // At this point, there should be no continuations and visitedFiles should be completely populated.", "+    // Check for errors; don't type-check if there are errors.", "+    if (languageLevelVisitorErrors.size() > 0) {", "+      _visitorErrors.addAll(languageLevelVisitorErrors);", "+    }", "+    ", "+    ", "+    //Let's TYPE CHECK!!!", "+          ", "+          else {", "+            ", "+            for (int ind = 0; ind<visited.size(); ind++) {", "+  ", "+              LanguageLevelVisitor llv = visited.get(ind).getFirst();", "+              SourceFile sf = visited.get(ind).getSecond();", "+              ", "+              //TODO: This is a terrible hack to get around the following problem.  Basically, when we autobox in isAssignableTo in SymbolData, ", "+              //we look through the object hierarchy for the primitive.  If its corresponding boxed object isn't in the symboltable, we're in trouble.", "+              //So, for those special cases, go ahead and make sure the object types are in the symbol table before we start type checking.", "+              //I'd like to make this better, but at least it works for now.", "+              ", "+              ", "+              //Before you type check, make sure that all boxed types of primitives are in the symbol table", "+              if (llv.symbolTable.get(\"java.lang.Integer\") == null) {llv.getSymbolData(\"java.lang.Integer\", JExprParser.NO_SOURCE_INFO);}", "+              if (llv.symbolTable.get(\"java.lang.Double\")==null) {llv.getSymbolData(\"java.lang.Double\", JExprParser.NO_SOURCE_INFO);}", "+              if (llv.symbolTable.get(\"java.lang.Character\")==null) {llv.getSymbolData(\"java.lang.Character\", JExprParser.NO_SOURCE_INFO);}", "+              if (llv.symbolTable.get(\"java.lang.Boolean\")==null) {llv.getSymbolData(\"java.lang.Boolean\", JExprParser.NO_SOURCE_INFO);}", "+              if (llv.symbolTable.get(\"java.lang.Long\")==null) {llv.getSymbolData(\"java.lang.Long\", JExprParser.NO_SOURCE_INFO);}", "+              if (llv.symbolTable.get(\"java.lang.Byte\")==null) {llv.getSymbolData(\"java.lang.Byte\", JExprParser.NO_SOURCE_INFO);}", "+              if (llv.symbolTable.get(\"java.lang.Short\")==null) {llv.getSymbolData(\"java.lang.Short\", JExprParser.NO_SOURCE_INFO);}", "+              if (llv.symbolTable.get(\"java.lang.Float\")==null) {llv.getSymbolData(\"java.lang.Float\", JExprParser.NO_SOURCE_INFO);}", "+              ", "+              ", "+              // Type check.", "+              TypeChecker btc = new TypeChecker(llv._file, llv._package, llv.errors, llv.symbolTable, llv._importedFiles, llv._importedPackages);", "+              sf.visit(btc);", "+              if (btc.errors.size() > 0) {", "+                _visitorErrors.addAll(btc.errors);", "+              }", "+              ", "+              // Add those files to be compiled to the array of files.", "+              if (llv.visitedFiles.size() > 0) {            ", "+                LinkedList<File> newFiles = new LinkedList<File>();", "+                for (int i = 0; i < files.length; i++) {", "+                  newFiles.addLast(files[i]);", "+                }", "+                Iterator<Pair<LanguageLevelVisitor, SourceFile>> iter = llv.visitedFiles.iterator();", "+                while (iter.hasNext()) {", "+                  Pair<LanguageLevelVisitor,SourceFile> currPair = iter.next();", "+                  File fileToAdd = currPair.getFirst()._file;", "+                  // if currSf is not null, then this visitedFile came from visiting the source file, not the class file. ", "+                  // We want to compile this source file; add it to the list of files after creating the mediator entry", "+                  // if necessary.", "+                  SourceFile currSf = currPair.getSecond();", "+                  if (currSf != null) {", "+                    if (newFiles.contains(fileToAdd)) {", "+                      // Messy, but we must make a mediator entry so that code augmentation has all the data it needs", "+                      // since we will skip visiting this file here.  ", "+                      // Can just pass llv since it will contain the correct symbolTable.", "+                      mediator.put(new Integer(newFiles.indexOf(fileToAdd)), new Pair<SourceFile, LanguageLevelVisitor>(currSf, currPair.getFirst())); ", "+                    }", "+                    // Now, if we aren't already compiling this file, and we visited the source, add it to the list of", "+                    // files to be compiled.", "+                    if (!newFiles.contains(fileToAdd) && currSf != null) {", "+                      mediator.put(new Integer(newFiles.size()), new Pair<SourceFile, LanguageLevelVisitor>(currSf, currPair.getFirst()));", "+                      newFiles.addLast(fileToAdd);", "+                    }", "+                    ", "+                  }", "+                  // Also make sure not to re-check these files whether we visited source or class file. ", "+                  // We only want to perform code augmentation since these files have already been visited.", "+                  if (!filesNotToCheck.contains(fileToAdd)) {", "+                    filesNotToCheck.addLast(fileToAdd);", "+                  }", "+                }", "+                files = (File[]) newFiles.toArray(new File[newFiles.size()]);", "+              }", "+              ", "+              mediator.put(new Integer(ind), new Pair<SourceFile, LanguageLevelVisitor>(sf, llv));", "+            }", "+          }", "+    ", "+    ", "+    //If there were any errors in the llv pass or the type checking pass, just return them.", "+    if (_parseExceptions.size() > 0 || _visitorErrors.size() > 0) {", "+      return new Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions, _visitorErrors);", "+    }", "+    ", "+    // Now do code augmentation.", "+    for (int ind = 0; ind < files.length; ind++) {", "+      try {", "+        BufferedReader tempBr = new BufferedReader(new FileReader(files[ind]));", "+        String firstLine = tempBr.readLine();", "+        tempBr.close(); // Important to close the reader, otherwise Windows will not allow the renameTo call later.", "+        if (firstLine == null) {", "+          continue;", "+        }", "+", "+        // If the file has the correct beginner tag at the beginning, then parse it.", "+        // It should not end in .beginner since that's just a temporary copy which gets", "+        // deleted after the compile.", "+        if (_isLanguageLevelFile(files[ind])) {", "+          Pair<SourceFile, LanguageLevelVisitor> pair = mediator.get(new Integer(ind));", "+          if (pair != null) { //if pair is null, we do not actually need to augment this file--it wasn't visited.  Maybe we used the class file?", "+            SourceFile sf = pair.getFirst();", "+            LanguageLevelVisitor llv = pair.getSecond();", "+            File f = files[ind];", "+            // Do code augmentation.  This will involve a line-by-line copy, editing", "+            // lines as appropriate.", "+            String augmentedFilePath = f.getAbsolutePath();", "+            augmentedFilePath = augmentedFilePath.substring(0, augmentedFilePath.length() - 4); //remove the .dj# extension", "+            File augmentedFile = new File(augmentedFilePath + \".java\"); //replace it with .java", "+            BufferedReader br = new BufferedReader(new FileReader(f));", "+            BufferedWriter bw = new BufferedWriter(new FileWriter(augmentedFile));", "+            ", "+            Augmentor a = new Augmentor(SAFE_SUPPORT_CODE, br, bw, llv);", "+            sf.visit(a);", "+            ", "+            br.close();", "+            bw.close();", "+          }", "+        }", "+      }", "+      catch (Augmentor.Exception ae) {", "+        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "+        _addVisitorError(new Pair<String, JExpressionIF>(ae.getMessage(), new NullLiteral(JExprParser.NO_SOURCE_INFO)));", "+      }", "+      catch (IOException ioe) {", "+        // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "+        _addVisitorError(new Pair<String, JExpressionIF>(ioe.getMessage(), new NullLiteral(JExprParser.NO_SOURCE_INFO)));", "+      }", "+    }", "+    return new Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>(_parseExceptions,", "+                                                                                       _visitorErrors);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "57da769b77b37d956fa49936e3f936c2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/parser/wrapper/ParseError.java", "commitBeforeChange": "f5712545338ec09fefb321f9e27396d8fb91a646", "commitAfterChange": "1676fcce81c19c5d647ee9a67867801bec666091", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": "          public ParseError(Throwable t)", "signatureAfterChange": "          public ParseError(Throwable t, SourceInfo si)", "diff": ["-    ", "-    public ParseError(Throwable t) {", "-        this(t.getMessage(), \"\", -1, -1);", "-    }", "+    public ParseError(Throwable t, SourceInfo si) {", "+      super(t.getMessage(), t);", "+      _si = si;"]}], "num": 9310}