{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cd13df96f46dfc6d19dc60019144c46a", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3ff6188fb5dbc33b416728fe8c1126d2", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/newjvm/SlaveJVMRunner.java", "commitBeforeChange": "3ae33096a45a4dc4990b95b1565bd0aeaf9084da", "commitAfterChange": "e69a4c60c625d52f9ba6a18669f0f6846846e463", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "   public static void main(String[] args)", "signatureAfterChange": "   public synchronized static void main(String[] args)", "diff": ["-  public static void main(String[] args) {", "-    ", "-    _log.log(\"Slave JVM has started with args \" + edu.rice.cs.util.StringOps.toString(args));", "+  public synchronized static void main(String[] args) {", "+        ", "+      _main = Thread.currentThread();", "-      // if we have a remote classloader to use", "-      if (args.length == 3) {", "-        //get the classloader", "-        IRemoteClassLoader remoteLoader = null;", "-        FileInputStream fstream = new FileInputStream(args[2]);", "-        ObjectInputStream ostream = new ObjectInputStream(new BufferedInputStream(fstream));", "-        _log.log(\"Slave JVM reading remote loader object\");", "-        remoteLoader = (IRemoteClassLoader) ostream.readObject();", "-        _log.log(\"remote loader read\");", "-        if (ClassLoader.getSystemClassLoader() instanceof CustomSystemClassLoader) {", "-          CustomSystemClassLoader loader = (CustomSystemClassLoader) ClassLoader.getSystemClassLoader();", "-          loader.setMasterRemote(remoteLoader);", "-        }", "-        _log.log(\"remote loader installed\");", "-      }", "-", "+//      // Loading the class that intermittently hangs first readObject(...) call below", "+//      Class psi = Class.forName(\"java.net.PlainSocketImpl\");", "+      ", "-      _log.log(\"Slave JVM reading the remote master object\");", "-      FileInputStream fstream = new FileInputStream(args[0]);", "-      ObjectInputStream ostream = new ObjectInputStream(new BufferedInputStream(fstream));", "-      MasterRemote master = (MasterRemote) ostream.readObject();", "-      _log.log(\"remote master read\");", "+      final FileInputStream fstream = new FileInputStream(args[0]);", "+      final ObjectInputStream ostream = new ObjectInputStream(new BufferedInputStream(fstream));", "+      ", "+      _log.log(\"Slave JVM reading master remote stub from file \" + args[0] + \" with \" + ", "+                 fstream.getChannel().size() + \" bytes\");", "+      ", "+/* The following code currently breaks unit tests (and perhaps DrJava) when it detects the hanging", "+ * of readObject(...).  It can be commented back if the calling code is revised to handle this form", "+ * of exit. */", "+      ", "+//      Thread timeout = new Thread(\"RMI Timeout Thread\") {", "+//        public void run() {", "+//          _log.log(\"RMI timer started\");", "+//          final Object lock = new Object();", "+//          try { synchronized(lock) { lock.wait(RMI_TIMEOUT); } }", "+//          catch(InterruptedException e) { throw new UnexpectedException(e); }", "+//          // Abort starting this slave JVM if readObject has hung", "+//          if (_remoteLoader == null) {", "+//            StackTraceElement[] trace = Thread.getAllStackTraces().get(_main);", "+//            _log.log(\"DUMP of hung deserializing thread:\", trace);", "+//            System.exit(9);", "+//          }", "+//          else _log.log(this + \" TERMINATED normally\");", "+//        }", "+//      };", "+//      ", "+//      timeout.setDaemon(true);", "+//      timeout.start();", "+      ", "+//      // if we have a remote classloader to use, load it", "+//      if (args.length == 3) _installRemoteLoader(args[2]);", "+", "+      final MasterRemote masterRemote = (MasterRemote) ostream.readObject();", "+      _log.log(\"Slave JVM completed reading \" + masterRemote);", "+  ", "-        _log.log(\"Slave JVM creating singleton instance of slave class \" + args[1]);", "-        SlaveRemote slave = _getInstance(slaveClass);", "+//        _log.log(\"Slave JVM created singleton of \" + args[1]);", "+        AbstractSlaveJVM slave = _getInstance(slaveClass);", "-        // Must export slave object to RMI so we can pass stub to the master", "-        _log.log(\"Slave JVM creaing RMI stub for slave class instance \" + slave);", "-        SlaveRemote stub = (SlaveRemote) UnicastRemoteObject.exportObject(slave);  ", "-        _log.log(\"Exported stub \" + stub + \" for \" + slaveClass);", "-        ", "-        // Debug: check that the IP address is 127.0.0.1", "-        //javax.swing.JOptionPane.showMessageDialog(null, stub.toString());", "+        //Export slave object to RMI, passing stub to the master JVM (how does stub get there?  Transitivity?", "+//        _log.log(\"Slave JVM exporting \" + slave + \" to RMI\");", "+        SlaveRemote slaveRemote = (SlaveRemote) UnicastRemoteObject.exportObject(slave);  ", "+        _log.log(\"Slave JVM exported stub \" + slaveRemote);", "-        _log.log(\"Slave JVM invoking the method start(\" + master + \") in the Slave JVM class\");", "-        slave.start(master);", "+//        _log.log(\"Slave JVM invoking the method \" + slave + \".start(\" + masterRemote + \")\");", "+        slave.start(masterRemote);", "-        master.registerSlave(slave);", "+        masterRemote.registerSlave(slaveRemote);", "-      catch (Throwable t) {", "+      catch (Exception e) {", "-        _log.log(\"Slave JVM could not intstantiate slave class and will exit\");", "+        _log.log(\"Slave JVM could not intstantiate slave class.  Threw exception: \" + e);", "-          master.errorStartingSlave(t);", "+          masterRemote.errorStartingSlave(e);", "-          _showErrorMessage(msg, t);", "+          _showErrorMessage(msg, e);", "-    catch (Throwable t) {", "+    catch (Exception e) { // IOException, ClassNotFoundException", "-      _showErrorMessage(\"Couldn't deserialize remote stub for the master JVM.\", t);", "+      _showErrorMessage(\"Could not set up the Slave JVM.\", e);", "+      _log.log(\"Could not set up the Slave JVM. Calling System.exit(2) in response to: \" + e);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ace8ec10196f6bb9cf27cc6b37b76cc3", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/JPDADebugger.java", "commitBeforeChange": "7b90d9227a34693633b434e1d2773067e65a70e5", "commitAfterChange": "1b1a2ff927caf38a8f2ba21780232fcbeb4319bb", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 57, "signatureBeforeChange": "   private void _updateWatches() throws DebugException", "signatureAfterChange": "   private void _updateWatches() throws DebugException", "diff": ["+      ObjectReference obj = currFrame.thisObject();", "+      ", "+        ", "-          ObjectReference obj = currFrame.thisObject();", "+          // Not compiled with debug flag.... ignore", "+        ObjectReference outer = obj;", "-          String className = outerRt.name();", "-          while (field == null) {", "+          Field outerThis = outerRt.fieldByName(\"this$0\");", "+          ", "+          while ((field == null) && (outerThis != null)) {", "+            outer = (ObjectReference) outer.getValue(outerThis);", "+            //outer = (ObjectReference)outer.getValue(outerThis);//currFrame.getValue(var);", "+            outerRt = outer.referenceType();", "+            field = outerRt.fieldByName(currName);", "+            ", "+            if (field == null) {", "+              // Enter the loop again with the next outer enclosing class", "+              outerThis = outerRt.fieldByName(\"this$0\");                ", "+            }    ", "+          }", "+          ", "+          if (field != null) {", "+            currWatch.setValue(_getValue(outer.getValue(field)));", "+            try {", "+              currWatch.setType(field.type());", "+            }", "+            catch (ClassNotLoadedException cnle) {", "+              currWatch.setType(null);", "+            }", "+          }", "+          /*", "+              LocalVariable var;", "+              ObjectReference outer;", "+              do {", "+                // get the object reference for outer classes", "+                var = currFrame.visibleVariableByName(\"this$0\");", "+                outer = (ObjectReference)currFrame.getValue(var);", "+              }", "+              while (!outer.referenceType().equals(outerRt));", "+                 ", "+              */", "+          ", "+              /*", "-            }", "-          }", "+              ", "+            }*/"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0adffac9f11bf8e582f846203f168b7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelConverter.java", "commitBeforeChange": "c2534d285c076411f44905ccf9cea4fb321903a1", "commitAfterChange": "6c7308b28231f013064e2caac6c40346905e6204", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>   convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "signatureAfterChange": "   public Pair<LinkedList<JExprParseException>, LinkedList<Pair<String, JExpressionIF>>>     convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap)", "diff": ["-  convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap) {", "+    convert(File[] files, Options options, Map<File,Set<String>> sourceToTopLevelClassMap) {", "-", "-    //And a linked list thing to share visited files.", "+    ", "+    //And a linked list to share visited files.", "-", "+    ", "+      File f = files[ind];", "-        BufferedReader tempBr = new BufferedReader(new FileReader(files[ind]));", "+        BufferedReader tempBr = new BufferedReader(new FileReader(f));", "-        ", "+        ", "-        boolean foundFile = false;", "-        for (int i = 0; i < filesNotToCheck.size(); i++) {", "-          if (filesNotToCheck.get(i).getAbsolutePath().equals(files[ind].getAbsolutePath())) {", "-            foundFile = true;", "+//        boolean foundFile = false;", "+        ", "+        for (File fntc: files) {", "+          if (fntc.getAbsolutePath().equals(f.getAbsolutePath())) {", "+//            foundFile = true;", "-", "-        if (_isLanguageLevelFile(files[ind]) && ! foundFile) {", "+        ", "+        if (_isLanguageLevelFile(f) /* && ! foundFile*/) {", "-          File f = files[ind];", "+//          File f = files[ind];", "-", "+          ", "-", "+      ", "-    ", "+//    Utilities.show(\"Visited \" + visited + \" in first pass\");", "-        //Resolve continuations", "+    //Resolve continuations", "-    while (!continuations.isEmpty()) {", "+    while (! continuations.isEmpty()) {", "-    if (languageLevelVisitorErrors.size() > 0) {", "-      _visitorErrors.addAll(languageLevelVisitorErrors);", "+    if (languageLevelVisitorErrors.size() > 0)  _visitorErrors.addAll(languageLevelVisitorErrors);", "+    ", "+    else { //Let's TYPE CHECK!!!", "+      ", "+      ", "+      for (int ind = 0; ind < visited.size(); ind++) {", "+        ", "+        LanguageLevelVisitor llv = visited.get(ind).getFirst();", "+        SourceFile sf = visited.get(ind).getSecond();", "+        ", "+        //TODO: This is a terrible hack to get around the following problem.  Basically, when we autobox in isAssignableTo in SymbolData, ", "+        //we look through the object hierarchy for the primitive.  If its corresponding boxed object isn't in the symboltable, we're in trouble.", "+        //So, for those special cases, go ahead and make sure the object types are in the symbol table before we start type checking.", "+        //I'd like to make this better, but at least it works for now.", "+        ", "+        ", "+        //Before you type check, make sure that all boxed types of primitives are in the symbol table", "+        if (llv.symbolTable.get(\"java.lang.Integer\") == null) {llv.getSymbolData(\"java.lang.Integer\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Double\")==null) {llv.getSymbolData(\"java.lang.Double\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Character\")==null) {llv.getSymbolData(\"java.lang.Character\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Boolean\")==null) {llv.getSymbolData(\"java.lang.Boolean\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Long\")==null) {llv.getSymbolData(\"java.lang.Long\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Byte\")==null) {llv.getSymbolData(\"java.lang.Byte\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Short\")==null) {llv.getSymbolData(\"java.lang.Short\", JExprParser.NO_SOURCE_INFO);}", "+        if (llv.symbolTable.get(\"java.lang.Float\")==null) {llv.getSymbolData(\"java.lang.Float\", JExprParser.NO_SOURCE_INFO);}", "+        ", "+        ", "+        // Type check.", "+        TypeChecker btc = new TypeChecker(llv._file, llv._package, llv.errors, llv.symbolTable, llv._importedFiles, llv._importedPackages);", "+        sf.visit(btc);", "+        if (btc.errors.size() > 0) _visitorErrors.addAll(btc.errors);", "+      }", "+      ", "+      // Set up code augmentation.  We will NOT try to augment files unless they appear in the visited List.  Unlisted LL files cannot be found", "+      // reliably during type checking because there is no naming convention that tells the type checker what files to look for.", "+      ", "+      Iterator<Pair<LanguageLevelVisitor, SourceFile>> iter = visited.iterator();", "+      LinkedList<File> newFiles = new LinkedList<File>();", "+      for (int ind = 0; iter.hasNext(); ind++) { // Note unusual loop termination condition; iter, ind in lock step", "+        Pair<LanguageLevelVisitor, SourceFile> currPair = iter.next();", "+        File fileToAdd = currPair.getFirst()._file;", "+        ", "+        if (_isLanguageLevelFile(fileToAdd)) { // fileToAdd is a visited LL file", "+//          Utilities.show(fileToAdd + \" is a LL file for augmentation\");", "+          newFiles.addLast(fileToAdd);", "+          mediator.put(ind, new Pair<SourceFile, LanguageLevelVisitor>(currPair.getSecond(), currPair.getFirst())); ", "+        }", "+        ", "+        // Also make sure not to re-check these files whether we visited source or class file. ", "+        // We only want to perform code augmentation since these files have already been visited.", "+        if (! filesNotToCheck.contains(fileToAdd)) filesNotToCheck.addLast(fileToAdd);", "+      }", "+      files = newFiles.toArray(new File[newFiles.size()]);", "+//      Utilities.show(\"Created files array: \" + Arrays.toString(files));", "-    ", "-    //Let's TYPE CHECK!!!", "-          ", "-          else {", "-            ", "-            for (int ind = 0; ind<visited.size(); ind++) {", "-  ", "-              LanguageLevelVisitor llv = visited.get(ind).getFirst();", "-              SourceFile sf = visited.get(ind).getSecond();", "-              ", "-              //TODO: This is a terrible hack to get around the following problem.  Basically, when we autobox in isAssignableTo in SymbolData, ", "-              //we look through the object hierarchy for the primitive.  If its corresponding boxed object isn't in the symboltable, we're in trouble.", "-              //So, for those special cases, go ahead and make sure the object types are in the symbol table before we start type checking.", "-              //I'd like to make this better, but at least it works for now.", "-              ", "-              ", "-              //Before you type check, make sure that all boxed types of primitives are in the symbol table", "-              if (llv.symbolTable.get(\"java.lang.Integer\") == null) {llv.getSymbolData(\"java.lang.Integer\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Double\")==null) {llv.getSymbolData(\"java.lang.Double\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Character\")==null) {llv.getSymbolData(\"java.lang.Character\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Boolean\")==null) {llv.getSymbolData(\"java.lang.Boolean\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Long\")==null) {llv.getSymbolData(\"java.lang.Long\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Byte\")==null) {llv.getSymbolData(\"java.lang.Byte\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Short\")==null) {llv.getSymbolData(\"java.lang.Short\", JExprParser.NO_SOURCE_INFO);}", "-              if (llv.symbolTable.get(\"java.lang.Float\")==null) {llv.getSymbolData(\"java.lang.Float\", JExprParser.NO_SOURCE_INFO);}", "-              ", "-              ", "-              // Type check.", "-              TypeChecker btc = new TypeChecker(llv._file, llv._package, llv.errors, llv.symbolTable, llv._importedFiles, llv._importedPackages);", "-              sf.visit(btc);", "-              if (btc.errors.size() > 0) {", "-                _visitorErrors.addAll(btc.errors);", "-              }", "-              ", "-              // Add those files to be compiled to the array of files.", "-              if (llv.visitedFiles.size() > 0) {            ", "-                LinkedList<File> newFiles = new LinkedList<File>();", "-                for (int i = 0; i < files.length; i++) {", "-                  newFiles.addLast(files[i]);", "-                }", "-                Iterator<Pair<LanguageLevelVisitor, SourceFile>> iter = llv.visitedFiles.iterator();", "-                while (iter.hasNext()) {", "-                  Pair<LanguageLevelVisitor,SourceFile> currPair = iter.next();", "-                  File fileToAdd = currPair.getFirst()._file;", "-                  // if currSf is not null, then this visitedFile came from visiting the source file, not the class file. ", "-                  // We want to compile this source file; add it to the list of files after creating the mediator entry", "-                  // if necessary.", "-                  SourceFile currSf = currPair.getSecond();", "-                  if (currSf != null) {", "-                    if (newFiles.contains(fileToAdd)) {", "-                      // Messy, but we must make a mediator entry so that code augmentation has all the data it needs", "-                      // since we will skip visiting this file here.  ", "-                      // Can just pass llv since it will contain the correct symbolTable.", "-                      mediator.put(new Integer(newFiles.indexOf(fileToAdd)), new Pair<SourceFile, LanguageLevelVisitor>(currSf, currPair.getFirst())); ", "-                    }", "-                    // Now, if we aren't already compiling this file, and we visited the source, add it to the list of", "-                    // files to be compiled.", "-                    if (!newFiles.contains(fileToAdd) && currSf != null) {", "-                      mediator.put(new Integer(newFiles.size()), new Pair<SourceFile, LanguageLevelVisitor>(currSf, currPair.getFirst()));", "-                      newFiles.addLast(fileToAdd);", "-                    }", "-                    ", "-                  }", "-                  // Also make sure not to re-check these files whether we visited source or class file. ", "-                  // We only want to perform code augmentation since these files have already been visited.", "-                  if (!filesNotToCheck.contains(fileToAdd)) {", "-                    filesNotToCheck.addLast(fileToAdd);", "-                  }", "-                }", "-                files = newFiles.toArray(new File[newFiles.size()]);", "-              }", "-              ", "-              mediator.put(new Integer(ind), new Pair<SourceFile, LanguageLevelVisitor>(sf, llv));", "-            }", "-          }", "+//        mediator.put(new Integer(ind), new Pair<SourceFile, LanguageLevelVisitor>(sf, llv));", "+//      }", "+//  }", "-    ", "+//    Utilities.show(\"Processed LL files: \" + Arrays.toString(files));", "+//    Utilities.show(\"mediator is: \" + mediator);", "+      File f = files[ind];", "-        BufferedReader tempBr = new BufferedReader(new FileReader(files[ind]));", "+//        Utilities.show(\"File is: \" + f + \" mediator is: \" + mediator.get(ind));", "+        BufferedReader tempBr = new BufferedReader(new FileReader(f));", "-        if (firstLine == null) {", "-          continue;", "-        }", "-", "-        // If the file has the correct beginner tag at the beginning, then parse it.", "-        // It should not end in .beginner since that's just a temporary copy which gets", "-        // deleted after the compile.", "-        if (_isLanguageLevelFile(files[ind])) {", "+        if (firstLine == null) continue;", "+        ", "+        // If the file has an appropriate LL extension, then parse it.", "+        if (_isLanguageLevelFile(f)) {", "+          if (pair == null) {", "+            _log.log(\"Not augmenting \" + f + \" no mediator\");", "+//            Utilities.show(\"Not augmenting \" + f + \" no mediator\");", "+          }", "+          ", "-            File f = files[ind];", "+//            File f = files[ind];", "-//            _log.log(\"Augmenting the source file \" + sf);", "+            _log.log(\"Augmenting the source file \" + sf);", "+//            Utilities.show(\"Augmenting the source file \" + sf.getSourceInfo().getFile());", "-                                                                                       _visitorErrors);", "+                                                                                              _visitorErrors);"]}], "num": 8133}