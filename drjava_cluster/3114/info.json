{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "844e8bef676a98cfeb28cfdd538f55c5", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2d5e553744dfdc5d8889e3d1baae4397", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/JDKToolsLibrary.java", "commitBeforeChange": "06c097879b27ffb8ca08a54a4961265ba5907f07", "commitAfterChange": "cb297201cc08624c537abfd29974e65bdfd2f397", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "   public static JDKToolsLibrary makeFromRuntime(GlobalModel model)", "signatureAfterChange": "\r   public static JDKToolsLibrary makeFromRuntime(GlobalModel model)", "diff": ["-   */", "-  public static JDKToolsLibrary makeFromRuntime(GlobalModel model) {", "-    FullVersion version = JavaVersion.CURRENT_FULL;", "-", "-    CompilerInterface compiler = NoCompilerAvailable.ONLY;", "-    String compilerAdapter = adapterForCompiler(version.majorVersion());", "-    if (compilerAdapter != null) {", "-      List<File> bootClassPath = null;", "-      String bootProp = System.getProperty(\"sun.boot.class.path\");", "-      if (bootProp != null) { bootClassPath = CollectUtil.makeList(IOUtil.parsePath(bootProp)); }", "-      try {", "-        Class<?>[] sig = { FullVersion.class, String.class, List.class };", "-        Object[] args = { version, \"the runtime class path\", bootClassPath };", "-        CompilerInterface attempt = (CompilerInterface) ReflectUtil.loadObject(compilerAdapter, sig, args);", "-        if (attempt.isAvailable()) { compiler = attempt; }", "-      }", "-      catch (ReflectException e) { /* can't load */ }", "-      catch (LinkageError e) { /* can't load */ }", "-    }", "-    ", "-    Debugger debugger = NoDebuggerAvailable.ONLY;", "-    String debuggerAdapter = adapterForDebugger(version.majorVersion());", "-    if (debuggerAdapter != null) {", "-      try {", "-        Debugger attempt = (Debugger) ReflectUtil.loadObject(debuggerAdapter, new Class<?>[]{GlobalModel.class}, model);", "-        if (attempt.isAvailable()) { debugger = attempt; }", "-      }", "-      catch (ReflectException e) { /* can't load */ }", "-      catch (LinkageError e) { /* can't load */ }", "-    }", "-    ", "-    JavadocModel javadoc = new NoJavadocAvailable(model);", "-    try {", "-      Class.forName(\"com.sun.tools.javadoc.Main\");", "-      javadoc = new DefaultJavadocModel(model, null, ReflectUtil.SYSTEM_CLASS_PATH);", "-    }", "-    catch (ClassNotFoundException e) { /* can't load */ }", "-    catch (LinkageError e) { /* can't load (probably not necessary, but might as well catch it) */ }", "-    ", "-    return new JDKToolsLibrary(version, compiler, debugger, javadoc);", "-  }", "+   */\r", "+  public static JDKToolsLibrary makeFromRuntime(GlobalModel model) {\r", "+    FullVersion version = JavaVersion.CURRENT_FULL;\r", "+\r", "+    CompilerInterface compiler = NoCompilerAvailable.ONLY;\r", "+    String compilerAdapter = adapterForCompiler(version);\r", "+    if (compilerAdapter != null) {\r", "+      List<File> bootClassPath = null;\r", "+      String bootProp = System.getProperty(\"sun.boot.class.path\");\r", "+      if (bootProp != null) { bootClassPath = CollectUtil.makeList(IOUtil.parsePath(bootProp)); }\r", "+      try {\r", "+        Class<?>[] sig = { FullVersion.class, String.class, List.class };\r", "+        Object[] args = { version, \"the runtime class path\", bootClassPath };\r", "+        CompilerInterface attempt = (CompilerInterface) ReflectUtil.loadObject(compilerAdapter, sig, args);\r", "+        if (attempt.isAvailable()) { compiler = attempt; }\r", "+      }\r", "+      catch (ReflectException e) { /* can't load */ }\r", "+      catch (LinkageError e) { /* can't load */ }\r", "+    }\r", "+    \r", "+    Debugger debugger = NoDebuggerAvailable.ONLY;\r", "+    String debuggerAdapter = adapterForDebugger(version);\r", "+    if (debuggerAdapter != null) {\r", "+      try {\r", "+        Debugger attempt = (Debugger) ReflectUtil.loadObject(debuggerAdapter, new Class<?>[]{GlobalModel.class}, model);\r", "+        if (attempt.isAvailable()) { debugger = attempt; }\r", "+      }\r", "+      catch (ReflectException e) { /* can't load */ }\r", "+      catch (LinkageError e) { /* can't load */ }\r", "+    }\r", "+    \r", "+    JavadocModel javadoc = new NoJavadocAvailable(model);\r", "+    try {\r", "+      Class.forName(\"com.sun.tools.javadoc.Main\");\r", "+      javadoc = new DefaultJavadocModel(model, null, ReflectUtil.SYSTEM_CLASS_PATH);\r", "+    }\r", "+    catch (ClassNotFoundException e) { /* can't load */ }\r", "+    catch (LinkageError e) { /* can't load (probably not necessary, but might as well catch it) */ }\r", "+    \r", "+    return new JDKToolsLibrary(version, compiler, debugger, javadoc);\r", "+  }\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da82d5612e0a6fe320d388b828473672", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/JarJDKToolsLibrary.java", "commitBeforeChange": "06c097879b27ffb8ca08a54a4961265ba5907f07", "commitAfterChange": "cb297201cc08624c537abfd29974e65bdfd2f397", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model)", "signatureAfterChange": "\r   public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model)", "diff": ["-  /** Create a JarJDKToolsLibrary from a specific {@code \"tools.jar\"} or {@code \"classes.jar\"} file. */", "-  public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model) {", "-    FullVersion version = guessVersion(f);", "-    CompilerInterface compiler = NoCompilerAvailable.ONLY;", "-    Debugger debugger = NoDebuggerAvailable.ONLY;", "-    JavadocModel javadoc = new NoJavadocAvailable(model);", "-    ", "-    // We can't execute code that was possibly compiled for a later Java API version.", "-    if (JavaVersion.CURRENT.supports(version.majorVersion())) {", "-      // block tools.jar classes, so that references don't point to a different version of the classes", "-      ClassLoader loader =", "-        new ShadowingClassLoader(JarJDKToolsLibrary.class.getClassLoader(), true, TOOLS_PACKAGES, true);", "-      Iterable<File> path = IterUtil.singleton(IOUtil.attemptAbsoluteFile(f));", "-      ", "-      String compilerAdapter = adapterForCompiler(version.majorVersion());", "-      if (compilerAdapter != null) {", "-        ", "-        // determine boot class path", "-        File libDir = null;", "-        if (f.getName().equals(\"classes.jar\")) { libDir = f.getParentFile(); }", "-        else if (f.getName().equals(\"tools.jar\")) {", "-          File jdkLibDir = f.getParentFile();", "-          if (jdkLibDir != null) {", "-            File jdkRoot = jdkLibDir.getParentFile();", "-            if (jdkRoot != null) {", "-              File jreLibDir = new File(jdkRoot, \"jre/lib\");", "-              if (IOUtil.attemptExists(new File(jreLibDir, \"rt.jar\"))) { libDir = jreLibDir; }", "-            }", "-            if (libDir == null) {", "-              if (IOUtil.attemptExists(new File(jdkLibDir, \"rt.jar\"))) { libDir = jdkLibDir; }", "-            }", "-          }", "-        }", "-        List<File> bootClassPath = null; // null defers to the compiler's default behavior", "-        if (libDir != null) {", "-          File[] jars = IOUtil.attemptListFiles(libDir, IOUtil.extensionFilePredicate(\"jar\"));", "-          if (jars != null) { bootClassPath = Arrays.asList(jars); }", "-        }", "-", "-        try {", "-          Class<?>[] sig = { FullVersion.class, String.class, List.class };", "-          Object[] args = { version, f.toString(), bootClassPath };", "-          CompilerInterface attempt = (CompilerInterface) ReflectUtil.loadLibraryAdapter(loader, path, compilerAdapter, ", "-                                                                                         sig, args);", "-          if (attempt.isAvailable()) { compiler = attempt; }", "-        }", "-        catch (ReflectException e) { /* can't load */ }", "-        catch (LinkageError e) { /* can't load */ }", "-      }", "-      ", "-      String debuggerAdapter = adapterForDebugger(version.majorVersion());", "-      String debuggerPackage = \"edu.rice.cs.drjava.model.debug.jpda\";", "-      if (debuggerAdapter != null) {", "-        try {", "-          Class<?>[] sig = { GlobalModel.class };", "-          // can't use loadLibraryAdapter because we need to preempt the whole package", "-          ClassLoader debugLoader = new PreemptingClassLoader(new PathClassLoader(loader, path), debuggerPackage);", "-          Debugger attempt = (Debugger) ReflectUtil.loadObject(debugLoader, debuggerAdapter, sig, model);        ", "-          if (attempt.isAvailable()) { debugger = attempt; }", "-        }", "-        catch (ReflectException e) { /* can't load */ }", "-        catch (LinkageError e) { /* can't load */ }", "-      }", "-      ", "-      try {", "-        new PathClassLoader(loader, path).loadClass(\"com.sun.tools.javadoc.Main\");", "-        File bin = new File(f.getParentFile(), \"../bin\");", "-        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(f.getParentFile(), \"../Home/bin\"); }", "-        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(System.getProperty(\"java.home\", f.getParent())); }", "-        javadoc = new DefaultJavadocModel(model, bin, path);", "-      }", "-      catch (ClassNotFoundException e) { /* can't load */ }", "-      catch (LinkageError e) { /* can't load (probably not necessary, but might as well catch it) */ }", "-        ", "-    }", "-    ", "-    return new JarJDKToolsLibrary(f, version, compiler, debugger, javadoc);", "-  }", "+  /** Create a JarJDKToolsLibrary from a specific {@code \"tools.jar\"} or {@code \"classes.jar\"} file. */\r", "+  public static JarJDKToolsLibrary makeFromFile(File f, GlobalModel model) {\r", "+    FullVersion version = guessVersion(f);\r", "+    CompilerInterface compiler = NoCompilerAvailable.ONLY;\r", "+    Debugger debugger = NoDebuggerAvailable.ONLY;\r", "+    JavadocModel javadoc = new NoJavadocAvailable(model);\r", "+    \r", "+    // We can't execute code that was possibly compiled for a later Java API version.\r", "+    if (JavaVersion.CURRENT.supports(version.majorVersion())) {\r", "+      // block tools.jar classes, so that references don't point to a different version of the classes\r", "+      ClassLoader loader =\r", "+        new ShadowingClassLoader(JarJDKToolsLibrary.class.getClassLoader(), true, TOOLS_PACKAGES, true);\r", "+      Iterable<File> path = IterUtil.singleton(IOUtil.attemptAbsoluteFile(f));\r", "+      \r", "+      String compilerAdapter = adapterForCompiler(version);\r", "+      if (compilerAdapter != null) {\r", "+        \r", "+        // determine boot class path\r", "+        File libDir = null;\r", "+        if (f.getName().equals(\"classes.jar\")) { libDir = f.getParentFile(); }\r", "+        else if (f.getName().equals(\"tools.jar\")) {\r", "+          File jdkLibDir = f.getParentFile();\r", "+          if (jdkLibDir != null) {\r", "+            File jdkRoot = jdkLibDir.getParentFile();\r", "+            if (jdkRoot != null) {\r", "+              File jreLibDir = new File(jdkRoot, \"jre/lib\");\r", "+              if (IOUtil.attemptExists(new File(jreLibDir, \"rt.jar\"))) { libDir = jreLibDir; }\r", "+            }\r", "+            if (libDir == null) {\r", "+              if (IOUtil.attemptExists(new File(jdkLibDir, \"rt.jar\"))) { libDir = jdkLibDir; }\r", "+            }\r", "+          }\r", "+        }\r", "+        List<File> bootClassPath = null; // null defers to the compiler's default behavior\r", "+        if (libDir != null) {\r", "+          File[] jars = IOUtil.attemptListFiles(libDir, IOUtil.extensionFilePredicate(\"jar\"));\r", "+          if (jars != null) { bootClassPath = Arrays.asList(jars); }\r", "+        }\r", "+\r", "+        try {\r", "+          Class<?>[] sig = { FullVersion.class, String.class, List.class };\r", "+          Object[] args = { version, f.toString(), bootClassPath };\r", "+          CompilerInterface attempt = (CompilerInterface) ReflectUtil.loadLibraryAdapter(loader, path, compilerAdapter, \r", "+                                                                                         sig, args);\r", "+          if (attempt.isAvailable()) { compiler = attempt; }\r", "+        }\r", "+        catch (ReflectException e) { /* can't load */ }\r", "+        catch (LinkageError e) { /* can't load */ }\r", "+      }\r", "+      \r", "+      String debuggerAdapter = adapterForDebugger(version);\r", "+      String debuggerPackage = \"edu.rice.cs.drjava.model.debug.jpda\";\r", "+      if (debuggerAdapter != null) {\r", "+        try {\r", "+          Class<?>[] sig = { GlobalModel.class };\r", "+          // can't use loadLibraryAdapter because we need to preempt the whole package\r", "+          ClassLoader debugLoader = new PreemptingClassLoader(new PathClassLoader(loader, path), debuggerPackage);\r", "+          Debugger attempt = (Debugger) ReflectUtil.loadObject(debugLoader, debuggerAdapter, sig, model);        \r", "+          if (attempt.isAvailable()) { debugger = attempt; }\r", "+        }\r", "+        catch (ReflectException e) { /* can't load */ }\r", "+        catch (LinkageError e) { /* can't load */ }\r", "+      }\r", "+      \r", "+      try {\r", "+        new PathClassLoader(loader, path).loadClass(\"com.sun.tools.javadoc.Main\");\r", "+        File bin = new File(f.getParentFile(), \"../bin\");\r", "+        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(f.getParentFile(), \"../Home/bin\"); }\r", "+        if (!IOUtil.attemptIsDirectory(bin)) { bin = new File(System.getProperty(\"java.home\", f.getParent())); }\r", "+        javadoc = new DefaultJavadocModel(model, bin, path);\r", "+      }\r", "+      catch (ClassNotFoundException e) { /* can't load */ }\r", "+      catch (LinkageError e) { /* can't load (probably not necessary, but might as well catch it) */ }\r", "+        \r", "+    }\r", "+    \r", "+    return new JarJDKToolsLibrary(f, version, compiler, debugger, javadoc);\r", "+  }\r"]}], "num": 3114}