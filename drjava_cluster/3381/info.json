{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bd54129ab7d7d5797470a6abe397cfcb", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0e6b945430757e2f72b4b886c8a8c193", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": "   public TypeData forSimpleAnonymousClassInstantiation(SimpleAnonymousClassInstantiation that)", "signatureAfterChange": "   public TypeData forSimpleAnonymousClassInstantiation(SimpleAnonymousClassInstantiation that)", "diff": ["-    if (_data.isDoublyAnonymous()) {", "-      _addError(_data + \"is a nested anonymous class, which is not supported at any language level\", that);", "+    /* Note: _data should be the enclosing class. */", "+//    System.err.println(\"******** Type-checking the anonymous class \" + that);", "+//    if (! (_data instanceof SymbolData) )", "+//      System.err.println(\"********* Type-checking following anon class blows up \" + that);", "+//                                     ", "+//    assert _data instanceof SymbolData;", "+    ", "+    SymbolData enclosing = _data.getSymbolData();  // grabs the enclosing class if _data not already a SymbolData", "+    ", "+    if (enclosing.isDoublyAnonymous()) {", "+      _addError(enclosing + \"is a nested anonymous class, which is not supported at any language level\", that);", "-    ", "-    final SymbolData superclass_result = getSymbolData(that.getType().getName(), _data, that); // resolve super class", "-    ", "+    System.err.println(\"***** forSACInst called for anon class in \" + enclosing);", "+    final SymbolData superClass = getSymbolData(that.getType().getName(), enclosing, that); // resolve super class", "+    System.err.println(\"**** SuperClass symbol is \" + superClass);", "-    SymbolData myData = handleAnonymousClassInstantiation(that, superclass_result);", "+    SymbolData myData = handleAnonymousClassInstantiation(that, enclosing /*.getEnclosingClass() */);", "+    System.err.println(\"This anonymous class's symbol is: \" + myData);", "-    int lastIndexOfDot = name.lastIndexOf(\".\");", "-    if (!superclass_result.hasModifier(\"static\") && !superclass_result.isInterface() && ", "-        (superclass_result.getOuterData() != null) && lastIndexOfDot != -1) {", "+    int lastIndexOfDot = name.lastIndexOf('.');", "+    if (!superClass.hasModifier(\"static\") && !superClass.isInterface() && ", "+        (superClass.getOuterData() != null) && lastIndexOfDot != -1) {", "-      _addError(Data.dollarSignsToDots(superclass_result.getName()) + ", "+      _addError(Data.dollarSignsToDots(superClass.getName()) + ", "-    //if superclass_result is an interface, then the constructor that should be used is Object--i.e. no arguments", "-    if (superclass_result.isInterface()) {", "+    //if superClass is an interface, then the constructor that should be used is Object--i.e. no arguments", "+    if (superClass.isInterface()) {", "-    else classInstantiationHelper(that, superclass_result); //use super class here, since it has constructors in it", "+    else classInstantiationHelper(that, superClass); //use super class here, since it has constructors in it"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e7a46863d7debc908e179c08718016e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "   public TypeData forComplexAnonymousClassInstantiation(ComplexAnonymousClassInstantiation that)", "signatureAfterChange": "   public TypeData forComplexAnonymousClassInstantiation(ComplexAnonymousClassInstantiation that)", "diff": ["+    /* Note: _data should be the enclosing class. */", "+//    System.err.println(\"******** Type-checking the anonymous class \" + that);", "+//    if (! (_data instanceof SymbolData) )", "+//      System.err.println(\"********* Type-checking following anon class blows up \" + that);", "+//                                     ", "+//    assert _data instanceof SymbolData;", "+    ", "+   ", "-    TypeData enclosingType = that.getEnclosing().visit(this);", "+    ", "+    SymbolData lexEnclosing = _data.getSymbolData();  // grabs the enclosing class if _data not already a SymbolData", "+    ", "+    Expression receiver = that.getEnclosing();", "+    ", "+    // Get the enclosing type as specified by the \"receiver\" expression.", "+    TypeData enclosingType = receiver.visit(this);", "+    ", "-    //make sure we can see enclosingType", "-    checkAccessibility(that, enclosingType.getSymbolData().getMav(), enclosingType.getSymbolData().getName(), ", "-                       enclosingType.getSymbolData(), _data.getSymbolData(), \"class or interface\", true);", "+    SymbolData enclosing = enclosingType.getSymbolData();", "-    final SymbolData superclass_result = getSymbolData(that.getType().getName(), enclosingType.getSymbolData(), ", "-                                                       that.getType());", "+    // Make sure we can see enclosing SymbolData from within lexEnclosing", "+    checkAccessibility(that, enclosing.getMav(), enclosing.getName(), enclosing, lexEnclosing, \"class or interface\", true);", "+    final SymbolData superClass = getSymbolData(that.getType().getName(), enclosing, that.getType());", "-    ", "-    // Get this anonymous inner class's SymbolData", "-    SymbolData myData = handleAnonymousClassInstantiation(that, superclass_result);", "+    // Get this anonymous inner class's SymbolData; passing lexEnclosing is a hack.  It almost certainly should be", "+    // enclosing, but the LLV processing contains the same error.  We need to be consistent.", "+    SymbolData myData = handleAnonymousClassInstantiation(that, lexEnclosing);  // TODO: the wrong enclosing context?", "-    if (superclass_result.isInterface()) {", "+    if (superClass.isInterface()) {", "-    else { //superclass_result is an interface...need to do some extra checking for static types.", "-      InstanceData result = classInstantiationHelper(that, superclass_result); //use super class here, since it has constructors in it", "-      if (result == null) {return null;}", "+    else { // superClass is an interface...need to do some extra checking for static types.", "+      InstanceData result = classInstantiationHelper(that, superClass); //use super class here, since it has constructors in it", "+      if (result == null) return null;", "-                Data.dollarSignsToDots(superclass_result.getName()) + \"()\", that);", "+                Data.dollarSignsToDots(superClass.getName()) + \"()\", that);"]}], "num": 3381}