{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "59a6ba8be8f7ae31e918ab30cd5661c7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5d8b73a3c3a29d7c062a3b03607d871e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ConstructorBodyTypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "   public TypeData forBracedBody(BracedBody that)", "signatureAfterChange": "   public TypeData forBracedBody(BracedBody that)", "diff": ["-   */", "+    */", "+//    System.err.println(\"forBracedBody called in \" + _data.getSymbolData() + \" for \" + that);", "-    if (startIndex == 0) {", "-      implicitSuperConstructor(that);", "-    }", "+    if (startIndex == 0) implicitSuperConstructor(that);", "-    for (int j = 0; j<this._thrown.size(); j++) {", "-      if (isUncaughtCheckedException(this._thrown.get(j).getFirst(), that)) {", "-        handleUncheckedException(this._thrown.get(j).getFirst(), this._thrown.get(j).getSecond());", "+    int thrownSize = _thrown.size();", "+    System.err.println(\"_thrown.size() in \" + _data + \" = \" + thrownSize);", "+    for (int j = 0; j < thrownSize; j++) {", "+      if (isUncaughtCheckedException(_thrown.get(j).getFirst(), that)) {", "+        handleUncheckedException(_thrown.get(j).getFirst(), _thrown.get(j).getSecond());", "-      ", "+    /** The following is supposed to be equivalent to calling SpecialTypeChecker.forBody(that, items_result) */", "-      //walk over what has been thrown and throw an error if it contains an unchecked exception", "-      for (int j = 0; j<this._thrown.size(); j++) {", "-        if (isUncaughtCheckedException(this._thrown.get(j).getFirst(), that)) {", "-          handleUncheckedException(this._thrown.get(j).getFirst(), this._thrown.get(j).getSecond());", "+      // Walk over what has been thrown and throw an error if it contains an unchecked exception", "+      for (int j = thrownSize; j < _thrown.size(); j++) {", "+        if (isUncaughtCheckedException(_thrown.get(j).getFirst(), that)) {", "+          handleUncheckedException(_thrown.get(j).getFirst(), _thrown.get(j).getSecond());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "67b761fdac1c5966e0b80f8019071ee8", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/LanguageLevelVisitor.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 47, "signatureBeforeChange": "   protected SymbolData getSymbolDataForClassFile(String className, SourceInfo si)", "signatureAfterChange": "   private SymbolData _identifyType(String name, SourceInfo si, String enclosingClassName)", "diff": ["-    */", "-  protected SymbolData getSymbolDataForClassFile(String className, SourceInfo si) {", "-    SymbolData sd = getSymbolDataHelper(className, si, true, true, true, false);", "-    ", "-    if (sd == null) {", "-      // This is an error in the user's class file so throw an error.", "-      // The NullLiteral is a hack to get a JExpression with the correct SourceInfo inside.", "-      _addAndIgnoreError(\"Class \" + className + \" not found.\", new NullLiteral(si));", "-      return null;", "-    }", "-    sd.setIsContinuation(false);", "-    ", "-    continuations.remove(sd.getName());", "-    return sd;", "-  }", "+    * datas.  We need to use the relative inner class name to do this. */", "+  private SymbolData _identifyType(String name, SourceInfo si, String enclosingClassName) {", "+    System.err.println(\"Calling _identifyType(\" + name  + \") within \" + enclosingClassName);", "+    SymbolData sd = getSymbolData(name, si);  // TODO: uses wrong enclosingClassName!!!", "+    if (sd != null) return sd;", "+    SymbolData enclosingSD = getQualifiedSymbolData(enclosingClassName, SourceInfo.NO_INFO);", "+    if (enclosingSD == null) {", "+      System.err.println(\"***ERROR*** in _identifyType \" + enclosingClassName + \" NOT FOUND\");", "+      return null;  // should only happen in tests", "+    sd = enclosingSD.getInnerClassOrInterface(name);", "+     ", "+    if (sd != null) return sd;", "+//    ", "+//    // Create continuation for new type", "+//    String qualifiedTypeName = enclosingClassName + '.' + name;", "+//    if (_innerClassesInThisBody.contains(qualifiedTypeName)) {  ", "+//      // reference to an inner class that will subsequently be defined", "+//      sd = addInnerSymbolData(si, qualifiedTypeName, enclosingSD);", "+//    }", "+    ", "+    return sd;  // Note: sd is null if name is not identified."]}], "num": 8423}