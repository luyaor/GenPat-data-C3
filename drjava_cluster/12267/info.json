{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a8f69e4e46f90fbfc4998dacab6fbce3", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "38d977b9d18512316b125ab759951680", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Bob.java", "commitBeforeChange": "fda8ed09ab1fd83aa0718b8a14f03f9745835af9", "commitAfterChange": "f82cbb172a00c2d57ed2feb202b1bece43cc7ef2", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": "          public void testForInitializedVariableDeclaratorOnly()", "signatureAfterChange": "          public void testForInitializedVariableDeclaratorOnly()", "diff": ["-      InitializedVariableDeclarator ivd = new InitializedVariableDeclarator(JExprParser.NO_SOURCE_INFO,", "-                                                                            JExprParser.NO_TYPE,", "-                                                                            new Word(JExprParser.NO_SOURCE_INFO, \"j\"),", "-                                                                            new DoubleLiteral(JExprParser.NO_SOURCE_INFO, 1.0));", "+      InitializedVariableDeclarator ivd = ", "+        new InitializedVariableDeclarator(SourceInfo.NO_INFO,", "+                                          JExprParser.NO_TYPE,", "+                                          new Word(SourceInfo.NO_INFO, \"j\"),", "+                                          new DoubleLiteral(SourceInfo.NO_INFO, 1.0));", "-      assertEquals(\"Two assignable types should not throw an error; return null.\", null, _b.forInitializedVariableDeclaratorOnly(ivd, sd1, sd1, sd3.getInstanceData()));", "+      assertEquals(\"Two assignable types should not throw an error; return null.\", null, ", "+                   _b.forInitializedVariableDeclaratorOnly(ivd, sd1, sd1, sd3.getInstanceData()));", "-      assertEquals(\"Two unassignable types should throw an error; return null.\", null, _b.forInitializedVariableDeclaratorOnly(ivd, sd1, sd1, sd2.getInstanceData()));", "+      assertEquals(\"Two unassignable types should throw an error; return null.\", null, ", "+                   _b.forInitializedVariableDeclaratorOnly(ivd, sd1, sd1, sd2.getInstanceData()));", "-      assertEquals(\"Error message should be correct:\", \"Type: \\\"double\\\" expected, instead found type: \\\"boolean\\\".\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct:\", \"Type: \\\"double\\\" expected, instead found type: \\\"boolean\\\".\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"An initialization from a SymbolData should return null\", null, _b.forInitializedVariableDeclaratorOnly(ivd, sd1, null, foo));", "+      assertEquals(\"An initialization from a SymbolData should return null\", null, ", "+                   _b.forInitializedVariableDeclaratorOnly(ivd, sd1, null, foo));", "-      assertEquals(\"Error message should be correct:\", \"Field or variable j cannot be initialized with the class or interface name Foo.  Perhaps you meant to create an instance or use Foo.class\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct:\", ", "+                   \"Field or variable j cannot be initialized with the class or interface name Foo.  \" + ", "+                   \"Perhaps you meant to create an instance or use Foo.class\", errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "67842f6be883aa3b88b4dbc3f8cd4bbb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "dd97c2983de18f5d46f596ce3c536a3b581f0ec4", "commitAfterChange": "e5b59097570657040bcd74f7a31c6db7f03359ce", "methodNumberBeforeChange": 113, "methodNumberAfterChange": 113, "signatureBeforeChange": "         public void testForInstanceOfExpressionOnly()", "signatureAfterChange": "            public void testForInstanceOfExpressionOnly()", "diff": ["-", "-    public void testForInstanceOfExpressionOnly() {", "-      InstanceofExpression ioe = new InstanceofExpression(SourceInfo.NO_INFO, ", "-                                                          new BooleanLiteral(SourceInfo.NO_INFO, true),", "-                                                          new PrimitiveType(SourceInfo.NO_INFO, \"int\"));", "-      try {", "-        _etc.forInstanceofExpressionOnly(ioe, SymbolData.BOOLEAN_TYPE.getInstanceData(), SymbolData.INT_TYPE.getInstanceData());", "-        fail(\"Should have thrown an exception.\");", "-      }", "-      catch (Exception e) {", "-        assertEquals(\"Exception message should be correct\", \"Internal Program Error: instanceof is not currently supported.  This should have been caught before the Type Checker.  Please report this bug.\", e.getMessage());", "-        ", "-      }", "-    }", "+    public void testForInstanceOfExpressionOnly() {", "+      SymbolData sd1 = SymbolData.DOUBLE_TYPE;", "+      SymbolData sd2 = SymbolData.BOOLEAN_TYPE;", "+      SymbolData sd3 = SymbolData.INT_TYPE;", "+      InstanceofExpression ioe = new InstanceofExpression(SourceInfo.NO_INFO,          ", "+                                                          new NullLiteral(SourceInfo.NO_INFO),", "+                                                          JExprParser.NO_TYPE);  // Object type", "+      ", "+      assertEquals(\"When value_result is subtype of type_result, return BOOLEAN type_result.\", sd2.getInstanceData(), ", "+                   _etc.forInstanceofExpressionOnly(ioe, sd1, sd3.getInstanceData()));", "+      assertEquals(\"Should not throw an error.\", 0, errors.size());", "+      assertEquals(\"When type_result is subtype of value_result, return BOOLEAN type_result.\", sd2.getInstanceData(), ", "+                   _etc.forInstanceofExpressionOnly(ioe, sd3, sd1.getInstanceData()));", "+      assertEquals(\"Should not throw an error.\", 0, errors.size());", "+      assertEquals(\"When type_result and value_result are not subtypes of each other, return BOOLEAN type_result\", ", "+                   sd2.getInstanceData(),", "+                   _etc.forInstanceofExpressionOnly(ioe, sd2, sd1.getInstanceData()));", "+      assertEquals(\"Should now be one error.\", 1, errors.size());", "+      assertEquals(\"Error message should be correct.\", \"You cannot test whether an expression of type \" + sd1.getName() ", "+                     + \" belongs to type \" + sd2.getName() + \" because they are not related\", ", "+                   errors.getLast().getFirst());     ", "+      SymbolData foo = new SymbolData(\"Foo\");", "+      SymbolData fooMama = new SymbolData(\"FooMama\");", "+      foo.setSuperClass(fooMama);", "+      assertEquals(\"When value_result is a SymbolData, return BOOLEAN type_result\",  sd2.getInstanceData(), ", "+                   _etc.forInstanceofExpressionOnly(ioe, foo, fooMama));", "+      assertEquals(\"There should be 2 errors.\", 2, errors.size());", "+      assertEquals(\"Error message should be correct.\", ", "+                   \"You are trying to test if FooMama belongs to type, but it is a class or interface type, \"", "+                     + \"not an instance.  Perhaps you meant to create a new instance of FooMama\",", "+                   errors.getLast().getFirst());", "+    }"]}], "num": 12267}