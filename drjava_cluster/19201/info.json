{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d74a35c80bbbda931e4473fdd977a01e", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "18a4745f931aea19b50543aad3443c5d", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/InteractionsPane.java", "commitBeforeChange": "3bfda0ffd8a22eda2f2daab913b510305e1ef801", "commitAfterChange": "02d5c825c13aaa4caad6b7e4e89ccbdbfdc16c9f", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": "   public void processKeyEvent(KeyEvent e)", "signatureAfterChange": "   public void processKeyEvent(KeyEvent e)", "diff": ["-  public void processKeyEvent(KeyEvent e) { super.processKeyEvent(e); }", "+  public void processKeyEvent(KeyEvent e) { ", "+    ", "+    //Fixes bug ID:2898576 - Backspace undo/redo issues", "+    if(e.getKeyCode() == KeyEvent.VK_BACK_SPACE && deleteCEBool){", "+      endCompoundEdit(); ", "+      deleteCEBool=false;", "+    }", "+    else if(e.getID()==KeyEvent.KEY_PRESSED && e.getKeyCode() != KeyEvent.VK_BACK_SPACE){", "+      deleteCEBool = true;", "+    }", "+    ", "+    KeyStroke ks = KeyStroke.getKeyStrokeForEvent(e);", "+    Action a = KeyBindingManager.ONLY.get(ks);", "+    // Don't perform the action if the keystroke is NULL_KEYSTROKE (generated by some Windows keys)", "+    if ((ks != KeyStrokeOption.NULL_KEYSTROKE) && (a != null)) {", "+      endCompoundEdit();", "+    }", "+    ", "+    if ((e.getModifiers() & e.SHIFT_MASK)!=0 && e.getKeyCode()==KeyEvent.VK_ENTER) endCompoundEdit();  //ends compound edit on line change", "+    ", "+    super.processKeyEvent(e);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "65db467c31d0c922631adbbe5d3847d7", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/DefinitionsPane.java", "commitBeforeChange": "7e9ff3bb619e0dc2b4141d09cbd325f980ff3ee5", "commitAfterChange": "8004e8339d9ea14156f225b11f26f546f17ae259", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "   public void processKeyEvent(KeyEvent e)", "signatureAfterChange": "   public void processKeyEvent(KeyEvent e)", "diff": ["+      // Performs the action a", "-    else {    ", "+    else {", "-      if (((e.getModifiers() & InputEvent.META_MASK) != 0) && e.getKeyCode() == KeyEvent.VK_UNDEFINED){", "-\treturn;", "+      if (((e.getModifiers() & InputEvent.META_MASK) != 0) && e.getKeyCode() == KeyEvent.VK_UNDEFINED) {", "+        return;", "+      }", "+      ", "+      // The following conditional fixes ease of use issue 693253 by checking if a typed event is ", "+      // shift-delete or shift-backspace and then performing a delete or backspace operation, ", "+      // respectively", "+      if ((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) {", "+        int newModifiers = e.getModifiers() & ~(InputEvent.SHIFT_MASK);", "+        ", "+        KeyStroke newKs = KeyStroke.getKeyStroke(ks.getKeyCode(), newModifiers, ks.isOnKeyRelease());", "+        String name = KeyBindingManager.Singleton.getName(newKs);", "+", "+        if (name != null && (name.equals(\"Delete Previous\") || name.equals(\"Delete Next\"))) {", "+          // We are unsure about the third and fourth arguments (e and e.getSource()); we simply ", "+          // reuse the original values", "+          SwingUtilities.notifyAction(KeyBindingManager.Singleton.get(newKs), newKs, e, e.getSource(), newModifiers);", "+          e.consume();", "+          return;", "+        }", "-\tsuper.processKeyEvent(e);       ", "+        super.processKeyEvent(e);       "]}], "num": 19201}