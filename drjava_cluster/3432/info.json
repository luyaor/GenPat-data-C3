{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a30727856b184f81e523b97bdd2a9a2a", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "41f06b690f957202966c7f1a77e292cf", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 116, "methodNumberAfterChange": 116, "signatureBeforeChange": "          public void testForComplexNamedClassInstantiation()", "signatureAfterChange": "          public void testForComplexNamedClassInstantiation()", "diff": ["+      ParenthesizedExpressionList pel1 = ", "+        new ParenthesizedExpressionList(SourceInfo.NONE, new Expression[] { new IntegerLiteral(SourceInfo.NONE, 5)});", "-        new ComplexNamedClassInstantiation(SourceInfo.NO_INFO, ", "-                                           new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"o\")), ", "-                                           new ClassOrInterfaceType(SourceInfo.NO_INFO, \"innerClass\", new Type[0]),                                  ", "-                                           new ParenthesizedExpressionList(SourceInfo.NO_INFO, ", "-                                                                           new Expression[] { new IntegerLiteral(SourceInfo.NO_INFO, 5)}));", "+        new ComplexNamedClassInstantiation(SourceInfo.NONE, ", "+                                           new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"o\")), ", "+                                           new ClassOrInterfaceType(SourceInfo.NONE, \"innerClass\", new Type[0]),                                  ", "+                                           pel1);", "-        new ComplexNamedClassInstantiation(SourceInfo.NO_INFO, ", "-                                           new SimpleNameReference(SourceInfo.NO_INFO, ", "-                                                                   new Word(SourceInfo.NO_INFO, \"o\")), ", "-                                           new ClassOrInterfaceType(SourceInfo.NO_INFO, \"innerClass\", new Type[0]), ", "-                                           new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]));", "+        new ComplexNamedClassInstantiation(SourceInfo.NONE, ", "+                                           new SimpleNameReference(SourceInfo.NONE, ", "+                                                                   new Word(SourceInfo.NONE, \"o\")), ", "+                                           new ClassOrInterfaceType(SourceInfo.NONE, \"innerClass\", new Type[0]), ", "+                                           new ParenthesizedExpressionList(SourceInfo.NONE, new Expression[0]));", "-      //if outer class is in symbol table and visible, but there is not a matching inner constructor, should give an error but still return instance of type", "+      // if outer class is in symbol table and visible, but there is not a matching inner constructor, should give ", "+      // an error but still return instance of type", "-      outerClass.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-      innerClass.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "+      outerClass.setMav(new ModifiersAndVisibility(SourceInfo.NONE, new String[] {\"public\"}));", "+      innerClass.setMav(new ModifiersAndVisibility(SourceInfo.NONE, new String[] {\"public\"}));", "-      assertEquals(\"Should return innerClass even though it could not find constructor\", innerClass.getInstanceData(), ci1.visit(_etc));", "+      assertEquals(\"Should return innerClass even though it could not find constructor\", innerClass.getInstanceData(), ", "+                   ci1.visit(_etc));", "-      assertEquals(\"Error message should be correct\", \"No constructor found in class outer.innerClass with signature: innerClass(int).\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\",", "+                   \"No constructor found in class outer.innerClass with signature: innerClass(int).\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"Should return innerClass even though it cannot really be instantiated\", innerClass.getInstanceData(), ci1.visit(_etc));", "+      assertEquals(\"Should return innerClass even though it cannot really be instantiated\", innerClass.getInstanceData(), ", "+                   ci1.visit(_etc));", "-      assertEquals(\"Error message should be correct\", \"outer.innerClass is abstract and thus cannot be instantiated\", errors.getLast().getFirst());              ", "+      assertEquals(\"Error message should be correct\", \"outer.innerClass is abstract and thus cannot be instantiated\", ", "+                   errors.getLast().getFirst());              ", "-      ComplexNamedClassInstantiation ci3 = new ComplexNamedClassInstantiation(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"outer\")), new ClassOrInterfaceType(SourceInfo.NO_INFO, \"innerClass\", new Type[0]), ", "-                                                                              new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[0]));             ", "-      outerClass.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-      innerClass.setMav(new ModifiersAndVisibility(SourceInfo.NO_INFO, new String[] {\"public\"}));", "-      assertEquals(\"Should return innerClass even though the syntax was wrong\", innerClass.getInstanceData(), ci3.visit(_etc));", "+      ComplexNamedClassInstantiation ci3 = ", "+        new ComplexNamedClassInstantiation(SourceInfo.NONE, ", "+                                           new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"outer\")), ", "+                                           new ClassOrInterfaceType(SourceInfo.NONE, \"innerClass\", new Type[0]), ", "+                                           new ParenthesizedExpressionList(SourceInfo.NONE, new Expression[0]));             ", "+      outerClass.setMav(new ModifiersAndVisibility(SourceInfo.NONE, new String[] {\"public\"}));", "+      innerClass.setMav(new ModifiersAndVisibility(SourceInfo.NONE, new String[] {\"public\"}));", "+      assertEquals(\"Should return innerClass even though the syntax was wrong\", innerClass.getInstanceData(), ", "+                   ci3.visit(_etc));", "-                   \"The constructor of a non-static inner class can only be called on an instance of its containing class (e.g. new outer().new innerClass())\", errors.getLast().getFirst());", "+                   \"The constructor of a non-static inner class can only be called on an instance of its containing \"", "+                     + \"class (e.g. new outer().new innerClass())\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"Should return innerClass even though the syntax was wrong\", innerClass.getInstanceData(), ci1.visit(_etc));", "+      assertEquals(\"Should return innerClass even though the syntax was wrong\", ", "+                   innerClass.getInstanceData(), ci1.visit(_etc));", "-                   \"You cannot instantiate a static inner class or interface with this syntax.  Instead, try new outer.innerClass()\",", "+                   \"You cannot instantiate a static inner class or interface with this syntax.  Instead, \"", "+                     + \"try new outer.innerClass()\",", "-      ComplexNamedClassInstantiation ci4 = new ComplexNamedClassInstantiation(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"o\")), new ClassOrInterfaceType(SourceInfo.NO_INFO, \"notInnerClass\", new Type[0]), ", "-                                                                              new ParenthesizedExpressionList(SourceInfo.NO_INFO, new Expression[] {new IntegerLiteral(SourceInfo.NO_INFO, 5)}));", "+      ParenthesizedExpressionList pel2 = ", "+        new ParenthesizedExpressionList(SourceInfo.NONE, new Expression[] {new IntegerLiteral(SourceInfo.NONE, 5)});", "+      ComplexNamedClassInstantiation ci4 = ", "+        new ComplexNamedClassInstantiation(SourceInfo.NONE, ", "+                                           new SimpleNameReference(SourceInfo.NONE, new Word(SourceInfo.NONE, \"o\")), ", "+                                           new ClassOrInterfaceType(SourceInfo.NONE, \"notInnerClass\", new Type[0]), ", "+                                           pel2);", "-      assertEquals(\"Error message should be correct\", \"Class or variable notInnerClass not found.\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", \"Class or variable notInnerClass not found.\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"Error message should be correct\", \"The class or interface outer.innerClass is private and cannot be accessed from i.like.monkey\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"The class or interface outer.innerClass in outer.innerClass is private and cannot be accessed from i.like.monkey\", ", "+                   errors.getLast().getFirst());", "-      assertEquals(\"Error message should be correct\", \"The class or interface outer is private and cannot be accessed from i.like.monkey\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"The class or interface outer in outer is private and cannot be accessed from i.like.monkey\", ", "+                   errors.getLast().getFirst());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "733c531fb8b7783913c6e36cb4661fe5", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyTypeChecker.java", "commitBeforeChange": "80f1de11eca64397e6c4771311a2a63da1189aed", "commitAfterChange": "b51ee0080da7d8cbad354c4c5be1a0e0e67cdc0a", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "          public void testForConstructorDef()", "signatureAfterChange": "          public void testForConstructorDef()", "diff": ["-      VariableDeclaration vd = new VariableDeclaration(SourceInfo.NO_INFO, _finalMav, new VariableDeclarator[] {new UninitializedVariableDeclarator(SourceInfo.NO_INFO, new PrimitiveType(SourceInfo.NO_INFO, \"int\"), new Word(SourceInfo.NO_INFO, \"i\"))});", "-      ExpressionStatement se = new ExpressionStatement(SourceInfo.NO_INFO, new SimpleAssignmentExpression(SourceInfo.NO_INFO, new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"i\")), new IntegerLiteral(SourceInfo.NO_INFO, 1)));      ", "-      BracedBody cbb = new BracedBody(SourceInfo.NO_INFO, new BodyItemI[] {se});", "-      ConstructorDef cd = new ConstructorDef(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"Jimes\"), _publicMav, new FormalParameter[0], new ReferenceType[0], cbb);", "+      VariableDeclarator[] vds = ", "+        new VariableDeclarator[] { new UninitializedVariableDeclarator(SourceInfo.NO_INFO, ", "+                                                                       new PrimitiveType(SourceInfo.NO_INFO, \"int\"), ", "+                                                                       new Word(SourceInfo.NO_INFO, \"i\"))};", "+      ", "+      VariableDeclaration vd =  new VariableDeclaration(SourceInfo.NO_INFO, _finalMav, vds);", "+      SimpleNameReference snr =  ", "+        new SimpleNameReference(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"i\"));", "+      ExpressionStatement es = ", "+        new ExpressionStatement(SourceInfo.NO_INFO, ", "+                                new SimpleAssignmentExpression(SourceInfo.NO_INFO, ", "+                                                               snr, ", "+                                                               new IntegerLiteral(SourceInfo.NO_INFO, 1)));      ", "+      BracedBody cbb = new BracedBody(SourceInfo.NO_INFO, new BodyItemI[] { es });", "+      ConstructorDef cd =  new ConstructorDef(SourceInfo.NO_INFO, ", "+                                              new Word(SourceInfo.NO_INFO, \"Jimes\"), ", "+                                              _publicMav, ", "+                                              new FormalParameter[0], ", "+                                              new ReferenceType[0], ", "+                                              cbb);", "-      ClassDef classDef = new ClassDef(SourceInfo.NO_INFO, _publicMav, new Word(SourceInfo.NO_INFO, \"Jimes\"), new TypeParameter[0], new ClassOrInterfaceType(SourceInfo.NO_INFO, \"java.lang.Object\", new Type[0]), new ReferenceType[0], b);", "+      ClassDef classDef = ", "+        new ClassDef(SourceInfo.NO_INFO, ", "+                     _publicMav, ", "+                     new Word(SourceInfo.NO_INFO, \"Jimes\"), ", "+                     new TypeParameter[0], ", "+                     new ClassOrInterfaceType(SourceInfo.NO_INFO, \"java.io.StreamTokenizer\", new Type[0]), ", "+                     new ReferenceType[0], ", "+                     b);", "-      SymbolData sd = new SymbolData(\"Jimes\");", "-      VariableData vData = new VariableData(\"i\", _finalMav, SymbolData.INT_TYPE, false, sd);", "+      SymbolData jimes = new SymbolData(\"Jimes\");", "+      VariableData vData = new VariableData(\"i\", _finalMav, SymbolData.INT_TYPE, false, jimes);", "-      sd.setMav(_publicMav);", "-      sd.setIsContinuation(false);", "-      sd.addVar(vData);", "-      SymbolData sd2 = new SymbolData(\"java.lang.Object\");", "-      sd2.setIsContinuation(false);", "-      sd2.setMav(_publicMav);", "-      sd2.setPackage(\"java.lang\");", "-      sd.setSuperClass(sd2);", "-      symbolTable.put(\"Jimes\", sd);", "-      symbolTable.put(\"java.lang.Object\", sd2);", "-      MethodData md = new MethodData(\"Jimes\", _publicMav, new TypeParameter[0], sd, new VariableData[0], new String[0], sd, cd);", "-      MethodData objMd = new MethodData(\"Object\", _publicMav, new TypeParameter[0], sd2, new VariableData[0], new String[0], sd2, cd);", "-      sd.addMethod(md);", "+      jimes.setMav(_publicMav);", "+      jimes.setIsContinuation(false);", "+      jimes.addVar(vData);", "+", "+      symbolTable.put(\"Jimes\", jimes);", "+", "+//      SymbolData obj = _cbbtc.getSymbolData(\"java.lang.Object\", new NullLiteral(SourceInfo.NO_INFO), false, true);", "+      SymbolData tokenizer = _cbbtc.getSymbolData(\"java.io.StreamTokenizer\", new NullLiteral(SourceInfo.NO_INFO), false, true);", "+      jimes.setSuperClass(tokenizer);", "+      SymbolData jutc = defineTestCaseClass();", "+      assert symbolTable.contains(tokenizer);", "+      assert symbolTable.contains(jutc);", "-      //assumes an explicit super call with no arguments", "+      MethodData md = ", "+        new MethodData(\"Jimes\", _publicMav, new TypeParameter[0], jimes, new VariableData[0], new String[0], jimes, cd);", "+      MethodData objMd = ", "+        new MethodData(\"java.lang.Object\", _publicMav, new TypeParameter[0], tokenizer, new VariableData[0], ", "+                       new String[0], tokenizer, cd);", "+      jimes.addMethod(md);", "+      ", "+      // assumes an explicit super call with no arguments", "-      assertEquals(\"Error message should be correct\", \"You must invoke one of java.lang.Object's constructors here.  You can either explicitly invoke one of its exisitng constructors or add a constructor with signature: Object().\", errors.getLast().getFirst());", "+      assertEquals(\"Error message should be correct\", ", "+                   \"You must invoke one of java.io.StreamTokenizer's constructors here.  You can either explicitly \"", "+                     + \"invoke one of its exisitng constructors or add a constructor with signature: StreamTokenizer().\", ", "+                   errors.getLast().getFirst());", "-      sd2.addMethod(objMd); //give super class constructor", "+      tokenizer.addMethod(objMd); //give super class constructor", "-      ", "+      // Since we are going to traverse classDef again, we are resetting the error log.", "+      errors.clear();", "-      cd = new ConstructorDef(SourceInfo.NO_INFO, new Word(SourceInfo.NO_INFO, \"Jimes\"), _publicMav, new FormalParameter[0], new ReferenceType[0], cbb);", "+      cd = new ConstructorDef(SourceInfo.NO_INFO, ", "+                              new Word(SourceInfo.NO_INFO, \"Jimes\"), ", "+                              _publicMav, ", "+                              new FormalParameter[0], ", "+                              new ReferenceType[0], ", "+                              cbb);", "-      classDef = new ClassDef(SourceInfo.NO_INFO, _publicMav, new Word(SourceInfo.NO_INFO, \"Jimes\"), new TypeParameter[0], new ClassOrInterfaceType(SourceInfo.NO_INFO, \"java.lang.Object\", new Type[0]), new ReferenceType[0], b);", "+      classDef = new ClassDef(SourceInfo.NO_INFO, ", "+                              _publicMav, ", "+                              new Word(SourceInfo.NO_INFO, \"Jimes\"), ", "+                              new TypeParameter[0], ", "+                              new ClassOrInterfaceType(SourceInfo.NO_INFO, \"java.lang.Object\", new Type[0]), ", "+                              new ReferenceType[0], b);", "+      System.err.println(\"***** Starting traversal of classDef\");", "+//      System.err.println(\"Error 3 for line 803 of ClassBodyTypeChecker is: \" + errors.get(2).getFirst());", "+      System.err.println(\"Error 2 for line 803 of ClassBodyTypeChecker is: \" + errors.get(1).getFirst());", "+      System.err.println(\"Error 1 for line 803 of ClassBodyTypeChecker is: \" + errors.get(0).getFirst());", "+      ", "-      assertEquals(\"The error message should be correct\", \"The final field i has not been initialized.  Make sure you give it a value in this constructor\", errors.getLast().getFirst());", "+      ", "+      assertEquals(\"The second error message should be correct\", ", "+                   \"The final field i has not been initialized.  Make sure you give it a value in this constructor\", ", "+                   errors.getLast().getFirst());", "-      vData = new VariableData(\"j\", _finalMav, SymbolData.INT_TYPE, false, sd);", "-      sd.setVars(new LinkedList<VariableData>());", "-      sd.addVar(vData);", "+      vData = new VariableData(\"j\", _finalMav, SymbolData.INT_TYPE, false, jimes);", "+      jimes.setVars(new LinkedList<VariableData>());", "+      jimes.addVar(vData);", "-      _cbbtc = new ClassBodyTypeChecker(sd, new File(\"\"), \"\", new LinkedList<String>(), new LinkedList<String>(), vs, new LinkedList<Pair<SymbolData, JExpression>>());", "+      _cbbtc = new ClassBodyTypeChecker(jimes, new File(\"\"), \"\", new LinkedList<String>(), new LinkedList<String>(), vs, new LinkedList<Pair<SymbolData, JExpression>>());"]}], "num": 3432}