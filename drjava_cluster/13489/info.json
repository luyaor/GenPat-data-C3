{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b83161519193b8fefeb99bac8dbbe40e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35f6d90523d32930abb543ff78be3704", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/koala/dynamicjava/interpreter/AbstractTypeChecker.java", "commitBeforeChange": "93cff9492f5f66f78081d1bfed6f05eaa775f999", "commitAfterChange": "fb4768f0a5915f88272f3d532585a4203c452f84", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "   public Class<?> visit(SwitchStatement node)", "signatureAfterChange": "   public Class<?> visit(SwitchStatement node)", "diff": ["-    // Visits the components of this node", "-    Expression exp = node.getSelector();", "-    Class<?> c = exp.acceptVisitor(this);", "-    if (c != char.class      && c != byte.class && c != short.class && c != int.class  && ", "-        c != Character.class && c != Byte.class && c != Short.class && c != Integer.class) {", "-      node.setProperty(NodeProperties.ERROR_STRINGS,", "-                       new String[] { c.getName() });", "-      throw new ExecutionError(\"selector.type\", node);", "-    }", "-    // unbox it if needed", "-    if (c == Character.class || c == Byte.class || c == Short.class || c == Integer.class) {", "-      node.setSelector(_unbox(exp, c));", "-    }", "-    ", "-    // Check the type of the case labels", "-    Iterator<SwitchBlock> it = node.getBindings().iterator();", "-    while (it.hasNext()) {", "-      SwitchBlock sb = it.next();", "-      sb.acceptVisitor(this);", "-      exp = sb.getExpression();", "-      if (exp != null) {", "-        Class<?> lc = NodeProperties.getType(exp);", "-        if (lc != char.class &&  lc != byte.class &&", "-            lc != short.class && lc != int.class) {", "-          node.setProperty(NodeProperties.ERROR_STRINGS,", "-                           new String[] { lc.getName() });", "-          throw new ExecutionError(\"switch.label.type\", node);", "-        }", "-        if (c != lc) {", "-          Number n = null;", "-          if (exp.hasProperty(NodeProperties.VALUE)) {", "-            Object cst = exp.getProperty(NodeProperties.VALUE);", "-            if (lc == char.class) {", "-              n = new Integer(((Character)cst).charValue());", "-            } else {", "-              n = (Number)cst;", "-            }", "+    try {", "+      // Visits the components of this node", "+      Expression exp = node.getSelector();", "+      Class<?> c = exp.acceptVisitor(this);", "+      if (c != char.class      && c != byte.class && c != short.class && c != int.class  && ", "+          c != Character.class && c != Byte.class && c != Short.class && c != Integer.class &&", "+          (TigerUtilities.isTigerEnabled() && (c.getSuperclass() != Class.forName(\"java.lang.Enum\")))) {", "+        //!TigerUtilities.isEnum(c) ) {", "+        node.setProperty(NodeProperties.ERROR_STRINGS,", "+                         new String[] { c.getName() });", "+        throw new ExecutionError(\"selector.type\", node);", "+      }", "+      // unbox it if needed", "+      if (c == Character.class || c == Byte.class || c == Short.class || c == Integer.class) {", "+        node.setSelector(_unbox(exp, c));", "+      }", "+      ", "+      // Check the type of the case labels", "+      Iterator<SwitchBlock> it = node.getBindings().iterator();", "+      while (it.hasNext()) {", "+        SwitchBlock sb = it.next();", "+        sb.acceptVisitor(this);", "+        exp = sb.getExpression();", "+        if (exp != null) {", "+          Class<?> lc = NodeProperties.getType(exp);", "+          if (lc != char.class &&  lc != byte.class &&", "+              lc != short.class && lc != int.class &&", "+              (TigerUtilities.isTigerEnabled() && (lc.getSuperclass() != Class.forName(\"java.lang.Enum\")))) {", "+            //!TigerUtilities.isEnum(lc)) {", "+            node.setProperty(NodeProperties.ERROR_STRINGS,", "+                             new String[] { lc.getName() });", "+            throw new ExecutionError(\"switch.label.type\", node);", "-          if (c == byte.class) {", "+          if (c != lc) {", "+            Number n = null;", "-              if (n.byteValue() != n.intValue()) {", "-                node.setProperty(NodeProperties.ERROR_STRINGS,", "-                                 new String[] { c.getName() });", "-                throw new ExecutionError", "-                  (\"switch.label.type\", node);", "+              Object cst = exp.getProperty(NodeProperties.VALUE);", "+              if (lc == char.class) {", "+                n = new Integer(((Character)cst).charValue());", "+              } else {", "+                n = (Number)cst;", "-            } else {", "-              throw new ExecutionError(\"switch.label.type\", node);", "-          } else if (c == short.class || c == char.class) {", "-            if (exp.hasProperty(NodeProperties.VALUE)) {", "-              if (n.shortValue() != n.intValue()) {", "+            if (c == byte.class) {", "+              if (exp.hasProperty(NodeProperties.VALUE)) {", "+                if (n.byteValue() != n.intValue()) {", "+                  node.setProperty(NodeProperties.ERROR_STRINGS,", "+                                   new String[] { c.getName() });", "+                  throw new ExecutionError", "+                    (\"switch.label.type\", node);", "+                }", "+              } else {", "+                throw new ExecutionError(\"switch.label.type\", node);", "+              }", "+            } else if (c == short.class || c == char.class) {", "+              if (exp.hasProperty(NodeProperties.VALUE)) {", "+                if (n.shortValue() != n.intValue()) {", "+                  node.setProperty(NodeProperties.ERROR_STRINGS,", "+                                   new String[] { c.getName() });", "+                  throw new ExecutionError", "+                    (\"switch.label.type\", node);", "+                }", "+              } else if (lc == int.class) {", "-                throw new ExecutionError", "-                  (\"switch.label.type\", node);", "+                throw new ExecutionError(\"switch.label.type\", node);", "-            } else if (lc == int.class) {", "-              node.setProperty(NodeProperties.ERROR_STRINGS,", "-                               new String[] { c.getName() });", "-              throw new ExecutionError(\"switch.label.type\", node);", "+    } ", "+    // this try/catch block should in fact not be there, but to use", "+    // TigerUtilities.isEnum(c) instead if the value of the ENUM flag", "+    // was known (see 2 commented lines above)", "+    catch(ClassNotFoundException e){", "+      throw new ExecutionError(\"Tiger is enabled, but cannot find class java.lang.Enum! Please contact the DynamicJava/DrJava team (javaplt@cs.rice.edu).\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39feea6dc4d2006f82916656e8222547", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/util/swing/FindReplaceMachine.java", "commitBeforeChange": "20a2512e394be5865ddd8dc1ebd648c5dfb08d0c", "commitAfterChange": "832e5dfbee9301c0432d02f86eab2d13af7f51bc", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 20, "signatureBeforeChange": "   public FindResult findNext()", "signatureAfterChange": "   public FindResult findNext()", "diff": ["+      FindResult tempFr = new FindResult(_doc, -1, false);", "+      // If the user just found and toggled the \"Search Backwards\"", "+      // option, we should skip the first find.", "-        _wrapped = true;", "-        //When we wrap, we need to include some text that was already searched before wrapping.", "-        //Otherwise, we won't find an only match that has the caret in it already.", "-        if(!_searchBackwards){", "-          start = 0;", "-          len = _start.getOffset() + (_findWord.length() - 1);", "-          if(len > _doc.getLength()){", "-            len = _doc.getLength();", "-          }", "-        } else {", "-          start = _start.getOffset() - (_findWord.length() - 1);", "-          if (start < 0){", "+        if (_searchAllDocuments) {", "+          tempFr = _findNextInAllDocs(!_searchBackwards ? _docIterator.getNextDocument(_doc) :", "+                                        _docIterator.getPrevDocument(_doc));", "+          foundOffset = tempFr.getFoundOffset();", "+        }", "+        // we still haven't found it", "+        if (foundOffset == -1) {", "+          _wrapped = true;", "+          //When we wrap, we need to include some text that was already searched before wrapping.", "+          //Otherwise, we won't find an only match that has the caret in it already.", "+          if(!_searchBackwards){", "+            len = _current.getOffset() + (_findWord.length() - 1);", "+            if(len > _doc.getLength()){", "+              len = _doc.getLength();", "+            }", "+          } ", "+          else {", "+            start = _current.getOffset() - (_findWord.length() - 1);", "+            if (start < 0){", "+              start = 0;", "+            }", "+            len = _doc.getLength() - start;", "-          len = _doc.getLength() - start;", "-        }", "-        findSpace = _doc.getText(start, len);", "-", "-        if (!_matchCase) {", "-          findSpace = findSpace.toLowerCase();", "-        }", "-", "-        foundOffset = !_searchBackwards ? findSpace.indexOf(findWord)", "-          : findSpace.lastIndexOf(findWord);", "-", "-        if (foundOffset >= 0) {", "-          foundOffset += start;", "-          if (!_searchBackwards) {", "-            foundOffset += findWord.length();", "+          findSpace = _doc.getText(start, len);", "+          ", "+          if (!_matchCase) {", "+            findSpace = findSpace.toLowerCase();", "-          _current = _doc.createPosition(foundOffset);", "+          foundOffset = !_searchBackwards ? findSpace.indexOf(findWord)", "+            : findSpace.lastIndexOf(findWord);", "+          ", "+          if (foundOffset >= 0) {", "+            foundOffset += start;", "+            if (!_searchBackwards) {", "+              foundOffset += findWord.length();", "+            }", "+            _current = _doc.createPosition(foundOffset);", "+          }", "-      if(foundOffset == -1 && _found) {", "-        _current = _start;", "-        _found = false;", "-        return findNext();", "-      }", "-      else {", "-        FindResult fr = new FindResult(foundOffset, _wrapped);", "-        _wrapped = false;", "-        return fr;", "-      }", "+//      if(foundOffset == -1 && _found) {", "+//        _current = _start;", "+//        _found = false;", "+//        return findNext();", "+//      }", "+//      else {", "+      FindResult fr = new FindResult(tempFr.getDocument(), foundOffset, _wrapped);", "+      _wrapped = false;", "+      return fr;", "+//      }", "+    }", "+  }"]}], "num": 13489}