{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f07bd6545b21adf2b4044ae7ff52f067", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "50c74573a73aff17dea9b24ba1fbc92b", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "9c6f88c259086ee69c4d958032e8427e6f011b12", "commitAfterChange": "9437c2299622c109c03b30ccc782cae5639dae6e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 12, "signatureBeforeChange": "      private boolean isSubtype(final Type subT, final Type superT, final RecursionStack2<Type, Type> stack)", "signatureAfterChange": "          public Predicate<Type> subtypes(Type sup)", "diff": ["-  private boolean isSubtype(final Type subT, final Type superT, final RecursionStack2<Type, Type> stack) {", "-    //debug.logStart(new String[]{\"subT\", \"superT\"}, subT, superT); try {", "-            ", "-    if (subT.equals(superT)) { return true; } // what follows assumes the types are not syntactically equal", "-    // Handle easy superT cases:", "-    Boolean result = superT.apply(new TypeAbstractVisitor<Boolean>() {", "-      public Boolean defaultCase(Type superT) { return null; }", "-      ", "-      @Override public Boolean forVariableType(final VariableType superT) {", "-        return subT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(final Type subT) {", "-            Thunk<Boolean> checkLowerBound = new Thunk<Boolean>() {", "-              public Boolean value() { return isSubtype(subT, superT.symbol().lowerBound(), stack); }", "-            };", "-            return stack.apply(checkLowerBound, false, subT, superT);", "-          }", "-          @Override public Boolean forVariableType(VariableType subT) {", "-            return defaultCase(subT) ? true : null;", "-          }", "-          @Override public Boolean forIntersectionType(IntersectionType subT) {", "-            return defaultCase(subT) ? true : null;", "-          }", "-          @Override public Boolean forBottomType(BottomType subT) { return true; }", "-        });", "-      }", "-      ", "-      @Override public Boolean forIntersectionType(IntersectionType superT) {", "-        if (subT instanceof BottomType) { return true; }", "-        else {", "-          return IterUtil.and(superT.ofTypes(), new Predicate<Type>() {", "-            public boolean contains(Type t) { return isSubtype(subT, t, stack); }", "-          });", "-        }", "-      }", "-      ", "-      @Override public Boolean forUnionType(final UnionType superT) {", "-        return subT.apply(new TypeAbstractVisitor<Boolean>() {", "-          @Override public Boolean defaultCase(Type t) {", "-            return IterUtil.or(superT.ofTypes(), new Predicate<Type>() {", "-              public boolean contains(Type t) { return isSubtype(subT, t, stack); }", "-            });", "-          }", "-          public Boolean forVariableType(VariableType t) { return defaultCase(subT) ? true : null; }", "-          public Boolean forUnionType(UnionType t) { return null; }", "-          public Boolean forBottomType(BottomType t) { return true; }", "-        });", "-      }", "-      ", "-      @Override public Boolean forTopType(TopType superT) { return true; }", "-    });", "-    if (result != null) { return result; }", "-    // Handle subT-based cases:", "-    return subT.apply(new TypeAbstractVisitor<Boolean>() {", "-      ", "-      public Boolean defaultCase(Type t) { return false; }", "-      ", "-      public Boolean forCharType(CharType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forCharType(CharType superT) { return true; }", "-          @Override public Boolean forIntType(IntType superT) { return true; }", "-          @Override public Boolean forLongType(LongType superT) { return true; }", "-          @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "-        });", "-      }", "-      ", "-      public Boolean forByteType(ByteType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forIntegerType(IntegerType superT) { return true; }", "-          @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "-        });", "-      }", "-      ", "-      public Boolean forShortType(ShortType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forShortType(ShortType superT) { return true; }", "-          @Override public Boolean forIntType(IntType superT) { return true; }", "-          @Override public Boolean forLongType(LongType superT) { return true; }", "-          @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "-        });", "-      }", "-      ", "-      public Boolean forIntType(IntType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forIntType(IntType superT) { return true; }", "-          @Override public Boolean forLongType(LongType superT) { return true; }", "-          @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "-        });", "-      }", "-      ", "-      public Boolean forLongType(LongType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forLongType(LongType superT) { return true; }", "-          @Override public Boolean forFloatingPointType(FloatingPointType superT) { return true; }", "-        });", "-      }", "-      ", "-      public Boolean forFloatType(FloatType subT) { return superT instanceof FloatingPointType; }", "-      ", "-      public Boolean forNullType(NullType subT) { return isReference(superT); }", "-      ", "-      public Boolean forSimpleArrayType(SimpleArrayType subT) { return handleArrayType(subT); }", "-      ", "-      public Boolean forVarargArrayType(VarargArrayType subT) { return handleArrayType(subT); }", "-      ", "-      private Boolean handleArrayType(final ArrayType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          ", "-          @Override public Boolean forArrayType(ArrayType superT) {", "-            if (isPrimitive(subT.ofType())) {", "-              // types may be inequal if one is vararg and the other is not", "-              return subT.ofType().equals(superT.ofType());", "-            }", "-            else { return isSubtype(subT.ofType(), superT.ofType(), stack); }", "-          }", "-          ", "-          @Override public Boolean forClassType(ClassType superT) { ", "-            return isSubtype(CLONEABLE_AND_SERIALIZABLE, superT, stack);", "-          }", "-          ", "-        });", "-      }", "-      ", "-      public Boolean forClassType(final ClassType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          @Override public Boolean forClassType(ClassType superT) {", "-            Type newSub = immediateSupertype(subT);", "-            if (newSub == null) { return false; }", "-            else { return isSubtype(newSub, superT, stack); }", "-          }", "-        });", "-      }", "-      ", "-      public Boolean forParameterizedClassType(final ParameterizedClassType subT) {", "-        return superT.apply(new TypeAbstractVisitor<Boolean>() {", "-          public Boolean defaultCase(Type superT) { return false; }", "-          ", "-          @Override public Boolean forParameterizedClassType(final ParameterizedClassType superT) {", "-            if (subT.ofClass().equals(superT.ofClass())) {", "+    public Predicate<Type> subtypes(Type sup) { return LambdaUtil.bindSecond((Order<Type>) this, sup); }", "-              Thunk<Boolean> containedArgs = new Thunk<Boolean>() {", "-                  boolean result = true;", "-                  ParameterizedClassType subCapT = capture(subT);", "-                  for (final Pair<Type, Type> args : IterUtil.zip(subCapT.typeArguments(), ", "-                                                                  superT.typeArguments())) {", "-                    result &= args.second().apply(new TypeAbstractVisitor<Boolean>() {", "-                      public Boolean defaultCase(Type superArg) { return isEqual(args.first(), superArg); }", "-                      @Override public Boolean forWildcard(Wildcard superArg) {", "-                        return isSubtype(superArg.symbol().lowerBound(), args.first(), stack) &&", "-                          isSubtype(args.first(), superArg.symbol().upperBound(), stack);", "-                      }", "-                    });", "-                    if (!result) { break; }", "-                  }", "-                  return result;", "-              ", "-              return stack.apply(containedArgs, true, subT, superT) || forClassType(superT);", "-            else { return forClassType(superT); }", "-          ", "-          @Override public Boolean forClassType(ClassType superT) {", "-            Type newSub = immediateSupertype(subT);", "-            if (newSub == null) { return false; }", "-            else { return isSubtype(meet(newSub, erase(subT)), superT, stack); }", "-          }", "-          ", "-      ", "-      public Boolean forVariableType(final VariableType subT) {", "-        // If variables are always Objects, we should test that superT is Object in the infinite case", "-        Thunk<Boolean> checkUpperBound = new Thunk<Boolean>() {", "-          public Boolean value() { return isSubtype(subT.symbol().upperBound(), superT, stack); }", "-        };", "-        return stack.apply(checkUpperBound, false, subT, superT);", "-      }", "-      ", "-      public Boolean forIntersectionType(IntersectionType subT) {", "-        return IterUtil.or(subT.ofTypes(), new Predicate<Type>() {", "-          public boolean contains(Type t) { return isSubtype(t, superT, stack); }", "-        });", "-      }", "-      ", "-      public Boolean forUnionType(UnionType subT) {", "-        return IterUtil.and(subT.ofTypes(), new Predicate<Type>() {", "-          public boolean contains(Type t) { return isSubtype(t, superT, stack); }", "-        });", "-      }", "-      ", "-      public Boolean forBottomType(BottomType subT) { return true; }", "-    });", "-    //} finally { debug.logEnd(); }", "-  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9325f93d088c66ef4dd7c3570afc8794", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/DefaultGlobalModel.java", "commitBeforeChange": "35ca78e33b0503c2a6070986170dae99ba9dcb1a", "commitAfterChange": "6136e4c5753a47e4bcb40afa831b9c58e353fd69", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 17, "signatureBeforeChange": "         public FileGroupingState _makeProjectFileGroupingState(final File jarMainClass,                                                           final File buildDir,                                                           final File projectFile,                                                           final File[] projectFiles,                                                          final ClasspathVector classpath)", "signatureAfterChange": "      protected FileGroupingState      makeProjectFileGroupingState(File main, File dir, File project, File[] files, ClasspathVector cp)", "diff": ["+  protected FileGroupingState ", "+    makeProjectFileGroupingState(File main, File dir, File project, File[] files, ClasspathVector cp) {", "+    return new ProjectFileGroupingState(main, dir, project, files, cp);", "-  ", "-  public FileGroupingState _makeProjectFileGroupingState(final File jarMainClass, ", "-                                                         final File buildDir, ", "-                                                         final File projectFile, ", "-                                                         final File[] projectFiles,", "-                                                         final ClasspathVector classpath) {", "-    return new FileGroupingState() {", "-      private File _builtDir = buildDir;", "-      private File _mainFile = jarMainClass;", "-      ", "-      private volatile boolean _isProjectChanged = false;", "-      ", "-      //private ArrayList<File> _auxFiles = new ArrayList<File>();", "-      ", "-      HashSet<String> _projFilePaths = new HashSet<String>();", "-      ", "-      private ClasspathVector _projExtraClasspath = classpath;", "-      ", "-      /** Initialization Block */", "-      { ", "-        try {  for (File file : projectFiles) { _projFilePaths.add(file.getCanonicalPath()); } }", "-        catch(IOException e) { }", "-      }", "-      ", "-      public boolean isProjectActive() { return true; }", "-      ", "-      /** Determines whether the specified doc in within the project file tree.", "-       *  No synchronization is required because only immutable data is accessed.", "-       */", "-      public boolean isInProjectPath(OpenDefinitionsDocument doc) {", "-        File projectRoot = projectFile.getParentFile();", "-        if (doc.isUntitled()) return false;", "-        ", "-        // If the file does not exist, we still want to tell if it's in the correct", "-        // path.  The file may have been in at one point and had been removed, in which", "-        // case we should treat it as an untitled project file that should be resaved.", "-        try {", "-          File f;", "-          try { f = doc.getFile(); } ", "-          catch(FileMovedException fme) { f = fme.getFile(); }", "-          ", "-          String filePath = f.getParentFile().getCanonicalPath() + File.separator;", "-          String projectPath = projectRoot.getCanonicalPath() + File.separator;", "-          return (filePath.startsWith(projectPath));", "-        }", "-        catch(IOException e) {", "-          //          System.out.println(e); // What should we do in this case?", "-          return false;", "-        }", "-      }", "-      ", "-      /** @return the absolute path to the project file.  Since projectFile is final, no synchronization", "-       *   is necessary.", "-       */", "-      public File getProjectFile() { return projectFile; }", "-      ", "-      public boolean isProjectFile(File f) {", "-        String path;", "-        ", "-        if (f == null) return false;", "-        ", "-        try { ", "-          path = f.getCanonicalPath();", "-          return _projFilePaths.contains(path);", "-        }", "-        catch(IOException ioe) { return false; }", "-        /*", "-         for (File file : projectFiles) {", "-         try {", "-         if (file.getCanonicalPath().equals(path))", "-         return true;", "-         }", "-         catch(IOException ioe) {", "-         //continue", "-         }", "-         }", "-         return false;*/", "-        ", "-      }", "-      ", "-      public File[] getProjectFiles() { return projectFiles; }", "-      ", "-      public File getBuildDirectory() { return _builtDir; }", "-      ", "-      public void setBuildDirectory(File f) { _builtDir = f; }", "-      ", "-      public File getMainClass() { return _mainFile; }", "-      ", "-      public void setJarMainClass(File f) { _mainFile = f; }", "-      ", "-      public boolean isProjectChanged() { return _isProjectChanged; }", "-      ", "-      public void setProjectChanged(boolean changed) { _isProjectChanged = changed; }", "-      ", "-      public boolean isAuxiliaryFile(File f) {", "-        String path;", "-        ", "-        if (f == null) return false;", "-        ", "-        try { path = f.getCanonicalPath();}", "-        catch(IOException ioe) { return false; }", "-        ", "-        synchronized(_auxiliaryFiles) {", "-          for (File file : _auxiliaryFiles) {", "-            try { if (file.getCanonicalPath().equals(path)) return true; }", "-            catch(IOException ioe) { /* ignore file */ }", "-          }", "-          return false;", "-        }", "-      }", "-      ", "-      public void cleanBuildDirectory() throws FileMovedException, IOException{", "-        File dir = this.getBuildDirectory();", "-        cleanHelper(dir);", "-        if (! dir.exists()) dir.mkdirs();", "-      }", "-      ", "-      private void cleanHelper(File f) {", "-        if (f.isDirectory()) {", "-          ", "-          File fs[] = f.listFiles(new FilenameFilter() {", "-            public boolean accept(File parent, String name) {", "-              return new File(parent, name).isDirectory() || name.endsWith(\".class\");", "-            }", "-          });", "-          ", "-          for (File kid: fs) { cleanHelper(kid); }", "-          ", "-          if (f.listFiles().length == 0)  f.delete();", "-          ", "-        } else if (f.getName().endsWith(\".class\")) f.delete();", "-      }", "-      ", "-      ", "-      /**", "-       * returns the name of the package from a fully qualified classname", "-       */", "-      ", "-      // ----- FIND ALL DEFINED CLASSES IN FOLDER ---", "-      public void compileAll() throws IOException{", "-        File dir = getProjectFile().getParentFile();", "-        final ArrayList<File> files = FileOps.getFilesInDir(dir, true, new FileFilter() {", "-          public boolean accept(File pathname) {", "-            return pathname.isDirectory() || ", "-              pathname.getPath().toLowerCase().endsWith(\".java\") ||", "-              pathname.getPath().toLowerCase().endsWith(\".dj0\") ||", "-              pathname.getPath().toLowerCase().endsWith(\".dj1\") ||", "-              pathname.getPath().toLowerCase().endsWith(\".dj2\");", "-          }", "-        });", "-        ", "-        ", "-        ClassAndInterfaceFinder finder;", "-        List<File> lof = new LinkedList<File>(); // the list of files to compile", "-        List<File> los = new LinkedList<File>(); // the list of sourceroots for the files", "-        ", "-        for (File f: files) {", "-          finder = new ClassAndInterfaceFinder(f);", "-          String classname = finder.getClassOrInterfaceName();", "-          String packagename = getPackageName(classname);", "-            File sourceroot = getSourceRoot(packagename, f);", "-            if (!los.contains(sourceroot)) los.add(sourceroot);", "-            lof.add(f);", "-        ", "-//        ScrollableDialog sd1 = new ScrollableDialog(null, \"Constructed list of files to compile: \" + lof, \"\", \"\");", "-//        sd1.show();", "-        ", "-        String[] exts = new String[]{\".java\", \".dj0\", \".dj1\", \".dj2\"};", "-        List<OpenDefinitionsDocument> lod = getOpenDefinitionsDocuments();", "-        for (OpenDefinitionsDocument d: lod) {", "-          if (d.isAuxiliaryFile()) {", "-            try {", "-              File f;", "-              File sourceRoot = d.getSourceRoot();", "-              try {", "-                f = d.getFile();", "-                for (String ext: exts) {", "-                  if (f.getName().endsWith(ext)) {", "-                    lof.add(f);", "-                    los.add(sourceRoot);", "-                  }", "-                }", "-              } ", "-              catch(FileMovedException fme) {", "-                // the file's not on disk, but send it in anyways", "-                f = fme.getFile();", "-                lof.add(f);", "-                los.add(sourceRoot);", "-              } ", "-              catch(IllegalStateException e) { /* do nothing */ }", "-            } ", "-            catch(InvalidPackageException e) { /* do nothing */ }", "-          }", "-        }", "-        getCompilerModel().compileAll(los, lof);", "-      }", "-      ", "-      // ----- FIND ALL DEFINED CLASSES IN FOLDER ---", "-      public void junitAll() {", "-        File dir = getProjectFile().getParentFile();", "-        final ArrayList<File> files = FileOps.getFilesInDir(dir, true, new FileFilter() {", "-          public boolean accept(File pathname) {", "-            return pathname.isDirectory() || ", "-              pathname.getPath().toLowerCase().endsWith(\".java\") ||", "-              pathname.getPath().toLowerCase().endsWith(\".dj0\") ||", "-              pathname.getPath().toLowerCase().endsWith(\".dj1\") ||", "-              pathname.getPath().toLowerCase().endsWith(\".dj2\");", "-          }", "-        });", "-        ClassAndInterfaceFinder finder;", "-        List<String> los = new LinkedList<String>();", "-        List<File> lof = new LinkedList<File>();", "-        for (File f: files) {", "-          finder = new ClassAndInterfaceFinder(f);", "-          String classname = finder.getClassName();", "-          if (classname.length() > 0) {", "-            los.add(classname);", "-            lof.add(f);", "-          }", "-        List<OpenDefinitionsDocument> lod = getOpenDefinitionsDocuments();", "-        for (OpenDefinitionsDocument d: lod) {", "-          if (d.isAuxiliaryFile()) {", "-              File f;", "-              String classname = d.getQualifiedClassName();", "-              try {", "-                f = d.getFile();", "-                lof.add(f);", "-                los.add(classname);", "-              }", "-              catch(FileMovedException fme) {", "-                // the file's not on disk, but send it in anyways", "-                f = fme.getFile();", "-                lof.add(f);", "-                los.add(classname);", "-              }", "-              catch(IllegalStateException e) {", "-                // it doesn't have a file, so don't try and test it...", "-              }", "-            catch(ClassNameNotFoundException e) {", "-              // don't add it if we don't have a classname", "-        getJUnitModel().junitAll(los, lof);", "-      ", "-      /**", "-       * Jars all the files in this project", "-       */", "-      public void jarAll() {", "-        //********************************", "-      }", "-      ", "-      public ClasspathVector getExtraClasspath() {", "-        return _projExtraClasspath;", "-      }", "-      ", "-      public void setExtraClasspath(ClasspathVector cp) {", "-        _projExtraClasspath = cp;", "-      }", "-    };"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b91177950750a9bdf4ac6c0cfa48399c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/DefinitionsPane.java", "commitBeforeChange": "3c18a1d03b53a699adfbc2df00845e9d60f9d1f5", "commitAfterChange": "4ec6eda5e5d4bd8e2b6e61afae08eb8548f8c4b5", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "   public void processKeyEvent(KeyEvent e)", "signatureAfterChange": "   public void processKeyEvent(KeyEvent e)", "diff": ["-    KeyStroke ks = KeyStroke.getKeyStrokeForEvent(e);", "-    Action a = KeyBindingManager.Singleton.get(ks);", "-    // Don't perform the action if the keystroke is NULL_KEYSTROKE,", "-    //  which can get generated by some Windows keys", "-    if ((ks != KeyStrokeOption.NULL_KEYSTROKE) && (a != null)) {", "-//      System.out.println(\"Keystroke was null\");", "-      endCompoundEdit();", "-      // Performs the action a", "-      SwingUtilities.notifyAction(a, ks, e, e.getSource(), e.getModifiers());", "-", "-      // Make sure we don't consume it again", "-      e.consume();", "-    }", "-    else {", "-      // Allows one step undoing of the keystrokes defined on the keymap (e.g. enter, tab, '{', '}', ':').", "-      Keymap km = getKeymap();", "-", "-      if (km.isLocallyDefined(ks) || km.isLocallyDefined(KeyStroke.getKeyStroke(ks.getKeyChar()))) {", "-        // We're breaking up compound edits at the granularity of \"enter\"'s.", "-        if (e.getKeyCode() == KeyEvent.VK_ENTER) {", "-          endCompoundEdit();", "-        }", "-", "-        CompoundUndoManager undoMan = _doc.getUndoManager();", "-        int key = undoMan.startCompoundEdit();", "-//        System.out.println(\"supering 1 \" + isAltF4);", "-        super.processKeyEvent(e);", "-        undoMan.endCompoundEdit(key);", "-//        e.consume();", "+    if(_mainFrame.getAllowKeyEvents()){", "+      KeyStroke ks = KeyStroke.getKeyStrokeForEvent(e);", "+      Action a = KeyBindingManager.Singleton.get(ks);", "+      // Don't perform the action if the keystroke is NULL_KEYSTROKE,", "+      //  which can get generated by some Windows keys", "+      if ((ks != KeyStrokeOption.NULL_KEYSTROKE) && (a != null)) {", "+        //      System.out.println(\"Keystroke was null\");", "+        endCompoundEdit();", "+        // Performs the action a", "+        SwingUtilities.notifyAction(a, ks, e, e.getSource(), e.getModifiers());", "+        ", "+        // Make sure we don't consume it again", "+        e.consume();", "-        // The following conditional fixes bug #676586 by ignoring typed events when the meta key is down", "-        // and fixes bug #905405 \"Undo Alt+Anything Causes Exception\" by ignoring typed events when", "-        // the alt key is down.", "-        if ((((e.getModifiers() & InputEvent.META_MASK) != 0) || ((e.getModifiers() & InputEvent.ALT_MASK) != 0))", "-              && e.getKeyCode() == KeyEvent.VK_UNDEFINED) {", "-//          System.out.println(\"not supering 1 \" + isAltF4);", "-          return;", "-        }", "-", "-        // The following conditional fixes ease of use issue 693253 by checking if a typed event is", "-        // shift-delete or shift-backspace and then performing a delete or backspace operation,", "-        // respectively", "-        if ((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) {", "-          int newModifiers = e.getModifiers() & ~(InputEvent.SHIFT_MASK);", "-", "-          KeyStroke newKs = KeyStroke.getKeyStroke(ks.getKeyCode(), newModifiers, ks.isOnKeyRelease());", "-          String name = KeyBindingManager.Singleton.getName(newKs);", "-", "-          if (name != null && (name.equals(\"Delete Previous\") || name.equals(\"Delete Next\"))) {", "+        // Allows one step undoing of the keystrokes defined on the keymap (e.g. enter, tab, '{', '}', ':').", "+        Keymap km = getKeymap();", "+        ", "+        if (km.isLocallyDefined(ks) || km.isLocallyDefined(KeyStroke.getKeyStroke(ks.getKeyChar()))) {", "+          // We're breaking up compound edits at the granularity of \"enter\"'s.", "+          if (e.getKeyCode() == KeyEvent.VK_ENTER) {", "-            // We are unsure about the third and fourth arguments (e and e.getSource()); we simply", "-            // reuse the original values", "-            SwingUtilities.notifyAction(KeyBindingManager.Singleton.get(newKs), newKs, e, e.getSource(), newModifiers);", "-            e.consume();", "-//            System.out.println(\"not supering 2 \" + isAltF4);", "+          }", "+          ", "+          CompoundUndoManager undoMan = _doc.getUndoManager();", "+          int key = undoMan.startCompoundEdit();", "+          //        System.out.println(\"supering 1 \" + isAltF4);", "+          super.processKeyEvent(e);", "+          undoMan.endCompoundEdit(key);", "+          //        e.consume();", "+        }", "+        else {", "+          // The following conditional fixes bug #676586 by ignoring typed events when the meta key is down", "+          // and fixes bug #905405 \"Undo Alt+Anything Causes Exception\" by ignoring typed events when", "+          // the alt key is down.", "+          if ((((e.getModifiers() & InputEvent.META_MASK) != 0) || ((e.getModifiers() & InputEvent.ALT_MASK) != 0))", "+                && e.getKeyCode() == KeyEvent.VK_UNDEFINED) {", "+            //          System.out.println(\"not supering 1 \" + isAltF4);", "-        }", "-", "-        // If the KeyEvent is not a pressed event, process it before we do", "-        // granular undo or _inCompoundEdit may get set incorrectly.", "-        // This code breaks Alt-F4, and may break other system keybindings", "-        // since the event is consumed by us.  For now, just check Alt-F4.", "-        if (e.getID() != KeyEvent.KEY_TYPED) {", "-//          System.out.println(\"supering 2 \" + isAltF4);", "-//          boolean isAltF4 = e.getKeyCode() == KeyEvent.VK_F4 && (KeyEvent.ALT_MASK & e.getModifiers()) != 0;", "-//          if (!isAltF4) {", "-          super.processKeyEvent(e);", "-//            e.consume();", "-//          }", "-          return;", "-        }", "-", "-        // backspace deletes twice without this check, overrides other keystrokes", "-        // that use the mask modifier", "-        if (((ks.getModifiers() & mask) == 0) && ks.getKeyChar() != '\\b') {", "-          int _keyval = (int) e.getKeyChar();", "-          if (_keyval >= 32 && _keyval <= 126) {", "-            CompoundUndoManager undoMan = _doc.getUndoManager();", "-            if (!_inCompoundEdit) {", "-              _inCompoundEdit = true;", "-              _compoundEditKey = undoMan.startCompoundEdit();", "-              getUndoAction().updateUndoState();", "-              getRedoAction().updateRedoState();", "-              //super.processKeyEvent(e);", "+          ", "+          // The following conditional fixes ease of use issue 693253 by checking if a typed event is", "+          // shift-delete or shift-backspace and then performing a delete or backspace operation,", "+          // respectively", "+          if ((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) {", "+            int newModifiers = e.getModifiers() & ~(InputEvent.SHIFT_MASK);", "+            ", "+            KeyStroke newKs = KeyStroke.getKeyStroke(ks.getKeyCode(), newModifiers, ks.isOnKeyRelease());", "+            String name = KeyBindingManager.Singleton.getName(newKs);", "+            ", "+            if (name != null && (name.equals(\"Delete Previous\") || name.equals(\"Delete Next\"))) {", "+              endCompoundEdit();", "+              // We are unsure about the third and fourth arguments (e and e.getSource()); we simply", "+              // reuse the original values", "+              SwingUtilities.notifyAction(KeyBindingManager.Singleton.get(newKs), newKs, e, e.getSource(), newModifiers);", "+              e.consume();", "+              //            System.out.println(\"not supering 2 \" + isAltF4);", "+              return;", "-//            else {", "-//              UndoableEdit lastEdit = undoMan.getNextUndo();", "-//              lastEdit.die();", "-//              _compoundEditKey = undoMan.startCompoundEdit();", "-//              super.processKeyEvent(e);", "-//              undoMan.addEdit(lastEdit);", "-//              undoMan.endCompoundEdit(_compoundEditKey);", "-//            }", "-//          System.out.println(\"supering 3 \" + isAltF4);", "-          super.processKeyEvent(e);", "+          ", "+          // If the KeyEvent is not a pressed event, process it before we do", "+          // granular undo or _inCompoundEdit may get set incorrectly.", "+          // This code breaks Alt-F4, and may break other system keybindings", "+          // since the event is consumed by us.  For now, just check Alt-F4.", "+          if (e.getID() != KeyEvent.KEY_TYPED) {", "+            //          System.out.println(\"supering 2 \" + isAltF4);", "+            //          boolean isAltF4 = e.getKeyCode() == KeyEvent.VK_F4 && (KeyEvent.ALT_MASK & e.getModifiers()) != 0;", "+            //          if (!isAltF4) {", "+            super.processKeyEvent(e);", "+            //            e.consume();", "+            //          }", "+            return;", "+          }", "+          ", "+          // backspace deletes twice without this check, overrides other keystrokes", "+          // that use the mask modifier", "+          if (((ks.getModifiers() & mask) == 0) && ks.getKeyChar() != '\\b') {", "+            int _keyval = (int) e.getKeyChar();", "+            if (_keyval >= 32 && _keyval <= 126) {", "+              CompoundUndoManager undoMan = _doc.getUndoManager();", "+              if (!_inCompoundEdit) {", "+                _inCompoundEdit = true;", "+                _compoundEditKey = undoMan.startCompoundEdit();", "+                getUndoAction().updateUndoState();", "+                getRedoAction().updateRedoState();", "+                //super.processKeyEvent(e);", "+              }", "+              //            else {", "+              //              UndoableEdit lastEdit = undoMan.getNextUndo();", "+              //              lastEdit.die();", "+              //              _compoundEditKey = undoMan.startCompoundEdit();", "+              //              super.processKeyEvent(e);", "+              //              undoMan.addEdit(lastEdit);", "+              //              undoMan.endCompoundEdit(_compoundEditKey);", "+              //            }", "+            }", "+            //          System.out.println(\"supering 3 \" + isAltF4);", "+            super.processKeyEvent(e);", "+          }", "+          //        else {", "+          //          e.consume();", "+          //          _inCompoundEdit = false;", "+          //        }", "-//        else {", "-//          e.consume();", "-//          _inCompoundEdit = false;", "-//        }"]}], "num": 29872}