{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6d3e8ffa11bcddae6f7ef550e35c42f3", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "05b5eccc63fbf1488b9b75d31936ae89", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/InterfaceBodyFullJavaVisitor.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "      public Void forAbstractMethodDef(AbstractMethodDef that)", "signatureAfterChange": "      public Void forAbstractMethodDef(AbstractMethodDef that)", "diff": ["-    MethodData md = createMethodData(that, _symbolData);", "+    assert _enclosing != null;", "+    ", "+      // Process type parameters", "+    TypeParameter[] tps = that.getTypeParams();", "+", "+    // TODO !!! pass genericTypes as a parameter to createMethod and critical submethods.  The scope of the", "+    // new generic types table includes all of createMethodData processing, notably processing the return type.", "+    // Passing an extended generic types table to BodyBodyFullJavaVisitor is insufficient", "+      ", "+    // Save a snapshot of _genericTypes", "+    HashMap<String, SymbolData> oldGenericTypes = _genericTypes;", "+    ", "+    // Rebind _genericTypes to a shallow copy of itself for use in processing this method. The temporary variable copy", "+    // gets around a bug in javac in processing the SuppressWarnings statement.", "+    @SuppressWarnings(\"unchecked\")", "+    HashMap<String, SymbolData> copy = (HashMap<String, SymbolData>)_genericTypes.clone();", "+    _genericTypes = copy;", "+    ", "+    if (tps != null) {  // extend genericTypes by new type variable bindings", "+      for (TypeParameter tp: tps) {", "+        final String typeName = tp.getVariable().getName();", "+        final String boundName = tp.getBound().getName();", "+        SymbolData boundSD = _identifyType(boundName, that.getSourceInfo(), _enclosingClassName);", "+        if (boundSD == null) { // create a dummy SymbolData ", "+          boundSD = symbolTable.get(\"java.lang.Object\"); //  TODO: could create a separate unbound type variable singleton class?", "+//        System.err.println(\"Creating dummy SymbolData for bounding type \" + typeName + \" in inner class \" + name);", "+          // TODO!  !!!!! Create an appropriate fixUp mechanism", "+        }", "+//        System.err.println(\"In method \" + _enclosing + \".\" + that.getName().getText() + \", type \" + typeName ", "+//                             + \" is bound to \" + boundSD);", "+        _genericTypes.put(typeName, boundSD);", "+      }", "+    }", "+    ", "+    MethodData md = createMethodData(that, _enclosing);", "-    String className = getUnqualifiedClassName(_symbolData.getName());", "+    String className = getUnqualifiedClassName(_enclosing.getName());", "-    else _symbolData.addMethod(md);", "+    else _enclosing.addMethod(md);", "+", "+    _genericTypes = oldGenericTypes;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9fda51d06dcc51c6a3719f0c80546410", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyFullJavaVisitor.java", "commitBeforeChange": "f2098dc3df82d0fc4c7e17fd5e93823851356d75", "commitAfterChange": "02bb605d31bd77f6715d3d33be9295c5381484e0", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "   public Void forAbstractMethodDef(AbstractMethodDef that)", "signatureAfterChange": "   public Void forAbstractMethodDef(AbstractMethodDef that)", "diff": ["+    assert _enclosing != null;", "+    ", "+    // Process type parameters", "+    TypeParameter[] tps = that.getTypeParams();", "+", "+    // TODO !!! pass genericTypes as a parameter to createMethod and critical submethods.  The scope of the", "+    // new generic types table includes all of createMethodData processing, notably processing the return type.", "+    // Passing an extended generic types table to BodyBodyFullJavaVisitor is insufficient", "+      ", "+    // Save a snapshot of _genericTypes", "+    HashMap<String, SymbolData> oldGenericTypes = _genericTypes;", "+    ", "+    // Rebind _genericTypes to a shallow copy of itself for use in processing this method. The temporary variable copy", "+    // gets around a bug in javac in processing the SuppressWarnings statement.", "+    @SuppressWarnings(\"unchecked\")", "+    HashMap<String, SymbolData> copy = (HashMap<String, SymbolData>)_genericTypes.clone();", "+    _genericTypes = copy;", "+    ", "+    if (tps != null) {  // extend genericTypes by new type variable bindings", "+      for (TypeParameter tp: tps) {", "+        final String typeName = tp.getVariable().getName();", "+        final String boundName = tp.getBound().getName();", "+        SymbolData boundSD = _identifyType(boundName, that.getSourceInfo(), _enclosingClassName);", "+        if (boundSD == null) { // create a dummy SymbolData ", "+          boundSD = symbolTable.get(\"java.lang.Object\"); //  TODO: could create a separate unbound type variable singleton class?", "+//        System.err.println(\"Creating dummy SymbolData for bounding type \" + typeName + \" in inner class \" + name);", "+          // TODO!  !!!!! Create an appropriate fixUp mechanism", "+        }", "+//        System.err.println(\"In method \" + _enclosing + \".\" + that.getName().getText() + \", type \" + typeName ", "+//                             + \" is bound to \" + boundSD);", "+        _genericTypes.put(typeName, boundSD);", "+      }", "+    }", "+    ", "+    _genericTypes = oldGenericTypes;"]}], "num": 4687}