{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b69747371113150091486d1a2d7aa18e", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2882533029ea08ed9fc76c9ed265cb94", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractGlobalModel.java", "commitBeforeChange": "fb266d92ba9efd43e20ccabcb8837490fbeddaea", "commitAfterChange": "9b317c4ea1656d56bf74b4b1688b4337b5b40277", "methodNumberBeforeChange": 322, "methodNumberAfterChange": 323, "signatureBeforeChange": "     protected DDReconstructor makeReconstructor()", "signatureAfterChange": "     protected DDReconstructor makeReconstructor()", "diff": ["-        private volatile boolean _positionsMade = false;", "-        ", "-        /** Reconstructs this document except for embedded positions.  Assumes _cacheLock is held.", "-          * @param image the bytes in the cached file image for this document. ", "-          */", "-          else if (_file != null) {", "+          else if (! isUntitled()) {", "-          ", "-          _positionsMade = false;", "+", "+          // re-create and update all positions", "+          newDefDoc.setWrappedPositionOffsets(_positions);", "-", "-        /** Reconstructs the embedded positions for this document.  Synchronized*/", "-        public void makePositions() { ", "-          if (_positionsMade) return;", "-          synchronized(this) {", "-            if (_positionsMade) return; // double-check works for volatile fields in Java 1.4 and later code", "-            _positionsMade = true;", "-          }", "-          try { getDocument().setWrappedPositionOffsets(_positions); }", "-          catch(Exception e) { /* ignore */ } // omitted positions are not fatal", "-        }", "+        ", "+//        private volatile boolean _positionsMade = false;", "+//        ", "+//        /** Reconstructs this document except for embedded positions.  Assumes _cacheLock is held.", "+//          * @param image the bytes in the cached file image for this document. ", "+//          */", "+//        public DefinitionsDocument make() throws IOException, BadLocationException, FileMovedException {  // should sync on _file", "+//          ", "+////          System.err.println(\"DDReconstructor.make() called on \" + ConcreteOpenDefDoc.this);", "+//          DefinitionsDocument newDefDoc = new DefinitionsDocument(_notifier);", "+//          newDefDoc.setOpenDefDoc(ConcreteOpenDefDoc.this);", "+//          ", "+//          if (_image != null) {", "+//            _editorKit.read(new InputStreamReader(new ByteArrayInputStream(_image)), newDefDoc, 0);", "+//            _log.log(\"Reading from image for \" + _file + \" containing \" + _image.length + \" chars\");", "+//          }", "+//          else if (! isUntitled()) {", "+//            final InputStreamReader reader = new FileReader(_file);", "+//            _editorKit.read(reader, newDefDoc, 0);", "+//            reader.close(); // win32 needs readers closed explicitly!", "+//          }", "+//          _loc = Math.min(_loc, newDefDoc.getLength()); // make sure not past end", "+//          _loc = Math.max(_loc, 0); // make sure not less than 0", "+//          newDefDoc.setCurrentLocation(_loc);", "+//          for (DocumentListener d : _list) {", "+//            if (d instanceof DocumentUIListener) newDefDoc.addDocumentListener(d);", "+//          }", "+//          for (FinalizationListener<DefinitionsDocument> l: _finalListeners) {", "+//            newDefDoc.addFinalizationListener(l);", "+//          }", "+//          ", "+//          _positionsMade = false;", "+//          ", "+//          newDefDoc.resetModification();  // Why is this necessary? A reconstructed document is already unmodified.", "+//", "+//          //            tempDoc.setUndoManager(_undo);", "+//          assert ! newDefDoc.isModifiedSinceSave();", "+////          System.err.println (\"_packageName in make() = \" + _packageName);", "+////          System.err.println(\"tempDoc.getLength() = \" + tempDoc.getLength());", "+//          _packageName = newDefDoc.getPackageName();", "+////          System.err.println(\"make() returned \" + newDefDoc);", "+//          return newDefDoc;", "+//", "+//        }", "+        ", "+//        /** Reconstructs the embedded positions for this document.  Synchronized*/", "+//        public void makePositions() { ", "+//          if (_positionsMade) return;", "+//          synchronized(this) {", "+//            if (_positionsMade) return; // double-check works for volatile fields in Java 1.4 and later code", "+//            _positionsMade = true;", "+//          }", "+//          try { getDocument().setWrappedPositionOffsets(_positions); }", "+//          catch(Exception e) { /* ignore */ } // omitted positions are not fatal", "+//        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c7fe79050077cc4bbcaebcedbb97fb93", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractGlobalModel.java", "commitBeforeChange": "60280b438c8e4415d1e3fb7cae7f2c5284f4ab7d", "commitAfterChange": "f1e49fbbed5c92cb9e03198e54bd2a4b521e7d76", "methodNumberBeforeChange": 156, "methodNumberAfterChange": 156, "signatureBeforeChange": "   protected void saveAllFilesHelper(FileSaveSelector com) throws IOException", "signatureAfterChange": "   protected void saveAllFilesHelper(FileSaveSelector com) throws IOException", "diff": ["-    ", "-    for (final OpenDefinitionsDocument doc: getOpenDefinitionsDocuments()) {  // getOpen... makes a copy", "-      // do not force Untitled document to be saved if projectActive() or unmodified", "-      if (doc.isUntitled() && (isProjActive || ! doc.isModifiedSinceSave())) continue;  ", "-      aboutToSaveFromSaveAll(doc);", "-      doc.saveFile(com);", "+", "+    List<OpenDefinitionsDocument> docsToWrite = getOpenDefinitionsDocuments();", "+    while(docsToWrite.size()>0) {", "+      ArrayList<OpenDefinitionsDocument> readOnlyDocs = new ArrayList<OpenDefinitionsDocument>();", "+      for (final OpenDefinitionsDocument doc: docsToWrite) {  // getOpen... makes a copy", "+        // do not force Untitled document to be saved if projectActive() or unmodified", "+        if (doc.isUntitled() && (isProjActive || ! doc.isModifiedSinceSave())) continue;", "+        try {", "+          if (doc.getFile().canWrite()) {", "+            // file is writable, save", "+            aboutToSaveFromSaveAll(doc);", "+            doc.saveFile(com);", "+          }", "+          else {", "+            // file is read-only, ask user about it", "+            readOnlyDocs.add(doc);", "+          }", "+        }", "+        catch(FileMovedException fme) {", "+          // file was moved, but we should still be able to save it", "+          aboutToSaveFromSaveAll(doc);", "+          doc.saveFile(com);", "+        }", "+      }", "+      docsToWrite.clear();", "+      if (readOnlyDocs.size()>0) {", "+        ArrayList<File> files = new ArrayList<File>();", "+        for(OpenDefinitionsDocument odd: readOnlyDocs) {", "+          try { ", "+            File roFile = odd.getFile();", "+            files.add(roFile);", "+          }", "+          catch(FileMovedException fme) { /* ignore, don't know what to do here */ }", "+        }", "+        File[] res = _notifier.filesReadOnly(com, files.toArray(new File[files.size()]));", "+        HashSet<File> rewriteFiles = new HashSet<File>(java.util.Arrays.asList(res));", "+        for(OpenDefinitionsDocument odd: readOnlyDocs) {", "+          try {", "+            File roFile = odd.getFile();", "+            if (rewriteFiles.contains(roFile)) {", "+              docsToWrite.add(odd);", "+              // try to make the file writable", "+              // strangely enough, there is a File.setReadOnly() method, but", "+              // no built-in way to make the file writable", "+              // Sun recommends deleting the read-only file (does that work?)", "+              File backup = new File(roFile.getAbsolutePath()+\"~\");", "+              boolean noBackup = true;", "+              if (backup.exists()) {", "+                try {", "+                  noBackup = backup.delete();", "+                }", "+                catch(SecurityException se) {", "+                  noBackup = false;", "+                }", "+              }", "+              if (noBackup) {", "+                try {", "+                  noBackup = roFile.renameTo(backup);", "+                  roFile.createNewFile();", "+                }", "+                catch(SecurityException se) {", "+                  noBackup = false;", "+                }", "+                catch(IOException ioe) { }", "+                try {", "+                  roFile.createNewFile();", "+                }", "+                catch(SecurityException se) { }", "+                catch(IOException ioe) { }", "+              }", "+              if (!noBackup) {", "+                try {", "+                  roFile.delete();", "+                }", "+                catch(SecurityException se) { /* can't do anything about it */ }", "+              }", "+              try {", "+                edu.rice.cs.plt.io.IOUtil.copyFile(backup, roFile);", "+              }", "+              catch(SecurityException se) {", "+                /* can't do anything about it */", "+              }", "+              catch(IOException ioe) {", "+                /* can't do anything about it */", "+              }", "+            }", "+          }", "+          catch(FileMovedException fme) { /* ignore, don't know what to do here */ }", "+        }", "+      }"]}], "num": 7284}