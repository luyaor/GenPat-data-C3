{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5de42c6689aa2234fce8959811da0285", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5bf48539476d1449c76cbfd552977ce1", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "f835199d645f480bb352cc51cff6dc5ae32e7dc4", "commitAfterChange": "f25bc20d2dd4058b4cf2bf5f693569e62fb40d6b", "methodNumberBeforeChange": 204, "methodNumberAfterChange": 203, "signatureBeforeChange": "   private ConstraintSet inferFromEqual(final Type arg, final Type param,                                        final Set<? extends VariableType> vars,                                         final RecursionStack3<Type, Type, InferenceMode> stack)", "signatureAfterChange": "              private Boolean checkBoundedSymbol(Type t, final BoundedSymbol s)", "diff": ["-   */", "-  private ConstraintSet inferFromEqual(final Type arg, final Type param,", "-                                       final Set<? extends VariableType> vars, ", "-                                       final RecursionStack3<Type, Type, InferenceMode> stack) {", "-    //debug.logValues(new String[]{ \"arg\", \"param\" }, wrap(arg), wrap(param));", "-    if (vars.contains(param)) {", "-      return param.apply(new TypeAbstractVisitor<ConstraintSet>() {", "-        public ConstraintSet defaultCase(Type param) { return UNSATISFIABLE_CONSTRAINTS; }", "-        ", "-        @Override public ConstraintSet forArrayType(ArrayType param) {", "-          if (arg instanceof ArrayType) { ", "-            return inferFromEqual(((ArrayType) arg).ofType(), param.ofType(), vars, stack);", "-          }", "-          else { return UNSATISFIABLE_CONSTRAINTS; }", "-        }", "-        ", "-        @Override public ConstraintSet forParameterizedClassType(ParameterizedClassType param) {", "-          if (arg instanceof ParameterizedClassType) {", "-            ParameterizedClassType argCast = (ParameterizedClassType) arg;", "-            if (param.ofClass().equals(argCast.ofClass())) {", "-              ConstraintSet result = EMPTY_CONSTRAINTS;", "-              for (Pair<Type, Type> pair : IterUtil.zip(argCast.typeArguments(), param.typeArguments())) {", "-                result = result.and(inferFromEqual(pair.first(), pair.second(), vars, stack));", "-            else { return UNSATISFIABLE_CONSTRAINTS; }", "-          else { return UNSATISFIABLE_CONSTRAINTS; }", "-        }", "-        ", "-        @Override public ConstraintSet forVariableType(VariableType param) {", "-          if (vars.contains(param)) {", "-            return EMPTY_CONSTRAINTS.andLowerBound(param, arg).andUpperBound(param, arg);", "-          else { return UNSATISFIABLE_CONSTRAINTS; }", "-        }", "-        ", "-        @Override public ConstraintSet forIntersectionType(IntersectionType param) {", "-          if (arg instanceof IntersectionType) {", "-            Iterable<? extends Type> argSups = ((IntersectionType) arg).ofTypes();", "-            if (IterUtil.sizeOf(argSups) != IterUtil.sizeOf(param.ofTypes())) {", "-              return UNSATISFIABLE_CONSTRAINTS;", "-            }", "-            else {", "-              ConstraintSet result = UNSATISFIABLE_CONSTRAINTS;", "-              for (Iterable<Type> paramSups : PermutationIterable.make(param.ofTypes())) {", "-                ConstraintSet thisPerm = EMPTY_CONSTRAINTS;", "-                for (Pair<Type, Type> pair : IterUtil.zip(argSups, paramSups)) {", "-                  thisPerm = thisPerm.and(inferFromEqual(pair.first(), pair.second(), vars, stack));", "-                  if (!thisPerm.isSatisfiable()) { break; }", "-                result = result.or(thisPerm);", "-          else { return UNSATISFIABLE_CONSTRAINTS; }", "-        }", "-        ", "-        @Override public ConstraintSet forWildcard(final Wildcard param) {", "-          if (arg instanceof Wildcard) {", "-            Thunk<ConstraintSet> recurOnBounds = new Thunk<ConstraintSet>() {", "-              public ConstraintSet value() {", "-                Wildcard argCast = (Wildcard) arg;", "-                ConstraintSet result = inferFromEqual(argCast.symbol().upperBound(), param.symbol().upperBound(),", "-                                                      vars, stack);", "-                if (result.isSatisfiable()) { ", "-                  result = result.and(inferFromEqual(argCast.symbol().lowerBound(), param.symbol().lowerBound(),", "-                                                     vars, stack));", "-            };", "-            return stack.apply(recurOnBounds, EMPTY_CONSTRAINTS, arg, param, InferenceMode.EQUAL);", "-          else { return UNSATISFIABLE_CONSTRAINTS; }", "-      });", "-    }", "-    else {", "-      return (isEqual(arg, param)) ? EMPTY_CONSTRAINTS : UNSATISFIABLE_CONSTRAINTS;", "-    }", "+      ", "+      private Boolean checkBoundedSymbol(Type t, final BoundedSymbol s) {", "+        final TypeVisitor<Boolean> visitor = this; // handles this shadowing", "+        // wildcards here aren't recursive, so don't need to be handled with a stack,", "+        // but it doesn't hurt to cover the more general case", "+        Thunk<Boolean> handleBounds = new Thunk<Boolean>() {", "+          public Boolean value() {", "+            return s.lowerBound().apply(visitor) || s.upperBound().apply(visitor);", "+          }", "+        };", "+        return _stack.apply(handleBounds, false, t);", "+      }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fcbd338ce239e5d94f47c5541afbfaeb", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/ExtendedTypeSystem.java", "commitBeforeChange": "f835199d645f480bb352cc51cff6dc5ae32e7dc4", "commitAfterChange": "f25bc20d2dd4058b4cf2bf5f693569e62fb40d6b", "methodNumberBeforeChange": 115, "methodNumberAfterChange": 200, "signatureBeforeChange": "      private boolean containsInferenceVariable(Type t, final Set<? extends VariableType> vars,                                              final RecursionStack<Type> stack)", "signatureAfterChange": "       @Override public Boolean forVariableType(VariableType t)", "diff": ["-  ", "-  private boolean containsInferenceVariable(Type t, final Set<? extends VariableType> vars, ", "-                                            final RecursionStack<Type> stack) {", "-    return t.apply(new TypeAbstractVisitor<Boolean>() {", "-      public Boolean defaultCase(Type t) { return false; }", "-      ", "-      @Override public Boolean forArrayType(ArrayType t) { ", "-        return containsInferenceVariable(t.ofType(), vars, stack);", "-      }", "-      ", "-      @Override public Boolean forParameterizedClassType(ParameterizedClassType t) { ", "-        return checkList(t.typeArguments());", "-      }", "-      ", "-      @Override public Boolean forIntersectionType(IntersectionType t) { ", "-        return checkList(t.ofTypes());", "-      }", "-      ", "-      private Boolean checkList(Iterable<? extends Type> types) {", "-        for (Type t : types) { ", "-          if (containsInferenceVariable(t, vars, stack)) { return true; }", "-        }", "-        return false;", "-      }", "-      ", "-      @Override public Boolean forVariableType(final VariableType t) {", "-        if (vars.contains(t)) { return true; }", "-        else {", "-          Thunk<Boolean> handleBounds = new Thunk<Boolean>() {", "-            public Boolean value() {", "-              return containsInferenceVariable(t.symbol().lowerBound(), vars, stack) ||", "-                containsInferenceVariable(t.symbol().upperBound(), vars, stack);", "-            }", "-          };", "-          return stack.apply(handleBounds, false, t);", "-        }", "-      }", "-      ", "-      @Override public Boolean forWildcard(final Wildcard t) {", "-        Thunk<Boolean> handleBounds = new Thunk<Boolean>() {", "-          public Boolean value() {", "-            return containsInferenceVariable(t.symbol().lowerBound(), vars, stack) ||", "-              containsInferenceVariable(t.symbol().upperBound(), vars, stack);", "-          }", "-        };", "-        return stack.apply(handleBounds, false, t);", "-      }", "-      ", "-    });", "-  }", "+      @Override public Boolean forBoundType(BoundType t) {  return checkList(t.ofTypes()); }", "+      @Override public Boolean forVariableType(VariableType t) {", "+        return _vars.contains(t) || checkBoundedSymbol(t, t.symbol());", "+      }"]}], "num": 16936}