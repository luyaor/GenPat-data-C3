{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3e9840d2ed8df02e2854cdf6e4a19e28", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4dc985b2c16656c5c8ac299dfad77532", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/debug/DebugManager.java", "commitBeforeChange": "90f3515e98e577591a6618f1cf8f59bee5e6c509", "commitAfterChange": "1acb7e79f21833d9f8611e81be6afdbc403d9516", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": "    private void _updateWatches()", "signatureAfterChange": "    private void _updateWatches()", "diff": ["-    int stackIndex = 0;", "-    StackFrame currFrame = null;", "-    List frames = null;", "+      int stackIndex = 0;", "+      StackFrame currFrame = null;", "+      List frames = null;", "-    }", "-    catch (IncompatibleThreadStateException itse) {", "-      return;", "-    }", "-    currFrame = (StackFrame) frames.get(stackIndex);", "-    stackIndex++;", "-    Location location = currFrame.location();", "-    ReferenceType rt = location.declaringType();", "-    for (int i = 0; i < _watches.size(); i++) {", "-      WatchData currWatch = _watches.elementAt(i);", "-      String currName = currWatch.getName();", "-      String currValue = currWatch.getValue();", "-      // check for \"this\"", "-      if (currName.equals(\"this\")) {", "-        ObjectReference obj = currFrame.thisObject();", "-        if (obj != null) {", "-          currWatch.setValue(obj);", "-          currWatch.setType(obj.type());", "+      currFrame = (StackFrame) frames.get(stackIndex);", "+      stackIndex++;", "+      Location location = currFrame.location();", "+      ReferenceType rt = location.declaringType();", "+      for (int i = 0; i < _watches.size(); i++) {", "+        WatchData currWatch = _watches.elementAt(i);", "+        String currName = currWatch.getName();", "+        String currValue = currWatch.getValue();", "+        // check for \"this\"", "+        if (currName.equals(\"this\")) {", "+          ObjectReference obj = currFrame.thisObject();", "+          if (obj != null) {", "+            currWatch.setValue(_getValue(obj));", "+            currWatch.setType(obj.type());", "+          }", "+          else {", "+            currWatch.setValue(WatchUndefinedValue.Singleton);", "+            currWatch.setType(null);", "+          }", "+          continue;", "+        } ", "+        //List frames = null;", "+        LocalVariable localVar = null;", "+        try {", "+          localVar = currFrame.visibleVariableByName(currName);", "-        else {", "-          currWatch.setValue(WatchUndefinedValue.Singleton);", "-          currWatch.setType(null);", "+        catch (AbsentInformationException aie) {", "-        continue;", "-      } ", "-      //List frames = null;", "-      LocalVariable localVar = null;", "-      try {", "-        localVar = currFrame.visibleVariableByName(currName);", "-      }", "-      catch (AbsentInformationException aie) {", "-      }", "-      ", "-      ReferenceType outerRt = rt;", "-      // if the variable being watched is not a local variable, check if it's a field", "-      if (localVar == null) {", "-        Field field = outerRt.fieldByName(currName);", "-        // if the variable is not a field either, it's not defined in this ", "-        // ReferenceType's scope, keep going further out in scope.", "-        String className = outerRt.name();", "-        while (field == null) {", "+        ReferenceType outerRt = rt;", "+        // if the variable being watched is not a local variable, check if it's a field", "+        if (localVar == null) {", "+          Field field = outerRt.fieldByName(currName);", "-          // crop off the $ if there is one and anything after it", "-          int indexOfDollar = className.lastIndexOf('$');    ", "-          if (indexOfDollar > -1) {", "-            className = className.substring(0, indexOfDollar);", "-          }", "-          else {", "-            // There is no $ in the className, we're at the outermost class and the", "-            // field still was not found", "-            break;", "-          }", "-          outerRt = (ReferenceType)_vm.classesByName(className).get(0);", "-          if (outerRt == null) {", "-            break;", "-          }", "-          field = outerRt.fieldByName(currName);", "-        }", "-        if (field != null) {", "-          // check if the field is static", "-          if (field.isStatic()) {", "-            currWatch.setValue(outerRt.getValue(field));", "-            try {", "-              currWatch.setType(field.type());", "+          // if the variable is not a field either, it's not defined in this ", "+          // ReferenceType's scope, keep going further out in scope.", "+          String className = outerRt.name();", "+          while (field == null) {", "+            ", "+            // crop off the $ if there is one and anything after it", "+            int indexOfDollar = className.lastIndexOf('$');    ", "+            if (indexOfDollar > -1) {", "+              className = className.substring(0, indexOfDollar);", "-            catch (ClassNotLoadedException cnle) {", "-              currWatch.setType(null);", "+            else {", "+              // There is no $ in the className, we're at the outermost class and the", "+              // field still was not found", "+              break;", "+            outerRt = (ReferenceType)_vm.classesByName(className).get(0);", "+            if (outerRt == null) {", "+              break;", "+            }", "+            field = outerRt.fieldByName(currName);", "-          else {", "-            StackFrame outerFrame = currFrame;", "-            // the field is not static", "-            // Check if the frame represents a native or static method and", "-            // keep going down the stack frame looking for the frame that", "-            // has the same ReferenceType that we found the Field in.", "-            // This is a hack, remove it to slightly improve performance but", "-            // at the loss of ever being able to watch outer instance", "-            // fields. If unremoved, this will work sometimes, but not always.", "-            while (outerFrame.thisObject() != null && ", "-                   !outerFrame.thisObject().referenceType().equals(outerRt) &&", "-                   stackIndex < frames.size()) {", "-              outerFrame = (StackFrame) frames.get(stackIndex);", "-              stackIndex++;", "-            }", "-            if (stackIndex < frames.size() && outerFrame.thisObject() != null) { ", "-              // then we found the right stack frame", "-              currWatch.setValue(outerFrame.thisObject().getValue(field));", "+          if (field != null) {", "+            // check if the field is static", "+            if (field.isStatic()) {", "+              currWatch.setValue(_getValue(outerRt.getValue(field)));", "-              currWatch.setValue(WatchUndefinedValue.Singleton);", "-              currWatch.setType(null);", "+              StackFrame outerFrame = currFrame;", "+              // the field is not static", "+              // Check if the frame represents a native or static method and", "+              // keep going down the stack frame looking for the frame that", "+              // has the same ReferenceType that we found the Field in.", "+              // This is a hack, remove it to slightly improve performance but", "+              // at the loss of ever being able to watch outer instance", "+              // fields. If unremoved, this will work sometimes, but not always.", "+              while (outerFrame.thisObject() != null && ", "+                     !outerFrame.thisObject().referenceType().equals(outerRt) &&", "+                     stackIndex < frames.size()) {", "+                outerFrame = (StackFrame) frames.get(stackIndex);", "+                stackIndex++;", "+              }", "+              if (stackIndex < frames.size() && outerFrame.thisObject() != null) { ", "+                // then we found the right stack frame", "+                currWatch.setValue(_getValue(outerFrame.thisObject().getValue(field)));", "+                try {", "+                  currWatch.setType(field.type());", "+                }", "+                catch (ClassNotLoadedException cnle) {", "+                  currWatch.setType(null);", "+                }", "+              }", "+              else {", "+                currWatch.setValue(WatchUndefinedValue.Singleton);", "+                currWatch.setType(null);", "+              }", "+          }", "+          else {", "+            currWatch.setValue(WatchUndefinedValue.Singleton);", "+            currWatch.setType(null);", "-          currWatch.setValue(WatchUndefinedValue.Singleton);", "-          currWatch.setType(null);", "-        }", "-      }", "-      else {", "-        currWatch.setValue(currFrame.getValue(localVar));", "-        try {", "-          currWatch.setType(localVar.type());", "-        }", "-        catch (ClassNotLoadedException cnle) {", "-          currWatch.setType(null);", "+          currWatch.setValue(_getValue(currFrame.getValue(localVar)));", "+          try {", "+            currWatch.setType(localVar.type());", "+          }", "+          catch (ClassNotLoadedException cnle) {", "+            currWatch.setType(null);", "+          }", "+    catch (IncompatibleThreadStateException itse) {", "+      return;", "+    }", "+    catch (InvalidStackFrameException isfe) {", "+      return;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a98a5784d60c7defc7c11a66eb1b0972", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/config/ConfigFrame.java", "commitBeforeChange": "d8743e3580123e01ed3e3df696be4659a04c6fac", "commitAfterChange": "7a9a1a584dbea988e52c91909a30a2d54f580df1", "methodNumberBeforeChange": 51, "methodNumberAfterChange": 53, "signatureBeforeChange": "   private void _setupJUnitPanel(ConfigPanel panel)", "signatureAfterChange": "   private void _setupJUnitPanel(ConfigPanel panel)", "diff": ["-        if (edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidJUnitFile(file) ||", "-            edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidConcJUnitFile(file)) {", "+        if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidJUnitFile(file) ||", "+            edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(file)) {", "-          if (edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidJUnitFile(newFile) ||", "-              edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidConcJUnitFile(newFile) ||", "+          if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidJUnitFile(newFile) ||", "+              edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(newFile) ||", "-        if (edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidRTConcJUnitFile(file)) {", "+        if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidRTConcJUnitFile(file)) {", "-          if (edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidRTConcJUnitFile(newFile) ||", "+          if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidRTConcJUnitFile(newFile) ||", "-          setEnabled(edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidConcJUnitFile(f));", "+          setEnabled(edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(f));", "-        if ((rtFile == null) || (FileOps.NULL_FILE.equals(rtFile))) {", "-          // no entry, suggest a place", "-          File drJavaFile = FileOps.getDrJavaApplicationFile();", "-          File parent = drJavaFile.getParentFile();", "-          if (parent == null) {", "-            parent = new File(System.getProperty(\"user.dir\"));", "+        edu.rice.cs.drjava.model.junit.ConcJUnitUtils.", "+          showGenerateRTConcJUnitJarFileDialog(ConfigFrame.this,", "+                                               rtFile,", "+                                               junitLoc.getComponent().getFileFromField(),", "+                                               new Runnable1<File>() {", "+          public void run(File targetFile) {", "+            rtConcJUnitLoc.getComponent().setFileField(targetFile);", "-          rtFile = new File(parent, \"rt.concjunit.jar\"); ", "-        }", "-        JFileChooser saveChooser = new JFileChooser() {", "-          public void setCurrentDirectory(File dir) {", "-            //next two lines are order dependent!", "-            super.setCurrentDirectory(dir);", "-            setDialogTitle(\"Save:  \" + getCurrentDirectory());", "-          }", "-        };", "-        saveChooser.setPreferredSize(new Dimension(650, 410));", "-        saveChooser.setSelectedFile(rtFile);", "-        saveChooser.setFileFilter(new javax.swing.filechooser.FileFilter() {", "-          public boolean accept(File f) {", "-            return f.isDirectory() || ", "-              f.getPath().endsWith(\".jar\");", "-          }", "-          public String getDescription() { ", "-            return \"Java Archive Files (*.jar)\";", "-          }", "-        });", "-        saveChooser.setMultiSelectionEnabled(false);", "-        int rc = saveChooser.showSaveDialog(ConfigFrame.this);", "-        if (rc == JFileChooser.APPROVE_OPTION) {", "-          final File targetFile = saveChooser.getSelectedFile();", "-          int n = JOptionPane.YES_OPTION;", "-          if (targetFile.exists()) {", "-            Object[] options = {\"Yes\",\"No\"};", "-            n = JOptionPane.showOptionDialog(ConfigFrame.this,", "-                                             \"This file already exists.  Do you wish to overwrite the file?\",", "-                                             \"Confirm Overwrite\",", "-                                             JOptionPane.YES_NO_OPTION,", "-                                             JOptionPane.QUESTION_MESSAGE,", "-                                             null,", "-                                             options,", "-                                             options[1]);", "-          }", "-          if (n == JOptionPane.YES_OPTION) {", "-            ConfigFrame.this.setEnabled(false);", "-            final ProcessingDialog processingDialog =", "-              new ProcessingDialog(ConfigFrame.this, \"Creating ConcJUnit Runtime\", \"Processing, please wait.\");", "-            final JProgressBar pb = processingDialog.getProgressBar();", "-            processingDialog.setVisible(true);", "-            try {", "-              final File tmpDir = FileOps.createTempDirectory(\"DrJavaGenerateRTConcJUnitJar\");", "-              ", "-              SwingWorker worker = new SwingWorker() {", "-                volatile Boolean _success = null;", "-                Thread _processIncrementer = new Thread(new Runnable() {", "-                  public void run() {", "-                    File tmpFile = new File(tmpDir, \"rt.concjunit.jar\");", "-                    boolean indeterminate = true;", "-                    try {", "-                      while (_success == null) {", "-                        Thread.sleep(1000);", "-                        if (tmpFile.exists()) {", "-                          if (indeterminate) {", "-                            pb.setIndeterminate(false);", "-                            indeterminate = false;", "-                          }", "-                          pb.setValue((int)(100.0/(30*1024*1024)*tmpFile.length()));", "-                        }", "-                      }", "-                    }", "-                    catch(InterruptedException ie) {", "-                      pb.setIndeterminate(true);", "-                    }", "-                  }", "-                });", "-                public Object construct() {", "-                  _processIncrementer.start();", "-                  _success = edu.rice.cs.drjava.model.junit.DefaultJUnitModel.", "-                    generateRTConcJUnitJarFile(targetFile, junitLoc.getComponent().getFileFromField(), tmpDir);", "-                  return null;", "-                }", "-                ", "-                public void finished() {", "-                  pb.setValue(100);", "-                  processingDialog.setVisible(false);", "-                  processingDialog.dispose();", "-                  ConfigFrame.this.setEnabled(true);", "-                  if ((_success != null) && (_success)) {", "-                    rtConcJUnitLoc.getComponent().setFileField(targetFile);", "-                    JOptionPane.showMessageDialog(ConfigFrame.this,", "-                                                  \"Successfully generated ConcJUnit Runtime File:\\n\"+targetFile,", "-                                                  \"Generation Successful\",", "-                                                  JOptionPane.INFORMATION_MESSAGE);", "-                  }", "-                  else {", "-                    JOptionPane.showMessageDialog(ConfigFrame.this,", "-                                                  \"Could not generate ConcJUnit Runtime File:\\n\"+targetFile,", "-                                                  \"Could Not Generate\",", "-                                                  JOptionPane.ERROR_MESSAGE);", "-                  }", "-                  edu.rice.cs.plt.io.IOUtil.deleteRecursively(tmpDir);", "-                }", "-              };", "-              worker.start();", "-            }", "-            catch(IOException ioe) {", "-              JOptionPane.showMessageDialog(ConfigFrame.this,", "-                                            \"Could not generate ConcJUnit Runtime file:\\n\"+targetFile,", "-                                            \"Could Not Generate\",", "-                                            JOptionPane.ERROR_MESSAGE);", "-            }", "-          }", "-        }", "+        },", "+                                               new Runnable() { public void run() { } });", "-          setEnabled(edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidConcJUnitFile(f));", "+          setEnabled(edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(f));", "-          if (edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidConcJUnitFile(f)) {", "+          if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(f)) {", "-                edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidRTConcJUnitFile(rtf)) {", "+                edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidRTConcJUnitFile(rtf)) {", "-          else if (edu.rice.cs.drjava.model.junit.DefaultJUnitModel.isValidJUnitFile(f)) {", "+          else if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidJUnitFile(f)) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b89ddbf2e2dd65c93c0beb856ac9feb8", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ClassBodyTypeChecker.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r   public TypeData forConcreteMethodDef(ConcreteMethodDef that)", "signatureAfterChange": "   public TypeData forConcreteMethodDef(ConcreteMethodDef that)", "diff": ["-   */\r", "-  public TypeData forConcreteMethodDef(ConcreteMethodDef that) {\r", "-    final TypeData mav_result = that.getMav().visit(this);\r", "-    final TypeData[] typeParams_result = makeArrayOfRetType(that.getTypeParams().length);\r", "-    for (int i = 0; i < that.getTypeParams().length; i++) {\r", "-      typeParams_result[i] = that.getTypeParams()[i].visit(this);\r", "-    }\r", "-    final SymbolData result_result = getSymbolData(that.getResult().getName(), _symbolData, that);\r", "-    final TypeData name_result = that.getName().visit(this);\r", "-    final TypeData[] throws_result = makeArrayOfRetType(that.getThrows().length);\r", "-    for (int i = 0; i < that.getThrows().length; i++) {\r", "-      throws_result[i] = getSymbolData(that.getThrows()[i].getName(), _symbolData, that.getThrows()[i]);\r", "-    }\r", "-    // We need to match the name and params.\r", "-    // First find the correct MethodData.\r", "-    MethodData md = null;\r", "-    FormalParameter[] fParams = that.getParams();\r", "-    String[] paramTypes = new String[fParams.length];\r", "-    for (int i = 0; i < fParams.length; i++) {\r", "-      paramTypes[i] = fParams[i].getDeclarator().getType().getName();\r", "-    }\r", "-    LinkedList<MethodData> mds = _symbolData.getMethods();\r", "-    Iterator<MethodData> iter = mds.iterator();\r", "-    while (iter.hasNext()) {\r", "-      boolean match = false;\r", "-      MethodData tempMd = iter.next();\r", "-      if (tempMd.getName().equals(that.getName().getText())) {\r", "-        match = true;\r", "-\r", "-        // Check the params.\r", "-        VariableData[] vds = tempMd.getParams();\r", "-        if (paramTypes.length == vds.length) {\r", "-          for (int i = 0; i < paramTypes.length; i++) {\r", "-            // The parameters should be in order.  Must also check the unqualified form of the VariableData's type.\r", "-            if(!vds[i].getType().getName().equals(paramTypes[i]) &&\r", "-               !LanguageLevelVisitor.getUnqualifiedClassName(vds[i].getType().getName()).equals(paramTypes[i])) {\r", "-              match = false;\r", "-              break;\r", "-            }\r", "-          }\r", "-          if (match) {\r", "-            md = tempMd;            \r", "-            break;\r", "-          }\r", "-        }\r", "-      }\r", "-    }\r", "-    if (md == null) {\r", "-      throw new RuntimeException(\"Internal Program Error: The method \" + that.getName().getText() + \" was not in the class \" + _symbolData.getName() + \".  Please report this bug.\");\r", "-    }\r", "-    \r", "-    LinkedList<VariableData> ll = new LinkedList<VariableData>();\r", "-    VariableData[] vds = md.getParams();\r", "-    for (int i = 0; i<vds.length; i++) {\r", "-      ll.addLast(vds[i]);\r", "-    }\r", "-    ll.addAll(cloneVariableDataList(_vars));\r", "-    \r", "-    LinkedList<VariableData> thingsWeAssigned = new LinkedList<VariableData>();\r", "-    for (int i = 0; i<_symbolData.getVars().size(); i++) {\r", "-      VariableData tempVd = _symbolData.getVars().get(i);\r", "-      if (tempVd.gotValue()) { //then this variable did not have a value previously.\r", "-        thingsWeAssigned.addLast(tempVd);\r", "-      }\r", "-    }\r", "-    \r", "-    BodyTypeChecker btc = new BodyTypeChecker(md, _file, _package, _importedFiles, _importedPackages, ll, new LinkedList<Pair<SymbolData, JExpression>>());\r", "-    \r", "-    TypeData body_result = that.getBody().visit(btc); // We assume that this will return an InstanceData -- the return type of the body\r", "-    \r", "-    // This checks to see that the method returns the correct type.  It throws its own errors.\r", "-    if (body_result != null) {body_result = body_result.getSymbolData();}\r", "-    _checkReturnType(md.getReturnType(), (SymbolData) body_result, that);\r", "-    if (md.getReturnType() != null) {\r", "-      // Ensure that this method doesn't override another method with a different return type.\r", "-      SymbolData.checkDifferentReturnTypes(md, _symbolData, _targetVersion);\r", "-    }\r", "-    \r", "-    // This is not used because this call eventually invokes the forUninitializedVariableDeclarator method above.\r", "-    final TypeData[] params_result = makeArrayOfRetType(that.getParams().length);\r", "-\r", "-    for (int i = 0; i<thingsWeAssigned.size(); i++) {\r", "-      thingsWeAssigned.get(i).lostValue();\r", "-    }\r", "-    \r", "-    return result_result;\r", "-\r", "-  }\r", "+   */", "+  public TypeData forConcreteMethodDef(ConcreteMethodDef that) {", "+    final TypeData mav_result = that.getMav().visit(this);", "+    final TypeData[] typeParams_result = makeArrayOfRetType(that.getTypeParams().length);", "+    for (int i = 0; i < that.getTypeParams().length; i++) {", "+      typeParams_result[i] = that.getTypeParams()[i].visit(this);", "+    }", "+    final SymbolData result_result = getSymbolData(that.getResult().getName(), _symbolData, that);", "+    final TypeData name_result = that.getName().visit(this);", "+    final TypeData[] throws_result = makeArrayOfRetType(that.getThrows().length);", "+    for (int i = 0; i < that.getThrows().length; i++) {", "+      throws_result[i] = getSymbolData(that.getThrows()[i].getName(), _symbolData, that.getThrows()[i]);", "+    }", "+    // We need to match the name and params.", "+    // First find the correct MethodData.", "+    MethodData md = null;", "+    FormalParameter[] fParams = that.getParams();", "+    String[] paramTypes = new String[fParams.length];", "+    for (int i = 0; i < fParams.length; i++) {", "+      paramTypes[i] = fParams[i].getDeclarator().getType().getName();", "+    }", "+    LinkedList<MethodData> mds = _symbolData.getMethods();", "+    Iterator<MethodData> iter = mds.iterator();", "+    while (iter.hasNext()) {", "+      boolean match = false;", "+      MethodData tempMd = iter.next();", "+      if (tempMd.getName().equals(that.getName().getText())) {", "+        match = true;", "+", "+        // Check the params.", "+        VariableData[] vds = tempMd.getParams();", "+        if (paramTypes.length == vds.length) {", "+          for (int i = 0; i < paramTypes.length; i++) {", "+            // The parameters should be in order.  Must also check the unqualified form of the VariableData's type.", "+            if(!vds[i].getType().getName().equals(paramTypes[i]) &&", "+               !LanguageLevelVisitor.getUnqualifiedClassName(vds[i].getType().getName()).equals(paramTypes[i])) {", "+              match = false;", "+              break;", "+            }", "+          }", "+          if (match) {", "+            md = tempMd;            ", "+            break;", "+          }", "+        }", "+      }", "+    }", "+    if (md == null) {", "+      throw new RuntimeException(\"Internal Program Error: The method \" + that.getName().getText() + \" was not in the class \" + _symbolData.getName() + \".  Please report this bug.\");", "+    }", "+    ", "+    LinkedList<VariableData> ll = new LinkedList<VariableData>();", "+    VariableData[] vds = md.getParams();", "+    for (int i = 0; i<vds.length; i++) {", "+      ll.addLast(vds[i]);", "+    }", "+    ll.addAll(cloneVariableDataList(_vars));", "+    ", "+    LinkedList<VariableData> thingsWeAssigned = new LinkedList<VariableData>();", "+    for (int i = 0; i<_symbolData.getVars().size(); i++) {", "+      VariableData tempVd = _symbolData.getVars().get(i);", "+      if (tempVd.gotValue()) { //then this variable did not have a value previously.", "+        thingsWeAssigned.addLast(tempVd);", "+      }", "+    }", "+    ", "+    BodyTypeChecker btc = new BodyTypeChecker(md, _file, _package, _importedFiles, _importedPackages, ll, new LinkedList<Pair<SymbolData, JExpression>>());", "+    ", "+    TypeData body_result = that.getBody().visit(btc); // We assume that this will return an InstanceData -- the return type of the body", "+    ", "+    // This checks to see that the method returns the correct type.  It throws its own errors.", "+    if (body_result != null) {body_result = body_result.getSymbolData();}", "+    _checkReturnType(md.getReturnType(), (SymbolData) body_result, that);", "+    if (md.getReturnType() != null) {", "+      // Ensure that this method doesn't override another method with a different return type.", "+      SymbolData.checkDifferentReturnTypes(md, _symbolData, LanguageLevelConverter.OPT.javaVersion());", "+    }", "+    ", "+    // This is not used because this call eventually invokes the forUninitializedVariableDeclarator method above.", "+    final TypeData[] params_result = makeArrayOfRetType(that.getParams().length);", "+", "+    for (int i = 0; i<thingsWeAssigned.size(); i++) {", "+      thingsWeAssigned.get(i).lostValue();", "+    }", "+    ", "+    return result_result;", "+", "+  }"]}], "num": 17247}