{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ddd8d1e192a3536b5b3f761e912d7013", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "751a805596c7a959f35d3a3a7c58a292", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/ui/RegionsTreePanel.java", "commitBeforeChange": "0a7bf024d048ea8c858680b0ac23e24e5ae6fe7d", "commitAfterChange": "362905f63dbb4da65eed4f6ca60b6ce9eca3dd7d", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 40, "signatureBeforeChange": "   public void removeRegion(final R r)", "signatureAfterChange": "   public void removeRegion(final R r)", "diff": ["+    ", "+    if ((_lastSelectedRegion!=null) && (_lastSelectedRegion.equals(r))) {", "+      // we need to change the _lastSelectedRegion", "+      R newLast = getPrevRegionInTree(_lastSelectedRegion);", "+      if (newLast==null) newLast = getNextRegionInTree(_lastSelectedRegion);", "+      _lastSelectedRegion = newLast;", "+      if (_lastSelectedRegion!=null) {", "+        selectRegion(_lastSelectedRegion);", "+      }", "+    }", "+    ", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c470fbcc676970460aa52e4be1722d70", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/ClassChecker.java", "commitBeforeChange": "488e3f877c7f7a8647e0d3f7fb5faea712ac20ce", "commitAfterChange": "35470e88ca153d8164d45d018c673900eac06ea2", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": "          @Override public Void visit(ConstructorDeclaration node)", "signatureAfterChange": "          @Override public Void visit(ConstructorDeclaration node)", "diff": ["-      if (call != null) { callChecker.checkConstructorCall(call); }", "-      new StatementChecker(bodyContext, _opt).checkList(node.getStatements());", "-      // if the call is implicit, check it *after* checking the body (better error messages this way) ", "-      if (call == null) { callChecker.checkConstructorCall(new ConstructorCall(null, null, true)); }", "+      ExecutionError error = null;", "+      if (call != null) {", "+        try { callChecker.checkConstructorCall(call); }", "+        catch (ExecutionError e) { error = e; }", "+      }", "+      try { new StatementChecker(bodyContext, _opt).checkList(node.getStatements()); }", "+      catch (ExecutionError e) {", "+        if (error != null) { error = e; }", "+      }", "+      // if the call is implicit, only check it if there are no errors (avoids redundant errors)", "+      if (call == null && error == null) {", "+        callChecker.checkConstructorCall(new ConstructorCall(null, null, true));", "+      }", "+      if (error != null) { throw error; }"]}], "num": 14522}