{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "72b39c1847d1c0675a956dbad06f3004", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ad1ac509db6ae468a9d628705255bf5c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/definitions/DefinitionsDocument.java", "commitBeforeChange": "a33dd9cdb6eaad3925dbd0230d8fd4013b8f8126", "commitAfterChange": "345a82c54e3e67af4bf9681fbb22f96d3e1754eb", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "   private int _uncommentBlock(final int start, final int end)", "signatureAfterChange": "   private int _uncommentBlock(final int start, final int end)", "diff": ["-      int walker = start;", "-      synchronized(_reduced) {", "-        while (walker < endPos.getOffset()) {", "-          setCurrentLocation(walker);", "-          // Keep pointer to walker position that will stay current", "-          // regardless of how commentLine changes things", "-          Position walkerPos = this.createUnwrappedPosition(walker);", "-          // uncomment current line", "-          afterUncommentEnd-= _uncommentLine();  // accesses _reduced", "-          // Move back to walker spot", "-          setCurrentLocation(walkerPos.getOffset());", "-          walker = walkerPos.getOffset();", "-          // Adding 1 makes us point to the first character AFTER the next newline.", "-          // We don't actually move yet. That happens at the top of the loop,", "-          // after we check if we're past the end.", "-          walker += _reduced.getDistToNextNewline() + 1;", "-          //DrJava.consoleOut().println(\"progress: \" + (100*(walker-start)/(end-start)));", "-        }", "-      }", "+      ", "+//      synchronized(_reduced) {  //unnecessary because write lock is exclusive", "+      int walker = getLineStartPos(start);", "+//      Utilities.show(\"Initial walker pos = \" + walker);", "+      while (walker < endPos.getOffset()) {", "+        setCurrentLocation(walker);           // Move cursor to walker position", "+        int diff = _uncommentLine();          // Uncomment current line, accessing the reduced model", "+        afterUncommentEnd -= diff;            // Update afterUncommentEnd", "+        walker = getLineEndPos(walker) + 1;   // Update walker pos to point to beginning of next line", "+//        Utilities.show(\"Updated value of walker = \" + walker);", "+      }        ", "+//      }   "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fe15ec730d6196912854cb53708d8893", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/AbstractDJDocument.java", "commitBeforeChange": "a8db062e8dfd667df6324c059f7a6725afc99a1b", "commitAfterChange": "35da9b77b7d75aca3d6277e27e3ba3dc86f3eaa9", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 40, "signatureBeforeChange": "   private void _indentBlock(final int start, final int end, int reason, ProgressMonitor pm)     throws OperationCanceledException", "signatureAfterChange": "   private void _indentBlock(final int start, final int end, int reason, ProgressMonitor pm)     throws OperationCanceledException, BadLocationException", "diff": ["-    throws OperationCanceledException {", "-    // throwErrorHuh();", "-    //DrJava.consoleOut().println(\"indenting block of \" + (end-start));", "-    try {", "-      // Keep marker at the end. This Position will be the correct endpoint no matter how we change ", "-      // the doc doing the indentLine calls.", "-      final Position endPos = this.createPosition(end);", "-      // Iterate, line by line, until we get to/past the end", "-      int walker = start;", "-      while (walker < endPos.getOffset()) {", "-        setCurrentLocation(walker);", "-        // Keep pointer to walker position that will stay current", "-        // regardless of how indentLine changes things", "-        Position walkerPos = this.createPosition(walker);", "-        // Indent current line", "-        // We currently ignore current location info from each line, because", "-        // it probably doesn't make sense in a block context.", "-        _indentLine(reason);", "-        // Move back to walker spot", "-        setCurrentLocation(walkerPos.getOffset());", "-        walker = walkerPos.getOffset();", "-        ", "-        if (pm != null) {", "-          // Update ProgressMonitor.", "-          pm.setProgress(walker);", "-          ", "-          // Check for cancel button-press.", "-          if (pm.isCanceled()) throw new OperationCanceledException();", "-        }", "-        ", "-        // Adding 1 makes us point to the first character AFTER the next newline.", "-        // We don't actually move yet. That happens at the top of the loop,", "-        // after we check if we're past the end.", "-        walker += _reduced.getDistToNextNewline() + 1;", "-        //DrJava.consoleOut().println(\"progress: \" + (100*(walker-start)/(end-start)));", "+    throws OperationCanceledException, BadLocationException {", "+    ", "+    // Keep marker at the end. This Position will be the correct endpoint no matter how we change ", "+    // the doc doing the indentLine calls.", "+    final Position endPos = this.createPosition(end);", "+    // Iterate, line by line, until we get to/past the end", "+    int walker = start;", "+    while (walker < endPos.getOffset()) {", "+      setCurrentLocation(walker);", "+      // Keep pointer to walker position that will stay current", "+      // regardless of how indentLine changes things", "+      Position walkerPos = this.createPosition(walker);", "+      // Indent current line", "+      // We currently ignore current location info from each line, because", "+      // it probably doesn't make sense in a block context.", "+      _indentLine(reason);", "+      // Move back to walker spot", "+      setCurrentLocation(walkerPos.getOffset());", "+      walker = walkerPos.getOffset();", "+      ", "+      if (pm != null) {", "+        pm.setProgress(walker); // Update ProgressMonitor.", "+        if (pm.isCanceled()) throw new OperationCanceledException(); // Check for cancel button-press.", "+      ", "+      // Adding 1 makes us point to the first character AFTER the next newline. We don't actually move the", "+      // location yet. That happens at the top of the loop, after we check if we're past the end.", "+      walker += _reduced.getDistToNextNewline() + 1;", "-    catch (BadLocationException e) { throw new UnexpectedException(e); }"]}], "num": 5639}