{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fbce6176c3fe8d9aa48024dc1ba4bd5e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2639eba64985976d70c5cba8f3fed304", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/model/FindReplaceMachine.java", "commitBeforeChange": "db8f0cb26e31432f350747ff5cceb39c84bddf2e", "commitAfterChange": "09ee5df535fa7711165b559136b85b4d08379671", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 28, "signatureBeforeChange": "   public FindResult findNext()", "signatureAfterChange": "   private FindResult findNext(boolean searchAll)", "diff": ["-  public FindResult findNext() {    ", "-    // If the user just found and toggled the \"Search Backwards\"", "-    // option, we should skip the first find.", "-    if (_skipOneFind) {", "-      int wordLength = _lastFindWord.length();", "-      if (!_searchBackwards) setPosition(getCurrentOffset() + wordLength);", "-      else setPosition(getCurrentOffset() - wordLength);", "+  private FindResult findNext(boolean searchAll) {  ", "+ ", "+    // If the user just found a match and toggled the \"Search Backwards\" option, we should skip the matched text.", "+    if (_skipText) {  // adjust position (offset)", "+//      System.err.println(\"Skip text is true!  Last find word = \" + _lastFindWord);", "+      int wordLen = _lastFindWord.length();", "+      if (_isForward) setPosition(getCurrentOffset() + wordLen);", "+      else setPosition(getCurrentOffset() - wordLen);", "-    if (!_searchBackwards) return _findNext(_current.getOffset(), _doc.getLength()-_current.getOffset());", "-    return _findNext(0, _current.getOffset());", "-  }        ", "+    ", "+//    System.err.println(\"findNext(\" + searchAll + \") called with _doc = [\" + _doc.getText() + \"] and offset = \" + _current.getOffset());", "+    ", "+    int offset = getCurrentOffset();", "+//    System.err.println(\"findNext(\" + searchAll + \") called; initial offset is \" + offset);", "+//    System.err.println(\"_doc = [\" + _doc.getText() + \"], _doc.getLength() = \" + _doc.getLength());", "+    if (_isForward) return _findNext(_doc, offset, _doc.getLength() - offset, searchAll);", "+    return _findNext(_doc, 0, offset, searchAll);", "+  } "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35841a70f31622252c8e9a9f18697255", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/TreeCompiler.java", "commitBeforeChange": "73d8f0963e3941f0992013e94dd38c610fad8320", "commitAfterChange": "79f5d66e5d12491f568b49d5064798e6d989d102", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "      private void compileField(final FieldDeclaration ast)", "signatureAfterChange": "      private void compileField(final FieldDeclaration ast, boolean isInterface)", "diff": ["-  private void compileField(final FieldDeclaration ast) {", "-    final boolean isStatic = Modifier.isStatic(ast.getAccessFlags());", "+  private void compileField(final FieldDeclaration ast, boolean isInterface) {", "+    int access = ast.getAccessFlags();", "+    if (isInterface) { access = defaultToPublicAccess(access) | Modifier.STATIC | Modifier.FINAL; }", "+    final boolean isStatic = Modifier.isStatic(access);", "-    _classWriter.visitField(ast.getAccessFlags(), ast.getName(), typeDescriptor(t), typeSignature(t),", "+    _classWriter.visitField(access, ast.getName(), typeDescriptor(t), typeSignature(t),"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "429d0244eb4b901c9c10ad6d8ef4ae29", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/interpreter/TreeCompiler.java", "commitBeforeChange": "73d8f0963e3941f0992013e94dd38c610fad8320", "commitAfterChange": "79f5d66e5d12491f568b49d5064798e6d989d102", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "      private void compileMethod(MethodDeclaration ast)", "signatureAfterChange": "      private void compileMethod(MethodDeclaration ast, boolean isInterface)", "diff": ["-  private void compileMethod(MethodDeclaration ast) {", "+  private void compileMethod(MethodDeclaration ast, boolean isInterface) {", "+    int access = ast.getAccessFlags();", "+    if (isInterface) { access = defaultToPublicAccess(access) | Modifier.ABSTRACT; }", "-    boolean isStatic = Modifier.isStatic(ast.getAccessFlags());", "+    boolean isStatic = Modifier.isStatic(access);", "-    final MethodVisitor mv = _classWriter.visitMethod(ast.getAccessFlags(), ast.getName(), methodDescriptor,", "+    final MethodVisitor mv = _classWriter.visitMethod(access, ast.getName(), methodDescriptor,", "-    if (!Modifier.isAbstract(ast.getAccessFlags())) {", "+    if (!Modifier.isAbstract(access)) {", "-        @Override public void forClassType(ClassType t) { mv.visitInsn(ARETURN); }", "+        @Override public void forReferenceType(ReferenceType t) { mv.visitInsn(ARETURN); }"]}], "num": 24701}