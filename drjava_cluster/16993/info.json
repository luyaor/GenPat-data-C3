{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "434ae5dedd468a5dacd9f022d76b94a7", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "205dfe111ebfb357dacee48c1ab5ebf0", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Bob.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r   public TypeData forArrayInitializerHelper(ArrayInitializer that, SymbolData type)", "signatureAfterChange": "   public TypeData forArrayInitializerHelper(ArrayInitializer that, SymbolData type)", "diff": ["-   */\r", "-  public TypeData forArrayInitializerHelper(ArrayInitializer that, SymbolData type) {\r", "-    if (type == null) {return null;}\r", "-    if (!(type instanceof ArrayData)) {_addError(\"You cannot initialize the non-array type \" + type.getName() + \" with an array initializer\", that); return type.getInstanceData();}\r", "-    \r", "-    SymbolData elementType = ((ArrayData) type).getElementType();\r", "-    VariableInitializerI[] elements = that.getItems();\r", "-    TypeData[] result = makeArrayOfRetType(elements.length);\r", "-    \r", "-    for (int i = 0; i<elements.length; i++) {\r", "-      if (elements[i] instanceof ArrayInitializer) {\r", "-          result[i] = forArrayInitializerHelper((ArrayInitializer) elements[i], elementType);\r", "-      }\r", "-      else {\r", "-        ExpressionTypeChecker etc = new ExpressionTypeChecker(_data, _file, _package, _importedFiles, _importedPackages, _vars, _thrown);\r", "-        result[i] = elements[i].visit(etc);\r", "-        thingsThatHaveBeenAssigned.addAll(etc.thingsThatHaveBeenAssigned); //incorporate the things that were assigned in the expression here\r", "-        if (result[i] != null) {\r", "-          if (assertFound(result[i], (JExpression) that.getItems()[i])) {\r", "-            if (!result[i].getSymbolData().isAssignableTo(elementType, _targetVersion)) {\r", "-              _addError(\"The elements of this initializer should have type \" + elementType.getName() + \" but element \" + i + \" has type \" + result[i].getSymbolData().getName(), (JExpression) that.getItems()[i]);\r", "-            }\r", "-            else {\r", "-              assertInstanceType(result[i], \"The elements of this initializer should all be instances, but you have specified the type name \" + result[i].getName(), (JExpression) that.getItems()[i]);\r", "-            }\r", "-          }\r", "-        }\r", "-      }\r", "-    }\r", "-    \r", "-    \r", "-    return type.getInstanceData();\r", "-  }\r", "+   */", "+  public TypeData forArrayInitializerHelper(ArrayInitializer that, SymbolData type) {", "+    if (type == null) {return null;}", "+    if (!(type instanceof ArrayData)) {_addError(\"You cannot initialize the non-array type \" + type.getName() + \" with an array initializer\", that); return type.getInstanceData();}", "+    ", "+    SymbolData elementType = ((ArrayData) type).getElementType();", "+    VariableInitializerI[] elements = that.getItems();", "+    TypeData[] result = makeArrayOfRetType(elements.length);", "+    ", "+    for (int i = 0; i<elements.length; i++) {", "+      if (elements[i] instanceof ArrayInitializer) {", "+          result[i] = forArrayInitializerHelper((ArrayInitializer) elements[i], elementType);", "+      }", "+      else {", "+        ExpressionTypeChecker etc = new ExpressionTypeChecker(_data, _file, _package, _importedFiles, _importedPackages, _vars, _thrown);", "+        result[i] = elements[i].visit(etc);", "+        thingsThatHaveBeenAssigned.addAll(etc.thingsThatHaveBeenAssigned); //incorporate the things that were assigned in the expression here", "+        if (result[i] != null) {", "+          if (assertFound(result[i], (JExpression) that.getItems()[i])) {", "+            if (!result[i].getSymbolData().isAssignableTo(elementType, LanguageLevelConverter.OPT.javaVersion())) {", "+              _addError(\"The elements of this initializer should have type \" + elementType.getName() + \" but element \" + i + \" has type \" + result[i].getSymbolData().getName(), (JExpression) that.getItems()[i]);", "+            }", "+            else {", "+              assertInstanceType(result[i], \"The elements of this initializer should all be instances, but you have specified the type name \" + result[i].getName(), (JExpression) that.getItems()[i]);", "+            }", "+          }", "+        }", "+      }", "+    }", "+    ", "+    ", "+    return type.getInstanceData();", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "72d30fbfa48f06dff51e9b68b7bf7e34", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 48, "methodNumberAfterChange": 48, "signatureBeforeChange": "\r   public TypeData forArrayAccessOnly(ArrayAccess that, TypeData lhs, TypeData index)", "signatureAfterChange": "   public TypeData forArrayAccessOnly(ArrayAccess that, TypeData lhs, TypeData index)", "diff": ["- */\r", "-  public TypeData forArrayAccessOnly(ArrayAccess that, TypeData lhs, TypeData index) {\r", "-    //if either lhs or index is null then an error has already been caught--return null\r", "-    if (lhs == null || index == null) {return null;}\r", "-    \r", "-    //if either lhs or index cannot be resolved, give error\r", "-    if (!assertFound(lhs, that) || !assertFound(index, that)) {\r", "-      return null;\r", "-    }\r", "-    \r", "-    if (assertInstanceType(lhs, \"You cannot access an array element of a type name\", that) &&\r", "-        ! (lhs.getSymbolData() instanceof ArrayData)) {\r", "-      _addError(\"The variable referred to by this array access is a \" + lhs.getSymbolData().getName() + \", not an array\", that);\r", "-      return lhs.getInstanceData();\r", "-    }\r", "-    \r", "-    if (assertInstanceType(index, \"You have used a type name in place of an array index\", that) &&\r", "-        !index.getSymbolData().isAssignableTo(SymbolData.INT_TYPE, _targetVersion)) {\r", "-      _addError(\"You cannot reference an array element with an index of type \" + index.getSymbolData().getName() + \".  Instead, you must use an int\", that);\r", "-      \r", "-    }\r", "-    \r", "-    return ((ArrayData)lhs.getSymbolData()).getElementType().getInstanceData();\r", "-  \r", "-  \r", "-}\r", "+ */", "+  public TypeData forArrayAccessOnly(ArrayAccess that, TypeData lhs, TypeData index) {", "+    //if either lhs or index is null then an error has already been caught--return null", "+    if (lhs == null || index == null) {return null;}", "+    ", "+    //if either lhs or index cannot be resolved, give error", "+    if (!assertFound(lhs, that) || !assertFound(index, that)) {", "+      return null;", "+    }", "+    ", "+    if (assertInstanceType(lhs, \"You cannot access an array element of a type name\", that) &&", "+        ! (lhs.getSymbolData() instanceof ArrayData)) {", "+      _addError(\"The variable referred to by this array access is a \" + lhs.getSymbolData().getName() + \", not an array\", that);", "+      return lhs.getInstanceData();", "+    }", "+    ", "+    if (assertInstanceType(index, \"You have used a type name in place of an array index\", that) &&", "+        !index.getSymbolData().isAssignableTo(SymbolData.INT_TYPE, LanguageLevelConverter.OPT.javaVersion())) {", "+      _addError(\"You cannot reference an array element with an index of type \" + index.getSymbolData().getName() + \".  Instead, you must use an int\", that);", "+      ", "+    }", "+    ", "+    return ((ArrayData)lhs.getSymbolData()).getElementType().getInstanceData();", "+  ", "+  ", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "74592105e98c91a4edcd3c520e9f5407", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 67, "methodNumberAfterChange": 67, "signatureBeforeChange": "\r   public TypeData forUninitializedArrayInstantiationOnly(UninitializedArrayInstantiation that, TypeData type_result, TypeData[] dimensions_result)", "signatureAfterChange": "   public TypeData forUninitializedArrayInstantiationOnly(UninitializedArrayInstantiation that, TypeData type_result, TypeData[] dimensions_result)", "diff": ["-   */\r", "-  public TypeData forUninitializedArrayInstantiationOnly(UninitializedArrayInstantiation that, TypeData type_result, TypeData[] dimensions_result) {\r", "-    //make sure all of the dimensions_result dimensions are instance datas\r", "-    Expression[] dims = that.getDimensionSizes().getExpressions();\r", "-    for (int i = 0; i<dimensions_result.length; i++) {\r", "-      if (dimensions_result[i] != null && assertFound(dimensions_result[i], dims[i])) {\r", "-        if (!dimensions_result[i].getSymbolData().isAssignableTo(SymbolData.INT_TYPE, _targetVersion)) {\r", "-          _addError(\"The dimensions of an array instantiation must all be ints.  You have specified something of type \" + dimensions_result[i].getName(), dims[i]);\r", "-        }\r", "-        else {\r", "-          assertInstanceType(dimensions_result[i], \"All dimensions of an array instantiation must be instances.  You have specified the type \" + dimensions_result[i].getName(), dims[i]);\r", "-        }               \r", "-      }\r", "-    }\r", "-    \r", "-    if (type_result instanceof ArrayData) {\r", "-      int dim = ((ArrayData) type_result).getDimensions();\r", "-      if (dimensions_result.length > dim) {\r", "-       //uh oh!  Dimensions list is too long!\r", "-        _addError(\"You are trying to initialize an array of type \" + type_result.getName() + \" which requires \" + dim + \" dimensions, but you have specified \" + dimensions_result.length + \" dimensions--the wrong number\", that);\r", "-      }\r", "-    }\r", "-\r", "-    //return an instance of the new type\r", "-    if (type_result == null || !assertFound(type_result, that)) {return null;}\r", "-    return type_result.getInstanceData();\r", "-  }\r", "+   */", "+  public TypeData forUninitializedArrayInstantiationOnly(UninitializedArrayInstantiation that, TypeData type_result, TypeData[] dimensions_result) {", "+    //make sure all of the dimensions_result dimensions are instance datas", "+    Expression[] dims = that.getDimensionSizes().getExpressions();", "+    for (int i = 0; i<dimensions_result.length; i++) {", "+      if (dimensions_result[i] != null && assertFound(dimensions_result[i], dims[i])) {", "+        if (!dimensions_result[i].getSymbolData().isAssignableTo(SymbolData.INT_TYPE, LanguageLevelConverter.OPT.javaVersion())) {", "+          _addError(\"The dimensions of an array instantiation must all be ints.  You have specified something of type \" + dimensions_result[i].getName(), dims[i]);", "+        }", "+        else {", "+          assertInstanceType(dimensions_result[i], \"All dimensions of an array instantiation must be instances.  You have specified the type \" + dimensions_result[i].getName(), dims[i]);", "+        }               ", "+      }", "+    }", "+    ", "+    if (type_result instanceof ArrayData) {", "+      int dim = ((ArrayData) type_result).getDimensions();", "+      if (dimensions_result.length > dim) {", "+       //uh oh!  Dimensions list is too long!", "+        _addError(\"You are trying to initialize an array of type \" + type_result.getName() + \" which requires \" + dim + \" dimensions, but you have specified \" + dimensions_result.length + \" dimensions--the wrong number\", that);", "+      }", "+    }", "+", "+    //return an instance of the new type", "+    if (type_result == null || !assertFound(type_result, that)) {return null;}", "+    return type_result.getInstanceData();", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a4b65f834256b02a77a2a48b54ea814", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r   public TypeData forSimpleAssignmentExpressionOnly(SimpleAssignmentExpression that, TypeData name_result, TypeData value_result)", "signatureAfterChange": "   public TypeData forSimpleAssignmentExpressionOnly(SimpleAssignmentExpression that, TypeData name_result, TypeData value_result)", "diff": ["-   */\r", "-  public TypeData forSimpleAssignmentExpressionOnly(SimpleAssignmentExpression that, TypeData name_result, TypeData value_result) {\r", "-    if (name_result == null || value_result == null) {return null;}\r", "-  \r", "-    //make sure that both lhs and rhs could be resolved (not PackageDatas)\r", "-    if (!assertFound(name_result, that) || !assertFound(value_result, that)) {\r", "-      return null;\r", "-    }\r", "-    \r", "-    //make sure both are instance datas\r", "-    if (assertInstanceType(name_result, \"You cannot assign a value to the type \" + name_result.getName(), that) &&\r", "-        assertInstanceType(value_result, \"You cannot use the type name \" + value_result.getName() + \" on the right hand side of an assignment\", that)) {\r", "-      \r", "-      //make sure the rhs can be assigned to the lhs\r", "-      if (!value_result.getSymbolData().isAssignableTo(name_result.getSymbolData(), _targetVersion)) {\r", "-        _addError(\"You cannot assign something of type \" + value_result.getName() + \" to something of type \" + name_result.getName(), that);\r", "-      }\r", "-    }   \r", "-    return name_result.getInstanceData();\r", "-  }\r", "+   */", "+  public TypeData forSimpleAssignmentExpressionOnly(SimpleAssignmentExpression that, TypeData name_result, TypeData value_result) {", "+    if (name_result == null || value_result == null) {return null;}", "+  ", "+    //make sure that both lhs and rhs could be resolved (not PackageDatas)", "+    if (!assertFound(name_result, that) || !assertFound(value_result, that)) {", "+      return null;", "+    }", "+    ", "+    //make sure both are instance datas", "+    if (assertInstanceType(name_result, \"You cannot assign a value to the type \" + name_result.getName(), that) &&", "+        assertInstanceType(value_result, \"You cannot use the type name \" + value_result.getName() + \" on the right hand side of an assignment\", that)) {", "+      ", "+      //make sure the rhs can be assigned to the lhs", "+      if (!value_result.getSymbolData().isAssignableTo(name_result.getSymbolData(), LanguageLevelConverter.OPT.javaVersion())) {", "+        _addError(\"You cannot assign something of type \" + value_result.getName() + \" to something of type \" + name_result.getName(), that);", "+      }", "+    }   ", "+    return name_result.getInstanceData();", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7dc6d92a80d78b383960b9e419b1817c", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/TypeChecker.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 45, "signatureBeforeChange": "\r   protected boolean _isAssignableFrom(SymbolData sdLeft, SymbolData sdRight)", "signatureAfterChange": "   protected boolean _isAssignableFrom(SymbolData sdLeft, SymbolData sdRight)", "diff": ["-   */\r", "-  protected boolean _isAssignableFrom(SymbolData sdLeft, SymbolData sdRight) {\r", "-    \r", "-    if (sdRight == null) {return false;}\r", "-    return sdRight.isAssignableTo(sdLeft, _targetVersion);\r", "-\r", "-  }\r", "+   */", "+  protected boolean _isAssignableFrom(SymbolData sdLeft, SymbolData sdRight) {", "+    ", "+    if (sdRight == null) {return false;}", "+    return sdRight.isAssignableTo(sdLeft, LanguageLevelConverter.OPT.javaVersion());", "+", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82b6fd0ff3331de7703fa0ec2609867f", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "\r   public TypeData forNotExpressionOnly(NotExpression that, TypeData value_result)", "signatureAfterChange": "   public TypeData forNotExpressionOnly(NotExpression that, TypeData value_result)", "diff": ["-   */\r", "-  public TypeData forNotExpressionOnly(NotExpression that, TypeData value_result) {\r", "-    if (value_result == null) {return null;}\r", "-    \r", "-    //make sure that lhs could be resolved (not PackageData)\r", "-    if (!assertFound(value_result, that)) {\r", "-      return null;\r", "-    }\r", "-    \r", "-    if (assertInstanceType(value_result, \"You cannot use the not (!) operator with \" + value_result.getName() + \", because it is a class name, not an instance\", that) &&\r", "-        !value_result.getSymbolData().isAssignableTo(SymbolData.BOOLEAN_TYPE, _targetVersion)) {\r", "-      \r", "-      _addError(\"You cannot use the not (!) operator with something of type \" + value_result.getName() + \". Instead, it should be used with an expression of boolean type\", that);\r", "-    }\r", "-    \r", "-    return SymbolData.BOOLEAN_TYPE.getInstanceData(); //it should always be a boolean type.\r", "-    \r", "-  }\r", "+   */", "+  public TypeData forNotExpressionOnly(NotExpression that, TypeData value_result) {", "+    if (value_result == null) {return null;}", "+    ", "+    //make sure that lhs could be resolved (not PackageData)", "+    if (!assertFound(value_result, that)) {", "+      return null;", "+    }", "+    ", "+    if (assertInstanceType(value_result, \"You cannot use the not (!) operator with \" + value_result.getName() + \", because it is a class name, not an instance\", that) &&", "+        !value_result.getSymbolData().isAssignableTo(SymbolData.BOOLEAN_TYPE, LanguageLevelConverter.OPT.javaVersion())) {", "+      ", "+      _addError(\"You cannot use the not (!) operator with something of type \" + value_result.getName() + \". Instead, it should be used with an expression of boolean type\", that);", "+    }", "+    ", "+    return SymbolData.BOOLEAN_TYPE.getInstanceData(); //it should always be a boolean type.", "+    ", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "91dd561d3ab231d8cd8962674b58ae19", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Augmentor.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": "\r   \r   private static LinkedList<MethodData> _getVariableAccessorListHelper(SymbolData currClass)", "signatureAfterChange": "      private static LinkedList<MethodData> _getVariableAccessorListHelper(SymbolData currClass)", "diff": ["-  \r", "-  private static LinkedList<MethodData> _getVariableAccessorListHelper(SymbolData currClass) {\r", "-    List<Pair<VariableData, MethodData>> accessorMappings = new Vector<Pair<VariableData, MethodData>>();\r", "-    LinkedList<SymbolData> classes = new LinkedList<SymbolData>();\r", "-    classes.add(currClass);\r", "-    \r", "-    // Gather all accessor methods that have a matching signature with their variables\r", "-    while (classes.size() > 0) {\r", "-      SymbolData tempSd = classes.removeFirst();\r", "-      if (LanguageLevelVisitor.isJavaLibraryClass(tempSd.getName())) { break; }\r", "-      \r", "-      for (int i = 0; i<tempSd.getVars().size(); i++) {\r", "-        VariableData tempVd = tempSd.getVars().get(i);\r", "-        MethodData md = tempSd.getMethod(tempVd.getName(), new TypeData[0]);\r", "-        if (md != null)\r", "-          accessorMappings.add(new Pair<VariableData, MethodData>(tempVd, md));\r", "-      }\r", "-      // Note that we don't need to check interface fields, because they are always static.\r", "-      \r", "-      SymbolData superClass = tempSd.getSuperClass();\r", "-      if (superClass != null) classes.addFirst(superClass); // Insure that we traverse the superclass hierarchy before we traverse the outer class hierarchy\r", "-      Data outerData = tempSd.getOuterData();\r", "-      if (outerData != null) { classes.addLast(outerData.getSymbolData()); }\r", "-    }\r", "-  \r", "-    // Eliminate those accessors that are inaccessible, that throw exceptions, that are static, that are shadowed, or that have a different return type\r", "-    LinkedList<MethodData> allMethods = new LinkedList<MethodData>();\r", "-    for (int i = accessorMappings.size() - 1; i >= 0; i--) {\r", "-      VariableData vd = accessorMappings.get(i).getFirst();\r", "-      MethodData md = accessorMappings.get(i).getSecond();\r", "-      boolean canSeeMethod = TypeChecker.checkAccessibility(new NullLiteral(JExprParser.NO_SOURCE_INFO), md.getMav(), md.getName(), md.getSymbolData(), currClass, \"method\", false);\r", "-      //TODO: it is okay to throw Runtime exceptions or Errors) {\r", "-      if (canSeeMethod && (! md.hasModifier(\"static\")) && (md.getThrown().length == 0) && vd.getType().getSymbolData().isAssignableTo(md.getReturnType(), _targetVersion)) {\r", "-        boolean isShadowed = false;\r", "-        for (int j = i - 1; j >= 0; j--) {\r", "-          if (accessorMappings.get(j).getSecond().getName().equals(md.getName())) { isShadowed = true; break; }\r", "-        }\r", "-        if (!isShadowed) { allMethods.addFirst(md); }\r", "-      }\r", "-    }\r", "-    return allMethods;\r", "-  }\r", "+  ", "+  private static LinkedList<MethodData> _getVariableAccessorListHelper(SymbolData currClass) {", "+    List<Pair<VariableData, MethodData>> accessorMappings = new Vector<Pair<VariableData, MethodData>>();", "+    LinkedList<SymbolData> classes = new LinkedList<SymbolData>();", "+    classes.add(currClass);", "+    ", "+    // Gather all accessor methods that have a matching signature with their variables", "+    while (classes.size() > 0) {", "+      SymbolData tempSd = classes.removeFirst();", "+      if (LanguageLevelVisitor.isJavaLibraryClass(tempSd.getName())) { break; }", "+      ", "+      for (int i = 0; i<tempSd.getVars().size(); i++) {", "+        VariableData tempVd = tempSd.getVars().get(i);", "+        MethodData md = tempSd.getMethod(tempVd.getName(), new TypeData[0]);", "+        if (md != null)", "+          accessorMappings.add(new Pair<VariableData, MethodData>(tempVd, md));", "+      }", "+      // Note that we don't need to check interface fields, because they are always static.", "+      ", "+      SymbolData superClass = tempSd.getSuperClass();", "+      if (superClass != null) classes.addFirst(superClass); // Insure that we traverse the superclass hierarchy before we traverse the outer class hierarchy", "+      Data outerData = tempSd.getOuterData();", "+      if (outerData != null) { classes.addLast(outerData.getSymbolData()); }", "+    }", "+  ", "+    // Eliminate those accessors that are inaccessible, that throw exceptions, that are static, that are shadowed, or that have a different return type", "+    LinkedList<MethodData> allMethods = new LinkedList<MethodData>();", "+    for (int i = accessorMappings.size() - 1; i >= 0; i--) {", "+      VariableData vd = accessorMappings.get(i).getFirst();", "+      MethodData md = accessorMappings.get(i).getSecond();", "+      boolean canSeeMethod = TypeChecker.checkAccessibility(new NullLiteral(JExprParser.NO_SOURCE_INFO), md.getMav(), md.getName(), md.getSymbolData(), currClass, \"method\", false);", "+      //TODO: it is okay to throw Runtime exceptions or Errors) {", "+      if (canSeeMethod && (! md.hasModifier(\"static\")) && (md.getThrown().length == 0) && vd.getType().getSymbolData().isAssignableTo(md.getReturnType(), LanguageLevelConverter.OPT.javaVersion())) {", "+        boolean isShadowed = false;", "+        for (int j = i - 1; j >= 0; j--) {", "+          if (accessorMappings.get(j).getSecond().getName().equals(md.getName())) { isShadowed = true; break; }", "+        }", "+        if (!isShadowed) { allMethods.addFirst(md); }", "+      }", "+    }", "+    return allMethods;", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bc2cd13ea76c5515e16d406acf891284", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/ExpressionTypeChecker.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "\r   public TypeData forCastExpressionOnly(CastExpression that, TypeData type_result, TypeData value_result)", "signatureAfterChange": "   public TypeData forCastExpressionOnly(CastExpression that, TypeData type_result, TypeData value_result)", "diff": ["-   */\r", "-  public TypeData forCastExpressionOnly(CastExpression that, TypeData type_result, TypeData value_result) {\r", "-    if (type_result == null || value_result == null) {return null;}\r", "-    \r", "-    //make sure that lhs could be resolved (not PackageData)\r", "-    if (!assertFound(value_result, that) || !assertFound(type_result, that)) {\r", "-      return null;\r", "-    }\r", "-    \r", "-    if (type_result.isInstanceType()) {\r", "-      _addError(\"You are trying to cast to an instance of a type, which is not allowed.  Perhaps you meant to cast to the type itself, \" + type_result.getName(), that);\r", "-    }\r", "-    \r", "-    else if (assertInstanceType(value_result, \"You are trying to cast \" + value_result.getName() + \", which is a class or interface type, not an instance\", that) &&\r", "-             !value_result.getSymbolData().isCastableTo(type_result.getSymbolData(), _targetVersion)) {\r", "-      \r", "-      _addError(\"You cannot cast an expression of type \" + value_result.getName() + \" to type \" + type_result.getName() + \" because they are not related\", that);\r", "-    }\r", "-    \r", "-    return type_result.getInstanceData();\r", "-  }\r", "+   */", "+  public TypeData forCastExpressionOnly(CastExpression that, TypeData type_result, TypeData value_result) {", "+    if (type_result == null || value_result == null) {return null;}", "+    ", "+    //make sure that lhs could be resolved (not PackageData)", "+    if (!assertFound(value_result, that) || !assertFound(type_result, that)) {", "+      return null;", "+    }", "+    ", "+    if (type_result.isInstanceType()) {", "+      _addError(\"You are trying to cast to an instance of a type, which is not allowed.  Perhaps you meant to cast to the type itself, \" + type_result.getName(), that);", "+    }", "+    ", "+    else if (assertInstanceType(value_result, \"You are trying to cast \" + value_result.getName() + \", which is a class or interface type, not an instance\", that) &&", "+             !value_result.getSymbolData().isCastableTo(type_result.getSymbolData(), LanguageLevelConverter.OPT.javaVersion())) {", "+      ", "+      _addError(\"You cannot cast an expression of type \" + value_result.getName() + \" to type \" + type_result.getName() + \" because they are not related\", that);", "+    }", "+    ", "+    return type_result.getInstanceData();", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da675b643d0e7fa095e93f1ade6937b1", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Augmentor.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 28, "signatureBeforeChange": "\r   protected static void writeSimpleHashCode(String className, SymbolData sd, int baseIndent, boolean waitForVarDef, \r                                             String valueHashCodeName, MethodData[] accessors)", "signatureAfterChange": "   protected static void writeSimpleHashCode(String className, SymbolData sd, int baseIndent, boolean waitForVarDef,                                              String valueHashCodeName, MethodData[] accessors)", "diff": ["-   */\r", "-  protected static void writeSimpleHashCode(String className, SymbolData sd, int baseIndent, boolean waitForVarDef, \r", "-                                            String valueHashCodeName, MethodData[] accessors) {\r", "-    \r", "-    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"/** This method is automatically generated by the Language Level Converter. */\");\r", "-    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"public int hashCode() {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 2) + \"return getClass().hashCode()\");\r", "-    for (int i = 0; i < accessors.length; i++) {\r", "-      _writeToFileOut(\" ^ \" + newLine + indentString(baseIndent, 4));\r", "-      SymbolData type = accessors[i].getReturnType().getSymbolData();\r", "-      \r", "-      if (! type.isPrimitiveType()) {\r", "-        _writeToFileOut(\"(\" + accessors[i].getName() + \"() == null ? 0 : \" + accessors[i].getName() + \"().hashCode())\");\r", "-      }\r", "-      else if (type == SymbolData.BOOLEAN_TYPE) {\r", "-        _writeToFileOut(\"(\" + accessors[i].getName() + \"() ? 1 : 0)\");\r", "-      }\r", "-      else if (type.isAssignableTo(SymbolData.INT_TYPE, _targetVersion)) {\r", "-        _writeToFileOut(accessors[i].getName() + \"()\");\r", "-      }\r", "-      else {\r", "-        _writeToFileOut(\"(int) \" + accessors[i].getName() + \"()\");           \r", "-      }\r", "-    }\r", "-    \r", "-    _writeToFileOut(\";\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 1) + \"}\" + newLine);\r", "-  }\r", "+   */", "+  protected static void writeSimpleHashCode(String className, SymbolData sd, int baseIndent, boolean waitForVarDef, ", "+                                            String valueHashCodeName, MethodData[] accessors) {", "+    ", "+    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"/** This method is automatically generated by the Language Level Converter. */\");", "+    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"public int hashCode() {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 2) + \"return getClass().hashCode()\");", "+    for (int i = 0; i < accessors.length; i++) {", "+      _writeToFileOut(\" ^ \" + newLine + indentString(baseIndent, 4));", "+      SymbolData type = accessors[i].getReturnType().getSymbolData();", "+      ", "+      if (! type.isPrimitiveType()) {", "+        _writeToFileOut(\"(\" + accessors[i].getName() + \"() == null ? 0 : \" + accessors[i].getName() + \"().hashCode())\");", "+      }", "+      else if (type == SymbolData.BOOLEAN_TYPE) {", "+        _writeToFileOut(\"(\" + accessors[i].getName() + \"() ? 1 : 0)\");", "+      }", "+      else if (type.isAssignableTo(SymbolData.INT_TYPE, LanguageLevelConverter.OPT.javaVersion())) {", "+        _writeToFileOut(accessors[i].getName() + \"()\");", "+      }", "+      else {", "+        _writeToFileOut(\"(int) \" + accessors[i].getName() + \"()\");           ", "+      }", "+    }", "+    ", "+    _writeToFileOut(\";\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 1) + \"}\" + newLine);", "+  }"]}], "num": 16993}