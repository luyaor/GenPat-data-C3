{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e477ccc19c98ac081e563c03bc2818fa", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a9bd3eff9f0d994097626d3227aca92a", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 371, "methodNumberAfterChange": 283, "signatureBeforeChange": "   private <T> Iterable<? extends T>     lookupMember(Type t, final Set<Type> alreadyChecked,                  TypeVisitor<? extends Iterable<? extends T>> baseCase,                   final TypeVisitor<? extends Iterable<? extends T>> recursiveBaseCase)", "signatureAfterChange": "          protected Iterable<T> declaredMatches(Type t)", "diff": ["+    ", "+    protected Iterable<T> declaredMatches(Type t) {", "+      Iterable<T> result = t.apply(new TypeAbstractVisitor<Iterable<T>>() {", "+        private boolean matches(DJField f) {", "+          return f.declaredName().equals(_name) && !(_onlyStatic && !f.isStatic());", "+        }", "+        @Override public Iterable<T> defaultCase(Type t) { return IterUtil.empty(); }", "+        @Override public Iterable<T> forArrayType(ArrayType t) {", "+          if (_name.equals(\"length\") && !_onlyStatic) {", "+            return IterUtil.make(makeFieldReference(t, ArrayLengthField.INSTANCE));", "+          }", "+          else { return IterUtil.empty(); }", "+        }", "+        @Override public Iterable<T> forClassType(ClassType t) {", "+          for (DJField f : t.ofClass().declaredFields()) {", "+            if (matches(f)) { return IterUtil.make(makeFieldReference(t, f)); }", "+          }", "+          return IterUtil.empty();", "+        }", "+      });", "+      return result;", "+    }", "-   */", "-  private <T> Iterable<? extends T>", "-    lookupMember(Type t, final Set<Type> alreadyChecked,", "-                 TypeVisitor<? extends Iterable<? extends T>> baseCase, ", "-                 final TypeVisitor<? extends Iterable<? extends T>> recursiveBaseCase) {", "-    debug.logStart(\"t\", wrap(t)); try {", "-      ", "-    if (alreadyChecked.contains(t)) { return IterUtil.empty(); }", "-    ", "-    final Iterable<? extends T> baseResult = t.apply(baseCase);", "-    alreadyChecked.add(t);", "-    if (!IterUtil.isEmpty(baseResult)) { return baseResult; }", "-    else {", "-      return t.apply(new TypeAbstractVisitor<Iterable<? extends T>>() {", "-        ", "-        public Iterable<? extends T> defaultCase(Type t) { return baseResult; }", "-        ", "-        @Override public Iterable<? extends T> forArrayType(ArrayType t) {", "-          return lookupMember(CLONEABLE_AND_SERIALIZABLE, alreadyChecked, recursiveBaseCase, recursiveBaseCase);", "-        }", "-        ", "-        @Override public Iterable<? extends T> forSimpleClassType(SimpleClassType t) {", "-          Type superT = immediateSupertype(t);", "-          if (superT == null) { return baseResult; }", "-          else { return lookupMember(superT, alreadyChecked, recursiveBaseCase, recursiveBaseCase); }", "-        }", "-        ", "-        @Override public Iterable<? extends T> forRawClassType(RawClassType t) {", "-          Type superT = immediateSupertype(t);", "-          if (superT == null) { return baseResult; }", "-          else { return lookupMember(superT, alreadyChecked, recursiveBaseCase, recursiveBaseCase); }", "-        }", "-        ", "-        @Override public Iterable<? extends T> forParameterizedClassType(ParameterizedClassType t) {", "-          Type superT = immediateSupertype(t);", "-          if (superT == null) { return baseResult; }", "-          else { return lookupMember(superT, alreadyChecked, recursiveBaseCase, recursiveBaseCase); }", "-        }", "-        ", "-        @Override public Iterable<? extends T> forVariableType(VariableType t) {", "-          return lookupMember(t.symbol().upperBound(), alreadyChecked, recursiveBaseCase, recursiveBaseCase);", "-        }", "-        ", "-        @Override public Iterable<? extends T> forIntersectionType(IntersectionType t) {", "-          Iterable<? extends T> result = IterUtil.empty();", "-          for (Type tSup : t.ofTypes()) {", "-            Iterable<? extends T> forSup = lookupMember(tSup, alreadyChecked, recursiveBaseCase, ", "-                                                        recursiveBaseCase);", "-            result = IterUtil.compose(result, forSup);", "-          }", "-          return result;", "-        }", "-        ", "-      });", "-    }", "-    ", "-    } finally { debug.logEnd(); }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc083f882d06c589b458ff6e003a071e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "dynamicjava/src/edu/rice/cs/dynamicjava/symbol/StandardTypeSystem.java", "commitBeforeChange": "c49bfac6b5c39aa536d2d1420b6c956dfa5557c6", "commitAfterChange": "d00e0fe6f02f0704b0308587aa3c8b683ceed0a6", "methodNumberBeforeChange": 331, "methodNumberAfterChange": 245, "signatureBeforeChange": "   public ObjectFieldReference lookupField(final Expression object, final String name)     throws InvalidTargetException, UnmatchedLookupException", "signatureAfterChange": "      public ObjectFieldReference lookupField(final Expression object, final String name)     throws UnmatchedLookupException", "diff": ["+  ", "+  public ObjectFieldReference lookupField(final Expression object, final String name)", "+    throws UnmatchedLookupException {", "+    FieldFinder<ObjectFieldReference> finder = new FieldFinder<ObjectFieldReference>(name, false) {", "+      public ObjectFieldReference makeFieldReference(Type t, DJField f) {", "+        return new ObjectFieldReference(f, fieldType(f, t), makeCast(t, object));", "+      }", "+    };", "+    return finder.findSingleField(NodeProperties.getType(object));", "+  }", "-   */", "-  public ObjectFieldReference lookupField(final Expression object, final String name)", "-    throws InvalidTargetException, UnmatchedLookupException {", "-    debug.logStart(new String[]{\"t\", \"name\"}, wrap(NodeProperties.getType(object)), name); try {", "-", "-    class LookupField extends TypeAbstractVisitor<Iterable<ObjectFieldReference>> {", "-      ", "-      private boolean _includePrivate;", "-      ", "-      public LookupField(boolean includePrivate) {", "-        _includePrivate = includePrivate;", "-      }", "-      ", "-      private boolean validField(DJField f) { ", "-        return _includePrivate || !f.accessibility().equals(Access.PRIVATE);", "-      }", "-      ", "-      public Iterable<ObjectFieldReference> defaultCase(Type t) { return IterUtil.empty(); }", "-      ", "-      @Override public Iterable<ObjectFieldReference> forArrayType(ArrayType t) {", "-        if (name.equals(\"length\")) {", "-          return IterUtil.make(new ObjectFieldReference(ArrayLengthField.INSTANCE, INT, object));", "-        }", "-        else { return IterUtil.empty(); }", "-      }", "-      ", "-      @Override public Iterable<ObjectFieldReference> forSimpleClassType(SimpleClassType t) {", "-        for (DJField f : t.ofClass().declaredFields()) {", "-          if (f.declaredName().equals(name) && validField(f)) {", "-            return IterUtil.make(new ObjectFieldReference(f, f.type(), makeCast(t, object)));", "-          }", "-        }", "-        return IterUtil.empty();", "-      }", "-      ", "-      @Override public Iterable<ObjectFieldReference> forRawClassType(RawClassType t) {", "-        // TODO: Handle raw member access warnings", "-        for (DJField f : t.ofClass().declaredFields()) {", "-          if (f.declaredName().equals(name) && validField(f)) {", "-            return IterUtil.make(new ObjectFieldReference(f, erase(f.type()), makeCast(t, object)));", "-          }", "-        }", "-        return IterUtil.empty();", "-      }", "-      ", "-      @Override public Iterable<ObjectFieldReference> forParameterizedClassType(ParameterizedClassType t) {", "-        for (DJField f : t.ofClass().declaredFields()) {", "-          if (f.declaredName().equals(name) && validField(f)) {", "-            Type fieldType = substitute(f.type(), SymbolUtil.allTypeParameters(t.ofClass()), ", "-                                        t.typeArguments());", "-            return IterUtil.make(new ObjectFieldReference(f, fieldType, makeCast(t, object)));", "-          }", "-        }", "-        return IterUtil.empty();", "-      }", "-      ", "-    }", "-    Iterable<? extends ObjectFieldReference> results = lookupMember(NodeProperties.getType(object), ", "-                                                                    new LookupField(true), ", "-                                                                    new LookupField(false));", "-    // TODO: provide more error-message information", "-    int matches = IterUtil.sizeOf(results);", "-    if (matches != 1) { throw new UnmatchedLookupException(matches); }", "-    else { return IterUtil.first(results); }", "-    ", "-    } finally { debug.logEnd(); }", "-  }"]}], "num": 21298}