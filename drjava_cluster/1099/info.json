{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a00b1ccb96fc9621eb597a13ea09d356", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1c06903a1e39826a64a3851044e26284", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/config/VectorOption.java", "commitBeforeChange": "042ffb6978685c2b793d5124edfd3dfa24636f7c", "commitAfterChange": "54c74315c73b1720afe84a0338d81d822eb71511", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Vector<T> parse(String s)", "signatureAfterChange": "     public Vector<T> parse(String s)", "diff": ["-   */", "-  public Vector<T> parse(String s)", "-  {  ", "-    // Enforced String format: \"[<element>, <element>, <element>]\"", "-      ", "-    if (s.charAt(0) != '[' || s.charAt(s.length() - 1) != ']')", "-      throw new IllegalArgumentException(\"Input must be String representation\" +", "-                                           \" of a Vector.\");", "-  ", "-    Vector<T> res = new Vector<T>();", "- ", "-    int i = 1;", "- ", "-    while (i != s.length() - 1)", "-      i = this.parseElement(s, i, res);", "-     ", "-    return res;", "-  }", "+     */", "+    public Vector<T> parse(String s) {  ", "+ int startFirstElement = header.length();", "+ int startFooter = s.length() - footer.length(); ", "+ ", "+ if (startFooter < startFirstElement || ", "+     !s.startsWith(header) || ", "+     !s.endsWith(footer)) {", "+     throw new IllegalArgumentException(\"String argument does not match format \" +", "+            \"specified by this VectorOption and its \" +", "+            \"delimiters.\");", "+ }", "+ s = s.substring(startFirstElement, startFooter);", "+ String d = String.valueOf(delim);", "+ StringTokenizer st = new StringTokenizer(s,d,true);", "+ ", "+ Vector<T> res = new Vector<T>();", "+ boolean sawDelim = st.hasMoreTokens();", "+", "+ while(st.hasMoreTokens()) {", "+     String token = st.nextToken();", "+     boolean isDelim = token.equals(d);", "+     ", "+     if(!isDelim) {", "+  res.addElement(parser.parse(token));", "+     } else if(sawDelim) { // isDelim & sawDelim (two delims in a row)", "+  throw new IllegalArgumentException(\" String argument contains delimiter with no preceding list element.\");", "+     } ", "+     sawDelim = isDelim;", "+ }", "+ if(sawDelim) {", "+     throw new IllegalArgumentException(\"String argument ends with delimiter.\");", "+ }", "+ return res;", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64aacb8bc22b9b73b386f93e664c7bbd", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "drjava/src/edu/rice/cs/drjava/config/VectorOption.java", "commitBeforeChange": "ef7dc3345b6835fe8ebb574f1a9119ee4c786794", "commitAfterChange": "21836dcccd81c2207652ee85b319b723ac9ff10b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "   public Vector<T> parse(String s)", "signatureAfterChange": "   public Vector<T> parse(String s)", "diff": ["+    Vector<T> res = new Vector<T>();", "+    if (s.equals(\"\")) { return res; }", "+", "-    String d = String.valueOf(delim);", "-    StringTokenizer st = new StringTokenizer(s,d,true);", "-", "-    Vector<T> res = new Vector<T>();", "-    boolean sawDelim = st.hasMoreTokens();", "-", "-    while(st.hasMoreTokens()) {", "-      String token = st.nextToken();", "-      boolean isDelim = token.equals(d);", "-", "-      if (!isDelim) {", "-        res.add(parser.parse(token));", "-      } else if (sawDelim) { // isDelim & sawDelim (two delims in a row)", "-        throw new OptionParseException(name, s, \"Argument contains delimiter with no preceding list element.\");", "-      }", "-      sawDelim = isDelim;", "+    if (s.equals(\"\")) {", "+      res.add(parser.parse(\"\"));", "+      return res;", "-    if (sawDelim) throw new OptionParseException(name, s, \"Value shouldn't end with a delimiter.\");", "+    ", "+    String d = String.valueOf(delim);", "+", "+    StreamTokenizer st = new StreamTokenizer(new StringReader(s));", "+    st.resetSyntax();", "+    st.wordChars(0,255);", "+    st.ordinaryChar('\\\\');", "+    st.ordinaryChar(delim);", "+    try {", "+      int tok = st.nextToken();", "+      int prevtok = -4;", "+      StringBuilder sb = new StringBuilder();", "+      while (tok!=StreamTokenizer.TT_EOF) {", "+        if (tok=='\\\\') {", "+          if (prevtok=='\\\\') {", "+            // second backslash in a row, append a backslash to string builder", "+            sb.append('\\\\');", "+            prevtok = tok = -4;", "+          }", "+          else {", "+            // first backslash, next token decides", "+            prevtok = tok;", "+          }", "+        }", "+        else if (tok==delim) {", "+          if (prevtok=='\\\\') {", "+            // backslash followed by delimiter --> escaped delimiter", "+            // append delimiter to string builder", "+            sb.append(delim);", "+            prevtok = tok = -4;", "+          }", "+          else {", "+            // no preceding backslash --> real delimiter", "+            res.add(parser.parse(sb.toString()));", "+            sb.setLength(0); // clear string builder", "+            prevtok = tok;", "+          }", "+        }", "+        else {", "+          // not a backslash or delimiter", "+          if (prevtok=='\\\\') {", "+            // backslash followed by neither a backslash nor a delimiter", "+            // invalid", "+            throw new OptionParseException(name, s, \"A backslash was discovered before the token '\" + st.sval +", "+                                           \"'. A backslash is only allowed in front of another backslash \" +", "+                                           \"or the delimiter \"+delim+\".\");", "+          }", "+          sb.append(st.sval);", "+          prevtok = tok;", "+        }", "+        ", "+        tok = st.nextToken();", "+      }", "+      ", "+      res.add(parser.parse(sb.toString()));      ", "+    }", "+    catch(IOException ioe) {", "+      throw new OptionParseException(name, s, \"An IOException occurred while parsing a vector.\");", "+    }", "+"]}], "num": 1099}