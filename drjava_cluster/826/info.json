{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "46d139978370a2a1bcc45a3e6caa614a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "43768a66f6badc96104c4273034c5360", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Augmentor.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": "\r   protected static void writeSafeToString(SymbolData sd, int baseIndent, String valueToStringName, MethodData[] accessors)", "signatureAfterChange": "   protected static void writeSafeToString(SymbolData sd, int baseIndent, String valueToStringName, MethodData[] accessors)", "diff": ["-  /** Helper to writeToString; writes a toString that handles infinitely-recursive data structures. */\r", "-  protected static void writeSafeToString(SymbolData sd, int baseIndent, String valueToStringName, MethodData[] accessors) {\r", "-    \r", "-    String flagName = sd.createUniqueName(\"__toStringFlag\");\r", "-    VariableData toStringFlag = new VariableData(flagName, new ModifiersAndVisibility(JExprParser.NO_SOURCE_INFO, new String[]{ \"private\", \"static\" }),\r", "-                                 _llv.getSymbolDataHelper(\"java.util.LinkedList\", JExprParser.NO_SOURCE_INFO, false, false, false, false),\r", "-                                 true, sd);\r", "-    toStringFlag.setGenerated(true);\r", "-    sd.addVar(toStringFlag);\r", "-    \r", "-    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"/** This field is automatically generated by the Language Level Converter. */\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 1) + \"private boolean \" + flagName + \" = false;\" + newLine);\r", "-    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"/** This method is automatically generated by the Language Level Converter. */\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 1) + \"public java.lang.String toString() {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 2) + \"if (\" + flagName + \") {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"return getClass().getName() + \\\"(...)\\\";\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 2) + \"}\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 2) + \"else {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + flagName + \" = true;\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"String result;\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"try {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 4) + \"result = getClass().getName() + \\\"(\\\" + \" + newLine);\r", "-    for (int i = 0; i < accessors.length; i++) {\r", "-      if (LanguageLevelConverter.versionSupportsAutoboxing(_targetVersion) ||\r", "-            ! accessors[i].getReturnType().getSymbolData().isPrimitiveType()) {\r", "-        \r", "-        _writeToFileOut(indentString(baseIndent, 6) + valueToStringName + \"(\" + accessors[i].getName() + \"()) + \");\r", "-      }\r", "-      else {\r", "-        _writeToFileOut(indentString(baseIndent, 6) + accessors[i].getName() + \"() + \");\r", "-      }\r", "-\r", "-      if (i < accessors.length - 1) {\r", "-        _writeToFileOut(\"\\\", \\\" + \");\r", "-      }\r", "-      _writeToFileOut(newLine);\r", "-    }\r", "-    _writeToFileOut(indentString(baseIndent, 6) + \"\\\")\\\";\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"}\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"catch (RuntimeException e) {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 4) + flagName + \" = false;\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 4) + \"throw e;\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"}\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + flagName + \" = false;\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"return result;\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 2) + \"}\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 1) + \"}\" + newLine);\r", "-  }\r", "+  /** Helper to writeToString; writes a toString that handles infinitely-recursive data structures. */", "+  protected static void writeSafeToString(SymbolData sd, int baseIndent, String valueToStringName, MethodData[] accessors) {", "+    ", "+    String flagName = sd.createUniqueName(\"__toStringFlag\");", "+    VariableData toStringFlag = new VariableData(flagName, new ModifiersAndVisibility(JExprParser.NO_SOURCE_INFO, new String[]{ \"private\", \"static\" }),", "+                                 _llv.getSymbolDataHelper(\"java.util.LinkedList\", JExprParser.NO_SOURCE_INFO, false, false, false, false),", "+                                 true, sd);", "+    toStringFlag.setGenerated(true);", "+    sd.addVar(toStringFlag);", "+    ", "+    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"/** This field is automatically generated by the Language Level Converter. */\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 1) + \"private boolean \" + flagName + \" = false;\" + newLine);", "+    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"/** This method is automatically generated by the Language Level Converter. */\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 1) + \"public java.lang.String toString() {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 2) + \"if (\" + flagName + \") {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"return getClass().getName() + \\\"(...)\\\";\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 2) + \"}\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 2) + \"else {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + flagName + \" = true;\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"String result;\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"try {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 4) + \"result = getClass().getName() + \\\"(\\\" + \" + newLine);", "+    for (int i = 0; i < accessors.length; i++) {", "+      if (LanguageLevelConverter.OPT.javaVersion().supports(JavaVersion.JAVA_5) ||", "+            ! accessors[i].getReturnType().getSymbolData().isPrimitiveType()) {", "+        ", "+        _writeToFileOut(indentString(baseIndent, 6) + valueToStringName + \"(\" + accessors[i].getName() + \"()) + \");", "+      }", "+      else {", "+        _writeToFileOut(indentString(baseIndent, 6) + accessors[i].getName() + \"() + \");", "+      }", "+", "+      if (i < accessors.length - 1) {", "+        _writeToFileOut(\"\\\", \\\" + \");", "+      }", "+      _writeToFileOut(newLine);", "+    }", "+    _writeToFileOut(indentString(baseIndent, 6) + \"\\\")\\\";\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"}\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"catch (RuntimeException e) {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 4) + flagName + \" = false;\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 4) + \"throw e;\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"}\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + flagName + \" = false;\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"return result;\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 2) + \"}\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 1) + \"}\" + newLine);", "+  }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f63ba4bed1747977c9ea8240154a4c8e", "repository": "http://git.code.sf.net/p/drjava/git_repo", "fileName": "javalanglevels/src/edu/rice/cs/javalanglevels/Augmentor.java", "commitBeforeChange": "4cc63aff8a22c85ad1d78de9f4e0b9395e7d4e72", "commitAfterChange": "e330f3abbead97d3e3ac8751976bab81936096c2", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "\r   protected static void writeSafeHashCode(String className, SymbolData sd, int baseIndent, boolean waitForVarDef, \r                                           String valueHashCodeName, MethodData[] accessors)", "signatureAfterChange": "   protected static void writeSafeHashCode(String className, SymbolData sd, int baseIndent, boolean waitForVarDef,                                            String valueHashCodeName, MethodData[] accessors)", "diff": ["-   */\r", "-  protected static void writeSafeHashCode(String className, SymbolData sd, int baseIndent, boolean waitForVarDef, \r", "-                                          String valueHashCodeName, MethodData[] accessors) {\r", "-    \r", "-    String listName = \"__hashCodeList\";\r", "-    listName = sd.createUniqueName(listName);\r", "-    VariableData hashCodeList = new VariableData(listName, new ModifiersAndVisibility(JExprParser.NO_SOURCE_INFO, new String[]{ \"private\", \"static\" }),\r", "-                                 _llv.getSymbolDataHelper(\"java.util.LinkedList\", JExprParser.NO_SOURCE_INFO, false, false, false, false),\r", "-                                 true, sd);\r", "-    hashCodeList.setGenerated(true);\r", "-    \r", "-    if (waitForVarDef) {\r", "-      SymbolData outermostData = sd;\r", "-      while (outermostData.getOuterData() != null) {\r", "-        outermostData = outermostData.getOuterData().getSymbolData();\r", "-      }\r", "-      outermostData.addVar(hashCodeList);\r", "-      _endOfClassVarDefs.add(\"/** This field is automatically generated by the Language Level Converter. */\");\r", "-      if (LanguageLevelConverter.versionSupportsGenerics(_targetVersion)) {\r", "-        _endOfClassVarDefs.add(\"private static java.util.LinkedList<Object> \" + listName + \" = new java.util.LinkedList<Object>();\");\r", "-      }\r", "-      else {\r", "-        _endOfClassVarDefs.add(\"private static java.util.LinkedList \" + listName + \" = new java.util.LinkedList();\");\r", "-      }\r", "-      _endOfClassVarDefs.add(\"\");\r", "-    }\r", "-    else {\r", "-      sd.addVar(hashCodeList);\r", "-      _writeToFileOut(newLine + indentString(baseIndent, 1) + \"/** This field is automatically generated by the Language Level Converter. */\");\r", "-      if (LanguageLevelConverter.versionSupportsGenerics(_targetVersion)) {\r", "-        _writeToFileOut(newLine + indentString(baseIndent, 1) + \"private static java.util.LinkedList<\" + className + \"> \" + listName + \" = new java.util.LinkedList<\" + className + \">();\" + newLine);\r", "-      }\r", "-      else {\r", "-        _writeToFileOut(newLine + indentString(baseIndent, 1) + \"private static java.util.LinkedList \" + listName + \" = new java.util.LinkedList();\" + newLine);\r", "-      }\r", "-    }\r", "-    \r", "-    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"/** This method is automatically generated by the Language Level Converter. */\");\r", "-    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"public int hashCode() {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 2) + \"if (\" + listName + \".contains(this)) {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"return -1;\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 2) + \"}\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 2) + \"else {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + listName + \".addLast(this);\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"int result;\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"try {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 4) + \"result = getClass().hashCode()\");\r", "-    for (int i = 0; i < accessors.length; i++) {\r", "-      _writeToFileOut(\" ^ \" + newLine + indentString(baseIndent, 6));\r", "-      SymbolData type = accessors[i].getReturnType().getSymbolData();\r", "-      \r", "-      if (LanguageLevelConverter.versionSupportsAutoboxing(_targetVersion) ||\r", "-          ! type.isPrimitiveType()) {\r", "-        \r", "-        _writeToFileOut(valueHashCodeName + \"(\" + accessors[i].getName() + \"())\");\r", "-      }\r", "-      else if (type == SymbolData.BOOLEAN_TYPE) {\r", "-        _writeToFileOut(\"(\" + accessors[i].getName() + \"() ? 1 : 0)\");\r", "-      }\r", "-      else if (type.isAssignableTo(SymbolData.INT_TYPE, _targetVersion)) {\r", "-        _writeToFileOut(accessors[i].getName() + \"()\");\r", "-      }\r", "-      else {\r", "-        _writeToFileOut(\"(int) \" + accessors[i].getName() + \"()\");           \r", "-      }\r", "-    }\r", "-    \r", "-    _writeToFileOut(\";\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"}\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"catch (RuntimeException e) {\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 4) + listName + \".removeLast();\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 4) + \"throw e;\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"}\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + listName + \".removeLast();\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 3) + \"return result;\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 2) + \"}\" + newLine);\r", "-    _writeToFileOut(indentString(baseIndent, 1) + \"}\" + newLine);\r", "-  }\r", "+   */", "+  protected static void writeSafeHashCode(String className, SymbolData sd, int baseIndent, boolean waitForVarDef, ", "+                                          String valueHashCodeName, MethodData[] accessors) {", "+    ", "+    String listName = \"__hashCodeList\";", "+    listName = sd.createUniqueName(listName);", "+    VariableData hashCodeList = new VariableData(listName, new ModifiersAndVisibility(JExprParser.NO_SOURCE_INFO, new String[]{ \"private\", \"static\" }),", "+                                 _llv.getSymbolDataHelper(\"java.util.LinkedList\", JExprParser.NO_SOURCE_INFO, false, false, false, false),", "+                                 true, sd);", "+    hashCodeList.setGenerated(true);", "+    ", "+    if (waitForVarDef) {", "+      SymbolData outermostData = sd;", "+      while (outermostData.getOuterData() != null) {", "+        outermostData = outermostData.getOuterData().getSymbolData();", "+      }", "+      outermostData.addVar(hashCodeList);", "+      _endOfClassVarDefs.add(\"/** This field is automatically generated by the Language Level Converter. */\");", "+      if (LanguageLevelConverter.OPT.javaVersion().supports(JavaVersion.JAVA_5)) {", "+        _endOfClassVarDefs.add(\"private static java.util.LinkedList<Object> \" + listName + \" = new java.util.LinkedList<Object>();\");", "+      }", "+      else {", "+        _endOfClassVarDefs.add(\"private static java.util.LinkedList \" + listName + \" = new java.util.LinkedList();\");", "+      }", "+      _endOfClassVarDefs.add(\"\");", "+    }", "+    else {", "+      sd.addVar(hashCodeList);", "+      _writeToFileOut(newLine + indentString(baseIndent, 1) + \"/** This field is automatically generated by the Language Level Converter. */\");", "+      if (LanguageLevelConverter.OPT.javaVersion().supports(JavaVersion.JAVA_5)) {", "+        _writeToFileOut(newLine + indentString(baseIndent, 1) + \"private static java.util.LinkedList<\" + className + \"> \" + listName + \" = new java.util.LinkedList<\" + className + \">();\" + newLine);", "+      }", "+      else {", "+        _writeToFileOut(newLine + indentString(baseIndent, 1) + \"private static java.util.LinkedList \" + listName + \" = new java.util.LinkedList();\" + newLine);", "+      }", "+    }", "+    ", "+    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"/** This method is automatically generated by the Language Level Converter. */\");", "+    _writeToFileOut(newLine + indentString(baseIndent, 1) + \"public int hashCode() {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 2) + \"if (\" + listName + \".contains(this)) {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"return -1;\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 2) + \"}\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 2) + \"else {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + listName + \".addLast(this);\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"int result;\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"try {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 4) + \"result = getClass().hashCode()\");", "+    for (int i = 0; i < accessors.length; i++) {", "+      _writeToFileOut(\" ^ \" + newLine + indentString(baseIndent, 6));", "+      SymbolData type = accessors[i].getReturnType().getSymbolData();", "+      ", "+      if (LanguageLevelConverter.OPT.javaVersion().supports(JavaVersion.JAVA_5) ||", "+          ! type.isPrimitiveType()) {", "+        ", "+        _writeToFileOut(valueHashCodeName + \"(\" + accessors[i].getName() + \"())\");", "+      }", "+      else if (type == SymbolData.BOOLEAN_TYPE) {", "+        _writeToFileOut(\"(\" + accessors[i].getName() + \"() ? 1 : 0)\");", "+      }", "+      else if (type.isAssignableTo(SymbolData.INT_TYPE, LanguageLevelConverter.OPT.javaVersion())) {", "+        _writeToFileOut(accessors[i].getName() + \"()\");", "+      }", "+      else {", "+        _writeToFileOut(\"(int) \" + accessors[i].getName() + \"()\");           ", "+      }", "+    }", "+    ", "+    _writeToFileOut(\";\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"}\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"catch (RuntimeException e) {\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 4) + listName + \".removeLast();\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 4) + \"throw e;\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"}\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + listName + \".removeLast();\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 3) + \"return result;\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 2) + \"}\" + newLine);", "+    _writeToFileOut(indentString(baseIndent, 1) + \"}\" + newLine);", "+  }"]}], "num": 826}