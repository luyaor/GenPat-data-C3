{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "af29694c45627eef6628cd6474ab9c5b", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6eeb30a70dd19184500934598c01f34b", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/net/sourceforge/cobertura/ant/InstrumentTask.java", "commitBeforeChange": "4558077bc3fa9bafa9125049db80cf9c99da089f", "commitAfterChange": "f21d7d6c791a9d50e30e19d77af0c8b3f2897c6c", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic void execute() throws BuildException", "signatureAfterChange": "  \tpublic void execute() throws BuildException", "diff": ["-\tpublic void execute() throws BuildException {", "+", "+\tpublic void execute() throws BuildException", "+\t{", "-\t\t\t// ignoreRegex.setRegex() is never called, but that's ok", "-\t\t\t// because ant sets it somehow, I think", "+\t\t\tfor (int i = 0; i < includeClassesRegexs.size(); i++) {", "+\t\t\t\tIncludeClasses includeClassesRegex = (IncludeClasses)includeClassesRegexs.get(i);", "+\t\t\t\tbuilder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());", "+\t\t\t}", "+", "+\t\t\tfor (int i = 0; i < excludeClassesRegexs.size(); i++) {", "+\t\t\t\tExcludeClasses excludeClassesRegex = (ExcludeClasses)excludeClassesRegexs.get(i);", "+\t\t\t\tbuilder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());", "+\t\t\t}", "+", "+\t\t\tif (instrumentationClasspath != null) {", "+\t\t\t\tprocessInstrumentationClasspath();", "+\t\t\t}", "+\t\tif (forkedJVMDebugPort != null && forkedJVMDebugPort.intValue() > 0) {", "+\t\t\tgetJava().createJvmarg().setValue(\"-Xdebug\");", "+\t\t\tgetJava().createJvmarg().setValue(\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort + \",server=y,suspend=y\");", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9589f559d2abc899b147f3d6219d93ff", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/net/sourceforge/cobertura/check/Main.java", "commitBeforeChange": "98a1c5393bec425291a2a3140327df05e58b1582", "commitAfterChange": "e6b9546f524ec82a34db61772929657e87625501", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic Main(String[] args) throws MalformedPatternException", "signatureAfterChange": "  \tpublic Main(String[] args) throws MalformedPatternException", "diff": ["+\t\tdouble packageBranchCoverageRate = 0.0;", "+\t\tdouble packageLineCoverageRate = 0.0;", "+\t\t\t}", "+\t\t\telse if (args[i].equals(\"--packagebranch\"))", "+\t\t\t{", "+\t\t\t\tpackageBranchCoverageRate = inRangeAndDivideByOneHundred(args[++i]);", "+\t\t\t}", "+\t\t\telse if (args[i].equals(\"--packageline\"))", "+\t\t\t{", "+\t\t\t\tpackageLineCoverageRate = inRangeAndDivideByOneHundred(args[++i]);", "+\t\t\t\t&& (packageLineCoverageRate == 0)", "+\t\t\t\t&& (packageBranchCoverageRate == 0)", "+\t\t\tpackageBranchCoverageRate = 0.5;", "+\t\t\tpackageLineCoverageRate = 0.5;", "+\t\t\t}", "+", "+\t\t\tPackageCoverage packageCoverage = getPackageCoverage(classData", "+\t\t\t\t\t.getPackageName());", "+\t\t\tif (packageBranchCoverageRate > 0.0)", "+\t\t\t{", "+\t\t\t\tpackageCoverage.addBranchCount(classData", "+\t\t\t\t\t\t.getNumberOfValidBranches());", "+\t\t\t\tpackageCoverage.addBranchCoverage(classData", "+\t\t\t\t\t\t.getNumberOfCoveredBranches());", "+\t\t\t}", "+", "+\t\t\tif (packageLineCoverageRate > 0.0)", "+\t\t\t{", "+\t\t\t\tpackageCoverage.addLineCount(classData.getNumberOfValidLines());", "+\t\t\t\tpackageCoverage.addLineCoverage(classData", "+\t\t\t\t\t\t.getNumberOfCoveredLines());", "+\t\texitStatus |= checkPackageCoverageLevels(packageBranchCoverageRate,", "+\t\t\t\tpackageLineCoverageRate);", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b47919a7499ed0bb28c1f7b9657c2298", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/net/sourceforge/cobertura/instrument/Main.java", "commitBeforeChange": "73cd6cee6c47bb171b3c10fb87c9d986322605f8", "commitAfterChange": "ea44d50de680cfb1f234670ee0209ccd6aa03416", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tprivate void addInstrumentationToArchive(ZipInputStream archive, \t\t\tZipOutputStream output) throws Exception", "signatureAfterChange": "  \tprivate boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, \t\t\tZipOutputStream output) throws Exception", "diff": ["-\tprivate void addInstrumentationToArchive(ZipInputStream archive,", "+", "+\tprivate boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive,", "+\t\t/*", "+\t\t * \"modified\" is returned and indicates that something was instrumented.", "+\t\t * If nothing is instrumented, the original entry will be used by the", "+\t\t * caller of this method.", "+\t\t */", "+\t\tboolean modified = false;", "+\t\t\t\tString entryName = entry.getName();", "+", "+\t\t\t\t/*", "+\t\t\t\t * If this is a signature file then don't copy it,", "+\t\t\t\t * but don't set modified to true.  If the only", "+\t\t\t\t * thing we do is strip the signature, just use", "+\t\t\t\t * the original entry.", "+\t\t\t\t */", "+\t\t\t\tif (ArchiveUtil.isSignatureFile(entry.getName()))", "+\t\t\t\t{", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\toutputEntry.setComment(entry.getComment());", "+\t\t\t\toutputEntry.setExtra(entry.getExtra());", "+\t\t\t\toutputEntry.setTime(entry.getTime());", "-\t\t\t\t// Check if we have class file", "-\t\t\t\tif (isClass(entry) && shouldInstrument(entry.getName()))", "+\t\t\t\t// Instrument embedded archives if a classPattern has been specified", "+\t\t\t\tif ((classPattern.isSpecified()) && ArchiveUtil.isArchive(entryName))", "+\t\t\t\t{", "+\t\t\t\t\tArchive archiveObj = new Archive(file, entryBytes);", "+\t\t\t\t\taddInstrumentationToArchive(archiveObj);", "+\t\t\t\t\tif (archiveObj.isModified())", "+\t\t\t\t\t{", "+\t\t\t\t\t\tmodified = true;", "+\t\t\t\t\t\tentryBytes = archiveObj.getBytes();", "+\t\t\t\t\t\toutputEntry.setTime(System.currentTimeMillis());", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\telse if (isClass(entry) && classPattern.matches(entryName))", "+\t\t\t\t\t\tmodified = true;", "+\t\t\t\t\t\toutputEntry.setTime(System.currentTimeMillis());", "+\t\treturn modified;"]}]}