{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a153930773890a03e47d52d030b214f0", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "758251cbead62f143cac82b8409cacd3", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/net/sourceforge/cobertura/instrument/Main.java", "commitBeforeChange": "0c76ce91897e30da3c3c98b0dbde4eaeb37f1634", "commitAfterChange": "d668df191a9fd0e829f2fd715bee289ce66ce39e", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprivate void addInstrumentation(File file)", "signatureAfterChange": " \tprivate void addInstrumentation(File file)", "diff": ["-\t\tOutputStream outputStream = null;", "+\t\tClassWriter cw;", "+\t\tClassInstrumenter cv;", "-\t\t\tClassWriter cw = new ClassWriter(true);", "-\t\t\tClassInstrumenter cv = new ClassInstrumenter(projectData, cw,", "-\t\t\t\t\tignoreRegexp);", "+\t\t\tcw = new ClassWriter(true);", "+\t\t\tcv = new ClassInstrumenter(projectData, cw, ignoreRegexp);", "-\t\t\tbyte[] instrumentedClass = cw.toByteArray();", "-", "-\t\t\tif (cv.isInstrumented())", "-\t\t\t{", "-\t\t\t\tFile outputFile = new File(destinationDirectory, cv", "-\t\t\t\t\t\t.getClassName().replace('.', File.separatorChar)", "-\t\t\t\t\t\t+ \".class\");", "-\t\t\t\tFile parentFile = outputFile.getParentFile();", "-\t\t\t\tif (parentFile != null)", "-\t\t\t\t{", "-\t\t\t\t\tparentFile.mkdirs();", "-\t\t\t\t}", "-\t\t\t\toutputStream = new FileOutputStream(outputFile);", "-\t\t\t\toutputStream.write(instrumentedClass);", "-\t\t\t}", "+\t\t\treturn;", "+\t\t}", "+", "+\t\tOutputStream outputStream = null;", "+\t\ttry", "+\t\t{", "+\t\t\tif (cv.isInstrumented())", "+\t\t\t{", "+\t\t\t\t// If destinationDirectory is null, then overwrite", "+\t\t\t\t// the original, uninstrumented file.", "+\t\t\t\tFile outputFile;", "+\t\t\t\tif (destinationDirectory == null)", "+\t\t\t\t\toutputFile = file;", "+\t\t\t\telse", "+\t\t\t\t\toutputFile = new File(destinationDirectory, cv", "+\t\t\t\t\t\t\t.getClassName().replace('.', File.separatorChar)", "+\t\t\t\t\t\t\t+ \".class\");", "+", "+\t\t\t\tFile parentFile = outputFile.getParentFile();", "+\t\t\t\tif (parentFile != null)", "+\t\t\t\t{", "+\t\t\t\t\tparentFile.mkdirs();", "+\t\t\t\t}", "+", "+\t\t\t\tbyte[] instrumentedClass = cw.toByteArray();", "+\t\t\t\toutputStream = new FileOutputStream(outputFile);", "+\t\t\t\toutputStream.write(instrumentedClass);", "+\t\t\t}", "+\t\t}", "+\t\tcatch (IOException e)", "+\t\t{", "+\t\t\tlogger.warn(", "+\t\t\t\t\t\"Unable to instrument file \" + file.getAbsolutePath(), e);", "+\t\t\treturn;", "+\t\t}", "+\t\tfinally", "+\t\t{"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b47919a7499ed0bb28c1f7b9657c2298", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/net/sourceforge/cobertura/instrument/Main.java", "commitBeforeChange": "73cd6cee6c47bb171b3c10fb87c9d986322605f8", "commitAfterChange": "ea44d50de680cfb1f234670ee0209ccd6aa03416", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tprivate void addInstrumentationToArchive(ZipInputStream archive, \t\t\tZipOutputStream output) throws Exception", "signatureAfterChange": "  \tprivate boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, \t\t\tZipOutputStream output) throws Exception", "diff": ["-\tprivate void addInstrumentationToArchive(ZipInputStream archive,", "+", "+\tprivate boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive,", "+\t\t/*", "+\t\t * \"modified\" is returned and indicates that something was instrumented.", "+\t\t * If nothing is instrumented, the original entry will be used by the", "+\t\t * caller of this method.", "+\t\t */", "+\t\tboolean modified = false;", "+\t\t\t\tString entryName = entry.getName();", "+", "+\t\t\t\t/*", "+\t\t\t\t * If this is a signature file then don't copy it,", "+\t\t\t\t * but don't set modified to true.  If the only", "+\t\t\t\t * thing we do is strip the signature, just use", "+\t\t\t\t * the original entry.", "+\t\t\t\t */", "+\t\t\t\tif (ArchiveUtil.isSignatureFile(entry.getName()))", "+\t\t\t\t{", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\toutputEntry.setComment(entry.getComment());", "+\t\t\t\toutputEntry.setExtra(entry.getExtra());", "+\t\t\t\toutputEntry.setTime(entry.getTime());", "-\t\t\t\t// Check if we have class file", "-\t\t\t\tif (isClass(entry) && shouldInstrument(entry.getName()))", "+\t\t\t\t// Instrument embedded archives if a classPattern has been specified", "+\t\t\t\tif ((classPattern.isSpecified()) && ArchiveUtil.isArchive(entryName))", "+\t\t\t\t{", "+\t\t\t\t\tArchive archiveObj = new Archive(file, entryBytes);", "+\t\t\t\t\taddInstrumentationToArchive(archiveObj);", "+\t\t\t\t\tif (archiveObj.isModified())", "+\t\t\t\t\t{", "+\t\t\t\t\t\tmodified = true;", "+\t\t\t\t\t\tentryBytes = archiveObj.getBytes();", "+\t\t\t\t\t\toutputEntry.setTime(System.currentTimeMillis());", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\telse if (isClass(entry) && classPattern.matches(entryName))", "+\t\t\t\t\t\tmodified = true;", "+\t\t\t\t\t\toutputEntry.setTime(System.currentTimeMillis());", "+\t\treturn modified;"]}]}