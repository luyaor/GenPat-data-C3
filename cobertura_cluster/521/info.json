{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ae180507a71062a0b2d91a55e8b4e442", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1a7d8ee8da0b0e1632416fcdc6d68219", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/main/java/net/sourceforge/cobertura/instrument/pass2/BuildClassMapClassVisitor.java", "commitBeforeChange": "35acea63ae80bc6a1e7453e64f26fa350a167870", "commitAfterChange": "686ffbecc7fe730d4e67767186de755b501fcc7f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \t@Override \tpublic AnnotationVisitor visitAnnotation(String name, boolean arg1)", "signatureAfterChange": "  \t@Override \tpublic AnnotationVisitor visitAnnotation(String name, boolean arg1)", "diff": ["+\t\t} else if (ignoredClassAnnotations != null) {", "+\t\t\tString className = Type.getObjectType(name).getClassName();", "+\t\t\t// Class name contains artifacts anyway so trimming them out before", "+\t\t\t// matching", "+\t\t\tString normalizedClassName = className.replaceAll(\"[L;]\", \"\");", "+\t\t\tif (ignoredClassAnnotations.contains(normalizedClassName)) {", "+\t\t\t\ttoInstrument = false;", "+\t\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d3f372f7fab05707083db286949a0eae", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "metrics/metrics-api/src/main/java/net/sourceforge/cobertura/metrics/api/location/SourceLocationFilter.java", "commitBeforeChange": "6f6a7661efb1fcbc73aa09bb85cdab7bdaf35db8", "commitAfterChange": "d1cf5bb06c93aa997e1f1f2066f2bdd82d480da5", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "     @Override     public boolean accept(final SourceLocation candidate)", "signatureAfterChange": "     @Override     public boolean accept(final SourceLocation candidate)", "diff": ["-        if(acceptAllInProject) {", "+        if (acceptAllInProject) {", "-            for(LocationScope current : LocationScope.values()) {", "+            for (LocationScope current : COMPARISON_ORDER) {", "-                if(current.compareTo(scope) > 0) {", "+                // Only compare down to the level defined within this SourceLocationFilter.", "+                if (current.compareTo(scope) > 0) {", "-                // Compare", "+                // Compare scope values to actual ones.", "+                final String toMatch = \"\" + candidate.get(current);", "+                final Matcher matcher = locationPatternMap.get(current).matcher(toMatch);", "+                if (!matcher.matches()) {", "+                    return false;", "+                }", "-        return false;", "+", "+        // All OK.", "+        return true;", "+    }"]}]}