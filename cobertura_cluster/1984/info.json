{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "27732cfdc15c9062af836196bdf9dce4", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0ffdd3d4a4618a66ce9937850ed897e", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/net/sourceforge/cobertura/coveragedata/ClassData.java", "commitBeforeChange": "fbee7ffc48bf33e8b027bcf667d5b6cdd9327aa4", "commitAfterChange": "4bbdbd75ab55c5d1b8592d3d81ff16479146ef37", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic void merge(ClassData coverageData)", "signatureAfterChange": " \tpublic void merge(CoverageData coverageData)", "diff": ["-\tpublic void merge(ClassData coverageData)", "+\tpublic void merge(CoverageData coverageData)", "-\t\tchildren.putAll(coverageData.children);", "-\t\tbranches.putAll(coverageData.branches);", "-\t\tmethodNamesAndDescriptors.addAll(coverageData", "+\t\tsuper.merge(coverageData);", "+", "+\t\tClassData classData = (ClassData)coverageData;", "+", "+\t\t// We can't just call this.branches.putAll(classData.branches);", "+\t\t// Why not?  If we did a putAll, then the LineData objects from", "+\t\t// the coverageData class would overwrite the LineData objects", "+\t\t// that are already in \"this.branches\"  And we don't need to", "+\t\t// update the LineData objects that are already in this.branches", "+\t\t// because they are shared between this.branches and this.children,", "+\t\t// so the object hit counts will be moved when we called", "+\t\t// super.merge() above.", "+\t\tfor (Iterator iter = classData.branches.keySet().iterator(); iter.hasNext();)", "+\t\t{", "+\t\t\tObject key = iter.next();", "+\t\t\tif (!this.branches.containsKey(key))", "+\t\t\t{", "+\t\t\t\tthis.branches.put(key, classData.branches.get(key));", "+\t\t\t}", "+\t\t}", "+", "+\t\tthis.methodNamesAndDescriptors.addAll(classData"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fa743df4daac5ec15383d0607c7be36c", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/net/sourceforge/cobertura/coveragedata/ClassData.java", "commitBeforeChange": "9d9559bc35e31469dc0037197bbb87c9c61ff122", "commitAfterChange": "3c60402fd58f26a40620843b35fedf083357e308", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tpublic void merge(CoverageData coverageData)", "signatureAfterChange": " \tpublic void merge(CoverageData coverageData)", "diff": ["-\t\tsuper.merge(coverageData);", "-", "-\t\t// We can't just call this.branches.putAll(classData.branches);", "-\t\t// Why not?  If we did a putAll, then the LineData objects from", "-\t\t// the coverageData class would overwrite the LineData objects", "-\t\t// that are already in \"this.branches\"  And we don't need to", "-\t\t// update the LineData objects that are already in this.branches", "-\t\t// because they are shared between this.branches and this.children,", "-\t\t// so the object hit counts will be moved when we called", "-\t\t// super.merge() above.", "-\t\tfor (Iterator iter = classData.branches.keySet().iterator(); iter.hasNext();)", "+\t\tgetBothLocks(classData);", "+\t\ttry", "-\t\t\tObject key = iter.next();", "-\t\t\tif (!this.branches.containsKey(key))", "+\t\t\tsuper.merge(coverageData);", "+\t", "+\t\t\t// We can't just call this.branches.putAll(classData.branches);", "+\t\t\t// Why not?  If we did a putAll, then the LineData objects from", "+\t\t\t// the coverageData class would overwrite the LineData objects", "+\t\t\t// that are already in \"this.branches\"  And we don't need to", "+\t\t\t// update the LineData objects that are already in this.branches", "+\t\t\t// because they are shared between this.branches and this.children,", "+\t\t\t// so the object hit counts will be moved when we called", "+\t\t\t// super.merge() above.", "+\t\t\tfor (Iterator iter = classData.branches.keySet().iterator(); iter.hasNext();)", "-\t\t\t\tthis.branches.put(key, classData.branches.get(key));", "+\t\t\t\tObject key = iter.next();", "+\t\t\t\tif (!this.branches.containsKey(key))", "+\t\t\t\t{", "+\t\t\t\t\tthis.branches.put(key, classData.branches.get(key));", "+\t\t\t\t}", "+\t", "+\t\t\tthis.containsInstrumentationInfo |= classData.containsInstrumentationInfo;", "+\t\t\tthis.methodNamesAndDescriptors.addAll(classData", "+\t\t\t\t\t.getMethodNamesAndDescriptors());", "+\t\t\tif (classData.sourceFileName != null)", "+\t\t\t\tthis.sourceFileName = classData.sourceFileName;", "-", "-\t\tthis.containsInstrumentationInfo |= classData.containsInstrumentationInfo;", "-\t\tthis.methodNamesAndDescriptors.addAll(classData", "-\t\t\t\t.getMethodNamesAndDescriptors());", "-\t\tif (classData.sourceFileName != null)", "-\t\t\tthis.sourceFileName = classData.sourceFileName;", "+\t\tfinally", "+\t\t{", "+\t\t\tlock.unlock();", "+\t\t\tclassData.lock.unlock();", "+\t}"]}]}