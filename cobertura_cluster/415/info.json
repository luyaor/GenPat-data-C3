{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0bd48c43f11a3f7202e09710dd737faa", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e7bc6ca07917f8704c65886db74ff49a", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/net/sourceforge/cobertura/coveragedata/ProjectData.java", "commitBeforeChange": "e07225a2249906b0c1fed76505d3565cbd3af0ac", "commitAfterChange": "ea3afef1448dc7ea01f62b71d341c731f6e990ec", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tpublic void merge(CoverageData coverageData)", "signatureAfterChange": "  \tpublic void merge(CoverageData coverageData)", "diff": ["+ \t\tfor (Iterator iter = projectData.sourceFiles.keySet().iterator(); iter.hasNext();)", "+ \t\t{", "+ \t\t\tObject key = iter.next();", "+ \t\t\tif (!this.sourceFiles.containsKey(key))", "+ \t\t\t{", "+ \t\t\t\tthis.sourceFiles.put(key, projectData.sourceFiles.get(key));", "+ \t\t\t}", "+ \t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0ffdd3d4a4618a66ce9937850ed897e", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/net/sourceforge/cobertura/coveragedata/ClassData.java", "commitBeforeChange": "fbee7ffc48bf33e8b027bcf667d5b6cdd9327aa4", "commitAfterChange": "4bbdbd75ab55c5d1b8592d3d81ff16479146ef37", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic void merge(ClassData coverageData)", "signatureAfterChange": " \tpublic void merge(CoverageData coverageData)", "diff": ["-\tpublic void merge(ClassData coverageData)", "+\tpublic void merge(CoverageData coverageData)", "-\t\tchildren.putAll(coverageData.children);", "-\t\tbranches.putAll(coverageData.branches);", "-\t\tmethodNamesAndDescriptors.addAll(coverageData", "+\t\tsuper.merge(coverageData);", "+", "+\t\tClassData classData = (ClassData)coverageData;", "+", "+\t\t// We can't just call this.branches.putAll(classData.branches);", "+\t\t// Why not?  If we did a putAll, then the LineData objects from", "+\t\t// the coverageData class would overwrite the LineData objects", "+\t\t// that are already in \"this.branches\"  And we don't need to", "+\t\t// update the LineData objects that are already in this.branches", "+\t\t// because they are shared between this.branches and this.children,", "+\t\t// so the object hit counts will be moved when we called", "+\t\t// super.merge() above.", "+\t\tfor (Iterator iter = classData.branches.keySet().iterator(); iter.hasNext();)", "+\t\t{", "+\t\t\tObject key = iter.next();", "+\t\t\tif (!this.branches.containsKey(key))", "+\t\t\t{", "+\t\t\t\tthis.branches.put(key, classData.branches.get(key));", "+\t\t\t}", "+\t\t}", "+", "+\t\tthis.methodNamesAndDescriptors.addAll(classData"]}]}