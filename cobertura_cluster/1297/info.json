{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "393f95ed23a0636bf95dbf24b082ead1", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5be54419290c4d76474af7a9a4f7465a", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "metrics/metrics-api/src/test/java/net/sourceforge/cobertura/metrics/api/helpers/DebugCoverageCalculator.java", "commitBeforeChange": "6f6a7661efb1fcbc73aa09bb85cdab7bdaf35db8", "commitAfterChange": "d1cf5bb06c93aa997e1f1f2066f2bdd82d480da5", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 1, "signatureBeforeChange": "     @Override     protected Rate getRate(final CoverageType nonNullCoverageType)", "signatureAfterChange": "     @Override     protected Rate getRate(final SourceLocationFilter nonNullFilter, final CoverageType nonNullCoverageType)", "diff": ["-    protected Rate getRate(final CoverageType nonNullCoverageType) {", "+    protected Rate getRate(final SourceLocationFilter nonNullFilter, final CoverageType nonNullCoverageType) {", "-        Rate toReturn = new Rate();", "-", "-        for(Map.Entry<SourceLocation, Integer> current : listener.recordedSteps.entrySet()) {", "-", "+        if(nonNullCoverageType == CoverageType.BRANCH) {", "+            throw new IllegalArgumentException(\"Cannot handle branch coverage.\");", "-        return null;", "+        final Filter<Tuple<SourceLocation, CoverageRecord>> filter = new Filter<Tuple<SourceLocation, CoverageRecord>>() {", "+            @Override", "+            public boolean accept(final Tuple<SourceLocation, CoverageRecord> candidate) {", "+                return candidate != null && nonNullFilter.accept(candidate.getKey());", "+            }", "+        };", "+", "+        final Map<SourceLocation, CoverageRecord> result = CollectionAlgorithms.filter(coverageRecords, filter);", "+        int hits = 0;", "+        for(CoverageRecord current : result.values()) {", "+            if(current.getHitCount() != 0) {", "+                hits++;", "+            }", "+        }", "+", "+        // All done.", "+        return new Rate(result.size(), hits, CoverageType.LINE.toString());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b47919a7499ed0bb28c1f7b9657c2298", "repository": "https://github.com/cobertura/cobertura.git", "fileName": "cobertura/src/net/sourceforge/cobertura/instrument/Main.java", "commitBeforeChange": "73cd6cee6c47bb171b3c10fb87c9d986322605f8", "commitAfterChange": "ea44d50de680cfb1f234670ee0209ccd6aa03416", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tprivate void addInstrumentationToArchive(ZipInputStream archive, \t\t\tZipOutputStream output) throws Exception", "signatureAfterChange": "  \tprivate boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, \t\t\tZipOutputStream output) throws Exception", "diff": ["-\tprivate void addInstrumentationToArchive(ZipInputStream archive,", "+", "+\tprivate boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive,", "+\t\t/*", "+\t\t * \"modified\" is returned and indicates that something was instrumented.", "+\t\t * If nothing is instrumented, the original entry will be used by the", "+\t\t * caller of this method.", "+\t\t */", "+\t\tboolean modified = false;", "+\t\t\t\tString entryName = entry.getName();", "+", "+\t\t\t\t/*", "+\t\t\t\t * If this is a signature file then don't copy it,", "+\t\t\t\t * but don't set modified to true.  If the only", "+\t\t\t\t * thing we do is strip the signature, just use", "+\t\t\t\t * the original entry.", "+\t\t\t\t */", "+\t\t\t\tif (ArchiveUtil.isSignatureFile(entry.getName()))", "+\t\t\t\t{", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\toutputEntry.setComment(entry.getComment());", "+\t\t\t\toutputEntry.setExtra(entry.getExtra());", "+\t\t\t\toutputEntry.setTime(entry.getTime());", "-\t\t\t\t// Check if we have class file", "-\t\t\t\tif (isClass(entry) && shouldInstrument(entry.getName()))", "+\t\t\t\t// Instrument embedded archives if a classPattern has been specified", "+\t\t\t\tif ((classPattern.isSpecified()) && ArchiveUtil.isArchive(entryName))", "+\t\t\t\t{", "+\t\t\t\t\tArchive archiveObj = new Archive(file, entryBytes);", "+\t\t\t\t\taddInstrumentationToArchive(archiveObj);", "+\t\t\t\t\tif (archiveObj.isModified())", "+\t\t\t\t\t{", "+\t\t\t\t\t\tmodified = true;", "+\t\t\t\t\t\tentryBytes = archiveObj.getBytes();", "+\t\t\t\t\t\toutputEntry.setTime(System.currentTimeMillis());", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\telse if (isClass(entry) && classPattern.matches(entryName))", "+\t\t\t\t\t\tmodified = true;", "+\t\t\t\t\t\toutputEntry.setTime(System.currentTimeMillis());", "+\t\treturn modified;"]}]}