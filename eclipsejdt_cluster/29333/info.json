{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "490ffe82d07ef2e00b4a341e3a362538", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "03d1f3362ab08a6af8c3640c3b799cb0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "acb688302e3cacbdc42738d6941f0a71f5b00f9c", "commitAfterChange": "37562c5a562cc71ff03559ef16cdaf50168f2116", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \t \tpublic ClassInstanceCreation convert(AnonymousLocalTypeDeclaration expression)", "signatureAfterChange": "  \tpublic ArrayCreation convert(org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression expression)", "diff": ["-\tpublic ClassInstanceCreation convert(AnonymousLocalTypeDeclaration expression) {", "-\t\tClassInstanceCreation classInstanceCreation = this.ast.newClassInstanceCreation();", "-\t\tclassInstanceCreation.setName(convert(expression.allocation.type));", "-\t\tif (expression.allocation.enclosingInstance != null) {", "-\t\t\tclassInstanceCreation.setExpression(convert(expression.allocation.enclosingInstance));", "-\t\t}", "-\t\tint declarationSourceStart = expression.allocation.sourceStart;", "-\t\tclassInstanceCreation.setSourceRange(declarationSourceStart, expression.bodyEnd - declarationSourceStart + 1);", "-\t\torg.eclipse.jdt.internal.compiler.ast.Expression[] arguments = expression.allocation.arguments;", "-\t\tif (arguments != null) {", "-\t\t\tint length = arguments.length;", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tclassInstanceCreation.arguments().add(convert(arguments[i]));", "-\t\t\t}", "-\t\t}", "-\t\tAnonymousClassDeclaration anonymousClassDeclaration = this.ast.newAnonymousClassDeclaration();", "-\t\tint start = retrieveStartBlockPosition(declarationSourceStart, expression.bodyEnd);", "-\t\tanonymousClassDeclaration.setSourceRange(start, expression.bodyEnd - start + 1);", "-\t\tclassInstanceCreation.setAnonymousClassDeclaration(anonymousClassDeclaration);", "-\t\tbuildBodyDeclarations(expression, anonymousClassDeclaration);", "-\t\tif (this.resolveBindings) {", "-\t\t\trecordNodes(classInstanceCreation, expression);", "-\t\t\trecordNodes(anonymousClassDeclaration, expression);", "-\t\t\tanonymousClassDeclaration.resolveBinding();", "-\t\t}", "-\t\treturn classInstanceCreation;", "-\t}", "+\tpublic ArrayCreation convert(org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression expression) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc8392b12ceb2ea622873ccaa8a5fb39", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "6a44e0777af1a4632e0d20c0e9b92d35d2ad59f3", "commitAfterChange": "2ca339c139c0fe73a5bd2705f66592731098d347", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "diff": ["-\t\tchar[] source = this.scanner.source;", "-\t\tif (false/*this.sourceParser.checkAnnotation*/) {", "-\t\t\tthis.annotation = new Annotation(annotationStart, annotationEnd);", "-\t\t} else {", "-\t\t\tthis.annotation = null;", "-\t\t} ", "-\t", "-\t\tint firstLineNumber = this.scanner.getLineNumber(annotationStart);", "-\t\tint lastLineNumber = this.scanner.getLineNumber(annotationEnd);", "-\t\tint[] index = new int[]{ 0 };", "-\t\t\t\t", "-\t\t// scan line per line, since tags are supposed to be at beginning of lines only", "-\t\tnextLine: for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "-\t\t\tint lineStart = this.scanner.getLineStart(line);", "-\t\t\tif (line == firstLineNumber) lineStart = annotationStart + 3; // skip leading /**", "-\t\t\tint lineEnd = this.scanner.getLineEnd(line);", "-\t\t\tif (line == lastLineNumber) lineEnd = annotationEnd - 2; // remove trailing */", "-\t\t\tindex[0] = lineStart;", "-\t\t\tboolean foundStar = false;", "-\t\t\twhile (index[0] < lineEnd) {", "-\t\t\t\tchar nextCharacter = getNextCharacter(source, index); // consider unicodes", "-\t\t\t\tswitch(nextCharacter) {", "-\t\t\t\t\tcase '@' :", "-\t\t\t\t\t\tif (this.annotation == null) {", "-\t\t\t\t\t\t\tif ((getNextCharacter(source, index) == 'd')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'p')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'r')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'c')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'a')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 't')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'd')) {", "-\t\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "-\t\t\t\t\t\t\t\tnextCharacter = getNextCharacter(source, index);", "-\t\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "-\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t\tbreak nextLine; // done", "+\t\ttry {", "+\t\t\tthis.source = this.sourceParser.scanner.source;", "+\t\t\tif (this.sourceParser.options.checkAnnotation) {", "+\t\t\t\tthis.annotation = new Annotation(annotationStart, annotationEnd);", "+\t\t\t\tthis.identifierPtr = -1;", "+\t\t\t} else {", "+\t\t\t\tthis.annotation = null;", "+\t\t\t} ", "+\t\t", "+\t\t\tint firstLineNumber = this.sourceParser.scanner.getLineNumber(annotationStart);", "+\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(annotationEnd);", "+\t\t\t\t\t", "+\t\t\t// scan line per line, since tags must be at beginning of lines only", "+\t\t\tnextLine: for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "+\t\t\t\tboolean foundStar = false;", "+\t\t\t\tint lineStart = line == firstLineNumber ", "+\t\t\t\t\t\t? annotationStart + 3 \t\t// skip leading /**", "+\t\t\t\t\t\t:  this.sourceParser.scanner.getLineStart(line);", "+\t\t\t\tthis.index[0] = lineStart;", "+\t\t\t\tint lineEnd = line == lastLineNumber", "+\t\t\t\t\t\t? annotationEnd - 2 \t\t// remove trailing */", "+\t\t\t\t\t\t:  this.sourceParser.scanner.getLineEnd(line);", "+\t\t\t\twhile (this.index[0] < lineEnd) {", "+\t\t\t\t\tchar nextCharacter = readChar(); // consider unicodes", "+\t\t\t\t\tswitch(nextCharacter) {", "+\t\t\t\t\t\tcase '@' :", "+\t\t\t\t\t\t\tif (this.annotation == null) {", "+\t\t\t\t\t\t\t\tif ((readChar() == 'd')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'p')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'r')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'c')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'a')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 't')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'd')) {", "+\t\t\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "+\t\t\t\t\t\t\t\t\tnextCharacter = readChar();", "+\t\t\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "+\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t\tbreak nextLine; // done", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\t\t} ", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.index[0], lineEnd);", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\tswitch (this.scanner.getNextToken()) {", "+\t\t\t\t\t\t\t\t\tcase  TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseParam();", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_THROWS) || CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseThrows();", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseSee();", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "+\t\t\t\t\t\t\t\t\t\tparseReturn();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t\t} ", "-/*", "- \t\t\t\t\t\t// parse annotation", "-\t\t\t\t\t\tint tagStart = index[0], tagEnd = 0;", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tsaveScannerState();", "-\t\t\t\t\t\t\tthis.scanner.startPosition = index[0];", "-\t\t\t\t\t\t\tthis.scanner.currentPosition = index[0];", "-\t\t\t\t\t\t\tthis.scanner.currentCharacter = -1;", "-\t\t\t\t\t\t\t// read tag", "-\t\t\t\t\t\t\tparseTag();", "-\t\t\t\t\t\t} finally {", "-\t\t\t\t\t\t\tloadScannerState();", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\t\tdo {", "-\t\t\t\t\t\t\tnextCharacter = getNextCharacter(source, index);", "-\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk", "-\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') break; ", "-\t\t\t\t\t\t\tthis.annotationBuffer[bufferLength++] = nextCharacter;", "-\t\t\t\t\t\t\ttagEnd = index[0];", "-\t\t\t\t\t\t} while (index[0] < lineEnd);", "-\t\t\t\t\t\tif (bufferLength == 0) continue nextLine;", "-\t\t\t\t\t\tchar[] tag = null;", "-\t\t\t\t\t\tswitch(this.annotationBuffer[0]) {", "-\t\t\t\t\t\t\tcase 'd' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_DEPRECATED, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_DEPRECATED;", "-\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase 'e' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_EXCEPTION, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_EXCEPTION;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase 't' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_THROWS, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_THROWS;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 's' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_SEE, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_SEE;", "-\t\t\t\t\t\t\t\t} else if (CharOperation.equals(Annotation.TAG_SINCE, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_SINCE;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 'p' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_PARAM, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_PARAM;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 'r' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_RETURN, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_RETURN;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (tag == null) {", "-\t\t\t\t\t\t\ttag = new char[bufferLength];", "-\t\t\t\t\t\t\tSystem.arraycopy(this.annotationBuffer, 0, tag, 0, bufferLength);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// read argument", "-\t\t\t\t\t\tint argumentStart = index[0];", "-\t\t\t\t\t\twhile (argumentStart < lineEnd && Character.isWhitespace(source[argumentStart])) argumentStart++; // trim argument leading spaces", "-\t\t\t\t\t\tint argumentEnd = lineEnd-1;", "-\t\t\t\t\t\twhile (argumentEnd > argumentStart && Character.isWhitespace(source[argumentEnd])) argumentEnd--; // trim argument trailing spaces", "-\t\t\t\t\t\tbufferLength = 0;", "-\t\t\t\t\t\tfor (index[0] = argumentStart; index[0] <= argumentEnd;) {", "-\t\t\t\t\t\t\tthis.annotationBuffer[bufferLength++] = getNextCharacter(source, index);", "-\t\t\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t\t\tchar[] argument = new char[bufferLength];", "-\t\t\t\t\t\tSystem.arraycopy(this.annotationBuffer, 0, argument, 0, bufferLength);", "-\t\t\t\t\t\tannotation.record(tag, argument, tagStart, argumentEnd);", "-*/\t\t\t\t\t\t", "-\t\t\t\t\t\tcontinue nextLine;", "-\t\t\t\t\tcase '*' :", "-\t\t\t\t\t\tif (foundStar) continue nextLine;", "-\t\t\t\t\t\tfoundStar = true;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault :", "-\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) continue nextLine;", "+\t\t\t\t\t\tcase '*' :", "+\t\t\t\t\t\t\tif (foundStar) continue nextLine;", "+\t\t\t\t\t\t\tfoundStar = true;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) continue nextLine;", "+\t\t\t\t\t}", "-\t\t}", "-\t\t", "+\t\t} finally {", "+\t\t\tthis.source = null; // release source as soon as finished", "+\t\t}\t\t"]}], "num": 29333}