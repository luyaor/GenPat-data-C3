{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5d1f3b4217a325c85050bc1f221c3749", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2eb640df1b61047abe235ab7ff28856b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "9fa4ee2d52d7a35a0c57f8c4b875f0f155754f75", "commitAfterChange": "330462fa1b1e3cc7e6b257e0a0f3470535bf4f54", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments, \t\t\t\t\t\t\t\t\tint depth, \t\t\t\t\t\t\t\t\tboolean mustResolve, \t\t\t\t\t\t\t\t\tTypeBinding type)", "signatureAfterChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments, \t\t\t\t\t\t\t\t\tint depth, \t\t\t\t\t\t\t\t\tTypeBinding type)", "diff": ["-\t\t\t\t\t\t\t\t\tboolean mustResolve,", "-\tif (type == null || patternTypeArguments == null|| patternTypeArguments.length == 0) return level;", "+\tif (type == null || patternTypeArguments == null|| patternTypeArguments.length == 0 || depth>=patternTypeArguments.length || patternTypeArguments[depth] == null) return level;", "+\t", "+\t// if pattern is erasure match (see bug 79790), commute impossible to erasure", "+\tint impossible = this.isErasureMatch ? ERASURE_MATCH : IMPOSSIBLE_MATCH;", "-\t\t\tif (mustResolve)", "+\t\t\tif (this.mustResolve)", "+\t\t\t\tboolean patternTypeArgHasAnyChars = CharOperation.contains(new char[] {'*', '?'}, patternTypeArgument);", "-\t\t\t\t\t\t\t// We cannot know in this case...", "-\t\t\t\t\t\t\tlevel = INACCURATE_MATCH;", "+\t\t\t\t\t\t\t// Invalid if type argument is not exact", "+\t\t\t\t\t\t\tif (patternTypeArgHasAnyChars) return impossible;", "-\t\t\t\t\t// Look for bound name in hierarchy", "+\t\t\t\t\t// Look if bound name match pattern type argument", "+\t\t\t\t\tif (CharOperation.match(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\tCharOperation.match(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\t// found name in hierarchy => match", "+\t\t\t\t\t\tcontinue nextTypeArgument;", "+\t\t\t\t\t}", "+", "+\t\t\t\t\t// If pattern is not exact then match fails", "+\t\t\t\t\tif (patternTypeArgHasAnyChars) return impossible;", "+\t\t\t\t\t\t", "+\t\t\t\t\t// Look for bound name in type argument superclasses", "+\t\t\t\t\tboundBinding = boundBinding.superclass();", "-\t\t\t\t\t\tif (CharOperation.match(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\t\tCharOperation.match(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\tif (CharOperation.equals(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\t\tCharOperation.equals(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\t\treturn impossible;", "+", "+\t\t\t\t// If pattern is not exact then match fails", "+\t\t\t\tif (patternTypeArgHasAnyChars) return impossible;", "-\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\treturn impossible;", "-\t\t\tif (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeArguments, depth+1, mustResolve, enclosingType) == IMPOSSIBLE_MATCH) {", "-\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t}", "+\t\t\tint enclosingLevel = resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeArguments, depth+1, enclosingType);", "+\t\t\tif (enclosingLevel == impossible) return impossible;", "+\t\t\tif (enclosingLevel == IMPOSSIBLE_MATCH) return IMPOSSIBLE_MATCH;", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7c27789ae2b32d3bf92186df88aa28ab", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java", "commitBeforeChange": "b1ce5a863ad0a541f80dd0793ff207f1e4ecf677", "commitAfterChange": "72d60854091bd7e8a5aafafdfea62cc297a3eb41", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tpublic static Test buildTestSuite(Class evaluationTestClass, String testPrefix, String suiteName)", "signatureAfterChange": "  \tpublic static Test buildTestSuite(Class evaluationTestClass, String testPrefix, String suiteName)", "diff": ["-\t\tfor (int m = 0, max = methods.length; m < max; m++) {", "+\t\tnextMethod: for (int m = 0, max = methods.length; m < max; m++) {", "-\t\t\t\t\tint numStart = testPrefix.length();", "-\t\t\t\t\t// tests names subset", "-\t\t\t\t\tif (testsNames != null) {", "-\t\t\t\t\t\tfor (int i = 0, imax= testsNames.length; i<imax; i++) {", "-\t\t\t\t\t\t\tif (testsNames[i].equals(methName) || testsNames[i].equals(methName.substring(numStart))) {", "-\t\t\t\t\t\t\t\ttests.add(methName);", "-\t\t\t\t\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t// no prefix, no subsets => add method", "+\t\t\t\t\tif (testPrefix == null && testsNames == null && testsNumbers == null && testsRange == null) {", "+\t\t\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "+\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t// look for test number", "-\t\t\t\t\tif (methName.startsWith(testPrefix) && Character.isDigit(methName.charAt(numStart))) {", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t// get test number", "-\t\t\t\t\t\t\tint n = numStart;", "-\t\t\t\t\t\t\twhile (methName.charAt(n) == '0') n++;", "-\t\t\t\t\t\t\tint num = Integer.parseInt(methName.substring(n));", "-\t\t\t\t\t\t\t// tests numbers subset", "-\t\t\t\t\t\t\tif (testsNumbers != null && !tests.contains(methName)) {", "-\t\t\t\t\t\t\t\tfor (int i = 0; i < testsNumbers.length; i++) {", "-\t\t\t\t\t\t\t\t\tif (testsNumbers[i] == num) {", "-\t\t\t\t\t\t\t\t\t\ttests.add(methName);", "-\t\t\t\t\t\t\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// tests range subset", "-\t\t\t\t\t\t\tif (testsRange != null && testsRange.length == 2 && !tests.contains(methName)) {", "-\t\t\t\t\t\t\t\tif ((testsRange[0]==-1 || num>=testsRange[0]) && (testsRange[1]==-1 || num<=testsRange[1])) {", "+\t\t\t\t\t// no prefix or method matches prefix", "+\t\t\t\t\tif (testPrefix == null || methName.startsWith(testPrefix)) {", "+\t\t\t\t\t\tint numStart = testPrefix==null ? 4 /* test */ : testPrefix.length();", "+\t\t\t\t\t\t// tests names subset", "+\t\t\t\t\t\tif (testsNames != null) {", "+\t\t\t\t\t\t\tfor (int i = 0, imax= testsNames.length; i<imax; i++) {", "+\t\t\t\t\t\t\t\tif (testsNames[i].equals(methName) || testsNames[i].equals(methName.substring(numStart))) {", "+\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\t} catch (NumberFormatException e) {", "-\t\t\t\t\t\t\tSystem.out.println(\"Method \"+methods[m]+\" has an invalid number format: \"+e.getMessage());", "-\t\t\t\t\t}", "-\t\t\t\t\t// no subset, add all tests", "-\t\t\t\t\tif (testsNames==null && testsNumbers==null &&testsRange==null) {", "-\t\t\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "+\t\t\t\t\t\t// look for test number", "+\t\t\t\t\t\tint length = methName.length();", "+\t\t\t\t\t\tif (numStart < length) {", "+\t\t\t\t\t\t\t// get test number", "+\t\t\t\t\t\t\twhile (numStart<length && !Character.isDigit(methName.charAt(numStart))) numStart++; // skip to first digit", "+\t\t\t\t\t\t\twhile (numStart<length && methName.charAt(numStart) == '0') numStart++; // skip to first non-nul digit", "+\t\t\t\t\t\t\tint n = numStart;", "+\t\t\t\t\t\t\twhile (n<length && Character.isDigit(methName.charAt(n))) n++; // skip to next non-digit", "+\t\t\t\t\t\t\tif (n>numStart && n <= length) {", "+\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\tint num = Integer.parseInt(methName.substring(numStart, n));", "+\t\t\t\t\t\t\t\t\t// tests numbers subset", "+\t\t\t\t\t\t\t\t\tif (testsNumbers != null && !tests.contains(methName)) {", "+\t\t\t\t\t\t\t\t\t\tfor (int i = 0; i < testsNumbers.length; i++) {", "+\t\t\t\t\t\t\t\t\t\t\tif (testsNumbers[i] == num) {", "+\t\t\t\t\t\t\t\t\t\t\t\ttests.add(methName);", "+\t\t\t\t\t\t\t\t\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "+\t\t\t\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// tests range subset", "+\t\t\t\t\t\t\t\t\tif (testsRange != null && testsRange.length == 2 && !tests.contains(methName)) {", "+\t\t\t\t\t\t\t\t\t\tif ((testsRange[0]==-1 || num>=testsRange[0]) && (testsRange[1]==-1 || num<=testsRange[1])) {", "+\t\t\t\t\t\t\t\t\t\t\ttests.add(methName);", "+\t\t\t\t\t\t\t\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "+\t\t\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} catch (NumberFormatException e) {", "+\t\t\t\t\t\t\t\t\tSystem.out.println(\"Method \"+methods[m]+\" has an invalid number format: \"+e.getMessage());", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+", "+\t\t\t\t\t\t// no subset, add all tests", "+\t\t\t\t\t\tif (testsNames==null && testsNumbers==null && testsRange==null) {", "+\t\t\t\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "+\t\t\t\t\t\t}"]}], "num": 63839}