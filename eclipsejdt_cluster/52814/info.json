{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9979e98d6c79d50d73b674a09e144580", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fa76563731cb5ebd98c4a62dc092ccea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "43dabbeccd524672d5c0373f4a964115fa6cc6d6", "commitAfterChange": "ab546e3212785482d3e5b8c6a85c81ea993a1abf", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tprivate void checkAndSetModifiers()", "signatureAfterChange": " \t \tprivate void checkAndSetModifiers()", "diff": ["+\t\t\t\t\tboolean needAbstractBit = false;", "-\t\t\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT)", "-\t\t\t\t\t\t\tif (!(fieldDecl.initialization instanceof QualifiedAllocationExpression))", "+\t\t\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT) {", "+\t\t\t\t\t\t\tif (!(fieldDecl.initialization instanceof QualifiedAllocationExpression)) {", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tneedAbstractBit = true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\t\tmodifiers |= ClassFileConstants.AccAbstract;", "+\t\t\t\t\tif (needAbstractBit) {", "+\t\t\t\t\t\tmodifiers |= ClassFileConstants.AccAbstract;", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc03587a7ca732ddf047f6e426efd5ec", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "605463bb98397b59c78b7fc56ee33e7e22fd8367", "commitAfterChange": "7428bd3b18a16b1860e6a1a28fbc6cd63967fdc6", "methodNumberBeforeChange": 49, "methodNumberAfterChange": 54, "signatureBeforeChange": " \t \tprivate void printLineComment()", "signatureAfterChange": " \t \tprivate void printLineComment()", "diff": ["-\t\tint currentTokenStartPosition = this.scanner.getCurrentTokenStartPosition();", "-\t\tint currentTokenEndPosition = this.scanner.getCurrentTokenEndPosition() + 1;", "-\t\tif (CharOperation.indexOf(Scanner.TAG_PREFIX, this.scanner.source, true, currentTokenStartPosition, currentTokenEndPosition) != -1) {", "-\t\t\tthis.nlsTagCounter = 0;", "-\t\t}", "-\t\tthis.scanner.resetTo(currentTokenStartPosition, currentTokenEndPosition - 1);", "-\t\tint currentCharacter;", "-\t\tint start = currentTokenStartPosition;", "-\t\tint nextCharacterStart = currentTokenStartPosition;", "-\t\t", "-\t\tif (this.indentationLevel != 0) {", "-\t\t\tif (!this.formatter.preferences.never_indent_line_comments_on_first_column", "-\t\t\t\t\t|| !isOnFirstColumn(start)) {", "-\t\t\t\tprintIndentationIfNecessary();", "-\t\t\t}", "-\t\t}", "-\t\tif (this.pendingSpace) {", "-\t\t\tthis.addInsertEdit(currentTokenStartPosition, \" \"); //$NON-NLS-1$", "-\t\t}", "-\t\tthis.needSpace = false;", "-\t\tthis.pendingSpace = false;", "-\t\tint previousStart = currentTokenStartPosition;", "+    \tint currentTokenStartPosition = this.scanner.getCurrentTokenStartPosition();", "+    \tint currentTokenEndPosition = this.scanner.getCurrentTokenEndPosition() + 1;", "+    \tboolean isNlsTag = false;", "+    \tif (CharOperation.indexOf(Scanner.TAG_PREFIX, this.scanner.source, true, currentTokenStartPosition, currentTokenEndPosition) != -1) {", "+    \t\tthis.nlsTagCounter = 0;", "+    \t\tisNlsTag = true;", "+    \t}", "+    \tthis.scanner.resetTo(currentTokenStartPosition, currentTokenEndPosition - 1);", "+    \tint currentCharacter;", "+    \tint start = currentTokenStartPosition;", "+    \tint nextCharacterStart = currentTokenStartPosition;", "+    \t", "+    \tif (this.indentationLevel != 0) {", "+    \t\tif (!this.formatter.preferences.never_indent_line_comments_on_first_column", "+    \t\t\t\t|| !isOnFirstColumn(start)) {", "+    \t\t\tprintIndentationIfNecessary();", "+    \t\t}", "+    \t}", "+    \tif (this.pendingSpace) {", "+    \t\tthis.addInsertEdit(currentTokenStartPosition, \" \"); //$NON-NLS-1$", "+    \t}", "+    \tthis.needSpace = false;", "+    \tthis.pendingSpace = false;", "+    \tint previousStart = currentTokenStartPosition;", "-\t\tloop: while (nextCharacterStart <= currentTokenEndPosition && (currentCharacter = this.scanner.getNextChar()) != -1) {", "-\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+\t\tif (!isNlsTag && includesLineComments()) {", "+\t\t\tprintLineComment(currentTokenStartPosition, currentTokenEndPosition);", "+\t\t} else {", "+\t\t\t// do nothing!?", "+\t    \tloop: while (nextCharacterStart <= currentTokenEndPosition && (currentCharacter = this.scanner.getNextChar()) != -1) {", "+\t    \t\tnextCharacterStart = this.scanner.currentPosition;", "+\t    ", "+\t    \t\tswitch(currentCharacter) {", "+\t    \t\t\tcase '\\r' :", "+\t    \t\t\t\tstart = previousStart;", "+\t    \t\t\t\tbreak loop;", "+\t    \t\t\tcase '\\n' :", "+\t    \t\t\t\tstart = previousStart;", "+\t    \t\t\t\tbreak loop;", "+\t    \t\t}", "+\t    \t\tpreviousStart = nextCharacterStart;", "+\t    \t}", "+\t    \tif (start != currentTokenStartPosition) {", "+\t    \t\t// this means that the line comment doesn't end the file", "+\t    \t\taddReplaceEdit(start, currentTokenEndPosition - 1, lineSeparator);", "+\t    \t\tthis.line++; ", "+\t    \t\tthis.column = 1;", "+\t    \t\tthis.lastNumberOfNewLines = 1;", "+\t    \t}", "+\t\t}", "+    \tthis.needSpace = false;", "+    \tthis.pendingSpace = false;", "+    \t// realign to the proper value", "+    \tif (this.currentAlignment != null) {", "+    \t\tif (this.memberAlignment != null) {", "+    \t\t\t// select the last alignment", "+    \t\t\tif (this.currentAlignment.location.inputOffset > this.memberAlignment.location.inputOffset) {", "+    \t\t\t\tif (this.currentAlignment.couldBreak() && this.currentAlignment.wasSplit) {", "+    \t\t\t\t\tthis.currentAlignment.performFragmentEffect();", "+    \t\t\t\t}", "+    \t\t\t} else {", "+    \t\t\t\tthis.indentationLevel = Math.max(this.indentationLevel, this.memberAlignment.breakIndentationLevel);", "+    \t\t\t}", "+    \t\t} else if (this.currentAlignment.couldBreak() && this.currentAlignment.wasSplit) {", "+    \t\t\tthis.currentAlignment.performFragmentEffect();", "+    \t\t}", "+    \t}", "+    \tthis.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);", "+    }", "-\t\t\tswitch(currentCharacter) {", "-\t\t\t\tcase '\\r' :", "-\t\t\t\t\tstart = previousStart;", "-\t\t\t\t\tbreak loop;", "-\t\t\t\tcase '\\n' :", "-\t\t\t\t\tstart = previousStart;", "-\t\t\t\t\tbreak loop;", "-\t\t\t}", "-\t\t\tpreviousStart = nextCharacterStart;", "-\t\t}", "-\t\tif (start != currentTokenStartPosition) {", "-\t\t\t// this means that the line comment doesn't end the file", "-\t\t\taddReplaceEdit(start, currentTokenEndPosition - 1, lineSeparator);", "-\t\t\tthis.line++; ", "-\t\t\tthis.column = 1;", "-\t\t\tthis.lastNumberOfNewLines = 1;", "-\t\t}", "-\t\tthis.needSpace = false;", "-\t\tthis.pendingSpace = false;", "-\t\t// realign to the proper value", "-\t\tif (this.currentAlignment != null) {", "-\t\t\tif (this.memberAlignment != null) {", "-\t\t\t\t// select the last alignment", "-\t\t\t\tif (this.currentAlignment.location.inputOffset > this.memberAlignment.location.inputOffset) {", "-\t\t\t\t\tif (this.currentAlignment.couldBreak() && this.currentAlignment.wasSplit) {", "-\t\t\t\t\t\tthis.currentAlignment.performFragmentEffect();", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.indentationLevel = Math.max(this.indentationLevel, this.memberAlignment.breakIndentationLevel);", "-\t\t\t} else if (this.currentAlignment.couldBreak() && this.currentAlignment.wasSplit) {", "-\t\t\t\tthis.currentAlignment.performFragmentEffect();", "-\t\tthis.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);"]}], "num": 52814}