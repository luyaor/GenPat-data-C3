{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a4e79389b68fc5487b8310cc912bc14e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f27aad64a40879020c7e260c44874e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "25a0c02d6979e76d70832f78f8eb60bd371c0ad1", "commitAfterChange": "1b6413921860c74cfa469f859f6fc627d6400adf", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \tprivate ReferenceBinding[] computeKosherThrowables()", "signatureAfterChange": " \t \tprivate boolean argumentsTypeElided()", "diff": ["-\tprivate ReferenceBinding[] computeKosherThrowables() {", "-\t\treturn this.singleAbstractMethod == null || !this.singleAbstractMethod.isValidBinding() ? Binding.NO_EXCEPTIONS : this.singleAbstractMethod.thrownExceptions; // for now.", "+\tprivate boolean argumentsTypeElided() {", "+\t\treturn this.arguments.length > 0 && this.arguments[0].hasElidedType();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37f60b2cbba11e82aa28f904df363d3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "db260d93667acab111e64138469df12a566a7b90", "commitAfterChange": "41616c6495c935b90356748e848cc3a6ffe7665e", "methodNumberBeforeChange": 132, "methodNumberAfterChange": 132, "signatureBeforeChange": " protected void consumeNestedType()", "signatureAfterChange": " protected void consumeNestedType()", "diff": ["-\tthis.nestedType++;", "-\ttry {", "-\t\tthis.nestedMethod[this.nestedType] = 0;", "-\t} catch (IndexOutOfBoundsException e) {", "-\t\t//except in test's cases, it should never raise", "-\t\tint oldL = this.nestedMethod.length;", "-\t\tSystem.arraycopy(this.nestedMethod , 0, (this.nestedMethod = new int[oldL + 30]), 0, oldL);", "-\t\tthis.nestedMethod[this.nestedType] = 0;", "-\t\t// increase the size of the fieldsCounter as well. It has to be consistent with the size of the nestedMethod collection", "-\t\tSystem.arraycopy(this.variablesCounter, 0, (this.variablesCounter = new int[oldL + 30]), 0, oldL);", "+\tint length = this.nestedMethod.length;", "+\tif (++this.nestedType >= length) {", "+\t\tSystem.arraycopy(", "+\t\t\tthis.nestedMethod, 0,", "+\t\t\tthis.nestedMethod = new int[length + 30], 0,", "+\t\t\tlength);", "+\t\t// increase the size of the variablesCounter as well. It has to be consistent with the size of the nestedMethod collection", "+\t\tSystem.arraycopy(", "+\t\t\tthis.variablesCounter, 0,", "+\t\t\tthis.variablesCounter = new int[length + 30], 0,", "+\t\t\tlength);", "+\tthis.nestedMethod[this.nestedType] = 0;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "83b27fb8a789c4e2af4149a1dcb1740d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java", "commitBeforeChange": "1639bd6af95429f315066bc991f1a39635a7a06b", "commitAfterChange": "39fac05fa8b77fcaf96c0cb04f6cdf322c685cfd", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": "  public int getNextToken() throws InvalidInputException", "signatureAfterChange": "  public int getNextToken() throws InvalidInputException", "diff": ["-\tif (!this.scanningJava8Plus || this.activeParser == null) {", "-\t\treturn token;  // no audience, no magic.", "+\tif (this.activeParser == null) { // anybody interested in the grammatical structure of the program should have registered.", "+\t\treturn token;", "-\tif (token == TokenNameLPAREN && this.activeParser.atConflictScenario(token)) {", "-\t\tif (atLambdaParameterList()) {", "-\t\t\tthis.nextToken = token;", "-\t\t\ttoken = TokenNameBeginLambda;", "-\t\t}", "-\t} else if (token == TokenNameLESS && this.activeParser.atConflictScenario(token)) {", "-\t\tif (atReferenceExpression()) {", "-\t\t\tthis.nextToken = token;", "-\t\t\ttoken = TokenNameBeginTypeArguments;", "-\t\t}", "+\tif (token == TokenNameLPAREN && atLambdaParameterList()) {", "+\t\tthis.nextToken = token;", "+\t\ttoken = TokenNameBeginLambda;", "+\t} else if (token == TokenNameLESS && atReferenceExpression()) {", "+\t\tthis.nextToken = token;", "+\t\ttoken = TokenNameBeginTypeArguments;", "+", "+\tthis.lookBack[0] = this.lookBack[1];", "+\tthis.lookBack[1] = token;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4b7c41d7ff11485ea78f92303384f65", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests.java", "commitBeforeChange": "457fc77ec96140a15fc3e1c18bbf7bf53c7ea1c9", "commitAfterChange": "44074e366655e2cf89768617c1e64463f5949123", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 30, "signatureBeforeChange": " \tpublic void testBug79267() throws CoreException", "signatureAfterChange": " \tpublic void testBug79267() throws CoreException", "diff": ["-\t\tICompilationUnit workingCopy = null;", "-\t\ttry {", "-\t\t\tworkingCopy = getWorkingCopy(\"/JavaSearchBugs/src/b79267/Test.java\",", "-\t\t\t\t\"package b79267;\\n\" + ", "-\t\t\t\t\"public class Test {\\n\" + ", "-\t\t\t\t\"\tprivate static final X<String, String> BEFORE\t= new X<String, String>(4);\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tstatic {\\n\" + ", "-\t\t\t\t\"\t\tBEFORE.put(\\\"key1\\\",\\\"value1\\\");\\n\" + ", "-\t\t\t\t\"\t\tBEFORE.put(\\\"key2\\\",\\\"value2\\\");\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\t\\n\" + ", "-\t\t\t\t\"\tprivate static final X<Y, Object>\tobjectToPrimitiveMap\t= new X<Y, Object>(8);\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tstatic {\\n\" + ", "-\t\t\t\t\"\t\tobjectToPrimitiveMap.put(new Y<Object>(new Object()), new Object());\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"class X<T, U> {\\n\" + ", "-\t\t\t\t\"\tX(int x) {}\\n\" + ", "-\t\t\t\t\"\tvoid put(T t, U u) {}\\n\" + ", "-\t\t\t\t\"}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"class Y<T> {\\n\" + ", "-\t\t\t\t\"\tY(T t) {}\\n\" + ", "-\t\t\t\t\"}\\n\");", "-\t\t\t// search field references", "-\t\t\tIType type = workingCopy.getType(\"Test\");", "-\t\t\tIField field = type.getField(\"BEFORE\");", "-\t\t\tsearch(field, REFERENCES);", "-\t\t\tfield = type.getField(\"objectToPrimitiveMap\");", "-\t\t\tsearch(field, REFERENCES);", "-\t\t\tassertSearchResults(", "-\t\t\t\t\"src/b79267/Test.java b79267.Test.static {} [BEFORE] EXACT_MATCH\\n\" + ", "-\t\t\t\t\"src/b79267/Test.java b79267.Test.static {} [BEFORE] EXACT_MATCH\\n\" + ", "-\t\t\t\t\"src/b79267/Test.java b79267.Test.static {} [objectToPrimitiveMap] EXACT_MATCH\",", "-\t\t\t\tresultCollector);", "-\t\t}", "-\t\tfinally {", "-\t\t\tif (workingCopy != null)", "-\t\t\t\tworkingCopy.discardWorkingCopy();", "-\t\t}", "+\t\tworkingCopies = new ICompilationUnit[1];", "+\t\tworkingCopies[0] = getWorkingCopy(\"/JavaSearchBugs/src/b79267/Test.java\",", "+\t\t\t\"package b79267;\\n\" + ", "+\t\t\t\"public class Test {\\n\" + ", "+\t\t\t\"\tprivate static final X<String, String> BEFORE\t= new X<String, String>(4);\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tstatic {\\n\" + ", "+\t\t\t\"\t\tBEFORE.put(\\\"key1\\\",\\\"value1\\\");\\n\" + ", "+\t\t\t\"\t\tBEFORE.put(\\\"key2\\\",\\\"value2\\\");\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\t\\n\" + ", "+\t\t\t\"\tprivate static final X<Y, Object>\tobjectToPrimitiveMap\t= new X<Y, Object>(8);\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tstatic {\\n\" + ", "+\t\t\t\"\t\tobjectToPrimitiveMap.put(new Y<Object>(new Object()), new Object());\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"class X<T, U> {\\n\" + ", "+\t\t\t\"\tX(int x) {}\\n\" + ", "+\t\t\t\"\tvoid put(T t, U u) {}\\n\" + ", "+\t\t\t\"}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"class Y<T> {\\n\" + ", "+\t\t\t\"\tY(T t) {}\\n\" + ", "+\t\t\t\"}\\n\");", "+\t\t// search field references", "+\t\tIType type = workingCopies[0].getType(\"Test\");", "+\t\tIField field = type.getField(\"BEFORE\");", "+\t\tsearch(field, REFERENCES);", "+\t\tfield = type.getField(\"objectToPrimitiveMap\");", "+\t\tsearch(field, REFERENCES);", "+\t\tassertSearchResults(", "+\t\t\t\"src/b79267/Test.java b79267.Test.static {} [BEFORE] EXACT_MATCH\\n\" + ", "+\t\t\t\"src/b79267/Test.java b79267.Test.static {} [BEFORE] EXACT_MATCH\\n\" + ", "+\t\t\t\"src/b79267/Test.java b79267.Test.static {} [objectToPrimitiveMap] EXACT_MATCH\"", "+\t\t);"]}], "num": 18388}