{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f09741029218c57b6e728c015fd9b94a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f33c423bc46c9498721f7c54f3ffc93", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tpublic void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired)", "signatureAfterChange": "  public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired)", "diff": ["+", "+public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired) {", "+\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\tcase Binding.FIELD : // assigning to a field", "+\t\t\tFieldBinding fieldBinding;", "+\t\t\tif ((fieldBinding = (FieldBinding) this.codegenBinding).isStatic()) {", "+\t\t\t\tif ((this.syntheticAccessors == null) || (this.syntheticAccessors[SingleNameReference.READ] == null)) {", "+\t\t\t\t\tcodeStream.getstatic(fieldBinding);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.invokestatic(this.syntheticAccessors[SingleNameReference.READ]);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif ((this.bits & ASTNode.DepthMASK) != 0) {", "+\t\t\t\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT);", "+\t\t\t\t\tObject[] emulationPath = currentScope.getEmulationPath(targetType, true /*only exact match*/, false/*consider enclosing arg*/);", "+\t\t\t\t\tcodeStream.generateOuterAccess(emulationPath, this, targetType, currentScope);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.aload_0();", "+\t\t\t\t}", "+\t\t\t\tcodeStream.dup();", "+\t\t\t\tif ((this.syntheticAccessors == null) || (this.syntheticAccessors[SingleNameReference.READ] == null)) {", "+\t\t\t\t\tcodeStream.getfield(fieldBinding);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.invokestatic(this.syntheticAccessors[SingleNameReference.READ]);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (valueRequired) {", "+\t\t\t\tif (fieldBinding.isStatic()) {", "+\t\t\t\t\tif ((fieldBinding.type == TypeBinding.LONG) || (fieldBinding.type == TypeBinding.DOUBLE)) {", "+\t\t\t\t\t\tcodeStream.dup2();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcodeStream.dup();", "+\t\t\t\t\t}", "+\t\t\t\t} else { // Stack:  [owner][old field value]  ---> [old field value][owner][old field value]", "+\t\t\t\t\tif ((fieldBinding.type == TypeBinding.LONG) || (fieldBinding.type == TypeBinding.DOUBLE)) {", "+\t\t\t\t\t\tcodeStream.dup2_x1();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcodeStream.dup_x1();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (this.genericCast != null) ", "+\t\t\t\tcodeStream.checkcast(this.genericCast);", "+\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);\t\t", "+\t\t\tcodeStream.generateConstant(postIncrement.expression.constant, this.implicitConversion);", "+\t\t\tcodeStream.sendOperator(postIncrement.operator, this.implicitConversion & TypeIds.COMPILE_TYPE_MASK);", "+\t\t\tcodeStream.generateImplicitConversion(postIncrement.preAssignImplicitConversion);", "+\t\t\tfieldStore(codeStream, fieldBinding, this.syntheticAccessors == null ? null : this.syntheticAccessors[SingleNameReference.WRITE], false);", "+\t\t\t// no need for generic cast ", "+\t\t\treturn;", "+\t\tcase Binding.LOCAL : // assigning to a local variable", "+\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;", "+\t\t\t// using incr bytecode if possible", "+\t\t\tif (localBinding.type == TypeBinding.INT) {", "+\t\t\t\t\tcodeStream.load(localBinding);", "+\t\t\t\t}", "+\t\t\t\tif (postIncrement.operator == OperatorIds.PLUS) {", "+\t\t\t\t\tcodeStream.iinc(localBinding.resolvedPosition, 1);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.iinc(localBinding.resolvedPosition, -1);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tcodeStream.load(localBinding);", "+\t\t\t\tif (valueRequired){", "-\t", "-\tpublic void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired) {", "-\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\tcase Binding.FIELD : // assigning to a field", "-\t\t\t\tFieldBinding fieldBinding;", "-\t\t\t\tif ((fieldBinding = (FieldBinding) this.codegenBinding).isStatic()) {", "-\t\t\t\t\tif ((syntheticAccessors == null) || (syntheticAccessors[READ] == null)) {", "-\t\t\t\t\t\tcodeStream.getstatic(fieldBinding);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcodeStream.invokestatic(syntheticAccessors[READ]);", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tif ((bits & DepthMASK) != 0) {", "-\t\t\t\t\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);", "-\t\t\t\t\t\tObject[] emulationPath = currentScope.getEmulationPath(targetType, true /*only exact match*/, false/*consider enclosing arg*/);", "-\t\t\t\t\t\tcodeStream.generateOuterAccess(emulationPath, this, targetType, currentScope);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcodeStream.aload_0();", "-\t\t\t\t\t}", "-\t\t\t\t\tcodeStream.dup();", "-\t\t\t\t\tif ((syntheticAccessors == null) || (syntheticAccessors[READ] == null)) {", "-\t\t\t\t\t\tcodeStream.getfield(fieldBinding);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcodeStream.invokestatic(syntheticAccessors[READ]);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (valueRequired) {", "-\t\t\t\t\tif (fieldBinding.isStatic()) {", "-\t\t\t\t\t\tif ((fieldBinding.type == TypeBinding.LONG) || (fieldBinding.type == TypeBinding.DOUBLE)) {", "-\t\t\t\t\t\t\tcodeStream.dup2();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcodeStream.dup();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else { // Stack:  [owner][old field value]  ---> [old field value][owner][old field value]", "-\t\t\t\t\t\tif ((fieldBinding.type == TypeBinding.LONG) || (fieldBinding.type == TypeBinding.DOUBLE)) {", "-\t\t\t\t\t\t\tcodeStream.dup2_x1();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcodeStream.dup_x1();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (this.genericCast != null) ", "-\t\t\t\t\tcodeStream.checkcast(this.genericCast);", "-\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);\t\t", "+\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\tcodeStream.sendOperator(postIncrement.operator, this.implicitConversion & COMPILE_TYPE_MASK);", "+\t\t\t\tcodeStream.sendOperator(postIncrement.operator, this.implicitConversion & TypeIds.COMPILE_TYPE_MASK);", "-\t\t\t\tfieldStore(codeStream, fieldBinding, this.syntheticAccessors == null ? null : this.syntheticAccessors[WRITE], false);", "-\t\t\t\t// no need for generic cast ", "-\t\t\t\treturn;", "-\t\t\tcase Binding.LOCAL : // assigning to a local variable", "-\t\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;", "-\t\t\t\t// using incr bytecode if possible", "-\t\t\t\tif (localBinding.type == TypeBinding.INT) {", "-\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\tcodeStream.load(localBinding);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (postIncrement.operator == PLUS) {", "-\t\t\t\t\t\tcodeStream.iinc(localBinding.resolvedPosition, 1);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcodeStream.iinc(localBinding.resolvedPosition, -1);", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.load(localBinding);", "-\t\t\t\t\tif (valueRequired){", "-\t\t\t\t\t\tif ((localBinding.type == TypeBinding.LONG) || (localBinding.type == TypeBinding.DOUBLE)) {", "-\t\t\t\t\t\t\tcodeStream.dup2();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcodeStream.dup();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "-\t\t\t\t\tcodeStream.generateConstant(postIncrement.expression.constant, implicitConversion);", "-\t\t\t\t\tcodeStream.sendOperator(postIncrement.operator, this.implicitConversion & COMPILE_TYPE_MASK);", "-\t\t\t\t\tcodeStream.generateImplicitConversion(postIncrement.preAssignImplicitConversion);", "-\t", "-\t\t\t\t\tcodeStream.store(localBinding, false);", "-\t\t\t\t}", "-\t\t}", "-\t}\t", "+\t\t\t\tcodeStream.store(localBinding, false);", "+\t}", "+}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7553e7a00b902f20f6b06ebb42f74d2f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, MethodBinding writeAccessor, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "signatureAfterChange": " public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, MethodBinding writeAccessor, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "diff": ["-\t */", "-\tpublic void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, MethodBinding writeAccessor, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired) {", "-\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\tcase Binding.FIELD : // assigning to a field", "-\t\t\t\tFieldBinding fieldBinding;", "-\t\t\t\tif ((fieldBinding = (FieldBinding) this.codegenBinding).isStatic()) {", "-\t\t\t\t\tif ((syntheticAccessors == null) || (syntheticAccessors[READ] == null)) {", "-\t\t\t\t\t\tcodeStream.invokestatic(syntheticAccessors[READ]);", "-\t\t\t\t\tif ((bits & DepthMASK) != 0) {", "-\t\t\t\t\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);", "-\t\t\t\t\t\tcodeStream.aload_0();", "-\t\t\t\t\tcodeStream.dup();", "-\t\t\t\t\tif ((syntheticAccessors == null) || (syntheticAccessors[READ] == null)) {", "-\t\t\t\t\t\tcodeStream.invokestatic(syntheticAccessors[READ]);", "-\t\t\tcase Binding.LOCAL : // assigning to a local variable (cannot assign to outer local)", "-\t\t\t\tConstant assignConstant;", "-\t\t\t\tint increment;", "-\t\t\t\t// using incr bytecode if possible", "-\t\t\t\tswitch (localBinding.type.id) {", "-\t\t\t\t\tcase T_JavaLangString :", "-\t\t\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, this, expression);", "-\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\tcodeStream.dup();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcodeStream.store(localBinding, false);", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\tcase T_int :", "-\t\t\t\t\t\tif (((assignConstant = expression.constant) != Constant.NotAConstant) ", "-\t\t\t\t\t\t\t&& (assignConstant.typeID() != T_float) // only for integral types", "-\t\t\t\t\t\t\t&& (assignConstant.typeID() != T_double)", "-\t\t\t\t\t\t\t&& ((increment = assignConstant.intValue()) == (short) increment)) { // 16 bits value", "-\t\t\t\t\t\t\tswitch (operator) {", "-\t\t\t\t\t\t\t\tcase PLUS :", "-\t\t\t\t\t\t\t\t\tcodeStream.iinc(localBinding.resolvedPosition, increment);", "-\t\t\t\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\t\t\t\tcodeStream.load(localBinding);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t\t\t\tcase MINUS :", "-\t\t\t\t\t\t\t\t\tcodeStream.iinc(localBinding.resolvedPosition, -increment);", "-\t\t\t\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\t\t\t\tcodeStream.load(localBinding);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\tdefault :", "-\t\t\t\t\t\tcodeStream.load(localBinding);", "-\t\t// perform the actual compound operation", "-\t\tint operationTypeID;", "-\t\tswitch(operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) {", "-\t\t\tcase T_JavaLangString :", "-\t\t\tcase T_JavaLangObject :", "-\t\t\tcase T_undefined :", "-\t\t\t\t// we enter here if the single name reference is a field of type java.lang.String or if the type of the ", "-\t\t\t\t// operation is java.lang.Object", "-\t\t\t\t// For example: o = o + \"\"; // where the compiled type of o is java.lang.Object.", "-\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t\t\t// no need for generic cast on previous #getfield since using Object string buffer methods.\t\t\t", "-\t\t\t\t// promote the array reference to the suitable operation type", "-\t\t\t\tif (this.genericCast != null)", "-\t\t\t\t\tcodeStream.checkcast(this.genericCast);", "-\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\t\tif (expression == IntLiteral.One){ // prefix operation", "-\t\t\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);\t\t\t", "-\t\t\t\t} else {", "-\t\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t\t}\t\t", "-\t\t\t\t// perform the operation", "-\t\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t\t// cast the value back to the array reference type", "-\t\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "-\t\t// store the result back into the variable", "-\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\tcase Binding.FIELD : // assigning to a field", "-\t\t\t\tfieldStore(codeStream, (FieldBinding) this.codegenBinding, writeAccessor, valueRequired);", "-\t\t\t\t// no need for generic cast as value got dupped", "-\t\t\t\treturn;", "-\t\t\tcase Binding.LOCAL : // assigning to a local variable", "-\t\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;", "+ */", "+public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, MethodBinding writeAccessor, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired) {", "+\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\tcase Binding.FIELD : // assigning to a field", "+\t\t\tFieldBinding fieldBinding;", "+\t\t\tif ((fieldBinding = (FieldBinding) this.codegenBinding).isStatic()) {", "+\t\t\t\tif ((this.syntheticAccessors == null) || (this.syntheticAccessors[SingleNameReference.READ] == null)) {", "+\t\t\t\t\tcodeStream.getstatic(fieldBinding);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.invokestatic(this.syntheticAccessors[SingleNameReference.READ]);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif ((this.bits & ASTNode.DepthMASK) != 0) {", "+\t\t\t\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT);", "+\t\t\t\t\tObject[] emulationPath = currentScope.getEmulationPath(targetType, true /*only exact match*/, false/*consider enclosing arg*/);", "+\t\t\t\t\tcodeStream.generateOuterAccess(emulationPath, this, targetType, currentScope);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.aload_0();", "+\t\t\t\t}", "+\t\t\t\tcodeStream.dup();", "+\t\t\t\tif ((this.syntheticAccessors == null) || (this.syntheticAccessors[SingleNameReference.READ] == null)) {", "+\t\t\t\t\tcodeStream.getfield(fieldBinding);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.invokestatic(this.syntheticAccessors[SingleNameReference.READ]);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbreak;", "+\t\tcase Binding.LOCAL : // assigning to a local variable (cannot assign to outer local)", "+\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;", "+\t\t\tConstant assignConstant;", "+\t\t\tint increment;", "+\t\t\t// using incr bytecode if possible", "+\t\t\tswitch (localBinding.type.id) {", "+\t\t\t\tcase T_JavaLangString :", "+\t\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, this, expression);", "+\t\t\t\t\tif (valueRequired) {", "+\t\t\t\t\t\tcodeStream.dup();", "+\t\t\t\t\t}", "+\t\t\t\t\tcodeStream.store(localBinding, false);", "+\t\t\t\t\treturn;", "+\t\t\t\tcase T_int :", "+\t\t\t\t\tif (((assignConstant = expression.constant) != Constant.NotAConstant) ", "+\t\t\t\t\t\t&& (assignConstant.typeID() != TypeIds.T_float) // only for integral types", "+\t\t\t\t\t\t&& (assignConstant.typeID() != TypeIds.T_double)", "+\t\t\t\t\t\t&& ((increment = assignConstant.intValue()) == (short) increment)) { // 16 bits value", "+\t\t\t\t\t\tswitch (operator) {", "+\t\t\t\t\t\t\tcase PLUS :", "+\t\t\t\t\t\t\t\tcodeStream.iinc(localBinding.resolvedPosition, increment);", "+\t\t\t\t\t\t\t\tif (valueRequired) {", "+\t\t\t\t\t\t\t\t\tcodeStream.load(localBinding);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t\tcase MINUS :", "+\t\t\t\t\t\t\t\tcodeStream.iinc(localBinding.resolvedPosition, -increment);", "+\t\t\t\t\t\t\t\tif (valueRequired) {", "+\t\t\t\t\t\t\t\t\tcodeStream.load(localBinding);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\tdefault :", "+\t\t\t\t\tcodeStream.load(localBinding);", "+\t\t\t}", "+\t}", "+\t// perform the actual compound operation", "+\tint operationTypeID;", "+\tswitch(operationTypeID = (this.implicitConversion & TypeIds.IMPLICIT_CONVERSION_MASK) >> 4) {", "+\t\tcase T_JavaLangString :", "+\t\tcase T_JavaLangObject :", "+\t\tcase T_undefined :", "+\t\t\t// we enter here if the single name reference is a field of type java.lang.String or if the type of the ", "+\t\t\t// operation is java.lang.Object", "+\t\t\t// For example: o = o + \"\"; // where the compiled type of o is java.lang.Object.", "+\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "+\t\t\t// no need for generic cast on previous #getfield since using Object string buffer methods.\t\t\t", "+\t\t\tbreak;", "+\t\tdefault :", "+\t\t\t// promote the array reference to the suitable operation type", "+\t\t\tif (this.genericCast != null)", "+\t\t\t\tcodeStream.checkcast(this.genericCast);", "+\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "+\t\t\tif (expression == IntLiteral.One){ // prefix operation", "+\t\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);\t\t\t", "+\t\t\t} else {", "+\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "+\t\t\t}\t\t", "+\t\t\t// perform the operation", "+\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "+\t\t\t// cast the value back to the array reference type", "+\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "+\t}", "+\t// store the result back into the variable", "+\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\tcase Binding.FIELD : // assigning to a field", "+\t\t\tfieldStore(codeStream, (FieldBinding) this.codegenBinding, writeAccessor, valueRequired);", "+\t\t\t// no need for generic cast as value got dupped", "+\t\t\treturn;", "+\t\tcase Binding.LOCAL : // assigning to a local variable", "+\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;", "+\t\t\tif (valueRequired) {", "+\t\t\t\tif ((localBinding.type == TypeBinding.LONG) || (localBinding.type == TypeBinding.DOUBLE)) {", "+\t\t\t\t\tcodeStream.dup2();", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.dup();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tcodeStream.store(localBinding, false);", "+\t}", "+}", "-\t\t\t\tcodeStream.store(localBinding, false);", "-\t\t}", "-\t}"]}], "num": 65141}