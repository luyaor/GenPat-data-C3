{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ef16b2dbd9e0fd44f47ff8578dece8ac", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1559b8a89ba552c5040a194c169b9d12", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "13a2bff8811ff586bab60fddd157d395e6533570", "commitAfterChange": "4e8c06d42dcf2a91f77056993fc995ad49c4f7d9", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-/*\t\t\t", "-\t\t\tcst = this.valueIfTrue.optimizedBooleanConstant();", "-\t\t\tboolean isValueIfTrueOptimizedTrue = cst != NotAConstant && cst.booleanValue() == true;", "-\t\t\tboolean isValueIfTrueOptimizedFalse = cst != NotAConstant && cst.booleanValue() == false;", "+\t\t\tcst = this.optimizedIfTrueConstant;", "+\t\t\tboolean isValueIfTrueOptimizedTrue = cst != null && cst != NotAConstant && cst.booleanValue() == true;", "+\t\t\tboolean isValueIfTrueOptimizedFalse = cst != null && cst != NotAConstant && cst.booleanValue() == false;", "-\t\t\tcst = this.valueIfFalse.optimizedBooleanConstant();", "-\t\t\tboolean isValueIfFalseOptimizedTrue = cst != NotAConstant && cst.booleanValue() == true;", "-\t\t\tboolean isValueIfFalseOptimizedFalse = cst != NotAConstant && cst.booleanValue() == false;", "-*/", "+\t\t\tcst = this.optimizedIfFalseConstant;", "+\t\t\tboolean isValueIfFalseOptimizedTrue = cst != null && cst != NotAConstant && cst.booleanValue() == true;", "+\t\t\tboolean isValueIfFalseOptimizedFalse = cst != null && cst != NotAConstant && cst.booleanValue() == false;", "+", "+\t\t\tUnconditionalFlowInfo trueInfoWhenTrue = trueFlowInfo.initsWhenTrue().copy().unconditionalInits();", "+\t\t\tif (isValueIfTrueOptimizedFalse) trueInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE); ", "+", "+\t\t\tUnconditionalFlowInfo falseInfoWhenTrue = falseFlowInfo.initsWhenTrue().copy().unconditionalInits();", "+\t\t\tif (isValueIfFalseOptimizedFalse) falseInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE); ", "+\t\t\t", "+\t\t\tUnconditionalFlowInfo trueInfoWhenFalse = trueFlowInfo.initsWhenFalse().copy().unconditionalInits();", "+\t\t\tif (isValueIfTrueOptimizedTrue) trueInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE); ", "+", "+\t\t\tUnconditionalFlowInfo falseInfoWhenFalse = falseFlowInfo.initsWhenFalse().copy().unconditionalInits();", "+\t\t\tif (isValueIfFalseOptimizedTrue) falseInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE); ", "+", "-\t\t\t\t\ttrueFlowInfo.initsWhenTrue().copy().unconditionalInits().mergedWith( // must copy, since could be shared with trueInfo.initsWhenFalse()...", "-\t\t\t\t\t\tfalseFlowInfo.initsWhenTrue().copy().unconditionalInits()),", "-\t\t\t\t\ttrueFlowInfo.initsWhenFalse().unconditionalInits().mergedWith(", "-\t\t\t\t\t\tfalseFlowInfo.initsWhenFalse().unconditionalInits()));", "+\t\t\t\t\ttrueInfoWhenTrue.mergedWith(falseInfoWhenTrue),", "+\t\t\t\t\ttrueInfoWhenFalse.mergedWith(falseInfoWhenFalse));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bde408279d7a3157803ade0909165c82", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "76c9d02e981a720920f3a98e40e7da666cb7f2a1", "commitAfterChange": "bd9b00bcf9923b9da6ff38651a157fa6bc3f2dc8", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, \t\t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, \t\t\tFlowInfo flowInfo)", "diff": ["+\t\t\tthis.nullStatus = this.valueIfTrue.nullStatus(trueFlowInfo);", "+\t\t\tthis.nullStatus = this.valueIfFalse.nullStatus(falseFlowInfo);", "-\t\t\t// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok", "+\t\t\t// this block must meet two conflicting requirements (see https://bugs.eclipse.org/324178):", "+\t\t\t// (1) For null analysis of \"Object o2 = (o1 != null) ? o1 : new Object();\" we need to distinguish", "+\t\t\t//     the paths *originating* from the evaluation of the condition to true/false respectively.", "+\t\t\t//     This is used to determine the possible null status of the entire conditional expression.", "+\t\t\t// (2) For definite assignment analysis (JLS 16.1.5) of boolean conditional expressions of the form", "+\t\t\t//     \"if (c1 ? expr1 : expr2) use(v);\" we need to check whether any variable v will be definitely", "+\t\t\t//     assigned whenever the entire conditional expression evaluates to true (to reach the then branch).", "+\t\t\t//     I.e., we need to collect flowInfo *towards* the overall outcome true/false ", "+\t\t\t//     (regardless of the evaluation of the condition).", "+\t\t\t", "+\t\t\t// to support (1) use the infos of both branches originating from the condition for computing the nullStatus:", "+\t\t\tcomputeNullStatus(trueFlowInfo, falseFlowInfo);", "+\t\t\t", "+\t\t\t// to support (2) we split the true/false branches according to their inner structure. Consider this:", "+\t\t\t// if (b ? false : (true && (v = false))) return v; -- ok", "+\t\t\t// - expr1 (\"false\") has no path towards true (mark as unreachable)", "+\t\t\t// - expr2 (\"(true && (v = false))\") has a branch towards true on which v is assigned.", "+\t\t\t//   -> merging these two branches yields: v is assigned", "+\t\t\t// - the paths towards false are irrelevant since the enclosing if has no else.", "-\t\t\tUnconditionalFlowInfo trueInfoWhenTrue = trueFlowInfo.initsWhenTrue().unconditionalCopy();", "-\t\t\tUnconditionalFlowInfo falseInfoWhenTrue = falseFlowInfo.initsWhenTrue().unconditionalCopy();", "-\t\t\tUnconditionalFlowInfo trueInfoWhenFalse = trueFlowInfo.initsWhenFalse().unconditionalInits();", "-\t\t\tUnconditionalFlowInfo falseInfoWhenFalse = falseFlowInfo.initsWhenFalse().unconditionalInits();", "+\t\t\tUnconditionalFlowInfo trueFlowTowardsTrue = trueFlowInfo.initsWhenTrue().unconditionalCopy();", "+\t\t\tUnconditionalFlowInfo falseFlowTowardsTrue = falseFlowInfo.initsWhenTrue().unconditionalCopy();", "+\t\t\tUnconditionalFlowInfo trueFlowTowardsFalse = trueFlowInfo.initsWhenFalse().unconditionalInits();", "+\t\t\tUnconditionalFlowInfo falseFlowTowardsFalse = falseFlowInfo.initsWhenFalse().unconditionalInits();", "-\t\t\t\ttrueInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t\t\t\t", "+\t\t\t\ttrueFlowTowardsTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t\t\t\t", "-\t\t\t\tfalseInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "+\t\t\t\tfalseFlowTowardsTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "-\t\t\t\ttrueInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "+\t\t\t\ttrueFlowTowardsFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "-\t\t\t\tfalseInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "+\t\t\t\tfalseFlowTowardsFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "-\t\t\t\t\ttrueInfoWhenTrue.mergedWith(falseInfoWhenTrue),", "-\t\t\t\t\ttrueInfoWhenFalse.mergedWith(falseInfoWhenFalse));", "+\t\t\t\t\ttrueFlowTowardsTrue.mergedWith(falseFlowTowardsTrue),", "+\t\t\t\t\ttrueFlowTowardsFalse.mergedWith(falseFlowTowardsFalse));", "+\t}"]}], "num": 16994}