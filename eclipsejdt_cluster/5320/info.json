{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "841abd9333745098aa1526b6cb2b1fc2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1082e8dd7e6ce7857643a39075925dba", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "b8d589b72f11298620e188a74f142f9887cfc702", "commitAfterChange": "92a5335907fd0cb9878a81d6d82d370dc8deacce", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 10, "signatureBeforeChange": "  protected void addAffectedSourceFiles(char[] secondaryTypeName)", "signatureAfterChange": "  protected void compile(SourceFile[] units, SourceFile[] additionalUnits, boolean compilingFirstGroup)", "diff": ["-protected void addAffectedSourceFiles(char[] secondaryTypeName) {", "-\t// the secondary type search can have too many false hits if we addAffectedSource files using all the qualified type names", "-\t// of each secondary type... so look for the dependents 1 file at a time", "-\tint index = CharOperation.lastIndexOf('/', secondaryTypeName);", "-\tString packageName = index == -1 ? \"\" : new String(CharOperation.subarray(secondaryTypeName, 0, index)); //$NON-NLS-1$", "-\tStringSet packageNames = new StringSet(1);", "-\tpackageNames.add(packageName);", "-\tString typeName = new String(index == -1 ? secondaryTypeName : CharOperation.subarray(secondaryTypeName, index + 1, secondaryTypeName.length));", "-\tStringSet typeNames = new StringSet(1);", "-\ttypeNames.add(typeName);", "-", "-\taddAffectedSourceFiles(packageNames, typeNames);", "-}", "+protected void compile(SourceFile[] units, SourceFile[] additionalUnits, boolean compilingFirstGroup) {", "+\tif (compilingFirstGroup && additionalUnits != null) {", "+\t\t// add any source file from additionalUnits to units if it defines secondary types", "+\t\t// otherwise its possible during testing with MAX_AT_ONCE == 1 that a secondary type", "+\t\t// can cause an infinite loop as it alternates between not found and defined, see bug 146324", "+\t\tArrayList extras = null;", "+\t\tfor (int i = 0, l = additionalUnits.length; i < l; i++) {", "+\t\t\tSourceFile unit = additionalUnits[i];", "+\t\t\tif (unit != null && newState.getDefinedTypeNamesFor(unit.typeLocator()) != null) {", "+\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\tSystem.out.println(\"About to compile file with secondary types \"+ unit.typeLocator()); //$NON-NLS-1$", "+\t\t\t\tif (extras == null)", "+\t\t\t\t\textras = new ArrayList(3);", "+\t\t\t\textras.add(unit);", "+\t\t\t}", "+\t\t}", "+\t\tif (extras != null) {", "+\t\t\tint oldLength = units.length;", "+\t\t\tint toAdd = extras.size();", "+\t\t\tSystem.arraycopy(units, 0, units = new SourceFile[oldLength + toAdd], 0, oldLength);", "+\t\t\tfor (int i = 0; i < toAdd; i++)", "+\t\t\t\tunits[oldLength++] = (SourceFile) extras.get(i);", "+\t\t}", "+\t}", "+\tsuper.compile(units, additionalUnits, compilingFirstGroup);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cdc14e9e61a4edd1514791e960996a03", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java", "commitBeforeChange": "1146476ca138da09c36a16ea64250a150f60b014", "commitAfterChange": "e3d3c02cc33fd5166184422215f4903c5a405e0f", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  static State read(DataInputStream in) throws IOException", "signatureAfterChange": "  static State read(IProject project, DataInputStream in) throws IOException", "diff": ["-static State read(DataInputStream in) throws IOException {", "+static State read(IProject project, DataInputStream in) throws IOException {", "+\tif (!project.getName().equals(newState.javaProjectName)) {", "+\t\tif (JavaBuilder.DEBUG)", "+\t\t\tSystem.out.println(\"Project's name does not match... answered null\"); //$NON-NLS-1$", "+\t\treturn null;", "+\t}", "-\tnewState.outputLocationString = in.readUTF();", "-\tnewState.classpathLocations = new ClasspathLocation[length];", "-\tString encoding = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot().getProject(newState.javaProjectName)).getOption(JavaCore.CORE_ENCODING, true);", "-\tfor (int i = 0; i < length; ++i) {", "+\tnewState.sourceLocations = new ClasspathMultiDirectory[length];", "+\tfor (int i = 0; i < length; i++) {", "+\t\tIContainer sourceFolder = project, outputFolder = project;", "+\t\tString folderName;", "+\t\tif ((folderName = in.readUTF()).length() > 0) sourceFolder = project.getFolder(folderName);", "+\t\tif ((folderName = in.readUTF()).length() > 0) outputFolder = project.getFolder(folderName);", "+\t\tClasspathMultiDirectory md =", "+\t\t\t(ClasspathMultiDirectory) ClasspathLocation.forSourceFolder(sourceFolder, outputFolder, readNames(in));", "+\t\tif (in.readBoolean())", "+\t\t\tmd.hasIndependentOutputFolder = true;", "+\t\tnewState.sourceLocations[i] = md;", "+\t}", "+", "+\tlength = in.readInt();", "+\tnewState.binaryLocations = new ClasspathLocation[length];", "+\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tnewState.classpathLocations[i] = ClasspathLocation.forSourceFolder(in.readUTF(), in.readUTF(), encoding);", "+\t\t\t\tnewState.binaryLocations[i] = newState.sourceLocations[in.readInt()];", "-\t\t\t\tnewState.classpathLocations[i] = ClasspathLocation.forBinaryFolder(in.readUTF());", "+\t\t\t\tIContainer outputFolder = project;", "+\t\t\t\tString folderName = in.readUTF();", "+\t\t\t\tif (folderName.length() > 0) outputFolder = project.getFolder(folderName);", "+\t\t\t\tnewState.binaryLocations[i] = ClasspathLocation.forBinaryFolder(outputFolder, in.readBoolean());", "-\t\t\t\tnewState.classpathLocations[i] = ClasspathLocation.forLibrary(in.readUTF());", "+\t\t\t\tnewState.binaryLocations[i] = ClasspathLocation.forLibrary(project.getFile(in.readUTF()));", "+\t\t\t\tbreak;", "+\t\t\tcase 4 :", "+\t\t\t\tnewState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF());", "-\tString[] internedLocations = new String[length = in.readInt()];", "+\tString[] internedTypeLocators = new String[length = in.readInt()];", "-\t\tinternedLocations[i] = in.readUTF();", "+\t\tinternedTypeLocators[i] = in.readUTF();", "-\tnewState.typeLocations = new SimpleLookupTable(length = in.readInt());", "+\tnewState.typeLocators = new SimpleLookupTable(length = in.readInt());", "-\t\tnewState.typeLocations.put(in.readUTF(), internedLocations[in.readInt()]);", "+\t\tnewState.typeLocators.put(in.readUTF(), internedTypeLocators[in.readInt()]);", "-\t\tString location = internedLocations[in.readInt()];", "+\t\tString typeLocator = internedTypeLocators[in.readInt()];", "-\t\t\t\tfor (int j = 0, qLength = qualifiedNames.length; j < qLength; j++)", "+\t\t\t\tfor (int j = 0, m = qualifiedNames.length; j < m; j++)", "-\t\t\t\tfor (int j = 0, sLength = simpleNames.length; j < sLength; j++)", "+\t\t\t\tfor (int j = 0, m = simpleNames.length; j < m; j++)", "-\t\t\t\tfor (int j = 0, qLength = qNames.length; j < qLength; j++)", "+\t\t\t\tfor (int j = 0, m = qNames.length; j < m; j++)", "-\t\t\t\tfor (int j = 0, sLength = sNames.length; j < sLength; j++)", "+\t\t\t\tfor (int j = 0, m = sNames.length; j < m; j++)", "-\t\tnewState.references.put(location, collection);", "+\t\tnewState.references.put(typeLocator, collection);"]}], "num": 5320}