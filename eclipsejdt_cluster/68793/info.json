{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2ca901702b5da533cdd9f5ad545f834b", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5cb312a04e7fb1876e2f04f82f2485aa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java", "commitBeforeChange": "7e5cc03e445550d3cbc10c611218c79332074276", "commitAfterChange": "c57706d05dc3654769cca2053ff9cb20fb0a6664", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["-\t */\r", "-\tpublic void generateCode(ClassScope classScope, ClassFile classFile) {\r", "-\t\tint clinitOffset = 0;\r", "-\t\tif (ignoreFurtherInvestigation) {\r", "-\t\t\t// should never have to add any <clinit> problem method\r", "-\t\t\treturn;\r", "+ */\r", "+public void generateCode(ClassScope classScope, ClassFile classFile) {\r", "+\tint clinitOffset = 0;\r", "+\tif (ignoreFurtherInvestigation) {\r", "+\t\t// should never have to add any <clinit> problem method\r", "+\t\treturn;\r", "+\t}\r", "+\ttry {\r", "+\t\tclinitOffset = classFile.contentsOffset;\r", "+\t\tConstantPool constantPool = classFile.constantPool;\r", "+\t\tint constantPoolOffset = constantPool.currentOffset;\r", "+\t\tint constantPoolIndex = constantPool.currentIndex;\r", "+\t\tclassFile.generateMethodInfoHeaderForClinit();\r", "+\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "+\t\tclassFile.generateCodeAttributeHeader();\r", "+\t\tCodeStream codeStream = classFile.codeStream;\r", "+\t\tcodeStream.reset(this, classFile);\r", "+\t\tTypeDeclaration declaringType = classScope.referenceContext;\r", "+\r", "+\t\t// initialize local positions - including initializer scope.\r", "+\t\tscope.computeLocalVariablePositions(0, codeStream); // should not be necessary\r", "+\t\tMethodScope staticInitializerScope = declaringType.staticInitializerScope;\r", "+\t\tstaticInitializerScope.computeLocalVariablePositions(0, codeStream); // offset by the argument size\r", "+\r", "+\t\t// generate initializers\r", "+\t\tif (declaringType.fields != null) {\r", "+\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {\r", "+\t\t\t\tFieldDeclaration fieldDecl;\r", "+\t\t\t\tif ((fieldDecl = declaringType.fields[i]).isStatic()) {\r", "+\t\t\t\t\tfieldDecl.generateCode(staticInitializerScope, codeStream);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "-\t\ttry {\r", "-\t\t\tclinitOffset = classFile.contentsOffset;\r", "-\t\t\tConstantPool constantPool = classFile.constantPool;\r", "-\t\t\tint constantPoolOffset = constantPool.currentOffset;\r", "-\t\t\tint constantPoolIndex = constantPool.currentIndex;\r", "-\t\t\tclassFile.generateMethodInfoHeaderForClinit();\r", "-\t\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "-\t\t\tclassFile.generateCodeAttributeHeader();\r", "-\t\t\tCodeStream codeStream = classFile.codeStream;\r", "-\t\t\tthis.resolve(classScope);\r", "-\r", "-\t\t\tcodeStream.reset(this, classFile);\r", "-\t\t\tTypeDeclaration declaringType = classScope.referenceContext;\r", "-\r", "-\t\t\t// initialize local positions - including initializer scope.\r", "-\t\t\tscope.computeLocalVariablePositions(0, codeStream); // should not be necessary\r", "-\t\t\tMethodScope staticInitializerScope = declaringType.staticInitializerScope;\r", "-\t\t\tstaticInitializerScope.computeLocalVariablePositions(0, codeStream);\r", "-\t\t\t// offset by the argument size\r", "-\r", "-\t\t\t// 1.4 feature\r", "-\t\t\t// This has to be done before any other initialization\r", "-\t\t\tif (this.assertionSyntheticFieldBinding != null) {\r", "-\t\t\t\t// generate code related to the activation of assertion for this class\r", "-\t\t\t\tcodeStream.generateClassLiteralAccessForType(\r", "-\t\t\t\t\tclassScope.enclosingSourceType(),\r", "-\t\t\t\t\tclassLiteralSyntheticField);\r", "-\t\t\t\tcodeStream.invokeJavaLangClassDesiredAssertionStatus();\r", "-\t\t\t\tLabel falseLabel = new Label(codeStream);\r", "-\t\t\t\tcodeStream.ifne(falseLabel);\r", "-\t\t\t\tcodeStream.iconst_1();\r", "-\t\t\t\tLabel jumpLabel = new Label(codeStream);\r", "-\t\t\t\tcodeStream.goto_(jumpLabel);\r", "-\t\t\t\tfalseLabel.place();\r", "-\t\t\t\tcodeStream.iconst_0();\r", "-\t\t\t\tjumpLabel.place();\r", "-\t\t\t\tcodeStream.putstatic(this.assertionSyntheticFieldBinding);\r", "-\t\t\t}\r", "-\t\t\t// generate initializers\r", "-\t\t\tif (declaringType.fields != null) {\r", "-\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {\r", "-\t\t\t\t\tFieldDeclaration fieldDecl;\r", "-\t\t\t\t\tif ((fieldDecl = declaringType.fields[i]).isStatic()) {\r", "-\t\t\t\t\t\tfieldDecl.generateCode(staticInitializerScope, codeStream);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tif (codeStream.position == 0) {\r", "-\t\t\t\t// do not need to output a Clinit if no bytecodes\r", "-\t\t\t\t// so we reset the offset inside the byte array contents.\r", "-\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "-\t\t\t\t// like we don't addd a method we need to undo the increment on the method count\r", "-\t\t\t\tclassFile.methodCount--;\r", "-\t\t\t\t// reset the constant pool to its state before the clinit\r", "-\t\t\t\tconstantPool.resetForClinit(constantPoolIndex, constantPoolOffset);\r", "-\t\t\t} else {\r", "-\t\t\t\tif (needFreeReturn) {\r", "-\t\t\t\t\tint oldPosition = codeStream.position;\r", "-\t\t\t\t\tcodeStream.return_();\r", "-\t\t\t\t\tcodeStream.updateLocalVariablesAttribute(oldPosition);\r", "-\t\t\t\t}\r", "-\t\t\t\t// Record the end of the clinit: point to the declaration of the class\r", "-\t\t\t\tcodeStream.recordPositionsFrom(0, declaringType);\r", "-\t\t\t\tclassFile.completeCodeAttributeForClinit(codeAttributeOffset);\r", "-\t\t\t}\r", "-\t\t} catch (AbortMethod e) {\r", "-\t\t\t// should never occur\r", "-\t\t\t// the clinit referenceContext is the type declaration\r", "-\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "-\t\t\t// reset the contentsOffset to the value before generating the clinit code\r", "-\t\t\t// decrement the number of method info as well.\r", "-\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "-\t\t\t// cases.\r", "+\t\tif (codeStream.position == 0) {\r", "+\t\t\t// do not need to output a Clinit if no bytecodes\r", "+\t\t\t// so we reset the offset inside the byte array contents.\r", "+\t\t\t// like we don't addd a method we need to undo the increment on the method count\r", "+\t\t\t// reset the constant pool to its state before the clinit\r", "+\t\t\tconstantPool.resetForClinit(constantPoolIndex, constantPoolOffset);\r", "+\t\t} else {\r", "+\t\t\tif (needFreeReturn) {\r", "+\t\t\t\tint oldPosition = codeStream.position;\r", "+\t\t\t\tcodeStream.return_();\r", "+\t\t\t\tcodeStream.updateLocalVariablesAttribute(oldPosition);\r", "+\t\t\t}\r", "+\t\t\t// Record the end of the clinit: point to the declaration of the class\r", "+\t\t\tcodeStream.recordPositionsFrom(0, declaringType);\r", "+\t\t\tclassFile.completeCodeAttributeForClinit(codeAttributeOffset);\r", "+\t} catch (AbortMethod e) {\r", "+\t\t// should never occur\r", "+\t\t// the clinit referenceContext is the type declaration\r", "+\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "+\t\t// reset the contentsOffset to the value before generating the clinit code\r", "+\t\t// decrement the number of method info as well.\r", "+\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "+\t\t// cases.\r", "+\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\tclassFile.methodCount--;\t\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a7d152f167b6f137556bfd97487b1d72", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java", "commitBeforeChange": "46418d248f89a29f49a77d154cdbfa57c408b256", "commitAfterChange": "c85433e27f0fa74bfe8e06c38c1c02c51b5599d7", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["-\t */\r", "-\tpublic void generateCode(ClassScope classScope, ClassFile classFile) {\r", "-\t\tint clinitOffset = 0;\r", "-\t\tif (ignoreFurtherInvestigation) {\r", "-\t\t\t// should never have to add any <clinit> problem method\r", "-\t\t\treturn;\r", "+ */\r", "+public void generateCode(ClassScope classScope, ClassFile classFile) {\r", "+\tint clinitOffset = 0;\r", "+\tif (ignoreFurtherInvestigation) {\r", "+\t\t// should never have to add any <clinit> problem method\r", "+\t\treturn;\r", "+\t}\r", "+\ttry {\r", "+\t\tclinitOffset = classFile.contentsOffset;\r", "+\t\tConstantPool constantPool = classFile.constantPool;\r", "+\t\tint constantPoolOffset = constantPool.currentOffset;\r", "+\t\tint constantPoolIndex = constantPool.currentIndex;\r", "+\t\tclassFile.generateMethodInfoHeaderForClinit();\r", "+\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "+\t\tclassFile.generateCodeAttributeHeader();\r", "+\t\tCodeStream codeStream = classFile.codeStream;\r", "+\t\tcodeStream.reset(this, classFile);\r", "+\t\tTypeDeclaration declaringType = classScope.referenceContext;\r", "+\r", "+\t\t// initialize local positions - including initializer scope.\r", "+\t\tscope.computeLocalVariablePositions(0, codeStream); // should not be necessary\r", "+\t\tMethodScope staticInitializerScope = declaringType.staticInitializerScope;\r", "+\t\tstaticInitializerScope.computeLocalVariablePositions(0, codeStream); // offset by the argument size\r", "+\r", "+\t\t// generate initializers\r", "+\t\tif (declaringType.fields != null) {\r", "+\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {\r", "+\t\t\t\tFieldDeclaration fieldDecl;\r", "+\t\t\t\tif ((fieldDecl = declaringType.fields[i]).isStatic()) {\r", "+\t\t\t\t\tfieldDecl.generateCode(staticInitializerScope, codeStream);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "-\t\ttry {\r", "-\t\t\tclinitOffset = classFile.contentsOffset;\r", "-\t\t\tConstantPool constantPool = classFile.constantPool;\r", "-\t\t\tint constantPoolOffset = constantPool.currentOffset;\r", "-\t\t\tint constantPoolIndex = constantPool.currentIndex;\r", "-\t\t\tclassFile.generateMethodInfoHeaderForClinit();\r", "-\t\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "-\t\t\tclassFile.generateCodeAttributeHeader();\r", "-\t\t\tCodeStream codeStream = classFile.codeStream;\r", "-\t\t\tthis.resolve(classScope);\r", "-\r", "-\t\t\tcodeStream.reset(this, classFile);\r", "-\t\t\tTypeDeclaration declaringType = classScope.referenceContext;\r", "-\r", "-\t\t\t// initialize local positions - including initializer scope.\r", "-\t\t\tscope.computeLocalVariablePositions(0, codeStream); // should not be necessary\r", "-\t\t\tMethodScope staticInitializerScope = declaringType.staticInitializerScope;\r", "-\t\t\tstaticInitializerScope.computeLocalVariablePositions(0, codeStream);\r", "-\t\t\t// offset by the argument size\r", "-\r", "-\t\t\t// 1.4 feature\r", "-\t\t\t// This has to be done before any other initialization\r", "-\t\t\tif (this.assertionSyntheticFieldBinding != null) {\r", "-\t\t\t\t// generate code related to the activation of assertion for this class\r", "-\t\t\t\tcodeStream.generateClassLiteralAccessForType(\r", "-\t\t\t\t\tclassScope.enclosingSourceType(),\r", "-\t\t\t\t\tclassLiteralSyntheticField);\r", "-\t\t\t\tcodeStream.invokeJavaLangClassDesiredAssertionStatus();\r", "-\t\t\t\tLabel falseLabel = new Label(codeStream);\r", "-\t\t\t\tcodeStream.ifne(falseLabel);\r", "-\t\t\t\tcodeStream.iconst_1();\r", "-\t\t\t\tLabel jumpLabel = new Label(codeStream);\r", "-\t\t\t\tcodeStream.goto_(jumpLabel);\r", "-\t\t\t\tfalseLabel.place();\r", "-\t\t\t\tcodeStream.iconst_0();\r", "-\t\t\t\tjumpLabel.place();\r", "-\t\t\t\tcodeStream.putstatic(this.assertionSyntheticFieldBinding);\r", "-\t\t\t}\r", "-\t\t\t// generate initializers\r", "-\t\t\tif (declaringType.fields != null) {\r", "-\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {\r", "-\t\t\t\t\tFieldDeclaration fieldDecl;\r", "-\t\t\t\t\tif ((fieldDecl = declaringType.fields[i]).isStatic()) {\r", "-\t\t\t\t\t\tfieldDecl.generateCode(staticInitializerScope, codeStream);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tif (codeStream.position == 0) {\r", "-\t\t\t\t// do not need to output a Clinit if no bytecodes\r", "-\t\t\t\t// so we reset the offset inside the byte array contents.\r", "-\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "-\t\t\t\t// like we don't addd a method we need to undo the increment on the method count\r", "-\t\t\t\tclassFile.methodCount--;\r", "-\t\t\t\t// reset the constant pool to its state before the clinit\r", "-\t\t\t\tconstantPool.resetForClinit(constantPoolIndex, constantPoolOffset);\r", "-\t\t\t} else {\r", "-\t\t\t\tif (needFreeReturn) {\r", "-\t\t\t\t\tint oldPosition = codeStream.position;\r", "-\t\t\t\t\tcodeStream.return_();\r", "-\t\t\t\t\tcodeStream.updateLocalVariablesAttribute(oldPosition);\r", "-\t\t\t\t}\r", "-\t\t\t\t// Record the end of the clinit: point to the declaration of the class\r", "-\t\t\t\tcodeStream.recordPositionsFrom(0, declaringType);\r", "-\t\t\t\tclassFile.completeCodeAttributeForClinit(codeAttributeOffset);\r", "-\t\t\t}\r", "-\t\t} catch (AbortMethod e) {\r", "-\t\t\t// should never occur\r", "-\t\t\t// the clinit referenceContext is the type declaration\r", "-\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "-\t\t\t// reset the contentsOffset to the value before generating the clinit code\r", "-\t\t\t// decrement the number of method info as well.\r", "-\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "-\t\t\t// cases.\r", "+\t\tif (codeStream.position == 0) {\r", "+\t\t\t// do not need to output a Clinit if no bytecodes\r", "+\t\t\t// so we reset the offset inside the byte array contents.\r", "+\t\t\t// like we don't addd a method we need to undo the increment on the method count\r", "+\t\t\t// reset the constant pool to its state before the clinit\r", "+\t\t\tconstantPool.resetForClinit(constantPoolIndex, constantPoolOffset);\r", "+\t\t} else {\r", "+\t\t\tif (needFreeReturn) {\r", "+\t\t\t\tint oldPosition = codeStream.position;\r", "+\t\t\t\tcodeStream.return_();\r", "+\t\t\t\tcodeStream.updateLocalVariablesAttribute(oldPosition);\r", "+\t\t\t}\r", "+\t\t\t// Record the end of the clinit: point to the declaration of the class\r", "+\t\t\tcodeStream.recordPositionsFrom(0, declaringType);\r", "+\t\t\tclassFile.completeCodeAttributeForClinit(codeAttributeOffset);\r", "+\t} catch (AbortMethod e) {\r", "+\t\t// should never occur\r", "+\t\t// the clinit referenceContext is the type declaration\r", "+\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "+\t\t// reset the contentsOffset to the value before generating the clinit code\r", "+\t\t// decrement the number of method info as well.\r", "+\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "+\t\t// cases.\r", "+\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\tclassFile.methodCount--;\t\r", "+}\r"]}], "num": 68793}