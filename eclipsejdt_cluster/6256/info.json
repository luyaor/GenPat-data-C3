{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "77debf7fbe3de2f97ca0c516d6e5f3e0", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ab76315c0f0f2d08fa4480b47afe4fd9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "b9c215c1a0014055731b42921e6d8437fe5d1c30", "commitAfterChange": "cf30dcc5cf110d772b62d35f57e0c35d494f0e46", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic static void checkInvocationArguments(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding method, Expression[] arguments, TypeBinding[] argumentTypes, boolean argsContainCast, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static void checkInvocationArguments(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding method, Expression[] arguments, TypeBinding[] argumentTypes, boolean argsContainCast, InvocationSite invocationSite)", "diff": ["-\t\tboolean isRawMemberInvocation = !method.isStatic() && !receiverType.isUnboundWildcard() && method.declaringClass.isRawType() && method.hasSubstitutedParameters();", "+\t\tint paramLength = params.length;", "+\t\tboolean isRawMemberInvocation = !method.isStatic() && !receiverType.isUnboundWildcard() && method.declaringClass.isRawType() && (method.hasSubstitutedParameters() || method.hasSubstitutedReturnType());", "-\t\t\t\tif (((ParameterizedGenericMethodBinding)method).isRaw && method.hasSubstitutedParameters()) {", "+\t\t\t\tif (((ParameterizedGenericMethodBinding)method).isRaw && (method.hasSubstitutedParameters() || method.hasSubstitutedReturnType())) {", "-\t\tif (method.isVarargs()) {", "-\t\t\t// 4 possibilities exist for a call to the vararg method foo(int i, long ... value) : foo(1), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new long[] {1, 2})", "-\t\t\tint lastIndex = params.length - 1;", "-\t\t\tfor (int i = 0; i < lastIndex; i++) {", "-\t\t\t\tTypeBinding originalRawParam = rawOriginalGenericMethod == null ? null : rawOriginalGenericMethod.parameters[i];", "-\t\t\t    if (checkInvocationArgument(scope, arguments[i], params[i] , argumentTypes[i], originalRawParam)) {", "-\t\t\t\t    unsafeWildcardInvocation = true;", "-\t\t\t    }", "-\t\t\t}", "-\t\t   int argLength = arguments.length;", "-\t\t   if (lastIndex < argLength) { // vararg argument was provided", "-\t\t\t   \tTypeBinding parameterType = params[lastIndex];", "-\t\t\t\tTypeBinding originalRawParam = null;", "-", "-\t\t\t    if (params.length != argLength || parameterType.dimensions() != argumentTypes[lastIndex].dimensions()) {", "-\t\t\t    \tparameterType = ((ArrayBinding) parameterType).elementsType(); // single element was provided for vararg parameter", "-\t\t\t\t\toriginalRawParam = rawOriginalGenericMethod == null ? null : ((ArrayBinding)rawOriginalGenericMethod.parameters[lastIndex]).elementsType();", "-\t\t\t    }", "-\t\t\t\tfor (int i = lastIndex; i < argLength; i++) {", "-\t\t\t\t    if (checkInvocationArgument(scope, arguments[i], parameterType, argumentTypes[i], originalRawParam))", "+\t\tif (arguments != null) {", "+\t\t\tif (method.isVarargs()) {", "+\t\t\t\t// 4 possibilities exist for a call to the vararg method foo(int i, long ... value) : foo(1), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new long[] {1, 2})", "+\t\t\t\tint lastIndex = paramLength - 1;", "+\t\t\t\tfor (int i = 0; i < lastIndex; i++) {", "+\t\t\t\t\tTypeBinding originalRawParam = rawOriginalGenericMethod == null ? null : rawOriginalGenericMethod.parameters[i];", "+\t\t\t\t    if (checkInvocationArgument(scope, arguments[i], params[i] , argumentTypes[i], originalRawParam)) {", "+\t\t\t\t\t    unsafeWildcardInvocation = true;", "+\t\t\t\t    }", "+\t\t\t\t}", "+\t\t\t   int argLength = arguments.length;", "+\t\t\t   if (lastIndex < argLength) { // vararg argument was provided", "+\t\t\t\t   \tTypeBinding parameterType = params[lastIndex];", "+\t\t\t\t\tTypeBinding originalRawParam = null;", "+\t", "+\t\t\t\t    if (paramLength != argLength || parameterType.dimensions() != argumentTypes[lastIndex].dimensions()) {", "+\t\t\t\t    \tparameterType = ((ArrayBinding) parameterType).elementsType(); // single element was provided for vararg parameter", "+\t\t\t\t\t\toriginalRawParam = rawOriginalGenericMethod == null ? null : ((ArrayBinding)rawOriginalGenericMethod.parameters[lastIndex]).elementsType();", "+\t\t\t\t    }", "+\t\t\t\t\tfor (int i = lastIndex; i < argLength; i++) {", "+\t\t\t\t\t    if (checkInvocationArgument(scope, arguments[i], parameterType, argumentTypes[i], originalRawParam))", "+\t\t\t\t\t\t    unsafeWildcardInvocation = true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t", "+\t\t\t   if (paramLength == argumentTypes.length) { // 70056", "+\t\t\t\t\tint varargIndex = paramLength - 1;", "+\t\t\t\t\tArrayBinding varargType = (ArrayBinding) params[varargIndex];", "+\t\t\t\t\tTypeBinding lastArgType = argumentTypes[varargIndex];", "+\t\t\t\t\tif (lastArgType == NullBinding) {", "+\t\t\t\t\t\tif (!(varargType.leafComponentType().isBaseType() && varargType.dimensions() == 1))", "+\t\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "+\t\t\t\t\t} else if (varargType.dimensions <= lastArgType.dimensions()) {", "+\t\t\t\t\t\tint dimensions = lastArgType.dimensions();", "+\t\t\t\t\t\tif (lastArgType.leafComponentType().isBaseType())", "+\t\t\t\t\t\t\tdimensions--;", "+\t\t\t\t\t\tif (varargType.dimensions < dimensions)", "+\t\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "+\t\t\t\t\t\telse if (varargType.dimensions == dimensions && varargType.leafComponentType != lastArgType.leafComponentType())", "+\t\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tfor (int i = 0; i < paramLength; i++) {", "+\t\t\t\t\tTypeBinding originalRawParam = rawOriginalGenericMethod == null ? null : rawOriginalGenericMethod.parameters[i];", "+\t\t\t\t    if (checkInvocationArgument(scope, arguments[i], params[i], argumentTypes[i], originalRawParam))", "-", "-\t\t   if (method.parameters.length == argumentTypes.length) { // 70056", "-\t\t\t\tint varargIndex = method.parameters.length - 1;", "-\t\t\t\tArrayBinding varargType = (ArrayBinding) method.parameters[varargIndex];", "-\t\t\t\tTypeBinding lastArgType = argumentTypes[varargIndex];", "-\t\t\t\tif (lastArgType == NullBinding) {", "-\t\t\t\t\tif (!(varargType.leafComponentType().isBaseType() && varargType.dimensions() == 1))", "-\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "-\t\t\t\t} else if (varargType.dimensions <= lastArgType.dimensions()) {", "-\t\t\t\t\tint dimensions = lastArgType.dimensions();", "-\t\t\t\t\tif (lastArgType.leafComponentType().isBaseType())", "-\t\t\t\t\t\tdimensions--;", "-\t\t\t\t\tif (varargType.dimensions < dimensions)", "-\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "-\t\t\t\t\telse if (varargType.dimensions == dimensions && varargType.leafComponentType != lastArgType.leafComponentType())", "-\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "-\t\t\t\t}", "+\t\t\tif (argsContainCast) {", "+\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, receiver, receiverType, method, arguments, argumentTypes, invocationSite);", "-\t\t} else {", "-\t\t\tfor (int i = 0, argLength = arguments.length; i < argLength; i++) {", "-\t\t\t\tTypeBinding originalRawParam = rawOriginalGenericMethod == null ? null : rawOriginalGenericMethod.parameters[i];", "-\t\t\t    if (checkInvocationArgument(scope, arguments[i], params[i], argumentTypes[i], originalRawParam))", "-\t\t\t\t    unsafeWildcardInvocation = true;", "-\t\t\t}", "-\t\t}", "-\t\tif (argsContainCast) {", "-\t\t\tCastExpression.checkNeedForArgumentCasts(scope, receiver, receiverType, method, arguments, argumentTypes, invocationSite);", "-\t\t} else if (!method.isStatic() && !receiverType.isUnboundWildcard() && method.declaringClass.isRawType() && method.hasSubstitutedParameters()) {", "+\t\t} else if (!method.isStatic() && !receiverType.isUnboundWildcard() && method.declaringClass.isRawType() && (method.hasSubstitutedParameters() || method.hasSubstitutedReturnType())) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b4c7555e477e0b3a8b985d96e74ea312", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "6272ddbc393added5976d56f44f1521fcf876495", "commitAfterChange": "a738cdbf5d0b40e078d2ec76d22bcb613279cff6", "methodNumberBeforeChange": 347, "methodNumberAfterChange": 347, "signatureBeforeChange": " public int[] getJavaDocPositions()", "signatureAfterChange": " public int[] getJavaDocPositions()", "diff": ["-\tfor (int i = 0, max = this.scanner.commentPtr; i <= max; i++){", "-\t\t// javadoc only (non javadoc comment have negative end positions.)", "-\t\tif (this.scanner.commentStops[i] > 0){", "+\tint max = this.scanner.commentPtr;", "+\tfor (int i = 0; i <= max; i++){", "+\t\t// javadoc only (non javadoc comment have negative start and/or end positions.)", "+\t\tif (this.scanner.commentStarts[i] >= 0 && this.scanner.commentStops[i] > 0) {", "-\tfor (int i = 0, max = this.scanner.commentPtr; i <= max; i++){", "-\t\t// javadoc only (non javadoc comment have negative end positions.)", "-\t\tif (this.scanner.commentStops[i] > 0){", "-\t\t\tpositions[index++] = this.scanner.commentStarts[i];", "-\t\t\tpositions[index++] = this.scanner.commentStops[i]-1; //stop is one over", "+\tfor (int i = 0; i <= max; i++){", "+\t\t// javadoc only (non javadoc comment have negative start and/or end positions.)", "+\t\tint commentStart = this.scanner.commentStarts[i];", "+\t\tif (commentStart >= 0) {", "+\t\t\tint commentStop = this.scanner.commentStops[i];", "+\t\t\tif (commentStop > 0){", "+\t\t\t\tpositions[index++] = commentStart;", "+\t\t\t\tpositions[index++] = commentStop-1; //stop is one over", "+\t\t\t}"]}], "num": 6256}