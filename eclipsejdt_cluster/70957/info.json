{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c956b8562f05b6cb8aa125e989b5142f", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53bd0cc9f341df7fce69b9ed43745d77", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java", "commitBeforeChange": "04b1f777f72aaed365425972c86158987dc99f47", "commitAfterChange": "627e74400f5d869da7cccfccaf9f22c5e00c372a", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tprivate static char[] computeBaseTypeNames(char firstName, char[][] excludedNames)", "signatureAfterChange": "  \tprivate static char[][] computeBaseTypeNames(char[] typeName, boolean isConstantField, char[][] excludedNames)", "diff": ["+\tprivate static char[][] computeBaseTypeNames(char[] typeName, boolean isConstantField, char[][] excludedNames){", "+\t\tchar[] name = computeBaseTypeNames(typeName[0], excludedNames);", "+\t\tif(name != null) {", "+\t\t\treturn new char[][]{name};", "+\t\t} else {", "+\t\t\t// compute variable name like from non base type", "+\t\t\treturn  computeNonBaseTypeNames(typeName, isConstantField);", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f960040f3103ec8e31b028779c40724", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "74ceca813d8e9be557353622cfb1779e5fa562ad", "commitAfterChange": "2d7d544af40c78aee4e80de194acd385e8eab51a", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods)", "signatureAfterChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods)", "diff": ["-void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods) {", "+void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods) {", "-\t\tfor (int i = 0, l = otherInheritedMethods.length; i < l; i++) {", "-\t\t\tif (otherInheritedMethods[i] != null) {", "-\t\t\t\tMethodBinding otherOriginal = otherInheritedMethods[i].original();", "-\t\t\t\tif (otherOriginal != otherInheritedMethods[i] && detectInheritedMethodClash(originalInherited, otherOriginal))", "-\t\t\t\t\treturn;", "-\t\t\t}", "-\t\t}", "-", "-\t\t// there is an ordering issue with the comparison in checkMethods", "-\t\t// its possible that compareTo(X) is walked first & removes Comparable.compareTo(T) from the inherited list before we can compare it to compareTo(Object)", "-\t\t// its only a problem when the matching inherited method creates a bridge method which collides with an unwalked current method", "-\t\t//\t\tclass X implements Comparable<X> {", "-\t\t//\t\t\tpublic int compareTo(Object o) { return 0; }", "-\t\t//\t\t\tpublic int compareTo(X o) { return 1; }", "-\t\t//\t\t}", "-\t\tMethodBinding[] toCheck = (MethodBinding[]) this.currentMethods.get(currentMethod.selector);", "-\t\tfor (int i = 0, l = toCheck.length; i < l; i++)", "-\t\t\tif (currentMethod != toCheck[i] && detectNameClash(toCheck[i], inheritedMethod))", "+\t\tfor (int i = 0, l = allInheritedMethods.length; i < l; i++) {", "+\t\t\tMethodBinding otherInheritedMethod = allInheritedMethods[i];", "+\t\t\tMethodBinding otherOriginal = otherInheritedMethod.original();", "+\t\t\tif (otherOriginal == otherInheritedMethod || areMethodsEqual(inheritedMethod, otherInheritedMethod)) continue;", "+\t\t\tif (detectInheritedMethodClash(originalInherited, otherOriginal))", "+\t\t}"]}], "num": 70957}