{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5ee0de132f6abb5193692229f75cc74f", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b2867ec5e42feb0faaa1165160731b99", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "ddff8dde894947390c9a90bd347a6ae6239b2112", "commitAfterChange": "e1bb62a6f97249ff77a2f0164d289109644f1d09", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static int[] getLocations( \t\t\tfinal TypeReference reference, \t\t\tfinal Annotation[] primaryAnnotation, \t\t\tfinal Annotation annotation, \t\t\tfinal Annotation[][] annotationsOnDimensionsOnExpression, \t\t\tfinal int dimensions)", "signatureAfterChange": " \tpublic static int[] getLocations( \t\t\tfinal Expression reference, \t\t\tfinal Annotation annotation)", "diff": ["-\t\t\tfinal TypeReference reference,", "-\t\t\tfinal Annotation[] primaryAnnotation,", "-\t\t\tfinal Annotation annotation,", "-\t\t\tfinal Annotation[][] annotationsOnDimensionsOnExpression,", "-\t\t\tfinal int dimensions) {", "+\t\t\tfinal Expression reference,", "+\t\t\tfinal Annotation annotation) {", "-\t\t\tAnnotation currentAnnotation;", "-\t\t\tboolean search = true;", "+\t\t\tAnnotation searchedAnnotation;", "+\t\t\tboolean continueSearch = true;", "-\t\t\t\tthis.currentAnnotation = currentAnnotation;", "+\t\t\t\tthis.searchedAnnotation = currentAnnotation;", "+\t\t\t}", "+\t\t\t", "+\t\t\tprivate int[] computeNestingDepth(TypeReference typeReference) {", "+\t\t\t\tTypeBinding type = typeReference.resolvedType == null ? null : typeReference.resolvedType.leafComponentType(); ", "+\t\t\t\tint[] nestingDepths = new int[typeReference.getAnnotatableLevels()];", "+\t\t\t\tif (type != null && type.isNestedType()) {", "+\t\t\t\t\tint depth = 0;", "+\t\t\t\t\tTypeBinding currentType = type;", "+\t\t\t\t\twhile (currentType != null) {", "+\t\t\t\t\t\tdepth += (currentType.isStatic()) ? 0 : 1;", "+\t\t\t\t\t\tcurrentType = currentType.enclosingType();", "+\t\t\t\t\t}", "+\t\t\t\t\t// Work backwards computing whether a INNER_TYPE entry is required for each level", "+\t\t\t\t\tint counter = nestingDepths.length - 1;", "+\t\t\t\t\twhile (type != null && counter >= 0) {", "+\t\t\t\t\t\tnestingDepths[counter--] = depth;", "+\t\t\t\t\t\tdepth -= type.isStatic() ? 0 : 1;", "+\t\t\t\t\t\ttype = type.enclosingType();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn nestingDepths;", "+\t\t\t}", "+\t\t\t", "+", "+\t\t\tprivate void inspectAnnotations(Annotation [] annotations) {", "+\t\t\t\tfor (int i = 0, length = annotations == null ? 0 : annotations.length; this.continueSearch && i < length; i++) {", "+\t\t\t\t\tif (annotations[i] == this.searchedAnnotation)", "+\t\t\t\t\t\tthis.continueSearch = false;", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\tprivate void inspectArrayDimensions(Annotation [][] annotationsOnDimensions, int dimensions) {", "+\t\t\t\tfor (int i = 0; this.continueSearch && i < dimensions; i++) {", "+\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions == null ? null : annotationsOnDimensions[i];", "+\t\t\t\t\tinspectAnnotations(annotations);", "+\t\t\t\t\tif (!this.continueSearch) return;", "+\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\tprivate void inspectTypeArguments(TypeReference[] typeReferences) {", "+\t\t\t\tfor (int i = 0, length = typeReferences == null ? 0 : typeReferences.length; this.continueSearch && i < length; i++) {", "+\t\t\t\t\tint size = this.typePathEntries.size();", "+\t\t\t\t\tthis.typePathEntries.add(new int[]{3,i});", "+\t\t\t\t\ttypeReferences[i].traverse(this, (BlockScope) null);", "+\t\t\t\t\tif (!this.continueSearch) return;", "+\t\t\t\t\tthis.typePathEntries.setSize(size);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(TypeReference typeReference, BlockScope scope) {", "+\t\t\t\tif (this.continueSearch) {", "+\t\t\t\t\tinspectArrayDimensions(typeReference.getAnnotationsOnDimensions(), typeReference.dimensions());", "+\t\t\t\t\tif (this.continueSearch) {", "+\t\t\t\t\t\tint[] nestingDepths = computeNestingDepth(typeReference);", "+\t\t\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "+\t\t\t\t\t\tTypeReference [][] typeArguments = typeReference.getTypeArguments();", "+\t\t\t\t\t\tint levels = typeReference.getAnnotatableLevels();", "+\t\t\t\t\t\tint size = this.typePathEntries.size();", "+\t\t\t\t\t\tfor (int i = levels - 1; this.continueSearch && i >= 0; i--) {  // traverse outwards, see comment below about type annotations from SE7 locations.", "+\t\t\t\t\t\t\tthis.typePathEntries.setSize(size);", "+\t\t\t\t\t\t\tfor (int j = 0, depth = nestingDepths[i]; j < depth; j++)", "+\t\t\t\t\t\t\t\tthis.typePathEntries.add(TYPE_PATH_INNER_TYPE);", "+\t\t\t\t\t\t\tif (annotations != null)", "+\t\t\t\t\t\t\t\tinspectAnnotations(annotations[i]);", "+\t\t\t\t\t\t\tif (this.continueSearch && typeArguments != null) {", "+\t\t\t\t\t\t\t\tinspectTypeArguments(typeArguments[i]);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn false; // if annotation is not found in the type reference, it must be one from SE7 location, typePathEntries captures the proper path entries for them. ", "+\t\t\t}\t", "+\t\t\tpublic boolean visit(SingleTypeReference typeReference, BlockScope scope) {", "+\t\t\t\treturn visit((TypeReference) typeReference, scope);", "+\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(ArrayTypeReference typeReference, BlockScope scope) {", "+\t\t\t\treturn visit((TypeReference) typeReference, scope);", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\t\t\t\t\t", "-\t\t\t\tAnnotation[][] annotationsOnDimensions = typeReference.getAnnotationsOnDimensions();", "-\t\t\t\tif (annotationsOnDimensions != null) {", "-\t\t\t\t\tfor (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {", "-\t\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[i];", "-\t\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\t\t// found it, push any relevant type path entries", "-\t\t\t\t\t\t\t\t\tfor (int k = 0; k < i; k++) {", "-\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\t// Example cases handled here: @B(1) List<String>[]", "-\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "-\t\t\t\tif (annotations == null) {", "-\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "-\t\t\t\t}", "-\t\t\t\tint annotationsLevels = annotations.length;", "-\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "-\t\t\t\t\tAnnotation [] current = annotations[i];", "-\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "-\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "-\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "-\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t// Found it, insert any necessary type path elements", "-\t\t\t\t\t\t\tfor (int k = 0; k < typeReference.dimensions; k++) {", "-\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\t// If a type argument is annotated it is necessary jump past the array elements", "-\t\t\t\tif (typeReference.dimensions != 0) {", "-\t\t\t\t\tfor (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {", "-\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tTypeReference[] typeReferences = typeReference.typeArguments;", "-\t\t\t\tfor (int i = 0, max = typeReferences.length; i < max; i++) {", "-\t\t\t\t\tthis.typePathEntries.add(new int[]{3,i});", "-\t\t\t\t\ttypeReferences[i].traverse(this, scope);", "-\t\t\t\t\tif (!this.search) {", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tthis.typePathEntries.pop();", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (typeReference.dimensions != 0) {", "-\t\t\t\t\tfor (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {", "-\t\t\t\t\t\tthis.typePathEntries.pop();", "-\t\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t}", "-\t\t\t\treturn true;", "+\t\t\t\treturn visit((TypeReference) typeReference, scope);", "-\t\t\tpublic boolean visit(SingleTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-", "-\t\t\t\t// Example case handled by this block: X[][] x = new @A X @B [] @C[]{ { null }, { null } };", "-\t\t\t\tif (dimensions != 0 && annotationsOnDimensionsOnExpression != null) {", "-\t\t\t\t\tfor (int i = 0, max = annotationsOnDimensionsOnExpression.length; i < max; i++) {", "-\t\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensionsOnExpression[i];", "-\t\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\t\t// Found it, insert relevant type path elements", "-\t\t\t\t\t\t\t\t\tfor (int k = 0, maxk = i; k < maxk; k++) {", "-\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\tif (dimensions != 0) {", "-\t\t\t\t\tfor (int k = 0; k < dimensions; k++) {", "-\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "-\t\t\t\tif (annotations == null) {", "-\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "-\t\t\t\t}", "-\t\t\t\tint annotationsLevels = annotations.length;", "-\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "-\t\t\t\t\tAnnotation [] current = annotations[i];", "-\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "-\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "-\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "-\t\t\t\t\t\t\t// Found", "-\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\tint depth = getInnerDepth(typeReference.resolvedType);", "-\t\t\t\t\t\t\tif (depth != 0) {", "-\t\t\t\t\t\t\t\tfor (int k = 0; k<depth; k++) {", "-\t\t\t\t\t\t\t\t\tthis.typePathEntries.add(TYPE_PATH_INNER_TYPE);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (dimensions != 0) {", "-\t\t\t\t\tfor (int k = 0; k < dimensions; k++) {", "-\t\t\t\t\t\tthis.typePathEntries.pop();", "+\t\t\tpublic boolean visit(QualifiedTypeReference typeReference, BlockScope scope) {", "+\t\t\t\treturn visit((TypeReference) typeReference, scope);", "+\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(ArrayQualifiedTypeReference typeReference, BlockScope scope) {", "+\t\t\t\treturn visit((TypeReference) typeReference, scope);", "+\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {", "+\t\t\t\treturn visit((TypeReference) typeReference, scope);", "+\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(Wildcard typeReference, BlockScope scope) {", "+\t\t\t\tvisit((TypeReference) typeReference, scope);", "+\t\t\t\tif (this.continueSearch) {", "+\t\t\t\t\tTypeReference bound = typeReference.bound;", "+\t\t\t\t\tif (bound != null) {", "+\t\t\t\t\t\tint size = this.typePathEntries.size();", "+\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ANNOTATION_ON_WILDCARD_BOUND);", "+\t\t\t\t\t\tbound.traverse(this, scope);", "+\t\t\t\t\t\tif (this.continueSearch)", "+\t\t\t\t\t\t\tthis.typePathEntries.setSize(size);", "-\t\t\tpublic boolean visit(ArrayTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\t", "-\t\t\t\tAnnotation[][] annotationsOnDimensions = typeReference.getAnnotationsOnDimensions();", "-\t\t\t\tif (annotationsOnDimensions != null) {", "-\t\t\t\t\tfor (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {", "-\t\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[i];", "-\t\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\t\tfor (int k = 0; k < i; k++) {", "-\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\tpublic boolean visit(ArrayAllocationExpression allocationExpression, BlockScope scope) {", "+\t\t\t\tif (this.continueSearch) {", "+\t\t\t\t\tinspectArrayDimensions(allocationExpression.getAnnotationsOnDimensions(), allocationExpression.dimensions.length);", "+\t\t\t\t\tif (this.continueSearch) {", "+\t\t\t\t\t\tallocationExpression.type.traverse(this, scope);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.continueSearch) throw new IllegalStateException();", "+\t\t\t\t}", "+\t\t\t\treturn false;", "+\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "-\t\t\t\tif (annotations == null) {", "-\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "-\t\t\t\t}", "-\t\t\t\tint annotationsLevels = annotations.length;", "-\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "-\t\t\t\t\tAnnotation [] current = annotations[i];", "-\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "-\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "-\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "-\t\t\t\t\t\t\tfor (int k = 0, maxk=typeReference.dimensions; k < maxk; k++) {", "-\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\t", "-\t\t\tpublic boolean visit(ArrayQualifiedTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\tAnnotation[][] annotationsOnDimensions = typeReference.getAnnotationsOnDimensions();", "-\t\t\t\tif (annotationsOnDimensions != null) {", "-\t\t\t\t\tfor (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {", "-\t\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[i];", "-\t\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\t\t// Found it, insert relevant type path elements", "-\t\t\t\t\t\t\t\t\tfor (int k = 0, maxk = i; k < maxk; k++) {", "-\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\tif (primaryAnnotation != null) {", "-\t\t\t\t\tfor (int i = 0, max = primaryAnnotation.length; i < max; i++) {", "-\t\t\t\t\t\tif (primaryAnnotation[i] == this.currentAnnotation) {", "-\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\tfor (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {", "-\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "-\t\t\t\tif (annotations != null) {", "-\t\t\t\t\tint annotationsLevels = annotations.length;", "-\t\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "-\t\t\t\t\t\tAnnotation [] current = annotations[i];", "-\t\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "-\t\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "-\t\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\tfor (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {", "-\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t// depth allows for references like: one.two.three.@B Foo[]", "-\t\t\t\t\t\t\t\t// the inner_type elements to the type path depend on the types not the package qualifiers", "-\t\t\t\t\t\t\t\tint depth = getInnerDepth(typeReference.resolvedType);", "-\t\t\t\t\t\t\t\tif (depth != 0) {", "-\t\t\t\t\t\t\t\t\tfor (int k = 0; k < depth; k++) {", "-\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_INNER_TYPE);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\t", "-\t\t\tpublic boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\t", "-\t\t\t\t// Example case handled by this block: java.util.List<String>[]@A[]", "-\t\t\t\tAnnotation[][] annotationsOnDimensions = typeReference.getAnnotationsOnDimensions();", "-\t\t\t\tif (annotationsOnDimensions != null) {", "-\t\t\t\t\tfor (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {", "-\t\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[i];", "-\t\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\t\t// Found it, insert relevant type path elements", "-\t\t\t\t\t\t\t\t\tfor (int k = 0, maxk = i; k < maxk; k++) {", "-\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\tboolean[] needsInnerEntryInfo = computeInnerEntryInfo(typeReference);", "-", "-\t\t\t\t// Example cases handled by this block:", "-\t\t\t\t// java.util.@A List<String>[][], com.demo.@A Outer.@B Inner<String>, java.util.Map.@A Entry<String,String>", "-\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "-\t\t\t\tif (annotations == null) {", "-\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "-\t\t\t\t}", "-\t\t\t\tint annotationsLevels = annotations.length;", "-\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "-\t\t\t\t\tAnnotation [] current = annotations[i];", "-\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "-\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "-\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "-\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t// Found, insert any relevant type path elements", "-\t\t\t\t\t\t\tfor (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {", "-\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// Found, insert any relevant type path elements", "-\t\t\t\t\t\t\tif (needsInnerEntryInfo != null) {", "-\t\t\t\t\t\t\t\tfor (int k = 0; k <= i; k++) {", "-\t\t\t\t\t\t\t\t\tif (needsInnerEntryInfo[k]) {", "-\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_INNER_TYPE);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\t// Example cases handled by this block:", "-\t\t\t\t// java.util.List<@A String>", "-\t\t\t\tif (typeReference.dimensions != 0) {", "-\t\t\t\t\tfor (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {", "-\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tint toPop = 0;", "-\t\t\t\tfor (int i = 0, max = typeReference.typeArguments.length; i < max; i++) {", "-\t\t\t\t\tTypeReference[] typeArgumentsForComponent = typeReference.typeArguments[i];", "-\t\t\t\t\tif (needsInnerEntryInfo != null && needsInnerEntryInfo[i]) { ", "-\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_INNER_TYPE);", "-\t\t\t\t\t\ttoPop++;", "-\t\t\t\t\t}", "-\t\t\t\t\tif (typeArgumentsForComponent != null) {", "-\t\t\t\t\t\tfor (int j = 0, max2 = typeArgumentsForComponent.length; j < max2; j++) {", "-\t\t\t\t\t\t\tthis.typePathEntries.push(new int[]{3,j});", "-\t\t\t\t\t\t\ttypeArgumentsForComponent[j].traverse(this,scope);", "-\t\t\t\t\t\t\tif (!this.search) return false;", "-\t\t\t\t\t\t\tthis.typePathEntries.pop();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\ttoPop += typeReference.dimensions;", "-\t\t\t\tfor (int k = 0, maxk = toPop; k < maxk; k++) {", "-\t\t\t\t\tthis.typePathEntries.pop();", "-\t\t\t\t}", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\t", "-\t\t\tpublic boolean visit(Wildcard typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\t", "-\t\t\t\t// This block handles List<@Foo ? extends Serializable>", "-\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "-\t\t\t\tif (annotations == null) {", "-\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "-\t\t\t\t}", "-\t\t\t\tint annotationsLevels = annotations.length;", "-\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "-\t\t\t\t\tAnnotation [] current = annotations[i];", "-\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "-\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "-\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "-\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ANNOTATION_ON_WILDCARD_BOUND);", "-\t\t\t\tTypeReference bound = typeReference.bound;", "-\t\t\t\tif (bound != null)", "-\t\t\t\t\tbound.traverse(this, scope);", "-\t\t\t\tif (!this.search) {", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t\tthis.typePathEntries.pop();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\t", "-\t\t\tprivate boolean[] computeInnerEntryInfo(QualifiedTypeReference typeReference) {", "-\t\t\t\tReferenceBinding resolvedType = (ReferenceBinding) ", "-\t\t\t\t\t\t(typeReference.resolvedType instanceof ArrayBinding ? typeReference.resolvedType.leafComponentType() : typeReference.resolvedType);", "-\t\t\t\tboolean[] needsInnerEntryInfo = null;", "-\t\t\t\tif (resolvedType != null && resolvedType.isNestedType()) {", "-\t\t\t\t\t// Work backwards computing whether a INNER_TYPE entry is required for each level", "-\t\t\t\t\tneedsInnerEntryInfo = new boolean[typeReference.tokens.length];", "-\t\t\t\t\tint counter = needsInnerEntryInfo.length - 1;", "-\t\t\t\t\tReferenceBinding type = resolvedType;//resolvedType.enclosingType();", "-\t\t\t\t\twhile (type != null && counter > 0) {", "-\t\t\t\t\t\tneedsInnerEntryInfo[counter--] = !type.isStatic();", "-\t\t\t\t\t\ttype = type.enclosingType();", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\treturn needsInnerEntryInfo;", "-\t\t\t}", "-\t\t\t", "-\t\t\tprivate int getInnerDepth(TypeBinding resolvedType) {", "-\t\t\t\tReferenceBinding type = null;", "-\t\t\t\tif (resolvedType instanceof ReferenceBinding) {", "-\t\t\t\t\ttype = (ReferenceBinding)resolvedType;", "-\t\t\t\t} else if (resolvedType instanceof ArrayBinding) {", "-\t\t\t\t\tTypeBinding leafComponentType = ((ArrayBinding)resolvedType).leafComponentType;", "-\t\t\t\t\tif (leafComponentType instanceof ReferenceBinding) {", "-\t\t\t\t\t\ttype = (ReferenceBinding)leafComponentType;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tint depth = 0;", "-\t\t\t\twhile (type != null) {", "-\t\t\t\t\tdepth += (type.isStatic())?0:1;", "-\t\t\t\t\ttype = type.enclosingType();", "-\t\t\t\t}", "-\t\t\t\treturn depth;", "-\t\t\t}", "-\t\t\t", "-\t\t\tpublic boolean visit(QualifiedTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\tboolean[] needsInnerEntryInfo = computeInnerEntryInfo(typeReference);", "-\t\t\t\t", "-\t\t\t\tif (dimensions != 0) {", "-\t\t\t\t\tfor (int k = 0; k < dimensions; k++) {", "-\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\t// Example cases handled by this block:", "-\t\t\t\t// java.util.@A List, com.demo.@A Outer.@B Inner, java.util.Map.@A Entry", "-\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "-\t\t\t\tif (annotations == null) {", "-\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "-\t\t\t\t}", "-\t\t\t\tint annotationsLevels = annotations.length;", "-\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "-\t\t\t\t\tAnnotation [] current = annotations[i];", "-\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "-\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "-\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "-\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t// Found, insert any relevant type path elements", "-\t\t\t\t\t\t\tif (needsInnerEntryInfo != null) {", "-\t\t\t\t\t\t\t\tfor (int k = 0; k <= i; k++) {", "-\t\t\t\t\t\t\t\t\tif (needsInnerEntryInfo[k]) {", "-\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_INNER_TYPE);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (dimensions != 0) {", "-\t\t\t\t\tfor (int k = 0; k < dimensions; k++) {", "-\t\t\t\t\t\tthis.typePathEntries.pop();", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\t", "-\t\t\t\t\t.append(this.currentAnnotation)", "+\t\t\t\t\t.append(this.searchedAnnotation)"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc8766947c959e21101527b2dd07f532", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java", "commitBeforeChange": "ddff8dde894947390c9a90bd347a6ae6239b2112", "commitAfterChange": "e1bb62a6f97249ff77a2f0164d289109644f1d09", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic AnnotationContext( \t\t\tAnnotation annotation, \t\t\tTypeReference typeReference, \t\t\tint targetType, \t\t\tAnnotation[] primaryAnnotations, \t\t\tint visibility, \t\t\tAnnotation[][] annotationsOnDimensions, \t\t\tint dimensions)", "signatureAfterChange": "  \tpublic AnnotationContext( \t\t\tAnnotation annotation, \t\t\tExpression typeReference, \t\t\tint targetType, \t\t\tint visibility)", "diff": ["-\t\t\tTypeReference typeReference,", "+\t\t\tExpression typeReference,", "-\t\t\tAnnotation[] primaryAnnotations,", "-\t\t\tint visibility,", "-\t\t\tAnnotation[][] annotationsOnDimensions,", "-\t\t\tint dimensions) {", "+\t\t\tint visibility) {", "-\t\tthis.primaryAnnotations = primaryAnnotations;", "-\t\tthis.annotationsOnDimensions = annotationsOnDimensions;", "-\t\tthis.dimensions = dimensions;"]}], "num": 36970}