{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7a8f6926bb82a981a9c016a0bb25da13", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9eaa86fa36842ca391d70194b508447d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "4043b8a88c35a2c1612858cff67743727f25247b", "commitAfterChange": "6b8da2bd2bb1367c9817dbe3821476ed638f0906", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 33, "signatureBeforeChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[] patternTypeSignature, \t\t\t\t\t\t\t\t\tboolean mustResolve, \t\t\t\t\t\t\t\t\tboolean declaration, \t\t\t\t\t\t\t\t\tTypeBinding type)", "signatureAfterChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments, \t\t\t\t\t\t\t\t\tint depth, \t\t\t\t\t\t\t\t\tboolean mustResolve, \t\t\t\t\t\t\t\t\tTypeBinding type)", "diff": ["-\t\t\t\t\t\t\t\t\tchar[] patternTypeSignature,", "+\t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments,", "+\t\t\t\t\t\t\t\t\tint depth,", "-\t\t\t\t\t\t\t\t\tboolean declaration,", "-\tif (type == null || patternTypeSignature == null) return level;", "-", "-\t// pattern has no type parameter, return standard result", "-\tchar[][] patternTypeArguments = Signature.getTypeArguments(patternTypeSignature);", "-\tif (patternTypeArguments == null || patternTypeArguments.length == 0) {", "-\t\treturn level;", "-\t}", "+\tif (type == null || patternTypeArguments == null|| patternTypeArguments.length == 0) return level;", "-\t\tint length = patternTypeArguments.length;", "+\t\tint length = patternTypeArguments[depth].length;", "-\t} else if (!type.isParameterizedType() && !isRawType) {", "+\t} else if (isRawType) {", "+\t\treturn level; // raw type always match", "+\t} else if (!type.isParameterizedType()) {", "-\t\t// Binding is parameterized type", "-\t\tif (paramTypeBinding.arguments == null) {", "-\t\t\t// binding has no type parameters => ok for raw types", "-\t\t\tif (isRawType) return level;", "-\t\t\t// need to verify hierarchy for member types (raw type of generic member", "-\t\t\t// are stored as parameterized types...)", "-\t\t\tif (type.isMemberType() && qualificationPattern != null) {", "-\t\t\t\tint lastDot = CharOperation.lastIndexOf('.', qualificationPattern);", "-\t\t\t\tchar[] enclosingQualificationPattern = lastDot==-1 ? null : CharOperation.subarray(qualificationPattern, 0, lastDot);", "-\t\t\t\tchar[] enclosingSimpleNamePattern = lastDot==-1 ? qualificationPattern : CharOperation.subarray(qualificationPattern, lastDot+1, qualificationPattern.length);", "-\t\t\t\tif (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeSignature, mustResolve, declaration, paramTypeBinding.enclosingType()) == IMPOSSIBLE_MATCH) {", "+\t\t// When there's no type argument, no verification is necessary ", "+\t\tif (paramTypeBinding.arguments != null) {", "+", "+\t\t\t// type parameters length must match at least specified type names length", "+\t\t\tint length = patternTypeArguments[depth].length;", "+\t\t\tif (paramTypeBinding.arguments.length != length) return IMPOSSIBLE_MATCH;", "+\t", "+\t\t\t// verify each pattern type parameter", "+\t\t\tnextTypeArgument: for (int i= 0; i<length; i++) {", "+\t\t\t\tchar[] patternTypeArgument = patternTypeArguments[depth][i];", "+\t\t\t\tTypeBinding argTypeBinding = paramTypeBinding.arguments[i];", "+\t\t\t\t// get corresponding pattern wildcard", "+\t\t\t\tswitch (patternTypeArgument[0]) {", "+\t\t\t\t\tcase Signature.C_STAR : // unbound parameter always match", "+\t\t\t\t\tcase Signature.C_SUPER : // needs pattern type parameter binding", "+\t\t\t\t\t\t// skip to next type argument as it will be resolved later", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tcase Signature.C_EXTENDS :", "+\t\t\t\t\t\t// remove wildcard from patter type argument", "+\t\t\t\t\t\tpatternTypeArgument = CharOperation.subarray(patternTypeArgument, 1, patternTypeArgument.length);", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\t// no wildcard", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\t// get pattern type argument from its signature", "+\t\t\t\tpatternTypeArgument = Signature.toCharArray(patternTypeArgument);", "+\t", "+\t\t\t\t// Verify that names match...", "+\t\t\t\t// ...special case for wildcard", "+\t\t\t\tif (argTypeBinding.isWildcard()) {", "+\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argTypeBinding;", "+\t\t\t\t\tswitch (wildcardBinding.kind) {", "+\t\t\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\t\t\t// We cannot know in this case...", "+\t\t\t\t\t\t\tlevel = INACCURATE_MATCH;", "+\t\t\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\t\t\t\t// there's no bound name to match => valid", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t}", "+\t\t\t\t\t// Look for bound name in hierarchy", "+\t\t\t\t\tReferenceBinding boundBinding = (ReferenceBinding) wildcardBinding.bound;", "+\t\t\t\t\twhile (boundBinding != null) {", "+\t\t\t\t\t\tif (CharOperation.equals(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\t\tCharOperation.equals(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\t\t// found name in hierarchy => match", "+\t\t\t\t\t\t\tcontinue nextTypeArgument;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tboundBinding = boundBinding.superclass();", "+\t\t\t\t\t}", "-\t\t\t\treturn level;", "-\t\t\t}", "-\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t}", "-", "-\t\t// type parameters length must match at least specified type names length", "-\t\tint length = patternTypeArguments.length;", "-\t\tif (paramTypeBinding.arguments.length != length) return IMPOSSIBLE_MATCH;", "-", "-\t\t// for generic type declaration, verification is different than for parameterized type", "-\t\tif (declaration) {", "-\t\t\t// TODO (frederic) more verification to do here with type parameter bounds?", "-\t\t\treturn level;", "-\t\t}", "-", "-\t\t// verify each pattern type parameter", "-\t\tnextTypeArgument: for (int i= 0; i<length; i++) {", "-\t\t\tchar[] typeArgument = patternTypeArguments[i];", "-\t\t\tTypeBinding argTypeBinding = paramTypeBinding.arguments[i];", "-\t\t\t// get corresponding pattern wildcard", "-\t\t\tswitch (patternTypeArguments[i][0]) {", "-\t\t\t\tcase Signature.C_STAR : // unbound parameter always match", "-\t\t\t\tcase Signature.C_SUPER : // needs pattern type parameter binding", "-\t\t\t\t\t// skip to next type argument as it will be resolved later", "+\t\t\t\t", "+\t\t\t\t// See if names match", "+\t\t\t\tif (CharOperation.equals(patternTypeArgument, argTypeBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\tCharOperation.equals(patternTypeArgument, argTypeBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\tcase Signature.C_EXTENDS :", "-\t\t\t\t\t// remove wildcard from patter type argument", "-\t\t\t\t\ttypeArgument = CharOperation.subarray(typeArgument, 1, typeArgument.length);", "-\t\t\t\tdefault :", "-\t\t\t\t\t// no wildcard", "-\t\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\t// get pattern type argument from its signature", "-\t\t\ttypeArgument = Signature.toCharArray(typeArgument);", "-", "-\t\t\t// Verify that names match...", "-\t\t\t// First if type argument is a wildcard", "-\t\t\tif (argTypeBinding.isWildcard()) {", "-\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argTypeBinding;", "-\t\t\t\tswitch (wildcardBinding.kind) {", "-\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t// We cannot know in this case...", "-\t\t\t\t\t\tlevel = INACCURATE_MATCH;", "-\t\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t\t\t\t// there's no bound name to match => valid", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t// try to match name in hierarchy", "-\t\t\t\tReferenceBinding boundBinding = (ReferenceBinding) wildcardBinding.bound;", "-\t\t\t\twhile (boundBinding != null) {", "-\t\t\t\t\tif (CharOperation.equals(typeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\tCharOperation.equals(typeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\t\t// found name in hierarchy => match", "-\t\t\t\t\t\tcontinue nextTypeArgument;", "+", "+\t\t\t\t// Get reference binding", "+\t\t\t\tReferenceBinding refBinding = null;", "+\t\t\t\tif (argTypeBinding.isArrayType()) {", "+\t\t\t\t\tTypeBinding leafBinding = ((ArrayBinding) argTypeBinding).leafComponentType;", "+\t\t\t\t\tif (!leafBinding.isBaseType()) {", "+\t\t\t\t\t\trefBinding = (ReferenceBinding) leafBinding;", "-\t\t\t\t\tboundBinding = boundBinding.superclass();", "+\t\t\t\t} else if (!argTypeBinding.isBaseType()) {", "+\t\t\t\t\trefBinding = (ReferenceBinding) argTypeBinding;", "+\t\t\t\t}", "+\t\t\t\t// Scan hierarchy", "+\t\t\t\tif (refBinding != null) {", "+\t\t\t\t\trefBinding = refBinding.superclass();", "+\t\t\t\t\twhile (refBinding != null) {", "+\t\t\t\t\t\tif (CharOperation.equals(patternTypeArgument, refBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\t\tCharOperation.equals(patternTypeArgument, refBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\t\t// found name in hierarchy => match", "+\t\t\t\t\t\t\tcontinue nextTypeArgument;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\trefBinding = refBinding.superclass();", "+\t\t\t\t\t}", "-\t\t\t", "-\t\t\t// try to match names when there's no wildcard", "-\t\t\t// first get real binding", "-\t\t\tReferenceBinding refBinding = null;", "-\t\t\tif (argTypeBinding.isArrayType()) {", "-\t\t\t\tTypeBinding leafBinding = ((ArrayBinding) argTypeBinding).leafComponentType;", "-\t\t\t\tif (!leafBinding.isBaseType()) {", "-\t\t\t\t\trefBinding = (ReferenceBinding) leafBinding;", "-\t\t\t\t}", "-\t\t\t} else if (!argTypeBinding.isBaseType()) {", "-\t\t\t\trefBinding = (ReferenceBinding) argTypeBinding;", "-\t\t\t}", "-\t\t\t// Compare name", "-\t\t\tif (refBinding == null) {", "-\t\t\t\t// Based type", "-\t\t\t\tif (!CharOperation.equals(typeArgument, argTypeBinding.shortReadableName(), this.isCaseSensitive) &&", "-\t\t\t\t\t!CharOperation.equals(typeArgument, argTypeBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\twhile (refBinding != null) {", "-\t\t\t\t\tif (CharOperation.equals(typeArgument, refBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\tCharOperation.equals(typeArgument, refBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\t\t// found name in hierarchy => match", "-\t\t\t\t\t\tcontinue nextTypeArgument;", "-\t\t\t\t\t}", "-\t\t\t\t\trefBinding = refBinding.superclass();", "-\t\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Recurse on enclosing type", "+\t\tTypeBinding enclosingType = paramTypeBinding.enclosingType();", "+\t\tif (enclosingType != null && enclosingType.isParameterizedType() && depth < patternTypeArguments.length && qualificationPattern != null) {", "+\t\t\tint lastDot = CharOperation.lastIndexOf('.', qualificationPattern);", "+\t\t\tchar[] enclosingQualificationPattern = lastDot==-1 ? null : CharOperation.subarray(qualificationPattern, 0, lastDot);", "+\t\t\tchar[] enclosingSimpleNamePattern = lastDot==-1 ? qualificationPattern : CharOperation.subarray(qualificationPattern, lastDot+1, qualificationPattern.length);", "+\t\t\tif (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeArguments, depth+1, mustResolve, enclosingType) == IMPOSSIBLE_MATCH) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a881aa513d86ed728d30054b59b3aab0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java", "commitBeforeChange": "06f23e3e171e1532838272ad3cfed1dbf476c295", "commitAfterChange": "fd83708e4f6c48e5f68b55d90ce222d8723ca6ce", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r String[] directoryList(String qualifiedPackageName)", "signatureAfterChange": "\r private String[] directoryList(char[][] compoundName, char[] packageName)", "diff": ["-String[] directoryList(String qualifiedPackageName) {\r", "-\tString[] dirList = (String[]) directoryCache.get(qualifiedPackageName);\r", "-\tif (dirList == missingPackageHolder) return null; // package exists in another classpath directory or jar\r", "-\tif (dirList != null) return dirList;\r", "-\r", "-\tFile dir = new File(path + qualifiedPackageName);\r", "-\tnotFound : if (dir != null && dir.isDirectory()) {\r", "-\t\t// must protect against a case insensitive File call\r", "-\t\t// walk the qualifiedPackageName backwards looking for an uppercase character before the '/'\r", "-\t\tint index = qualifiedPackageName.length();\r", "-\t\tint last = qualifiedPackageName.lastIndexOf('/');\r", "-\t\twhile (--index > last && !Character.isUpperCase(qualifiedPackageName.charAt(index))) {}\r", "-\t\tif (index > last) {\r", "-\t\t\tif (last == -1) {\r", "-\t\t\t\tif (!doesFileExist(qualifiedPackageName, \"\"))\r", "-\t\t\t\t\tbreak notFound;\r", "-\t\t\t} else {\r", "-\t\t\t\tString packageName = qualifiedPackageName.substring(last + 1);\r", "-\t\t\t\tString parentPackage = qualifiedPackageName.substring(0, last);\r", "-\t\t\t\tif (!doesFileExist(packageName, parentPackage))\r", "-\t\t\t\t\tbreak notFound;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\tif ((dirList = dir.list()) == null)\r", "-\t\t\tdirList = new String[0];\r", "-\t\tdirectoryCache.put(qualifiedPackageName, dirList);\r", "+private String[] directoryList(char[][] compoundName, char[] packageName) {\r", "+\tString partialPath = FileSystem.assembleName(packageName, compoundName, File.separatorChar);\r", "+\tString[] dirList = (String[])directoryCache.get(partialPath);\r", "+\tif (dirList != null)\r", "+\tif (missingPackages.containsKey(partialPath))\r", "+\t\treturn null;\r", "+\r", "+\tFile dir = new File(path + partialPath);\r", "+\tif (dir != null && dir.isDirectory()) {\r", "+\t\tboolean matchesName = packageName == null;\r", "+\t\tif (!matchesName) {\r", "+\t\t\tint index = packageName.length;\r", "+\t\t\twhile (--index >= 0 && !Character.isUpperCase(packageName[index])) {}\r", "+\t\t\tmatchesName = index < 0 || exists(new String(packageName), compoundName); // verify that the case sensitive packageName really does exist\r", "+\t\t}\r", "+\t\tif (matchesName) {\r", "+\t\t\tif ((dirList = dir.list()) == null)\r", "+\t\t\t\tdirList = new String[0];\r", "+\t\t\tdirectoryCache.put(partialPath, dirList);\r", "+\t\t\treturn dirList;\r", "+\t\t}\r", "-\tdirectoryCache.put(qualifiedPackageName, missingPackageHolder);\r", "+\tmissingPackages.put(partialPath, partialPath); // value is not used\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fcd437a47abe81afa001f73c413b8661", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "81c62d5935a591fe4cf87abbebf09e04755572ce", "commitAfterChange": "18c9ee28439dc99049f5f8ecbf6109b62307dc52", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tprivate void verifyTypeReference(Expression reference, Scope scope, boolean source15, ReferenceBinding resolvedType)", "signatureAfterChange": "  \tprivate void verifyTypeReference(Expression reference, Expression typeReference, Scope scope, boolean source15, ReferenceBinding resolvedType, int modifiers)", "diff": ["-\tprivate void verifyTypeReference(Expression reference, Scope scope, boolean source15, ReferenceBinding resolvedType) {", "+\tprivate void verifyTypeReference(Expression reference, Expression typeReference, Scope scope, boolean source15, ReferenceBinding resolvedType, int modifiers) {", "+", "+\t\t\t// reference must have enough visibility to be used", "+\t\t\tif (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, modifiers)) {", "+//\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\tscope.problemReporter().javadocHiddenReference(typeReference.sourceStart, reference.sourceEnd, scope, modifiers);", "+\t\t\t\treturn;", "+\t\t\t}", "+", "+\t\t\t// type reference must have enough visibility to be used", "+\t\t\tif (reference != typeReference) {", "+\t\t\t\tif (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, resolvedType.modifiers)) {", "+//\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\tscope.problemReporter().javadocHiddenReference(typeReference.sourceStart, typeReference.sourceEnd, scope, resolvedType.modifiers);", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "-\t\t\t\t\tif (reference instanceof JavadocSingleTypeReference) {", "+\t\t\t\t\tif (typeReference instanceof JavadocSingleTypeReference) {", "-\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t} else if (reference instanceof JavadocQualifiedTypeReference) {", "-\t\t\t\t\t\tJavadocQualifiedTypeReference qualifiedTypeReference = (JavadocQualifiedTypeReference) reference;", "+\t\t\t\t\t}", "+\t\t\t\t\t/*", "+\t\t\t\t\tif (typeReference instanceof JavadocQualifiedTypeReference) {", "+\t\t\t\t\t\tJavadocQualifiedTypeReference qualifiedTypeReference = (JavadocQualifiedTypeReference) typeReference;", "-\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t*/", "-\t\t\t}", "-", "-\t\t\t// reference must have enough visibility to be used", "-\t\t\tif (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, resolvedType)) {", "-\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "-\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);"]}], "num": 15537}