{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b92bd41fda78b55f1c91ebc24c6aee8a", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "735bda8d285a2a920627fb15d43c93f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingKeyScanner.java", "commitBeforeChange": "09b2a60a289857be8b68f0bdade8ca62b9081359", "commitAfterChange": "159e8ad6d8421b49efbcfb424fe9327481d95b23", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": " \t \tint nextToken()", "signatureAfterChange": " \t \tint nextToken()", "diff": ["+\t", "-\t\tthis.start = this.token == ARRAY ? this.index : ++this.index;", "-\t\tint previousTokenEnd = this.index-1;", "+\t\tint previousTokenEnd = this.index;", "+\t\tthis.start = this.index;", "-\t\t\t\t\tif (this.start == previousTokenEnd+1) {", "+\t\t\t\t\tif (this.index == previousTokenEnd) {", "-\t\t\t\t\tif (this.start == previousTokenEnd+1) {", "-\t\t\t\t\t\tthis.start = ++this.index;", "+\t\t\t\t\tif (this.index == previousTokenEnd) {", "+\t\t\t\t\t\tthis.start = this.index+1;", "-\t\t\t\t\tthis.token = TYPE;", "-\t\t\t\t\treturn this.token;", "+\t\t\t\t\tif (this.index == previousTokenEnd) {", "+\t\t\t\t\t\tthis.start = this.index+1;", "+\t\t\t\t\t\tpreviousTokenEnd = this.start;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.token = TYPE;", "+\t\t\t\t\t\treturn this.token;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase '%':", "+\t\t\t\t\tpreviousTokenEnd = this.start;", "-\t\t\t\t\tif (this.start > 0) {", "+\t\t\t\t\tif (this.index == previousTokenEnd) {", "+\t\t\t\t\t\tthis.start = this.index+1;", "+\t\t\t\t\t\tpreviousTokenEnd = this.start;", "+\t\t\t\t\t} else if (this.start > 0) {", "+\t\t\t\t\t\t\t\t\t// case of member type where enclosing type is parameterized", "-\t\t\t\t\t\t\tcase '%':", "-\t\t\t\t\t\t\t\tpreviousTokenEnd = this.index;", "-\t\t\t\t\t\t\t\tthis.start = this.index+1;", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\tthis.token = LOCAL_VAR;", "-\t\t\t\t\treturn this.token;", "+\t\t\t\t\tif (this.index == previousTokenEnd) {", "+\t\t\t\t\t\tthis.start = this.index+1;", "+\t\t\t\t\t\tpreviousTokenEnd = this.start;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.token = LOCAL_VAR;", "+\t\t\t\t\t\treturn this.token;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase '*':", "+\t\t\t\tcase '+':", "+\t\t\t\tcase '-':", "+\t\t\t\t\tthis.index++;", "+\t\t\t\t\tthis.token = TYPE;", "+\t\t\t\t\treturn this.token;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85da70879dbfd498590e46b36b0f7e76", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/BindingKeyParser.java", "commitBeforeChange": "ffd901457a8019a34d01704f9139e1e52b8a6906", "commitAfterChange": "0926f8224af442af001e56062ed4e4b1654d4df9", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t\t \t\tint nextToken()", "signatureAfterChange": " \t\t \t\tint nextToken()", "diff": ["+\t\t\tint dollarIndex = -1;", "+\t\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\t\tif (dollarIndex != -1) this.index = dollarIndex;", "+\t\t\t\t\t\tif (this.index == previousTokenEnd) {", "+\t\t\t\t\t\t\tthis.start = this.index+1;", "+\t\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (dollarIndex == -1) {", "+\t\t\t\t\t\t\t\tdollarIndex = this.index;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.index = dollarIndex;", "+\t\t\t\t\t\t\tthis.token = TYPE;", "+\t\t\t\t\t\t\treturn this.token;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\tdollarIndex = -1;", "-\t\t\t\t\t\t\t\t\tif (this.source[this.start-2] == '>')", "+\t\t\t\t\t\t\t\t\tif (this.source[this.start-2] == '>') {", "+\t\t\t\t\t\t\t\t\t\tif (dollarIndex != -1) this.index = dollarIndex;", "-\t\t\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\t\t\t\t\tif (dollarIndex != -1) this.index = dollarIndex;", "+\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\t\tdollarIndex = -1;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c200736346bc38b9dee43e032362a104", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "c62ecfd031507c11ea236866605fedd6f3a952c5", "commitAfterChange": "ded73445e8c5cf2db0a4abcc53e1680f02ae6cf7", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tprivate boolean dumpBinaryExpression( \t\tBinaryExpression binaryExpression, \t\tint operator, \t\tBlockScope scope)", "signatureAfterChange": "  \tprivate boolean dumpBinaryExpression( \t\tBinaryExpression binaryExpression, \t\tint operator, \t\tBlockScope scope)", "diff": ["-\t\tif ((builder.realFragmentsSize() > 1 || fragmentsSize > 4) && numberOfParens == 0) {", "-\t\t\tthis.scribe.printComment();", "-\t\t\tAlignment binaryExpressionAlignment = this.scribe.createAlignment(", "-\t\t\t\t\tAlignment.BINARY_EXPRESSION,", "-\t\t\t\t\tthis.preferences.alignment_for_binary_expression,", "-\t\t\t\t\tAlignment.R_OUTERMOST,", "-\t\t\t\t\tfragmentsSize,", "-\t\t\t\t\tthis.scribe.scanner.currentPosition);", "-\t\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "-\t\t\tboolean ok = false;", "-\t\t\tASTNode[] fragments = builder.fragments();", "-\t\t\tint[] operators = builder.operators();", "-\t\t\tdo {", "-\t\t\t\ttry {", "-\t\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "-\t\t\t\t\t\tASTNode fragment = fragments[i];", "-\t\t\t\t\t\tfragment.traverse(this, scope);", "-\t\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "-\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "-\t\t\t\t\t\t\t// a new line has been inserted by printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT)", "-\t\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.preferences.wrap_before_binary_operator) {", "-\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "-\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "-\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "-\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "-\t\t\t\t\t\t\tthis.scribe.space();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "-\t\t\t\t\t\t\tthis.scribe.space();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tfragments[fragmentsSize - 1].traverse(this, scope);", "-\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "-\t\t\t\t\tok = true;", "-\t\t\t\t} catch(AlignmentException e){", "-\t\t\t\t\tthis.scribe.redoAlignment(e);", "-\t\t\t\t}", "-\t\t\t} while (!ok);", "-\t\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);", "+\t\tif (this.expressionsDepth < 0) {", "+\t\t\tthis.expressionsDepth = 0;", "-\t\t\tbinaryExpression.left.traverse(this, scope);", "-\t\t\tthis.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);", "-\t\t\tif (operator == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "-\t\t\t\t// the next character is a minus (unary operator)", "-\t\t\t\tthis.scribe.space();", "+\t\t\tthis.expressionsDepth++;", "+\t\t\tthis.expressionsPos <<= 2;", "+\t\t}", "+\t\ttry {", "+\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = 0;", "+\t\t\tif ((builder.realFragmentsSize() > 1 || fragmentsSize > 4) && numberOfParens == 0) {", "+\t\t\t\tint scribeLine = this.scribe.line;", "+\t\t\t\tthis.scribe.printComment();", "+\t\t\t\tAlignment binaryExpressionAlignment = this.scribe.createAlignment(", "+\t\t\t\t\t\tAlignment.BINARY_EXPRESSION,", "+\t\t\t\t\t\tthis.preferences.alignment_for_binary_expression,", "+\t\t\t\t\t\tAlignment.R_OUTERMOST,", "+\t\t\t\t\t\tfragmentsSize,", "+\t\t\t\t\t\tthis.scribe.scanner.currentPosition);", "+\t\t\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "+\t\t\t\tboolean ok = false;", "+\t\t\t\tASTNode[] fragments = builder.fragments();", "+\t\t\t\tint[] operators = builder.operators();", "+\t\t\t\tdo {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tfinal int max = fragmentsSize - 1;", "+\t\t\t\t\t\tfor (int i = 0; i < max; i++) {", "+\t\t\t\t\t\t\tASTNode fragment = fragments[i];", "+\t\t\t\t\t\t\tfragment.traverse(this, scope);", "+\t\t\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "+\t\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t\t\t// a new line has been inserted while printing the comment", "+\t\t\t\t\t\t\t\t// hence we need to use the break indentation level before printing next token...", "+\t\t\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.preferences.wrap_before_binary_operator) {", "+\t\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tfragments[max].traverse(this, scope);", "+\t\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "+\t\t\t\t\t\tok = true;", "+\t\t\t\t\t} catch(AlignmentException e){", "+\t\t\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t\t\t}", "+\t\t\t\t} while (!ok);", "+\t\t\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);", "+\t\t\t\tif (this.scribe.line == scribeLine) {", "+\t\t\t\t\t// The expression was not broken => reset last break indentation", "+\t\t\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = 0;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.expressionsPos |= EXPRESSIONS_POS_ENTER_TWO;", "+\t\t\t\tbinaryExpression.left.traverse(this, scope);", "+\t\t\t\tthis.expressionsPos &= ~EXPRESSIONS_POS_MASK;", "+\t\t\t\tthis.expressionsPos |= EXPRESSIONS_POS_BETWEEN_TWO;", "+\t\t\t\tthis.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator, Scribe.PRESERVE_EMPTY_LINES_IN_BINARY_EXPRESSION);", "+\t\t\t\tif (operator == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t}", "+\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t}", "+\t\t\t\tbinaryExpression.right.traverse(this, scope);", "-\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "-\t\t\t\tthis.scribe.space();", "+\t\t}", "+\t\tfinally {", "+\t\t\tthis.expressionsDepth--;", "+\t\t\tthis.expressionsPos >>= 2;", "+\t\t\tif (this.expressionsDepth < 0) {", "+\t\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = 0;", "-\t\t\tbinaryExpression.right.traverse(this, scope);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d0755eabf4864367231ef65ceb8d4616", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "69b02d68015b1f30ee38d1576a843274517957c7", "commitAfterChange": "c7a9edf536467451ba659d7e03ac6c483c5c0cfe", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 28, "signatureBeforeChange": " protected void consumeClassHeaderExtends()", "signatureAfterChange": " protected void consumeClassHeaderExtends()", "diff": ["+}", "+\t", "+\tif (currentElement != null", "+\t\t&& currentToken == TokenNameIdentifier", "+\t\t&& this.cursorLocation+1 >= scanner.startPosition", "+\t\t&& this.cursorLocation < scanner.currentPosition){", "+\t\tthis.pushIdentifier();", "+\t\t", "+\t\tint index = -1;", "+\t\t/* check if current awaiting identifier is the completion identifier */", "+\t\tif ((index = this.indexOfAssistIdentifier()) > -1) {", "+", "+\t\t\tRecoveredType recoveredType = (RecoveredType)currentElement;", "+\t\t\t/* filter out cases where scanner is still inside type header */", "+\t\t\tif (!recoveredType.foundOpeningBrace) {", "+\t\t\t\tTypeDeclaration type = recoveredType.typeDeclaration;", "+\t\t\t\tif(type.superInterfaces == null) {", "+\t\t\t\t\ttype.superclass = new CompletionOnKeyword1(", "+\t\t\t\t\t\tidentifierStack[index],", "+\t\t\t\t\t\tidentifierPositionStack[index],", "+\t\t\t\t\t\tKeywords.IMPLEMENTS);", "+\t\t\t\t\tthis.assistNode = type.superclass;", "+\t\t\t\t\tthis.lastCheckPoint = type.superclass.sourceEnd + 1;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e82581b1f893be32d2f8b1e178b218d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "e4b55bd211dccbfbd971d96ae9fb1fa085f3370c", "commitAfterChange": "608a55b772f6bb6d5bb4b781bdb909738331065e", "methodNumberBeforeChange": 136, "methodNumberAfterChange": 136, "signatureBeforeChange": " protected void consumeEnumConstantHeaderName()", "signatureAfterChange": " protected void consumeEnumConstantHeaderName()", "diff": ["-   long pos = this.identifierPositionStack[this.identifierPtr];", "+\tif (this.currentElement != null) {", "+\t\tif (!(this.currentElement instanceof RecoveredType)", "+\t\t\t\t|| (this.lastIgnoredToken == TokenNameDOT)) {", "+\t\t\tthis.lastCheckPoint = this.scanner.startPosition;", "+\t\t\tthis.restartRecovery = true;", "+\t\t\treturn;", "+\t\t}", "+\t}", "+   long namePosition = this.identifierPositionStack[this.identifierPtr];", "-   final int sourceEnd = (int) pos;", "-   FieldDeclaration enumConstant = new FieldDeclaration(constantName, (int) (pos >>> 32), sourceEnd);", "+   final int sourceEnd = (int) namePosition;", "+   FieldDeclaration enumConstant = createFieldDeclaration(constantName, (int) (namePosition >>> 32), sourceEnd);", "+\tif (this.currentElement != null){", "+\t\tif (!(this.currentElement instanceof RecoveredType)", "+\t\t\t&& (this.currentToken == TokenNameDOT)){", "+\t\t\tthis.lastCheckPoint = (int) (namePosition >>> 32);", "+\t\t\tthis.restartRecovery = true;", "+\t\t\treturn;", "+\t\t}", "+\t\tthis.lastCheckPoint = enumConstant.sourceEnd + 1;", "+\t\tthis.currentElement = this.currentElement.add(enumConstant, 0);\t\t", "+\t}"]}], "num": 35141}