{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fd44422e5bab73f53eafbbffdc117a27", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "690749b5313f2e53f7e1e574e4f3db69", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "2c7a59198ef0accc78a3ea8fb276fbfe877a83c2", "commitAfterChange": "a55be3089b1474701c6009071b6792ce21fce5bc", "methodNumberBeforeChange": 53, "methodNumberAfterChange": 53, "signatureBeforeChange": "  \tprivate int generateBootstrapMethods(List functionalExpressionList)", "signatureAfterChange": "  \tprivate int generateBootstrapMethods(List functionalExpressionList)", "diff": ["-\t\tint indexForMetaFactory = this.constantPool.literalIndexForMethodHandle(ClassFileConstants.MethodHandleRefKindInvokeStatic, javaLangInvokeLambdaMetafactory, ", "-\t\t\t\tConstantPool.METAFACTORY, ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_METAFACTORY_SIGNATURE, false);", "+\t\t", "+\t\t// Depending on the complexity of the expression it may be necessary to use the altMetafactory() rather than the metafactory()", "+\t\tint indexForMetaFactory = 0;", "+\t\tint indexForAltMetaFactory = 0;", "+\t\t", "-\t\tthis.contentsOffset += exSize;", "-\t\tint value = (numberOfBootstraps * 10) + 2;", "-\t\tthis.contents[localContentsOffset++] = (byte) (value >> 24);", "-\t\tthis.contents[localContentsOffset++] = (byte) (value >> 16);", "-\t\tthis.contents[localContentsOffset++] = (byte) (value >> 8);", "-\t\tthis.contents[localContentsOffset++] = (byte) value;", "+\t\t// leave space for attribute_length and remember where to insert it", "+\t\tint attributeLengthPosition = localContentsOffset;", "+\t\tlocalContentsOffset += 4;", "-\t\t\tthis.contents[localContentsOffset++] = (byte) (indexForMetaFactory >> 8);", "-\t\t\tthis.contents[localContentsOffset++] = (byte) indexForMetaFactory;", "-\t\t\tthis.contents[localContentsOffset++] = 0;", "-\t\t\tthis.contents[localContentsOffset++] = (byte) 3;", "-\t\t\t", "-\t\t\tint functionalDescriptorIndex = this.constantPool.literalIndexForMethodType(functional.descriptor.original().signature());", "-\t\t\tthis.contents[localContentsOffset++] = (byte) (functionalDescriptorIndex >> 8);", "-\t\t\tthis.contents[localContentsOffset++] = (byte) functionalDescriptorIndex;", "+\t\t\tTypeBinding[] markerInterfaces = null;", "+\t\t\tif (functional instanceof LambdaExpression && ", "+\t\t\t\t   (((markerInterfaces=((LambdaExpression)functional).getMarkerInterfaces()) != null) ||", "+\t\t\t\t   \t((LambdaExpression)functional).isSerializable)) {", "+\t\t\t\t", "+\t\t\t\tLambdaExpression lambdaEx = (LambdaExpression)functional;", "+\t\t\t\t// may need even more space", "+\t\t\t\tint extraSpace = 2; // at least 2 more than when the normal metafactory is used, for the bitflags entry", "+\t\t\t\tif (markerInterfaces != null) {", "+\t\t\t\t\t// 2 for the marker interface list size then 2 per marker interface index", "+\t\t\t\t\textraSpace += (2 + 2 * markerInterfaces.length);", "+\t\t\t\t}", "+\t\t\t\tif (extraSpace + localContentsOffset >= this.contents.length) {", "+\t\t\t\t\tresizeContents(extraSpace);", "+\t\t\t\t} ", "+\t\t\t\t", "+\t\t\t\tif (indexForAltMetaFactory == 0) {", "+\t\t\t\t\tindexForAltMetaFactory = ", "+\t\t\t\t\t\tthis.constantPool.literalIndexForMethodHandle(ClassFileConstants.MethodHandleRefKindInvokeStatic, javaLangInvokeLambdaMetafactory, ", "+\t\t\t\t\t\tConstantPool.ALTMETAFACTORY, ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_ALTMETAFACTORY_SIGNATURE, false);", "+\t\t\t\t}", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) (indexForAltMetaFactory >> 8);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) indexForAltMetaFactory;", "+\t\t\t\t", "+\t\t\t\t// u2 num_bootstrap_arguments", "+\t\t\t\tthis.contents[localContentsOffset++] = 0;", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) (4+(markerInterfaces==null?0:1+markerInterfaces.length));", "+\t\t\t\t", "+\t\t\t\tint functionalDescriptorIndex = this.constantPool.literalIndexForMethodType(functional.descriptor.original().signature());", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) (functionalDescriptorIndex >> 8);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) functionalDescriptorIndex;", "+\t", "+\t\t\t\tint methodHandleIndex = this.constantPool.literalIndexForMethodHandle(functional.binding.original()); // Speak of \" implementation\" (erased) version here, adaptations described below.", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) (methodHandleIndex >> 8);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) methodHandleIndex;", "+\t", "+\t\t\t\tchar [] instantiatedSignature = functional.descriptor.signature();", "+\t\t\t\tint methodTypeIndex = this.constantPool.literalIndexForMethodType(instantiatedSignature);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) (methodTypeIndex >> 8);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) methodTypeIndex;", "-\t\t\tint methodHandleIndex = this.constantPool.literalIndexForMethodHandle(functional.binding.original()); // Speak of \" implementation\" (erased) version here, adaptations described below.", "-\t\t\tthis.contents[localContentsOffset++] = (byte) (methodHandleIndex >> 8);", "-\t\t\tthis.contents[localContentsOffset++] = (byte) methodHandleIndex;", "-", "-\t\t\tchar [] instantiatedSignature = functional.descriptor.signature();", "-\t\t\tint methodTypeIndex = this.constantPool.literalIndexForMethodType(instantiatedSignature);", "-\t\t\tthis.contents[localContentsOffset++] = (byte) (methodTypeIndex >> 8);", "-\t\t\tthis.contents[localContentsOffset++] = (byte) methodTypeIndex;", "+\t\t\t\t// Does this block have to deal with FLAG_BRIDGE? When is it needed?", "+\t\t\t\tint bitflags = 0;", "+\t\t\t\tif (lambdaEx.isSerializable) {", "+\t\t\t\t\tbitflags |= ClassFileConstants.FLAG_SERIALIZABLE;", "+\t\t\t\t}", "+\t\t\t\tif (markerInterfaces!=null) {", "+\t\t\t\t\tbitflags |= ClassFileConstants.FLAG_MARKERS;", "+\t\t\t\t}", "+\t\t\t\tint indexForBitflags = this.constantPool.literalIndex(bitflags);", "+\t\t\t\t", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte)(indexForBitflags>>8);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte)(indexForBitflags);", "+\t\t\t\t", "+\t\t\t\tif (markerInterfaces != null) {", "+\t\t\t\t\tint markerInterfaceCountIndex =  this.constantPool.literalIndex(markerInterfaces.length);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte)(markerInterfaceCountIndex>>8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte)(markerInterfaceCountIndex);", "+\t\t\t\t\tfor (int m = 0, maxm = markerInterfaces.length; m < maxm; m++) {", "+\t\t\t\t\t\tint classTypeIndex = this.constantPool.literalIndexForType(markerInterfaces[m]);", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte)(classTypeIndex>>8);", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte)(classTypeIndex);", "+\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (indexForMetaFactory == 0) {", "+\t\t\t\t\tindexForMetaFactory = this.constantPool.literalIndexForMethodHandle(ClassFileConstants.MethodHandleRefKindInvokeStatic, javaLangInvokeLambdaMetafactory, ", "+\t\t\t\t\t\t\tConstantPool.METAFACTORY, ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_METAFACTORY_SIGNATURE, false);", "+\t\t\t\t}", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) (indexForMetaFactory >> 8);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) indexForMetaFactory;", "+\t\t\t\t", "+\t\t\t\t// u2 num_bootstrap_arguments", "+\t\t\t\tthis.contents[localContentsOffset++] = 0;", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) 3;", "+\t\t\t\t", "+\t\t\t\tint functionalDescriptorIndex = this.constantPool.literalIndexForMethodType(functional.descriptor.original().signature());", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) (functionalDescriptorIndex >> 8);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) functionalDescriptorIndex;", "+\t", "+\t\t\t\tint methodHandleIndex = this.constantPool.literalIndexForMethodHandle(functional.binding.original()); // Speak of \" implementation\" (erased) version here, adaptations described below.", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) (methodHandleIndex >> 8);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) methodHandleIndex;", "+\t", "+\t\t\t\tchar [] instantiatedSignature = functional.descriptor.signature();", "+\t\t\t\tint methodTypeIndex = this.constantPool.literalIndexForMethodType(instantiatedSignature);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) (methodTypeIndex >> 8);", "+\t\t\t\tthis.contents[localContentsOffset++] = (byte) methodTypeIndex;\t\t\t\t", "+\t\t\t}", "+", "+\t\tint attributeLength = localContentsOffset - attributeLengthPosition - 4;", "+\t\tthis.contents[attributeLengthPosition++] = (byte) (attributeLength >> 24);", "+\t\tthis.contents[attributeLengthPosition++] = (byte) (attributeLength >> 16);", "+\t\tthis.contents[attributeLengthPosition++] = (byte) (attributeLength >> 8);", "+\t\tthis.contents[attributeLengthPosition++] = (byte) attributeLength;", "+\t\tthis.contentsOffset = localContentsOffset;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b9c4d48dfd3f28df61bce434f8d15f6c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "99a320ba218a453cde9430d003d516f8202cd4ca", "commitAfterChange": "bc5d9b450540dde0f4417c6b10a04ec18aa90f94", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 33, "signatureBeforeChange": " \tpublic void completeCodeAttributeForSyntheticMethod( \t\tSyntheticMethodBinding binding, \t\tint codeAttributeOffset, \t\tint[] startLineIndexes)", "signatureAfterChange": " \tpublic void completeCodeAttributeForSyntheticMethod( \t\tboolean hasExceptionHandlers, \t\tSyntheticMethodBinding binding, \t\tint codeAttributeOffset, \t\tint[] startLineIndexes)", "diff": ["+\t */", "+\tpublic void completeCodeAttributeForSyntheticMethod(", "+\t\tboolean hasExceptionHandlers,", "+\t\tSyntheticMethodBinding binding,", "+\t\tint codeAttributeOffset,", "+\t\tint[] startLineIndexes) {", "-\t\t// there is no exception table, so we need to offset by 2 the current offset and move ", "-\t\t// on the attribute generation", "-\t\tcontents[localContentsOffset++] = 0;", "-\t\tcontents[localContentsOffset++] = 0;", "+\t\t", "+\t\tif (hasExceptionHandlers) {", "+\t\t\t// write the exception table", "+\t\t\tint exceptionHandlersNumber = codeStream.exceptionHandlersCounter;", "+\t\t\tExceptionLabel[] exceptionHandlers = codeStream.exceptionHandlers;", "+\t\t\tint exSize = exceptionHandlersNumber * 8 + 2;", "+\t\t\tif (exSize + localContentsOffset >= this.contents.length) {", "+\t\t\t\tresizeContents(exSize);", "+\t\t\t}", "+\t\t\t// there is no exception table, so we need to offset by 2 the current offset and move ", "+\t\t\t// on the attribute generation", "+\t\t\tthis.contents[localContentsOffset++] = (byte) (exceptionHandlersNumber >> 8);", "+\t\t\tthis.contents[localContentsOffset++] = (byte) exceptionHandlersNumber;", "+\t\t\tfor (int i = 0, max = codeStream.exceptionHandlersIndex; i < max; i++) {", "+\t\t\t\tExceptionLabel exceptionHandler = exceptionHandlers[i];", "+\t\t\t\tif (exceptionHandler != null) {", "+\t\t\t\t\tint start = exceptionHandler.start;", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (start >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) start;", "+\t\t\t\t\tint end = exceptionHandler.end;", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (end >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) end;", "+\t\t\t\t\tint handlerPC = exceptionHandler.position;", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (handlerPC >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) handlerPC;", "+\t\t\t\t\tif (exceptionHandler.exceptionType == null) {", "+\t\t\t\t\t\t// any exception handler", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tint nameIndex;", "+\t\t\t\t\t\tswitch(exceptionHandler.exceptionType.id) {", "+\t\t\t\t\t\t\tcase T_null :", "+\t\t\t\t\t\t\t\t/* represents ClassNotFoundException, see class literal access*/", "+\t\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(ConstantPool.JavaLangClassNotFoundExceptionConstantPoolName);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase T_long :", "+\t\t\t\t\t\t\t\t/* represents NoSuchFieldError, see switch table generation*/", "+\t\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(ConstantPool.JavaLangNoSuchFieldErrorConstantPoolName);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(exceptionHandler.exceptionType.constantPoolName());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (nameIndex >> 8);", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) nameIndex;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// there is no exception table, so we need to offset by 2 the current offset and move ", "+\t\t\t// on the attribute generation", "+\t\t\tcontents[localContentsOffset++] = 0;", "+\t\t\tcontents[localContentsOffset++] = 0;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cde5735c4a08459f4c243f0600594dbf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tpublic void completeCodeAttributeForClinit(int codeAttributeOffset)", "signatureAfterChange": " \tpublic void completeCodeAttributeForClinit(int codeAttributeOffset)", "diff": ["+", "-\t\t\t\tfor (int i = 0; i < codeStream.allLocalsCounter; i++) {", "+", "+\t\t\t\t// used to remember the local variable with a generic type", "+\t\t\t\tint genericLocalVariablesCounter = 0;", "+\t\t\t\tLocalVariableBinding[] genericLocalVariables = null;", "+\t\t\t\tint numberOfGenericEntries = 0;", "+", "+\t\t\t\tfor (int i = 0, max = codeStream.allLocalsCounter; i < max; i++) {", "+\t\t\t\t\tfinal TypeBinding localVariableTypeBinding = localVariable.type;", "+\t\t\t\t\tboolean isParameterizedType = localVariableTypeBinding.isParameterizedType() || localVariableTypeBinding.isTypeVariable();", "+\t\t\t\t\tif (localVariable.initializationCount != 0 && isParameterizedType) {", "+\t\t\t\t\t\tif (genericLocalVariables == null) {", "+\t\t\t\t\t\t\t// we cannot have more than max locals", "+\t\t\t\t\t\t\tgenericLocalVariables = new LocalVariableBinding[max];", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tgenericLocalVariables[genericLocalVariablesCounter++] = localVariable;", "+\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (isParameterizedType) {", "+\t\t\t\t\t\t\t\tnumberOfGenericEntries++;", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tdescriptorIndex = constantPool.literalIndex(localVariable.type.signature());", "+\t\t\t\t\t\t\tdescriptorIndex = constantPool.literalIndex(localVariableTypeBinding.signature());", "+", "+\t\t\t\tif (genericLocalVariablesCounter != 0) {", "+\t\t\t\t\t// add the local variable type table attribute", "+\t\t\t\t\t// reserve enough space", "+\t\t\t\t\tint maxOfEntries = 8 + numberOfGenericEntries * 10;", "+", "+\t\t\t\t\tif (localContentsOffset + maxOfEntries >= this.contents.length) {", "+\t\t\t\t\t\tresizeContents(maxOfEntries);", "+\t\t\t\t\t}", "+\t\t\t\t\tint localVariableTypeNameIndex =", "+\t\t\t\t\t\tconstantPool.literalIndex(AttributeNamesConstants.LocalVariableTypeTableName);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (localVariableTypeNameIndex >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) localVariableTypeNameIndex;", "+\t\t\t\t\tvalue = numberOfGenericEntries * 10 + 2;", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (value >> 24);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (value >> 16);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (value >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) value;", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (numberOfGenericEntries >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) numberOfGenericEntries;", "+\t\t\t\t\tfor (int i = 0; i < genericLocalVariablesCounter; i++) {", "+\t\t\t\t\t\tLocalVariableBinding localVariable = genericLocalVariables[i];", "+\t\t\t\t\t\tfor (int j = 0; j < localVariable.initializationCount; j++) {", "+\t\t\t\t\t\t\tint startPC = localVariable.initializationPCs[j << 1];", "+\t\t\t\t\t\t\tint endPC = localVariable.initializationPCs[(j << 1) + 1];", "+\t\t\t\t\t\t\tif (startPC != endPC) { // only entries for non zero length", "+\t\t\t\t\t\t\t\t// now we can safely add the local entry", "+\t\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (startPC >> 8);", "+\t\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) startPC;", "+\t\t\t\t\t\t\t\tint length = endPC - startPC;", "+\t\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (length >> 8);", "+\t\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) length;", "+\t\t\t\t\t\t\t\tnameIndex = constantPool.literalIndex(localVariable.name);", "+\t\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (nameIndex >> 8);", "+\t\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) nameIndex;", "+\t\t\t\t\t\t\t\tdescriptorIndex = constantPool.literalIndex(localVariable.type.genericTypeSignature());", "+\t\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (descriptorIndex >> 8);", "+\t\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) descriptorIndex;", "+\t\t\t\t\t\t\t\tint resolvedPosition = localVariable.resolvedPosition;", "+\t\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (resolvedPosition >> 8);", "+\t\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) resolvedPosition;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tattributeNumber++;", "+\t\t\t\t}"]}], "num": 24452}