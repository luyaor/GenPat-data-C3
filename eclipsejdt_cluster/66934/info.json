{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f3d80b8467d0e16a73b62b4dc2eb100c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5d74f96fe4af3ba97b616290efff6948", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java", "commitBeforeChange": "f9a29367ea8f3c4c9489072b937e0b301d28ae36", "commitAfterChange": "a4f4cf398b9c048885f33786fe40b8704243b93a", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " public SyntheticArgumentBinding getSyntheticArgument(ReferenceBinding targetEnclosingType, boolean onlyExactMatch)", "signatureAfterChange": " public SyntheticArgumentBinding getSyntheticArgument(ReferenceBinding targetEnclosingType, boolean onlyExactMatch, boolean scopeIsConstructorCall)", "diff": ["-public SyntheticArgumentBinding getSyntheticArgument(ReferenceBinding targetEnclosingType, boolean onlyExactMatch) {", "+*/", "+public SyntheticArgumentBinding getSyntheticArgument(ReferenceBinding targetEnclosingType, boolean onlyExactMatch, boolean scopeIsConstructorCall) {", "+\t", "+\t", "+\t// firstly, during allocation, check and use the leftmost one (if possible) ", "+\t// to handle cases involving two instances of same type, such as", "+\t// class X {", "+\t//   class Inner extends X {}", "+\t//   void f(){", "+\t//     new X().new Inner(){} ", "+\t//     // here the result of (new X()) is passed as the first (synthetic) arg for ctor of new Inner(){}", "+\t//     // (and (this) as the second, of course) ", "+\t//   }", "+\t// }", "+\tif (scopeIsConstructorCall && this.enclosingInstances.length > 0)", "+\t\tif (this.enclosingInstances[0].type == targetEnclosingType) ", "+\t\t\tif (this.enclosingInstances[0].actualOuterLocalVariable == null)", "+\t\t\t\treturn this.enclosingInstances[0];", "+\t", "+\t// then check other possibility"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a91ecea5c6847237b1d50ce696446b59", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java", "commitBeforeChange": "20607cc9da90bd1294c224d1eff6327bec9954ac", "commitAfterChange": "11dd8a99a088c0f8f708fce4ca2ab2a6381f554a", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " public SyntheticArgumentBinding getSyntheticArgument(ReferenceBinding targetEnclosingType, boolean onlyExactMatch)", "signatureAfterChange": " public SyntheticArgumentBinding getSyntheticArgument(ReferenceBinding targetEnclosingType, boolean onlyExactMatch, boolean scopeIsConstructorCall)", "diff": ["-public SyntheticArgumentBinding getSyntheticArgument(ReferenceBinding targetEnclosingType, boolean onlyExactMatch) {", "+*/", "+public SyntheticArgumentBinding getSyntheticArgument(ReferenceBinding targetEnclosingType, boolean onlyExactMatch, boolean scopeIsConstructorCall) {", "+\t", "+\t", "+\t// firstly, during allocation, check and use the leftmost one (if possible) ", "+\t// to handle cases involving two instances of same type, such as", "+\t// class X {", "+\t//   class Inner extends X {}", "+\t//   void f(){", "+\t//     new X().new Inner(){} ", "+\t//     // here the result of (new X()) is passed as the first (synthetic) arg for ctor of new Inner(){}", "+\t//     // (and (this) as the second, of course) ", "+\t//   }", "+\t// }", "+\tif (scopeIsConstructorCall && this.enclosingInstances.length > 0)", "+\t\tif (this.enclosingInstances[0].type == targetEnclosingType) ", "+\t\t\tif (this.enclosingInstances[0].actualOuterLocalVariable == null)", "+\t\t\t\treturn this.enclosingInstances[0];", "+\t", "+\t// then check other possibility"]}], "num": 66934}