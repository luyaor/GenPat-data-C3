{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "edde4e43e29162eb4d0657cb2ec13e89", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0f41c767e8c1425d33dba2ee8066d300", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "f28c28de6ed3d2e9e475bca36caf25c219a92533", "commitAfterChange": "29530aea390a72e4225d01267051bcdef2bb5cd8", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "  \tpublic ASTNode convert(boolean isInterface, org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration methodDeclaration)", "signatureAfterChange": "  \tpublic ASTNode convert(boolean isInterface, org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration methodDeclaration)", "diff": ["-\t\t\tif (block != null", "-\t\t\t\t\t&& (Modifier.isAbstract(methodDecl.getModifiers())", "-\t\t\t\t\t\t\t|| Modifier.isNative(methodDecl.getModifiers())", "-\t\t\t\t\t\t\t|| isInterface)) {", "-\t\t\t\tmethodDecl.setFlags(methodDecl.getFlags() | ASTNode.MALFORMED);", "+\t\t\tif (block != null) {", "+\t\t\t\tif ((methodDeclaration.modifiers & (ClassFileConstants.AccAbstract | ClassFileConstants.AccNative)) != 0", "+\t\t\t\t\t\t|| (isInterface && (this.ast.apiLevel < AST.JLS8 ||", "+\t\t\t\t\t\t\t(methodDeclaration.modifiers & (ClassFileConstants.AccStatic | ExtraCompilerModifiers.AccDefaultMethod)) == 0))) {", "+\t\t\t\t\tmethodDecl.setFlags(methodDecl.getFlags() | ASTNode.MALFORMED);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "12dfdd1cf45db4eaccd218b7e6e236f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CaseStatement.java", "commitBeforeChange": "b418235473d69146fcb35be10bf158bb2b040cf7", "commitAfterChange": "eadf5ba6d44f28f071965cf829d67590b0a71974", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement)", "signatureAfterChange": " public Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement)", "diff": ["+ */", "+public Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement) {", "+\t// switchExpressionType maybe null in error case", "+    scope.enclosingCase = this; // record entering in a switch case block", "+    ", "+\tif (this.constantExpression == null) {", "+\t\t// remember the default case into the associated switch statement", "+\t\tif (switchStatement.defaultCase != null)", "+\t\t\tscope.problemReporter().duplicateDefaultCase(this);", "-\t */", "-\tpublic Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement) {", "-\t\t// switchExpressionType maybe null in error case", "-\t    scope.enclosingCase = this; // record entering in a switch case block", "-\t    ", "-\t\tif (constantExpression == null) {", "-\t\t\t// remember the default case into the associated switch statement", "-\t\t\tif (switchStatement.defaultCase != null)", "-\t\t\t\tscope.problemReporter().duplicateDefaultCase(this);", "-\t", "-\t\t\t// on error the last default will be the selected one ...\t", "-\t\t\tswitchStatement.defaultCase = this;", "-\t\t\treturn Constant.NotAConstant;", "-\t\t}", "-\t\t// add into the collection of cases of the associated switch statement", "-\t\tswitchStatement.cases[switchStatement.caseCount++] = this;", "-\t\t// tag constant name with enum type for privileged access to its members", "-\t\tif (switchExpressionType != null && switchExpressionType.isEnum() && (constantExpression instanceof SingleNameReference)) {", "-\t\t\t((SingleNameReference) constantExpression).setActualReceiverType((ReferenceBinding)switchExpressionType);", "-\t\t}", "-\t\tTypeBinding caseType = constantExpression.resolveType(scope);", "-\t\tif (caseType == null || switchExpressionType == null) return Constant.NotAConstant;", "-\t\tif (constantExpression.isConstantValueOfTypeAssignableToType(caseType, switchExpressionType)", "-\t\t\t\t|| caseType.isCompatibleWith(switchExpressionType)) {", "-\t\t\tif (caseType.isEnum()) {", "-\t\t\t\tthis.isEnumConstant = true;", "-\t\t\t\tif (((this.constantExpression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) != 0) {", "-\t\t\t\t\tscope.problemReporter().enumConstantsCannotBeSurroundedByParenthesis(this.constantExpression);", "-\t\t\t\t}", "-", "-\t\t\t\tif (constantExpression instanceof NameReference", "-\t\t\t\t\t\t&& (constantExpression.bits & RestrictiveFlagMASK) == Binding.FIELD) {", "-\t\t\t\t\tNameReference reference = (NameReference) constantExpression;", "-\t\t\t\t\tFieldBinding field = reference.fieldBinding();", "-\t\t\t\t\tif ((field.modifiers & ClassFileConstants.AccEnum) == 0) {", "-\t\t\t\t\t\t scope.problemReporter().enumSwitchCannotTargetField(reference, field);", "-\t\t\t\t\t} else \tif (reference instanceof QualifiedNameReference) {", "-\t\t\t\t\t\t scope.problemReporter().cannotUseQualifiedEnumConstantInCaseLabel(reference, field);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn IntConstant.fromValue(field.original().id + 1); // (ordinal value + 1) zero should not be returned see bug 141810", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\treturn constantExpression.constant;", "-\t\t\t}", "-\t\t} else if (scope.isBoxingCompatibleWith(caseType, switchExpressionType)", "-\t\t\t\t\t\t|| (caseType.isBaseType()  // narrowing then boxing ?", "-\t\t\t\t\t\t\t\t&& scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "-\t\t\t\t\t\t\t\t&& !switchExpressionType.isBaseType()", "-\t\t\t\t\t\t\t\t&& constantExpression.isConstantValueOfTypeAssignableToType(caseType, scope.environment().computeBoxingType(switchExpressionType)))) {", "-\t\t\t// constantExpression.computeConversion(scope, caseType, switchExpressionType); - do not report boxing/unboxing conversion", "-\t\t\treturn constantExpression.constant;", "-\t\t}", "-\t\tscope.problemReporter().typeMismatchError(caseType, switchExpressionType, constantExpression);", "+\t\t// on error the last default will be the selected one ...\t", "+\t\tswitchStatement.defaultCase = this;", "+\t// add into the collection of cases of the associated switch statement", "+\tswitchStatement.cases[switchStatement.caseCount++] = this;", "+\t// tag constant name with enum type for privileged access to its members", "+\tif (switchExpressionType != null && switchExpressionType.isEnum() && (this.constantExpression instanceof SingleNameReference)) {", "+\t\t((SingleNameReference) this.constantExpression).setActualReceiverType((ReferenceBinding)switchExpressionType);", "+\tTypeBinding caseType = this.constantExpression.resolveType(scope);", "+\tif (caseType == null || switchExpressionType == null) return Constant.NotAConstant;", "+\tif (this.constantExpression.isConstantValueOfTypeAssignableToType(caseType, switchExpressionType)", "+\t\t\t|| caseType.isCompatibleWith(switchExpressionType)) {", "+\t\tif (caseType.isEnum()) {", "+\t\t\tif (((this.constantExpression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) != 0) {", "+\t\t\t\tscope.problemReporter().enumConstantsCannotBeSurroundedByParenthesis(this.constantExpression);", "+\t\t\t}", "+", "+\t\t\tif (this.constantExpression instanceof NameReference", "+\t\t\t\t\t&& (this.constantExpression.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD) {", "+\t\t\t\tNameReference reference = (NameReference) this.constantExpression;", "+\t\t\t\tFieldBinding field = reference.fieldBinding();", "+\t\t\t\tif ((field.modifiers & ClassFileConstants.AccEnum) == 0) {", "+\t\t\t\t\t scope.problemReporter().enumSwitchCannotTargetField(reference, field);", "+\t\t\t\t} else \tif (reference instanceof QualifiedNameReference) {", "+\t\t\t\t\t scope.problemReporter().cannotUseQualifiedEnumConstantInCaseLabel(reference, field);", "+\t\t\t\t}", "+\t\t\t\treturn IntConstant.fromValue(field.original().id + 1); // (ordinal value + 1) zero should not be returned see bug 141810", "+\t\t\t}", "+\t\t} else {", "+\t\t\treturn this.constantExpression.constant;", "+\t\t}", "+\t} else if (scope.isBoxingCompatibleWith(caseType, switchExpressionType)", "+\t\t\t\t\t|| (caseType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t&& scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "+\t\t\t\t\t\t\t&& !switchExpressionType.isBaseType()", "+\t\t\t\t\t\t\t&& this.constantExpression.isConstantValueOfTypeAssignableToType(caseType, scope.environment().computeBoxingType(switchExpressionType)))) {", "+\t\t// constantExpression.computeConversion(scope, caseType, switchExpressionType); - do not report boxing/unboxing conversion", "+\t\treturn this.constantExpression.constant;", "+\t}", "+\tscope.problemReporter().typeMismatchError(caseType, switchExpressionType, this.constantExpression);", "+\treturn Constant.NotAConstant;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39e57b3398c319a0027aa01885f005c8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tpublic TypeBinding resolveForCatch(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveForCatch(BlockScope scope)", "diff": ["-\t\t\t\tcase Binding.ARRAY_TYPE :", "-\t\t\t\t\tif (((ArrayBinding) exceptionType).leafComponentType == TypeBinding.VOID) {", "-\t\t\t\t\t\tscope.problemReporter().variableTypeCannotBeVoidArray(this);", "-\t\t\t\t\t\thasError = true;", "-\t\t\t\t\t\t// fall thru to create the variable - avoids additional errors because the variable is missing", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-", "-\t\tthis.binding = new LocalVariableBinding(this, exceptionType, this.modifiers, false); // argument decl, but local var  (where isArgument = false)", "+\t\t", "+\t\tif ((this.type.bits & ASTNode.IsUnionType) != 0) {", "+\t\t\tthis.binding = new CatchParameterBinding(this, exceptionType, this.modifiers | ClassFileConstants.AccFinal, false); // argument decl, but local var  (where isArgument = false)", "+\t\t\tthis.binding.tagBits |= TagBits.MultiCatchParameter;", "+\t\t} else {", "+\t\t\tthis.binding = new CatchParameterBinding(this, exceptionType, this.modifiers, false); // argument decl, but local var  (where isArgument = false)", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c567b8476bb14f9739ae3212c891f11e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "8b0f83ab2fc2f0377aa0a160aaebc6cf11976024", "commitAfterChange": "841d4b99f7f88577aa004d23df8444d60d488b4b", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tpublic ConstructorDeclaration createDefaultConstructor( \t\tboolean needExplicitConstructorCall, \t\tboolean needToInsert)", "signatureAfterChange": "  public ConstructorDeclaration createDefaultConstructor(\tboolean needExplicitConstructorCall, boolean needToInsert)", "diff": ["+", "+public ConstructorDeclaration createDefaultConstructor(\tboolean needExplicitConstructorCall, boolean needToInsert) {", "+\t//Add to method'set, the default constuctor that just recall the", "+\t//super constructor with no arguments", "+\t//The arguments' type will be positionned by the TC so just use", "+\t//the default int instead of just null (consistency purpose)", "+", "+\t//the constructor", "+\tConstructorDeclaration constructor = new ConstructorDeclaration(this.compilationResult);", "+\tconstructor.isDefaultConstructor = true;", "+\tconstructor.selector = this.name;", "+\tconstructor.modifiers = this.modifiers & ExtraCompilerModifiers.AccVisibilityMASK;", "+", "+\t//if you change this setting, please update the ", "+\t//SourceIndexer2.buildTypeDeclaration(TypeDeclaration,char[]) method", "+\tconstructor.declarationSourceStart = constructor.sourceStart = this.sourceStart;", "+\tconstructor.declarationSourceEnd =", "+\t\tconstructor.sourceEnd = constructor.bodyEnd = this.sourceEnd;", "+", "+\t//the super call inside the constructor", "+\tif (needExplicitConstructorCall) {", "+\t\tconstructor.constructorCall = SuperReference.implicitSuperConstructorCall();", "+\t\tconstructor.constructorCall.sourceStart = this.sourceStart;", "+\t\tconstructor.constructorCall.sourceEnd = this.sourceEnd;", "-\t", "-\tpublic ConstructorDeclaration createDefaultConstructor(", "-\t\tboolean needExplicitConstructorCall,", "-\t\tboolean needToInsert) {", "-", "-\t\t//Add to method'set, the default constuctor that just recall the", "-\t\t//super constructor with no arguments", "-\t\t//The arguments' type will be positionned by the TC so just use", "-\t\t//the default int instead of just null (consistency purpose)", "-", "-\t\t//the constructor", "-\t\tConstructorDeclaration constructor = new ConstructorDeclaration(this.compilationResult);", "-\t\tconstructor.isDefaultConstructor = true;", "-\t\tconstructor.selector = this.name;", "-\t\tif (modifiers != ClassFileConstants.AccDefault) {", "-\t\t\tconstructor.modifiers =", "-\t\t\t\t(((this.bits & ASTNode.IsMemberType) != 0) && (modifiers & ClassFileConstants.AccPrivate) != 0)", "-\t\t\t\t\t? ClassFileConstants.AccDefault", "-\t\t\t\t\t: modifiers & ExtraCompilerModifiers.AccVisibilityMASK;", "-\t\t}", "-", "-\t\t//if you change this setting, please update the ", "-\t\t//SourceIndexer2.buildTypeDeclaration(TypeDeclaration,char[]) method", "-\t\tconstructor.declarationSourceStart = constructor.sourceStart = sourceStart;", "-\t\tconstructor.declarationSourceEnd =", "-\t\t\tconstructor.sourceEnd = constructor.bodyEnd = sourceEnd;", "-", "-\t\t//the super call inside the constructor", "-\t\tif (needExplicitConstructorCall) {", "-\t\t\tconstructor.constructorCall = SuperReference.implicitSuperConstructorCall();", "-\t\t\tconstructor.constructorCall.sourceStart = sourceStart;", "-\t\t\tconstructor.constructorCall.sourceEnd = sourceEnd;", "-\t\t}", "-", "-\t\t//adding the constructor in the methods list", "-\t\tif (needToInsert) {", "-\t\t\tif (methods == null) {", "-\t\t\t\tmethods = new AbstractMethodDeclaration[] { constructor };", "-\t\t\t} else {", "-\t\t\t\tAbstractMethodDeclaration[] newMethods;", "-\t\t\t\tSystem.arraycopy(", "-\t\t\t\t\tmethods,", "-\t\t\t\t\t0,", "-\t\t\t\t\tnewMethods = new AbstractMethodDeclaration[methods.length + 1],", "-\t\t\t\t\t1,", "-\t\t\t\t\tmethods.length);", "-\t\t\t\tnewMethods[0] = constructor;", "-\t\t\t\tmethods = newMethods;", "-\t\t\t}", "-\t\t}", "-\t\treturn constructor;", "-\t}", "+\t//adding the constructor in the methods list", "+\tif (needToInsert) {", "+\t\tif (this.methods == null) {", "+\t\t\tthis.methods = new AbstractMethodDeclaration[] { constructor };", "+\t\t\t\tthis.methods,", "+\t\t\t\tnewMethods = new AbstractMethodDeclaration[this.methods.length + 1],", "+\t\t\t\tthis.methods.length);", "+\t\t\tnewMethods[0] = constructor;", "+\t\t\tthis.methods = newMethods;", "+\t}", "+\treturn constructor;", "+}"]}], "num": 59740}