{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bdddb5684f154fd56c7877851d4e413b", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e68c7626f3cf411c342fd1cf07fe38c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "c68561900839d22ed60d27add792729a269fc650", "commitAfterChange": "0a6b1d13a406c88bfb0ad014ad0ce93c729298f3", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 60, "signatureBeforeChange": "  \tprivate void printLineComment(int commentStart, int commentEnd)", "signatureAfterChange": "  \tprivate void printLineComment(int commentStart, int commentEnd)", "diff": ["-\t\tStringBuffer buffer = new StringBuffer();", "-\t\tint editStart = this.scanner.currentPosition;", "-\t\tStringBuffer tokensBuffer = new StringBuffer();", "-\t\tboolean bufferHasTokens = false;", "-\t\tint previousPosition = commentStart;", "-\t\tboolean firstWord = true;", "+\t\tint lastTokenEndPosition = commentStart;", "+\t\tint spaceStartPosition = -1;", "+\t\tint spaceEndPosition = -1;", "+\t\tString newLineString = null;", "+\t\tthis.commentIndentation = null;", "-\t\t\t\t\tpreviousToken = token;", "-\t\t\t\t\tif (tokensBuffer.length() > 0) {", "-\t\t\t\t\t\tbuffer.append(tokensBuffer);", "-\t\t\t\t\t\tthis.column += tokensBuffer.length();", "-\t\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\t\t\tbufferHasTokens = true;", "+\t\t\t\t\tif (previousToken == -1) {", "+\t\t\t\t\t\t// do not remember the first whitespace", "+\t\t\t\t\t\tpreviousToken = SKIP_FIRST_WHITESPACE_TOKEN;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tpreviousToken = token;", "+\t\t\t\t\t// Remember space position", "+\t\t\t\t\tspaceStartPosition = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\tspaceEndPosition = this.scanner.getCurrentTokenEndPosition();", "-    \t\tboolean insertSpace = previousToken == -1 || previousToken == TerminalTokens.TokenNameWHITESPACE;", "-    \t\tint lastColumn = this.column + tokensBuffer.length() + tokenLength;", "-    \t\tif (insertSpace) lastColumn++;", "-\t\t\tif (!firstWord && lastColumn > maxColumn) {", "-\t\t\t\t// not enough space on the line", "-\t\t\t\tthis.line++;", "-\t\t\t\tif ((firstColumn+tokensBuffer.length()+tokenLength) > maxColumn) {", "-\t\t\t\t\t// there won't be enough room even if we break the line before the buffered tokens", "-\t\t\t\t\t// So add the buffered tokens now", "-\t\t\t\t\tbuffer.append(tokensBuffer);", "-\t\t\t\t\tthis.column += tokensBuffer.length();", "-\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\t\tbufferHasTokens = true;", "-\t\t\t\t}", "-\t\t\t\tif (bufferHasTokens) {", "-\t\t\t    \tbuffer.append(this.lineSeparator);", "-\t\t\t    \tthis.column = 1;", "-\t\t\t    \tprintIndentationIfNecessary(buffer);", "-\t    \t\t\tbuffer.append(LINE_COMMENT_PREFIX);", "-\t\t    \t\tthis.column += LINE_COMMENT_PREFIX_LENGTH;", "-\t\t\t\t}", "-\t\t    \tif (tokensBuffer.length() > 0) {", "-\t\t    \t\tif (ScannerHelper.isWhitespace(tokensBuffer.charAt(0))) {", "-\t\t\t\t\t\tbuffer.append(tokensBuffer.substring(1));", "-\t\t\t\t\t\tthis.column += tokensBuffer.length() - 1;", "-\t\t    \t\t} else {", "-\t\t\t\t\t\tbuffer.append(tokensBuffer);", "-\t\t\t\t\t\tthis.column += tokensBuffer.length();", "-\t\t    \t\t}", "-\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\t\tif (insertSpace)  {", "-\t\t    \t\t\tbuffer.append(' ');", "-\t\t    \t\t\tthis.column++;", "-\t\t\t\t\t}", "-\t\t    \t}", "-\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "-\t\t\t\tbufferHasTokens = true;", "-\t\t\t\tthis.column += tokenLength;", "-\t\t\t\tfirstColumn = this.indentationLevel + LINE_COMMENT_PREFIX_LENGTH;", "-\t\t\t} else {", "-\t\t\t\t// append token to the line", "-\t\t\t\tif (insertSpace)  {", "-\t    \t\t\ttokensBuffer.append(' ');", "-\t\t\t\t}", "-\t\t\t\ttokensBuffer.append(this.scanner.source, tokenStart, tokenLength);", "+", "+\t\t\t// insert space at the beginning if not present", "+\t\t\tif (previousToken == -1 ) {", "+    \t\t\taddInsertEdit(this.scanner.startPosition, \" \"); //$NON-NLS-1$", "+\t\t\t\tthis.column++;", "+\t\t\t// replace space at the beginning if present", "+\t\t\telse if (previousToken == SKIP_FIRST_WHITESPACE_TOKEN) {", "+\t\t\t\taddReplaceEdit(spaceStartPosition, this.scanner.startPosition-1, \" \"); //$NON-NLS-1$", "+\t\t\t\tthis.column++;", "+\t\t\t\tspaceStartPosition = -1; // do not use this position to split the comment", "+\t\t\t} else {", "+\t\t\t\t// not on the first token", "+\t\t\t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE;", "+\t\t\t\tif (insertSpace) {", "+\t\t\t\t\t// count inserted space if any in token length", "+\t\t\t\t\ttokenLength++;", "+\t\t\t\t}", "+\t\t\t\t// insert new line if max line width is reached and a space was previously encountered", "+\t\t\t\tif (spaceStartPosition > 0 && (this.column+tokenLength) > maxColumn) {", "+\t\t\t\t\tthis.lastNumberOfNewLines++;", "+\t\t\t\t\tthis.line++;", "+\t\t\t\t\tif (newLineString == null) {", "+\t\t\t\t\t\tStringBuffer newLineBuffer = new StringBuffer(this.lineSeparator);", "+\t\t\t\t\t\tthis.column = 1;", "+\t\t\t\t\t\tprintIndentationIfNecessary(newLineBuffer);", "+\t\t\t\t\t    newLineBuffer.append(LINE_COMMENT_PREFIX);", "+\t\t\t\t\t\tthis.column += LINE_COMMENT_PREFIX_LENGTH;", "+\t\t\t\t\t\tnewLineString = newLineBuffer.toString();", "+\t\t\t\t    \tfirstColumn = this.column;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.column = firstColumn;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (lastTokenEndPosition > spaceEndPosition) {", "+\t\t\t\t\t\tthis.column += lastTokenEndPosition - (spaceEndPosition + 1); // add all previous tokens lengths since last space", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.edits[this.editsIndex-1].offset == spaceStartPosition) {", "+\t\t\t\t\t\t// previous space was already edited, so remove it", "+\t\t\t\t\t\tthis.editsIndex--;", "+\t\t\t\t\t}", "+\t\t\t\t\taddReplaceEdit(spaceStartPosition, spaceEndPosition, newLineString);", "+\t\t\t\t\tspaceStartPosition = -1;", "+\t\t\t\t\tif (insertSpace) {", "+\t\t\t\t\t\ttokenLength--; // reduce token length as the space will be replaced by the new line", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// replace space if needed", "+\t\t\t\telse if (insertSpace) {", "+\t\t\t\t\taddReplaceEdit(spaceStartPosition, this.scanner.startPosition-1, \" \"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// update column position and store info of the current token", "+\t\t\tthis.column += tokenLength;", "-\t\t\tpreviousPosition = this.scanner.currentPosition;", "-\t\t\tfirstWord = false;", "+\t\t\tlastTokenEndPosition = this.scanner.currentPosition;", "-\t\t// Add remaining buffered tokens", "-\t\tif (tokensBuffer.length() > 0) {", "-\t\t\tbuffer.append(tokensBuffer);", "-\t\t\tthis.column += tokensBuffer.length();", "-\t\t}", "-", "-\t\t// Append separator if the comment is not at the end of file", "+\t\t// Skip separator if the comment is not at the end of file", "-\t\tthis.scanner.resetTo(previousPosition, commentEnd);", "+\t\tthis.scanner.resetTo(lastTokenEndPosition, commentEnd);", "-\t\t\tpreviousPosition = this.scanner.currentPosition;", "+\t\t\tspaceEndPosition = this.scanner.currentPosition;", "-", "-\t\t// Replace the existing comment with new one", "-\t\tif (buffer.length() > 0) {", "-\t\t\taddReplaceEdit(editStart, previousPosition - 1, buffer.toString());", "+\t\t", "+\t\t// Delete leading whitespaces if any", "+\t\tif (previousToken != -1 && lastTokenEndPosition != commentStart && spaceEndPosition > lastTokenEndPosition) {", "+\t\t\taddDeleteEdit(lastTokenEndPosition, spaceEndPosition-1);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fff24d460a5950bd9d4a7bd0ea47c0f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "917603919e9d38772fd63709feb3bbda7696f523", "commitAfterChange": "fca5fd453024a315e76f840acd34b846e15423bf", "methodNumberBeforeChange": 54, "methodNumberAfterChange": 58, "signatureBeforeChange": " \tprivate void printLineComment(int commentStart, int commentEnd)", "signatureAfterChange": "  \tprivate void printLineComment(int commentStart, int commentEnd)", "diff": ["+", "-\t\ttry {", "-\t\t\t// Consume text token per token", "-    \t\twhile (!this.scanner.atEnd()) {", "-\t\t\t\tint token;", "-\t\t\t\ttry {", "-\t\t\t\t\ttoken = this.scanner.getNextToken();", "-\t\t\t\t} catch (InvalidInputException iie) {", "-\t\t\t\t\tString msg = iie.getMessage();", "-\t\t\t\t\tif (msg == Scanner.INVALID_CHARACTER_CONSTANT) {", "-\t\t\t\t\t\tbuffer.append('\\'');", "-\t\t\t\t\t} else if (msg == Scanner.INVALID_CHAR_IN_STRING) {", "-\t\t\t\t\t\tbuffer.append('\"');", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tthrow iie;", "-\t\t\t\t\t}", "-\t\t\t\t\t// Need to retrieve correct position", "-\t\t\t\t\tthis.scanner.resetTo(this.scanner.startPosition, commentEnd);", "-\t\t\t\t\tthis.scanner.getNextChar();", "-\t\t\t\t\tthis.column++;", "+\t\t// Consume text token per token", "+\t\twhile (!this.scanner.atEnd()) {", "+\t\t\tint token;", "+\t\t\ttry {", "+\t\t\t\ttoken = this.scanner.getNextToken();", "+\t\t\t} catch (InvalidInputException iie) {", "+\t\t\t\tString msg = iie.getMessage();", "+\t\t\t\tif (msg == Scanner.INVALID_CHARACTER_CONSTANT) {", "+\t\t\t\t\tbuffer.append('\\'');", "+\t\t\t\t} else if (msg == Scanner.INVALID_CHAR_IN_STRING) {", "+\t\t\t\t\tbuffer.append('\"');", "+\t\t\t\t} else {", "+\t\t\t\t\t// skip failure", "+\t\t\t\t}", "+\t\t\t\t// Need to retrieve correct position", "+\t\t\t\tthis.scanner.resetTo(this.scanner.startPosition, commentEnd);", "+\t\t\t\tthis.scanner.getNextChar();", "+\t\t\t\tthis.column++;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tswitch (token) {", "+\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\tpreviousToken = token;", "+\t\t\t\t\tpreviousPosition = this.scanner.currentPosition;", "+\t\t\t\t\tpreviousChar = this.scanner.currentCharacter;", "-\t\t\t\t}", "-\t\t\t\tswitch (token) {", "-\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\tpreviousToken = token;", "-\t\t\t\t\t\tpreviousPosition = this.scanner.currentPosition;", "-\t\t\t\t\t\tpreviousChar = this.scanner.currentCharacter;", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\tcase TerminalTokens.TokenNameEOF:", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t}", "-    \t\t\tint tokenStart = this.scanner.getCurrentTokenStartPosition();", "-\t    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;", "-\t    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE;", "-\t\t\t\tthis.column += tokenLength;", "-\t    \t\tif (previousToken == -1 || insertSpace) this.column++;", "-\t    \t\tint col = column; ", "-\t\t\t\tif (!firstWord && col > maxColumn) {", "-\t\t\t\t\t// not enough space on the line", "-\t\t\t\t\tthis.lastNumberOfNewLines++;", "-\t\t\t    \tbuffer.append(this.lineSeparator);", "-\t\t\t    \tthis.column = 1;", "-\t\t\t    \tprintIndentationIfNecessary(buffer);", "-\t\t    \t\tbuffer.append(LINE_COMMENT_PREFIX);", "-\t\t\t    \tthis.column = firstColumn + LINE_COMMENT_PREFIX_LENGTH;", "-\t\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "-\t\t\t\t\tthis.column += tokenLength;", "-    \t\t\t} else {", "-\t\t\t\t\t// append token to the line", "-\t\t\t\t\tif (previousToken == -1 || insertSpace)  {", "-\t\t    \t\t\tbuffer.append(' ');", "-\t\t\t\t\t}", "-\t\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "-    \t\t\t}", "-\t\t\t\tpreviousToken = token;", "-\t\t\t\tpreviousPosition = this.scanner.currentPosition;", "-\t\t\t\tpreviousChar = this.scanner.currentCharacter;", "-\t\t\t\tfirstWord = false;", "-    \t\t}", "-\t\t} catch (InvalidInputException iie) {", "-\t\t\t// leave now", "-\t\t}", "-\t\tfinally {", "-\t\t\tthis.indentationLevel = indentLevel;", "-\t\t\tthis.numberOfIndentations = indentations;", "-\t\t\tif (previousChar == '\\n' || previousChar == '\\r') {", "-\t\t\t\t// line comment is normally ended with new line", "-\t\t\t\tthis.column = 1;", "-\t\t\t\tbuffer.append(this.lineSeparator);", "+\t\t\t\tcase TerminalTokens.TokenNameEOF:", "+\t\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tint tokenStart = this.scanner.getCurrentTokenStartPosition();", "+    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;", "+    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE;", "+\t\t\tthis.column += tokenLength;", "+    \t\tif (previousToken == -1 || insertSpace) this.column++;", "+    \t\tint col = column; ", "+\t\t\tif (!firstWord && col > maxColumn) {", "+\t\t\t\t// not enough space on the line", "-\t\t\t} else {", "-\t\t\t\tthis.scanner.resetTo(previousPosition, commentEnd);", "-\t\t\t\twhile (!this.scanner.atEnd()) {", "-\t\t\t\t\tthis.scanner.getNextChar();", "-\t\t\t\t\tif (this.scanner.currentCharacter == '\\n' || this.scanner.currentCharacter == '\\r') {", "-\t\t\t\t\t\t// line comment is normally ended with new line", "-\t\t\t\t\t\tbuffer.append(this.lineSeparator);", "-\t\t\t\t\t\tthis.column = 1;", "-\t\t\t\t\t\tthis.lastNumberOfNewLines++;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t// empty comment => it will be deleted", "-//\t\tif (previousToken == -1) {", "-//\t\t\tbuffer = null;", "-//\t\t\tif (this.column == 1) this.line--; // decrement as we're going to remove an empty comment", "-//\t\t} else {", "-\t\t\tif (this.column == 1) this.line++;", "-//\t\t}", "-", "-\t\t// Add corresponding edit", "-//\t\tif (buffer != null) {", "-\t\t\taddReplaceEdit(commentStart, commentEnd-1, buffer.toString());", "-//\t\t} else {", "-\t\t\t// delete empty comment ?", "-//\t\t\taddDeleteEdit(commentStart, commentEnd-1);", "-//\t\t}", "-\t}", "+\t\t    \tbuffer.append(this.lineSeparator);", "+\t\t    \tthis.column = 1;", "+\t\t    \tprintIndentationIfNecessary(buffer);", "+\t    \t\tbuffer.append(LINE_COMMENT_PREFIX);", "+\t\t    \tthis.column = firstColumn + LINE_COMMENT_PREFIX_LENGTH;", "+\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "+\t\t\t} else {", "+\t\t\t\t// append token to the line", "+\t\t\t\tif (previousToken == -1 || insertSpace)  {", "+\t    \t\t\tbuffer.append(' ');", "+\t\t\t\t}", "+\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "+\t\t\tpreviousToken = token;", "+\t\t\tpreviousPosition = this.scanner.currentPosition;", "+\t\t\tpreviousChar = this.scanner.currentCharacter;", "+\t\t\tfirstWord = false;", "+\t\t}", "+", "+\t\t// Append separator if the comment is not at the end of file", "+\t\tthis.indentationLevel = indentLevel;", "+\t\tthis.numberOfIndentations = indentations;", "+\t\tif (previousChar == '\\n' || previousChar == '\\r') {", "+\t\t\t// line comment is normally ended with new line", "+\t\t\tthis.column = 1;", "+\t\t\tbuffer.append(this.lineSeparator);", "+\t\t\tthis.lastNumberOfNewLines++;", "+\t\t} else if (previousPosition < commentEnd) {", "+\t\t\tthis.scanner.resetTo(previousPosition, commentEnd);", "+\t\t\t\t\t// line comment is normally ended with new line", "+\t\t\t\t\tbuffer.append(this.lineSeparator);", "+\t\t\t\t\tthis.column = 1;", "+\t\t\t\t\tthis.lastNumberOfNewLines++;", "+\t\t\t\t\tbreak;", "+", "+\t\t// Replace the existing comment with new one", "+\t\taddReplaceEdit(commentStart, commentEnd-1, buffer.toString());", "+\t}"]}], "num": 69174}