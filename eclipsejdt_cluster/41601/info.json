{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6bad161a260e0330768dfd10e709c278", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2cf7682f231a2efa8a4d2d55e0b95764", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " public int literalIndexForLdc(char[] stringCharArray)", "signatureAfterChange": " public int literalIndexForLdc(char[] stringCharArray)", "diff": ["-\tint savedCurrentIndex = this.currentIndex;", "-\tint savedCurrentOffset = this.currentOffset;", "-\tint index;", "-\tif ((index = stringCache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "-\t\t// The entry doesn't exit yet", "-\t\tthis.currentIndex++;", "-\t\t// Write the tag first", "-\t\twriteU1(StringTag);", "-\t\t", "-\t\t// Then the string index", "-\t\tint stringIndexOffset = this.currentOffset;", "-\t\tif (currentOffset + 2 >= poolContent.length) {", "-\t\t\tresizePoolContents(2);", "-\t\t}", "-\t\tcurrentOffset+=2;", "+    int savedCurrentIndex = this.currentIndex;", "+    int savedCurrentOffset = this.currentOffset;", "+    int index;", "+    if ((index = stringCache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "+        if ((index = -index)> 0xFFFF) {", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        // The entry doesn't exit yet", "+        this.currentIndex++;", "+        // Write the tag first", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(StringTag);", "-\t\tint stringIndex;", "-\t\tif ((stringIndex = UTF8Cache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "-\t\t\t// The entry doesn't exit yet", "-\t\t\tthis.currentIndex++;", "-\t\t\t// Write the tag first", "-\t\t\twriteU1(Utf8Tag);", "-\t\t\t// Then the size of the stringName array", "-\t\t\tint lengthOffset = currentOffset;", "-\t\t\tif (currentOffset + 2 >= poolContent.length) {", "-\t\t\t\t// we need to resize the poolContent array because we won't have", "-\t\t\t\t// enough space to write the length", "-\t\t\t\tresizePoolContents(2);", "-\t\t\t}", "-\t\t\tcurrentOffset += 2;", "-\t\t\tint length = 0;", "-\t\t\tfor (int i = 0; i < stringCharArray.length; i++) {", "-\t\t\t\tchar current = stringCharArray[i];", "-\t\t\t\tif ((current >= 0x0001) && (current <= 0x007F)) {", "-\t\t\t\t\t// we only need one byte: ASCII table", "-\t\t\t\t\tlength++;", "-\t\t\t\t\tif (currentOffset + 1 >= poolContent.length) {", "-\t\t\t\t\t\t// we need to resize the poolContent array because we won't have", "-\t\t\t\t\t\t// enough space to write the length", "-\t\t\t\t\t\tresizePoolContents(1);", "-\t\t\t\t\t}", "-\t\t\t\t\tpoolContent[currentOffset++] = (byte)(current);", "-\t\t\t\t} else", "-\t\t\t\t\tif (current > 0x07FF) {", "-\t\t\t\t\t\t// we need 3 bytes", "-\t\t\t\t\t\tlength += 3;", "-\t\t\t\t\t\tif (currentOffset + 3 >= poolContent.length) {", "-\t\t\t\t\t\t\t// we need to resize the poolContent array because we won't have", "-\t\t\t\t\t\t\t// enough space to write the length", "-\t\t\t\t\t\t\tresizePoolContents(3);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tpoolContent[currentOffset++] = (byte) (0xE0 | ((current >> 12) & 0x0F)); // 0xE0 = 1110 0000", "-\t\t\t\t\t\tpoolContent[currentOffset++] = (byte) (0x80 | ((current >> 6) & 0x3F)); // 0x80 = 1000 0000", "-\t\t\t\t\t\tpoolContent[currentOffset++] = (byte) (0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (currentOffset + 2 >= poolContent.length) {", "-\t\t\t\t\t\t\t// we need to resize the poolContent array because we won't have", "-\t\t\t\t\t\t\t// enough space to write the length", "-\t\t\t\t\t\t\tresizePoolContents(2);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// we can be 0 or between 0x0080 and 0x07FF", "-\t\t\t\t\t\t// In that case we only need 2 bytes", "-\t\t\t\t\t\tlength += 2;", "-\t\t\t\t\t\tpoolContent[currentOffset++] = (byte) (0xC0 | ((current >> 6) & 0x1F)); // 0xC0 = 1100 0000", "-\t\t\t\t\t\tpoolContent[currentOffset++] = (byte) (0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "-\t\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (length >= 65535) {", "-\t\t\t\tthis.currentOffset = savedCurrentOffset;", "-\t\t\t\tthis.currentIndex = savedCurrentIndex;", "-\t\t\t\tthis.stringCache.remove(stringCharArray);", "-\t\t\t\tthis.UTF8Cache.remove(stringCharArray);", "-\t\t\t\treturn 0;", "-\t\t\t}", "-\t\t\tpoolContent[lengthOffset++] = (byte) (length >> 8);", "-\t\t\tpoolContent[lengthOffset] = (byte) length;", "-\t\t\tstringIndex = -stringIndex;", "-\t\t}", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\tpoolContent[stringIndexOffset++] = (byte) (stringIndex >> 8);", "-\t\tpoolContent[stringIndexOffset] = (byte) stringIndex;", "-\t}", "-\treturn index;", "+        // Then the string index", "+        int stringIndexOffset = this.currentOffset;", "+        if (currentOffset + 2 >= poolContent.length) {", "+            resizePoolContents(2);", "+        }", "+        currentOffset+=2;", "+", "+        int stringIndex;", "+        if ((stringIndex = UTF8Cache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "+            if ((stringIndex = -stringIndex)> 0xFFFF) {", "+                this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+            }", "+            // The entry doesn't exit yet", "+            this.currentIndex++;", "+            // Write the tag first", "+            length = this.offsets.length;", "+            if (length <= stringIndex) {", "+            \t// resize", "+                System.arraycopy(this.offsets, 0, (this.offsets = new int[stringIndex * 2]), 0, length);", "+            }", "+            this.offsets[stringIndex] = this.currentOffset;", "+            writeU1(Utf8Tag);", "+            // Then the size of the stringName array", "+            int lengthOffset = currentOffset;", "+            if (currentOffset + 2 >= poolContent.length) {", "+                // we need to resize the poolContent array because we won't have", "+                // enough space to write the length", "+                resizePoolContents(2);", "+            }", "+            currentOffset += 2;", "+            length = 0;", "+            for (int i = 0; i < stringCharArray.length; i++) {", "+                char current = stringCharArray[i];", "+                if ((current >= 0x0001) && (current <= 0x007F)) {", "+                    // we only need one byte: ASCII table", "+                    length++;", "+                    if (currentOffset + 1 >= poolContent.length) {", "+                        // we need to resize the poolContent array because we won't have", "+                        // enough space to write the length", "+                        resizePoolContents(1);", "+                    }", "+                    poolContent[currentOffset++] = (byte)(current);", "+                } else", "+                    if (current > 0x07FF) {", "+                        // we need 3 bytes", "+                        length += 3;", "+                        if (currentOffset + 3 >= poolContent.length) {", "+                            // we need to resize the poolContent array because we won't have", "+                            // enough space to write the length", "+                            resizePoolContents(3);", "+                        }", "+                        poolContent[currentOffset++] = (byte) (0xE0 | ((current >> 12) & 0x0F)); // 0xE0 = 1110 0000", "+                        poolContent[currentOffset++] = (byte) (0x80 | ((current >> 6) & 0x3F)); // 0x80 = 1000 0000", "+                        poolContent[currentOffset++] = (byte) (0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "+                    } else {", "+                        if (currentOffset + 2 >= poolContent.length) {", "+                            // we need to resize the poolContent array because we won't have", "+                            // enough space to write the length", "+                            resizePoolContents(2);", "+                        }", "+                        // we can be 0 or between 0x0080 and 0x07FF", "+                        // In that case we only need 2 bytes", "+                        length += 2;", "+                        poolContent[currentOffset++] = (byte) (0xC0 | ((current >> 6) & 0x1F)); // 0xC0 = 1100 0000", "+                        poolContent[currentOffset++] = (byte) (0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "+                    }", "+            }", "+            if (length >= 65535) {", "+                this.currentOffset = savedCurrentOffset;", "+                this.currentIndex = savedCurrentIndex;", "+                this.stringCache.remove(stringCharArray);", "+                this.UTF8Cache.remove(stringCharArray);", "+                return 0;", "+            }", "+            poolContent[lengthOffset++] = (byte) (length >> 8);", "+            poolContent[lengthOffset] = (byte) length;", "+        }", "+        poolContent[stringIndexOffset++] = (byte) (stringIndex >> 8);", "+        poolContent[stringIndexOffset] = (byte) stringIndex;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bb8ba0b4dccfc144ab37789bd87de6d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public int literalIndex(char[] utf8Constant)", "signatureAfterChange": " public int literalIndex(char[] utf8Constant)", "diff": ["-\tint index;", "-\tif ((index = UTF8Cache.putIfAbsent(utf8Constant, this.currentIndex)) < 0) {", "-\t\tindex = -index;", "-\t\t// The entry doesn't exit yet", "-\t\t// Write the tag first", "-\t\twriteU1(Utf8Tag);", "-\t\t// Then the size of the stringName array", "-\t\tint savedCurrentOffset = currentOffset;", "-\t\tif (currentOffset + 2 >= poolContent.length) {", "-\t\t\t// we need to resize the poolContent array because we won't have", "-\t\t\t// enough space to write the length", "-\t\t\tresizePoolContents(2);", "-\t\t}", "-\t\tcurrentOffset += 2;", "-\t\tint length = 0;", "-\t\tfor (int i = 0; i < utf8Constant.length; i++) {", "-\t\t\tchar current = utf8Constant[i];", "-\t\t\tif ((current >= 0x0001) && (current <= 0x007F)) {", "-\t\t\t\t// we only need one byte: ASCII table", "-\t\t\t\twriteU1(current);", "-\t\t\t\tlength++;", "-\t\t\t} else {", "-\t\t\t\tif (current > 0x07FF) {", "-\t\t\t\t\t// we need 3 bytes", "-\t\t\t\t\tlength += 3;", "-\t\t\t\t\twriteU1(0xE0 | ((current >> 12) & 0x0F)); // 0xE0 = 1110 0000", "-\t\t\t\t\twriteU1(0x80 | ((current >> 6) & 0x3F)); // 0x80 = 1000 0000", "-\t\t\t\t\twriteU1(0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "-\t\t\t\t} else {", "-\t\t\t\t\t// we can be 0 or between 0x0080 and 0x07FF", "-\t\t\t\t\t// In that case we only need 2 bytes", "-\t\t\t\t\tlength += 2;", "-\t\t\t\t\twriteU1(0xC0 | ((current >> 6) & 0x1F)); // 0xC0 = 1100 0000", "-\t\t\t\t\twriteU1(0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (length >= 65535) {", "-\t\t\tcurrentOffset = savedCurrentOffset - 1;", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceForConstant(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\tif (index > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\tcurrentIndex++;     ", "-\t\t// Now we know the length that we have to write in the constant pool", "-\t\t// we use savedCurrentOffset to do that", "-\t\tpoolContent[savedCurrentOffset] = (byte) (length >> 8);", "-\t\tpoolContent[savedCurrentOffset + 1] = (byte) length;", "-\t}", "-\treturn index;", "+    int index;", "+    if ((index = UTF8Cache.putIfAbsent(utf8Constant, this.currentIndex)) < 0) {", "+        if ((index = -index)> 0xFFFF) {", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        // The entry doesn't exit yet", "+        // Write the tag first", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(Utf8Tag);", "+        // Then the size of the stringName array", "+        int savedCurrentOffset = currentOffset;", "+        if (currentOffset + 2 >= poolContent.length) {", "+            // we need to resize the poolContent array because we won't have", "+            // enough space to write the length", "+            resizePoolContents(2);", "+        }", "+        currentOffset += 2;", "+        length = 0;", "+        for (int i = 0; i < utf8Constant.length; i++) {", "+            char current = utf8Constant[i];", "+            if ((current >= 0x0001) && (current <= 0x007F)) {", "+                // we only need one byte: ASCII table", "+                writeU1(current);", "+                length++;", "+            } else {", "+                if (current > 0x07FF) {", "+                    // we need 3 bytes", "+                    length += 3;", "+                    writeU1(0xE0 | ((current >> 12) & 0x0F)); // 0xE0 = 1110 0000", "+                    writeU1(0x80 | ((current >> 6) & 0x3F)); // 0x80 = 1000 0000", "+                    writeU1(0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "+                } else {", "+                    // we can be 0 or between 0x0080 and 0x07FF", "+                    // In that case we only need 2 bytes", "+                    length += 2;", "+                    writeU1(0xC0 | ((current >> 6) & 0x1F)); // 0xC0 = 1100 0000", "+                    writeU1(0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "+                }", "+            }", "+        }", "+        if (length >= 65535) {", "+            currentOffset = savedCurrentOffset - 1;", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceForConstant(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        if (index > 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        currentIndex++;", "+        // Now we know the length that we have to write in the constant pool", "+        // we use savedCurrentOffset to do that", "+        poolContent[savedCurrentOffset] = (byte) (length >> 8);", "+        poolContent[savedCurrentOffset + 1] = (byte) length;", "+    }", "+    return index;"]}], "num": 41601}