{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a0803680c3b90802fc9cf9e4eb36dbd6", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9949d81166c2f346d9e1a9a88de9ad3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java", "commitBeforeChange": "bb7b9521196186c5be108c1f350a453c12233137", "commitAfterChange": "871cac4ba4cecfc6322ce0af5777177652a514a9", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  \t@Override \tpublic boolean visit(ArrayInitializer node)", "signatureAfterChange": "  \t@Override \tpublic boolean visit(ArrayInitializer node)", "diff": ["+\t\t}", "+\t\tif (!this.options.join_wrapped_lines", "+\t\t\t\t&& !this.options.insert_new_line_before_closing_brace_in_array_initializer) {", "+\t\t\t// if there is a line break before the closing brace, formatter should treat it as a valid wrap to preserve", "+\t\t\tint closingBraceIndex = this.tm.lastIndexIn(node, TokenNameRBRACE);", "+\t\t\tToken closingBrace = this.tm.get(closingBraceIndex);", "+\t\t\tif (this.tm.countLineBreaksBetween(this.tm.get(closingBraceIndex - 1), closingBrace) == 1) {", "+\t\t\t\tint openingBraceIndex = this.tm.firstIndexIn(node, TokenNameLBRACE);", "+\t\t\t\tclosingBrace.setWrapPolicy(", "+\t\t\t\t\t\tnew WrapPolicy(0, openingBraceIndex, this.currentDepth, 1, true, false, -1, false));", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d8d8a37713afc412216d52f701679b36", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java", "commitBeforeChange": "bb7b9521196186c5be108c1f350a453c12233137", "commitAfterChange": "871cac4ba4cecfc6322ce0af5777177652a514a9", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  \tprivate void findTokensToWrap(InfixExpression node, int depth)", "signatureAfterChange": "  \tprivate void findTokensToWrap(InfixExpression node, int depth)", "diff": ["-\t\t\tif (this.options.wrap_before_binary_operator) {", "-\t\t\t\tint index = this.tm.firstIndexBefore(operand, -1);", "-\t\t\t\twhile (this.tm.get(index).isComment())", "-\t\t\t\t\tindex--;", "-\t\t\t\tassert node.getOperator().toString().equals(this.tm.toString(index));", "-\t\t\t\tthis.wrapIndexes.add(index);", "-\t\t\t} else {", "-\t\t\t\tthis.wrapIndexes.add(this.tm.firstIndexIn(operand, -1));", "+\t\t\tint indexBefore = this.tm.firstIndexBefore(operand, -1);", "+\t\t\twhile (this.tm.get(indexBefore).isComment())", "+\t\t\t\tindexBefore--;", "+\t\t\tassert node.getOperator().toString().equals(this.tm.toString(indexBefore));", "+\t\t\tint indexAfter = this.tm.firstIndexIn(operand, -1);", "+\t\t\tthis.wrapIndexes.add(this.options.wrap_before_binary_operator ? indexBefore : indexAfter);", "+", "+\t\t\tif (!this.options.join_wrapped_lines) {", "+\t\t\t\t// TODO there should be an option for never joining wraps on opposite side of the operator", "+\t\t\t\tif (this.options.wrap_before_binary_operator) {", "+\t\t\t\t\tif (this.tm.countLineBreaksBetween(this.tm.get(indexAfter - 1), this.tm.get(indexAfter)) > 0)", "+\t\t\t\t\t\tthis.wrapIndexes.add(indexAfter);", "+\t\t\t\t} else {", "+\t\t\t\t\tif (this.tm.countLineBreaksBetween(this.tm.get(indexBefore), this.tm.get(indexBefore - 1)) > 0)", "+\t\t\t\t\t\tthis.wrapIndexes.add(indexBefore);", "+\t\t\t\t}"]}], "num": 18432}