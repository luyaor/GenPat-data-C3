{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "881c23b42dd0a82f7e41e12ca3cb20df", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3fbc813f358f88a18c9a537d302964f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "c9df47e6bc4127d80d1e16ea8353f464e792fda3", "commitAfterChange": "514d8e9afb885d3be64fa67a03a4dd281867840f", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\t\t\t\t\tboolean isExactMatch = true;", "-\t\t\t\t\t\tif (methodBinding == null) {", "-\t\t\t\t\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "-\t\t\t\t\t\t\tisExactMatch = false;", "+\t\t\t\t\t\tif (methodBinding == null)", "-\t\t\t\t\t\t\t// methodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (!isExactMatch) {", "-\t\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\t\t\tif (compatibleMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t// likely not a match in the first place, 2 cases are possible", "-\t\t\t\t\t\t\t\t\t\t// first is when methodBinding was found thru inheritance starting from an nested type - in this case do not want to search outer scope", "-\t\t\t\t\t\t\t\t\t\t// second is when normal search turned up only this selector match so NotFound is expected", "-\t\t\t\t\t\t\t\t\t\t// except in 1.5 when static import methods can match correctly", "-\t\t\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible) {", "-\t\t\t\t\t\t\t\t\t\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 && !receiverType.isNestedType()) {", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak; // need to search for static import method matches", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t// inherited mismatch is reported directly, not looking at enclosing matches", "-\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t} else if (!compatibleMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\t\tfuzzyProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tmethodBinding = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\tif (!methodBinding.canBeSeenBy(receiverType, invocationSite, classScope)) {", "-\t\t\t\t\t\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "-\t\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, ProblemReasons.NotVisible);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (fuzzyProblem == null && !methodBinding.isStatic()) {", "+\t\t\t\t\t\t\t\tif (!methodBinding.isStatic()) {", "-\t", "-\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass", "-\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS", "-\t\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)) {", "-\t\t\t\t\t\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "-\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited visible shadows enclosing)", "-\t\t\t\t\t\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "-\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+", "+\t\t\t\t\t\t\t\tif (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass", "+\t\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS", "+\t\t\t\t\t\t\t\t\t\t|| ((foundFuzzyProblem == null || foundFuzzyProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)) {", "+\t\t\t\t\t\t\t\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited visible shadows enclosing)", "+\t\t\t\t\t\t\t\t\t\t\tif (depth > 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.problemId() != ProblemReasons.NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn foundFuzzyProblem;", "+\t\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "+\t\t\t\t\t\t\t\t\t\t\treturn methodBinding;", "-\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\t\tif (fuzzyProblem != null)", "-\t\t\t\t\t\t\t\t\t\t\treturn fuzzyProblem;", "-\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "-\t\t\t\t\t\t\t\t\t\treturn methodBinding;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tfuzzyProblem = methodBinding;", "+\t\t\t\t\t\t\t}", "+", "+\t\t\t\t\t\t\tif (foundMethod != null && foundMethod.declaringClass != methodBinding.declaringClass)", "+\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass || (receiverType.getMethods(selector)) != Binding.NO_METHODS)", "-\t\t\t\t\t\t\t\t\tif (foundMethod.declaringClass != methodBinding.declaringClass)", "-\t\t\t\t\t\t\t\t\t\t// ie. have we found the same method - do not trust field identity yet", "-\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\tProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t", "+\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\tProblemReasons.InheritedNameHidesEnclosingName);", "+", "+\t\tif (foundFuzzyProblem != null)", "+\t\t\tif (foundFuzzyProblem.problemId() != ProblemReasons.NotVisible && foundFuzzyProblem.problemId() != ProblemReasons.NotFound)", "+\t\t\t\treturn foundFuzzyProblem;", "+\t\tif (foundInsideProblem != null)", "+\t\t\treturn foundInsideProblem;", "+", "+\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.declaringClass != null && foundFuzzyProblem.declaringClass.id == TypeIds.T_JavaLangObject)", "+\t\t\t\treturn foundFuzzyProblem; // static imports lose to methods from Object", "+", "-\t\t\t\tMethodBinding[] visible = null;", "+\t\t\t\tObjectVector visible = null;", "-\t\t\t\t\t\tif (possible != null && possible != foundMethod) {", "+\t\t\t\t\t\tif (possible != null && possible != foundFuzzyProblem) {", "-\t\t\t\t\t\t\t\tif (foundMethod == null)", "-\t\t\t\t\t\t\t\t\tfoundMethod = possible; // answer as error case match", "+\t\t\t\t\t\t\t\tif (foundFuzzyProblem == null)", "+\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = possible; // answer as error case match", "-\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "-\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\t\t\t\t\t\tif (foundMethod == null || !foundMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\tif (!importBinding.onDemand && foundMethod.isValidBinding())", "-\t\t\t\t\t\t\t\t\t\t\t\t\tskipOnDemand = true;", "-\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\tif (visible == null || !visible.contains(compatibleMethod)) {", "+\t\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\t} else if (visible == null) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = new MethodBinding[] {foundMethod, compatibleMethod};", "-\t\t\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tint visibleLength = visible.length;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleLength + 1];", "-\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(visible, 0, temp, 0, visibleLength);", "-\t\t\t\t\t\t\t\t\t\t\t\t\ttemp[visibleLength] = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = temp;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (visible == null)", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = new ObjectVector(3);", "+\t\t\t\t\t\t\t\t\t\t\t\tvisible.add(compatibleMethod);", "-\t\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "+\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "+\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\tif (visible != null)", "-\t\t\t\t\tfoundMethod = mostSpecificMethodBinding(visible, visible.length, argumentTypes, invocationSite, null);", "-\t\t\t}", "-\t\t\tif (foundMethod != null) {", "-\t\t\t\tinvocationSite.setActualReceiverType(foundMethod.declaringClass);", "-\t\t\t\treturn foundMethod;", "+\t\t\t\tif (visible != null) {", "+\t\t\t\t\tMethodBinding[] temp = new MethodBinding[visible.size];", "+\t\t\t\t\tvisible.copyInto(temp);", "+\t\t\t\t\tfoundMethod = mostSpecificMethodBinding(temp, temp.length, argumentTypes, invocationSite, null);", "+\t\t\t\t}", "+\t\tif (foundMethod != null) {", "+\t\t\tinvocationSite.setActualReceiverType(foundMethod.declaringClass);", "+\t\t\treturn foundMethod;", "+\t\t}", "-\t\tif (foundInsideProblem != null)", "-\t\t\treturn foundInsideProblem;", "-\t\tif (foundMethod != null)", "-\t\t\treturn foundMethod;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ca2fff865398556b9dcae72621a6eed5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java", "commitBeforeChange": "c9df47e6bc4127d80d1e16ea8353f464e792fda3", "commitAfterChange": "514d8e9afb885d3be64fa67a03a4dd281867840f", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  public MethodBinding getImplicitMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  public MethodBinding getImplicitMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\tboolean insideStaticContext = false;", "-\tboolean insideConstructorCall = false;", "-\tMethodBinding foundMethod = null;", "-\tProblemMethodBinding foundFuzzyProblem = null; // the weird method lookup case (matches method name in scope, then arg types, then visibility)", "-\tProblemMethodBinding foundInsideProblem = null; // inside Constructor call or inside static context", "-\tScope scope = this;", "-\tboolean isExactMatch = true;", "-\tMethodBinding methodBinding =", "-\t\t(foundMethod == null)", "-\t\t\t? findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-\t\t\t: findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-//\t\t\t\t\t\t? findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-//\t\t\t\t\t\t: findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-\tif (methodBinding == null && foundMethod == null) {", "-\t\t// answers closest approximation, may not check argumentTypes or visibility", "-\t\tisExactMatch = false;", "+\tMethodBinding methodBinding = findExactMethod(receiverType, selector, argumentTypes, invocationSite);", "+\tif (methodBinding == null)", "-//\t\t\t\t\tmethodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t}", "-\t\tif (methodBinding.problemId() == ProblemReasons.Ambiguous) {", "-\t\t\tif (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible)", "-\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\treturn methodBinding;", "-\t\t\telse", "-\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\treturn new ProblemMethodBinding(selector, methodBinding.parameters, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t}", "-", "-\t\tProblemMethodBinding fuzzyProblem = null;", "-\t\tProblemMethodBinding insideProblem = null;", "-\t\tif (methodBinding.isValidBinding()) {", "-\t\t\tif (!isExactMatch) {", "-\t    \t    MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-\t\t\t\tif (compatibleMethod == null) {", "-\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\t} else {", "-\t\t\t\t    methodBinding = compatibleMethod;", "-\t\t\t\t    if (!canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this)) {\t", "-\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "-\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotVisible);", "-\t\t\t\t    }", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (fuzzyProblem == null && !methodBinding.isStatic()) {", "-\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\tinsideProblem = new ProblemMethodBinding(methodBinding, methodBinding.selector, methodBinding.parameters, ProblemReasons.NonStaticReferenceInConstructorInvocation);", "-\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\tinsideProblem = new ProblemMethodBinding(methodBinding, methodBinding.selector, methodBinding.parameters, ProblemReasons.NonStaticReferenceInStaticContext);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (receiverType == methodBinding.declaringClass || (receiverType.getMethods(selector)) != Binding.NO_METHODS) {", "-\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t// OR the receiverType implemented a method with the correct name", "-\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (it is inherited)", "-\t\t\t\t\tif (fuzzyProblem != null)", "-\t\t\t\t\t\treturn fuzzyProblem;", "-\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\treturn insideProblem;", "-\t\t\t\t\treturn methodBinding;", "-\t\t\t\t}", "-\t\t\t\t// if a method was found, complain when another is found in an 'immediate' enclosing type (ie. not inherited)", "-\t\t\t\t// NOTE: Unlike fields, a non visible method hides a visible method", "-\t\t\t\tif (foundMethod.declaringClass != methodBinding.declaringClass) // ie. have we found the same method - do not trust field identity yet", "-\t\t\t\t\treturn new ProblemMethodBinding(methodBinding, methodBinding.selector, methodBinding.parameters, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t}", "-\t\t}", "-", "-\t\tif (foundMethod == null || (foundMethod.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() != ProblemReasons.NotVisible)) {", "-\t\t\t// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...", "-\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "-\t\t\tfoundFuzzyProblem = fuzzyProblem;", "-\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\tif (fuzzyProblem == null)", "-\t\t\t\tfoundMethod = methodBinding; // only keep it if no error was found", "-\t\t}", "+\t\tif (methodBinding.isValidBinding())", "+\t\t    if (!canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this))", "+\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotVisible);", "+\t\treturn methodBinding;", "-\tinsideStaticContext |= receiverType.isStatic();", "-\t// 1EX5I8Z - accessing outer fields within a constructor call is permitted", "-\t// in order to do so, we change the flag as we exit from the type, not the method", "-\t// itself, because the class scope is used to retrieve the fields.", "-\tMethodScope enclosingMethodScope = scope.methodScope();", "-\tinsideConstructorCall = enclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "-", "-\tif (foundFuzzyProblem != null)", "-\t\treturn foundFuzzyProblem;", "-\tif (foundInsideProblem != null)", "-\t\treturn foundInsideProblem;", "-\tif (foundMethod != null)", "-\t\treturn foundMethod;"]}], "num": 360}