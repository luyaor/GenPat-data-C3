{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "083ccf47e37ceb496d6d3d6b56d1bdea", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0ff9b82e02a026f026175bc77c529318", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/TestingEnvironment.java", "commitBeforeChange": "5371361e21820d2b2e231653f1940e5405c7ae2f", "commitAfterChange": "83631fa7de14141f6ec93506fe4cb66a8c3eb380", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  \tpublic IPath addProject(String projectName, String compliance)", "signatureAfterChange": "  \tpublic IPath addProject(String projectName, String compliance)", "diff": ["+\t\tint requiredComplianceFlag = 0;", "+\t\tString compilerVersion = null;", "-\t\t\tif ((AbstractCompilerTest.getPossibleComplianceLevels()  & AbstractCompilerTest.F_1_5) == 0)", "-\t\t\t\tthrow new RuntimeException(\"This test should run on top of a 1.5 JRE\");", "+\t\t\trequiredComplianceFlag = AbstractCompilerTest.F_1_5;", "+\t\t\tcompilerVersion = CompilerOptions.VERSION_1_5;", "+\t\t}", "+\t\telse if (\"1.6\".equals(compliance)) {", "+\t\t\trequiredComplianceFlag = AbstractCompilerTest.F_1_6;", "+\t\t\tcompilerVersion = CompilerOptions.VERSION_1_6;", "+\t\t}", "+\t\telse if (\"1.7\".equals(compliance)) {", "+\t\t\trequiredComplianceFlag = AbstractCompilerTest.F_1_7;", "+\t\t\tcompilerVersion = CompilerOptions.VERSION_1_7;", "+\t\t}", "+\t\telse if (!\"1.4\".equals(compliance) && !\"1.3\".equals(compliance)) {", "+\t\t\tthrow new UnsupportedOperationException(\"Test framework doesn't support compliance level: \" + compliance);", "+\t\t}", "+\t\tif (requiredComplianceFlag != 0) {", "+\t\t\tif ((AbstractCompilerTest.getPossibleComplianceLevels() & requiredComplianceFlag) == 0)", "+\t\t\t\tthrow new RuntimeException(\"This test requires a \" + compliance + \" JRE\");", "-\t\t\toptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);", "-\t\t\toptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);\t", "-\t\t\toptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);\t", "+\t\t\toptions.put(CompilerOptions.OPTION_Compliance, compilerVersion);", "+\t\t\toptions.put(CompilerOptions.OPTION_Source, compilerVersion);\t", "+\t\t\toptions.put(CompilerOptions.OPTION_TargetPlatform, compilerVersion);\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "261bdafebc4ad1d8bb80fef9cc5c0198", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java", "commitBeforeChange": "e18b8152863f75de59815219afe0ab3ec946a798", "commitAfterChange": "5333a8d6e234b4d5bbcbee365cfa39aafade1032", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": " public static UnconditionalFlowInfo mergedOptimizedBranchesIfElse( \t\tFlowInfo initsWhenTrue, boolean isOptimizedTrue, \t\tFlowInfo initsWhenFalse, boolean isOptimizedFalse, \t\tboolean allowFakeDeadBranch, FlowInfo flowInfo, IfStatement ifStatement)", "signatureAfterChange": " public static UnconditionalFlowInfo mergedOptimizedBranchesIfElse( \t\tFlowInfo initsWhenTrue, boolean isOptimizedTrue, \t\tFlowInfo initsWhenFalse, boolean isOptimizedFalse, \t\tboolean allowFakeDeadBranch, FlowInfo flowInfo, IfStatement ifStatement, \t\tboolean reportDeadCodeInKnownPattern)", "diff": ["-\t\tboolean allowFakeDeadBranch, FlowInfo flowInfo, IfStatement ifStatement) {", "+\t\tboolean allowFakeDeadBranch, FlowInfo flowInfo, IfStatement ifStatement,", "+\t\tboolean reportDeadCodeInKnownPattern) {", "-\t\t\tmergedInfo = initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).", "-\t\t\t\tunconditionalInits();", "+\t\t\tif (!reportDeadCodeInKnownPattern) {", "+\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=256796", "+\t\t\t\t// do not report code even after if-else as dead as a consequence of analysis done in known dead code pattern", "+\t\t\t\t// when the CompilerOptions$reportDeadCodeInTrivialIfStatement option is disabled", "+\t\t\t\tif (ifStatement.elseStatement == null) {", "+\t\t\t\t\tmergedInfo = flowInfo.unconditionalInits();", "+\t\t\t\t} else {", "+\t\t\t\t\tmergedInfo = initsWhenFalse.unconditionalInits();", "+\t\t\t\t\tif (initsWhenFalse != FlowInfo.DEAD_END) {", "+\t\t\t\t\t\t// let the definitely true status of known dead code pattern not affect the reachability", "+\t\t\t\t\t\tmergedInfo.setReachMode(flowInfo.reachMode());", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tmergedInfo = initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).", "+\t\t\t\t\tunconditionalInits();", "+\t\t\t}", "-\t\t\tmergedInfo = initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).", "-\t\t\t\tunconditionalInits();", "+\t\t\tif (!reportDeadCodeInKnownPattern) {", "+\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=256796", "+\t\t\t\t// do not report code even after if-else as dead as a consequence of analysis done in known dead code pattern", "+\t\t\t\t// when the CompilerOptions$reportDeadCodeInTrivialIfStatement option is disabled", "+\t\t\t\tif (ifStatement.thenStatement == null) {", "+\t\t\t\t\tmergedInfo = flowInfo.unconditionalInits();", "+\t\t\t\t} else {", "+\t\t\t\t\tmergedInfo = initsWhenTrue.unconditionalInits();", "+\t\t\t\t\tif (initsWhenTrue != FlowInfo.DEAD_END) {", "+\t\t\t\t\t\t// let the definitely false status of known dead code pattern not affect the reachability", "+\t\t\t\t\t\tmergedInfo.setReachMode(flowInfo.reachMode());", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tmergedInfo = initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).", "+\t\t\t\t\tunconditionalInits();", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5579dfaba0ab836f50f43237c36885f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "69d976ecb2b4a910a78fb1eaf551e2775a0ff256", "commitAfterChange": "6e7138933a7b0a4bb6f562a7b0b5324e7f7fa604", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tpublic boolean ensureGeneratedSourceFolder( IProgressMonitor progressMonitor )", "signatureAfterChange": " \tpublic boolean ensureGeneratedSourceFolder( IProgressMonitor progressMonitor )", "diff": ["+\t\tboolean reset = false;", "+\t\tIFolder curSrcFolder = null;", "-\t\t\tif ( _generatedSourceFolder != null )", "+\t\t\tif( _generatedSourceFolderName == null )", "+\t\t\tif( _generatedSourceFolder != null ){", "+\t\t\t\tfinal IPath srcFolderPath = _generatedSourceFolder.getProjectRelativePath();", "+\t\t\t\t", "+\t", "+\t\t\t\tif( !_generatedSourceFolderName.equals( srcFolderPath.toString()) ){", "+\t\t\t\t\treset = true;", "+\t\t\t\t\tcurSrcFolder = _generatedSourceFolder;", "+\t\t\t\t\t_generatedSourceFolder = null;", "+\t\t\t\t}", "+\t\t\t\telse", "+\t\t\t\t\treturn false;", "+\t\t\t}", "+\t", "-\t\t// don't take any locks while creating the folder, since we are doing file-system operations", "-\t\tIFolder srcFolder = getGeneratedSourceFolder();", "-\t\ttry{ ", "+\t\tIFolder srcFolder = null;", "+\t\ttry{", "+\t\t\tif( reset ){", "+\t\t\t\t// the generated source folder and the generated source folder name is not", "+\t\t\t\t// lining up.", "+\t\t\t\tremoveFromProjectClasspath(_javaProject, curSrcFolder, progressMonitor );", "+\t\t\t\tif ( curSrcFolder.exists() ){", "+\t\t\t\t\tif( AptPlugin.DEBUG )", "+\t\t\t\t\t\tAptPlugin.trace(\"deleting gen src dir \" + curSrcFolder.getName() ); //$NON-NLS-1$", "+\t\t\t\t\tcurSrcFolder.delete( true, false, null );", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t\t", "+\t\t\t// don't take any locks while creating the folder, since we are doing file-system operations", "+\t\t\tsrcFolder = getGeneratedSourceFolder();", "+\t\t "]}], "num": 65988}