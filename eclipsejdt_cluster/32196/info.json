{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c8f9d1684c9e0b2803105e88083e1be5", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c280940b3a3591b3ec69e1bc26a74ee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "931e434bb3e4b9f62577b10f8123cfc028893969", "commitAfterChange": "c0b519c3b149b13ea0f307f0d3414359b2cf0639", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "  \tpublic TypeBinding getOtherFieldBindings(BlockScope scope)", "signatureAfterChange": "  public TypeBinding getOtherFieldBindings(BlockScope scope)", "diff": ["-\tpublic TypeBinding getOtherFieldBindings(BlockScope scope) {", "-\t\t// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)", "-\t\tint length = tokens.length;", "-\t\tFieldBinding field;", "-\t\tif ((bits & Binding.FIELD) != 0) {", "-\t\t\tfield = (FieldBinding) this.binding;", "-\t\t\tif (!field.isStatic()) {", "-\t\t\t\t//must check for the static status....", "-\t\t\t\tif (indexOfFirstFieldBinding > 1  //accessing to a field using a type as \"receiver\" is allowed only with static field", "-\t\t\t\t\t\t || scope.methodScope().isStatic) { \t// the field is the first token of the qualified reference....", "-\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, field);", "-\t\t\t\t\treturn null;", "-\t\t\t\t }", "-\t\t\t} else {", "+", "+public TypeBinding getOtherFieldBindings(BlockScope scope) {", "+\t// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)", "+\tint length = this.tokens.length;", "+\tFieldBinding field;", "+\tif ((this.bits & Binding.FIELD) != 0) {", "+\t\tfield = (FieldBinding) this.binding;", "+\t\tif (!field.isStatic()) {", "+\t\t\t//must check for the static status....", "+\t\t\tif (this.indexOfFirstFieldBinding > 1  //accessing to a field using a type as \"receiver\" is allowed only with static field", "+\t\t\t\t\t || scope.methodScope().isStatic) { \t// the field is the first token of the qualified reference....", "+\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, field);", "+\t\t\t\treturn null;", "+\t\t\t }", "+\t\t} else {", "+\t\t\t// indirect static reference ?", "+\t\t\tif (this.indexOfFirstFieldBinding > 1 ", "+\t\t\t\t\t&& field.declaringClass != this.actualReceiverType", "+\t\t\t\t\t&& field.declaringClass.canBeSeenBy(scope)) {", "+\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, field);", "+\t\t\t}", "+\t\t}", "+\t\t// only last field is actually a write access if any", "+\t\tif (isFieldUseDeprecated(field, scope, (this.bits & ASTNode.IsStrictlyAssigned) != 0 && this.indexOfFirstFieldBinding == length))", "+\t\t\tscope.problemReporter().deprecatedField(field, this);", "+\t} else {", "+\t\tfield = null;", "+\t}", "+\tTypeBinding type = ((VariableBinding) this.binding).type;", "+\tint index = this.indexOfFirstFieldBinding;", "+\tif (index == length) { //\trestrictiveFlag == FIELD", "+\t\tthis.constant = ((FieldBinding) this.binding).constant();", "+\t\t// perform capture conversion if read access", "+\t\treturn (type != null && (this.bits & ASTNode.IsStrictlyAssigned) == 0)", "+\t\t\t\t? type.capture(scope, this.sourceEnd)", "+\t\t\t\t: type;", "+\t}", "+\t// allocation of the fieldBindings array\tand its respective constants", "+\tint otherBindingsLength = length - index;", "+\tthis.otherCodegenBindings = this.otherBindings = new FieldBinding[otherBindingsLength];", "+\tthis.otherDepths = new int[otherBindingsLength];", "+\t", "+\t// fill the first constant (the one of the binding)", "+\tthis.constant = ((VariableBinding) this.binding).constant();", "+\t// save first depth, since will be updated by visibility checks of other bindings", "+\tint firstDepth = (this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT;", "+\t// iteration on each field\t", "+\twhile (index < length) {", "+\t\tchar[] token = this.tokens[index];", "+\t\tif (type == null)", "+\t\t\treturn null; // could not resolve type prior to this point", "+", "+\t\tthis.bits &= ~ASTNode.DepthMASK; // flush previous depth if any\t\t", "+\t\tFieldBinding previousField = field;", "+\t\tfield = scope.getField(type.capture(scope, (int)this.sourcePositions[index]), token, this);", "+\t\tint place = index - this.indexOfFirstFieldBinding;", "+\t\tthis.otherBindings[place] = field;", "+\t\tthis.otherDepths[place] = (this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT;", "+\t\tif (field.isValidBinding()) {", "+\t\t\t// set generic cast of for previous field (if any)", "+\t\t\tif (previousField != null) {", "+\t\t\t\tTypeBinding fieldReceiverType = type;", "+\t\t\t\tTypeBinding receiverErasure = type.erasure();", "+\t\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "+\t\t\t\t\tif (receiverErasure.findSuperTypeWithSameErasure(field.declaringClass) == null) {", "+\t\t\t\t\t\tfieldReceiverType = field.declaringClass; // handle indirect inheritance thru variable secondary bound", "+\t\t\t\t\t}", "+\t\t\t\t}\t\t\t\t", "+\t\t\t\tFieldBinding originalBinding = previousField.original();", "+\t\t\t    if ((originalBinding.type.tagBits &  TagBits.HasTypeVariable) != 0 && fieldReceiverType.id != TypeIds.T_JavaLangObject) {", "+\t\t\t    \tsetGenericCast(index-1,originalBinding.type.genericCast(fieldReceiverType)); // type cannot be base-type even in boxing case", "+\t\t\t    }", "+\t\t    }", "+\t\t\t// only last field is actually a write access if any", "+\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & ASTNode.IsStrictlyAssigned) !=0 && index+1 == length)) {", "+\t\t\t\tscope.problemReporter().deprecatedField(field, this);", "+\t\t\t}", "+\t\t\t// constant propagation can only be performed as long as the previous one is a constant too.", "+\t\t\tif (this.constant != Constant.NotAConstant) {", "+\t\t\t\tthis.constant = field.constant();\t\t\t\t\t", "+\t\t\t}", "+", "+\t\t\tif (field.isStatic()) {", "+\t\t\t\t// static field accessed through receiver? legal but unoptimal (optional warning)", "+\t\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, field);", "-\t\t\t\tif (indexOfFirstFieldBinding > 1 ", "-\t\t\t\t\t\t&& field.declaringClass != actualReceiverType", "-\t\t\t\t\t\t&& field.declaringClass.canBeSeenBy(scope)) {", "+\t\t\t\tif (field.declaringClass != type) {", "-\t\t\t// only last field is actually a write access if any", "-\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & IsStrictlyAssigned) != 0 && indexOfFirstFieldBinding == length))", "-\t\t\t\tscope.problemReporter().deprecatedField(field, this);", "+\t\t\ttype = field.type;", "+\t\t\tindex++;", "-\t\t\tfield = null;", "-\t\t}", "-\t\tTypeBinding type = ((VariableBinding) binding).type;", "-\t\tint index = indexOfFirstFieldBinding;", "-\t\tif (index == length) { //\trestrictiveFlag == FIELD", "-\t\t\tthis.constant = ((FieldBinding) binding).constant();", "-\t\t\t// perform capture conversion if read access", "-\t\t\treturn (type != null && (this.bits & IsStrictlyAssigned) == 0)", "-\t\t\t\t\t? type.capture(scope, this.sourceEnd)", "-\t\t\t\t\t: type;", "-\t\t}", "-\t\t// allocation of the fieldBindings array\tand its respective constants", "-\t\tint otherBindingsLength = length - index;", "-\t\totherCodegenBindings = otherBindings = new FieldBinding[otherBindingsLength];", "-\t\totherDepths = new int[otherBindingsLength];", "-\t\t", "-\t\t// fill the first constant (the one of the binding)", "-\t\tthis.constant = ((VariableBinding) binding).constant();", "-\t\t// save first depth, since will be updated by visibility checks of other bindings", "-\t\tint firstDepth = (bits & DepthMASK) >> DepthSHIFT;", "-\t\t// iteration on each field\t", "-\t\twhile (index < length) {", "-\t\t\tchar[] token = tokens[index];", "-\t\t\tif (type == null)", "-\t\t\t\treturn null; // could not resolve type prior to this point", "-", "-\t\t\tbits &= ~DepthMASK; // flush previous depth if any\t\t", "-\t\t\tFieldBinding previousField = field;", "-\t\t\tfield = scope.getField(type.capture(scope, (int)this.sourcePositions[index]), token, this);", "-\t\t\tint place = index - indexOfFirstFieldBinding;", "-\t\t\totherBindings[place] = field;", "-\t\t\totherDepths[place] = (bits & DepthMASK) >> DepthSHIFT;", "-\t\t\tif (field.isValidBinding()) {", "-\t\t\t\t// set generic cast of for previous field (if any)", "-\t\t\t\tif (previousField != null) {", "-\t\t\t\t\tTypeBinding fieldReceiverType = type;", "-\t\t\t\t\tTypeBinding receiverErasure = type.erasure();", "-\t\t\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "-\t\t\t\t\t\tif (receiverErasure.findSuperTypeWithSameErasure(field.declaringClass) == null) {", "-\t\t\t\t\t\t\tfieldReceiverType = field.declaringClass; // handle indirect inheritance thru variable secondary bound", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}\t\t\t\t", "-\t\t\t\t\tFieldBinding originalBinding = previousField.original();", "-\t\t\t\t    if ((originalBinding.type.tagBits &  TagBits.HasTypeVariable) != 0 && fieldReceiverType.id != T_JavaLangObject) {", "-\t\t\t\t    \tsetGenericCast(index-1,originalBinding.type.genericCast(fieldReceiverType)); // type cannot be base-type even in boxing case", "-\t\t\t\t    }", "-\t\t\t    }", "-\t\t\t\t// only last field is actually a write access if any", "-\t\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & IsStrictlyAssigned) !=0 && index+1 == length)) {", "-\t\t\t\t\tscope.problemReporter().deprecatedField(field, this);", "-\t\t\t\t}", "-\t\t\t\t// constant propagation can only be performed as long as the previous one is a constant too.", "-\t\t\t\tif (this.constant != Constant.NotAConstant) {", "-\t\t\t\t\tthis.constant = field.constant();\t\t\t\t\t", "-\t\t\t\t}", "-", "-\t\t\t\tif (field.isStatic()) {", "-\t\t\t\t\t// static field accessed through receiver? legal but unoptimal (optional warning)", "-\t\t\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, field);", "-\t\t\t\t\t// indirect static reference ?", "-\t\t\t\t\tif (field.declaringClass != type) {", "-\t\t\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, field);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\ttype = field.type;", "-\t\t\t\tindex++;", "-\t\t\t} else {", "-\t\t\t\tconstant = Constant.NotAConstant; //don't fill other constants slots...", "-\t\t\t\tscope.problemReporter().invalidField(this, field, index, type);", "-\t\t\t\tsetDepth(firstDepth);", "-\t\t\t\treturn null;", "-\t\t\t}", "-\t\t}", "-\t\tsetDepth(firstDepth);", "-\t\ttype = (otherBindings[otherBindingsLength - 1]).type;", "-\t\t// perform capture conversion if read access", "-\t\treturn (type != null && (this.bits & IsStrictlyAssigned) == 0)", "-\t\t\t\t? type.capture(scope, this.sourceEnd)", "-\t\t\t\t: type;\t\t", "-\t}", "+\t\t\tthis.constant = Constant.NotAConstant; //don't fill other constants slots...", "+\t\t\tscope.problemReporter().invalidField(this, field, index, type);", "+\t\t\tsetDepth(firstDepth);", "+\t\t\treturn null;", "+\tsetDepth(firstDepth);", "+\ttype = (this.otherBindings[otherBindingsLength - 1]).type;", "+\t// perform capture conversion if read access", "+\treturn (type != null && (this.bits & ASTNode.IsStrictlyAssigned) == 0)", "+\t\t\t? type.capture(scope, this.sourceEnd)", "+\t\t\t: type;\t\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd711d04e1c04140cac181c8fdfb9da0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "16a26bc49f78acb9a7d0c10a9d6bedce29952111", "commitAfterChange": "e70f557904c0f4a9dab2a8974c294cadedac3b10", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r public TypeBinding getOtherFieldBindings(BlockScope scope)", "signatureAfterChange": "\r \r \tpublic TypeBinding getOtherFieldBindings(BlockScope scope)", "diff": ["-}\r", "-public TypeBinding getOtherFieldBindings(BlockScope scope) {\r", "-\t// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)\r", "-\tif ((bits & FIELD) != 0) {\r", "-\t\tif (!((FieldBinding) binding).isStatic()) { //must check for the static status....\r", "-\t\t\tif (indexOfFirstFieldBinding == 1) {\r", "-\t\t\t\t//the field is the first token of the qualified reference....\r", "-\t\t\t\tif (scope.methodScope().isStatic) {\r", "-\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, (FieldBinding) binding);\r", "+\r", "+\tpublic TypeBinding getOtherFieldBindings(BlockScope scope) {\r", "+\r", "+\t\t// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)\r", "+\t\tif ((bits & FIELD) != 0) {\r", "+\t\t\tif (!((FieldBinding) binding).isStatic()) {\r", "+\t\t\t\t//must check for the static status....\r", "+\t\t\t\tif (indexOfFirstFieldBinding == 1) {\r", "+\t\t\t\t\t//the field is the first token of the qualified reference....\r", "+\t\t\t\t\tif (scope.methodScope().isStatic) {\r", "+\t\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(\r", "+\t\t\t\t\t\t\tthis,\r", "+\t\t\t\t\t\t\t(FieldBinding) binding);\r", "+\t\t\t\t\t\treturn null;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t} else { //accessing to a field using a type as \"receiver\" is allowed only with static field\t\r", "+\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(\r", "+\t\t\t\t\t\tthis,\r", "+\t\t\t\t\t\t(FieldBinding) binding);\r", "-\t\t\t} else { //accessing to a field using a type as \"receiver\" is allowed only with static field\t\r", "-\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, (FieldBinding) binding);\r", "+\t\t\t}\r", "+\t\t\tif (isFieldUseDeprecated((FieldBinding) binding, scope))\r", "+\t\t\t\tscope.problemReporter().deprecatedField((FieldBinding) binding, this);\r", "+\r", "+\t\t\t// if the binding declaring class is not visible, need special action\r", "+\t\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "+\t\t\tFieldBinding fieldBinding = (FieldBinding) binding;\r", "+\t\t\tif (fieldBinding.declaringClass != null\r", "+\t\t\t\t&& fieldBinding.constant == NotAConstant\r", "+\t\t\t\t&& !fieldBinding.declaringClass.canBeSeenBy(scope))\r", "+\t\t\t\tbinding = new FieldBinding(fieldBinding, scope.enclosingSourceType());\r", "+\t\t}\r", "+\r", "+\t\tTypeBinding type = ((VariableBinding) binding).type;\r", "+\t\tint index = indexOfFirstFieldBinding;\r", "+\t\tint length = tokens.length;\r", "+\t\tif (index == length) { //\trestrictiveFlag == FIELD\r", "+\t\t\tconstant =\r", "+\t\t\t\tFieldReference.getConstantFor((FieldBinding) binding, false, this, index - 1);\r", "+\t\t\treturn type;\r", "+\t\t}\r", "+\r", "+\t\t// allocation of the fieldBindings array\tand its respective constants\r", "+\t\tint otherBindingsLength = length - index;\r", "+\t\totherBindings = new FieldBinding[otherBindingsLength];\r", "+\t\totherDepths = new int[otherBindingsLength];\r", "+\t\t\r", "+\t\t// fill the first constant (the one of the binding)\r", "+\t\tconstant =\r", "+\t\t\t((bits & FIELD) != 0)\r", "+\t\t\t\t? FieldReference.getConstantFor((FieldBinding) binding, false, this, index - 1)\r", "+\t\t\t\t: ((VariableBinding) binding).constant;\r", "+\t\t// save first depth, since will be updated by visibility checks of other bindings\r", "+\t\tint firstDepth = (bits & DepthMASK) >> DepthSHIFT;\r", "+\r", "+\t\t// iteration on each field\t\r", "+\t\twhile (index < length) {\r", "+\t\t\tchar[] token = tokens[index];\r", "+\t\t\tif (type == null)\r", "+\t\t\t\treturn null; // could not resolve type prior to this point\r", "+\t\t\tFieldBinding field = scope.getField(type, token, this);\r", "+\t\t\tint place = index - indexOfFirstFieldBinding;\r", "+\t\t\totherBindings[place] = field;\r", "+\t\t\totherDepths[place] = (bits & DepthMASK) >> DepthSHIFT;\r", "+\t\t\tif (field.isValidBinding()) {\r", "+\t\t\t\tif (isFieldUseDeprecated(field, scope))\r", "+\t\t\t\t\tscope.problemReporter().deprecatedField(field, this);\r", "+\t\t\t\tConstant someConstant =\r", "+\t\t\t\t\tFieldReference.getConstantFor(field, false, this, place);\r", "+\t\t\t\t// constant propagation can only be performed as long as the previous one is a constant too.\r", "+\t\t\t\tif (constant != NotAConstant) {\r", "+\t\t\t\t\tconstant = someConstant;\r", "+\t\t\t\t}\r", "+\t\t\t\t// if the binding declaring class is not visible, need special action\r", "+\t\t\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "+\t\t\t\tif (field.declaringClass != type\r", "+\t\t\t\t\t&& field.declaringClass != null // array.length\r", "+\t\t\t\t\t&& field.constant == NotAConstant\r", "+\t\t\t\t\t&& !field.declaringClass.canBeSeenBy(scope))\r", "+\t\t\t\t\totherBindings[place] = new FieldBinding(field, (ReferenceBinding) type);\r", "+\t\t\t\ttype = field.type;\r", "+\t\t\t\tindex++;\r", "+\t\t\t} else {\r", "+\t\t\t\tconstant = NotAConstant; //don't fill other constants slots...\r", "+\t\t\t\tscope.problemReporter().invalidField(this, field, index, type);\r", "+\t\t\t\tsetDepth(firstDepth);\r", "-\t\tif (isFieldUseDeprecated((FieldBinding) binding, scope))\r", "-\t\t\tscope.problemReporter().deprecatedField((FieldBinding) binding, this);\r", "-\r", "-\t\t// if the binding declaring class is not visible, need special action\r", "-\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "-\t\tFieldBinding fieldBinding = (FieldBinding)binding;\r", "-\t\tif (fieldBinding.declaringClass != null\r", "-\t\t\t&& fieldBinding.constant == NotAConstant\r", "-\t\t\t&& !fieldBinding.declaringClass.canBeSeenBy(scope))\r", "-\t\t\t\tbinding = new FieldBinding(fieldBinding, scope.enclosingSourceType());\r", "+\t\tsetDepth(firstDepth);\r", "+\t\treturn (otherBindings[otherBindingsLength - 1]).type;\r", "-\tTypeBinding type = ((VariableBinding) binding).type;\r", "-\tint index = indexOfFirstFieldBinding;\r", "-\tint length = tokens.length;\r", "-\tif (index == length) { //\trestrictiveFlag == FIELD\r", "-\t\tconstant = FieldReference.getConstantFor((FieldBinding) binding, false, this, index - 1);\r", "-\t\treturn type;\r", "-\t}\r", "-\t// allocation of the fieldBindings array\tand its respective constants\r", "-\tint otherBindingsLength = length - index;\r", "-\totherBindings = new FieldBinding[otherBindingsLength];\r", "-\t\r", "-\t// fill the first constant (the one of the binding)\r", "-\tconstant =\r", "-\t\t((bits & FIELD) != 0)\r", "-\t\t\t? FieldReference.getConstantFor((FieldBinding) binding, false, this, index - 1)\r", "-\t\t\t: ((VariableBinding) binding).constant;\r", "-\r", "-\t// iteration on each field\t\r", "-\twhile (index < length) {\r", "-\t\tchar[] token = tokens[index];\r", "-\t\tif (type == null) return null; // could not resolve type prior to this point\r", "-\t\tFieldBinding field = scope.getField(type, token, this);\r", "-\t\tint place = index - indexOfFirstFieldBinding;\r", "-\t\totherBindings[place] = field;\r", "-\t\tif (field.isValidBinding()) {\r", "-\t\t\tif (isFieldUseDeprecated(field, scope))\r", "-\t\t\t\tscope.problemReporter().deprecatedField(field, this);\r", "-\t\t\tConstant someConstant = FieldReference.getConstantFor(field, false, this, place);\r", "-\t\t\t// constant propagation can only be performed as long as the previous one is a constant too.\r", "-\t\t\tif (constant != NotAConstant){\r", "-\t\t\t\tconstant = someConstant;\r", "-\t\t\t}\r", "-\t\t\t// if the binding declaring class is not visible, need special action\r", "-\t\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "-\t\t\tif (field.declaringClass != type\r", "-\t\t\t\t&& field.declaringClass != null // array.length\r", "-\t\t\t\t&& field.constant == NotAConstant\r", "-\t\t\t\t&& !field.declaringClass.canBeSeenBy(scope))\r", "-\t\t\t\t\totherBindings[place] = new FieldBinding(field, (ReferenceBinding)type);\r", "-\t\t\ttype = field.type;\r", "-\t\t\tindex++;\r", "-\t\t} else {\r", "-\t\t\tconstant = NotAConstant; //don't fill other constants slots...\r", "-\t\t\tscope.problemReporter().invalidField(this, field, index, type);\r", "-\t\t\treturn null;\r", "-\t}\r", "-\treturn (otherBindings[otherBindingsLength - 1]).type;\r", "-}\r"]}], "num": 32196}