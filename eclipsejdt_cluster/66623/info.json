{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "577083c3dd466d9c6bb92661e95fb7cc", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b59bd4964561b5512c2474fc8d44156", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "9275c96ab9e7e5e5f780672ec67bf57a1eb2d42e", "commitAfterChange": "437ac0488c92b5c24e88567c6caa0b204b0064ba", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 29, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-\t\t\t\t\t\t\tif (methodDecl == null) {", "-\t\t\t\t\t\t\t\tmethodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost", "-\t\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, methodDecl);", "-\t\t\t\t\t\t\t\tmethodDecl.binding = null;", "-\t\t\t\t\t\t\t\tmethods[i] = null;", "-\t\t\t\t\t\t\t\tfailed++;", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (methodDecl == null) \tmethodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost", "-\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, method2Decl);", "-\t\t\t\t\t\t\tmethod2Decl.binding = null;", "-\t\t\t\t\t\t\tmethods[j] = null;", "-\t\t\t\t\t\t\tfailed++;", "+\t\t\t\t\t\t\t// could collide with special methods for enumerations", "+\t\t\t\t\t\t\tif (methodDecl == null) {", "+\t\t\t\t\t\t\t\tif (method.selector == TypeConstants.VALUEOF", "+\t\t\t\t\t\t\t\t\t\t|| method.selector == TypeConstants.VALUES) {", "+\t\t\t\t\t\t\t\t\tif (method2Decl != null) {", "+\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, method2Decl);", "+\t\t\t\t\t\t\t\t\t\tmethod2Decl.binding = null;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// leave enum special method to minimize secondary error (further references to it)", "+\t\t\t\t\t\t\t\t\tmethods[j] = null;", "+\t\t\t\t\t\t\t\t\tfailed++;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if (method2Decl == null) {", "+\t\t\t\t\t\t\t\tif (method2.selector == TypeConstants.VALUEOF", "+\t\t\t\t\t\t\t\t\t\t|| method2.selector == TypeConstants.VALUES) {", "+\t\t\t\t\t\t\t\t\tif (methodDecl != null) {", "+\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, methodDecl);", "+\t\t\t\t\t\t\t\t\t\tmethodDecl.binding = null;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// leave enum special method to minimize secondary error (further references to it)", "+\t\t\t\t\t\t\t\t\tmethods[i] = null;", "+\t\t\t\t\t\t\t\t\tfailed++;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (methodDecl.binding != null) {", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, methodDecl);", "+\t\t\t\t\t\t\t\t\tmethodDecl.binding = null;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (method2Decl != null) {", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, method2Decl);", "+\t\t\t\t\t\t\t\t\tmethod2Decl.binding = null;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tmethods[i] = null;", "+\t\t\t\t\t\t\t\tmethods[j] = null;", "+\t\t\t\t\t\t\t\tfailed+=2;", "+\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c36eb46c95523904f99e2d8074438e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "a2ae3e117eaea10fecaf3678af5938ffa98d76f4", "commitAfterChange": "71ab6b3956db9fea4a8f81e891e05ac4d44d96d9", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "\r public int literalIndex(MethodBinding aMethodBinding)", "signatureAfterChange": "\r public int literalIndex(MethodBinding aMethodBinding)", "diff": ["+\t\t\t\tif (index > 0xFFFF){\r", "+\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());\r", "+\t\t\t\t}\r", "+\t\t\t\tif (index > 0xFFFF){\r", "+\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());\r", "+\t\t\t\t}\r", "+\t\t\t\tif (index > 0xFFFF){\r", "+\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());\r", "+\t\t\t\t}\r", "+\t\t\t\tif (index > 0xFFFF){\r", "+\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());\r", "+\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c5dc265191a548d953df3859a84b72b9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "7cc5105214055493937549b61fac95d343064ee5", "commitAfterChange": "7568a4350d418633b0b504fd95408219cea387db", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 24, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) this.binding;", "-\t\t\t\t\tif (!local.isFinal() && ((this.bits & ASTNode.DepthMASK) != 0))", "-\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal((LocalVariableBinding) this.binding, this);", "+\t\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) this.binding;", "+\t\t\t\t\tif (!local.isFinal() && ((this.bits & ASTNode.DepthMASK) != 0)) {", "+\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal((LocalVariableBinding) this.binding, this);", "+\t\t\t\t\t}", "-\t\t\t\t\tif (this.resolvedType != null", "-\t\t\t\t\t\t\t&& (this.resolvedType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\tif (this.resolvedType != null && (this.resolvedType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\tthis.bits &= ~ASTNode.RestrictiveFlagMASK; // clear bits", "+\t\t\t\t\tthis.bits |= Binding.FIELD;", "+\t\t\t\t\tReferenceBinding declaringClass = fieldBinding.original().declaringClass;", "+\t\t\t\t\tSourceTypeBinding sourceType = methodScope.enclosingSourceType();", "-\t\t\t\t\tif (this.indexOfFirstFieldBinding == 1", "-\t\t\t\t\t\t\t&& methodScope.enclosingSourceType() == fieldBinding.original().declaringClass", "+\t\t\t\t\tif ((this.indexOfFirstFieldBinding == 1 || declaringClass.isEnum())", "+\t\t\t\t\t\t\t&& sourceType == declaringClass", "-\t\t\t\t\t\tscope.problemReporter().forwardReference(this, 0, methodScope.enclosingSourceType());", "+\t\t\t\t\t\tscope.problemReporter().forwardReference(this, this.indexOfFirstFieldBinding-1, fieldBinding);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (isFieldUseDeprecated(fieldBinding, scope, (this.bits & ASTNode.IsStrictlyAssigned) != 0 && this.indexOfFirstFieldBinding == this.tokens.length)) {", "+\t\t\t\t\t\tscope.problemReporter().deprecatedField(fieldBinding, this);\t", "-\t\t\t\t\t\tReferenceBinding declaringClass = fieldBinding.declaringClass;", "+\t\t\t\t\t\t// only last field is actually a write access if any", "-\t\t\t\t\t\t\tSourceTypeBinding sourceType = methodScope.enclosingSourceType();", "-\t\t\t\t\t} else if (this.indexOfFirstFieldBinding == 1 && scope.compilerOptions().getSeverity(CompilerOptions.UnqualifiedFieldAccess) != ProblemSeverities.Ignore) {", "-\t\t\t\t\t\tscope.problemReporter().unqualifiedFieldAccess(this, fieldBinding);", "+\t\t\t\t\t\tif (this.indexOfFirstFieldBinding > 1", "+\t\t\t\t\t\t\t\t&& fieldBinding.declaringClass != this.actualReceiverType", "+\t\t\t\t\t\t\t\t&& fieldBinding.declaringClass.canBeSeenBy(scope)) {", "+\t\t\t\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, fieldBinding);", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (this.indexOfFirstFieldBinding == 1 && scope.compilerOptions().getSeverity(CompilerOptions.UnqualifiedFieldAccess) != ProblemSeverities.Ignore) {", "+\t\t\t\t\t\t\tscope.problemReporter().unqualifiedFieldAccess(this, fieldBinding);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t//must check for the static status....", "+\t\t\t\t\t\tif (this.indexOfFirstFieldBinding > 1  //accessing to a field using a type as \"receiver\" is allowed only with static field", "+\t\t\t\t\t\t\t\t || scope.methodScope().isStatic) { \t// the field is the first token of the qualified reference....", "+\t\t\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, fieldBinding);", "+\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t\t }", "-\t\t\t\t\tthis.bits &= ~ASTNode.RestrictiveFlagMASK; // clear bits", "-\t\t\t\t\tthis.bits |= Binding.FIELD;", "-", "-//\t\t\t\t\t\t// check for deprecated receiver type", "-//\t\t\t\t\t\t// deprecation check for receiver type if not first token", "-//\t\t\t\t\t\tif (indexOfFirstFieldBinding > 1) {", "-//\t\t\t\t\t\t\tif (isTypeUseDeprecated(this.actualReceiverType, scope))", "-//\t\t\t\t\t\t\t\tscope.problemReporter().deprecatedType(this.actualReceiverType, this);", "-//\t\t\t\t\t\t}", "+\t\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c85b0ea158790a735ad031536aadcb30", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "9275c96ab9e7e5e5f780672ec67bf57a1eb2d42e", "commitAfterChange": "437ac0488c92b5c24e88567c6caa0b204b0064ba", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 19, "signatureBeforeChange": " public int literalIndexForJavaLangLong()", "signatureAfterChange": " public int literalIndexForMethod(char[] declaringClass, char[] selector, char[] signature, boolean isInterface)", "diff": ["+}", "+public int literalIndexForMethod(char[] declaringClass, char[] selector, char[] signature, boolean isInterface) {", "+\tint index = getFromCache(declaringClass, selector, signature);", "+\tif (index == -1) {", "+\t\tint classIndex;", "+\t\tif ((classIndex = classCache.get(declaringClass)) < 0) {", "+\t\t\tint nameIndex = literalIndex(declaringClass);", "+\t\t\tclassIndex = classCache.put(declaringClass, this.currentIndex++);", "+\t\tint nameAndTypeIndex = literalIndexForMethod(selector, signature);", "+\t\tindex = putInCache(declaringClass, selector, signature, currentIndex++);", "+\t\tif (index > 0xFFFF){", "+\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+\t\t}", "+\t\t// Write the interface method ref constant into the constant pool", "+\t\t// First add the tag", "+\t\twriteU1(isInterface ? InterfaceMethodRefTag : MethodRefTag);", "+\t\t// Then write the class index", "+\t\twriteU2(classIndex);", "+\t\t// The write the nameAndType index", "+\t\twriteU2(nameAndTypeIndex);\t\t", "+\t}", "+\treturn index;", "+}", "- */", "-public int literalIndexForJavaLangLong() {", "-\tint index;", "-\tif ((index = wellKnownTypes[JAVA_LANG_LONG_TYPE]) == 0) {", "-\t\tint nameIndex;", "-\t\t// The entry doesn't exit yet", "-\t\tnameIndex = literalIndex(QualifiedNamesConstants.JavaLangLongConstantPoolName);", "-\t\tindex = wellKnownTypes[JAVA_LANG_LONG_TYPE] = currentIndex++;", "-\t\tif (index > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\twriteU1(ClassTag);", "-\t\t// Then add the 8 bytes representing the long", "-\t\twriteU2(nameIndex);", "-\t}", "-\treturn index;", "-}"]}], "num": 66623}