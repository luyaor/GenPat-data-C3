{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "974599030b2af85e32f0733ee5c8c2c8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6647ad8442d5b7edec57821456e70773", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/BatchASTCreationTests.java", "commitBeforeChange": "a1fa0960e8bf8c2d86b0b4556cf5470457cb514c", "commitAfterChange": "0ea38f06cd1227fc139bddac2eec897cb8fbed35", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate void assertRequestedBindingFound(final MarkerInfo[] markerInfos, final String expectedKey) throws JavaModelException", "signatureAfterChange": " \tprivate void assertRequestedBindingFound(String[] pathAndSources, final String expectedKey) throws JavaModelException", "diff": ["-\tprivate void assertRequestedBindingFound(final MarkerInfo[] markerInfos, final String expectedKey) throws JavaModelException {", "-\t\tICompilationUnit[] workingCopies;", "-\t\tworkingCopies = createWorkingCopies(markerInfos);", "-\t\tclass Requestor extends TestASTRequestor {", "-\t\t\tString bindingKey;", "-\t\t\tint index = -1;", "-\t\t\tString foundKey;", "-\t\t\tpublic void acceptAST(CompilationUnit cu, ICompilationUnit source) {", "-\t\t\t\tsuper.acceptAST(cu, source);", "-\t\t\t\tASTNode node = findNode(cu, markerInfos[++this.index]);", "-\t\t\t\tif (node != null) {", "-\t\t\t\t\tIBinding binding = null;", "-\t\t\t\t\tif (node instanceof PackageDeclaration) {", "-\t\t\t\t\t\tbinding = ((PackageDeclaration) node).resolveBinding();", "-\t\t\t\t\t} else if (node instanceof TypeDeclaration) {", "-\t\t\t\t\t\tbinding = ((TypeDeclaration) node).resolveBinding();", "-\t\t\t\t\t} else if (node instanceof AnonymousClassDeclaration) {", "-\t\t\t\t\t\tbinding = ((AnonymousClassDeclaration) node).resolveBinding();", "-\t\t\t\t\t} else if (node instanceof TypeDeclarationStatement) {", "-\t\t\t\t\t\tbinding = ((TypeDeclarationStatement) node).resolveBinding();", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.bindingKey = binding == null ? null : binding.getKey();", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tpublic void acceptBinding(IBinding binding, String key) {", "-\t\t\t\tsuper.acceptBinding(binding, key);", "-\t\t\t\tthis.foundKey = binding.getKey();", "-\t\t\t}", "-\t\t};", "-\t\tRequestor requestor = new Requestor();", "-\t\tresolveASTs(workingCopies, new String[] {expectedKey}, requestor);", "-\t\t", "-\t\tif (!expectedKey.equals(requestor.bindingKey))", "-\t\t\tSystem.out.println(Util.displayString(expectedKey, 3));", "-\t\tassertEquals(\"Unexpected binding for marked node\", expectedKey, requestor.bindingKey);", "-\t\t", "-\t\tif (!expectedKey.equals(requestor.foundKey)) {", "-\t\t\tSystem.out.println(Util.displayString(requestor.foundKey, 3));", "-\t\t}", "-\t\tassertEquals(\"Unexpected binding found by acceptBinding\", expectedKey, requestor.foundKey);", "-\t}", "+\tprivate void assertRequestedBindingFound(String[] pathAndSources, final String expectedKey) throws JavaModelException {", "+\t\t\tfinal MarkerInfo[] markerInfos = createMarkerInfos(pathAndSources);", "+\t\t\tworkingCopies = createWorkingCopies(markerInfos);", "+\t\t\tclass Requestor extends TestASTRequestor {", "+\t\t\t\tString bindingKey;", "+\t\t\t\tint index = -1;", "+\t\t\t\tString foundKey;", "+\t\t\t\tpublic void acceptAST(CompilationUnit cu, ICompilationUnit source) {", "+\t\t\t\t\tsuper.acceptAST(cu, source);", "+\t\t\t\t\tASTNode node = findNode(cu, markerInfos[++this.index]);", "+\t\t\t\t\tif (node != null) {", "+\t\t\t\t\t\tIBinding binding = null;", "+\t\t\t\t\t\tif (node instanceof PackageDeclaration) {", "+\t\t\t\t\t\t\tbinding = ((PackageDeclaration) node).resolveBinding();", "+\t\t\t\t\t\t} else if (node instanceof TypeDeclaration) {", "+\t\t\t\t\t\t\tbinding = ((TypeDeclaration) node).resolveBinding();", "+\t\t\t\t\t\t} else if (node instanceof AnonymousClassDeclaration) {", "+\t\t\t\t\t\t\tbinding = ((AnonymousClassDeclaration) node).resolveBinding();", "+\t\t\t\t\t\t} else if (node instanceof TypeDeclarationStatement) {", "+\t\t\t\t\t\t\tbinding = ((TypeDeclarationStatement) node).resolveBinding();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.bindingKey = binding == null ? null : binding.getKey();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tpublic void acceptBinding(IBinding binding, String key) {", "+\t\t\t\t\tsuper.acceptBinding(binding, key);", "+\t\t\t\t\tthis.foundKey = binding.getKey();", "+\t\t\t\t}", "+\t\t\t};", "+\t\t\tRequestor requestor = new Requestor();", "+\t\t\tresolveASTs(workingCopies, new String[] {expectedKey}, requestor);", "+\t\t\t", "+\t\t\tif (!expectedKey.equals(requestor.bindingKey))", "+\t\t\t\tSystem.out.println(Util.displayString(expectedKey, 3));", "+\t\t\tassertEquals(\"Unexpected binding for marked node\", expectedKey, requestor.bindingKey);", "+\t\t\t", "+\t\t\tif (!expectedKey.equals(requestor.foundKey)) {", "+\t\t\t\tSystem.out.println(Util.displayString(requestor.foundKey, 3));", "+\t\t\t}", "+\t\t\tassertEquals(\"Unexpected binding found by acceptBinding\", expectedKey, requestor.foundKey);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fda884a5a0a56bef341761c34f5f8862", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "b7f88e87f49f0610756dfbedb8e57185924f0ebb", "commitAfterChange": "386549a68b724ddc22b4fffcf50fe779bbe728e1", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " protected void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "signatureAfterChange": " protected void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "diff": ["+\t", "-", "-\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "-\tboolean bindingsWereCreated = true;", "-\t\tfor (int i = start, maxUnits = start + length; i < maxUnits; i++)", "-\t\t\tbuildBindings(potentialMatches[i]);", "-\t\tlookupEnvironment.completeTypeBindings();", "-", "-\t\t// create hierarchy resolver if needed", "-\t\tIType focusType = getFocusType();", "-\t\tif (focusType == null) {", "-\t\t\tthis.hierarchyResolver = null;", "-\t\t} else if (!createHierarchyResolver(focusType, potentialMatches)) {", "-\t\t\t// focus type is not visible, use the super type names instead of the bindings", "-\t\t\tif (computeSuperTypeNames(focusType) == null) return;", "-\t\t}", "-\t} catch (AbortCompilation e) {", "-\t\tbindingsWereCreated = false;", "-\t}", "-", "-\t// potential match resolution", "-\tfor (int i = 0; i < this.numberOfMatches; i++) {", "-\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "-\t\t\tthrow new OperationCanceledException();", "-\t\tPotentialMatch potentialMatch = this.matchesToProcess[i];", "-\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "+\t\tthis.nameLookup.setUnitsToLookInside(this.workingCopies);", "+\t", "+\t\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "+\t\tboolean bindingsWereCreated = true;", "-\t\t\tprocess(potentialMatch, bindingsWereCreated);", "+\t\t\tfor (int i = start, maxUnits = start + length; i < maxUnits; i++)", "+\t\t\t\tbuildBindings(potentialMatches[i]);", "+\t\t\tlookupEnvironment.completeTypeBindings();", "+\t", "+\t\t\t// create hierarchy resolver if needed", "+\t\t\tIType focusType = getFocusType();", "+\t\t\tif (focusType == null) {", "+\t\t\t\tthis.hierarchyResolver = null;", "+\t\t\t} else if (!createHierarchyResolver(focusType, potentialMatches)) {", "+\t\t\t\t// focus type is not visible, use the super type names instead of the bindings", "+\t\t\t\tif (computeSuperTypeNames(focusType) == null) return;", "+\t\t\t}", "-\t\t\t// problem with class path: it could not find base classes", "-\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t} catch (JavaModelException e) {", "-\t\t\t// problem with class path: it could not find base classes", "-\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\tbindingsWereCreated = false;", "-\t\t} catch (CoreException e) {", "-\t\t\t// core exception thrown by client's code: let it through", "-\t\t\tthrow new JavaModelException(e);", "-\t\t} finally {", "-\t\t\tif (this.options.verbose)", "-\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "-\t\t\t\t\tnew String[] {", "-\t\t\t\t\t\tString.valueOf(i + 1),", "-\t\t\t\t\t\tString.valueOf(numberOfMatches),", "-\t\t\t\t\t\tnew String(potentialMatch.parsedUnit.getFileName())}));", "-\t\t\t// cleanup compilation unit result", "-\t\t\tpotentialMatch.parsedUnit.cleanUp();", "-\t\t\tpotentialMatch.parsedUnit = null;", "-\t\tif (this.progressMonitor != null)", "-\t\t\tthis.progressMonitor.worked(5);", "+\t", "+\t\t// potential match resolution", "+\t\tfor (int i = 0; i < this.numberOfMatches; i++) {", "+\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "+\t\t\t\tthrow new OperationCanceledException();", "+\t\t\tPotentialMatch potentialMatch = this.matchesToProcess[i];", "+\t\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "+\t\t\ttry {", "+\t\t\t\tprocess(potentialMatch, bindingsWereCreated);", "+\t\t\t} catch (AbortCompilation e) {", "+\t\t\t\t// problem with class path: it could not find base classes", "+\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\t\tbindingsWereCreated = false;", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// problem with class path: it could not find base classes", "+\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\t\tbindingsWereCreated = false;", "+\t\t\t} catch (CoreException e) {", "+\t\t\t\t// core exception thrown by client's code: let it through", "+\t\t\t\tthrow new JavaModelException(e);", "+\t\t\t} finally {", "+\t\t\t\tif (this.options.verbose)", "+\t\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "+\t\t\t\t\t\tnew String[] {", "+\t\t\t\t\t\t\tString.valueOf(i + 1),", "+\t\t\t\t\t\t\tString.valueOf(numberOfMatches),", "+\t\t\t\t\t\t\tnew String(potentialMatch.parsedUnit.getFileName())}));", "+\t\t\t\t// cleanup compilation unit result", "+\t\t\t\tpotentialMatch.parsedUnit.cleanUp();", "+\t\t\t\tpotentialMatch.parsedUnit = null;", "+\t\t\t}", "+\t\t\tif (this.progressMonitor != null)", "+\t\t\t\tthis.progressMonitor.worked(5);", "+\t\t}", "+\t} finally {", "+\t\tthis.nameLookup.setUnitsToLookInside(null);"]}], "num": 41322}