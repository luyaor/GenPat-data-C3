{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f1f61efec2d44076bbbf8ba4b1a719c8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "27d6b9aebed547749258ef0b6ac5674c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "6cd0099c2021e34815eaba987a586ae52dacf569", "commitAfterChange": "d6dc74869d8c303dbb7a6d8b327d8b104cd5865b", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(TypeBinding left, final Scope someScope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(TypeBinding targetType, final Scope skope)", "diff": ["-\tpublic boolean isCompatibleWith(TypeBinding left, final Scope someScope) {", "-\t\tif (!(left instanceof ReferenceBinding))", "-\t\t\treturn false;", "-", "-\t\tshapeAnalysis: if (!this.shapeAnalysisComplete) {", "-\t\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "-\t\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "-\t\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "-\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "-\t\t\ttry {", "-\t\t\t\tfinal LambdaExpression copy = copy();", "-\t\t\t\tif (copy == null) {", "-\t\t\t\t\tif (this.assistNode) {", "-\t\t\t\t\t\tanalyzeShape(); // not on terra firma here !", "-\t\t\t\t\t\tbreak shapeAnalysis;", "-\t\t\t\t\t}", "-\t\t\t\t\treturn !isPertinentToApplicability(left, null);", "-\t\t\t\t}", "-\t\t\t\tcopy.setExpressionContext(this.expressionContext);", "-\t\t\t\tcopy.setExpectedType(left);", "-\t\t\t\tthis.hasIgnoredMandatoryErrors = false;", "-\t\t\t\tTypeBinding type = copy.resolveType(this.enclosingScope);", "-\t\t\t\tif (type == null || !type.isValidBinding())", "-\t\t\t\t\treturn false;", "-\t\t\t\tif (this.body instanceof Block) {", "-\t\t\t\t\tif (this.returnsVoid) {", "-\t\t\t\t\t\tthis.shapeAnalysisComplete = true;", "-\t\t\t\t\t\tbreak shapeAnalysis;", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tfinal Expression expressionBody = (Expression) copy.body;", "-\t\t\t\t\tthis.voidCompatible = this.assistNode ? true : expressionBody.statementExpression();", "-\t\t\t\t\tthis.valueCompatible = expressionBody.resolvedType != TypeBinding.VOID;", "-\t\t\t\t\tthis.shapeAnalysisComplete = true;", "-\t\t\t\t\tbreak shapeAnalysis;", "-\t\t\t\t}", "-\t\t\t\t// Do not proceed with data/control flow analysis if resolve encountered errors.", "-\t\t\t\tif (this.hasIgnoredMandatoryErrors || enclosingScopesHaveErrors()) {", "-\t\t\t\t\tif (!isPertinentToApplicability(left, null))", "-\t\t\t\t\t\tbreak shapeAnalysis;", "-\t\t\t\t\tif (this.arguments.length != 0) // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\tbreak shapeAnalysis;", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\t// value compatibility of block lambda's is the only open question.", "-\t\t\t\tif (!this.shapeAnalysisComplete)", "-\t\t\t\t\tthis.valueCompatible = copy.doesNotCompleteNormally();", "-\t\t\t\t", "-\t\t\t\tthis.shapeAnalysisComplete = true;", "-\t\t\t} finally {", "-\t\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;", "-\t\t\t\tthis.hasIgnoredMandatoryErrors = false;", "-\t\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t\t\t}", "+\tpublic boolean isCompatibleWith(TypeBinding targetType, final Scope skope) {", "+\t\t", "+\t\tif (!super.isPertinentToApplicability(targetType, null))", "+\t\t\treturn true;", "+\t\t", "+\t\tLambdaExpression copy = null;", "+\t\ttry {", "+\t\t\tcopy = cachedResolvedCopy(targetType);", "+\t\t} catch (CopyFailureException cfe) {", "+\t\t\tif (this.assistNode)", "+\t\t\t\treturn true; // can't type check result expressions, just say yes.", "+\t\t\treturn !isPertinentToApplicability(targetType, null); // don't expect to hit this ever.", "-", "-\t\tReferenceBinding expectedSAMType = null;", "-\t\tif (left instanceof IntersectionTypeBinding18)", "-\t\t\texpectedSAMType = (ReferenceBinding) ((IntersectionTypeBinding18) left).getSAMType(this.enclosingScope); ", "-\t\telse if (left instanceof ReferenceBinding)", "-\t\t\texpectedSAMType = (ReferenceBinding) left;", "-\t\tReferenceBinding groundTargetType = expectedSAMType != null ? findGroundTargetType(this.enclosingScope, expectedSAMType, argumentsTypeElided()) : null;", "-\t\tif (groundTargetType == null)", "+\t\tif (copy == null)", "-\t\tMethodBinding sam = groundTargetType.getSingleAbstractMethod(this.enclosingScope, true);", "-\t\tif (sam == null || !sam.isValidBinding())", "-\t\t\treturn false;", "-\t\tif (sam.parameters.length != this.arguments.length)", "-\t\t\treturn false;", "-", "-\t\tif (sam.returnType.id == TypeIds.T_void) {", "-\t\t\tif (!this.voidCompatible)", "-\t\t\t\treturn false;", "-\t\t} else {", "-\t\t\tif (!this.valueCompatible)", "-\t\t\t\treturn false;", "-\t\t}", "-", "-\t\tif (!isPertinentToApplicability(left, null))", "-\t\t\treturn true;", "-", "-\t\tExpression [] returnExpressions = this.resultExpressions;", "-\t\tfor (int i = 0, length = returnExpressions.length; i < length; i++) {", "-\t\t\tif (returnExpressions[i] instanceof FunctionalExpression) { // don't want to use the resolvedType - polluted from some other overload resolution candidate", "-\t\t\t\tif (!returnExpressions[i].isCompatibleWith(sam.returnType, this.enclosingScope))", "-\t\t\t\t\treturn false;", "-\t\t\t} else {", "-\t\t\t\tif (this.enclosingScope.parameterCompatibilityLevel(returnExpressions[i].resolvedType, sam.returnType) == Scope.NOT_COMPATIBLE) {", "-\t\t\t\t\tif (!returnExpressions[i].isConstantValueOfTypeAssignableToType(returnExpressions[i].resolvedType, sam.returnType))", "-\t\t\t\t\t\tif (sam.returnType.id != TypeIds.T_void || this.body instanceof Block)", "+\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "+\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "+\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "+\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "+\t\ttry {", "+\t\t\t/* At this point, shape analysis is complete for ((see returnsExpression(...))", "+\t\t\t       - a lambda with an expression body,", "+\t\t\t\t   - a lambda with a block body in which we saw a return statement naked or otherwise.", "+\t\t\t*/", "+\t\t\tif (copy.body instanceof Block && !copy.returnsVoid && !copy.returnsValue && !copy.valueCompatible) {", "+\t\t\t\t// Do not proceed with data/control flow analysis if resolve encountered errors.", "+\t\t\t\tif (copy.hasIgnoredMandatoryErrors || enclosingScopesHaveErrors()) {", "+\t\t\t\t\tif (isPertinentToApplicability(targetType, null))", "+\t\t\t\t\t\tif (copy.arguments.length != 0) // ?? Needs check. ", "+\t\t\t\t} else {", "+\t\t\t\t\tcopy.valueCompatible = copy.doesNotCompleteNormally();", "+\t\t} finally {", "+\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;", "+\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t", "-\t\tTypeBinding [] samPararameterTypes = sam.parameters;", "-\t\tfor (int i = 0, length = samPararameterTypes.length; i < length; i++) { // lengths known to be equal.", "-\t\t\tif (TypeBinding.notEquals(samPararameterTypes[i], this.argumentTypes[i]))", "+", "+\t\ttargetType = findGroundTargetType(this.enclosingScope, targetType, argumentsTypeElided());", "+\t\tMethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true);", "+\t\tif (sam.returnType.id == TypeIds.T_void) {", "+\t\t\tif (!copy.voidCompatible)", "+\t\t\t\treturn false;", "+\t\t} else {", "+\t\t\tif (!copy.valueCompatible)", "+\t\tif (!isPertinentToApplicability(targetType, null))", "+\t\t\treturn true;", "+", "+\t\tExpression [] returnExpressions = copy.resultExpressions;", "+\t\tfor (int i = 0, length = returnExpressions.length; i < length; i++) {", "+\t\t\tif (this.enclosingScope.parameterCompatibilityLevel(returnExpressions[i].resolvedType, sam.returnType) == Scope.NOT_COMPATIBLE) {", "+\t\t\t\tif (!returnExpressions[i].isConstantValueOfTypeAssignableToType(returnExpressions[i].resolvedType, sam.returnType))", "+\t\t\t\t\tif (sam.returnType.id != TypeIds.T_void || this.body instanceof Block)", "+\t\t\t\t\t\treturn false;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2e7e21b57e5fbbfe418a4e23ff94cdd4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "31225f931c10340b8616c3f4ecc6725f368df84c", "commitAfterChange": "86bc6fbd8bb61b3353c5beacb63fca5b9ddef84a", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": "  \tprivate int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site)", "signatureAfterChange": "  \tprivate int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site)", "diff": ["-\t\tif (site instanceof Invocation) {", "+\t\tjdk18checks:", "+\t\tif (site instanceof Invocation && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_8) {", "-\t\t\t\tboolean isVarArgs = argLen != method.parameters.length; // if same lengths, isVarArgs can still be updated below", "+\t\t\t\tboolean isVarArgs[] = new boolean[1]; // emulate an in-out parameter for compatibilityLevel18FromInner(..)", "+\t\t\t\tisVarArgs[0] = method.isVarargs() && argLen != method.parameters.length; // if same lengths, isVarArgs can still be updated below", "+\t\t\t\tint level = COMPATIBLE;", "-\t\t\t\t\tExpression invocArg = invocationArguments[i];", "-\t\t\t\t\tif (invocArg instanceof Invocation && invocArg.resolvedType != null) { // TODO any poly? ReferenceExpression?", "-\t\t\t\t\t\tInvocation innerPoly = (Invocation) invocArg;", "-\t\t\t\t\t\tTypeBinding resolvedType = invocArg.resolvedType;", "-\t\t\t\t\t\tTypeBinding targetType = InferenceContext18.getParameter(method.parameters, i, isVarArgs);", "-\t\t\t\t\t\tif (!isVarArgs && shouldTryVarargs(method, resolvedType, targetType)) {", "-\t\t\t\t\t\t\tisVarArgs = true;", "-\t\t\t\t\t\t\ttargetType = InferenceContext18.getParameter(method.parameters, i, true);", "+\t\t\t\t\tint nextLevel = compatibilityLevel18FromInner(method, innerInferenceHelper, invocationArguments[i], argLen, i, isVarArgs);", "+\t\t\t\t\tif (nextLevel == NOT_COMPATIBLE)", "+\t\t\t\t\t\treturn nextLevel;", "+\t\t\t\t\tif (nextLevel == -2)", "+\t\t\t\t\t\tbreak jdk18checks;", "+\t\t\t\t\tlevel = Math.max(level,  nextLevel);", "+\t\t\t\t}", "+\t\t\t\treturn level; // neither NOT_COMPATIBLE nor unknown(-2) seen", "+\t\t\t}", "+\t\t}", "+\t\t// fall back to old method:", "+\t\treturn parameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods);", "+\t}", "-\t\t\t\t\t\tif (!resolvedType.isCompatibleWith(targetType, this)) {", "-\t\t\t\t\t\t\tMethodBinding innerBinding = innerPoly.binding(null); // 1. try without update", "-\t\t\t\t\t\t\tif (innerBinding instanceof ParameterizedGenericMethodBinding) {", "-\t\t\t\t\t\t\t\tParameterizedGenericMethodBinding innerParameterized = (ParameterizedGenericMethodBinding) innerBinding;", "-\t\t\t\t\t\t\t\tInferenceContext18 infCtx18 = innerPoly.getInferenceContext(innerParameterized);", "-\t\t\t\t\t\t\t\tif (infCtx18 != null && !infCtx18.hasResultFor(targetType)) {", "-\t\t\t\t\t\t\t\t\t// not detected as compatible, because inference still needs to complete?", "-\t\t\t\t\t\t\t\t\tinvocArg.setExpectedType(targetType);", "-\t\t\t\t\t\t\t\t\tMethodBinding solution = infCtx18.inferInvocationType(innerPoly, innerParameterized);", "-\t\t\t\t\t\t\t\t\tif (solution != null && solution.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\t\tif (innerPoly.updateBindings(solution, targetType)) {", "-\t\t\t\t\t\t\t\t\t\t\tif (innerInferenceHelper != null)", "-\t\t\t\t\t\t\t\t\t\t\t\tinnerInferenceHelper.registerInnerResult(method, invocArg.resolvedType, argLen, i);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tif (solution.returnType != null && solution.returnType.isCompatibleWith(targetType, this))", "-\t\t\t\t\t\t\t\t\t\t\treturn isVarArgs ? VARARGS_COMPATIBLE : COMPATIBLE;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn NOT_COMPATIBLE;", "-\t\t\t\t\t\t\t\t} else if (innerPoly instanceof AllocationExpression) {", "-\t\t\t\t\t\t\t\t\t// not detected as compatible, because its a diamond whose type hasn't yet been inferred?", "-\t\t\t\t\t\t\t\t\tTypeBinding[] typeArguments = resolvedType.typeArguments();", "-\t\t\t\t\t\t\t\t\tif (typeArguments != null && typeArguments.length == 0) {", "-\t\t\t\t\t\t\t\t\t\tAllocationExpression alloc = (AllocationExpression) innerPoly;", "-\t\t\t\t\t\t\t\t\t\tif ((alloc.type.bits & ASTNode.IsDiamond) != 0) {", "-\t\t\t\t\t\t\t\t\t\t\t// not-yet-inferred diamond: erasure compatibility should suffice, detail will be checked using inference", "-\t\t\t\t\t\t\t\t\t\t\tif (invocArg.resolvedType.isCompatibleWith(targetType.erasure(), this))", "-\t\t\t\t\t\t\t\t\t\t\t\treturn COMPATIBLE;", "-\t\t\t\t\t\t\t\t\t\t\treturn NOT_COMPATIBLE;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (innerPoly instanceof AllocationExpression) {", "-\t\t\t\t\t\t\t\tMethodBinding updatedMethod = innerPoly.binding(targetType); // 2. try with updating", "-\t\t\t\t\t\t\t\tif (updatedMethod != innerBinding && updatedMethod != null && updatedMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tif (updatedMethod.declaringClass.isCompatibleWith(targetType))", "-\t\t\t\t\t\t\t\t\t\treturn COMPATIBLE;", "-\t\t\t\t\t\t\t\t\treturn NOT_COMPATIBLE;", "-\t\t\t\t\t\t\t\t}", "-\t\treturn parameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods);"]}], "num": 26554}