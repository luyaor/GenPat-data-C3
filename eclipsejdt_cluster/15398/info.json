{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4de90d2aba571d4ff7968cb8ce90b2eb", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3fbc813f358f88a18c9a537d302964f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "c9df47e6bc4127d80d1e16ea8353f464e792fda3", "commitAfterChange": "514d8e9afb885d3be64fa67a03a4dd281867840f", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\t\t\t\t\tboolean isExactMatch = true;", "-\t\t\t\t\t\tif (methodBinding == null) {", "-\t\t\t\t\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "-\t\t\t\t\t\t\tisExactMatch = false;", "+\t\t\t\t\t\tif (methodBinding == null)", "-\t\t\t\t\t\t\t// methodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (!isExactMatch) {", "-\t\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\t\t\tif (compatibleMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t// likely not a match in the first place, 2 cases are possible", "-\t\t\t\t\t\t\t\t\t\t// first is when methodBinding was found thru inheritance starting from an nested type - in this case do not want to search outer scope", "-\t\t\t\t\t\t\t\t\t\t// second is when normal search turned up only this selector match so NotFound is expected", "-\t\t\t\t\t\t\t\t\t\t// except in 1.5 when static import methods can match correctly", "-\t\t\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible) {", "-\t\t\t\t\t\t\t\t\t\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 && !receiverType.isNestedType()) {", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak; // need to search for static import method matches", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t// inherited mismatch is reported directly, not looking at enclosing matches", "-\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t} else if (!compatibleMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\t\tfuzzyProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tmethodBinding = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\tif (!methodBinding.canBeSeenBy(receiverType, invocationSite, classScope)) {", "-\t\t\t\t\t\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "-\t\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, ProblemReasons.NotVisible);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (fuzzyProblem == null && !methodBinding.isStatic()) {", "+\t\t\t\t\t\t\t\tif (!methodBinding.isStatic()) {", "-\t", "-\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass", "-\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS", "-\t\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)) {", "-\t\t\t\t\t\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "-\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited visible shadows enclosing)", "-\t\t\t\t\t\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "-\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+", "+\t\t\t\t\t\t\t\tif (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass", "+\t\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS", "+\t\t\t\t\t\t\t\t\t\t|| ((foundFuzzyProblem == null || foundFuzzyProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)) {", "+\t\t\t\t\t\t\t\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited visible shadows enclosing)", "+\t\t\t\t\t\t\t\t\t\t\tif (depth > 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.problemId() != ProblemReasons.NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn foundFuzzyProblem;", "+\t\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "+\t\t\t\t\t\t\t\t\t\t\treturn methodBinding;", "-\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\t\tif (fuzzyProblem != null)", "-\t\t\t\t\t\t\t\t\t\t\treturn fuzzyProblem;", "-\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "-\t\t\t\t\t\t\t\t\t\treturn methodBinding;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tfuzzyProblem = methodBinding;", "+\t\t\t\t\t\t\t}", "+", "+\t\t\t\t\t\t\tif (foundMethod != null && foundMethod.declaringClass != methodBinding.declaringClass)", "+\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass || (receiverType.getMethods(selector)) != Binding.NO_METHODS)", "-\t\t\t\t\t\t\t\t\tif (foundMethod.declaringClass != methodBinding.declaringClass)", "-\t\t\t\t\t\t\t\t\t\t// ie. have we found the same method - do not trust field identity yet", "-\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\tProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t", "+\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\tProblemReasons.InheritedNameHidesEnclosingName);", "+", "+\t\tif (foundFuzzyProblem != null)", "+\t\t\tif (foundFuzzyProblem.problemId() != ProblemReasons.NotVisible && foundFuzzyProblem.problemId() != ProblemReasons.NotFound)", "+\t\t\t\treturn foundFuzzyProblem;", "+\t\tif (foundInsideProblem != null)", "+\t\t\treturn foundInsideProblem;", "+", "+\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.declaringClass != null && foundFuzzyProblem.declaringClass.id == TypeIds.T_JavaLangObject)", "+\t\t\t\treturn foundFuzzyProblem; // static imports lose to methods from Object", "+", "-\t\t\t\tMethodBinding[] visible = null;", "+\t\t\t\tObjectVector visible = null;", "-\t\t\t\t\t\tif (possible != null && possible != foundMethod) {", "+\t\t\t\t\t\tif (possible != null && possible != foundFuzzyProblem) {", "-\t\t\t\t\t\t\t\tif (foundMethod == null)", "-\t\t\t\t\t\t\t\t\tfoundMethod = possible; // answer as error case match", "+\t\t\t\t\t\t\t\tif (foundFuzzyProblem == null)", "+\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = possible; // answer as error case match", "-\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "-\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\t\t\t\t\t\tif (foundMethod == null || !foundMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\tif (!importBinding.onDemand && foundMethod.isValidBinding())", "-\t\t\t\t\t\t\t\t\t\t\t\t\tskipOnDemand = true;", "-\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\tif (visible == null || !visible.contains(compatibleMethod)) {", "+\t\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\t} else if (visible == null) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = new MethodBinding[] {foundMethod, compatibleMethod};", "-\t\t\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tint visibleLength = visible.length;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleLength + 1];", "-\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(visible, 0, temp, 0, visibleLength);", "-\t\t\t\t\t\t\t\t\t\t\t\t\ttemp[visibleLength] = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = temp;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (visible == null)", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = new ObjectVector(3);", "+\t\t\t\t\t\t\t\t\t\t\t\tvisible.add(compatibleMethod);", "-\t\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "+\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "+\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\tif (visible != null)", "-\t\t\t\t\tfoundMethod = mostSpecificMethodBinding(visible, visible.length, argumentTypes, invocationSite, null);", "-\t\t\t}", "-\t\t\tif (foundMethod != null) {", "-\t\t\t\tinvocationSite.setActualReceiverType(foundMethod.declaringClass);", "-\t\t\t\treturn foundMethod;", "+\t\t\t\tif (visible != null) {", "+\t\t\t\t\tMethodBinding[] temp = new MethodBinding[visible.size];", "+\t\t\t\t\tvisible.copyInto(temp);", "+\t\t\t\t\tfoundMethod = mostSpecificMethodBinding(temp, temp.length, argumentTypes, invocationSite, null);", "+\t\t\t\t}", "+\t\tif (foundMethod != null) {", "+\t\t\tinvocationSite.setActualReceiverType(foundMethod.declaringClass);", "+\t\t\treturn foundMethod;", "+\t\t}", "-\t\tif (foundInsideProblem != null)", "-\t\t\treturn foundInsideProblem;", "-\t\tif (foundMethod != null)", "-\t\t\treturn foundMethod;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d36855d5cb9272e031d4d19607ba504", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "4bca3a5b750a1427c84a78f92ee835c1f5e75da7", "commitAfterChange": "65cffea518e323981e83002b5b2ff520f43d6c58", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tMethodBinding foundFuzzyProblem = null;", "-\t\t// the weird method lookup case (matches method name in scope, then arg types, then visibility)", "-\t\tMethodBinding foundInsideProblem = null;", "-\t\t// inside Constructor call or inside static context", "+\t\tMethodBinding foundProblem = null;", "-\t\t\t\t\t\tMethodBinding methodBinding =", "-\t\t\t\t\t\t\t(foundMethod == null)", "-\t\t\t\t\t\t\t\t? classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-\t\t\t\t\t\t\t\t: classScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "+\t\t\t\t\t\tMethodBinding methodBinding = classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\tif (methodBinding.problemId() == ProblemReasons.Ambiguous) {", "-\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible) {", "-\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t\treturn methodBinding;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\tselector,", "-\t\t\t\t\t\t\t\t\targumentTypes,", "-\t\t\t\t\t\t\t\t\tProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tMethodBinding fuzzyProblem = null;", "-\t\t\t\t\t\t\tMethodBinding insideProblem = null;", "-\t\t\t\t\t\t\tif (methodBinding.isValidBinding()) {", "-\t\t\t\t\t\t\t\tif (!methodBinding.isStatic()) {", "-\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\t\tProblemReasons.NonStaticReferenceInConstructorInvocation);", "-\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\t\tProblemReasons.NonStaticReferenceInStaticContext);", "+\t\t\t\t\t\t\tif (foundMethod == null) {", "+\t\t\t\t\t\t\t\tif (methodBinding.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (!methodBinding.isStatic() && (insideConstructorCall || insideStaticContext)) {", "+\t\t\t\t\t\t\t\t\t\tif (foundProblem != null && foundProblem.problemId() != ProblemReasons.NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\treturn foundProblem; // takes precedence", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\t\tinsideConstructorCall", "+\t\t\t\t\t\t\t\t\t\t\t\t? ProblemReasons.NonStaticReferenceInConstructorInvocation", "+\t\t\t\t\t\t\t\t\t\t\t\t: ProblemReasons.NonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS", "-\t\t\t\t\t\t\t\t\t\t|| ((foundFuzzyProblem == null || foundFuzzyProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)) {", "+\t\t\t\t\t\t\t\t\t\t|| ((foundProblem == null || foundProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)", "+\t\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS) {", "-\t\t\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundProblem != null && foundProblem.problemId() != ProblemReasons.NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn foundProblem;", "-\t\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.problemId() != ProblemReasons.NotVisible)", "-\t\t\t\t\t\t\t\t\t\t\t\treturn foundFuzzyProblem;", "-\t\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tfuzzyProblem = methodBinding;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (foundMethod != null && foundMethod.declaringClass != methodBinding.declaringClass)", "-\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass || (receiverType.getMethods(selector)) != Binding.NO_METHODS)", "-\t\t\t\t\t\t\t\t\t// if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "+\t\t\t\t\t\t\t\t\tif (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\t\t// only remember the methodBinding if its the first one found", "+\t\t\t\t\t\t\t\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "+\t\t\t\t\t\t\t\t\t\tif (depth > 0) {", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tfoundMethod = methodBinding;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else { // methodBinding is a problem method", "+\t\t\t\t\t\t\t\t\tif (methodBinding.problemId() != ProblemReasons.NotVisible && methodBinding.problemId() != ProblemReasons.NotFound)", "+\t\t\t\t\t\t\t\t\t\treturn methodBinding; // return the error now", "+\t\t\t\t\t\t\t\t\tif (foundProblem == null || (foundProblem.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() == ProblemReasons.NotFound))", "+\t\t\t\t\t\t\t\t\t\tfoundProblem = methodBinding; // hold onto the first not visible/found error and keep the second not found if first is not visible", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else { // found a valid method so check to see if this is a hiding case", "+\t\t\t\t\t\t\t\tif (methodBinding.problemId() == ProblemReasons.Ambiguous", "+\t\t\t\t\t\t\t\t\t|| (foundMethod.declaringClass != methodBinding.declaringClass", "+\t\t\t\t\t\t\t\t\t\t&& (receiverType == methodBinding.declaringClass || receiverType.getMethods(selector) != Binding.NO_METHODS)))", "+\t\t\t\t\t\t\t\t\t// ambiguous case -> must qualify the method (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\t\t// otherwise if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\tselector,", "+\t\t\t\t\t\t\t\t\t\targumentTypes,", "-", "-\t\t\t\t\t\t\tif (foundMethod == null || (foundMethod.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() != ProblemReasons.NotVisible)) {", "-\t\t\t\t\t\t\t\t// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...", "-\t\t\t\t\t\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "-\t\t\t\t\t\t\t\tif (depth > 0) {", "-\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tfoundFuzzyProblem = fuzzyProblem;", "-\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\t\t\t\t\t\tif (fuzzyProblem == null)", "-\t\t\t\t\t\t\t\t\tfoundMethod = methodBinding; // only keep it if no error was found", "-\t\t\t\t\tinsideConstructorCall =", "-\t\t\t\t\t\tenclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "+\t\t\t\t\tinsideConstructorCall = enclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "-\t\tif (foundFuzzyProblem != null)", "-\t\t\tif (foundFuzzyProblem.problemId() != ProblemReasons.NotVisible && foundFuzzyProblem.problemId() != ProblemReasons.NotFound)", "-\t\t\t\treturn foundFuzzyProblem;", "-\t\tif (foundInsideProblem != null)", "-\t\t\treturn foundInsideProblem;", "-", "-\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.declaringClass != null && foundFuzzyProblem.declaringClass.id == TypeIds.T_JavaLangObject)", "-\t\t\t\treturn foundFuzzyProblem; // static imports lose to methods from Object", "+\t\t\tif (foundProblem != null) {", "+\t\t\t\tif (foundProblem.declaringClass != null && foundProblem.declaringClass.id == TypeIds.T_JavaLangObject)", "+\t\t\t\t\treturn foundProblem; // static imports lose to methods from Object", "+\t\t\t\tif (foundProblem.problemId() == ProblemReasons.NotFound) {", "+\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding) foundProblem).closestMatch;", "+\t\t\t\t\tif (closestMatch != null && closestMatch.canBeSeenBy(invocationSite, this))", "+\t\t\t\t\t\treturn foundProblem; // visible method selectors take precedence", "+\t\t\t\t}", "+\t\t\t}", "-\t\t\t\t\t\tif (possible != null && possible != foundFuzzyProblem) {", "+\t\t\t\t\t\tif (possible != null && possible != foundProblem) {", "-\t\t\t\t\t\t\t\tif (foundFuzzyProblem == null)", "-\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = possible; // answer as error case match", "+\t\t\t\t\t\t\t\tif (foundProblem == null)", "+\t\t\t\t\t\t\t\t\tfoundProblem = possible; // answer as error case match", "-\t\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "-\t\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t\t} else if (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundProblem = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "-\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "-\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t} else if (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\t\tfoundProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "-\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\t\t\t\t\t\t} else if (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\tfoundProblem = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\tif (foundFuzzyProblem != null)", "-\t\t\treturn foundFuzzyProblem;", "+\t\tif (foundProblem != null)", "+\t\t\treturn foundProblem;"]}], "num": 15398}