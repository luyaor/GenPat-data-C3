{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2e14638ddf1df5a664dee4e1021f4906", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "011b940433c88807dc48bb15356eafa8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "c48ecebe36df1bdca1948a66baeb643827a9b9c4", "commitAfterChange": "df8a00dea42b2c33f742d8ce1045c2aa42b28f3e", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\t\t\t\t\tif (foundSize == 1 && compatibleMethod.canBeSeenBy(receiverType, invocationSite, this)) {", "+\t\t\t\t\t\t\t// return the single visible match now", "+\t\t\t\t\t\t\tif (isCompliant14 && (receiverType.isAbstract() || receiverType.isTypeVariable())) {", "+\t\t\t\t\t\t\t\tMethodBinding interfaceMethod =", "+\t\t\t\t\t\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found);", "+\t\t\t\t\t\t\t\tif (interfaceMethod != null) {", "+\t\t\t\t\t\t\t\t\tcandidates = new MethodBinding[] {compatibleMethod, interfaceMethod};", "+\t\t\t\t\t\t\t\t\treturn mostSpecificMethodBinding(candidates, 2, argumentTypes, invocationSite, receiverType);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tunitScope.recordTypeReferences(compatibleMethod.thrownExceptions);", "+\t\t\t\t\t\t\treturn compatibleMethod;", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d8a0cb6a00dd3427671d59f197dad262", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "cb102deeeb30ec755d64a8d266f5423000dc4f4e", "commitAfterChange": "f18746495477338a9b83fca4f673d973bc3b28e9", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "diff": ["-\t\t\t} ", "-\t\t\tmatchingMethod =", "-\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "+\t\t\t}", "+\t\t\t// when receiverType is abstract then need to find possible matches in interfaces", "+\t\t\tif (receiverType.isAbstract())", "+\t\t\t\tmatchingMethod =", "+\t\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "+\t\t\t// reduces secondary errors since missing interface method error is already reported", "-\t\t\tmatchingMethod = mostSpecificMethodBinding(candidates, visiblesCount, argumentTypes, invocationSite);", "+\t\t\tmatchingMethod = mostSpecificMethodBinding(candidates, visiblesCount, argumentTypes, invocationSite, receiverType);", "-\t\t\t\t// see if there is a better match in the interfaces", "+\t\t\t\t// see if there is a better match in the interfaces - see AutoBoxingTest 99"]}], "num": 37369}