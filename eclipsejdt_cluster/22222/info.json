{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fb4c4465d0886eba2b2984d960e7ca1e", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76af2700bc09c81d7c6bc3b65afe2d24", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java", "commitBeforeChange": "fa5828480ebc13512cc4c6649155f597883abe5f", "commitAfterChange": "dbadb98550952623b726dd998146fbf52c65b243", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 49, "signatureBeforeChange": "   \tpublic int scanNumber(boolean dotPrefix) throws InvalidInputException", "signatureAfterChange": "   public int scanNumber(boolean dotPrefix) throws InvalidInputException", "diff": ["-\tpublic int scanNumber(boolean dotPrefix) throws InvalidInputException {", "+public int scanNumber(boolean dotPrefix) throws InvalidInputException {", "-\t\t//when entering this method the currentCharacter is the first", "-\t\t//digit of the number. It may be preceeded by a '.' when", "-\t\t//dotPrefix is true", "+\t//when entering this method the currentCharacter is the first", "+\t//digit of the number. It may be preceeded by a '.' when", "+\t//dotPrefix is true", "-\t\tboolean floating = dotPrefix;", "-\t\tif (!dotPrefix && (this.currentCharacter == '0')) {", "-\t\t\tif (getNextChar('x', 'X') >= 0) { //----------hexa-----------------", "-\t\t\t\tint start = this.currentPosition;", "-\t\t\t\tconsumeDigits(16, true);", "-\t\t\t\tint end = this.currentPosition;", "-\t\t\t\tif (getNextChar('l', 'L') >= 0) {", "+\tboolean floating = dotPrefix;", "+\tif ((!dotPrefix) && (this.currentCharacter == '0')) {", "+\t\tif (getNextChar('x', 'X') >= 0) { //----------hexa-----------------", "+\t\t\tint start = this.currentPosition;", "+\t\t\twhile (getNextCharAsDigit(16)){/*empty*/}", "+\t\t\tint end = this.currentPosition;", "+\t\t\tif (getNextChar('l', 'L') >= 0) {", "+\t\t\t\tif (end == start) {", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\t}", "+\t\t\t\treturn TokenNameLongLiteral;", "+\t\t\t} else if (getNextChar('.')) {", "+\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\treturn TokenNameLongLiteral;", "-\t\t\t\t} else if (getNextChar('.')) {", "-\t\t\t\t\t// hexadecimal floating point literal", "-\t\t\t\t\t// read decimal part", "-\t\t\t\t\tboolean hasNoDigitsBeforeDot = end == start;", "-\t\t\t\t\tstart = this.currentPosition;", "-\t\t\t\t\tconsumeDigits(16, true);", "-\t\t\t\t\tend = this.currentPosition;", "-\t\t\t\t\tif (hasNoDigitsBeforeDot && end == start) {", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "-\t\t\t\t\t}", "+\t\t\t\t\tthis.currentPosition = end;", "+\t\t\t\t\treturn TokenNameIntegerLiteral;", "+\t\t\t\t}", "+\t\t\t\t// hexadecimal floating point literal", "+\t\t\t\t// read decimal part", "+\t\t\t\tboolean hasNoDigitsBeforeDot = end == start;", "+\t\t\t\tstart = this.currentPosition;", "+\t\t\t\twhile (getNextCharAsDigit(16)){/*empty*/}", "+\t\t\t\tend = this.currentPosition;", "+\t\t\t\tif (hasNoDigitsBeforeDot && end == start) {", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\t}", "-\t\t\t\t\tif (getNextChar('p', 'P') >= 0) { // consume next character", "-\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "-\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "-\t\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\t\tgetNextUnicodeChar();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "-\t\t\t\t\t\t\t\tunicodeStore();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\tif ((this.currentCharacter == '-')", "-\t\t\t\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "-\t\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "-\t\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "-\t\t\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\t\t\tgetNextUnicodeChar();", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "-\t\t\t\t\t\t\t\t\tunicodeStore();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (!ScannerHelper.isDigit(this.currentCharacter)) {", "-\t\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (this.currentCharacter == '_') {", "-\t\t\t\t\t\t\t\t// wrongly place '_'", "-\t\t\t\t\t\t\t\tconsumeDigits(10);", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_UNDERSCORE);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tconsumeDigits(10, true);", "-\t\t\t\t\t\tif (getNextChar('f', 'F') >= 0) {", "-\t\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn TokenNameFloatingPointLiteral;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (getNextChar('d', 'D') >= 0) {", "-\t\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn TokenNameDoubleLiteral;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (getNextChar('l', 'L') >= 0) {", "-\t\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn TokenNameDoubleLiteral;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "-\t\t\t\t\t}", "-\t\t\t\t} else if (getNextChar('p', 'P') >= 0) { // consume next character", "+\t\t\t\tif (getNextChar('p', 'P') >= 0) { // consume next character", "-\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "+\t\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "-\t\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.currentCharacter == '_') {", "-\t\t\t\t\t\t\t// wrongly place '_'", "-\t\t\t\t\t\t\tconsumeDigits(10);", "-\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_UNDERSCORE);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "+\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "-\t\t\t\t\tconsumeDigits(10, true);", "+\t\t\t\t\twhile (getNextCharAsDigit()){/*empty*/}", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\tif (end == start)", "-\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\t}", "+\t\t\t} else if (getNextChar('p', 'P') >= 0) { // consume next character", "+\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "+\t\t\t\t\t// if we are in source level < 1.5 we report an integer literal", "+\t\t\t\t\tthis.currentPosition = end;", "-\t\t\t} else if (getNextChar('b', 'B') >= 0) { //----------binary-----------------", "-\t\t\t\tint start = this.currentPosition;", "-\t\t\t\tconsumeDigits(2, true);", "-\t\t\t\tint end = this.currentPosition;", "-\t\t\t\tif (end == start) {", "-\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_7) {", "-\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_BINARY_LITERAL);", "-\t\t\t\t\t}", "-\t\t\t\t\tthrow new InvalidInputException(INVALID_BINARY);", "-\t\t\t\t}", "-\t\t\t\tif (getNextChar('l', 'L') >= 0) {", "-\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_7) {", "-\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_BINARY_LITERAL);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn TokenNameLongLiteral;", "-\t\t\t\t}", "-\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_7) {", "-\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_BINARY_LITERAL);", "-\t\t\t\t}", "-\t\t\t\treturn TokenNameIntegerLiteral;", "-\t\t\t}", "-", "-\t\t\t//there is no x or X nor b or B in the number", "-\t\t\t//potential octal", "-\t\t\tif (getNextCharAsDigit()) { //-------------potential octal-----------------", "-\t\t\t\tconsumeDigits(10);", "-", "-\t\t\t\tif (getNextChar('l', 'L') >= 0) {", "-\t\t\t\t\treturn TokenNameLongLiteral;", "-\t\t\t\t}", "-", "-\t\t\t\tif (getNextChar('f', 'F') >= 0) {", "-\t\t\t\t\treturn TokenNameFloatingPointLiteral;", "-\t\t\t\t}", "-", "-\t\t\t\tif (getNextChar('d', 'D') >= 0) {", "-\t\t\t\t\treturn TokenNameDoubleLiteral;", "-\t\t\t\t} else { //make the distinction between octal and float ....", "-\t\t\t\t\tboolean isInteger = true;", "-\t\t\t\t\tif (getNextChar('.')) {", "-\t\t\t\t\t\tisInteger = false;", "-\t\t\t\t\t\tconsumeDigits(10);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (getNextChar('e', 'E') >= 0) { // consume next character", "-\t\t\t\t\t\tisInteger = false;", "-\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "-\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "-\t\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\t\tgetNextUnicodeChar();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "-\t\t\t\t\t\t\t\tunicodeStore();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\tif ((this.currentCharacter == '-')", "-\t\t\t\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "-\t\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "-\t\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "-\t\t\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\t\t\tgetNextUnicodeChar();", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "-\t\t\t\t\t\t\t\t\tunicodeStore();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (!ScannerHelper.isDigit(this.currentCharacter)) {", "-\t\t\t\t\t\t\tif (this.currentCharacter == '_') {", "-\t\t\t\t\t\t\t\t// wrongly place '_'", "-\t\t\t\t\t\t\t\tconsumeDigits(10);", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_UNDERSCORE);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tconsumeDigits(10, true);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (getNextChar('f', 'F') >= 0)", "-\t\t\t\t\t\treturn TokenNameFloatingPointLiteral;", "-\t\t\t\t\tif (getNextChar('d', 'D') >= 0 || !isInteger)", "-\t\t\t\t\t\treturn TokenNameDoubleLiteral;", "-\t\t\t\t\treturn TokenNameIntegerLiteral;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t/* carry on */", "-\t\t\t}", "-\t\t}", "-", "-\t\tconsumeDigits(10);", "-", "-\t\tif ((!dotPrefix) && (getNextChar('l', 'L') >= 0))", "-\t\t\treturn TokenNameLongLiteral;", "-", "-\t\tif ((!dotPrefix) && (getNextChar('.'))) { //decimal part that can be empty", "-\t\t\tconsumeDigits(10, true);", "-\t\t\tfloating = true;", "-\t\t}", "-", "-\t\t//if floating is true both exponant and suffix may be optional", "-", "-\t\tif (getNextChar('e', 'E') >= 0) {", "-\t\t\tfloating = true;", "-\t\t\t// consume next character", "-\t\t\tthis.unicodeAsBackSlash = false;", "-\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "-\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\tgetNextUnicodeChar();", "-\t\t\t} else {", "-\t\t\t\tif (this.withoutUnicodePtr != 0) {", "-\t\t\t\t\tunicodeStore();", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\tif ((this.currentCharacter == '-')", "-\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "-\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t}", "-\t\t\tif (!ScannerHelper.isDigit(this.currentCharacter)) {", "-\t\t\t\tif (this.currentCharacter == '_') {", "-\t\t\t\t\t// wrongly place '_'", "-\t\t\t\t\tconsumeDigits(10);", "-\t\t\t\t\tthrow new InvalidInputException(INVALID_UNDERSCORE);", "+", "+\t\t\t\tif ((this.currentCharacter == '-')", "+\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "+\t\t\t\t\tthis.unicodeAsBackSlash = false;", "+\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "+\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\tgetNextUnicodeChar();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\t\t\t\tunicodeStore();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "+\t\t\t\tif (!ScannerHelper.isDigit(this.currentCharacter))", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "+\t\t\t\twhile (getNextCharAsDigit()){/*empty*/}", "+\t\t\t\tif (getNextChar('f', 'F') >= 0)", "+\t\t\t\t\treturn TokenNameFloatingPointLiteral;", "+\t\t\t\tif (getNextChar('d', 'D') >= 0)", "+\t\t\t\t\treturn TokenNameDoubleLiteral;", "+\t\t\t\tif (getNextChar('l', 'L') >= 0) {", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\t}", "+\t\t\t\treturn TokenNameDoubleLiteral;", "+\t\t\t} else {", "+\t\t\t\tif (end == start)", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\treturn TokenNameIntegerLiteral;", "-\t\t\tconsumeDigits(10, true);", "-\t\tif (getNextChar('d', 'D') >= 0)", "-\t\t\treturn TokenNameDoubleLiteral;", "-\t\tif (getNextChar('f', 'F') >= 0)", "-\t\t\treturn TokenNameFloatingPointLiteral;", "+\t\t//there is x or X in the number", "+\t\t//potential octal ! ... some one may write 000099.0 ! thus 00100 < 00078.0 is true !!!!! crazy language", "+\t\tif (getNextCharAsDigit()) { //-------------potential octal-----------------", "+\t\t\twhile (getNextCharAsDigit()){/*empty*/}", "-\t\t//the long flag has been tested before", "+\t\t\tif (getNextChar('l', 'L') >= 0) {", "+\t\t\t\treturn TokenNameLongLiteral;", "+\t\t\t}", "-\t\treturn floating ? TokenNameDoubleLiteral : TokenNameIntegerLiteral;", "-\t}", "+\t\t\tif (getNextChar('f', 'F') >= 0) {", "+\t\t\t\treturn TokenNameFloatingPointLiteral;", "+\t\t\t}", "+\t\t\tif (getNextChar('d', 'D') >= 0) {", "+\t\t\t\treturn TokenNameDoubleLiteral;", "+\t\t\t} else { //make the distinction between octal and float ....", "+\t\t\t\tboolean isInteger = true;", "+\t\t\t\tif (getNextChar('.')) {", "+\t\t\t\t\tisInteger = false;", "+\t\t\t\t\twhile (getNextCharAsDigit()){/*empty*/}", "+\t\t\t\t}", "+\t\t\t\tif (getNextChar('e', 'E') >= 0) { // consume next character", "+\t\t\t\t\tisInteger = false;", "+\t\t\t\t\tthis.unicodeAsBackSlash = false;", "+\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "+\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\tgetNextUnicodeChar();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\t\t\t\tunicodeStore();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif ((this.currentCharacter == '-')", "+\t\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "+\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "+\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "+\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\t\tgetNextUnicodeChar();", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\t\t\t\t\tunicodeStore();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!ScannerHelper.isDigit(this.currentCharacter))", "+\t\t\t\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "+\t\t\t\t\twhile (getNextCharAsDigit()){/*empty*/}", "+\t\t\t\t}", "+\t\t\t\tif (getNextChar('f', 'F') >= 0)", "+\t\t\t\t\treturn TokenNameFloatingPointLiteral;", "+\t\t\t\tif (getNextChar('d', 'D') >= 0 || !isInteger)", "+\t\t\t\t\treturn TokenNameDoubleLiteral;", "+\t\t\t\treturn TokenNameIntegerLiteral;", "+\t\t\t}", "+\t\t\t/* carry on */", "+", "+\twhile (getNextCharAsDigit()){/*empty*/}", "+", "+\tif ((!dotPrefix) && (getNextChar('l', 'L') >= 0))", "+\t\treturn TokenNameLongLiteral;", "+", "+\tif ((!dotPrefix) && (getNextChar('.'))) { //decimal part that can be empty", "+\t\twhile (getNextCharAsDigit()){/*empty*/}", "+\t\tfloating = true;", "+\t}", "+", "+\t//if floating is true both exponant and suffix may be optional", "+", "+\tif (getNextChar('e', 'E') >= 0) {", "+\t\tfloating = true;", "+\t\t// consume next character", "+\t\tthis.unicodeAsBackSlash = false;", "+\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "+\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\tgetNextUnicodeChar();", "+\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\tunicodeStore();", "+\t\t\t}", "+", "+\t\tif ((this.currentCharacter == '-')", "+\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "+\t\t\tthis.unicodeAsBackSlash = false;", "+\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "+\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\tgetNextUnicodeChar();", "+\t\t\t} else {", "+\t\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\t\tunicodeStore();", "+\t\t\t\t}", "+\t\t\t}", "+\t\tif (!ScannerHelper.isDigit(this.currentCharacter))", "+\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "+\t\twhile (getNextCharAsDigit()){/*empty*/}", "+", "+\tif (getNextChar('d', 'D') >= 0)", "+\t\treturn TokenNameDoubleLiteral;", "+\tif (getNextChar('f', 'F') >= 0)", "+\t\treturn TokenNameFloatingPointLiteral;", "+", "+\t//the long flag has been tested before", "+", "+\treturn floating ? TokenNameDoubleLiteral : TokenNameIntegerLiteral;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf811a1367d64c8ef5fc559229e9dfa9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java", "commitBeforeChange": "fa5828480ebc13512cc4c6649155f597883abe5f", "commitAfterChange": "dbadb98550952623b726dd998146fbf52c65b243", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 49, "signatureBeforeChange": "   \tpublic int scanNumber(boolean dotPrefix) throws InvalidInputException", "signatureAfterChange": "   public int scanNumber(boolean dotPrefix) throws InvalidInputException", "diff": ["-\tpublic int scanNumber(boolean dotPrefix) throws InvalidInputException {", "+public int scanNumber(boolean dotPrefix) throws InvalidInputException {", "-\t\t//when entering this method the currentCharacter is the first", "-\t\t//digit of the number. It may be preceeded by a '.' when", "-\t\t//dotPrefix is true", "+\t//when entering this method the currentCharacter is the first", "+\t//digit of the number. It may be preceeded by a '.' when", "+\t//dotPrefix is true", "-\t\tboolean floating = dotPrefix;", "-\t\tif (!dotPrefix && (this.currentCharacter == '0')) {", "-\t\t\tif (getNextChar('x', 'X') >= 0) { //----------hexa-----------------", "-\t\t\t\tint start = this.currentPosition;", "-\t\t\t\tconsumeDigits(16, true);", "-\t\t\t\tint end = this.currentPosition;", "-\t\t\t\tif (getNextChar('l', 'L') >= 0) {", "+\tboolean floating = dotPrefix;", "+\tif ((!dotPrefix) && (this.currentCharacter == '0')) {", "+\t\tif (getNextChar('x', 'X') >= 0) { //----------hexa-----------------", "+\t\t\tint start = this.currentPosition;", "+\t\t\twhile (getNextCharAsDigit(16)){/*empty*/}", "+\t\t\tint end = this.currentPosition;", "+\t\t\tif (getNextChar('l', 'L') >= 0) {", "+\t\t\t\tif (end == start) {", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\t}", "+\t\t\t\treturn TokenNameLongLiteral;", "+\t\t\t} else if (getNextChar('.')) {", "+\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\treturn TokenNameLongLiteral;", "-\t\t\t\t} else if (getNextChar('.')) {", "-\t\t\t\t\t// hexadecimal floating point literal", "-\t\t\t\t\t// read decimal part", "-\t\t\t\t\tboolean hasNoDigitsBeforeDot = end == start;", "-\t\t\t\t\tstart = this.currentPosition;", "-\t\t\t\t\tconsumeDigits(16, true);", "-\t\t\t\t\tend = this.currentPosition;", "-\t\t\t\t\tif (hasNoDigitsBeforeDot && end == start) {", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "-\t\t\t\t\t}", "+\t\t\t\t\tthis.currentPosition = end;", "+\t\t\t\t\treturn TokenNameIntegerLiteral;", "+\t\t\t\t}", "+\t\t\t\t// hexadecimal floating point literal", "+\t\t\t\t// read decimal part", "+\t\t\t\tboolean hasNoDigitsBeforeDot = end == start;", "+\t\t\t\tstart = this.currentPosition;", "+\t\t\t\twhile (getNextCharAsDigit(16)){/*empty*/}", "+\t\t\t\tend = this.currentPosition;", "+\t\t\t\tif (hasNoDigitsBeforeDot && end == start) {", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\t}", "-\t\t\t\t\tif (getNextChar('p', 'P') >= 0) { // consume next character", "-\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "-\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "-\t\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\t\tgetNextUnicodeChar();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "-\t\t\t\t\t\t\t\tunicodeStore();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\tif ((this.currentCharacter == '-')", "-\t\t\t\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "-\t\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "-\t\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "-\t\t\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\t\t\tgetNextUnicodeChar();", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "-\t\t\t\t\t\t\t\t\tunicodeStore();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (!ScannerHelper.isDigit(this.currentCharacter)) {", "-\t\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (this.currentCharacter == '_') {", "-\t\t\t\t\t\t\t\t// wrongly place '_'", "-\t\t\t\t\t\t\t\tconsumeDigits(10);", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_UNDERSCORE);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tconsumeDigits(10, true);", "-\t\t\t\t\t\tif (getNextChar('f', 'F') >= 0) {", "-\t\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn TokenNameFloatingPointLiteral;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (getNextChar('d', 'D') >= 0) {", "-\t\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn TokenNameDoubleLiteral;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (getNextChar('l', 'L') >= 0) {", "-\t\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn TokenNameDoubleLiteral;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "-\t\t\t\t\t}", "-\t\t\t\t} else if (getNextChar('p', 'P') >= 0) { // consume next character", "+\t\t\t\tif (getNextChar('p', 'P') >= 0) { // consume next character", "-\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "+\t\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "-\t\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.currentCharacter == '_') {", "-\t\t\t\t\t\t\t// wrongly place '_'", "-\t\t\t\t\t\t\tconsumeDigits(10);", "-\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_UNDERSCORE);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "+\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "-\t\t\t\t\tconsumeDigits(10, true);", "+\t\t\t\t\twhile (getNextCharAsDigit()){/*empty*/}", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "-\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_HEXA_LITERAL);", "-\t\t\t\t\tif (end == start)", "-\t\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\t}", "+\t\t\t} else if (getNextChar('p', 'P') >= 0) { // consume next character", "+\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_5) {", "+\t\t\t\t\t// if we are in source level < 1.5 we report an integer literal", "+\t\t\t\t\tthis.currentPosition = end;", "-\t\t\t} else if (getNextChar('b', 'B') >= 0) { //----------binary-----------------", "-\t\t\t\tint start = this.currentPosition;", "-\t\t\t\tconsumeDigits(2, true);", "-\t\t\t\tint end = this.currentPosition;", "-\t\t\t\tif (end == start) {", "-\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_7) {", "-\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_BINARY_LITERAL);", "-\t\t\t\t\t}", "-\t\t\t\t\tthrow new InvalidInputException(INVALID_BINARY);", "-\t\t\t\t}", "-\t\t\t\tif (getNextChar('l', 'L') >= 0) {", "-\t\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_7) {", "-\t\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_BINARY_LITERAL);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn TokenNameLongLiteral;", "-\t\t\t\t}", "-\t\t\t\tif (this.sourceLevel < ClassFileConstants.JDK1_7) {", "-\t\t\t\t\tthrow new InvalidInputException(ILLEGAL_BINARY_LITERAL);", "-\t\t\t\t}", "-\t\t\t\treturn TokenNameIntegerLiteral;", "-\t\t\t}", "-", "-\t\t\t//there is no x or X nor b or B in the number", "-\t\t\t//potential octal", "-\t\t\tif (getNextCharAsDigit()) { //-------------potential octal-----------------", "-\t\t\t\tconsumeDigits(10);", "-", "-\t\t\t\tif (getNextChar('l', 'L') >= 0) {", "-\t\t\t\t\treturn TokenNameLongLiteral;", "-\t\t\t\t}", "-", "-\t\t\t\tif (getNextChar('f', 'F') >= 0) {", "-\t\t\t\t\treturn TokenNameFloatingPointLiteral;", "-\t\t\t\t}", "-", "-\t\t\t\tif (getNextChar('d', 'D') >= 0) {", "-\t\t\t\t\treturn TokenNameDoubleLiteral;", "-\t\t\t\t} else { //make the distinction between octal and float ....", "-\t\t\t\t\tboolean isInteger = true;", "-\t\t\t\t\tif (getNextChar('.')) {", "-\t\t\t\t\t\tisInteger = false;", "-\t\t\t\t\t\tconsumeDigits(10);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (getNextChar('e', 'E') >= 0) { // consume next character", "-\t\t\t\t\t\tisInteger = false;", "-\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "-\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "-\t\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\t\tgetNextUnicodeChar();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "-\t\t\t\t\t\t\t\tunicodeStore();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\tif ((this.currentCharacter == '-')", "-\t\t\t\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "-\t\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "-\t\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "-\t\t\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\t\t\t\t\tgetNextUnicodeChar();", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "-\t\t\t\t\t\t\t\t\tunicodeStore();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (!ScannerHelper.isDigit(this.currentCharacter)) {", "-\t\t\t\t\t\t\tif (this.currentCharacter == '_') {", "-\t\t\t\t\t\t\t\t// wrongly place '_'", "-\t\t\t\t\t\t\t\tconsumeDigits(10);", "-\t\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_UNDERSCORE);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tconsumeDigits(10, true);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (getNextChar('f', 'F') >= 0)", "-\t\t\t\t\t\treturn TokenNameFloatingPointLiteral;", "-\t\t\t\t\tif (getNextChar('d', 'D') >= 0 || !isInteger)", "-\t\t\t\t\t\treturn TokenNameDoubleLiteral;", "-\t\t\t\t\treturn TokenNameIntegerLiteral;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t/* carry on */", "-\t\t\t}", "-\t\t}", "-", "-\t\tconsumeDigits(10);", "-", "-\t\tif ((!dotPrefix) && (getNextChar('l', 'L') >= 0))", "-\t\t\treturn TokenNameLongLiteral;", "-", "-\t\tif ((!dotPrefix) && (getNextChar('.'))) { //decimal part that can be empty", "-\t\t\tconsumeDigits(10, true);", "-\t\t\tfloating = true;", "-\t\t}", "-", "-\t\t//if floating is true both exponant and suffix may be optional", "-", "-\t\tif (getNextChar('e', 'E') >= 0) {", "-\t\t\tfloating = true;", "-\t\t\t// consume next character", "-\t\t\tthis.unicodeAsBackSlash = false;", "-\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "-\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t\tgetNextUnicodeChar();", "-\t\t\t} else {", "-\t\t\t\tif (this.withoutUnicodePtr != 0) {", "-\t\t\t\t\tunicodeStore();", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\tif ((this.currentCharacter == '-')", "-\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "-\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "-\t\t\t}", "-\t\t\tif (!ScannerHelper.isDigit(this.currentCharacter)) {", "-\t\t\t\tif (this.currentCharacter == '_') {", "-\t\t\t\t\t// wrongly place '_'", "-\t\t\t\t\tconsumeDigits(10);", "-\t\t\t\t\tthrow new InvalidInputException(INVALID_UNDERSCORE);", "+", "+\t\t\t\tif ((this.currentCharacter == '-')", "+\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "+\t\t\t\t\tthis.unicodeAsBackSlash = false;", "+\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "+\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\tgetNextUnicodeChar();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\t\t\t\tunicodeStore();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "+\t\t\t\tif (!ScannerHelper.isDigit(this.currentCharacter))", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "+\t\t\t\twhile (getNextCharAsDigit()){/*empty*/}", "+\t\t\t\tif (getNextChar('f', 'F') >= 0)", "+\t\t\t\t\treturn TokenNameFloatingPointLiteral;", "+\t\t\t\tif (getNextChar('d', 'D') >= 0)", "+\t\t\t\t\treturn TokenNameDoubleLiteral;", "+\t\t\t\tif (getNextChar('l', 'L') >= 0) {", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\t}", "+\t\t\t\treturn TokenNameDoubleLiteral;", "+\t\t\t} else {", "+\t\t\t\tif (end == start)", "+\t\t\t\t\tthrow new InvalidInputException(INVALID_HEXA);", "+\t\t\t\treturn TokenNameIntegerLiteral;", "-\t\t\tconsumeDigits(10, true);", "-\t\tif (getNextChar('d', 'D') >= 0)", "-\t\t\treturn TokenNameDoubleLiteral;", "-\t\tif (getNextChar('f', 'F') >= 0)", "-\t\t\treturn TokenNameFloatingPointLiteral;", "+\t\t//there is x or X in the number", "+\t\t//potential octal ! ... some one may write 000099.0 ! thus 00100 < 00078.0 is true !!!!! crazy language", "+\t\tif (getNextCharAsDigit()) { //-------------potential octal-----------------", "+\t\t\twhile (getNextCharAsDigit()){/*empty*/}", "-\t\t//the long flag has been tested before", "+\t\t\tif (getNextChar('l', 'L') >= 0) {", "+\t\t\t\treturn TokenNameLongLiteral;", "+\t\t\t}", "-\t\treturn floating ? TokenNameDoubleLiteral : TokenNameIntegerLiteral;", "-\t}", "+\t\t\tif (getNextChar('f', 'F') >= 0) {", "+\t\t\t\treturn TokenNameFloatingPointLiteral;", "+\t\t\t}", "+\t\t\tif (getNextChar('d', 'D') >= 0) {", "+\t\t\t\treturn TokenNameDoubleLiteral;", "+\t\t\t} else { //make the distinction between octal and float ....", "+\t\t\t\tboolean isInteger = true;", "+\t\t\t\tif (getNextChar('.')) {", "+\t\t\t\t\tisInteger = false;", "+\t\t\t\t\twhile (getNextCharAsDigit()){/*empty*/}", "+\t\t\t\t}", "+\t\t\t\tif (getNextChar('e', 'E') >= 0) { // consume next character", "+\t\t\t\t\tisInteger = false;", "+\t\t\t\t\tthis.unicodeAsBackSlash = false;", "+\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "+\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\tgetNextUnicodeChar();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\t\t\t\tunicodeStore();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif ((this.currentCharacter == '-')", "+\t\t\t\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "+\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "+\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "+\t\t\t\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\t\tgetNextUnicodeChar();", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\t\t\t\t\tunicodeStore();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!ScannerHelper.isDigit(this.currentCharacter))", "+\t\t\t\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "+\t\t\t\t\twhile (getNextCharAsDigit()){/*empty*/}", "+\t\t\t\t}", "+\t\t\t\tif (getNextChar('f', 'F') >= 0)", "+\t\t\t\t\treturn TokenNameFloatingPointLiteral;", "+\t\t\t\tif (getNextChar('d', 'D') >= 0 || !isInteger)", "+\t\t\t\t\treturn TokenNameDoubleLiteral;", "+\t\t\t\treturn TokenNameIntegerLiteral;", "+\t\t\t}", "+\t\t\t/* carry on */", "+", "+\twhile (getNextCharAsDigit()){/*empty*/}", "+", "+\tif ((!dotPrefix) && (getNextChar('l', 'L') >= 0))", "+\t\treturn TokenNameLongLiteral;", "+", "+\tif ((!dotPrefix) && (getNextChar('.'))) { //decimal part that can be empty", "+\t\twhile (getNextCharAsDigit()){/*empty*/}", "+\t\tfloating = true;", "+\t}", "+", "+\t//if floating is true both exponant and suffix may be optional", "+", "+\tif (getNextChar('e', 'E') >= 0) {", "+\t\tfloating = true;", "+\t\t// consume next character", "+\t\tthis.unicodeAsBackSlash = false;", "+\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "+\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\tgetNextUnicodeChar();", "+\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\tunicodeStore();", "+\t\t\t}", "+", "+\t\tif ((this.currentCharacter == '-')", "+\t\t\t|| (this.currentCharacter == '+')) { // consume next character", "+\t\t\tthis.unicodeAsBackSlash = false;", "+\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\')", "+\t\t\t\t&& (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\tgetNextUnicodeChar();", "+\t\t\t} else {", "+\t\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\t\tunicodeStore();", "+\t\t\t\t}", "+\t\t\t}", "+\t\tif (!ScannerHelper.isDigit(this.currentCharacter))", "+\t\t\tthrow new InvalidInputException(INVALID_FLOAT);", "+\t\twhile (getNextCharAsDigit()){/*empty*/}", "+", "+\tif (getNextChar('d', 'D') >= 0)", "+\t\treturn TokenNameDoubleLiteral;", "+\tif (getNextChar('f', 'F') >= 0)", "+\t\treturn TokenNameFloatingPointLiteral;", "+", "+\t//the long flag has been tested before", "+", "+\treturn floating ? TokenNameDoubleLiteral : TokenNameIntegerLiteral;", "+}"]}], "num": 22222}