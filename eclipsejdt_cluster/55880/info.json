{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "63d8e597e3d2acb7baeafadc93bd2ea1", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "acb4032869e82a3d16b83fe8e900a0eb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "16bbff04917b9cd9bd7cceaf4adfc1563daef0bc", "commitAfterChange": "898da07e1ab8f70e81db909fb2e1c38edc9b87c3", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-        \tint len = this.binding.parameters.length;", "+        \tint len;", "+        \tint expectedlen = this.binding.parameters.length;", "+        \tint providedLen = this.descriptor.parameters.length;", "+        \tboolean isVarArgs = false;", "+        \tif (this.binding.isVarargs()) {", "+        \t\tisVarArgs = (providedLen == expectedlen)", "+\t\t\t\t\t? !this.descriptor.parameters[expectedlen-1].isCompatibleWith(this.binding.parameters[expectedlen-1])", "+\t\t\t\t\t: true;", "+        \t\tlen = providedLen; // binding parameters will be padded from InferenceContext18.getParameter()", "+        \t} else {", "+        \t\tlen = Math.min(expectedlen, providedLen);", "+        \t}", "-    \t\t\tlong declared = this.descriptor.parameters[i+paramOffset].tagBits & TagBits.AnnotationNullMASK;", "-    \t\t\tlong implemented = this.binding.parameters[i].tagBits & TagBits.AnnotationNullMASK;", "-    \t\t\tif (declared == TagBits.AnnotationNullable) { // promise to accept null", "-    \t\t\t\tif (implemented != TagBits.AnnotationNullable) {", "-    \t\t\t\t\tchar[][] requiredAnnot = implemented == 0L ? null : scope.environment().getNonNullAnnotationName();", "-    \t\t\t\t\tscope.problemReporter().parameterLackingNullableAnnotation(this, this.descriptor, i, paramOffset, ", "-    \t\t\t\t\t\t\tscope.environment().getNullableAnnotationName(),", "-    \t\t\t\t\t\t\trequiredAnnot, this.binding.parameters[i]);", "-    \t\t\t\t}", "-    \t\t\t} else if (declared == 0L) {", "-    \t\t\t\tif (implemented == TagBits.AnnotationNonNull) {", "-    \t\t\t\t\tscope.problemReporter().parameterRequiresNonnull(this, this.descriptor, i+paramOffset,", "-    \t\t\t\t\t\t\tscope.environment().getNonNullAnnotationName(), this.binding.parameters[i]);", "-    \t\t\t\t}", "+    \t\t\tTypeBinding descriptorParameter = this.descriptor.parameters[i+paramOffset];", "+    \t\t\tTypeBinding bindingParameter = InferenceContext18.getParameter(this.binding.parameters, i, isVarArgs);", "+    \t\t\tNullAnnotationMatching annotationStatus = NullAnnotationMatching.analyse(bindingParameter, descriptorParameter, FlowInfo.UNKNOWN);", "+    \t\t\tif (annotationStatus.isAnyMismatch()) {", "+    \t\t\t\t// immediate reporting:", "+    \t\t\t\tscope.problemReporter().referenceExpressionArgumentNullityMismatch(this, bindingParameter, descriptorParameter, this.descriptor, i, annotationStatus);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b4e4411f6968edfaa40c2376e5fb5756", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "7548eaaea6e1259875e63eaf19dcd9a6bb7fd118", "commitAfterChange": "3d5aa7d7eabaf3445aad76f168f1c9da2ba34591", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " private void add(String path, boolean withSubFolders, AccessRuleSet access)", "signatureAfterChange": " private void add(String path, String containerPath, boolean withSubFolders, AccessRuleSet access)", "diff": ["-private void add(String path, boolean withSubFolders, AccessRuleSet access) {", "-\tif (this.paths.length == this.pathsCount) {", "-\t\tSystem.arraycopy(", "-\t\t\tthis.paths,", "-\t\t\t0,", "-\t\t\tthis.paths = new String[this.pathsCount * 2],", "-\t\t\t0,", "-\t\t\tthis.pathsCount);", "-\t\tSystem.arraycopy(", "-\t\t\tthis.pathWithSubFolders,", "-\t\t\t0,", "-\t\t\tthis.pathWithSubFolders = new boolean[this.pathsCount * 2],", "-\t\t\t0,", "-\t\t\tthis.pathsCount);", "-\t\tif (this.pathRestrictions != null)", "-\t\t\tSystem.arraycopy(", "-\t\t\t\tthis.pathRestrictions,", "-\t\t\t\t0,", "-\t\t\t\tthis.pathRestrictions = new AccessRuleSet[this.pathsCount * 2],", "-\t\t\t\t0,", "-\t\t\t\tthis.pathsCount);", "-\t\telse if (access != null)", "-\t\t\tthis.pathRestrictions = new AccessRuleSet[this.pathsCount * 2];", "+private void add(String path, String containerPath, boolean withSubFolders, AccessRuleSet access) {", "+\tint index = (containerPath.hashCode() & 0x7FFFFFFF) % this.paths.length;", "+\tString currentPath, currentContainerPath;", "+\twhile ((currentPath = this.paths[index]) != null && (currentContainerPath = this.containerPaths[index]) != null) {", "+\t\tif (currentPath.equals(path) && currentContainerPath.equals(containerPath))", "+\t\t\treturn;", "+\t\tindex = (index + 1) % this.paths.length;", "-\tthis.paths[this.pathsCount] = path;", "-\tthis.pathWithSubFolders[this.pathsCount] = withSubFolders; ", "+\tthis.paths[index] = path;", "+\tthis.containerPaths[index] = containerPath;", "+\tthis.pathWithSubFolders[index] = withSubFolders;", "-\t\tthis.pathRestrictions[this.pathsCount] = access;", "-\tthis.pathsCount++;", "+\t\tthis.pathRestrictions[index] = access;", "+\telse if (access != null) {", "+\t\tthis.pathRestrictions = new AccessRuleSet[this.paths.length];", "+\t\tthis.pathRestrictions[index] = access;", "+\t}", "+", "+\t// assumes the threshold is never equal to the size of the table", "+\tif (++this.pathsCount > this.threshold)", "+\t\trehash();", "+\t\t"]}], "num": 55880}