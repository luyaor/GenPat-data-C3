{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5ed641734afa293da1dfca3a4dfe52ea", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dfa0143730df3d8e9e17aae7ac26f9a0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "5da4268a6e911ad3865241747a8e9714544fc990", "commitAfterChange": "1e8305535ff304200778a08eb6eb4025791a09c1", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 16, "signatureBeforeChange": "  void checkMethods()", "signatureAfterChange": "  void checkMethods()", "diff": ["+\t\t// ensure that if we have a concrete method this shows up at position [0]:", "+\t\tinherited = Sorting.concreteFirst(inherited, inherited.length);", "+\t\tboolean[] isOverridden = new boolean[inheritedLength];", "-\t\t\t\t\t\t\tskip[j] = couldMethodOverride(currentMethod, inheritedMethod);", "+\t\t\t\t\t\t\tisOverridden[j] = skip[j] = couldMethodOverride(currentMethod, inheritedMethod);", "-", "+\t\t// first round: collect information into skip and isOverridden by comparing all pairs:", "+\t\t// (and perform some side effects : bridge methods & use flags)", "-\t\t\tif (skip[i]) continue;", "-\t\t\tif (matchMethod == null)", "-\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\t\t\tif (otherInheritedMethod.declaringClass.isInterface() && !inheritedMethod.declaringClass.isInterface()) {", "-\t\t\t\t\t\tif (isInterfaceMethodImplemented(otherInheritedMethod, inheritedMethod, otherInheritedMethod.declaringClass)) {", "-\t\t\t\t\t\t\tskip[j] = true;", "-\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else if (areMethodsCompatible(inheritedMethod, otherInheritedMethod, true)) {", "-\t\t\t\t\t\tskip[j] = true;", "+\t\t\t\t\t// these method calls produce their effect as side-effects into skip and isOverridden:", "+\t\t\t\t\tif (isSkippableOrOverridden(inheritedMethod, otherInheritedMethod, skip, isOverridden, j))", "-\t\t\t\t\t}", "+\t\t\t\t\tif (isSkippableOrOverridden(otherInheritedMethod, inheritedMethod, skip, isOverridden, i))", "+\t\t\t\t\t\tcontinue;", "-\t\t\t\totherInheritedMethod = computeSubstituteMethod(otherInheritedMethod, inheritedMethod);", "-\t\t\t\tif (otherInheritedMethod != null) {", "-\t\t\t\t\tif (((!inheritedMethod.isAbstract() || otherInheritedMethod.isAbstract()) \t\t// if (abstract(inherited) => abstract(other)) check if inherited overrides other ", "-\t\t\t\t\t\t\t\t&& isSubstituteParameterSubsignature(inheritedMethod, otherInheritedMethod))", "-\t\t\t\t\t\t|| ((!otherInheritedMethod.isAbstract() || inheritedMethod.isAbstract())\t// if (abstract(other) => abstract(inherited)) check if other overrides inherited ", "-\t\t\t\t\t\t\t\t&& isSubstituteParameterSubsignature(otherInheritedMethod, inheritedMethod))) ", "-\t\t\t\t\t{", "-\t\t\t\t\t\tif (index == -1)", "-\t\t\t\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\t\t\t\tif (foundMatch[j] == null)", "-\t\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "+\t\t\t}", "+\t\t}", "+\t\t// second round: collect and check matchingInherited, directly check methods with no replacing etc.", "+\t\tfor (int i = 0; i < inheritedLength; i++) {", "+\t\t\tMethodBinding matchMethod = foundMatch[i];", "+\t\t\tif (skip[i]) continue;", "+\t\t\tMethodBinding inheritedMethod = inherited[i];", "+\t\t\tif (matchMethod == null)", "+\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "+\t\t\tfor (int j = i + 1; j < inheritedLength; j++) {", "+\t\t\t\tif (foundMatch[j] == null) {", "+\t\t\t\t\tMethodBinding otherInheritedMethod = inherited[j];", "+\t\t\t\t\tif (matchMethod == foundMatch[j] && matchMethod != null)", "+\t\t\t\t\t\tcontinue; // both inherited methods matched the same currentMethod", "+\t\t\t\t\tif (canSkipInheritedMethods(inheritedMethod, otherInheritedMethod))", "+\t\t\t\t\t\tcontinue;", "+", "+\t\t\t\t\tMethodBinding replaceMatch;", "+\t\t\t\t\tif ((replaceMatch = findReplacedMethod(inheritedMethod, otherInheritedMethod)) != null) {", "+\t\t\t\t\t\tmatchingInherited[++index] = replaceMatch;", "-\t\t\t\t\t} else if (matchMethod == null && foundMatch[j] == null) {", "+\t\t\t\t\t} else if ((replaceMatch = findReplacedMethod(otherInheritedMethod, inheritedMethod)) != null) {", "+\t\t\t\t\t\tmatchingInherited[++index] = replaceMatch;", "+\t\t\t\t\t\tskip[j] = true;\t\t\t\t\t\t", "+\t\t\t\t\t} else if (matchMethod == null) {", "+\t\t\t\t\t\t// none replaced by the other, check these methods against each other now:", "-\t\t\t\tcheckInheritedMethods(matchingInherited, index + 1); // pass in the length of matching", "+\t\t\t\tcheckInheritedMethods(matchingInherited, index + 1, isOverridden); // pass in the length of matching"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fe534494e0cf659292e79f1633ca5fb7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "b9bb6123c3e4c0567c677af33c7c0e8037ba4975", "commitAfterChange": "4dd974a226271180ff02d909a12722017f80ff3a", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 16, "signatureBeforeChange": "  void checkMethods()", "signatureAfterChange": "  void checkMethods()", "diff": ["+\t\tboolean[] isOverridden = new boolean[inheritedLength];", "-\t\t\t\t\t\t\tskip[j] = couldMethodOverride(currentMethod, inheritedMethod);", "+\t\t\t\t\t\t\tisOverridden[j] = skip[j] = couldMethodOverride(currentMethod, inheritedMethod);", "-", "+\t\t// first round: collect information into skip and isOverridden by comparing all pairs:", "+\t\t// (and perform some side effects : bridge methods & use flags)", "-\t\t\tif (skip[i]) continue;", "-\t\t\tif (matchMethod == null)", "-\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\t\t\tif (otherInheritedMethod.declaringClass.isInterface() && !inheritedMethod.declaringClass.isInterface()) {", "-\t\t\t\t\t\tif (isInterfaceMethodImplemented(otherInheritedMethod, inheritedMethod, otherInheritedMethod.declaringClass)) {", "-\t\t\t\t\t\t\tskip[j] = true;", "-\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else if (areMethodsCompatible(inheritedMethod, otherInheritedMethod, true)) {", "-\t\t\t\t\t\tskip[j] = true;", "+\t\t\t\t\t// these method calls produce their effect as side-effects into skip and isOverridden:", "+\t\t\t\t\tif (isSkippableOrOverridden(inheritedMethod, otherInheritedMethod, skip, isOverridden, j))", "-\t\t\t\t\t}", "+\t\t\t\t\tif (isSkippableOrOverridden(otherInheritedMethod, inheritedMethod, skip, isOverridden, i))", "+\t\t\t\t\t\tcontinue;", "-\t\t\t\totherInheritedMethod = computeSubstituteMethod(otherInheritedMethod, inheritedMethod);", "-\t\t\t\tif (otherInheritedMethod != null) {", "-\t\t\t\t\tif (((!inheritedMethod.isAbstract() || otherInheritedMethod.isAbstract()) \t\t// if (abstract(inherited) => abstract(other)) check if inherited overrides other ", "-\t\t\t\t\t\t\t\t&& isSubstituteParameterSubsignature(inheritedMethod, otherInheritedMethod))", "-\t\t\t\t\t\t|| ((!otherInheritedMethod.isAbstract() || inheritedMethod.isAbstract())\t// if (abstract(other) => abstract(inherited)) check if other overrides inherited ", "-\t\t\t\t\t\t\t\t&& isSubstituteParameterSubsignature(otherInheritedMethod, inheritedMethod))) ", "-\t\t\t\t\t{", "-\t\t\t\t\t\tif (index == -1)", "-\t\t\t\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\t\t\t\tif (foundMatch[j] == null)", "-\t\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "+\t\t\t}", "+\t\t}", "+\t\t// second round: collect and check matchingInherited, directly check methods with no replacing etc.", "+\t\tfor (int i = 0; i < inheritedLength; i++) {", "+\t\t\tMethodBinding matchMethod = foundMatch[i];", "+\t\t\tif (skip[i]) continue;", "+\t\t\tMethodBinding inheritedMethod = inherited[i];", "+\t\t\tif (matchMethod == null)", "+\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "+\t\t\tfor (int j = i + 1; j < inheritedLength; j++) {", "+\t\t\t\tif (foundMatch[j] == null) {", "+\t\t\t\t\tMethodBinding otherInheritedMethod = inherited[j];", "+\t\t\t\t\tif (matchMethod == foundMatch[j] && matchMethod != null)", "+\t\t\t\t\t\tcontinue; // both inherited methods matched the same currentMethod", "+\t\t\t\t\tif (canSkipInheritedMethods(inheritedMethod, otherInheritedMethod))", "+\t\t\t\t\t\tcontinue;", "+", "+\t\t\t\t\tMethodBinding replaceMatch;", "+\t\t\t\t\tif ((replaceMatch = findReplacedMethod(inheritedMethod, otherInheritedMethod)) != null) {", "+\t\t\t\t\t\tmatchingInherited[++index] = replaceMatch;", "-\t\t\t\t\t} else if (matchMethod == null && foundMatch[j] == null) {", "+\t\t\t\t\t} else if ((replaceMatch = findReplacedMethod(otherInheritedMethod, inheritedMethod)) != null) {", "+\t\t\t\t\t\tmatchingInherited[++index] = replaceMatch;", "+\t\t\t\t\t\tskip[j] = true;\t\t\t\t\t\t", "+\t\t\t\t\t} else if (matchMethod == null) {", "+\t\t\t\t\t\t// none replaced by the other, check these methods against each other now:", "-\t\t\t\tcheckInheritedMethods(matchingInherited, index + 1); // pass in the length of matching", "+\t\t\t\tcheckInheritedMethods(matchingInherited, index + 1, isOverridden); // pass in the length of matching"]}], "num": 71269}