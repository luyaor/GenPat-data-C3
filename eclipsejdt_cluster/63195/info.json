{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "99b08a29fceb415b22267ab5f0e67b55", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a6f237cb2cf45b155fa3a674ec225b74", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "cefc7f3f8677282aa49e610700500999ffcaffcb", "commitAfterChange": "89e8879d5dd978e5f2535f9d8b7bac080dd4f73b", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "signatureAfterChange": " protected IJavaElement createHandle(LambdaExpression lambdaExpression, IJavaElement parent)", "diff": ["+ */", "+protected IJavaElement createHandle(LambdaExpression lambdaExpression, IJavaElement parent) {", "+\tif (!(parent instanceof IType)) return parent;", "+", "+\tIType type = (IType) parent;", "+\tArgument[] arguments = lambdaExpression.arguments();", "+\tint syntheticArgumentSize = lambdaExpression.getSyntheticArgumentSize();", "+\tMethodBinding descriptor = lambdaExpression.descriptor;", "+\tint argCount = arguments == null ? 0 : arguments.length;", "+\tif (type.isBinary()) {", "+\t\tClassFileReader reader = classFileReader(type);", "+\t\tif (reader != null) {", "+\t\t\t// build arguments names", "+\t\t\tchar[][] argumentTypeNames = new char[argCount - syntheticArgumentSize][];", "+\t\t\tfor (int i = syntheticArgumentSize; i < argCount; i++) {", "+\t\t\t\tchar[] typeName = null;", "+\t\t\t\tif (arguments != null) {", "+\t\t\t\t\tTypeReference typeRef = arguments[i].type;", "+\t\t\t\t\ttypeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "+\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "+\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t\t}", "+\t\t\t\tif (typeName == null) {", "+\t\t\t\t\t// invalid type name", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t\targumentTypeNames[i - syntheticArgumentSize] = typeName;", "+\t\t\t}", "+\t\t\t// return binary method", "+\t\t\tIMethod binaryMethod = createBinaryMethodHandle(type, descriptor.selector, argumentTypeNames);", "+\t\t\tif (binaryMethod == null) {", "+\t\t\t\t// when first attempt fails, try with similar matches if any...", "+\t\t\t\tPossibleMatch similarMatch = this.currentPossibleMatch.getSimilarMatch();", "+\t\t\t\twhile (similarMatch != null) {", "+\t\t\t\t\ttype = ((ClassFile)similarMatch.openable).getType();", "+\t\t\t\t\tbinaryMethod = createBinaryMethodHandle(type, descriptor.selector, argumentTypeNames);", "+\t\t\t\t\tif (binaryMethod != null) {", "+\t\t\t\t\t\treturn binaryMethod;", "+\t\t\t\t\t}", "+\t\t\t\t\tsimilarMatch = similarMatch.getSimilarMatch();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn binaryMethod;", "+\t\t}", "+\t\tif (BasicSearchEngine.VERBOSE) {", "+\t\t\tSystem.out.println(\"Not able to createHandle for the lambda expression \" + //$NON-NLS-1$", "+\t\t\t\t\tCharOperation.charToString(descriptor.selector) + \" May miss some results\");  //$NON-NLS-1$", "+\t\t}", "+\t\treturn null;", "+\t}", "+", "+\tString[] parameterTypeSignatures = new String[argCount - syntheticArgumentSize];", "+\tif (arguments != null) {", "+\t\tfor (int i = syntheticArgumentSize; i < argCount; i++) {", "+\t\t\tTypeReference typeRef = arguments[i].type;", "+\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getParameterizedTypeName(), '.');", "+\t\t\tparameterTypeSignatures[i - syntheticArgumentSize] = Signature.createTypeSignature(typeName, false);", "+\t\t}", "+\t}", "+", "+\treturn createMethodHandle(type, new String(descriptor.selector), parameterTypeSignatures);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dba6402c2adf2110b8d24b0160d9778f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "06cedbd8bd184e3f34c939385e2cbddd9e3aedca", "commitAfterChange": "0d09a2966f3cebfb8d6601000e2b64259fed7dd8", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " protected IJavaElement createHandle(LambdaExpression lambdaExpression, IJavaElement parent)", "signatureAfterChange": " protected IJavaElement createHandle(LambdaExpression lambdaExpression, IJavaElement parent)", "diff": ["-\tif (!(parent instanceof IType)) return parent;", "-", "-\tIType type = (IType) parent;", "-\tArgument[] arguments = lambdaExpression.arguments();", "-\tint syntheticArgumentSize = lambdaExpression.getSyntheticArgumentSize();", "-\tMethodBinding descriptor = lambdaExpression.descriptor;", "-\tint argCount = arguments == null ? 0 : arguments.length;", "-\tif (type.isBinary()) {", "-\t\tClassFileReader reader = classFileReader(type);", "-\t\tif (reader != null) {", "-\t\t\t// build arguments names", "-\t\t\tchar[][] argumentTypeNames = new char[argCount - syntheticArgumentSize][];", "-\t\t\tfor (int i = syntheticArgumentSize; i < argCount; i++) {", "-\t\t\t\tchar[] typeName = null;", "-\t\t\t\tif (arguments != null) {", "-\t\t\t\t\tTypeReference typeRef = arguments[i].type;", "-\t\t\t\t\ttypeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "-\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "-\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "-\t\t\t\t}", "-\t\t\t\tif (typeName == null) {", "-\t\t\t\t\t// invalid type name", "-\t\t\t\t\treturn null;", "-\t\t\t\t}", "-\t\t\t\targumentTypeNames[i - syntheticArgumentSize] = typeName;", "-\t\t\t}", "-\t\t\t// return binary method", "-\t\t\tIMethod binaryMethod = createBinaryMethodHandle(type, descriptor.selector, argumentTypeNames);", "-\t\t\tif (binaryMethod == null) {", "-\t\t\t\t// when first attempt fails, try with similar matches if any...", "-\t\t\t\tPossibleMatch similarMatch = this.currentPossibleMatch.getSimilarMatch();", "-\t\t\t\twhile (similarMatch != null) {", "-\t\t\t\t\ttype = ((ClassFile)similarMatch.openable).getType();", "-\t\t\t\t\tbinaryMethod = createBinaryMethodHandle(type, descriptor.selector, argumentTypeNames);", "-\t\t\t\t\tif (binaryMethod != null) {", "-\t\t\t\t\t\treturn binaryMethod;", "-\t\t\t\t\t}", "-\t\t\t\t\tsimilarMatch = similarMatch.getSimilarMatch();", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn binaryMethod;", "-\t\t}", "-\t\tif (BasicSearchEngine.VERBOSE) {", "-\t\t\tSystem.out.println(\"Not able to createHandle for the lambda expression \" + //$NON-NLS-1$", "-\t\t\t\t\tCharOperation.charToString(descriptor.selector) + \" May miss some results\");  //$NON-NLS-1$", "-\t\t}", "-\t\treturn null;", "-\t}", "-", "-\tString[] parameterTypeSignatures = new String[argCount - syntheticArgumentSize];", "-\tif (arguments != null) {", "-\t\tfor (int i = syntheticArgumentSize; i < argCount; i++) {", "-\t\t\tTypeReference typeRef = arguments[i].type;", "-\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getParameterizedTypeName(), '.');", "-\t\t\tparameterTypeSignatures[i - syntheticArgumentSize] = Signature.createTypeSignature(typeName, false);", "-\t\t}", "-\t}", "-", "-\treturn createMethodHandle(type, new String(descriptor.selector), parameterTypeSignatures);", "+\torg.eclipse.jdt.internal.core.LambdaExpression lambdaElement = new org.eclipse.jdt.internal.core.LambdaExpression((JavaElement) parent, lambdaExpression);", "+\tIMethod lambdaMethodElement = lambdaElement.getMethod();", "+\tthis.methodHandles.add(lambdaMethodElement);", "+\treturn lambdaMethodElement;"]}], "num": 63195}