{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8db204a97d3e60e3beeb78eeea64a9f1", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5eac0fac87af12090d339736cbf80eae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DocCommentParser.java", "commitBeforeChange": "6defd2b79520062f5150164ded77c2d030acc168", "commitAfterChange": "d351702f3561d64a024c15ffbed0faad48ce2838", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tprotected boolean pushParamName()", "signatureAfterChange": " \tprotected boolean pushParamName(boolean isTypeParam)", "diff": ["-\tprotected boolean pushParamName() {", "-\t\tSimpleName name = this.ast.newSimpleName(new String(this.scanner.getCurrentIdentifierSource()));", "-\t\tname.setSourceRange(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition()-this.scanner.getCurrentTokenStartPosition()+1);", "+\tprotected boolean pushParamName(boolean isTypeParam) {", "+\t\tSimpleName name = this.ast.newSimpleName(new String(this.identifierStack[0]));", "+\t\tint start = (int) (this.identifierPositionStack[0] >>> 32);", "+\t\tint end = (int) (this.identifierPositionStack[0] & 0x00000000FFFFFFFFL);", "+\t\tname.setSourceRange(start, end-start+1);", "-\t\tparamTag.setSourceRange(this.tagSourceStart, this.scanner.getCurrentTokenEndPosition()-this.tagSourceStart+1);", "+\t\tparamTag.setSourceRange(this.tagSourceStart, end-this.tagSourceStart+1);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "616ef91d21bc69c274f10ad49375d7c1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "f0cc0529135fe43e5b6252dca937651f0a04d49c", "commitAfterChange": "79c1182746ff2f44f9956aeaf2f61882a4911acb", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static int[] getLocations( \t\t\tfinal TypeReference reference, \t\t\tfinal Annotation[] primaryAnnotation, \t\t\tfinal Annotation annotation, \t\t\tfinal Annotation[][] annotationsOnDimensionsOnExpression)", "signatureAfterChange": " \tpublic static int[] getLocations( \t\t\tfinal TypeReference reference, \t\t\tfinal Annotation[] primaryAnnotation, \t\t\tfinal Annotation annotation, \t\t\tfinal Annotation[][] annotationsOnDimensionsOnExpression, \t\t\tfinal int dimensions)", "diff": ["-\t\t\tfinal Annotation[][] annotationsOnDimensionsOnExpression) {", "+\t\t\tfinal Annotation[][] annotationsOnDimensionsOnExpression,", "+\t\t\tfinal int dimensions) {", "+\t", "-\t\t\tStack currentIndexes;", "+\t\t\tStack typePathEntries;", "-\t\t\t\tthis.currentIndexes = new Stack();", "+\t\t\t\tthis.typePathEntries = new Stack();", "-\t\t\tpublic boolean visit(ArrayTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\tAnnotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;", "-\t\t\t\tif (annotationsOnDimensions != null) {", "-\t\t\t\t\t// check if the annotation is located on the first dimension", "-\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[0];", "-\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-", "-\t\t\t\t\tthis.currentIndexes.push(new Integer(0));", "-\t\t\t\t\tfor (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {", "-\t\t\t\t\t\tannotations = annotationsOnDimensions[i];", "-\t\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "-\t\t\t\tif (annotations == null) {", "-\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "-\t\t\t\t}", "-\t\t\t\tint annotationsLevels = annotations.length;", "-\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "-\t\t\t\t\tAnnotation [] current = annotations[i];", "-\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "-\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "-\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "-\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tthis.currentIndexes.pop();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic boolean visit(ArrayQualifiedTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\tAnnotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;", "-\t\t\t\tif (annotationsOnDimensions != null) {", "-\t\t\t\t\t// check if the annotation is located on the first dimension", "-\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[0];", "-\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-", "-\t\t\t\t\tthis.currentIndexes.push(new Integer(0));", "-\t\t\t\t\tfor (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {", "-\t\t\t\t\t\tannotations = annotationsOnDimensions[i];", "-\t\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "-\t\t\t\tif (annotations == null) {", "-\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "-\t\t\t\t}", "-\t\t\t\tint annotationsLevels = annotations.length;", "-\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "-\t\t\t\t\tAnnotation [] current = annotations[i];", "-\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "-\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "-\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "-\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tthis.currentIndexes.pop();", "-\t\t\t\treturn true;", "-\t\t\t}", "+\t\t\t", "+\t\t\t\t\t\t\t\t", "-\t\t\t\t\t// check if the annotation is located on the first dimension", "-\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[0];", "-\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-", "-\t\t\t\t\tthis.currentIndexes.push(new Integer(0));", "-\t\t\t\t\tfor (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {", "-\t\t\t\t\t\tannotations = annotationsOnDimensions[i];", "+\t\t\t\t\tfor (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {", "+\t\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[i];", "+\t\t\t\t\t\t\t\t\t// found it, push any relevant type path entries", "+\t\t\t\t\t\t\t\t\tfor (int k = 0; k < i; k++) {", "+\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));", "+\t\t\t\t\t\t", "+\t\t\t\t", "+\t\t\t\t// Example cases handled here: @B(1) List<String>[]", "+\t\t\t\t\t\t\t// Found it, insert any necessary type path elements", "+\t\t\t\t\t\t\tfor (int k = 0; k < typeReference.dimensions; k++) {", "+\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// If a type argument is annotated it is necessary jump past the array elements", "+\t\t\t\tif (typeReference.dimensions != 0) {", "+\t\t\t\t\tfor (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {", "+\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "-\t\t\t\tthis.currentIndexes.push(new Integer(0));", "+\t\t\t\t\tthis.typePathEntries.add(new int[]{3,i});", "-\t\t\t\t\tif (!this.search) return false;", "-\t\t\t\t\tthis.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));", "+\t\t\t\t\tif (!this.search) {", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.typePathEntries.pop();", "+\t\t\t\t\t}", "-\t\t\t\tthis.currentIndexes.pop();", "+\t\t\t\tif (typeReference.dimensions != 0) {", "+\t\t\t\t\tfor (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {", "+\t\t\t\t\t\tthis.typePathEntries.pop();", "+\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\t}", "-\t\t\tpublic boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\tAnnotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;", "-\t\t\t\tif (annotationsOnDimensions != null) {", "-\t\t\t\t\t// check if the annotation is located on the first dimension", "-\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[0];", "-\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.currentIndexes.push(new Integer(0));", "-\t\t\t\t\tfor (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {", "-\t\t\t\t\t\tannotations = annotationsOnDimensions[i];", "-\t\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "-\t\t\t\tif (annotations == null) {", "-\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "-\t\t\t\t}", "-\t\t\t\tint annotationsLevels = annotations.length;", "-\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "-\t\t\t\t\tAnnotation [] current = annotations[i];", "-\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "-\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "-\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "-\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t//TODO it is unclear how to manage annotations located in the first type arguments", "-\t\t\t\tTypeReference[] typeReferences = typeReference.typeArguments[typeReference.typeArguments.length - 1];", "-\t\t\t\tthis.currentIndexes.push(new Integer(0));", "-\t\t\t\tfor (int i = 0, max = typeReferences.length; i < max; i++) {", "-\t\t\t\t\ttypeReferences[i].traverse(this, scope);", "-\t\t\t\t\tif (!this.search) return false;", "-\t\t\t\t\tthis.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));", "-\t\t\t\t}", "-\t\t\t\tthis.currentIndexes.pop();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\t\tAnnotation[][] annotationsOnDimensions = annotationsOnDimensionsOnExpression;", "-\t\t\t\tif (annotationsOnDimensions != null) {", "-\t\t\t\t\t// check if the annotation is located on the first dimension", "-\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[0];", "-\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.currentIndexes.push(new Integer(0));", "-\t\t\t\t\tfor (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {", "-\t\t\t\t\t\tannotations = annotationsOnDimensions[i];", "-\t\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "-\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "-\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "-\t\t\t\t\t\t\t\t\tthis.search = false;", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));", "+\t\t\t\t// depth allows for the syntax \"outerInstance.new @A InnerType();\"", "+\t\t\t\tint depth = 0;", "+\t\t\t\tif (typeReference.resolvedType instanceof ReferenceBinding) {", "+\t\t\t\t\tdepth = getInnerDepth((ReferenceBinding)typeReference.resolvedType);", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tif (dimensions != 0) {", "+\t\t\t\t\tfor (int k = 0; k < dimensions; k++) {", "+\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t\t\t\t// Found", "+\t\t\t\t\t\t\tif (depth != 0) {", "+\t\t\t\t\t\t\t\tfor (int k = 0; k<depth; k++) {", "+\t\t\t\t\t\t\t\t\tthis.typePathEntries.add(TYPE_PATH_INNER_TYPE);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (dimensions != 0) {", "+\t\t\t\t\tfor (int k = 0; k < dimensions; k++) {", "+\t\t\t\t\t\tthis.typePathEntries.pop();", "-\t\t\tpublic boolean visit(Wildcard typeReference, BlockScope scope) {", "+", "+\t\t\tpublic boolean visit(ArrayTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tTypeReference bound = typeReference.bound;", "-\t\t\t\tbound.traverse(this, scope);", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic boolean visit(QualifiedTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "+\t\t\t\t", "+\t\t\t\tAnnotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;", "+\t\t\t\tif (annotationsOnDimensions != null) {", "+\t\t\t\t\tfor (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {", "+\t\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[i];", "+\t\t\t\t\t\tif (annotations != null) {", "+\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "+\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "+\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "+\t\t\t\t\t\t\t\t\tfor (int k = 0; k < i; k++) {", "+\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tthis.search = false;", "+\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t\tint annotationsLevels = annotations == null ? 0 : annotations.length;", "+\t\t\t\tif (annotations == null) {", "+\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "+\t\t\t\t}", "+\t\t\t\tint annotationsLevels = annotations.length;", "+\t\t\t\t\t\t\tfor (int k = 0, maxk=typeReference.dimensions; k < maxk; k++) {", "+\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(ArrayQualifiedTypeReference typeReference, BlockScope scope) {", "+\t\t\t\tif (!this.search) return false;", "+\t\t\t\tAnnotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;", "+\t\t\t\tif (annotationsOnDimensions != null) {", "+\t\t\t\t\tfor (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {", "+\t\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[i];", "+\t\t\t\t\t\tif (annotations != null) {", "+\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "+\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "+\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "+\t\t\t\t\t\t\t\t\tthis.search = false;", "+\t\t\t\t\t\t\t\t\t// Found it, insert relevant type path elements", "+\t\t\t\t\t\t\t\t\tfor (int k = 0, maxk = i; k < maxk; k++) {", "+\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "+\t\t\t\tif (annotations == null) {", "+\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "+\t\t\t\t}", "+\t\t\t\tint annotationsLevels = annotations.length;", "+\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "+\t\t\t\t\tAnnotation [] current = annotations[i];", "+\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "+\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "+\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "+\t\t\t\t\t\t\tthis.search = false;", "+\t\t\t\t\t\t\tfor (int k = 0, maxk=typeReference.dimensions; k < maxk; k++) {", "+\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {", "+\t\t\t\tif (!this.search) return false;", "+\t\t\t\t", "+\t\t\t\t// Example case handled by this block: java.util.List<String>[]@A[]", "+\t\t\t\tAnnotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;", "+\t\t\t\tif (annotationsOnDimensions != null) {", "+\t\t\t\t\tfor (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {", "+\t\t\t\t\t\tAnnotation[] annotations = annotationsOnDimensions[i];", "+\t\t\t\t\t\tif (annotations != null) {", "+\t\t\t\t\t\t\tfor (int j = 0, max2 = annotations.length; j < max2; j++) {", "+\t\t\t\t\t\t\t\tAnnotation current = annotations[j];", "+\t\t\t\t\t\t\t\tif (current == this.currentAnnotation) {", "+\t\t\t\t\t\t\t\t\tthis.search = false;", "+\t\t\t\t\t\t\t\t\t// Found it, insert relevant type path elements", "+\t\t\t\t\t\t\t\t\tfor (int k = 0, maxk = i; k < maxk; k++) {", "+\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+", "+\t\t\t\tboolean[] needsInnerEntryInfo = computeInnerEntryInfo(typeReference);", "+", "+\t\t\t\t// Example cases handled by this block:", "+\t\t\t\t// java.util.@A List<String>[][], com.demo.@A Outer.@B Inner<String>, java.util.Map.@A Entry<String,String>", "+\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "+\t\t\t\tif (annotations == null) {", "+\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "+\t\t\t\t}", "+\t\t\t\tint annotationsLevels = annotations.length;", "+\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "+\t\t\t\t\tAnnotation [] current = annotations[i];", "+\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "+\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "+\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "+\t\t\t\t\t\t\tthis.search = false;", "+\t\t\t\t\t\t\t// Found, insert any relevant type path elements", "+\t\t\t\t\t\t\tfor (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {", "+\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// Found, insert any relevant type path elements", "+\t\t\t\t\t\t\tif (needsInnerEntryInfo != null) {", "+\t\t\t\t\t\t\t\tfor (int k = 0; k <= i; k++) {", "+\t\t\t\t\t\t\t\t\tif (needsInnerEntryInfo[k]) {", "+\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_INNER_TYPE);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// Example cases handled by this block:", "+\t\t\t\t// java.util.List<@A String>", "+\t\t\t\tif (typeReference.dimensions != 0) {", "+\t\t\t\t\tfor (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {", "+\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tint toPop = 0;", "+\t\t\t\tfor (int i = 0, max = typeReference.typeArguments.length; i < max; i++) {", "+\t\t\t\t\tTypeReference[] typeArgumentsForComponent = typeReference.typeArguments[i];", "+\t\t\t\t\tif (needsInnerEntryInfo != null && needsInnerEntryInfo[i]) { ", "+\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_INNER_TYPE);", "+\t\t\t\t\t\ttoPop++;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (typeArgumentsForComponent != null) {", "+\t\t\t\t\t\tfor (int j = 0, max2 = typeArgumentsForComponent.length; j < max2; j++) {", "+\t\t\t\t\t\t\tthis.typePathEntries.push(new int[]{3,j});", "+\t\t\t\t\t\t\ttypeArgumentsForComponent[j].traverse(this,scope);", "+\t\t\t\t\t\t\tif (!this.search) return false;", "+\t\t\t\t\t\t\tthis.typePathEntries.pop();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\ttoPop += typeReference.dimensions;", "+\t\t\t\tfor (int k = 0, maxk = toPop; k < maxk; k++) {", "+\t\t\t\t\tthis.typePathEntries.pop();", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(Wildcard typeReference, BlockScope scope) {", "+\t\t\t\tif (!this.search) return false;", "+\t\t\t\tTypeReference bound = typeReference.bound;", "+\t\t\t\tthis.typePathEntries.push(TYPE_PATH_ANNOTATION_ON_WILDCARD_BOUND);", "+\t\t\t\tbound.traverse(this, scope);", "+\t\t\t\tif (!this.search) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tthis.typePathEntries.pop();", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\t", "+\t\t\tprivate boolean[] computeInnerEntryInfo(QualifiedTypeReference typeReference) {", "+\t\t\t\tReferenceBinding resolvedType = (ReferenceBinding) ", "+\t\t\t\t\t\t(typeReference.resolvedType instanceof ArrayBinding ? typeReference.resolvedType.leafComponentType() : typeReference.resolvedType);", "+\t\t\t\tboolean[] needsInnerEntryInfo = null;", "+\t\t\t\tif (resolvedType != null && resolvedType.isNestedType()) {", "+\t\t\t\t\t// Work backwards computing whether a INNER_TYPE entry is required for each level", "+\t\t\t\t\tneedsInnerEntryInfo = new boolean[typeReference.tokens.length];", "+\t\t\t\t\tint counter = needsInnerEntryInfo.length - 1;", "+\t\t\t\t\tReferenceBinding type = resolvedType;//resolvedType.enclosingType();", "+\t\t\t\t\twhile (type != null) {", "+\t\t\t\t\t\tneedsInnerEntryInfo[counter--] = !type.isStatic();", "+\t\t\t\t\t\ttype = type.enclosingType();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn needsInnerEntryInfo;", "+\t\t\t}", "+\t\t\t", "+\t\t\tprivate int getInnerDepth(ReferenceBinding resolvedType) {", "+\t\t\t\tint depth = 0;", "+\t\t\t\tReferenceBinding type = resolvedType;", "+\t\t\t\twhile (type != null) {", "+\t\t\t\t\tdepth += (type.isStatic())?0:1;", "+\t\t\t\t\ttype = type.enclosingType();", "+\t\t\t\t}", "+\t\t\t\treturn depth;", "+\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(QualifiedTypeReference typeReference, BlockScope scope) {", "+\t\t\t\tif (!this.search) return false;", "+\t\t\t\tboolean[] needsInnerEntryInfo = computeInnerEntryInfo(typeReference);", "+\t\t\t\t", "+\t\t\t\t// Example cases handled by this block:", "+\t\t\t\t// java.util.@A List, com.demo.@A Outer.@B Inner, java.util.Map.@A Entry", "+\t\t\t\tAnnotation[][] annotations = typeReference.annotations;", "+\t\t\t\tif (annotations == null) {", "+\t\t\t\t\tannotations = new Annotation[][] { primaryAnnotation };", "+\t\t\t\t}", "+\t\t\t\tint annotationsLevels = annotations.length;", "+\t\t\t\tfor (int i = 0; i < annotationsLevels; i++) {", "+\t\t\t\t\tAnnotation [] current = annotations[i];", "+\t\t\t\t\tint annotationsLength = current == null ? 0 : current.length;", "+\t\t\t\t\tfor (int j = 0; j < annotationsLength; j++) {", "+\t\t\t\t\t\tif (current[j] == this.currentAnnotation) {", "+\t\t\t\t\t\t\tthis.search = false;", "+\t\t\t\t\t\t\t// Found, insert any relevant type path elements", "+\t\t\t\t\t\t\tif (needsInnerEntryInfo != null) {", "+\t\t\t\t\t\t\t\tfor (int k = 0; k <= i; k++) {", "+\t\t\t\t\t\t\t\t\tif (needsInnerEntryInfo[k]) {", "+\t\t\t\t\t\t\t\t\t\tthis.typePathEntries.push(TYPE_PATH_INNER_TYPE);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\t", "-\t\t\t\t\t.append(\"\\ncurrent indexes : \") //$NON-NLS-1$", "-\t\t\t\t\t.append(this.currentIndexes);", "+\t\t\t\t\t.append(\"\\ncurrent type_path entries : \"); //$NON-NLS-1$", "+\t\t\t\tfor (int i = 0, maxi = this.typePathEntries.size(); i < maxi; i++) {", "+\t\t\t\t\tint[] typePathEntry = (int[]) this.typePathEntries.get(i);", "+\t\t\t\t\tbuffer", "+\t\t\t\t\t\t.append('(')", "+\t\t\t\t\t\t.append(typePathEntry[0])", "+\t\t\t\t\t\t.append(',')", "+\t\t\t\t\t\t.append(typePathEntry[1])", "+\t\t\t\t\t\t.append(')');", "+\t\t\t\t}", "-\t\tif (collector.currentIndexes.isEmpty()) {", "+\t\tif (collector.typePathEntries.isEmpty()) {", "-\t\tint size = collector.currentIndexes.size();", "-\t\tint[] result = new int[size];", "+\t\tint size = collector.typePathEntries.size();", "+\t\tint[] result = new int[size*2];", "+\t\tint offset=0;", "-\t\t\tresult[size - i - 1] = ((Integer) collector.currentIndexes.pop()).intValue();", "+\t\t\tint[] pathElement = (int[])collector.typePathEntries.get(i);", "+\t\t\tresult[offset++] = pathElement[0];", "+\t\t\tresult[offset++] = pathElement[1];"]}], "num": 65561}