{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bc10cb3679e3d9b5ebe1628a6843a60d", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5842736b000ff5bbf59e9224e64acd24", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "9ee78f50bb7fb9d70095ea7ff2d9f2e27d840c37", "commitAfterChange": "b6410432af18704990f18fa69a09dd7a76e8fb04", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " void matchReportReference(MessageSend messageSend, IJavaElement element, int accuracy, MatchLocator locator, MethodBinding methodBinding) throws CoreException", "signatureAfterChange": " void matchReportReference(MessageSend messageSend, MatchLocator locator, MethodBinding methodBinding) throws CoreException", "diff": ["-void matchReportReference(MessageSend messageSend, IJavaElement element, int accuracy, MatchLocator locator, MethodBinding methodBinding) throws CoreException {", "+void matchReportReference(MessageSend messageSend, MatchLocator locator, MethodBinding methodBinding) throws CoreException {", "-\tint rule = SearchPattern.R_EXACT_MATCH;", "-\tint refinedAccuracy = accuracy;", "+\tboolean isParameterized = false;", "+\t\tisParameterized = true;", "+", "+\t\t// Update match regarding method type arguments", "-\t\trefinedAccuracy = refineAccuracy(accuracy, parameterizedMethodBinding.typeArguments, locator, this.pattern.methodArguments, this.pattern.hasMethodParameters());", "-\t\t", "+\t\tmatch.setRaw(parameterizedMethodBinding.isRaw);", "+\t\tTypeBinding[] typeArguments = /*parameterizedMethodBinding.isRaw ? null :*/ parameterizedMethodBinding.typeArguments;", "+\t\tupdateMatch(typeArguments, locator, this.pattern.methodArguments, this.pattern.hasMethodParameters());", "+", "+\t\t// Update match regarding declaring class type arguments", "-\t\t\t\t// special case for pattern which defines method arguments but no type ones", "-\t\t\t\t// in this case, we only use refined accuracy for constructor", "+\t\t\t\t// special case for pattern which defines method arguments but not its declaring type", "+\t\t\t\t// in this case, we do not refine accuracy using declaring type arguments...!", "-\t\t\t\trefinedAccuracy = refineAccuracy(refinedAccuracy, parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);", "+\t\t\t\tupdateMatch(parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);", "-\t\t\tif (refinedAccuracy == -1) return;", "-\t\t\trule = SearchPattern.R_ERASURE_MATCH;", "+\t\t\tmatch.setRule(SearchPattern.R_ERASURE_MATCH);", "+", "+\t\t// Update match regarding method parameters", "+\t\t// TODO ? (frederic)", "+", "+\t\t// Update match regarding method return type", "+\t\t// TODO ? (frederic)", "+\t\tisParameterized = true;", "-\t\t\trefinedAccuracy = refineAccuracy(refinedAccuracy, parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);", "-\t\t\tif (refinedAccuracy == -1) return;", "+\t\t\tupdateMatch(parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);", "-\t\t\trule = SearchPattern.R_ERASURE_MATCH;", "+\t\t\tmatch.setRule(SearchPattern.R_ERASURE_MATCH);", "+", "+\t\t// Update match regarding method parameters", "+\t\t// TODO ? (frederic)", "+", "+\t\t// Update match regarding method return type", "+\t\t// TODO ? (frederic)", "-\t\trule = SearchPattern.R_ERASURE_MATCH;", "+\t\tmatch.setRule(SearchPattern.R_ERASURE_MATCH);", "-\tboolean report = refinedAccuracy != -1; // impossible match", "-\tif (report && (refinedAccuracy & SearchPattern.R_ERASURE_MATCH) != 0) { // erasure match", "-\t\tif ((refinedAccuracy & SearchPattern.R_EQUIVALENT_MATCH) != 0) { // raw match", "-\t\t\treport = this.isEquivalentMatch || this.isErasureMatch; // report only if pattern is equivalent or erasure", "-\t\t} else {", "-\t\t\treport = this.isErasureMatch; // report only if pattern is erasure", "-\t\t}", "-\t}", "-\telse if (report && (refinedAccuracy & SearchPattern.R_EQUIVALENT_MATCH) != 0) { // equivalent match", "-\t\treport  = this.isEquivalentMatch || this.isErasureMatch; // report only if pattern is equivalent or erasure", "-\t}", "+\tif (match.getRule() == 0) return; // impossible match", "+\tboolean report = (this.isErasureMatch && match.isErasure()) || (this.isEquivalentMatch && match.isEquivalent()) || match.isExact();", "-", "-\t// Set rule", "-\tif (rule != SearchPattern.R_ERASURE_MATCH) {", "-\t\trule |= refinedAccuracy & RULE_MASK;", "-\t}", "-\trefinedAccuracy = refinedAccuracy & (~RULE_MASK);", "-\tSearchMatch match = locator.newMethodReferenceMatch(element,", "-\t\t\taccuracy,", "-\t\t\toffset,", "-\t\t\tmessageSend.sourceEnd - offset + 1,", "-\t\t\tfalse, // not constructor", "-\t\t\tfalse, // not synthetic", "-\t\t\tmessageSend);", "-\tmatch.setMatchRule(rule);", "-\tlocator.report(match);", "+\tmatch.setOffset(offset);", "+\tmatch.setLength(messageSend.sourceEnd - offset + 1);", "+\t if (isParameterized && this.pattern.hasMethodArguments())  {", "+\t\tlocator.reportAccurateParameterizedMethodReference(match, messageSend, messageSend.typeArguments);", "+\t} else {", "+\t\tlocator.report(match);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e4506899591567ef45e93df562441a9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java", "commitBeforeChange": "9ee78f50bb7fb9d70095ea7ff2d9f2e27d840c37", "commitAfterChange": "b6410432af18704990f18fa69a09dd7a76e8fb04", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " protected void matchReportReference(ASTNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": " protected void matchReportReference(ASTNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "diff": ["-\t\tisSynthetic = ((ExplicitConstructorCall) reference).isImplicitSuper();", "-\t\tconstructorBinding = ((ExplicitConstructorCall) reference).binding;", "+\t\tExplicitConstructorCall call = (ExplicitConstructorCall) reference;", "+\t\tisSynthetic = call.isImplicitSuper();", "+\t\tconstructorBinding = call.binding;", "-\t\tconstructorBinding = ((AllocationExpression) reference).binding;", "+\t\tAllocationExpression alloc = (AllocationExpression) reference;", "+\t\tconstructorBinding = alloc.binding;", "+\t\tif (match != null) return;", "+\t// Create search match", "+\tmatch = locator.newMethodReferenceMatch(element, accuracy, -1, -1, true, isSynthetic, reference);", "+", "-\tint rule = SearchPattern.R_EXACT_MATCH;", "-\tint refinedAccuracy = accuracy;", "+\t\t// Update match regarding constructor type arguments", "-\t\trefinedAccuracy = refineAccuracy(accuracy, parameterizedMethodBinding.typeArguments, locator, this.pattern.constructorArguments, this.pattern.hasConstructorParameters());", "-\t\t", "+\t\tmatch.setRaw(parameterizedMethodBinding.isRaw);", "+\t\tTypeBinding[] typeBindings = parameterizedMethodBinding.isRaw ? null : parameterizedMethodBinding.typeArguments;", "+\t\tupdateMatch(typeBindings, locator, this.pattern.constructorArguments, this.pattern.hasConstructorParameters());", "+", "+\t\t// Update match regarding declaring class type arguments", "-\t\t\t\trefinedAccuracy = refineAccuracy(accuracy, parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);", "+\t\t\t\tupdateMatch(parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);", "-\t\t\t\trefinedAccuracy = refineAccuracy(refinedAccuracy, parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);", "+\t\t\t\tupdateMatch(parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);", "-\t\t\tif (refinedAccuracy == -1) return;", "-\t\t\trule = SearchPattern.R_ERASURE_MATCH;", "+\t\t\tmatch.setRule(SearchPattern.R_ERASURE_MATCH);", "+", "+\t\t// Update match regarding constructor parameters", "+\t\t// TODO ? (frederic)", "+\t\t// Update match regarding declaring class type arguments", "-\t\t\t\trefinedAccuracy = refineAccuracy(refinedAccuracy, parameterizedBinding, new char[][][] {this.pattern.constructorArguments}, this.pattern.hasTypeParameters(), 0, locator);", "+\t\t\t\tupdateMatch(parameterizedBinding, new char[][][] {this.pattern.constructorArguments}, this.pattern.hasTypeParameters(), 0, locator);", "-\t\t\t\trefinedAccuracy = refineAccuracy(refinedAccuracy, parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);", "+\t\t\t\tupdateMatch(parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);", "-\t\t\tif (refinedAccuracy == -1) return;", "-\t\t\trule = SearchPattern.R_ERASURE_MATCH;", "+\t\t\tmatch.setRule(SearchPattern.R_ERASURE_MATCH);", "+", "+\t\t// Update match regarding constructor parameters", "+\t\t// TODO ? (frederic)", "-\t\trule = SearchPattern.R_ERASURE_MATCH;", "+\t\tmatch.setRule(SearchPattern.R_ERASURE_MATCH);", "-\tboolean report = refinedAccuracy != -1; // impossible match", "-\tif (report && (refinedAccuracy & SearchPattern.R_ERASURE_MATCH) != 0) { // erasure match", "-\t\tif ((refinedAccuracy & SearchPattern.R_EQUIVALENT_MATCH) != 0) { // raw match", "-\t\t\treport = this.isEquivalentMatch || this.isErasureMatch; // report only if pattern is equivalent or erasure", "-\t\t} else {", "-\t\t\treport = this.isErasureMatch; // report only if pattern is erasure", "-\t\t}", "-\t}", "-\telse if (report && (refinedAccuracy & SearchPattern.R_EQUIVALENT_MATCH) != 0) { // equivalent match", "-\t\treport  = this.isEquivalentMatch || this.isErasureMatch; // report only if pattern is equivalent or erasure", "-\t}", "+\tif (match.getRule() == 0) return; // impossible match", "+\tboolean report = (this.isErasureMatch && match.isErasure()) || (this.isEquivalentMatch && match.isEquivalent()) || match.isExact();", "-", "-\t// Set rule", "-\tif (rule != SearchPattern.R_ERASURE_MATCH) {", "-\t\trule |= refinedAccuracy & RULE_MASK;", "-\t}", "-\trefinedAccuracy = refinedAccuracy & (~RULE_MASK);", "-\tSearchMatch match = locator.newMethodReferenceMatch(element,", "-\t\t\taccuracy,", "-\t\t\toffset,", "-\t\t\treference.sourceEnd - offset + 1,", "-\t\t\ttrue, //isConstructor,", "-\t\t\tisSynthetic,", "-\t\t\treference);", "-\tmatch.setMatchRule(rule);", "+\tmatch.setOffset(offset);", "+\tmatch.setLength(reference.sourceEnd - offset + 1);"]}], "num": 58988}