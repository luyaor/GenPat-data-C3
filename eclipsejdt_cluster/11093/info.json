{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "073c21179f3c1e719738ef2268ae79df", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34314b8340001052d2580b78b33ab920", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "e1454516411e21c76afb7797ea67208e4fc9c49d", "commitAfterChange": "85e7f681aa7d70ec863df3c9b4c8ff252b7d94c0", "methodNumberBeforeChange": 72, "methodNumberAfterChange": 72, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\t\t\t\tMethodBinding method2 = visible[j];", "-\t\t\t\t\tif (!visible[j].tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters)) {", "-\t\t\t\t\t\tif (method.isVarargs() && visible[j].isVarargs()) {", "+\t\t\t\t\tif (!method2.tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters)) {", "+\t\t\t\t\t\tif (method.isVarargs() && method2.isVarargs()) {", "-\t\t\t\t\t\t\tif (paramLength == visible[j].parameters.length && paramLength == argumentTypes.length + 1) {", "-\t\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) visible[j].parameters[paramLength - 1]).elementsType();", "+\t\t\t\t\t\t\tif (paramLength == method2.parameters.length && paramLength == argumentTypes.length + 1) {", "+\t\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) method2.parameters[paramLength - 1]).elementsType();", "+\t\t\t\t\t} else if (method.hasSubstitutedParameters() && method.isAbstract() == method2.isAbstract()) { // must both be abstract or concrete, not one of each", "+\t\t\t\t\t\tif (method.areParametersEqual(method2)) {", "+\t\t\t\t\t\t\t// its possible with 2 abstract methods that one does not inherit from the other", "+\t\t\t\t\t\t\t// need to find their methods from the receiver type", "+\t\t\t\t\t\t\tMethodBinding original = method.original();", "+\t\t\t\t\t\t\tMethodBinding original2 = method2.original();", "+\t\t\t\t\t\t\tif (original.areParameterErasuresEqual(original2)) continue;", "+\t\t\t\t\t\t\tReferenceBinding receiverType = (ReferenceBinding) ((MessageSend) invocationSite).actualReceiverType;", "+\t\t\t\t\t\t\tif (receiverType != method.declaringClass) {", "+\t\t\t\t\t\t\t\tReferenceBinding superType = ((ReferenceBinding) receiverType.erasure()).findSuperTypeErasingTo(original.declaringClass);", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "+\t\t\t\t\t\t\t\t\t\toriginal = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (receiverType != method2.declaringClass) {", "+\t\t\t\t\t\t\t\tReferenceBinding superType = ((ReferenceBinding) receiverType.erasure()).findSuperTypeErasingTo(original2.declaringClass);", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original2.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "+\t\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!original.areParametersEqual(original2))", "+\t\t\t\t\t\t\t\tcontinue nextVisible; // cannot be substituted from 2 different type variables", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "45445cf8a2273e0b9f4650cf8d07e5d4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/TestingEnvironment.java", "commitBeforeChange": "dade23c0ca1cb5b996dfae1d1cfc189d06d41a6f", "commitAfterChange": "b9f6281b56af6781d8bb8cc727077eb3dccaebba", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic Problem[] getProblemsFor(IPath path)", "signatureAfterChange": " \tpublic Problem[] getProblemsFor(IPath path)", "diff": ["-\t\treturn getProblemsFor(path, false);", "-\t}", "+\t\t\t\tproblems.add(new Problem(markers[i]));", "+\t\t\t\tproblems.add(new Problem(markers[i]));", "+\t\t\t\tproblems.add(new Problem(markers[i]));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9a26cae27e7c281b7a011e8d5b6358a4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java", "commitBeforeChange": "1c3577f5abe07ca9a1f5e8ed95ec7cecb20f5290", "commitAfterChange": "007f2027ff425d194812a64dbd50790ef7383015", "methodNumberBeforeChange": 777, "methodNumberAfterChange": 777, "signatureBeforeChange": "  \tpublic void testModifiers()", "signatureAfterChange": "  \tpublic void testModifiers()", "diff": ["-\t\tint[] mods =", "+\t\tfinal int[] mods =", "+\t\t\ttry {", "+\t\t\t\tast.newModifiers(Modifier.NONE);", "+\t\t\t\tassertTrue(false);", "+\t\t\t} catch (UnsupportedOperationException e) {", "+\t\t\t\t// pass", "+\t\t\t}", "+\t\t\t// skip rest of tests", "+\t\t", "+\t\t// JLS3 only", "-\t\tModifier.ModifierKeyword[] known = {", "+\t\tfinal Modifier.ModifierKeyword[] known = {", "+\t\t// check AST.newModifiers(flags)", "+\t\tfor (int i = 0; i < mods.length; i++) {", "+\t\t\tint m = mods[i];", "+\t\t\tList result = ast.newModifiers(m);", "+\t\t\tassertEquals(1, result.size());", "+\t\t\tModifier modNode = (Modifier) result.get(0);", "+\t\t\tassertEquals(m, modNode.getKeyword().toFlagValue());", "+\t\t}", "+\t\t", "+\t\t// check AST.newModifiers ordering", "+\t\tfinal Modifier.ModifierKeyword[] expectedOrder = {", "+\t\t\t\tModifier.ModifierKeyword.PUBLIC_KEYWORD,", "+\t\t\t\tModifier.ModifierKeyword.PROTECTED_KEYWORD,", "+\t\t\t\tModifier.ModifierKeyword.PRIVATE_KEYWORD,", "+\t\t\t\tModifier.ModifierKeyword.ABSTRACT_KEYWORD,", "+\t\t\t\tModifier.ModifierKeyword.STATIC_KEYWORD,", "+\t\t\t\tModifier.ModifierKeyword.FINAL_KEYWORD,", "+\t\t\t\tModifier.ModifierKeyword.SYNCHRONIZED_KEYWORD,", "+\t\t\t\tModifier.ModifierKeyword.NATIVE_KEYWORD,", "+\t\t\t\tModifier.ModifierKeyword.STRICTFP_KEYWORD,", "+\t\t\t\tModifier.ModifierKeyword.TRANSIENT_KEYWORD,", "+\t\t\t\tModifier.ModifierKeyword.VOLATILE_KEYWORD,", "+\t\t\t};", "+\t\tint all = 0;", "+\t\tfor (int i = 0; i < mods.length; i++) {", "+\t\t\tall |= mods[i];", "+\t\t}", "+\t\tList result = ast.newModifiers(all);", "+\t\tassertEquals(expectedOrder.length, result.size());", "+\t\tfor (int i = 0; i< expectedOrder.length; i++) {", "+\t\t\tassertEquals(expectedOrder[i], ((Modifier) result.get(i)).getKeyword());", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4093272f005c2aa8cff22684a7e725f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java", "commitBeforeChange": "0f841a0360389f0f91aef636ca6531276c4a074d", "commitAfterChange": "4e57894c46e6fdc6da393db7e5519e070814fd68", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tprotected ASTNode[] buildASTs(String newContents, ICompilationUnit cu, boolean reportErrors) throws JavaModelException", "signatureAfterChange": "  \tprivate ASTNode[] buildASTs(String newContents, ICompilationUnit cu, int flags) throws JavaModelException", "diff": ["+", "+\tprivate ASTNode[] buildASTs(String newContents, ICompilationUnit cu, int flags) throws JavaModelException {", "+\t\tMarkerInfo markerInfo;", "+\t\tif (newContents == null) {", "+\t\t\tmarkerInfo = new MarkerInfo(cu.getSource());", "+\t\t} else {", "+\t\t\tmarkerInfo = new MarkerInfo(newContents);", "+\t\t}", "+\t\tnewContents = markerInfo.source;", "+", "+\t\tCompilationUnit unit;", "+\t\tif (cu.isWorkingCopy()) {", "+\t\t\tcu.getBuffer().setContents(newContents);", "+\t\t\tunit = cu.reconcile(AST.JLS3, flags, null, null);", "+\t\t} else {", "+\t\t\tIBuffer buffer = cu.getBuffer();", "+\t\t\tbuffer.setContents(newContents);", "+\t\t\tbuffer.save(null, false);", "+\t\t\t", "+\t\t\tASTParser parser = ASTParser.newParser(AST.JLS3);", "+\t\t\tparser.setSource(cu);", "+\t\t\tparser.setResolveBindings(true);", "+\t\t\tparser.setStatementsRecovery((flags & ICompilationUnit.ENABLE_STATEMENTS_RECOVERY) != 0);", "+\t\t\tunit = (CompilationUnit) parser.createAST(null);", "+\t\t}", "+\t\t", "+\t\tif ((flags & ICompilationUnit.FORCE_PROBLEM_DETECTION) != 0) {", "+\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\tIProblem[] problems = unit.getProblems();", "+\t\t\tfor (int i = 0, length = problems.length; i < length; i++)", "+\t\t\t\tUtil.appendProblem(buffer, problems[i], newContents.toCharArray(), i+1);", "+\t\t\tif (buffer.length() > 0)", "+\t\t\t\tSystem.err.println(buffer.toString());", "+\t\t}", "+", "+\t\tASTNode[] nodes = findNodes(unit, markerInfo);", "+\t\tif (nodes.length == 0)", "+\t\t\treturn new ASTNode[] {unit};", "+\t\treturn nodes;", "+\t}"]}], "num": 11093}