{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0648e6e1fa46f628a33ec15c1fa37073", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66aa8ec1f9272a2a8c711c0c37d2905a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "8b9431052e3d61392fc8179c11535d264307c499", "commitAfterChange": "c9c353b1f3633c7934ab02e6b5f4d6f7b6d921d9", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  void checkMethods()", "signatureAfterChange": "  void checkMethods()", "diff": ["-\t\t\tif (index > 0)", "-\t\t\t\tcheckInheritedMethods(matchingInherited, index + 1, isOverridden, isInherited); // pass in the length of matching", "+\t\t\tif (index > 0) {", "+\t\t\t\tint length = index + 1;", "+\t\t\t\tboolean[] matchingIsOverridden;", "+\t\t\t\tboolean[] matchingIsInherited;", "+\t\t\t\tif (length != inheritedLength) { // transfer inherited & overridden status to align with subset of methods.", "+\t\t\t\t\tmatchingIsOverridden = new boolean[length];", "+\t\t\t\t\tmatchingIsInherited = new boolean[length];", "+\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\tfor (int k = 0; k < inheritedLength; k++) {", "+\t\t\t\t\t\t\tif (matchingInherited[j] == inherited[k]) {", "+\t\t\t\t\t\t\t\tmatchingIsOverridden[j] = isOverridden[k];", "+\t\t\t\t\t\t\t\tmatchingIsInherited[j] = isInherited[k];", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tmatchingIsOverridden = isOverridden;", "+\t\t\t\t\tmatchingIsInherited = isInherited;", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tcheckInheritedMethods(matchingInherited, length, matchingIsOverridden, matchingIsInherited); // pass in the length of matching", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "88222149d4990bc98d5d385662ee19d7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java", "commitBeforeChange": "fb6bfab81c6e6aeb7fa0724cc6e6c643983f63cf", "commitAfterChange": "fb2eb7acd5b5f912d44476dd03c9e941ddf18d2f", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void checkTaskTag(int commentStart, int commentEnd) throws InvalidInputException", "signatureAfterChange": " public void checkTaskTag(int commentStart, int commentEnd) throws InvalidInputException", "diff": ["+\tboolean containsEmptyTask = false;", "-\t\tif (msgStart == end)", "-\t\t\tcontinue; // empty", "+\t\tif (msgStart == end) {", "+\t\t\t// if the description is empty, we might want to see if two tags are not sharing the same message", "+\t\t\t// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=110797", "+\t\t\tcontainsEmptyTask = true;", "+\t\t\tcontinue;", "+\t\t}", "+\tif (containsEmptyTask) {", "+\t\tfor (int i = foundTaskIndex, max = this.foundTaskCount; i < max; i++) {", "+\t\t\tif (this.foundTaskMessages[i].length == 0) {", "+\t\t\t\tloop: for (int j = i + 1; j < max; j++) {", "+\t\t\t\t\tif (this.foundTaskMessages[j].length != 0) {", "+\t\t\t\t\t\tthis.foundTaskMessages[i] = this.foundTaskMessages[j];", "+\t\t\t\t\t\tthis.foundTaskPositions[i][1] = this.foundTaskPositions[j][1];", "+\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e2f7a72f8bd71db56f5893eb7b73e1d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java", "commitBeforeChange": "fb6bfab81c6e6aeb7fa0724cc6e6c643983f63cf", "commitAfterChange": "fb2eb7acd5b5f912d44476dd03c9e941ddf18d2f", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void checkTaskTag(int commentStart, int commentEnd) throws InvalidInputException", "signatureAfterChange": " public void checkTaskTag(int commentStart, int commentEnd) throws InvalidInputException", "diff": ["+\tboolean containsEmptyTask = false;", "-\t\tif (msgStart == end)", "-\t\t\tcontinue; // empty", "+\t\tif (msgStart == end) {", "+\t\t\t// if the description is empty, we might want to see if two tags are not sharing the same message", "+\t\t\t// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=110797", "+\t\t\tcontainsEmptyTask = true;", "+\t\t\tcontinue;", "+\t\t}", "+\t}", "+\tif (containsEmptyTask) {", "+\t\tfor (int i = foundTaskIndex, max = this.foundTaskCount; i < max; i++) {", "+\t\t\tif (this.foundTaskMessages[i].length == 0) {", "+\t\t\t\tloop: for (int j = i + 1; j < max; j++) {", "+\t\t\t\t\tif (this.foundTaskMessages[j].length != 0) {", "+\t\t\t\t\t\tthis.foundTaskMessages[i] = this.foundTaskMessages[j];", "+\t\t\t\t\t\tthis.foundTaskPositions[i][1] = this.foundTaskPositions[j][1];", "+\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f66b37ea5a7d4eb6deec337dd421c36", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "ef0d751764a03bfb7b7e9d8838fc454e1e51fa0c", "commitAfterChange": "878eb7333d4b0eef7a3f9e4be62a4fad044a7734", "methodNumberBeforeChange": 72, "methodNumberAfterChange": 72, "signatureBeforeChange": " \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, InvocationSite invocationSite)", "signatureAfterChange": " \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, InvocationSite invocationSite) {", "+\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "+\t\tboolean varargsStatus = visible[0].isVarargs();", "+\t\tfor (int i = 1; i < visibleSize; i++) {", "+\t\t\tif (visible[i].isVarargs() != varargsStatus) {", "+\t\t\t\t// visible is a mix of fixed & variable arity methods, so double check the varargs methods, but consider their vararg argument as a fixed array", "+\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleSize];", "+\t\t\t\tint newSize = 0;", "+\t\t\t\tfor (int j = 0; j < visibleSize; j++)", "+\t\t\t\t\tif (!visible[j].isVarargs() || computeCompatibleMethod(visible[j], argumentTypes, invocationSite, false) != null)", "+\t\t\t\t\t\ttemp[newSize++] = visible[j];", "+\t\t\t\tvisible = temp;", "+\t\t\t\tvisibleSize = newSize;", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f8263b2fb5f4a92e848a0a413f074fd3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "572021b99f292f39a76e81c2ea834ac6a839b00b", "commitAfterChange": "727d8ca46d64642ad4f629f81ba37e76e7ae8c85", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprivate void adaptRegions()", "signatureAfterChange": " \tprivate void adaptRegions()", "diff": ["-\t\t\t\t\t// adapt only javadoc or block comments. Since fix for bug", "+\t\t\t\t\t// adapt only javadoc or block commments. Since fix for bug", "+\t\t\t\t\t// include also the indentation edit just before the comment if any", "+\t\t\t\t\tfor (int j=0; j<this.editsIndex; j++) {", "+\t\t\t\t\t\tint editOffset = this.edits[j].offset;", "+\t\t\t\t\t\tint editEnd = editOffset + this.edits[j].length;", "+\t\t\t\t\t\tif (editEnd == adaptedOffset) {", "+\t\t\t\t\t\t\tif (j > 0 && this.edits[j].replacement.trim().length() == 0) {", "+\t\t\t\t\t\t\t\tadaptedLength += adaptedOffset - this.edits[j].offset;", "+\t\t\t\t\t\t\t\tadaptedOffset = editOffset;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (editEnd > adaptedOffset) {", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}"]}], "num": 49365}