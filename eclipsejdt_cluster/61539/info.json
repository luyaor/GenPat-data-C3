{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b97c6b14218815dd313cffd31d7f5168", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "064c03397516c9369ad0166ef911b843", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java", "commitBeforeChange": "7ed8fb3f335f5407b01a590a0c668733ebc19aa6", "commitAfterChange": "3b0a2063dbdc61567393530ebaab7037ae911123", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " private synchronized HashtableOfObject readCategoryTable(char[] categoryName, boolean cacheDocNumbers) throws IOException", "signatureAfterChange": " private synchronized HashtableOfObject readCategoryTable(char[] categoryName, boolean readDocNumbers) throws IOException", "diff": ["-private synchronized HashtableOfObject readCategoryTable(char[] categoryName, boolean cacheDocNumbers) throws IOException {", "+private synchronized HashtableOfObject readCategoryTable(char[] categoryName, boolean readDocNumbers) throws IOException {", "-\t\tif (cacheDocNumbers)", "+\t\tif (readDocNumbers)", "+\t\tint largeArraySize = 256;", "-\t\t\tif (arrayOffset > 0) {", "+\t\t\t// if arrayOffset is:", "+\t\t\t//\t\t<= 0 then the array size == 1 with the value -> -arrayOffset", "+\t\t\t//\t\t> 1 & < 256 then the size of the array is > 1 & < 256, the document array follows immediately", "+\t\t\t//\t\t256 if the array size >= 256 followed by another int which is the offset to the array (written prior to the table)", "+\t\t\tif (arrayOffset <= 0) {", "+\t\t\t\tcategoryTable.put(word, new int[] {-arrayOffset}); // store 1 element array by negating documentNumber", "+\t\t\t} else if (arrayOffset < largeArraySize) {", "+\t\t\t\tcategoryTable.put(word, readDocumentArray(stream, arrayOffset)); // read in-lined array providing size", "+\t\t\t} else {", "+\t\t\t\tarrayOffset = stream.readInt(); // read actual offset", "-\t\t\t} else {", "-\t\t\t\tcategoryTable.put(word, new int[] {-arrayOffset}); // stored a 1 element array by negating the documentNumber", "-\t\t\t\tcategoryTable.put(matchingWords[i], readDocumentArray(stream));", "+\t\t\t\tcategoryTable.put(matchingWords[i], readDocumentArray(stream, stream.readInt()));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e8e30904abcb901bc782645b01a12fa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java", "commitBeforeChange": "7ed8fb3f335f5407b01a590a0c668733ebc19aa6", "commitAfterChange": "3b0a2063dbdc61567393530ebaab7037ae911123", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " private void writeCategoryTable(char[] categoryName, HashtableOfObject wordsToDocs, DataOutputStream stream) throws IOException", "signatureAfterChange": " private void writeCategoryTable(char[] categoryName, HashtableOfObject wordsToDocs, DataOutputStream stream) throws IOException", "diff": ["-\t// append the file with the document number arrays & remember the offsets", "+\t// the format of a category table is as follows:", "+\t// any document number arrays with >= 256 elements are written before the table (the offset to each array is remembered)", "+\t// then the number of word->int[] pairs in the table is written", "+\t// for each word -> int[] pair, the word is written followed by:", "+\t//\t\tan int <= 0 if the array size == 1", "+\t//\t\tan int > 1 & < 256 for the size of the array if its > 1 & < 256, the document array follows immediately", "+\t//\t\t256 if the array size >= 256 followed by another int which is the offset to the array (written prior to the table)", "+", "+\tint largeArraySize = 256;", "-\t\t\tint[] documentNumbers = o instanceof int[] ? (int[]) o : ((IntList) o).asArray();", "-\t\t\tint length = documentNumbers.length;", "-\t\t\tif (length == 1) {", "-\t\t\t\tvalues[i] = new Integer(-documentNumbers[0]); // store an array of 1 element by negating the documentNumber (can be zero)", "-\t\t\t} else {", "+\t\t\tif (o instanceof IntList)", "+\t\t\t\to = values[i] = ((IntList) values[i]).asArray();", "+\t\t\tint[] documentNumbers = (int[]) o;", "+\t\t\tif (documentNumbers.length >= largeArraySize) {", "-\t// append the file with the arrays followed by the words & offsets", "-\t\tif (words[i] != null) {", "+\t\tObject o = values[i];", "+\t\tif (o != null) {", "-\t\t\tstream.writeInt(((Integer) values[i]).intValue()); // offset in the file of the array of document numbers", "+\t\t\tif (o instanceof int[]) {", "+\t\t\t\tint[] documentNumbers = (int[]) o;", "+\t\t\t\tif (documentNumbers.length == 1)", "+\t\t\t\t\tstream.writeInt(-documentNumbers[0]); // store an array of 1 element by negating the documentNumber (can be zero)", "+\t\t\t\telse", "+\t\t\t\t\twriteDocumentNumbers(documentNumbers, stream);", "+\t\t\t} else {", "+\t\t\t\tstream.writeInt(largeArraySize); // mark to identify that an offset follows", "+\t\t\t\tstream.writeInt(((Integer) o).intValue()); // offset in the file of the array of document numbers", "+\t\t\t}"]}], "num": 61539}