{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b7fe257802692578a137e265759a4823", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f50b579593baa6c2e49620caba7817d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "c4891fe70e58ba287a7bbc2f099afcf753974e95", "commitAfterChange": "f50252d848b2855a0e3b480a92607978678762ce", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "signatureAfterChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "diff": ["+\t\tchar[] tagName = this.scanner.getCurrentIdentifierSource();", "-\t\tchar pc = peekChar();", "-\t\tboolean validTag = false;", "-\t\tswitch (token) {", "-\t\t\tcase TerminalTokens.TokenNameIdentifier:", "-\t\t\tcase TerminalTokens.TokenNamereturn:", "-\t\t\tcase TerminalTokens.TokenNamethrows:", "-\t\t\tcase TerminalTokens.TokenNameabstract:", "-\t\t\tcase TerminalTokens.TokenNameassert:", "-\t\t\tcase TerminalTokens.TokenNameboolean:", "-\t\t\tcase TerminalTokens.TokenNamebreak:", "-\t\t\tcase TerminalTokens.TokenNamebyte:", "-\t\t\tcase TerminalTokens.TokenNamecase:", "-\t\t\tcase TerminalTokens.TokenNamecatch:", "-\t\t\tcase TerminalTokens.TokenNamechar:", "-\t\t\tcase TerminalTokens.TokenNameclass:", "-\t\t\tcase TerminalTokens.TokenNamecontinue:", "-\t\t\tcase TerminalTokens.TokenNamedefault:", "-\t\t\tcase TerminalTokens.TokenNamedo:", "-\t\t\tcase TerminalTokens.TokenNamedouble:", "-\t\t\tcase TerminalTokens.TokenNameelse:", "-\t\t\tcase TerminalTokens.TokenNameextends:", "-\t\t\tcase TerminalTokens.TokenNamefalse:", "-\t\t\tcase TerminalTokens.TokenNamefinal:", "-\t\t\tcase TerminalTokens.TokenNamefinally:", "-\t\t\tcase TerminalTokens.TokenNamefloat:", "-\t\t\tcase TerminalTokens.TokenNamefor:", "-\t\t\tcase TerminalTokens.TokenNameif:", "-\t\t\tcase TerminalTokens.TokenNameimplements:", "-\t\t\tcase TerminalTokens.TokenNameimport:", "-\t\t\tcase TerminalTokens.TokenNameinstanceof:", "-\t\t\tcase TerminalTokens.TokenNameint:", "-\t\t\tcase TerminalTokens.TokenNameinterface:", "-\t\t\tcase TerminalTokens.TokenNamelong:", "-\t\t\tcase TerminalTokens.TokenNamenative:", "-\t\t\tcase TerminalTokens.TokenNamenew:", "-\t\t\tcase TerminalTokens.TokenNamenull:", "-\t\t\tcase TerminalTokens.TokenNamepackage:", "-\t\t\tcase TerminalTokens.TokenNameprivate:", "-\t\t\tcase TerminalTokens.TokenNameprotected:", "-\t\t\tcase TerminalTokens.TokenNamepublic:", "-\t\t\tcase TerminalTokens.TokenNameshort:", "-\t\t\tcase TerminalTokens.TokenNamestatic:", "-\t\t\tcase TerminalTokens.TokenNamestrictfp:", "-\t\t\tcase TerminalTokens.TokenNamesuper:", "-\t\t\tcase TerminalTokens.TokenNameswitch:", "-\t\t\tcase TerminalTokens.TokenNamesynchronized:", "-\t\t\tcase TerminalTokens.TokenNamethis:", "-\t\t\tcase TerminalTokens.TokenNamethrow:", "-\t\t\tcase TerminalTokens.TokenNametransient:", "-\t\t\tcase TerminalTokens.TokenNametrue:", "-\t\t\tcase TerminalTokens.TokenNametry:", "-\t\t\tcase TerminalTokens.TokenNamevoid:", "-\t\t\tcase TerminalTokens.TokenNamevolatile:", "-\t\t\tcase TerminalTokens.TokenNamewhile:", "-\t\t\t\tvalidTag= true;", "-\t\t}", "-\t\ttagNameToken: while (token != TerminalTokens.TokenNameEOF && this.index < this.scanner.eofPosition) {", "-\t\t\t// !, \", #, %, &, ', -, :, <, >, * chars and spaces are not allowed in tag names", "-\t\t\tswitch (pc) {", "-\t\t\t\tcase '}':", "-\t\t\t\tcase '*': // break for '*' as this is perhaps the end of comment (bug 65288)", "-\t\t\t\t\tbreak tagNameToken;", "-\t\t\t\tcase '!':", "-\t\t\t\tcase '#':", "-\t\t\t\tcase '%':", "-\t\t\t\tcase '&':", "-\t\t\t\tcase '\\'':", "-\t\t\t\tcase '\"':", "-\t\t\t\tcase ':':", "-\t\t\t\tcase '<':", "-\t\t\t\tcase '>':", "-\t\t\t\t\tvalidTag = false;", "-\t\t\t\t\t// fall thru next case to read character and resynch scanner", "-\t\t\t\tcase '-': // allowed in tag names as this character is often used in doclets (bug 68087)", "-\t\t\t\t\treadChar();", "-\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\tthis.scanner.currentPosition = this.index;", "-\t\t\t\t\tbreak;", "-\t\t\t\tdefault:", "-\t\t\t\t\tif (pc == ' ' || Character.isWhitespace(pc)) break tagNameToken;", "-\t\t\t\t\ttoken = readTokenAndConsume();", "-\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\tbreak;", "+\t\tif (this.scanner.currentCharacter != ' ' && !Character.isWhitespace(this.scanner.currentCharacter)) {", "+\t\t\tboolean validTag = true;", "+\t\t\ttagNameToken: while (token != TerminalTokens.TokenNameEOF && this.index < this.scanner.eofPosition) {", "+\t\t\t\tint length = tagName.length;", "+\t\t\t\t// !, \", #, %, &, ', -, :, <, >, * chars and spaces are not allowed in tag names", "+\t\t\t\tswitch (this.scanner.currentCharacter) {", "+\t\t\t\t\tcase '}':", "+\t\t\t\t\tcase '*': // break for '*' as this is perhaps the end of comment (bug 65288)", "+\t\t\t\t\t\tbreak tagNameToken;", "+\t\t\t\t\tcase '!':", "+\t\t\t\t\tcase '#':", "+\t\t\t\t\tcase '%':", "+\t\t\t\t\tcase '&':", "+\t\t\t\t\tcase '\\'':", "+\t\t\t\t\tcase '\"':", "+\t\t\t\t\tcase ':':", "+\t\t\t\t\tcase '<':", "+\t\t\t\t\tcase '>':", "+\t\t\t\t\tcase '@':", "+\t\t\t\t\t\tvalidTag = false;", "+\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tthis.index = this.scanner.currentPosition;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase '-': // allowed in tag names as this character is often used in doclets (bug 68087)", "+\t\t\t\t\t\tSystem.arraycopy(tagName, 0, tagName = new char[length+1], 0, length);", "+\t\t\t\t\t\ttagName[length] = this.scanner.currentCharacter;", "+\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tthis.index = this.scanner.currentPosition;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tif (this.scanner.currentCharacter == ' ' || Character.isWhitespace(this.scanner.currentCharacter)) {", "+\t\t\t\t\t\t\tbreak tagNameToken;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\ttoken = readTokenAndConsume();", "+\t\t\t\t\t\tchar[] ident = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\tSystem.arraycopy(tagName, 0, tagName = new char[length+ident.length], 0, length);", "+\t\t\t\t\t\tSystem.arraycopy(ident, 0, tagName, length, ident.length);", "+\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tthis.scanner.getNextChar();", "-\t\t\tpc = peekChar();", "+\t\t\tif (!validTag) {", "+\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(this.tagSourceStart, this.tagSourceEnd);", "+\t\t\t\treturn false;", "+\t\t\t}", "-\t\tif (!validTag) {", "-\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(this.tagSourceStart, this.tagSourceEnd);", "-\t\t\treturn false;", "-\t\t}", "-\t\tint length = this.tagSourceEnd-this.tagSourceStart+1;", "+\t\tint length = tagName.length;", "-", "+\t", "-\t\tchar firstChar = this.source[this.tagSourceStart];", "-\t\t\t\tswitch (firstChar) {", "+\t\t\t\tswitch (tagName[0]) {", "-\t\t\t\t\t\tif (length == TAG_CATEGORY_LENGTH && CharOperation.equals(TAG_CATEGORY, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_CATEGORY_LENGTH && CharOperation.equals(TAG_CATEGORY, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_DEPRECATED_LENGTH && CharOperation.equals(TAG_DEPRECATED, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_DEPRECATED_LENGTH && CharOperation.equals(TAG_DEPRECATED, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_EXCEPTION_LENGTH && CharOperation.equals(TAG_EXCEPTION, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_EXCEPTION_LENGTH && CharOperation.equals(TAG_EXCEPTION, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_INHERITDOC_LENGTH && CharOperation.equals(TAG_INHERITDOC, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_INHERITDOC_LENGTH && CharOperation.equals(TAG_INHERITDOC, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_LINK_LENGTH && CharOperation.equals(TAG_LINK, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_LINK_LENGTH && CharOperation.equals(TAG_LINK, tagName)) {", "-\t\t\t\t\t\t} else if (length == TAG_LINKPLAIN_LENGTH && CharOperation.equals(TAG_LINKPLAIN, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\t} else if (length == TAG_LINKPLAIN_LENGTH && CharOperation.equals(TAG_LINKPLAIN, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_PARAM_LENGTH && CharOperation.equals(TAG_PARAM, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_PARAM_LENGTH && CharOperation.equals(TAG_PARAM, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_SEE_LENGTH && this.source[this.tagSourceStart+1] == TAG_SEE[1] &&  this.source[this.tagSourceEnd] == TAG_SEE[2]) {", "+\t\t\t\t\t\tif (length == TAG_SEE_LENGTH && CharOperation.equals(TAG_SEE, tagName)) {", "-\t\t\t\t\t\tif (this.sourceLevel >= ClassFileConstants.JDK1_5 && length == TAG_VALUE_LENGTH && CharOperation.equals(TAG_VALUE, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (this.sourceLevel >= ClassFileConstants.JDK1_5 && length == TAG_VALUE_LENGTH && CharOperation.equals(TAG_VALUE, tagName)) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "628a9bdb6df3795f05ea612b580affc8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "875cc8d42787c90738d8dc077a25eb401e9e38f9", "commitAfterChange": "adfd584faf146517cb3e86f9f2b585f2851a3630", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod)", "diff": ["-}", "-void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length) {", "-\t// methods includes the inherited methods that the currentMethod must comply with", "-\t// likely only 1 but could be more if mutiple declared supertypes define the method (1 superclass & 1 to many declared interfaces)", "-\tnextMethod : for (int i = length; --i >= 0;) {", "-\t\tMethodBinding inheritedMethod = methods[i];", "-\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "-\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "-\t\t\tcontinue nextMethod;", "-\t\t}", "-", "-\t\t// curentMethod is always resolved as its defined by the source type BUT the inheritedMethod may not be", "-\t\t// so now with generics, the inheritedMethod should be resolved since we don't want to waste time dealing", "-\t\t// with Unresolved types over & over", "-\t\tif (inheritedMethod.declaringClass instanceof BinaryTypeBinding)", "-\t\t\t((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);", "-", "-\t\tif (checkForNameClash(currentMethod, inheritedMethod)) {", "-\t\t\tthis.problemReporter(currentMethod).methodNameClash(currentMethod, inheritedMethod);", "-\t\t\tcontinue nextMethod;", "-\t\t}", "-", "-\t\tif (!currentMethod.isAbstract() && inheritedMethod.isAbstract()) {", "-\t\t\tif ((currentMethod.modifiers & CompilerModifiers.AccOverriding) == 0)", "-\t\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccImplementing;", "-\t\t} else {", "-\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccOverriding;", "-\t\t}", "-", "-\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType();", "-\t\tif (currentMethod.returnType != inheritedMethod.returnType) {", "-\t\t\t// can be [] of Class#RAW vs. Class<T>", "-\t\t\tif (!isReturnTypeSubstituable(currentMethod, inheritedMethod)) {", "-\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\t\t\tcontinue nextMethod;", "-\t\t\t}", "-", "-\t\t\tTypeBinding inheritedReturnType = inheritedMethod.returnType.leafComponentType();", "-\t\t\tTypeBinding returnType = currentMethod.returnType.leafComponentType();", "-\t\t\tif (inheritedReturnType.isRawType()) {", "-\t\t\t\tif (returnType.isParameterizedType() && hasBoundedParameters((ParameterizedTypeBinding) returnType)) {", "-\t\t\t\t\tthis.problemReporter(currentMethod).methodNameClash(currentMethod, inheritedMethod);", "-\t\t\t\t\tcontinue nextMethod;", "-\t\t\t} else if (inheritedReturnType.isParameterizedType()) {", "-\t\t\t\tif (!returnType.isParameterizedType()) ", "-\t\t\t\t\tthis.problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, inheritedMethod, ((MethodDeclaration)currentMethod.sourceMethod()).returnType);", "-\t\t\t} else if (inheritedReturnType.isTypeVariable()) {", "-\t\t\t\tthis.problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, inheritedMethod,  ((MethodDeclaration)currentMethod.sourceMethod()).returnType);", "-\t\t\t}", "-\t\t\taddBridgeMethod = true;", "-\t\t}", "-", "-\t\tif (addBridgeMethod || inheritedMethod.hasSubstitutedParameters()) {", "-\t\t    MethodBinding original = inheritedMethod.original();", "-\t\t    if (!areReturnTypesEqual(original, currentMethod) || !areParametersEqual(original, currentMethod))", "-\t\t\t\tthis.type.addSyntheticBridgeMethod(original, currentMethod);", "-\t\t}", "-", "-\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "-\t\tif (inheritedMethod.isFinal())", "-\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "-\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-", "-\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "+}", "+MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod) {", "+\tif (inheritedMethod == null) return null;", "+", "+\t// due to hierarchy & compatibility checks, we need to ensure these 2 methods are resolved", "+\t// should we push these tests to where they're needed? returnType.isCompatibleWith && parameter isEquivalentTo ?", "+\tif (currentMethod.declaringClass instanceof BinaryTypeBinding)", "+\t\t((BinaryTypeBinding) currentMethod.declaringClass).resolveTypesFor(currentMethod);", "+\tif (inheritedMethod.declaringClass instanceof BinaryTypeBinding)", "+\t\t((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);", "+", "+\tTypeVariableBinding[] inheritedTypeVariables = inheritedMethod.typeVariables();", "+\tif (inheritedTypeVariables == NoTypeVariables) return inheritedMethod;", "+\tTypeVariableBinding[] typeVariables = currentMethod == null ? NoTypeVariables : currentMethod.typeVariables;", "+", "+\tint inheritedLength = inheritedTypeVariables.length;", "+\tint length = typeVariables.length;", "+\tTypeBinding[] arguments = new TypeBinding[inheritedLength];", "+\tif (inheritedLength <= length) {", "+\t\tSystem.arraycopy(typeVariables, 0, arguments, 0, inheritedLength);", "+\t} else {", "+\t\tSystem.arraycopy(typeVariables, 0, arguments, 0, length);", "+\t\tfor (int i = length; i < inheritedLength; i++)", "+\t\t\targuments[i] = inheritedTypeVariables[i].erasure();", "+\t}", "+\tParameterizedGenericMethodBinding substitute =", "+\t\tnew ParameterizedGenericMethodBinding(inheritedMethod, arguments, this.environment);", "+\tfor (int i = 0; i < inheritedLength; i++)", "+\t    if (!inheritedTypeVariables[i].boundCheck(substitute, arguments[i]))", "+\t    \treturn inheritedMethod; // incompatible due to bound check", "+   return substitute;", "+}"]}], "num": 34111}