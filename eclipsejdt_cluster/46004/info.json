{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3cff3d92c6c1d89f023f41bc4ef44bd9", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "262638bcf7f48abae6c21d70b12a04df", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "5d7b0ed4ccf6dc91337d9ac62f14ae585f547855", "commitAfterChange": "e706e02e84b0ab73a5fa0bab5675fe627a8c0157", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\t  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "\t  \tpublic void resolve(BlockScope upperScope)", "diff": ["-\t\tif (finallyBlock != null", "-\t\t\t&& finallyBlock.statements != null) {", "-", "-\t\t\tfinallyScope = new BlockScope(scope, false); // don't add it yet to parent scope", "-", "-\t\t\t// provision for returning and forcing the finally block to run", "-\t\t\tMethodScope methodScope = scope.methodScope();", "-", "-\t\t\t// the type does not matter as long as it is not a base type", "-\t\t\tthis.returnAddressVariable =", "-\t\t\t\tnew LocalVariableBinding(SecretReturnName, upperScope.getJavaLangObject(), AccDefault, false);", "-\t\t\tfinallyScope.addLocalVariable(returnAddressVariable);", "-\t\t\tthis.returnAddressVariable.constant = NotAConstant; // not inlinable", "-\t\t\tthis.subRoutineStartLabel = new Label();", "-", "-\t\t\tthis.anyExceptionVariable =", "-\t\t\t\tnew LocalVariableBinding(SecretAnyHandlerName, scope.getJavaLangThrowable(), AccDefault, false);", "-\t\t\tfinallyScope.addLocalVariable(this.anyExceptionVariable);", "-\t\t\tthis.anyExceptionVariable.constant = NotAConstant; // not inlinable", "-", "-\t\t\tif (!methodScope.isInsideInitializer()) {", "-\t\t\t\tMethodBinding methodBinding =", "-\t\t\t\t\t((AbstractMethodDeclaration) methodScope.referenceContext).binding;", "-\t\t\t\tif (methodBinding != null) {", "-\t\t\t\t\tTypeBinding methodReturnType = methodBinding.returnType;", "-\t\t\t\t\tif (methodReturnType.id != T_void) {", "-\t\t\t\t\t\tthis.secretReturnValue =", "-\t\t\t\t\t\t\tnew LocalVariableBinding(", "-\t\t\t\t\t\t\t\tSecretLocalDeclarationName,", "-\t\t\t\t\t\t\t\tmethodReturnType,", "-\t\t\t\t\t\t\t\tAccDefault,", "-\t\t\t\t\t\t\t\tfalse);", "-\t\t\t\t\t\tfinallyScope.addLocalVariable(this.secretReturnValue);", "-\t\t\t\t\t\tthis.secretReturnValue.constant = NotAConstant; // not inlinable", "+\t\tif (finallyBlock != null) {", "+\t\t\tif (finallyBlock.isEmptyBlock()) {", "+\t\t\t\tif ((finallyBlock.bits & UncommentedEmptyBlockMASK) != 0) {", "+\t\t\t\t\tscope.problemReporter().uncommentedEmptyBlock(finallyBlock);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tfinallyScope = new BlockScope(scope, false); // don't add it yet to parent scope", "+\t", "+\t\t\t\t// provision for returning and forcing the finally block to run", "+\t\t\t\tMethodScope methodScope = scope.methodScope();", "+\t", "+\t\t\t\t// the type does not matter as long as it is not a base type", "+\t\t\t\tthis.returnAddressVariable =", "+\t\t\t\t\tnew LocalVariableBinding(SecretReturnName, upperScope.getJavaLangObject(), AccDefault, false);", "+\t\t\t\tfinallyScope.addLocalVariable(returnAddressVariable);", "+\t\t\t\tthis.returnAddressVariable.constant = NotAConstant; // not inlinable", "+\t\t\t\tthis.subRoutineStartLabel = new Label();", "+\t", "+\t\t\t\tthis.anyExceptionVariable =", "+\t\t\t\t\tnew LocalVariableBinding(SecretAnyHandlerName, scope.getJavaLangThrowable(), AccDefault, false);", "+\t\t\t\tfinallyScope.addLocalVariable(this.anyExceptionVariable);", "+\t\t\t\tthis.anyExceptionVariable.constant = NotAConstant; // not inlinable", "+\t", "+\t\t\t\tif (!methodScope.isInsideInitializer()) {", "+\t\t\t\t\tMethodBinding methodBinding =", "+\t\t\t\t\t\t((AbstractMethodDeclaration) methodScope.referenceContext).binding;", "+\t\t\t\t\tif (methodBinding != null) {", "+\t\t\t\t\t\tTypeBinding methodReturnType = methodBinding.returnType;", "+\t\t\t\t\t\tif (methodReturnType.id != T_void) {", "+\t\t\t\t\t\t\tthis.secretReturnValue =", "+\t\t\t\t\t\t\t\tnew LocalVariableBinding(", "+\t\t\t\t\t\t\t\t\tSecretLocalDeclarationName,", "+\t\t\t\t\t\t\t\t\tmethodReturnType,", "+\t\t\t\t\t\t\t\t\tAccDefault,", "+\t\t\t\t\t\t\t\t\tfalse);", "+\t\t\t\t\t\t\tfinallyScope.addLocalVariable(this.secretReturnValue);", "+\t\t\t\t\t\t\tthis.secretReturnValue.constant = NotAConstant; // not inlinable", "+\t\t\t\t\t\t}", "+\t\t\t\tfinallyBlock.resolveUsing(finallyScope);", "+\t\t\t\t// force the finally scope to have variable positions shifted after its try scope and catch ones", "+\t\t\t\tfinallyScope.shiftScopes = new BlockScope[catchArguments == null ? 1 : catchArguments.length+1];", "+\t\t\t\tfinallyScope.shiftScopes[0] = tryScope;", "-\t\t\tfinallyBlock.resolveUsing(finallyScope);", "-\t\t\t// force the finally scope to have variable positions shifted after its try scope and catch ones", "-\t\t\tfinallyScope.shiftScopes = new BlockScope[catchArguments == null ? 1 : catchArguments.length+1];", "-\t\t\tfinallyScope.shiftScopes[0] = tryScope;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "abfdf7773816f243babf8096b773c25b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  public void resolve(BlockScope upperScope)", "diff": ["-\t", "-\tpublic void resolve(BlockScope upperScope) {", "-", "-\t\t// special scope for secret locals optimization.\t", "-\t\tthis.scope = new BlockScope(upperScope);", "-", "-\t\tBlockScope tryScope = new BlockScope(this.scope);", "-\t\tBlockScope finallyScope = null;", "-\t\t", "-\t\tif (this.finallyBlock != null) {", "-\t\t\tif (this.finallyBlock.isEmptyBlock()) {", "-\t\t\t\tif ((this.finallyBlock.bits & ASTNode.UndocumentedEmptyBlock) != 0) {", "-\t\t\t\t\tthis.scope.problemReporter().undocumentedEmptyBlock(this.finallyBlock.sourceStart, this.finallyBlock.sourceEnd);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tfinallyScope = new BlockScope(this.scope, false); // don't add it yet to parent scope", "-\t", "-\t\t\t\t// provision for returning and forcing the finally block to run", "-\t\t\t\tMethodScope methodScope = this.scope.methodScope();", "-\t", "-\t\t\t\t// the type does not matter as long as it is not a base type", "-\t\t\t\tif (!upperScope.compilerOptions().inlineJsrBytecode) {", "-\t\t\t\t\tthis.returnAddressVariable =", "-\t\t\t\t\t\tnew LocalVariableBinding(TryStatement.SecretReturnName, upperScope.getJavaLangObject(), ClassFileConstants.AccDefault, false);", "-\t\t\t\t\tfinallyScope.addLocalVariable(this.returnAddressVariable);", "-\t\t\t\t\tthis.returnAddressVariable.setConstant(Constant.NotAConstant); // not inlinable", "-\t\t\t\t}", "-\t\t\t\tthis.subRoutineStartLabel = new BranchLabel();", "-\t", "-\t\t\t\tthis.anyExceptionVariable =", "-\t\t\t\t\tnew LocalVariableBinding(TryStatement.SecretAnyHandlerName, this.scope.getJavaLangThrowable(), ClassFileConstants.AccDefault, false);", "-\t\t\t\tfinallyScope.addLocalVariable(this.anyExceptionVariable);", "-\t\t\t\tthis.anyExceptionVariable.setConstant(Constant.NotAConstant); // not inlinable", "-\t", "-\t\t\t\tif (!methodScope.isInsideInitializer()) {", "-\t\t\t\t\tMethodBinding methodBinding =", "-\t\t\t\t\t\t((AbstractMethodDeclaration) methodScope.referenceContext).binding;", "-\t\t\t\t\tif (methodBinding != null) {", "-\t\t\t\t\t\tTypeBinding methodReturnType = methodBinding.returnType;", "-\t\t\t\t\t\tif (methodReturnType.id != TypeIds.T_void) {", "-\t\t\t\t\t\t\tthis.secretReturnValue =", "-\t\t\t\t\t\t\t\tnew LocalVariableBinding(", "-\t\t\t\t\t\t\t\t\tTryStatement.SecretLocalDeclarationName,", "-\t\t\t\t\t\t\t\t\tmethodReturnType,", "-\t\t\t\t\t\t\t\t\tClassFileConstants.AccDefault,", "-\t\t\t\t\t\t\t\t\tfalse);", "-\t\t\t\t\t\t\tfinallyScope.addLocalVariable(this.secretReturnValue);", "-\t\t\t\t\t\t\tthis.secretReturnValue.setConstant(Constant.NotAConstant); // not inlinable", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tthis.finallyBlock.resolveUsing(finallyScope);", "-\t\t\t\t// force the finally scope to have variable positions shifted after its try scope and catch ones", "-\t\t\t\tfinallyScope.shiftScopes = new BlockScope[this.catchArguments == null ? 1 : this.catchArguments.length+1];", "-\t\t\t\tfinallyScope.shiftScopes[0] = tryScope;", "-\t\t\t}", "-\t\t}", "-\t\tthis.tryBlock.resolveUsing(tryScope);", "-", "-\t\t// arguments type are checked against JavaLangThrowable in resolveForCatch(..)", "-\t\tif (this.catchBlocks != null) {", "-\t\t\tint length = this.catchArguments.length;", "-\t\t\tTypeBinding[] argumentTypes = new TypeBinding[length];", "-\t\t\tboolean catchHasError = false;", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tBlockScope catchScope = new BlockScope(this.scope);", "-\t\t\t\tif (finallyScope != null){", "-\t\t\t\t\tfinallyScope.shiftScopes[i+1] = catchScope;", "-\t\t\t\t}", "-\t\t\t\t// side effect on catchScope in resolveForCatch(..)", "-\t\t\t\tif ((argumentTypes[i] = this.catchArguments[i].resolveForCatch(catchScope)) == null) {", "-\t\t\t\t\tcatchHasError = true;", "-\t\t\t\t}", "-\t\t\t\tthis.catchBlocks[i].resolveUsing(catchScope);", "-\t\t\t}", "-\t\t\tif (catchHasError) {", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t\t// Verify that the catch clause are ordered in the right way:", "-\t\t\t// more specialized first.", "-\t\t\tthis.caughtExceptionTypes = new ReferenceBinding[length];", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tthis.caughtExceptionTypes[i] = (ReferenceBinding) argumentTypes[i];", "-\t\t\t\tfor (int j = 0; j < i; j++) {", "-\t\t\t\t\tif (this.caughtExceptionTypes[i].isCompatibleWith(argumentTypes[j])) {", "-\t\t\t\t\t\tthis.scope.problemReporter().wrongSequenceOfExceptionTypesError(this, this.caughtExceptionTypes[i], i, argumentTypes[j]);", "-\t\t\t\t\t}", "-\t\t\tthis.caughtExceptionTypes = new ReferenceBinding[0];", "-\t\t", "-\t\tif (finallyScope != null){", "-\t\t\t// add finallyScope as last subscope, so it can be shifted behind try/catch subscopes.", "-\t\t\t// the shifting is necessary to achieve no overlay in between the finally scope and its", "-\t\t\t// sibling in term of local variable positions.", "-\t\t\tthis.scope.addSubscope(finallyScope);", "+", "+public void resolve(BlockScope upperScope) {", "+\t// special scope for secret locals optimization.\t", "+\tthis.scope = new BlockScope(upperScope);", "+", "+\tBlockScope tryScope = new BlockScope(this.scope);", "+\tBlockScope finallyScope = null;", "+\t", "+\tif (this.finallyBlock != null) {", "+\t\tif (this.finallyBlock.isEmptyBlock()) {", "+\t\t\tif ((this.finallyBlock.bits & ASTNode.UndocumentedEmptyBlock) != 0) {", "+\t\t\t\tthis.scope.problemReporter().undocumentedEmptyBlock(this.finallyBlock.sourceStart, this.finallyBlock.sourceEnd);", "+\t\t\t}", "+\t\t} else {", "+\t\t\tfinallyScope = new BlockScope(this.scope, false); // don't add it yet to parent scope", "+", "+\t\t\t// provision for returning and forcing the finally block to run", "+\t\t\tMethodScope methodScope = this.scope.methodScope();", "+", "+\t\t\t// the type does not matter as long as it is not a base type", "+\t\t\tif (!upperScope.compilerOptions().inlineJsrBytecode) {", "+\t\t\t\tthis.returnAddressVariable =", "+\t\t\t\t\tnew LocalVariableBinding(TryStatement.SECRET_RETURN_ADDRESS_NAME, upperScope.getJavaLangObject(), ClassFileConstants.AccDefault, false);", "+\t\t\t\tfinallyScope.addLocalVariable(this.returnAddressVariable);", "+\t\t\t\tthis.returnAddressVariable.setConstant(Constant.NotAConstant); // not inlinable", "+\t\t\t}", "+\t\t\tthis.subRoutineStartLabel = new BranchLabel();", "+", "+\t\t\tthis.anyExceptionVariable =", "+\t\t\t\tnew LocalVariableBinding(TryStatement.SECRET_ANY_HANDLER_NAME, this.scope.getJavaLangThrowable(), ClassFileConstants.AccDefault, false);", "+\t\t\tfinallyScope.addLocalVariable(this.anyExceptionVariable);", "+\t\t\tthis.anyExceptionVariable.setConstant(Constant.NotAConstant); // not inlinable", "+", "+\t\t\tif (!methodScope.isInsideInitializer()) {", "+\t\t\t\tMethodBinding methodBinding =", "+\t\t\t\t\t((AbstractMethodDeclaration) methodScope.referenceContext).binding;", "+\t\t\t\tif (methodBinding != null) {", "+\t\t\t\t\tTypeBinding methodReturnType = methodBinding.returnType;", "+\t\t\t\t\tif (methodReturnType.id != TypeIds.T_void) {", "+\t\t\t\t\t\tthis.secretReturnValue =", "+\t\t\t\t\t\t\tnew LocalVariableBinding(", "+\t\t\t\t\t\t\t\tTryStatement.SECRET_RETURN_VALUE_NAME,", "+\t\t\t\t\t\t\t\tmethodReturnType,", "+\t\t\t\t\t\t\t\tClassFileConstants.AccDefault,", "+\t\t\t\t\t\t\t\tfalse);", "+\t\t\t\t\t\tfinallyScope.addLocalVariable(this.secretReturnValue);", "+\t\t\t\t\t\tthis.secretReturnValue.setConstant(Constant.NotAConstant); // not inlinable", "+\t\t\t\t\t}", "+\t\t\tthis.finallyBlock.resolveUsing(finallyScope);", "+\t\t\t// force the finally scope to have variable positions shifted after its try scope and catch ones", "+\t\t\tfinallyScope.shiftScopes = new BlockScope[this.catchArguments == null ? 1 : this.catchArguments.length+1];", "+\t\t\tfinallyScope.shiftScopes[0] = tryScope;", "+\tthis.tryBlock.resolveUsing(tryScope);", "+", "+\t// arguments type are checked against JavaLangThrowable in resolveForCatch(..)", "+\tif (this.catchBlocks != null) {", "+\t\tint length = this.catchArguments.length;", "+\t\tTypeBinding[] argumentTypes = new TypeBinding[length];", "+\t\tboolean catchHasError = false;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tBlockScope catchScope = new BlockScope(this.scope);", "+\t\t\tif (finallyScope != null){", "+\t\t\t\tfinallyScope.shiftScopes[i+1] = catchScope;", "+\t\t\t}", "+\t\t\t// side effect on catchScope in resolveForCatch(..)", "+\t\t\tif ((argumentTypes[i] = this.catchArguments[i].resolveForCatch(catchScope)) == null) {", "+\t\t\t\tcatchHasError = true;", "+\t\t\t}", "+\t\t\tthis.catchBlocks[i].resolveUsing(catchScope);", "+\t\t}", "+\t\tif (catchHasError) {", "+\t\t\treturn;", "+\t\t}", "+\t\t// Verify that the catch clause are ordered in the right way:", "+\t\t// more specialized first.", "+\t\tthis.caughtExceptionTypes = new ReferenceBinding[length];", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tthis.caughtExceptionTypes[i] = (ReferenceBinding) argumentTypes[i];", "+\t\t\tfor (int j = 0; j < i; j++) {", "+\t\t\t\tif (this.caughtExceptionTypes[i].isCompatibleWith(argumentTypes[j])) {", "+\t\t\t\t\tthis.scope.problemReporter().wrongSequenceOfExceptionTypesError(this, this.caughtExceptionTypes[i], i, argumentTypes[j]);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t} else {", "+\t\tthis.caughtExceptionTypes = new ReferenceBinding[0];", "+\t}", "+\t", "+\tif (finallyScope != null){", "+\t\t// add finallyScope as last subscope, so it can be shifted behind try/catch subscopes.", "+\t\t// the shifting is necessary to achieve no overlay in between the finally scope and its", "+\t\t// sibling in term of local variable positions.", "+\t\tthis.scope.addSubscope(finallyScope);", "+\t}", "+}"]}], "num": 46004}