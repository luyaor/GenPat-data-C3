{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e1cea9ae09d7294479ff5548381aff2b", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46b7e300c8bff7e0358b820c0396b474", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "ba388ee53170dee91fb2402f317f8b352855c459", "commitAfterChange": "d043ef6776b1e3fad1bb618496ee2a48a9410e4b", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 15, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "diff": ["-\t\tIErrorHandlingPolicy oldPolicy = this.scope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "+\t\tif (!this.shapeAnalysisComplete && this.body instanceof Expression) {", "+\t\t\tExpression expression = (Expression) this.body;", "+\t\t\tthis.voidCompatible = expression.statementExpression();", "+\t\t\tthis.valueCompatible = true;", "+\t\t\tthis.shapeAnalysisComplete = true;", "+\t\t}", "+\t\tif (this.shapeAnalysisComplete) {", "+\t\t\tif (squarePegInRoundHole(sam))", "+\t\t\t\treturn false;", "+\t\t} ", "+", "+\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "+\t\tthis.hasIgnoredMandatoryErrors = false;", "-\t\t\tif (this.shapeAnalysisComplete) {", "-\t\t\t\tif (squarePegInRoundHole(sam))", "-\t\t\t\t\treturn false;", "-\t\t\t} else {", "-\t\t\t\tLambdaExpression copy = copy();", "-\t\t\t\tif (copy == null)", "-\t\t\t\t\treturn false;", "-\t\t\t\tcopy.setExpressionContext(this.expressionContext);", "-\t\t\t\tcopy.setExpectedType(left);", "-\t\t\t\tcopy.resolveType(this.enclosingScope);", "-\t\t\t\tthis.valueCompatible = copy.valueCompatible = copy.doesNotCompleteNormally();", "-\t\t\t\tthis.shapeAnalysisComplete = copy.shapeAnalysisComplete = true;", "-\t\t\t\tif (squarePegInRoundHole(sam))", "-\t\t\t\t\treturn false;", "-\t\t\t}", "-\t\t", "+\t\t\tthis.resultExpressions.put(left, new Expression[0]);", "-\t\t\t", "-\t\t\tif (!argumentsTypeElided()) {", "-\t\t\t\tfor (int i = 0, length = sam.parameters.length; i < length; i++) {", "-\t\t\t\t\tTypeBinding argumentType = copy.arguments[i].binding.type;", "-\t\t\t\t\tif (sam.parameters[i] != argumentType)", "-\t\t\t\t\t\treturn false;", "+\t\t\tif (!this.shapeAnalysisComplete) {", "+\t\t\t\tboolean lambdaIsFubar = this.hasIgnoredMandatoryErrors; // capture now, before doesNotCompleteNormally which runs analyzeCode on lambda body *without* the enclosing context being analyzed ", "+\t\t\t\tif (!this.returnsVoid && !this.returnsValue && this.throwsException) {  // () -> { throw new Exception(); } is value compatible.", "+\t\t\t\t\tBlock block = (Block) this.body;", "+\t\t\t\t\tfinal Statement[] statements = block.statements;", "+\t\t\t\t\tfinal int statementsLength = statements == null ? 0 : statements.length;", "+\t\t\t\t\tStatement ultimateStatement = statementsLength == 0 ? null : statements[statementsLength - 1];", "+\t\t\t\t\tthis.valueCompatible = ultimateStatement instanceof ThrowStatement ? true: copy.doesNotCompleteNormally(); ", "-\t\t\t}", "-", "-\t\t\tif (this.returnExpressionsTally > 0) {", "-\t\t\t\tfinal TypeBinding returnType = sam.returnType;", "-\t\t\t\tif (this.resultExpressions == null)", "-\t\t\t\t\tthis.resultExpressions = new SimpleLookupTable(); // gather for more specific analysis later.", "-\t\t\t\tif (this.body instanceof Block) {", "-\t\t\t\t\tASTVisitor visitor = new ASTVisitor() {", "-\t\t\t\t\t\tExpression [] returnExpressions = new Expression[LambdaExpression.this.returnExpressionsTally];", "-\t\t\t\t\t\tint returnExpressionsCount = 0;", "-\t\t\t\t\t\tpublic boolean visit(ReturnStatement returnStatement, BlockScope blockScope) {", "-\t\t\t\t\t\t\tExpression expression = returnStatement.expression;", "-\t\t\t\t\t\t\tif (expression != null && !expression.isAssignmentCompatible(returnType, blockScope))", "-\t\t\t\t\t\t\t\tthrow new IncongruentLambdaException();", "-\t\t\t\t\t\t\tthis.returnExpressions[this.returnExpressionsCount++] = expression;", "-\t\t\t\t\t\t\treturn false; // should not analyze any nested lambda returns", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tpublic boolean visit(TypeDeclaration declaration, BlockScope dontCare) {", "-\t\t\t\t\t\t\treturn false;  // do not analyze inner local types so as not to confuse returns from there.", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tpublic boolean visit(LambdaExpression lambda, BlockScope dontCare) {", "-\t\t\t\t\t\t\treturn LambdaExpression.this == lambda;  // do not analyze any inner lambdas so as not to confuse returns from there.", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tpublic void endVisit(Block block, BlockScope blockScope) {", "-\t\t\t\t\t\t\tif (block == copy.body)", "-\t\t\t\t\t\t\t\tLambdaExpression.this.resultExpressions.put(left, this.returnExpressions);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t};", "-\t\t\t\t\tcopy.body.traverse(visitor, copy.scope);", "-\t\t\t\t} else if (this.body instanceof Expression){", "-\t\t\t\t\tExpression expression = (Expression) copy.body;", "-\t\t\t\t\tif (!expression.isAssignmentCompatible(returnType, copy.scope))", "-\t\t\t\t\t\tthrow new IncongruentLambdaException();", "-\t\t\t\t\tthis.resultExpressions.put(left, new Expression [] { expression });", "-\t\t\t\t}", "+\t\t\t\tthis.shapeAnalysisComplete = true;", "+\t\t\t\tif (squarePegInRoundHole(sam) || lambdaIsFubar)", "+\t\t\t\t\treturn false;", "-\t\t\tthis.scope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "+\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "+\t\t\tthis.hasIgnoredMandatoryErrors = false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b59fa8c3afac660b1115a447fb0d9eab", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java", "commitBeforeChange": "d341317f75b9a87cb34c95bcadc8a79cf2e6761a", "commitAfterChange": "a7f1c6560d5eb4d7d0a892472094d38c8840f4ac", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r protected void computeJarChildren(JarPackageFragmentRootInfo info, ArrayList vChildren) throws JavaModelException", "signatureAfterChange": "\r protected void computeJarChildren(JarPackageFragmentRootInfo info, ArrayList vChildren) throws JavaModelException", "diff": ["+\tfinal int JAVA = 0;\r", "+\tfinal int NON_JAVA = 1;\r", "-\t\tpackageFragToTypes.put(IPackageFragment.DEFAULT_PACKAGE_NAME, new ArrayList[] { new ArrayList(), new ArrayList()\r", "-\t\t});\r", "+\t\tpackageFragToTypes.put(IPackageFragment.DEFAULT_PACKAGE_NAME, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });\r", "-\t\tArrayList[] temp;\r", "-\t\t\tString eName= member.getName();\r", "+\t\t\tString entryName= member.getName();\r", "+\r", "-\t\t\t\teName= eName.substring(0, eName.length() - 1);\r", "-\t\t\t\teName= eName.replace('/', '.');\r", "-\t\t\t\ttemp= (ArrayList[]) packageFragToTypes.get(eName);\r", "-\t\t\t\tif (temp == null) {\r", "-\t\t\t\t\ttemp= new ArrayList[] { new ArrayList(), new ArrayList()\r", "-\t\t\t\t };\r", "-\t\t\t\t\tpackageFragToTypes.put(eName, temp);\r", "+\t\t\t\t\r", "+\t\t\t\tint last = entryName.length() - 1;\r", "+\t\t\t\tentryName= entryName.substring(0, last);\r", "+\t\t\t\tentryName= entryName.replace('/', '.');\r", "+\r", "+\t\t\t\t// add the package name & all of its parent packages\r", "+\t\t\t\twhile (true) {\r", "+\t\t\t\t\t// extract the package name\r", "+\t\t\t\t\tif (packageFragToTypes.containsKey(entryName)) break;\r", "+\t\t\t\t\tpackageFragToTypes.put(entryName, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tif ((last = entryName.lastIndexOf('.')) < 0) break;\r", "+\t\t\t\t\tentryName = entryName.substring(0, last);\r", "-\t\t\t\tif (Util.isClassFileName(eName)) {\r", "-\t\t\t\t\t//only interested in class files\r", "-\t\t\t\t\t//store the class file entry name to be cached in the appropriate package fragment\r", "-\t\t\t\t\t//zip entries only use '/'\r", "-\t\t\t\t\tArrayList classTemp;\r", "-\t\t\t\t\tint lastSeparator= eName.lastIndexOf('/');\r", "-\t\t\t\t\tString key= IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "-\t\t\t\t\tString value= eName;\r", "-\t\t\t\t\tif (lastSeparator != -1) {\r", "-\t\t\t\t\t\t//not in the default package\r", "-\t\t\t\t\t\teName= eName.replace('/', '.');\r", "-\t\t\t\t\t\tvalue= eName.substring(lastSeparator + 1);\r", "-\t\t\t\t\t\tkey= eName.substring(0, lastSeparator);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\ttemp= (ArrayList[]) packageFragToTypes.get(key);\r", "-\t\t\t\t\tif (temp == null) {\r", "-\t\t\t\t\t\t// build all package fragments in the key\r", "-\t\t\t\t\t\tlastSeparator= key.indexOf('.');\r", "-\t\t\t\t\t\twhile (lastSeparator > 0) {\r", "-\t\t\t\t\t\t\tString prefix= key.substring(0, lastSeparator);\r", "-\t\t\t\t\t\t\tif (packageFragToTypes.get(prefix) == null) {\r", "-\t\t\t\t\t\t\t\tpackageFragToTypes.put(prefix, new ArrayList[] { new ArrayList(), new ArrayList()\r", "-\t\t\t\t\t\t\t });\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\tlastSeparator= key.indexOf('.', lastSeparator + 1);\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tclassTemp= new ArrayList();\r", "-\t\t\t\t\t\tclassTemp.add(value);\r", "-\t\t\t\t\t\tpackageFragToTypes.put(key, new ArrayList[] {classTemp, new ArrayList()\r", "-\t\t\t\t\t });\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tclassTemp= temp[0];\r", "-\t\t\t\t\t\tclassTemp.add(value);\r", "-\t\t\t\t\t}\r", "+\t\t\t\t//store the class file / non-java rsc entry name to be cached in the appropriate package fragment\r", "+\t\t\t\t//zip entries only use '/'\r", "+\t\t\t\tint lastSeparator= entryName.lastIndexOf('/');\r", "+\t\t\t\tString packageName;\r", "+\t\t\t\tString fileName;\r", "+\t\t\t\tif (lastSeparator != -1) { //not in the default package\r", "+\t\t\t\t\tentryName= entryName.replace('/', '.');\r", "+\t\t\t\t\tfileName= entryName.substring(lastSeparator + 1);\r", "+\t\t\t\t\tpackageName= entryName.substring(0, lastSeparator);\r", "-\t\t\t\t\tArrayList resTemp;\r", "-\t\t\t\t\tint lastSeparator= eName.lastIndexOf('/');\r", "-\t\t\t\t\tString key= IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "-\t\t\t\t\tString value= eName;\r", "-\t\t\t\t\tif (lastSeparator != -1) {\r", "-\t\t\t\t\t\t//not in the default package\r", "-\t\t\t\t\t\teName= eName.replace('/', '.');\r", "-\t\t\t\t\t\tkey= eName.substring(0, lastSeparator);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\ttemp= (ArrayList[]) packageFragToTypes.get(key);\r", "-\t\t\t\t\tif (temp == null) {\r", "-\t\t\t\t\t\t// build all package fragments in the key\r", "-\t\t\t\t\t\tlastSeparator= key.indexOf('.');\r", "-\t\t\t\t\t\twhile (lastSeparator > 0) {\r", "-\t\t\t\t\t\t\tString prefix= key.substring(0, lastSeparator);\r", "-\t\t\t\t\t\t\tif (packageFragToTypes.get(prefix) == null) {\r", "-\t\t\t\t\t\t\t\tpackageFragToTypes.put(prefix, new ArrayList[] { new ArrayList(), new ArrayList()\r", "-\t\t\t\t\t\t\t });\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\tlastSeparator= key.indexOf('.', lastSeparator + 1);\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tresTemp= new ArrayList();\r", "-\t\t\t\t\t\tresTemp.add(value);\r", "-\t\t\t\t\t\tpackageFragToTypes.put(key, new ArrayList[] { new ArrayList(), resTemp });\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tresTemp= temp[1];\r", "-\t\t\t\t\t\tresTemp.add(value);\r", "-\t\t\t\t\t}\r", "+\t\t\t\t\tfileName = entryName;\r", "+\t\t\t\t\tpackageName =  IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "+\t\t\t\t}\r", "+\t\t\t\t\r", "+\t\t\t\t// add the package name & all of its parent packages\r", "+\t\t\t\tString currentPackageName = packageName;\r", "+\t\t\t\twhile (true) {\r", "+\t\t\t\t\t// extract the package name\r", "+\t\t\t\t\tif (packageFragToTypes.containsKey(currentPackageName)) break;\r", "+\t\t\t\t\tpackageFragToTypes.put(currentPackageName, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tint last;\r", "+\t\t\t\t\tif ((last = currentPackageName.lastIndexOf('.')) < 0) break;\r", "+\t\t\t\t\tcurrentPackageName = currentPackageName.substring(0, last);\r", "+\t\t\t\t}\r", "+\t\t\t\t// add classfile info amongst children\r", "+\t\t\t\tArrayList[] children = (ArrayList[]) packageFragToTypes.get(packageName);\r", "+\t\t\t\tif (Util.isClassFileName(entryName)) {\r", "+\t\t\t\t\tif (children[JAVA] == EMPTY_LIST) children[JAVA] = new ArrayList();\r", "+\t\t\t\t\tchildren[JAVA].add(fileName);\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tif (children[NON_JAVA] == EMPTY_LIST) children[NON_JAVA] = new ArrayList();\r", "+\t\t\t\t\tchildren[NON_JAVA].add(fileName);\r", "-\t\t\tString packName= (String) packages.next();\r", "+\t\t\tString packName = (String) packages.next();\r", "+\t\t\t\r", "-\t\t\t\tfragInfo.setEntryNames(entries[0]);\r", "+\t\t\t\tfragInfo.setEntryNames(entries[JAVA]);\r", "-\t\t\tint resLength= entries[1].size();\r", "+\t\t\tint resLength= entries[NON_JAVA].size();\r", "-\t\t\t\tpackFrag.computeNonJavaResources(new String[] {}, fragInfo, jar.getName());\r", "+\t\t\t\tpackFrag.computeNonJavaResources(NO_STRINGS, fragInfo, jar.getName());\r", "-\t\t\t\tentries[1].toArray(resNames);\r", "+\t\t\t\tentries[NON_JAVA].toArray(resNames);\r"]}], "num": 56237}