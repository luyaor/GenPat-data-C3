{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9f2eb1c540c924a6c12590c2bcfbaccd", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0339fc7d8f8be0120db01c9df89a437c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java", "commitBeforeChange": "d827489386a0080be2baf2be380c0f3630a2f239", "commitAfterChange": "b0e22c1c1f34d79e167c112a42cdff6b01498911", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "+\t// process the condition", "+\tFlowInfo conditionFlowInfo = this.condition.analyseCode(currentScope, flowContext, flowInfo);", "+\tint initialComplaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;", "+", "+\tConstant cst = this.condition.optimizedBooleanConstant();", "+\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "+", "+\t// process the THEN part", "+\tFlowInfo thenFlowInfo = conditionFlowInfo.safeInitsWhenTrue();", "+\tif (isConditionOptimizedFalse) {", "+\t\tthenFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\tFlowInfo elseFlowInfo = conditionFlowInfo.initsWhenFalse();", "+\tif (isConditionOptimizedTrue) {", "+\t\telseFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "-", "-\tpublic FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "-\t\t// process the condition", "-\t\tFlowInfo conditionFlowInfo = this.condition.analyseCode(currentScope, flowContext, flowInfo);", "-\t\tint initialComplaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;", "-", "-\t\tConstant cst = this.condition.optimizedBooleanConstant();", "-\t\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "-", "-\t\t// process the THEN part", "-\t\tFlowInfo thenFlowInfo = conditionFlowInfo.safeInitsWhenTrue();", "+\tif (this.thenStatement != null) {", "+\t\t// Save info for code gen", "+\t\tthis.thenInitStateIndex = currentScope.methodScope().recordInitializationStates(thenFlowInfo);", "-\t\t\tthenFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t}", "-\t\tFlowInfo elseFlowInfo = conditionFlowInfo.initsWhenFalse();", "-\t\tif (isConditionOptimizedTrue) {", "-\t\t\telseFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t}", "-\t\tif (this.thenStatement != null) {", "-\t\t\t// Save info for code gen", "-\t\t\tthis.thenInitStateIndex = currentScope.methodScope().recordInitializationStates(thenFlowInfo);", "-\t\t\tif (this.thenStatement.complainIfUnreachable(thenFlowInfo, currentScope, initialComplaintLevel) < Statement.COMPLAINED_UNREACHABLE) {", "-\t\t\t\tthenFlowInfo = this.thenStatement.analyseCode(currentScope, flowContext, thenFlowInfo);", "+\t\t\tif (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {", "+\t\t\t\tthis.thenStatement.complainIfUnreachable(thenFlowInfo, currentScope, initialComplaintLevel);", "-\t\t// code gen: optimizing the jump around the ELSE part", "-\t\tif ((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) {", "-\t\t\tthis.bits |= ASTNode.ThenExit;", "-\t\t}", "-", "-\t\t// process the ELSE part", "-\t\tif (this.elseStatement != null) {", "-\t\t    // signal else clause unnecessarily nested, tolerate else-if code pattern", "-\t\t    if (thenFlowInfo == FlowInfo.DEAD_END", "-\t\t            && (this.bits & IsElseIfStatement) == 0 \t// else of an else-if", "-\t\t            && !(this.elseStatement instanceof IfStatement)) {", "-\t\t        currentScope.problemReporter().unnecessaryElse(this.elseStatement);", "-\t\t    }", "-\t\t\t// Save info for code gen", "-\t\t\tthis.elseInitStateIndex = currentScope.methodScope().recordInitializationStates(elseFlowInfo);", "-\t\t\tif (this.elseStatement.complainIfUnreachable(elseFlowInfo, currentScope, initialComplaintLevel) < Statement.COMPLAINED_UNREACHABLE) {", "-\t\t\t\telseFlowInfo = this.elseStatement.analyseCode(currentScope, flowContext, elseFlowInfo);", "-\t\t\t}", "-\t\t}", "-", "-\t\t// merge THEN & ELSE initializations", "-\t\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "-\t\t\tthenFlowInfo,", "-\t\t\tisConditionOptimizedTrue,", "-\t\t\telseFlowInfo,", "-\t\t\tisConditionOptimizedFalse,", "-\t\t\ttrue /*if(true){ return; }  fake-reachable(); */);", "-\t\tthis.mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\treturn mergedInfo;", "+\t\tthenFlowInfo = this.thenStatement.analyseCode(currentScope, flowContext, thenFlowInfo);", "+\t}", "+\t// code gen: optimizing the jump around the ELSE part", "+\tif ((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) {", "+\t\tthis.bits |= ASTNode.ThenExit;", "+\t// process the ELSE part", "+\tif (this.elseStatement != null) {", "+\t    // signal else clause unnecessarily nested, tolerate else-if code pattern", "+\t    if (thenFlowInfo == FlowInfo.DEAD_END", "+\t            && (this.bits & IsElseIfStatement) == 0 \t// else of an else-if", "+\t            && !(this.elseStatement instanceof IfStatement)) {", "+\t        currentScope.problemReporter().unnecessaryElse(this.elseStatement);", "+\t    }", "+\t\t// Save info for code gen", "+\t\tthis.elseInitStateIndex = currentScope.methodScope().recordInitializationStates(elseFlowInfo);", "+\t\tif (isConditionOptimizedTrue) {", "+\t\t\tif (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {", "+\t\t\t\tthis.elseStatement.complainIfUnreachable(elseFlowInfo, currentScope, initialComplaintLevel);", "+\t\t\t}", "+\t\telseFlowInfo = this.elseStatement.analyseCode(currentScope, flowContext, elseFlowInfo);", "+\t}", "+\t// merge THEN & ELSE initializations", "+\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "+\t\tthenFlowInfo,", "+\t\tisConditionOptimizedTrue,", "+\t\telseFlowInfo,", "+\t\tisConditionOptimizedFalse,", "+\t\ttrue /*if(true){ return; }  fake-reachable(); */);", "+\tthis.mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "+\treturn mergedInfo;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35f2996320b7d71d6a0a7f961fb20f58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "e5e6f9097f2c3bf7294bd658643d6be9f7aaa5ef", "commitAfterChange": "d00bc48524f3df289951f11fca95cb39820be47f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "\r \r \tpublic FlowInfo analyseCode(\r \t\tBlockScope currentScope,\r \t\tFlowContext flowContext,\r \t\tFlowInfo flowInfo)", "diff": ["-}\r", "-public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {\r", "-\tConstant inlinedCondition = condition.constant;\r", "-\tif (inlinedCondition == NotAConstant) inlinedCondition = condition.conditionalConstant();\r", "-\tif (inlinedCondition != NotAConstant) {\r", "-\t\tif (inlinedCondition.booleanValue() == true) {\r", "-\t\t\tFlowInfo resultInfo = valueIfTrue.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\t// analyse valueIfFalse, but do not take into account any of its infos\r", "-\t\t\tvalueIfFalse.analyseCode(currentScope, flowContext, flowInfo.copy().markAsFakeReachable(true));\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(resultInfo);\r", "-\t\t\treturn resultInfo;\r", "-\t\t} else {\r", "-\t\t\t// analyse valueIfTrue, but do not take into account any of its infos\t\t\t\r", "-\t\t\tvalueIfTrue.analyseCode(currentScope, flowContext, flowInfo.copy().markAsFakeReachable(true));\r", "-\t\t\tFlowInfo mergeInfo = valueIfFalse.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergeInfo);\r", "-\t\t\treturn mergeInfo;\r", "-\t\t}\r", "-\t}\r", "-\t// notice that the receiver investigation is not performed in the previous case, since there is\r", "-\t// not a chance it is worth trying to check anything on a constant expression.\r", "-\tflowInfo = condition.analyseCode(currentScope, flowContext, flowInfo);\r", "-\r", "-\t// store a copy of the merged info, so as to compute the local variable attributes afterwards\r", "-\tFlowInfo trueInfo = flowInfo.initsWhenTrue();\r", "-\tthenInitStateIndex = currentScope.methodScope().recordInitializationStates(trueInfo);\r", "-\tFlowInfo falseInfo = flowInfo.initsWhenFalse();\r", "-\telseInitStateIndex = currentScope.methodScope().recordInitializationStates(falseInfo);\r", "-\t// propagate analysis\r", "-\ttrueInfo = valueIfTrue.analyseCode(currentScope, flowContext, trueInfo.copy());\r", "-\tfalseInfo = valueIfFalse.analyseCode(currentScope, flowContext, falseInfo.copy());\r", "-\t\r", "-\t// merge back using a conditional info -  1GK2BLM\r", "-\t// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok\r", "-\tFlowInfo mergedInfo = FlowInfo.conditional(\r", "-\t\ttrueInfo.initsWhenTrue().unconditionalInits().mergedWith(\r", "-\t\t\tfalseInfo.initsWhenTrue().unconditionalInits()),\r", "-\t\tfalseInfo.initsWhenFalse().unconditionalInits().mergedWith(\r", "-\t\t\tfalseInfo.initsWhenFalse().unconditionalInits()));\r", "-/*\t\t\t\r", "-\tFlowInfo mergedInfo = valueIfTrue.analyseCode(\r", "-\t\tcurrentScope,\r", "-\t\tflowContext,\r", "-\t\tflowInfo.initsWhenTrue().copy()).\r", "-\t\t\tunconditionalInits().\r", "-\t\t\t\tmergedWith(\r", "-\t\t\t\t\tvalueIfFalse.analyseCode(\r", "-\t\t\t\t\t\tcurrentScope,\r", "-\t\t\t\t\t\tflowContext,\r", "-\t\t\t\t\t\tflowInfo.initsWhenFalse().copy()).\r", "-\t\t\t\t\t\t\tunconditionalInits());\r", "-*/\t\t\t\t\t\t\t\r", "-\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\treturn mergedInfo;\r", "-}\r", "+\tpublic FlowInfo analyseCode(\r", "+\t\tBlockScope currentScope,\r", "+\t\tFlowContext flowContext,\r", "+\t\tFlowInfo flowInfo) {\r", "+\t\tConstant conditionConstant = condition.conditionalConstant();\r", "+\t\tif (conditionConstant != NotAConstant) {\r", "+\t\t\tif (conditionConstant.booleanValue() == true) {\r", "+\t\t\t\t// TRUE ? left : right\r", "+\t\t\t\tFlowInfo resultInfo =\r", "+\t\t\t\t\tvalueIfTrue.analyseCode(currentScope, flowContext, flowInfo);\r", "+\t\t\t\t// analyse valueIfFalse, but do not take into account any of its infos\r", "+\t\t\t\tvalueIfFalse.analyseCode(\r", "+\t\t\t\t\tcurrentScope,\r", "+\t\t\t\t\tflowContext,\r", "+\t\t\t\t\tflowInfo.copy().markAsFakeReachable(true));\r", "+\t\t\t\tmergedInitStateIndex =\r", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(resultInfo);\r", "+\t\t\t\treturn resultInfo;\r", "+\t\t\t} else {\r", "+\t\t\t\t// FALSE ? left : right\r", "+\t\t\t\t// analyse valueIfTrue, but do not take into account any of its infos\t\t\t\r", "+\t\t\t\tvalueIfTrue.analyseCode(\r", "+\t\t\t\t\tcurrentScope,\r", "+\t\t\t\t\tflowContext,\r", "+\t\t\t\t\tflowInfo.copy().markAsFakeReachable(true));\r", "+\t\t\t\tFlowInfo mergeInfo =\r", "+\t\t\t\t\tvalueIfFalse.analyseCode(currentScope, flowContext, flowInfo);\r", "+\t\t\t\tmergedInitStateIndex =\r", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergeInfo);\r", "+\t\t\t\treturn mergeInfo;\r", "+\t\t// notice that the receiver investigation is not performed in the previous case, since there is\r", "+\t\t// not a chance it is worth trying to check anything on a constant expression.\r", "+\t\tflowInfo = condition.analyseCode(currentScope, flowContext, flowInfo);\r", "+\t\t// store a copy of the merged info, so as to compute the local variable attributes afterwards\r", "+\t\tFlowInfo trueInfo = flowInfo.initsWhenTrue();\r", "+\t\tthenInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(trueInfo);\r", "+\t\tFlowInfo falseInfo = flowInfo.initsWhenFalse();\r", "+\t\telseInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(falseInfo);\r", "+\r", "+\t\t// propagate analysis\r", "+\t\ttrueInfo = valueIfTrue.analyseCode(currentScope, flowContext, trueInfo.copy());\r", "+\t\tfalseInfo =\r", "+\t\t\tvalueIfFalse.analyseCode(currentScope, flowContext, falseInfo.copy());\r", "+\r", "+\t\t// merge back using a conditional info -  1GK2BLM\r", "+\t\t// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok\r", "+\t\tFlowInfo mergedInfo =\r", "+\t\t\tFlowInfo.conditional(\r", "+\t\t\t\ttrueInfo.initsWhenTrue().copy().unconditionalInits().mergedWith( // must copy, since could be shared with trueInfo.initsWhenFalse()...\r", "+\t\t\t\t\tfalseInfo.initsWhenTrue().copy().unconditionalInits()),\r", "+\t\t\t\ttrueInfo.initsWhenFalse().unconditionalInits().mergedWith(\r", "+\t\t\t\t\tfalseInfo.initsWhenFalse().unconditionalInits()));\r", "+\t\t/*\t\t\t\r", "+\t\t\tFlowInfo mergedInfo = valueIfTrue.analyseCode(\r", "+\t\t\t\tcurrentScope,\r", "+\t\t\t\tflowContext,\r", "+\t\t\t\tflowInfo.initsWhenTrue().copy()).\r", "+\t\t\t\t\tunconditionalInits().\r", "+\t\t\t\t\t\tmergedWith(\r", "+\t\t\t\t\t\t\tvalueIfFalse.analyseCode(\r", "+\t\t\t\t\t\t\t\tcurrentScope,\r", "+\t\t\t\t\t\t\t\tflowContext,\r", "+\t\t\t\t\t\t\t\tflowInfo.initsWhenFalse().copy()).\r", "+\t\t\t\t\t\t\t\t\tunconditionalInits());\r", "+\t\t*/\r", "+\t\tmergedInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);\r", "+\t\treturn mergedInfo;\r"]}], "num": 20788}