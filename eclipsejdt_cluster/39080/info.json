{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "96ac72aef25a8e97699c9bebd2388312", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "62f6d7b78d0d9accf35ffc087584e6c4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "09c9d84aad79985551ce918cbcc33cdee71ab4e2", "commitAfterChange": "0f631524aef87d3ee7b5140c20a85cb2799ddd71", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " public RecoveredElement buildInitialRecoveryState()", "signatureAfterChange": " public RecoveredElement buildInitialRecoveryState()", "diff": ["+\t", "+\tif (this.statementRecoveryActivated) {", "+\t\tif (this.pendingRecoveredType != null &&", "+\t\t\t\tthis.scanner.startPosition - 1 <= this.pendingRecoveredType.declarationSourceEnd) {", "+\t\t\t// Add the pending type to the AST if this type isn't already added in the AST.", "+\t\t\telement = element.add(this.pendingRecoveredType, 0);\t\t\t\t", "+\t\t\tthis.lastCheckPoint = this.pendingRecoveredType.declarationSourceEnd + 1;", "+\t\t\tthis.pendingRecoveredType = null;", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b725bb5a4209f371e38be74b6b350f7e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java", "commitBeforeChange": "42f1e70a46f62ba06d110671431cc4e0acafff68", "commitAfterChange": "6d26e89371291b0e31c04fda43f7d9e8d5d62845", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+\t", "+\tif (this.expression instanceof FunctionalExpression) {", "+\t\tif (this.expression.resolvedType == null || !this.expression.resolvedType.isValidBinding()) {", "+\t\t\t/* Don't descend without proper target types. For lambda shape analysis, what is pertinent is value vs void return and the fact that", "+\t\t\t   this constitutes an abrupt exit. The former is already gathered, the latter is handled here.", "+\t\t\t*/ ", "+\t\t\tflowContext.recordAbruptExit();", "+\t\t\treturn FlowInfo.DEAD_END;", "+\t\t}", "+\t}"]}], "num": 39080}