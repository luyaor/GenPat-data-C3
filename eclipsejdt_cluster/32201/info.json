{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "485308a82639a5ffe226b7fc76014cc6", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b8e7912dea4c247db781aa97ec2d7002", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "59f63ebee2d26201a814fe525a701186855b7a34", "commitAfterChange": "625da6d5291673f01e323396ceb1f6773e9845a5", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "diff": ["-\t\tJob job = new Job(Messages.javamodel_initialization) {", "-\t\t\tprotected IStatus run(IProgressMonitor progressMonitor) {", "-\t\t\t\t// dummy query for waiting until the indexes are ready and classpath containers/variables are initialized", "-\t\t\t\tSearchEngine engine = new SearchEngine();", "-\t\t\t\tIJavaSearchScope scope = SearchEngine.createWorkspaceScope(); // initialize all containers and variables", "-\t\t\t\ttry {", "-\t\t\t\t\tengine.searchAllTypeNames(", "-\t\t\t\t\t\tnull,", "-\t\t\t\t\t\t\"!@$#!@\".toCharArray(), //$NON-NLS-1$", "-\t\t\t\t\t\tSearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,", "-\t\t\t\t\t\tIJavaSearchConstants.CLASS,", "-\t\t\t\t\t\tscope, ", "-\t\t\t\t\t\tnew TypeNameRequestor() {", "-\t\t\t\t\t\t\tpublic void acceptType(", "-\t\t\t\t\t\t\t\tint modifiers,", "-\t\t\t\t\t\t\t\tchar[] packageName,", "-\t\t\t\t\t\t\t\tchar[] simpleTypeName,", "-\t\t\t\t\t\t\t\tchar[][] enclosingTypeNames,", "-\t\t\t\t\t\t\t\tString path) {", "-\t\t\t\t\t\t\t\t// no type to accept", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t},", "-\t\t\t\t\t\t// will not activate index query caches if indexes are not ready, since it would take to long", "-\t\t\t\t\t\t// to wait until indexes are fully rebuild", "-\t\t\t\t\t\tIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,", "-\t\t\t\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 99) // 99% of the time is spent in the dummy search", "-\t\t\t\t\t); ", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t// /search failed: ignore", "-\t\t\t\t} catch (OperationCanceledException e) {", "-\t\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled())", "-\t\t\t\t\t\tthrow e;", "-\t\t\t\t\t// else indexes were not ready: catch the exception so that jars are still refreshed", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\t// check if the build state version number has changed since last session", "-\t\t\t\t// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)", "-\t\t\t\tQualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, \"stateVersionNumber\"); //$NON-NLS-1$", "-\t\t\t\tIWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();", "-\t\t\t\tString versionNumber = null;", "-\t\t\t\ttry {", "-\t\t\t\t\tversionNumber = root.getPersistentProperty(qName);", "-\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t// could not read version number: consider it is new", "-\t\t\t\t}", "-\t\t\t\tfinal JavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();", "-\t\t\t\tString newVersionNumber = Byte.toString(State.VERSION);", "-\t\t\t\tif (!newVersionNumber.equals(versionNumber)) {", "-\t\t\t\t\t// build state version number has changed: touch every projects to force a rebuild", "-\t\t\t\t\tif (JavaBuilder.DEBUG)", "-\t\t\t\t\t\tSystem.out.println(\"Build state version number has changed\"); //$NON-NLS-1$", "-\t\t\t\t\tIWorkspaceRunnable runnable = new IWorkspaceRunnable() {", "-\t\t\t\t\t\tpublic void run(IProgressMonitor progressMonitor2) throws CoreException {", "-\t\t\t\t\t\t\tIJavaProject[] projects = null;", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tprojects = model.getJavaProjects();", "-\t\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\t\t// could not get Java projects: ignore", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (projects != null) {", "-\t\t\t\t\t\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "-\t\t\t\t\t\t\t\t\tIJavaProject project = projects[i];", "-\t\t\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\t\t\tif (JavaBuilder.DEBUG)", "-\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"Touching \" + project.getElementName()); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\tproject.getProject().touch(progressMonitor2);", "-\t\t\t\t\t\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t\t\t\t\t\t// could not touch this project: ignore", "-\t\t\t\t\t\t\t\t\t}", "+\t\ttry {", "+\t\t\tif (monitor != null) monitor.beginTask(Messages.javamodel_initialization, 100);", "+\t\t\t// dummy query for waiting until the indexes are ready and classpath containers/variables are initialized", "+\t\t\tSearchEngine engine = new SearchEngine();", "+\t\t\tIJavaSearchScope scope = SearchEngine.createWorkspaceScope(); // initialize all containers and variables", "+\t\t\ttry {", "+\t\t\t\tengine.searchAllTypeNames(", "+\t\t\t\t\tnull,", "+\t\t\t\t\t\"!@$#!@\".toCharArray(), //$NON-NLS-1$", "+\t\t\t\t\tSearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,", "+\t\t\t\t\tIJavaSearchConstants.CLASS,", "+\t\t\t\t\tscope, ", "+\t\t\t\t\tnew TypeNameRequestor() {", "+\t\t\t\t\t\tpublic void acceptType(", "+\t\t\t\t\t\t\tint modifiers,", "+\t\t\t\t\t\t\tchar[] packageName,", "+\t\t\t\t\t\t\tchar[] simpleTypeName,", "+\t\t\t\t\t\t\tchar[][] enclosingTypeNames,", "+\t\t\t\t\t\t\tString path) {", "+\t\t\t\t\t\t\t// no type to accept", "+\t\t\t\t\t\t}", "+\t\t\t\t\t},", "+\t\t\t\t\t// will not activate index query caches if indexes are not ready, since it would take to long", "+\t\t\t\t\t// to wait until indexes are fully rebuild", "+\t\t\t\t\tIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,", "+\t\t\t\t\tmonitor == null ? null : new SubProgressMonitor(monitor, 99) // 99% of the time is spent in the dummy search", "+\t\t\t\t); ", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// /search failed: ignore", "+\t\t\t} catch (OperationCanceledException e) {", "+\t\t\t\tif (monitor != null && monitor.isCanceled())", "+\t\t\t\t\tthrow e;", "+\t\t\t\t// else indexes were not ready: catch the exception so that jars are still refreshed", "+\t\t\t}", "+\t\t\t", "+\t\t\t// check if the build state version number has changed since last session", "+\t\t\t// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)", "+\t\t\tQualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, \"stateVersionNumber\"); //$NON-NLS-1$", "+\t\t\tIWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();", "+\t\t\tString versionNumber = null;", "+\t\t\ttry {", "+\t\t\t\tversionNumber = root.getPersistentProperty(qName);", "+\t\t\t} catch (CoreException e) {", "+\t\t\t\t// could not read version number: consider it is new", "+\t\t\t}", "+\t\t\tfinal JavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();", "+\t\t\tString newVersionNumber = Byte.toString(State.VERSION);", "+\t\t\tif (!newVersionNumber.equals(versionNumber)) {", "+\t\t\t\t// build state version number has changed: touch every projects to force a rebuild", "+\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\tSystem.out.println(\"Build state version number has changed\"); //$NON-NLS-1$", "+\t\t\t\tIWorkspaceRunnable runnable = new IWorkspaceRunnable() {", "+\t\t\t\t\tpublic void run(IProgressMonitor progressMonitor2) throws CoreException {", "+\t\t\t\t\t\tIJavaProject[] projects = null;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tprojects = model.getJavaProjects();", "+\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\t// could not get Java projects: ignore", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (projects != null) {", "+\t\t\t\t\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\t\t\t\t\t\t\tIJavaProject project = projects[i];", "+\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"Touching \" + project.getElementName()); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tproject.getProject().touch(progressMonitor2);", "+\t\t\t\t\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\t\t\t\t\t// could not touch this project: ignore", "-\t\t\t\t\t};", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tResourcesPlugin.getWorkspace().run(runnable, progressMonitor);", "-\t\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t\t// could not touch all projects", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\troot.setPersistentProperty(qName, newVersionNumber);", "-\t\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t\tUtil.log(e, \"Could not persist build state version number\"); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\t// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)", "+\t\t\t\t};", "-\t\t\t\t\tmodel.refreshExternalArchives(", "-\t\t\t\t\t\tnull/*refresh all projects*/, ", "-\t\t\t\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1) // 1% of the time is spent in jar refresh", "-\t\t\t\t\t);", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t// refreshing failed: ignore", "+\t\t\t\t\tResourcesPlugin.getWorkspace().run(runnable, monitor);", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\t// could not touch all projects", "-\t\t\t\t", "-\t\t\t\treturn Status.OK_STATUS;", "+\t\t\t\ttry {", "+\t\t\t\t\troot.setPersistentProperty(qName, newVersionNumber);", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\tUtil.log(e, \"Could not persist build state version number\"); //$NON-NLS-1$", "+\t\t\t\t}", "-\t\t\tpublic boolean belongsTo(Object family) {", "-\t\t\t\treturn PLUGIN_ID.equals(family);", "+\t\t\t", "+\t\t\t// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)", "+\t\t\ttry {", "+\t\t\t\tmodel.refreshExternalArchives(", "+\t\t\t\t\tnull/*refresh all projects*/, ", "+\t\t\t\t\tmonitor == null ? null : new SubProgressMonitor(monitor, 1) // 1% of the time is spent in jar refresh", "+\t\t\t\t);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// refreshing failed: ignore", "-\t\t};", "-\t\tjob.setPriority(Job.SHORT);", "-\t\tjob.schedule(2000);\t // wait for the startup activity to calm down", "-\t\t", "+\t\t} finally {", "+\t\t\tif (monitor != null) monitor.done();", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d1ea35fc211cb461a668a585baec8982", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "b700d8caadb42adbdbc0b00fcd8471ef9991a26b", "commitAfterChange": "d93813799bc1dd9daff699b402d0401494fdce4b", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "diff": ["-\t\t// dummy query for waiting until the indexes are ready and classpath containers/variables are initialized", "-\t\tSearchEngine engine = new SearchEngine();", "-\t\tIJavaSearchScope scope = SearchEngine.createWorkspaceScope(); // initialize all containers and variables", "-\t\ttry {", "-\t\t\tengine.searchAllTypeNames(", "-\t\t\t\tnull,", "-\t\t\t\t\"!@$#!@\".toCharArray(), //$NON-NLS-1$", "-\t\t\t\tSearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,", "-\t\t\t\tIJavaSearchConstants.CLASS,", "-\t\t\t\tscope, ", "-\t\t\t\tnew TypeNameRequestor() {", "-\t\t\t\t\tpublic void acceptType(", "-\t\t\t\t\t\tint modifiers,", "-\t\t\t\t\t\tchar[] packageName,", "-\t\t\t\t\t\tchar[] simpleTypeName,", "-\t\t\t\t\t\tchar[][] enclosingTypeNames,", "-\t\t\t\t\t\tString path) {", "-\t\t\t\t\t\t// no type to accept", "-\t\t\t\t\t}", "-\t\t\t\t},", "-\t\t\t\t// will not activate index query caches if indexes are not ready, since it would take to long", "-\t\t\t\t// to wait until indexes are fully rebuild", "-\t\t\t\tIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,", "-\t\t\t\tmonitor == null ? null : new SubProgressMonitor(monitor, 99) // 99% of the time is spent in the dummy search", "-\t\t\t); ", "-\t\t} catch (OperationCanceledException e) {", "-\t\t\t// indexes were not ready", "-\t\t}", "+\t\tJob job = new Job(Messages.javamodel_initialization) {", "+\t\t\tprotected IStatus run(IProgressMonitor progressMonitor) {", "+\t\t\t\t// dummy query for waiting until the indexes are ready and classpath containers/variables are initialized", "+\t\t\t\tSearchEngine engine = new SearchEngine();", "+\t\t\t\tIJavaSearchScope scope = SearchEngine.createWorkspaceScope(); // initialize all containers and variables", "+\t\t\t\ttry {", "+\t\t\t\t\tengine.searchAllTypeNames(", "+\t\t\t\t\t\tnull,", "+\t\t\t\t\t\t\"!@$#!@\".toCharArray(), //$NON-NLS-1$", "+\t\t\t\t\t\tSearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,", "+\t\t\t\t\t\tIJavaSearchConstants.CLASS,", "+\t\t\t\t\t\tscope, ", "+\t\t\t\t\t\tnew TypeNameRequestor() {", "+\t\t\t\t\t\t\tpublic void acceptType(", "+\t\t\t\t\t\t\t\tint modifiers,", "+\t\t\t\t\t\t\t\tchar[] packageName,", "+\t\t\t\t\t\t\t\tchar[] simpleTypeName,", "+\t\t\t\t\t\t\t\tchar[][] enclosingTypeNames,", "+\t\t\t\t\t\t\t\tString path) {", "+\t\t\t\t\t\t\t\t// no type to accept", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t},", "+\t\t\t\t\t\t// will not activate index query caches if indexes are not ready, since it would take to long", "+\t\t\t\t\t\t// to wait until indexes are fully rebuild", "+\t\t\t\t\t\tIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,", "+\t\t\t\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 99) // 99% of the time is spent in the dummy search", "+\t\t\t\t\t); ", "+\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t// /search failed: ignore", "+\t\t\t\t} catch (OperationCanceledException e) {", "+\t\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled())", "+\t\t\t\t\t\tthrow e;", "+\t\t\t\t\t// else indexes were not ready: catch the exception so that jars are still refreshed", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)", "+\t\t\t\ttry {", "+\t\t\t\t\tJavaModelManager.getJavaModelManager().getJavaModel().refreshExternalArchives(", "+\t\t\t\t\t\tnull/*refresh all projects*/, ", "+\t\t\t\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1) // 1% of the time is spent in jar refresh", "+\t\t\t\t\t);", "+\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t// refreshing failed: ignore", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\treturn Status.OK_STATUS;", "+\t\t\t}", "+\t\t\tpublic boolean belongsTo(Object family) {", "+\t\t\t\treturn PLUGIN_ID.equals(family);", "+\t\t\t}", "+\t\t};", "+\t\tjob.setPriority(Job.SHORT);", "+\t\tjob.schedule();\t\t", "-\t\t// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)", "-\t\tJavaModelManager.getJavaModelManager().getJavaModel().refreshExternalArchives(", "-\t\t\tnull/*refresh all projects*/, ", "-\t\t\tmonitor == null ? null : new SubProgressMonitor(monitor, 1) // 1% of the time is spent in jar refresh", "-\t\t);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ed893c76e5cba5c96849cf88d00c5e1c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "c3c566a914f3d94e9c9bd5dba71e015077681183", "commitAfterChange": "d13325d285185f513ba4e1343c1dad363338cb19", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "diff": ["-\t\tengine.searchAllTypeNames(", "-\t\t\tnull,", "-\t\t\t\"!@$#!@\".toCharArray(), //$NON-NLS-1$", "-\t\t\tSearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,", "-\t\t\tIJavaSearchConstants.CLASS,", "-\t\t\tscope, ", "-\t\t\tnew TypeNameRequestor() {", "-\t\t\t\tpublic void acceptType(", "-\t\t\t\t\tint modifiers,", "-\t\t\t\t\tchar[] packageName,", "-\t\t\t\t\tchar[] simpleTypeName,", "-\t\t\t\t\tchar[][] enclosingTypeNames,", "-\t\t\t\t\tString path) {", "-\t\t\t\t\t// no type to accept", "-\t\t\t\t}", "-\t\t\t},", "-\t\t\t// will not activate index query caches if indexes are not ready, since it would take to long", "-\t\t\t// to wait until indexes are fully rebuild", "-\t\t\tIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,", "-\t\t\tmonitor == null ? null : new SubProgressMonitor(monitor, 99) // 99% of the time is spent in the dummy search", "-\t\t); ", "+\t\ttry {", "+\t\t\tengine.searchAllTypeNames(", "+\t\t\t\tnull,", "+\t\t\t\t\"!@$#!@\".toCharArray(), //$NON-NLS-1$", "+\t\t\t\tSearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,", "+\t\t\t\tIJavaSearchConstants.CLASS,", "+\t\t\t\tscope, ", "+\t\t\t\tnew TypeNameRequestor() {", "+\t\t\t\t\tpublic void acceptType(", "+\t\t\t\t\t\tint modifiers,", "+\t\t\t\t\t\tchar[] packageName,", "+\t\t\t\t\t\tchar[] simpleTypeName,", "+\t\t\t\t\t\tchar[][] enclosingTypeNames,", "+\t\t\t\t\t\tString path) {", "+\t\t\t\t\t\t// no type to accept", "+\t\t\t\t\t}", "+\t\t\t\t},", "+\t\t\t\t// will not activate index query caches if indexes are not ready, since it would take to long", "+\t\t\t\t// to wait until indexes are fully rebuild", "+\t\t\t\tIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,", "+\t\t\t\tmonitor == null ? null : new SubProgressMonitor(monitor, 99) // 99% of the time is spent in the dummy search", "+\t\t\t); ", "+\t\t} catch (OperationCanceledException e) {", "+\t\t\t// indexes were not ready", "+\t\t}"]}], "num": 32201}