{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c13f5452497d3473fabb6c8774d1c8d1", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5b2433c79e73691fb2da9993c09df3d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java", "commitBeforeChange": "e70a97840585a3ede400b971666912929897851b", "commitAfterChange": "f5104ea8b01f4418b9868445123db4c689077583", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " private void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion)", "signatureAfterChange": " private void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion, IProgressMonitor monitor)", "diff": ["-private void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion) {", "+private void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion, IProgressMonitor monitor) {", "-\t\t\tworked(1);", "-\t// resolve", "-\tif (infosSize > 0 || unitsSize > 0) {", "-\t\tIType focusType = this.getType();", "-\t\tCompilationUnit unitToLookInside = null;", "-\t\tif (focusType != null) {", "-\t\t\tunitToLookInside = (CompilationUnit)focusType.getCompilationUnit();", "-\t\t}", "-\t\tif (this.nameLookup != null && unitToLookInside != null) {", "-\t\t\tsynchronized(this.nameLookup) { // prevent 2 concurrent accesses to name lookup while the working copies are set", "-\t\t\t\ttry {", "-\t\t\t\t\tnameLookup.setUnitsToLookInside(new IWorkingCopy[] {unitToLookInside});", "-\t\t\t\t\tthis.hierarchyResolver.resolve(genericTypes, compilationUnits);", "-\t\t\t\t} finally {", "-\t\t\t\t\tnameLookup.setUnitsToLookInside(null);", "-\t\t\t\t}", "+\ttry {", "+\t\t// resolve", "+\t\tif (monitor != null) monitor.beginTask(\"\", (infosSize+unitsSize) * 2/* 1 for build binding, 1 for connect hierarchy*/); //$NON-NLS-1$", "+\t\tif (infosSize > 0 || unitsSize > 0) {", "+\t\t\tIType focusType = this.getType();", "+\t\t\tCompilationUnit unitToLookInside = null;", "+\t\t\tif (focusType != null) {", "+\t\t\t\tunitToLookInside = (CompilationUnit)focusType.getCompilationUnit();", "-\t\t} else {", "-\t\t\tthis.hierarchyResolver.resolve(genericTypes, compilationUnits);", "+\t\t\tif (this.nameLookup != null && unitToLookInside != null) {", "+\t\t\t\tsynchronized(this.nameLookup) { // prevent 2 concurrent accesses to name lookup while the working copies are set", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tnameLookup.setUnitsToLookInside(new IWorkingCopy[] {unitToLookInside});", "+\t\t\t\t\t\tthis.hierarchyResolver.resolve(genericTypes, compilationUnits, monitor);", "+\t\t\t\t\t} finally {", "+\t\t\t\t\t\tnameLookup.setUnitsToLookInside(null);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.hierarchyResolver.resolve(genericTypes, compilationUnits, monitor);", "+\t\t\t}", "+\t} finally {", "+\t\tif (monitor != null) monitor.done();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7c2158c7eb9aadcd19546f3a97934d95", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "e70a97840585a3ede400b971666912929897851b", "commitAfterChange": "f5104ea8b01f4418b9868445123db4c689077583", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "signatureAfterChange": " private void buildFromPotentialSubtypes(String[] allPotentialSubTypes, IProgressMonitor monitor)", "diff": ["-private void buildFromPotentialSubtypes(String[] allPotentialSubTypes) {", "+private void buildFromPotentialSubtypes(String[] allPotentialSubTypes, IProgressMonitor monitor) {", "-\t// create element infos for subtypes", "-\tHandleFactory factory = new HandleFactory(ResourcesPlugin.getWorkspace());", "-\tIJavaProject currentProject = null;", "-\tfor (int i = 0; i < length; i++) {", "-\t\ttry {", "-\t\t\tString resourcePath = allPotentialSubTypes[i];", "-\t\t\t", "-\t\t\t// skip duplicate paths (e.g. if focus path was injected when it was already a potential subtype)", "-\t\t\tif (i > 0 && resourcePath.equals(allPotentialSubTypes[i-1])) continue;", "-\t\t\t", "-\t\t\tOpenable handle;", "-\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(resourcePath);", "-\t\t\tif (workingCopy != null) {", "-\t\t\t\thandle = (Openable)workingCopy;", "-\t\t\t} else {", "-\t\t\t\thandle = ", "-\t\t\t\t\tresourcePath.equals(focusPath) ? ", "-\t\t\t\t\t\tfocusCU :", "-\t\t\t\t\t\tfactory.createOpenable(resourcePath, this.scope);", "-\t\t\t\tif (handle == null) continue; // match is outside classpath", "-\t\t\t}", "-\t\t\t", "-\t\t\tIJavaProject project = handle.getJavaProject();", "-\t\t\tif (currentProject == null) {", "-\t\t\t\tcurrentProject = project;", "-\t\t\t\tinfos = new ArrayList(5);", "-\t\t\t\tunits = new ArrayList(5);", "-\t\t\t} else if (!currentProject.equals(project)) {", "-\t\t\t\t// build current project", "-\t\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies);", "-\t\t\t\tcurrentProject = project;", "-\t\t\t\tinfos = new ArrayList(5);", "-\t\t\t\tunits = new ArrayList(5);", "-\t\t\t}", "-\t\t\t", "-\t\t\tthis.addInfoFromElement(handle, infos, units, resourcePath);", "-\t\t\t", "-\t\t\tworked(1);", "-\t\t} catch (JavaModelException e) {", "-\t\t\tcontinue;", "-\t\t}", "-\t}", "-\t", "-\t// build last project", "-\t\tif (currentProject == null) {", "-\t\t\t// case of no potential subtypes", "-\t\t\tcurrentProject = focusType.getJavaProject();", "-\t\t\tthis.addInfosFromType(focusType, infos);", "+\t\t// create element infos for subtypes", "+\t\tHandleFactory factory = new HandleFactory(ResourcesPlugin.getWorkspace());", "+\t\tIJavaProject currentProject = null;", "+\t\tif (monitor != null) monitor.beginTask(\"\", length*2 /* 1 for build binding, 1 for connect hierarchy*/); //$NON-NLS-1$", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\ttry {", "+\t\t\t\tString resourcePath = allPotentialSubTypes[i];", "+\t\t\t\t", "+\t\t\t\t// skip duplicate paths (e.g. if focus path was injected when it was already a potential subtype)", "+\t\t\t\tif (i > 0 && resourcePath.equals(allPotentialSubTypes[i-1])) continue;", "+\t\t\t\t", "+\t\t\t\tOpenable handle;", "+\t\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(resourcePath);", "+\t\t\t\tif (workingCopy != null) {", "+\t\t\t\t\thandle = (Openable)workingCopy;", "+\t\t\t\t} else {", "+\t\t\t\t\thandle = ", "+\t\t\t\t\t\tresourcePath.equals(focusPath) ? ", "+\t\t\t\t\t\t\tfocusCU :", "+\t\t\t\t\t\t\tfactory.createOpenable(resourcePath, this.scope);", "+\t\t\t\t\tif (handle == null) continue; // match is outside classpath", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tIJavaProject project = handle.getJavaProject();", "+\t\t\t\tif (currentProject == null) {", "+\t\t\t\t\tcurrentProject = project;", "+\t\t\t\t\tinfos = new ArrayList(5);", "+\t\t\t\t\tunits = new ArrayList(5);", "+\t\t\t\t} else if (!currentProject.equals(project)) {", "+\t\t\t\t\t// build current project", "+\t\t\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies, monitor);", "+\t\t\t\t\tcurrentProject = project;", "+\t\t\t\t\tinfos = new ArrayList(5);", "+\t\t\t\t\tunits = new ArrayList(5);", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tthis.addInfoFromElement(handle, infos, units, resourcePath);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\tcontinue;", "+\t\t\t}", "-\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies);", "-\t} catch (JavaModelException e) {", "-\t}", "-\t", "-\t// Compute hierarchy of focus type if not already done (case of a type with potential subtypes that are not real subtypes)", "-\tif (!this.hierarchy.contains(focusType)) {", "+\t\t", "+\t\t// build last project", "-\t\t\tcurrentProject = focusType.getJavaProject();", "-\t\t\tinfos = new ArrayList();", "-\t\t\tunits = new ArrayList();", "-\t\t\tthis.addInfosFromType(focusType, infos);", "-\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies);", "+\t\t\tif (currentProject == null) {", "+\t\t\t\t// case of no potential subtypes", "+\t\t\t\tcurrentProject = focusType.getJavaProject();", "+\t\t\t\tthis.addInfosFromType(focusType, infos);", "+\t\t\t}", "+\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies, monitor);", "-\t}", "-\t", "-\t// Add focus if not already in (case of a type with no explicit super type)", "-\tif (!this.hierarchy.contains(focusType)) {", "-\t\tthis.hierarchy.addRootClass(focusType);", "+\t\t", "+\t\t// Compute hierarchy of focus type if not already done (case of a type with potential subtypes that are not real subtypes)", "+\t\tif (!this.hierarchy.contains(focusType)) {", "+\t\t\ttry {", "+\t\t\t\tcurrentProject = focusType.getJavaProject();", "+\t\t\t\tinfos = new ArrayList();", "+\t\t\t\tunits = new ArrayList();", "+\t\t\t\tthis.addInfosFromType(focusType, infos);", "+\t\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies, monitor);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Add focus if not already in (case of a type with no explicit super type)", "+\t\tif (!this.hierarchy.contains(focusType)) {", "+\t\t\tthis.hierarchy.addRootClass(focusType);", "+\t\t}", "+\t} finally {", "+\t\tif (monitor != null) monitor.done();"]}], "num": 6179}