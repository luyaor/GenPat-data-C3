{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4c6ef830bde30dda6019df843b1950c8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1559b8a89ba552c5040a194c169b9d12", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "13a2bff8811ff586bab60fddd157d395e6533570", "commitAfterChange": "4e8c06d42dcf2a91f77056993fc995ad49c4f7d9", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-/*\t\t\t", "-\t\t\tcst = this.valueIfTrue.optimizedBooleanConstant();", "-\t\t\tboolean isValueIfTrueOptimizedTrue = cst != NotAConstant && cst.booleanValue() == true;", "-\t\t\tboolean isValueIfTrueOptimizedFalse = cst != NotAConstant && cst.booleanValue() == false;", "+\t\t\tcst = this.optimizedIfTrueConstant;", "+\t\t\tboolean isValueIfTrueOptimizedTrue = cst != null && cst != NotAConstant && cst.booleanValue() == true;", "+\t\t\tboolean isValueIfTrueOptimizedFalse = cst != null && cst != NotAConstant && cst.booleanValue() == false;", "-\t\t\tcst = this.valueIfFalse.optimizedBooleanConstant();", "-\t\t\tboolean isValueIfFalseOptimizedTrue = cst != NotAConstant && cst.booleanValue() == true;", "-\t\t\tboolean isValueIfFalseOptimizedFalse = cst != NotAConstant && cst.booleanValue() == false;", "-*/", "+\t\t\tcst = this.optimizedIfFalseConstant;", "+\t\t\tboolean isValueIfFalseOptimizedTrue = cst != null && cst != NotAConstant && cst.booleanValue() == true;", "+\t\t\tboolean isValueIfFalseOptimizedFalse = cst != null && cst != NotAConstant && cst.booleanValue() == false;", "+", "+\t\t\tUnconditionalFlowInfo trueInfoWhenTrue = trueFlowInfo.initsWhenTrue().copy().unconditionalInits();", "+\t\t\tif (isValueIfTrueOptimizedFalse) trueInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE); ", "+", "+\t\t\tUnconditionalFlowInfo falseInfoWhenTrue = falseFlowInfo.initsWhenTrue().copy().unconditionalInits();", "+\t\t\tif (isValueIfFalseOptimizedFalse) falseInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE); ", "+\t\t\t", "+\t\t\tUnconditionalFlowInfo trueInfoWhenFalse = trueFlowInfo.initsWhenFalse().copy().unconditionalInits();", "+\t\t\tif (isValueIfTrueOptimizedTrue) trueInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE); ", "+", "+\t\t\tUnconditionalFlowInfo falseInfoWhenFalse = falseFlowInfo.initsWhenFalse().copy().unconditionalInits();", "+\t\t\tif (isValueIfFalseOptimizedTrue) falseInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE); ", "+", "-\t\t\t\t\ttrueFlowInfo.initsWhenTrue().copy().unconditionalInits().mergedWith( // must copy, since could be shared with trueInfo.initsWhenFalse()...", "-\t\t\t\t\t\tfalseFlowInfo.initsWhenTrue().copy().unconditionalInits()),", "-\t\t\t\t\ttrueFlowInfo.initsWhenFalse().unconditionalInits().mergedWith(", "-\t\t\t\t\t\tfalseFlowInfo.initsWhenFalse().unconditionalInits()));", "+\t\t\t\t\ttrueInfoWhenTrue.mergedWith(falseInfoWhenTrue),", "+\t\t\t\t\ttrueInfoWhenFalse.mergedWith(falseInfoWhenFalse));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ee2accaf9ceb628f483239f80e9a829", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java", "commitBeforeChange": "71a2279542d7f81c81ac185c946009de95de9746", "commitAfterChange": "a8db9d6e29539ad424b2aeb72ada09e6eab41c24", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  SimpleLookupTable directoryTable(String qualifiedPackageName)", "signatureAfterChange": "  SimpleLookupTable directoryTable(String qualifiedPackageName)", "diff": ["+\t\t\t// look for secondary types, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=382778", "+\t\t\tIJavaProject project = JavaCore.create(container.getProject());", "+\t\t\tMap secondaryTypePaths = JavaModelManager.getJavaModelManager().secondaryTypes(project, false, null);", "+\t\t\tif (secondaryTypePaths.size() > 0) {", "+\t\t\t\tMap typesInPackage = (Map) secondaryTypePaths.get(qualifiedPackageName);", "+\t\t\t\tif (typesInPackage != null && typesInPackage.size() > 0) {", "+\t\t\t\t\tfor (Iterator j = typesInPackage.keySet().iterator(); j.hasNext();) {", "+\t\t\t\t\t\tString secondaryTypeName = (String) j.next();", "+\t\t\t\t\t\tIType secondaryType = (IType) typesInPackage.get(secondaryTypeName);", "+\t\t\t\t\t\tIJavaElement parent = secondaryType.getParent();", "+\t\t\t\t\t\tString fullPath = parent.getResource().getFullPath().toString();", "+\t\t\t\t\t\tif (!org.eclipse.jdt.internal.compiler.util.Util.isExcluded(fullPath.toCharArray(), this.fulInclusionPatternChars, this.fullExclusionPatternChars, false/*not a folder path*/)) {", "+\t\t\t\t\t\t\tdirTable.put(secondaryTypeName, parent.getResource());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b0dc0dde042a9c728844295a31fcaad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "cc7aa64325098cb95ddb21b1ff5c605a41d7b6cb", "commitAfterChange": "62d5e4ea01329275dd7873def8e9944099937650", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "diff": ["+\r", "+\t// tolerate null path, it will be reset to default\r", "+\tint length = classpath == null ? 0 : classpath.length; \r", "+\r", "-\tfor (int i = 0, length = classpath.length ; i < length; i++) {\r", "+\tfor (int i = 0 ; i < length; i++) {\r", "+\tObjectSet pathes = new ObjectSet(length);\r", "+\t\r", "-\tfor (int i = 0 ; i < classpath.length; i++) {\r", "+\tfor (int i = 0 ; i < length; i++) {\r", "-\t\tif (entry == null) continue;\r", "-\t\tIPath entryPath = entry.getPath();\r", "+\t\tif (entry == null) continue;\r", "+\r", "+\t\tIPath entryPath = entry.getPath();\r", "+\t\tint kind = entry.getEntryKind();\r", "+\r", "+\t\t// complain if duplicate path\r", "+\t\tif (!pathes.add(entryPath)){\r", "+\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.NAME_COLLISION, Util.bind(\"classpath.duplicateEntryPath\", entryPath.toString())); //$NON-NLS-1$\r", "+\t\t}\r", "-\t\tif (entryPath.equals(projectPath)) continue;\r", "+\t\tif (entryPath.equals(projectPath)){\r", "+\t\t\t// complain if self-referring project entry\r", "+\t\t\tif (kind == IClasspathEntry.CPE_PROJECT){\r", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, Util.bind(\"classpath.cannotReferToItself\", entryPath.toString()));//$NON-NLS-1$\r", "+\t\t\t}\r", "+\t\t\tcontinue;\r", "+\t\t}\r", "-\t\t\r", "+\r", "+\r", "-\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE){\r", "+\t\tif (kind == IClasspathEntry.CPE_SOURCE \r", "+\t\t\t\t|| (kind == IClasspathEntry.CPE_LIBRARY && !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(entryPath.toString()))){\r", "-\t\t\t\tif (entry != otherEntry && otherEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE){\r", "-\t\t\t\t\tif (entryPath.isPrefixOf(otherEntry.getPath())){\r", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestSourceFolderInSource\",entryPath.toString(), otherEntry.getPath().toString())); //$NON-NLS-1$\r", "+\t\t\t\tint otherKind = otherEntry.getEntryKind();\r", "+\t\t\t\tif (entry != otherEntry \r", "+\t\t\t\t\t&& (otherKind == IClasspathEntry.CPE_SOURCE \r", "+\t\t\t\t\t\t\t|| (otherKind == IClasspathEntry.CPE_LIBRARY \r", "+\t\t\t\t\t\t\t\t\t&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(otherEntry.getPath().toString())))){\r", "+\t\t\t\t\tif (otherEntry.getPath().isPrefixOf(entryPath)){\r", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInEntry\", entryPath.toString(), otherEntry.getPath().toString())); //$NON-NLS-1$\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66ae3fc1a256a2d5d7ab7fdc1295e4cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java", "commitBeforeChange": "8c9f236498368a5c4b97ae0ebfef0c4abc8dc11a", "commitAfterChange": "ae52a28648d52b5eafe0fdcc634d32123f7b745b", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  SimpleLookupTable directoryTable(String qualifiedPackageName)", "signatureAfterChange": "  SimpleLookupTable directoryTable(String qualifiedPackageName)", "diff": ["+\t\t\t// look for secondary types, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=382778", "+\t\t\tIJavaProject project = JavaCore.create(container.getProject());", "+\t\t\tMap secondaryTypePaths = JavaModelManager.getJavaModelManager().secondaryTypes(project, false, null);", "+\t\t\tif (secondaryTypePaths.size() > 0) {", "+\t\t\t\tMap typesInPackage = (Map) secondaryTypePaths.get(qualifiedPackageName);", "+\t\t\t\tif (typesInPackage != null && typesInPackage.size() > 0) {", "+\t\t\t\t\tfor (Iterator j = typesInPackage.keySet().iterator(); j.hasNext();) {", "+\t\t\t\t\t\tString secondaryTypeName = (String) j.next();", "+\t\t\t\t\t\tIType secondaryType = (IType) typesInPackage.get(secondaryTypeName);", "+\t\t\t\t\t\tIJavaElement parent = secondaryType.getParent();", "+\t\t\t\t\t\tString fullPath = parent.getResource().getFullPath().toString();", "+\t\t\t\t\t\tif (!org.eclipse.jdt.internal.compiler.util.Util.isExcluded(fullPath.toCharArray(), this.fulInclusionPatternChars, this.fullExclusionPatternChars, false/*not a folder path*/)) {", "+\t\t\t\t\t\t\tdirTable.put(secondaryTypeName, parent.getResource());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9181a416e7179b5bcd64dd16b549dfc3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironmentRequestor.java", "commitBeforeChange": "11c24986fc925cfc43f4c88e72e0daee39a1576b", "commitAfterChange": "55350d5af8386833b94a470ab6a0d389ee3fc665", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void acceptType(IType type)", "signatureAfterChange": " public void acceptType(IType type)", "diff": ["-\t\tif (fUnitToSkip != null && fUnitToSkip.equals(type.getCompilationUnit())){", "+\t\tif (this.unitToSkip != null && this.unitToSkip.equals(type.getCompilationUnit())){", "+\t\tString packageName = type.getPackageFragment().getElementName();", "+\t\tString typeName = type.getElementName();", "+\t\tboolean isBinary = type instanceof BinaryType;", "+\t\t", "+\t\t// determine associated access restriction", "+\t\tAccessRestriction accessRestriction = null;", "+\t\t", "+\t\tif (this.checkAccessRestrictions && (isBinary || !type.getJavaProject().equals(this.project))) {", "+\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)type.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);", "+\t\t\tClasspathEntry entry = (ClasspathEntry) this.nameLookup.rootToResolvedEntries.get(root);", "+\t\t\tif (entry != null) { // reverse map always contains resolved CP entry", "+\t\t\t\taccessRestriction = entry.getImportRestriction();", "+\t\t\t\tif (accessRestriction != null) {", "+\t\t\t\t\t// TODO (philippe) improve char[] <-> String conversions to avoid performing them on the fly", "+\t\t\t\t\tchar[][] packageChars = CharOperation.splitOn('.', packageName.toCharArray());", "+\t\t\t\t\tchar[] typeChars = typeName.toCharArray();", "+\t\t\t\t\taccessRestriction = accessRestriction.getViolatedRestriction(CharOperation.concatWith(packageChars, typeChars, '/'), null);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\t\tfRequestor.acceptClass(type.getPackageFragment().getElementName().toCharArray(), type.getElementName().toCharArray(), type.getFlags());", "+\t\t\tthis.requestor.acceptClass(type.getPackageFragment().getElementName().toCharArray(), type.getElementName().toCharArray(), type.getFlags(), accessRestriction);", "-\t\t\tfRequestor.acceptInterface(type.getPackageFragment().getElementName().toCharArray(), type.getElementName().toCharArray(), type.getFlags());", "+\t\t\tthis.requestor.acceptInterface(type.getPackageFragment().getElementName().toCharArray(), type.getElementName().toCharArray(), type.getFlags(), accessRestriction);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f8edb62d9f2b1be7e1c49d5146b5618d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/ProcessorEnvImpl.java", "commitBeforeChange": "03e205d7db02078dce9accf78d78c9d9a6ce6117", "commitAfterChange": "7ff51a474972e200f8003fdc2186f43ef4e82e14", "methodNumberBeforeChange": 71, "methodNumberAfterChange": 71, "signatureBeforeChange": "      void postMarkers()", "signatureAfterChange": "      void postMarkers()", "diff": ["+    \t// for those markers that doesn't have an ending offset, figure it out by", "+    \t// traversing the ast.", "+    \t// we do it once just before we post the marker so we only have to walk the ast ", "+    \t// once.", "+    \tint count = 0;", "+    \tfor( MarkerInfo markerInfo : _markerInfos ){    \t\t", "+    \t\tif( markerInfo._markerAttrs.get(IMarker.CHAR_END) == null ) ", "+    \t\t\tcount ++;", "+    \t}", "+    \tif( count > 0 ){", "+\t    \tfinal int[] startingOffsets = new int[count];", "+\t    \tint index = 0;", "+\t    \tfor( MarkerInfo markerInfo : _markerInfos ){    \t\t", "+\t    \t\tif( markerInfo._markerAttrs.get(IMarker.CHAR_END) == null ){", "+\t    \t\t\tfinal Integer startingOffset = (Integer)markerInfo._markerAttrs.get(IMarker.CHAR_START);", "+\t    \t\t\tstartingOffsets[index++] = startingOffset.intValue();", "+\t    \t\t}", "+\t    \t}", "+\t    \t", "+\t    \tfinal EndingOffsetFinder lfinder = new EndingOffsetFinder(startingOffsets);", "+\t    \t_astCompilationUnit.accept( lfinder );", "+\t    \t", "+\t    \tfor( MarkerInfo markerInfo : _markerInfos ){    \t\t", "+\t    \t\tif( markerInfo._markerAttrs.get(IMarker.CHAR_END) == null ){", "+\t    \t\t\tfinal int startingOffset = ", "+\t    \t\t\t\t((Integer)markerInfo._markerAttrs.get(IMarker.CHAR_START)).intValue();", "+\t    \t\t\tint endingOffset = lfinder.getEndingOffset(startingOffset);", "+\t    \t\t\tif( endingOffset == 0 )", "+\t    \t\t\t\tendingOffset = startingOffset;", "+\t    \t\t\tmarkerInfo._markerAttrs.put(IMarker.CHAR_END, endingOffset);", "+\t    \t\t}", "+\t    \t}", "+    \t}", "+    \t", "-\t\t\tfinal IResource currentResource = _file;", "+\t\t\tfinal IResource currentResource = _file; ", "-\t            {", "+\t            {\t            ", "-\t\t\t\t\t\t\t\t\t\t\t  RECONCILE_MARKER : BUILD_MARKER;", "+\t\t\t\t\t\t\t\t\t\t\t  RECONCILE_MARKER : BUILD_MARKER;\t\t\t\t"]}], "num": 26393}