{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "54279fd7a087276417fde264def1634b", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1c6d6ee2ea8506f56f399c6820ffaffb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "1807cc67396ea9076c76cb31f2d61c82f124d048", "commitAfterChange": "52597fb7db7ddfe8d0d19142d700054ae1d908a1", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t\t\tpublic void preferenceChange(PreferenceChangeEvent event)", "signatureAfterChange": " \tpublic void handlePreferenceChange(String key, String oldValue, String newValue)", "diff": ["-\t\tIPreferenceChangeListener projListener = new IPreferenceChangeListener() {", "-\t\t\tpublic void preferenceChange(PreferenceChangeEvent event) {", "-\t\t\t\t", "-\t\t\t\tfinal String newValue = (String)event.getNewValue();", "-\t\t\t\tif (newValue == null) {", "-\t\t\t\t\t// Null is used to indicate this preference has", "-\t\t\t\t\t// been removed, as the project has been deleted.", "-\t\t\t\t\t// We do nothing", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t\tfinal String oldValue = (String)event.getOldValue();", "-\t\t\t\tif (newValue.equals(oldValue)) {", "-\t\t\t\t\t// No-op -- same config", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\tif (AptPreferenceConstants.APT_GENSRCDIR.equals(event.getKey())) {", "-\t\t\t\t\tfinal boolean aptEnabled = AptConfig.isEnabled(_aptProject.getJavaProject());", "-\t\t\t\t\tif( AptPlugin.DEBUG )", "-\t\t\t\t\t\tAptPlugin.trace(\"configure generated source directory new value = \" +  //$NON-NLS-1$", "-\t\t\t\t\t\t\t\tnewValue + ", "-\t\t\t\t\t\t\t\t\" old value = \"  + oldValue + //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\" APT is enabled = \" + aptEnabled); //$NON-NLS-1$", "-\t\t\t\t\t// If APT is enabled, ", "-\t\t\t\t\t// clean up the old cp entry, delete the old folder, ", "-\t\t\t\t\t// create the new one and update the classpath.", "-\t\t\t\t\tif( aptEnabled )", "-\t\t\t\t\t\tconfigureGeneratedSourceFolder( newValue, oldValue );", "-\t\t\t\t\telse", "-\t\t\t\t\t\tsetGeneratedSourceFolderName(newValue);", "-\t\t\t\t}", "-\t\t\t\telse if(AptPreferenceConstants.APT_ENABLED.equals(event.getKey()) ){", "-\t\t\t\t\tif( AptPlugin.DEBUG ){", "-\t\t\t\t\t\tAptPlugin.trace(\"Got preference change event for \" + AptPreferenceConstants.APT_ENABLED ); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\t// no-op;", "-\t\t\t\t\tif(newValue.equals(oldValue)){", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\tfinal boolean isEnabling = Boolean.parseBoolean(newValue);", "-\t\t\t\t\tif( AptPlugin.DEBUG ){", "-\t\t\t\t\t\tif( isEnabling )", "-\t\t\t\t\t\t\tAptPlugin.trace(\"enabling APT for \" + _aptProject.getJavaProject().getElementName()); //$NON-NLS-1$", "-\t\t\t\t\t\telse", "-\t\t\t\t\t\t\tAptPlugin.trace(\"diabling APT \" + _aptProject.getJavaProject().getElementName()); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t\tif( isEnabling )", "-\t\t\t\t\t\tconfigureGeneratedSourceFolder();", "-\t\t\t\t\telse{", "-\t\t\t\t\t\tfinal IFolder srcFolder = getGeneratedSourceFolder();", "-\t\t\t\t\t\tprojectClean(true);", "-\t\t\t\t\t\tresetGeneratedSrcFolder(srcFolder, false);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "+\t */", "+\tpublic void handlePreferenceChange(String key, String oldValue, String newValue) ", "+\t{", "+\t\tif (newValue == null) {", "+\t\t\t// Null is used to indicate this preference has", "+\t\t\t// been removed, as the project has been deleted.", "+\t\t\t// We do nothing", "+\t\t\treturn;", "+\t\t}", "+\t\tif (newValue.equals(oldValue)) {", "+\t\t\t// No-op -- same config", "+\t\t\treturn;", "+\t\t}", "+\t\t", "+\t\tif (AptPreferenceConstants.APT_GENSRCDIR.equals(key)) {", "+\t\t\tfinal boolean aptEnabled = AptConfig.isEnabled(_aptProject.getJavaProject());", "+\t\t\tif( AptPlugin.DEBUG )", "+\t\t\t\tAptPlugin.trace(\"configure generated source directory new value = \" +  //$NON-NLS-1$", "+\t\t\t\t\t\tnewValue + ", "+\t\t\t\t\t\t\" old value = \"  + oldValue + //$NON-NLS-1$", "+\t\t\t\t\t\t\" APT is enabled = \" + aptEnabled); //$NON-NLS-1$", "+\t\t\t// If APT is enabled, ", "+\t\t\t// clean up the old cp entry, delete the old folder, ", "+\t\t\t// create the new one and update the classpath.", "+\t\t\tif( aptEnabled )", "+\t\t\t\tconfigureGeneratedSourceFolder( newValue, oldValue );", "+\t\t\telse", "+\t\t\t\tsetGeneratedSourceFolderName(newValue);", "+\t\t}", "+\t\telse if(AptPreferenceConstants.APT_ENABLED.equals(key) ){", "+\t\t\tif( AptPlugin.DEBUG ){", "+\t\t\t\tAptPlugin.trace(\"Got preference change event for \" + AptPreferenceConstants.APT_ENABLED ); //$NON-NLS-1$", "+\t\t\t}", "+\t\t\t", "+\t\t\tfinal boolean isEnabling = Boolean.parseBoolean(newValue);", "+\t\t\tif( AptPlugin.DEBUG ){", "+\t\t\t\tif( isEnabling )", "+\t\t\t\t\tAptPlugin.trace(\"enabling APT for \" + _aptProject.getJavaProject().getElementName()); //$NON-NLS-1$", "+\t\t\t\telse", "+\t\t\t\t\tAptPlugin.trace(\"diabling APT \" + _aptProject.getJavaProject().getElementName()); //$NON-NLS-1$", "+\t\t\t}", "+\t\t\tif( isEnabling )", "+\t\t\t\tconfigureGeneratedSourceFolder();", "+\t\t\telse{", "+\t\t\t\tfinal IFolder srcFolder = getGeneratedSourceFolder();", "+\t\t\t\tprojectClean(true);", "+\t\t\t\tresetGeneratedSrcFolder(srcFolder, false);", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34e49851c47b18a4b7c0e8e6a3c1a25c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "e67d1dc6830648c83fdb0e0b83b59925424638d8", "commitAfterChange": "4817a4bde9db799e7a793068d64037f59bfa521f", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": " void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding)", "signatureAfterChange": " void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding)", "diff": ["-\tif (nullableAnnotationName == null || nonNullAnnotationName == null)", "+\tchar[][] nonNullByDefaultAnnotationName = this.environment.getNonNullByDefaultAnnotationName();", "+\tif (nullableAnnotationName == null || nonNullAnnotationName == null || nonNullByDefaultAnnotationName == null)", "+", "+\tint currentDefault = NO_NULL_DEFAULT;", "+\tif ((this.tagBits & TagBits.AnnotationNonNullByDefault) != 0) {", "+\t\tcurrentDefault = NONNULL_BY_DEFAULT;", "+\t} else if ((this.tagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0) {", "+\t\tcurrentDefault = NULL_UNSPECIFIED_BY_DEFAULT;", "+\t}", "+\tboolean explicitNullness = false;", "-\t\t\tif (CharOperation.equals(typeName, nonNullAnnotationName)) {", "-\t\t\t\tmethodBinding.tagBits |= TagBits.AnnotationNonNull;", "-\t\t\t\tbreak;", "+\t\t\tif (CharOperation.equals(typeName, nonNullByDefaultAnnotationName)) {", "+\t\t\t\tmethodBinding.tagBits |= TagBits.AnnotationNonNullByDefault;", "+\t\t\t\tcurrentDefault = NONNULL_BY_DEFAULT;", "-\t\t\tif (CharOperation.equals(typeName, nullableAnnotationName)) {", "+\t\t\tif (!explicitNullness && CharOperation.equals(typeName, nonNullAnnotationName)) {", "+\t\t\t\tmethodBinding.tagBits |= TagBits.AnnotationNonNull;", "+\t\t\t\texplicitNullness = true;", "+\t\t\t}", "+\t\t\tif (!explicitNullness && CharOperation.equals(typeName, nullableAnnotationName)) {", "-\t\t\t\tbreak;", "+\t\t\t\texplicitNullness = true;", "+\t}", "+\tif (!explicitNullness && currentDefault == NONNULL_BY_DEFAULT) {", "+\t\tmethodBinding.tagBits |= TagBits.AnnotationNonNull;", "-\tif (numParamAnnotations > 0) {", "-\t\tint startIndex = numParamAnnotations - numVisibleParams;", "+\tif (numParamAnnotations > 0 || currentDefault == NONNULL_BY_DEFAULT) {", "-\t\t\tIBinaryAnnotation[] paramAnnotations = method.getParameterAnnotations(j+startIndex);", "-\t\t\tif (paramAnnotations != null) {", "-\t\t\t\tfor (int i = 0; i < paramAnnotations.length; i++) {", "-\t\t\t\t\tchar[] annotationTypeName = paramAnnotations[i].getTypeName();", "-\t\t\t\t\tif (annotationTypeName[0] != Util.C_RESOLVED)", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\tchar[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'", "-\t\t\t\t\tif (CharOperation.equals(typeName, nonNullAnnotationName)) {", "-\t\t\t\t\t\tif (methodBinding.parameterNonNullness == null)", "-\t\t\t\t\t\t\tmethodBinding.parameterNonNullness = new Boolean[numVisibleParams];", "-\t\t\t\t\t\tmethodBinding.parameterNonNullness[j] = Boolean.TRUE;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t} else if (CharOperation.equals(typeName, nullableAnnotationName)) {", "-\t\t\t\t\t\tif (methodBinding.parameterNonNullness == null)", "-\t\t\t\t\t\t\tmethodBinding.parameterNonNullness = new Boolean[numVisibleParams];", "-\t\t\t\t\t\tmethodBinding.parameterNonNullness[j] = Boolean.FALSE;", "-\t\t\t\t\t\tbreak;", "+\t\t\texplicitNullness = false;", "+\t\t\tif (numParamAnnotations > 0) {", "+\t\t\t\tint startIndex = numParamAnnotations - numVisibleParams;", "+\t\t\t\tIBinaryAnnotation[] paramAnnotations = method.getParameterAnnotations(j+startIndex);", "+\t\t\t\tif (paramAnnotations != null) {", "+\t\t\t\t\tfor (int i = 0; i < paramAnnotations.length; i++) {", "+\t\t\t\t\t\tchar[] annotationTypeName = paramAnnotations[i].getTypeName();", "+\t\t\t\t\t\tif (annotationTypeName[0] != Util.C_RESOLVED)", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\tchar[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'", "+\t\t\t\t\t\tif (CharOperation.equals(typeName, nonNullAnnotationName)) {", "+\t\t\t\t\t\t\tif (methodBinding.parameterNonNullness == null)", "+\t\t\t\t\t\t\t\tmethodBinding.parameterNonNullness = new Boolean[numVisibleParams];", "+\t\t\t\t\t\t\tmethodBinding.parameterNonNullness[j] = Boolean.TRUE;", "+\t\t\t\t\t\t\texplicitNullness = true;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t} else if (CharOperation.equals(typeName, nullableAnnotationName)) {", "+\t\t\t\t\t\t\tif (methodBinding.parameterNonNullness == null)", "+\t\t\t\t\t\t\t\tmethodBinding.parameterNonNullness = new Boolean[numVisibleParams];", "+\t\t\t\t\t\t\tmethodBinding.parameterNonNullness[j] = Boolean.FALSE;", "+\t\t\t\t\t\t\texplicitNullness = true;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (!explicitNullness && currentDefault == NONNULL_BY_DEFAULT) {", "+\t\t\t\tif (methodBinding.parameterNonNullness == null)", "+\t\t\t\t\tmethodBinding.parameterNonNullness = new Boolean[numVisibleParams];", "+\t\t\t\tmethodBinding.parameterNonNullness[j] = Boolean.TRUE;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53356ecce67a8b850b54986145f1ee72", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java", "commitBeforeChange": "4d19416746402b8fbbfd02c13772658da70a345a", "commitAfterChange": "81400db64234d6cf1ce3b6a87a8f065ac6bd072f", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \r protected char[][][] collect()", "signatureAfterChange": "\r \r protected char[][][] collect() throws JavaModelException", "diff": ["-protected char[][][] collect() {\r", "-\t\t\r", "-\t// Collect the paths of the cus that declare a type which matches declaringQualification + declaringSimpleName\r", "-\tString[] paths = this.getPathsOfDeclaringType();\r", "+protected char[][][] collect() throws JavaModelException {\r", "-\t// Create bindings from source types and binary types\r", "-\t// and collect super type names of the type declaration \r", "-\t// that match the given declaring type\r", "-\tif (paths != null) {\r", "+\tif (this.type != null) {\r", "-\t\tfor (int i = 0, length = paths.length; i < length; i++) {\r", "+\t\tthis.createParser((JavaProject)this.type.getJavaProject());\r", "+\t\tif (this.type.isBinary()) {\r", "+\t\t\tBinaryTypeBinding binding = this.cacheBinaryType(this.type);\r", "+\t\t\tthis.collectSuperTypeNames(binding);\r", "+\t\t} else {\r", "-\t\t\t\tOpenable openable = locator.handleFactory.createOpenable(paths[i]);\r", "-\t\t\t\tif (openable == null)\r", "-\t\t\t\t\tcontinue; // outside classpath\r", "-\t\t\t\tif (openable instanceof ICompilationUnit) {\r", "-\t\t\t\t\tICompilationUnit unit = (ICompilationUnit)openable;\r", "-\t\t\t\t\tCompilationUnitDeclaration parsedUnit = locator.buildBindings(unit);\r", "-\t\t\t\t\tif (parsedUnit != null) {\r", "-\t\t\t\t\t\tparsedUnit.traverse(new TypeDeclarationVisitor(), parsedUnit.scope);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t} else if (openable instanceof IClassFile) {\r", "-\t\t\t\t\tIClassFile classFile = (IClassFile)openable;\r", "-\t\t\t\t\tBinaryTypeBinding binding = this.cacheBinaryType(classFile.getType());\r", "-\t\t\t\t\tif (this.matches(binding)) {\r", "-\t\t\t\t\t\tthis.collectSuperTypeNames(binding);\r", "-\t\t\t\t\t}\r", "+\t\t\t\tICompilationUnit unit = this.type.getCompilationUnit();\r", "+\t\t\t\tif (unit.isWorkingCopy()) {\r", "+\t\t\t\t\tunit = (ICompilationUnit)unit.getOriginalElement();\r", "+\t\t\t\t}\r", "+\t\t\t\tCompilationUnitDeclaration parsedUnit = this.buildBindings(unit);\r", "+\t\t\t\tif (parsedUnit != null) {\r", "+\t\t\t\t\tparsedUnit.traverse(new TypeDeclarationVisitor(), parsedUnit.scope);\r", "-\t\t\t\t// ignore: continue with next element\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t// ignore: continue with next element\r", "+\t\t\t\t// report inacurrate matches\r", "+\t\t\t\treturn null;\r", "-\t\tSystem.arraycopy(this.result, 0, this.result = new char[this.resultIndex][][], 0, this.resultIndex);\r", "-\t} else {\r", "-\t\treturn null;\r", "+\t} else {\t\r", "+\t\t// Collect the paths of the cus that declare a type which matches declaringQualification + declaringSimpleName\r", "+\t\tString[] paths = this.getPathsOfDeclaringType();\r", "+\t\t\r", "+\t\t// Create bindings from source types and binary types\r", "+\t\t// and collect super type names of the type declaration \r", "+\t\t// that match the given declaring type\r", "+\t\tif (paths != null) {\r", "+\t\t\tUtil.sort(paths); // sort by projects\r", "+\t\t\tJavaProject previousProject = null;\r", "+\t\t\tthis.result = new char[1][][];\r", "+\t\t\tthis.resultIndex = 0;\r", "+\t\t\tfor (int i = 0, length = paths.length; i < length; i++) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tOpenable openable = this.handleFactory.createOpenable(paths[i]);\r", "+\t\t\t\t\tif (openable == null)\r", "+\t\t\t\t\t\tcontinue; // outside classpath\r", "+\t\t\t\t\tIJavaProject project = openable.getJavaProject();\r", "+\t\t\t\t\tif (previousProject == null || !previousProject.equals(project)) {\r", "+\t\t\t\t\t\tpreviousProject = (JavaProject)project;\r", "+\t\t\t\t\t\tthis.createParser(previousProject);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tif (openable instanceof ICompilationUnit) {\r", "+\t\t\t\t\t\tICompilationUnit unit = (ICompilationUnit)openable;\r", "+\t\t\t\t\t\tCompilationUnitDeclaration parsedUnit = this.buildBindings(unit);\r", "+\t\t\t\t\t\tif (parsedUnit != null) {\r", "+\t\t\t\t\t\t\tparsedUnit.traverse(new TypeDeclarationVisitor(), parsedUnit.scope);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else if (openable instanceof IClassFile) {\r", "+\t\t\t\t\t\tIClassFile classFile = (IClassFile)openable;\r", "+\t\t\t\t\t\tBinaryTypeBinding binding = this.cacheBinaryType(classFile.getType());\r", "+\t\t\t\t\t\tif (this.matches(binding)) {\r", "+\t\t\t\t\t\t\tthis.collectSuperTypeNames(binding);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t} catch (AbortCompilation e) {\r", "+\t\t\t\t\t// ignore: continue with next element\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t// ignore: continue with next element\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tSystem.arraycopy(this.result, 0, this.result = new char[this.resultIndex][][], 0, this.resultIndex);\r", "+\t\t\treturn this.result;\r", "+\t\t} else {\r", "+\t\t\treturn null;\r", "+\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "562f158d038f5538c9ab106973324bb5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "6cb413dbd992ad73f847d7b4e14e78f1406fa2fc", "commitAfterChange": "8659b871eae5c2008485cfb120ce2c8f8ecbfe04", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 32, "signatureBeforeChange": " \tprivate ICompilationUnit getCachedWorkingCopy( IFile parentFile, String typeName )", "signatureAfterChange": " \tprivate synchronized ICompilationUnit getWorkingCopyForGeneratedFile(IFile parentFile, String typeName, CompilationUnitHelper cuh)", "diff": ["-\t//", "-\tprivate ICompilationUnit getCachedWorkingCopy( IFile parentFile, String typeName )", "+\t */", "+\tprivate synchronized ICompilationUnit getWorkingCopyForGeneratedFile(IFile parentFile, String typeName, CompilationUnitHelper cuh)", "-\t\tIFile derivedFile = getIFileForTypeName( typeName );", "-\t\tICompilationUnit workingCopy= null;", "+\t\tIPackageFragmentRoot root = _generatedPackageFragmentRoot.get().root;", "+\t\tIFile generatedFile = getIFileForTypeName(typeName);", "+\t\tICompilationUnit workingCopy;", "-\t\tsynchronized( this )", "-\t\t{", "-\t\t\tworkingCopy = _generatedFile2WorkingCopy.get( derivedFile );", "+\t\tworkingCopy = _hiddenBuiltTypes.get(generatedFile);", "+\t\tif (null != workingCopy) {", "+\t\t\t// file is currently hidden with a blank WC. Move that WC to the regular list.", "+\t\t\tif (AptPlugin.DEBUG_GFM_MAPS) AptPlugin.trace(", "+\t\t\t\t\t\"move working copy from hidden to regular list: \" + generatedFile); //$NON-NLS-1$", "+\t\t\t_hiddenBuiltTypes.remove(generatedFile);", "+\t\t\t_workingCopies.put(generatedFile, workingCopy);", "+\t\t} else {", "+\t\t\tworkingCopy = _workingCopies.get(generatedFile);", "+\t\t\tif (null == workingCopy) {", "+\t\t\t\t// we've not yet created a working copy for this file, so make one now.", "+\t\t\t\tworkingCopy = cuh.createWorkingCopy(typeName, root);", "+\t\t\t\t_workingCopies.put(generatedFile, workingCopy);", "+\t\t\t\tif (AptPlugin.DEBUG_GFM_MAPS) AptPlugin.trace( ", "+\t\t\t\t\t\t\"added new working copy to regular list: \" + generatedFile); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tif (AptPlugin.DEBUG_GFM_MAPS) AptPlugin.trace(", "+\t\t\t\t\t\t\"obtained existing working copy from regular list: \" + workingCopy.getElementName()); //$NON-NLS-1$", "+\t\t\t}", "-\t\t", "-\t\tif ( workingCopy != null )", "-\t\t\taddEntryToWorkingCopyMaps( parentFile, workingCopy );", "+", "+\t\t// Add it to the dependency map (a no-op if it's already there)", "+\t\tboolean added = _parentToGenWorkingCopies.put(parentFile, workingCopy);", "+\t\tif (AptPlugin.DEBUG_GFM_MAPS) {", "+\t\t\tif (added)", "+\t\t\t\tAptPlugin.trace(\"working copy association added: \" + parentFile + \" -> \" + workingCopy.getElementName()); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\telse", "+\t\t\t\tAptPlugin.trace(\"working copy association already present: \" + parentFile + \" -> \" + workingCopy.getElementName()); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t}", "+", "+\t\tassert checkIntegrity();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "57dd536b3921b2366ececa9ba23a063d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "fdaafe32db6fb8160ac96735f3629164c831f24b", "commitAfterChange": "1819c30a56affd533a48985d222f687b6215e066", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "\r private void updateRoots(Openable project, IResourceDelta projectDelta)", "signatureAfterChange": "\r private void updateRoots(Openable project, IResourceDelta projectDelta)", "diff": [" "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5fbc24648a0a1c8c6ecbd2efd2893b72", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "32a99f8c41e7f6505e98564a2fe955f48d80f711", "commitAfterChange": "38819b0397930dbfdcf4973c1bb1a5b3cfbe15eb", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": "\r \tprivate void findVariableName(char[] token, char[] qualifiedPackageName, char[] qualifiedSourceName, char[] sourceName, char[][] excludeNames)", "signatureAfterChange": "\r \tprivate void findVariableName(char[] token, char[] qualifiedPackageName, char[] qualifiedSourceName, char[] sourceName, char[][] excludeNames)", "diff": ["+\t\t\tif(CharOperation.endsWith(sourceName, new char[]{'[' ,']'})) {\r", "+\t\t\t\tsourceName = CharOperation.subarray(sourceName, 0, sourceName.length - 2);\r", "+\t\t\t}\r", "+\r", "+\t\t\tchar[] name = null;\r", "+\t\t\t\r", "+\t\t\t// compute variable name for base type\r", "+\t\t\ttry{\r", "+\t\t\t\tnameScanner.setSourceBuffer(sourceName);\r", "+\t\t\t\tswitch (nameScanner.getNextToken()) {\r", "+\t\t\t\t\tcase TokenNameint :\r", "+\t\t\t\t\tcase TokenNamebyte :\r", "+\t\t\t\t\tcase TokenNameshort :\r", "+\t\t\t\t\tcase TokenNamechar :\r", "+\t\t\t\t\tcase TokenNamelong :\r", "+\t\t\t\t\tcase TokenNamefloat :\r", "+\t\t\t\t\tcase TokenNamedouble :\r", "+\t\t\t\t\t\tif(token != null && token.length != 0)\r", "+\t\t\t\t\t\t\treturn;\r", "+\t\t\t\t\t\tname = computeBaseNames(sourceName[0], excludeNames);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameboolean :\r", "+\t\t\t\t\t\tif(token != null && token.length != 0)\r", "+\t\t\t\t\t\t\treturn;\r", "+\t\t\t\t\t\tname = computeBaseNames('z', excludeNames);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t\tif(name != null) {\r", "+\t\t\t\t\t// accept result\r", "+\t\t\t\t\trequestor.acceptVariableName(\r", "+\t\t\t\t\t\tqualifiedPackageName,\r", "+\t\t\t\t\t\tqualifiedSourceName,\r", "+\t\t\t\t\t\tname,\r", "+\t\t\t\t\t\tname,\r", "+\t\t\t\t\t\tstartPosition,\r", "+\t\t\t\t\t\tendPosition);\r", "+\t\t\t\t\treturn;\r", "+\t\t\t\t}\r", "+\t\t\t} catch(InvalidInputException e){\r", "+\t\t\t}\r", "+\t\t\t\r", "+\t\t\t// compute variable name for non base type\r", "-\t\t\t\tchar[] name = names[i];\r", "+\t\t\t\tname = names[i];\r", "-\t\t\t\t\tidentifierScanner.setSourceBuffer(name);\r", "-\t\t\t\t\tif(identifierScanner.getNextToken() != identifierScanner.TokenNameIdentifier)\r", "+\t\t\t\t\tnameScanner.setSourceBuffer(name);\r", "+\t\t\t\t\tif(nameScanner.getNextToken() != TokenNameIdentifier)\r", "+\t\t\t\tint count = 2;\r", "+\t\t\t\tchar[] originalName = name;\r", "-\t\t\t\t\tif(CharOperation.equals(name, excludeNames[j], false))\r", "-\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t\tif(CharOperation.equals(name, excludeNames[j], false)) {\r", "+\t\t\t\t\t\tname = CharOperation.concat(originalName, String.valueOf(count++).toCharArray());\r", "+\t\t\t\t\t\ti = 0;\r", "+\t\t\t\t\t}\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "857e0219d56aeb827007ccb2b65009c9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "c1c274932491e0be8f680c6ad9f4ab9bacdf19f5", "commitAfterChange": "0c46c5213b09d0da0f69c7b26f904c0f9c4b8264", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r \tpublic void checkProjectsBeingAddedOrRemoved(IResourceDelta delta)", "signatureAfterChange": "\r \tpublic void checkProjectsBeingAddedOrRemoved(IResourceDelta delta)", "diff": ["+\t\t\t\t// workaround for bug 15168 circular errors not reported \r", "+\t\t\t\tif (this.javaProjectsCache == null) {\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tthis.javaProjectsCache = this.getJavaModel().getJavaProjects();\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\t\r", "-\t\t\t\t\t// in case the project was removed then added\r", "-\t\t\t\t\tthis.projectsBeingDeleted.remove(resource);\r", "-\t\t\t\t\t\r", "-\t\t\t\t\tthis.deltaProcessor.addToProjectsToUpdateWithDependents((IProject)resource);\r", "+\t\t\t\t\tIProject project = (IProject)resource;\r", "+\t\t\t\t\tthis.deltaProcessor.addToProjectsToUpdateWithDependents(project);\r", "+\t\t\t\t\t\r", "+\t\t\t\t\t// workaround for bug 15168 circular errors not reported \r", "+\t\t\t\t\tif (this.deltaProcessor.hasJavaNature(project)) {\r", "+\t\t\t\t\t\tthis.deltaProcessor.addToParentInfo((JavaProject)JavaCore.create(project));\r", "+\t\t\t\t\t}\r", "-\t\t\t\t\t// in case the project was removed then added then changed\r", "-\t\t\t\t\tthis.projectsBeingDeleted.remove(resource);\r", "-\t\t\t\t\t\r", "+\t\t\t\t\tIProject project = (IProject)resource;\r", "-\t\t\t\t\t\tthis.deltaProcessor.addToProjectsToUpdateWithDependents((IProject)resource);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif ((delta.getFlags() & IResourceDelta.DESCRIPTION) != 0) {\r", "-\t\t\t\t\t\tIProject project = (IProject)resource;\r", "+\t\t\t\t\t\tthis.deltaProcessor.addToProjectsToUpdateWithDependents(project);\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\t\t// workaround for bug 15168 circular errors not reported \r", "+\t\t\t\t\t\tif (project.isOpen()) {\r", "+\t\t\t\t\t\t\tif (this.deltaProcessor.hasJavaNature(project)) {\r", "+\t\t\t\t\t\t\t\tthis.deltaProcessor.addToParentInfo((JavaProject)JavaCore.create(project));\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tJavaProject javaProject = (JavaProject)this.getJavaModel().findJavaProject(project);\r", "+\t\t\t\t\t\t\tif (javaProject != null) {\r", "+\t\t\t\t\t\t\t\ttry {\r", "+\t\t\t\t\t\t\t\t\tjavaProject.close();\r", "+\t\t\t\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\tthis.deltaProcessor.removeFromParentInfo(javaProject);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else if ((delta.getFlags() & IResourceDelta.DESCRIPTION) != 0) {\r", "-\t\t\t\t\t\t\tthis.deltaProcessor.addToProjectsToUpdateWithDependents((IProject)resource);\r", "+\t\t\t\t\t\t\tthis.deltaProcessor.addToProjectsToUpdateWithDependents(project);\r", "+\r", "+\t\t\t\t\t\t\t// workaround for bug 15168 circular errors not reported \r", "+\t\t\t\t\t\t\tif (isJavaProject) {\r", "+\t\t\t\t\t\t\t\tthis.deltaProcessor.addToParentInfo((JavaProject)JavaCore.create(project));\r", "+\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(project);\r", "+\t\t\t\t\t\t\t\ttry {\r", "+\t\t\t\t\t\t\t\t\tjavaProject.close();\r", "+\t\t\t\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\tthis.deltaProcessor.removeFromParentInfo(javaProject);\r", "+\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t// workaround for bug 15168 circular errors not reported \r", "+\t\t\t\t\t\t// in case the project was removed then added then changed\r", "+\t\t\t\t\t\tthis.deltaProcessor.addToParentInfo((JavaProject)JavaCore.create(project));\r", "+\t\t\t\t\t}\t\t\t\t\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a782eb48cecc342eeb2046b46d8b7939", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "1819c30a56affd533a48985d222f687b6215e066", "commitAfterChange": "9e3274a4e22859a72bb671e841084e7489806ddc", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "\r private void updateRoots(Openable project, IResourceDelta projectDelta)", "signatureAfterChange": "\r private void updateRoots(Openable project, IResourceDelta projectDelta)", "diff": [" "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c2563f1dd73635090cc9c1726785c320", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "70416b46b1375461a92d89ffa1cb077778dc6e86", "commitAfterChange": "0c53505dd9d8f221929a96f99e04ff55bfc4fc05", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tvoid createAndResolveBindings(MatchingOpenable[] openables)", "signatureAfterChange": " \tprotected void createAndResolveBindings(PotentialMatch[] potentialMatches, int start, int length)", "diff": ["+\t */", "+\tprotected void createAndResolveBindings(PotentialMatch[] potentialMatches, int start, int length) {", "+\t\tfor (int i = start, maxUnits = start+length; i < maxUnits; i++) {", "+\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) {", "+\t\t\t\tthrow new OperationCanceledException();", "+\t\t\t}", "+\t\t\tPotentialMatch potentialMatch = potentialMatches[i];", "+\t\t\ttry {", "+\t\t\t\tif (potentialMatch != null) {", "+\t\t\t\t\tthis.parser.matchSet = potentialMatch.matchingNodeSet;", "+\t\t\t\t}", "+\t\t\t\tCompilationResult unitResult =", "+\t\t\t\t\tnew CompilationResult(potentialMatch, i, maxUnits, this.options.maxProblemsPerUnit);", "+\t\t\t\t\t", "+\t\t\t\tif (SearchEngine.VERBOSE) {", "+\t\t\t\t\tSystem.out.println(\"Parsing \" + potentialMatch.openable.toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\t// diet parsing for large collection of units", "+\t\t\t\tCompilationUnitDeclaration parsedUnit;", "+\t\t\t\tif (totalUnits < parseThreshold) {", "+\t\t\t\t\tparsedUnit = this.parser.parse(potentialMatch, unitResult);", "+\t\t\t\t} else {", "+\t\t\t\t\tparsedUnit = this.parser.dietParse(potentialMatch, unitResult);", "+\t\t\t\t}", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t// initial type binding creation", "+\t\t\t\tif (parsedUnit != null && !parsedUnit.isEmpty()) {", "+\t\t\t\t\tthis.lookupEnvironment.buildTypeBindings(parsedUnit);", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tthis.addCompilationUnit(potentialMatch, parsedUnit);", "+\t\t\t\t", "+\t\t\t\t// progress reporting", "+\t\t\t\tif (this.progressMonitor != null) {", "+\t\t\t\t\tthis.progressMonitor.worked(4);", "+\t\t\t\t}", "+\t\t\t} finally {", "+\t\t\t\tthis.parser.matchSet = null;", "+\t\t\t\tpotentialMatches[i] = null; // no longer hold onto the unit", "+\t\t\t}", "+\t\t}", "+\t\t// binding resolution", "+\t\tlookupEnvironment.completeTypeBindings();", "+\t}", "-", "-\tvoid createAndResolveBindings(MatchingOpenable[] openables) {", "-\t\t// binding creation", "-\t\tfor (int i = 0, length = openables.length; i < length; i++) { ", "-\t\t\topenables[i].buildTypeBindings();", "-\t\t\tif (this.progressMonitor != null) {", "-\t\t\t\tif (this.progressMonitor.isCanceled()) {", "-\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.progressMonitor.worked(6);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// binding resolution", "-\t\ttry {", "-\t\t\tthis.lookupEnvironment.completeTypeBindings();", "-\t\t} catch (AbortCompilation e) {", "-\t\t\t// problem with class path: it could not find base classes", "-\t\t\t// continue reporting innacurate matches (since bindings will be null)", "-\t\t\tthis.compilationAborted = true;", "-\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ca75a0d7c4cfb60d8c94ff2bf0d136f9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "d2861a7753e529217c872f1a7e1714670325b389", "commitAfterChange": "3fede7546d33952755c77985258d932ac43f63ce", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": " \tpublic CompilationUnitDeclaration resolve( \t\t\tCompilationUnitDeclaration unit,  \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit,  \t\t\tboolean verifyMethods, \t\t\tboolean analyzeCode, \t\t\tboolean generateCode)", "signatureAfterChange": " \tpublic CompilationUnitDeclaration resolve( \t\t\tCompilationUnitDeclaration unit,  \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit,  \t\t\tboolean verifyMethods, \t\t\tboolean analyzeCode, \t\t\tboolean generateCode)", "diff": ["+\t */", "+\tpublic CompilationUnitDeclaration resolve(", "+\t\t\tCompilationUnitDeclaration unit, ", "+\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit, ", "+\t\t\tboolean verifyMethods,", "+\t\t\tboolean analyzeCode,", "+\t\t\tboolean generateCode) {", "+\t\t\t\t", "+\t\ttry {", "+\t\t\tthis.parser.getMethodBodies(unit);", "-\t */", "-\tpublic CompilationUnitDeclaration resolve(", "-\t\t\tCompilationUnitDeclaration unit, ", "-\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit, ", "-\t\t\tboolean verifyMethods,", "-\t\t\tboolean analyzeCode,", "-\t\t\tboolean generateCode) {", "-\t\t", "-\t\treturn resolve(", "-\t\t\tunit, ", "-\t\t\tsourceUnit, ", "-\t\t\tnull/*no node searcher*/, ", "-\t\t\tverifyMethods, ", "-\t\t\tanalyzeCode, ", "-\t\t\tgenerateCode);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cdae1b2e200d39563d659592b0cc1390", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "e4a4b50610c646cb6bf3bb4c3d31aa510f5cd436", "commitAfterChange": "674f4479b6b5621d2d1cd025a88c2a63b198bd88", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " private void buildMoreCompletionContext(Expression expression)", "signatureAfterChange": " private void buildMoreCompletionContext(Expression expression)", "diff": ["-\t\t\t\t", "+\t\t\tcase K_BETWEEN_CASE_AND_COLON :", "+\t\t\t\tif(this.expressionPtr > 0) {", "+\t\t\t\t\tSwitchStatement switchStatement = new SwitchStatement();", "+\t\t\t\t\tswitchStatement.expression = this.expressionStack[this.expressionPtr - 1];", "+\t\t\t\t\tif(this.astLengthPtr > -1 && this.astPtr > -1) {", "+\t\t\t\t\t\tint length = this.astLengthStack[this.astLengthPtr];", "+\t\t\t\t\t\tint newAstPtr = this.astPtr - length;", "+\t\t\t\t\t\tASTNode firstNode = this.astStack[newAstPtr + 1];", "+\t\t\t\t\t\tif(length != 0 && firstNode.sourceStart > switchStatement.expression.sourceEnd) {", "+\t\t\t\t\t\t\tswitchStatement.statements = new Statement[length + 1];", "+\t\t\t\t\t\t\tSystem.arraycopy(", "+\t\t\t\t\t\t\t\tthis.astStack, ", "+\t\t\t\t\t\t\t\tnewAstPtr + 1, ", "+\t\t\t\t\t\t\t\tswitchStatement.statements, ", "+\t\t\t\t\t\t\t\t0, ", "+\t\t\t\t\t\t\t\tlength); ", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tCaseStatement caseStatement = new CaseStatement(expression, expression.sourceStart, expression.sourceEnd);", "+\t\t\t\t\tif(switchStatement.statements == null) {", "+\t\t\t\t\t\tswitchStatement.statements = new Statement[]{caseStatement};", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tswitchStatement.statements[switchStatement.statements.length - 1] = caseStatement;", "+\t\t\t\t\t}", "+\t\t\t\t\tassistNodeParent = switchStatement;", "+\t\t\t\t}", "+\t\t\t\tbreak;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e4e432b14300c27fb0c84607d3602ca3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CommitWorkingCopyOperation.java", "commitBeforeChange": "987b84492820c5eeff2230233c35db158228c8e3", "commitAfterChange": "882e850a9e00f22aac1934fd17ac4c0522b9b030", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected void executeOperation() throws JavaModelException", "signatureAfterChange": " \tprotected void executeOperation() throws JavaModelException", "diff": ["+\t\t\tIFile resource = (IFile)workingCopy.getResource();", "-\t\t", "-\t\t\t// creates the delta builder (this remembers the content of the cu)\t", "-\t\t\tif (!primary.isOpen()) {", "+", "+\t\t\tJavaElementDeltaBuilder deltaBuilder = null;", "+\t\t\t", "+\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)workingCopy.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);", "+\t\t\tif (root.isOnClasspath() && resource.isAccessible()) {", "+\t\t\t", "-\t\t\t\tprimary.open(null);", "-\t\t\t}", "-\t\t\tJavaElementDeltaBuilder deltaBuilder;", "-\t\t\tif (Util.isExcluded(primary)) {", "-\t\t\t\tdeltaBuilder = null;", "-\t\t\t} else {", "-\t\t\t\tdeltaBuilder = new JavaElementDeltaBuilder(primary);", "-\t\t\t}", "-\t\t", "-\t\t\t// save the cu", "-\t\t\tIBuffer primaryBuffer = primary.getBuffer();", "-\t\t\tif (primaryBuffer == null) return;", "-\t\t\tchar[] primaryContents = primaryBuffer.getCharacters();", "-\t\t\tboolean hasSaved = false;", "-\t\t\ttry {", "-\t\t\t\tIBuffer workingCopyBuffer = workingCopy.getBuffer();", "-\t\t\t\tif (workingCopyBuffer == null) return;", "-\t\t\t\tprimaryBuffer.setContents(workingCopyBuffer.getCharacters());", "-\t\t\t\tprimary.save(fMonitor, fForce);", "-\t\t\t\tsetAttribute(HAS_MODIFIED_RESOURCE_ATTR, TRUE); ", "-\t\t\t\thasSaved = true;", "-\t\t\t} finally {", "-\t\t\t\tif (!hasSaved){", "-\t\t\t\t\t// restore original buffer contents since something went wrong", "-\t\t\t\t\tprimaryBuffer.setContents(primaryContents);", "+\t\t\t\tif (!primary.isOpen()) {", "+\t\t\t\t\tprimary.open(null);", "+", "+\t\t\t\t// creates the delta builder (this remembers the content of the cu)\t", "+\t\t\t\tif (!Util.isExcluded(primary)) {", "+\t\t\t\t\tdeltaBuilder = new JavaElementDeltaBuilder(primary);", "+\t\t\t\t}", "+\t\t\t", "+\t\t\t\t// save the cu", "+\t\t\t\tIBuffer primaryBuffer = primary.getBuffer();", "+\t\t\t\tif (primaryBuffer == null) return;", "+\t\t\t\tchar[] primaryContents = primaryBuffer.getCharacters();", "+\t\t\t\tboolean hasSaved = false;", "+\t\t\t\ttry {", "+\t\t\t\t\tIBuffer workingCopyBuffer = workingCopy.getBuffer();", "+\t\t\t\t\tif (workingCopyBuffer == null) return;", "+\t\t\t\t\tprimaryBuffer.setContents(workingCopyBuffer.getCharacters());", "+\t\t\t\t\tprimaryBuffer.save(fMonitor, fForce);", "+\t\t\t\t\tprimary.makeConsistent(this);", "+\t\t\t\t\thasSaved = true;", "+\t\t\t\t} finally {", "+\t\t\t\t\tif (!hasSaved){", "+\t\t\t\t\t\t// restore original buffer contents since something went wrong", "+\t\t\t\t\t\tprimaryBuffer.setContents(primaryContents);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\t// working copy on cu outside classpath OR resource doesn't exist yet", "+\t\t\t\tString encoding = workingCopy.getJavaProject().getOption(JavaCore.CORE_ENCODING, true);", "+\t\t\t\tString contents = workingCopy.getSource();", "+\t\t\t\tif (contents == null) return;", "+\t\t\t\ttry {", "+\t\t\t\t\tbyte[] bytes = encoding == null ", "+\t\t\t\t\t\t? contents.getBytes() ", "+\t\t\t\t\t\t: contents.getBytes(encoding);", "+\t\t\t\t\tByteArrayInputStream stream = new ByteArrayInputStream(bytes);", "+\t\t\t\t\tif (resource.exists()) {", "+\t\t\t\t\t\tresource.setContents(", "+\t\t\t\t\t\t\tstream, ", "+\t\t\t\t\t\t\tfForce ? IResource.FORCE | IResource.KEEP_HISTORY : IResource.KEEP_HISTORY, ", "+\t\t\t\t\t\t\tnull);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tresource.create(", "+\t\t\t\t\t\t\tstream,", "+\t\t\t\t\t\t\tfForce,", "+\t\t\t\t\t\t\tfMonitor);", "+\t\t\t\t\t}", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\tthrow new JavaModelException(e);", "+\t\t\t\t} catch (UnsupportedEncodingException e) {", "+\t\t\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);", "+\t\t\t\t}", "+\t\t\t\t", "+", "+\t\t\tsetAttribute(HAS_MODIFIED_RESOURCE_ATTR, TRUE); ", "+\t\t\t", "+\t\t\t// build the deltas", "-\t\t\t\t// build the deltas"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc53b710cab4cf3a34da51b149a00ea7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "6cb413dbd992ad73f847d7b4e14e78f1406fa2fc", "commitAfterChange": "8659b871eae5c2008485cfb120ce2c8f8ecbfe04", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 36, "signatureBeforeChange": " \tprivate File getSerializationFile(IProject project)", "signatureAfterChange": " \tprivate void saveCompilationUnit(IPackageFragment pkgFrag, final String cuName, String contents, \t\t\tIProgressMonitor progressMonitor)", "diff": ["+\t */", "+\tprivate void saveCompilationUnit(IPackageFragment pkgFrag, final String cuName, String contents,", "+\t\t\tIProgressMonitor progressMonitor)", "+\t{", "+\t\tICompilationUnit unit = pkgFrag.getCompilationUnit(cuName);", "+\t\tboolean isWorkingCopy = unit.isWorkingCopy();", "+\t\tif (isWorkingCopy && unit.getResource().exists()) {", "+\t\t\t// If we have a working copy and it has a file, all we", "+\t\t\t// need to do is update its contents and commit it.", "+\t\t\t_CUHELPER.commitNewContents(unit, contents, progressMonitor);", "+\t\t\tif (AptPlugin.DEBUG_GFM) AptPlugin.trace( ", "+\t\t\t\t\t\"Committed existing working copy during build: \" + unit.getElementName()); //$NON-NLS-1$", "+\t\t}", "+\t\telse {", "+\t\t\tif (isWorkingCopy) {", "+\t\t\t\t// See https://bugs.eclipse.org/bugs/show_bug.cgi?id=163906 -", "+\t\t\t\t// commitWorkingCopy() fails if file does not already exist.", "+\t\t\t\tSet<ICompilationUnit> toDiscard = discardWorkingCopy(unit);", "+\t\t\t\tfor (ICompilationUnit cuToDiscard : toDiscard) {", "+\t\t\t\t\t_CUHELPER.discardWorkingCopy(cuToDiscard);", "+\t\t\t\t\tif (AptPlugin.DEBUG_GFM) AptPlugin.trace( ", "+\t\t\t\t\t\t\t\"Discarded working copy during build: \" + unit.getElementName()); //$NON-NLS-1$", "+\t\t\ttry {", "+\t\t\t\tunit = pkgFrag.createCompilationUnit(cuName, contents, true, progressMonitor);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\tAptPlugin.log(e, \"Unable to create compilation unit on disk: \" +  //$NON-NLS-1$", "+\t\t\t\t\t\tcuName + \" in pkg fragment: \" + pkgFrag.getElementName()); //$NON-NLS-1$", "+\t\t\tif (AptPlugin.DEBUG_GFM) AptPlugin.trace( ", "+\t\t\t\t\t\"Created compilation unit during build: \" + unit.getElementName()); //$NON-NLS-1$", "-\t */", "-\tprivate File getSerializationFile(IProject project) {", "-\t\tif (!project.exists()) return null;", "-\t\tIPath workingLocation = project.getWorkingLocation(AptPlugin.PLUGIN_ID);", "-\t\treturn workingLocation.append(\"state.dat\").toFile(); //$NON-NLS-1$", "-\t}"]}], "num": 67449}