{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2165303cb0058ec3938bdbb621ef37d6", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "435f58add62ac8623a0c141ac5f2a8cf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetQualifiedNameReference.java", "commitBeforeChange": "de542d47e7857076ff550f4560e517bc0773f2ce", "commitAfterChange": "29901dd2faebfaef1b4d98d076ffc43db80ce6e9", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "signatureAfterChange": " public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "diff": ["-\t\tif ((operationTypeID = (this.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) == T_JavaLangString) {", "-\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t} else {", "-\t\t\t// promote the array reference to the suitable operation type", "-\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\tif (expression == IntLiteral.One){ // prefix operation", "-\t\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);\t\t\t", "-\t\t\t} else {", "-\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t}", "-\t\t\t// perform the operation", "-\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t// cast the value back to the array reference type", "-\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "+\t\tswitch(operationTypeID = (this.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) {", "+\t\t\tcase T_JavaLangString :", "+\t\t\tcase T_JavaLangObject :", "+\t\t\tcase T_undefined :", "+\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\t// promote the array reference to the suitable operation type", "+\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "+\t\t\t\tif (expression == IntLiteral.One){ // prefix operation", "+\t\t\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);\t\t\t", "+\t\t\t\t} else {", "+\t\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "+\t\t\t\t}", "+\t\t\t\t// perform the operation", "+\t\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "+\t\t\t\t// cast the value back to the array reference type", "+\t\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "505f303ed3451765832148972275cf71", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetFieldReference.java", "commitBeforeChange": "de542d47e7857076ff550f4560e517bc0773f2ce", "commitAfterChange": "29901dd2faebfaef1b4d98d076ffc43db80ce6e9", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "signatureAfterChange": "  public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "diff": ["-\t\tif ((operationTypeID = (this.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) == T_JavaLangString) {", "-\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t} else {", "-\t\t\t// promote the array reference to the suitable operation type", "-\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\tif (expression == IntLiteral.One){ // prefix operation", "-\t\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);\t\t\t", "-\t\t\t} else {", "-\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t}\t\t", "-\t\t\t// perform the operation", "-\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t// cast the value back to the array reference type", "-\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "+\t\tswitch(operationTypeID = (this.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) {", "+\t\t\tcase T_JavaLangString :", "+\t\t\tcase T_JavaLangObject :", "+\t\t\tcase T_undefined :", "+\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\t// promote the array reference to the suitable operation type", "+\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "+\t\t\t\tif (expression == IntLiteral.One){ // prefix operation", "+\t\t\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);\t\t\t", "+\t\t\t\t} else {", "+\t\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "+\t\t\t\t}\t\t", "+\t\t\t\t// perform the operation", "+\t\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "+\t\t\t\t// cast the value back to the array reference type", "+\t\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "57704f2bd5d50060684532cc42464a9b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "de542d47e7857076ff550f4560e517bc0773f2ce", "commitAfterChange": "29901dd2faebfaef1b4d98d076ffc43db80ce6e9", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tpublic void generateCompoundAssignment( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tExpression expression, \t\tint operator, \t\tint assignmentImplicitConversion, \t\tboolean valueRequired)", "signatureAfterChange": " \tpublic void generateCompoundAssignment( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tExpression expression, \t\tint operator, \t\tint assignmentImplicitConversion, \t\tboolean valueRequired)", "diff": ["-\t\tif ((operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) == T_JavaLangString) {", "-\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t} else {", "-\t\t\t// promote the array reference to the suitable operation type", "-\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "-\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\tif (expression == IntLiteral.One) { // prefix operation", "-\t\t\t\tcodeStream.generateConstant(expression.constant, implicitConversion);", "-\t\t\t} else {", "-\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t}", "-\t\t\t// perform the operation", "-\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t// cast the value back to the array reference type", "-\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "+\t\tswitch(operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) {", "+\t\t\tcase T_JavaLangString :", "+\t\t\tcase T_JavaLangObject :", "+\t\t\tcase T_undefined :", "+\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\t// promote the array reference to the suitable operation type", "+\t\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "+\t\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "+\t\t\t\tif (expression == IntLiteral.One) { // prefix operation", "+\t\t\t\t\tcodeStream.generateConstant(expression.constant, implicitConversion);", "+\t\t\t\t} else {", "+\t\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "+\t\t\t\t}", "+\t\t\t\t// perform the operation", "+\t\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "+\t\t\t\t// cast the value back to the array reference type", "+\t\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "61b169f3a37f756bf0bdd864a4e1d927", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "de542d47e7857076ff550f4560e517bc0773f2ce", "commitAfterChange": "29901dd2faebfaef1b4d98d076ffc43db80ce6e9", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tpublic void generateCompoundAssignment( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tExpression expression, \t\tint operator, \t\tint assignmentImplicitConversion, \t\tboolean valueRequired)", "signatureAfterChange": "  \tpublic void generateCompoundAssignment( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tExpression expression, \t\tint operator, \t\tint assignmentImplicitConversion, \t\tboolean valueRequired)", "diff": ["-\t\tif ((operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) == T_JavaLangString) {", "-\t\t    // no need for generic cast on previous #getfield since using Object string buffer methods.", "-\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t} else {", "-\t\t\t// promote the array reference to the suitable operation type", "-\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "-\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\tif (expression == IntLiteral.One) { // prefix operation", "-\t\t\t\tcodeStream.generateConstant(expression.constant, implicitConversion);", "-\t\t\t} else {", "-\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t}", "-\t\t\t// perform the operation", "-\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t// cast the value back to the array reference type", "-\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "+\t\tswitch(operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) {", "+\t\t\tcase T_JavaLangString :", "+\t\t\tcase T_JavaLangObject :", "+\t\t\tcase T_undefined :", "+\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\t// promote the array reference to the suitable operation type", "+\t\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "+\t\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "+\t\t\t\tif (expression == IntLiteral.One) { // prefix operation", "+\t\t\t\t\tcodeStream.generateConstant(expression.constant, implicitConversion);", "+\t\t\t\t} else {", "+\t\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "+\t\t\t\t}", "+\t\t\t\t// perform the operation", "+\t\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "+\t\t\t\t// cast the value back to the array reference type", "+\t\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "81e2ca714420e858409fbccd26654465", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java", "commitBeforeChange": "de542d47e7857076ff550f4560e517bc0773f2ce", "commitAfterChange": "29901dd2faebfaef1b4d98d076ffc43db80ce6e9", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic void generateCompoundAssignment( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tExpression expression, \t\tint operator, \t\tint assignmentImplicitConversion, \t\tboolean valueRequired)", "signatureAfterChange": "  \tpublic void generateCompoundAssignment( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tExpression expression, \t\tint operator, \t\tint assignmentImplicitConversion, \t\tboolean valueRequired)", "diff": ["-\t\tif ((operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) == T_JavaLangString) {", "-\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t} else {", "-\t\t\t// promote the array reference to the suitable operation type", "-\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "-\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\tif (expression == IntLiteral.One) { // prefix operation", "-\t\t\t\tcodeStream.generateConstant(expression.constant, implicitConversion);", "-\t\t\t} else {", "-\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t}", "-\t\t\t// perform the operation", "-\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t// cast the value back to the array reference type", "-\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "+\t\tswitch(operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) {", "+\t\t\tcase T_JavaLangString :", "+\t\t\tcase T_JavaLangObject :", "+\t\t\tcase T_undefined :", "+\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\t// promote the array reference to the suitable operation type", "+\t\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "+\t\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "+\t\t\t\tif (expression == IntLiteral.One) { // prefix operation", "+\t\t\t\t\tcodeStream.generateConstant(expression.constant, implicitConversion);", "+\t\t\t\t} else {", "+\t\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "+\t\t\t\t}", "+\t\t\t\t// perform the operation", "+\t\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "+\t\t\t\t// cast the value back to the array reference type", "+\t\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);"]}], "num": 31013}