{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dbfabc0b770e03e19f02f92b53afdb78", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7222d1ce4d88e875b741aabf3736f1a3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsMassiveTests.java", "commitBeforeChange": "e94247ea6ac5ec863496bda9d3658e2dc349e6ab", "commitAfterChange": "9448736fbeb476ae8eacb15d6ea8788cf2db77a1", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  private String expectedFormattedSource(String source)", "signatureAfterChange": "  private String expectedFormattedSource(String source)", "diff": ["-\tDefaultCodeFormatter codeFormatter = codeFormatter();", "-\tScanner scanner = new Scanner(true, true, false/*nls*/, ClassFileConstants.JDK1_4/*sourceLevel*/, null/*taskTags*/, null/*taskPriorities*/, true/*taskCaseSensitive*/);", "-\tCodeSnippetParsingUtil codeSnippetParsingUtil = new CodeSnippetParsingUtil();", "-\tCompilationUnitDeclaration compilationUnitDeclaration = codeSnippetParsingUtil.parseCompilationUnit(source.toCharArray(), getDefaultCompilerOptions(), true);", "-\tscanner.setSource(source.toCharArray());", "-\tscanner.lineEnds = codeSnippetParsingUtil.recordedParsingInformation.lineEnds;", "-\tint[][] commentsPositions = compilationUnitDeclaration.comments;", "-\tint length = commentsPositions == null ? 0 : commentsPositions.length;", "-\tString[] formattedComments = new String[length];", "-\tfor (int i=0; i<length; i++) {", "-\t\tint[] positions = commentsPositions[i];", "-\t\tint commentKind = CodeFormatter.K_JAVA_DOC;", "-\t\tint commentStart = positions [0];", "-\t\tint commentEnd = positions [1];", "-\t\tif (commentEnd < 0) { // line or block comments have negative end position", "-\t\t\tcommentEnd = -commentEnd;", "-\t\t\tif (commentStart > 0) { // block comments have positive start position", "-\t\t\t\tcommentKind = CodeFormatter.K_MULTI_LINE_COMMENT;", "-\t\t\t} else {", "-\t\t\t\tcommentStart = -commentStart;", "-\t\t\t\tcommentKind = CodeFormatter.K_SINGLE_LINE_COMMENT;", "-\t\t\t}", "-\t\t}", "-\t\tint indentationLevel = getIndentationLevel(scanner, commentStart);", "-\t\tformattedComments[i] = runFormatter(codeFormatter, source.substring(commentStart, commentEnd), commentKind, indentationLevel, 0, commentEnd - commentStart, LINE_SEPARATOR);", "-\t}", "-\tSimpleDocument document = new SimpleDocument(source);", "-\tfor (int i=length-1; i>=0; i--) {", "-\t\tif (formattedComments[i] != null) {", "+\tboolean enableNewCommentFormatter = DefaultCodeFormatter.ENABLE_NEW_COMMENTS_FORMAT;", "+\ttry {", "+\t\tDefaultCodeFormatter.ENABLE_NEW_COMMENTS_FORMAT = false;", "+\t\tDefaultCodeFormatter codeFormatter = codeFormatter();", "+\t\tScanner scanner = new Scanner(true, true, false/*nls*/, ClassFileConstants.JDK1_4/*sourceLevel*/, null/*taskTags*/, null/*taskPriorities*/, true/*taskCaseSensitive*/);", "+\t\tCodeSnippetParsingUtil codeSnippetParsingUtil = new CodeSnippetParsingUtil();", "+\t\tCompilationUnitDeclaration compilationUnitDeclaration = codeSnippetParsingUtil.parseCompilationUnit(source.toCharArray(), getDefaultCompilerOptions(), true);", "+\t\tscanner.setSource(source.toCharArray());", "+\t\tscanner.lineEnds = codeSnippetParsingUtil.recordedParsingInformation.lineEnds;", "+\t\tint[][] commentsPositions = compilationUnitDeclaration.comments;", "+\t\tint length = commentsPositions == null ? 0 : commentsPositions.length;", "+\t\tString[] formattedComments = new String[length];", "+\t\tfor (int i=0; i<length; i++) {", "+\t\t\tint commentKind = CodeFormatter.K_JAVA_DOC;", "-\t\t\t\tif (commentStart < 0) { // line comments have negative start position", "+\t\t\t\tif (commentStart > 0) { // block comments have positive start position", "+\t\t\t\t\tcommentKind = CodeFormatter.K_MULTI_LINE_COMMENT;", "+\t\t\t\t} else {", "+\t\t\t\t\tcommentKind = CodeFormatter.K_SINGLE_LINE_COMMENT;", "-\t\t\tdocument.replace(commentStart, commentEnd - commentStart, formattedComments[i]);", "+\t\t\tint indentationLevel = getIndentationLevel(scanner, commentStart);", "+\t\t\tformattedComments[i] = runFormatter(codeFormatter, source.substring(commentStart, commentEnd), commentKind, indentationLevel, 0, commentEnd - commentStart, LINE_SEPARATOR);", "+\t\tSimpleDocument document = new SimpleDocument(source);", "+\t\tfor (int i=length-1; i>=0; i--) {", "+\t\t\tif (formattedComments[i] != null) {", "+\t\t\t\tint[] positions = commentsPositions[i];", "+\t\t\t\tint commentStart = positions [0];", "+\t\t\t\tint commentEnd = positions [1];", "+\t\t\t\tif (commentEnd < 0) { // line or block comments have negative end position", "+\t\t\t\t\tcommentEnd = -commentEnd;", "+\t\t\t\t\tif (commentStart < 0) { // line comments have negative start position", "+\t\t\t\t\t\tcommentStart = -commentStart;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tdocument.replace(commentStart, commentEnd - commentStart, formattedComments[i]);", "+\t\t\t}", "+\t\t}", "+\t\tString newSource = document.get();", "+\t\tString oldResult = runFormatter(codeFormatter, newSource, CodeFormatter.K_COMPILATION_UNIT, 0, 0, newSource.length(), null);", "+\t\treturn oldResult == null ? newSource : oldResult;", "-\tString newSource = document.get();", "-\tString oldResult = runFormatter(codeFormatter, newSource, CodeFormatter.K_COMPILATION_UNIT, 0, 0, newSource.length(), null);", "-\treturn oldResult == null ? newSource : oldResult;", "+\tfinally {", "+\t\tDefaultCodeFormatter.ENABLE_NEW_COMMENTS_FORMAT = enableNewCommentFormatter;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f81a4dd2e80f9a90a70a8c113940dade", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 32, "signatureBeforeChange": " \t \tpublic CompilationUnit convert(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration unit, char[] source)", "signatureAfterChange": " \t \tpublic CompilationUnit convert(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration unit, char[] source)", "diff": ["-\t", "-\tpublic CompilationUnit convert(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration unit, char[] source) {", "-\t\tthis.compilationUnitSource = source;", "-\t\tthis.scanner.setSource(source);", "-\t\tthis.scanner.lineEnds = unit.compilationResult().lineSeparatorPositions;", "-\t\tCompilationUnit compilationUnit = this.ast.newCompilationUnit();", "-\t\t// handle the package declaration immediately", "-\t\t// There is no node corresponding to the package declaration", "-\t\tif (this.resolveBindings) {", "-\t\t\trecordNodes(compilationUnit, unit);", "-\t\t}", "-\t\tif (unit.currentPackage != null) {", "-\t\t\tPackageDeclaration packageDeclaration = convertPackage(unit);", "-\t\t\tcompilationUnit.setPackage(packageDeclaration);", "-\t\t}", "-\t\torg.eclipse.jdt.internal.compiler.ast.ImportReference[] imports = unit.imports;", "-\t\tif (imports != null) {", "-\t\t\tint importLength = imports.length;", "-\t\t\tfor (int i = 0; i < importLength; i++) {", "-\t\t\t\tcompilationUnit.imports().add(convertImport(imports[i]));", "-\t\t\t}", "-\t\t}", "-", "-\t\t// Parse comments", "-\t\tint[][] comments = unit.comments;", "-\t\tif (comments != null) {", "-\t\t\tbuildCommentsTable(compilationUnit, comments);", "-\t\t}", "-", "-\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = unit.types;", "-\t\tif (types != null) {", "-\t\t\tint typesLength = types.length;", "-\t\t\tfor (int i = 0; i < typesLength; i++) {", "-\t\t\t\tcompilationUnit.types().add(convert(types[i]));", "-\t\t\t}", "-\t\t}", "-\t\tcompilationUnit.setSourceRange(unit.sourceStart, unit.sourceEnd - unit.sourceStart  + 1);", "-\t\t", "-\t\tint problemLength = unit.compilationResult.problemCount;", "-\t\tif (problemLength != 0) {", "-\t\t\tIProblem[] resizedProblems = null;", "-\t\t\tfinal IProblem[] problems = unit.compilationResult.problems;", "-\t\t\tif (problems.length == problemLength) {", "-\t\t\t\tresizedProblems = problems;", "-\t\t\t} else {", "-\t\t\t\tSystem.arraycopy(problems, 0, (resizedProblems = new IProblem[problemLength]), 0, problemLength);", "-\t\t\t}", "-\t\t\tpropagateErrors(compilationUnit, resizedProblems);", "-\t\t\tcompilationUnit.setProblems(resizedProblems);", "-\t\t}", "-\t\tif (this.resolveBindings) {", "-\t\t\tlookupForScopes();", "-\t\t}", "-\t\tcompilationUnit.initCommentMapper(this.scanner);", "-\t\treturn compilationUnit;", "-\t}", "+\t", "+\tpublic CompilationUnit convert(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration unit, char[] source) {", "+\t\tthis.compilationUnitSource = source;", "+\t\tthis.scanner.setSource(source);", "+\t\tthis.scanner.lineEnds = unit.compilationResult().lineSeparatorPositions;", "+\t\tCompilationUnit compilationUnit = this.ast.newCompilationUnit();", "+\t\t// handle the package declaration immediately", "+\t\t// There is no node corresponding to the package declaration", "+\t\tif (this.resolveBindings) {", "+\t\t\trecordNodes(compilationUnit, unit);", "+\t\t}", "+\t\tif (unit.currentPackage != null) {", "+\t\t\tPackageDeclaration packageDeclaration = convertPackage(unit);", "+\t\t\tcompilationUnit.setPackage(packageDeclaration);", "+\t\t}", "+\t\torg.eclipse.jdt.internal.compiler.ast.ImportReference[] imports = unit.imports;", "+\t\tif (imports != null) {", "+\t\t\tint importLength = imports.length;", "+\t\t\tfor (int i = 0; i < importLength; i++) {", "+\t\t\t\tcompilationUnit.imports().add(convertImport(imports[i]));", "+\t\t\t}", "+\t\t}", "+", "+\t\t// Parse comments", "+\t\tint[][] comments = unit.comments;", "+\t\tif (comments != null) {", "+\t\t\tbuildCommentsTable(compilationUnit, comments);", "+\t\t}", "+", "+\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = unit.types;", "+\t\tif (types != null) {", "+\t\t\tint typesLength = types.length;", "+\t\t\tfor (int i = 0; i < typesLength; i++) {", "+\t\t\t\tASTNode type = convert(types[i]);", "+\t\t\t\tif (type == null) {", "+\t\t\t\t\tcompilationUnit.setFlags(compilationUnit.getFlags() | ASTNode.MALFORMED);", "+\t\t\t\t} else {", "+\t\t\t\t\tcompilationUnit.types().add(type);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tcompilationUnit.setSourceRange(unit.sourceStart, unit.sourceEnd - unit.sourceStart  + 1);", "+\t\t", "+\t\tint problemLength = unit.compilationResult.problemCount;", "+\t\tif (problemLength != 0) {", "+\t\t\tIProblem[] resizedProblems = null;", "+\t\t\tfinal IProblem[] problems = unit.compilationResult.problems;", "+\t\t\tif (problems.length == problemLength) {", "+\t\t\t\tresizedProblems = problems;", "+\t\t\t} else {", "+\t\t\t\tSystem.arraycopy(problems, 0, (resizedProblems = new IProblem[problemLength]), 0, problemLength);", "+\t\t\t}", "+\t\t\tASTSyntaxErrorPropagator syntaxErrorPropagator = new ASTSyntaxErrorPropagator(resizedProblems);", "+\t\t\tcompilationUnit.accept(syntaxErrorPropagator);", "+\t\t\tcompilationUnit.setProblems(resizedProblems);", "+\t\t}", "+\t\tif (this.resolveBindings) {", "+\t\t\tlookupForScopes();", "+\t\t}", "+\t\tcompilationUnit.initCommentMapper(this.scanner);", "+\t\treturn compilationUnit;", "+\t}"]}], "num": 4941}