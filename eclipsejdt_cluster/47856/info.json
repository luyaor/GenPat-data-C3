{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8b8d92808431f22630a8a0d8bafd29de", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2664083d06ac1c731ea31aa0539f2766", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "06c1fc5d4dd55fd1e0b31649f37b30f27170e633", "commitAfterChange": "e5d472ae376881b61d2a17c3e23cd62b7ed964f0", "methodNumberBeforeChange": 70, "methodNumberAfterChange": 70, "signatureBeforeChange": " protected void reportMatching(TypeParameter[] typeParameters, IJavaElement enclosingElement, IJavaElement parent, Binding binding, MatchingNodeSet nodeSet) throws CoreException", "signatureAfterChange": " protected void reportMatching(TypeParameter[] typeParameters, IJavaElement enclosingElement, IJavaElement parent, Binding binding, MatchingNodeSet nodeSet) throws CoreException", "diff": ["+\t\t\t\tif (typeParameter.type instanceof ParameterizedSingleTypeReference) {", "+                    ParameterizedSingleTypeReference paramSTR = (ParameterizedSingleTypeReference) typeParameter.type;", "+                    if (paramSTR.typeArguments != null) {", "+                    \tint length = paramSTR.typeArguments.length;", "+                    \tfor (int k=0; k<length; k++) {", "+\t\t\t\t\t\t\tTypeReference typeArgument = paramSTR.typeArguments[k];", "+\t\t\t\t\t\t\tlevel = (Integer) nodeSet.matchingNodes.removeKey(typeArgument);", "+\t\t\t\t\t\t\tif (level != null) {", "+\t\t\t\t\t\t\t\tIJavaElement localElement = createHandle(typeParameter, enclosingElement);", "+\t\t\t\t\t\t\t\tthis.patternLocator.matchReportReference(typeArgument, enclosingElement, localElement, null, binding, level.intValue(), this);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (typeArgument instanceof Wildcard) {", "+\t                            TypeReference wildcardBound = ((Wildcard) typeArgument).bound;", "+\t\t\t\t\t\t\t\tlevel = (Integer) nodeSet.matchingNodes.removeKey(wildcardBound);", "+\t\t\t\t\t\t\t\tif (level != null) {", "+\t\t\t\t\t\t\t\t\tIJavaElement localElement = createHandle(typeParameter, enclosingElement);", "+\t\t\t\t\t\t\t\t\tthis.patternLocator.matchReportReference(wildcardBound, enclosingElement, localElement, null, binding, level.intValue(), this);", "+\t\t\t\t\t\t\t\t}", "+                            }", "+                    \t}", "+                    }", "+\t\t\t\t}", "-\t\t\t\t\tlevel = (Integer) nodeSet.matchingNodes.removeKey(typeParameter.bounds[j]);", "+\t\t\t\t\tTypeReference typeParameterBound = typeParameter.bounds[j];", "+\t\t\t\t\tlevel = (Integer) nodeSet.matchingNodes.removeKey(typeParameterBound);", "-\t\t\t\t\t\tthis.patternLocator.matchReportReference(typeParameter.bounds[j], enclosingElement, localElement, null, binding, level.intValue(), this);", "+\t\t\t\t\t\tthis.patternLocator.matchReportReference(typeParameterBound, enclosingElement, localElement, null, binding, level.intValue(), this);", "+\t\t\t\t\tif (typeParameterBound instanceof ParameterizedSingleTypeReference) {", "+\t                    ParameterizedSingleTypeReference paramSTR = (ParameterizedSingleTypeReference) typeParameterBound;", "+\t                    if (paramSTR.typeArguments != null) {", "+\t                    \tint length = paramSTR.typeArguments.length;", "+\t                    \tfor (int k=0; k<length; k++) {", "+\t\t\t\t\t\t\t\tTypeReference typeArgument = paramSTR.typeArguments[k];", "+\t\t\t\t\t\t\t\tlevel = (Integer) nodeSet.matchingNodes.removeKey(typeArgument);", "+\t\t\t\t\t\t\t\tif (level != null) {", "+\t\t\t\t\t\t\t\t\tIJavaElement localElement = createHandle(typeParameter, enclosingElement);", "+\t\t\t\t\t\t\t\t\tthis.patternLocator.matchReportReference(typeArgument, enclosingElement, localElement, null, binding, level.intValue(), this);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (typeArgument instanceof Wildcard) {", "+\t\t                            TypeReference wildcardBound = ((Wildcard) typeArgument).bound;", "+\t\t\t\t\t\t\t\t\tlevel = (Integer) nodeSet.matchingNodes.removeKey(wildcardBound);", "+\t\t\t\t\t\t\t\t\tif (level != null) {", "+\t\t\t\t\t\t\t\t\t\tIJavaElement localElement = createHandle(typeParameter, enclosingElement);", "+\t\t\t\t\t\t\t\t\t\tthis.patternLocator.matchReportReference(wildcardBound, enclosingElement, localElement, null, binding, level.intValue(), this);", "+\t\t\t\t\t\t\t\t\t}", "+\t                            }", "+\t                    \t}", "+\t                    }", "+                    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a7c3085cf400bcc6f7e2bf0bfa07fe2d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "09f42f58bcdf2fa84ccd2b8b65f28ab3036222ca", "commitAfterChange": "57e8dd41219d846363c918d62edb5007994c5c79", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tprivate int myParameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site)", "signatureAfterChange": "  \tprivate int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site)", "diff": ["-\t// FIXME(stephan): final integration into the code", "-\tprivate int myParameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site) {", "+\tprivate int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site) {", "-\t\t\tif (((Invocation) site).inferenceKind() > 0)", "-\t\t\t\treturn COMPATIBLE; // inference is responsible, no need to recheck", "+\t\t\tInvocation invocation = (Invocation) site;", "+\t\t\tif (method instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\tInferenceContext18 infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);", "+\t\t\t\tif (infCtx != null)", "+\t\t\t\t\treturn COMPATIBLE; // inference is responsible, no need to recheck", "+\t\t\t}", "+\t\t\t// collect inner invocations where the outer did not involve any inference:", "+\t\t\tExpression[] invocationArguments = invocation.arguments();", "+\t\t\tif (invocationArguments != null) {", "+\t\t\t\tint argLen = invocationArguments.length;", "+\t\t\t\tboolean isVarArgs = false;", "+\t\t\t\tfor (int i = 0; i < argLen; i++) {", "+\t\t\t\t\tExpression invocArg = invocationArguments[i];", "+\t\t\t\t\tif (invocArg instanceof Invocation && invocArg.resolvedType != null) { // TODO any poly? ReferenceExpression?", "+\t\t\t\t\t\tInvocation innerPoly = (Invocation) invocArg;", "+\t\t\t\t\t\tTypeBinding targetType = InferenceContext18.getParameter(method.parameters, i, false);", "+\t\t\t\t\t\tif (targetType == null && method.isVarargs()) {", "+\t\t\t\t\t\t\tisVarArgs = true;", "+\t\t\t\t\t\t\ttargetType = InferenceContext18.getParameter(method.parameters, i, true);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tTypeBinding resolvedType = invocArg.resolvedType; ", "+\t\t\t\t\t\tif (!resolvedType.isCompatibleWith(targetType, this)) {", "+\t\t\t\t\t\t\tMethodBinding innerBinding = innerPoly.binding();", "+\t\t\t\t\t\t\tif (innerBinding instanceof ParameterizedGenericMethodBinding) { // FIXME: does this happen?", "+\t\t\t\t\t\t\t\tInferenceContext18 infCtx18 = innerPoly.getInferenceContext((ParameterizedGenericMethodBinding) innerBinding);", "+\t\t\t\t\t\t\t\tif (infCtx18 != null) {", "+\t\t\t\t\t\t\t\t\t// not detected as compatible, because inference still needs to complete?", "+\t\t\t\t\t\t\t\t\tMethodBinding solution = infCtx18.getInvocationTypeInferenceSolution(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinnerPoly.binding().original(), innerPoly, targetType);", "+\t\t\t\t\t\t\t\t\tif (solution != null) {", "+\t\t\t\t\t\t\t\t\t\tif (solution.returnType != null && solution.returnType.isCompatibleWith(targetType, this))", "+\t\t\t\t\t\t\t\t\t\t\treturn isVarArgs ? VARARGS_COMPATIBLE : COMPATIBLE;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tMethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(targetType, innerPoly.binding());", "+\t\t\t\t\t\t\t\t\t\tif (problemMethod != null && problemMethod.isValidBinding())", "+\t\t\t\t\t\t\t\t\t\t\treturn COMPATIBLE;", "+\t\t\t\t\t\t\t\t\t\treturn NOT_COMPATIBLE;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else if (innerPoly instanceof AllocationExpression) {", "+\t\t\t\t\t\t\t\t\t// not detected as compatible, because its a diamond whose type hasn't yet been inferred?", "+\t\t\t\t\t\t\t\t\tTypeBinding[] typeArguments = resolvedType.typeArguments();", "+\t\t\t\t\t\t\t\t\tif (typeArguments != null && typeArguments.length == 0) {", "+\t\t\t\t\t\t\t\t\t\tAllocationExpression alloc = (AllocationExpression) innerPoly;", "+\t\t\t\t\t\t\t\t\t\tif ((alloc.type.bits & ASTNode.IsDiamond) != 0) {", "+\t\t\t\t\t\t\t\t\t\t\t// not-yet-inferred diamond: erasure compatibility should suffice, detail will be checked using inference", "+\t\t\t\t\t\t\t\t\t\t\tif (invocArg.resolvedType.isCompatibleWith(targetType.erasure(), this))", "+\t\t\t\t\t\t\t\t\t\t\t\treturn COMPATIBLE;", "+\t\t\t\t\t\t\t\t\t\t\treturn NOT_COMPATIBLE;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 47856}