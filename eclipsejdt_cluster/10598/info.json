{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4dc1a6f416793ce2408795ca5c8527ad", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "31b69c51973b76e1d6cc979af06ccd58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java", "commitBeforeChange": "76b6aef868544c4d2f6d21575e84412f247472ae", "commitAfterChange": "406d61c9a16be8f709e407a59600ccbf947335dd", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \r \tpublic void checkName()", "signatureAfterChange": "\r \r \tpublic void resolveStatements(ClassScope upperScope)", "diff": ["-\tpublic void checkName() {\r", "-\r", "-\t\t// look if the name of the method is correct\r", "-\t\tif (binding != null && isTypeUseDeprecated(binding.returnType, scope))\r", "-\t\t\tscope.problemReporter().deprecatedType(binding.returnType, returnType);\r", "-\r", "-\t\tif (CharOperation.equals(scope.enclosingSourceType().sourceName, selector))\r", "-\t\t\tscope.problemReporter().methodWithConstructorName(this);\r", "-\r", "-\t\t// by grammatical construction, interface methods are always abstract\r", "-\t\tif (scope.enclosingSourceType().isInterface())\r", "-\t\t\treturn;\r", "-\r", "-\t\t// if a method has an semicolon body and is not declared as abstract==>error\r", "-\t\t// native methods may have a semicolon body \r", "-\t\tif ((modifiers & AccSemicolonBody) != 0) {\r", "-\t\t\tif ((modifiers & AccNative) == 0)\r", "-\t\t\t\tif ((modifiers & AccAbstract) == 0)\r", "-\t\t\t\t\tscope.problemReporter().methodNeedingAbstractModifier(this);\r", "-\t\t} else {\r", "-\t\t\t// the method HAS a body --> abstract native modifiers are forbiden\r", "-\t\t\tif (((modifiers & AccNative) != 0) || ((modifiers & AccAbstract) != 0))\r", "-\t\t\t\tscope.problemReporter().methodNeedingNoBody(this);\r", "-\t\t}\r", "-\t}\r", "+\tpublic void resolveStatements(ClassScope upperScope) {\r", "+\t\tif (this.returnType != null && this.binding != null) {\r", "+\t\t\tthis.returnType.binding = this.binding.returnType;\r", "+\t\t\t// record the return type binding\r", "+\t\t// look if the name of the method is correct\r", "+\t\tif (binding != null && isTypeUseDeprecated(binding.returnType, scope))\r", "+\t\t\tscope.problemReporter().deprecatedType(binding.returnType, returnType);\r", "+\r", "+\t\tif (CharOperation.equals(scope.enclosingSourceType().sourceName, selector))\r", "+\t\t\tscope.problemReporter().methodWithConstructorName(this);\r", "+\r", "+\t\t// by grammatical construction, interface methods are always abstract\r", "+\t\tif (!scope.enclosingSourceType().isInterface()){\r", "+\r", "+\t\t\t// if a method has an semicolon body and is not declared as abstract==>error\r", "+\t\t\t// native methods may have a semicolon body \r", "+\t\t\tif ((modifiers & AccSemicolonBody) != 0) {\r", "+\t\t\t\tif ((modifiers & AccNative) == 0)\r", "+\t\t\t\t\tif ((modifiers & AccAbstract) == 0)\r", "+\t\t\t\t\t\tscope.problemReporter().methodNeedingAbstractModifier(this);\r", "+\t\t\t} else {\r", "+\t\t\t\t// the method HAS a body --> abstract native modifiers are forbiden\r", "+\t\t\t\tif (((modifiers & AccNative) != 0) || ((modifiers & AccAbstract) != 0))\r", "+\t\t\t\t\tscope.problemReporter().methodNeedingNoBody(this);\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tsuper.resolveStatements(upperScope); \r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c598accbe27f39d2f6e8a1b520aa99c9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java", "commitBeforeChange": "9275c96ab9e7e5e5f780672ec67bf57a1eb2d42e", "commitAfterChange": "437ac0488c92b5c24e88567c6caa0b204b0064ba", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic void resolveStatements()", "signatureAfterChange": "  \tpublic void resolveStatements()", "diff": ["-\t\tif (!scope.enclosingSourceType().isInterface()){", "-", "-\t\t\t// if a method has an semicolon body and is not declared as abstract==>error", "-\t\t\t// native methods may have a semicolon body ", "-\t\t\tif ((modifiers & AccSemicolonBody) != 0) {", "-\t\t\t\tif ((modifiers & AccNative) == 0)", "-\t\t\t\t\tif ((modifiers & AccAbstract) == 0)", "-\t\t\t\t\t\tscope.problemReporter().methodNeedBody(this);", "-\t\t\t} else {", "-\t\t\t\t// the method HAS a body --> abstract native modifiers are forbiden", "-\t\t\t\tif (((modifiers & AccNative) != 0) || ((modifiers & AccAbstract) != 0))", "-\t\t\t\t\tscope.problemReporter().methodNeedingNoBody(this);", "-\t\t\t}", "+\t\tswitch (scope.referenceType().getKind()) {", "+\t\t\tcase IGenericType.ENUM :", "+\t\t\t\tif (this.selector == TypeConstants.VALUES) break;", "+\t\t\t\tif (this.selector == TypeConstants.VALUEOF) break;", "+\t\t\tcase IGenericType.CLASS :", "+\t\t\t\t// if a method has an semicolon body and is not declared as abstract==>error", "+\t\t\t\t// native methods may have a semicolon body ", "+\t\t\t\tif ((modifiers & AccSemicolonBody) != 0) {", "+\t\t\t\t\tif ((modifiers & AccNative) == 0)", "+\t\t\t\t\t\tif ((modifiers & AccAbstract) == 0)", "+\t\t\t\t\t\t\tscope.problemReporter().methodNeedBody(this);", "+\t\t\t\t} else {", "+\t\t\t\t\t// the method HAS a body --> abstract native modifiers are forbiden", "+\t\t\t\t\tif (((modifiers & AccNative) != 0) || ((modifiers & AccAbstract) != 0))", "+\t\t\t\t\t\tscope.problemReporter().methodNeedingNoBody(this);", "+\t\t\t\t}"]}], "num": 10598}