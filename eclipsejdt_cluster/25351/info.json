{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "066da093e9d0487fa1c904c853a93c5c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "21e99b1716cb72802bb336a2699c190c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java", "commitBeforeChange": "45c680054b27b9c98f10c88da800e79c9dec8528", "commitAfterChange": "1d817cf86d6dbfa3bc80c59d0139cb561aace8b1", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tpublic void generateOptimizedStringConcatenationCreation( \t\tBlockScope blockScope, \t\tCodeStream codeStream, \t\tint typeID)", "signatureAfterChange": " \tpublic void generateOptimizedStringConcatenationCreation( \t\tBlockScope blockScope, \t\tCodeStream codeStream, \t\tint typeID)", "diff": ["-\t\t// Optimization only for integers and strings", "-\t\tif (typeID == T_JavaLangObject) {", "-\t\t\t// in the case the runtime value of valueOf(Object) returns null, we have to use append(Object) instead of directly valueOf(Object)", "-\t\t\t// append(Object) returns append(valueOf(Object)), which means that the null case is handled by append(String).", "-\t\t\tcodeStream.newStringContatenation();", "-\t\t\tcodeStream.dup();", "-\t\t\tcodeStream.invokeStringConcatenationDefaultConstructor();", "-\t\t\tgenerateCode(blockScope, codeStream, true);", "-\t\t\tcodeStream.invokeStringConcatenationAppendForType(T_JavaLangObject);", "-\t\t\treturn;", "-\t\t}", "-\t\tif (typeID == T_JavaLangString || typeID == T_null) {", "-\t\t\tif (constant != NotAConstant) {", "-\t\t\t\tString stringValue = constant.stringValue();", "-\t\t\t\tif (stringValue.length() == 0) {  // optimize \"\"+<str> ", "-\t\t\t\t\tcodeStream.invokeStringConcatenationDefaultConstructor();", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t\tcodeStream.ldc(stringValue);", "-\t\t\t} else {", "+\t\tswitch (typeID) {", "+\t\t\tcase T_JavaLangObject :", "+\t\t\tcase T_undefined :", "+\t\t\t\t// in the case the runtime value of valueOf(Object) returns null, we have to use append(Object) instead of directly valueOf(Object)", "+\t\t\t\t// append(Object) returns append(valueOf(Object)), which means that the null case is handled by append(String).", "+\t\t\t\tcodeStream.invokeStringConcatenationDefaultConstructor();", "-\t\t\t\tcodeStream.invokeStringValueOf(T_JavaLangObject);", "-\t\t\t}", "-\t\t} else {", "-\t\t\tgenerateCode(blockScope, codeStream, true);", "-\t\t\tcodeStream.invokeStringValueOf(typeID);", "+\t\t\t\tcodeStream.invokeStringConcatenationAppendForType(T_JavaLangObject);", "+\t\t\t\treturn;", "+", "+\t\t\tcase T_JavaLangString :", "+\t\t\tcase T_null :", "+\t\t\t\tif (constant != NotAConstant) {", "+\t\t\t\t\tString stringValue = constant.stringValue();", "+\t\t\t\t\tif (stringValue.length() == 0) {  // optimize \"\"+<str> ", "+\t\t\t\t\t\tcodeStream.invokeStringConcatenationDefaultConstructor();", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tcodeStream.ldc(stringValue);", "+\t\t\t\t} else {", "+\t\t\t\t\tgenerateCode(blockScope, codeStream, true);", "+\t\t\t\t\tcodeStream.invokeStringValueOf(T_JavaLangObject);", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tdefault :", "+\t\t\t\tgenerateCode(blockScope, codeStream, true);", "+\t\t\t\tcodeStream.invokeStringValueOf(typeID);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f789828c998b6f3a6a0394c45ebe2aa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "a738cdbf5d0b40e078d2ec76d22bcb613279cff6", "commitAfterChange": "b41120aee6f499b9a774d71aea9151d984f245c5", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " public void processDelta(IJavaElementDelta delta, int eventType)", "signatureAfterChange": " public void processDelta(IJavaElementDelta delta, int eventType)", "diff": ["-\t\t\t\tIPath path = null;", "+\t\t\t\tString path = null;", "-\t\t\t\t\t\tpath = ((IJavaProject)element).getProject().getFullPath();", "+\t\t\t\t\t\tpath = ((IJavaProject)element).getProject().getFullPath().toString();", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tif (path == null) {", "-\t\t\t\t\t\t\tpath = ((IPackageFragmentRoot)element).getPath();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tint toRemove = -1;", "-\t\t\t\t\t\tfor (int i = 0; i < this.pathsCount; i++) {", "-\t\t\t\t\t\t\tif (this.relativePaths[i].equals(path)) { // TODO (jerome) this compares String and IPath !", "-\t\t\t\t\t\t\t\ttoRemove = i;", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (toRemove != -1) {", "-\t\t\t\t\t\t\tthis.relativePaths[toRemove] = null;", "-\t\t\t\t\t\t\trehash();", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tpath = ((IPackageFragmentRoot)element).getPath().toString();", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t\tfor (int i = 0; i < this.pathsCount; i++) {", "+\t\t\t\t\tif (this.relativePaths[i].equals(path)) {", "+\t\t\t\t\t\tthis.relativePaths[i] = null;", "+\t\t\t\t\t\trehash();", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f372933d5769cd4a26a821c3ed5186cb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "ba65adb7228709772812cc43f8ccb14a824acf89", "commitAfterChange": "6c797406271c70e354dc360e4e2b55dc743bf914", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tprotected void updateDocComment()", "signatureAfterChange": " \tprotected void updateDocComment()", "diff": ["-\t\t\tif (ptr == SEE_TAG_EXPECTED_ORDER) {", "-\t\t\t\tint size = this.astLengthStack[this.astLengthPtr--];", "-\t\t\t\tfor (int i=0; i<size; i++) {", "-\t\t\t\t\tthis.docComment.references[--sizes[ptr]] = (Expression) this.astStack[this.astPtr--];", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tswitch(ptr) {", "+\t\t\t\tcase SEE_TAG_EXPECTED_ORDER:", "+\t\t\t\t\tint size = this.astLengthStack[this.astLengthPtr--];", "+\t\t\t\t\tfor (int i=0; i<size; i++) {", "+\t\t\t\t\t\tthis.docComment.references[--sizes[ptr]] = (Expression) this.astStack[this.astPtr--];", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "-\t\t\t// Then continuing with class names (eg. TypeReference) coming from @throw/@exception declarations", "-\t\t\telse if (ptr == THROWS_TAG_EXPECTED_ORDER) {", "-\t\t\t\tint size = this.astLengthStack[this.astLengthPtr--];", "-\t\t\t\tfor (int i=0; i<size; i++) {", "-\t\t\t\t\tthis.docComment.thrownExceptions[--sizes[ptr]] = (TypeReference) this.astStack[this.astPtr--];", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\t\t// Then continuing with class names (eg. TypeReference) coming from @throw/@exception declarations", "+\t\t\t\tcase THROWS_TAG_EXPECTED_ORDER:", "+\t\t\t\t\tsize = this.astLengthStack[this.astLengthPtr--];", "+\t\t\t\t\tfor (int i=0; i<size; i++) {", "+\t\t\t\t\t\tthis.docComment.thrownExceptions[--sizes[ptr]] = (TypeReference) this.astStack[this.astPtr--];", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "-\t\t\t// Finally, finishing with parameters nales (ie. Argument) coming from @param declaration", "-\t\t\telse if (ptr == PARAM_TAG_EXPECTED_ORDER) {", "-\t\t\t\tint size = this.astLengthStack[this.astLengthPtr--];", "-\t\t\t\tfor (int i=0; i<size; i++) {", "-\t\t\t\t\tthis.docComment.parameters[--sizes[ptr]] = (JavadocSingleNameReference) this.astStack[this.astPtr--];", "-\t\t\t\t}", "+\t\t\t\t// Finally, finishing with parameters nales (ie. Argument) coming from @param declaration", "+\t\t\t\tcase PARAM_TAG_EXPECTED_ORDER:", "+\t\t\t\t\tsize = this.astLengthStack[this.astLengthPtr--];", "+\t\t\t\t\tfor (int i=0; i<size; i++) {", "+\t\t\t\t\t\tthis.docComment.parameters[--sizes[ptr]] = (JavadocSingleNameReference) this.astStack[this.astPtr--];", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;"]}], "num": 25351}