{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "501687d8b2ec733d8b6810406f0f851d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2eb7fccb1a64d4a31bada3683ed9d0a4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["+\t\tboolean isViewedAsDeprecated = isViewedAsDeprecated();", "+\t\tboolean complyTo15 = fPackage.environment.options.sourceLevel >= ClassFileConstants.JDK1_5;", "-\t\t\tif (resolveTypesFor(methods[i]) == null) {", "+\t\t\tMethodBinding method = methods[i];", "+\t\t\tif (resolveTypesFor(method) == null) {", "+\t\t\t} else {", "+\t\t\t\tif ((method.getAnnotationTagBits() & AnnotationDeprecated) != 0) {", "+\t\t\t\t\tmethod.modifiers |= AccDeprecated;", "+\t\t\t\t} else if (complyTo15 && (method.modifiers & AccDeprecated) != 0) {", "+\t\t\t\t\tscope.problemReporter().missingDeprecatedAnnotationForMethod(method.sourceMethod());", "+\t\t\t\t}", "+\t\t\t\tif (isViewedAsDeprecated && !method.isDeprecated()) {", "+\t\t\t\t\tmethod.modifiers |= AccDeprecatedImplicitly;", "+\t\t\t\t}", "-\t\tboolean is15 = fPackage.environment.options.sourceLevel >= ClassFileConstants.JDK1_5;", "-\t\t\t\t\t\tboolean paramsMatch = is15 && method.returnType == method2.returnType // see 87956", "+\t\t\t\t\t\tboolean paramsMatch = complyTo15 && method.returnType == method2.returnType // see 87956"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60295b5eed009c4dfa94cad3cba6d427", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java", "commitBeforeChange": "7d36cd74d7dfc1f56f940c426e98d6c489655858", "commitAfterChange": "f95e58c822d23fa71cf6c6e2ac3adce80f07a42f", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope, boolean checkBounds)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope, boolean checkBounds)", "diff": ["-\t\tReferenceBinding qualifiedType = null;", "+\t\tReferenceBinding qualifyingType = null;", "-\t\t\tif (qualifiedType == null) {", "-\t\t\t\tqualifiedType = currentType.enclosingType(); // if member type", "-\t\t\t\tif (qualifiedType != null) {", "-\t\t\t\t\tqualifiedType = currentType.isStatic()", "-\t\t\t\t\t\t? (ReferenceBinding) scope.environment().convertToRawType(qualifiedType, false /*do not force conversion of enclosing types*/)", "-\t\t\t\t\t\t: scope.environment().convertToParameterizedType(qualifiedType);", "+\t\t\tif (qualifyingType == null) {", "+\t\t\t\tqualifyingType = currentType.enclosingType(); // if member type", "+\t\t\t\tif (qualifyingType != null) {", "+\t\t\t\t\tqualifyingType = currentType.isStatic()", "+\t\t\t\t\t\t? (ReferenceBinding) scope.environment().convertToRawType(qualifyingType, false /*do not force conversion of enclosing types*/)", "+\t\t\t\t\t\t: scope.environment().convertToParameterizedType(qualifyingType);", "-\t\t\t}\t\t\t\t", "-\t\t\tif (typeIsConsistent ", "-\t\t\t\t\t\t&& currentType.isStatic() ", "-\t\t\t\t\t\t&& qualifiedType != null ", "-\t\t\t\t\t\t&& ((qualifiedType.isParameterizedType() && ((ParameterizedTypeBinding)qualifiedType).arguments != null) || qualifiedType.isGenericType())) {", "-\t\t\t\tscope.problemReporter().staticMemberOfParameterizedType(this, scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), null, qualifiedType));", "-\t\t\t\ttypeIsConsistent = false;", "-\t\t\t}\t\t\t", "+\t\t\t} else {", "+\t\t\t\tif (typeIsConsistent && currentType.isStatic() ", "+\t\t\t\t\t\t&& ((qualifyingType.isParameterizedType() && ((ParameterizedTypeBinding)qualifyingType).arguments != null) || qualifyingType.isGenericType())) {", "+\t\t\t\t\tscope.problemReporter().staticMemberOfParameterizedType(this, scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), null, qualifyingType));", "+\t\t\t\t\ttypeIsConsistent = false;", "+\t\t\t\t}\t\t\t\t\t", "+\t\t\t\tReferenceBinding enclosingType = currentType.enclosingType();", "+\t\t\t\tif (enclosingType != null && enclosingType.erasure() != qualifyingType.erasure()) { // qualifier != declaring/enclosing", "+\t\t\t\t\tqualifyingType = enclosingType; // inherited member type, leave it associated with its enclosing rather than subtype", "+\t\t\t\t}", "+\t\t\t}", "+\t\t", "-\t\t\t\t\tthis.resolvedType =  (qualifiedType != null && qualifiedType.isParameterizedType())", "-\t\t\t\t\t\t? scope.environment().createParameterizedType(currentErasure, null, qualifiedType)", "+\t\t\t\t\tthis.resolvedType =  (qualifyingType != null && qualifyingType.isParameterizedType())", "+\t\t\t\t\t\t? scope.environment().createParameterizedType(currentErasure, null, qualifyingType)", "-\t\t\t\t}\t\t\t\t", "-\t\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(currentErasure, argTypes, qualifiedType);", "+\t\t\t\t}", "+\t\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(currentErasure, argTypes, qualifyingType);", "-\t\t\t\tqualifiedType = parameterizedType;", "+\t\t\t\tqualifyingType = parameterizedType;", "-\t   \t\t\t    if (typeIsConsistent && qualifiedType != null && qualifiedType.isParameterizedType()) {", "-\t\t\t\t\t\tscope.problemReporter().parameterizedMemberTypeMissingArguments(this, scope.environment().createParameterizedType(currentErasure, null, qualifiedType));", "+\t   \t\t\t    if (typeIsConsistent && qualifyingType != null && qualifyingType.isParameterizedType()) {", "+\t\t\t\t\t\tscope.problemReporter().parameterizedMemberTypeMissingArguments(this, scope.environment().createParameterizedType(currentErasure, null, qualifyingType));", "-\t   \t\t\t    qualifiedType = scope.environment().createRawType(currentErasure, qualifiedType); // raw type", "+\t   \t\t\t    qualifyingType = scope.environment().createRawType(currentErasure, qualifyingType); // raw type", "-\t\t\t\t\tqualifiedType = (qualifiedType != null && qualifiedType.isParameterizedType())", "-\t\t\t\t\t\t\t\t\t\t\t\t\t? scope.environment().createParameterizedType(currentErasure, null, qualifiedType)", "+\t\t\t\t\tqualifyingType = (qualifyingType != null && qualifyingType.isParameterizedType())", "+\t\t\t\t\t\t\t\t\t\t\t\t\t? scope.environment().createParameterizedType(currentErasure, null, qualifyingType)", "-\t\t\tif (isTypeUseDeprecated(qualifiedType, scope))", "-\t\t\t\treportDeprecatedType(qualifiedType, scope);\t\t    ", "-\t\t\tthis.resolvedType = qualifiedType;", "+\t\t\tif (isTypeUseDeprecated(qualifyingType, scope))", "+\t\t\t\treportDeprecatedType(qualifyingType, scope);\t\t    ", "+\t\t\tthis.resolvedType = qualifyingType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "84cf94a26084f3b014b594930a5afa95", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " public FieldBinding[] fields()", "signatureAfterChange": " public FieldBinding[] fields()", "diff": ["+\t\tboolean isViewedAsDeprecated = isViewedAsDeprecated();", "+\t\tboolean complyTo15 = fPackage.environment.options.sourceLevel >= ClassFileConstants.JDK1_5;", "-\t\t\tif (resolveTypeFor(fields[i]) == null) {", "+\t\t\tFieldBinding field = fields[i];", "+\t\t\tif (resolveTypeFor(field) == null) {", "+\t\t\t} else {", "+\t\t\t\tif ((field.getAnnotationTagBits() & AnnotationDeprecated) != 0) {", "+\t\t\t\t\tfield.modifiers |= AccDeprecated;", "+\t\t\t\t} else if (complyTo15 && (field.modifiers & AccDeprecated) != 0) {", "+\t\t\t\t\tscope.problemReporter().missingDeprecatedAnnotationForField(field.sourceField());", "+\t\t\t\t}", "+\t\t\t\tif (isViewedAsDeprecated && !field.isDeprecated()) {", "+\t\t\t\t\tfield.modifiers |= AccDeprecatedImplicitly;\t", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f337ce9604e16440979dd5362efea4f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "f908d0c09b5bf34a0f6e90dacd8d551c0f19870c", "commitAfterChange": "2d9e2019b5b59684e0488ab5bab1ae5850c1ca71", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes)", "signatureAfterChange": " \tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes)", "diff": ["-\t\t\t    returnType.collectSubstitutes(scope, expectedType, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t    this.returnType.collectSubstitutes(scope, expectedType, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t\tboolean argAlreadyInferred = argument != originalVariable;", "-\t\t\t\t\tScope.substitute(this, originalVariable.firstBound) // substitue original bound with resolved variables", "-\t\t\t\t\t\t.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t\tTypeBinding substitutedBound = Scope.substitute(this, originalVariable.superclass);", "+\t\t\t\t\targument.collectSubstitutes(scope, substitutedBound, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference", "+\t\t\t\t\t// e.g. given: <E extends Object, S extends Collection<E>> S test1(S param)", "+\t\t\t\t\t//                   invocation: test1(new Vector<String>())    will infer: S=Vector<String>  and with code below: E=String", "+\t\t\t\t\tif (argAlreadyInferred)", "+\t\t\t\t\t\tsubstitutedBound.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "-\t\t\t\t\tScope.substitute(this, originalVariable.superInterfaces[j]) // substitue original bound with resolved variables", "-\t\t\t\t\t\t.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t\tTypeBinding substitutedBound = Scope.substitute(this, originalVariable.superInterfaces[j]);", "+\t\t\t\t\targument.collectSubstitutes(scope, substitutedBound, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference", "+\t\t\t\t\tif (argAlreadyInferred)", "+\t\t\t\t\t\tsubstitutedBound.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a9eb3bb7c76f7e98c4b9a3edcab8bd03", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " private void createMethods(IBinaryMethod[] iMethods, long sourceLevel)", "signatureAfterChange": " private void createMethods(IBinaryMethod[] iMethods, long sourceLevel)", "diff": ["+\tboolean isViewedAsDeprecated = isViewedAsDeprecated();", "-\t\tfor (int i = 0; i < initialTotal; i++)", "-\t\t\tthis.methods[i] = createMethod(iMethods[i], sourceLevel);", "+\t\tfor (int i = 0; i < initialTotal; i++) {", "+\t\t\tMethodBinding method = createMethod(iMethods[i], sourceLevel);", "+\t\t\tif (isViewedAsDeprecated && !method.isDeprecated()) {", "+\t\t\t\tmethod.modifiers |= AccDeprecatedImplicitly;", "+\t\t\t}\t\t", "+\t\t\tthis.methods[i] = method;", "+\t\t}", "-\t\t\tif (iClinit != i && (toSkip == null || toSkip[i] != -1))", "-\t\t\t\tthis.methods[index++] = createMethod(iMethods[i], sourceLevel);", "+\t\t\tif (iClinit != i && (toSkip == null || toSkip[i] != -1)) {", "+\t\t\t\tMethodBinding method = createMethod(iMethods[i], sourceLevel);", "+\t\t\t\tif (isViewedAsDeprecated && !method.isDeprecated()) {", "+\t\t\t\t\tmethod.modifiers |= AccDeprecatedImplicitly;", "+\t\t\t\t}\t\t", "+\t\t\t\tthis.methods[index++] = method;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b7aaec1624c41d4e9874347321b7eb44", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  void faultInTypesForFieldsAndMethods()", "signatureAfterChange": "  void faultInTypesForFieldsAndMethods()", "diff": ["+\t// check @Deprecated annotation", "+\tif ((this.getAnnotationTagBits() & AnnotationDeprecated) != 0) {", "+\t\tthis.modifiers |= AccDeprecated;", "+\t} else if ((this.modifiers & AccDeprecated) != 0 && scope != null && scope.environment().options.sourceLevel >= JDK1_5) {", "+\t\tscope.problemReporter().missingDeprecatedAnnotationForType(scope.referenceContext);", "+\t}", "+\tReferenceBinding enclosingType = this.enclosingType();", "+\tif (enclosingType != null && enclosingType.isViewedAsDeprecated() && !this.isDeprecated()) {", "+\t\tmodifiers |= AccDeprecatedImplicitly;\t", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c3967df270adf5912761fa0f22241346", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "b89ad18e17834e64930a830c92b5e2241f9a8b44", "commitAfterChange": "d9605208e25375e966739effbd053a969138c830", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-\t\tboolean complyTo15 = this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\tboolean complyTo15OrAbove = this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\tboolean compliance16 = this.scope.compilerOptions().complianceLevel == ClassFileConstants.JDK1_6;", "+\t\t", "+\t\t\tint severity = ProblemSeverities.Error;", "-\t\t\t\tif (complyTo15 ? !method.areParameterErasuresEqual(method2) : !method.areParametersEqual(method2))", "-\t\t\t\t\tcontinue nextSibling; // otherwise duplicates / name clash", "+\t\t\t\tif (complyTo15OrAbove) {", "+\t\t\t\t\tif (method.areParameterErasuresEqual(method2)) {", "+\t\t\t\t\t\t// we now ignore return types in 1.7 when detecting duplicates, just as we did before 1.5 ", "+\t\t\t\t\t\t// Only in 1.6, we have to make sure even return types are different", "+\t\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=317719", "+\t\t\t\t\t\tif (compliance16 && method.returnType != null && method2.returnType != null) {", "+\t\t\t\t\t\t\tif (method.returnType.erasure() != method2.returnType.erasure()) {", "+\t\t\t\t\t\t\t\tseverity = ProblemSeverities.Warning;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// else return types also equal. All conditions satisfied", "+\t\t\t\t\t\t\t// to give error in 1.6 compliance as well.", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcontinue nextSibling;", "+\t\t\t\t\t}", "+\t\t\t\t} else if (!method.areParametersEqual(method2)) {", "+\t\t\t\t\t// prior to 1.5, parameters identical meant a collision case", "+\t\t\t\t\tcontinue nextSibling;", "+\t\t\t\t}", "+\t\t\t\t// otherwise duplicates / name clash", "-\t\t\t\tboolean removeMethod2 = true;", "+\t\t\t\tboolean removeMethod2 = (severity == ProblemSeverities.Error) ? true : false; // do not remove if in 1.6 and just a warning given", "-\t\t\t\t\t\t\tthis.scope.problemReporter().duplicateMethodInType(this, methodDecl, method.areParametersEqual(method2));", "+\t\t\t\t\t\t\tthis.scope.problemReporter().duplicateMethodInType(this, methodDecl, method.areParametersEqual(method2), severity);", "-\t\t\t\t\t\tthis.scope.problemReporter().duplicateMethodInType(this, method2Decl, method.areParametersEqual(method2));", "+\t\t\t\t\t\tthis.scope.problemReporter().duplicateMethodInType(this, method2Decl, method.areParametersEqual(method2), severity);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0e546c40bf131adb5257d02606fbd40", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "c10286277f9239e3088b8d188b41d6fe94e627af", "commitAfterChange": "0537003e571cfeb53f220f7f5e8c40a8ad99bcc6", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r public void checkAnnotation()", "signatureAfterChange": "\r public void checkAnnotation()", "diff": ["+\tboolean checkDeprecated = false;\r", "-\tfound : {\r", "-\t\tif ((lastAnnotationIndex = scanner.commentPtr) >= 0) { //look for @deprecated\r", "-\t\t\tint commentSourceStart = scanner.commentStarts[lastAnnotationIndex];\r", "-\t\t\t// javadoc only (non javadoc comment have negative end positions.)\r", "-\t\t\tint commentSourceEnd = scanner.commentStops[lastAnnotationIndex] - 1; //stop is one over\r", "-\t\t\tchar[] comment = scanner.source;\r", "-\r", "-\t\t\tfor (int i = commentSourceStart + 3; i < commentSourceEnd - 10; i++) {\r", "-\t\t\t\tif ((comment[i] == '@') \r", "-\t\t\t\t\t&& (comment[i + 1] == 'd')\r", "-\t\t\t\t\t&& (comment[i + 2] == 'e')\r", "-\t\t\t\t\t&& (comment[i + 3] == 'p')\r", "-\t\t\t\t\t&& (comment[i + 4] == 'r')\r", "-\t\t\t\t\t&& (comment[i + 5] == 'e')\r", "-\t\t\t\t\t&& (comment[i + 6] == 'c')\r", "-\t\t\t\t\t&& (comment[i + 7] == 'a')\r", "-\t\t\t\t\t&& (comment[i + 8] == 't')\r", "-\t\t\t\t\t&& (comment[i + 9] == 'e')\r", "-\t\t\t\t\t&& (comment[i + 10] == 'd')) {\r", "-\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.\r", "-\t\t\t\t\tint nextPos = i+11;\r", "-\t\t\t\t\tdeprecated = (comment[nextPos] == ' ') || (comment[nextPos] == '\\t') || (comment[nextPos] == '\\n') || (comment[nextPos] == '\\r') || (comment[nextPos] == '*');\r", "-\t\t\t\t\tbreak found;\r", "-\t\t\t\t}\r", "+\tfound : for (lastAnnotationIndex = scanner.commentPtr; lastAnnotationIndex >= 0; ){\r", "+\t\t//look for @deprecated into the first javadoc comment preceeding the declaration\r", "+\t\tint commentSourceStart = scanner.commentStarts[lastAnnotationIndex];\r", "+\t\t// javadoc only (non javadoc comment have negative end positions.)\r", "+\t\tif (modifiersSourceStart != -1 && modifiersSourceStart < commentSourceStart) {\r", "+\t\t\tif (lastAnnotationIndex-- >= 0) {\r", "+\t\t\t\tcontinue;\r", "+\t\t\t} else {\r", "+\t\t\t\treturn;\r", "+\t\tif (scanner.commentStops[lastAnnotationIndex] < 0) {\r", "+\t\t\tbreak found;\r", "+\t\t}\r", "+\t\tcheckDeprecated = true;\r", "+\t\tint commentSourceEnd = scanner.commentStops[lastAnnotationIndex] - 1; //stop is one over\r", "+\t\tchar[] comment = scanner.source;\r", "+\r", "+\t\tfor (int i = commentSourceStart + 3; i < commentSourceEnd - 10; i++) {\r", "+\t\t\tif ((comment[i] == '@') \r", "+\t\t\t\t&& (comment[i + 1] == 'd')\r", "+\t\t\t\t&& (comment[i + 2] == 'e')\r", "+\t\t\t\t&& (comment[i + 3] == 'p')\r", "+\t\t\t\t&& (comment[i + 4] == 'r')\r", "+\t\t\t\t&& (comment[i + 5] == 'e')\r", "+\t\t\t\t&& (comment[i + 6] == 'c')\r", "+\t\t\t\t&& (comment[i + 7] == 'a')\r", "+\t\t\t\t&& (comment[i + 8] == 't')\r", "+\t\t\t\t&& (comment[i + 9] == 'e')\r", "+\t\t\t\t&& (comment[i + 10] == 'd')) {\r", "+\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.\r", "+\t\t\t\tint nextPos = i+11;\r", "+\t\t\t\tdeprecated = (comment[nextPos] == ' ') || (comment[nextPos] == '\\t') || (comment[nextPos] == '\\n') || (comment[nextPos] == '\\r') || (comment[nextPos] == '*');\r", "+\t\t\t\tbreak found;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tbreak found;\r", "-\tif (lastAnnotationIndex >= 0) {\r", "-\t\tmodifiersSourceStart = scanner.commentStarts[scanner.commentPtr]; \r", "-\t\tscanner.commentPtr = -1; // reset the comment stack, since not necessary after having checked\r", "+\tif (lastAnnotationIndex >= 0 && checkDeprecated) {\r", "+\t\tmodifiersSourceStart = scanner.commentStarts[lastAnnotationIndex]; \r", "+\tscanner.commentPtr = -1; // reset the comment stack, since not necessary after having checked\r"]}], "num": 68268}