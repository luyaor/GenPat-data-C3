{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5453ae229007657c5dd7a895ce2d7685", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b439fad57104117d35bb4eb88a02e028", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java", "commitBeforeChange": "d3a9da1814717a2c18ee252440a7a4915c82ca4d", "commitAfterChange": "48f271f8e7253c61ab509c2c5bf9a6fc4c4c9724", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tpublic int lineNumber(int position)", "signatureAfterChange": " \tpublic int lineNumber(int position)", "diff": ["-\t */", "-\tpublic int lineNumber(int position) {", "-\t\tint length = lineEndTable.length;", "-\t\tif (length == 0) {", "-\t\t\t// no line number info", "-\t\t\treturn 1;", "-\t\t}", "-\t\tint low = 0;", "-\t\tif (position <= lineEndTable[low]) {", "-\t\t\t// position illegal or before the first line delimiter", "-\t\t\treturn 1;", "-\t\t}", "-\t\t// assert position > lineEndTable[low+1]  && low == 0", "-\t\tint hi = length - 1;", "-\t\tif (position > lineEndTable[hi]) {", "-\t\t\t// position beyond the last line separator", "-\t\t\tif (position >= getStartPosition() + getLength()) {", "-\t\t\t\t// this is beyond the end of the source length", "-\t\t\t\treturn 1;", "-\t\t\t} else {", "-\t\t\t\treturn length + 1;", "-\t\t\t}", "-\t\t}", "-\t\t// assert lineEndTable[low]  < position <= lineEndTable[hi]", "-\t\t// && low == 0 && hi == length - 1 && low < hi", "-\t\t", "-\t\t// binary search line end table", "-\t\twhile (true) {", "-\t\t\t// invariant lineEndTable[low] < position <= lineEndTable[hi]", "-\t\t\t// && 0 <= low < hi <= length - 1", "-\t\t\t// reducing measure hi - low", "-\t\t\tif (low + 1 == hi) {", "-\t\t\t\t// assert lineEndTable[low] < position <= lineEndTable[low+1]", "-\t\t\t\t// position is on line low+1 (line number is low+2)", "-\t\t\t\treturn low + 2;", "-\t\t\t}", "-\t\t\t// assert hi - low >= 2, so average is truly in between", "-\t\t\tint mid = (low + hi) / 2;", "-\t\t\t// assert 0 <= low < mid < hi <= length - 1", "-\t\t\tif (position <= lineEndTable[mid]) {", "-\t\t\t\t// assert lineEndTable[low] < position <= lineEndTable[mid]", "-\t\t\t\t// && 0 <= low < mid < hi <= length - 1", "-\t\t\t\thi = mid;", "-\t\t\t} else {", "-\t\t\t\t// position > lineEndTable[mid]", "-\t\t\t\t// assert lineEndTable[mid] < position <= lineEndTable[hi]", "-\t\t\t\t// && 0 <= low < mid < hi <= length - 1", "-\t\t\t\tlow = mid;", "-\t\t\t}", "-\t\t\t// in both cases, invariant reachieved with reduced measure", "-\t\t}", "-\t}", "+\t */", "+\tpublic int lineNumber(int position) {", "+\t\tif (this.lineEndTable == null) return 1;", "+\t\tint length = this.lineEndTable.length;", "+\t\tif (length == 0) {", "+\t\t\t// no line number info", "+\t\t\treturn 1;", "+\t\t}", "+\t\tint low = 0;", "+\t\tif (position <= this.lineEndTable[low]) {", "+\t\t\t// position illegal or before the first line delimiter", "+\t\t\treturn 1;", "+\t\t}", "+\t\t// assert position > lineEndTable[low+1]  && low == 0", "+\t\tint hi = length - 1;", "+\t\tif (position > this.lineEndTable[hi]) {", "+\t\t\t// position beyond the last line separator", "+\t\t\tif (position >= getStartPosition() + getLength()) {", "+\t\t\t\t// this is beyond the end of the source length", "+\t\t\t\treturn 1;", "+\t\t\t} else {", "+\t\t\t\treturn length + 1;", "+\t\t\t}", "+\t\t}", "+\t\t// assert lineEndTable[low]  < position <= lineEndTable[hi]", "+\t\t// && low == 0 && hi == length - 1 && low < hi", "+\t\t", "+\t\t// binary search line end table", "+\t\twhile (true) {", "+\t\t\t// invariant lineEndTable[low] < position <= lineEndTable[hi]", "+\t\t\t// && 0 <= low < hi <= length - 1", "+\t\t\t// reducing measure hi - low", "+\t\t\tif (low + 1 == hi) {", "+\t\t\t\t// assert lineEndTable[low] < position <= lineEndTable[low+1]", "+\t\t\t\t// position is on line low+1 (line number is low+2)", "+\t\t\t\treturn low + 2;", "+\t\t\t}", "+\t\t\t// assert hi - low >= 2, so average is truly in between", "+\t\t\tint mid = (low + hi) / 2;", "+\t\t\t// assert 0 <= low < mid < hi <= length - 1", "+\t\t\tif (position <= this.lineEndTable[mid]) {", "+\t\t\t\t// assert lineEndTable[low] < position <= lineEndTable[mid]", "+\t\t\t\t// && 0 <= low < mid < hi <= length - 1", "+\t\t\t\thi = mid;", "+\t\t\t} else {", "+\t\t\t\t// position > lineEndTable[mid]", "+\t\t\t\t// assert lineEndTable[mid] < position <= lineEndTable[hi]", "+\t\t\t\t// && 0 <= low < mid < hi <= length - 1", "+\t\t\t\tlow = mid;", "+\t\t\t}", "+\t\t\t// in both cases, invariant reachieved with reduced measure", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf09a81a833f1a71e2adaeb2ae6c1501", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic LocalDeclaration[] findLocalVariableDeclarations(int position)", "signatureAfterChange": " public LocalDeclaration[] findLocalVariableDeclarations(int position)", "diff": ["-\t */", "-\tpublic LocalDeclaration[] findLocalVariableDeclarations(int position) {", "-\t\t// local variable init", "-\t\tint ilocal = 0, maxLocals = this.localIndex;", "-\t\tboolean hasMoreVariables = maxLocals > 0;", "-\t\tLocalDeclaration[] localDeclarations = null;", "-\t\tint declPtr = 0;", "-\t\t// scope init", "-\t\tint iscope = 0, maxScopes = this.subscopeCount;", "-\t\tboolean hasMoreScopes = maxScopes > 0;", "-", "-\t\t// iterate scopes and variables in parallel", "-\t\twhile (hasMoreVariables || hasMoreScopes) {", "-\t\t\tif (hasMoreScopes", "-\t\t\t\t&& (!hasMoreVariables || (subscopes[iscope].startIndex() <= ilocal))) {", "-\t\t\t\t// consider subscope first", "-\t\t\t\tScope subscope = subscopes[iscope];", "-\t\t\t\tif (subscope.kind == Scope.BLOCK_SCOPE) { // do not dive in nested types", "-\t\t\t\t\tlocalDeclarations = ((BlockScope)subscope).findLocalVariableDeclarations(position);", "-\t\t\t\t\tif (localDeclarations != null) {", "-\t\t\t\t\t\treturn localDeclarations;", "-\t\t\t\t\t}", "-\t\t\t\thasMoreScopes = ++iscope < maxScopes;", "-\t\t\t} else {", "-\t\t\t\t// consider variable first", "-\t\t\t\tLocalVariableBinding local = locals[ilocal]; // if no local at all, will be locals[ilocal]==null", "-\t\t\t\tif (local != null) {", "-\t\t\t\t\tLocalDeclaration localDecl = local.declaration;", "-\t\t\t\t\tif (localDecl != null) {", "-\t\t\t\t\t\tif (localDecl.declarationSourceStart <= position) {", "-\t\t\t\t\t\t\tif (position <= localDecl.declarationSourceEnd) {", "-\t\t\t\t\t\t\t\tif (localDeclarations == null) {", "-\t\t\t\t\t\t\t\t\tlocalDeclarations = new LocalDeclaration[maxLocals];", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tlocalDeclarations[declPtr++] = localDecl;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\treturn localDeclarations;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\thasMoreVariables = ++ilocal < maxLocals;", "-\t\t\t\tif (!hasMoreVariables && localDeclarations != null) {", "+ */", "+public LocalDeclaration[] findLocalVariableDeclarations(int position) {", "+\t// local variable init", "+\tint ilocal = 0, maxLocals = this.localIndex;", "+\tboolean hasMoreVariables = maxLocals > 0;", "+\tLocalDeclaration[] localDeclarations = null;", "+\tint declPtr = 0;", "+", "+\t// scope init", "+\tint iscope = 0, maxScopes = this.subscopeCount;", "+\tboolean hasMoreScopes = maxScopes > 0;", "+", "+\t// iterate scopes and variables in parallel", "+\twhile (hasMoreVariables || hasMoreScopes) {", "+\t\tif (hasMoreScopes", "+\t\t\t&& (!hasMoreVariables || (this.subscopes[iscope].startIndex() <= ilocal))) {", "+\t\t\t// consider subscope first", "+\t\t\tScope subscope = this.subscopes[iscope];", "+\t\t\tif (subscope.kind == Scope.BLOCK_SCOPE) { // do not dive in nested types", "+\t\t\t\tlocalDeclarations = ((BlockScope)subscope).findLocalVariableDeclarations(position);", "+\t\t\t\tif (localDeclarations != null) {", "-\t\t}", "-\t\treturn null;", "-\t}", "+\t\t\thasMoreScopes = ++iscope < maxScopes;", "+\t\t} else {", "+\t\t\t// consider variable first", "+\t\t\tLocalVariableBinding local = this.locals[ilocal]; // if no local at all, will be locals[ilocal]==null", "+\t\t\tif (local != null) {", "+\t\t\t\tLocalDeclaration localDecl = local.declaration;", "+\t\t\t\tif (localDecl != null) {", "+\t\t\t\t\tif (localDecl.declarationSourceStart <= position) {", "+\t\t\t\t\t\tif (position <= localDecl.declarationSourceEnd) {", "+\t\t\t\t\t\t\tif (localDeclarations == null) {", "+\t\t\t\t\t\t\t\tlocalDeclarations = new LocalDeclaration[maxLocals];", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tlocalDeclarations[declPtr++] = localDecl;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\treturn localDeclarations;", "+\t\t\t}", "+\t\t\thasMoreVariables = ++ilocal < maxLocals;", "+\t\t\tif (!hasMoreVariables && localDeclarations != null) {", "+\t\t\t\treturn localDeclarations;", "+\treturn null;", "+}"]}], "num": 26242}