{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7c207976500149b723d2c9ee9dc3bced", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7d64f859a91f3a060c9d743de73b12b4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "bacbe6f6e994ffc49a94960691c76bff97cb04d5", "commitAfterChange": "719705b20dc5e72fab3b2b50b669f9dfc58049aa", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t \tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "signatureAfterChange": " \t \tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "diff": ["-\t\t/* 15.12.2.5 s is more specific than t iff ... Some of the checks here are redundant by the very fact of control reaching here, ", "-\t\t   but have been left in for completeness/documentation sakes. These should be cheap anyways. ", "-\t\t*/", "-\t\t// Both t and s are functional interface types ... ", "+\t\t// 15.12.2.5 ", "+\t\t", "+\t\tif (TypeBinding.equalsEquals(s,  t))", "+\t\t\treturn true;", "+\t\t", "+\t\tif (argumentsTypeElided() || t.findSuperTypeOriginatingFrom(s) != null)", "+\t\t\treturn false;", "+\t\t", "+\t\ts = s.capture(this.enclosingScope, this.sourceEnd);", "+\t\tTypeBinding r1 = sSam.returnType;", "+\t\tTypeBinding r2 = tSam.returnType;", "-\t\t// t should neither be a subinterface nor a superinterface of s", "-\t\tif (s.findSuperTypeOriginatingFrom(t) != null || t.findSuperTypeOriginatingFrom(s) != null)", "-\t\t\treturn false;", "-", "-\t\t// If the lambda expression's parameters have inferred types, then the descriptor parameter types of t are the same as the descriptor parameter types of s.", "-\t\tif (argumentsTypeElided()) {", "-\t\t\tif (sSam.parameters.length != tSam.parameters.length)", "-\t\t\t\treturn false;", "-\t\t\tfor (int i = 0, length = sSam.parameters.length; i < length; i++) {", "-\t\t\t\tif (TypeBinding.notEquals(sSam.parameters[i], tSam.parameters[i]))", "-\t\t\t\t\treturn false;", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// either the descriptor return type of s is void or ...", "-\t\tif (tSam.returnType.id == TypeIds.T_void)", "+\t\tif (r2.id == TypeIds.T_void)", "-\t\t/* ... or for all result expressions in the lambda body (or for the body itself if the body is an expression), ", "-           the descriptor return type of the capture of T is more specific than the descriptor return type of S.", "-\t\t*/", "+\t\tif (r1.id == TypeIds.T_void)", "+\t\t\treturn false;", "+\t\t", "+\t\tif (r1.findSuperTypeOriginatingFrom(r2) != null)", "+\t\t\treturn true;", "+\t\t", "-\t\tif (returnExpressionsLength == 0)", "-\t\t\treturn true; // as good as or as bad as false.", "-\t\ts = s.capture(this.enclosingScope, this.sourceEnd);", "+\t\t// r1 is a primitive type, r2 is a reference type, and each result expression is a standalone expression (15.2) of a primitive type", "+\t\tif (r1.isBaseType() && !r2.isBaseType()) {", "+\t\t\tfor (int i = 0; i < returnExpressionsLength; i++) {", "+\t\t\t\tif (returnExpressions[i].isPolyExpression() || !returnExpressions[i].resolvedType.isBaseType())", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\treturn true;", "+\t\t}", "+\t\tif (returnExpressionsLength == 0)", "+\t\t\treturn false;", "+\t\t", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b35c23781e96031a681e219dc8e0c987", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "3aabc067e22084d59ef0ea59b0d58e1085dede4c", "commitAfterChange": "b7295bb19a68269f09e5fdceeecf4f4c701e7063", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "signatureAfterChange": " \t \tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "diff": ["+\t", "-\t\t/* 15.12.2.5 t is more specific than s iff ... Some of the checks here are redundant by the very fact of control reaching here, ", "-\t\t   but have been left in for completeness/documentation sakes. These should be cheap anyways. ", "-\t\t*/", "-\t\t// Both t and s are functional interface types ... ", "+\t\tif (TypeBinding.equalsEquals(s, t))", "+\t\t\treturn true;", "+\t\t", "+\t\tif (this.exactMethodBinding == null)", "+\t\t\treturn false;", "+\t\t", "+\t\ts = s.capture(this.enclosingScope, this.sourceEnd);", "+\t\tTypeBinding r1 = sSam.returnType;", "+\t\t", "+\t\tTypeBinding r2 = tSam.returnType;", "-\t\t// t should neither be a subinterface nor a superinterface of s", "-\t\tif (s.findSuperTypeOriginatingFrom(t) != null || t.findSuperTypeOriginatingFrom(s) != null)", "-\t\t\treturn false;", "-", "-\t\t// The descriptor parameter types of t are the same as the descriptor parameter types of s.", "-\t\tif (sSam.parameters.length != tSam.parameters.length)", "-\t\t\treturn false;", "-\t\tfor (int i = 0, length = sSam.parameters.length; i < length; i++) {", "-\t\t\tif (TypeBinding.notEquals(sSam.parameters[i], tSam.parameters[i]))", "-\t\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\t// Either the descriptor return type of s is void or ...", "-\t\tif (tSam.returnType.id == TypeIds.T_void)", "+\t\tif (r2.id == TypeIds.T_void)", "+\t\tif (r1.id == TypeIds.T_void)", "+\t\t\treturn false;", "-\t\treturn true;", "+\t\tif (r1.findSuperTypeOriginatingFrom(r2) != null)", "+\t\t\treturn true;", "+\t\tif (r2.findSuperTypeOriginatingFrom(r1) != null)", "+\t\t\treturn false;", "-\t\t/* ... or the descriptor return type of the capture of T is more specific than the descriptor return type of S for ", "-\t\t   an invocation expression of the same form as the method reference..", "-\t\t*/", "-\t//\tExpression resultExpression = (Expression) this.resultExpressions.get(s); // should be same as for s", "-\t\t", "-//\t\ts = s.capture(this.enclosingScope, this.sourceEnd);", "-//\t\tsSam = s.getSingleAbstractMethod(this.enclosingScope);", "-//\t\treturn resultExpression.sIsMoreSpecific(sSam.returnType, tSam.returnType);", "+\t\treturn r1.isBaseType() != r2.isBaseType() && r1.isBaseType() == this.exactMethodBinding.returnType.isBaseType();"]}], "num": 10017}