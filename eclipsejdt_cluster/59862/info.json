{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "358575cf4acd7abba7ab1107caaa5aab", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f41acc6994cdef9cfc92f8a47aa6980", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java", "commitBeforeChange": "83dc88df7a1508be17b764df4120ac8a34178f58", "commitAfterChange": "f428b70bc80bfdae47260a00a8636113b21b698c", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void collectSubstitutes(Scope scope, TypeBinding actualType, InferenceContext inferenceContext, int constraint)", "signatureAfterChange": " \tpublic void collectSubstitutes(Scope scope, TypeBinding actualType, InferenceContext inferenceContext, int constraint)", "diff": ["-//\t\t\t\t\t\tif (otherType.isWildcard()) {", "-//\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "-//\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+//\t\t\t\t\t\tswitch (actualType.kind()) {", "+//\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+//\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "+//\t\t\t\t\t\t\tswitch(actualWildcard.kind) {", "-//\t\t\t\t\t\t} else { // A=V << F={?} ---> 0", "-//\t\t\t\t\t\t}", "+//\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\tcase Binding.INTERSECTION_TYPE :// A={? extends V1&...&Vn} << F={?} ---> 0", "+//\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\tdefault :// A=V << F={?} ---> 0", "+//\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\t\tif (actualType.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "-\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} << F={? extends U}  --> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} << F={? extends U} ---> V << U", "-\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "-\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "-\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "-\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} << F={? extends U} ---> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else { // A=V << F={? extends U} ---> V << U", "-\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualType, inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "+\t\t\t\t\t\tswitch(actualType.kind()) {", "+\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "+\t\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "+\t\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} << F={? extends U}  --> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} << F={? extends U} ---> V << U", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} << F={? extends U} ---> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Binding.INTERSECTION_TYPE : // A={? extends V1&...&Vn} << F={? extends U} ---> V1 << U, ..., Vn << U", "+\t\t\t\t\t\t\t\tWildcardBinding actualIntersection = (WildcardBinding) actualType;", "+\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualIntersection.bound, inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "+\t\t\t\t\t        \tfor (int i = 0, length = actualIntersection.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualIntersection.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "+\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault : // A=V << F={? extends U} ---> V << U", "+\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualType, inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "+\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tif (actualType.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "-\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} << F={? super U}  --> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} << F={? super U} ---> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} << F={? super U} ---> 0", "-\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "-\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else { // A=V << F={? super U} ---> V >> U", "-\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualType, inferenceContext, TypeConstants.CONSTRAINT_SUPER);\t\t\t\t\t\t\t", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t\tswitch (actualType.kind()) {", "+\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "+\t\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "+\t\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} << F={? super U}  --> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} << F={? super U} ---> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} << F={? super U} ---> 0", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Binding.INTERSECTION_TYPE : // A={? extends V1&...&Vn} << F={? super U} ---> 0", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault :// A=V << F={? super U} ---> V >> U", "+\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualType, inferenceContext, TypeConstants.CONSTRAINT_SUPER);\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "-//\t\t\t\t\t\tif (otherType.isWildcard()) {", "-//\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "-//\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+//\t\t\t\t\t\tswitch (actualType.kind()) {", "+//\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+//\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "+//\t\t\t\t\t\t\tswitch(actualWildcard.kind) {", "-//\t\t\t\t\t\t} else { // A=V == F={?} ---> 0", "-//\t\t\t\t\t\t}", "+//\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\tcase Binding.INTERSECTION_TYPE :// A={? extends V1&...&Vn} == F={?} ---> 0", "+//\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\tdefault :// A=V == F={?} ---> 0", "+//\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t}\t\t", "-\t\t\t\t\t\tif (actualType.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "-\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} == F={? extends U}  --> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} == F={? extends U} ---> V == U", "-\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_EQUAL);", "-\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "-\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_EQUAL);", "-\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} == F={? extends U} ---> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else { // A=V == F={? extends U} ---> 0", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tswitch (actualType.kind()) {", "+\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "+\t\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "+\t\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} == F={? extends U}  --> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} == F={? extends U} ---> V == U", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_EQUAL);", "+\t\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_EQUAL);", "+\t\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} == F={? extends U} ---> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Binding.INTERSECTION_TYPE : // A={? extends V1&...&Vn} == F={? extends U} ---> V1 == U, ..., Vn == U", "+\t\t\t\t\t\t\t\tWildcardBinding actuaIntersection = (WildcardBinding) actualType;", "+\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actuaIntersection.bound, inferenceContext, TypeConstants.CONSTRAINT_EQUAL);", "+\t\t\t\t\t        \tfor (int i = 0, length = actuaIntersection.otherBounds == null ? 0 : actuaIntersection.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actuaIntersection.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_EQUAL);", "+\t\t\t\t\t        \t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault : // A=V == F={? extends U} ---> 0", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\t\tif (actualType.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "-\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} == F={? super U}  --> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} == F={? super U} ---> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} == F={? super U} ---> 0", "-\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_EQUAL);", "-\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "-\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_EQUAL);", "-\t\t\t\t\t\t        \t}\t", "-\t\t\t\t\t\t        \tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else { // A=V == F={? super U} ---> 0", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t\tswitch (actualType.kind()) {", "+\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "+\t\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "+\t\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} == F={? super U}  --> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} == F={? super U} ---> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} == F={? super U} ---> 0", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_EQUAL);", "+\t\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_EQUAL);", "+\t\t\t\t\t\t\t        \t}\t", "+\t\t\t\t\t\t\t        \tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Binding.INTERSECTION_TYPE :  // A={? extends V1&...&Vn} == F={? super U} ---> 0", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault : // A=V == F={? super U} ---> 0", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}\t\t\t\t\t\t\t\t", "-//\t\t\t\t\t\tif (otherType.isWildcard()) {", "-//\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "-//\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+//\t\t\t\t\t\tswitch (actualType.kind()) {", "+//\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+//\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "+//\t\t\t\t\t\t\tswitch(actualWildcard.kind) {", "-//\t\t\t\t\t\t} else { // A=V >> F={?} ---> 0", "-//\t\t\t\t\t\t}", "+//\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\tcase Binding.INTERSECTION_TYPE :// A={? extends V1&...&Vn} >> F={?} ---> 0", "+//\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\tdefault :// A=V >> F={?} ---> 0", "+//\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t}\t\t", "-\t\t\t\t\t\tif (actualType.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "-\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} >> F={? extends U}  --> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} >> F={? extends U} ---> V >> U", "-\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "-\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} >> F={? extends U} ---> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else { // A=V == F={? extends U} ---> 0", "+\t\t\t\t\t\tswitch (actualType.kind()) {", "+\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "+\t\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "+\t\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} >> F={? extends U}  --> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} >> F={? extends U} ---> V >> U", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} >> F={? extends U} ---> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Binding.INTERSECTION_TYPE : // A={? extends V1&...&Vn} >> F={? extends U} ---> V1 >> U, ..., Vn >> U", "+\t\t\t\t\t\t\t\tWildcardBinding actualIntersection = (WildcardBinding) actualType;", "+\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualIntersection.bound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t\t\t\t        \tfor (int i = 0, length = actualIntersection.otherBounds == null ? 0 : actualIntersection.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualIntersection.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault : // A=V == F={? extends U} ---> 0", "+\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tif (actualType.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "-\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} >> F={? super U}  --> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} >> F={? super U} ---> 0", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} >> F={? super U} ---> V >> U", "-\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "-\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t\t\t\t        \t}\t", "-\t\t\t\t\t\t        \tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else { // A=V >> F={? super U} ---> 0", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t\tswitch (actualType.kind()) {", "+\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\t\t\t\tWildcardBinding actualWildcard = (WildcardBinding) actualType;", "+\t\t\t\t\t\t\t\tswitch(actualWildcard.boundKind) {", "+\t\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} >> F={? super U}  --> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} >> F={? super U} ---> 0", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} >> F={? super U} ---> V >> U", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.bound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t\t\t\t\t\t        \tfor (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t\t\t\t\t\t        \t}\t", "+\t\t\t\t\t\t\t        \tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Binding.INTERSECTION_TYPE :  // A={? extends V1&...&Vn} >> F={? super U} ---> 0", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault : // A=V >> F={? super U} ---> 0", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6c28ca8c9ba920259e39d0a30931f229", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java", "commitBeforeChange": "1146476ca138da09c36a16ea64250a150f60b014", "commitAfterChange": "e3d3c02cc33fd5166184422215f4903c5a405e0f", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 15, "signatureBeforeChange": "  private void createFolder(IContainer folder) throws CoreException", "signatureAfterChange": "  private boolean hasClasspathChanged()", "diff": ["-private void createFolder(IContainer folder) throws CoreException {", "-\tif (!folder.exists()) {", "-\t\tIContainer parent = folder.getParent();", "-\t\tif (currentProject.getFullPath() != parent.getFullPath())", "-\t\t\tcreateFolder(parent);", "-\t\t((IFolder) folder).create(true, true, null);", "-\t}", "-}", "+\tClasspathMultiDirectory[] newSourceLocations = nameEnvironment.sourceLocations;", "+\tClasspathMultiDirectory[] oldSourceLocations = lastState.sourceLocations;", "+\tint newLength = newSourceLocations.length;", "+\tint oldLength = oldSourceLocations.length;", "+\tint n = 0, o = 0;", "+\tfor (; n < newLength && o < oldLength; n++, o++) {", "+\t\tif (newSourceLocations[n].equals(oldSourceLocations[o])) continue; // checks source & output folders", "+\t\ttry {", "+\t\t\tif (newSourceLocations[n].sourceFolder.members().length == 0) { // added new empty source folder", "+\t\t} catch (CoreException ignore) {}", "+\t\tif (DEBUG)", "+\t\t\tSystem.out.println(newSourceLocations[n] + \" != \" + oldSourceLocations[o]); //$NON-NLS-1$", "+\t\treturn true;", "+\t}", "+\twhile (n < newLength) {", "+\t\ttry {", "+\t\t\tif (newSourceLocations[n].sourceFolder.members().length == 0) { // added new empty source folder", "+\t\t\t\tn++;", "+\t\t\t\tcontinue;", "+\t\t} catch (CoreException ignore) {}", "+\t\tif (DEBUG)", "+\t\t\tSystem.out.println(\"Added non-empty source folder\"); //$NON-NLS-1$", "+\t\treturn true;", "+\t}", "+\tif (o < oldLength) {", "+\t\tif (DEBUG)", "+\t\t\tSystem.out.println(\"Removed source folder\"); //$NON-NLS-1$", "+\t\treturn true;", "+\tClasspathLocation[] newBinaryLocations = nameEnvironment.binaryLocations;", "+\tClasspathLocation[] oldBinaryLocations = lastState.binaryLocations;", "+\tnewLength = newBinaryLocations.length;", "+\toldLength = oldBinaryLocations.length;", "+\tn = o = 0;", "+\tfor (; n < newLength && o < oldLength; n++, o++) {", "+\t\tif (newBinaryLocations[n].equals(oldBinaryLocations[o])) continue;", "+\t\tif (DEBUG)", "+\t\t\tSystem.out.println(newBinaryLocations[n] + \" != \" + oldBinaryLocations[o]); //$NON-NLS-1$", "+\t\treturn true;", "+\t}", "+\tif (n < newLength || o < oldLength) {", "+\t\tif (DEBUG)", "+\t\t\tSystem.out.println(\"Binary folders/jar files size changed\"); //$NON-NLS-1$", "+\t\treturn true;", "+\t}", "+\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c4b518e9e4e9e68c6b5cfd9d67be52a7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "f0cc0529135fe43e5b6252dca937651f0a04d49c", "commitAfterChange": "79c1182746ff2f44f9956aeaf2f61882a4911acb", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 30, "signatureBeforeChange": " \tprivate static int[] getWildcardLocations(TypeReference reference, Wildcard wildcard)", "signatureAfterChange": " \t \tpublic int generateTypeAnnotationsOnCodeAttribute()", "diff": ["-\t */", "-\tprivate static int[] getWildcardLocations(TypeReference reference, Wildcard wildcard) {", "-\t\tclass LocationCollector extends ASTVisitor {", "-\t\t\tStack currentIndexes;", "-\t\t\tboolean search = true;", "-\t\t\tWildcard currentWildcard;", "-\t\t\t", "-\t\t\tpublic LocationCollector(Wildcard currentWildcard) {", "-\t\t\t\tthis.currentIndexes = new Stack();", "-\t\t\t\tthis.currentWildcard = currentWildcard;", "-\t\t\t}", "-\t\t\tpublic boolean visit(ParameterizedSingleTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\tTypeReference[] typeReferences = typeReference.typeArguments;", "-\t\t\t\tthis.currentIndexes.push(new Integer(0));", "-\t\t\t\tfor (int i = 0, max = typeReferences.length; i < max; i++) {", "-\t\t\t\t\ttypeReferences[i].traverse(this, scope);", "-\t\t\t\t\tif (!this.search) return false;", "-\t\t\t\t\tthis.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));", "-\t\t\t\t}", "-\t\t\t\tthis.currentIndexes.pop();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\tTypeReference[] typeReferences = typeReference.typeArguments[typeReference.typeArguments.length - 1];", "-\t\t\t\tthis.currentIndexes.push(new Integer(0));", "-\t\t\t\tfor (int i = 0, max = typeReferences.length; i < max; i++) {", "-\t\t\t\t\ttypeReferences[i].traverse(this, scope);", "-\t\t\t\t\tif (!this.search) return false;", "-\t\t\t\t\tthis.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));", "-\t\t\t\t}", "-\t\t\t\tthis.currentIndexes.pop();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic boolean visit(Wildcard typeReference, BlockScope scope) {", "-\t\t\t\tif (!this.search) return false;", "-\t\t\t\tif (typeReference.equals(this.currentWildcard)) {", "-\t\t\t\t\tthis.search = false;", "-\t\t\t\t}", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic String toString() {", "-\t\t\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\t\tbuffer", "-\t\t\t\t\t.append(\"search location for \") //$NON-NLS-1$", "-\t\t\t\t\t.append(this.currentWildcard)", "-\t\t\t\t\t.append(\"\\ncurrent indexes : \") //$NON-NLS-1$", "-\t\t\t\t\t.append(this.currentIndexes);", "-\t\t\t\treturn String.valueOf(buffer);", "-\t\t\t}", "-\t\t}", "-\t\tif (reference == null) return null;", "-\t\tLocationCollector collector = new LocationCollector(wildcard);", "-\t\treference.traverse(collector, (BlockScope) null);", "-\t\tif (collector.currentIndexes.isEmpty()) {", "-\t\t\treturn null;", "-\t\t}", "-\t\tint size = collector.currentIndexes.size();", "-\t\tint[] result = new int[size];", "-\t\tfor (int i = 0; i < size; i++) {", "-\t\t\tresult[size - i - 1] = ((Integer) collector.currentIndexes.pop()).intValue();", "-\t\t}", "-\t\treturn result;", "-\t}", "+\t", "+\tpublic int generateTypeAnnotationsOnCodeAttribute() {", "+\t\tint attributesNumber = 0;", "+\t\t", "+\t\tList allTypeAnnotationContexts = ((TypeAnnotationCodeStream) this.codeStream).allTypeAnnotationContexts;", "+\t\tint invisibleTypeAnnotationsCounter = 0;", "+\t\tint visibleTypeAnnotationsCounter = 0;", "+", "+\t\tfor (int i = 0, max = this.codeStream.allLocalsCounter; i < max; i++) {", "+\t\t\tLocalVariableBinding localVariable = this.codeStream.locals[i];", "+\t\t\tif (localVariable.isCatchParameter()) continue;", "+\t\t\tLocalDeclaration declaration = localVariable.declaration;", "+\t\t\tif (declaration == null", "+\t\t\t\t\t|| (declaration.isArgument() && ((declaration.bits & ASTNode.IsUnionType) == 0))", "+\t\t\t\t\t|| (localVariable.initializationCount == 0)", "+\t\t\t\t\t|| ((declaration.bits & ASTNode.HasTypeAnnotations) == 0)) {", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tint targetType = ((localVariable.tagBits & TagBits.IsResource) == 0) ? AnnotationTargetTypeConstants.LOCAL_VARIABLE : AnnotationTargetTypeConstants.RESOURCE_VARIABLE;", "+\t\t\tdeclaration.getAllAnnotationContexts(targetType, localVariable, allTypeAnnotationContexts);", "+\t\t}", "+\t\t", "+\t\tExceptionLabel[] exceptionLabels = this.codeStream.exceptionLabels;", "+\t\tint tableIndex = 0;", "+\t\tfor (int i = 0, max = this.codeStream.exceptionLabelsCounter; i < max; i++) {", "+\t\t\tExceptionLabel exceptionLabel = exceptionLabels[i];", "+\t\t\tif (exceptionLabel instanceof MultiCatchExceptionLabel) {", "+\t\t\t\tMultiCatchExceptionLabel multiCatchExceptionLabel = (MultiCatchExceptionLabel)exceptionLabel;", "+\t\t\t\ttableIndex += multiCatchExceptionLabel.getAllAnnotationContexts(tableIndex, allTypeAnnotationContexts);", "+\t\t\t} else {", "+\t\t\t\tif (exceptionLabel.exceptionTypeReference != null) { // ignore those which cannot be annotated", "+\t\t\t\t\texceptionLabel.exceptionTypeReference.getAllAnnotationContexts(AnnotationTargetTypeConstants.EXCEPTION_PARAMETER, tableIndex, allTypeAnnotationContexts);", "+\t\t\t\t}", "+\t\t\t\ttableIndex++;", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\tint size = allTypeAnnotationContexts.size();", "+\t\tif (size != 0) {", "+\t\t\tAnnotationContext[] allTypeAnnotationContextsArray = new AnnotationContext[size];", "+\t\t\tallTypeAnnotationContexts.toArray(allTypeAnnotationContextsArray);", "+\t\t\tfor (int j = 0, max2 = allTypeAnnotationContextsArray.length; j < max2; j++) {", "+\t\t\t\tAnnotationContext annotationContext = allTypeAnnotationContextsArray[j];", "+\t\t\t\tif ((annotationContext.visibility & AnnotationContext.INVISIBLE) != 0) {", "+\t\t\t\t\tinvisibleTypeAnnotationsCounter++;", "+\t\t\t\t} else {", "+\t\t\t\t\tvisibleTypeAnnotationsCounter++;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tattributesNumber += generateRuntimeTypeAnnotations(", "+\t\t\t\t\tallTypeAnnotationContextsArray,", "+\t\t\t\t\tvisibleTypeAnnotationsCounter,", "+\t\t\t\t\tinvisibleTypeAnnotationsCounter);", "+\t\t}", "+\t\treturn attributesNumber;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1b28196f14a4ae010608d0cf0f72758", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticMethodBinding.java", "commitBeforeChange": "99a320ba218a453cde9430d003d516f8202cd4ca", "commitAfterChange": "bc5d9b450540dde0f4417c6b10a04ec18aa90f94", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic SyntheticMethodBinding(MethodBinding targetMethod, boolean isSuperAccess, ReferenceBinding receiverType)", "signatureAfterChange": "  \tpublic SyntheticMethodBinding(FieldBinding targetField, ReferenceBinding declaringClass, TypeBinding enumBinding, char[] selector)", "diff": ["+\tpublic SyntheticMethodBinding(FieldBinding targetField, ReferenceBinding declaringClass, TypeBinding enumBinding, char[] selector) {", "+\t\tthis.modifiers = AccDefault | AccStatic | AccSynthetic;", "+\t\tthis.tagBits |= TagBits.AnnotationResolved;", "+\t\tSourceTypeBinding declaringSourceType = (SourceTypeBinding) declaringClass;", "+\t\tSyntheticMethodBinding[] knownAccessMethods = declaringSourceType.syntheticMethods();", "+\t\tint methodId = knownAccessMethods == null ? 0 : knownAccessMethods.length;", "+\t\tthis.index = methodId;", "+\t\tthis.selector = selector;", "+\t\tthis.returnType = declaringSourceType.scope.createArrayType(BaseTypes.IntBinding, 1);", "+\t\tthis.parameters = NoParameters;", "+\t\tthis.targetReadField = targetField;", "+\t\tthis.targetEnumType = enumBinding;", "+\t\tthis.kind = SwitchTable;", "+\t\tthis.thrownExceptions = NoExceptions;", "+\t\tthis.declaringClass = declaringSourceType;", "+  ", "+\t\tif (declaringSourceType.isStrictfp()) {", "+\t\t\tthis.modifiers |= AccStrictfp;", "+\t\t}", "+\t\t// check for method collision", "+\t\tboolean needRename;", "+\t\tdo {", "+\t\t\tcheck : {", "+\t\t\t\tneedRename = false;", "+\t\t\t\t// check for collision with known methods", "+\t\t\t\tMethodBinding[] methods = declaringSourceType.methods;", "+\t\t\t\tfor (int i = 0, length = methods.length; i < length; i++) {", "+\t\t\t\t\tif (CharOperation.equals(this.selector, methods[i].selector) && this.areParametersEqual(methods[i])) {", "+\t\t\t\t\t\tneedRename = true;", "+\t\t\t\t\t\tbreak check;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// check for collision with synthetic accessors", "+\t\t\t\tif (knownAccessMethods != null) {", "+\t\t\t\t\tfor (int i = 0, length = knownAccessMethods.length; i < length; i++) {", "+\t\t\t\t\t\tif (knownAccessMethods[i] == null) continue;", "+\t\t\t\t\t\tif (CharOperation.equals(this.selector, knownAccessMethods[i].selector) && this.areParametersEqual(methods[i])) {", "+\t\t\t\t\t\t\tneedRename = true;", "+\t\t\t\t\t\t\tbreak check;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (needRename) { // retry with a selector postfixed by a growing methodId", "+\t\t\t\tthis.setSelector(CharOperation.concat(selector, String.valueOf(++methodId).toCharArray()));", "+\t\t\t}", "+\t\t} while (needRename);", "+", "+\t\t// We now at this point - per construction - it is for sure an enclosing instance, we are going to", "+\t\t// show the target field type declaration location.", "+\t\tthis.sourceStart = declaringSourceType.scope.referenceContext.sourceStart; // use the target declaring class name position instead", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e6e447d7d7e87ab5377a1694fb25afbf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "5a243353f41a52ea072e05a758d642d784b6e03c", "commitAfterChange": "bf7283aec4274d8cf1ac48f5497946a29ebdedf2", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tprivate void disassemble(IClassFileReader classFileReader, char[] className, IMethodInfo methodInfo, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "signatureAfterChange": " \tprivate void disassemble(IClassFileReader classFileReader, char[] className, IMethodInfo methodInfo, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "diff": ["+\t\tchar[] methodHeader = null;", "-\t\t\t\tbuffer.append(Signature.toCharArray(signature, returnClassName(className, '.', COMPACT), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), false, isVarArgs));", "+\t\t\t\tmethodHeader = Signature.toCharArray(signature, returnClassName(className, '.', COMPACT), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), false, isVarArgs);", "-\t\t\t\tbuffer.append(Signature.toCharArray(methodDescriptor, returnClassName(className, '.', COMPACT), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), false, isVarArgs));", "+\t\t\t\tmethodHeader = Signature.toCharArray(methodDescriptor, returnClassName(className, '.', COMPACT), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), false, isVarArgs);", "-\t\t\tbuffer.append(Messages.bind(Messages.classfileformat_clinitname));", "+\t\t\tmethodHeader = Messages.bind(Messages.classfileformat_clinitname).toCharArray();", "-\t\t\t\tbuffer.append(Signature.toCharArray(signature, methodInfo.getName(), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), true, isVarArgs));", "+\t\t\t\tmethodHeader = Signature.toCharArray(signature, methodInfo.getName(), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), true, isVarArgs);", "-\t\t\t\tbuffer.append(Signature.toCharArray(methodDescriptor, methodInfo.getName(), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), true, isVarArgs));", "+\t\t\t\tmethodHeader = Signature.toCharArray(methodDescriptor, methodInfo.getName(), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), true, isVarArgs);", "+\t\t}", "+\t\tif (checkMode(mode, DETAILED) && (runtimeInvisibleParameterAnnotationsAttribute != null || runtimeVisibleParameterAnnotationsAttribute != null)) {", "+\t\t\tIParameterAnnotation[] invisibleParameterAnnotations = null;", "+\t\t\tIParameterAnnotation[] visibleParameterAnnotations = null;", "+\t\t\tint length = -1;", "+\t\t\tif (runtimeInvisibleParameterAnnotationsAttribute != null) {", "+\t\t\t\tIRuntimeInvisibleParameterAnnotationsAttribute attribute = (IRuntimeInvisibleParameterAnnotationsAttribute) runtimeInvisibleParameterAnnotationsAttribute;", "+\t\t\t\tinvisibleParameterAnnotations = attribute.getParameterAnnotations();", "+\t\t\t\tlength = invisibleParameterAnnotations.length;", "+\t\t\t}", "+\t\t\tif (runtimeVisibleParameterAnnotationsAttribute != null) {", "+\t\t\t\tIRuntimeVisibleParameterAnnotationsAttribute attribute = (IRuntimeVisibleParameterAnnotationsAttribute) runtimeVisibleParameterAnnotationsAttribute;", "+\t\t\t\tvisibleParameterAnnotations = attribute.getParameterAnnotations();", "+\t\t\t\tlength = visibleParameterAnnotations.length;", "+\t\t\t}", "+\t\t\tint insertionPosition = CharOperation.indexOf('(', methodHeader) + 1;", "+\t\t\tint start = 0;", "+\t\t\tStringBuffer stringBuffer = new StringBuffer();", "+\t\t\tstringBuffer.append(methodHeader, 0, insertionPosition);", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tif (i > 0) {", "+\t\t\t\t\tstringBuffer.append(' ');", "+\t\t\t\t}", "+\t\t\t\tint stringBufferSize = stringBuffer.length();", "+\t\t\t\tif (runtimeVisibleParameterAnnotationsAttribute != null) {", "+\t\t\t\t\tdisassembleAsModifier((IRuntimeVisibleParameterAnnotationsAttribute) runtimeVisibleParameterAnnotationsAttribute, stringBuffer, i, lineSeparator, tabNumber, mode);", "+\t\t\t\t}", "+\t\t\t\tif (runtimeInvisibleParameterAnnotationsAttribute != null) {", "+\t\t\t\t\tif (stringBuffer.length() != stringBufferSize) {", "+\t\t\t\t\t\tstringBuffer.append(' ');", "+\t\t\t\t\t\tstringBufferSize = stringBuffer.length();", "+\t\t\t\t\t}", "+\t\t\t\t\tdisassembleAsModifier((IRuntimeInvisibleParameterAnnotationsAttribute) runtimeInvisibleParameterAnnotationsAttribute, stringBuffer, i, lineSeparator, tabNumber, mode);", "+\t\t\t\t}", "+\t\t\t\tif (i == 0 && stringBuffer.length() != stringBufferSize) {", "+\t\t\t\t\tstringBuffer.append(' ');", "+\t\t\t\t}", "+\t\t\t\tstart = insertionPosition;", "+\t\t\t\tinsertionPosition = CharOperation.indexOf(',', methodHeader, start + 1) + 1;", "+\t\t\t\tif (insertionPosition == 0) {", "+\t\t\t\t\tstringBuffer.append(methodHeader, start, methodHeader.length - start);", "+\t\t\t\t} else {", "+\t\t\t\t\tstringBuffer.append(methodHeader, start, insertionPosition - start);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbuffer.append(stringBuffer);", "+\t\t} else {", "+\t\t\tbuffer.append(methodHeader);"]}], "num": 59862}