{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "62e613f4f9a0dab9bf8ea2a1ad79f6bb", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2208c739f80c67122e6d6cc429ee9e9e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "702c62fec0923d7526ca23efea5c1bb4f5a2ef27", "commitAfterChange": "48a78bfcb529886e24e5f62b1bc56f7d3678e46a", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "signatureAfterChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "diff": ["-\t\t\tcopy = cachedResolvedCopy(targetType, false);", "+\t\t\tcopy = cachedResolvedCopy(targetType, false, true);", "-\t\t}", "-\t\tif (copy == null) {", "-\t\t\treturn null;", "-\t\t}", "-\t\t", "-\t\t/* copy is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and ", "-\t\t   result expressions have been gathered. Proceed with flow analysis to gather precise thrown exceptions. However, we can do this only", "-\t\t   if resolve encountered no errors - if it did, we will miss precise exceptions, but that is OK.", "-\t\t*/", "-\t\tif (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {", "-\t\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "-\t\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "-\t\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "-\t\t\ttry {", "-\t\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "-\t\t\t\tcopy.analyzeExceptions();", "-\t\t\t} finally {", "-\t\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;", "-\t\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "582bdbd7bd49448e2f5f663036c5b3dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "72398fb1bfc9de8f8d1c235c08849e28d61cb9f4", "commitAfterChange": "a52f17f8883dd812875c341ff752527a9011d961", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(TypeBinding targetType, final Scope skope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(TypeBinding targetType, final Scope skope)", "diff": ["-\t\t\tcopy = cachedResolvedCopy(targetType, argumentsTypeElided()); // if argument types are elided, we don't care for result expressions against *this* target, any port in a storm is ok.", "+\t\t\tcopy = cachedResolvedCopy(targetType, argumentsTypeElided()); // if argument types are elided, we don't care for result expressions against *this* target, any valid target is OK.", "-\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "-\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "-\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "-\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "-\t\ttry {", "-\t\t\t/* At this point, shape analysis is complete for ((see returnsExpression(...))", "-\t\t\t       - a lambda with an expression body,", "-\t\t\t\t   - a lambda with a block body in which we saw a return statement naked or otherwise.", "-\t\t\t*/", "-\t\t\tif (copy.body instanceof Block && !copy.returnsVoid && !copy.returnsValue && !copy.valueCompatible) {", "-\t\t\t\t// Do not proceed with data/control flow analysis if resolve encountered errors.", "-\t\t\t\tif (copy.hasIgnoredMandatoryErrors || enclosingScopesHaveErrors()) {", "-\t\t\t\t\tif (isPertinentToApplicability(targetType, null))", "-\t\t\t\t\t\tif (copy.arguments.length != 0) // ?? Needs check. ", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t} else {", "-\t\t\t\t\tcopy.valueCompatible = copy.doesNotCompleteNormally();", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} finally {", "-\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;", "-\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t\t}", "-", "+\t\t// copy here is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and result expressions have been gathered."]}], "num": 21701}