{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4c0abaa7fd5649af0656fd33aadd973d", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "003a0a58aea26ea8d88169f24e75a7fe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/AdvancedFactoryPathOptionsDialog.java", "commitBeforeChange": "3973964fa15a8c49d459282ce0d949753f7e2224", "commitAfterChange": "be99a78ebde70e086535a722e0c99b2c26590dce", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tprotected Control createDialogArea(Composite parent)", "signatureAfterChange": "      \tprotected Control createDialogArea(Composite parent)", "diff": ["+    ", "+\tprotected Control createDialogArea(Composite parent) {", "+\t\tComposite dlgArea= (Composite) super.createDialogArea(parent);", "+\t\t// Set up \"batch mode\" checkbox.", "-", "-\tprotected Control createDialogArea(Composite parent) {", "-\t\tComposite composite= (Composite) super.createDialogArea(parent);", "-\t\t", "-\t\tComposite inner= new Composite(composite, SWT.NONE);", "-\t\tGridLayout layout= new GridLayout();", "-\t\tlayout.marginHeight= 0;", "-\t\tlayout.marginWidth= 0;", "-\t\tlayout.numColumns= 2;", "-\t\tinner.setLayout(layout);", "-\t\t", "-\t\t_batchModeField.doFillIntoGrid(inner, 2);", "-\t\t", "-\t\t// Plugins can't run in APT compatibility mode.", "+\t\t_batchModeField.doFillIntoGrid(dlgArea, 2);", "+\t\t\t// Plugins can't run in APT compatibility mode.", "-\t\tapplyDialogFont(composite);\t\t", "-\t\treturn composite;", "+\t\tDialogField.createEmptySpace(dlgArea, 1);", "+", "+\t\t// Set up label for processor contents list", "+\t\tLabel description= new Label(dlgArea, SWT.WRAP);", "+\t\tdescription.setText(Messages.AdvancedFactoryPathOptionsDialog_label_processorsInThisContainer); ", "+\t\tGridData gdLabel= new GridData(GridData.HORIZONTAL_ALIGN_FILL);", "+\t\tgdLabel.horizontalSpan= 2;", "+\t\tdescription.setLayoutData(gdLabel);", "+", "+\t\t// Set up processor contents list", "+\t\t_contentsField= new ListViewer(dlgArea, SWT.SINGLE | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);", "+        GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);", "+        data.heightHint = convertHeightInCharsToPixels(LIST_HEIGHT);", "+        data.widthHint = convertWidthInCharsToPixels(LIST_WIDTH);", "+        _contentsField.getList().setLayoutData(data);", "+        _contentsField.getList().setFont(parent.getFont());", "+        try {", "+\t        for (String name : _fc.getFactoryNames()) {", "+\t        \t_contentsField.add(name);", "+\t        }", "+        }", "+        catch (IOException e) {", "+\t\t\tfinal String message = \"Unable to load factory names from container [\" + _fc.getId() + \"]\"; //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\tExceptionHandler.log(e, message);", "+        }", "+        _contentsField.setSelection(null, false);", "+        ", "+\t\tapplyDialogFont(dlgArea);\t\t", "+\t\treturn dlgArea;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "018be990e50564bc7a28d2d6c01e20cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceTests.java", "commitBeforeChange": "5281f7a1d02f4134760334f239cbffb833f0ed1c", "commitAfterChange": "b8222e0e4564cc4472bb2fdfd410e7de68bbf0fa", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 28, "signatureBeforeChange": " \tprotected int startBuild(Hashtable options) throws IOException, CoreException", "signatureAfterChange": " \tprotected void startBuild(Hashtable options, boolean noWarning) throws IOException, CoreException", "diff": ["-\tprotected int startBuild(Hashtable options) throws IOException, CoreException {", "+\tprotected void startBuild(Hashtable options, boolean noWarning) throws IOException, CoreException {", "+\t\t", "+\t\t// Clean memory", "+\t\trunGc();", "+\t\t", "+\t\t// Measure", "+\t\t", "+\t\t// Verify markers", "+\t\tList resources = new ArrayList();", "+\t\tList messages = new ArrayList();", "-\t\t\t\t\tassertTrue(\"Unexpected marker: \" + marker.getAttribute(IMarker.MESSAGE), false);", "+\t\t\t\t\tresources.add(marker.getResource().getName());", "+\t\t\t\t\tmessages.add(marker.getAttribute(IMarker.MESSAGE));", "+\t\t\t\t\tif (noWarning) {", "+\t\t\t\t\t\tresources.add(marker.getResource().getName());", "+\t\t\t\t\t\tmessages.add(marker.getAttribute(IMarker.MESSAGE));", "+\t\t\t\t\t}", "-\t\tif (DEBUG) System.out.println(\"done\");", "-\t\t{", "-\t\t\tcommitMeasurements();", "-\t\t\tassertPerformance();", "+\t\t", "+\t\t// Assert result", "+\t\tint size = messages.size();", "+\t\tif (size > 0) {", "+\t\t\t/*", "+\t\t\tif (LOG_DIR == null) {", "+\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\tint max = size > 10 ? 10 : size;", "+\t\t\t\tfor (int i=0; i<max; i++) {", "+\t\t\t\t\tbuffer.append(resources.get(i));", "+\t\t\t\t\tbuffer.append(\":\\n\\t\");", "+\t\t\t\t\tbuffer.append(messages.get(i));", "+\t\t\t\t\tbuffer.append('\\n');", "+\t\t\t\t}", "+\t\t\t\tif (size > max)", "+\t\t\t\t\tbuffer.append(\"...\\n\");", "+\t\t\t\tassertTrue(\"Unexpected marker(s):\\n\" + buffer.toString(), size==0);", "+\t\t\t}", "+\t\t\t*/", "+//\t\t\tif (LOG_DIR != null || DEBUG) {", "+\t\t\t\tStringBuffer debugBuffer = new StringBuffer();", "+\t\t\t\tfor (int i=0; i<size; i++) {", "+\t\t\t\t\tdebugBuffer.append(resources.get(i));", "+\t\t\t\t\tdebugBuffer.append(\":\\n\\t\");", "+\t\t\t\t\tdebugBuffer.append(messages.get(i));", "+\t\t\t\t\tdebugBuffer.append('\\n');", "+\t\t\t\t}", "+\t\t\t\tSystem.out.println(\"ERROR: Unexpected marker(s):\\n\" + debugBuffer.toString());", "+//\t\t\t}", "-\t\treturn warnings;", "+\t\tif (DEBUG) System.out.println(\"done\");", "+\t\t", "+\t\t// Commit measure", "+\t\tcommitMeasurements();", "+\t\tassertPerformance();", "+", "+\t\t// Store warning", "+\t\tif (warnings>0) {", "+\t\t\tSystem.out.println(\"\\t- \"+warnings+\" warnings found while performing build.\");", "+\t\t}", "+\t\tif (this.scenarioComment == null) {", "+\t\t\tthis.scenarioComment = new StringBuffer(\"[\"+TEST_POSITION+\"]\");", "+\t\t} else {", "+\t\t\tthis.scenarioComment.append(' ');", "+\t\t}", "+\t\tthis.scenarioComment.append(\"warn=\");", "+\t\tthis.scenarioComment.append(warnings);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "020c432d14a630f14687160ff05e138e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "1784048e951cac8e5c6590cc5827817757e6384e", "commitAfterChange": "4a48abb3b4027036bdeac61104059b6c83710144", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 22, "signatureBeforeChange": "  \tpublic String toString()", "signatureAfterChange": "  \tpublic String toString()", "diff": ["+//\t\tbuffer.append(\"scanner: \").append(this.scanner.toString());\t//$NON-NLS-1$", "+\t\tint startPos = this.scanner.currentPosition<this.index ? this.scanner.currentPosition : this.index;", "+\t\tint endPos = this.scanner.currentPosition<this.index ? this.index : this.scanner.currentPosition;", "+\t\tif (startPos == this.source.length)", "+\t\t\treturn \"EOF\\n\\n\" + new String(this.source); //$NON-NLS-1$", "+\t\tif (endPos > this.source.length)", "+\t\t\treturn \"behind the EOF\\n\\n\" + new String(this.source); //$NON-NLS-1$", "+\t", "+\t\tchar front[] = new char[startPos];", "+\t\tSystem.arraycopy(this.source, 0, front, 0, startPos);", "+\t", "+\t\tint middleLength = (endPos - 1) - startPos + 1;", "+\t\tchar middle[];", "+\t\tif (middleLength > -1) {", "+\t\t\tmiddle = new char[middleLength];", "+\t\t\tSystem.arraycopy(", "+\t\t\t\tthis.source, ", "+\t\t\t\tstartPos, ", "+\t\t\t\tmiddle, ", "+\t\t\t\t0, ", "+\t\t\t\tmiddleLength);", "+\t\t} else {", "+\t\t\tmiddle = CharOperation.NO_CHAR;", "+\t\t}", "+\t\t", "+\t\tchar end[] = new char[this.source.length - (endPos - 1)];", "+\t\tSystem.arraycopy(", "+\t\t\tthis.source, ", "+\t\t\t(endPos - 1) + 1, ", "+\t\t\tend, ", "+\t\t\t0, ", "+\t\t\tthis.source.length - (endPos - 1) - 1);", "+\t\t", "+\t\tbuffer.append(front);", "+\t\tif (this.scanner.currentPosition<this.index) {", "+\t\t\tbuffer.append(\"\\n===============================\\nScanner current position here -->\"); //$NON-NLS-1$", "+\t\t} else {", "+\t\t\tbuffer.append(\"\\n===============================\\nParser index here -->\"); //$NON-NLS-1$", "+\t\t}", "+\t\tbuffer.append(middle);", "+\t\tif (this.scanner.currentPosition<this.index) {", "+\t\t\tbuffer.append(\"<-- Parser index here\\n===============================\\n\"); //$NON-NLS-1$", "+\t\t} else {", "+\t\t\tbuffer.append(\"<-- Scanner current position here\\n===============================\\n\"); //$NON-NLS-1$", "+\t\t}", "+\t\t//\t+ \"\" //$NON-NLS-1$", "+\t\tbuffer.append(end);", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0985a9451b337c623b54ce69446f2ac8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java", "commitBeforeChange": "2daf63d08a96c2ed6e0e08ccfe89195f55d9f8ce", "commitAfterChange": "b4d3f967db596bbe85e51e090676967f450c3332", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     @Override     public TypeMirror asMemberOf(DeclaredType containing, Element element)", "signatureAfterChange": "     @Override     public TypeMirror asMemberOf(DeclaredType containing, Element element)", "diff": ["-        throw new UnsupportedOperationException(\"NYI: TypesImpl.asMemberOf(\" + containing + \", \" + element + \")\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$", "+//        throw new UnsupportedOperationException(\"NYI: TypesImpl.asMemberOf(\" + containing + \", \" + element + \")\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$", "+    \tElementImpl elementImpl = (ElementImpl) element;", "+    \tDeclaredTypeImpl declaredTypeImpl = (DeclaredTypeImpl) containing;", "+    \tReferenceBinding referenceBinding = (ReferenceBinding) declaredTypeImpl._binding;", "+    \tswitch(element.getKind()) {", "+    \t\tcase CONSTRUCTOR :", "+    \t\tcase METHOD :", "+    \t\t\tMethodBinding methodBinding = (MethodBinding) elementImpl._binding;", "+    \t\t\tif (methodBinding.declaringClass != referenceBinding) {", "+    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "+    \t\t\t}", "+    \t\t\tfor (MethodBinding method : referenceBinding.methods()) {", "+    \t\t\t\tif (CharOperation.equals(method.selector, methodBinding.selector)", "+    \t\t\t\t\t\t&& method.areParameterErasuresEqual(methodBinding)) {", "+    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(method);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tbreak;", "+    \t\tcase FIELD :", "+    \t\t\tFieldBinding fieldBinding = (FieldBinding) elementImpl._binding;", "+    \t\t\tif (fieldBinding.declaringClass != referenceBinding) {", "+    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "+    \t\t\t}", "+    \t\t\tfor (FieldBinding field : referenceBinding.fields()) {", "+    \t\t\t\tif (CharOperation.equals(field.name, fieldBinding.name)) {", "+    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(field);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tbreak;", "+    \t\tcase ENUM :", "+    \t\tcase ANNOTATION_TYPE :", "+    \t\tcase INTERFACE :", "+    \t\tcase CLASS :", "+    \t\t\tReferenceBinding referenceBinding2 = (ReferenceBinding) elementImpl._binding;", "+    \t\t\tif (referenceBinding2.enclosingType() != referenceBinding) {", "+    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "+    \t\t\t}", "+    \t\t\tfor (ReferenceBinding referenceBinding3 : referenceBinding.memberTypes()) {", "+    \t\t\t\tif (CharOperation.equals(referenceBinding3.compoundName, referenceBinding3.compoundName)) {", "+    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(referenceBinding3);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tbreak;", "+    \t}", "+\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1778f10034affb4475993554c9d72c82", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterMassiveRegressionTests.java", "commitBeforeChange": "48b439005b4e27b9edf7ac75008df6663dca3609", "commitAfterChange": "db94ada762c25cbafb7604978ccc4fc3df281550", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " public void tearDownSuite() throws Exception", "signatureAfterChange": " public void tearDownSuite() throws Exception", "diff": ["+\t// Display time measures", "+\tStringBuffer buffer1 = new StringBuffer();", "+\tbuffer1.append(\"Time measures:\").append(LINE_SEPARATOR);", "+\tbuffer1.append(\"\t- first format:\").append(LINE_SEPARATOR);", "+\tbuffer1.append(\"\t\t+ elapsed = \"+timeString(TIME_MEASURES.formatting[0])).append(LINE_SEPARATOR);", "+\tbuffer1.append(\"\t\t+ occurrences = \"+TIME_MEASURES.occurences[0]).append(LINE_SEPARATOR);", "+\tbuffer1.append(\"\t\t+ null output = \"+TIME_MEASURES.null_output[0]).append(LINE_SEPARATOR);", "+\tbuffer1.append(\"\t- repeated format:\").append(LINE_SEPARATOR);", "+\tfor (int i=1; i<FORMAT_REPEAT; i++) {", "+\t\tbuffer1.append(\"\t   n\ufffd \"+(i+1)).append(LINE_SEPARATOR);", "+\t\tbuffer1.append(\"\t\t+ elapsed = \"+timeString(TIME_MEASURES.formatting[i])).append(LINE_SEPARATOR);", "+\t\tbuffer1.append(\"\t\t+ occurrences = \"+TIME_MEASURES.occurences[i]).append(LINE_SEPARATOR);", "+\t\tbuffer1.append(\"\t\t+ null output = \"+TIME_MEASURES.null_output[i]).append(LINE_SEPARATOR);", "+\t}", "+\tbuffer1.append(LINE_SEPARATOR);", "+", "-\tStringBuffer buffer = new StringBuffer(LINE_SEPARATOR);", "-\t\t\tbuffer.append(size);", "-\t\t\tbuffer.append(\" file\");", "+\t\t\tbuffer1.append(size);", "+\t\t\tbuffer1.append(\" file\");", "-\t\t\t\tbuffer.append(\" has \");", "+\t\t\t\tbuffer1.append(\" has \");", "-\t\t\t\tbuffer.append(\"s have \");", "+\t\t\t\tbuffer1.append(\"s have \");", "-\t\t\tbuffer.append(FAILURES[i]);", "-\t\t\tbuffer.append('!');", "-\t\t\tbuffer.append(LINE_SEPARATOR);", "+\t\t\tbuffer1.append(FAILURES[i]);", "+\t\t\tbuffer1.append('!');", "+\t\t\tbuffer1.append(LINE_SEPARATOR);", "-\tbuffer.append(LINE_SEPARATOR);", "+\tbuffer1.append(LINE_SEPARATOR);", "+\tStringBuffer buffer2 = new StringBuffer(LINE_SEPARATOR);", "-\t\t\tbuffer.append(\"List of file(s) with \");", "-\t\t\tbuffer.append(FAILURES[i]);", "-\t\t\tbuffer.append(':');", "-\t\t\tbuffer.append(LINE_SEPARATOR);", "+\t\t\tbuffer2.append(\"List of file(s) with \");", "+\t\t\tbuffer2.append(FAILURES[i]);", "+\t\t\tbuffer2.append(':');", "+\t\t\tbuffer2.append(LINE_SEPARATOR);", "-\t\t\t\tbuffer.append(\"\t- \");", "-\t\t\t\tbuffer.append(failures.get(j));", "-\t\t\t\tbuffer.append(LINE_SEPARATOR);", "+\t\t\t\tbuffer2.append(\"\t- \");", "+\t\t\t\tbuffer2.append(failures.get(j));", "+\t\t\t\tbuffer2.append(LINE_SEPARATOR);", "+\tSystem.out.println(buffer1.toString());", "-\t\tSystem.out.println(buffer.toString());", "+\t\tSystem.out.println(buffer2.toString());", "-\t\tLOG_STREAM.print(buffer.toString());", "+\t\tLOG_STREAM.print(buffer1.toString());", "+\t\tLOG_STREAM.print(buffer2.toString());", "+//\tLOG_BUFFER.append(buffer1.toString());", "+//\tLOG_BUFFER.append(buffer2.toString());", "+//\tInputStream stream= new InputStream() {", "+//\t\tprivate Reader reader= new StringReader(LOG_BUFFER.toString());", "+//\t\tpublic int read() throws IOException {", "+//\t\t\treturn this.reader.read();", "+//\t\t}", "+//\t};", "+//\tif (LOG_RESOURCE.exists()) {", "+//\t\tLOG_RESOURCE.setContents(", "+//\t\t\tstream,", "+//\t\t\tIResource.FORCE | IResource.KEEP_HISTORY,", "+//\t\t\tnull);", "+//\t} else {", "+//\t\tLOG_RESOURCE.create(stream, IResource.FORCE, null);", "+//\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2c394775d0046124782520811f5a6ec2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java", "commitBeforeChange": "b8f9116e058ff109e3943db933379c84a64ecfdc", "commitAfterChange": "b5f5f93dde4e439dc96f53e74d57c1059230610e", "methodNumberBeforeChange": 142, "methodNumberAfterChange": 142, "signatureBeforeChange": " \tpublic boolean visit(TagElement node)", "signatureAfterChange": " \tpublic boolean visit(TagElement node)", "diff": ["-\t\tif (isChanged(node, TagElement.FRAGMENTS_PROPERTY)) {", "-\t\t\t// eval position after opening parent", "-\t\t\ttry {", "-\t\t\t\tint startOffset= getScanner().getTokenEndOffset(ITerminalSymbols.TokenNameIdentifier, node.getStartPosition());", "-\t\t\t\trewriteNodeList(node, TagElement.FRAGMENTS_PROPERTY, startOffset, \" \", \", \"); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t} catch (CoreException e) {", "-\t\t\t\thandleException(e);", "+\t\t", "+\t\tint changeKind= getChangeKind(node, TagElement.TAG_NAME_PROPERTY);", "+\t\tswitch (changeKind) {", "+\t\t\tcase RewriteEvent.INSERTED: {", "+\t\t\t    String newTagName= '@' + (String) getNewValue(node, TagElement.TAG_NAME_PROPERTY);", "+\t\t\t\tdoTextInsert(node.getStartPosition(), newTagName, getEditGroup(node, TagElement.TAG_NAME_PROPERTY));", "+\t\t\t\tbreak;", "+\t\t\tcase RewriteEvent.REMOVED: {", "+\t\t\t    String oldTag= (String) getOriginalValue(node, TagElement.TAG_NAME_PROPERTY);", "+\t\t\t    int tagEnd= findTagNameStart(node)  + oldTag.length();", "+\t\t\t    doTextRemove(node.getStartPosition(), tagEnd - node.getStartPosition(), getEditGroup(node, TagElement.TAG_NAME_PROPERTY));", "+\t\t\t    break;", "+\t\t\t}", "+\t\t\tcase RewriteEvent.REPLACED: {", "+\t\t\t    String newTagName= (String) getNewValue(node, TagElement.TAG_NAME_PROPERTY);", "+\t\t    \tString oldTag= (String) getOriginalValue(node, TagElement.TAG_NAME_PROPERTY);", "+\t\t    \tint tagStart= findTagNameStart(node);", "+\t\t    \tdoTextReplace(tagStart, oldTag.length(), newTagName, getEditGroup(node, TagElement.TAG_NAME_PROPERTY));", "+\t\t\t    break;", "+\t\t\t}", "+\t\t}", "+\t\t\t\t", "+\t\tif (isChanged(node, TagElement.FRAGMENTS_PROPERTY)) {", "+\t\t\t// eval position after name", "+\t\t\tint startOffset= node.getStartPosition();", "+            String oldTag= (String) getOriginalValue(node, TagElement.TAG_NAME_PROPERTY);", "+            if (oldTag != null) {", "+                startOffset= findTagNameStart(node) + oldTag.length();", "+            }", "+            ", "+            rewriteNodeList(node, TagElement.FRAGMENTS_PROPERTY, startOffset, \" \", \" \");  //$NON-NLS-1$//$NON-NLS-2$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2d2a2d56010453f14ff24dfc25be8cae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/BuildNotifier.java", "commitBeforeChange": "54ba66d9d78ab42f826307bbdbfd4052bc565f16", "commitAfterChange": "3badf84171cbba8161f3e622b35064462f96fa86", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " protected String problemsMessage()", "signatureAfterChange": " protected String problemsMessage()", "diff": ["-\tif (newErrorCount == 0 && fixedErrorCount == 0) return \"\"; //$NON-NLS-1$", "-\tif (fixedErrorCount == 0)", "-\t\treturn '(' + (newErrorCount == 1", "-\t\t\t? Util.bind(\"build.oneErrorFound\") //$NON-NLS-1$", "-\t\t\t: Util.bind(\"build.errorsFound\", String.valueOf(newErrorCount))) + ')'; //$NON-NLS-1$", "-\tif (newErrorCount == 0)", "-\t\treturn '(' + (fixedErrorCount == 1", "-\t\t\t? Util.bind(\"build.oneErrorFixed\") //$NON-NLS-1$", "-\t\t\t: Util.bind(\"build.errorsFixed\", String.valueOf(fixedErrorCount))) + ')'; //$NON-NLS-1$", "-\treturn", "-\t\t'(' + (fixedErrorCount == 1", "-\t\t\t? Util.bind(\"build.oneErrorFixed\") //$NON-NLS-1$", "-\t\t\t: Util.bind(\"build.errorsFixed\", String.valueOf(fixedErrorCount))) //$NON-NLS-1$", "-\t\t+ \", \" //$NON-NLS-1$", "-\t\t+ (newErrorCount == 1", "-\t\t\t? Util.bind(\"build.oneErrorFound\") //$NON-NLS-1$", "-\t\t\t: Util.bind(\"build.errorsFound\", String.valueOf(newErrorCount))) + ')'; //$NON-NLS-1$", "+\tint numNew = newErrorCount + newWarningCount;", "+\tint numFixed = fixedErrorCount + fixedWarningCount;", "+\tif (numNew == 0 && numFixed == 0) return \"\"; //$NON-NLS-1$", "+", "+\tStringBuffer buffer = new StringBuffer();", "+\tbuffer.append('(');", "+\tif (numNew == 0) {", "+\t\t// (Fixed: x errors, y warnings)", "+\t\tbuffer.append(Util.bind(\"build.fixedHeader\")); //$NON-NLS-1$", "+\t\tbuffer.append(' ');", "+\t\tif (fixedErrorCount > 0) {", "+\t\t\tif (fixedErrorCount == 1)", "+\t\t\t\tbuffer.append(Util.bind(\"build.oneError\")); //$NON-NLS-1$", "+\t\t\telse", "+\t\t\t\tbuffer.append(Util.bind(\"build.multipleErrors\", String.valueOf(fixedErrorCount))); //$NON-NLS-1$", "+\t\t\tif (fixedWarningCount > 0)", "+\t\t\t\tbuffer.append(',').append(' ');", "+\t\t}", "+\t\tif (fixedWarningCount > 0) {", "+\t\t\tif (fixedWarningCount == 1)", "+\t\t\t\tbuffer.append(Util.bind(\"build.oneWarning\")); //$NON-NLS-1$", "+\t\t\telse", "+\t\t\t\tbuffer.append(Util.bind(\"build.multipleWarnings\", String.valueOf(fixedWarningCount))); //$NON-NLS-1$", "+\t\t}", "+\t} else if (numFixed == 0) {", "+\t\t// (Found: x errors, y warnings)", "+\t\tbuffer.append(Util.bind(\"build.foundHeader\")); //$NON-NLS-1$", "+\t\tbuffer.append(' ');", "+\t\tif (newErrorCount > 0) {", "+\t\t\tif (newErrorCount == 1)", "+\t\t\t\tbuffer.append(Util.bind(\"build.oneError\")); //$NON-NLS-1$", "+\t\t\telse", "+\t\t\t\tbuffer.append(Util.bind(\"build.multipleErrors\", String.valueOf(newErrorCount))); //$NON-NLS-1$", "+\t\t\tif (newWarningCount > 0)", "+\t\t\t\tbuffer.append(',').append(' ');", "+\t\t}", "+\t\tif (newWarningCount > 0) {", "+\t\t\tif (newWarningCount == 1)", "+\t\t\t\tbuffer.append(Util.bind(\"build.oneWarning\")); //$NON-NLS-1$", "+\t\t\telse", "+\t\t\t\tbuffer.append(Util.bind(\"build.multipleWarnings\", String.valueOf(newWarningCount))); //$NON-NLS-1$", "+\t\t}", "+\t} else {", "+\t\t// (Found/fixed: x/y errors, x/y warnings)", "+\t\tbuffer.append(Util.bind(\"build.foundFixedHeader\")); //$NON-NLS-1$", "+\t\tbuffer.append(' ');", "+", "+\t\tif (newErrorCount > 0 || fixedErrorCount > 0) {", "+\t\t\tString plusMinus = String.valueOf(newErrorCount) + \"/\" + String.valueOf(fixedErrorCount); //$NON-NLS-1$", "+\t\t\tbuffer.append(Util.bind(\"build.multipleErrors\", plusMinus)); //$NON-NLS-1$", "+\t\t\tif (fixedWarningCount > 0 || newWarningCount > 0)", "+\t\t\t\tbuffer.append(',').append(' ');", "+\t\t}", "+\t\tif (newWarningCount > 0 || fixedWarningCount > 0) {", "+\t\t\tString plusMinus = String.valueOf(newWarningCount) + \"/\" + String.valueOf(fixedWarningCount); //$NON-NLS-1$", "+\t\t\tbuffer.append(Util.bind(\"build.multipleWarnings\", plusMinus)); //$NON-NLS-1$", "+\t\t}", "+\t}", "+\tbuffer.append(')');", "+\treturn buffer.toString();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4e14c81803cca115b2ed611b11462dfc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java", "commitBeforeChange": "8ff87d310a91c2a77c65ad68bb4b1fd94425fd85", "commitAfterChange": "dbf8a869161361178e399dd7e18a85b9a48bde74", "methodNumberBeforeChange": 102, "methodNumberAfterChange": 115, "signatureBeforeChange": "\t\t  \tpublic void testStringLiteralUnicode()", "signatureAfterChange": "\t\t  \tpublic void testStringLiteralUnicode()", "diff": ["-\t\tAST localAst = new AST();", "+\t\tAST localAst;", "+\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "+\t\t\tlocalAst = AST.newAST2();", "+\t\t} else {", "+\t\t\tlocalAst = AST.newAST3();", "+\t\t}", "-\t\tlocalAst = new AST();", "+\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "+\t\t\tlocalAst = AST.newAST2();", "+\t\t} else {", "+\t\t\tlocalAst = AST.newAST3();", "+\t\t}", "-\t\tlocalAst = new AST();", "+\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "+\t\t\tlocalAst = AST.newAST2();", "+\t\t} else {", "+\t\t\tlocalAst = AST.newAST3();", "+\t\t}", "-\t\tlocalAst = new AST();", "+\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "+\t\t\tlocalAst = AST.newAST2();", "+\t\t} else {", "+\t\t\tlocalAst = AST.newAST3();", "+\t\t}", "-\t\tlocalAst = new AST();", "+\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "+\t\t\tlocalAst = AST.newAST2();", "+\t\t} else {", "+\t\t\tlocalAst = AST.newAST3();", "+\t\t}", "-\t\tlocalAst = new AST();", "+\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "+\t\t\tlocalAst = AST.newAST2();", "+\t\t} else {", "+\t\t\tlocalAst = AST.newAST3();", "+\t\t}", "-\t\tlocalAst = new AST();", "+\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "+\t\t\tlocalAst = AST.newAST2();", "+\t\t} else {", "+\t\t\tlocalAst = AST.newAST3();", "+\t\t}", "-\t\tlocalAst = new AST();", "+\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "+\t\t\tlocalAst = AST.newAST2();", "+\t\t} else {", "+\t\t\tlocalAst = AST.newAST3();", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "601d34d7c064304ea3598f2574c2f69d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java", "commitBeforeChange": "4b460199498c48cda44ce10125aa5901a10bff62", "commitAfterChange": "ccd12469d7fc21a8e1a0a597451a059df56002ad", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic static String formatJavadoc(char[] unparsed)", "signatureAfterChange": " \tprivate static String formatJavadoc(char[] unparsed)", "diff": ["-\tpublic static String formatJavadoc(char[] unparsed)", "+\tprivate static String formatJavadoc(char[] unparsed)", "-\t\t", "+", "-\t\t\treturn lines[0];", "-\t\t}", "-\t\t", "-\t\tint firstLine = lines[0].trim().length() > 0 ? 0 : 1;", "-\t\t", "-\t\t// for each line after the first, including the last, if it starts with whitespace", "-\t\t// followed by stars, skip all that. ", "-\t\tfor (int line = 1; line < lines.length; ++line) {", "-\t\t\tMatcher whitespaceMatcher = INITIAL_WHITESPACE_STARS.matcher(lines[line]);", "-\t\t\tif (whitespaceMatcher.find()) {", "-\t\t\t\tint firstAfterStars = whitespaceMatcher.end();", "-\t\t\t\tlines[line] = lines[line].substring(firstAfterStars);", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// If the last line is now empty, skip it", "-\t\tint lastLine = lines[lines.length - 1].trim().length() > 0 ? lines.length - 1 : lines.length - 2;", "-\t\t", "-\t\tStringBuilder sb = new StringBuilder();", "-\t\tfor (int line = firstLine; line <= lastLine; ++line) {", "-\t\t\tchar[] chars = lines[line].toCharArray();", "+\t\t\t// we should however remove the starting whitespaces", "+\t\t\tStringBuilder sb = new StringBuilder();", "+\t\t\tchar[] chars = lines[0].toCharArray();", "+\t\t\tboolean startingWhitespaces = true;", "-\t\t\t\tif (c == '\\t') {", "-\t\t\t\t\tfor (int i = 0; i < 8; i++) {", "-\t\t\t\t\t\tsb.append(' ');", "-\t\t\t\t\t}", "+\t\t\t\tif (Character.isWhitespace(c))", "+\t\t\t\t\tif (startingWhitespaces) {", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\tstartingWhitespaces = false;", "+\t\t\treturn sb.toString();", "+\t\t}", "+", "+\t\t// if the first line ends with spaces after the /** then we want to insert a line separator", "+\t\tint firstLine = lines[0].trim().length() > 0 ? 0 : 1;", "+", "+\t\t// If the last line is now empty, skip it", "+\t\tint lastLine = lines[lines.length - 1].trim().length() > 0 ? lines.length - 1 : lines.length - 2;", "+", "+\t\tStringBuilder sb = new StringBuilder();", "+\t\tif (lines[0].length() != 0 && firstLine == 1) {", "+\t\t\t// insert a line separator only if the remaining chars on the line are whitespaces", "+\t\t\tsb.append('\\n');", "+\t\t}", "+\t\tboolean preserveLineSeparator = lines[0].length() == 0;", "+\t\tfor (int line = firstLine; line <= lastLine; ++line) {", "+\t\t\tchar[] chars = lines[line].toCharArray();", "+\t\t\tint starsIndex = getStars(chars);", "+\t\t\tint leadingWhitespaces = 0;", "+\t\t\tboolean recordLeadingWhitespaces = true;", "+\t\t\tfor (int i = 0, max = chars.length; i < max; i++) {", "+\t\t\t\tchar c = chars[i];", "+\t\t\t\tswitch(c) {", "+\t\t\t\t\tcase '\\t' :", "+\t\t\t\t\t\tif (starsIndex == -1) {", "+\t\t\t\t\t\t\tif (recordLeadingWhitespaces) {", "+\t\t\t\t\t\t\t\tleadingWhitespaces += 8;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (i >= starsIndex) {", "+\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase ' ' :", "+\t\t\t\t\t\tif (starsIndex == -1) {", "+\t\t\t\t\t\t\tif (recordLeadingWhitespaces) {", "+\t\t\t\t\t\t\t\tleadingWhitespaces++;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (i >= starsIndex) {", "+\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\t// convert leadingwhitespaces to spaces", "+\t\t\t\t\t\trecordLeadingWhitespaces = false;", "+\t\t\t\t\t\tif (leadingWhitespaces != 0) {", "+\t\t\t\t\t\t\tint numberOfTabs = leadingWhitespaces / 8;", "+\t\t\t\t\t\t\tif (numberOfTabs != 0) {", "+\t\t\t\t\t\t\t\tfor (int j = 0, max2 = numberOfTabs; j < max2; j++) {", "+\t\t\t\t\t\t\t\t\tsb.append(\"        \"); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif ((leadingWhitespaces % 8) >= 1) {", "+\t\t\t\t\t\t\t\t\tsb.append(' ');", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if (line != 0) {", "+\t\t\t\t\t\t\t\t// we don't want to preserve the leading spaces for the first line", "+\t\t\t\t\t\t\t\tfor (int j = 0, max2 = leadingWhitespaces; j < max2; j++) {", "+\t\t\t\t\t\t\t\t\tsb.append(' ');", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tleadingWhitespaces = 0;", "+\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t} else if (c != '*' || i > starsIndex) {", "+\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "-\t\t\tif (line < lines.length - 1) {", "+\t\t\tint end = lines.length - 1;", "+\t\t\tif (line < end) {", "+\t\t\t\tsb.append('\\n');", "+\t\t\t} else if (preserveLineSeparator && line == end) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6292c6435633b9b257d74e14451b733a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionRequestorWrapper.java", "commitBeforeChange": "dee57778319ecddc17299fb2d002d4a5a28d0bbb", "commitAfterChange": "5fd533c8760a35e551d2642335bb8a6be55dd0a9", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic void accept(CompletionProposal proposal)", "signatureAfterChange": " \t \tpublic void accept(CompletionProposal proposal)", "diff": ["-\t\t\t\t\t\t\t\tproposal.getPackageName(),", "+\t\t\t\t\t\t\t\tproposal.getPackageName() == null ? CharOperation.NO_CHAR : proposal.getPackageName(),", "-\t\t\t\t\t\t\t\tproposal.getPackageName(),", "+\t\t\t\t\t\t\t\tproposal.getPackageName() == null ? CharOperation.NO_CHAR : proposal.getPackageName(),", "-\t\t\t\t\t\t\tproposal.getDeclarationPackageName(),", "-\t\t\t\t\t\t\tproposal.getDeclarationTypeName(),", "+\t\t\t\t\t\t\tproposal.getDeclarationPackageName() == null ? CharOperation.NO_CHAR : proposal.getDeclarationPackageName(),", "+\t\t\t\t\t\t\tproposal.getDeclarationTypeName() == null ? CharOperation.NO_CHAR : proposal.getDeclarationTypeName(),", "-\t\t\t\t\t\t\tproposal.getPackageName(),", "-\t\t\t\t\t\t\tproposal.getTypeName(),", "+\t\t\t\t\t\t\tproposal.getPackageName() == null ? CharOperation.NO_CHAR : proposal.getPackageName(),", "+\t\t\t\t\t\t\tproposal.getTypeName() == null ? CharOperation.NO_CHAR : proposal.getTypeName(),", "-\t\t\t\t\t\t\tproposal.findParameterNames(null),", "+\t\t\t\t\t\t\tproposal.findParameterNames(null) == null ? CharOperation.NO_CHAR_CHAR : proposal.findParameterNames(null),", "-\t\t\t\t\t\t\tproposal.getDeclarationPackageName(),", "-\t\t\t\t\t\t\tproposal.getDeclarationTypeName(),", "+\t\t\t\t\t\t\tproposal.getDeclarationPackageName() == null ? CharOperation.NO_CHAR : proposal.getDeclarationPackageName(),", "+\t\t\t\t\t\t\tproposal.getDeclarationTypeName() == null ? CharOperation.NO_CHAR : proposal.getDeclarationTypeName(),", "-\t\t\t\t\t\t\tproposal.findParameterNames(null),", "-\t\t\t\t\t\t\tproposal.getPackageName(),", "-\t\t\t\t\t\t\tproposal.getTypeName(),", "+\t\t\t\t\t\t\tproposal.findParameterNames(null) == null ? CharOperation.NO_CHAR_CHAR : proposal.findParameterNames(null),", "+\t\t\t\t\t\t\tproposal.getPackageName() == null ? CharOperation.NO_CHAR : proposal.getPackageName(),", "+\t\t\t\t\t\t\tproposal.getTypeName() == null ? CharOperation.NO_CHAR : proposal.getTypeName(),", "-\t\t\t\t\t\t\tproposal.findParameterNames(null),", "+\t\t\t\t\t\t\tproposal.findParameterNames(null) == null ? CharOperation.NO_CHAR_CHAR : proposal.findParameterNames(null),", "-\t\t\t\t\t\t\tproposal.findParameterNames(null),", "+\t\t\t\t\t\t\tproposal.findParameterNames(null) == null ? CharOperation.NO_CHAR_CHAR : proposal.findParameterNames(null),", "-\t\t\t\t\t\t\tproposal.findParameterNames(null),", "+\t\t\t\t\t\t\tproposal.findParameterNames(null) == null ? CharOperation.NO_CHAR_CHAR : proposal.findParameterNames(null),", "-\t\t\t\t\t\tproposal.findParameterNames(null),", "+\t\t\t\t\t\tproposal.findParameterNames(null) == null ? CharOperation.NO_CHAR_CHAR : proposal.findParameterNames(null),", "-\t\t\t\t\t\t\tproposal.getPackageName(),", "+\t\t\t\t\t\t\tproposal.getPackageName() == null ? CharOperation.NO_CHAR : proposal.getPackageName(),"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6b781318878d95faaf90932b107bbf11", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingComparator.java", "commitBeforeChange": "9357aeb22ce7f7b62f42472f1ba9defaa31953c5", "commitAfterChange": "2beca67c12b6708d00577783b2092953170491c0", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " \tstatic boolean isEqual(org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding2)", "signatureAfterChange": "  \tstatic boolean isEqual(org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding2, boolean checkTypeVariables)", "diff": ["-\t */", "-\tstatic boolean isEqual(org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding2) {", "+\tstatic boolean isEqual(org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding2, boolean checkTypeVariables) {", "-\t\t\treturn CharOperation.equals(referenceBinding.compoundName, referenceBinding2.compoundName)", "-\t\t\t\t&& (referenceBinding.isParameterizedType() == referenceBinding2.isParameterizedType())", "-\t\t\t\t&& (referenceBinding.isWildcard() == referenceBinding2.isWildcard())", "-\t\t\t\t&& (referenceBinding.isGenericType() == referenceBinding2.isGenericType())", "-\t\t\t\t&& (referenceBinding.isRawType() == referenceBinding2.isRawType())", "-\t\t\t\t&& (referenceBinding.isInterface() == referenceBinding2.isInterface())", "-\t\t\t\t&& (referenceBinding.isEnum() == referenceBinding2.isEnum())", "-\t\t\t\t&& (referenceBinding.isAnnotationType() == referenceBinding2.isAnnotationType())", "-\t\t\t\t&& (referenceBinding.modifiers == referenceBinding2.modifiers);", "+\t\t\tif (referenceBinding.isParameterizedType()) {", "+\t\t\t\tif (!referenceBinding2.isParameterizedType()) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tParameterizedTypeBinding parameterizedTypeBinding = (ParameterizedTypeBinding) referenceBinding;", "+\t\t\t\tParameterizedTypeBinding parameterizedTypeBinding2 = (ParameterizedTypeBinding) referenceBinding2;", "+\t\t\t\treturn CharOperation.equals(referenceBinding.compoundName, referenceBinding2.compoundName)", "+\t\t\t\t\t&& (referenceBinding.isInterface() == referenceBinding2.isInterface())", "+\t\t\t\t\t&& (referenceBinding.isEnum() == referenceBinding2.isEnum())", "+\t\t\t\t\t&& (referenceBinding.isAnnotationType() == referenceBinding2.isAnnotationType())", "+\t\t\t\t\t&& (referenceBinding.modifiers == referenceBinding2.modifiers)", "+\t\t\t\t\t&& isEqual(parameterizedTypeBinding.arguments, parameterizedTypeBinding2.arguments);", "+\t\t\t} else if (referenceBinding.isWildcard()) {", "+\t\t\t\tif (!referenceBinding2.isWildcard()) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) referenceBinding;", "+\t\t\t\tWildcardBinding wildcardBinding2 = (WildcardBinding) referenceBinding2;", "+\t\t\t\treturn isEqual(wildcardBinding.bound, wildcardBinding2.bound)", "+\t\t\t\t\t&& wildcardBinding.kind == wildcardBinding2.kind;", "+\t\t\t} else if (referenceBinding.isGenericType()) {", "+\t\t\t\tif (!referenceBinding2.isGenericType()) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tif (checkTypeVariables) {", "+\t\t\t\t\tif (!isEqual(referenceBinding.typeVariables(), referenceBinding2.typeVariables())) {", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn CharOperation.equals(referenceBinding.compoundName, referenceBinding2.compoundName)", "+\t\t\t\t\t&& (referenceBinding.isGenericType() == referenceBinding2.isGenericType())", "+\t\t\t\t\t&& (referenceBinding.isRawType() == referenceBinding2.isRawType())", "+\t\t\t\t\t&& (referenceBinding.isInterface() == referenceBinding2.isInterface())", "+\t\t\t\t\t&& (referenceBinding.isEnum() == referenceBinding2.isEnum())", "+\t\t\t\t\t&& (referenceBinding.isAnnotationType() == referenceBinding2.isAnnotationType())", "+\t\t\t\t\t&& (referenceBinding.modifiers == referenceBinding2.modifiers);", "+\t\t\t} else {", "+\t\t\t\treturn CharOperation.equals(referenceBinding.compoundName, referenceBinding2.compoundName)", "+\t\t\t\t\t&& (referenceBinding.isRawType() == referenceBinding2.isRawType())", "+\t\t\t\t\t&& (referenceBinding.isInterface() == referenceBinding2.isInterface())", "+\t\t\t\t\t&& (referenceBinding.isEnum() == referenceBinding2.isEnum())", "+\t\t\t\t\t&& (referenceBinding.isAnnotationType() == referenceBinding2.isAnnotationType())", "+\t\t\t\t\t&& (referenceBinding.modifiers == referenceBinding2.modifiers);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6c2e7000f221d19ca7667b60bd008d1f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterJavadocTest.java", "commitBeforeChange": "1dbf45ade1eaa8473579771e92825a7887776253", "commitAfterChange": "0fb8e6d8cd5771230b88c7189dc0d95f3a5da0e3", "methodNumberBeforeChange": 47, "methodNumberAfterChange": 47, "signatureBeforeChange": " \tpublic void testBug51363() throws JavaModelException", "signatureAfterChange": " \tpublic void testBug51363() throws JavaModelException", "diff": ["-\t\tverifyComments(\"Bug51363\");", "+\t\tthis.sourceUnit = getCompilationUnit(\"Converter\" , \"src\", \"javadoc.testBug51363\", \"Test.java\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$", "+\t\tASTNode result = runConversion(this.sourceUnit, false);", "+\t\tfinal CompilationUnit unit = (CompilationUnit) result;", "+\t\tassertEquals(this.prefix+\"Wrong number of problems\", 0, unit.getProblems().length); //$NON-NLS-1$", "+\t\tassertEquals(this.prefix+\"Wrong number of comments\", 2, unit.getCommentTable().length);", "+\t\t// verify first comment", "+\t\tComment comment = unit.getCommentTable()[0];", "+\t\tassertTrue(this.prefix+\"Comment should be a line comment \", comment.isLineComment());", "+\t\tString sourceStr = this.sourceUnit.getSource();", "+\t\tint startPos = comment.getStartPosition()+comment.getLength();", "+\t\tassertEquals(\"Wrong length for line comment \"+comment, \"public\", sourceStr.substring(startPos, startPos+6));", "+\t\tif (debug) System.out.println(comment+\"\\nsuccessfully verified.\");", "+\t\t// verify second comment", "+\t\tcomment = unit.getCommentTable()[1];", "+\t\tassertTrue(this.prefix+\"Comment should be a line comment\", comment.isLineComment());", "+\t\tsourceStr = this.sourceUnit.getSource();", "+\t\tstartPos = comment.getStartPosition()+comment.getLength();", "+\t\tassertEquals(\"Wrong length for line comment \"+comment, \"void\", sourceStr.substring(startPos, startPos+4));", "+\t\tif (debug) System.out.println(comment+\"\\nsuccessfully verified.\");", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "70baca8126c11de0d7d17f032623cb39", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "ab74babcdf0f89ee66e36b91189c0d301a4da95d", "commitAfterChange": "66a4221dd418603b7f2bc6722d99e4e300585ef1", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tprotected Object createMethodReference(Object receiver, List arguments) throws InvalidInputException", "signatureAfterChange": " \tprotected Object createMethodReference(Object receiver, List arguments) throws InvalidInputException", "diff": ["+\t\t\tint length = this.identifierLengthStack[0];\t// may be > 0 for inner class constructor reference", "-\t\t\t\tisConstructor = CharOperation.equals(this.identifierStack[0], name);", "+\t\t\t\tisConstructor = CharOperation.equals(this.identifierStack[length-1], name);", "-\t\t\t\tchar[] name = null;", "-\t\t\t\t\tname = ((JavadocSingleTypeReference)typeRef).token;", "+\t\t\t\t\tchar[] name = ((JavadocSingleTypeReference)typeRef).token;", "+\t\t\t\t\tisConstructor = CharOperation.equals(this.identifierStack[length-1], name);", "-\t\t\t\t\tname = tokens[tokens.length-1];", "+\t\t\t\t\tint last = tokens.length-1;", "+\t\t\t\t\tisConstructor = CharOperation.equals(this.identifierStack[length-1], tokens[last]);", "+\t\t\t\t\tif (isConstructor) {", "+\t\t\t\t\t\tboolean valid = true;", "+\t\t\t\t\t\tif (valid) {", "+\t\t\t\t\t\t\tfor (int i=0; i<length-1 && valid; i++) {", "+\t\t\t\t\t\t\t\tvalid = CharOperation.equals(this.identifierStack[i], tokens[i]);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (!valid) {", "+\t\t\t\t\t\t\tif (this.reportProblems) {", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidConstructorQualification(this.memberStart+1, this.scanner.getCurrentTokenEndPosition());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\tisConstructor = CharOperation.equals(this.identifierStack[0], name);", "-\t\t\t\t\tJavadocAllocationExpression alloc = new JavadocAllocationExpression(this.identifierPositionStack[0]);", "-\t\t\t\t\talloc.type = typeRef;", "-\t\t\t\t\talloc.tagValue = this.tagValue;", "-\t\t\t\t\talloc.sourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\treturn alloc;", "+\t\t\t\t\tJavadocAllocationExpression allocation = new JavadocAllocationExpression(this.identifierPositionStack[length-1]);", "+\t\t\t\t\tallocation.type = typeRef;", "+\t\t\t\t\tallocation.tagValue = this.tagValue;", "+\t\t\t\t\tallocation.sourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\tif (length == 1) {", "+\t\t\t\t\t\tallocation.qualification = new char[][] { this.identifierStack[0] };", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tSystem.arraycopy(this.identifierStack, 0, allocation.qualification = new char[length][], 0, length);", "+\t\t\t\t\t}", "+\t\t\t\t\tallocation.memberStart = this.memberStart;", "+\t\t\t\t\treturn allocation;", "-\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[0], this.identifierPositionStack[0]);", "+\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[length-1], this.identifierPositionStack[length-1]);", "-\t\t\t\t\tJavadocAllocationExpression alloc = new JavadocAllocationExpression(this.identifierPositionStack[0]);", "-\t\t\t\t\talloc.arguments = expressions;", "-\t\t\t\t\talloc.type = typeRef;", "-\t\t\t\t\talloc.tagValue = this.tagValue;", "-\t\t\t\t\talloc.sourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\treturn alloc;", "+\t\t\t\t\tJavadocAllocationExpression allocation = new JavadocAllocationExpression(this.identifierPositionStack[length-1]);", "+\t\t\t\t\tallocation.arguments = expressions;", "+\t\t\t\t\tallocation.type = typeRef;", "+\t\t\t\t\tallocation.tagValue = this.tagValue;", "+\t\t\t\t\tallocation.sourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\tif (length == 1) {", "+\t\t\t\t\t\tallocation.qualification = new char[][] { this.identifierStack[0] };", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tSystem.arraycopy(this.identifierStack, 0, allocation.qualification = new char[length][], 0, length);", "+\t\t\t\t\t}", "+\t\t\t\t\tallocation.memberStart = this.memberStart;", "+\t\t\t\t\treturn allocation;", "-\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[0], this.identifierPositionStack[0], expressions);", "+\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[length-1], this.identifierPositionStack[length-1], expressions);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "963980ac4b155d8def9889281f472700", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "4bca3a5b750a1427c84a78f92ee835c1f5e75da7", "commitAfterChange": "65cffea518e323981e83002b5b2ff520f43d6c58", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static String buildAllDirectoriesInto( \t\tString outputPath, \t\tString relativeFileName) \t\tthrows IOException", "signatureAfterChange": " \tpublic static String buildAllDirectoriesInto( \t\tString outputPath, \t\tString relativeFileName) \t\tthrows IOException", "diff": ["-\t\t// First we ensure that the outputPath exists", "-\t\t// To be able to pass the mkdirs() method we need to remove the extra file separator at the end of the outDir name", "-\t\tif (outputPath.endsWith(fileSeparator)) {", "-\t\t\toutputPath = outputPath.substring(0, outputPath.length() - 1);", "-\t\t}", "-\t\tf = new File(outputPath);", "-\t\tif (f.exists()) {", "-\t\t\tif (!f.isDirectory()) {", "-\t\t\t\tfinal String message = Messages.bind(Messages.output_isFile, f.getAbsolutePath());", "-\t\t\t\tthrow new IOException(message);", "+\t\t\t// these could be optimized out if we normalized paths once and for", "+\t\t\t// all", "+\t\trelativeFileName = relativeFileName.replace('/', fileSeparatorChar);", "+\t\tString outputDirPath, fileName;", "+\t\tint separatorIndex = relativeFileName.lastIndexOf(fileSeparatorChar);", "+\t\tif (separatorIndex == -1) {", "+\t\t\tif (outputPath.endsWith(fileSeparator)) {", "+\t\t\t\toutputDirPath = outputPath.substring(0, outputPath.length() - 1);", "+\t\t\t\tfileName = outputPath + relativeFileName;", "+\t\t\t} else {", "+\t\t\t\toutputDirPath = outputPath;", "+\t\t\t\tfileName = outputPath + fileSeparator + relativeFileName;", "-\t\t\t// we have to create that directory", "-\t\t\tif (!f.mkdirs()) {", "-\t\t\t\tfinal String message = Messages.bind(Messages.output_notValidAll, f.getAbsolutePath());", "-\t\t\t\tthrow new IOException(message);", "+\t\t\tif (outputPath.endsWith(fileSeparator)) {", "+\t\t\t\toutputDirPath = outputPath + ", "+\t\t\t\t\trelativeFileName.substring(0, separatorIndex);", "+\t\t\t\tfileName = outputPath + relativeFileName;", "+\t\t\t} else {", "+\t\t\t\toutputDirPath = outputPath + fileSeparator +", "+\t\t\t\t\trelativeFileName.substring(0, separatorIndex);", "+\t\t\t\tfileName = outputPath + fileSeparator + relativeFileName;", "-\t\tStringBuffer outDir = new StringBuffer(outputPath);", "-\t\toutDir.append(fileSeparator);", "-\t\tStringTokenizer tokenizer =", "-\t\t\tnew StringTokenizer(relativeFileName, fileSeparator);", "-\t\tString token = tokenizer.nextToken();", "-\t\twhile (tokenizer.hasMoreTokens()) {", "-\t\t\tf = new File(outDir.append(token).append(fileSeparator).toString());", "+\t\tf = new File(outputDirPath);", "+\t\tf.mkdirs();", "+\t\tif (f.isDirectory()) {", "+\t\t\treturn fileName;", "+\t\t} else {", "+\t\t\t// the directory creation failed for some reason - retry using", "+\t\t\t// a slower algorithm so as to refine the diagnostic", "+\t\t\tif (outputPath.endsWith(fileSeparator)) {", "+\t\t\t\toutputPath = outputPath.substring(0, outputPath.length() - 1);", "+\t\t\t}", "+\t\t\tf = new File(outputPath);", "+\t\t\tboolean checkFileType = false;", "-\t\t\t\t// The outDir already exists, so we proceed the next entry", "-\t\t\t\t// System.out.println(\"outDir: \" + outDir + \" already exists.\");", "+\t\t\t  \tcheckFileType = true; // pre-existed", "-\t\t\t\t// Need to add the outDir", "-\t\t\t\tif (!f.mkdir()) {", "-\t\t\t\t\tthrow new IOException(Messages.bind(Messages.output_notValid, f.getName()));", "+\t\t\t\t// we have to create that directory", "+\t\t\t\tif (!f.mkdirs()) {", "+\t\t\t\t  \tif (f.exists()) {", "+\t\t\t\t  \t  \t// someone else created f -- need to check its type", "+\t\t\t\t  \t  \tcheckFileType = true;", "+\t\t\t\t  \t} else {", "+\t\t\t\t  \t  \t// no one could create f -- complain", "+\t    \t\t\t\tthrow new IOException(Messages.bind(", "+\t    \t\t\t\t\tMessages.output_notValidAll, f.getAbsolutePath()));", "+\t\t\t\t  \t}", "-\t\t\ttoken = tokenizer.nextToken();", "+\t\t\tif (checkFileType) {", "+\t\t\t  \tif (!f.isDirectory()) {", "+\t    \t\t\tthrow new IOException(Messages.bind(", "+\t    \t\t\t\tMessages.output_isFile, f.getAbsolutePath()));", "+\t\t\t  \t}", "+\t\t\t}", "+\t\t\tStringBuffer outDir = new StringBuffer(outputPath);", "+\t\t\toutDir.append(fileSeparator);", "+\t\t\tStringTokenizer tokenizer =", "+\t\t\t\tnew StringTokenizer(relativeFileName, fileSeparator);", "+\t\t\tString token = tokenizer.nextToken();", "+\t\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\t\tf = new File(outDir.append(token).append(fileSeparator).toString());", "+\t\t\t  \tcheckFileType = false; // reset", "+\t\t\t\tif (f.exists()) {", "+\t\t\t\t  \tcheckFileType = true; // this is suboptimal, but it catches corner cases", "+\t\t\t\t  \t\t\t\t\t\t  // in which a regular file pre-exists", "+\t\t\t\t} else {", "+\t\t\t\t// we have to create that directory", "+\t    \t\t\tif (!f.mkdir()) {", "+\t    \t\t\t  \tif (f.exists()) {", "+\t    \t\t\t  \t  \t// someone else created f -- need to check its type", "+\t    \t\t\t  \t  \tcheckFileType = true;", "+\t    \t\t\t  \t} else {", "+\t    \t\t\t  \t  \t// no one could create f -- complain", "+\t        \t\t\t\tthrow new IOException(Messages.bind(", "+\t        \t\t\t\t\tMessages.output_notValid, ", "+\t        \t\t\t\t\t\toutDir.substring(outputPath.length() + 1, ", "+\t        \t\t\t\t\t\t\toutDir.length() - 1),", "+\t        \t\t\t\t\t\toutputPath));", "+\t    \t\t\t  \t}", "+\t    \t\t\t}", "+\t\t\t\t}", "+\t    \t\tif (checkFileType) {", "+\t    \t\t  \tif (!f.isDirectory()) {", "+\t        \t\t\tthrow new IOException(Messages.bind(", "+\t        \t\t\t\tMessages.output_isFile, f.getAbsolutePath()));", "+\t    \t\t  \t}", "+\t    \t\t}", "+\t\t\t\ttoken = tokenizer.nextToken();", "+\t\t\t}", "+\t\t\t// token contains the last one", "+\t\t\treturn outDir.append(token).toString();", "-\t\t// token contains the last one", "-\t\treturn outDir.append(token).toString();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "992087495bfa073dae3e0539efbbaa52", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "f11400a6293169aae30e17b2e27f5adb8ea51511", "commitAfterChange": "f04e3f1ae3453f83dbe0aa3f6ea76c9c43c152ce", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "\r \tprotected void initializeDefaultPluginPreferences()", "signatureAfterChange": "\r \tprotected void initializeDefaultPluginPreferences()", "diff": ["-\t\r", "+\t\tHashSet optionNames = JavaModelManager.getJavaModelManager().OptionNames;\r", "+\t\t\r", "+\t\toptionNames.add(COMPILER_LOCAL_VARIABLE_ATTR);\r", "+\r", "+\t\toptionNames.add(COMPILER_LINE_NUMBER_ATTR);\r", "+\r", "+\t\toptionNames.add(COMPILER_SOURCE_FILE_ATTR);\r", "+\r", "+\t\toptionNames.add(COMPILER_CODEGEN_UNUSED_LOCAL);\r", "+\r", "+\t\toptionNames.add(COMPILER_CODEGEN_TARGET_PLATFORM);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_UNREACHABLE_CODE);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_INVALID_IMPORT);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_OVERRIDING_PACKAGE_DEFAULT_METHOD);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_METHOD_WITH_CONSTRUCTOR_NAME);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_DEPRECATION);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_HIDDEN_CATCH_BLOCK);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_UNUSED_LOCAL);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_UNUSED_PARAMETER);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_UNUSED_IMPORT);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_SYNTHETIC_ACCESS_EMULATION);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_NON_NLS_STRING_LITERAL);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_ASSERT_IDENTIFIER);\r", "+\r", "+\t\toptionNames.add(COMPILER_SOURCE);\r", "+\r", "+\t\toptionNames.add(COMPILER_COMPLIANCE);\r", "+\r", "+\t\toptionNames.add(COMPILER_PB_MAX_PER_UNIT);\r", "+\t\toptionNames.add(CORE_JAVA_BUILD_RESOURCE_COPY_FILTER);\r", "+\r", "+\t\toptionNames.add(CORE_JAVA_BUILD_INVALID_CLASSPATH);\r", "+\t\toptionNames.add(CORE_JAVA_BUILD_ORDER);\r", "+\t\toptionNames.add(FORMATTER_NEWLINE_OPENING_BRACE);\r", "+\r", "+\t\toptionNames.add(FORMATTER_NEWLINE_CONTROL);\r", "+\r", "+\t\toptionNames.add(FORMATTER_CLEAR_BLANK_LINES);\r", "+\r", "+\t\toptionNames.add(FORMATTER_NEWLINE_ELSE_IF);\r", "+\r", "+\t\toptionNames.add(FORMATTER_NEWLINE_EMPTY_BLOCK);\r", "+\r", "+\t\toptionNames.add(FORMATTER_LINE_SPLIT);\r", "+\r", "+\t\toptionNames.add(FORMATTER_COMPACT_ASSIGNMENT);\r", "+\r", "+\t\toptionNames.add(FORMATTER_TAB_CHAR);\r", "+\r", "+\t\toptionNames.add(FORMATTER_TAB_SIZE);\r", "+\t\toptionNames.add(CODEASSIST_VISIBILITY_CHECK);\r", "+\r", "+\t\toptionNames.add(CODEASSIST_IMPLICIT_QUALIFICATION);\r", "+\t\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a27bdec103d894281fdff704a92c20c7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java", "commitBeforeChange": "904e81d11d3fc634ae2d9d861dc6c73c9ea81e03", "commitAfterChange": "2fce9fdec7d24fd4985bfaa8a4da9bdc5aff2660", "methodNumberBeforeChange": 67, "methodNumberAfterChange": 74, "signatureBeforeChange": " \tpublic void testExampleSnippets()", "signatureAfterChange": " \tpublic void testExampleSnippets()", "diff": ["-\t\t\t// public class MyClass {}", "+\t\t\t// /** Spec. \\n @deprecated Use {@link #foo() bar} instead. */public class MyClass {}", "+\t\t\t{ ", "+\t\t\t\tJavadoc jd = localAst.newJavadoc();", "+\t\t\t\tTextElement tx1 = localAst.newTextElement();", "+\t\t\t\ttx1.setText(\"Spec.\"); //$NON-NLS-1$", "+\t\t\t\tjd.fragments().add(tx1);", "+\t\t\t\tTagElement tg1 = localAst.newTagElement();", "+\t\t\t\ttg1.setTagName(\"@deprecated\");", "+\t\t\t\tjd.fragments().add(tg1);", "+\t\t\t\tTextElement tx2 = localAst.newTextElement();", "+\t\t\t\ttx2.setText(\"Use \"); //$NON-NLS-1$", "+\t\t\t\ttg1.fragments().add(tx2);", "+\t\t\t\tTagElement tg2 = localAst.newTagElement();", "+\t\t\t\ttg2.setTagName(\"@link\");", "+\t\t\t\ttg1.fragments().add(tg2);", "+\t\t\t\tMethodRef mr1 = localAst.newMethodRef();", "+\t\t\t\tmr1.setName(localAst.newSimpleName(\"foo\"));", "+\t\t\t\ttg2.fragments().add(mr1);", "+\t\t\t\tTextElement tx3 = localAst.newTextElement();", "+\t\t\t\ttx3.setText(\"bar\"); //$NON-NLS-1$", "+\t\t\t\ttg2.fragments().add(tx3);", "+\t\t\t\tTextElement tx4 = localAst.newTextElement();", "+\t\t\t\ttx2.setText(\" instead.\"); //$NON-NLS-1$", "+\t\t\t\ttg1.fragments().add(tx4);", "+\t\t\t}", "+\t\t\t", "-\t\t\t// new String[len]", "+\t\t\t// new String[len];", "-\t\t\t// new double[7][24][]", "+\t\t\t// new double[7][24][];", "-\t\t\t// new int[] {1, 2}", "+\t\t\t// new int[] {1, 2};", "-\t\t\t// new String(10)", "+\t\t\t// new String(10);", "-\t\t\t// new Listener() {public void handleEvent() {} }", "+\t\t\t// new Listener() {public void handleEvent() {} };"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a7aada78d1e54c74695d042490ea0f56", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java", "commitBeforeChange": "048c99cb4c40c6639a98df3f0c05bf0ba13af8f8", "commitAfterChange": "73d46cf67b022e45f4a1a5989eb3965ffa6f4612", "methodNumberBeforeChange": 784, "methodNumberAfterChange": 784, "signatureBeforeChange": " \tpublic void testModifiers()", "signatureAfterChange": " \tpublic void testModifiers()", "diff": ["-\t\t\tassertEquals(expectedOrder[i], ((Modifier) result.get(i)).getKeyword());", "+\t\t\tfinal Modifier modifier = ((Modifier) result.get(i));", "+\t\t\tassertEquals(expectedOrder[i], modifier.getKeyword());", "+\t\t\tif (modifier.isAbstract()) {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.ABSTRACT_KEYWORD, modifier.getKeyword());", "+\t\t\t} else if (modifier.isFinal()) {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.FINAL_KEYWORD, modifier.getKeyword());", "+\t\t\t} else if (modifier.isNative()) {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.NATIVE_KEYWORD, modifier.getKeyword());", "+\t\t\t} else if (modifier.isPrivate()) {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.PRIVATE_KEYWORD, modifier.getKeyword());", "+\t\t\t} else if (modifier.isProtected()) {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.PROTECTED_KEYWORD, modifier.getKeyword());", "+\t\t\t} else if (modifier.isPublic()) {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.PUBLIC_KEYWORD, modifier.getKeyword());", "+\t\t\t} else if (modifier.isStatic()) {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.STATIC_KEYWORD, modifier.getKeyword());", "+\t\t\t} else if (modifier.isStrictfp()) {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.STRICTFP_KEYWORD, modifier.getKeyword());", "+\t\t\t} else if (modifier.isSynchronized()) {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.SYNCHRONIZED_KEYWORD, modifier.getKeyword());", "+\t\t\t} else if (modifier.isTransient()) {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.TRANSIENT_KEYWORD, modifier.getKeyword());", "+\t\t\t} else {", "+\t\t\t\tassertEquals(Modifier.ModifierKeyword.VOLATILE_KEYWORD, modifier.getKeyword());", "+\t\t\t} "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf11b25af413da7ba15afb1179c815f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java", "commitBeforeChange": "40ad9904e939ba54abece52421044021edd6e1c0", "commitAfterChange": "8d45cb26fc5ad244f93e8632d761d46ad4a120cf", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic static void handleResourceAssignment(FlowInfo flowInfo, Statement location, Expression rhs, LocalVariableBinding local, \t\t\t\tLocalVariableBinding previousTrackerBinding)", "signatureAfterChange": " \tpublic static void handleResourceAssignment(BlockScope scope, FlowInfo upstreamInfo, FlowInfo flowInfo, ASTNode location, Expression rhs, LocalVariableBinding local)", "diff": ["-\tpublic static void handleResourceAssignment(FlowInfo flowInfo, Statement location, Expression rhs, LocalVariableBinding local,", "-\t\t\t\tLocalVariableBinding previousTrackerBinding) ", "+\tpublic static void handleResourceAssignment(BlockScope scope, FlowInfo upstreamInfo, FlowInfo flowInfo, ASTNode location, Expression rhs, LocalVariableBinding local)", "-\t\tif (isAutoCloseable(rhs.resolvedType)) {", "+\t\t// does the LHS (local) already have a tracker, indicating we may leak a resource by the assignment?", "+\t\tFakedTrackingVariable previousTracker = null;", "+\t\tFakedTrackingVariable disconnectedTracker = null;", "+\t\tif (local.closeTracker != null) {", "+\t\t\t// assigning to a variable already holding an AutoCloseable, has it been closed before?", "+\t\t\tpreviousTracker = local.closeTracker;", "+\t\t\tint nullStatus = upstreamInfo.nullStatus(local);", "+\t\t\tif (nullStatus != FlowInfo.NULL && nullStatus != FlowInfo.UNKNOWN) // only if previous value may be relevant", "+\t\t\t\tdisconnectedTracker = previousTracker; // report error below, unless we have a self-wrap assignment", "+\t\t}", "+", "+\t\tif (rhs.resolvedType != TypeBinding.NULL) {", "-\t", "-\t\t\tif (rhsTrackVar != null) {\t\t\t\t\t\t\t\t// 1. share tracking variable with RHS?", "-\t\t\t\tlocal.closeTracker = rhsTrackVar;", "-\t\t\t\t// keep null-status unchanged across this assignment", "-\t\t\t} else if (previousTrackerBinding != null) {\t\t\t// 2. re-use tracking variable from the LHS?", "-\t\t\t\t// re-assigning from a fresh, mark as not-closed again:", "-\t\t\t\tflowInfo.markAsDefinitelyNull(previousTrackerBinding);", "+\t\t\tif (rhsTrackVar != null) {\t\t\t\t\t\t\t\t// 1. if RHS has a tracking variable...", "+\t\t\t\tif (local.closeTracker == null) {", "+\t\t\t\t\t// null shouldn't occur but let's play safe", "+\t\t\t\t\tif (rhsTrackVar.originalBinding != null)", "+\t\t\t\t\t\tlocal.closeTracker = rhsTrackVar;\t\t\t//\t\ta.: let fresh LHS share it ", "+\t\t\t\t} else {", "+\t\t\t\t\tif (rhsTrackVar == disconnectedTracker && rhs instanceof AllocationExpression)", "+\t\t\t\t\t\treturn; \t\t\t\t\t\t\t\t\t// \t\tb.: self wrapper: res = new Wrap(res); -> done!", "+\t\t\t\t\tlocal.closeTracker = rhsTrackVar;\t\t\t\t//\t\tc.: conflicting LHS and RHS, proceed with recordErrorLocation below", "+\t\t\t\t}", "+\t\t\t\t// keep close-status of RHS unchanged across this assignment", "+\t\t\t} else if (previousTracker != null) {\t\t\t\t\t// 2. re-use tracking variable from the LHS?", "+\t\t\t\t// re-assigning from a fresh value, mark as not-closed again:", "+\t\t\t\tif ((previousTracker.globalClosingState & (SHARED_WITH_OUTSIDE|OWNED_BY_OUTSIDE)) == 0)", "+\t\t\t\t\tflowInfo.markAsDefinitelyNull(previousTracker.binding);", "+\t\t\t\tlocal.closeTracker = analyseCloseableExpression(flowInfo, local, location, rhs, previousTracker);", "-\t\t\t\tlocal.closeTracker = new FakedTrackingVariable(local, location);", "-\t\t\t\t// a fresh resource, mark as not-closed:", "-\t\t\t\tflowInfo.markAsDefinitelyNull(local.closeTracker.binding);", "+\t\t\t\trhsTrackVar = analyseCloseableExpression(flowInfo, local, location, rhs, null);", "+\t\t\t\tif (rhsTrackVar != null) {", "+\t\t\t\t\tlocal.closeTracker = rhsTrackVar;", "+\t\t\t\t\t// a fresh resource, mark as not-closed:", "+\t\t\t\t\tif ((rhsTrackVar.globalClosingState & (SHARED_WITH_OUTSIDE|OWNED_BY_OUTSIDE)) == 0)", "+\t\t\t\t\t\tflowInfo.markAsDefinitelyNull(rhsTrackVar.binding);", "-//\t\t\t\tif (flowContext.initsOnFinally != null)", "-//\t\t\t\t\tflowContext.initsOnFinally.markAsDefinitelyNonNull(trackerBinding);", "+//\t\t\t\t\tif (flowContext.initsOnFinally != null)", "+//\t\t\t\t\t\tflowContext.initsOnFinally.markAsDefinitelyNonNull(trackerBinding);", "+\t\t\t\t}", "+\t\t}", "+", "+\t\tif (disconnectedTracker != null) {", "+\t\t\tif (disconnectedTracker.innerTracker != null && disconnectedTracker.innerTracker.binding.declaringScope == scope) {", "+\t\t\t\t// discard tracker for the wrapper but keep the inner:", "+\t\t\t\tdisconnectedTracker.innerTracker.outerTracker = null;", "+\t\t\t\tscope.pruneWrapperTrackingVar(disconnectedTracker);", "+\t\t\t} else {", "+\t\t\t\tint upstreamStatus = upstreamInfo.nullStatus(disconnectedTracker.binding);", "+\t\t\t\tif (upstreamStatus != FlowInfo.NON_NULL)", "+\t\t\t\t\tdisconnectedTracker.recordErrorLocation(location, upstreamStatus);", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e3b3f5c145b170dcbc7d6089c35ebb5c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ScannerTest.java", "commitBeforeChange": "e9740a5d5d266d4ab1f1481408252eab08091df9", "commitAfterChange": "c0b7ec7ac86ca976e8dafca35f37afdb3d3303ce", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 63, "signatureBeforeChange": " \tpublic void test061()", "signatureAfterChange": " \tpublic void test061()", "diff": ["-\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383062", "+\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=387146", "+\t\tIScanner scanner = ToolFactory.createScanner(", "+\t\t\t\ttrue,", "+\t\t\t\ttrue,", "+\t\t\t\ttrue,", "+\t\t\t\tJavaCore.VERSION_1_4,", "+\t\t\t\tJavaCore.VERSION_1_4);", "+\t\tfinal char[] source = \"case 1:\\nsynchronized (someLock){}\\n//$FALL-THROUGH$\\ncase 2:\".toCharArray();", "+\t\tscanner.setSource(source);", "+\t\tscanner.resetTo(0, source.length - 1);", "+\t\ttry {", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNamecase, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameWHITESPACE, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameIntegerLiteral, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameCOLON, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameWHITESPACE, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNamesynchronized, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameWHITESPACE, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameLPAREN, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameIdentifier, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameRPAREN, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameLBRACE, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameRBRACE, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameWHITESPACE, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameCOMMENT_LINE, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNamecase, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameWHITESPACE, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameIntegerLiteral, scanner.getNextToken());", "+\t\t\tassertEquals(\"Wrong token\", ITerminalSymbols.TokenNameCOLON, scanner.getNextToken());", "+\t\t} catch (InvalidInputException e) {", "+\t\t\tassertTrue(\"Should not fail with InvalidInputException\", false);", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f644297378d9186b45ca880e24522312", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "c539ab4170e4fe0d8578cc8fb0121c9a797f5894", "commitAfterChange": "44363e0012bf09a8a44565479ae5740426ed378a", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "signatureAfterChange": " \t \tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "diff": ["-\t\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) return;", "-\t\tif (this.binding == null || !this.binding.isValidBinding()) return;", "+\t\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0 || this.binding == null || !this.binding.isValidBinding()) ", "+\t\t\treturn;", "+\t\t", "+\t\tMethodBinding codegenBinding = this.binding.original();", "+\t\tSourceTypeBinding enclosingSourceType = currentScope.enclosingSourceType();", "-\t\t\t// if constructor from parameterized type got found, use the original constructor at codegen time", "-\t\t\tMethodBinding codegenBinding = this.binding.original();", "-", "-\t\t\tif (codegenBinding.isPrivate() && currentScope.enclosingSourceType() != (allocatedType = codegenBinding.declaringClass)) {", "+\t\t\tif (codegenBinding.isPrivate() && enclosingSourceType != (allocatedType = codegenBinding.declaringClass)) {", "+\t\t\treturn;", "+\t\t}", "+\t", "+\t\t// -----------------------------------   Only method references from now on -----------", "+\t\tif (this.binding.isPrivate()) {", "+\t\t\tif (enclosingSourceType != codegenBinding.declaringClass){", "+\t\t\t\tthis.syntheticAccessor = ((SourceTypeBinding)codegenBinding.declaringClass).addSyntheticMethod(codegenBinding, false /* not super access */);", "+\t\t\t\tcurrentScope.problemReporter().needToEmulateMethodAccess(codegenBinding, this);", "+\t\t\t}", "+\t\t\treturn;", "+\t\t}", "+\t\t", "+\t\tif (this.lhs.isSuper()) {", "+\t\t\tSourceTypeBinding destinationType = enclosingSourceType;", "+\t\t\tif (this.lhs instanceof QualifiedSuperReference) { \t// qualified super", "+\t\t\t\tQualifiedSuperReference qualifiedSuperReference = (QualifiedSuperReference) this.lhs;", "+\t\t\t\tTypeReference qualification = qualifiedSuperReference.qualification;", "+\t\t\t\tif (!qualification.resolvedType.isInterface()) // we can't drop the bridge in I, it may not even be a source type.", "+\t\t\t\t\tdestinationType = (SourceTypeBinding) (qualifiedSuperReference.currentCompatibleType);", "+\t\t\t}", "+\t\t\t", "+\t\t\tthis.syntheticAccessor = destinationType.addSyntheticMethod(codegenBinding, true);", "+\t\t\tcurrentScope.problemReporter().needToEmulateMethodAccess(codegenBinding, this);", "+\t\t\treturn;", "+\t\t}", "+\t\t", "+\t\tif (this.binding.isProtected() && (this.bits & ASTNode.DepthMASK) != 0 && codegenBinding.declaringClass.getPackage() != enclosingSourceType.getPackage()) {", "+\t\t\tSourceTypeBinding currentCompatibleType = (SourceTypeBinding) enclosingSourceType.enclosingTypeAt((this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT);", "+\t\t\tthis.syntheticAccessor = currentCompatibleType.addSyntheticMethod(codegenBinding, isSuperAccess());", "+\t\t\tcurrentScope.problemReporter().needToEmulateMethodAccess(codegenBinding, this);", "+\t\t\treturn;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f7461e995ca5566f395e12ecdc537231", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/FormatJavadocBlock.java", "commitBeforeChange": "b7259e61ad84f1dda95b63bf74b4b4f38727c3a6", "commitAfterChange": "db331d5badcb0b35069c87387ccad89f9c226a52", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  protected void toString(StringBuffer buffer)", "signatureAfterChange": "  protected void toString(StringBuffer buffer)", "diff": ["+\t}", "+\tStringBuffer flagsBuffer = new StringBuffer();", "+\tif (isDescription()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"description\"); //$NON-NLS-1$", "+\t}", "+\tif (isFirst()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"first\"); //$NON-NLS-1$", "+\t}", "+\tif (isHeaderLine()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"header line\"); //$NON-NLS-1$", "+\t}", "+\tif (isImmutable()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"immutable\"); //$NON-NLS-1$", "+\t}", "+\tif (isInDescription()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"in description\"); //$NON-NLS-1$", "+\t}", "+\tif (isInlined()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"inlined\"); //$NON-NLS-1$", "+\t}", "+\tif (isInParamTag()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"in param tag\"); //$NON-NLS-1$", "+\t}", "+\tif (isOneLineTag()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"one line tag\"); //$NON-NLS-1$", "+\t}", "+\tif (isParamTag()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"param tag\"); //$NON-NLS-1$", "+\t}", "+\tif (flagsBuffer.length() > 0) {", "+\t\tif (inlined) buffer.append('\\t');", "+\t\tbuffer.append(\"\tflags: \"); //$NON-NLS-1$", "+\t\tbuffer.append(flagsBuffer);", "+\t\tbuffer.append('\\n');"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f7d08580c29cf8c9c0424a1a8877143f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "17d4fac2e2145f81ae8773e6bd604f552ec24c76", "commitAfterChange": "8f4037084194a0a8c6b51e4ac889744e5d6e68a8", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " public void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["+\tboolean requiresCatchesExit = false;", "+\t\tBranchLabel catchesExitLabel = null;", "+\t\tBranchLabel postCatchesFinallyLabel = null;\t\t", "+\t\tfor (int i = 0; i < maxCatches; i++) {", "+\t\t\texceptionLabels[i].placeEnd();", "+\t\t}", "-\t\t\t\t\t// fall through", "+\t\t\t\t\tif (this.postTryInitStateIndex != -1) {", "+\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t}", "+\t\t\t\t\tcodeStream.goto_(naturalExitLabel);", "+\t\t\t\t\tbreak;", "+\t\t\t\t\tif (this.postTryInitStateIndex != -1) {", "+\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t}", "-\t\tfor (int i = 0; i < maxCatches; i++) {", "-\t\t\texceptionLabels[i].placeEnd();", "-\t\t}", "+\t\t\tcatchesExitLabel = new BranchLabel(codeStream);", "+\t\t\tpostCatchesFinallyLabel = new BranchLabel(codeStream);", "+\t\t\t", "+\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "-\t\t\t\t\t\tcase FINALLY_SUBROUTINE :", "+\t\t\t\t\t\t\trequiresCatchesExit = true;", "+\t\t\t\t\t\t\tcodeStream.goto_(catchesExitLabel);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase FINALLY_SUBROUTINE :", "+\t\t\t\t\t\t\tif (this.postTryInitStateIndex != -1) {", "+\t\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\t\t}", "-//\t\t\t\tCaseLabel defaultReturnLocationLabel = null; // only used when emulating RET instruction", "-//\t\t\t\tCaseLabel naturalExitReturnLocationLabel = null; // only used when emulating RET instruction", "+\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "+\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\t\t\t\t}", "+\t\t\t", "-\t\t\tnaturalExitLabel.place();", "+\t\t\t\t\t\tnaturalExitLabel.place();", "-\t\t\t\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\t\t\t\t\t// needed since any exception handler got inlined subroutine", "-\t\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "-\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\t\t\t\t\t// inlined finally here can see all merged variables", "+\t\t\t\t\t\tif (this.postTryInitStateIndex != -1) {", "+\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\tnaturalExitLabel.place();", "+\t\t\t\t\t\tif (postCatchesFinallyLabel != null && requiresCatchesExit) {", "+\t\t\t\t\t\t\tcodeStream.goto_(postCatchesFinallyLabel);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\tnaturalExitLabel.place();", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (requiresCatchesExit) {", "+\t\t\t\tswitch(finallyMode) {", "+\t\t\t\t\tcase FINALLY_INLINE :", "+\t\t\t\t\t\t// inlined finally here can see all merged variables", "+\t\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "+\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcatchesExitLabel.place();", "+\t\t\t\t\t\t// entire sequence for finally is associated to finally block", "+\t\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "+\t\t\t\t\t\tpostCatchesFinallyLabel.place();", "+\t\t\tif (catchesExitLabel != null) {", "+\t\t\t\tcatchesExitLabel.place();", "+\t\t\t}"]}], "num": 8170}