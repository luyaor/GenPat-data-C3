{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "90668f579fbb15a5cd1edcbb1daaf893", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3a3d6d772e226332650290265afd7571", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "4b34ac952495406305286be091754126c6d25593", "commitAfterChange": "a3337f44ed6348a5f4f65ab1b2584cb8125066c6", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 40, "signatureBeforeChange": "  \tpublic void handleLineTooLong()", "signatureAfterChange": "  \tpublic void handleLineTooLong()", "diff": ["+\t\tint previousKind = -1;", "+\t\tboolean insideMessageArguments = false;", "+\t\tboolean insideMessageSend = false;", "-\t\t\tif (targetAlignment.tieBreakRule == Alignment.R_OUTERMOST && targetAlignment.couldBreak()){", "+\t\t\tboolean couldBreak = targetAlignment.tieBreakRule == Alignment.R_OUTERMOST ||", "+\t\t\t\t((insideMessageArguments || insideMessageSend) && targetAlignment.kind == Alignment.MESSAGE_ARGUMENTS", "+\t\t\t\t\t\t&& (!targetAlignment.wasReset() || previousKind != Alignment.MESSAGE_SEND));", "+\t\t\tif (couldBreak && targetAlignment.couldBreak()){", "+\t\t\tswitch (targetAlignment.kind) {", "+\t\t\t\tcase Alignment.MESSAGE_ARGUMENTS:", "+\t\t\t\t\tinsideMessageArguments = true;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Alignment.MESSAGE_SEND:", "+\t\t\t\t\tinsideMessageSend = true;", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tpreviousKind = targetAlignment.kind;", "-\t\twhile (targetAlignment != null){", "-\t\t\tif (targetAlignment.couldBreak()){", "-\t\t\t\tthrow new AlignmentException(AlignmentException.LINE_TOO_LONG, relativeDepth);", "+\t\tAlignmentException alignmentException = null;", "+\t\tint msgArgsDepth = -1;", "+\t\twhile (targetAlignment != null) {", "+\t\t\tif (targetAlignment.kind == Alignment.MESSAGE_ARGUMENTS) {", "+\t\t\t\tmsgArgsDepth = relativeDepth;", "+\t\t\t}", "+\t\t\tif (alignmentException == null) {", "+\t\t\t\tif (targetAlignment.couldBreak()) {", "+\t\t\t\t\t// do not throw the exception immediately to have a chance to reset", "+\t\t\t\t\t// previously broken alignments (see bug 203588)", "+\t\t\t\t\talignmentException = new AlignmentException(AlignmentException.LINE_TOO_LONG, relativeDepth);", "+\t\t\t\t}", "+\t\t\t} else if (targetAlignment.wasSplit) {", "+\t\t\t\t// reset the nearest already broken outermost alignment.", "+\t\t\t\t// Note that it's not done twice to avoid infinite loop while raising", "+\t\t\t\t// the exception on an innermost alignment...", "+\t\t\t\tif (!targetAlignment.wasReset()) {", "+\t\t\t\t\ttargetAlignment.reset();", "+\t\t\t\t\tif (msgArgsDepth > alignmentException.relativeDepth) {", "+\t\t\t\t\t\talignmentException.relativeDepth = msgArgsDepth;", "+\t\t\t\t\t}", "+\t\t\t\t\tthrow alignmentException;", "+\t\t\t\t}", "+\t\tif (alignmentException != null) {", "+\t\t\tthrow alignmentException;", "+\t\t}", "+\t\tif (this.currentAlignment != null) {", "+\t\t\tthis.currentAlignment.blockAlign = false;", "+\t\t\tthis.currentAlignment.tooLong = true;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bd2db6be0d0bb99b44a15f9328b69611", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "0534618c17c0b5f6c361eb5acf9c22731255984f", "commitAfterChange": "d85ef445439a7932d1fe7c7dafa9bf16e2d2dd51", "methodNumberBeforeChange": 372, "methodNumberAfterChange": 377, "signatureBeforeChange": " protected void parse()", "signatureAfterChange": " protected void parse()", "diff": ["+\tboolean jumpOverTypeAfterReduce = false;", "-\t\t\t}\t\t\t\t\t", "+\t\t\t}\t\t\t\t", "+\t\t\tif(this.statementRecoveryActivated) {", "+\t\t\t\tjumpOverTypeAfterReduce = true;", "+\t\t\t}", "+\t\t\t\tif(this.statementRecoveryActivated) {", "+\t\t\t\t\tthis.jumpOverType();", "+\t\t\t\t}", "+\t\t\tif(this.statementRecoveryActivated && act > NUM_RULES) {", "+\t\t\t\tif(jumpOverTypeAfterReduce) {", "+\t\t\t\t\tthis.jumpOverType();", "+\t\t\t\t\tjumpOverTypeAfterReduce = false;", "+\t\t\t\t}", "+\t\t\t}", "+\t", "-\tif (this.reportSyntaxErrorIsRequired && this.hasError) {", "-\t\treportSyntaxErrors(isDietParse, oldFirstToken);", "-\t}\t", "+\tif (this.reportSyntaxErrorIsRequired && this.hasError && !this.statementRecoveryActivated) {", "+\t\tif(!this.options.performStatementsRecovery) {", "+\t\t\treportSyntaxErrors(isDietParse, oldFirstToken);", "+\t\t} else {", "+\t\t\tRecoveryScannerData data = this.referenceContext.compilationResult().recoveryScannerData;", "+\t\t\t", "+\t\t\tif(this.recoveryScanner == null) {", "+\t\t\t\tthis.recoveryScanner = new RecoveryScanner(this.scanner, data);", "+\t\t\t} else {", "+\t\t\t\tthis.recoveryScanner.setData(data);", "+\t\t\t}", "+\t\t\t", "+\t\t\tthis.recoveryScanner.setSource(scanner.source);", "+\t\t\tthis.recoveryScanner.lineEnds = this.scanner.lineEnds;", "+\t\t\tthis.recoveryScanner.linePtr = this.scanner.linePtr;", "+\t\t\t", "+\t\t\treportSyntaxErrors(isDietParse, oldFirstToken);", "+\t\t\t", "+\t\t\tif(data == null) {", "+\t\t\t\tthis.referenceContext.compilationResult().recoveryScannerData =", "+\t\t\t\t\tthis.recoveryScanner.getData();", "+\t\t\t}", "+\t\t\t", "+\t\t\tif (this.methodRecoveryActivated) {", "+\t\t\t\tthis.methodRecoveryActivated = false;", "+\t\t\t\tthis.recoverStatements();", "+\t\t\t\tthis.methodRecoveryActivated = true;", "+", "+\t\t\t\tthis.lastAct = ERROR_ACTION;", "+\t\t\t}", "+\t\t}", "+\t}", "+\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c27700c5552d29e9f052fa3c237add48", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java", "commitBeforeChange": "c85c898de3099d8d87b870385bc47667302c5e21", "commitAfterChange": "73c6d3ea7dc5df8e531fcab68ea3f39bbd288577", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic void recordContinueFrom(FlowInfo flowInfo)", "signatureAfterChange": "  public void recordContinueFrom(FlowContext innerFlowContext, FlowInfo flowInfo)", "diff": ["-\tpublic void recordContinueFrom(FlowInfo flowInfo) {", "-", "-\t\tif (!flowInfo.isReachable()) return;", "-\t\tif (initsOnContinue == FlowInfo.DEAD_END) {", "-\t\t\tinitsOnContinue = flowInfo.copy().unconditionalInits();", "-\t\t} else {", "-\t\t\tinitsOnContinue = initsOnContinue.mergedWith(flowInfo.copy().unconditionalInits());", "-\t\t}", "+public void recordContinueFrom(FlowContext innerFlowContext, FlowInfo flowInfo) {", "+\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0)\t{", "+\tif ((initsOnContinue.tagBits & FlowInfo.UNREACHABLE) == 0) {", "+\t\tinitsOnContinue = initsOnContinue.", "+\t\t\tmergedWith(flowInfo.unconditionalInitsWithoutSideEffect());", "+\t} ", "+\telse {", "+\t\tinitsOnContinue = flowInfo.unconditionalCopy();", "+\tFlowContext inner = innerFlowContext;", "+\twhile (inner != this && !(inner instanceof LoopingFlowContext)) {", "+\t\tinner = inner.parent;", "+\t}", "+\tif (inner == this) {", "+\t\tthis.upstreamNullFlowInfo.", "+\t\t\taddPotentialNullInfoFrom(", "+\t\t\t\tflowInfo.unconditionalInitsWithoutSideEffect());", "+\t}", "+\telse {", "+\t\tint length = 0;", "+\t\tif (this.innerFlowContexts == null) {", "+\t\t\tthis.innerFlowContexts = new LoopingFlowContext[5];", "+\t\t\tthis.innerFlowInfos = new UnconditionalFlowInfo[5];", "+\t\t}", "+\t\telse if (this.innerFlowContextsNb == ", "+\t\t\t\t(length = this.innerFlowContexts.length) - 1) {", "+\t\t\tSystem.arraycopy(this.innerFlowContexts, 0, ", "+\t\t\t\t(this.innerFlowContexts = new LoopingFlowContext[length + 5]), ", "+\t\t\t\t0, length);", "+\t\t\tSystem.arraycopy(this.innerFlowInfos, 0, ", "+\t\t\t\t(this.innerFlowInfos= new UnconditionalFlowInfo[length + 5]), ", "+\t\t\t\t0, length);", "+\t\t}", "+\t\tthis.innerFlowContexts[this.innerFlowContextsNb] = (LoopingFlowContext) inner;", "+\t\tthis.innerFlowInfos[this.innerFlowContextsNb++] = ", "+\t\t\tflowInfo.unconditionalInitsWithoutSideEffect();", "+\t}", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e22e1e7f2da707876695ae8e288d2538", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "de85d73a10e0280a45c9d9fcbbd2b35068e06127", "commitAfterChange": "df9615ffbbc7235a218c4e9aa88ba85075714875", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["+\t\tthis.parentScope = blockScope;", "+\t\tif (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {", "+\t\t\tif (this.body instanceof Block) {", "+\t\t\t\t// Gather shape information for potential applicability analysis.", "+\t\t\t\tASTVisitor visitor = new ASTVisitor() {", "+\t\t\t\t\tboolean valueReturnSeen = false;", "+\t\t\t\t\tboolean voidReturnSeen = false;", "+\t\t\t\t\tpublic boolean visit(ReturnStatement returnStatement, BlockScope dontCare) {", "+\t\t\t\t\t\tif (returnStatement.expression != null) {", "+\t\t\t\t\t\t\tthis.valueReturnSeen = true;", "+\t\t\t\t\t\t\tLambdaExpression.this.voidCompatible = false;", "+\t\t\t\t\t\t\tLambdaExpression.this.valueCompatible = !this.voidReturnSeen;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.voidReturnSeen = true;", "+\t\t\t\t\t\t\tLambdaExpression.this.valueCompatible = false;", "+\t\t\t\t\t\t\tLambdaExpression.this.voidCompatible = !this.valueReturnSeen;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\t}", "+\t\t\t\t};", "+\t\t\t\tthis.traverse(visitor, blockScope);", "+\t\t\t} else {", "+\t\t\t\tExpression expression = (Expression) this.body;", "+\t\t\t\tthis.voidCompatible = expression.statementExpression();", "+\t\t\t\tthis.valueCompatible = true;", "+\t\t\t}\t", "+\t\t\tif (devNullCompilationResult == null)", "+\t\t\t\tdevNullCompilationResult = new CompilationResult(this.compilationResult.getCompilationUnit(), 0, 0, blockScope.compilerOptions().maxProblemsPerUnit);", "+\t\t\treturn new PolyTypeBinding(this);", "+\t\t}"]}], "num": 15613}