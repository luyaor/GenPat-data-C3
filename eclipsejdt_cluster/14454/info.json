{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9afd9de18bf8adab691ff89ec27c7ba6", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3458faa848fa257086c05de74d5e73b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "6d9cd9b246f8b8740f4a501085a32633b2b6c2af", "commitAfterChange": "470afdfff602b441f9a45a7d903230534423c9ca", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprivate boolean connectSuperInterfaces()", "signatureAfterChange": " \tprivate boolean connectSuperInterfaces()", "diff": ["+\t\t\t// check for simple interface collisions ", "-\t\t\tfor (int k = 0; k < count; k++) {", "-\t\t\t\tif (interfaceBindings[k].erasure() == superInterface.erasure()) {", "-\t\t\t\t\tproblemReporter().duplicateSuperinterface(sourceType, referenceContext, (ReferenceBinding) superInterface.erasure());", "+\t\t\tfor (int j = 0; j < i; j++) {", "+\t\t\t\tif (interfaceBindings[j] == superInterface) {", "+\t\t\t\t\tproblemReporter().duplicateSuperinterface(sourceType, superInterfaceRef, superInterface);", "-\t\t\tReferenceBinding invalid = findAmbiguousInterface(superInterface, sourceType);", "-\t\t\tif (invalid != null) {", "-\t\t\t\tReferenceBinding generic = null;", "-\t\t\t\tif (superInterface.isParameterizedType())", "-\t\t\t\t\tgeneric = ((ParameterizedTypeBinding) superInterface).type;", "-\t\t\t\telse if (invalid.isParameterizedType())", "-\t\t\t\t\tgeneric = ((ParameterizedTypeBinding) invalid).type;", "-\t\t\t\tproblemReporter().superinterfacesCollide(generic, referenceContext, superInterface, invalid);", "-\t\t\t\tsourceType.tagBits |= HierarchyHasProblems;", "-\t\t\t\tnoProblems = false;", "-\t\t\t\tcontinue nextInterface;", "-\t\t\t}", "-", "+\t\t}", "+\t\t// check for parameterized interface collisions (when different parameterizations occur)", "+\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\tTypeBinding[] types = new TypeBinding[2];", "+\t\t\tMap invocations = new HashMap(2);", "+\t\t\tnextInterface: for (int i = 0; i < count; i++) {", "+\t\t\t\tReferenceBinding superInterface =  interfaceBindings[i];", "+\t\t\t\t// check against superclass", "+\t\t\t\tif (!sourceType.isInterface()) {", "+\t\t\t\t\tReferenceBinding match = sourceType.superclass.findSuperTypeWithSameErasure(superInterface);", "+\t\t\t\t\tif (match != null && match != superInterface) {", "+\t\t\t\t\t\tproblemReporter().superinterfacesCollide(superInterface.erasure(), referenceContext, superInterface, match);", "+\t\t\t\t\t\tsourceType.tagBits |= HierarchyHasProblems;", "+\t\t\t\t\t\tnoProblems = false;", "+\t\t\t\t\t\tcontinue nextInterface;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// check against other super-interfaces", "+\t\t\t\ttypes[0] = superInterface;", "+\t\t\t\tnextOtherInterface: for (int j = 0; j < i; j++) {", "+\t\t\t\t\tReferenceBinding otherInterface = interfaceBindings[j];", "+\t\t\t\t\tif (otherInterface == null) continue nextOtherInterface;", "+\t\t\t\t\ttypes[1] = otherInterface;", "+\t\t\t\t\tinvocations.clear();", "+\t\t\t\t\tTypeBinding[] mecs = minimalErasedCandidates(types, invocations);", "+\t\t\t\t\tif (mecs != null) {", "+\t\t\t\t\t\tnextCandidate: for (int k = 0, max = mecs.length; k < max; k++) {", "+\t\t\t\t\t\t\tTypeBinding mec = mecs[k];", "+\t\t\t\t\t\t\tif (mec == null) continue nextCandidate;", "+\t\t\t\t\t\t\tSet invalidInvocations = (Set)invocations.get(mec);", "+\t\t\t\t\t\t\tint invalidSize = invalidInvocations.size();", "+\t\t\t\t\t\t\tif (invalidSize > 1) {", "+\t\t\t\t\t\t\t\tTypeBinding[] collisions;", "+\t\t\t\t\t\t\t\tinvalidInvocations.toArray(collisions = new TypeBinding[invalidSize]);", "+\t\t\t\t\t\t\t\tproblemReporter().superinterfacesCollide(collisions[0].erasure(), referenceContext, collisions[0], collisions[1]);", "+\t\t\t\t\t\t\t\tsourceType.tagBits |= HierarchyHasProblems;", "+\t\t\t\t\t\t\t\tnoProblems = false;", "+\t\t\t\t\t\t\t\tcontinue nextInterface;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4484c9be666585bc66b3b6f31ff0ef0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "f908d0c09b5bf34a0f6e90dacd8d551c0f19870c", "commitAfterChange": "2d9e2019b5b59684e0488ab5bab1ae5850c1ca71", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \t \tprotected boolean connectTypeVariables(TypeParameter[] typeParameters)", "signatureAfterChange": " \t \tprotected boolean connectTypeVariables(TypeParameter[] typeParameters)", "diff": ["-", "+\t\tTypeBinding[] types = new TypeBinding[2];", "+\t\tMap invocations = new HashMap(2);", "-\t\t\t\ttypeVariable.modifiers |= AccInterface;", "-", "+\t\t\t\t\ttypes[0] = superType;", "-\t\t\t\t\tif (superType.isParameterizedType()) {", "+\t\t\t\t\t// check against superclass", "+\t\t\t\t\tif (typeVariable.firstBound == typeVariable.superclass) {", "-\t\t\t\t\t\tboolean isCollision = match != null && match != superType;", "-\t\t\t\t\t\tfor (int index = typeVariable.superInterfaces.length; !isCollision && --index >= 0;) {", "-\t\t\t\t\t\t\tReferenceBinding temp = typeVariable.superInterfaces[index];", "-\t\t\t\t\t\t\tisCollision = superType != temp && superType.erasure() == temp.erasure();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (isCollision) {", "-\t\t\t\t\t\t\tproblemReporter().boundHasConflictingArguments(typeRef, superType);", "+\t\t\t\t\t\tif (match != null && match != superType) {", "+\t\t\t\t\t\t\tproblemReporter().superinterfacesCollide(superType.erasure(), typeRef, superType, match);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t// check against superinterfaces", "-\t\t\t\t\t\tif (superType.erasure() == typeVariable.superInterfaces[index].erasure()) {", "+\t\t\t\t\t\tReferenceBinding previousInterface = typeVariable.superInterfaces[index];", "+\t\t\t\t\t\tif (previousInterface == superRefType) {", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\ttypes[1] = previousInterface;", "+\t\t\t\t\t\tinvocations.clear();", "+\t\t\t\t\t\tTypeBinding[] mecs = minimalErasedCandidates(types, invocations);", "+\t\t\t\t\t\tif (mecs != null) {", "+\t\t\t\t\t\t\tnextCandidate: for (int m = 0, max = mecs.length; m < max; m++) {", "+\t\t\t\t\t\t\t\tTypeBinding mec = mecs[m];", "+\t\t\t\t\t\t\t\tif (mec == null) continue nextCandidate;", "+\t\t\t\t\t\t\t\tSet invalidInvocations = (Set)invocations.get(mec);", "+\t\t\t\t\t\t\t\tint invalidSize = invalidInvocations.size();", "+\t\t\t\t\t\t\t\tif (invalidSize > 1) {", "+\t\t\t\t\t\t\t\t\tTypeBinding[] collisions;", "+\t\t\t\t\t\t\t\t\tinvalidInvocations.toArray(collisions = new TypeBinding[invalidSize]);", "+\t\t\t\t\t\t\t\t\tproblemReporter().superinterfacesCollide(collisions[0].erasure(), typeRef, collisions[0], collisions[1]);", "+\t\t\t\t\t\t\t\t\ttypeVariable.tagBits |= HierarchyHasProblems;", "+\t\t\t\t\t\t\t\t\tnoProblems = false;", "+\t\t\t\t\t\t\t\t\tcontinue nextVariable;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}\t\t\t\t\t"]}], "num": 14454}