{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d01a3cca63a99ed4fb6efa880bc7ad71", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "692b6188df1d2382569f932feb44a2d9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java", "commitBeforeChange": "566dfe9d75afc609e513171bfa949df8ee32e8da", "commitAfterChange": "14bf482e9ce4e28aba53c29fe3155a9c59b88f63", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tTypeBinding leftTb = left.resolveType(scope);", "-\tTypeBinding rightTb = right.resolveType(scope);", "-\tif (leftTb == null || rightTb == null){", "+\tTypeBinding leftType = left.resolveType(scope);", "+\tTypeBinding rightType = right.resolveType(scope);", "+\tif (leftType == null || rightType == null){", "-\tif (leftTb.isBaseType() && rightTb.isBaseType()) {", "+\tif (leftType.isBaseType() && rightType.isBaseType()) {", "-\t\tint result = ResolveTypeTables[EQUAL_EQUAL][ (leftTb.id << 4) + rightTb.id];", "+\t\tint result = ResolveTypeTables[EQUAL_EQUAL][ (leftType.id << 4) + rightType.id];", "-\t\t\tscope.problemReporter().invalidOperator(this, leftTb, rightTb);", "+\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-\t\tcomputeConstant(leftTb, rightTb);", "+\t\tcomputeConstant(leftType, rightType);", "-\tif (areTypesCastCompatible(scope, rightTb, leftTb) || areTypesCastCompatible(scope, leftTb, rightTb)) {", "+\tif (areTypesCastCompatible(scope, rightType, leftType) || areTypesCastCompatible(scope, leftType, rightType)) {", "-\t\tif ((rightTb.id == T_String) && (leftTb.id == T_String))", "-\t\t\tcomputeConstant(leftTb, rightTb);", "+\t\tif ((rightType.id == T_String) && (leftType.id == T_String))", "+\t\t\tcomputeConstant(leftType, rightType);", "-\t\tif (rightTb.id == T_String)", "+\t\tif (rightType.id == T_String)", "-\t\tif (leftTb.id == T_String)", "+\t\tif (leftType.id == T_String)", "-\tscope.problemReporter().notCompatibleTypesError(this, leftTb, rightTb);", "+\tscope.problemReporter().notCompatibleTypesError(this, leftType, rightType);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7be3fce9d8bb9fbfc2c11975e4d43c1b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "3a7eebe0921eeefbdbf1fe4891891b6335310197", "commitAfterChange": "e8aa72d0e85424c76c1185b7518db6803dde6255", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic void computeConstant(BlockScope scope, int leftId, int rightId)", "signatureAfterChange": "  public void computeConstant(BlockScope scope, int leftId, int rightId)", "diff": ["-\tpublic void computeConstant(BlockScope scope, int leftId, int rightId) {", "-", "-\t\t//compute the constant when valid", "-\t\tif ((this.left.constant != Constant.NotAConstant)", "-\t\t\t&& (this.right.constant != Constant.NotAConstant)) {", "-\t\t\ttry {", "-\t\t\t\tthis.constant =", "-\t\t\t\t\tConstant.computeConstantOperation(", "-\t\t\t\t\t\tthis.left.constant,", "-\t\t\t\t\t\tleftId,", "-\t\t\t\t\t\t(this.bits & OperatorMASK) >> OperatorSHIFT,", "-\t\t\t\t\t\tthis.right.constant,", "-\t\t\t\t\t\trightId);", "-\t\t\t} catch (ArithmeticException e) {", "-\t\t\t\tthis.constant = Constant.NotAConstant;", "-\t\t\t\t// 1.2 no longer throws an exception at compile-time", "-\t\t\t\t//scope.problemReporter().compileTimeConstantThrowsArithmeticException(this);", "-\t\t\t}", "-\t\t} else {", "+public void computeConstant(BlockScope scope, int leftId, int rightId) {", "+\t//compute the constant when valid", "+\tif ((this.left.constant != Constant.NotAConstant)", "+\t\t&& (this.right.constant != Constant.NotAConstant)) {", "+\t\ttry {", "+\t\t\tthis.constant =", "+\t\t\t\tConstant.computeConstantOperation(", "+\t\t\t\t\tthis.left.constant,", "+\t\t\t\t\tleftId,", "+\t\t\t\t\t(this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT,", "+\t\t\t\t\tthis.right.constant,", "+\t\t\t\t\trightId);", "+\t\t} catch (ArithmeticException e) {", "-\t\t\t//add some work for the boolean operators & |  ", "-\t\t\tthis.optimizedBooleanConstant(", "-\t\t\t\tleftId,", "-\t\t\t\t(this.bits & OperatorMASK) >> OperatorSHIFT,", "-\t\t\t\trightId);", "+\t\t\t// 1.2 no longer throws an exception at compile-time", "+\t\t\t//scope.problemReporter().compileTimeConstantThrowsArithmeticException(this);", "+\t} else {", "+\t\tthis.constant = Constant.NotAConstant;", "+\t\t//add some work for the boolean operators & |  ", "+\t\tthis.optimizedBooleanConstant(", "+\t\t\tleftId,", "+\t\t\t(this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT,", "+\t\t\trightId);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "edf12ba359542aa40deb61b70b5ba657", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java", "commitBeforeChange": "4e7caa3a77ad20f357ad4b6907dbbeb13267be58", "commitAfterChange": "90e913a6f89a9a5089d1398987b958c3f2bb0a05", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "\r public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tTypeBinding lhsTb = lhs.resolveType(scope);\r", "-\tTypeBinding expressionTb = expression.resolveType(scope);\r", "-\tif (lhsTb == null || expressionTb == null)\r", "+\tTypeBinding lhsType = lhs.resolveType(scope);\r", "+\tTypeBinding expressionType = expression.resolveType(scope);\r", "+\tif (lhsType == null || expressionType == null)\r", "-\tint lhsId = lhsTb.id;\r", "-\tint expressionId = expressionTb.id;\r", "-\tif (restrainUsageToNumericTypes() && !lhsTb.isNumericType()) {\r", "-\t\tscope.problemReporter().operatorOnlyValidOnNumericType(this, lhsTb, expressionTb);\r", "+\tint lhsId = lhsType.id;\r", "+\tint expressionId = expressionType.id;\r", "+\tif (restrainUsageToNumericTypes() && !lhsType.isNumericType()) {\r", "+\t\tscope.problemReporter().operatorOnlyValidOnNumericType(this, lhsType, expressionType);\r", "-\t\t\tscope.problemReporter().invalidOperator(this, lhsTb, expressionTb);\r", "+\t\t\tscope.problemReporter().invalidOperator(this, lhsType, expressionType);\r", "-\t\tscope.problemReporter().invalidOperator(this, lhsTb, expressionTb);\r", "+\t\tscope.problemReporter().invalidOperator(this, lhsType, expressionType);\r", "-\tif (operator == PLUS && scope.isJavaLangObject(lhsTb)) {\r", "-\t\t// Object o = \"hello\"; \r", "-\t\t// o += \" world\"  // <--illegal\r", "-\t\tscope.problemReporter().invalidOperator(this, lhsTb, expressionTb);\r", "-\t\treturn null;\r", "+\tif (operator == PLUS){\r", "+\t\tif(scope.isJavaLangObject(lhsType)) {\r", "+\t\t\t// <Object> += <String> is illegal\r", "+\t\t\tscope.problemReporter().invalidOperator(this, lhsType, expressionType);\r", "+\t\t\treturn null;\r", "+\t\t} else if (lhsType.isNumericType() && !expressionType.isNumericType()){\r", "+\t\t\t// <int> += <String> is illegal\r", "+\t\t\tscope.problemReporter().invalidOperator(this, lhsType, expressionType);\r", "+\t\t\treturn null;\r", "+\t\t}\r", "-\treturn lhsTb;\r", "+\treturn lhsType;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f1042b787c6f0c9ccbfec6ecfbbac48b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java", "commitBeforeChange": "d7e7bb059880a6c87ea3290708d2d0a9f9e7ebe8", "commitAfterChange": "a415220ad0bdc743d286b40ccc481ededfe8132e", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tTypeBinding expressionTb = expression.resolveType(scope);", "-\t\tif (expressionTb == null) {", "-\t\t\tconstant = NotAConstant;", "+\t\t", "+\t\tTypeBinding expressionType = this.expression.resolveType(scope);", "+\t\tif (expressionType == null) {", "+\t\t\tthis.constant = NotAConstant;", "-\t\tint expressionId = expressionTb.id;", "+\t\tint expressionId = expressionType.id;", "-\t\t\tconstant = NotAConstant;", "-\t\t\tscope.problemReporter().invalidOperator(this, expressionTb);", "+\t\t\tthis.constant = NotAConstant;", "+\t\t\tscope.problemReporter().invalidOperator(this, expressionType);", "-\t\texpression.implicitConversion = result >>> 12;", "-\t\tbits |= result & 0xF;", "+\t\tthis.expression.implicitConversion = result >>> 12;", "+\t\tthis.bits |= result & 0xF;", "-\t\t\t\tconstant = Constant.NotAConstant;", "+\t\t\t\tthis.constant = Constant.NotAConstant;", "-\t\t\t\t\tscope.problemReporter().invalidOperator(this, expressionTb);", "+\t\t\t\t\tscope.problemReporter().invalidOperator(this, expressionType);", "-\t\tif (expression.constant != Constant.NotAConstant) {", "-\t\t\tconstant =", "+\t\tif (this.expression.constant != Constant.NotAConstant) {", "+\t\t\tthis.constant =", "-\t\t\t\t\texpression.constant,", "+\t\t\t\t\tthis.expression.constant,", "-\t\t\tconstant = Constant.NotAConstant;", "+\t\t\tthis.constant = Constant.NotAConstant;", "-\t\t\t\tConstant cst = expression.conditionalConstant();", "-\t\t\t\tif (cst.typeID() == T_boolean)", "-\t\t\t\t\toptimizedBooleanConstant = Constant.fromValue(!cst.booleanValue());", "+\t\t\t\tConstant cst = expression.optimizedBooleanConstant();", "+\t\t\t\tif (cst != Constant.NotAConstant) ", "+\t\t\t\t\tthis.optimizedBooleanConstant = Constant.fromValue(!cst.booleanValue());"]}], "num": 54680}