{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2bbd92cb849ffe9d98e735ea14be9381", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "582bdbd7bd49448e2f5f663036c5b3dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "72398fb1bfc9de8f8d1c235c08849e28d61cb9f4", "commitAfterChange": "a52f17f8883dd812875c341ff752527a9011d961", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(TypeBinding targetType, final Scope skope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(TypeBinding targetType, final Scope skope)", "diff": ["-\t\t\tcopy = cachedResolvedCopy(targetType, argumentsTypeElided()); // if argument types are elided, we don't care for result expressions against *this* target, any port in a storm is ok.", "+\t\t\tcopy = cachedResolvedCopy(targetType, argumentsTypeElided()); // if argument types are elided, we don't care for result expressions against *this* target, any valid target is OK.", "-\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "-\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "-\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "-\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "-\t\ttry {", "-\t\t\t/* At this point, shape analysis is complete for ((see returnsExpression(...))", "-\t\t\t       - a lambda with an expression body,", "-\t\t\t\t   - a lambda with a block body in which we saw a return statement naked or otherwise.", "-\t\t\t*/", "-\t\t\tif (copy.body instanceof Block && !copy.returnsVoid && !copy.returnsValue && !copy.valueCompatible) {", "-\t\t\t\t// Do not proceed with data/control flow analysis if resolve encountered errors.", "-\t\t\t\tif (copy.hasIgnoredMandatoryErrors || enclosingScopesHaveErrors()) {", "-\t\t\t\t\tif (isPertinentToApplicability(targetType, null))", "-\t\t\t\t\t\tif (copy.arguments.length != 0) // ?? Needs check. ", "-\t\t\t\t\t\t\treturn false;", "-\t\t\t\t} else {", "-\t\t\t\t\tcopy.valueCompatible = copy.doesNotCompleteNormally();", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} finally {", "-\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;", "-\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t\t}", "-", "+\t\t// copy here is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and result expressions have been gathered."]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "73c116fca14d786864a7d8ae8c8e192a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "6cd0099c2021e34815eaba987a586ae52dacf569", "commitAfterChange": "d6dc74869d8c303dbb7a6d8b327d8b104cd5865b", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 39, "signatureBeforeChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "signatureAfterChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "diff": ["-\t\tLambdaExpression lambda = this.copiesPerTargetType != null ? this.copiesPerTargetType.get(targetType) : null;", "-\t\tif (lambda == null) {", "-\t\t\tlambda = getResolvedCopyForInferenceTargeting(targetType);", "-\t\t\tif (this.copiesPerTargetType == null)", "-\t\t\t\tthis.copiesPerTargetType = new HashMap<TypeBinding, LambdaExpression>();", "-\t\t\tthis.copiesPerTargetType.put(targetType, lambda);", "+\t\tLambdaExpression copy = null;", "+\t\ttry {", "+\t\t\tcopy = cachedResolvedCopy(targetType);", "+\t\t} catch (CopyFailureException cfe) {", "+\t\t\treturn null;", "-\t\treturn lambda;", "-\t}", "+\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "+\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "+\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "+\t\t\tif (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {", "+\t\t\t\tcopy.valueCompatible |= copy.doesNotCompleteNormally();"]}], "num": 50114}