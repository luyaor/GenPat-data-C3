{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "df4bdd63a5272fa857ac706697afd068", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1c8497a9fd1c44153bdb9d99e50d7306", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "99d47e4046e97803f75625986f5eb5ffc13cddfe", "commitAfterChange": "8282cb3c46786d73ca763e64384724ac9c0798d9", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tpublic void inferFromExpectedType(TypeBinding expectedType, Scope scope)", "signatureAfterChange": " \tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes)", "diff": ["-\t", "-\tpublic void inferFromExpectedType(TypeBinding expectedType, Scope scope) {", "-\t    if (this.returnType == expectedType) ", "-\t        return;", "-\t    if ((this.returnType.tagBits & TagBits.HasTypeVariable) == 0) ", "-\t        return;", "-\t    Map substitutes = new HashMap(1);", "-\t    int length = this.typeArguments.length;", "+\t */", "+\tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes) {", "-\t    boolean hasUnboundParameters = false;", "-\t    for (int i = 0; i < length; i++) {", "-\t        if (this.typeArguments[i] == originalVariables[i]) {", "-\t            hasUnboundParameters = true;", "-\t        \tsubstitutes.put(originalVariables[i], new TypeBinding[1]);", "-\t        } else {", "-\t        \tsubstitutes.put(originalVariables[i], new TypeBinding[] { this.typeArguments[i] });", "-\t        }", "-\t    }", "-\t    if (!hasUnboundParameters)", "-\t        return;", "-\t    returnType.collectSubstitutes(expectedType, substitutes);", "-\t    if (substitutes.isEmpty()) {", "-\t    \t// raw generic method inferred", "-\t    \tthis.isRaw = true;", "-\t    \tfor (int i = 0; i < length; i++) {", "-\t    \t\tthis.typeArguments[i] = originalVariables[i].erasure();", "-\t    \t}", "-\t    } else {", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tTypeBinding[] variableSubstitutes = (TypeBinding[]) substitutes.get(originalVariables[i]);", "-\t\t\t\tTypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);", "-\t\t\t\tif (mostSpecificSubstitute == null) {", "-\t\t\t\t    return; // TODO (philippe) should report no way to infer type", "-\t\t\t\t}", "-\t\t\t\tif (mostSpecificSubstitute == VoidBinding) {", "-\t\t\t\t\t// 15.12.2.8 - any remaining variable is assumed to be its erasure", "-\t\t\t\t\tmostSpecificSubstitute = originalVariables[i].erasure();", "-\t\t\t\t}\t\t\t\t", "-\t\t\t\tthis.typeArguments[i] = mostSpecificSubstitute;", "+\t\tint varLength = originalVariables.length;", "+\t\t", "+\t\tcomputeSubstitutes: {", "+\t\t    // infer from expected return type", "+\t\t\tif (expectedType != null) {", "+\t\t\t    returnType.collectSubstitutes(scope, expectedType, collectedSubstitutes, CONSTRAINT_SUPER);", "-\t    }", "+\t\t    // infer from bounds of type parameters", "+\t\t\tfor (int i = 0; i < varLength; i++) {", "+\t\t\t\tTypeVariableBinding originalVariable = originalVariables[i];", "+\t\t\t\tTypeBinding argument = this.typeArguments[i];", "+\t\t\t\tif (originalVariable.firstBound == originalVariable.superclass) {", "+\t\t\t\t\tScope.substitute(this, originalVariable.firstBound) // substitue original bound with resolved variables", "+\t\t\t\t\t\t.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t}", "+\t\t\t\tfor (int j = 0, max = originalVariable.superInterfaces.length; j < max; j++) {", "+\t\t\t\t\tScope.substitute(this, originalVariable.superInterfaces[j]) // substitue original bound with resolved variables", "+\t\t\t\t\t\t.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tsubstitutes = resolveSubstituteConstraints(scope, originalVariables, substitutes, true/*consider Ti<:Uk*/, collectedSubstitutes);", "+\t\t\tif (substitutes == null) ", "+\t\t\t\treturn null; // incompatible", "+\t\t\tif (substitutes.length == 0) {", "+\t\t    \t// raw generic method inferred", "+\t\t    \tthis.isRaw = true;", "+\t\t    \tfor (int i = 0; i < varLength; i++) {", "+\t\t    \t\tthis.typeArguments[i] = originalVariables[i].erasure();", "+\t\t    \t}", "+\t\t    \tbreak computeSubstitutes;", "+\t\t\t}", "+\t\t\t// this.typeArguments = substitutes; - no op since side effects got performed during #resolveSubstituteConstraints", "+\t    \tfor (int i = 0; i < varLength; i++) {", "+\t    \t\tTypeBinding substitute = substitutes[i];", "+\t    \t\tif (substitute != null) {", "+\t    \t\t\tthis.typeArguments[i] = substitutes[i];", "+\t    \t\t} else {", "+\t    \t\t\t// remaining unresolved variable are considered to be Object (or their bound actually)", "+\t\t    \t\tthis.typeArguments[i] = originalVariables[i].erasure();", "+\t\t    \t}", "+\t    \t}", "+\t\t}\t\t", "+\t\t// adjust method types to reflect latest inference", "+\t    return this;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7cf1acd09d4fb11df3c2908057141744", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "8d86c45b7dbc1d8316194b358e7234e4491fa695", "commitAfterChange": "0305482ace5c5443f44c914a225574b12096815b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \t \tpublic void inferFromExpectedType(TypeBinding expectedType, Scope scope)", "signatureAfterChange": " \t \tpublic void inferFromExpectedType(TypeBinding expectedType, Scope scope)", "diff": ["-        if ((this.returnType.tagBits & TagBits.HasTypeVariable) == 0) ", "-            return;", "-        Map substitutes = new HashMap(1);", "-        int length = this.typeArguments.length;", "-        TypeVariableBinding[] originalVariables = this.original().typeVariables;", "-        boolean hasUnboundParameters = false;", "-        for (int i = 0; i < length; i++) {", "-            if (this.typeArguments[i] == originalVariables[i]) {", "-                hasUnboundParameters = true;", "+\t    if ((this.returnType.tagBits & TagBits.HasTypeVariable) == 0) ", "+\t        return;", "+\t    Map substitutes = new HashMap(1);", "+\t    int length = this.typeArguments.length;", "+\t    TypeVariableBinding[] originalVariables = this.original().typeVariables;", "+\t    boolean hasUnboundParameters = false;", "+\t    for (int i = 0; i < length; i++) {", "+\t        if (this.typeArguments[i] == originalVariables[i]) {", "+\t            hasUnboundParameters = true;", "-            } else {", "+\t        } else {", "-            }", "-        }", "-        if (!hasUnboundParameters)", "-            return;", "-        returnType.collectSubstitutes(expectedType, substitutes);", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tTypeBinding[] variableSubstitutes = (TypeBinding[]) substitutes.get(originalVariables[i]);", "-\t\t\tTypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);", "-\t\t\tif (mostSpecificSubstitute == null) {", "-\t\t\t    return; // TODO (philippe) should report no way to infer type", "-\t\t\t}", "-\t\t\tif (mostSpecificSubstitute != VoidBinding) ", "+\t        }", "+\t    }", "+\t    if (!hasUnboundParameters)", "+\t        return;", "+\t    returnType.collectSubstitutes(expectedType, substitutes);", "+\t    if (substitutes.isEmpty()) {", "+\t    \t// raw generic method inferred", "+\t    \tthis.isRaw = true;", "+\t    \tfor (int i = 0; i < length; i++) {", "+\t    \t\tthis.typeArguments[i] = originalVariables[i].erasure();", "+\t    \t}", "+\t    } else {", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tTypeBinding[] variableSubstitutes = (TypeBinding[]) substitutes.get(originalVariables[i]);", "+\t\t\t\tTypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);", "+\t\t\t\tif (mostSpecificSubstitute == null) {", "+\t\t\t\t    return; // TODO (philippe) should report no way to infer type", "+\t\t\t\t}", "+\t\t\t\tif (mostSpecificSubstitute == VoidBinding) {", "+\t\t\t\t\t// 15.12.2.8 - any remaining variable is assumed to be Object", "+\t\t\t\t\tmostSpecificSubstitute = scope.getJavaLangObject();", "+\t\t\t\t}\t\t\t\t", "-\t\t}", "+\t\t\t}", "+\t    }"]}], "num": 36497}