{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "480c453c94d8afca1b8dd03d473c6f86", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ce789386a8b7f54714b354d0d8f954b4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "f6037f3e0e76e18ea82dd93d13e55dc410583456", "commitAfterChange": "a5577117cb4a612450eddce3c0b20eb90f21cb89", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tprivate boolean createExternalArchiveDelta(IProgressMonitor monitor)", "signatureAfterChange": " \tprivate boolean createExternalArchiveDelta(IProgressMonitor monitor)", "diff": ["-\t\t\t\t\tJavaProject project = (JavaProject) element;", "-\t\t\t\t\tif (!JavaProject.hasJavaNature(project.getProject())) {", "+\t\t\t\t\tJavaProject javaProject = (JavaProject) element;", "+\t\t\t\t\tif (!JavaProject.hasJavaNature(javaProject.getProject())) {", "-\t\t\t\t\t\tclasspath = project.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, false/*don't generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);", "+\t\t\t\t\t\tclasspath = javaProject.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, false/*don't generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);", "-\t\t\t\t\tIJavaProject[] projects;", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tprojects = this.manager.getJavaModel().getOldJavaProjectsList();", "-\t\t\t\t\t} catch (JavaModelException e1) {", "-\t\t\t\t\t\t// cannot retrieve old projects list -> ignore", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t}", "-\t\t\t\t\tfor (int j = 0, projectsLength = projects.length; j < projectsLength; j++){", "-\t\t\t\t\t\tproject = (JavaProject) projects[j];", "-\t\t\t\t\t\tif (!JavaProject.hasJavaNature(project.getProject())) {", "+\t\t\t\t\tIterator projectNames = this.state.getOldJavaProjecNames().iterator();", "+\t\t\t\t\twhile (projectNames.hasNext()) {", "+\t\t\t\t\t\tString projectName = (String) projectNames.next();", "+\t\t\t\t\t\tIProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);", "+\t\t\t\t\t\tif (!JavaProject.hasJavaNature(project)) {", "+\t\t\t\t\t\tjavaProject = (JavaProject) JavaCore.create(project);", "-\t\t\t\t\t\t\tclasspath = project.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, false/*don't generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);", "+\t\t\t\t\t\t\tclasspath = javaProject.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, false/*don't generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);", "-\t\tIJavaProject[] projects;", "-\t\ttry {", "-\t\t\tprojects = this.manager.getJavaModel().getOldJavaProjectsList();", "-\t\t} catch (JavaModelException e) {", "-\t\t\t// cannot retrieve old projects list -> give up", "-\t\t\treturn false;", "-\t\t}", "+\t\tIterator projectNames = this.state.getOldJavaProjecNames().iterator();", "-\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\twhile (projectNames.hasNext()) {", "-\t\t\tJavaProject project = (JavaProject) projects[i];", "-\t\t\tif (!JavaProject.hasJavaNature(project.getProject())) {", "+\t\t\tString projectName = (String) projectNames.next();", "+\t\t\tIProject project = wksRoot.getProject(projectName);", "+\t\t\tif (!JavaProject.hasJavaNature(project)) {", "+\t\t\tJavaProject javaProject = (JavaProject) JavaCore.create(project);", "-\t\t\t\tentries = project.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, false/*don't generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);", "+\t\t\t\tentries = javaProject.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, false/*don't generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);", "-\t\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)project.getPackageFragmentRoot(entryPath.toString());", "+\t\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot) javaProject.getPackageFragmentRoot(entryPath.toString());", "-\t\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)project.getPackageFragmentRoot(entryPath.toString());", "+\t\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot) javaProject.getPackageFragmentRoot(entryPath.toString());", "-\t\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)project.getPackageFragmentRoot(entryPath.toString());", "+\t\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot) javaProject.getPackageFragmentRoot(entryPath.toString());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d3d4b4c96e5e9c58abc4d97a4b34346f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST3_2.java", "commitBeforeChange": "02975100ed17446fdc81602d5e551e37445d3dd6", "commitAfterChange": "6cb413dbd992ad73f847d7b4e14e78f1406fa2fc", "methodNumberBeforeChange": 300, "methodNumberAfterChange": 300, "signatureBeforeChange": " \tpublic void _test0655() throws JavaModelException", "signatureAfterChange": " \tpublic void _test0655()", "diff": ["-\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=156352", "-\tpublic void _test0655() throws JavaModelException {", "-\t\tICompilationUnit workingCopy = null;", "-\t\tICompilationUnit workingCopy2 = null;", "-\t\ttry {", "-   \t\t\tString contents =", "-\t\t\t\t\"package p;\\n\" +", "-\t\t\t\t\"public class Test1 {}\";", "-\t\t\tworkingCopy = getWorkingCopy(\"/Converter/src/p/Test1.java\", true/*resolve*/);", "-\t\t\tworkingCopy.getBuffer().setContents(contents);", "-\t\t\tworkingCopy.save(null, true);", "-\t\t\t", "-   \t\t\tcontents =", "-\t\t\t\t\"package p;\\n\" +", "-\t\t\t\t\"public class Test3 extends Test1 {}\";", "-\t\t\tworkingCopy2 = getWorkingCopy(\"/Converter/src/p/Test3.java\", true/*resolve*/);", "-\t\t\tworkingCopy2.getBuffer().setContents(contents);", "-\t\t\tworkingCopy2.save(null, true);", "-\t\t\tIType type = workingCopy2.getType(\"Test3\");", "-\t\t\t", "-\t\t\tASTParser parser= ASTParser.newParser(AST.JLS3);", "-    \t\tparser.setProject(type.getJavaProject());", "-    \t\tIBinding[] bindings= parser.createBindings(new IJavaElement[] { type }, null);", "-    \t\tif (bindings.length == 1 && bindings[0] instanceof ITypeBinding) {", "-    \t\t\tITypeBinding binding= (ITypeBinding) bindings[0];", "-    \t\t\twhile (binding != null) {", "-    \t\t\t\tbinding.getAnnotations(); // NPE here on 'Test1'", "-    \t\t\t\tbinding= binding.getSuperclass();", "-    \t\t\t}", "-    \t\t}", "-\t\t} finally {", "-\t\t\tif (workingCopy != null)", "-\t\t\t\tworkingCopy.discardWorkingCopy();", "-\t\t\tif (workingCopy2 != null)", "-\t\t\t\tworkingCopy2.discardWorkingCopy();", "+\t */", "+\tpublic void _test0655() {", "+\t\tString src = \"public static void m1()\\n\" + ", "+\t\t\t\t\"    {\\n\" + ", "+\t\t\t\t\"        int a;\\n\" + ", "+\t\t\t\t\"        int b;\\n\" + ", "+\t\t\t\t\"    }\\n\" + ", "+\t\t\t\t\"\\n\" + ", "+\t\t\t\t\"    public static void m2()\\n\" + ", "+\t\t\t\t\"    {\\n\" + ", "+\t\t\t\t\"        int c;\\n\" + ", "+\t\t\t\t\"        int d;\\n\" + ", "+\t\t\t\t\"    }\";", "+\t\tchar[] source = src.toCharArray();", "+\t\tASTParser parser = ASTParser.newParser(AST.JLS3);", "+\t\tparser.setKind (ASTParser.K_STATEMENTS);", "+\t\tparser.setStatementsRecovery(true);", "+\t\tparser.setSource (source);", "+\t\tASTNode result = parser.createAST (null);", "+\t\tassertNotNull(\"no result\", result);", "+\t\tassertEquals(\"Not a block\", ASTNode.BLOCK, result.getNodeType());", "+\t\tBlock block = (Block) result;", "+\t\tList statements = block.statements();", "+\t\tfor (Iterator iterator = statements.iterator(); iterator.hasNext(); ) {", "+\t\t\tStatement statement = (Statement) iterator.next();", "+\t\t\tassertTrue(isMalformed(statement));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d8ad0ff26269d2cc539568de2b8e616c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java", "commitBeforeChange": "14ba43da4ca84e6aa2e4b0e2b6c660335b90691e", "commitAfterChange": "b7f39314c9eefd05e7002c31c87dcdb0333c0655", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic final static boolean isArchiveFileName(String name)", "signatureAfterChange": " \tpublic final static boolean isPotentialZipArchive(String name)", "diff": ["-\tpublic final static boolean isArchiveFileName(String name) {", "-\t\tint nameLength = name == null ? 0 : name.length();", "-\t\tint suffixLength = SUFFIX_JAR.length;", "-\t\tif (nameLength < suffixLength) return false;", "-", "-\t\t// try to match as JAR file", "-\t\tfor (int i = 0; i < suffixLength; i++) {", "-\t\t\tchar c = name.charAt(nameLength - i - 1);", "-\t\t\tint suffixIndex = suffixLength - i - 1;", "-\t\t\tif (c != SUFFIX_jar[suffixIndex] && c != SUFFIX_JAR[suffixIndex]) {", "-", "-\t\t\t\t// try to match as ZIP file", "-\t\t\t\tsuffixLength = SUFFIX_ZIP.length;", "-\t\t\t\tif (nameLength < suffixLength) return false;", "-\t\t\t\tfor (int j = 0; j < suffixLength; j++) {", "-\t\t\t\t\tc = name.charAt(nameLength - j - 1);", "-\t\t\t\t\tsuffixIndex = suffixLength - j - 1;", "-\t\t\t\t\tif (c != SUFFIX_zip[suffixIndex] && c != SUFFIX_ZIP[suffixIndex]) return false;", "+\tpublic final static boolean isPotentialZipArchive(String name) {", "+\t\tint lastDot = name.lastIndexOf('.');", "+\t\tif (lastDot == -1)", "+\t\t\treturn false; // no file extension, it cannot be a zip archive name", "+\t\tif (name.lastIndexOf(File.separatorChar) > lastDot)", "+\t\t\treturn false; // dot was before the last file separator, it cannot be a zip archive name", "+\t\tint length = name.length();", "+\t\tint extensionLength = length - lastDot - 1;", "+\t\tif (extensionLength == EXTENSION_java.length()) {", "+\t\t\tfor (int i = extensionLength-1; i >=0; i--) {", "+\t\t\t\tif (Character.toLowerCase(name.charAt(length - extensionLength + i)) != EXTENSION_java.charAt(i)) {", "+\t\t\t\t\tbreak; // not a \".java\" file, check \".class\" file case below", "-\t\t\t\treturn true;", "+\t\t\t\tif (i == 0) {", "+\t\t\t\t\treturn false; // it is a \".java\" file, it cannot be a zip archive name", "+\t\t\t\t}", "-\t\treturn true;\t\t", "-\t}\t", "+\t\tif (extensionLength == EXTENSION_class.length()) {", "+\t\t\tfor (int i = extensionLength-1; i >=0; i--) {", "+\t\t\t\tif (Character.toLowerCase(name.charAt(length - extensionLength + i)) != EXTENSION_class.charAt(i)) {", "+\t\t\t\t\treturn true; // not a \".class\" file, so this is a potential archive name", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn false; // it is a \".class\" file, it cannot be a zip archive name", "+\t\t}", "+\t\treturn true; // it is neither a \".java\" file nor a \".class\" file, so this is a potential archive name", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fb246c3dfd124d148521008e0990099f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/FieldLocator.java", "commitBeforeChange": "9ee78f50bb7fb9d70095ea7ff2d9f2e27d840c37", "commitAfterChange": "b6410432af18704990f18fa69a09dd7a76e8fb04", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " protected void matchReportReference(ASTNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": " protected void matchReportReference(ASTNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "diff": ["-\t\tSearchMatch match = locator.newFieldReferenceMatch(element, accuracy, start, end-start+1, importRef);", "+\t\tmatch = locator.newFieldReferenceMatch(element, accuracy, start, end-start+1, importRef);", "-\t\tSearchMatch match = locator.newFieldReferenceMatch(element, accuracy, start, end-start+1, fieldReference);", "+\t\tmatch = locator.newFieldReferenceMatch(element, accuracy, start, end-start+1, fieldReference);", "-\t\tSearchMatch match = locator.newFieldReferenceMatch(element, accuracy, offset, reference.sourceEnd-offset+1, reference);", "+\t\tmatch = locator.newFieldReferenceMatch(element, accuracy, offset, reference.sourceEnd-offset+1, reference);", "-\t\tint[] accuracies = new int[length];", "+\t\tSearchMatch[] matches = new SearchMatch[length];", "-\t\tfor (int i = 0; i < indexOfFirstFieldBinding; i++)", "-\t\t\taccuracies[i] = -1;", "+", "-\t\t\t\taccuracies[indexOfFirstFieldBinding] = accuracy;", "+\t\t\t\tmatches[indexOfFirstFieldBinding] = locator.newFieldReferenceMatch(element, accuracy, -1, -1, reference);", "-\t\t\t\t\t\taccuracies[indexOfFirstFieldBinding] = SearchMatch.A_ACCURATE;", "+\t\t\t\t\t\tmatches[indexOfFirstFieldBinding] = locator.newFieldReferenceMatch(element, SearchMatch.A_ACCURATE, -1, -1, reference);", "-\t\t\t\t\t\tif (fieldBinding.type.isParameterizedType() && this.pattern.hasTypeArguments())", "-\t\t\t\t\t\t\taccuracies[indexOfFirstFieldBinding] = refineAccuracy(SearchMatch.A_INACCURATE, (ParameterizedTypeBinding) fieldBinding.type, this.pattern.getTypeArguments(), locator);", "-\t\t\t\t\t\telse", "-\t\t\t\t\t\t\taccuracies[indexOfFirstFieldBinding] = SearchMatch.A_INACCURATE;", "+\t\t\t\t\t\tmatch = locator.newFieldReferenceMatch(element, SearchMatch.A_INACCURATE, -1, -1, reference);", "+\t\t\t\t\t\tif (fieldBinding.type.isParameterizedType() && this.pattern.hasTypeArguments()) {", "+\t\t\t\t\t\t\tupdateMatch((ParameterizedTypeBinding) fieldBinding.type, this.pattern.getTypeArguments(), locator);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tmatches[indexOfFirstFieldBinding] = match;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\taccuracies[indexOfFirstFieldBinding] = -1;", "-\t\t} else {", "-\t\t\taccuracies[indexOfFirstFieldBinding] = -1;", "+", "-\t\t\t\t\taccuracies[i] = accuracy;", "+\t\t\t\t\tmatches[i] = locator.newFieldReferenceMatch(element, accuracy, -1, -1, reference);", "-\t\t\t\t\t\t\taccuracies[i] = SearchMatch.A_ACCURATE;", "+\t\t\t\t\t\t\tmatches[i] = locator.newFieldReferenceMatch(element, SearchMatch.A_ACCURATE, -1, -1, reference);", "-\t\t\t\t\t\t\tif (otherBinding.type.isParameterizedType() && this.pattern.hasTypeArguments())", "-\t\t\t\t\t\t\t\taccuracies[i] = refineAccuracy(SearchMatch.A_INACCURATE, (ParameterizedTypeBinding) otherBinding.type, this.pattern.getTypeArguments(), locator);", "-\t\t\t\t\t\t\telse", "-\t\t\t\t\t\t\t\taccuracies[i] = SearchMatch.A_INACCURATE;", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\taccuracies[i] = -1;", "+\t\t\t\t\t\t\tmatch = locator.newFieldReferenceMatch(element, SearchMatch.A_INACCURATE, -1, -1, reference);", "+\t\t\t\t\t\t\tif (otherBinding.type.isParameterizedType() && this.pattern.hasTypeArguments()) {", "+\t\t\t\t\t\t\t\tupdateMatch((ParameterizedTypeBinding) otherBinding.type, this.pattern.getTypeArguments(), locator);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tmatches[indexOfFirstFieldBinding] = match;", "+\t\t\t\t\t\t\tbreak;", "-\t\t\t} else {", "-\t\t\t\taccuracies[i] = -1;", "-\t\tlocator.reportAccurateFieldReference(qNameRef, element, accuracies);", "+\t\tlocator.reportAccurateFieldReference(matches, qNameRef);"]}], "num": 271}