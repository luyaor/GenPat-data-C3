{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1c560499f747bda5cb4f0d30569eeed5", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4828bb5da696da568d771e406ec4807d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "673b7eda95cd26449992e862f0c63f2c612903a0", "commitAfterChange": "b04602938404af4f8569a399fb36a5018768a262", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \r \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "\r public TypeBinding resolveType(BlockScope scope)", "diff": ["+}\r", "+public TypeBinding resolveType(BlockScope scope) {\r", "+\t// Answer the signature return type\r", "+\t// Base type promotion\r", "+\tconstant = NotAConstant;\r", "+\tthis.receiverType = receiver.resolveType(scope); \r", "+\t// will check for null after args are resolved\r", "+\tTypeBinding[] argumentTypes = NoParameters;\r", "+\tif (arguments != null) {\r", "+\t\tboolean argHasError = false; // typeChecks all arguments \r", "+\t\tint length = arguments.length;\r", "+\t\targumentTypes = new TypeBinding[length];\r", "+\t\tfor (int i = 0; i < length; i++)\r", "+\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)\r", "+\t\t\t\targHasError = true;\r", "+\t\tif (argHasError)\r", "+\t\t\treturn null;\r", "+\t}\r", "+\tif (this.receiverType == null)\r", "+\t\treturn null;\r", "+\r", "+\t// base type cannot receive any message\r", "+\tif (this.receiverType.isBaseType()) {\r", "+\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);\r", "+\t\treturn null;\r", "+\t}\r", "+\r", "+\tbinding = \r", "+\t\treceiver == ThisReference.ThisImplicit\r", "+\t\t\t? scope.getImplicitMethod(selector, argumentTypes, this)\r", "+\t\t\t: scope.getMethod(this.receiverType, selector, argumentTypes, this); \r", "+\tif (!binding.isValidBinding()) {\r", "+\t\tif (binding.declaringClass == null) {\r", "+\t\t\tif (this.receiverType instanceof ReferenceBinding) {\r", "+\t\t\t\tbinding.declaringClass = (ReferenceBinding) this.receiverType;\r", "+\t\t\t} else { // really bad error ....\r", "+\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);\r", "+\t\t\t\treturn null;\r", "+\t\t}\r", "+\t\tscope.problemReporter().invalidMethod(this, binding);\r", "+\t\treturn null;\r", "+\t}\r", "+\tif (!binding.isStatic()) {\r", "+\t\t// the \"receiver\" must not be a type, i.e. a NameReference that the TC has bound to a Type\r", "+\t\tif (receiver instanceof NameReference) {\r", "+\t\t\tif ((((NameReference) receiver).bits & BindingIds.TYPE) != 0) {\r", "+\t\t\t\tscope.problemReporter().mustUseAStaticMethod(this, binding);\r", "+\t\t\t\treturn null;\r", "+\tif (arguments != null)\r", "+\t\tfor (int i = 0; i < arguments.length; i++)\r", "+\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);\r", "-\tpublic TypeBinding resolveType(BlockScope scope) {\r", "-\t\t// Answer the signature return type\r", "-\t\t// Base type promotion\r", "-\r", "-\t\tconstant = NotAConstant;\r", "-\t\tTypeBinding receiverType = receiver.resolveType(scope);\r", "-\t\t// will check for null after args are resolved\r", "-\t\tTypeBinding[] argumentTypes = NoParameters;\r", "+\t//-------message send that are known to fail at compile time-----------\r", "+\tif (binding.isAbstract()) {\r", "+\t\tif (receiver.isSuper()) {\r", "+\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);\r", "+\t\t\treturn null;\r", "+\t\t}\r", "+\t\t// abstract private methods cannot occur nor abstract static............\r", "+\t}\r", "+\tif (isMethodUseDeprecated(binding, scope))\r", "+\t\tscope.problemReporter().deprecatedMethod(binding, this);\r", "+\t// if the binding declaring class is not visible, need special action\r", "+\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "+\tif (binding.declaringClass != this.receiverType\r", "+\t\t&& !binding.declaringClass.canBeSeenBy(scope))\r", "+\t\tbinding = new MethodBinding(binding, (ReferenceBinding) this.receiverType);\r", "+\treturn binding.returnType;\r", "+}\r", "-\t\t\tboolean argHasError = false; // typeChecks all arguments \r", "-\t\t\tint length = arguments.length;\r", "-\t\t\targumentTypes = new TypeBinding[length];\r", "-\t\t\tfor (int i = 0; i < length; i++)\r", "-\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)\r", "-\t\t\t\t\targHasError = true;\r", "-\t\t\tif (argHasError)\r", "-\t\t\t\treturn null;\r", "-\t\t}\r", "-\t\tif (receiverType == null)\r", "-\t\t\treturn null;\r", "-\r", "-\t\t// base type cannot receive any message\r", "-\t\tif (receiverType.isBaseType()) {\r", "-\t\t\tscope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);\r", "-\t\t\treturn null;\r", "-\t\t}\r", "-\r", "-\t\tbinding =\r", "-\t\t\treceiver == ThisReference.ThisImplicit\r", "-\t\t\t\t? scope.getImplicitMethod(selector, argumentTypes, this)\r", "-\t\t\t\t: scope.getMethod(receiverType, selector, argumentTypes, this);\r", "-\t\tif (!binding.isValidBinding()) {\r", "-\t\t\tif (binding.declaringClass == null) {\r", "-\t\t\t\tif (receiverType instanceof ReferenceBinding) {\r", "-\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) receiverType;\r", "-\t\t\t\t} else { // really bad error ....\r", "-\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);\r", "-\t\t\t\t\treturn null;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tscope.problemReporter().invalidMethod(this, binding);\r", "-\t\t\treturn null;\r", "-\t\t}\r", "-\t\tif (!binding.isStatic()) {\r", "-\t\t\t// the \"receiver\" must not be a type, i.e. a NameReference that the TC has bound to a Type\r", "-\t\t\tif (receiver instanceof NameReference) {\r", "-\t\t\t\tif ((((NameReference) receiver).bits & BindingIds.TYPE) != 0) {\r", "-\t\t\t\t\tscope.problemReporter().mustUseAStaticMethod(this, binding);\r", "-\t\t\t\t\treturn null;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\tif (arguments != null)\r", "-\t\t\tfor (int i = 0; i < arguments.length; i++)\r", "-\t\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);\r", "-\r", "-\t\t//-------message send that are known to fail at compile time-----------\r", "-\t\tif (binding.isAbstract()) {\r", "-\t\t\tif (receiver.isSuper()) {\r", "-\t\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);\r", "-\t\t\t\treturn null;\r", "-\t\t\t}\r", "-\t\t\t// abstract private methods cannot occur nor abstract static............\r", "-\t\t}\r", "-\t\tif (isMethodUseDeprecated(binding, scope))\r", "-\t\t\tscope.problemReporter().deprecatedMethod(binding, this);\r", "-\t\t// if the binding declaring class is not visible, need special action\r", "-\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "-\t\tif (binding.declaringClass != receiverType\r", "-\t\t\t&& !binding.declaringClass.canBeSeenBy(scope))\r", "-\t\t\tbinding = new MethodBinding(binding, (ReferenceBinding) receiverType);\r", "-\t\treturn binding.returnType;\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "496bea1739243c9c6f2f515a6dc52795", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java", "commitBeforeChange": "302df05b099c1ea06faca0b00f806513c7db6904", "commitAfterChange": "c661afbb38268ca6f18a772df813f6c69bb9e17c", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tconstant = NotAConstant;", "-\tthis.qualifyingType = this.receiverType = receiver.resolveType(scope); ", "+\tthis.constant = NotAConstant;", "+\tthis.qualifyingType = this.receiverType = this.receiver.resolveType(scope); ", "-\tif (arguments != null) {", "+\tif (this.arguments != null) {", "-\t\tint length = arguments.length;", "+\t\tint length = this.arguments.length;", "-\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)", "+\t\t\tif ((argumentTypes[i] = this.arguments[i].resolveType(scope)) == null)", "-\tif (receiverType == null) ", "+\tif (this.receiverType == null) ", "-\tif (receiverType.isBaseType()) {", "-\t\tscope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);", "+\tif (this.receiverType.isBaseType()) {", "+\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);", "-\tbinding = ", "-\t\treceiver.isImplicitThis()", "-\t\t\t? scope.getImplicitMethod(selector, argumentTypes, this)", "-\t\t\t: scope.getMethod(receiverType, selector, argumentTypes, this); ", "-\tif (!binding.isValidBinding()) {", "-\t\tif (binding instanceof ProblemMethodBinding", "-\t\t\t&& ((ProblemMethodBinding) binding).problemId() == NotVisible) {", "+\tthis.binding = ", "+\t\tthis.receiver.isImplicitThis()", "+\t\t\t? scope.getImplicitMethod(this.selector, argumentTypes, this)", "+\t\t\t: scope.getMethod(this.receiverType, this.selector, argumentTypes, this); ", "+\tif (!this.binding.isValidBinding()) {", "+\t\tif (this.binding instanceof ProblemMethodBinding", "+\t\t\t&& ((ProblemMethodBinding) this.binding).problemId() == NotVisible) {", "-\t\t\t\tdelegateThis = scope.getField(scope.enclosingSourceType(), DELEGATE_THIS, this);", "-\t\t\t\tif (delegateThis == null){ // if not found then internal error, field should have been found", "-\t\t\t\t\tconstant = NotAConstant;", "-\t\t\t\t\tscope.problemReporter().invalidMethod(this, binding);", "+\t\t\t\tthis.delegateThis = scope.getField(scope.enclosingSourceType(), DELEGATE_THIS, this);", "+\t\t\t\tif (this.delegateThis == null){ // if not found then internal error, field should have been found", "+\t\t\t\t\tthis.constant = NotAConstant;", "+\t\t\t\t\tscope.problemReporter().invalidMethod(this, this.binding);", "-\t\t\t\tconstant = NotAConstant;", "-\t\t\t\tscope.problemReporter().invalidMethod(this, binding);", "+\t\t\t\tthis.constant = NotAConstant;", "+\t\t\t\tscope.problemReporter().invalidMethod(this, this.binding);", "-\t\t\t\treceiver instanceof CodeSnippetThisReference && ((CodeSnippetThisReference) receiver).isImplicit", "-\t\t\t\t\t? localScope.getImplicitMethod((ReferenceBinding)delegateThis.type, selector, argumentTypes, this)", "-\t\t\t\t\t: localScope.getMethod(delegateThis.type, selector, argumentTypes, this); ", "+\t\t\t\tthis.receiver instanceof CodeSnippetThisReference && ((CodeSnippetThisReference) this.receiver).isImplicit", "+\t\t\t\t\t? localScope.getImplicitMethod((ReferenceBinding)this.delegateThis.type, this.selector, argumentTypes, this)", "+\t\t\t\t\t: localScope.getMethod(this.delegateThis.type, this.selector, argumentTypes, this); ", "-\t\t\t\tif (binding.declaringClass == null) {", "-\t\t\t\t\tif (receiverType instanceof ReferenceBinding) {", "-\t\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) receiverType;", "+\t\t\t\tif (this.binding.declaringClass == null) {", "+\t\t\t\t\tif (this.receiverType instanceof ReferenceBinding) {", "+\t\t\t\t\t\tthis.binding.declaringClass = (ReferenceBinding) this.receiverType;", "-\t\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);", "+\t\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);", "-\t\t\t\tscope.problemReporter().invalidMethod(this, binding);", "+\t\t\t\tscope.problemReporter().invalidMethod(this, this.binding);", "-\t\t\t\tbinding = privateBinding;", "+\t\t\t\tthis.binding = privateBinding;", "-\t\t\tif (binding.declaringClass == null) {", "-\t\t\t\tif (receiverType instanceof ReferenceBinding) {", "-\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) receiverType;", "+\t\t\tif (this.binding.declaringClass == null) {", "+\t\t\t\tif (this.receiverType instanceof ReferenceBinding) {", "+\t\t\t\t\tthis.binding.declaringClass = (ReferenceBinding) this.receiverType;", "-\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);", "+\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);", "-\t\t\tscope.problemReporter().invalidMethod(this, binding);", "+\t\t\tscope.problemReporter().invalidMethod(this, this.binding);", "-\tif (!binding.isStatic()) {", "+\tif (!this.binding.isStatic()) {", "-\t\tif (receiver instanceof NameReference) {", "-\t\t\tif ((((NameReference) receiver).bits & BindingIds.TYPE) != 0) {", "-\t\t\t\tscope.problemReporter().mustUseAStaticMethod(this, binding);", "+\t\tif (this.receiver instanceof NameReference) {", "+\t\t\tif ((((NameReference) this.receiver).bits & BindingIds.TYPE) != 0) {", "+\t\t\t\tscope.problemReporter().mustUseAStaticMethod(this, this.binding);", "-\tif (arguments != null)", "-\t\tfor (int i = 0; i < arguments.length; i++)", "-\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);", "+\tif (this.arguments != null)", "+\t\tfor (int i = 0; i < this.arguments.length; i++)", "+\t\t\tthis.arguments[i].implicitWidening(this.binding.parameters[i], argumentTypes[i]);", "-\tif (binding.isAbstract()) {", "-\t\tif (receiver.isSuper()) {", "-\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);", "+\tif (this.binding.isAbstract()) {", "+\t\tif (this.receiver.isSuper()) {", "+\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, this.binding);", "-\tif (isMethodUseDeprecated(binding, scope))", "-\t\tscope.problemReporter().deprecatedMethod(binding, this);", "+\tif (isMethodUseDeprecated(this.binding, scope))", "+\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "-\treturn this.resolvedType = binding.returnType;", "+\treturn this.resolvedType = this.binding.returnType;"]}], "num": 29546}