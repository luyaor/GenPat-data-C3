{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e967134720e9474b18263030f354756e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35f2996320b7d71d6a0a7f961fb20f58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "e5e6f9097f2c3bf7294bd658643d6be9f7aaa5ef", "commitAfterChange": "d00bc48524f3df289951f11fca95cb39820be47f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "\r \r \tpublic FlowInfo analyseCode(\r \t\tBlockScope currentScope,\r \t\tFlowContext flowContext,\r \t\tFlowInfo flowInfo)", "diff": ["-}\r", "-public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {\r", "-\tConstant inlinedCondition = condition.constant;\r", "-\tif (inlinedCondition == NotAConstant) inlinedCondition = condition.conditionalConstant();\r", "-\tif (inlinedCondition != NotAConstant) {\r", "-\t\tif (inlinedCondition.booleanValue() == true) {\r", "-\t\t\tFlowInfo resultInfo = valueIfTrue.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\t// analyse valueIfFalse, but do not take into account any of its infos\r", "-\t\t\tvalueIfFalse.analyseCode(currentScope, flowContext, flowInfo.copy().markAsFakeReachable(true));\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(resultInfo);\r", "-\t\t\treturn resultInfo;\r", "-\t\t} else {\r", "-\t\t\t// analyse valueIfTrue, but do not take into account any of its infos\t\t\t\r", "-\t\t\tvalueIfTrue.analyseCode(currentScope, flowContext, flowInfo.copy().markAsFakeReachable(true));\r", "-\t\t\tFlowInfo mergeInfo = valueIfFalse.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergeInfo);\r", "-\t\t\treturn mergeInfo;\r", "-\t\t}\r", "-\t}\r", "-\t// notice that the receiver investigation is not performed in the previous case, since there is\r", "-\t// not a chance it is worth trying to check anything on a constant expression.\r", "-\tflowInfo = condition.analyseCode(currentScope, flowContext, flowInfo);\r", "-\r", "-\t// store a copy of the merged info, so as to compute the local variable attributes afterwards\r", "-\tFlowInfo trueInfo = flowInfo.initsWhenTrue();\r", "-\tthenInitStateIndex = currentScope.methodScope().recordInitializationStates(trueInfo);\r", "-\tFlowInfo falseInfo = flowInfo.initsWhenFalse();\r", "-\telseInitStateIndex = currentScope.methodScope().recordInitializationStates(falseInfo);\r", "-\t// propagate analysis\r", "-\ttrueInfo = valueIfTrue.analyseCode(currentScope, flowContext, trueInfo.copy());\r", "-\tfalseInfo = valueIfFalse.analyseCode(currentScope, flowContext, falseInfo.copy());\r", "-\t\r", "-\t// merge back using a conditional info -  1GK2BLM\r", "-\t// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok\r", "-\tFlowInfo mergedInfo = FlowInfo.conditional(\r", "-\t\ttrueInfo.initsWhenTrue().unconditionalInits().mergedWith(\r", "-\t\t\tfalseInfo.initsWhenTrue().unconditionalInits()),\r", "-\t\tfalseInfo.initsWhenFalse().unconditionalInits().mergedWith(\r", "-\t\t\tfalseInfo.initsWhenFalse().unconditionalInits()));\r", "-/*\t\t\t\r", "-\tFlowInfo mergedInfo = valueIfTrue.analyseCode(\r", "-\t\tcurrentScope,\r", "-\t\tflowContext,\r", "-\t\tflowInfo.initsWhenTrue().copy()).\r", "-\t\t\tunconditionalInits().\r", "-\t\t\t\tmergedWith(\r", "-\t\t\t\t\tvalueIfFalse.analyseCode(\r", "-\t\t\t\t\t\tcurrentScope,\r", "-\t\t\t\t\t\tflowContext,\r", "-\t\t\t\t\t\tflowInfo.initsWhenFalse().copy()).\r", "-\t\t\t\t\t\t\tunconditionalInits());\r", "-*/\t\t\t\t\t\t\t\r", "-\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\treturn mergedInfo;\r", "-}\r", "+\tpublic FlowInfo analyseCode(\r", "+\t\tBlockScope currentScope,\r", "+\t\tFlowContext flowContext,\r", "+\t\tFlowInfo flowInfo) {\r", "+\t\tConstant conditionConstant = condition.conditionalConstant();\r", "+\t\tif (conditionConstant != NotAConstant) {\r", "+\t\t\tif (conditionConstant.booleanValue() == true) {\r", "+\t\t\t\t// TRUE ? left : right\r", "+\t\t\t\tFlowInfo resultInfo =\r", "+\t\t\t\t\tvalueIfTrue.analyseCode(currentScope, flowContext, flowInfo);\r", "+\t\t\t\t// analyse valueIfFalse, but do not take into account any of its infos\r", "+\t\t\t\tvalueIfFalse.analyseCode(\r", "+\t\t\t\t\tcurrentScope,\r", "+\t\t\t\t\tflowContext,\r", "+\t\t\t\t\tflowInfo.copy().markAsFakeReachable(true));\r", "+\t\t\t\tmergedInitStateIndex =\r", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(resultInfo);\r", "+\t\t\t\treturn resultInfo;\r", "+\t\t\t} else {\r", "+\t\t\t\t// FALSE ? left : right\r", "+\t\t\t\t// analyse valueIfTrue, but do not take into account any of its infos\t\t\t\r", "+\t\t\t\tvalueIfTrue.analyseCode(\r", "+\t\t\t\t\tcurrentScope,\r", "+\t\t\t\t\tflowContext,\r", "+\t\t\t\t\tflowInfo.copy().markAsFakeReachable(true));\r", "+\t\t\t\tFlowInfo mergeInfo =\r", "+\t\t\t\t\tvalueIfFalse.analyseCode(currentScope, flowContext, flowInfo);\r", "+\t\t\t\tmergedInitStateIndex =\r", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergeInfo);\r", "+\t\t\t\treturn mergeInfo;\r", "+\t\t// notice that the receiver investigation is not performed in the previous case, since there is\r", "+\t\t// not a chance it is worth trying to check anything on a constant expression.\r", "+\t\tflowInfo = condition.analyseCode(currentScope, flowContext, flowInfo);\r", "+\t\t// store a copy of the merged info, so as to compute the local variable attributes afterwards\r", "+\t\tFlowInfo trueInfo = flowInfo.initsWhenTrue();\r", "+\t\tthenInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(trueInfo);\r", "+\t\tFlowInfo falseInfo = flowInfo.initsWhenFalse();\r", "+\t\telseInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(falseInfo);\r", "+\r", "+\t\t// propagate analysis\r", "+\t\ttrueInfo = valueIfTrue.analyseCode(currentScope, flowContext, trueInfo.copy());\r", "+\t\tfalseInfo =\r", "+\t\t\tvalueIfFalse.analyseCode(currentScope, flowContext, falseInfo.copy());\r", "+\r", "+\t\t// merge back using a conditional info -  1GK2BLM\r", "+\t\t// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok\r", "+\t\tFlowInfo mergedInfo =\r", "+\t\t\tFlowInfo.conditional(\r", "+\t\t\t\ttrueInfo.initsWhenTrue().copy().unconditionalInits().mergedWith( // must copy, since could be shared with trueInfo.initsWhenFalse()...\r", "+\t\t\t\t\tfalseInfo.initsWhenTrue().copy().unconditionalInits()),\r", "+\t\t\t\ttrueInfo.initsWhenFalse().unconditionalInits().mergedWith(\r", "+\t\t\t\t\tfalseInfo.initsWhenFalse().unconditionalInits()));\r", "+\t\t/*\t\t\t\r", "+\t\t\tFlowInfo mergedInfo = valueIfTrue.analyseCode(\r", "+\t\t\t\tcurrentScope,\r", "+\t\t\t\tflowContext,\r", "+\t\t\t\tflowInfo.initsWhenTrue().copy()).\r", "+\t\t\t\t\tunconditionalInits().\r", "+\t\t\t\t\t\tmergedWith(\r", "+\t\t\t\t\t\t\tvalueIfFalse.analyseCode(\r", "+\t\t\t\t\t\t\t\tcurrentScope,\r", "+\t\t\t\t\t\t\t\tflowContext,\r", "+\t\t\t\t\t\t\t\tflowInfo.initsWhenFalse().copy()).\r", "+\t\t\t\t\t\t\t\t\tunconditionalInits());\r", "+\t\t*/\r", "+\t\tmergedInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);\r", "+\t\treturn mergedInfo;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "809ca537922cb64bc000a06a4998ee18", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingKey.java", "commitBeforeChange": "65bc58d731b2b7495611004f31fbf68869bf0c34", "commitAfterChange": "a618dea008dd005a2062d94159d61d7900b021b7", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 7, "signatureBeforeChange": " \t Binding getCompilerBinding(CompilationUnitResolver resolver)", "signatureAfterChange": " \t Binding getCompilerBinding()", "diff": ["-\t Binding getCompilerBinding(CompilationUnitResolver resolver) {", "-\t\tCompilationUnitDeclaration parsedUnit = getCompilationUnitDeclaration(resolver.lookupEnvironment);", "+\t Binding getCompilerBinding() {", "+\t\tCompilationUnitDeclaration parsedUnit = getCompilationUnitDeclaration();", "-\t\t\tif (!resolver.requestedKeys.containsKey(fileName) && !resolver.requestedSources.containsKey(fileName))", "-\t\t\t\tresolver.process(parsedUnit, resolver.totalUnits+1);", "+\t\t\tif (!this.resolver.requestedKeys.containsKey(fileName) && !this.resolver.requestedSources.containsKey(fileName))", "+\t\t\t\tthis.resolver.process(parsedUnit, this.resolver.totalUnits+1);", "-\t\treturn getCompilerBinding(parsedUnit, resolver);", "+\t\treturn getCompilerBinding(parsedUnit);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a8909e97c23e222b14678e9b02f41f5c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/FactoryPathConfigurationBlock.java", "commitBeforeChange": "6a39aeee024a65d73e9084e99bead655e3ded072", "commitAfterChange": "30a0d8b166ac2fa2854a231544dfecb8e382982a", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tprivate void initListContents()", "signatureAfterChange": " \tprivate void initListContents()", "diff": ["-\t\tfor (Map.Entry<FactoryContainer, Boolean> e : fOriginalPath.entrySet()) {", "-\t\t\tFactoryContainer fc = e.getKey();", "-\t\t\tfFactoryPathList.addElement(fc);", "-\t\t\tfFactoryPathList.setChecked(fc, e.getValue());", "+\t\tfor (FactoryPathEntry originalFpe : fOriginalPath) {", "+\t\t\t// clone, because we may later modify it and we want to compare with the original.", "+\t\t\tFactoryPathEntry fpe = new FactoryPathEntry(originalFpe._fc, originalFpe._attr);", "+\t\t\tfFactoryPathList.addElement(fpe);", "+\t\t\tfFactoryPathList.setChecked(fpe, fpe._attr.isEnabled());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dc58e4c29ad98de101e463e031c8fc03", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SortElementBuilder.java", "commitBeforeChange": "5bb4424c2a16bd21f3ccb39ffd0ecc0967ba9f5b", "commitAfterChange": "554ad9262edde8518a6f39200ec65ed5eaeb92c4", "methodNumberBeforeChange": 64, "methodNumberAfterChange": 61, "signatureBeforeChange": "  \tfinal int normalizeSourceStart(int position)", "signatureAfterChange": "  \tfinal int normalizeSourceStart(int position)", "diff": ["-\t\tint lineNumber = searchLineNumber(this.lineEnds, position);", "-\t\tif (lineNumber == 1) {", "+\t\tif (position == 0) {", "-\t\tint normalizeSourceStart = this.lineEnds[lineNumber - 2] + 1;", "-\t\tint index = position;", "-\t\tindex--;", "-\t\twhile (Character.isWhitespace(this.source[index]) && index > normalizeSourceStart) {", "+\t\tint index = position - 1;", "+\t\twhile(index >= 0 && Character.isWhitespace(this.source[index])) {", "-\t\tif (index == normalizeSourceStart) {", "-\t\t\treturn normalizeSourceStart;", "-\t\t} else {", "+\t\t", "+\t\tint originalLineNumber = searchLineNumber(this.lineEnds, position);", "+\t\tint newLineNumber = searchLineNumber(this.lineEnds, index);", "+\t\t", "+\t\tif (originalLineNumber == newLineNumber) {", "+\t\t} else {", "+\t\t\treturn this.lineEnds[newLineNumber - 1] + 1;"]}], "num": 8844}