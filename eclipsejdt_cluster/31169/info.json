{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "888c1b10fee5cd48ecc7ce05189039e5", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "00c8029f34b7aac5fd0ecaea8013808b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "signatureAfterChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "diff": ["-", "+\t\t\t\tboolean insideTypeAnnotation = false;", "+\t\t\t\t", "+\t\t\t\t\t\t\tinsideTypeAnnotation = methodScope.insideTypeAnnotation;", "+\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tFieldBinding fieldBinding = classScope.findField(enclosingType, name, invocationSite, needResolve);", "-\t\t\t\t\t\t\t// Use next line instead if willing to enable protected access accross inner types", "-\t\t\t\t\t\t\t// FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tif (fieldBinding != null) { // skip it if we did not find anything", "-\t\t\t\t\t\t\t\tif (fieldBinding.problemId() == Ambiguous) {", "-\t\t\t\t\t\t\t\t\tif (foundField == null || foundField.problemId() == NotVisible)", "-\t\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t\t\treturn fieldBinding;", "-\t\t\t\t\t\t\t\t\t// make the user qualify the field, likely wants the first inherited field (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "-\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "-\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\t\tProblemFieldBinding insideProblem = null;", "-\t\t\t\t\t\t\t\tif (fieldBinding.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tif (!fieldBinding.isStatic()) {", "-\t\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "-\t\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!insideTypeAnnotation) {", "+\t\t\t\t\t\t\t\tFieldBinding fieldBinding = classScope.findField(enclosingType, name, invocationSite, needResolve);", "+\t\t\t\t\t\t\t\t// Use next line instead if willing to enable protected access accross inner types", "+\t\t\t\t\t\t\t\t// FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\tif (fieldBinding != null) { // skip it if we did not find anything", "+\t\t\t\t\t\t\t\t\tif (fieldBinding.problemId() == Ambiguous) {", "+\t\t\t\t\t\t\t\t\t\tif (foundField == null || foundField.problemId() == NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "+\t\t\t\t\t\t\t\t\t\t\treturn fieldBinding;", "+\t\t\t\t\t\t\t\t\t\t// make the user qualify the field, likely wants the first inherited field (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "+\t\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t\tif (enclosingType == fieldBinding.declaringClass || environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "-\t\t\t\t\t\t\t\t\t\t// found a valid field in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "-\t\t\t\t\t\t\t\t\t\tif (foundField == null) {", "-\t\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "-\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(enclosingType);", "+\t", "+\t\t\t\t\t\t\t\t\tProblemFieldBinding insideProblem = null;", "+\t\t\t\t\t\t\t\t\tif (fieldBinding.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\t\tif (!fieldBinding.isStatic()) {", "+\t\t\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "+\t\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "+\t\t\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "+\t\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t\t\t\t// return the fieldBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\t\t\treturn insideProblem == null ? fieldBinding : insideProblem;", "-\t\t\t\t\t\t\t\t\t\tif (foundField.isValidBinding())", "-\t\t\t\t\t\t\t\t\t\t\t// if a valid field was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "-\t\t\t\t\t\t\t\t\t\t\tif (foundField.declaringClass != fieldBinding.declaringClass)", "-\t\t\t\t\t\t\t\t\t\t\t\t// ie. have we found the same field - do not trust field identity yet", "-\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t\tif (enclosingType == fieldBinding.declaringClass || environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "+\t\t\t\t\t\t\t\t\t\t\t// found a valid field in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundField == null) {", "+\t\t\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "+\t\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(enclosingType);", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\t// return the fieldBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn insideProblem == null ? fieldBinding : insideProblem;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tif (foundField.isValidBinding())", "+\t\t\t\t\t\t\t\t\t\t\t\t// if a valid field was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "+\t\t\t\t\t\t\t\t\t\t\t\tif (foundField.declaringClass != fieldBinding.declaringClass)", "+\t\t\t\t\t\t\t\t\t\t\t\t\t// ie. have we found the same field - do not trust field identity yet", "+\t\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\t\tif (foundField == null || (foundField.problemId() == NotVisible && fieldBinding.problemId() != NotVisible)) {", "-\t\t\t\t\t\t\t\t\t// only remember the fieldBinding if its the first one found or the previous one was not visible & fieldBinding is...", "-\t\t\t\t\t\t\t\t\tfoundDepth = depth;", "-\t\t\t\t\t\t\t\t\tfoundActualReceiverType = enclosingType;", "-\t\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\t\t\t\t\t\t\tfoundField = fieldBinding;", "+\t", "+\t\t\t\t\t\t\t\t\tif (foundField == null || (foundField.problemId() == NotVisible && fieldBinding.problemId() != NotVisible)) {", "+\t\t\t\t\t\t\t\t\t\t// only remember the fieldBinding if its the first one found or the previous one was not visible & fieldBinding is...", "+\t\t\t\t\t\t\t\t\t\tfoundDepth = depth;", "+\t\t\t\t\t\t\t\t\t\tfoundActualReceiverType = enclosingType;", "+\t\t\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "+\t\t\t\t\t\t\t\t\t\tfoundField = fieldBinding;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tinsideTypeAnnotation = false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d36855d5cb9272e031d4d19607ba504", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "4bca3a5b750a1427c84a78f92ee835c1f5e75da7", "commitAfterChange": "65cffea518e323981e83002b5b2ff520f43d6c58", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tMethodBinding foundFuzzyProblem = null;", "-\t\t// the weird method lookup case (matches method name in scope, then arg types, then visibility)", "-\t\tMethodBinding foundInsideProblem = null;", "-\t\t// inside Constructor call or inside static context", "+\t\tMethodBinding foundProblem = null;", "-\t\t\t\t\t\tMethodBinding methodBinding =", "-\t\t\t\t\t\t\t(foundMethod == null)", "-\t\t\t\t\t\t\t\t? classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-\t\t\t\t\t\t\t\t: classScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "+\t\t\t\t\t\tMethodBinding methodBinding = classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\tif (methodBinding.problemId() == ProblemReasons.Ambiguous) {", "-\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible) {", "-\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t\treturn methodBinding;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\tselector,", "-\t\t\t\t\t\t\t\t\targumentTypes,", "-\t\t\t\t\t\t\t\t\tProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tMethodBinding fuzzyProblem = null;", "-\t\t\t\t\t\t\tMethodBinding insideProblem = null;", "-\t\t\t\t\t\t\tif (methodBinding.isValidBinding()) {", "-\t\t\t\t\t\t\t\tif (!methodBinding.isStatic()) {", "-\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\t\tProblemReasons.NonStaticReferenceInConstructorInvocation);", "-\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\t\tProblemReasons.NonStaticReferenceInStaticContext);", "+\t\t\t\t\t\t\tif (foundMethod == null) {", "+\t\t\t\t\t\t\t\tif (methodBinding.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (!methodBinding.isStatic() && (insideConstructorCall || insideStaticContext)) {", "+\t\t\t\t\t\t\t\t\t\tif (foundProblem != null && foundProblem.problemId() != ProblemReasons.NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\treturn foundProblem; // takes precedence", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\t\tinsideConstructorCall", "+\t\t\t\t\t\t\t\t\t\t\t\t? ProblemReasons.NonStaticReferenceInConstructorInvocation", "+\t\t\t\t\t\t\t\t\t\t\t\t: ProblemReasons.NonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS", "-\t\t\t\t\t\t\t\t\t\t|| ((foundFuzzyProblem == null || foundFuzzyProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)) {", "+\t\t\t\t\t\t\t\t\t\t|| ((foundProblem == null || foundProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)", "+\t\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS) {", "-\t\t\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundProblem != null && foundProblem.problemId() != ProblemReasons.NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn foundProblem;", "-\t\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.problemId() != ProblemReasons.NotVisible)", "-\t\t\t\t\t\t\t\t\t\t\t\treturn foundFuzzyProblem;", "-\t\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tfuzzyProblem = methodBinding;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (foundMethod != null && foundMethod.declaringClass != methodBinding.declaringClass)", "-\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass || (receiverType.getMethods(selector)) != Binding.NO_METHODS)", "-\t\t\t\t\t\t\t\t\t// if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "+\t\t\t\t\t\t\t\t\tif (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\t\t// only remember the methodBinding if its the first one found", "+\t\t\t\t\t\t\t\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "+\t\t\t\t\t\t\t\t\t\tif (depth > 0) {", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tfoundMethod = methodBinding;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else { // methodBinding is a problem method", "+\t\t\t\t\t\t\t\t\tif (methodBinding.problemId() != ProblemReasons.NotVisible && methodBinding.problemId() != ProblemReasons.NotFound)", "+\t\t\t\t\t\t\t\t\t\treturn methodBinding; // return the error now", "+\t\t\t\t\t\t\t\t\tif (foundProblem == null || (foundProblem.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() == ProblemReasons.NotFound))", "+\t\t\t\t\t\t\t\t\t\tfoundProblem = methodBinding; // hold onto the first not visible/found error and keep the second not found if first is not visible", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else { // found a valid method so check to see if this is a hiding case", "+\t\t\t\t\t\t\t\tif (methodBinding.problemId() == ProblemReasons.Ambiguous", "+\t\t\t\t\t\t\t\t\t|| (foundMethod.declaringClass != methodBinding.declaringClass", "+\t\t\t\t\t\t\t\t\t\t&& (receiverType == methodBinding.declaringClass || receiverType.getMethods(selector) != Binding.NO_METHODS)))", "+\t\t\t\t\t\t\t\t\t// ambiguous case -> must qualify the method (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\t\t// otherwise if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\tselector,", "+\t\t\t\t\t\t\t\t\t\targumentTypes,", "-", "-\t\t\t\t\t\t\tif (foundMethod == null || (foundMethod.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() != ProblemReasons.NotVisible)) {", "-\t\t\t\t\t\t\t\t// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...", "-\t\t\t\t\t\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "-\t\t\t\t\t\t\t\tif (depth > 0) {", "-\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tfoundFuzzyProblem = fuzzyProblem;", "-\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\t\t\t\t\t\tif (fuzzyProblem == null)", "-\t\t\t\t\t\t\t\t\tfoundMethod = methodBinding; // only keep it if no error was found", "-\t\t\t\t\tinsideConstructorCall =", "-\t\t\t\t\t\tenclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "+\t\t\t\t\tinsideConstructorCall = enclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "-\t\tif (foundFuzzyProblem != null)", "-\t\t\tif (foundFuzzyProblem.problemId() != ProblemReasons.NotVisible && foundFuzzyProblem.problemId() != ProblemReasons.NotFound)", "-\t\t\t\treturn foundFuzzyProblem;", "-\t\tif (foundInsideProblem != null)", "-\t\t\treturn foundInsideProblem;", "-", "-\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.declaringClass != null && foundFuzzyProblem.declaringClass.id == TypeIds.T_JavaLangObject)", "-\t\t\t\treturn foundFuzzyProblem; // static imports lose to methods from Object", "+\t\t\tif (foundProblem != null) {", "+\t\t\t\tif (foundProblem.declaringClass != null && foundProblem.declaringClass.id == TypeIds.T_JavaLangObject)", "+\t\t\t\t\treturn foundProblem; // static imports lose to methods from Object", "+\t\t\t\tif (foundProblem.problemId() == ProblemReasons.NotFound) {", "+\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding) foundProblem).closestMatch;", "+\t\t\t\t\tif (closestMatch != null && closestMatch.canBeSeenBy(invocationSite, this))", "+\t\t\t\t\t\treturn foundProblem; // visible method selectors take precedence", "+\t\t\t\t}", "+\t\t\t}", "-\t\t\t\t\t\tif (possible != null && possible != foundFuzzyProblem) {", "+\t\t\t\t\t\tif (possible != null && possible != foundProblem) {", "-\t\t\t\t\t\t\t\tif (foundFuzzyProblem == null)", "-\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = possible; // answer as error case match", "+\t\t\t\t\t\t\t\tif (foundProblem == null)", "+\t\t\t\t\t\t\t\t\tfoundProblem = possible; // answer as error case match", "-\t\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "-\t\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t\t} else if (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundProblem = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "-\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "-\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t} else if (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\t\tfoundProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "-\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\t\t\t\t\t\t} else if (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\tfoundProblem = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\tif (foundFuzzyProblem != null)", "-\t\t\treturn foundFuzzyProblem;", "+\t\tif (foundProblem != null)", "+\t\t\treturn foundProblem;"]}], "num": 31169}