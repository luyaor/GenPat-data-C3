{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "eeff31b0a54c57cd427df02964fe11f2", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09c732ea55e2ff58dc8c49f8a98d716a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java", "commitBeforeChange": "888ff915accf0f7dc08ba845bca467c94f1e290b", "commitAfterChange": "f69c200469412ca3b93e80844c6c1f4e077169ac", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 73, "signatureBeforeChange": " public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException", "signatureAfterChange": " public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException", "diff": ["- */", "-public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException {", "-\t", "-\t// if factory is null, default factory must be used", "-\tif (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();", "-", "-\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t", "-\t// In order to be shared, working copies have to denote the same compilation unit ", "-\t// AND use the same buffer factory.", "-\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "-\tMap sharedWorkingCopies = manager.sharedWorkingCopies;", "-\t", "-\tMap perFactoryWorkingCopies = (Map) sharedWorkingCopies.get(factory);", "-\tif (perFactoryWorkingCopies == null){", "-\t\tperFactoryWorkingCopies = new HashMap();", "-\t\tsharedWorkingCopies.put(factory, perFactoryWorkingCopies);", "-\t}", "-\tWorkingCopy workingCopy = (WorkingCopy)perFactoryWorkingCopies.get(this);", "-\tif (workingCopy != null) {", "-\t\tworkingCopy.useCount++;", "-", "-\t\tif (SHARED_WC_VERBOSE) {", "-\t\t\tSystem.out.println(\"Incrementing use count of shared working copy \" + workingCopy.toStringWithAncestors()); //$NON-NLS-1$", "-\t\t}", "-", "-\t\treturn workingCopy;", "-\t} else {", "-\t\tCreateWorkingCopyOperation op = new CreateWorkingCopyOperation(this, perFactoryWorkingCopies, factory, problemRequestor);", "-\t\trunOperation(op, pm);", "-\t\treturn op.getResultElements()[0];", "-\t}", "-}", "+ */", "+public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException {", "+\t", "+\tif (isWorkingCopy()) return this;", "+\t", "+\t// if factory is null, default factory must be used", "+\tif (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();", "+", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\t", "+\t// In order to be shared, working copies have to denote the same compilation unit ", "+\t// AND use the same buffer factory.", "+\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "+\tMap sharedWorkingCopies = manager.sharedWorkingCopies;", "+\t", "+\tCompilationUnitOwner workingCopyOwner = new DefaultCompilationUnitOwner(factory, problemRequestor);", "+\tMap perOwnerWorkingCopies = (Map) sharedWorkingCopies.get(workingCopyOwner);", "+\tif (perOwnerWorkingCopies == null){", "+\t\tperOwnerWorkingCopies = new HashMap();", "+\t\tsharedWorkingCopies.put(workingCopyOwner, perOwnerWorkingCopies);", "+\t}", "+\tCompilationUnit workingCopy = (CompilationUnit)perOwnerWorkingCopies.get(this);", "+\tif (workingCopy != null) {", "+\t\tObject info = manager.getInfo(workingCopy);", "+\t\tif (info instanceof WorkingCopyElementInfo) {", "+\t\t\t((WorkingCopyElementInfo)info).incrementUseCount();", "+", "+\t\t\tif (SHARED_WC_VERBOSE) {", "+\t\t\t\tSystem.out.println(\"Incrementing use count of shared working copy \" + workingCopy.toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\t}", "+", "+\t\t\treturn workingCopy;", "+\t\t}", "+\t} ", "+\tworkingCopy = new CompilationUnit((IPackageFragment)getParent(), getElementName(), workingCopyOwner);", "+\tBecomeWorkingCopyOperation op = new BecomeWorkingCopyOperation(workingCopy, perOwnerWorkingCopies);", "+\trunOperation(op, pm);", "+\treturn workingCopy;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3d3a6eb384c54540e0037526e4f9e27", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java", "commitBeforeChange": "3c7abdea60e3dea7a9b2b822e92d260aea9179a7", "commitAfterChange": "85d82ef92c86e257cfcb71c0ec95b6b64432a5cb", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": " \tpublic boolean visit(IfStatement node)", "signatureAfterChange": " \tpublic boolean visit(LambdaExpression node)", "diff": ["+\t */", "+\tpublic boolean visit(LambdaExpression node) {", "+\t\tboolean hasParentheses = node.hasParentheses();", "+\t\tif (hasParentheses)", "+\t\t\tthis.buffer.append('(');", "+\t\tIterator it = node.parameters().iterator();", "+\t\tboolean hasNext = it.hasNext();", "+\t\twhile (hasNext) {", "+\t\t\tVariableDeclaration  variableDeclaration = (VariableDeclaration) it.next();", "+\t\t\tvariableDeclaration.accept(this);", "+\t\t\tif ((hasNext = it.hasNext()) == true)", "+\t\t\t\tthis.buffer.append(',');", "+\t\t}", "+\t\tif (hasParentheses) ", "+\t\t\tthis.buffer.append(')');\t", "+\t\tthis.buffer.append(\" -> \"); //$NON-NLS-1$", "+\t\tnode.getBody().accept(this);", "+\t\treturn false;", "+\t}"]}], "num": 42733}