{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7c767b3a37d67507d9f81900188f9000", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "00c8029f34b7aac5fd0ecaea8013808b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "signatureAfterChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "diff": ["-", "+\t\t\t\tboolean insideTypeAnnotation = false;", "+\t\t\t\t", "+\t\t\t\t\t\t\tinsideTypeAnnotation = methodScope.insideTypeAnnotation;", "+\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tFieldBinding fieldBinding = classScope.findField(enclosingType, name, invocationSite, needResolve);", "-\t\t\t\t\t\t\t// Use next line instead if willing to enable protected access accross inner types", "-\t\t\t\t\t\t\t// FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tif (fieldBinding != null) { // skip it if we did not find anything", "-\t\t\t\t\t\t\t\tif (fieldBinding.problemId() == Ambiguous) {", "-\t\t\t\t\t\t\t\t\tif (foundField == null || foundField.problemId() == NotVisible)", "-\t\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t\t\treturn fieldBinding;", "-\t\t\t\t\t\t\t\t\t// make the user qualify the field, likely wants the first inherited field (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "-\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "-\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\t\tProblemFieldBinding insideProblem = null;", "-\t\t\t\t\t\t\t\tif (fieldBinding.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tif (!fieldBinding.isStatic()) {", "-\t\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "-\t\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!insideTypeAnnotation) {", "+\t\t\t\t\t\t\t\tFieldBinding fieldBinding = classScope.findField(enclosingType, name, invocationSite, needResolve);", "+\t\t\t\t\t\t\t\t// Use next line instead if willing to enable protected access accross inner types", "+\t\t\t\t\t\t\t\t// FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\tif (fieldBinding != null) { // skip it if we did not find anything", "+\t\t\t\t\t\t\t\t\tif (fieldBinding.problemId() == Ambiguous) {", "+\t\t\t\t\t\t\t\t\t\tif (foundField == null || foundField.problemId() == NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "+\t\t\t\t\t\t\t\t\t\t\treturn fieldBinding;", "+\t\t\t\t\t\t\t\t\t\t// make the user qualify the field, likely wants the first inherited field (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "+\t\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t\tif (enclosingType == fieldBinding.declaringClass || environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "-\t\t\t\t\t\t\t\t\t\t// found a valid field in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "-\t\t\t\t\t\t\t\t\t\tif (foundField == null) {", "-\t\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "-\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(enclosingType);", "+\t", "+\t\t\t\t\t\t\t\t\tProblemFieldBinding insideProblem = null;", "+\t\t\t\t\t\t\t\t\tif (fieldBinding.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\t\tif (!fieldBinding.isStatic()) {", "+\t\t\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "+\t\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "+\t\t\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "+\t\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t\t\t\t// return the fieldBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\t\t\treturn insideProblem == null ? fieldBinding : insideProblem;", "-\t\t\t\t\t\t\t\t\t\tif (foundField.isValidBinding())", "-\t\t\t\t\t\t\t\t\t\t\t// if a valid field was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "-\t\t\t\t\t\t\t\t\t\t\tif (foundField.declaringClass != fieldBinding.declaringClass)", "-\t\t\t\t\t\t\t\t\t\t\t\t// ie. have we found the same field - do not trust field identity yet", "-\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t\tif (enclosingType == fieldBinding.declaringClass || environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "+\t\t\t\t\t\t\t\t\t\t\t// found a valid field in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundField == null) {", "+\t\t\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "+\t\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(enclosingType);", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\t// return the fieldBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn insideProblem == null ? fieldBinding : insideProblem;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tif (foundField.isValidBinding())", "+\t\t\t\t\t\t\t\t\t\t\t\t// if a valid field was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "+\t\t\t\t\t\t\t\t\t\t\t\tif (foundField.declaringClass != fieldBinding.declaringClass)", "+\t\t\t\t\t\t\t\t\t\t\t\t\t// ie. have we found the same field - do not trust field identity yet", "+\t\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\t\tif (foundField == null || (foundField.problemId() == NotVisible && fieldBinding.problemId() != NotVisible)) {", "-\t\t\t\t\t\t\t\t\t// only remember the fieldBinding if its the first one found or the previous one was not visible & fieldBinding is...", "-\t\t\t\t\t\t\t\t\tfoundDepth = depth;", "-\t\t\t\t\t\t\t\t\tfoundActualReceiverType = enclosingType;", "-\t\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\t\t\t\t\t\t\tfoundField = fieldBinding;", "+\t", "+\t\t\t\t\t\t\t\t\tif (foundField == null || (foundField.problemId() == NotVisible && fieldBinding.problemId() != NotVisible)) {", "+\t\t\t\t\t\t\t\t\t\t// only remember the fieldBinding if its the first one found or the previous one was not visible & fieldBinding is...", "+\t\t\t\t\t\t\t\t\t\tfoundDepth = depth;", "+\t\t\t\t\t\t\t\t\t\tfoundActualReceiverType = enclosingType;", "+\t\t\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "+\t\t\t\t\t\t\t\t\t\tfoundField = fieldBinding;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tinsideTypeAnnotation = false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ca2fff865398556b9dcae72621a6eed5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java", "commitBeforeChange": "c9df47e6bc4127d80d1e16ea8353f464e792fda3", "commitAfterChange": "514d8e9afb885d3be64fa67a03a4dd281867840f", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  public MethodBinding getImplicitMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  public MethodBinding getImplicitMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\tboolean insideStaticContext = false;", "-\tboolean insideConstructorCall = false;", "-\tMethodBinding foundMethod = null;", "-\tProblemMethodBinding foundFuzzyProblem = null; // the weird method lookup case (matches method name in scope, then arg types, then visibility)", "-\tProblemMethodBinding foundInsideProblem = null; // inside Constructor call or inside static context", "-\tScope scope = this;", "-\tboolean isExactMatch = true;", "-\tMethodBinding methodBinding =", "-\t\t(foundMethod == null)", "-\t\t\t? findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-\t\t\t: findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-//\t\t\t\t\t\t? findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-//\t\t\t\t\t\t: findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-\tif (methodBinding == null && foundMethod == null) {", "-\t\t// answers closest approximation, may not check argumentTypes or visibility", "-\t\tisExactMatch = false;", "+\tMethodBinding methodBinding = findExactMethod(receiverType, selector, argumentTypes, invocationSite);", "+\tif (methodBinding == null)", "-//\t\t\t\t\tmethodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t}", "-\t\tif (methodBinding.problemId() == ProblemReasons.Ambiguous) {", "-\t\t\tif (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible)", "-\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\treturn methodBinding;", "-\t\t\telse", "-\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\treturn new ProblemMethodBinding(selector, methodBinding.parameters, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t}", "-", "-\t\tProblemMethodBinding fuzzyProblem = null;", "-\t\tProblemMethodBinding insideProblem = null;", "-\t\tif (methodBinding.isValidBinding()) {", "-\t\t\tif (!isExactMatch) {", "-\t    \t    MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-\t\t\t\tif (compatibleMethod == null) {", "-\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\t} else {", "-\t\t\t\t    methodBinding = compatibleMethod;", "-\t\t\t\t    if (!canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this)) {\t", "-\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "-\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotVisible);", "-\t\t\t\t    }", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (fuzzyProblem == null && !methodBinding.isStatic()) {", "-\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\tinsideProblem = new ProblemMethodBinding(methodBinding, methodBinding.selector, methodBinding.parameters, ProblemReasons.NonStaticReferenceInConstructorInvocation);", "-\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\tinsideProblem = new ProblemMethodBinding(methodBinding, methodBinding.selector, methodBinding.parameters, ProblemReasons.NonStaticReferenceInStaticContext);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (receiverType == methodBinding.declaringClass || (receiverType.getMethods(selector)) != Binding.NO_METHODS) {", "-\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t// OR the receiverType implemented a method with the correct name", "-\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (it is inherited)", "-\t\t\t\t\tif (fuzzyProblem != null)", "-\t\t\t\t\t\treturn fuzzyProblem;", "-\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\treturn insideProblem;", "-\t\t\t\t\treturn methodBinding;", "-\t\t\t\t}", "-\t\t\t\t// if a method was found, complain when another is found in an 'immediate' enclosing type (ie. not inherited)", "-\t\t\t\t// NOTE: Unlike fields, a non visible method hides a visible method", "-\t\t\t\tif (foundMethod.declaringClass != methodBinding.declaringClass) // ie. have we found the same method - do not trust field identity yet", "-\t\t\t\t\treturn new ProblemMethodBinding(methodBinding, methodBinding.selector, methodBinding.parameters, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t}", "-\t\t}", "-", "-\t\tif (foundMethod == null || (foundMethod.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() != ProblemReasons.NotVisible)) {", "-\t\t\t// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...", "-\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "-\t\t\tfoundFuzzyProblem = fuzzyProblem;", "-\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\tif (fuzzyProblem == null)", "-\t\t\t\tfoundMethod = methodBinding; // only keep it if no error was found", "-\t\t}", "+\t\tif (methodBinding.isValidBinding())", "+\t\t    if (!canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this))", "+\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotVisible);", "+\t\treturn methodBinding;", "-\tinsideStaticContext |= receiverType.isStatic();", "-\t// 1EX5I8Z - accessing outer fields within a constructor call is permitted", "-\t// in order to do so, we change the flag as we exit from the type, not the method", "-\t// itself, because the class scope is used to retrieve the fields.", "-\tMethodScope enclosingMethodScope = scope.methodScope();", "-\tinsideConstructorCall = enclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "-", "-\tif (foundFuzzyProblem != null)", "-\t\treturn foundFuzzyProblem;", "-\tif (foundInsideProblem != null)", "-\t\treturn foundInsideProblem;", "-\tif (foundMethod != null)", "-\t\treturn foundMethod;"]}], "num": 53881}