{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a413f01ec6a162d66da61370035b3ecb", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "40b5709e4516ebc31f0c7ebaabe01e65", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "71df68ac6bbd7c5b4b673539241b9c1cc905574c", "commitAfterChange": "04c08732703d5f5e97b66e89468d2f87b7f84cff", "methodNumberBeforeChange": 67, "methodNumberAfterChange": 114, "signatureBeforeChange": " \tpublic HashMap getSecondaryTypes(IJavaProject project, boolean waitForIndexes, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " \tpublic Map secondaryTypes(IJavaProject project, boolean waitForIndexes, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\t */", "-\tpublic HashMap getSecondaryTypes(IJavaProject project, boolean waitForIndexes, IProgressMonitor monitor) throws JavaModelException {", "-\t\tif (VERBOSE) {", "-\t\t\tStringBuffer buffer = new StringBuffer(\"JavaModelManager.getSecondaryTypesPaths(\"); //$NON-NLS-1$", "-\t\t\tbuffer.append(project.getElementName());", "-\t\t\tbuffer.append(')');", "-\t\t\tUtil.verbose(buffer.toString());", "-\t\t}", "-", "-\t\t// Wait the end of indexing if requested", "-\t\tfinal PerProjectInfo projectInfo = getPerProjectInfoCheckExistence(project.getProject());", "-\t\tIndexManager manager = getIndexManager();", "-\t\tboolean indexing = manager.awaitingJobsCount() > 0;", "-\t\tif (indexing && waitForIndexes) {", "-\t\t\twhile (manager.awaitingJobsCount() > 0) {", "-\t\t\t\tif (monitor != null && monitor.isCanceled()) {", "-\t\t\t\t\tif (projectInfo.secondaryTypes == null) return NO_SECONDARY_TYPES;", "-\t\t\t\t\treturn projectInfo.secondaryTypes;", "-\t\t\t\t}", "-\t\t\t\ttry {", "-\t\t\t\t\tThread.sleep(10);", "-\t\t\t\t} catch (InterruptedException e) {", "-\t\t\t\t\tif (projectInfo.secondaryTypes == null) return NO_SECONDARY_TYPES;", "-\t\t\t\t\treturn projectInfo.secondaryTypes;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-", "-\t\t// Return cache if not empty and not dirty", "-\t\tif (projectInfo.secondaryTypes != null && projectInfo.secondaryTypes.get(DIRTY_CACHE) == null) {", "-\t\t\treturn projectInfo.secondaryTypes;", "-\t\t}", "-\t\t", "-\t\t// Return cache if not waiting for indexing", "-\t\tif (indexing && !waitForIndexes) {", "-\t\t\tif (projectInfo.secondaryTypes == null) {", "-\t\t\t\treturn NO_SECONDARY_TYPES; // cache is not initialized return empty one", "-\t\t\t}", "-\t\t\treturn projectInfo.secondaryTypes; // cache is dirty => return current one...", "-\t\t}", "-", "-\t\t// Init variables for search", "-\t\tfinal HashMap secondaryTypes = new HashMap(3);", "-\t\tIRestrictedAccessTypeRequestor nameRequestor = new IRestrictedAccessTypeRequestor() {", "-\t\t\tpublic void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, String path, AccessRestriction access) {", "-\t\t\t\tString key = packageName==null ? \"\" : new String(packageName); //$NON-NLS-1$", "-\t\t\t\tHashMap types = (HashMap) secondaryTypes.get(key);", "-\t\t\t\tif (types == null) types = new HashMap(3);", "-\t\t\t\ttypes.put(new String(simpleTypeName), path);", "-\t\t\t\tsecondaryTypes.put(key, types);", "-\t\t\t}", "-\t\t};", "-", "-\t\t// Build scope using prereq projects but only source folders", "-\t\tIPackageFragmentRoot[] allRoots = project.getAllPackageFragmentRoots();", "-\t\tint length = allRoots.length, size = 0;", "-\t\tIPackageFragmentRoot[] allSourceFolders = new IPackageFragmentRoot[length];", "-\t\tfor (int i=0; i<length; i++) {", "-\t\t\tif (allRoots[i].getKind() == IPackageFragmentRoot.K_SOURCE) {", "-\t\t\t\tallSourceFolders[size++] = allRoots[i];", "-\t\t\t}", "-\t\t}", "-\t\tif (size < length) {", "-\t\t\tSystem.arraycopy(allSourceFolders, 0, allSourceFolders = new IPackageFragmentRoot[size], 0, size);", "-\t\t}", "-", "-\t\t// Search all secondary types on scope", "-\t\tnew BasicSearchEngine().searchAllSecondaryTypeNames(allSourceFolders, nameRequestor, monitor);", "-\t\tif (VERBOSE) {", "-\t\t\tSystem.out.print(Thread.currentThread() + \"\t-> secondary paths: \");  //$NON-NLS-1$", "-\t\t\tSystem.out.println();", "-\t\t\tIterator keys = secondaryTypes.keySet().iterator();", "-\t\t\twhile (keys.hasNext()) {", "-\t\t\t\tString qualifiedName = (String) keys.next();", "-\t\t\t\tUtil.verbose(\"\t\t- \"+qualifiedName+'-'+secondaryTypes.get(qualifiedName) ); //$NON-NLS-1$", "-\t\t\t}", "-\t\t}", "-", "-\t\t// Build types from paths", "-\t\tIterator packages = secondaryTypes.keySet().iterator();", "-\t\twhile (packages.hasNext()) {", "-\t\t\tString packName = (String) packages.next();", "-\t\t\tHashMap types = (HashMap) secondaryTypes.get(packName);", "-\t\t\tIterator names = types.keySet().iterator();", "-\t\t\twhile (names.hasNext()) {", "-\t\t\t\tString typeName = (String) names.next();", "-\t\t\t\tString path = (String) types.get(typeName);", "-\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(path)) {", "-\t\t\t\t\tIFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(path));", "-\t\t\t\t\tICompilationUnit unit = JavaModelManager.createCompilationUnitFrom(file, null);", "-\t\t\t\t\tIType type = unit.getType(typeName);", "-\t\t\t\t\ttypes.put(typeName, type); // replace stored path with type itself", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-", "-\t\t// Store result in per project info cache if still null or dirty (may have been set by another thread...)", "-\t\tif (projectInfo.secondaryTypes == null || projectInfo.secondaryTypes.get(DIRTY_CACHE) != null) {", "-\t\t\tprojectInfo.secondaryTypes = secondaryTypes;", "-\t\t}", "-\t\treturn projectInfo.secondaryTypes;", "+\t */", "+\tpublic Map secondaryTypes(IJavaProject project, boolean waitForIndexes, IProgressMonitor monitor) throws JavaModelException {", "+\t\tif (VERBOSE) {", "+\t\t\tStringBuffer buffer = new StringBuffer(\"JavaModelManager.secondaryTypes(\"); //$NON-NLS-1$", "+\t\t\tbuffer.append(project.getElementName());", "+\t\t\tbuffer.append(',');", "+\t\t\tbuffer.append(waitForIndexes);", "+\t\t\tbuffer.append(')');", "+\t\t\tUtil.verbose(buffer.toString());", "+\t\t}", "+", "+\t\t// Return cache if not empty and there's no new secondary types created during indexing", "+\t\tfinal PerProjectInfo projectInfo = getPerProjectInfoCheckExistence(project.getProject());", "+\t\tMap indexingSecondaryCache = projectInfo.secondaryTypes == null ? null : (Map) projectInfo.secondaryTypes.get(INDEXED_SECONDARY_TYPES);", "+\t\tif (projectInfo.secondaryTypes != null && indexingSecondaryCache == null) {", "+\t\t\treturn projectInfo.secondaryTypes;", "+\t\t}", "+", "+\t\t// Perform search request only if secondary types cache is not initialized yet (this will happen only once!)", "+\t\tif (projectInfo.secondaryTypes == null) {", "+\t\t\treturn secondaryTypesSearching(project, waitForIndexes, monitor, projectInfo);", "+\t\t}", "+", "+\t\t// New secondary types have been created while indexing secondary types cache", "+\t\t// => need to know whether the indexing is finished or not", "+\t\tboolean indexing = this.indexManager.awaitingJobsCount() > 0;", "+\t\tif (indexing) {", "+\t\t\tif (!waitForIndexes)  {", "+\t\t\t\t// Indexing is running but caller cannot wait => return current cache", "+\t\t\t\treturn projectInfo.secondaryTypes;", "+\t\t\t}", "+", "+\t\t\t// Wait for the end of indexing or a cancel", "+\t\t\twhile (this.indexManager.awaitingJobsCount() > 0) {", "+\t\t\t\tif (monitor != null && monitor.isCanceled()) {", "+\t\t\t\t\treturn projectInfo.secondaryTypes;", "+\t\t\t\t}", "+\t\t\t\ttry {", "+\t\t\t\t\tThread.sleep(10);", "+\t\t\t\t} catch (InterruptedException e) {", "+\t\t\t\t\treturn projectInfo.secondaryTypes;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+", "+\t\t// Indexing is finished => merge caches and return result", "+\t\treturn secondaryTypesMerging(projectInfo.secondaryTypes);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3922fe33f94fbd013dc56c49b6a145d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java", "commitBeforeChange": "61910f9ffdfc607d31120af5ce39e6bf8d69bab0", "commitAfterChange": "3a10f90d587275b68cb248facf53e1ae26bb70b8", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 67, "signatureBeforeChange": "  \tprotected void runTest( \t\t\tString[] testFiles, \t\t\tboolean expectingCompilerErrors, \t\t\tString expectedCompilerLog, \t\t\tString expectedOutputString, \t\t\tString expectedErrorString, \t\t\tboolean forceExecution, \t\t\tString[] classLib, \t\t\tboolean shouldFlushOutputDirectory,  \t\t\tString[] vmArguments,  \t\t\tMap customOptions, \t\t\tICompilerRequestor clientRequestor, \t\t\tboolean skipJavac)", "signatureAfterChange": "  \tprotected void runTest( \t\t\tString[] testFiles, \t\t\tboolean expectingCompilerErrors, \t\t\tString expectedCompilerLog, \t\t\tString expectedOutputString, \t\t\tString expectedErrorString, \t\t\tboolean forceExecution, \t\t\tString[] classLibraries, \t\t\tboolean shouldFlushOutputDirectory,  \t\t\tString[] vmArguments,  \t\t\tMap customOptions, \t\t\tICompilerRequestor customRequestor, \t\t\tboolean skipJavac)", "diff": ["-\t\t\tString[] classLib,", "+\t\t\tString[] classLibraries,", "+\t\t\tboolean shouldFlushOutputDirectory, ", "+\t\t\tString[] vmArguments, ", "+\t\t\tMap customOptions,", "+\t\t\tICompilerRequestor customRequestor,", "+\t\t\tboolean skipJavac) {", "+\t\trunTest(", "+\t \t\t// test directory preparation", "+\t\t\tshouldFlushOutputDirectory /* should flush output directory */,", "+\t\t\ttestFiles /* test files */,", "+\t\t\t// compiler options", "+\t\t\tclassLibraries /* class libraries */,", "+\t\t\tcustomOptions /* custom options */,", "+\t\t\tfalse /* do not perform statements recovery */, ", "+\t\t\tcustomRequestor /* custom requestor */,", "+\t\t\t// compiler results", "+\t\t\texpectingCompilerErrors /* expecting compiler errors */,", "+\t\t\texpectedCompilerLog /* expected compiler log */,", "+\t\t\t// runtime options", "+\t\t\tforceExecution /* force execution */,", "+\t\t\tvmArguments /* vm arguments */, ", "+\t\t\t// runtime results", "+\t\t\texpectedOutputString /* expected output string */,", "+\t\t\texpectedErrorString /* expected error string */,", "+\t\t\t// javac options", "+\t\t\tskipJavac ? ", "+\t\t\t\tJavacTestOptions.SKIP : ", "+\t\t\t\tJavacTestOptions.DEFAULT /* javac test options */);", "+", "+\t}", "-\t\t\tboolean skipJavac) {", "-\t\t// Non-javac part", "-\t\t\tif (shouldFlushOutputDirectory)", "-\t\t\t\tUtil.flushDirectoryContent(new File(OUTPUT_DIR));", "-\t", "-\t\t\tIProblemFactory problemFactory = getProblemFactory();", "-\t\t\tRequestor requestor = ", "-\t\t\t\tnew Requestor(", "-\t\t\t\t\tproblemFactory, ", "-\t\t\t\t\tOUTPUT_DIR.endsWith(File.separator) ? OUTPUT_DIR : OUTPUT_DIR + File.separator, ", "-\t\t\t\t\tforceExecution,", "-\t\t\t\t\tclientRequestor,", "-\t\t\t\t\tfalse, /* show category */", "-\t\t\t\t\tfalse /* show warning token*/);", "-\t", "-\t\t\tMap options = getCompilerOptions();", "-\t\t\tif (customOptions != null) {", "-\t\t\t\toptions.putAll(customOptions);", "-\t\t\t}", "-\t\t\tCompilerOptions compilerOptions = new CompilerOptions(options);", "-\t\t\tcompilerOptions.performMethodsFullRecovery = false;", "-\t\t\tcompilerOptions.performStatementsRecovery = false;", "-\t\t\tCompiler batchCompiler = ", "-\t\t\t\tnew Compiler(", "-\t\t\t\t\tgetNameEnvironment(new String[]{}, classLib), ", "-\t\t\t\t\tgetErrorHandlingPolicy(), ", "-\t\t\t\t\tcompilerOptions,", "-\t\t\t\t\trequestor, ", "-\t\t\t\t\tproblemFactory);", "-\t\t\tcompilerOptions.produceReferenceInfo = true;", "-\t\t\tThrowable exception = null;", "-\t\t\ttry {", "-\t\t\t\tbatchCompiler.compile(Util.compilationUnits(testFiles)); // compile all files together", "-\t\t\t} catch(RuntimeException e){", "-\t\t\t\texception = e;", "-\t\t\t\tthrow e;", "-\t\t\t} catch(Error e) {", "-\t\t\t\texception = e;", "-\t\t\t\tthrow e;", "-\t\t\t} finally {", "-\t\t\t\tString computedProblemLog = Util.convertToIndependantLineDelimiter(requestor.problemLog.toString());", "-\t\t\t\tString platformIndependantExpectedLog = Util.convertToIndependantLineDelimiter(expectedCompilerLog);", "-\t\t\t\tif (!platformIndependantExpectedLog.equals(computedProblemLog)) {", "-\t\t\t\t\tSystem.out.println(getClass().getName() + '#' + getName());", "-\t\t\t\t\tSystem.out.println(Util.displayString(computedProblemLog, INDENT, SHIFT));", "-\t\t\t\t\tfor (int i = 0; i < testFiles.length; i += 2) {", "-\t\t\t\t\t\tSystem.out.print(testFiles[i]);", "-\t\t\t\t\t\tSystem.out.println(\" [\"); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println(testFiles[i + 1]);", "-\t\t\t\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (exception == null) {", "-\t\t\t\t\tif (expectingCompilerErrors) {", "-\t\t\t\t\t\tassertTrue(\"Unexpected success\", requestor.hasErrors);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tassertFalse(\"Unexpected failure\", requestor.hasErrors);", "-\t\t\t\t\t}", "-\t\t\t\t\tassertEquals(\"Invalid problem log \", platformIndependantExpectedLog, computedProblemLog);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (!requestor.hasErrors || forceExecution) {", "-\t\t\t\tString sourceFile = testFiles[0];", "-\t", "-\t\t\t\t// Compute class name by removing \".java\" and replacing slashes with dots", "-\t\t\t\tString className = sourceFile.substring(0, sourceFile.length() - 5).replace('/', '.').replace('\\\\', '.');", "-\t\t\t\tif (className.endsWith(PACKAGE_INFO_NAME)) return;", "-\t", "-\t\t\t\tif (vmArguments != null) {", "-\t\t\t\t\tif (this.verifier != null) {", "-\t\t\t\t\t\tthis.verifier.shutDown();", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.verifier = new TestVerifier(false);", "-\t\t\t\t\tthis.createdVerifier = true;", "-\t\t\t\t}", "-\t\t\t\tboolean passed = ", "-\t\t\t\t\tthis.verifier.verifyClassFiles(", "-\t\t\t\t\t\tsourceFile, ", "-\t\t\t\t\t\tclassName,", "-\t\t\t\t\t\texpectedOutputString,", "-\t\t\t\t\t\texpectedErrorString,", "-\t\t\t\t\t\tthis.classpaths, ", "-\t\t\t\t\t\tnull, ", "-\t\t\t\t\t\tvmArguments);", "-\t\t\t\tif (!passed) {", "-\t\t\t\t\tSystem.out.println(getClass().getName() + '#' + getName());", "-\t\t\t\t\tfor (int i = 0; i < testFiles.length; i += 2) {", "-\t\t\t\t\t\tSystem.out.print(testFiles[i]);", "-\t\t\t\t\t\tSystem.out.println(\" [\"); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println(testFiles[i + 1]);", "-\t\t\t\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tassertTrue(this.verifier.failureReason, // computed by verifyClassFiles(...) action", "-\t\t\t\t\t\tpassed);", "-\t\t\t\tif (vmArguments != null) {", "-\t\t\t\t\tif (this.verifier != null) {", "-\t\t\t\t\t\tthis.verifier.shutDown();", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.verifier = new TestVerifier(false);", "-\t\t\t\t\tthis.createdVerifier = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t// javac part", "-\t\t} catch (AssertionFailedError e) {", "-\t\t\tif (RUN_JAVAC && !skipJavac)", "-\t\t\t\trunJavac(testFiles, null, expectedOutputString, shouldFlushOutputDirectory);", "-\t\t\t  // PREMATURE for now, skipping javac implies skipping the compile", "-\t\t\t  //                and execution steps; yet, only cases for which the", "-\t\t\t  //                execution step was a problem have been discovered so", "-\t\t\t  //                far; may consider skipping the execution step only"]}], "num": 18903}