{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9ed74814403f89b181c2c8c1881cc60f", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "129b6145f377e463943b339a3b1b4ccc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5ea56603dc1ee6ae8d60e4a5ed0d457e4e0823e2", "commitAfterChange": "985aba49ffb0849a1927eddcbca9cdac39c5c825", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\tboolean receiverTypeIsInterface = receiverType.isInterface();", "-\t\tif (currentType.isInterface()) {", "-\t\t\tunitScope.recordTypeReference(currentType);", "-\t\t\tMethodBinding[] currentMethods = currentType.getMethods(selector);", "-\t\t\tif (currentMethods.length > 0)", "-\t\t\t\tfound.addAll(currentMethods);", "-\t\t\tfindMethodInSuperInterfaces(currentType, selector, found);", "+\t\tif (receiverTypeIsInterface) {", "+\t\t\tunitScope.recordTypeReference(receiverType);", "+\t\t\tMethodBinding[] receiverMethods = receiverType.getMethods(selector);", "+\t\t\tif (receiverMethods.length > 0)", "+\t\t\t\tfound.addAll(receiverMethods);", "+\t\t\tfindMethodInSuperInterfaces(receiverType, selector, found);", "-\t\tboolean mustBePublic = receiverType.isInterface();", "-\t\t\t\tif (isCompliant14 && (mustBePublic || found.size > 0)) {", "+\t\t\t\tif (isCompliant14 && (receiverTypeIsInterface || found.size > 0)) {", "-\t\t\t\t\t\tif (mustBePublic && !currentMethod.isPublic()) { // only public methods from Object are visible to interface receiverTypes", "+\t\t\t\t\t\tif (receiverTypeIsInterface && !currentMethod.isPublic()) { // only public methods from Object are visible to interface receiverTypes", "+\t\tboolean searchForDefaultAbstractMethod = isCompliant14 && ! receiverTypeIsInterface && (receiverType.isAbstract() || receiverType.isTypeVariable());", "-\t\t\t\t\t\t\tif (isCompliant14 && (receiverType.isAbstract() || receiverType.isTypeVariable()))", "+\t\t\t\t\t\t\tif (searchForDefaultAbstractMethod)", "-\t\t// no match was found, try to find a close match when the parameter order is wrong or missing some parameters", "+\t\t// no match was found", "-\t\t\t// reduces secondary errors since missing interface method error is already reported", "+\t\t\t// abstract classes may get a match in interfaces; for non abstract", "+\t\t\t// classes, reduces secondary errors since missing interface method ", "+\t\t\t// error is already reported", "+", "+\t\t\t// still no match; try to find a close match when the parameter ", "+\t\t\t// order is wrong or missing some parameters", "-\t\tfor (int i = 0; i < candidatesCount; i++) {", "-\t\t\tMethodBinding methodBinding = candidates[i];", "-\t\t\tif (methodBinding.canBeSeenBy(receiverType, invocationSite, this)) {", "-\t\t\t\tif (visiblesCount != i) {", "-\t\t\t\t\tcandidates[i] = null;", "-\t\t\t\t\tcandidates[visiblesCount] = methodBinding;", "-\t\t\t\t}", "-\t\t\t\tvisiblesCount++;", "+\t\tif (receiverTypeIsInterface) {", "+\t\t\tif (candidatesCount == 1) {", "+\t\t\t\tunitScope.recordTypeReferences(candidates[0].thrownExceptions);", "+\t\t\t\treturn candidates[0];", "-\t\t}", "-\t\tif (visiblesCount == 1) {", "-\t\t\tif (isCompliant14 && (receiverType.isAbstract() || receiverType.isTypeVariable()))", "-\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, candidates[0]);", "-\t\t\tunitScope.recordTypeReferences(candidates[0].thrownExceptions);", "-\t\t\treturn candidates[0];", "-\t\t}", "-\t\tif (visiblesCount == 0) {", "-\t\t\tMethodBinding interfaceMethod =", "-\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, null);", "-\t\t\tif (interfaceMethod != null) return interfaceMethod;", "-\t\t\treturn new ProblemMethodBinding(candidates[0], candidates[0].selector, candidates[0].parameters, ProblemReasons.NotVisible);", "+\t\t\tvisiblesCount = candidatesCount;", "+\t\t} else {", "+\t\t\tfor (int i = 0; i < candidatesCount; i++) {", "+\t\t\t\tMethodBinding methodBinding = candidates[i];", "+\t\t\t\tif (methodBinding.canBeSeenBy(receiverType, invocationSite, this)) {", "+\t\t\t\t\tif (visiblesCount != i) {", "+\t\t\t\t\t\tcandidates[i] = null;", "+\t\t\t\t\t\tcandidates[visiblesCount] = methodBinding;", "+\t\t\t\t\t}", "+\t\t\t\t\tvisiblesCount++;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (visiblesCount == 1) {", "+\t\t\t\tif (searchForDefaultAbstractMethod)", "+\t\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, candidates[0]);", "+\t\t\t\tunitScope.recordTypeReferences(candidates[0].thrownExceptions);", "+\t\t\t\treturn candidates[0];", "+\t\t\t}", "+\t\t\tif (visiblesCount == 0) {", "+\t\t\t\tMethodBinding interfaceMethod =", "+\t\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, null);", "+\t\t\t\tif (interfaceMethod != null) return interfaceMethod;", "+\t\t\t\treturn new ProblemMethodBinding(candidates[0], candidates[0].selector, candidates[0].parameters, ProblemReasons.NotVisible);", "+\t\t\t}", "-\t\tif (isCompliant15", "-\t\t\t&& mostSpecificMethod.isValidBinding()", "-\t\t\t&& parameterCompatibilityLevel(mostSpecificMethod, argumentTypes) > COMPATIBLE) {", "-\t\t\t\t// see if there is a better match in the interfaces - see AutoBoxingTest 99", "+\t\tif (searchForDefaultAbstractMethod) { // search interfaces for a better match", "+\t\t\tif (mostSpecificMethod.isValidBinding())", "+\t\t\t\t// see if there is a better match in the interfaces - see AutoBoxingTest 99, LookupTest#81", "+\t\t\t// see if there is a match in the interfaces - see LookupTest#84", "+\t\t\tMethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, null);", "+\t\t\tif (interfaceMethod != null && interfaceMethod.isValidBinding() /* else return the same error as before */)", "+\t\t\t\treturn interfaceMethod;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b4bc00452fd180ce5a0ec33082f5b907", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "ba27b8beba862586d02454473338bb69e72c4fad", "commitAfterChange": "424434f0bc8f5f118b22e054c33acbc180d3cbd4", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \tpublic MethodBinding findMethod(\r \t\tReferenceBinding receiverType,\r \t\tchar[] selector,\r \t\tTypeBinding[] argumentTypes,\r \t\tInvocationSite invocationSite)", "signatureAfterChange": "\r \tpublic MethodBinding findMethod(\r \t\tReferenceBinding receiverType,\r \t\tchar[] selector,\r \t\tTypeBinding[] argumentTypes,\r \t\tInvocationSite invocationSite)", "diff": ["-\t\t//boolean relyOnDefaultAbstractMethods = environment().options.targetJDK < CompilerOptions.JDK1_2;\r", "+\r", "+\t\t// superclass lookup\r", "+\t\tboolean hierarchyContainsAbstractClasses = false;\r", "+\t\tReferenceBinding classHierarchyStart = currentType;\r", "+\t\t\r", "-\r", "-\t\t\t//if (!relyOnDefaultAbstractMethods && currentType.isAbstract())\r", "-\t\t\tif (currentType.isAbstract())\r", "-\t\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "+\t\t\tif (currentType.isAbstract()) hierarchyContainsAbstractClasses = true;\r", "+\t\t}\r", "+\r", "+\t\t// abstract superclass superinterface lookup (since maybe missing default\r", "+\t\t// abstract methods)\r", "+\t\tif (hierarchyContainsAbstractClasses){\r", "+\t\t\tcurrentType = classHierarchyStart;\r", "+\t\t\twhile (currentType != null){\r", "+\t\t\t\tif (currentType.isAbstract()){\r", "+\t\t\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "+\t\t\t\t}\r", "+\t\t\t\tcurrentType = currentType.superclass();\r", "+\t\t\t}\r", "-\t\tMethodBinding[] compatible = new MethodBinding[foundSize];\r", "-\t\tint compatibleIndex = 0;\r", "+\t\tMethodBinding[] candidates = new MethodBinding[foundSize];\r", "+\t\tint candidatesCount = 0;\r", "+\r", "+\t\t// argument type compatibility check\r", "-\t\t\t\tcompatible[compatibleIndex++] = methodBinding;\r", "+\t\t\t\tcandidates[candidatesCount++] = methodBinding;\r", "-\t\tif (compatibleIndex == 1)\r", "-\t\t\treturn compatible[0]; // have not checked visibility\r", "-\t\tif (compatibleIndex == 0) { // try to find a close match when the parameter order is wrong or missing some parameters\r", "+\t\tif (candidatesCount == 1)\r", "+\t\t\treturn candidates[0]; // have not checked visibility\r", "+\t\tif (candidatesCount == 0) { // try to find a close match when the parameter order is wrong or missing some parameters\r", "-\t\tMethodBinding[] visible = new MethodBinding[compatibleIndex];\r", "-\t\tint visibleIndex = 0;\r", "-\t\tfor (int i = 0; i < compatibleIndex; i++) {\r", "-\t\t\tMethodBinding methodBinding = compatible[i];\r", "-\t\t\tif (methodBinding.canBeSeenBy(receiverType, invocationSite, this))\r", "-\t\t\t\tvisible[visibleIndex++] = methodBinding;\r", "+\t\t// visibility check\r", "+\t\tint visiblesCount = 0;\r", "+\t\tfor (int i = 0; i < candidatesCount; i++) {\r", "+\t\t\tMethodBinding methodBinding = candidates[i];\r", "+\t\t\tif (methodBinding.canBeSeenBy(receiverType, invocationSite, this)) {\r", "+\t\t\t\tif (visiblesCount != i) {\r", "+\t\t\t\t\tcandidates[i] = null;\r", "+\t\t\t\t\tcandidates[visiblesCount] = methodBinding;\r", "+\t\t\t\t}\r", "+\t\t\t\tvisiblesCount++;\r", "+\t\t\t}\r", "-\t\tif (visibleIndex == 1) {\r", "-\t\t\tcompilationUnitScope().recordTypeReferences(visible[0].thrownExceptions);\r", "-\t\t\treturn visible[0];\r", "+\t\tif (visiblesCount == 1) {\r", "+\t\t\tcompilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);\r", "+\t\t\treturn candidates[0];\r", "-\t\tif (visibleIndex == 0)\r", "+\t\tif (visiblesCount == 0)\r", "-\t\t\t\tcompatible[0].selector,\r", "+\t\t\t\tcandidates[0].selector,\r", "-\t\t\t\tcompatible[0].declaringClass,\r", "+\t\t\t\tcandidates[0].declaringClass,\r", "-\t\tif (visible[0].declaringClass.isClass())\r", "-\t\t\treturn mostSpecificClassMethodBinding(visible, visibleIndex);\r", "-\t\telse\r", "-\t\t\treturn mostSpecificInterfaceMethodBinding(visible, visibleIndex);\r", "+\t\t\t\t\r", "+\t\tif (candidates[0].declaringClass.isClass()) {\r", "+\t\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount);\r", "+\t\t} else {\r", "+\t\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount);\r", "+\t\t}\r"]}], "num": 43106}