{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dc6081cba465c87f994056e32ccf7ec0", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85a710385a41f3345f74be479ff444a9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "18214de46fa9202fa142bc8c10e22754e8ddc00c", "commitAfterChange": "a19e5612a97c00c41d991b7d28c08961f0357225", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "signatureAfterChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "diff": ["-\t\t\t\t\t\tif (innerCtx == null)", "-\t\t\t\t\t\t\tInferenceContext18.missingImplementation(\"Missing context for inner inference for \"+invocation.toString()); //$NON-NLS-1$", "+\t\t\t\t\t\tif (innerCtx == null) { // no inference -> assume it wasn't really poly after all", "+\t\t\t\t\t\t\tTypeBinding exprType = this.left.resolvedType;", "+\t\t\t\t\t\t\tif (exprType == null || !exprType.isValidBinding())", "+\t\t\t\t\t\t\t\treturn FALSE;", "+\t\t\t\t\t\t\treturn new ConstraintTypeFormula(exprType, this.right, COMPATIBLE, this.isSoft);", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ece71cfe6e7a54252465a11d30a39b30", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "a337a67d07e229d2e8a590edfef8bdffb92e4516", "commitAfterChange": "f0baa4687c4b232261eab4264c1bc16ee1b49e9d", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, \t\t\tInvocationSite invocationSite, int inferenceLevel)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, \t\t\tInvocationSite invocationSite, int inferenceLevel)", "diff": ["+\t\t\t\tif (infCtx18 == null)", "+\t\t\t\t\treturn originalMethod;", "+\t\t\t\t\t\t\tif (invocationSite instanceof ReferenceExpression)", "+\t\t\t\t\t\t\t\t((ReferenceExpression) invocationSite).inferenceKind = infCtx18.inferenceKind;", "-\t\t\t\t\t\t\t\treturn methodSubstitute.boundCheck18(scope, arguments);", "+\t\t\t\t\t\t\t\tMethodBinding problemMethod = methodSubstitute.boundCheck18(scope, arguments);", "+\t\t\t\t\t\t\t\tif (problemMethod != null)", "+\t\t\t\t\t\t\t\t\treturn problemMethod;", "-\t\t\t\t\t\t\t\treturn methodSubstitute;", "+\t\t\t\t\t\t\treturn methodSubstitute;"]}], "num": 4645}