{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "762367a1b58b69ca39a65a359338d8ac", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2460db385be4f0210a8dcdbb9ff8bf1d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "08a9fdc71afa0132ac39c0b0527fded03b0bf377", "commitAfterChange": "41212d6ccde0d1bea3d4ddbc47774cebd313e943", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] rawClasspath, IPath projectOutputLocation)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] rawClasspath, IPath projectOutputLocation)", "diff": ["+\t\t\tIPath path = resolvedEntry.getPath();", "-\t\t\t\t\tif ((index = indexOfMatchingPath(resolvedEntry.getPath(), outputLocations, outputCount)) != -1){", "+\t\t\t\t\tif ((index = indexOfMatchingPath(path, outputLocations, outputCount)) != -1){", "-\t\t\t\t\thasLibFolder |= !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(resolvedEntry.getPath().lastSegment());", "-\t\t\t\t\tif ((index = indexOfMatchingPath(resolvedEntry.getPath(), outputLocations, outputCount)) != -1){", "+\t\t\t\t\thasLibFolder |= !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(path.lastSegment());", "+\t\t\t\t\tif ((index = indexOfMatchingPath(path, outputLocations, outputCount)) != -1){", "-\t", "-\t", "+\t\t// ensure that no output is coincidating with another source folder (only allowed if matching current source folder)", "+\t\t// perform one separate iteration so as to not take precedence over previously checked scenarii (in particular should", "+\t\t// diagnose nesting source folder issue before this one, e.g. [src]\"Project/\", [src]\"Project/source/\" and output=\"Project/\" should", "+\t\t// first complain about missing exclusion pattern", "+\t\tfor (int i = 0 ; i < length; i++) {", "+\t\t\tIClasspathEntry entry = classpath[i];", "+\t\t\tif (entry == null) continue;", "+\t\t\tIPath entryPath = entry.getPath();", "+\t\t\tint kind = entry.getEntryKind();", "+", "+\t\t\tif (kind == IClasspathEntry.CPE_SOURCE) {", "+\t\t\t\tIPath output = entry.getOutputLocation();", "+\t\t\t\tif (output == null) output = projectOutputLocation; // if no specific output, still need to check using default output", "+\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\tIClasspathEntry otherEntry = classpath[j];", "+\t\t\t\t\tif (otherEntry == entry) continue;", "+\t\t\t\t\tswitch (otherEntry.getEntryKind()) {", "+\t\t\t\t\t\tcase IClasspathEntry.CPE_SOURCE :", "+\t\t\t\t\t\t\tif (otherEntry.getPath().equals(output)) {", "+\t\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotUseDistinctSourceFolderAsOutput\", entryPath.makeRelative().toString(), otherEntry.getPath().makeRelative().toString())); //$NON-NLS-1$", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY :", "+\t\t\t\t\t\t\tif (otherEntry.getPath().equals(output)) {", "+\t\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotUseLibraryAsOutput\", entryPath.makeRelative().toString(), otherEntry.getPath().makeRelative().toString())); //$NON-NLS-1$", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}\t\t\t", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b0dc0dde042a9c728844295a31fcaad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "cc7aa64325098cb95ddb21b1ff5c605a41d7b6cb", "commitAfterChange": "62d5e4ea01329275dd7873def8e9944099937650", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "diff": ["+\r", "+\t// tolerate null path, it will be reset to default\r", "+\tint length = classpath == null ? 0 : classpath.length; \r", "+\r", "-\tfor (int i = 0, length = classpath.length ; i < length; i++) {\r", "+\tfor (int i = 0 ; i < length; i++) {\r", "+\tObjectSet pathes = new ObjectSet(length);\r", "+\t\r", "-\tfor (int i = 0 ; i < classpath.length; i++) {\r", "+\tfor (int i = 0 ; i < length; i++) {\r", "-\t\tif (entry == null) continue;\r", "-\t\tIPath entryPath = entry.getPath();\r", "+\t\tif (entry == null) continue;\r", "+\r", "+\t\tIPath entryPath = entry.getPath();\r", "+\t\tint kind = entry.getEntryKind();\r", "+\r", "+\t\t// complain if duplicate path\r", "+\t\tif (!pathes.add(entryPath)){\r", "+\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.NAME_COLLISION, Util.bind(\"classpath.duplicateEntryPath\", entryPath.toString())); //$NON-NLS-1$\r", "+\t\t}\r", "-\t\tif (entryPath.equals(projectPath)) continue;\r", "+\t\tif (entryPath.equals(projectPath)){\r", "+\t\t\t// complain if self-referring project entry\r", "+\t\t\tif (kind == IClasspathEntry.CPE_PROJECT){\r", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, Util.bind(\"classpath.cannotReferToItself\", entryPath.toString()));//$NON-NLS-1$\r", "+\t\t\t}\r", "+\t\t\tcontinue;\r", "+\t\t}\r", "-\t\t\r", "+\r", "+\r", "-\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE){\r", "+\t\tif (kind == IClasspathEntry.CPE_SOURCE \r", "+\t\t\t\t|| (kind == IClasspathEntry.CPE_LIBRARY && !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(entryPath.toString()))){\r", "-\t\t\t\tif (entry != otherEntry && otherEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE){\r", "-\t\t\t\t\tif (entryPath.isPrefixOf(otherEntry.getPath())){\r", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestSourceFolderInSource\",entryPath.toString(), otherEntry.getPath().toString())); //$NON-NLS-1$\r", "+\t\t\t\tint otherKind = otherEntry.getEntryKind();\r", "+\t\t\t\tif (entry != otherEntry \r", "+\t\t\t\t\t&& (otherKind == IClasspathEntry.CPE_SOURCE \r", "+\t\t\t\t\t\t\t|| (otherKind == IClasspathEntry.CPE_LIBRARY \r", "+\t\t\t\t\t\t\t\t\t&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(otherEntry.getPath().toString())))){\r", "+\t\t\t\t\tif (otherEntry.getPath().isPrefixOf(entryPath)){\r", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInEntry\", entryPath.toString(), otherEntry.getPath().toString())); //$NON-NLS-1$\r"]}], "num": 36960}