{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3719f39599ba6229328d67f91c939b47", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "048b9adb9abb935fbe11133103553b8b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/HierarchyResolver.java", "commitBeforeChange": "81506ae8cde4c9731bf1393802436c42681071e3", "commitAfterChange": "38b45821c6a8adb25c41b5b709d94fc0713cc3dd", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r private void reportHierarchy()", "signatureAfterChange": "\r private void reportHierarchy()", "diff": ["-\t// ensure each binary type knows its supertypes before reporting the hierarchy\r", "-\tint problemLength = typeIndex+1;\r", "-\tboolean[] typesWithProblem = new boolean[problemLength];\r", "-\tfor (int current = 0; current <= typeIndex; current++) { // typeIndex may continue to grow\r", "-\t\tReferenceBinding typeBinding = typeBindings[current];\r", "-\t\tif (typeBinding.isBinaryBinding()) {\r", "-\t\t\t// fault in its hierarchy...\r", "-\t\t\ttry {\r", "-\t\t\t\ttypeBinding.superclass();\r", "-\t\t\t\ttypeBinding.superInterfaces();\r", "-\t\t\t} catch (AbortCompilation e) {\r", "-\t\t\t\tif (current >= problemLength) {\r", "-\t\t\t\t\tSystem.arraycopy(typesWithProblem, 0, typesWithProblem = new boolean[current+1], 0, problemLength);\r", "-\t\t\t\t\tproblemLength = current+1;\r", "-\t\t\t\t}\r", "-\t\t\t\ttypesWithProblem[current] = true;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r", "-\r", "-\t\tif (current < problemLength && typesWithProblem[current]) continue;\r", "-\r", "+\r", "+\t\tif (!subOrSuperOfFocus(typeBinding)) {\r", "+\t\t\tcontinue; // ignore types outside of hierarchy\r", "+\t\t}\r", "+\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0f131f377068df1bf5b0bd43ec105773", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java", "commitBeforeChange": "d85d39eaac6c50a092ebc71013caff6067946721", "commitAfterChange": "4113d4b15f909d9ae6a13dfdc1603db4b3835658", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " private void generateAnnotationInfo(JavaElement parent, HashMap newElements, IBinaryAnnotation annotationInfo)", "signatureAfterChange": " private void generateAnnotationInfo(JavaElement parent, HashMap newElements, IBinaryAnnotation annotationInfo)", "diff": ["+\tgenerateAnnotationInfo(parent, newElements, annotationInfo, null);", "+}", "-\tAnnotation annotation = new Annotation(parent, new String(typeName));", "-\t\t\tgenerateAnnotationInfo(annotation, newElements, (IBinaryAnnotation) value);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3c74849a37a59e512cfbd29fde6ae58c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "694b8ccf96bd76967363d1bcdba493ae5464ca4d", "commitAfterChange": "88b45f0d87eead26518b1d6a35c12c8894aa8965", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["-\tboolean mustImplementAbstractMethods = ((this.type.modifiers & IConstants.AccInterface) == 0) && !this.type.isAbstract();", "-\tif (mustImplementAbstractMethods && this.type.isEnum() && !this.type.isAnonymousType()) {", "-\t\t// enum type only needs to implement abstract methods if any of its constants does not supply a body", "-\t\tcheckEnumConstantBodies: {", "-\t\t\tTypeDeclaration typeDeclaration = this.type.scope.referenceContext;", "-\t\t\tfor (int i = 0, length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length; i < length; i++) {", "-\t\t\t\tFieldDeclaration fieldDecl = typeDeclaration.fields[i];", "-\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT && !(fieldDecl.initialization instanceof QualifiedAllocationExpression)) {", "-\t\t\t\t\tbreak checkEnumConstantBodies; // leave mustImplementAbstractMethods flag on ", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tmustImplementAbstractMethods = false; // since all enum constants define an anonymous body", "-\t\t}", "-\t}", "+\tboolean mustImplementAbstractMethods = mustImplementAbstractMethods();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4fab4eef0d817d6ed502537dd6f9e9f1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchingOpenable.java", "commitBeforeChange": "7daed772befc71241cd5718015cdd1d8faa642ca", "commitAfterChange": "bf0f3c0ee6c28cc3716705a3315c5622fc576ce2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public void buildTypeBindings()", "signatureAfterChange": " public void buildTypeBindings()", "diff": ["-\t// if a parsed unit exits, its bindings have already been built", "-\tif (this.parsedUnit != null) return;", "-\t", "-\tchar[] source = this.getSource();", "-\tif (source == null) return;", "-\tthis.buildTypeBindings(source);", "-\t\t\t", "-\tif (this.openable instanceof org.eclipse.jdt.internal.core.ClassFile) {", "-\t\t// try to use the main type's class file as the openable", "-\t\tTypeDeclaration[] types = this.parsedUnit.types;", "-\t\tif (types != null) {", "-\t\t\tString classFileName = openable.getElementName();", "-\t\t\tfor (int i = 0, length = types.length; i < length; i++) {", "-\t\t\t\tTypeDeclaration typeDeclaration = types[i];", "-\t\t\t\tString simpleTypeName = new String(typeDeclaration.name);", "-\t\t\t\tif (classFileName.startsWith(simpleTypeName)) {", "-\t\t\t\t\tIPackageFragment parent = (IPackageFragment)openable.getParent();", "-\t\t\t\t\tthis.openable = (Openable)parent.getClassFile(simpleTypeName + \".class\"); //$NON-NLS-1$", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t} ", "-\t\t}", "+\tif (this.parsedUnit == null) {", "+\t\tchar[] source = this.getSource();", "+\t\tif (source == null) return;", "+\t\tthis.buildTypeBindings(source);", "+\t} else {", "+\t\t// if a parsed unit's scope is set, its bindings have already been built", "+\t\tif (this.parsedUnit.scope != null) return;", "+\t\t", "+\t\tthis.locator.lookupEnvironment.buildTypeBindings(this.parsedUnit);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c35fc7457b968faef3a650343dddf73", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "8726985690d5211d83787440cfdc69960f688cd3", "commitAfterChange": "b2bac1f114347c5119b74b76ba91158e0de76647", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": "\r \tpublic boolean hasClasspathCycle(IClasspathEntry[] entries)", "signatureAfterChange": "\r \tpublic boolean hasClasspathCycle(IClasspathEntry[] entries)", "diff": ["-\r", "-\t\tStringHashtableOfInt depthTable = new StringHashtableOfInt();\r", "+\t\t\r", "+\t\tHashSet cycleParticipants = new HashSet();\r", "+\t\tupdateCycleParticipants(entries, new HashSet(), cycleParticipants, getWorkspace().getRoot());\r", "+\t\treturn !cycleParticipants.isEmpty();\r", "+\t}\r", "-\t\t\tString projectName = this.getElementName();\r", "-\t\t\tdepthTable.put(projectName, -2); // mark this project as being visited\r", "-\t\t\tString[] prerequisites = this.projectPrerequisites(entries);\r", "-\t\t\tfor (int i = 0, length = prerequisites.length; i < length; i++) {\r", "-\t\t\t\t((JavaModel) this.getJavaModel()).computeDepth(\r", "-\t\t\t\t\tprerequisites[i],\r", "-\t\t\t\t\tdepthTable);\r", "-\t\t} catch (JavaModelException e) {\r", "-\t\t\treturn e.getStatus().getCode() == IJavaModelStatusConstants.NAME_COLLISION;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa0321a7868c105688fee9e86c40690c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "424b9c711eb8f066b325841662effb171f3ae4ef", "commitAfterChange": "4d19416746402b8fbbfd02c13772658da70a345a", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \tpublic void computePackageFragmentRoots(\r \t\tIClasspathEntry entry,\r \t\tObjectVector accumulatedRoots, \r \t\tObjectSet rootIDs, \r \t\tboolean insideOriginalProject,\r \t\tboolean checkExistency,\r \t\tboolean computeBuilderRoots)", "signatureAfterChange": "\r \tpublic void computePackageFragmentRoots(\r \t\tIClasspathEntry entry,\r \t\tObjectVector accumulatedRoots, \r \t\tObjectSet rootIDs, \r \t\tboolean insideOriginalProject,\r \t\tboolean checkExistency,\r \t\tboolean retrieveExportedRoots)", "diff": ["-\t\tboolean computeBuilderRoots) {\r", "+\t\tboolean retrieveExportedRoots) {\r", "-\t\t\t\tif (computeBuilderRoots) return;\r", "+\t\t\t\tif (!retrieveExportedRoots) return;\r", "-\t\t\t\t\tif (computeBuilderRoots){\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tIResource output = workspaceRoot.findMember(requiredProject.getOutputLocation());\r", "-\t\t\t\t\t\t\tif (output != null && output.exists()){\r", "-\t\t\t\t\t\t\t\tPackageFragmentRoot binaryOutputRoot =\r", "-\t\t\t\t\t\t\t\t\t(PackageFragmentRoot) requiredProject.getPackageFragmentRoot(output);\r", "-\t\t\t\t\t\t\t\tbinaryOutputRoot.setOccurrenceCount(binaryOutputRoot.getOccurrenceCount() + 1);\r", "-\t\t\t\t\t\t\t\t((PackageFragmentRootInfo) binaryOutputRoot.getElementInfo()).setRootKind(\r", "-\t\t\t\t\t\t\t\t\tIPackageFragmentRoot.K_BINARY);\r", "-\t\t\t\t\t\t\t\tbinaryOutputRoot.refreshChildren();\r", "-\t\t\t\t\t\t\t\taccumulatedRoots.add(binaryOutputRoot);\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t} catch (JavaModelException e){\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\trequiredProject.computePackageFragmentRoots(accumulatedRoots, rootIDs, false, checkExistency, computeBuilderRoots);\r", "+\t\t\t\t\trequiredProject.computePackageFragmentRoots(accumulatedRoots, rootIDs, false, checkExistency, retrieveExportedRoots);\r"]}], "num": 30440}