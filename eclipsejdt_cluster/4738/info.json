{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4c2d48ff3f1bb49d61b5ae0a5ab224ba", "detectedBy": ["DIFF_HIERARCHICAL", "AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0115b839adaf561c289520bd81a22f50", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "a1b8b888d8c8c040023fcd2856f96f5ad6c69b3e", "commitAfterChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r \tpublic void locateMatches(String[] filePaths, IWorkspace workspace)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r public void locateMatches(String[] filePaths, IWorkspace workspace) throws JavaModelException", "diff": ["+ */\r", "+public void locateMatches(String[] filePaths, IWorkspace workspace) throws JavaModelException {\r", "+\tUtil.sort(filePaths); // sort by projects\r", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "+\tJavaProject previousJavaProject = null;\r", "+\tint length = filePaths.length;\r", "+\tdouble increment = 100.0 / length;\r", "+\tdouble totalWork = 0;\r", "+\tint lastProgress = 0;\r", "+\tboolean couldInitializePattern = false;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIProgressMonitor monitor = this.collector.getProgressMonitor();\r", "+\t\tif (monitor != null && monitor.isCanceled()) {\r", "+\t\t\tthrow new OperationCanceledException();\r", "+\t\t}\r", "+\t\tString pathString = filePaths[i];\r", "+\t\tthis.currentOpenable = factory.createOpenable(pathString);\r", "+\t\tif (this.currentOpenable == null) continue;  // match is outside classpath\r", "+\r", "+\t\t// create new parser and lookup environment if this is a new project\r", "+\t\ttry {\r", "+\t\t\tJavaProject javaProject = (JavaProject)this.currentOpenable.getJavaProject();\r", "+\t\t\tthis.currentResource = this.currentOpenable.getUnderlyingResource();\r", "+\t\t\tif (this.currentResource == null) { // case of a file in an external jar\r", "+\t\t\t\tthis.currentResource = javaProject.getProject();\r", "+\t\t\t}\r", "+\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "+\t\t\t\t// create parser for this project\r", "+\t\t\t\tcouldInitializePattern = this.createParser(javaProject);\r", "+\t\t\t\tpreviousJavaProject = javaProject;\r", "+\t\t\t}\r", "+\t\t\tif (!couldInitializePattern) continue; // the pattern could not be initialized: the match cannot be in this project\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t\t// file doesn't exist -> skip it\r", "+\t\t\tcontinue;\r", "+\t\t// locate matches in current file and report them\r", "+\t\ttry {\r", "+\t\t\tif (this.currentOpenable instanceof CompilationUnit) {\r", "+\t\t\t\tthis.locateMatchesInCompilationUnit();\r", "+\t\t\t} else if (this.currentOpenable instanceof org.eclipse.jdt.internal.core.ClassFile) {\r", "+\t\t\t\tthis.locateMatchesInClassFile();\r", "+\t\t\t}\r", "+\t\t} catch (AbortCompilation e) {\r", "+\t\t\t// problem with class path: it could not find base classes\r", "+\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "+\t\t} catch (CoreException e) {\r", "+\t\t\tif (e instanceof JavaModelException) {\r", "+\t\t\t\tthrow (JavaModelException)e;\r", "+\t\t\t} else {\r", "+\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (monitor != null) {\r", "+\t\t\ttotalWork = totalWork + increment;\r", "+\t\t\tint worked = (int)totalWork - lastProgress;\r", "+\t\t\tmonitor.worked(worked);\r", "+\t\t\tlastProgress = (int)totalWork;\r", "+\t\t}\r", "+\t}\r", "+}\r", "-\t */\r", "-\tpublic void locateMatches(String[] filePaths, IWorkspace workspace)\r", "-\t\tthrows JavaModelException {\r", "-\t\tUtil.sort(filePaths); // sort by projects\r", "-\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "-\t\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "-\t\tJavaProject previousJavaProject = null;\r", "-\t\tint length = filePaths.length;\r", "-\t\tdouble increment = 100.0 / length;\r", "-\t\tdouble totalWork = 0;\r", "-\t\tint lastProgress = 0;\r", "-\t\tboolean couldInitializePattern = false;\r", "-\t\tthis.potentialMatches = new PotentialMatch[10];\r", "-\t\tthis.potentialMatchesLength = 0;\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tIProgressMonitor monitor = this.collector.getProgressMonitor();\r", "-\t\t\tif (monitor != null && monitor.isCanceled()) {\r", "-\t\t\t\tthrow new OperationCanceledException();\r", "-\t\t\t}\r", "-\t\t\tString pathString = filePaths[i];\r", "-\t\t\tOpenable openable = factory.createOpenable(pathString);\r", "-\t\t\tif (openable == null)\r", "-\t\t\t\tcontinue; // match is outside classpath\r", "-\r", "-\t\t\t// create new parser and lookup environment if this is a new project\r", "-\t\t\tIResource resource = null;\r", "-\t\t\ttry {\r", "-\t\t\t\tJavaProject javaProject = (JavaProject) openable.getJavaProject();\r", "-\t\t\t\tresource = openable.getUnderlyingResource();\r", "-\t\t\t\tif (resource == null) { // case of a file in an external jar\r", "-\t\t\t\t\tresource = javaProject.getProject();\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "-\t\t\t\t\t// locate matches in previous project\r", "-\t\t\t\t\tif (previousJavaProject != null) {\r", "-\t\t\t\t\t\tthis.locateMatches();\r", "-\t\t\t\t\t\tthis.potentialMatchesLength = 0;\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\t// create parser for this project\r", "-\t\t\t\t\tcouldInitializePattern = this.createParser(javaProject);\r", "-\t\t\t\t\tpreviousJavaProject = javaProject;\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!couldInitializePattern)\r", "-\t\t\t\t\tcontinue;\r", "-\t\t\t\t// the pattern could not be initialized: the match cannot be in this project\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t// file doesn't exist -> skip it\r", "-\t\t\t\tcontinue;\r", "-\t\t\t}\r", "-\r", "-\t\t\t// add potential match\r", "-\t\t\tthis.addPotentialMatch(resource, openable);\r", "-\r", "-\t\t\tif (monitor != null) {\r", "-\t\t\t\ttotalWork = totalWork + increment;\r", "-\t\t\t\tint worked = (int) totalWork - lastProgress;\r", "-\t\t\t\tmonitor.worked(worked);\r", "-\t\t\t\tlastProgress = (int) totalWork;\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\t// last project\r", "-\t\tif (previousJavaProject != null) {\r", "-\t\t\tthis.locateMatches();\r", "-\t\t\tthis.potentialMatchesLength = 0;\r", "-\t\t}\r", "-\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a04733dfe9c5084b7d40c20411b61f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "46418d248f89a29f49a77d154cdbfa57c408b256", "commitAfterChange": "c85433e27f0fa74bfe8e06c38c1c02c51b5599d7", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r \tpublic void locateMatches(String[] filePaths, IWorkspace workspace)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r public void locateMatches(String[] filePaths, IWorkspace workspace) throws JavaModelException", "diff": ["+ */\r", "+public void locateMatches(String[] filePaths, IWorkspace workspace) throws JavaModelException {\r", "+\tUtil.sort(filePaths); // sort by projects\r", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "+\tJavaProject previousJavaProject = null;\r", "+\tint length = filePaths.length;\r", "+\tdouble increment = 100.0 / length;\r", "+\tdouble totalWork = 0;\r", "+\tint lastProgress = 0;\r", "+\tboolean couldInitializePattern = false;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIProgressMonitor monitor = this.collector.getProgressMonitor();\r", "+\t\tif (monitor != null && monitor.isCanceled()) {\r", "+\t\t\tthrow new OperationCanceledException();\r", "+\t\t}\r", "+\t\tString pathString = filePaths[i];\r", "+\t\tthis.currentOpenable = factory.createOpenable(pathString);\r", "+\t\tif (this.currentOpenable == null) continue;  // match is outside classpath\r", "+\r", "+\t\t// create new parser and lookup environment if this is a new project\r", "+\t\ttry {\r", "+\t\t\tJavaProject javaProject = (JavaProject)this.currentOpenable.getJavaProject();\r", "+\t\t\tthis.currentResource = this.currentOpenable.getUnderlyingResource();\r", "+\t\t\tif (this.currentResource == null) { // case of a file in an external jar\r", "+\t\t\t\tthis.currentResource = javaProject.getProject();\r", "+\t\t\t}\r", "+\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "+\t\t\t\t// create parser for this project\r", "+\t\t\t\tcouldInitializePattern = this.createParser(javaProject);\r", "+\t\t\t\tpreviousJavaProject = javaProject;\r", "+\t\t\t}\r", "+\t\t\tif (!couldInitializePattern) continue; // the pattern could not be initialized: the match cannot be in this project\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t\t// file doesn't exist -> skip it\r", "+\t\t\tcontinue;\r", "+\t\t// locate matches in current file and report them\r", "+\t\ttry {\r", "+\t\t\tif (this.currentOpenable instanceof CompilationUnit) {\r", "+\t\t\t\tthis.locateMatchesInCompilationUnit();\r", "+\t\t\t} else if (this.currentOpenable instanceof org.eclipse.jdt.internal.core.ClassFile) {\r", "+\t\t\t\tthis.locateMatchesInClassFile();\r", "+\t\t\t}\r", "+\t\t} catch (AbortCompilation e) {\r", "+\t\t\t// problem with class path: it could not find base classes\r", "+\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "+\t\t} catch (CoreException e) {\r", "+\t\t\tif (e instanceof JavaModelException) {\r", "+\t\t\t\tthrow (JavaModelException)e;\r", "+\t\t\t} else {\r", "+\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (monitor != null) {\r", "+\t\t\ttotalWork = totalWork + increment;\r", "+\t\t\tint worked = (int)totalWork - lastProgress;\r", "+\t\t\tmonitor.worked(worked);\r", "+\t\t\tlastProgress = (int)totalWork;\r", "+\t\t}\r", "+\t}\r", "+}\r", "-\t */\r", "-\tpublic void locateMatches(String[] filePaths, IWorkspace workspace)\r", "-\t\tthrows JavaModelException {\r", "-\t\tUtil.sort(filePaths); // sort by projects\r", "-\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "-\t\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "-\t\tJavaProject previousJavaProject = null;\r", "-\t\tint length = filePaths.length;\r", "-\t\tdouble increment = 100.0 / length;\r", "-\t\tdouble totalWork = 0;\r", "-\t\tint lastProgress = 0;\r", "-\t\tboolean couldInitializePattern = false;\r", "-\t\tthis.potentialMatches = new PotentialMatch[10];\r", "-\t\tthis.potentialMatchesLength = 0;\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tIProgressMonitor monitor = this.collector.getProgressMonitor();\r", "-\t\t\tif (monitor != null && monitor.isCanceled()) {\r", "-\t\t\t\tthrow new OperationCanceledException();\r", "-\t\t\t}\r", "-\t\t\tString pathString = filePaths[i];\r", "-\t\t\tOpenable openable = factory.createOpenable(pathString);\r", "-\t\t\tif (openable == null)\r", "-\t\t\t\tcontinue; // match is outside classpath\r", "-\r", "-\t\t\t// create new parser and lookup environment if this is a new project\r", "-\t\t\tIResource resource = null;\r", "-\t\t\ttry {\r", "-\t\t\t\tJavaProject javaProject = (JavaProject) openable.getJavaProject();\r", "-\t\t\t\tresource = openable.getUnderlyingResource();\r", "-\t\t\t\tif (resource == null) { // case of a file in an external jar\r", "-\t\t\t\t\tresource = javaProject.getProject();\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "-\t\t\t\t\t// locate matches in previous project\r", "-\t\t\t\t\tif (previousJavaProject != null) {\r", "-\t\t\t\t\t\tthis.locateMatches();\r", "-\t\t\t\t\t\tthis.potentialMatchesLength = 0;\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\t// create parser for this project\r", "-\t\t\t\t\tcouldInitializePattern = this.createParser(javaProject);\r", "-\t\t\t\t\tpreviousJavaProject = javaProject;\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!couldInitializePattern)\r", "-\t\t\t\t\tcontinue;\r", "-\t\t\t\t// the pattern could not be initialized: the match cannot be in this project\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t// file doesn't exist -> skip it\r", "-\t\t\t\tcontinue;\r", "-\t\t\t}\r", "-\r", "-\t\t\t// add potential match\r", "-\t\t\tthis.addPotentialMatch(resource, openable);\r", "-\r", "-\t\t\tif (monitor != null) {\r", "-\t\t\t\ttotalWork = totalWork + increment;\r", "-\t\t\t\tint worked = (int) totalWork - lastProgress;\r", "-\t\t\t\tmonitor.worked(worked);\r", "-\t\t\t\tlastProgress = (int) totalWork;\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\t// last project\r", "-\t\tif (previousJavaProject != null) {\r", "-\t\t\tthis.locateMatches();\r", "-\t\t\tthis.potentialMatchesLength = 0;\r", "-\t\t}\r", "-\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "68b596d8130274a85e1e4596a74113b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "7e5cc03e445550d3cbc10c611218c79332074276", "commitAfterChange": "c57706d05dc3654769cca2053ff9cb20fb0a6664", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r \tpublic void locateMatches(String[] filePaths, IWorkspace workspace)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r public void locateMatches(String[] filePaths, IWorkspace workspace) throws JavaModelException", "diff": ["+ */\r", "+public void locateMatches(String[] filePaths, IWorkspace workspace) throws JavaModelException {\r", "+\tUtil.sort(filePaths); // sort by projects\r", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "+\tJavaProject previousJavaProject = null;\r", "+\tint length = filePaths.length;\r", "+\tdouble increment = 100.0 / length;\r", "+\tdouble totalWork = 0;\r", "+\tint lastProgress = 0;\r", "+\tboolean couldInitializePattern = false;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIProgressMonitor monitor = this.collector.getProgressMonitor();\r", "+\t\tif (monitor != null && monitor.isCanceled()) {\r", "+\t\t\tthrow new OperationCanceledException();\r", "+\t\t}\r", "+\t\tString pathString = filePaths[i];\r", "+\t\tthis.currentOpenable = factory.createOpenable(pathString);\r", "+\t\tif (this.currentOpenable == null) continue;  // match is outside classpath\r", "+\r", "+\t\t// create new parser and lookup environment if this is a new project\r", "+\t\ttry {\r", "+\t\t\tJavaProject javaProject = (JavaProject)this.currentOpenable.getJavaProject();\r", "+\t\t\tthis.currentResource = this.currentOpenable.getUnderlyingResource();\r", "+\t\t\tif (this.currentResource == null) { // case of a file in an external jar\r", "+\t\t\t\tthis.currentResource = javaProject.getProject();\r", "+\t\t\t}\r", "+\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "+\t\t\t\t// create parser for this project\r", "+\t\t\t\tcouldInitializePattern = this.createParser(javaProject);\r", "+\t\t\t\tpreviousJavaProject = javaProject;\r", "+\t\t\t}\r", "+\t\t\tif (!couldInitializePattern) continue; // the pattern could not be initialized: the match cannot be in this project\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t\t// file doesn't exist -> skip it\r", "+\t\t\tcontinue;\r", "+\t\t// locate matches in current file and report them\r", "+\t\ttry {\r", "+\t\t\tif (this.currentOpenable instanceof CompilationUnit) {\r", "+\t\t\t\tthis.locateMatchesInCompilationUnit();\r", "+\t\t\t} else if (this.currentOpenable instanceof org.eclipse.jdt.internal.core.ClassFile) {\r", "+\t\t\t\tthis.locateMatchesInClassFile();\r", "+\t\t\t}\r", "+\t\t} catch (AbortCompilation e) {\r", "+\t\t\t// problem with class path: it could not find base classes\r", "+\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "+\t\t} catch (CoreException e) {\r", "+\t\t\tif (e instanceof JavaModelException) {\r", "+\t\t\t\tthrow (JavaModelException)e;\r", "+\t\t\t} else {\r", "+\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (monitor != null) {\r", "+\t\t\ttotalWork = totalWork + increment;\r", "+\t\t\tint worked = (int)totalWork - lastProgress;\r", "+\t\t\tmonitor.worked(worked);\r", "+\t\t\tlastProgress = (int)totalWork;\r", "+\t\t}\r", "+\t}\r", "+}\r", "-\t */\r", "-\tpublic void locateMatches(String[] filePaths, IWorkspace workspace)\r", "-\t\tthrows JavaModelException {\r", "-\t\tUtil.sort(filePaths); // sort by projects\r", "-\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "-\t\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "-\t\tJavaProject previousJavaProject = null;\r", "-\t\tint length = filePaths.length;\r", "-\t\tdouble increment = 100.0 / length;\r", "-\t\tdouble totalWork = 0;\r", "-\t\tint lastProgress = 0;\r", "-\t\tboolean couldInitializePattern = false;\r", "-\t\tthis.potentialMatches = new PotentialMatch[10];\r", "-\t\tthis.potentialMatchesLength = 0;\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tIProgressMonitor monitor = this.collector.getProgressMonitor();\r", "-\t\t\tif (monitor != null && monitor.isCanceled()) {\r", "-\t\t\t\tthrow new OperationCanceledException();\r", "-\t\t\t}\r", "-\t\t\tString pathString = filePaths[i];\r", "-\t\t\tOpenable openable = factory.createOpenable(pathString);\r", "-\t\t\tif (openable == null)\r", "-\t\t\t\tcontinue; // match is outside classpath\r", "-\r", "-\t\t\t// create new parser and lookup environment if this is a new project\r", "-\t\t\tIResource resource = null;\r", "-\t\t\ttry {\r", "-\t\t\t\tJavaProject javaProject = (JavaProject) openable.getJavaProject();\r", "-\t\t\t\tresource = openable.getUnderlyingResource();\r", "-\t\t\t\tif (resource == null) { // case of a file in an external jar\r", "-\t\t\t\t\tresource = javaProject.getProject();\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "-\t\t\t\t\t// locate matches in previous project\r", "-\t\t\t\t\tif (previousJavaProject != null) {\r", "-\t\t\t\t\t\tthis.locateMatches();\r", "-\t\t\t\t\t\tthis.potentialMatchesLength = 0;\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\t// create parser for this project\r", "-\t\t\t\t\tcouldInitializePattern = this.createParser(javaProject);\r", "-\t\t\t\t\tpreviousJavaProject = javaProject;\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!couldInitializePattern)\r", "-\t\t\t\t\tcontinue;\r", "-\t\t\t\t// the pattern could not be initialized: the match cannot be in this project\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t// file doesn't exist -> skip it\r", "-\t\t\t\tcontinue;\r", "-\t\t\t}\r", "-\r", "-\t\t\t// add potential match\r", "-\t\t\tthis.addPotentialMatch(resource, openable);\r", "-\r", "-\t\t\tif (monitor != null) {\r", "-\t\t\t\ttotalWork = totalWork + increment;\r", "-\t\t\t\tint worked = (int) totalWork - lastProgress;\r", "-\t\t\t\tmonitor.worked(worked);\r", "-\t\t\t\tlastProgress = (int) totalWork;\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\t// last project\r", "-\t\tif (previousJavaProject != null) {\r", "-\t\t\tthis.locateMatches();\r", "-\t\t\tthis.potentialMatchesLength = 0;\r", "-\t\t}\r", "-\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "79f1127b31f9db0927ed7f7317374fce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "commitAfterChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r \tpublic void locateMatches(String[] filePaths, IWorkspace workspace)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r public void locateMatches(String[] filePaths, IWorkspace workspace) throws JavaModelException", "diff": ["+ */\r", "+public void locateMatches(String[] filePaths, IWorkspace workspace) throws JavaModelException {\r", "+\tUtil.sort(filePaths); // sort by projects\r", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "+\tJavaProject previousJavaProject = null;\r", "+\tint length = filePaths.length;\r", "+\tdouble increment = 100.0 / length;\r", "+\tdouble totalWork = 0;\r", "+\tint lastProgress = 0;\r", "+\tboolean couldInitializePattern = false;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIProgressMonitor monitor = this.collector.getProgressMonitor();\r", "+\t\tif (monitor != null && monitor.isCanceled()) {\r", "+\t\t\tthrow new OperationCanceledException();\r", "+\t\t}\r", "+\t\tString pathString = filePaths[i];\r", "+\t\tthis.currentOpenable = factory.createOpenable(pathString);\r", "+\t\tif (this.currentOpenable == null) continue;  // match is outside classpath\r", "+\r", "+\t\t// create new parser and lookup environment if this is a new project\r", "+\t\ttry {\r", "+\t\t\tJavaProject javaProject = (JavaProject)this.currentOpenable.getJavaProject();\r", "+\t\t\tthis.currentResource = this.currentOpenable.getUnderlyingResource();\r", "+\t\t\tif (this.currentResource == null) { // case of a file in an external jar\r", "+\t\t\t\tthis.currentResource = javaProject.getProject();\r", "+\t\t\t}\r", "+\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "+\t\t\t\t// create parser for this project\r", "+\t\t\t\tcouldInitializePattern = this.createParser(javaProject);\r", "+\t\t\t\tpreviousJavaProject = javaProject;\r", "+\t\t\t}\r", "+\t\t\tif (!couldInitializePattern) continue; // the pattern could not be initialized: the match cannot be in this project\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t\t// file doesn't exist -> skip it\r", "+\t\t\tcontinue;\r", "+\t\t// locate matches in current file and report them\r", "+\t\ttry {\r", "+\t\t\tif (this.currentOpenable instanceof CompilationUnit) {\r", "+\t\t\t\tthis.locateMatchesInCompilationUnit();\r", "+\t\t\t} else if (this.currentOpenable instanceof org.eclipse.jdt.internal.core.ClassFile) {\r", "+\t\t\t\tthis.locateMatchesInClassFile();\r", "+\t\t\t}\r", "+\t\t} catch (AbortCompilation e) {\r", "+\t\t\t// problem with class path: it could not find base classes\r", "+\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "+\t\t} catch (CoreException e) {\r", "+\t\t\tif (e instanceof JavaModelException) {\r", "+\t\t\t\tthrow (JavaModelException)e;\r", "+\t\t\t} else {\r", "+\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (monitor != null) {\r", "+\t\t\ttotalWork = totalWork + increment;\r", "+\t\t\tint worked = (int)totalWork - lastProgress;\r", "+\t\t\tmonitor.worked(worked);\r", "+\t\t\tlastProgress = (int)totalWork;\r", "+\t\t}\r", "+\t}\r", "+}\r", "-\t */\r", "-\tpublic void locateMatches(String[] filePaths, IWorkspace workspace)\r", "-\t\tthrows JavaModelException {\r", "-\t\tUtil.sort(filePaths); // sort by projects\r", "-\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "-\t\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "-\t\tJavaProject previousJavaProject = null;\r", "-\t\tint length = filePaths.length;\r", "-\t\tdouble increment = 100.0 / length;\r", "-\t\tdouble totalWork = 0;\r", "-\t\tint lastProgress = 0;\r", "-\t\tboolean couldInitializePattern = false;\r", "-\t\tthis.potentialMatches = new PotentialMatch[10];\r", "-\t\tthis.potentialMatchesLength = 0;\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tIProgressMonitor monitor = this.collector.getProgressMonitor();\r", "-\t\t\tif (monitor != null && monitor.isCanceled()) {\r", "-\t\t\t\tthrow new OperationCanceledException();\r", "-\t\t\t}\r", "-\t\t\tString pathString = filePaths[i];\r", "-\t\t\tOpenable openable = factory.createOpenable(pathString);\r", "-\t\t\tif (openable == null)\r", "-\t\t\t\tcontinue; // match is outside classpath\r", "-\r", "-\t\t\t// create new parser and lookup environment if this is a new project\r", "-\t\t\tIResource resource = null;\r", "-\t\t\ttry {\r", "-\t\t\t\tJavaProject javaProject = (JavaProject) openable.getJavaProject();\r", "-\t\t\t\tresource = openable.getUnderlyingResource();\r", "-\t\t\t\tif (resource == null) { // case of a file in an external jar\r", "-\t\t\t\t\tresource = javaProject.getProject();\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "-\t\t\t\t\t// locate matches in previous project\r", "-\t\t\t\t\tif (previousJavaProject != null) {\r", "-\t\t\t\t\t\tthis.locateMatches();\r", "-\t\t\t\t\t\tthis.potentialMatchesLength = 0;\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\t// create parser for this project\r", "-\t\t\t\t\tcouldInitializePattern = this.createParser(javaProject);\r", "-\t\t\t\t\tpreviousJavaProject = javaProject;\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!couldInitializePattern)\r", "-\t\t\t\t\tcontinue;\r", "-\t\t\t\t// the pattern could not be initialized: the match cannot be in this project\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t// file doesn't exist -> skip it\r", "-\t\t\t\tcontinue;\r", "-\t\t\t}\r", "-\r", "-\t\t\t// add potential match\r", "-\t\t\tthis.addPotentialMatch(resource, openable);\r", "-\r", "-\t\t\tif (monitor != null) {\r", "-\t\t\t\ttotalWork = totalWork + increment;\r", "-\t\t\t\tint worked = (int) totalWork - lastProgress;\r", "-\t\t\t\tmonitor.worked(worked);\r", "-\t\t\t\tlastProgress = (int) totalWork;\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\t// last project\r", "-\t\tif (previousJavaProject != null) {\r", "-\t\t\tthis.locateMatches();\r", "-\t\t\tthis.potentialMatchesLength = 0;\r", "-\t\t}\r", "-\r", "-\t}\r"]}], "num": 4738}