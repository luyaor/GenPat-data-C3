{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9ce61b2fe38e379062e26049a645ea5c", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3dfa9af28e44e375eb4a9dac54208811", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/DeclarationsUtil.java", "commitBeforeChange": "72643ddaac52d3ea6e2573fbe40b9af5d9586d1e", "commitAfterChange": "965ee55c83771df9f7f21b38b9a78903a86f630d", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "     public boolean hides(MemberDeclaration sub, MemberDeclaration sup)", "signatureAfterChange": "     public boolean hides(MemberDeclaration sub, MemberDeclaration sup)", "diff": ["-    public boolean hides(MemberDeclaration sub, MemberDeclaration sup)", "-    {", "-        throw new UnsupportedOperationException(\"NYI\");", "+    public boolean hides(MemberDeclaration sub, MemberDeclaration sup) {", "+\t\t", "+\t\t// A declaration cannot hide itself", "+\t\tif (sub == sup || sub.equals(sup))", "+\t\t\treturn false;", "+\t\t", "+\t\tMemberDeclarationImpl subImpl = (MemberDeclarationImpl)sub;", "+\t\tMemberDeclarationImpl supImpl = (MemberDeclarationImpl)sup;", "+\t\t", "+\t\tIBinding subBinding = subImpl.getDeclarationBinding();", "+\t\tIBinding supBinding = supImpl.getDeclarationBinding();", "+\t\t", "+\t\t", "+\t\t// Hiding can only take place between declarations of the same kind and name,", "+\t\t// and types, variables and methods", "+\t\tint subKind = subBinding.getKind();", "+\t\tint supKind = supBinding.getKind();", "+\t\tif (subKind != supKind || subKind == IBinding.PACKAGE)", "+\t\t\treturn false;", "+\t\tif (!subBinding.getName().equals(supBinding.getName()))", "+\t\t\treturn false;", "+\t\t", "+\t\t// Methods must be both static and the sub a subsignature of the sup", "+\t\tif (subKind == IBinding.METHOD) {", "+\t\t\tboolean allowed = false;", "+\t\t\tint modifiers = subBinding.getModifiers();", "+\t\t\tif ((modifiers & Modifier.STATIC) == Modifier.STATIC) {", "+\t\t\t\tIMethodBinding methodBinding = (IMethodBinding)subBinding;", "+\t\t\t\tif (methodBinding.isSubsignature((IMethodBinding)supBinding)) {", "+\t\t\t\t\tallowed = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (!allowed)", "+\t\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\t// sub's enclosing class must be a subclass of sup's", "+\t\tITypeBinding subClass = getDeclaringClass(subBinding);", "+\t\tITypeBinding supClass = getDeclaringClass(supBinding);", "+\t\tif (subClass == null || supClass == null)", "+\t\t\treturn false;", "+\t\tif (!subClass.isSubTypeCompatible(supClass))", "+\t\t\treturn false;", "+\t\t", "+\t\t// sup must be visible from sub", "+\t\tif (!isVisibleForHiding(supClass, supClass, supBinding.getModifiers()))", "+\t\t\treturn false;", "+\t\t", "+\t\treturn true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4f658a8226da282521a995747709748", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java", "commitBeforeChange": "40ad9904e939ba54abece52421044021edd6e1c0", "commitAfterChange": "8d45cb26fc5ad244f93e8632d761d46ad4a120cf", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tpublic static LocalVariableBinding getTrackerForCloseCall(ASTNode invocationSite)", "signatureAfterChange": " \tprivate static FakedTrackingVariable findCloseTracker(BlockScope scope, FlowInfo flowInfo, Expression arg)", "diff": ["-\t/** if 'invocationSite' is a call to close() that has a registered tracking variable, answer that variable's binding. */", "-\tpublic static LocalVariableBinding getTrackerForCloseCall(ASTNode invocationSite) {", "-\t\tif (invocationSite instanceof MessageSend) {", "-\t\t\tMessageSend send = (MessageSend) invocationSite;", "-\t\t\tif (CharOperation.equals(TypeConstants.CLOSE, send.selector) && send.receiver instanceof SingleNameReference) {", "-\t\t\t\tBinding receiverBinding = ((SingleNameReference)send.receiver).binding;", "-\t\t\t\tif (receiverBinding instanceof LocalVariableBinding) {", "-\t\t\t\t\tFakedTrackingVariable trackingVariable = ((LocalVariableBinding)receiverBinding).closeTracker;", "-\t\t\t\t\tif (trackingVariable != null)", "-\t\t\t\t\t\treturn trackingVariable.binding;", "-\t\t\t\t}", "-\t\treturn null;", "+\t/** Find an existing tracking variable for the argument of an allocation for a resource wrapper. */", "+\tprivate static FakedTrackingVariable findCloseTracker(BlockScope scope, FlowInfo flowInfo, Expression arg)", "+\t{", "+\t\twhile (arg instanceof Assignment) {", "+\t\t\tAssignment assign = (Assignment)arg;", "+\t\t\tLocalVariableBinding innerLocal = assign.localVariableBinding();", "+\t\t\tif (innerLocal != null) {", "+\t\t\t\t// nested assignment has already been processed", "+\t\t\t\treturn innerLocal.closeTracker;", "+\t\t\t} else {", "+\t\t\t\targ = assign.expression; // unwrap assignment and fall through", "+\t\t\t}", "+\t\t}", "+\t\tif (arg instanceof SingleNameReference) {", "+\t\t\t// is allocation arg a reference to an existing closeable?", "+\t\t\tLocalVariableBinding local = arg.localVariableBinding();", "+\t\t\tif (local != null) {", "+\t\t\t\treturn local.closeTracker;", "+\t\t\t}", "+\t\t} else if (arg instanceof AllocationExpression) {", "+\t\t\t// nested allocation", "+\t\t\treturn ((AllocationExpression)arg).closeTracker;", "+\t\t}", "+\t\treturn null; // not a tracked expression"]}], "num": 70508}