{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2426b194640c93f086efe54b925ea9ce", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2076f28d10d665230690e57b618cebcf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "341ead40b71a0bffec0f8325f6b29d2b567caf8a", "commitAfterChange": "f5884fa8b0573c548eaeabaa37cd99c51e41fd3b", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "signatureAfterChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "diff": ["-\t\t\t\t\t\t}", "-\t\t\t\t\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=432682, 18.2.1, bullet 3, clause 2", "-\t\t\t\t\t\t   \"... the constraint reduces to the bound set B3 which would be used to determine the expression's invocation type when targeting T, as defined in \u00a718.5.2.\"", "-\t\t\t\t\t\t   We are actually using B4 here - to be fixed with https://bugs.eclipse.org/bugs/show_bug.cgi?id=444891", "-\t\t\t\t\t\t*/", "-\t\t\t\t\t\tSolution solution = innerCtx.getResultFor(this.right);", "-\t\t\t\t\t\tif (solution != null) {", "-\t\t\t\t\t\t\tBoundSet b3 = solution.bounds;", "-\t\t\t\t\t\t\tinferenceContext.currentBounds.addBounds(b3, inferenceContext.environment);", "-\t\t\t\t\t\t\treturn TRUE;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "23633fa0068c6677e83b386ffbdcdb1c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "3f131825dfbebcd2d9846517fd8419ae56311784", "commitAfterChange": "ede87229fe271e061ecd80820c468f7956351f61", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\t// recording the closing of AutoCloseable resources:", "-\tif (CharOperation.equals(TypeConstants.CLOSE, this.selector)) ", "-\t{", "-\t\tFakedTrackingVariable trackingVariable = FakedTrackingVariable.getCloseTrackingVariable(this.receiver);", "-\t\tif (trackingVariable != null) { // null happens if receiver is not a local variable or not an AutoCloseable", "-\t\t\tif (trackingVariable.methodScope == currentScope.methodScope()) {", "-\t\t\t\ttrackingVariable.markClose(flowInfo, flowContext);", "-\t\t\t} else {", "-\t\t\t\ttrackingVariable.markClosedInNestedMethod();", "-\t\t\t}", "-\t\t}", "-\t}", "-\t\t\t// if argument is an AutoCloseable insert info that it *may* be closed (by the target method, i.e.)", "-\t\t\tflowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d36b13da374a3c0b72368794ef3bfae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "42f049f937d70e439674a5e8b4bf5fe233176519", "commitAfterChange": "b554fb8243e7e9f6b3dc500c3bd41ecd1fd736dd", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "signatureAfterChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "diff": ["-\t\t\tif (this.kind == BLOCK_SCOPE || this.kind == METHOD_SCOPE) {", "-\t\t\t\tLocalVariableBinding variableBinding = findVariable(name);", "-\t\t\t\t// looks in this scope only", "-\t\t\t\tif (variableBinding != null) return variableBinding;", "-\t\t\t}", "-", "-\t\t\tif (this.kind == METHOD_SCOPE) {", "-\t\t\t\tMethodScope methodScope = (MethodScope) this;", "-\t\t\t\tinsideStaticContext |= methodScope.isStatic;", "-\t\t\t\tinsideConstructorCall |= methodScope.isConstructorCall;", "-\t\t\t}", "-\t\t\tScope scope = parent;", "-\t\t\tif (scope == null) return new ProblemBinding(name, null, NotFound);", "+\t\t\tScope scope = this;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "642d6f46dc6e6aaedf7e98e92106afd9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java", "commitBeforeChange": "3f131825dfbebcd2d9846517fd8419ae56311784", "commitAfterChange": "ede87229fe271e061ecd80820c468f7956351f61", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\t\t}", "-\t\tFakedTrackingVariable trackingVariable = FakedTrackingVariable.getCloseTrackingVariable(this.expression);", "-\t\tif (trackingVariable != null) {", "-\t\t\tif (currentScope.methodScope() != trackingVariable.methodScope)", "-\t\t\t\ttrackingVariable.markClosedInNestedMethod();", "-\t\t\t// don't report issues concerning this local, since by returning", "-\t\t\t// the method passes the responsibility to the caller:", "-\t\t\tcurrentScope.removeTrackingVar(trackingVariable);", "-\tcurrentScope.checkUnclosedCloseables(flowInfo, null/*ignore exception exits from flowContext*/, this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ffe520414ae6108306e8ef2ebc0b340b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java", "commitBeforeChange": "78950c7a462ba6fe8424532e69a4abeff0c7c745", "commitAfterChange": "bb74c75a01728288c8fd321cd0dfd5da07348196", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\tcheckAccess(scope.methodScope(), this.resolvedType);", "-\t\t} else {", "-\t\t\t// Could also be targeting an enclosing instance inside a super constructor invocation", "-\t\t\t//\tclass X {", "-\t\t\t//\t\tpublic X(int i) {", "-\t\t\t//\t\t\tthis(new Object() { Object obj = X.this; });", "-\t\t\t//\t\t}", "-\t\t\t//\t}", "-", "-\t\t\tMethodScope methodScope = scope.methodScope();", "-\t\t\twhile (methodScope != null) {", "-\t\t\t\tif (!this.checkAccess(methodScope, this.resolvedType)) break;", "-\t\t\t\tif (methodScope.enclosingSourceType() == this.currentCompatibleType) break;", "-\t\t\t\tmethodScope = methodScope.parent.methodScope();", "-\t\t\t}", "-\t\t}", "+\t\t\tcheckAccess(scope.methodScope());", "+\t\t} // if depth>0, path emulation will diagnose bad scenarii"]}], "num": 12370}