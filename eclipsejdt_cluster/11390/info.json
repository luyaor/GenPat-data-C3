{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a59f8f57f74e35a310df82741a03ca61", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "06cce66d4cf952039481ae77c394831c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java", "commitBeforeChange": "f338c86815ffb4c165b8024ba4f28cade0b2b75f", "commitAfterChange": "a98d7d87df415161ba75f53acbdbe8d316ea160c", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": " public RecoveredElement buildInitialRecoveryState()", "signatureAfterChange": " public RecoveredElement buildInitialRecoveryState()", "diff": ["+\t\tthis.snapShot = null;", "-\tfor(int i = 0; i <= this.astPtr; i++){", "-\t\tASTNode node = this.astStack[i];", "+\tASTNode node = null, lastNode = null;", "+\tfor (int i = 0; i <= this.astPtr; i++, lastNode = node) {", "+\t\tnode = this.astStack[i];", "-\t\t\t\t\tblock = new Block(0);", "+\t\t\t\t\tblock = new Block(0, lastNode instanceof LambdaExpression);", "-\t\tif (node instanceof LambdaExpression) {", "-\t\t\tLambdaExpression lambda = (LambdaExpression) node;", "-\t\t\telement = element.add(lambda, 0);", "-\t\t\tthis.lastCheckPoint = lambda.sourceEnd + 1;", "-\t\t\tcontinue;", "-\t\t}", "+\t/* For block bodied lambdas we should create a block even though the lambda header appears before it, so elements from within don't get misattributed. */", "+\tboolean createLambdaBlock = lastNode instanceof LambdaExpression && ((LambdaExpression) node).body() instanceof Block;", "-\t\t\tif ((this.blockStarts[j] < pos) && (this.blockStarts[j] != lastStart)){ // avoid multiple block if at same position", "-\t\t\t\tblock = new Block(0);", "+\t\t\tif ((this.blockStarts[j] < pos || createLambdaBlock) && (this.blockStarts[j] != lastStart)){ // avoid multiple block if at same position", "+\t\t\t\tblock = new Block(0, createLambdaBlock);", "+\t\t\t\tcreateLambdaBlock = false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ae97b5a323217b7a9817f9857594bc00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "a0e794820a3e45ac013c44e55b82e935802d5378", "commitAfterChange": "a06fd70a66cd192fe200df3baf9406d9e87b6313", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 32, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "diff": ["-\t\t", "-\t\tfinal MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);", "-\t\t", "-\t\tif (sam == null || !sam.isValidBinding())", "+\t\tif (!(left instanceof ReferenceBinding))", "-\t\tif (sam.parameters.length != this.arguments.length)", "-\t\t\treturn false;", "-\t\t", "-\t\tif (!this.shapeAnalysisComplete) {", "+", "+\t\tshapeAnalysis: if (!this.shapeAnalysisComplete) {", "-\t\t\t\t\t\tif (sam.returnType.id == TypeIds.T_void) {", "-\t\t\t\t\t\t\tif (!this.voidCompatible)", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (!this.valueCompatible)", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "+// FIXME: we don't yet have the same, should we compute it here & now?", "+//\t\t\t\t\t\tif (sam.returnType.id == TypeIds.T_void) {", "+//\t\t\t\t\t\t\tif (!this.voidCompatible)", "+//\t\t\t\t\t\t\t\treturn false;", "+//\t\t\t\t\t\t} else {", "+//\t\t\t\t\t\t\tif (!this.valueCompatible)", "+//\t\t\t\t\t\t\t\treturn false;", "+//\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn true;", "-\t\t\t\t\treturn this.arguments.length == 0; // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.", "+\t\t\t\t\t\tbreak shapeAnalysis;", "+\t\t\t\t\tif (this.arguments.length != 0) // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\tbreak shapeAnalysis;", "+\t\tReferenceBinding groundTargetType = findGroundTargetType(this.enclosingScope, (ReferenceBinding) left, argumentsTypeElided());", "+\t\tif (groundTargetType == null)", "+\t\t\treturn false;", "+\t\t", "+\t\tMethodBinding sam = groundTargetType.getSingleAbstractMethod(this.enclosingScope, true);", "+\t\tif (sam == null || !sam.isValidBinding())", "+\t\t\treturn false;", "+\t\tif (sam.parameters.length != this.arguments.length)", "+\t\t\treturn false;", "+"]}], "num": 11390}