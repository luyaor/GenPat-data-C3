{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c985b89202f7f4472f66c6660b3ccb92", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "06c708683fda7bc1dddfa0a7227dee16", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "00cabdb6b90ee48364f71e75a5da5edca1e7837c", "commitAfterChange": "fcccc4dd1377e549112e0bdc9a74b0eb625c6ab2", "methodNumberBeforeChange": 67, "methodNumberAfterChange": 67, "signatureBeforeChange": "  \tprivate int printJavadocHtmlTag(FormatJavadocText text, FormatJavadocBlock block)", "signatureAfterChange": "  \tprivate int printJavadocHtmlTag(FormatJavadocText text, FormatJavadocBlock block)", "diff": ["-\t\t", "-\t\t// Local variables init", "+", "+\t\t// Compute indentation if necessary", "+\t\tboolean indentRootTags = this.formatter.preferences.comment_indent_root_tags && !block.isDescription();", "+\t\tboolean indentParamTag = this.formatter.preferences.comment_indent_parameter_description && block.isParamTag();", "+\t\tboolean headerLine = block.isHeaderLine() && this.lastNumberOfNewLines == 0;", "+\t\tint firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;", "+\t\tif (headerLine) firstColumn++;", "+\t\tStringBuffer indentationBuffer = null;", "+\t\tif (indentRootTags) {", "+\t\t\tint indentLevel = this.indentationLevel;", "+\t\t\tint indentations = this.numberOfIndentations;", "+\t\t\tthis.numberOfIndentations += (BLOCK_LINE_PREFIX_LENGTH / this.indentationSize) + 1;", "+\t\t\tthis.indentationLevel = this.numberOfIndentations * this.indentationSize;", "+\t\t\tint currentColumn = this.column;", "+\t\t\tthis.column = firstColumn;", "+\t\t\tif (indentParamTag) {", "+\t\t\t\tthis.indentationLevel += this.indentationSize;", "+\t\t\t\tthis.numberOfIndentations++;", "+\t\t\t}", "+\t\t\tprintIndentationIfNecessary(indentationBuffer = new StringBuffer());", "+\t\t\tthis.column = currentColumn;", "+\t\t\tthis.indentationLevel = indentLevel;", "+\t\t\tthis.numberOfIndentations = indentations;", "+\t\t}", "+", "+\t\t// Local variables init", "-\t\t\t\t\tif (textStart < previousEnd) addReplaceEdit(textStart, previousEnd, buffer.toString());", "+\t\t\t\t\tif (textStart < previousEnd) {", "+\t\t\t\t\t\taddReplaceEdit(textStart, previousEnd, buffer.toString());", "+//\t\t\t\t\t\tthis.column += buffer.length();", "+\t\t\t\t\t}", "+\t\t\t\t\tboolean immutable = htmlTag == null ? false : htmlTag.isImmutableHtmlTag();", "+\t\t\t\t\tboolean overEndLine = false;", "+\t\t\t\t\tif (immutable) {", "+\t\t\t\t\t\toverEndLine = (this.column + htmlTag.getLength()) > this.formatter.preferences.comment_line_length;", "+\t\t\t\t\t\tif (overEndLine) {", "+\t\t\t\t\t\t\tif (newLines < 1) newLines = 1;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tbuffer = new StringBuffer();", "-\t\t\t\t\t\tlinesAfter = printJavadocHtmlTag(htmlTag, block);", "+\t\t\t\t\t\tif (immutable) {", "+\t\t\t\t\t\t\t// do not change immutable tags, just increment column", "+\t\t\t\t\t\t\tthis.column += getTextLength(block, htmlTag);", "+\t\t\t\t\t\t\tlinesAfter = 0;", "+\t\t\t\t\t\t\tif (overEndLine) {", "+\t\t\t\t\t\t\t\t// need to indent", "+\t\t\t\t\t\t\t\tif (indentationBuffer != null) {", "+\t\t\t\t\t\t\t\t\taddInsertEdit(node.sourceStart, indentationBuffer.toString());", "+\t\t\t\t\t\t\t\t}", "+//\t\t\t\t\t\t\t\tbuffer.append(' ');", "+//\t\t\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tlinesAfter = printJavadocHtmlTag(htmlTag, block);", "+\t\t\t\t\t\t}", "-\t\t\t\t\tbuffer = new StringBuffer();", "-\t\t\t\t\ttextStart = node.sourceEnd + 1;", "+\t\t\t\t\ttextStart = node.sourceEnd+1;", "-\t\t\t\t\t\tif (wasHtmlTag || idx==0 || (idx==max && ((text.htmlIndexes[max] & JAVADOC_TAGS_ID_MASK) == htmlTagID))) {", "+//\t\t\t\t\t\tif (wasHtmlTag || idx==0 || (idx==max && ((text.htmlIndexes[max] & JAVADOC_TAGS_ID_MASK) == htmlTagID))) {", "+\t\t\t\t\t\tif (idx==0 || (idx==max && ((text.htmlIndexes[max] & JAVADOC_TAGS_ID_MASK) == htmlTagID)) || (idx < max && wasHtmlTag && (text.htmlIndexes[idx-1] & JAVADOC_TAGS_ID_MASK) != JAVADOC_IMMUTABLE_TAGS_ID)) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2237f5dc77632c453d4bb094f5446aaa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "75871e5cf780d193f3aa131d6533bfb3e88085a3", "commitAfterChange": "262c2d405c84f8f17d09d055f013ac895aa0dc67", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 28, "signatureBeforeChange": "\r \tpublic void reportAccurateReference(\r \t\tint sourceStart,\r \t\tint sourceEnd,\r \t\tchar[][] qualifiedName,\r \t\tIJavaElement element,\r \t\tint accuracy)\r \t\tthrows CoreException", "signatureAfterChange": "\r \tpublic void reportAccurateReference(\r \t\tint sourceStart,\r \t\tint sourceEnd,\r \t\tchar[][] tokens,\r \t\tIJavaElement element,\r \t\tint[] accuracies)\r \t\tthrows CoreException", "diff": ["-\t\t\t\r", "-\t\tthis.reportAccurateReference(\r", "-\t\t\tsourceStart,\r", "-\t\t\tsourceEnd,\r", "-\t\t\tqualifiedName,\r", "-\t\t\telement,\r", "-\t\t\tnew int[] {accuracy},\r", "-\t\t\tfalse);\r", "-\t}\r", "+\t */\r", "+\tpublic void reportAccurateReference(\r", "+\t\tint sourceStart,\r", "+\t\tint sourceEnd,\r", "+\t\tchar[][] tokens,\r", "+\t\tIJavaElement element,\r", "+\t\tint[] accuracies)\r", "+\t\tthrows CoreException {\r", "+\r", "+\t\t// compute source positions of the qualified reference \r", "+\t\tScanner scanner = parser.scanner;\r", "+\t\tscanner.setSourceBuffer(\r", "+\t\t\tthis.potentialMatches[this.potentialMatchesIndex].getSource());\r", "+\t\tscanner.resetTo(sourceStart, sourceEnd);\r", "+\r", "+\t\tint refSourceStart = -1, refSourceEnd = -1;\r", "+\t\tint length = tokens.length;\r", "+\t\tint token = -1;\r", "+\t\tint previousValid = -1;\r", "+\t\tint i = 0;\r", "+\t\tint accuracyIndex = 0;\r", "+\t\tdo {\r", "+\t\t\tint currentPosition = scanner.currentPosition;\r", "+\t\t\t// read token\r", "+\t\t\ttry {\r", "+\t\t\t\ttoken = scanner.getNextToken();\r", "+\t\t\t} catch (InvalidInputException e) {\r", "+\t\t\t}\r", "+\t\t\tif (token != TerminalSymbols.TokenNameEOF) {\r", "+\t\t\t\tchar[] currentTokenSource = scanner.getCurrentTokenSource();\r", "+\t\t\t\tboolean equals = false;\r", "+\t\t\t\twhile (i < length\r", "+\t\t\t\t\t&& !(equals = CharOperation.equals(tokens[i++], currentTokenSource))) {\r", "+\t\t\t\t}\r", "+\t\t\t\tif (equals && (previousValid == -1 || previousValid == i - 2)) {\r", "+\t\t\t\t\tpreviousValid = i - 1;\r", "+\t\t\t\t\tif (refSourceStart == -1) {\r", "+\t\t\t\t\t\trefSourceStart = currentPosition;\r", "+\t\t\t\t\trefSourceEnd = scanner.currentPosition - 1;\r", "+\t\t\t\t} else {\r", "+\t\t\t\t}\r", "+\t\t\t\t// read '.'\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\ttoken = scanner.getNextToken();\r", "+\t\t\t\t} catch (InvalidInputException e) {\r", "+\t\t\tif (accuracies[accuracyIndex] != -1) {\r", "+\t\t\t\t// accept reference\r", "+\t\t\t\tif (refSourceStart != -1) {\r", "+\t\t\t\t\tthis.report(refSourceStart, refSourceEnd, element, accuracies[accuracyIndex]);\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tthis.report(sourceStart, sourceEnd, element, accuracies[accuracyIndex]);\r", "+\t\t\t\t}\r", "+\t\t\t\ti = 0;\r", "+\t\t\t}\r", "+\t\t\trefSourceStart = -1;\r", "+\t\t\tpreviousValid = -1;\r", "+\t\t\tif (accuracyIndex < accuracies.length-1) {\r", "+\t\t} while (token != TerminalSymbols.TokenNameEOF);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "29c8336c2ca76bdae8a64351a892e688", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java", "commitBeforeChange": "5c930a2be2f56a634252cd32fd5425aacd603534", "commitAfterChange": "eb4f7811e5216181c33caa5f1f098b6e53cc8ce4", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic CompilerOptions(Map settings)", "signatureAfterChange": " \tpublic CompilerOptions(CompilerOptions options)", "diff": ["+\t */", "+\tpublic CompilerOptions(CompilerOptions options) {", "+\t\tthis.errorThreshold = options.errorThreshold;", "+\t\tthis.warningThreshold = options.warningThreshold;", "+\t\tthis.produceDebugAttributes = options.produceDebugAttributes;", "+\t\tthis.complianceLevel = options.complianceLevel;", "+\t\tthis.sourceLevel = options.sourceLevel;", "+\t\tthis.targetJDK = options.targetJDK;", "+\t\tthis.isPrivateConstructorAccessChangingVisibility = options.isPrivateConstructorAccessChangingVisibility;", "+\t\tthis.defaultEncoding = options.defaultEncoding;", "+\t\tthis.verbose = options.verbose;", "+\t\tthis.produceReferenceInfo = options.produceReferenceInfo;", "+\t\tthis.preserveAllLocalVariables = options.preserveAllLocalVariables;", "+\t\tthis.parseLiteralExpressionsAsConstants = options.parseLiteralExpressionsAsConstants;", "+\t\tthis.maxProblemsPerUnit = options.maxProblemsPerUnit;", "+\t\tthis.taskTags = options.taskTags;", "+\t\tthis.taskPriorites = options.taskPriorites;", "+\t\tthis.isTaskCaseSensitive = options.isTaskCaseSensitive;", "+\t\tthis.reportDeprecationInsideDeprecatedCode = options.reportDeprecationInsideDeprecatedCode;", "+\t\tthis.reportDeprecationWhenOverridingDeprecatedMethod = options.reportDeprecationWhenOverridingDeprecatedMethod;", "+\t\tthis.reportUnusedParameterWhenImplementingAbstract = options.reportUnusedParameterWhenImplementingAbstract;", "+\t\tthis.reportUnusedParameterWhenOverridingConcrete = options.reportUnusedParameterWhenOverridingConcrete;", "+\t\tthis.reportUnusedDeclaredThrownExceptionWhenOverriding = options.reportUnusedDeclaredThrownExceptionWhenOverriding;", "+\t\tthis.reportSpecialParameterHidingField = options.reportSpecialParameterHidingField;", "+\t\tthis.reportInvalidJavadocTagsVisibility = options.reportInvalidJavadocTagsVisibility;", "+\t\tthis.reportInvalidJavadocTags = options.reportInvalidJavadocTags;", "+\t\tthis.reportInvalidJavadocTagsDeprecatedRef = options.reportInvalidJavadocTagsDeprecatedRef;", "+\t\tthis.reportInvalidJavadocTagsNotVisibleRef = options.reportInvalidJavadocTagsNotVisibleRef;", "+\t\tthis.reportMissingJavadocTagsVisibility = options.reportMissingJavadocTagsVisibility;", "+\t\tthis.reportMissingJavadocTagsOverriding = options.reportMissingJavadocTagsOverriding;", "+\t\tthis.reportMissingJavadocCommentsVisibility = options.reportMissingJavadocCommentsVisibility; ", "+\t\tthis.reportMissingJavadocCommentsOverriding = options.reportMissingJavadocCommentsOverriding;", "+\t\tthis.inlineJsrBytecode = options.inlineJsrBytecode;", "+\t\tthis.docCommentSupport = options.docCommentSupport;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "332b9dee4de407360b503be174e40498", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "11e4e14c87ae9f5d3c387265b339332ab33728bd", "commitAfterChange": "a8ccd47f929845c5a31f3d30e26f356186998ae8", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 62, "signatureBeforeChange": " protected void consumeBinaryExpression(int op)", "signatureAfterChange": " protected void consumeBinaryExpression(int op)", "diff": ["+\t\t\t\t} else if (expr1 instanceof CombinedBinaryExpression) {", "+\t\t\t\t\tCombinedBinaryExpression cursor;", "+\t\t\t\t\t// left branch is comprised of PLUS BEs", "+\t\t\t\t\t// cursor is shifted upwards, while needed BEs are added", "+\t\t\t\t\t// on demand; past the arityMax-th", "+\t\t\t\t\t// consecutive BE, a CBE is inserted that holds a ", "+\t\t\t\t\t// full-fledged references table", "+\t\t\t\t\tif ((cursor = (CombinedBinaryExpression)expr1).arity <", "+\t\t\t\t\t\t\t\tcursor.arityMax) {", "+\t\t\t\t\t\tcursor.left = new BinaryExpression(cursor.left,", "+\t\t\t\t\t\t\t\tcursor.right, PLUS);", "+\t\t\t\t\t\tcursor.arity++;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcursor.left = new CombinedBinaryExpression(cursor.left,", "+\t\t\t\t\t\t\t\tcursor.right, PLUS, cursor.arity);", "+\t\t\t\t\t\tcursor.arity = 0;", "+\t\t\t\t\t\tcursor.tuneArityMax();", "+\t\t\t\t\t}", "+\t\t\t\t\tcursor.right = expr2;", "+\t\t\t\t\tcursor.sourceEnd = expr2.sourceEnd;", "+\t\t\t\t\tthis.expressionStack[this.expressionPtr] = cursor;", "+\t\t\t\t\t// BE_INSTRUMENTATION: neutralized in the released code\t\t\t\t\t", "+//\t\t\t\t\tcursor.depthTracker = ((BinaryExpression)cursor.left).", "+//\t\t\t\t\t\tdepthTracker + 1;\t\t\t\t\t", "+\t\t\t\t} else if (expr1 instanceof BinaryExpression) {", "+\t\t\t\t\tthis.expressionStack[this.expressionPtr] = ", "+\t\t\t\t\t\tnew CombinedBinaryExpression(expr1, expr2, PLUS, 1);", "-\t\t\t\t\tthis.expressionStack[this.expressionPtr] = new BinaryExpression(expr1, expr2, PLUS);", "+\t\t\t\t\t// single out the a + b case, which is a BE ", "+\t\t\t\t\t// instead of a CBE (slightly more than a half of strings", "+\t\t\t\t\t// concatenation are one-deep binary expressions)", "+\t\t\t\t\tthis.expressionStack[this.expressionPtr] = ", "+\t\t\t\t\t\tnew BinaryExpression(expr1, expr2, PLUS);", "+\t\t\t\t\t// single out the a + b case", "-\t\t\t\t\t\tnew BinaryExpression(", "-\t\t\t\t\t\t\texpr1, ", "-\t\t\t\t\t\t\texpr2, ", "-\t\t\t\t\t\t\top);", "+\t\t\t\t\t\tnew BinaryExpression(expr1, expr2, PLUS);", "-\t\t\t} else {", "-\t\t\t\tthis.expressionStack[this.expressionPtr] = ", "-\t\t\t\t\tnew BinaryExpression(", "-\t\t\t\t\t\texpr1, ", "-\t\t\t\t\t\texpr2, ", "-\t\t\t\t\t\top);", "-\t\t\t}", "+\t\t\t} else if (expr1 instanceof CombinedBinaryExpression) {", "+\t\t\t\t\tCombinedBinaryExpression cursor;", "+\t\t\t\t\t// shift cursor; create BE/CBE as needed", "+\t\t\t\t\tif ((cursor = (CombinedBinaryExpression)expr1).arity <", "+\t\t\t\t\t\t\t\tcursor.arityMax) {", "+\t\t\t\t\t\tcursor.left = new BinaryExpression(cursor.left,", "+\t\t\t\t\t\t\t\tcursor.right, PLUS);", "+\t\t\t\t\t\tcursor.arity++;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcursor.left = new CombinedBinaryExpression(cursor.left,", "+\t\t\t\t\t\t\t\tcursor.right, PLUS, cursor.arity);", "+\t\t\t\t\t\tcursor.arity = 0;", "+\t\t\t\t\t\tcursor.tuneArityMax();", "+\t\t\t\t\t}", "+\t\t\t\t\tcursor.right = expr2;", "+\t\t\t\t\tcursor.sourceEnd = expr2.sourceEnd;", "+\t\t\t\t\t// BE_INSTRUMENTATION: neutralized in the released code\t\t\t\t\t", "+//\t\t\t\t\tcursor.depthTracker = ((BinaryExpression)cursor.left).", "+//\t\t\t\t\t\tdepthTracker + 1;", "+\t\t\t\t\tthis.expressionStack[this.expressionPtr] = cursor;", "+\t\t\t\t} else if (expr1 instanceof BinaryExpression) {", "+\t\t\t\t\tthis.expressionStack[this.expressionPtr] = ", "+\t\t\t\t\t\tnew CombinedBinaryExpression(expr1, expr2, PLUS, 1);", "+\t\t\t\t} else {", "+\t\t\t\t\t// single out the a + b case", "+\t\t\t\t\tthis.expressionStack[this.expressionPtr] = ", "+\t\t\t\t\t\tnew BinaryExpression(expr1, expr2, PLUS);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6593c9f93ddaac2a43cc7c15c4ec8369", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "9275c96ab9e7e5e5f780672ec67bf57a1eb2d42e", "commitAfterChange": "437ac0488c92b5c24e88567c6caa0b204b0064ba", "methodNumberBeforeChange": 137, "methodNumberAfterChange": 137, "signatureBeforeChange": " protected void consumeEnumConstantHeader()", "signatureAfterChange": " protected void consumeEnumConstantHeader()", "diff": ["+}", "-\tEnumConstant enumConstant = new EnumConstant(this.compilationUnit.compilationResult);", "-\tlong pos = this.identifierPositionStack[this.identifierPtr];", "-\tint enumConstantEnd = (int) pos;", "-\tenumConstant.sourceEnd = enumConstantEnd;", "-\tfinal int start = (int) (pos >>> 32);", "-\tenumConstant.sourceStart = start;", "-\tenumConstant.declarationSourceStart = start;", "-\tenumConstant.name = this.identifierStack[this.identifierPtr--];", "-\tthis.identifierLengthPtr--;", "-", "-\t// fill arguments if needed", "-\tint length;", "-\tif ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {", "-\t\tthis.expressionPtr -= length;", "-\t\tSystem.arraycopy(", "-\t\t\tthis.expressionStack, ", "-\t\t\tthis.expressionPtr + 1, ", "-\t\t\tenumConstant.arguments = new Expression[length], ", "-\t\t\t0, ", "-\t\t\tlength); ", "-\t\tenumConstant.declarationSourceEnd = flushCommentsDefinedPriorTo(rParenPos);", "-\t\tenumConstant.bodyStart = rParenPos;", "-\t\tenumConstant.bodyEnd = rParenPos;\t", "-\t} else {", "-\t\tif (enumConstantEnd <= rParenPos) {", "-\t\t\tenumConstant.bodyEnd = rParenPos;", "-\t\t} else {", "-\t\t\tenumConstant.bodyEnd = enumConstantEnd;", "-\t\t}", "-\t}", "-", "-\tif (this.currentToken == TokenNameLBRACE) {", "-\t\tenumConstant.bodyStart = this.scanner.currentPosition;", "-\t}", "-\t", "-\tpushOnAstStack(enumConstant);", "+   FieldDeclaration enumConstant = (FieldDeclaration) this.astStack[this.astPtr];", "+   if (rParenPos > enumConstant.declarationSourceEnd) {", "+      enumConstant.declarationSourceEnd = flushCommentsDefinedPriorTo(rParenPos);", "+      enumConstant.declarationEnd = rParenPos;", "+   }", "+   if (this.currentToken == TokenNameLBRACE){", "+      // qualified allocation expression", "+      TypeDeclaration anonymousType = new TypeDeclaration(this.compilationUnit.compilationResult);", "+      anonymousType.name = TypeDeclaration.ANONYMOUS_EMPTY_NAME;", "+      anonymousType.bits |= ASTNode.AnonymousAndLocalMask;", "+      final int start = this.scanner.startPosition;", "+      anonymousType.declarationSourceStart = start;", "+      anonymousType.sourceStart = start;", "+      anonymousType.sourceEnd = start; // closing parenthesis", "+      anonymousType.modifiers = 0;", "+      pushOnAstStack(anonymousType);", "+      this.lastCheckPoint = anonymousType.bodyStart = this.scanner.currentPosition;", "+      if (this.currentElement != null) {", "+         this.currentElement = this.currentElement.add(anonymousType, 0);", "+         this.lastIgnoredToken = -1;", "+         this.currentToken = 0; // opening brace already taken into account", "+      }", "+      QualifiedAllocationExpression allocationExpression = new QualifiedAllocationExpression(anonymousType);", "+      allocationExpression.enumConstant = enumConstant;", "+      markEnclosingMemberWithLocalType();", "+      ", "+      // fill arguments if needed", "+      int length;", "+      if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {", "+         this.expressionPtr -= length;", "+         System.arraycopy(", "+               this.expressionStack, ", "+               this.expressionPtr + 1, ", "+               allocationExpression.arguments = new Expression[length], ", "+               0, ", "+               length); ", "+      }", "+      enumConstant.initialization = allocationExpression;", "+   } else {", "+      AllocationExpression allocationExpression = new AllocationExpression();", "+      allocationExpression.enumConstant = enumConstant;", "+      // fill arguments if needed", "+      int length;", "+      if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {", "+         this.expressionPtr -= length;", "+         System.arraycopy(", "+               this.expressionStack, ", "+               this.expressionPtr + 1, ", "+               allocationExpression.arguments = new Expression[length], ", "+               0, ", "+               length); ", "+      }", "+      enumConstant.initialization = allocationExpression;", "+   }", "+   ", "+   // recovery", "+   if (this.currentElement != null) {", "+      if (!(this.currentElement instanceof RecoveredType)", "+            && (this.currentToken == TokenNameDOT)){", "+         this.lastCheckPoint = enumConstant.sourceStart;", "+         this.restartRecovery = true;", "+         return;", "+      }", "+      this.lastCheckPoint = enumConstant.sourceEnd + 1;", "+      this.currentElement = this.currentElement.add(enumConstant, 0);", "+      this.lastIgnoredToken = -1;", "+   }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93acf6f2affe7ce592b25c9be26a67dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "3cbc5a17035fd93e630a5ce3a447371924b2eaec", "commitAfterChange": "2fbac062d3f933d7974166e3d20ea9843fdd9750", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 63, "signatureBeforeChange": "  \tprivate void printLineComment()", "signatureAfterChange": "  \tprivate void printLineComment()", "diff": ["-    \tif (this.indentationLevel != 0) {", "-    \t\tif (!this.formatter.preferences.never_indent_line_comments_on_first_column", "-    \t\t\t\t|| !isOnFirstColumn(start)) {", "-    \t\t\tprintIndentationIfNecessary();", "+    \t// Print comment line indentation", "+    \tint commentIndentationLevel;", "+    \tif (this.indentationLevel == 0) {", "+    \t\tcommentIndentationLevel = this.column - 1;", "+    \t} else {", "+    \t\tif (this.formatter.preferences.never_indent_line_comments_on_first_column &&", "+    \t\t\tisOnFirstColumn(start)) {", "+\t   \t\t\tcommentIndentationLevel = this.column - 1;", "+    \t\t} else {", "+    \t\t\t// Indentation may be specific for contiguous comment", "+    \t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=293300", "+\t\t\t\tif (this.lastLineComment.contiguous) {", "+\t\t\t\t\t// The leading spaces have been set while looping in the printComment(int) method", "+\t\t\t\t\tint currentCommentIndentation = getCurrentColumn(this.lastLineComment.leadingSpaces);", "+\t\t\t\t\t// Keep the current comment indentation when over the previous contiguous line comment", "+\t\t\t\t\t// and the previous comment has not been reindented", "+\t\t\t\t\tint lastCommentColumn = this.lastLineComment.currentColumn;", "+\t\t\t\t\tif (this.tabLength > 0) {", "+\t\t\t\t\t\tif ((currentCommentIndentation % this.tabLength) == 0) {", "+\t\t\t\t\t\t\tlastCommentColumn = (lastCommentColumn / this.tabLength) * this.tabLength;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tcurrentCommentIndentation = ((currentCommentIndentation / this.tabLength) + 1) * this.tabLength;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (currentCommentIndentation >= lastCommentColumn && this.lastLineComment.indentation != this.indentationLevel) {", "+\t\t\t\t\t\tint currentIndentationLevel = this.indentationLevel;", "+\t\t\t\t\t\tthis.indentationLevel = this.lastLineComment.indentation ;", "+\t\t\t\t\t\tprintIndentationIfNecessary();", "+\t\t\t\t\t\tthis.indentationLevel = currentIndentationLevel;", "+\t\t\t   \t\t\tcommentIndentationLevel = this.lastLineComment.indentation ;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tprintIndentationIfNecessary();", "+\t\t\t   \t\t\tcommentIndentationLevel = this.column - 1;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tif (this.currentAlignment != null && this.currentAlignment.name.equals(\"array_initializer\") && //$NON-NLS-1$", "+\t\t\t\t\t\tthis.indentationLevel < this.currentAlignment.breakIndentationLevel &&", "+\t\t\t\t\t\tthis.lastLineComment.lines > 0)", "+\t\t\t\t\t{", "+\t\t\t\t\t\tint currentIndentationLevel = this.indentationLevel;", "+\t\t\t\t\t\tthis.indentationLevel = this.currentAlignment.breakIndentationLevel;", "+\t\t    \t\t\tprintIndentationIfNecessary();", "+\t\t\t\t\t\tthis.indentationLevel = currentIndentationLevel;", "+\t\t\t   \t\t\tcommentIndentationLevel = this.currentAlignment.breakIndentationLevel;", "+\t\t\t\t\t} else {", "+\t\t    \t\t\tprintIndentationIfNecessary();", "+\t\t\t   \t\t\tcommentIndentationLevel = this.column - 1;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+    \t", "+    \t// Store line comment information", "+   \t\tthis.lastLineComment.contiguous = true;", "+\t\tthis.lastLineComment.currentColumn = getCurrentCommentColumn(currentTokenStartPosition);", "+\t\tthis.lastLineComment.indentation = commentIndentationLevel;", "+\t\t", "+\t\t// Add pending space if necessary"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "973eeb7049d574733097157671fc51c5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "a3da1013b6fe549ad5c2ee5b7dc726eba38ff59e", "commitAfterChange": "30692448718de71df165cc52c018bee7df31a8fb", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": " public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence, TypeDeclaration declaringType)", "signatureAfterChange": " public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence, TypeDeclaration declaringType)", "diff": ["-      switch (typeDeclaration.getKind()) {", "+      int kind = typeDeclaration.getKind();", "+      switch (kind) {", "-\t\t\t\t\trequestor.enterClass(", "-\t\t\t\t\t\ttypeDeclaration.declarationSourceStart, ", "-\t\t\t\t\t\tflags, ", "-\t\t\t\t\t\ttypeDeclaration.name, ", "-\t\t\t\t\t\ttypeDeclaration.sourceStart, ", "-\t\t\t\t\t\tsourceEnd(typeDeclaration), ", "-\t\t\t\t\t\tisEnumInit ? declaringType.name : null, ", "-\t\t\t\t\t\tinterfaceNames);", "+ \t\t\t\t\tISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();", "+ \t\t\t\t\ttypeInfo.kind = kind;", "+ \t\t\t\t\ttypeInfo.declarationStart = typeDeclaration.declarationSourceStart;", "+ \t\t\t\t\ttypeInfo.modifiers = flags;", "+ \t\t\t\t\ttypeInfo.name = typeDeclaration.name;", "+ \t\t\t\t\ttypeInfo.nameSourceStart = typeDeclaration.sourceStart;", "+ \t\t\t\t\ttypeInfo.nameSourceEnd = sourceEnd(typeDeclaration);", "+ \t\t\t\t\ttypeInfo.superclass = isEnumInit ? declaringType.name : null;", "+ \t\t\t\t\ttypeInfo.superinterfaces = interfaceNames;", "+ \t\t\t\t\ttypeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);", "+\t\t\t\t\trequestor.enterClass(typeInfo);", "-                  requestor.enterClass(", "-                     typeDeclaration.declarationSourceStart, ", "-                     typeDeclaration.modifiers, ", "-                     typeDeclaration.name, ", "-                     typeDeclaration.sourceStart, ", "-                     sourceEnd(typeDeclaration), ", "-                     CharOperation.concatWith(superclass.getParameterizedTypeName(), '.'), ", "-                     interfaceNames);", "+\t\t\t\t\tISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();", "+ \t\t\t\t\ttypeInfo.kind = kind;", "+ \t\t\t\t\ttypeInfo.declarationStart = typeDeclaration.declarationSourceStart;", "+ \t\t\t\t\ttypeInfo.modifiers = typeDeclaration.modifiers;", "+ \t\t\t\t\ttypeInfo.name = typeDeclaration.name;", "+ \t\t\t\t\ttypeInfo.nameSourceStart = typeDeclaration.sourceStart;", "+ \t\t\t\t\ttypeInfo.nameSourceEnd = sourceEnd(typeDeclaration);", "+ \t\t\t\t\ttypeInfo.superclass = CharOperation.concatWith(superclass.getParameterizedTypeName(), '.');", "+ \t\t\t\t\ttypeInfo.superinterfaces = interfaceNames;", "+ \t\t\t\t\ttypeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);", "+\t\t\t\t\trequestor.enterClass(typeInfo);", "-            notifySourceElementRequestor(typeDeclaration.typeParameters);         ", "-               requestor.enterInterface(", "-                  typeDeclaration.declarationSourceStart, ", "-                  deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, ", "-                  typeDeclaration.name, ", "-                  typeDeclaration.sourceStart, ", "-                  sourceEnd(typeDeclaration), ", "-                  interfaceNames);", "+\t\t\t\tISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();", "+\t\t\t\ttypeInfo.kind = kind;", "+\t\t\t\ttypeInfo.declarationStart = typeDeclaration.declarationSourceStart;", "+\t\t\t\ttypeInfo.modifiers = deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag;", "+\t\t\t\ttypeInfo.name = typeDeclaration.name;", "+\t\t\t\ttypeInfo.nameSourceStart = typeDeclaration.sourceStart;", "+\t\t\t\ttypeInfo.nameSourceEnd = sourceEnd(typeDeclaration);", "+\t\t\t\ttypeInfo.superinterfaces = interfaceNames;", "+\t\t\t\ttypeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);", "+\t\t\t\trequestor.enterInterface(typeInfo);", "-            notifySourceElementRequestor(typeDeclaration.typeParameters);         ", "-               requestor.enterEnum(", "-                  typeDeclaration.declarationSourceStart, ", "-                  deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, ", "-                  typeDeclaration.name, ", "-                  typeDeclaration.sourceStart, ", "-                  sourceEnd(typeDeclaration), ", "-                  interfaceNames);", "+\t\t\t\tISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();", "+\t\t\t\ttypeInfo.kind = kind;", "+\t\t\t\ttypeInfo.declarationStart = typeDeclaration.declarationSourceStart;", "+\t\t\t\ttypeInfo.modifiers = deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag;", "+\t\t\t\ttypeInfo.name = typeDeclaration.name;", "+\t\t\t\ttypeInfo.nameSourceStart = typeDeclaration.sourceStart;", "+\t\t\t\ttypeInfo.nameSourceEnd = sourceEnd(typeDeclaration);", "+\t\t\t\ttypeInfo.superinterfaces = interfaceNames;", "+\t\t\t\ttypeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);", "+\t\t\t\trequestor.enterEnum(typeInfo);", "-            notifySourceElementRequestor(typeDeclaration.typeParameters);         "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d2ee45d769b2b3fea762afbf9e604f23", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "e944f831810e143e8894d05428eb208a2cd78cce", "commitAfterChange": "45b2548f21c6553964603037785b1fef0bb3e0d3", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprivate void adaptRegions()", "signatureAfterChange": " \tprivate void adaptRegions()", "diff": ["-\t\tthis.adaptedRegions = new IRegion[this.regions.length];", "-\t\tfor (int i = 0, max = this.regions.length; i < max; i++) {", "+\t\tint max = this.regions.length;", "+\t\tif (max == 1) {", "+\t\t\t// It's not necessary to adapt the single region which covers all the source", "+\t\t\tif (this.regions[0].getOffset() == 0 && this.regions[0].getLength() == this.scannerEndPosition) {", "+\t\t\t\tthis.adaptedRegions = this.regions;", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t}", "+\t\tthis.adaptedRegions = new IRegion[max];", "+\t\tint commentIndex = 0;", "+\t\tfor (int i = 0; i < max; i++) {", "+\t\t\tint length = aRegion.getLength();", "+", "+\t\t\t// First look if the region starts or ends inside a comment", "+\t\t\tint index = getCommentIndex(commentIndex, offset);", "+\t\t\tint adaptedOffset = offset;", "+\t\t\tint adaptedLength = length;", "+\t\t\tif (index >= 0) {", "+\t\t\t\t// the offset of the region is inside a comment => restart the region from the comment start", "+\t\t\t\tadaptedOffset = this.commentPositions[index][0];", "+\t\t\t\tif (adaptedOffset < 0) adaptedOffset = -adaptedOffset;", "+\t\t\t\tadaptedLength = length + offset - adaptedOffset;", "+\t\t\t\tcommentIndex = index;", "+\t\t\t\t// include also the indentation edit just before the comment if any", "+\t\t\t\tfor (int j=0; j<this.editsIndex; j++) {", "+\t\t\t\t\tint editOffset = this.edits[j].offset;", "+\t\t\t\t\tint editEnd = editOffset + this.edits[j].length;", "+\t\t\t\t\tif (editEnd == adaptedOffset) {", "+\t\t\t\t\t\tif (j > 0 && this.edits[j].replacement.trim().length() == 0) {", "+\t\t\t\t\t\t\tadaptedLength += adaptedOffset - this.edits[j].offset;", "+\t\t\t\t\t\t\tadaptedOffset = editOffset;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (editEnd > adaptedOffset) {", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tindex = getCommentIndex(commentIndex, offset+length-1);", "+\t\t\tif (index >= 0) {", "+\t\t\t\t// the region end is inside a comment => set the region end at the comment end", "+\t\t\t\tint commentEnd = this.commentPositions[index][1];", "+\t\t\t\tif (commentEnd < 0) commentEnd = -commentEnd;", "+\t\t\t\tadaptedLength = commentEnd - adaptedOffset;", "+\t\t\t\tcommentIndex = index;", "+\t\t\t}", "+\t\t\tif (adaptedLength != length) {", "+\t\t\t\t// adapt the region and jump to next one", "+\t\t\t\tthis.adaptedRegions[i] = new Region(adaptedOffset, adaptedLength);", "+\t\t\t\tcontinue;", "+\t\t\t}", "+", "-\t\t\t\tint length = aRegion.getLength();"]}], "num": 46528}