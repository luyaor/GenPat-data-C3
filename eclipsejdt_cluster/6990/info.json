{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bbceb58b04380794ac81af40eebb29a9", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2319475039cafff3929820bd2625c9c9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8a64589617f7b80b7f12bb3f773ab58c605663c7", "commitAfterChange": "6585c7471e2cc73387fb0d652a600f2678de9051", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tpublic void printBlockComment(char[] s, int commentStart, boolean isJavadoc)", "signatureAfterChange": " \tprivate void printBlockComment(char[] s, boolean isJavadoc)", "diff": ["-\tpublic void printBlockComment(char[] s, int commentStart, boolean isJavadoc) {", "-\t\tString commentSource = new String(s);", "-\t\tStringTokenizer tokenizer = new StringTokenizer(commentSource, \"\\r\\n\");\t//$NON-NLS-1$", "-\t\tprintIndentationIfNecessary();", "-\t\tLocation location = null;", "-\t\tint lineCounter = 0;", "-\t\tint startSearchIndex = 0;", "+\tprivate void printBlockComment(char[] s, boolean isJavadoc) {", "-\t\twhile(tokenizer.hasMoreElements()) {", "-\t\t\tString lineContents = tokenizer.nextToken();", "-\t\t\tif (lineContents.length() != 0) {", "-\t\t\t\tprintIndentationIfNecessary();", "-\t\t\t\tif (lineCounter >= 1) {", "-\t\t\t\t\tbuffer.append(\" \");//$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\t// remove leading whitespaces", "-\t\t\t\tint lineStartPosition = currentTokenStartPosition + commentSource.indexOf(lineContents, startSearchIndex);", "-\t\t\t\tthis.scanner.resetTo(lineStartPosition, this.scannerEndPosition - 1);", "-\t\t\t\tString reduceLine = null;", "-\t\t\t\ttry {", "-\t\t\t\t\t// TODO need investigation in term of edits", "-\t\t\t\t\tif (this.scanner.getNextToken() == ITerminalSymbols.TokenNameWHITESPACE) {", "-\t\t\t\t\t\tint begin = this.scanner.getCurrentTokenEndPosition() + 1 - lineStartPosition;", "-\t\t\t\t\t\tif (begin < lineContents.length()) {", "-\t\t\t\t\t\t\treduceLine = lineContents.substring(begin);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\treduceLine = \"\"; //$NON-NLS-1$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\treduceLine = lineContents;", "+\t\tthis.scanner.resetTo(currentTokenStartPosition, currentTokenEndPosition - 1);", "+\t\tint currentCharacter;", "+\t\tboolean isNewLine = false;", "+\t\tint start = currentTokenStartPosition;", "+\t\tint nextCharacterStart = currentTokenStartPosition;", "+\t\tprintIndentationIfNecessary();", "+\t\tint previousStart = currentTokenStartPosition;", "+", "+\t\twhile (nextCharacterStart <= currentTokenEndPosition && (currentCharacter = this.scanner.getNextChar()) != -1) {", "+\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+", "+\t\t\tswitch(currentCharacter) {", "+\t\t\t\tcase '\\r' :", "+\t\t\t\t\tstart = previousStart;", "+\t\t\t\t\tisNewLine = true;", "+\t\t\t\t\tif (this.scanner.getNextChar('\\n')) {", "+\t\t\t\t\t\tcurrentCharacter = '\\n';", "+\t\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "-\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t// should not happen", "-\t\t\t\t}", "-\t\t\t\tfinal int reduceLineLength = reduceLine.length();", "-\t\t\t\t// add position mapping", "-\t\t\t\tint start = commentSource.indexOf(reduceLine, startSearchIndex);", "-\t\t\t\tif (this.positionsToMap != null) {", "-\t\t\t\t\tmapPositions(start + commentStart, this.buffer.length(), reduceLineLength);", "-\t\t\t\t}", "-\t\t\t\tstartSearchIndex = start + reduceLineLength + 1;", "-\t\t\t\tbuffer.append(reduceLine);", "-\t\t\t\tcolumn += reduceLineLength;", "-\t\t\t\tlocation = new Location(this, 0);", "-\t\t\t\tbuffer.append(this.lineSeparator);", "-\t\t\t\tthis.line++;", "-\t\t\t\tlineCounter++;", "-\t\t\t\tcolumn = 1;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase '\\n' :", "+\t\t\t\t\tstart = previousStart;", "+\t\t\t\t\tisNewLine = true;", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tif (isNewLine) {", "+\t\t\t\t\t\tif (Character.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\twhile(currentCharacter != -1 && currentCharacter != '\\r' && currentCharacter != '\\n' && Character.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\t\tpreviousStart = nextCharacterStart;", "+\t\t\t\t\t\t\t\tcurrentCharacter = this.scanner.getNextChar();", "+\t\t\t\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.column = 1;", "+\t\t\t\t\t\tthis.line++;", "+", "+\t\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t\t\tbuffer.append(this.lineSeparator);", "+\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "+\t\t\t\t\t\tbuffer.append(this.fillingSpace);", "+\t\t\t\t", "+\t\t\t\t\t\taddReplaceEdit(start, previousStart - 1, String.valueOf(buffer)); //$NON-NLS-1$", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.column += (nextCharacterStart - previousStart);", "+\t\t\t\t\t}", "+\t\t\t\t\tisNewLine = false;", "-\t\t}", "-\t\tif (location != null) {", "-\t\t\tresetAt(location);", "+\t\t\tpreviousStart = nextCharacterStart;", "+\t\tthis.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);", "-\t\tthis.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f8911b629905b99b062503351da44ec", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java", "commitBeforeChange": "d5a32e245b27c645dcf70347396d7253765682d3", "commitAfterChange": "562bd70d52b78a80d9ea0f036f9a91cfb91468db", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowInfo)", "signatureAfterChange": " public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowInfo)", "diff": ["-\t\t\tswitch (this.nullCheckTypes[i]) {", "+\t\t\tswitch (this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) {", "-\t\t\t\t\t\tif (this.nullCheckTypes[i] == (CAN_ONLY_NON_NULL | IN_COMPARISON_NON_NULL)) {", "-\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "+\t\t\t\t\t\tif ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == (CAN_ONLY_NON_NULL | IN_COMPARISON_NON_NULL)) {", "+\t\t\t\t\t\t\tif ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tscope.problemReporter().localVariableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\tif (this.nullCheckTypes[i] == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {", "-\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "+\t\t\t\t\t\tif ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {", "+\t\t\t\t\t\t\tif ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tscope.problemReporter().localVariableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\tif (this.nullCheckTypes[i] == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {", "-\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "+\t\t\t\t\t\tif ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {", "+\t\t\t\t\t\t\tif ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNullComparedToNonNull(local, location);", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tscope.problemReporter().localVariableNullComparedToNonNull(local, location);", "-\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "+\t\t\t\t\t\t\t\tif ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNullComparedToNonNull(local, expression);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNullComparedToNonNull(local, expression);", "-\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\tswitch (this.nullCheckTypes[i]) {", "+\t\t\tswitch (this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) {", "-\t\t\t\t\t\tif (this.nullCheckTypes[i] == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {", "-\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "+\t\t\t\t\t\tif ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {", "+\t\t\t\t\t\t\tif ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tscope.problemReporter().localVariableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "+\t\t\t\t\t\t\t\tif ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNullComparedToNonNull(local, expression);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNullComparedToNonNull(local, expression);", "-\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\tif (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "99ec94d46de4c029e5100883a07983eb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/ProcessorEnvImpl.java", "commitBeforeChange": "1af62c8ac8c29f055bb8404d4de6ad60e868f8c4", "commitAfterChange": "1c68a970a8cbd8bfa2174955d5c78e149d7e6268", "methodNumberBeforeChange": 71, "methodNumberAfterChange": 73, "signatureBeforeChange": "      void postMarkers()", "signatureAfterChange": "     private void updateProblemLength()", "diff": ["-", "-    void postMarkers()", "+     */", "+    private void updateProblemLength()", "-    \tfor( MarkerInfo markerInfo : _markerInfos ){    \t\t", "-    \t\tif( markerInfo._markerAttrs.get(IMarker.CHAR_END) == null ) ", "-    \t\t\tcount ++;", "+    \tfor( Map.Entry<IFile, List<IProblem>> entry : _allProblems.entrySet() ){  ", "+    \t\tif( _file.equals(entry.getKey()) ){", "+    \t\t\tfor(IProblem problem : entry.getValue() ){", "+    \t\t\t\tif( problem.getSourceEnd() == -1 )", "+    \t\t\t\t\tcount ++;", "+    \t\t\t}    \t\t\t\t", "+    \t\t}", "+    \t\telse{", "+    \t\t\tfor(IProblem problem : entry.getValue() ){", "+    \t\t\t\tif( problem.getSourceEnd() < problem.getSourceStart() )", "+    \t\t\t\t\tproblem.setSourceEnd(problem.getSourceStart());", "+    \t\t\t}", "+    \t\t}", "-\t    \tfor( MarkerInfo markerInfo : _markerInfos ){    \t\t", "-\t    \t\tif( markerInfo._markerAttrs.get(IMarker.CHAR_END) == null ){", "-\t    \t\t\tfinal Integer startingOffset = (Integer)markerInfo._markerAttrs.get(IMarker.CHAR_START);", "-\t    \t\t\tstartingOffsets[index++] = startingOffset.intValue();", "+\t    \t", "+\t    \tfor( Map.Entry<IFile, List<IProblem>> entry : _allProblems.entrySet() ){  ", "+\t    \t\tif( entry.getKey() == _file ){", "+\t    \t\t\tfor(IProblem problem : entry.getValue() ){", "+\t    \t\t\t\tif( problem.getSourceEnd() == -1 )", "+\t    \t\t\t\t\tstartingOffsets[index++] = problem.getSourceStart();", "+\t    \t\t\t}    \t\t\t\t", "-\t    \tfor( MarkerInfo markerInfo : _markerInfos ){    \t\t", "-\t    \t\tif( markerInfo._markerAttrs.get(IMarker.CHAR_END) == null ){", "-\t    \t\t\tfinal int startingOffset = ", "-\t    \t\t\t\t((Integer)markerInfo._markerAttrs.get(IMarker.CHAR_START)).intValue();", "-\t    \t\t\tint endingOffset = lfinder.getEndingOffset(startingOffset);", "-\t    \t\t\tif( endingOffset == 0 )", "-\t    \t\t\t\tendingOffset = startingOffset;", "-\t    \t\t\tmarkerInfo._markerAttrs.put(IMarker.CHAR_END, endingOffset);", "+\t    \tfor( Map.Entry<IFile, List<IProblem>> entry : _allProblems.entrySet() ){  ", "+\t    \t\tif( _file.equals(entry.getKey()) ){", "+\t    \t\t\tfor(IProblem problem : entry.getValue() ){", "+\t    \t\t\t\tif( problem.getSourceEnd() == -1 ){", "+\t    \t\t\t\t\tint startingOffset = problem.getSourceStart();", "+\t    \t\t\t\t\tint endingOffset = lfinder.getEndingOffset(startingOffset);", "+\t    \t    \t\t\tif( endingOffset == 0 )", "+\t    \t    \t\t\t\tendingOffset = startingOffset;", "+\t    \t    \t\t\tproblem.setSourceEnd(endingOffset);\t    \t    \t\t\t", "+\t    \t\t\t\t}", "+\t    \t\t\t}    \t\t\t\t", "-    \t", "-\t\t// Posting all the markers to the workspace. Doing this in a batch process", "-\t\t// to minimize the amount of notification.", "-\t\ttry{", "-\t\t\t// the resource of the compilation unit in the environment.", "-\t\t\tfinal IResource currentResource = _file; ", "-\t        final IWorkspaceRunnable runnable = new IWorkspaceRunnable(){", "-\t            public void run(IProgressMonitor monitor)", "-\t            {\t            ", "-\t\t\t\t\tfinal String markerType = _phase == Phase.RECONCILE ?", "-\t\t\t\t\t\t\t\t\t\t\t  RECONCILE_MARKER : BUILD_MARKER;\t\t\t\t", "-\t                for( MarkerInfo markerInfo : _markerInfos ){", "-\t                    IResource resource = markerInfo._resource;", "-\t\t\t\t\t\tif( resource == null )", "-\t\t\t\t\t\t\tresource = currentResource;", "-\t\t\t\t\t\ttry{", "-\t\t                    final IMarker marker = resource.createMarker(markerType);", "-\t\t                    marker.setAttributes(markerInfo._markerAttrs);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcatch(CoreException e){", "-\t\t\t\t\t\t\tthrow new IllegalStateException(e);", "-\t\t\t\t\t\t}", "-\t                }", "-\t            };", "-\t        };", "-\t\t\tcurrentResource.getWorkspace().run(runnable, currentResource, IWorkspace.AVOID_UPDATE, null );", "-", "-\t\t}", "-\t\tcatch(CoreException e){", "-\t\t\tthrow new IllegalStateException(e);", "-\t\t}", "-\t\tfinally{", "-\t\t\t_markerInfos.clear();", "-\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c8ea3105c3f28d02b161abb762456b89", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "0de5167791884524f72d9d44c10f0e243af65d00", "commitAfterChange": "07ab76f69fbeeb2f2fd54cdf3d01ee69344b9ae0", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  \tpublic static CompilationUnitDeclaration parse( \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit, \t\t\tNodeSearcher nodeSearcher, \t\t\tMap settings, \t\t\tint flags)", "signatureAfterChange": " \tpublic static void parse( \t\t\tString[] sourceUnits, \t\t\tString[] encodings, \t\t\tFileASTRequestor astRequestor, \t\t\tint apiLevel, \t\t\tMap options, \t\t\tint flags, \t\t\tIProgressMonitor monitor)", "diff": ["+\tpublic static void parse(", "+\t\t\tString[] sourceUnits,", "+\t\t\tString[] encodings,", "+\t\t\tFileASTRequestor astRequestor,", "+\t\t\tint apiLevel,", "+\t\t\tMap options,", "+\t\t\tint flags,", "+\t\t\tIProgressMonitor monitor) {", "+\t\ttry {", "+\t\t\tCompilerOptions compilerOptions = new CompilerOptions(options);", "+\t\t\tcompilerOptions.ignoreMethodBodies = (flags & ICompilationUnit.IGNORE_METHOD_BODIES) != 0;", "+\t\t\tParser parser = new CommentRecorderParser(", "+\t\t\t\tnew ProblemReporter(", "+\t\t\t\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(),", "+\t\t\t\t\t\tcompilerOptions,", "+\t\t\t\t\t\tnew DefaultProblemFactory()),", "+\t\t\t\tfalse);", "+\t\t\tint unitLength = sourceUnits.length;", "+\t\t\tif (monitor != null) monitor.beginTask(\"\", unitLength); //$NON-NLS-1$", "+\t\t\tfor (int i = 0; i < unitLength; i++) {", "+\t\t\t\tchar[] contents = null;", "+\t\t\t\tString encoding = encodings != null ? encodings[i] : null;", "+\t\t\t\ttry {", "+\t\t\t\t\tcontents = Util.getFileCharContent(new File(sourceUnits[i]), encoding);", "+\t\t\t\t} catch(IOException e) {", "+\t\t\t\t\t// go to the next unit", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tif (contents == null) {", "+\t\t\t\t\t// go to the next unit", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\torg.eclipse.jdt.internal.compiler.batch.CompilationUnit compilationUnit = new org.eclipse.jdt.internal.compiler.batch.CompilationUnit(contents, sourceUnits[i], encoding);", "+\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationUnit;", "+\t\t\t\tCompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, compilerOptions.maxProblemsPerUnit);", "+\t\t\t\tCompilationUnitDeclaration compilationUnitDeclaration = parser.dietParse(sourceUnit, compilationResult);", "+\t\t\t\tif (compilationUnitDeclaration.ignoreMethodBodies) {", "+\t\t\t\t\tcompilationUnitDeclaration.ignoreFurtherInvestigation = true;", "+\t\t\t\t\t// if initial diet parse did not work, no need to dig into method bodies.", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+", "+\t\t\t\t//fill the methods bodies in order for the code to be generated", "+\t\t\t\t//real parse of the method....", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = compilationUnitDeclaration.types;", "+\t\t\t\tif (types != null) {", "+\t\t\t\t\tfor (int j = 0, typeLength = types.length; j < typeLength; j++) {", "+\t\t\t\t\t\ttypes[j].parseMethods(parser, compilationUnitDeclaration);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+", "+\t\t\t\t// convert AST", "+\t\t\t\tCompilationUnit node = convert(compilationUnitDeclaration, parser.scanner.getSource(), apiLevel, options, false/*don't resolve binding*/, null/*no owner needed*/, null/*no binding table needed*/, flags /* flags */, monitor, true);", "+\t\t\t\tnode.setTypeRoot(null);", "+", "+\t\t\t\t// accept AST", "+\t\t\t\tastRequestor.acceptAST(sourceUnits[i], node);", "+", "+\t\t\t\tif (monitor != null) monitor.worked(1);", "+\t\t\t}", "+\t\t} finally {", "+\t\t\tif (monitor != null) monitor.done();", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf24ca14ccfb5069435ea7eddb5b8d26", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchGenericTypeTests.java", "commitBeforeChange": "9fa4ee2d52d7a35a0c57f8c4b875f0f155754f75", "commitAfterChange": "330462fa1b1e3cc7e6b257e0a0f3470535bf4f54", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tprotected int selectionEnd(ICompilationUnit cu, String commentText) throws JavaModelException", "signatureAfterChange": " \tprivate int[] selectionInfo(ICompilationUnit cu, String selection, int occurences) throws JavaModelException", "diff": ["+\t */", "+\tprivate int[] selectionInfo(ICompilationUnit cu, String selection, int occurences) throws JavaModelException {", "+\t\tString source = cu.getSource();", "+\t\tint index = occurences < 0 ? source.lastIndexOf(selection) : source.indexOf(selection);", "+\t\tint max = Math.abs(occurences)-1;", "+\t\tfor (int n=0; index >= 0 && n<max; n++) {", "+\t\t\tindex = occurences < 0 ? source.lastIndexOf(selection, index) : source.indexOf(selection, index+selection.length());", "+\t\t}", "+\t\tStringBuffer msg = new StringBuffer(\"Selection '\");", "+\t\tmsg.append(selection);", "+\t\tif (index >= 0) {", "+\t\t\tif (selection.startsWith(\"/**\")) { // comment is before", "+\t\t\t\tint start = source.indexOf(\"*/\", index);", "+\t\t\t\tif (start >=0) {", "+\t\t\t\t\treturn new int[] { start+2, selection.length()-(start+2-index) };", "+\t\t\t\t} else {", "+\t\t\t\t\tmsg.append(\"' starts with an unterminated comment\");", "+\t\t\t} else if (selection.endsWith(\"*/\")) { // comment is after", "+\t\t\t\tint end = source.lastIndexOf(\"/**\", index+selection.length());", "+\t\t\t\tif (end >=0) {", "+\t\t\t\t\treturn new int[] { index, index-end };", "+\t\t\t\t} else {", "+\t\t\t\t\tmsg.append(\"' ends with an unstartted comment\");", "+\t\t\t\t}", "+\t\t\t} else { // no comment => use whole selection", "+\t\t\t\treturn new int[] { index, selection.length() };", "+\t\t} else {", "+\t\t\tmsg.append(\"' was not found in \");", "+\t\tmsg.append(source);", "-\tprotected int selectionEnd(ICompilationUnit cu, String commentText) throws JavaModelException {", "-", "-\t\t// Get dom compilation unit", "-\t\tASTParser parser = ASTParser.newParser(AST.JLS3);", "-\t\tparser.setSource(cu);", "-\t\tparser.setResolveBindings(false);", "-", "-\t\t// Look for selection", "-\t\tfinal CompilationUnit unit = (CompilationUnit) parser.createAST(null);", "-\t\tList comments = unit.getCommentList();", "-\t\tJavadoc selectionComment = null;", "-\t\tfor (int i=0, size=comments.size(); i<size && selectionComment==null; i++) {", "-\t\t\tComment comment = (Comment) comments.get(i);", "-\t\t\tif (comment.isDocComment()) {", "-\t\t\t\tJavadoc javadoc = (Javadoc) comment;", "-\t\t\t\tif (javadoc.tags().size() == 1) {", "-\t\t\t\t\tTagElement tagElement = (TagElement) javadoc.tags().get(0);", "-\t\t\t\t\tif (tagElement.fragments().size() == 1) {", "-\t\t\t\t\t\tASTNode node = (ASTNode) tagElement.fragments().get(0);", "-\t\t\t\t\t\tif (node.getNodeType() == ASTNode.TEXT_ELEMENT) {", "-\t\t\t\t\t\t\tTextElement text = (TextElement) node;", "-\t\t\t\t\t\t\tif (commentText.equals(text.getText())) {", "-\t\t\t\t\t\t\t\tselectionComment = javadoc;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (selectionComment == null) {", "-\t\t\tStringBuffer msg = new StringBuffer(\"No javadoc comment /** \");", "-\t\t\tmsg.append(commentText);", "-\t\t\tmsg.append(\" */ was found in \");", "-\t\t\tmsg.append(cu.getElementName());", "-\t\t\tmsg.append(\":\\n\");", "-\t\t\tmsg.append(cu.getBuffer().getCharacters());", "-\t\t\tassertTrue(msg.toString(), false);", "-\t\t\treturn -1;", "-\t\t}", "-\t\treturn selectionComment.getStartPosition()+selectionComment.getLength();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3094ae1ed229befa97e6528a441dc10", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "cb102deeeb30ec755d64a8d266f5423000dc4f4e", "commitAfterChange": "f18746495477338a9b83fca4f673d973bc3b28e9", "methodNumberBeforeChange": 72, "methodNumberAfterChange": 73, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["-\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "+\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType) {", "+\t\tbyte[] skipValues = new byte[visibleSize]; // tagged with -1 if method cannot be best match", "-\t\t\t\tif (compatibilityLevels[i] != level) continue nextVisible; // skip this method for now", "-\t\t\t\tMethodBinding method = visible[i];", "-\t\t\t\tTypeBinding[] params = method.tiebreakMethod().parameters;", "+\t\t\t\tif (compatibilityLevels[i] != level || skipValues[i] == -1) continue nextVisible; // skip this method for now", "+\t\t\t\tMethodBinding original = visible[i].original();", "+\t\t\t\tMethodBinding method = visible[i].tiebreakMethod();", "-\t\t\t\t\tMethodBinding method2 = visible[j];", "-\t\t\t\t\t// tiebreak generic methods using variant where type params are substituted by their erasures", "-\t\t\t\t\tif (!method2.tiebreakMethod().areParametersCompatibleWith(params)) {", "-\t\t\t\t\t\tif (method.isVarargs() && method2.isVarargs()) {", "-\t\t\t\t\t\t\t// check the non-vararg parameters", "-\t\t\t\t\t\t\tint paramLength = params.length;", "-\t\t\t\t\t\t\tTypeBinding[] params2 = method2.tiebreakMethod().parameters;", "-\t\t\t\t\t\t\tif (paramLength != params2.length)", "-\t\t\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t\t\tfor (int p = paramLength - 2; p >= 0; p--)", "-\t\t\t\t\t\t\t\tif (params[p] != params2[p] && !params[p].isCompatibleWith(params2[p]))", "-\t\t\t\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t\tMethodBinding original2 = visible[j].original();", "+\t\t\t\t\tif (original == original2)", "+\t\t\t\t\t\tcontinue; // parameterized superclasses & interfaces may be walked twice from different paths", "-\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) params2[paramLength - 1]).elementsType();", "-\t\t\t\t\t\t\tif (params[paramLength - 1].isCompatibleWith(elementsType))", "-\t\t\t\t\t\t\t\tcontinue; // special case to choose between 2 varargs methods when the last arg is missing or its Object[]", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t\tMethodBinding method2 = visible[j].tiebreakMethod();", "+\t\t\t\t\tif (!isMoreSpecificMethod(method, method2)) {", "+\t\t\t\t\t\tif (!isMoreSpecificMethod(method2, method))", "+\t\t\t\t\t\t\tskipValues[j] = -1; // no point checking method2 either", "+\t\t\t\t\t\tcontinue nextVisible; // method2 is a better match", "-\t\t\t\t\t// parameterized superclasses & interfaces may be walked twice from different paths", "-\t\t\t\t\tif (method.original() == method2.original()) continue;", "-", "-\t\t\t\t\t// see if method & method2 are duplicates due to the current substitution or multiple static imported methods", "-\t\t\t\t\tif (method.tiebreakMethod().areParametersEqual(method2.tiebreakMethod())) {", "-\t\t\t\t\t\tif (method.declaringClass == method2.declaringClass)", "-\t\t\t\t\t\t\tcontinue nextVisible; // duplicates thru substitution", "-", "-\t\t\t\t\t\tMethodBinding original = method.original();", "-\t\t\t\t\t\tif (method.hasSubstitutedParameters() || original.typeVariables != NoTypeVariables) {", "-\t\t\t\t\t\t\tReferenceBinding declaringClass = (ReferenceBinding) method.declaringClass.erasure();", "-\t\t\t\t\t\t\tReferenceBinding superType = declaringClass.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "-\t\t\t\t\t\t\tif (superType == null) {", "-\t\t\t\t\t\t\t\t// accept concrete methods over abstract methods found due to the default abstract method walk", "-\t\t\t\t\t\t\t\tif (!method.isAbstract() && method2.isAbstract())", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tMethodBinding inheritedMethod = method2;", "-\t\t\t\t\t\t\tMethodBinding inheritedOriginal = method2.original();", "-\t\t\t\t\t\t\tif (method.hasSubstitutedParameters()) { // must find inherited method with the same substituted variables", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(inheritedMethod.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == inheritedOriginal) {", "-\t\t\t\t\t\t\t\t\t\tinheritedMethod = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (original.typeVariables != NoTypeVariables)", "-\t\t\t\t\t\t\t\tinheritedMethod = original.computeSubstitutedMethod(inheritedMethod == method2 ? inheritedOriginal : inheritedMethod, environment());", "-\t\t\t\t\t\t\tif (inheritedMethod == null || !original.areParametersEqual(inheritedMethod))", "-\t\t\t\t\t\t\t\tbreak nextVisible; // dup thru substitution, not overridden... cannot find possible match", "-\t\t\t\t\t\t\t// method overrides method2, accept it", "-\t\t\t\t\t\t} else if (method.isStatic() && method2.isStatic()) {", "+\t\t\t\t\tif (method.areParametersEqual(method2)) {", "+\t\t\t\t\t\tif (method.isStatic() && method2.isStatic()) {", "+\t\t\t\t\t\t\t// if you knew that method overrode method2, it would help", "+\t\t\t\t\t\tif (original == method && original2 == method2)", "+\t\t\t\t\t\t\tcontinue; // no need to check further", "+\t\t\t\t\t\tif (!method.isAbstract() && method2.isAbstract())", "+\t\t\t\t\t\t\tcontinue; // 15.12.2, concrete method beats abstract method", "+\t\t\t\t\t\tif (method.declaringClass == method2.declaringClass)", "+\t\t\t\t\t\t\tcontinue nextVisible; // duplicates thru substitution", "+", "+\t\t\t\t\t\tif (method.hasSubstitutedParameters() && method.isAbstract() == method2.isAbstract() && receiverType != null) {", "+\t\t\t\t\t\t\t// class A<T> { void foo(T t) {} }", "+\t\t\t\t\t\t\t// class B<T, S> extends A<S> { void foo(T t) {} }", "+\t\t\t\t\t\t\treceiverType = receiverType instanceof CaptureBinding ? receiverType : (ReferenceBinding) receiverType.erasure();", "+\t\t\t\t\t\t\tReferenceBinding superType = receiverType.findSuperTypeWithSameErasure(method.declaringClass.erasure());", "+\t\t\t\t\t\t\tif (original.declaringClass == superType || superType == null) {", "+\t\t\t\t\t\t\t\tmethod = original;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(method.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "+\t\t\t\t\t\t\t\t\t\tmethod = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tsuperType = receiverType.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "+\t\t\t\t\t\t\tif (original2.declaringClass == superType || superType == null) {", "+\t\t\t\t\t\t\t\tmethod2 = original2;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(method2.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "+\t\t\t\t\t\t\t\t\t\tmethod2 = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (method.typeVariables != NoTypeVariables)", "+\t\t\t\t\t\t\t\tmethod2 = method.computeSubstitutedMethod(method2, environment());", "+\t\t\t\t\t\t\tif (method2 == null || !method.areParametersEqual(method2)) {", "+\t\t\t\t\t\t\t\tskipValues[j] = -1;", "+\t\t\t\t\t\t\t\tcontinue nextVisible; // dup thru substitution, not overridden... cannot find possible match", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// method overrides method2, accept it", "+\t\t\t\t\t\t} else if (!original.areTypeVariableErasuresEqual(original2)) {", "+\t\t\t\t\t\t\tif (original.typeVariables != NoTypeVariables) {", "+\t\t\t\t\t\t\t\tskipValues[j] = -1;", "+\t\t\t\t\t\t\t\tcontinue nextVisible; // method is not better since variables are not equal", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tcontinue nextVisible; // method2 is better match than method", "+\t\t\t\t\t\t}", "+\t\t\t\tmethod = visible[i]; // instead of the tieBreakMethod"]}], "num": 6990}