{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "df3a35355cd0b686d30d1484ed39bdfe", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5706aafbbdae95344c8e25ce5d306904", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "5daf90a164d16969119f51284ec69f74248f815c", "commitAfterChange": "88ba045d7ed9cf0766b43baca6283d95ae96a725", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "  protected void writeClassFileBytes(byte[] bytes, IFile file, String qualifiedFileName, boolean isTopLevelType, boolean updateClassFile) throws CoreException", "signatureAfterChange": "  protected void writeClassFileBytes(byte[] bytes, IFile file, String qualifiedFileName, boolean isTopLevelType, SourceFile compilationUnit) throws CoreException", "diff": ["-protected void writeClassFileBytes(byte[] bytes, IFile file, String qualifiedFileName, boolean isTopLevelType, boolean updateClassFile) throws CoreException {", "+protected void writeClassFileBytes(byte[] bytes, IFile file, String qualifiedFileName, boolean isTopLevelType, SourceFile compilationUnit) throws CoreException {", "-\t// If structural changes occured then add dependent source files", "+\t// If structural changes occurred then add dependent source files", "-\t\tif (writeClassFileCheck(file, qualifiedFileName, bytes) || updateClassFile) { // see 46093", "+\t\tif (writeClassFileCheck(file, qualifiedFileName, bytes) || compilationUnit.updateClassFile) { // see 46093", "-\t\t\tif (e.getStatus().getCode() == IResourceStatus.CASE_VARIANT_EXISTS)", "-\t\t\t\t// catch the case that a nested type has been renamed and collides on disk with an as-yet-to-be-deleted type", "+\t\t\tif (e.getStatus().getCode() == IResourceStatus.CASE_VARIANT_EXISTS) {", "+\t\t\t\tIStatus status = e.getStatus();", "+\t\t\t\tif (status instanceof IResourceStatus) {", "+\t\t\t\t\tIPath oldFilePath = ((IResourceStatus) status).getPath();", "+\t\t\t\t\tchar[] oldTypeName = oldFilePath.removeFileExtension().lastSegment().toCharArray();", "+\t\t\t\t\tchar[][] previousTypeNames = newState.getDefinedTypeNamesFor(compilationUnit.typeLocator());", "+\t\t\t\t\tboolean fromSameFile = false;", "+\t\t\t\t\tif (previousTypeNames == null) {", "+\t\t\t\t\t\tfromSameFile = CharOperation.equals(compilationUnit.getMainTypeName(), oldTypeName);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfor (int i = 0, l = previousTypeNames.length; i < l; i++) {", "+\t\t\t\t\t\t\tif (CharOperation.equals(previousTypeNames[i], oldTypeName)) {", "+\t\t\t\t\t\t\t\tfromSameFile = true;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (fromSameFile) {", "+\t\t\t\t\t\t// file is defined by the same compilationUnit, but won't be deleted until later so do it now", "+\t\t\t\t\t\tIFile collision = file.getParent().getFile(new Path(oldFilePath.lastSegment()));", "+\t\t\t\t\t\tcollision.delete(true, false, null);", "+\t\t\t\t\t\tboolean success = false;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tfile.create(new ByteArrayInputStream(bytes), IResource.FORCE | IResource.DERIVED, null);", "+\t\t\t\t\t\t\tsuccess = true;", "+\t\t\t\t\t\t} catch (CoreException ignored) {", "+\t\t\t\t\t\t\t// ignore the second exception", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (success) return;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// catch the case that a type has been renamed and collides on disk with an as-yet-to-be-deleted type", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a35e3698d0dfa3146a1d1beb7effabb7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "98ad487e103c268099d7117573693243c8d3b8fc", "commitAfterChange": "721a9dcda02493639666143934bddb089e848d18", "methodNumberBeforeChange": 70, "methodNumberAfterChange": 71, "signatureBeforeChange": " protected void reportMatching(FieldDeclaration field, TypeDeclaration type, IJavaElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException", "signatureAfterChange": " protected void reportMatching(FieldDeclaration field, TypeDeclaration type, IJavaElement parent, IJavaElement[] otherElements, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException", "diff": ["-protected void reportMatching(FieldDeclaration field, TypeDeclaration type, IJavaElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException {", "+protected void reportMatching(FieldDeclaration field, TypeDeclaration type, IJavaElement parent, IJavaElement[] otherElements, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException {", "-\t\t// limit scan to end part position for multiple fields declaration (see bug 73112)", "-\t\tint end = field.endPart2Position==0 ? field.declarationSourceEnd : field.endPart2Position;", "-\t\tASTNode[] nodes = nodeSet.matchingNodes(field.declarationSourceStart, end);", "+\t\t// Look at field declaration", "+\t\tif (field.endPart1Position != 0) { // not necessary if field is an initializer", "+\t\t\tASTNode[] nodes = nodeSet.matchingNodes(field.declarationSourceStart, field.endPart1Position);", "+\t\t\tif (nodes != null) {", "+\t\t\t\tif ((this.matchContainer & PatternLocator.FIELD_CONTAINER) == 0) {", "+\t\t\t\t\tfor (int i = 0, l = nodes.length; i < l; i++)", "+\t\t\t\t\t\tnodeSet.matchingNodes.removeKey(nodes[i]);", "+\t\t\t\t} else {", "+\t\t\t\t\tif (enclosingElement == null)", "+\t\t\t\t\t\tenclosingElement = createHandle(field, type, parent);", "+\t\t\t\t\tif (encloses(enclosingElement)) {", "+\t\t\t\t\t\tfor (int i = 0, l = nodes.length; i < l; i++) {", "+\t\t\t\t\t\t\tASTNode node = nodes[i];", "+\t\t\t\t\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(node);", "+\t\t\t\t\t\t\tthis.patternLocator.matchReportReference(node, enclosingElement, null, otherElements, field.binding, level.intValue(), this);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+", "+\t\t// Look in initializer", "+\t\tint fieldEnd = field.endPart2Position == 0 ? field.declarationSourceEnd : field.endPart2Position;", "+\t\tASTNode[] nodes = nodeSet.matchingNodes(field.sourceStart, fieldEnd);", "-\t\t\t\tif (enclosingElement == null)", "+\t\t\t\tif (enclosingElement == null) {", "-\t\t\t\tif (encloses(enclosingElement))", "+\t\t\t\t}", "+\t\t\t\tif (encloses(enclosingElement)) {", "-\t\t\t\t\t\tthis.patternLocator.matchReportReference(node, enclosingElement, field.binding, level.intValue(), this);", "+\t\t\t\t\t\t// Set block scope for initializer in case there would have other local and other elements to report", "+\t\t\t\t\t\tBlockScope blockScope = null;", "+\t\t\t\t\t\tif (field.getKind() == AbstractVariableDeclaration.INITIALIZER) {", "+\t\t\t\t\t\t\tBlock block = ((Initializer)field).block;", "+\t\t\t\t\t\t\tif (block != null) blockScope = block.scope;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.patternLocator.matchReportReference(node, enclosingElement, field.binding, blockScope, level.intValue(), this);", "+\t\t\t\t}"]}], "num": 72467}