{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d13c2a6c91cc99703c4c30656727b098", "detectedBy": ["DIFF_DBSCAN", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "52f12fdb2ae8fcc1bc56764b2e9be811", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "commitAfterChange": "44855522f87e615f1ca0bfcda268b074e4443dfe", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "\r public char[] computeConstantPoolName(LocalTypeBinding localType)", "signatureAfterChange": "\r \tpublic char[] computeConstantPoolName(LocalTypeBinding localType)", "diff": ["+\t */\r", "+\tpublic char[] computeConstantPoolName(LocalTypeBinding localType) {\r", "+\t\tif (localType.constantPoolName() != null) {\r", "+\t\t\treturn localType.constantPoolName();\r", "+\t\t}\r", "+\t\t// delegates to the outermost enclosing classfile, since it is the only one with a global vision of its innertypes.\r", "+\t\tif (enclosingClassFile != null) {\r", "+\t\t\treturn this.outerMostEnclosingClassFile().computeConstantPoolName(localType);\r", "+\t\t}\r", "+\t\tif (nameUsage == null)\r", "+\t\t\tnameUsage = new HashtableOfType();\r", "+\r", "+\t\t// ensure there is not already such a local type name defined by the user\r", "+\t\tint index = 0;\r", "+\t\tchar[] candidateName;\r", "+\t\twhile(true) {\r", "+\t\t\tif (localType.isMemberType()){\r", "+\t\t\t\tif (index == 0){\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\tlocalType.enclosingType().constantPoolName(),\r", "+\t\t\t\t\t\tlocalType.sourceName,\r", "+\t\t\t\t\t\t'$');\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\t// in case of collision, then member name gets extra $1 inserted\r", "+\t\t\t\t\t// e.g. class X { { class L{} new X(){ class L{} } } }\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\tlocalType.enclosingType().constantPoolName(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tString.valueOf(index).toCharArray(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tlocalType.sourceName);\r", "+\t\t\t\t}\r", "+\t\t\t} else if (localType.isAnonymousType()){\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\treferenceBinding.constantPoolName(),\r", "+\t\t\t\t\t\tString.valueOf(index+1).toCharArray(),\r", "+\t\t\t\t\t\t'$');\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\treferenceBinding.constantPoolName(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tString.valueOf(index+1).toCharArray(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tlocalType.sourceName);\r", "+\t\t\t}\t\t\t\t\t\t\r", "+\t\t\tif (nameUsage.get(candidateName) != null) {\r", "+\t\t\t\tindex ++;\r", "+\t\t\t} else {\r", "+\t\t\t\tnameUsage.put(candidateName, localType);\r", "+\t\t\t\tbreak;\r", "+\t\t}\r", "+\t\treturn candidateName;\r", "+\t}\r", "- */\r", "-public char[] computeConstantPoolName(LocalTypeBinding localType) {\r", "-\tif (localType.constantPoolName() != null) {\r", "-\t\treturn localType.constantPoolName();\r", "-\t}\r", "-\r", "-\t// delegates to the outermost enclosing classfile, since it is the only one with a global vision of its innertypes.\r", "-\tif (enclosingClassFile != null) {\r", "-\t\treturn this.outerMostEnclosingClassFile().computeConstantPoolName(localType);\r", "-\t}\r", "-\r", "-\tif (nameUsage == null) {\r", "-\t\tnameUsage = new CharArrayCache();\r", "-\t}\r", "-\tif (localType.isMemberType()) { // catches member types of local types\r", "-\t\treturn CharOperation.concat(\r", "-\t\t\tlocalType.enclosingType().constantPoolName(),\r", "-\t\t\tlocalType.sourceName,\r", "-\t\t\t'$');\r", "-\t} else {\r", "-\t\tchar[][] compoundName =  (char[][]) referenceBinding.compoundName.clone();\r", "-\t\tint last = compoundName.length - 1;\r", "-\t\tStringBuffer nameBuffer = new StringBuffer().append(compoundName[last]);\r", "-\t\t// retrieve the number of use of the combination\r", "-\t\tchar[] simpleName = localType.sourceName;\r", "-\t\t//if (simpleName == null) simpleName = new char[]{}; // for anonymous\r", "-\t\tint nameCount = nameUsage.get(simpleName); // -1 if not found\r", "-\t\tnameCount =  nameCount == -1 ? 1 : nameCount + 1;\r", "-\t\tnameBuffer.append('$').append(nameCount);\r", "-\t\tnameUsage.put(simpleName, nameCount);\r", "-\t\tif (!localType.isAnonymousType()) { // named local type\r", "-\t\t\tnameBuffer.append('$').append(simpleName);\r", "-\t\t}\r", "-\t\tcompoundName[last] = nameBuffer.toString().toCharArray();\r", "-\t\treturn CharOperation.concatWith(compoundName, '/');\r", "-\t}\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "87bb4dc6d89732374e75142b2b5ff145", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "40383c2427f4645edcb9e28f2e15a8a778f0a951", "commitAfterChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "\r public char[] computeConstantPoolName(LocalTypeBinding localType)", "signatureAfterChange": "\r \tpublic char[] computeConstantPoolName(LocalTypeBinding localType)", "diff": ["+\t */\r", "+\tpublic char[] computeConstantPoolName(LocalTypeBinding localType) {\r", "+\t\tif (localType.constantPoolName() != null) {\r", "+\t\t\treturn localType.constantPoolName();\r", "+\t\t}\r", "+\t\t// delegates to the outermost enclosing classfile, since it is the only one with a global vision of its innertypes.\r", "+\t\tif (enclosingClassFile != null) {\r", "+\t\t\treturn this.outerMostEnclosingClassFile().computeConstantPoolName(localType);\r", "+\t\t}\r", "+\t\tif (nameUsage == null)\r", "+\t\t\tnameUsage = new HashtableOfType();\r", "+\r", "+\t\t// ensure there is not already such a local type name defined by the user\r", "+\t\tint index = 0;\r", "+\t\tchar[] candidateName;\r", "+\t\twhile(true) {\r", "+\t\t\tif (localType.isMemberType()){\r", "+\t\t\t\tif (index == 0){\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\tlocalType.enclosingType().constantPoolName(),\r", "+\t\t\t\t\t\tlocalType.sourceName,\r", "+\t\t\t\t\t\t'$');\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\t// in case of collision, then member name gets extra $1 inserted\r", "+\t\t\t\t\t// e.g. class X { { class L{} new X(){ class L{} } } }\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\tlocalType.enclosingType().constantPoolName(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tString.valueOf(index).toCharArray(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tlocalType.sourceName);\r", "+\t\t\t\t}\r", "+\t\t\t} else if (localType.isAnonymousType()){\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\treferenceBinding.constantPoolName(),\r", "+\t\t\t\t\t\tString.valueOf(index+1).toCharArray(),\r", "+\t\t\t\t\t\t'$');\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\treferenceBinding.constantPoolName(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tString.valueOf(index+1).toCharArray(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tlocalType.sourceName);\r", "+\t\t\t}\t\t\t\t\t\t\r", "+\t\t\tif (nameUsage.get(candidateName) != null) {\r", "+\t\t\t\tindex ++;\r", "+\t\t\t} else {\r", "+\t\t\t\tnameUsage.put(candidateName, localType);\r", "+\t\t\t\tbreak;\r", "+\t\t}\r", "+\t\treturn candidateName;\r", "+\t}\r", "- */\r", "-public char[] computeConstantPoolName(LocalTypeBinding localType) {\r", "-\tif (localType.constantPoolName() != null) {\r", "-\t\treturn localType.constantPoolName();\r", "-\t}\r", "-\r", "-\t// delegates to the outermost enclosing classfile, since it is the only one with a global vision of its innertypes.\r", "-\tif (enclosingClassFile != null) {\r", "-\t\treturn this.outerMostEnclosingClassFile().computeConstantPoolName(localType);\r", "-\t}\r", "-\r", "-\tif (nameUsage == null) {\r", "-\t\tnameUsage = new CharArrayCache();\r", "-\t}\r", "-\tif (localType.isMemberType()) { // catches member types of local types\r", "-\t\treturn CharOperation.concat(\r", "-\t\t\tlocalType.enclosingType().constantPoolName(),\r", "-\t\t\tlocalType.sourceName,\r", "-\t\t\t'$');\r", "-\t} else {\r", "-\t\tchar[][] compoundName =  (char[][]) referenceBinding.compoundName.clone();\r", "-\t\tint last = compoundName.length - 1;\r", "-\t\tStringBuffer nameBuffer = new StringBuffer().append(compoundName[last]);\r", "-\t\t// retrieve the number of use of the combination\r", "-\t\tchar[] simpleName = localType.sourceName;\r", "-\t\t//if (simpleName == null) simpleName = new char[]{}; // for anonymous\r", "-\t\tint nameCount = nameUsage.get(simpleName); // -1 if not found\r", "-\t\tnameCount =  nameCount == -1 ? 1 : nameCount + 1;\r", "-\t\tnameBuffer.append('$').append(nameCount);\r", "-\t\tnameUsage.put(simpleName, nameCount);\r", "-\t\tif (!localType.isAnonymousType()) { // named local type\r", "-\t\t\tnameBuffer.append('$').append(simpleName);\r", "-\t\t}\r", "-\t\tcompoundName[last] = nameBuffer.toString().toCharArray();\r", "-\t\treturn CharOperation.concatWith(compoundName, '/');\r", "-\t}\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fd23f77ae3886ff0f60fcd407dab260c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "commitAfterChange": "7e5cc03e445550d3cbc10c611218c79332074276", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "\r public char[] computeConstantPoolName(LocalTypeBinding localType)", "signatureAfterChange": "\r \tpublic char[] computeConstantPoolName(LocalTypeBinding localType)", "diff": ["+\t */\r", "+\tpublic char[] computeConstantPoolName(LocalTypeBinding localType) {\r", "+\t\tif (localType.constantPoolName() != null) {\r", "+\t\t\treturn localType.constantPoolName();\r", "+\t\t}\r", "+\t\t// delegates to the outermost enclosing classfile, since it is the only one with a global vision of its innertypes.\r", "+\t\tif (enclosingClassFile != null) {\r", "+\t\t\treturn this.outerMostEnclosingClassFile().computeConstantPoolName(localType);\r", "+\t\t}\r", "+\t\tif (nameUsage == null)\r", "+\t\t\tnameUsage = new HashtableOfType();\r", "+\r", "+\t\t// ensure there is not already such a local type name defined by the user\r", "+\t\tint index = 0;\r", "+\t\tchar[] candidateName;\r", "+\t\twhile(true) {\r", "+\t\t\tif (localType.isMemberType()){\r", "+\t\t\t\tif (index == 0){\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\tlocalType.enclosingType().constantPoolName(),\r", "+\t\t\t\t\t\tlocalType.sourceName,\r", "+\t\t\t\t\t\t'$');\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\t// in case of collision, then member name gets extra $1 inserted\r", "+\t\t\t\t\t// e.g. class X { { class L{} new X(){ class L{} } } }\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\tlocalType.enclosingType().constantPoolName(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tString.valueOf(index).toCharArray(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tlocalType.sourceName);\r", "+\t\t\t\t}\r", "+\t\t\t} else if (localType.isAnonymousType()){\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\treferenceBinding.constantPoolName(),\r", "+\t\t\t\t\t\tString.valueOf(index+1).toCharArray(),\r", "+\t\t\t\t\t\t'$');\r", "+\t\t\t\t\tcandidateName = CharOperation.concat(\r", "+\t\t\t\t\t\treferenceBinding.constantPoolName(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tString.valueOf(index+1).toCharArray(),\r", "+\t\t\t\t\t\t'$',\r", "+\t\t\t\t\t\tlocalType.sourceName);\r", "+\t\t\t}\t\t\t\t\t\t\r", "+\t\t\tif (nameUsage.get(candidateName) != null) {\r", "+\t\t\t\tindex ++;\r", "+\t\t\t} else {\r", "+\t\t\t\tnameUsage.put(candidateName, localType);\r", "+\t\t\t\tbreak;\r", "+\t\t}\r", "+\t\treturn candidateName;\r", "+\t}\r", "- */\r", "-public char[] computeConstantPoolName(LocalTypeBinding localType) {\r", "-\tif (localType.constantPoolName() != null) {\r", "-\t\treturn localType.constantPoolName();\r", "-\t}\r", "-\r", "-\t// delegates to the outermost enclosing classfile, since it is the only one with a global vision of its innertypes.\r", "-\tif (enclosingClassFile != null) {\r", "-\t\treturn this.outerMostEnclosingClassFile().computeConstantPoolName(localType);\r", "-\t}\r", "-\r", "-\tif (nameUsage == null) {\r", "-\t\tnameUsage = new CharArrayCache();\r", "-\t}\r", "-\tif (localType.isMemberType()) { // catches member types of local types\r", "-\t\treturn CharOperation.concat(\r", "-\t\t\tlocalType.enclosingType().constantPoolName(),\r", "-\t\t\tlocalType.sourceName,\r", "-\t\t\t'$');\r", "-\t} else {\r", "-\t\tchar[][] compoundName =  (char[][]) referenceBinding.compoundName.clone();\r", "-\t\tint last = compoundName.length - 1;\r", "-\t\tStringBuffer nameBuffer = new StringBuffer().append(compoundName[last]);\r", "-\t\t// retrieve the number of use of the combination\r", "-\t\tchar[] simpleName = localType.sourceName;\r", "-\t\t//if (simpleName == null) simpleName = new char[]{}; // for anonymous\r", "-\t\tint nameCount = nameUsage.get(simpleName); // -1 if not found\r", "-\t\tnameCount =  nameCount == -1 ? 1 : nameCount + 1;\r", "-\t\tnameBuffer.append('$').append(nameCount);\r", "-\t\tnameUsage.put(simpleName, nameCount);\r", "-\t\tif (!localType.isAnonymousType()) { // named local type\r", "-\t\t\tnameBuffer.append('$').append(simpleName);\r", "-\t\t}\r", "-\t\tcompoundName[last] = nameBuffer.toString().toCharArray();\r", "-\t\treturn CharOperation.concatWith(compoundName, '/');\r", "-\t}\r", "-}\r"]}], "num": 11623}