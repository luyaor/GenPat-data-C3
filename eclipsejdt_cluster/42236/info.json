{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "518a40723bd2dd466731752fe18e8010", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8afb95271ea75772bff00a7c286c5eb6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "6a29ffabb8852f66a4bd6f0eb1028fdab8109d02", "commitAfterChange": "12a6e6b3ea4cf17ceba63d178b2d704d35d7d009", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "signatureAfterChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "diff": ["+\t\t\t\tboolean firstIsSynthetic = false;", "+\t\t\t\ttry {", "+\t\t\t\t\tif (type.isMember() && method.isConstructor() && !method.isStatic()) {", "+\t\t\t\t\t\tfirstIsSynthetic = true;", "+\t\t\t\t\t\targCount++;", "+\t\t\t\t\t}", "+\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t// ignored", "+\t\t\t\t}", "-\t\t\t\t\t\t\tTypeReference typeRef = arguments[j].type;", "-\t\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "-\t\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "-\t\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t\t\t\t\tchar[] typeName;", "+\t\t\t\t\t\t\tif (j == 0 && firstIsSynthetic) {", "+\t\t\t\t\t\t\t\ttypeName = type.getDeclaringType().getFullyQualifiedName().toCharArray();", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tTypeReference typeRef = arguments[firstIsSynthetic ? j - 1 : j].type;", "+\t\t\t\t\t\t\t\ttypeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "+\t\t\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "+\t\t\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t\t\t\t\t}", "+\t\treturn null;", "-\tIMethod handle = type.getMethod(new String(method.selector), parameterTypeSignatures);", "-\tif (type.isBinary() && !handle.exists()) return null; // element doesn't exist in the .class file", "-\treturn handle;", "+\treturn type.getMethod(new String(method.selector), parameterTypeSignatures);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b057a6b5123f53254f3272a172c23d0b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java", "commitBeforeChange": "ba388ee53170dee91fb2402f317f8b352855c459", "commitAfterChange": "d043ef6776b1e3fad1bb618496ee2a48a9410e4b", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  public void resolve(BlockScope scope)", "signatureAfterChange": "  public void resolve(BlockScope scope)", "diff": ["+\tLambdaExpression lambda = methodScope.referenceContext instanceof LambdaExpression ? (LambdaExpression) methodScope.referenceContext : null;", "-\t\t(methodScope.referenceContext instanceof LambdaExpression) ? ((LambdaExpression) methodScope.referenceContext).expectedResultType() :", "+\t\tlambda != null ? lambda.expectedResultType() :", "-\t\t// the expression should be null", "-\t\tif (this.expression == null)", "+\t\t// the expression should be null, exceptions exist for lambda expressions.", "+\t\tif (this.expression == null) {", "+\t\t\tif (lambda != null)", "+\t\t\t\tlambda.returnsExpression(null, TypeBinding.VOID);", "+\t\t}", "+\t\tif (lambda != null && !this.implicitReturn)", "+\t\t\tlambda.returnsExpression(this.expression, expressionType);", "+\t\tif (lambda != null)", "+\t\t\tlambda.returnsExpression(null,  methodType);", "-\tif ((expressionType = this.expression.resolveType(scope)) == null) return;", "+\t", "+\texpressionType = this.expression.resolveType(scope);", "+\tif (lambda != null)", "+\t\tlambda.returnsExpression(this.expression, expressionType);", "+\t", "+\tif (expressionType == null) return;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f870e2f2e456be33500b77a874854e0f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "94a425e221148886c840b4d545bf87183980be4b", "commitAfterChange": "ee446c21d0aaa4f4c4b0513ad11960ed53ccba7d", "methodNumberBeforeChange": 118, "methodNumberAfterChange": 118, "signatureBeforeChange": " \tpublic void resolveClasspath(PerProjectInfo perProjectInfo) throws JavaModelException", "signatureAfterChange": " \tpublic void resolveClasspath(PerProjectInfo perProjectInfo) throws JavaModelException", "diff": ["+\t\t\tExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();", "-\t\t\t\t\t\t\t// Catch the assertion failure and set ststus instead", "+\t\t\t\t\t\t\t// Catch the assertion failure and set status instead", "+\t\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "+\t\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered ", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (cEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "+\t\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered ", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (rawEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "+\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered ", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f94652383de7742c1741107cc900f95d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "e5950298e29dbaf979a85e6f3f4a27d3f4b008e8", "commitAfterChange": "9473b3328ae3d850ecb04d4c484b0fd6f4ca2ab4", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " void faultInImports()", "signatureAfterChange": " void faultInImports()", "diff": ["-\t\tif (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding)", "-\t\t\tresolvedSingeTypeImports.put(binding.compoundName[binding.compoundName.length - 1], binding);", "+\t\tif (binding.resolvedImport instanceof ReferenceBinding) {", "+\t\t\tReferenceBinding refBinding = (ReferenceBinding) binding.resolvedImport;", "+\t\t\tint nameLength = binding.compoundName.length - 1;", "+\t\t\tif ((!binding.onDemand && !binding.isStatic()) || (binding.onDemand && binding.isStatic())) {", "+\t\t\t\t// either single non-static or on-demand static import", "+\t\t\t\tresolvedSingeTypeImports.put(binding.compoundName[nameLength], binding);", "+\t\t\t} else if (binding.isStatic()) {", "+\t\t\t\t// single static import", "+\t\t\t\tif (refBinding.isMemberType())", "+\t\t\t\t\tresolvedSingeTypeImports.put(binding.compoundName[nameLength], binding);", "+\t\t\t\telse if (nameLength > 0)", "+\t\t\t\t\tresolvedSingeTypeImports.put(binding.compoundName[nameLength-1], binding);", "+\t\t\t}", "+\t\t}"]}], "num": 42236}