{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "077e18b4326465c64fd657aa4c322b38", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "03d7034ed0b32d0480b0d09711e9ccce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterMassiveRegressionTests.java", "commitBeforeChange": "48b439005b4e27b9edf7ac75008df6663dca3609", "commitAfterChange": "db94ada762c25cbafb7604978ccc4fc3df281550", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "  String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator, boolean repeat)", "signatureAfterChange": "  String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator, boolean repeat)", "diff": ["+\tlong timeStart = System.currentTimeMillis();", "+\tif (FAILURES != null) { // Comparison has started", "+\t\tTIME_MEASURES.formatting[0] += System.currentTimeMillis() - timeStart;", "+\t\tTIME_MEASURES.occurences[0]++;", "+\t\tif (edit == null) TIME_MEASURES.null_output[0]++;", "+\t}", "-\tint count = 1;", "+\tint count = 0;", "-\twhile (count++ < FORMAT_REPEAT) {", "+\twhile (++count < FORMAT_REPEAT) {", "+\t\ttimeStart = System.currentTimeMillis();", "+\t\tif (FAILURES != null) { // Comparison has started", "+\t\t\tTIME_MEASURES.formatting[count] += System.currentTimeMillis() - timeStart;", "+\t\t\tTIME_MEASURES.occurences[count]++;", "+\t\t\tif (edit == null) TIME_MEASURES.null_output[count]++;", "+\t\t}", "-\t\t\tString counterString = counterToString(count-1);", "+\t\t\tString counterString = counterToString(count);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4cd9d5e52da104524d5c5b1874360144", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "9fb0bbe2a3801102d42dc2cab72c635ae1849ea0", "commitAfterChange": "906658ef6f48da220e1774c79e394ded35878c9f", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 63, "signatureBeforeChange": " protected void consumeBinaryExpression(int op)", "signatureAfterChange": " protected void consumeBinaryExpression(int op)", "diff": ["+\t\t\t\t\tint numberOfParens = (expr1.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;", "+\t\t\t\t\t\tif (numberOfParens != 0) {", "+\t\t\t\t\t\t\t// clear the bits on cursor and put them back on cursor.left", "+\t\t\t\t\t\t\tcursor.bits &= ~ASTNode.ParenthesizedMASK;", "+\t\t\t\t\t\t\tcursor.left.bits &= ~ASTNode.ParenthesizedMASK;", "+\t\t\t\t\t\t\tcursor.left.bits |= numberOfParens << ASTNode.ParenthesizedSHIFT;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (numberOfParens != 0) {", "+\t\t\t\t\t\t\t// clear the bits on cursor and put them back on cursor.left", "+\t\t\t\t\t\t\tcursor.bits &= ~ASTNode.ParenthesizedMASK;", "+\t\t\t\t\t\t\tcursor.left.bits &= ~ASTNode.ParenthesizedMASK;", "+\t\t\t\t\t\t\tcursor.left.bits |= numberOfParens << ASTNode.ParenthesizedSHIFT;", "+\t\t\t\t\t\t}", "-\t\t\t} else if (expr1 instanceof BinaryExpression && ", "-\t\t\t\t\t\t\t// single out the a + b case", "-\t\t\t\t\t\t((expr1.bits & ASTNode.OperatorMASK) >> ", "+\t\t\t} else if (expr1 instanceof BinaryExpression", "+\t\t\t\t\t&& ((expr1.bits & ASTNode.OperatorMASK) >> ", "+\t\t\t\t// single out the a + b case", "-\t\t\t\t\top);\t\t", "+\t\t\t\t\top);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "50b90ff50845134f518680dde6d867f9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "a11ec54f2e1e149e77b968382e79f482cc29add9", "commitAfterChange": "831d96bc5763622ed503192c35bfd6688abedd96", "methodNumberBeforeChange": 144, "methodNumberAfterChange": 149, "signatureBeforeChange": " protected void consumeEnterVariable()", "signatureAfterChange": " protected void consumeEnterVariable()", "diff": ["+\t// pop any annotations on extended dimensions now, so they don't pollute the base dimensions.", "+\tAnnotation [][] annotationsOnExtendedDimensions = extendedDimension == 0 ? null : getAnnotationsOnDimensions(extendedDimension);", "+\t\t\t\tdeclaration.bits |= ASTNode.HasTypeAnnotations;", "+\t\t\t\tdeclaration.bits |= ASTNode.HasTypeAnnotations;", "+\t\t\tdeclaration.bits |= ASTNode.HasTypeAnnotations;", "+\t\tdeclaration.bits |= (type.bits & ASTNode.HasTypeAnnotations);", "-\t\tdeclaration.type = copyDims(type, dimension);", "+\t\tAnnotation [][] annotationsOnAllDimensions = null;", "+\t\tAnnotation[][] annotationsOnDimensions = type.getAnnotationsOnDimensions();", "+\t\tif (annotationsOnDimensions != null || annotationsOnExtendedDimensions != null) {", "+\t\t\tannotationsOnAllDimensions = getMergedAnnotationsOnDimensions(typeDim, annotationsOnDimensions, extendedDimension, annotationsOnExtendedDimensions); ", "+\t\t\tdeclaration.bits |= (type.bits & ASTNode.HasTypeAnnotations);", "+\t\t}", "+\t\tdeclaration.type = copyDims(type, dimension, annotationsOnAllDimensions);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64ce528a9354f692ed958eeb2528773f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "f875f4161e47c5087f589529b7e7ee5cf66c1b26", "commitAfterChange": "3e03e3984540d3907fa7739b419f89dad9725944", "methodNumberBeforeChange": 64, "methodNumberAfterChange": 59, "signatureBeforeChange": " \tpublic boolean visit( \t\tArrayQualifiedTypeReference arrayQualifiedTypeReference, \t\tClassScope scope)", "signatureAfterChange": " \tpublic boolean visit( \t\tArrayQualifiedTypeReference arrayQualifiedTypeReference, \t\tClassScope scope)", "diff": ["-\t\t\tformatArrayQualifiedTypeReference(arrayQualifiedTypeReference);", "+\t\t\tfinal int numberOfParens = (arrayQualifiedTypeReference.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;", "+\t\t\tif (numberOfParens > 0) {", "+\t\t\t\tmanageOpeningParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);", "+\t\t\t}", "+\t\t\tthis.scribe.printArrayQualifiedReference(arrayQualifiedTypeReference.tokens.length, arrayQualifiedTypeReference.sourceEnd);", "+\t\t\tint dimensions = getDimensions();", "+\t\t\tif (dimensions != 0) {", "+\t\t\t\tfor (int i = 0; i < dimensions; i++) {", "+\t\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameLBRACKET);", "+\t\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameRBRACKET);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (numberOfParens > 0) {", "+\t\t\t\tmanageClosingParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "797cd4e573f206f45c7748b92aa57383", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "c539ab4170e4fe0d8578cc8fb0121c9a797f5894", "commitAfterChange": "44363e0012bf09a8a44565479ae5740426ed378a", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+        this.depth = 0;", "-        ", "-        if (someMethod != null && someMethod.isValidBinding()) {", "+        int someMethodDepth = this.depth, anotherMethodDepth = 0;", "+    \tif (someMethod != null && someMethod.isValidBinding()) {", "+        \t\tthis.depth = 0;", "+        \t\tanotherMethodDepth = this.depth;", "+        \t\tthis.depth = 0;", "-", "-        this.binding = someMethod != null && someMethod.isValidBinding() ? someMethod : ", "-        \t\t\t\t\t\t\t\t\t\t\tanotherMethod != null && anotherMethod.isValidBinding() ? anotherMethod : null;", "+        ", "+        if (someMethod != null && someMethod.isValidBinding()) {", "+        \tthis.binding = someMethod;", "+        \tthis.bits &= ~ASTNode.DepthMASK;", "+        \tif (someMethodDepth > 0) {", "+        \t\tthis.bits |= (someMethodDepth & 0xFF) << ASTNode.DepthSHIFT;", "+        \t}", "+        } else if (anotherMethod != null && anotherMethod.isValidBinding()) {", "+        \tthis.binding = anotherMethod;", "+        \tthis.bits &= ~ASTNode.DepthMASK;", "+        \tif (anotherMethodDepth > 0) {", "+        \t\tthis.bits |= (anotherMethodDepth & 0xFF) << ASTNode.DepthSHIFT;", "+        \t}", "+        } else {", "+        \tthis.binding = null;", "+        \tthis.bits &= ~ASTNode.DepthMASK;", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85da70879dbfd498590e46b36b0f7e76", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/BindingKeyParser.java", "commitBeforeChange": "ffd901457a8019a34d01704f9139e1e52b8a6906", "commitAfterChange": "0926f8224af442af001e56062ed4e4b1654d4df9", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t\t \t\tint nextToken()", "signatureAfterChange": " \t\t \t\tint nextToken()", "diff": ["+\t\t\tint dollarIndex = -1;", "+\t\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\t\tif (dollarIndex != -1) this.index = dollarIndex;", "+\t\t\t\t\t\tif (this.index == previousTokenEnd) {", "+\t\t\t\t\t\t\tthis.start = this.index+1;", "+\t\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (dollarIndex == -1) {", "+\t\t\t\t\t\t\t\tdollarIndex = this.index;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.index = dollarIndex;", "+\t\t\t\t\t\t\tthis.token = TYPE;", "+\t\t\t\t\t\t\treturn this.token;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\tdollarIndex = -1;", "-\t\t\t\t\t\t\t\t\tif (this.source[this.start-2] == '>')", "+\t\t\t\t\t\t\t\t\tif (this.source[this.start-2] == '>') {", "+\t\t\t\t\t\t\t\t\t\tif (dollarIndex != -1) this.index = dollarIndex;", "-\t\t\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\t\t\t\t\tif (dollarIndex != -1) this.index = dollarIndex;", "+\t\t\t\t\t\tdollarIndex = -1;", "+\t\t\t\t\t\t\tdollarIndex = -1;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c200736346bc38b9dee43e032362a104", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "c62ecfd031507c11ea236866605fedd6f3a952c5", "commitAfterChange": "ded73445e8c5cf2db0a4abcc53e1680f02ae6cf7", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tprivate boolean dumpBinaryExpression( \t\tBinaryExpression binaryExpression, \t\tint operator, \t\tBlockScope scope)", "signatureAfterChange": "  \tprivate boolean dumpBinaryExpression( \t\tBinaryExpression binaryExpression, \t\tint operator, \t\tBlockScope scope)", "diff": ["-\t\tif ((builder.realFragmentsSize() > 1 || fragmentsSize > 4) && numberOfParens == 0) {", "-\t\t\tthis.scribe.printComment();", "-\t\t\tAlignment binaryExpressionAlignment = this.scribe.createAlignment(", "-\t\t\t\t\tAlignment.BINARY_EXPRESSION,", "-\t\t\t\t\tthis.preferences.alignment_for_binary_expression,", "-\t\t\t\t\tAlignment.R_OUTERMOST,", "-\t\t\t\t\tfragmentsSize,", "-\t\t\t\t\tthis.scribe.scanner.currentPosition);", "-\t\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "-\t\t\tboolean ok = false;", "-\t\t\tASTNode[] fragments = builder.fragments();", "-\t\t\tint[] operators = builder.operators();", "-\t\t\tdo {", "-\t\t\t\ttry {", "-\t\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "-\t\t\t\t\t\tASTNode fragment = fragments[i];", "-\t\t\t\t\t\tfragment.traverse(this, scope);", "-\t\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "-\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "-\t\t\t\t\t\t\t// a new line has been inserted by printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT)", "-\t\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.preferences.wrap_before_binary_operator) {", "-\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "-\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "-\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "-\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "-\t\t\t\t\t\t\tthis.scribe.space();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "-\t\t\t\t\t\t\tthis.scribe.space();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tfragments[fragmentsSize - 1].traverse(this, scope);", "-\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "-\t\t\t\t\tok = true;", "-\t\t\t\t} catch(AlignmentException e){", "-\t\t\t\t\tthis.scribe.redoAlignment(e);", "-\t\t\t\t}", "-\t\t\t} while (!ok);", "-\t\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);", "+\t\tif (this.expressionsDepth < 0) {", "+\t\t\tthis.expressionsDepth = 0;", "-\t\t\tbinaryExpression.left.traverse(this, scope);", "-\t\t\tthis.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);", "-\t\t\tif (operator == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "-\t\t\t\t// the next character is a minus (unary operator)", "-\t\t\t\tthis.scribe.space();", "+\t\t\tthis.expressionsDepth++;", "+\t\t\tthis.expressionsPos <<= 2;", "+\t\t}", "+\t\ttry {", "+\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = 0;", "+\t\t\tif ((builder.realFragmentsSize() > 1 || fragmentsSize > 4) && numberOfParens == 0) {", "+\t\t\t\tint scribeLine = this.scribe.line;", "+\t\t\t\tthis.scribe.printComment();", "+\t\t\t\tAlignment binaryExpressionAlignment = this.scribe.createAlignment(", "+\t\t\t\t\t\tAlignment.BINARY_EXPRESSION,", "+\t\t\t\t\t\tthis.preferences.alignment_for_binary_expression,", "+\t\t\t\t\t\tAlignment.R_OUTERMOST,", "+\t\t\t\t\t\tfragmentsSize,", "+\t\t\t\t\t\tthis.scribe.scanner.currentPosition);", "+\t\t\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "+\t\t\t\tboolean ok = false;", "+\t\t\t\tASTNode[] fragments = builder.fragments();", "+\t\t\t\tint[] operators = builder.operators();", "+\t\t\t\tdo {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tfinal int max = fragmentsSize - 1;", "+\t\t\t\t\t\tfor (int i = 0; i < max; i++) {", "+\t\t\t\t\t\t\tASTNode fragment = fragments[i];", "+\t\t\t\t\t\t\tfragment.traverse(this, scope);", "+\t\t\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "+\t\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t\t\t// a new line has been inserted while printing the comment", "+\t\t\t\t\t\t\t\t// hence we need to use the break indentation level before printing next token...", "+\t\t\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.preferences.wrap_before_binary_operator) {", "+\t\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tfragments[max].traverse(this, scope);", "+\t\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "+\t\t\t\t\t\tok = true;", "+\t\t\t\t\t} catch(AlignmentException e){", "+\t\t\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t\t\t}", "+\t\t\t\t} while (!ok);", "+\t\t\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);", "+\t\t\t\tif (this.scribe.line == scribeLine) {", "+\t\t\t\t\t// The expression was not broken => reset last break indentation", "+\t\t\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = 0;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.expressionsPos |= EXPRESSIONS_POS_ENTER_TWO;", "+\t\t\t\tbinaryExpression.left.traverse(this, scope);", "+\t\t\t\tthis.expressionsPos &= ~EXPRESSIONS_POS_MASK;", "+\t\t\t\tthis.expressionsPos |= EXPRESSIONS_POS_BETWEEN_TWO;", "+\t\t\t\tthis.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator, Scribe.PRESERVE_EMPTY_LINES_IN_BINARY_EXPRESSION);", "+\t\t\t\tif (operator == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t}", "+\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t}", "+\t\t\t\tbinaryExpression.right.traverse(this, scope);", "-\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "-\t\t\t\tthis.scribe.space();", "+\t\t}", "+\t\tfinally {", "+\t\t\tthis.expressionsDepth--;", "+\t\t\tthis.expressionsPos >>= 2;", "+\t\t\tif (this.expressionsDepth < 0) {", "+\t\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = 0;", "-\t\t\tbinaryExpression.right.traverse(this, scope);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d0755eabf4864367231ef65ceb8d4616", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "69b02d68015b1f30ee38d1576a843274517957c7", "commitAfterChange": "c7a9edf536467451ba659d7e03ac6c483c5c0cfe", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 28, "signatureBeforeChange": " protected void consumeClassHeaderExtends()", "signatureAfterChange": " protected void consumeClassHeaderExtends()", "diff": ["+}", "+\t", "+\tif (currentElement != null", "+\t\t&& currentToken == TokenNameIdentifier", "+\t\t&& this.cursorLocation+1 >= scanner.startPosition", "+\t\t&& this.cursorLocation < scanner.currentPosition){", "+\t\tthis.pushIdentifier();", "+\t\t", "+\t\tint index = -1;", "+\t\t/* check if current awaiting identifier is the completion identifier */", "+\t\tif ((index = this.indexOfAssistIdentifier()) > -1) {", "+", "+\t\t\tRecoveredType recoveredType = (RecoveredType)currentElement;", "+\t\t\t/* filter out cases where scanner is still inside type header */", "+\t\t\tif (!recoveredType.foundOpeningBrace) {", "+\t\t\t\tTypeDeclaration type = recoveredType.typeDeclaration;", "+\t\t\t\tif(type.superInterfaces == null) {", "+\t\t\t\t\ttype.superclass = new CompletionOnKeyword1(", "+\t\t\t\t\t\tidentifierStack[index],", "+\t\t\t\t\t\tidentifierPositionStack[index],", "+\t\t\t\t\t\tKeywords.IMPLEMENTS);", "+\t\t\t\t\tthis.assistNode = type.superclass;", "+\t\t\t\t\tthis.lastCheckPoint = type.superclass.sourceEnd + 1;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e82581b1f893be32d2f8b1e178b218d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "e4b55bd211dccbfbd971d96ae9fb1fa085f3370c", "commitAfterChange": "608a55b772f6bb6d5bb4b781bdb909738331065e", "methodNumberBeforeChange": 136, "methodNumberAfterChange": 136, "signatureBeforeChange": " protected void consumeEnumConstantHeaderName()", "signatureAfterChange": " protected void consumeEnumConstantHeaderName()", "diff": ["-   long pos = this.identifierPositionStack[this.identifierPtr];", "+\tif (this.currentElement != null) {", "+\t\tif (!(this.currentElement instanceof RecoveredType)", "+\t\t\t\t|| (this.lastIgnoredToken == TokenNameDOT)) {", "+\t\t\tthis.lastCheckPoint = this.scanner.startPosition;", "+\t\t\tthis.restartRecovery = true;", "+\t\t\treturn;", "+\t\t}", "+\t}", "+   long namePosition = this.identifierPositionStack[this.identifierPtr];", "-   final int sourceEnd = (int) pos;", "-   FieldDeclaration enumConstant = new FieldDeclaration(constantName, (int) (pos >>> 32), sourceEnd);", "+   final int sourceEnd = (int) namePosition;", "+   FieldDeclaration enumConstant = createFieldDeclaration(constantName, (int) (namePosition >>> 32), sourceEnd);", "+\tif (this.currentElement != null){", "+\t\tif (!(this.currentElement instanceof RecoveredType)", "+\t\t\t&& (this.currentToken == TokenNameDOT)){", "+\t\t\tthis.lastCheckPoint = (int) (namePosition >>> 32);", "+\t\t\tthis.restartRecovery = true;", "+\t\t\treturn;", "+\t\t}", "+\t\tthis.lastCheckPoint = enumConstant.sourceEnd + 1;", "+\t\tthis.currentElement = this.currentElement.add(enumConstant, 0);\t\t", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ffda3bdfe11966e294969f55b9b78d93", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8fd47ede750ba6005aab3e86ceccb03a6e16dba8", "commitAfterChange": "e0664fc441b4961f478c3f32edb809e211e609ac", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tprivate boolean isAdaptableRegion(int offset, int length)", "signatureAfterChange": " \tprivate boolean isAdaptableRegion(int offset, int length)", "diff": ["-\t\tint span = offset + length;", "+\t\tint regionEnd = offset + length + this.lineSeparator.length() - 1;", "-\t\tif (span > this.pageWidth) {", "+\t\tif (regionEnd > this.pageWidth) {", "-\t\t// more than one line selected", "-\t\tif (span > this.getLineEnd(this.scanner.getLineNumber(offset) + 1)) {", "-\t\t\treturn false;", "-\t\t// region is on a single line and CU has more than one line", "-\t\t} else if (this.lineEnds != null && this.lineEnds.length > 1) {", "-\t\t\treturn true;", "+\t\tint numberOfLineEnds = this.lineEnds != null && this.lineEnds.length > 0 ? this.lineEnds.length : 0;", "+\t\tif (this.line > 1 && numberOfLineEnds > 0) { // CU has more than one line", "+\t\t\tint lineNumber = Util.getLineNumber(offset, this.lineEnds, 0, this.line);", "+\t\t\tint lineEnd = this.getLineEnd(lineNumber);", "+\t\t\tif (regionEnd > lineEnd) {", "+\t\t\t\t// if more than one line selected, check whether selection is at line end", "+\t\t\t\tfor (int i = lineNumber + 1 ; i <=  numberOfLineEnds ; i++) {", "+\t\t\t\t\tif (regionEnd == this.getLineEnd(i)) {", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn false; // more than one line selected, no need to adapt region", "+\t\t\t} else {", "+\t\t\t\tif (this.scannerEndPosition - 1 == lineEnd) { // EOF reached?", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\treturn true; // a single line was selected", "+\t\t\t}"]}], "num": 30151}