{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "92be43aea09b4118e0ceb34bac19afab", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2e090d7f32edc7f3fdeb6edb0b3dc763", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatter.java", "commitBeforeChange": "135399ac7f48d47679e738d0a583e6c95ff87fd6", "commitAfterChange": "092d49846655da2c4e511a256ba551dc4e15c674", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r private void format()", "signatureAfterChange": "\r private void format()", "diff": ["-\tint token = 0;\r", "-\tint previousToken = 0;\r", "-\tint previousCompilableToken = 0;\r", "+ int token = 0;\r", "+ int previousToken = 0;\r", "+ int previousCompilableToken = 0;\r", "-\tint indentationOffset = 0;\r", "+ int indentationOffset = 0;\r", "-\tint newLinesInWhitespace = 0;\r", "-\t// number of new lines in the previous whitespace token\r", "-\t// (used to leave blank lines before comments)\r", "-\tint pendingNewLines = 0;\r", "-\tboolean expectingOpenBrace = false;\r", "-\tboolean clearNonBlockIndents = false;\r", "-\t// true if all indentations till the 1st { (usefull after } or ;)\r", "-\tboolean pendingSpace = true;\r", "-\tboolean pendingNewlineAfterParen = false;\r", "-\t// true when a cr is to be put after a ) (in conditional statements)\r", "-\tboolean inAssignment = false;\r", "-\tboolean inArrayAssignment = false;\r", "-\tboolean inThrowsClause = false;\r", "-\tboolean inClassOrInterfaceHeader = false;\r", "+ int newLinesInWhitespace = 0;\r", "+ // number of new lines in the previous whitespace token\r", "+ // (used to leave blank lines before comments)\r", "+ int pendingNewLines = 0;\r", "+ boolean expectingOpenBrace = false;\r", "+ boolean clearNonBlockIndents = false;\r", "+ // true if all indentations till the 1st { (usefull after } or ;)\r", "+ boolean pendingSpace = true;\r", "+ boolean pendingNewlineAfterParen = false;\r", "+ // true when a cr is to be put after a ) (in conditional statements)\r", "+ boolean inAssignment = false;\r", "+ boolean inArrayAssignment = false;\r", "+ boolean inThrowsClause = false;\r", "+ boolean inClassOrInterfaceHeader = false;\r", "-\t// openBracketCount is used to count the number of open brackets not closed yet.\r", "-\tint openBracketCount = 0;\r", "-\t\r", "-\tint unarySignModifier = 0;\r", "+ // openBracketCount is used to count the number of open brackets not closed yet.\r", "+ int openBracketCount = 0;\r", "+ \r", "+  int unarySignModifier = 0;\r", "-\t// openParenthesis[0] is used to count the parenthesis not belonging to a condition\r", "-\t// (eg foo();). parenthesis in for (...) are count elsewhere in the array.\r", "-\tint openParenthesisCount = 1;\r", "-\tint[] openParenthesis = new int[10];\r", "+ // openParenthesis[0] is used to count the parenthesis not belonging to a condition\r", "+ // (eg foo();). parenthesis in for (...) are count elsewhere in the array.\r", "+ int openParenthesisCount = 1;\r", "+ int[] openParenthesis = new int[10];\r", "-\t// tokenBeforeColon is used to know what token goes along with the current :\r", "-\t// it can be case or ?\r", "-\tint tokenBeforeColonCount = 0;\r", "-\tint[] tokenBeforeColon = new int[10];\r", "+ // tokenBeforeColon is used to know what token goes along with the current :\r", "+ // it can be case or ?\r", "+ int tokenBeforeColonCount = 0;\r", "+ int[] tokenBeforeColon = new int[10];\r", "-\tconstructionsCount = 0; // initializes the constructions count.\r", "+ constructionsCount = 0; // initializes the constructions count.\r", "-\t// contains DO if in a DO..WHILE statement, UNITIALIZED otherwise.\r", "-\tint nlicsToken = 0;\r", "+ // contains DO if in a DO..WHILE statement, UNITIALIZED otherwise.\r", "+ int nlicsToken = 0;\r", "-\t// fix for 1FF17XY: LFCOM:ALL - Format problem on not matching } and else \r", "-\tboolean specialElse = false;\r", "+ // fix for 1FF17XY: LFCOM:ALL - Format problem on not matching } and else \r", "+ boolean specialElse = false;\r", "-\t// OPTION (IndentationLevel): initial indentation level may be non-zero.\r", "-\tcurrentLineIndentationLevel += constructionsCount;\r", "+ // OPTION (IndentationLevel): initial indentation level may be non-zero.\r", "+ currentLineIndentationLevel += constructionsCount;\r", "-\t\r", "-\t// An InvalidInputException exception might cause the termination of this loop.\r", "-\ttry {\r", "-\t\twhile (true) {\r", "-\t\t\t// Get the next token.  Catch invalid input and output it\r", "-\t\t\t// with minimal formatting, also catch end of input and\r", "-\t\t\t// exit the loop.\r", "-\t\t\ttry {\r", "-\t\t\t\ttoken = scanner.getNextToken();\r", "-\t\t\t} catch (InvalidInputException e) {\r", "-\t\t\t\tif (!handleInvalidToken(e)) {\r", "-\t\t\t\t\tthrow e;\r", "-\t\t\t\t}\r", "-\t\t\t\ttoken = 0;\r", "-\t\t\t}\r", "-\t\t\tif (token == Scanner.TokenNameEOF)\r", "-\t\t\t\tbreak;\r", "+ \r", "+ // An InvalidInputException exception might cause the termination of this loop.\r", "+ try {\r", "+  while (true) {\r", "+   // Get the next token.  Catch invalid input and output it\r", "+   // with minimal formatting, also catch end of input and\r", "+   // exit the loop.\r", "+   try {\r", "+    token = scanner.getNextToken();\r", "+   } catch (InvalidInputException e) {\r", "+    if (!handleInvalidToken(e)) {\r", "+     throw e;\r", "+    }\r", "+    token = 0;\r", "+   }\r", "+   if (token == Scanner.TokenNameEOF)\r", "+    break;\r", "-\t\t\t/* ## MODIFYING the indentation level before generating new lines\r", "-\t\t\tand indentation in the output string\r", "-\t\t\t*/\r", "+   /* ## MODIFYING the indentation level before generating new lines\r", "+   and indentation in the output string\r", "+   */\r", "-\t\t\t// Removes all the indentations made by statements not followed by a block\r", "-\t\t\t// except if the current token is ELSE, CATCH or if we are in a switch/case\r", "+   // Removes all the indentations made by statements not followed by a block\r", "+   // except if the current token is ELSE, CATCH or if we are in a switch/case\r", "-\t\t\tif (clearNonBlockIndents && (token != Scanner.TokenNameWHITESPACE)) {\r", "+   if (clearNonBlockIndents && (token != Scanner.TokenNameWHITESPACE)) {\r", "-\t\t\t\tswitch (token) {\r", "-\t\t\t\t\tcase TokenNameelse :\r", "-\t\t\t\t\t\tif (constructionsCount > 0 && constructions[constructionsCount-1] == TokenNameelse){\r", "-\t\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\t\tspecialElse = true;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNameif);\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase TokenNamecatch :\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNamecatch);\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase TokenNamefinally :\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNamecatch);\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase TokenNamewhile :\r", "-\t\t\t\t\t\tif (nlicsToken == TokenNamedo) {\r", "-\t\t\t\t\t\t\tindentationLevel += pop(TokenNamedo);\r", "-\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\tdefault :\r", "-\t\t\t\t\t\tindentationLevel += popExclusiveUntilBlockOrCase();\r", "-\t\t\t\t\t\t// clear until a CASE, DEFAULT or BLOCK is encountered.\r", "-\t\t\t\t\t\t// Thus, the indentationLevel is correctly cleared either\r", "-\t\t\t\t\t\t// in a switch/case statement or in any other situation.\r", "-\t\t\t\t}\r", "-\t\t\t\tclearNonBlockIndents = false;\r", "-\t\t\t}\r", "+    switch (token) {\r", "+     case TokenNameelse :\r", "+      if (constructionsCount > 0 && constructions[constructionsCount-1] == TokenNameelse){\r", "+       pendingNewLines = 1;\r", "+       specialElse = true;\r", "+      }\r", "+      indentationLevel += popInclusiveUntil(TokenNameif);\r", "+      break;\r", "+     case TokenNamecatch :\r", "+      indentationLevel += popInclusiveUntil(TokenNamecatch);\r", "+      break;\r", "+     case TokenNamefinally :\r", "+      indentationLevel += popInclusiveUntil(TokenNamecatch);\r", "+      break;\r", "+     case TokenNamewhile :\r", "+      if (nlicsToken == TokenNamedo) {\r", "+       indentationLevel += pop(TokenNamedo);\r", "+       break;\r", "+      }\r", "+     default :\r", "+      indentationLevel += popExclusiveUntilBlockOrCase();\r", "+      // clear until a CASE, DEFAULT or BLOCK is encountered.\r", "+      // Thus, the indentationLevel is correctly cleared either\r", "+      // in a switch/case statement or in any other situation.\r", "+    }\r", "+    clearNonBlockIndents = false;\r", "+   }\r", "-\t\t\t// returns to the indentation level created by the SWITCH keyword\r", "-\t\t\t// if the current token is a CASE or a DEFAULT\r", "+   // returns to the indentation level created by the SWITCH keyword\r", "+   // if the current token is a CASE or a DEFAULT\r", "-\t\t\tif (token == TokenNamecase || token == TokenNamedefault) {\r", "-\t\t\t\tindentationLevel += pop(TokenNamecase);\r", "-\t\t\t}\r", "+   if (token == TokenNamecase || token == TokenNamedefault) {\r", "+    indentationLevel += pop(TokenNamecase);\r", "+   }\r", "-\t\t\tif (token == Scanner.TokenNamethrows) {\r", "-\t\t\t\tinThrowsClause = true;\r", "-\t\t\t}\r", "+   if (token == Scanner.TokenNamethrows) {\r", "+    inThrowsClause = true;\r", "+   }\r", "-\t\t\tif (token == Scanner.TokenNameclass || token == Scanner.TokenNameinterface) {\r", "-\t\t\t\tinClassOrInterfaceHeader = true;\r", "-\t\t\t}\r", "-\t\t\t/* ## APPEND newlines and indentations to the output string\r", "-\t\t\t*/\r", "+   if (token == Scanner.TokenNameclass || token == Scanner.TokenNameinterface) {\r", "+    inClassOrInterfaceHeader = true;\r", "+   }\r", "+   /* ## APPEND newlines and indentations to the output string\r", "+   */\r", "-\t\t\t// Do not add a new line between ELSE and IF, if the option elseIfOnSameLine is true.\r", "-\t\t\t// Fix for 1ETLWPZ: IVJCOM:ALL - incorrect \"else if\" formatting\r", "-\t\t\tif (pendingNewlineAfterParen && previousCompilableToken == TokenNameelse && token == TokenNameif && options.compactElseIfMode){\r", "-\t\t\t\tpendingNewlineAfterParen = false;\r", "-\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\tindentationLevel += pop(TokenNameelse);\r", "-\t\t\t\t// because else if is now one single statement,\r", "-\t\t\t\t// the indentation level after it is increased by one and not by 2\r", "-\t\t\t\t// (else = 1 indent, if = 1 indent, but else if = 1 indent, not 2).\r", "-\t\t\t}\r", "-\t\t\t\r", "-\t\t\t// Add a newline & indent to the formatted source string if\r", "-\t\t\t// a for/if-else/while statement was scanned and there is no block\r", "-\t\t\t// following it.\r", "-\t\t\t\r", "-\t\t\tpendingNewlineAfterParen = pendingNewlineAfterParen || (previousCompilableToken == TokenNameRPAREN && token == TokenNameLBRACE);\r", "-\t\t\tif (pendingNewlineAfterParen && token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t\tpendingNewlineAfterParen = false;\r", "+   // Do not add a new line between ELSE and IF, if the option elseIfOnSameLine is true.\r", "+   // Fix for 1ETLWPZ: IVJCOM:ALL - incorrect \"else if\" formatting\r", "+   if (pendingNewlineAfterParen && previousCompilableToken == TokenNameelse && token == TokenNameif && options.compactElseIfMode){\r", "+    pendingNewlineAfterParen = false;\r", "+    pendingNewLines = 0;\r", "+    indentationLevel += pop(TokenNameelse);\r", "+    // because else if is now one single statement,\r", "+    // the indentation level after it is increased by one and not by 2\r", "+    // (else = 1 indent, if = 1 indent, but else if = 1 indent, not 2).\r", "+   }\r", "+   \r", "+   // Add a newline & indent to the formatted source string if\r", "+   // a for/if-else/while statement was scanned and there is no block\r", "+   // following it.\r", "+   \r", "+   pendingNewlineAfterParen = pendingNewlineAfterParen || (previousCompilableToken == TokenNameRPAREN && token == TokenNameLBRACE);\r", "+   if (pendingNewlineAfterParen && token != Scanner.TokenNameWHITESPACE) {\r", "+    pendingNewlineAfterParen = false;\r", "-\t\t\t\t// Do to add a newline & indent sequence if the current token is an\r", "-\t\t\t\t// open brace or a period or if the current token is a semi-colon and the\r", "-\t\t\t\t// previous token is a close paren.\r", "-\t\t\t\t// add a new line if a parenthesis belonging to a for() statement\r", "-\t\t\t\t// has been closed and the current token is not an opening brace\r", "+    // Do to add a newline & indent sequence if the current token is an\r", "+    // open brace or a period or if the current token is a semi-colon and the\r", "+    // previous token is a close paren.\r", "+    // add a new line if a parenthesis belonging to a for() statement\r", "+    // has been closed and the current token is not an opening brace\r", "-\t\t\t\tif (token != TokenNameLBRACE && !isComment(token)\r", "-\t\t\t\t// to avoid adding new line between else and a comment\r", "-\t\t\t\t\t\t&& token != TokenNameDOT\r", "-\t\t\t\t\t\t&& ! (previousCompilableToken == TokenNameRPAREN\r", "-\t\t\t\t\t\t\t&& token == TokenNameSEMICOLON)) {\r", "-\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\tcurrentLineIndentationLevel += indentationLevel;\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tif (token == TokenNameLBRACE && options.newLineBeforeOpeningBraceMode) {\r", "-\t\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "-\t\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "+    if (token != TokenNameLBRACE && !isComment(token)\r", "+    // to avoid adding new line between else and a comment\r", "+      && token != TokenNameDOT\r", "+      && ! (previousCompilableToken == TokenNameRPAREN\r", "+       && token == TokenNameSEMICOLON)) {\r", "+     newLine(1);\r", "+     currentLineIndentationLevel = indentationLevel;\r", "+     pendingNewLines = 0;\r", "+     pendingSpace = false;\r", "+    } else {\r", "+     if (token == TokenNameLBRACE && options.newLineBeforeOpeningBraceMode) {\r", "+      newLine(1);\r", "+      if (constructionsCount > 0\r", "+       && constructions[constructionsCount - 1] != BLOCK\r", "+       && constructions[constructionsCount - 1] != NONINDENT_BLOCK) {\r", "+       currentLineIndentationLevel = indentationLevel - 1;\r", "+      } else {\r", "+       currentLineIndentationLevel = indentationLevel;\r", "+      }\r", "+      pendingNewLines = 0;\r", "+      pendingSpace = false;\r", "+     }\r", "+    }\r", "+   }\r", "-\t\t\t// see PR 1G5G8EC\r", "-\t\t\tif (token == TokenNameLBRACE && inThrowsClause) {\r", "-\t\t\t\tinThrowsClause = false;      \r", "-\t\t\t\tif (options.newLineBeforeOpeningBraceMode) {\r", "-\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\t\r", "-\t\t\t// see PR 1G5G82G\r", "-\t\t\tif (token == TokenNameLBRACE && inClassOrInterfaceHeader) {\r", "-\t\t\t\tinClassOrInterfaceHeader = false;\r", "-\t\t\t\tif (options.newLineBeforeOpeningBraceMode) {\r", "-\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t}\r", "-\t\t\t}            \r", "-\t\t\t// Add pending new lines to the formatted source string.\r", "-\t\t\t// Note: pending new lines are not added if the current token\r", "-\t\t\t// is a single line comment or whitespace.\r", "-\t\t\t// if the comment is between parenthesis, there is no blank line preservation\r", "-\t\t\t// (if it's a one-line comment, a blank line is added after it).\r", "+   if (token == TokenNameLBRACE\r", "+    && options.newLineBeforeOpeningBraceMode\r", "+    && constructionsCount > 0\r", "+    && constructions[constructionsCount - 1] == TokenNamedo) {\r", "+    newLine(1);\r", "+    currentLineIndentationLevel = indentationLevel - 1;\r", "+    pendingNewLines = 0;\r", "+    pendingSpace = false;\r", "+   }\r", "-\t\t\tif (((pendingNewLines > 0 && (!isComment(token)))\r", "-\t\t\t\t\t|| (newLinesInWhitespace > 0\r", "-\t\t\t\t\t\t\t&& (openParenthesisCount <= 1 && isComment(token)))\r", "-\t\t\t\t\t|| (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE))\r", "-\t\t\t\t&& token != Scanner.TokenNameWHITESPACE) {\r", "+   // see PR 1G5G8EC\r", "+   if (token == TokenNameLBRACE && inThrowsClause) {\r", "+    inThrowsClause = false;      \r", "+    if (options.newLineBeforeOpeningBraceMode) {\r", "+     newLine(1);\r", "+     currentLineIndentationLevel = indentationLevel;\r", "+     pendingNewLines = 0;\r", "+     pendingSpace = false;\r", "+    }\r", "+   }\r", "+   \r", "+   // see PR 1G5G82G\r", "+   if (token == TokenNameLBRACE && inClassOrInterfaceHeader) {\r", "+    inClassOrInterfaceHeader = false;\r", "+    if (options.newLineBeforeOpeningBraceMode) {\r", "+     newLine(1);\r", "+     currentLineIndentationLevel = indentationLevel;\r", "+     pendingNewLines = 0;\r", "+     pendingSpace = false;\r", "+    }\r", "+   }            \r", "+   // Add pending new lines to the formatted source string.\r", "+   // Note: pending new lines are not added if the current token\r", "+   // is a single line comment or whitespace.\r", "+   // if the comment is between parenthesis, there is no blank line preservation\r", "+   // (if it's a one-line comment, a blank line is added after it).\r", "-\t\t\t\t// Do not add newline & indent between an adjoining close brace and\r", "-\t\t\t\t// close paren.  Anonymous inner classes may use this form.\r", "+   if (((pendingNewLines > 0 && (!isComment(token)))\r", "+     || (newLinesInWhitespace > 0\r", "+       && (openParenthesisCount <= 1 && isComment(token)))\r", "+     || (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE))\r", "+    && token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t\tboolean closeBraceAndCloseParen = \r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameRPAREN; \r", "+    // Do not add newline & indent between an adjoining close brace and\r", "+    // close paren.  Anonymous inner classes may use this form.\r", "-\t\t\t\t// OPTION (NewLineInCompoundStatement): do not add newline & indent\r", "-\t\t\t\t// between close brace and else, (do) while, catch, and finally if\r", "-\t\t\t\t// newlineInCompoundStatement is true.\r", "+    boolean closeBraceAndCloseParen = \r", "+      previousToken == TokenNameRBRACE && token == TokenNameRPAREN; \r", "-\t\t\t\tboolean nlicsOption = \r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE\r", "-\t\t\t\t\t\t\t&& !options.newlineInControlStatementMode\r", "-\t\t\t\t\t\t\t&& (token == TokenNameelse\r", "-\t\t\t\t\t\t\t\t|| (token == TokenNamewhile && nlicsToken == TokenNamedo)\r", "-\t\t\t\t\t\t\t\t|| token == TokenNamecatch\r", "-\t\t\t\t\t\t\t\t|| token == TokenNamefinally);\r", "+    // OPTION (NewLineInCompoundStatement): do not add newline & indent\r", "+    // between close brace and else, (do) while, catch, and finally if\r", "+    // newlineInCompoundStatement is true.\r", "-\t\t\t\t// Do not add a newline & indent between a close brace and semi-colon.\r", "-\t\t\t\tboolean semiColonAndCloseBrace = \r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameSEMICOLON; \r", "+    boolean nlicsOption = \r", "+      previousToken == TokenNameRBRACE\r", "+       && !options.newlineInControlStatementMode\r", "+       && (token == TokenNameelse\r", "+        || (token == TokenNamewhile && nlicsToken == TokenNamedo)\r", "+        || token == TokenNamecatch\r", "+        || token == TokenNamefinally);\r", "-\t\t\t\t// Do not add a new line & indent between a multiline comment and a opening brace\r", "+    // Do not add a newline & indent between a close brace and semi-colon.\r", "-\t\t\t\tboolean commentAndOpenBrace = previousToken == Scanner.TokenNameCOMMENT_BLOCK && token == TokenNameLBRACE;\r", "-\t\t\t\t\r", "-\t\t\t\t// Do not add a newline & indent between a close brace and a colon (in array assignments, for example).\r", "-\t\t\t\t\r", "-\t\t\t\tboolean commaAndCloseBrace =\r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameCOMMA; \r", "+    boolean semiColonAndCloseBrace = \r", "+      previousToken == TokenNameRBRACE && token == TokenNameSEMICOLON; \r", "-\t\t\t\t// Add a newline and indent, if appropriate.\r", "+    // Do not add a new line & indent between a multiline comment and a opening brace\r", "-\t\t\t\tif (specialElse || (!commentAndOpenBrace && !closeBraceAndCloseParen && !nlicsOption && !semiColonAndCloseBrace && !commaAndCloseBrace)) {\r", "-\t\t\t\t\t// if clearAllBlankLinesMode=false, leaves the blank lines\r", "-\t\t\t\t\t// inserted by the user\r", "-\t\t\t\t\t// if clearAllBlankLinesMode=true, removes all of then\r", "-\t\t\t\t\t// and insert only blank lines required by the formatting.\r", "-\t\t\t\t\tif (!options.clearAllBlankLinesMode) {\r", "-\t\t\t\t\t\tpendingNewLines = \r", "-\t\t\t\t\t\t\t\t(pendingNewLines < newLinesInWhitespace)\r", "+    boolean commentAndOpenBrace = previousToken == Scanner.TokenNameCOMMENT_BLOCK && token == TokenNameLBRACE;\r", "+    \r", "+    // Do not add a newline & indent between a close brace and a colon (in array assignments, for example).\r", "+    \r", "+    boolean commaAndCloseBrace =\r", "+      previousToken == TokenNameRBRACE && token == TokenNameCOMMA; \r", "+\r", "+    // Add a newline and indent, if appropriate.\r", "+\r", "+    if (specialElse || (!commentAndOpenBrace && !closeBraceAndCloseParen && !nlicsOption && !semiColonAndCloseBrace && !commaAndCloseBrace)) {\r", "+     // if clearAllBlankLinesMode=false, leaves the blank lines\r", "+     // inserted by the user\r", "+     // if clearAllBlankLinesMode=true, removes all of then\r", "+     // and insert only blank lines required by the formatting.\r", "+     if (!options.clearAllBlankLinesMode) {\r", "+      pendingNewLines = \r", "+        (pendingNewLines < newLinesInWhitespace)\r", "-\t\t\t\t\t\t\t\t\t? newLinesInWhitespace \r", "-\t\t\t\t\t\t\t\t\t: pendingNewLines;\r", "-\t\t\t\t\t\tpendingNewLines = (pendingNewLines > 2) ? 2 : pendingNewLines;\r", "-\t\t\t\t\t}\r", "+         ? newLinesInWhitespace \r", "+         : pendingNewLines;\r", "+      pendingNewLines = (pendingNewLines > 2) ? 2 : pendingNewLines;\r", "+     }\r", "-\t\t\t\t\tif (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE) {\r", "-\t\t\t\t\t\tcontainsOpenCloseBraces = true;\r", "-\t\t\t\t\t\tindentationLevelForOpenCloseBraces = currentLineIndentationLevel;\r", "-\t\t\t\t\t\tif (isComment(previousToken)) {\r", "-\t\t\t\t\t\t\tnewLine(pendingNewLines);\r", "-\t\t\t\t\t\t} else {\r", "+     if (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE) {\r", "+      containsOpenCloseBraces = true;\r", "+      indentationLevelForOpenCloseBraces = currentLineIndentationLevel;\r", "+      if (isComment(previousToken)) {\r", "+       newLine(pendingNewLines);\r", "+      } else {\r", "-\t\t\t\t\t\t\t\t&& constructions[constructionsCount-1] == NONINDENT_BLOCK\r", "-\t\t\t\t\t\t\t\t&& (constructions[constructionsCount-2] == TokenNamefor \r", "-\t\t\t\t\t\t\t\t\t|| constructions[constructionsCount-2] == TokenNamewhile))) {*/\r", "-\t\t\t\t\t\t\tif (options.newLineInEmptyBlockMode) {\r", "-\t\t\t\t\t\t\t\tif (inArrayAssignment) {\r", "-\t\t\t\t\t\t\t\t\tnewLine(1); // array assigment with an empty block\r", "-\t\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t\tnewLine(pendingNewLines);\r", "-\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t}\r", "+        && constructions[constructionsCount-1] == NONINDENT_BLOCK\r", "+        && (constructions[constructionsCount-2] == TokenNamefor \r", "+         || constructions[constructionsCount-2] == TokenNamewhile))) {*/\r", "+       if (options.newLineInEmptyBlockMode) {\r", "+        if (inArrayAssignment) {\r", "+         newLine(1); // array assigment with an empty block\r", "+        } else {\r", "+         newLine(pendingNewLines);\r", "+        }\r", "+       }\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t// see PR 1FKKC3U: LFCOM:WINNT - Format problem with a comment before the ';'\r", "-\t\t\t\t\t\tif (!((previousToken == Scanner.TokenNameCOMMENT_BLOCK || previousToken == Scanner.TokenNameCOMMENT_JAVADOC) && token == TokenNameSEMICOLON)) {\r", "-\t\t\t\t\t\t\tnewLine(pendingNewLines);                       \r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (((previousCompilableToken == TokenNameSEMICOLON)\r", "-\t\t\t\t\t\t\t|| (previousCompilableToken == TokenNameLBRACE)\r", "-\t\t\t\t\t\t\t|| (previousCompilableToken == TokenNameRBRACE)\r", "-\t\t\t\t\t\t\t|| (isComment(previousToken)))\r", "-\t\t\t\t\t\t&& (token == TokenNameRBRACE)) {\r", "-\t\t\t\t\t\tindentationOffset = -1;\r", "-\t\t\t\t\t\tindentationLevel += popExclusiveUntilBlock();\r", "-\t\t\t\t\t}\r", "+      }\r", "+     } else {\r", "+      // see PR 1FKKC3U: LFCOM:WINNT - Format problem with a comment before the ';'\r", "+      if (!((previousToken == Scanner.TokenNameCOMMENT_BLOCK || previousToken == Scanner.TokenNameCOMMENT_JAVADOC) && token == TokenNameSEMICOLON)) {\r", "+       newLine(pendingNewLines);                       \r", "+      }\r", "+     }\r", "+     if (((previousCompilableToken == TokenNameSEMICOLON)\r", "+       || (previousCompilableToken == TokenNameLBRACE)\r", "+       || (previousCompilableToken == TokenNameRBRACE)\r", "+       || (isComment(previousToken)))\r", "+      && (token == TokenNameRBRACE)) {\r", "+      indentationOffset = -1;\r", "+      indentationLevel += popExclusiveUntilBlock();\r", "+     }\r", "-\t\t\t\t\tif (previousToken == Scanner.TokenNameCOMMENT_LINE && inAssignment) {\r", "-\t\t\t\t\t\t// PR 1FI5IPO\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel++;\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel + indentationOffset;\r", "-\t\t\t\t\t}\r", "+     if (previousToken == Scanner.TokenNameCOMMENT_LINE && inAssignment) {\r", "+      // PR 1FI5IPO\r", "+      currentLineIndentationLevel++;\r", "+     } else {\r", "+      currentLineIndentationLevel = indentationLevel + indentationOffset;\r", "+     }\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tindentationOffset = 0;\r", "-\t\t\t\t}\r", "-\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\tnewLinesInWhitespace = 0;\r", "-\t\t\t\tspecialElse = false;\r", "+     pendingSpace = false;\r", "+     indentationOffset = 0;\r", "+    }\r", "+    pendingNewLines = 0;\r", "+    newLinesInWhitespace = 0;\r", "+    specialElse = false;\r", "-\t\t\t\tif (nlicsToken == TokenNamedo && token == TokenNamewhile) {\r", "-\t\t\t\t\tnlicsToken = 0;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "+    if (nlicsToken == TokenNamedo && token == TokenNamewhile) {\r", "+     nlicsToken = 0;\r", "+    }\r", "+   }\r", "-\t\t\tswitch (token) {\r", "-\t\t\t\tcase TokenNameelse :\r", "-\t\t\t\tcase TokenNamefinally :\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\tpendingNewlineAfterParen = true;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamecase :\r", "-\t\t\t\tcase TokenNamedefault :\r", "-\t\t\t\t\tif (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "-\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\ttokenBeforeColon, \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\t(tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\ttokenBeforeColonCount); \r", "-\t\t\t\t\t}\r", "-\t\t\t\t\ttokenBeforeColon[tokenBeforeColonCount++] = TokenNamecase;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(TokenNamecase);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameQUESTION :\r", "-\t\t\t\t\tif (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "-\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\ttokenBeforeColon, \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\t(tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\ttokenBeforeColonCount); \r", "-\t\t\t\t\t}\r", "-\t\t\t\t\ttokenBeforeColon[tokenBeforeColonCount++] = token;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameswitch :\r", "-\t\t\t\tcase TokenNamefor :\r", "-\t\t\t\tcase TokenNameif :\r", "-\t\t\t\tcase TokenNamewhile :\r", "-\t\t\t\t\tif (openParenthesisCount == openParenthesis.length) {\r", "-\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\topenParenthesis, \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\t(openParenthesis = new int[openParenthesisCount * 2]), \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\topenParenthesisCount); \r", "-\t\t\t\t\t}\r", "-\t\t\t\t\topenParenthesis[openParenthesisCount++] = 0;\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\t\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNametry :\r", "-\t\t\t\t\tpendingNewlineAfterParen = true;\r", "-\t\t\t\tcase TokenNamecatch :\r", "-\t\t\t\t\t// several CATCH statements can be contiguous.\r", "-\t\t\t\t\t// a CATCH is encountered pop until first CATCH (if a CATCH follows a TRY it works the same way,\r", "-\t\t\t\t\t// as CATCH and TRY are the same token in the stack).\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(TokenNamecatch);\r", "-\t\t\t\t\tbreak;\r", "+   switch (token) {\r", "+    case TokenNameelse :\r", "+    case TokenNamefinally :\r", "+     expectingOpenBrace = true;\r", "+     pendingNewlineAfterParen = true;\r", "+     indentationLevel += pushControlStatement(token);\r", "+     break;\r", "+    case TokenNamecase :\r", "+    case TokenNamedefault :\r", "+     if (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "+      System.arraycopy(\r", "+        tokenBeforeColon, \r", "+        0, \r", "+        (tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "+        0, \r", "+        tokenBeforeColonCount); \r", "+     }\r", "+     tokenBeforeColon[tokenBeforeColonCount++] = TokenNamecase;\r", "+     indentationLevel += pushControlStatement(TokenNamecase);\r", "+     break;\r", "+    case TokenNameQUESTION :\r", "+     if (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "+      System.arraycopy(\r", "+        tokenBeforeColon, \r", "+        0, \r", "+        (tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "+        0, \r", "+        tokenBeforeColonCount); \r", "+     }\r", "+     tokenBeforeColon[tokenBeforeColonCount++] = token;\r", "+     break;\r", "+    case TokenNameswitch :\r", "+    case TokenNamefor :\r", "+    case TokenNameif :\r", "+    case TokenNamewhile :\r", "+     if (openParenthesisCount == openParenthesis.length) {\r", "+      System.arraycopy(\r", "+        openParenthesis, \r", "+        0, \r", "+        (openParenthesis = new int[openParenthesisCount * 2]), \r", "+        0, \r", "+        openParenthesisCount); \r", "+     }\r", "+     openParenthesis[openParenthesisCount++] = 0;\r", "+     expectingOpenBrace = true;\r", "+     \r", "+     indentationLevel += pushControlStatement(token);\r", "+     break;\r", "+    case TokenNametry :\r", "+     pendingNewlineAfterParen = true;\r", "+    case TokenNamecatch :\r", "+     // several CATCH statements can be contiguous.\r", "+     // a CATCH is encountered pop until first CATCH (if a CATCH follows a TRY it works the same way,\r", "+     // as CATCH and TRY are the same token in the stack).\r", "+     expectingOpenBrace = true;\r", "+     indentationLevel += pushControlStatement(TokenNamecatch);\r", "+     break;\r", "-\t\t\t\tcase TokenNamedo :\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "-\t\t\t\t\tnlicsToken = token;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamenew :\r", "+    case TokenNamedo :\r", "+     expectingOpenBrace = true;\r", "+     indentationLevel += pushControlStatement(token);\r", "+     nlicsToken = token;\r", "+     break;\r", "+    case TokenNamenew :\r", "+     break;\r", "+    case TokenNameLPAREN :\r", "-\t\t\t\t\t// The flag inAssigment is used to properly format\r", "-\t\t\t\t\t// array assignments, and if a non-array assignment\r", "-\t\t\t\t\t// statement is in progress, it is no longer\r", "-\t\t\t\t\t// beneficial to know this, so set the flag to false.\r", "+     // Put a space between the previous and current token if the\r", "+     // previous token was not a keyword, open paren, logical\r", "+     // compliment (eg: !), semi-colon, open brace, close brace,\r", "+     // super, or this.\r", "-/*                  if (!inArrayAssignment) {\r", "-\t\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\t}*/\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameLPAREN :\r", "+     if (previousCompilableToken != TokenNameLBRACKET\r", "+      && previousToken != TokenNameIdentifier\r", "+      && previousToken != 0\r", "+      && previousToken != TokenNameNOT\r", "+      && previousToken != TokenNameLPAREN\r", "+      && previousToken != TokenNameTWIDDLE\r", "+      && previousToken != TokenNameSEMICOLON\r", "+      && previousToken != TokenNameLBRACE\r", "+      && previousToken != TokenNameRBRACE\r", "+      && previousToken != TokenNamesuper\r", "+      && previousToken != TokenNamethis) {\r", "+      space();\r", "+     }\r", "-\t\t\t\t\t// Put a space between the previous and current token if the\r", "-\t\t\t\t\t// previous token was not a keyword, open paren, logical\r", "-\t\t\t\t\t// compliment (eg: !), semi-colon, open brace, close brace,\r", "-\t\t\t\t\t// super, or this.\r", "+     // If in a for/if/while statement, increase the parenthesis count\r", "+     // for the current openParenthesisCount\r", "+     // else increase the count for stand alone parenthesis.\r", "+     if (openParenthesisCount > 0)\r", "+      openParenthesis[openParenthesisCount - 1]++;\r", "+     else\r", "+      openParenthesis[0]++;\r", "-\t\t\t\t\tif (previousCompilableToken != TokenNameLBRACKET\r", "-\t\t\t\t\t\t&& previousToken != TokenNameIdentifier\r", "-\t\t\t\t\t\t&& previousToken != 0\r", "-\t\t\t\t\t\t&& previousToken != TokenNameNOT\r", "-\t\t\t\t\t\t&& previousToken != TokenNameLPAREN\r", "-\t\t\t\t\t\t&& previousToken != TokenNameTWIDDLE\r", "-\t\t\t\t\t\t&& previousToken != TokenNameSEMICOLON\r", "-\t\t\t\t\t\t&& previousToken != TokenNameLBRACE\r", "-\t\t\t\t\t\t&& previousToken != TokenNameRBRACE\r", "-\t\t\t\t\t\t&& previousToken != TokenNamesuper\r", "-\t\t\t\t\t\t&& previousToken != TokenNamethis) {\r", "-\t\t\t\t\t\tspace();\r", "-\t\t\t\t\t}\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameRPAREN :\r", "-\t\t\t\t\t// If in a for/if/while statement, increase the parenthesis count\r", "-\t\t\t\t\t// for the current openParenthesisCount\r", "-\t\t\t\t\t// else increase the count for stand alone parenthesis.\r", "-\t\t\t\t\tif (openParenthesisCount > 0)\r", "-\t\t\t\t\t\topenParenthesis[openParenthesisCount - 1]++;\r", "-\t\t\t\t\telse\r", "-\t\t\t\t\t\topenParenthesis[0]++;\r", "+     // Decrease the parenthesis count\r", "+     // if there is no more unclosed parenthesis,\r", "+     // a new line and indent may be append (depending on the next token).\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameRPAREN :\r", "+     if ((openParenthesisCount > 1)\r", "+      && (openParenthesis[openParenthesisCount - 1] > 0)) {\r", "+      openParenthesis[openParenthesisCount - 1]--;\r", "+      if (openParenthesis[openParenthesisCount - 1] <= 0) {\r", "+       pendingNewlineAfterParen = true;\r", "+       inAssignment = false;\r", "+       openParenthesisCount--;\r", "-\t\t\t\t\t// Decrease the parenthesis count\r", "-\t\t\t\t\t// if there is no more unclosed parenthesis,\r", "-\t\t\t\t\t// a new line and indent may be append (depending on the next token).\r", "+      }\r", "+     } else {\r", "+      openParenthesis[0]--;\r", "+     }\r", "-\t\t\t\t\tif ((openParenthesisCount > 1)\r", "-\t\t\t\t\t\t&& (openParenthesis[openParenthesisCount - 1] > 0)) {\r", "-\t\t\t\t\t\topenParenthesis[openParenthesisCount - 1]--;\r", "-\t\t\t\t\t\tif (openParenthesis[openParenthesisCount - 1] <= 0) {\r", "-\t\t\t\t\t\t\tpendingNewlineAfterParen = true;\r", "-\t\t\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\t\t\topenParenthesisCount--;\r", "-\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\topenParenthesis[0]--;\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameLBRACE :\r", "-\t\t\t\t\tif ((previousCompilableToken == TokenNameRBRACKET) || (previousCompilableToken == TokenNameEQUAL)) {\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameLBRACE :\r", "+     if ((previousCompilableToken == TokenNameRBRACKET) || (previousCompilableToken == TokenNameEQUAL)) {\r", "-\t\t\t\t\t\tinArrayAssignment = true;\r", "-\t\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (inArrayAssignment) {\r", "-\t\t\t\t\t\tindentationLevel += pushBlock();\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t// Add new line and increase indentation level after open brace.\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tindentationLevel += pushBlock();\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameRBRACE :\r", "-\t\t\t\t\tif (previousCompilableToken == TokenNameRPAREN) {\r", "-\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (inArrayAssignment) {\r", "-\t\t\t\t\t\tinArrayAssignment = false;\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntilBlock();\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntilBlock();\r", "+      inArrayAssignment = true;\r", "+      inAssignment = false;\r", "+     }\r", "+     if (inArrayAssignment) {\r", "+      indentationLevel += pushBlock();\r", "+     } else {\r", "+      // Add new line and increase indentation level after open brace.\r", "+      pendingNewLines = 1;\r", "+      indentationLevel += pushBlock();\r", "+     }\r", "+     break;\r", "+    case TokenNameRBRACE :\r", "+     if (previousCompilableToken == TokenNameRPAREN) {\r", "+      pendingSpace = false;\r", "+     }\r", "+     if (inArrayAssignment) {\r", "+      inArrayAssignment = false;\r", "+      pendingNewLines = 1;\r", "+      indentationLevel += popInclusiveUntilBlock();\r", "+     } else {\r", "+      pendingNewLines = 1;\r", "+      indentationLevel += popInclusiveUntilBlock();\r", "-\t\t\t\t\t\tif (previousCompilableToken == TokenNameRPAREN){\r", "-\t\t\t\t\t\t\t// fix for 1FGDDV6: LFCOM:WIN98 - Weird splitting on message expression\r", "-\t\t\t\t\t\t\tcurrentLineBuffer.append(options.lineSeparatorSequence);\r", "-\t\t\t\t\t\t\tincreaseLineDelta(options.lineSeparatorSequence.length);                            \r", "-\t\t\t\t\t\t}\r", "+      if (previousCompilableToken == TokenNameRPAREN){\r", "+       // fix for 1FGDDV6: LFCOM:WIN98 - Weird splitting on message expression\r", "+       currentLineBuffer.append(options.lineSeparatorSequence);\r", "+       increaseLineDelta(options.lineSeparatorSequence.length);                            \r", "+      }\r", "-\t\t\t\t\t\tif (constructionsCount > 0) {\r", "-\t\t\t\t\t\t\tswitch (constructions[constructionsCount - 1]) {\r", "-\t\t\t\t\t\t\t\tcase TokenNamefor :\r", "-\t\t\t\t\t\t\t\t\t//indentationLevel += popExclusiveUntilBlock();\r", "-\t\t\t\t\t\t\t\t\t//break;\r", "-\t\t\t\t\t\t\t\tcase TokenNameswitch :\r", "-\t\t\t\t\t\t\t\tcase TokenNameif :\r", "-\t\t\t\t\t\t\t\tcase TokenNameelse :\r", "-\t\t\t\t\t\t\t\tcase TokenNametry :\r", "-\t\t\t\t\t\t\t\tcase TokenNamecatch :\r", "-\t\t\t\t\t\t\t\tcase TokenNamefinally :\r", "-\t\t\t\t\t\t\t\tcase TokenNamewhile :\r", "-\t\t\t\t\t\t\t\tcase TokenNamedo :\r", "-\t\t\t\t\t\t\t\t\tclearNonBlockIndents = true;\r", "-\t\t\t\t\t\t\t\tdefault :\r", "-\t\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "+      if (constructionsCount > 0) {\r", "+       switch (constructions[constructionsCount - 1]) {\r", "+        case TokenNamefor :\r", "+         //indentationLevel += popExclusiveUntilBlock();\r", "+         //break;\r", "+        case TokenNameswitch :\r", "+        case TokenNameif :\r", "+        case TokenNameelse :\r", "+        case TokenNametry :\r", "+        case TokenNamecatch :\r", "+        case TokenNamefinally :\r", "+        case TokenNamewhile :\r", "+        case TokenNamedo :\r", "+         clearNonBlockIndents = true;\r", "+        default :\r", "+         break;\r", "+       }\r", "+      }\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameLBRACKET :\r", "-\t\t\t\t\topenBracketCount++;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameRBRACKET :\r", "-\t\t\t\t\topenBracketCount-=(openBracketCount>0)?1:0;\r", "-\t\t\t\t\t// if there is no left bracket to close, the right bracket is ignored.\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameCOMMA :\r", "-\t\t\t\tcase TokenNameDOT :\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameSEMICOLON :\r", "+     }\r", "+     break;\r", "+    case TokenNameLBRACKET :\r", "+     openBracketCount++;\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameRBRACKET :\r", "+     openBracketCount-=(openBracketCount>0)?1:0;\r", "+     // if there is no left bracket to close, the right bracket is ignored.\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameCOMMA :\r", "+    case TokenNameDOT :\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameSEMICOLON :\r", "-\t\t\t\t\t// Do not generate line terminators in the definition of\r", "-\t\t\t\t\t// the for statement.\r", "-\t\t\t\t\t// if not in this case, jump a line and reduce indentation after the brace\r", "-\t\t\t\t\t// if the block it closes belongs to a conditional statement (if, while, do...).\r", "+     // Do not generate line terminators in the definition of\r", "+     // the for statement.\r", "+     // if not in this case, jump a line and reduce indentation after the brace\r", "+     // if the block it closes belongs to a conditional statement (if, while, do...).\r", "-\t\t\t\t\tif (openParenthesisCount <= 1) {\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tif (expectingOpenBrace) {\r", "-\t\t\t\t\t\t\tclearNonBlockIndents = true;\r", "-\t\t\t\t\t\t\texpectingOpenBrace = false;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamePLUS_PLUS :\r", "-\t\t\t\tcase TokenNameMINUS_MINUS :\r", "+     if (openParenthesisCount <= 1) {\r", "+      pendingNewLines = 1;\r", "+      if (expectingOpenBrace) {\r", "+       clearNonBlockIndents = true;\r", "+       expectingOpenBrace = false;\r", "+      }\r", "+     }\r", "+     inAssignment = false;\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNamePLUS_PLUS :\r", "+    case TokenNameMINUS_MINUS :\r", "-\t\t\t\t\t// Do not put a space between a post-increment/decrement\r", "-\t\t\t\t\t// and the identifier being modified.\r", "+     // Do not put a space between a post-increment/decrement\r", "+     // and the identifier being modified.\r", "-\t\t\t\t\tif (previousToken == TokenNameIdentifier\r", "-\t\t\t\t\t\t|| previousToken == TokenNameRBRACKET) {\r", "-\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamePLUS : // previously ADDITION\r", "-\t\t\t\tcase TokenNameMINUS :\r", "+     if (previousToken == TokenNameIdentifier\r", "+      || previousToken == TokenNameRBRACKET) {\r", "+      pendingSpace = false;\r", "+     }\r", "+     break;\r", "+    case TokenNamePLUS : // previously ADDITION\r", "+    case TokenNameMINUS :\r", "-\t\t\t\t\t// Handle the unary operators plus and minus via a 3-state flag.\r", "+     // Handle the unary operators plus and minus via a flag\r", "-\t\t\t\t\tif (!isLiteralToken(previousToken)\r", "-\t\t\t\t\t\t&& previousToken != TokenNameIdentifier\r", "-\t\t\t\t\t\t&& previousToken != TokenNameRPAREN\r", "-\t\t\t\t\t\t&& previousToken != TokenNameRBRACKET) {\r", "-\t\t\t\t\t\tunarySignModifier = 2;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameCOLON :\r", "+     if (!isLiteralToken(previousToken)\r", "+      && previousToken != TokenNameIdentifier\r", "+      && previousToken != TokenNameRPAREN\r", "+      && previousToken != TokenNameRBRACKET) {\r", "+      unarySignModifier = 1;\r", "+     }\r", "+     break;\r", "+    case TokenNameCOLON :\r", "+     // In a switch/case statement, add a newline & indent\r", "+     // when a colon is encountered.\r", "+     if (tokenBeforeColonCount > 0) {\r", "+      if (tokenBeforeColon[tokenBeforeColonCount - 1] == TokenNamecase) {\r", "+       pendingNewLines = 1;\r", "+      }\r", "+      tokenBeforeColonCount--;\r", "+     }\r", "+     break;\r", "+    case TokenNameEQUAL :\r", "+     inAssignment = true;\r", "+     break;\r", "+    case Scanner.TokenNameCOMMENT_LINE :\r", "+     pendingNewLines = 1;\r", "+     if (inAssignment) {\r", "+      currentLineIndentationLevel++;\r", "+     }\r", "+     break; // a line is always inserted after a one-line comment\r", "+    case Scanner.TokenNameCOMMENT_JAVADOC :\r", "+    case Scanner.TokenNameCOMMENT_BLOCK :\r", "+     currentCommentOffset = getCurrentCommentOffset();\r", "+     if (openParenthesis[0]==0 && openBracketCount < 1){\r", "+      pendingNewLines = 1;\r", "+      // a new line is inserted only if the comment is not between parenthesis.\r", "+     }\r", "+     break;\r", "+    case Scanner.TokenNameWHITESPACE :\r", "-\t\t\t\t\t// In a switch/case statement, add a newline & indent\r", "-\t\t\t\t\t// when a colon is encountered.\r", "-\t\t\t\t\tif (tokenBeforeColonCount > 0) {\r", "-\t\t\t\t\t\tif (tokenBeforeColon[tokenBeforeColonCount - 1] == TokenNamecase) {\r", "-\t\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\ttokenBeforeColonCount--;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameEQUAL :\r", "-\t\t\t\t\tinAssignment = true;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase Scanner.TokenNameCOMMENT_LINE :\r", "-\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\tif (inAssignment) {\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel++;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak; // a line is always inserted after a one-line comment\r", "-\t\t\t\tcase Scanner.TokenNameCOMMENT_JAVADOC :\r", "-\t\t\t\tcase Scanner.TokenNameCOMMENT_BLOCK :\r", "-\t\t\t\t\tcurrentCommentOffset = getCurrentCommentOffset();\r", "-\t\t\t\t\tif (openParenthesis[0]==0 && openBracketCount < 1){\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\t// a new line is inserted only if the comment is not between parenthesis.\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase Scanner.TokenNameWHITESPACE :\r", "+     // Count the number of line terminators in the whitespace so\r", "+     // line spacing can be preserved near comments.\r", "-\t\t\t\t\t// Count the number of line terminators in the whitespace so\r", "-\t\t\t\t\t// line spacing can be preserved near comments.\r", "+     char[] source = scanner.source;\r", "+     newLinesInWhitespace = 0;\r", "+     for (\r", "+      int i = scanner.startPosition, max = scanner.currentPosition; \r", "+      i < max; \r", "+      i++) {\r", "+      if (source[i] == '\\n') {\r", "+       newLinesInWhitespace++;\r", "+      }\r", "+     }\r", "+     increaseLineDelta(scanner.startPosition - scanner.currentPosition);\r", "+     break;\r", "+    default :\r", "+     if ((token == TokenNameIdentifier)\r", "+      || isLiteralToken(token)\r", "+      || token == TokenNamesuper\r", "+      || token == TokenNamethis) {\r", "-\t\t\t\t\tchar[] source = scanner.source;\r", "-\t\t\t\t\tnewLinesInWhitespace = 0;\r", "-\t\t\t\t\tfor (\r", "-\t\t\t\t\t\tint i = scanner.startPosition, max = scanner.currentPosition; \r", "-\t\t\t\t\t\ti < max; \r", "-\t\t\t\t\t\ti++) {\r", "-\t\t\t\t\t\tif (source[i] == '\\n') {\r", "-\t\t\t\t\t\t\tnewLinesInWhitespace++;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tincreaseLineDelta(scanner.startPosition - scanner.currentPosition);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tdefault :\r", "-\t\t\t\t\tif ((token == TokenNameIdentifier)\r", "-\t\t\t\t\t\t|| isLiteralToken(token)\r", "-\t\t\t\t\t\t|| token == TokenNamesuper\r", "-\t\t\t\t\t\t|| token == TokenNamethis) {\r", "+      // Do not put a space between a unary operator\r", "+      // (eg: ++, --, +, -) and the identifier being modified.\r", "+      if (previousToken == TokenNamePLUS_PLUS\r", "+       || previousToken == TokenNameMINUS_MINUS\r", "+       || (previousToken == TokenNamePLUS && unarySignModifier > 0)\r", "+       || (previousToken == TokenNameMINUS && unarySignModifier > 0)) {\r", "+       pendingSpace = false;\r", "+      }\r", "+      unarySignModifier = 0;\r", "+     }\r", "+     break;\r", "+   }\r", "-\t\t\t\t\t\t// Do not put a space between a unary operator\r", "-\t\t\t\t\t\t// (eg: ++, --, +, -) and the identifier being modified.\r", "+   // Do not output whitespace tokens.\r", "-\t\t\t\t\t\tunarySignModifier -= (unarySignModifier > 0) ? 1 : 0;\r", "-\t\t\t\t\t\tif (previousToken == TokenNamePLUS_PLUS\r", "-\t\t\t\t\t\t\t|| previousToken == TokenNameMINUS_MINUS\r", "-\t\t\t\t\t\t\t|| (unarySignModifier > 0)) {\r", "-\t\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t}\r", "+   if (token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t// Do not output whitespace tokens.\r", "+    /* Add pending space to the formatted source string.\r", "+    Do not output a space under the following circumstances:\r", "+    1) this is the first pass\r", "+    2) previous token is an open paren\r", "+    3) previous token is a period\r", "+    4) previous token is the logical compliment (eg: !)\r", "+    5) previous token is the bitwise compliment (eg: ~)\r", "+    6) previous token is the open bracket (eg: [)\r", "+    7) in an assignment statement, if the previous token is an \r", "+    open brace or the current token is a close brace\r", "+    8) previous token is a single line comment\r", "+    */\r", "-\t\t\tif (token != Scanner.TokenNameWHITESPACE) {\r", "+    boolean openAndCloseBrace = previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE;\r", "-\t\t\t\t/* Add pending space to the formatted source string.\r", "-\t\t\t\tDo not output a space under the following circumstances:\r", "-\t\t\t\t1) this is the first pass\r", "-\t\t\t\t2) previous token is an open paren\r", "-\t\t\t\t3) previous token is a period\r", "-\t\t\t\t4) previous token is the logical compliment (eg: !)\r", "-\t\t\t\t5) previous token is the bitwise compliment (eg: ~)\r", "-\t\t\t\t6) previous token is the open bracket (eg: [)\r", "-\t\t\t\t7) in an assignment statement, if the previous token is an \r", "-\t\t\t\topen brace or the current token is a close brace\r", "-\t\t\t\t8) previous token is a single line comment\r", "-\t\t\t\t*/\r", "+    // to be replaced by a nicer condition.\r", "+   \r", "+    if (pendingSpace\r", "+     && insertSpaceAfter(previousToken)\r", "+     && ! (inAssignment\r", "+      && (previousToken == TokenNameLBRACE || token == TokenNameRBRACE))\r", "+     && previousToken != Scanner.TokenNameCOMMENT_LINE) {\r", "+     if ((! (options.compactAssignmentMode && token == TokenNameEQUAL)) && !openAndCloseBrace)\r", "+      space();\r", "+    }\r", "-\t\t\t\tboolean openAndCloseBrace = previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE;\r", "+    // Add the next token to the formatted source string.\r", "-\t\t\t\t// to be replaced by a nicer condition.\r", "-\t\t\t\r", "-\t\t\t\tif (pendingSpace\r", "-\t\t\t\t\t&& insertSpaceAfter(previousToken)\r", "-\t\t\t\t\t&& ! (inAssignment\r", "-\t\t\t\t\t\t&& (previousToken == TokenNameLBRACE || token == TokenNameRBRACE))\r", "-\t\t\t\t\t&& previousToken != Scanner.TokenNameCOMMENT_LINE) {\r", "-\t\t\t\t\tif ((! (options.compactAssignmentMode && token == TokenNameEQUAL)) && !openAndCloseBrace)\r", "-\t\t\t\t\t\tspace();\r", "-\t\t\t\t}\r", "+    outputCurrentToken(token);\r", "+    if (token == Scanner.TokenNameCOMMENT_LINE && openParenthesisCount > 1){\r", "+     pendingNewLines = 0;\r", "+     currentLineBuffer.append(options.lineSeparatorSequence);\r", "+     increaseLineDelta(options.lineSeparatorSequence.length);                    \r", "+    }\r", "+    pendingSpace = true;\r", "+   }\r", "-\t\t\t\t// Add the next token to the formatted source string.\r", "+   // Whitespace tokens do not need to be remembered.\r", "-\t\t\t\toutputCurrentToken(token);\r", "-\t\t\t\tif (token == Scanner.TokenNameCOMMENT_LINE && openParenthesisCount > 1){\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tcurrentLineBuffer.append(options.lineSeparatorSequence);\r", "-\t\t\t\t\tincreaseLineDelta(options.lineSeparatorSequence.length);                    \r", "-\t\t\t\t}\r", "-\t\t\t\tpendingSpace = true;\r", "-\t\t\t}\r", "+   if (token != Scanner.TokenNameWHITESPACE) {\r", "+    previousToken = token;\r", "+    if (token != Scanner.TokenNameCOMMENT_BLOCK\r", "+     && token != Scanner.TokenNameCOMMENT_LINE\r", "+     && token != Scanner.TokenNameCOMMENT_JAVADOC) {\r", "+     previousCompilableToken = token;\r", "+    }\r", "+   }\r", "-\t\t\t// Whitespace tokens do not need to be remembered.\r", "-\r", "-\t\t\tif (token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t\tpreviousToken = token;\r", "-\t\t\t\tif (token != Scanner.TokenNameCOMMENT_BLOCK\r", "-\t\t\t\t\t&& token != Scanner.TokenNameCOMMENT_LINE\r", "-\t\t\t\t\t&& token != Scanner.TokenNameCOMMENT_JAVADOC) {\r", "-\t\t\t\t\tpreviousCompilableToken = token;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t}\r", "-\t\toutput(copyRemainingSource());\r", "-\t\tflushBuffer(); // dump the last token of the source in the formatted output.\r", "-\t} catch (InvalidInputException e) {\r", "-\t\toutput(copyRemainingSource());\r", "-\t\tflushBuffer(); // dump the last token of the source in the formatted output.\r", "-\t}\r", "+  }\r", "+  output(copyRemainingSource());\r", "+  flushBuffer(); // dump the last token of the source in the formatted output.\r", "+ } catch (InvalidInputException e) {\r", "+  output(copyRemainingSource());\r", "+  flushBuffer(); // dump the last token of the source in the formatted output.\r", "+ }\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b4d15876f4f92b69663654b756b076e5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatter.java", "commitBeforeChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "commitAfterChange": "44855522f87e615f1ca0bfcda268b074e4443dfe", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r private void format()", "signatureAfterChange": "\r private void format()", "diff": ["-\tint token = 0;\r", "-\tint previousToken = 0;\r", "-\tint previousCompilableToken = 0;\r", "+ int token = 0;\r", "+ int previousToken = 0;\r", "+ int previousCompilableToken = 0;\r", "-\tint indentationOffset = 0;\r", "+ int indentationOffset = 0;\r", "-\tint newLinesInWhitespace = 0;\r", "-\t// number of new lines in the previous whitespace token\r", "-\t// (used to leave blank lines before comments)\r", "-\tint pendingNewLines = 0;\r", "-\tboolean expectingOpenBrace = false;\r", "-\tboolean clearNonBlockIndents = false;\r", "-\t// true if all indentations till the 1st { (usefull after } or ;)\r", "-\tboolean pendingSpace = true;\r", "-\tboolean pendingNewlineAfterParen = false;\r", "-\t// true when a cr is to be put after a ) (in conditional statements)\r", "-\tboolean inAssignment = false;\r", "-\tboolean inArrayAssignment = false;\r", "-\tboolean inThrowsClause = false;\r", "-\tboolean inClassOrInterfaceHeader = false;\r", "+ int newLinesInWhitespace = 0;\r", "+ // number of new lines in the previous whitespace token\r", "+ // (used to leave blank lines before comments)\r", "+ int pendingNewLines = 0;\r", "+ boolean expectingOpenBrace = false;\r", "+ boolean clearNonBlockIndents = false;\r", "+ // true if all indentations till the 1st { (usefull after } or ;)\r", "+ boolean pendingSpace = true;\r", "+ boolean pendingNewlineAfterParen = false;\r", "+ // true when a cr is to be put after a ) (in conditional statements)\r", "+ boolean inAssignment = false;\r", "+ boolean inArrayAssignment = false;\r", "+ boolean inThrowsClause = false;\r", "+ boolean inClassOrInterfaceHeader = false;\r", "-\t// openBracketCount is used to count the number of open brackets not closed yet.\r", "-\tint openBracketCount = 0;\r", "-\t\r", "-\tint unarySignModifier = 0;\r", "+ // openBracketCount is used to count the number of open brackets not closed yet.\r", "+ int openBracketCount = 0;\r", "+ \r", "+  int unarySignModifier = 0;\r", "-\t// openParenthesis[0] is used to count the parenthesis not belonging to a condition\r", "-\t// (eg foo();). parenthesis in for (...) are count elsewhere in the array.\r", "-\tint openParenthesisCount = 1;\r", "-\tint[] openParenthesis = new int[10];\r", "+ // openParenthesis[0] is used to count the parenthesis not belonging to a condition\r", "+ // (eg foo();). parenthesis in for (...) are count elsewhere in the array.\r", "+ int openParenthesisCount = 1;\r", "+ int[] openParenthesis = new int[10];\r", "-\t// tokenBeforeColon is used to know what token goes along with the current :\r", "-\t// it can be case or ?\r", "-\tint tokenBeforeColonCount = 0;\r", "-\tint[] tokenBeforeColon = new int[10];\r", "+ // tokenBeforeColon is used to know what token goes along with the current :\r", "+ // it can be case or ?\r", "+ int tokenBeforeColonCount = 0;\r", "+ int[] tokenBeforeColon = new int[10];\r", "-\tconstructionsCount = 0; // initializes the constructions count.\r", "+ constructionsCount = 0; // initializes the constructions count.\r", "-\t// contains DO if in a DO..WHILE statement, UNITIALIZED otherwise.\r", "-\tint nlicsToken = 0;\r", "+ // contains DO if in a DO..WHILE statement, UNITIALIZED otherwise.\r", "+ int nlicsToken = 0;\r", "-\t// fix for 1FF17XY: LFCOM:ALL - Format problem on not matching } and else \r", "-\tboolean specialElse = false;\r", "+ // fix for 1FF17XY: LFCOM:ALL - Format problem on not matching } and else \r", "+ boolean specialElse = false;\r", "-\t// OPTION (IndentationLevel): initial indentation level may be non-zero.\r", "-\tcurrentLineIndentationLevel += constructionsCount;\r", "+ // OPTION (IndentationLevel): initial indentation level may be non-zero.\r", "+ currentLineIndentationLevel += constructionsCount;\r", "-\t\r", "-\t// An InvalidInputException exception might cause the termination of this loop.\r", "-\ttry {\r", "-\t\twhile (true) {\r", "-\t\t\t// Get the next token.  Catch invalid input and output it\r", "-\t\t\t// with minimal formatting, also catch end of input and\r", "-\t\t\t// exit the loop.\r", "-\t\t\ttry {\r", "-\t\t\t\ttoken = scanner.getNextToken();\r", "-\t\t\t} catch (InvalidInputException e) {\r", "-\t\t\t\tif (!handleInvalidToken(e)) {\r", "-\t\t\t\t\tthrow e;\r", "-\t\t\t\t}\r", "-\t\t\t\ttoken = 0;\r", "-\t\t\t}\r", "-\t\t\tif (token == Scanner.TokenNameEOF)\r", "-\t\t\t\tbreak;\r", "+ \r", "+ // An InvalidInputException exception might cause the termination of this loop.\r", "+ try {\r", "+  while (true) {\r", "+   // Get the next token.  Catch invalid input and output it\r", "+   // with minimal formatting, also catch end of input and\r", "+   // exit the loop.\r", "+   try {\r", "+    token = scanner.getNextToken();\r", "+   } catch (InvalidInputException e) {\r", "+    if (!handleInvalidToken(e)) {\r", "+     throw e;\r", "+    }\r", "+    token = 0;\r", "+   }\r", "+   if (token == Scanner.TokenNameEOF)\r", "+    break;\r", "-\t\t\t/* ## MODIFYING the indentation level before generating new lines\r", "-\t\t\tand indentation in the output string\r", "-\t\t\t*/\r", "+   /* ## MODIFYING the indentation level before generating new lines\r", "+   and indentation in the output string\r", "+   */\r", "-\t\t\t// Removes all the indentations made by statements not followed by a block\r", "-\t\t\t// except if the current token is ELSE, CATCH or if we are in a switch/case\r", "+   // Removes all the indentations made by statements not followed by a block\r", "+   // except if the current token is ELSE, CATCH or if we are in a switch/case\r", "-\t\t\tif (clearNonBlockIndents && (token != Scanner.TokenNameWHITESPACE)) {\r", "+   if (clearNonBlockIndents && (token != Scanner.TokenNameWHITESPACE)) {\r", "-\t\t\t\tswitch (token) {\r", "-\t\t\t\t\tcase TokenNameelse :\r", "-\t\t\t\t\t\tif (constructionsCount > 0 && constructions[constructionsCount-1] == TokenNameelse){\r", "-\t\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\t\tspecialElse = true;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNameif);\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase TokenNamecatch :\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNamecatch);\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase TokenNamefinally :\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNamecatch);\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase TokenNamewhile :\r", "-\t\t\t\t\t\tif (nlicsToken == TokenNamedo) {\r", "-\t\t\t\t\t\t\tindentationLevel += pop(TokenNamedo);\r", "-\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\tdefault :\r", "-\t\t\t\t\t\tindentationLevel += popExclusiveUntilBlockOrCase();\r", "-\t\t\t\t\t\t// clear until a CASE, DEFAULT or BLOCK is encountered.\r", "-\t\t\t\t\t\t// Thus, the indentationLevel is correctly cleared either\r", "-\t\t\t\t\t\t// in a switch/case statement or in any other situation.\r", "-\t\t\t\t}\r", "-\t\t\t\tclearNonBlockIndents = false;\r", "-\t\t\t}\r", "+    switch (token) {\r", "+     case TokenNameelse :\r", "+      if (constructionsCount > 0 && constructions[constructionsCount-1] == TokenNameelse){\r", "+       pendingNewLines = 1;\r", "+       specialElse = true;\r", "+      }\r", "+      indentationLevel += popInclusiveUntil(TokenNameif);\r", "+      break;\r", "+     case TokenNamecatch :\r", "+      indentationLevel += popInclusiveUntil(TokenNamecatch);\r", "+      break;\r", "+     case TokenNamefinally :\r", "+      indentationLevel += popInclusiveUntil(TokenNamecatch);\r", "+      break;\r", "+     case TokenNamewhile :\r", "+      if (nlicsToken == TokenNamedo) {\r", "+       indentationLevel += pop(TokenNamedo);\r", "+       break;\r", "+      }\r", "+     default :\r", "+      indentationLevel += popExclusiveUntilBlockOrCase();\r", "+      // clear until a CASE, DEFAULT or BLOCK is encountered.\r", "+      // Thus, the indentationLevel is correctly cleared either\r", "+      // in a switch/case statement or in any other situation.\r", "+    }\r", "+    clearNonBlockIndents = false;\r", "+   }\r", "-\t\t\t// returns to the indentation level created by the SWITCH keyword\r", "-\t\t\t// if the current token is a CASE or a DEFAULT\r", "+   // returns to the indentation level created by the SWITCH keyword\r", "+   // if the current token is a CASE or a DEFAULT\r", "-\t\t\tif (token == TokenNamecase || token == TokenNamedefault) {\r", "-\t\t\t\tindentationLevel += pop(TokenNamecase);\r", "-\t\t\t}\r", "+   if (token == TokenNamecase || token == TokenNamedefault) {\r", "+    indentationLevel += pop(TokenNamecase);\r", "+   }\r", "-\t\t\tif (token == Scanner.TokenNamethrows) {\r", "-\t\t\t\tinThrowsClause = true;\r", "-\t\t\t}\r", "+   if (token == Scanner.TokenNamethrows) {\r", "+    inThrowsClause = true;\r", "+   }\r", "-\t\t\tif (token == Scanner.TokenNameclass || token == Scanner.TokenNameinterface) {\r", "-\t\t\t\tinClassOrInterfaceHeader = true;\r", "-\t\t\t}\r", "-\t\t\t/* ## APPEND newlines and indentations to the output string\r", "-\t\t\t*/\r", "+   if (token == Scanner.TokenNameclass || token == Scanner.TokenNameinterface) {\r", "+    inClassOrInterfaceHeader = true;\r", "+   }\r", "+   /* ## APPEND newlines and indentations to the output string\r", "+   */\r", "-\t\t\t// Do not add a new line between ELSE and IF, if the option elseIfOnSameLine is true.\r", "-\t\t\t// Fix for 1ETLWPZ: IVJCOM:ALL - incorrect \"else if\" formatting\r", "-\t\t\tif (pendingNewlineAfterParen && previousCompilableToken == TokenNameelse && token == TokenNameif && options.compactElseIfMode){\r", "-\t\t\t\tpendingNewlineAfterParen = false;\r", "-\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\tindentationLevel += pop(TokenNameelse);\r", "-\t\t\t\t// because else if is now one single statement,\r", "-\t\t\t\t// the indentation level after it is increased by one and not by 2\r", "-\t\t\t\t// (else = 1 indent, if = 1 indent, but else if = 1 indent, not 2).\r", "-\t\t\t}\r", "-\t\t\t\r", "-\t\t\t// Add a newline & indent to the formatted source string if\r", "-\t\t\t// a for/if-else/while statement was scanned and there is no block\r", "-\t\t\t// following it.\r", "-\t\t\t\r", "-\t\t\tpendingNewlineAfterParen = pendingNewlineAfterParen || (previousCompilableToken == TokenNameRPAREN && token == TokenNameLBRACE);\r", "-\t\t\tif (pendingNewlineAfterParen && token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t\tpendingNewlineAfterParen = false;\r", "+   // Do not add a new line between ELSE and IF, if the option elseIfOnSameLine is true.\r", "+   // Fix for 1ETLWPZ: IVJCOM:ALL - incorrect \"else if\" formatting\r", "+   if (pendingNewlineAfterParen && previousCompilableToken == TokenNameelse && token == TokenNameif && options.compactElseIfMode){\r", "+    pendingNewlineAfterParen = false;\r", "+    pendingNewLines = 0;\r", "+    indentationLevel += pop(TokenNameelse);\r", "+    // because else if is now one single statement,\r", "+    // the indentation level after it is increased by one and not by 2\r", "+    // (else = 1 indent, if = 1 indent, but else if = 1 indent, not 2).\r", "+   }\r", "+   \r", "+   // Add a newline & indent to the formatted source string if\r", "+   // a for/if-else/while statement was scanned and there is no block\r", "+   // following it.\r", "+   \r", "+   pendingNewlineAfterParen = pendingNewlineAfterParen || (previousCompilableToken == TokenNameRPAREN && token == TokenNameLBRACE);\r", "+   if (pendingNewlineAfterParen && token != Scanner.TokenNameWHITESPACE) {\r", "+    pendingNewlineAfterParen = false;\r", "-\t\t\t\t// Do to add a newline & indent sequence if the current token is an\r", "-\t\t\t\t// open brace or a period or if the current token is a semi-colon and the\r", "-\t\t\t\t// previous token is a close paren.\r", "-\t\t\t\t// add a new line if a parenthesis belonging to a for() statement\r", "-\t\t\t\t// has been closed and the current token is not an opening brace\r", "+    // Do to add a newline & indent sequence if the current token is an\r", "+    // open brace or a period or if the current token is a semi-colon and the\r", "+    // previous token is a close paren.\r", "+    // add a new line if a parenthesis belonging to a for() statement\r", "+    // has been closed and the current token is not an opening brace\r", "-\t\t\t\tif (token != TokenNameLBRACE && !isComment(token)\r", "-\t\t\t\t// to avoid adding new line between else and a comment\r", "-\t\t\t\t\t\t&& token != TokenNameDOT\r", "-\t\t\t\t\t\t&& ! (previousCompilableToken == TokenNameRPAREN\r", "-\t\t\t\t\t\t\t&& token == TokenNameSEMICOLON)) {\r", "-\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\tcurrentLineIndentationLevel += indentationLevel;\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tif (token == TokenNameLBRACE && options.newLineBeforeOpeningBraceMode) {\r", "-\t\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "-\t\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "+    if (token != TokenNameLBRACE && !isComment(token)\r", "+    // to avoid adding new line between else and a comment\r", "+      && token != TokenNameDOT\r", "+      && ! (previousCompilableToken == TokenNameRPAREN\r", "+       && token == TokenNameSEMICOLON)) {\r", "+     newLine(1);\r", "+     currentLineIndentationLevel = indentationLevel;\r", "+     pendingNewLines = 0;\r", "+     pendingSpace = false;\r", "+    } else {\r", "+     if (token == TokenNameLBRACE && options.newLineBeforeOpeningBraceMode) {\r", "+      newLine(1);\r", "+      if (constructionsCount > 0\r", "+       && constructions[constructionsCount - 1] != BLOCK\r", "+       && constructions[constructionsCount - 1] != NONINDENT_BLOCK) {\r", "+       currentLineIndentationLevel = indentationLevel - 1;\r", "+      } else {\r", "+       currentLineIndentationLevel = indentationLevel;\r", "+      }\r", "+      pendingNewLines = 0;\r", "+      pendingSpace = false;\r", "+     }\r", "+    }\r", "+   }\r", "-\t\t\t// see PR 1G5G8EC\r", "-\t\t\tif (token == TokenNameLBRACE && inThrowsClause) {\r", "-\t\t\t\tinThrowsClause = false;      \r", "-\t\t\t\tif (options.newLineBeforeOpeningBraceMode) {\r", "-\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\t\r", "-\t\t\t// see PR 1G5G82G\r", "-\t\t\tif (token == TokenNameLBRACE && inClassOrInterfaceHeader) {\r", "-\t\t\t\tinClassOrInterfaceHeader = false;\r", "-\t\t\t\tif (options.newLineBeforeOpeningBraceMode) {\r", "-\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t}\r", "-\t\t\t}            \r", "-\t\t\t// Add pending new lines to the formatted source string.\r", "-\t\t\t// Note: pending new lines are not added if the current token\r", "-\t\t\t// is a single line comment or whitespace.\r", "-\t\t\t// if the comment is between parenthesis, there is no blank line preservation\r", "-\t\t\t// (if it's a one-line comment, a blank line is added after it).\r", "+   if (token == TokenNameLBRACE\r", "+    && options.newLineBeforeOpeningBraceMode\r", "+    && constructionsCount > 0\r", "+    && constructions[constructionsCount - 1] == TokenNamedo) {\r", "+    newLine(1);\r", "+    currentLineIndentationLevel = indentationLevel - 1;\r", "+    pendingNewLines = 0;\r", "+    pendingSpace = false;\r", "+   }\r", "-\t\t\tif (((pendingNewLines > 0 && (!isComment(token)))\r", "-\t\t\t\t\t|| (newLinesInWhitespace > 0\r", "-\t\t\t\t\t\t\t&& (openParenthesisCount <= 1 && isComment(token)))\r", "-\t\t\t\t\t|| (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE))\r", "-\t\t\t\t&& token != Scanner.TokenNameWHITESPACE) {\r", "+   // see PR 1G5G8EC\r", "+   if (token == TokenNameLBRACE && inThrowsClause) {\r", "+    inThrowsClause = false;      \r", "+    if (options.newLineBeforeOpeningBraceMode) {\r", "+     newLine(1);\r", "+     currentLineIndentationLevel = indentationLevel;\r", "+     pendingNewLines = 0;\r", "+     pendingSpace = false;\r", "+    }\r", "+   }\r", "+   \r", "+   // see PR 1G5G82G\r", "+   if (token == TokenNameLBRACE && inClassOrInterfaceHeader) {\r", "+    inClassOrInterfaceHeader = false;\r", "+    if (options.newLineBeforeOpeningBraceMode) {\r", "+     newLine(1);\r", "+     currentLineIndentationLevel = indentationLevel;\r", "+     pendingNewLines = 0;\r", "+     pendingSpace = false;\r", "+    }\r", "+   }            \r", "+   // Add pending new lines to the formatted source string.\r", "+   // Note: pending new lines are not added if the current token\r", "+   // is a single line comment or whitespace.\r", "+   // if the comment is between parenthesis, there is no blank line preservation\r", "+   // (if it's a one-line comment, a blank line is added after it).\r", "-\t\t\t\t// Do not add newline & indent between an adjoining close brace and\r", "-\t\t\t\t// close paren.  Anonymous inner classes may use this form.\r", "+   if (((pendingNewLines > 0 && (!isComment(token)))\r", "+     || (newLinesInWhitespace > 0\r", "+       && (openParenthesisCount <= 1 && isComment(token)))\r", "+     || (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE))\r", "+    && token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t\tboolean closeBraceAndCloseParen = \r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameRPAREN; \r", "+    // Do not add newline & indent between an adjoining close brace and\r", "+    // close paren.  Anonymous inner classes may use this form.\r", "-\t\t\t\t// OPTION (NewLineInCompoundStatement): do not add newline & indent\r", "-\t\t\t\t// between close brace and else, (do) while, catch, and finally if\r", "-\t\t\t\t// newlineInCompoundStatement is true.\r", "+    boolean closeBraceAndCloseParen = \r", "+      previousToken == TokenNameRBRACE && token == TokenNameRPAREN; \r", "-\t\t\t\tboolean nlicsOption = \r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE\r", "-\t\t\t\t\t\t\t&& !options.newlineInControlStatementMode\r", "-\t\t\t\t\t\t\t&& (token == TokenNameelse\r", "-\t\t\t\t\t\t\t\t|| (token == TokenNamewhile && nlicsToken == TokenNamedo)\r", "-\t\t\t\t\t\t\t\t|| token == TokenNamecatch\r", "-\t\t\t\t\t\t\t\t|| token == TokenNamefinally);\r", "+    // OPTION (NewLineInCompoundStatement): do not add newline & indent\r", "+    // between close brace and else, (do) while, catch, and finally if\r", "+    // newlineInCompoundStatement is true.\r", "-\t\t\t\t// Do not add a newline & indent between a close brace and semi-colon.\r", "-\t\t\t\tboolean semiColonAndCloseBrace = \r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameSEMICOLON; \r", "+    boolean nlicsOption = \r", "+      previousToken == TokenNameRBRACE\r", "+       && !options.newlineInControlStatementMode\r", "+       && (token == TokenNameelse\r", "+        || (token == TokenNamewhile && nlicsToken == TokenNamedo)\r", "+        || token == TokenNamecatch\r", "+        || token == TokenNamefinally);\r", "-\t\t\t\t// Do not add a new line & indent between a multiline comment and a opening brace\r", "+    // Do not add a newline & indent between a close brace and semi-colon.\r", "-\t\t\t\tboolean commentAndOpenBrace = previousToken == Scanner.TokenNameCOMMENT_BLOCK && token == TokenNameLBRACE;\r", "-\t\t\t\t\r", "-\t\t\t\t// Do not add a newline & indent between a close brace and a colon (in array assignments, for example).\r", "-\t\t\t\t\r", "-\t\t\t\tboolean commaAndCloseBrace =\r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameCOMMA; \r", "+    boolean semiColonAndCloseBrace = \r", "+      previousToken == TokenNameRBRACE && token == TokenNameSEMICOLON; \r", "-\t\t\t\t// Add a newline and indent, if appropriate.\r", "+    // Do not add a new line & indent between a multiline comment and a opening brace\r", "-\t\t\t\tif (specialElse || (!commentAndOpenBrace && !closeBraceAndCloseParen && !nlicsOption && !semiColonAndCloseBrace && !commaAndCloseBrace)) {\r", "-\t\t\t\t\t// if clearAllBlankLinesMode=false, leaves the blank lines\r", "-\t\t\t\t\t// inserted by the user\r", "-\t\t\t\t\t// if clearAllBlankLinesMode=true, removes all of then\r", "-\t\t\t\t\t// and insert only blank lines required by the formatting.\r", "-\t\t\t\t\tif (!options.clearAllBlankLinesMode) {\r", "-\t\t\t\t\t\tpendingNewLines = \r", "-\t\t\t\t\t\t\t\t(pendingNewLines < newLinesInWhitespace)\r", "+    boolean commentAndOpenBrace = previousToken == Scanner.TokenNameCOMMENT_BLOCK && token == TokenNameLBRACE;\r", "+    \r", "+    // Do not add a newline & indent between a close brace and a colon (in array assignments, for example).\r", "+    \r", "+    boolean commaAndCloseBrace =\r", "+      previousToken == TokenNameRBRACE && token == TokenNameCOMMA; \r", "+\r", "+    // Add a newline and indent, if appropriate.\r", "+\r", "+    if (specialElse || (!commentAndOpenBrace && !closeBraceAndCloseParen && !nlicsOption && !semiColonAndCloseBrace && !commaAndCloseBrace)) {\r", "+     // if clearAllBlankLinesMode=false, leaves the blank lines\r", "+     // inserted by the user\r", "+     // if clearAllBlankLinesMode=true, removes all of then\r", "+     // and insert only blank lines required by the formatting.\r", "+     if (!options.clearAllBlankLinesMode) {\r", "+      pendingNewLines = \r", "+        (pendingNewLines < newLinesInWhitespace)\r", "-\t\t\t\t\t\t\t\t\t? newLinesInWhitespace \r", "-\t\t\t\t\t\t\t\t\t: pendingNewLines;\r", "-\t\t\t\t\t\tpendingNewLines = (pendingNewLines > 2) ? 2 : pendingNewLines;\r", "-\t\t\t\t\t}\r", "+         ? newLinesInWhitespace \r", "+         : pendingNewLines;\r", "+      pendingNewLines = (pendingNewLines > 2) ? 2 : pendingNewLines;\r", "+     }\r", "-\t\t\t\t\tif (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE) {\r", "-\t\t\t\t\t\tcontainsOpenCloseBraces = true;\r", "-\t\t\t\t\t\tindentationLevelForOpenCloseBraces = currentLineIndentationLevel;\r", "-\t\t\t\t\t\tif (isComment(previousToken)) {\r", "-\t\t\t\t\t\t\tnewLine(pendingNewLines);\r", "-\t\t\t\t\t\t} else {\r", "+     if (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE) {\r", "+      containsOpenCloseBraces = true;\r", "+      indentationLevelForOpenCloseBraces = currentLineIndentationLevel;\r", "+      if (isComment(previousToken)) {\r", "+       newLine(pendingNewLines);\r", "+      } else {\r", "-\t\t\t\t\t\t\t\t&& constructions[constructionsCount-1] == NONINDENT_BLOCK\r", "-\t\t\t\t\t\t\t\t&& (constructions[constructionsCount-2] == TokenNamefor \r", "-\t\t\t\t\t\t\t\t\t|| constructions[constructionsCount-2] == TokenNamewhile))) {*/\r", "-\t\t\t\t\t\t\tif (options.newLineInEmptyBlockMode) {\r", "-\t\t\t\t\t\t\t\tif (inArrayAssignment) {\r", "-\t\t\t\t\t\t\t\t\tnewLine(1); // array assigment with an empty block\r", "-\t\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t\tnewLine(pendingNewLines);\r", "-\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t}\r", "+        && constructions[constructionsCount-1] == NONINDENT_BLOCK\r", "+        && (constructions[constructionsCount-2] == TokenNamefor \r", "+         || constructions[constructionsCount-2] == TokenNamewhile))) {*/\r", "+       if (options.newLineInEmptyBlockMode) {\r", "+        if (inArrayAssignment) {\r", "+         newLine(1); // array assigment with an empty block\r", "+        } else {\r", "+         newLine(pendingNewLines);\r", "+        }\r", "+       }\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t// see PR 1FKKC3U: LFCOM:WINNT - Format problem with a comment before the ';'\r", "-\t\t\t\t\t\tif (!((previousToken == Scanner.TokenNameCOMMENT_BLOCK || previousToken == Scanner.TokenNameCOMMENT_JAVADOC) && token == TokenNameSEMICOLON)) {\r", "-\t\t\t\t\t\t\tnewLine(pendingNewLines);                       \r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (((previousCompilableToken == TokenNameSEMICOLON)\r", "-\t\t\t\t\t\t\t|| (previousCompilableToken == TokenNameLBRACE)\r", "-\t\t\t\t\t\t\t|| (previousCompilableToken == TokenNameRBRACE)\r", "-\t\t\t\t\t\t\t|| (isComment(previousToken)))\r", "-\t\t\t\t\t\t&& (token == TokenNameRBRACE)) {\r", "-\t\t\t\t\t\tindentationOffset = -1;\r", "-\t\t\t\t\t\tindentationLevel += popExclusiveUntilBlock();\r", "-\t\t\t\t\t}\r", "+      }\r", "+     } else {\r", "+      // see PR 1FKKC3U: LFCOM:WINNT - Format problem with a comment before the ';'\r", "+      if (!((previousToken == Scanner.TokenNameCOMMENT_BLOCK || previousToken == Scanner.TokenNameCOMMENT_JAVADOC) && token == TokenNameSEMICOLON)) {\r", "+       newLine(pendingNewLines);                       \r", "+      }\r", "+     }\r", "+     if (((previousCompilableToken == TokenNameSEMICOLON)\r", "+       || (previousCompilableToken == TokenNameLBRACE)\r", "+       || (previousCompilableToken == TokenNameRBRACE)\r", "+       || (isComment(previousToken)))\r", "+      && (token == TokenNameRBRACE)) {\r", "+      indentationOffset = -1;\r", "+      indentationLevel += popExclusiveUntilBlock();\r", "+     }\r", "-\t\t\t\t\tif (previousToken == Scanner.TokenNameCOMMENT_LINE && inAssignment) {\r", "-\t\t\t\t\t\t// PR 1FI5IPO\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel++;\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel + indentationOffset;\r", "-\t\t\t\t\t}\r", "+     if (previousToken == Scanner.TokenNameCOMMENT_LINE && inAssignment) {\r", "+      // PR 1FI5IPO\r", "+      currentLineIndentationLevel++;\r", "+     } else {\r", "+      currentLineIndentationLevel = indentationLevel + indentationOffset;\r", "+     }\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tindentationOffset = 0;\r", "-\t\t\t\t}\r", "-\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\tnewLinesInWhitespace = 0;\r", "-\t\t\t\tspecialElse = false;\r", "+     pendingSpace = false;\r", "+     indentationOffset = 0;\r", "+    }\r", "+    pendingNewLines = 0;\r", "+    newLinesInWhitespace = 0;\r", "+    specialElse = false;\r", "-\t\t\t\tif (nlicsToken == TokenNamedo && token == TokenNamewhile) {\r", "-\t\t\t\t\tnlicsToken = 0;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "+    if (nlicsToken == TokenNamedo && token == TokenNamewhile) {\r", "+     nlicsToken = 0;\r", "+    }\r", "+   }\r", "-\t\t\tswitch (token) {\r", "-\t\t\t\tcase TokenNameelse :\r", "-\t\t\t\tcase TokenNamefinally :\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\tpendingNewlineAfterParen = true;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamecase :\r", "-\t\t\t\tcase TokenNamedefault :\r", "-\t\t\t\t\tif (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "-\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\ttokenBeforeColon, \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\t(tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\ttokenBeforeColonCount); \r", "-\t\t\t\t\t}\r", "-\t\t\t\t\ttokenBeforeColon[tokenBeforeColonCount++] = TokenNamecase;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(TokenNamecase);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameQUESTION :\r", "-\t\t\t\t\tif (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "-\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\ttokenBeforeColon, \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\t(tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\ttokenBeforeColonCount); \r", "-\t\t\t\t\t}\r", "-\t\t\t\t\ttokenBeforeColon[tokenBeforeColonCount++] = token;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameswitch :\r", "-\t\t\t\tcase TokenNamefor :\r", "-\t\t\t\tcase TokenNameif :\r", "-\t\t\t\tcase TokenNamewhile :\r", "-\t\t\t\t\tif (openParenthesisCount == openParenthesis.length) {\r", "-\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\topenParenthesis, \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\t(openParenthesis = new int[openParenthesisCount * 2]), \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\topenParenthesisCount); \r", "-\t\t\t\t\t}\r", "-\t\t\t\t\topenParenthesis[openParenthesisCount++] = 0;\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\t\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNametry :\r", "-\t\t\t\t\tpendingNewlineAfterParen = true;\r", "-\t\t\t\tcase TokenNamecatch :\r", "-\t\t\t\t\t// several CATCH statements can be contiguous.\r", "-\t\t\t\t\t// a CATCH is encountered pop until first CATCH (if a CATCH follows a TRY it works the same way,\r", "-\t\t\t\t\t// as CATCH and TRY are the same token in the stack).\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(TokenNamecatch);\r", "-\t\t\t\t\tbreak;\r", "+   switch (token) {\r", "+    case TokenNameelse :\r", "+    case TokenNamefinally :\r", "+     expectingOpenBrace = true;\r", "+     pendingNewlineAfterParen = true;\r", "+     indentationLevel += pushControlStatement(token);\r", "+     break;\r", "+    case TokenNamecase :\r", "+    case TokenNamedefault :\r", "+     if (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "+      System.arraycopy(\r", "+        tokenBeforeColon, \r", "+        0, \r", "+        (tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "+        0, \r", "+        tokenBeforeColonCount); \r", "+     }\r", "+     tokenBeforeColon[tokenBeforeColonCount++] = TokenNamecase;\r", "+     indentationLevel += pushControlStatement(TokenNamecase);\r", "+     break;\r", "+    case TokenNameQUESTION :\r", "+     if (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "+      System.arraycopy(\r", "+        tokenBeforeColon, \r", "+        0, \r", "+        (tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "+        0, \r", "+        tokenBeforeColonCount); \r", "+     }\r", "+     tokenBeforeColon[tokenBeforeColonCount++] = token;\r", "+     break;\r", "+    case TokenNameswitch :\r", "+    case TokenNamefor :\r", "+    case TokenNameif :\r", "+    case TokenNamewhile :\r", "+     if (openParenthesisCount == openParenthesis.length) {\r", "+      System.arraycopy(\r", "+        openParenthesis, \r", "+        0, \r", "+        (openParenthesis = new int[openParenthesisCount * 2]), \r", "+        0, \r", "+        openParenthesisCount); \r", "+     }\r", "+     openParenthesis[openParenthesisCount++] = 0;\r", "+     expectingOpenBrace = true;\r", "+     \r", "+     indentationLevel += pushControlStatement(token);\r", "+     break;\r", "+    case TokenNametry :\r", "+     pendingNewlineAfterParen = true;\r", "+    case TokenNamecatch :\r", "+     // several CATCH statements can be contiguous.\r", "+     // a CATCH is encountered pop until first CATCH (if a CATCH follows a TRY it works the same way,\r", "+     // as CATCH and TRY are the same token in the stack).\r", "+     expectingOpenBrace = true;\r", "+     indentationLevel += pushControlStatement(TokenNamecatch);\r", "+     break;\r", "-\t\t\t\tcase TokenNamedo :\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "-\t\t\t\t\tnlicsToken = token;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamenew :\r", "+    case TokenNamedo :\r", "+     expectingOpenBrace = true;\r", "+     indentationLevel += pushControlStatement(token);\r", "+     nlicsToken = token;\r", "+     break;\r", "+    case TokenNamenew :\r", "+     break;\r", "+    case TokenNameLPAREN :\r", "-\t\t\t\t\t// The flag inAssigment is used to properly format\r", "-\t\t\t\t\t// array assignments, and if a non-array assignment\r", "-\t\t\t\t\t// statement is in progress, it is no longer\r", "-\t\t\t\t\t// beneficial to know this, so set the flag to false.\r", "+     // Put a space between the previous and current token if the\r", "+     // previous token was not a keyword, open paren, logical\r", "+     // compliment (eg: !), semi-colon, open brace, close brace,\r", "+     // super, or this.\r", "-/*                  if (!inArrayAssignment) {\r", "-\t\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\t}*/\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameLPAREN :\r", "+     if (previousCompilableToken != TokenNameLBRACKET\r", "+      && previousToken != TokenNameIdentifier\r", "+      && previousToken != 0\r", "+      && previousToken != TokenNameNOT\r", "+      && previousToken != TokenNameLPAREN\r", "+      && previousToken != TokenNameTWIDDLE\r", "+      && previousToken != TokenNameSEMICOLON\r", "+      && previousToken != TokenNameLBRACE\r", "+      && previousToken != TokenNameRBRACE\r", "+      && previousToken != TokenNamesuper\r", "+      && previousToken != TokenNamethis) {\r", "+      space();\r", "+     }\r", "-\t\t\t\t\t// Put a space between the previous and current token if the\r", "-\t\t\t\t\t// previous token was not a keyword, open paren, logical\r", "-\t\t\t\t\t// compliment (eg: !), semi-colon, open brace, close brace,\r", "-\t\t\t\t\t// super, or this.\r", "+     // If in a for/if/while statement, increase the parenthesis count\r", "+     // for the current openParenthesisCount\r", "+     // else increase the count for stand alone parenthesis.\r", "+     if (openParenthesisCount > 0)\r", "+      openParenthesis[openParenthesisCount - 1]++;\r", "+     else\r", "+      openParenthesis[0]++;\r", "-\t\t\t\t\tif (previousCompilableToken != TokenNameLBRACKET\r", "-\t\t\t\t\t\t&& previousToken != TokenNameIdentifier\r", "-\t\t\t\t\t\t&& previousToken != 0\r", "-\t\t\t\t\t\t&& previousToken != TokenNameNOT\r", "-\t\t\t\t\t\t&& previousToken != TokenNameLPAREN\r", "-\t\t\t\t\t\t&& previousToken != TokenNameTWIDDLE\r", "-\t\t\t\t\t\t&& previousToken != TokenNameSEMICOLON\r", "-\t\t\t\t\t\t&& previousToken != TokenNameLBRACE\r", "-\t\t\t\t\t\t&& previousToken != TokenNameRBRACE\r", "-\t\t\t\t\t\t&& previousToken != TokenNamesuper\r", "-\t\t\t\t\t\t&& previousToken != TokenNamethis) {\r", "-\t\t\t\t\t\tspace();\r", "-\t\t\t\t\t}\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameRPAREN :\r", "-\t\t\t\t\t// If in a for/if/while statement, increase the parenthesis count\r", "-\t\t\t\t\t// for the current openParenthesisCount\r", "-\t\t\t\t\t// else increase the count for stand alone parenthesis.\r", "-\t\t\t\t\tif (openParenthesisCount > 0)\r", "-\t\t\t\t\t\topenParenthesis[openParenthesisCount - 1]++;\r", "-\t\t\t\t\telse\r", "-\t\t\t\t\t\topenParenthesis[0]++;\r", "+     // Decrease the parenthesis count\r", "+     // if there is no more unclosed parenthesis,\r", "+     // a new line and indent may be append (depending on the next token).\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameRPAREN :\r", "+     if ((openParenthesisCount > 1)\r", "+      && (openParenthesis[openParenthesisCount - 1] > 0)) {\r", "+      openParenthesis[openParenthesisCount - 1]--;\r", "+      if (openParenthesis[openParenthesisCount - 1] <= 0) {\r", "+       pendingNewlineAfterParen = true;\r", "+       inAssignment = false;\r", "+       openParenthesisCount--;\r", "-\t\t\t\t\t// Decrease the parenthesis count\r", "-\t\t\t\t\t// if there is no more unclosed parenthesis,\r", "-\t\t\t\t\t// a new line and indent may be append (depending on the next token).\r", "+      }\r", "+     } else {\r", "+      openParenthesis[0]--;\r", "+     }\r", "-\t\t\t\t\tif ((openParenthesisCount > 1)\r", "-\t\t\t\t\t\t&& (openParenthesis[openParenthesisCount - 1] > 0)) {\r", "-\t\t\t\t\t\topenParenthesis[openParenthesisCount - 1]--;\r", "-\t\t\t\t\t\tif (openParenthesis[openParenthesisCount - 1] <= 0) {\r", "-\t\t\t\t\t\t\tpendingNewlineAfterParen = true;\r", "-\t\t\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\t\t\topenParenthesisCount--;\r", "-\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\topenParenthesis[0]--;\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameLBRACE :\r", "-\t\t\t\t\tif ((previousCompilableToken == TokenNameRBRACKET) || (previousCompilableToken == TokenNameEQUAL)) {\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameLBRACE :\r", "+     if ((previousCompilableToken == TokenNameRBRACKET) || (previousCompilableToken == TokenNameEQUAL)) {\r", "-\t\t\t\t\t\tinArrayAssignment = true;\r", "-\t\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (inArrayAssignment) {\r", "-\t\t\t\t\t\tindentationLevel += pushBlock();\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t// Add new line and increase indentation level after open brace.\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tindentationLevel += pushBlock();\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameRBRACE :\r", "-\t\t\t\t\tif (previousCompilableToken == TokenNameRPAREN) {\r", "-\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (inArrayAssignment) {\r", "-\t\t\t\t\t\tinArrayAssignment = false;\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntilBlock();\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntilBlock();\r", "+      inArrayAssignment = true;\r", "+      inAssignment = false;\r", "+     }\r", "+     if (inArrayAssignment) {\r", "+      indentationLevel += pushBlock();\r", "+     } else {\r", "+      // Add new line and increase indentation level after open brace.\r", "+      pendingNewLines = 1;\r", "+      indentationLevel += pushBlock();\r", "+     }\r", "+     break;\r", "+    case TokenNameRBRACE :\r", "+     if (previousCompilableToken == TokenNameRPAREN) {\r", "+      pendingSpace = false;\r", "+     }\r", "+     if (inArrayAssignment) {\r", "+      inArrayAssignment = false;\r", "+      pendingNewLines = 1;\r", "+      indentationLevel += popInclusiveUntilBlock();\r", "+     } else {\r", "+      pendingNewLines = 1;\r", "+      indentationLevel += popInclusiveUntilBlock();\r", "-\t\t\t\t\t\tif (previousCompilableToken == TokenNameRPAREN){\r", "-\t\t\t\t\t\t\t// fix for 1FGDDV6: LFCOM:WIN98 - Weird splitting on message expression\r", "-\t\t\t\t\t\t\tcurrentLineBuffer.append(options.lineSeparatorSequence);\r", "-\t\t\t\t\t\t\tincreaseLineDelta(options.lineSeparatorSequence.length);                            \r", "-\t\t\t\t\t\t}\r", "+      if (previousCompilableToken == TokenNameRPAREN){\r", "+       // fix for 1FGDDV6: LFCOM:WIN98 - Weird splitting on message expression\r", "+       currentLineBuffer.append(options.lineSeparatorSequence);\r", "+       increaseLineDelta(options.lineSeparatorSequence.length);                            \r", "+      }\r", "-\t\t\t\t\t\tif (constructionsCount > 0) {\r", "-\t\t\t\t\t\t\tswitch (constructions[constructionsCount - 1]) {\r", "-\t\t\t\t\t\t\t\tcase TokenNamefor :\r", "-\t\t\t\t\t\t\t\t\t//indentationLevel += popExclusiveUntilBlock();\r", "-\t\t\t\t\t\t\t\t\t//break;\r", "-\t\t\t\t\t\t\t\tcase TokenNameswitch :\r", "-\t\t\t\t\t\t\t\tcase TokenNameif :\r", "-\t\t\t\t\t\t\t\tcase TokenNameelse :\r", "-\t\t\t\t\t\t\t\tcase TokenNametry :\r", "-\t\t\t\t\t\t\t\tcase TokenNamecatch :\r", "-\t\t\t\t\t\t\t\tcase TokenNamefinally :\r", "-\t\t\t\t\t\t\t\tcase TokenNamewhile :\r", "-\t\t\t\t\t\t\t\tcase TokenNamedo :\r", "-\t\t\t\t\t\t\t\t\tclearNonBlockIndents = true;\r", "-\t\t\t\t\t\t\t\tdefault :\r", "-\t\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "+      if (constructionsCount > 0) {\r", "+       switch (constructions[constructionsCount - 1]) {\r", "+        case TokenNamefor :\r", "+         //indentationLevel += popExclusiveUntilBlock();\r", "+         //break;\r", "+        case TokenNameswitch :\r", "+        case TokenNameif :\r", "+        case TokenNameelse :\r", "+        case TokenNametry :\r", "+        case TokenNamecatch :\r", "+        case TokenNamefinally :\r", "+        case TokenNamewhile :\r", "+        case TokenNamedo :\r", "+         clearNonBlockIndents = true;\r", "+        default :\r", "+         break;\r", "+       }\r", "+      }\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameLBRACKET :\r", "-\t\t\t\t\topenBracketCount++;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameRBRACKET :\r", "-\t\t\t\t\topenBracketCount-=(openBracketCount>0)?1:0;\r", "-\t\t\t\t\t// if there is no left bracket to close, the right bracket is ignored.\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameCOMMA :\r", "-\t\t\t\tcase TokenNameDOT :\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameSEMICOLON :\r", "+     }\r", "+     break;\r", "+    case TokenNameLBRACKET :\r", "+     openBracketCount++;\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameRBRACKET :\r", "+     openBracketCount-=(openBracketCount>0)?1:0;\r", "+     // if there is no left bracket to close, the right bracket is ignored.\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameCOMMA :\r", "+    case TokenNameDOT :\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameSEMICOLON :\r", "-\t\t\t\t\t// Do not generate line terminators in the definition of\r", "-\t\t\t\t\t// the for statement.\r", "-\t\t\t\t\t// if not in this case, jump a line and reduce indentation after the brace\r", "-\t\t\t\t\t// if the block it closes belongs to a conditional statement (if, while, do...).\r", "+     // Do not generate line terminators in the definition of\r", "+     // the for statement.\r", "+     // if not in this case, jump a line and reduce indentation after the brace\r", "+     // if the block it closes belongs to a conditional statement (if, while, do...).\r", "-\t\t\t\t\tif (openParenthesisCount <= 1) {\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tif (expectingOpenBrace) {\r", "-\t\t\t\t\t\t\tclearNonBlockIndents = true;\r", "-\t\t\t\t\t\t\texpectingOpenBrace = false;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamePLUS_PLUS :\r", "-\t\t\t\tcase TokenNameMINUS_MINUS :\r", "+     if (openParenthesisCount <= 1) {\r", "+      pendingNewLines = 1;\r", "+      if (expectingOpenBrace) {\r", "+       clearNonBlockIndents = true;\r", "+       expectingOpenBrace = false;\r", "+      }\r", "+     }\r", "+     inAssignment = false;\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNamePLUS_PLUS :\r", "+    case TokenNameMINUS_MINUS :\r", "-\t\t\t\t\t// Do not put a space between a post-increment/decrement\r", "-\t\t\t\t\t// and the identifier being modified.\r", "+     // Do not put a space between a post-increment/decrement\r", "+     // and the identifier being modified.\r", "-\t\t\t\t\tif (previousToken == TokenNameIdentifier\r", "-\t\t\t\t\t\t|| previousToken == TokenNameRBRACKET) {\r", "-\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamePLUS : // previously ADDITION\r", "-\t\t\t\tcase TokenNameMINUS :\r", "+     if (previousToken == TokenNameIdentifier\r", "+      || previousToken == TokenNameRBRACKET) {\r", "+      pendingSpace = false;\r", "+     }\r", "+     break;\r", "+    case TokenNamePLUS : // previously ADDITION\r", "+    case TokenNameMINUS :\r", "-\t\t\t\t\t// Handle the unary operators plus and minus via a 3-state flag.\r", "+     // Handle the unary operators plus and minus via a flag\r", "-\t\t\t\t\tif (!isLiteralToken(previousToken)\r", "-\t\t\t\t\t\t&& previousToken != TokenNameIdentifier\r", "-\t\t\t\t\t\t&& previousToken != TokenNameRPAREN\r", "-\t\t\t\t\t\t&& previousToken != TokenNameRBRACKET) {\r", "-\t\t\t\t\t\tunarySignModifier = 2;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameCOLON :\r", "+     if (!isLiteralToken(previousToken)\r", "+      && previousToken != TokenNameIdentifier\r", "+      && previousToken != TokenNameRPAREN\r", "+      && previousToken != TokenNameRBRACKET) {\r", "+      unarySignModifier = 1;\r", "+     }\r", "+     break;\r", "+    case TokenNameCOLON :\r", "+     // In a switch/case statement, add a newline & indent\r", "+     // when a colon is encountered.\r", "+     if (tokenBeforeColonCount > 0) {\r", "+      if (tokenBeforeColon[tokenBeforeColonCount - 1] == TokenNamecase) {\r", "+       pendingNewLines = 1;\r", "+      }\r", "+      tokenBeforeColonCount--;\r", "+     }\r", "+     break;\r", "+    case TokenNameEQUAL :\r", "+     inAssignment = true;\r", "+     break;\r", "+    case Scanner.TokenNameCOMMENT_LINE :\r", "+     pendingNewLines = 1;\r", "+     if (inAssignment) {\r", "+      currentLineIndentationLevel++;\r", "+     }\r", "+     break; // a line is always inserted after a one-line comment\r", "+    case Scanner.TokenNameCOMMENT_JAVADOC :\r", "+    case Scanner.TokenNameCOMMENT_BLOCK :\r", "+     currentCommentOffset = getCurrentCommentOffset();\r", "+     if (openParenthesis[0]==0 && openBracketCount < 1){\r", "+      pendingNewLines = 1;\r", "+      // a new line is inserted only if the comment is not between parenthesis.\r", "+     }\r", "+     break;\r", "+    case Scanner.TokenNameWHITESPACE :\r", "-\t\t\t\t\t// In a switch/case statement, add a newline & indent\r", "-\t\t\t\t\t// when a colon is encountered.\r", "-\t\t\t\t\tif (tokenBeforeColonCount > 0) {\r", "-\t\t\t\t\t\tif (tokenBeforeColon[tokenBeforeColonCount - 1] == TokenNamecase) {\r", "-\t\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\ttokenBeforeColonCount--;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameEQUAL :\r", "-\t\t\t\t\tinAssignment = true;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase Scanner.TokenNameCOMMENT_LINE :\r", "-\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\tif (inAssignment) {\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel++;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak; // a line is always inserted after a one-line comment\r", "-\t\t\t\tcase Scanner.TokenNameCOMMENT_JAVADOC :\r", "-\t\t\t\tcase Scanner.TokenNameCOMMENT_BLOCK :\r", "-\t\t\t\t\tcurrentCommentOffset = getCurrentCommentOffset();\r", "-\t\t\t\t\tif (openParenthesis[0]==0 && openBracketCount < 1){\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\t// a new line is inserted only if the comment is not between parenthesis.\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase Scanner.TokenNameWHITESPACE :\r", "+     // Count the number of line terminators in the whitespace so\r", "+     // line spacing can be preserved near comments.\r", "-\t\t\t\t\t// Count the number of line terminators in the whitespace so\r", "-\t\t\t\t\t// line spacing can be preserved near comments.\r", "+     char[] source = scanner.source;\r", "+     newLinesInWhitespace = 0;\r", "+     for (\r", "+      int i = scanner.startPosition, max = scanner.currentPosition; \r", "+      i < max; \r", "+      i++) {\r", "+      if (source[i] == '\\n') {\r", "+       newLinesInWhitespace++;\r", "+      }\r", "+     }\r", "+     increaseLineDelta(scanner.startPosition - scanner.currentPosition);\r", "+     break;\r", "+    default :\r", "+     if ((token == TokenNameIdentifier)\r", "+      || isLiteralToken(token)\r", "+      || token == TokenNamesuper\r", "+      || token == TokenNamethis) {\r", "-\t\t\t\t\tchar[] source = scanner.source;\r", "-\t\t\t\t\tnewLinesInWhitespace = 0;\r", "-\t\t\t\t\tfor (\r", "-\t\t\t\t\t\tint i = scanner.startPosition, max = scanner.currentPosition; \r", "-\t\t\t\t\t\ti < max; \r", "-\t\t\t\t\t\ti++) {\r", "-\t\t\t\t\t\tif (source[i] == '\\n') {\r", "-\t\t\t\t\t\t\tnewLinesInWhitespace++;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tincreaseLineDelta(scanner.startPosition - scanner.currentPosition);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tdefault :\r", "-\t\t\t\t\tif ((token == TokenNameIdentifier)\r", "-\t\t\t\t\t\t|| isLiteralToken(token)\r", "-\t\t\t\t\t\t|| token == TokenNamesuper\r", "-\t\t\t\t\t\t|| token == TokenNamethis) {\r", "+      // Do not put a space between a unary operator\r", "+      // (eg: ++, --, +, -) and the identifier being modified.\r", "+      if (previousToken == TokenNamePLUS_PLUS\r", "+       || previousToken == TokenNameMINUS_MINUS\r", "+       || (previousToken == TokenNamePLUS && unarySignModifier > 0)\r", "+       || (previousToken == TokenNameMINUS && unarySignModifier > 0)) {\r", "+       pendingSpace = false;\r", "+      }\r", "+      unarySignModifier = 0;\r", "+     }\r", "+     break;\r", "+   }\r", "-\t\t\t\t\t\t// Do not put a space between a unary operator\r", "-\t\t\t\t\t\t// (eg: ++, --, +, -) and the identifier being modified.\r", "+   // Do not output whitespace tokens.\r", "-\t\t\t\t\t\tunarySignModifier -= (unarySignModifier > 0) ? 1 : 0;\r", "-\t\t\t\t\t\tif (previousToken == TokenNamePLUS_PLUS\r", "-\t\t\t\t\t\t\t|| previousToken == TokenNameMINUS_MINUS\r", "-\t\t\t\t\t\t\t|| (unarySignModifier > 0)) {\r", "-\t\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t}\r", "+   if (token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t// Do not output whitespace tokens.\r", "+    /* Add pending space to the formatted source string.\r", "+    Do not output a space under the following circumstances:\r", "+    1) this is the first pass\r", "+    2) previous token is an open paren\r", "+    3) previous token is a period\r", "+    4) previous token is the logical compliment (eg: !)\r", "+    5) previous token is the bitwise compliment (eg: ~)\r", "+    6) previous token is the open bracket (eg: [)\r", "+    7) in an assignment statement, if the previous token is an \r", "+    open brace or the current token is a close brace\r", "+    8) previous token is a single line comment\r", "+    */\r", "-\t\t\tif (token != Scanner.TokenNameWHITESPACE) {\r", "+    boolean openAndCloseBrace = previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE;\r", "-\t\t\t\t/* Add pending space to the formatted source string.\r", "-\t\t\t\tDo not output a space under the following circumstances:\r", "-\t\t\t\t1) this is the first pass\r", "-\t\t\t\t2) previous token is an open paren\r", "-\t\t\t\t3) previous token is a period\r", "-\t\t\t\t4) previous token is the logical compliment (eg: !)\r", "-\t\t\t\t5) previous token is the bitwise compliment (eg: ~)\r", "-\t\t\t\t6) previous token is the open bracket (eg: [)\r", "-\t\t\t\t7) in an assignment statement, if the previous token is an \r", "-\t\t\t\topen brace or the current token is a close brace\r", "-\t\t\t\t8) previous token is a single line comment\r", "-\t\t\t\t*/\r", "+    // to be replaced by a nicer condition.\r", "+   \r", "+    if (pendingSpace\r", "+     && insertSpaceAfter(previousToken)\r", "+     && ! (inAssignment\r", "+      && (previousToken == TokenNameLBRACE || token == TokenNameRBRACE))\r", "+     && previousToken != Scanner.TokenNameCOMMENT_LINE) {\r", "+     if ((! (options.compactAssignmentMode && token == TokenNameEQUAL)) && !openAndCloseBrace)\r", "+      space();\r", "+    }\r", "-\t\t\t\tboolean openAndCloseBrace = previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE;\r", "+    // Add the next token to the formatted source string.\r", "-\t\t\t\t// to be replaced by a nicer condition.\r", "-\t\t\t\r", "-\t\t\t\tif (pendingSpace\r", "-\t\t\t\t\t&& insertSpaceAfter(previousToken)\r", "-\t\t\t\t\t&& ! (inAssignment\r", "-\t\t\t\t\t\t&& (previousToken == TokenNameLBRACE || token == TokenNameRBRACE))\r", "-\t\t\t\t\t&& previousToken != Scanner.TokenNameCOMMENT_LINE) {\r", "-\t\t\t\t\tif ((! (options.compactAssignmentMode && token == TokenNameEQUAL)) && !openAndCloseBrace)\r", "-\t\t\t\t\t\tspace();\r", "-\t\t\t\t}\r", "+    outputCurrentToken(token);\r", "+    if (token == Scanner.TokenNameCOMMENT_LINE && openParenthesisCount > 1){\r", "+     pendingNewLines = 0;\r", "+     currentLineBuffer.append(options.lineSeparatorSequence);\r", "+     increaseLineDelta(options.lineSeparatorSequence.length);                    \r", "+    }\r", "+    pendingSpace = true;\r", "+   }\r", "-\t\t\t\t// Add the next token to the formatted source string.\r", "+   // Whitespace tokens do not need to be remembered.\r", "-\t\t\t\toutputCurrentToken(token);\r", "-\t\t\t\tif (token == Scanner.TokenNameCOMMENT_LINE && openParenthesisCount > 1){\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tcurrentLineBuffer.append(options.lineSeparatorSequence);\r", "-\t\t\t\t\tincreaseLineDelta(options.lineSeparatorSequence.length);                    \r", "-\t\t\t\t}\r", "-\t\t\t\tpendingSpace = true;\r", "-\t\t\t}\r", "+   if (token != Scanner.TokenNameWHITESPACE) {\r", "+    previousToken = token;\r", "+    if (token != Scanner.TokenNameCOMMENT_BLOCK\r", "+     && token != Scanner.TokenNameCOMMENT_LINE\r", "+     && token != Scanner.TokenNameCOMMENT_JAVADOC) {\r", "+     previousCompilableToken = token;\r", "+    }\r", "+   }\r", "-\t\t\t// Whitespace tokens do not need to be remembered.\r", "-\r", "-\t\t\tif (token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t\tpreviousToken = token;\r", "-\t\t\t\tif (token != Scanner.TokenNameCOMMENT_BLOCK\r", "-\t\t\t\t\t&& token != Scanner.TokenNameCOMMENT_LINE\r", "-\t\t\t\t\t&& token != Scanner.TokenNameCOMMENT_JAVADOC) {\r", "-\t\t\t\t\tpreviousCompilableToken = token;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t}\r", "-\t\toutput(copyRemainingSource());\r", "-\t\tflushBuffer(); // dump the last token of the source in the formatted output.\r", "-\t} catch (InvalidInputException e) {\r", "-\t\toutput(copyRemainingSource());\r", "-\t\tflushBuffer(); // dump the last token of the source in the formatted output.\r", "-\t}\r", "+  }\r", "+  output(copyRemainingSource());\r", "+  flushBuffer(); // dump the last token of the source in the formatted output.\r", "+ } catch (InvalidInputException e) {\r", "+  output(copyRemainingSource());\r", "+  flushBuffer(); // dump the last token of the source in the formatted output.\r", "+ }\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e180b6d090d70e07b40cb703594ced61", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatter.java", "commitBeforeChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "commitAfterChange": "7e5cc03e445550d3cbc10c611218c79332074276", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r private void format()", "signatureAfterChange": "\r private void format()", "diff": ["-\tint token = 0;\r", "-\tint previousToken = 0;\r", "-\tint previousCompilableToken = 0;\r", "+ int token = 0;\r", "+ int previousToken = 0;\r", "+ int previousCompilableToken = 0;\r", "-\tint indentationOffset = 0;\r", "+ int indentationOffset = 0;\r", "-\tint newLinesInWhitespace = 0;\r", "-\t// number of new lines in the previous whitespace token\r", "-\t// (used to leave blank lines before comments)\r", "-\tint pendingNewLines = 0;\r", "-\tboolean expectingOpenBrace = false;\r", "-\tboolean clearNonBlockIndents = false;\r", "-\t// true if all indentations till the 1st { (usefull after } or ;)\r", "-\tboolean pendingSpace = true;\r", "-\tboolean pendingNewlineAfterParen = false;\r", "-\t// true when a cr is to be put after a ) (in conditional statements)\r", "-\tboolean inAssignment = false;\r", "-\tboolean inArrayAssignment = false;\r", "-\tboolean inThrowsClause = false;\r", "-\tboolean inClassOrInterfaceHeader = false;\r", "+ int newLinesInWhitespace = 0;\r", "+ // number of new lines in the previous whitespace token\r", "+ // (used to leave blank lines before comments)\r", "+ int pendingNewLines = 0;\r", "+ boolean expectingOpenBrace = false;\r", "+ boolean clearNonBlockIndents = false;\r", "+ // true if all indentations till the 1st { (usefull after } or ;)\r", "+ boolean pendingSpace = true;\r", "+ boolean pendingNewlineAfterParen = false;\r", "+ // true when a cr is to be put after a ) (in conditional statements)\r", "+ boolean inAssignment = false;\r", "+ boolean inArrayAssignment = false;\r", "+ boolean inThrowsClause = false;\r", "+ boolean inClassOrInterfaceHeader = false;\r", "-\t// openBracketCount is used to count the number of open brackets not closed yet.\r", "-\tint openBracketCount = 0;\r", "-\t\r", "-\tint unarySignModifier = 0;\r", "+ // openBracketCount is used to count the number of open brackets not closed yet.\r", "+ int openBracketCount = 0;\r", "+ \r", "+  int unarySignModifier = 0;\r", "-\t// openParenthesis[0] is used to count the parenthesis not belonging to a condition\r", "-\t// (eg foo();). parenthesis in for (...) are count elsewhere in the array.\r", "-\tint openParenthesisCount = 1;\r", "-\tint[] openParenthesis = new int[10];\r", "+ // openParenthesis[0] is used to count the parenthesis not belonging to a condition\r", "+ // (eg foo();). parenthesis in for (...) are count elsewhere in the array.\r", "+ int openParenthesisCount = 1;\r", "+ int[] openParenthesis = new int[10];\r", "-\t// tokenBeforeColon is used to know what token goes along with the current :\r", "-\t// it can be case or ?\r", "-\tint tokenBeforeColonCount = 0;\r", "-\tint[] tokenBeforeColon = new int[10];\r", "+ // tokenBeforeColon is used to know what token goes along with the current :\r", "+ // it can be case or ?\r", "+ int tokenBeforeColonCount = 0;\r", "+ int[] tokenBeforeColon = new int[10];\r", "-\tconstructionsCount = 0; // initializes the constructions count.\r", "+ constructionsCount = 0; // initializes the constructions count.\r", "-\t// contains DO if in a DO..WHILE statement, UNITIALIZED otherwise.\r", "-\tint nlicsToken = 0;\r", "+ // contains DO if in a DO..WHILE statement, UNITIALIZED otherwise.\r", "+ int nlicsToken = 0;\r", "-\t// fix for 1FF17XY: LFCOM:ALL - Format problem on not matching } and else \r", "-\tboolean specialElse = false;\r", "+ // fix for 1FF17XY: LFCOM:ALL - Format problem on not matching } and else \r", "+ boolean specialElse = false;\r", "-\t// OPTION (IndentationLevel): initial indentation level may be non-zero.\r", "-\tcurrentLineIndentationLevel += constructionsCount;\r", "+ // OPTION (IndentationLevel): initial indentation level may be non-zero.\r", "+ currentLineIndentationLevel += constructionsCount;\r", "-\t\r", "-\t// An InvalidInputException exception might cause the termination of this loop.\r", "-\ttry {\r", "-\t\twhile (true) {\r", "-\t\t\t// Get the next token.  Catch invalid input and output it\r", "-\t\t\t// with minimal formatting, also catch end of input and\r", "-\t\t\t// exit the loop.\r", "-\t\t\ttry {\r", "-\t\t\t\ttoken = scanner.getNextToken();\r", "-\t\t\t} catch (InvalidInputException e) {\r", "-\t\t\t\tif (!handleInvalidToken(e)) {\r", "-\t\t\t\t\tthrow e;\r", "-\t\t\t\t}\r", "-\t\t\t\ttoken = 0;\r", "-\t\t\t}\r", "-\t\t\tif (token == Scanner.TokenNameEOF)\r", "-\t\t\t\tbreak;\r", "+ \r", "+ // An InvalidInputException exception might cause the termination of this loop.\r", "+ try {\r", "+  while (true) {\r", "+   // Get the next token.  Catch invalid input and output it\r", "+   // with minimal formatting, also catch end of input and\r", "+   // exit the loop.\r", "+   try {\r", "+    token = scanner.getNextToken();\r", "+   } catch (InvalidInputException e) {\r", "+    if (!handleInvalidToken(e)) {\r", "+     throw e;\r", "+    }\r", "+    token = 0;\r", "+   }\r", "+   if (token == Scanner.TokenNameEOF)\r", "+    break;\r", "-\t\t\t/* ## MODIFYING the indentation level before generating new lines\r", "-\t\t\tand indentation in the output string\r", "-\t\t\t*/\r", "+   /* ## MODIFYING the indentation level before generating new lines\r", "+   and indentation in the output string\r", "+   */\r", "-\t\t\t// Removes all the indentations made by statements not followed by a block\r", "-\t\t\t// except if the current token is ELSE, CATCH or if we are in a switch/case\r", "+   // Removes all the indentations made by statements not followed by a block\r", "+   // except if the current token is ELSE, CATCH or if we are in a switch/case\r", "-\t\t\tif (clearNonBlockIndents && (token != Scanner.TokenNameWHITESPACE)) {\r", "+   if (clearNonBlockIndents && (token != Scanner.TokenNameWHITESPACE)) {\r", "-\t\t\t\tswitch (token) {\r", "-\t\t\t\t\tcase TokenNameelse :\r", "-\t\t\t\t\t\tif (constructionsCount > 0 && constructions[constructionsCount-1] == TokenNameelse){\r", "-\t\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\t\tspecialElse = true;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNameif);\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase TokenNamecatch :\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNamecatch);\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase TokenNamefinally :\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNamecatch);\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase TokenNamewhile :\r", "-\t\t\t\t\t\tif (nlicsToken == TokenNamedo) {\r", "-\t\t\t\t\t\t\tindentationLevel += pop(TokenNamedo);\r", "-\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\tdefault :\r", "-\t\t\t\t\t\tindentationLevel += popExclusiveUntilBlockOrCase();\r", "-\t\t\t\t\t\t// clear until a CASE, DEFAULT or BLOCK is encountered.\r", "-\t\t\t\t\t\t// Thus, the indentationLevel is correctly cleared either\r", "-\t\t\t\t\t\t// in a switch/case statement or in any other situation.\r", "-\t\t\t\t}\r", "-\t\t\t\tclearNonBlockIndents = false;\r", "-\t\t\t}\r", "+    switch (token) {\r", "+     case TokenNameelse :\r", "+      if (constructionsCount > 0 && constructions[constructionsCount-1] == TokenNameelse){\r", "+       pendingNewLines = 1;\r", "+       specialElse = true;\r", "+      }\r", "+      indentationLevel += popInclusiveUntil(TokenNameif);\r", "+      break;\r", "+     case TokenNamecatch :\r", "+      indentationLevel += popInclusiveUntil(TokenNamecatch);\r", "+      break;\r", "+     case TokenNamefinally :\r", "+      indentationLevel += popInclusiveUntil(TokenNamecatch);\r", "+      break;\r", "+     case TokenNamewhile :\r", "+      if (nlicsToken == TokenNamedo) {\r", "+       indentationLevel += pop(TokenNamedo);\r", "+       break;\r", "+      }\r", "+     default :\r", "+      indentationLevel += popExclusiveUntilBlockOrCase();\r", "+      // clear until a CASE, DEFAULT or BLOCK is encountered.\r", "+      // Thus, the indentationLevel is correctly cleared either\r", "+      // in a switch/case statement or in any other situation.\r", "+    }\r", "+    clearNonBlockIndents = false;\r", "+   }\r", "-\t\t\t// returns to the indentation level created by the SWITCH keyword\r", "-\t\t\t// if the current token is a CASE or a DEFAULT\r", "+   // returns to the indentation level created by the SWITCH keyword\r", "+   // if the current token is a CASE or a DEFAULT\r", "-\t\t\tif (token == TokenNamecase || token == TokenNamedefault) {\r", "-\t\t\t\tindentationLevel += pop(TokenNamecase);\r", "-\t\t\t}\r", "+   if (token == TokenNamecase || token == TokenNamedefault) {\r", "+    indentationLevel += pop(TokenNamecase);\r", "+   }\r", "-\t\t\tif (token == Scanner.TokenNamethrows) {\r", "-\t\t\t\tinThrowsClause = true;\r", "-\t\t\t}\r", "+   if (token == Scanner.TokenNamethrows) {\r", "+    inThrowsClause = true;\r", "+   }\r", "-\t\t\tif (token == Scanner.TokenNameclass || token == Scanner.TokenNameinterface) {\r", "-\t\t\t\tinClassOrInterfaceHeader = true;\r", "-\t\t\t}\r", "-\t\t\t/* ## APPEND newlines and indentations to the output string\r", "-\t\t\t*/\r", "+   if (token == Scanner.TokenNameclass || token == Scanner.TokenNameinterface) {\r", "+    inClassOrInterfaceHeader = true;\r", "+   }\r", "+   /* ## APPEND newlines and indentations to the output string\r", "+   */\r", "-\t\t\t// Do not add a new line between ELSE and IF, if the option elseIfOnSameLine is true.\r", "-\t\t\t// Fix for 1ETLWPZ: IVJCOM:ALL - incorrect \"else if\" formatting\r", "-\t\t\tif (pendingNewlineAfterParen && previousCompilableToken == TokenNameelse && token == TokenNameif && options.compactElseIfMode){\r", "-\t\t\t\tpendingNewlineAfterParen = false;\r", "-\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\tindentationLevel += pop(TokenNameelse);\r", "-\t\t\t\t// because else if is now one single statement,\r", "-\t\t\t\t// the indentation level after it is increased by one and not by 2\r", "-\t\t\t\t// (else = 1 indent, if = 1 indent, but else if = 1 indent, not 2).\r", "-\t\t\t}\r", "-\t\t\t\r", "-\t\t\t// Add a newline & indent to the formatted source string if\r", "-\t\t\t// a for/if-else/while statement was scanned and there is no block\r", "-\t\t\t// following it.\r", "-\t\t\t\r", "-\t\t\tpendingNewlineAfterParen = pendingNewlineAfterParen || (previousCompilableToken == TokenNameRPAREN && token == TokenNameLBRACE);\r", "-\t\t\tif (pendingNewlineAfterParen && token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t\tpendingNewlineAfterParen = false;\r", "+   // Do not add a new line between ELSE and IF, if the option elseIfOnSameLine is true.\r", "+   // Fix for 1ETLWPZ: IVJCOM:ALL - incorrect \"else if\" formatting\r", "+   if (pendingNewlineAfterParen && previousCompilableToken == TokenNameelse && token == TokenNameif && options.compactElseIfMode){\r", "+    pendingNewlineAfterParen = false;\r", "+    pendingNewLines = 0;\r", "+    indentationLevel += pop(TokenNameelse);\r", "+    // because else if is now one single statement,\r", "+    // the indentation level after it is increased by one and not by 2\r", "+    // (else = 1 indent, if = 1 indent, but else if = 1 indent, not 2).\r", "+   }\r", "+   \r", "+   // Add a newline & indent to the formatted source string if\r", "+   // a for/if-else/while statement was scanned and there is no block\r", "+   // following it.\r", "+   \r", "+   pendingNewlineAfterParen = pendingNewlineAfterParen || (previousCompilableToken == TokenNameRPAREN && token == TokenNameLBRACE);\r", "+   if (pendingNewlineAfterParen && token != Scanner.TokenNameWHITESPACE) {\r", "+    pendingNewlineAfterParen = false;\r", "-\t\t\t\t// Do to add a newline & indent sequence if the current token is an\r", "-\t\t\t\t// open brace or a period or if the current token is a semi-colon and the\r", "-\t\t\t\t// previous token is a close paren.\r", "-\t\t\t\t// add a new line if a parenthesis belonging to a for() statement\r", "-\t\t\t\t// has been closed and the current token is not an opening brace\r", "+    // Do to add a newline & indent sequence if the current token is an\r", "+    // open brace or a period or if the current token is a semi-colon and the\r", "+    // previous token is a close paren.\r", "+    // add a new line if a parenthesis belonging to a for() statement\r", "+    // has been closed and the current token is not an opening brace\r", "-\t\t\t\tif (token != TokenNameLBRACE && !isComment(token)\r", "-\t\t\t\t// to avoid adding new line between else and a comment\r", "-\t\t\t\t\t\t&& token != TokenNameDOT\r", "-\t\t\t\t\t\t&& ! (previousCompilableToken == TokenNameRPAREN\r", "-\t\t\t\t\t\t\t&& token == TokenNameSEMICOLON)) {\r", "-\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\tcurrentLineIndentationLevel += indentationLevel;\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tif (token == TokenNameLBRACE && options.newLineBeforeOpeningBraceMode) {\r", "-\t\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "-\t\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "+    if (token != TokenNameLBRACE && !isComment(token)\r", "+    // to avoid adding new line between else and a comment\r", "+      && token != TokenNameDOT\r", "+      && ! (previousCompilableToken == TokenNameRPAREN\r", "+       && token == TokenNameSEMICOLON)) {\r", "+     newLine(1);\r", "+     currentLineIndentationLevel = indentationLevel;\r", "+     pendingNewLines = 0;\r", "+     pendingSpace = false;\r", "+    } else {\r", "+     if (token == TokenNameLBRACE && options.newLineBeforeOpeningBraceMode) {\r", "+      newLine(1);\r", "+      if (constructionsCount > 0\r", "+       && constructions[constructionsCount - 1] != BLOCK\r", "+       && constructions[constructionsCount - 1] != NONINDENT_BLOCK) {\r", "+       currentLineIndentationLevel = indentationLevel - 1;\r", "+      } else {\r", "+       currentLineIndentationLevel = indentationLevel;\r", "+      }\r", "+      pendingNewLines = 0;\r", "+      pendingSpace = false;\r", "+     }\r", "+    }\r", "+   }\r", "-\t\t\t// see PR 1G5G8EC\r", "-\t\t\tif (token == TokenNameLBRACE && inThrowsClause) {\r", "-\t\t\t\tinThrowsClause = false;      \r", "-\t\t\t\tif (options.newLineBeforeOpeningBraceMode) {\r", "-\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\t\r", "-\t\t\t// see PR 1G5G82G\r", "-\t\t\tif (token == TokenNameLBRACE && inClassOrInterfaceHeader) {\r", "-\t\t\t\tinClassOrInterfaceHeader = false;\r", "-\t\t\t\tif (options.newLineBeforeOpeningBraceMode) {\r", "-\t\t\t\t\tnewLine(1);\r", "-\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t}\r", "-\t\t\t}            \r", "-\t\t\t// Add pending new lines to the formatted source string.\r", "-\t\t\t// Note: pending new lines are not added if the current token\r", "-\t\t\t// is a single line comment or whitespace.\r", "-\t\t\t// if the comment is between parenthesis, there is no blank line preservation\r", "-\t\t\t// (if it's a one-line comment, a blank line is added after it).\r", "+   if (token == TokenNameLBRACE\r", "+    && options.newLineBeforeOpeningBraceMode\r", "+    && constructionsCount > 0\r", "+    && constructions[constructionsCount - 1] == TokenNamedo) {\r", "+    newLine(1);\r", "+    currentLineIndentationLevel = indentationLevel - 1;\r", "+    pendingNewLines = 0;\r", "+    pendingSpace = false;\r", "+   }\r", "-\t\t\tif (((pendingNewLines > 0 && (!isComment(token)))\r", "-\t\t\t\t\t|| (newLinesInWhitespace > 0\r", "-\t\t\t\t\t\t\t&& (openParenthesisCount <= 1 && isComment(token)))\r", "-\t\t\t\t\t|| (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE))\r", "-\t\t\t\t&& token != Scanner.TokenNameWHITESPACE) {\r", "+   // see PR 1G5G8EC\r", "+   if (token == TokenNameLBRACE && inThrowsClause) {\r", "+    inThrowsClause = false;      \r", "+    if (options.newLineBeforeOpeningBraceMode) {\r", "+     newLine(1);\r", "+     currentLineIndentationLevel = indentationLevel;\r", "+     pendingNewLines = 0;\r", "+     pendingSpace = false;\r", "+    }\r", "+   }\r", "+   \r", "+   // see PR 1G5G82G\r", "+   if (token == TokenNameLBRACE && inClassOrInterfaceHeader) {\r", "+    inClassOrInterfaceHeader = false;\r", "+    if (options.newLineBeforeOpeningBraceMode) {\r", "+     newLine(1);\r", "+     currentLineIndentationLevel = indentationLevel;\r", "+     pendingNewLines = 0;\r", "+     pendingSpace = false;\r", "+    }\r", "+   }            \r", "+   // Add pending new lines to the formatted source string.\r", "+   // Note: pending new lines are not added if the current token\r", "+   // is a single line comment or whitespace.\r", "+   // if the comment is between parenthesis, there is no blank line preservation\r", "+   // (if it's a one-line comment, a blank line is added after it).\r", "-\t\t\t\t// Do not add newline & indent between an adjoining close brace and\r", "-\t\t\t\t// close paren.  Anonymous inner classes may use this form.\r", "+   if (((pendingNewLines > 0 && (!isComment(token)))\r", "+     || (newLinesInWhitespace > 0\r", "+       && (openParenthesisCount <= 1 && isComment(token)))\r", "+     || (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE))\r", "+    && token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t\tboolean closeBraceAndCloseParen = \r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameRPAREN; \r", "+    // Do not add newline & indent between an adjoining close brace and\r", "+    // close paren.  Anonymous inner classes may use this form.\r", "-\t\t\t\t// OPTION (NewLineInCompoundStatement): do not add newline & indent\r", "-\t\t\t\t// between close brace and else, (do) while, catch, and finally if\r", "-\t\t\t\t// newlineInCompoundStatement is true.\r", "+    boolean closeBraceAndCloseParen = \r", "+      previousToken == TokenNameRBRACE && token == TokenNameRPAREN; \r", "-\t\t\t\tboolean nlicsOption = \r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE\r", "-\t\t\t\t\t\t\t&& !options.newlineInControlStatementMode\r", "-\t\t\t\t\t\t\t&& (token == TokenNameelse\r", "-\t\t\t\t\t\t\t\t|| (token == TokenNamewhile && nlicsToken == TokenNamedo)\r", "-\t\t\t\t\t\t\t\t|| token == TokenNamecatch\r", "-\t\t\t\t\t\t\t\t|| token == TokenNamefinally);\r", "+    // OPTION (NewLineInCompoundStatement): do not add newline & indent\r", "+    // between close brace and else, (do) while, catch, and finally if\r", "+    // newlineInCompoundStatement is true.\r", "-\t\t\t\t// Do not add a newline & indent between a close brace and semi-colon.\r", "-\t\t\t\tboolean semiColonAndCloseBrace = \r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameSEMICOLON; \r", "+    boolean nlicsOption = \r", "+      previousToken == TokenNameRBRACE\r", "+       && !options.newlineInControlStatementMode\r", "+       && (token == TokenNameelse\r", "+        || (token == TokenNamewhile && nlicsToken == TokenNamedo)\r", "+        || token == TokenNamecatch\r", "+        || token == TokenNamefinally);\r", "-\t\t\t\t// Do not add a new line & indent between a multiline comment and a opening brace\r", "+    // Do not add a newline & indent between a close brace and semi-colon.\r", "-\t\t\t\tboolean commentAndOpenBrace = previousToken == Scanner.TokenNameCOMMENT_BLOCK && token == TokenNameLBRACE;\r", "-\t\t\t\t\r", "-\t\t\t\t// Do not add a newline & indent between a close brace and a colon (in array assignments, for example).\r", "-\t\t\t\t\r", "-\t\t\t\tboolean commaAndCloseBrace =\r", "-\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameCOMMA; \r", "+    boolean semiColonAndCloseBrace = \r", "+      previousToken == TokenNameRBRACE && token == TokenNameSEMICOLON; \r", "-\t\t\t\t// Add a newline and indent, if appropriate.\r", "+    // Do not add a new line & indent between a multiline comment and a opening brace\r", "-\t\t\t\tif (specialElse || (!commentAndOpenBrace && !closeBraceAndCloseParen && !nlicsOption && !semiColonAndCloseBrace && !commaAndCloseBrace)) {\r", "-\t\t\t\t\t// if clearAllBlankLinesMode=false, leaves the blank lines\r", "-\t\t\t\t\t// inserted by the user\r", "-\t\t\t\t\t// if clearAllBlankLinesMode=true, removes all of then\r", "-\t\t\t\t\t// and insert only blank lines required by the formatting.\r", "-\t\t\t\t\tif (!options.clearAllBlankLinesMode) {\r", "-\t\t\t\t\t\tpendingNewLines = \r", "-\t\t\t\t\t\t\t\t(pendingNewLines < newLinesInWhitespace)\r", "+    boolean commentAndOpenBrace = previousToken == Scanner.TokenNameCOMMENT_BLOCK && token == TokenNameLBRACE;\r", "+    \r", "+    // Do not add a newline & indent between a close brace and a colon (in array assignments, for example).\r", "+    \r", "+    boolean commaAndCloseBrace =\r", "+      previousToken == TokenNameRBRACE && token == TokenNameCOMMA; \r", "+\r", "+    // Add a newline and indent, if appropriate.\r", "+\r", "+    if (specialElse || (!commentAndOpenBrace && !closeBraceAndCloseParen && !nlicsOption && !semiColonAndCloseBrace && !commaAndCloseBrace)) {\r", "+     // if clearAllBlankLinesMode=false, leaves the blank lines\r", "+     // inserted by the user\r", "+     // if clearAllBlankLinesMode=true, removes all of then\r", "+     // and insert only blank lines required by the formatting.\r", "+     if (!options.clearAllBlankLinesMode) {\r", "+      pendingNewLines = \r", "+        (pendingNewLines < newLinesInWhitespace)\r", "-\t\t\t\t\t\t\t\t\t? newLinesInWhitespace \r", "-\t\t\t\t\t\t\t\t\t: pendingNewLines;\r", "-\t\t\t\t\t\tpendingNewLines = (pendingNewLines > 2) ? 2 : pendingNewLines;\r", "-\t\t\t\t\t}\r", "+         ? newLinesInWhitespace \r", "+         : pendingNewLines;\r", "+      pendingNewLines = (pendingNewLines > 2) ? 2 : pendingNewLines;\r", "+     }\r", "-\t\t\t\t\tif (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE) {\r", "-\t\t\t\t\t\tcontainsOpenCloseBraces = true;\r", "-\t\t\t\t\t\tindentationLevelForOpenCloseBraces = currentLineIndentationLevel;\r", "-\t\t\t\t\t\tif (isComment(previousToken)) {\r", "-\t\t\t\t\t\t\tnewLine(pendingNewLines);\r", "-\t\t\t\t\t\t} else {\r", "+     if (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE) {\r", "+      containsOpenCloseBraces = true;\r", "+      indentationLevelForOpenCloseBraces = currentLineIndentationLevel;\r", "+      if (isComment(previousToken)) {\r", "+       newLine(pendingNewLines);\r", "+      } else {\r", "-\t\t\t\t\t\t\t\t&& constructions[constructionsCount-1] == NONINDENT_BLOCK\r", "-\t\t\t\t\t\t\t\t&& (constructions[constructionsCount-2] == TokenNamefor \r", "-\t\t\t\t\t\t\t\t\t|| constructions[constructionsCount-2] == TokenNamewhile))) {*/\r", "-\t\t\t\t\t\t\tif (options.newLineInEmptyBlockMode) {\r", "-\t\t\t\t\t\t\t\tif (inArrayAssignment) {\r", "-\t\t\t\t\t\t\t\t\tnewLine(1); // array assigment with an empty block\r", "-\t\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t\tnewLine(pendingNewLines);\r", "-\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t}\r", "+        && constructions[constructionsCount-1] == NONINDENT_BLOCK\r", "+        && (constructions[constructionsCount-2] == TokenNamefor \r", "+         || constructions[constructionsCount-2] == TokenNamewhile))) {*/\r", "+       if (options.newLineInEmptyBlockMode) {\r", "+        if (inArrayAssignment) {\r", "+         newLine(1); // array assigment with an empty block\r", "+        } else {\r", "+         newLine(pendingNewLines);\r", "+        }\r", "+       }\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t// see PR 1FKKC3U: LFCOM:WINNT - Format problem with a comment before the ';'\r", "-\t\t\t\t\t\tif (!((previousToken == Scanner.TokenNameCOMMENT_BLOCK || previousToken == Scanner.TokenNameCOMMENT_JAVADOC) && token == TokenNameSEMICOLON)) {\r", "-\t\t\t\t\t\t\tnewLine(pendingNewLines);                       \r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (((previousCompilableToken == TokenNameSEMICOLON)\r", "-\t\t\t\t\t\t\t|| (previousCompilableToken == TokenNameLBRACE)\r", "-\t\t\t\t\t\t\t|| (previousCompilableToken == TokenNameRBRACE)\r", "-\t\t\t\t\t\t\t|| (isComment(previousToken)))\r", "-\t\t\t\t\t\t&& (token == TokenNameRBRACE)) {\r", "-\t\t\t\t\t\tindentationOffset = -1;\r", "-\t\t\t\t\t\tindentationLevel += popExclusiveUntilBlock();\r", "-\t\t\t\t\t}\r", "+      }\r", "+     } else {\r", "+      // see PR 1FKKC3U: LFCOM:WINNT - Format problem with a comment before the ';'\r", "+      if (!((previousToken == Scanner.TokenNameCOMMENT_BLOCK || previousToken == Scanner.TokenNameCOMMENT_JAVADOC) && token == TokenNameSEMICOLON)) {\r", "+       newLine(pendingNewLines);                       \r", "+      }\r", "+     }\r", "+     if (((previousCompilableToken == TokenNameSEMICOLON)\r", "+       || (previousCompilableToken == TokenNameLBRACE)\r", "+       || (previousCompilableToken == TokenNameRBRACE)\r", "+       || (isComment(previousToken)))\r", "+      && (token == TokenNameRBRACE)) {\r", "+      indentationOffset = -1;\r", "+      indentationLevel += popExclusiveUntilBlock();\r", "+     }\r", "-\t\t\t\t\tif (previousToken == Scanner.TokenNameCOMMENT_LINE && inAssignment) {\r", "-\t\t\t\t\t\t// PR 1FI5IPO\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel++;\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel + indentationOffset;\r", "-\t\t\t\t\t}\r", "+     if (previousToken == Scanner.TokenNameCOMMENT_LINE && inAssignment) {\r", "+      // PR 1FI5IPO\r", "+      currentLineIndentationLevel++;\r", "+     } else {\r", "+      currentLineIndentationLevel = indentationLevel + indentationOffset;\r", "+     }\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tindentationOffset = 0;\r", "-\t\t\t\t}\r", "-\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\tnewLinesInWhitespace = 0;\r", "-\t\t\t\tspecialElse = false;\r", "+     pendingSpace = false;\r", "+     indentationOffset = 0;\r", "+    }\r", "+    pendingNewLines = 0;\r", "+    newLinesInWhitespace = 0;\r", "+    specialElse = false;\r", "-\t\t\t\tif (nlicsToken == TokenNamedo && token == TokenNamewhile) {\r", "-\t\t\t\t\tnlicsToken = 0;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "+    if (nlicsToken == TokenNamedo && token == TokenNamewhile) {\r", "+     nlicsToken = 0;\r", "+    }\r", "+   }\r", "-\t\t\tswitch (token) {\r", "-\t\t\t\tcase TokenNameelse :\r", "-\t\t\t\tcase TokenNamefinally :\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\tpendingNewlineAfterParen = true;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamecase :\r", "-\t\t\t\tcase TokenNamedefault :\r", "-\t\t\t\t\tif (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "-\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\ttokenBeforeColon, \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\t(tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\ttokenBeforeColonCount); \r", "-\t\t\t\t\t}\r", "-\t\t\t\t\ttokenBeforeColon[tokenBeforeColonCount++] = TokenNamecase;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(TokenNamecase);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameQUESTION :\r", "-\t\t\t\t\tif (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "-\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\ttokenBeforeColon, \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\t(tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\ttokenBeforeColonCount); \r", "-\t\t\t\t\t}\r", "-\t\t\t\t\ttokenBeforeColon[tokenBeforeColonCount++] = token;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameswitch :\r", "-\t\t\t\tcase TokenNamefor :\r", "-\t\t\t\tcase TokenNameif :\r", "-\t\t\t\tcase TokenNamewhile :\r", "-\t\t\t\t\tif (openParenthesisCount == openParenthesis.length) {\r", "-\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\topenParenthesis, \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\t(openParenthesis = new int[openParenthesisCount * 2]), \r", "-\t\t\t\t\t\t\t\t0, \r", "-\t\t\t\t\t\t\t\topenParenthesisCount); \r", "-\t\t\t\t\t}\r", "-\t\t\t\t\topenParenthesis[openParenthesisCount++] = 0;\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\t\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNametry :\r", "-\t\t\t\t\tpendingNewlineAfterParen = true;\r", "-\t\t\t\tcase TokenNamecatch :\r", "-\t\t\t\t\t// several CATCH statements can be contiguous.\r", "-\t\t\t\t\t// a CATCH is encountered pop until first CATCH (if a CATCH follows a TRY it works the same way,\r", "-\t\t\t\t\t// as CATCH and TRY are the same token in the stack).\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(TokenNamecatch);\r", "-\t\t\t\t\tbreak;\r", "+   switch (token) {\r", "+    case TokenNameelse :\r", "+    case TokenNamefinally :\r", "+     expectingOpenBrace = true;\r", "+     pendingNewlineAfterParen = true;\r", "+     indentationLevel += pushControlStatement(token);\r", "+     break;\r", "+    case TokenNamecase :\r", "+    case TokenNamedefault :\r", "+     if (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "+      System.arraycopy(\r", "+        tokenBeforeColon, \r", "+        0, \r", "+        (tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "+        0, \r", "+        tokenBeforeColonCount); \r", "+     }\r", "+     tokenBeforeColon[tokenBeforeColonCount++] = TokenNamecase;\r", "+     indentationLevel += pushControlStatement(TokenNamecase);\r", "+     break;\r", "+    case TokenNameQUESTION :\r", "+     if (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "+      System.arraycopy(\r", "+        tokenBeforeColon, \r", "+        0, \r", "+        (tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "+        0, \r", "+        tokenBeforeColonCount); \r", "+     }\r", "+     tokenBeforeColon[tokenBeforeColonCount++] = token;\r", "+     break;\r", "+    case TokenNameswitch :\r", "+    case TokenNamefor :\r", "+    case TokenNameif :\r", "+    case TokenNamewhile :\r", "+     if (openParenthesisCount == openParenthesis.length) {\r", "+      System.arraycopy(\r", "+        openParenthesis, \r", "+        0, \r", "+        (openParenthesis = new int[openParenthesisCount * 2]), \r", "+        0, \r", "+        openParenthesisCount); \r", "+     }\r", "+     openParenthesis[openParenthesisCount++] = 0;\r", "+     expectingOpenBrace = true;\r", "+     \r", "+     indentationLevel += pushControlStatement(token);\r", "+     break;\r", "+    case TokenNametry :\r", "+     pendingNewlineAfterParen = true;\r", "+    case TokenNamecatch :\r", "+     // several CATCH statements can be contiguous.\r", "+     // a CATCH is encountered pop until first CATCH (if a CATCH follows a TRY it works the same way,\r", "+     // as CATCH and TRY are the same token in the stack).\r", "+     expectingOpenBrace = true;\r", "+     indentationLevel += pushControlStatement(TokenNamecatch);\r", "+     break;\r", "-\t\t\t\tcase TokenNamedo :\r", "-\t\t\t\t\texpectingOpenBrace = true;\r", "-\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "-\t\t\t\t\tnlicsToken = token;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamenew :\r", "+    case TokenNamedo :\r", "+     expectingOpenBrace = true;\r", "+     indentationLevel += pushControlStatement(token);\r", "+     nlicsToken = token;\r", "+     break;\r", "+    case TokenNamenew :\r", "+     break;\r", "+    case TokenNameLPAREN :\r", "-\t\t\t\t\t// The flag inAssigment is used to properly format\r", "-\t\t\t\t\t// array assignments, and if a non-array assignment\r", "-\t\t\t\t\t// statement is in progress, it is no longer\r", "-\t\t\t\t\t// beneficial to know this, so set the flag to false.\r", "+     // Put a space between the previous and current token if the\r", "+     // previous token was not a keyword, open paren, logical\r", "+     // compliment (eg: !), semi-colon, open brace, close brace,\r", "+     // super, or this.\r", "-/*                  if (!inArrayAssignment) {\r", "-\t\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\t}*/\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameLPAREN :\r", "+     if (previousCompilableToken != TokenNameLBRACKET\r", "+      && previousToken != TokenNameIdentifier\r", "+      && previousToken != 0\r", "+      && previousToken != TokenNameNOT\r", "+      && previousToken != TokenNameLPAREN\r", "+      && previousToken != TokenNameTWIDDLE\r", "+      && previousToken != TokenNameSEMICOLON\r", "+      && previousToken != TokenNameLBRACE\r", "+      && previousToken != TokenNameRBRACE\r", "+      && previousToken != TokenNamesuper\r", "+      && previousToken != TokenNamethis) {\r", "+      space();\r", "+     }\r", "-\t\t\t\t\t// Put a space between the previous and current token if the\r", "-\t\t\t\t\t// previous token was not a keyword, open paren, logical\r", "-\t\t\t\t\t// compliment (eg: !), semi-colon, open brace, close brace,\r", "-\t\t\t\t\t// super, or this.\r", "+     // If in a for/if/while statement, increase the parenthesis count\r", "+     // for the current openParenthesisCount\r", "+     // else increase the count for stand alone parenthesis.\r", "+     if (openParenthesisCount > 0)\r", "+      openParenthesis[openParenthesisCount - 1]++;\r", "+     else\r", "+      openParenthesis[0]++;\r", "-\t\t\t\t\tif (previousCompilableToken != TokenNameLBRACKET\r", "-\t\t\t\t\t\t&& previousToken != TokenNameIdentifier\r", "-\t\t\t\t\t\t&& previousToken != 0\r", "-\t\t\t\t\t\t&& previousToken != TokenNameNOT\r", "-\t\t\t\t\t\t&& previousToken != TokenNameLPAREN\r", "-\t\t\t\t\t\t&& previousToken != TokenNameTWIDDLE\r", "-\t\t\t\t\t\t&& previousToken != TokenNameSEMICOLON\r", "-\t\t\t\t\t\t&& previousToken != TokenNameLBRACE\r", "-\t\t\t\t\t\t&& previousToken != TokenNameRBRACE\r", "-\t\t\t\t\t\t&& previousToken != TokenNamesuper\r", "-\t\t\t\t\t\t&& previousToken != TokenNamethis) {\r", "-\t\t\t\t\t\tspace();\r", "-\t\t\t\t\t}\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameRPAREN :\r", "-\t\t\t\t\t// If in a for/if/while statement, increase the parenthesis count\r", "-\t\t\t\t\t// for the current openParenthesisCount\r", "-\t\t\t\t\t// else increase the count for stand alone parenthesis.\r", "-\t\t\t\t\tif (openParenthesisCount > 0)\r", "-\t\t\t\t\t\topenParenthesis[openParenthesisCount - 1]++;\r", "-\t\t\t\t\telse\r", "-\t\t\t\t\t\topenParenthesis[0]++;\r", "+     // Decrease the parenthesis count\r", "+     // if there is no more unclosed parenthesis,\r", "+     // a new line and indent may be append (depending on the next token).\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameRPAREN :\r", "+     if ((openParenthesisCount > 1)\r", "+      && (openParenthesis[openParenthesisCount - 1] > 0)) {\r", "+      openParenthesis[openParenthesisCount - 1]--;\r", "+      if (openParenthesis[openParenthesisCount - 1] <= 0) {\r", "+       pendingNewlineAfterParen = true;\r", "+       inAssignment = false;\r", "+       openParenthesisCount--;\r", "-\t\t\t\t\t// Decrease the parenthesis count\r", "-\t\t\t\t\t// if there is no more unclosed parenthesis,\r", "-\t\t\t\t\t// a new line and indent may be append (depending on the next token).\r", "+      }\r", "+     } else {\r", "+      openParenthesis[0]--;\r", "+     }\r", "-\t\t\t\t\tif ((openParenthesisCount > 1)\r", "-\t\t\t\t\t\t&& (openParenthesis[openParenthesisCount - 1] > 0)) {\r", "-\t\t\t\t\t\topenParenthesis[openParenthesisCount - 1]--;\r", "-\t\t\t\t\t\tif (openParenthesis[openParenthesisCount - 1] <= 0) {\r", "-\t\t\t\t\t\t\tpendingNewlineAfterParen = true;\r", "-\t\t\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\t\t\topenParenthesisCount--;\r", "-\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\topenParenthesis[0]--;\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameLBRACE :\r", "-\t\t\t\t\tif ((previousCompilableToken == TokenNameRBRACKET) || (previousCompilableToken == TokenNameEQUAL)) {\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameLBRACE :\r", "+     if ((previousCompilableToken == TokenNameRBRACKET) || (previousCompilableToken == TokenNameEQUAL)) {\r", "-\t\t\t\t\t\tinArrayAssignment = true;\r", "-\t\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (inArrayAssignment) {\r", "-\t\t\t\t\t\tindentationLevel += pushBlock();\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t// Add new line and increase indentation level after open brace.\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tindentationLevel += pushBlock();\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameRBRACE :\r", "-\t\t\t\t\tif (previousCompilableToken == TokenNameRPAREN) {\r", "-\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (inArrayAssignment) {\r", "-\t\t\t\t\t\tinArrayAssignment = false;\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntilBlock();\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tindentationLevel += popInclusiveUntilBlock();\r", "+      inArrayAssignment = true;\r", "+      inAssignment = false;\r", "+     }\r", "+     if (inArrayAssignment) {\r", "+      indentationLevel += pushBlock();\r", "+     } else {\r", "+      // Add new line and increase indentation level after open brace.\r", "+      pendingNewLines = 1;\r", "+      indentationLevel += pushBlock();\r", "+     }\r", "+     break;\r", "+    case TokenNameRBRACE :\r", "+     if (previousCompilableToken == TokenNameRPAREN) {\r", "+      pendingSpace = false;\r", "+     }\r", "+     if (inArrayAssignment) {\r", "+      inArrayAssignment = false;\r", "+      pendingNewLines = 1;\r", "+      indentationLevel += popInclusiveUntilBlock();\r", "+     } else {\r", "+      pendingNewLines = 1;\r", "+      indentationLevel += popInclusiveUntilBlock();\r", "-\t\t\t\t\t\tif (previousCompilableToken == TokenNameRPAREN){\r", "-\t\t\t\t\t\t\t// fix for 1FGDDV6: LFCOM:WIN98 - Weird splitting on message expression\r", "-\t\t\t\t\t\t\tcurrentLineBuffer.append(options.lineSeparatorSequence);\r", "-\t\t\t\t\t\t\tincreaseLineDelta(options.lineSeparatorSequence.length);                            \r", "-\t\t\t\t\t\t}\r", "+      if (previousCompilableToken == TokenNameRPAREN){\r", "+       // fix for 1FGDDV6: LFCOM:WIN98 - Weird splitting on message expression\r", "+       currentLineBuffer.append(options.lineSeparatorSequence);\r", "+       increaseLineDelta(options.lineSeparatorSequence.length);                            \r", "+      }\r", "-\t\t\t\t\t\tif (constructionsCount > 0) {\r", "-\t\t\t\t\t\t\tswitch (constructions[constructionsCount - 1]) {\r", "-\t\t\t\t\t\t\t\tcase TokenNamefor :\r", "-\t\t\t\t\t\t\t\t\t//indentationLevel += popExclusiveUntilBlock();\r", "-\t\t\t\t\t\t\t\t\t//break;\r", "-\t\t\t\t\t\t\t\tcase TokenNameswitch :\r", "-\t\t\t\t\t\t\t\tcase TokenNameif :\r", "-\t\t\t\t\t\t\t\tcase TokenNameelse :\r", "-\t\t\t\t\t\t\t\tcase TokenNametry :\r", "-\t\t\t\t\t\t\t\tcase TokenNamecatch :\r", "-\t\t\t\t\t\t\t\tcase TokenNamefinally :\r", "-\t\t\t\t\t\t\t\tcase TokenNamewhile :\r", "-\t\t\t\t\t\t\t\tcase TokenNamedo :\r", "-\t\t\t\t\t\t\t\t\tclearNonBlockIndents = true;\r", "-\t\t\t\t\t\t\t\tdefault :\r", "-\t\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "+      if (constructionsCount > 0) {\r", "+       switch (constructions[constructionsCount - 1]) {\r", "+        case TokenNamefor :\r", "+         //indentationLevel += popExclusiveUntilBlock();\r", "+         //break;\r", "+        case TokenNameswitch :\r", "+        case TokenNameif :\r", "+        case TokenNameelse :\r", "+        case TokenNametry :\r", "+        case TokenNamecatch :\r", "+        case TokenNamefinally :\r", "+        case TokenNamewhile :\r", "+        case TokenNamedo :\r", "+         clearNonBlockIndents = true;\r", "+        default :\r", "+         break;\r", "+       }\r", "+      }\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameLBRACKET :\r", "-\t\t\t\t\topenBracketCount++;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameRBRACKET :\r", "-\t\t\t\t\topenBracketCount-=(openBracketCount>0)?1:0;\r", "-\t\t\t\t\t// if there is no left bracket to close, the right bracket is ignored.\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameCOMMA :\r", "-\t\t\t\tcase TokenNameDOT :\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameSEMICOLON :\r", "+     }\r", "+     break;\r", "+    case TokenNameLBRACKET :\r", "+     openBracketCount++;\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameRBRACKET :\r", "+     openBracketCount-=(openBracketCount>0)?1:0;\r", "+     // if there is no left bracket to close, the right bracket is ignored.\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameCOMMA :\r", "+    case TokenNameDOT :\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNameSEMICOLON :\r", "-\t\t\t\t\t// Do not generate line terminators in the definition of\r", "-\t\t\t\t\t// the for statement.\r", "-\t\t\t\t\t// if not in this case, jump a line and reduce indentation after the brace\r", "-\t\t\t\t\t// if the block it closes belongs to a conditional statement (if, while, do...).\r", "+     // Do not generate line terminators in the definition of\r", "+     // the for statement.\r", "+     // if not in this case, jump a line and reduce indentation after the brace\r", "+     // if the block it closes belongs to a conditional statement (if, while, do...).\r", "-\t\t\t\t\tif (openParenthesisCount <= 1) {\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\tif (expectingOpenBrace) {\r", "-\t\t\t\t\t\t\tclearNonBlockIndents = true;\r", "-\t\t\t\t\t\t\texpectingOpenBrace = false;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tinAssignment = false;\r", "-\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamePLUS_PLUS :\r", "-\t\t\t\tcase TokenNameMINUS_MINUS :\r", "+     if (openParenthesisCount <= 1) {\r", "+      pendingNewLines = 1;\r", "+      if (expectingOpenBrace) {\r", "+       clearNonBlockIndents = true;\r", "+       expectingOpenBrace = false;\r", "+      }\r", "+     }\r", "+     inAssignment = false;\r", "+     pendingSpace = false;\r", "+     break;\r", "+    case TokenNamePLUS_PLUS :\r", "+    case TokenNameMINUS_MINUS :\r", "-\t\t\t\t\t// Do not put a space between a post-increment/decrement\r", "-\t\t\t\t\t// and the identifier being modified.\r", "+     // Do not put a space between a post-increment/decrement\r", "+     // and the identifier being modified.\r", "-\t\t\t\t\tif (previousToken == TokenNameIdentifier\r", "-\t\t\t\t\t\t|| previousToken == TokenNameRBRACKET) {\r", "-\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNamePLUS : // previously ADDITION\r", "-\t\t\t\tcase TokenNameMINUS :\r", "+     if (previousToken == TokenNameIdentifier\r", "+      || previousToken == TokenNameRBRACKET) {\r", "+      pendingSpace = false;\r", "+     }\r", "+     break;\r", "+    case TokenNamePLUS : // previously ADDITION\r", "+    case TokenNameMINUS :\r", "-\t\t\t\t\t// Handle the unary operators plus and minus via a 3-state flag.\r", "+     // Handle the unary operators plus and minus via a flag\r", "-\t\t\t\t\tif (!isLiteralToken(previousToken)\r", "-\t\t\t\t\t\t&& previousToken != TokenNameIdentifier\r", "-\t\t\t\t\t\t&& previousToken != TokenNameRPAREN\r", "-\t\t\t\t\t\t&& previousToken != TokenNameRBRACKET) {\r", "-\t\t\t\t\t\tunarySignModifier = 2;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameCOLON :\r", "+     if (!isLiteralToken(previousToken)\r", "+      && previousToken != TokenNameIdentifier\r", "+      && previousToken != TokenNameRPAREN\r", "+      && previousToken != TokenNameRBRACKET) {\r", "+      unarySignModifier = 1;\r", "+     }\r", "+     break;\r", "+    case TokenNameCOLON :\r", "+     // In a switch/case statement, add a newline & indent\r", "+     // when a colon is encountered.\r", "+     if (tokenBeforeColonCount > 0) {\r", "+      if (tokenBeforeColon[tokenBeforeColonCount - 1] == TokenNamecase) {\r", "+       pendingNewLines = 1;\r", "+      }\r", "+      tokenBeforeColonCount--;\r", "+     }\r", "+     break;\r", "+    case TokenNameEQUAL :\r", "+     inAssignment = true;\r", "+     break;\r", "+    case Scanner.TokenNameCOMMENT_LINE :\r", "+     pendingNewLines = 1;\r", "+     if (inAssignment) {\r", "+      currentLineIndentationLevel++;\r", "+     }\r", "+     break; // a line is always inserted after a one-line comment\r", "+    case Scanner.TokenNameCOMMENT_JAVADOC :\r", "+    case Scanner.TokenNameCOMMENT_BLOCK :\r", "+     currentCommentOffset = getCurrentCommentOffset();\r", "+     if (openParenthesis[0]==0 && openBracketCount < 1){\r", "+      pendingNewLines = 1;\r", "+      // a new line is inserted only if the comment is not between parenthesis.\r", "+     }\r", "+     break;\r", "+    case Scanner.TokenNameWHITESPACE :\r", "-\t\t\t\t\t// In a switch/case statement, add a newline & indent\r", "-\t\t\t\t\t// when a colon is encountered.\r", "-\t\t\t\t\tif (tokenBeforeColonCount > 0) {\r", "-\t\t\t\t\t\tif (tokenBeforeColon[tokenBeforeColonCount - 1] == TokenNamecase) {\r", "-\t\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\ttokenBeforeColonCount--;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TokenNameEQUAL :\r", "-\t\t\t\t\tinAssignment = true;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase Scanner.TokenNameCOMMENT_LINE :\r", "-\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\tif (inAssignment) {\r", "-\t\t\t\t\t\tcurrentLineIndentationLevel++;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak; // a line is always inserted after a one-line comment\r", "-\t\t\t\tcase Scanner.TokenNameCOMMENT_JAVADOC :\r", "-\t\t\t\tcase Scanner.TokenNameCOMMENT_BLOCK :\r", "-\t\t\t\t\tcurrentCommentOffset = getCurrentCommentOffset();\r", "-\t\t\t\t\tif (openParenthesis[0]==0 && openBracketCount < 1){\r", "-\t\t\t\t\t\tpendingNewLines = 1;\r", "-\t\t\t\t\t\t// a new line is inserted only if the comment is not between parenthesis.\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase Scanner.TokenNameWHITESPACE :\r", "+     // Count the number of line terminators in the whitespace so\r", "+     // line spacing can be preserved near comments.\r", "-\t\t\t\t\t// Count the number of line terminators in the whitespace so\r", "-\t\t\t\t\t// line spacing can be preserved near comments.\r", "+     char[] source = scanner.source;\r", "+     newLinesInWhitespace = 0;\r", "+     for (\r", "+      int i = scanner.startPosition, max = scanner.currentPosition; \r", "+      i < max; \r", "+      i++) {\r", "+      if (source[i] == '\\n') {\r", "+       newLinesInWhitespace++;\r", "+      }\r", "+     }\r", "+     increaseLineDelta(scanner.startPosition - scanner.currentPosition);\r", "+     break;\r", "+    default :\r", "+     if ((token == TokenNameIdentifier)\r", "+      || isLiteralToken(token)\r", "+      || token == TokenNamesuper\r", "+      || token == TokenNamethis) {\r", "-\t\t\t\t\tchar[] source = scanner.source;\r", "-\t\t\t\t\tnewLinesInWhitespace = 0;\r", "-\t\t\t\t\tfor (\r", "-\t\t\t\t\t\tint i = scanner.startPosition, max = scanner.currentPosition; \r", "-\t\t\t\t\t\ti < max; \r", "-\t\t\t\t\t\ti++) {\r", "-\t\t\t\t\t\tif (source[i] == '\\n') {\r", "-\t\t\t\t\t\t\tnewLinesInWhitespace++;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tincreaseLineDelta(scanner.startPosition - scanner.currentPosition);\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tdefault :\r", "-\t\t\t\t\tif ((token == TokenNameIdentifier)\r", "-\t\t\t\t\t\t|| isLiteralToken(token)\r", "-\t\t\t\t\t\t|| token == TokenNamesuper\r", "-\t\t\t\t\t\t|| token == TokenNamethis) {\r", "+      // Do not put a space between a unary operator\r", "+      // (eg: ++, --, +, -) and the identifier being modified.\r", "+      if (previousToken == TokenNamePLUS_PLUS\r", "+       || previousToken == TokenNameMINUS_MINUS\r", "+       || (previousToken == TokenNamePLUS && unarySignModifier > 0)\r", "+       || (previousToken == TokenNameMINUS && unarySignModifier > 0)) {\r", "+       pendingSpace = false;\r", "+      }\r", "+      unarySignModifier = 0;\r", "+     }\r", "+     break;\r", "+   }\r", "-\t\t\t\t\t\t// Do not put a space between a unary operator\r", "-\t\t\t\t\t\t// (eg: ++, --, +, -) and the identifier being modified.\r", "+   // Do not output whitespace tokens.\r", "-\t\t\t\t\t\tunarySignModifier -= (unarySignModifier > 0) ? 1 : 0;\r", "-\t\t\t\t\t\tif (previousToken == TokenNamePLUS_PLUS\r", "-\t\t\t\t\t\t\t|| previousToken == TokenNameMINUS_MINUS\r", "-\t\t\t\t\t\t\t|| (unarySignModifier > 0)) {\r", "-\t\t\t\t\t\t\tpendingSpace = false;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t}\r", "+   if (token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t// Do not output whitespace tokens.\r", "+    /* Add pending space to the formatted source string.\r", "+    Do not output a space under the following circumstances:\r", "+    1) this is the first pass\r", "+    2) previous token is an open paren\r", "+    3) previous token is a period\r", "+    4) previous token is the logical compliment (eg: !)\r", "+    5) previous token is the bitwise compliment (eg: ~)\r", "+    6) previous token is the open bracket (eg: [)\r", "+    7) in an assignment statement, if the previous token is an \r", "+    open brace or the current token is a close brace\r", "+    8) previous token is a single line comment\r", "+    */\r", "-\t\t\tif (token != Scanner.TokenNameWHITESPACE) {\r", "+    boolean openAndCloseBrace = previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE;\r", "-\t\t\t\t/* Add pending space to the formatted source string.\r", "-\t\t\t\tDo not output a space under the following circumstances:\r", "-\t\t\t\t1) this is the first pass\r", "-\t\t\t\t2) previous token is an open paren\r", "-\t\t\t\t3) previous token is a period\r", "-\t\t\t\t4) previous token is the logical compliment (eg: !)\r", "-\t\t\t\t5) previous token is the bitwise compliment (eg: ~)\r", "-\t\t\t\t6) previous token is the open bracket (eg: [)\r", "-\t\t\t\t7) in an assignment statement, if the previous token is an \r", "-\t\t\t\topen brace or the current token is a close brace\r", "-\t\t\t\t8) previous token is a single line comment\r", "-\t\t\t\t*/\r", "+    // to be replaced by a nicer condition.\r", "+   \r", "+    if (pendingSpace\r", "+     && insertSpaceAfter(previousToken)\r", "+     && ! (inAssignment\r", "+      && (previousToken == TokenNameLBRACE || token == TokenNameRBRACE))\r", "+     && previousToken != Scanner.TokenNameCOMMENT_LINE) {\r", "+     if ((! (options.compactAssignmentMode && token == TokenNameEQUAL)) && !openAndCloseBrace)\r", "+      space();\r", "+    }\r", "-\t\t\t\tboolean openAndCloseBrace = previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE;\r", "+    // Add the next token to the formatted source string.\r", "-\t\t\t\t// to be replaced by a nicer condition.\r", "-\t\t\t\r", "-\t\t\t\tif (pendingSpace\r", "-\t\t\t\t\t&& insertSpaceAfter(previousToken)\r", "-\t\t\t\t\t&& ! (inAssignment\r", "-\t\t\t\t\t\t&& (previousToken == TokenNameLBRACE || token == TokenNameRBRACE))\r", "-\t\t\t\t\t&& previousToken != Scanner.TokenNameCOMMENT_LINE) {\r", "-\t\t\t\t\tif ((! (options.compactAssignmentMode && token == TokenNameEQUAL)) && !openAndCloseBrace)\r", "-\t\t\t\t\t\tspace();\r", "-\t\t\t\t}\r", "+    outputCurrentToken(token);\r", "+    if (token == Scanner.TokenNameCOMMENT_LINE && openParenthesisCount > 1){\r", "+     pendingNewLines = 0;\r", "+     currentLineBuffer.append(options.lineSeparatorSequence);\r", "+     increaseLineDelta(options.lineSeparatorSequence.length);                    \r", "+    }\r", "+    pendingSpace = true;\r", "+   }\r", "-\t\t\t\t// Add the next token to the formatted source string.\r", "+   // Whitespace tokens do not need to be remembered.\r", "-\t\t\t\toutputCurrentToken(token);\r", "-\t\t\t\tif (token == Scanner.TokenNameCOMMENT_LINE && openParenthesisCount > 1){\r", "-\t\t\t\t\tpendingNewLines = 0;\r", "-\t\t\t\t\tcurrentLineBuffer.append(options.lineSeparatorSequence);\r", "-\t\t\t\t\tincreaseLineDelta(options.lineSeparatorSequence.length);                    \r", "-\t\t\t\t}\r", "-\t\t\t\tpendingSpace = true;\r", "-\t\t\t}\r", "+   if (token != Scanner.TokenNameWHITESPACE) {\r", "+    previousToken = token;\r", "+    if (token != Scanner.TokenNameCOMMENT_BLOCK\r", "+     && token != Scanner.TokenNameCOMMENT_LINE\r", "+     && token != Scanner.TokenNameCOMMENT_JAVADOC) {\r", "+     previousCompilableToken = token;\r", "+    }\r", "+   }\r", "-\t\t\t// Whitespace tokens do not need to be remembered.\r", "-\r", "-\t\t\tif (token != Scanner.TokenNameWHITESPACE) {\r", "-\t\t\t\tpreviousToken = token;\r", "-\t\t\t\tif (token != Scanner.TokenNameCOMMENT_BLOCK\r", "-\t\t\t\t\t&& token != Scanner.TokenNameCOMMENT_LINE\r", "-\t\t\t\t\t&& token != Scanner.TokenNameCOMMENT_JAVADOC) {\r", "-\t\t\t\t\tpreviousCompilableToken = token;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t}\r", "-\t\toutput(copyRemainingSource());\r", "-\t\tflushBuffer(); // dump the last token of the source in the formatted output.\r", "-\t} catch (InvalidInputException e) {\r", "-\t\toutput(copyRemainingSource());\r", "-\t\tflushBuffer(); // dump the last token of the source in the formatted output.\r", "-\t}\r", "+  }\r", "+  output(copyRemainingSource());\r", "+  flushBuffer(); // dump the last token of the source in the formatted output.\r", "+ } catch (InvalidInputException e) {\r", "+  output(copyRemainingSource());\r", "+  flushBuffer(); // dump the last token of the source in the formatted output.\r", "+ }\r"]}], "num": 53552}