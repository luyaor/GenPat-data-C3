{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "337bcee8675a8e2b4e1f0e6b69a44665", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2142025c889e31a0c2650f73b910b617", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "bf0bb24ad2aa11936f786fa3a21e4724052c7919", "commitAfterChange": "3f4c816813820db669d197557cb718b17b2bf721", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tprivate boolean parseHref() throws InvalidInputException", "signatureAfterChange": " \tprivate boolean parseHref() throws InvalidInputException", "diff": ["-\t\t\t\t\tif (CharOperation.equals(this.scanner.getCurrentIdentifierSource(), new char[]{'h', 'r', 'e', 'f'}, false) &&", "+\t\t\t\t\tif (CharOperation.equals(this.scanner.getCurrentIdentifierSource(), HREF_TAG, false) &&", "-\t\t\t\t\t\t\t// Skip all characters after string literal until closing '>' (see bug 68726)", "-\t\t\t\t\t\t\twhile (readToken() != TerminalTokens.TokenNameGREATER) {", "-\t\t\t\t\t\t\t\tif (this.scanner.currentPosition >= this.scanner.eofPosition || this.scanner.currentCharacter == '@' ||", "-\t\t\t\t\t\t\t\t\t(this.inlineTagStarted && this.scanner.currentCharacter == '}')) {", "-\t\t\t\t\t\t\t\t\t// Reset position: we want to rescan last token", "-\t\t\t\t\t\t\t\t\tthis.index = this.tokenPreviousPosition;", "-\t\t\t\t\t\t\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "-\t\t\t\t\t\t\t\t\tthis.currentTokenType = -1;", "-\t\t\t\t\t\t\t\t\t// Signal syntax error", "-\t\t\t\t\t\t\t\t\tif (this.tagValue != TAG_VALUE_VALUE) { // do not report error for @value tag, this will be done after...", "-\t\t\t\t\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidSeeUrlReference(start, this.lineEnd);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tthis.currentTokenType = -1; // do not update line end", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (this.currentTokenType == TerminalTokens.TokenNameGREATER) {", "-\t\t\t\t\t\t\t\tconsumeToken(); // update line end as new lines are allowed in URL description", "-\t\t\t\t\t\t\t\twhile (readToken() != TerminalTokens.TokenNameLESS) {", "+\t\t\t\t\t\t\twhile (this.index < this.javadocEnd) { // main loop to search for the </a> pattern", "+\t\t\t\t\t\t\t\t// Skip all characters after string literal until closing '>' (see bug 68726)", "+\t\t\t\t\t\t\t\twhile (readToken() != TerminalTokens.TokenNameGREATER) {", "-\t\t\t\t\t\t\t\t\t\t(this.inlineTagStarted && this.scanner.currentCharacter == '}')) {", "+\t\t\t\t\t\t\t\t\t\t\t(this.inlineTagStarted && this.scanner.currentCharacter == '}')) {", "-\t\t\t\t\t\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidSeeUrlReference(start, this.lineEnd);", "+\t\t\t\t\t\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidSeeHref(start, this.lineEnd);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tthis.currentTokenType = -1; // consume token without updating line end", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tconsumeToken(); // update line end as new lines are allowed in URL description", "+\t\t\t\t\t\t\t\twhile (readToken() != TerminalTokens.TokenNameLESS) {", "+\t\t\t\t\t\t\t\t\tif (this.scanner.currentPosition >= this.scanner.eofPosition || this.scanner.currentCharacter == '@' ||", "+\t\t\t\t\t\t\t\t\t\t\t(this.inlineTagStarted && this.scanner.currentCharacter == '}')) {", "+\t\t\t\t\t\t\t\t\t\t// Reset position: we want to rescan last token", "+\t\t\t\t\t\t\t\t\t\tthis.index = this.tokenPreviousPosition;", "+\t\t\t\t\t\t\t\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t\t\t\t\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\t\t\t\t\t\t// Signal syntax error", "+\t\t\t\t\t\t\t\t\t\tif (this.tagValue != TAG_VALUE_VALUE) { // do not report error for @value tag, this will be done after...", "+\t\t\t\t\t\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidSeeHref(start, this.lineEnd);", "-\t\t\t\t\t\t\t\tif (readChar() == '/') {", "+\t\t\t\t\t\t\t\tcurrentChar = readChar();", "+\t\t\t\t\t\t\t\t// search for the </a> pattern and store last char read", "+\t\t\t\t\t\t\t\tif (currentChar == '/') {", "-\t\t\t\t\t\t\t\t\tif (currentChar == 'a' || currentChar == 'A') {", "-\t\t\t\t\t\t\t\t\t\tif (readChar() == '>') {", "-\t\t\t\t\t\t\t\t\t\t\t// Valid href", "-\t\t\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t\tif (currentChar == 'a' || currentChar =='A') {", "+\t\t\t\t\t\t\t\t\t\tcurrentChar = readChar();", "+\t\t\t\t\t\t\t\t\t\tif (currentChar == '>') {", "+\t\t\t\t\t\t\t\t\t\t\treturn true; // valid href", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t// search for invalid char in tags", "+\t\t\t\t\t\t\t\tif (currentChar == '\\r' || currentChar == '\\n' || currentChar == '\\t' || currentChar == ' ') {", "+\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidSeeUrlReference(start, this.lineEnd);", "+\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidSeeHref(start, this.lineEnd);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e322adbd293c8587d3e0ba7fa98ab4ec", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "3cbc5a17035fd93e630a5ce3a447371924b2eaec", "commitAfterChange": "2fbac062d3f933d7974166e3d20ea9843fdd9750", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 61, "signatureBeforeChange": " \tvoid printComment(int kind, int trailing)", "signatureAfterChange": " \tvoid printComment(int kind, int trailing)", "diff": ["-\t\t\t\t\t\tif (trailing == IMPORT_TRAILING_COMMENT && this.scanner.currentCharacter == '/' && lines <= 1) {", "-\t\t\t\t\t\t\tint currentPosition = this.scanner.currentPosition;", "-\t\t\t\t\t\t\tif (this.scanner.getNextToken() == TerminalTokens.TokenNameCOMMENT_LINE) {", "-\t\t\t\t\t\t\t\tint token = this.scanner.getNextToken();", "-\t\t\t\t\t\t\t\twhile (token == TerminalTokens.TokenNameCOMMENT_LINE) {", "-\t\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "-\t\t\t\t\t\t\t\t\tchar[] secondWhiteSpaces = this.scanner.getCurrentTokenSource();", "-\t\t\t\t\t\t\t\t\tloop: for (int i = 0, max = secondWhiteSpaces.length; i < max; i++) {", "-\t\t\t\t\t\t\t\t\t\tswitch(secondWhiteSpaces[i]) {", "-\t\t\t\t\t\t\t\t\t\t\tcase '\\r' :", "-\t\t\t\t\t\t\t\t\t\t\tcase '\\n' :", "-\t\t\t\t\t\t\t\t\t\t\t\trealTrailing = false;", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (realTrailing && this.scanner.currentCharacter == '/' && (lines == 0 || (lines == 1 && !hasLineComment && trailing == IMPORT_TRAILING_COMMENT))) {", "+\t\t\t\t\t\t\t// sometimes changing the trailing may not be the best idea", "+\t\t\t\t\t\t\t// for complex trailing comment, it's basically a good idea", "+\t\t\t\t\t\t\tboolean canChangeTrailing = (trailing & COMPLEX_TRAILING_COMMENT) != 0;", "+\t\t\t\t\t\t\t// for basic trailing comment preceded by a line comment, then it depends on the comments relative position", "+\t\t\t\t\t\t\t// when following comment column (after having been rounded) is below the preceding one,", "+\t\t\t\t\t\t\t// then it becomes not a good idea to change the trailing flag", "+\t\t\t\t\t\t\tif (trailing == BASIC_TRAILING_COMMENT && hasLineComment) {", "+\t\t\t\t\t\t\t\tint currentCommentColumn = getCurrentColumn(whiteSpaces);", "+\t\t\t\t\t\t\t\tint lastCommentColumn = this.lastLineComment.currentColumn;", "+\t\t\t\t\t\t\t\tif (this.tabLength > 0) {", "+\t\t\t\t\t\t\t\t\tif ((currentCommentColumn % this.tabLength) == 0) {", "+\t\t\t\t\t\t\t\t\t\tlastCommentColumn = (lastCommentColumn / this.tabLength) * this.tabLength;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tcurrentCommentColumn = ((currentCommentColumn / this.tabLength) + 1) * this.tabLength;", "+\t\t\t\t\t\t\t\tcanChangeTrailing = currentCommentColumn >= lastCommentColumn;", "-\t\t\t\t\t\t\tthis.scanner.resetTo(currentPosition, this.scanner.eofPosition - 1);", "+\t\t\t\t\t\t\t// if the trailing can be change, then look at the following tokens", "+\t\t\t\t\t\t\tif (canChangeTrailing) {", "+\t\t\t\t\t\t\t\tint currentPosition = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\tif (this.scanner.getNextToken() == TerminalTokens.TokenNameCOMMENT_LINE) {", "+\t\t\t\t\t\t\t\t\trealTrailing = !hasLineComment;", "+\t\t\t\t\t\t\t\t\tswitch (this.scanner.getNextToken()) {", "+\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameCOMMENT_LINE:", "+\t\t\t\t\t\t\t\t\t\t\t// at least two contiguous line comments", "+\t\t\t\t\t\t\t\t\t\t\t// the formatter should not consider comments as trailing ones", "+\t\t\t\t\t\t\t\t\t\t\trealTrailing = false;", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\t\t\t\t\tif (this.scanner.getNextToken() == TerminalTokens.TokenNameCOMMENT_LINE) {", "+\t\t\t\t\t\t\t\t\t\t\t\t// at least two contiguous line comments", "+\t\t\t\t\t\t\t\t\t\t\t\t// the formatter should not consider comments as trailing ones", "+\t\t\t\t\t\t\t\t\t\t\t\trealTrailing = false;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tthis.scanner.resetTo(currentPosition, this.scanner.eofPosition - 1);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t// Look whether comments line may be contiguous or not", "+\t\t\t\t\t\t// Note that when preceding token is a comment line, then only one line", "+\t\t\t\t\t\t// is enough to have an empty line as the line end is included in the comment line...", "+\t\t\t\t\t\t// If comments are contiguous, store the white spaces to be able to compute the current comment indentation", "+\t\t\t\t\t\tif (lines > 1 || (lines == 1 && hasLineComment)) {", "+\t\t\t\t\t\t\tthis.lastLineComment.contiguous = false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.lastLineComment.leadingSpaces = whiteSpaces;", "+\t\t\t\t\t\tthis.lastLineComment.lines = lines;", "+\t\t\t\t\t\t// Strategy to consume spaces and eventually leave at this stage", "+\t\t\t\t\t\t// depends on the fact that a trailing comment is expected or not", "+\t\t\t\t\t\tthis.lastLineComment.contiguous = false;", "+\t\t\t\t\t\tthis.lastLineComment.contiguous = false;", "+\t\t\t\t\t\tthis.lastLineComment.contiguous = false;"]}], "num": 23788}