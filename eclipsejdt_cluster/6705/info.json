{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "233de15596ff8c0e151f45a968a2bb2d", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3717a4ca83f4f0a2ed1e13f266ac7d2e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "415e478fd80c86e1c699eefa6d86979134ae5921", "commitAfterChange": "63b8bf54c7c6ab31eaeaf33c9d376ceaa28b674d", "methodNumberBeforeChange": 69, "methodNumberAfterChange": 69, "signatureBeforeChange": " \tpublic static void setClasspathContainer(final IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " \tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\tpublic static void setClasspathContainer(final IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException {", "-", "-\t\tif (affectedProjects.length != respectiveContainers.length) Assert.isTrue(false, \"Projects and containers collections should have the same size\"); //$NON-NLS-1$", "-\t", "-\t\tif (monitor != null && monitor.isCanceled()) return;", "-\t", "-\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){", "-\t\t\tUtil.verbose(", "-\t\t\t\t\"CPContainer SET  - setting container\\n\" + //$NON-NLS-1$", "-\t\t\t\t\"\tcontainer path: \" + containerPath + '\\n' + //$NON-NLS-1$", "-\t\t\t\t\"\tprojects: {\" +//$NON-NLS-1$", "-\t\t\t\torg.eclipse.jdt.internal.compiler.util.Util.toString(", "-\t\t\t\t\taffectedProjects, ", "-\t\t\t\t\tnew org.eclipse.jdt.internal.compiler.util.Util.Displayable(){ ", "-\t\t\t\t\t\tpublic String displayString(Object o) { return ((IJavaProject) o).getElementName(); }", "-\t\t\t\t\t}) +", "-\t\t\t\t\"}\\n\tvalues: {\\n\"  +//$NON-NLS-1$", "-\t\t\t\torg.eclipse.jdt.internal.compiler.util.Util.toString(", "-\t\t\t\t\trespectiveContainers, ", "-\t\t\t\t\tnew org.eclipse.jdt.internal.compiler.util.Util.Displayable(){ ", "-\t\t\t\t\t\tpublic String displayString(Object o) { ", "-\t\t\t\t\t\t\tStringBuffer buffer = new StringBuffer(\"\t\t\"); //$NON-NLS-1$", "-\t\t\t\t\t\t\tif (o == null) {", "-\t\t\t\t\t\t\t\tbuffer.append(\"<null>\"); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\treturn buffer.toString();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tIClasspathContainer container = (IClasspathContainer) o;", "-\t\t\t\t\t\t\tbuffer.append(container.getDescription());", "-\t\t\t\t\t\t\tbuffer.append(\" {\\n\"); //$NON-NLS-1$", "-\t\t\t\t\t\t\tIClasspathEntry[] entries = container.getClasspathEntries();", "-\t\t\t\t\t\t\tif (entries != null){", "-\t\t\t\t\t\t\t\tfor (int i = 0; i < entries.length; i++){", "-\t\t\t\t\t\t\t\t\tbuffer.append(\" \t\t\t\"); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\tbuffer.append(entries[i]); ", "-\t\t\t\t\t\t\t\t\tbuffer.append('\\n'); ", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbuffer.append(\" \t\t}\"); //$NON-NLS-1$", "-\t\t\t\t\t\t\treturn buffer.toString();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}) +", "-\t\t\t\t\"\\n\t}\\n\tinvocation stack trace:\"); //$NON-NLS-1$", "-\t\t\t\tnew Exception(\"<Fake exception>\").printStackTrace(System.out); //$NON-NLS-1$", "-\t\t}", "-\t\t", "-\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t\tif (manager.containerPutIfInitializingWithSameEntries(containerPath, affectedProjects, respectiveContainers))", "-\t\t\treturn;", "-", "-\t\tfinal int projectLength = affectedProjects.length;\t", "-\t\tfinal IJavaProject[] modifiedProjects;", "-\t\tSystem.arraycopy(affectedProjects, 0, modifiedProjects = new IJavaProject[projectLength], 0, projectLength);", "-\t\tfinal IClasspathEntry[][] oldResolvedPaths = new IClasspathEntry[projectLength][];", "-\t\t\t", "-\t\t// filter out unmodified project containers", "-\t\tint remaining = 0;", "-\t\tfor (int i = 0; i < projectLength; i++){", "-\t", "-\t\t\tif (monitor != null && monitor.isCanceled()) return;", "-\t", "-\t\t\tJavaProject affectedProject = (JavaProject) affectedProjects[i];", "-\t\t\tIClasspathContainer newContainer = respectiveContainers[i];", "-\t\t\tif (newContainer == null) newContainer = JavaModelManager.CONTAINER_INITIALIZATION_IN_PROGRESS; // 30920 - prevent infinite loop", "-\t\t\tboolean found = false;", "-\t\t\tif (JavaProject.hasJavaNature(affectedProject.getProject())){", "-\t\t\t\tIClasspathEntry[] rawClasspath = affectedProject.getRawClasspath();", "-\t\t\t\tfor (int j = 0, cpLength = rawClasspath.length; j <cpLength; j++) {", "-\t\t\t\t\tIClasspathEntry entry = rawClasspath[j];", "-\t\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER && entry.getPath().equals(containerPath)){", "-\t\t\t\t\t\tfound = true;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (!found){", "-\t\t\t\tmodifiedProjects[i] = null; // filter out this project - does not reference the container path, or isnt't yet Java project", "-\t\t\t\tmanager.containerPut(affectedProject, containerPath, newContainer);", "-\t\t\t\tcontinue;", "-\t\t\t}", "-\t\t\tIClasspathContainer oldContainer = manager.containerGet(affectedProject, containerPath);", "-\t\t\tif (oldContainer == JavaModelManager.CONTAINER_INITIALIZATION_IN_PROGRESS) {", "-//\t\t\t\tMap previousContainerValues = (Map)JavaModelManager.getJavaModelManager().previousSessionContainers.get(affectedProject);", "-//\t\t\t\tif (previousContainerValues != null){", "-//\t\t\t\t\tIClasspathContainer previousContainer = (IClasspathContainer)previousContainerValues.get(containerPath);", "-//\t\t\t\t\tif (previousContainer != null) {", "-//\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){", "-//\t\t\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "-//\t\t\t\t\t\t\tbuffer.append(\"CPContainer INIT - reentering access to project container during its initialization, will see previous value\\n\"); ", "-//\t\t\t\t\t\t\tbuffer.append(\"\tproject: \" + affectedProject.getElementName() + '\\n');", "-//\t\t\t\t\t\t\tbuffer.append(\"\tcontainer path: \" + containerPath + '\\n');", "-//\t\t\t\t\t\t\tbuffer.append(\"\tprevious value: \");", "-//\t\t\t\t\t\t\tbuffer.append(previousContainer.getDescription());", "-//\t\t\t\t\t\t\tbuffer.append(\" {\\n\");", "-//\t\t\t\t\t\t\tIClasspathEntry[] entries = previousContainer.getClasspathEntries();", "-//\t\t\t\t\t\t\tif (entries != null){", "-//\t\t\t\t\t\t\t\tfor (int j = 0; j < entries.length; j++){", "-//\t\t\t\t\t\t\t\t\tbuffer.append(\" \t\t\");", "-//\t\t\t\t\t\t\t\t\tbuffer.append(entries[j]); ", "-//\t\t\t\t\t\t\t\t\tbuffer.append('\\n'); ", "-//\t\t\t\t\t\t\t\t}", "-//\t\t\t\t\t\t\t}", "-//\t\t\t\t\t\t\tbuffer.append(\" \t}\");", "-//\t\t\t\t\t\t\tUtil.verbose(buffer.toString());", "-//\t\t\t\t\t\t}", "-//\t\t\t\t\t\tJavaModelManager.getJavaModelManager().containerPut(affectedProject, containerPath, previousContainer); ", "-//\t\t\t\t\t}", "-//\t\t\t\t\toldContainer = null; //33695 - cannot filter out restored container, must update affected project to reset cached CP", "-//\t\t\t\t} else {", "-\t\t\t\t\toldContainer = null;", "-//\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (oldContainer != null && oldContainer.equals(respectiveContainers[i])){", "-\t\t\t\tmodifiedProjects[i] = null; // filter out this project - container did not change", "-\t\t\t\tcontinue;", "-\t\t\t}", "-\t\t\tremaining++; ", "-\t\t\toldResolvedPaths[i] = affectedProject.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, false/*don't generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);", "-\t\t\tmanager.containerPut(affectedProject, containerPath, newContainer);", "-\t\t}", "-\t\t", "-\t\tif (remaining == 0) return;", "-\t\t", "-\t\t// trigger model refresh", "-\t\ttry {", "-\t\t\tfinal boolean canChangeResources = !ResourcesPlugin.getWorkspace().isTreeLocked();", "-\t\t\tJavaCore.run(new IWorkspaceRunnable() {", "-\t\t\t\tpublic void run(IProgressMonitor progressMonitor) throws CoreException {", "-\t\t\t\t\tfor(int i = 0; i < projectLength; i++){", "-\t\t", "-\t\t\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) return;", "-\t\t", "-\t\t\t\t\t\tJavaProject affectedProject = (JavaProject)modifiedProjects[i];", "-\t\t\t\t\t\tif (affectedProject == null) continue; // was filtered out", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){", "-\t\t\t\t\t\t\tUtil.verbose(", "-\t\t\t\t\t\t\t\t\"CPContainer SET  - updating affected project due to setting container\\n\" + //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\"\tproject: \" + affectedProject.getElementName() + '\\n' + //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\"\tcontainer path: \" + containerPath); //$NON-NLS-1$", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t// force a refresh of the affected project (will compute deltas)", "-\t\t\t\t\t\taffectedProject.setRawClasspath(", "-\t\t\t\t\t\t\t\taffectedProject.getRawClasspath(),", "-\t\t\t\t\t\t\t\tSetClasspathOperation.DO_NOT_SET_OUTPUT,", "-\t\t\t\t\t\t\t\tprogressMonitor,", "-\t\t\t\t\t\t\t\tcanChangeResources,", "-\t\t\t\t\t\t\t\toldResolvedPaths[i],", "-\t\t\t\t\t\t\t\tfalse, // updating - no need for early validation", "-\t\t\t\t\t\t\t\tfalse); // updating - no need to save", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t},", "-\t\t\tnull/*no need to lock anything*/,", "-\t\t\tmonitor);", "-\t\t} catch(CoreException e) {", "-\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){", "-\t\t\t\tUtil.verbose(", "-\t\t\t\t\t\"CPContainer SET  - FAILED DUE TO EXCEPTION\\n\" + //$NON-NLS-1$", "-\t\t\t\t\t\"\tcontainer path: \" + containerPath, //$NON-NLS-1$", "-\t\t\t\t\tSystem.err);", "-\t\t\t\te.printStackTrace();", "-\t\t\t}", "-\t\t\tif (e instanceof JavaModelException) {", "-\t\t\t\tthrow (JavaModelException)e;", "-\t\t\t} else {", "-\t\t\t\tthrow new JavaModelException(e);", "-\t\t\t}", "-\t\t} finally {", "-\t\t\tfor (int i = 0; i < projectLength; i++) {", "-\t\t\t\tif (respectiveContainers[i] == null) {", "-\t\t\t\t\tmanager.containerPut(affectedProjects[i], containerPath, null); // reset init in progress marker", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t\t\t\t", "+\tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException {", "+\t\tif (affectedProjects.length != respectiveContainers.length) ", "+\t\t\tAssert.isTrue(false, \"Projects and containers collections should have the same size\"); //$NON-NLS-1$", "+\t\tSetContainerOperation operation = new SetContainerOperation(containerPath, affectedProjects, respectiveContainers);", "+\t\toperation.runOperation(monitor);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d31d654d63970b1e540e705f0a6d049d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "8726985690d5211d83787440cfdc69960f688cd3", "commitAfterChange": "b2bac1f114347c5119b74b76ba91158e0de76647", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "\r \tpublic void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor)", "signatureAfterChange": "\r \tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] newContainers, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\tpublic void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor){\r", "-/*\r", "+\tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] newContainers, IProgressMonitor monitor) throws JavaModelException {\r", "+\r", "-\t\t\r", "+\r", "+\t\tint projectLength = affectedProjects.length;\r", "-\t\tArrayList projectsToCheck = new ArrayList();\r", "+\t\tIClasspathEntry[][] oldResolvedPaths = new IClasspathEntry[projectLength][];\r", "+\r", "+\t\t// filter out unmodified project containers\r", "+\t\tint remaining = 0;\r", "+\t\tfor (int i = 0; i < projectLength; i++){\r", "+\r", "+\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "+\r", "+\t\t\tIJavaProject affectedProject = affectedProjects[i];\r", "+\t\t\tIClasspathContainer newContainer = newContainers[i];\r", "+\t\t\t\r", "+\t\t\tIClasspathEntry[] rawClasspath = affectedProject.getRawClasspath();\r", "+\t\t\tboolean found = false;\r", "+\t\t\tfor (int j = 0, cpLength = rawClasspath.length; j <cpLength; j++) {", "+\t\t\t\tIClasspathEntry entry = rawClasspath[j];\r", "+\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER && entry.getPath().equals(containerPath)){\r", "+\t\t\t\t\tfound = true;\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\t}", "+\t\t\t}\r", "+\t\t\tif (!found){\r", "+\t\t\t\taffectedProjects[i] = null; // filter out this project - does not reference the container path\r", "+\t\t\t\tcontinue;\r", "+\t\t\t}\r", "+\t\t\tMap perProjectContainers = (Map)JavaModelManager.Containers.get(affectedProject);\r", "+\t\t\tif (perProjectContainers == null){\r", "+\t\t\t\tperProjectContainers = new HashMap();\r", "+\t\t\t\tJavaModelManager.Containers.put(affectedProject, perProjectContainers);\r", "+\t\t\t} else {\r", "+\t\t\t\tIClasspathContainer oldContainer = (IClasspathContainer) perProjectContainers.get(containerPath);\r", "+\t\t\t\tif (oldContainer != null && oldContainer.equals(newContainers[i])){\r", "+\t\t\t\t\taffectedProjects[i] = null; // filter out this project - container did not change\r", "+\t\t\t\t\tcontinue;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tremaining++;\r", "+\t\t\toldResolvedPaths[i] = affectedProject.getResolvedClasspath(true);\r", "+\t\t\tperProjectContainers.put(containerPath, newContainer);\r", "+\t\t}\r", "-\t\tswitch (affectedElement.getElementType()){\r", "-\t\t\tcase IJavaElement.JAVA_PROJECT:\r", "-\t\t\t\tprojectsToCheck.add(affectedElement);\r", "-\t\t\t\tbreak;\r", "-\t\t\tcase IJavaElement.JAVA_MODEL:\r", "-\t\t\t\tIJavaProject[] projects = manager.getJavaModel().getJavaProjects();\r", "-\t\t\t\tfor (int i = 0; i < projects.length; i++) {\r", "-\t\t\t\t\tprojectsToCheck.add(projects[i]);\r", "-\t\t\t\t}\r", "-\t\t\t\tbreak;\r", "-\t\t\tdefault:\r", "-\t\t\t\t// no effect if affected element isn't one of the above case\r", "-\t\t\t\treturn;\r", "-\t\t}\r", "-\r", "-\t\t// gather classpath information for updating\r", "-\t\tHashMap affectedProjects = new HashMap(5);\r", "-\r", "-\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\r", "-\t\tnextProject : for (int i = 0, projectLength = projectsToCheck.length; i < projectLength; i++){\r", "-\t\t\tIJavaProject project = projectsToCheck[i];\r", "-\t\t\t\t\t\r", "-\t\t\t// check to see if any of the modified variables is present on the classpath\r", "-\t\t\tIClasspathEntry[] classpath = project.getRawClasspath();\r", "-\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++){\r", "+\t\tif (remaining == 0) return;\r", "+\t\t\r", "+\t\t// trigger model refresh\r", "+\t\tboolean wasFiring = manager.isFiring();\r", "+\t\tint count = 0;\r", "+\t\ttry {\r", "+\t\t\tif (wasFiring)\r", "+\t\t\t\tmanager.stopDeltas();\r", "-\t\t\t\tIClasspathEntry entry = classpath[j];\r", "-\t\t\t\tfor (int k = 0; k < varLength; k++){\r", "+\t\t\tfor(int i = 0; i < projectLength; i++){\r", "-\t\t\t\t\tString variableName = variableNames[k];\t\t\t\t\t\t\r", "-\t\t\t\t\tif (entry.getEntryKind() ==  IClasspathEntry.CPE_CONTAINER){\r", "+\t\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\t\t\t\t\t\tif (entry.getPath().equals(containerPath)){\r", "-\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));\r", "-\t\t\t\t\t\t\t\r", "-\t\t\t\t\t\t\t// also check whether it will be necessary to update proj references and cycle markers\r", "-\t\t\t\t\t\t\tif (!mayChangeProjectDependencies && entry.getPath().segmentCount() ==  1){\r", "-\t\t\t\t\t\t\t\tIPath oldPath = (IPath)JavaModelManager.Variables.get(variableName);\r", "-\t\t\t\t\t\t\t\tif (oldPath != null && oldPath.segmentCount() == 1) {\r", "-\t\t\t\t\t\t\t\t\tmayChangeProjectDependencies = true;\r", "-\t\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t\tIPath newPath = variablePaths[k];\r", "-\t\t\t\t\t\t\t\t\tif (newPath != null && newPath.segmentCount() == 1) {\r", "-\t\t\t\t\t\t\t\t\t\tmayChangeProjectDependencies = true;\r", "-\t\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\tcontinue nextProject;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tIPath sourcePath, sourceRootPath;\r", "-\t\t\t\t\t\tif (((sourcePath = entry.getSourceAttachmentPath()) != null\t&& sourcePath.segment(0).equals(variableName))\r", "-\t\t\t\t\t\t\t|| ((sourceRootPath = entry.getSourceAttachmentRootPath()) != null\t&& sourceRootPath.segment(0).equals(variableName))) {\r", "-\r", "-\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));\r", "-\t\t\t\t\t\t\tcontinue nextProject;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\t// reset saved container path\r", "-\t\tfor (int i = 0; i < \r", "-\t\tMap projectContainers = (Map)JavaModelManager.Containers.get(project);\r", "-\t\tif (projectContainers != null){\r", "-\t\t\tIClasspathEntry[] entries = (IClasspathEntry[])projectContainers.get(containerPath);\r", "+\t\t\t\tJavaProject affectedProject = (JavaProject)affectedProjects[i];\r", "+\t\t\t\tif (affectedProject == null) continue; // was filtered out\r", "-\t\t// update affected project classpaths\r", "-\t\tif (!affectedProjects.isEmpty()) {\r", "-\t\t\tboolean wasFiring = manager.isFiring();\r", "-\t\t\ttry {\r", "-\t\t\t\tif (wasFiring)\r", "-\t\t\t\t\tmanager.stopDeltas();\r", "-\t\t\t\t// propagate classpath change\r", "-\t\t\t\tIterator projectsToUpdate = affectedProjects.keySet().iterator();\r", "-\t\t\t\twhile (projectsToUpdate.hasNext()) {\r", "-\r", "-\t\t\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\r", "-\t\t\t\t\tJavaProject project = (JavaProject) projectsToUpdate.next();\r", "-\t\t\t\t\t\r", "-\t\t\t\t\tif (!projectsToUpdate.hasNext()) {\r", "-\t\t\t\t\t\t// re-enable firing for the last operation\r", "-\t\t\t\t\t\tif (wasFiring) {\r", "-\t\t\t\t\t\t\twasFiring = false;\r", "-\t\t\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\t\t}\r", "+\t\t\t\tif (++count == remaining) { // re-enable firing for the last operation\r", "+\t\t\t\t\tif (wasFiring) {\r", "+\t\t\t\t\t\twasFiring = false;\r", "+\t\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\tproject\r", "-\t\t\t\t\t\t.setRawClasspath(\r", "-\t\t\t\t\t\t\tproject.getRawClasspath(),\r", "-\t\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,\r", "-\t\t\t\t\t\t\tmonitor,\r", "-\t\t\t\t\t\t\ttrue,\r", "-\t\t\t\t\t\t\tproject.getWorkspace().isAutoBuilding(),\r", "-\t\t\t\t\t\t\t// force build if in auto build mode\r", "-\t\t\t\t\t\t\t(IClasspathEntry[]) affectedProjects.get(project),\r", "-\t\t\t\t\t\t\tmayChangeProjectDependencies);\r", "-\t\t\t} finally {\r", "-\t\t\t\tif (wasFiring) {\r", "-\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\t// in case of exception traversing, deltas may be fired only in the next #fire() iteration\r", "+\t\t\t\r", "+\t\t\t\t// force a refresh of the affected project (will compute deltas)\r", "+\t\t\t\taffectedProject.setRawClasspath(\r", "+\t\t\t\t\t\taffectedProject.getRawClasspath(),\r", "+\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,\r", "+\t\t\t\t\t\tmonitor,\r", "+\t\t\t\t\t\ttrue,\r", "+\t\t\t\t\t\taffectedProject.getWorkspace().isAutoBuilding(),\r", "+\t\t\t\t\t\toldResolvedPaths[i],\r", "+\t\t\t\t\t\tremaining == 1); // no individual cycle check if more than 1 project\r", "+\t\t\t}\r", "+\t\t\tif (remaining > 1){\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\t// use workspace runnable so as to allow marker creation - workaround bug 14733\r", "+\t\t\t\t\tResourcesPlugin.getWorkspace().run(\r", "+\t\t\t\t\t\tnew IWorkspaceRunnable() {\r", "+\t\t\t\t\t\t\tpublic void run(IProgressMonitor monitor) throws CoreException {\r", "+\t\t\t\t\t\t\t\tJavaProject.updateAllCycleMarkers(); // update them all at once\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}, \r", "+\t\t\t\t\t\tmonitor);\t\t\t\t\t\r", "+\t\t\t\t} catch(CoreException e){\r", "+\t\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t} finally {\r", "+\t\t\tif (wasFiring) {\r", "+\t\t\t\tmanager.startDeltas();\r", "+\t\t\t\t// in case of exception traversing, deltas may be fired only in the next #fire() iteration\r", "+\t\t\t}\r", "-*/\r", "+\t\t\t\t\t\r"]}], "num": 6705}