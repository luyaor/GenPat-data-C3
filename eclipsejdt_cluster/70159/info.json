{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6de86d836d345afa1380c9be2075dc12", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5daeef1f13c961f34f4a533a9697cacc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "e6d78cda375a26ce6fdb882d62ed50fe3c6a25b5", "commitAfterChange": "8aee5680d034dfec291b1e7b2abb4d9d081e8e31", "methodNumberBeforeChange": 67, "methodNumberAfterChange": 67, "signatureBeforeChange": " \tpublic HashMap getSecondaryTypes(IJavaProject project) throws JavaModelException", "signatureAfterChange": " \tpublic HashMap getSecondaryTypes(IJavaProject project, boolean waitForIndexes, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\tpublic HashMap getSecondaryTypes(IJavaProject project) throws JavaModelException {", "+\tpublic HashMap getSecondaryTypes(IJavaProject project, boolean waitForIndexes, IProgressMonitor monitor) throws JavaModelException {", "-\t\tPerProjectInfo projectInfo = getPerProjectInfoCheckExistence(project.getProject());", "-\t\tif (projectInfo.secondaryTypes != null) return projectInfo.secondaryTypes;", "-\t\tfinal HashMap secondaryTypePaths = new HashMap(3);", "+\t\t// Wait the end of indexing if requested", "+\t\tfinal PerProjectInfo projectInfo = getPerProjectInfoCheckExistence(project.getProject());", "+\t\tIndexManager manager = getIndexManager();", "+\t\tboolean indexing = manager.awaitingJobsCount() > 0;", "+\t\tif (indexing && waitForIndexes) {", "+\t\t\twhile (manager.awaitingJobsCount() > 0) {", "+\t\t\t\tif (monitor != null && monitor.isCanceled()) {", "+\t\t\t\t\tif (projectInfo.secondaryTypes == null) return NO_SECONDARY_TYPES;", "+\t\t\t\t\treturn projectInfo.secondaryTypes;", "+\t\t\t\t}", "+\t\t\t\ttry {", "+\t\t\t\t\tThread.sleep(10);", "+\t\t\t\t} catch (InterruptedException e) {", "+\t\t\t\t\tif (projectInfo.secondaryTypes == null) return NO_SECONDARY_TYPES;", "+\t\t\t\t\treturn projectInfo.secondaryTypes;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t// Return cache if not empty and not dirty", "+\t\tif (projectInfo.secondaryTypes != null && projectInfo.secondaryTypes.get(DIRTY_CACHE) == null) {", "+\t\t\treturn projectInfo.secondaryTypes;", "+\t\t}", "+\t\t", "+\t\t// Return cache if not waiting for indexing", "+\t\tif (indexing && !waitForIndexes) {", "+\t\t\tif (projectInfo.secondaryTypes == null) {", "+\t\t\t\treturn NO_SECONDARY_TYPES; // cache is not initialized return empty one", "+\t\t\t}", "+\t\t\treturn projectInfo.secondaryTypes; // cache is dirty => return current one...", "+\t\t}", "+", "+\t\t// Init variables for search", "+\t\tfinal HashMap secondaryTypes = new HashMap(3);", "-\t\t\t\tHashMap types = (HashMap) secondaryTypePaths.get(key);", "-\t\t\t\tif (types == null) {", "-\t\t\t\t\ttypes = new HashMap();", "-\t\t\t\t}", "+\t\t\t\tHashMap types = (HashMap) secondaryTypes.get(key);", "+\t\t\t\tif (types == null) types = new HashMap(3);", "-\t\t\t\tsecondaryTypePaths.put(key, types);", "+\t\t\t\tsecondaryTypes.put(key, types);", "-\t\t\t", "+", "-\t\tnew BasicSearchEngine().searchAllSecondaryTypeNames(allSourceFolders, nameRequestor);", "+\t\tnew BasicSearchEngine().searchAllSecondaryTypeNames(allSourceFolders, nameRequestor, monitor);", "-\t\t\tSystem.out.print(Thread.currentThread() + \" -> secondary paths: \");  //$NON-NLS-1$", "-\t\t\tif (secondaryTypePaths == null) {", "-\t\t\t\tSystem.out.println(\" NONE\"); //$NON-NLS-1$", "-\t\t\t} else {", "-\t\t\t\tSystem.out.println();", "-\t\t\t\tIterator keys = secondaryTypePaths.keySet().iterator();", "-\t\t\t\twhile (keys.hasNext()) {", "-\t\t\t\t\tString qualifiedName = (String) keys.next();", "-\t\t\t\t\tUtil.verbose(\"\t\t- \"+qualifiedName+'-'+secondaryTypePaths.get(qualifiedName) ); //$NON-NLS-1$", "-\t\t\t\t}", "+\t\t\tSystem.out.print(Thread.currentThread() + \"\t-> secondary paths: \");  //$NON-NLS-1$", "+\t\t\tSystem.out.println();", "+\t\t\tIterator keys = secondaryTypes.keySet().iterator();", "+\t\t\twhile (keys.hasNext()) {", "+\t\t\t\tString qualifiedName = (String) keys.next();", "+\t\t\t\tUtil.verbose(\"\t\t- \"+qualifiedName+'-'+secondaryTypes.get(qualifiedName) ); //$NON-NLS-1$", "-\t\t", "+", "-\t\tIterator packages = secondaryTypePaths.keySet().iterator();", "+\t\tIterator packages = secondaryTypes.keySet().iterator();", "-\t\t\tHashMap types = (HashMap) secondaryTypePaths.get(packName);", "+\t\t\tHashMap types = (HashMap) secondaryTypes.get(packName);", "-\t\t", "-\t\t// Store result in per project info cache", "-\t\treturn (projectInfo.secondaryTypes = secondaryTypePaths);", "+", "+\t\t// Store result in per project info cache if still null or dirty (may have been set by another thread...)", "+\t\tif (projectInfo.secondaryTypes == null || projectInfo.secondaryTypes.get(DIRTY_CACHE) != null) {", "+\t\t\tprojectInfo.secondaryTypes = secondaryTypes;", "+\t\t}", "+\t\treturn projectInfo.secondaryTypes;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f0fa566e598333ed84c530ab00df707", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java", "commitBeforeChange": "a6914dc16e1f0ce25a9de76d8e25b9be5b842c74", "commitAfterChange": "fa8802ca34ede6a02e1972c1e68e4f30dba72e81", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " void initialize(boolean reuseExistingFile) throws IOException", "signatureAfterChange": " void initialize(boolean reuseExistingFile) throws IOException", "diff": ["-\t\t\tRandomAccessFile file = new RandomAccessFile(this.indexFile, \"r\"); //$NON-NLS-1$", "+\t\t\tFileInputStream stream = new FileInputStream(this.indexFile);", "+\t\t\tthis.streamBuffer = new byte[BUFFER_READ_SIZE];", "+\t\t\tthis.bufferIndex = 0;", "+\t\t\tthis.bufferEnd = stream.read(this.streamBuffer, 0, 128);", "-\t\t\t\tString signature = file.readUTF();", "-\t\t\t\tif (!signature.equals(SIGNATURE))", "-\t\t\t\t\tthrow new IOException(Messages.exception_wrongFormat); ", "-", "-\t\t\t\tthis.headerInfoOffset = file.readInt();", "-\t\t\t\tif (this.headerInfoOffset > 0) // file is empty if its not set", "-\t\t\t\t\treadHeaderInfo(file);", "+\t\t\t\tchar[] signature = readStreamChars(stream);", "+\t\t\t\tif (!CharOperation.equals(signature, SIGNATURE_CHARS)) {", "+\t\t\t\t\tthrow new IOException(Messages.exception_wrongFormat);", "+\t\t\t\t}", "+\t\t\t\tthis.headerInfoOffset = readStreamInt(stream);", "+\t\t\t\tif (this.headerInfoOffset > 0) { // file is empty if its not set", "+\t\t\t\t\tstream.skip(this.headerInfoOffset - this.bufferEnd); // assume that the header info offset is over current buffer end", "+\t\t\t\t\tthis.bufferIndex = 0;", "+\t\t\t\t\tthis.bufferEnd = stream.read(this.streamBuffer, 0, this.streamBuffer.length);", "+\t\t\t\t\treadHeaderInfo(stream);", "+\t\t\t\t}", "-\t\t\t\tfile.close();", "+\t\t\t\tstream.close();", "-\t\tRandomAccessFile file = new RandomAccessFile(this.indexFile, \"rw\"); //$NON-NLS-1$", "+\t\tFileOutputStream stream = new FileOutputStream(this.indexFile, false);", "-\t\t\tfile.writeUTF(SIGNATURE);", "-\t\t\tfile.writeInt(-1); // file is empty", "+\t\t\tthis.streamBuffer = new byte[BUFFER_READ_SIZE];", "+\t\t\tthis.bufferIndex = 0;", "+\t\t\twriteStreamChars(stream, SIGNATURE_CHARS);", "+\t\t\twriteStreamInt(stream, -1); // file is empty", "+\t\t\t// write the buffer to the stream", "+\t\t\tif (this.bufferIndex > 0) {", "+\t\t\t\tstream.write(this.streamBuffer, 0, this.bufferIndex);", "+\t\t\t\tthis.bufferIndex = 0;", "+\t\t\t}", "-\t\t\tfile.close();", "+\t\t\tstream.close();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c478f38613fe527afce7815f2dd5e85b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "39787fb323b3f06bf37a085118b28347f6a17b39", "commitAfterChange": "0cc61e9905c3f603dab789f6a44abfa63094212c", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public boolean generateSubRoutineInvocation(BlockScope currentScope, CodeStream codeStream, Object targetLocation)", "signatureAfterChange": " public boolean generateSubRoutineInvocation(BlockScope currentScope, CodeStream codeStream, Object targetLocation, int stateIndex, LocalVariableBinding secretLocal)", "diff": ["-public boolean generateSubRoutineInvocation(BlockScope currentScope, CodeStream codeStream, Object targetLocation) {", "+public boolean generateSubRoutineInvocation(BlockScope currentScope, CodeStream codeStream, Object targetLocation, int stateIndex, LocalVariableBinding secretLocal) {", "+\tboolean isStackMapFrameCodeStream = codeStream instanceof StackMapFrameCodeStream;", "+\t\tboolean reuseTargetLocation = true;", "-\t\t\t\tcodeStream.goto_(this.reusableJSRSequenceStartLabels[i]);", "-\t\t\t\treturn true;", "+\t\t\t\tif ((this.reusableJSRStateIndexes[i] != stateIndex) && finallyMode == FINALLY_INLINE && isStackMapFrameCodeStream) {", "+\t\t\t\t\treuseTargetLocation = false;", "+\t\t\t\t\tbreak nextReusableTarget;", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.goto_(this.reusableJSRSequenceStartLabels[i]);", "+\t\t\t\t\treturn true;", "+\t\t\t\t}", "+\t\t\tthis.reusableJSRStateIndexes = new int[3];", "-\t\tif (this.reusableJSRTargetsCount == this.reusableJSRTargets.length) {", "-\t\t\tSystem.arraycopy(this.reusableJSRTargets, 0, this.reusableJSRTargets = new Object[2*this.reusableJSRTargetsCount], 0, this.reusableJSRTargetsCount);", "-\t\t\tSystem.arraycopy(this.reusableJSRSequenceStartLabels, 0, this.reusableJSRSequenceStartLabels = new BranchLabel[2*this.reusableJSRTargetsCount], 0, this.reusableJSRTargetsCount);", "+\t\tif (reuseTargetLocation) {", "+\t\t\tif (this.reusableJSRTargetsCount == this.reusableJSRTargets.length) {", "+\t\t\t\tSystem.arraycopy(this.reusableJSRTargets, 0, this.reusableJSRTargets = new Object[2*this.reusableJSRTargetsCount], 0, this.reusableJSRTargetsCount);", "+\t\t\t\tSystem.arraycopy(this.reusableJSRSequenceStartLabels, 0, this.reusableJSRSequenceStartLabels = new BranchLabel[2*this.reusableJSRTargetsCount], 0, this.reusableJSRTargetsCount);", "+\t\t\t\tSystem.arraycopy(this.reusableJSRStateIndexes, 0, this.reusableJSRStateIndexes = new int[2*this.reusableJSRTargetsCount], 0, this.reusableJSRTargetsCount);", "+\t\t\t}", "+\t\t\tthis.reusableJSRTargets[this.reusableJSRTargetsCount] = targetLocation;", "+\t\t\tBranchLabel reusableJSRSequenceStartLabel = new BranchLabel(codeStream);", "+\t\t\treusableJSRSequenceStartLabel.place();", "+\t\t\tthis.reusableJSRStateIndexes[this.reusableJSRTargetsCount] = stateIndex;", "+\t\t\tthis.reusableJSRSequenceStartLabels[this.reusableJSRTargetsCount++] = reusableJSRSequenceStartLabel;", "-\t\tthis.reusableJSRTargets[this.reusableJSRTargetsCount] = targetLocation;", "-\t\tBranchLabel reusableJSRSequenceStartLabel = new BranchLabel(codeStream);", "-\t\treusableJSRSequenceStartLabel.place();", "-\t\tthis.reusableJSRSequenceStartLabels[this.reusableJSRTargetsCount++] = reusableJSRSequenceStartLabel;", "-\t}\t\t\t", "+\t}", "-\t\tif (this.preTryInitStateIndex != -1) {", "-\t\t\t// reset initialization state, as for a normal catch block", "-\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\tif (isStackMapFrameCodeStream) {", "+\t\t\t((StackMapFrameCodeStream) codeStream).pushStateIndex(stateIndex);", "+\t\t\tif (this.naturalExitMergeInitStateIndex != -1 || stateIndex != -1) {", "+\t\t\t\t// reset initialization state, as for a normal catch block", "+\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.naturalExitMergeInitStateIndex);", "+\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.naturalExitMergeInitStateIndex);", "+\t\t\t}", "+\t\t} else {", "+\t\t\tif (this.naturalExitMergeInitStateIndex != -1) {", "+\t\t\t\t// reset initialization state, as for a normal catch block", "+\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.naturalExitMergeInitStateIndex);", "+\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.naturalExitMergeInitStateIndex);", "+\t\t\t}", "+\t\t}", "+\t\tif (secretLocal != null) {", "+\t\t\tcodeStream.addVariable(secretLocal);", "+\t\tif (isStackMapFrameCodeStream) {", "+\t\t\t((StackMapFrameCodeStream) codeStream).popStateIndex();", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f53121ff5b1e7874d0cc2b049b0a677c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java", "commitBeforeChange": "bb811cafdba11489b23b9c8cd6c46c237bf0db24", "commitAfterChange": "2a64f816a9e1e382be3c6f39875e5c587a7235c0", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " private synchronized HashtableOfObject readCategoryTable(char[] categoryName, boolean readDocNumbers) throws IOException", "signatureAfterChange": " private synchronized HashtableOfObject readCategoryTable(char[] categoryName, boolean readDocNumbers) throws IOException", "diff": ["-\tif (offset == HashtableOfIntValues.NO_VALUE)", "+\tif (offset == HashtableOfIntValues.NO_VALUE) {", "+\t}", "+\tthis.streamEnd = this.categoryEnds.get(categoryName);", "-\tDataInputStream stream = new DataInputStream(new BufferedInputStream(new FileInputStream(this.indexFile), 2048));", "+\tFileInputStream stream = new FileInputStream(this.indexFile);", "+\tthis.streamBuffer = new byte[BUFFER_READ_SIZE];", "-\t\tint size = stream.readInt();", "+\t\tint readSize = this.streamEnd - offset;", "+\t\tthis.bufferIndex = 0;", "+\t\tthis.streamPos = stream.read(this.streamBuffer, 0, readSize < BUFFER_READ_SIZE ? readSize : BUFFER_READ_SIZE) + offset;", "+\t\tint size = readStreamInt(stream);", "-\t\t\tchar[] word = Util.readUTF(stream);", "-\t\t\tint arrayOffset = stream.readInt();", "+\t\t\tchar[] word = readStreamChars(stream);", "+\t\t\tint arrayOffset = readStreamInt(stream);", "-\t\t\t\tcategoryTable.put(word, readDocumentArray(stream, arrayOffset)); // read in-lined array providing size", "+\t\t\t\tcategoryTable.put(word, readStreamDocumentArray(stream, arrayOffset)); // read in-lined array providing size", "-\t\t\t\tarrayOffset = stream.readInt(); // read actual offset", "+\t\t\t\tarrayOffset = readStreamInt(stream); // read actual offset", "-\t} finally {", "+\t}", "+\tcatch (IOException ioe) {", "+\t\tthis.streamBuffer = null;", "+\t\tthrow ioe;", "+\t}", "+\tfinally {", "-\t\tstream = new DataInputStream(new BufferedInputStream(new FileInputStream(this.indexFile), 2048));", "+\t\tstream = new FileInputStream(this.indexFile);", "-\t\t\tfor (int i = 0; i < count; i++) // each array follows the previous one", "-\t\t\t\tcategoryTable.put(matchingWords[i], readDocumentArray(stream, stream.readInt()));", "-\t\t} finally {", "+\t\t\tint readSize = this.streamEnd - firstOffset;", "+\t\t\tthis.bufferIndex = 0;", "+\t\t\tthis.streamPos = stream.read(this.streamBuffer, 0, readSize < BUFFER_READ_SIZE ? readSize : BUFFER_READ_SIZE) + firstOffset;", "+\t\t\tfor (int i = 0; i < count; i++) { // each array follows the previous one", "+\t\t\t\tcategoryTable.put(matchingWords[i], readStreamDocumentArray(stream, readStreamInt(stream)));", "+\t\t\t}", "+\t\t}", "+\t\tcatch (IOException ioe) {", "+\t\t\tthis.streamBuffer = null;", "+\t\t\tthrow ioe;", "+\t\t}", "+\t\tfinally {", "+\tthis.streamBuffer = null;"]}], "num": 70159}