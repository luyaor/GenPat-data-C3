{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7bd4c77975e1d65468c6cd0240a1a8df", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "69118f47d3f4f22b1b44709bc9f2d9ed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java", "commitBeforeChange": "9e6971330e1dbf8dfcd3f7b3b236a977c961b5cf", "commitAfterChange": "1cfa134949cdabf37fc8e84395bd1a2b80d960f5", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": " \tprotected String getURLContents(String docUrlValue) throws JavaModelException", "signatureAfterChange": " \tprotected String getURLContents(String docUrlValue) throws JavaModelException", "diff": ["+\t\t} catch(NoRouteToHostException e) {", "+\t\t\t// ignore. see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=247845"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "737c71a73c9393dc9b5edbb70fab099f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java", "commitBeforeChange": "577162b289bc08314eef0995f49154e96642351e", "commitAfterChange": "e599f0bb80a774d7f0e7c2244302e661dd529f10", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 62, "signatureBeforeChange": " \tprotected String getURLContents(String docUrlValue) throws JavaModelException", "signatureAfterChange": " \tprotected String getURLContents(String docUrlValue) throws JavaModelException", "diff": ["+\t\t\t\t} catch(IllegalStateException e) {", "+\t\t\t\t\t/*", "+\t\t\t\t\t * ignore. Can happen in case the stream.close() did close the jar file", "+\t\t\t\t\t * see https://bugs.eclipse.org/bugs/show_bug.cgi?id=140750", "+\t\t\t\t\t */"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "89ff46a2394e6438e978ef706e2ae40f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java", "commitBeforeChange": "6c4672b1e2a9f0f79cc6133dda1f6a85c52a7092", "commitAfterChange": "d1d399f0fbeeb5108250a5ab8eacdfab512e0cb9", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " public ISourceRange getJavadocRange() throws JavaModelException", "signatureAfterChange": " public ISourceRange getJavadocRange() throws JavaModelException", "diff": ["-\t\tscanner.setSource(buf.getText(start, length).toCharArray());", "+\t\t\tscanner.setSource(buf.getText(start, length).toCharArray());", "+\t\t} catch (IndexOutOfBoundsException e) {", "+\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=305001"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c6173c0b0e6a812cb6995c76e42809f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/HierarchyResolver.java", "commitBeforeChange": "673b7eda95cd26449992e862f0c63f2c612903a0", "commitAfterChange": "b04602938404af4f8569a399fb36a5018768a262", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r \r \tpublic void resolve(\r \t\tIGenericType[] suppliedTypes,\r \t\tICompilationUnit[] sourceUnits)", "signatureAfterChange": "\r \r public void resolve(IGenericType[] suppliedTypes, ICompilationUnit[] sourceUnits)", "diff": ["+\r", "+public void resolve(IGenericType[] suppliedTypes, ICompilationUnit[] sourceUnits) {\r", "+\ttry {\r", "+\t\tint suppliedLength = suppliedTypes == null ? 0 : suppliedTypes.length;\r", "+\t\tint sourceLength = sourceUnits == null ? 0 : sourceUnits.length;\r", "+\t\tCompilationUnitDeclaration[] units = new CompilationUnitDeclaration[suppliedLength + sourceLength];\r", "+\t\tint count = -1;\r", "+\t\tfor (int i = 0; i < suppliedLength; i++) {\r", "+\t\t\tif (suppliedTypes[i].isBinaryType()) {\r", "+\t\t\t\tIBinaryType binaryType = (IBinaryType) suppliedTypes[i];\r", "+\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\r", "+\t\t\t\t\tremember(binaryType, lookupEnvironment.cacheBinaryType(binaryType, false));\r", "+\t\t\t\t\t// classpath problem for this type: ignore\r", "+\t\t\t} else {\r", "+\t\t\t\t// must start with the top level type\r", "+\t\t\t\tISourceType topLevelType = (ISourceType) suppliedTypes[i];\r", "+\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\t\t\t\t\r", "+\t\t\t\twhile (topLevelType.getEnclosingType() != null)\r", "+\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();\r", "+\t\t\t\tCompilationResult result = new CompilationResult(topLevelType.getFileName(), i, suppliedLength);\r", "+\t\t\t\tunits[++count] = SourceTypeConverter.buildCompilationUnit(topLevelType, false, true, lookupEnvironment.problemReporter, result);\r", "-\r", "-\tpublic void resolve(\r", "-\t\tIGenericType[] suppliedTypes,\r", "-\t\tICompilationUnit[] sourceUnits) {\r", "-\t\ttry {\r", "-\t\t\tint suppliedLength = suppliedTypes == null ? 0 : suppliedTypes.length;\r", "-\t\t\tint sourceLength = sourceUnits == null ? 0 : sourceUnits.length;\r", "-\t\t\tCompilationUnitDeclaration[] units =\r", "-\t\t\t\tnew CompilationUnitDeclaration[suppliedLength + sourceLength];\r", "-\t\t\tint count = -1;\r", "-\t\t\tfor (int i = 0; i < suppliedLength; i++) {\r", "-\t\t\t\tif (suppliedTypes[i].isBinaryType()) {\r", "-\t\t\t\t\tIBinaryType binaryType = (IBinaryType) suppliedTypes[i];\r", "-\t\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\r", "+\t\t\t\tif (units[count] == null) {\r", "+\t\t\t\t\tcount--;\r", "+\t\t\t\t} else {\r", "-\t\t\t\t\t\tremember(binaryType, lookupEnvironment.cacheBinaryType(binaryType, false));\r", "+\t\t\t\t\t\tlookupEnvironment.buildTypeBindings(units[count]);\r", "+\t\t\t\t\t\trememberWithMemberTypes(topLevelType, units[count].types[0].binding);\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\t// must start with the top level type\r", "-\t\t\t\t\tISourceType topLevelType = (ISourceType) suppliedTypes[i];\r", "-\t\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\t\t\t\t\r", "-\t\t\t\t\twhile (topLevelType.getEnclosingType() != null)\r", "-\t\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();\r", "-\t\t\t\t\tCompilationResult result =\r", "-\t\t\t\t\t\tnew CompilationResult(topLevelType.getFileName(), i, suppliedLength);\r", "-\t\t\t\t\tunits[++count] =\r", "-\t\t\t\t\t\tSourceTypeConverter.buildCompilationUnit(\r", "-\t\t\t\t\t\t\ttopLevelType,\r", "-\t\t\t\t\t\t\tfalse,\r", "-\t\t\t\t\t\t\ttrue,\r", "-\t\t\t\t\t\t\tlookupEnvironment.problemReporter,\r", "-\t\t\t\t\t\t\tresult);\r", "-\r", "-\t\t\t\t\tif (units[count] == null) {\r", "-\t\t\t\t\t\tcount--;\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tlookupEnvironment.buildTypeBindings(units[count]);\r", "-\t\t\t\t\t\t\trememberWithMemberTypes(topLevelType, units[count].types[0].binding);\r", "-\t\t\t\t\t\t} catch (AbortCompilation e) {\r", "-\t\t\t\t\t\t\t// classpath problem for this type: ignore\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\tfor (int i = 0; i < sourceLength; i++) {\r", "-\t\t\t\tICompilationUnit sourceUnit = sourceUnits[i];\r", "-\t\t\t\tsourceUnits[i] = null; // no longer needed pass this point\r", "-\t\t\t\tCompilationResult unitResult =\r", "-\t\t\t\t\tnew CompilationResult(\r", "-\t\t\t\t\t\tsourceUnit,\r", "-\t\t\t\t\t\tsuppliedLength + i,\r", "-\t\t\t\t\t\tsuppliedLength + sourceLength);\r", "-\t\t\t\tParser parser = new Parser(lookupEnvironment.problemReporter);\r", "-\t\t\t\tCompilationUnitDeclaration parsedUnit =\r", "-\t\t\t\t\tparser.dietParse(sourceUnit, unitResult);\r", "-\t\t\t\tif (parsedUnit != null) {\r", "-\t\t\t\t\tunits[++count] = parsedUnit;\r", "-\t\t\t\t\tlookupEnvironment.buildTypeBindings(units[count]);\r", "-\t\t\t\t\tint typeCount = parsedUnit.types == null ? 0 : parsedUnit.types.length;\r", "-\t\t\t\t\tfor (int j = 0; j < typeCount; j++) {\r", "-\t\t\t\t\t\trememberWithMemberTypes(parsedUnit.types[j], null, sourceUnit);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tfor (int i = 0; i <= count; i++)\r", "-\t\t\t\tlookupEnvironment.completeTypeBindings(units[i], false);\r", "-\r", "-\t\t\treportHierarchy();\r", "-\t\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "-\t\t} finally {\r", "-\t\t\treset();\r", "-\t}\r", "+\t\tfor (int i = 0; i < sourceLength; i++){\r", "+\t\t\tICompilationUnit sourceUnit = sourceUnits[i];\r", "+\t\t\tsourceUnits[i] = null; // no longer needed pass this point\r", "+\t\t\tCompilationResult unitResult = new CompilationResult(sourceUnit, suppliedLength+i, suppliedLength+sourceLength); \r", "+\t\t\tParser parser = new Parser(lookupEnvironment.problemReporter);\r", "+\t\t\tCompilationUnitDeclaration parsedUnit = parser.dietParse(sourceUnit, unitResult);\r", "+\t\t\tif (parsedUnit != null) {\r", "+\t\t\t\tunits[++count] = parsedUnit;\r", "+\t\t\t\tlookupEnvironment.buildTypeBindings(units[count]);\r", "+\t\t\t\tint typeCount = parsedUnit.types == null ? 0 : parsedUnit.types.length;\r", "+\t\t\t\tfor (int j = 0; j < typeCount; j++){\r", "+\t\t\t\t\trememberWithMemberTypes(parsedUnit.types[j], null, sourceUnit);\r", "+\t\tfor (int i = 0; i <= count; i++)\r", "+\t\t\tlookupEnvironment.completeTypeBindings(units[i], false);\r", "+\t\treportHierarchy();\r", "+\t\t\r", "+\t} catch (ClassCastException e){ // work-around for 1GF5W1S - can happen in case duplicates are fed to the hierarchy with binaries hiding sources\r", "+\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "+\t} finally {\r", "+\t\treset();\r", "+\t}\r", "+}\r"]}], "num": 71434}