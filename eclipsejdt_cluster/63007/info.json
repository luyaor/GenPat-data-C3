{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0653218e3837ff7638e6fc73689bc2e4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f1782a8ee431bc2ea63186df55beab55", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "0de5167791884524f72d9d44c10f0e243af65d00", "commitAfterChange": "07ab76f69fbeeb2f2fd54cdf3d01ee69344b9ae0", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic static IBinding[] resolve( \t\tfinal IJavaElement[] elements, \t\tint apiLevel, \t\tMap compilerOptions, \t\tIJavaProject javaProject, \t\tWorkingCopyOwner owner, \t\tint flags, \t\tIProgressMonitor monitor)", "signatureAfterChange": " \tpublic static void resolve( \t\t\tString[] sourceUnits, \t\t\tString[] encodings, \t\t\tString[] bindingKeys, \t\t\tFileASTRequestor requestor, \t\t\tint apiLevel, \t\t\tMap options, \t\t\tList classpaths, \t\t\tint flags, \t\t\tIProgressMonitor monitor)", "diff": ["+\tpublic static void resolve(", "+\t\t\tString[] sourceUnits,", "+\t\t\tString[] encodings,", "+\t\t\tString[] bindingKeys,", "+\t\t\tFileASTRequestor requestor,", "+\t\t\tint apiLevel,", "+\t\t\tMap options,", "+\t\t\tList classpaths,", "+\t\t\tint flags,", "+\t\t\tIProgressMonitor monitor) {", "+", "+\t\t\tINameEnviromentWithProgress environment = null;", "+\t\t\tCancelableProblemFactory problemFactory = null;", "+\t\t\ttry {", "+\t\t\t\tif (monitor != null) {", "+\t\t\t\t\tint amountOfWork = (sourceUnits.length + bindingKeys.length) * 2; // 1 for beginToCompile, 1 for resolve", "+\t\t\t\t\tmonitor.beginTask(\"\", amountOfWork); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\tClasspath[] allEntries = new Classpath[classpaths.size()];", "+\t\t\t\tclasspaths.toArray(allEntries);", "+\t\t\t\tenvironment = new NameEnviromentWithProgress(allEntries, null, monitor);", "+\t\t\t\tproblemFactory = new CancelableProblemFactory(monitor);", "+\t\t\t\tCompilerOptions compilerOptions = getCompilerOptions(options, (flags & ICompilationUnit.ENABLE_STATEMENTS_RECOVERY) != 0);", "+\t\t\t\tcompilerOptions.ignoreMethodBodies = (flags & ICompilationUnit.IGNORE_METHOD_BODIES) != 0;", "+\t\t\t\tCompilationUnitResolver resolver =", "+\t\t\t\t\tnew CompilationUnitResolver(", "+\t\t\t\t\t\tenvironment,", "+\t\t\t\t\t\tgetHandlingPolicy(),", "+\t\t\t\t\t\tcompilerOptions,", "+\t\t\t\t\t\tgetRequestor(),", "+\t\t\t\t\t\tproblemFactory,", "+\t\t\t\t\t\tmonitor,", "+\t\t\t\t\t\tfalse);", "+\t\t\t\tresolver.resolve(sourceUnits, encodings, bindingKeys, requestor, apiLevel, options, flags);", "+\t\t\t\tif (NameLookup.VERBOSE && (environment instanceof CancelableNameEnvironment)) {", "+\t\t\t\t\tCancelableNameEnvironment cancelableNameEnvironment = (CancelableNameEnvironment) environment;", "+\t\t\t\t\tSystem.out.println(Thread.currentThread() + \" TIME SPENT in NameLoopkup#seekTypesInSourcePackage: \" + cancelableNameEnvironment.nameLookup.timeSpentInSeekTypesInSourcePackage + \"ms\");  //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\t\tSystem.out.println(Thread.currentThread() + \" TIME SPENT in NameLoopkup#seekTypesInBinaryPackage: \" + cancelableNameEnvironment.nameLookup.timeSpentInSeekTypesInBinaryPackage + \"ms\");  //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\t}", "+\t\t\t} finally {", "+\t\t\t\tif (monitor != null) monitor.done();", "+\t\t\t\tif (environment != null) {", "+\t\t\t\t\tenvironment.setMonitor(null); // don't hold a reference to this external object", "+\t\t\t\t}", "+\t\t\t\tif (problemFactory != null) {", "+\t\t\t\t\tproblemFactory.monitor = null; // don't hold a reference to this external object", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3094ae1ed229befa97e6528a441dc10", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "cb102deeeb30ec755d64a8d266f5423000dc4f4e", "commitAfterChange": "f18746495477338a9b83fca4f673d973bc3b28e9", "methodNumberBeforeChange": 72, "methodNumberAfterChange": 73, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["-\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "+\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType) {", "+\t\tbyte[] skipValues = new byte[visibleSize]; // tagged with -1 if method cannot be best match", "-\t\t\t\tif (compatibilityLevels[i] != level) continue nextVisible; // skip this method for now", "-\t\t\t\tMethodBinding method = visible[i];", "-\t\t\t\tTypeBinding[] params = method.tiebreakMethod().parameters;", "+\t\t\t\tif (compatibilityLevels[i] != level || skipValues[i] == -1) continue nextVisible; // skip this method for now", "+\t\t\t\tMethodBinding original = visible[i].original();", "+\t\t\t\tMethodBinding method = visible[i].tiebreakMethod();", "-\t\t\t\t\tMethodBinding method2 = visible[j];", "-\t\t\t\t\t// tiebreak generic methods using variant where type params are substituted by their erasures", "-\t\t\t\t\tif (!method2.tiebreakMethod().areParametersCompatibleWith(params)) {", "-\t\t\t\t\t\tif (method.isVarargs() && method2.isVarargs()) {", "-\t\t\t\t\t\t\t// check the non-vararg parameters", "-\t\t\t\t\t\t\tint paramLength = params.length;", "-\t\t\t\t\t\t\tTypeBinding[] params2 = method2.tiebreakMethod().parameters;", "-\t\t\t\t\t\t\tif (paramLength != params2.length)", "-\t\t\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t\t\tfor (int p = paramLength - 2; p >= 0; p--)", "-\t\t\t\t\t\t\t\tif (params[p] != params2[p] && !params[p].isCompatibleWith(params2[p]))", "-\t\t\t\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t\tMethodBinding original2 = visible[j].original();", "+\t\t\t\t\tif (original == original2)", "+\t\t\t\t\t\tcontinue; // parameterized superclasses & interfaces may be walked twice from different paths", "-\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) params2[paramLength - 1]).elementsType();", "-\t\t\t\t\t\t\tif (params[paramLength - 1].isCompatibleWith(elementsType))", "-\t\t\t\t\t\t\t\tcontinue; // special case to choose between 2 varargs methods when the last arg is missing or its Object[]", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t\tMethodBinding method2 = visible[j].tiebreakMethod();", "+\t\t\t\t\tif (!isMoreSpecificMethod(method, method2)) {", "+\t\t\t\t\t\tif (!isMoreSpecificMethod(method2, method))", "+\t\t\t\t\t\t\tskipValues[j] = -1; // no point checking method2 either", "+\t\t\t\t\t\tcontinue nextVisible; // method2 is a better match", "-\t\t\t\t\t// parameterized superclasses & interfaces may be walked twice from different paths", "-\t\t\t\t\tif (method.original() == method2.original()) continue;", "-", "-\t\t\t\t\t// see if method & method2 are duplicates due to the current substitution or multiple static imported methods", "-\t\t\t\t\tif (method.tiebreakMethod().areParametersEqual(method2.tiebreakMethod())) {", "-\t\t\t\t\t\tif (method.declaringClass == method2.declaringClass)", "-\t\t\t\t\t\t\tcontinue nextVisible; // duplicates thru substitution", "-", "-\t\t\t\t\t\tMethodBinding original = method.original();", "-\t\t\t\t\t\tif (method.hasSubstitutedParameters() || original.typeVariables != NoTypeVariables) {", "-\t\t\t\t\t\t\tReferenceBinding declaringClass = (ReferenceBinding) method.declaringClass.erasure();", "-\t\t\t\t\t\t\tReferenceBinding superType = declaringClass.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "-\t\t\t\t\t\t\tif (superType == null) {", "-\t\t\t\t\t\t\t\t// accept concrete methods over abstract methods found due to the default abstract method walk", "-\t\t\t\t\t\t\t\tif (!method.isAbstract() && method2.isAbstract())", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tMethodBinding inheritedMethod = method2;", "-\t\t\t\t\t\t\tMethodBinding inheritedOriginal = method2.original();", "-\t\t\t\t\t\t\tif (method.hasSubstitutedParameters()) { // must find inherited method with the same substituted variables", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(inheritedMethod.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == inheritedOriginal) {", "-\t\t\t\t\t\t\t\t\t\tinheritedMethod = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (original.typeVariables != NoTypeVariables)", "-\t\t\t\t\t\t\t\tinheritedMethod = original.computeSubstitutedMethod(inheritedMethod == method2 ? inheritedOriginal : inheritedMethod, environment());", "-\t\t\t\t\t\t\tif (inheritedMethod == null || !original.areParametersEqual(inheritedMethod))", "-\t\t\t\t\t\t\t\tbreak nextVisible; // dup thru substitution, not overridden... cannot find possible match", "-\t\t\t\t\t\t\t// method overrides method2, accept it", "-\t\t\t\t\t\t} else if (method.isStatic() && method2.isStatic()) {", "+\t\t\t\t\tif (method.areParametersEqual(method2)) {", "+\t\t\t\t\t\tif (method.isStatic() && method2.isStatic()) {", "+\t\t\t\t\t\t\t// if you knew that method overrode method2, it would help", "+\t\t\t\t\t\tif (original == method && original2 == method2)", "+\t\t\t\t\t\t\tcontinue; // no need to check further", "+\t\t\t\t\t\tif (!method.isAbstract() && method2.isAbstract())", "+\t\t\t\t\t\t\tcontinue; // 15.12.2, concrete method beats abstract method", "+\t\t\t\t\t\tif (method.declaringClass == method2.declaringClass)", "+\t\t\t\t\t\t\tcontinue nextVisible; // duplicates thru substitution", "+", "+\t\t\t\t\t\tif (method.hasSubstitutedParameters() && method.isAbstract() == method2.isAbstract() && receiverType != null) {", "+\t\t\t\t\t\t\t// class A<T> { void foo(T t) {} }", "+\t\t\t\t\t\t\t// class B<T, S> extends A<S> { void foo(T t) {} }", "+\t\t\t\t\t\t\treceiverType = receiverType instanceof CaptureBinding ? receiverType : (ReferenceBinding) receiverType.erasure();", "+\t\t\t\t\t\t\tReferenceBinding superType = receiverType.findSuperTypeWithSameErasure(method.declaringClass.erasure());", "+\t\t\t\t\t\t\tif (original.declaringClass == superType || superType == null) {", "+\t\t\t\t\t\t\t\tmethod = original;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(method.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "+\t\t\t\t\t\t\t\t\t\tmethod = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tsuperType = receiverType.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "+\t\t\t\t\t\t\tif (original2.declaringClass == superType || superType == null) {", "+\t\t\t\t\t\t\t\tmethod2 = original2;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(method2.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "+\t\t\t\t\t\t\t\t\t\tmethod2 = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (method.typeVariables != NoTypeVariables)", "+\t\t\t\t\t\t\t\tmethod2 = method.computeSubstitutedMethod(method2, environment());", "+\t\t\t\t\t\t\tif (method2 == null || !method.areParametersEqual(method2)) {", "+\t\t\t\t\t\t\t\tskipValues[j] = -1;", "+\t\t\t\t\t\t\t\tcontinue nextVisible; // dup thru substitution, not overridden... cannot find possible match", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// method overrides method2, accept it", "+\t\t\t\t\t\t} else if (!original.areTypeVariableErasuresEqual(original2)) {", "+\t\t\t\t\t\t\tif (original.typeVariables != NoTypeVariables) {", "+\t\t\t\t\t\t\t\tskipValues[j] = -1;", "+\t\t\t\t\t\t\t\tcontinue nextVisible; // method is not better since variables are not equal", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tcontinue nextVisible; // method2 is better match than method", "+\t\t\t\t\t\t}", "+\t\t\t\tmethod = visible[i]; // instead of the tieBreakMethod"]}], "num": 63007}