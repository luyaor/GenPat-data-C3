{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1ec8afe0dd7edd9815f770825201cd3b", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7ab13da32958241d83fecd6fc3f8567c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "1317e9ebe26807b45d83a46701194241e6f648d5", "commitAfterChange": "3649f3f6d703fd53c9c12b41cdc037f657d98134", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 39, "signatureBeforeChange": "\r \tpublic void classpathContainerChanged(IPath containerPath, IJavaElement changeScope, IProgressMonitor monitor)", "signatureAfterChange": "\r \tpublic void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor)", "diff": ["-\t */\r", "-\tpublic void classpathContainerChanged(IPath containerPath, IJavaElement changeScope, IProgressMonitor monitor){\r", "-\r", "-\t\t//TOFIX\r", "-\t}\r", "+\t */\r", "+\tpublic void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor){\r", "+/*\r", "+\t\tif (monitor != null && monitor.isCanceled()) return;\r", "+\t\t\r", "+\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\t\tArrayList projectsToCheck = new ArrayList();\r", "+\t\t\r", "+\t\tswitch (affectedElement.getElementType()){\r", "+\t\t\tcase IJavaElement.JAVA_PROJECT:\r", "+\t\t\t\tprojectsToCheck.add(affectedElement);\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase IJavaElement.JAVA_MODEL:\r", "+\t\t\t\tIJavaProject[] projects = manager.getJavaModel().getJavaProjects();\r", "+\t\t\t\tfor (int i = 0; i < projects.length; i++) {\r", "+\t\t\t\t\tprojectsToCheck.add(projects[i]);\r", "+\t\t\t\t}\r", "+\t\t\t\tbreak;\r", "+\t\t\tdefault:\r", "+\t\t\t\t// no effect if affected element isn't one of the above case\r", "+\t\t\t\treturn;\r", "+\t\t}\r", "+\r", "+\t\t// gather classpath information for updating\r", "+\t\tHashMap affectedProjects = new HashMap(5);\r", "+\r", "+\t\tif (monitor != null && monitor.isCanceled()) return;\r", "+\r", "+\t\tnextProject : for (int i = 0, projectLength = projectsToCheck.length; i < projectLength; i++){\r", "+\t\t\tIJavaProject project = projectsToCheck[i];\r", "+\t\t\t\t\t\r", "+\t\t\t// check to see if any of the modified variables is present on the classpath\r", "+\t\t\tIClasspathEntry[] classpath = project.getRawClasspath();\r", "+\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++){\r", "+\t\t\t\t\r", "+\t\t\t\tIClasspathEntry entry = classpath[j];\r", "+\t\t\t\tfor (int k = 0; k < varLength; k++){\r", "+\r", "+\t\t\t\t\tString variableName = variableNames[k];\t\t\t\t\t\t\r", "+\t\t\t\t\tif (entry.getEntryKind() ==  IClasspathEntry.CPE_CONTAINER){\r", "+\r", "+\t\t\t\t\t\tif (entry.getPath().equals(containerPath)){\r", "+\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));\r", "+\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t// also check whether it will be necessary to update proj references and cycle markers\r", "+\t\t\t\t\t\t\tif (!mayChangeProjectDependencies && entry.getPath().segmentCount() ==  1){\r", "+\t\t\t\t\t\t\t\tIPath oldPath = (IPath)JavaModelManager.Variables.get(variableName);\r", "+\t\t\t\t\t\t\t\tif (oldPath != null && oldPath.segmentCount() == 1) {\r", "+\t\t\t\t\t\t\t\t\tmayChangeProjectDependencies = true;\r", "+\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\tIPath newPath = variablePaths[k];\r", "+\t\t\t\t\t\t\t\t\tif (newPath != null && newPath.segmentCount() == 1) {\r", "+\t\t\t\t\t\t\t\t\t\tmayChangeProjectDependencies = true;\r", "+\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tcontinue nextProject;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tIPath sourcePath, sourceRootPath;\r", "+\t\t\t\t\t\tif (((sourcePath = entry.getSourceAttachmentPath()) != null\t&& sourcePath.segment(0).equals(variableName))\r", "+\t\t\t\t\t\t\t|| ((sourceRootPath = entry.getSourceAttachmentRootPath()) != null\t&& sourceRootPath.segment(0).equals(variableName))) {\r", "+\r", "+\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));\r", "+\t\t\t\t\t\t\tcontinue nextProject;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\t// reset saved container path\r", "+\t\tfor (int i = 0; i < \r", "+\t\tMap projectContainers = (Map)JavaModelManager.Containers.get(project);\r", "+\t\tif (projectContainers != null){\r", "+\t\t\tIClasspathEntry[] entries = (IClasspathEntry[])projectContainers.get(containerPath);\r", "+\t\t\t\t\r", "+\t\t// update affected project classpaths\r", "+\t\tif (!affectedProjects.isEmpty()) {\r", "+\t\t\tboolean wasFiring = manager.isFiring();\r", "+\t\t\ttry {\r", "+\t\t\t\tif (wasFiring)\r", "+\t\t\t\t\tmanager.stopDeltas();\r", "+\t\t\t\t// propagate classpath change\r", "+\t\t\t\tIterator projectsToUpdate = affectedProjects.keySet().iterator();\r", "+\t\t\t\twhile (projectsToUpdate.hasNext()) {\r", "+\r", "+\t\t\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "+\r", "+\t\t\t\t\tJavaProject project = (JavaProject) projectsToUpdate.next();\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tif (!projectsToUpdate.hasNext()) {\r", "+\t\t\t\t\t\t// re-enable firing for the last operation\r", "+\t\t\t\t\t\tif (wasFiring) {\r", "+\t\t\t\t\t\t\twasFiring = false;\r", "+\t\t\t\t\t\t\tmanager.startDeltas();\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tproject\r", "+\t\t\t\t\t\t.setRawClasspath(\r", "+\t\t\t\t\t\t\tproject.getRawClasspath(),\r", "+\t\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,\r", "+\t\t\t\t\t\t\tmonitor,\r", "+\t\t\t\t\t\t\ttrue,\r", "+\t\t\t\t\t\t\tproject.getWorkspace().isAutoBuilding(),\r", "+\t\t\t\t\t\t\t// force build if in auto build mode\r", "+\t\t\t\t\t\t\t(IClasspathEntry[]) affectedProjects.get(project),\r", "+\t\t\t\t\t\t\tmayChangeProjectDependencies);\r", "+\t\t\t\t}\r", "+\t\t\t} finally {\r", "+\t\t\t\tif (wasFiring) {\r", "+\t\t\t\t\tmanager.startDeltas();\r", "+\t\t\t\t\t// in case of exception traversing, deltas may be fired only in the next #fire() iteration\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+*/\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d31d654d63970b1e540e705f0a6d049d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "8726985690d5211d83787440cfdc69960f688cd3", "commitAfterChange": "b2bac1f114347c5119b74b76ba91158e0de76647", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "\r \tpublic void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor)", "signatureAfterChange": "\r \tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] newContainers, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\tpublic void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor){\r", "-/*\r", "+\tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] newContainers, IProgressMonitor monitor) throws JavaModelException {\r", "+\r", "-\t\t\r", "+\r", "+\t\tint projectLength = affectedProjects.length;\r", "-\t\tArrayList projectsToCheck = new ArrayList();\r", "+\t\tIClasspathEntry[][] oldResolvedPaths = new IClasspathEntry[projectLength][];\r", "+\r", "+\t\t// filter out unmodified project containers\r", "+\t\tint remaining = 0;\r", "+\t\tfor (int i = 0; i < projectLength; i++){\r", "+\r", "+\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "+\r", "+\t\t\tIJavaProject affectedProject = affectedProjects[i];\r", "+\t\t\tIClasspathContainer newContainer = newContainers[i];\r", "+\t\t\t\r", "+\t\t\tIClasspathEntry[] rawClasspath = affectedProject.getRawClasspath();\r", "+\t\t\tboolean found = false;\r", "+\t\t\tfor (int j = 0, cpLength = rawClasspath.length; j <cpLength; j++) {", "+\t\t\t\tIClasspathEntry entry = rawClasspath[j];\r", "+\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER && entry.getPath().equals(containerPath)){\r", "+\t\t\t\t\tfound = true;\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\t}", "+\t\t\t}\r", "+\t\t\tif (!found){\r", "+\t\t\t\taffectedProjects[i] = null; // filter out this project - does not reference the container path\r", "+\t\t\t\tcontinue;\r", "+\t\t\t}\r", "+\t\t\tMap perProjectContainers = (Map)JavaModelManager.Containers.get(affectedProject);\r", "+\t\t\tif (perProjectContainers == null){\r", "+\t\t\t\tperProjectContainers = new HashMap();\r", "+\t\t\t\tJavaModelManager.Containers.put(affectedProject, perProjectContainers);\r", "+\t\t\t} else {\r", "+\t\t\t\tIClasspathContainer oldContainer = (IClasspathContainer) perProjectContainers.get(containerPath);\r", "+\t\t\t\tif (oldContainer != null && oldContainer.equals(newContainers[i])){\r", "+\t\t\t\t\taffectedProjects[i] = null; // filter out this project - container did not change\r", "+\t\t\t\t\tcontinue;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tremaining++;\r", "+\t\t\toldResolvedPaths[i] = affectedProject.getResolvedClasspath(true);\r", "+\t\t\tperProjectContainers.put(containerPath, newContainer);\r", "+\t\t}\r", "-\t\tswitch (affectedElement.getElementType()){\r", "-\t\t\tcase IJavaElement.JAVA_PROJECT:\r", "-\t\t\t\tprojectsToCheck.add(affectedElement);\r", "-\t\t\t\tbreak;\r", "-\t\t\tcase IJavaElement.JAVA_MODEL:\r", "-\t\t\t\tIJavaProject[] projects = manager.getJavaModel().getJavaProjects();\r", "-\t\t\t\tfor (int i = 0; i < projects.length; i++) {\r", "-\t\t\t\t\tprojectsToCheck.add(projects[i]);\r", "-\t\t\t\t}\r", "-\t\t\t\tbreak;\r", "-\t\t\tdefault:\r", "-\t\t\t\t// no effect if affected element isn't one of the above case\r", "-\t\t\t\treturn;\r", "-\t\t}\r", "-\r", "-\t\t// gather classpath information for updating\r", "-\t\tHashMap affectedProjects = new HashMap(5);\r", "-\r", "-\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\r", "-\t\tnextProject : for (int i = 0, projectLength = projectsToCheck.length; i < projectLength; i++){\r", "-\t\t\tIJavaProject project = projectsToCheck[i];\r", "-\t\t\t\t\t\r", "-\t\t\t// check to see if any of the modified variables is present on the classpath\r", "-\t\t\tIClasspathEntry[] classpath = project.getRawClasspath();\r", "-\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++){\r", "+\t\tif (remaining == 0) return;\r", "+\t\t\r", "+\t\t// trigger model refresh\r", "+\t\tboolean wasFiring = manager.isFiring();\r", "+\t\tint count = 0;\r", "+\t\ttry {\r", "+\t\t\tif (wasFiring)\r", "+\t\t\t\tmanager.stopDeltas();\r", "-\t\t\t\tIClasspathEntry entry = classpath[j];\r", "-\t\t\t\tfor (int k = 0; k < varLength; k++){\r", "+\t\t\tfor(int i = 0; i < projectLength; i++){\r", "-\t\t\t\t\tString variableName = variableNames[k];\t\t\t\t\t\t\r", "-\t\t\t\t\tif (entry.getEntryKind() ==  IClasspathEntry.CPE_CONTAINER){\r", "+\t\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\t\t\t\t\t\tif (entry.getPath().equals(containerPath)){\r", "-\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));\r", "-\t\t\t\t\t\t\t\r", "-\t\t\t\t\t\t\t// also check whether it will be necessary to update proj references and cycle markers\r", "-\t\t\t\t\t\t\tif (!mayChangeProjectDependencies && entry.getPath().segmentCount() ==  1){\r", "-\t\t\t\t\t\t\t\tIPath oldPath = (IPath)JavaModelManager.Variables.get(variableName);\r", "-\t\t\t\t\t\t\t\tif (oldPath != null && oldPath.segmentCount() == 1) {\r", "-\t\t\t\t\t\t\t\t\tmayChangeProjectDependencies = true;\r", "-\t\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t\tIPath newPath = variablePaths[k];\r", "-\t\t\t\t\t\t\t\t\tif (newPath != null && newPath.segmentCount() == 1) {\r", "-\t\t\t\t\t\t\t\t\t\tmayChangeProjectDependencies = true;\r", "-\t\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\tcontinue nextProject;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tIPath sourcePath, sourceRootPath;\r", "-\t\t\t\t\t\tif (((sourcePath = entry.getSourceAttachmentPath()) != null\t&& sourcePath.segment(0).equals(variableName))\r", "-\t\t\t\t\t\t\t|| ((sourceRootPath = entry.getSourceAttachmentRootPath()) != null\t&& sourceRootPath.segment(0).equals(variableName))) {\r", "-\r", "-\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));\r", "-\t\t\t\t\t\t\tcontinue nextProject;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\t// reset saved container path\r", "-\t\tfor (int i = 0; i < \r", "-\t\tMap projectContainers = (Map)JavaModelManager.Containers.get(project);\r", "-\t\tif (projectContainers != null){\r", "-\t\t\tIClasspathEntry[] entries = (IClasspathEntry[])projectContainers.get(containerPath);\r", "+\t\t\t\tJavaProject affectedProject = (JavaProject)affectedProjects[i];\r", "+\t\t\t\tif (affectedProject == null) continue; // was filtered out\r", "-\t\t// update affected project classpaths\r", "-\t\tif (!affectedProjects.isEmpty()) {\r", "-\t\t\tboolean wasFiring = manager.isFiring();\r", "-\t\t\ttry {\r", "-\t\t\t\tif (wasFiring)\r", "-\t\t\t\t\tmanager.stopDeltas();\r", "-\t\t\t\t// propagate classpath change\r", "-\t\t\t\tIterator projectsToUpdate = affectedProjects.keySet().iterator();\r", "-\t\t\t\twhile (projectsToUpdate.hasNext()) {\r", "-\r", "-\t\t\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\r", "-\t\t\t\t\tJavaProject project = (JavaProject) projectsToUpdate.next();\r", "-\t\t\t\t\t\r", "-\t\t\t\t\tif (!projectsToUpdate.hasNext()) {\r", "-\t\t\t\t\t\t// re-enable firing for the last operation\r", "-\t\t\t\t\t\tif (wasFiring) {\r", "-\t\t\t\t\t\t\twasFiring = false;\r", "-\t\t\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\t\t}\r", "+\t\t\t\tif (++count == remaining) { // re-enable firing for the last operation\r", "+\t\t\t\t\tif (wasFiring) {\r", "+\t\t\t\t\t\twasFiring = false;\r", "+\t\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\tproject\r", "-\t\t\t\t\t\t.setRawClasspath(\r", "-\t\t\t\t\t\t\tproject.getRawClasspath(),\r", "-\t\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,\r", "-\t\t\t\t\t\t\tmonitor,\r", "-\t\t\t\t\t\t\ttrue,\r", "-\t\t\t\t\t\t\tproject.getWorkspace().isAutoBuilding(),\r", "-\t\t\t\t\t\t\t// force build if in auto build mode\r", "-\t\t\t\t\t\t\t(IClasspathEntry[]) affectedProjects.get(project),\r", "-\t\t\t\t\t\t\tmayChangeProjectDependencies);\r", "-\t\t\t} finally {\r", "-\t\t\t\tif (wasFiring) {\r", "-\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\t// in case of exception traversing, deltas may be fired only in the next #fire() iteration\r", "+\t\t\t\r", "+\t\t\t\t// force a refresh of the affected project (will compute deltas)\r", "+\t\t\t\taffectedProject.setRawClasspath(\r", "+\t\t\t\t\t\taffectedProject.getRawClasspath(),\r", "+\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,\r", "+\t\t\t\t\t\tmonitor,\r", "+\t\t\t\t\t\ttrue,\r", "+\t\t\t\t\t\taffectedProject.getWorkspace().isAutoBuilding(),\r", "+\t\t\t\t\t\toldResolvedPaths[i],\r", "+\t\t\t\t\t\tremaining == 1); // no individual cycle check if more than 1 project\r", "+\t\t\t}\r", "+\t\t\tif (remaining > 1){\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\t// use workspace runnable so as to allow marker creation - workaround bug 14733\r", "+\t\t\t\t\tResourcesPlugin.getWorkspace().run(\r", "+\t\t\t\t\t\tnew IWorkspaceRunnable() {\r", "+\t\t\t\t\t\t\tpublic void run(IProgressMonitor monitor) throws CoreException {\r", "+\t\t\t\t\t\t\t\tJavaProject.updateAllCycleMarkers(); // update them all at once\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}, \r", "+\t\t\t\t\t\tmonitor);\t\t\t\t\t\r", "+\t\t\t\t} catch(CoreException e){\r", "+\t\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t} finally {\r", "+\t\t\tif (wasFiring) {\r", "+\t\t\t\tmanager.startDeltas();\r", "+\t\t\t\t// in case of exception traversing, deltas may be fired only in the next #fire() iteration\r", "+\t\t\t}\r", "-*/\r", "+\t\t\t\t\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7cb0d8ca326c163bca0479209c4b7ae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "2f2916c1fb13d22701e433ffbb1a51f9e96c2bc4", "commitAfterChange": "a47d03faa1d7f04a91914573d6a6cca4eff80427", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 42, "signatureBeforeChange": "\r \tprivate static void updateVariableValue(\r \t\tString variableName,\r \t\tIPath path,\r \t\tIProgressMonitor monitor)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r \tprivate static void updateVariableValues(\r \t\tString[] variableNames,\r \t\tIPath[] variablePaths,\r \t\tIProgressMonitor monitor) throws JavaModelException", "diff": ["-\tprivate static void updateVariableValue(\r", "-\t\tString variableName,\r", "-\t\tIPath path,\r", "-\t\tIProgressMonitor monitor)\r", "-\t\tthrows JavaModelException {\r", "+\tprivate static void updateVariableValues(\r", "+\t\tString[] variableNames,\r", "+\t\tIPath[] variablePaths,\r", "+\t\tIProgressMonitor monitor) throws JavaModelException {\r", "+\t\tif (monitor != null && monitor.isCanceled()) return;\r", "+\t\t\r", "+\t\tint varLength = variableNames.length;\r", "+\t\t\r", "-\t\ttry {\r", "-\t\t\tIJavaModel model = manager.getJavaModel();\r", "-\t\t\tif (model != null) {\r", "-\t\t\t\tIJavaProject[] projects = model.getJavaProjects();\r", "-\t\t\t\tnextProject : for (int i = 0, max = projects.length; i < max; i++) {\r", "-\t\t\t\t\tIClasspathEntry[] entries = projects[i].getRawClasspath();\r", "-\t\t\t\t\tfor (int j = 0, cplength = entries.length; j < cplength; j++) {\r", "-\t\t\t\t\t\tIClasspathEntry oldEntry = entries[j];\r", "-\t\t\t\t\t\tif (oldEntry.getEntryKind() == IClasspathEntry.CPE_VARIABLE) {\r", "+\t\tIJavaModel model = manager.getJavaModel();\r", "+\r", "+\t\t// filter out unmodified variables\r", "+\t\tint discardCount = 0;\r", "+\t\tfor (int i = 0; i < varLength; i++){\r", "+\t\t\tIPath oldPath = (IPath)Variables.get(variableNames[i]);\r", "+\t\t\tif (oldPath != null && oldPath.equals(variablePaths[i])){\r", "+\t\t\t\tvariableNames[i] = null;\r", "+\t\t\t\tdiscardCount++;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (discardCount > 0){\r", "+\t\t\tif (discardCount == varLength) return;\r", "+\t\t\tint changedLength = varLength - discardCount;\r", "+\t\t\tString[] changedVariableNames = new String[changedLength];\r", "+\t\t\tIPath[] changedVariablePaths = new IPath[changedLength];\r", "+\t\t\tfor (int i = 0, index = 0; i < varLength; i++){\r", "+\t\t\t\tif (variableNames[i] != null){\r", "+\t\t\t\t\tchangedVariableNames[index] = variableNames[i];\r", "+\t\t\t\t\tchangedVariablePaths[index] = variablePaths[i];\r", "+\t\t\t\t\tindex++;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tvariableNames = changedVariableNames;\r", "+\t\t\tvariablePaths = changedVariablePaths;\r", "+\t\t\tvarLength = changedLength;\r", "+\t\t}\r", "+\t\t\r", "+\t\tif (monitor != null && monitor.isCanceled()) return;\r", "+\r", "+\t\tif (model != null) {\r", "+\t\t\tIJavaProject[] projects = model.getJavaProjects();\r", "+\t\t\tnextProject : for (int i = 0, projectLength = projects.length; i < projectLength; i++){\r", "+\t\t\t\tIJavaProject project = projects[i];\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t// check to see if any of the modified variables is present on the classpath\r", "+\t\t\t\tIClasspathEntry[] classpath = project.getRawClasspath();\r", "+\t\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++){\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tIClasspathEntry entry = classpath[j];\r", "+\t\t\t\t\tfor (int k = 0; k < varLength; k++){\r", "+\r", "+\t\t\t\t\t\tString variableName = variableNames[k];\t\t\t\t\t\t\r", "+\t\t\t\t\t\tif (entry.getEntryKind() ==  IClasspathEntry.CPE_VARIABLE){\r", "+\r", "-\t\t\t\t\t\t\tif (oldEntry.getPath().segment(0).equals(variableName)\r", "-\t\t\t\t\t\t\t\t|| ((sourcePath = oldEntry.getSourceAttachmentPath()) != null\r", "-\t\t\t\t\t\t\t\t\t&& sourcePath.segment(0).equals(variableName))\r", "-\t\t\t\t\t\t\t\t|| ((sourceRootPath = oldEntry.getSourceAttachmentRootPath()) != null\r", "-\t\t\t\t\t\t\t\t\t&& sourceRootPath.segment(0).equals(variableName))) {\r", "-\t\t\t\t\t\t\t\taffectedProjects.put(projects[i], ((JavaProject)projects[i]).getExpandedClasspath(true));\r", "+\t\t\t\t\t\t\tif (entry.getPath().segment(0).equals(variableName)\r", "+\t\t\t\t\t\t\t\t\t\t|| ((sourcePath = entry.getSourceAttachmentPath()) != null\t&& sourcePath.segment(0).equals(variableName))\r", "+\t\t\t\t\t\t\t\t\t\t|| ((sourceRootPath = entry.getSourceAttachmentRootPath()) != null\t&& sourceRootPath.segment(0).equals(variableName))) {\r", "+\t\t\t\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getExpandedClasspath(true));\r", "-\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\r", "-\t\t} catch (JavaModelException e) {\r", "-\t\tif (path == null) {\r", "-\t\t\tVariables.remove(variableName);\r", "-\t\t} else {\r", "-\t\t\t// new variable value is assigned\r", "-\t\t\tVariables.put(variableName, path);\r", "+\t\t// update variables\r", "+\t\tfor (int i = 0; i < varLength; i++){\r", "+\t\t\tIPath path = variablePaths[i];\r", "+\t\t\tif (path == null) {\r", "+\t\t\t\tVariables.remove(variableNames[i]);\r", "+\t\t\t} else {\r", "+\t\t\t\t// new variable value is assigned\r", "+\t\t\t\tVariables.put(variableNames[i], path);\r", "+\t\t\t}\r", "+\t\t\t\t\r", "+\t\t// update affected project classpaths\r", "+\r", "+\t\t\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "+\r"]}], "num": 93}