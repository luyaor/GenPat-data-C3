{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "93ca3d2f232186368e23e138eaa1a971", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "11c6267f35f273ba9d64009171e1ce26", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java", "commitBeforeChange": "24dd55a6c6cf382583635c8206f082775e353206", "commitAfterChange": "44f6e5d4c5aa57a943059b880589a2a0bea34009", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["+\t\tboolean isOptimizedFalseAssertion = cst != NotAConstant && cst.booleanValue() == false;", "+", "-\t\t\texceptionArgument.analyseCode(currentScope, flowContext, assertInfo.copy()); //dead branch", "+\t\t\t// only gets evaluated when escaping - results are not taken into account", "+\t\t\texceptionArgument.analyseCode(currentScope, flowContext, assertInfo.copy()); ", "-\t\treturn flowInfo.mergedWith(assertInfo.unconditionalInits()); ", "+\t\tif (isOptimizedFalseAssertion) {", "+\t\t\treturn flowInfo; // if assertions are enabled, the following code will be unreachable", "+\t\t} else {", "+\t\t\treturn flowInfo.mergedWith(assertInfo.unconditionalInits()); ", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e910ca8974bfbb9568b3fcf0bb3a5da7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java", "commitBeforeChange": "cd6826d338c946dccccfded9e97883fe86b0725e", "commitAfterChange": "24dd55a6c6cf382583635c8206f082775e353206", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tFlowInfo assertInfo = assertExpression.analyseCode(currentScope, flowContext, flowInfo.copy()).unconditionalInits();", "-\t\t\t", "+", "+\t\tConstant cst = this.assertExpression.optimizedBooleanConstant();\t\t", "+\t\tboolean isOptimizedTrueAssertion = cst != NotAConstant && cst.booleanValue() == true;", "+\t\tFlowInfo assertInfo = flowInfo.copy();", "+\t\tif (isOptimizedTrueAssertion) {", "+\t\t\tassertInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\t\t}", "+\t\tassertInfo = assertExpression.analyseCode(currentScope, flowContext, assertInfo).unconditionalInits();", "+\t\t", "-\t\t\tassertInfo = exceptionArgument.analyseCode(currentScope, flowContext, assertInfo);", "+\t\t\texceptionArgument.analyseCode(currentScope, flowContext, assertInfo.copy()); //dead branch", "-", "-\t\tFlowInfo mergedInfo = flowInfo.mergedWith(assertInfo.unconditionalInits());", "-\t\treturn mergedInfo;", "+\t\treturn flowInfo.mergedWith(assertInfo.unconditionalInits()); "]}], "num": 43519}