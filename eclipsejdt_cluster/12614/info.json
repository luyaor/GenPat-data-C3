{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "107f36b18d73e2907466356942ccc489", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76d7cb6ea8507de552e8396ddc4a8172", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java", "commitBeforeChange": "5ec4215ec4f52f55dcb6e314c5f755ceba34fff6", "commitAfterChange": "5a4580d346b40161405692269366aba5f28266bb", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \tprivate void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion)", "signatureAfterChange": "\r private void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion)", "diff": ["-\t */\r", "-\tprivate void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion) {\r", "-\t\t\r", "-\t\tint size = allTypesInRegion.size();\r", "-\t\tif (size != 0) {\r", "-\t\t\tthis.infoToHandle = new HashMap(size);\r", "-\t\t}\r", "-\t\tArrayList temp = new ArrayList(size);\r", "-\t\ttypes : for (int i = 0; i < size; i++) {\r", "-\t\t\ttry {\r", "-\t\t\t\tIType type = (IType) allTypesInRegion.get(i);\r", "-\t\t\t\tIGenericType info = (IGenericType) ((JavaElement) type).getRawInfo();\r", "-\t\t\t\ttemp.add(info);\r", "-\t\t\t\tif (info.isBinaryType()) {\r", "-\t\t\t\t\tthis.infoToHandle.put(info, type.getParent());\r", "-\t\t\t\t}\r", "-\t\t\t\tworked(1);\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\tcontinue types;\r", "-\t\t\t}\r", "-\t\t}\r", "+ */\r", "+private void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion) {\r", "+\t\r", "+\tint size = allTypesInRegion.size();\r", "+\tif (size != 0) {\r", "+\t\tthis.infoToHandle = new HashMap(size);\r", "+\t}\r", "+\tIType[] types = new IType[size];\r", "+\tallTypesInRegion.toArray(types);\r", "-\t\tsize = temp.size();\r", "-\t\tif (size > 0) {\r", "-\t\t\tIGenericType[] genericTypes = new IGenericType[size];\r", "-\t\t\ttemp.toArray(genericTypes);\r", "-\t\t\tIType focusType = this.getType();\r", "-\t\t\tCompilationUnit unitToLookInside = null;\r", "-\t\t\tif (focusType != null) {\r", "-\t\t\t\tunitToLookInside = (CompilationUnit)focusType.getCompilationUnit();\r", "-\t\t\t}\r", "-\t\t\tif (this.nameLookup != null && unitToLookInside != null) {\r", "-\t\t\t\tsynchronized(this.nameLookup) { // prevent 2 concurrent accesses to name lookup while the working copies are set\r", "-\t\t\t\t\ttry {\r", "-\t\t\t\t\t\tnameLookup.setUnitsToLookInside(new IWorkingCopy[] {unitToLookInside});\r", "-\t\t\t\t\t\tthis.hierarchyResolver.resolve(genericTypes);\r", "-\t\t\t\t\t} finally {\r", "-\t\t\t\t\t\tnameLookup.setUnitsToLookInside(null);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t} else {\r", "-\t\t\t\tthis.hierarchyResolver.resolve(genericTypes);\r", "+\t/*\r", "+\t * NOTE: To workaround pb with hierarchy resolver that requests top  \r", "+\t * level types in the process of caching an enclosing type, this needs to\r", "+\t * be sorted in reverse alphabetical order so that top level types are cached\r", "+\t * before their inner types.\r", "+\t */\r", "+\tUtil.sort(\r", "+\t\ttypes,\r", "+\t\tnew Util.Comparer() {\r", "+\t\t\t/**\r", "+\t\t\t * @see Comparer#compare(Object, Object)\r", "+\t\t\t */\r", "+\t\t\tpublic int compare(Object a, Object b) {\r", "+\t\t\t\treturn - ((IJavaElement)a).getParent().getElementName().compareTo(((IJavaElement)b).getParent().getElementName());\r", "+\t);\r", "+\r", "+\t// collect infos and compilation units\r", "+\tArrayList infos = new ArrayList();\r", "+\tArrayList units = new ArrayList();\r", "+\ttypes : for (int i = 0; i < size; i++) {\r", "+\t\ttry {\r", "+\t\t\tIType type = types[i];\r", "+\t\t\tthis.addInfoFromElement((Openable)type.getOpenable(), infos, units, type.getPath().toString());\r", "+\t\t\tworked(1);\r", "+\t\t} catch (JavaModelException npe) {\r", "+\t\t\tcontinue types;\r", "+\t\t}\r", "+\r", "+\t// copy vectors into arrays\r", "+\tIGenericType[] genericTypes;\r", "+\tint infosSize = infos.size();\r", "+\tif (infosSize > 0) {\r", "+\t\tgenericTypes = new IGenericType[infosSize];\r", "+\t\tinfos.toArray(genericTypes);\r", "+\t} else {\r", "+\t\tgenericTypes = new IGenericType[0];\r", "+\t}\r", "+\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit[] compilationUnits;\r", "+\tint unitsSize = units.size();\r", "+\tif (unitsSize > 0) {\r", "+\t\tcompilationUnits = new org.eclipse.jdt.internal.compiler.env.ICompilationUnit[unitsSize];\r", "+\t\tunits.toArray(compilationUnits);\r", "+\t} else {\r", "+\t\tcompilationUnits = new org.eclipse.jdt.internal.compiler.env.ICompilationUnit[0];\r", "+\t}\r", "+\r", "+\t// resolve\r", "+\tif (infosSize > 0 || unitsSize > 0) {\r", "+\t\tIType focusType = this.getType();\r", "+\t\tCompilationUnit unitToLookInside = null;\r", "+\t\tif (focusType != null) {\r", "+\t\t\tunitToLookInside = (CompilationUnit)focusType.getCompilationUnit();\r", "+\t\t}\r", "+\t\tif (this.nameLookup != null && unitToLookInside != null) {\r", "+\t\t\tsynchronized(this.nameLookup) { // prevent 2 concurrent accesses to name lookup while the working copies are set\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tnameLookup.setUnitsToLookInside(new IWorkingCopy[] {unitToLookInside});\r", "+\t\t\t\t\tthis.hierarchyResolver.resolve(genericTypes, compilationUnits);\r", "+\t\t\t\t} finally {\r", "+\t\t\t\t\tnameLookup.setUnitsToLookInside(null);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t} else {\r", "+\t\t\tthis.hierarchyResolver.resolve(genericTypes, compilationUnits);\r", "+\t\t}\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "96fa21a00e34f3db089bef4600b99ac0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java", "commitBeforeChange": "c382c60104b7fa9333f25f2fb10b318d2a6c9d85", "commitAfterChange": "890be42f32773e7ca5496c222c424ace19ee53bc", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \t \tprivate void computeAllRootPaths(IPackageFragmentRoot root)", "signatureAfterChange": " \t \tprivate void computeAllRootPaths(IPackageFragmentRoot root)", "diff": ["-\t\tif (this.rootPaths == null) {", "-\t\t\tthis.rootPaths = new HashSet();", "-\t\t}", "+\t\tfinal HashSet tempRoots = new HashSet();", "-\t\t\t\t\t\t\tIStatus status = JavaConventions.validatePackageName(firstLevelPackageName);", "-\t\t\t\t\t\t\tif (status.isOK() || status.getSeverity() == IStatus.WARNING) {", "-\t\t\t\t\t\t\t\tfirstLevelPackageNames.add(firstLevelPackageName);", "+\t\t\t\t\t\t\tif (!firstLevelPackageNames.contains(firstLevelPackageName)) {", "+\t\t\t\t\t\t\t\tIStatus status = JavaConventions.validatePackageName(firstLevelPackageName);", "+\t\t\t\t\t\t\t\tif (status.isOK() || status.getSeverity() == IStatus.WARNING) {", "+\t\t\t\t\t\t\t\t\tfirstLevelPackageNames.add(firstLevelPackageName);", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tthis.rootPaths.add(path.uptoSegment(i).toString());", "+\t\t\t\t\t\t\t\t\ttempRoots.add(path.uptoSegment(i));", "-\t\t\t\t\t\t\t\t\tthis.rootPaths.add(path.uptoSegment(max).toString());", "+\t\t\t\t\t\t\t\t\ttempRoots.add(path.uptoSegment(max));", "-\t\t\t\t\t\t\tthis.rootPaths.add(\"\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\ttempRoots.add(new Path(\"\")); //$NON-NLS-1$", "-\t\t\t\t\tcomputeRootPath((IContainer)target, firstLevelPackageNames, containsADefaultPackage);", "+\t\t\t\t\tcomputeRootPath((IContainer)target, firstLevelPackageNames, containsADefaultPackage, tempRoots);", "-\t\t\t\t\tcomputeRootPath(file, firstLevelPackageNames, containsADefaultPackage);", "+\t\t\t\t\tcomputeRootPath(file, firstLevelPackageNames, containsADefaultPackage, tempRoots);", "+\t\tint size = tempRoots.size();", "+\t\tif (this.rootPaths != null) {", "+\t\t\tfor (Iterator iterator = this.rootPaths.iterator(); iterator.hasNext(); ) {", "+\t\t\t\ttempRoots.add(iterator.next());", "+\t\t\t\tsize++;", "+\t\t\t}", "+\t\t\tthis.rootPaths.clear();", "+\t\t} else {", "+\t\t\tthis.rootPaths = new ArrayList(size);", "+\t\t}", "+\t\tif (size != 0) {", "+\t\t\tArrayList sortedRoots = new ArrayList(tempRoots);", "+\t\t\tCollections.sort(sortedRoots, new Comparator() {", "+\t\t\t\tpublic int compare(Object o1, Object o2) {", "+\t\t\t\t\tIPath path1 = (IPath) o1;", "+\t\t\t\t\tIPath path2 = (IPath) o2;", "+\t\t\t\t\treturn path1.segmentCount() - path2.segmentCount();", "+\t\t\t\t}", "+\t\t\t});", "+\t\t\tfor (Iterator iter = sortedRoots.iterator(); iter.hasNext();) {", "+\t\t\t\tIPath path = (IPath) iter.next();", "+\t\t\t\tthis.rootPaths.add(path.toString());", "+\t\t\t}", "+\t\t}", "+\t\tthis.areRootPathsComputed = true;", "-\t\t\tfinal int size = this.rootPaths.size();", "+\t\t\tSystem.out.println(\"Spent \" + (System.currentTimeMillis() - time) + \"ms\"); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t\tString rootpath = (String) iterator.next();", "-\t\t\t\tSystem.out.println(\"root[\" + i + \"]=\" + rootpath);//$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\tSystem.out.println(\"root[\" + i + \"]=\" + ((String) iterator.next()));//$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\tSystem.out.println(\"Spent \" + (System.currentTimeMillis() - time) + \"ms\"); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\tthis.areRootPathsComputed = true;"]}], "num": 12614}