{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3456ee62b51ba3ba5263c9c4ebbe2bb1", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8181d5771b8fb080bf72cd693f86c293", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "3eb085ff141aa0943f0e7cfcd789554d94243507", "commitAfterChange": "8f6891d448939e984803e732396c844070896f56", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " private Binding findImport(char[][] compoundName, int length)", "signatureAfterChange": " public Binding findImport(char[][] compoundName, boolean findStaticImports, boolean onDemand)", "diff": ["+// this API is for code assist purpose", "+public Binding findImport(char[][] compoundName, boolean findStaticImports, boolean onDemand) {", "+\tif(onDemand) {", "+\t\treturn findImport(compoundName, compoundName.length);", "+\t} else {", "+\t\treturn findSingleImport(compoundName, findStaticImports);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "844d7acc13da37ac0ee3f67da9ca83b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 21, "signatureBeforeChange": " \t \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "  \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-\t", "+", "-\t\t\tchar[][] compoundName = typeReference.getTypeName();", "-\t\t\tcompilationUnitScope().recordQualifiedReference(compoundName);", "-\t\t\tSourceTypeBinding sourceType = referenceContext.binding;", "-\t\t\tint size = compoundName.length;", "-\t\t\tint n = 1;", "-\t\t\tReferenceBinding superType;", "+\t\t\tcompilationUnitScope().recordQualifiedReference(typeReference.getTypeName());", "+\t\t\tthis.superTypeReference = typeReference;", "+\t\t\tReferenceBinding superType = (ReferenceBinding) typeReference.resolveSuperType(this);", "+\t\t\tthis.superTypeReference = null;", "+\t\t\tif (superType == null) return null;", "-\t\t\t// resolve the first name of the compoundName", "-\t\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {", "-\t\t\t\tsuperType = sourceType;", "-\t\t\t\t// match against the sourceType even though nested members cannot be supertypes", "-\t\t\t} else {", "-\t\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);", "-\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())", "-\t\t\t\t\treturn new ProblemReferenceBinding(", "-\t\t\t\t\t\tcompoundName[0],", "-\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());", "-\t", "-\t\t\t\tboolean checkVisibility = false;", "-\t\t\t\tfor (; n < size; n++) {", "-\t\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;", "-\t\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);", "-\t\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())", "-\t\t\t\t\t\treturn new ProblemReferenceBinding(", "-\t\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),", "-\t\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());", "-\t\t\t\t\tcheckVisibility = true;", "-\t\t\t\t}", "-\t", "-\t\t\t\t// convert to a ReferenceBinding", "-\t\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName", "-\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);", "-\t\t\t\tsuperType = (ReferenceBinding) typeOrPackage;", "-\t\t\t\tcompilationUnitScope().recordTypeReference(superType); // to record supertypes", "-\t", "-\t\t\t\tif (checkVisibility", "-\t\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility", "-\t\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))", "-\t\t\t\t\t\t// its a toplevel type so just check package access", "-\t\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), superType, NotVisible);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// at this point we know we have a type but we have to look for cycles", "-\t\t\twhile (true) {", "-\t\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.", "-\t\t\t\t// must be guaranteed that the superType knows its entire hierarchy", "-\t\t\t\tif (detectCycle(sourceType, superType, typeReference))", "-\t\t\t\t\treturn null; // cycle error was already reported", "-\t", "-\t\t\t\tif (n >= size)", "-\t\t\t\t\tbreak;", "-\t", "-\t\t\t\t// retrieve the next member type", "-\t\t\t\tchar[] typeName = compoundName[n++];", "-\t\t\t\tsuperType = findMemberType(typeName, superType);", "-\t\t\t\tif (superType == null)", "-\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);", "-\t\t\t\tif (!superType.isValidBinding()) {", "-\t\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);", "-\t\t\t\t\treturn superType;", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tcompilationUnitScope().recordTypeReference(superType); // to record supertypes", "+\t\t\tif (superType.isParameterizedType())", "+\t\t\t\treturn superType; // already checked cycle before resolving its type variables", "+", "+\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.", "+\t\t\t// must be guaranteed that the superType knows its entire hierarchy", "+\t\t\tif (detectCycle(referenceContext.binding, superType, typeReference))", "+\t\t\t\treturn null; // cycle error was already reported", "-\t\t}", "+\t\t}\t\t\t"]}], "num": 40192}