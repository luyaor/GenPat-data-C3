{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a236ed6746fdffce5531de4e8e0215fd", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9916187182e717674cf7b493f599d68c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java", "commitBeforeChange": "c7e159d36a6e86c73ba8d33970f5e7f3b5edc0c4", "commitAfterChange": "d4e2f0c7a3096a7a9485b327e844751de2001505", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tUnconditionalFlowInfo assertInfo = assertExpression.", "-\t\t\tanalyseCode(currentScope, flowContext, flowInfo.copy()).", "+\t\tFlowInfo assertRawInfo = assertExpression.", "+\t\t\tanalyseCode(currentScope, flowContext, flowInfo.copy());", "+\t\tUnconditionalFlowInfo assertWhenTrueInfo = assertRawInfo.initsWhenTrue().", "+\t\tUnconditionalFlowInfo assertInfo = assertRawInfo.unconditionalCopy();", "+\t\t\t// change this if we need to carry null analysis results of the assert", "+\t\t\t// expression downstream", "-\t\t\treturn flowInfo.mergedWith(assertInfo); ", "+\t\t\treturn flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).", "+\t\t\t\taddInitializationsFrom(assertWhenTrueInfo.nullInfo());", "+\t\t\t// keep the merge from the initial code for the definite assignment ", "+\t\t\t// analysis, tweak the null part to influence nulls downstream"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c9855087fbab293dd2785e2a76d75acf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java", "commitBeforeChange": "8d45cb26fc5ad244f93e8632d761d46ad4a120cf", "commitAfterChange": "e113fe138f1e4be2f22f54aa73cae2174e2d64a6", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic static FlowInfo markPassedToOutside(BlockScope scope, Expression expression, FlowInfo flowInfo, boolean owned)", "signatureAfterChange": " \tpublic static FlowInfo markPassedToOutside(BlockScope scope, Expression expression, FlowInfo flowInfo, boolean owned)", "diff": ["-\t\t\tif (trackVar.originalBinding == null) {", "-\t\t\t\t// an allocation that never was assigned to a local variable -> drop it completely as we're not responsible", "-\t\t\t\tscope.removeTrackingVar(trackVar);", "-\t\t\t\treturn flowInfo;", "-\t\t\t}", "-\t\t\tFlowInfo infoResourceIsClosed = flowInfo.copy();", "+\t\t\tFlowInfo infoResourceIsClosed = owned ? flowInfo : flowInfo.copy();", "-\t\t\t} while ((trackVar = trackVar.innerTracker) != null); ", "-\t\t\treturn FlowInfo.conditional(flowInfo, infoResourceIsClosed);", "+\t\t\t} while ((trackVar = trackVar.innerTracker) != null);", "+\t\t\tif (owned) {", "+\t\t\t\treturn infoResourceIsClosed; // don't let downstream signal any problems on this flow", "+\t\t\t} else {", "+\t\t\t\treturn FlowInfo.conditional(flowInfo, infoResourceIsClosed); // only report potential problems on this flow", "+\t\t\t}"]}], "num": 41214}