{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c7306e271978f3864966f8242b088cbf", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7784dc96e8a0c1624bc5f46d1456af30", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java", "commitBeforeChange": "cbf4d8b0c602d0860355a0bb315f58708fa257d2", "commitAfterChange": "0d8c4f28f9db6373751aa6d7cffbf4e0fcb51948", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 7, "signatureBeforeChange": " protected char[] indexEntryPrefix()", "signatureAfterChange": " protected char[] indexEntryPrefix()", "diff": ["-protected char[] indexEntryPrefix(){", "-\treturn AbstractIndexer.bestTypeDeclarationPrefix(pkg, simpleName, classOrInterface, matchMode, isCaseSensitive);", "+protected char[] indexEntryPrefix() {", "+\tchar[] packageName = this.isCaseSensitive ? pkg : null;", "+\tswitch(this.classOrInterface) {", "+\t\tcase CLASS_SUFFIX :", "+\t\t\tif (packageName == null) return CLASS_DECL;", "+\t\t\tbreak;", "+\t\tcase INTERFACE_SUFFIX :", "+\t\t\tif (packageName == null) return INTERFACE_DECL;", "+\t\t\tbreak;", "+\t\tdefault :", "+\t\t\treturn TYPE_DECL; // cannot do better given encoding", "+\t}", "+", "+\tchar[] typeName = this.isCaseSensitive ? simpleName : null;", "+\tif (typeName != null && this.matchMode == PATTERN_MATCH) {", "+\t\tint starPos = CharOperation.indexOf('*', typeName);", "+\t\tswitch(starPos) {", "+\t\t\tcase -1 :", "+\t\t\t\tbreak;", "+\t\t\tcase 0 :", "+\t\t\t\ttypeName = null;", "+\t\t\t\tbreak;", "+\t\t\tdefault : ", "+\t\t\t\ttypeName = CharOperation.subarray(typeName, 0, starPos);", "+\t\t}", "+\t}", "+", "+\tint packageLength = packageName.length;", "+\tint typeLength = typeName == null ? 0 : typeName.length;", "+\tint pos = TYPE_DECL_LENGTH;", "+\tchar[] result = new char[pos + packageLength + typeLength + 3];", "+\tSystem.arraycopy(TYPE_DECL, 0, result, 0, pos);", "+\tresult[pos++] = classOrInterface;", "+\tresult[pos++] = SEPARATOR;", "+\tSystem.arraycopy(packageName, 0, result, pos, packageLength);", "+\tpos += packageLength;", "+\tresult[pos++] = SEPARATOR;", "+\tif (typeLength > 0)", "+\t\tSystem.arraycopy(typeName, 0, result, pos, typeName.length);", "+\treturn result;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82c96e19d63567da3785fa69aa2c5c76", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "b9495a9cef3d68a9dfd6b29b27e2e36ed75f4620", "commitAfterChange": "6897b6240cf6b9585a3dd2a75157f0669f6dd5c1", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected boolean parseComment(int javadocStart, int javadocEnd)", "signatureAfterChange": " \tprotected boolean parseComment(int javadocStart, int javadocEnd)", "diff": ["-\t\t\t\t\t\t// Start tag parsing only if we are on line beginning or at inline tag beginning", "-\t\t\t\t\t\tif (!this.lineStarted || previousChar == '{') {", "+\t\t\t\t\t\t// Start tag parsing only if we have a java identifier start character and if we are on line beginning or at inline tag beginning", "+\t\t\t\t\t\tif (Character.isJavaIdentifierStart(peekChar()) && (!this.lineStarted || previousChar == '{')) {", "-\t\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "-\t\t\t\t\t\t\t\tthis.tagSourceStart = this.kind == COMPIL_PARSER ? this.scanner.getCurrentTokenStartPosition() : previousPosition;", "+\t\t\t\t\t\t\t\tint token = readTokenAndConsume();", "+\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\t\t\tswitch (tk) {", "+\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource(); // first token is either an identifier or a keyword", "+\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) {", "+\t\t\t\t\t\t\t\t\t// For DOM parser, try to get tag name other than java identifier", "+\t\t\t\t\t\t\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51660)", "+\t\t\t\t\t\t\t\t\tint tk = token;", "+\t\t\t\t\t\t\t\t\tint le = this.lineEnd;", "+\t\t\t\t\t\t\t\t\tchar pc = peekChar();", "+\t\t\t\t\t\t\t\t\ttagNameToken: while (tk != TerminalTokens.TokenNameERROR && tk != TerminalTokens.TokenNameEOF) {", "+\t\t\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\t\t\t\ttoken = tk;", "+\t\t\t\t\t\t\t\t\t\t// !, \", #, %, &, ', -, :, <, >", "+\t\t\t\t\t\t\t\t\t\tif (Character.isWhitespace(pc)) break;", "+\t\t\t\t\t\t\t\t\t\tswitch (pc) {", "+\t\t\t\t\t\t\t\t\t\t\tcase '}':", "+\t\t\t\t\t\t\t\t\t\t\tcase '!':", "+\t\t\t\t\t\t\t\t\t\t\tcase '#':", "+\t\t\t\t\t\t\t\t\t\t\tcase '%':", "+\t\t\t\t\t\t\t\t\t\t\tcase '&':", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\'':", "+\t\t\t\t\t\t\t\t\t\t\tcase '-':", "+\t\t\t\t\t\t\t\t\t\t\tcase '<' :", "+\t\t\t\t\t\t\t\t\t\t\tcase '>':", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak tagNameToken;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\ttk = readTokenAndConsume();", "+\t\t\t\t\t\t\t\t\t\tpc = peekChar();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tint length = this.tagSourceEnd-this.tagSourceStart+1;", "+\t\t\t\t\t\t\t\t\ttag = new char[length];", "+\t\t\t\t\t\t\t\t\tSystem.arraycopy(this.source, this.tagSourceStart, tag, 0, length);", "+\t\t\t\t\t\t\t\t\tthis.index = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\t\tthis.scanner.currentPosition = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\t\tthis.tagSourceStart = previousPosition;", "+\t\t\t\t\t\t\t\t\tthis.lineEnd = le;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tswitch (token) {", "-\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\t\t\t\t\t\t\t\tthis.inherited = true;", "+\t\t\t\t\t\t\t\t\t\t\t// inhibits inherited flag when tags have been already stored", "+\t\t\t\t\t\t\t\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51606", "+\t\t\t\t\t\t\t\t\t\t\t// Note that for DOM_PARSER, nodes stack may be not empty even no '@' tag", "+\t\t\t\t\t\t\t\t\t\t\t// was encountered in comment. But it cannot be the case for COMPILER_PARSER", "+\t\t\t\t\t\t\t\t\t\t\t// and so is enough as it is only this parser which signals the missing tag warnings...", "+\t\t\t\t\t\t\t\t\t\t\tthis.inherited = this.astPtr==-1;", "-\t\t\t\t\t\t\t\t\t\t\tswitch (tk) {", "+\t\t\t\t\t\t\t\t\t\t\tswitch (token) {"]}], "num": 58219}