{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3ed7a4820508e809a2cfbdb2f966403b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76ccb4500f7a3a53aab8eea5388568c8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementDelta.java", "commitBeforeChange": "cccafe00dbf29f156949d8f0d0aec370b02aa048", "commitAfterChange": "1a542c460a449efbae14d1057ba233825602248d", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 16, "signatureBeforeChange": " protected JavaElementDelta find(IJavaElement e)", "signatureAfterChange": " protected JavaElementDelta find(IJavaElement e)", "diff": ["-\tif (equalsAndSameParent(this.changedElement, e)) { // handle case of two jars that can be equals but not in the same project", "+\tif (equalsAndSameParent(getElement(), e)) // handle case of two jars that can be equals but not in the same project", "-\t} else {", "-\t\tfor (int i = 0; i < this.affectedChildren.length; i++) {", "-\t\t\tJavaElementDelta delta = ((JavaElementDelta)this.affectedChildren[i]).find(e);", "-\t\t\tif (delta != null) {", "-\t\t\t\treturn delta;", "-\t\t\t}", "-\t\t}", "+\treturn findDescendant(new Key(e));", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bc57dcc2b26ca6aba7877699a64be8ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "11ebb7eac78033ed4b8b7f8bf2dae372f511166c", "commitAfterChange": "ba04cb6ba4b5497c184d335aa777690304f7e67a", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "diff": ["-\tMethodBinding superClassMethod = null;", "-\tboolean playingTrump = false;", "+\tMethodBinding abstractSuperClassMethod = null;", "+\tboolean playingTrump = false; // invariant: playingTrump => (concreteMethod == null)", "-\t\tif (!methods[i].declaringClass.isInterface() && methods[i].declaringClass != this.type) {", "-\t\t\tsuperClassMethod = methods[i];", "+\t\tif (!methods[i].declaringClass.isInterface()", "+\t\t\t\t&& methods[i].declaringClass != this.type", "+\t\t\t\t&& methods[i].isAbstract())", "+\t\t{", "+\t\t\tabstractSuperClassMethod = methods[i];", "-\t\t\t\t\t&& superClassMethod != null\t\t\t\t\t\t\t// condition (a)", "-\t\t\t\t\t&& areParametersEqual(superClassMethod, methods[i]) // condition (b)...", "-\t\t\t\t\t&& (concreteMethod == null || areParametersEqual(superClassMethod, concreteMethod))) {", "-\t\t\t\t// skip, class method trumps this default method", "+\t\t\t\t\t&& abstractSuperClassMethod != null\t\t\t\t\t\t\t// condition (a)", "+\t\t\t\t\t&& areParametersEqual(abstractSuperClassMethod, methods[i]) // condition (b)...", "+\t\t\t\t\t&& concreteMethod == null) {", "+\t\t\t\t// skip, class method trumps this default method (concreteMethod remains null)", "+\t\t\t\tconcreteMethod = methods[i];", "-\t\t\tconcreteMethod = methods[i];", "-\t\tif (concreteMethod != null && concreteMethod.isDefaultMethod()) {", "-\t\t\tif (playingTrump) {", "-\t\t\t\t// multiple abstract & default methods are OK on this branch, but then the class must be declared abstract:", "-\t\t\t\tif (!this.type.isAbstract()) {", "-\t\t\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\t\t\tif (methods[i] == concreteMethod) continue;", "-\t\t\t\t\t\tif (!doesMethodOverride(concreteMethod, methods[i])) {", "-\t\t\t\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, methods[i]);", "-\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} else {", "+\t\tif (playingTrump) {", "+\t\t\t// multiple abstract & default methods are OK on this branch, but then the class must be declared abstract:", "+\t\t\tif (!this.type.isAbstract()) {", "+\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, abstractSuperClassMethod);", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t} else {", "+\t\t\tif (concreteMethod != null && concreteMethod.isDefaultMethod()) {"]}], "num": 6853}