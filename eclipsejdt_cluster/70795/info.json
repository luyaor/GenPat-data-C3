{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ed4078016fdd4228c02e47ad16f7464f", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1e6e17cab8b07046757aff03841603b3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java", "commitBeforeChange": "0bd04abb8575a021cf8905c773ca1d2199f31c53", "commitAfterChange": "1bf6db68524b43c8e140351de0b8d9940aee5925", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tprotected TypeBinding getTypeBinding(Scope scope)", "signatureAfterChange": "  \tprotected TypeBinding getTypeBinding(Scope scope)", "diff": ["+\t\t\t} else if (qualifiedType != null) {", "+\t\t\t\tboolean rawQualified;", "+\t\t\t\tif ((rawQualified = qualifiedType.isRawType()) && !currentType.isStatic()) {", "+\t\t\t\t\tqualifiedType = scope.environment().createRawType((ReferenceBinding)currentType.erasure(), qualifiedType);", "+\t\t\t\t} else if (rawQualified || qualifiedType.isParameterizedType()) {", "+\t\t\t\t\tqualifiedType = scope.createParameterizedType((ReferenceBinding)currentType.erasure(), null, qualifiedType);", "+\t\t\t\t} else {", "+\t\t\t\t\tqualifiedType = currentType;", "+\t\t\t\t}", "-\t\t\t\tqualifiedType = (qualifiedType != null && (qualifiedType.isRawType() || qualifiedType.isParameterizedType()))", "-\t\t\t\t\t\t\t\t\t\t? scope.createParameterizedType((ReferenceBinding)currentType.erasure(), null, qualifiedType)", "-\t\t\t\t\t\t\t\t\t\t: currentType;", "-\t\t\t}", "+\t\t\t\tqualifiedType = currentType;", "+\t\t\t}\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "22419f7aa2280ff8522cbb1cdc442013", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "8c93d4e99b8a943865cb7391e781eba5bb83dfc9", "commitAfterChange": "bd0edd7688142c1743cb6b10766dfc576040f113", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode)", "signatureAfterChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode)", "diff": ["-\t\t// check missing blank final field initializations", "+\t\t// check missing blank final field initializations (plus @NonNull)", "-\t\t\t\tFieldBinding field;", "-\t\t\t\tif ((!(field = fields[i]).isStatic())", "-\t\t\t\t\t&& field.isFinal()", "-\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {", "-\t\t\t\t\tthis.scope.problemReporter().uninitializedBlankFinalField(", "-\t\t\t\t\t\tfield,", "-\t\t\t\t\t\t((this.bits & ASTNode.IsDefaultConstructor) != 0) ? (ASTNode) this.scope.referenceType() : this);", "+\t\t\t\tFieldBinding field = fields[i];", "+\t\t\t\tif (!field.isStatic()) {", "+\t\t\t\t\tif (field.isFinal()", "+\t\t\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(field))) {", "+\t\t\t\t\t\tthis.scope.problemReporter().uninitializedBlankFinalField(", "+\t\t\t\t\t\t\t\tfield,", "+\t\t\t\t\t\t\t\t((this.bits & ASTNode.IsDefaultConstructor) != 0) ? (ASTNode) this.scope.referenceType() : this);", "+\t\t\t\t\t} else if (field.isNonNull()) {", "+\t\t\t\t\t\tif (!flowInfo.isDefinitelyAssigned(field)) {", "+\t\t\t\t\t\t\tthis.scope.problemReporter().uninitializedNonNullField(", "+\t\t\t\t\t\t\t\t\tfield,", "+\t\t\t\t\t\t\t\t\t((this.bits & ASTNode.IsDefaultConstructor) != 0) ? (ASTNode) this.scope.referenceType() : this);\t\t\t\t\t\t", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f45d6dd1a01446b5952ce4502652a2f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "64c79aaade93cc6bf9061f58a0917e55ce5f44d7", "commitAfterChange": "0f30dd165e42ed7c89f5ae15972d54606f639fe9", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic TypeBinding getOtherFieldBindings(BlockScope scope)", "signatureAfterChange": " \tpublic TypeBinding getOtherFieldBindings(BlockScope scope)", "diff": ["-\t\t\tif (!((FieldBinding) binding).isStatic()) {", "+\t\t\tFieldBinding fieldBinding = (FieldBinding) binding;", "+\t\t\tif (!fieldBinding.isStatic()) {", "-\t\t\t\tif (indexOfFirstFieldBinding == 1) {", "-\t\t\t\t\t//the field is the first token of the qualified reference....", "-\t\t\t\t\tif (scope.methodScope().isStatic) {", "-\t\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(", "-\t\t\t\t\t\t\tthis,", "-\t\t\t\t\t\t\t(FieldBinding) binding);", "-\t\t\t\t\t\treturn null;", "-\t\t\t\t\t}", "-\t\t\t\t} else { //accessing to a field using a type as \"receiver\" is allowed only with static field\t", "-\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(", "-\t\t\t\t\t\tthis,", "-\t\t\t\t\t\t(FieldBinding) binding);", "+\t\t\t\tif (indexOfFirstFieldBinding > 1  //accessing to a field using a type as \"receiver\" is allowed only with static field", "+\t\t\t\t\t\t || scope.methodScope().isStatic) { \t// the field is the first token of the qualified reference....", "+\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, fieldBinding);", "+\t\t\t\t }", "+\t\t\t} else {", "+\t\t\t\t// indirect static reference ?", "+\t\t\t\tif (indexOfFirstFieldBinding > 1 ", "+\t\t\t\t\t\t&& fieldBinding.declaringClass != actualReceiverType) {", "+\t\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, fieldBinding);", "-\t\t\tif (isFieldUseDeprecated((FieldBinding) binding, scope, (this.bits & IsStrictlyAssignedMASK) !=0 && indexOfFirstFieldBinding == length))", "-\t\t\t\tscope.problemReporter().deprecatedField((FieldBinding) binding, this);", "+\t\t\tif (isFieldUseDeprecated(fieldBinding, scope, (this.bits & IsStrictlyAssignedMASK) !=0 && indexOfFirstFieldBinding == length))", "+\t\t\t\tscope.problemReporter().deprecatedField(fieldBinding, this);", "-\t\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & IsStrictlyAssignedMASK) !=0 && index+1 == length))", "+\t\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & IsStrictlyAssignedMASK) !=0 && index+1 == length)) {", "+\t\t\t\t}", "-\t\t\t\ttype = field.type;", "-\t\t\t\tindex++;", "-\t\t\t\t", "-\t\t\t\t\tscope.problemReporter().unnecessaryReceiverForStaticField(this, field);", "+\t\t\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, field);", "+\t\t\t\t\t// indirect static reference ?", "+\t\t\t\t\tif (field.declaringClass != type) {", "+\t\t\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, field);", "+\t\t\t\t\t}", "-\t\t\t\t", "+\t\t\t\ttype = field.type;", "+\t\t\t\tindex++;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "74b50eb3a56d3c81ca9ae9d4e8094b48", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "0bd04abb8575a021cf8905c773ca1d2199f31c53", "commitAfterChange": "1bf6db68524b43c8e140351de0b8d9940aee5925", "methodNumberBeforeChange": 55, "methodNumberAfterChange": 55, "signatureBeforeChange": " \tpublic final Binding getTypeOrPackage(char[][] compoundName)", "signatureAfterChange": " \tpublic final Binding getTypeOrPackage(char[][] compoundName)", "diff": ["+\t\t} else if (qualifiedType != null) {", "+\t\t\tboolean rawQualified;", "+\t\t\tif ((rawQualified = qualifiedType.isRawType()) && !typeBinding.isStatic()) {", "+\t\t\t\tqualifiedType = this.environment().createRawType((ReferenceBinding)typeBinding.erasure(), qualifiedType);", "+\t\t\t} else if (rawQualified || qualifiedType.isParameterizedType()) {", "+\t\t\t\tqualifiedType = this.createParameterizedType((ReferenceBinding)typeBinding.erasure(), null, qualifiedType);", "+\t\t\t} else {", "+\t\t\t\tqualifiedType = typeBinding;", "+\t\t\t}", "-\t\t\tqualifiedType = (qualifiedType != null && (qualifiedType.isRawType() || qualifiedType.isParameterizedType()))", "-\t\t\t\t? this.createParameterizedType(typeBinding, null, qualifiedType)", "-\t\t\t\t: typeBinding;", "+\t\t\tqualifiedType = typeBinding;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "945d05f37466256c04784dd03d535a9f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatch.java", "commitBeforeChange": "72643ddaac52d3ea6e2573fbe40b9af5d9586d1e", "commitAfterChange": "965ee55c83771df9f7f21b38b9a78903a86f630d", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic static APTBuildResult runAPTDuringBuild( \t\t\tfinal List<AnnotationProcessorFactory> factories, IFile file, \t\t\tIJavaProject javaProj)", "signatureAfterChange": "  \tpublic static APTResult runAPTDuringBuild( \t\t\tfinal List<AnnotationProcessorFactory> factories, IFile file, \t\t\tIJavaProject javaProj)", "diff": ["-\tpublic static APTBuildResult runAPTDuringBuild(", "+\tpublic static APTResult runAPTDuringBuild(", "-\t\t//  bail-out early if there aren't factories.", "+\t\t//  bail-out early if there aren't factories, or if there aren't any annotation instances", "-\t\tif ( factories == null || factories.size() == 0 )", "-\t\t\treturn EMPTY_BUILD_RESULT;", "-\t\t", "-\t\t//", "-\t\t// scan file for annotation instances, and bail early if none.", "-\t\t// do this before construction ProcessorEnvImpl to avoid ", "-\t\t// unnecessary creation of AST.", "-\t\t//", "-\t\tif ( ! hasAnnotationInstance( file ) )", "-\t\t\treturn EMPTY_BUILD_RESULT;", "+\t\tif ( factories == null || factories.size() == 0  || ! AptUtil.hasAnnotationInstance( file ) )", "+\t\t{", "+\t\t\tif ( DEBUG ) trace( \"runAPTDuringBuild: leaving early because there are no factories or annotation instances\");", "+\t\t\tSet<IFile> deletedFiles = cleanupAllGeneratedFilesForParent( file );", "+\t\t\tif ( deletedFiles.size() == 0 )", "+\t\t\t\treturn EMPTY_APT_RESULT;", "+\t\t\telse", "+\t\t\t\treturn new APTResult( (Set<IFile>)Collections.emptySet(), deletedFiles, (Set<String>)Collections.emptySet() );", "+\t\t}", "-\t\tSet newFiles = runAPT(factories, processorEnv);", "-\t\tSet<String> newDependencies = processorEnv.getTypeDependencies();", "-\t\tAPTBuildResult result = new APTBuildResult( newFiles, newDependencies );", "+\t\tAPTResult result = runAPT(factories, processorEnv);"]}], "num": 70795}