{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dd579fd7fb5ab47f225d9b376f91fa59", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2270dd530487bf21356da3b75e3dcbd1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "1e824a6f76b10e480f47e7bb3a7a70a5562012eb", "commitAfterChange": "fe48a8c1d697b99a27b139ea7b4c9bd7c7eaf9aa", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 16, "signatureBeforeChange": "\r public void storeDependencyInfo()", "signatureAfterChange": "\r public void storeDependencyInfo()", "diff": ["-\r", "-// Old code to be removed\r", "-\tfor (int i = 0; i < typeDependencies.size; i++) { // grows as more types are added\r", "-\t\t// add all the supertypes & associated packages\r", "-\t\tReferenceBinding type = (ReferenceBinding) typeDependencies.elementAt(i);\r", "-\r", "-\t\taddNamespaceReference(type.fPackage); // is this necessary? If so what about a & a.b from a.b.c?\r", "-\t\tif (type.enclosingType() != null)\r", "-\t\t\taddTypeReference(type.enclosingType());\r", "-\t\tif (type.superclass() != null)\r", "-\t\t\taddTypeReference(type.superclass());\r", "-\t\tReferenceBinding[] interfaces = type.superInterfaces();\r", "-\t\tfor (int j = 0, length = interfaces.length; j < length; j++)\r", "-\t\t\taddTypeReference(interfaces[j]);\r", "-\t}\r", "-\r", "-\tint length = namespaceDependencies.size;\r", "-\tchar[][] namespaceNames = new char[length][];\r", "-\tfor (int i = 0; i < length; i++)\r", "-\t\tnamespaceNames[i] = ((PackageBinding) namespaceDependencies.elementAt(i)).readableName();\r", "-\treferenceContext.compilationResult.namespaceDependencies = namespaceNames;\r", "-\r", "-\tlength = typeDependencies.size;\r", "-\tint toplevelTypeCount = 0;\r", "-\tfor (int i = 0; i < length; i++)\r", "-\t\tif (!((ReferenceBinding) typeDependencies.elementAt(i)).isNestedType())\r", "-\t\t\ttoplevelTypeCount++;\r", "-\tchar[][] fileNames = new char[toplevelTypeCount][];\r", "-\tfor (int i = 0; i < length; i++)\r", "-\t\tif (!((ReferenceBinding) typeDependencies.elementAt(i)).isNestedType())\r", "-\t\t\tfileNames[--toplevelTypeCount] = ((ReferenceBinding) typeDependencies.elementAt(i)).getFileName();\r", "-\r", "-\t// eliminate duplicates\r", "-\tint unique = 0;\r", "-\tchar[] ownFileName = referenceContext.getFileName();\r", "-\tnext : for (int i = 0, l = fileNames.length; i < l; i++) {\r", "-\t\tchar[] fileName = fileNames[i];\r", "-\t\tif (CharOperation.equals(fileName, ownFileName)) {\r", "-\t\t\tfileNames[i] = null;\r", "-\t\t\tcontinue next;\r", "-\t\t}\r", "-\t\tfor (int j = i + 1; j < l; j++) {\r", "-\t\t\tif (CharOperation.equals(fileName, fileNames[j])) {\r", "-\t\t\t\tfileNames[i] = null;\r", "-\t\t\t\tcontinue next;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\tunique++;\r", "-\t}\r", "-\tif (unique < fileNames.length) {\r", "-\t\tchar[][] uniqueFileNames = new char[unique][];\r", "-\t\tfor (int i = fileNames.length; --i >= 0;)\r", "-\t\t\tif (fileNames[i] != null)\r", "-\t\t\t\tuniqueFileNames[--unique] = fileNames[i];\r", "-\t\tfileNames = uniqueFileNames;\r", "-\t}\r", "-\treferenceContext.compilationResult.fileDependencies = fileNames;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b11efa9f97b4b47907465742b59a1215", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java", "commitBeforeChange": "a0e794820a3e45ac013c44e55b82e935802d5378", "commitAfterChange": "a06fd70a66cd192fe200df3baf9406d9e87b6313", "methodNumberBeforeChange": 68, "methodNumberAfterChange": 68, "signatureBeforeChange": " \tpublic MethodBinding getSingleAbstractMethod(final Scope scope, boolean replaceWildcards)", "signatureAfterChange": " \tpublic MethodBinding getSingleAbstractMethod(final Scope scope, boolean replaceWildcards)", "diff": ["-\t\tMethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope, true);", "+\t\tMethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope, replaceWildcards);", "-\t\tTypeBinding [] typeArguments = this.arguments; // A1 ... An", "-\t\tif (typeArguments == null)", "-\t\t\ttypeArguments = Binding.NO_TYPES;", "-\t\tTypeVariableBinding [] typeParameters = genericType.typeVariables(); // P1 ... Pn", "-\t\tTypeBinding [] types = new TypeBinding[typeArguments.length];  // T1 ... Tn", "-\t\tfor (int i = 0, length = typeArguments.length; i < length; i++) {", "-\t\t\tTypeBinding typeArgument = typeArguments[i];", "-\t\t\tif (replaceWildcards && typeArgument.kind() == Binding.WILDCARD_TYPE) {", "-\t\t\t\tif (typeParameters[i].mentionsAny(typeParameters, i))", "-\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);", "-\t\t\t\tWildcardBinding wildcard = (WildcardBinding) typeArgument;", "-\t\t\t\tswitch(wildcard.boundKind) {", "-    \t\t\t\tcase Wildcard.EXTENDS :", "-    \t\t\t\t\t// If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi).", "-    \t\t\t\t\t// Note: neither Ui nor Bi is necessarily scalar -> need to collect all bounds", "-    \t\t\t\t\tTypeBinding[] otherUBounds = wildcard.otherBounds;", "-    \t\t\t\t\tTypeBinding[] otherBBounds = typeParameters[i].otherUpperBounds();", "-    \t\t\t\t\tint len = 1 + (otherUBounds != null ? otherUBounds.length : 0) + otherBBounds.length;", "-    \t\t\t\t\tif (typeParameters[i].firstBound != null)", "-    \t\t\t\t\t\tlen++;", "-    \t\t\t\t\tReferenceBinding[] allBounds = new ReferenceBinding[len];", "-    \t\t\t\t\ttry {", "-    \t\t\t\t\t\tint idx = 0;", "-    \t\t\t\t\t\t// Ui", "-\t    \t\t\t\t\tallBounds[idx++] = (ReferenceBinding) wildcard.bound;", "-\t    \t\t\t\t\tif (otherUBounds != null)", "-\t    \t\t\t\t\t\tfor (int j = 0; j < otherUBounds.length; j++)", "-\t    \t\t\t\t\t\t\tallBounds[idx++] = (ReferenceBinding) otherUBounds[j];", "-\t    \t\t\t\t\t// Bi", "-\t    \t\t\t\t\tif (typeParameters[i].firstBound != null)", "-\t    \t\t\t\t\t\tallBounds[idx++] = (ReferenceBinding) typeParameters[i].firstBound;", "-\t    \t\t\t\t\tfor (int j = 0; j < otherBBounds.length; j++)", "-\t    \t\t\t\t\t\tallBounds[idx++] = (ReferenceBinding) otherBBounds[j];", "-    \t\t\t\t\t} catch (ClassCastException cce) {", "-    \t\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);\t\t    \t\t\t\t\t\t", "-    \t\t\t\t\t}", "-    \t\t\t\t\tReferenceBinding[] glb = Scope.greaterLowerBound(allBounds);", "-    \t\t\t\t\tif (glb == null || glb.length == 0) {", "-\t\t\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);", "-\t\t\t\t\t\t} else if (glb.length == 1) {", "-\t\t\t\t\t\t\ttypes[i] = glb[0];", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\ttypes[i] = new IntersectionCastTypeBinding(glb, this.environment);", "-\t\t\t\t\t\t}", "-    \t\t\t\t\tbreak;", "-    \t\t\t\tcase Wildcard.SUPER :", "-    \t\t\t\t\t// If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.", "-    \t\t\t\t\ttypes[i] = wildcard.bound;", "-    \t\t\t\t\tbreak;", "-    \t\t\t\tcase Wildcard.UNBOUND :", "-    \t\t\t\t\t// If Ai is an unbound wildcard ?, then Ti = Bi.", "-    \t\t\t\t\ttypes[i] = typeParameters[i].firstBound;", "-    \t\t\t\t\tif (types[i] == null)", "-    \t\t\t\t\t\ttypes[i] = typeParameters[i].superclass; // assumably j.l.Object?", "-    \t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t// If Ai is a type, then Ti = Ai.", "-\t\t\t\ttypes[i] = typeArgument;", "-\t\t\t}", "+\t\tParameterizedTypeBinding declaringType = null;", "+\t\tTypeBinding [] types = this.arguments; ", "+\t\tif (replaceWildcards) {", "+\t\t\ttypes = getNonWildcardParameterization();", "+\t\t\tif (types == null)", "+\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);", "+\t\t} else if (types == null) {", "+\t\t\ttypes = NO_TYPES;", "-\t\tParameterizedTypeBinding declaringType = scope.environment().createParameterizedType(genericType, types, genericType.enclosingType());", "+\t\tdeclaringType = scope.environment().createParameterizedType(genericType, types, genericType.enclosingType());", "+\t\tTypeVariableBinding [] typeParameters = genericType.typeVariables();"]}], "num": 60948}