{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0415f044ff5e03b572826242611e237d", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5dcb9e2d5dad7f75420faf00fe49b125", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "a289b2bef35844f69838cba7e382e98900bb75bf", "commitAfterChange": "81190a8f2edcd73602d2c6f116017af0ad27c7cf", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "diff": ["+\t\t\t", "+\t\t\t/*", "+\t\t\t * if 1.4 compliant, must filter out redundant protected methods from superclasses", "+\t\t\t */", "+\t\t\tif (compilationUnitScope().environment.options.complianceLevel >= CompilerOptions.JDK1_4){\t\t\t ", "+\t\t\t\tnextMethod: for (int i = 0; i < currentLength; i++){", "+\t\t\t\t\tMethodBinding currentMethod = currentMethods[i];", "+\t\t\t\t\t// protected method need to be checked only - default access is already dealt with in #canBeSeen implementation", "+\t\t\t\t\t// when checking that p.C -> q.B -> p.A cannot see default access members from A through B.", "+\t\t\t\t\tif ((currentMethod.modifiers & AccProtected) == 0) continue nextMethod;", "+\t\t\t\t\tif (matchingMethod != null){", "+\t\t\t\t\t\tif (currentMethod.areParametersEqual(matchingMethod)){", "+\t\t\t\t\t\t\tcurrentLength--;", "+\t\t\t\t\t\t\tcurrentMethods[i] = null; // discard this match", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfor (int j = 0, max = found.size; j < max; j++) {", "+\t\t\t\t\t\t\tif (((MethodBinding)found.elementAt(j)).areParametersEqual(currentMethod)){", "+\t\t\t\t\t\t\t\tcurrentLength--;", "+\t\t\t\t\t\t\t\tcurrentMethods[i] = null;", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "-\t\t\t\tfound.addAll(currentMethods);", "+\t\t\t\t// append currentMethods, filtering out null entries", "+\t\t\t\tint maxMethod = currentMethods.length;", "+\t\t\t\tif (maxMethod == currentLength) { // no method was eliminated for 1.4 compliance (see above)", "+\t\t\t\t\tfound.addAll(currentMethods);", "+\t\t\t\t} else {", "+\t\t\t\t\tfor (int i = 0, max = currentMethods.length; i < max; i++) {", "+\t\t\t\t\t\tMethodBinding currentMethod = currentMethods[i];", "+\t\t\t\t\t\tif (currentMethod != null) found.add(currentMethod);", "+\t\t\t\t\t}", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d5535827acd636764b4824d25d6e0e35", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5a10f519c81ebdddb6bd4a37e304977f9bce5290", "commitAfterChange": "7b4e4fcfdd4d04f13dc930d8b751701d20daa4d2", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\t\t\t\t} else if (method.isStatic()) {", "+\t\t\t\t\t\t// detect collision between static import methods", "+\t\t\t\t\t\tif (method.declaringClass != method2.declaringClass && method.original().areParametersEqual(method2.original()))", "+\t\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t\t\t// its possible with 2 abstract methods that one does not inherit from the other", "+\t\t\t\t\t\t\t// its possible with 2 methods that one does not inherit from the other", "+\t\t\t\t\t\t\t// see cases in verify test #43", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "-\t\t\t\t\t\t\t\t\t\toriginal = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tif (superType != null) {", "+\t\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original.selector);", "+\t\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "+\t\t\t\t\t\t\t\t\t\t\toriginal = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original2.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "-\t\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tif (superType != null) {", "+\t\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original2.selector);", "+\t\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "+\t\t\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}"]}], "num": 12414}