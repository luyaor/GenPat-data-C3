{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a2f279431acd85eb4e80027d114ab63f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82c96e19d63567da3785fa69aa2c5c76", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "b9495a9cef3d68a9dfd6b29b27e2e36ed75f4620", "commitAfterChange": "6897b6240cf6b9585a3dd2a75157f0669f6dd5c1", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected boolean parseComment(int javadocStart, int javadocEnd)", "signatureAfterChange": " \tprotected boolean parseComment(int javadocStart, int javadocEnd)", "diff": ["-\t\t\t\t\t\t// Start tag parsing only if we are on line beginning or at inline tag beginning", "-\t\t\t\t\t\tif (!this.lineStarted || previousChar == '{') {", "+\t\t\t\t\t\t// Start tag parsing only if we have a java identifier start character and if we are on line beginning or at inline tag beginning", "+\t\t\t\t\t\tif (Character.isJavaIdentifierStart(peekChar()) && (!this.lineStarted || previousChar == '{')) {", "-\t\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "-\t\t\t\t\t\t\t\tthis.tagSourceStart = this.kind == COMPIL_PARSER ? this.scanner.getCurrentTokenStartPosition() : previousPosition;", "+\t\t\t\t\t\t\t\tint token = readTokenAndConsume();", "+\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\t\t\tswitch (tk) {", "+\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource(); // first token is either an identifier or a keyword", "+\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) {", "+\t\t\t\t\t\t\t\t\t// For DOM parser, try to get tag name other than java identifier", "+\t\t\t\t\t\t\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51660)", "+\t\t\t\t\t\t\t\t\tint tk = token;", "+\t\t\t\t\t\t\t\t\tint le = this.lineEnd;", "+\t\t\t\t\t\t\t\t\tchar pc = peekChar();", "+\t\t\t\t\t\t\t\t\ttagNameToken: while (tk != TerminalTokens.TokenNameERROR && tk != TerminalTokens.TokenNameEOF) {", "+\t\t\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\t\t\t\ttoken = tk;", "+\t\t\t\t\t\t\t\t\t\t// !, \", #, %, &, ', -, :, <, >", "+\t\t\t\t\t\t\t\t\t\tif (Character.isWhitespace(pc)) break;", "+\t\t\t\t\t\t\t\t\t\tswitch (pc) {", "+\t\t\t\t\t\t\t\t\t\t\tcase '}':", "+\t\t\t\t\t\t\t\t\t\t\tcase '!':", "+\t\t\t\t\t\t\t\t\t\t\tcase '#':", "+\t\t\t\t\t\t\t\t\t\t\tcase '%':", "+\t\t\t\t\t\t\t\t\t\t\tcase '&':", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\'':", "+\t\t\t\t\t\t\t\t\t\t\tcase '-':", "+\t\t\t\t\t\t\t\t\t\t\tcase '<' :", "+\t\t\t\t\t\t\t\t\t\t\tcase '>':", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak tagNameToken;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\ttk = readTokenAndConsume();", "+\t\t\t\t\t\t\t\t\t\tpc = peekChar();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tint length = this.tagSourceEnd-this.tagSourceStart+1;", "+\t\t\t\t\t\t\t\t\ttag = new char[length];", "+\t\t\t\t\t\t\t\t\tSystem.arraycopy(this.source, this.tagSourceStart, tag, 0, length);", "+\t\t\t\t\t\t\t\t\tthis.index = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\t\tthis.scanner.currentPosition = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\t\tthis.tagSourceStart = previousPosition;", "+\t\t\t\t\t\t\t\t\tthis.lineEnd = le;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tswitch (token) {", "-\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\t\t\t\t\t\t\t\tthis.inherited = true;", "+\t\t\t\t\t\t\t\t\t\t\t// inhibits inherited flag when tags have been already stored", "+\t\t\t\t\t\t\t\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51606", "+\t\t\t\t\t\t\t\t\t\t\t// Note that for DOM_PARSER, nodes stack may be not empty even no '@' tag", "+\t\t\t\t\t\t\t\t\t\t\t// was encountered in comment. But it cannot be the case for COMPILER_PARSER", "+\t\t\t\t\t\t\t\t\t\t\t// and so is enough as it is only this parser which signals the missing tag warnings...", "+\t\t\t\t\t\t\t\t\t\t\tthis.inherited = this.astPtr==-1;", "-\t\t\t\t\t\t\t\t\t\t\tswitch (tk) {", "+\t\t\t\t\t\t\t\t\t\t\tswitch (token) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd60c0c1d73b7c2feb567d32224e4d80", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "330aeaad59d1633d10c0cd3a9ee9ac57073b385f", "commitAfterChange": "960ce528d76bd309a28ce655fc14cff77629ffa5", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "signatureAfterChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "diff": ["-\t */", "-", "-\t\t// In case of previous return tag, set it to not empty if parsing an inline tag", "-\t\tif (this.currentAstPtr != -2 && this.returnStatement != null) {", "-\t\t\tthis.currentAstPtr = -2;", "-\t\t\tJavadocReturnStatement javadocReturn = (JavadocReturnStatement) this.returnStatement;", "-\t\t\tjavadocReturn.empty = javadocReturn.empty && !this.inlineTagStarted;", "-\t\t}", "-", "+\t", "-\t\tchar[] tag = this.scanner.getCurrentIdentifierSource(); // first token is either an identifier or a keyword", "+\t", "+\t\t// Try to get tag name other than java identifier", "+\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51660)", "+\t\tchar pc = peekChar();", "+\t\tboolean validTag = false;", "+\t\tswitch (token) {", "+\t\t\tcase TerminalTokens.TokenNameIdentifier:", "+\t\t\tcase TerminalTokens.TokenNamereturn:", "+\t\t\tcase TerminalTokens.TokenNamethrows:", "+\t\t\t\tvalidTag= true;", "+\t\t}", "+\t\ttagNameToken: while (token != TerminalTokens.TokenNameEOF && this.index < this.scanner.eofPosition) {", "+\t\t\t// !, \", #, %, &, ', -, :, <, >, * chars and spaces are not allowed in tag names", "+\t\t\tswitch (pc) {", "+\t\t\t\tcase '}':", "+\t\t\t\tcase '*': // break for '*' as this is perhaps the end of comment (bug 65288)", "+\t\t\t\t\tbreak tagNameToken;", "+\t\t\t\tcase '!':", "+\t\t\t\tcase '#':", "+\t\t\t\tcase '%':", "+\t\t\t\tcase '&':", "+\t\t\t\tcase '\\'':", "+\t\t\t\tcase '\"':", "+\t\t\t\tcase ':':", "+\t\t\t\t// case '-': allowed in tag names as this character is often used in doclets (bug 68087)", "+\t\t\t\tcase '<':", "+\t\t\t\tcase '>':", "+\t\t\t\t\treadChar();", "+\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\tvalidTag = false;", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tif (pc == ' ' || Character.isWhitespace(pc)) break tagNameToken;", "+\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\ttoken = readTokenAndConsume();", "+\t\t\t}", "+\t\t\tpc = peekChar();", "+\t\t}", "+\t\tif (!validTag) {", "+\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(this.tagSourceStart, this.tagSourceEnd);", "+\t\t\treturn false;", "+\t\t}", "+\t\tint length = this.tagSourceEnd-this.tagSourceStart+1;", "+\t\tchar[] tag = new char[length];", "+\t\tSystem.arraycopy(this.source, this.tagSourceStart, tag, 0, length);", "+\t\tthis.index = this.tagSourceEnd+1;", "+\t\tthis.scanner.currentPosition = this.tagSourceEnd+1;"]}], "num": 41412}