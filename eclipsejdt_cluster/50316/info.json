{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7de54d2f3f6797d90aeae883a7a2b69c", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5daaaf8d9e2269ae48c45bbb01a614af", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "00b719c0d7c4b5271c818d210d84b349bc0324e3", "commitAfterChange": "f90ca993824b1d0e38aec24edba147ca4e8ec0d1", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\tpublic TypeBinding resolveType(BlockScope scope) {", "-", "-\t\t// Propagate the type checking to the arguments, and check if the constructor is defined.", "-\t\tconstant = NotAConstant;", "-\t\tthis.resolvedType = type.resolveType(scope);", "-\t\t// will check for null after args are resolved", "-", "-\t\t// buffering the arguments' types", "-\t\tTypeBinding[] argumentTypes = NoParameters;", "-\t\tif (arguments != null) {", "-\t\t\tboolean argHasError = false;", "-\t\t\tint length = arguments.length;", "-\t\t\targumentTypes = new TypeBinding[length];", "-\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)", "-\t\t\t\t\targHasError = true;", "-\t\t\tif (argHasError)", "-\t\t\t\treturn this.resolvedType;", "-\t\t}", "-\t\tif (this.resolvedType == null)", "-\t\t\treturn null;", "-", "-\t\tif (!this.resolvedType.canBeInstantiated()) {", "-\t\t\tscope.problemReporter().cannotInstantiate(type, this.resolvedType);", "-\t\t\treturn this.resolvedType;", "-\t\t}", "-\t\tReferenceBinding allocatedType = (ReferenceBinding) this.resolvedType;", "-\t\tif (!(binding = scope.getConstructor(allocatedType, argumentTypes, this))", "-\t\t\t.isValidBinding()) {", "-\t\t\tif (binding.declaringClass == null)", "-\t\t\t\tbinding.declaringClass = allocatedType;", "-\t\t\tscope.problemReporter().invalidConstructor(this, binding);", "-\t\t\treturn this.resolvedType;", "-\t\t}", "-\t\tif (isMethodUseDeprecated(binding, scope))", "-\t\t\tscope.problemReporter().deprecatedMethod(binding, this);", "-", "-\t\tif (arguments != null)", "-\t\t\tfor (int i = 0; i < arguments.length; i++)", "-\t\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);", "-\t\treturn allocatedType;", "-\t}", "+\t", "+\tpublic TypeBinding resolveType(BlockScope scope) {", "+", "+\t\t// Propagate the type checking to the arguments, and check if the constructor is defined.", "+\t\tconstant = NotAConstant;", "+\t\tthis.resolvedType = type.resolveType(scope);", "+\t\t// will check for null after args are resolved", "+", "+\t\t// buffering the arguments' types", "+\t\tboolean argsContainCast = false;", "+\t\tTypeBinding[] argumentTypes = NoParameters;", "+\t\tif (arguments != null) {", "+\t\t\tboolean argHasError = false;", "+\t\t\tint length = arguments.length;", "+\t\t\targumentTypes = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\t\targsContainCast = true;", "+\t\t\t\t}", "+\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null) {", "+\t\t\t\t\targHasError = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (argHasError) {", "+\t\t\t\treturn this.resolvedType;", "+\t\t\t}", "+\t\t}", "+\t\tif (this.resolvedType == null)", "+\t\t\treturn null;", "+", "+\t\tif (!this.resolvedType.canBeInstantiated()) {", "+\t\t\tscope.problemReporter().cannotInstantiate(type, this.resolvedType);", "+\t\t\treturn this.resolvedType;", "+\t\t}", "+\t\tReferenceBinding allocationType = (ReferenceBinding) this.resolvedType;", "+\t\tif (!(binding = scope.getConstructor(allocationType, argumentTypes, this))", "+\t\t\t.isValidBinding()) {", "+\t\t\tif (binding.declaringClass == null)", "+\t\t\t\tbinding.declaringClass = allocationType;", "+\t\t\tscope.problemReporter().invalidConstructor(this, binding);", "+\t\t\treturn this.resolvedType;", "+\t\t}", "+\t\tif (isMethodUseDeprecated(binding, scope))", "+\t\t\tscope.problemReporter().deprecatedMethod(binding, this);", "+", "+\t\tif (arguments != null) {", "+\t\t\tfor (int i = 0; i < arguments.length; i++) {", "+\t\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);", "+\t\t\t}", "+\t\t\tif (argsContainCast) {", "+\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, allocationType, binding, this.arguments, argumentTypes, this);", "+\t\t\t}", "+\t\t}", "+\t\treturn allocationType;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0dfed25fe92dd268f7355a27906f79f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "673b7eda95cd26449992e862f0c63f2c612903a0", "commitAfterChange": "b04602938404af4f8569a399fb36a5018768a262", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r \r \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "\r public TypeBinding resolveType(BlockScope scope)", "diff": ["+}\r", "+public TypeBinding resolveType(BlockScope scope) {\r", "+\t// Propagate the type checking to the arguments, and check if the constructor is defined.\r", "+\tconstant = NotAConstant;\r", "+\tTypeBinding typeBinding = type.resolveType(scope); // will check for null after args are resolved\r", "-\tpublic TypeBinding resolveType(BlockScope scope) {\r", "-\t\t// Propagate the type checking to the arguments, and check if the constructor is defined.\r", "-\t\tconstant = NotAConstant;\r", "-\t\tTypeBinding typeBinding = type.resolveType(scope);\r", "-\t\t// will check for null after args are resolved\r", "+\t// buffering the arguments' types\r", "+\tTypeBinding[] argumentTypes = NoParameters;\r", "+\tif (arguments != null) {\r", "+\t\tboolean argHasError = false;\r", "+\t\tint length = arguments.length;\r", "+\t\targumentTypes = new TypeBinding[length];\r", "+\t\tfor (int i = 0; i < length; i++)\r", "+\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)\r", "+\t\t\t\targHasError = true;\r", "+\t\tif (argHasError)\r", "+\t\t\treturn typeBinding;\r", "+\t}\r", "+\tif (typeBinding == null)\r", "+\t\treturn null;\r", "-\t\t// buffering the arguments' types\r", "-\t\tTypeBinding[] argumentTypes = NoParameters;\r", "+\tif (!typeBinding.canBeInstantiated()) {\r", "+\t\tscope.problemReporter().cannotInstantiate(type, typeBinding);\r", "+\t\treturn typeBinding;\r", "+\t}\r", "+\tReferenceBinding allocatedType = (ReferenceBinding) typeBinding;\r", "+\tif (!(binding = scope.getConstructor(allocatedType, argumentTypes, this)).isValidBinding()) {\r", "+\t\tif (binding.declaringClass == null)\r", "+\t\t\tbinding.declaringClass = allocatedType;\r", "+\t\tscope.problemReporter().invalidConstructor(this, binding);\r", "+\t\treturn typeBinding;\r", "+\t}\r", "+\tif (isMethodUseDeprecated(binding, scope))\r", "+\t\tscope.problemReporter().deprecatedMethod(binding, this);\r", "+\r", "+\tif (arguments != null)\r", "+\t\tfor (int i = 0; i < arguments.length; i++)\r", "+\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);\r", "+\treturn allocatedType;\r", "+}\r", "-\t\t\tboolean argHasError = false;\r", "-\t\t\tint length = arguments.length;\r", "-\t\t\targumentTypes = new TypeBinding[length];\r", "-\t\t\tfor (int i = 0; i < length; i++)\r", "-\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)\r", "-\t\t\t\t\targHasError = true;\r", "-\t\t\tif (argHasError)\r", "-\t\t\t\treturn null;\r", "-\t\tif (typeBinding == null)\r", "-\t\t\treturn null;\r", "-\r", "-\t\tif (!typeBinding.canBeInstantiated()) {\r", "-\t\t\tscope.problemReporter().cannotInstantiate(type, typeBinding);\r", "-\t\t\treturn null;\r", "-\t\t}\r", "-\t\tReferenceBinding allocatedType = (ReferenceBinding) typeBinding;\r", "-\t\tif (!(binding = scope.getConstructor(allocatedType, argumentTypes, this))\r", "-\t\t\t.isValidBinding()) {\r", "-\t\t\tif (binding.declaringClass == null)\r", "-\t\t\t\tbinding.declaringClass = allocatedType;\r", "-\t\t\tscope.problemReporter().invalidConstructor(this, binding);\r", "-\t\t\treturn null;\r", "-\t\t}\r", "-\t\tif (isMethodUseDeprecated(binding, scope))\r", "-\t\t\tscope.problemReporter().deprecatedMethod(binding, this);\r", "-\r", "-\t\tif (arguments != null)\r", "-\t\t\tfor (int i = 0; i < arguments.length; i++)\r", "-\t\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);\r", "-\t\treturn allocatedType;\r"]}], "num": 50316}