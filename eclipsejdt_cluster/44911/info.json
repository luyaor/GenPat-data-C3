{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ce289185da99b0b827de26bc176a6309", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "266a2bf17ef95de5cb9fc311dc62ac16", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "e6099120ee9021152f84e60105066d4964c2db21", "commitAfterChange": "82631a98caad8b28e9cefb217339d51e64ef47f9", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \tpublic void locateMatches(\r \t\tString[] filePaths, \r \t\tIWorkspace workspace,\r \t\tIWorkingCopy[] workingCopies, \r \t\tIProgressMonitor progressMonitor)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r \tpublic void locateMatches(\r \t\tString[] filePaths, \r \t\tIWorkspace workspace,\r \t\tIWorkingCopy[] workingCopies, \r \t\tIProgressMonitor progressMonitor)\r \t\tthrows JavaModelException", "diff": ["-\t\t// initialize handle factory (used as a cache of handles so as to optimize space)\r", "-\t\tif (this.handleFactory == null) {\r", "-\t\t\tthis.handleFactory = new HandleFactory(workspace);\r", "-\t\t}\r", "-\t\t\r", "-\t\t// initialize locator with working copies\r", "-\t\tthis.workingCopies = workingCopies;\r", "-\t\t\r", "-\t\t// substitute compilation units with working copies\r", "-\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies\r", "-\t\tint wcLength;\r", "-\t\tif (workingCopies != null && (wcLength = workingCopies.length) > 0) {\r", "-\t\t\tString[] newPaths = new String[wcLength];\r", "-\t\t\tfor (int i = 0; i < wcLength; i++) {\r", "-\t\t\t\tIWorkingCopy workingCopy = workingCopies[i];\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tIResource res = workingCopy.getOriginalElement().getUnderlyingResource();\r", "-\t\t\t\t\tString path = res.getFullPath().toString();\r", "-\t\t\t\t\twcPaths.put(path, workingCopy);\r", "-\t\t\t\t\tnewPaths[i] = path;\r", "-\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t\t// continue with next working copy\r", "-\t\t\t\t}\r", "+\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\t\ttry {\r", "+\t\t\t// optimize access to zip files during search operation\r", "+\t\t\tmanager.cacheZipFiles();\r", "+\t\t\t\t\r", "+\t\t\t// initialize handle factory (used as a cache of handles so as to optimize space)\r", "+\t\t\tif (this.handleFactory == null) {\r", "+\t\t\t\tthis.handleFactory = new HandleFactory(workspace);\r", "-\t\t\tint filePathsLength = filePaths.length;\r", "-\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);\r", "-\t\t\tSystem.arraycopy(newPaths, 0, filePaths, filePathsLength, wcLength);\r", "-\t\t}\r", "-\t\t\r", "-\t\tint length = filePaths.length;\r", "-\t\tif (progressMonitor != null) {\r", "-\t\t\tprogressMonitor.beginTask(\"\", length * 3); // 1 for file path, 1 for binding creation, 1 for resolution //$NON-NLS-1$\r", "-\t\t}\r", "-\r", "-\t\t// sort file paths projects\r", "-\t\tUtil.sort(filePaths); \r", "-\t\t\r", "-\t\t// initialize pattern for polymorphic search (ie. method reference pattern)\r", "-\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "-\t\tthis.pattern.initializePolymorphicSearch(this, progressMonitor);\r", "-\t\t\r", "-\t\tJavaProject previousJavaProject = null;\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {\r", "-\t\t\t\tthrow new OperationCanceledException();\r", "-\t\t\t}\r", "-\t\t\tString pathString = filePaths[i];\r", "-\t\t\t// skip duplicate paths\r", "-\t\t\tif (i > 0 && pathString.equals(filePaths[i-1])) continue;\r", "+\t\t\t// initialize locator with working copies\r", "+\t\t\tthis.workingCopies = workingCopies;\r", "-\t\t\tOpenable openable;\r", "-\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(pathString);\r", "-\t\t\tif (workingCopy != null) {\r", "-\t\t\t\topenable = (Openable)workingCopy;\r", "-\t\t\t} else {\r", "-\t\t\t\topenable = this.handleFactory.createOpenable(pathString);\r", "-\t\t\t\tif (openable == null)\r", "-\t\t\t\t\tcontinue; // match is outside classpath\r", "-\t\t\t}\r", "-\r", "-\t\t\t// create new parser and lookup environment if this is a new project\r", "-\t\t\tIResource resource = null;\r", "-\t\t\tJavaProject javaProject = null;\r", "-\t\t\ttry {\r", "-\t\t\t\tjavaProject = (JavaProject) openable.getJavaProject();\r", "-\t\t\t\tif (workingCopy != null) {\r", "-\t\t\t\t\tresource = workingCopy.getOriginalElement().getUnderlyingResource();\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tresource = openable.getUnderlyingResource();\r", "-\t\t\t\t}\r", "-\t\t\t\tif (resource == null) { // case of a file in an external jar\r", "-\t\t\t\t\tresource = javaProject.getProject();\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "-\t\t\t\t\t// locate matches in previous project\r", "-\t\t\t\t\tif (previousJavaProject != null) {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "-\t\t\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) {\r", "-\t\t\t\t\t\t\t\tthrow e;\r", "-\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t// problem with classpath in this project -> skip it\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\t// substitute compilation units with working copies\r", "+\t\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies\r", "+\t\t\tint wcLength;\r", "+\t\t\tif (workingCopies != null && (wcLength = workingCopies.length) > 0) {\r", "+\t\t\t\tString[] newPaths = new String[wcLength];\r", "+\t\t\t\tfor (int i = 0; i < wcLength; i++) {\r", "+\t\t\t\t\tIWorkingCopy workingCopy = workingCopies[i];\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tIResource res = workingCopy.getOriginalElement().getUnderlyingResource();\r", "+\t\t\t\t\t\tString path = res.getFullPath().toString();\r", "+\t\t\t\t\t\twcPaths.put(path, workingCopy);\r", "+\t\t\t\t\t\tnewPaths[i] = path;\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t\t// continue with next working copy\r", "-\r", "-\t\t\t\t\t// create parser for this project\r", "-\t\t\t\t\tthis.createParser(javaProject);\r", "-\t\t\t\t\tpreviousJavaProject = javaProject;\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t// file doesn't exist -> skip it\r", "-\t\t\t\tcontinue;\r", "+\t\t\t\tint filePathsLength = filePaths.length;\r", "+\t\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);\r", "+\t\t\t\tSystem.arraycopy(newPaths, 0, filePaths, filePathsLength, wcLength);\r", "-\r", "-\t\t\t// add matching openable\r", "-\t\t\tthis.addMatchingOpenable(resource, openable);\r", "-\r", "+\t\t\t\r", "+\t\t\tint length = filePaths.length;\r", "-\t\t\t\tprogressMonitor.worked(1);\r", "+\t\t\t\tprogressMonitor.beginTask(\"\", length * 3); // 1 for file path, 1 for binding creation, 1 for resolution //$NON-NLS-1$\r", "-\t\t}\r", "-\t\t\r", "-\t\t// last project\r", "-\t\tif (previousJavaProject != null) {\r", "-\t\t\ttry {\r", "-\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\tif (e.getException() instanceof CoreException) {\r", "-\t\t\t\t\tthrow e;\r", "+\t\r", "+\t\t\t// sort file paths projects\r", "+\t\t\tUtil.sort(filePaths); \r", "+\t\t\t\r", "+\t\t\t// initialize pattern for polymorphic search (ie. method reference pattern)\r", "+\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\tthis.pattern.initializePolymorphicSearch(this, progressMonitor);\r", "+\t\t\t\r", "+\t\t\tJavaProject previousJavaProject = null;\r", "+\t\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {\r", "+\t\t\t\t\tthrow new OperationCanceledException();\r", "+\t\t\t\t}\r", "+\t\t\t\tString pathString = filePaths[i];\r", "+\t\t\t\t\r", "+\t\t\t\t// skip duplicate paths\r", "+\t\t\t\tif (i > 0 && pathString.equals(filePaths[i-1])) continue;\r", "+\t\t\t\t\r", "+\t\t\t\tOpenable openable;\r", "+\t\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(pathString);\r", "+\t\t\t\tif (workingCopy != null) {\r", "+\t\t\t\t\topenable = (Openable)workingCopy;\r", "-\t\t\t\t\t// problem with classpath in last project -> skip it\r", "+\t\t\t\t\topenable = this.handleFactory.createOpenable(pathString);\r", "+\t\t\t\t\tif (openable == null)\r", "+\t\t\t\t\t\tcontinue; // match is outside classpath\r", "+\t\t\t\t}\r", "+\t\r", "+\t\t\t\t// create new parser and lookup environment if this is a new project\r", "+\t\t\t\tIResource resource = null;\r", "+\t\t\t\tJavaProject javaProject = null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tjavaProject = (JavaProject) openable.getJavaProject();\r", "+\t\t\t\t\tif (workingCopy != null) {\r", "+\t\t\t\t\t\tresource = workingCopy.getOriginalElement().getUnderlyingResource();\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tresource = openable.getUnderlyingResource();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tif (resource == null) { // case of a file in an external jar\r", "+\t\t\t\t\t\tresource = javaProject.getProject();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "+\t\t\t\t\t\t// locate matches in previous project\r", "+\t\t\t\t\t\tif (previousJavaProject != null) {\r", "+\t\t\t\t\t\t\ttry {\r", "+\t\t\t\t\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "+\t\t\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) {\r", "+\t\t\t\t\t\t\t\t\tthrow e;\r", "+\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t// problem with classpath in this project -> skip it\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\t\t\t\t}\r", "+\t\r", "+\t\t\t\t\t\t// create parser for this project\r", "+\t\t\t\t\t\tthis.createParser(javaProject);\r", "+\t\t\t\t\t\tpreviousJavaProject = javaProject;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t// file doesn't exist -> skip it\r", "+\t\t\t\t\tcontinue;\r", "+\t\t\t\t}\r", "+\t\r", "+\t\t\t\t// add matching openable\r", "+\t\t\t\tthis.addMatchingOpenable(resource, openable);\r", "+\t\r", "+\t\t\t\tif (progressMonitor != null) {\r", "+\t\t\t\t\tprogressMonitor.worked(1);\r", "-\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "-\t\t} \r", "-\t\t\r", "-\t\tif (progressMonitor != null) {\r", "-\t\t\tprogressMonitor.done();\r", "-\t\t}\r", "-\r", "+\t\t\t\r", "+\t\t\t// last project\r", "+\t\t\tif (previousJavaProject != null) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\tif (e.getException() instanceof CoreException) {\r", "+\t\t\t\t\t\tthrow e;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t// problem with classpath in last project -> skip it\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\t} \r", "+\t\t\t\r", "+\t\t\tif (progressMonitor != null) {\r", "+\t\t\t\tprogressMonitor.done();\r", "+\t\t\t}\r", "+\t\t} finally {\r", "+\t\t\tif (this.nameEnvironment != null) {\r", "+\t\t\t\tthis.nameEnvironment.cleanup();\r", "+\t\t\t}\r", "+\t\t\tthis.parsedUnits = null;\r", "+\t\t\tmanager.flushZipFiles();\r", "+\t\t}\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60d0c2961023d5bc3a70f18a16091a3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tpublic void locateMatches( \t\tString[] filePaths,  \t\tIWorkspace workspace, \t\torg.eclipse.jdt.core.ICompilationUnit[] copies) \t\tthrows JavaModelException", "signatureAfterChange": " public void locateMatches(String[] filePaths, IWorkspace workspace, org.eclipse.jdt.core.ICompilationUnit[] copies) throws JavaModelException", "diff": ["-\t */", "-\tpublic void locateMatches(", "-\t\tString[] filePaths, ", "-\t\tIWorkspace workspace,", "-\t\torg.eclipse.jdt.core.ICompilationUnit[] copies)", "-\t\tthrows JavaModelException {", "-\t\t\t", "-\t\tif (SearchEngine.VERBOSE) {", "-\t\t\tSystem.out.println(\"Locating matches in files [\"); //$NON-NLS-1$", "-\t\t\tfor (int i = 0, length = filePaths.length; i < length; i++) {", "-\t\t\t\tString path = filePaths[i];", "-\t\t\t\tSystem.out.println(\"\\t\" + path); //$NON-NLS-1$", "-\t\t\t}", "-\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "-\t\t\tif (copies != null) {", "-\t\t\t\t System.out.println(\"and working copies [\"); //$NON-NLS-1$", "-\t\t\t\tfor (int i = 0, length = copies.length; i < length; i++) {", "-\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit wc = copies[i];", "-\t\t\t\t\tSystem.out.println(\"\\t\" + ((JavaElement)wc).toStringWithAncestors()); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "-\t\t\t}", "+ */", "+public void locateMatches(String[] filePaths, IWorkspace workspace, org.eclipse.jdt.core.ICompilationUnit[] copies) throws JavaModelException {", "+\tif (SearchEngine.VERBOSE) {", "+\t\tSystem.out.println(\"Locating matches in files [\"); //$NON-NLS-1$", "+\t\tfor (int i = 0, length = filePaths.length; i < length; i++)", "+\t\t\tSystem.out.println(\"\\t\" + filePaths[i]); //$NON-NLS-1$", "+\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "+\t\tif (copies != null) {", "+\t\t\t System.out.println(\"and working copies [\"); //$NON-NLS-1$", "+\t\t\tfor (int i = 0, length = copies.length; i < length; i++)", "+\t\t\t\tSystem.out.println(\"\\t\" + ((JavaElement) copies[i]).toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "+\t\t}", "+\t}", "+", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\ttry {", "+\t\t// optimize access to zip files during search operation", "+\t\tmanager.cacheZipFiles();", "+\t\t\t", "+\t\t// initialize handle factory (used as a cache of handles so as to optimize space)", "+\t\tif (this.handleFactory == null)", "+\t\t\tthis.handleFactory = new HandleFactory(workspace);", "-\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t\ttry {", "-\t\t\t// optimize access to zip files during search operation", "-\t\t\tmanager.cacheZipFiles();", "-\t\t\t\t", "-\t\t\t// initialize handle factory (used as a cache of handles so as to optimize space)", "-\t\t\tif (this.handleFactory == null) {", "-\t\t\t\tthis.handleFactory = new HandleFactory(workspace);", "-\t\t\t}", "-\t\t\t", "-\t\t\t// initialize locator with working copies", "-\t\t\tthis.workingCopies = copies;", "-\t\t\t", "-\t\t\t// substitute compilation units with working copies", "-\t\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies", "-\t\t\tint wcLength;", "-\t\t\tif (copies != null && (wcLength = copies.length) > 0) {", "+\t\t// substitute compilation units with working copies", "+\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies", "+\t\tif ((this.workingCopies = copies) != null) {", "+\t\t\tint wcLength = this.workingCopies.length;", "+\t\t\tif (wcLength > 0) {", "-\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = copies[i];", "+\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = this.workingCopies[i];", "-\t\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);", "+\t\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength + wcLength], 0, filePathsLength);", "-\t\t\t", "-\t\t\tint length = filePaths.length;", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tif (this.pattern.mustResolve) {", "-\t\t\t\t\tprogressMonitor.beginTask(\"\", length * 10); // 1 for file path, 4 for parsing and binding creation, 5 for binding resolution //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tprogressMonitor.beginTask(\"\", length * 5); // 1 for file path, 4 for parsing and binding creation //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t}", "-\t", "-\t\t\t// sort file paths projects", "-\t\t\tUtil.sort(filePaths); ", "-\t\t\t", "-\t\t\t// initialize pattern for polymorphic search (ie. method reference pattern)", "-\t\t\tthis.matchSet = new PotentialMatchSet();", "-\t\t\tthis.pattern.initializePolymorphicSearch(this, progressMonitor);", "-\t\t\t", "-\t\t\tJavaProject previousJavaProject = null;", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {", "-\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t\t}", "-\t\t\t\tString pathString = filePaths[i];", "-\t\t\t\t", "-\t\t\t\t// skip duplicate paths", "-\t\t\t\tif (i > 0 && pathString.equals(filePaths[i-1])) continue;", "-\t\t\t\t", "-\t\t\t\tOpenable openable;", "-\t\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = (org.eclipse.jdt.core.ICompilationUnit)wcPaths.get(pathString);", "-\t\t\t\tif (workingCopy != null) {", "-\t\t\t\t\topenable = (Openable)workingCopy;", "-\t\t\t\t} else {", "-\t\t\t\t\topenable = this.handleFactory.createOpenable(pathString, this.scope);", "-\t\t\t\t\tif (openable == null)", "-\t\t\t\t\t\tcontinue; // match is outside classpath", "-\t\t\t\t}", "-\t", "-\t\t\t\t// create new parser and lookup environment if this is a new project", "-\t\t\t\tIResource resource = null;", "-\t\t\t\tJavaProject javaProject = null;", "-\t\t\t\ttry {", "-\t\t\t\t\tjavaProject = (JavaProject) openable.getJavaProject();", "-\t\t\t\t\tif (workingCopy != null) {", "-\t\t\t\t\t\tresource = workingCopy.getResource();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tresource = openable.getResource();", "-\t\t\t\t\t}", "-\t\t\t\t\tif (resource == null) { // case of a file in an external jar", "-\t\t\t\t\t\tresource = javaProject.getProject();", "-\t\t\t\t\t}", "-\t\t\t\t\tif (!javaProject.equals(previousJavaProject)) {", "-\t\t\t\t\t\t// locate matches in previous project", "-\t\t\t\t\t\tif (previousJavaProject != null) {", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tthis.locateMatches(previousJavaProject);", "-\t\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) {", "-\t\t\t\t\t\t\t\t\tthrow e;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t// problem with classpath in this project -> skip it", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthis.matchSet = new PotentialMatchSet();", "-\t\t\t\t\t\t}", "-\t", "-\t\t\t\t\t\tpreviousJavaProject = javaProject;", "-\t\t\t\t\t}", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t// file doesn't exist -> skip it", "-\t\t\t\t\tcontinue;", "-\t\t\t\t}", "-\t", "-\t\t\t\t// add potential match", "-\t\t\t\tthis.addPotentialMatch(resource, openable);", "-\t", "-\t\t\t\tif (progressMonitor != null) {", "-\t\t\t\t\tprogressMonitor.worked(1);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// last project", "-\t\t\tif (previousJavaProject != null) {", "-\t\t\t\ttry {", "-\t\t\t\t\tthis.locateMatches(previousJavaProject);", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\tif (e.getException() instanceof CoreException) {", "-\t\t\t\t\t\tthrow e;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// problem with classpath in last project -> skip it", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tthis.matchSet = new PotentialMatchSet();", "-\t\t\t} ", "-\t\t\t", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tprogressMonitor.done();", "-\t\t\t}", "-\t\t} finally {", "-\t\t\tif (this.nameEnvironment != null) {", "-\t\t\t\tthis.nameEnvironment.cleanup();", "-\t\t\t}", "-\t\t\tmanager.flushZipFiles();", "-\t\t}\t", "-\t}", "+\t\t}", "+\t\tif (this.progressMonitor != null) {", "+\t\t\t// 1 for file path, 4 for parsing and binding creation, 5 for binding resolution? //$NON-NLS-1$", "+\t\t\tthis.progressMonitor.beginTask(\"\", filePaths.length * (this.pattern.mustResolve ? 10 : 5));", "+\t\t}", "+", "+\t\t// initialize pattern for polymorphic search (ie. method reference pattern)", "+\t\tthis.pattern.initializePolymorphicSearch(this, this.progressMonitor);", "+", "+\t\tJavaProject previousJavaProject = null;", "+\t\tPotentialMatchSet matchSet = new PotentialMatchSet();", "+\t\tUtil.sort(filePaths); ", "+\t\tfor (int i = 0, l = filePaths.length; i < l; i++) {", "+\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "+\t\t\t\tthrow new OperationCanceledException();", "+", "+\t\t\t// skip duplicate paths", "+\t\t\tString pathString = filePaths[i];", "+\t\t\tif (i > 0 && pathString.equals(filePaths[i - 1])) continue;", "+\t\t\t", "+\t\t\tOpenable openable;", "+\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = (org.eclipse.jdt.core.ICompilationUnit) wcPaths.get(pathString);", "+\t\t\tif (workingCopy != null) {", "+\t\t\t\topenable = (Openable) workingCopy;", "+\t\t\t} else {", "+\t\t\t\topenable = this.handleFactory.createOpenable(pathString, this.scope);", "+\t\t\t\tif (openable == null) continue; // match is outside classpath", "+", "+\t\t\t// create new parser and lookup environment if this is a new project", "+\t\t\tIResource resource = null;", "+\t\t\ttry {", "+\t\t\t\tJavaProject javaProject = (JavaProject) openable.getJavaProject();", "+\t\t\t\tresource = workingCopy != null ? workingCopy.getResource() : openable.getResource();", "+\t\t\t\tif (resource == null)", "+\t\t\t\t\tresource = javaProject.getProject(); // case of a file in an external jar", "+\t\t\t\tif (!javaProject.equals(previousJavaProject)) {", "+\t\t\t\t\t// locate matches in previous project", "+\t\t\t\t\tif (previousJavaProject != null) {", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tlocateMatches(previousJavaProject, matchSet);", "+\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) throw e;", "+\t\t\t\t\t\t\t// problem with classpath in this project -> skip it", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tmatchSet.reset();", "+\t\t\t\t\t}", "+\t\t\t\t\tpreviousJavaProject = javaProject;", "+\t\t\t\t}", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// file doesn't exist -> skip it", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tmatchSet.add(new PotentialMatch(this, resource, openable));", "+", "+\t\t\tif (this.progressMonitor != null)", "+\t\t\t\tthis.progressMonitor.worked(1);", "+\t\t// last project", "+\t\tif (previousJavaProject != null) {", "+\t\t\ttry {", "+\t\t\t\tlocateMatches(previousJavaProject, matchSet);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\tif (e.getException() instanceof CoreException) throw e;", "+\t\t\t\t// problem with classpath in last project -> skip it", "+\t\t\t}", "+\t\t} ", "+", "+\t\tif (this.progressMonitor != null)", "+\t\t\tthis.progressMonitor.done();", "+\t} finally {", "+\t\tif (this.nameEnvironment != null)", "+\t\t\tthis.nameEnvironment.cleanup();", "+\t\tmanager.flushZipFiles();", "+\t}\t", "+}"]}], "num": 44911}