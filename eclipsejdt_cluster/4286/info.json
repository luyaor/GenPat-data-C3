{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ee75237156b0c7e3494e979cc0b2dd21", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "22014db3a4f15a4d24fb7406f11c3792", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "c0679d24710a6b2a91bf47b3b4b03da992188ceb", "commitAfterChange": "e0d96d91a2a3382c51c572fe1c4254d193e4a7b4", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "diff": ["+\tif (length <= 1) {", "+\t\treturn true; // no need to continue since only 1 inherited method is left", "+\t}", "+\t// get rid of overriden methods coming from interfaces - if any", "+\tMethodBinding methodsToCheck[] = new MethodBinding[length];\t// must not nullify methods slots in place", "+\tint count = length;", "+\tfor (int i = 0; i < length; i++) {", "+\t\tmethodsToCheck[i] = methods[i];", "+\t}", "+\tfor (int i = 0; i < length; i++) {", "+\t\tMethodBinding existingMethod;", "+\t\tif ((existingMethod = methodsToCheck[i]) != null) {", "+\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\tMethodBinding inheritedMethod;", "+\t\t\t\tif (i != j && (inheritedMethod = methodsToCheck[j]) != null &&", "+\t\t\t\t\t\texistingMethod.declaringClass.implementsInterface(inheritedMethod.declaringClass, true)) {", "+\t\t\t\t\tMethodBinding substitute = computeSubstituteMethod(inheritedMethod, existingMethod);", "+\t\t\t\t\tif (substitute != null && ", "+\t\t\t\t\t\t\tdoesSubstituteMethodOverride(existingMethod, substitute) &&", "+\t\t\t\t\t\t\t(existingMethod.returnType.isCompatibleWith(substitute.returnType) ||", "+\t\t\t\t\t\t\t\t\tisReturnTypeSubstituable(substitute, existingMethod))) {", "+\t\t\t\t\t\tcount--;", "+\t\t\t\t\t\tmethodsToCheck[j] = null;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\tif (count < length) {", "+\t\tif (count == 1) { ", "+\t\t\treturn true; // no need to continue since only 1 inherited method is left", "+\t\t}", "+\t\tfor (int i = 0, j = 0; j < count; i++) {", "+\t\t\tif (methodsToCheck[i] != null) {", "+\t\t\t\tmethodsToCheck[j++] = methodsToCheck[i];", "+\t\t\t}", "+\t\t}", "+\t\tmethods = methodsToCheck;", "+\t\tlength = count;", "+\t} // else keep methods unchanged for further checks"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d95063c1e14ced38d997851a75ffdf8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "bacbe6f6e994ffc49a94960691c76bff97cb04d5", "commitAfterChange": "719705b20dc5e72fab3b2b50b669f9dfc58049aa", "methodNumberBeforeChange": 89, "methodNumberAfterChange": 89, "signatureBeforeChange": " \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, final InvocationSite invocationSite, ReferenceBinding receiverType)", "signatureAfterChange": " \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, final InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["+\t\t// Apply one level of filtering per poly expression more specific rules.", "+\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\tMethodBinding[] moreSpecific = new MethodBinding[visibleSize];", "+\t\t\tint count = 0;", "+\t\t\tfor (int i = 0, length = argumentTypes.length; i < length; i++) {", "+\t\t\t\tTypeBinding argumentType = argumentTypes[i];", "+\t\t\t\tif (argumentType.kind() != Binding.POLY_TYPE)", "+\t\t\t\t\tcontinue;", "+\t\t\t\tnext:", "+\t\t\t\t\tfor (int j = 0; j < visibleSize; j++) {", "+\t\t\t\t\t\tfinal TypeBinding[] mbjParameters = visible[j].parameters;", "+\t\t\t\t\t\tfinal int mbjParametersLength = mbjParameters.length;", "+\t\t\t\t\t\tTypeBinding t = i < mbjParametersLength ? mbjParameters[i] : mbjParameters[mbjParametersLength - 1];", "+\t\t\t\t\t\tboolean tIsMoreSpecific = false;", "+\t\t\t\t\t\tfor (int k = 0; k < visibleSize; k++) {", "+\t\t\t\t\t\t\tif (j == k) continue;", "+\t\t\t\t\t\t\tfinal TypeBinding[] mbkParameters = visible[k].parameters;", "+\t\t\t\t\t\t\tfinal int mbkParametersLength = mbkParameters.length;", "+\t\t\t\t\t\t\tTypeBinding s = i < mbkParametersLength ? mbkParameters[i] : mbkParameters[mbkParametersLength - 1];", "+\t\t\t\t\t\t\tif (TypeBinding.equalsEquals(t, s))", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\tif (!argumentType.sIsMoreSpecific(t,s)) ", "+\t\t\t\t\t\t\t\tcontinue next;", "+\t\t\t\t\t\t\ttIsMoreSpecific = true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (tIsMoreSpecific)", "+\t\t\t\t\t\t\tmoreSpecific[count++] = visible[j];", "+\t\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (count != 0) {", "+\t\t\t\tvisible = moreSpecific;", "+\t\t\t\tvisibleSize = count;", "+\t\t\t}", "+\t\t}", "+\t", "+\t\t// JLS7 implementation  ", "+\t\t"]}], "num": 4286}