{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "60a5f86a97772330233c37449ef96c8c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39636cb830d60b5a069891cfd20abe1f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r \tprivate void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "signatureAfterChange": "\r private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "diff": ["+ */\r", "+private void buildFromPotentialSubtypes(String[] allPotentialSubTypes) {\r", "+\t// sort by projects\r", "+\t/*\r", "+\t * NOTE: To workaround pb with hierarchy resolver that requests top  \r", "+\t * level types in the process of caching an enclosing type, this needs to\r", "+\t * be sorted in reverse alphabetical order so that top level types are cached\r", "+\t * before their inner types.\r", "-\tprivate void buildFromPotentialSubtypes(String[] allPotentialSubTypes) {\r", "-\t\t// sort by projects\r", "-\t\t/*\r", "-\t\t * NOTE: To workaround pb with hierarchy resolver that requests top  \r", "-\t\t * level types in the process of caching an enclosing type, this needs to\r", "-\t\t * be sorted in reverse alphabetical order so that top level types are cached\r", "-\t\t * before their inner types.\r", "-\t\t */\r", "-\t\tUtil.sortReverseOrder(allPotentialSubTypes);\r", "+\tUtil.sortReverseOrder(allPotentialSubTypes);\r", "+\t\r", "+\tVector infos = new Vector();\r", "+\tVector units = new Vector();\r", "-\t\tVector infos = new Vector();\r", "-\t\tVector units = new Vector();\r", "+\tIType focusType = this.getType();\r", "-\t\tIType focusType = this.getType();\r", "-\r", "-\t\t// create element infos for subtypes\r", "-\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "-\t\tIWorkspace workspace = focusType.getJavaProject().getProject().getWorkspace();\r", "-\t\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "-\t\tIJavaProject currentProject = null;\r", "-\t\tfor (int i = 0, length = allPotentialSubTypes.length; i < length; i++) {\r", "-\t\t\ttry {\r", "-\t\t\t\tString resourcePath = allPotentialSubTypes[i];\r", "-\t\t\t\tOpenable handle = factory.createOpenable(resourcePath);\r", "-\t\t\t\tif (handle == null)\r", "-\t\t\t\t\tcontinue; // match is outside classpath\r", "-\t\t\t\tIJavaProject project = handle.getJavaProject();\r", "-\t\t\t\tif (currentProject == null) {\r", "-\t\t\t\t\tcurrentProject = project;\r", "-\t\t\t\t\tinfos = new Vector(5);\r", "-\t\t\t\t\tunits = new Vector(5);\r", "-\t\t\t\t} else\r", "-\t\t\t\t\tif (!currentProject.equals(project)) {\r", "-\t\t\t\t\t\tthis.buildForProject((JavaProject) currentProject, infos, units);\r", "-\t\t\t\t\t\tcurrentProject = project;\r", "-\t\t\t\t\t\tinfos = new Vector(5);\r", "-\t\t\t\t\t\tunits = new Vector(5);\r", "-\t\t\t\t\t}\r", "-\t\t\t\tif (handle.isOpen()) {\r", "-\t\t\t\t\t// reuse the info from the java model cache\r", "-\t\t\t\t\tif (handle instanceof CompilationUnit) {\r", "-\t\t\t\t\t\tthis.addInfoFromOpenCU((CompilationUnit) handle, infos);\r", "-\t\t\t\t\t} else\r", "-\t\t\t\t\t\tif (handle instanceof ClassFile) {\r", "-\t\t\t\t\t\t\tthis.addInfoFromOpenClassFile((ClassFile) handle, infos);\r", "-\t\t\t\t\t\t}\r", "+\t// create element infos for subtypes\r", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\tIWorkspace workspace = focusType.getJavaProject().getProject().getWorkspace();\r", "+\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "+\tIJavaProject currentProject = null;\r", "+\tfor (int i = 0, length = allPotentialSubTypes.length; i < length; i++) {\r", "+\t\ttry {\r", "+\t\t\tString resourcePath = allPotentialSubTypes[i];\r", "+\t\t\tOpenable handle = factory.createOpenable(resourcePath);\r", "+\t\t\tif (handle == null) continue; // match is outside classpath\r", "+\t\t\tIJavaProject project = handle.getJavaProject();\r", "+\t\t\tif (currentProject == null) {\r", "+\t\t\t\tcurrentProject = project;\r", "+\t\t\t\tinfos = new Vector(5);\r", "+\t\t\t\tunits = new Vector(5);\r", "+\t\t\t} else if (!currentProject.equals(project)) {\r", "+\t\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units);\r", "+\t\t\t\tcurrentProject = project;\r", "+\t\t\t\tinfos = new Vector(5);\r", "+\t\t\t\tunits = new Vector(5);\r", "+\t\t\t}\r", "+\t\t\tif (handle.isOpen()) {\r", "+\t\t\t\t// reuse the info from the java model cache\r", "+\t\t\t\tif (handle instanceof CompilationUnit) {\r", "+\t\t\t\t\tthis.addInfoFromOpenCU((CompilationUnit)handle, infos);\r", "+\t\t\t\t} else if (handle instanceof ClassFile) {\r", "+\t\t\t\t\tthis.addInfoFromOpenClassFile((ClassFile)handle, infos);\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\tHierarchyBinaryType binaryType = (HierarchyBinaryType) binariesFromIndexMatches.get(resourcePath);\r", "+\t\t\t\tif (binaryType != null){\r", "+\t\t\t\t\tthis.addInfoFromBinaryIndexMatch(handle, binaryType, infos);\r", "-\t\t\t\t\tHierarchyBinaryType binaryType =\r", "-\t\t\t\t\t\t(HierarchyBinaryType) binariesFromIndexMatches.get(resourcePath);\r", "-\t\t\t\t\tif (binaryType != null) {\r", "-\t\t\t\t\t\tthis.addInfoFromBinaryIndexMatch(handle, binaryType, infos);\r", "+\t\t\t\t\t// create a temporary info\r", "+\t\t\t\t\tIJavaElement pkg = handle.getParent();\r", "+\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "+\t\t\t\t\tif (root.isArchive()) {\r", "+\t\t\t\t\t\t// class file in a jar\r", "+\t\t\t\t\t\tthis.createInfoFromClassFileInJar(handle, infos);\r", "-\t\t\t\t\t\t// create a temporary info\r", "-\t\t\t\t\t\tIJavaElement pkg = handle.getParent();\r", "-\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot) pkg.getParent();\r", "-\t\t\t\t\t\tif (root.isArchive()) {\r", "-\t\t\t\t\t\t\t// class file in a jar\r", "-\t\t\t\t\t\t\tthis.createInfoFromClassFileInJar(handle, infos);\r", "-\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t// file in a directory\r", "-\t\t\t\t\t\t\tIPath path = new Path(resourcePath);\r", "-\t\t\t\t\t\t\tIFile file = workspace.getRoot().getFile(path);\r", "-\t\t\t\t\t\t\tString osPath = file.getLocation().toOSString();\r", "+\t\t\t\t\t\t// file in a directory\r", "+\t\t\t\t\t\tIPath path = new Path(resourcePath);\r", "+\t\t\t\t\t\tIFile file = workspace.getRoot().getFile(path);\r", "+\t\t\t\t\t\tIPath location = file.getLocation();\r", "+\t\t\t\t\t\tif (location != null){\r", "+\t\t\t\t\t\t\tString osPath = location.toOSString();\r", "-\t\t\t\t\t\t\t} else\r", "-\t\t\t\t\t\t\t\tif (handle instanceof ClassFile) {\r", "-\t\t\t\t\t\t\t\t\t// class file in a directory\r", "-\t\t\t\t\t\t\t\t\tthis.createInfoFromClassFile(handle, osPath, infos);\r", "-\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t} else if (handle instanceof ClassFile) {\r", "+\t\t\t\t\t\t\t\t// class file in a directory\r", "+\t\t\t\t\t\t\t\tthis.createInfoFromClassFile(handle, osPath, infos);\r", "+\t\t\t\t\t\t\t}\r", "-\t\t\t\tworked(1);\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\tcontinue;\r", "+\t\t\tworked(1);\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t\tcontinue;\r", "+\t}\r", "+\ttry {\r", "+\t\tif (currentProject == null) currentProject = focusType.getJavaProject(); // case of no potential subtypes\r", "+\t\tthis.buildForProject((JavaProject)currentProject, infos, units);\r", "+\t} catch (JavaModelException e) {\r", "+\t}\r", "+\t\r", "+\t// Compute hierarchy of focus type if not already done (case of a type with potential subtypes that are not real subtypes)\r", "+\tif (!this.hierarchy.contains(focusType)) {\r", "-\t\t\tif (currentProject == null)\r", "-\t\t\t\tcurrentProject = focusType.getJavaProject(); // case of no potential subtypes\r", "-\t\t\tthis.buildForProject((JavaProject) currentProject, infos, units);\r", "+\t\t\tcurrentProject = focusType.getJavaProject();\r", "+\t\t\tthis.buildForProject((JavaProject)currentProject, new Vector(), new Vector());\r", "-\r", "-\t\t// Add focus if not already in (case of a type with no explicit super type)\r", "-\t\tif (!this.hierarchy.contains(focusType)) {\r", "-\t\t\tthis.hierarchy.addRootClass(focusType);\r", "-\t\t}\r", "+\t\r", "+\t// Add focus if not already in (case of a type with no explicit super type)\r", "+\tif (!this.hierarchy.contains(focusType)) {\r", "+\t\tthis.hierarchy.addRootClass(focusType);\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c439206c99427f3c8abec62b4902a083", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java", "commitBeforeChange": "6dbf227f3909a5c9be3f2b1942d08bb2a333adf5", "commitAfterChange": "1007c186f9f6b762c7a99cc47620c05dbb87ab5f", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic void set(Map settings)", "signatureAfterChange": "  \tpublic void set(Map settings)", "diff": ["+\t\t\t}", "+\t\t}", "+\t\tfinal Object blankLinesBetweenImportGroupsOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_BLANK_LINES_BETWEEN_IMPORT_GROUPS);", "+\t\tif (blankLinesBetweenImportGroupsOption != null) {", "+\t\t\ttry {", "+\t\t\t\tthis.blank_lines_between_import_groups = Integer.parseInt((String) blankLinesBetweenImportGroupsOption);", "+\t\t\t} catch (NumberFormatException e) {", "+\t\t\t\tthis.blank_lines_between_import_groups = 1;", "+\t\t\t} catch(ClassCastException e) {", "+\t\t\t\tthis.blank_lines_between_import_groups = 1;"]}], "num": 72363}