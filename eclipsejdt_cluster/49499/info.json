{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cc6f72f9cb5bba0f65d28c12b723a92f", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "25e0c586faad31d41e2384ef98a8e423", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "a8a55ef8028ddd96daf4473daaec157ec40ab668", "commitAfterChange": "2c2d8aa7ba193d80394867d2f6025d47f27b1f9e", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tsynchronized ITypeBinding getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.TypeBinding referenceBinding)", "signatureAfterChange": " \tsynchronized ITypeBinding getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.TypeBinding referenceBinding)", "diff": ["+\t\t\t\t\tif (!this.isRecoveringBindings) {", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "-\t\t\t\t\t} else if (this.isRecoveringBindings) {", "+\t\t\t\t\t} else {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "91a08e7644391df0cdf1b73652e2fe00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "6908063eba8a685f56d7ca33afe706e68d2c77b5", "commitAfterChange": "f78b6c4d80823115b2a0c851e53515d68cdcf5c5", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tprivate Boolean moreSpecificMain(TypeBinding si, TypeBinding ti, Expression expri) throws InferenceFailureException", "signatureAfterChange": " \tprivate Boolean moreSpecificMain(TypeBinding si, TypeBinding ti, Expression expri) throws InferenceFailureException", "diff": ["-\t// null:  need the otherwise branch", "+\t// null:  need to create the si <: ti constraint", "-\t\tif (si.isFunctionalInterface(this.scope)) {", "-\t\t\tTypeBinding funcI = ti.original();", "-\t\t\tif (funcI.isFunctionalInterface(this.scope)) {", "-\t\t\t\t// \"... none of the following is true:\" ", "-\t\t\t\tif (siSuperI(si, funcI) || siSubI(si, funcI))", "-\t\t\t\t\treturn null;", "-\t\t\t\tif (si instanceof IntersectionTypeBinding18) {", "-\t\t\t\t\tTypeBinding[] elements = ((IntersectionTypeBinding18)si).intersectingTypes;", "-\t\t\t\t\tcheckSuper: {", "-\t\t\t\t\t\tfor (int i = 0; i < elements.length; i++)", "-\t\t\t\t\t\t\tif (!siSuperI(elements[i], funcI))", "-\t\t\t\t\t\t\t\tbreak checkSuper;", "-\t\t\t\t\t\treturn null; // each element of the intersection is a superinterface of I, or a parameterization of a superinterface of I.", "-\t\t\t\t\t}", "+\t\t// \"if Ti is not a functional interface type\" specifically requests the si <: ti constraint created by our caller", "+\t\tif (!ti.isFunctionalInterface(this.scope))", "+\t\t\treturn null;", "+", "+\t\tTypeBinding funcI = ti.original();", "+\t\t// \"It must be determined whether Si satisfies the following five conditions:\"", "+\t\t// (we negate each condition for early exit):", "+\t\tif (si.isFunctionalInterface(this.scope)) {\t\t\t// bullet 1", "+\t\t\tif (siSuperI(si, funcI) || siSubI(si, funcI))", "+\t\t\t\treturn null;\t\t\t\t\t\t\t\t// bullets 2 & 3", "+\t\t\tif (si instanceof IntersectionTypeBinding18) {", "+\t\t\t\tTypeBinding[] elements = ((IntersectionTypeBinding18)si).intersectingTypes;", "+\t\t\t\tcheckSuper: {", "-\t\t\t\t\t\tif (siSubI(elements[i], funcI))", "-\t\t\t\t\t\t\treturn null; // some element of the intersection is a subinterface of I, or a parameterization of a subinterface of I.\t", "+\t\t\t\t\t\tif (!siSuperI(elements[i], funcI))", "+\t\t\t\t\t\t\tbreak checkSuper;", "+\t\t\t\t\treturn null;\t\t\t\t\t\t\t// bullet 4 ", "+\t\t\t\t\t// each element of the intersection is a superinterface of I, or a parameterization of a superinterface of I.", "-\t\t\t\t// all passed, time to do some work:", "-\t\t\t\tTypeBinding siCapture = si.capture(this.scope, expri.sourceStart, expri.sourceEnd);", "-\t\t\t\tMethodBinding sam = siCapture.getSingleAbstractMethod(this.scope, false); // no wildcards should be left needing replacement", "-\t\t\t\tTypeBinding[] u = sam.parameters;", "-\t\t\t\tTypeBinding r1 = sam.isConstructor() ? sam.declaringClass : sam.returnType;", "-\t\t\t\tsam = ti.getSingleAbstractMethod(this.scope, true); // TODO", "-\t\t\t\tTypeBinding[] v = sam.parameters;", "-\t\t\t\tTypeBinding r2 = sam.isConstructor() ? sam.declaringClass : sam.returnType;", "-\t\t\t\treturn Boolean.valueOf(checkExpression(expri, u, r1, v, r2));", "+\t\t\t\tfor (int i = 0; i < elements.length; i++)", "+\t\t\t\t\tif (siSubI(elements[i], funcI))", "+\t\t\t\t\t\treturn null;\t\t\t\t\t\t// bullet 5", "+\t\t\t\t\t\t// some element of the intersection is a subinterface of I, or a parameterization of a subinterface of I.\t", "+\t\t\t// all passed, time to do some work:", "+\t\t\tTypeBinding siCapture = si.capture(this.scope, expri.sourceStart, expri.sourceEnd);", "+\t\t\tMethodBinding sam = siCapture.getSingleAbstractMethod(this.scope, false); // no wildcards should be left needing replacement", "+\t\t\tTypeBinding[] u = sam.parameters;", "+\t\t\tTypeBinding r1 = sam.isConstructor() ? sam.declaringClass : sam.returnType;", "+\t\t\tsam = ti.getSingleAbstractMethod(this.scope, true); // TODO", "+\t\t\tTypeBinding[] v = sam.parameters;", "+\t\t\tTypeBinding r2 = sam.isConstructor() ? sam.declaringClass : sam.returnType;", "+\t\t\treturn Boolean.valueOf(checkExpression(expri, u, r1, v, r2));"]}], "num": 49499}