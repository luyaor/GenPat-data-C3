{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0bf47ac774f9d3b8a05b9f032ced9ab8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a70dbe9db42382c6cb83039ad82de905", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java", "commitBeforeChange": "d3244b9b1f07dec23fc8a11bdb05cd710c7b96c6", "commitAfterChange": "ed58872582a38f521f8bc7cc18b9c76c2c6fa7a1", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public void acceptImport(int declarationStart, int declarationEnd, char[] name, boolean onDemand)", "signatureAfterChange": " public void acceptImport(int declarationStart, int declarationEnd, char[] name, boolean onDemand, int modifiers)", "diff": ["-public void acceptImport(int declarationStart, int declarationEnd, char[] name, boolean onDemand) {", "+public void acceptImport(int declarationStart, int declarationEnd, char[] name, boolean onDemand, int modifiers) {", "-\tif (fImportContainerInfo == null) {", "-\t\tfImportContainerInfo= new JavaElementInfo();", "-\t\tfImportContainerInfo.setIsStructureKnown(true);", "+\tif (this.importContainerInfo == null) {", "+\t\tthis.importContainerInfo= new JavaElementInfo();", "+\t\tthis.importContainerInfo.setIsStructureKnown(true);", "-\t\tfNewElements.put(importContainer, fImportContainerInfo);", "+\t\tfNewElements.put(importContainer, this.importContainerInfo);", "-\tSourceRefElementInfo info = new SourceRefElementInfo();", "+\tImportDeclarationElementInfo info = new ImportDeclarationElementInfo();", "+\tinfo.setFlags(modifiers);", "+\tinfo.setName(name); // no trailing * if onDemand", "+\tinfo.setOnDemand(onDemand);", "-\tfImportContainerInfo.addChild(handle);", "+\tthis.importContainerInfo.addChild(handle);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3acea674dc39bf8fdf6badd4d1847c9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 125, "methodNumberAfterChange": 125, "signatureBeforeChange": " protected void consumeMethodHeaderParameters()", "signatureAfterChange": " protected void consumeMethodHeaderParameters()", "diff": ["-\tint length = astLengthStack[astLengthPtr--];", "-\tastPtr -= length;", "-\tAbstractMethodDeclaration md = (AbstractMethodDeclaration) astStack[astPtr];", "-\tmd.sourceEnd = \trParenPos;", "+\tint length = this.astLengthStack[this.astLengthPtr--];", "+\tthis.astPtr -= length;", "+\tAbstractMethodDeclaration md = (AbstractMethodDeclaration) this.astStack[this.astPtr];", "+\tmd.sourceEnd = \tthis.rParenPos;", "-\t\t\tastStack, ", "-\t\t\tastPtr + 1, ", "+\t\t\tthis.astStack, ", "+\t\t\tthis.astPtr + 1, ", "-\tmd.bodyStart = rParenPos+1;", "-\tlistLength = 0; // reset listLength after having read all parameters", "+\tmd.bodyStart = this.rParenPos+1;", "+\tthis.listLength = 0; // reset listLength after having read all parameters", "-\tif (currentElement != null){", "-\t\tlastCheckPoint = md.bodyStart;", "-\t\tif (currentElement.parseTree() == md) return;", "+\tif (this.currentElement != null){", "+\t\tthis.lastCheckPoint = md.bodyStart;", "+\t\tif (this.currentElement.parseTree() == md) return;", "-\t\t\t\t|| (currentToken == TokenNameLBRACE) ", "-\t\t\t\t|| (currentToken == TokenNamethrows)){", "-\t\t\t\tcurrentElement = currentElement.add(md, 0);", "-\t\t\t\tlastIgnoredToken = -1;", "+\t\t\t\t|| (this.currentToken == TokenNameLBRACE) ", "+\t\t\t\t|| (this.currentToken == TokenNamethrows)){", "+\t\t\t\tthis.currentElement = this.currentElement.add(md, 0);", "+\t\t\t\tthis.lastIgnoredToken = -1;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb4a8fbb15cd6980d631a73f00d0e253", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java", "commitBeforeChange": "babe82af3726a6979eb5da4c747f51906154b2bc", "commitAfterChange": "fab4ac0c2a45db58d02407ad5972d843c8dba1e6", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\tpublic FlowInfo analyseCode(", "-\t\tBlockScope currentScope,", "-\t\tFlowContext flowContext,", "-\t\tFlowInfo flowInfo) {", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "+\tthis.breakLabel = new BranchLabel();", "+\tthis.continueLabel = new BranchLabel();", "+\tLoopingFlowContext loopingContext =", "+\t\tnew LoopingFlowContext(", "+\t\t\tflowContext,", "+\t\t\tflowInfo,", "+\t\t\tthis,", "+\t\t\tthis.breakLabel,", "+\t\t\tthis.continueLabel,", "+\t\t\tcurrentScope);", "-\t\tbreakLabel = new BranchLabel();", "-\t\tcontinueLabel = new BranchLabel();", "-\t\tLoopingFlowContext loopingContext =", "-\t\t\tnew LoopingFlowContext(", "-\t\t\t\tflowContext,", "-\t\t\t\tflowInfo,", "-\t\t\t\tthis,", "-\t\t\t\tbreakLabel,", "-\t\t\t\tcontinueLabel,", "-\t\t\t\tcurrentScope);", "+\tConstant cst = this.condition.constant;", "+\tboolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\tcst = this.condition.optimizedBooleanConstant();", "+\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "-\t\tConstant cst = condition.constant;", "-\t\tboolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\tcst = condition.optimizedBooleanConstant();", "-\t\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "+\tint previousMode = flowInfo.reachMode();", "+\t\t\t", "+\tUnconditionalFlowInfo actionInfo = flowInfo.nullInfoLessUnconditionalCopy();", "+\t// we need to collect the contribution to nulls of the coming paths through the", "+\t// loop, be they falling through normally or branched to break, continue labels", "+\t// or catch blocks", "+\tif ((this.action != null) && !this.action.isEmptyBlock()) {", "+\t\tactionInfo = this.action.", "+\t\t\tanalyseCode(currentScope, loopingContext, actionInfo).", "+\t\t\tunconditionalInits();", "-\t\tint previousMode = flowInfo.reachMode();", "-\t\t\t\t", "-\t\tUnconditionalFlowInfo actionInfo = flowInfo.nullInfoLessUnconditionalCopy();", "-\t\t// we need to collect the contribution to nulls of the coming paths through the", "-\t\t// loop, be they falling through normally or branched to break, continue labels", "-\t\t// or catch blocks", "-\t\tif ((action != null) && !action.isEmptyBlock()) {", "-\t\t\tactionInfo = action.", "-\t\t\t\tanalyseCode(currentScope, loopingContext, actionInfo).", "-\t\t\t\tunconditionalInits();", "-", "-\t\t\t// code generation can be optimized when no need to continue in the loop", "-\t\t\tif ((actionInfo.tagBits & ", "-\t\t\t\t\tloopingContext.initsOnContinue.tagBits & ", "-\t\t\t\t\tFlowInfo.UNREACHABLE) != 0) {", "-\t\t\t\tcontinueLabel = null;", "-\t\t\t}", "+\t\t// code generation can be optimized when no need to continue in the loop", "+\t\tif ((actionInfo.tagBits & ", "+\t\t\t\tloopingContext.initsOnContinue.tagBits & ", "+\t\t\t\tFlowInfo.UNREACHABLE) != 0) {", "+\t\t\tthis.continueLabel = null;", "-\t\t/* Reset reach mode, to address following scenario.", "-\t\t *   final blank;", "-\t\t *   do { if (true) break; else blank = 0; } while(false);", "-\t\t *   blank = 1; // may be initialized already ", "-\t\t */", "-\t\tactionInfo.setReachMode(previousMode);", "-\t\t", "-\t\tLoopingFlowContext condLoopContext;", "-\t\tFlowInfo condInfo =", "-\t\t\tcondition.analyseCode(", "-\t\t\t\tcurrentScope,", "-\t\t\t\t(condLoopContext =", "-\t\t\t\t\tnew LoopingFlowContext(flowContext,\tflowInfo, this, null, ", "-\t\t\t\t\t\tnull, currentScope)),", "-\t\t\t\t(action == null", "-\t\t\t\t\t? actionInfo", "-\t\t\t\t\t: (actionInfo.mergedWith(loopingContext.initsOnContinue))).copy());", "-\t\tif (!isConditionOptimizedFalse && continueLabel != null) {", "-\t\t\tloopingContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "-\t\t\tcondLoopContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "-\t\t\tUnconditionalFlowInfo checkFlowInfo;", "-\t\t\tloopingContext.complainOnDeferredNullChecks(currentScope, ", "-\t\t\t\t\tcheckFlowInfo = actionInfo.", "-\t\t\t\t\t\taddPotentialNullInfoFrom(", "-\t\t\t\t\t\t  condInfo.initsWhenTrue().unconditionalInits()));", "-\t\t\tcondLoopContext.complainOnDeferredNullChecks(currentScope, ", "-\t\t\t\t\tcheckFlowInfo);", "-\t\t}", "-", "-\t\t// end of loop", "-\t\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "-\t\t\t\t(loopingContext.initsOnBreak.tagBits &", "-\t\t\t\t\tFlowInfo.UNREACHABLE) != 0 ?", "-\t\t\t\t\tloopingContext.initsOnBreak :", "-\t\t\t\t\tflowInfo.unconditionalCopy().addInitializationsFrom(loopingContext.initsOnBreak), ", "-\t\t\t\t\t\t// recover upstream null info", "-\t\t\t\tisConditionOptimizedTrue,", "-\t\t\t\t(condInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ?", "-\t\t\t\t\t\tflowInfo.addInitializationsFrom(condInfo.initsWhenFalse()) : condInfo, ", "-\t\t\t\t\t// recover null inits from before condition analysis", "-\t\t\t\tfalse, // never consider opt false case for DO loop, since break can always occur (47776)", "-\t\t\t\t!isConditionTrue /*do{}while(true); unreachable(); */);", "-\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\treturn mergedInfo;", "+\t/* Reset reach mode, to address following scenario.", "+\t *   final blank;", "+\t *   do { if (true) break; else blank = 0; } while(false);", "+\t *   blank = 1; // may be initialized already ", "+\tactionInfo.setReachMode(previousMode);", "+\t", "+\tLoopingFlowContext condLoopContext;", "+\tFlowInfo condInfo =", "+\t\tthis.condition.analyseCode(", "+\t\t\tcurrentScope,", "+\t\t\t(condLoopContext =", "+\t\t\t\tnew LoopingFlowContext(flowContext,\tflowInfo, this, null, ", "+\t\t\t\t\tnull, currentScope)),", "+\t\t\t(this.action == null", "+\t\t\t\t? actionInfo", "+\t\t\t\t: (actionInfo.mergedWith(loopingContext.initsOnContinue))).copy());", "+\tif (!isConditionOptimizedFalse && this.continueLabel != null) {", "+\t\tloopingContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "+\t\tcondLoopContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "+\t\tUnconditionalFlowInfo checkFlowInfo;", "+\t\tloopingContext.complainOnDeferredNullChecks(currentScope, ", "+\t\t\t\tcheckFlowInfo = actionInfo.", "+\t\t\t\t\taddPotentialNullInfoFrom(", "+\t\t\t\t\t  condInfo.initsWhenTrue().unconditionalInits()));", "+\t\tcondLoopContext.complainOnDeferredNullChecks(currentScope, ", "+\t\t\t\tcheckFlowInfo);", "+\t// end of loop", "+\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "+\t\t\t(loopingContext.initsOnBreak.tagBits &", "+\t\t\t\tFlowInfo.UNREACHABLE) != 0 ?", "+\t\t\t\tloopingContext.initsOnBreak :", "+\t\t\t\tflowInfo.unconditionalCopy().addInitializationsFrom(loopingContext.initsOnBreak), ", "+\t\t\t\t\t// recover upstream null info", "+\t\t\tisConditionOptimizedTrue,", "+\t\t\t(condInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ?", "+\t\t\t\t\tflowInfo.addInitializationsFrom(condInfo.initsWhenFalse()) : condInfo, ", "+\t\t\t\t// recover null inits from before condition analysis", "+\t\t\tfalse, // never consider opt false case for DO loop, since break can always occur (47776)", "+\t\t\t!isConditionTrue /*do{}while(true); unreachable(); */);", "+\tthis.mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "+\treturn mergedInfo;", "+}"]}], "num": 53786}