{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8f296eee38b8bf3c1b64de0a90e1d3e8", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "098d935fad990587d9c37f881e81cc13", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "34746595229d52daf40c32629450d7fae4966422", "commitAfterChange": "88853c38c7298f1ea978b5ada5033a497eb024c5", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 28, "signatureBeforeChange": " \tpublic void completeCodeAttributeForClinit(int codeAttributeOffset)", "signatureAfterChange": " \tpublic void completeCodeAttributeForClinit(int codeAttributeOffset)", "diff": ["-\t\tint exceptionHandlersNumber = codeStream.exceptionHandlersCounter;", "-\t\tExceptionLabel[] exceptionHandlers = codeStream.exceptionHandlers;", "-\t\tint exSize = exceptionHandlersNumber * 8 + 2;", "+\t\tExceptionLabel[] exceptionLabels = codeStream.exceptionLabels;", "+\t\tint exceptionHandlersCount = 0; // each label holds one handler per range (start/end contiguous)", "+\t\tfor (int i = 0, length = codeStream.exceptionLabelsCounter; i < length; i++) {", "+\t\t\texceptionHandlersCount += codeStream.exceptionLabels[i].count / 2; ", "+\t\t}", "+\t\tint exSize = exceptionHandlersCount * 8 + 2;", "-\t\tthis.contents[localContentsOffset++] = (byte) (exceptionHandlersNumber >> 8);", "-\t\tthis.contents[localContentsOffset++] = (byte) exceptionHandlersNumber;", "-\t\tfor (int i = 0, max = codeStream.exceptionHandlersIndex; i < max; i++) {", "-\t\t\tExceptionLabel exceptionHandler = exceptionHandlers[i];", "-\t\t\tif (exceptionHandler != null) {", "-\t\t\t\tint start = exceptionHandler.start;", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) (start >> 8);", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) start;", "-\t\t\t\tint end = exceptionHandler.end;", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) (end >> 8);", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) end;", "-\t\t\t\tint handlerPC = exceptionHandler.position;", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) (handlerPC >> 8);", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) handlerPC;", "-\t\t\t\tif (exceptionHandler.exceptionType == null) {", "-\t\t\t\t\t// any exception handler", "-\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "-\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "-\t\t\t\t} else {", "-\t\t\t\t\tint nameIndex;", "-\t\t\t\t\tif (exceptionHandler.exceptionType == TypeBinding.NULL) {", "-\t\t\t\t\t\t/* represents denote ClassNotFoundException, see class literal access*/", "-\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(ConstantPool.JavaLangClassNotFoundExceptionConstantPoolName);", "+\t\tthis.contents[localContentsOffset++] = (byte) (exceptionHandlersCount >> 8);", "+\t\tthis.contents[localContentsOffset++] = (byte) exceptionHandlersCount;", "+\t\tfor (int i = 0, max = codeStream.exceptionLabelsCounter; i < max; i++) {", "+\t\t\tExceptionLabel exceptionLabel = exceptionLabels[i];", "+\t\t\tif (exceptionLabel != null) {", "+\t\t\t\tint iRange = 0, maxRange = exceptionLabel.count;", "+\t\t\t\twhile  (iRange < maxRange) {", "+\t\t\t\t\tint start = exceptionLabel.ranges[iRange++]; // even ranges are start positions", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (start >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) start;", "+\t\t\t\t\tint end = exceptionLabel.ranges[iRange++]; // odd ranges are end positions", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (end >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) end;", "+\t\t\t\t\tint handlerPC = exceptionLabel.position;", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (handlerPC >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) handlerPC;", "+\t\t\t\t\tif (exceptionLabel.exceptionType == null) {", "+\t\t\t\t\t\t// any exception handler", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "-\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(exceptionHandler.exceptionType.constantPoolName());", "+\t\t\t\t\t\tint nameIndex;", "+\t\t\t\t\t\tif (exceptionLabel.exceptionType == TypeBinding.NULL) {", "+\t\t\t\t\t\t\t/* represents denote ClassNotFoundException, see class literal access*/", "+\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(ConstantPool.JavaLangClassNotFoundExceptionConstantPoolName);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(exceptionLabel.exceptionType.constantPoolName());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (nameIndex >> 8);", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) nameIndex;", "-\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (nameIndex >> 8);", "-\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) nameIndex;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "44a9b8fa3e6f1c765646626572031244", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "34746595229d52daf40c32629450d7fae4966422", "commitAfterChange": "88853c38c7298f1ea978b5ada5033a497eb024c5", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic void completeCodeAttribute(int codeAttributeOffset)", "signatureAfterChange": " \tpublic void completeCodeAttribute(int codeAttributeOffset)", "diff": ["-\t\tint exceptionHandlersNumber = codeStream.exceptionHandlersCounter;", "-\t\tExceptionLabel[] exceptionHandlers = codeStream.exceptionHandlers;", "-\t\tint exSize = exceptionHandlersNumber * 8 + 2;", "+\t\tExceptionLabel[] exceptionLabels = codeStream.exceptionLabels;", "+\t\tint exceptionHandlersCount = 0; // each label holds one handler per range (start/end contiguous)", "+\t\tfor (int i = 0, length = codeStream.exceptionLabelsCounter; i < length; i++) {", "+\t\t\texceptionHandlersCount += codeStream.exceptionLabels[i].count / 2; ", "+\t\t}", "+\t\tint exSize = exceptionHandlersCount * 8 + 2;", "-\t\tthis.contents[localContentsOffset++] = (byte) (exceptionHandlersNumber >> 8);", "-\t\tthis.contents[localContentsOffset++] = (byte) exceptionHandlersNumber;", "-\t\tfor (int i = 0, max = codeStream.exceptionHandlersIndex; i < max; i++) {", "-\t\t\tExceptionLabel exceptionHandler = exceptionHandlers[i];", "-\t\t\tif (exceptionHandler != null) {", "-\t\t\t\tint start = exceptionHandler.start;", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) (start >> 8);", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) start;", "-\t\t\t\tint end = exceptionHandler.end;", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) (end >> 8);", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) end;", "-\t\t\t\tint handlerPC = exceptionHandler.position;", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) (handlerPC >> 8);", "-\t\t\t\tthis.contents[localContentsOffset++] = (byte) handlerPC;", "-\t\t\t\tif (exceptionHandler.exceptionType == null) {", "-\t\t\t\t\t// any exception handler", "-\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "-\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "-\t\t\t\t} else {", "-\t\t\t\t\tint nameIndex;", "-\t\t\t\t\tif (exceptionHandler.exceptionType == TypeBinding.NULL) {", "-\t\t\t\t\t\t/* represents ClassNotFoundException, see class literal access*/", "-\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(ConstantPool.JavaLangClassNotFoundExceptionConstantPoolName);", "+\t\tthis.contents[localContentsOffset++] = (byte) (exceptionHandlersCount >> 8);", "+\t\tthis.contents[localContentsOffset++] = (byte) exceptionHandlersCount;", "+\t\tfor (int i = 0, max = codeStream.exceptionLabelsCounter; i < max; i++) {", "+\t\t\tExceptionLabel exceptionLabel = exceptionLabels[i];", "+\t\t\tif (exceptionLabel != null) {", "+\t\t\t\tint iRange = 0, maxRange = exceptionLabel.count;", "+\t\t\t\twhile  (iRange < maxRange) {", "+\t\t\t\t\tint start = exceptionLabel.ranges[iRange++]; // even ranges are start positions", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (start >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) start;", "+\t\t\t\t\tint end = exceptionLabel.ranges[iRange++]; // odd ranges are end positions", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (end >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) end;", "+\t\t\t\t\tint handlerPC = exceptionLabel.position;", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (handlerPC >> 8);", "+\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) handlerPC;", "+\t\t\t\t\tif (exceptionLabel.exceptionType == null) {", "+\t\t\t\t\t\t// any exception handler", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "-\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(exceptionHandler.exceptionType.constantPoolName());", "+\t\t\t\t\t\tint nameIndex;", "+\t\t\t\t\t\tif (exceptionLabel.exceptionType == TypeBinding.NULL) {", "+\t\t\t\t\t\t\t/* represents ClassNotFoundException, see class literal access*/", "+\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(ConstantPool.JavaLangClassNotFoundExceptionConstantPoolName);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(exceptionLabel.exceptionType.constantPoolName());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (nameIndex >> 8);", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) nameIndex;", "-\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (nameIndex >> 8);", "-\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) nameIndex;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76de8901d90c5e5386dc1baa4f72781b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "34746595229d52daf40c32629450d7fae4966422", "commitAfterChange": "88853c38c7298f1ea978b5ada5033a497eb024c5", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " \tpublic void completeCodeAttributeForSyntheticMethod( \t\tboolean hasExceptionHandlers, \t\tSyntheticMethodBinding binding, \t\tint codeAttributeOffset, \t\tint[] startLineIndexes)", "signatureAfterChange": " \tpublic void completeCodeAttributeForSyntheticMethod( \t\tboolean hasExceptionHandlers, \t\tSyntheticMethodBinding binding, \t\tint codeAttributeOffset, \t\tint[] startLineIndexes)", "diff": ["-\t\t\tint exceptionHandlersNumber = codeStream.exceptionHandlersCounter;", "-\t\t\tExceptionLabel[] exceptionHandlers = codeStream.exceptionHandlers;", "-\t\t\tint exSize = exceptionHandlersNumber * 8 + 2;", "+\t\t\tExceptionLabel[] exceptionLabels = codeStream.exceptionLabels;", "+\t\t\tint exceptionHandlersCount = 0; // each label holds one handler per range (start/end contiguous)", "+\t\t\tfor (int i = 0, length = codeStream.exceptionLabelsCounter; i < length; i++) {", "+\t\t\t\texceptionHandlersCount += codeStream.exceptionLabels[i].count / 2; ", "+\t\t\t}", "+\t\t\tint exSize = exceptionHandlersCount * 8 + 2;", "-\t\t\tthis.contents[localContentsOffset++] = (byte) (exceptionHandlersNumber >> 8);", "-\t\t\tthis.contents[localContentsOffset++] = (byte) exceptionHandlersNumber;", "-\t\t\tfor (int i = 0, max = codeStream.exceptionHandlersIndex; i < max; i++) {", "-\t\t\t\tExceptionLabel exceptionHandler = exceptionHandlers[i];", "-\t\t\t\tif (exceptionHandler != null) {", "-\t\t\t\t\tint start = exceptionHandler.start;", "-\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (start >> 8);", "-\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) start;", "-\t\t\t\t\tint end = exceptionHandler.end;", "-\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (end >> 8);", "-\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) end;", "-\t\t\t\t\tint handlerPC = exceptionHandler.position;", "-\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (handlerPC >> 8);", "-\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) handlerPC;", "-\t\t\t\t\tif (exceptionHandler.exceptionType == null) {", "-\t\t\t\t\t\t// any exception handler", "-\t\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "-\t\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tint nameIndex;", "-\t\t\t\t\t\tswitch(exceptionHandler.exceptionType.id) {", "-\t\t\t\t\t\t\tcase T_null :", "-\t\t\t\t\t\t\t\t/* represents ClassNotFoundException, see class literal access*/", "-\t\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(ConstantPool.JavaLangClassNotFoundExceptionConstantPoolName);", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase T_long :", "-\t\t\t\t\t\t\t\t/* represents NoSuchFieldError, see switch table generation*/", "-\t\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(ConstantPool.JavaLangNoSuchFieldErrorConstantPoolName);", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(exceptionHandler.exceptionType.constantPoolName());", "+\t\t\tthis.contents[localContentsOffset++] = (byte) (exceptionHandlersCount >> 8);", "+\t\t\tthis.contents[localContentsOffset++] = (byte) exceptionHandlersCount;", "+\t\t\tfor (int i = 0, max = codeStream.exceptionLabelsCounter; i < max; i++) {", "+\t\t\t\tExceptionLabel exceptionLabel = exceptionLabels[i];", "+\t\t\t\tif (exceptionLabel != null) {", "+\t\t\t\t\tint iRange = 0, maxRange = exceptionLabel.count;", "+\t\t\t\t\twhile  (iRange < maxRange) {", "+\t\t\t\t\t\tint start = exceptionLabel.ranges[iRange++]; // even ranges are start positions", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (start >> 8);", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) start;", "+\t\t\t\t\t\tint end = exceptionLabel.ranges[iRange++]; // odd ranges are end positions", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (end >> 8);", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) end;", "+\t\t\t\t\t\tint handlerPC = exceptionLabel.position;", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (handlerPC >> 8);", "+\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) handlerPC;", "+\t\t\t\t\t\tif (exceptionLabel.exceptionType == null) {", "+\t\t\t\t\t\t\t// any exception handler", "+\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "+\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = 0;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tint nameIndex;", "+\t\t\t\t\t\t\tswitch(exceptionLabel.exceptionType.id) {", "+\t\t\t\t\t\t\t\tcase T_null :", "+\t\t\t\t\t\t\t\t\t/* represents ClassNotFoundException, see class literal access*/", "+\t\t\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(ConstantPool.JavaLangClassNotFoundExceptionConstantPoolName);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase T_long :", "+\t\t\t\t\t\t\t\t\t/* represents NoSuchFieldError, see switch table generation*/", "+\t\t\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(ConstantPool.JavaLangNoSuchFieldErrorConstantPoolName);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\t\tnameIndex = constantPool.literalIndexForType(exceptionLabel.exceptionType.constantPoolName());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (nameIndex >> 8);", "+\t\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) nameIndex;", "-\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) (nameIndex >> 8);", "-\t\t\t\t\t\tthis.contents[localContentsOffset++] = (byte) nameIndex;"]}], "num": 62791}