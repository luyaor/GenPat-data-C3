{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f1db62f1f2afe85f9b6f6bff1f36ecd4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7e3a4302733266d205340553aa69e6e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java", "commitBeforeChange": "c86c38d672e49d50e598810327b66493258e94dd", "commitAfterChange": "060261358ee4101b16c7399fe1e71ff5bc4ac40a", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic boolean isInterchangeableWith(final LookupEnvironment environment, final TypeVariableBinding otherVariable)", "signatureAfterChange": " \tpublic boolean isInterchangeableWith(TypeVariableBinding otherVariable, Substitution substitute)", "diff": ["-\tpublic boolean isInterchangeableWith(final LookupEnvironment environment, final TypeVariableBinding otherVariable) {", "+\tpublic boolean isInterchangeableWith(TypeVariableBinding otherVariable, Substitution substitute) {", "-\t\tidentical: {", "-\t\t\tif (this.superclass != otherVariable.superclass) {", "-\t\t\t\tif (this.superclass.erasure() != otherVariable.superclass.erasure())", "-\t\t\t\t\treturn false; // no way it can match after substitution", "-\t\t\t\tbreak identical;", "-\t\t\t}", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tif (this.superInterfaces[i] != otherVariable.superInterfaces[i]) {", "-\t\t\t\t\tif (this.superInterfaces[i].erasure() != otherVariable.superInterfaces[i].erasure())", "-\t\t\t\t\t\treturn false; // no way it can match after substitution", "-\t\t\t\t\tbreak identical;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn true;", "-\t\t}", "-\t\t// need substitutions", "-\t\tSubstitution subst = new Substitution() {", "-\t\t\tpublic LookupEnvironment environment() { return environment; }", "-\t\t\tpublic boolean isRawSubstitution() { return false; }", "-\t\t\tpublic TypeBinding substitute(TypeVariableBinding typeVariable) {", "-\t\t\t\treturn typeVariable == otherVariable ? TypeVariableBinding.this : typeVariable;", "-\t\t\t}", "-\t\t};", "-\t\tif (this.superclass != Scope.substitute(subst, otherVariable.superclass))", "+\t\tif (this.superclass != Scope.substitute(substitute, otherVariable.superclass))", "-\t\tfor (int i = 0; i < length; i++)", "-\t\t\tif (this.superInterfaces[i] != Scope.substitute(subst, otherVariable.superInterfaces[i]))", "-\t\t\t\treturn false;", "+", "+\t\tnext : for (int i = 0; i < length; i++) {", "+\t\t\tTypeBinding superType = Scope.substitute(substitute, otherVariable.superInterfaces[i]);", "+\t\t\tfor (int j = 0; j < length; j++)", "+\t\t\t\tif (superType == this.superInterfaces[j])", "+\t\t\t\t\tcontinue next;", "+\t\t\treturn false; // not a match", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f6848a7c143466b67099466fe41f589b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "bca01eadc82a3abb71100149fcbedb07d33a04ad", "commitAfterChange": "a6f21a01110fe95a43760ec08fc8cc1e27e1c4bc", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tboolean use18specifics = sourceLevel >= ClassFileConstants.JDK1_8;", "+\t\tthis.use18specifics = sourceLevel >= ClassFileConstants.JDK1_8;", "-\t\tif (use18specifics) {", "+\t\tif (this.use18specifics) {", "-", "-\t\t\tif (isPolyExpression()) {", "-\t\t\t\tthis.polyExpressionScope = scope;", "-\t\t\t}", "-", "-\t\t\tif (this.originalValueIfTrueType.kind() == Binding.POLY_TYPE || this.originalValueIfFalseType.kind() == Binding.POLY_TYPE) {", "-\t\t\t\treturn new PolyTypeBinding(this);", "-\t\t\t}", "+\t\t\t/* Not reached as of now as we don't evaluate conditional expressions multiple times, left in for now.", "+\t\t\t   If in future, we change things so control reaches here, a precondition is that this.expectedType is", "+\t\t\t   the final target type.", "+\t\t\t*/", "-\t\t", "+\t\tif (isPolyExpression()) {", "+\t\t\tif (this.expectedType == null) {", "+\t\t\t\tthis.polyExpressionScope = scope; // preserve for eventual resolution/error reporting.", "+\t\t\t\treturn new PolyTypeBinding(this);", "+\t\t\t}", "+\t\t\tcomputeConversions(scope, this.expectedType);", "+\t\t\treturn this.resolvedType = this.expectedType;", "+\t\t}", "-\t\tif (use18specifics && isPolyExpression()) {", "-\t\t\tif (this.expectedType == null) {", "-\t\t\t\tthis.polyExpressionScope = scope;", "-\t\t\t\treturn new PolyTypeBinding(this);", "-\t\t\t}", "-\t\t\tif (valueIfTrueType != null) {", "-\t\t\t\tif (!valueIfTrueType.isCompatibleWith(this.expectedType, scope)) {", "-\t\t\t\t\tscope.problemReporter().typeMismatchError(valueIfTrueType, this.expectedType, this.valueIfTrue, null);", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.valueIfTrue.computeConversion(scope, this.expectedType, this.originalValueIfTrueType);\t", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (valueIfFalseType != null) {", "-\t\t\t\tif (!valueIfFalseType.isCompatibleWith(this.expectedType, scope)) {", "-\t\t\t\t\tscope.problemReporter().typeMismatchError(valueIfFalseType, this.expectedType, this.valueIfFalse, null);", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.valueIfFalse.computeConversion(scope, this.expectedType, this.originalValueIfFalseType);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn this.resolvedType = this.expectedType;", "-\t\t}"]}], "num": 363}