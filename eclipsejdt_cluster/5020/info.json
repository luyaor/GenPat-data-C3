{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "294789d08259d9ea4908a3d65db2bfe4", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3ecf6cc12d09435a26c9a7b61f310c3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "67da1da15e9afbcd33679f07597c706e7915cf4a", "commitAfterChange": "027fccb2c17e0f0d2b28705c6704af10fc8ce0aa", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected void attachOrphanCompletionNode()", "signatureAfterChange": " protected void attachOrphanCompletionNode()", "diff": ["+\tif(assistNode == null) return;", "+\t", "-\tif ((!this.inMethodStack[this.inMethodPtr] && !this.inFieldInitializationStack[this.inFieldInitializationPtr])) { ", "+\tif ((!isInsideMethod() && !isInsideFieldInitialization())) { ", "-\tif (this.expressionPtr > -1 && containsCompletionNode(expression = this.expressionStack[this.expressionPtr])) {", "-\t\t/* check for completion at the beginning of method body", "-\t\t\tbehind an invalid signature", "-\t\t */", "-\t\tRecoveredMethod method = currentElement.enclosingMethod();", "-\t\tif (method != null){", "-\t\t\tAbstractMethodDeclaration methodDecl = method.methodDeclaration;", "-\t\t\tif ((methodDecl.bodyStart == methodDecl.sourceEnd+1) // was missing opening brace", "-\t\t\t\t&& (scanner.getLineNumber(expression.sourceStart) == scanner.getLineNumber(methodDecl.sourceEnd))){", "-\t\t\t\treturn;", "+\tif (this.expressionPtr > -1) {", "+\t\texpression = this.expressionStack[this.expressionPtr];", "+\t\tCompletionNodeDetector detector = new CompletionNodeDetector(assistNode, expression);", "+\t\tif(detector.containsCompletionNode()) {", "+\t\t\t/* check for completion at the beginning of method body", "+\t\t\t\tbehind an invalid signature", "+\t\t\t */", "+\t\t\tRecoveredMethod method = currentElement.enclosingMethod();", "+\t\t\tif (method != null){", "+\t\t\t\tAbstractMethodDeclaration methodDecl = method.methodDeclaration;", "+\t\t\t\tif ((methodDecl.bodyStart == methodDecl.sourceEnd+1) // was missing opening brace", "+\t\t\t\t\t&& (scanner.getLineNumber(expression.sourceStart) == scanner.getLineNumber(methodDecl.sourceEnd))){", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif(expression == assistNode", "+\t\t\t\t|| (expression instanceof AllocationExpression", "+\t\t\t\t\t&& ((AllocationExpression)expression).type == assistNode)){", "+\t\t\t\tbuildMoreCompletionContext(expression);", "+\t\t\t} else {", "+\t\t\t\tassistNodeParent = detector.getCompletionNodeParent();", "+\t\t\t\tif(assistNodeParent != null) {", "+\t\t\t\t\tcurrentElement = currentElement.add((Statement)assistNodeParent, 0);", "+\t\t\t\t} else {", "+\t\t\t\t\tcurrentElement = currentElement.add(expression, 0);", "+\t\t\t\t}", "-\t\tif (expression instanceof AllocationExpression) {", "-\t\t\t// keep the context if it is an allocation expression", "-\t\t\tStatement statement = (Statement)wrapWithExplicitConstructorCallIfNeeded(expression);", "-\t\t\tcurrentElement = currentElement.add(statement, 0);", "-\t\t} else {", "-\t\t\tStatement statement = (Statement)wrapWithExplicitConstructorCallIfNeeded(this.assistNode);", "-\t\t\tcurrentElement = currentElement.add(statement, 0);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bad64025b3790869f0bbc5018761a653", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 27, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["+\tif ((modifiers & AccUnresolved) == 0)", "+\t\treturn methods;", "+", "+\tint failed = 0;", "-\t\tif ((modifiers & AccUnresolved) == 0)", "-\t\t\treturn methods;", "-\t", "-\t\tint failed = 0;", "-\t\tfor (int m = 0, max = methods.length; m < max; m++) {", "-\t\t\tif (resolveTypesFor(methods[m]) == null) {", "-\t\t\t\tmethods[m] = null; // unable to resolve parameters", "+\t\tfor (int i = 0, length = methods.length; i < length; i++) {", "+\t\t\tif (resolveTypesFor(methods[i]) == null) {", "+\t\t\t\tmethods[i] = null; // unable to resolve parameters", "-\t", "-\t\tfor (int m = methods.length; --m >= 0;) {", "-\t\t\tMethodBinding method = methods[m];", "+", "+\t\t// find & report collision cases", "+\t\tfor (int i = 0, length = methods.length; i < length; i++) {", "+\t\t\tMethodBinding method = methods[i];", "-\t\t\t\tfor (int i = 0; i < m; i++) {", "-\t\t\t\t\tMethodBinding method2 = methods[i];", "+\t\t\t\tfor (int j = length - 1; j > i; j--) {", "+\t\t\t\t\tMethodBinding method2 = methods[j];", "-\t\t\t\t\t\tif (method.areParametersEqual(method2)) {", "+\t\t\t\t\t\tif (method.areParameterErasuresEqual(method2)) {", "-\t\t\t\t\t\t\t\tmethods[m] = null;", "+\t\t\t\t\t\t\t\tmethods[i] = null;", "-\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, method2.sourceMethod());", "-\t\t\t\t\t\t\tmethod2.sourceMethod().binding = null;", "-\t\t\t\t\t\t\tmethods[i] = null;", "+\t\t\t\t\t\t\tAbstractMethodDeclaration method2Decl = method2.sourceMethod();", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, method2Decl);", "+\t\t\t\t\t\t\tmethod2Decl.binding = null;", "+\t\t\t\t\t\t\tmethods[j] = null;", "-\t\t\t\t\tmethods[m] = null;", "+\t\t\t\t\tmethods[i] = null;", "-\t", "+\t} finally {", "-\t\t\t\tfor (int m = 0, n = 0, max = methods.length; m < max; m++)", "-\t\t\t\t\tif (methods[m] != null)", "-\t\t\t\t\t\tnewMethods[n++] = methods[m];", "+\t\t\t\tfor (int i = 0, j = 0, length = methods.length; i < length; i++)", "+\t\t\t\t\tif (methods[i] != null)", "+\t\t\t\t\t\tnewMethods[j++] = methods[i];", "-\t", "+", "-\t} catch(AbortCompilation e){", "-\t\t// ensure null methods are removed", "-\t\tMethodBinding[] newMethods = null;", "-\t\tint count = 0;", "-\t\tfor (int i = 0, max = methods.length; i < max; i++){", "-\t\t\tMethodBinding method = methods[i];", "-\t\t\tif (method == null && newMethods == null){", "-\t\t\t\tSystem.arraycopy(methods, 0, newMethods = new MethodBinding[max], 0, i);", "-\t\t\t} else if (newMethods != null && method != null) {", "-\t\t\t\tnewMethods[count++] = method;", "-\t\t\t}", "-\t\t}", "-\t\tif (newMethods != null){", "-\t\t\tSystem.arraycopy(newMethods, 0, methods = new MethodBinding[count], 0, count);", "-\t\t}\t\t\t", "+", "-\t\tthrow e;", "-\tmodifiers ^= AccUnresolved;"]}], "num": 5020}