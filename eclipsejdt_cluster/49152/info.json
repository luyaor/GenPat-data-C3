{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "edb0ae79f83166c376ccbb1dc310628c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eeed94e88fed16a677ebc3d5f149a359", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "e31e89499c545f3404d7787f4d333516631375ec", "commitAfterChange": "0eef8a719c726a9948e73db62c7f81adbce0f319", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public TypeBinding clone(TypeBinding outerType)", "signatureAfterChange": "  public TypeBinding clone(TypeBinding outerType)", "diff": ["-\t", "-\tif (outerType instanceof UnresolvedReferenceBinding)", "-\t\tcopy.tagBits |= TagBits.HasUnresolvedEnclosingType;", "-\telse ", "-\t\tcopy.tagBits &= ~TagBits.HasUnresolvedEnclosingType;", "-\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f953f50210128afc7cba45e82702a7c7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "72398fb1bfc9de8f8d1c235c08849e28d61cb9f4", "commitAfterChange": "a52f17f8883dd812875c341ff752527a9011d961", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "signatureAfterChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "diff": ["-\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "-\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "-\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "-\t\ttry {", "-\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "-\t\t\t// Do not proceed with data/control flow analysis if resolve encountered errors.", "-\t\t\tif (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {", "-\t\t\t\t// value compatibility of block lambda's is the only open question.", "-\t\t\t\tcopy.valueCompatible |= copy.doesNotCompleteNormally();", "-\t\t\t} else {", "-\t\t\t\tif (!copy.returnsVoid)", "-\t\t\t\t\tcopy.valueCompatible = true; // optimistically, TODO: is this OK??", "+\t\t", "+\t\t/* copy is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and ", "+\t\t   result expressions have been gathered. Proceed with flow analysis to gather precise thrown exceptions. However, we can do this only", "+\t\t   if resolve encountered no errors - if it did, we will miss precise exceptions, but that is OK.", "+\t\t*/", "+\t\tif (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {", "+\t\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "+\t\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "+\t\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "+\t\t\ttry {", "+\t\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "+\t\t\t\tcopy.analyzeExceptions();", "+\t\t\t} finally {", "+\t\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;", "+\t\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t\t} finally {", "-\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;", "-\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);"]}], "num": 49152}