{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2fade9579aa567008f6a487d563117fd", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "29107feef4fa7d7ea09e83a26abb145f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java", "commitBeforeChange": "d1246b4aff159c8bec10d39c7616aa371724fb25", "commitAfterChange": "3aaa02433bee6eae022db09efeb9fd0aba7da6a0", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tprivate TextEdit formatComments(String source, int kind, IRegion[] regions)", "signatureAfterChange": " \tprivate TextEdit formatComment(int kind, String source, int indentationLevel, String lineSeparator, IRegion[] regions)", "diff": ["-", "-\tprivate TextEdit formatComments(String source, int kind, IRegion[] regions) {", "-\t\tMultiTextEdit result = new MultiTextEdit();", "-\t\tif (!init(source))", "-\t\t\treturn result;", "-", "-\t\tCommentsPreparator commentsPreparator = new CommentsPreparator(this.tokenManager, this.workingOptions,", "-\t\t\t\tthis.sourceLevel);", "-\t\tCommentWrapExecutor commentWrapper = new CommentWrapExecutor(this.tokenManager, this.workingOptions);", "-\t\tswitch (kind) {", "-\t\t\tcase K_JAVA_DOC:", "-\t\t\t\tASTParser parser = ASTParser.newParser(AST.JLS8);", "-\t\t\t\tfor (Token token : this.tokens) {", "-\t\t\t\t\tif (token.tokenType == TokenNameCOMMENT_JAVADOC) {", "-\t\t\t\t\t\tparser.setSourceRange(token.originalStart, token.countChars());", "-\t\t\t\t\t\tCompilationUnit cu = (CompilationUnit) parseSourceCode(parser, ASTParser.K_COMPILATION_UNIT,", "-\t\t\t\t\t\t\t\ttrue);", "-\t\t\t\t\t\tJavadoc javadoc = (Javadoc) cu.getCommentList().get(0);", "-\t\t\t\t\t\tjavadoc.accept(commentsPreparator);", "-\t\t\t\t\t\tint startPosition = this.tokenManager.findSourcePositionInLine(token.originalStart);", "-\t\t\t\t\t\tcommentWrapper.wrapMultiLineComment(token, startPosition, false, false);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase K_MULTI_LINE_COMMENT:", "-\t\t\t\tfor (int i = 0; i < this.tokens.size(); i++) {", "-\t\t\t\t\tToken token = this.tokens.get(i);", "-\t\t\t\t\tif (token.tokenType == TokenNameCOMMENT_BLOCK) {", "-\t\t\t\t\t\tcommentsPreparator.handleBlockComment(i);", "-\t\t\t\t\t\tint startPosition = this.tokenManager.findSourcePositionInLine(token.originalStart);", "-\t\t\t\t\t\tcommentWrapper.wrapMultiLineComment(token, startPosition, false, false);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase K_SINGLE_LINE_COMMENT:", "-\t\t\t\tfor (int i = 0; i < this.tokens.size(); i++) {", "-\t\t\t\t\tToken token = this.tokens.get(i);", "-\t\t\t\t\tif (token.tokenType == TokenNameCOMMENT_LINE) {", "-\t\t\t\t\t\tcommentsPreparator.handleLineComment(i);", "-\t\t\t\t\t\tif (i >= this.tokens.size() || this.tokens.get(i) != token) {", "-\t\t\t\t\t\t\t// current token has been removed and merged with previous one", "-\t\t\t\t\t\t\ti--;", "-\t\t\t\t\t\t\ttoken = this.tokens.get(i);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tint startPosition = this.tokenManager.findSourcePositionInLine(token.originalStart);", "-\t\t\t\t\t\tcommentWrapper.wrapLineComment(token, startPosition);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tdefault:", "-\t\t\t\tthrow new AssertionError(String.valueOf(kind));", "-\t\t}", "-", "-\t\tthis.tokenManager.applyFormatOff();", "-", "-\t\tTextEditsBuilder resultBuilder = new TextEditsBuilder(source, regions, this.tokenManager, this.workingOptions);", "-\t\tresultBuilder.setAlignChar(DefaultCodeFormatterOptions.SPACE);", "-\t\tfor (Token token : this.tokens) {", "-\t\t\tList<Token> structure = token.getInternalStructure();", "-\t\t\tif (structure != null && !structure.isEmpty())", "-\t\t\t\tresultBuilder.processComment(token);", "-\t\t}", "-", "-\t\tfor (TextEdit edit : resultBuilder.getEdits()) {", "-\t\t\tresult.addChild(edit);", "-\t\t}", "-\t\treturn result;", "-\t}", "+\t */", "+\tprivate TextEdit formatComment(int kind, String source, int indentationLevel, String lineSeparator, IRegion[] regions) {", "+\t\tObject oldOption = oldCommentFormatOption();", "+\t\tboolean isFormattingComments = false;", "+\t\tif (oldOption == null) {", "+\t\t\tswitch (kind & K_MASK) {", "+\t\t\t\tcase K_SINGLE_LINE_COMMENT:", "+\t\t\t\t\tisFormattingComments = DefaultCodeFormatterConstants.TRUE.equals(this.options.get(DefaultCodeFormatterConstants.FORMATTER_COMMENT_FORMAT_LINE_COMMENT));", "+\t\t\t\tcase K_MULTI_LINE_COMMENT:", "+\t\t\t\t\tisFormattingComments = DefaultCodeFormatterConstants.TRUE.equals(this.options.get(DefaultCodeFormatterConstants.FORMATTER_COMMENT_FORMAT_BLOCK_COMMENT));", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase K_JAVA_DOC:", "+\t\t\t\t\tisFormattingComments = DefaultCodeFormatterConstants.TRUE.equals(this.options.get(DefaultCodeFormatterConstants.FORMATTER_COMMENT_FORMAT_JAVADOC_COMMENT));", "+\t\t} else {", "+\t\t\tisFormattingComments = DefaultCodeFormatterConstants.TRUE.equals(oldOption);", "+\t\t}", "+\t\tif (isFormattingComments) {", "+\t\t\tif (lineSeparator != null) {", "+\t\t\t\tthis.preferences.line_separator = lineSeparator;", "+\t\t\t} else {", "+\t\t\t\tthis.preferences.line_separator = Util.LINE_SEPARATOR;", "+\t\t\t}", "+\t\t\tthis.preferences.initial_indentation_level = indentationLevel;", "+\t\t\tif (this.codeSnippetParsingUtil == null) this.codeSnippetParsingUtil = new CodeSnippetParsingUtil();", "+\t\t\tthis.codeSnippetParsingUtil.parseCompilationUnit(source.toCharArray(), this.defaultCompilerOptions, true);", "+\t\t\tthis.newCodeFormatter = new CodeFormatterVisitor(this.preferences, this.options, regions, this.codeSnippetParsingUtil, true);", "+\t\t\tIRegion coveredRegion = getCoveredRegion(regions);", "+\t\t\tint start = coveredRegion.getOffset();", "+\t\t\tint end = start + coveredRegion.getLength();", "+\t\t\tthis.newCodeFormatter.formatComment(kind, source, start, end, indentationLevel);", "+\t\t\treturn this.newCodeFormatter.scribe.getRootEdit();", "+\t\t}", "+\t\treturn null;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "867e6a26196ca9f486466b755e11f1fc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java", "commitBeforeChange": "32aae0cf1b9f94fe336a2b34d2b2b110c5363f4a", "commitAfterChange": "7fa614421be752542e93fc8394ff005421401e06", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": "  public void resolve(IGenericType[] suppliedTypes, org.eclipse.jdt.core.ICompilationUnit[] closedCUs, HashSet localTypes, IProgressMonitor monitor)", "signatureAfterChange": "  public void resolve(Openable[] openables, HashSet localTypes, IProgressMonitor monitor)", "diff": ["-public void resolve(IGenericType[] suppliedTypes, org.eclipse.jdt.core.ICompilationUnit[] closedCUs, HashSet localTypes, IProgressMonitor monitor) {", "+public void resolve(Openable[] openables, HashSet localTypes, IProgressMonitor monitor) {", "-\t\tint suppliedLength = suppliedTypes == null ? 0 : suppliedTypes.length;", "-\t\tint sourceLength = closedCUs == null ? 0 : closedCUs.length;", "-\t\tCompilationUnitDeclaration[] units = new CompilationUnitDeclaration[suppliedLength + sourceLength];", "-\t\tboolean[] hasLocalType = new boolean[suppliedLength + sourceLength];", "-\t\t", "-\t\t// cache binary type bidings", "-\t\tBinaryTypeBinding[] binaryBindings = new BinaryTypeBinding[suppliedLength];", "-\t\tfor (int i = 0; i < suppliedLength; i++) {", "-\t\t\tif (suppliedTypes[i].isBinaryType()) {", "-\t\t\t\tIBinaryType binaryType = (IBinaryType) suppliedTypes[i];", "-\t\t\t\ttry {", "-\t\t\t\t\tbinaryBindings[i] = this.lookupEnvironment.cacheBinaryType(binaryType, false);", "-\t\t\t\t} catch (AbortCompilation e) {", "-\t\t\t\t\t// classpath problem for this type: ignore", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "+\t\tint openablesLength = openables.length;", "+\t\tCompilationUnitDeclaration[] parsedUnits = new CompilationUnitDeclaration[openablesLength];", "+\t\tboolean[] hasLocalType = new boolean[openablesLength];", "+\t\torg.eclipse.jdt.core.ICompilationUnit[] cus = new org.eclipse.jdt.core.ICompilationUnit[openablesLength];", "+\t\tint unitsIndex = 0;", "-\t\tfor (int i = 0; i < suppliedLength; i++) {", "-\t\t\tif (suppliedTypes[i].isBinaryType()) {", "-\t\t\t\tif (binaryBindings[i] != null) {", "+\t\tParser parser = new Parser(this.lookupEnvironment.problemReporter, true);", "+\t\tfor (int i = 0; i < openablesLength; i++) {", "+\t\t\tOpenable openable = openables[i];", "+\t\t\tif (openable instanceof org.eclipse.jdt.core.ICompilationUnit) {", "+\t\t\t\torg.eclipse.jdt.core.ICompilationUnit cu = (org.eclipse.jdt.core.ICompilationUnit)openable;", "+", "+\t\t\t\t// contains a potential subtype as a local or anonymous type?", "+\t\t\t\tboolean containsLocalType = false;", "+\t\t\t\tif (localTypes == null) { // case of hierarchy on region", "+\t\t\t\t\tcontainsLocalType = false;", "+\t\t\t\t} else {", "+\t\t\t\t\tIPath path = cu.getPath();", "+\t\t\t\t\tcontainsLocalType = localTypes.contains(path.toString());", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// build parsed unit", "+\t\t\t\tCompilationUnitDeclaration parsedUnit = null;", "+\t\t\t\tif (cu.isOpen()) {", "+\t\t\t\t\t// create parsed unit from source element infos", "+\t\t\t\t\tCompilationResult result = new CompilationResult(((ICompilationUnit)cu).getFileName(), i, openablesLength, this.options.maxProblemsPerUnit);", "+\t\t\t\t\tSourceTypeElementInfo[] typeInfos = null;", "-\t\t\t\t\t\tremember(suppliedTypes[i], binaryBindings[i]);", "+\t\t\t\t\t\tIType[] topLevelTypes = cu.getTypes();", "+\t\t\t\t\t\tint topLevelLength = topLevelTypes.length;", "+\t\t\t\t\t\ttypeInfos = new SourceTypeElementInfo[topLevelLength];", "+\t\t\t\t\t\tfor (int j = 0; j < topLevelLength; j++) {", "+\t\t\t\t\t\t\tIType topLevelType = topLevelTypes[j];", "+\t\t\t\t\t\t\ttypeInfos[j] = (SourceTypeElementInfo)((JavaElement)topLevelType).getElementInfo();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t// types/cu exist since cu is opened", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!containsLocalType) {", "+\t\t\t\t\t\tparsedUnit = ", "+\t\t\t\t\t\t\tSourceTypeConverter.buildCompilationUnit(", "+\t\t\t\t\t\t\t\ttypeInfos, ", "+\t\t\t\t\t\t\t\ttrue, // need for field and methods // TODO (jerome) need fields and methods only for supertypes of local types", "+\t\t\t\t\t\t\t\ttrue, // need member types", "+\t\t\t\t\t\t\t\tfalse, // no need for field initialization", "+\t\t\t\t\t\t\t\tthis.lookupEnvironment.problemReporter, ", "+\t\t\t\t\t\t\t\tresult);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tparsedUnit =", "+\t\t\t\t\t\t\tElementInfoConverter.buildCompilationUnit(", "+\t\t\t\t\t\t\t\ttypeInfos, ", "+\t\t\t\t\t\t\t\ttrue, // need local types", "+\t\t\t\t\t\t\t\tthis.lookupEnvironment.problemReporter, ", "+\t\t\t\t\t\t\t\tresult);", "+\t\t\t\t\t\tparsedUnit.bits |= AstNode.HasAllMethodBodies;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t// create parsed unit from file", "+\t\t\t\t\tIResource file = cu.getResource();", "+\t\t\t\t\tString osPath = file.getLocation().toOSString();", "+\t\t\t\t\tICompilationUnit sourceUnit = this.requestor.createCompilationUnitFromPath(openable, osPath);", "+\t\t\t\t\t", "+\t\t\t\t\tCompilationResult unitResult = new CompilationResult(sourceUnit, i, openablesLength, this.options.maxProblemsPerUnit); ", "+\t\t\t\t\tparsedUnit = parser.dietParse(sourceUnit, unitResult);", "+\t\t\t\t}", "+", "+\t\t\t\tif (parsedUnit != null) {", "+\t\t\t\t\thasLocalType[unitsIndex] = containsLocalType;", "+\t\t\t\t\tcus[unitsIndex] = cu;", "+\t\t\t\t\tparsedUnits[unitsIndex++] = parsedUnit;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tthis.lookupEnvironment.buildTypeBindings(parsedUnit);", "-\t\t\t\t// must start with the top level type", "-\t\t\t\tISourceType topLevelType = (ISourceType) suppliedTypes[i];", "-\t\t\t\twhile (topLevelType.getEnclosingType() != null)", "-\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();", "-\t\t\t\t", "-\t\t\t\t// contains a potential subtype as a local or anonymous type?", "-\t\t\t\tboolean containsLocalType = false;", "-\t\t\t\tif (localTypes == null) { // case of hierarchy on region", "-\t\t\t\t\tcontainsLocalType = false;", "-\t\t\t\t} else if (topLevelType instanceof SourceTypeElementInfo) {", "-\t\t\t\t\tIPath path = ((SourceTypeElementInfo)topLevelType).getHandle().getPath();", "-\t\t\t\t\tcontainsLocalType = localTypes.contains(path.toString());", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\tCompilationResult result = new CompilationResult(topLevelType.getFileName(), i, suppliedLength, this.options.maxProblemsPerUnit);", "-\t\t\t\tif (!containsLocalType) {", "-\t\t\t\t\tunits[i] = ", "-\t\t\t\t\t\tSourceTypeConverter.buildCompilationUnit(", "-\t\t\t\t\t\t\tnew ISourceType[]{topLevelType}, ", "-\t\t\t\t\t\t\ttrue, // need for field and methods // TODO (jerome) need fields and methods only for supertypes of local types", "-\t\t\t\t\t\t\ttrue, // need member types", "-\t\t\t\t\t\t\tfalse, // no need for field initialization", "-\t\t\t\t\t\t\tthis.lookupEnvironment.problemReporter, ", "-\t\t\t\t\t\t\tresult);", "-\t\t\t\t} else {", "-\t\t\t\t\tunits[i] =", "-\t\t\t\t\t\tElementInfoConverter.buildCompilationUnit(", "-\t\t\t\t\t\t\tnew SourceTypeElementInfo[]{(SourceTypeElementInfo)topLevelType}, ", "-\t\t\t\t\t\t\ttrue, // need local types", "-\t\t\t\t\t\t\tthis.lookupEnvironment.problemReporter, ", "-\t\t\t\t\t\t\tresult);", "-\t\t\t\t\tunits[i].bits |= AstNode.HasAllMethodBodies;", "-\t\t\t\t\thasLocalType[i] = true;", "-\t\t\t\t}", "-\t\t\t\tif (units[i] != null) {", "+\t\t\t\t// cache binary type binding", "+\t\t\t\tClassFile classFile = (ClassFile)openable;", "+\t\t\t\tIBinaryType binaryType = null;", "+\t\t\t\tif (classFile.isOpen()) {", "+\t\t\t\t\t// create binary type from info", "+\t\t\t\t\tIType type = classFile.getType();", "-\t\t\t\t\t\tthis.lookupEnvironment.buildTypeBindings(units[i]);", "+\t\t\t\t\t\tbinaryType = (IBinaryType)((JavaElement)type).getElementInfo();", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t// type exists since class file is opened", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t// create binary type from file", "+\t\t\t\t\tif (classFile.getPackageFragmentRoot().isArchive()) {", "+\t\t\t\t\t\tbinaryType = this.requestor.createInfoFromClassFileInJar(classFile);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tIResource file = classFile.getResource();", "+\t\t\t\t\t\tString osPath = file.getLocation().toOSString();", "+\t\t\t\t\t\tbinaryType = this.requestor.createInfoFromClassFile(classFile, osPath);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (binaryType != null) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tBinaryTypeBinding binaryTypeBinding = this.lookupEnvironment.cacheBinaryType(binaryType, false);", "+\t\t\t\t\t\tremember(binaryType, binaryTypeBinding);", "-\t\t\tworked(monitor, 1);", "-\t\tParser parser = new Parser(this.lookupEnvironment.problemReporter, true);", "-\t\tfor (int i = 0; i < sourceLength; i++){", "-\t\t\torg.eclipse.jdt.core.ICompilationUnit closedCU = closedCUs[i];", "-\t\t\tIResource file = closedCU.getResource();", "-\t\t\tString osPath = file.getLocation().toOSString();", "-\t\t\tICompilationUnit sourceUnit = this.requestor.createCompilationUnitFromPath((Openable)closedCU, osPath);", "-\t\t\t", "-\t\t\tCompilationResult unitResult = new CompilationResult(sourceUnit, suppliedLength+i, suppliedLength+sourceLength, this.options.maxProblemsPerUnit); ", "-\t\t\tCompilationUnitDeclaration parsedUnit = parser.dietParse(sourceUnit, unitResult);", "-\t\t\tif (parsedUnit != null) {", "-\t\t\t\tunits[suppliedLength+i] = parsedUnit;", "-", "-\t\t\t\t// contains a potential subtype as a local or anonymous type?", "-\t\t\t\tif (localTypes == null) { // case of hierarchy on region", "-\t\t\t\t\thasLocalType[suppliedLength+i] = false;", "-\t\t\t\t} else {", "-\t\t\t\t\tIPath path = file.getFullPath();", "-\t\t\t\t\thasLocalType[suppliedLength+i] = localTypes.contains(path.toString());", "-\t\t\t\t}", "-\t\t\t", "-\t\t\t\tthis.lookupEnvironment.buildTypeBindings(parsedUnit);", "-\t\t\t}", "-\t\t\tworked(monitor, 1);", "-\t\t}", "+\t\t\t\t", "-\t\tfor (int i = 0; i < suppliedLength; i++) {", "-\t\t\tif (!suppliedTypes[i].isBinaryType()) { // note that binary types have already been remembered above", "-\t\t\t\tCompilationUnitDeclaration parsedUnit = units[i];", "-\t\t\t\tif (parsedUnit != null) {", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\t// NB: No need to get method bodies as they were already computed", "-\t\t\t\t\t\tthis.lookupEnvironment.completeTypeBindings(parsedUnit, true); // TODO (jerome) build fields and methods only for super types of local types", "-\t\t\t\t\t} catch (AbortCompilation e) {", "-\t\t\t\t\t\t// classpath problem for this type: ignore", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tworked(monitor, 1);", "-\t\t}", "-\t\tfor (int i = 0; i < sourceLength; i++) {", "-\t\t\tCompilationUnitDeclaration parsedUnit = units[suppliedLength+i];", "+\t\tfor (int i = 0; i < unitsIndex; i++) {", "+\t\t\tCompilationUnitDeclaration parsedUnit = parsedUnits[i];", "-\t\t\t\t\tboolean localType = hasLocalType[suppliedLength+i];", "-\t\t\t\t\tif (localType) {", "+\t\t\t\t\tboolean containsLocalType = hasLocalType[i];", "+\t\t\t\t\tif (containsLocalType) { // NB: no-op if method bodies have been already parsed", "-\t\tfor (int i = 0; i < suppliedLength; i++) {", "-\t\t\tif (!suppliedTypes[i].isBinaryType()) { // note that binary types have already been remembered above", "-\t\t\t\tCompilationUnitDeclaration parsedUnit = units[i];", "-\t\t\t\tif (parsedUnit != null) {", "-\t\t\t\t\tboolean localType = hasLocalType[i];", "-\t\t\t\t\tif (localType) {", "-\t\t\t\t\t\tparsedUnit.scope.faultInTypes();", "-\t\t\t\t\t\tparsedUnit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());", "-\t\t\t\t\t\tparsedUnit.resolve();", "-\t\t\t\t\t}", "-\t\t\t\t\t\t", "-\t\t\t\t\t// must start with the top level type", "-\t\t\t\t\tISourceType topLevelType = (ISourceType) suppliedTypes[i];", "-\t\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\t\t\t\t", "-\t\t\t\t\twhile (topLevelType.getEnclosingType() != null) {", "-\t\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();", "-\t\t\t\t\t}", "-\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit cu = ((SourceTypeElementInfo)topLevelType).getHandle().getCompilationUnit();", "-\t\t\t\t\trememberAllTypes(parsedUnit, cu, localType);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tfor (int i = 0; i < sourceLength; i++) {", "-\t\t\tCompilationUnitDeclaration parsedUnit = units[suppliedLength+i];", "+\t\tfor (int i = 0; i < unitsIndex; i++) {", "+\t\t\tCompilationUnitDeclaration parsedUnit = parsedUnits[i];", "-\t\t\t\tboolean localType = hasLocalType[suppliedLength+i];", "-\t\t\t\tif (localType) {", "+\t\t\t\tboolean containsLocalType = hasLocalType[i];", "+\t\t\t\tif (containsLocalType) {", "-\t\t\t\t", "-\t\t\t\trememberAllTypes(parsedUnit, closedCUs[i], localType);", "+\t\t\t\t\t", "+\t\t\t\trememberAllTypes(parsedUnit, cus[i], containsLocalType);"]}], "num": 2047}