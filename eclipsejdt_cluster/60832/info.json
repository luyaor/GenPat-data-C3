{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7fc1c396db2ab9c606bde992e0dbe161", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09181282d9cf76fc940685674c8159b6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeReferencePattern.java", "commitBeforeChange": "7dce3ced6f2c34a63721a3fda038e2fad50139b7", "commitAfterChange": "4a258c24dea43b906f3daa4041c94e7315633dfe", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public static char[] createReference( \tint modifiers, \tchar[] packageName, \tchar[] typeName, \tchar[][] enclosingTypeNames, \tchar classOrInterface, \tchar[] superTypeName, \tchar superClassOrInterface)", "signatureAfterChange": " public static SuperTypeReferencePattern getSuperTypeReferenceRecord()", "diff": ["-public static char[] createReference(", "-\tchar[] enclosingTypeName = CharOperation.concatWith(enclosingTypeNames, '$');", "-\tchar[] typeSimpleName = CharOperation.lastSegment(typeName, '.');", "-\tchar[] superTypeSimpleName = CharOperation.lastSegment(superTypeName, '.');", "-\tchar[] superQualification = null;", "-\tif (superTypeSimpleName != superTypeName) {", "-\t\tint length = superTypeName.length - superTypeSimpleName.length - 1;", "-\t\tsuperQualification = new char[length];", "-\t\tSystem.arraycopy(superTypeName, 0, superQualification, 0, length);", "-\tchar[] superTypeSourceName = CharOperation.lastSegment(superTypeSimpleName, '$');", "-\tif (superTypeSourceName != superTypeSimpleName) {", "-\t\tint start = superQualification == null ? 0 : superQualification.length + 1;", "-\t\tint prefixLength = superTypeSimpleName.length - superTypeSourceName.length;", "-\t\tif (superQualification != null) {", "-\t\t\tSystem.arraycopy(superQualification, 0, mangledQualification, 0, start-1);", "-\t\tSystem.arraycopy(superTypeSimpleName, 0, mangledQualification, start, prefixLength);", "-\t\tsuperQualification = mangledQualification;", "-\t\tsuperTypeSimpleName = superTypeSourceName;", "-", "-\tint superTypeSimpleNameLength = superTypeSimpleName == null ? 0 : superTypeSimpleName.length;", "-\tint superQualificationLength = superQualification == null ? 0 : superQualification.length;", "-\tint typeSimpleNameLength = typeSimpleName == null ? 0 : typeSimpleName.length;", "-\tint enclosingTypeNameLength = enclosingTypeName == null ? 0 : enclosingTypeName.length;", "-\tint packageNameLength = packageName == null ? 0 : packageName.length;", "-\tint pos = SUPER_REF.length;", "-", "-\t// SUPER_REF superTypeSimpleName / superQualification / superClassOrInterface /  typeSimpleName / enclosingTypeName / packageName / classOrInterface modifiers", "-\tchar[] result = new char[pos + superTypeSimpleNameLength + superQualificationLength + typeSimpleNameLength", "-\t\t+ enclosingTypeNameLength + packageNameLength + 9];", "-\tSystem.arraycopy(SUPER_REF, 0, result, 0, pos);", "-\tif (superTypeSimpleNameLength > 0) {", "-\t\tSystem.arraycopy(superTypeSimpleName, 0, result, pos, superTypeSimpleNameLength);", "-\t\tpos += superTypeSimpleNameLength;", "-\t}", "-\tresult[pos++] = SEPARATOR;", "-\tif (superQualificationLength > 0) {", "-\t\tSystem.arraycopy(superQualification, 0, result, pos, superQualificationLength);", "-\t\tpos += superQualificationLength;", "-\t}", "-\tresult[pos++] = SEPARATOR;", "-\tresult[pos++] = superClassOrInterface;", "-\tresult[pos++] = SEPARATOR;", "-\tif (typeSimpleNameLength > 0) {", "-\t\tSystem.arraycopy(typeSimpleName, 0, result, pos, typeSimpleNameLength);", "-\t\tpos += typeSimpleNameLength;", "-\t}", "-\tresult[pos++] = SEPARATOR;", "-\tif (enclosingTypeNameLength > 0) {", "-\t\tSystem.arraycopy(enclosingTypeName, 0, result, pos, enclosingTypeNameLength);", "-\t\tpos += enclosingTypeNameLength;", "-\t}", "-\tresult[pos++] = SEPARATOR;", "-\tif (packageNameLength > 0) {", "-\t\tSystem.arraycopy(packageName, 0, result, pos, packageNameLength);", "-\t\tpos += packageNameLength;", "-\t}", "-\tresult[pos++] = SEPARATOR;", "-\tresult[pos++] = classOrInterface;", "-\tresult[pos] = (char) modifiers;", "-\treturn result;", "+public static SuperTypeReferencePattern getSuperTypeReferenceRecord() {", "+\treturn (SuperTypeReferencePattern)indexRecord.get();", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "23bb42998f8d2d932bd57362196ad54b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodDeclarationPattern.java", "commitBeforeChange": "ae317766273ccd74fe0e1bfd1f3ccc3925356a13", "commitAfterChange": "3fc8f68d913a6f6e40f71f3d7dea34c1f2893e07", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static char[] createDeclarationIndexKey( \t\t\tchar[] typeName, \t\t\tchar[] declaringQualification, \t\t\tchar[] methodName, \t\t\tint argCount, \t\t\tchar[] signature, \t\t\tchar[][] parameterTypes, \t\t\tchar[][] parameterNames, \t\t\tchar[] returnType, \t\t\tint modifiers, \t\t\tchar[] packageName, \t\t\tint typeModifiers, \t\t\tint extraFlags)", "signatureAfterChange": " \tpublic static char[] createDeclarationIndexKey( \t\t\tchar[] typeName, \t\t\tchar[] declaringQualification, \t\t\tchar[] methodName, \t\t\tint argCount, \t\t\tchar[] signature, \t\t\tchar[][] parameterTypes, \t\t\tchar[][] parameterNames, \t\t\tchar[] returnType, \t\t\tint modifiers, \t\t\tchar[] packageName, \t\t\tint typeModifiers, \t\t\tint extraFlags)", "diff": ["-\t\tcountChars = argCount < 10 ? COUNTS[argCount]: (\"/\" + String.valueOf(argCount)).toCharArray(); //$NON-NLS-1$", "+\t\tcountChars = argCount < 10 ? new char[] {COUNTS[argCount][1]}:  String.valueOf(argCount).toCharArray(); ", "-\t\t\t", "-\t\tchar[] returnTypeChars = returnType == null ? CharOperation.NO_CHAR : getTypeErasure(returnType);", "-\t\t", "-\t\t", "-\t\tint typeNameLength = typeName == null ? 0 : typeName.length;", "-\t\tint qualifierLength = declaringQualification == null ? 0 : declaringQualification.length;", "-\t\tint methodNameLength = methodName == null ? 0 : methodName.length;", "-\t\tint packageNameLength = packageName == null ? 0 : packageName.length;", "-\t\tint countCharsLength = countChars.length;", "-\t\tint parameterTypesLength = signature == null ? (parameterTypesChars == null ? 0 : parameterTypesChars.length): signature.length;", "-\t\tint parameterNamesLength = parameterNamesChars == null ? 0 : parameterNamesChars.length;", "-\t\tint returnTypeLength = returnTypeChars.length;", "-\t\t", "-\t\tint resultLength = methodNameLength + countCharsLength + qualifierLength + typeNameLength + 2 /* type modifiers */", "-\t\t\t\t+ packageNameLength + parameterTypesLength + parameterNamesLength + returnTypeLength + 2 /* modifiers*/ + 9; // SEPARATOR = 9", "-\t\tchar[] result = new char[resultLength];", "-\t\t", "-\t\tint pos = 0;", "-\t\tif (methodNameLength > 0) {", "-\t\t\tSystem.arraycopy(methodName, 0, result, pos, methodNameLength);", "-\t\t\tpos += methodNameLength;", "-\t\t}", "-\t\tif (countCharsLength > 0) {", "-\t\t\tSystem.arraycopy(countChars, 0, result, pos, countCharsLength);", "-\t\t\tpos += countCharsLength;", "-\t\t}", "-\t\tresult[pos++] = SEPARATOR;", "-\t\tif (qualifierLength > 0) {", "-\t\t\tSystem.arraycopy(declaringQualification, 0, result, pos, qualifierLength);", "-\t\t\tpos += qualifierLength;", "-\t\t}", "-\t\tresult[pos++] = SEPARATOR;", "-", "-\t\tif (typeNameLength > 0) {", "-\t\t\tSystem.arraycopy(typeName, 0, result, pos, typeNameLength);", "-\t\t\tpos += typeNameLength;", "-\t\t}", "-", "-\t\t", "+\t\tchar[] returnTypeChars = returnType == null ? CharOperation.NO_CHAR : getTypeErasure(returnType);\t\t", "-\t\tresult[pos++] = SEPARATOR;", "-\t\tresult[pos++] = (char) typeModifiersWithExtraFlags;", "-\t\tresult[pos++] = (char) (typeModifiersWithExtraFlags>>16);", "+\t\tint entryIndex = 0;", "+\t\tint numEntries = 10;", "+\t\tchar [][] tmp = new char[numEntries][];", "-\t\tresult[pos++] = SEPARATOR;", "-\t\tif (packageNameLength > 0) {", "-\t\t\tSystem.arraycopy(packageName, 0, result, pos, packageNameLength);", "-\t\t\tpos += packageNameLength;", "-\t\t}", "+\t\ttmp[entryIndex++] = methodName != null ? methodName : CharOperation.NO_CHAR;", "+\t\ttmp[entryIndex++] = countChars;", "+\t\ttmp[entryIndex++] = declaringQualification != null ? declaringQualification : CharOperation.NO_CHAR;", "+\t\ttmp[entryIndex++] = typeName != null ? typeName : CharOperation.NO_CHAR;", "+\t\ttmp[entryIndex++] = new char[] {(char) typeModifiersWithExtraFlags, (char) (typeModifiersWithExtraFlags>>16)};", "+\t\ttmp[entryIndex++] = packageName != null ? packageName : CharOperation.NO_CHAR;", "-\t\t\tresult[pos++] = SEPARATOR;", "-\t\t\tresult[pos++] = SEPARATOR;", "-\t\t\tresult[pos++] = SEPARATOR;", "+\t\t\ttmp[entryIndex++] = CharOperation.NO_CHAR;", "+\t\t\ttmp[entryIndex++] = CharOperation.NO_CHAR;", "-\t\t\tresult[pos++] = SEPARATOR;", "-\t\t\tif (parameterTypesLength > 0) {", "-\t\t\t\tif (signature == null) {", "-\t\t\t\t\tSystem.arraycopy(parameterTypesChars, 0, result, pos, parameterTypesLength);", "-\t\t\t\t} else {", "-\t\t\t\t\tSystem.arraycopy(CharOperation.replaceOnCopy(signature, SEPARATOR, '\\\\'), 0, result, pos, parameterTypesLength);", "-\t\t\t\t}", "-\t\t\t\tpos += parameterTypesLength;", "-\t\t\t}", "-\t\t\t", "-\t\t\tresult[pos++] = SEPARATOR;", "-\t\t\tif (parameterNamesLength > 0) {", "-\t\t\t\tSystem.arraycopy(parameterNamesChars, 0, result, pos, parameterNamesLength);", "-\t\t\t\tpos += parameterNamesLength;", "-\t\t\t}", "-\t\t\t", "-\t\t\tresult[pos++] = SEPARATOR;", "+\t\t\ttmp[entryIndex++] = signature != null ? CharOperation.replaceOnCopy(signature, SEPARATOR, '\\\\') : parameterTypesChars != null ? parameterTypesChars  : CharOperation.NO_CHAR;", "+\t\t\ttmp[entryIndex++] = parameterNamesChars != null ? parameterNamesChars : CharOperation.NO_CHAR;", "-\t\tresult[pos++] = (char) modifiers;", "-\t\tresult[pos++] = (char) (modifiers>>16);", "-\t\tresult[pos++] = SEPARATOR;", "-", "-\t\tif (returnTypeLength > 0) {", "-\t\t\tSystem.arraycopy(returnTypeChars, 0, result, pos, returnTypeLength);", "-\t\t\tpos += returnTypeLength;", "-\t\t}", "-\t\tresult[pos++] = SEPARATOR;", "-\t\treturn result;", "+\t\ttmp[entryIndex++] = new char[] {(char) modifiers, (char) (modifiers>>16)};", "+\t\ttmp[entryIndex] = returnTypeChars;", "+\t\treturn CharOperation.concatWithAll(tmp, '/');"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66173712a6ad83564b1af0d9ba01522b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "4977ef90a9cbab898d33f6e3ba736939d7ac7a85", "commitAfterChange": "ed3a0c0705f2be20be3aaf856f81a3803e4ac341", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " public MethodBinding getMethodBinding(MethodPattern methodPattern)", "signatureAfterChange": " public MethodBinding getMethodBinding(MethodPattern methodPattern)", "diff": ["+    MethodBinding methodBinding = getMethodBinding0(methodPattern);", "+    if (methodBinding != null)", "+    \treturn methodBinding; // known to be valid.", "+    // special handling for methods of anonymous/local types. Since these cannot be looked up in the environment the usual way ...", "+    if (methodPattern.focus instanceof SourceMethod) {", "+    \tchar[] typeName = PatternLocator.qualifiedPattern(methodPattern.declaringSimpleName, methodPattern.declaringQualification);", "+    \tif (CharOperation.indexOf(IIndexConstants.ONE_STAR, typeName, true) >= 0) { // See org.eclipse.jdt.core.search.SearchPattern.enclosingTypeNames(IType)", "+    \t\tIType type = methodPattern.declaringType;", "+    \t\tIType enclosingType = type.getDeclaringType();", "+    \t\twhile (enclosingType != null) {", "+    \t\t\ttype = enclosingType;", "+    \t\t\tenclosingType = type.getDeclaringType();", "+    \t\t}", "+    \t\ttypeName = type.getFullyQualifiedName().toCharArray();", "+    \t\tTypeBinding declaringTypeBinding = getType(typeName, typeName);", "+    \t\tif (declaringTypeBinding instanceof SourceTypeBinding) {", "+    \t\t\tSourceTypeBinding sourceTypeBinding = ((SourceTypeBinding) declaringTypeBinding);", "+    \t\t\tClassScope skope = sourceTypeBinding.scope;", "+    \t\t\tif (skope != null) {", "+    \t\t\t\tCompilationUnitDeclaration unit = skope.referenceCompilationUnit();", "+    \t\t\t\tif (unit != null) {", "+    \t\t\t\t\tAbstractMethodDeclaration amd = new ASTNodeFinder(unit).findMethod((IMethod) methodPattern.focus);", "+    \t\t\t\t\tif (amd != null && amd.binding != null && amd.binding.isValidBinding()) {", "+    \t\t\t\t\t\tthis.bindings.put(methodPattern, amd.binding);", "+    \t\t\t\t\t\treturn amd.binding;", "+    \t\t\t\t\t}", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t}", "+    \t}", "+    }", "+\treturn null;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8734789ea3719da3fb655fb5ac48ebf7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 9, "signatureBeforeChange": " public static char[] createCharArrayTypeSignature(char[] typeName, boolean isResolved)", "signatureAfterChange": " public static char[] createCharArrayTypeSignature(char[] typeName, boolean isResolved)", "diff": ["+\tStringBuffer buffer = new StringBuffer(5);", "+\tint pos = encodeTypeSignature(typeName, 0, isResolved, length, buffer);", "+\tpos = consumeWhitespace(typeName, pos, length);", "+\tif (pos < length) throw new IllegalArgumentException(new String(typeName));", "+\tchar[] result = new char[length = buffer.length()];", "+\tbuffer.getChars(0, length, result, 0);", "+\treturn result;\t", "+}", "-\tint arrayCount = CharOperation.occurencesOf('[', typeName);", "-\tchar[] sig;", "-\t", "-\tswitch (typeName[0]) {", "-\t\t\tif (checkPrimitiveType(BOOLEAN, typeName)) {", "-\t\t\t\tsig = new char[arrayCount+1];", "-\t\t\t\tsig[arrayCount] = C_BOOLEAN;", "-\t\t\t\tbreak;", "-\t\t\t} else if (checkPrimitiveType(BYTE, typeName)) {", "-\t\t\t\tsig = new char[arrayCount+1];", "-\t\t\t\tsig[arrayCount] = C_BYTE;", "-\t\t\t\tbreak;", "-\t\t\tif (checkPrimitiveType(CHAR, typeName)) {", "-\t\t\t\tsig = new char[arrayCount+1];", "-\t\t\t\tsig[arrayCount] = C_CHAR;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tif (checkPrimitiveType(DOUBLE, typeName)) {", "-\t\t\t\tsig = new char[arrayCount+1];", "-\t\t\t\tsig[arrayCount] = C_DOUBLE;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tif (checkPrimitiveType(FLOAT, typeName)) {", "-\t\t\t\tsig = new char[arrayCount+1];", "-\t\t\t\tsig[arrayCount] = C_FLOAT;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tif (checkPrimitiveType(INT, typeName)) {", "-\t\t\t\tsig = new char[arrayCount+1];", "-\t\t\t\tsig[arrayCount] = C_INT;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tif (checkPrimitiveType(LONG, typeName)) {", "-\t\t\t\tsig = new char[arrayCount+1];", "-\t\t\t\tsig[arrayCount] = C_LONG;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tif (checkPrimitiveType(SHORT, typeName)) {", "-\t\t\t\tsig = new char[arrayCount+1];", "-\t\t\t\tsig[arrayCount] = C_SHORT;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tif (checkPrimitiveType(VOID, typeName)) {", "-\t\t\t\tsig = new char[arrayCount+1];", "-\t\t\t\tsig[arrayCount] = C_VOID;", "-\t\t\t\tbreak;", "-\t\tdefault:", "-\t\t\t// non primitive type", "-\t\t\tint sigLength = arrayCount + 1 + length + 1; // for example '[[[Ljava.lang.String;'", "-\t\t\tsig = new char[sigLength];", "-\t\t\tint sigIndex = arrayCount+1; // index in sig", "-\t\t\tint startID = 0; // start of current ID in typeName", "-\t\t\tint index = 0; // index in typeName", "-\t\t\twhile (index < length) {", "-\t\t\t\tchar currentChar = typeName[index];", "-\t\t\t\tswitch (currentChar) {", "-\t\t\t\t\tcase '.':", "-\t\t\t\t\t\tif (startID == -1) throw new IllegalArgumentException(new String(typeName));", "-\t\t\t\t\t\tif (startID < index) {", "-\t\t\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "-\t\t\t\t\t\t\tsigIndex += index-startID;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tsig[sigIndex++] = C_DOT;", "-\t\t\t\t\t\tindex++;", "-\t\t\t\t\t\tstartID = index;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase '[':", "-\t\t\t\t\t\tif (startID != -1) {", "-\t\t\t\t\t\t\tif (startID < index) {", "-\t\t\t\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "-\t\t\t\t\t\t\t\tsigIndex += index-startID;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tstartID = -1; // no more id after []", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tindex++;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault :", "-\t\t\t\t\t\tif (startID != -1 && CharOperation.isWhitespace(currentChar)) {", "-\t\t\t\t\t\t\tif (startID < index) {", "-\t\t\t\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "-\t\t\t\t\t\t\t\tsigIndex += index-startID;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tstartID = index+1;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tindex++;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t// last id", "-\t\t\tif (startID != -1 && startID < index) {", "-\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "-\t\t\t\tsigIndex += index-startID;", "-\t\t\t", "-\t\t\t// add L (or Q) at the beigininig and ; at the end", "-\t\t\tsig[arrayCount] = isResolved ? C_RESOLVED : C_UNRESOLVED;", "-\t\t\tsig[sigIndex++] = C_NAME_END;", "-\t\t\t", "-\t\t\t// resize if needed", "-\t\t\tif (sigLength > sigIndex) {", "-\t\t\t\tSystem.arraycopy(sig, 0, sig = new char[sigIndex], 0, sigIndex);", "-\t\t\t}", "-", "-\t// add array info", "-\tfor (int i = 0; i < arrayCount; i++) {", "-\t\tsig[i] = C_ARRAY;", "-\t", "-\treturn sig;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fbfdaf397c7dab5715c8e17c48e046cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/AndPattern.java", "commitBeforeChange": "9ccc53063dda8b7e1afdde95ae36a8417c582abc", "commitAfterChange": "7143e72571bb2e6a2e74f6791210a97b375b5ab6", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " protected void findIndexMatches(IndexInput input, IndexQueryRequestor requestor, SearchParticipant participant, IJavaSearchScope scope, IProgressMonitor progressMonitor, char[] queryKey, char[] category) throws IOException", "signatureAfterChange": " public void findIndexMatches(Index index, IndexQueryRequestor requestor, SearchParticipant participant, IJavaSearchScope scope, IProgressMonitor progressMonitor) throws IOException", "diff": ["- */", "-protected void findIndexMatches(IndexInput input, IndexQueryRequestor requestor, SearchParticipant participant, IJavaSearchScope scope, IProgressMonitor progressMonitor, char[] queryKey, char[] category) throws IOException {", "-", "+public void findIndexMatches(Index index, IndexQueryRequestor requestor, SearchParticipant participant, IJavaSearchScope scope, IProgressMonitor progressMonitor) throws IOException {", "-\t", "-\t/* narrow down a set of entries using prefix criteria */", "-\tlong[] possibleRefs = null;", "-\tint maxRefs = -1;", "+", "-\tdo {", "-\t\tqueryKey = encodeIndexKey();", "-\t\tchar[] pattern = CharOperation.concat(category, queryKey);", "-\t\tEntryResult[] entries = input.queryEntries(pattern, SearchPattern.R_PREFIX_MATCH);", "-\t\tif (entries == null) break;", "+\tSimpleSet intersectedNames = null;", "+\ttry {", "+\t\tindex.startQuery();", "+\t\tdo {", "+\t\t\tSearchPattern pattern = currentPattern();", "+\t\t\tEntryResult[] entries = pattern.queryIn(index);", "+\t\t\tif (entries == null) return;", "-\t\tint numFiles = input.getNumFiles();", "-\t\tlong[] references = null;", "-\t\tint referencesLength = -1;", "-\t\tfor (int i = 0, max = entries.length; i < max; i++) {", "-\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) throw new OperationCanceledException();", "+\t\t\tSearchPattern decodedResult = pattern.getBlankPattern();", "+\t\t\tSimpleSet newIntersectedNames = new SimpleSet();", "+\t\t\tfor (int i = 0, l = entries.length; i < l; i++) {", "+\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) throw new OperationCanceledException();", "-\t\t\t/* retrieve and decode entry */\t", "-\t\t\tEntryResult entry = entries[i];", "-\t\t\tchar[] word = entry.getWord();", "-\t\t\tchar[] indexKey = CharOperation.subarray(word, category.length, word.length);", "-\t\t\tSearchPattern decodedPattern = getBlankPattern();", "-\t\t\tdecodedPattern.decodeIndexKey(indexKey);", "-\t\t\tif (matchesDecodedPattern(decodedPattern)) {", "-\t\t\t\t/* accumulate references in an array of bits : 1 if the reference is present, 0 otherwise */", "-\t\t\t\tint[] fileReferences = entry.getFileReferences();", "-\t\t\t\tfor (int j = 0, refLength = fileReferences.length; j < refLength; j++) {", "-\t\t\t\t\tint fileReference = fileReferences[j];", "-\t\t\t\t\tint vectorIndex = fileReference / 64; // a long has 64 bits", "-\t\t\t\t\tif (references == null) {", "-\t\t\t\t\t\treferencesLength = (numFiles / 64) + 1;", "-\t\t\t\t\t\treferences = new long[referencesLength];", "-\t\t\t\t\t}", "-\t\t\t\t\tlong mask = 1L << (fileReference % 64);", "-\t\t\t\t\treferences[vectorIndex] |= mask;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t/* only select entries which actually match the entire search pattern */", "-\t\tif (references == null) return;", "-\t\tif (possibleRefs == null) {", "-\t\t\t/* first query : these are the possible references */", "-\t\t\tpossibleRefs = references;", "-\t\t\tmaxRefs = numFiles;", "-\t\t} else {", "-\t\t\t/* eliminate possible references that don't match the current references */", "-\t\t\tint possibleLength = possibleRefs.length;", "-\t\t\tfor (int i = 0, length = references.length; i < length; i++) {", "-\t\t\t\tif (i < possibleLength)", "-\t\t\t\t\tpossibleRefs[i] &= references[i];", "-\t\t\t\telse", "-\t\t\t\t\tpossibleRefs[i] = 0;", "-\t\t\t}", "-\t\t\t// check to see that there are still possible references after the merge", "-\t\t\twhile (--possibleLength >= 0 && possibleRefs[possibleLength] == 0);", "-\t\t\tif (possibleLength == -1) return;", "-\t\t}", "-\t} while (this.hasNextQuery());", "-", "-\t/* report possible references that remain */", "-\tif (possibleRefs != null) {", "-\t\tint[] refs = new int[maxRefs];", "-\t\tint refsLength = 0;", "-\t\tfor (int reference = 1; reference <= maxRefs; reference++) {", "-\t\t\tint vectorIndex = reference / 64; // a long has 64 bits", "-\t\t\tif ((possibleRefs[vectorIndex] & (1L << (reference % 64))) != 0)", "-\t\t\t\trefs[refsLength++] = reference;", "-\t\t}", "-\t\tSystem.arraycopy(refs, 0, refs = new int[refsLength], 0, refsLength);", "-\t\tfor (int i = 0; i < refsLength; i++) { // TODO (jerome) merge with previous loop", "-\t\t\tint reference = refs[i];", "-\t\t\tif (reference != -1) { // if the reference has not been eliminated", "-\t\t\t\tIndexedFile file = input.getIndexedFile(reference);", "-\t\t\t\tif (file != null) {", "-\t\t\t\t\tString documentPath = IndexedFile.convertPath(file.getPath());", "-\t\t\t\t\tif (scope.encloses(documentPath)) {", "-\t\t\t\t\t\tif (!requestor.acceptIndexMatch(documentPath, null, participant)) // AndPatterns cannot provide the decoded pattern ", "-\t\t\t\t\t\t\tthrow new OperationCanceledException();", "+\t\t\t\tEntryResult entry = entries[i];", "+\t\t\t\tdecodedResult.decodeIndexKey(entry.getWord());", "+\t\t\t\tif (pattern.matchesDecodedKey(decodedResult)) {", "+\t\t\t\t\tString[] names = entry.getDocumentNames(index);", "+\t\t\t\t\tif (intersectedNames != null) {", "+\t\t\t\t\t\tfor (int j = 0, n = names.length; j < n; j++)", "+\t\t\t\t\t\t\tif (intersectedNames.includes(names[j]))", "+\t\t\t\t\t\t\t\tnewIntersectedNames.add(names[j]);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfor (int j = 0, n = names.length; j < n; j++)", "+\t\t\t\t\t\t\tnewIntersectedNames.add(names[j]);", "-\t\t}", "+", "+\t\t\tif (newIntersectedNames.elementSize == 0) return;", "+\t\t\tintersectedNames = newIntersectedNames;", "+\t\t} while (this.hasNextQuery());", "+\t} finally {", "+\t\tindex.stopQuery();", "+\tif (intersectedNames == null) return;", "+", "+\tObject[] names = intersectedNames.values;", "+\tfor (int i = 0, l = names.length; i < l; i++)", "+\t\tif (names[i] != null)", "+\t\t\tacceptMatch((String) names[i], null, requestor, participant, scope); // AndPatterns cannot provide the decoded result"]}], "num": 60832}