{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "176be3eb2e7eaf70f0da41dd6fe04dd7", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "27082451f1f7995829abc0f25f345c83", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "e733dacf7e2cb0f1c468842218b8cf0fff8a2c3b", "commitAfterChange": "ef98b1110b7ab3f8a6089643c80689cd9cb542d0", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tprivate String getPreserveEmptyLines(int count)", "signatureAfterChange": " \tprivate String getPreserveEmptyLines(int count)", "diff": ["+\t\t\t\t\t// Reset indentation level to the location output", "+\t\t\t\t\tthis.indentationLevel = this.currentAlignment.location.outputIndentationLevel;", "+\t\t\t\t\tthis.numberOfIndentations = this.currentAlignment.location.numberOfIndentations;", "+\t\t\t\t\tthis.formatter.lastLocalDeclarationSourceStart = this.currentAlignment.location.lastLocalDeclarationSourceStart;", "+\t\t\t\t\t// Create new line keeping the existing indentation", "-\t\t\t\t\tif (this.currentAlignment.useBreakIndentation) {", "+\t\t\t\t\tint currentColumn = getCurrentIndentation(this.scanner.currentPosition);", "+\t\t\t\t\tAlignment rootAlignment = this.currentAlignment;", "+\t\t\t\t\twhile (rootAlignment.enclosing != null) {", "+\t\t\t\t\t\trootAlignment = rootAlignment.enclosing;", "+\t\t\t\t\t}", "+\t\t\t\t\tLocation location = rootAlignment.location;", "+\t\t\t\t\tif (currentColumn > location.inputColumn) {", "-\t\t\t\t\t\tthis.indentationLevel = this.currentAlignment.breakIndentationLevel;", "+\t\t\t\t\t\tthis.indentationLevel += currentColumn - location.inputColumn;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e600a4e9efabbd59376c401a88e499e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8494797ba855fec4ee2bbc6396bac52c13992e9d", "commitAfterChange": "950e006d80a8c444f42fb13ad689e30f2484e0db", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 41, "signatureBeforeChange": "  \tpublic void handleLineTooLong()", "signatureAfterChange": "  \tpublic void handleLineTooLong()", "diff": ["+\t\tif (this.formatter.preferences.wrap_outer_expressions_when_nested) {", "+\t\t\thandleLineTooLongSmartly();", "+\t\t\treturn;", "+\t\t}", "+\t\t// search for closest breakable alignment, using tiebreak rules", "+\t\t// look for outermost breakable one", "+\t\tint relativeDepth = 0, outerMostDepth = -1;", "+\t\tAlignment targetAlignment = this.currentAlignment;", "+\t\twhile (targetAlignment != null){", "+\t\t\tif (targetAlignment.tieBreakRule == Alignment.R_OUTERMOST && targetAlignment.couldBreak()){", "+\t\t\t\touterMostDepth = relativeDepth;", "+\t\t\t}", "+\t\t\ttargetAlignment = targetAlignment.enclosing;", "+\t\t\trelativeDepth++;", "+\t\t}", "+\t\tif (outerMostDepth >= 0) {", "+\t\t\tthrow new AlignmentException(AlignmentException.LINE_TOO_LONG, outerMostDepth);", "+\t\t}", "+\t\t// look for innermost breakable one", "+\t\trelativeDepth = 0;", "+\t\ttargetAlignment = this.currentAlignment;", "+\t\twhile (targetAlignment != null){", "+\t\t\tif (targetAlignment.couldBreak()){", "+\t\t\t\tthrow new AlignmentException(AlignmentException.LINE_TOO_LONG, relativeDepth);", "+\t\t\t}", "+\t\t\ttargetAlignment = targetAlignment.enclosing;", "+\t\t\trelativeDepth++;", "+\t\t}", "+\t\t// did not find any breakable location - proceed", "+\t}"]}], "num": 7985}