{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7f810cb0020b1e59d2b15fb4abc91814", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "383ab572407cfe2e1dd2d1ba48ea115f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SearchPattern.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 28, "signatureBeforeChange": "\r \tprotected boolean matchesAsSubtype(\r \t\tReferenceBinding type,\r \t\tReferenceBinding superType)", "signatureAfterChange": "\r private char[][][] collectSuperTypeNames(ReferenceBinding type)", "diff": ["+ */\r", "+private char[][][] collectSuperTypeNames(ReferenceBinding type) {\r", "+\r", "+\t// superclass\r", "+\tchar[][][] superClassNames = null;\r", "+\tReferenceBinding superclass = type.superclass();\r", "+\tif (superclass != null) {\r", "+\t\tsuperClassNames = this.collectSuperTypeNames(superclass);\r", "+\t}\r", "+\r", "+\t// interfaces\r", "+\tchar[][][][] superInterfaceNames = null;\r", "+\tint superInterfaceNamesLength = 0;\r", "+\tReferenceBinding[] interfaces = type.superInterfaces();\r", "+\tif (interfaces != null) {\r", "+\t\tsuperInterfaceNames = new char[interfaces.length][][][];\r", "+\t\tfor (int i = 0; i < interfaces.length; i++) {\r", "+\t\t\tsuperInterfaceNames[i] = this.collectSuperTypeNames(interfaces[i]);\r", "+\t\t\tsuperInterfaceNamesLength += superInterfaceNames[i].length;\r", "+\tint length = \r", "+\t\t(superclass == null ? 0 : 1)\r", "+\t\t+ (superClassNames == null ? 0 : superClassNames.length)\r", "+\t\t+ (interfaces == null ? 0 : interfaces.length)\r", "+\t\t+ superInterfaceNamesLength;\r", "+\tchar[][][] result = new char[length][][];\r", "+\tint index = 0;\r", "+\tif (superclass != null) {\r", "+\t\tresult[index++] = superclass.compoundName;\r", "+\t\tif (superClassNames != null) {\r", "+\t\t\tSystem.arraycopy(superClassNames, 0, result, index, superClassNames.length);\r", "+\t\t\tindex += superClassNames.length;\r", "+\t\t}\r", "+\t}\r", "+\tif (interfaces != null) {\r", "+\t\tfor (int i = 0, max = interfaces.length; i < max; i++) {\r", "+\t\t\tresult[index++] = interfaces[i].compoundName;\r", "+\t\t\tif (superInterfaceNames != null) {\r", "+\t\t\t\tSystem.arraycopy(superInterfaceNames[i], 0, result, index, superInterfaceNames[i].length);\r", "+\t\t\t\tindex += superInterfaceNames[i].length;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r", "+\t\r", "+\treturn result;\r", "+}\r", "-\t */\r", "-\tprotected boolean matchesAsSubtype(\r", "-\t\tReferenceBinding type,\r", "-\t\tReferenceBinding superType) {\r", "-\r", "-\t\t// matches superclass\r", "-\t\tReferenceBinding superclass = type.superclass();\r", "-\t\tif (superType == superclass)\r", "-\t\t\treturn true;\r", "-\t\tif (superclass != null) {\r", "-\t\t\tif (this.matchesAsSubtype(superclass, superType))\r", "-\t\t\t\treturn true;\r", "-\t\t}\r", "-\r", "-\t\t// matches interfaces\r", "-\t\tReferenceBinding[] interfaces = type.superInterfaces();\r", "-\t\tfor (int i = 0; i < interfaces.length; i++) {\r", "-\t\t\tReferenceBinding interf = interfaces[i];\r", "-\t\t\tif (superType == interf)\r", "-\t\t\t\treturn true;\r", "-\t\t\tif (this.matchesAsSubtype(interf, superType))\r", "-\t\t\t\treturn true;\r", "-\t\t}\r", "-\r", "-\t\treturn false;\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a8eae444a0e4e9ef812329436e43e53f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "58e1f97a6c11cbf99287f2cc95bb245d2faf2bd1", "commitAfterChange": "e33ceacdb6e9b17f29de3a23e3df28f1c6bec162", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic void configure(String[] argv) throws InvalidInputException", "signatureAfterChange": " \tpublic void configure(String[] argv) throws InvalidInputException", "diff": ["-\t\tif ((argv == null) || (argv.length == 0))", "-\t\t\tthrow new InvalidInputException(Main.bind(\"configure.noSourceFile\")); //$NON-NLS-1$", "+\t\tif ((argv == null) || (argv.length == 0)) {", "+\t\t\tprintUsage();", "+\t\t\treturn;", "+\t\t}", "+\t\t// expand the command line if necessary", "+\t\tboolean needExpansion = false;", "+\t\tloop: for (int i = 0; i < argCount; i++) {", "+\t\t\t\tif (argv[i].startsWith(\"@\")) {", "+\t\t\t\t\tneedExpansion = true;", "+\t\t\t\t\tbreak loop;", "+\t\t\t\t}", "+\t\t}", "+", "+\t\tString[] newCommandLineArgs = null;", "+\t\tif (needExpansion) {", "+\t\t\tnewCommandLineArgs = new String[argCount];", "+\t\t\tindex = 0;", "+\t\t\tfor (int i = 0; i < argCount; i++) {", "+\t\t\t\tString[] newArgs = null;", "+\t\t\t\tString arg = argv[i].trim();", "+\t\t\t\tif (arg.startsWith(\"@\")) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tLineNumberReader reader = new LineNumberReader(new StringReader(new String(Util.getFileCharContent(new File(arg.substring(1)), null))));", "+\t\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t\t\tString line;", "+\t\t\t\t\t\twhile((line = reader.readLine()) != null) {", "+\t\t\t\t\t\t\tbuffer.append(line).append(\" \");", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tnewArgs = tokenize(buffer.toString());", "+\t\t\t\t\t} catch(IOException e) {", "+\t\t\t\t\t\tthrow new InvalidInputException(", "+\t\t\t\t\t\t\tMain.bind(\"configure.invalidexpansionargumentname\", arg)); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (newArgs != null) {", "+\t\t\t\t\tint newCommandLineArgsLength = newCommandLineArgs.length;", "+\t\t\t\t\tint newArgsLength = newArgs.length;", "+\t\t\t\t\tSystem.arraycopy(newCommandLineArgs, 0, (newCommandLineArgs = new String[newCommandLineArgsLength + newArgsLength - 1]), 0, index);", "+\t\t\t\t\tSystem.arraycopy(newArgs, 0, newCommandLineArgs, index, newArgsLength);", "+\t\t\t\t\tindex += newArgsLength;", "+\t\t\t\t} else {", "+\t\t\t\t\tnewCommandLineArgs[index++] = arg;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tindex = -1;", "+\t\t} else {", "+\t\t\tnewCommandLineArgs = argv;", "+\t\t\tfor (int i = 0; i < argCount; i++) {", "+\t\t\t\tnewCommandLineArgs[i] = newCommandLineArgs[i].trim();", "+\t\t\t}", "+\t\t}", "+\t\targCount = newCommandLineArgs.length;", "-\t\t\tcurrentArg = argv[index].trim();", "+\t\t\tcurrentArg = newCommandLineArgs[index];", "-\t\tif (filenames == null)", "-\t\t\tthrow new InvalidInputException(Main.bind(\"configure.noSource\")); //$NON-NLS-1$", "+\t\tif (filenames == null) {", "+\t\t\tprintUsage();", "+\t\t\treturn;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b0bf4dc5de5d858795858e4a95b312de", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "9a828b6f308f1048d5448d6c6f9c881639322d34", "commitAfterChange": "5028738b115a56f3f04beb6089ff2c05854751f1", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": " public static char[] createMethodSignature(char[][] parameterTypes, char[] returnType)", "signatureAfterChange": " public static char[] createMethodSignature( \t\tchar[][] parameterTypes, \t\tchar[] returnType, \t\tchar[][] formalTypeParameters, \t\tchar[][] thrownExceptions)", "diff": ["-\tint parameterTypesLength = parameterTypes.length;", "-\tint parameterLength = 0;", "-\tfor (int i = 0; i < parameterTypesLength; i++) {", "-\t\tparameterLength += parameterTypes[i].length;", "-\t\t", "-\t}", "-\tint returnTypeLength = returnType.length;", "-\tchar[] result = new char[1 + parameterLength + 1 + returnTypeLength];", "-\tresult[0] = C_PARAM_START;", "-\tint index = 1;", "-\tfor (int i = 0; i < parameterTypesLength; i++) {", "-\t\tchar[] parameterType = parameterTypes[i];", "-\t\tint length = parameterType.length;", "-\t\tSystem.arraycopy(parameterType, 0, result, index, length);", "-\t\tindex += length;", "-\t}", "-\tresult[index] = C_PARAM_END;", "-\tSystem.arraycopy(returnType, 0, result, index+1, returnTypeLength);", "-\treturn result;", "+ */", "+public static char[] createMethodSignature(", "+\t\tchar[][] parameterTypes,", "+\t\tchar[] returnType,", "+\t\tchar[][] formalTypeParameters,", "+\t\tchar[][] thrownExceptions) {", "+\tint formalTypeParameterCount = formalTypeParameters.length;", "+\tint formalTypeLength = 0;", "+\tfor (int i = 0; i < formalTypeParameterCount; i++) {", "+\t\tformalTypeLength += formalTypeParameters[i].length;", "+\t}", "+\tint parameterTypesCount = parameterTypes.length;", "+\tint parameterLength = 0;", "+\tfor (int i = 0; i < parameterTypesCount; i++) {", "+\t\tparameterLength += parameterTypes[i].length;", "+\t}", "+\tint returnTypeLength = returnType.length;", "+\tint thrownExceptionsCount = thrownExceptions.length;", "+\tint exceptionsLength = 0;", "+\tfor (int i = 0; i < thrownExceptionsCount; i++) {", "+\t\texceptionsLength += thrownExceptions[i].length;", "+\t}", "+\tint extras = 2; // \"(\" and \")\"", "+\tif (formalTypeParameterCount > 0) {", "+\t\textras += 2;   // \"<\" and \">\"", "+\t}", "+\tif (thrownExceptionsCount > 0) {", "+\t\textras += thrownExceptionsCount;   // one \"^\" per", "+\t}", "+\tchar[] result = new char[extras+ formalTypeLength + parameterLength + returnTypeLength + exceptionsLength];", "+\tint index = 0;", "+\tif (formalTypeParameterCount > 0) {", "+\t\tresult[index++] = C_GENERIC_START;", "+\t\tfor (int i = 0; i < formalTypeParameterCount; i++) {", "+\t\t\tchar[] formalTypeParameter = formalTypeParameters[i];", "+\t\t\tint length = formalTypeParameter.length;", "+\t\t\tSystem.arraycopy(formalTypeParameter, 0, result, index, length);", "+\t\t\tindex += length;", "+\t\t}", "+\t\tresult[index++] = C_GENERIC_END;", "+\t}", "+\tresult[index++] = C_PARAM_START;", "+\tfor (int i = 0; i < parameterTypesCount; i++) {", "+\t\tchar[] parameterType = parameterTypes[i];", "+\t\tint length = parameterType.length;", "+\t\tSystem.arraycopy(parameterType, 0, result, index, length);", "+\t\tindex += length;", "+\t}", "+\tresult[index++] = C_PARAM_END;", "+\tSystem.arraycopy(returnType, 0, result, index, returnTypeLength);", "+\tindex += returnTypeLength;", "+\tif (thrownExceptionsCount > 0) {", "+\t\tfor (int i = 0; i < thrownExceptionsCount; i++) {", "+\t\t\tresult[index++] = C_THROWS;", "+\t\t\tchar[] thrownException = thrownExceptions[i];", "+\t\t\tint length = thrownException.length;", "+\t\t\tSystem.arraycopy(thrownException, 0, result, index, length);", "+\t\t\tindex += length;", "+\t\t}", "+\t}", "+\treturn result;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e94035d8281c3ba41999c8407da203a8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "457fc77ec96140a15fc3e1c18bbf7bf53c7ea1c9", "commitAfterChange": "44074e366655e2cf89768617c1e64463f5949123", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " public MethodBinding getMethodBinding(IMethod method)", "signatureAfterChange": " public MethodBinding getMethodBinding(IMethod method)", "diff": ["-\tMethodBinding methodBinding = null;", "-\t\t\tint length = parameterTypes.length;", "-\t\t\tTypeBinding[] parameters = new TypeBinding[length];", "-\t\t\tfor (int i=0;  i<length; i++) {", "-\t\t\t\tparameters[i] = this.unitScope.getType(Signature.toCharArray(parameterTypes[i].toCharArray()));", "+\t\t\tint paramTypeslength = parameterTypes.length;", "+\t\t\tchar[][] paramTypesChars = new char[paramTypeslength][];", "+\t\t\tfor (int i=0;  i<paramTypeslength; i++) {", "+\t\t\t\tparamTypesChars[i] = Signature.toCharArray(parameterTypes[i].toCharArray());", "-\t\t\tmethodBinding = referenceBinding.getExactMethod(method.getElementName().toCharArray(), parameters);", "-\t\t\tthis.bindings.put(method, methodBinding);", "-\t\t\treturn methodBinding;", "+\t\t\tMethodBinding[] methods = referenceBinding.getMethods(method.getElementName().toCharArray());", "+\t\t\tint methodsLength = methods.length;", "+\t\t\tTypeVariableBinding[] refTypeVariables = referenceBinding.typeVariables();", "+\t\t\tint typeVarLength = refTypeVariables==null ? 0 : refTypeVariables.length;", "+\t\t\tfor (int i=0; i<methodsLength; i++) {", "+\t\t\t\tTypeBinding[] methodParameters = methods[i].parameters;", "+\t\t\t\tint paramLength = methodParameters==null ? 0 : methodParameters.length;", "+\t\t\t\tTypeVariableBinding[] methodTypeVariables = methods[i].typeVariables;", "+\t\t\t\tint methTypeVarLength = methodTypeVariables==null ? 0 : methodTypeVariables.length;", "+\t\t\t\tboolean found = paramLength == paramTypeslength;", "+\t\t\t\tif (found) {", "+\t\t\t\t\tfor (int p=0; found && p<paramLength; p++) {", "+\t\t\t\t\t\tif (CharOperation.equals(methodParameters[p].erasure().shortReadableName(), paramTypesChars[p])) {", "+\t\t\t\t\t\t\t// param erasure match", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// type variable", "+\t\t\t\t\t\t\tboolean foundVar = true;", "+\t\t\t\t\t\t\tfor (int v=0; foundVar && v<typeVarLength; v++) {", "+\t\t\t\t\t\t\t\tif (!CharOperation.equals(refTypeVariables[v].sourceName, paramTypesChars[p])) {", "+\t\t\t\t\t\t\t\t\tfoundVar = false;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!foundVar) {", "+\t\t\t\t\t\t\t\tfoundVar = true;", "+\t\t\t\t\t\t\t\tfor (int v=0; foundVar && v<methTypeVarLength; v++) {", "+\t\t\t\t\t\t\t\t\tif (!CharOperation.equals(methodTypeVariables[v].sourceName, paramTypesChars[p])) {", "+\t\t\t\t\t\t\t\t\t\tfoundVar = false;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (!foundVar) found = false;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (found) {", "+\t\t\t\t\tthis.bindings.put(method, methods[i]);", "+\t\t\t\t\treturn methods[i];", "+\t\t\t\t}", "+\t\t\t}", "+//\t\t\tmethodBinding = referenceBinding.getExactMethod(method.getElementName().toCharArray(), parameters);", "+//\t\t\tthis.bindings.put(method, methodBinding);", "+//\t\t\treturn methodBinding;"]}], "num": 57955}