{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6c36df13eba23afbb3c3e546741abcf7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "397610c6f592d040537a083af312218e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "afbd59588c9ca5e9f9fa1e0c9c6d428db18067ff", "commitAfterChange": "5d6b68778bc5cc6ff8d2d7502de9a5e78a68b5d0", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " private void createMethods(IBinaryMethod[] iMethods)", "signatureAfterChange": " private void createMethods(IBinaryMethod[] iMethods)", "diff": ["+\tint[] toSkip = null;", "-\t\t\tIBinaryMethod method;", "-\t\t\tchar[] methodName = (method = iMethods[i]).getSelector();", "-\t\t\tif ((methodName[0] == '<' && methodName.length == 8)", "-\t\t\t\t\t|| (method.getModifiers() & AccSynthetic) != 0) { // Can only match <clinit> or synthetics", "-\t\t\t\ttotal--;", "+\t\t\tIBinaryMethod method = iMethods[i];", "+\t\t\tchar[] methodName;", "+\t\t\tif ((method.getModifiers() & AccSynthetic) != 0 ||", "+\t\t\t\t((methodName = method.getSelector()).length == 8 && methodName[0] == '<')) {", "+\t\t\t\t\tif (toSkip == null)", "+\t\t\t\t\t\ttoSkip = new int[iMethods.length];", "+\t\t\t\t\ttoSkip[i] = -1;", "+\t\t\t\t\ttotal--;", "-\tfor (int i = 0, length = iMethods.length; i < length; i++){", "-\t\t\tIBinaryMethod method;", "-\t\t\tchar[] methodName = (method = iMethods[i]).getSelector();", "-\t\t\tif (!((methodName[0] == '<' && methodName.length == 8)", "-\t\t\t\t\t|| (method.getModifiers() & AccSynthetic) != 0)) { // Can only match <clinit> or synthetics", "+\tif (toSkip == null) {", "+\t\tfor (int i = 0, length = iMethods.length; i < length; i++)", "+\t\t\tthis.methods[next++] = createMethod(iMethods[i]);", "+\t} else {", "+\t\tfor (int i = 0, length = iMethods.length; i < length; i++)", "+\t\t\tif (toSkip[i] == 0)", "-\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ccf8c212f0268b10069afda6cdec2e4b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java", "commitBeforeChange": "c85c898de3099d8d87b870385bc47667302c5e21", "commitAfterChange": "73c6d3ea7dc5df8e531fcab68ea3f39bbd288577", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic UnconditionalFlowInfo discardNonFieldInitializations()", "signatureAfterChange": " public UnconditionalFlowInfo discardNonFieldInitializations()", "diff": ["+ */", "+public UnconditionalFlowInfo discardNonFieldInitializations() {", "+\tint limit = this.maxFieldCount;", "+\tif (limit < BitCacheSize) {", "+\t\tlong mask = (1L << limit)-1;", "+\t\tthis.definiteInits &= mask;", "+\t\tthis.potentialInits &= mask;", "+\t\tthis.nullAssignmentStatusBit1 &= mask;", "+\t\tthis.nullAssignmentStatusBit2 &= mask;", "+\t\tthis.nullAssignmentValueBit1 &= mask;", "+\t\tthis.nullAssignmentValueBit2 &= mask;", "+\t} ", "+\t// use extra vector", "+\tif (this.extra == null) {", "+\t\treturn this; // if vector not yet allocated, then not initialized", "+\t}", "+\tint vectorIndex, length = this.extra[0].length;", "+\tif ((vectorIndex = (limit / BitCacheSize) - 1) >= length) {", "+\t\treturn this; // not enough room yet", "+\t}", "+\tif (vectorIndex >= 0) { ", "+\t\t// else we only have complete non field array items left", "+\t\tfor (int j = 0; j < extraLength; j++) {", "+\t\t\tthis.extra[j][vectorIndex] &= mask;", "+\t\t}", "+\tfor (int i = vectorIndex + 1; i < length; i++) {", "+\t\tfor (int j = 0; j < extraLength; j++) {", "+\t\t\tthis.extra[j][i] = 0;", "+\t\t}", "+\t}", "+\treturn this;", "+}", "-\tpublic UnconditionalFlowInfo discardNonFieldInitializations(){", "-\t\t", "-\t\tint limit = this.maxFieldCount;", "-\t\t", "-\t\tif (limit < BitCacheSize) {", "-\t\t\tlong mask = (1L << limit)-1;", "-\t\t\tthis.definiteInits &= mask;", "-\t\t\tthis.potentialInits &= mask;", "-\t\t\tthis.definiteNulls &= mask;", "-\t\t\tthis.definiteNonNulls &= mask;", "-\t\t\treturn this;", "-\t\t// use extra vector", "-\t\tif (extraDefiniteInits == null) {", "-\t\t\treturn this; // if vector not yet allocated, then not initialized", "-\t\tint vectorIndex, length = this.extraDefiniteInits.length;", "-\t\tif ((vectorIndex = (limit / BitCacheSize) - 1) >= length) {", "-\t\t\treturn this; // not enough room yet", "-\t\t}", "-\t\tlong mask = (1L << (limit % BitCacheSize))-1;", "-\t\tthis.extraDefiniteInits[vectorIndex] &= mask;", "-\t\tthis.extraPotentialInits[vectorIndex] &= mask;", "-\t\tthis.extraDefiniteNulls[vectorIndex] &= mask;", "-\t\tthis.extraDefiniteNonNulls[vectorIndex] &= mask;", "-\t\tfor (int i = vectorIndex+1; i < length; i++) {", "-\t\t\tthis.extraDefiniteInits[i] = 0L;", "-\t\t\tthis.extraPotentialInits[i] = 0L;", "-\t\t\tthis.extraDefiniteNulls[i] = 0L;", "-\t\t\tthis.extraDefiniteNonNulls[i] = 0L;", "-\t\t}", "-\t\treturn this;"]}], "num": 61796}