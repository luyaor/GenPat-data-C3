{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "144e7ccd5a6e9ea05c2683b5b4b83d51", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "233cde874020355600c1791bfa6cd022", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java", "commitBeforeChange": "12fb3ecf388804aa7057e14bf4ec17ccc0ebc59e", "commitAfterChange": "0c07824a3373a555044221cb10d67e17d420e689", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " private void initializeKnownFileNames(String[] initialFileNames)", "signatureAfterChange": " private void initializeKnownFileNames(String[] initialFileNames)", "diff": ["+\t\tboolean globalPathMatches = false;", "+\t\t// the most nested path should be the selected one", "-\t\t\tif (this.classpaths[j] instanceof  ClasspathDirectory &&", "-\t\t\t\t\tCharOperation.prefixEquals(matchCandidate, fileName) &&", "-\t\t\t\t\t(matchingPathName == null ||", "-\t\t\t\t\t\t\tmatchCandidate.length < matchingPathName.length)) {", "-\t\t\t\tmatchingPathName = matchCandidate;", "+\t\t\tboolean currentPathMatch = false;", "+\t\t\tif (this.classpaths[j] instanceof ClasspathDirectory", "+\t\t\t\t\t&& CharOperation.prefixEquals(matchCandidate, fileName)) {", "+\t\t\t\tcurrentPathMatch = true;", "+\t\t\t\tif (matchingPathName == null) {", "+\t\t\t\t\tmatchingPathName = matchCandidate;", "+\t\t\t\t} else {", "+\t\t\t\t\tif (currentPathMatch) {", "+\t\t\t\t\t\t// we have a second source folder that matches the path of the source file", "+\t\t\t\t\t\tif (matchCandidate.length > matchingPathName.length) {", "+\t\t\t\t\t\t\t// we want to preserve the shortest possible path", "+\t\t\t\t\t\t\tmatchingPathName = matchCandidate;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// we want to preserve the shortest possible path", "+\t\t\t\t\t\tif (!globalPathMatches && matchCandidate.length < matchingPathName.length) {", "+\t\t\t\t\t\t\tmatchingPathName = matchCandidate;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (currentPathMatch) {", "+\t\t\t\t\tglobalPathMatches = true;", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6aee90dd99a16651b1dc18727403cc84", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java", "commitBeforeChange": "02828090e8fa6eaf7f602de6b5b4043352cd97df", "commitAfterChange": "59a2ec14c0a9b25e9570170a15536076cba7a855", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": "  \tprivate ASTNode internalCreateAST(IProgressMonitor monitor)", "signatureAfterChange": "  \tprivate ASTNode internalCreateAST(IProgressMonitor monitor)", "diff": ["+\t\t\t\tif (this.rawSource == null) {", "+\t\t\t\t\tif (this.typeRoot != null) {", "+\t\t\t\t\t\t// get the source from the type root", "+\t\t\t\t\t\tif (this.typeRoot instanceof ICompilationUnit) {", "+\t\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) this.typeRoot;", "+\t\t\t\t\t\t\tthis.rawSource = sourceUnit.getContents();", "+\t\t\t\t\t\t} else if (this.typeRoot instanceof IClassFile) {", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\tString sourceString = this.typeRoot.getSource();", "+\t\t\t\t\t\t\t\tif (sourceString != null) {", "+\t\t\t\t\t\t\t\t\tthis.rawSource = sourceString.toCharArray();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} catch(JavaModelException e) {", "+\t\t\t\t\t\t\t\t// an error occured accessing the java element", "+\t\t\t\t\t\t\t\tStringWriter stringWriter = new StringWriter();", "+\t\t\t\t\t\t\t\tPrintWriter writer = null;", "+\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\twriter = new PrintWriter(stringWriter);", "+\t\t\t\t\t\t\t\t\te.printStackTrace(writer);", "+\t\t\t\t\t\t\t\t} finally {", "+\t\t\t\t\t\t\t\t\tif (writer != null) writer.close();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tthrow new IllegalStateException(String.valueOf(stringWriter.getBuffer()));", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t\t\t    throw new IllegalStateException();", "+\t\t\t\t\t\tthrow new IllegalStateException();"]}], "num": 70226}