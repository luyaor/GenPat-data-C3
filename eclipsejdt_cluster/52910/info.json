{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "235a62974a1d1ac1a5325644840d7bed", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a7b76bd0b898c949cc8319dae802bdcf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "9fa4ee2d52d7a35a0c57f8c4b875f0f155754f75", "commitAfterChange": "330462fa1b1e3cc7e6b257e0a0f3470535bf4f54", "methodNumberBeforeChange": 58, "methodNumberAfterChange": 60, "signatureBeforeChange": " protected void reportAccurateParameterizedTypeReference(TypeReference typeRef, char[] name, int start, TypeReference[] typeArguments, IJavaElement element, int accuracy) throws CoreException", "signatureAfterChange": " protected void reportAccurateParameterizedTypeReference(TypeReference typeRef, int start, int index, TypeReference[] typeArguments, IJavaElement element, int accuracy, int rule) throws CoreException", "diff": ["-protected void reportAccurateParameterizedTypeReference(TypeReference typeRef, char[] name, int start, TypeReference[] typeArguments, IJavaElement element, int accuracy) throws CoreException {", "+protected void reportAccurateParameterizedTypeReference(TypeReference typeRef, int start, int index, TypeReference[] typeArguments, IJavaElement element, int accuracy, int rule) throws CoreException {", "-", "-\t\tscanner.resetTo(end, source.length-1);", "-\t\t// Set scanner position at end of last type argument", "-\t\tint depth = 0;", "-\t\tfor (int i=typeArguments.length-1; i>=0; i--) {", "-\t\t\tif (typeArguments[i] != null) {", "-\t\t\t\tdepth = resetScannerAfterLastTypeArgumentEnd(typeArguments[i], scanner, depth)+1;", "-\t\t\t\tbreak;", "+\t\t", "+\t\tJavaSearchPattern javaSearchPattern = (JavaSearchPattern)this.pattern;", "+\t\tif (javaSearchPattern.isErasureMatch || javaSearchPattern.typeSignatures == null) {", "+\t\t\t// if pattern is erasure only, then select the end of the reference", "+\t\t\tif (typeRef instanceof QualifiedTypeReference && index >= 0) {", "+\t\t\t\tlong[] positions = ((QualifiedTypeReference) typeRef).sourcePositions;", "+\t\t\t\tend = (int) positions[index];", "+\t\t\t} else if (typeRef instanceof ArrayTypeReference) {", "+\t\t\t\tend = ((ArrayTypeReference) typeRef).originalSourceEnd;", "-\t\t}", "-", "-\t\t// Now, scan to search next closing '>'", "-\t\twhile (depth-- > 0) {", "-\t\t\twhile (!scanner.atEnd()) {", "-\t\t\t\tif (scanner.getNextChar() == '>') {", "-\t\t\t\t\tend = scanner.currentPosition - 1;", "+\t\t}  else {", "+\t\t\t// Set scanner position at end of last type argument", "+\t\t\tscanner.resetTo(end, source.length-1);", "+\t\t\tint depth = 0;", "+\t\t\tfor (int i=typeArguments.length-1; i>=0; i--) {", "+\t\t\t\tif (typeArguments[i] != null) {", "+\t\t\t\t\tdepth = resetScannerAfterLastTypeArgumentEnd(typeArguments[i], scanner, depth)+1;", "-\t\t}", "+\t", "+\t\t\t// Now, scan to search next closing '>'", "+\t\t\twhile (depth-- > 0) {", "+\t\t\t\twhile (!scanner.atEnd()) {", "+\t\t\t\t\tif (scanner.getNextChar() == '>') {", "+\t\t\t\t\t\tend = scanner.currentPosition - 1;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t \t}", "-\tSearchMatch match = newTypeReferenceMatch(element, accuracy, start, end-start+1, typeRef);", "+\tSearchMatch match = newTypeReferenceMatch(element, accuracy, start, end-start+1, rule, typeRef);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c8b9acf7023f9669f2c503579810b189", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "4043b8a88c35a2c1612858cff67743727f25247b", "commitAfterChange": "6b8da2bd2bb1367c9817dbe3821476ed638f0906", "methodNumberBeforeChange": 58, "methodNumberAfterChange": 58, "signatureBeforeChange": " protected void reportAccurateParameterizedTypeReference(ASTNode typeRef, char[] name, IJavaElement element, int accuracy) throws CoreException", "signatureAfterChange": " protected void reportAccurateParameterizedTypeReference(TypeReference typeRef, char[] name, int start, TypeReference[] typeArguments, IJavaElement element, int accuracy) throws CoreException", "diff": ["-protected void reportAccurateParameterizedTypeReference(ASTNode typeRef, char[] name, IJavaElement element, int accuracy) throws CoreException {", "+protected void reportAccurateParameterizedTypeReference(TypeReference typeRef, char[] name, int start, TypeReference[] typeArguments, IJavaElement element, int accuracy) throws CoreException {", "-\t// compute source positions of the qualified reference ", "-\tScanner scanner = this.parser.scanner;", "-\tscanner.setSource(this.currentPossibleMatch.getContents());", "-\tint sourceStart = typeRef.sourceStart;", "-\tint sourceEnd = scanner.eofPosition;", "-\tscanner.resetTo(sourceStart, sourceEnd);", "+\t// If there's type arguments, look for end (ie. char '>') of last one.", "+\tint end = typeRef.sourceEnd;", "+\tif (typeArguments != null) {", "-\tint token = -1;", "-\tint currentPosition;", "-\tdo {", "-\t\tcurrentPosition = scanner.currentPosition;", "-\t\ttry {", "-\t\t\ttoken = scanner.getNextToken();", "-\t\t} catch (InvalidInputException e) {", "-\t\t\t// ignore", "+\t\t// Initialize scanner", "+\t\tScanner scanner = this.parser.scanner;", "+\t\tchar[] source = this.currentPossibleMatch.getContents();", "+\t\tscanner.setSource(source);", "+\t\tscanner.resetTo(end, source.length-1);", "+", "+\t\t// Set scanner position at end of last type argument", "+\t\tint depth = 0;", "+\t\tfor (int i=typeArguments.length-1; i>=0; i--) {", "+\t\t\tif (typeArguments[i] != null) {", "+\t\t\t\tdepth = resetScannerAfterLastTypeArgumentEnd(typeArguments[i], scanner, depth)+1;", "+\t\t\t\tbreak;", "+\t\t\t}", "-\t\tif (token == TerminalTokens.TokenNameIdentifier && this.pattern.matchesName(name, scanner.getCurrentTokenSource())) {", "-\t\t\t// extends selection end for parameterized types if necessary", "-\t\t\tint count = 0;", "-\t\t\tint ch = -1;", "-\t\t\twhile (ch != '>' || count > 0) {", "-\t\t\t\tch = scanner.getNextChar();", "-\t\t\t\tswitch (ch) {", "-\t\t\t\t\tcase '<':", "-\t\t\t\t\t\tcount++;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase '>':", "-\t\t\t\t\t\tcount--;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase -1:", "-\t\t\t\t\t\t// we missed type parameters declarations! => do not report match", "-\t\t\t\t\t\treturn;", "+", "+\t\t// Now, scan to search next closing '>'", "+\t\twhile (depth-- > 0) {", "+\t\t\twhile (!scanner.atEnd()) {", "+\t\t\t\tif (scanner.getNextChar() == '>') {", "+\t\t\t\t\tend = scanner.currentPosition - 1;", "+\t\t\t\t\tbreak;", "-\t\t\tint length = scanner.currentPosition-currentPosition;", "-\t\t\tSearchMatch match = newTypeReferenceMatch(element, accuracy, currentPosition, length, typeRef);", "-\t\t\treport(match);", "-\t\t\treturn;", "-\t} while (token != TerminalTokens.TokenNameEOF);", "-\tSearchMatch match = newTypeReferenceMatch(element, accuracy, sourceStart, sourceEnd-sourceStart+1, typeRef);", "+\t}", "+\t", "+\t// Report match", "+\tSearchMatch match = newTypeReferenceMatch(element, accuracy, start, end-start+1, typeRef);"]}], "num": 52910}