{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e52df35fe0da2a9ee1ad37245ebe6cdd", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0233bbb3573c386a88c98a16c20f8d39", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/FactoryPathConfigurationBlock.java", "commitBeforeChange": "b8409b2c5761cb2e6dbcdfc3bef92e6e755d2aa7", "commitAfterChange": "e968b992e38be58d07a46d70f656322d8b2edb33", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \t \tpublic boolean performApply()", "signatureAfterChange": " \tprivate boolean settingsChanged()", "diff": ["-\tpublic boolean performApply() {", "-\t\tsaveContainers();", "-\t\treturn super.performApply();", "+\t */", "+\tprivate boolean settingsChanged() {", "+\t\tboolean isProjectSpecific= (fJProj != null) && fBlockControl.getEnabled();", "+\t\tif (fOriginallyProjectSpecific ^ isProjectSpecific) {", "+\t\t\t// the project-specificness changed.", "+\t\t\treturn true;", "+\t\t} else if ((fJProj != null) && !isProjectSpecific) {", "+\t\t\t// no project specific data, and there never was, so nothing could have changed.", "+\t\t\treturn false;", "+\t\t}", "+\t\tint count = fFactoryPathList.getSize();", "+\t\tif (fOriginalPath.size() != count) {", "+\t\t\t// something was added or removed", "+\t\t\treturn true;", "+\t\t}", "+\t\t// now we know both lists are the same size", "+\t\tIterator<Map.Entry<FactoryContainer, Boolean>> iOriginal = fOriginalPath.entrySet().iterator();", "+\t\tfor (int i = 0; i < count; ++i) {", "+\t\t\tMap.Entry<FactoryContainer, Boolean> entry = iOriginal.next();", "+\t\t\tBoolean wasEnabled = entry.getValue();", "+\t\t\tFactoryContainer fc = (FactoryContainer)fFactoryPathList.getElement(i);", "+\t\t\tif (!fc.equals(entry.getKey())) {", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\tBoolean isEnabled = fFactoryPathList.isChecked(fc);", "+\t\t\tif (isEnabled ^ wasEnabled) {", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t}", "+\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "77f80f1e39eaaa0f58ac3d76fa5e5441", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java", "commitBeforeChange": "4f20574f1c28798f17471aa0877376caa5cbe832", "commitAfterChange": "40c99687ccd3cd2f32c7182f6dd3a3815c599017", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, String path, AccessRestriction access)", "signatureAfterChange": " public void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, String path, AccessRestriction access)", "diff": ["-\t\tint separatorIndex= path.indexOf(IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR);", "-\t\tIType type = separatorIndex == -1", "-\t\t\t? createTypeFromPath(path, new String(simpleTypeName), enclosingTypeNames)", "-\t\t\t: createTypeFromJar(path, separatorIndex);", "+\t\tIType type = null;", "+\t\tif (this.handleFactory != null) {", "+\t\t\tOpenable openable = this.handleFactory.createOpenable(path, this.scope);", "+\t\t\tif (openable == null) return;", "+\t\t\tswitch (openable.getElementType()) {", "+\t\t\t\tcase IJavaElement.COMPILATION_UNIT:", "+\t\t\t\t\tICompilationUnit cu = (ICompilationUnit) openable;", "+\t\t\t\t\tif (enclosingTypeNames != null && enclosingTypeNames.length > 0) {", "+\t\t\t\t\t\ttype = cu.getType(new String(enclosingTypeNames[0]));", "+\t\t\t\t\t\tfor (int j=1, l=enclosingTypeNames.length; j<l; j++) {", "+\t\t\t\t\t\t\ttype = type.getType(new String(enclosingTypeNames[j]));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\ttype = cu.getType(new String(simpleTypeName));", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IJavaElement.CLASS_FILE:", "+\t\t\t\t\ttype = ((IClassFile)openable).getType();", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t} else {", "+\t\t\tint separatorIndex= path.indexOf(IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR);", "+\t\t\ttype = separatorIndex == -1", "+\t\t\t\t? createTypeFromPath(path, new String(simpleTypeName), enclosingTypeNames)", "+\t\t\t\t: createTypeFromJar(path, separatorIndex);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d8b355a745642f7b7a5b0055e34c702c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/BindingKeyResolver.java", "commitBeforeChange": "c117a64cdf0af5bb1016a70197fdaaecfa29c6f9", "commitAfterChange": "f27e1412cdba4e953d571d1998376687a4c5af71", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \t \tpublic void consumeCapture()", "signatureAfterChange": " \t \tpublic void consumeCapture(final int position)", "diff": ["-\tpublic void consumeCapture() {", "-\t\tthis.isCapture = true;", "+\tpublic void consumeCapture(final int position) {", "+\t\tif (this.parsedUnit == null) return;", "+\t\tclass CaptureFinder extends ASTVisitor {", "+\t\t\tBinding parameterizedTypeBinding;", "+\t\t\tpublic boolean visit(SingleNameReference singleNameReference, BlockScope blockScope) {", "+\t\t\t\tif (singleNameReference.sourceEnd == position) {", "+\t\t\t\t\tthis.parameterizedTypeBinding = singleNameReference.resolvedType;", "+\t\t\t\t\treturn false;", "+\t\t\t\t} ", "+\t\t\t\treturn super.visit(singleNameReference, blockScope);", "+\t\t\t}", "+\t\t\tpublic boolean visit(QualifiedNameReference qualifiedNameReference, BlockScope blockScope) {", "+\t\t\t\tif (qualifiedNameReference.sourceEnd == position) {", "+\t\t\t\t\tthis.parameterizedTypeBinding = qualifiedNameReference.resolvedType;", "+\t\t\t\t\treturn false;", "+\t\t\t\t} ", "+\t\t\t\treturn super.visit(qualifiedNameReference, blockScope);", "+\t\t\t}", "+\t\t\tpublic boolean visit(MessageSend messageSend, BlockScope blockScope) {", "+\t\t\t\tif (messageSend.sourceEnd == position) {", "+\t\t\t\t\tthis.parameterizedTypeBinding = messageSend.resolvedType;", "+\t\t\t\t\treturn false;", "+\t\t\t\t} ", "+\t\t\t\treturn super.visit(messageSend, blockScope);", "+\t\t\t}", "+\t\t\tpublic boolean visit(FieldReference fieldReference, BlockScope blockScope) {", "+\t\t\t\tif (fieldReference.sourceEnd == position) {", "+\t\t\t\t\tthis.parameterizedTypeBinding = fieldReference.resolvedType;", "+\t\t\t\t\treturn false;", "+\t\t\t\t} ", "+\t\t\t\treturn super.visit(fieldReference, blockScope);", "+\t\t\t}", "+\t\t\tpublic boolean visit(ConditionalExpression conditionalExpression, BlockScope blockScope) {", "+\t\t\t\tif (conditionalExpression.sourceEnd == position) {", "+\t\t\t\t\tthis.parameterizedTypeBinding = conditionalExpression.resolvedType;", "+\t\t\t\t\treturn false;", "+\t\t\t\t} ", "+\t\t\t\treturn super.visit(conditionalExpression, blockScope);", "+\t\t\t}", "+\t\t\tpublic boolean visit(CastExpression castExpression, BlockScope blockScope) {", "+\t\t\t\tif (castExpression.sourceEnd == position) {", "+\t\t\t\t\tthis.parameterizedTypeBinding = castExpression.resolvedType;", "+\t\t\t\t\treturn false;", "+\t\t\t\t} ", "+\t\t\t\treturn super.visit(castExpression, blockScope);", "+\t\t\t}", "+\t\t\tpublic boolean visit(Assignment assignment, BlockScope blockScope) {", "+\t\t\t\tif (assignment.sourceEnd == position) {", "+\t\t\t\t\tthis.parameterizedTypeBinding = assignment.resolvedType;", "+\t\t\t\t\treturn false;", "+\t\t\t\t} ", "+\t\t\t\treturn super.visit(assignment, blockScope);", "+\t\t\t}", "+\t\t\tpublic boolean visit(ArrayReference arrayReference, BlockScope blockScope) {", "+\t\t\t\tif (arrayReference.sourceEnd == position) {", "+\t\t\t\t\tthis.parameterizedTypeBinding = arrayReference.resolvedType;", "+\t\t\t\t\treturn false;", "+\t\t\t\t} ", "+\t\t\t\treturn super.visit(arrayReference, blockScope);", "+\t\t\t}", "+\t\t}", "+\t\tCaptureFinder captureFinder = new CaptureFinder();", "+\t\tthis.parsedUnit.traverse(captureFinder, this.parsedUnit.scope);", "+\t\tif (!(captureFinder.parameterizedTypeBinding instanceof ParameterizedTypeBinding))", "+\t\t\treturn;", "+\t\tTypeBinding[] arguments = ((ParameterizedTypeBinding) captureFinder.parameterizedTypeBinding).arguments;", "+\t\tif (arguments == null) return;", "+\t\tBinding wildcardBinding = ((BindingKeyResolver) this.types.get(0)).compilerBinding;", "+\t\tfor (int i = 0, length = arguments.length; i < length; i++) {", "+\t\t\tTypeBinding binding = arguments[i];", "+\t\t\tif (binding instanceof CaptureBinding) {", "+\t\t\t\tCaptureBinding captureBinding = (CaptureBinding) binding;", "+\t\t\t\tif (captureBinding.wildcard == wildcardBinding && captureBinding.sourceType == this.typeBinding) {", "+\t\t\t\t\tthis.compilerBinding = binding;", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ddd79d1e934e7f5c8d84583cc84355dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "46bb2fc11bd9440d4fff5ca5f3078f9c39a1d152", "commitAfterChange": "cc1ae7d3e1f618e7e804996cc901b77df44b4213", "methodNumberBeforeChange": 67, "methodNumberAfterChange": 67, "signatureBeforeChange": " protected void reportMatching(CompilationUnitDeclaration unit, boolean mustResolve) throws CoreException", "signatureAfterChange": " protected void reportMatching(CompilationUnitDeclaration unit, boolean mustResolve) throws CoreException", "diff": ["+", "+\t// report references in javadoc", "+\tif (unit.javadoc != null) {", "+\t\tASTNode[] nodes = nodeSet.matchingNodes(unit.javadoc.sourceStart, unit.javadoc.sourceEnd);", "+\t\tif (nodes != null) {", "+\t\t\tif (!matchedUnitContainer) {", "+\t\t\t\tfor (int i = 0, l = nodes.length; i < l; i++)", "+\t\t\t\t\tnodeSet.matchingNodes.removeKey(nodes[i]);", "+\t\t\t} else {", "+\t\t\t\tIJavaElement element = createTypeHandle(new String(unit.getMainTypeName()));", "+\t\t\t\tfor (int i = 0, l = nodes.length; i < l; i++) {", "+\t\t\t\t\tASTNode node = nodes[i];", "+\t\t\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(node);", "+\t\t\t\t\tif (encloses(element))", "+\t\t\t\t\t\tthis.patternLocator.matchReportReference(node, element, null/*no binding*/, level.intValue(), this);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e0e5c719db4bb9a0568650d6fbc2573a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "82dc67de142f757f6098e678017a2b32f752c9b7", "commitAfterChange": "5249d37677c0ce4d66ab262efb5c3dd4aa089796", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public void abstractMethodInAbstractClass(SourceTypeBinding type, AbstractMethodDeclaration methodDecl)", "signatureAfterChange": " public void abstractMethodInAbstractClass(SourceTypeBinding type, MethodBinding[] abstractMethods)", "diff": ["-public void abstractMethodInAbstractClass(SourceTypeBinding type, AbstractMethodDeclaration methodDecl) {", "-", "-\tString[] arguments = new String[] {new String(type.sourceName()), new String(methodDecl.selector)};", "-\tthis.handle(", "-\t\tIProblem.AbstractMethodInAbstractClass,", "-\t\targuments,", "-\t\targuments,", "-\t\tmethodDecl.sourceStart,", "-\t\tmethodDecl.sourceEnd);", "+public void abstractMethodInAbstractClass(SourceTypeBinding type, MethodBinding[] abstractMethods) {", "+\tif (type.isEnum() && type.isLocalType()) {", "+\t\tFieldBinding field = type.scope.enclosingMethodScope().initializedField;", "+\t\tFieldDeclaration decl = field.sourceField();", "+\t\tString[] arguments = new String[] {new String(decl.name)};", "+\t\tthis.handle(", "+\t\t\tIProblem.EnumConstantCannotDefineAbstractMethod,", "+\t\t\targuments,", "+\t\t\targuments,", "+\t\t\tdecl.sourceStart(),", "+\t\t\tdecl.sourceEnd());", "+\t} else {", "+\t\tStringBuffer selectorsString = new StringBuffer();", "+\t\tfor (int i = 0, l = abstractMethods.length; i < l;) {", "+\t\t\tMethodBinding abstractMethod = abstractMethods[i++];", "+\t\t\tselectorsString.append(abstractMethod.selector);", "+\t\t\tselectorsString.append(\"()\"); //$NON-NLS-1$", "+\t\t\tif (i < l)", "+\t\t\t\tselectorsString.append(\", \"); //$NON-NLS-1$", "+\t\t}", "+\t\tString[] arguments = new String[] {new String(type.sourceName()), selectorsString.toString()};", "+\t\tthis.handle(", "+\t\t\tIProblem.AbstractMethodInAbstractClass,", "+\t\t\targuments,", "+\t\t\targuments,", "+\t\t\ttype.sourceStart(),", "+\t\t\ttype.sourceEnd());", "+\t}"]}], "num": 61564}