{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bc89a86f26d5f77014bf2b217aead0a3", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b93f24d9cb214bf9abc2b67e1894c4b3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "3a7eebe0921eeefbdbf1fe4891891b6335310197", "commitAfterChange": "e8aa72d0e85424c76c1185b7518db6803dde6255", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \t \tpublic void generateOptimizedStringConcatenation( \t\tBlockScope blockScope, \t\tCodeStream codeStream, \t\tint typeID)", "signatureAfterChange": "  public void generateOptimizedStringConcatenation(BlockScope blockScope, CodeStream codeStream, int typeID)", "diff": ["-\t", "-\tpublic void generateOptimizedStringConcatenation(", "-\t\tBlockScope blockScope,", "-\t\tCodeStream codeStream,", "-\t\tint typeID) {", "-\t\t\t", "-\t\t/* In the case trying to make a string concatenation, there is no need to create a new", "-\t\t * string buffer, thus use a lower-level API for code generation involving only the", "-\t\t * appending of arguments to the existing StringBuffer", "-\t\t */", "-\t\tif ((((bits & OperatorMASK) >> OperatorSHIFT) == PLUS)", "-\t\t\t&& ((bits & ReturnTypeIDMASK) == T_JavaLangString)) {", "-\t\t\tif (constant != Constant.NotAConstant) {", "-\t\t\t\tcodeStream.generateConstant(constant, implicitConversion);", "-\t\t\t\tcodeStream.invokeStringConcatenationAppendForType(implicitConversion & COMPILE_TYPE_MASK);", "-\t\t\t\tint pc = codeStream.position;", "-\t\t\t\tleft.generateOptimizedStringConcatenation(", "-\t\t\t\t\tblockScope,", "-\t\t\t\t\tleft.implicitConversion & COMPILE_TYPE_MASK);", "-\t\t\t\tcodeStream.recordPositionsFrom(pc, left.sourceStart);", "-\t\t\t\tpc = codeStream.position;", "-\t\t\t\tright.generateOptimizedStringConcatenation(", "-\t\t\t\t\tblockScope,", "-\t\t\t\t\tright.implicitConversion & COMPILE_TYPE_MASK);", "-\t\t\t\tcodeStream.recordPositionsFrom(pc, right.sourceStart);", "-\t\t\tsuper.generateOptimizedStringConcatenation(blockScope, codeStream, typeID);", "+", "+public void generateOptimizedStringConcatenation(BlockScope blockScope, CodeStream codeStream, int typeID) {", "+\t\t", "+\t/* In the case trying to make a string concatenation, there is no need to create a new", "+\t * string buffer, thus use a lower-level API for code generation involving only the", "+\t * appending of arguments to the existing StringBuffer", "+\t */", "+", "+\tif ((((this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) == OperatorIds.PLUS)", "+\t\t&& ((this.bits & ASTNode.ReturnTypeIDMASK) == TypeIds.T_JavaLangString)) {", "+\t\tif (this.constant != Constant.NotAConstant) {", "+\t\t\tcodeStream.generateConstant(this.constant, this.implicitConversion);", "+\t\t\tcodeStream.invokeStringConcatenationAppendForType(this.implicitConversion & TypeIds.COMPILE_TYPE_MASK);", "+\t\t} else {", "+\t\t\tint pc = codeStream.position;", "+\t\t\tthis.left.generateOptimizedStringConcatenation(", "+\t\t\t\tblockScope,", "+\t\t\t\tcodeStream,", "+\t\t\t\tthis.left.implicitConversion & TypeIds.COMPILE_TYPE_MASK);", "+\t\t\tcodeStream.recordPositionsFrom(pc, this.left.sourceStart);", "+\t\t\tpc = codeStream.position;", "+\t\t\tthis.right.generateOptimizedStringConcatenation(", "+\t\t\t\tblockScope,", "+\t\t\t\tcodeStream,", "+\t\t\t\tthis.right.implicitConversion & TypeIds.COMPILE_TYPE_MASK);", "+\t\t\tcodeStream.recordPositionsFrom(pc, this.right.sourceStart);", "+\t\t}", "+\t} else {", "+\t\tsuper.generateOptimizedStringConcatenation(blockScope, codeStream, typeID);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ddac8885ff7c39fd951e8891b4b21536", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "3a7eebe0921eeefbdbf1fe4891891b6335310197", "commitAfterChange": "e8aa72d0e85424c76c1185b7518db6803dde6255", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t \tpublic void generateOptimizedStringConcatenationCreation( \t\tBlockScope blockScope, \t\tCodeStream codeStream, \t\tint typeID)", "signatureAfterChange": "  public void generateOptimizedStringConcatenationCreation(BlockScope blockScope, CodeStream codeStream, int typeID)", "diff": ["-\t", "-\tpublic void generateOptimizedStringConcatenationCreation(", "-\t\tBlockScope blockScope,", "-\t\tCodeStream codeStream,", "-\t\tint typeID) {", "-\t\t\t", "-\t\t/* In the case trying to make a string concatenation, there is no need to create a new", "-\t\t * string buffer, thus use a lower-level API for code generation involving only the ", "-\t\t * appending of arguments to the existing StringBuffer", "-\t\t */", "-\t\tif ((((bits & OperatorMASK) >> OperatorSHIFT) == PLUS)", "-\t\t\t&& ((bits & ReturnTypeIDMASK) == T_JavaLangString)) {", "-\t\t\tif (constant != Constant.NotAConstant) {", "-\t\t\t\tcodeStream.newStringContatenation(); // new: java.lang.StringBuffer", "-\t\t\t\tcodeStream.dup();", "-\t\t\t\tcodeStream.ldc(constant.stringValue());", "-\t\t\t\tcodeStream.invokeStringConcatenationStringConstructor();", "-\t\t\t\t// invokespecial: java.lang.StringBuffer.<init>(Ljava.lang.String;)V", "-\t\t\t\tint pc = codeStream.position;", "-\t\t\t\tleft.generateOptimizedStringConcatenationCreation(", "-\t\t\t\t\tblockScope,", "-\t\t\t\t\tleft.implicitConversion & COMPILE_TYPE_MASK);", "-\t\t\t\tcodeStream.recordPositionsFrom(pc, left.sourceStart);", "-\t\t\t\tpc = codeStream.position;", "-\t\t\t\tright.generateOptimizedStringConcatenation(", "-\t\t\t\t\tblockScope,", "-\t\t\t\t\tright.implicitConversion & COMPILE_TYPE_MASK);", "-\t\t\t\tcodeStream.recordPositionsFrom(pc, right.sourceStart);", "-\t\t\tsuper.generateOptimizedStringConcatenationCreation(blockScope, codeStream, typeID);", "+", "+public void generateOptimizedStringConcatenationCreation(BlockScope blockScope, CodeStream codeStream, int typeID) {", "+\t\t", "+\t/* In the case trying to make a string concatenation, there is no need to create a new", "+\t * string buffer, thus use a lower-level API for code generation involving only the ", "+\t * appending of arguments to the existing StringBuffer", "+\t */", "+", "+\tif ((((this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) == OperatorIds.PLUS)", "+\t\t&& ((this.bits & ASTNode.ReturnTypeIDMASK) == TypeIds.T_JavaLangString)) {", "+\t\tif (this.constant != Constant.NotAConstant) {", "+\t\t\tcodeStream.newStringContatenation(); // new: java.lang.StringBuffer", "+\t\t\tcodeStream.dup();", "+\t\t\tcodeStream.ldc(this.constant.stringValue());", "+\t\t\tcodeStream.invokeStringConcatenationStringConstructor();", "+\t\t\t// invokespecial: java.lang.StringBuffer.<init>(Ljava.lang.String;)V", "+\t\t} else {", "+\t\t\tint pc = codeStream.position;", "+\t\t\tthis.left.generateOptimizedStringConcatenationCreation(", "+\t\t\t\tblockScope,", "+\t\t\t\tcodeStream,", "+\t\t\t\tthis.left.implicitConversion & TypeIds.COMPILE_TYPE_MASK);", "+\t\t\tcodeStream.recordPositionsFrom(pc, this.left.sourceStart);", "+\t\t\tpc = codeStream.position;", "+\t\t\tthis.right.generateOptimizedStringConcatenation(", "+\t\t\t\tblockScope,", "+\t\t\t\tcodeStream,", "+\t\t\t\tthis.right.implicitConversion & TypeIds.COMPILE_TYPE_MASK);", "+\t\t\tcodeStream.recordPositionsFrom(pc, this.right.sourceStart);", "+\t\t}", "+\t} else {", "+\t\tsuper.generateOptimizedStringConcatenationCreation(blockScope, codeStream, typeID);", "+\t}", "+}"]}], "num": 71949}