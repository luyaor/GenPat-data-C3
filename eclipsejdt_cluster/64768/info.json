{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "72cf5e5c866d926f719913a7a1df1931", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2a15441a0d50da7607e381b7503d5bfc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "5d2cd7f1076b45eee90e6733e80765abd1df3d6a", "commitAfterChange": "14e86a8141996732826e41cf3c8dd392bb1fd5ba", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 38, "signatureBeforeChange": " \tprivate void performPreBuildCheck( \t\tIResourceDelta delta, \t\tIJavaElement parent)", "signatureAfterChange": " \tprivate void performPreBuildCheck(IResourceDelta delta, Map preferredClasspaths, Map preferredOutputs)", "diff": ["-\tprivate void performPreBuildCheck(", "-\t\tIResourceDelta delta,", "-\t\tIJavaElement parent) {", "-\t", "+\tprivate void performPreBuildCheck(IResourceDelta delta, Map preferredClasspaths, Map preferredOutputs) {", "-\t\tIJavaElement element = null;", "-\t", "+\t\t", "-\t\t\t\t\telement = JavaCore.create(resource);", "+\t\t\t\tIProject project = (IProject)resource;", "+\t\t\t\tboolean isJavaProject = JavaProject.hasJavaNature(project);", "+\t\t\t\t\tcase IResourceDelta.ADDED:", "+\t\t\t\t\t\tprocessChildren = isJavaProject;", "+\t\t\t\t\t\tthis.rootsToRefresh.add(project.getFullPath());", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t// do not visit non-java projects (see bug 16140 Non-java project gets .classpath)", "-\t\t\t\t\t\tIProject project = (IProject)resource;", "-\t\t\t\t\t\tif (JavaProject.hasJavaNature(project)) {", "-\t\t\t\t\t\t\telement = JavaCore.create(resource);", "-\t\t\t\t\t\t\tprocessChildren = true;", "-\t\t\t\t\t\t} else if (this.manager.getJavaModel().findJavaProject(project) != null) {", "-\t\t\t\t\t\t\t// project had the java nature", "-\t\t\t\t\t\t\tthis.state.rootsAreStale = true;", "-", "-\t\t\t\t\t\t\t// remove classpath cache so that initializeRoots() will not consider the project has a classpath", "-\t\t\t\t\t\t\tthis.manager.removePerProjectInfo((JavaProject)JavaCore.create(project));", "+\t\t\t\t\t\tprocessChildren = isJavaProject;", "+\t\t\t\t\t\tif ((delta.getFlags() & IResourceDelta.OPEN) != 0) {", "+\t\t\t\t\t\t\t// project opened or closed: remember  project and its dependents", "+\t\t\t\t\t\t\tthis.rootsToRefresh.add(project.getFullPath());", "+\t\t\t\t\t\t\tif (isJavaProject) {", "+\t\t\t\t\t\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(project);", "+\t\t\t\t\t\t\t\tjavaProject.updateClasspathMarkers(preferredClasspaths, preferredOutputs); // in case .classpath got modified while closed", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if ((delta.getFlags() & IResourceDelta.DESCRIPTION) != 0) {", "+\t\t\t\t\t\t\tif (!JavaProject.hasJavaNature(project)) {", "+\t\t\t\t\t\t\t\t// project no longer has Java nature, discard Java related obsolete markers", "+\t\t\t\t\t\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(project);", "+\t\t\t\t\t\t\t\tthis.rootsToRefresh.add(project.getFullPath());", "+\t\t\t\t\t\t\t\t// flush classpath markers", "+\t\t\t\t\t\t\t\tjavaProject.", "+\t\t\t\t\t\t\t\t\tflushClasspathProblemMarkers(", "+\t\t\t\t\t\t\t\t\t\ttrue, // flush cycle markers", "+\t\t\t\t\t\t\t\t\t\ttrue  //flush classpath format markers", "+\t\t\t\t\t\t\t\t\t);", "+\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t// remove problems and tasks created  by the builder", "+\t\t\t\t\t\t\t\tJavaBuilder.removeProblemsAndTasksFor(project);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\tcase IResourceDelta.ADDED:", "-\t\t\t\t\t\tthis.state.rootsAreStale = true;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t// remove classpath cache so that initializeRoots() will not consider the project has a classpath", "-\t\t\t\t\t\tthis.manager.removePerProjectInfo((JavaProject)JavaCore.create(resource));", "-\t\t\t\t\t\tthis.state.rootsAreStale = true;", "+\t\t\t\t\t\tthis.rootsToRefresh.add(project.getFullPath());", "-\t\t\t\tif (parent.getElementType() == IJavaElement.JAVA_PROJECT) {", "-\t\t\t\t\tIFile file = (IFile) resource;", "-\t\t\t\t\tJavaProject project = (JavaProject) parent;", "-\t", "-\t\t\t\t\t/* check classpath file change */", "-\t\t\t\t\tif (file.getName().equals(JavaProject.CLASSPATH_FILENAME)) {", "-\t\t\t\t\t\treconcileClasspathFileUpdate(delta, project);", "-\t\t\t\t\t\tthis.state.rootsAreStale = true;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-//\t\t\t\t\t/* check custom preference file change */", "-//\t\t\t\t\tif (file.getName().equals(JavaProject.PREF_FILENAME)) {", "-//\t\t\t\t\t\treconcilePreferenceFileUpdate(delta, file, project);", "-//\t\t\t\t\t\tbreak;", "-//\t\t\t\t\t}", "+\t\t\t\t/* check classpath file change */", "+\t\t\t\tIFile file = (IFile) resource;", "+\t\t\t\tif (file.getName().equals(JavaProject.CLASSPATH_FILENAME)) {", "+\t\t\t\t\tthis.rootsToRefresh.add(file.getProject().getFullPath());", "+\t\t\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(file.getProject());", "+\t\t\t\t\tjavaProject.updateClasspathMarkers(preferredClasspaths, preferredOutputs);", "+\t\t\t\t\tbreak;", "+//\t\t\t\t/* check custom preference file change */", "+//\t\t\t\tif (file.getName().equals(JavaProject.PREF_FILENAME)) {", "+//\t\t\t\t\treconcilePreferenceFileUpdate(delta, file, project);", "+//\t\t\t\t\tbreak;", "+//\t\t\t\t}", "-\t\t\t\tperformPreBuildCheck(children[i], element);", "+\t\t\t\tperformPreBuildCheck(children[i], preferredClasspaths, preferredOutputs);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66b2717cc16b0b1286c8f8afe5ed26d0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tpublic void manageSyntheticWriteAccessIfNecessary( \t\t\tBlockScope currentScope, \t\t\tFieldBinding fieldBinding, \t\t\tTypeBinding lastReceiverType, \t\t\tFlowInfo flowInfo)", "signatureAfterChange": " \tpublic void manageSyntheticAccessIfNecessary( \t\t\tBlockScope currentScope, \t\t\tFieldBinding fieldBinding, \t\t\tTypeBinding lastReceiverType, \t\t\tint index, \t\t\tFlowInfo flowInfo)", "diff": ["+\t */", "+\tpublic void manageSyntheticAccessIfNecessary(", "+\t    ", "+\t\t// index == 0 denotes the first fieldBinding, index > 0 denotes one of the 'otherBindings', index < 0 denotes a write access (to last binding)", "+", "+\t\t// if field from parameterized type got found, use the original field at codegen time", "+\t\tif (fieldBinding instanceof ParameterizedFieldBinding) {", "+\t\t    ParameterizedFieldBinding parameterizedField = (ParameterizedFieldBinding) fieldBinding;", "+\t\t    FieldBinding originalField = parameterizedField.originalField;", "+\t\t    TypeBinding requiredGenericCast = null;", "+\t\t    // extra cast needed if field type was type variable", "+\t\t    if ((originalField.type.tagBits & TagBits.HasTypeVariable) != 0) {", "+\t\t        requiredGenericCast = originalField.type.genericCast(parameterizedField.type);", "+\t\t    }\t\t    ", "+\t\t    setCodegenBinding(fieldBinding, index, originalField, requiredGenericCast);", "+\t\t}", "+\t\t", "+\t\t\t    FieldBinding someCodegenBinding = getCodegenBinding(fieldBinding, index);", "+\t\t\t    setSyntheticAccessor(fieldBinding, index, ", "+\t\t\t            ((SourceTypeBinding) fieldBinding.declaringClass).addSyntheticMethod(someCodegenBinding, index >= 0 /*read-access?*/));", "+\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(someCodegenBinding, this, index >= 0 /*read-access?*/);", "-\t */", "-\tpublic void manageSyntheticWriteAccessIfNecessary(", "-\t\t\tBlockScope currentScope,", "-\t\t\tFieldBinding fieldBinding,", "-\t\t\tTypeBinding lastReceiverType,", "-\t\t\tFlowInfo flowInfo) {", "-\t\tif (!flowInfo.isReachable()) return;", "-\t\tif (fieldBinding.isPrivate()) {", "-\t\t\tif (fieldBinding.declaringClass != currentScope.enclosingSourceType()) {", "-\t\t\t\tsyntheticWriteAccessor = ((SourceTypeBinding) fieldBinding.declaringClass)", "-\t\t\t\t\t\t\t\t\t\t\t.addSyntheticMethod(fieldBinding, false);", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldWriteAccess(fieldBinding, this);", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t} else if (fieldBinding.isProtected()){", "-\t\t\tint depth = fieldBinding == binding ? (bits & DepthMASK) >> DepthSHIFT : otherDepths[otherDepths.length-1];", "-\t\t\tif (depth > 0 && (fieldBinding.declaringClass.getPackage()", "-\t\t\t\t\t\t\t\t!= currentScope.enclosingSourceType().getPackage())) {", "-\t\t\t\tsyntheticWriteAccessor = ((SourceTypeBinding) currentScope.enclosingSourceType().enclosingTypeAt(depth))", "-\t\t\t\t\t\t\t\t\t\t\t.addSyntheticMethod(fieldBinding, false);", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldWriteAccess(fieldBinding, this);", "+\t\t    int depth = fieldBinding == binding ", "+\t\t    \t\t? (bits & DepthMASK) >> DepthSHIFT ", "+\t\t    \t\t : otherDepths[index < 0 ? otherDepths.length-1 : index-1];", "+\t\t\t", "+\t\t\t// implicit protected access ", "+\t\t\tif (depth > 0 && (fieldBinding.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage())) {", "+\t\t\t    FieldBinding someCodegenBinding = getCodegenBinding(fieldBinding, index);", "+\t\t\t    setSyntheticAccessor(fieldBinding, index, ", "+\t\t\t            ((SourceTypeBinding) currentScope.enclosingSourceType().enclosingTypeAt(depth)).addSyntheticMethod(someCodegenBinding, index >= 0 /*read-access?*/));", "+\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(someCodegenBinding, this, index >= 0 /*read-access?*/);", "-\t\t\tif (fieldBinding == binding){", "-\t\t\t\tthis.codegenBinding = currentScope.enclosingSourceType().getUpdatedFieldBinding(fieldBinding, (ReferenceBinding)lastReceiverType);", "-\t\t\t} else {", "-\t\t\t\tif (this.otherCodegenBindings == this.otherBindings){", "-\t\t\t\t\tint l = this.otherBindings.length;", "-\t\t\t\t\tSystem.arraycopy(this.otherBindings, 0, this.otherCodegenBindings = new FieldBinding[l], 0, l);", "-\t\t\t\t}", "-\t\t\t\tthis.otherCodegenBindings[this.otherCodegenBindings.length-1] = currentScope.enclosingSourceType().getUpdatedFieldBinding(fieldBinding, (ReferenceBinding)lastReceiverType);", "-\t\t\t}", "+\t\t    setCodegenBinding(", "+\t\t            fieldBinding, ", "+\t\t            index, ", "+\t\t            currentScope.enclosingSourceType().getUpdatedFieldBinding(", "+\t\t                    getCodegenBinding(fieldBinding, index), ", "+\t\t                    (ReferenceBinding)lastReceiverType.erasure()), ", "+\t\t         \tnull/*reuse existing*/);", "-\t\t"]}], "num": 64768}