{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fea04cfdd2e4d56236f4011d4c727d82", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26eadb27af8360fd83a873bfe1327308", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "ec8e689e69ce65d5a3f127f9c7126c4bebdd7b60", "commitAfterChange": "c922c60b9bc5fcda7fb9f2a477eba6f8f95a6cf9", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 20, "signatureBeforeChange": "  \tprivate void resolve(ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner, IProgressMonitor monitor)", "signatureAfterChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner, IProgressMonitor monitor)", "diff": ["-\tprivate void resolve(ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner, IProgressMonitor monitor) {", "-", "-\t\tDefaultBindingResolver.BindingTables bindingTables = new DefaultBindingResolver.BindingTables();", "+\tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner, IProgressMonitor monitor) {", "+\t", "+\t\tastRequestor.compilationUnitResolver = this;", "+\t\tthis.bindingTables = new DefaultBindingResolver.BindingTables();", "-\t\t\tICompilationUnit[] workingCopies = astRequestor.getSources();", "-\t\t\tif (workingCopies == null) return;", "-\t\t\tint length = workingCopies.length;", "+\t\t\tint length = compilationUnits.length;", "-\t\t\tSystem.arraycopy(workingCopies, 0, sourceUnits, 0, length);", "-\t\t\tbeginToCompile(sourceUnits);", "+\t\t\tSystem.arraycopy(compilationUnits, 0, sourceUnits, 0, length);", "+\t\t\tbeginToCompile(sourceUnits, bindingKeys);", "-\t\t\t\t\t// convert AST", "-\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "-\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "-\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "-\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "-\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "-\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, monitor);", "-\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, bindingTables);", "-\t\t\t\t\tast.setBindingResolver(resolver);", "-\t\t\t\t\tconverter.setAST(ast);", "-\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "-\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.lineSeparatorPositions);", "-\t\t\t\t\tast.setDefaultNodeFlag(0);", "-\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "+\t\t\t\t\tICompilationUnit source = (ICompilationUnit) this.requestedSources.removeKey(unit.compilationResult.getFileName());", "+\t\t\t\t\tif (source != null) {", "+\t\t\t\t\t\t// convert AST", "+\t\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "+\t\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "+\t\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "+\t\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "+\t\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, monitor);", "+\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables, this);", "+\t\t\t\t\t\tast.setBindingResolver(resolver);", "+\t\t\t\t\t\tconverter.setAST(ast);", "+\t\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "+\t\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.lineSeparatorPositions);", "+\t\t\t\t\t\tast.setDefaultNodeFlag(0);", "+\t\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "+\t\t\t\t\t\t", "+\t\t\t\t\t\t// pass it to requestor", "+\t\t\t\t\t\tastRequestor.acceptAST(compilationUnit, source);", "+\t\t\t\t\t} ", "-\t\t\t\t\t// pass it to requestor", "-\t\t\t\t\tastRequestor.acceptAST(compilationUnit);", "+\t\t\t\t\tBindingKey bindingKey = (BindingKey) this.requestedKeys.removeKey(unit.compilationResult.getFileName());", "+\t\t\t\t\tif (bindingKey != null) {", "+\t\t\t\t\t\tBinding compilerBinding = bindingKey.getCompilerBinding(unit, this);", "+\t\t\t\t\t\tif (compilerBinding != null) {", "+\t\t\t\t\t\t\tDefaultBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables, this);", "+\t\t\t\t\t\t\tIBinding binding = resolver.getBinding(compilerBinding);", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t// pass it to requestor", "+\t\t\t\t\t\t\tif (binding != null)", "+\t\t\t\t\t\t\t\tastRequestor.acceptBinding(binding, bindingKey.getKey());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\t// remaining binding keys are package binding keys", "+\t\t\tchar[][] pkgNames = this.requestedKeys.keyTable;", "+\t\t\tfor (int j = 0, pkgLength = pkgNames.length; j < pkgLength; j++) {", "+\t\t\t\tchar[] pkgName = pkgNames[j];", "+\t\t\t\tif (pkgName == null) continue;", "+\t\t\t\tBinding compilerBinding = new PackageBinding(CharOperation.splitOn('.', pkgName), null, this.lookupEnvironment);", "+\t\t\t\tDefaultBindingResolver resolver = new DefaultBindingResolver(null, owner, this.bindingTables, this);", "+\t\t\t\tIBinding binding = resolver.getBinding(compilerBinding);", "-\t\t\t\tif (i == this.totalUnits-1) {", "-\t\t\t\t\t// end of batch: look for new one", "-\t\t\t\t\tdo {", "-\t\t\t\t\t\tworkingCopies = astRequestor.getSources();", "-\t\t\t\t\t} while (workingCopies != null && workingCopies.length == 0);", "-\t\t\t\t\tif (workingCopies != null) {", "-\t\t\t\t\t\tfor (int j = 0, workingCopyLength = workingCopies.length; j < workingCopyLength; j++) {", "-\t\t\t\t\t\t\tICompilationUnit workingCopy = workingCopies[j];", "-\t\t\t\t\t\t\taccept((org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy, null /* no access restriction*/);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t\t// pass it to requestor", "+\t\t\t\tif (binding != null)", "+\t\t\t\t\tastRequestor.acceptBinding(binding, ((BindingKey) this.requestedKeys.valueTable[j]).getKey());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb84936e5be61120b89e8d6e5720ef68", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "89566b19098686deffb54767a28967337579ef90", "commitAfterChange": "907520562618c52ad9275f3500852726a78168ff", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner)", "signatureAfterChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner)", "diff": ["-\t\t\t\tif (this.requestedSources.size() == 0 && this.requestedKeys.size() == 0)", "+\t\t\t\tif (this.requestedSources.size() == 0 && this.requestedKeys.size() == 0) {", "+\t\t\t\t\t// cleanup remaining units", "+\t\t\t\t\tfor (; i < this.totalUnits; i++) {", "+\t\t\t\t\t\tthis.unitsToProcess[i].cleanUp();", "+\t\t\t\t\t\tthis.unitsToProcess[i] = null;", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t\t\tchar[] fileName = unit.compilationResult.getFileName();", "-\t\t\t\t\t", "-\t\t\t\t\t// only process requested units", "-\t\t\t\t\tif (this.requestedKeys.containsKey(fileName) || this.requestedSources.containsKey(fileName)) {", "-\t\t\t\t\t\tsuper.process(unit, i); // this.process(...) is optimized to not process already known units", "+\t\t\t\t\tsuper.process(unit, i); // this.process(...) is optimized to not process already known units", "-\t\t\t\t\t\t// requested AST", "-\t\t\t\t\t\tICompilationUnit source = (ICompilationUnit) this.requestedSources.get(fileName);", "-\t\t\t\t\t\tif (source != null) {", "-\t\t\t\t\t\t\t// convert AST", "-\t\t\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "-\t\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "-\t\t\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "-\t\t\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "-\t\t\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "-\t\t\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, this.monitor);", "-\t\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables);", "-\t\t\t\t\t\t\tast.setBindingResolver(resolver);", "-\t\t\t\t\t\t\tconverter.setAST(ast);", "-\t\t\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "-\t\t\t\t\t\t\tcompilationUnit.setJavaElement(source);", "-\t\t\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.getLineSeparatorPositions());", "-\t\t\t\t\t\t\tast.setDefaultNodeFlag(0);", "-\t\t\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t// pass it to requestor", "-\t\t\t\t\t\t\tastRequestor.acceptAST(source, compilationUnit);", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tworked(1);", "-\t\t\t\t\t\t} ", "+\t\t\t\t\t// requested AST", "+\t\t\t\t\tchar[] fileName = unit.compilationResult.getFileName();\t\t\t\t\t", "+\t\t\t\t\tICompilationUnit source = (ICompilationUnit) this.requestedSources.get(fileName);", "+\t\t\t\t\tif (source != null) {", "+\t\t\t\t\t\t// convert AST", "+\t\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "+\t\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "+\t\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "+\t\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "+\t\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, this.monitor);", "+\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables);", "+\t\t\t\t\t\tast.setBindingResolver(resolver);", "+\t\t\t\t\t\tconverter.setAST(ast);", "+\t\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "+\t\t\t\t\t\tcompilationUnit.setJavaElement(source);", "+\t\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.getLineSeparatorPositions());", "+\t\t\t\t\t\tast.setDefaultNodeFlag(0);", "+\t\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "-\t\t\t\t\t\t// requested binding", "-\t\t\t\t\t\tObject key = this.requestedKeys.get(fileName);", "-\t\t\t\t\t\tif (key instanceof BindingKeyResolver) {", "-\t\t\t\t\t\t\treportBinding(key, astRequestor, owner, unit);", "+\t\t\t\t\t\t// pass it to requestor", "+\t\t\t\t\t\tastRequestor.acceptAST(source, compilationUnit);", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tworked(1);", "+\t\t\t\t\t} ", "+\t\t\t\t\t", "+\t\t\t\t\t// requested binding", "+\t\t\t\t\tObject key = this.requestedKeys.get(fileName);", "+\t\t\t\t\tif (key instanceof BindingKeyResolver) {", "+\t\t\t\t\t\treportBinding(key, astRequestor, owner, unit);", "+\t\t\t\t\t\tworked(1);", "+\t\t\t\t\t} else if (key instanceof ArrayList) {", "+\t\t\t\t\t\tIterator iterator = ((ArrayList) key).iterator();", "+\t\t\t\t\t\twhile (iterator.hasNext()) {", "+\t\t\t\t\t\t\treportBinding(iterator.next(), astRequestor, owner, unit);", "-\t\t\t\t\t\t} else if (key instanceof ArrayList) {", "-\t\t\t\t\t\t\tIterator iterator = ((ArrayList) key).iterator();", "-\t\t\t\t\t\t\twhile (iterator.hasNext()) {", "-\t\t\t\t\t\t\t\treportBinding(iterator.next(), astRequestor, owner, unit);", "-\t\t\t\t\t\t\t\tworked(1);", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// remove at the end so that we don't resolve twice if a source and a key for the same file name have been requested", "+\t\t\t\t\tthis.requestedSources.removeKey(fileName);", "+\t\t\t\t\tthis.requestedKeys.removeKey(fileName);", "-\t\t\t\t\t\t// remove at the end so that we don't resolve twice if a source and a key for the same file name have been requested", "-\t\t\t\t\t\tthis.requestedSources.removeKey(fileName);", "-\t\t\t\t\t\tthis.requestedKeys.removeKey(fileName);", "+/*\tCode used to fault in types and resolve which is no longer necessary as all questions asked to forward references are", "+ * lazily resolved.", "+ * Code used to be:", "+\t\t\t\t\tif (this.requestedKeys.containsKey(fileName) || this.requestedSources.containsKey(fileName)) {", "+\t\t\t\t\t   ...", "+", "-/*", "+", "-\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d2c3332c421aa08dbc4666c0d712c92d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "bb58594beea7321f1a2a3673bab3e26af89ead20", "commitAfterChange": "7376fb10956e4a03cc528e86b634b5ca73ef755b", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner, IProgressMonitor monitor)", "signatureAfterChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner, IProgressMonitor monitor)", "diff": ["-\t\t\t\t\tsuper.process(unit, i); // this.process(...) is optimized to not process already known units", "+\t\t\t\t\tchar[] fileName = unit.compilationResult.getFileName();", "-\t\t\t\t\tICompilationUnit source = (ICompilationUnit) this.requestedSources.removeKey(unit.compilationResult.getFileName());", "-\t\t\t\t\tif (source != null) {", "-\t\t\t\t\t\t// convert AST", "-\t\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "-\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "-\t\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "-\t\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "-\t\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "-\t\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, monitor);", "-\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables);", "-\t\t\t\t\t\tast.setBindingResolver(resolver);", "-\t\t\t\t\t\tconverter.setAST(ast);", "-\t\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "-\t\t\t\t\t\tcompilationUnit.setJavaElement(source);", "-\t\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.lineSeparatorPositions);", "-\t\t\t\t\t\tast.setDefaultNodeFlag(0);", "-\t\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "+\t\t\t\t\t// only process requested units", "+\t\t\t\t\tif (this.requestedKeys.containsKey(fileName) || this.requestedSources.containsKey(fileName)) {", "+\t\t\t\t\t\tsuper.process(unit, i); // this.process(...) is optimized to not process already known units", "-\t\t\t\t\t\t// pass it to requestor", "-\t\t\t\t\t\tastRequestor.acceptAST(source, compilationUnit);", "-\t\t\t\t\t} ", "-\t\t\t\t\t", "-\t\t\t\t\tObject key = this.requestedKeys.removeKey(unit.compilationResult.getFileName());", "-\t\t\t\t\tif (key instanceof BindingKeyResolver) {", "-\t\t\t\t\t\treportBinding(key, astRequestor, owner, unit);", "-\t\t\t\t\t} else if (key instanceof ArrayList) {", "-\t\t\t\t\t\tIterator iterator = ((ArrayList) key).iterator();", "-\t\t\t\t\t\twhile (iterator.hasNext()) {", "-\t\t\t\t\t\t\treportBinding(iterator.next(), astRequestor, owner, unit);", "+\t\t\t\t\t\tICompilationUnit source = (ICompilationUnit) this.requestedSources.removeKey(fileName);", "+\t\t\t\t\t\tif (source != null) {", "+\t\t\t\t\t\t\t// convert AST", "+\t\t\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "+\t\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "+\t\t\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "+\t\t\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "+\t\t\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "+\t\t\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, monitor);", "+\t\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables);", "+\t\t\t\t\t\t\tast.setBindingResolver(resolver);", "+\t\t\t\t\t\t\tconverter.setAST(ast);", "+\t\t\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "+\t\t\t\t\t\t\tcompilationUnit.setJavaElement(source);", "+\t\t\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.lineSeparatorPositions);", "+\t\t\t\t\t\t\tast.setDefaultNodeFlag(0);", "+\t\t\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t// pass it to requestor", "+\t\t\t\t\t\t\tastRequestor.acceptAST(source, compilationUnit);", "+\t\t\t\t\t\t} ", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tObject key = this.requestedKeys.removeKey(fileName);", "+\t\t\t\t\t\tif (key instanceof BindingKeyResolver) {", "+\t\t\t\t\t\t\treportBinding(key, astRequestor, owner, unit);", "+\t\t\t\t\t\t} else if (key instanceof ArrayList) {", "+\t\t\t\t\t\t\tIterator iterator = ((ArrayList) key).iterator();", "+\t\t\t\t\t\t\twhile (iterator.hasNext()) {", "+\t\t\t\t\t\t\t\treportBinding(iterator.next(), astRequestor, owner, unit);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (unit.scope != null)", "+\t\t\t\t\t\t\tunit.scope.faultInTypes(); // still force resolution of signatures, so clients can query DOM AST"]}], "num": 50332}