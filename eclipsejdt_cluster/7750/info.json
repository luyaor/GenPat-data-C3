{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "704fe94ae83b726ce7bc0e7d25a62103", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6415ec6121a9d9963195fa938d966694", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "67766e5b27ea79987add5b8cee1657ec3cbfbedb", "commitAfterChange": "e6c002b5fc187b459093049d56b25a0df58b8d61", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tprivate void checkAndSetModifiers()", "signatureAfterChange": " \t \tprivate void checkAndSetModifiers()", "diff": ["-\t\t\tif ((referenceContext.bits & ASTNode.HasAbstractMethods) != 0)", "+\t\t\tif ((referenceContext.bits & ASTNode.HasAbstractMethods) != 0) {", "-\t\t\telse if (!sourceType.isAnonymousType()){ // body of enum constant must implement any inherited abstract methods", "+\t\t\t} else if (!sourceType.isAnonymousType()) {", "+\t\t\t\t// body of enum constant must implement any inherited abstract methods", "-\t\t\t\tTypeDeclaration typeDeclaration = this.referenceContext;", "-\t\t\t\tFieldDeclaration[] fields = typeDeclaration.fields;", "-\t\t\t\tint length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length;", "-\t\t\t\t\tif (length == 0) break checkAbstractEnum; // has no constants so must implement the method itself", "-\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tTypeDeclaration typeDeclaration = this.referenceContext;", "+\t\t\t\t\tFieldDeclaration[] fields = typeDeclaration.fields;", "+\t\t\t\t\tint fieldsLength = fields == null ? 0 : fields.length;", "+\t\t\t\t\tif (fieldsLength == 0) break checkAbstractEnum; // has no constants so must implement the method itself", "+\t\t\t\t\tAbstractMethodDeclaration[] methods = typeDeclaration.methods;", "+\t\t\t\t\tint methodsLength = methods == null ? 0 : methods.length;", "+\t\t\t\t\t// TODO (kent) cannot tell that the superinterfaces are empty or that their methods are implemented", "+\t\t\t\t\tboolean definesAbstractMethod = typeDeclaration.superInterfaces != null;", "+\t\t\t\t\tfor (int i = 0; i < methodsLength && !definesAbstractMethod; i++)", "+\t\t\t\t\t\tdefinesAbstractMethod = methods[i].isAbstract();", "+\t\t\t\t\tif (!definesAbstractMethod) break checkAbstractEnum; // all methods have bodies", "+\t\t\t\t\tfor (int i = 0; i < fieldsLength; i++) {", "+\t\t\tmodifiers |= AccFinal;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6bdc1bc86c3e5bf6903dbdb22184046e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "890be42f32773e7ca5496c222c424ace19ee53bc", "commitAfterChange": "56f6c261cdbb79871bca6b1da5ab32712debf654", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tprivate void checkAndSetModifiers()", "signatureAfterChange": " \t \tprivate void checkAndSetModifiers()", "diff": ["-// what about inherited interface methods?", "+\t\t\t// what about inherited interface methods?", "+\t\t\telse if (!sourceType.isAnonymousType()){ // body of enum constant must implement any inherited abstract methods", "+\t\t\t\t// enum type needs to implement abstract methods if one of its constants does not supply a body", "+\t\t\t\tTypeDeclaration typeDeclaration = this.referenceContext;", "+\t\t\t\tFieldDeclaration[] fields = typeDeclaration.fields;", "+\t\t\t\tint length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length;", "+\t\t\t\tcheckAbstractEnum: {", "+\t\t\t\t\tif (length == 0) break checkAbstractEnum; // has no constants so must implement the method itself", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\tFieldDeclaration fieldDecl = fields[i];", "+\t\t\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT)", "+\t\t\t\t\t\t\tif (!(fieldDecl.initialization instanceof QualifiedAllocationExpression))", "+\t\t\t\t\t\t\t\tbreak checkAbstractEnum;", "+\t\t\t\t\t}", "+\t\t\t\t\t// tag this enum as abstract since an abstract method must be implemented AND all enum constants define an anonymous body", "+\t\t\t\t\t// as a result, each of its anonymous constants will see it as abstract and must implement each inherited abstract method\t\t\t\t\t", "+\t\t\t\t\tmodifiers |= AccAbstract;", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c8c1a3325f75dbe24b5a9e4dcc08559c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "519f65f0f5344992cd2a44d698edb1295f3c3a67", "commitAfterChange": "1b7858c417f0a2eea0d6f609fa41df3128fd97dd", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 21, "signatureBeforeChange": " boolean mustImplementAbstractMethods()", "signatureAfterChange": " boolean mustImplementAbstractMethod(ReferenceBinding declaringClass)", "diff": ["-boolean mustImplementAbstractMethods() {", "-\tif (!super.mustImplementAbstractMethods()) return false;", "-\tif (!this.type.isEnum() || this.type.isAnonymousType()) return true;", "+boolean mustImplementAbstractMethod(ReferenceBinding declaringClass) {", "+\tif (!super.mustImplementAbstractMethod(declaringClass)) return false;", "-\t// enum type only needs to implement abstract methods if any of its constants does not supply a body", "+\tif (!this.type.isEnum() || this.type.isAnonymousType()) return true; // want to test the actual enum type only", "+\tif (this.type.isAbstract()) return false; // is an enum that has since been tagged as abstract by the code below", "+", "+\t// enum type needs to implement abstract methods if one of its constants does not supply a body", "-\tfor (int i = 0, length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length; i < length; i++) {", "-\t\tFieldDeclaration fieldDecl = typeDeclaration.fields[i];", "+\tFieldDeclaration[] fields = typeDeclaration.fields;", "+\tint length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length;", "+\tif (length == 0) return true; // has no constants so must implement the method itself", "+\tfor (int i = 0; i < length; i++) {", "+\t\tFieldDeclaration fieldDecl = fields[i];", "-\t\t\t\treturn true; // leave mustImplementAbstractMethods flag on ", "+\t\t\t\treturn true;", "-\treturn false; // since all enum constants define an anonymous body", "+", "+\t// tag this enum as abstract since an abstract method must be implemented AND all enum constants define an anonymous body", "+\t// as a result, each of its anonymous constants will see it as abstract and must implement each inherited abstract method", "+\tthis.type.modifiers |= IConstants.AccAbstract;", "+\treturn false;"]}], "num": 7750}