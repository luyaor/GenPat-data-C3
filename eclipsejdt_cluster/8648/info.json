{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8b92b939d63f8c1cccce83d2d3773de8", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "530d8c5f10d27020294a1c8c46da5ce7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "82d58f9af854b98a92f7d694d40ac1e84e13013c", "commitAfterChange": "6d114aac1fbfd4c23041534efbb02c24c883ba25", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": "    public void resolve()", "signatureAfterChange": "    public void resolve()", "diff": ["-\t\tboolean hasEnumConstantsWithoutBody = false;", "+\t\tFieldDeclaration[] enumConstantsWithoutBody = null;", "-\t\t\t\t\t\tif (!(field.initialization instanceof QualifiedAllocationExpression))", "-\t\t\t\t\t\t\thasEnumConstantsWithoutBody = true;", "+\t\t\t\t\t\tif (!(field.initialization instanceof QualifiedAllocationExpression)) {", "+\t\t\t\t\t\t\tif (enumConstantsWithoutBody == null)", "+\t\t\t\t\t\t\t\tenumConstantsWithoutBody = new FieldDeclaration[count];", "+\t\t\t\t\t\t\tenumConstantsWithoutBody[i] = field;", "+\t\t\t\t\t\t}", "-\t\t\t\t\tif (!hasEnumConstants || hasEnumConstantsWithoutBody) {", "+\t\t\t\t\tif (!hasEnumConstants) {", "+\t\t\t\t\t\tfor (int i = 0, count = this.methods.length; i < count; i++) {", "+\t\t\t\t\t\t\tfinal AbstractMethodDeclaration methodDeclaration = this.methods[i];", "+\t\t\t\t\t\t\tif (methodDeclaration.isAbstract() && methodDeclaration.binding != null)", "+\t\t\t\t\t\t\t\tthis.scope.problemReporter().enumAbstractMethodMustBeImplemented(methodDeclaration);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (enumConstantsWithoutBody != null) {", "-\t\t\t\t\t\t\t\tthis.scope.problemReporter().enumAbstractMethodMustBeImplemented(methodDeclaration);", "+\t\t\t\t\t\t\t\tfor (int f = 0, l = enumConstantsWithoutBody.length; f < l; f++)", "+\t\t\t\t\t\t\t\t\tif (enumConstantsWithoutBody[f] != null)", "+\t\t\t\t\t\t\t\t\t\tthis.scope.problemReporter().enumConstantMustImplementAbstractMethod(methodDeclaration, enumConstantsWithoutBody[f]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "777b0fde268e4c5f3ea1902061626030", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "bb58594beea7321f1a2a3673bab3e26af89ead20", "commitAfterChange": "7376fb10956e4a03cc528e86b634b5ca73ef755b", "methodNumberBeforeChange": 296, "methodNumberAfterChange": 296, "signatureBeforeChange": " public void updateLastRecordedEndPC(int pos)", "signatureAfterChange": " public void updateLastRecordedEndPC(Scope scope, int pos)", "diff": ["-public void updateLastRecordedEndPC(int pos) {", "+ */", "+public void updateLastRecordedEndPC(Scope scope, int pos) {", "-\tupdateLocalVariablesAttribute(pos);", "-}", "+\tif (this.generateLocalVariableTableAttributes) {", "+\t\tfor (int i = 0, max = this.locals.length; i < max; i++) {", "+\t\t\tLocalVariableBinding local = this.locals[i];", "+\t\t\tif (local != null && local.declaringScope == scope && local.initializationCount > 0) {", "+\t\t\t\t\tlocal.initializationPCs[((local.initializationCount - 1) << 1) + 1] = this.position;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac890a57aa14e0fd752395f7bad90ffe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedAnnotationBinding.java", "commitBeforeChange": "833acf9fd171cc3b88beb3f35c58318abd7b1b7c", "commitAfterChange": "e83ae1e37e0f93b696a44a9888bf8d5e9425c659", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public ElementValuePair[] getElementValuePairs()", "signatureAfterChange": "  public ElementValuePair[] getElementValuePairs()", "diff": ["-\tif (this.env != null)", "-\t\tgetAnnotationType(); // resolve the annotation type & method bindings of each pair", "-", "+\tif (this.env != null) {", "+\t\tif (this.typeUnresolved) {", "+\t\t\tgetAnnotationType(); // resolve the annotation type", "+\t\t}", "+\t\t// resolve method binding and value type (if unresolved) for each pair", "+\t\tfor (int i = this.pairs.length; --i >= 0;) {", "+\t\t\tElementValuePair pair = this.pairs[i];", "+\t\t\tMethodBinding[] methods = this.type.getMethods(pair.getName());", "+\t\t\t// there should be exactly one since the type is an annotation type.", "+\t\t\tif (methods != null && methods.length == 1) {", "+\t\t\t\tpair.setMethodBinding(methods[0]);", "+\t\t\t} // else silently leave a null there", "+\t\t\tObject value = pair.getValue();", "+\t\t\tif (value instanceof UnresolvedReferenceBinding) {", "+\t\t\t\tpair.setValue(((UnresolvedReferenceBinding) value).", "+\t\t\t\t\t\tresolve(this.env, false));", "+\t\t\t\t\t\t\t// no parameterized types in annotation values", "+\t\t\t} // do nothing for UnresolvedAnnotationBinding-s, since their ", "+\t\t\t  // content is only accessed through get* methods", "+\t\t}", "+\t\tthis.env = null;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d102e38d2efb3b5e28e5e86637c8fe1c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "ade133e0ba99ce8f261b5dbbb001561f152f4db8", "commitAfterChange": "a6c0426e8a97e5c69fdac3bea072af18fea82d0e", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": " \tpublic static IPath resolveDotDot(IPath path)", "signatureAfterChange": " \tpublic static IPath resolveDotDot(IPath reference, IPath path)", "diff": ["-\tpublic static IPath resolveDotDot(IPath path) {", "+\tpublic static IPath resolveDotDot(IPath reference, IPath path) {", "-\t\tIPath workspaceLocation = null;", "-\t\tfor (int i = 0, length = path.segmentCount(); i < length; i++) {", "-\t\t\tString segment = path.segment(i);", "-\t\t\tif (DOT_DOT.equals(segment)) {", "-\t\t\t\tif (newPath == null) {", "-\t\t\t\t\tif (i == 0) {", "-\t\t\t\t\t\tworkspaceLocation = workspaceRoot.getLocation();", "-\t\t\t\t\t\tnewPath = workspaceLocation;", "+\t\tIPath workspaceLocation = workspaceRoot.getLocation();", "+\t\tif (reference == null || workspaceLocation.isPrefixOf(reference)) {", "+\t\t\tfor (int i = 0, length = path.segmentCount(); i < length; i++) {", "+\t\t\t\tString segment = path.segment(i);", "+\t\t\t\tif (DOT_DOT.equals(segment)) {", "+\t\t\t\t\tif (newPath == null) {", "+\t\t\t\t\t\tif (i == 0) {", "+\t\t\t\t\t\t\tnewPath = workspaceLocation;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tnewPath = path.removeFirstSegments(i);", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tnewPath = path.removeFirstSegments(i);", "+\t\t\t\t\t\tif (newPath.segmentCount() > 0) {", "+\t\t\t\t\t\t\tnewPath = newPath.removeLastSegments(1);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tnewPath = workspaceLocation;", "+\t\t\t\t\t\t}", "-\t\t\t\t} else {", "+\t\t\t\t} else if (newPath != null) {", "+\t\t\t\t\tif (newPath.equals(workspaceLocation) && workspaceRoot.getProject(segment).isAccessible()) {", "+\t\t\t\t\t\tnewPath = new Path(segment).makeAbsolute();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tnewPath = newPath.append(segment);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\telse {", "+\t\t\tfor (int i = 0, length = path.segmentCount(); i < length; i++) {", "+\t\t\t\tString segment = path.segment(i);", "+\t\t\t\tif (DOT_DOT.equals(segment)) {", "+\t\t\t\t\tif (newPath == null){", "+\t\t\t\t\t\tnewPath = reference;", "+\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tworkspaceLocation = workspaceRoot.getLocation();", "-\t\t\t\t\t\tnewPath = workspaceLocation;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} else if (newPath != null) {", "-\t\t\t\tif (newPath.equals(workspaceLocation) && workspaceRoot.getProject(segment).isAccessible()) {", "-\t\t\t\t\tnewPath = new Path(segment).makeAbsolute();", "-\t\t\t\t} else {", "+\t \t\t\t\t}", "+\t\t\t\t} else if (newPath != null) {", "-\t\t\t\t}", "+\t \t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d3f31700a6e87e283062b0bf015264de", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "cae2235178dd91d5be4ed811b5134ba4b502f56a", "commitAfterChange": "20291e123853b40f3437b01ca0907aa48371db12", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods)", "signatureAfterChange": "  void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods)", "diff": ["+\t\t\tboolean isViewedAsDeprecated = isViewedAsDeprecated();", "+\t\t\tif (isViewedAsDeprecated) {", "+\t\t\t\tfor (int i = 0, max = this.fields.length; i < max; i++) {", "+\t\t\t\t\tFieldBinding field = this.fields[i];", "+\t\t\t\t\tif (!field.isDeprecated()) {", "+\t\t\t\t\t\tfield.modifiers |= ExtraCompilerModifiers.AccDeprecatedImplicitly;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tfor (int i = 0, max = this.methods.length; i < max; i++) {", "+\t\t\t\t\tMethodBinding method = this.methods[i];", "+\t\t\t\t\tif (!method.isDeprecated()) {", "+\t\t\t\t\t\tmethod.modifiers |= ExtraCompilerModifiers.AccDeprecatedImplicitly;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 8648}