{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c45898f885ff2db5ff44ebad1e714fff", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53e32ba90b0c8a8850fabd645b21e89a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8bd987839355c299213c95f3874a2e3574283d9c", "commitAfterChange": "76b6723dbe61d0b9874754d0d6572d1a4d8c0cbc", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 63, "signatureBeforeChange": "  \tprivate void printJavadocBlock(FormatJavadocBlock block)", "signatureAfterChange": "  \tprivate void printJavadocBlock(FormatJavadocBlock block)", "diff": ["-\t\tint firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;", "-\t\t\tfirstColumn++;", "-\t\tStringBuffer indentationBuffer = printJavadocIndentationBuffer(block, firstColumn);", "-\t\tif (!block.isDescription()) {", "-\t\t\tthis.column += previousEnd - block.sourceStart + 1;", "+\t\tif (block.isDescription()) {", "+\t\t\tif (!block.isInlined()) {", "+\t\t\t    this.commentIndentation = null;", "+\t\t\t}", "+\t\t} else {", "+\t\t\tint tagLength = previousEnd - block.sourceStart + 1;", "+\t\t\tthis.column += tagLength;", "+\t\t\tif (!block.isInlined()) {", "+\t\t\t    boolean indentRootTags = this.formatter.preferences.comment_indent_root_tags && !block.isInDescription();", "+\t\t\t    int commentIndentationLevel = 0;", "+\t\t\t\tif (indentRootTags) {", "+\t\t\t\t    commentIndentationLevel = tagLength + 1;", "+\t\t\t\t\tboolean indentParamTag = this.formatter.preferences.comment_indent_parameter_description && block.isInParamTag();", "+\t\t\t\t\tif (indentParamTag) {", "+\t\t\t\t\t\tcommentIndentationLevel += this.indentationSize;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (commentIndentationLevel == 0) {", "+\t\t\t\t    this.commentIndentation = null;", "+\t\t\t\t} else {", "+\t\t    \t\tStringBuffer indentationBuffer = new StringBuffer();", "+\t\t        \tfor (int i=0; i<commentIndentationLevel; i++) {", "+\t\t    \t\t\tindentationBuffer.append(' ');", "+\t\t        \t}", "+\t        \t\tthis.commentIndentation = indentationBuffer.toString();", "+\t\t    \t}", "+\t\t\t}", "-\t\t\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\t\tprintJavadocBlockReference(buffer, reference, block);", "-\t\t\t    addReplaceEdit(previousEnd+1, reference.sourceEnd, buffer.toString());", "+\t\t\t\tprintJavadocBlockReference(block, reference);", "-\t\t\t\t\t// Need to print the closing brace", "-\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\t\t\tif ((this.column+1) > maxColumn) {", "-\t\t\t\t\t\tthis.lastNumberOfNewLines++;", "-\t\t\t\t\t\tthis.line++;", "-\t\t\t\t    \tbuffer.append(this.lineSeparator);", "-\t\t\t\t    \tthis.column = 1;", "-\t\t\t\t    \tprintIndentationIfNecessary(buffer);", "-\t\t\t    \t\tbuffer.append(BLOCK_LINE_PREFIX);", "-\t\t\t\t    \tthis.column = headerLine ? firstColumn-1 : firstColumn;", "-\t\t\t\t    \tif (indentationBuffer != null) {", "-\t\t\t\t\t\t\tbuffer.append(indentationBuffer);", "-\t\t\t\t\t\t\tthis.column += indentationBuffer.length();", "-\t\t\t\t    \t}", "-\t\t\t\t    \theaderLine = false;", "-\t\t\t\t    \tmaxColumn--;", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.scanner.resetTo(previousEnd+1, block.sourceEnd+1);", "-\t\t\t\t\ttry {", "-\t                    int token = this.scanner.getNextToken();", "-\t                    while (token == TerminalTokens.TokenNameWHITESPACE || token == TerminalTokens.TokenNameMULTIPLY) {", "-\t                    \ttoken = this.scanner.getNextToken();", "-\t                    }", "-\t                    if (token == TerminalTokens.TokenNameRBRACE) {", "-\t\t                    buffer.append(this.scanner.source, this.scanner.startPosition, this.scanner.currentPosition-this.scanner.startPosition);", "-\t\t\t\t\t    \tthis.column += (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;", "-\t                    }", "-                    } catch (InvalidInputException e) {", "-\t\t\t\t\t\tbuffer.append('}');", "-                    }", "-                    addReplaceEdit(previousEnd+1, block.sourceEnd, buffer.toString());", "+\t\t\t\t\tthis.column++;", "+\t\tint previousLine = 0;", "-\t\t\tint textLength = -1;", "-\t\t\t   \t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "+\t\t\t\t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "+\t\t\t\tif (!clearBlankLines && node.lineStart > (previousLine+1)) newLines = node.lineStart - previousLine;", "-\t\t\t\t\t\t// Immutable tags are not formatted", "-\t\t\t\t\t\tif (textLength == -1) {", "-\t\t\t\t\t\t\ttextLength = getTextLength(block, text, false);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tint additionalLength = printJavadocHtmlImmutableTag(text, block, newLines > 0);", "-\t\t\t\t\t\tthis.column += textLength - additionalLength;", "+\t\t\t\t\t\tif (newLines > 0 && this.commentIndentation != null) {", "+\t\t\t\t\t    \taddInsertEdit(node.sourceStart, this.commentIndentation);", "+\t\t\t\t\t    \tthis.column += this.commentIndentation.length();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tprintJavadocHtmlImmutableTag(text, block, newLines > 0);", "+\t\t\t\t\t\tthis.column += getTextLength(block, text);", "-\t\t\t\tif (newLines > 0 && indentationBuffer != null) {", "-\t\t\t\t\taddInsertEdit(node.sourceStart, indentationBuffer.toString());", "-\t\t\t\t\tthis.column += indentationBuffer.length();", "+\t\t\t\tif (newLines > 0 && this.commentIndentation != null) {", "+\t\t\t    \taddInsertEdit(node.sourceStart, this.commentIndentation);", "+\t\t\t    \tthis.column += this.commentIndentation.length();", "+\t\t\tpreviousLine = Util.getLineNumber(previousEnd, this.lineEnds, node.lineStart > 1 ? node.lineStart-2 : 0, this.maxLines);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e68c7626f3cf411c342fd1cf07fe38c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "c68561900839d22ed60d27add792729a269fc650", "commitAfterChange": "0a6b1d13a406c88bfb0ad014ad0ce93c729298f3", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 60, "signatureBeforeChange": "  \tprivate void printLineComment(int commentStart, int commentEnd)", "signatureAfterChange": "  \tprivate void printLineComment(int commentStart, int commentEnd)", "diff": ["-\t\tStringBuffer buffer = new StringBuffer();", "-\t\tint editStart = this.scanner.currentPosition;", "-\t\tStringBuffer tokensBuffer = new StringBuffer();", "-\t\tboolean bufferHasTokens = false;", "-\t\tint previousPosition = commentStart;", "-\t\tboolean firstWord = true;", "+\t\tint lastTokenEndPosition = commentStart;", "+\t\tint spaceStartPosition = -1;", "+\t\tint spaceEndPosition = -1;", "+\t\tString newLineString = null;", "+\t\tthis.commentIndentation = null;", "-\t\t\t\t\tpreviousToken = token;", "-\t\t\t\t\tif (tokensBuffer.length() > 0) {", "-\t\t\t\t\t\tbuffer.append(tokensBuffer);", "-\t\t\t\t\t\tthis.column += tokensBuffer.length();", "-\t\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\t\t\tbufferHasTokens = true;", "+\t\t\t\t\tif (previousToken == -1) {", "+\t\t\t\t\t\t// do not remember the first whitespace", "+\t\t\t\t\t\tpreviousToken = SKIP_FIRST_WHITESPACE_TOKEN;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tpreviousToken = token;", "+\t\t\t\t\t// Remember space position", "+\t\t\t\t\tspaceStartPosition = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\tspaceEndPosition = this.scanner.getCurrentTokenEndPosition();", "-    \t\tboolean insertSpace = previousToken == -1 || previousToken == TerminalTokens.TokenNameWHITESPACE;", "-    \t\tint lastColumn = this.column + tokensBuffer.length() + tokenLength;", "-    \t\tif (insertSpace) lastColumn++;", "-\t\t\tif (!firstWord && lastColumn > maxColumn) {", "-\t\t\t\t// not enough space on the line", "-\t\t\t\tthis.line++;", "-\t\t\t\tif ((firstColumn+tokensBuffer.length()+tokenLength) > maxColumn) {", "-\t\t\t\t\t// there won't be enough room even if we break the line before the buffered tokens", "-\t\t\t\t\t// So add the buffered tokens now", "-\t\t\t\t\tbuffer.append(tokensBuffer);", "-\t\t\t\t\tthis.column += tokensBuffer.length();", "-\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\t\tbufferHasTokens = true;", "-\t\t\t\t}", "-\t\t\t\tif (bufferHasTokens) {", "-\t\t\t    \tbuffer.append(this.lineSeparator);", "-\t\t\t    \tthis.column = 1;", "-\t\t\t    \tprintIndentationIfNecessary(buffer);", "-\t    \t\t\tbuffer.append(LINE_COMMENT_PREFIX);", "-\t\t    \t\tthis.column += LINE_COMMENT_PREFIX_LENGTH;", "-\t\t\t\t}", "-\t\t    \tif (tokensBuffer.length() > 0) {", "-\t\t    \t\tif (ScannerHelper.isWhitespace(tokensBuffer.charAt(0))) {", "-\t\t\t\t\t\tbuffer.append(tokensBuffer.substring(1));", "-\t\t\t\t\t\tthis.column += tokensBuffer.length() - 1;", "-\t\t    \t\t} else {", "-\t\t\t\t\t\tbuffer.append(tokensBuffer);", "-\t\t\t\t\t\tthis.column += tokensBuffer.length();", "-\t\t    \t\t}", "-\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\t\tif (insertSpace)  {", "-\t\t    \t\t\tbuffer.append(' ');", "-\t\t    \t\t\tthis.column++;", "-\t\t\t\t\t}", "-\t\t    \t}", "-\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "-\t\t\t\tbufferHasTokens = true;", "-\t\t\t\tthis.column += tokenLength;", "-\t\t\t\tfirstColumn = this.indentationLevel + LINE_COMMENT_PREFIX_LENGTH;", "-\t\t\t} else {", "-\t\t\t\t// append token to the line", "-\t\t\t\tif (insertSpace)  {", "-\t    \t\t\ttokensBuffer.append(' ');", "-\t\t\t\t}", "-\t\t\t\ttokensBuffer.append(this.scanner.source, tokenStart, tokenLength);", "+", "+\t\t\t// insert space at the beginning if not present", "+\t\t\tif (previousToken == -1 ) {", "+    \t\t\taddInsertEdit(this.scanner.startPosition, \" \"); //$NON-NLS-1$", "+\t\t\t\tthis.column++;", "+\t\t\t// replace space at the beginning if present", "+\t\t\telse if (previousToken == SKIP_FIRST_WHITESPACE_TOKEN) {", "+\t\t\t\taddReplaceEdit(spaceStartPosition, this.scanner.startPosition-1, \" \"); //$NON-NLS-1$", "+\t\t\t\tthis.column++;", "+\t\t\t\tspaceStartPosition = -1; // do not use this position to split the comment", "+\t\t\t} else {", "+\t\t\t\t// not on the first token", "+\t\t\t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE;", "+\t\t\t\tif (insertSpace) {", "+\t\t\t\t\t// count inserted space if any in token length", "+\t\t\t\t\ttokenLength++;", "+\t\t\t\t}", "+\t\t\t\t// insert new line if max line width is reached and a space was previously encountered", "+\t\t\t\tif (spaceStartPosition > 0 && (this.column+tokenLength) > maxColumn) {", "+\t\t\t\t\tthis.lastNumberOfNewLines++;", "+\t\t\t\t\tthis.line++;", "+\t\t\t\t\tif (newLineString == null) {", "+\t\t\t\t\t\tStringBuffer newLineBuffer = new StringBuffer(this.lineSeparator);", "+\t\t\t\t\t\tthis.column = 1;", "+\t\t\t\t\t\tprintIndentationIfNecessary(newLineBuffer);", "+\t\t\t\t\t    newLineBuffer.append(LINE_COMMENT_PREFIX);", "+\t\t\t\t\t\tthis.column += LINE_COMMENT_PREFIX_LENGTH;", "+\t\t\t\t\t\tnewLineString = newLineBuffer.toString();", "+\t\t\t\t    \tfirstColumn = this.column;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.column = firstColumn;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (lastTokenEndPosition > spaceEndPosition) {", "+\t\t\t\t\t\tthis.column += lastTokenEndPosition - (spaceEndPosition + 1); // add all previous tokens lengths since last space", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.edits[this.editsIndex-1].offset == spaceStartPosition) {", "+\t\t\t\t\t\t// previous space was already edited, so remove it", "+\t\t\t\t\t\tthis.editsIndex--;", "+\t\t\t\t\t}", "+\t\t\t\t\taddReplaceEdit(spaceStartPosition, spaceEndPosition, newLineString);", "+\t\t\t\t\tspaceStartPosition = -1;", "+\t\t\t\t\tif (insertSpace) {", "+\t\t\t\t\t\ttokenLength--; // reduce token length as the space will be replaced by the new line", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// replace space if needed", "+\t\t\t\telse if (insertSpace) {", "+\t\t\t\t\taddReplaceEdit(spaceStartPosition, this.scanner.startPosition-1, \" \"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// update column position and store info of the current token", "+\t\t\tthis.column += tokenLength;", "-\t\t\tpreviousPosition = this.scanner.currentPosition;", "-\t\t\tfirstWord = false;", "+\t\t\tlastTokenEndPosition = this.scanner.currentPosition;", "-\t\t// Add remaining buffered tokens", "-\t\tif (tokensBuffer.length() > 0) {", "-\t\t\tbuffer.append(tokensBuffer);", "-\t\t\tthis.column += tokensBuffer.length();", "-\t\t}", "-", "-\t\t// Append separator if the comment is not at the end of file", "+\t\t// Skip separator if the comment is not at the end of file", "-\t\tthis.scanner.resetTo(previousPosition, commentEnd);", "+\t\tthis.scanner.resetTo(lastTokenEndPosition, commentEnd);", "-\t\t\tpreviousPosition = this.scanner.currentPosition;", "+\t\t\tspaceEndPosition = this.scanner.currentPosition;", "-", "-\t\t// Replace the existing comment with new one", "-\t\tif (buffer.length() > 0) {", "-\t\t\taddReplaceEdit(editStart, previousPosition - 1, buffer.toString());", "+\t\t", "+\t\t// Delete leading whitespaces if any", "+\t\tif (previousToken != -1 && lastTokenEndPosition != commentStart && spaceEndPosition > lastTokenEndPosition) {", "+\t\t\taddDeleteEdit(lastTokenEndPosition, spaceEndPosition-1);"]}], "num": 29821}