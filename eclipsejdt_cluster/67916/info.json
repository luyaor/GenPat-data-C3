{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3dacbc9355f19aae3e7f9721328329c0", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7289468e4135f768aa2f02c70fd2b567", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "d7a2176a086ffe5cc9f82c35abb4d496e220561a", "commitAfterChange": "583238ffeb9a97546ad084c6e7cea427e3752805", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tTypeBinding receiverErasure = this.actualReceiverType.erasure();", "-\tif (receiverErasure instanceof ReferenceBinding) {", "-\t\tif (receiverErasure.findSuperTypeOriginatingFrom(fieldBinding.declaringClass) == null) {", "-\t\t\tthis.actualReceiverType = fieldBinding.declaringClass; // handle indirect inheritance thru variable secondary bound", "-\t\t}", "-\t}", "+\t// handle indirect inheritance thru variable secondary bound", "+\t// receiver may receive generic cast, as part of implicit conversion", "+\tTypeBinding oldReceiverType = this.actualReceiverType;", "+\tthis.actualReceiverType = this.actualReceiverType.getErasureCompatibleType(fieldBinding.declaringClass);", "+\tif (this.actualReceiverType != oldReceiverType && this.receiver.postConversionType(scope) != this.actualReceiverType) { // record need for explicit cast at codegen since receiver could not handle it", "+\t\tthis.bits |= NeedReceiverGenericCast;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac7440f9f5f44545dc2c90f1242024e0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java", "commitBeforeChange": "16d54acda4e0b7a146a54bf4587ffd8f08316b0a", "commitAfterChange": "adb31abd7b76aacf34a5241ce11f6a5ccfcea015", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "  \tpublic void resolve()", "signatureAfterChange": "  \tpublic void resolve()", "diff": ["-\t\tif (this.currentPackage != null) {", "-\t\t\tboolean packageInfo = CharOperation.equals(this.getMainTypeName(), TypeConstants.PACKAGE_INFO_NAME);", "+\t\tboolean isPackageInfo = isPackageInfo();", "+\t\tif (this.types != null && isPackageInfo) {", "+            // resolve synthetic type declaration", "+\t\t\tfinal TypeDeclaration syntheticTypeDeclaration = types[0];", "+\t\t\tsyntheticTypeDeclaration.resolve(this.scope);", "+\t\t\t// resolve annotations if any", "-\t\t\t\tif (packageInfo) {", "-                    if (this.types != null) {", "-                        // resolve annotations", "-    \t\t\t\t\tfinal TypeDeclaration syntheticTypeDeclaration = types[0];", "-    \t\t\t\t\tsyntheticTypeDeclaration.resolve(this.scope);", "-    \t\t\t\t\tresolveAnnotations(syntheticTypeDeclaration.staticInitializerScope, this.currentPackage.annotations, this.scope.fPackage);", "-    \t\t\t\t\t// set the synthetic bit", "-    \t\t\t\t\tsyntheticTypeDeclaration.binding.modifiers |= AccSynthetic;", "-    \t\t\t\t\tstartingTypeIndex = 1;", "-                    }", "-\t\t\t\t} else {", "-\t\t\t\t\tscope.problemReporter().invalidFileNameForPackageAnnotations(this.currentPackage.annotations[0]);", "-\t\t\t\t}", "+\t\t\t\tresolveAnnotations(syntheticTypeDeclaration.staticInitializerScope, this.currentPackage.annotations, this.scope.fPackage);", "-\t\t\t\tif (packageInfo) {", "-\t\t\t\t\tthis.javadoc.resolve(this.scope);", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\t\tthis.javadoc.resolve(syntheticTypeDeclaration.staticInitializerScope);", "+    \t\t}", "+\t\t\t// set the synthetic bit", "+\t\t\tsyntheticTypeDeclaration.binding.modifiers |= AccSynthetic;", "+\t\t\tstartingTypeIndex = 1;", "+\t\t}", "+\t\tif (this.currentPackage != null && this.currentPackage.annotations != null && !isPackageInfo) {", "+\t\t\tscope.problemReporter().invalidFileNameForPackageAnnotations(this.currentPackage.annotations[0]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7595c91c4d8d8596e449efe4e978a0f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java", "commitBeforeChange": "d7a2176a086ffe5cc9f82c35abb4d496e220561a", "commitAfterChange": "583238ffeb9a97546ad084c6e7cea427e3752805", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t// compute generic cast if necessary", "-\t\t\tTypeBinding receiverErasure = this.actualReceiverType.erasure();", "-\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "-\t\t\t\tif (receiverErasure.findSuperTypeOriginatingFrom(this.binding.declaringClass) == null) {", "-\t\t\t\t\tthis.actualReceiverType = this.binding.declaringClass; // handle indirect inheritance thru variable secondary bound", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\t// handle indirect inheritance thru variable secondary bound", "+\t\t\t// receiver may receive generic cast, as part of implicit conversion", "+\t\t\tTypeBinding oldReceiverType = this.actualReceiverType;", "+\t\t\tthis.actualReceiverType = this.actualReceiverType.getErasureCompatibleType(this.binding.declaringClass);", "+\t\t\tif (this.actualReceiverType != oldReceiverType && this.receiver.postConversionType(scope) != this.actualReceiverType) { // record need for explicit cast at codegen since receiver could not handle it", "+\t\t\t\tthis.bits |= NeedReceiverGenericCast;", "+\t\t\t}\t\t\t"]}], "num": 67916}