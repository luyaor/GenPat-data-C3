{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c535cc27ba17c36d7635967316a4cc54", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a3ae073cb689c2b30897eb59079197eb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tpublic void resolve(BlockScope scope)", "signatureAfterChange": " \t \tpublic void resolve(BlockScope scope)", "diff": ["-\t\t\tif (accessMode != This)", "+\t\t\tboolean rcvHasError = false;", "+\t\t\tif (this.accessMode != ExplicitConstructorCall.This) {", "-", "-\t\t\tif (receiverType == null) {", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t\t// prevent (explicit) super constructor invocation from within enum", "-\t\t\tif (this.accessMode == Super && receiverType.erasure().id == T_JavaLangEnum) {", "-\t\t\t\tscope.problemReporter().cannotInvokeSuperConstructorInEnum(this, methodScope.referenceMethod().binding);", "-\t\t\t}", "-\t\t\t// qualification should be from the type of the enclosingType", "-\t\t\tif (qualification != null) {", "-\t\t\t\tif (accessMode != Super) {", "-\t\t\t\t\tscope.problemReporter().unnecessaryEnclosingInstanceSpecification(", "-\t\t\t\t\t\tqualification,", "-\t\t\t\t\t\treceiverType);", "+\t\t\t\tTypeReference superclassRef = scope.referenceType().superclass;", "+\t\t\t\tif (superclassRef != null && superclassRef.resolvedType != null && !superclassRef.resolvedType.isValidBinding()) {", "+\t\t\t\t\trcvHasError = true;", "-\t\t\t\tReferenceBinding enclosingType = receiverType.enclosingType();", "-\t\t\t\tif (enclosingType == null) {", "-\t\t\t\t\tscope.problemReporter().unnecessaryEnclosingInstanceSpecification(", "-\t\t\t\t\t\tqualification,", "-\t\t\t\t\t\treceiverType);", "-\t\t\t\t\tthis.bits |= ASTNode.DiscardEnclosingInstance;", "-\t\t\t\t} else {", "-\t\t\t\t\tTypeBinding qTb = qualification.resolveTypeExpecting(scope, enclosingType);", "-\t\t\t\t\tqualification.computeConversion(scope, qTb, qTb);", "+\t\t\t}", "+\t\t\tif (receiverType != null) {", "+\t\t\t\t// prevent (explicit) super constructor invocation from within enum", "+\t\t\t\tif (this.accessMode == ExplicitConstructorCall.Super && receiverType.erasure().id == TypeIds.T_JavaLangEnum) {", "+\t\t\t\t\tscope.problemReporter().cannotInvokeSuperConstructorInEnum(this, methodScope.referenceMethod().binding);", "+\t\t\t\t}", "+\t\t\t\t// qualification should be from the type of the enclosingType", "+\t\t\t\tif (this.qualification != null) {", "+\t\t\t\t\tif (this.accessMode != ExplicitConstructorCall.Super) {", "+\t\t\t\t\t\tscope.problemReporter().unnecessaryEnclosingInstanceSpecification(", "+\t\t\t\t\t\t\tthis.qualification,", "+\t\t\t\t\t\t\treceiverType);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!rcvHasError) {", "+\t\t\t\t\t\tReferenceBinding enclosingType = receiverType.enclosingType();", "+\t\t\t\t\t\tif (enclosingType == null) {", "+\t\t\t\t\t\t\tscope.problemReporter().unnecessaryEnclosingInstanceSpecification(this.qualification, receiverType);", "+\t\t\t\t\t\t\tthis.bits |= ASTNode.DiscardEnclosingInstance;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tTypeBinding qTb = this.qualification.resolveTypeExpecting(scope, enclosingType);", "+\t\t\t\t\t\t\tthis.qualification.computeConversion(scope, qTb, qTb);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\tboolean argHasError = scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_5;", "-\t\t\t\tboolean argHasError = false; // typeChecks all arguments", "+\t\t\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "+\t\t\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t\t\t\tthis.arguments[i].resolveType(scope);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}\t\t\t\t\t", "-\t", "-\t\t\tif (arguments != null) {", "+\t\t\tif (this.arguments != null) {", "-\t\t\t\tint length = arguments.length;", "+\t\t\t\tint length = this.arguments.length;", "-\t\t\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\t\t\t\targument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\t\t\t\t\tif (receiverType == null) {", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "-\t\t\t} else if (receiverType.erasure().id == T_JavaLangEnum) {", "+\t\t\t} else if (receiverType.erasure().id == TypeIds.T_JavaLangEnum) {", "-\t\t\tif ((binding = scope.getConstructor(receiverType, argumentTypes, this)).isValidBinding()) {", "-\t\t\t\tif (isMethodUseDeprecated(this.binding, scope, this.accessMode != ImplicitSuper))", "-\t\t\t\t\tscope.problemReporter().deprecatedMethod(binding, this);", "-\t\t\t\tcheckInvocationArguments(scope, null, receiverType, binding, this.arguments, argumentTypes, argsContainCast, this);", "-\t\t\t\tif (binding.isPrivate() || receiverType.isLocalType()) {", "-\t\t\t\t\tbinding.original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\tif (receiverType == null) {", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tif ((this.binding = scope.getConstructor(receiverType, argumentTypes, this)).isValidBinding()) {", "+\t\t\t\tif ((this.binding.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\tif (!methodScope.enclosingSourceType().isAnonymousType()) {", "+\t\t\t\t\t\tscope.problemReporter().missingTypeInConstructor(this, this.binding);", "+\t\t\t\t\t}", "+\t\t\t\t}\t\t\t\t", "+\t\t\t\tif (isMethodUseDeprecated(this.binding, scope, this.accessMode != ExplicitConstructorCall.ImplicitSuper)) {", "+\t\t\t\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "-\t\t\t\tif (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "+\t\t\t\tcheckInvocationArguments(scope, null, receiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this);", "+\t\t\t\tif (this.binding.isPrivate() || receiverType.isLocalType()) {", "+\t\t\t\t\tthis.binding.original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t}", "+\t\t\t\tif (this.typeArguments != null ", "+\t\t\t\t\t\t&& this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "-\t\t\t\tif (binding.declaringClass == null)", "-\t\t\t\t\tbinding.declaringClass = receiverType;", "-\t\t\t\tscope.problemReporter().invalidConstructor(this, binding);", "+\t\t\t\tif (this.binding.declaringClass == null) {", "+\t\t\t\t\tthis.binding.declaringClass = receiverType;", "+\t\t\t\t}", "+\t\t\t\tif (rcvHasError)", "+\t\t\t\t\treturn;", "+\t\t\t\tscope.problemReporter().invalidConstructor(this, this.binding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc8392b12ceb2ea622873ccaa8a5fb39", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "6a44e0777af1a4632e0d20c0e9b92d35d2ad59f3", "commitAfterChange": "2ca339c139c0fe73a5bd2705f66592731098d347", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "diff": ["-\t\tchar[] source = this.scanner.source;", "-\t\tif (false/*this.sourceParser.checkAnnotation*/) {", "-\t\t\tthis.annotation = new Annotation(annotationStart, annotationEnd);", "-\t\t} else {", "-\t\t\tthis.annotation = null;", "-\t\t} ", "-\t", "-\t\tint firstLineNumber = this.scanner.getLineNumber(annotationStart);", "-\t\tint lastLineNumber = this.scanner.getLineNumber(annotationEnd);", "-\t\tint[] index = new int[]{ 0 };", "-\t\t\t\t", "-\t\t// scan line per line, since tags are supposed to be at beginning of lines only", "-\t\tnextLine: for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "-\t\t\tint lineStart = this.scanner.getLineStart(line);", "-\t\t\tif (line == firstLineNumber) lineStart = annotationStart + 3; // skip leading /**", "-\t\t\tint lineEnd = this.scanner.getLineEnd(line);", "-\t\t\tif (line == lastLineNumber) lineEnd = annotationEnd - 2; // remove trailing */", "-\t\t\tindex[0] = lineStart;", "-\t\t\tboolean foundStar = false;", "-\t\t\twhile (index[0] < lineEnd) {", "-\t\t\t\tchar nextCharacter = getNextCharacter(source, index); // consider unicodes", "-\t\t\t\tswitch(nextCharacter) {", "-\t\t\t\t\tcase '@' :", "-\t\t\t\t\t\tif (this.annotation == null) {", "-\t\t\t\t\t\t\tif ((getNextCharacter(source, index) == 'd')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'p')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'r')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'c')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'a')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 't')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'd')) {", "-\t\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "-\t\t\t\t\t\t\t\tnextCharacter = getNextCharacter(source, index);", "-\t\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "-\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t\tbreak nextLine; // done", "+\t\ttry {", "+\t\t\tthis.source = this.sourceParser.scanner.source;", "+\t\t\tif (this.sourceParser.options.checkAnnotation) {", "+\t\t\t\tthis.annotation = new Annotation(annotationStart, annotationEnd);", "+\t\t\t\tthis.identifierPtr = -1;", "+\t\t\t} else {", "+\t\t\t\tthis.annotation = null;", "+\t\t\t} ", "+\t\t", "+\t\t\tint firstLineNumber = this.sourceParser.scanner.getLineNumber(annotationStart);", "+\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(annotationEnd);", "+\t\t\t\t\t", "+\t\t\t// scan line per line, since tags must be at beginning of lines only", "+\t\t\tnextLine: for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "+\t\t\t\tboolean foundStar = false;", "+\t\t\t\tint lineStart = line == firstLineNumber ", "+\t\t\t\t\t\t? annotationStart + 3 \t\t// skip leading /**", "+\t\t\t\t\t\t:  this.sourceParser.scanner.getLineStart(line);", "+\t\t\t\tthis.index[0] = lineStart;", "+\t\t\t\tint lineEnd = line == lastLineNumber", "+\t\t\t\t\t\t? annotationEnd - 2 \t\t// remove trailing */", "+\t\t\t\t\t\t:  this.sourceParser.scanner.getLineEnd(line);", "+\t\t\t\twhile (this.index[0] < lineEnd) {", "+\t\t\t\t\tchar nextCharacter = readChar(); // consider unicodes", "+\t\t\t\t\tswitch(nextCharacter) {", "+\t\t\t\t\t\tcase '@' :", "+\t\t\t\t\t\t\tif (this.annotation == null) {", "+\t\t\t\t\t\t\t\tif ((readChar() == 'd')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'p')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'r')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'c')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'a')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 't')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'd')) {", "+\t\t\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "+\t\t\t\t\t\t\t\t\tnextCharacter = readChar();", "+\t\t\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "+\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t\tbreak nextLine; // done", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\t\t} ", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.index[0], lineEnd);", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\tswitch (this.scanner.getNextToken()) {", "+\t\t\t\t\t\t\t\t\tcase  TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseParam();", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_THROWS) || CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseThrows();", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseSee();", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "+\t\t\t\t\t\t\t\t\t\tparseReturn();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t\t} ", "-/*", "- \t\t\t\t\t\t// parse annotation", "-\t\t\t\t\t\tint tagStart = index[0], tagEnd = 0;", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tsaveScannerState();", "-\t\t\t\t\t\t\tthis.scanner.startPosition = index[0];", "-\t\t\t\t\t\t\tthis.scanner.currentPosition = index[0];", "-\t\t\t\t\t\t\tthis.scanner.currentCharacter = -1;", "-\t\t\t\t\t\t\t// read tag", "-\t\t\t\t\t\t\tparseTag();", "-\t\t\t\t\t\t} finally {", "-\t\t\t\t\t\t\tloadScannerState();", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\t\tdo {", "-\t\t\t\t\t\t\tnextCharacter = getNextCharacter(source, index);", "-\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk", "-\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') break; ", "-\t\t\t\t\t\t\tthis.annotationBuffer[bufferLength++] = nextCharacter;", "-\t\t\t\t\t\t\ttagEnd = index[0];", "-\t\t\t\t\t\t} while (index[0] < lineEnd);", "-\t\t\t\t\t\tif (bufferLength == 0) continue nextLine;", "-\t\t\t\t\t\tchar[] tag = null;", "-\t\t\t\t\t\tswitch(this.annotationBuffer[0]) {", "-\t\t\t\t\t\t\tcase 'd' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_DEPRECATED, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_DEPRECATED;", "-\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase 'e' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_EXCEPTION, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_EXCEPTION;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase 't' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_THROWS, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_THROWS;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 's' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_SEE, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_SEE;", "-\t\t\t\t\t\t\t\t} else if (CharOperation.equals(Annotation.TAG_SINCE, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_SINCE;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 'p' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_PARAM, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_PARAM;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 'r' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_RETURN, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_RETURN;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (tag == null) {", "-\t\t\t\t\t\t\ttag = new char[bufferLength];", "-\t\t\t\t\t\t\tSystem.arraycopy(this.annotationBuffer, 0, tag, 0, bufferLength);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// read argument", "-\t\t\t\t\t\tint argumentStart = index[0];", "-\t\t\t\t\t\twhile (argumentStart < lineEnd && Character.isWhitespace(source[argumentStart])) argumentStart++; // trim argument leading spaces", "-\t\t\t\t\t\tint argumentEnd = lineEnd-1;", "-\t\t\t\t\t\twhile (argumentEnd > argumentStart && Character.isWhitespace(source[argumentEnd])) argumentEnd--; // trim argument trailing spaces", "-\t\t\t\t\t\tbufferLength = 0;", "-\t\t\t\t\t\tfor (index[0] = argumentStart; index[0] <= argumentEnd;) {", "-\t\t\t\t\t\t\tthis.annotationBuffer[bufferLength++] = getNextCharacter(source, index);", "-\t\t\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t\t\tchar[] argument = new char[bufferLength];", "-\t\t\t\t\t\tSystem.arraycopy(this.annotationBuffer, 0, argument, 0, bufferLength);", "-\t\t\t\t\t\tannotation.record(tag, argument, tagStart, argumentEnd);", "-*/\t\t\t\t\t\t", "-\t\t\t\t\t\tcontinue nextLine;", "-\t\t\t\t\tcase '*' :", "-\t\t\t\t\t\tif (foundStar) continue nextLine;", "-\t\t\t\t\t\tfoundStar = true;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault :", "-\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) continue nextLine;", "+\t\t\t\t\t\tcase '*' :", "+\t\t\t\t\t\t\tif (foundStar) continue nextLine;", "+\t\t\t\t\t\t\tfoundStar = true;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) continue nextLine;", "+\t\t\t\t\t}", "-\t\t}", "-\t\t", "+\t\t} finally {", "+\t\t\tthis.source = null; // release source as soon as finished", "+\t\t}\t\t"]}], "num": 11438}