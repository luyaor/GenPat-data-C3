{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "25f036b976e58a7c73050a4d4b391b6d", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "28d7983c5f15aafed93a26397eb0fc57", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptCompilationParticipant.java", "commitBeforeChange": "bfcd45867d04fefcde8c411b2c4f613fed962f2b", "commitAfterChange": "8360857ac96415dcd60ac94fbc284e7801424ade", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t \tpublic void processAnnotations(ICompilationParticipantResult[] filesWithAnnotations, boolean isBatchBuild)", "signatureAfterChange": " \t \tpublic void processAnnotations(ICompilationParticipantResult[] allfiles)", "diff": ["-\tpublic void processAnnotations(ICompilationParticipantResult[] filesWithAnnotations, boolean isBatchBuild) {", "-\t\tif( filesWithAnnotations == null || filesWithAnnotations.length == 0 )", "+\t", "+\tpublic void processAnnotations(ICompilationParticipantResult[] allfiles) {\t", "+\t\t// This should not happen. There should always be file that that needs ", "+\t\t// building when ", "+\t\tfinal int total = allfiles == null ? 0 : allfiles.length;", "+\t\tif( total == 0 )", "-\t\tfinal IProject project = filesWithAnnotations[0].getFile().getProject();", "+", "+\t\tfinal IProject project = allfiles[0].getFile().getProject();", "-\t\t}\t\t\t", "+\t\t}", "+\t\t", "+\t\tif ( _isBatch && _buildRound == 0 ) {", "+\t\t\tAnnotationProcessorFactoryLoader.getLoader().resetBatchProcessors(javaProject);", "+\t\t\t_previousRoundsBatchFactories.clear();", "+\t\t}", "-\t\t\tif (isBatchBuild && _buildRound == 0 ) {", "-\t\t\t\tAnnotationProcessorFactoryLoader.getLoader().resetBatchProcessors(javaProject);", "-\t\t\t\t_previousRoundsBatchFactories.clear();", "+\t\t", "+\t\t\t// split up the list of files with annotations from those that don't", "+\t\t\t// also exclude files that has already been processed.", "+\t\t\tint annoFileCount = 0;", "+\t\t\tint noAnnoFileCount = 0;", "+\t\t\tfor( int i=0; i<total; i++ ){", "+\t\t\t\tif( _buildRound > 0 && _processedFiles.contains( allfiles[i].getFile() )){", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tif( allfiles[i].hasAnnotations() )", "+\t\t\t\t\tannoFileCount ++;", "+\t\t\t\telse", "+\t\t\t\t\tnoAnnoFileCount ++;", "+\t\t\t// apt has already processed all files", "+\t\t\t// files that are reported at this point is triggered by", "+\t\t\t// dependencies introduced by type creation. ", "+\t\t\tif( annoFileCount == 0 && noAnnoFileCount == 0 )", "+\t\t\t\treturn;", "+\t\t\t", "+\t\t\tICompilationParticipantResult[] withAnnotation = null;", "+\t\t\tICompilationParticipantResult[] withoutAnnotation = null;", "+\t\t\t", "+\t\t\tif( annoFileCount != 0 )", "+\t\t\t\twithAnnotation = new ICompilationParticipantResult[annoFileCount];", "+\t\t\tif(noAnnoFileCount != 0 )", "+\t\t\t\twithoutAnnotation = new ICompilationParticipantResult[noAnnoFileCount];", "+\t\t\tint wIndex = 0; // index for 'withAnnotation' array", "+\t\t\tint woIndex = 0; // index of 'withoutAnnotation' array", "+\t\t\tfor( int i=0; i<total; i++ ){\t\t", "+\t\t\t\tif( _processedFiles.contains( allfiles[i].getFile() ) )", "+\t\t\t\t\tcontinue;", "+\t\t\t\tif( allfiles[i].hasAnnotations() )", "+\t\t\t\t\twithAnnotation[wIndex ++] = allfiles[i];", "+\t\t\t\telse", "+\t\t\t\t\twithoutAnnotation[woIndex ++] = allfiles[i];", "+\t\t\t}", "+\t\t\t", "+\t\t\tfor( ICompilationParticipantResult file : allfiles )", "+\t\t\t\t_processedFiles.add(file.getFile());", "-\t\t\tAptProject aptProject = AptPlugin.getAptProject(javaProject);", "+\t\t\tAptProject aptProject = AptPlugin.getAptProject(javaProject);\t\t\t", "-\t\t\t\tAPTDispatchRunnable.runAPTDuringBuild(filesWithAnnotations, aptProject, factories, _previousRoundsBatchFactories, isBatchBuild);", "+\t\t\t\tAPTDispatchRunnable.runAPTDuringBuild(", "+\t\t\t\t\t\twithAnnotation, ", "+\t\t\t\t\t\twithoutAnnotation,", "+\t\t\t\t\t\taptProject, ", "+\t\t\t\t\t\tfactories, ", "+\t\t\t\t\t\t_previousRoundsBatchFactories, ", "+\t\t\t\t\t\t_isBatch);", "-\t\t\tif (isBatchBuild) {", "+\t\t\tif (_isBatch) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f2683052ca902b1314b8e9247d14b6bf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java", "commitBeforeChange": "a1ad7ed237b99cea40e4be02872fbc81f27fd996", "commitAfterChange": "039d36406bcab8d55430422b8fa21e6430ca432b", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public void finalizeProblems()", "signatureAfterChange": "  public void finalizeProblems()", "diff": ["-\tif (this.suppressWarningsCount == 0) return;", "+\tif (this.suppressWarningsCount == 0) {", "+\t\tif (this.compilationResult.hasErrors()) {", "+\t\t\t// we need to check if we should discard unused locals warnings (336648)", "+\t\t\tint removed = 0;", "+\t\t\tCategorizedProblem[] problems = this.compilationResult.problems;", "+\t\t\tint problemCount = this.compilationResult.problemCount;", "+\t\t\tfor (int i = 0; i < problemCount; i++) {", "+\t\t\t\tif (problems[i].getID() == IProblem.LocalVariableIsNeverUsed) {", "+\t\t\t\t\tproblems[i] = null;", "+\t\t\t\t\tremoved++;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// compact remaining problems", "+\t\t\tif (removed > 0) {", "+\t\t\t\tfor (int i = 0, index = 0; i < problemCount; i++) {", "+\t\t\t\t\tCategorizedProblem problem;", "+\t\t\t\t\tif ((problem = problems[i]) != null) {", "+\t\t\t\t\t\tif (i > index) {", "+\t\t\t\t\t\t\tproblems[index++] = problem;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tindex++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tthis.compilationResult.problemCount -= removed;", "+\t\t\t}", "+\t\t}", "+\t\treturn;", "+\t}", "+\tint remainingErrors = 0;", "-\t\tif (problem.isError()) {", "+\t\tboolean isError = problem.isError();", "+\t\tif (isError) {", "+\t\t\t\tremainingErrors++;", "+\t\t\t\tremainingErrors++;", "-\t\t\tif (start < startSuppress) continue nextSuppress;", "-\t\t\tif (end > endSuppress) continue nextSuppress;", "-\t\t\tif (!this.suppressWarningIrritants[iSuppress].isSet(irritant))", "+\t\t\tif (start < startSuppress) {", "+\t\t\t}", "+\t\t\tif (end > endSuppress) {", "+\t\t\t\tcontinue nextSuppress;", "+\t\t\t}", "+\t\t\tif (!this.suppressWarningIrritants[iSuppress].isSet(irritant)) {", "+\t\t\t\tcontinue nextSuppress;", "+\t\t\t}", "+\t\t\tif (isError) {", "+\t\t\t\tthis.compilationResult.numberOfErrors--;", "+\t\t\t}", "+\t\tif (isError) {", "+\t\t\tremainingErrors++;", "+\t\t}", "+\t}", "+\t// we need to check if we should discard unused locals warnings that were not already filtered out (336648)", "+\tif (remainingErrors > 0) {", "+\t\tfor (int i = 0; i < problemCount; i++) {", "+\t\t\tCategorizedProblem problem;", "+\t\t\tif ((problem = problems[i]) != null && problem.getID() == IProblem.LocalVariableIsNeverUsed) {", "+\t\t\t\tproblems[i] = null;", "+\t\t\t\tremoved++;", "+\t\t\t}", "+\t\t}"]}], "num": 41558}