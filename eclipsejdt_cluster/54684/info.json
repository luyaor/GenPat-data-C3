{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5b52bce72d4a31cc21af932f1d83b22f", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8c28015ca23939f6a774178bda48c3df", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "e37ddd2cb60251da977bfe008d0c558febeb1616", "commitAfterChange": "ddff16f6a6b8fee88d497b4653d14d58ccda81b4", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "diff": ["+\tboolean playingTrump = false;", "-\t\t\t// re-checking compatibility is needed for https://bugs.eclipse.org/346029", "-\t\t\tif (concreteMethod != null && !(isOverridden[i] && areMethodsCompatible(concreteMethod, methods[i]))) {", "-\t\t\t\t// 8.4.8.4 defines an exception for default methods if", "-\t\t\t\t// (a) there exists an abstract method declared in a superclass of C and inherited by C", "-\t\t\t\t// (b) that is override-equivalent with the two methods.", "-\t\t\t\tif (methods[i].isDefaultMethod() ", "-\t\t\t\t\t\t&& superClassMethod != null\t\t\t\t\t\t\t// condition (a)", "-\t\t\t\t\t\t&& areParametersEqual(superClassMethod, methods[i]) // condition (b)...", "-\t\t\t\t\t\t&& areParametersEqual(superClassMethod, concreteMethod)) {", "-\t\t\t\t\t// skip, class method trumps this default method", "-\t\t\t\t} else {", "+\t\t\t// 8.4.8.4 defines an exception for default methods if", "+\t\t\t// (a) there exists an abstract method declared in a superclass of C and inherited by C", "+\t\t\t// (b) that is override-equivalent with the two methods.", "+\t\t\tif (methods[i].isDefaultMethod()", "+\t\t\t\t\t&& superClassMethod != null\t\t\t\t\t\t\t// condition (a)", "+\t\t\t\t\t&& areParametersEqual(superClassMethod, methods[i]) // condition (b)...", "+\t\t\t\t\t&& (concreteMethod == null || areParametersEqual(superClassMethod, concreteMethod))) {", "+\t\t\t\t// skip, class method trumps this default method", "+\t\t\t\tplayingTrump = true;", "+\t\t\t} else {", "+\t\t\t\tplayingTrump = false;", "+\t\t\t\t// re-checking compatibility is needed for https://bugs.eclipse.org/346029", "+\t\t\t\tif (concreteMethod != null && !(isOverridden[i] && areMethodsCompatible(concreteMethod, methods[i]))) {", "+\t\tif (concreteMethod != null && concreteMethod.isDefaultMethod()) {", "+\t\t\tif (playingTrump) {", "+\t\t\t\t// multiple abstract & default methods are OK on this branch, but then the class must be declared abstract:", "+\t\t\t\tif (!this.type.isAbstract()) {", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\tif (methods[i] == concreteMethod) continue;", "+\t\t\t\t\t\tif (!doesMethodOverride(concreteMethod, methods[i])) {", "+\t\t\t\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, methods[i]);", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (this.environment.globalOptions.complianceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\t\t\tif (!checkInheritedDefaultMethods(methods, length))", "+\t\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b37e5878e21e1ea9ae7e4ea3801784c1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "a78bb88c7ea4587ba8eb2a245492f61be802a95c", "commitAfterChange": "778e64a3c8e6903c625067607c9068d73d8cd5e5", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "  void checkForRedundantSuperinterfaces(ReferenceBinding superclass, ReferenceBinding[] superInterfaces)", "signatureAfterChange": "  void checkForRedundantSuperinterfaces(ReferenceBinding superclass, ReferenceBinding[] superInterfaces)", "diff": ["-\tfor (int i = 0, l = superInterfaces.length; i < l; i++)", "-\t\tinterfacesToCheck.add(superInterfaces[i]);", "+\tnext : for (int i = 0, l = superInterfaces.length; i < l; i++) {", "+\t\tReferenceBinding toCheck = superInterfaces[i];", "+\t\tfor (int j = 0; j < l; j++) {", "+\t\t\tif (i != j && toCheck.implementsInterface(superInterfaces[j], true)) {", "+\t\t\t\tTypeReference[] refs = this.type.scope.referenceContext.superInterfaces;", "+\t\t\t\tfor (int r = 0, rl = refs.length; r < rl; r++) {", "+\t\t\t\t\tif (refs[r].resolvedType == toCheck) {", "+\t\t\t\t\t\tproblemReporter().redundantSuperInterface(this.type, refs[r], toCheck, superInterfaces[j]);", "+\t\t\t\t\t\tcontinue next;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tinterfacesToCheck.add(toCheck);", "+\t}", "+"]}], "num": 54684}