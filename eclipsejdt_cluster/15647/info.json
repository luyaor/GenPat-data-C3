{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "82b90d7b3941ae328b6b49c0bcb8a472", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "62c8d204acfe89d00e9248fdd46ac5af", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalCompletionProposal.java", "commitBeforeChange": "24cf489e4c973e29dff7eade9d41897f72a37db0", "commitAfterChange": "f924ed86fe1dbe148077a9cade20b11e404ba89b", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tprotected char[][] createDefaultParameterNames(int length)", "signatureAfterChange": " \t \tprotected char[][] findConstructorParameterNames(char[] declaringTypePackageName, char[] declaringTypeName, char[] selector, char[][] paramTypeNames)", "diff": ["+\t", "+\tprotected char[][] findConstructorParameterNames(char[] declaringTypePackageName, char[] declaringTypeName, char[] selector, char[][] paramTypeNames){", "+\t\tif(paramTypeNames == null || declaringTypeName == null) return null;", "-\tprotected char[][] createDefaultParameterNames(int length) {", "-\t\tchar[][] parameters;", "-\t\tswitch (length) {", "-\t\t\tcase 0 :", "-\t\t\t\tparameters = new char[length][];", "-\t\t\t\tbreak;", "-\t\t\tcase 1 :", "-\t\t\t\tparameters = ARGS1;", "-\t\t\t\tbreak;", "-\t\t\tcase 2 :", "-\t\t\t\tparameters = ARGS2;", "-\t\t\t\tbreak;", "-\t\t\tcase 3 :", "-\t\t\t\tparameters = ARGS3;", "-\t\t\t\tbreak;", "-\t\t\tcase 4 :", "-\t\t\t\tparameters = ARGS4;", "-\t\t\t\tbreak;", "-\t\t\tdefault :", "-\t\t\t\tparameters = new char[length][];", "-\t\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\t\tparameters[i] = CharOperation.concat(ARG, String.valueOf(i).toCharArray());", "-\t\t\t\t}", "-\t\t\t\tbreak;", "+\t\tchar[][] parameters = null;", "+\t\tint length = paramTypeNames.length;", "+", "+\t\tchar[] tName = CharOperation.concat(declaringTypePackageName,declaringTypeName,'.');", "+\t\tObject cachedType = this.completionEngine.typeCache.get(tName);", "+", "+\t\tIType type = null;", "+\t\tif(cachedType != null) {", "+\t\t\tif(cachedType != NO_ATTACHED_SOURCE && cachedType instanceof BinaryType) {", "+\t\t\t\ttype = (BinaryType)cachedType;", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// TODO (david) shouldn't it be NameLookup.ACCEPT_ALL ?", "+\t\t\tNameLookup.Answer answer = this.nameLookup.findType(new String(tName),", "+\t\t\t\tfalse,", "+\t\t\t\tNameLookup.ACCEPT_CLASSES & NameLookup.ACCEPT_INTERFACES,", "+\t\t\t\ttrue/* consider secondary types */,", "+\t\t\t\tfalse/* do NOT wait for indexes */,", "+\t\t\t\tfalse/*don't check restrictions*/,", "+\t\t\t\tnull);", "+\t\t\ttype = answer == null ? null : answer.type;", "+\t\t\tif(type instanceof BinaryType){", "+\t\t\t\tthis.completionEngine.typeCache.put(tName, type);", "+\t\t\t} else {", "+\t\t\t\ttype = null;", "+\t\t\t}", "+", "+\t\tif(type != null) {", "+\t\t\tString[] args = new String[length];", "+\t\t\tfor(int i = 0;\ti< length ; i++){", "+\t\t\t\targs[i] = new String(paramTypeNames[i]);", "+\t\t\t}", "+\t\t\tIMethod method = type.getMethod(new String(selector),args);", "+\t\t\t", "+\t\t\tif (this.hasNoParameterNamesFromIndex) {", "+\t\t\t\tIPackageFragmentRoot packageFragmentRoot = (IPackageFragmentRoot)type.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);", "+\t\t\t\tif (packageFragmentRoot.isArchive() ||", "+\t\t\t\t\t\tthis.completionEngine.openedBinaryTypes < OPENED_BYNARY_TYPES_THRESHOLD) {", "+\t\t\t\t\tSourceMapper mapper = ((JavaElement)method).getSourceMapper();", "+\t\t\t\t\tif (mapper != null) {", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tchar[][] paramNames = mapper.getMethodParameterNames(method);", "+\t\t\t\t\t", "+\t\t\t\t\t\t\t// map source and try to find parameter names", "+\t\t\t\t\t\t\tif(paramNames == null) {", "+\t\t\t\t\t\t\t\tif (!packageFragmentRoot.isArchive()) this.completionEngine.openedBinaryTypes++;", "+\t\t\t\t\t\t\t\tIBinaryType info = (IBinaryType) ((BinaryType) type).getElementInfo();", "+\t\t\t\t\t\t\t\tchar[] source = mapper.findSource(type, info);", "+\t\t\t\t\t\t\t\tif (source != null){", "+\t\t\t\t\t\t\t\t\tmapper.mapSource(type, source, info);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tparamNames = mapper.getMethodParameterNames(method);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tif(paramNames != null) {", "+\t\t\t\t\t\t\t\tparameters = paramNames;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} catch(JavaModelException e){", "+\t\t\t\t\t\t\t//parameters == null;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\ttry{", "+\t\t\t\t\tIBinaryMethod info = (IBinaryMethod) ((JavaElement)method).getElementInfo();", "+\t\t\t\t\tchar[][] argumentNames = info.getArgumentNames();", "+\t\t\t\t\tif (argumentNames != null && argumentNames.length == length) {", "+\t\t\t\t\t\tparameters = argumentNames;", "+\t\t\t\t\t}", "+\t\t\t\t} catch(JavaModelException e){", "+\t\t\t\t\t//parameters == null;", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\ttry{", "+\t\t\t\t\tparameters = new char[length][];", "+\t\t\t\t\tString[] params = method.getParameterNames();", "+\t\t\t\t\tfor(int i = 0;\ti< length ; i++){", "+\t\t\t\t\t\tparameters[i] = params[i].toCharArray();", "+\t\t\t\t\t}", "+\t\t\t\t} catch(JavaModelException e){", "+\t\t\t\t\tparameters = null;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+", "+\t\t// default parameters name", "+\t\tif(parameters == null) {", "+\t\t\tparameters = CompletionEngine.createDefaultParameterNames(length);", "+\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ebdfa4bc01d3414d44c2f782c8f7c48a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessingState.java", "commitBeforeChange": "34f79b507663962f5a8b34c6546e7cf80423bb0b", "commitAfterChange": "0b3c372cd8063a26d1eaf5c9a3c9657a40eb4a99", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " \t \tpublic void initializeRoots(boolean initAfterLoad)", "signatureAfterChange": " \t \tpublic void initializeRoots(boolean initAfterLoad)", "diff": ["-\t\tHashMap[] rootInfos = null;", "+\t\tHashMap newRoots = null;", "+\t\tHashMap newOtherRoots = null;", "+\t\tHashMap newSourceAttachments = null;", "+\t\tHashMap newProjectDependencies = null;", "-\t\t\t\t", "-\t\t\t\trootInfos = getRootInfos(false/*don't use previous session values*/);", "+\t\t\t\tnewRoots = new HashMap();", "+\t\t\t\tnewOtherRoots = new HashMap();", "+\t\t\t\tnewSourceAttachments = new HashMap();", "+\t\t\t\tnewProjectDependencies = new HashMap();", "+\t\t", "+\t\t\t\tIJavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();", "+\t\t\t\tIJavaProject[] projects;", "+\t\t\t\ttry {", "+\t\t\t\t\tprojects = model.getJavaProjects();", "+\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t// nothing can be done", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\t\t\t\tJavaProject project = (JavaProject) projects[i];", "+\t\t\t\t\tIClasspathEntry[] classpath;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tclasspath = project.getResolvedClasspath();", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t// continue with next project", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t}", "+\t\t\t\t\tfor (int j= 0, classpathLength = classpath.length; j < classpathLength; j++) {", "+\t\t\t\t\t\tIClasspathEntry entry = classpath[j];", "+\t\t\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT) {", "+\t\t\t\t\t\t\tIJavaProject key = model.getJavaProject(entry.getPath().segment(0)); // TODO (jerome) reuse handle", "+\t\t\t\t\t\t\tIJavaProject[] dependents = (IJavaProject[]) newProjectDependencies.get(key);", "+\t\t\t\t\t\t\tif (dependents == null) {", "+\t\t\t\t\t\t\t\tdependents = new IJavaProject[] {project};", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tint dependentsLength = dependents.length;", "+\t\t\t\t\t\t\t\tSystem.arraycopy(dependents, 0, dependents = new IJavaProject[dependentsLength+1], 0, dependentsLength);", "+\t\t\t\t\t\t\t\tdependents[dependentsLength] = project;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tnewProjectDependencies.put(key, dependents);", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t", "+\t\t\t\t\t\t// root path", "+\t\t\t\t\t\tIPath path = entry.getPath();", "+\t\t\t\t\t\tif (newRoots.get(path) == null) {", "+\t\t\t\t\t\t\tnewRoots.put(path, new DeltaProcessor.RootInfo(project, path, ((ClasspathEntry)entry).fullInclusionPatternChars(), ((ClasspathEntry)entry).fullExclusionPatternChars(), entry.getEntryKind()));", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tArrayList rootList = (ArrayList)newOtherRoots.get(path);", "+\t\t\t\t\t\t\tif (rootList == null) {", "+\t\t\t\t\t\t\t\trootList = new ArrayList();", "+\t\t\t\t\t\t\t\tnewOtherRoots.put(path, rootList);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\trootList.add(new DeltaProcessor.RootInfo(project, path, ((ClasspathEntry)entry).fullInclusionPatternChars(), ((ClasspathEntry)entry).fullExclusionPatternChars(), entry.getEntryKind()));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t", "+\t\t\t\t\t\t// source attachment path", "+\t\t\t\t\t\tif (entry.getEntryKind() != IClasspathEntry.CPE_LIBRARY) continue;", "+\t\t\t\t\t\tString propertyString = null;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tpropertyString = Util.getSourceAttachmentProperty(path);", "+\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\te.printStackTrace();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tIPath sourceAttachmentPath;", "+\t\t\t\t\t\tif (propertyString != null) {", "+\t\t\t\t\t\t\tint index= propertyString.lastIndexOf(PackageFragmentRoot.ATTACHMENT_PROPERTY_DELIMITER);", "+\t\t\t\t\t\t\tsourceAttachmentPath = (index < 0) ?  new Path(propertyString) : new Path(propertyString.substring(0, index));", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tsourceAttachmentPath = entry.getSourceAttachmentPath();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (sourceAttachmentPath != null) {", "+\t\t\t\t\t\t\tnewSourceAttachments.put(sourceAttachmentPath, path);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\tif (this.rootsAreStale && rootInfos != null) { // double check again", "-\t\t\t\tthis.roots = rootInfos[0];", "-\t\t\t\tthis.otherRoots = rootInfos[1];", "-\t\t\t\tthis.sourceAttachments = rootInfos[2];", "-\t\t\t\tthis.projectDependencies = rootInfos[3];", "+\t\t\tif (this.rootsAreStale && newRoots != null) { // double check again", "+\t\t\t\tthis.roots = newRoots;", "+\t\t\t\tthis.otherRoots = newOtherRoots;", "+\t\t\t\tthis.sourceAttachments = newSourceAttachments;", "+\t\t\t\tthis.projectDependencies = newProjectDependencies;", "-\t}"]}], "num": 15647}