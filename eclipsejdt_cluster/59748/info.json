{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1e150cab12c5618e67faf5bd3c7eeaaa", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35d10583a0727711ff407b84e3102c80", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java", "commitBeforeChange": "08a2bb4b18c0c69c0ed4f816cadfd40ebe8abddb", "commitAfterChange": "d0e5b2ab614e06e582b08c94edd4cb759a159eaf", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r protected IType resolveType(char[] packageName, char[] typeName, int acceptFlags)", "signatureAfterChange": "\r protected IType resolveType(char[] packageName, char[] typeName, int acceptFlags)", "diff": ["-\tIPackageFragment[] pkgs = fNameLookup.findPackageFragments(\r", "-\t\t(packageName == null || packageName.length == 0) ? IPackageFragment.DEFAULT_PACKAGE_NAME : new String(packageName), \r", "-\t\tfalse);\r", "-\t// iterate type lookup in each package fragment\r", "-\tfor (int i = 0, length = pkgs == null ? 0 : pkgs.length; i < length; i++) {\r", "-\t\ttype= fNameLookup.findType(new String(typeName), pkgs[i], false, acceptFlags);\r", "-\t\tif (type != null) break;\t\r", "-\t}\r", "-\tif (type == null) {\r", "-\t\tString pName= IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "-\t\tif (packageName != null) {\r", "-\t\t\tpName = new String(packageName);\r", "-\t\t}\r", "-\t\tif (fCodeResolve != null && fCodeResolve.getParent().getElementName().equals(pName)) {\r", "-\t\t\t// look inside the type in which we are resolving in\r", "-\t\t\tString tName= new String(typeName);\r", "-\t\t\ttName = tName.replace('.','$');\r", "-\t\t\tIType[] allTypes= null;\r", "-\t\t\ttry {\r", "-\t\t\t\tjava.util.Vector v = ((JavaElement)fCodeResolve).getChildrenOfType(IJavaElement.TYPE);\r", "-\t\t\t\tallTypes = new IType[v.size()];\r", "-\t\t\t\tv.copyInto(allTypes);\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\treturn null;\r", "+\t\r", "+\tif (fCodeResolve instanceof WorkingCopy) {\r", "+\t\tWorkingCopy wc = (WorkingCopy) fCodeResolve;\r", "+\t\ttry {\r", "+\t\t\tif(((packageName == null || packageName.length == 0) && wc.getPackageDeclarations().length == 0) ||\r", "+\t\t\t\t(!(packageName == null || packageName.length == 0) && wc.getPackageDeclaration(new String(packageName)).exists())) {\r", "+\t\t\t\t\t\r", "+\t\t\t\ttype = wc.getType(new String(typeName));\r", "+\t\t\t\tif(!type.exists()) {\r", "+\t\t\t\t\ttype = null;\r", "+\t\t\t\t}\r", "-\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "-\t\t\t\tif (allTypes[i].getTypeQualifiedName().equals(tName)) {\r", "-\t\t\t\t\treturn allTypes[i];\r", "+\t\t}catch (JavaModelException e) {\r", "+\t\t\ttype = null;", "+\t\t}\r", "+\t}\r", "+\r", "+\tif(type == null) {\r", "+\t\tIPackageFragment[] pkgs = fNameLookup.findPackageFragments(\r", "+\t\t\t(packageName == null || packageName.length == 0) ? IPackageFragment.DEFAULT_PACKAGE_NAME : new String(packageName), \r", "+\t\t\tfalse);\r", "+\t\t// iterate type lookup in each package fragment\r", "+\t\tfor (int i = 0, length = pkgs == null ? 0 : pkgs.length; i < length; i++) {\r", "+\t\t\ttype= fNameLookup.findType(new String(typeName), pkgs[i], false, acceptFlags);\r", "+\t\t\tif (type != null) break;\t\r", "+\t\t}\r", "+\t\tif (type == null) {\r", "+\t\t\tString pName= IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "+\t\t\tif (packageName != null) {\r", "+\t\t\t\tpName = new String(packageName);\r", "+\t\t\t}\r", "+\t\t\tif (fCodeResolve != null && fCodeResolve.getParent().getElementName().equals(pName)) {\r", "+\t\t\t\t// look inside the type in which we are resolving in\r", "+\t\t\t\tString tName= new String(typeName);\r", "+\t\t\t\ttName = tName.replace('.','$');\r", "+\t\t\t\tIType[] allTypes= null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tjava.util.Vector v = ((JavaElement)fCodeResolve).getChildrenOfType(IJavaElement.TYPE);\r", "+\t\t\t\t\tallTypes = new IType[v.size()];\r", "+\t\t\t\t\tv.copyInto(allTypes);\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "+\t\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "+\t\t\t\t\tif (allTypes[i].getTypeQualifiedName().equals(tName)) {\r", "+\t\t\t\t\t\treturn allTypes[i];\r", "+\t\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9a41c31af3d2eadd9150bba06c8a1f99", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic IType lookupType(TypeBinding typeBinding)", "signatureAfterChange": " public IType lookupType(TypeBinding typeBinding)", "diff": ["-\t}", "-\tpublic IType lookupType(TypeBinding typeBinding) {", "-\t\tchar[] packageName = typeBinding.qualifiedPackageName();", "-\t\tchar[] typeName = typeBinding.qualifiedSourceName();", "-\t\t", "-\t\t// find package fragments", "-\t\tIPackageFragment[] pkgs = ", "-\t\t\tthis.nameLookup.findPackageFragments(", "-\t\t\t\t(packageName == null || packageName.length == 0) ? ", "-\t\t\t\t\tIPackageFragment.DEFAULT_PACKAGE_NAME : ", "-\t\t\t\t\tnew String(packageName), ", "-\t\t\t\tfalse);", "-\t\t\t\t", "-\t\t// iterate type lookup in each package fragment", "-\t\tfor (int i = 0, length = pkgs == null ? 0 : pkgs.length; i < length; i++) {", "-\t\t\tIType type = ", "-\t\t\t\tthis.nameLookup.findType(", "-\t\t\t\t\tnew String(typeName), ", "-\t\t\t\t\tpkgs[i], ", "-\t\t\t\t\tfalse, ", "-\t\t\t\t\ttypeBinding.isClass() ?", "-\t\t\t\t\t\tNameLookup.ACCEPT_CLASSES:", "-\t\t\t\t\t\tNameLookup.ACCEPT_INTERFACES);", "-\t\t\tif (type != null) return type;\t", "-\t\t// search inside enclosing element", "-\t\tchar[][] qualifiedName = CharOperation.splitOn('.', typeName);", "-\t\tint length = qualifiedName.length;", "-\t\tif (length == 0) return null;", "-\t\tIType type = this.createTypeHandle(qualifiedName[0]);", "+}", "+public IType lookupType(TypeBinding typeBinding) {", "+\tchar[] packageName = typeBinding.qualifiedPackageName();", "+\tIPackageFragment[] pkgs = this.nameLookup.findPackageFragments(", "+\t\t(packageName == null || packageName.length == 0)", "+\t\t\t? IPackageFragment.DEFAULT_PACKAGE_NAME", "+\t\t\t: new String(packageName), ", "+\t\tfalse);", "+", "+\t// iterate type lookup in each package fragment", "+\tchar[] sourceName = typeBinding.qualifiedSourceName();", "+\tString typeName = new String(sourceName);", "+\tfor (int i = 0, length = pkgs == null ? 0 : pkgs.length; i < length; i++) {", "+\t\tIType type = this.nameLookup.findType(", "+\t\t\ttypeName,", "+\t\t\tpkgs[i], ", "+\t\t\tfalse, ", "+\t\t\ttypeBinding.isClass() ? NameLookup.ACCEPT_CLASSES : NameLookup.ACCEPT_INTERFACES);", "+\t\tif (type != null) return type;\t", "+\t}", "+", "+\t// search inside enclosing element", "+\tchar[][] qualifiedName = CharOperation.splitOn('.', sourceName);", "+\tint length = qualifiedName.length;", "+\tif (length == 0) return null;", "+\tIType type = createTypeHandle(qualifiedName[0]);", "+\tif (type == null) return null;", "+\tfor (int i = 1; i < length; i++) {", "+\t\ttype = createTypeHandle(type, qualifiedName[i]);", "-\t\tfor (int i = 1; i < length; i++) {", "-\t\t\ttype = this.createTypeHandle(type, qualifiedName[i]);", "-\t\t\tif (type == null) return null;", "-\t\t}", "-\t\tif (type.exists()) return type;\t", "-\t\t", "-\t\treturn null;", "+\tif (type.exists()) return type;", "+\treturn null;", "+}"]}], "num": 59748}