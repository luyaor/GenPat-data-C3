{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4cb905fc9a64168634d6170e8ebe434d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3556bb6f15d501327d1ba481e0ce65a7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 105, "methodNumberAfterChange": 88, "signatureBeforeChange": " \tprivate void savePreferences(Preferences preferences)", "signatureAfterChange": " \t private void updatePreferences(IEclipsePreferences preferences)", "diff": ["+\t */", "+\t private void updatePreferences(IEclipsePreferences preferences) {", "+\t \t", "+\t \tPreferences oldPreferences = loadPreferences();", "+\t \tIPreferencesService service = Platform.getPreferencesService();", "+\t \tif (oldPreferences != null) {", "+\t \t\tString[] propertyNames = oldPreferences.propertyNames();", "+\t\t\tfor (int i = 0; i < propertyNames.length; i++){", "+\t\t\t\tString propertyName = propertyNames[i];", "+\t\t\t    String propertyValue = oldPreferences.getString(propertyName);", "+\t\t\t\tString defaultValue = service.get(propertyName, null, JavaCore.preferencesLookup);", "+\t\t\t    if (!\"\".equals(propertyValue) && (defaultValue == null || !propertyValue.equals(defaultValue))) { //$NON-NLS-1$", "+\t\t\t\t    preferences.put(propertyName, propertyValue);", "+\t\t\t    }", "+\t\t\t}", "+\t\t\ttry {", "+\t\t\t\t// save immediately old preferences", "+\t\t\t\tpreferences.flush();", "+\t\t\t} catch (BackingStoreException e) {", "+\t\t\t\t// fails silently", "+\t\t\t}", "+\t\t}", "+\t }", "-\t */", "-\tprivate void savePreferences(Preferences preferences) {", "-\t\t", "-\t\tif (!JavaProject.hasJavaNature(this.project)) return; // ignore", "-\t\t", "-\t\tif (preferences == null || (!preferences.needsSaving() && preferences.propertyNames().length != 0)) {", "-\t\t\t// nothing to save", "-\t\t\treturn;", "-\t\t}", "-\t", "-\t\t// preferences need to be saved", "-\t\t// the preferences file is located in the plug-in's state area", "-\t\t// at a well-known name (.jprefs)", "-//\t\tFile prefFile = this.project.getLocation().append(PREF_FILENAME).toFile();", "-\t\tFile prefFile = getPluginWorkingLocation().append(PREF_FILENAME).toFile();", "-\t\tif (preferences.propertyNames().length == 0) {", "-\t\t\t// there are no preference settings", "-\t\t\t// rather than write an empty file, just delete any existing file", "-\t\t\tif (prefFile.exists()) {", "-\t\t\t\tprefFile.delete(); // don't worry if delete unsuccessful", "-\t\t\t}", "-\t\t\treturn;", "-\t\t}", "-\t\t", "-\t\t// write file, overwriting an existing one", "-\t\tOutputStream out = null;", "-\t\ttry {", "-\t\t\t// do it as carefully as we know how so that we don't lose/mangle", "-\t\t\t// the setting in times of stress", "-\t\t\tout = new BufferedOutputStream(new FileOutputStream(prefFile));", "-\t\t\tpreferences.store(out, null);", "-\t\t} catch (IOException e) { // problems saving preference store - quietly ignore", "-\t\t} finally {", "-\t\t\tif (out != null) {", "-\t\t\t\ttry {", "-\t\t\t\t\tout.close();", "-\t\t\t\t} catch (IOException e) { // ignore problems with close", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60ccc0d7188ff7b2f1ad7153112a8eb1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java", "commitBeforeChange": "e91a03d6ffd76cb11afae070200dbbbe73ce30b0", "commitAfterChange": "1ea5f94648ece67f779d3f9547f2c42cabdfedc2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tConstant condConstant = this.condition.constant; ", "-\t\tConstant optimizedConstant = this.condition.optimizedBooleanConstant();", "+", "+\t\tConstant cst = this.condition.constant;", "+\t\tboolean isConditionTrue = cst != NotAConstant && cst.booleanValue() == true;", "+\t\tboolean isConditionFalse = cst != NotAConstant && cst.booleanValue() == false;", "+", "+\t\tcst = this.condition.optimizedBooleanConstant();", "+\t\tboolean isConditionOptimizedTrue = cst != NotAConstant && cst.booleanValue() == true;", "+\t\tboolean isConditionOptimizedFalse = cst != NotAConstant && cst.booleanValue() == false;", "-\t\t\tthenFlowInfo =", "-\t\t\t\t(optimizedConstant != NotAConstant && optimizedConstant.booleanValue() == false)", "-\t\t\t\t\t? flowInfo.initsWhenTrue().copy().markAsFakeReachable(true)", "-\t\t\t\t\t: flowInfo.initsWhenTrue().copy();", "+\t\t\tthenFlowInfo = flowInfo.initsWhenTrue().copy();", "+\t\t\tif (isConditionOptimizedFalse) thenFlowInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);", "+", "-\t\tthis.thenExit = (thenFlowInfo == FlowInfo.DeadEnd) || thenFlowInfo.isFakeReachable();", "+\t\tthis.thenExit = !thenFlowInfo.isReachable();", "-\t\t\telseFlowInfo =", "-\t\t\t\t(optimizedConstant != NotAConstant && optimizedConstant.booleanValue() == true)", "-\t\t\t\t\t? flowInfo.initsWhenFalse().copy().markAsFakeReachable(true)", "-\t\t\t\t\t: flowInfo.initsWhenFalse().copy();", "+\t\t\telseFlowInfo = flowInfo.initsWhenFalse().copy();", "+\t\t\tif (isConditionOptimizedTrue) elseFlowInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);", "+", "+\t\tboolean elseExit = !elseFlowInfo.isReachable();", "+\t\t", "-\t\tif (condConstant != NotAConstant && condConstant.booleanValue() == true) {", "-\t\t\t// IF (TRUE)", "-\t\t\tif (this.thenExit) {", "-\t\t\t\tmergedInfo = elseFlowInfo.markAsFakeReachable(true);", "-\t\t\t\tmergedInitStateIndex =", "-\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\t\t\treturn mergedInfo;", "-\t\t\t} else {", "-\t\t\t\tmergedInitStateIndex =", "-\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(thenFlowInfo);", "-\t\t\t\treturn thenFlowInfo;", "-\t\t\t}", "+\t\tif (isConditionTrue){", "+\t\t\tmergedInfo = this.thenExit ? elseFlowInfo : thenFlowInfo;", "+\t\t} else if (isConditionFalse) {", "+\t\t\tmergedInfo = elseExit ? thenFlowInfo : elseFlowInfo;", "-\t\t\t// IF (FALSE)", "-\t\t\tif (condConstant != NotAConstant && condConstant.booleanValue() == false) {", "-\t\t\t\tif (elseFlowInfo == FlowInfo.DeadEnd || elseFlowInfo.isFakeReachable()) {", "-\t\t\t\t\tmergedInfo = thenFlowInfo.markAsFakeReachable(true);", "-\t\t\t\t\tmergedInitStateIndex =", "-\t\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\t\t\t\treturn mergedInfo;", "-\t\t\t\t} else {", "-\t\t\t\t\tmergedInitStateIndex =", "-\t\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(elseFlowInfo);", "-\t\t\t\t\treturn elseFlowInfo;", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tmergedInfo = thenFlowInfo.mergedWith(elseFlowInfo.unconditionalInits());", "-\t\tmergedInfo = thenFlowInfo.mergedWith(elseFlowInfo.unconditionalInits());", "+\t\tif ((isConditionOptimizedTrue && this.thenExit)", "+\t\t\t\t|| (isConditionOptimizedFalse && elseExit)) {", "+\t\t\tmergedInfo.setReachMode(FlowInfo.FAKE_REACHABLE);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "80bac6431b329ed4d5867e3a28104ecb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FileSystemUtil.java", "commitBeforeChange": "b4f6df5ae08d61af8762ee59e5c247a670be227d", "commitAfterChange": "7007043cae1b12e48764a4ad7f71075181f1dd30", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic static void deleteFolder(final IFolder folder)", "signatureAfterChange": " \tpublic static boolean deleteDerivedResources(final IResource resource) \t\tthrows CoreException", "diff": ["-\tpublic static void deleteFolder(final IFolder folder) {", "-\t\tif( folder != null ){", "-\t\t\tfinal IWorkspaceRunnable runnable = new IWorkspaceRunnable(){", "-\t            public void run(IProgressMonitor monitor)", "-\t            {\t\t", "-\t            \tif( folder != null ){", "-\t\t            \ttry{", "-\t\t            \t\tfolder.delete(true, false, null);", "-\t\t            \t}catch(CoreException e){", "-\t\t            \t\tAptPlugin.log(e, \"failed to delete old generated source folder \" + folder.getName() ); //$NON-NLS-1$", "-\t\t            \t}catch(OperationCanceledException cancel){", "-\t\t            \t\tAptPlugin.log(cancel, \"deletion of generated source folder got cancelled\"); //$NON-NLS-1$", "-\t\t            \t}", "-\t            \t}", "-\t            }", "-\t        };", "-\t        IWorkspace ws = ResourcesPlugin.getWorkspace();", "-\t        try{", "-\t        \tws.run(runnable, ws.getRoot(), IWorkspace.AVOID_UPDATE, null);", "-\t        }catch(CoreException e){", "-\t    \t\tAptPlugin.log(e, \"Runnable for deleting old generated source folder \" + folder.getName() + \" failed.\"); //$NON-NLS-1$ //$NON-NLS-2$", "-\t    \t}", "+\tpublic static boolean deleteDerivedResources(final IResource resource)", "+\t\tthrows CoreException", "+\t{", "+\t\tif (null == resource) {", "+\t\t\treturn false;", "+\t\tif( resource.getType() == IResource.FOLDER ){", "+\t\t\tboolean deleteFolder = resource.isDerived();", "+\t\t\tIResource[] members = ((IFolder)resource).members();", "+\t\t\tfor( int i=0, len=members.length; i<len; i++ ){\t", "+\t\t\t\tdeleteFolder &= deleteDerivedResources(members[i]);", "+\t\t\t}", "+\t\t\tif( deleteFolder ){", "+\t\t\t\tresource.delete(true, null);", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\treturn false; ", "+\t\t}", "+\t\telse if( resource.getType() == IResource.FILE ){", "+\t\t\tif( resource.isDerived() ){", "+\t\t\t\tresource.delete(true, null);", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\treturn false;", "+\t\t}", "+\t\t// will skip pass everything else.", "+\t\telse", "+\t\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bc32630eb8ea987c7a9a99a5f12ceaa3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tprivate void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "signatureAfterChange": " protected void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "diff": ["-\tprivate void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException {", "-\t\t", "-\t\t// copy array because elements  from the original are removed below", "-\t\tPotentialMatch[] copy = new PotentialMatch[length];", "-\t\tSystem.arraycopy(potentialMatches, start, copy, 0, length);", "-\t\tthis.initialize(javaProject, copy);", "-\t\t", "-\t\tthis.compilationAborted = false;", "-\t\t", "-\t\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "-\t\ttry {", "-\t\t\tthis.createAndResolveBindings(potentialMatches, start, length);", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.compilationAborted = true;", "-\t\t}", "-\t\t", "-\t\t// create hierarchy resolver if needed", "-\t\ttry {", "-\t\t\tif (!this.compilationAborted && !this.createHierarchyResolver(copy)) {", "-\t\t\t\t// focus type is not visible, use the super type names instead of the bindings", "-\t\t\t\tcomputeSuperTypeNames();", "-\t\t\t\tif (this.allSuperTypeNames == null) return;", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.compilationAborted = true;", "-\t\t", "-\t\t// free memory", "-\t\tcopy = null;", "-\t\tpotentialMatches = null;", "-\t\t", "-\t\t// potential match resolution", "-\t\ttry {", "-\t\t\tCompilationUnitDeclaration unit = null;", "-\t\t\tfor (int i = 0; i < this.totalUnits; i++) {", "-\t\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) {", "-\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t\t}", "-\t\t\t\tunit = this.unitsToProcess[i];", "-\t\t\t\ttry {", "-\t\t\t\t\tprocess(unit, i);", "-\t\t\t\t} catch (AbortCompilation e) {", "-\t\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\t\tthis.compilationAborted = true;", "-\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\tif (e instanceof JavaModelException) {", "-\t\t\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\t\t\tthis.compilationAborted = true;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// core exception thrown by client's code: let it through", "-\t\t\t\t\t\tthrow new JavaModelException(e);", "-\t\t\t\t} finally {", "-\t\t\t\t\t// cleanup compilation unit result", "-\t\t\t\t\tunit.cleanUp();", "-\t\t\t\t\tif (this.options.verbose)", "-\t\t\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "+}", "+protected void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException {", "+\tinitialize(javaProject, length);", "+", "+\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "+\tboolean bindingsWereCreated = true;", "+\ttry {", "+\t\tfor (int i = start, maxUnits = start + length; i < maxUnits; i++)", "+\t\t\tbuildBindings(potentialMatches[i]);", "+\t\tlookupEnvironment.completeTypeBindings();", "+", "+\t\t// create hierarchy resolver if needed", "+\t\tIType focusType = getFocusType();", "+\t\tif (focusType == null) {", "+\t\t\tthis.hierarchyResolver = null;", "+\t\t} else if (!createHierarchyResolver(focusType, potentialMatches)) {", "+\t\t\t// focus type is not visible, use the super type names instead of the bindings", "+\t\t\tif (computeSuperTypeNames(focusType) == null) return;", "+\t\t}", "+\t} catch (AbortCompilation e) {", "+\t\tbindingsWereCreated = false;", "+\t}", "+", "+\t// potential match resolution", "+\tfor (int i = 0; i < this.numberOfMatches; i++) {", "+\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "+\t\t\tthrow new OperationCanceledException();", "+\t\tPotentialMatch potentialMatch = this.matchesToProcess[i];", "+\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "+\t\ttry {", "+\t\t\tprocess(potentialMatch, bindingsWereCreated);", "+\t\t} catch (AbortCompilation e) {", "+\t\t\t// problem with class path: it could not find base classes", "+\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\tbindingsWereCreated = false;", "+\t\t} catch (JavaModelException e) {", "+\t\t\t// problem with class path: it could not find base classes", "+\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\tbindingsWereCreated = false;", "+\t\t} catch (CoreException e) {", "+\t\t\t// core exception thrown by client's code: let it through", "+\t\t\tthrow new JavaModelException(e);", "+\t\t} finally {", "+\t\t\tif (this.options.verbose)", "+\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "-\t\t\t\t\t\tString.valueOf(totalUnits),", "-\t\t\t\t\t\tnew String(unitsToProcess[i].getFileName())}));", "-\t\t\t\t}", "-\t\t\t\tthis.unitsToProcess[i] = null; // release reference to processed unit declaration", "-\t\t\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "-\t\t\t\tif (this.progressMonitor != null) {", "-\t\t\t\t\tthis.progressMonitor.worked(5);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.compilationAborted = true;", "-\t\t}\t\t", "-\t}", "+\t\t\t\t\t\tString.valueOf(numberOfMatches),", "+\t\t\t\t\t\tnew String(potentialMatch.parsedUnit.getFileName())}));", "+\t\t\t// cleanup compilation unit result", "+\t\t\tpotentialMatch.parsedUnit.cleanUp();", "+\t\t\tpotentialMatch.parsedUnit = null;", "+\t\tif (this.progressMonitor != null)", "+\t\t\tthis.progressMonitor.worked(5);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0a14791d114087d7c0b560bfd3b64ac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java", "commitBeforeChange": "f8f573fb4945f47fa2e1f634d0b55fa9e0151f17", "commitAfterChange": "b1e2ed2bb1403d1f729ccda27eb7b9ebe7009bed", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic final TextEdit rewriteImports(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic final TextEdit rewriteImports(IProgressMonitor monitor) throws CoreException", "diff": ["+\t\t\tImportRewriteConfiguration config= buildImportRewriteConfiguration();", "+", "-\t\t\t\tnew ImportRewriteAnalyzer(", "-\t\t\t\t\t\tthis.compilationUnit,", "-\t\t\t\t\t\tusedAstRoot,", "-\t\t\t\t\t\tthis.importOrder,", "-\t\t\t\t\t\tthis.importOnDemandThreshold,", "-\t\t\t\t\t\tthis.staticImportOnDemandThreshold,", "-\t\t\t\t\t\tthis.restoreExistingImports,", "-\t\t\t\t\t\tthis.useContextToFilterImplicitImports);", "-\t\t\tcomputer.setFilterImplicitImports(this.filterImplicitImports);", "+\t\t\t\tnew ImportRewriteAnalyzer(this.compilationUnit, usedAstRoot, config);", "-\t\t\tif (this.addedImports != null) {", "-\t\t\t\tfor (int i= 0; i < this.addedImports.size(); i++) {", "-\t\t\t\t\tString curr= (String) this.addedImports.get(i);", "-\t\t\t\t\tcomputer.addImport(curr.substring(1), STATIC_PREFIX == curr.charAt(0), usedAstRoot, this.restoreExistingImports);", "-\t\t\t\t}", "+\t\t\tfor (String addedImport : this.addedImports) {", "+\t\t\t\tboolean isStatic = STATIC_PREFIX == addedImport.charAt(0);", "+\t\t\t\tString qualifiedName = addedImport.substring(1);", "+\t\t\t\tcomputer.addImport(isStatic, qualifiedName);", "-\t\t\tif (this.removedImports != null) {", "-\t\t\t\tfor (int i= 0; i < this.removedImports.size(); i++) {", "-\t\t\t\t\tString curr= (String) this.removedImports.get(i);", "-\t\t\t\t\tcomputer.removeImport(curr.substring(1), STATIC_PREFIX == curr.charAt(0));", "-\t\t\t\t}", "+\t\t\tfor (String removedImport : this.removedImports) {", "+\t\t\t\tboolean isStatic = STATIC_PREFIX == removedImport.charAt(0);", "+\t\t\t\tString qualifiedName = removedImport.substring(1);", "+\t\t\t\tcomputer.removeImport(isStatic, qualifiedName);", "-\t\t\tTextEdit result= computer.getResultingEdits(new SubProgressMonitor(monitor, 1));", "-\t\t\tthis.createdImports= computer.getCreatedImports();", "-\t\t\tthis.createdStaticImports= computer.getCreatedStaticImports();", "-\t\t\treturn result;", "+\t\t\tfor (String typeExplicitSimpleName : this.typeExplicitSimpleNames) {", "+\t\t\t\tcomputer.requireExplicitImport(false, typeExplicitSimpleName);", "+\t\t\t}", "+", "+\t\t\tfor (String staticExplicitSimpleName : this.staticExplicitSimpleNames) {", "+\t\t\t\tcomputer.requireExplicitImport(true, staticExplicitSimpleName);", "+\t\t\t}", "+", "+\t\t\tImportRewriteAnalyzer.RewriteResult result= computer.analyzeRewrite(new SubProgressMonitor(monitor, 1));", "+", "+\t\t\tthis.createdImports= result.getCreatedImports();", "+\t\t\tthis.createdStaticImports= result.getCreatedStaticImports();", "+", "+\t\t\treturn result.getTextEdit();", "+\t}"]}], "num": 42394}