{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d7fa74bae055a3c834b5895584d3384a", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "28c3771230d15dfb2ee003dfd6926ad2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java", "commitBeforeChange": "7dce3ced6f2c34a63721a3fda038e2fad50139b7", "commitAfterChange": "4a258c24dea43b906f3daa4041c94e7315633dfe", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 13, "signatureBeforeChange": " private void indexClassFile(byte[] contents, char[] documentName)", "signatureAfterChange": " \tpublic void indexDocument()", "diff": ["-}", "-private void indexClassFile(byte[] contents, char[] documentName) /* throws IOException */ {", "-\ttry {", "-\t\tClassFileReader reader = new ClassFileReader(contents, documentName);", "-", "-\t\t// first add type references", "-\t\tchar[] className = replace('/', '.', reader.getName()); // looks like java/lang/String", "-\t\t// need to extract the package name and the simple name", "-\t\tint packageNameIndex = CharOperation.lastIndexOf('.', className);", "-\t\tchar[] packageName = null;", "-\t\tchar[] name = null;", "-\t\tif (packageNameIndex >= 0) {", "-\t\t\tpackageName = CharOperation.subarray(className, 0, packageNameIndex);", "-\t\t\tname = CharOperation.subarray(className, packageNameIndex + 1, className.length);", "-\t\t} else {", "-\t\t\tname = className;", "-\t\t}", "-\t\tchar[] enclosingTypeName = null;", "-\t\tif (reader.isNestedType()) {", "-\t\t\tif (reader.isAnonymous()) {", "-\t\t\t\tname = CharOperation.NO_CHAR;", "-\t\t\t} else {", "-\t\t\t\tname = reader.getInnerSourceName();", "-\t\t\tif (reader.isLocal() || reader.isAnonymous()) {", "-\t\t\t\tenclosingTypeName = ONE_ZERO;", "-\t\t\t} else {", "-\t\t\t\tchar[] fullEnclosingName = reader.getEnclosingTypeName();", "-\t\t\t\tint nameLength = fullEnclosingName.length - packageNameIndex - 1;", "-\t\t\t\tif (nameLength <= 0) {", "-\t\t\t\t\t// See PR 1GIR345: ITPJCORE:ALL - Indexer: NegativeArraySizeException", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t\tenclosingTypeName = new char[nameLength]; ", "-\t\t\t\tSystem.arraycopy(fullEnclosingName, packageNameIndex + 1, enclosingTypeName, 0, nameLength);", "-\t\t// eliminate invalid innerclasses (1G4KCF7)", "-\t\tif (name == null) return;", "-\t\t", "-\t\tchar[][] superinterfaces = replace('/', '.', reader.getInterfaceNames());", "-\t\tchar[][] enclosingTypeNames = enclosingTypeName == null ? null : new char[][] {enclosingTypeName};", "-\t\tif (reader.isInterface()) {", "-\t\t\taddInterfaceDeclaration(reader.getModifiers(), packageName, name, enclosingTypeNames, superinterfaces);", "-\t\t} else {", "-\t\t\tchar[] superclass = replace('/', '.', reader.getSuperclassName());", "-\t\t\taddClassDeclaration(reader.getModifiers(), packageName, name, enclosingTypeNames, superclass, superinterfaces);", "-", "-\t\t// first reference all methods declarations and field declarations", "-\t\tMethodInfo[] methods = (MethodInfo[]) reader.getMethods();", "-\t\tif (methods != null) {", "-\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "-\t\t\t\tMethodInfo method = methods[i];", "-\t\t\t\tchar[] descriptor = method.getMethodDescriptor();", "-\t\t\t\tchar[][] parameterTypes = decodeParameterTypes(descriptor);", "-\t\t\t\tchar[] returnType = decodeReturnType(descriptor);", "-\t\t\t\tchar[][] exceptionTypes = replace('/', '.', method.getExceptionTypeNames());", "-\t\t\t\tif (method.isConstructor()) {", "-\t\t\t\t\taddConstructorDeclaration(className, parameterTypes, exceptionTypes);", "+\t}", "+\tpublic void indexDocument() {", "+\t\ttry {", "+\t\t\tbyte[] contents = this.document.getByteContents();", "+\t\t\tClassFileReader reader = new ClassFileReader(contents, this.document.getPath().toCharArray());", "+\t", "+\t\t\t// first add type references", "+\t\t\tchar[] className = replace('/', '.', reader.getName()); // looks like java/lang/String", "+\t\t\t// need to extract the package name and the simple name", "+\t\t\tint packageNameIndex = CharOperation.lastIndexOf('.', className);", "+\t\t\tchar[] packageName = null;", "+\t\t\tchar[] name = null;", "+\t\t\tif (packageNameIndex >= 0) {", "+\t\t\t\tpackageName = CharOperation.subarray(className, 0, packageNameIndex);", "+\t\t\t\tname = CharOperation.subarray(className, packageNameIndex + 1, className.length);", "+\t\t\t} else {", "+\t\t\t\tpackageName = CharOperation.NO_CHAR;", "+\t\t\t\tname = className;", "+\t\t\t}", "+\t\t\tchar[] enclosingTypeName = null;", "+\t\t\tif (reader.isNestedType()) {", "+\t\t\t\tif (reader.isAnonymous()) {", "+\t\t\t\t\tname = CharOperation.NO_CHAR;", "-\t\t\t\t\tif (!method.isClinit()) {", "-\t\t\t\t\t\taddMethodDeclaration(method.getSelector(), parameterTypes, returnType, exceptionTypes);", "+\t\t\t\t\tname = reader.getInnerSourceName();", "+\t\t\t\t}", "+\t\t\t\tif (reader.isLocal() || reader.isAnonymous()) {", "+\t\t\t\t\tenclosingTypeName = ONE_ZERO;", "+\t\t\t\t} else {", "+\t\t\t\t\tchar[] fullEnclosingName = reader.getEnclosingTypeName();", "+\t\t\t\t\tint nameLength = fullEnclosingName.length - packageNameIndex - 1;", "+\t\t\t\t\tif (nameLength <= 0) {", "+\t\t\t\t\t\t// See PR 1GIR345: ITPJCORE:ALL - Indexer: NegativeArraySizeException", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tenclosingTypeName = new char[nameLength]; ", "+\t\t\t\t\tSystem.arraycopy(fullEnclosingName, packageNameIndex + 1, enclosingTypeName, 0, nameLength);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// eliminate invalid innerclasses (1G4KCF7)", "+\t\t\tif (name == null) return;", "+\t\t\t", "+\t\t\tchar[][] superinterfaces = replace('/', '.', reader.getInterfaceNames());", "+\t\t\tchar[][] enclosingTypeNames = enclosingTypeName == null ? null : new char[][] {enclosingTypeName};", "+\t\t\tif (reader.isInterface()) {", "+\t\t\t\taddInterfaceDeclaration(reader.getModifiers(), packageName, name, enclosingTypeNames, superinterfaces);", "+\t\t\t} else {", "+\t\t\t\tchar[] superclass = replace('/', '.', reader.getSuperclassName());", "+\t\t\t\taddClassDeclaration(reader.getModifiers(), packageName, name, enclosingTypeNames, superclass, superinterfaces);", "+\t\t\t}", "+\t", "+\t\t\t// first reference all methods declarations and field declarations", "+\t\t\tMethodInfo[] methods = (MethodInfo[]) reader.getMethods();", "+\t\t\tif (methods != null) {", "+\t\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "+\t\t\t\t\tMethodInfo method = methods[i];", "+\t\t\t\t\tchar[] descriptor = method.getMethodDescriptor();", "+\t\t\t\t\tchar[][] parameterTypes = decodeParameterTypes(descriptor);", "+\t\t\t\t\tchar[] returnType = decodeReturnType(descriptor);", "+\t\t\t\t\tchar[][] exceptionTypes = replace('/', '.', method.getExceptionTypeNames());", "+\t\t\t\t\tif (method.isConstructor()) {", "+\t\t\t\t\t\taddConstructorDeclaration(className, parameterTypes, exceptionTypes);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (!method.isClinit()) {", "+\t\t\t\t\t\t\taddMethodDeclaration(method.getSelector(), parameterTypes, returnType, exceptionTypes);", "+\t\t\t\t\t\t}", "+\t\t\tFieldInfo[] fields = (FieldInfo[]) reader.getFields();", "+\t\t\tif (fields != null) {", "+\t\t\t\tfor (int i = 0, max = fields.length; i < max; i++) {", "+\t\t\t\t\tFieldInfo field = fields[i];", "+\t\t\t\t\tchar[] fieldName = field.getName();", "+\t\t\t\t\tchar[] fieldType = decodeFieldType(replace('/', '.', field.getTypeName()));", "+\t\t\t\t\taddFieldDeclaration(fieldType, fieldName);", "+\t\t\t\t}", "+\t\t\t}", "+\t", "+\t\t\t// record all references found inside the .class file", "+\t\t\textractReferenceFromConstantPool(contents, reader);", "+\t\t} catch (ClassFormatException e) {", "+\t\t\t// ignore", "-\t\tFieldInfo[] fields = (FieldInfo[]) reader.getFields();", "-\t\tif (fields != null) {", "-\t\t\tfor (int i = 0, max = fields.length; i < max; i++) {", "-\t\t\t\tFieldInfo field = fields[i];", "-\t\t\t\tchar[] fieldName = field.getName();", "-\t\t\t\tchar[] fieldType = decodeFieldType(replace('/', '.', field.getTypeName()));", "-\t\t\t\taddFieldDeclaration(fieldType, fieldName);", "+\t}", "-", "-\t\t// record all references found inside the .class file", "-\t\tif (needReferences) {", "-\t\t\textractReferenceFromConstantPool(contents, reader);", "-\t\t}", "-\t} catch (ClassFormatException e) {", "-\t\t// ignore", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7ab07bc2263d4f6f41c1fe317e37395f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "dfc3b8264596f4754baac29eef1af815f182c4f3", "commitAfterChange": "db0143bfca2398448195a62173050bd24d4fcb31", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \r private void findMethods(\r \tchar[] methodName,\r \tTypeBinding[] argTypes,\r \tMethodBinding[] methods,\r \tScope scope,\r \tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \tboolean exactMatch)", "signatureAfterChange": "\r \r \tprivate void findMethods(\r \t\tchar[] methodName,\r \t\tTypeBinding[] argTypes,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType,\r \t\tInvocationSite invocationSite)", "diff": ["-\r", "-private void findMethods(\r", "-\tchar[] methodName,\r", "-\tTypeBinding[] argTypes,\r", "-\tMethodBinding[] methods,\r", "-\tScope scope,\r", "-\tObjectVector methodsFound,\r", "-//\tboolean noVoidReturnType, how do you know?\r", "-\tboolean onlyStaticMethods,\r", "-\tboolean exactMatch) {\r", "-\r", "-\t// Inherited methods which are hidden by subclasses are filtered out\r", "-\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\tint methodLength = methodName.length;\r", "-\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\tMethodBinding method = methods[f];\r", "-\t\tif (method.isConstructor()) continue next;\r", "-//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "-\t\tif (onlyStaticMethods && !method.isStatic()) continue next;\r", "-\t\tif (exactMatch) {\r", "-\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) continue next;\r", "-\t\t} else {\r", "-\t\t\tif (methodLength > method.selector.length) continue next;\r", "-\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false /* ignore case */)) continue next;\r", "-\t\t}\r", "-\t\tif (minArgLength > method.parameters.length) continue next;\r", "-\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a])) continue next;\r", "-\r", "-\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "-\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "-\t\t\tif (method == otherMethod) continue next;\r", "-\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true) && method.areParametersEqual(otherMethod)) {\r", "-\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass)) continue next;\r", "-\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "-\t\t\t\t\tif (method.declaringClass.implementsInterface(otherMethod.declaringClass, true)) continue next;\r", "-\t\t}\r", "-\t\tmethodsFound.add(method);\r", "-\t\tint length = method.parameters.length;\r", "-\t\tchar[][] parameterPackageNames = new char[length][];\r", "-\t\tchar[][] parameterTypeNames = new char[length][];\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tTypeBinding type = method.parameters[i];\r", "-\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\tif (!exactMatch) {\r", "-\t\t\tif (source != null && source.length > endPosition && source[endPosition] == '(')\r", "-\t\t\t\tcompletion = method.selector;\r", "-\t\t\telse\r", "-\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] {'(', ')'});\r", "-\t\t}\r", "-\t\trequestor.acceptMethod(\r", "-\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "-\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "-\t\t\tmethod.selector,\r", "-\t\t\tparameterPackageNames,\r", "-\t\t\tparameterTypeNames,\r", "-\t\t\tmethod.returnType.qualifiedPackageName(),\r", "-\t\t\tmethod.returnType.qualifiedSourceName(),\r", "-\t\t\tcompletion,\r", "-\t\t\tmethod.modifiers,\r", "-\t\t\tstartPosition,\r", "-\t\t\tendPosition);\r", "-}\r", "+\tprivate void findMethods(\r", "+\t\tchar[] methodName,\r", "+\t\tTypeBinding[] argTypes,\r", "+\t\tMethodBinding[] methods,\r", "+\t\tScope scope,\r", "+\t\tObjectVector methodsFound,\r", "+\t//\tboolean noVoidReturnType, how do you know?\r", "+\tboolean onlyStaticMethods,\r", "+\t\tboolean exactMatch,\r", "+\t\tTypeBinding receiverType,\r", "+\t\tInvocationSite invocationSite) {\r", "+\t\t// Inherited methods which are hidden by subclasses are filtered out\r", "+\t\t// No visibility checks can be performed without the scope & invocationSite\r", "+\t\tint methodLength = methodName.length;\r", "+\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\tMethodBinding method = methods[f];\r", "+\t\t\tif (method.isConstructor())\r", "+\t\t\t\tcontinue next;\r", "+\t\t\t//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "+\t\t\tif (onlyStaticMethods && !method.isStatic())\r", "+\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tif (options.checkVisibilitySensitive()\r", "+\t\t\t\t&& !method.canBeSeenBy(receiverType, invocationSite, scope))\r", "+\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tif (exactMatch) {\r", "+\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */\r", "+\t\t\t\t\t))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t} else {\r", "+\t\t\t\tif (methodLength > method.selector.length)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false\r", "+\t\t\t\t\t/* ignore case */\r", "+\t\t\t\t\t))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t}\r", "+\t\t\tif (minArgLength > method.parameters.length)\r", "+\t\t\t\tcontinue next;\r", "+\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a]))\r", "+\t\t\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "+\t\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "+\t\t\t\tif (method == otherMethod)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)\r", "+\t\t\t\t\t&& method.areParametersEqual(otherMethod)) {\r", "+\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))\r", "+\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "+\t\t\t\t\t\tif (method\r", "+\t\t\t\t\t\t\t.declaringClass\r", "+\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))\r", "+\t\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\tmethodsFound.add(method);\r", "+\t\t\tint length = method.parameters.length;\r", "+\t\t\tchar[][] parameterPackageNames = new char[length][];\r", "+\t\t\tchar[][] parameterTypeNames = new char[length][];\r", "+\t\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\t\tTypeBinding type = method.parameters[i];\r", "+\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t}\r", "+\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\tif (!exactMatch) {\r", "+\t\t\t\tif (source != null\r", "+\t\t\t\t\t&& source.length > endPosition\r", "+\t\t\t\t\t&& source[endPosition] == '(')\r", "+\t\t\t\t\tcompletion = method.selector;\r", "+\t\t\t\telse\r", "+\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });\r", "+\t\t\t}\r", "+\t\t\trequestor.acceptMethod(\r", "+\t\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "+\t\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "+\t\t\t\tmethod.selector,\r", "+\t\t\t\tparameterPackageNames,\r", "+\t\t\t\tparameterTypeNames,\r", "+\t\t\t\tmethod.returnType.qualifiedPackageName(),\r", "+\t\t\t\tmethod.returnType.qualifiedSourceName(),\r", "+\t\t\t\tcompletion,\r", "+\t\t\t\tmethod.modifiers,\r"]}], "num": 48962}