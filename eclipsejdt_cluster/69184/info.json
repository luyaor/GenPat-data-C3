{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ae9874067fc1c8cf2c33301e1fa57e92", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8ba4003774d2098022935d115d0f9a6c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "d38fc1042ea41405e872886fade2fc483e8bcf01", "commitAfterChange": "8bea847412c36874664a80a329bfe627deff5fa9", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "  \tprotected void findMethodInSuperInterfaces(ReferenceBinding currentType, char[] selector, ObjectVector found)", "signatureAfterChange": "  \tprotected void findMethodInSuperInterfaces(ReferenceBinding currentType, char[] selector, ObjectVector found)", "diff": ["-\t\t\t\tif (currentMethods.length > 0)", "-\t\t\t\t\tfound.addAll(currentMethods);", "+\t\t\t\tif (currentMethods.length > 0) {", "+\t\t\t\t\tint foundSize = found.size;", "+\t\t\t\t\tif (foundSize > 0) {", "+\t\t\t\t\t\t// its possible to walk the same superinterface from different classes in the hierarchy", "+\t\t\t\t\t\tnext : for (int c = 0, l = currentMethods.length; c < l; c++) {", "+\t\t\t\t\t\t\tMethodBinding current = currentMethods[c];", "+\t\t\t\t\t\t\tfor (int f = 0; f < foundSize; f++)", "+\t\t\t\t\t\t\t\tif (current == found.elementAt(f)) continue next;", "+\t\t\t\t\t\t\tfound.add(current);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfound.addAll(currentMethods);", "+\t\t\t\t\t}", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b4710da8ceea932d2571b17441d75150", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "0eda4899fe49711eb207c4c5710f5520d9ea2e2d", "commitAfterChange": "4a8da6910e1c14334403dae0988de171cbd44126", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[] abstractMethods)", "signatureAfterChange": "  void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[] abstractMethods)", "diff": ["+", "+\t// A subclass inheriting this method and putting it up as the implementation to meet its own", "+\t// obligations should qualify as a use.", "+\tif (concreteMethod.isOrEnclosedByPrivateType())", "+\t\tconcreteMethod.original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\tfor (int i = abstractMethods.length; --i >= 0;) {", "+\t\tif (abstractMethods[i].isOrEnclosedByPrivateType())", "+\t\t\tabstractMethods[i].original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t}"]}], "num": 69184}