{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "45055cf15abddcb046364f7dfa29177a", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1e5814f8cfc1c076b392f709a3e9ed86", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "82dc67de142f757f6098e678017a2b32f752c9b7", "commitAfterChange": "5249d37677c0ce4d66ab262efb5c3dd4aa089796", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding method, MethodBinding otherMethod)", "diff": ["-boolean checkInheritedReturnTypes(MethodBinding[] methods, int length) {", "-\t// assumes length > 1", "-\t// its possible in 1.5 that A is compatible with B & C, but B is not compatible with C", "-\t// so find 1 method that is compatible with every other method", "-\t// abstract classes must check every method against each other", "-\t// but if first method is concrete, then only check it against the rest", "-\tmatch : for (int i = 0, l = methods[0].isAbstract() ? length - 1 : 0; i <= l; i++) {", "-\t\tMethodBinding method = methods[i];", "-\t\tnext : for (int j = 0; j < length; j++) {", "-\t\t\tif (i == j) continue;", "-\t\t\tif (!areReturnTypesCompatible(method, methods[j])) {", "-\t\t\t\tif (this.type.isInterface()) {", "-\t\t\t\t\tfor (int m = length; --m >= 0;)", "-\t\t\t\t\t\tif (methods[m].declaringClass.id == TypeIds.T_JavaLangObject)", "-\t\t\t\t\t\t\treturn true; // do not complain since the super interface already got blamed", "-\t\t\t\t} else {", "-\t\t\t\t\tif (method.declaringClass.isClass() || !this.type.implementsInterface(method.declaringClass, false))", "-\t\t\t\t\t\tif (methods[j].declaringClass.isClass() || !this.type.implementsInterface(methods[j].declaringClass, false))", "-\t\t\t\t\t\t\tcontinue next; // do not complain since the superclass already got blamed", "-\t\t\t\t}", "-\t\t\t\t// check to see if this is just a warning, if so report it & skip to next method", "-\t\t\t\tif (isUnsafeReturnTypeOverride(method, methods[j])) {", "-\t\t\t\t\tproblemReporter(method).unsafeReturnTypeOverride(method, methods[j], this.type);", "-\t\t\t\t\tcontinue next;", "-\t\t\t\t}", "-\t\t\t\tcontinue match;", "-\t\t\t}", "-\t\t}", "+boolean checkInheritedReturnTypes(MethodBinding method, MethodBinding otherMethod) {", "+\tif (areReturnTypesCompatible(method, otherMethod)) return true;", "+", "+\tif (!this.type.isInterface())", "+\t\tif (method.declaringClass.isClass() || !this.type.implementsInterface(method.declaringClass, false))", "+\t\t\tif (otherMethod.declaringClass.isClass() || !this.type.implementsInterface(otherMethod.declaringClass, false))", "+\t\t\t\treturn true; // do not complain since the superclass already got blamed", "+", "+\t// check to see if this is just a warning, if so report it & skip to next method", "+\tif (isUnsafeReturnTypeOverride(method, otherMethod)) {", "+\t\tif (!method.declaringClass.implementsInterface(otherMethod.declaringClass, false))", "+\t\t\tproblemReporter(method).unsafeReturnTypeOverride(method, otherMethod, this.type);", "-\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c54bbb217c5111e55ae8df29e66e7c62", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NamedMember.java", "commitBeforeChange": "f6b98e81e084c7fc5756b6873d78549cc1ce9d4c", "commitAfterChange": "334acc099e45b6ce9ec3bc9c1d31c4c1fb234636", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": " \t \tprotected String getFullyQualifiedParameterizedName(String fullyQualifiedName, ITypeParameter[] typeParameters) throws JavaModelException", "signatureAfterChange": " \t \tpublic String getFullyQualifiedName(char enclosingTypeSeparator, boolean showParameters) throws JavaModelException", "diff": ["-\tprotected String getFullyQualifiedParameterizedName(String fullyQualifiedName, ITypeParameter[] typeParameters) throws JavaModelException {", "-\t\tif (typeParameters.length == 0) return fullyQualifiedName;", "-\t\tStringBuffer buffer = new StringBuffer(fullyQualifiedName);", "-\t\tbuffer.append('<');", "-\t\tfor (int i = 0, length = typeParameters.length; i < length; i++) {", "-\t\t\tITypeParameter typeParameter = typeParameters[i];", "-\t\t\tbuffer.append(typeParameter.getElementName());", "-\t\t\tString[] bounds = typeParameter.getBounds();", "-\t\t\tint boundsLength = bounds.length;", "-\t\t\tif (boundsLength > 0) {", "-\t\t\t\tbuffer.append(\" extends \"); //$NON-NLS-1$", "-\t\t\t\tfor (int j = 0; j < boundsLength; j++) {", "-\t\t\t\t\tbuffer.append(bounds[j]);", "-\t\t\t\t\tif (j < boundsLength-1)", "-\t\t\t\t\t\tbuffer.append(\" & \"); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (i < length-1)", "-\t\t\t\tbuffer.append(\", \"); //$NON-NLS-1$", "+\t", "+\tpublic String getFullyQualifiedName(char enclosingTypeSeparator, boolean showParameters) throws JavaModelException {", "+\t\tString packageName = getPackageFragment().getElementName();", "+\t\tif (packageName.equals(IPackageFragment.DEFAULT_PACKAGE_NAME)) {", "+\t\t\treturn getTypeQualifiedName(enclosingTypeSeparator, showParameters);", "-\t\tbuffer.append('>');", "-\t\treturn buffer.toString();", "+\t\treturn packageName + '.' + getTypeQualifiedName(enclosingTypeSeparator, showParameters);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d6484224726b0c9e14bf6927e696f2f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "786bdcb54629de0c38fe45d8c9c539f76fe7da89", "commitAfterChange": "0f2bcb9853eb25fef3d26daa6737dcdc0dcad109", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "diff": ["-\tint[] areIncompatible = null;", "+\t// so find 1 method that is compatible with every other method", "-\tfor (int i = 0, l = methods[0].isAbstract() ? length - 2 : 0; i <= l;) {", "-\t\tMethodBinding method = methods[i++];", "-\t\tnextMethod : for (int j = i; j < length; j++) {", "+\tmatch : for (int i = 0, l = methods[0].isAbstract() ? length - 1 : 0; i <= l; i++) {", "+\t\tMethodBinding method = methods[i];", "+\t\tnext : for (int j = 0; j < length; j++) {", "+\t\t\tif (i == j) continue;", "-\t\t\t\t\t\t\tcontinue nextMethod; // do not complain since the super interface already got blamed", "+\t\t\t\t\t\t\treturn true; // do not complain since the super interface already got blamed", "-\t\t\t\t\tif (method.isAbstract() && method.declaringClass.isClass())", "-\t\t\t\t\t\tif (areReturnTypesCompatible(methods[j], method))", "-\t\t\t\t\t\t\tcontinue nextMethod; // return type of the superclass' inherited method is a supertype of the return type of the interface's method ", "-\t\t\t\t\t\t\tcontinue nextMethod; // do not complain since the superclass already got blamed", "+\t\t\t\t\t\t\tcontinue next; // do not complain since the superclass already got blamed", "-\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\tcontinue next;", "-\t\t\t\tif (areIncompatible == null)", "-\t\t\t\t\tareIncompatible = new int[length];", "-\t\t\t\tareIncompatible[i - 1] = -1;", "-\t\t\t\tareIncompatible[j] = -1;", "+\t\t\t\tcontinue match;", "-\t}", "-\tif (areIncompatible == null)", "-", "-\tint count = 0;", "-\tfor (int i = 0; i < length; i++)", "-\t\tif (areIncompatible[i] == -1) count++;", "-\tif (count == length) {", "-\t\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);", "-\t\treturn false;", "-\tMethodBinding[] methodsToReport = new MethodBinding[count];", "-\tfor (int i = 0, index = 0; i < length; i++)", "-\t\tif (areIncompatible[i] == -1)", "-\t\t\tmethodsToReport[index++] = methods[i];", "-\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methodsToReport, count);", "+", "+\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);"]}], "num": 37073}