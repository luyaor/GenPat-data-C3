{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "533229a5d352c5552bcdaab923d9949e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "44157727474c61cc248b81ce8afafa80", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java", "commitBeforeChange": "fd2f05a21f35cbfcda729da26a9cef6e676227a2", "commitAfterChange": "d82bab5c3bc5a3dc0c32d13db0378bcec919d784", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType, \t\tExpression expression)", "signatureAfterChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType, \t\tExpression expression)", "diff": ["-\t\t//-----------cast to something which is NOT a base type--------------------------\t", "-\t\tif (expressionType == NullBinding) {", "-\t\t\ttagAsUnnecessaryCast(scope, castType);", "-\t\t\treturn true; //null is compatible with every thing", "-\t\t}", "-\t\tif (expressionType.isBaseType()) {", "-\t\t\treturn false;", "-\t\t}", "-\t", "-\t\tif (expressionType.isArrayType()) {", "-\t\t\tif (castType == expressionType) {", "-\t\t\t\ttagAsUnnecessaryCast(scope, castType);", "-\t\t\t\treturn true; // identity conversion", "-\t\t\t}", "-\t", "-\t\t\tif (castType.isArrayType()) {", "-\t\t\t\t//------- (castType.isArray) expressionType.isArray -----------", "-\t\t\t\tTypeBinding castElementType = ((ArrayBinding) castType).elementsType();", "-\t\t\t\tTypeBinding exprElementType = ((ArrayBinding) expressionType).elementsType();", "-\t\t\t\tif (exprElementType.isBaseType() || castElementType.isBaseType()) {", "-\t\t\t\t\t// <---stop the recursion------- ", "-\t\t\t\t\tif (castElementType == exprElementType) {", "-\t\t\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\t\t\treturn true;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t// recursively on the elements...", "-\t\t\t\treturn checkCastTypesCompatibility(scope, ((ArrayBinding) castType).elementsType(), exprElementType, expression);", "-\t\t\t} else if (castType.isTypeVariable()) {", "-\t\t\t\tif (expressionType instanceof ReferenceBinding) {", "-\t\t\t\t\tReferenceBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "-\t\t\t\t\tif (match == null) {", "-\t\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, null, true);", "-\t\t\t\t}", "-\t\t\t\t// recursively on the type variable upper bound", "-\t\t\t\treturn checkCastTypesCompatibility(scope, castType.erasure(), expressionType, expression);", "-\t\t\t} else if (castType.isClass() || castType.isEnum()) {", "-\t\t\t\t//------(castType.isClass) expressionType.isArray ---------------\t", "-\t\t\t\tif (castType.id == T_JavaLangObject) {", "+\t\tswitch(expressionType.kind()) {", "+\t\t\tcase Binding.BASE_TYPE :", "+\t\t\t\t//-----------cast to something which is NOT a base type--------------------------\t", "+\t\t\t\tif (expressionType == NullBinding) {", "-\t\t\t\t\treturn true;", "+\t\t\t\t\treturn true; //null is compatible with every thing", "-\t\t\t} else { //------- (castType.isInterface) expressionType.isArray -----------", "-\t\t\t\tif (castType.id == T_JavaLangCloneable || castType.id == T_JavaIoSerializable) {", "-\t\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn false;", "-\t\t}", "-\t\tif (expressionType.isTypeVariable() || expressionType.isWildcard()) {", "-\t\t\tif (castType instanceof ReferenceBinding) {", "-\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "-\t\t\t\tif (match != null) {", "-\t\t\t\t\ttagAsUnnecessaryCast(scope, castType);", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// recursively on the type variable upper bound", "-\t\t\treturn checkCastTypesCompatibility(scope, castType, expressionType.erasure(), expression);", "-\t\t}", "-\t\t", "-\t\tif (expressionType.isClass() || expressionType.isEnum()) {", "-\t\t\tif (castType.isArrayType()) {", "-\t\t\t\t// ---- (castType.isArray) expressionType.isClass -------", "-\t\t\t\tif (expressionType.id == T_JavaLangObject) { // potential runtime error", "-\t\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t} else if (castType.isTypeVariable()) {", "-\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "-\t\t\t\tif (match == null) {", "-\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "-\t\t\t\t}", "-\t\t\t\t// recursively on the type variable upper bound", "-\t\t\t\treturn checkCastTypesCompatibility(scope, castType.erasure(), expressionType, expression);", "-\t\t\t} else if (castType.isClass() || castType.isEnum()) { // ----- (castType.isClass) expressionType.isClass ------", "-\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "-\t\t\t\tif (match != null) {", "-\t\t\t\t\tif (expression != null && castType.id == T_JavaLangString) this.constant = expression.constant; // (String) cst is still a constant", "-\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, false);", "-\t\t\t\t}", "-\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeErasingTo((ReferenceBinding)expressionType.erasure());", "-\t\t\t\tif (match != null) {", "-\t\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, true);", "-\t\t\t\t}", "-\t\t\t} else { // ----- (castType.isInterface) expressionType.isClass -------  ", "-", "-\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "-\t\t\t\tif (match != null) {", "-\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, false);", "-\t\t\t\t}", "-\t\t\t\t// a subclass may implement the interface ==> no check at compile time", "-\t\t\t\tif (!((ReferenceBinding) expressionType).isFinal()) {", "-\t\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeErasingTo((ReferenceBinding)expressionType.erasure());", "-\t\t\t\t\tif (match != null) {", "-\t\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, true);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t\t// no subclass for expressionType, thus compile-time check is valid", "-\t\t\t}", "-\t\t\treturn false;", "-\t\t}", "-\t", "-\t\t//\tif (expressionType.isInterface()) { cannot be anything else", "-\t\tif (castType.isArrayType()) {", "-\t\t\t// ----- (castType.isArray) expressionType.isInterface ------", "-\t\t\tif (expressionType.id == T_JavaLangCloneable", "-\t\t\t\t\t|| expressionType.id == T_JavaIoSerializable) {// potential runtime error", "-\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\treturn true;", "-\t\t\t} else {", "-\t\t\t}", "-\t\t} else if (castType.isTypeVariable()) {", "-\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "-\t\t\tif (match == null) {", "-\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "-\t\t\t}", "-\t\t\t// recursively on the type variable upper bound", "-\t\t\treturn checkCastTypesCompatibility(scope, castType.erasure(), expressionType, expression);", "-\t\t} else if (castType.isClass() || castType.isEnum()) { // ----- (castType.isClass) expressionType.isInterface --------", "-", "-\t\t\tif (castType.id == T_JavaLangObject) { // no runtime error", "-\t\t\t\ttagAsUnnecessaryCast(scope, castType);", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tif (((ReferenceBinding) castType).isFinal()) {", "-\t\t\t\t// no subclass for castType, thus compile-time check is valid", "-\t\t\t\tTypeBinding match = ((ReferenceBinding)castType).findSuperTypeErasingTo((ReferenceBinding)expressionType.erasure());", "-\t\t\t\tif (match == null) {", "-\t\t\t\t\t// potential runtime error", "-\t\t\t\t\treturn false;", "-\t\t\t\t}\t\t\t\t", "-\t\t\t}", "-\t\t} else { // ----- (castType.isInterface) expressionType.isInterface -------", "-\t\t\t\tReferenceBinding interfaceType = (ReferenceBinding) expressionType;", "-\t\t\t\tTypeBinding match = interfaceType.findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "-\t\t\t\tif (match != null) {", "-\t\t\t\t\treturn checkUnsafeCast(scope, castType, interfaceType, match, false);", "-\t\t\t\t}", "-\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeErasingTo((ReferenceBinding)interfaceType.erasure());", "-\t\t\t\tif (match != null) {", "-\t\t\t\t\treturn checkUnsafeCast(scope, castType, interfaceType, match, true);", "+\t\t\tcase Binding.ARRAY_TYPE :", "+\t\t\t\tif (castType == expressionType) {", "+\t\t\t\t\ttagAsUnnecessaryCast(scope, castType);", "+\t\t\t\t\treturn true; // identity conversion", "-\t\t\t\tif (use15specifics) {", "-\t\t\t\t\t// a subclass may implement the interface ==> no check at compile time", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t\t// pre1.5 semantics - no covariance allowed (even if 1.5 compliant, but 1.4 source)", "-\t\t\t\tMethodBinding[] castTypeMethods = getAllInheritedMethods((ReferenceBinding) castType);", "-\t\t\t\tMethodBinding[] expressionTypeMethods = getAllInheritedMethods((ReferenceBinding) expressionType);", "-\t\t\t\tint exprMethodsLength = expressionTypeMethods.length;", "-\t\t\t\tfor (int i = 0, castMethodsLength = castTypeMethods.length; i < castMethodsLength; i++)", "-\t\t\t\t\tfor (int j = 0; j < exprMethodsLength; j++) {", "-\t\t\t\t\t\tif ((castTypeMethods[i].returnType != expressionTypeMethods[j].returnType)", "-\t\t\t\t\t\t\t\t&& (CharOperation.equals(castTypeMethods[i].selector, expressionTypeMethods[j].selector))", "-\t\t\t\t\t\t\t\t&& castTypeMethods[i].areParametersEqual(expressionTypeMethods[j])) {", "+\t\t\t\tswitch (castType.kind()) {", "+\t\t\t\t\tcase Binding.ARRAY_TYPE : ", "+\t\t\t\t\t\t// ( ARRAY ) ARRAY", "+\t\t\t\t\t\tTypeBinding castElementType = ((ArrayBinding) castType).elementsType();", "+\t\t\t\t\t\tTypeBinding exprElementType = ((ArrayBinding) expressionType).elementsType();", "+\t\t\t\t\t\tif (exprElementType.isBaseType() || castElementType.isBaseType()) {", "+\t\t\t\t\t\t\tif (castElementType == exprElementType) {", "+\t\t\t\t\t\t\t\ttagAsNeedCheckCast();", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t} ", "-", "+\t\t\t\t\t\t// recurse on array type elements", "+\t\t\t\t\t\treturn checkCastTypesCompatibility(scope, ((ArrayBinding) castType).elementsType(), exprElementType, expression);\t\t\t\t\t\t", "+\t\t\t\t\t\t", "+\t\t\t\t\tcase Binding.TYPE_PARAMETER : ", "+\t\t\t\t\t\t// ( TYPE_PARAMETER ) ARRAY", "+\t\t\t\t\t\tif (expressionType instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\tReferenceBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "+\t\t\t\t\t\t\tif (match == null) {", "+\t\t\t\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, null, true);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// recurse on the type variable upper bound", "+\t\t\t\t\t\treturn checkCastTypesCompatibility(scope, castType.erasure(), expressionType, expression);", "+\t\t\t\t\t\t", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\t// ( CLASS/INTERFACE ) ARRAY", "+\t\t\t\t\t\tswitch (castType.id) {", "+\t\t\t\t\t\t\tcase T_JavaLangCloneable :", "+\t\t\t\t\t\t\tcase T_JavaIoSerializable :", "+\t\t\t\t\t\t\t\ttagAsNeedCheckCast();", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\tcase T_JavaLangObject :", "+\t\t\t\t\t\t\t\ttagAsUnnecessaryCast(scope, castType);", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t\t\t", "+\t\t\tcase Binding.TYPE_PARAMETER :", "+\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\tif (castType instanceof ReferenceBinding) {", "+\t\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "+\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\ttagAsUnnecessaryCast(scope, castType);", "+\t\t\t\t\t\treturn true;", "-\t\t\t\treturn true;", "+\t\t\t\t}", "+\t\t\t\t// recursively on the type variable upper bound", "+\t\t\t\treturn checkCastTypesCompatibility(scope, castType, expressionType.erasure(), expression);", "+", "+\t\t\tdefault:", "+\t\t\t\tif (expressionType.isInterface()) {", "+\t\t\t\t\tswitch (castType.kind()) {", "+\t\t\t\t\t\tcase Binding.ARRAY_TYPE :", "+\t\t\t\t\t\t\t// ( ARRAY ) INTERFACE", "+\t\t\t\t\t\t\tswitch (expressionType.id) {", "+\t\t\t\t\t\t\t\tcase T_JavaLangCloneable :", "+\t\t\t\t\t\t\t\tcase T_JavaIoSerializable :", "+\t\t\t\t\t\t\t\t\ttagAsNeedCheckCast();", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\tdefault :\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t}", "+", "+\t\t\t\t\t\tcase Binding.TYPE_PARAMETER :", "+\t\t\t\t\t\t\t// ( INTERFACE ) TYPE_PARAMETER", "+\t\t\t\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "+\t\t\t\t\t\t\tif (match == null) {", "+\t\t\t\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// recurse on the type variable upper bound", "+\t\t\t\t\t\t\treturn checkCastTypesCompatibility(scope, castType.erasure(), expressionType, expression);", "+", "+\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\tif (castType.isInterface()) {", "+\t\t\t\t\t\t\t\t// ( INTERFACE ) INTERFACE", "+\t\t\t\t\t\t\t\tReferenceBinding interfaceType = (ReferenceBinding) expressionType;", "+\t\t\t\t\t\t\t\tmatch = interfaceType.findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "+\t\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\t\treturn checkUnsafeCast(scope, castType, interfaceType, match, false);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\ttagAsNeedCheckCast();", "+\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeErasingTo((ReferenceBinding)interfaceType.erasure());", "+\t\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\t\treturn checkUnsafeCast(scope, castType, interfaceType, match, true);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (!use15specifics) {", "+\t\t\t\t\t\t\t\t\t// pre1.5 semantics - no covariance allowed (even if 1.5 compliant, but 1.4 source)", "+\t\t\t\t\t\t\t\t\tMethodBinding[] castTypeMethods = getAllInheritedMethods((ReferenceBinding) castType);", "+\t\t\t\t\t\t\t\t\tMethodBinding[] expressionTypeMethods = getAllInheritedMethods((ReferenceBinding) expressionType);", "+\t\t\t\t\t\t\t\t\tint exprMethodsLength = expressionTypeMethods.length;", "+\t\t\t\t\t\t\t\t\tfor (int i = 0, castMethodsLength = castTypeMethods.length; i < castMethodsLength; i++) {", "+\t\t\t\t\t\t\t\t\t\tfor (int j = 0; j < exprMethodsLength; j++) {", "+\t\t\t\t\t\t\t\t\t\t\tif ((castTypeMethods[i].returnType != expressionTypeMethods[j].returnType)", "+\t\t\t\t\t\t\t\t\t\t\t\t\t&& (CharOperation.equals(castTypeMethods[i].selector, expressionTypeMethods[j].selector))", "+\t\t\t\t\t\t\t\t\t\t\t\t\t&& castTypeMethods[i].areParametersEqual(expressionTypeMethods[j])) {", "+\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\treturn true;\t\t", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// ( CLASS ) INTERFACE", "+\t\t\t\t\t\t\t\tif (castType.id == T_JavaLangObject) { // no runtime error", "+\t\t\t\t\t\t\t\t\ttagAsUnnecessaryCast(scope, castType);", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (((ReferenceBinding) castType).isFinal()) {", "+\t\t\t\t\t\t\t\t\t// no subclass for castType, thus compile-time check is valid", "+\t\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeErasingTo((ReferenceBinding)expressionType.erasure());", "+\t\t\t\t\t\t\t\t\tif (match == null) {", "+\t\t\t\t\t\t\t\t\t\t// potential runtime error", "+\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t}\t\t\t\t", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\ttagAsNeedCheckCast();", "+\t\t\t\t\treturn true;", "+\t\t\t\t} else {", "+\t\t\t\t\tswitch (castType.kind()) {", "+\t\t\t\t\t\tcase Binding.ARRAY_TYPE :", "+\t\t\t\t\t\t\t// ( ARRAY ) CLASS", "+\t\t\t\t\t\t\tif (expressionType.id == T_JavaLangObject) { // potential runtime error", "+\t\t\t\t\t\t\t\ttagAsNeedCheckCast();", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\tcase Binding.TYPE_PARAMETER :", "+\t\t\t\t\t\t\t// ( TYPE_PARAMETER ) CLASS", "+\t\t\t\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "+\t\t\t\t\t\t\tif (match == null) {", "+\t\t\t\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// recurse on the type variable upper bound", "+\t\t\t\t\t\t\treturn checkCastTypesCompatibility(scope, castType.erasure(), expressionType, expression);", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\tif (castType.isInterface()) {", "+\t\t\t\t\t\t\t\t// ( INTERFACE ) CLASS\t\t", "+\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "+\t\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, false);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t// unless final a subclass may implement the interface ==> no check at compile time", "+\t\t\t\t\t\t\t\tif (((ReferenceBinding) expressionType).isFinal()) {", "+\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\ttagAsNeedCheckCast();", "+\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeErasingTo((ReferenceBinding)expressionType.erasure());", "+\t\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, true);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// ( CLASS ) CLASS", "+\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "+\t\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\t\tif (expression != null && castType.id == T_JavaLangString) this.constant = expression.constant; // (String) cst is still a constant", "+\t\t\t\t\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, false);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeErasingTo((ReferenceBinding)expressionType.erasure());", "+\t\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\t\ttagAsNeedCheckCast();", "+\t\t\t\t\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, true);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\ttagAsNeedCheckCast();", "-\t\treturn true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5ceecaf6120198e8bebd91c52ca0d581", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "59e26d7d44dd6102df4b7a4747425328bf55da24", "commitAfterChange": "74b7e9bbbee0eebec4c9550b37cb671ca5d91239", "methodNumberBeforeChange": 124, "methodNumberAfterChange": 124, "signatureBeforeChange": " \tpublic void resolveClasspath(PerProjectInfo perProjectInfo, boolean usePreviousSession) throws JavaModelException", "signatureAfterChange": " \t \tprivate ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, boolean usePreviousSession) throws JavaModelException", "diff": ["+\t", "+\tprivate ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, boolean usePreviousSession) throws JavaModelException {", "+\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\t\tExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();", "+\t\tResolvedClasspath result = new ResolvedClasspath();", "+", "+\t\tint length = rawClasspath.length;", "+\t\tfor (int i = 0; i < length; i++) {", "+", "+\t\t\tIPath resolvedPath;", "+", "+", "+\t\t\t\tcase IClasspathEntry.CPE_VARIABLE :", "+\t\t\t\t\t\tresolvedEntry = manager.getResolvedClasspathEntry(rawEntry, usePreviousSession);", "+\t\t\t\t\t\t// Catch the assertion failure and set status instead", "+\t\t\t\t\t\tresult.unresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, e.getMessage());", "+\t\t\t\t\tif (resolvedEntry == null) {", "+\t\t\t\t\t\tresult.unresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND, this, rawEntry.getPath());", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (result.rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) {", "+\t\t\t\t\t\t\tresult.rawReverseMap.put(resolvedPath , rawEntry);", "+\t\t\t\t\t\t\tresult.rootPathToResolvedEntries.put(resolvedPath, resolvedEntry);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "+\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+", "+\t\t\t\tcase IClasspathEntry.CPE_CONTAINER :", "+\t\t\t\t\tIClasspathContainer container = usePreviousSession ? manager.getPreviousSessionContainer(rawEntry.getPath(), this) : JavaCore.getClasspathContainer(rawEntry.getPath(), this);", "+\t\t\t\t\tif (container == null){", "+\t\t\t\t\t\tresult.unresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.CP_CONTAINER_PATH_UNBOUND, this, rawEntry.getPath());", "+\t\t\t\t\t}", "+", "+\t\t\t\t\t\tif (result.rawReverseMap.get(resolvedPath = cEntry.getPath()) == null) {", "+\t\t\t\t\t\t\tresult.rawReverseMap.put(resolvedPath , rawEntry);", "+\t\t\t\t\t\t\tresult.rootPathToResolvedEntries.put(resolvedPath, cEntry);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (cEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "+\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "+\t\t\t\t\t\t}", "+", "+\t\t\t\tdefault :", "+\t\t\t\t\tif (result.rawReverseMap.get(resolvedPath = rawEntry.getPath()) == null) {", "+\t\t\t\t\t\tresult.rawReverseMap.put(resolvedPath , rawEntry);", "+\t\t\t\t\t\tresult.rootPathToResolvedEntries.put(resolvedPath, rawEntry);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (rawEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "+\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "+\t\t\t\t\t}", "+", "+\t\tresult.resolvedClasspath = new IClasspathEntry[resolvedEntries.size()];", "+\t\tresolvedEntries.toArray(result.resolvedClasspath);", "-\t\t\tExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();", "-", "-", "-\t\t\tIJavaModelStatus unresolvedEntryStatus = JavaModelStatus.VERIFIED_OK;", "-\t\t\tHashMap rawReverseMap = new HashMap();", "-\t\t\tMap rootPathToResolvedEntries = new HashMap();", "-", "-\t\t\tArrayList resolvedEntries = new ArrayList();", "-\t\t\tint length = rawClasspath.length;", "-\t\t\tfor (int i = 0; i < length; i++) {", "-", "-\t\t\t\tIClasspathEntry rawEntry = rawClasspath[i];", "-\t\t\t\tIPath resolvedPath;", "-", "-\t\t\t\tswitch (rawEntry.getEntryKind()){", "-", "-\t\t\t\t\tcase IClasspathEntry.CPE_VARIABLE :", "-\t\t\t\t\t\tIClasspathEntry resolvedEntry = null;", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tresolvedEntry = manager.getResolvedClasspathEntry(rawEntry, usePreviousSession);", "-\t\t\t\t\t\t} catch (ClasspathEntry.AssertionFailedException e) {", "-\t\t\t\t\t\t\t// Catch the assertion failure and set status instead", "-\t\t\t\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=55992", "-\t\t\t\t\t\t\tunresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, e.getMessage());", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (resolvedEntry == null) {", "-\t\t\t\t\t\t\tunresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND, this, rawEntry.getPath());", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) {", "-\t\t\t\t\t\t\t\trawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t\t\trootPathToResolvedEntries.put(resolvedPath, resolvedEntry);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-", "-\t\t\t\t\tcase IClasspathEntry.CPE_CONTAINER :", "-\t\t\t\t\t\tIClasspathContainer container = usePreviousSession ? manager.getPreviousSessionContainer(rawEntry.getPath(), this) : JavaCore.getClasspathContainer(rawEntry.getPath(), this);", "-\t\t\t\t\t\tif (container == null){", "-\t\t\t\t\t\t\tunresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.CP_CONTAINER_PATH_UNBOUND, this, rawEntry.getPath());", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\tIClasspathEntry[] containerEntries = container.getClasspathEntries();", "-\t\t\t\t\t\tif (containerEntries == null) {", "-\t\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE || JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {", "-\t\t\t\t\t\t\t\tJavaModelManager.getJavaModelManager().verbose_missbehaving_container_null_entries(this, rawEntry.getPath());", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t// container was bound", "-\t\t\t\t\t\tfor (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){", "-\t\t\t\t\t\t\tClasspathEntry cEntry = (ClasspathEntry) containerEntries[j];", "-\t\t\t\t\t\t\tif (cEntry == null) {", "-\t\t\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE || JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {", "-\t\t\t\t\t\t\t\t\tJavaModelManager.getJavaModelManager().verbose_missbehaving_container(this, rawEntry.getPath(), containerEntries);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// if container is exported or restricted, then its nested entries must in turn be exported  (21749) and/or propagate restrictions", "-\t\t\t\t\t\t\tcEntry = cEntry.combineWith((ClasspathEntry) rawEntry);", "-\t\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = cEntry.getPath()) == null) {", "-\t\t\t\t\t\t\t\trawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t\t\trootPathToResolvedEntries.put(resolvedPath, cEntry);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tresolvedEntries.add(cEntry);", "-\t\t\t\t\t\t\tif (cEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-", "-\t\t\t\t\tdefault :", "-\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = rawEntry.getPath()) == null) {", "-\t\t\t\t\t\t\trawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t\trootPathToResolvedEntries.put(resolvedPath, rawEntry);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tresolvedEntries.add(rawEntry);", "-\t\t\t\t\t\tif (rawEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tIClasspathEntry[] resolvedClasspath = new IClasspathEntry[resolvedEntries.size()];", "-\t\t\tresolvedEntries.toArray(resolvedClasspath);", "-\t\t\tperProjectInfo.setResolvedClasspath(resolvedClasspath, rawReverseMap, rootPathToResolvedEntries, usePreviousSession ? PerProjectInfo.NEED_RESOLUTION : unresolvedEntryStatus, timeStamp);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7a562df72cc3a0efb40ba097787c44f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "900392dc83f32684036212f916a5915ba3721662", "commitAfterChange": "adfa6eea97da9a8b8e860dcf2bcb64f1459b7350", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 33, "signatureBeforeChange": "  \tprivate String getBytesAsString(final byte[] bytes, final String lineSeparator, final int tabNumber)", "signatureAfterChange": "  \tprivate String disassemble(IVerificationTypeInfo[] infos, String lineSeparator, int tabNumber, int mode)", "diff": ["+\tprivate String disassemble(IVerificationTypeInfo[] infos, String lineSeparator, int tabNumber, int mode) {", "+\t\tStringBuffer buffer = new StringBuffer();", "+\t\tfor (int i = 0, max = infos.length; i < max; i++) {", "+\t\t\tif(i != 0) buffer.append(',');", "+\t\t\tswitch(infos[i].getTag()) {", "+\t\t\t\tcase IVerificationTypeInfo.ITEM_DOUBLE :", "+\t\t\t\t\tbuffer.append(\"double\"); //$NON-NLS-1$", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IVerificationTypeInfo.ITEM_FLOAT :", "+\t\t\t\t\tbuffer.append(\"float\"); //$NON-NLS-1$", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IVerificationTypeInfo.ITEM_INTEGER :", "+\t\t\t\t\tbuffer.append(\"int\"); //$NON-NLS-1$", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IVerificationTypeInfo.ITEM_LONG :", "+\t\t\t\t\tbuffer.append(\"long\"); //$NON-NLS-1$", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IVerificationTypeInfo.ITEM_NULL :", "+\t\t\t\t\tbuffer.append(\"null\"); //$NON-NLS-1$", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IVerificationTypeInfo.ITEM_OBJECT :", "+\t\t\t\t\tfinal char[] classTypeName = infos[i].getClassTypeName();", "+\t\t\t\t\tCharOperation.replace(classTypeName, '/', '.');", "+\t\t\t\t\tbuffer.append(returnClassName(classTypeName, '.', mode));", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IVerificationTypeInfo.ITEM_TOP :", "+\t\t\t\t\tbuffer.append(\"top\"); //$NON-NLS-1$", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IVerificationTypeInfo.ITEM_UNINITIALIZED :", "+\t\t\t\t\tbuffer.append(\"uninitialized\"); //$NON-NLS-1$", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IVerificationTypeInfo.ITEM_UNINITIALIZED_THIS :", "+\t\t\t\t\tbuffer.append(\"uninitialized_this\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t}", "+\t\treturn String.valueOf(buffer);", "+\t}", "-\tprivate String getBytesAsString(final byte[] bytes, final String lineSeparator, final int tabNumber) {", "-\t\tStringBuffer buffer = new StringBuffer();", "-\t\tNumberFormat format = NumberFormat.getInstance();", "-\t\tformat.setMaximumIntegerDigits(3);", "-\t\tformat.setMinimumIntegerDigits(3);", "-\t\tfinal int length = bytes.length;", "-\t\tif (length == 0) {", "-\t\t\treturn \"{}\"; //$NON-NLS-1$", "-\t\t} else {", "-\t\t\tbuffer.append('{');", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "-\t\t\tString hexString = Integer.toHexString(bytes[0] & 0xFF);", "-\t\t\tswitch(hexString.length()) {", "-\t\t\t\tcase 1 :", "-\t\t\t\t\tbuffer.append('0');", "-\t\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tbuffer.append(hexString).append(' ');", "-\t\t\thexString = Integer.toHexString(bytes[1] & 0xFF);", "-\t\t\tswitch(hexString.length()) {", "-\t\t\t\tcase 1 :", "-\t\t\t\t\tbuffer.append('0');", "-\t\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tbuffer.append(hexString);", "-\t\t\tfor (int i = 2; i < length; i++) {", "-\t\t\t\tif ((i - 2) % 11 == 0) {", "-\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "-\t\t\t\t} else {", "-\t\t\t\t\tbuffer.append(' ');", "-\t\t\t\t}", "-\t\t\t\tfinal int currentByte = bytes[i] & 0xFF;", "-\t\t\t\thexString = Integer.toHexString(currentByte).toUpperCase();", "-\t\t\t\tswitch(hexString.length()) {", "-\t\t\t\t\tcase 1 :", "-\t\t\t\t\t\tbuffer.append('0');", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\tbuffer.append(hexString).append('(').append(format.format(currentByte)).append(')');", "-\t\t\t}", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 1);", "-\t\t\tbuffer.append('}');", "-\t\t}", "-\t\treturn String.valueOf(buffer);", "-\t}"]}], "num": 24150}