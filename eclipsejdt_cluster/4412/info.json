{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "54d760b627e875b40540db557697c39d", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "27d301a62b2af705aa94fc5961f22ee6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "21b06b1f77b7fda7b2358e6e2d335e77a6ac8125", "commitAfterChange": "b397fbf1ef2684ee73e7617091ec4c7be38fc011", "methodNumberBeforeChange": 44, "methodNumberAfterChange": 47, "signatureBeforeChange": " \tpublic void setGeneratedSourceFolderName( String s )", "signatureAfterChange": " \tprivate void setGenratedSourceFolderName(String newName)", "diff": ["+\t */", "+\tprivate void setGenratedSourceFolderName(String newName){", "+\t\tassert !AptConfig.isEnabled(_aptProject.getJavaProject()) :", "+\t\t\t \"APT is enabled for \" + _aptProject.getJavaProject().getElementName(); //$NON-NLS-1$", "+\t\tif( newName == null || newName.length() == 0 )", "+\t\t\tthrow new IllegalStateException(\"[\" + newName + \"] not a valid name for generated source folder \");  //$NON-NLS-1$//$NON-NLS-2$", "+\t\tsynchronized (this) {", "+\t\t\t_generatedSourceFolderName = newName;", "+\t\t}", "+\t}", "-\tpublic void setGeneratedSourceFolderName( String s ) ", "-\t\tif ( s == null || s.length() == 0 || s.equals( getGeneratedSourceFolderName() ) )", "-\t\tfinal IFolder srcFolder;", "-\t\t\t_generatedSourceFolderName = s;", "-\t\t\t// save _generatedSrcFolder off to avoid race conditions"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "adbe0da1c188930031c4cc6a82a87c8f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeReferenceLocator.java", "commitBeforeChange": "9ee78f50bb7fb9d70095ea7ff2d9f2e27d840c37", "commitAfterChange": "b6410432af18704990f18fa69a09dd7a76e8fb04", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " protected void matchReportImportRef(ImportReference importRef, Binding binding, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": " protected void matchReportImportRef(ImportReference importRef, Binding binding, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "diff": ["+\t", "+\t// Create search match", "+\tmatch = locator.newTypeReferenceMatch(element, accuracy, importRef);", "-\t// set match rule", "-\tint rule = SearchMatch.A_ACCURATE;", "-\tif (this.pattern.hasTypeArguments()) { // binding has no type params, compatible erasure if pattern does", "-\t\trule = SearchPattern.R_EQUIVALENT_MATCH | SearchPattern.R_ERASURE_MATCH;", "+\t// set match raw flag and rule", "+\tmatch.setRaw(true);", "+\tif (this.pattern.hasTypeArguments()) {", "+\t\t// binding is raw => only compatible erasure if pattern has type arguments", "+\t\tmatch.setRule(match.getRule() & (~SearchPattern.R_FULL_MATCH));", "-\t\t\t\t\tSearchMatch match = locator.newTypeReferenceMatch(element, accuracy, start, end-start+1, rule, importRef);", "+\t\t\t\t\tmatch.setOffset(start);", "+\t\t\t\t\tmatch.setLength(end-start+1);", "-\tlocator.reportAccurateTypeReference(importRef, this.pattern.simpleName, element, accuracy, rule);", "+\tlocator.reportAccurateTypeReference(match, importRef, this.pattern.simpleName);"]}], "num": 4412}