{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b98898838651bdb90f4c2b1340126223", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c87194100544f10079072edb42da5da", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 13, "signatureBeforeChange": " public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType, Scope scope)", "signatureAfterChange": "  public boolean isCompatibleWith(TypeBinding targetType, final Scope scope)", "diff": ["+", "+public boolean isCompatibleWith(TypeBinding targetType, final Scope scope) {", "+\tif (this.argumentsHaveErrors || this.binding == null || !this.binding.isValidBinding() || targetType == null || scope == null)", "+\t\treturn false;", "+\tTypeBinding allocationType = this.resolvedType;", "+\tif (isPolyExpression()) {", "+\t\tTypeBinding originalExpectedType = this.typeExpected;", "+\t\ttry {", "+\t\t\tthis.typeExpected = targetType;", "+\t\t\tReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();", "+\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+\t\t\tif (inferredTypes == null)", "+\t\t\t\treturn false;", "+\t\t\tallocationType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t} finally {", "+\t\t\tthis.typeExpected = originalExpectedType;", "+\t\t}", "+\t}", "+\treturn allocationType != null && allocationType.isCompatibleWith(targetType, scope);", "+}", "-}", "-public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType, Scope scope) {", "-\tthis.typeExpected = targetType;", "-\tboolean needsUpdate = this.binding == null || \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// not yet resolved", "-\t\t\t(this.resolvedType != null && targetType != null && !this.resolvedType.isCompatibleWith(targetType));\t// previous attempt was wrong", "-\tif (needsUpdate && this.suspendedResolutionState != null && !this.suspendedResolutionState.hasReportedError) {", "-\t\t// Attempt to resolve half resolved diamond", "-\t\tresolvePart2(this.suspendedResolutionState);", "-\t}", "-\t// confer MessageSend.checkAgainstFinalTargetType(,,):", "-\tif (this.binding instanceof ParameterizedGenericMethodBinding) {", "-\t\tInferenceContext18 ctx = getInferenceContext((ParameterizedMethodBinding) this.binding);", "-\t\tif (ctx != null && ctx.stepCompleted < InferenceContext18.TYPE_INFERRED) {", "-\t\t\tthis.typeExpected = targetType;", "-\t\t\tMethodBinding updatedBinding = ctx.inferInvocationType(this, (ParameterizedGenericMethodBinding) this.binding);", "-\t\t\tif (updateBindings(updatedBinding, targetType)) {", "-\t\t\t\tASTNode.resolvePolyExpressionArguments(this, updatedBinding, scope);", "-\t\t\t}", "-\t\t}", "-\t}", "-\tif (this.suspendedResolutionState != null) {", "-\t\treturn resolvePart3(this.suspendedResolutionState);", "-\t}", "-\treturn this.resolvedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c37ea218d9612f6a3e3129a7a8a48325", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["+\tTypeBinding[] argumentTypes = Binding.NO_PARAMETERS;", "-\t\tfor (int a = argsLength; --a >= 0;)", "-\t\t\tthis.arguments[a].resolveType(scope);", "+\t\tint length = this.arguments.length;", "+\t\targumentTypes = new TypeBinding[length];", "+\t\tfor (int a = argsLength; --a >= 0;) {", "+\t\t\targumentTypes[a] = this.arguments[a].resolveType(scope);", "+\t\t}", "-", "+\tfinal boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;", "+\t\tif (enclosingType == null) {", "+\t\t\t// try to propose something even if enclosing type cannot be resolved.", "+\t\t\t// Eg.: new Test<>().new Test<>(#cursor#", "+\t\t\tif (this.enclosingInstance instanceof AllocationExpression) {", "+\t\t\t\tTypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;", "+\t\t\t\tif (enclosingInstanceType != null) {", "+\t\t\t\t\tenclosingType = enclosingInstanceType.resolvedType;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(((ParameterizedTypeBinding) this.resolvedType).genericType(), null, argumentTypes, scope);", "+\t\t\tif (inferredTypes != null) {", "+\t\t\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t\t} else {", "+\t\t\t\t// inference failed. Resolved type will be of the form Test<>", "+\t\t\t\tthis.bits |= ASTNode.IsDiamond;", "+\t\t\t}", "+\t \t}", "-\t\tthis.resolvedType = this.type.resolveType(scope, true /* check bounds*/);", "+\t \tthis.resolvedType = this.type.resolveType(scope, true /* check bounds*/);", "+\t \tif (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(((ParameterizedTypeBinding) this.resolvedType).genericType(), null, argumentTypes, scope);", "+\t\t\tif (inferredTypes != null) {", "+\t\t\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t\t} else {", "+\t\t\t\t// inference failed. Resolved type will be of the form Test<>", "+\t\t\t\tthis.bits |= ASTNode.IsDiamond;", "+\t\t\t}", "+\t \t}"]}], "num": 43096}