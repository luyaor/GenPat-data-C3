{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a1268c5be96102589e9028cc4a174525", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c6283ed0e3057250d52914716b367de0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java", "commitBeforeChange": "e5e6f9097f2c3bf7294bd658643d6be9f7aaa5ef", "commitAfterChange": "d00bc48524f3df289951f11fca95cb39820be47f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "\r \r \tpublic FlowInfo analyseCode(\r \t\tBlockScope currentScope,\r \t\tFlowContext flowContext,\r \t\tFlowInfo flowInfo)", "diff": ["-}\r", "-public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {\r", "-\tConstant opConstant;\r", "-\tif ((opConstant = left.constant) != NotAConstant) {\r", "-\t\tif (opConstant.booleanValue() == true) { \r", "-\t\t\t// TRUE && anything\r", "-\t\t\tFlowInfo mergedInfo = right.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\treturn mergedInfo;\r", "-\t\t} else { \r", "-\t\t\t// FALSE && anything\r", "-\t\t\treturn flowInfo;\r", "-\t\t}\r", "-\t}\r", "-\tif ((opConstant = right.constant) != NotAConstant) {\r", "-\t\tif (opConstant.booleanValue() == true) { \r", "-\t\t\t// anything && TRUE\r", "-\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\treturn mergedInfo;\r", "-\t\t} else { \r", "-\t\t\t// anything && FALSE\r", "-\t\t\t// whatever is on the left, we will fail, so the result must merge the left inits when answering\r", "-\t\t\t// initsWhenFalse. the initsWhenTrue are undetermined, since this path will be fake reachable...\r", "-\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\treturn mergedInfo;\t\t\t\r", "-\t\t}\r", "-\t}\r", "-\tif ((opConstant = left.conditionalConstant()) != NotAConstant){\r", "-\t\tif (opConstant.booleanValue() == false){ \r", "-\t\t\t// something eq. FALSE && anything\r", "-\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\tright.analyseCode(currentScope, flowContext, mergedInfo.copy().markAsFakeReachable(true));\r", "-\t\t\treturn mergedInfo;\r", "-\t\t} \r", "-\t}\r", "-\tFlowInfo leftInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\tFlowInfo rightInfo = leftInfo.initsWhenTrue().copy();\r", "-\trightInitStateIndex = currentScope.methodScope().recordInitializationStates(rightInfo);\r", "-\trightInfo = right.analyseCode(currentScope, flowContext, rightInfo);\r", "-\tFlowInfo mergedInfo = FlowInfo.conditional(\r", "-\t\t\t\t\t\t\t\t\t\t\t\t\trightInfo.initsWhenTrue(), \r", "-\t\t\t\t\t\t\t\t\t\t\t\t\tleftInfo.initsWhenFalse().unconditionalInits().mergedWith(rightInfo.initsWhenFalse().copy().unconditionalInits()));\r", "-\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\treturn mergedInfo;\r", "-}\r", "+\tpublic FlowInfo analyseCode(\r", "+\t\tBlockScope currentScope,\r", "+\t\tFlowContext flowContext,\r", "+\t\tFlowInfo flowInfo) {\r", "+\t\tConstant opConstant = left.conditionalConstant();\r", "+\t\tif (opConstant != NotAConstant) {\r", "+\t\t\tif (opConstant.booleanValue() == true) {\r", "+\t\t\t\t// TRUE && anything\r", "+\t\t\t\t // need to be careful of scenario:\r", "+\t\t\t\t//\t\t(x && y) && !z, if passing the left info to the right, it would be swapped by the !\r", "+\t\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits(); \r", "+\t\t\t\tmergedInfo = right.analyseCode(currentScope, flowContext, mergedInfo);\r", "+\t\t\t\tmergedInitStateIndex =\r", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);\r", "+\t\t\t\treturn mergedInfo;\r", "+\t\tFlowInfo leftInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "+\t\t // need to be careful of scenario:\r", "+\t\t//\t\t(x && y) && !z, if passing the left info to the right, it would be swapped by the !\r", "+\t\tFlowInfo rightInfo = leftInfo.initsWhenTrue().unconditionalInits().copy();\r", "+\t\tif (opConstant != NotAConstant && opConstant.booleanValue() == false) rightInfo.markAsFakeReachable(true);\r", "+\r", "+\t\trightInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(rightInfo);\r", "+\t\trightInfo = right.analyseCode(currentScope, flowContext, rightInfo);\r", "+\t\tFlowInfo mergedInfo =\r", "+\t\t\tFlowInfo.conditional(\r", "+\t\t\t\trightInfo.initsWhenTrue().copy(),\r", "+\t\t\t\tleftInfo.initsWhenFalse().copy().unconditionalInits().mergedWith(\r", "+\t\t\t\t\trightInfo.initsWhenFalse().copy().unconditionalInits()));\r", "+\t\tmergedInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);\r", "+\t\treturn mergedInfo;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf42f9da6ff19f0b00f4ee6943ef2c47", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java", "commitBeforeChange": "2f0c7ec523954b9442b914a192aeb84937c76666", "commitAfterChange": "e1ce38065823480549fe152214755fa58b2884e3", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "   public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String qualifiedBinaryFileName)", "signatureAfterChange": "   public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String qualifiedBinaryFileName)", "diff": ["+\tClassFileReader reader = null;", "-\t\tClassFileReader reader = ClassFileReader.read(binaryLocation + qualifiedBinaryFileName);", "-\t\tif (reader != null) {", "-\t\t\tif (this.accessRuleSet == null)", "-\t\t\t\treturn new NameEnvironmentAnswer(reader, null);", "-\t\t\tString fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);", "-\t\t\treturn new NameEnvironmentAnswer(reader, this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()));", "-\t\t}", "-\t} catch (Exception e) {", "-\t\t// handle the case when the project is the output folder and the top-level package is a linked folder", "-\t\tif (binaryFolder instanceof IProject) {", "-\t\t\tIResource file = binaryFolder.findMember(qualifiedBinaryFileName);", "-\t\t\tif (file instanceof IFile) {", "-\t\t\t\tIPath location = file.getLocation();", "-\t\t\t\tif (location != null) {", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tClassFileReader reader = ClassFileReader.read(location.toString());", "-\t\t\t\t\t\tif (reader != null) {", "-\t\t\t\t\t\t\tif (this.accessRuleSet == null)", "-\t\t\t\t\t\t\t\treturn new NameEnvironmentAnswer(reader, null);", "-\t\t\t\t\t\t\tString fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);", "-\t\t\t\t\t\t\treturn new NameEnvironmentAnswer(reader, this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()));", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} catch (Exception ignored) { // treat as if class file is missing", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "+\t\treader = Util.newClassFileReader(this.binaryFolder.getFile(new Path(qualifiedBinaryFileName)));", "+\t} catch (CoreException e) {", "+\t\treturn null;", "+\t} catch (ClassFormatException e) {", "+\t\treturn null;", "+\t} catch (IOException e) {", "+\t\treturn null;", "+\t}", "+\tif (reader != null) {", "+\t\tif (this.accessRuleSet == null)", "+\t\t\treturn new NameEnvironmentAnswer(reader, null);", "+\t\tString fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);", "+\t\treturn new NameEnvironmentAnswer(reader, this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e2888cccf492632747f5bced61c45d7f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CopyResourceElementsOperation.java", "commitBeforeChange": "90d481edc9060cc498a8f085b08186108312e37b", "commitAfterChange": "f3a3c06f6e68ab7680c250209b9759ac3d56fec6", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tprivate void processPackageFragmentResource(PackageFragment source, PackageFragmentRoot root, String newName) throws JavaModelException", "signatureAfterChange": " \tprivate void processPackageFragmentResource(PackageFragment source, PackageFragmentRoot root, String newName) throws JavaModelException", "diff": ["-    // TODO - JDOM - remove once model ported off of JDOM", "-\t\t\tboolean sourceIsReadOnly = srcFolder.isReadOnly();", "+\t\t\tboolean sourceIsReadOnly = Util.isReadOnly(srcFolder);", "-\t\t\t\t\tsrcFolder.setReadOnly(false);", "+\t\t\t\t\tUtil.setReadOnly(srcFolder, false);", "-\t\t\t\t\tsrcFolder.setReadOnly(true);", "+\t\t\t\t\tUtil.setReadOnly(srcFolder, true);", "-\t\t\t\t\t\tIDOMCompilationUnit domCU = fFactory.createCompilationUnit(cu.getSource(), cu.getElementName());", "-\t\t\t\t\t\tif (domCU != null) {", "-\t\t\t\t\t\t\tupdatePackageStatement(domCU, newFragName);", "-\t\t\t\t\t\t\tIBuffer buffer = cu.getBuffer();", "-\t\t\t\t\t\t\tif (buffer == null) continue;", "-\t\t\t\t\t\t\tString bufferContents = buffer.getContents();", "-\t\t\t\t\t\t\tif (bufferContents == null) continue;", "-\t\t\t\t\t\t\tString domCUContents = domCU.getContents();", "-\t\t\t\t\t\t\tString cuContents = null;", "-\t\t\t\t\t\t\tif (domCUContents != null) {", "-\t\t\t\t\t\t\t\tcuContents = Util.normalizeCRs(domCU.getContents(), bufferContents);", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t// See PR http://dev.eclipse.org/bugs/show_bug.cgi?id=11285", "-\t\t\t\t\t\t\t\tcuContents = bufferContents;//$NON-NLS-1$", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbuffer.setContents(cuContents);", "-\t\t\t\t\t\t\tcu.save(null, false);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.parser.setSource(cu);", "+\t\t\t\t\t\tCompilationUnit astCU = (CompilationUnit) this.parser.createAST(this.progressMonitor);", "+\t\t\t\t\t\tupdatePackageStatement(astCU, newFragName, getDocument(cu));", "+\t\t\t\t\t\tcu.save(null, false);", "-\t\t\t\t\t\t\tif (file.isReadOnly()) {", "-\t\t\t\t\t\t\t\tfile.setReadOnly(false);", "+\t\t\t\t\t\t\tif (Util.isReadOnly(file)) {", "+\t\t\t\t\t\t\t\tUtil.setReadOnly(file, false);", "-\t\t} catch (DOMException dom) {", "-\t\t\tthrow new JavaModelException(dom, IJavaModelStatusConstants.DOM_EXCEPTION);"]}], "num": 57494}