{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "767aca8321a237acefb669af7c95a7fd", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8ed954a4b063c0ebb6c3ced539ff63b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "6c7de59cc4e8b7d3ff952cb73eea6ba69e83b190", "commitAfterChange": "8eda346eb2b6784c607071f6828a328415623f59", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": "  public void checkcast(TypeReference typeReference, TypeBinding typeBinding)", "signatureAfterChange": "  public void checkcast(TypeReference typeReference, TypeBinding typeBinding)", "diff": ["-\t/* We use a slightly sub-optimal generation for intersection casts by resorting to a runtime cast for every intersecting type, but in", "-\t   reality this should not matter. In its intended use form such as (I & Serializable) () -> {}, no cast is emitted at all", "-\t*/", "-\tTypeBinding [] types = typeBinding instanceof IntersectionCastTypeBinding ? typeBinding.getIntersectingTypes() : new TypeBinding [] { typeBinding };", "-\tfor (int i = 0, max = types.length; i < max; i++) {", "-\t\tthis.countLabels = 0;", "-\t\tif (this.classFileOffset + 2 >= this.bCodeStream.length) {", "-\t\t\tresizeByteArray();", "-\t\t}", "-\t\tthis.position++;", "-\t\tthis.bCodeStream[this.classFileOffset++] = Opcodes.OPC_checkcast;", "-\t\twriteUnsignedShort(this.constantPool.literalIndexForType(types[i]));", "+\tthis.countLabels = 0;", "+\tif (this.classFileOffset + 2 >= this.bCodeStream.length) {", "+\t\tresizeByteArray();", "+\tthis.position++;", "+\tthis.bCodeStream[this.classFileOffset++] = Opcodes.OPC_checkcast;", "+\twriteUnsignedShort(this.constantPool.literalIndexForType(typeBinding));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "97099eb14029c79526b97d4da437e3e8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/impl/InMemoryIndex.java", "commitBeforeChange": "0050ce1e7f4e1aa09d2a0680eb2a656c745b9584", "commitAfterChange": "c557f8e28df32d4f3742c65d1f4547b281353194", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \tpublic IndexedFile getIndexedFile(String path)", "signatureAfterChange": "\r \tpublic IndexedFile getIndexedFile(String path)", "diff": ["-\t\t// duplicate paths do exist but by walking the collection backwards, the latest is found\r", "-\t\tfor (int i= files.size(); i > 0; i--) {\r", "-\t\t\tIndexedFile file= (IndexedFile) files.get(i - 1);\r", "-\t\t\tif (file.getPath().equals(path))\r", "-\t\t\t\treturn file;\r", "-\t\t}\r", "-\t\treturn null;\r", "+\t\treturn files.get(path);\r"]}], "num": 37235}