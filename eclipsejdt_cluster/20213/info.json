{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "85cd511c9e9255982eec78e0141a1727", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "015ef4cbf2f0a15108d550749546005f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java", "commitBeforeChange": "00b719c0d7c4b5271c818d210d84b349bc0324e3", "commitAfterChange": "f90ca993824b1d0e38aec24edba147ca4e8ec0d1", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \t \tpublic void resolve(BlockScope scope)", "signatureAfterChange": " \t \tpublic void resolve(BlockScope scope)", "diff": ["-\t\t\tTypeBinding[] argTypes = NoParameters;", "+\t\t\tTypeBinding[] argumentTypes = NoParameters;", "+\t\t\tboolean argsContainCast = false;", "-\t\t\t\targTypes = new TypeBinding[length];", "-\t\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\t\tif ((argTypes[i] = arguments[i].resolveType(scope)) == null)", "+\t\t\t\targumentTypes = new TypeBinding[length];", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\t\t\targsContainCast = true;", "+\t\t\t\t\t}", "+\t\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null) {", "-\t\t\t\tif (argHasError)", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (argHasError) {", "+\t\t\t\t}", "-\t\t\tif ((binding = scope.getConstructor(receiverType, argTypes, this))", "-\t\t\t\t.isValidBinding()) {", "+\t\t\tif ((binding = scope.getConstructor(receiverType, argumentTypes, this)).isValidBinding()) {", "-\t\t\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\t\t\targuments[i].implicitWidening(paramTypes[i], argTypes[i]);", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\targuments[i].implicitWidening(paramTypes[i], argumentTypes[i]);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (argsContainCast) {", "+\t\t\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, receiverType, binding, this.arguments, argumentTypes, this);", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5daaaf8d9e2269ae48c45bbb01a614af", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "00b719c0d7c4b5271c818d210d84b349bc0324e3", "commitAfterChange": "f90ca993824b1d0e38aec24edba147ca4e8ec0d1", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\tpublic TypeBinding resolveType(BlockScope scope) {", "-", "-\t\t// Propagate the type checking to the arguments, and check if the constructor is defined.", "-\t\tconstant = NotAConstant;", "-\t\tthis.resolvedType = type.resolveType(scope);", "-\t\t// will check for null after args are resolved", "-", "-\t\t// buffering the arguments' types", "-\t\tTypeBinding[] argumentTypes = NoParameters;", "-\t\tif (arguments != null) {", "-\t\t\tboolean argHasError = false;", "-\t\t\tint length = arguments.length;", "-\t\t\targumentTypes = new TypeBinding[length];", "-\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)", "-\t\t\t\t\targHasError = true;", "-\t\t\tif (argHasError)", "-\t\t\t\treturn this.resolvedType;", "-\t\t}", "-\t\tif (this.resolvedType == null)", "-\t\t\treturn null;", "-", "-\t\tif (!this.resolvedType.canBeInstantiated()) {", "-\t\t\tscope.problemReporter().cannotInstantiate(type, this.resolvedType);", "-\t\t\treturn this.resolvedType;", "-\t\t}", "-\t\tReferenceBinding allocatedType = (ReferenceBinding) this.resolvedType;", "-\t\tif (!(binding = scope.getConstructor(allocatedType, argumentTypes, this))", "-\t\t\t.isValidBinding()) {", "-\t\t\tif (binding.declaringClass == null)", "-\t\t\t\tbinding.declaringClass = allocatedType;", "-\t\t\tscope.problemReporter().invalidConstructor(this, binding);", "-\t\t\treturn this.resolvedType;", "-\t\t}", "-\t\tif (isMethodUseDeprecated(binding, scope))", "-\t\t\tscope.problemReporter().deprecatedMethod(binding, this);", "-", "-\t\tif (arguments != null)", "-\t\t\tfor (int i = 0; i < arguments.length; i++)", "-\t\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);", "-\t\treturn allocatedType;", "-\t}", "+\t", "+\tpublic TypeBinding resolveType(BlockScope scope) {", "+", "+\t\t// Propagate the type checking to the arguments, and check if the constructor is defined.", "+\t\tconstant = NotAConstant;", "+\t\tthis.resolvedType = type.resolveType(scope);", "+\t\t// will check for null after args are resolved", "+", "+\t\t// buffering the arguments' types", "+\t\tboolean argsContainCast = false;", "+\t\tTypeBinding[] argumentTypes = NoParameters;", "+\t\tif (arguments != null) {", "+\t\t\tboolean argHasError = false;", "+\t\t\tint length = arguments.length;", "+\t\t\targumentTypes = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\t\targsContainCast = true;", "+\t\t\t\t}", "+\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null) {", "+\t\t\t\t\targHasError = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (argHasError) {", "+\t\t\t\treturn this.resolvedType;", "+\t\t\t}", "+\t\t}", "+\t\tif (this.resolvedType == null)", "+\t\t\treturn null;", "+", "+\t\tif (!this.resolvedType.canBeInstantiated()) {", "+\t\t\tscope.problemReporter().cannotInstantiate(type, this.resolvedType);", "+\t\t\treturn this.resolvedType;", "+\t\t}", "+\t\tReferenceBinding allocationType = (ReferenceBinding) this.resolvedType;", "+\t\tif (!(binding = scope.getConstructor(allocationType, argumentTypes, this))", "+\t\t\t.isValidBinding()) {", "+\t\t\tif (binding.declaringClass == null)", "+\t\t\t\tbinding.declaringClass = allocationType;", "+\t\t\tscope.problemReporter().invalidConstructor(this, binding);", "+\t\t\treturn this.resolvedType;", "+\t\t}", "+\t\tif (isMethodUseDeprecated(binding, scope))", "+\t\t\tscope.problemReporter().deprecatedMethod(binding, this);", "+", "+\t\tif (arguments != null) {", "+\t\t\tfor (int i = 0; i < arguments.length; i++) {", "+\t\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);", "+\t\t\t}", "+\t\t\tif (argsContainCast) {", "+\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, allocationType, binding, this.arguments, argumentTypes, this);", "+\t\t\t}", "+\t\t}", "+\t\treturn allocationType;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "86689129daa7ad784d04262b22797002", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "00b719c0d7c4b5271c818d210d84b349bc0324e3", "commitAfterChange": "f90ca993824b1d0e38aec24edba147ca4e8ec0d1", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t\tboolean argsContainCast = false;", "-\t\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null){", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\t\t\targsContainCast = true;", "+\t\t\t\t\t}", "+\t\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null){", "+\t\t\t\t}", "-", "+\t\t\tReferenceBinding allocationType = (ReferenceBinding) receiverType;", "-\t\t\tif ((this.binding = scope.getConstructor((ReferenceBinding) receiverType, argumentTypes, this))", "-\t\t\t\t\t.isValidBinding()) {", "-\t\t\t\tif (isMethodUseDeprecated(binding, scope))", "+\t\t\tif ((this.binding = scope.getConstructor(allocationType, argumentTypes, this)).isValidBinding()) {", "+\t\t\t\tif (isMethodUseDeprecated(binding, scope)) {", "-", "-\t\t\t\tif (arguments != null)", "-\t\t\t\t\tfor (int i = 0; i < arguments.length; i++)", "+\t\t\t\t}", "+\t\t\t\tif (arguments != null) {", "+\t\t\t\t\tfor (int i = 0; i < arguments.length; i++) {", "+\t\t\t\t\t}", "+\t\t\t\t\tif (argsContainCast) {", "+\t\t\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, allocationType, binding, this.arguments, argumentTypes, this);", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t\tif (this.binding.declaringClass == null)", "-\t\t\t\t\tthis.binding.declaringClass = (ReferenceBinding) receiverType;", "+\t\t\t\tif (this.binding.declaringClass == null) {", "+\t\t\t\t\tthis.binding.declaringClass = allocationType;", "+\t\t\t\t}", "-\t\t\tif (enclosingInstanceType.isCompatibleWith(expectedType))", "+\t\t\tif (enclosingInstanceType.isCompatibleWith(expectedType)) {", "+\t\t\t}", "-\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null) {", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\t\targsContainCast = true;", "+\t\t\t\t}", "+\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null) {", "+\t\t\t}", "-\t\t\t\treturn receiverType;", "+\t\t\treturn receiverType;", "-\t\t\tif (inheritedBinding.declaringClass == null)", "+\t\t\tif (inheritedBinding.declaringClass == null) {", "+\t\t\t}", "-\t\tif (arguments != null)", "-\t\t\tfor (int i = 0; i < arguments.length; i++)", "+\t\tif (arguments != null) {", "+\t\t\tfor (int i = 0; i < arguments.length; i++) {", "-", "+\t\t\t}", "+\t\t\tif (argsContainCast) {", "+\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, this.superTypeBinding, inheritedBinding, this.arguments, argumentTypes, this);", "+\t\t\t}", "+\t\t}"]}], "num": 20213}