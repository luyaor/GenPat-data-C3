{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "409ce02afae7612a174da471ff3e7a1a", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c66039ac2367fbb40d5e869eab4c1061", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "3edfc82342658662e3a25a41e35742d4e6f8a5e9", "commitAfterChange": "605cc5dd745b7e1d6935bfc34c1be6fcea51b4ab", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 26, "signatureBeforeChange": " protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type, TypeBinding[] argumentTypes)", "signatureAfterChange": " protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type, TypeBinding[] argumentTypes)", "diff": ["-\t\tif (!type.isAbstract() && !type.isInterface()) { // if concrete class, then method is overridden", "+\t\tMethodBinding method = argumentTypes == null ? null : getMethodBinding(type, argumentTypes);", "+\t\tif (((method != null && !method.isAbstract()) || !type.isAbstract()) && !type.isInterface()) { // if concrete, then method is overridden", "-\t\t\t\tMethodBinding[] methods = type.getMethods(this.pattern.selector);", "-\t\t\t\tfor (int i=0, length=methods.length; i<length; i++) {", "-\t\t\t\t\tMethodBinding method = methods[i];", "-\t\t\t\t\tTypeBinding[] parameters = method.parameters;", "-\t\t\t\t\tif (argumentTypes.length == parameters.length) {", "-\t\t\t\t\t\tboolean found = true;", "-\t\t\t\t\t\tfor (int j=0,l=parameters.length; j<l; j++) {", "-\t\t\t\t\t\t\tif (parameters[j].erasure() != argumentTypes[j].erasure()) {", "-\t\t\t\t\t\t\t\tfound = false;", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (found) { // one method match in hierarchy", "-\t\t\t\t\t\t\tif ((level & OVERRIDDEN_METHOD_FLAVOR) != 0) {", "-\t\t\t\t\t\t\t\t// this method is already overridden on a super class, current match is impossible", "-\t\t\t\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (!method.isAbstract() && !type.isInterface()) {", "-\t\t\t\t\t\t\t\t// store the fact that the method is overridden", "-\t\t\t\t\t\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\tMethodBinding method = getMethodBinding(type, argumentTypes);", "+\t\t\t\tif (method != null) { // one method match in hierarchy", "+\t\t\t\t\tif ((level & OVERRIDDEN_METHOD_FLAVOR) != 0) {", "+\t\t\t\t\t\t// this method is already overridden on a super class, current match is impossible", "+\t\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!method.isAbstract() && !type.isInterface()) {", "+\t\t\t\t\t\t// store the fact that the method is overridden", "+\t\t\t\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d82bdc1daa60edb8f9e3d3302dfdc68f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ReconcileWorkingCopyOperation.java", "commitBeforeChange": "20a3b07578a2ebec2d9a0569764e78af37761eaf", "commitAfterChange": "c052d66dbc2732414cdaf446e79eec5da0743843", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected void executeOperation() throws JavaModelException", "signatureAfterChange": " \tprotected void executeOperation() throws JavaModelException", "diff": ["-\t\t\tbeginTask(Messages.element_reconciling, 2); ", "-\t", "+\t\t\tbeginTask(Messages.element_reconciling, 2);", "+", "+\t\t\tif (problemRequestor != null) {", "+\t\t\t\tproblemRequestor =  ((JavaModelManager.PerWorkingCopyInfo)problemRequestor).getProblemRequestor();", "+\t\t\t}", "+\t\t\tIProblemRequestor ownerProblemRequestor = this.workingCopyOwner.getProblemRequestor(workingCopy);", "-\t\t\t", "+", "-\t\t\t", "+", "-\t\t\t", "+", "-\t\t\t", "+", "-\t\t", "+", "-\t\t\t\ttry {", "-\t\t\t\t\tproblemRequestor.beginReporting();", "-\t\t\t\t\tfor (Iterator iteraror = this.problems.values().iterator(); iteraror.hasNext();) {", "-\t\t\t\t\t\tCategorizedProblem[] categorizedProblems = (CategorizedProblem[]) iteraror.next();", "-\t\t\t\t\t\tif (categorizedProblems == null) continue;", "-\t\t\t\t\t\tfor (int i = 0, length = categorizedProblems.length; i < length; i++) {", "-\t\t\t\t\t\t\tCategorizedProblem problem = categorizedProblems[i];", "-\t\t\t\t\t\t\tif (JavaModelManager.VERBOSE){", "-\t\t\t\t\t\t\t\tSystem.out.println(\"PROBLEM FOUND while reconciling : \" + problem.getMessage());//$NON-NLS-1$", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) break;", "-\t\t\t\t\t\t\tproblemRequestor.acceptProblem(problem);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t} finally {", "-\t\t\t\t\tproblemRequestor.endReporting();", "+\t\t\t\tif (problemRequestor != null) {", "+\t\t\t\t\treportProblems(workingCopy, problemRequestor);", "+\t\t\t\t}", "+\t\t\t\tif (ownerProblemRequestor != null && ownerProblemRequestor != problemRequestor) {", "+\t\t\t\t\treportProblems(workingCopy, ownerProblemRequestor);", "-\t\t\t", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e31b28c626b9bfe931600fe9be73bfa2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "fcf5bf0d0a4c39456e8c7db3f2ddaa402f21bade", "commitAfterChange": "6f8419ff850f25167775793977c62e26753f7b73", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic NameLookup(IPackageFragmentRoot[] packageFragmentRoots, HashtableOfArrayToObject packageFragments, ICompilationUnit[] workingCopies, Map rootToResolvedEntries)", "signatureAfterChange": "  \tpublic NameLookup( \t\t\tIPackageFragmentRoot[] packageFragmentRoots,  \t\t\tHashtableOfArrayToObject packageFragments,  \t\t\tHashtableOfArrayToObject isPackage,  \t\t\tICompilationUnit[] workingCopies,  \t\t\tMap rootToResolvedEntries)", "diff": ["-\tpublic NameLookup(IPackageFragmentRoot[] packageFragmentRoots, HashtableOfArrayToObject packageFragments, ICompilationUnit[] workingCopies, Map rootToResolvedEntries) {", "+\tpublic NameLookup(", "+\t\t\tIPackageFragmentRoot[] packageFragmentRoots, ", "+\t\t\tHashtableOfArrayToObject packageFragments, ", "+\t\t\tHashtableOfArrayToObject isPackage, ", "+\t\t\tICompilationUnit[] workingCopies, ", "+\t\t\tMap rootToResolvedEntries) {", "-\t\ttry {", "-\t\t\tthis.packageFragments = (HashtableOfArrayToObject) packageFragments.clone();", "-\t\t} catch (CloneNotSupportedException e1) {", "-\t\t\t// ignore (implementation of HashtableOfArrayToObject supports cloning)", "-\t\t}", "-\t\tif (workingCopies != null) {", "+\t\tif (workingCopies == null) {", "+\t\t\tthis.packageFragments = packageFragments;", "+\t\t\tthis.isPackageCache = isPackage;", "+\t\t} else {", "+\t\t\t// clone tables as we're adding packages from working copies", "+\t\t\ttry {", "+\t\t\t\tthis.packageFragments = (HashtableOfArrayToObject) packageFragments.clone();", "+\t\t\t\tthis.isPackageCache = (HashtableOfArrayToObject) isPackage.clone();", "+\t\t\t} catch (CloneNotSupportedException e1) {", "+\t\t\t\t// ignore (implementation of HashtableOfArrayToObject supports cloning)", "+\t\t\t}", "+\t\t\t\t\t// cache whether each package and its including packages (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=119161)", "+\t\t\t\t\t// are actual packages", "+\t\t\t\t\tJavaProjectElementInfo.addNames(pkgName, this.isPackageCache);", "-\t\t// cache whether each package and its including packages (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=119161)", "-\t\t// are actual packages", "-\t\tthis.isPackageCache = new HashtableOfArrayToObject();", "-\t\tfor (int i = 0, size = this.packageFragments.keyTable.length; i < size; i++) {", "-\t\t\tString[] pkgName = (String[]) this.packageFragments.keyTable[i];", "-\t\t\tif (pkgName == null) continue;", "-\t\t\tthis.isPackageCache.put(pkgName, pkgName);", "-\t\t\tint length = pkgName.length;", "-\t\t\tfor (int j = length-1; j > 0; j--) {", "-\t\t\t\tString[] subPkgName = new String[j];", "-\t\t\t\tSystem.arraycopy(pkgName, 0, subPkgName, 0, j);", "-\t\t\t\tthis.isPackageCache.put(subPkgName, subPkgName);", "-\t\t\t}", "-\t\t}", "-            Util.verbose(\" -> spent: \" + (start - System.currentTimeMillis()) + \"ms\");  //$NON-NLS-1$ //$NON-NLS-2$", "+            Util.verbose(\" -> spent: \" + (System.currentTimeMillis() - start) + \"ms\");  //$NON-NLS-1$ //$NON-NLS-2$"]}], "num": 3195}