{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "96d82da6f2e16e4104654646760f3981", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3554a7377db593299f0aa9ff66a80c1e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "3a9d0e9ebb77a4184e107b2ffacf2122d4d188cf", "commitAfterChange": "cc44d533509199a22dee3cb03412b30282a18add", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": " \tprivate void printJavadocTextLine(StringBuffer buffer, int textStart, int textEnd, FormatJavadocBlock block, boolean firstText, boolean needIndentation, boolean isHtmlTag)", "signatureAfterChange": " \tprivate void printJavadocTextLine(StringBuffer buffer, int textStart, int textEnd, FormatJavadocBlock block, boolean firstText, boolean needIndentation, boolean isHtmlTag)", "diff": ["+    \t\t\tint tokenStart = this.scanner.getCurrentTokenStartPosition();", "+\t    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE || (tokenStart == textStart && this.column > firstColumn && !(firstText || isHtmlTag));", "-\t\t\t\t\tcase TerminalTokens.TokenNameStringLiteral:", "-\t\t\t\t\t\tif (this.scanner.currentPosition > this.scanner.eofPosition) {", "-\t\t\t\t\t\t\tthis.scanner.resetTo(this.scanner.startPosition, textEnd);", "-\t\t\t\t\t\t\tthis.scanner.getNextChar();", "-\t\t\t\t\t\t\ttoken = 1;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-    \t\t\tint tokenStart = this.scanner.getCurrentTokenStartPosition();", "-\t    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE || (tokenStart == textStart && this.column > firstColumn && !(firstText || isHtmlTag));", "-\t\t\t\t\tif (!isHtmlTag && (firstColumn+tokensBufferLength+tokenLength) >= maxColumn) {", "+\t\t\t\t\tif (!isHtmlTag && tokensBufferLength > 0 && (firstColumn+tokensBufferLength+tokenLength) >= maxColumn) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f3c37f95f4d617729e09627fd807bdd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "388d6309502d2277c29518666e0a29b9ef8f3348", "commitAfterChange": "ef51b740fbbff33bb9bc830d786a838b3dd10149", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " public RecoveredElement buildInitialRecoveryState()", "signatureAfterChange": " public RecoveredElement buildInitialRecoveryState()", "diff": ["-\t\tif (true){ // experimenting restart recovery from scratch", "-\t\t\tthis.compilationUnit.currentPackage = null;", "-\t\t\tthis.compilationUnit.imports = null;", "-\t\t\tthis.compilationUnit.types = null;", "-\t\t\tthis.currentToken = 0;", "-\t\t\tthis.listLength = 0;", "-\t\t\tthis.listTypeParameterLength = 0;", "-\t\t\tthis.endPosition = 0;", "-\t\t\tthis.endStatementPosition = 0;", "-\t\t\treturn element;", "-\t\t}", "-\t\tif (this.compilationUnit.currentPackage != null){", "-\t\t\tthis.lastCheckPoint = this.compilationUnit.currentPackage.declarationSourceEnd+1;", "-\t\t}", "-\t\tif (this.compilationUnit.imports != null){", "-\t\t\tthis.lastCheckPoint = this.compilationUnit.imports[this.compilationUnit.imports.length -1].declarationSourceEnd+1;", "-\t\t}", "+\t\t// restart recovery from scratch", "+\t\tthis.compilationUnit.currentPackage = null;", "+\t\tthis.compilationUnit.imports = null;", "+\t\tthis.compilationUnit.types = null;", "+\t\tthis.currentToken = 0;", "+\t\tthis.listLength = 0;", "+\t\tthis.listTypeParameterLength = 0;", "+\t\tthis.endPosition = 0;", "+\t\tthis.endStatementPosition = 0;", "+\t\treturn element;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "435231c1e99e23cdb2ae2b1a3bf95d45", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "48b439005b4e27b9edf7ac75008df6663dca3609", "commitAfterChange": "db94ada762c25cbafb7604978ccc4fc3df281550", "methodNumberBeforeChange": 73, "methodNumberAfterChange": 72, "signatureBeforeChange": " \tpublic boolean visit( \t\tCompilationUnitDeclaration compilationUnitDeclaration, \t\tCompilationUnitScope scope)", "signatureAfterChange": " \tpublic boolean visit( \t\tCompilationUnitDeclaration compilationUnitDeclaration, \t\tCompilationUnitScope scope)", "diff": ["-\t\t\tthis.scribe.printTrailingComment();", "+\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "-\t\t\tint savedNumberOfLineToPreserve = this.preferences.number_of_empty_lines_to_preserve;", "-    \t\t\tthis.preferences.number_of_empty_lines_to_preserve = savedNumberOfLineToPreserve;", "-\t\t\tthis.preferences.number_of_empty_lines_to_preserve = savedNumberOfLineToPreserve;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "531df84b3d5ce9bb3c0230f75314e20e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "be99a78ebde70e086535a722e0c99b2c26590dce", "commitAfterChange": "15b09e3657f237aa7526b08315f9749226cbc20e", "methodNumberBeforeChange": 366, "methodNumberAfterChange": 366, "signatureBeforeChange": " protected boolean moveRecoveryCheckpoint()", "signatureAfterChange": " protected boolean moveRecoveryCheckpoint()", "diff": ["-\t\tif (this.scanner.currentLine != null) this.scanner.currentLine.clear();", "-\t\t\tif (this.scanner.currentLine != null) this.scanner.currentLine.clear();", "-\tif (this.scanner.currentLine != null) this.scanner.currentLine.clear();", "-"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "61721990a4aea19e769380ddd284dfcf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "787257b7f904a5d229cd823de8c5673381972038", "commitAfterChange": "a9350c2b120d179766a1ddbf26ea8f42a99618dc", "methodNumberBeforeChange": 127, "methodNumberAfterChange": 127, "signatureBeforeChange": " \tprotected int retrievePositionBeforeNextCommaOrSemiColon(int start, int end)", "signatureAfterChange": " \tprotected int retrievePositionBeforeNextCommaOrSemiColon(int start, int end)", "diff": ["-\t\t\t\t\t\tif(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isInsertedToken()) {", "-\t\t\t\t\t\t\treturn this.scanner.startPosition;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isInsertedToken()) {", "-\t\t\t\t\t\t\treturn this.scanner.startPosition;", "-\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "727b81bc05beb47ec60b0fbbcbfe4cac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "14eeb335b7a4f4b5dc293b65ac56b4b7f62e99e5", "commitAfterChange": "000351037175db78f3f7a7716a67e8a0125ff547", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprotected boolean parseParam() throws InvalidInputException", "signatureAfterChange": " \tprotected boolean parseParam() throws InvalidInputException", "diff": ["-\t\t// Verify that there are whitespaces after tag", "-\t\tboolean isCompletionParser = (this.kind & COMPLETION_PARSER) != 0;", "-\t\tif (this.scanner.currentCharacter != ' ' && !ScannerHelper.isWhitespace(this.scanner.currentCharacter)) {", "-\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(start, this.scanner.getCurrentTokenEndPosition());", "-\t\t\tif (!isCompletionParser) {", "-\t\t\t\tthis.scanner.currentPosition = start;", "-\t\t\t\tthis.index = start;", "-\t\t\t}", "-\t\t\tthis.currentTokenType = -1;", "-\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\t// Get first non whitespace token", "-\t\tthis.identifierPtr = -1;", "-\t\tthis.identifierLengthPtr = -1;", "-\t\tboolean hasMultiLines = this.scanner.currentPosition > (this.lineEnd+1);", "-\t\tboolean isTypeParam = false;", "-\t\tboolean valid = true, empty = true;", "-\t\tboolean mayBeGeneric = this.sourceLevel >= ClassFileConstants.JDK1_5;", "-\t\tint token = -1;", "-\t\tnextToken: while (true) {", "-\t\t\tthis.currentTokenType = -1;", "-\t\t\ttry {", "-\t\t\t\ttoken = readToken();", "-\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\tvalid = false;", "-\t\t\t}", "-\t\t\tswitch (token) {", "-\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\tif (valid) { ", "-\t\t\t\t\t\t// store param name id", "-\t\t\t\t\t\tpushIdentifier(true, false);", "-\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\t}", "-\t\t\t\t\t// fall through next case to report error", "-\t\t\t\tcase TerminalTokens.TokenNameLESS:", "-\t\t\t\t\tif (valid && mayBeGeneric) {", "-\t\t\t\t\t\t// store '<' in identifiers stack as we need to add it to tag element (bug 79809)", "-\t\t\t\t\t\tpushIdentifier(true, true);", "-\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tisTypeParam = true;", "-\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\t}", "-\t\t\t\t\t// fall through next case to report error", "-\t\t\t\tdefault:", "-\t\t\t\t\tif (token == TerminalTokens.TokenNameLEFT_SHIFT) isTypeParam = true;", "-\t\t\t\t\tif (valid && !hasMultiLines) start = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\tvalid = false;", "-\t\t\t\t\tif (!hasMultiLines) {", "-\t\t\t\t\t\tempty = false;", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\tend = this.lineEnd;", "-\t\t\t\t\t// when several lines, fall through next case to report problem immediately", "-\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\tif (this.scanner.currentPosition > (this.lineEnd+1)) hasMultiLines = true;", "-\t\t\t\t\tif (valid) break;", "-\t\t\t\t\t// if not valid fall through next case to report error", "-\t\t\t\tcase TerminalTokens.TokenNameEOF:", "-\t\t\t\t\tif (this.reportProblems)", "-\t\t\t\t\t\tif (empty)", "-\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocMissingParamName(start, end, this.sourceParser.modifiers);", "-\t\t\t\t\t\telse if (mayBeGeneric && isTypeParam)", "-\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "-\t\t\t\t\t\telse", "-\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTagName(start, end);", "-\t\t\t\t\tif (!isCompletionParser) {", "-\t\t\t\t\t\tthis.scanner.currentPosition = start;", "-\t\t\t\t\t\tthis.index = start;", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.currentTokenType = -1;", "-\t\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\t\t\t\treturn false;", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// Scan more tokens for type parameter declaration", "-\t\tif (isTypeParam && mayBeGeneric) {", "-\t\t\t// Get type parameter name", "-\t\t\tnextToken: while (true) {", "+\t\ttry {", "+\t\t\t// Verify that there are whitespaces after tag", "+\t\t\tboolean isCompletionParser = (this.kind & COMPLETION_PARSER) != 0;", "+\t\t\tif (this.scanner.currentCharacter != ' ' && !ScannerHelper.isWhitespace(this.scanner.currentCharacter)) {", "+\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(start, this.scanner.getCurrentTokenEndPosition());", "+\t\t\t\tif (!isCompletionParser) {", "+\t\t\t\t\tthis.scanner.currentPosition = start;", "+\t\t\t\t\tthis.index = start;", "+\t\t\t\t}", "-\t\t\t\ttry {", "-\t\t\t\t\ttoken = readToken();", "-\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\tvalid = false;", "-\t\t\t\t}", "-\t\t\t\tswitch (token) {", "-\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\tif (valid && this.scanner.currentPosition <= (this.lineEnd+1)) break;", "-\t\t\t\t\t\t// if not valid fall through next case to report error", "-\t\t\t\t\tcase TerminalTokens.TokenNameEOF:", "-\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "-\t\t\t\t\t\tif (!isCompletionParser) {", "-\t\t\t\t\t\t\tthis.scanner.currentPosition = start;", "-\t\t\t\t\t\t\tthis.index = start;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.currentTokenType = -1;", "-\t\t\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tif (valid) {", "-\t\t\t\t\t\t\t// store param name id", "-\t\t\t\t\t\t\tpushIdentifier(false, false);", "-\t\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tvalid = false;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\t\t\t\treturn false;", "-\t\t\t// Get last character of type parameter declaration", "-\t\t\tboolean spaces = false;", "+\t\t\t// Get first non whitespace token", "+\t\t\tthis.identifierPtr = -1;", "+\t\t\tthis.identifierLengthPtr = -1;", "+\t\t\tboolean hasMultiLines = this.scanner.currentPosition > (this.lineEnd+1);", "+\t\t\tboolean isTypeParam = false;", "+\t\t\tboolean valid = true, empty = true;", "+\t\t\tboolean mayBeGeneric = this.sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\t\tint token = -1;", "-\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\tif (this.scanner.currentPosition > (this.lineEnd+1)) {", "-\t\t\t\t\t\t\t// do not accept type parameter declaration on several lines", "-\t\t\t\t\t\t\thasMultiLines = true;", "-\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\tif (valid) { ", "+\t\t\t\t\t\t\t// store param name id", "+\t\t\t\t\t\t\tpushIdentifier(true, false);", "+\t\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\t\tspaces = true;", "+\t\t\t\t\t\t// fall through next case to report error", "+\t\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\t\tif (valid && mayBeGeneric) {", "+\t\t\t\t\t\t\t// store '<' in identifiers stack as we need to add it to tag element (bug 79809)", "+\t\t\t\t\t\t\tpushIdentifier(true, true);", "+\t\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tisTypeParam = true;", "+\t\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// fall through next case to report error", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tif (token == TerminalTokens.TokenNameLEFT_SHIFT) isTypeParam = true;", "+\t\t\t\t\t\tif (valid && !hasMultiLines) start = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\tif (!hasMultiLines) {", "+\t\t\t\t\t\t\tempty = false;", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tend = this.lineEnd;", "+\t\t\t\t\t\t// when several lines, fall through next case to report problem immediately", "+\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\tif (this.scanner.currentPosition > (this.lineEnd+1)) hasMultiLines = true;", "-\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\tif (this.reportProblems)", "+\t\t\t\t\t\t\tif (empty)", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocMissingParamName(start, end, this.sourceParser.modifiers);", "+\t\t\t\t\t\t\telse if (mayBeGeneric && isTypeParam)", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTagName(start, end);", "-\t\t\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\t\t\t\tcase TerminalTokens.TokenNameGREATER:", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tif (valid) {", "-\t\t\t\t\t\t\t// store '>' in identifiers stack as we need to add it to tag element (bug 79809)", "-\t\t\t\t\t\t\tpushIdentifier(false, true);", "-\t\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\tif (!spaces) end = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tvalid = false;", "-\t\t\t\t\t\tbreak;", "-\t\t}", "-\t\t", "-\t\t// Verify that tag name is well followed by white spaces", "-\t\tif (valid) {", "-\t\t\tthis.currentTokenType = -1;", "-\t\t\tint restart = this.scanner.currentPosition;", "-\t\t\ttry {", "-\t\t\t\ttoken = readToken();", "-\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\tvalid = false;", "+\t\t\t", "+\t\t\t// Scan more tokens for type parameter declaration", "+\t\t\tif (isTypeParam && mayBeGeneric) {", "+\t\t\t\t// Get type parameter name", "+\t\t\t\tnextToken: while (true) {", "+\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\ttoken = readToken();", "+\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t}", "+\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\tif (valid && this.scanner.currentPosition <= (this.lineEnd+1)) break;", "+\t\t\t\t\t\t\t// if not valid fall through next case to report error", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameEOF:", "+\t\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\t\tif (!isCompletionParser) {", "+\t\t\t\t\t\t\t\tthis.scanner.currentPosition = start;", "+\t\t\t\t\t\t\t\tthis.index = start;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tif (valid) {", "+\t\t\t\t\t\t\t\t// store param name id", "+\t\t\t\t\t\t\t\tpushIdentifier(false, false);", "+\t\t\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// Get last character of type parameter declaration", "+\t\t\t\tboolean spaces = false;", "+\t\t\t\tnextToken: while (true) {", "+\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\ttoken = readToken();", "+\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t}", "+\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\tif (this.scanner.currentPosition > (this.lineEnd+1)) {", "+\t\t\t\t\t\t\t\t// do not accept type parameter declaration on several lines", "+\t\t\t\t\t\t\t\thasMultiLines = true;", "+\t\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tspaces = true;", "+\t\t\t\t\t\t\tif (valid) break;", "+\t\t\t\t\t\t\t// if not valid fall through next case to report error", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameEOF:", "+\t\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\t\tif (!isCompletionParser) {", "+\t\t\t\t\t\t\t\tthis.scanner.currentPosition = start;", "+\t\t\t\t\t\t\t\tthis.index = start;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameGREATER:", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tif (valid) {", "+\t\t\t\t\t\t\t\t// store '>' in identifiers stack as we need to add it to tag element (bug 79809)", "+\t\t\t\t\t\t\t\tpushIdentifier(false, true);", "+\t\t\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\tif (!spaces) end = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "-\t\t\t\tthis.scanner.currentPosition = restart;", "-\t\t\t\tthis.index = restart;", "-\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\t\t\treturn pushParamName(isTypeParam);", "+\t\t\t", "+\t\t\t// Verify that tag name is well followed by white spaces", "+\t\t\tif (valid) {", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tint restart = this.scanner.currentPosition;", "+\t\t\t\ttry {", "+\t\t\t\t\ttoken = readToken();", "+\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\tvalid = false;", "+\t\t\t\t}", "+\t\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\t\t\tthis.scanner.currentPosition = restart;", "+\t\t\t\t\tthis.index = restart;", "+\t\t\t\t\treturn pushParamName(isTypeParam);", "+\t\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// Report problem", "-\t\tthis.currentTokenType = -1;", "-\t\tif (isCompletionParser) return false;", "-\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\twhile ((token=readToken()) != TerminalTokens.TokenNameWHITESPACE && token != TerminalTokens.TokenNameEOF) {", "+\t\t\t// Report problem", "+\t\t\tif (isCompletionParser) return false;", "+\t\t\twhile ((token=readToken()) != TerminalTokens.TokenNameWHITESPACE && token != TerminalTokens.TokenNameEOF) {", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t}", "+\t\t\tif (this.reportProblems)", "+\t\t\t\tif (mayBeGeneric && isTypeParam)", "+\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\telse", "+\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTagName(start, end);", "+\t\t\tthis.scanner.currentPosition = start;", "+\t\t\tthis.index = start;", "+\t\t\tthis.currentTokenType = -1;", "+\t\t\treturn false;", "+\t\t} finally {", "+\t\t\t// we have to make sure that this is reset to the previous value even if an exception occurs", "+\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\tif (this.reportProblems)", "-\t\t\tif (mayBeGeneric && isTypeParam)", "-\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "-\t\t\telse", "-\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTagName(start, end);", "-\t\tthis.scanner.currentPosition = start;", "-\t\tthis.index = start;", "-\t\tthis.currentTokenType = -1;", "-\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a85a129ea4f72530a3abbc31dfdf30f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "e0c65d48fbfbc2b240962f72967bed335ff04a38", "commitAfterChange": "388d6309502d2277c29518666e0a29b9ef8f3348", "methodNumberBeforeChange": 168, "methodNumberAfterChange": 168, "signatureBeforeChange": "  \tprivate void findTypesAndPackages(char[] token, Scope scope, boolean proposeBaseTypes, boolean proposeVoidType, ObjectVector typesFound)", "signatureAfterChange": "  \tprivate void findTypesAndPackages(char[] token, Scope scope, boolean proposeBaseTypes, boolean proposeVoidType, ObjectVector typesFound)", "diff": ["-\t\t// do not propose type if completion token is empty", "-\t\tboolean skip = false;", "-\t\tif (token.length == 0 && NO_TYPE_COMPLETION_ON_EMPTY_TOKEN) {", "-\t\t\tif(!this.assistNodeIsConstructor && (this.assistNodeInJavadoc & CompletionOnJavadoc.EXCEPTION) == 0) {", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t\tskip = true;", "-\t\t}", "-", "-\t\tif (!skip && proposeType && scope.enclosingSourceType() != null) {", "+\t\tif (proposeType && scope.enclosingSourceType() != null) {", "-\t\tif (!skip && proposeType && this.unitScope != null) {", "+\t\tif (proposeType && this.unitScope != null) {", "-\t\tif(!skip && proposeType) {", "+\t\tif(proposeType) {", "-\t\t\t\t\t\tif(skip || !inSameUnit || (inSameUnit && refBinding.isMemberType())) {", "+\t\t\t\t\t\tif(!inSameUnit || (inSameUnit && refBinding.isMemberType())) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cadb5152c6cb99b114cc555315e3f4e8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "3f4d5d2136631e9cf63e2a32bd9868cec640bf4a", "commitAfterChange": "e72ce28100309ddf8def791ea7002ecc7cb95b9e", "methodNumberBeforeChange": 66, "methodNumberAfterChange": 66, "signatureBeforeChange": " \tpublic boolean visit( \t\tConditionalExpression conditionalExpression, \t\tBlockScope scope)", "signatureAfterChange": "     public boolean visit(     \tConditionalExpression conditionalExpression,     \tBlockScope scope)", "diff": ["-\t */", "-\tpublic boolean visit(", "-\t\tConditionalExpression conditionalExpression,", "-\t\tBlockScope scope) {", "-", "-\t\tfinal int numberOfParens = (conditionalExpression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;", "-\t\tif (numberOfParens > 0) {", "-\t\t\tmanageOpeningParenthesizedExpression(conditionalExpression, numberOfParens);", "-\t\t}", "-\t\tconditionalExpression.condition.traverse(this, scope);", "-", "-\t\tboolean placeSpaceImmediately = this.preferences.insert_space_before_question_in_conditional", "-\t\t\t\t&& ((this.preferences.conditional_expression_alignment & Alignment.M_INDENT_ON_COLUMN) != 0)", "-\t\t\t\t&& ((this.preferences.conditional_expression_alignment & Alignment.M_NEXT_PER_LINE_SPLIT) != 0);", "-\t\tif (placeSpaceImmediately) {", "-\t\t\tthis.scribe.space();", "-\t\t}", "-\t\t", "-\t\tAlignment conditionalExpressionAlignment =this.scribe.createAlignment(", "-\t\t\t\t\"conditionalExpression\", //$NON-NLS-1$", "-\t\t\t\tthis.preferences.conditional_expression_alignment,", "-\t\t\t\t2,", "-\t\t\t\tthis.scribe.scanner.currentPosition);", "-", "-\t\tthis.scribe.enterAlignment(conditionalExpressionAlignment);", "-\t\tboolean ok = false;", "-\t\tdo {", "-\t\t\ttry {", "-\t\t\t\tthis.scribe.alignFragment(conditionalExpressionAlignment, 0);", "-\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameQUESTION, !placeSpaceImmediately && this.preferences.insert_space_before_question_in_conditional);", "-", "-\t\t\t\tif (this.preferences.insert_space_after_question_in_conditional) {", "-\t\t\t\t\tthis.scribe.space();", "-\t\t\t\t}", "-\t\t\t\tconditionalExpression.valueIfTrue.traverse(this, scope);", "-\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\tthis.scribe.alignFragment(conditionalExpressionAlignment, 1);", "-\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameCOLON, this.preferences.insert_space_before_colon_in_conditional);", "-", "-\t\t\t\tif (this.preferences.insert_space_after_colon_in_conditional) {", "-\t\t\t\t\tthis.scribe.space();", "-\t\t\t\t}", "-\t\t\t\tconditionalExpression.valueIfFalse.traverse(this, scope);", "-", "-\t\t\t\tok = true;", "-\t\t\t} catch (AlignmentException e) {", "-\t\t\t\tthis.scribe.redoAlignment(e);", "-\t\t\t}", "-\t\t} while (!ok);", "-\t\tthis.scribe.exitAlignment(conditionalExpressionAlignment, true);", "-\t\t\t", "-\t\tif (numberOfParens > 0) {", "-\t\t\tmanageClosingParenthesizedExpression(conditionalExpression, numberOfParens);", "-\t\t}", "-\t\treturn false;\t", "-\t}", "+     */", "+    public boolean visit(", "+    \tConditionalExpression conditionalExpression,", "+    \tBlockScope scope) {", "+    ", "+    \tfinal int numberOfParens = (conditionalExpression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;", "+    \tif (numberOfParens > 0) {", "+    \t\tmanageOpeningParenthesizedExpression(conditionalExpression, numberOfParens);", "+    \t}", "+    \tconditionalExpression.condition.traverse(this, scope);", "+    ", "+    \tAlignment conditionalExpressionAlignment =this.scribe.createAlignment(", "+    \t\t\t\"conditionalExpression\", //$NON-NLS-1$", "+    \t\t\tthis.preferences.conditional_expression_alignment,", "+    \t\t\t2,", "+    \t\t\tthis.scribe.scanner.currentPosition);", "+    ", "+    \tthis.scribe.enterAlignment(conditionalExpressionAlignment);", "+    \tboolean ok = false;", "+    \tdo {", "+    \t\ttry {", "+    \t\t\tthis.scribe.alignFragment(conditionalExpressionAlignment, 0);", "+    \t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameQUESTION, this.preferences.insert_space_before_question_in_conditional);", "+    ", "+    \t\t\tif (this.preferences.insert_space_after_question_in_conditional) {", "+    \t\t\t\tthis.scribe.space();", "+    \t\t\t}", "+    \t\t\tconditionalExpression.valueIfTrue.traverse(this, scope);", "+    \t\t\tthis.scribe.printTrailingComment();", "+    \t\t\tthis.scribe.alignFragment(conditionalExpressionAlignment, 1);", "+    \t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameCOLON, this.preferences.insert_space_before_colon_in_conditional);", "+    ", "+    \t\t\tif (this.preferences.insert_space_after_colon_in_conditional) {", "+    \t\t\t\tthis.scribe.space();", "+    \t\t\t}", "+    \t\t\tconditionalExpression.valueIfFalse.traverse(this, scope);", "+    ", "+    \t\t\tok = true;", "+    \t\t} catch (AlignmentException e) {", "+    \t\t\tthis.scribe.redoAlignment(e);", "+    \t\t}", "+    \t} while (!ok);", "+    \tthis.scribe.exitAlignment(conditionalExpressionAlignment, true);", "+    \t\t", "+    \tif (numberOfParens > 0) {", "+    \t\tmanageClosingParenthesizedExpression(conditionalExpression, numberOfParens);", "+    \t}", "+    \treturn false;\t", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc7af9716fe2195d7d5a5df7ac4c3f34", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "ddcdec92193a08ed9a48385d9f75cb39b23ca528", "commitAfterChange": "5597c46654cd0a97c576a9b45078ed0c449aa7d1", "methodNumberBeforeChange": 69, "methodNumberAfterChange": 69, "signatureBeforeChange": " \tpublic boolean visit( \t\tCompilationUnitDeclaration compilationUnitDeclaration, \t\tCompilationUnitScope scope)", "signatureAfterChange": " \tpublic boolean visit( \t\tCompilationUnitDeclaration compilationUnitDeclaration, \t\tCompilationUnitScope scope)", "diff": ["-\t\tint numberOfEmptyLineToPreserve = this.preferences.number_of_empty_lines_to_preserve;", "-\t\tthis.preferences.number_of_empty_lines_to_preserve = 0;", "-\t\t\t\tthis.preferences.number_of_empty_lines_to_preserve = numberOfEmptyLineToPreserve;", "-\t\t\tthis.preferences.number_of_empty_lines_to_preserve = numberOfEmptyLineToPreserve;", "-\t\t\t}", "+\t\t\t}\t\t\t", "+\t\t", "-\t", "-\t\tthis.preferences.number_of_empty_lines_to_preserve = numberOfEmptyLineToPreserve;", "+"]}], "num": 27874}