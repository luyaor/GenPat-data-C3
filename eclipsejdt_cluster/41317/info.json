{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4bb75a9e61b94e6777d7d966e65ecdbf", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bb3cbcd5ebc25fcfe7574df485892f0d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "a2999324910e04c9c4d68f1aa93d5053c047f21c", "commitAfterChange": "a3d873b0829375e0f0465ac99af6f9753248e839", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tthis.codegenBinding = this.binding = scope.getField(this.receiverType, token, this);", "-\t\tif (!binding.isValidBinding()) {", "+\t\tFieldBinding fieldBinding = this.codegenBinding = this.binding = scope.getField(this.receiverType, token, this);", "+\t\tif (!fieldBinding.isValidBinding()) {", "-\t\t\tReferenceBinding match = ((ReferenceBinding)receiverErasure).findSuperTypeErasingTo((ReferenceBinding)this.binding.declaringClass.erasure());", "+\t\t\tReferenceBinding match = ((ReferenceBinding)receiverErasure).findSuperTypeErasingTo((ReferenceBinding)fieldBinding.declaringClass.erasure());", "-\t\t\t\tthis.receiverType = this.binding.declaringClass; // handle indirect inheritance thru variable secondary bound", "+\t\t\t\tthis.receiverType = fieldBinding.declaringClass; // handle indirect inheritance thru variable secondary bound", "-\t\tif (isFieldUseDeprecated(binding, scope, (this.bits & IsStrictlyAssignedMASK) !=0)) {", "-\t\t\tscope.problemReporter().deprecatedField(binding, this);", "+\t\tif (isFieldUseDeprecated(fieldBinding, scope, (this.bits & IsStrictlyAssignedMASK) !=0)) {", "+\t\t\tscope.problemReporter().deprecatedField(fieldBinding, this);", "-\t\tconstant = FieldReference.getConstantFor(binding, this, isImplicitThisRcv, scope);", "+\t\tconstant = FieldReference.getConstantFor(fieldBinding, this, isImplicitThisRcv, scope);", "-\t\tif (binding.isStatic()) {", "+\t\tif (fieldBinding.isStatic()) {", "-\t\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, binding);", "+\t\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, fieldBinding);", "-\t\t\tif (!isImplicitThisRcv && binding.declaringClass != receiverType) {", "-\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, binding);", "+\t\t\tif (!isImplicitThisRcv && fieldBinding.declaringClass != receiverType) {", "+\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, fieldBinding);", "-\t\treturn this.resolvedType = binding.type;", "+\t\t// perform capture conversion if read access", "+\t\treturn this.resolvedType = ", "+\t\t\t(((this.bits & IsStrictlyAssignedMASK) == 0) ", "+\t\t\t\t? fieldBinding.type.capture()", "+\t\t\t\t: fieldBinding.type);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf42a50948e8005fe13f4da0dfd6c30b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "5dba2fb9ff4a65e2ec3c984b606cb269bb911a06", "commitAfterChange": "de6638c19ddd648da6cdf9ca6437e426c1cc8e15", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tthis.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\tthis.receiver.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "-\t\tconstant = Constant.NotAConstant;", "+\t\tthis.constant = Constant.NotAConstant;", "-\tFieldBinding fieldBinding = this.codegenBinding = this.binding = scope.getField(this.receiverType, token, this);", "+\tFieldBinding fieldBinding = this.codegenBinding = this.binding = scope.getField(this.receiverType, this.token, this);", "-\t\tconstant = Constant.NotAConstant;", "+\t\tthis.constant = Constant.NotAConstant;", "-\tif (isFieldUseDeprecated(fieldBinding, scope, (this.bits & IsStrictlyAssigned) !=0)) {", "+\tif (isFieldUseDeprecated(fieldBinding, scope, (this.bits & ASTNode.IsStrictlyAssigned) !=0)) {", "-\tboolean isImplicitThisRcv = receiver.isImplicitThis();", "-\tconstant = isImplicitThisRcv ? fieldBinding.constant() : Constant.NotAConstant;", "+\tboolean isImplicitThisRcv = this.receiver.isImplicitThis();", "+\tthis.constant = isImplicitThisRcv ? fieldBinding.constant() : Constant.NotAConstant;", "-\t\t\t\t|| (receiver instanceof NameReference ", "-\t\t\t\t\t&& (((NameReference) receiver).bits & Binding.TYPE) != 0))) {", "+\t\t\t\t|| (this.receiver instanceof NameReference ", "+\t\t\t\t\t&& (((NameReference) this.receiver).bits & Binding.TYPE) != 0))) {", "+\t\tReferenceBinding declaringClass = this.binding.declaringClass;", "-\t\t\t\t&& fieldBinding.declaringClass != receiverType", "-\t\t\t\t&& fieldBinding.declaringClass.canBeSeenBy(scope)) {", "+\t\t\t\t&& declaringClass != this.receiverType", "+\t\t\t\t&& declaringClass.canBeSeenBy(scope)) {", "+\t\t// check if accessing enum static field in initializer", "+\t\tif (declaringClass.isEnum()) {", "+\t\t\tMethodScope methodScope = scope.methodScope();", "+\t\t\tSourceTypeBinding sourceType = scope.enclosingSourceType();", "+\t\t\tif (this.constant == Constant.NotAConstant", "+\t\t\t\t\t&& !methodScope.isStatic", "+\t\t\t\t\t&& (sourceType == declaringClass || sourceType.superclass == declaringClass) // enum constant body", "+\t\t\t\t\t&& methodScope.isInsideInitializerOrConstructor()) {", "+\t\t\t\tscope.problemReporter().enumStaticFieldUsedDuringInitialization(this.binding, this);", "+\t\t\t}", "+\t\t}\t\t", "-\t\tif ((this.bits & IsStrictlyAssigned) == 0) {", "+\t\tif ((this.bits & ASTNode.IsStrictlyAssigned) == 0) {"]}], "num": 41317}