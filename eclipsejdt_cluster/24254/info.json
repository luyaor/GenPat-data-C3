{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0d8ce4da85411daefa551a75ddb0d8c7", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "40152997f9b8da4149595f484de65d4c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "591b3befccafa73608a18aec511ef48a3ca050bb", "commitAfterChange": "6d7da1254151724e22f25d1be0ba01cba8049f5e", "methodNumberBeforeChange": 236, "methodNumberAfterChange": 288, "signatureBeforeChange": " protected void consumeNestedLambda()", "signatureAfterChange": "  protected void consumeNestedLambda()", "diff": ["-protected void consumeNestedLambda() {", "-\t// NestedLambda ::= $empty", "-\tthis.nestedMethod[this.nestedType] ++;", "-}", "+", "+protected void consumeNestedLambda() {", "+\t// NestedLambda ::= $empty - we get here just after the type+parenthesis elided singleton parameter or just before the '(' of the parameter list. ", "+\tconsumeNestedType();", "+\tthis.nestedMethod[this.nestedType] ++;", "+\tLambdaExpression lambda = new LambdaExpression(this.compilationUnit.compilationResult, this instanceof AssistParser);", "+\tpushOnAstStack(lambda);", "+\tif (this.currentElement != null) {", "+\t\tthis.currentElement = this.currentElement.add(lambda, 0);", "+\t\tthis.lastCheckPoint = this.scanner.currentPosition;", "+\t\tthis.lastIgnoredToken = -1;", "+\t}", "+\tthis.processingLambdaParameterList = true;\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9525e02729621cedde05b93f1b24aab", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "9201dfdd65456845c29d6dc3323aadc8322279d6", "commitAfterChange": "c8ca8bc0ed355b1996bc738eb2798ac55ee50894", "methodNumberBeforeChange": 332, "methodNumberAfterChange": 288, "signatureBeforeChange": " protected void consumeLambdaHeader()", "signatureAfterChange": " protected void consumeLambdaHeader()", "diff": ["+protected void consumeLambdaHeader() {", "+\t// LambdaHeader ::= LambdaParameters '->'  Synthetic/fake production with a synthetic non-terminal. Body not seen yet.", "+\tLambdaExpression lexp = new LambdaExpression(this.compilationUnit.compilationResult, arguments, null, this instanceof AssistParser /* synthesize elided types as needed */);", "+\tlexp.sourceEnd = this.intStack[this.intPtr--];   // ')' position or identifier position.", "+\tpushOnAstStack(lexp);", "+\tpushOnExpressionStack(lexp);", "+\tthis.listLength = 0; // reset this.listLength after having read all parameters", "+}", "-}", "-protected void consumeLambdaHeader() {", "-\t// Overridden in assist parser."]}], "num": 24254}