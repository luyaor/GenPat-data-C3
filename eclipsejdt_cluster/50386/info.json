{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2330989f101820ffce023d469d78cda9", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0db621fe268263bddb94cffe9842c8d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java", "commitBeforeChange": "9fff7ba189be037b4cf4f61956b7e287259b8f6d", "commitAfterChange": "8f52c3e814b7d9e86327e186704f1c7e2be78c75", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t\tint[] sortedIndexes = new int[caseCount];", "-\t\tint[] localKeysCopy;", "-\t\tif ((bits & IsReachableMASK) == 0) {", "-\t\t\treturn;", "-\t\t}", "-\t\tint pc = codeStream.position;", "-", "-\t\t// prepare the labels and constants", "-\t\tbreakLabel.codeStream = codeStream;", "-\t\tCaseLabel[] caseLabels = new CaseLabel[caseCount];", "-\t\tint[] constants = new int[caseCount];", "-\t\tboolean needSwitch = caseCount != 0;", "-\t\tfor (int i = 0; i < caseCount; i++) {", "-\t\t\tconstants[i] = cases[i].constantExpression.constant.intValue();", "-\t\t\tcases[i].targetLabel = (caseLabels[i] = new CaseLabel(codeStream));", "-\t\t}", "-", "-\t\t// we sort the keys to be able to generate the code for tableswitch or lookupswitch", "-\t\tfor (int i = 0; i < caseCount; i++) {", "-\t\t\tsortedIndexes[i] = i;", "-\t\t}", "-\t\tSystem.arraycopy(", "-\t\t\tconstants,", "-\t\t\t0,", "-\t\t\t(localKeysCopy = new int[caseCount]),", "-\t\t\t0,", "-\t\t\tcaseCount);", "-\t\tCodeStream.sort(localKeysCopy, 0, caseCount - 1, sortedIndexes);", "-\t\tCaseLabel defaultLabel = new CaseLabel(codeStream);", "-\t\tif (defaultCase != null) {", "-\t\t\tdefaultCase.targetLabel = defaultLabel;", "-\t\t}", "-\t\t// generate expression testes", "-\t\texpression.generateCode(currentScope, codeStream, needSwitch);", "-", "-\t\t// generate the appropriate switch table/lookup bytecode", "-\t\tif (needSwitch) {", "-\t\t\tint max = localKeysCopy[caseCount - 1];", "-\t\t\tint min = localKeysCopy[0];", "-\t\t\tif ((long) (caseCount * 2.5) > ((long) max - (long) min)) {", "-\t\t\t\t", "-\t\t\t\t// work-around 1.3 VM bug, if max>0x7FFF0000, must use lookup bytecode", "-\t\t\t\t// see http://dev.eclipse.org/bugs/show_bug.cgi?id=21557", "-\t\t\t\tif (max > 0x7FFF0000 && currentScope.environment().options.complianceLevel < ClassFileConstants.JDK1_4) {", "-\t\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "-", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.tableswitch(", "-\t\t\t\t\t\tdefaultLabel,", "-\t\t\t\t\t\tmin,", "-\t\t\t\t\t\tmax,", "-\t\t\t\t\t\tconstants,", "-\t\t\t\t\t\tsortedIndexes,", "-\t\t\t\t\t\tcaseLabels);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "+\t    try {", "+\t\t\tint[] sortedIndexes = new int[caseCount];", "+\t\t\tint[] localKeysCopy;", "+\t\t\tif ((bits & IsReachableMASK) == 0) {", "+\t\t\t\treturn;", "-\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "-\t\t}", "-\t\t", "-\t\t// generate the switch block statements", "-\t\tint caseIndex = 0;", "-\t\tif (statements != null) {", "-\t\t\tfor (int i = 0, maxCases = statements.length; i < maxCases; i++) {", "-\t\t\t\tStatement statement = statements[i];", "-\t\t\t\tif ((caseIndex < caseCount)", "-\t\t\t\t\t&& (statement == cases[caseIndex])) { // statements[i] is a case", "-\t\t\t\t\tif (preSwitchInitStateIndex != -1) {", "-\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tpreSwitchInitStateIndex);", "-\t\t\t\t\t\tcaseIndex++;", "+\t\t\tint pc = codeStream.position;", "+\t", "+\t\t\t// prepare the labels and constants", "+\t\t\tbreakLabel.codeStream = codeStream;", "+\t\t\tCaseLabel[] caseLabels = new CaseLabel[caseCount];", "+\t\t\tint[] constants = new int[caseCount];", "+\t\t\tboolean needSwitch = caseCount != 0;", "+\t\t\tfor (int i = 0; i < caseCount; i++) {", "+\t\t\t\tconstants[i] = cases[i].constantExpression.constant.intValue();", "+\t\t\t\tcases[i].targetLabel = (caseLabels[i] = new CaseLabel(codeStream));", "+\t\t\t}", "+\t", "+\t\t\t// we sort the keys to be able to generate the code for tableswitch or lookupswitch", "+\t\t\tfor (int i = 0; i < caseCount; i++) {", "+\t\t\t\tsortedIndexes[i] = i;", "+\t\t\t}", "+\t\t\tSystem.arraycopy(", "+\t\t\t\tconstants,", "+\t\t\t\t0,", "+\t\t\t\t(localKeysCopy = new int[caseCount]),", "+\t\t\t\t0,", "+\t\t\t\tcaseCount);", "+\t\t\tCodeStream.sort(localKeysCopy, 0, caseCount - 1, sortedIndexes);", "+\t\t\tCaseLabel defaultLabel = new CaseLabel(codeStream);", "+\t\t\tif (defaultCase != null) {", "+\t\t\t\tdefaultCase.targetLabel = defaultLabel;", "+\t\t\t}", "+\t\t\t// generate expression testes", "+\t\t\texpression.generateCode(currentScope, codeStream, needSwitch);", "+\t", "+\t\t\t// generate the appropriate switch table/lookup bytecode", "+\t\t\tif (needSwitch) {", "+\t\t\t\tint max = localKeysCopy[caseCount - 1];", "+\t\t\t\tint min = localKeysCopy[0];", "+\t\t\t\tif ((long) (caseCount * 2.5) > ((long) max - (long) min)) {", "+\t\t\t\t\t", "+\t\t\t\t\t// work-around 1.3 VM bug, if max>0x7FFF0000, must use lookup bytecode", "+\t\t\t\t\t// see http://dev.eclipse.org/bugs/show_bug.cgi?id=21557", "+\t\t\t\t\tif (max > 0x7FFF0000 && currentScope.environment().options.complianceLevel < ClassFileConstants.JDK1_4) {", "+\t\t\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "+\t", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcodeStream.tableswitch(", "+\t\t\t\t\t\t\tdefaultLabel,", "+\t\t\t\t\t\t\tmin,", "+\t\t\t\t\t\t\tmax,", "+\t\t\t\t\t\t\tconstants,", "+\t\t\t\t\t\t\tsortedIndexes,", "+\t\t\t\t\t\t\tcaseLabels);", "-\t\t\t\t\tif (statement == defaultCase) { // statements[i] is a case or a default case", "+\t\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "+\t\t\t\t}", "+\t\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "+\t\t\t}", "+\t\t\t", "+\t\t\t// generate the switch block statements", "+\t\t\tint caseIndex = 0;", "+\t\t\tif (statements != null) {", "+\t\t\t\tfor (int i = 0, maxCases = statements.length; i < maxCases; i++) {", "+\t\t\t\t\tStatement statement = statements[i];", "+\t\t\t\t\tif ((caseIndex < caseCount) && (statement == cases[caseIndex])) { // statements[i] is a case", "+\t\t\t\t\t\tthis.scope.switchCase = cases[caseIndex]; // record entering in a switch case block", "+\t\t\t\t\t\tcaseIndex++;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (statement == defaultCase) { // statements[i] is a case or a default case", "+\t\t\t\t\t\t\tthis.scope.switchCase = defaultCase; // record entering in a switch case block", "+\t\t\t\t\t\t\tif (preSwitchInitStateIndex != -1) {", "+\t\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "+\t\t\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\t\t\tpreSwitchInitStateIndex);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\tstatement.generateCode(scope, codeStream);", "-\t\t\t\tstatement.generateCode(scope, codeStream);", "-\t\t}", "-\t\t// place the trailing labels (for break and default case)", "-\t\tbreakLabel.place();", "-\t\tif (defaultCase == null) {", "-\t\t\tdefaultLabel.place();", "-\t\t}", "-\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\tif (mergedInitStateIndex != -1) {", "-\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "-\t\t\t\tcurrentScope,", "-\t\t\t\tmergedInitStateIndex);", "-\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "-\t\t}", "-\t\tif (scope != currentScope) {", "-\t\t\tcodeStream.exitUserScope(scope);", "-\t\t}", "-\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\t\t\t// place the trailing labels (for break and default case)", "+\t\t\tbreakLabel.place();", "+\t\t\tif (defaultCase == null) {", "+\t\t\t\tdefaultLabel.place();", "+\t\t\t}", "+\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "+\t\t\tif (mergedInitStateIndex != -1) {", "+\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\tmergedInitStateIndex);", "+\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "+\t\t\t}", "+\t\t\tif (scope != currentScope) {", "+\t\t\t\tcodeStream.exitUserScope(scope);", "+\t\t\t}", "+\t\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\t    } finally {", "+\t        if (this.scope != null) this.scope.switchCase = null; // no longer inside switch case block", "+\t    }\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b6b00d60e217dd2ad00f7eacaa266890", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "1b80cae94595518122618b458eed60915f76d171", "commitAfterChange": "92d6141bb346285ff13c588faa5a059cb9f83b3d", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t\tif ((bits & IsReachable) == 0) {", "+\t\tif ((this.bits & ASTNode.IsReachable) == 0) {", "-\t\t\tthis.anyExceptionLabels = NO_EXCEPTION_HANDLER;", "+\t\t\tthis.anyExceptionLabels = SubRoutineStatement.NO_EXCEPTION_HANDLER;", "-\t\tif (subRoutineStartLabel == null) { ", "+\t\tif (this.subRoutineStartLabel == null) { ", "-\t\t\t} else if (scope.compilerOptions().inlineJsrBytecode) {", "+\t\t\t} else if (this.scope.compilerOptions().inlineJsrBytecode) {", "-\t\t\t\tcatchArguments == null ? 0 : catchArguments.length];", "+\t\t\t\tthis.catchArguments == null ? 0 : this.catchArguments.length];", "-\t\t\texceptionLabels[i] = new ExceptionLabel(codeStream, catchArguments[i].binding.type);", "+\t\t\texceptionLabels[i] = new ExceptionLabel(codeStream, this.catchArguments[i].binding.type);", "-\t\tif (subRoutineStartLabel != null) {", "-\t\t\tsubRoutineStartLabel.initialize(codeStream);", "+\t\tif (this.subRoutineStartLabel != null) {", "+\t\t\tthis.subRoutineStartLabel.initialize(codeStream);", "-\t\ttryBlock.generateCode(scope, codeStream);", "+\t\tthis.tryBlock.generateCode(this.scope, codeStream);", "-\t\t\tif (!tryBlockExit) {", "+\t\t\tif (!this.tryBlockExit) {", "-\t\t\t\t\t\tcodeStream.goto_(subRoutineStartLabel);", "+\t\t\t\t\t\tcodeStream.goto_(this.subRoutineStartLabel);", "-\t\t\t\tcodeStream.updateLastRecordedEndPC(tryBlock.scope, position);", "+\t\t\t\tcodeStream.updateLastRecordedEndPC(this.tryBlock.scope, position);", "-\t\t\tif (catchArguments != null) {", "+\t\t\tif (this.catchArguments != null) {", "-\t\t\t\t\tif (preTryInitStateIndex != -1) {", "-\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, preTryInitStateIndex);", "+\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "+\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "-\t\t\t\t\tif ((catchVar = catchArguments[i].binding).resolvedPosition != -1) {", "+\t\t\t\t\tif ((catchVar = this.catchArguments[i].binding).resolvedPosition != -1) {", "-\t\t\t\t\tcodeStream.recordPositionsFrom(varPC, catchArguments[i].sourceStart);", "+\t\t\t\t\tcodeStream.recordPositionsFrom(varPC, this.catchArguments[i].sourceStart);", "-\t\t\t\t\tcatchBlocks[i].generateCode(scope, codeStream);", "-\t\t\t\t\tif (!catchExits[i]) {", "+\t\t\t\t\tthis.catchBlocks[i].generateCode(this.scope, codeStream);", "+\t\t\t\t\tif (!this.catchExits[i]) {", "-\t\t\t\t\t\t\t\tcodeStream.goto_(subRoutineStartLabel);", "+\t\t\t\t\t\t\t\tcodeStream.goto_(this.subRoutineStartLabel);", "-\t\t\tif (subRoutineStartLabel != null) {", "-\t\t\t\tcodeStream.pushOnStack(scope.getJavaLangThrowable());", "-\t\t\t\tif (preTryInitStateIndex != -1) {", "+\t\t\tif (this.subRoutineStartLabel != null) {", "+\t\t\t\tcodeStream.pushOnStack(this.scope.getJavaLangThrowable());", "+\t\t\t\tif (this.preTryInitStateIndex != -1) {", "-\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, preTryInitStateIndex);", "+\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "-\t\t\t\t\t\tcodeStream.store(anyExceptionVariable, false);", "-\t\t\t\t\t\tcodeStream.jsr(subRoutineStartLabel);", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "+\t\t\t\t\t\tcodeStream.store(this.anyExceptionVariable, false);", "+\t\t\t\t\t\tcodeStream.jsr(this.subRoutineStartLabel);", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);", "-\t\t\t\t\t\tcodeStream.throwAnyException(anyExceptionVariable);", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(position, finallyBlock.sourceEnd);", "-\t\t\t\t\t\tsubRoutineStartLabel.place();", "-\t\t\t\t\t\tcodeStream.pushOnStack(scope.getJavaLangThrowable());", "+\t\t\t\t\t\tcodeStream.throwAnyException(this.anyExceptionVariable);", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(position, this.finallyBlock.sourceEnd);", "+\t\t\t\t\t\tthis.subRoutineStartLabel.place();", "+\t\t\t\t\t\tcodeStream.pushOnStack(this.scope.getJavaLangThrowable());", "-\t\t\t\t\t\tcodeStream.store(returnAddressVariable, false);", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(position, finallyBlock.sourceStart);", "-\t\t\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "+\t\t\t\t\t\tcodeStream.store(this.returnAddressVariable, false);", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(position, this.finallyBlock.sourceStart);", "+\t\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "-\t\t\t\t\t\tcodeStream.ret(returnAddressVariable.resolvedPosition);", "+\t\t\t\t\t\tcodeStream.ret(this.returnAddressVariable.resolvedPosition);", "-\t\t\t\t\t\t\tfinallyBlock.sourceEnd);", "+\t\t\t\t\t\t\tthis.finallyBlock.sourceEnd);", "-\t\t\t\t\t\tcodeStream.store(anyExceptionVariable, false);", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "+\t\t\t\t\t\tcodeStream.store(this.anyExceptionVariable, false);", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);", "-\t\t\t\t\t\tcodeStream.throwAnyException(anyExceptionVariable);", "-\t\t\t\t\t\tsubRoutineStartLabel.place();", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(position, finallyBlock.sourceEnd);", "+\t\t\t\t\t\tcodeStream.throwAnyException(this.anyExceptionVariable);", "+\t\t\t\t\t\tthis.subRoutineStartLabel.place();", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(position, this.finallyBlock.sourceEnd);", "-\t\t\t\t\t\tsubRoutineStartLabel.place();", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "-\t\t\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "+\t\t\t\t\t\tthis.subRoutineStartLabel.place();", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);", "+\t\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "-\t\t\t\t\t\t\tcodeStream.jsr(subRoutineStartLabel);", "+\t\t\t\t\t\t\tcodeStream.jsr(this.subRoutineStartLabel);", "-\t\t\t\t\t\t\t\tfinallyBlock.sourceEnd);\t", "+\t\t\t\t\t\t\t\tthis.finallyBlock.sourceEnd);\t", "-\t\t\t\t\t\t\tif (preTryInitStateIndex != -1) {", "-\t\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, preTryInitStateIndex);", "+\t\t\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "+\t\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "-\t\t\t\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "+\t\t\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "-\t\t\tif (subRoutineStartLabel != null) {", "-\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "+\t\t\tif (this.subRoutineStartLabel != null) {", "+\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "-\t\tif (mergedInitStateIndex != -1) {", "-\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "-\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "+\t\tif (this.mergedInitStateIndex != -1) {", "+\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);", "+\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ddcbfd58f5c0089a1d64d08579c7cfbd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "ae980cab0e47f9f9109f15f27f7ea765847cf9bc", "commitAfterChange": "4d657d16dcce8d103534cfb60b4be82696664aa1", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-", "-\t\tif (tryBlock.isEmptyBlock()) {", "-\t\t\tif (subRoutineStartLabel != null) {", "-\t\t\t\t// since not passing the finallyScope, the block generation will exitUserScope(finallyScope)", "-\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "-\t\t\t}", "-\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\t\tif (mergedInitStateIndex != -1) {", "-\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "-\t\t\t\t\tcurrentScope,", "-\t\t\t\t\tmergedInitStateIndex);", "-\t\t\t}", "-\t\t\t// no local bytecode produced so no need for position remembering", "-\t\t\treturn;", "-\t\t}", "-\t\tLabel endLabel = new Label(codeStream);", "-\t\tboolean requiresNaturalJsr = false;", "-", "+\t\tfinal int NoFinally = 0;\t\t\t\t\t\t\t// no finally block", "+\t\tfinal int FinallySubroutine = 1; \t\t\t\t// finally is generated as a subroutine (using jsr/ret bytecodes)", "+\t\tfinal int FinallyDoesNotComplete = 2;\t// non returning finally is optimized with only one instance of finally block", "+\t\tfinal int FinallyMustBeInlined = 3;\t\t\t// finally block must be inlined since cannot use jsr/ret bytecodes >1.5", "+\t\tint finallyMode;", "+\t\tif (subRoutineStartLabel == null) { ", "+\t\t\tfinallyMode = NoFinally;", "+\t\t} else {", "+\t\t\tif (this.isSubRoutineEscaping) {", "+\t\t\t\tfinallyMode = FinallyDoesNotComplete;", "+\t\t\t} else if (scope.environment().options.targetJDK < ClassFileConstants.JDK1_5) {", "+\t\t\t\tfinallyMode = FinallySubroutine;", "+\t\t\t} else {", "+\t\t\t\tfinallyMode = FinallyMustBeInlined;", "+\t\t\t}", "+\t\t}", "+\t\tboolean requiresNaturalExit = false;", "-\t\t// natural exit: only if necessary", "-\t\tboolean nonReturningSubRoutine = subRoutineStartLabel != null && isSubRoutineEscaping; ", "-\t\tif ((!tryBlockExit) && tryBlockHasSomeCode) {", "-\t\t\tint position = codeStream.position;", "-\t\t\tif (nonReturningSubRoutine) {", "-\t\t\t\tcodeStream.goto_(subRoutineStartLabel);", "-\t\t\t} else {", "-\t\t\t\trequiresNaturalJsr = true;", "-\t\t\t\tcodeStream.goto_(endLabel);", "-\t\t\t}", "-\t\t\tcodeStream.updateLastRecordedEndPC(position);", "-\t\t\t//goto is tagged as part of the try block", "-\t\t}", "+\t\t\t// natural exit may require subroutine invocation (if finally != null)", "+\t\t\tLabel naturalExitLabel = new Label(codeStream);", "+\t\t\tif (!tryBlockExit) {", "+\t\t\t\tint position = codeStream.position;", "+\t\t\t\tswitch(finallyMode) {", "+\t\t\t\t\tcase FinallySubroutine :", "+\t\t\t\t\tcase FinallyMustBeInlined :", "+\t\t\t\t\t\trequiresNaturalExit = true;", "+\t\t\t\t\t\t// fall through", "+\t\t\t\t\tcase NoFinally :", "+\t\t\t\t\t\tcodeStream.goto_(naturalExitLabel);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase FinallyDoesNotComplete :", "+\t\t\t\t\t\tcodeStream.goto_(subRoutineStartLabel);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcodeStream.updateLastRecordedEndPC(position);", "+\t\t\t\t//goto is tagged as part of the try block", "+\t\t\t}", "-\t\t\t\t\t\tif (nonReturningSubRoutine) {", "-\t\t\t\t\t\t\tcodeStream.goto_(subRoutineStartLabel);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\trequiresNaturalJsr = true;", "-\t\t\t\t\t\t\tcodeStream.goto_(endLabel);", "+\t\t\t\t\t\tswitch(finallyMode) {", "+\t\t\t\t\t\t\tcase FinallySubroutine :", "+\t\t\t\t\t\t\tcase FinallyMustBeInlined :", "+\t\t\t\t\t\t\t\trequiresNaturalExit = true;", "+\t\t\t\t\t\t\t\t// fall through", "+\t\t\t\t\t\t\tcase NoFinally :", "+\t\t\t\t\t\t\t\tcodeStream.goto_(naturalExitLabel);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase FinallyDoesNotComplete :", "+\t\t\t\t\t\t\t\tcodeStream.goto_(subRoutineStartLabel);", "+\t\t\t\t\t\t\t\tbreak;", "-\t\t\tExceptionLabel naturalExitExceptionHandler = null;", "-\t\t\tif (requiresNaturalJsr) {", "-\t\t\t\tnaturalExitExceptionHandler = this.enterAnyExceptionHandler(codeStream);", "-\t\t\t}", "+\t\t\tExceptionLabel naturalExitExceptionHandler = ", "+\t\t\t\tfinallyMode == FinallySubroutine && requiresNaturalExit ? this.enterAnyExceptionHandler(codeStream) : null;", "-\t\t\t\tif (nonReturningSubRoutine) {", "-\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t\t// \"if subroutine cannot return, no need to jsr/jump to subroutine since it will be entered in sequence", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.store(anyExceptionVariable, false);", "-\t\t\t\t\tcodeStream.jsr(subRoutineStartLabel);", "-\t\t\t\t\tcodeStream.load(anyExceptionVariable);", "-\t\t\t\t\tcodeStream.athrow();", "-\t\t\t\t}", "-\t\t\t\t// end of catch sequence, place label that will correspond to the finally block beginning, or end of statement\t", "-\t\t\t\tsubRoutineStartLabel.place();", "-\t\t\t\tif (!nonReturningSubRoutine) {", "-\t\t\t\t\tcodeStream.incrStackSize(1);", "-\t\t\t\t\tcodeStream.store(returnAddressVariable, false);", "-\t\t\t\t}", "-\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "-\t\t\t\t// entire sequence for finally is associated to finally block", "-\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "-\t\t\t\tif (!nonReturningSubRoutine) {", "-\t\t\t\t\tint position = codeStream.position;", "-\t\t\t\t\tcodeStream.ret(returnAddressVariable.resolvedPosition);", "-\t\t\t\t\tcodeStream.updateLastRecordedEndPC(position);", "-\t\t\t\t\tcodeStream.recordPositionsFrom(", "-\t\t\t\t\t\tposition,", "-\t\t\t\t\t\tfinallyBlock.sourceEnd);", "-\t\t\t\t\t// the ret bytecode is part of the subroutine", "+\t\t\t\tswitch(finallyMode) {", "+\t\t\t\t\t", "+\t\t\t\t\tcase FinallySubroutine :", "+\t\t\t\t\t\tcodeStream.store(anyExceptionVariable, false);", "+\t\t\t\t\t\tcodeStream.jsr(subRoutineStartLabel);", "+\t\t\t\t\t\tcodeStream.load(anyExceptionVariable);", "+\t\t\t\t\t\tcodeStream.athrow();", "+\t\t\t\t\t\tsubRoutineStartLabel.place();", "+\t\t\t\t\t\tcodeStream.incrStackSize(1);", "+\t\t\t\t\t\tcodeStream.store(returnAddressVariable, false);", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "+\t\t\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "+\t\t\t\t\t\tint position = codeStream.position;", "+\t\t\t\t\t\tcodeStream.ret(returnAddressVariable.resolvedPosition);", "+\t\t\t\t\t\tcodeStream.updateLastRecordedEndPC(position);", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(", "+\t\t\t\t\t\t\tposition,", "+\t\t\t\t\t\t\tfinallyBlock.sourceEnd);", "+\t\t\t\t\t\t// the ret bytecode is part of the subroutine", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t", "+\t\t\t\t\tcase FinallyMustBeInlined :", "+\t\t\t\t\t\tcodeStream.store(anyExceptionVariable, false);", "+\t\t\t\t\t\tthis.finallyBlock.generateCode(currentScope, codeStream);", "+\t\t\t\t\t\tcodeStream.load(anyExceptionVariable);", "+\t\t\t\t\t\tcodeStream.athrow();", "+\t\t\t\t\t\tsubRoutineStartLabel.place();", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t", "+\t\t\t\t\tcase FinallyDoesNotComplete :", "+\t\t\t\t\t\tcodeStream.pop();", "+\t\t\t\t\t\tsubRoutineStartLabel.place();", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "+\t\t\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "+\t\t\t\t\t\tbreak;", "-\t\t\t\tendLabel.place();", "-\t\t\t\tif (naturalExitExceptionHandler != null) {", "-\t\t\t\t\tint position = codeStream.position;\t\t\t\t\t", "-\t\t\t\t\t// fix up natural exit handler", "-\t\t\t\t\tnaturalExitExceptionHandler.placeStart();", "-\t\t\t\t\tcodeStream.jsr(subRoutineStartLabel);", "-\t\t\t\t\tnaturalExitExceptionHandler.placeEnd();", "-\t\t\t\t\tcodeStream.recordPositionsFrom(", "-\t\t\t\t\t\tposition,", "-\t\t\t\t\t\tfinallyBlock.sourceStart);\t\t\t\t\t", "+\t\t\t\tnaturalExitLabel.place();", "+\t\t\t\tif (requiresNaturalExit) {", "+\t\t\t\t\tswitch(finallyMode) {", "+", "+\t\t\t\t\t\tcase FinallySubroutine :", "+\t\t\t\t\t\t\tint position = codeStream.position;\t\t\t\t\t", "+\t\t\t\t\t\t\t// fix up natural exit handler", "+\t\t\t\t\t\t\tnaturalExitExceptionHandler.placeStart();", "+\t\t\t\t\t\t\tcodeStream.jsr(subRoutineStartLabel);", "+\t\t\t\t\t\t\tnaturalExitExceptionHandler.placeEnd();", "+\t\t\t\t\t\t\tcodeStream.recordPositionsFrom(", "+\t\t\t\t\t\t\t\tposition,", "+\t\t\t\t\t\t\t\tfinallyBlock.sourceStart);\t\t\t\t\t", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tcase FinallyMustBeInlined :", "+\t\t\t\t\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "+\t\t\t\t\t\t\t// needed since any exception handler got inlined subroutine", "+\t\t\t\t\t\t\tif (preTryInitStateIndex != -1) {", "+\t\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "+\t\t\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\t\t\tpreTryInitStateIndex);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// entire sequence for finally is associated to finally block", "+\t\t\t\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tcase FinallyDoesNotComplete :", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "-\t\t\t\t// no subroutine, simply position end label", "-\t\t\t\tendLabel.place();", "+\t\t\t\t// no subroutine, simply position end label (natural exit == end)", "+\t\t\t\tnaturalExitLabel.place();", "-\t\t\tendLabel.place();"]}], "num": 50386}