{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "566250d3f98bc204c440a6f92adcdfbe", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "61efe28b40cf8a1805a397e6192c9ec0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java", "commitBeforeChange": "a59c911bb67a4a0588e810060c73cd3ec2f53032", "commitAfterChange": "f9b051d5e41bd27efd803711c20da8dcd750758f", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tpublic void set(Map settings)", "signatureAfterChange": "  \tpublic void set(Map settings)", "diff": ["-\t\t}", "-\t\tfinal Object convertOldToNewOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_CONVERT_OLD_TO_NEW);", "-\t\tif (convertOldToNewOption != null) {", "-\t\t\tthis.convert_old_to_new = DefaultCodeFormatterConstants.TRUE.equals(convertOldToNewOption);", "-\t\t// TODO Remove before 3.0", "-\t\tif (this.convert_old_to_new) {", "-\t\t\tfinal Object clearBlankLines = settings.get(JavaCore.FORMATTER_CLEAR_BLANK_LINES);", "-\t\t\tif (clearBlankLines != null) {", "-\t\t\t\tif (JavaCore.CLEAR_ALL.equals(clearBlankLines)) {", "-\t\t\t\t\tthis.number_of_empty_lines_to_preserve = 0;", "-\t\t\t\t} else if (JavaCore.PRESERVE_ONE.equals(clearBlankLines)) {", "-\t\t\t\t\tthis.number_of_empty_lines_to_preserve = 1;", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.number_of_empty_lines_to_preserve = Integer.MAX_VALUE;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tfinal Object compactAssignment = settings.get(JavaCore.FORMATTER_COMPACT_ASSIGNMENT);", "-\t\t\tif (compactAssignment != null) {", "-\t\t\t\tthis.insert_space_before_assignment_operators = JavaCore.NORMAL.equals(compactAssignment);", "-\t\t\t}", "-\t\t\tfinal Object newLineOpenBrace = settings.get(JavaCore.FORMATTER_NEWLINE_OPENING_BRACE);", "-\t\t\tif(newLineOpenBrace != null){", "-\t\t\t\tif (JavaCore.INSERT.equals(newLineOpenBrace)) {", "-\t\t\t\t\tthis.anonymous_type_declaration_brace_position = DefaultCodeFormatterConstants.NEXT_LINE;", "-\t\t\t\t\tthis.type_declaration_brace_position = DefaultCodeFormatterConstants.NEXT_LINE;", "-\t\t\t\t\tthis.method_declaration_brace_position = DefaultCodeFormatterConstants.NEXT_LINE;", "-\t\t\t\t\tthis.block_brace_position = DefaultCodeFormatterConstants.NEXT_LINE;", "-\t\t\t\t\tthis.switch_brace_position = DefaultCodeFormatterConstants.NEXT_LINE;", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.anonymous_type_declaration_brace_position = DefaultCodeFormatterConstants.END_OF_LINE;", "-\t\t\t\t\tthis.type_declaration_brace_position = DefaultCodeFormatterConstants.END_OF_LINE;", "-\t\t\t\t\tthis.method_declaration_brace_position = DefaultCodeFormatterConstants.END_OF_LINE;", "-\t\t\t\t\tthis.block_brace_position = DefaultCodeFormatterConstants.END_OF_LINE;", "-\t\t\t\t\tthis.switch_brace_position = DefaultCodeFormatterConstants.END_OF_LINE;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tfinal Object newLineControl = settings.get(JavaCore.FORMATTER_NEWLINE_CONTROL);", "-\t\t\tif (newLineControl != null) {", "-\t\t\t\tthis.insert_new_line_in_control_statements = JavaCore.INSERT.equals(newLineControl);", "-\t\t\t}", "-\t\t\tfinal Object newLineElseIf  = settings.get(JavaCore.FORMATTER_NEWLINE_ELSE_IF);", "-\t\t\tif (newLineElseIf != null) {", "-\t\t\t\tthis.compact_else_if = JavaCore.DO_NOT_INSERT.equals(newLineElseIf);", "-\t\t\t}", "-\t\t\tfinal Object newLineEmptyBlock  = settings.get(JavaCore.FORMATTER_NEWLINE_EMPTY_BLOCK);", "-\t\t\tif (newLineEmptyBlock != null) {", "-\t\t\t\tif (JavaCore.INSERT.equals(newLineEmptyBlock)) {", "-\t\t\t\t\tthis.insert_new_line_in_empty_anonymous_type_declaration = true;", "-\t\t\t\t\tthis.insert_new_line_in_empty_type_declaration = true;", "-\t\t\t\t\tthis.insert_new_line_in_empty_method_body = true;", "-\t\t\t\t\tthis.insert_new_line_in_empty_block = true;", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.insert_new_line_in_empty_anonymous_type_declaration = false;", "-\t\t\t\t\tthis.insert_new_line_in_empty_type_declaration = false;", "-\t\t\t\t\tthis.insert_new_line_in_empty_method_body = false;", "-\t\t\t\t\tthis.insert_new_line_in_empty_block = false;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tfinal Object castExpression = settings.get(JavaCore.FORMATTER_SPACE_CASTEXPRESSION);", "-\t\t\tif (castExpression != null) {", "-\t\t\t\tthis.insert_space_after_closing_paren_in_cast = JavaCore.INSERT.equals(castExpression);", "-\t\t\t}", "-\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ca2fff865398556b9dcae72621a6eed5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java", "commitBeforeChange": "c9df47e6bc4127d80d1e16ea8353f464e792fda3", "commitAfterChange": "514d8e9afb885d3be64fa67a03a4dd281867840f", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  public MethodBinding getImplicitMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  public MethodBinding getImplicitMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\tboolean insideStaticContext = false;", "-\tboolean insideConstructorCall = false;", "-\tMethodBinding foundMethod = null;", "-\tProblemMethodBinding foundFuzzyProblem = null; // the weird method lookup case (matches method name in scope, then arg types, then visibility)", "-\tProblemMethodBinding foundInsideProblem = null; // inside Constructor call or inside static context", "-\tScope scope = this;", "-\tboolean isExactMatch = true;", "-\tMethodBinding methodBinding =", "-\t\t(foundMethod == null)", "-\t\t\t? findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-\t\t\t: findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-//\t\t\t\t\t\t? findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-//\t\t\t\t\t\t: findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-\tif (methodBinding == null && foundMethod == null) {", "-\t\t// answers closest approximation, may not check argumentTypes or visibility", "-\t\tisExactMatch = false;", "+\tMethodBinding methodBinding = findExactMethod(receiverType, selector, argumentTypes, invocationSite);", "+\tif (methodBinding == null)", "-//\t\t\t\t\tmethodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t}", "-\t\tif (methodBinding.problemId() == ProblemReasons.Ambiguous) {", "-\t\t\tif (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible)", "-\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\treturn methodBinding;", "-\t\t\telse", "-\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\treturn new ProblemMethodBinding(selector, methodBinding.parameters, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t}", "-", "-\t\tProblemMethodBinding fuzzyProblem = null;", "-\t\tProblemMethodBinding insideProblem = null;", "-\t\tif (methodBinding.isValidBinding()) {", "-\t\t\tif (!isExactMatch) {", "-\t    \t    MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-\t\t\t\tif (compatibleMethod == null) {", "-\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\t} else {", "-\t\t\t\t    methodBinding = compatibleMethod;", "-\t\t\t\t    if (!canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this)) {\t", "-\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "-\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotVisible);", "-\t\t\t\t    }", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (fuzzyProblem == null && !methodBinding.isStatic()) {", "-\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\tinsideProblem = new ProblemMethodBinding(methodBinding, methodBinding.selector, methodBinding.parameters, ProblemReasons.NonStaticReferenceInConstructorInvocation);", "-\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\tinsideProblem = new ProblemMethodBinding(methodBinding, methodBinding.selector, methodBinding.parameters, ProblemReasons.NonStaticReferenceInStaticContext);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (receiverType == methodBinding.declaringClass || (receiverType.getMethods(selector)) != Binding.NO_METHODS) {", "-\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t// OR the receiverType implemented a method with the correct name", "-\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (it is inherited)", "-\t\t\t\t\tif (fuzzyProblem != null)", "-\t\t\t\t\t\treturn fuzzyProblem;", "-\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\treturn insideProblem;", "-\t\t\t\t\treturn methodBinding;", "-\t\t\t\t}", "-\t\t\t\t// if a method was found, complain when another is found in an 'immediate' enclosing type (ie. not inherited)", "-\t\t\t\t// NOTE: Unlike fields, a non visible method hides a visible method", "-\t\t\t\tif (foundMethod.declaringClass != methodBinding.declaringClass) // ie. have we found the same method - do not trust field identity yet", "-\t\t\t\t\treturn new ProblemMethodBinding(methodBinding, methodBinding.selector, methodBinding.parameters, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t}", "-\t\t}", "-", "-\t\tif (foundMethod == null || (foundMethod.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() != ProblemReasons.NotVisible)) {", "-\t\t\t// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...", "-\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "-\t\t\tfoundFuzzyProblem = fuzzyProblem;", "-\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\tif (fuzzyProblem == null)", "-\t\t\t\tfoundMethod = methodBinding; // only keep it if no error was found", "-\t\t}", "+\t\tif (methodBinding.isValidBinding())", "+\t\t    if (!canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this))", "+\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotVisible);", "+\t\treturn methodBinding;", "-\tinsideStaticContext |= receiverType.isStatic();", "-\t// 1EX5I8Z - accessing outer fields within a constructor call is permitted", "-\t// in order to do so, we change the flag as we exit from the type, not the method", "-\t// itself, because the class scope is used to retrieve the fields.", "-\tMethodScope enclosingMethodScope = scope.methodScope();", "-\tinsideConstructorCall = enclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "-", "-\tif (foundFuzzyProblem != null)", "-\t\treturn foundFuzzyProblem;", "-\tif (foundInsideProblem != null)", "-\t\treturn foundInsideProblem;", "-\tif (foundMethod != null)", "-\t\treturn foundMethod;"]}], "num": 30433}