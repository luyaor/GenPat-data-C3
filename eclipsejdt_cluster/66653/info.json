{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "76094f47b8944f4adbb1cfb7b9609b30", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a387a888fddf1d531de76635483483d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "9bbf6f5c6011b94aa504d5f2bba9aecfb52bdb59", "commitAfterChange": "948443324097fc0a2f3e65cedca6321b5386663d", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd, boolean samePartCount)", "signatureAfterChange": " public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd, boolean samePartCount)", "diff": ["+\treturn StringOperation.getCamelCaseMatchingRegions(pattern, patternStart, patternEnd, name, nameStart, nameEnd, samePartCount) != null;", "+}", "-\t/* !!!!!!!!!! WARNING !!!!!!!!!!", "-\t * The algorithm of this method has been entirely copied from", "-\t * CharOperation#camelCaseMatch(char[], int, int, char[], int, int, boolean).", "-\t * Array lengths have been replaced with call to {@link String#length()} and", "-\t * array direct access have been replaced with call to {@link String#charAt(int)}.", "-\t *", "-\t * So, do NOT modify this method directly to fix any bug but modify first the", "-\t * corresponding CharOperation method and do the copy again to be sure that", "-\t * these two methods are kept synchronized.", "-\t */", "-", "-\tif (name == null)", "-\t\treturn false; // null name cannot match", "-\tif (pattern == null)", "-\t\treturn true; // null pattern is equivalent to '*'", "-\tif (patternEnd < 0) \tpatternEnd = pattern.length();", "-\tif (nameEnd < 0) nameEnd = name.length();", "-", "-\tif (patternEnd <= patternStart) return nameEnd <= nameStart;", "-\tif (nameEnd <= nameStart) return false;", "-\t// check first pattern char", "-\tif (name.charAt(nameStart) != pattern.charAt(patternStart)) {", "-\t\t// first char must strictly match (upper/lower)", "-\t\treturn false;", "-", "-\tchar patternChar, nameChar;", "-\tint iPattern = patternStart;", "-\tint iName = nameStart;", "-", "-\t// Main loop is on pattern characters", "-\twhile (true) {", "-", "-\t\tiPattern++;", "-\t\tiName++;", "-", "-\t\tif (iPattern == patternEnd) { // we have exhausted pattern...", "-\t\t\t// it's a match if the name can have additional parts (i.e. uppercase characters) or is also exhausted", "-\t\t\tif (!samePartCount || iName == nameEnd) return true;", "-", "-\t\t\t// otherwise it's a match only if the name has no more uppercase characters", "-\t\t\twhile (true) {", "-\t\t\t\tif (iName == nameEnd) {", "-\t\t\t\t\t// we have exhausted the name, so it's a match", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t\tnameChar = name.charAt(iName);", "-\t\t\t\t// test if the name character is uppercase", "-\t\t\t\tif (nameChar < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[nameChar] & ScannerHelper.C_UPPER_LETTER) != 0) {", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\telse if (!Character.isJavaIdentifierPart(nameChar) || Character.isUpperCase(nameChar)) {", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t\tiName++;", "-\t\t}", "-", "-\t\tif (iName == nameEnd){", "-\t\t\t// We have exhausted the name (and not the pattern), so it's not a match", "-\t\t\treturn false;", "-\t\t}", "-", "-\t\t// For as long as we're exactly matching, bring it on (even if it's a lower case character)", "-\t\tif ((patternChar = pattern.charAt(iPattern)) == name.charAt(iName)) {", "-\t\t\tcontinue;", "-\t\t}", "-", "-\t\t// If characters are not equals, then it's not a match if patternChar is lowercase", "-\t\tif (patternChar < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[patternChar] & (ScannerHelper.C_UPPER_LETTER | ScannerHelper.C_DIGIT)) == 0) {", "-\t\t\t\treturn false;", "-\t\t}", "-\t\telse if (Character.isJavaIdentifierPart(patternChar) && !Character.isUpperCase(patternChar) && !Character.isDigit(patternChar)) {", "-\t\t\treturn false;", "-\t\t}", "-", "-\t\t// patternChar is uppercase, so let's find the next uppercase in name", "-\t\twhile (true) {", "-\t\t\tif (iName == nameEnd){", "-\t            //\tWe have exhausted name (and not pattern), so it's not a match", "-\t\t\t\treturn false;", "-", "-\t\t\tnameChar = name.charAt(iName);", "-\t\t\tif (nameChar < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\t\tint charNature = ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[nameChar];", "-\t\t\t\tif ((charNature & (ScannerHelper.C_LOWER_LETTER | ScannerHelper.C_SPECIAL)) != 0) {", "-\t\t\t\t\t// nameChar is lowercase", "-\t\t\t\t\tiName++;", "-\t\t\t\t} else if ((charNature & ScannerHelper.C_DIGIT) != 0) {", "-\t\t\t\t\t// nameChar is digit => break if the digit is current pattern character otherwise consume it", "-\t\t\t\t\tif (patternChar == nameChar) break;", "-\t\t\t\t\tiName++;", "-\t\t\t\t// nameChar is uppercase...", "-\t\t\t\t} else  if (patternChar != nameChar) {", "-\t\t\t\t\t//.. and it does not match patternChar, so it's not a match", "-\t\t\t\t\treturn false;", "-\t\t\t\t} else {", "-\t\t\t\t\t//.. and it matched patternChar. Back to the big loop", "-\t\t\t\t\tbreak;", "-\t\t\t// Same tests for non-obvious characters", "-\t\t\telse if (Character.isJavaIdentifierPart(nameChar) && !Character.isUpperCase(nameChar)) {", "-\t\t\t\tiName++;", "-\t\t\t} else if (Character.isDigit(nameChar)) {", "-\t\t\t\tif (patternChar == nameChar) break;", "-\t\t\t\tiName++;", "-\t\t\t} else  if (patternChar != nameChar) {", "-\t\t\t\treturn false;", "-\t\t\t} else {", "-\t\t\t\tbreak;", "-\t\t}", "-\t\t// At this point, either name has been exhausted, or it is at an uppercase letter.", "-\t\t// Since pattern is also at an uppercase letter"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a280ce0af19a1969ddf2ccecad3a495", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "7bf8b664251457ee19a0ca0f4e524593e5cebbd2", "commitAfterChange": "c844b42e53f5e6c13f3c402081599074b3dd58c2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd)", "signatureAfterChange": " public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd)", "diff": ["-\tif (name == null)", "-\t\treturn false; // null name cannot match", "-\tif (pattern == null)", "-\t\treturn true; // null pattern is equivalent to '*'", "-\tif (patternEnd < 0) \tpatternEnd = pattern.length();", "-\tif (nameEnd < 0) nameEnd = name.length();", "-", "-\tif (patternEnd <= patternStart) return nameEnd <= nameStart;", "-\tif (nameEnd <= nameStart) return false;", "-\t// check first pattern char", "-\tif (name.charAt(nameStart) != pattern.charAt(patternStart)) {", "-\t\t// first char must strictly match (upper/lower)", "-\t\treturn false;", "-\t}", "-", "-\tchar patternChar, nameChar;", "-\tint iPattern = patternStart;", "-\tint iName = nameStart;", "-", "-\t// Main loop is on pattern characters", "-\twhile (true) {", "-", "-\t\tiPattern++;", "-\t\tiName++;", "-", "-\t\tif (iPattern == patternEnd) {", "-\t\t\t// We have exhausted pattern, so it's a match", "-\t\t\treturn true;", "-\t\t}", "-", "-\t\tif (iName == nameEnd){", "-\t\t\t// We have exhausted name (and not pattern), so it's not a match ", "-\t\t\treturn false;", "-\t\t}", "-", "-\t\t// For as long as we're exactly matching, bring it on (even if it's a lower case character)", "-\t\tif ((patternChar = pattern.charAt(iPattern)) == name.charAt(iName)) {", "-\t\t\tcontinue;", "-\t\t}", "-", "-\t\t// If characters are not equals, then it's not a match if patternChar is lowercase", "-\t\tif (patternChar < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[patternChar] & ScannerHelper.C_UPPER_LETTER) == 0) {", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t}", "-\t\telse if (Character.isJavaIdentifierPart(patternChar) && !Character.isUpperCase(patternChar)) {", "-\t\t\treturn false;", "-\t\t}", "-", "-\t\t// patternChar is uppercase, so let's find the next uppercase in name", "-\t\twhile (true) {", "-\t\t\tif (iName == nameEnd){", "-\t            //\tWe have exhausted name (and not pattern), so it's not a match", "-\t\t\t\treturn false;", "-\t\t\t}", "-", "-\t\t\tnameChar = name.charAt(iName);", "-", "-\t\t\tif (nameChar < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[nameChar] & (ScannerHelper.C_LOWER_LETTER | ScannerHelper.C_SPECIAL | ScannerHelper.C_DIGIT)) != 0) {", "-\t\t\t\t\t// nameChar is lowercase    ", "-\t\t\t\t\tiName++;", "-\t\t\t\t// nameChar is uppercase...", "-\t\t\t\t} else  if (patternChar != nameChar) {", "-\t\t\t\t\t//.. and it does not match patternChar, so it's not a match", "-\t\t\t\t\treturn false;", "-\t\t\t\t} else {", "-\t\t\t\t\t//.. and it matched patternChar. Back to the big loop", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\telse if (Character.isJavaIdentifierPart(nameChar) && !Character.isUpperCase(nameChar)) {", "-\t\t\t\t// nameChar is lowercase    ", "-\t\t\t\tiName++;", "-\t\t\t// nameChar is uppercase...", "-\t\t\t} else  if (patternChar != nameChar) {", "-\t\t\t\t//.. and it does not match patternChar, so it's not a match", "-\t\t\t\treturn false;", "-\t\t\t} else {", "-\t\t\t\t//.. and it matched patternChar. Back to the big loop", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\t// At this point, either name has been exhausted, or it is at an uppercase letter.", "-\t\t// Since pattern is also at an uppercase letter", "-\t}", "+\treturn CharOperation.camelCaseMatch(pattern.toCharArray(), patternStart, patternEnd, name.toCharArray(), nameStart, nameEnd);"]}], "num": 66653}