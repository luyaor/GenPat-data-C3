{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0c790b74a8a38f5c38a422adbe679124", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bb522244cba66b55f35a6354921eb9fb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java", "commitBeforeChange": "386973a3070496c014c76dfef6b370eb80aa95d3", "commitAfterChange": "1e351d47b6a42ac5f4bfe0ec77b007aad61afe06", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "\r \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["+\t\t\tthis.generateCode(classScope, classFile, clinitOffset);\r", "+\t\t} catch (AbortMethod e) {\r", "+\t\t\t// should never occur\r", "+\t\t\t// the clinit referenceContext is the type declaration\r", "+\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "+\t\t\t// reset the contentsOffset to the value before generating the clinit code\r", "+\t\t\t// decrement the number of method info as well.\r", "+\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "+\t\t\t// cases.\r", "+\t\t\tif (e.compilationResult == CodeStream.RESTART_IN_WIDE_MODE) {\r", "+\t\t\t\t// a branch target required a goto_w, restart code gen in wide mode.\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tif (statements != null) {\r", "+\t\t\t\t\t\tfor (int i = 0, max = statements.length; i < max; i++)\r", "+\t\t\t\t\t\t\tstatements[i].resetStateForCodeGeneration();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\t\t\t\tclassFile.methodCount--;\r", "+\t\t\t\t\tclassFile.codeStream.wideMode = true; // request wide mode \r", "+\t\t\t\t\tthis.generateCode(classScope, classFile, clinitOffset); // restart method generation\r", "+\t\t\t\t} catch(AbortMethod e2) {\r", "+\t\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\t\t\t\tclassFile.methodCount--;\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\t// produce a problem method accounting for this fatal error\r", "+\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\t\t\tclassFile.methodCount--;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r", "-\t\t} catch (AbortMethod e) {\r", "-\t\t\t// should never occur\r", "-\t\t\t// the clinit referenceContext is the type declaration\r", "-\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "-\t\t\t// reset the contentsOffset to the value before generating the clinit code\r", "-\t\t\t// decrement the number of method info as well.\r", "-\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "-\t\t\t// cases.\r", "-\t\t\tclassFile.contentsOffset = clinitOffset;\r", "-\t\t\tclassFile.methodCount--;\r", "-\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e0f688c611a884efb6ced814efd86b61", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "26e0b0c271d5031424823a1070ef180ba24218bf", "commitAfterChange": "c84496f37e5dff715764911530c1fceaa60b14ee", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void generateCode( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tboolean valueRequired)", "signatureAfterChange": " \tpublic void generateCode( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tboolean valueRequired)", "diff": ["-\t\tLabel falseLabel, endLabel;", "-\t\tbits |= OnlyValueRequired;", "-\t\t\t\t\t\tgenerateOptimizedLogicalAnd(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\t\tnull,", "-\t\t\t\t\t\t\t(falseLabel = new Label(codeStream)),", "-\t\t\t\t\t\t\tvalueRequired);", "-\t\t\t\t\t\t/* improving code gen for such a case: boolean b = i < 0 && false;", "-\t\t\t\t\t\t * since the label has never been used, we have the inlined value on the stack. */", "-\t\t\t\t\t\tif (falseLabel.hasForwardReferences()) {", "-\t\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\t\tcodeStream.iconst_1();", "-\t\t\t\t\t\t\t\tif ((bits & IsReturnedValue) != 0) {", "-\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tcodeStream.goto_(endLabel = new Label(codeStream));", "-\t\t\t\t\t\t\t\t\tcodeStream.decrStackSize(1);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t\tendLabel.place();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tgenerateLogicalAnd(currentScope, codeStream, valueRequired);", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tgenerateOptimizedLogicalOr(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\t\tnull,", "-\t\t\t\t\t\t\t(falseLabel = new Label(codeStream)),", "-\t\t\t\t\t\t\tvalueRequired);", "-\t\t\t\t\t\t/* improving code gen for such a case: boolean b = i < 0 || true;", "-\t\t\t\t\t\t * since the label has never been used, we have the inlined value on the stack. */", "-\t\t\t\t\t\tif (falseLabel.hasForwardReferences()) {", "-\t\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\t\tcodeStream.iconst_1();", "-\t\t\t\t\t\t\t\tif ((bits & IsReturnedValue) != 0) {", "-\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tcodeStream.goto_(endLabel = new Label(codeStream));", "-\t\t\t\t\t\t\t\t\tcodeStream.decrStackSize(1);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t\tendLabel.place();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tgenerateLogicalOr(currentScope, codeStream, valueRequired);", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tgenerateOptimizedLogicalXor(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\t\tnull,", "-\t\t\t\t\t\t\t(falseLabel = new Label(codeStream)),", "-\t\t\t\t\t\t\tvalueRequired);", "-\t\t\t\t\t\t/* improving code gen for such a case: boolean b = i < 0 ^ bool;", "-\t\t\t\t\t\t * since the label has never been used, we have the inlined value on the stack. */", "-\t\t\t\t\t\tif (falseLabel.hasForwardReferences()) {", "-\t\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\t\tcodeStream.iconst_1();", "-\t\t\t\t\t\t\t\tif ((bits & IsReturnedValue) != 0) {", "-\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tcodeStream.goto_(endLabel = new Label(codeStream));", "-\t\t\t\t\t\t\t\t\tcodeStream.decrStackSize(1);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t\tendLabel.place();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tgenerateLogicalXor(currentScope, \tcodeStream, valueRequired);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\tLabel falseLabel, endLabel;"]}], "num": 53946}