{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "986ad585db19640af9dcb79e6d139395", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "27ec0ab4527252dfd5add3614aed8f43", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceTests.java", "commitBeforeChange": "3916c67b0128c74e08a07f109332d68e11705964", "commitAfterChange": "db24d1d0025b319685ad3bf80253e7a07fb708a2", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t\t\tpublic void run(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \t\tpublic boolean accept(File project)", "diff": ["+\tclass FullSourceProjectsFilter implements FileFilter {", "+\t\tpublic boolean accept(File project) {", "+\t\t\tif (project.isDirectory()) {", "+\t\t\t\tStringTokenizer tokenizer = new StringTokenizer(project.getName(), \".\");", "+\t\t\t\tString token = tokenizer.nextToken();", "+\t\t\t\tif (token.equals(\"org\") && tokenizer.hasMoreTokens()) {", "+\t\t\t\t\ttoken = tokenizer.nextToken();", "+\t\t\t\t\tif (token.equals(\"junit\") && !tokenizer.hasMoreTokens()) {", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (token.equals(\"apache\")) {", "+\t\t\t\t\t\ttoken = tokenizer.nextToken();", "+\t\t\t\t\t\tif (token.equals(\"ant\") || token.equals(\"lucene\")) {", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (token.equals(\"eclipse\") && tokenizer.hasMoreTokens()) {", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn false;", "+\t\t}", "-\t\tworkspace.run(new IWorkspaceRunnable() {", "-\t\t\tpublic void run(IProgressMonitor monitor) throws CoreException {", "-\t\t\t\tFile targetWorkspaceDir = new File(targetWorkspacePath);", "-\t\t\t\tString[] projectNames = targetWorkspaceDir.list();", "-\t\t\t\tfor (int i = 0, length = projectNames.length; i < length; i++) {", "-\t\t\t\t\tString projectName = projectNames[i];", "-\t\t\t\t\tif (\".metadata\".equals(projectName)) continue;", "-\t\t\t\t\tIProject project = workspaceRoot.getProject(projectName);", "-\t\t\t\t\tproject.create(monitor);", "-\t\t\t\t\tproject.open(monitor);", "-\t\t\t\t}", "-\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2c7e7748b2e66c7f20d695dc91127193", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java", "commitBeforeChange": "808ee1989aa546fef406f77c37a96f979df5219f", "commitAfterChange": "2528937997399f978f8c04c6800f46f957dbd27f", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 6, "signatureBeforeChange": " public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd)", "signatureAfterChange": " public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd, boolean prefixMatch)", "diff": ["+ */", "+public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd, boolean prefixMatch) {", "-\t\tif (iPattern == patternEnd) {", "-\t\t\t// We have exhausted pattern, so it's a match", "-\t\t\treturn true;", "+\t\tif (iPattern == patternEnd) { // we have exhausted pattern...", "+\t\t\t// it's a match if not exact mode or name is also exhausted", "+\t\t\tif (prefixMatch || iName == nameEnd) return true;", "+", "+\t\t\t// it's not a match if last pattern character is a lowercase", "+\t\t\tif ((patternChar = pattern[iPattern-1]) < ScannerHelper.MAX_OBVIOUS) {", "+\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[patternChar] & (ScannerHelper.C_UPPER_LETTER | ScannerHelper.C_DIGIT)) == 0) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\telse if (Character.isJavaIdentifierPart(patternChar) && !Character.isUpperCase(patternChar) && !Character.isDigit(patternChar)) {", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\t// it's a match only if name has no more uppercase characters (exact mode)", "+\t\t\twhile (true) {", "+\t\t\t\tif (iName == nameEnd) {", "+\t\t\t\t\t// we have exhausted name, so it's a match", "+\t\t\t\t\treturn true;", "+\t\t\t\t}", "+\t\t\t\tnameChar = name[iName];", "+\t\t\t\tif (nameChar < ScannerHelper.MAX_OBVIOUS) {", "+\t\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[nameChar] & ScannerHelper.C_UPPER_LETTER) != 0) {", "+\t\t\t\t\t\t// nameChar is uppercase, so it's not a match", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\telse if (!Character.isJavaIdentifierPart(nameChar) || Character.isUpperCase(nameChar)) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tiName++;", "+\t\t\t}"]}], "num": 31446}