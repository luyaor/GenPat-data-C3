{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d425554bf4ce84973a0b5ab55c042121", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "41c83435c905f2d73318431490fe2882", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "b64f224a477bcbe9ca6144dc3c1b296938ab0569", "commitAfterChange": "e2a464122cca0e168e5e6a45c115970b861f3e3d", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": "\r \tprivate void findMethods(\r \t\tchar[] selector,\r \t\tTypeBinding[] argTypes,\r \t\tReferenceBinding receiverType,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \t\tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tboolean isCompletingDeclaration,\r \t\tInvocationSite invocationSite,\r \t\tScope invocationScope,\r \t\tboolean implicitCall)", "signatureAfterChange": "\r \tprivate void findMethods(\r \t\tchar[] selector,\r \t\tTypeBinding[] argTypes,\r \t\tReferenceBinding receiverType,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \t\tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tboolean isCompletingDeclaration,\r \t\tInvocationSite invocationSite,\r \t\tScope invocationScope,\r \t\tboolean implicitCall)", "diff": ["-\r", "-\t\t\t\r", "+\t\t\r", "+\t\tif(isCompletingDeclaration) {\r", "+\t\t\tMethodBinding[] methods = receiverType.availableMethods();\r", "+\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "+\t\t\t\tif(!methods[i].isDefaultAbstract()) {\r", "+\t\t\t\t\tmethodsFound.add(methods[i]);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\t\r", "-\r", "-\r", "-\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e9ab22000b0d63ac7a2cf2516f5d8e5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "1b4ae3c306349bc12b5bd14c0b0208197346f4fe", "commitAfterChange": "e411de6de610f4a41b2ca5b35274818572448e41", "methodNumberBeforeChange": 141, "methodNumberAfterChange": 141, "signatureBeforeChange": " public static TypeBinding getConstantPoolDeclaringClass(Scope currentScope, MethodBinding codegenBinding, TypeBinding actualReceiverType, boolean isImplicitThisReceiver)", "signatureAfterChange": " public static TypeBinding getConstantPoolDeclaringClass(Scope currentScope, MethodBinding codegenBinding, TypeBinding actualReceiverType, boolean isImplicitThisReceiver)", "diff": ["-\t\t\t\tif (!actualReceiverType.isIntersectionType18()) // no constant pool representation. FIXME, visibility issue not handled.", "+\t\t\t\tif (actualReceiverType.isIntersectionType18()) {", "+\t\t\t\t\tTypeBinding[] intersectingTypes = ((IntersectionTypeBinding18)actualReceiverType).getIntersectingTypes();", "+\t\t\t\t\tfor(int i = 0; i < intersectingTypes.length; i++) {", "+\t\t\t\t\t\tif (intersectingTypes[i].findSuperTypeOriginatingFrom(constantPoolDeclaringClass) != null) {", "+\t\t\t\t\t\t\tconstantPoolDeclaringClass = intersectingTypes[i];", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bba61dbe226d96215e77df0b38b5ed00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java", "commitBeforeChange": "7186c730d487753734b0547672e890b50fededb4", "commitAfterChange": "7ceb7b86e5d2c6d0639c543a0b8998dc4ed1502e", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tboolean incorporate(InferenceContext18 context) throws InferenceFailureException", "signatureAfterChange": " \tboolean incorporate(InferenceContext18 context) throws InferenceFailureException", "diff": ["+\t\t\t\t\t\t// TODO here and below: better checking if constraint really added to the boundset (optimization)?", "+\t\t\t\t\t}", "+\t\t\t\t\tConstraintFormula[] typeArgumentConstraints = deriveTypeArgumentConstraints(boundI, boundJ);", "+\t\t\t\t\tif (typeArgumentConstraints != null) {", "+\t\t\t\t\t\tfor (int k = 0; k < typeArgumentConstraints.length; k++) {", "+\t\t\t\t\t\t\tif (!reduceOneConstraint(context, typeArgumentConstraints[k]))", "+\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\thasUpdate = true;", "+\t\t\t\t\t\t}"]}], "num": 64422}