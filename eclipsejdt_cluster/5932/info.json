{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d2a0851cd500b4cdc25e7286b71d3f30", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "530dfa69748e200ec430314a9b5933e0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "20ebda4b91a2d1bbceacbc52f4461a1082458d8e", "commitAfterChange": "800101f8c8d6360d176bce00478df3375a46d057", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 26, "signatureBeforeChange": "\r public static char[] toCharArray(char[] methodSignature, char[] methodName, char[][] parameterNames, boolean fullyQualifyTypeNames, boolean includeReturnType)", "signatureAfterChange": "\r public static char[] toCharArray(char[] methodSignature, char[] methodName, char[][] parameterNames, boolean fullyQualifyTypeNames, boolean includeReturnType)", "diff": ["-\tint length = parameterNames.length;\r", "-\tString[] parameters = new String[length];\r", "-\tfor (int i=0;i<length;i++) {\r", "-\t\tparameters[i] = new String(parameterNames[i]);\r", "-\t}\r", "-\treturn toString(new String(methodSignature), new String(methodName), parameters, fullyQualifyTypeNames, includeReturnType).toCharArray();\r", "-\t/*\r", "-\t\r", "+\t\tint firstParen = CharOperation.indexOf(C_PARAM_START, methodSignature);\r", "+\t\tif (firstParen == -1) throw new IllegalArgumentException();\r", "+\t\t\r", "+\t\tint paramCount = 0;\r", "-\t\tsignature: for (int i = 0; i < sigLength; i++) {", "+\t\tsignature: for (int i = firstParen; i < sigLength; i++) {", "-\t\t\t\t\tresultLength += 2;\r", "-\t\t\t\t\tbreak;\r", "+\t\t\t\t\tresultLength += 2; // []\r", "+\t\t\t\t\tcontinue signature;\r", "-\t\t\t\t\tresultLength += 7; // boolean\r", "+\t\t\t\t\tresultLength += BOOLEAN.length;\r", "-\t\t\t\t\tresultLength += 4; // byte\r", "+\t\t\t\t\tresultLength += BYTE.length;\r", "-\t\t\t\t\tresultLength += 4; // char\r", "+\t\t\t\t\tresultLength += CHAR.length;\r", "-\t\t\t\t\tresultLength += 6; // double\r", "+\t\t\t\t\tresultLength += DOUBLE.length;\r", "-\t\t\t\t\tresultLength += 5; // float\r", "+\t\t\t\t\tresultLength += FLOAT.length;\r", "-\t\t\t\t\tresultLength += 3; // int\r", "+\t\t\t\t\tresultLength += INT.length;\r", "-\t\t\t\t\tresultLength += 4; // long\r", "+\t\t\t\t\tresultLength += LONG.length;\r", "-\t\t\t\t\tresultLength += 5; // short\r", "+\t\t\t\t\tresultLength += SHORT.length;\r", "-\t\t\t\t\tresultLength += 4; // void\r", "+\t\t\t\t\tresultLength += VOID.length;\r", "-\t\t\t\t\t\tstart = CharOperation.lastIndexOf(C_DOT, methodSignature, i, end);\r", "+\t\t\t\t\t\tstart = CharOperation.lastIndexOf(C_DOT, methodSignature, i, end)+1;\r", "-\t\t\t\t\tresultLength++; // space for \"(\"\r", "-\t\t\t\t\tbreak;\r", "+\t\t\t\t\t// add space for \"(\"\r", "+\t\t\t\t\tresultLength++;\r", "+\t\t\t\t\tcontinue signature;\r", "-\t\t\t\t\t\t// remove space for \", \" that was added with last parameter and add space for \") \"\r", "-\t\t\t\t\t\t// -> noop\r", "-\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t// remove space for \", \" that was added with last parameter and remove space that is going to be added for \", \" after return type \r", "+\t\t\t\t\t\t// and add space for \") \"\r", "+\t\t\t\t\t\tresultLength -= 2;\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\t\t// decrement param count because it is going to be added for return type\r", "+\t\t\t\t\t\tparamCount--;\r", "+\t\t\t\t\t\tcontinue signature;\r", "+\t\t\tparamCount++;\r", "-\t\tint parameterNamesLength = parameterNames.length;\r", "+\t\tint parameterNamesLength = parameterNames == null ? 0 : parameterNames.length;\r", "-\t\t// remove last space\r", "-\t\tif (parameterNamesLength > 0) resultLength--;\r", "+\t\t\r", "+\t\t// selector\r", "+\t\tint selectorLength = methodName == null ? 0 : methodName.length;\r", "+\t\tresultLength += selectorLength;\r", "+\t\tint index = 0;\r", "-\t\t\tint arrayCount = 0;\r", "-\t\t\tfor (int i = lastParen+1; i < sigLength; i++) {\r", "-\t\t\t\tswitch (methodSignature[i]) {\r", "-\t\t\t\t\tcase C_ARRAY :\r", "-\t\t\t\t\t\tarrayCount++;\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase C_BOOLEAN :\r", "-\t\t\t\t\t\tresultLength += 7; // boolean\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase C_BYTE :\r", "-\t\t\t\t\t\tresultLength += 4; // byte\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase C_CHAR :\r", "-\t\t\t\t\t\tresultLength += 4; // char\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase C_DOUBLE :\r", "-\t\t\t\t\t\tresultLength += 6; // double\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase C_FLOAT :\r", "-\t\t\t\t\t\tresultLength += 5; // float\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase C_INT :\r", "-\t\t\t\t\t\tresultLength += 3; // int\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase C_LONG :\r", "-\t\t\t\t\t\tresultLength += 4; // long\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase C_SHORT :\r", "-\t\t\t\t\t\tresultLength += 5; // short\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase C_VOID :\r", "-\t\t\t\t\t\tresultLength += 4; // void\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\tcase C_RESOLVED :\r", "-\t\t\t\t\tcase C_UNRESOLVED :\r", "-\t\t\t\t\t\tint end = CharOperation.indexOf(C_SEMICOLON, methodSignature, i);\r", "-\t\t\t\t\t\tif (end == -1) throw new IllegalArgumentException();\r", "-\t\t\t\t\t\tint start;\r", "-\t\t\t\t\t\tif (fullyQualifyTypeNames) {\r", "-\t\t\t\t\t\t\tstart = i+1;\r", "-\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\tstart = CharOperation.lastIndexOf(C_DOT, methodSignature, i, end);\r", "-\t\t\t\t\t\t\tif (start == -1) start = i+1;\r", "-\t\t\t\t\t\t} \r", "-\t\t\t\t\t\tresultLength += end-start;\r", "-\t\t\t\t\t\ti = end;\r", "-\t\t\t\t\t\tbreak;\r", "-\t\t\t\t}\r", "+\t\t\tlong pos = copyType(methodSignature, lastParen+1, result, index, fullyQualifyTypeNames);\r", "+\t\t\tindex = (int) (pos >>> 32);\r", "+\t\t\tresult[index++] = ' ';\r", "+\t\t}\r", "+\t\t\r", "+\t\t// selector\r", "+\t\tif (methodName != null) {\r", "+\t\t\tSystem.arraycopy(methodName, 0, result, index, selectorLength);\r", "+\t\t\tindex += selectorLength;\r", "+\t\t}\r", "+\t\t\r", "+\t\t// parameters\r", "+\t\tresult[index++] = C_PARAM_START;\r", "+\t\tint sigPos = firstParen+1;\r", "+\t\tfor (int i = 0; i < paramCount; i++) {", "+\t\t\tlong pos = copyType(methodSignature, sigPos, result, index, fullyQualifyTypeNames);\r", "+\t\t\tindex = (int) (pos >>> 32);", "+\t\t\tsigPos = (int)pos;\r", "+\t\t\tif (parameterNames != null) {\r", "+\t\t\t\tresult[index++] = ' ';\r", "+\t\t\t\tchar[] parameterName = parameterNames[i];\r", "+\t\t\t\tint paramLength = parameterName.length;\r", "+\t\t\t\tSystem.arraycopy(parameterName, 0, result, index, paramLength);\r", "+\t\t\t\tindex += paramLength;\r", "-\t\t\t\r", "+\t\t\tif (i != paramCount-1) {\r", "+\t\t\t\tresult[index++] = ',';\r", "+\t\t\t\tresult[index++] = ' ';\r", "+\t\t\t}", "-\t\r", "-\t\tint count = getParameterCount(methodSignature);\r", "-\t\tchar[][] result = new char[count][];\r", "-\t\tif (count == 0)\r", "-\t\t\treturn result;\r", "-\t\tint i = CharOperation.indexOf(C_PARAM_START, methodSignature) + 1;\r", "-\t\tcount = 0;\r", "-\t\tint start = i;\r", "-\t\tfor (;;) {\r", "-\t\t\tchar c = methodSignature[i++];\r", "-\t\t\tswitch (c) {\r", "-\t\t\t\tcase C_ARRAY :\r", "-\t\t\t\t\t// array depth is i - start;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase C_BOOLEAN :\r", "-\t\t\t\tcase C_BYTE :\r", "-\t\t\t\tcase C_CHAR :\r", "-\t\t\t\tcase C_DOUBLE :\r", "-\t\t\t\tcase C_FLOAT :\r", "-\t\t\t\tcase C_INT :\r", "-\t\t\t\tcase C_LONG :\r", "-\t\t\t\tcase C_SHORT :\r", "-\t\t\t\tcase C_VOID :\r", "-\t\t\t\t\t// common case of base types\r", "-\t\t\t\t\tif (i - start == 1) {\r", "-\t\t\t\t\t\tswitch (c) {\r", "-\t\t\t\t\t\t\tcase C_BOOLEAN :\r", "-\t\t\t\t\t\t\t\tresult[count++] = new char[] {C_BOOLEAN};\r", "-\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\tcase C_BYTE :\r", "-\t\t\t\t\t\t\t\tresult[count++] = new char[] {C_BYTE};\r", "-\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\tcase C_CHAR :\r", "-\t\t\t\t\t\t\t\tresult[count++] = new char[] {C_CHAR};\r", "-\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\tcase C_DOUBLE :\r", "-\t\t\t\t\t\t\t\tresult[count++] = new char[] {C_DOUBLE};\r", "-\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\tcase C_FLOAT :\r", "-\t\t\t\t\t\t\t\tresult[count++] = new char[] {C_FLOAT};\r", "-\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\tcase C_INT :\r", "-\t\t\t\t\t\t\t\tresult[count++] = new char[] {C_INT};\r", "-\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\tcase C_LONG :\r", "-\t\t\t\t\t\t\t\tresult[count++] = new char[] {C_LONG};\r", "-\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\tcase C_SHORT :\r", "-\t\t\t\t\t\t\t\tresult[count++] = new char[] {C_SHORT};\r", "-\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\tcase C_VOID :\r", "-\t\t\t\t\t\t\t\tresult[count++] = new char[] {C_VOID};\r", "-\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tresult[count++] = CharOperation.subarray(methodSignature, start, i);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tstart = i;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase C_RESOLVED :\r", "-\t\t\t\tcase C_UNRESOLVED :\r", "-\t\t\t\t\ti = CharOperation.indexOf(C_SEMICOLON, methodSignature, i) + 1;\r", "-\t\t\t\t\tif (i == 0)\r", "-\t\t\t\t\t\tthrow new IllegalArgumentException();\r", "-\t\t\t\t\tresult[count++] = CharOperation.subarray(methodSignature, start, i);\r", "-\t\t\t\t\tstart = i;\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase C_PARAM_END:\r", "-\t\t\t\t\treturn result;\r", "-\t\t\t\tdefault :\r", "-\t\t\t\t\tthrow new IllegalArgumentException();\r", "-\t\t\t}\r", "+\t\tif (sigPos >= sigLength) {\r", "+\t\t\tthrow new IllegalArgumentException(); // should be on last paren\r", "-\t\r", "-\tStringBuffer sb = new StringBuffer();\r", "-\tString[] paramTypes = getParameterTypes(methodSignature);\r", "-\tif (includeReturnType) {\r", "-\t\tString returnType = getReturnType(methodSignature);\r", "-\t\tif (returnType.length() != 0) {\r", "-\t\t\treturnType = toString(returnType);\r", "-\t\t\tif (!fullyQualifyTypeNames) {\r", "-\t\t\t\tint lastDot = returnType.lastIndexOf(C_DOT);\r", "-\t\t\t\tif (lastDot != -1) {\r", "-\t\t\t\t\treturnType = returnType.substring(lastDot + 1);\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tsb.append(returnType);\r", "-\t\t\tsb.append(' ');\r", "-\t\t}\r", "-\t}\r", "-\tif (methodName != null)\r", "-\t\tsb.append(methodName);\r", "-\tsb.append(C_PARAM_START);\r", "-\tfor (int i = 0; i < paramTypes.length; ++i) {\r", "-\t\tif (i != 0)\r", "-\t\t\tsb.append(\", \"); //$NON-NLS-1$\r", "-\t\tString readableParamType = toString(paramTypes[i]);\r", "-\t\tif (!fullyQualifyTypeNames) {\r", "-\t\t\tint lastDot = readableParamType.lastIndexOf(C_DOT);\r", "-\t\t\tif (lastDot != -1) {\r", "-\t\t\t\treadableParamType = readableParamType.substring(lastDot + 1);\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\tsb.append(readableParamType);\r", "-\t\tif (parameterNames != null) {\r", "-\t\t\tsb.append(' ');\r", "-\t\t\tsb.append(parameterNames[i]);\r", "-\t\t}\r", "-\t}\r", "-\tsb.append(C_PARAM_END);\r", "-\treturn sb.toString();\r", "-\t*/\r", "+\t\tresult[index++] = C_PARAM_END;\r", "+\t\t\r", "+\t\treturn result;\r", "+\t} catch (ArrayIndexOutOfBoundsException e) {\r", "+\t\tthrow new IllegalArgumentException();\r", "+\t}\t\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d759a80fb8a6b52ae0a715abd408ec3c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "03e37ed5506ed50fa30b9f5aa42ff423995a94bd", "commitAfterChange": "4111f058addae7e2d753cc95bd7546b1f787e4c8", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 42, "signatureBeforeChange": " public static char[] toCharArray( \t\tchar[] methodSignature, \t\tchar[] methodName, \t\tchar[][] parameterNames, \t\tboolean fullyQualifyTypeNames, \t\tboolean includeReturnType, \t\tboolean includeFormalTypeParameters, \t\tboolean includeThrownExceptions)", "signatureAfterChange": " private static int appendTypeArgumentSignatures(char[] string, int start, boolean fullyQualifyTypeNames, StringBuffer buffer)", "diff": ["- */", "-public static char[] toCharArray(", "-\t\tchar[] methodSignature,", "-\t\tchar[] methodName,", "-\t\tchar[][] parameterNames,", "-\t\tboolean fullyQualifyTypeNames,", "-\t\tboolean includeReturnType,", "-\t\tboolean includeFormalTypeParameters,", "-\t\tboolean includeThrownExceptions) {", "-\t// TODO (jeem) - needs to handle includeFormalTypeParameters and includeThrownExceptions", "-\ttry {", "-\t\tint firstParen = CharOperation.indexOf(C_PARAM_START, methodSignature);", "-\t\tif (firstParen == -1) throw new IllegalArgumentException();", "-\t\t", "-\t\tint sigLength = methodSignature.length;", "-\t\t", "-\t\t// compute result length", "-\t\t", "-\t\t// method signature", "-\t\tint paramCount = 0;", "-\t\tint lastParen = -1;", "-\t\tint resultLength = 0;", "-\t\tsignature: for (int i = firstParen; i < sigLength; i++) {", "-\t\t\tswitch (methodSignature[i]) {", "-\t\t\t\tcase C_ARRAY :", "-\t\t\t\t\tresultLength += 2; // []", "-\t\t\t\t\tcontinue signature;", "-\t\t\t\tcase C_BOOLEAN :", "-\t\t\t\t\tresultLength += BOOLEAN.length;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase C_BYTE :", "-\t\t\t\t\tresultLength += BYTE.length;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase C_CHAR :", "-\t\t\t\t\tresultLength += CHAR.length;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase C_DOUBLE :", "-\t\t\t\t\tresultLength += DOUBLE.length;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase C_FLOAT :", "-\t\t\t\t\tresultLength += FLOAT.length;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase C_INT :", "-\t\t\t\t\tresultLength += INT.length;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase C_LONG :", "-\t\t\t\t\tresultLength += LONG.length;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase C_SHORT :", "-\t\t\t\t\tresultLength += SHORT.length;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase C_VOID :", "-\t\t\t\t\tresultLength += VOID.length;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase C_RESOLVED :", "-\t\t\t\tcase C_UNRESOLVED :", "-\t\t\t\t\tint end = CharOperation.indexOf(C_SEMICOLON, methodSignature, i);", "-\t\t\t\t\tif (end == -1) throw new IllegalArgumentException();", "-\t\t\t\t\tint start;", "-\t\t\t\t\tif (fullyQualifyTypeNames) {", "-\t\t\t\t\t\tstart = i+1;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tstart = CharOperation.lastIndexOf(C_DOT, methodSignature, i, end) + 1;", "-\t\t\t\t\t\tif (start == 0) start = i+1;", "-\t\t\t\t\t} ", "-\t\t\t\t\tresultLength += end-start;", "-\t\t\t\t\ti = end;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase C_PARAM_START :", "-\t\t\t\t\t// add space for \"(\"", "-\t\t\t\t\tresultLength++;", "-\t\t\t\t\tcontinue signature;", "-\t\t\t\tcase C_PARAM_END :", "-\t\t\t\t\tlastParen = i;", "-\t\t\t\t\tif (includeReturnType) {", "-\t\t\t\t\t\tif (paramCount > 0) {", "-\t\t\t\t\t\t\t// remove space for \", \" that was added with last parameter and remove space that is going to be added for \", \" after return type ", "-\t\t\t\t\t\t\t// and add space for \") \"", "-\t\t\t\t\t\t\tresultLength -= 2;", "-\t\t\t\t\t\t} //else", "-\t\t\t\t\t\t\t// remove space that is going to be added for \", \" after return type ", "-\t\t\t\t\t\t\t// and add space for \") \"", "-\t\t\t\t\t\t\t// -> noop", "-\t\t\t\t\t\t", "-\t\t\t\t\t\t// decrement param count because it is going to be added for return type", "-\t\t\t\t\t\tparamCount--;", "-\t\t\t\t\t\tcontinue signature;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (paramCount > 0) {", "-\t\t\t\t\t\t\t// remove space for \", \" that was added with last parameter and add space for \")\"", "-\t\t\t\t\t\t\tresultLength--;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t// add space for \")\"", "-\t\t\t\t\t\t\tresultLength++;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak signature;", "-\t\t\t\t\t}", "-\t\t\t\tdefault :", "-\t\t\t\t\tthrow new IllegalArgumentException();", "-\t\t\t}", "-\t\t\tresultLength += 2; // add space for \", \"", "-\t\t\tparamCount++;", "-\t\t}", "-\t\t", "-\t\t// parameter names", "-\t\tint parameterNamesLength = parameterNames == null ? 0 : parameterNames.length;", "-\t\tfor (int i = 0; i <parameterNamesLength; i++) {", "-\t\t\tresultLength += parameterNames[i].length + 1; // parameter name + space", "-\t\t}", "-\t\t", "-\t\t// selector", "-\t\tint selectorLength = methodName == null ? 0 : methodName.length;", "-\t\tresultLength += selectorLength;", "-\t\t", "-\t\t// create resulting char array", "-\t\tchar[] result = new char[resultLength];", "-\t\t", "-\t\t// returned type", "-\t\tint index = 0;", "-\t\tif (includeReturnType) {", "-\t\t\tlong pos = copyType(methodSignature, lastParen+1, result, index, fullyQualifyTypeNames);", "-\t\t\tindex = (int) (pos >>> 32);", "-\t\t\tresult[index++] = ' ';", "-\t\t}", "-\t\t", "-\t\t// selector", "-\t\tif (methodName != null) {", "-\t\t\tSystem.arraycopy(methodName, 0, result, index, selectorLength);", "-\t\t\tindex += selectorLength;", "-\t\t}", "-\t\t", "-\t\t// parameters", "-\t\tresult[index++] = C_PARAM_START;", "-\t\tint sigPos = firstParen+1;", "-\t\tfor (int i = 0; i < paramCount; i++) {", "-\t\t\tlong pos = copyType(methodSignature, sigPos, result, index, fullyQualifyTypeNames);", "-\t\t\tindex = (int) (pos >>> 32);", "-\t\t\tsigPos = (int)pos;", "-\t\t\tif (parameterNames != null) {", "-\t\t\t\tresult[index++] = ' ';", "-\t\t\t\tchar[] parameterName = parameterNames[i];", "-\t\t\t\tint paramLength = parameterName.length;", "-\t\t\t\tSystem.arraycopy(parameterName, 0, result, index, paramLength);", "-\t\t\t\tindex += paramLength;", "-\t\t\t}", "-\t\t\tif (i != paramCount-1) {", "-\t\t\t\tresult[index++] = ',';", "-\t\t\t\tresult[index++] = ' ';", "-\t\t\t}", "-\t\t}", "-\t\tif (sigPos >= sigLength) {", "-\t\t\tthrow new IllegalArgumentException(); // should be on last paren", "-\t\t}", "-\t\tresult[index++] = C_PARAM_END;", "-\t\t", "-\t\treturn result;", "-\t} catch (ArrayIndexOutOfBoundsException e) {", "-\t}\t\t", "+ */", "+private static int appendTypeArgumentSignatures(char[] string, int start, boolean fullyQualifyTypeNames, StringBuffer buffer) {", "+\t// need a minimum 2 char \"<>\"", "+\tif (start >= string.length - 1) {", "+\t\tthrow new IllegalArgumentException();", "+\t}", "+\tchar c = string[start];", "+\tif (c != C_GENERIC_START) {", "+\t\tthrow new IllegalArgumentException();", "+\t}", "+\tbuffer.append('<');", "+\tint p = start + 1;", "+\tint count = 0;", "+\twhile (true) {", "+\t\tif (p >= string.length) {", "+\t\t\tthrow new IllegalArgumentException();", "+\t\t}", "+\t\tc = string[p];", "+\t\tif (c == C_GENERIC_END) {", "+\t\t\tbuffer.append('>');", "+\t\t\treturn p;", "+\t\t}", "+\t\tif (count != 0) {", "+\t\t\tbuffer.append(',');", "+\t\t}", "+\t\tint e = appendTypeArgumentSignature(string, p, fullyQualifyTypeNames, buffer);", "+\t\tcount++;", "+\t\tp = e + 1;", "+\t}", "+}"]}], "num": 5932}