{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "09a1dfa69ba8bdd586fc3510d61d2db6", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c80b5a608256fb1b16b94878dfc4195f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "a708a833352a17a462cbe9e9346d660fa6317a1e", "commitAfterChange": "0e8e783b8823e467b82792c7ef9289caad32e202", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 75, "signatureBeforeChange": "  \tprivate void printJavadocImmutableText(FormatJavadocText text, FormatJavadocBlock block, boolean textOnNewLine)", "signatureAfterChange": "  \tprivate void printJavadocImmutableText(FormatJavadocText text, FormatJavadocBlock block, boolean textOnNewLine)", "diff": ["-\t\t\tStringBuffer buffer = null;", "+\t\t\tString newLineString = null;", "-\t\t\t\t\tif (buffer == null) {", "-\t\t\t\t\t\tbuffer = new StringBuffer();", "+\t\t\t\t\tif (newLineString == null) {", "+\t\t\t\t\t\tthis.tempBuffer.setLength(0);", "-\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "-\t\t\t\t\t\tbuffer.append(BLOCK_LINE_PREFIX);", "+\t\t\t\t\t\tprintIndentationIfNecessary(this.tempBuffer);", "+\t\t\t\t\t\tthis.tempBuffer.append(BLOCK_LINE_PREFIX);", "+\t\t\t\t\t\tnewLineString = this.tempBuffer.toString();", "-\t\t\t\t\taddReplaceEdit(end+1, this.scanner.getCurrentTokenEndPosition(), buffer.toString());", "+\t\t\t\t\taddReplaceEdit(end+1, this.scanner.getCurrentTokenEndPosition(), newLineString);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f6aaf6a0a0d6bb7b659579e5afe87efa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "fc8ba03f9916b4ab5a789fe72fe040f0a158e1e5", "commitAfterChange": "6dec51f3a3503c4d8924810ab83aa422e394cac6", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "signatureAfterChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "diff": ["-\t\t\tIBinaryMethod[] methods = reader.getMethods();", "-\t\t\tif (methods != null) {", "-\t\t\t\t// build arguments names", "-\t\t\t\tboolean firstIsSynthetic = false;", "-\t\t\t\tif (reader.isMember() && method.isConstructor() && !Flags.isStatic(reader.getModifiers())) { // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=48261", "-\t\t\t\t\tfirstIsSynthetic = true;", "-\t\t\t\t\targCount++;", "-\t\t\t\t}", "-\t\t\t\tchar[][] argumentTypeNames = new char[argCount][];", "-\t\t\t\tfor (int i = 0; i < argCount; i++) {", "-\t\t\t\t\tchar[] typeName = null;", "-\t\t\t\t\tif (i == 0 && firstIsSynthetic) {", "-\t\t\t\t\t\ttypeName = type.getDeclaringType().getFullyQualifiedName().toCharArray();", "-\t\t\t\t\t} else if (arguments != null) {", "-\t\t\t\t\t\tTypeReference typeRef = arguments[firstIsSynthetic ? i - 1 : i].type;", "-\t\t\t\t\t\ttypeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "-\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "-\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "-\t\t\t\t\t}", "-\t\t\t\t\tif (typeName == null) {", "-\t\t\t\t\t\t// invalid type name", "-\t\t\t\t\t\treturn null;", "-\t\t\t\t\t}", "-\t\t\t\t\targumentTypeNames[i] = typeName;", "-\t\t\t\t}", "-", "-\t\t\t\t// return binary method", "-\t\t\t\tIMethod binaryMethod = createBinaryMethodHandle(type, method.selector, argumentTypeNames);", "-\t\t\t\tif (binaryMethod == null) {", "-\t\t\t\t\t// when first attempt fails, try with similar matches if any...", "-\t\t\t\t\tPossibleMatch similarMatch = this.currentPossibleMatch.getSimilarMatch();", "-\t\t\t\t\twhile (similarMatch != null) {", "-\t\t\t\t\t\ttype = ((ClassFile)similarMatch.openable).getType();", "-\t\t\t\t\t\tbinaryMethod = createBinaryMethodHandle(type, method.selector, argumentTypeNames);", "-\t\t\t\t\t\tif (binaryMethod != null) {", "-\t\t\t\t\t\t\treturn binaryMethod;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tsimilarMatch = similarMatch.getSimilarMatch();", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\treturn binaryMethod;", "+\t\t\t// build arguments names", "+\t\t\tboolean firstIsSynthetic = false;", "+\t\t\tif (reader.isMember() && method.isConstructor() && !Flags.isStatic(reader.getModifiers())) { // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=48261", "+\t\t\t\tfirstIsSynthetic = true;", "+\t\t\t\targCount++;", "+\t\t\tchar[][] argumentTypeNames = new char[argCount][];", "+\t\t\tfor (int i = 0; i < argCount; i++) {", "+\t\t\t\tchar[] typeName = null;", "+\t\t\t\tif (i == 0 && firstIsSynthetic) {", "+\t\t\t\t\ttypeName = type.getDeclaringType().getFullyQualifiedName().toCharArray();", "+\t\t\t\t} else if (arguments != null) {", "+\t\t\t\t\tTypeReference typeRef = arguments[firstIsSynthetic ? i - 1 : i].type;", "+\t\t\t\t\ttypeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "+\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "+\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t\t}", "+\t\t\t\tif (typeName == null) {", "+\t\t\t\t\t// invalid type name", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t\targumentTypeNames[i] = typeName;", "+\t\t\t}", "+\t\t\t// return binary method", "+\t\t\tIMethod binaryMethod = createBinaryMethodHandle(type, method.selector, argumentTypeNames);", "+\t\t\tif (binaryMethod == null) {", "+\t\t\t\t// when first attempt fails, try with similar matches if any...", "+\t\t\t\tPossibleMatch similarMatch = this.currentPossibleMatch.getSimilarMatch();", "+\t\t\t\twhile (similarMatch != null) {", "+\t\t\t\t\ttype = ((ClassFile)similarMatch.openable).getType();", "+\t\t\t\t\tbinaryMethod = createBinaryMethodHandle(type, method.selector, argumentTypeNames);", "+\t\t\t\t\tif (binaryMethod != null) {", "+\t\t\t\t\t\treturn binaryMethod;", "+\t\t\t\t\t}", "+\t\t\t\t\tsimilarMatch = similarMatch.getSimilarMatch();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn binaryMethod;", "+\t\t}", "+\t\tif (BasicSearchEngine.VERBOSE) {", "+\t\t\tSystem.out.println(\"Not able to createHandle for the method \" + //$NON-NLS-1$", "+\t\t\t\t\tCharOperation.charToString(method.selector) + \" May miss some results\");  //$NON-NLS-1$"]}], "num": 44338}