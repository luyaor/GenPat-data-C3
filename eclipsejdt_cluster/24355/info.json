{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dbd509271efc65f0f29acade69b9526e", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ddcd5718531d31a902653c3012e7bf69", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "a2999324910e04c9c4d68f1aa93d5053c047f21c", "commitAfterChange": "a3d873b0829375e0f0465ac99af6f9753248e839", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tsynchronized ITypeBinding resolveExpressionType(Expression expression)", "signatureAfterChange": " \tsynchronized ITypeBinding resolveExpressionType(Expression expression)", "diff": ["-\t\tif (expression instanceof ClassInstanceCreation) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode astNode = (org.eclipse.jdt.internal.compiler.ast.ASTNode) this.newAstToOldAst.get(expression);", "-\t\t\tif (astNode instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {", "-\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) astNode;", "-\t\t\t\tif (typeDeclaration != null) {", "-\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding(typeDeclaration.binding);", "-\t\t\t\t\tif (typeBinding == null) {", "-\t\t\t\t\t\treturn null;", "+\t\tswitch(expression.getNodeType()) {", "+\t\t\tcase ASTNode.CLASS_INSTANCE_CREATION : ", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode astNode = (org.eclipse.jdt.internal.compiler.ast.ASTNode) this.newAstToOldAst.get(expression);", "+\t\t\t\tif (astNode instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {", "+\t\t\t\t\t// anonymous type case", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) astNode;", "+\t\t\t\t\tif (typeDeclaration != null) {", "+\t\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding(typeDeclaration.binding);", "+\t\t\t\t\t\tif (typeBinding == null) {", "+\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn typeBinding;", "-\t\t\t\t\treturn typeBinding;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t// should be an AllocationExpression", "-\t\t\t\tAllocationExpression allocationExpression = (AllocationExpression) astNode;", "-\t\t\t\tIMethodBinding methodBinding = this.getMethodBinding(allocationExpression.binding);", "-\t\t\t\tif (methodBinding == null) {", "-\t\t\t\t\treturn null;", "-\t\t\t\t\treturn methodBinding.getDeclaringClass();", "+\t\t\t\t\t// should be an AllocationExpression", "+\t\t\t\t\tAllocationExpression allocationExpression = (AllocationExpression) astNode;", "+\t\t\t\t\treturn this.getTypeBinding(allocationExpression.resolvedType);", "-\t\t\t}", "-\t\t} else if (expression instanceof Name) {", "-\t\t\tIBinding binding = this.resolveName((Name) expression);", "-\t\t\tif (binding == null) {", "-\t\t\t}", "-\t\t\tswitch(binding.getKind()) {", "-\t\t\t\tcase IBinding.TYPE :", "-\t\t\t\t\treturn (ITypeBinding) binding;", "-\t\t\t\tcase IBinding.VARIABLE :", "-\t\t\t\t\treturn ((IVariableBinding) binding).getType();", "-\t\t\t\tcase IBinding.METHOD :", "-\t\t\t\t\treturn ((IMethodBinding) binding).getReturnType();", "-\t\t\t}", "-\t\t} else if (expression instanceof ArrayInitializer) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.ArrayInitializer oldAst = (org.eclipse.jdt.internal.compiler.ast.ArrayInitializer) this.newAstToOldAst.get(expression);", "-\t\t\tif (oldAst == null || oldAst.binding == null) {", "+\t\t\tcase ASTNode.SIMPLE_NAME :", "+\t\t\tcase ASTNode.QUALIFIED_NAME :", "+\t\t\t\treturn this.resolveTypeBindingForName((Name) expression);", "+\t\t\tcase ASTNode.ARRAY_INITIALIZER :", "+\t\t\tcase ASTNode.ARRAY_CREATION :", "+\t\t\tcase ASTNode.ASSIGNMENT :\t\t\t\t", "+\t\t\tcase ASTNode.POSTFIX_EXPRESSION : ", "+\t\t\tcase ASTNode.PREFIX_EXPRESSION :", "+\t\t\tcase ASTNode.CAST_EXPRESSION :", "+\t\t\tcase ASTNode.TYPE_LITERAL :", "+\t\t\tcase ASTNode.INFIX_EXPRESSION :", "+\t\t\tcase ASTNode.INSTANCEOF_EXPRESSION :", "+\t\t\tcase ASTNode.FIELD_ACCESS :", "+\t\t\tcase ASTNode.SUPER_FIELD_ACCESS :", "+\t\t\tcase ASTNode.ARRAY_ACCESS :", "+\t\t\tcase ASTNode.METHOD_INVOCATION :", "+\t\t\tcase ASTNode.SUPER_METHOD_INVOCATION :", "+\t\t\tcase ASTNode.CONDITIONAL_EXPRESSION : ", "+\t\t\tcase ASTNode.MARKER_ANNOTATION : ", "+\t\t\tcase ASTNode.NORMAL_ANNOTATION :", "+\t\t\tcase ASTNode.SINGLE_MEMBER_ANNOTATION :", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression compilerExpression = (org.eclipse.jdt.internal.compiler.ast.Expression) this.newAstToOldAst.get(expression);", "+\t\t\t\tif (compilerExpression == null) {", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t\treturn this.getTypeBinding(compilerExpression.resolvedType);", "+\t\t\tcase ASTNode.STRING_LITERAL :", "+\t\t\t\treturn this.getTypeBinding(this.scope.getJavaLangString());", "+\t\t\tcase ASTNode.BOOLEAN_LITERAL :", "+\t\t\tcase ASTNode.NULL_LITERAL : ", "+\t\t\tcase ASTNode.CHARACTER_LITERAL :", "+\t\t\tcase ASTNode.NUMBER_LITERAL :", "+\t\t\t\tLiteral literal = (Literal) this.newAstToOldAst.get(expression);", "+\t\t\t\treturn this.getTypeBinding(literal.literalType(null));", "+\t\t\tcase ASTNode.THIS_EXPRESSION :", "+\t\t\t\tThisReference thisReference = (ThisReference) this.newAstToOldAst.get(expression);", "+\t\t\t\tBlockScope blockScope = (BlockScope) this.astNodesToBlockScope.get(expression);", "+\t\t\t\tif (blockScope == null) {", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t\treturn this.getTypeBinding(thisReference.resolveType(blockScope));", "+\t\t\tcase ASTNode.PARENTHESIZED_EXPRESSION :", "+\t\t\t\tParenthesizedExpression parenthesizedExpression = (ParenthesizedExpression) expression;", "+\t\t\t\treturn this.resolveExpressionType(parenthesizedExpression.getExpression());", "+\t\t\tcase ASTNode.VARIABLE_DECLARATION_EXPRESSION :", "+\t\t\t\tVariableDeclarationExpression variableDeclarationExpression = (VariableDeclarationExpression) expression;", "+\t\t\t\tType type = variableDeclarationExpression.getType();", "+\t\t\t\tif (type != null) {", "+\t\t\t\t\treturn type.resolveBinding();", "+\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn this.getTypeBinding(oldAst.binding);", "-\t\t} else if (expression instanceof ArrayCreation) {", "-\t\t\tArrayAllocationExpression arrayAllocationExpression = (ArrayAllocationExpression) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(arrayAllocationExpression.resolvedType);", "-\t\t} else if (expression instanceof Assignment) {", "-\t\t\tAssignment assignment = (Assignment) expression;", "-\t\t\treturn this.resolveExpressionType(assignment.getLeftHandSide());", "-\t\t} else if (expression instanceof PostfixExpression) {", "-\t\t\tPostfixExpression postFixExpression = (PostfixExpression) expression;", "-\t\t\treturn this.resolveExpressionType(postFixExpression.getOperand());", "-\t\t} else if (expression instanceof PrefixExpression) {", "-\t\t\tPrefixExpression preFixExpression = (PrefixExpression) expression;", "-\t\t\treturn this.resolveExpressionType(preFixExpression.getOperand());", "-\t\t} else if (expression instanceof CastExpression) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.CastExpression castExpression = (org.eclipse.jdt.internal.compiler.ast.CastExpression) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(castExpression.resolvedType);", "-\t\t} else if (expression instanceof StringLiteral) {", "-\t\t\treturn this.getTypeBinding(this.scope.getJavaLangString());", "-\t\t} else if (expression instanceof TypeLiteral) {", "-\t\t\tClassLiteralAccess classLiteralAccess = (ClassLiteralAccess) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(classLiteralAccess.resolvedType);", "-\t\t} else if (expression instanceof BooleanLiteral) {", "-\t\t\tBooleanLiteral booleanLiteral = (BooleanLiteral) expression;", "-\t\t\tif (booleanLiteral.booleanValue()) {", "-\t\t\t\tTrueLiteral trueLiteral = (TrueLiteral) this.newAstToOldAst.get(booleanLiteral);", "-\t\t\t\treturn this.getTypeBinding(trueLiteral.literalType(null));", "-\t\t\t} else {", "-\t\t\t\tFalseLiteral falseLiteral = (FalseLiteral) this.newAstToOldAst.get(booleanLiteral);", "-\t\t\t\treturn this.getTypeBinding(falseLiteral.literalType(null));", "-\t\t\t}", "-\t\t} else if (expression instanceof NullLiteral) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.NullLiteral nullLiteral = (org.eclipse.jdt.internal.compiler.ast.NullLiteral) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(nullLiteral.literalType(null));", "-\t\t} else if (expression instanceof CharacterLiteral) {", "-\t\t\tCharLiteral charLiteral = (CharLiteral) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(charLiteral.literalType(null));", "-\t\t} else if (expression instanceof NumberLiteral) {", "-\t\t\tLiteral literal = (Literal) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(literal.literalType(null));", "-\t\t} else if (expression instanceof InfixExpression) {", "-\t\t\tObject node = this.newAstToOldAst.get(expression);", "-\t\t\tif (node instanceof OperatorExpression) {", "-\t\t\t\tOperatorExpression operatorExpression = (OperatorExpression) node;", "-\t\t\t\treturn this.getTypeBinding(operatorExpression.resolvedType);", "-\t\t\t} else if (node instanceof StringLiteralConcatenation) {", "-\t\t\t\tStringLiteralConcatenation stringLiteralConcatenation = (StringLiteralConcatenation) node;", "-\t\t\t\treturn this.getTypeBinding(stringLiteralConcatenation.resolvedType);", "-\t\t\t}", "-\t\t} else if (expression instanceof InstanceofExpression) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.InstanceOfExpression instanceOfExpression = (org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(instanceOfExpression.resolvedType);", "-\t\t} else if (expression instanceof FieldAccess) {", "-\t\t\tFieldReference fieldReference = (FieldReference) this.newAstToOldAst.get(expression);", "-\t\t\tIVariableBinding variableBinding = this.getVariableBinding(fieldReference.binding);", "-\t\t\tif (variableBinding == null) {", "+\t\t\tdefault: ", "-\t\t\t} else {", "-\t\t\t\treturn variableBinding.getType();", "-\t\t\t}", "-\t\t} else if (expression instanceof SuperFieldAccess) {", "-\t\t\tFieldReference fieldReference = (FieldReference) this.newAstToOldAst.get(expression);", "-\t\t\tIVariableBinding variableBinding = this.getVariableBinding(fieldReference.binding);", "-\t\t\tif (variableBinding == null) {", "-\t\t\t\treturn null;", "-\t\t\t} else {", "-\t\t\t\treturn variableBinding.getType();", "-\t\t\t}", "-\t\t} else if (expression instanceof ArrayAccess) {", "-\t\t\tArrayReference arrayReference = (ArrayReference) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(arrayReference.resolvedType);", "-\t\t} else if (expression instanceof ThisExpression) {", "-\t\t\tThisReference thisReference = (ThisReference) this.newAstToOldAst.get(expression);", "-\t\t\tBlockScope blockScope = (BlockScope) this.astNodesToBlockScope.get(expression);", "-\t\t\tif (blockScope == null) {", "-\t\t\t\treturn null;", "-\t\t\t}", "-\t\t\treturn this.getTypeBinding(thisReference.resolveType(blockScope));", "-\t\t} else if (expression instanceof MethodInvocation", "-\t\t\t\t|| expression instanceof SuperMethodInvocation) {", "-\t\t\tMessageSend messageSend = (MessageSend)  this.newAstToOldAst.get(expression);", "-\t\t\tIMethodBinding methodBinding = this.getMethodBinding(messageSend.binding);", "-\t\t\tif (methodBinding == null) {", "-\t\t\t\treturn null;", "-\t\t\t} else {", "-\t\t\t\treturn methodBinding.getReturnType();", "-\t\t\t}", "-\t\t} else if (expression instanceof ParenthesizedExpression) {", "-\t\t\tParenthesizedExpression parenthesizedExpression = (ParenthesizedExpression) expression;", "-\t\t\treturn this.resolveExpressionType(parenthesizedExpression.getExpression());", "-\t\t} else if (expression instanceof ConditionalExpression) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.ConditionalExpression conditionalExpression = (org.eclipse.jdt.internal.compiler.ast.ConditionalExpression) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(conditionalExpression.resolvedType);", "-\t\t} else if (expression instanceof VariableDeclarationExpression) {", "-\t\t\tVariableDeclarationExpression variableDeclarationExpression = (VariableDeclarationExpression) expression;", "-\t\t\tType type = variableDeclarationExpression.getType();", "-\t\t\tif (type != null) {", "-\t\t\t\treturn type.resolveBinding();", "-\t\t\t}", "-\t\t} else if (expression instanceof MarkerAnnotation) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.MarkerAnnotation markerAnnotation = (org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(markerAnnotation.resolvedType);", "-\t\t} else if (expression instanceof NormalAnnotation) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.NormalAnnotation normalAnnotation = (org.eclipse.jdt.internal.compiler.ast.NormalAnnotation) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(normalAnnotation.resolvedType);", "-\t\t} else if (expression instanceof SingleMemberAnnotation) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation singleMemberAnnotation = (org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation) this.newAstToOldAst.get(expression);", "-\t\t\treturn this.getTypeBinding(singleMemberAnnotation.resolvedType);", "-\t\treturn null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ee2968cc6b7f54c341ed12d1ef32bf1f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java", "commitBeforeChange": "0492d8e41c1aba4d81d43f5d644f4506ed10c8ab", "commitAfterChange": "cbb80b4c969d064367ed598ba99f074660c726c6", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tboolean incorporate(InferenceContext18 context) throws InferenceFailureException", "signatureAfterChange": " \tboolean incorporate(InferenceContext18 context) throws InferenceFailureException", "diff": ["+\t// Driver for the real workhorse - Implements generational incorporation a la generational garbage collector. ", "+\tboolean incorporate(InferenceContext18 context) throws InferenceFailureException {", "+\t\t", "+\t\tif (this.unincorporatedBoundsCount == 0 && this.captures.size() == 0)", "+\t\t\treturn true;", "+\t\t", "+\t\tdo {", "+\t\t\tTypeBound [] freshBounds;", "+\t\t\tSystem.arraycopy(this.unincorporatedBounds, 0, freshBounds = new TypeBound[this.unincorporatedBoundsCount], 0, this.unincorporatedBoundsCount);", "+\t\t\tthis.unincorporatedBoundsCount = 0;", "+\t\t\t", "+\t\t\t// Pairwise bidirectional compare all bounds from previous generation with the fresh set.", "+\t\t\tif (!incorporate(context, this.incorporatedBounds, freshBounds))", "+\t\t\t\treturn false;", "+\t\t\t// Pairwise bidirectional compare all fresh bounds. ", "+\t\t\tif (!incorporate(context, freshBounds, freshBounds))", "+\t\t\t\treturn false;", "+\t\t\tthis.captures.clear();", "+\t\t\t", "+\t\t\t// Merge the bounds into one incorporated generation.", "+\t\t\tfinal int incorporatedLength = this.incorporatedBounds.length;", "+\t\t\tfinal int unincorporatedLength = freshBounds.length;", "+\t\t\tTypeBound [] aggregate = new TypeBound[incorporatedLength + unincorporatedLength];", "+\t\t\tSystem.arraycopy(this.incorporatedBounds, 0, aggregate, 0, incorporatedLength);", "+\t\t\tSystem.arraycopy(freshBounds, 0, aggregate, incorporatedLength, unincorporatedLength);", "+\t\t\tthis.incorporatedBounds = aggregate;", "+\t\t\t", "+\t\t} while (this.unincorporatedBoundsCount > 0);", "+\t\t", "+\t\treturn true;", "+\t}", "-\tboolean incorporate(InferenceContext18 context) throws InferenceFailureException {", "-\t\tif (this.isIncorporated)", "-\t\t\treturn true;", "-\t\tdo {", "-\t\t\tthis.isIncorporated = true;", "-\t\t\t// using a flattened copy also allows us to insert more bounds during the process", "-\t\t\t// without disturbing the current round of incorporation:", "-\t\t\tTypeBound[] bounds = flatten();", "-\t\t\tint boundsCount = bounds.length;", "-\t\t\tif (boundsCount < 2)", "-\t\t\t\treturn true;", "-\t\t\t// check each pair:", "-\t\t\tfor (int i = 0; i < boundsCount; i++) {", "-\t\t\t\tTypeBound boundI = bounds[i];", "-\t\t\t\tfinal boolean setHasI = boundI.id < this.incorporatedBounds.length && this.incorporatedBounds[boundI.id] == true;", "-\t\t\t\tfor (int j = i+1; j < boundsCount; j++) {", "-\t\t\t\t\tTypeBound boundJ = bounds[j];", "-\t\t\t\t\tif (setHasI && boundJ.id < this.incorporatedBounds.length && this.incorporatedBounds[boundJ.id] == true)", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t}", "-\t\t\t\tif (!setHasI) {", "-\t\t\t\t\tint length = this.incorporatedBounds.length;", "-\t\t\t\t\tif (boundI.id >= length)", "-\t\t\t\t\t\tSystem.arraycopy(this.incorporatedBounds, 0, this.incorporatedBounds = new boolean[boundI.id * 2], 0, length);", "-\t\t\t\t\tthis.incorporatedBounds[boundI.id] = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t/* TODO: are we sure this will always terminate? Cf. e.g. (Discussion in 18.3):", "-\t\t\t *  ", "-\t\t\t *    \"The assertion that incorporation reaches a fixed point oversimplifies the matter slightly. ...\"", "-\t\t\t */", "-\t\t\tIterator<Entry<ParameterizedTypeBinding, ParameterizedTypeBinding>> captIter = this.captures.entrySet().iterator();", "-\t\t\twhile (captIter.hasNext()) {", "-\t\t\t\tEntry<ParameterizedTypeBinding, ParameterizedTypeBinding> capt = captIter.next();", "-\t\t\t\tParameterizedTypeBinding gAlpha = capt.getKey();", "-\t\t\t\tParameterizedTypeBinding gA = capt.getValue();", "-\t\t\t\tReferenceBinding g = (ReferenceBinding) gA.original();", "-\t\t\t\tfinal TypeVariableBinding[] parameters = g.typeVariables();", "-\t\t\t\t// construct theta = [P1:=alpha1,...]", "-\t\t\t\tfinal InferenceVariable[] alphas = new InferenceVariable[gAlpha.arguments.length];", "-\t\t\t\tSystem.arraycopy(gAlpha.arguments, 0, alphas, 0, alphas.length);", "-\t\t\t\tInferenceSubstitution theta = new InferenceSubstitution(context.environment, alphas) {", "-\t\t\t\t\t@Override", "-\t\t\t\t\tprotected TypeBinding getP(int i) {", "-\t\t\t\t\t\treturn parameters[i];", "-\t\t\t\t};", "-\t\t\t\tfor (int i = 0, length = parameters.length; i < length; i++) {", "-\t\t\t\t\t// A set of bounds on \u03b11, ..., \u03b1n, constructed from the declared bounds of P1, ..., Pn as described in 18.1.3, is immediately implied.", "-\t\t\t\t\tTypeVariableBinding pi = parameters[i];", "-\t\t\t\t\tInferenceVariable alpha = (InferenceVariable) gAlpha.arguments[i];", "-\t\t\t\t\taddBounds(pi.getTypeBounds(alpha, theta), context.environment);", "-\t\t\t\t\tTypeBinding ai = gA.arguments[i];", "-\t\t\t\t\tif (ai instanceof WildcardBinding) {", "-\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding)ai;", "-\t\t\t\t\t\tTypeBinding t = wildcardBinding.bound;", "-\t\t\t\t\t\tThreeSets three = this.boundsPerVariable.get(alpha.prototype());", "-\t\t\t\t\t\tif (three != null) {", "-\t\t\t\t\t\t\tIterator<TypeBound> it;", "-\t\t\t\t\t\t\tif (three.sameBounds != null) {", "-\t\t\t\t\t\t\t\t//  \u03b1 = R implies false", "-\t\t\t\t\t\t\t\tit = three.sameBounds.iterator();", "-\t\t\t\t\t\t\t\twhile (it.hasNext()) {", "-\t\t\t\t\t\t\t\t\tTypeBound bound = it.next();", "-\t\t\t\t\t\t\t\t\tif (!(bound.right instanceof InferenceVariable))", "-\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (three.subBounds != null && pi.firstBound != null) {", "-\t\t\t\t\t\t\t\t// If Bi is Object, \u03b1 <: R implies \u27e8T <: R\u27e9\t(extends wildcard)", "-\t\t\t\t\t\t\t\t// \u03b1 <: R implies \u27e8\u03b8 Bi <: R\u27e9\t\t\t\t(else) ", "-\t\t\t\t\t\t\t\tit = three.subBounds.iterator();", "-\t\t\t\t\t\t\t\twhile (it.hasNext()) {", "-\t\t\t\t\t\t\t\t\tTypeBound bound = it.next();", "-\t\t\t\t\t\t\t\t\tif (!(bound.right instanceof InferenceVariable)) {", "-\t\t\t\t\t\t\t\t\t\tTypeBinding r = bound.right;", "-\t\t\t\t\t\t\t\t\t\tTypeBinding bi1 = pi.firstBound;", "-\t\t\t\t\t\t\t\t\t\tReferenceBinding[] otherBounds = pi.superInterfaces;", "-\t\t\t\t\t\t\t\t\t\tTypeBinding bi;", "-\t\t\t\t\t\t\t\t\t\tif (otherBounds == Binding.NO_SUPERINTERFACES) {", "-\t\t\t\t\t\t\t\t\t\t\tbi = bi1;", "-\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\tint n = otherBounds.length+1;", "-\t\t\t\t\t\t\t\t\t\t\tReferenceBinding[] allBounds = new ReferenceBinding[n];", "-\t\t\t\t\t\t\t\t\t\t\tallBounds[0] = (ReferenceBinding) bi1; // TODO is this safe?", "-\t\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(otherBounds, 0, allBounds, 1, n-1);", "-\t\t\t\t\t\t\t\t\t\t\tbi = new IntersectionCastTypeBinding(allBounds, context.environment);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\taddTypeBoundsFromWildcardBound(context, theta, wildcardBinding.boundKind, t, r, bi);", "-//\t\t\t\t\t\t\t\t\t\tif (otherBounds != null) {", "-//\t\t\t\t\t\t\t\t\t\t\tfor (int j = 0; j < otherBounds.length; j++) {", "-//\t\t\t\t\t\t\t\t\t\t\t\tTypeBinding tj = otherBounds[j];", "-//\t\t\t\t\t\t\t\t\t\t\t\tif (TypeBinding.notEquals(tj, t))", "-//\t\t\t\t\t\t\t\t\t\t\t\t\taddTypeBoundsFromWildcardBound(context, wildcardBinding, tj, r, bij);", "-//\t\t\t\t\t\t\t\t\t\t\t}", "-//\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (three.superBounds != null) {", "-\t\t\t\t\t\t\t\t//  R <: \u03b1 implies \u27e8R <: T\u27e9  (super wildcard)", "-\t\t\t\t\t\t\t\t//  R <: \u03b1 implies false\t (else) ", "-\t\t\t\t\t\t\t\tit = three.superBounds.iterator();", "-\t\t\t\t\t\t\t\twhile (it.hasNext()) {", "-\t\t\t\t\t\t\t\t\tTypeBound bound = it.next();", "-\t\t\t\t\t\t\t\t\tif (!(bound.right instanceof InferenceVariable)) {", "-\t\t\t\t\t\t\t\t\t\tif (wildcardBinding.boundKind == Wildcard.SUPER)", "-\t\t\t\t\t\t\t\t\t\t\treduceOneConstraint(context, ConstraintTypeFormula.create(bound.right, t, ReductionResult.SUBTYPE));", "-\t\t\t\t\t\t\t\t\t\telse", "-\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\taddBound(new TypeBound(alpha, ai, ReductionResult.SAME), context.environment);", "-\t\t\tthis.captures.clear();", "-\t\t} while (!this.isIncorporated);"]}], "num": 24355}