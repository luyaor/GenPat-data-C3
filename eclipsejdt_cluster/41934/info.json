{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "aa614e3542a8faeeca342d75b99eb8c8", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c6283ed0e3057250d52914716b367de0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java", "commitBeforeChange": "e5e6f9097f2c3bf7294bd658643d6be9f7aaa5ef", "commitAfterChange": "d00bc48524f3df289951f11fca95cb39820be47f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "\r \r \tpublic FlowInfo analyseCode(\r \t\tBlockScope currentScope,\r \t\tFlowContext flowContext,\r \t\tFlowInfo flowInfo)", "diff": ["-}\r", "-public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {\r", "-\tConstant opConstant;\r", "-\tif ((opConstant = left.constant) != NotAConstant) {\r", "-\t\tif (opConstant.booleanValue() == true) { \r", "-\t\t\t// TRUE && anything\r", "-\t\t\tFlowInfo mergedInfo = right.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\treturn mergedInfo;\r", "-\t\t} else { \r", "-\t\t\t// FALSE && anything\r", "-\t\t\treturn flowInfo;\r", "-\t\t}\r", "-\t}\r", "-\tif ((opConstant = right.constant) != NotAConstant) {\r", "-\t\tif (opConstant.booleanValue() == true) { \r", "-\t\t\t// anything && TRUE\r", "-\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\treturn mergedInfo;\r", "-\t\t} else { \r", "-\t\t\t// anything && FALSE\r", "-\t\t\t// whatever is on the left, we will fail, so the result must merge the left inits when answering\r", "-\t\t\t// initsWhenFalse. the initsWhenTrue are undetermined, since this path will be fake reachable...\r", "-\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\treturn mergedInfo;\t\t\t\r", "-\t\t}\r", "-\t}\r", "-\tif ((opConstant = left.conditionalConstant()) != NotAConstant){\r", "-\t\tif (opConstant.booleanValue() == false){ \r", "-\t\t\t// something eq. FALSE && anything\r", "-\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\tright.analyseCode(currentScope, flowContext, mergedInfo.copy().markAsFakeReachable(true));\r", "-\t\t\treturn mergedInfo;\r", "-\t\t} \r", "-\t}\r", "-\tFlowInfo leftInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\tFlowInfo rightInfo = leftInfo.initsWhenTrue().copy();\r", "-\trightInitStateIndex = currentScope.methodScope().recordInitializationStates(rightInfo);\r", "-\trightInfo = right.analyseCode(currentScope, flowContext, rightInfo);\r", "-\tFlowInfo mergedInfo = FlowInfo.conditional(\r", "-\t\t\t\t\t\t\t\t\t\t\t\t\trightInfo.initsWhenTrue(), \r", "-\t\t\t\t\t\t\t\t\t\t\t\t\tleftInfo.initsWhenFalse().unconditionalInits().mergedWith(rightInfo.initsWhenFalse().copy().unconditionalInits()));\r", "-\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\treturn mergedInfo;\r", "-}\r", "+\tpublic FlowInfo analyseCode(\r", "+\t\tBlockScope currentScope,\r", "+\t\tFlowContext flowContext,\r", "+\t\tFlowInfo flowInfo) {\r", "+\t\tConstant opConstant = left.conditionalConstant();\r", "+\t\tif (opConstant != NotAConstant) {\r", "+\t\t\tif (opConstant.booleanValue() == true) {\r", "+\t\t\t\t// TRUE && anything\r", "+\t\t\t\t // need to be careful of scenario:\r", "+\t\t\t\t//\t\t(x && y) && !z, if passing the left info to the right, it would be swapped by the !\r", "+\t\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits(); \r", "+\t\t\t\tmergedInfo = right.analyseCode(currentScope, flowContext, mergedInfo);\r", "+\t\t\t\tmergedInitStateIndex =\r", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);\r", "+\t\t\t\treturn mergedInfo;\r", "+\t\tFlowInfo leftInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "+\t\t // need to be careful of scenario:\r", "+\t\t//\t\t(x && y) && !z, if passing the left info to the right, it would be swapped by the !\r", "+\t\tFlowInfo rightInfo = leftInfo.initsWhenTrue().unconditionalInits().copy();\r", "+\t\tif (opConstant != NotAConstant && opConstant.booleanValue() == false) rightInfo.markAsFakeReachable(true);\r", "+\r", "+\t\trightInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(rightInfo);\r", "+\t\trightInfo = right.analyseCode(currentScope, flowContext, rightInfo);\r", "+\t\tFlowInfo mergedInfo =\r", "+\t\t\tFlowInfo.conditional(\r", "+\t\t\t\trightInfo.initsWhenTrue().copy(),\r", "+\t\t\t\tleftInfo.initsWhenFalse().copy().unconditionalInits().mergedWith(\r", "+\t\t\t\t\trightInfo.initsWhenFalse().copy().unconditionalInits()));\r", "+\t\tmergedInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);\r", "+\t\treturn mergedInfo;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f6cacaf328aeaae6e6ce0a022637bb73", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java", "commitBeforeChange": "e5e6f9097f2c3bf7294bd658643d6be9f7aaa5ef", "commitAfterChange": "d00bc48524f3df289951f11fca95cb39820be47f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "\r \r \tpublic FlowInfo analyseCode(\r \t\tBlockScope currentScope,\r \t\tFlowContext flowContext,\r \t\tFlowInfo flowInfo)", "diff": ["-}\r", "-public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {\r", "-\tConstant opConstant;\r", "-\tif ((opConstant = left.constant) != NotAConstant) {\r", "-\t\tif (opConstant.booleanValue() == false) { \r", "-\t\t\t// FALSE || anything\r", "-\t\t\treturn right.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t} else { \r", "-\t\t\t// TRUE || anything\r", "-\t\t\treturn flowInfo;\r", "-\t\t}\r", "-\t}\r", "-\tif ((opConstant = right.constant) != NotAConstant) {\r", "-\t\tif (opConstant.booleanValue() == true) { \r", "-\t\t\t// anything || TRUE\r", "-\t\t\t// whatever is on the left, we will succeed, so the result must merge the left inits when answering\r", "-\t\t\t// initsWhenTrue.\r", "-\t\t\t// the initsWhenFalse are undetermined, since this path will be fake reachable...\r", "-\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\treturn mergedInfo;\t\t\t\r", "-\t\t} else { \r", "-\t\t\t// anything || FALSE\r", "-\t\t\t// ignore the right part\r", "-\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\treturn mergedInfo;\t\t\t\r", "-\t\t}\r", "-\t}\r", "-\tif ((opConstant = left.conditionalConstant()) != NotAConstant) {\r", "-\t\tif (opConstant.booleanValue() == true){ \r", "-\t\t\t// TRUE || anything\r", "-\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\t\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\t\t\tright.analyseCode(currentScope, flowContext, mergedInfo.copy().markAsFakeReachable(true));\r", "-\t\t\treturn mergedInfo;\r", "-\t\t} \r", "-\t}\r", "-\tFlowInfo leftInfo, rightInfo;\tleftInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "-\trightInfo = leftInfo.initsWhenFalse().copy();\r", "-\trightInitStateIndex = currentScope.methodScope().recordInitializationStates(rightInfo);\r", "-\trightInfo = right.analyseCode(currentScope, flowContext, rightInfo);\r", "-\tFlowInfo mergedInfo = FlowInfo.conditional(\r", "-\t\t// merging two true initInfos for such a negative case: if ((t && (b = t)) || f) r = b; // b may not have been initialized\r", "-\t\tleftInfo.initsWhenTrue().unconditionalInits().mergedWith(rightInfo.initsWhenTrue().copy().unconditionalInits()), \r", "-\t\trightInfo.initsWhenFalse());\r", "-\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);\r", "-\treturn mergedInfo;\r", "-}\r", "+\tpublic FlowInfo analyseCode(\r", "+\t\tBlockScope currentScope,\r", "+\t\tFlowContext flowContext,\r", "+\t\tFlowInfo flowInfo) {\r", "+\t\tConstant opConstant = left.conditionalConstant();\r", "+\t\tif (opConstant != NotAConstant) {\r", "+\t\t\tif (opConstant.booleanValue() == false) {\r", "+\t\t\t\t// FALSE || anything\r", "+\t\t\t\t // need to be careful of scenario:\r", "+\t\t\t\t//\t\t(x || y) || !z, if passing the left info to the right, it would be swapped by the !\r", "+\t\t\t\tFlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();\r", "+\t\t\t\tmergedInfo = right.analyseCode(currentScope, flowContext, mergedInfo);\r", "+\t\t\t\tmergedInitStateIndex =\r", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);\r", "+\t\t\t\treturn mergedInfo;\r", "+\t\tFlowInfo leftInfo, rightInfo;\r", "+\t\tleftInfo = left.analyseCode(currentScope, flowContext, flowInfo);\r", "+\t\r", "+\t\t // need to be careful of scenario:\r", "+\t\t//\t\t(x || y) || !z, if passing the left info to the right, it would be swapped by the !\r", "+\t\trightInfo = leftInfo.initsWhenFalse().unconditionalInits().copy();\r", "+\t\tif (opConstant != NotAConstant && opConstant.booleanValue() == true) rightInfo.markAsFakeReachable(true);\r", "+\r", "+\t\trightInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(rightInfo);\r", "+\t\trightInfo = right.analyseCode(currentScope, flowContext, rightInfo);\r", "+\t\tFlowInfo mergedInfo = FlowInfo.conditional(\r", "+\t\t\t\t\t// merging two true initInfos for such a negative case: if ((t && (b = t)) || f) r = b; // b may not have been initialized\r", "+\t\t\t\t\tleftInfo.initsWhenTrue().copy().unconditionalInits().mergedWith(\r", "+\t\t\t\t\t\trightInfo.initsWhenTrue().copy().unconditionalInits()),\r", "+\t\t\t\t\trightInfo.initsWhenFalse().copy());\r", "+\t\tmergedInitStateIndex =\r", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);\r", "+\t\treturn mergedInfo;\r"]}], "num": 41934}