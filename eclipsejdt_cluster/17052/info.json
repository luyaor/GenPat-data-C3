{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "864526d957bd61244e6fa438022c177e", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1bace1cebc39b777dc61fb88a0c81a1b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "1df699e669c4e4f2a900614bdd75bf90200992be", "commitAfterChange": "0171a309cfa1d187647511afec0bb25c2eadf3cf", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite)", "diff": ["+\t\t", "+\t\t// first iteration, questionning widening cast", "-\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)argument);", "+\t\t\t\t\tscope.problemReporter().unnecessaryCastForArgument((CastExpression)argument, binding.parameters[i]);", "-\t\tif (rawArgumentTypes == argumentTypes) return; // did not find any unnecessary cast candidate", "-\t", "-\t\tInvocationSite fakeInvocationSite = new InvocationSite(){\t", "-\t\t\tpublic boolean isSuperAccess(){ return invocationSite.isSuperAccess(); }", "-\t\t\tpublic boolean isTypeAccess() { return invocationSite.isTypeAccess(); }", "-\t\t\tpublic void setActualReceiverType(ReferenceBinding actualReceiverType) {}", "-\t\t\tpublic void setDepth(int depth) {}", "-\t\t\tpublic void setFieldIndex(int depth){}", "-\t\t};\t", "-\t\tMethodBinding bindingIfNoCast;", "-\t\tif (binding.isConstructor()) {", "-\t\t\tbindingIfNoCast = scope.getConstructor(receiverType, rawArgumentTypes, fakeInvocationSite);", "-\t\t} else {", "-\t\t\tbindingIfNoCast = receiver.isImplicitThis()", "-\t\t\t\t? scope.getImplicitMethod(binding.selector, rawArgumentTypes, fakeInvocationSite)", "-\t\t\t\t: scope.getMethod(receiverType, binding.selector, rawArgumentTypes, fakeInvocationSite); \t", "+\t\t// did not find any unnecessary cast candidate", "+\t\tif (rawArgumentTypes != argumentTypes) {", "+\t\t\tcheckAlternateBinding(scope, receiver, receiverType, binding, arguments, argumentTypes, rawArgumentTypes, invocationSite);", "-\t\tif (bindingIfNoCast == binding) {", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tif (argumentTypes[i] != rawArgumentTypes[i]) {", "-\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)arguments[i]);", "+\t\t", "+\t\t// second attempt questionning narrowing cast", "+\t\trawArgumentTypes = argumentTypes;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tExpression argument = arguments[i];", "+\t\t\tif (argument instanceof CastExpression && (argument.bits & UnnecessaryCastMask) == 0) {", "+\t\t\t\tTypeBinding castedExpressionType = ((CastExpression)argument).expression.resolvedType;", "+\t\t\t\tif (rawArgumentTypes == argumentTypes) {", "+\t\t\t\t\tSystem.arraycopy(rawArgumentTypes, 0, rawArgumentTypes = new TypeBinding[length], 0, length);", "+\t\t\t\trawArgumentTypes[i] = castedExpressionType; ", "+\t\t}", "+\t\tif (rawArgumentTypes != argumentTypes) {", "+\t\t\tcheckAlternateBinding(scope, receiver, receiverType, binding, arguments, argumentTypes, rawArgumentTypes, invocationSite);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "86689129daa7ad784d04262b22797002", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "00b719c0d7c4b5271c818d210d84b349bc0324e3", "commitAfterChange": "f90ca993824b1d0e38aec24edba147ca4e8ec0d1", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t\tboolean argsContainCast = false;", "-\t\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null){", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\t\t\targsContainCast = true;", "+\t\t\t\t\t}", "+\t\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null){", "+\t\t\t\t}", "-", "+\t\t\tReferenceBinding allocationType = (ReferenceBinding) receiverType;", "-\t\t\tif ((this.binding = scope.getConstructor((ReferenceBinding) receiverType, argumentTypes, this))", "-\t\t\t\t\t.isValidBinding()) {", "-\t\t\t\tif (isMethodUseDeprecated(binding, scope))", "+\t\t\tif ((this.binding = scope.getConstructor(allocationType, argumentTypes, this)).isValidBinding()) {", "+\t\t\t\tif (isMethodUseDeprecated(binding, scope)) {", "-", "-\t\t\t\tif (arguments != null)", "-\t\t\t\t\tfor (int i = 0; i < arguments.length; i++)", "+\t\t\t\t}", "+\t\t\t\tif (arguments != null) {", "+\t\t\t\t\tfor (int i = 0; i < arguments.length; i++) {", "+\t\t\t\t\t}", "+\t\t\t\t\tif (argsContainCast) {", "+\t\t\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, allocationType, binding, this.arguments, argumentTypes, this);", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t\tif (this.binding.declaringClass == null)", "-\t\t\t\t\tthis.binding.declaringClass = (ReferenceBinding) receiverType;", "+\t\t\t\tif (this.binding.declaringClass == null) {", "+\t\t\t\t\tthis.binding.declaringClass = allocationType;", "+\t\t\t\t}", "-\t\t\tif (enclosingInstanceType.isCompatibleWith(expectedType))", "+\t\t\tif (enclosingInstanceType.isCompatibleWith(expectedType)) {", "+\t\t\t}", "-\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null) {", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\t\targsContainCast = true;", "+\t\t\t\t}", "+\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null) {", "+\t\t\t}", "-\t\t\t\treturn receiverType;", "+\t\t\treturn receiverType;", "-\t\t\tif (inheritedBinding.declaringClass == null)", "+\t\t\tif (inheritedBinding.declaringClass == null) {", "+\t\t\t}", "-\t\tif (arguments != null)", "-\t\t\tfor (int i = 0; i < arguments.length; i++)", "+\t\tif (arguments != null) {", "+\t\t\tfor (int i = 0; i < arguments.length; i++) {", "-", "+\t\t\t}", "+\t\t\tif (argsContainCast) {", "+\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, this.superTypeBinding, inheritedBinding, this.arguments, argumentTypes, this);", "+\t\t\t}", "+\t\t}"]}], "num": 17052}