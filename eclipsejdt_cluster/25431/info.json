{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "66efa573f10a2c7e862d12245fb9c0d1", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3257f170202d17c0c623942e30cc6989", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java", "commitBeforeChange": "e727e59f7c542c72974201b990d6500618f1dbac", "commitAfterChange": "dfc95f9bbb633dbf9f58a8f0947067806925def8", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " \tpublic static final boolean pathMatch( \t\tchar[] pattern, \t\tchar[] filepath, \t\tboolean isCaseSensitive, \t\tchar pathSeparator)", "signatureAfterChange": " \tpublic static final boolean pathMatch( \t\tchar[] pattern, \t\tchar[] filepath, \t\tboolean isCaseSensitive, \t\tchar pathSeparator)", "diff": ["-\t\t// offsets inside pattern", "-\t\tint pSegmentStart = 0, pLength = pattern.length;", "-\t\tint pSegmentEnd = CharOperation.indexOf(pathSeparator, pattern);", "-\t\tif (pSegmentEnd < 0)", "-\t\t\tpSegmentEnd = pLength;", "-", "-\t\t// offsets inside filepath", "-\t\tint fSegmentStart = 0, fLength = filepath.length;", "-\t\tint fSegmentEnd = CharOperation.indexOf(pathSeparator, filepath);", "-\t\tif (fSegmentEnd < 0)", "-\t\t\tfSegmentEnd = fLength;", "-", "-\t\tboolean freeLeadingDoubleStar = pattern[0] != pathSeparator;", "+\t\tboolean freeLeadingDoubleStar;", "+", "+\t\t// offsets inside pattern", "+\t\tint pSegmentStart, pLength = pattern.length;", "+", "+\t\tif (freeLeadingDoubleStar = pattern[0] != pathSeparator){", "+\t\t\tpSegmentStart = 0;", "+\t\t} else {", "+\t\t\tpSegmentStart = 1;", "+\t\t}", "+\t\tint pSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, pSegmentStart+1);", "+\t\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "+\t\t// offsets inside filepath", "+\t\tint fSegmentStart, fLength = filepath.length;", "+\t\tif (filepath[0] != pathSeparator){", "+\t\t\tfSegmentStart = 0;", "+\t\t} else {", "+\t\t\tfSegmentStart = 1;", "+\t\t}", "+\t\tif (fSegmentStart != pSegmentStart) {", "+\t\t\treturn false; // both must start with a separator or none.", "+\t\t}", "+\t\tint fSegmentEnd = CharOperation.indexOf(pathSeparator, filepath, fSegmentStart+1);", "+\t\tif (fSegmentEnd < 0) fSegmentEnd = fLength;", "+", "-\t\t\t&& !(pSegmentEnd == pSegmentStart + 2", "-\t\t\t\t&& pattern[pSegmentStart] == '*'", "-\t\t\t\t&& pattern[pSegmentStart + 1] == '*')) {", "+\t\t\t&& !(pSegmentEnd == pLength && freeTrailingDoubleStar", "+\t\t\t\t\t|| (pSegmentEnd == pSegmentStart + 2", "+\t\t\t\t\t\t\t&& pattern[pSegmentStart] == '*'", "+\t\t\t\t\t\t\t&& pattern[pSegmentStart + 1] == '*'))) {", "-\t\t\tif (fSegmentEnd < 0)", "-\t\t\t\tfSegmentEnd = fLength;", "+\t\t\tif (fSegmentEnd < 0) fSegmentEnd = fLength;", "-\t\tif (pSegmentEnd == pSegmentStart + 2", "-\t\t\t&& pattern[pSegmentStart] == '*'", "-\t\t\t&& pattern[pSegmentStart + 1] == '*') {", "+\t\tif ((pSegmentStart >= pLength && freeTrailingDoubleStar)", "+\t\t\t\t|| (pSegmentEnd == pSegmentStart + 2", "+\t\t\t\t\t&& pattern[pSegmentStart] == '*'", "+\t\t\t\t\t&& pattern[pSegmentStart + 1] == '*')) {", "-\t\t\tif (pSegmentEnd < 0)", "-\t\t\t\tpSegmentEnd = pLength;", "+\t\t\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "-\t\tcheckSegment : while (", "-\t\t\tfSegmentStart < fLength && pSegmentStart < pLength) {", "-\t\t\t/* segment is ending */", "-\t\t\tif (pSegmentEnd == pSegmentStart + 2", "-\t\t\t\t&& pattern[pSegmentStart] == '*'", "-\t\t\t\t&& pattern[pSegmentStart + 1] == '*') {", "+\t\tcheckSegment : while (fSegmentStart < fLength) {", "+\t\t\t\t", "+\t\t\tif (pSegmentStart >= pLength) {", "+\t\t\t\tif (freeTrailingDoubleStar) return true;", "+\t\t\t\t// mismatch - restart current path segment", "-\t\t\t\t\tCharOperation.indexOf(", "-\t\t\t\t\t\tpathSeparator,", "-\t\t\t\t\t\tpattern,", "-\t\t\t\t\t\tpSegmentStart = pSegmentEnd + 1);", "-\t\t\t\t// skip separator", "-\t\t\t\tif (pSegmentEnd < 0)", "-\t\t\t\t\tpSegmentEnd = pLength;", "-\t\t\t\tpSegmentRestart = pSegmentStart;", "-\t\t\t\tfSegmentRestart = fSegmentStart;", "-\t\t\t\tcontinue checkSegment;", "-\t\t\t}", "-\t\t\t/* chech current path segment */", "-\t\t\tif (!CharOperation", "-\t\t\t\t.match(", "-\t\t\t\t\tpattern,", "-\t\t\t\t\tpSegmentStart,", "-\t\t\t\t\tpSegmentEnd,", "-\t\t\t\t\tfilepath,", "-\t\t\t\t\tfSegmentStart,", "-\t\t\t\t\tfSegmentEnd,", "-\t\t\t\t\tisCaseSensitive)) {", "-\t\t\t\t// mismatch - restart current segment", "-\t\t\t\tpSegmentEnd =", "-\t\t\t\t\tCharOperation.indexOf(", "-\t\t\t\t\t\tpathSeparator,", "-\t\t\t\t\t\tpattern,", "-\t\t\t\t\t\tpSegmentStart = pSegmentRestart);", "-\t\t\t\tif (pSegmentEnd < 0)", "-\t\t\t\t\tpSegmentEnd = pLength;", "+\t\t\t\t\tCharOperation.indexOf(pathSeparator, pattern, pSegmentStart = pSegmentRestart);", "+\t\t\t\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "-\t\t\t\tfSegmentRestart =", "-\t\t\t\t\tCharOperation.indexOf(", "-\t\t\t\t\t\tpathSeparator,", "-\t\t\t\t\t\tfilepath,", "-\t\t\t\t\t\tfSegmentRestart + 1);", "+\t\t\t\tfSegmentRestart = ", "+\t\t\t\t\tCharOperation.indexOf(pathSeparator, filepath, fSegmentRestart + 1);", "-\t\t\t\t\tCharOperation.indexOf(", "-\t\t\t\t\t\tpathSeparator,", "-\t\t\t\t\t\tfilepath,", "-\t\t\t\t\t\tfSegmentStart = fSegmentRestart);", "-\t\t\t\tif (fSegmentEnd < 0)", "-\t\t\t\t\tfSegmentEnd = fLength;", "+\t\t\t\t\tCharOperation.indexOf(pathSeparator, filepath, fSegmentStart = fSegmentRestart);", "+\t\t\t\tif (fSegmentEnd < 0) fSegmentEnd = fLength;", "+\t\t\t\tcontinue checkSegment;", "+\t\t\t}", "+\t\t\t", "+\t\t\t/* path segment is ending */", "+\t\t\tif (pSegmentEnd == pSegmentStart + 2", "+\t\t\t\t&& pattern[pSegmentStart] == '*'", "+\t\t\t\t&& pattern[pSegmentStart + 1] == '*') {", "+\t\t\t\tpSegmentEnd =", "+\t\t\t\t\tCharOperation.indexOf(pathSeparator, pattern, pSegmentStart = pSegmentEnd + 1);", "+\t\t\t\t// skip separator", "+\t\t\t\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "+\t\t\t\tpSegmentRestart = pSegmentStart;", "+\t\t\t\tfSegmentRestart = fSegmentStart;", "+\t\t\t\tif (pSegmentStart >= pLength) return true;", "+\t\t\t\tcontinue checkSegment;", "+\t\t\t}", "+\t\t\t/* chech current path segment */", "+\t\t\tif (!CharOperation.match(", "+\t\t\t\t\t\t\t\tpattern,", "+\t\t\t\t\t\t\t\tpSegmentStart,", "+\t\t\t\t\t\t\t\tpSegmentEnd,", "+\t\t\t\t\t\t\t\tfilepath,", "+\t\t\t\t\t\t\t\tfSegmentStart,", "+\t\t\t\t\t\t\t\tfSegmentEnd,", "+\t\t\t\t\t\t\t\tisCaseSensitive)) {", "+\t\t\t\t// mismatch - restart current path segment", "+\t\t\t\tpSegmentEnd =", "+\t\t\t\t\tCharOperation.indexOf(pathSeparator, pattern, pSegmentStart = pSegmentRestart);", "+\t\t\t\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "+", "+\t\t\t\tfSegmentRestart = ", "+\t\t\t\t\tCharOperation.indexOf(pathSeparator, filepath, fSegmentRestart + 1);", "+\t\t\t\t// skip separator", "+\t\t\t\tif (fSegmentRestart < 0) {", "+\t\t\t\t\tfSegmentRestart = fLength;", "+\t\t\t\t} else {", "+\t\t\t\t\tfSegmentRestart++;", "+\t\t\t\t}", "+\t\t\t\tfSegmentEnd =", "+\t\t\t\t\tCharOperation.indexOf(pathSeparator, filepath, fSegmentStart = fSegmentRestart);", "+\t\t\t\tif (fSegmentEnd < 0) fSegmentEnd = fLength;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "412326e4680652a878ec82cf58376a48", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/CharOperation.java", "commitBeforeChange": "bef4c5dc335e4766b9aab99de5f2d0512ecb779a", "commitAfterChange": "354f375450d972454ab50692e7588deeb00e49c5", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " public static final boolean pathMatch(char[] pattern, char[] path, boolean isCaseSensitive, char pathSeparator)", "signatureAfterChange": " public static final boolean pathMatch(char[] pattern, char[] path, boolean isCaseSensitive, char pathSeparator)", "diff": ["-\tint iPattern = 0, patternLength = pattern.length;", "-\tint iPath = 0, pathLength = path.length;", "-", "-\t/* check first segment */", "-\tchar patternChar = 0;", "-\twhile ((iPattern < patternLength) && (patternChar = pattern[iPattern]) != '*'){", "-\t\tif (iPath == pathLength) return false;", "-\t\tif (patternChar != (isCaseSensitive ", "-\t\t\t\t\t\t\t\t? path[iPath] ", "-\t\t\t\t\t\t\t\t: Character.toLowerCase(path[iPath]))", "-\t\t\t\t&& patternChar != '?'){", "+\t", "+\tchar[][] patternSegments = splitOn(pathSeparator, pattern);", "+\tchar[][] pathSegments = splitOn(pathSeparator, path);", "+\tchar[] patternSegment = null;", "+\t", "+\tint iPatternSegment = 0, patternSegmentLength = patternSegments.length;", "+\tint iPathSegment = 0, pathSegmentLength = pathSegments.length;", "+\t", "+\tfinal char[] doubleStar = new char[] { '*', '*' };", "+\tfor (int i = 0; i < patternSegmentLength; i++) {", "+\t\tif (patternSegments[i].length == 2 && patternSegments[i][0] == '*' && patternSegments[i][1] == '*') {", "+\t\t\tpatternSegments[i] = doubleStar;", "+\t\t}", "+\t}", "+\t", "+\t// first segments", "+\twhile (iPatternSegment < patternSegmentLength && (patternSegment = patternSegments[iPatternSegment]) != doubleStar) {", "+\t\tif (iPathSegment == pathSegmentLength) return false;", "+\t\tif (!match(patternSegment, pathSegments[iPathSegment], isCaseSensitive)) {", "-\t\tiPath++;", "-\t\tiPattern++;", "+\t\t", "+\t\tiPatternSegment++;", "+\t\tiPathSegment++;", "-\t/* check sequence of star+segment */", "+", "+\t/* check sequence of doubleStar+segment */", "-\tif (patternChar == '*'){", "-\t\tsegmentStart = ++iPattern; // skip star", "+\tif (patternSegment == doubleStar){", "+\t\tsegmentStart = ++iPatternSegment; // skip star", "-\tint prefixStart = iPath;", "-\tcheckSegment: while (iPath < pathLength && iPattern < patternLength){", "+\tint prefixStart = iPathSegment;", "+\tcheckSegment: while (iPathSegment < pathSegmentLength && iPatternSegment < patternSegmentLength){", "-\t\tif ((patternChar = pattern[iPattern]) == '*'){", "-\t\t\tsegmentStart = ++iPattern; // skip start", "-\t\t\tprefixStart = iPath;", "+\t\tif ((patternSegment = patternSegments[iPatternSegment]) == doubleStar){", "+\t\t\tsegmentStart = ++iPatternSegment; // skip start", "+\t\t\tprefixStart = iPathSegment;", "-\t\t/* chech current name character */", "-\t\tif ((isCaseSensitive ", "-\t\t\t\t? path[iPath] ", "-\t\t\t\t: Character.toLowerCase(path[iPath]))!= patternChar", "-\t\t\t\t\t&& patternChar != '?'){", "-\t\t\tiPattern = segmentStart; // mismatch - restart current segment", "-\t\t\tiPath = ++prefixStart;", "+\t\t/* chech current path segment */", "+\t\tif (!match(patternSegment, pathSegments[iPathSegment], isCaseSensitive)) {", "+\t\t\tiPatternSegment = segmentStart; // mismatch - restart current segment", "+\t\t\tiPathSegment = ++prefixStart;", "-\t\tiPath++;", "-\t\tiPattern++;", "+\t\tiPathSegment++;", "+\t\tiPatternSegment++;", "-\treturn (segmentStart == patternLength)", "-\t\t\t|| (iPath == pathLength && iPattern == patternLength)\t", "-\t\t\t|| (iPattern == patternLength - 1 && pattern[iPattern] == '*'); ", "+\treturn (segmentStart == patternSegmentLength)", "+\t\t\t|| (iPathSegment == pathSegmentLength && iPatternSegment == patternSegmentLength)\t", "+\t\t\t|| (iPatternSegment == patternSegmentLength - 1 && patternSegments[iPatternSegment] == doubleStar); "]}], "num": 25431}