{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "125e05d7de993d35fbf103e518b3ccf2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "45fb82ae36d2b33b14582c5c44baa42b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "12c7a1390003be03c294e54b44d9a738e6c7419f", "commitAfterChange": "53e6fec78075a59c5a113791cd010b007a9d1ec1", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 40, "signatureBeforeChange": "\r \tpublic void startup()", "signatureAfterChange": "\r \tpublic void startup()", "diff": ["+\t\t\r", "+\t\tif(JavaCore.getPlugin().isDebugging()){\r", "+\t\t\tString option = Platform.getDebugOption(INDEX_MANAGER_DEBUG);\r", "+\t\t\tif(option != null) IndexManager.VERBOSE = option.equalsIgnoreCase(\"true\") ; //$NON-NLS-1$\r", "+\t\t\t\r", "+\t\t\toption = Platform.getDebugOption(COMPILER_DEBUG);\r", "+\t\t\tif(option != null) Compiler.DEBUG = option.equalsIgnoreCase(\"true\") ; //$NON-NLS-1$\r", "+\t\t}\r", "+\t\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90b05b83b28c0c1d7864101fe3e76aa1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPathUtil.java", "commitBeforeChange": "a08b4c389632f0f20a50182ded68880addc0de18", "commitAfterChange": "5cb40e1ad24651b50221770b935dfa647cb41f4d", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t \tpublic static Map<FactoryContainer, Boolean> decodeFactoryPath(final String xmlFactoryPath)  \t\tthrows IOException", "signatureAfterChange": " \t \tpublic static Map<FactoryContainer, Boolean> decodeFactoryPath(final String xmlFactoryPath)  \t\tthrows IOException", "diff": ["+\t\t\t\t// deprecated container type \"JAR\" is now \"EXTJAR\"", "+\t\t\t\tif (\"JAR\".equals(kindString)) {", "+\t\t\t\t\tkindString = \"EXTJAR\";", "+\t\t\t\t}", "-\t\t\t\tcase (JAR) :", "-\t\t\t\t\tcontainer = new JarFactoryContainer(new File(idString));", "+\t\t\t\tcase WKSPJAR :", "+\t\t\t\t\tcontainer = FactoryPath.newWkspJarFactoryContainer(new Path(idString));", "+\t\t\t\t\tbreak;", "+\t\t\t\t\t", "+\t\t\t\tcase EXTJAR :", "+\t\t\t\t\tcontainer = FactoryPath.newExtJarFactoryContainer(new File(idString));", "+\t\t\t\t\tbreak;", "+\t\t\t\t\t", "+\t\t\t\tcase VARJAR :", "+\t\t\t\t\tcontainer = FactoryPath.newVarJarFactoryContainer(new Path(idString));", "-\t\t\t\tcase (PLUGIN) :", "-\t\t\t\t\tcontainer = new PluginFactoryContainer(idString);", "+\t\t\t\tcase PLUGIN :", "+\t\t\t\t\tcontainer = FactoryPath.newPluginFactoryContainer(idString);", "-\t\t\t\tresult.put(container, new Boolean(enabledString));", "+\t\t\t\tif (null != container) {", "+\t\t\t\t\tresult.put(container, new Boolean(enabledString));", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd7d5e01513e69c2462083ec483c3a2f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "8a55616a15f0e12ee24162781746f45ed8c24b78", "commitAfterChange": "d7c285a09f8cde2ba05e7f838f10ce545b90c736", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "\r public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo)", "signatureAfterChange": "\r \r \tpublic void analyseCode(\r \t\tClassScope classScope,\r \t\tInitializationFlowContext initializerFlowContext,\r \t\tFlowInfo flowInfo)", "diff": ["-\tpublic int referenceCount = 0; // count how many times this constructor is referenced from other local constructors\r", "-public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo) {\r", "-\tif (ignoreFurtherInvestigation)\r", "-\t\treturn;\r", "-\ttry {\r", "-\t\tExceptionHandlingFlowContext constructorContext = new ExceptionHandlingFlowContext(\r", "-\t\t\tinitializerFlowContext.parent, \r", "-\t\t\tthis, \r", "-\t\t\tbinding.thrownExceptions, \r", "-\t\t\tscope,\r", "-\t\t\tFlowInfo.DeadEnd);\r", "-\t\tinitializerFlowContext.checkInitializerExceptions(scope, constructorContext, flowInfo);\r", "-\t\t\r", "-\t\t// propagate to constructor call\r", "-\t\tif (constructorCall != null) {\r", "-\t\t\t// if calling 'this(...)', then flag all non-static fields as definitely\r", "-\t\t\t// set since they are supposed to be set inside other local constructor\r", "-\t\t\tif (constructorCall.accessMode == ExplicitConstructorCall.This) {\r", "-\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();\r", "-\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {\r", "-\t\t\t\t\tFieldBinding field;\r", "-\t\t\t\t\tif (!(field = fields[i]).isStatic()) {\r", "-\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(field);\r", "+\r", "+\tpublic void analyseCode(\r", "+\t\tClassScope classScope,\r", "+\t\tInitializationFlowContext initializerFlowContext,\r", "+\t\tFlowInfo flowInfo) {\r", "+\r", "+\t\tif (ignoreFurtherInvestigation)\r", "+\t\t\treturn;\r", "+\t\ttry {\r", "+\t\t\tExceptionHandlingFlowContext constructorContext =\r", "+\t\t\t\tnew ExceptionHandlingFlowContext(\r", "+\t\t\t\t\tinitializerFlowContext.parent,\r", "+\t\t\t\t\tthis,\r", "+\t\t\t\t\tbinding.thrownExceptions,\r", "+\t\t\t\t\tscope,\r", "+\t\t\t\t\tFlowInfo.DeadEnd);\r", "+\t\t\tinitializerFlowContext.checkInitializerExceptions(\r", "+\t\t\t\tscope,\r", "+\t\t\t\tconstructorContext,\r", "+\t\t\t\tflowInfo);\r", "+\r", "+\t\t\t// anonymous constructor can gain extra thrown exceptions from unhandled ones\r", "+\t\t\tif (binding.declaringClass.isAnonymousType()) {\r", "+\t\t\t\tArrayList computedExceptions = constructorContext.extendedExceptions;\r", "+\t\t\t\tif (computedExceptions != null){\r", "+\t\t\t\t\tint size;\r", "+\t\t\t\t\tif ((size = computedExceptions.size()) > 0){\r", "+\t\t\t\t\t\tReferenceBinding[] actuallyThrownExceptions;\r", "+\t\t\t\t\t\tcomputedExceptions.toArray(actuallyThrownExceptions = new ReferenceBinding[size]);\r", "+\t\t\t\t\t\tbinding.thrownExceptions = actuallyThrownExceptions;\r", "-\t\t\tflowInfo = constructorCall.analyseCode(scope, constructorContext, flowInfo);\r", "-\t\t}\r", "-\t\t// propagate to statements\r", "-\t\tif (statements != null){\r", "-\t\t\tfor (int i = 0, count = statements.length; i < count; i++) {\r", "-\t\t\t\tStatement stat;\r", "-\t\t\t\tif (!flowInfo.complainIfUnreachable((stat = statements[i]), scope)) {\r", "-\t\t\t\t\tflowInfo = stat.analyseCode(scope, constructorContext, flowInfo);\r", "+\t\t\t\r", "+\t\t\t// propagate to constructor call\r", "+\t\t\tif (constructorCall != null) {\r", "+\t\t\t\t// if calling 'this(...)', then flag all non-static fields as definitely\r", "+\t\t\t\t// set since they are supposed to be set inside other local constructor\r", "+\t\t\t\tif (constructorCall.accessMode == ExplicitConstructorCall.This) {\r", "+\t\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();\r", "+\t\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {\r", "+\t\t\t\t\t\tFieldBinding field;\r", "+\t\t\t\t\t\tif (!(field = fields[i]).isStatic()) {\r", "+\t\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(field);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tflowInfo = constructorCall.analyseCode(scope, constructorContext, flowInfo);\r", "+\t\t\t}\r", "+\t\t\t// propagate to statements\r", "+\t\t\tif (statements != null) {\r", "+\t\t\t\tfor (int i = 0, count = statements.length; i < count; i++) {\r", "+\t\t\t\t\tStatement stat;\r", "+\t\t\t\t\tif (!flowInfo.complainIfUnreachable((stat = statements[i]), scope)) {\r", "+\t\t\t\t\t\tflowInfo = stat.analyseCode(scope, constructorContext, flowInfo);\r", "+\t\t\t\t\t}\r", "-\t\t}\r", "-\t\t// check for missing returning path\r", "-\t\tneedFreeReturn = !((flowInfo == FlowInfo.DeadEnd) || flowInfo.isFakeReachable());\r", "+\t\t\t// check for missing returning path\r", "+\t\t\tneedFreeReturn =\r", "+\t\t\t\t!((flowInfo == FlowInfo.DeadEnd) || flowInfo.isFakeReachable());\r", "-\t\t// check missing blank final field initializations\r", "-\t\tif ((constructorCall != null) && (constructorCall.accessMode != ExplicitConstructorCall.This)){\r", "-\t\t\tflowInfo = flowInfo.mergedWith(initializerFlowContext.initsOnReturn);\r", "-\t\t\tFieldBinding[] fields = binding.declaringClass.fields();\r", "-\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {\r", "-\t\t\t\tFieldBinding field;\r", "-\t\t\t\tif ((!(field = fields[i]).isStatic())\r", "-\t\t\t\t\t&& field.isFinal()\r", "-\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {\r", "-\t\t\t\t\tscope.problemReporter().uninitializedBlankFinalField(field, isDefaultConstructor ? (AstNode)scope.referenceType() : this);\r", "+\t\t\t// check missing blank final field initializations\r", "+\t\t\tif ((constructorCall != null)\r", "+\t\t\t\t&& (constructorCall.accessMode != ExplicitConstructorCall.This)) {\r", "+\t\t\t\tflowInfo = flowInfo.mergedWith(initializerFlowContext.initsOnReturn);\r", "+\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();\r", "+\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {\r", "+\t\t\t\t\tFieldBinding field;\r", "+\t\t\t\t\tif ((!(field = fields[i]).isStatic())\r", "+\t\t\t\t\t\t&& field.isFinal()\r", "+\t\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {\r", "+\t\t\t\t\t\tscope.problemReporter().uninitializedBlankFinalField(\r", "+\t\t\t\t\t\t\tfield,\r", "+\t\t\t\t\t\t\tisDefaultConstructor ? (AstNode) scope.referenceType() : this);\r", "+\t\t\t\t\t}\r", "+\t\t} catch (AbortMethod e) {\r", "+\t\t\tthis.ignoreFurtherInvestigation = true;\r", "-\t} catch (AbortMethod e) {\r", "-\t\tthis.ignoreFurtherInvestigation = true;\t\t\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "db246afc8e7f87584fe7166a90801978", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "8bffc680730baeb75a0764c02d5d9479eee4502e", "commitAfterChange": "a29a64421d33da260a7d362b9f95ba50806929de", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "signatureAfterChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "diff": ["-\t\t\t\t\tinferenceContext.leavePolyInvocation(prevInvocation);", "+\t\t\t\t\tinferenceContext.resumeSuspendedInference(prevInvocation);", "-\t\t\t\tScope scope = inferenceContext.scope;", "-\t\t\t\tTypeBinding t = this.right;", "-\t\t\t\tif (!t.isFunctionalInterface(scope))", "+\t\t\t\tBlockScope scope = lambda.enclosingScope;", "+\t\t\t\tif (!this.right.isFunctionalInterface(scope))", "+\t\t\t\t\treturn FALSE;", "+\t\t\t\t", "+\t\t\t\tReferenceBinding t = (ReferenceBinding) this.right;", "+\t\t\t\tParameterizedTypeBinding withWildCards = InferenceContext18.parameterizedWithWildcard(t);", "+\t\t\t\tif (withWildCards != null) {", "+\t\t\t\t\tt = findGroundTargetType(inferenceContext, scope, lambda, withWildCards);", "+\t\t\t\t}", "+\t\t\t\tif (t == null)", "+\t}"]}], "num": 39202}