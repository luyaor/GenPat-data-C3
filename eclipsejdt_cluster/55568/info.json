{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "185e2304725641ae64636981f061baad", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "54f7df3c6c3e76047c200137e481b2fc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes, Scope scope)", "signatureAfterChange": " \tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding method, TypeBinding[] argumentTypes, BlockScope scope)", "diff": ["-\tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes, Scope scope) {", "-\t\tif (!invocation.innersNeedUpdate())", "+\tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding method, TypeBinding[] argumentTypes, BlockScope scope) {", "+\t\tMethodBinding candidateMethod = method.isValidBinding() ? method : method instanceof ProblemMethodBinding ? ((ProblemMethodBinding) method).closestMatch : null;", "+\t\tif (candidateMethod == null)", "-\t\tint problemReason = 0;", "-\t\tMethodBinding candidateMethod;", "-\t\tif (methodBinding.isValidBinding()) {", "-\t\t\tcandidateMethod = methodBinding;", "-\t\t} else if (methodBinding instanceof ProblemMethodBinding) {", "-\t\t\tproblemReason = methodBinding.problemId();", "-\t\t\tcandidateMethod = ((ProblemMethodBinding) methodBinding).closestMatch;", "-\t\t} else {", "-\t\t\tcandidateMethod = null;", "-\t\t}", "-\t\tif (candidateMethod != null) {", "-\t\t\tboolean variableArity = candidateMethod.isVarargs();", "-\t\t\tInferenceContext18 infCtx = null;", "-\t\t\tif (candidateMethod instanceof ParameterizedMethodBinding) {", "-\t\t\t\tinfCtx = invocation.getInferenceContext((ParameterizedMethodBinding) candidateMethod);", "-\t\t\t\tif (infCtx != null) {", "-\t\t\t\t\tif (infCtx.stepCompleted != InferenceContext18.TYPE_INFERRED) {", "-\t\t\t\t\t\t// only work in the exact state of TYPE_INFERRED", "-\t\t\t\t\t\t// - below we're not yet ready", "-\t\t\t\t\t\t// - above we're already done-done", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\t}", "-\t\t\t\t\tvariableArity &= infCtx.isVarArgs(); // TODO: if no infCtx is available, do we have to re-check if this is a varargs invocation?", "-\t\t\t\t}", "-\t\t\t} else if (invocation instanceof AllocationExpression) {", "-\t\t\t\tif (((AllocationExpression)invocation).suspendedResolutionState != null)", "-\t\t\t\t\treturn; // not yet ready", "-\t\t\t}", "-\t\t\t", "-\t\t\tfinal TypeBinding[] parameters = candidateMethod.parameters;", "-\t\t\tExpression[] innerArguments = invocation.arguments();", "-\t\t\tExpression [] arguments = innerArguments;", "-\t\t\tif (infCtx == null && variableArity && arguments != null && parameters.length == arguments.length) { // re-check", "-\t\t\t\tTypeBinding lastParam = parameters[parameters.length-1];", "-\t\t\t\tExpression lastArg = arguments[arguments.length-1];", "-\t\t\t\tif (lastArg.isCompatibleWith(lastParam, null)) {", "-\t\t\t\t\tvariableArity = false;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tfor (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {", "-\t\t\t\tExpression argument = arguments[i];", "-\t\t\t\tTypeBinding updatedArgumentType = null;", "-\t\t\t\tTypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);", "-\t\t\t\tif (parameterType == null && problemReason != ProblemReasons.NoError)", "-\t\t\t\t\tcontinue; // not much we can do without a target type, assume it only happens after some resolve error", "-", "-\t\t\t\tif (argument instanceof LambdaExpression && ((LambdaExpression) argument).hasErrors())", "-\t\t\t\t\tcontinue; // don't update if inner poly has errors", "-", "-\t\t\t\tif (argument instanceof Invocation) {", "-\t\t\t\t\tInvocation innerInvocation = (Invocation)argument;", "-\t\t\t\t\tMethodBinding binding = innerInvocation.binding(parameterType, true, scope);", "-\t\t\t\t\tif (binding instanceof ParameterizedGenericMethodBinding) {", "-\t\t\t\t\t\tParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) binding;", "-\t\t\t\t\t\tInferenceContext18 innerContext = innerInvocation.getInferenceContext(parameterizedMethod);", "-\t\t\t\t\t\tif (innerContext != null) {", "-\t\t\t\t\t\t\tif (!innerContext.hasResultFor(parameterType)) {", "-\t\t\t\t\t\t\t\targument.setExpectedType(parameterType);", "-\t\t\t\t\t\t\t\tMethodBinding improvedBinding = innerContext.inferInvocationType(innerInvocation, parameterizedMethod);", "-\t\t\t\t\t\t\t\tif (!improvedBinding.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tinnerContext.reportInvalidInvocation(innerInvocation, improvedBinding);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (innerInvocation.updateBindings(improvedBinding, parameterType)) {", "-\t\t\t\t\t\t\t\t\tresolvePolyExpressionArguments(innerInvocation, improvedBinding, scope);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (innerContext.stepCompleted < InferenceContext18.BINDINGS_UPDATED) {", "-\t\t\t\t\t\t\t\tinnerContext.rebindInnerPolies(parameterizedMethod, innerInvocation);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcontinue; // otherwise these have been dealt with during inner method lookup", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\tif (argument.isPolyExpression()) {", "-\t\t\t\t\t// poly expressions in an invocation context may need to be resolved now:", "-\t\t\t\t\tif (infCtx != null && infCtx.stepCompleted == InferenceContext18.BINDINGS_UPDATED)", "-\t\t\t\t\t\tupdatedArgumentType = argument.resolvedType; // in this case argument was already resolved via InferenceContext18.acceptPendingPolyArguments()", "-\t\t\t\t\telse", "-\t\t\t\t\t\tupdatedArgumentType = argument.checkAgainstFinalTargetType(parameterType, scope);", "-", "-\t\t\t\t\tif (problemReason == ProblemReasons.NoError // preserve errors", "-\t\t\t\t\t\t\t&& updatedArgumentType != null\t\t\t\t\t// do we have a relevant update? ...", "-\t\t\t\t\t\t\t&& !(updatedArgumentType instanceof PolyTypeBinding))", "-\t\t\t\t\t{", "-\t\t\t\t\t\t// update the argumentTypes array (supposed to be owned by the calling method)", "-\t\t\t\t\t\t// in order to give better information for subsequent checks", "-\t\t\t\t\t\targumentTypes[i] = updatedArgumentType;", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\tboolean variableArity = candidateMethod.isVarargs();", "+\t\tfinal TypeBinding[] parameters = candidateMethod.parameters;", "+\t\tExpression[] arguments = invocation.arguments();", "+\t\tif (variableArity && arguments != null && parameters.length == arguments.length) {", "+\t\t\tif (arguments[arguments.length-1].isCompatibleWith(parameters[parameters.length-1], scope)) {", "+\t\t\t\tvariableArity = false;", "-\t\tinvocation.innerUpdateDone();", "-\t}", "+\t\tfor (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {", "+\t\t\tExpression argument = arguments[i];", "+\t\t\tTypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);", "+\t\t\tif (parameterType == null)", "+\t\t\t\tcontinue; // not much we can do without a target type, assume it only happens after some resolve error", "+\t\t\tif (argumentTypes[i].isPolyType()) {", "+\t\t\t\targument.setExpectedType(parameterType);", "+\t\t\t\tTypeBinding updatedArgumentType = argument.resolveType(scope); ", "+\t\t\t\tif (argument instanceof LambdaExpression) {", "+\t\t\t\t\t// LE.resolveType may return a valid binding because resolve does not detect structural errors at this point.", "+\t\t\t\t\tLambdaExpression lambda = (LambdaExpression) argument;", "+\t\t\t\t\tif (!lambda.isCompatibleWith(parameterType, scope) || lambda.hasErrors())", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tif (updatedArgumentType != null && updatedArgumentType.kind() != Binding.POLY_TYPE)", "+\t\t\t\t\targumentTypes[i] = updatedArgumentType;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e7ad51c8c06fbdb0a8ee698c4011016", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "09f42f58bcdf2fa84ccd2b8b65f28ab3036222ca", "commitAfterChange": "57e8dd41219d846363c918d62edb5007994c5c79", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tpublic static boolean resolvePolyExpressionArguments(Invocation invocation, BlockScope scope, MethodBinding methodBinding, TypeBinding[] argumentTypes)", "signatureAfterChange": " \tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes)", "diff": ["-\tpublic static boolean resolvePolyExpressionArguments(Invocation invocation, BlockScope scope, MethodBinding methodBinding, TypeBinding[] argumentTypes) {", "+\tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes) {", "-\t\tboolean hasUpdatedInner = false;", "+\t\t\tInferenceContext18 infCtx = null;", "+\t\t\tif (candidateMethod instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\tinfCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) candidateMethod);", "+\t\t\t\tif (infCtx != null) {", "+\t\t\t\t\tif (!infCtx.hasFinished)", "+\t\t\t\t\t\treturn; // not yet ready for pushing type information down to arguments", "+\t\t\t\t\tvariableArity &= infCtx.isVarArgs(); // TODO: if no infCtx is available, do we have to re-check if this is a varargs invocation?", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "-\t\t\tfinal int parametersLength = parameters.length;", "-\t\t\tExpression [] arguments = invocation.arguments();", "+\t\t\tExpression[] innerArguments = invocation.arguments();", "+\t\t\tExpression [] arguments = innerArguments;", "-\t\t\t\tTypeBinding parameterType = i < parametersLength ? parameters[i] : variableArity ? parameters[parametersLength - 1] : null;", "+\t\t\t\tTypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity); ", "-\t\t\t\tif (variableArity && i >= parametersLength - 1)", "-\t\t\t\t\targument.tagAsEllipsisArgument();", "-\t\t\t\tupdatedArgumentType = updateExpression(scope, argument, argumentTypes[i], parameterType, invocation.hasInferenceFinished());", "-\t\t\t\tif (updatedArgumentType == POLY_ERROR) //$IDENTITY-COMPARISON$", "+\t\t\t\tif (argument instanceof LambdaExpression && ((LambdaExpression) argument).hasErrors())", "-\t\t\t\tif (problemReason != ProblemReasons.Ambiguous \t// preserve this error", "-\t\t\t\t\t\t&& updatedArgumentType != null\t\t\t\t\t// do we have a relevant update? ...", "-\t\t\t\t\t\t&& !(updatedArgumentType instanceof PolyTypeBinding)", "-\t\t\t\t\t\t&& TypeBinding.notEquals(updatedArgumentType, argumentTypes[i]))", "-\t\t\t\t{", "-\t\t\t\t\t// update the argumentTypes array (supposed to be owned by the calling method)", "-\t\t\t\t\t// in order to give better information into a second round of method lookup:", "-\t\t\t\t\targumentTypes[i] = updatedArgumentType;", "-\t\t\t\t\thasUpdatedInner = true;", "+", "+\t\t\t\tif (argument instanceof Invocation) {", "+\t\t\t\t\tInvocation innerInvocation = (Invocation)argument;", "+\t\t\t\t\tMethodBinding binding = innerInvocation.binding();", "+\t\t\t\t\tif (binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\t\t\tParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) binding;", "+\t\t\t\t\t\tInferenceContext18 innerContext = innerInvocation.getInferenceContext(parameterizedMethod);", "+\t\t\t\t\t\tif (innerContext != null && !innerContext.hasFinished) {\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\targument.setExpectedType(parameterType);", "+\t\t\t\t\t\t\tTypeBinding[] innerArgumentTypes = null;", "+\t\t\t\t\t\t\tif (innerArguments != null) {", "+\t\t\t\t\t\t\t\tinnerArgumentTypes = new TypeBinding[innerArguments.length];", "+\t\t\t\t\t\t\t\tfor (int j = 0; j < innerArguments.length; j++)", "+\t\t\t\t\t\t\t\t\tinnerArgumentTypes[i] = innerArguments[i].resolvedType;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tMethodBinding improvedBinding = innerContext.inferInvocationType(innerInvocation, innerArgumentTypes, parameterizedMethod);", "+\t\t\t\t\t\t\tinnerInvocation.updateBindings(improvedBinding);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcontinue; // otherwise these have been dealt with during inner method lookup", "+\t\t\t\t\t}", "+\t\t\t\t}", "+", "+\t\t\t\tif (argument.isPolyExpression()) {", "+\t\t\t\t\t// poly expressions in an invocation context need to be resolved now:", "+\t\t\t\t\tupdatedArgumentType = argument.checkAgainstFinalTargetType(parameterType);", "+", "+\t\t\t\t\tif (problemReason == ProblemReasons.NoError // preserve errors", "+\t\t\t\t\t\t\t&& updatedArgumentType != null\t\t\t\t\t// do we have a relevant update? ...", "+\t\t\t\t\t\t\t&& !(updatedArgumentType instanceof PolyTypeBinding))", "+\t\t\t\t\t{", "+\t\t\t\t\t\t// update the argumentTypes array (supposed to be owned by the calling method)", "+\t\t\t\t\t\t// in order to give better information for subsequent checks", "+\t\t\t\t\t\targumentTypes[i] = updatedArgumentType;", "+\t\t\t\t\t}", "-\t\treturn hasUpdatedInner;", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a2bde0fe4424fecccf4bea68c48b4ee0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  \tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method)", "signatureAfterChange": "  \tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method, boolean interleaved) throws InferenceFailureException", "diff": ["-\tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method) {", "+\tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method, boolean interleaved) throws InferenceFailureException {", "+\t\t", "+\t\t// See https://bugs.openjdk.java.net/browse/JDK-8052325 for exclusion of poly expressions targeting proper types. CEF.reduce validates ", "+\t\t// that they are compatible in a loose invocation context against the target type. They contribute nothing further to solving the formulas.", "+\t\tif (substF.isProperType(true))", "+\t\t\treturn true;", "+\t\t", "+\t\t\tif (expri instanceof LambdaExpression) {", "+\t\t\t\tLambdaExpression lambda = (LambdaExpression) expri;", "+\t\t\t\tBlockScope skope = lambda.enclosingScope;", "+\t\t\t\tif (substF.isFunctionalInterface(skope)) { // could be an inference variable.", "+\t\t\t\t\tReferenceBinding t = (ReferenceBinding) substF;", "+\t\t\t\t\tParameterizedTypeBinding withWildCards = InferenceContext18.parameterizedWithWildcard(t);", "+\t\t\t\t\tif (withWildCards != null) {", "+\t\t\t\t\t\tt = ConstraintExpressionFormula.findGroundTargetType(this, skope, lambda, withWildCards);", "+\t\t\t\t\t}", "+\t\t\t\t\tMethodBinding functionType;", "+\t\t\t\t\tif (t != null && (functionType = t.getSingleAbstractMethod(skope, true)) != null && (lambda = lambda.getResolvedCopyForInferenceTargeting(t)) != null) {", "+\t\t\t\t\t\tTypeBinding r = functionType.returnType;", "+\t\t\t\t\t\tExpression[] resultExpressions = lambda.resultExpressions();", "+\t\t\t\t\t\tfor (int i = 0, length = resultExpressions == null ? 0 : resultExpressions.length; i < length; i++) {", "+\t\t\t\t\t\t\tExpression resultExpression = resultExpressions[i];", "+\t\t\t\t\t\t\tif (!addConstraintsToC_OneExpr(resultExpression, c, r.original(), r, method, true))", "+\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "-\t\t\tMethodBinding innerMethod = invocation.binding(null, false, null);", "+\t\t\tMethodBinding innerMethod = invocation.binding(substF, this.scope);", "+\t\t\tif (innerMethod == null)", "+\t\t\t\treturn true; \t\t  // -> proceed with no new C set elements.", "+\t\t\t", "+\t\t\tif (interleaved) {", "+\t\t\t\tMethodBinding shallowMethod = innerMethod.shallowOriginal();", "+\t\t\t\tSuspendedInferenceRecord prevInvocation = enterPolyInvocation(invocation, invocation.arguments());", "+\t\t\t\ttry {", "+\t\t\t\t\tExpression[] arguments = invocation.arguments();", "+\t\t\t\t\tTypeBinding[] argumentTypes = arguments == null ? Binding.NO_PARAMETERS : new TypeBinding[arguments.length];", "+\t\t\t\t\tfor (int i = 0; i < argumentTypes.length; i++)", "+\t\t\t\t\t\targumentTypes[i] = arguments[i].resolvedType;", "+\t\t\t\t\tif (innerMethod instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\t\t\tInferenceContext18 innerCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) innerMethod);", "+\t\t\t\t\t\tthis.inferenceKind = innerCtx.inferenceKind;", "+\t\t\t\t\t}", "+\t\t\t\t\tinferInvocationApplicability(shallowMethod, argumentTypes, shallowMethod.isConstructor());", "+\t\t\t\t\tif (!ConstraintExpressionFormula.inferPolyInvocationType(this, invocation, substF, shallowMethod))", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t} finally {", "+\t\t\t\t\tresumeSuspendedInference(prevInvocation);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tint applicabilityKind = CHECK_LOOSE;  // FIXME, for <> resolving to a non-generic method, this need to be computed.", "-\t\t\t\tif (innerCtx != null) { // otherwise innerMethod does not participate in inference", "-\t\t\t\t\treturn addConstraintsToC(invocation.arguments(), c, innerMethod.genericMethod(), innerCtx.inferenceKind);", "+\t\t\t\tif (innerCtx != null) {", "+\t\t\t\t\tapplicabilityKind = innerCtx.inferenceKind;", "+\t\t\treturn addConstraintsToC(invocation.arguments(), c, innerMethod.genericMethod(), applicabilityKind, interleaved);", "-\t\t\treturn addConstraintsToC_OneExpr(ce.valueIfTrue, c, fsi, substF, method)", "-\t\t\t\t && addConstraintsToC_OneExpr(ce.valueIfFalse, c, fsi, substF, method);", "+\t\t\treturn addConstraintsToC_OneExpr(ce.valueIfTrue, c, fsi, substF, method, interleaved)", "+\t\t\t\t\t&& addConstraintsToC_OneExpr(ce.valueIfFalse, c, fsi, substF, method, interleaved);", "-\t}"]}], "num": 55568}