{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b2b0f4eb13aef1ca048540780466ed67", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b8add37103e9d27815389ba434bf00f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "09f42f58bcdf2fa84ccd2b8b65f28ab3036222ca", "commitAfterChange": "57e8dd41219d846363c918d62edb5007994c5c79", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tpublic void rebindInnerPolies(BoundSet bounds, TypeBinding[] argumentTypes)", "signatureAfterChange": " \tpublic void rebindInnerPolies(BoundSet bounds, TypeBinding[] parameterTypes)", "diff": ["-\tpublic void rebindInnerPolies(BoundSet bounds, TypeBinding[] argumentTypes) {", "+\tpublic void rebindInnerPolies(BoundSet bounds, TypeBinding[] parameterTypes) {", "+\t\t// This updates all remaining poly expressions that are direct arguments of the current invocation:", "+\t\t// (handles FunctionalExpression & ConditionalExpression)", "+\t\tacceptPendingPolyArguments(bounds, parameterTypes, this.inferenceKind == CHECK_VARARG);", "+\t\t// This loops over all poly expressions for which a sub-inference was triggered:", "+\t\t// (handles generic invocations)", "-\t\t\t\t// apply inference results onto the binding of the inner invocation:", "+\t\t\t\t// apply results of the combined inference onto the binding of the inner invocation:", "-\t\t\t\tinnerMessage.updateBindings(innerBinding);", "-\t\t\t\tinnerMessage.markInferenceFinished(); // invocation type inference has already happened on the inner, too.", "-\t\t\t\t// finalize resolving of arguments of the inner invocation:", "-\t\t\t\tTypeBinding[] innerParameters = innerBinding.parameters;", "-\t\t\t\tint inferenceKind = innerMessage.inferenceKind();", "-\t\t\t\tboolean isVarargs = (inferenceKind == CHECK_VARARG) && innerBinding.isVarargs();", "-\t\t\t\tTypeBinding varArgsType = isVarargs ? ((ArrayBinding)innerParameters[innerParameters.length-1]).elementsType() : null; ", "-\t\t\t\tExpression[] arguments = innerMessage.arguments();", "-\t\t\t\tif (arguments != null) {", "-\t\t\t\t\tfor (int j = 0; j < arguments.length; j++) {", "-\t\t\t\t\t\tTypeBinding param = (varArgsType == null || (j < innerParameters.length-1))", "-\t\t\t\t\t\t\t\t\t\t\t\t? innerParameters[j]", "-\t\t\t\t\t\t\t\t\t\t\t\t: varArgsType;", "-\t\t\t\t\t\targuments[j].checkAgainstFinalTargetType(param);", "+\t\t\t\tif (innerMessage.updateBindings(innerBinding)) { // only if we are actually improving anything", "+\t\t\t\t\tTypeBinding[] innerArgumentTypes = null;", "+\t\t\t\t\tExpression[] innerArguments = innerMessage.arguments();", "+\t\t\t\t\tif (innerArguments != null) {", "+\t\t\t\t\t\tinnerArgumentTypes = new TypeBinding[innerArguments.length];", "+\t\t\t\t\t\tfor (int j = 0; j < innerArguments.length; j++)", "+\t\t\t\t\t\t\tinnerArgumentTypes[i] = innerArguments[i].resolvedType;", "+\t\t\t\t\tASTNode.resolvePolyExpressionArguments(innerMessage, innerBinding, innerArgumentTypes);", "-\t\t\t// inner FunctionalExpression don't seem to be included in inference.", "-\t\t\t// TODO recheck any inquires on those actually involve inference of which the results are included here. "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bb6a95c79e93367e76ec8adf2483c107", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java", "commitBeforeChange": "fb551e71f8331e7335b6496578d819b690109f3c", "commitAfterChange": "02112ae5d67523cea52b946942bd13130a946a0e", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": "  public void resolve(IGenericType suppliedType)", "signatureAfterChange": "  public void resolve(IGenericType suppliedType)", "diff": ["+\t\t\tthis.superTypesOnly = true;", "-\t\t\t// must start with the top level type", "-\t\t\tISourceType topLevelType = (ISourceType) suppliedType;", "-\t\t\twhile (topLevelType.getEnclosingType() != null)", "-\t\t\t\ttopLevelType = topLevelType.getEnclosingType();", "-\t\t\tCompilationResult result = new CompilationResult(topLevelType.getFileName(), 1, 1, this.options.maxProblemsPerUnit);", "-\t\t\tCompilationUnitDeclaration unit =", "-\t\t\t\tSourceTypeConverter.buildCompilationUnit(", "-\t\t\t\t\tnew ISourceType[]{topLevelType}, ", "-\t\t\t\t\t// no need for field and methods", "-\t\t\t\t\tSourceTypeConverter.MEMBER_TYPE, // need member types", "-\t\t\t\t\t// no need for field initialization", "-\t\t\t\t\tthis.lookupEnvironment.problemReporter, ", "-\t\t\t\t\tresult);", "-", "-\t\t\tif (unit != null) {", "-\t\t\t\tthis.lookupEnvironment.buildTypeBindings(unit);", "-", "-\t\t\t\torg.eclipse.jdt.core.ICompilationUnit cu = ((SourceTypeElementInfo)topLevelType).getHandle().getCompilationUnit();", "-\t\t\t\trememberAllTypes(unit, cu, false);", "-", "-\t\t\t\tthis.lookupEnvironment.completeTypeBindings(unit, false);", "-", "-\t\t\t\treportHierarchy(this.requestor.getType(), unit, null);", "-\t\t\t}", "+\t\t\torg.eclipse.jdt.core.ICompilationUnit cu = ((SourceTypeElementInfo)suppliedType).getHandle().getCompilationUnit();", "+\t\t\tHashSet localTypes = new HashSet();", "+\t\t\tlocalTypes.add(cu.getPath().toString());", "+\t\t\tthis.superTypesOnly = true;", "+\t\t\tresolve(new Openable[] {(Openable)cu}, localTypes, null);"]}], "num": 679}