{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "98d589bcfe899933a243f5104941d0d1", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "28dbbdc6309ddf98c32b2c43a0a03818", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "4748f10b5a3e791bc8e4784d261c474bbab1449a", "commitAfterChange": "c3bed616fda9d34c9c223290e9dda976cadf693c", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprivate boolean connectSuperInterfaces()", "signatureAfterChange": " \tprivate boolean connectSuperInterfaces()", "diff": ["-\t\t\t\t\tReferenceBinding match = sourceType.superclass.findSuperTypeWithSameErasure(superInterface);", "-\t\t\t\t\tif (match != null && match != superInterface) {", "-\t\t\t\t\t\tproblemReporter().superinterfacesCollide(superInterface.erasure(), referenceContext, superInterface, match);", "-\t\t\t\t\t\tsourceType.tagBits |= HierarchyHasProblems;", "-\t\t\t\t\t\tnoProblems = false;", "-\t\t\t\t\t\tcontinue nextInterface;", "-\t\t\t\t\t}", "+\t\t\t\t\ttypes[0] = sourceType.superclass;", "+\t\t\t\t\ttypes[1] = superInterface;", "+\t\t\t\t\tTypeBinding[] mecs = minimalErasedCandidates(types, invocations);", "+\t\t\t\t\tif (mecs != null) {", "+\t\t\t\t\t\tnextCandidate: for (int k = 0, max = mecs.length; k < max; k++) {", "+\t\t\t\t\t\t\tTypeBinding mec = mecs[k];", "+\t\t\t\t\t\t\tif (mec == null) continue nextCandidate;", "+\t\t\t\t\t\t\tSet invalidInvocations = (Set)invocations.get(mec);", "+\t\t\t\t\t\t\tint invalidSize = invalidInvocations.size();", "+\t\t\t\t\t\t\tif (invalidSize > 1) {", "+\t\t\t\t\t\t\t\tTypeBinding[] collisions;", "+\t\t\t\t\t\t\t\tinvalidInvocations.toArray(collisions = new TypeBinding[invalidSize]);", "+\t\t\t\t\t\t\t\tproblemReporter().superinterfacesCollide(collisions[0].erasure(), referenceContext, collisions[0], collisions[1]);", "+\t\t\t\t\t\t\t\tsourceType.tagBits |= HierarchyHasProblems;", "+\t\t\t\t\t\t\t\tnoProblems = false;", "+\t\t\t\t\t\t\t\tcontinue nextInterface;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\t\t}\t\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4484c9be666585bc66b3b6f31ff0ef0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "f908d0c09b5bf34a0f6e90dacd8d551c0f19870c", "commitAfterChange": "2d9e2019b5b59684e0488ab5bab1ae5850c1ca71", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \t \tprotected boolean connectTypeVariables(TypeParameter[] typeParameters)", "signatureAfterChange": " \t \tprotected boolean connectTypeVariables(TypeParameter[] typeParameters)", "diff": ["-", "+\t\tTypeBinding[] types = new TypeBinding[2];", "+\t\tMap invocations = new HashMap(2);", "-\t\t\t\ttypeVariable.modifiers |= AccInterface;", "-", "+\t\t\t\t\ttypes[0] = superType;", "-\t\t\t\t\tif (superType.isParameterizedType()) {", "+\t\t\t\t\t// check against superclass", "+\t\t\t\t\tif (typeVariable.firstBound == typeVariable.superclass) {", "-\t\t\t\t\t\tboolean isCollision = match != null && match != superType;", "-\t\t\t\t\t\tfor (int index = typeVariable.superInterfaces.length; !isCollision && --index >= 0;) {", "-\t\t\t\t\t\t\tReferenceBinding temp = typeVariable.superInterfaces[index];", "-\t\t\t\t\t\t\tisCollision = superType != temp && superType.erasure() == temp.erasure();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (isCollision) {", "-\t\t\t\t\t\t\tproblemReporter().boundHasConflictingArguments(typeRef, superType);", "+\t\t\t\t\t\tif (match != null && match != superType) {", "+\t\t\t\t\t\t\tproblemReporter().superinterfacesCollide(superType.erasure(), typeRef, superType, match);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t// check against superinterfaces", "-\t\t\t\t\t\tif (superType.erasure() == typeVariable.superInterfaces[index].erasure()) {", "+\t\t\t\t\t\tReferenceBinding previousInterface = typeVariable.superInterfaces[index];", "+\t\t\t\t\t\tif (previousInterface == superRefType) {", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\ttypes[1] = previousInterface;", "+\t\t\t\t\t\tinvocations.clear();", "+\t\t\t\t\t\tTypeBinding[] mecs = minimalErasedCandidates(types, invocations);", "+\t\t\t\t\t\tif (mecs != null) {", "+\t\t\t\t\t\t\tnextCandidate: for (int m = 0, max = mecs.length; m < max; m++) {", "+\t\t\t\t\t\t\t\tTypeBinding mec = mecs[m];", "+\t\t\t\t\t\t\t\tif (mec == null) continue nextCandidate;", "+\t\t\t\t\t\t\t\tSet invalidInvocations = (Set)invocations.get(mec);", "+\t\t\t\t\t\t\t\tint invalidSize = invalidInvocations.size();", "+\t\t\t\t\t\t\t\tif (invalidSize > 1) {", "+\t\t\t\t\t\t\t\t\tTypeBinding[] collisions;", "+\t\t\t\t\t\t\t\t\tinvalidInvocations.toArray(collisions = new TypeBinding[invalidSize]);", "+\t\t\t\t\t\t\t\t\tproblemReporter().superinterfacesCollide(collisions[0].erasure(), typeRef, collisions[0], collisions[1]);", "+\t\t\t\t\t\t\t\t\ttypeVariable.tagBits |= HierarchyHasProblems;", "+\t\t\t\t\t\t\t\t\tnoProblems = false;", "+\t\t\t\t\t\t\t\t\tcontinue nextVariable;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}\t\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ba6f6146c32ccde4d35ea9920fac9019", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "4748f10b5a3e791bc8e4784d261c474bbab1449a", "commitAfterChange": "c3bed616fda9d34c9c223290e9dda976cadf693c", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \t \tprotected boolean connectTypeVariables(TypeParameter[] typeParameters)", "signatureAfterChange": " \t \tprotected boolean connectTypeVariables(TypeParameter[] typeParameters)", "diff": ["-\t\t\t\tfor (int j = 0, k = boundRefs.length; j < k; j++) {", "+\t\t\t\tfor (int j = 0, boundLength = boundRefs.length; j < boundLength; j++) {", "-\t\t\t\t\t\tReferenceBinding match = typeVariable.superclass.findSuperTypeWithSameErasure(superType);", "-\t\t\t\t\t\tif (match != null && match != superType) {", "-\t\t\t\t\t\t\tproblemReporter().superinterfacesCollide(superType.erasure(), typeRef, superType, match);", "-\t\t\t\t\t\t\ttypeVariable.tagBits |= HierarchyHasProblems;", "-\t\t\t\t\t\t\tnoProblems = false;", "-\t\t\t\t\t\t\tcontinue nextVariable;", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t\ttypes[1] = typeVariable.superclass;", "+\t\t\t\t\t\tTypeBinding[] mecs = minimalErasedCandidates(types, invocations);", "+\t\t\t\t\t\tif (mecs != null) {", "+\t\t\t\t\t\t\tnextCandidate: for (int k = 0, max = mecs.length; k < max; k++) {", "+\t\t\t\t\t\t\t\tTypeBinding mec = mecs[k];", "+\t\t\t\t\t\t\t\tif (mec == null) continue nextCandidate;", "+\t\t\t\t\t\t\t\tSet invalidInvocations = (Set)invocations.get(mec);", "+\t\t\t\t\t\t\t\tint invalidSize = invalidInvocations.size();", "+\t\t\t\t\t\t\t\tif (invalidSize > 1) {", "+\t\t\t\t\t\t\t\t\tTypeBinding[] collisions;", "+\t\t\t\t\t\t\t\t\tinvalidInvocations.toArray(collisions = new TypeBinding[invalidSize]);", "+\t\t\t\t\t\t\t\t\tproblemReporter().superinterfacesCollide(collisions[0].erasure(), typeRef, collisions[1], collisions[0]); // swap collisions since mec types got swapped", "+\t\t\t\t\t\t\t\t\ttypeVariable.tagBits |= HierarchyHasProblems;", "+\t\t\t\t\t\t\t\t\tnoProblems = false;", "+\t\t\t\t\t\t\t\t\tcontinue nextVariable;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}\t\t\t", "+\t\t\t\t\t\t}"]}], "num": 72851}