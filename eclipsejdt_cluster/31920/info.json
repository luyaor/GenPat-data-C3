{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "41fb863abfa89ae00979ee4b84762948", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5706aafbbdae95344c8e25ce5d306904", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "5daf90a164d16969119f51284ec69f74248f815c", "commitAfterChange": "88ba045d7ed9cf0766b43baca6283d95ae96a725", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "  protected void writeClassFileBytes(byte[] bytes, IFile file, String qualifiedFileName, boolean isTopLevelType, boolean updateClassFile) throws CoreException", "signatureAfterChange": "  protected void writeClassFileBytes(byte[] bytes, IFile file, String qualifiedFileName, boolean isTopLevelType, SourceFile compilationUnit) throws CoreException", "diff": ["-protected void writeClassFileBytes(byte[] bytes, IFile file, String qualifiedFileName, boolean isTopLevelType, boolean updateClassFile) throws CoreException {", "+protected void writeClassFileBytes(byte[] bytes, IFile file, String qualifiedFileName, boolean isTopLevelType, SourceFile compilationUnit) throws CoreException {", "-\t// If structural changes occured then add dependent source files", "+\t// If structural changes occurred then add dependent source files", "-\t\tif (writeClassFileCheck(file, qualifiedFileName, bytes) || updateClassFile) { // see 46093", "+\t\tif (writeClassFileCheck(file, qualifiedFileName, bytes) || compilationUnit.updateClassFile) { // see 46093", "-\t\t\tif (e.getStatus().getCode() == IResourceStatus.CASE_VARIANT_EXISTS)", "-\t\t\t\t// catch the case that a nested type has been renamed and collides on disk with an as-yet-to-be-deleted type", "+\t\t\tif (e.getStatus().getCode() == IResourceStatus.CASE_VARIANT_EXISTS) {", "+\t\t\t\tIStatus status = e.getStatus();", "+\t\t\t\tif (status instanceof IResourceStatus) {", "+\t\t\t\t\tIPath oldFilePath = ((IResourceStatus) status).getPath();", "+\t\t\t\t\tchar[] oldTypeName = oldFilePath.removeFileExtension().lastSegment().toCharArray();", "+\t\t\t\t\tchar[][] previousTypeNames = newState.getDefinedTypeNamesFor(compilationUnit.typeLocator());", "+\t\t\t\t\tboolean fromSameFile = false;", "+\t\t\t\t\tif (previousTypeNames == null) {", "+\t\t\t\t\t\tfromSameFile = CharOperation.equals(compilationUnit.getMainTypeName(), oldTypeName);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfor (int i = 0, l = previousTypeNames.length; i < l; i++) {", "+\t\t\t\t\t\t\tif (CharOperation.equals(previousTypeNames[i], oldTypeName)) {", "+\t\t\t\t\t\t\t\tfromSameFile = true;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (fromSameFile) {", "+\t\t\t\t\t\t// file is defined by the same compilationUnit, but won't be deleted until later so do it now", "+\t\t\t\t\t\tIFile collision = file.getParent().getFile(new Path(oldFilePath.lastSegment()));", "+\t\t\t\t\t\tcollision.delete(true, false, null);", "+\t\t\t\t\t\tboolean success = false;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tfile.create(new ByteArrayInputStream(bytes), IResource.FORCE | IResource.DERIVED, null);", "+\t\t\t\t\t\t\tsuccess = true;", "+\t\t\t\t\t\t} catch (CoreException ignored) {", "+\t\t\t\t\t\t\t// ignore the second exception", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (success) return;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// catch the case that a type has been renamed and collides on disk with an as-yet-to-be-deleted type", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "752b67db1ffcfb94e7430f28ecbfbb74", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "cdf4427e144add1a36f3939b37283556991d4db8", "commitAfterChange": "75f702ac7a9f5b98d8daf289140c0d700af63244", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspathEntry(IJavaProject javaProject, IClasspathEntry entry, boolean checkSourceAttachment)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspathEntry(IJavaProject project, IClasspathEntry entry, boolean checkSourceAttachment)", "diff": ["-\tpublic static IJavaModelStatus validateClasspathEntry(IJavaProject javaProject, IClasspathEntry entry, boolean checkSourceAttachment){", "+\tpublic static IJavaModelStatus validateClasspathEntry(IJavaProject project, IClasspathEntry entry, boolean checkSourceAttachment){", "-\t\t\t\t\t\tIClasspathContainer container = JavaCore.getClasspathContainer(path, javaProject);", "+\t\t\t\t\t\tIClasspathContainer container = JavaCore.getClasspathContainer(path, project);", "-\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.CP_CONTAINER_PATH_UNBOUND, javaProject, path);", "+\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.CP_CONTAINER_PATH_UNBOUND, project, path);", "-\t\t\t\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CP_CONTAINER_ENTRY, javaProject, path);", "+\t\t\t\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CP_CONTAINER_ENTRY, project, path);", "-\t\t\t\t\t\t\t\tIJavaModelStatus containerEntryStatus = validateClasspathEntry(javaProject, containerEntry, checkSourceAttachment);", "+\t\t\t\t\t\t\t\tIJavaModelStatus containerEntryStatus = validateClasspathEntry(project, containerEntry, checkSourceAttachment);", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND, javaProject, path);", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND, project, path);", "-\t\t\t\t\treturn validateClasspathEntry(javaProject, entry, checkSourceAttachment);", "+\t\t\t\t\treturn validateClasspathEntry(project, entry, checkSourceAttachment);", "+\t\t\t\t\tif (target != null && project.getOption(JavaCore.CORE_INCOMPATIBLE_JDK_LEVEL, true) != JavaCore.IGNORE) {", "+\t\t\t\t\t\tlong projectTargetJDK = CompilerOptions.versionToJdkLevel(project.getOption(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, true));", "+\t\t\t\t\t\tlong libraryJDK = Util.getJdkLevel(target);", "+\t\t\t\t\t\tif (libraryJDK != 0 && libraryJDK > projectTargetJDK) {", "+\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INCOMPATIBLE_JDK_LEVEL, project, path, CompilerOptions.versionFromJdkLevel(libraryJDK)); ", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\t\tIProject project = workspaceRoot.getProject(path.segment(0));", "+\t\t\t\t\tIProject prereqProjectRsc = workspaceRoot.getProject(path.segment(0));", "+\t\t\t\t\tIJavaProject prereqProject = JavaCore.create(prereqProjectRsc);", "-\t\t\t\t\t\tif (!project.exists() || !project.hasNature(JavaCore.NATURE_ID)){", "+\t\t\t\t\t\tif (!prereqProjectRsc.exists() || !prereqProjectRsc.hasNature(JavaCore.NATURE_ID)){", "-\t\t\t\t\t\tif (!project.isOpen()){", "+\t\t\t\t\t\tif (!prereqProjectRsc.isOpen()){", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (project.getOption(JavaCore.CORE_INCOMPATIBLE_JDK_LEVEL, true) != JavaCore.IGNORE) {", "+\t\t\t\t\t\t\tlong projectTargetJDK = CompilerOptions.versionToJdkLevel(project.getOption(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, true));", "+\t\t\t\t\t\t\tlong prereqProjectTargetJDK = CompilerOptions.versionToJdkLevel(prereqProject.getOption(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, true));", "+\t\t\t\t\t\t\tif (prereqProjectTargetJDK > projectTargetJDK) {", "+\t\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INCOMPATIBLE_JDK_LEVEL, project, path, CompilerOptions.versionFromJdkLevel(prereqProjectTargetJDK)); ", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t&& JavaCore.DISABLED.equals(javaProject.getOption(JavaCore.CORE_ENABLE_CLASSPATH_EXCLUSION_PATTERNS, true))) {", "+\t\t\t\t\t\t&& JavaCore.DISABLED.equals(project.getOption(JavaCore.CORE_ENABLE_CLASSPATH_EXCLUSION_PATTERNS, true))) {", "-\t\t\t\tif (entry.getOutputLocation() != null && JavaCore.DISABLED.equals(javaProject.getOption(JavaCore.CORE_ENABLE_CLASSPATH_MULTIPLE_OUTPUT_LOCATIONS, true))) {", "+\t\t\t\tif (entry.getOutputLocation() != null && JavaCore.DISABLED.equals(project.getOption(JavaCore.CORE_ENABLE_CLASSPATH_MULTIPLE_OUTPUT_LOCATIONS, true))) {", "-\t\t\t\t\tIPath projectPath= javaProject.getProject().getFullPath();", "+\t\t\t\t\tIPath projectPath= project.getProject().getFullPath();"]}], "num": 31920}