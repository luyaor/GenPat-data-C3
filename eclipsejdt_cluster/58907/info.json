{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "11336dd4b5ab1b839a22f1018644e753", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26849bb51aa682182edf5643c0ccb1de", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "457fc77ec96140a15fc3e1c18bbf7bf53c7ea1c9", "commitAfterChange": "44074e366655e2cf89768617c1e64463f5949123", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": " int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean isPatternSourceType, int depth, MatchLocator locator)", "signatureAfterChange": " protected int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator)", "diff": ["-int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean isPatternSourceType, int depth, MatchLocator locator) {", "+protected int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator) {", "+\t// We can only refine if locator has an unit scope.", "+\tif (locator.unitScope == null) return accuracy;", "+", "+\t// Refine accuracy using binding and pattern arguments", "+\tchar[][] patternArguments = (patternTypeArguments==null) ? null : patternTypeArguments[depth];", "+\tint refinedAccuracy = refineAccuracy(accuracy, parameterizedBinding.arguments, locator, patternArguments, patternHasTypeParameters);", "+\tif (refinedAccuracy == SearchPattern.R_ERASURE_MATCH) {", "+\t\treturn SearchPattern.R_ERASURE_MATCH;", "+\t}", "+", "+\t// Recurse refining on enclosing types if any", "+\tTypeBinding enclosingType = parameterizedBinding.enclosingType();", "+\tif (enclosingType != null && (enclosingType.isParameterizedType() || enclosingType.isRawType())) {", "+\t\tif (patternTypeArguments == null || (depth+1)<patternTypeArguments.length) {", "+\t\t\treturn refineAccuracy(refinedAccuracy, (ParameterizedTypeBinding)enclosingType, patternTypeArguments, patternHasTypeParameters, depth+1, locator);", "+\t\t}", "+\t}", "+\t", "+\t// Refine the accuracy to accurate", "+\treturn refinedAccuracy;", "+}", "-\tint patternTypeArgsLength = (patternTypeArguments==null || depth>=patternTypeArguments.length || patternTypeArguments[depth] == null) ? 0 : patternTypeArguments[depth].length;", "-\tTypeBinding[] argumentsBinding = parameterizedBinding.arguments;", "-\t\t\tif (isPatternSourceType) { // raw source type pattern is always compatible erasure...", "-\t\t\tif (isPatternSourceType) {", "-\t\t\tif (patternTypeArguments == null || depth < patternTypeArguments.length) {", "-\t\t\t\t// if valid type arguments, then it is always compatible erasure except if accuracy has been already refined", "-\t\t\t\tif (refinedAccuracy <= SearchMatch.A_INACCURATE)", "-\t\t\t\t\trefinedAccuracy |= RAW_MASK;", "-//\tint refinedAccuracy = SearchMatch.A_ACCURATE;", "-\tif (!isPatternSourceType) {", "-\t\t\tchar[] patternTypeArgument = patternTypeArguments[depth][i];", "-\t// Recurse refining on enclosing types if any", "-\tTypeBinding enclosingType = parameterizedBinding.enclosingType();", "-\tif (enclosingType != null && (enclosingType.isParameterizedType() || enclosingType.isRawType())) {", "-\t\treturn refineAccuracy(refinedAccuracy, (ParameterizedTypeBinding)enclosingType, patternTypeArguments, isPatternSourceType, depth+1, locator);", "-\t}", "-\t", "-\t// Refine the accuracy to accurate"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8cb07a6300f68a3de510e721a065bd46", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "9ee78f50bb7fb9d70095ea7ff2d9f2e27d840c37", "commitAfterChange": "b6410432af18704990f18fa69a09dd7a76e8fb04", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " protected int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator)", "signatureAfterChange": " protected void updateMatch(ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator)", "diff": ["-}", "-protected int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator) {", "-\t// We can only refine if locator has an unit scope.", "-\tif (locator.unitScope == null) return accuracy;", "-", "-\t// Refine accuracy using binding and pattern arguments", "-\tchar[][] patternArguments = (patternTypeArguments==null) ? null : patternTypeArguments[depth];", "-\tint refinedAccuracy = refineAccuracy(accuracy, parameterizedBinding.arguments, locator, patternArguments, patternHasTypeParameters);", "-\tif (refinedAccuracy == SearchPattern.R_ERASURE_MATCH) {", "-\t\treturn SearchPattern.R_ERASURE_MATCH;", "-", "-\t// Recurse refining on enclosing types if any", "-\tTypeBinding enclosingType = parameterizedBinding.enclosingType();", "-\tif (enclosingType != null && (enclosingType.isParameterizedType() || enclosingType.isRawType())) {", "-\t\tif (patternTypeArguments == null || (depth+1)<patternTypeArguments.length) {", "-\t\t\treturn refineAccuracy(refinedAccuracy, (ParameterizedTypeBinding)enclosingType, patternTypeArguments, patternHasTypeParameters, depth+1, locator);", "-\t\t}", "-\t}", "-\t", "-\t// Refine the accuracy to accurate", "-\treturn refinedAccuracy;", "+protected void updateMatch(ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator) {", "+\t// Only possible if locator has an unit scope.", "+\tif (locator.unitScope == null) return;", "+", "+\t// Set match raw flag", "+\tboolean endPattern = depth>=patternTypeArguments.length;", "+\tchar[][] patternArguments = (patternTypeArguments==null || endPattern) ? null : patternTypeArguments[depth];", "+\tboolean isRaw = parameterizedBinding.isRawType()|| (parameterizedBinding.arguments==null && parameterizedBinding.type.isGenericType());", "+\tif (isRaw && !match.isRaw()) {", "+\t\tmatch.setRaw(isRaw);", "+\t}", "+\t", "+\t// Update match", "+\tif (!endPattern) {", "+\t\tupdateMatch(parameterizedBinding.arguments, locator, patternArguments, patternHasTypeParameters);", "+\t}", "+", "+\t// Recurse", "+\tTypeBinding enclosingType = parameterizedBinding.enclosingType();", "+\tif (enclosingType != null && (enclosingType.isParameterizedType() || enclosingType.isRawType())) {", "+\t\tupdateMatch((ParameterizedTypeBinding)enclosingType, patternTypeArguments, patternHasTypeParameters, depth+1, locator);", "+\t}", "+}"]}], "num": 58907}