{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "439c794e171959f4fb223dc50b17172a", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34567f66a32cf1b129cbb5fc4f3a5642", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "d5b9ab15bb3f769b7e2ac485fe6da55027818828", "commitAfterChange": "e98478cd38caef5e23457b8b0fdc364bf2846afc", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t\t  \tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException", "signatureAfterChange": "  \tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException", "diff": ["+\tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException {", "+", "+\t\tint modulo = 0; // should be 2 for (Type,Type,...) and 3 for (Type arg,Type arg,...)", "+\t\tint iToken = 0;", "+\t\tchar[] argName = null;", "+\t\tint ptr = astPtr;", "+\t\tint lptr = astLengthPtr;", "+", "+\t\t// Parse arguments declaration if method reference", "+\t\tnextArg : while (this.index < this.scanner.eofPosition) {", "+", "+\t\t\t// Read argument type reference", "+\t\t\tint argStart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\tTypeReference typeRef;", "+\t\t\ttry {", "+\t\t\t\ttypeRef = parseQualifiedName(false);", "+\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t\tboolean firstArg = modulo == 0;", "+\t\t\tif (firstArg) { // verify position", "+\t\t\t\tif (iToken != 0)", "+\t\t\t\t\tbreak nextArg;", "+\t\t\t} else if ((iToken % modulo) != 0) {", "+\t\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t\tif (typeRef == null) {", "+\t\t\t\tif (firstArg && this.currentTokenType == TerminalTokens.TokenNameRPAREN) {", "+\t\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0]);", "+\t\t\t\t\tmsg.receiver = receiver;", "+\t\t\t\t\treturn msg;", "+\t\t\t\t}", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t\tiToken++;", "+", "+\t\t\t// Read possible array declaration", "+\t\t\tint dim = 0;", "+\t\t\tif (readToken() == TerminalTokens.TokenNameLBRACKET) {", "+\t\t\t\twhile (readToken() == TerminalTokens.TokenNameLBRACKET) {", "+\t\t\t\t\tconsumeToken();", "+\t\t\t\t\tif (readToken() != TerminalTokens.TokenNameRBRACKET) {", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t\t}", "+\t\t\t\t\tconsumeToken();", "+\t\t\t\t\tdim++;", "+\t\t\t\t}", "+\t\t\t\tlong pos = ((long) typeRef.sourceStart) << 32 + typeRef.sourceEnd;", "+\t\t\t\tif (typeRef instanceof AnnotationSingleTypeReference) {", "+\t\t\t\t\tAnnotationSingleTypeReference singleRef = (AnnotationSingleTypeReference) typeRef;", "+\t\t\t\t\ttypeRef = new AnnotationArraySingleTypeReference(singleRef.token, dim, pos);", "+\t\t\t\t} else {", "+\t\t\t\t\tAnnotationQualifiedTypeReference qualifRef = (AnnotationQualifiedTypeReference) typeRef;", "+\t\t\t\t\ttypeRef = new AnnotationArrayQualifiedTypeReference(qualifRef, dim);", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\t// Read argument name", "+\t\t\tif (readToken() == TerminalTokens.TokenNameIdentifier) {", "+\t\t\t\tconsumeToken();", "+\t\t\t\tif (firstArg) { // verify position", "+\t\t\t\t\tif (iToken != 1)", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t} else if ((iToken % modulo) != 1) {", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t}", "+\t\t\t\tif (argName == null) { // verify that all arguments name are declared", "+\t\t\t\t\tif (!firstArg) {", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\targName = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\tiToken++;", "+\t\t\t} else if (argName != null) { // verify that no argument name is declared", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+", "+\t\t\t// Verify token position", "+\t\t\tif (firstArg) {", "+\t\t\t\tmodulo = iToken + 1;", "+\t\t\t} else {", "+\t\t\t\tif ((iToken % modulo) != (modulo - 1)) {", "+\t\t\t\t\tbreak nextArg;", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\t// Read separator or end arguments declaration", "+\t\t\tint token = readToken();", "+\t\t\tchar[] name = argName == null ? new char[0] : argName;", "+\t\t\tif (token == TerminalTokens.TokenNameCOMMA) {", "+\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner", "+\t\t\t\t\t\t.getCurrentTokenStartPosition()", "+\t\t\t\t\t\t- 1, typeRef);", "+\t\t\t\tpushOnAstStack(expr, firstArg);", "+\t\t\t\tconsumeToken();", "+\t\t\t\tiToken++;", "+\t\t\t} else if (token == TerminalTokens.TokenNameRPAREN) {", "+\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name,", "+\t\t\t\t\t\targStart,", "+\t\t\t\t\t\tthis.scanner.getCurrentTokenStartPosition()- 1,", "+\t\t\t\t\t\ttypeRef);", "+\t\t\t\tpushOnAstStack(expr, (iToken == (modulo - 1)));", "+\t\t\t\tint size = astLengthStack[astLengthPtr--];", "+\t\t\t\tAnnotationArgumentExpression[] arguments = new AnnotationArgumentExpression[size];", "+\t\t\t\tfor (int i = (size - 1); i >= 0; i--) {", "+\t\t\t\t\targuments[i] = (AnnotationArgumentExpression) astStack[astPtr--];", "+\t\t\t\t}", "+\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0], arguments);", "+\t\t\t\tmsg.receiver = receiver;", "+\t\t\t\treturn msg;", "+\t\t\t} else {", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t}", "+", "+\t\t// Invalid input: reset ast stacks pointers", "+\t\tconsumeToken();", "+\t\tif (iToken > 0) {", "+\t\t\tthis.astPtr = ptr;", "+\t\t\tthis.astLengthPtr = lptr;", "+\t\t}", "+\t\tthrow new InvalidInputException();", "+\t}", "-\tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException {", "-", "-\t\tint modulo = 0;\t// should be 2 for (Type,Type,...) and 3 for (Type arg,Type arg,...)", "-\t\tint iToken = 0;", "-\t\tchar[] argName = null;", "-\t\tint ptr = astPtr;", "-\t\tint lptr = astLengthPtr;", "-", "-\t\t// Parse arguments declaration if method reference", "-\t\tnextArg: while (this.index < this.scanner.eofPosition) {", "-", "-\t\t\t// Read argument type reference", "-\t\t\tint argStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\tTypeReference typeRef;", "-\t\t\t\ttypeRef = parseQualifiedName(false);", "-\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\tbreak nextArg;", "-\t\t\tboolean firstArg = modulo == 0;", "-\t\t\tif (firstArg) { // verify position", "-\t\t\t\tif (iToken != 0) break nextArg;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tif ((iToken % modulo) != 0) break nextArg;", "-\t\t\t}", "-\t\t\tif (typeRef == null) {", "-\t\t\t\tif (firstArg && this.currentTokenType == TerminalTokens.TokenNameRPAREN) {", "-\t\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0]);", "-\t\t\t\t\tmsg.receiver = receiver;", "-\t\t\t\t\treturn msg;", "-\t\t\t\t} ", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\tiToken++;", "-", "-\t\t\t// Read possible array declaration", "-\t\t\tint dim = 0;", "-\t\t\tif (readToken() == TerminalTokens.TokenNameLBRACKET) {", "-\t\t\t\twhile (readToken() == TerminalTokens.TokenNameLBRACKET) {", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tif (readToken() != TerminalTokens.TokenNameRBRACKET) {", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t\t}", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tdim++;", "-\t\t\t\t}", "-\t\t\t\tlong pos = ((long)typeRef.sourceStart)<<32 + typeRef.sourceEnd;", "-\t\t\t\tif (typeRef instanceof AnnotationSingleTypeReference) {", "-\t\t\t\t\tAnnotationSingleTypeReference singleRef = (AnnotationSingleTypeReference) typeRef;", "-\t\t\t\t\ttypeRef = new AnnotationArraySingleTypeReference(singleRef.token, dim, pos);", "-\t\t\t\t} else {", "-\t\t\t\t\tAnnotationQualifiedTypeReference qualifRef = (AnnotationQualifiedTypeReference) typeRef;", "-\t\t\t\t\ttypeRef = new AnnotationArrayQualifiedTypeReference(qualifRef, dim);", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\t// Read argument name", "-\t\t\tif (readToken() == TerminalTokens.TokenNameIdentifier) {", "-\t\t\t\tconsumeToken();", "-\t\t\t\tif (firstArg) { // verify position", "-\t\t\t\t\tif (iToken != 1) break nextArg;", "-\t\t\t\t}", "-\t\t\t\telse {", "-\t\t\t\t\tif ((iToken % modulo) != 1) break nextArg;", "-\t\t\t\t}", "-\t\t\t\tif (argName == null) { // verify that all arguments name are declared", "-\t\t\t\t\tif (!firstArg)  break nextArg;", "-\t\t\t\t}", "-\t\t\t\targName = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\tiToken++;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tif (argName != null) { // verify that no argument name is declared", "-\t\t\t\t\tbreak nextArg;", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\t// Verify token position", "-\t\t\tif (firstArg) {", "-\t\t\t\tmodulo = iToken+1;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tif ((iToken % modulo) != (modulo-1)) break nextArg;", "-\t\t\t}", "-", "-\t\t\t// Read separator or end arguments declaration", "-\t\t\tint token = readToken();", "-\t\t\tchar[] name = argName==null ? new char[0] : argName;", "-\t\t\tif (token == TerminalTokens.TokenNameCOMMA) {", "-\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner.getCurrentTokenStartPosition()-1, typeRef);", "-\t\t\t\tpushOnAstStack(expr, firstArg);", "-\t\t\t\tconsumeToken();", "-\t\t\t\tiToken++;", "-\t\t\t}", "-\t\t\telse if (token == TerminalTokens.TokenNameRPAREN) {", "-\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner.getCurrentTokenStartPosition()-1, typeRef);", "-\t\t\t\tpushOnAstStack(expr, (iToken==(modulo-1)));", "-\t\t\t\tint size = astLengthStack[astLengthPtr--];", "-\t\t\t\tAnnotationArgumentExpression[] arguments = new AnnotationArgumentExpression[size];", "-\t\t\t\tfor (int i=(size-1); i>=0; i--) {", "-\t\t\t\t\targuments[i] = (AnnotationArgumentExpression) astStack[astPtr--];", "-\t\t\t\t}", "-\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0], arguments);", "-\t\t\t\tmsg.receiver = receiver;", "-\t\t\t\treturn msg;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// Invalid input: reset ast stacks pointers", "-\t\tconsumeToken();", "-\t\tif (iToken > 0) {", "-\t\t\tthis.astPtr = ptr;", "-\t\t\tthis.astLengthPtr = lptr;", "-\t\t}", "-\t\tthrow new InvalidInputException();", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a386241a770d58dfb9c5a42a67775a5e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "c5bf031f4b646d81e14dd5faa71b9bbeeb941e13", "commitAfterChange": "aa391de0b6241e6b9dfe0b8f1b66fa7ccbb887f2", "methodNumberBeforeChange": 80, "methodNumberAfterChange": 80, "signatureBeforeChange": " \tpublic boolean visit(FieldDeclaration enumConstant, MethodScope scope)", "signatureAfterChange": " \tpublic boolean visit(FieldDeclaration enumConstant, MethodScope scope)", "diff": ["+\t\t\t/*", "+\t\t\t * Type body", "+\t\t\t */", "+\t\t\tString enum_constant_brace = this.preferences.brace_position_for_enum_constant;", "+\t", "+\t        formatLeftCurlyBrace(line, enum_constant_brace);", "+\t\t\tformatTypeOpeningBrace(enum_constant_brace, this.preferences.insert_space_before_opening_brace_in_enum_constant, typeDeclaration);", "+\t\t\t", "+\t\t\tif (this.preferences.indent_body_declarations_compare_to_enum_constant_header) {", "+\t\t\t\tthis.scribe.indent();", "+\t\t\t}", "+\t", "-\t\t\t\t/*", "-\t\t\t\t * Type body", "-\t\t\t\t */", "-\t\t\t\tString enum_constant_brace = this.preferences.brace_position_for_enum_constant;", "-\t\t", "-\t\t        formatLeftCurlyBrace(line, enum_constant_brace);", "-\t\t\t\tformatTypeOpeningBrace(enum_constant_brace, this.preferences.insert_space_before_opening_brace_in_enum_constant, typeDeclaration);", "-\t\t\t\t", "-\t\t\t\tif (this.preferences.indent_body_declarations_compare_to_enum_constant_header) {", "-\t\t\t\t\tthis.scribe.indent();", "-\t\t\t\t}", "-\t\t", "-\t\t", "-\t\t\t\tthis.scribe.printComment();", "-\t\t\t\t", "-\t\t\t\tif (this.preferences.indent_body_declarations_compare_to_enum_constant_header) {", "-\t\t\t\t\tthis.scribe.unIndent();", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\tif (this.preferences.insert_new_line_in_empty_enum_constant) {", "-\t\t\t\t\tthis.scribe.printNewLine();", "-\t\t\t\t}", "-\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameRBRACE);", "-\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\tif (enum_constant_brace.equals(DefaultCodeFormatterConstants.NEXT_LINE_SHIFTED)) {", "-\t\t\t\t\tthis.scribe.unIndent();", "-\t\t\t\t}", "-\t\t\t\tif (hasComments()) {", "-\t\t\t\t\tthis.scribe.printNewLine();", "-\t\t\t\t}", "+\t\t\t}", "+\t", "+\t\t\tthis.scribe.printComment();", "+\t\t\t", "+\t\t\tif (this.preferences.indent_body_declarations_compare_to_enum_constant_header) {", "+\t\t\t\tthis.scribe.unIndent();", "+\t\t\t}", "+\t\t\t", "+\t\t\tif (this.preferences.insert_new_line_in_empty_enum_constant) {", "+\t\t\t\tthis.scribe.printNewLine();", "+\t\t\t}", "+\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameRBRACE);", "+\t\t\tthis.scribe.printTrailingComment();", "+\t\t\tif (enum_constant_brace.equals(DefaultCodeFormatterConstants.NEXT_LINE_SHIFTED)) {", "+\t\t\t\tthis.scribe.unIndent();", "+\t\t\t}", "+\t\t\tif (hasComments()) {", "+\t\t\t\tthis.scribe.printNewLine();"]}], "num": 32796}