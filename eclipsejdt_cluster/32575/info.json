{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e4eb896085ad6098d3e8f6c80a3f653b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1cf649673d686453c4c349e815dbc679", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java", "commitBeforeChange": "8e8664655ac66e3f161f9980a96f44314418e85c", "commitAfterChange": "76a2ec884825e9edb380555c61500f23750ece32", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tpublic void finalizeProblems()", "signatureAfterChange": "  \tpublic void finalizeProblems()", "diff": ["+\t\tCompilerOptions options = scope.compilerOptions();", "+\t\tboolean hasErrors = false;", "-\t\t\tlong problemIrritant = ProblemReporter.getIrritant(problemID);", "-\t\t\tboolean isWarning = problem.isWarning();", "+\t\t\tif (problem.isError()) {", "+\t\t\t\tif (problemID != IProblem.UnusedWarningToken) {", "+\t\t\t\t// tolerate unused warning tokens which were promoted as errors", "+\t\t\t\t\thasErrors = true;", "+\t\t\t\t}", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tlong irritant = ProblemReporter.getIrritant(problemID);", "-\t\t\t\tif (isWarning) {", "-\t\t\t\t\tif ((problemIrritant & this.suppressWarningIrritants[iSuppress]) == 0)", "-\t\t\t\t\t\tcontinue nextSuppress;", "-\t\t\t\t\t// discard suppressed warning", "-\t\t\t\t\tremoved++;", "-\t\t\t\t\tproblems[iProblem] = null;", "-\t\t\t\t\tif (compilationResult.problemsMap != null) compilationResult.problemsMap.remove(problem);", "-\t\t\t\t\tif (compilationResult.firstErrors != null) compilationResult.firstErrors.remove(problem);", "-\t\t\t\t\tfoundIrritants[iSuppress] |= problemIrritant;", "-\t\t\t\t\tcontinue nextProblem;", "-\t\t\t\t} else {", "-\t\t\t\t\t// any error may prevent further warnings to be emitted, hence shouldn't report unused warning tokens if in same scope", "-\t\t\t\t\tfoundIrritants[iSuppress] = this.suppressWarningIrritants[iSuppress]; // treat as used", "-\t\t\t\t\tcontinue nextSuppress;\t\t\t\t\t", "-\t\t\t\t}", "+\t\t\t\tif ((irritant & this.suppressWarningIrritants[iSuppress]) == 0)", "+\t\t\t\t\tcontinue nextSuppress;", "+\t\t\t\t// discard suppressed warning", "+\t\t\t\tremoved++;", "+\t\t\t\tproblems[iProblem] = null;", "+\t\t\t\tif (compilationResult.problemsMap != null) compilationResult.problemsMap.remove(problem);", "+\t\t\t\tif (compilationResult.firstErrors != null) compilationResult.firstErrors.remove(problem);", "+\t\t\t\tfoundIrritants[iSuppress] |= irritant;", "+\t\t\t\tcontinue nextProblem;", "-\t\t// flag SuppressWarnings which had no effect", "-\t\tif (scope.compilerOptions().getSeverity(CompilerOptions.UnusedWarningToken) != ProblemSeverities.Ignore) {", "-\t\t\tfor (int iSuppress = 0, suppressCount = this.suppressWarningsCount; iSuppress < suppressCount; iSuppress++) {", "-\t\t\t\tAnnotation annotation = this.suppressWarningAnnotations[iSuppress];", "-\t\t\t\tif (annotation == null) continue; // implicit annotation", "-\t\t\t\tlong irritants = this.suppressWarningIrritants[iSuppress];", "-\t\t\t\tif (~irritants == 0) continue; // @SuppressWarnings(\"all\") also suppresses unused warning token", "-\t\t\t\tif (irritants != foundIrritants[iSuppress]) { // mismatch, some warning tokens were unused", "-\t\t\t\t\tMemberValuePair[] pairs = annotation.memberValuePairs();", "-\t\t\t\t\tpairLoop: for (int iPair = 0, pairCount = pairs.length; iPair < pairCount; iPair++) {", "-\t\t\t\t\t\tMemberValuePair pair = pairs[iPair];", "-\t\t\t\t\t\tif (CharOperation.equals(pair.name, TypeConstants.VALUE)) {", "-\t\t\t\t\t\t\tExpression value = pair.value;", "-\t\t\t\t\t\t\tif (value instanceof ArrayInitializer) {", "-\t\t\t\t\t\t\t\tArrayInitializer initializer = (ArrayInitializer) value;", "-\t\t\t\t\t\t\t\tExpression[] inits = initializer.expressions;", "-\t\t\t\t\t\t\t\tif (inits != null) {", "-\t\t\t\t\t\t\t\t\tfor (int iToken = 0, tokenCount = inits.length; iToken < tokenCount; iToken++) {", "-\t\t\t\t\t\t\t\t\t\tConstant cst = inits[iToken].constant;", "-\t\t\t\t\t\t\t\t\t\tif (cst != Constant.NotAConstant && cst.typeID() == TypeIds.T_JavaLangString) {", "-\t\t\t\t\t\t\t\t\t\t\tlong irritant = CompilerOptions.warningTokenToIrritant(cst.stringValue());", "-\t\t\t\t\t\t\t\t\t\t\tif (irritant != 0 && (foundIrritants[iSuppress] & irritant) == 0) {", "+\t\t// flag SuppressWarnings which had no effect (only if no (mandatory) error got detected within unit", "+\t\tif (!hasErrors) {", "+\t\t\tint severity = options.getSeverity(CompilerOptions.UnusedWarningToken);", "+\t\t\tif (severity != ProblemSeverities.Ignore) {", "+\t\t\t\tboolean unusedWarningTokenIsWarning = (severity & ProblemSeverities.Error) == 0;", "+\t\t\t\tfor (int iSuppress = 0, suppressCount = this.suppressWarningsCount; iSuppress < suppressCount; iSuppress++) {", "+\t\t\t\t\tAnnotation annotation = this.suppressWarningAnnotations[iSuppress];", "+\t\t\t\t\tif (annotation == null) continue; // implicit annotation", "+\t\t\t\t\tlong irritants = this.suppressWarningIrritants[iSuppress];", "+\t\t\t\t\tif (unusedWarningTokenIsWarning && ~irritants == 0) continue; // @SuppressWarnings(\"all\") also suppresses unused warning token", "+\t\t\t\t\tif (irritants != foundIrritants[iSuppress]) { // mismatch, some warning tokens were unused", "+\t\t\t\t\t\tMemberValuePair[] pairs = annotation.memberValuePairs();", "+\t\t\t\t\t\tpairLoop: for (int iPair = 0, pairCount = pairs.length; iPair < pairCount; iPair++) {", "+\t\t\t\t\t\t\tMemberValuePair pair = pairs[iPair];", "+\t\t\t\t\t\t\tif (CharOperation.equals(pair.name, TypeConstants.VALUE)) {", "+\t\t\t\t\t\t\t\tExpression value = pair.value;", "+\t\t\t\t\t\t\t\tif (value instanceof ArrayInitializer) {", "+\t\t\t\t\t\t\t\t\tArrayInitializer initializer = (ArrayInitializer) value;", "+\t\t\t\t\t\t\t\t\tExpression[] inits = initializer.expressions;", "+\t\t\t\t\t\t\t\t\tif (inits != null) {", "+\t\t\t\t\t\t\t\t\t\tfor (int iToken = 0, tokenCount = inits.length; iToken < tokenCount; iToken++) {", "+\t\t\t\t\t\t\t\t\t\t\tConstant cst = inits[iToken].constant;", "+\t\t\t\t\t\t\t\t\t\t\tif (cst != Constant.NotAConstant && cst.typeID() == TypeIds.T_JavaLangString) {", "+\t\t\t\t\t\t\t\t\t\t\t\tlong irritant = CompilerOptions.warningTokenToIrritant(cst.stringValue());", "+\t\t\t\t\t\t\t\t\t\t\t\tif (irritant != 0 && (foundIrritants[iSuppress] & irritant) == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (unusedWarningTokenIsWarning) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tint start = value.sourceStart, end = value.sourceEnd;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tnextSuppress: for (int jSuppress = iSuppress - 1; jSuppress >= 0; jSuppress--) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlong position = this.suppressWarningScopePositions[jSuppress];", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint startSuppress = (int) (position >>> 32);", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint endSuppress = (int) position;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (start < startSuppress) continue nextSuppress;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (end > endSuppress) continue nextSuppress;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (~this.suppressWarningIrritants[jSuppress] == 0) break pairLoop; // suppress all?", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\t\tscope.problemReporter().unusedWarningToken(inits[iToken]);", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tConstant cst = value.constant;", "+\t\t\t\t\t\t\t\t\tif (cst != Constant.NotAConstant && cst.typeID() == T_JavaLangString) {", "+\t\t\t\t\t\t\t\t\t\tlong irritant = CompilerOptions.warningTokenToIrritant(cst.stringValue());", "+\t\t\t\t\t\t\t\t\t\tif (irritant != 0 && (foundIrritants[iSuppress] & irritant) == 0) {", "+\t\t\t\t\t\t\t\t\t\t\tif (unusedWarningTokenIsWarning) {", "-\t\t\t\t\t\t\t\t\t\t\t\tscope.problemReporter().unusedWarningToken(inits[iToken]);", "+\t\t\t\t\t\t\t\t\t\t\tscope.problemReporter().unusedWarningToken(value);", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}\t", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tConstant cst = value.constant;", "-\t\t\t\t\t\t\t\tif (cst != Constant.NotAConstant && cst.typeID() == T_JavaLangString) {", "-\t\t\t\t\t\t\t\t\tlong irritant = CompilerOptions.warningTokenToIrritant(cst.stringValue());", "-\t\t\t\t\t\t\t\t\tif (irritant != 0 && (foundIrritants[iSuppress] & irritant) == 0) {", "-\t\t\t\t\t\t\t\t\t\tint start = value.sourceStart, end = value.sourceEnd;", "-\t\t\t\t\t\t\t\t\t\tnextSuppress: for (int jSuppress = iSuppress - 1; jSuppress >= 0; jSuppress--) {", "-\t\t\t\t\t\t\t\t\t\t\tlong position = this.suppressWarningScopePositions[jSuppress];", "-\t\t\t\t\t\t\t\t\t\t\tint startSuppress = (int) (position >>> 32);", "-\t\t\t\t\t\t\t\t\t\t\tint endSuppress = (int) position;", "-\t\t\t\t\t\t\t\t\t\t\tif (start < startSuppress) continue nextSuppress;", "-\t\t\t\t\t\t\t\t\t\t\tif (end > endSuppress) continue nextSuppress;", "-\t\t\t\t\t\t\t\t\t\t\tif (~this.suppressWarningIrritants[jSuppress] == 0) break pairLoop; // suppress all?", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tscope.problemReporter().unusedWarningToken(value);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}\t", "+\t\t\t\t\t\t\t\tbreak pairLoop;", "-\t\t\t\t\t\t\tbreak pairLoop;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7929c0c3916fde5801cab72f7db290df", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "aa840c8bcdfb26adabb4ef3914d3bd09d15784c4", "commitAfterChange": "c1f9cc390c170609267b76bee97dfba81631d517", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode)", "signatureAfterChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode)", "diff": ["-\tif (this.binding != null && !this.binding.isUsed() && (this.binding.isPrivate() || (this.binding.declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType)) {", "-\t\tif (!classScope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "-\t\t\tthis.scope.problemReporter().unusedPrivateConstructor(this);", "+\tcheckUnused: {", "+\t\tMethodBinding constructorBinding;", "+\t\tif ((constructorBinding = this.binding) == null) break checkUnused;", "+\t\tif (this.isDefaultConstructor) break checkUnused;", "+\t\tif (constructorBinding.isUsed()) break checkUnused;", "+\t\tif (constructorBinding.isPrivate()) {", "+\t\t\tif ((this.binding.declaringClass.tagBits & TagBits.HasNonPrivateConstructor) == 0)", "+\t\t\t\tbreak checkUnused; // tolerate as known pattern to block instantiation", "+\t\t} else if ((this.binding.declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) != TagBits.IsLocalType) {", "+\t\t\tbreak checkUnused;", "+\t\t// complain unused", "+\t\tthis.scope.problemReporter().unusedPrivateConstructor(this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d968dca6c1d3d3a1ba5f507eb016ce23", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java", "commitBeforeChange": "a2999324910e04c9c4d68f1aa93d5053c047f21c", "commitAfterChange": "a3d873b0829375e0f0465ac99af6f9753248e839", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "     \tReferenceBinding resolve(LookupEnvironment environment)", "signatureAfterChange": "     \tReferenceBinding resolve(LookupEnvironment environment)", "diff": ["-\t", "+", "+\t\tTypeBinding oldSuperclass = this.superclass, oldFirstInterface = null;", "-\t\tif (this.firstBound != null)", "-\t\t\tthis.firstBound = BinaryTypeBinding.resolveUnresolvedType(this.firstBound, environment, true);", "-\t\tfor (int i = interfaces.length; --i >= 0;)", "-\t\t\tinterfaces[i] = BinaryTypeBinding.resolveUnresolvedType(interfaces[i], environment, true);", "+\t\tint length;", "+\t\tif ((length = interfaces.length) != 0) {", "+\t\t\toldFirstInterface = interfaces[0];", "+\t\t\tfor (int i = length; --i >= 0;) {", "+\t\t\t\tinterfaces[i] = BinaryTypeBinding.resolveUnresolvedType(interfaces[i], environment, true);", "+\t\t\t}", "+\t\t}", "-\t\tif (this.firstBound != null)", "-\t\t\tthis.firstBound = BinaryTypeBinding.resolveType(this.firstBound, environment, true);", "+", "+\t\t// refresh the firstBound in case it changed", "+\t\tif (this.firstBound != null) {", "+\t\t\tif (this.firstBound == oldSuperclass) {", "+\t\t\t\tthis.firstBound = this.superclass;", "+\t\t\t} else if (this.firstBound == oldFirstInterface) {", "+\t\t\t\tthis.firstBound = interfaces[0];", "+\t\t\t}", "+\t\t}"]}], "num": 32575}