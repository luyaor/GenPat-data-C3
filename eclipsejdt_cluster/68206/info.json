{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "08de5272b7fddec7d7de3c407b0fa21e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "521ea0afaaaef0f92f2a66ff5e773679", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java", "commitBeforeChange": "973af06dbc6df022ac42e8e0a0c238581d8558f6", "commitAfterChange": "f61787e560ec300f4e60b2d9cc64378b38b8a03a", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 59, "signatureBeforeChange": " public ReferenceBinding findSuperTypeErasingTo(int wellKnownErasureID, boolean erasureIsClass)", "signatureAfterChange": " public boolean isThrowable()", "diff": ["- */", "-public ReferenceBinding findSuperTypeErasingTo(int wellKnownErasureID, boolean erasureIsClass) {", "-", "-    // do not allow type variables to match with erasures for free", "-    if (this.id == wellKnownErasureID || (!isTypeVariable() && !isIntersectionType()  && erasure().id == wellKnownErasureID)) return this;", "-", "-    ReferenceBinding currentType = this;", "-    // iterate superclass to avoid recording interfaces if searched supertype is class", "-    if (erasureIsClass) {", "-\t\twhile ((currentType = currentType.superclass()) != null) { ", "-\t\t\tif (currentType.id == wellKnownErasureID || (!currentType.isTypeVariable() && !currentType.isIntersectionType() && currentType.erasure().id == wellKnownErasureID))", "-\t\t\t\treturn currentType;", "-\t\t}    ", "-\t\treturn null;", "-    }", "-\tReferenceBinding[] interfacesToVisit = null;", "-\tint nextPosition = 0;", "-\tdo {", "-\t\tReferenceBinding[] itsInterfaces = currentType.superInterfaces();", "-\t\t// be resilient to unitialized interfaces (144976)", "-\t\tif (itsInterfaces != null && itsInterfaces != Binding.NO_SUPERINTERFACES) { // null check for extra resilience (144976)", "-\t\t\tif (interfacesToVisit == null) {", "-\t\t\t\tinterfacesToVisit = itsInterfaces;", "-\t\t\t\tnextPosition = interfacesToVisit.length;", "-\t\t\t} else {", "-\t\t\t\tint itsLength = itsInterfaces.length;", "-\t\t\t\tif (nextPosition + itsLength >= interfacesToVisit.length)", "-\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);", "-\t\t\t\tnextInterface : for (int a = 0; a < itsLength; a++) {", "-\t\t\t\t\tReferenceBinding next = itsInterfaces[a];", "-\t\t\t\t\tfor (int b = 0; b < nextPosition; b++)", "-\t\t\t\t\t\tif (next == interfacesToVisit[b]) continue nextInterface;", "-\t\t\t\t\tinterfacesToVisit[nextPosition++] = next;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t} while ((currentType = currentType.superclass()) != null);", "-\t\t\t", "-\tfor (int i = 0; i < nextPosition; i++) {", "-\t\tcurrentType = interfacesToVisit[i];", "-\t\tif (currentType.id == wellKnownErasureID || (!currentType.isTypeVariable() && !currentType.isIntersectionType() && currentType.erasure().id == wellKnownErasureID))", "-\t\t\treturn currentType;", "-", "-\t\tReferenceBinding[] itsInterfaces = currentType.superInterfaces();", "-\t\tif (itsInterfaces != null && itsInterfaces != Binding.NO_SUPERINTERFACES) {", "-\t\t\tint itsLength = itsInterfaces.length;", "-\t\t\tif (nextPosition + itsLength >= interfacesToVisit.length)", "-\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);", "-\t\t\tnextInterface : for (int a = 0; a < itsLength; a++) {", "-\t\t\t\tReferenceBinding next = itsInterfaces[a];", "-\t\t\t\tfor (int b = 0; b < nextPosition; b++)", "-\t\t\t\t\tif (next == interfacesToVisit[b]) continue nextInterface;", "-\t\t\t\tinterfacesToVisit[nextPosition++] = next;", "-\t\t\t}", "-\t\t}", "-\t}", "-\treturn null;", "-}", "+ */", "+public boolean isThrowable() {", "+\tReferenceBinding current = this;", "+\tdo {", "+\t\tswitch (current.id) {", "+\t\t\tcase TypeIds.T_JavaLangThrowable :", "+\t\t\tcase TypeIds.T_JavaLangError :", "+\t\t\tcase TypeIds.T_JavaLangRuntimeException :", "+\t\t\tcase TypeIds.T_JavaLangException :", "+\t\t\t\treturn true;", "+\t\t}", "+\t} while ((current = current.superclass()) != null);", "+\treturn false;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "78cf49c61d06ef97f13d05086096098b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "5af3ec11c73ebd5f465c42ddba07188d87fc00f1", "commitAfterChange": "b246de6fdcd5a901a16dcaeba98ae727a49eb635", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic IPackageFragment[] findPackageFragments(String name, boolean partialMatch)", "signatureAfterChange": " \tpublic IPackageFragment[] findPackageFragments(String name, boolean partialMatch)", "diff": ["-\t\tif (partialMatch) {", "+\t\treturn findPackageFragments(name, partialMatch, false);", "+\t}", "-\t\t\t\tif (pkgName != null && Util.startsWithIgnoreCase(pkgName, splittedName)) {", "-\t\t\t\t\tObject value = this.packageFragments.valueTable[i];", "-\t\t\t\t\tif (value instanceof PackageFragmentRoot) {", "-\t\t\t\t\t\tIPackageFragment pkg = ((PackageFragmentRoot) value).getPackageFragment(pkgName);", "-\t\t\t\t\t\tif (oneFragment == null) {", "-\t\t\t\t\t\t\toneFragment = new IPackageFragment[] {pkg};", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (pkgs == null) {", "-\t\t\t\t\t\t\t\tpkgs = new ArrayList();", "-\t\t\t\t\t\t\t\tpkgs.add(oneFragment[0]);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tpkgs.add(pkg);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tIPackageFragmentRoot[] roots = (IPackageFragmentRoot[]) value;", "-\t\t\t\t\t\tfor (int j = 0, length2 = roots.length; j < length2; j++) {", "-\t\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot) roots[j];", "-\t\t\t\t\t\t\tIPackageFragment pkg = root.getPackageFragment(pkgName);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dba6402c2adf2110b8d24b0160d9778f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "06cedbd8bd184e3f34c939385e2cbddd9e3aedca", "commitAfterChange": "0d09a2966f3cebfb8d6601000e2b64259fed7dd8", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " protected IJavaElement createHandle(LambdaExpression lambdaExpression, IJavaElement parent)", "signatureAfterChange": " protected IJavaElement createHandle(LambdaExpression lambdaExpression, IJavaElement parent)", "diff": ["-\tif (!(parent instanceof IType)) return parent;", "-", "-\tIType type = (IType) parent;", "-\tArgument[] arguments = lambdaExpression.arguments();", "-\tint syntheticArgumentSize = lambdaExpression.getSyntheticArgumentSize();", "-\tMethodBinding descriptor = lambdaExpression.descriptor;", "-\tint argCount = arguments == null ? 0 : arguments.length;", "-\tif (type.isBinary()) {", "-\t\tClassFileReader reader = classFileReader(type);", "-\t\tif (reader != null) {", "-\t\t\t// build arguments names", "-\t\t\tchar[][] argumentTypeNames = new char[argCount - syntheticArgumentSize][];", "-\t\t\tfor (int i = syntheticArgumentSize; i < argCount; i++) {", "-\t\t\t\tchar[] typeName = null;", "-\t\t\t\tif (arguments != null) {", "-\t\t\t\t\tTypeReference typeRef = arguments[i].type;", "-\t\t\t\t\ttypeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "-\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "-\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "-\t\t\t\t}", "-\t\t\t\tif (typeName == null) {", "-\t\t\t\t\t// invalid type name", "-\t\t\t\t\treturn null;", "-\t\t\t\t}", "-\t\t\t\targumentTypeNames[i - syntheticArgumentSize] = typeName;", "-\t\t\t}", "-\t\t\t// return binary method", "-\t\t\tIMethod binaryMethod = createBinaryMethodHandle(type, descriptor.selector, argumentTypeNames);", "-\t\t\tif (binaryMethod == null) {", "-\t\t\t\t// when first attempt fails, try with similar matches if any...", "-\t\t\t\tPossibleMatch similarMatch = this.currentPossibleMatch.getSimilarMatch();", "-\t\t\t\twhile (similarMatch != null) {", "-\t\t\t\t\ttype = ((ClassFile)similarMatch.openable).getType();", "-\t\t\t\t\tbinaryMethod = createBinaryMethodHandle(type, descriptor.selector, argumentTypeNames);", "-\t\t\t\t\tif (binaryMethod != null) {", "-\t\t\t\t\t\treturn binaryMethod;", "-\t\t\t\t\t}", "-\t\t\t\t\tsimilarMatch = similarMatch.getSimilarMatch();", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn binaryMethod;", "-\t\t}", "-\t\tif (BasicSearchEngine.VERBOSE) {", "-\t\t\tSystem.out.println(\"Not able to createHandle for the lambda expression \" + //$NON-NLS-1$", "-\t\t\t\t\tCharOperation.charToString(descriptor.selector) + \" May miss some results\");  //$NON-NLS-1$", "-\t\t}", "-\t\treturn null;", "-\t}", "-", "-\tString[] parameterTypeSignatures = new String[argCount - syntheticArgumentSize];", "-\tif (arguments != null) {", "-\t\tfor (int i = syntheticArgumentSize; i < argCount; i++) {", "-\t\t\tTypeReference typeRef = arguments[i].type;", "-\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getParameterizedTypeName(), '.');", "-\t\t\tparameterTypeSignatures[i - syntheticArgumentSize] = Signature.createTypeSignature(typeName, false);", "-\t\t}", "-\t}", "-", "-\treturn createMethodHandle(type, new String(descriptor.selector), parameterTypeSignatures);", "+\torg.eclipse.jdt.internal.core.LambdaExpression lambdaElement = new org.eclipse.jdt.internal.core.LambdaExpression((JavaElement) parent, lambdaExpression);", "+\tIMethod lambdaMethodElement = lambdaElement.getMethod();", "+\tthis.methodHandles.add(lambdaMethodElement);", "+\treturn lambdaMethodElement;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e67dc234fbea212870ef1a8addf1bbd9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SetClasspathOperation.java", "commitBeforeChange": "6e412529e3c9d841ef857516943929ed94e3593c", "commitAfterChange": "cdf9b8e4c56a386ff2dde986be8b72d07aa1cb88", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tprotected void updateProjectReferencesIfNecessary() throws JavaModelException", "signatureAfterChange": " \tprotected void updateProjectReferencesIfNecessary() throws JavaModelException", "diff": ["-\t\tif (!this.canChangeResources) return;", "-\t", "-\t\tString[] oldRequired = this.project.projectPrerequisites(this.oldResolvedPath);", "-", "-\t\tif (this.newResolvedPath == null) {", "-\t\t\tthis.newResolvedPath = this.project.getResolvedClasspath(this.newRawPath, null, true, true, null/*no reverse map*/);", "-\t\t}", "-\t\tString[] newRequired = this.project.projectPrerequisites(this.newResolvedPath);", "-\t", "-\t\ttry {\t\t", "-\t\t\tIProject projectResource = this.project.getProject();", "-\t\t\tIProjectDescription description = projectResource.getDescription();", "-\t\t\t ", "-\t\t\tIProject[] projectReferences = description.getDynamicReferences();", "-\t\t\t", "-\t\t\tHashSet oldReferences = new HashSet(projectReferences.length);", "-\t\t\tfor (int i = 0; i < projectReferences.length; i++){", "-\t\t\t\tString projectName = projectReferences[i].getName();", "-\t\t\t\toldReferences.add(projectName);", "-\t\t\t}", "-\t\t\tHashSet newReferences = (HashSet)oldReferences.clone();", "-\t", "-\t\t\tfor (int i = 0; i < oldRequired.length; i++){", "-\t\t\t\tString projectName = oldRequired[i];", "-\t\t\t\tnewReferences.remove(projectName);", "-\t\t\t}", "-\t\t\tfor (int i = 0; i < newRequired.length; i++){", "-\t\t\t\tString projectName = newRequired[i];", "-\t\t\t\tnewReferences.add(projectName);", "-\t\t\t}", "-\t", "-\t\t\tIterator iter;", "-\t\t\tint newSize = newReferences.size();", "-\t\t\t", "-\t\t\tcheckIdentity: {", "-\t\t\t\tif (oldReferences.size() == newSize){", "-\t\t\t\t\titer = newReferences.iterator();", "-\t\t\t\t\twhile (iter.hasNext()){", "-\t\t\t\t\t\tif (!oldReferences.contains(iter.next())){", "-\t\t\t\t\t\t\tbreak checkIdentity;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tString[] requiredProjectNames = new String[newSize];", "-\t\t\tint index = 0;", "-\t\t\titer = newReferences.iterator();", "-\t\t\twhile (iter.hasNext()){", "-\t\t\t\trequiredProjectNames[index++] = (String)iter.next();", "-\t\t\t}", "-\t\t\tUtil.sort(requiredProjectNames); // ensure that if changed, the order is consistent", "-\t\t\t", "-\t\t\tIProject[] requiredProjectArray = new IProject[newSize];", "-\t\t\tIWorkspaceRoot wksRoot = projectResource.getWorkspace().getRoot();", "-\t\t\tfor (int i = 0; i < newSize; i++){", "-\t\t\t\trequiredProjectArray[i] = wksRoot.getProject(requiredProjectNames[i]);", "-\t\t\t}", "-\t", "-\t\t\tdescription.setDynamicReferences(requiredProjectArray);", "-\t\t\tprojectResource.setDescription(description, this.progressMonitor);", "-\t", "-\t\t} catch(CoreException e){", "-\t\t\tthrow new JavaModelException(e);", "-\t\t}", "+\t\t// will run now, or be deferred until next pre-auto-build notification if resource tree is locked", "+\t\tJavaModelManager.getJavaModelManager().deltaState.performClasspathResourceChange(", "+\t\t        project, ", "+\t\t        oldResolvedPath, ", "+\t\t        newResolvedPath, ", "+\t\t        newRawPath, ", "+\t\t        canChangeResources);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ff88851f00c6f8b42dc2a3186bf61fff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "07f2a3d76611d11852367ea136a6272990449122", "commitAfterChange": "b51487a3e769c1faf54930e906289a243b81936a", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tpublic void fire(JavaElementDelta customDelta, int originalEventType)", "signatureAfterChange": " \tpublic void fire(IJavaElementDelta customDelta, int eventType)", "diff": ["-\tpublic void fire(JavaElementDelta customDelta, int originalEventType) {", "+\tpublic void fire(IJavaElementDelta customDelta, int eventType) {", "-\t\tif (this.isFiring) {", "+\t\tif (!this.isFiring) return;", "+\t\t", "+\t\tif (DeltaProcessor.VERBOSE && (eventType == DEFAULT_CHANGE_EVENT || eventType == ElementChangedEvent.PRE_AUTO_BUILD)) {", "+\t\t\tSystem.out.println(\"-----------------------------------------------------------------------------------------------------------------------\");//$NON-NLS-1$", "+\t\t}", "-\t\t\tint eventType;", "+\t\tIJavaElementDelta deltaToNotify;", "+\t\tif (customDelta == null){", "+\t\t\tdeltaToNotify = this.mergeDeltas(this.javaModelDeltas);", "+\t\t} else {", "+\t\t\tdeltaToNotify = customDelta;", "+\t\t}", "-\t\t\t/* DEFAULT event type is used when operation doesn't know actual event type and needed to fire immediately:", "-\t\t\t * e.g. non-resource modifying operation, create/destroy shared working copies", "-\t\t\t *", "-\t\t\t * this is mapped to a POST-change + PRE-build change for all interested listeners", "-\t\t\t */", "-\t\t\tif (originalEventType == DEFAULT_CHANGE_EVENT){", "-\t\t\t\teventType = ElementChangedEvent.POST_CHANGE;", "-\t\t\t} else {", "-\t\t\t\teventType = originalEventType;", "-\t\t\t}", "-\t\t\t", "-\t\t\tJavaElementDelta deltaToNotify;", "-\t\t\tif (customDelta == null){", "-\t\t\t\tthis.mergeDeltas();", "-\t\t\t\tif (this.javaModelDeltas.size() > 0){ ", "-", "-\t\t\t\t\t// cannot be more than 1 after merge", "-\t\t\t\t\tdeltaToNotify = (JavaElementDelta)this.javaModelDeltas.get(0);", "-", "-\t\t\t\t\t// empty the queue only after having fired final volley of deltas and no custom deltas was superposed", "-\t\t\t\t\tif (eventType == ElementChangedEvent.POST_CHANGE){", "-\t\t\t\t\t\t// flush now so as to keep listener reactions to post their own deltas for subsequent iteration", "-\t\t\t\t\t\tthis.flush();", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tdeltaToNotify = customDelta;", "-\t\t\t}", "-\t\t\t\t", "-\t\t\t// Refresh internal scopes", "+\t\t// Refresh internal scopes", "+\t\tif (deltaToNotify != null) {", "-\t\t\t\t", "-\t\t\t// Notification", "+\t\t}", "+\t\t\t", "+\t\t// Notification", "+\t", "+\t\t// Important: if any listener reacts to notification by updating the listeners list or mask, these lists will", "+\t\t// be duplicated, so it is necessary to remember original lists in a variable (since field values may change under us)", "+\t\tIElementChangedListener[] listeners = this.elementChangedListeners;", "+\t\tint[] listenerMask = this.elementChangedListenerMasks;", "+\t\tint listenerCount = this.elementChangedListenerCount;", "-\t\t\t// Important: if any listener reacts to notification by updating the listeners list or mask, these lists will", "-\t\t\t// be duplicated, so it is necessary to remember original lists in a variable (since field values may change under us)", "-\t\t\tIElementChangedListener[] listeners = this.elementChangedListeners;", "-\t\t\tint[] listenerMask = this.elementChangedListenerMasks;", "-\t\t\tint listenerCount = this.elementChangedListenerCount;", "+\t\tswitch (eventType) {", "+\t\t\tcase DEFAULT_CHANGE_EVENT:", "+\t\t\t\tfirePreAutoBuildDelta(deltaToNotify, listeners, listenerMask, listenerCount);", "+\t\t\t\tfirePostChangeDelta(deltaToNotify, listeners, listenerMask, listenerCount);", "+\t\t\t\tfireReconcileDelta(listeners, listenerMask, listenerCount);", "+\t\t\t\tbreak;", "+\t\t\tcase ElementChangedEvent.PRE_AUTO_BUILD:", "+\t\t\t\tfirePreAutoBuildDelta(deltaToNotify, listeners, listenerMask, listenerCount);", "+\t\t\t\tbreak;", "+\t\t\tcase ElementChangedEvent.POST_CHANGE:", "+\t\t\t\tfirePostChangeDelta(deltaToNotify, listeners, listenerMask, listenerCount);", "+\t\t\t\tfireReconcileDelta(listeners, listenerMask, listenerCount);", "+\t\t\t\tbreak;", "+\t\t}", "-\t\t\t// in case using a DEFAULT change event, will notify also all listeners also interested in PRE-build events", "-\t\t\tif (originalEventType == DEFAULT_CHANGE_EVENT){", "-\t\t\t\tif (DeltaProcessor.VERBOSE){", "-\t\t\t\t\tSystem.out.println(\"FIRING PRE_AUTO_BUILD Delta [\"+Thread.currentThread()+\"]:\\n\" + deltaToNotify);//$NON-NLS-1$//$NON-NLS-2$", "+\t}", "-\t\t\t\tfinal ElementChangedEvent extraEvent = new ElementChangedEvent(deltaToNotify, ElementChangedEvent.PRE_AUTO_BUILD);", "-\t\t\t\tfor (int i= 0; i < listenerCount; i++) {", "-\t\t\t\t\tif ((listenerMask[i] & ElementChangedEvent.PRE_AUTO_BUILD) != 0){", "-\t\t\t\t\t\tfinal IElementChangedListener listener = listeners[i];", "-\t\t\t\t\t\tif (DeltaProcessor.VERBOSE) {", "-\t\t\t\t\t\t\tSystem.out.println(\"Listener #\" + (i+1) + \"=\" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief", "-\t\t\t\t\t\tPlatform.run(new ISafeRunnable() {", "-\t\t\t\t\t\t\tpublic void handleException(Throwable exception) {", "-\t\t\t\t\t\t\t\tUtil.log(exception, \"Exception occurred in listener of Java element change notification\"); //$NON-NLS-1$", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tpublic void run() throws Exception {", "-\t\t\t\t\t\t\t\tlistener.elementChanged(extraEvent);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t});", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\t// regular notification", "-\t\t\tif (DeltaProcessor.VERBOSE){", "-\t\t\t\tString type = \"\";//$NON-NLS-1$", "-\t\t\t\tswitch (eventType) {", "-\t\t\t\t\tcase ElementChangedEvent.POST_CHANGE:", "-\t\t\t\t\t\ttype = \"POST_CHANGE\"; //$NON-NLS-1$", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase ElementChangedEvent.PRE_AUTO_BUILD:", "-\t\t\t\t\t\ttype = \"PRE_AUTO_BUILD\"; //$NON-NLS-1$", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase ElementChangedEvent.POST_RECONCILE:", "-\t\t\t\t\t\ttype = \"POST_RECONCILE\"; //$NON-NLS-1$", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\tSystem.out.println(\"FIRING \" + type + \" Delta [\"+Thread.currentThread()+\"]:\\n\" + deltaToNotify);//$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$", "-\t\t\t}", "-\t\t\tfinal ElementChangedEvent event = new ElementChangedEvent(deltaToNotify, eventType);", "-\t\t\tfor (int i= 0; i < listenerCount; i++) {", "-\t\t\t\tif ((listenerMask[i] & eventType) != 0){", "-\t\t\t\t\t// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief", "-\t\t\t\t\tfinal IElementChangedListener listener = listeners[i];", "-\t\t\t\t\tif (DeltaProcessor.VERBOSE) {", "-\t\t\t\t\t\tSystem.out.println(\"Listener #\" + (i+1) + \"=\" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$", "-\t\t\t\t\tPlatform.run(new ISafeRunnable() {", "-\t\t\t\t\t\tpublic void handleException(Throwable exception) {", "-\t\t\t\t\t\t\tUtil.log(exception, \"Exception occurred in listener of Java element change notification\"); //$NON-NLS-1$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tpublic void run() throws Exception {", "-\t\t\t\t\t\t\tlistener.elementChanged(event);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t});", "-\t\t\t\t}"]}], "num": 68206}