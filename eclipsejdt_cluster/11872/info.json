{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ebcee825232b047fbd99e657287ca948", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a1222ea3a6f6a75ec8c8c62598da3eb2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java", "commitBeforeChange": "83b2f6a03c3dc62e9f0da4478de073882f53022b", "commitAfterChange": "3b7e9a0f1d7c1bcba3808ca366020fd264fda3dd", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 32, "signatureBeforeChange": " public ParameterizedTypeBinding createParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, long annotationBits, ReferenceBinding enclosingType)", "signatureAfterChange": " public TypeBinding createAnnotatedType(TypeBinding type, AnnotationBinding[] newbies)", "diff": ["- */", "-public ParameterizedTypeBinding createParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, long annotationBits, ReferenceBinding enclosingType) {", "-\t// cached info is array of already created parameterized types for this type", "-\tParameterizedTypeBinding[] cachedInfo = (ParameterizedTypeBinding[])this.uniqueParameterizedTypeBindings.get(genericType);", "-\tint argLength = typeArguments == null ? 0: typeArguments.length;", "-\tboolean needToGrow = false;", "-\tint index = 0;", "-\tif (cachedInfo != null){", "-\t\tnextCachedType :", "-\t\t\t// iterate existing parameterized for reusing one with same type arguments if any", "-\t\t\tfor (int max = cachedInfo.length; index < max; index++){", "-\t\t\t    ParameterizedTypeBinding cachedType = cachedInfo[index];", "-\t\t\t    if (cachedType == null) break nextCachedType;", "-\t\t\t    if (cachedType.actualType() != genericType) continue nextCachedType; // remain of unresolved type", "-\t\t\t    if (cachedType.enclosingType() != enclosingType) continue nextCachedType;", "-\t\t\t    long cachedBits = cachedType.tagBits & TagBits.AnnotationNullMASK;", "-\t\t\t    if ((cachedBits | annotationBits) != 0 && cachedBits != annotationBits) continue nextCachedType;", "-\t\t\t\tTypeBinding[] cachedArguments = cachedType.arguments;", "-\t\t\t\tint cachedArgLength = cachedArguments == null ? 0 : cachedArguments.length;", "-\t\t\t\tif (argLength != cachedArgLength) continue nextCachedType; // would be an error situation (from unresolved binaries)", "-\t\t\t\tfor (int j = 0; j < cachedArgLength; j++){", "-\t\t\t\t\tif (typeArguments[j] != cachedArguments[j]) continue nextCachedType;", "-\t\t\t\t}", "-\t\t\t\t// all arguments match, reuse current", "-\t\t\t\treturn cachedType;", "-\t\t}", "-\t\tneedToGrow = true;", "-\t} else {", "-\t\tcachedInfo = new ParameterizedTypeBinding[5];", "-\t\tthis.uniqueParameterizedTypeBindings.put(genericType, cachedInfo);", "+// Variant to handle incoming type possibly carrying annotations.", "+public TypeBinding createAnnotatedType(TypeBinding type, AnnotationBinding[] newbies) {", "+\tfinal int newLength = newbies == null ? 0 :  newbies.length;", "+\tif (type == null || newLength == 0)", "+\t\treturn type;", "+\tAnnotationBinding [] oldies = type.getTypeAnnotations();", "+\tfinal int oldLength = oldies == null ? 0 : oldies.length;", "+\tif (oldLength > 0) {", "+\t\tSystem.arraycopy(newbies, 0, newbies = new AnnotationBinding[newLength + oldLength], 0, newLength);", "+\t\tSystem.arraycopy(oldies, 0, newbies, newLength, oldLength);", "-\t// grow cache ?", "-\tint length = cachedInfo.length;", "-\tif (needToGrow && index == length){", "-\t\tSystem.arraycopy(cachedInfo, 0, cachedInfo = new ParameterizedTypeBinding[length*2], 0, length);", "-\t\tthis.uniqueParameterizedTypeBindings.put(genericType, cachedInfo);", "-\t}", "-\t// add new binding", "-\tParameterizedTypeBinding parameterizedType = new ParameterizedTypeBinding(genericType,typeArguments, enclosingType, this);", "-\tif (annotationBits != 0L)", "-\t\tparameterizedType.tagBits |= annotationBits | TagBits.HasNullTypeAnnotation;", "-\tcachedInfo[index] = parameterizedType;", "-\treturn parameterizedType;", "+\t", "+\tTypeBinding annotatedType = this.typeSystem.getAnnotatedType(type, new AnnotationBinding [][] { newbies });", "+\tannotatedType.tagBits |= type.tagBits & TagBits.AnnotationNullMASK; // carry over any synthesized null bits e.g new Object() unless the annotation binding themselves are synthesized.", "+\treturn annotatedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cba244df1893058828ee3820c2a0cced", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java", "commitBeforeChange": "83b2f6a03c3dc62e9f0da4478de073882f53022b", "commitAfterChange": "3b7e9a0f1d7c1bcba3808ca366020fd264fda3dd", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 37, "signatureBeforeChange": " public WildcardBinding createWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind, long annotationTagBits)", "signatureAfterChange": "  public AnnotationBinding getNullableAnnotation()", "diff": ["-}", "-public WildcardBinding createWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind, long annotationTagBits) {", "-\t// cached info is array of already created wildcard  types for this type", "-\tif (genericType == null) // pseudo wildcard denoting composite bounds for lub computation", "-\t\tgenericType = ReferenceBinding.LUB_GENERIC;", "-\tWildcardBinding[] cachedInfo = (WildcardBinding[])this.uniqueWildcardBindings.get(genericType);", "-\tboolean needToGrow = false;", "-\tint index = 0;", "-\tif (cachedInfo != null){", "-\t\tnextCachedType :", "-\t\t\t// iterate existing wildcards for reusing one with same information if any", "-\t\t\tfor (int max = cachedInfo.length; index < max; index++){", "-\t\t\t    WildcardBinding cachedType = cachedInfo[index];", "-\t\t\t    if (cachedType == null) break nextCachedType;", "-\t\t\t    if (cachedType.genericType != genericType) continue nextCachedType; // remain of unresolved type", "-\t\t\t    if (cachedType.rank != rank) continue nextCachedType;", "-\t\t\t    if ((cachedType.tagBits & TagBits.AnnotationNullMASK) != annotationTagBits) continue nextCachedType;", "-\t\t\t    if (cachedType.boundKind != boundKind) continue nextCachedType;", "-\t\t\t    if (cachedType.bound != bound) continue nextCachedType;", "-\t\t\t    if (cachedType.otherBounds != otherBounds) {", "-\t\t\t    \tint cachedLength = cachedType.otherBounds == null ? 0 : cachedType.otherBounds.length;", "-\t\t\t    \tint length = otherBounds == null ? 0 : otherBounds.length;", "-\t\t\t    \tif (cachedLength != length) continue nextCachedType;", "-\t\t\t    \tfor (int j = 0; j < length; j++) {", "-\t\t\t    \t\tif (cachedType.otherBounds[j] != otherBounds[j]) continue nextCachedType;", "-\t\t\t    \t}", "-\t\t\t    }", "-\t\t\t\t// all match, reuse current", "-\t\t\t\treturn cachedType;", "-\t\t}", "-\t\tneedToGrow = true;", "-\t} else {", "-\t\tcachedInfo = new WildcardBinding[10];", "-\t\tthis.uniqueWildcardBindings.put(genericType, cachedInfo);", "-\t}", "-\t// grow cache ?", "-\tint length = cachedInfo.length;", "-\tif (needToGrow && index == length){", "-\t\tSystem.arraycopy(cachedInfo, 0, cachedInfo = new WildcardBinding[length*2], 0, length);", "-\t\tthis.uniqueWildcardBindings.put(genericType, cachedInfo);", "-\t}", "-\t// add new binding", "-\tWildcardBinding wildcard = new WildcardBinding(genericType, rank, bound, otherBounds, boundKind, this);", "-\tif (annotationTagBits != 0)", "-\t\twildcard.tagBits |= annotationTagBits | TagBits.HasNullTypeAnnotation;", "-\tcachedInfo[index] = wildcard;", "-\treturn wildcard;", "+public AnnotationBinding getNullableAnnotation() {", "+\tReferenceBinding nullable = getResolvedType(this.globalOptions.nullableAnnotationName, null);", "+\treturn new AnnotationBinding(nullable, Binding.NO_ELEMENT_VALUE_PAIRS);", "+}"]}], "num": 11872}