{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1a8836646ccc96b05d1966f880d21e08", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "12dfdd1cf45db4eaccd218b7e6e236f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CaseStatement.java", "commitBeforeChange": "b418235473d69146fcb35be10bf158bb2b040cf7", "commitAfterChange": "eadf5ba6d44f28f071965cf829d67590b0a71974", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement)", "signatureAfterChange": " public Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement)", "diff": ["+ */", "+public Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement) {", "+\t// switchExpressionType maybe null in error case", "+    scope.enclosingCase = this; // record entering in a switch case block", "+    ", "+\tif (this.constantExpression == null) {", "+\t\t// remember the default case into the associated switch statement", "+\t\tif (switchStatement.defaultCase != null)", "+\t\t\tscope.problemReporter().duplicateDefaultCase(this);", "-\t */", "-\tpublic Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement) {", "-\t\t// switchExpressionType maybe null in error case", "-\t    scope.enclosingCase = this; // record entering in a switch case block", "-\t    ", "-\t\tif (constantExpression == null) {", "-\t\t\t// remember the default case into the associated switch statement", "-\t\t\tif (switchStatement.defaultCase != null)", "-\t\t\t\tscope.problemReporter().duplicateDefaultCase(this);", "-\t", "-\t\t\t// on error the last default will be the selected one ...\t", "-\t\t\tswitchStatement.defaultCase = this;", "-\t\t\treturn Constant.NotAConstant;", "-\t\t}", "-\t\t// add into the collection of cases of the associated switch statement", "-\t\tswitchStatement.cases[switchStatement.caseCount++] = this;", "-\t\t// tag constant name with enum type for privileged access to its members", "-\t\tif (switchExpressionType != null && switchExpressionType.isEnum() && (constantExpression instanceof SingleNameReference)) {", "-\t\t\t((SingleNameReference) constantExpression).setActualReceiverType((ReferenceBinding)switchExpressionType);", "-\t\t}", "-\t\tTypeBinding caseType = constantExpression.resolveType(scope);", "-\t\tif (caseType == null || switchExpressionType == null) return Constant.NotAConstant;", "-\t\tif (constantExpression.isConstantValueOfTypeAssignableToType(caseType, switchExpressionType)", "-\t\t\t\t|| caseType.isCompatibleWith(switchExpressionType)) {", "-\t\t\tif (caseType.isEnum()) {", "-\t\t\t\tthis.isEnumConstant = true;", "-\t\t\t\tif (((this.constantExpression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) != 0) {", "-\t\t\t\t\tscope.problemReporter().enumConstantsCannotBeSurroundedByParenthesis(this.constantExpression);", "-\t\t\t\t}", "-", "-\t\t\t\tif (constantExpression instanceof NameReference", "-\t\t\t\t\t\t&& (constantExpression.bits & RestrictiveFlagMASK) == Binding.FIELD) {", "-\t\t\t\t\tNameReference reference = (NameReference) constantExpression;", "-\t\t\t\t\tFieldBinding field = reference.fieldBinding();", "-\t\t\t\t\tif ((field.modifiers & ClassFileConstants.AccEnum) == 0) {", "-\t\t\t\t\t\t scope.problemReporter().enumSwitchCannotTargetField(reference, field);", "-\t\t\t\t\t} else \tif (reference instanceof QualifiedNameReference) {", "-\t\t\t\t\t\t scope.problemReporter().cannotUseQualifiedEnumConstantInCaseLabel(reference, field);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn IntConstant.fromValue(field.original().id + 1); // (ordinal value + 1) zero should not be returned see bug 141810", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\treturn constantExpression.constant;", "-\t\t\t}", "-\t\t} else if (scope.isBoxingCompatibleWith(caseType, switchExpressionType)", "-\t\t\t\t\t\t|| (caseType.isBaseType()  // narrowing then boxing ?", "-\t\t\t\t\t\t\t\t&& scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "-\t\t\t\t\t\t\t\t&& !switchExpressionType.isBaseType()", "-\t\t\t\t\t\t\t\t&& constantExpression.isConstantValueOfTypeAssignableToType(caseType, scope.environment().computeBoxingType(switchExpressionType)))) {", "-\t\t\t// constantExpression.computeConversion(scope, caseType, switchExpressionType); - do not report boxing/unboxing conversion", "-\t\t\treturn constantExpression.constant;", "-\t\t}", "-\t\tscope.problemReporter().typeMismatchError(caseType, switchExpressionType, constantExpression);", "+\t\t// on error the last default will be the selected one ...\t", "+\t\tswitchStatement.defaultCase = this;", "+\t// add into the collection of cases of the associated switch statement", "+\tswitchStatement.cases[switchStatement.caseCount++] = this;", "+\t// tag constant name with enum type for privileged access to its members", "+\tif (switchExpressionType != null && switchExpressionType.isEnum() && (this.constantExpression instanceof SingleNameReference)) {", "+\t\t((SingleNameReference) this.constantExpression).setActualReceiverType((ReferenceBinding)switchExpressionType);", "+\tTypeBinding caseType = this.constantExpression.resolveType(scope);", "+\tif (caseType == null || switchExpressionType == null) return Constant.NotAConstant;", "+\tif (this.constantExpression.isConstantValueOfTypeAssignableToType(caseType, switchExpressionType)", "+\t\t\t|| caseType.isCompatibleWith(switchExpressionType)) {", "+\t\tif (caseType.isEnum()) {", "+\t\t\tif (((this.constantExpression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) != 0) {", "+\t\t\t\tscope.problemReporter().enumConstantsCannotBeSurroundedByParenthesis(this.constantExpression);", "+\t\t\t}", "+", "+\t\t\tif (this.constantExpression instanceof NameReference", "+\t\t\t\t\t&& (this.constantExpression.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD) {", "+\t\t\t\tNameReference reference = (NameReference) this.constantExpression;", "+\t\t\t\tFieldBinding field = reference.fieldBinding();", "+\t\t\t\tif ((field.modifiers & ClassFileConstants.AccEnum) == 0) {", "+\t\t\t\t\t scope.problemReporter().enumSwitchCannotTargetField(reference, field);", "+\t\t\t\t} else \tif (reference instanceof QualifiedNameReference) {", "+\t\t\t\t\t scope.problemReporter().cannotUseQualifiedEnumConstantInCaseLabel(reference, field);", "+\t\t\t\t}", "+\t\t\t\treturn IntConstant.fromValue(field.original().id + 1); // (ordinal value + 1) zero should not be returned see bug 141810", "+\t\t\t}", "+\t\t} else {", "+\t\t\treturn this.constantExpression.constant;", "+\t\t}", "+\t} else if (scope.isBoxingCompatibleWith(caseType, switchExpressionType)", "+\t\t\t\t\t|| (caseType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t&& scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "+\t\t\t\t\t\t\t&& !switchExpressionType.isBaseType()", "+\t\t\t\t\t\t\t&& this.constantExpression.isConstantValueOfTypeAssignableToType(caseType, scope.environment().computeBoxingType(switchExpressionType)))) {", "+\t\t// constantExpression.computeConversion(scope, caseType, switchExpressionType); - do not report boxing/unboxing conversion", "+\t\treturn this.constantExpression.constant;", "+\t}", "+\tscope.problemReporter().typeMismatchError(caseType, switchExpressionType, this.constantExpression);", "+\treturn Constant.NotAConstant;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a0e7a67ff456b39855234f09bb5a1f0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java", "commitBeforeChange": "b944419a775a8766a80aaf50d5c9201201448e38", "commitAfterChange": "66a68a77c79dc8161adf91226d8f791e46bc037a", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 11, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["+", "+public TypeBinding resolveType(BlockScope scope) {", "+\t// due to syntax lhs may be only a NameReference, a FieldReference or an ArrayReference", "+\tthis.constant = Constant.NotAConstant;", "+\tif (!(this.lhs instanceof Reference) || this.lhs.isThis()) {", "+\t\tscope.problemReporter().expressionShouldBeAVariable(this.lhs);", "+\tTypeBinding lhsType = lhs.resolveType(scope);", "+\tthis.expression.setExpectedType(lhsType); // needed in case of generic method invocation", "+\tif (lhsType != null) ", "+\t\tthis.resolvedType = lhsType.capture(scope, this.sourceEnd);", "+\tTypeBinding rhsType = this.expression.resolveType(scope);", "+\tif (lhsType == null || rhsType == null) {", "+\t\treturn null;", "+\t// check for assignment with no effect", "+\tBinding left = getDirectBinding(this.lhs);", "+\tif (left != null && left == getDirectBinding(this.expression)) {", "+\t\tscope.problemReporter().assignmentHasNoEffect(this, left.shortReadableName());", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-", "-\t\t// due to syntax lhs may be only a NameReference, a FieldReference or an ArrayReference", "-\t\tthis.constant = Constant.NotAConstant;", "-\t\tif (!(this.lhs instanceof Reference) || this.lhs.isThis()) {", "-\t\t\tscope.problemReporter().expressionShouldBeAVariable(this.lhs);", "-\t\t\treturn null;", "-\t\t}", "-\t\tTypeBinding lhsType = lhs.resolveType(scope);", "-\t\tthis.expression.setExpectedType(lhsType); // needed in case of generic method invocation", "-\t\tif (lhsType != null) ", "-\t\t\tthis.resolvedType = lhsType.capture(scope, this.sourceEnd);", "-\t\tTypeBinding rhsType = this.expression.resolveType(scope);", "-\t\tif (lhsType == null || rhsType == null) {", "-\t\t\treturn null;", "-\t\t}", "-\t\tcheckAssignmentEffect(scope);", "-", "-\t\t// Compile-time conversion of base-types : implicit narrowing integer into byte/short/character", "-\t\t// may require to widen the rhs expression at runtime", "-\t\tif (lhsType != rhsType) // must call before computeConversion() and typeMismatchError()", "-\t\t\tscope.compilationUnitScope().recordTypeConversion(lhsType, rhsType);", "-\t\tif ((this.expression.isConstantValueOfTypeAssignableToType(rhsType, lhsType)", "-\t\t\t\t|| (lhsType.isBaseType() && BaseTypeBinding.isWidening(lhsType.id, rhsType.id)))", "-\t\t\t\t|| rhsType.isCompatibleWith(lhsType)) {", "-\t\t\tthis.expression.computeConversion(scope, lhsType, rhsType);", "-\t\t\tcheckAssignment(scope, lhsType, rhsType);", "-\t\t\tif (this.expression instanceof CastExpression ", "-\t\t\t\t\t&& (this.expression.bits & ASTNode.UnnecessaryCast) == 0) {", "-\t\t\t\tCastExpression.checkNeedForAssignedCast(scope, lhsType, (CastExpression) this.expression);", "-\t\t\t}\t\t\t", "-\t\t\treturn this.resolvedType;", "-\t\t} else if (scope.isBoxingCompatibleWith(rhsType, lhsType) ", "-\t\t\t\t\t\t\t|| (rhsType.isBaseType()  // narrowing then boxing ?", "-\t\t\t\t\t\t\t\t\t&& scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "-\t\t\t\t\t\t\t\t\t&& !lhsType.isBaseType()", "-\t\t\t\t\t\t\t\t\t&& this.expression.isConstantValueOfTypeAssignableToType(rhsType, scope.environment().computeBoxingType(lhsType)))) {", "-\t\t\tthis.expression.computeConversion(scope, lhsType, rhsType);", "-\t\t\tif (this.expression instanceof CastExpression ", "-\t\t\t\t\t&& (this.expression.bits & ASTNode.UnnecessaryCast) == 0) {", "-\t\t\t\tCastExpression.checkNeedForAssignedCast(scope, lhsType, (CastExpression) this.expression);", "-\t\t\t}\t\t\t", "-\t\t\treturn this.resolvedType;", "-\t\t} ", "-\t\tscope.problemReporter().typeMismatchError(rhsType, lhsType, this.expression);", "-\t\treturn lhsType;", "-\t}", "+\t// Compile-time conversion of base-types : implicit narrowing integer into byte/short/character", "+\t// may require to widen the rhs expression at runtime", "+\tif (lhsType != rhsType) // must call before computeConversion() and typeMismatchError()", "+\t\tscope.compilationUnitScope().recordTypeConversion(lhsType, rhsType);", "+\tif ((this.expression.isConstantValueOfTypeAssignableToType(rhsType, lhsType)", "+\t\t\t|| (lhsType.isBaseType() && BaseTypeBinding.isWidening(lhsType.id, rhsType.id)))", "+\t\t\t|| rhsType.isCompatibleWith(lhsType)) {", "+\t\tthis.expression.computeConversion(scope, lhsType, rhsType);", "+\t\tif (this.expression instanceof CastExpression ", "+\t\t\t\t&& (this.expression.bits & ASTNode.UnnecessaryCast) == 0) {", "+\t\t\tCastExpression.checkNeedForAssignedCast(scope, lhsType, (CastExpression) this.expression);", "+\t\t}\t\t\t", "+\t\treturn this.resolvedType;", "+\t} else if (scope.isBoxingCompatibleWith(rhsType, lhsType) ", "+\t\t\t\t\t\t|| (rhsType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t\t&& scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "+\t\t\t\t\t\t\t\t&& !lhsType.isBaseType()", "+\t\t\t\t\t\t\t\t&& this.expression.isConstantValueOfTypeAssignableToType(rhsType, scope.environment().computeBoxingType(lhsType)))) {", "+\t\tthis.expression.computeConversion(scope, lhsType, rhsType);", "+\t\tif (this.expression instanceof CastExpression ", "+\t\t\t\t&& (this.expression.bits & ASTNode.UnnecessaryCast) == 0) {", "+\t\t\tCastExpression.checkNeedForAssignedCast(scope, lhsType, (CastExpression) this.expression);", "+\t\t}\t\t\t", "+\t\treturn this.resolvedType;", "+\t} ", "+\tscope.problemReporter().typeMismatchError(rhsType, lhsType, this.expression);", "+\treturn lhsType;", "+}"]}], "num": 72865}