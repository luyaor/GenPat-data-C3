{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "505677daa20b1d18a35f04da82be7079", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f1e5681ff8df5471c6c66901de839e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "3c97a12fe797bc8f1a4e22eb2cfe11932a52f122", "commitAfterChange": "cb3bfb0879489be8fed32e037d62f37c21d37c6b", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 14, "signatureBeforeChange": " MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod)", "signatureAfterChange": " MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod)", "diff": ["+\tif (length > 0 && inheritedLength != length) return inheritedMethod;", "-\tfor (int i = 0; i < inheritedLength; i++)", "-\t    if (inheritedTypeVariables[i].boundCheck(substitute, arguments[i]) != TypeConstants.OK)", "-\t    \treturn inheritedMethod; // incompatible due to bound check", "+", "+\t// interface I { <T> void foo(T t); }", "+\t// class X implements I { public <T extends I> void foo(T t) {} }", "+\t// for the above case, we do not want to answer the substitute method since its not a match", "+\tfor (int i = 0; i < inheritedLength; i++) {", "+\t\tTypeVariableBinding inheritedTypeVariable = inheritedTypeVariables[i];", "+\t\tTypeBinding argument = arguments[i];", "+\t\tif (argument instanceof TypeVariableBinding) {", "+\t\t\tTypeVariableBinding typeVariable = (TypeVariableBinding) argument;", "+\t\t\tif (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)  ", "+\t\t\t\treturn inheritedMethod; // not a match", "+\t\t\tint interfaceLength = inheritedTypeVariable.superInterfaces.length;", "+\t\t\tReferenceBinding[] interfaces = typeVariable.superInterfaces;", "+\t\t\tif (interfaceLength != interfaces.length)", "+\t\t\t\treturn inheritedMethod; // not a match", "+\t\t\tnext : for (int j = 0; j < interfaceLength; j++) {", "+\t\t\t\tTypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);", "+\t\t\t\tfor (int k = 0; k < interfaceLength; k++)", "+\t\t\t\t\tif (superType == interfaces[k])", "+\t\t\t\t\t\tcontinue next;", "+\t\t\t\treturn inheritedMethod; // not a match", "+\t\t\t}", "+\t\t} else if (inheritedTypeVariables[i].boundCheck(substitute, argument) != TypeConstants.OK) {", "+\t    \treturn inheritedMethod;", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "84ab1bbff6bfb5f0d58cad7e6300ebce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "2e4e63b9ed8aad7925bed1f9109d7e2d1a341f45", "commitAfterChange": "6f2d59d80da8490e52a278944b98c97220ac4149", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "  static MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod, LookupEnvironment environment)", "signatureAfterChange": "  static MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod, LookupEnvironment environment)", "diff": ["-\t\tTypeBinding argument = arguments[i];", "-\t\tif (argument instanceof TypeVariableBinding) {", "-\t\t\tTypeVariableBinding typeVariable = (TypeVariableBinding) argument;", "-\t\t\tif (typeVariable.firstBound == inheritedTypeVariable.firstBound) {", "-\t\t\t\tif (typeVariable.firstBound == null)", "-\t\t\t\t\tcontinue; // both are null", "-\t\t\t} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {", "-\t\t\t\tif (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())", "-\t\t\t\t\treturn inheritedMethod; // not a match", "-\t\t\t}", "-\t\t\tif (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)", "+\t\tTypeVariableBinding typeVariable = (TypeVariableBinding) arguments[i]; // cast is safe by construction: arguments is copied from TypeVariableBinding[]", "+\t\tif (typeVariable.firstBound == inheritedTypeVariable.firstBound) {", "+\t\t\tif (typeVariable.firstBound == null)", "+\t\t\t\tcontinue; // both are null", "+\t\t} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {", "+\t\t\tif (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())", "-\t\t\tint interfaceLength = inheritedTypeVariable.superInterfaces.length;", "-\t\t\tReferenceBinding[] interfaces = typeVariable.superInterfaces;", "-\t\t\tif (interfaceLength != interfaces.length)", "-\t\t\t\treturn inheritedMethod; // not a match", "-\t\t\tnext : for (int j = 0; j < interfaceLength; j++) {", "-\t\t\t\tTypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);", "-\t\t\t\tfor (int k = 0; k < interfaceLength; k++)", "-\t\t\t\t\tif (superType == interfaces[k])", "-\t\t\t\t\t\tcontinue next;", "-\t\t\t\treturn inheritedMethod; // not a match", "-\t\t\t}", "-\t\t} else if (inheritedTypeVariable.boundCheck(substitute, argument, null) != TypeConstants.OK) {", "-\t    \treturn inheritedMethod;", "+\t\t}", "+\t\tif (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)", "+\t\t\treturn inheritedMethod; // not a match", "+\t\tint interfaceLength = inheritedTypeVariable.superInterfaces.length;", "+\t\tReferenceBinding[] interfaces = typeVariable.superInterfaces;", "+\t\tif (interfaceLength != interfaces.length)", "+\t\t\treturn inheritedMethod; // not a match", "+\t\tnext : for (int j = 0; j < interfaceLength; j++) {", "+\t\t\tTypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);", "+\t\t\tfor (int k = 0; k < interfaceLength; k++)", "+\t\t\t\tif (superType == interfaces[k])", "+\t\t\t\t\tcontinue next;", "+\t\t\treturn inheritedMethod; // not a match"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7e3a4302733266d205340553aa69e6e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java", "commitBeforeChange": "c86c38d672e49d50e598810327b66493258e94dd", "commitAfterChange": "060261358ee4101b16c7399fe1e71ff5bc4ac40a", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic boolean isInterchangeableWith(final LookupEnvironment environment, final TypeVariableBinding otherVariable)", "signatureAfterChange": " \tpublic boolean isInterchangeableWith(TypeVariableBinding otherVariable, Substitution substitute)", "diff": ["-\tpublic boolean isInterchangeableWith(final LookupEnvironment environment, final TypeVariableBinding otherVariable) {", "+\tpublic boolean isInterchangeableWith(TypeVariableBinding otherVariable, Substitution substitute) {", "-\t\tidentical: {", "-\t\t\tif (this.superclass != otherVariable.superclass) {", "-\t\t\t\tif (this.superclass.erasure() != otherVariable.superclass.erasure())", "-\t\t\t\t\treturn false; // no way it can match after substitution", "-\t\t\t\tbreak identical;", "-\t\t\t}", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tif (this.superInterfaces[i] != otherVariable.superInterfaces[i]) {", "-\t\t\t\t\tif (this.superInterfaces[i].erasure() != otherVariable.superInterfaces[i].erasure())", "-\t\t\t\t\t\treturn false; // no way it can match after substitution", "-\t\t\t\t\tbreak identical;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn true;", "-\t\t}", "-\t\t// need substitutions", "-\t\tSubstitution subst = new Substitution() {", "-\t\t\tpublic LookupEnvironment environment() { return environment; }", "-\t\t\tpublic boolean isRawSubstitution() { return false; }", "-\t\t\tpublic TypeBinding substitute(TypeVariableBinding typeVariable) {", "-\t\t\t\treturn typeVariable == otherVariable ? TypeVariableBinding.this : typeVariable;", "-\t\t\t}", "-\t\t};", "-\t\tif (this.superclass != Scope.substitute(subst, otherVariable.superclass))", "+\t\tif (this.superclass != Scope.substitute(substitute, otherVariable.superclass))", "-\t\tfor (int i = 0; i < length; i++)", "-\t\t\tif (this.superInterfaces[i] != Scope.substitute(subst, otherVariable.superInterfaces[i]))", "-\t\t\t\treturn false;", "+", "+\t\tnext : for (int i = 0; i < length; i++) {", "+\t\t\tTypeBinding superType = Scope.substitute(substitute, otherVariable.superInterfaces[i]);", "+\t\t\tfor (int j = 0; j < length; j++)", "+\t\t\t\tif (superType == this.superInterfaces[j])", "+\t\t\t\t\tcontinue next;", "+\t\t\treturn false; // not a match", "+\t\t}"]}], "num": 40222}