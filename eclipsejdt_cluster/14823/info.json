{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3b5f099b12da44b78b984794df8a9f58", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1621be3bcf8d3147a28b6227002484ca", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java", "commitBeforeChange": "e5bb4bddaa8ae27dfddec859067bcb3df83df4dc", "commitAfterChange": "65877d9109defab8c1c7191e1a9530b8bc8f9b43", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic void analyseCode(ClassScope classScope, InitializationFlowContext initializationContext, FlowInfo flowInfo)", "signatureAfterChange": "  \tpublic void analyseCode(ClassScope classScope, InitializationFlowContext initializationContext, FlowInfo flowInfo)", "diff": ["+\t\t\t\t\t// if this method uses a type parameter declared by the declaring class,", "+\t\t\t\t\t// it can't be static. https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682", "+\t\t\t\t\tif (this.arguments[i].binding != null && (this.arguments[i].binding.type instanceof TypeVariableBinding)) {", "+\t\t\t\t\t\tBinding declaringElement = ((TypeVariableBinding)this.arguments[i].binding.type).declaringElement;", "+\t\t\t\t\t\tif (this.binding != null && this.binding.declaringClass == declaringElement)", "+\t\t\t\t\t\t\tthis.bits &= ~ASTNode.CanBeStatic;", "+\t\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (this.binding.declaringClass instanceof MemberTypeBinding && !this.binding.declaringClass.isStatic()) {", "+\t\t\t\t// method of a non-static member type can't be static.", "+\t\t\t\tthis.bits &= ~ASTNode.CanBeStatic;", "+\t\t\t} else {", "+\t\t\t\t// method with empty body should not be flagged as static.", "+\t\t\t\tthis.bits &= ~ASTNode.CanBeStatic;", "+\t\t\t// check if the method could have been static", "+\t\t\tif (!this.binding.isStatic() && (this.bits & ASTNode.CanBeStatic) != 0) {", "+\t\t\t\tif(!this.binding.isOverriding() && !this.binding.isImplementing()) {", "+\t\t\t\t\tif (this.binding.isPrivate() || this.binding.isFinal() || this.binding.declaringClass.isFinal()) {", "+\t\t\t\t\t\tthis.scope.problemReporter().methodCanBeDeclaredStatic(this);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.scope.problemReporter().methodCanBePotentiallyDeclaredStatic(this);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc5efa13ec57ca5e17bfcd33973235bd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\t\tif (!((LocalVariableBinding) this.binding).isFinal() && ((this.bits & ASTNode.DepthMASK) != 0))", "-\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal(", "-\t\t\t\t\t\t\t(LocalVariableBinding) this.binding,", "-\t\t\t\t\t\t\tthis);", "+\t\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) this.binding;", "+\t\t\t\t\tif (!local.isFinal() && ((this.bits & ASTNode.DepthMASK) != 0))", "+\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal((LocalVariableBinding) this.binding, this);", "-\t\t\t\t\treturn this.resolvedType = getOtherFieldBindings(scope);", "+\t\t\t\t\tif (local.type != null && (local.type.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\t\t// only complain if field reference (for local, its type got flagged already)", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.resolvedType = getOtherFieldBindings(scope);", "+\t\t\t\t\tif (this.resolvedType != null ", "+\t\t\t\t\t\t\t&& (this.resolvedType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\t\tFieldBinding lastField = this.otherBindings[this.otherBindings.length - 1];", "+\t\t\t\t\t\tscope.problemReporter().invalidField(this, new ProblemFieldBinding(lastField.declaringClass, lastField.name, ProblemReasons.NotFound), this.tokens.length, this.resolvedType.leafComponentType());", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "+\t\t\t\t\treturn this.resolvedType;\t\t\t\t\t", "-\t\t\t\t\t", "-\t\t\t\t\treturn this.resolvedType = getOtherFieldBindings(scope);", "+\t\t\t\t\tthis.resolvedType = getOtherFieldBindings(scope);", "+\t\t\t\t\tif (this.resolvedType != null ", "+\t\t\t\t\t\t\t&& (this.resolvedType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\t\tFieldBinding lastField = this.indexOfFirstFieldBinding == this.tokens.length ? (FieldBinding)this.binding : this.otherBindings[this.otherBindings.length - 1];", "+\t\t\t\t\t\tscope.problemReporter().invalidField(this, new ProblemFieldBinding(lastField.declaringClass, lastField.name, ProblemReasons.NotFound), this.tokens.length, this.resolvedType.leafComponentType());", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "+\t\t\t\t\treturn this.resolvedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f87a7675d7ae83e42a13a4d28b83a91e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "da3abb814c31b6e1c2d43312de494af316e19273", "commitAfterChange": "8af0e3d96f10bb27360a77bbd330487cf3fdc8dd", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprotected boolean parseReference(boolean plain) throws InvalidInputException", "signatureAfterChange": " \tprotected boolean parseReference() throws InvalidInputException", "diff": ["-\tprotected boolean parseReference(boolean plain) throws InvalidInputException {", "-\t\tObject typeRef = null;", "-\t\tObject reference = null;", "-\t\tint previousPosition = -1;", "-\t\tint typeRefStartPosition = -1;", "-\t\tnextToken : while (this.index < this.scanner.eofPosition) {", "-\t\t\tpreviousPosition = this.index;", "-\t\t\tint token = readToken();", "-\t\t\tswitch (token) {", "-\t\t\t\tcase TerminalTokens.TokenNameStringLiteral : // @see \"string\"", "-\t\t\t\t\tint start = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "-\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "-\t\t\t\t\tif (typeRef != null) {", "-\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "-\t\t\t\t\t\tpreviousPosition = start;", "-\t\t\t\t\t\ttypeRef = null;", "-\t\t\t\t\t}", "-\t\t\t\t\t// verify end line (expecting empty or end comment)", "-\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "-\t\t\t\t\t\treturn true;", "-\t\t\t\t\t}", "-\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidSeeReference(start, this.lineEnd);", "-\t\t\t\t\treturn false;", "-\t\t\t\tcase TerminalTokens.TokenNameLESS : // @see \"<a href=\"URL#Value\">label</a>", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\tif (parseHref()) {", "+\tprotected boolean parseReference() throws InvalidInputException {", "+\t\tint currentPosition = this.scanner.currentPosition;", "+\t\ttry {", "+\t\t\tObject typeRef = null;", "+\t\t\tObject reference = null;", "+\t\t\tint previousPosition = -1;", "+\t\t\tint typeRefStartPosition = -1;", "+\t\t\t", "+\t\t\t// Get reference tokens", "+\t\t\tnextToken : while (this.index < this.scanner.eofPosition) {", "+\t\t\t\tpreviousPosition = this.index;", "+\t\t\t\tint token = readToken();", "+\t\t\t\tswitch (token) {", "+\t\t\t\t\tcase TerminalTokens.TokenNameStringLiteral : // @see \"string\"", "-\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "-\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "-\t\t\t\t\t\tif (typeRef != null) {", "-\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "-\t\t\t\t\t\t\tpreviousPosition = start;", "-\t\t\t\t\t\t\ttypeRef = null;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "-\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "-\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidSeeReference(start, this.lineEnd);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn false;", "-\t\t\t\tcase TerminalTokens.TokenNameERROR :", "-\t\t\t\t\tif (this.scanner.currentCharacter == '#') { // @see ...#member", "-\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\treference = parseMember(typeRef);", "-\t\t\t\t\t\tif (reference != null) {", "-\t\t\t\t\t\t\treturn pushSeeRef(reference, plain);", "+\t\t\t\t\t\tint start = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidValueReference(start, getTokenEndPosition());", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "+\t\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidReference(start, this.lineEnd);", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak nextToken;", "-\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\tif (typeRef == null) {", "-\t\t\t\t\t\ttypeRefStartPosition = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\ttypeRef = parseQualifiedName(true);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak nextToken;", "-\t\t\t\tdefault :", "-\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\tcase TerminalTokens.TokenNameLESS : // @see \"<a href=\"URL#Value\">label</a>", "+\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tif (parseHref()) {", "+\t\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "+\t\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.tagValue != TAG_VALUE_VALUE && this.sourceParser != null) {", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidReference(start, this.lineEnd);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE && this.sourceParser != null) {", "+\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidValueReference(start, getIndexPosition());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\tcase TerminalTokens.TokenNameERROR :", "+\t\t\t\t\t\tif (this.scanner.currentCharacter == '#') { // @see ...#member", "+\t\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t\treference = parseMember(typeRef);", "+\t\t\t\t\t\t\tif (reference != null) {", "+\t\t\t\t\t\t\t\treturn pushSeeRef(reference);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\tif (typeRef == null) {", "+\t\t\t\t\t\t\ttypeRefStartPosition = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\ttypeRef = parseQualifiedName(true);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// Verify that we got a reference", "-\t\tif (reference == null) reference = typeRef;", "-\t\tif (reference == null) {", "-\t\t\tthis.index = this.tokenPreviousPosition;", "-\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+", "+\t\t\t// Verify that we got a reference", "+\t\t\tif (reference == null) reference = typeRef;", "+\t\t\tif (reference == null) {", "+\t\t\t\tthis.index = this.tokenPreviousPosition;", "+\t\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\t\tif (this.kind == DOM_PARSER) createTag();", "+\t\t\t\t\treturn true;", "+\t\t\t\t}", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingReference(this.tagSourceStart, this.tagSourceEnd);", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\t// Reset position at the end of type reference", "+\t\t\tthis.index = this.lastIdentifierEndPosition+1;", "+\t\t\tthis.scanner.currentPosition = this.index;", "-\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingSeeReference(this.tagSourceStart, this.tagSourceEnd);", "-\t\t\treturn false;", "+", "+\t\t\t// In case of @value, we have an invalid reference (only static field refs are valid for this tag)", "+\t\t\tif (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidReference(typeRefStartPosition, this.lineEnd);", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\t// Verify that line end does not start with an open parenthese (which could be a constructor reference wrongly written...)", "+\t\t\t// See bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=47215", "+\t\t\tchar ch = peekChar();", "+\t\t\tif (ch == '(') {", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingHashCharacter(typeRefStartPosition, this.lineEnd, String.valueOf(this.source, typeRefStartPosition, this.lineEnd-typeRefStartPosition+1));", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\t// Verify that we get white space after reference", "+\t\t\tif (!verifySpaceOrEndComment()) {", "+\t\t\t\tthis.index = this.tokenPreviousPosition;", "+\t\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tint end = this.starPosition == -1 ? this.lineEnd : this.starPosition;", "+\t\t\t\tif (this.source[end]=='\\n') end--;", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMalformedSeeReference(typeRefStartPosition, end);", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t\t", "+\t\t\t// Everything is OK, store reference", "+\t\t\treturn pushSeeRef(reference);", "-", "-\t\t// Reset position at the end of type reference", "-\t\tthis.index = this.lastIdentifierEndPosition+1;", "-\t\tthis.scanner.currentPosition = this.index;", "-\t\tthis.currentTokenType = -1;", "-", "-\t\t// Verify that line end does not start with an open parenthese (which could be a constructor reference wrongly written...)", "-\t\t// See bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=47215", "-\t\tchar ch = peekChar();", "-\t\tif (ch == '(') {", "-\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingHashCharacter(typeRefStartPosition, this.lineEnd, String.valueOf(this.source, typeRefStartPosition, this.lineEnd-typeRefStartPosition+1));", "-\t\t\treturn false;", "-\t\t}", "-", "-\t\t// Verify that we get white space after reference", "-\t\tif (!verifySpaceOrEndComment()) {", "-\t\t\tthis.index = this.tokenPreviousPosition;", "-\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "-\t\t\tthis.currentTokenType = -1;", "-\t\t\tint end = this.starPosition == -1 ? this.lineEnd : this.starPosition;", "-\t\t\tif (this.source[end]=='\\n') end--;", "-\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMalformedSeeReference(typeRefStartPosition, end);", "-\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\t// Everything is OK, store reference", "-\t\treturn pushSeeRef(reference, plain);", "-\t}", "+\t\tcatch (InvalidInputException ex) {", "+\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidReference(currentPosition, getTokenEndPosition());"]}], "num": 14823}