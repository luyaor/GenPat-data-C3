{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5079d1d00aedd9acc86366136f30edc1", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37d842d62336aa5eff6f32e0eb358829", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "1784048e951cac8e5c6590cc5827817757e6384e", "commitAfterChange": "4a48abb3b4027036bdeac61104059b6c83710144", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int javadocStart, int javadocEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int javadocStart, int javadocEnd)", "diff": ["+\t\t\tthis.index = javadocStart +3;", "+\t\t\tint endComment = javadocEnd - 2;", "+\t\t\t\t// Initialization", "-\t\t\t} else if (this.sourceParser.options.getSeverity(CompilerOptions.MissingJavadocComments) != ProblemSeverities.Ignore) {", "-\t\t\t\tthis.javadoc = new Javadoc(javadocStart, javadocEnd);", "-\t\t\t} else {", "-\t\t\t\tthis.javadoc = null;", "-\t\t\t}", "-", "-\t\t\tint firstLineNumber = this.sourceParser.scanner.getLineNumber(javadocStart);", "-\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(javadocEnd);", "-", "-\t\t\t// scan line per line, since tags must be at beginning of lines only", "-\t\t\tnextLine : for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "-\t\t\t\tint lineStart = line == firstLineNumber", "-\t\t\t\t\t\t? javadocStart + 3 // skip leading /**", "-\t\t\t\t\t\t: this.sourceParser.scanner.getLineStart(line);", "-\t\t\t\tthis.index = lineStart;", "-\t\t\t\tthis.lineEnd = line == lastLineNumber", "-\t\t\t\t\t\t? javadocEnd - 2 // remove trailing */", "-\t\t\t\t\t\t: this.sourceParser.scanner.getLineEnd(line);", "-\t\t\t\twhile (this.index < this.lineEnd) {", "-\t\t\t\t\tchar nextCharacter = readChar(); // consider unicodes", "+\t\t\t\tthis.scanner.startPosition = this.index;", "+\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\tthis.lineStarted = false;", "+\t\t\t\tint lineNumber = this.sourceParser.scanner.getLineNumber(javadocStart);", "+\t\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(javadocEnd);", "+\t\t\t\tthis.lineEnd = lineNumber == lastLineNumber ? javadocEnd - 2 : javadocStart + 3;", "+\t\t\t\tchar nextCharacter= 0, previousChar;", "+\t\t\t\tint charPosition = -1, inlineStartPosition = 0;", "+\t\t\t\t", "+\t\t\t\t// Loop on each comment character", "+\t\t\t\twhile (this.index < endComment) {", "+\t\t\t\t\tint previousPosition = this.index;", "+\t\t\t\t\tpreviousChar = nextCharacter;", "+\t\t\t\t\t", "+\t\t\t\t\t// Calculate line end (cannot use this.scanner.linePtr as scanner does not parse line ends again)", "+\t\t\t\t\tif (this.index > this.lineEnd) {", "+\t\t\t\t\t\tif (lineNumber < lastLineNumber) {", "+\t\t\t\t\t\t\tthis.lineEnd = this.sourceParser.scanner.getLineEnd(++lineNumber) - 1;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.lineEnd = javadocEnd - 2;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.lineStarted = false;", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// Read next char only if token was consumed", "+\t\t\t\t\tif (this.currentTokenType < 0) {", "+\t\t\t\t\t\tnextCharacter = readChar(); // consider unicodes", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tswitch (this.currentTokenType) {", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameRBRACE:", "+\t\t\t\t\t\t\t\tnextCharacter = '}';", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "+\t\t\t\t\t\t\t\tnextCharacter = '*';", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\tnextCharacter = this.scanner.currentCharacter;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t}", "+\t\t\t\t\t", "-\t\t\t\t\t\t\tif (!this.checkJavadoc) {", "-\t\t\t\t\t\t\t\tif ((readChar() == 'd') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'e') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'p') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'r') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'e') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'c') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'a') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 't') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'e') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'd')) {", "-\t\t\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "-\t\t\t\t\t\t\t\t\tnextCharacter = readChar();", "-\t\t\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "-\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t\t\tbreak nextLine; // done", "+\t\t\t\t\t\t\tboolean valid = false;", "+\t\t\t\t\t\t\t// Start tag parsing only if we are on line beginning or at inline tag beginning", "+\t\t\t\t\t\t\tif (!this.lineStarted || previousChar == '{') {", "+\t\t\t\t\t\t\t\tthis.lineStarted = true;", "+\t\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "+\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\t\t\t\t\t\tint start = this.astStack[this.astPtr].sourceStart;", "+\t\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidTag(start, charPosition);", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tif (previousChar == '{') {", "+\t\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = true;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, endComment);", "+\t\t\t\t\t\t\t\t\tthis.currentTokenType = -1; // flush token cache at line begin", "+\t\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "+\t\t\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\t\t\t\tswitch (tk) {", "+\t\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_INHERITDOC)) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tthis.javadoc.inherited = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseParam();", "+\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseThrows();", "+\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE) ||", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.equals(tag, TAG_LINK) ||", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.equals(tag, TAG_LINKPLAIN)) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseSee();", "+\t\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseTag();", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "+\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseReturn();", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamethrows :", "+\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseThrows();", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tif (!valid && this.inlineTagStarted) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\t\t\tcontinue nextLine;", "-\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.lineEnd);", "-\t\t\t\t\t\t\tthis.currentTokenType = -1; // flush token cache at line begin", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "-\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\t\t\tswitch (tk) {", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "-\t\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "-\t\t\t\t\t\t\t\t\t\t\tparseParam();", "-\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {", "-\t\t\t\t\t\t\t\t\t\t\tparseThrows();", "-\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE)) {", "-\t\t\t\t\t\t\t\t\t\t\tparseSee();", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "-\t\t\t\t\t\t\t\t\t\tparseReturn();", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamethrows :", "-\t\t\t\t\t\t\t\t\t\tparseThrows();", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase '\\r':", "+\t\t\t\t\t\tcase '\\n':", "+\t\t\t\t\t\t\tthis.lineStarted = false;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase '}' :", "+\t\t\t\t\t\t\tif (this.inlineTagStarted) this.inlineTagStarted = false;", "+\t\t\t\t\t\t\tthis.lineStarted = true;", "+\t\t\t\t\t\t\tcharPosition = previousPosition;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase '{' :", "+\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "+\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidTag(inlineStartPosition, this.index);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tinlineStartPosition = previousPosition;", "-\t\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcharPosition = previousPosition;", "-\t\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) {", "-\t\t\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\t\tcharPosition = previousPosition;", "+\t\t\t\t\t\t\tif (!this.lineStarted && !CharOperation.isWhitespace(nextCharacter)) {", "+\t\t\t\t\t\t\t\tthis.lineStarted = true;", "+\t\t\t} else {", "+\t\t\t\t// Init javadoc if necessary", "+\t\t\t\tif (this.sourceParser.options.getSeverity(CompilerOptions.MissingJavadocComments) != ProblemSeverities.Ignore) {", "+\t\t\t\t\tthis.javadoc = new Javadoc(javadocStart, javadocEnd);", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.javadoc = null;", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// Parse comment", "+\t\t\t\tint firstLineNumber = this.sourceParser.scanner.getLineNumber(javadocStart);", "+\t\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(javadocEnd);", "+\t", "+\t\t\t\t// scan line per line, since tags must be at beginning of lines only", "+\t\t\t\tnextLine : for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "+\t\t\t\t\tint lineStart = line == firstLineNumber", "+\t\t\t\t\t\t\t? javadocStart + 3 // skip leading /**", "+\t\t\t\t\t\t\t: this.sourceParser.scanner.getLineStart(line);", "+\t\t\t\t\tthis.index = lineStart;", "+\t\t\t\t\tthis.lineEnd = line == lastLineNumber", "+\t\t\t\t\t\t\t? javadocEnd - 2 // remove trailing * /", "+\t\t\t\t\t\t\t: this.sourceParser.scanner.getLineEnd(line);", "+\t\t\t\t\twhile (this.index < this.lineEnd) {", "+\t\t\t\t\t\tchar nextCharacter = readChar(); // consider unicodes", "+\t\t\t\t\t\tif  (nextCharacter == '@' &&", "+\t\t\t\t\t\t\t(readChar() == 'd') &&", "+\t\t\t\t\t\t\t(readChar() == 'e') &&", "+\t\t\t\t\t\t\t(readChar() == 'p') &&", "+\t\t\t\t\t\t\t(readChar() == 'r') &&", "+\t\t\t\t\t\t\t(readChar() == 'e') &&", "+\t\t\t\t\t\t\t(readChar() == 'c') &&", "+\t\t\t\t\t\t\t(readChar() == 'a') &&", "+\t\t\t\t\t\t\t(readChar() == 't') &&", "+\t\t\t\t\t\t\t(readChar() == 'e') &&", "+\t\t\t\t\t\t\t(readChar() == 'd'))", "+\t\t\t\t\t\t{", "+\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "+\t\t\t\t\t\t\tnextCharacter = readChar();", "+\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "711dd92b14122f19aba0a9e6dbc1a86c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "73e6c55b6cebcb032c8128286708483f86167b64", "commitAfterChange": "5326f4925981afee39790c88bc133bd18e542033", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "diff": ["-\t\t\tif (this.checkAnnotation && this.scanner.source != null) {", "+\t\t\tif (this.checkAnnotation) {", "-\t\t\t\t\t\t\tif (this.annotation == null) {", "+\t\t\t\t\t\t\tif (!this.checkAnnotation) {", "-\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.lineEnd);", "-\t\t\t\t\t\tthis.currentTokenType = -1; // flush token cache at line begin", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "-\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\t\tswitch (tk) {", "-\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "-\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "-\t\t\t\t\t\t\t\t\tparseParam();", "-\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {", "-\t\t\t\t\t\t\t\t\tparseThrows();", "-\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE)) {", "-\t\t\t\t\t\t\t\t\tparseSee();", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.lineEnd);", "+\t\t\t\t\t\t\tthis.currentTokenType = -1; // flush token cache at line begin", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "+\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\t\tswitch (tk) {", "+\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "+\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "+\t\t\t\t\t\t\t\t\t\tparseParam();", "+\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\t\t\t\tparseThrows();", "+\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE)) {", "+\t\t\t\t\t\t\t\t\t\tparseSee();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "+\t\t\t\t\t\t\t\t\t\tparseReturn();", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamethrows :", "+\t\t\t\t\t\t\t\t\t\tparseThrows();", "+\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "-\t\t\t\t\t\t\t\t\tparseReturn();", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamethrows :", "-\t\t\t\t\t\t\t\t\tparseThrows();", "-\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\t\tcontinue nextLine;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "759e021d0a2d998c1fd68768665b1e31", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "618f3771c49dbf9480ae16a58263680af2b36ad6", "commitAfterChange": "7cfc4523cdcfe787f1d0d2fd75b08c06e5b4b089", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int javadocStart, int javadocEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int javadocStart, int javadocEnd)", "diff": ["-\t\tboolean foundDeprecated = false;", "-\t\t\tint endComment = javadocEnd - 2;", "+\t\t\tthis.endComment = javadocEnd - 2;", "-\t\t\t\tthis.astLengthPtr = -1;", "-\t\t\t\tthis.astPtr = -1;", "-\t\t\t\tthis.currentTokenType = -1;", "-\t\t\t\tthis.scanner.startPosition = this.index;", "-\t\t\t\tthis.inlineTagStarted = false;", "-\t\t\t\tthis.lineStarted = false;", "-\t\t\t\tint lineNumber = this.sourceParser.scanner.getLineNumber(javadocStart);", "-\t\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(javadocEnd);", "-\t\t\t\tthis.lineEnd = lineNumber == lastLineNumber ? javadocEnd - 2 : javadocStart + 3;", "-\t\t\t\tchar nextCharacter= 0, previousChar;", "-\t\t\t\tint charPosition = -1, inlineStartPosition = 0;", "-\t\t\t\t", "-\t\t\t\t// Loop on each comment character", "-\t\t\t\twhile (this.index < endComment) {", "-\t\t\t\t\tint previousPosition = this.index;", "-\t\t\t\t\tpreviousChar = nextCharacter;", "-\t\t\t\t\t", "-\t\t\t\t\t// Calculate line end (cannot use this.scanner.linePtr as scanner does not parse line ends again)", "-\t\t\t\t\tif (this.index > this.lineEnd) {", "-\t\t\t\t\t\tif (lineNumber < lastLineNumber) {", "-\t\t\t\t\t\t\tthis.lineEnd = this.sourceParser.scanner.getLineEnd(++lineNumber) - 1;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tthis.lineEnd = javadocEnd - 2;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.lineStarted = false;", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\t// Read next char only if token was consumed", "-\t\t\t\t\tif (this.currentTokenType < 0) {", "-\t\t\t\t\t\tnextCharacter = readChar(); // consider unicodes", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tswitch (this.currentTokenType) {", "-\t\t\t\t\t\t\tcase TerminalTokens.TokenNameRBRACE:", "-\t\t\t\t\t\t\t\tnextCharacter = '}';", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "-\t\t\t\t\t\t\t\tnextCharacter = '*';", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\tnextCharacter = this.scanner.currentCharacter;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\tswitch (nextCharacter) {", "-\t\t\t\t\t\tcase '@' :", "-\t\t\t\t\t\t\tboolean valid = false;", "-\t\t\t\t\t\t\t// Start tag parsing only if we are on line beginning or at inline tag beginning", "-\t\t\t\t\t\t\tif (!this.lineStarted || previousChar == '{') {", "-\t\t\t\t\t\t\t\tthis.lineStarted = true;", "-\t\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "-\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "-\t\t\t\t\t\t\t\t\tint start = this.astStack[this.astPtr].sourceStart;", "-\t\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidTag(start, charPosition);", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tif (previousChar == '{') {", "-\t\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = true;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, endComment);", "-\t\t\t\t\t\t\t\t\tthis.currentTokenType = -1; // flush token cache at line begin", "-\t\t\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "-\t\t\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\t\t\t\t\tswitch (tk) {", "-\t\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = true;", "-\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_INHERITDOC)) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tthis.javadoc.inherited = true;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = true;", "-\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseParam();", "-\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseThrows();", "-\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE) ||", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.equals(tag, TAG_LINK) ||", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.equals(tag, TAG_LINKPLAIN)) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseSee();", "-\t\t\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseTag();", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "-\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseReturn();", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamethrows :", "-\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseThrows();", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tif (!valid && this.inlineTagStarted) {", "-\t\t\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase '\\r':", "-\t\t\t\t\t\tcase '\\n':", "-\t\t\t\t\t\t\tthis.lineStarted = false;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase '}' :", "-\t\t\t\t\t\t\tif (this.inlineTagStarted) this.inlineTagStarted = false;", "-\t\t\t\t\t\t\tthis.lineStarted = true;", "-\t\t\t\t\t\t\tcharPosition = previousPosition;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase '{' :", "-\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "-\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "-\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidTag(inlineStartPosition, this.index);", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tinlineStartPosition = previousPosition;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase '*' :", "-\t\t\t\t\t\t\tcharPosition = previousPosition;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tdefault :", "-\t\t\t\t\t\t\tcharPosition = previousPosition;", "-\t\t\t\t\t\t\tif (!this.lineStarted && !CharOperation.isWhitespace(nextCharacter)) {", "-\t\t\t\t\t\t\t\tthis.lineStarted = true;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t\tsuper.checkDeprecation(javadocStart, javadocEnd);", "-\t\t\tif (this.checkJavadoc) {", "-\t\t\t\tupdateJavadoc();", "-\t\t\t}", "-\t\treturn foundDeprecated;", "+\t\treturn this.deprecated;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b5190495328fb0beb7d4f7c554403f56", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "d5b9ab15bb3f769b7e2ac485fe6da55027818828", "commitAfterChange": "e98478cd38caef5e23457b8b0fdc364bf2846afc", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "diff": ["-\t", "+", "-\t\t\t//this.problemReporter = sourceParser.problemReporter();", "-\t\t\t\t//if (this.scanner.source == null) {", "-\t\t\t\t//\tthis.scanner.setSource(this.source);", "-\t\t\t\t//}", "-\t\t\t\t//this.scanner.setSource(CharOperation.subarray(this.source, annotationStart, annotationEnd+1));", "-\t\t\t\t//this.source = this.scanner.source;", "-\t\t\t} ", "-\t\t", "+\t\t\t}", "+", "-\t\t\t\t\t", "+", "-\t\t\tnextLine: for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "-\t\t\t\tint lineStart = line == firstLineNumber ", "-\t\t\t\t\t\t? annotationStart + 3 \t\t// skip leading /**", "-\t\t\t\t\t\t:  this.sourceParser.scanner.getLineStart(line);", "-\t\t\t\t//lineStart -= annotationStart;", "+\t\t\tnextLine : for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "+\t\t\t\tint lineStart = line == firstLineNumber", "+\t\t\t\t\t\t? annotationStart + 3 // skip leading /**", "+\t\t\t\t\t\t: this.sourceParser.scanner.getLineStart(line);", "-\t\t\t\t\t\t? annotationEnd - 2 \t\t// remove trailing */", "-\t\t\t\t\t\t:  this.sourceParser.scanner.getLineEnd(line);", "-\t\t\t\t//this.lineEnd -= annotationStart;", "+\t\t\t\t\t\t? annotationEnd - 2 // remove trailing */", "+\t\t\t\t\t\t: this.sourceParser.scanner.getLineEnd(line);", "-\t\t\t\t\tswitch(nextCharacter) {", "+\t\t\t\t\tswitch (nextCharacter) {", "-\t\t\t\t\t\t\t\tif ((readChar() == 'd')", "-\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "-\t\t\t\t\t\t\t\t\t&& (readChar() == 'p')", "-\t\t\t\t\t\t\t\t\t&& (readChar() == 'r')", "-\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "-\t\t\t\t\t\t\t\t\t&& (readChar() == 'c')", "-\t\t\t\t\t\t\t\t\t&& (readChar() == 'a')", "-\t\t\t\t\t\t\t\t\t&& (readChar() == 't')", "-\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "-\t\t\t\t\t\t\t\t\t&& (readChar() == 'd')) {", "+\t\t\t\t\t\t\t\tif ((readChar() == 'd') &&", "+\t\t\t\t\t\t\t\t\t(readChar() == 'e') &&", "+\t\t\t\t\t\t\t\t\t(readChar() == 'p') &&", "+\t\t\t\t\t\t\t\t\t(readChar() == 'r') &&", "+\t\t\t\t\t\t\t\t\t(readChar() == 'e') &&", "+\t\t\t\t\t\t\t\t\t(readChar() == 'c') &&", "+\t\t\t\t\t\t\t\t\t(readChar() == 'a') &&", "+\t\t\t\t\t\t\t\t\t(readChar() == 't') &&", "+\t\t\t\t\t\t\t\t\t(readChar() == 'e') &&", "+\t\t\t\t\t\t\t\t\t(readChar() == 'd')) {", "-\t\t\t\t\t\t\t} ", "-\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.lineEnd);", "-\t\t\t\t\t\t\tthis.currentTokenType = -1; // flush token cache at line begin", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tint tk = readConsumeToken();", "-\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\t\t\tswitch (tk) {", "-\t\t\t\t\t\t\t\t\tcase  TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "-\t\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "-\t\t\t\t\t\t\t\t\t\t\tparseParam();", "-\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {", "-\t\t\t\t\t\t\t\t\t\t\tparseThrows();", "-\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE)) {", "-\t\t\t\t\t\t\t\t\t\t\tparseSee();", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "-\t\t\t\t\t\t\t\t\t\tparseReturn();", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamethrows :", "-\t\t\t\t\t\t\t\t\t\tparseThrows();", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "-\t \t\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.lineEnd);", "+\t\t\t\t\t\tthis.currentTokenType = -1; // flush token cache at line begin", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "+\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tswitch (tk) {", "+\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "+\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "+\t\t\t\t\t\t\t\t\tparseParam();", "+\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\t\t\tparseThrows();", "+\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE)) {", "+\t\t\t\t\t\t\t\t\tparseSee();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "+\t\t\t\t\t\t\t\t\tparseReturn();", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamethrows :", "+\t\t\t\t\t\t\t\t\tparseThrows();", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcontinue nextLine;", "-\t\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) continue nextLine;", "+\t\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) {", "+\t\t\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\t\t}", "-\t\t}\t\t", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc8392b12ceb2ea622873ccaa8a5fb39", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "6a44e0777af1a4632e0d20c0e9b92d35d2ad59f3", "commitAfterChange": "2ca339c139c0fe73a5bd2705f66592731098d347", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "diff": ["-\t\tchar[] source = this.scanner.source;", "-\t\tif (false/*this.sourceParser.checkAnnotation*/) {", "-\t\t\tthis.annotation = new Annotation(annotationStart, annotationEnd);", "-\t\t} else {", "-\t\t\tthis.annotation = null;", "-\t\t} ", "-\t", "-\t\tint firstLineNumber = this.scanner.getLineNumber(annotationStart);", "-\t\tint lastLineNumber = this.scanner.getLineNumber(annotationEnd);", "-\t\tint[] index = new int[]{ 0 };", "-\t\t\t\t", "-\t\t// scan line per line, since tags are supposed to be at beginning of lines only", "-\t\tnextLine: for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "-\t\t\tint lineStart = this.scanner.getLineStart(line);", "-\t\t\tif (line == firstLineNumber) lineStart = annotationStart + 3; // skip leading /**", "-\t\t\tint lineEnd = this.scanner.getLineEnd(line);", "-\t\t\tif (line == lastLineNumber) lineEnd = annotationEnd - 2; // remove trailing */", "-\t\t\tindex[0] = lineStart;", "-\t\t\tboolean foundStar = false;", "-\t\t\twhile (index[0] < lineEnd) {", "-\t\t\t\tchar nextCharacter = getNextCharacter(source, index); // consider unicodes", "-\t\t\t\tswitch(nextCharacter) {", "-\t\t\t\t\tcase '@' :", "-\t\t\t\t\t\tif (this.annotation == null) {", "-\t\t\t\t\t\t\tif ((getNextCharacter(source, index) == 'd')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'p')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'r')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'c')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'a')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 't')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'd')) {", "-\t\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "-\t\t\t\t\t\t\t\tnextCharacter = getNextCharacter(source, index);", "-\t\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "-\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t\tbreak nextLine; // done", "+\t\ttry {", "+\t\t\tthis.source = this.sourceParser.scanner.source;", "+\t\t\tif (this.sourceParser.options.checkAnnotation) {", "+\t\t\t\tthis.annotation = new Annotation(annotationStart, annotationEnd);", "+\t\t\t\tthis.identifierPtr = -1;", "+\t\t\t} else {", "+\t\t\t\tthis.annotation = null;", "+\t\t\t} ", "+\t\t", "+\t\t\tint firstLineNumber = this.sourceParser.scanner.getLineNumber(annotationStart);", "+\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(annotationEnd);", "+\t\t\t\t\t", "+\t\t\t// scan line per line, since tags must be at beginning of lines only", "+\t\t\tnextLine: for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "+\t\t\t\tboolean foundStar = false;", "+\t\t\t\tint lineStart = line == firstLineNumber ", "+\t\t\t\t\t\t? annotationStart + 3 \t\t// skip leading /**", "+\t\t\t\t\t\t:  this.sourceParser.scanner.getLineStart(line);", "+\t\t\t\tthis.index[0] = lineStart;", "+\t\t\t\tint lineEnd = line == lastLineNumber", "+\t\t\t\t\t\t? annotationEnd - 2 \t\t// remove trailing */", "+\t\t\t\t\t\t:  this.sourceParser.scanner.getLineEnd(line);", "+\t\t\t\twhile (this.index[0] < lineEnd) {", "+\t\t\t\t\tchar nextCharacter = readChar(); // consider unicodes", "+\t\t\t\t\tswitch(nextCharacter) {", "+\t\t\t\t\t\tcase '@' :", "+\t\t\t\t\t\t\tif (this.annotation == null) {", "+\t\t\t\t\t\t\t\tif ((readChar() == 'd')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'p')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'r')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'c')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'a')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 't')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'd')) {", "+\t\t\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "+\t\t\t\t\t\t\t\t\tnextCharacter = readChar();", "+\t\t\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "+\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t\tbreak nextLine; // done", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\t\t} ", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.index[0], lineEnd);", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\tswitch (this.scanner.getNextToken()) {", "+\t\t\t\t\t\t\t\t\tcase  TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseParam();", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_THROWS) || CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseThrows();", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseSee();", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "+\t\t\t\t\t\t\t\t\t\tparseReturn();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t\t} ", "-/*", "- \t\t\t\t\t\t// parse annotation", "-\t\t\t\t\t\tint tagStart = index[0], tagEnd = 0;", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tsaveScannerState();", "-\t\t\t\t\t\t\tthis.scanner.startPosition = index[0];", "-\t\t\t\t\t\t\tthis.scanner.currentPosition = index[0];", "-\t\t\t\t\t\t\tthis.scanner.currentCharacter = -1;", "-\t\t\t\t\t\t\t// read tag", "-\t\t\t\t\t\t\tparseTag();", "-\t\t\t\t\t\t} finally {", "-\t\t\t\t\t\t\tloadScannerState();", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\t\tdo {", "-\t\t\t\t\t\t\tnextCharacter = getNextCharacter(source, index);", "-\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk", "-\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') break; ", "-\t\t\t\t\t\t\tthis.annotationBuffer[bufferLength++] = nextCharacter;", "-\t\t\t\t\t\t\ttagEnd = index[0];", "-\t\t\t\t\t\t} while (index[0] < lineEnd);", "-\t\t\t\t\t\tif (bufferLength == 0) continue nextLine;", "-\t\t\t\t\t\tchar[] tag = null;", "-\t\t\t\t\t\tswitch(this.annotationBuffer[0]) {", "-\t\t\t\t\t\t\tcase 'd' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_DEPRECATED, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_DEPRECATED;", "-\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase 'e' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_EXCEPTION, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_EXCEPTION;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase 't' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_THROWS, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_THROWS;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 's' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_SEE, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_SEE;", "-\t\t\t\t\t\t\t\t} else if (CharOperation.equals(Annotation.TAG_SINCE, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_SINCE;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 'p' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_PARAM, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_PARAM;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 'r' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_RETURN, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_RETURN;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (tag == null) {", "-\t\t\t\t\t\t\ttag = new char[bufferLength];", "-\t\t\t\t\t\t\tSystem.arraycopy(this.annotationBuffer, 0, tag, 0, bufferLength);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// read argument", "-\t\t\t\t\t\tint argumentStart = index[0];", "-\t\t\t\t\t\twhile (argumentStart < lineEnd && Character.isWhitespace(source[argumentStart])) argumentStart++; // trim argument leading spaces", "-\t\t\t\t\t\tint argumentEnd = lineEnd-1;", "-\t\t\t\t\t\twhile (argumentEnd > argumentStart && Character.isWhitespace(source[argumentEnd])) argumentEnd--; // trim argument trailing spaces", "-\t\t\t\t\t\tbufferLength = 0;", "-\t\t\t\t\t\tfor (index[0] = argumentStart; index[0] <= argumentEnd;) {", "-\t\t\t\t\t\t\tthis.annotationBuffer[bufferLength++] = getNextCharacter(source, index);", "-\t\t\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t\t\tchar[] argument = new char[bufferLength];", "-\t\t\t\t\t\tSystem.arraycopy(this.annotationBuffer, 0, argument, 0, bufferLength);", "-\t\t\t\t\t\tannotation.record(tag, argument, tagStart, argumentEnd);", "-*/\t\t\t\t\t\t", "-\t\t\t\t\t\tcontinue nextLine;", "-\t\t\t\t\tcase '*' :", "-\t\t\t\t\t\tif (foundStar) continue nextLine;", "-\t\t\t\t\t\tfoundStar = true;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault :", "-\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) continue nextLine;", "+\t\t\t\t\t\tcase '*' :", "+\t\t\t\t\t\t\tif (foundStar) continue nextLine;", "+\t\t\t\t\t\t\tfoundStar = true;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) continue nextLine;", "+\t\t\t\t\t}", "-\t\t}", "-\t\t", "+\t\t} finally {", "+\t\t\tthis.source = null; // release source as soon as finished", "+\t\t}\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ea0e853f982de8b228fed488fd616909", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "5b534766d4f50c0b706c85a960952c0a8d402690", "commitAfterChange": "9c01a288cfc10861d0cbe8d85e9282d8f2684406", "methodNumberBeforeChange": 75, "methodNumberAfterChange": 75, "signatureBeforeChange": "  \tprivate int printJavadocHtmlTag(FormatJavadocText text, FormatJavadocBlock block, boolean textOnNewLine)", "signatureAfterChange": "  \tprivate int printJavadocHtmlTag(FormatJavadocText text, FormatJavadocBlock block, boolean textOnNewLine)", "diff": ["-\t\t\t\t\t\t// Count the lines until the exact start position of the code", "-\t\t\t\t\t\tthis.scanner.resetTo(end+1, nextStart-1);", "-\t\t\t\t\t\tint newLines = 0;", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tint token = this.scanner.getNextToken();", "-\t\t\t\t\t\t\tloop: while (true) {", "-\t\t\t\t\t\t\t\tswitch (token) {", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\t\t\t\t\tif (CharOperation.indexOf('\\n', this.scanner.source, this.scanner.startPosition, this.scanner.currentPosition) < 0) {", "-\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tnewLines++;", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "-\t\t\t\t\t\t\t\t\t\tnextStart = this.scanner.currentPosition + 1;", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t// See whether there's a space before the code", "+\t\t\t\t\t\tboolean needLeadingSpace = false;", "+\t\t\t\t\t\tif (linesGap > 0) {", "+\t\t\t\t\t\t\tint lineStart = this.scanner.getLineStart(startLine);", "+\t\t\t\t\t\t\tif (nextStart > lineStart) { // if code starts at the line, then no leading space is needed", "+\t\t\t\t\t\t\t\tthis.scanner.resetTo(lineStart, nextStart-1);", "+\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\tint token = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\t\t\t\t\t\t\t\t// skip indentation", "+\t\t\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t\t\t\tneedLeadingSpace = false; // there may be no star after", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tneedLeadingSpace = true;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (token == TerminalTokens.TokenNameMULTIPLY) {", "+\t\t\t\t\t\t\t\t\t\tnextStart = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\t\t\t// skip javadoc comment star", "+\t\t\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t\t\t\tneedLeadingSpace = true;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\t\t\t\t\t\t\t\tneedLeadingSpace = false;", "+\t\t\t\t\t\t\t\t\t\tnextStart++;", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t\tcatch (InvalidInputException iie) {", "+\t\t\t\t\t\t\t\t\t// skip", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tcatch (InvalidInputException iie) {", "-\t\t\t\t\t\t\t// skip", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t// Format gap lines before code", "+\t\t\t\t\t\tint newLines = linesGap;", "-\t\t    \t\t\tprintJavadocGapLines(end+1, nextStart-1, newLines, false/* clear first blank lines inside <pre> tag as done by old formatter */, false, null);", "+\t\t\t\t\t\tprintJavadocGapLines(end+1, nextStart-1, newLines, false/* clear first blank lines inside <pre> tag as done by old formatter */, false, null);", "+\t\t\t\t\t\tif (needLeadingSpace) {", "+\t\t\t\t\t\t\taddInsertEdit(nextStart, \" \"); //$NON-NLS-1$", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// Format the code", "+\t\t\t\t\t\t// Format the gap lines after the code"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3392193c5f49d827dab1924aec47773", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "aabd59e4934a861167bc5ad69597bc9fd97e06dc", "commitAfterChange": "4ed2786f22dd00c9c1f7773433c3548c8c0f6fc3", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "diff": ["-\t\t\tif (this.sourceParser.options.checkAnnotation) {", "+\t\t\t//this.problemReporter = sourceParser.problemReporter();", "+\t\t\tif (this.checkAnnotation) {", "-\t\t\t\tthis.identifierPtr = -1;", "+\t\t\t\tthis.astLengthPtr = -1;", "+\t\t\t\tthis.astPtr = -1;", "+\t\t\t\t//if (this.scanner.source == null) {", "+\t\t\t\t//\tthis.scanner.setSource(this.source);", "+\t\t\t\t//}", "+\t\t\t\t//this.scanner.setSource(CharOperation.subarray(this.source, annotationStart, annotationEnd+1));", "+\t\t\t\t//this.source = this.scanner.source;", "+\t\t\t\tthis.currentTokenType = -1;", "-\t\t\t\tthis.index[0] = lineStart;", "-\t\t\t\tint lineEnd = line == lastLineNumber", "+\t\t\t\t//lineStart -= annotationStart;", "+\t\t\t\tthis.index = lineStart;", "+\t\t\t\tthis.lineEnd = line == lastLineNumber", "-\t\t\t\twhile (this.index[0] < lineEnd) {", "+\t\t\t\t//this.lineEnd -= annotationStart;", "+\t\t\t\twhile (this.index < this.lineEnd) {", "-\t\t\t\t\t\t\tthis.scanner.resetTo(this.index[0], lineEnd);", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.lineEnd);", "+\t\t\t\t\t\t\tthis.currentTokenType = -1; // flush token cache at line begin", "-\t\t\t\t\t\t\t\tswitch (this.scanner.getNextToken()) {", "+\t\t\t\t\t\t\t\tint tk = readConsumeToken();", "+\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\t\tswitch (tk) {", "-\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_THROWS) || CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamethrows :", "+\t\t\t\t\t\t\t\t\t\tparseThrows();", "+\t\t\t\t\t\t\t\t\t\tbreak;", "-\t \t\t\t\t\t\t\t// ignore", "+\t \t\t\t\t\t\t\tconsumeToken();", "+\t\t\tupdateAnnotation();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f77fe9a0478257267708c68f952882a2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "ac2c3539b72e65a4a4e0b168769da151e63c5ff1", "commitAfterChange": "014710437062a15282800b8efb747a8973068ba8", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int javadocStart, int javadocEnd)", "signatureAfterChange": " \tprotected boolean parseComment(int javadocStart, int javadocEnd)", "diff": ["-\tpublic boolean checkDeprecation(int javadocStart, int javadocEnd) {", "+\tprotected boolean parseComment(int javadocStart, int javadocEnd) {", "-\t\t\tchar nextCharacter= 0, previousChar;", "-\t\t\tint charPosition = -1, inlineStartPosition = 0;", "-\t\t\tinitLineEnd();", "+\t\t\tthis.linePtr = getLineNumber(javadocStart);", "+\t\t\tthis.lastLinePtr = getLineNumber(javadocEnd);", "+\t\t\tthis.lineEnd = (this.linePtr == this.lastLinePtr) ? this.endComment : javadocStart + 3;", "+\t\t\tthis.textStart = -1;", "+\t\t\tchar nextCharacter= 0, previousChar;", "+\t\t\tint charPosition = -1, inlineStartPosition = 0;", "-\t\t\t\tif (this.index > this.lineEnd) {", "+\t\t\t\tif (this.index > (this.lineEnd+1)) {", "+\t\t\t\t\tpreviousPosition = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\t\t\tpushText(this.textStart, charPosition);", "-\t\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\t\t\tthis.tagSourceStart = this.kind == COMPIL_PARSER ? this.scanner.getCurrentTokenStartPosition() : previousPosition;", "-\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseThrows();", "+\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseThrows(false);", "-\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.equals(tag, TAG_LINK) ||", "-\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.equals(tag, TAG_LINKPLAIN)) {", "-\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseSee();", "+\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.equals(tag, TAG_LINK)) {", "+\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseSee(false);", "+\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_LINKPLAIN)) {", "+\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseSee(true);", "-\t\t\t\t\t\t\t\t\t\t\tvalid = parseThrows();", "+\t\t\t\t\t\t\t\t\t\t\tvalid = parseThrows(true);", "+\t\t\t\t\t\t\t\t\tthis.textStart = this.index;", "+\t\t\t\t\t\tif (this.lineStarted && this.textStart <= charPosition) {", "+\t\t\t\t\t\t\tpushText(this.textStart, charPosition);", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.inlineTagStarted) this.inlineTagStarted = false;", "-\t\t\t\t\t\tthis.lineStarted = true;", "-\t\t\t\t\t\tcharPosition = previousPosition;", "+\t\t\t\t\t\tif (this.inlineTagStarted) {", "+\t\t\t\t\t\t\tif (this.lineStarted && this.textStart <= charPosition) {", "+\t\t\t\t\t\t\t\tpushText(this.textStart, charPosition);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.textStart = this.index;", "+\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.index < this.lineEnd) {", "+\t\t\t\t\t\t\tthis.lineStarted = true;", "+\t\t\t\t\t\t\tcharPosition = previousPosition;", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (!this.lineStarted && !CharOperation.isWhitespace(nextCharacter)) {", "+\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) {", "+\t\t\t\t\t\t\tif (!this.lineStarted) {", "+\t\t\t\t\t\t\t\tthis.textStart = previousPosition;", "+\t\t\t\t\t\t\t}", "-\t\t} finally {", "-\t\t\tupdateJavadoc();", "+\t\t\tif (this.lineStarted && this.textStart <= this.endComment) {", "+\t\t\t\tpushText(this.textStart, this.endComment);", "+\t\t\t}", "+\t\t\tupdateDocComment();", "+\t\t} catch (Exception ex) {", "+\t\t\tvalidComment = false;"]}], "num": 45821}