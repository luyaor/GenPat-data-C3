{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6067777efd27ae664a5f5d962f476cfd", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "251302e48274e041689dc3e244aa96a6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " public FieldBinding[] fields()", "signatureAfterChange": " public FieldBinding[] fields()", "diff": ["-\tif ((tagBits & TagBits.AreFieldsComplete) != 0)", "-\t\treturn fields;\t", "+\tif ((this.tagBits & TagBits.AreFieldsComplete) != 0)", "+\t\treturn this.fields;\t", "-\t\tfor (int i = 0, length = fields.length; i < length; i++) {", "-\t\t\tif (resolveTypeFor(fields[i]) == null) {", "-\t\t\t\tfields[i] = null;", "+\t\t// lazily sort fields", "+\t\tif ((this.tagBits & TagBits.AreFieldsSorted) == 0) {", "+\t\t\tint length = this.fields.length;", "+\t\t\tif (length > 1) \tReferenceBinding.sortFields(this.fields, 0, length - 1);", "+\t\t\tthis.tagBits |= TagBits.AreFieldsSorted;", "+\t\t}\t\t\t", "+\t\tfor (int i = 0, length = this.fields.length; i < length; i++) {", "+\t\t\tif (resolveTypeFor(this.fields[i]) == null) {", "+\t\t\t\tthis.fields[i] = null;", "-\t\t\tint newSize = fields.length - failed;", "+\t\t\tint newSize = this.fields.length - failed;", "-\t\t\t\treturn fields = Binding.NO_FIELDS;", "+\t\t\t\treturn this.fields = Binding.NO_FIELDS;", "-\t\t\tfor (int i = 0, j = 0, length = fields.length; i < length; i++)", "-\t\t\t\tif (fields[i] != null)", "-\t\t\t\t\tnewFields[j++] = fields[i];", "-\t\t\tfields = newFields;", "+\t\t\tfor (int i = 0, j = 0, length = this.fields.length; i < length; i++) {", "+\t\t\t\tif (this.fields[i] != null) {", "+\t\t\t\t\tnewFields[j++] = this.fields[i];", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tthis.fields = newFields;", "-\ttagBits |= TagBits.AreFieldsComplete;", "-\treturn fields;", "+\tthis.tagBits |= TagBits.AreFieldsComplete;", "+\treturn this.fields;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5d304ed4de0325584e60621db13099e2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java", "commitBeforeChange": "ee73272992444a9c8e6586ce5a37f5dc6d6e8bd9", "commitAfterChange": "f598d68e65d421b1e902e4d71831d57a9b4e73ab", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public char[] getCurrentIdentifierSource()", "signatureAfterChange": " public char[] getCurrentIdentifierSource()", "diff": ["-\tif (completionIdentifier == null){", "-\t\tif (cursorLocation < startPosition && currentPosition == startPosition){ // fake empty identifier got issued", "+\tif (this.completionIdentifier == null){", "+\t\tif (this.cursorLocation < this.startPosition && this.currentPosition == this.startPosition){ // fake empty identifier got issued", "-\t\t\tcompletedIdentifierStart = startPosition;", "-\t\t\tcompletedIdentifierEnd = completedIdentifierStart - 1;\t\t\t", "-\t\t\treturn completionIdentifier = EmptyCompletionIdentifier;\t\t\t\t\t", "+\t\t\tthis.completedIdentifierStart = this.startPosition;", "+\t\t\tthis.completedIdentifierEnd = this.completedIdentifierStart - 1;\t\t\t", "+\t\t\treturn this.completionIdentifier = EmptyCompletionIdentifier;\t\t\t\t\t", "-\t\tif (cursorLocation+1 >= startPosition && cursorLocation < currentPosition){", "+\t\tif (this.cursorLocation+1 >= this.startPosition && this.cursorLocation < this.currentPosition){", "-\t\t\tcompletedIdentifierStart = startPosition;", "-\t\t\tcompletedIdentifierEnd = currentPosition - 1;", "-\t\t\tif (withoutUnicodePtr != 0){\t\t\t// check unicode scenario", "-\t\t\t\tSystem.arraycopy(withoutUnicodeBuffer, 1, completionIdentifier = new char[withoutUnicodePtr], 0, withoutUnicodePtr);", "+\t\t\tthis.completedIdentifierStart = this.startPosition;", "+\t\t\tthis.completedIdentifierEnd = this.currentPosition - 1;", "+\t\t\tif (this.withoutUnicodePtr != 0){\t\t\t// check unicode scenario", "+\t\t\t\tSystem.arraycopy(this.withoutUnicodeBuffer, 1, this.completionIdentifier = new char[this.withoutUnicodePtr], 0, this.withoutUnicodePtr);", "-\t\t\t\tint length = cursorLocation + 1 - startPosition;", "+\t\t\t\tint length = this.cursorLocation + 1 - this.startPosition;", "-\t\t\t\tSystem.arraycopy(source, startPosition, (completionIdentifier = new char[length]), 0, length);", "+\t\t\t\tSystem.arraycopy(this.source, this.startPosition, (this.completionIdentifier = new char[length]), 0, length);", "-\t\t\treturn completionIdentifier;", "+\t\t\treturn this.completionIdentifier;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6ec057077864e0736d5e03b1f9a2d971", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "9f63437bec67bc6f1450b706ffa6a59a67485b74", "commitAfterChange": "2b5868a69a1295fe1d99f9e80995ceed273132ed", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 24, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["+", "+public TypeBinding resolveType(BlockScope scope) {", "+\t// compute a new constant if the cast is effective", "+", "+\t// due to the fact an expression may start with ( and that a cast can also start with (", "+\t// the field is an expression....it can be a TypeReference OR a NameReference Or", "+\t// any kind of Expression <-- this last one is invalid.......", "+", "+\tthis.constant = Constant.NotAConstant;", "+\tthis.implicitConversion = TypeIds.T_undefined;", "+", "+\tif ((this.type instanceof TypeReference) || (this.type instanceof NameReference)", "+\t\t\t&& ((this.type.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) == 0) { // no extra parenthesis around type: ((A))exp", "+", "+\t\tboolean exprContainCast = false;", "+\t\t", "+\t\tTypeBinding castType = this.resolvedType = this.type.resolveType(scope);", "+\t\t//expression.setExpectedType(this.resolvedType); // needed in case of generic method invocation\t\t\t", "+\t\tif (this.expression instanceof CastExpression) {", "+\t\t\tthis.expression.bits |= ASTNode.DisableUnnecessaryCastCheck;", "+\t\t\texprContainCast = true;", "-", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-\t\t// compute a new constant if the cast is effective", "-", "-\t\t// due to the fact an expression may start with ( and that a cast can also start with (", "-\t\t// the field is an expression....it can be a TypeReference OR a NameReference Or", "-\t\t// any kind of Expression <-- this last one is invalid.......", "-", "-\t\tconstant = Constant.NotAConstant;", "-\t\timplicitConversion = T_undefined;", "-", "-\t\tif ((type instanceof TypeReference) || (type instanceof NameReference)", "-\t\t\t\t&& ((type.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) == 0) { // no extra parenthesis around type: ((A))exp", "-", "-\t\t\tTypeBinding castType = this.resolvedType = type.resolveType(scope);", "-\t\t\t//expression.setExpectedType(this.resolvedType); // needed in case of generic method invocation\t\t\t", "-\t\t\tTypeBinding expressionType = expression.resolveType(scope);", "-\t\t\tif (castType != null) {", "-\t\t\t\tif (expressionType != null) {", "-\t\t\t\t\tboolean isLegal = checkCastTypesCompatibility(scope, castType, expressionType, this.expression);", "-\t\t\t\t\tif (isLegal) {", "-\t\t\t\t\t\tthis.expression.computeConversion(scope, castType, expressionType);", "-\t\t\t\t\t\tif ((this.bits & UnsafeCast) != 0) { // unsafe cast", "-\t\t\t\t\t\t\tscope.problemReporter().unsafeCast(this, scope);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (castType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){", "-\t\t\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.type, castType);\t\t\t", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif ((this.bits & (UnnecessaryCast|DisableUnnecessaryCastCheck)) == UnnecessaryCast) { // unnecessary cast ", "-\t\t\t\t\t\t\t\tif (!isIndirectlyUsed()) // used for generic type inference or boxing ?", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().unnecessaryCast(this);", "-\t\t\t\t\t\t\t}", "+\t\tTypeBinding expressionType = this.expression.resolveType(scope);", "+\t\tif (castType != null) {", "+\t\t\tif (expressionType != null) {", "+\t\t\t\tboolean isLegal = checkCastTypesCompatibility(scope, castType, expressionType, this.expression);", "+\t\t\t\tif (isLegal) {", "+\t\t\t\t\tthis.expression.computeConversion(scope, castType, expressionType);", "+\t\t\t\t\tif ((this.bits & ASTNode.UnsafeCast) != 0) { // unsafe cast", "+\t\t\t\t\t\tscope.problemReporter().unsafeCast(this, scope);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (castType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){", "+\t\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.type, castType);\t\t\t", "-\t\t\t\t\t} else { // illegal cast", "-\t\t\t\t\t\tif ((castType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error", "-\t\t\t\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "+\t\t\t\t\t\tif ((this.bits & (ASTNode.UnnecessaryCast|ASTNode.DisableUnnecessaryCastCheck)) == ASTNode.UnnecessaryCast) { // unnecessary cast ", "+\t\t\t\t\t\t\tif (!isIndirectlyUsed()) // used for generic type inference or boxing ?", "+\t\t\t\t\t\t\t\tscope.problemReporter().unnecessaryCast(this);", "-\t\t\t\t\t\tthis.bits |= DisableUnnecessaryCastCheck; // disable further secondary diagnosis", "+\t\t\t\t} else { // illegal cast", "+\t\t\t\t\tif ((castType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error", "+\t\t\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.bits |= ASTNode.DisableUnnecessaryCastCheck; // disable further secondary diagnosis", "-\t\t\t\tthis.resolvedType = castType.capture(scope, this.sourceEnd);", "-\t\t\treturn this.resolvedType;", "-\t\t} else { // expression as a cast", "-\t\t\tTypeBinding expressionType = expression.resolveType(scope);", "-\t\t\tif (expressionType == null) return null;", "-\t\t\tscope.problemReporter().invalidTypeReference(type);", "-\t\t\treturn null;", "-\t\t}", "-\t}", "+\t\t\tthis.resolvedType = castType.capture(scope, this.sourceEnd);", "+\t\t\tif (exprContainCast) {", "+\t\t\t\tcheckNeedForCastCast(scope, this);", "+\t\treturn this.resolvedType;", "+\t} else { // expression as a cast", "+\t\tTypeBinding expressionType = this.expression.resolveType(scope);", "+\t\tif (expressionType == null) return null;", "+\t\tscope.problemReporter().invalidTypeReference(this.type);", "+\t\treturn null;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f3aa5b874754e2471a3b95e87451749", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 98, "methodNumberAfterChange": 98, "signatureBeforeChange": " protected void consumeFieldDeclaration()", "signatureAfterChange": " protected void consumeFieldDeclaration()", "diff": ["-\tint variableDeclaratorsCounter = astLengthStack[astLengthPtr];", "+\tint variableDeclaratorsCounter = this.astLengthStack[this.astLengthPtr];", "-\t\tFieldDeclaration fieldDeclaration = (FieldDeclaration) astStack[astPtr - i];", "-\t\tfieldDeclaration.declarationSourceEnd = endStatementPosition; ", "-\t\tfieldDeclaration.declarationEnd = endStatementPosition;\t// semi-colon included", "+\t\tFieldDeclaration fieldDeclaration = (FieldDeclaration) this.astStack[this.astPtr - i];", "+\t\tfieldDeclaration.declarationSourceEnd = this.endStatementPosition; ", "+\t\tfieldDeclaration.declarationEnd = this.endStatementPosition;\t// semi-colon included", "-\tint endPos = flushCommentsDefinedPriorTo(endStatementPosition);", "-\tif (endPos != endStatementPosition) {", "+\tint endPos = flushCommentsDefinedPriorTo(this.endStatementPosition);", "+\tif (endPos != this.endStatementPosition) {", "-\t\t\tFieldDeclaration fieldDeclaration = (FieldDeclaration) astStack[astPtr - i];", "+\t\t\tFieldDeclaration fieldDeclaration = (FieldDeclaration) this.astStack[this.astPtr - i];", "-\tint startIndex = astPtr - variablesCounter[nestedType] + 1;", "+\tint startIndex = this.astPtr - this.variablesCounter[this.nestedType] + 1;", "-\t\tastStack, ", "+\t\tthis.astStack, ", "-\t\tastStack, ", "+\t\tthis.astStack, ", "-\tastPtr--; // remove the type reference", "-\tastLengthStack[--astLengthPtr] = variableDeclaratorsCounter;", "+\tthis.astPtr--; // remove the type reference", "+\tthis.astLengthStack[--this.astLengthPtr] = variableDeclaratorsCounter;", "-\tif (currentElement != null) {", "-\t\tlastCheckPoint = endPos + 1;", "-\t\tif (currentElement.parent != null && currentElement instanceof RecoveredField){", "-\t\t\tif (!(currentElement instanceof RecoveredInitializer)) {", "-\t\t\t\tcurrentElement = currentElement.parent;", "+\tif (this.currentElement != null) {", "+\t\tthis.lastCheckPoint = endPos + 1;", "+\t\tif (this.currentElement.parent != null && this.currentElement instanceof RecoveredField){", "+\t\t\tif (!(this.currentElement instanceof RecoveredInitializer)) {", "+\t\t\t\tthis.currentElement = this.currentElement.parent;", "-\t\trestartRecovery = true;", "+\t\tthis.restartRecovery = true;", "-\tvariablesCounter[nestedType] = 0;", "+\tthis.variablesCounter[this.nestedType] = 0;"]}], "num": 367}