{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d480f1a8c63be53386877130f0bcd304", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2520ae119ac1df47f43b2ea23e0de9ed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "ab74babcdf0f89ee66e36b91189c0d301a4da95d", "commitAfterChange": "66a4221dd418603b7f2bc6722d99e4e300585ef1", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": " \t \tprivate void resolveReference(Expression reference, Scope scope)", "signatureAfterChange": " \t \tprivate void resolveReference(Expression reference, Scope scope)", "diff": ["-\t\tboolean verifyValues = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\tboolean source15 = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\tint scopeModifiers = -1;", "-\t\t\tint modifiers = fieldRef.binding==null ? -1 : fieldRef.binding.modifiers;", "-\t\t\t\t\tscope.problemReporter().javadocInvalidValueReference(fieldRef.sourceStart, fieldRef.sourceEnd, modifiers);", "+\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\tscope.problemReporter().javadocInvalidValueReference(fieldRef.sourceStart, fieldRef.sourceEnd, scopeModifiers);", "-\t\t\telse if (verifyValues && fieldRef.binding != null && fieldRef.binding.isValidBinding()) {", "+\t\t\telse if (source15 && fieldRef.binding != null && fieldRef.binding.isValidBinding()) {", "-\t\t\t\t\tscope.problemReporter().javadocInvalidValueReference(fieldRef.sourceStart, fieldRef.sourceEnd, modifiers);", "+\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\tscope.problemReporter().javadocInvalidValueReference(fieldRef.sourceStart, fieldRef.sourceEnd, scopeModifiers);", "-\t\t\t", "+", "-\t\t// If not 1.5 level, verification is finished", "-\t\tif (!verifyValues)  return;", "+\t\t// Verify type references", "+\t\tif ((reference instanceof JavadocSingleTypeReference || reference instanceof JavadocQualifiedTypeReference) && reference.resolvedType instanceof ReferenceBinding) {", "+\t\t\tReferenceBinding resolvedType = (ReferenceBinding) reference.resolvedType;", "+\t\t\tif (reference.resolvedType.isValidBinding()) {", "-\t\t// Verify that message reference are not used for @value tags", "-\t\telse if (reference instanceof JavadocMessageSend) {", "-\t\t\tJavadocMessageSend msgSend = (JavadocMessageSend) reference;", "-\t\t\tint modifiers = msgSend.binding==null ? -1 : msgSend.binding.modifiers;", "-\t\t\tif (msgSend.tagValue == JavadocTagConstants.TAG_VALUE_VALUE) { // cannot refer to method for @value tag", "-\t\t\t\tscope.problemReporter().javadocInvalidValueReference(msgSend.sourceStart, msgSend.sourceEnd, modifiers);", "+\t\t\t\t// member types", "+\t\t\t\tif (resolvedType.isMemberType()) {", "+\t\t\t\t\tReferenceBinding topLevelType = resolvedType;", "+\t\t\t\t\tint depth = 0;", "+\t\t\t\t\twhile (topLevelType.enclosingType() != null) {", "+\t\t\t\t\t\ttopLevelType = topLevelType.enclosingType();", "+\t\t\t\t\t\tdepth++;", "+\t\t\t\t\t}", "+\t\t\t\t\tClassScope topLevelScope = scope.classScope();", "+\t\t\t\t\t// when scope is not on compilation unit type, then inner class may not be visible...", "+\t\t\t\t\tif (topLevelScope.parent.kind != Scope.COMPILATION_UNIT_SCOPE ||", "+\t\t\t\t\t\t!CharOperation.equals(topLevelType.sourceName, topLevelScope.referenceContext.name)) {", "+\t\t\t\t\t\ttopLevelScope = topLevelScope.outerMostClassScope();", "+\t\t\t\t\t\tif (reference instanceof JavadocSingleTypeReference) {", "+\t\t\t\t\t\t\t// inner class single reference can only be done in same unit", "+\t\t\t\t\t\t\tif ((!source15 && depth == 1) || topLevelType != topLevelScope.referenceContext.binding) {", "+\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// inner class qualified reference can only be done in same package", "+\t\t\t\t\t\t\tif (topLevelType.getPackage() != topLevelScope.referenceContext.binding.getPackage()) {", "+\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+", "+\t\t\t\t// reference must have enough visibility to be used", "+\t\t\t\tif (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, resolvedType)) {", "+\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "+\t\t\t\t}", "-\t\t// Verify that constructorreference are not used for @value tags", "+\t\t// Verify that message reference are not used for @value tags", "+\t\tif (reference instanceof JavadocMessageSend) {", "+\t\t\tJavadocMessageSend msgSend = (JavadocMessageSend) reference;", "+", "+\t\t\t// tag value", "+\t\t\tif (source15 && msgSend.tagValue == JavadocTagConstants.TAG_VALUE_VALUE) { // cannot refer to method for @value tag", "+\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\tscope.problemReporter().javadocInvalidValueReference(msgSend.sourceStart, msgSend.sourceEnd, scopeModifiers);", "+\t\t\t}", "+", "+\t\t}", "+", "+\t\t// Verify that constructor reference are not used for @value tags", "-\t\t\tint modifiers = alloc.binding==null ? -1 : alloc.binding.modifiers;", "-\t\t\tif (alloc.tagValue == JavadocTagConstants.TAG_VALUE_VALUE) { // cannot refer to method for @value tag", "-\t\t\t\tscope.problemReporter().javadocInvalidValueReference(alloc.sourceStart, alloc.sourceEnd, modifiers);", "+", "+\t\t\t// tag value", "+\t\t\tif (source15 && alloc.tagValue == JavadocTagConstants.TAG_VALUE_VALUE) { // cannot refer to method for @value tag", "+\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\tscope.problemReporter().javadocInvalidValueReference(alloc.sourceStart, alloc.sourceEnd, scopeModifiers);", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "539066f99d522cf257220eb3628a8106", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "3de46f74e60c4a3809d64f36594b156b755e8151", "commitAfterChange": "a278a6d0aa65f732809dc346bd96a708d28563bd", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": " \t \tprivate void resolveReference(Expression reference, Scope scope)", "signatureAfterChange": " \t \tprivate void resolveReference(Expression reference, Scope scope)", "diff": ["+\t\t\t// Verify type references", "+\t\t\t// TODO (frederic) fix for bug 119857", "+\t\t\t/*", "+\t\t\tif (fieldRef.binding != null && fieldRef.binding.isValidBinding() && fieldRef.receiverType instanceof ReferenceBinding) {", "+\t\t\t\tReferenceBinding resolvedType = (ReferenceBinding) fieldRef.receiverType;", "+\t\t\t\tverifyTypeReference(fieldRef.receiver, scope, source15, resolvedType);", "+\t\t\t}", "+\t\t\t*/", "+", "-\t\t\tif (reference.resolvedType.isValidBinding()) {", "-", "-\t\t\t\t// member types", "-\t\t\t\tif (resolvedType.isMemberType()) {", "-\t\t\t\t\tReferenceBinding topLevelType = resolvedType;", "-\t\t\t\t\tint depth = 0;", "-\t\t\t\t\twhile (topLevelType.enclosingType() != null) {", "-\t\t\t\t\t\ttopLevelType = topLevelType.enclosingType();", "-\t\t\t\t\t\tdepth++;", "-\t\t\t\t\t}", "-\t\t\t\t\tClassScope topLevelScope = scope.classScope();", "-\t\t\t\t\t// when scope is not on compilation unit type, then inner class may not be visible...", "-\t\t\t\t\tif (topLevelScope.parent.kind != Scope.COMPILATION_UNIT_SCOPE ||", "-\t\t\t\t\t\t!CharOperation.equals(topLevelType.sourceName, topLevelScope.referenceContext.name)) {", "-\t\t\t\t\t\ttopLevelScope = topLevelScope.outerMostClassScope();", "-\t\t\t\t\t\tif (reference instanceof JavadocSingleTypeReference) {", "-\t\t\t\t\t\t\t// inner class single reference can only be done in same unit", "-\t\t\t\t\t\t\tif ((!source15 && depth == 1) || topLevelType != topLevelScope.referenceContext.binding) {", "-\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "-\t\t\t\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t// inner class qualified reference can only be done in same package", "-\t\t\t\t\t\t\tif (topLevelType.getPackage() != topLevelScope.referenceContext.binding.getPackage()) {", "-\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "-\t\t\t\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\t// reference must have enough visibility to be used", "-\t\t\t\tif (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, resolvedType)) {", "-\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "-\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tverifyTypeReference(reference, scope, source15, resolvedType);", "+\t\t\t// Verify type references", "+\t\t\t// TODO (frederic) fix for bug 119857", "+\t\t\t/*", "+\t\t\tif (msgSend.binding != null && msgSend.binding.isValidBinding() && msgSend.actualReceiverType instanceof ReferenceBinding) {", "+\t\t\t\tReferenceBinding resolvedType = (ReferenceBinding) msgSend.actualReceiverType;", "+\t\t\t\tverifyTypeReference(msgSend.receiver, scope, source15, resolvedType);", "+\t\t\t}", "+\t\t\t*/", "+\t\t\t// Verify type references", "+\t\t\t// TODO (frederic) fix for bug 119857", "+\t\t\t/*", "+\t\t\tif (alloc.binding != null && alloc.binding.isValidBinding() && alloc.resolvedType instanceof ReferenceBinding) {", "+\t\t\t\tReferenceBinding resolvedType = (ReferenceBinding) alloc.resolvedType;", "+\t\t\t\tverifyTypeReference(alloc.type, scope, source15, resolvedType);", "+\t\t\t}", "+\t\t\t*/"]}], "num": 9298}