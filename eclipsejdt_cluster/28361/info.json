{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d3488e125a4b33a5760cafd9a211c304", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "55b96af22a8d5b771f235b7aaa7a4e19", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "457fc77ec96140a15fc3e1c18bbf7bf53c7ea1c9", "commitAfterChange": "44074e366655e2cf89768617c1e64463f5949123", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tprivate static SearchPattern createMethodPattern(String patternString, int limitTo, int matchRule)", "signatureAfterChange": " \tprivate static SearchPattern createMethodOrConstructorPattern(String patternString, int limitTo, int matchRule, boolean isConstructor)", "diff": ["-\tprivate static SearchPattern createMethodPattern(String patternString, int limitTo, int matchRule) {", "+\tprivate static SearchPattern createMethodOrConstructorPattern(String patternString, int limitTo, int matchRule, boolean isConstructor) {", "+\t\tfinal int InsideTypeArguments = 4;", "+\t\tchar[][] typeArguments = null;", "-\t\tint token;", "+\t\tint token, argCount = 0;", "-\t\t\t\t\tswitch (token) {", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameDOT:", "-\t\t\t\t\t\t\tif (declaringType == null) {", "-\t\t\t\t\t\t\t\tif (selector == null) return null;", "-\t\t\t\t\t\t\t\tdeclaringType = selector;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tString tokenSource = new String(scanner.getCurrentTokenSource());", "-\t\t\t\t\t\t\t\tdeclaringType += tokenSource + selector;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tselector = null;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameLPAREN:", "-\t\t\t\t\t\t\tparameterTypes = new String[5];", "-\t\t\t\t\t\t\tparameterCount = 0;", "-\t\t\t\t\t\t\tmode = InsideParameter;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\t\tif (!(TerminalTokens.TokenNameWHITESPACE == lastToken || TerminalTokens.TokenNameDOT == lastToken))", "-\t\t\t\t\t\t\t\tmode = InsideReturnType;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tdefault: // all other tokens are considered identifiers (see bug 21763 Problem in Java search [search])", "-\t\t\t\t\t\t\tif (selector == null)", "-\t\t\t\t\t\t\t\tselector = new String(scanner.getCurrentTokenSource());", "-\t\t\t\t\t\t\telse", "-\t\t\t\t\t\t\t\tselector += new String(scanner.getCurrentTokenSource());", "-\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\tif (argCount == 0) {", "+\t\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\t\t\t\targCount++;", "+\t\t\t\t\t\t\t\tif (selector == null) return null; // invalid syntax", "+\t\t\t\t\t\t\t\tif (declaringType == null) {", "+\t\t\t\t\t\t\t\t\tdeclaringType = selector;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tdeclaringType += '.' + selector;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tdeclaringType += scanner.getCurrentTokenString();", "+\t\t\t\t\t\t\t\tselector = null;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameDOT:", "+\t\t\t\t\t\t\t\tif (declaringType == null) {", "+\t\t\t\t\t\t\t\t\tif (selector == null) return null;", "+\t\t\t\t\t\t\t\t\tdeclaringType = selector;", "+\t\t\t\t\t\t\t\t} else if (selector != null) {", "+\t\t\t\t\t\t\t\t\tString tokenSource = scanner.getCurrentTokenString();", "+\t\t\t\t\t\t\t\t\tdeclaringType += tokenSource + selector;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tselector = null;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameLPAREN:", "+\t\t\t\t\t\t\t\tparameterTypes = new String[5];", "+\t\t\t\t\t\t\t\tparameterCount = 0;", "+\t\t\t\t\t\t\t\tmode = InsideParameter;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\t\tif (!(TerminalTokens.TokenNameWHITESPACE == lastToken || TerminalTokens.TokenNameDOT == lastToken))", "+\t\t\t\t\t\t\t\t\tmode = isConstructor ? InsideTypeArguments : InsideReturnType;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameREMAINDER:", "+\t\t\t\t\t\t\t\tif (selector == null) return null;// invalid syntax", "+\t\t\t\t\t\t\t\tmode = InsideTypeArguments;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault: // all other tokens are considered identifiers (see bug 21763 Problem in Java search [search])", "+\t\t\t\t\t\t\t\tif (selector == null)", "+\t\t\t\t\t\t\t\t\tselector = scanner.getCurrentTokenString();", "+\t\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\t\tselector += scanner.getCurrentTokenString();", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameGREATER:", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameRIGHT_SHIFT:", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameUNSIGNED_RIGHT_SHIFT:", "+\t\t\t\t\t\t\t\targCount--;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\t\t\t\targCount++;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (declaringType == null) return null; // invalid syntax", "+\t\t\t\t\t\tdeclaringType += scanner.getCurrentTokenString();", "-\t\t\t\t\tswitch (token) {", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameCOMMA:", "-\t\t\t\t\t\t\tif (parameterType == null) return null;", "-\t\t\t\t\t\t\tif (parameterTypes.length == parameterCount)", "-\t\t\t\t\t\t\t\tSystem.arraycopy(parameterTypes, 0, parameterTypes = new String[parameterCount*2], 0, parameterCount);", "-\t\t\t\t\t\t\tparameterTypes[parameterCount++] = parameterType;", "-\t\t\t\t\t\t\tparameterType = null;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameRPAREN:", "-\t\t\t\t\t\t\tfoundClosingParenthesis = true;", "-\t\t\t\t\t\t\tif (parameterType != null){", "+\t\t\t\t\tif (argCount == 0) {", "+\t\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameCOMMA:", "+\t\t\t\t\t\t\t\tif (parameterType == null) return null;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tmode = InsideReturnType;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tdefault: // all other tokens are considered identifiers (see bug 21763 Problem in Java search [search])", "-\t\t\t\t\t\t\tif (parameterType == null)", "-\t\t\t\t\t\t\t\tparameterType = new String(scanner.getCurrentTokenSource());", "-\t\t\t\t\t\t\telse", "-\t\t\t\t\t\t\t\tparameterType += new String(scanner.getCurrentTokenSource());", "+\t\t\t\t\t\t\t\tparameterType = null;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameRPAREN:", "+\t\t\t\t\t\t\t\tfoundClosingParenthesis = true;", "+\t\t\t\t\t\t\t\tif (parameterType != null){", "+\t\t\t\t\t\t\t\t\tif (parameterTypes.length == parameterCount)", "+\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(parameterTypes, 0, parameterTypes = new String[parameterCount*2], 0, parameterCount);", "+\t\t\t\t\t\t\t\t\tparameterTypes[parameterCount++] = parameterType;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tmode = isConstructor ? InsideTypeArguments : InsideReturnType;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameREMAINDER:", "+\t\t\t\t\t\t\t\t// invalid syntax", "+\t\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\t\t\t\targCount++;", "+\t\t\t\t\t\t\t\tif (parameterType == null) return null; // invalid syntax", "+\t\t\t\t\t\t\t\t// fall through next case to add token", "+\t\t\t\t\t\t\tdefault: // all other tokens are considered identifiers (see bug 21763 Problem in Java search [search])", "+\t\t\t\t\t\t\t\tif (parameterType == null)", "+\t\t\t\t\t\t\t\t\tparameterType = scanner.getCurrentTokenString();", "+\t\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\t\tparameterType += scanner.getCurrentTokenString();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameGREATER:", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameRIGHT_SHIFT:", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameUNSIGNED_RIGHT_SHIFT:", "+\t\t\t\t\t\t\t\targCount--;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\t\t\t\targCount++;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (parameterType == null) return null; // invalid syntax", "+\t\t\t\t\t\tparameterType += scanner.getCurrentTokenString();", "+\t\t\t\t\tif (argCount == 0) {", "+\t\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameREMAINDER:", "+\t\t\t\t\t\t\t\tmode = InsideTypeArguments;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\t\t\t\targCount++;", "+\t\t\t\t\t\t\t\tif (returnType == null) return null; // invalid syntax", "+\t\t\t\t\t\t\t\t// fall through next case to add token", "+\t\t\t\t\t\t\tdefault: // all other tokens are considered identifiers (see bug 21763 Problem in Java search [search])", "+\t\t\t\t\t\t\t\tif (returnType == null)", "+\t\t\t\t\t\t\t\t\treturnType = scanner.getCurrentTokenString();", "+\t\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\t\treturnType += scanner.getCurrentTokenString();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameGREATER:", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameRIGHT_SHIFT:", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameUNSIGNED_RIGHT_SHIFT:", "+\t\t\t\t\t\t\t\targCount--;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\t\t\t\targCount++;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (returnType == null) return null; // invalid syntax", "+\t\t\t\t\t\treturnType += scanner.getCurrentTokenString();", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase InsideTypeArguments:", "-\t\t\t\t\t\tdefault: // all other tokens are considered identifiers (see bug 21763 Problem in Java search [search])", "-\t\t\t\t\t\t\tif (returnType == null)", "-\t\t\t\t\t\t\t\treturnType = new String(scanner.getCurrentTokenSource());", "-\t\t\t\t\t\t\telse", "-\t\t\t\t\t\t\t\treturnType += new String(scanner.getCurrentTokenSource());", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameREMAINDER:", "+\t\t\t\t\t\t\tString pseudoType = selector+patternString.substring(scanner.getCurrentTokenStartPosition()); // '%' is a valid character for type", "+\t\t\t\t\t\t\ttypeArguments = Util.extractMethodArguments(Signature.createTypeSignature(pseudoType, false));", "+\t\t\t\t\t\t\tscanner.currentPosition = scanner.eofPosition; // end scan", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\t\t\tif (lastToken == TerminalTokens.TokenNameREMAINDER || lastToken == TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\t\t\t\t\t\tpseudoType = selector+'%'+patternString.substring(scanner.getCurrentTokenStartPosition()); // '%' is a valid character for type", "+\t\t\t\t\t\t\t\ttypeArguments = Util.extractMethodArguments(Signature.createTypeSignature(pseudoType, false));", "+\t\t\t\t\t\t\t\tscanner.currentPosition = scanner.eofPosition; // end scan", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\treturn null; // invalid syntax", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\treturn null; // invalid syntax", "-\t\tif (selector == null) return null;", "-\t", "-\t\tchar[] selectorChars = selector.toCharArray();", "-\t\tif (selectorChars.length == 1 && selectorChars[0] == '*')", "-\t\t\tselectorChars = null;", "+\t\t// type arguments mismatch", "+\t\tif (argCount > 0) return null;", "+", "+\t\tchar[] selectorChars = null;", "+\t\tif (isConstructor) {", "+\t\t\t// retrieve type for constructor patterns", "+\t\t\tif (declaringType == null)", "+\t\t\t\tdeclaringType = selector;", "+\t\t\telse if (selector != null)", "+\t\t\t\tdeclaringType += '.' + selector;", "+\t\t} else {", "+\t\t\t// get selector chars", "+\t\t\tif (selector == null) return null;", "+\t\t\tselectorChars = selector.toCharArray();", "+\t\t\tif (selectorChars.length == 1 && selectorChars[0] == '*')", "+\t\t\t\tselectorChars = null;", "+\t\t}", "+\t\t// Signatures", "+\t\tString declaringTypeSignature = null;", "+\t\tString returnTypeSignature = null;", "+\t\tString[] parameterTypeSignatures = null;", "-\t\t\tchar[] declaringTypePart = declaringType.toCharArray();", "+\t\t\t// get declaring type part and signature", "+\t\t\tchar[] declaringTypePart = null;", "+\t\t\ttry {", "+\t\t\t\tdeclaringTypeSignature = Signature.createTypeSignature(declaringType, false);", "+\t\t\t\tif (declaringTypeSignature.indexOf(Signature.C_GENERIC_START) < 0) {", "+\t\t\t\t\tdeclaringTypePart = declaringType.toCharArray();", "+\t\t\t\t} else {", "+\t\t\t\t\tdeclaringTypePart = Signature.toCharArray(Signature.getTypeErasure(declaringTypeSignature.toCharArray()));", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tcatch (IllegalArgumentException iae) {", "+\t\t\t\t// declaring type is invalid", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t\tparameterTypeSignatures = new String[parameterCount];", "-\t\t\t\tchar[] parameterTypePart = parameterTypes[i].toCharArray();", "+\t\t\t\t// get parameter type part and signature", "+\t\t\t\tchar[] parameterTypePart = null;", "+\t\t\t\ttry {", "+\t\t\t\t\tparameterTypeSignatures[i] = Signature.createTypeSignature(parameterTypes[i], false);", "+\t\t\t\t\tif (parameterTypeSignatures[i].indexOf(Signature.C_GENERIC_START) < 0) {", "+\t\t\t\t\t\tparameterTypePart = parameterTypes[i].toCharArray();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tparameterTypePart = Signature.toCharArray(Signature.getTypeErasure(parameterTypeSignatures[i].toCharArray()));", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tcatch (IllegalArgumentException iae) {", "+\t\t\t\t\t// string is not a valid type syntax", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "-\t\t\tchar[] returnTypePart = returnType.toCharArray();", "+\t\t\t// get return type part and signature", "+\t\t\tchar[] returnTypePart = null;", "+\t\t\ttry {", "+\t\t\t\treturnTypeSignature = Signature.createTypeSignature(returnType, false);", "+\t\t\t\tif (returnTypeSignature.indexOf(Signature.C_GENERIC_START) < 0) {", "+\t\t\t\t\treturnTypePart = returnType.toCharArray();", "+\t\t\t\t} else {", "+\t\t\t\t\treturnTypePart = Signature.toCharArray(Signature.getTypeErasure(returnTypeSignature.toCharArray()));", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tcatch (IllegalArgumentException iae) {", "+\t\t\t\t// declaring type is invalid", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t// Create method/constructor pattern", "+\t\tboolean findDeclarations = true;", "+\t\tboolean findReferences = true;", "-\t\t\t\treturn new MethodPattern(", "-\t\t\t\t\ttrue,", "-\t\t\t\t\tfalse,", "-\t\t\t\t\tselectorChars, ", "-\t\t\t\t\tdeclaringTypeQualification, ", "-\t\t\t\t\tdeclaringTypeSimpleName, ", "-\t\t\t\t\treturnTypeQualification, ", "-\t\t\t\t\treturnTypeSimpleName, ", "-\t\t\t\t\tparameterTypeQualifications, ", "-\t\t\t\t\tparameterTypeSimpleNames,", "-\t\t\t\t\tfalse,", "-\t\t\t\t\tnull,", "-\t\t\t\t\tmatchRule);", "+\t\t\t\tfindReferences = false;", "+\t\t\t\tbreak;", "-\t\t\t\treturn new MethodPattern(", "-\t\t\t\t\tfalse,", "-\t\t\t\t\ttrue,", "-\t\t\t\t\tselectorChars, ", "-\t\t\t\t\tdeclaringTypeQualification, ", "-\t\t\t\t\tdeclaringTypeSimpleName, ", "-\t\t\t\t\treturnTypeQualification, ", "-\t\t\t\t\treturnTypeSimpleName, ", "-\t\t\t\t\tparameterTypeQualifications, ", "-\t\t\t\t\tparameterTypeSimpleNames,", "-\t\t\t\t\tfalse,", "-\t\t\t\t\tnull,", "-\t\t\t\t\tmatchRule);", "+\t\t\t\tfindDeclarations = false;", "+\t\t\t\tbreak;", "-\t\t\t\treturn new MethodPattern(", "-\t\t\t\t\ttrue,", "-\t\t\t\t\ttrue,", "-\t\t\t\t\tselectorChars, ", "-\t\t\t\t\tdeclaringTypeQualification, ", "+\t\t\t\tbreak;", "+\t\t}", "+\t\tif (isConstructor) {", "+\t\t\treturn new ConstructorPattern(", "+\t\t\t\t\tfindDeclarations,", "+\t\t\t\t\tfindReferences,", "-\t\t\t\t\treturnTypeQualification, ", "-\t\t\t\t\treturnTypeSimpleName, ", "+\t\t\t\t\tdeclaringTypeQualification,", "+\t\t\t\t\tdeclaringTypeSignature,", "+\t\t\t\t\tparameterTypeSignatures,", "-\t\t\t\t\tnull,", "+\t\t\t\t\ttypeArguments,", "+\t\t\t\t\tmatchRule);", "+\t\t} else {", "+\t\t\treturn new MethodPattern(", "+\t\t\t\t\tfindDeclarations,", "+\t\t\t\t\tfindReferences,", "+\t\t\t\t\tselectorChars,", "+\t\t\t\t\tdeclaringTypeQualification,", "+\t\t\t\t\tdeclaringTypeSimpleName,", "+\t\t\t\t\tdeclaringTypeSignature,", "+\t\t\t\t\treturnTypeQualification,", "+\t\t\t\t\treturnTypeSimpleName,", "+\t\t\t\t\treturnTypeSignature,", "+\t\t\t\t\tparameterTypeQualifications,", "+\t\t\t\t\tparameterTypeSimpleNames,", "+\t\t\t\t\tparameterTypeSignatures,", "+\t\t\t\t\tfalse,", "+\t\t\t\t\ttypeArguments,", "-\t\treturn null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aaac63b5aff066e1074aeb72c88bb8f3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DocCommentParser.java", "commitBeforeChange": "da3abb814c31b6e1c2d43312de494af316e19273", "commitAfterChange": "8af0e3d96f10bb27360a77bbd330487cf3fdc8dd", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tprotected boolean parseTag()", "signatureAfterChange": " \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "diff": ["-\tprotected boolean parseTag() {", "-\t\tTagElement tag = this.ast.newTagElement();", "-\t\tint start = this.tagSourceStart;", "-\t\ttag.setTagName(new String(this.source, start, this.tagSourceEnd-start+1));", "-\t\tif (this.inlineTagStarted) {", "-\t\t\tstart = this.inlineTagStart;", "-\t\t\tTagElement previousTag = null;", "-\t\t\tif (this.astPtr == -1) {", "-\t\t\t\tpreviousTag = this.ast.newTagElement();", "-\t\t\t\tpreviousTag.setSourceRange(start, this.tagSourceEnd-start+1);", "-\t\t\t\tpushOnAstStack(previousTag, true);", "-\t\t\t} else {", "-\t\t\t\tpreviousTag = (TagElement) this.astStack[this.astPtr];", "+\tprotected boolean parseTag(int previousPosition) throws InvalidInputException {", "+\t\t", "+\t\t// Read tag name", "+\t\tint token = readTokenAndConsume();", "+\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "+\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\tchar[] tag = this.scanner.getCurrentIdentifierSource(); // first token is either an identifier or a keyword", "+", "+\t\t// Try to get tag name other than java identifier", "+\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51660)", "+\t\tint tk = token;", "+\t\tint le = this.lineEnd;", "+\t\tchar pc = peekChar();", "+\t\ttagNameToken: while (tk != TerminalTokens.TokenNameEOF) {", "+\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\ttoken = tk;", "+\t\t\t// !, \", #, %, &, ', -, :, <, >, * chars and spaces are not allowed in tag names", "+\t\t\tswitch (pc) {", "+\t\t\t\tcase '}':", "+\t\t\t\tcase '!':", "+\t\t\t\tcase '#':", "+\t\t\t\tcase '%':", "+\t\t\t\tcase '&':", "+\t\t\t\tcase '\\'':", "+\t\t\t\tcase '\"':", "+\t\t\t\tcase ':':", "+\t\t\t\t// case '-': allowed in tag names as this character is often used in doclets (bug 68087)", "+\t\t\t\tcase '<':", "+\t\t\t\tcase '>':", "+\t\t\t\tcase '*': // break for '*' as this is perhaps the end of comment (bug 65288)", "+\t\t\t\t\tbreak tagNameToken;", "+\t\t\t\tdefault:", "+\t\t\t\t\tif (pc == ' ' || Character.isWhitespace(pc)) break tagNameToken;", "-\t\t\tint previousStart = previousTag.getStartPosition();", "-\t\t\tpreviousTag.fragments().add(tag);", "-\t\t\tpreviousTag.setSourceRange(previousStart, this.tagSourceEnd-previousStart+1);", "-\t\t} else {", "-\t\t\tpushOnAstStack(tag, true);", "+\t\t\ttk = readTokenAndConsume();", "+\t\t\tpc = peekChar();", "-\t\ttag.setSourceRange(start, this.tagSourceEnd-start+1);", "-\t\treturn true;", "+\t\tint length = this.tagSourceEnd-this.tagSourceStart+1;", "+\t\ttag = new char[length];", "+\t\tSystem.arraycopy(this.source, this.tagSourceStart, tag, 0, length);", "+\t\tthis.index = this.tagSourceEnd+1;", "+\t\tthis.scanner.currentPosition = this.tagSourceEnd+1;", "+\t\tthis.tagSourceStart = previousPosition;", "+\t\tthis.lineEnd = le;", "+", "+\t\t// Decide which parse to perform depending on tag name", "+\t\tthis.tagValue = NO_TAG_VALUE;", "+\t\tboolean valid = true;", "+\t\tswitch (token) {", "+\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\tswitch (tag[0]) {", "+\t\t\t\t\tcase 'd':", "+\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "+\t\t\t\t\t\t\tthis.deprecated = true;", "+\t\t\t\t\t\t\tthis.tagValue = TAG_DEPRECATED_VALUE;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_OTHERS_VALUE;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcreateTag();", "+\t\t\t\t\tbreak;", "+\t\t\t\t\tcase 'i':", "+\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_INHERITDOC)) {", "+\t\t\t\t\t\t\t// inhibits inherited flag when tags have been already stored", "+\t\t\t\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51606", "+\t\t\t\t\t\t\t// Note that for DOM_PARSER, nodes stack may be not empty even no '@' tag", "+\t\t\t\t\t\t\t// was encountered in comment. But it cannot be the case for COMPILER_PARSER", "+\t\t\t\t\t\t\t// and so is enough as it is only this parser which signals the missing tag warnings...", "+\t\t\t\t\t\t\tthis.inherited = this.astPtr==-1;", "+\t\t\t\t\t\t\tthis.tagValue = TAG_INHERITDOC_VALUE;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_OTHERS_VALUE;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcreateTag();", "+\t\t\t\t\tbreak;", "+\t\t\t\t\tcase 'p':", "+\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_PARAM)) {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_PARAM_VALUE;", "+\t\t\t\t\t\t\tvalid = parseParam();", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_OTHERS_VALUE;", "+\t\t\t\t\t\t\tcreateTag();", "+\t\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t\tcase 'e':", "+\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_EXCEPTION_VALUE;", "+\t\t\t\t\t\t\tvalid = parseThrows();", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_OTHERS_VALUE;", "+\t\t\t\t\t\t\tcreateTag();", "+\t\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t\tcase 's':", "+\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_SEE)) {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_SEE_VALUE;", "+\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "+\t\t\t\t\t\t\t\t// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=53290", "+\t\t\t\t\t\t\t\t// Cannot have @see inside inline comment", "+\t\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tvalid = parseReference();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_OTHERS_VALUE;", "+\t\t\t\t\t\t\tcreateTag();", "+\t\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t\tcase 'l':", "+\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_LINK)) {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_LINK_VALUE;", "+\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_LINKPLAIN)) {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_LINKPLAIN_VALUE;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.tagValue != NO_TAG_VALUE)  {", "+\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "+\t\t\t\t\t\t\t\tvalid = parseReference();", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=53290", "+\t\t\t\t\t\t\t\t// Cannot have @link outside inline comment", "+\t\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_OTHERS_VALUE;", "+\t\t\t\t\t\t\tcreateTag();", "+\t\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t\tcase 'v':", "+\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_VALUE) && this.ast.apiLevel() >= AST.JLS3) {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_VALUE_VALUE;", "+\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "+\t\t\t\t\t\t\t\tvalid = parseReference();", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.tagValue = TAG_OTHERS_VALUE;", "+\t\t\t\t\t\t\tcreateTag();", "+\t\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tthis.tagValue = TAG_OTHERS_VALUE;", "+\t\t\t\t\t\tcreateTag();", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tcase TerminalTokens.TokenNamereturn :", "+\t\t\t\tthis.tagValue = TAG_RETURN_VALUE;", "+\t\t\t\tvalid = parseReturn();", "+\t\t\t\tbreak;", "+\t\t\tcase TerminalTokens.TokenNamethrows :", "+\t\t\t\tthis.tagValue = TAG_THROWS_VALUE;", "+\t\t\t\tvalid = parseThrows();", "+\t\t\t\tbreak;", "+\t\t\tcase TerminalTokens.TokenNameabstract:", "+\t\t\tcase TerminalTokens.TokenNameassert:", "+\t\t\tcase TerminalTokens.TokenNameboolean:", "+\t\t\tcase TerminalTokens.TokenNamebreak:", "+\t\t\tcase TerminalTokens.TokenNamebyte:", "+\t\t\tcase TerminalTokens.TokenNamecase:", "+\t\t\tcase TerminalTokens.TokenNamecatch:", "+\t\t\tcase TerminalTokens.TokenNamechar:", "+\t\t\tcase TerminalTokens.TokenNameclass:", "+\t\t\tcase TerminalTokens.TokenNamecontinue:", "+\t\t\tcase TerminalTokens.TokenNamedefault:", "+\t\t\tcase TerminalTokens.TokenNamedo:", "+\t\t\tcase TerminalTokens.TokenNamedouble:", "+\t\t\tcase TerminalTokens.TokenNameelse:", "+\t\t\tcase TerminalTokens.TokenNameextends:", "+\t\t\tcase TerminalTokens.TokenNamefalse:", "+\t\t\tcase TerminalTokens.TokenNamefinal:", "+\t\t\tcase TerminalTokens.TokenNamefinally:", "+\t\t\tcase TerminalTokens.TokenNamefloat:", "+\t\t\tcase TerminalTokens.TokenNamefor:", "+\t\t\tcase TerminalTokens.TokenNameif:", "+\t\t\tcase TerminalTokens.TokenNameimplements:", "+\t\t\tcase TerminalTokens.TokenNameimport:", "+\t\t\tcase TerminalTokens.TokenNameinstanceof:", "+\t\t\tcase TerminalTokens.TokenNameint:", "+\t\t\tcase TerminalTokens.TokenNameinterface:", "+\t\t\tcase TerminalTokens.TokenNamelong:", "+\t\t\tcase TerminalTokens.TokenNamenative:", "+\t\t\tcase TerminalTokens.TokenNamenew:", "+\t\t\tcase TerminalTokens.TokenNamenull:", "+\t\t\tcase TerminalTokens.TokenNamepackage:", "+\t\t\tcase TerminalTokens.TokenNameprivate:", "+\t\t\tcase TerminalTokens.TokenNameprotected:", "+\t\t\tcase TerminalTokens.TokenNamepublic:", "+\t\t\tcase TerminalTokens.TokenNameshort:", "+\t\t\tcase TerminalTokens.TokenNamestatic:", "+\t\t\tcase TerminalTokens.TokenNamestrictfp:", "+\t\t\tcase TerminalTokens.TokenNamesuper:", "+\t\t\tcase TerminalTokens.TokenNameswitch:", "+\t\t\tcase TerminalTokens.TokenNamesynchronized:", "+\t\t\tcase TerminalTokens.TokenNamethis:", "+\t\t\tcase TerminalTokens.TokenNamethrow:", "+\t\t\tcase TerminalTokens.TokenNametransient:", "+\t\t\tcase TerminalTokens.TokenNametrue:", "+\t\t\tcase TerminalTokens.TokenNametry:", "+\t\t\tcase TerminalTokens.TokenNamevoid:", "+\t\t\tcase TerminalTokens.TokenNamevolatile:", "+\t\t\tcase TerminalTokens.TokenNamewhile:", "+\t\t\t\tthis.tagValue = TAG_OTHERS_VALUE;", "+\t\t\t\tcreateTag();", "+\t\t\t\tbreak;", "+\t\t}", "+\t\tthis.textStart = this.index;", "+\t\treturn valid;"]}], "num": 28361}