{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ac0a080c80b4f5a9cf521274facda6b0", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9ebdf163e0a9ee3c7e46b0e43106c78b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "b0ee678b65f48d1cfab35972dd53d6bd85389446", "commitAfterChange": "5a11933bf440021c4c92ce580c9967dadb549d6e", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite, boolean tiebreakingVarargsMethods)", "signatureAfterChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite, boolean tiebreakingVarargsMethods)", "diff": ["-\t\t\tfor (int i = 0; i < argLength; i++) {", "-\t\t\t\tTypeBinding param = i < paramLength ? parameters[i] : parameters[paramLength - 1];", "-\t\t\t\tif (arguments[i].isBaseType() != param.isBaseType()) {", "-\t\t\t\t\tif (newArgs == null) {", "-\t\t\t\t\t\tnewArgs = new TypeBinding[argLength];", "-\t\t\t\t\t\tSystem.arraycopy(arguments, 0, newArgs, 0, argLength);", "+\t\t\tif (compilerOptions.sourceLevel < ClassFileConstants.JDK1_8 || genericTypeArguments != null) { // for 1.8+ inferred calls, we do this inside PGMB.cCM18.", "+\t\t\t\tfor (int i = 0; i < argLength; i++) {", "+\t\t\t\t\tTypeBinding param = i < paramLength ? parameters[i] : parameters[paramLength - 1];", "+\t\t\t\t\tif (arguments[i].isBaseType() != param.isBaseType()) {", "+\t\t\t\t\t\tif (newArgs == null) {", "+\t\t\t\t\t\t\tnewArgs = new TypeBinding[argLength];", "+\t\t\t\t\t\t\tSystem.arraycopy(arguments, 0, newArgs, 0, argLength);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tnewArgs[i] = environment().computeBoxingType(arguments[i]);", "-\t\t\t\t\tnewArgs[i] = environment().computeBoxingType(arguments[i]);", "-\t\t\telse  // ensure that computeCompatibleMethod() below can update arguments without harming our caller: (TODO: always copy before the loop? only in 1.8?)", "-\t\t\t\tSystem.arraycopy(arguments, 0, arguments=new TypeBinding[argLength], 0, argLength);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5db50e523ad6c6a1bf0e64054fd5006", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "b0ee678b65f48d1cfab35972dd53d6bd85389446", "commitAfterChange": "5a11933bf440021c4c92ce580c9967dadb549d6e", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic static MethodBinding computeCompatibleMethod18(MethodBinding originalMethod, TypeBinding[] arguments, final Scope scope, InvocationSite invocationSite)", "signatureAfterChange": "  \tpublic static MethodBinding computeCompatibleMethod18(MethodBinding originalMethod, TypeBinding[] arguments, final Scope scope, InvocationSite invocationSite)", "diff": ["-\t\tInferenceContext18 infCtx18 = null;", "+\t\tInferenceContext18 infCtx18 = invocationSite.freshInferenceContext(scope);", "-\t\tinfCtx18 = invocationSite.freshInferenceContext(scope);", "+\t\tboolean requireBoxing = false;", "+\t\t", "+\t\t// See if we should start in loose inference mode.", "+\t\tTypeBinding [] argumentsCopy = new TypeBinding[arguments.length];", "+\t\tfor (int i = 0, length = arguments.length, parametersLength = parameters.length ; i < length; i++) {", "+\t\t\tTypeBinding parameter = i < parametersLength ? parameters[i] : parameters[parametersLength - 1];", "+\t\t\tfinal TypeBinding argument = arguments[i];", "+\t\t\tif (argument.isPrimitiveType() != parameter.isPrimitiveType()) { // Scope.cCM incorrectly but harmlessly uses isBaseType which answers true for null.", "+\t\t\t\targumentsCopy[i] = scope.environment().computeBoxingType(argument);", "+\t\t\t\trequireBoxing = true; // can't be strict mode, needs at least loose.", "+\t\t\t} else {", "+\t\t\t\targumentsCopy[i] = argument;", "+\t\t\t}", "+\t\t}", "+\t\targuments = argumentsCopy; // either way, this allows the engine to update arguments without harming the callers. ", "-\t\t\t\tinfCtx18.inferenceKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.", "+\t\t\t\tinfCtx18.inferenceKind = requireBoxing ? InferenceContext18.CHECK_LOOSE : InferenceContext18.CHECK_STRICT; // engine may still slip into loose mode and adjust level."]}], "num": 1389}