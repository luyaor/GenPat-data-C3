{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c46c04a23314cfa49d409a2565082122", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f27aad64a40879020c7e260c44874e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "25a0c02d6979e76d70832f78f8eb60bd371c0ad1", "commitAfterChange": "1b6413921860c74cfa469f859f6fc627d6400adf", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \tprivate ReferenceBinding[] computeKosherThrowables()", "signatureAfterChange": " \t \tprivate boolean argumentsTypeElided()", "diff": ["-\tprivate ReferenceBinding[] computeKosherThrowables() {", "-\t\treturn this.singleAbstractMethod == null || !this.singleAbstractMethod.isValidBinding() ? Binding.NO_EXCEPTIONS : this.singleAbstractMethod.thrownExceptions; // for now.", "+\tprivate boolean argumentsTypeElided() {", "+\t\treturn this.arguments.length > 0 && this.arguments[0].hasElidedType();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37f60b2cbba11e82aa28f904df363d3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "db260d93667acab111e64138469df12a566a7b90", "commitAfterChange": "41616c6495c935b90356748e848cc3a6ffe7665e", "methodNumberBeforeChange": 132, "methodNumberAfterChange": 132, "signatureBeforeChange": " protected void consumeNestedType()", "signatureAfterChange": " protected void consumeNestedType()", "diff": ["-\tthis.nestedType++;", "-\ttry {", "-\t\tthis.nestedMethod[this.nestedType] = 0;", "-\t} catch (IndexOutOfBoundsException e) {", "-\t\t//except in test's cases, it should never raise", "-\t\tint oldL = this.nestedMethod.length;", "-\t\tSystem.arraycopy(this.nestedMethod , 0, (this.nestedMethod = new int[oldL + 30]), 0, oldL);", "-\t\tthis.nestedMethod[this.nestedType] = 0;", "-\t\t// increase the size of the fieldsCounter as well. It has to be consistent with the size of the nestedMethod collection", "-\t\tSystem.arraycopy(this.variablesCounter, 0, (this.variablesCounter = new int[oldL + 30]), 0, oldL);", "+\tint length = this.nestedMethod.length;", "+\tif (++this.nestedType >= length) {", "+\t\tSystem.arraycopy(", "+\t\t\tthis.nestedMethod, 0,", "+\t\t\tthis.nestedMethod = new int[length + 30], 0,", "+\t\t\tlength);", "+\t\t// increase the size of the variablesCounter as well. It has to be consistent with the size of the nestedMethod collection", "+\t\tSystem.arraycopy(", "+\t\t\tthis.variablesCounter, 0,", "+\t\t\tthis.variablesCounter = new int[length + 30], 0,", "+\t\t\tlength);", "+\tthis.nestedMethod[this.nestedType] = 0;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "83b27fb8a789c4e2af4149a1dcb1740d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java", "commitBeforeChange": "1639bd6af95429f315066bc991f1a39635a7a06b", "commitAfterChange": "39fac05fa8b77fcaf96c0cb04f6cdf322c685cfd", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": "  public int getNextToken() throws InvalidInputException", "signatureAfterChange": "  public int getNextToken() throws InvalidInputException", "diff": ["-\tif (!this.scanningJava8Plus || this.activeParser == null) {", "-\t\treturn token;  // no audience, no magic.", "+\tif (this.activeParser == null) { // anybody interested in the grammatical structure of the program should have registered.", "+\t\treturn token;", "-\tif (token == TokenNameLPAREN && this.activeParser.atConflictScenario(token)) {", "-\t\tif (atLambdaParameterList()) {", "-\t\t\tthis.nextToken = token;", "-\t\t\ttoken = TokenNameBeginLambda;", "-\t\t}", "-\t} else if (token == TokenNameLESS && this.activeParser.atConflictScenario(token)) {", "-\t\tif (atReferenceExpression()) {", "-\t\t\tthis.nextToken = token;", "-\t\t\ttoken = TokenNameBeginTypeArguments;", "-\t\t}", "+\tif (token == TokenNameLPAREN && atLambdaParameterList()) {", "+\t\tthis.nextToken = token;", "+\t\ttoken = TokenNameBeginLambda;", "+\t} else if (token == TokenNameLESS && atReferenceExpression()) {", "+\t\tthis.nextToken = token;", "+\t\ttoken = TokenNameBeginTypeArguments;", "+", "+\tthis.lookBack[0] = this.lookBack[1];", "+\tthis.lookBack[1] = token;"]}], "num": 56754}