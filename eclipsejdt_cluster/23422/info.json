{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "38a6844d620431e68085922d41232ad3", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eb56fa3c52077a95b778ac3d6f32b5ea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "a6bc9b89c0f99b3b1a760aa351e68b2be5cc2b5f", "commitAfterChange": "8a48a7de4f9fc7b7b5d29ad5943e4b915c73fc49", "methodNumberBeforeChange": 54, "methodNumberAfterChange": 54, "signatureBeforeChange": "\r \tpublic void runOperation(JavaModelOperation operation, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": "\r \tpublic void runOperation(JavaModelOperation operation, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\r\t\ttry {\r", "-\t\t\tif (operation.isReadOnly() || operation instanceof SetClasspathOperation) {\r", "-\t\t\t\tboolean wasFiring = isFiring();\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tif (wasFiring) stopDeltas();\r", "-\t\t\t\t\toperation.run(monitor);\r", "-\t\t\t\t} finally {\r", "-\t\t\t\t\tif (wasFiring) {\r", "-\t\t\t\t\t\tstartDeltas();\r", "-\t\t\t\t\t\tfire();\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t} else {\r", "-\t\t\t\t// use IWorkspace.run(...) to ensure that a build will be done in autobuild mode\r", "-\t\t\t\tthis.getJavaModel().getWorkspace().run(operation, monitor);\r", "-\t\t\t\t // NB: deltas are fired while processing the resource delta\r", "-\t\t\t}\r", "+\t\tboolean hadAwaitingDeltas = !fJavaModelDeltas.isEmpty();\r\t\ttry {\r", "+\t\t\t// use IWorkspace.run(...) to ensure that a build will be done in autobuild mode\r", "+\t\t\tthis.getJavaModel().getWorkspace().run(operation, monitor);\r", "+\t\t} finally {\r", "+\t\t\t// fire only if there were no awaiting deltas (if there were, they would come from a resource modifying operation)\r", "+\t\t\t// and the operation has not modified any resource\r", "+\t\t\tif (!hadAwaitingDeltas && !operation.hasModifiedResource()) {\r", "+\t\t\t\tfire();\r", "+\t\t\t} // else deltas are fired while processing the resource delta\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "faf18c798f804f527ff6cbdcbc055042", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tprotected boolean createHierarchyResolver(PotentialMatch[] potentialMatches)", "signatureAfterChange": " protected boolean createHierarchyResolver(IType focusType, PotentialMatch[] potentialMatches)", "diff": ["-\t */", "-\tprotected boolean createHierarchyResolver(PotentialMatch[] potentialMatches) {", "-\t\t// create hierarchy resolver if scope is a hierarchy scope", "-\t\tIType focusType = getFocusType();", "-\t\tif (focusType != null) {", "-\t\t\t// cache focus type if not a potential match", "-\t\t\tchar[][] compoundName = CharOperation.splitOn('.', focusType.getFullyQualifiedName().toCharArray());", "-\t\t\tboolean isPotentialMatch = false;", "-\t\t\tfor (int i = 0, length = potentialMatches.length; i < length; i++) {", "-\t\t\t\tif (CharOperation.equals(potentialMatches[i].compoundName, compoundName)) {", "-\t\t\t\t\tisPotentialMatch = true;", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (!isPotentialMatch) {", "-\t\t\t\tif (focusType.isBinary()) {", "-\t\t\t\t\t// cache binary type", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tthis.cacheBinaryType(focusType);", "-\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\t// cache all types in the focus' compilation unit (even secondary types)", "-\t\t\t\t\tthis.accept((ICompilationUnit)focusType.getCompilationUnit());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// resolve focus type", "-\t\t\tthis.hierarchyResolver = new HierarchyResolver(this.lookupEnvironment, null/*hierarchy is not going to be computed*/);", "-\t\t\tReferenceBinding focusTypeBinding = this.hierarchyResolver.setFocusType(compoundName);", "-\t\t\tif (focusTypeBinding == null || !focusTypeBinding.isValidBinding() || (focusTypeBinding.tagBits & TagBits.HierarchyHasProblems) > 0) {", "-\t\t\t\t// focus type is not visible from this project", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t} else {", "-\t\t\tthis.hierarchyResolver = null;", "-\t\t}", "-\t\treturn true;", "-\t}", "+ */", "+protected boolean createHierarchyResolver(IType focusType, PotentialMatch[] potentialMatches) {", "+\t// cache focus type if not a potential match", "+\tchar[][] compoundName = CharOperation.splitOn('.', focusType.getFullyQualifiedName().toCharArray());", "+\tboolean isPotentialMatch = false;", "+\tfor (int i = 0, length = potentialMatches.length; i < length; i++) {", "+\t\tif (CharOperation.equals(potentialMatches[i].compoundName, compoundName)) {", "+\t\t\tisPotentialMatch = true;", "+\t\t\tbreak;", "+\tif (!isPotentialMatch) {", "+\t\tif (focusType.isBinary()) {", "+\t\t\ttry {", "+\t\t\t\tcacheBinaryType(focusType);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\treturn false;", "+\t\t} else {", "+\t\t\t// cache all types in the focus' compilation unit (even secondary types)", "+\t\t\taccept((ICompilationUnit) focusType.getCompilationUnit());", "+\t}", "+", "+\t// resolve focus type", "+\tthis.hierarchyResolver = new HierarchyResolver(this.lookupEnvironment, null/*hierarchy is not going to be computed*/);", "+\tReferenceBinding binding = this.hierarchyResolver.setFocusType(compoundName);", "+\treturn binding != null && binding.isValidBinding() && (binding.tagBits & TagBits.HierarchyHasProblems) == 0;", "+}"]}], "num": 23422}