{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7a5c818d4298824800891173eba02a9b", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7f1762c19ce546d8cc5d7ceb743b4e79", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "signatureAfterChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "diff": ["-\t\tproper:", "-\t\t\tTypeBinding exprType = this.left.resolvedType;", "-\t\t\tif (exprType == null) {", "-\t\t\t\t// if we get here for some kinds of poly expressions (incl. ConditionalExpression),", "-\t\t\t\t// then other ways for checking compatibility are needed:", "-                if (this.left instanceof FunctionalExpression) {", "-                    if (this.left instanceof LambdaExpression) {", "-                        // cf. NegativeLambdaExpressionTest.test412453()", "-                        LambdaExpression copy = ((LambdaExpression) this.left).getResolvedCopyForInferenceTargeting(this.right);", "-                        return (copy != null && copy.resolvedType != null && copy.resolvedType.isValidBinding()) ? TRUE : FALSE;", "-                    }", "-                }", "-                return this.left.isCompatibleWith(this.right, inferenceContext.scope) ? TRUE : FALSE;", "-\t\t\t} else if (!exprType.isValidBinding()) {", "-\t\t\t\treturn FALSE;", "-\t\t\t}", "-\t\t\tif (isCompatibleWithInLooseInvocationContext(exprType, this.right, inferenceContext)) {", "-\t\t\t\treturn TRUE;", "-\t\t\t} else if (this.left instanceof AllocationExpression && this.left.isPolyExpression()) {", "-\t\t\t\t// half-resolved diamond has a resolvedType, but that may not be the final word, try one more step of resolution:", "-            \tMethodBinding binding = ((AllocationExpression) this.left).binding(this.right, false, null);", "-            \treturn (binding != null && binding.declaringClass.isCompatibleWith(this.right, inferenceContext.scope)) ? TRUE : FALSE;", "-            } else if (this.left instanceof Invocation && this.left.isPolyExpression()) {", "-            \tInvocation invoc = (Invocation) this.left;", "-            \tMethodBinding binding = invoc.binding(this.right, false, null);", "-            \tif (binding instanceof ParameterizedGenericMethodBinding) {", "-            \t\tParameterizedGenericMethodBinding method = (ParameterizedGenericMethodBinding) binding;", "-\t\t\t\t\tInferenceContext18 leftCtx = invoc.getInferenceContext(method);", "-            \t\tif (leftCtx.stepCompleted < InferenceContext18.TYPE_INFERRED) {", "-            \t\t\tbreak proper; // fall through into nested inference below (not explicit in the spec!)", "-            \t\t}", "-            \t}", "-            }", "-\t\t\treturn FALSE;", "+\t\t\treturn this.left.isCompatibleWith(this.right, inferenceContext.scope) || this.left.isBoxingCompatibleWith(this.right, inferenceContext.scope) ? TRUE : FALSE;", "-\t\t\t\tMethodBinding previousMethod = invocation.binding(this.right, false, null);", "+\t\t\t\tMethodBinding previousMethod = invocation.binding(this.right, inferenceContext.scope);", "+\t\t\t\t\t\tif (innerCtx.stepCompleted >= InferenceContext18.TYPE_INFERRED) {", "+\t\t\t\t\t\t\t// The constraints and initial bounds that would effectively reduce to b3 are already transferred to current context during C Set construction.", "+\t\t\t\t\t\t\treturn TRUE;", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tinnerCtx.outerContext = inferenceContext;", "-\t\t\t\t\tExpression[] exprs;", "-\t\t\t\t\tif (lambda.body() instanceof Expression) {", "-\t\t\t\t\t\texprs = new Expression[] {(Expression)lambda.body()};", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\texprs = lambda.resultExpressions();", "-\t\t\t\t\t}", "-\t\t\t\t\tfor (int i = 0; i < exprs.length; i++) {", "+\t\t\t\t\tExpression[] exprs = lambda.resultExpressions();", "+\t\t\t\t\tfor (int i = 0, length = exprs == null ? 0 : exprs.length; i < length; i++) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e06cfd9397b70d1d68ffad33d69deeb0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "67be753fec1b8f88653e28d3d4d4837dd29cdece", "commitAfterChange": "c76b87d837ed14384819cb84439501329f23edce", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 22, "signatureBeforeChange": "\r \r \tprivate IBinding resolveNameForNameReference(Name name, AstNode node)", "signatureAfterChange": "\r \r \tprivate IBinding internalResolveNameForSimpleName(Name name)", "diff": ["-\r", "-\tprivate IBinding resolveNameForNameReference(Name name, AstNode node) {\r", "-\t\tif (node != null) {\r", "-\t\t\tif (node instanceof SingleNameReference) {\r", "-\t\t\t\tSingleNameReference singleNameReference = (SingleNameReference) node;\r", "-\t\t\t\tif (singleNameReference.isTypeReference()) {\r", "-\t\t\t\t\treturn this.getTypeBinding((ReferenceBinding)singleNameReference.binding);\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\t// this is a variable or a field\r", "-\t\t\t\t\treturn this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding)singleNameReference.binding);\t\t\t\t\r", "-\t\t\t\t}\r", "-\t\t\t} else if (node instanceof QualifiedNameReference) {\r", "-\t\t\t\tQualifiedNameReference qualifiedNameReference = (QualifiedNameReference) node;\r", "-\t\t\r", "-\t\t\t\tif (qualifiedNameReference.isTypeReference()) {\r", "-\t\t\t\t\treturn this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\t// this is a variable or a field\r", "-\t\t\t\t\tif (qualifiedNameReference.otherBindings == null) {\r", "-\t\t\t\t\t\treturn this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) qualifiedNameReference.binding);\t\t\t\t\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\treturn this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) qualifiedNameReference.otherBindings[qualifiedNameReference.otherBindings.length - 1]);\t\t\t\t\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t// this might be a inner qualified name or simple name inside a qualified name\r", "-\t\tint index = 1;\r", "-\t\tQualifiedName firstQualifier = null;\r", "-\t\tName firstName = name;\r", "-\t\tif (name.isSimpleName()) {\r", "-\t\t\tif (name.getParent() instanceof QualifiedName) {\r", "-\t\t\t\tname = (QualifiedName) name.getParent();\r", "-\t\t\t\tfirstQualifier = (QualifiedName) name;\r", "-\t\t\t} else {\r", "-\t\t\t\treturn super.resolveName(name);\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\twhile (name.getParent() instanceof QualifiedName) {\r", "-\t\t\tindex++;\r", "-\t\t\tname = (QualifiedName) name.getParent();\r", "-\t\t}\r", "-\t\t// now we can retrieve the enclosing compiler's node corresponding to the inner name\r", "-\t\tnode = (AstNode) this.newAstToOldAst.get(name);\r", "-\t\tif (node == null) {\r", "-\t\t\treturn super.resolveName(name);\r", "-\t\t} else if (node instanceof NameReference) {\r", "-\t\t\t\r", "-\t\t\tQualifiedNameReference qualifiedNameReference = (QualifiedNameReference) node;\r", "-\t\t\tif (firstQualifier != null) {\r", "-\t\t\t\t// handle the first simple name in a qualified name a.b.c.d (handles the 'a' case)\r", "-\t\t\t\tName firstQualifierName = firstQualifier.getQualifier();\r", "-\t\t\t\tif (firstQualifierName.isSimpleName() && firstName == firstQualifierName) {\r", "-\t\t\t\t\treturn this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) qualifiedNameReference.binding);\t\t\t\t\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tif (qualifiedNameReference.isTypeReference()) {\r", "-\t\t\t\treturn this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);\r", "-\t\t\t} else {\r", "-\t\t\t\t// this is a variable or a field\r", "-\t\t\t\treturn this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) qualifiedNameReference.otherBindings[qualifiedNameReference.otherBindings.length - index]);\t\t\t\t\r", "-\t\t\t}\r", "-\t\t} else if (node instanceof MessageSend) {\r", "-\t\t\treturn this.resolveNameForMessageSend(name, node, index);\r", "-\t\t}\r", "-\t\treturn super.resolveName(name);\r", "-\t}\r", "+\r", "+\tprivate IBinding internalResolveNameForSimpleName(Name name) {\r", "+\t\tAstNode node = (AstNode) this.newAstToOldAst.get(name);\r", "+\t\tif (node == null) {\r", "+\t\t\tASTNode parent = name.getParent();\r", "+\t\t\tif (parent instanceof QualifiedName) {\r", "+\t\t\t\t// retrieve the qualified name and remember at which position is the simple name\r", "+\t\t\t\tQualifiedName qualifiedName = (QualifiedName) parent;\r", "+\t\t\t\tint index = -1;\r", "+\t\t\t\tif (qualifiedName.getQualifier() == name) {\r", "+\t\t\t\t\tindex++;\r", "+\t\t\t\t}\r", "+\t\t\t\twhile (parent instanceof QualifiedName) {\r", "+\t\t\t\t\tqualifiedName = (QualifiedName) parent;\r", "+\t\t\t\t\tparent = parent.getParent();\r", "+\t\t\t\t\tindex++;\r", "+\t\t\t\t}\r", "+\t\t\t\treturn returnBindingForQualifiedNamePart(qualifiedName, index);\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (node instanceof SingleNameReference) {\r", "+\t\t\tSingleNameReference singleNameReference = (SingleNameReference) node;\r", "+\t\t\tif (singleNameReference.isTypeReference()) {\r", "+\t\t\t\treturn this.getTypeBinding((ReferenceBinding)singleNameReference.binding);\r", "+\t\t\t} else {\r", "+\t\t\t\t// this is a variable or a field\r", "+\t\t\t\treturn this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding)singleNameReference.binding);\t\t\t\t\r", "+\t\t\t}\r", "+\t\t} else if (node instanceof QualifiedSuperReference) {\r", "+\t\t\tQualifiedSuperReference qualifiedSuperReference = (QualifiedSuperReference) node;\r", "+\t\t\treturn this.getTypeBinding(qualifiedSuperReference.qualification.binding);\r", "+\t\t}\r", "+\t\treturn null;\r", "+\t}\r"]}], "num": 35812}