{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3d8945879d7fc4475f21a6c276cdfc41", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3ecf6cc12d09435a26c9a7b61f310c3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "67da1da15e9afbcd33679f07597c706e7915cf4a", "commitAfterChange": "027fccb2c17e0f0d2b28705c6704af10fc8ce0aa", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected void attachOrphanCompletionNode()", "signatureAfterChange": " protected void attachOrphanCompletionNode()", "diff": ["+\tif(assistNode == null) return;", "+\t", "-\tif ((!this.inMethodStack[this.inMethodPtr] && !this.inFieldInitializationStack[this.inFieldInitializationPtr])) { ", "+\tif ((!isInsideMethod() && !isInsideFieldInitialization())) { ", "-\tif (this.expressionPtr > -1 && containsCompletionNode(expression = this.expressionStack[this.expressionPtr])) {", "-\t\t/* check for completion at the beginning of method body", "-\t\t\tbehind an invalid signature", "-\t\t */", "-\t\tRecoveredMethod method = currentElement.enclosingMethod();", "-\t\tif (method != null){", "-\t\t\tAbstractMethodDeclaration methodDecl = method.methodDeclaration;", "-\t\t\tif ((methodDecl.bodyStart == methodDecl.sourceEnd+1) // was missing opening brace", "-\t\t\t\t&& (scanner.getLineNumber(expression.sourceStart) == scanner.getLineNumber(methodDecl.sourceEnd))){", "-\t\t\t\treturn;", "+\tif (this.expressionPtr > -1) {", "+\t\texpression = this.expressionStack[this.expressionPtr];", "+\t\tCompletionNodeDetector detector = new CompletionNodeDetector(assistNode, expression);", "+\t\tif(detector.containsCompletionNode()) {", "+\t\t\t/* check for completion at the beginning of method body", "+\t\t\t\tbehind an invalid signature", "+\t\t\t */", "+\t\t\tRecoveredMethod method = currentElement.enclosingMethod();", "+\t\t\tif (method != null){", "+\t\t\t\tAbstractMethodDeclaration methodDecl = method.methodDeclaration;", "+\t\t\t\tif ((methodDecl.bodyStart == methodDecl.sourceEnd+1) // was missing opening brace", "+\t\t\t\t\t&& (scanner.getLineNumber(expression.sourceStart) == scanner.getLineNumber(methodDecl.sourceEnd))){", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif(expression == assistNode", "+\t\t\t\t|| (expression instanceof AllocationExpression", "+\t\t\t\t\t&& ((AllocationExpression)expression).type == assistNode)){", "+\t\t\t\tbuildMoreCompletionContext(expression);", "+\t\t\t} else {", "+\t\t\t\tassistNodeParent = detector.getCompletionNodeParent();", "+\t\t\t\tif(assistNodeParent != null) {", "+\t\t\t\t\tcurrentElement = currentElement.add((Statement)assistNodeParent, 0);", "+\t\t\t\t} else {", "+\t\t\t\t\tcurrentElement = currentElement.add(expression, 0);", "+\t\t\t\t}", "-\t\tif (expression instanceof AllocationExpression) {", "-\t\t\t// keep the context if it is an allocation expression", "-\t\t\tStatement statement = (Statement)wrapWithExplicitConstructorCallIfNeeded(expression);", "-\t\t\tcurrentElement = currentElement.add(statement, 0);", "-\t\t} else {", "-\t\t\tStatement statement = (Statement)wrapWithExplicitConstructorCallIfNeeded(this.assistNode);", "-\t\t\tcurrentElement = currentElement.add(statement, 0);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f94ddcd20325ac0d11544fb9b3e80ff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "9ecb7eaa028f8fe11c4e3235ef672652805b58ee", "commitAfterChange": "e58bb12ba99b825db26f7a9c342525f2ccde5c31", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " private void buildMoreCompletionContext(Expression expression)", "signatureAfterChange": " private void buildMoreCompletionContext(Expression expression)", "diff": ["-\t\t\t\tif(expressionPtr > 0) {", "+\t\t\t\tif(expressionPtr > -1) {", "-\t\t\t\t\tswitch (info) {", "-\t\t\t\t\t\tcase AND_AND :", "-\t\t\t\t\t\t\toperatorExpression = new AND_AND_Expression(this.expressionStack[expressionPtr-1], expression, info);", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase OR_OR :", "-\t\t\t\t\t\t\toperatorExpression = new OR_OR_Expression(this.expressionStack[expressionPtr-1], expression, info);", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase EQUAL_EQUAL :", "-\t\t\t\t\t\tcase NOT_EQUAL :", "-\t\t\t\t\t\t\toperatorExpression = new EqualExpression(this.expressionStack[expressionPtr-1], expression, info);", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase INSTANCEOF :", "-\t\t\t\t\t\t\t// should never occur", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tdefault :", "-\t\t\t\t\t\t\toperatorExpression = new BinaryExpression(this.expressionStack[expressionPtr-1], expression, info);", "-\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\tExpression left = null;", "+\t\t\t\t\tif(expressionPtr == 0) {", "+\t\t\t\t\t\t// it is  a ***_NotName rule", "+\t\t\t\t\t\tif(this.identifierPtr > -1) {", "+\t\t\t\t\t\t\tleft = getUnspecifiedReferenceOptimized();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tleft = this.expressionStack[expressionPtr-1];", "+\t\t\t\t\t\t// is it a ***_NotName rule ?", "+\t\t\t\t\t\tif(this.identifierPtr > -1) {", "+\t\t\t\t\t\t\tint start = (int) (identifierPositionStack[this.identifierPtr] >>> 32);", "+\t\t\t\t\t\t\tif(left.sourceStart < start) {", "+\t\t\t\t\t\t\t\tleft = getUnspecifiedReferenceOptimized();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\tif(left != null) {", "+\t\t\t\t\t\tswitch (info) {", "+\t\t\t\t\t\t\tcase AND_AND :", "+\t\t\t\t\t\t\t\toperatorExpression = new AND_AND_Expression(left, expression, info);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase OR_OR :", "+\t\t\t\t\t\t\t\toperatorExpression = new OR_OR_Expression(left, expression, info);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase EQUAL_EQUAL :", "+\t\t\t\t\t\t\tcase NOT_EQUAL :", "+\t\t\t\t\t\t\t\toperatorExpression = new EqualExpression(left, expression, info);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase INSTANCEOF :", "+\t\t\t\t\t\t\t\t// should never occur", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\t\toperatorExpression = new BinaryExpression(left, expression, info);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}"]}], "num": 61755}