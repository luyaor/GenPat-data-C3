{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a25fc010a27749c0d118cb5cf04517d9", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a6484d3b064a05439a319260f66b080", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java", "commitBeforeChange": "b21d6f8f20d5a0613166092aaf1883f1403e1251", "commitAfterChange": "b3921c5eea6f0c6a7e0f7e9f7a3a4e8e611961a3", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedType)", "signatureAfterChange": "  \tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedType)", "diff": ["-\t\t\t\tTypeBinding exprType = expression instanceof ArrayInitializer", "+\t\t\t\tTypeBinding expressionType = expression instanceof ArrayInitializer", "-\t\t\t\tif (exprType == null)", "-\t\t\t\t\treturn null;", "+\t\t\t\tif (expressionType == null)", "+\t\t\t\t\tcontinue;", "-\t\t\t\tif (elementType != exprType) // must call before computeConversion() and typeMismatchError()", "-\t\t\t\t\tscope.compilationUnitScope().recordTypeConversion(elementType, exprType);", "+\t\t\t\tif (elementType != expressionType) // must call before computeConversion() and typeMismatchError()", "+\t\t\t\t\tscope.compilationUnitScope().recordTypeConversion(elementType, expressionType);", "-\t\t\t\tif ((expression.isConstantValueOfTypeAssignableToType(exprType, elementType)", "-\t\t\t\t\t\t|| (elementType.isBaseType() && BaseTypeBinding.isWidening(elementType.id, exprType.id)))", "-\t\t\t\t\t\t|| exprType.isCompatibleWith(elementType)) {", "-\t\t\t\t\texpression.computeConversion(scope, elementType, exprType);", "-\t\t\t\t} else if (scope.isBoxingCompatibleWith(exprType, elementType) ", "-\t\t\t\t\t\t\t\t\t|| (exprType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\tif ((expression.isConstantValueOfTypeAssignableToType(expressionType, elementType)", "+\t\t\t\t\t\t|| (elementType.isBaseType() && BaseTypeBinding.isWidening(elementType.id, expressionType.id)))", "+\t\t\t\t\t\t|| expressionType.isCompatibleWith(elementType)) {", "+\t\t\t\t\texpression.computeConversion(scope, elementType, expressionType);", "+\t\t\t\t} else if (scope.isBoxingCompatibleWith(expressionType, elementType) ", "+\t\t\t\t\t\t\t\t\t|| (expressionType.isBaseType()  // narrowing then boxing ?", "-\t\t\t\t\t\t\t\t\t\t\t&& expression.isConstantValueOfTypeAssignableToType(exprType, scope.environment().computeBoxingType(elementType)))) {", "-\t\t\t\t\texpression.computeConversion(scope, elementType, exprType);", "+\t\t\t\t\t\t\t\t\t\t\t&& expression.isConstantValueOfTypeAssignableToType(expressionType, scope.environment().computeBoxingType(elementType)))) {", "+\t\t\t\t\texpression.computeConversion(scope, elementType, expressionType);", "-\t\t\t\t\tscope.problemReporter().typeMismatchError(exprType, elementType, expression);", "-\t\t\t\t\treturn null;", "+\t\t\t\t\tscope.problemReporter().typeMismatchError(expressionType, elementType, expression);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ad4774de477738c441e95d71dbc38bf5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java", "commitBeforeChange": "ad30422de59b5093c5225e2a4599516c056303dc", "commitAfterChange": "c1c045ff9c256acaa6d98530fa4640b4cd80b7c6", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedTb)", "signatureAfterChange": "  \tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedType)", "diff": ["-\tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedTb) {", "+\tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedType) {", "-\t\t\tTypeBinding leafComponentType = expectedTb.leafComponentType();", "+\t\t\tTypeBinding leafComponentType = expectedType.leafComponentType();", "-\t\tif (expectedTb.isArrayType()) {", "-\t\t\tthis.resolvedType = this.binding = (ArrayBinding) expectedTb;", "-\t\t\tif (expressions == null)", "-\t\t\t\treturn binding;", "-\t\t\tTypeBinding expectedElementsTb = binding.elementsType();", "-\t\t\tif (expectedElementsTb.isBaseType()) {", "-\t\t\t\tfor (int i = 0, length = expressions.length; i < length; i++) {", "-\t\t\t\t\tExpression expression = expressions[i];", "-\t\t\t\t\tTypeBinding expressionTb =", "-\t\t\t\t\t\t(expression instanceof ArrayInitializer)", "-\t\t\t\t\t\t\t? expression.resolveTypeExpecting(scope, expectedElementsTb)", "-\t\t\t\t\t\t\t: expression.resolveType(scope);", "-\t\t\t\t\tif (expressionTb == null)", "-\t\t\t\t\t\treturn null;", "-\t", "-\t\t\t\t\t// Compile-time conversion required?", "-\t\t\t\t\tif (expectedElementsTb != expressionTb) // must call before computeConversion() and typeMismatchError()", "-\t\t\t\t\t\tscope.compilationUnitScope().recordTypeConversion(expectedElementsTb, expressionTb);", "-\t\t\t\t\tif (expression.isConstantValueOfTypeAssignableToType(expressionTb, expectedElementsTb)", "-\t\t\t\t\t\t|| BaseTypeBinding.isWidening(expectedElementsTb.id, expressionTb.id)", "-\t\t\t\t\t\t|| scope.isBoxingCompatibleWith(expressionTb, expectedElementsTb)) {", "-\t\t\t\t\t\t\texpression.computeConversion(scope, expectedElementsTb, expressionTb);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tscope.problemReporter().typeMismatchError(expressionTb, expectedElementsTb, expression);", "-\t\t\t\t\t\treturn null;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tfor (int i = 0, length = expressions.length; i < length; i++)", "-\t\t\t\t\tif (expressions[i].resolveTypeExpecting(scope, expectedElementsTb) == null)", "-\t\t\t\t\t\treturn null;", "+\t\tif (expectedType.isArrayType()) {", "+\t\t\tthis.resolvedType = this.binding = (ArrayBinding) expectedType;", "+\t\t\tif (this.expressions == null)", "+\t\t\t\treturn this.binding;", "+\t\t\tTypeBinding elementType = this.binding.elementsType();", "+\t\t\tfor (int i = 0, length = expressions.length; i < length; i++) {", "+\t\t\t\tExpression expression = expressions[i];", "+\t\t\t\tTypeBinding exprType = expression instanceof ArrayInitializer", "+\t\t\t\t\t\t? expression.resolveTypeExpecting(scope, elementType)", "+\t\t\t\t\t\t: expression.resolveType(scope);", "+\t\t\t\tif (exprType == null)", "+\t\t\t\t\treturn null;", "+", "+\t\t\t\t// Compile-time conversion required?", "+\t\t\t\tif (elementType != exprType) // must call before computeConversion() and typeMismatchError()", "+\t\t\t\t\tscope.compilationUnitScope().recordTypeConversion(elementType, exprType);", "+", "+\t\t\t\tif ((expression.isConstantValueOfTypeAssignableToType(exprType, elementType)", "+\t\t\t\t\t\t|| (elementType.isBaseType() && BaseTypeBinding.isWidening(elementType.id, exprType.id)))", "+\t\t\t\t\t\t|| exprType.isCompatibleWith(elementType)) {", "+\t\t\t\t\texpression.computeConversion(scope, elementType, exprType);", "+\t\t\t\t} else if (scope.isBoxingCompatibleWith(exprType, elementType) ", "+\t\t\t\t\t\t\t\t\t|| (exprType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t\t\t\t\t&& !elementType.isBaseType()", "+\t\t\t\t\t\t\t\t\t\t\t&& expression.isConstantValueOfTypeAssignableToType(exprType, scope.environment().computeBoxingType(elementType)))) {", "+\t\t\t\t\texpression.computeConversion(scope, elementType, exprType);", "+\t\t\t\t} else {", "+\t\t\t\t\tscope.problemReporter().typeMismatchError(exprType, elementType, expression);", "+\t\t\t\t\treturn null;", "+\t\t\t\t} \t\t\t\t", "-\t\t\tscope.problemReporter().typeMismatchError(probableTb, expectedTb, this);", "+\t\t\tscope.problemReporter().typeMismatchError(probableTb, expectedType, this);"]}], "num": 40539}