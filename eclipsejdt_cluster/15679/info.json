{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ba2bfba84110a5789c94a0d63c8dc2b0", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2e7e21b57e5fbbfe418a4e23ff94cdd4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "31225f931c10340b8616c3f4ecc6725f368df84c", "commitAfterChange": "86bc6fbd8bb61b3353c5beacb63fca5b9ddef84a", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": "  \tprivate int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site)", "signatureAfterChange": "  \tprivate int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site)", "diff": ["-\t\tif (site instanceof Invocation) {", "+\t\tjdk18checks:", "+\t\tif (site instanceof Invocation && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_8) {", "-\t\t\t\tboolean isVarArgs = argLen != method.parameters.length; // if same lengths, isVarArgs can still be updated below", "+\t\t\t\tboolean isVarArgs[] = new boolean[1]; // emulate an in-out parameter for compatibilityLevel18FromInner(..)", "+\t\t\t\tisVarArgs[0] = method.isVarargs() && argLen != method.parameters.length; // if same lengths, isVarArgs can still be updated below", "+\t\t\t\tint level = COMPATIBLE;", "-\t\t\t\t\tExpression invocArg = invocationArguments[i];", "-\t\t\t\t\tif (invocArg instanceof Invocation && invocArg.resolvedType != null) { // TODO any poly? ReferenceExpression?", "-\t\t\t\t\t\tInvocation innerPoly = (Invocation) invocArg;", "-\t\t\t\t\t\tTypeBinding resolvedType = invocArg.resolvedType;", "-\t\t\t\t\t\tTypeBinding targetType = InferenceContext18.getParameter(method.parameters, i, isVarArgs);", "-\t\t\t\t\t\tif (!isVarArgs && shouldTryVarargs(method, resolvedType, targetType)) {", "-\t\t\t\t\t\t\tisVarArgs = true;", "-\t\t\t\t\t\t\ttargetType = InferenceContext18.getParameter(method.parameters, i, true);", "+\t\t\t\t\tint nextLevel = compatibilityLevel18FromInner(method, innerInferenceHelper, invocationArguments[i], argLen, i, isVarArgs);", "+\t\t\t\t\tif (nextLevel == NOT_COMPATIBLE)", "+\t\t\t\t\t\treturn nextLevel;", "+\t\t\t\t\tif (nextLevel == -2)", "+\t\t\t\t\t\tbreak jdk18checks;", "+\t\t\t\t\tlevel = Math.max(level,  nextLevel);", "+\t\t\t\t}", "+\t\t\t\treturn level; // neither NOT_COMPATIBLE nor unknown(-2) seen", "+\t\t\t}", "+\t\t}", "+\t\t// fall back to old method:", "+\t\treturn parameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods);", "+\t}", "-\t\t\t\t\t\tif (!resolvedType.isCompatibleWith(targetType, this)) {", "-\t\t\t\t\t\t\tMethodBinding innerBinding = innerPoly.binding(null); // 1. try without update", "-\t\t\t\t\t\t\tif (innerBinding instanceof ParameterizedGenericMethodBinding) {", "-\t\t\t\t\t\t\t\tParameterizedGenericMethodBinding innerParameterized = (ParameterizedGenericMethodBinding) innerBinding;", "-\t\t\t\t\t\t\t\tInferenceContext18 infCtx18 = innerPoly.getInferenceContext(innerParameterized);", "-\t\t\t\t\t\t\t\tif (infCtx18 != null && !infCtx18.hasResultFor(targetType)) {", "-\t\t\t\t\t\t\t\t\t// not detected as compatible, because inference still needs to complete?", "-\t\t\t\t\t\t\t\t\tinvocArg.setExpectedType(targetType);", "-\t\t\t\t\t\t\t\t\tMethodBinding solution = infCtx18.inferInvocationType(innerPoly, innerParameterized);", "-\t\t\t\t\t\t\t\t\tif (solution != null && solution.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\t\tif (innerPoly.updateBindings(solution, targetType)) {", "-\t\t\t\t\t\t\t\t\t\t\tif (innerInferenceHelper != null)", "-\t\t\t\t\t\t\t\t\t\t\t\tinnerInferenceHelper.registerInnerResult(method, invocArg.resolvedType, argLen, i);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tif (solution.returnType != null && solution.returnType.isCompatibleWith(targetType, this))", "-\t\t\t\t\t\t\t\t\t\t\treturn isVarArgs ? VARARGS_COMPATIBLE : COMPATIBLE;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn NOT_COMPATIBLE;", "-\t\t\t\t\t\t\t\t} else if (innerPoly instanceof AllocationExpression) {", "-\t\t\t\t\t\t\t\t\t// not detected as compatible, because its a diamond whose type hasn't yet been inferred?", "-\t\t\t\t\t\t\t\t\tTypeBinding[] typeArguments = resolvedType.typeArguments();", "-\t\t\t\t\t\t\t\t\tif (typeArguments != null && typeArguments.length == 0) {", "-\t\t\t\t\t\t\t\t\t\tAllocationExpression alloc = (AllocationExpression) innerPoly;", "-\t\t\t\t\t\t\t\t\t\tif ((alloc.type.bits & ASTNode.IsDiamond) != 0) {", "-\t\t\t\t\t\t\t\t\t\t\t// not-yet-inferred diamond: erasure compatibility should suffice, detail will be checked using inference", "-\t\t\t\t\t\t\t\t\t\t\tif (invocArg.resolvedType.isCompatibleWith(targetType.erasure(), this))", "-\t\t\t\t\t\t\t\t\t\t\t\treturn COMPATIBLE;", "-\t\t\t\t\t\t\t\t\t\t\treturn NOT_COMPATIBLE;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (innerPoly instanceof AllocationExpression) {", "-\t\t\t\t\t\t\t\tMethodBinding updatedMethod = innerPoly.binding(targetType); // 2. try with updating", "-\t\t\t\t\t\t\t\tif (updatedMethod != innerBinding && updatedMethod != null && updatedMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tif (updatedMethod.declaringClass.isCompatibleWith(targetType))", "-\t\t\t\t\t\t\t\t\t\treturn COMPATIBLE;", "-\t\t\t\t\t\t\t\t\treturn NOT_COMPATIBLE;", "-\t\t\t\t\t\t\t\t}", "-\t\treturn parameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "42d7b2fbfe8f961b558628e0bf2320b0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "354ebb443c1299f35a4e7d9feb7df720666960e5", "commitAfterChange": "f5d7f3f14e69a955635d98e0e88aeb491988cae5", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 64, "signatureBeforeChange": "  \tpublic boolean registerSolution(TypeBinding targetType, MethodBinding updatedBinding)", "signatureAfterChange": "  \tpublic void forwardResults(BoundSet result, Invocation invocation, ParameterizedMethodBinding pmb, TypeBinding targetType)", "diff": ["-", "-\tpublic boolean registerSolution(TypeBinding targetType, MethodBinding updatedBinding) {", "-\t\tSolution solution = this.solutionsPerTargetType.get(targetType);", "-\t\tif (solution != null)", "-\t\t\treturn false; // no update", "-\t\tthis.solutionsPerTargetType.put(targetType, new Solution(updatedBinding, null));", "-\t\tthis.stepCompleted = Math.max(this.stepCompleted, TYPE_INFERRED);", "-\t\treturn true;", "+", "+\tpublic void forwardResults(BoundSet result, Invocation invocation, ParameterizedMethodBinding pmb, TypeBinding targetType) {", "+\t\tif (targetType != null)", "+\t\t\tinvocation.registerResult(targetType, pmb);", "+\t\tExpression[] arguments = invocation.arguments();", "+\t\tfor (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {", "+\t\t\tExpression [] expressions = arguments[i].getPolyExpressions();", "+\t\t\tfor (int j = 0, jLength = expressions.length; j < jLength; j++) {", "+\t\t\t\tExpression expression = expressions[j];", "+\t\t\t\tif (!(expression instanceof Invocation))", "+\t\t\t\t\tcontinue;", "+\t\t\t\tInvocation polyInvocation = (Invocation) expression;", "+\t\t\t\tMethodBinding binding = polyInvocation.binding();", "+\t\t\t\tif (binding == null || !binding.isValidBinding())", "+\t\t\t\t\tcontinue;", "+\t\t\t\tParameterizedMethodBinding methodSubstitute = null;", "+\t\t\t\tif (binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\t\tMethodBinding shallowOriginal = binding.shallowOriginal();", "+\t\t\t\t\tTypeBinding[] solutions = getSolutions(shallowOriginal.typeVariables(), polyInvocation, result);", "+\t\t\t\t\tif (solutions == null)  // in CEF.reduce, we lift inner poly expressions into outer context only if their target type has inference variables. ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tmethodSubstitute = this.environment.createParameterizedGenericMethod(shallowOriginal, solutions);", "+\t\t\t\t} else {", "+\t\t\t\t\tif (!binding.isConstructor() || !(binding instanceof ParameterizedMethodBinding))", "+\t\t\t\t\t\tcontinue; // throw ISE ?", "+\t\t\t\t\tMethodBinding shallowOriginal = binding.shallowOriginal();", "+\t\t\t\t\tReferenceBinding genericType = shallowOriginal.declaringClass;", "+\t\t\t\t\tTypeBinding[] solutions = getSolutions(genericType.typeVariables(), polyInvocation, result);", "+\t\t\t\t\tif (solutions == null)  // in CEF.reduce, we lift inner poly expressions into outer context only if their target type has inference variables. ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tParameterizedTypeBinding parameterizedType = this.environment.createParameterizedType(genericType, solutions, binding.declaringClass.enclosingType());", "+\t\t\t\t\tfor (MethodBinding parameterizedMethod : parameterizedType.methods()) {", "+\t\t\t\t\t\tif (parameterizedMethod.original() == shallowOriginal) {", "+\t\t\t\t\t\t\tmethodSubstitute = (ParameterizedMethodBinding) parameterizedMethod;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (methodSubstitute == null || !methodSubstitute.isValidBinding())", "+\t\t\t\t\tcontinue;", "+\t\t\t\tboolean variableArity = pmb.isVarargs();", "+\t\t\t\tfinal TypeBinding[] parameters = pmb.parameters;", "+\t\t\t\tif (variableArity && parameters.length == arguments.length && i == length - 1) {", "+\t\t\t\t\tTypeBinding returnType = methodSubstitute.returnType.capture(this.scope, expression.sourceStart, expression.sourceEnd);", "+\t\t\t\t\tif (returnType.isCompatibleWith(parameters[parameters.length - 1], this.scope)) {", "+\t\t\t\t\t\tvariableArity = false;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tTypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);", "+\t\t\t\tforwardResults(result, polyInvocation, methodSubstitute, parameterType);\t\t", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a7c3085cf400bcc6f7e2bf0bfa07fe2d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "09f42f58bcdf2fa84ccd2b8b65f28ab3036222ca", "commitAfterChange": "57e8dd41219d846363c918d62edb5007994c5c79", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tprivate int myParameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site)", "signatureAfterChange": "  \tprivate int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site)", "diff": ["-\t// FIXME(stephan): final integration into the code", "-\tprivate int myParameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site) {", "+\tprivate int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site) {", "-\t\t\tif (((Invocation) site).inferenceKind() > 0)", "-\t\t\t\treturn COMPATIBLE; // inference is responsible, no need to recheck", "+\t\t\tInvocation invocation = (Invocation) site;", "+\t\t\tif (method instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\tInferenceContext18 infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);", "+\t\t\t\tif (infCtx != null)", "+\t\t\t\t\treturn COMPATIBLE; // inference is responsible, no need to recheck", "+\t\t\t}", "+\t\t\t// collect inner invocations where the outer did not involve any inference:", "+\t\t\tExpression[] invocationArguments = invocation.arguments();", "+\t\t\tif (invocationArguments != null) {", "+\t\t\t\tint argLen = invocationArguments.length;", "+\t\t\t\tboolean isVarArgs = false;", "+\t\t\t\tfor (int i = 0; i < argLen; i++) {", "+\t\t\t\t\tExpression invocArg = invocationArguments[i];", "+\t\t\t\t\tif (invocArg instanceof Invocation && invocArg.resolvedType != null) { // TODO any poly? ReferenceExpression?", "+\t\t\t\t\t\tInvocation innerPoly = (Invocation) invocArg;", "+\t\t\t\t\t\tTypeBinding targetType = InferenceContext18.getParameter(method.parameters, i, false);", "+\t\t\t\t\t\tif (targetType == null && method.isVarargs()) {", "+\t\t\t\t\t\t\tisVarArgs = true;", "+\t\t\t\t\t\t\ttargetType = InferenceContext18.getParameter(method.parameters, i, true);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tTypeBinding resolvedType = invocArg.resolvedType; ", "+\t\t\t\t\t\tif (!resolvedType.isCompatibleWith(targetType, this)) {", "+\t\t\t\t\t\t\tMethodBinding innerBinding = innerPoly.binding();", "+\t\t\t\t\t\t\tif (innerBinding instanceof ParameterizedGenericMethodBinding) { // FIXME: does this happen?", "+\t\t\t\t\t\t\t\tInferenceContext18 infCtx18 = innerPoly.getInferenceContext((ParameterizedGenericMethodBinding) innerBinding);", "+\t\t\t\t\t\t\t\tif (infCtx18 != null) {", "+\t\t\t\t\t\t\t\t\t// not detected as compatible, because inference still needs to complete?", "+\t\t\t\t\t\t\t\t\tMethodBinding solution = infCtx18.getInvocationTypeInferenceSolution(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinnerPoly.binding().original(), innerPoly, targetType);", "+\t\t\t\t\t\t\t\t\tif (solution != null) {", "+\t\t\t\t\t\t\t\t\t\tif (solution.returnType != null && solution.returnType.isCompatibleWith(targetType, this))", "+\t\t\t\t\t\t\t\t\t\t\treturn isVarArgs ? VARARGS_COMPATIBLE : COMPATIBLE;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tMethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(targetType, innerPoly.binding());", "+\t\t\t\t\t\t\t\t\t\tif (problemMethod != null && problemMethod.isValidBinding())", "+\t\t\t\t\t\t\t\t\t\t\treturn COMPATIBLE;", "+\t\t\t\t\t\t\t\t\t\treturn NOT_COMPATIBLE;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else if (innerPoly instanceof AllocationExpression) {", "+\t\t\t\t\t\t\t\t\t// not detected as compatible, because its a diamond whose type hasn't yet been inferred?", "+\t\t\t\t\t\t\t\t\tTypeBinding[] typeArguments = resolvedType.typeArguments();", "+\t\t\t\t\t\t\t\t\tif (typeArguments != null && typeArguments.length == 0) {", "+\t\t\t\t\t\t\t\t\t\tAllocationExpression alloc = (AllocationExpression) innerPoly;", "+\t\t\t\t\t\t\t\t\t\tif ((alloc.type.bits & ASTNode.IsDiamond) != 0) {", "+\t\t\t\t\t\t\t\t\t\t\t// not-yet-inferred diamond: erasure compatibility should suffice, detail will be checked using inference", "+\t\t\t\t\t\t\t\t\t\t\tif (invocArg.resolvedType.isCompatibleWith(targetType.erasure(), this))", "+\t\t\t\t\t\t\t\t\t\t\t\treturn COMPATIBLE;", "+\t\t\t\t\t\t\t\t\t\t\treturn NOT_COMPATIBLE;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 15679}