{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "69c96b666a345de82a36d215df464e1b", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "129b6145f377e463943b339a3b1b4ccc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5ea56603dc1ee6ae8d60e4a5ed0d457e4e0823e2", "commitAfterChange": "985aba49ffb0849a1927eddcbca9cdac39c5c825", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\tboolean receiverTypeIsInterface = receiverType.isInterface();", "-\t\tif (currentType.isInterface()) {", "-\t\t\tunitScope.recordTypeReference(currentType);", "-\t\t\tMethodBinding[] currentMethods = currentType.getMethods(selector);", "-\t\t\tif (currentMethods.length > 0)", "-\t\t\t\tfound.addAll(currentMethods);", "-\t\t\tfindMethodInSuperInterfaces(currentType, selector, found);", "+\t\tif (receiverTypeIsInterface) {", "+\t\t\tunitScope.recordTypeReference(receiverType);", "+\t\t\tMethodBinding[] receiverMethods = receiverType.getMethods(selector);", "+\t\t\tif (receiverMethods.length > 0)", "+\t\t\t\tfound.addAll(receiverMethods);", "+\t\t\tfindMethodInSuperInterfaces(receiverType, selector, found);", "-\t\tboolean mustBePublic = receiverType.isInterface();", "-\t\t\t\tif (isCompliant14 && (mustBePublic || found.size > 0)) {", "+\t\t\t\tif (isCompliant14 && (receiverTypeIsInterface || found.size > 0)) {", "-\t\t\t\t\t\tif (mustBePublic && !currentMethod.isPublic()) { // only public methods from Object are visible to interface receiverTypes", "+\t\t\t\t\t\tif (receiverTypeIsInterface && !currentMethod.isPublic()) { // only public methods from Object are visible to interface receiverTypes", "+\t\tboolean searchForDefaultAbstractMethod = isCompliant14 && ! receiverTypeIsInterface && (receiverType.isAbstract() || receiverType.isTypeVariable());", "-\t\t\t\t\t\t\tif (isCompliant14 && (receiverType.isAbstract() || receiverType.isTypeVariable()))", "+\t\t\t\t\t\t\tif (searchForDefaultAbstractMethod)", "-\t\t// no match was found, try to find a close match when the parameter order is wrong or missing some parameters", "+\t\t// no match was found", "-\t\t\t// reduces secondary errors since missing interface method error is already reported", "+\t\t\t// abstract classes may get a match in interfaces; for non abstract", "+\t\t\t// classes, reduces secondary errors since missing interface method ", "+\t\t\t// error is already reported", "+", "+\t\t\t// still no match; try to find a close match when the parameter ", "+\t\t\t// order is wrong or missing some parameters", "-\t\tfor (int i = 0; i < candidatesCount; i++) {", "-\t\t\tMethodBinding methodBinding = candidates[i];", "-\t\t\tif (methodBinding.canBeSeenBy(receiverType, invocationSite, this)) {", "-\t\t\t\tif (visiblesCount != i) {", "-\t\t\t\t\tcandidates[i] = null;", "-\t\t\t\t\tcandidates[visiblesCount] = methodBinding;", "-\t\t\t\t}", "-\t\t\t\tvisiblesCount++;", "+\t\tif (receiverTypeIsInterface) {", "+\t\t\tif (candidatesCount == 1) {", "+\t\t\t\tunitScope.recordTypeReferences(candidates[0].thrownExceptions);", "+\t\t\t\treturn candidates[0];", "-\t\t}", "-\t\tif (visiblesCount == 1) {", "-\t\t\tif (isCompliant14 && (receiverType.isAbstract() || receiverType.isTypeVariable()))", "-\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, candidates[0]);", "-\t\t\tunitScope.recordTypeReferences(candidates[0].thrownExceptions);", "-\t\t\treturn candidates[0];", "-\t\t}", "-\t\tif (visiblesCount == 0) {", "-\t\t\tMethodBinding interfaceMethod =", "-\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, null);", "-\t\t\tif (interfaceMethod != null) return interfaceMethod;", "-\t\t\treturn new ProblemMethodBinding(candidates[0], candidates[0].selector, candidates[0].parameters, ProblemReasons.NotVisible);", "+\t\t\tvisiblesCount = candidatesCount;", "+\t\t} else {", "+\t\t\tfor (int i = 0; i < candidatesCount; i++) {", "+\t\t\t\tMethodBinding methodBinding = candidates[i];", "+\t\t\t\tif (methodBinding.canBeSeenBy(receiverType, invocationSite, this)) {", "+\t\t\t\t\tif (visiblesCount != i) {", "+\t\t\t\t\t\tcandidates[i] = null;", "+\t\t\t\t\t\tcandidates[visiblesCount] = methodBinding;", "+\t\t\t\t\t}", "+\t\t\t\t\tvisiblesCount++;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (visiblesCount == 1) {", "+\t\t\t\tif (searchForDefaultAbstractMethod)", "+\t\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, candidates[0]);", "+\t\t\t\tunitScope.recordTypeReferences(candidates[0].thrownExceptions);", "+\t\t\t\treturn candidates[0];", "+\t\t\t}", "+\t\t\tif (visiblesCount == 0) {", "+\t\t\t\tMethodBinding interfaceMethod =", "+\t\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, null);", "+\t\t\t\tif (interfaceMethod != null) return interfaceMethod;", "+\t\t\t\treturn new ProblemMethodBinding(candidates[0], candidates[0].selector, candidates[0].parameters, ProblemReasons.NotVisible);", "+\t\t\t}", "-\t\tif (isCompliant15", "-\t\t\t&& mostSpecificMethod.isValidBinding()", "-\t\t\t&& parameterCompatibilityLevel(mostSpecificMethod, argumentTypes) > COMPATIBLE) {", "-\t\t\t\t// see if there is a better match in the interfaces - see AutoBoxingTest 99", "+\t\tif (searchForDefaultAbstractMethod) { // search interfaces for a better match", "+\t\t\tif (mostSpecificMethod.isValidBinding())", "+\t\t\t\t// see if there is a better match in the interfaces - see AutoBoxingTest 99, LookupTest#81", "+\t\t\t// see if there is a match in the interfaces - see LookupTest#84", "+\t\t\tMethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, null);", "+\t\t\tif (interfaceMethod != null && interfaceMethod.isValidBinding() /* else return the same error as before */)", "+\t\t\t\treturn interfaceMethod;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94aa037aaf7a207117372b73056304a3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "e0ebad67303a47fa3ab9d8532c92ffc60ae916e2", "commitAfterChange": "6940f5238f5f044dc7dc7f5472f64a2c5617a365", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["+\tboolean diamondNeedsDeferring = false;", "+\tlong sourceLevel = compilerOptions.sourceLevel;", "-\t\t\tif (isDiamond && this.typeExpected == null && this.expressionContext == INVOCATION_CONTEXT && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\tif (isDiamond && this.typeExpected == null && this.expressionContext == INVOCATION_CONTEXT && sourceLevel >= ClassFileConstants.JDK1_8) {", "-\t\t\t\t\treturn new PolyTypeBinding(this);", "+\t\t\t\t\tdiamondNeedsDeferring = true;", "-\t\tboolean argHasError = compilerOptions.sourceLevel < ClassFileConstants.JDK1_5;", "+\t\tboolean argHasError = sourceLevel < ClassFileConstants.JDK1_5;", "-\t\tTypeBinding argumentType;", "-\t\t\tif ((argumentType = argumentTypes[i] = argument.resolveType(scope)) == null) {", "+\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null) {", "-\t\t\tif (argumentType != null && argumentType.kind() == Binding.POLY_TYPE)", "+\t\t\tif (sourceLevel >= ClassFileConstants.JDK1_8 && argument.isPolyExpression())", "-\tif (isDiamond) {", "-\t\tTypeBinding [] inferredTypes = inferElidedTypes(((ParameterizedTypeBinding) this.resolvedType).genericType(), null, argumentTypes, scope);", "+\tif (isDiamond && !diamondNeedsDeferring) {", "+\t\tReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();", "+\t\tTypeBinding [] inferredTypes = inferElidedTypes(genericType, genericType.enclosingType(), argumentTypes, scope);", "-\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\tReferenceBinding receiverType = (ReferenceBinding) this.resolvedType;", "+\tif (diamondNeedsDeferring) {", "+\t\t// in this preliminary mode use the raw receiver type for constructor lookup, to avoid spurious type errors", "+\t\treceiverType = (ReferenceBinding) receiverType.original();", "+\t\treceiverType = scope.environment().createRawType(receiverType, receiverType.enclosingType());", "+\t\tthis.inferenceKind = 1; // inference needed!", "+\t}", "+\tthis.binding = findConstructorBinding(scope, this, receiverType, argumentTypes, polyExpressionSeen);", "+", "-\tthis.binding = scope.getConstructor(allocationType, argumentTypes, this);", "-\tif (polyExpressionSeen) ", "-\t\tresolvePolyExpressionArguments(scope, this.binding, this.arguments, argumentTypes);", "-\t", "-\tif (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, argumentTypes, argsContainCast, this)) {", "-\t\tthis.bits |= ASTNode.Unchecked;", "+\tif (!diamondNeedsDeferring) { // don't check diamonds before we have the target type", "+\t\tif (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, argumentTypes, argsContainCast, this)) {", "+\t\t\tthis.bits |= ASTNode.Unchecked;", "+\t\t}", "- \t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, null, argumentTypes, scope);", "+ \t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), argumentTypes, scope);"]}], "num": 67680}