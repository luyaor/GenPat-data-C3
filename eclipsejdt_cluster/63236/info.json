{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4db9bef1251d22cddd696c5532c04b08", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0985a9451b337c623b54ce69446f2ac8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java", "commitBeforeChange": "2daf63d08a96c2ed6e0e08ccfe89195f55d9f8ce", "commitAfterChange": "b4d3f967db596bbe85e51e090676967f450c3332", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     @Override     public TypeMirror asMemberOf(DeclaredType containing, Element element)", "signatureAfterChange": "     @Override     public TypeMirror asMemberOf(DeclaredType containing, Element element)", "diff": ["-        throw new UnsupportedOperationException(\"NYI: TypesImpl.asMemberOf(\" + containing + \", \" + element + \")\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$", "+//        throw new UnsupportedOperationException(\"NYI: TypesImpl.asMemberOf(\" + containing + \", \" + element + \")\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$", "+    \tElementImpl elementImpl = (ElementImpl) element;", "+    \tDeclaredTypeImpl declaredTypeImpl = (DeclaredTypeImpl) containing;", "+    \tReferenceBinding referenceBinding = (ReferenceBinding) declaredTypeImpl._binding;", "+    \tswitch(element.getKind()) {", "+    \t\tcase CONSTRUCTOR :", "+    \t\tcase METHOD :", "+    \t\t\tMethodBinding methodBinding = (MethodBinding) elementImpl._binding;", "+    \t\t\tif (methodBinding.declaringClass != referenceBinding) {", "+    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "+    \t\t\t}", "+    \t\t\tfor (MethodBinding method : referenceBinding.methods()) {", "+    \t\t\t\tif (CharOperation.equals(method.selector, methodBinding.selector)", "+    \t\t\t\t\t\t&& method.areParameterErasuresEqual(methodBinding)) {", "+    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(method);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tbreak;", "+    \t\tcase FIELD :", "+    \t\t\tFieldBinding fieldBinding = (FieldBinding) elementImpl._binding;", "+    \t\t\tif (fieldBinding.declaringClass != referenceBinding) {", "+    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "+    \t\t\t}", "+    \t\t\tfor (FieldBinding field : referenceBinding.fields()) {", "+    \t\t\t\tif (CharOperation.equals(field.name, fieldBinding.name)) {", "+    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(field);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tbreak;", "+    \t\tcase ENUM :", "+    \t\tcase ANNOTATION_TYPE :", "+    \t\tcase INTERFACE :", "+    \t\tcase CLASS :", "+    \t\t\tReferenceBinding referenceBinding2 = (ReferenceBinding) elementImpl._binding;", "+    \t\t\tif (referenceBinding2.enclosingType() != referenceBinding) {", "+    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "+    \t\t\t}", "+    \t\t\tfor (ReferenceBinding referenceBinding3 : referenceBinding.memberTypes()) {", "+    \t\t\t\tif (CharOperation.equals(referenceBinding3.compoundName, referenceBinding3.compoundName)) {", "+    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(referenceBinding3);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tbreak;", "+    \t}", "+\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6a0521379605c9d1bb102ee0fa8eb184", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java", "commitBeforeChange": "e254cb1235fced696c16505589db91831c0df710", "commitAfterChange": "fdf4380d8dd2e7b1f08462c3e15a52a8d6142eb4", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     @Override     public TypeMirror asMemberOf(DeclaredType containing, Element element)", "signatureAfterChange": "      @Override     public TypeMirror asMemberOf(DeclaredType containing, Element element)", "diff": ["-     */", "-    \t\t\tif (TypeBinding.notEquals(methodBinding.declaringClass, referenceBinding)) {", "-    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "-    \t\t\t}", "-    \t\t\tfor (MethodBinding method : referenceBinding.methods()) {", "-    \t\t\t\tif (CharOperation.equals(method.selector, methodBinding.selector)", "-    \t\t\t\t\t\t&& method.areParameterErasuresEqual(methodBinding)) {", "-    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(method);", "-    \t\t\t\t}", "-    \t\t\t}", "+    \t\t\twhile (referenceBinding != null) {", "+                    for (MethodBinding method : referenceBinding.methods()) {", "+                        if (CharOperation.equals(method.selector, methodBinding.selector)", "+                                && method.areParameterErasuresEqual(methodBinding)) {", "+                            return this._env.getFactory().newTypeMirror(method);", "+                        }", "+                    }", "+                    referenceBinding = referenceBinding.superclass();", "+                }", "-    \t\t\tif (TypeBinding.notEquals(fieldBinding.declaringClass, referenceBinding)) {", "-    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "-    \t\t\t}", "-    \t\t\tfor (FieldBinding field : referenceBinding.fields()) {", "-    \t\t\t\tif (CharOperation.equals(field.name, fieldBinding.name)) {", "-    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(field);", "-    \t\t\t\t}", "-    \t\t\t}", "+                while (referenceBinding != null) {", "+                    for (FieldBinding field : referenceBinding.fields()) {", "+                        if (CharOperation.equals(field.name, fieldBinding.name)) {", "+                            return this._env.getFactory().newTypeMirror(field);", "+                        }", "+                    }", "+                    referenceBinding = referenceBinding.superclass();", "+                }", "-    \t\t\tReferenceBinding referenceBinding2 = (ReferenceBinding) elementImpl._binding;", "-    \t\t\tif (TypeBinding.notEquals(referenceBinding2.enclosingType(), referenceBinding)) {", "-    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "-    \t\t\t}", "-    \t\t\tfor (ReferenceBinding referenceBinding3 : referenceBinding.memberTypes()) {", "-    \t\t\t\tif (CharOperation.equals(referenceBinding3.compoundName, referenceBinding3.compoundName)) {", "-    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(referenceBinding3);", "-    \t\t\t\t}", "-    \t\t\t}", "+    \t\t\tReferenceBinding elementBinding = (ReferenceBinding) elementImpl._binding;", "+                while (referenceBinding != null) {", "+                    // If referenceBinding is a ParameterizedTypeBinding, this will return only ParameterizedTypeBindings", "+                    // for member types, even if the member happens to be a static nested class. That's probably a bug;", "+                    // static nested classes are not parameterized by their outer class.", "+                    for (ReferenceBinding memberReferenceBinding : referenceBinding.memberTypes()) {", "+                        if (CharOperation.equals(elementBinding.compoundName, memberReferenceBinding.compoundName)) {", "+                            return this._env.getFactory().newTypeMirror(memberReferenceBinding);", "+                        }", "+                    }", "+                    referenceBinding = referenceBinding.superclass();", "+                }", "-    \t\t\tbreak;", "-    \t}", "-\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type: element kind \" + element.getKind()); //$NON-NLS-1$", "+                throw new IllegalArgumentException(\"element \" + element + //$NON-NLS-1$", "+                        \" has unrecognized element kind \" + element.getKind()); //$NON-NLS-1$", "+            }", "+            throw new IllegalArgumentException(\"element \" + element + //$NON-NLS-1$", "+                    \" is not a member of the containing type \" + containing +  //$NON-NLS-1$", "+                    \" nor any of its superclasses\"); //$NON-NLS-1$"]}], "num": 63236}