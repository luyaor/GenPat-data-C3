{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "98669f78e5ac03e45c4f83c2eb60a4f7", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2b8fd9aa5c56ce38ed5e96e4fc44cc08", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "a38d26ea4f2f03195744026af44f070900d21cea", "commitAfterChange": "72578ba43287462a0c91a7de026e07610ac80a95", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " boolean isInterfaceMethodImplemented(MethodBinding inheritedMethod, MethodBinding existingMethod, ReferenceBinding superType)", "signatureAfterChange": " boolean isInterfaceMethodImplemented(MethodBinding inheritedMethod, MethodBinding existingMethod, ReferenceBinding superType)", "diff": ["-\t\t&& (inheritedMethod.returnType == existingMethod.returnType\t// need to keep around to produce bridge methods? ...", "-\t\t\t|| (this.type != existingMethod.declaringClass \t\t\t// ... not if inheriting the bridge situation from a superclass", "+\t\t&& (TypeBinding.equalsEquals(inheritedMethod.returnType, existingMethod.returnType)\t// need to keep around to produce bridge methods? ...", "+\t\t\t|| (TypeBinding.notEquals(this.type, existingMethod.declaringClass) \t\t\t// ... not if inheriting the bridge situation from a superclass"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a1ec7d800d69a820e9e1e2351116d8ac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "11ebb7eac78033ed4b8b7f8bf2dae372f511166c", "commitAfterChange": "ba04cb6ba4b5497c184d335aa777690304f7e67a", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " boolean isInterfaceMethodImplemented(MethodBinding inheritedMethod, MethodBinding existingMethod, ReferenceBinding superType)", "signatureAfterChange": " boolean isInterfaceMethodImplemented(MethodBinding inheritedMethod, MethodBinding existingMethod, ReferenceBinding superType)", "diff": ["-\t\t&& inheritedMethod.returnType == existingMethod.returnType // keep around to produce bridge methods", "+\t\t&& (inheritedMethod.returnType == existingMethod.returnType\t// need to keep around to produce bridge methods? ...", "+\t\t\t|| (this.type != existingMethod.declaringClass \t\t\t// ... not if inheriting the bridge situation from a superclass", "+\t\t\t\t\t&& !existingMethod.declaringClass.isInterface()))"]}], "num": 14156}