{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "305cb76efa8a0f6f10dbf3ad3fad9efd", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7e9d02052e622cd5b77cc4b5f24355e8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java", "commitBeforeChange": "fa21653618683a7c1daa8e88412c523157e6d5cf", "commitAfterChange": "b507d9a904cae2791728076e7abcce8b001f81b2", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \t \tprivate synchronized void computeAllRootPaths(IType type)", "signatureAfterChange": " \t \tprivate synchronized void computeAllRootPaths(IType type)", "diff": ["+\t\tIPath pkgFragmentRootPath = root.getPath();", "+\t\tboolean containsJavaSource = !pkgFragmentRootPath.equals(this.sourcePath); // used to optimize zip file reading only if source path and root path are equals, otherwise assume that attachment contains Java source", "-\t\t\tJarPackageFragmentRoot jarPackageFragmentRoot = (JarPackageFragmentRoot) root;", "-\t\t\t\tzip = manager.getZipFile(jarPackageFragmentRoot.getPath());", "+\t\t\t\tzip = manager.getZipFile(pkgFragmentRootPath);", "-\t\t\t\t\t\tint index = entryName.indexOf('/');", "-\t\t\t\t\t\tif (index != -1 && Util.isClassFileName(entryName)) {", "-\t\t\t\t\t\t\tString firstLevelPackageName = entryName.substring(0, index);", "-\t\t\t\t\t\t\tif (!firstLevelPackageNames.contains(firstLevelPackageName)) {", "-\t\t\t\t\t\t\t\tif (sourceLevel == null) {", "-\t\t\t\t\t\t\t\t\tIJavaProject project = root.getJavaProject();", "-\t\t\t\t\t\t\t\t\tsourceLevel = project.getOption(JavaCore.COMPILER_SOURCE, true);", "-\t\t\t\t\t\t\t\t\tcomplianceLevel = project.getOption(JavaCore.COMPILER_COMPLIANCE, true);", "+\t\t\t\t\t\tif (Util.isClassFileName(entryName)) {", "+\t\t\t\t\t\t\tint index = entryName.indexOf('/');", "+\t\t\t\t\t\t\tif (index != -1) {", "+\t\t\t\t\t\t\t\tString firstLevelPackageName = entryName.substring(0, index);", "+\t\t\t\t\t\t\t\tif (!firstLevelPackageNames.contains(firstLevelPackageName)) {", "+\t\t\t\t\t\t\t\t\tif (sourceLevel == null) {", "+\t\t\t\t\t\t\t\t\t\tIJavaProject project = root.getJavaProject();", "+\t\t\t\t\t\t\t\t\t\tsourceLevel = project.getOption(JavaCore.COMPILER_SOURCE, true);", "+\t\t\t\t\t\t\t\t\t\tcomplianceLevel = project.getOption(JavaCore.COMPILER_COMPLIANCE, true);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tIStatus status = JavaConventions.validatePackageName(firstLevelPackageName, sourceLevel, complianceLevel);", "+\t\t\t\t\t\t\t\t\tif (status.isOK() || status.getSeverity() == IStatus.WARNING) {", "+\t\t\t\t\t\t\t\t\t\tfirstLevelPackageNames.add(firstLevelPackageName);", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tIStatus status = JavaConventions.validatePackageName(firstLevelPackageName, sourceLevel, complianceLevel);", "-\t\t\t\t\t\t\t\tif (status.isOK() || status.getSeverity() == IStatus.WARNING) {", "-\t\t\t\t\t\t\t\t\tfirstLevelPackageNames.add(firstLevelPackageName);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tcontainsADefaultPackage = true;", "-\t\t\t\t\t\t} else if (Util.isClassFileName(entryName)) {", "-\t\t\t\t\t\t\tcontainsADefaultPackage = true;", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t\t} else if (!containsJavaSource && org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(entryName)) {", "+\t\t\t\t\t\t\tcontainsJavaSource = true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tString resourceName = member.getName();", "-\t\t\t\t\t\t\t\tString firstLevelPackageName = member.getName();", "-\t\t\t\t\t\t\t\tIStatus status = JavaConventions.validatePackageName(firstLevelPackageName, sourceLevel, complianceLevel);", "+\t\t\t\t\t\t\t\tIStatus status = JavaConventions.validatePackageName(resourceName, sourceLevel, complianceLevel);", "-\t\t\t\t\t\t\t\t\tfirstLevelPackageNames.add(firstLevelPackageName);", "+\t\t\t\t\t\t\t\t\tfirstLevelPackageNames.add(resourceName);", "-\t\t\t\t\t\t\t} else if (Util.isClassFileName(member.getName())) {", "+\t\t\t\t\t\t\t} else if (Util.isClassFileName(resourceName)) {", "+\t\t\t\t\t\t\t} else if (!containsJavaSource && org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(resourceName)) {", "+\t\t\t\t\t\t\t\tcontainsJavaSource = true;", "-\t\tObject target = JavaModel.getTarget(this.sourcePath, true);", "-\t\tif (target instanceof IContainer) {", "-\t\t\tIContainer folder = (IContainer)target;", "-\t\t\tcomputeRootPath(folder, firstLevelPackageNames, containsADefaultPackage, tempRoots, folder.getFullPath().segmentCount()/*if external folder, this is the linked folder path*/);", "-\t\t} else {", "-\t\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t\t\tZipFile zip = null;", "-\t\t\ttry {", "-\t\t\t\tzip = manager.getZipFile(this.sourcePath);", "-\t\t\t\tfor (Enumeration entries = zip.entries(); entries.hasMoreElements(); ) {", "-\t\t\t\t\tZipEntry entry = (ZipEntry) entries.nextElement();", "-\t\t\t\t\tString entryName;", "-\t\t\t\t\tif (!entry.isDirectory() && org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(entryName = entry.getName())) {", "-\t\t\t\t\t\tIPath path = new Path(entryName);", "-\t\t\t\t\t\tint segmentCount = path.segmentCount();", "-\t\t\t\t\t\tif (segmentCount > 1) {", "-\t\t\t\t\t\t\tfor (int i = 0, max = path.segmentCount() - 1; i < max; i++) {", "-\t\t\t\t\t\t\t\tif (firstLevelPackageNames.contains(path.segment(i))) {", "-\t\t\t\t\t\t\t\t\ttempRoots.add(path.uptoSegment(i));", "-\t\t\t\t\t\t\t\t\t// don't break here as this path could contain other first level package names (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=74014)", "+\t\tif (containsJavaSource) { // no need to read source attachment if it contains no Java source (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=190840 )", "+\t\t\tObject target = JavaModel.getTarget(this.sourcePath, true);", "+\t\t\tif (target instanceof IContainer) {", "+\t\t\t\tIContainer folder = (IContainer)target;", "+\t\t\t\tcomputeRootPath(folder, firstLevelPackageNames, containsADefaultPackage, tempRoots, folder.getFullPath().segmentCount()/*if external folder, this is the linked folder path*/);", "+\t\t\t} else {", "+\t\t\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\t\t\t\tZipFile zip = null;", "+\t\t\t\ttry {", "+\t\t\t\t\tzip = manager.getZipFile(this.sourcePath);", "+\t\t\t\t\tfor (Enumeration entries = zip.entries(); entries.hasMoreElements(); ) {", "+\t\t\t\t\t\tZipEntry entry = (ZipEntry) entries.nextElement();", "+\t\t\t\t\t\tString entryName;", "+\t\t\t\t\t\tif (!entry.isDirectory() && org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(entryName = entry.getName())) {", "+\t\t\t\t\t\t\tIPath path = new Path(entryName);", "+\t\t\t\t\t\t\tint segmentCount = path.segmentCount();", "+\t\t\t\t\t\t\tif (segmentCount > 1) {", "+\t\t\t\t\t\t\t\tfor (int i = 0, max = path.segmentCount() - 1; i < max; i++) {", "+\t\t\t\t\t\t\t\t\tif (firstLevelPackageNames.contains(path.segment(i))) {", "+\t\t\t\t\t\t\t\t\t\ttempRoots.add(path.uptoSegment(i));", "+\t\t\t\t\t\t\t\t\t\t// don't break here as this path could contain other first level package names (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=74014)", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (i == max - 1 && containsADefaultPackage) {", "+\t\t\t\t\t\t\t\t\t\ttempRoots.add(path.uptoSegment(max));", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (i == max - 1 && containsADefaultPackage) {", "-\t\t\t\t\t\t\t\t\ttempRoots.add(path.uptoSegment(max));", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if (containsADefaultPackage) {", "+\t\t\t\t\t\t\t\ttempRoots.add(new Path(\"\")); //$NON-NLS-1$", "-\t\t\t\t\t\t} else if (containsADefaultPackage) {", "-\t\t\t\t\t\t\ttempRoots.add(new Path(\"\")); //$NON-NLS-1$", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\t// ignore", "+\t\t\t\t} finally {", "+\t\t\t\t\tmanager.closeZipFile(zip); // handle null case", "-\t\t\t} catch (CoreException e) {", "-\t\t\t\t// ignore", "-\t\t\t} finally {", "-\t\t\t\tmanager.closeZipFile(zip); // handle null case"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5f2884cd912987c4e80e386b7ee25c4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "244829701e930ed5e8c032bf583662e3d16d3513", "commitAfterChange": "352a6d10b0265833df8f27de2e4e038afdaa31d6", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-\t\t\t\tfor (int j = length - 1; j > i; j--) {", "-\t\t\t\t\tMethodBinding method2 = methods[j];", "-\t\t\t\t\tif (method2 != null && CharOperation.equals(selector, method2.selector)) {", "-\t\t\t\t\t\tboolean paramsMatch = complyTo15 && methodTypeErasure == (method2.returnType == null ? null : method2.returnType.erasure()) // see 87956 & 88094", "-\t\t\t\t\t\t\t? method.areParameterErasuresEqual(method2)", "-\t\t\t\t\t\t\t: method.areParametersEqual(method2);", "-\t\t\t\t\t\tif (paramsMatch) {", "-\t\t\t\t\t\t\tboolean isEnumSpecialMethod = isEnum()", "-\t\t\t\t\t\t\t\t&& (selector == TypeConstants.VALUEOF || selector == TypeConstants.VALUES);", "-\t\t\t\t\t\t\tif (methodDecl == null) {", "-\t\t\t\t\t\t\t\tmethodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost & may still be null if method is special", "-\t\t\t\t\t\t\t\tif (methodDecl != null && methodDecl.binding != null) { // ensure its a valid user defined method", "-\t\t\t\t\t\t\t\t\tif (isEnumSpecialMethod)", "-\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, methodDecl);", "-\t\t\t\t\t\t\t\t\telse", "-\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, methodDecl);", "-\t\t\t\t\t\t\t\t\tmethodDecl.binding = null;", "-\t\t\t\t\t\t\t\t\tmethods[i] = null;", "-\t\t\t\t\t\t\t\t\tfailed++;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tAbstractMethodDeclaration method2Decl = method2.sourceMethod();", "-\t\t\t\t\t\t\tif (method2Decl != null && method2Decl.binding != null) { // ensure its a valid user defined method", "-\t\t\t\t\t\t\t\tif (isEnumSpecialMethod)", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, method2Decl);", "-\t\t\t\t\t\t\t\telse", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, method2Decl);", "-\t\t\t\t\t\t\t\tmethod2Decl.binding = null;", "-\t\t\t\t\t\t\t\tmethods[j] = null;", "-\t\t\t\t\t\t\t\tfailed++;", "-\t\t\t\t\t\t\t}", "+\t\t\t\tnextOtherMethod: for (int j = length - 1; j > i; j--) {", "+\t\t\t\t\tMethodBinding otherMethod = methods[j];", "+\t\t\t\t\t// check collision with otherMethod", "+\t\t\t\t\tif (otherMethod == null) ", "+\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\tif (!CharOperation.equals(selector, otherMethod.selector))", "+\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\tif (complyTo15) {", "+\t\t\t\t\t\tTypeBinding otherMethodTypeErasure = otherMethod.returnType == null ? null : otherMethod.returnType.erasure();", "+\t\t\t\t\t\tif (methodTypeErasure != otherMethodTypeErasure) {", "+\t\t\t\t\t\t\tif (method.typeVariables != NoTypeVariables && otherMethod.typeVariables != NoTypeVariables) {", "+\t\t\t\t\t\t\t\t// for generic methods, no need to check arguments", "+\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (!method.areParametersEqual(otherMethod)) ", "+\t\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t\t\t}\t\t\t\t\t\t\t", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (!method.areParameterErasuresEqual(otherMethod))", "+\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// prior to 1.5, parameter match is enough for collision", "+\t\t\t\t\t\tif (!method.areParametersEqual(otherMethod)) ", "+\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t}", "+\t\t\t\t\t// report duplicate", "+\t\t\t\t\tboolean isEnumSpecialMethod = isEnum()", "+\t\t\t\t\t\t&& (selector == TypeConstants.VALUEOF || selector == TypeConstants.VALUES);", "+\t\t\t\t\tif (methodDecl == null) {", "+\t\t\t\t\t\tmethodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost & may still be null if method is special", "+\t\t\t\t\t\tif (methodDecl != null && methodDecl.binding != null) { // ensure its a valid user defined method", "+\t\t\t\t\t\t\tif (isEnumSpecialMethod)", "+\t\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, methodDecl);", "+\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, methodDecl);", "+\t\t\t\t\t\t\tmethodDecl.binding = null;", "+\t\t\t\t\t\t\tmethods[i] = null;", "+\t\t\t\t\t\t\tfailed++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tAbstractMethodDeclaration otherMethodDecl = otherMethod.sourceMethod();", "+\t\t\t\t\tif (otherMethodDecl != null && otherMethodDecl.binding != null) { // ensure its a valid user defined method", "+\t\t\t\t\t\tif (isEnumSpecialMethod)", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, otherMethodDecl);", "+\t\t\t\t\t\telse", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, otherMethodDecl);", "+\t\t\t\t\t\totherMethodDecl.binding = null;", "+\t\t\t\t\t\tmethods[j] = null;", "+\t\t\t\t\t\tfailed++;"]}], "num": 50228}