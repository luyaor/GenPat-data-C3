{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2fa960b402dd840beb24c72ffaa65dde", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64b2d4ff205d824241582f28637ab5ab", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "717a44c6b6c761be0c48243cde9dff6857a6db32", "commitAfterChange": "df9941361641a347d1ba4ee80fe7f9c7468ba17a", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r public static final Constant getConstantFor(\r \tFieldBinding binding, \r \tboolean implicitReceiver, \r \tReference ref, \r \tint indexInQualification)", "signatureAfterChange": "\r \r \tpublic static final Constant getConstantFor(\r \t\tFieldBinding binding,\r \t\tboolean implicitReceiver,\r \t\tReference reference,\r \t\tScope referenceScope,\r \t\tint indexInQualification)", "diff": ["-}\r", "-public static final Constant getConstantFor(\r", "-\tFieldBinding binding, \r", "-\tboolean implicitReceiver, \r", "-\tReference ref, \r", "-\tint indexInQualification) {\r", "-\t//propagation of the constant.\r", "-\r", "-\t//ref can be a FieldReference, a SingleNameReference or a QualifiedNameReference\r", "-\t//indexInQualification may have a value greater than zero only for QualifiednameReference\r", "-\t//if ref==null then indexInQualification==0 AND implicitReceiver == false. This case is a \r", "-\t//degenerated case where a fake reference field (null) \r", "-\t//is associted to a real FieldBinding in order \r", "-\t//to allow its constant computation using the regular path (i.e. find the fieldDeclaration\r", "-\t//and proceed to its type resolution). As implicitReceiver is false, no error reporting\r", "-\t//against ref will be used ==> no nullPointerException risk .... \r", "-\r", "-\t//special treatment for langage-built-in  field (their declaring class is null)\r", "-\tif (binding.declaringClass == null) {\r", "-\t\t//currently only one field \"length\" : the constant computation is never done\r", "-\t\treturn NotAConstant;\r", "-\t}\r", "-\tif (!binding.isFinal()) {\r", "-\t\treturn binding.constant = NotAConstant;\r", "-\t}\r", "-\tif (binding.constant != null) {\r", "-\t\tif (indexInQualification == 0) {\r", "-\t\t\treturn binding.constant;\r", "-\t\t//see previous comment for the (sould-always-be) valid cast\r", "-\t\tQualifiedNameReference qnr = (QualifiedNameReference) ref;\r", "-\t\tif (indexInQualification == (qnr.indexOfFirstFieldBinding - 1)) {\r", "-\t\t\treturn binding.constant;\r", "-\t\treturn NotAConstant;\r", "-\t//The field has not been yet type checked.\r", "-\t//It also means that the field is not coming from a class that\r", "-\t//has already been compiled. It can only be from a class within\r", "-\t//compilation units to process. Thus the field is NOT from a BinaryTypeBinbing\r", "-\tSourceTypeBinding tb = (SourceTypeBinding) binding.declaringClass;\r", "-\tTypeDeclaration typeDecl = tb.scope.referenceContext;\r", "+\tpublic static final Constant getConstantFor(\r", "+\t\tFieldBinding binding,\r", "+\t\tboolean implicitReceiver,\r", "+\t\tReference reference,\r", "+\t\tScope referenceScope,\r", "+\t\tint indexInQualification) {\r", "-\t//fetch the field declaration\r", "-\tFieldDeclaration fieldDecl = null;\r", "-\tint index = 0;\r", "-\tFieldDeclaration[] fields = typeDecl.fields;\r", "-\twhile (fieldDecl == null) {\r", "-\t\tif ((fields[index].isField())\r", "-\t\t\t&& (CharOperation.equals(fields[index].name, binding.name)))\r", "-\t\t\tfieldDecl = fields[index];\r", "-\t\telse\r", "-\t\t\tindex++;\r", "-\t}\r", "-\t//what scope to use (depend on the staticness of the field binding)\r", "-\tMethodScope fieldScope = \r", "-\t\tbinding.isStatic()\r", "-\t\t\t? typeDecl.staticInitializerScope\r", "-\t\t\t: typeDecl.initializerScope; \r", "-\tif (implicitReceiver) { //Determine if the ref is legal in the current class of the field\r", "-\t\t//i.e. not a forward reference .... (they are allowed when the receiver is explicit ! ... Please don't ask me why !...yet another java mystery...)\r", "-\t\tif (fieldScope.fieldDeclarationIndex == MethodScope.NotInFieldDecl) {\r", "-\t\t\t// no field is currently being analysed in typeDecl\r", "+\t\t//propagation of the constant.\r", "+\r", "+\t\t//ref can be a FieldReference, a SingleNameReference or a QualifiedNameReference\r", "+\t\t//indexInQualification may have a value greater than zero only for QualifiednameReference\r", "+\t\t//if ref==null then indexInQualification==0 AND implicitReceiver == false. This case is a \r", "+\t\t//degenerated case where a fake reference field (null) \r", "+\t\t//is associted to a real FieldBinding in order \r", "+\t\t//to allow its constant computation using the regular path (i.e. find the fieldDeclaration\r", "+\t\t//and proceed to its type resolution). As implicitReceiver is false, no error reporting\r", "+\t\t//against ref will be used ==> no nullPointerException risk .... \r", "+\r", "+\t\t//special treatment for langage-built-in  field (their declaring class is null)\r", "+\t\tif (binding.declaringClass == null) {\r", "+\t\t\t//currently only one field \"length\" : the constant computation is never done\r", "+\t\t\treturn NotAConstant;\r", "+\t\t}\r", "+\t\tif (!binding.isFinal()) {\r", "+\t\t\treturn binding.constant = NotAConstant;\r", "+\t\t}\r", "+\t\tif (binding.constant != null) {\r", "+\t\t\tif (indexInQualification == 0) {\r", "+\t\t\t\treturn binding.constant;\r", "+\t\t\t}\r", "+\t\t\t//see previous comment for the (sould-always-be) valid cast\r", "+\t\t\tQualifiedNameReference qualifiedReference = (QualifiedNameReference) reference;\r", "+\t\t\tif (indexInQualification == (qualifiedReference.indexOfFirstFieldBinding - 1)) {\r", "+\t\t\t\treturn binding.constant;\r", "+\t\t\t}\r", "+\t\t\treturn NotAConstant;\r", "+\t\t}\r", "+\r", "+\t\t//The field has not been yet type checked.\r", "+\t\t//It also means that the field is not coming from a class that\r", "+\t\t//has already been compiled. It can only be from a class within\r", "+\t\t//compilation units to process. Thus the field is NOT from a BinaryTypeBinbing\r", "+\r", "+\t\tSourceTypeBinding typeBinding = (SourceTypeBinding) binding.declaringClass;\r", "+\t\tTypeDeclaration typeDecl = typeBinding.scope.referenceContext;\r", "+\t\tFieldDeclaration fieldDecl = typeDecl.declarationOf(binding);\r", "+\r", "+\t\t//what scope to use (depend on the staticness of the field binding)\r", "+\t\tMethodScope fieldScope =\r", "+\t\t\tbinding.isStatic()\r", "+\t\t\t\t? typeDecl.staticInitializerScope\r", "+\t\t\t\t: typeDecl.initializerScope;\r", "+\r", "+\t\tif (implicitReceiver) { //Determine if the ref is legal in the current class of the field\r", "+\t\t\t//i.e. not a forward reference .... (they are allowed when the receiver is explicit ! ... Please don't ask me why !...yet another java mystery...)\r", "+\t\t\tif (fieldScope.fieldDeclarationIndex == MethodScope.NotInFieldDecl) {\r", "+\t\t\t\t// no field is currently being analysed in typeDecl\r", "+\t\t\t\tfieldDecl.resolve(fieldScope); //side effect on binding :-) ... \r", "+\t\t\t\treturn binding.constant;\r", "+\t\t\t}\r", "+\t\t\t//We are re-entering the same class fields analysing\r", "+\t\t\tif ((reference != null)\r", "+\t\t\t\t&& (binding.declaringClass == referenceScope.enclosingSourceType()) // only complain for access inside same type\r", "+\t\t\t\t&& (binding.id > fieldScope.fieldDeclarationIndex)) {\r", "+\t\t\t\t//forward reference. The declaration remains unresolved.\r", "+\t\t\t\treferenceScope.problemReporter().forwardReference(reference, indexInQualification, typeBinding);\r", "+\t\t\t\treturn NotAConstant;\r", "+\t\t\t}\r", "-\t\t//We are re-entering the same class fields analysing\r", "-\t\tif (((ref == null) || ((ref.bits & DepthMASK) == 0)) // not implicit ref to enclosing field\r", "-\t\t\t&& (binding.id > fieldScope.fieldDeclarationIndex)) {\r", "-\t\t\t//forward reference. The declaration remains unresolved.\r", "-\t\t\ttb.scope.problemReporter().forwardReference(ref, indexInQualification, tb);\r", "+\t\t//the field reference is explicity. It has to be a \"simple\" like field reference to get the\r", "+\t\t//constant propagation. For example in Packahe.Type.field1.field2 , field1 may have its\r", "+\t\t//constant having a propagation where field2 is always not propagating its\r", "+\t\tif (indexInQualification == 0) {\r", "+\t\t\tfieldDecl.resolve(fieldScope); //side effect on binding :-) ... \r", "+\t\t\treturn binding.constant;\r", "+\t\t}\r", "+\t\t// Side-effect on the field binding may not be propagated out for the qualified reference\r", "+\t\t// unless it occurs in first place of the name sequence\r", "+\t\tfieldDecl.resolve(fieldScope); //side effect on binding :-) ... \r", "+\t\t//see previous comment for the cast that should always be valid\r", "+\t\tQualifiedNameReference qualifiedReference = (QualifiedNameReference) reference;\r", "+\t\tif (indexInQualification == (qualifiedReference.indexOfFirstFieldBinding - 1)) {\r", "+\t\t\treturn binding.constant;\r", "+\t\t} else {\r", "-\t\tfieldDecl.resolve(fieldScope); //side effect on binding :-) ... \r", "-\t\treturn binding.constant;\r", "-\t//the field reference is explicity. It has to be a \"simple\" like field reference to get the\r", "-\t//constant propagation. For example in Packahe.Type.field1.field2 , field1 may have its\r", "-\t//constant having a propagation where field2 is always not propagating its\r", "-\tif (indexInQualification == 0) {\r", "-\t\tfieldDecl.resolve(fieldScope); //side effect on binding :-) ... \r", "-\t\treturn binding.constant;\r", "-\t}\r", "-\t// Side-effect on the field binding may not be propagated out for the qualified reference\r", "-\t// unless it occurs in first place of the name sequence\r", "-\tfieldDecl.resolve(fieldScope); //side effect on binding :-) ... \r", "-\t//see previous comment for the cast that should always be valid\r", "-\tQualifiedNameReference qnr = (QualifiedNameReference) ref;\r", "-\tif (indexInQualification == (qnr.indexOfFirstFieldBinding - 1)) {\r", "-\t\treturn binding.constant;\r", "-\t} else {\r", "-\t\treturn NotAConstant;\r", "-\t}\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e7b83a40fcf9bbc84eeb58e31e717796", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java", "commitBeforeChange": "5b7577970cc1147a47fff02a981297149bac38c1", "commitAfterChange": "747a63a0a2a9b4e7029fd103555c522985364757", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 10, "signatureBeforeChange": " public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " public boolean canBeRemovedFromCache()", "diff": ["+ */", "+public boolean canBeRemovedFromCache() {", "+\tif (isWorkingCopy()) return false; // working copies should remain in the cache until they are destroyed", "+\treturn super.canBeRemovedFromCache();", "+}", "- */", "-public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {", "-\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\tObject info = manager.getInfo(this);", "-\tif (info == null) {", "-\t\tinfo = openWhenClosed(new CompilationUnitElementInfo(), monitor);", "-\t} else if (info instanceof WorkingCopyElementInfo && !((WorkingCopyElementInfo)info).isOpen()) {", "-\t\tWorkingCopyElementInfo workingCopyElementInfo = (WorkingCopyElementInfo)info;", "-\t\tint useCount = workingCopyElementInfo.useCount();", "-\t\tinfo = openWhenClosed(new WorkingCopyElementInfo(useCount, workingCopyElementInfo.problemRequestor), monitor);", "-\t}", "-\treturn info;", "-}"]}], "num": 42198}