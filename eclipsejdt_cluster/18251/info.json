{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b0916624f8ef45dd07db52f9ae83f3f4", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66aa8ec1f9272a2a8c711c0c37d2905a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "8b9431052e3d61392fc8179c11535d264307c499", "commitAfterChange": "c9c353b1f3633c7934ab02e6b5f4d6f7b6d921d9", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  void checkMethods()", "signatureAfterChange": "  void checkMethods()", "diff": ["-\t\t\tif (index > 0)", "-\t\t\t\tcheckInheritedMethods(matchingInherited, index + 1, isOverridden, isInherited); // pass in the length of matching", "+\t\t\tif (index > 0) {", "+\t\t\t\tint length = index + 1;", "+\t\t\t\tboolean[] matchingIsOverridden;", "+\t\t\t\tboolean[] matchingIsInherited;", "+\t\t\t\tif (length != inheritedLength) { // transfer inherited & overridden status to align with subset of methods.", "+\t\t\t\t\tmatchingIsOverridden = new boolean[length];", "+\t\t\t\t\tmatchingIsInherited = new boolean[length];", "+\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\tfor (int k = 0; k < inheritedLength; k++) {", "+\t\t\t\t\t\t\tif (matchingInherited[j] == inherited[k]) {", "+\t\t\t\t\t\t\t\tmatchingIsOverridden[j] = isOverridden[k];", "+\t\t\t\t\t\t\t\tmatchingIsInherited[j] = isInherited[k];", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tmatchingIsOverridden = isOverridden;", "+\t\t\t\t\tmatchingIsInherited = isInherited;", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tcheckInheritedMethods(matchingInherited, length, matchingIsOverridden, matchingIsInherited); // pass in the length of matching", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f313fe7f720986e0bd0f8f9b628925f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "e2422311047b85902980920dda1eeedf124d520c", "commitAfterChange": "c107fdebcaaafcbea0a28f68e9b229afba9f7c4f", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["+\t\tint inheritedLength = inherited.length;", "-\t\tbyte[] foundMatch = new byte[inherited.length];", "+\t\tMethodBinding[] foundMatch = new MethodBinding[inherited.length]; // null is no match, otherwise value is matching currentMethod", "-\t\t\t\tfor (int j = 0, length2 = inherited.length; j < length2; j++) {", "+\t\t\t\tMethodBinding[] nonMatchingInherited = null;", "+\t\t\t\tfor (int j = 0; j < inheritedLength; j++) {", "-\t\t\t\t\t\tif (foundMatch[j] == 0 && isSubstituteParameterSubsignature(currentMethod, inheritedMethod)) {", "+\t\t\t\t\t\tif (foundMatch[j] == null && isSubstituteParameterSubsignature(currentMethod, inheritedMethod)) {", "-\t\t\t\t\t\t\tfoundMatch[j] = 1; // cannot null out inherited methods", "+\t\t\t\t\t\t\tfoundMatch[j] = currentMethod;", "+\t\t\t\t\t\t\t// best place to check each currentMethod against each non-matching inheritedMethod", "+\t\t\t\t\t\t\tif (inheritedLength > 1) {", "+\t\t\t\t\t\t\t\tif (nonMatchingInherited == null)", "+\t\t\t\t\t\t\t\t\tnonMatchingInherited = new MethodBinding[inheritedLength];", "+\t\t\t\t\t\t\t\tnonMatchingInherited[j] = inheritedMethod;", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\tcheckAgainstInheritedMethods(currentMethod, matchingInherited, index + 1, inherited); // pass in the length of matching", "+\t\t\t\t\tcheckAgainstInheritedMethods(currentMethod, matchingInherited, index + 1, nonMatchingInherited); // pass in the length of matching", "-\t\tfor (int i = 0, length = inherited.length; i < length; i++) {", "-\t\t\tif (foundMatch[i] == 1) continue;", "-", "+\t\t// skip tracks which inherited methods have matched other inherited methods", "+\t\t// either because they match the same currentMethod or match each other", "+\t\tboolean[] skip = new boolean[inheritedLength];", "+\t\tfor (int i = 0; i < inheritedLength; i++) {", "+\t\t\tif (skip[i]) continue;", "-\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\tfor (int j = i + 1; j < length; j++) {", "+\t\t\tMethodBinding matchMethod = foundMatch[i];", "+\t\t\tif (matchMethod == null)", "+\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "+\t\t\tfor (int j = i + 1; j < inheritedLength; j++) {", "-\t\t\t\tif (foundMatch[j] == 1 || canSkipInheritedMethods(inheritedMethod, otherInheritedMethod))", "+\t\t\t\tif (matchMethod == foundMatch[j] && matchMethod != null)", "+\t\t\t\t\tcontinue; // both inherited methods matched the same currentMethod", "+\t\t\t\tif (canSkipInheritedMethods(inheritedMethod, otherInheritedMethod))", "+\t\t\t\t\t\t\tif (index == -1)", "+\t\t\t\t\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\t\t\t\t\tfoundMatch[j] = 1; // cannot null out inherited methods", "-\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tskip[j] = true;", "+\t\t\t\t\t} else if (matchMethod == null && foundMatch[j] == null) {", "-\t\t\telse if (mustImplementAbstractMethods && index == 0 && matchingInherited[0].isAbstract())", "+\t\t\telse if (mustImplementAbstractMethods && matchingInherited[0].isAbstract())"]}], "num": 18251}