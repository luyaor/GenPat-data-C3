{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5865442aabe9112d63a95d6289e332d2", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0cd0af3493e8cb4073831e8549b1b8f3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java", "commitBeforeChange": "1248181e23c81da45ee8e328a409b761a39e6e52", "commitAfterChange": "3df0b6d0a7c9e742ebbc5f2930d09070fa613a77", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic AssistOptions(Map settings)", "signatureAfterChange": " \tpublic AssistOptions(Map settings)", "diff": ["-\t\t\t} ", "+\t\t\t} else if(optionID.equals(OPTION_FieldPrefixes)){", "+\t\t\t\tif (optionValue.length() == 0) {", "+\t\t\t\t\tthis.fieldPrefixes = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.fieldPrefixes = CharOperation.splitAndTrimOn(',', optionValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t\tcontinue;", "+\t\t\t} else if(optionID.equals(OPTION_StaticFieldPrefixes)){", "+\t\t\t\tif (optionValue.length() == 0) {", "+\t\t\t\t\tthis.staticFieldPrefixes = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.staticFieldPrefixes = CharOperation.splitAndTrimOn(',', optionValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t\tcontinue;", "+\t\t\t} else if(optionID.equals(OPTION_LocalPrefixes)){", "+\t\t\t\tif (optionValue.length() == 0) {", "+\t\t\t\t\tthis.localPrefixes = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.localPrefixes = CharOperation.splitAndTrimOn(',', optionValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t\tcontinue;", "+\t\t\t} else if(optionID.equals(OPTION_ArgumentPrefixes)){", "+\t\t\t\tif (optionValue.length() == 0) {", "+\t\t\t\t\tthis.argumentPrefixes = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.argumentPrefixes = CharOperation.splitAndTrimOn(',', optionValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t\tcontinue;", "+\t\t\t} else if(optionID.equals(OPTION_FieldSuffixes)){", "+\t\t\t\tif (optionValue.length() == 0) {", "+\t\t\t\t\tthis.fieldSuffixes = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.fieldSuffixes = CharOperation.splitAndTrimOn(',', optionValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t\tcontinue;", "+\t\t\t} else if(optionID.equals(OPTION_StaticFieldSuffixes)){", "+\t\t\t\tif (optionValue.length() == 0) {", "+\t\t\t\t\tthis.staticFieldSuffixes = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.staticFieldSuffixes = CharOperation.splitAndTrimOn(',', optionValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t\tcontinue;", "+\t\t\t} else if(optionID.equals(OPTION_LocalSuffixes)){", "+\t\t\t\tif (optionValue.length() == 0) {", "+\t\t\t\t\tthis.localSuffixes = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.localSuffixes = CharOperation.splitAndTrimOn(',', optionValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t\tcontinue;", "+\t\t\t} else if(optionID.equals(OPTION_ArgumentSuffixes)){", "+\t\t\t\tif (optionValue.length() == 0) {", "+\t\t\t\t\tthis.argumentSuffixes = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.argumentSuffixes = CharOperation.splitAndTrimOn(',', optionValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t\tcontinue;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "188ad23c356f088cfe8cb5cb23634618", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java", "commitBeforeChange": "6665973e9a36116a8cb24b7143317e47a83a98f0", "commitAfterChange": "305123b230bcfd1f733969b7cd2c687b75857ff0", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  \tpublic void set(Map optionsMap)", "signatureAfterChange": "  \tpublic void set(Map optionsMap)", "diff": ["+\t\tif ((optionValue = optionsMap.get(OPTION_AnnotationBasedNullAnalysis)) != null) {", "+\t\t\tthis.isAnnotationBasedNullAnalysisEnabled = ENABLED.equals(optionValue);", "+\t\t}", "+\t\tif (this.isAnnotationBasedNullAnalysisEnabled) {", "+\t\t\tif ((optionValue = optionsMap.get(OPTION_ReportNullSpecViolation)) != null) {", "+\t\t\t\tif (ERROR.equals(optionValue)) {", "+\t\t\t\t\tthis.errorThreshold.set(NullSpecViolation);", "+\t\t\t\t\tthis.warningThreshold.clear(NullSpecViolation);", "+\t\t\t\t} else if (WARNING.equals(optionValue)) {", "+\t\t\t\t\tthis.errorThreshold.clear(NullSpecViolation);", "+\t\t\t\t\tthis.warningThreshold.set(NullSpecViolation);", "+\t\t\t\t}", "+\t\t\t\t// \"ignore\" is not valid for this option", "+\t\t\t}", "+\t\t\tif ((optionValue = optionsMap.get(OPTION_ReportPotentialNullSpecViolation)) != null) updateSeverity(PotentialNullSpecViolation, optionValue);", "+\t\t\tif ((optionValue = optionsMap.get(OPTION_ReportNullSpecInsufficientInfo)) != null) updateSeverity(NullSpecInsufficientInfo, optionValue);", "+\t\t\tif ((optionValue = optionsMap.get(OPTION_ReportRedundantNullAnnotation)) != null) updateSeverity(RedundantNullAnnotation, optionValue);", "+\t\t\tif ((optionValue = optionsMap.get(OPTION_NullableAnnotationName)) != null) {", "+\t\t\t\tthis.nullableAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());", "+\t\t\t}", "+\t\t\tif ((optionValue = optionsMap.get(OPTION_NonNullAnnotationName)) != null) {", "+\t\t\t\tthis.nonNullAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());", "+\t\t\t}", "+\t\t\tif ((optionValue = optionsMap.get(OPTION_NonNullByDefaultAnnotationName)) != null) {", "+\t\t\t\tthis.nonNullByDefaultAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());", "+\t\t\t}", "+\t\t\tif ((optionValue = optionsMap.get(OPTION_NonNullIsDefault)) != null) {", "+\t\t\t\tif (CompilerOptions.ENABLED.equals(optionValue))", "+\t\t\t\t\tthis.defaultNonNullness = TagBits.AnnotationNonNull;", "+\t\t\t\telse if (CompilerOptions.DISABLED.equals(optionValue))", "+\t\t\t\t\tthis.defaultNonNullness = 0;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "220a74fa5cdbd0560674d45c4a58c26a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "9ecfd83150af2852591fa7ec68468d790c7eefcb", "commitAfterChange": "bbc460d21d93548b386e69b054c421a009cad4c2", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected boolean parseComment(int javadocStart, int javadocEnd)", "signatureAfterChange": " \tprotected boolean parseComment(int javadocStart, int javadocEnd)", "diff": ["+\t\t\tint invalidTagLineEnd = -1;", "+\t\t\tint invalidInlineTagLineEnd = -1;", "-\t\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocUnexpectedTag(this.inlineTagStart, this.inlineTagStart);", "+\t\t\t\t\t\t\t\tif (this.sourceParser != null) {", "+\t\t\t\t\t\t\t\t\tint end = previousPosition<invalidInlineTagLineEnd ? previousPosition : invalidInlineTagLineEnd;", "+\t\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocUnterminatedInlineTag(this.inlineTagStart, end);", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "+\t\t\t\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) refreshInlineTagPosition(previousPosition);", "+\t\t\t\t\t\t\t} // else {", "+\t\t\t\t\t\t\t\t\tinvalidInlineTagLineEnd = this.lineEnd;", "+\t\t\t\t\t\t\t\t} else if (this.textStart != -1 && this.textStart < invalidTagLineEnd) {", "+\t\t\t\t\t\t\t\t\tpushText(this.textStart, invalidTagLineEnd);", "-\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseSee(false);", "+\t\t\t\t\t\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "+//\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseTag();", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.sourceParser != null)", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocUnexpectedTag(this.tagSourceStart, this.tagSourceEnd);", "+\t\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseSee(false);", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseTag();", "+//\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseTag();", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.sourceParser != null)", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocUnexpectedTag(this.tagSourceStart, this.tagSourceEnd);", "-\t\t\t\t\t\t\t\t\tif (!valid) {", "-\t\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "-\t\t\t\t\t\t\t\t\t\tvalidComment = false;", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (!valid) {", "+\t\t\t\t\t\t\t\t\t\t// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51600", "+\t\t\t\t\t\t\t\t\t\t// do not stop the inline tag when error is encountered to get text after", "+//\t\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\t\t\t\t\t\t\tvalidComment = false;", "+\t\t\t\t\t\t\t\t\t\t// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51600", "+\t\t\t\t\t\t\t\t\t\t// for DOM AST node, store tag as text in case of invalid syntax", "+\t\t\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) {", "+\t\t\t\t\t\t\t\t\t\t\tparseTag();", "+\t\t\t\t\t\t\t\t\t\t\tthis.textStart = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\t\t\t\tinvalidTagLineEnd  = this.lineEnd;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t//}", "-\t\t\t\t\t\tthis.inlineTagStarted = false;", "+//\t\t\t\t\t\tthis.inlineTagStarted = false;", "-\t\t\t\t\t\t\tthis.lineStarted = true;", "+//\t\t\t\t\t\t\tthis.lineStarted = true;", "+\t\t\t\t\t\tthis.lineStarted = true;", "-\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidTag(this.inlineTagStart, this.index);", "-\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (this.sourceParser != null) {", "+\t\t\t\t\t\t\t\tint end = previousPosition<invalidInlineTagLineEnd ? previousPosition : invalidInlineTagLineEnd;", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocUnterminatedInlineTag(this.inlineTagStart, end);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "+\t\t\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) refreshInlineTagPosition(previousPosition);", "+\t\t\t\t\t\t} //else {", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t//}", "-\t\t\tif (this.lineStarted && this.textStart < previousPosition) {", "+\t\t\tif (this.inlineTagStarted) {", "+\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\tif (this.sourceParser != null) {", "+\t\t\t\t\tint end = previousPosition<invalidInlineTagLineEnd ? previousPosition : invalidInlineTagLineEnd;", "+\t\t\t\t\tif (this.index >= this.endComment) end = invalidInlineTagLineEnd;", "+\t\t\t\t\tthis.sourceParser.problemReporter().javadocUnterminatedInlineTag(this.inlineTagStart, end);", "+\t\t\t\t}", "+\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "+\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t}", "+\t\t\t\tif (this.kind == DOM_PARSER) {", "+\t\t\t\t\trefreshInlineTagPosition(previousPosition);", "+\t\t\t\t}", "+\t\t\t} else if (this.lineStarted && this.textStart < previousPosition) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3cad2665e5663404e75cb22de833306a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java", "commitBeforeChange": "fc25b1b826e7fad7f1da04ab9d452bc350b24919", "commitAfterChange": "19b4c669e6d8313d03dbcc8b595622002fe408a5", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  \tpublic void set(Map optionsMap)", "signatureAfterChange": "  \tpublic void set(Map optionsMap)", "diff": ["+\t\tif ((optionValue = optionsMap.get(OPTION_ReportNullContractViolation)) != null) updateSeverity(NullContractViolation, optionValue);", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportPotentialNullContractViolation)) != null) updateSeverity(PotentialNullContractViolation, optionValue);", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportNullContractInsufficientInfo)) != null) updateSeverity(NullContractInsufficientInfo, optionValue);", "+\t\tif ((optionValue = optionsMap.get(OPTION_NullableAnnotationName)) != null) {", "+\t\t\tthis.nullableAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_NonNullAnnotationName)) != null) {", "+\t\t\tthis.nonNullAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_EmulateNullAnnotationTypes)) != null) {", "+\t\t\tif (ENABLED.equals(optionValue)) {", "+\t\t\t\tthis.emulateNullAnnotationTypes = true;", "+\t\t\t\t// ensure that we actually have annotation names to emulate:", "+\t\t\t\tif (this.nullableAnnotationName == null)", "+\t\t\t\t\tthis.nullableAnnotationName = DEFAULT_NULLABLE_ANNOTATION_NAME;", "+\t\t\t\tif (this.nonNullAnnotationName == null)", "+\t\t\t\t\tthis.nonNullAnnotationName = DEFAULT_NONNULL_ANNOTATION_NAME;", "+\t\t\t} else if (DISABLED.equals(optionValue)) {", "+\t\t\t\tthis.emulateNullAnnotationTypes = false;", "+\t\t\t}", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_DefaultImportNullAnnotationTypes)) != null) {", "+\t\t\tif (ENABLED.equals(optionValue)) {", "+\t\t\t\tthis.defaultImportNullAnnotationTypes = true;", "+\t\t\t\t// ensure that we actually have annotation names to be used for default imports:", "+\t\t\t\tif (this.nullableAnnotationName == null)", "+\t\t\t\t\tthis.nullableAnnotationName = DEFAULT_NULLABLE_ANNOTATION_NAME;", "+\t\t\t\tif (this.nonNullAnnotationName == null)", "+\t\t\t\t\tthis.nonNullAnnotationName = DEFAULT_NONNULL_ANNOTATION_NAME;", "+\t\t\t} else if (DISABLED.equals(optionValue)) {", "+\t\t\t\tthis.defaultImportNullAnnotationTypes = false;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "416524e25d6ea0db970122f06a72b8a0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "82286041004c3a1c8b03ed85a8b5ba0c85e39f08", "commitAfterChange": "c3894f02481a65e7c5a6b2e211e3716b20cd9dd8", "methodNumberBeforeChange": 98, "methodNumberAfterChange": 101, "signatureBeforeChange": "  \tpublic Type convertType(TypeReference typeReference)", "signatureAfterChange": "  \tpublic Type convertType(TypeReference typeReference)", "diff": ["+", "+\t\torg.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;", "+\t\t\t}", "+\t\t\tif (typeReference.annotations != null && (annotations = typeReference.annotations[0]) != null) {", "+\t\t\t\tannotateType(wildcardType, annotations);", "+\t\t\t\tif (typeReference.annotations != null && (annotations = typeReference.annotations[0]) != null) {", "+\t\t\t\t\tannotateType(primitiveType, annotations);", "+\t\t\t\t}", "+\t\t\t\t\t\tif (typeReference.annotations != null && (annotations = typeReference.annotations[0]) != null) {", "+\t\t\t\t\t\t\tannotateType(simpleType, annotations);", "+\t\t\t\t\t\t}", "+\t\t\t\tif (typeReference.annotations != null && (annotations = typeReference.annotations[0]) != null) {", "+\t\t\t\t\tannotateType(simpleType, annotations);", "+\t\t\t\t}", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.Annotation[][] annotationsOnDimensions = typeReference.getAnnotationsOnDimensions();", "+\t\t\t\t\tif (annotationsOnDimensions != null && (annotations = annotationsOnDimensions[index]) != null) {", "+\t\t\t\t\t\tannotateType(subarrayType, annotations);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (annotationsOnDimensions != null && (annotations = annotationsOnDimensions[0]) != null) {", "+\t\t\t\t\tannotateType(subarrayType, annotations);", "-\t\t\t\t\t\tName qualifiedName = this.setQualifiedNameNameAndSourceRanges(name, positions, typeReference);", "+\t\t\t\t\t\tName qualifiedName = this.setQualifiedNameNameAndSourceRanges(name, positions, typeReference, typeReference.annotations);", "+\t\t\t\t\t\tsimpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);", "+\t\t\t\t\t\t\tif (endingIndex == 0 && typeReference.annotations != null && (annotations = typeReference.annotations[0]) != null) {", "+\t\t\t\t\t\t\t\tannotateType(simpleType, annotations);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (typeReference.annotations != null && (annotations = typeReference.annotations[startingIndex]) != null) {", "+\t\t\t\t\t\t\t\t\tannotateType(qualifiedType, annotations);", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\tfinal Name qualifiedName = this.setQualifiedNameNameAndSourceRanges(name, positions, typeReference);", "+\t\t\t\tfinal Name qualifiedName = this.setQualifiedNameNameAndSourceRanges(name, positions, typeReference, typeReference.annotations);", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.Annotation[][] annotationsOnDimensions = typeReference.getAnnotationsOnDimensions();", "+\t\t\t\t\tif (annotationsOnDimensions != null  && (annotations = annotationsOnDimensions[index]) != null) {", "+\t\t\t\t\t\tannotateType(subarrayType, annotations);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (annotationsOnDimensions != null  && (annotations = annotationsOnDimensions[0]) != null) {", "+\t\t\t\t\tannotateType(subarrayType, annotations);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c6aa10338b1c4e80b12bbbf919af902", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java", "commitBeforeChange": "cdead094a9813fdba5ccda0ce2f9f48a99552dbc", "commitAfterChange": "3be4aa0b7d051355f329ce1003f3f4c0f7acfab2", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic void set(Map optionsMap)", "signatureAfterChange": "  \tpublic void set(Map optionsMap)", "diff": ["-\t\tif ((optionValue = optionsMap.get(OPTION_ReportMissingJavadoc)) != null) {", "-\t\t\tif (ENABLED.equals(optionValue)) {", "-\t\t\t\tthis.reportMissingJavadoc = true;", "-\t\t\t} else if (DISABLED.equals(optionValue)) {", "-\t\t\t\tthis.reportMissingJavadoc = false;", "-\t\t\t}", "-\t\t}", "-\t\tif ((optionValue = optionsMap.get(OPTION_ReportInvalidJavadoc)) != null) updateSeverity(InvalidJavadoc, optionValue);", "+", "+\t\t// Javadoc options", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportInvalidJavadoc)) != null) {", "+\t\t\tupdateSeverity(InvalidJavadoc, optionValue);", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportInvalidJavadocTagsVisibility)) != null) {", "+\t\t\tif (PUBLIC.equals(optionValue)) {", "+\t\t\t\tthis.reportInvalidJavadocTagsVisibility = AccPublic;", "+\t\t\t} else if (PROTECTED.equals(optionValue)) {", "+\t\t\t\tthis.reportInvalidJavadocTagsVisibility = AccProtected;", "+\t\t\t} else if (DEFAULT.equals(optionValue)) {", "+\t\t\t\tthis.reportInvalidJavadocTagsVisibility = AccDefault;", "+\t\t\t} else if (PRIVATE.equals(optionValue)) {", "+\t\t\t\tthis.reportInvalidJavadocTagsVisibility = AccPrivate;", "+\t\t\t}", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportInvalidJavadocTags)) != null) {", "+\t\t\tif (ENABLED.equals(optionValue)) {", "+\t\t\t\tthis.reportInvalidJavadocTags= true;", "+\t\t\t} else if (DISABLED.equals(optionValue)) {", "+\t\t\t\tthis.reportInvalidJavadocTags = false;", "+\t\t\t}", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportMissingJavadocTags)) != null) {", "+\t\t\tupdateSeverity(MissingJavadocTags, optionValue);", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportMissingJavadocTagsVisibility)) != null) {", "+\t\t\tif (PUBLIC.equals(optionValue)) {", "+\t\t\t\tthis.reportMissingJavadocTagsVisibility = AccPublic;", "+\t\t\t} else if (PROTECTED.equals(optionValue)) {", "+\t\t\t\tthis.reportMissingJavadocTagsVisibility = AccProtected;", "+\t\t\t} else if (DEFAULT.equals(optionValue)) {", "+\t\t\t\tthis.reportMissingJavadocTagsVisibility = AccDefault;", "+\t\t\t} else if (PRIVATE.equals(optionValue)) {", "+\t\t\t\tthis.reportMissingJavadocTagsVisibility = AccPrivate;", "+\t\t\t}", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportMissingJavadocTagsOverriding)) != null) {", "+\t\t\t// TODO (frederic) see with jdt-ui whether we use ignore instead of report", "+\t\t\tif (ENABLED.equals(optionValue)) {", "+\t\t\t\t//this.reportMissingJavadocTagsOverriding = true;", "+\t\t\t\tthis.reportMissingJavadocTagsOverriding = false;", "+\t\t\t} else if (DISABLED.equals(optionValue)) {", "+\t\t\t\t//this.reportMissingJavadocTagsOverriding = false;", "+\t\t\t\tthis.reportMissingJavadocTagsOverriding = true;", "+\t\t\t}", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportMissingJavadocComments)) != null) {", "+\t\t\tupdateSeverity(MissingJavadocComments, optionValue);", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportMissingJavadocCommentsVisibility)) != null) {", "+\t\t\tif (PUBLIC.equals(optionValue)) {", "+\t\t\t\tthis.reportMissingJavadocCommentsVisibility = AccPublic;", "+\t\t\t} else if (PROTECTED.equals(optionValue)) {", "+\t\t\t\tthis.reportMissingJavadocCommentsVisibility = AccProtected;", "+\t\t\t} else if (DEFAULT.equals(optionValue)) {", "+\t\t\t\tthis.reportMissingJavadocCommentsVisibility = AccDefault;", "+\t\t\t} else if (PRIVATE.equals(optionValue)) {", "+\t\t\t\tthis.reportMissingJavadocCommentsVisibility = AccPrivate;", "+\t\t\t}", "+\t\t}", "+\t\tif ((optionValue = optionsMap.get(OPTION_ReportMissingJavadocCommentsOverriding)) != null) {", "+\t\t\t// TODO (frederic) see with jdt-ui whether we use ignore instead of report", "+\t\t\tif (ENABLED.equals(optionValue)) {", "+\t\t\t\t//this.reportMissingJavadocCommentsOverriding = true;", "+\t\t\t\tthis.reportMissingJavadocCommentsOverriding = false;", "+\t\t\t} else if (DISABLED.equals(optionValue)) {", "+\t\t\t\t//this.reportMissingJavadocCommentsOverriding = false;", "+\t\t\t\tthis.reportMissingJavadocCommentsOverriding = true;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5cb04fa26b9334ebcb96e8fe62335559", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "12f65faa0a3b984e9751d243a3eab6e6ab078ed7", "commitAfterChange": "36d2cf066100445cbe45dd4cf851204404f7d76f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected boolean commentParse()", "signatureAfterChange": " \tprotected boolean commentParse()", "diff": ["-\t\t\t// Init scanner position", "-\t\t\tthis.linePtr = getLineNumber(this.firstTagPosition);", "-\t\t\tint realStart = this.linePtr==1 ? javadocStart : this.scanner.getLineEnd(this.linePtr-1)+1;", "-\t\t\tif (realStart < javadocStart) realStart = javadocStart;", "-\t\t\tthis.scanner.resetTo(realStart, javadocEnd);", "-\t\t\tthis.index = realStart;", "-\t\t\tif (realStart == javadocStart) {", "-\t\t\t\treadChar(); // starting '/'", "-\t\t\t\treadChar(); // first '*'", "-\t\t\t}", "-\t\t\tint previousPosition = this.index;", "-\t\t\tchar nextCharacter = 0;", "-\t\t\tif (realStart == javadocStart) nextCharacter = readChar(); // second '*'", "-", "-\t\t\tthis.lineEnd = (this.linePtr == this.lastLinePtr) ? this.javadocEnd: this.scanner.getLineEnd(this.linePtr) - 1;", "+\t\t\tthis.spacePosition = -1;", "+\t\t\tboolean isFormatterParser = (this.kind & FORMATTER_COMMENT_PARSER) != 0;", "+", "+\t\t\t// Init scanner position", "+\t\t\tthis.linePtr = getLineNumber(this.firstTagPosition);", "+\t\t\tint realStart = this.linePtr==1 ? javadocStart : this.scanner.getLineEnd(this.linePtr-1)+1;", "+\t\t\tif (realStart < javadocStart) realStart = javadocStart;", "+\t\t\tthis.scanner.resetTo(realStart, javadocEnd);", "+\t\t\tthis.index = realStart;", "+\t\t\tif (realStart == javadocStart) {", "+\t\t\t\treadChar(); // starting '/'", "+\t\t\t\treadChar(); // first '*'", "+\t\t\t}", "+\t\t\tint previousPosition = this.index;", "+\t\t\tchar nextCharacter = 0;", "+\t\t\tif (realStart == javadocStart) {", "+\t\t\t\tnextCharacter = readChar(); // second '*'", "+\t\t\t\tthis.javadocTextStart = this.index;", "+\t\t\t}", "+\t\t\tthis.lineEnd = (this.linePtr == this.lastLinePtr) ? this.javadocEnd: this.scanner.getLineEnd(this.linePtr) - 1;", "-\t\t\t", "-\t\t\t\tif (this.index >= this.javadocEnd) {", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\t", "+", "+\t\t\t\t// Consume rules depending on the read character", "-\t\t\t\t\t\t\t\tif (this.textStart != -1 && this.textStart < previousPosition) {", "-\t\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\t\tint textEndPosition = previousPosition;", "+\t\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "-\t\t\t\t\t\t\t\tif (isDomParser) refreshInlineTagPosition(previousPosition);", "+\t\t\t\t\t\t\t\tif (this.textStart != -1 && this.textStart < textEndPosition) {", "+\t\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, textEndPosition);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (isDomParser || isFormatterParser) {", "+\t\t\t\t\t\t\t\t\trefreshInlineTagPosition(textEndPosition);", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (this.textStart != -1 && this.textStart < this.inlineTagStart) {", "-\t\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, this.inlineTagStart);", "+\t\t\t\t\t\t\t\tif (this.textStart != -1) {", "+\t\t\t\t\t\t\t\t\tint textEndPosition = this.inlineTagStart;", "+\t\t\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (this.textStart < textEndPosition) {", "+\t\t\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, textEndPosition);", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, invalidTagLineEnd);", "+\t\t\t\t\t\t\t\tint textEndPosition = invalidTagLineEnd;", "+\t\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, textEndPosition);", "-\t\t\t\t\t\tif (this.lineStarted && this.textStart < previousPosition) {", "-\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, previousPosition);", "+\t\t\t\t\t\tif (this.lineStarted) {", "+\t\t\t\t\t\t\tint textEndPosition = previousPosition;", "+\t\t\t\t\t\t\tif (isFormatterParser) {", "+\t\t\t\t\t\t\t\tif (ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.spacePosition = previousPosition;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.textStart != -1 && this.textStart < textEndPosition) {", "+\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, textEndPosition);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "-\t\t\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\t\tint textEndPosition = previousPosition;", "+\t\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "-\t\t\t\t\t\t\t\trefreshInlineTagPosition(previousPosition);", "+\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < textEndPosition) {", "+\t\t\t\t\t\t\t\t\tpushText(this.textStart, textEndPosition);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\trefreshInlineTagPosition(textEndPosition);", "-\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "-\t\t\t\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\t\tint textEndPosition = previousPosition;", "+\t\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "-\t\t\t\t\t\t\t\trefreshInlineTagPosition(previousPosition);", "+\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < textEndPosition) {", "+\t\t\t\t\t\t\t\t\tpushText(this.textStart, textEndPosition);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\trefreshInlineTagPosition(textEndPosition);", "+\t\t\t\t\t\t// Store the star position as text start while formatting", "+\t\t\t\t\t\tthis.starPosition = previousPosition;", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t// do nothing for space or '*' characters", "+\t\t\t\t\t\t// Store first space position while formatting", "+\t\t\t\t\t\tif (isFormatterParser && !ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\tthis.spacePosition = previousPosition;", "+\t\t\t\t\t\t}", "+\t\t\t\t\tcase '/':", "+\t\t\t\t\t\tif (previousChar == '*') {", "+\t\t\t\t\t\t\t// End of javadoc", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// fall through default case", "+\t\t\t\t\t\tif (isFormatterParser && nextCharacter == '<') {", "+\t\t\t\t\t\t\t// html tags are meaningful for formatter parser", "+\t\t\t\t\t\t\tint initialIndex = this.index;", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.javadocEnd);", "+\t\t\t\t\t\t\tint endTextPosition = ScannerHelper.isWhitespace(previousChar) ? this.spacePosition : previousPosition;", "+\t\t\t\t\t\t\tif (parseHtmlTag(previousPosition, endTextPosition)) {", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.abort) return false;", "+\t\t\t\t\t\t\t// Wrong html syntax continue to process character normally", "+\t\t\t\t\t\t\tthis.scanner.currentPosition = initialIndex;", "+\t\t\t\t\t\t\tthis.index = initialIndex;", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (!this.lineStarted) {", "+\t\t\t\t\t\tif (!this.lineStarted || this.textStart == -1) {", "+\t\t\tthis.javadocTextEnd = this.starPosition-1;", "+", "-\t\t\t\tthis.inlineTagStarted = false;", "-\t\t\t\t\tint end = previousPosition<invalidInlineTagLineEnd ? previousPosition : invalidInlineTagLineEnd;", "+\t\t\t\t\tint end = this.javadocTextEnd<invalidInlineTagLineEnd ? this.javadocTextEnd : invalidInlineTagLineEnd;", "-\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "-\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\tint textEndPosition = this.javadocTextEnd;", "+\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "-\t\t\t\t\trefreshInlineTagPosition(previousPosition);", "+\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < textEndPosition) {", "+\t\t\t\t\t\tpushText(this.textStart, textEndPosition);", "+\t\t\t\t\t}", "+\t\t\t\t\trefreshInlineTagPosition(textEndPosition);", "-\t\t\t} else if (pushText && this.lineStarted && this.textStart < previousPosition) {", "-\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t} else if (pushText && this.lineStarted && this.textStart != -1 && this.textStart <= this.javadocTextEnd) {", "+\t\t\t\tpushText(this.textStart, this.starPosition);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66a7d620555847d2c086b6ed486b0aed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java", "commitBeforeChange": "83b88f3849bc3529944cb5ada76e610acc101ab1", "commitAfterChange": "7eed8178809b3804cdae88d40ff2d9114bc0d206", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope upperScope)", "diff": ["-\t\t\t\tTypeBinding collectionElementType = ((ArrayBinding) collectionType).elementsType();", "+\t\t\t\tthis.collectionElementType = ((ArrayBinding) collectionType).elementsType();", "-\t\t\t\tthis.arrayElementTypeID = collectionElementType.id;", "-\t\t\t\tint compileTimeTypeID = this.arrayElementTypeID;", "+\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "-\t\t\t\t\t\t\tTypeBinding collectionElementType = parameterizedType.arguments[0]; ", "-\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)) {", "+\t\t\t\t\t\t\tthis.collectionElementType = parameterizedType.arguments[0]; ", "+\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "+\t\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "+\t\t\t\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "+\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\tif (!collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = UNBOXING;", "+\t\t\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tint boxedID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = boxedID;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tTypeBinding collectionElementType = iterableType.typeVariables()[0]; ", "-\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)) {", "+\t\t\t\t\t\t\tthis.collectionElementType = iterableType.typeVariables()[0]; ", "+\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "+\t\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "+\t\t\t\t\t\t\t// no conversion needed as only for reference types", "+\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\tif (!collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = UNBOXING;", "+\t\t\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tint boxedID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = boxedID;", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tTypeBinding collectionElementType = scope.getJavaLangObject(); ", "-\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)) {", "+\t\t\t\t\t\tthis.collectionElementType = scope.getJavaLangObject();", "+\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "+\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "-\t\t\t\t\t}", "+\t\t\t\t\t}\t\t\t    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f19550944665517eea5e36572525aa7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/impl/FormatterOptions.java", "commitBeforeChange": "d2d42dc68198e20f3f5cc7326a07cced2c751eb5", "commitAfterChange": "add5c6babb13b20df1267306ec710a4efca88a4d", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r public FormatterOptions(ConfigurableOption[] settings)", "signatureAfterChange": "\r public FormatterOptions(Map settings)", "diff": ["-public FormatterOptions(ConfigurableOption[] settings){\r", "+public FormatterOptions(Map settings){\r", "-\t// filter options which are related to the formatter component\r", "-\tString componentName = CodeFormatter.class.getName();\r", "-\tfor (int i = 0, max = settings.length; i < max; i++){\r", "-\t\tif (settings[i].getComponentName().equals(componentName)){\r", "-\t\t\tthis.setOption(settings[i]);\r", "+\t// filter options which are related to the assist component\r", "+\tObject[] entries = settings.entrySet().toArray();\r", "+\tfor (int i = 0, max = entries.length; i < max; i++){\r", "+\t\tMap.Entry entry = (Map.Entry)entries[i];\r", "+\t\tif (!(entry.getKey() instanceof String)) continue;\r", "+\t\tif (!(entry.getValue() instanceof String)) continue;\r", "+\t\tString optionID = (String) entry.getKey();\r", "+\t\tString optionValue = (String) entry.getValue();\r", "+\t\t\r", "+\t\tif(optionID.equals(OPTION_InsertNewlineBeforeOpeningBrace)){\r", "+\t\t\tif (optionValue.equals(INSERT)){\r", "+\t\t\t\tthis.newLineBeforeOpeningBraceMode = true;\r", "+\t\t\t} else if (optionValue.equals(DO_NOT_INSERT)){\r", "+\t\t\t\tthis.newLineBeforeOpeningBraceMode = false;\r", "+\t\t\t}\r", "+\t\t\tcontinue;\r", "+\t\t}\r", "+\t\tif(optionID.equals(OPTION_InsertNewlineInControlStatement)){\r", "+\t\t\tif (optionValue.equals(INSERT)){\r", "+\t\t\t\tthis.newlineInControlStatementMode = true;\r", "+\t\t\t} else if (optionValue.equals(DO_NOT_INSERT)){\r", "+\t\t\t\tthis.newlineInControlStatementMode = false;\r", "+\t\t\t}\r", "+\t\t\tcontinue;\r", "+\t\t}\r", "+\t\tif(optionID.equals(OPTION_ClearAllBlankLines)){\r", "+\t\t\tif (optionValue.equals(CLEAR_ALL)){\r", "+\t\t\t\tthis.clearAllBlankLinesMode = true;\r", "+\t\t\t} else if (optionValue.equals(PRESERVE_ONE)){\r", "+\t\t\t\tthis.clearAllBlankLinesMode = false;\r", "+\t\t\t}\r", "+\t\t\tcontinue;\r", "+\t\t}\r", "+\t\tif(optionID.equals(OPTION_InsertNewLineBetweenElseAndIf)){\r", "+\t\t\tif (optionValue.equals(INSERT)){\r", "+\t\t\t\tthis.compactElseIfMode = false;\r", "+\t\t\t} else if (optionValue.equals(DO_NOT_INSERT)){\r", "+\t\t\t\tthis.compactElseIfMode = true;\r", "+\t\t\t}\r", "+\t\t\tcontinue;\r", "+\t\t}\r", "+\t\tif(optionID.equals(OPTION_InsertNewLineInEmptyBlock)){\r", "+\t\t\tif (optionValue.equals(INSERT)){\r", "+\t\t\t\tthis.newLineInEmptyBlockMode = true;\r", "+\t\t\t} else if (optionValue.equals(DO_NOT_INSERT)){\r", "+\t\t\t\tthis.newLineInEmptyBlockMode = false;\r", "+\t\t\t}\r", "+\t\t\tcontinue;\r", "+\t\t}\r", "+\t\tif(optionID.equals(OPTION_SplitLineExceedingLength)){\r", "+\t\t\ttry {\r", "+\t\t\t\tint val = Integer.parseInt(optionValue);\r", "+\t\t\t\tif (val >= 0) this.maxLineLength = val;\r", "+\t\t\t} catch(NumberFormatException e){\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif(optionID.equals(OPTION_CompactAssignment)){\r", "+\t\t\tif (optionValue.equals(COMPACT)){\r", "+\t\t\t\tthis.compactAssignmentMode = true;\r", "+\t\t\t} else if (optionValue.equals(NORMAL)){\r", "+\t\t\t\tthis.compactAssignmentMode = false;\r", "+\t\t\t}\r", "+\t\t\tcontinue;\r", "+\t\t}\r", "+\t\tif(optionID.equals(OPTION_TabulationChar)){\r", "+\t\t\tif (optionValue.equals(TAB)){\r", "+\t\t\t\tthis.indentWithTab = true;\r", "+\t\t\t} else if (optionValue.equals(SPACE)){\r", "+\t\t\t\tthis.indentWithTab = false;\r", "+\t\t\t}\r", "+\t\t\tcontinue;\r", "+\t\t}\r", "+\t\tif(optionID.equals(OPTION_TabulationSize)){\r", "+\t\t\ttry {\r", "+\t\t\t\tint val = Integer.parseInt(optionValue);\r", "+\t\t\t\tif (val > 0) this.tabSize = val;\r", "+\t\t\t} catch(NumberFormatException e){\r", "+\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "946ff6c6bc90c90ff2b72808371e45c5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PackageReferencePattern.java", "commitBeforeChange": "948661c4cb198af70b598b9954e5159cb73d7234", "commitAfterChange": "b1348e3d0230a581c7eb25acd6ec072853b12bb0", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": "\r protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "diff": ["-\tchar[][] splitName = CharOperation.splitOn('.', \r", "-\t\tthis.pkgName == null ? \r", "-\t\t\tnew char[0] :\r", "-\t\t\tthis.pkgName);\r", "-\tlocator.reportAccurateReference(reference.sourceStart, reference.sourceEnd, splitName, element, accuracy);\r", "+\tchar[][] tokens = null;\r", "+\tif (reference instanceof ImportReference) {\r", "+\t\tImportReference importRef = (ImportReference)reference;\r", "+\t\tif (importRef.onDemand) {\r", "+\t\t\ttokens = importRef.tokens;\r", "+\t\t} else {\r", "+\t\t\tint length = importRef.tokens.length - 1;\r", "+\t\t\ttokens = new char[length][];\r", "+\t\t\tSystem.arraycopy(importRef.tokens, 0, tokens, 0, length);\r", "+\t\t}\r", "+\t} else if (reference instanceof QualifiedNameReference) {\r", "+\t\tQualifiedNameReference qNameRef = (QualifiedNameReference)reference;\r", "+\t\tBinding binding = qNameRef.binding;\r", "+\t\tTypeBinding typeBinding = null;\r", "+\t\tswitch (qNameRef.bits & AstNode.RestrictiveFlagMASK) {\r", "+\t\t\tcase BindingIds.FIELD : // reading a field\r", "+\t\t\t\ttypeBinding = ((FieldBinding)binding).declaringClass;\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase BindingIds.TYPE : //=============only type ==============\r", "+\t\t\t\ttypeBinding = (TypeBinding)binding;\r", "+\t\t}\r", "+\t\tif (typeBinding instanceof ReferenceBinding) {\r", "+\t\t\tPackageBinding pkgBinding = ((ReferenceBinding)typeBinding).fPackage;\r", "+\t\t\tif (pkgBinding != null) {\r", "+\t\t\t\ttokens = pkgBinding.compoundName;\r", "+\t\t\t}\r", "+\t\t} \r", "+\t\tif (tokens == null) {\r", "+\t\t\ttokens = qNameRef.tokens;\r", "+\t\t}\r", "+\t} else if (reference instanceof QualifiedTypeReference) {\r", "+\t\tQualifiedTypeReference qTypeRef = (QualifiedTypeReference)reference;\r", "+\t\tTypeBinding typeBinding = qTypeRef.binding;\r", "+\t\tif (typeBinding instanceof ArrayBinding) {\r", "+\t\t\ttypeBinding = ((ArrayBinding)typeBinding).leafComponentType;\r", "+\t\t}\r", "+\t\tif (typeBinding instanceof ReferenceBinding) {\r", "+\t\t\tPackageBinding pkgBinding = ((ReferenceBinding)typeBinding).fPackage;\r", "+\t\t\tif (pkgBinding != null) {\r", "+\t\t\t\ttokens = pkgBinding.compoundName;\r", "+\t\t\t}\r", "+\t\t} \r", "+\t\tif (tokens == null) {\r", "+\t\t\ttokens = qTypeRef.tokens;\r", "+\t\t}\r", "+\t}\r", "+\tif (tokens == null) tokens = NO_CHAR_CHAR;\r", "+\tlocator.reportAccurateReference(reference.sourceStart, reference.sourceEnd, tokens, element, accuracy);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b8f507b013c7ef31d1803607da2e0211", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java", "commitBeforeChange": "3e28b00b3ff1ea2877f4a4e8b245ac6023e86b59", "commitAfterChange": "52e6fbe49c09ab2aed24d8a25448612c4ab36bce", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \t \tpublic void set(Map optionsMap)", "signatureAfterChange": " \t \tpublic void set(Map optionsMap)", "diff": ["+\t\tif ((optionValue = optionsMap.get(OPTION_ImportRestrictionInclude)) != null) {", "+\t\t\tif (optionValue instanceof String) {", "+\t\t\t\tString stringValue = (String) optionValue;", "+\t\t\t\tif (stringValue.length() == 0) {", "+\t\t\t\t\tthis.importRestrictionInclude = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.importRestrictionInclude = CharOperation.splitAndTrimOn(',', stringValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}\t", "+\t\tif ((optionValue = optionsMap.get(OPTION_ImportRestrictionExclude)) != null) {", "+\t\t\tif (optionValue instanceof String) {", "+\t\t\t\tString stringValue = (String) optionValue;", "+\t\t\t\tif (stringValue.length() == 0) {", "+\t\t\t\t\tthis.importRestrictionExclude = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.importRestrictionExclude = CharOperation.splitAndTrimOn(',', stringValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}\t\t\t", "+\t\tif ((optionValue = optionsMap.get(OPTION_ExportRestrictionInclude)) != null) {", "+\t\t\tif (optionValue instanceof String) {", "+\t\t\t\tString stringValue = (String) optionValue;", "+\t\t\t\tif (stringValue.length() == 0) {", "+\t\t\t\t\tthis.exportRestrictionInclude = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.exportRestrictionInclude = CharOperation.splitAndTrimOn(',', stringValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}\t\t\t", "+\t\tif ((optionValue = optionsMap.get(OPTION_ExportRestrictionExclude)) != null) {", "+\t\t\tif (optionValue instanceof String) {", "+\t\t\t\tString stringValue = (String) optionValue;", "+\t\t\t\tif (stringValue.length() == 0) {", "+\t\t\t\t\tthis.exportRestrictionExclude = null;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.exportRestrictionExclude = CharOperation.splitAndTrimOn(',', stringValue.toCharArray());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "db7f1a5129cd873d51a356210525db56", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "99b0ee0a94dea46a82c44b5f56daa5fcb74d2ad6", "commitAfterChange": "039fe9e46951f3ae4fb135033e62de597c68c2d9", "methodNumberBeforeChange": 108, "methodNumberAfterChange": 108, "signatureBeforeChange": " \t \tprivate void recordNodes(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, TagElement tagElement)", "signatureAfterChange": " \t \tprivate void recordNodes(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, TagElement tagElement)", "diff": ["-\t\t\t\tName name = ((MemberRef)node).getName();", "+\t\t\t\tMemberRef memberRef = (MemberRef) node;", "+\t\t\t\tName name = memberRef.getName();", "+\t\t\t\t// get compiler node and record nodes", "-\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode compilerNode = javadoc.getNodeStartingAt(start);", "-\t\t\t\tif (compilerNode != null) {", "-\t\t\t\t\trecordNodes(node, compilerNode);", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.JavadocFieldReference fieldRef = (org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference) javadoc.getNodeStartingAt(start);", "+\t\t\t\tif (fieldRef != null) {", "+\t\t\t\t\trecordNodes(name, fieldRef);", "+\t\t\t\t\trecordNodes(node, fieldRef);", "-\t\t\t} else if (node.getNodeType() == ASTNode.METHOD_REF ||", "-\t\t\t\t\tnode.getNodeType() == ASTNode.SIMPLE_NAME ||", "+\t\t\t\t// Replace qualifier to have all nodes recorded", "+\t\t\t\tif (memberRef.getQualifier() != null) {", "+\t\t\t\t\tmemberRef.setQualifier(convert((org.eclipse.jdt.internal.compiler.ast.TypeReference) fieldRef.receiver));", "+\t\t\t\t}", "+\t\t\t} else if (node.getNodeType() == ASTNode.METHOD_REF) {", "+\t\t\t\tMethodRef methodRef = (MethodRef) node;", "+\t\t\t\t// get compiler node and record nodes", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode compilerNode = javadoc.getNodeStartingAt(node.getStartPosition());", "+\t\t\t\tif (compilerNode != null) {", "+\t\t\t\t\trecordNodes(methodRef.getName(), compilerNode);", "+\t\t\t\t\trecordNodes(methodRef, compilerNode);", "+\t\t\t\t}", "+\t\t\t\t// Replace qualifier to have all nodes recorded", "+\t\t\t\tif (methodRef.getQualifier() != null) {", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeReference typeRef = null;", "+\t\t\t\t\tif (compilerNode instanceof org.eclipse.jdt.internal.compiler.ast.JavadocAllocationExpression) {", "+\t\t\t\t\t\ttypeRef = ((org.eclipse.jdt.internal.compiler.ast.JavadocAllocationExpression)compilerNode).type;", "+\t\t\t\t\t} ", "+\t\t\t\t\telse if (compilerNode instanceof org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend) {", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression expression = ((org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend)compilerNode).receiver;", "+\t\t\t\t\t\tif (expression instanceof org.eclipse.jdt.internal.compiler.ast.TypeReference) {", "+\t\t\t\t\t\t\ttypeRef = (org.eclipse.jdt.internal.compiler.ast.TypeReference) expression;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\tmethodRef.setQualifier(convert(typeRef));", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else if (node.getNodeType() == ASTNode.SIMPLE_NAME ||", "+\t\t\t\t\tif (compilerNode instanceof org.eclipse.jdt.internal.compiler.ast.TypeReference) {", "+//\t\t\t\t\t\tconvert((org.eclipse.jdt.internal.compiler.ast.TypeReference) compilerNode);", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeReference typeRef = (org.eclipse.jdt.internal.compiler.ast.TypeReference) compilerNode;", "+\t\t\t\t\t\tName name = (Name) node;", "+\t\t\t\t\t\tif (name.isQualifiedName()) {", "+\t\t\t\t\t\t\tSimpleName simpleName = null;", "+\t\t\t\t\t\t\twhile (name.isQualifiedName()) {", "+\t\t\t\t\t\t\t\tsimpleName = ((QualifiedName) name).getName();", "+\t\t\t\t\t\t\t\trecordNodes(simpleName, typeRef);", "+\t\t\t\t\t\t\t\tname = ((QualifiedName) name).getQualifier();", "+\t\t\t\t\t\t\t\trecordNodes(name, typeRef);", "+\t\t\t\t\t\t\t}", "+//\t\t\t\t\t\t\tsimpleName = ((QualifiedName) name).getName();", "+//\t\t\t\t\t\t\trecordNodes(simpleName, typeRef);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f119430c6b4297f0b900d56e9cfef8e7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "24134b187b46ea16212a45107324227f46ba3e4a", "commitAfterChange": "496121d0ad975842fb45544aac592b8195531ce7", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 38, "signatureBeforeChange": "  \tprivate void printBlockComment(char[] s, boolean isJavadoc)", "signatureAfterChange": "  \tprivate void printBlockComment(char[] s, boolean isJavadoc)", "diff": ["-\t\tprintIndentationIfNecessary();", "+\t\tint previousStart = currentTokenStartPosition;", "+\t\tboolean onFirstColumn = isOnFirstColumn(start);", "+", "+\t\tboolean indentComment = false;", "+\t\tif (this.indentationLevel != 0) {", "+\t\t\tif (isJavadoc", "+\t\t\t\t\t|| !this.formatter.preferences.never_indent_block_comments_on_first_column", "+\t\t\t\t\t|| !onFirstColumn) {", "+\t\t\t\tindentComment = true;", "+\t\t\t\tprintIndentationIfNecessary();", "+\t\t\t}", "+\t\t}", "-\t\tthis.needSpace = false;\t\t", "-\t\tthis.pendingSpace = false;\t\t", "-\t\tint previousStart = currentTokenStartPosition;", "+\t\tthis.needSpace = false;", "+\t\tthis.pendingSpace = false;", "+", "+\t\tint currentCommentOffset = onFirstColumn ? 0 : getCurrentCommentOffset(start);", "+\t\tboolean formatComment = (isJavadoc && formatJavadocComment) || (!isJavadoc && formatBlockComment);", "+\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "-\t\t\t\t\t\tif (ScannerHelper.isWhitespace((char) currentCharacter)) {", "-\t\t\t\t\t\t\tint previousStartPosition = this.scanner.currentPosition;", "-\t\t\t\t\t\t\twhile(currentCharacter != -1 && currentCharacter != '\\r' && currentCharacter != '\\n' && ScannerHelper.isWhitespace((char) currentCharacter)) {", "-\t\t\t\t\t\t\t\tpreviousStart = nextCharacterStart;", "-\t\t\t\t\t\t\t\tpreviousStartPosition = this.scanner.currentPosition;", "-\t\t\t\t\t\t\t\tcurrentCharacter = this.scanner.getNextChar();", "-\t\t\t\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (currentCharacter == '\\r' || currentCharacter == '\\n') {", "-\t\t\t\t\t\t\t\tnextCharacterStart = previousStartPosition;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-", "+\t\t\t\t\t\tisNewLine = false;", "+\t\t\t\t\t\t", "-\t\t\t\t\t\tbuffer.append(this.lineSeparator);", "-\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "-\t\t\t\t\t\tbuffer.append(' ');", "-\t\t\t\t", "+\t\t\t\t\t\tif (onFirstColumn) {", "+\t\t\t\t\t\t\t// simply insert indentation if necessary", "+\t\t\t\t\t\t\tbuffer.append(this.lineSeparator);", "+\t\t\t\t\t\t\tif (indentComment) {", "+\t\t\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (formatComment) {", "+\t\t\t\t\t\t\t\tif (ScannerHelper.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\t\t\tint previousStartPosition = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\t\twhile(currentCharacter != -1 && currentCharacter != '\\r' && currentCharacter != '\\n' && ScannerHelper.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\t\t\t\tpreviousStart = nextCharacterStart;", "+\t\t\t\t\t\t\t\t\t\tpreviousStartPosition = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\t\t\tcurrentCharacter = this.scanner.getNextChar();", "+\t\t\t\t\t\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (currentCharacter == '\\r' || currentCharacter == '\\n') {", "+\t\t\t\t\t\t\t\t\t\tnextCharacterStart = previousStartPosition;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (currentCharacter != '\\r' && currentCharacter != '\\n') {", "+\t\t\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (ScannerHelper.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\t\tint previousStartPosition = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\tint count = 0;", "+\t\t\t\t\t\t\t\tloop: while(currentCharacter != -1 && currentCharacter != '\\r' && currentCharacter != '\\n' && ScannerHelper.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\t\t\tif (count >= currentCommentOffset) {", "+\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tpreviousStart = nextCharacterStart;", "+\t\t\t\t\t\t\t\t\tpreviousStartPosition = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\t\tswitch(currentCharacter) {", "+\t\t\t\t\t\t\t\t\t\tcase '\\t' :", "+\t\t\t\t\t\t\t\t\t\t\tcount += this.tabLength;", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\t\t\t\t\tcount ++;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tcurrentCharacter = this.scanner.getNextChar();", "+\t\t\t\t\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (currentCharacter == '\\r' || currentCharacter == '\\n') {", "+\t\t\t\t\t\t\t\t\tnextCharacterStart = previousStartPosition;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbuffer.append(this.lineSeparator);", "+\t\t\t\t\t\t\tif (indentComment) {", "+\t\t\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (formatComment) {", "+\t\t\t\t\t\t\t\tint previousStartTemp = previousStart;", "+\t\t\t\t\t\t\t\tint nextCharacterStartTemp = nextCharacterStart;", "+\t\t\t\t\t\t\t\twhile(currentCharacter != -1 && currentCharacter != '\\r' && currentCharacter != '\\n' && ScannerHelper.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\t\t\tpreviousStart = nextCharacterStart;", "+\t\t\t\t\t\t\t\t\tcurrentCharacter = this.scanner.getNextChar();", "+\t\t\t\t\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (currentCharacter == '*') {", "+\t\t\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tpreviousStart = previousStartTemp;", "+\t\t\t\t\t\t\t\t\tnextCharacterStart = nextCharacterStartTemp;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tthis.scanner.currentPosition = nextCharacterStart;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\t\tisNewLine = false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f85138dd0a8e970f74b28270e6dd17ea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "03f4a4782f5839bc6b71dbdaa61bddb7d624d757", "commitAfterChange": "d9449e8887bdabd52ba7a1ff8609baf4e6dc9497", "methodNumberBeforeChange": 108, "methodNumberAfterChange": 108, "signatureBeforeChange": " \t \tprivate BlockScope lookupScope(ASTNode node)", "signatureAfterChange": " \t \tprivate BlockScope lookupScope(ASTNode node)", "diff": ["-\t\t\twhile(!(currentNode instanceof TypeDeclaration)) {", "+\t\t\twhile(!(currentNode instanceof AbstractTypeDeclaration)) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDecl = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) this.ast.getBindingResolver().getCorrespondingNode(currentNode);", "-\t\t\tif ((initializer.getModifiers() & Modifier.STATIC) != 0) {", "-\t\t\t\treturn typeDecl.staticInitializerScope;", "-\t\t\t} else {", "-\t\t\t\treturn typeDecl.initializerScope;", "+\t\t\tif (currentNode instanceof TypeDeclaration) {", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDecl = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) this.ast.getBindingResolver().getCorrespondingNode(currentNode);", "+\t\t\t\tif ((initializer.getModifiers() & Modifier.STATIC) != 0) {", "+\t\t\t\t\treturn typeDecl.staticInitializerScope;", "+\t\t\t\t} else {", "+\t\t\t\t\treturn typeDecl.initializerScope;", "+\t\t\t\t}", "+\t\t\t} else if (currentNode instanceof EnumDeclaration) {", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.EnumDeclaration enumDecl = (org.eclipse.jdt.internal.compiler.ast.EnumDeclaration) this.ast.getBindingResolver().getCorrespondingNode(currentNode);", "+\t\t\t\tif ((initializer.getModifiers() & Modifier.STATIC) != 0) {", "+\t\t\t\t\treturn enumDecl.staticInitializerScope;", "+\t\t\t\t} else {", "+\t\t\t\t\treturn enumDecl.initializerScope;", "+\t\t\t\t}", "+\t\t\t} else if (currentNode instanceof AnnotationTypeDeclaration) {", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.AnnotationTypeDeclaration annotationTypeDecl = (org.eclipse.jdt.internal.compiler.ast.AnnotationTypeDeclaration) this.ast.getBindingResolver().getCorrespondingNode(currentNode);", "+\t\t\t\tif ((initializer.getModifiers() & Modifier.STATIC) != 0) {", "+\t\t\t\t\treturn annotationTypeDecl.staticInitializerScope;", "+\t\t\t\t} else {", "+\t\t\t\t\treturn annotationTypeDecl.initializerScope;", "+\t\t\t\t}", "-\t\t\twhile(!(currentNode instanceof TypeDeclaration)) {", "+\t\t\twhile(!(currentNode instanceof AbstractTypeDeclaration)) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDecl = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) this.ast.getBindingResolver().getCorrespondingNode(currentNode);", "-\t\t\tif ((fieldDeclaration.getModifiers() & Modifier.STATIC) != 0) {", "-\t\t\t\treturn typeDecl.staticInitializerScope;", "-\t\t\t} else {", "-\t\t\t\treturn typeDecl.initializerScope;", "+\t\t\tif (currentNode instanceof TypeDeclaration) {", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDecl = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) this.ast.getBindingResolver().getCorrespondingNode(currentNode);", "+\t\t\t\tif ((fieldDeclaration.getModifiers() & Modifier.STATIC) != 0) {", "+\t\t\t\t\treturn typeDecl.staticInitializerScope;", "+\t\t\t\t} else {", "+\t\t\t\t\treturn typeDecl.initializerScope;", "+\t\t\t\t}", "+\t\t\t} else if (currentNode instanceof EnumDeclaration) {", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.EnumDeclaration enumDecl = (org.eclipse.jdt.internal.compiler.ast.EnumDeclaration) this.ast.getBindingResolver().getCorrespondingNode(currentNode);", "+\t\t\t\tif ((fieldDeclaration.getModifiers() & Modifier.STATIC) != 0) {", "+\t\t\t\t\treturn enumDecl.staticInitializerScope;", "+\t\t\t\t} else {", "+\t\t\t\t\treturn enumDecl.initializerScope;", "+\t\t\t\t}", "+\t\t\t} else if (currentNode instanceof AnnotationTypeDeclaration) {", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.AnnotationTypeDeclaration annotationTypeDecl = (org.eclipse.jdt.internal.compiler.ast.AnnotationTypeDeclaration) this.ast.getBindingResolver().getCorrespondingNode(currentNode);", "+\t\t\t\tif ((fieldDeclaration.getModifiers() & Modifier.STATIC) != 0) {", "+\t\t\t\t\treturn annotationTypeDecl.staticInitializerScope;", "+\t\t\t\t} else {", "+\t\t\t\t\treturn annotationTypeDecl.initializerScope;", "+\t\t\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fd7cdfca03e82dfc3d0c7a1c0bdac87c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "0f7f9d63e5fbc5d41771bd4e2e39b628130add76", "commitAfterChange": "ed4cdf5cf5dec0284dce12a661248f2f9a27a709", "methodNumberBeforeChange": 58, "methodNumberAfterChange": 58, "signatureBeforeChange": "  \tprivate void printLineComment(int commentStart, int commentEnd)", "signatureAfterChange": "  \tprivate void printLineComment(int commentStart, int commentEnd)", "diff": ["-\t\tthis.indentationLevel = getNextIndentationLevel(firstColumn);", "+\t\tthis.indentationLevel = (this.column / this.tabLength) * this.tabLength;", "+\t\tStringBuffer tokensBuffer = new StringBuffer();", "+\t\tboolean bufferHasTokens = false;", "-\t\t\t\tString msg = iie.getMessage();", "-\t\t\t\tif (msg == Scanner.INVALID_CHARACTER_CONSTANT) {", "-\t\t\t\t\tbuffer.append('\\'');", "-\t\t\t\t} else if (msg == Scanner.INVALID_CHAR_IN_STRING) {", "-\t\t\t\t\tbuffer.append('\"');", "-\t\t\t\t} else {", "-\t\t\t\t\t// skip failure", "-\t\t\t\t}", "-\t\t\t\t// Need to retrieve correct position", "+\t    \t\tif (previousToken == -1 || previousToken == TerminalTokens.TokenNameWHITESPACE) {", "+\t    \t\t\ttokensBuffer.append(' ');", "+\t    \t\t}", "-\t\t\t\tthis.scanner.getNextChar();", "-\t\t\t\tthis.column++;", "+\t    \t\tchar ch = (char) this.scanner.getNextChar();", "+\t\t\t\tpreviousToken = TerminalTokens.TokenNameWHITESPACE;", "+\t\t\t\twhile (!ScannerHelper.isWhitespace(ch)) {", "+\t\t\t\t\ttokensBuffer.append(ch);", "+\t\t\t\t\tif (this.scanner.atEnd()) {", "+\t\t\t\t\t\tpreviousToken = TerminalTokens.TokenNameEOF;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tch = (char) this.scanner.getNextChar();", "+\t\t\t\t}", "+\t\t\t\t\tif (tokensBuffer.length() > 0) {", "+\t\t\t\t\t\tbuffer.append(tokensBuffer);", "+\t\t\t\t\t\tthis.column += tokensBuffer.length();", "+\t\t\t\t\t\ttokensBuffer.setLength(0);", "+\t\t\t\t\t\tbufferHasTokens = true;", "+\t\t\t\t\t}", "-    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE;", "-\t\t\tthis.column += tokenLength;", "-    \t\tif (previousToken == -1 || insertSpace) this.column++;", "-    \t\tint col = column; ", "-\t\t\tif (!firstWord && col > maxColumn) {", "+    \t\tboolean insertSpace = previousToken == -1 || previousToken == TerminalTokens.TokenNameWHITESPACE;", "+    \t\tint lastColumn = this.column + tokensBuffer.length() + tokenLength;", "+    \t\tif (insertSpace) lastColumn++;", "+\t\t\tif (!firstWord && lastColumn > maxColumn) {", "-\t\t    \tbuffer.append(this.lineSeparator);", "-\t\t    \tthis.column = 1;", "-\t\t    \tprintIndentationIfNecessary(buffer);", "-\t    \t\tbuffer.append(LINE_COMMENT_PREFIX);", "-\t\t    \tthis.column = firstColumn + LINE_COMMENT_PREFIX_LENGTH;", "+\t\t\t\tif ((firstColumn+tokensBuffer.length()+tokenLength) > maxColumn) {", "+\t\t\t\t\t// there won't be enough room even if we break the line before the buffered tokens", "+\t\t\t\t\t// So add the buffered tokens now", "+\t\t\t\t\tbuffer.append(tokensBuffer);", "+\t\t\t\t\tthis.column += tokensBuffer.length();", "+\t\t\t\t\ttokensBuffer.setLength(0);", "+\t\t\t\t\tbufferHasTokens = true;", "+\t\t\t\t}", "+\t\t\t\tif (bufferHasTokens) {", "+\t\t\t    \tbuffer.append(this.lineSeparator);", "+\t\t\t    \tthis.column = 1;", "+\t\t\t    \tprintIndentationIfNecessary(buffer);", "+\t    \t\t\tbuffer.append(LINE_COMMENT_PREFIX);", "+\t\t    \t\tthis.column += LINE_COMMENT_PREFIX_LENGTH;", "+\t\t\t\t}", "+\t\t    \tif (tokensBuffer.length() > 0) {", "+\t\t    \t\tif (ScannerHelper.isWhitespace(tokensBuffer.charAt(0))) {", "+\t\t\t\t\t\tbuffer.append(tokensBuffer.substring(1));", "+\t\t\t\t\t\tthis.column += tokensBuffer.length() - 1;", "+\t\t    \t\t} else {", "+\t\t\t\t\t\tbuffer.append(tokensBuffer);", "+\t\t\t\t\t\tthis.column += tokensBuffer.length();", "+\t\t    \t\t}", "+\t\t\t\t\ttokensBuffer.setLength(0);", "+\t\t\t\t\tif (insertSpace)  {", "+\t\t    \t\t\tbuffer.append(' ');", "+\t\t    \t\t\tthis.column++;", "+\t\t\t\t\t}", "+\t\t    \t}", "+\t\t\t\tbufferHasTokens = true;", "+\t\t\t\tfirstColumn = this.indentationLevel + LINE_COMMENT_PREFIX_LENGTH;", "-\t\t\t\tif (previousToken == -1 || insertSpace)  {", "-\t    \t\t\tbuffer.append(' ');", "+\t\t\t\tif (insertSpace)  {", "+\t    \t\t\ttokensBuffer.append(' ');", "-\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "+\t\t\t\ttokensBuffer.append(this.scanner.source, tokenStart, tokenLength);", "+\t\t}", "+", "+\t\t// Add remaining buffered tokens", "+\t\tif (tokensBuffer.length() > 0) {", "+\t\t\tbuffer.append(tokensBuffer);", "+\t\t\tthis.column += tokensBuffer.length();"]}], "num": 52066}