{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5a4149abd547e2d3b455482a0de3fe61", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "29e8a4ebc9986410155d61175cf94f2f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java", "commitBeforeChange": "c06e07ca77c0b109ce7d4e6c3f60180a3777bc7d", "commitAfterChange": "a1d61f4860d08002c8a193d70dccc7a85c870208", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tint depth = 0;", "-\t\tthis.currentCompatibleType = scope.referenceType().binding;", "-\t\twhile (this.currentCompatibleType != null && this.currentCompatibleType != type) {", "-\t\t\tdepth++;", "-\t\t\tthis.currentCompatibleType = this.currentCompatibleType.isStatic() ? null : this.currentCompatibleType.enclosingType();", "-\t\t}", "+\t\tint depth = findCompatibleEnclosing(scope.referenceType().binding, type);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2c539e2809de270341db296fa4fb4a08", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "aabd59e4934a861167bc5ad69597bc9fd97e06dc", "commitAfterChange": "4ed2786f22dd00c9c1f7773433c3548c8c0f6fc3", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tboolean readToken(int expectedTokenType) throws InvalidInputException", "signatureAfterChange": "\t \t \tprivate int readConsumeToken() throws InvalidInputException", "diff": ["-\t */", "-\tboolean readToken(int expectedTokenType) throws InvalidInputException {", "-\t\tif (this.currentTokenType < 0) this.currentTokenType = this.scanner.getNextToken();", "-\t\tif (this.currentTokenType == expectedTokenType) {", "-\t\t\tthis.consumeToken();", "-\t\t\treturn true;", "-\t\t} ", "-\t\treturn false;", "-\t}", "+\tprivate int readConsumeToken() throws InvalidInputException {", "+\t\tint token = readToken();", "+\t\tconsumeToken();", "+\t\treturn token;", "+\t}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "30f471510894e7106fa63dd93ee9d11e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ReconcileWorkingCopyOperation.java", "commitBeforeChange": "8bea847412c36874664a80a329bfe627deff5fa9", "commitAfterChange": "c4145c80a504c8681f4571ff2bd214b778e87107", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected void executeOperation() throws JavaModelException", "signatureAfterChange": " \tprotected void executeOperation() throws JavaModelException", "diff": ["-\t\tif (this.progressMonitor != null) {", "-\t\t\tif (this.progressMonitor.isCanceled()) ", "-\t\t\t\tthrow new OperationCanceledException();", "-\t\t\tthis.progressMonitor.beginTask(Messages.element_reconciling, 2); ", "-\t\t}", "-\t", "-\t\tCompilationUnit workingCopy = getWorkingCopy();", "-\t\tboolean wasConsistent = workingCopy.isConsistent();", "-\t\tIProblemRequestor problemRequestor = workingCopy.getPerWorkingCopyInfo();", "-\t\tthis.resolveBindings |= problemRequestor != null && problemRequestor.isActive();", "-\t\t", "-\t\t// create the delta builder (this remembers the current content of the cu)", "-\t\tthis.deltaBuilder = new JavaElementDeltaBuilder(workingCopy);", "-\t\t", "-\t\t// make working copy consistent if needed and compute AST if needed", "-\t\tmakeConsistent(workingCopy, problemRequestor);", "-\t\t", "-\t\t// notify reconcile participants", "-\t\tnotifyParticipants(workingCopy);", "-\t\t", "-\t\t// recreate ast if needed", "-\t\tif (this.ast == null && (this.astLevel > ICompilationUnit.NO_AST || this.resolveBindings))", "-\t\t\tmakeConsistent(workingCopy, problemRequestor);", "-\t", "-\t\t// report problems", "-\t\tif (this.problems != null && (this.forceProblemDetection || !wasConsistent)) {", "-\t\t\ttry {", "-\t\t\t\tproblemRequestor.beginReporting();", "-\t\t\t\tfor (Iterator iteraror = this.problems.values().iterator(); iteraror.hasNext();) {", "-\t\t\t\t\tCategorizedProblem[] categorizedProblems = (CategorizedProblem[]) iteraror.next();", "-\t\t\t\t\tif (categorizedProblems == null) continue;", "-\t\t\t\t\tfor (int i = 0, length = categorizedProblems.length; i < length; i++) {", "-\t\t\t\t\t\tCategorizedProblem problem = categorizedProblems[i];", "-\t\t\t\t\t\tif (JavaModelManager.VERBOSE){", "-\t\t\t\t\t\t\tSystem.out.println(\"PROBLEM FOUND while reconciling : \" + problem.getMessage());//$NON-NLS-1$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) break;", "-\t\t\t\t\t\tproblemRequestor.acceptProblem(problem);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} finally {", "-\t\t\t\tproblemRequestor.endReporting();", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// report delta", "+\t\tcheckCanceled();", "+\t\t\tbeginTask(Messages.element_reconciling, 2); ", "+\t", "+\t\t\tCompilationUnit workingCopy = getWorkingCopy();", "+\t\t\tboolean wasConsistent = workingCopy.isConsistent();", "+\t\t\tIProblemRequestor problemRequestor = workingCopy.getPerWorkingCopyInfo();", "+\t\t\tthis.resolveBindings |= problemRequestor != null && problemRequestor.isActive();", "+\t\t\t", "+\t\t\t// create the delta builder (this remembers the current content of the cu)", "+\t\t\tthis.deltaBuilder = new JavaElementDeltaBuilder(workingCopy);", "+\t\t\t", "+\t\t\t// make working copy consistent if needed and compute AST if needed", "+\t\t\tmakeConsistent(workingCopy, problemRequestor);", "+\t\t\t", "+\t\t\t// notify reconcile participants", "+\t\t\tnotifyParticipants(workingCopy);", "+\t\t\t", "+\t\t\t// recreate ast if needed", "+\t\t\tif (this.ast == null && (this.astLevel > ICompilationUnit.NO_AST || this.resolveBindings))", "+\t\t\t\tmakeConsistent(workingCopy, problemRequestor);", "+\t\t", "+\t\t\t// report problems", "+\t\t\tif (this.problems != null && (this.forceProblemDetection || !wasConsistent)) {", "+\t\t\t\ttry {", "+\t\t\t\t\tproblemRequestor.beginReporting();", "+\t\t\t\t\tfor (Iterator iteraror = this.problems.values().iterator(); iteraror.hasNext();) {", "+\t\t\t\t\t\tCategorizedProblem[] categorizedProblems = (CategorizedProblem[]) iteraror.next();", "+\t\t\t\t\t\tif (categorizedProblems == null) continue;", "+\t\t\t\t\t\tfor (int i = 0, length = categorizedProblems.length; i < length; i++) {", "+\t\t\t\t\t\t\tCategorizedProblem problem = categorizedProblems[i];", "+\t\t\t\t\t\t\tif (JavaModelManager.VERBOSE){", "+\t\t\t\t\t\t\t\tSystem.out.println(\"PROBLEM FOUND while reconciling : \" + problem.getMessage());//$NON-NLS-1$", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) break;", "+\t\t\t\t\t\t\tproblemRequestor.acceptProblem(problem);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} finally {", "+\t\t\t\t\tproblemRequestor.endReporting();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\t// report delta", "-\t\t\tif (this.progressMonitor != null) this.progressMonitor.done();", "+\t\t\tdone();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "626ba6ae313a55c64a89fa701114441b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "fd4873f8881450efaceb482ead403702f0b3cd50", "commitAfterChange": "efd7cd38b35f875ede44936aed68717b93ca608e", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 12, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["-\tboolean skipInheritedMethods = mustImplementAbstractMethods && this.type.superInterfaces() == NoSuperInterfaces", "-\t\t&& this.type.superclass() != null && !this.type.superclass().isAbstract(); // have a single concrete superclass so only check overridden methods", "+\tboolean skipInheritedMethods = mustImplementAbstractMethods && canSkipInheritedMethods(); // have a single concrete superclass so only check overridden methods", "-\t\t\t\t\tif (otherInheritedMethod != null && otherInheritedMethod.declaringClass != inheritedMethod.declaringClass) { // must be from a different class for their params to be equal", "-\t\t\t\t\t\totherInheritedMethod = computeSubstituteMethod(otherInheritedMethod, inheritedMethod);", "-\t\t\t\t\t\tif (areMethodsEqual(inheritedMethod, otherInheritedMethod)) {", "-\t\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "-\t\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "-\t\t\t\t\t\t}", "+\t\t\t\t\tif (canSkipInheritedMethods(inheritedMethod, otherInheritedMethod))", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\totherInheritedMethod = computeSubstituteMethod(otherInheritedMethod, inheritedMethod);", "+\t\t\t\t\tif (areMethodsEqual(inheritedMethod, otherInheritedMethod)) {", "+\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "+\t\t\t\t\t\tinherited[j] = null; // do not want to find it again"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fe4cd92b9aa9d4a11e1250c8b00a976c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "d644fbac5b6fa9c32824a6e9c1731fdea560370f", "commitAfterChange": "a2ea211548ddb7d816d913062440866fd92fd6cc", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t\tpublic IPackageFragmentRoot getPackageFragmentRoot(IResource resource)", "signatureAfterChange": " \t\tpublic IPackageFragmentRoot getPackageFragmentRoot()", "diff": ["+\t\t}", "+\t\tpublic IPackageFragmentRoot getPackageFragmentRoot() {", "+\t\t\tIPackageFragmentRoot tRoot = null;", "+\t\t\tObject target = JavaModel.getTarget(this.rootPath, false/*don't check existence*/);", "+\t\t\tif (target instanceof IResource) {", "+\t\t\t\ttRoot = this.project.getPackageFragmentRoot((IResource)target);", "+\t\t\t} else {", "+\t\t\t\ttRoot = this.project.getPackageFragmentRoot(this.rootPath.toOSString());", "+\t\t\t}", "+\t\t\treturn tRoot;", "-\t\t\t\t\tObject target = JavaModel.getTarget(this.rootPath, false/*don't check existence*/);", "-\t\t\t\t\tif (target instanceof IResource) {", "-\t\t\t\t\t\tthis.root = this.project.getPackageFragmentRoot((IResource)target);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tthis.root = this.project.getPackageFragmentRoot(this.rootPath.toOSString());", "-\t\t\t\t\t}"]}], "num": 23460}