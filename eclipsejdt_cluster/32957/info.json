{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b911539a7697009a774e194b87c35e65", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "07feefd74f1e4a22a04f18c5aa1dd512", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java", "commitBeforeChange": "4a7fb72faa1d4eb35981dd799c06dbffe9837a2f", "commitAfterChange": "af607e2e1ad6576e50200e327ea9acd540ed1ad7", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \t\tprotected void append(IField field) throws JavaModelException", "signatureAfterChange": " \t\tprotected void append(IAnnotation annotation) throws JavaModelException", "diff": ["+\t\tprotected void append(IAnnotation annotation) throws JavaModelException {", "+\t\t\tline.append(\"@\");", "+\t\t\tline.append(annotation.getElementName());", "+\t\t\tline.append('(');", "+\t\t\tIMemberValuePair[] pairs = annotation.getMemberValuePairs();", "+\t\t\tint length = pairs == null ? 0 : pairs.length;", "+\t\t\tfor (int i=0; i<length; i++) {", "+\t\t\t\tline.append(pairs[i].getMemberName());", "+\t\t\t\tline.append('=');", "+\t\t\t\tObject value = pairs[i].getValue();", "+\t\t\t\tswitch (pairs[i].getValueKind()) {", "+\t\t\t\t\tcase IMemberValuePair.K_CLASS:", "+\t\t\t\t\t\tline.append(value);", "+\t\t\t\t\t\tline.append(\".class\");", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tline.append(value);", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tline.append(')');", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "15709a9a2db4cbc2addfec64ff4571cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java", "commitBeforeChange": "91f3edc5382142e13f8351418b65563536c6670f", "commitAfterChange": "8beb6c014c6d79a132720a5abe8725a7bc30bf83", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  \tpublic void testTypeAnnotations7()", "signatureAfterChange": "  \tpublic void testTypeAnnotations7()", "diff": ["+", "+\t\t// public <T> Z(@Type T t){}", "+\t\tList<? extends Element> members = _elementUtils.getAllMembers(typeZ);", "+\t\tfor (ExecutableElement method : ElementFilter.constructorsIn(members)) {", "+\t\t\tExecutableType executabletype = (ExecutableType) method.asType();", "+\t\t\tList<? extends TypeMirror> list = executabletype.getParameterTypes();", "+\t\t\tList<? extends VariableElement> list1 = method.getParameters();", "+\t\t\tfor(int i = 0; i < list1.size(); i++) {", "+\t\t\t\tVariableElement variableelement = list1.get(i);", "+\t\t\t\tif (method.getSimpleName().toString().equals(\"<init>\")) {", "+\t\t\t\t\tassertEquals(\"Trouble!\", list.get(i), variableelement.asType());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1d5cbaf7510d88516a4afdc45fce2567", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java", "commitBeforeChange": "98c08ded096494364ca74f948e8f494b3f447e89", "commitAfterChange": "423cede7ef9cde15030dc54ef2266be4ddcc9112", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " public static void createJar(String[] pathsAndContents, String jarPath, String compliance) throws IOException", "signatureAfterChange": " public static void createJar(String[] pathsAndContents, String[] extraPathsAndContents, Map options, String jarPath) throws IOException", "diff": ["+}", "+public static void createJar(String[] pathsAndContents, String[] extraPathsAndContents, Map options, String jarPath) throws IOException {", "+\tif (pathsAndContents != null) {", "+\t\tcompile(pathsAndContents, options, classesPath);", "+\t}", "+\tfor (int i = 0, l = extraPathsAndContents == null ? 0 : extraPathsAndContents.length; i < l; /* inc in loop */) {", "+\t\tFile  outputFile = new File(classesPath, extraPathsAndContents[i++]);", "+\t\toutputFile.getParentFile().mkdirs();", "+\t\tUtil.writeToFile(extraPathsAndContents[i++], outputFile.getAbsolutePath());", "+\t}", "-public static void createJar(String[] pathsAndContents, String jarPath, String compliance) throws IOException {", "-    createJar(pathsAndContents, getCompileOptions(compliance), jarPath);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2218b838071cc7d1dcf682212960b4f3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java", "commitBeforeChange": "fd3ab9c75de2623a0c445ae20bbf9555b802842b", "commitAfterChange": "dc82ed373b675aa38d1bde68b062faa0d442c79e", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " \t \tprivate TypeBinding getTypeFromSignature(String typeSignature, Scope scope)", "signatureAfterChange": " \t \tprivate TypeBinding getTypeFromSignature(String typeSignature, Scope scope)", "diff": ["-\t\t\ttypeVariables = methodDeclaration.binding.typeVariables;", "+\t\t\tTypeParameter[] typeParameters = methodDeclaration.typeParameters();", "+\t\t\tif (typeParameters != null && typeParameters.length > 0) {", "+\t\t\t\tint length = typeParameters.length;", "+\t\t\t\tint count = 0;", "+\t\t\t\ttypeVariables = new TypeVariableBinding[length];", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tif (typeParameters[i].binding != null) {", "+\t\t\t\t\t\ttypeVariables[count++] = typeParameters[i].binding;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tif (count != length) {", "+\t\t\t\t\tSystem.arraycopy(typeVariables, 0, typeVariables = new TypeVariableBinding[count], 0, count);", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3695ecb284ac8bd01e21007e9758789c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java", "commitBeforeChange": "7ff0d09aa487a0631f946435eaa975868c23d1f5", "commitAfterChange": "39e213fa6f67cec1c2c3ab80a64ac8dcf4d5cf90", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tprotected IType getType(String typeName)", "signatureAfterChange": " \tprotected IType getType(String typeName)", "diff": ["-\t\tif (this.binaryType.getElementName().equals(typeName))", "+\t\tif (typeName.length() == 0) {", "+\t\t\tIJavaElement classFile = this.binaryType.getParent();", "+\t\t\tString classFileName = classFile.getElementName();", "+\t\t\tStringBuffer newClassFileName = new StringBuffer();", "+\t\t\tint lastDollar = classFileName.lastIndexOf('$');", "+\t\t\tfor (int i = 0; i <= lastDollar; i++)", "+\t\t\t\tnewClassFileName.append(classFileName.charAt(i));", "+\t\t\tnewClassFileName.append(Integer.toString(this.anonymousCounter));", "+\t\t\tnewClassFileName.append(SuffixConstants.SUFFIX_class);", "+\t\t\tPackageFragment pkg = (PackageFragment) classFile.getParent();", "+\t\t\treturn new BinaryType(new ClassFile(pkg, newClassFileName.toString()), typeName);", "+\t\t} else if (this.binaryType.getElementName().equals(typeName))"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3918dbb7a79fc84b91502f6b74d3a25a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/newbuilder/IncrementalImageBuilder.java", "commitBeforeChange": "4338f1a4587c82218a7d04fd414f807b13e3b40e", "commitAfterChange": "a6355ed8a952db69dc06abd606ccc2ecc5f494cd", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r \r protected void findSourceFiles(IResourceDelta sourceDelta, int sourceFolderSegmentCount) throws CoreException", "signatureAfterChange": "\r \r protected void findSourceFiles(IResourceDelta sourceDelta, int sourceFolderSegmentCount) throws CoreException", "diff": ["-\t\t\t\t\t\tnewState.remove(location);\r", "+\t\t\t\t\t\tchar[][] additionalTypeNames = newState.getAdditionalTypeNamesFor(location.toString());\r", "+\t\t\t\t\t\tif (additionalTypeNames != null) {\r", "+\t\t\t\t\t\t\tfor (int i = 0, length = additionalTypeNames.length; i < length; i++) {\r", "+\t\t\t\t\t\t\t\ttypePath = typePath.removeLastSegments(1).append(new String(additionalTypeNames[i]));\r", "+\t\t\t\t\t\t\t\tclassFile = outputFolder.getFile(typePath.addFileExtension(JavaBuilder.CLASS_EXTENSION));\r", "+\t\t\t\t\t\t\t\tif (classFile.exists()) {\r", "+\t\t\t\t\t\t\t\t\tif (JavaBuilder.DEBUG)\r", "+\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"Deleting class file of removed file \" + typePath); //$NON-NLS-1$\r", "+\t\t\t\t\t\t\t\t\tclassFile.delete(true, null);\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\taddDependentsOf(typePath, true);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tnewState.remove(location);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39cd47642d8f4647797a78bf258c78d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexAllProject.java", "commitBeforeChange": "1c5e7e547be721f9ec87cd4dd76a42ec63ff0bb1", "commitAfterChange": "021e1bbe1df76f3c86c477a6dfa61edf287069ab", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "signatureAfterChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "diff": ["-", "-\t\tIndex index = this.manager.getIndexForUpdate(this.containerPath, true, /*reuse index file*/ true /*create if none*/);", "-\t\tif (index == null) return true;", "-\t\tReadWriteMonitor monitor = index.monitor;", "-\t\tif (monitor == null) return true; // index got deleted since acquired", "-", "+\t\t", "+\t\tReadWriteMonitor monitor = null;", "+\t\t\t// Get source folder entries. Libraries are done as a separate job", "+\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(this.project);", "+\t\t\t// Do not create marker nor log problems while getting raw classpath (see bug 41859)", "+\t\t\tIClasspathEntry[] entries = javaProject.getRawClasspath(false, false);", "+\t\t\tint length = entries.length;", "+\t\t\tIClasspathEntry[] sourceEntries = new IClasspathEntry[length];", "+\t\t\tint sourceEntriesNumber = 0;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tIClasspathEntry entry = entries[i];", "+\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_SOURCE)) ", "+\t\t\t\t\tsourceEntries[sourceEntriesNumber++] = entry;", "+\t\t\t}", "+\t\t\tif (sourceEntriesNumber == 0) ", "+\t\t\t\t// nothing to index", "+\t\t\t\t// also the project might be a library folder (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=89815)", "+\t\t\t\treturn true;", "+\t\t\tif (sourceEntriesNumber != length)", "+\t\t\t\tSystem.arraycopy(sourceEntries, 0, sourceEntries = new IClasspathEntry[sourceEntriesNumber], 0, sourceEntriesNumber);", "+\t", "+\t\t\tIndex index = this.manager.getIndexForUpdate(this.containerPath, true, /*reuse index file*/ true /*create if none*/);", "+\t\t\tif (index == null) return true;", "+\t\t\tmonitor = index.monitor;", "+\t\t\tif (monitor == null) return true; // index got deleted since acquired", "+\t\t\t", "-\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(this.project);", "-\t\t\t// Do not create marker nor log problems while getting raw classpath (see bug 41859)", "-\t\t\tIClasspathEntry[] entries = javaProject.getRawClasspath(false, false);", "-\t\t\tfor (int i = 0, length = entries.length; i < length; i++) {", "+\t\t\tfor (int i = 0; i < sourceEntriesNumber; i++) {", "-\t\t\t\tIClasspathEntry entry = entries[i];", "-\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_SOURCE)) { // Index only source folders. Libraries are done as a separate job", "-\t\t\t\t\tIResource sourceFolder = root.findMember(entry.getPath());", "-\t\t\t\t\tif (sourceFolder != null) {", "-\t\t\t\t\t\t", "-\t\t\t\t\t\t// collect output locations if source is project (see http://bugs.eclipse.org/bugs/show_bug.cgi?id=32041)", "-\t\t\t\t\t\tfinal HashSet outputs = new HashSet();", "-\t\t\t\t\t\tif (sourceFolder.getType() == IResource.PROJECT) {", "-\t\t\t\t\t\t\t// Do not create marker nor log problems while getting output location (see bug 41859)", "-\t\t\t\t\t\t\toutputs.add(javaProject.getOutputLocation(false, false));", "-\t\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "-\t\t\t\t\t\t\t\tIPath output = entries[j].getOutputLocation();", "-\t\t\t\t\t\t\t\tif (output != null) {", "-\t\t\t\t\t\t\t\t\toutputs.add(output);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\tIClasspathEntry entry = sourceEntries[i];", "+\t\t\t\tIResource sourceFolder = root.findMember(entry.getPath());", "+\t\t\t\tif (sourceFolder != null) {", "+\t\t\t\t\t", "+\t\t\t\t\t// collect output locations if source is project (see http://bugs.eclipse.org/bugs/show_bug.cgi?id=32041)", "+\t\t\t\t\tfinal HashSet outputs = new HashSet();", "+\t\t\t\t\tif (sourceFolder.getType() == IResource.PROJECT) {", "+\t\t\t\t\t\t// Do not create marker nor log problems while getting output location (see bug 41859)", "+\t\t\t\t\t\toutputs.add(javaProject.getOutputLocation(false, false));", "+\t\t\t\t\t\tfor (int j = 0; j < sourceEntriesNumber; j++) {", "+\t\t\t\t\t\t\tIPath output = sourceEntries[j].getOutputLocation();", "+\t\t\t\t\t\t\tif (output != null) {", "+\t\t\t\t\t\t\t\toutputs.add(output);", "-\t\t\t\t\t\tfinal boolean hasOutputs = !outputs.isEmpty();", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tfinal char[][] inclusionPatterns = ((ClasspathEntry) entry).fullInclusionPatternChars();", "-\t\t\t\t\t\tfinal char[][] exclusionPatterns = ((ClasspathEntry) entry).fullExclusionPatternChars();", "-\t\t\t\t\t\tif (max == 0) {", "-\t\t\t\t\t\t\tsourceFolder.accept(", "-\t\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "-\t\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "-\t\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "-\t\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "-\t\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (file.getLocation() == null) return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(file.getFullPath().toString(), file);", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "-\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null && inclusionPatterns == null) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\t// if there are inclusion patterns then we must walk the children", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestFullPath(), inclusionPatterns, exclusionPatterns, true)) ", "-\t\t\t\t\t\t\t\t\t\t\t\t\t    return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "-\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t},", "-\t\t\t\t\t\t\t\tIResource.NONE", "-\t\t\t\t\t\t\t);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tsourceFolder.accept(", "-\t\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "-\t\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "-\t\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "-\t\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "-\t\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tIPath location = file.getLocation();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (location == null) return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tString path = file.getFullPath().toString();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(path,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.get(path) == null || indexLastModified < location.toFile().lastModified()", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? (Object) file", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: (Object) OK);", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "+\t\t\t\t\t}", "+\t\t\t\t\tfinal boolean hasOutputs = !outputs.isEmpty();", "+\t\t\t\t\t", "+\t\t\t\t\tfinal char[][] inclusionPatterns = ((ClasspathEntry) entry).fullInclusionPatternChars();", "+\t\t\t\t\tfinal char[][] exclusionPatterns = ((ClasspathEntry) entry).fullExclusionPatternChars();", "+\t\t\t\t\tif (max == 0) {", "+\t\t\t\t\t\tsourceFolder.accept(", "+\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "+\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "+\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "+\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "+\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "+\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "+\t\t\t\t\t\t\t\t\t\t\t\tif (file.getLocation() == null) return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestResource(), inclusionPatterns, exclusionPatterns))", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "-\t\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "-\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(file.getFullPath().toString(), file);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "+\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null && inclusionPatterns == null) {", "+\t\t\t\t\t\t\t\t\t\t\t\t// if there are inclusion patterns then we must walk the children", "+\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestFullPath(), inclusionPatterns, exclusionPatterns, true)) ", "+\t\t\t\t\t\t\t\t\t\t\t\t    return false;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "+\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t},", "-\t\t\t\t\t\t\t\tIResource.NONE", "-\t\t\t\t\t\t\t);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t},", "+\t\t\t\t\t\t\tIResource.NONE", "+\t\t\t\t\t\t);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tsourceFolder.accept(", "+\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "+\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "+\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "+\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "+\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "+\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "+\t\t\t\t\t\t\t\t\t\t\t\tIPath location = file.getLocation();", "+\t\t\t\t\t\t\t\t\t\t\t\tif (location == null) return false;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\t\t\tString path = file.getFullPath().toString();", "+\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(path,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.get(path) == null || indexLastModified < location.toFile().lastModified()", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t? (Object) file", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t: (Object) OK);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "+\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "+\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestResource(), inclusionPatterns, exclusionPatterns))", "+\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "+\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t},", "+\t\t\t\t\t\t\tIResource.NONE", "+\t\t\t\t\t\t);", "-\t\t\tfor (int i = 0, length = names.length; i < length; i++) {", "+\t\t\tfor (int i = 0, namesLength = names.length; i < namesLength; i++) {", "-\t\t\tmonitor.exitRead(); // free read lock", "+\t\t\tif (monitor != null)", "+\t\t\t\tmonitor.exitRead(); // free read lock"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3ece70b568c84cffe0aa5d04d15eba3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java", "commitBeforeChange": "d644fbac5b6fa9c32824a6e9c1731fdea560370f", "commitAfterChange": "a2ea211548ddb7d816d913062440866fd92fd6cc", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic int generateDelta(JavaElementDelta delta, boolean addClasspathChange)", "signatureAfterChange": " \tpublic int generateDelta(JavaElementDelta delta, boolean addClasspathChange)", "diff": ["-\t\t\t\tPackageFragmentRoot[] pkgFragmentRoots = null;", "+\t\t\t\tIPackageFragmentRoot[] pkgFragmentRoots = null;", "+\t\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=335986", "+\t\t\t\t\t\t// When a package fragment's corresponding resource is removed from the project, ", "+\t\t\t\t\t\t// IJavaProject#computePackageFragmentRoots() doesn't include that entry. Hence ", "+\t\t\t\t\t\t// the cache become necessary in such cases. Add the cache to the accumulatedRoots ", "+\t\t\t\t\t\t// only when it's not already present.", "+\t\t\t\t\t\tRootInfo rootInfo = (RootInfo) state.oldRoots.get(this.oldResolvedClasspath[i].getPath());", "+\t\t\t\t\t\tif (rootInfo != null && rootInfo.cache != null) {", "+\t\t\t\t\t\t\tIPackageFragmentRoot oldRoot = rootInfo.cache;", "+\t\t\t\t\t\t\tboolean found = false;", "+\t\t\t\t\t\t\tfor (int j = 0; j < accumulatedRoots.size(); j++) {", "+\t\t\t\t\t\t\t\tIPackageFragmentRoot root = (IPackageFragmentRoot) accumulatedRoots.elementAt(j);", "+\t\t\t\t\t\t\t\tif (!root.getPath().equals(oldRoot.getPath())) {", "+\t\t\t\t\t\t\t\t\tfound = true;", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!found)", "+\t\t\t\t\t\t\t\taccumulatedRoots.add(oldRoot);", "+\t\t\t\t\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4268c0441fd049f61771ab2b43822f4a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding.java", "commitBeforeChange": "cd65b8d76037ea98de2f66f3cc29001c505073c6", "commitAfterChange": "dfc12356d0e56187f27726140c3e4ba7be8134b7", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void initializeBounds(ParameterizedTypeBinding capturedParameterizedType)", "signatureAfterChange": " \tpublic void initializeBounds(ParameterizedTypeBinding capturedParameterizedType)", "diff": ["+\t\tReferenceBinding substitutedVariableSuperclass = (ReferenceBinding) Scope.substitute(capturedParameterizedType, originalVariableSuperclass);", "-\t\tReferenceBinding substitutedVariableSuperclass = originalVariableSuperclass.isTypeVariable() ? originalVariableSuperclass : (ReferenceBinding) Scope.substitute(capturedParameterizedType, originalVariableSuperclass);", "-\t\tReferenceBinding[] substitutedVariableInterfaces = Scope.substitute(capturedParameterizedType, wildcardVariable.superInterfaces());", "+\t\tif (substitutedVariableSuperclass == this) substitutedVariableSuperclass = originalVariableSuperclass;", "+\t\t", "+\t\tReferenceBinding[] originalVariableInterfaces = wildcardVariable.superInterfaces();\t\t", "+\t\tReferenceBinding[] substitutedVariableInterfaces = Scope.substitute(capturedParameterizedType, originalVariableInterfaces);", "+\t\tif (substitutedVariableInterfaces != originalVariableInterfaces) {", "+\t\t\t// prevent cyclic capture: given X<T>, capture(X<? extends T> could yield a circular type", "+\t\t\tfor (int i = 0, length = substitutedVariableInterfaces.length; i < length; i++) {", "+\t\t\t\tif (substitutedVariableInterfaces[i] == this) substitutedVariableInterfaces[i] = originalVariableInterfaces[i];", "+\t\t\t}", "+\t\t}", "+\t\tTypeBinding originalWildcardBound = wildcard.bound;", "+\t\t// prevent cyclic capture: given X<T>, capture(X<? extends T> could yield a circular type", "+\t\tTypeBinding substitutedWildcardBound = originalWildcardBound == null ? null : Scope.substitute(capturedParameterizedType, originalWildcardBound);", "+\t\tif (substitutedWildcardBound == this) substitutedWildcardBound = originalWildcardBound;", "-\t\t\t\t\t\tthis.superInterfaces = new ReferenceBinding[] { (ReferenceBinding) wildcard.bound };", "+\t\t\t\t\t\tthis.superInterfaces = new ReferenceBinding[] { (ReferenceBinding) substitutedWildcardBound };", "-\t\t\t\tTypeBinding substitutedWildcardBound = Scope.substitute(capturedParameterizedType, wildcard.bound);", "-\t\t\t\t// prevent cyclic capture: given X<T>, capture(X<? super T> could yield a circular type", "-\t\t\t\tsubstitutedWildcardBound = wildcard.bound.isTypeVariable() ? wildcard.bound : Scope.substitute(capturedParameterizedType, wildcard.bound);", "-\t\t\t\tif (wildcardVariable.firstBound == this.superclass ", "-\t\t\t\t\t\t|| substitutedWildcardBound == this.superclass) {", "-\t\t\t\t\tthis.firstBound = this.superclass;", "+\t\t\t\tif (wildcardVariable.firstBound == substitutedVariableSuperclass || substitutedWildcardBound == substitutedVariableSuperclass) {", "+\t\t\t\t\tthis.firstBound = substitutedVariableSuperclass;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5267c80f691421fb3fe49ff85e351cbd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "8d1c92d5ff789a78e5b2b21597d7c303cc8d5234", "commitAfterChange": "270bcfc5f9a8c2abee755a7d8ecdd2a24972b638", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \t \tprotected boolean connectTypeVariables(TypeParameter[] typeParameters)", "signatureAfterChange": " \t \tprotected boolean connectTypeVariables(TypeParameter[] typeParameters)", "diff": ["+\t\t\t\t\tif (superType.isParameterizedType()) {", "+\t\t\t\t\t\tReferenceBinding match = typeVariable.superclass.findSuperTypeErasingTo((ReferenceBinding) superType.erasure());", "+\t\t\t\t\t\tboolean isCollision = match != null && match != superType;", "+\t\t\t\t\t\tfor (int index = typeVariable.superInterfaces.length; !isCollision && --index >= 0;) {", "+\t\t\t\t\t\t\tReferenceBinding temp = typeVariable.superInterfaces[index];", "+\t\t\t\t\t\t\tisCollision = superType != temp && superType.erasure() == temp.erasure();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (isCollision) {", "+\t\t\t\t\t\t\tproblemReporter().boundHasConflictingArguments(typeRef, superType);", "+\t\t\t\t\t\t\ttypeVariable.tagBits |= HierarchyHasProblems;", "+\t\t\t\t\t\t\tnoProblems = false;", "+\t\t\t\t\t\t\tcontinue nextVariable;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a161e0358d84749016938197de937e4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "fc25b1b826e7fad7f1da04ab9d452bc350b24919", "commitAfterChange": "19b4c669e6d8313d03dbcc8b595622002fe408a5", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " void faultInImports()", "signatureAfterChange": " void faultInImports()", "diff": ["+\t\tfor (int i = 0; i < this.imports.length; i++) {", "+\t\t\t// cache default-imported null annotation types:", "+\t\t\tif (!this.imports[i].onDemand) {", "+\t\t\t\tchar[][] importName = this.imports[i].compoundName;", "+\t\t\t\tthis.typeOrPackageCache.put(importName[importName.length-1], this.imports[i].resolvedImport);", "+\t\t\t}", "+\t\t}", "+\tint numberOfDefaultImports = 1;", "+\tif (this.environment.globalOptions.defaultImportNullAnnotationTypes) {", "+\t\tnumberOfDefaultImports += 2;", "+\t\tnumberOfImports += 2;", "+\t}", "-\tresolvedImports[0] = getDefaultImports()[0];", "-\tint index = 1;", "+\tImportBinding[] defaultImports = getDefaultImports(); // consistent number of default imports is ensured in LookupEnvironment.makeNullAnnotationTypeImports()", "+\tfor (int i = 0; i < numberOfDefaultImports; i++) {", "+\t\tresolvedImports[i] = defaultImports[i];", "+\t}", "+", "+\tint index = numberOfDefaultImports;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5ab2b49034c0574aadf1418472aa3312", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tboolean receiverCast = false, argumentsCast = false; ", "+\tboolean receiverCast = false, argsContainCast = false; ", "-\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)this.receiver);\t\t", "+\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)this.receiver);\t\t", "+\t// resolve type arguments (for generic constructor call)", "+\tif (this.typeArguments != null) {", "+\t\tint length = this.typeArguments.length;", "+\t\tboolean argHasError = false; // typeChecks all arguments", "+\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tif ((this.genericTypeArguments[i] = this.typeArguments[i].resolveType(scope)) == null) {", "+\t\t\t\targHasError = true;", "+\t\t\t}", "+\t\t}", "+\t\tif (argHasError) {", "+\t\t\treturn null;", "+\t\t}", "+\t}\t", "-\t\t\t\targumentsCast = true;", "+\t\t\t\targsContainCast = true;", "-\t\t\t\tthis.codegenBinding = this.binding = scope.findMethod((ReferenceBinding)receiverType, selector, new TypeBinding[]{}, this);", "+\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding)receiverType, selector, new TypeBinding[]{}, this);", "-\tif (this.receiverType == null)", "+\tif (this.receiverType == null) {", "-", "+\t}", "-\tthis.codegenBinding = this.binding = ", "+\tthis.binding = ", "-\t\t// record the closest match, for clients who may still need hint about possible method match", "-\t\tif (binding instanceof ProblemMethodBinding){", "-\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)binding).closestMatch;", "-\t\t\tif (closestMatch != null) this.codegenBinding = this.binding = closestMatch;", "+\t\tMethodBinding closestMatch = ((ProblemMethodBinding)binding).closestMatch;", "+\t\tswitch (this.binding.problemId()) {", "+\t\t\tcase ProblemReasons.Ambiguous :", "+\t\t\tcase ProblemReasons.NotVisible :", "+\t\t\tcase ProblemReasons.NonStaticReferenceInConstructorInvocation :", "+\t\t\tcase ProblemReasons.NonStaticReferenceInStaticContext :", "+\t\t\tcase ProblemReasons.ReceiverTypeNotVisible :", "+\t\t\tcase ProblemReasons.ParameterBoundMismatch :", "+\t\t\t\t// only steal returnType in cases listed above", "+\t\t\t\tif (closestMatch != null) this.resolvedType = closestMatch.returnType;", "+\t\t\tdefault :", "-\t\treturn this.resolvedType = this.binding == null ? null : this.binding.returnType;", "+\t\t// record the closest match, for clients who may still need hint about possible method match", "+\t\tif (closestMatch != null) this.binding = closestMatch;", "+\t\treturn this.resolvedType;", "-\tif (arguments != null) {", "-\t\tfor (int i = 0; i < arguments.length; i++) {", "-\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);", "-\t\t}", "-\t\tif (argumentsCast) {", "-\t\t\tCastExpression.checkNeedForArgumentCasts(scope, this.receiver, receiverType, binding, this.arguments, argumentTypes, this);", "-\t\t}", "-\t}", "+\tif (this.arguments != null) ", "+\t\tcheckInvocationArguments(scope, this.receiver, receiverType, binding, this.arguments, argumentTypes, argsContainCast, this);", "+", "-\treturn this.resolvedType = binding.returnType;", "+\treturn this.resolvedType = this.binding.returnType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e7a20bb76ec745d335f92507824305d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CreateImportOperation.java", "commitBeforeChange": "90d481edc9060cc498a8f085b08186108312e37b", "commitAfterChange": "f3a3c06f6e68ab7680c250209b9759ac3d56fec6", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected IDOMNode generateElementDOM()", "signatureAfterChange": " protected ASTNode generateElementAST(ASTRewrite rewriter, IDocument document, ICompilationUnit cu) throws JavaModelException", "diff": ["-// TODO - JDOM - remove once model ported off of JDOM", "-protected IDOMNode generateElementDOM() {", "-\tif (fCUDOM.getChild(fImportName) == null) {", "-\t\tDOMFactory factory = new DOMFactory();", "-\t\t//not a duplicate", "-\t\tIDOMImport imp = factory.createImport();", "-\t\timp.setName(fImportName);", "-\t\treturn imp;", "+}", "+protected ASTNode generateElementAST(ASTRewrite rewriter, IDocument document, ICompilationUnit cu) throws JavaModelException {", "+\t// ensure no duplicate", "+\tIterator imports = this.cuAST.imports().iterator();", "+\twhile (imports.hasNext()) {", "+\t\tImportDeclaration importDeclaration = (ImportDeclaration) imports.next();", "+\t\tif (this.importName.equals(importDeclaration.getName().getFullyQualifiedName())) {", "+\t\t\t//no new import was generated", "+\t\t\tthis.creationOccurred = false;", "+\t\t\treturn null;", "+\t\t}", "-\t//no new import was generated", "-\tfCreationOccurred = false;", "-\t//all the work has already been done", "-\treturn null;", "+\tAST ast = this.cuAST.getAST();", "+\tImportDeclaration importDeclaration = ast.newImportDeclaration();", "+\tName name = ast.newName(new String[] {this.importName});", "+\timportDeclaration.setName(name);", "+\treturn importDeclaration;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "68bc359d236f9cede4c61bdf75196e39", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceSearchTests.java", "commitBeforeChange": "2d1be1f1f4a58e88e50c3b86fdfc977ad3b4dc33", "commitAfterChange": "0ac8f989e8e30ba627dfaa54489b47b0049b464d", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 17, "signatureBeforeChange": "  \tpublic void testPerfIndexing() throws IOException, CoreException", "signatureAfterChange": "  \tpublic void testPerfIndexing() throws CoreException", "diff": ["-\tpublic void testPerfIndexing() throws IOException, CoreException {", "+\tpublic void testPerfIndexing() throws CoreException {", "-\t\tstartMeasuring();", "+\t\tINDEX_MANAGER.discardJobs(null); // discard all previous index jobs", "+\t\tINDEX_MANAGER.performConcurrentJob(new DoNothing(), IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, null);", "+\t\tINDEX_MANAGER.request(new Measuring(true/*start measuring*/));", "+\t\tfor (int i=0, length=ALL_PROJECTS.length; i<length; i++) {", "+\t\t\tINDEX_MANAGER.indexAll(ALL_PROJECTS[i].getProject());", "+\t\t}", "-\t\tstopMeasuring();", "-\t\tcommitMeasurements();", "-\t\tassertPerformance();", "+\t\tINDEX_MANAGER.request(new Measuring(false /*end measuring*/));", "+\t\tINDEX_MANAGER.performConcurrentJob(new DoNothing(), IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, null);", "+\t\tassertEquals(\"Index manager should not have remaining jobs!\", 0, INDEX_MANAGER.awaitingJobsCount()); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "71edfd2558124cac51998d382ea38df4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "8457dc17f56c4fff3fa2589438e210393d270f41", "commitAfterChange": "60249e9dd075ec142e7f7240fcef068b0fddb812", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": "  public String toString()", "signatureAfterChange": "  public String toString()", "diff": ["+\t\t\tString[] paths = new String[this.relativePaths.length];", "+\t\t\tint index = 0;", "-\t\t\t\tresult.append(\"\\n\\t\"); //$NON-NLS-1$", "+\t\t\t\tString containerPath;", "-\t\t\t\t\tresult.append(((IFolder) target).getLocation().toOSString());", "+\t\t\t\t\tcontainerPath = ((IFolder) target).getLocation().toOSString();", "-\t\t\t\t\tresult.append(this.containerPaths[i]);", "+\t\t\t\t\tcontainerPath = this.containerPaths[i];", "-\t\t\t\t\tresult.append('/');", "-\t\t\t\t\tresult.append(path);", "+\t\t\t\t\tpaths[index++] = containerPath + '/' + path;", "+\t\t\t\t} else {", "+\t\t\t\t\tpaths[index++] = containerPath;", "+\t\t\tSystem.arraycopy(paths, 0, paths = new String[index], 0, index);", "+\t\t\tUtil.sort(paths);", "+\t\t\tfor (int i = 0; i < index; i++) {", "+\t\t\t\tresult.append(\"\\n\\t\"); //$NON-NLS-1$", "+\t\t\t\tresult.append(paths[i]);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "862725fdad348a99dc36efb5b6b515c5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "3ef93f23afcd2f32a7f2e702fed5d9d29c70e752", "commitAfterChange": "a54ce0f1a5965500a06d345ce2b572137c5b2f38", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 28, "signatureBeforeChange": "\r \r \tpublic ArrayCreation convert(ArrayAllocationExpression expression)", "signatureAfterChange": "\r \r \tpublic ArrayCreation convert(ArrayAllocationExpression expression)", "diff": ["+\t\tif (this.resolveBindings) {\r", "+\t\t\trecordNodes(type, expression.type);\r", "+\t\t}\t\t\r", "+\t\t\tint start = type.getStartPosition();\r", "+\t\t\tint end = type.getStartPosition() + type.getLength();\r", "+\t\t\tint previousSearchStart = end;\r", "+\t\t\tArrayType componentType = (ArrayType) type.getParent();\r", "+\t\t\tfor (int i = 0; i < dimensionsLength; i++) {\r", "+\t\t\t\tpreviousSearchStart = retrieveRightBracketPosition(previousSearchStart + 1, this.compilationUnitSource.length);\r", "+\t\t\t\tcomponentType.setSourceRange(start, previousSearchStart - start + 1);\r", "+\t\t\t\tcomponentType = (ArrayType) componentType.getParent();\r", "+\t\t\t}\r", "+\t\tif (this.resolveBindings) {\r", "+\t\t\trecordNodes(arrayType, expression);\r", "+\t\t}\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8dc63d1e44d1baa3efc4f898ea243951", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "79ea7516ee993fa0354e3522ad8337d5c8c5bf24", "commitAfterChange": "444d0d90fb5197da92c8f8879cb5ec3d4ff0d34c", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic void checkExternalArchiveChanges(IJavaElement[] elementsToRefresh, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " \tpublic void checkExternalArchiveChanges(IJavaElement[] elementsToRefresh, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\t\t\t\tfor (int i = 0, length = projectDeltas.length; i < length; i++) {", "+\t\t\t\tfinal int length = projectDeltas.length;", "+\t\t\t\tfinal IProject[] projectsToTouch = new IProject[length];", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\t\t", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\t// touch the project to force it to be recompiled", "-\t\t\t\t\t\tjavaProject.getProject().touch(monitor);", "-\t\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t\tthrow new JavaModelException(e);", "+\t\t\t\t\tprojectsToTouch[i] = javaProject.getProject();", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// touch the projects to force them to be recompiled while taking the workspace lock ", "+\t\t\t\t// so that there is no concurrency with the Java builder", "+\t\t\t\t// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=96575", "+\t\t\t\tIWorkspaceRunnable runnable = new IWorkspaceRunnable() {", "+\t\t\t\t\tpublic void run(IProgressMonitor progressMonitor) throws CoreException {", "+\t\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\t\tIProject project = projectsToTouch[i];", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t// reset the corresponding project built state, since the builder would miss this change", "+\t\t\t\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\t\t\t\tSystem.out.println(\"Clearing last state for project with external jar changed: \" + project); //$NON-NLS-1$\t\t\t\t\t\t", "+\t\t\t\t\t\t\tDeltaProcessor.this.manager.setLastBuiltState(project, null /*no state*/);", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t// touch to force a build of this project", "+\t\t\t\t\t\t\tproject.touch(progressMonitor);", "+\t\t\t\t\t\t}", "-\t\t\t\t}\t\t", "+\t\t\t\t};", "+\t\t\t\ttry {", "+\t\t\t\t\tResourcesPlugin.getWorkspace().run(runnable, monitor);", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\tthrow new JavaModelException(e);", "+\t\t\t\t}", "+\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e2e4a058058567ed5ebce445edb3e12", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "1146476ca138da09c36a16ea64250a150f60b014", "commitAfterChange": "e3d3c02cc33fd5166184422215f4903c5a405e0f", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  protected void finishedWith(String sourceLocation, CompilationResult result, char[] mainTypeName, ArrayList definedTypeNames, ArrayList duplicateTypeNames) throws CoreException", "signatureAfterChange": "  protected void finishedWith(String sourceLocator, CompilationResult result, char[] mainTypeName, ArrayList definedTypeNames, ArrayList duplicateTypeNames) throws CoreException", "diff": ["-protected void finishedWith(String sourceLocation, CompilationResult result, char[] mainTypeName, ArrayList definedTypeNames, ArrayList duplicateTypeNames) throws CoreException {", "-\tchar[][] previousTypeNames = newState.getDefinedTypeNamesFor(sourceLocation);", "+protected void finishedWith(String sourceLocator, CompilationResult result, char[] mainTypeName, ArrayList definedTypeNames, ArrayList duplicateTypeNames) throws CoreException {", "+\tchar[][] previousTypeNames = newState.getDefinedTypeNamesFor(sourceLocator);", "-\tnext : for (int i = 0, x = previousTypeNames.length; i < x; i++) {", "+\tnext : for (int i = 0, l = previousTypeNames.length; i < l; i++) {", "-\t\tfor (int j = 0, y = definedTypeNames.size(); j < y; j++)", "+\t\tfor (int j = 0, m = definedTypeNames.size(); j < m; j++)", "-\t\tif (packagePath == null)", "-\t\t\tpackagePath = new Path(extractTypeNameFrom(sourceLocation)).removeLastSegments(1);", "+\t\tSourceFile sourceFile = (SourceFile) result.getCompilationUnit();", "+\t\tif (packagePath == null) {", "+\t\t\tint count = sourceFile.sourceLocation.sourceFolder.getFullPath().segmentCount();", "+\t\t\tpackagePath = sourceFile.resource.getFullPath().removeFirstSegments(count).removeLastSegments(1);", "+\t\t}", "-\t\t\tthis.secondaryTypesToRemove = new ArrayList();", "-\t\tsecondaryTypesToRemove.add(packagePath.append(new String(previous)));", "+\t\t\tthis.secondaryTypesToRemove = new SimpleLookupTable();", "+\t\tArrayList types = (ArrayList) secondaryTypesToRemove.get(sourceFile.sourceLocation.binaryFolder);", "+\t\tif (types == null)", "+\t\t\ttypes = new ArrayList(definedTypeNames.size());", "+\t\ttypes.add(packagePath.append(new String(previous)));", "+\t\tsecondaryTypesToRemove.put(sourceFile.sourceLocation.binaryFolder, types);", "-\tsuper.finishedWith(sourceLocation, result, mainTypeName, definedTypeNames, duplicateTypeNames);", "+\tsuper.finishedWith(sourceLocator, result, mainTypeName, definedTypeNames, duplicateTypeNames);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94ec92c9c45bd12c85630571e1a0352c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java", "commitBeforeChange": "8376377bee92e0d16cfa404c8d1e948dcf5be147", "commitAfterChange": "0a6cb9139841c5f6143bc94201bfcbd6024601de", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 19, "signatureBeforeChange": " protected IJavaProject createJavaProject(final String projectName, final String[] sourceFolders, final String[] libraries, final String[] projects, final String output) throws CoreException", "signatureAfterChange": " protected IJavaProject createJavaProject(final String projectName, final String[] sourceFolders, final String[] libraries, final String[] projects, final String projectOutput, final String[] sourceOutputs) throws CoreException", "diff": ["-protected IJavaProject createJavaProject(final String projectName, final String[] sourceFolders, final String[] libraries, final String[] projects, final String output) throws CoreException {", "+}", "+protected IJavaProject createJavaProject(final String projectName, final String[] sourceFolders, final String[] libraries, final String[] projects, final String projectOutput, final String[] sourceOutputs) throws CoreException {", "-\t\t\tint sourceLength = sourceFolders.length;", "-\t\t\tint libLength = libraries.length;", "-\t\t\tint projectLength = projects.length;", "+\t\t\tint sourceLength = sourceFolders == null ? 0 : sourceFolders.length;", "+\t\t\tint libLength = libraries == null ? 0 : libraries.length;", "+\t\t\tint projectLength = projects == null ? 0 : projects.length;", "-\t\t\t\tentries[i] = JavaCore.newSourceEntry(projectPath.append(sourcePath));", "+\t\t\t\tIPath outputPath = null;", "+\t\t\t\tif (sourceOutputs != null) {", "+\t\t\t\t\t// create out folder for source entry", "+\t\t\t\t\toutputPath = sourceOutputs[i] == null ? null : new Path(sourceOutputs[i]);", "+\t\t\t\t\tif (outputPath != null && outputPath.segmentCount() > 0) {", "+\t\t\t\t\t\tIFolder output = project.getFolder(outputPath);", "+\t\t\t\t\t\tif (!output.exists()) {", "+\t\t\t\t\t\t\toutput.create(true, true, null);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// create source entry", "+\t\t\t\tentries[i] = ", "+\t\t\t\t\tJavaCore.newSourceEntry(", "+\t\t\t\t\t\tprojectPath.append(sourcePath), ", "+\t\t\t\t\t\tnew IPath[0], ", "+\t\t\t\t\t\toutputPath == null ? null : projectPath.append(outputPath)", "+\t\t\t\t\t);", "-\t\t\t// create output folder", "-\t\t\tIPath outputPath = new Path(output);", "+\t\t\t// create project's output folder", "+\t\t\tIPath outputPath = new Path(projectOutput);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "952efe967cd451f9b5243fccd04cdf55", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java", "commitBeforeChange": "fb2d7d99aabb8ff6fc09a1333f98ae4d56a6ccdf", "commitAfterChange": "9c8a866e1dfa3b05dfb4303df292630a591df281", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tpublic String getQualifiedName()", "signatureAfterChange": " \tpublic String getQualifiedName()", "diff": ["-\t\t\t\t.append('.')", "-\t\t\t\t.append(getName());", "+\t\t\t\t.append('.');", "+\t\t\tif (isParameterizedType()) {", "+\t\t\t\tParameterizedTypeBinding parameterizedTypeBinding = (ParameterizedTypeBinding) this.binding;", "+\t\t\t\tbuffer.append(parameterizedTypeBinding.sourceName());", "+\t\t\t\tITypeBinding[] typeArguments = getTypeArguments();", "+\t\t\t\tfinal int typeArgumentsLength = typeArguments.length;", "+\t\t\t\tif (typeArgumentsLength != 0) {", "+\t\t\t\t\tbuffer.append('<');", "+\t\t\t\t\tfor (int i = 0, max = typeArguments.length; i < max; i++) {", "+\t\t\t\t\t\tif (i > 0) {", "+\t\t\t\t\t\t\tbuffer.append(',');", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbuffer.append(typeArguments[i].getQualifiedName());", "+\t\t\t\t\t}", "+\t\t\t\t\tbuffer.append('>');\t", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tbuffer.append(getName());", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "95ffcf83c8dc12192b28e750b41441e6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "64d39f3567030242a0089e54dec7b20eb2379aa8", "commitAfterChange": "61bef0fdf04ab68e34740d553b6ad5e9433edc7e", "methodNumberBeforeChange": 51, "methodNumberAfterChange": 53, "signatureBeforeChange": " \tpublic void resourceChanged(IResourceChangeEvent event)", "signatureAfterChange": " \tpublic void resourceChanged(IResourceChangeEvent event)", "diff": ["+\t\t\t\t\t\t\t\t\tif ((result & ClasspathChange.HAS_LIBRARY_CHANGE) != 0) {", "+\t\t\t\t\t\t\t\t\t\tstate.addExternalFolderChange(change.project, change.oldResolvedClasspath);", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tHashSet existingElements = this.state.removeExternalElementsToRefresh();", "-\t\t\t\t\t\t\t\tif (existingElements != null) {", "-\t\t\t\t\t\t\t\t\telementsToRefresh.addAll(existingElements);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tHashSet newElementsToRefresh = this.state.removeExternalElementsToRefresh();", "+\t\t\t\t\t\t\t\tif (newElementsToRefresh != null)", "+\t\t\t\t\t\t\t\t\telementsToRefresh.addAll(newElementsToRefresh);", "+\t\t\t\t// update external folders if necessary", "+\t\t\t    ExternalFolderChange[] folderChanges = this.state.removeExternalFolderChanges();", "+\t\t\t\tif (folderChanges != null) {", "+\t\t\t\t    for (int i = 0, length = folderChanges.length; i < length; i++) {", "+\t\t\t\t        try {", "+\t\t\t\t\t        folderChanges[i].updateExternalFoldersIfNecessary(null);", "+\t\t\t\t        } catch (JavaModelException e) {", "+\t\t\t\t        \tif (!e.isDoesNotExist())", "+\t\t\t\t        \t\tUtil.log(e, \"Exception while updating external folders\"); //$NON-NLS-1$", "+\t\t\t\t        }", "+\t\t\t\t    }", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t        \tif (!e.isDoesNotExist())", "+\t\t\t\t        \t\tUtil.log(e, \"Exception while updating project references\"); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a46abf14abd191d27dac86ca364e07ee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java", "commitBeforeChange": "fdb8d62f1c901c375bd2aaf491776e68829346d4", "commitAfterChange": "abac83588fd8774146bd06b2319f52de11bc9846", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public static String[] concatWithClassLibs(String classpath, boolean inFront)", "signatureAfterChange": " public static String[] concatWithClassLibs(String[] classpaths, boolean inFront)", "diff": ["+public static String[] concatWithClassLibs(String[] classpaths, boolean inFront) {", "+\tString[] classLibs = getJavaClassLibs();", "+\tif (classpaths == null) return classLibs;", "+\tfinal int classLibsLength = classLibs.length;", "+\tfinal int classpathsLength = classpaths.length;", "+\tString[] defaultClassPaths = new String[classLibsLength + classpathsLength];", "+\tif (inFront) {", "+\t\tSystem.arraycopy(classLibs, 0, defaultClassPaths, classpathsLength, classLibsLength);", "+\t\tSystem.arraycopy(classpaths, 0, defaultClassPaths, 0, classpathsLength);", "+\t} else {", "+\t\tSystem.arraycopy(classLibs, 0, defaultClassPaths, 0, classLibsLength);", "+\t\tSystem.arraycopy(classpaths, 0, defaultClassPaths, classLibsLength, classpathsLength);", "+\t}", "+\tfor (int i = 0; i < classpathsLength; i++) {", "+\t\tFile file = new File(classpaths[i]);", "+\t\tif (!file.exists()) {", "+\t\t\tfile.mkdirs();", "+\t\t} ", "+\t}", "+\treturn defaultClassPaths;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a74873c9573ccb6c920a13e826c5bb3f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "7d36cd74d7dfc1f56f940c426e98d6c489655858", "commitAfterChange": "f95e58c822d23fa71cf6c6e2ac3adce80f07a42f", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": " public String toString()", "signatureAfterChange": " public String toString()", "diff": ["+\tif (this.typeVariables == null) {", "+\t\tbuffer.append(\"<NULL TYPE VARIABLES>\"); //$NON-NLS-1$", "+\t} else if (this.typeVariables != Binding.NO_TYPE_VARIABLES) {", "+\t\tbuffer.append(\"<\"); //$NON-NLS-1$", "+\t\tfor (int i = 0, length = this.typeVariables.length; i < length; i++) {", "+\t\t\tif (i  > 0) buffer.append(\", \"); //$NON-NLS-1$", "+\t\t\tif (this.typeVariables[i] == null) {", "+\t\t\t\tbuffer.append(\"NULL TYPE VARIABLE\"); //$NON-NLS-1$", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tchar[] varChars = this.typeVariables[i].toString().toCharArray();", "+\t\t\tbuffer.append(varChars, 1, varChars.length - 2);", "+\t\t}", "+\t\tbuffer.append(\">\"); //$NON-NLS-1$", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3c675d40bc00f2939ad7cb8bb31e4f8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "a0fd6dae6dbb696f05ef352cad9852f287a5aeec", "commitAfterChange": "3f1cbb254c604c7416bb668e3ca0c2f6d90b8afc", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tprivate BoundSet resolve() throws InferenceFailureException", "signatureAfterChange": " \tprivate BoundSet resolve() throws InferenceFailureException", "diff": ["-\t\t\t\t\t\t// FIXME: remove capture bounds", "+\t\t\t\t\t\tIterator captureKeys = tmpBoundSet.captures.keySet().iterator();", "+\t\t\t\t\t\tSet toRemove = new HashSet();", "+\t\t\t\t\t\twhile (captureKeys.hasNext()) {", "+\t\t\t\t\t\t\tParameterizedTypeBinding key = (ParameterizedTypeBinding) captureKeys.next();", "+\t\t\t\t\t\t\tint len = key.arguments.length;", "+\t\t\t\t\t\t\tfor (int i = 0; i < len; i++) {", "+\t\t\t\t\t\t\t\tif (key.arguments[i] == variable) { //$IDENTITY-COMPARISON$", "+\t\t\t\t\t\t\t\t\ttoRemove.add(key);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcaptureKeys = toRemove.iterator();", "+\t\t\t\t\t\twhile (captureKeys.hasNext())", "+\t\t\t\t\t\t\ttmpBoundSet.captures.remove(captureKeys.next());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c36c26d39d3f4a8d4b505e25fa528b15", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "d3d92e370789aaaed8a46c804d74e3cb2b4bb167", "commitAfterChange": "07061c09a4baa11ac0a53e425e478493f3662bd4", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "signatureAfterChange": " \t \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "diff": ["-\t\tcodeStream.invokeDynamic(invokeDynamicNumber, 0, 1, TypeConstants.ANONYMOUS_METHOD, CharOperation.concat(\"()\".toCharArray(), this.descriptor.declaringClass.signature())); //$NON-NLS-1$", "+\t\tStringBuffer signature = new StringBuffer();", "+\t\tsignature.append('(');", "+\t\tfor (int i = 0, length = this.outerLocalVariables == null ? 0 : this.outerLocalVariables.length; i < length; i++) {", "+\t\t\tsignature.append(this.outerLocalVariables[i].type.signature());", "+\t\t\tLocalVariableBinding capturedOuterLocal = this.outerLocalVariables[i].actualOuterLocalVariable;", "+\t\t\tVariableBinding[] path = currentScope.getEmulationPath(capturedOuterLocal);", "+\t\t\tcodeStream.generateOuterAccess(path, this, capturedOuterLocal, currentScope);", "+\t\t}", "+\t\tsignature.append(')');", "+\t\tsignature.append(this.descriptor.declaringClass.signature());", "+\t\tcodeStream.invokeDynamic(invokeDynamicNumber, this.outerLocalVariablesSlotSize, 1, TypeConstants.ANONYMOUS_METHOD, signature.toString().toCharArray());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c685a4e63213d69f41d4c2a747751227", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests2.java", "commitBeforeChange": "a790cc2a1fe344908ce312351c9762d437d04475", "commitAfterChange": "96135df97393d0f8f1ee1a690487357a43849eda", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t\t\tpublic IClasspathEntry[] getClasspathEntries()", "signatureAfterChange": " \t\t\tpublic IClasspathEntry[] getClasspathEntries()", "diff": ["+\t\t", "+\t\t\t\t    IAccessRule[] accessRules;", "+\t\t\t\t    if(forbiddenReferences != null && forbiddenReferences[j]!= null && forbiddenReferences[j].length() != 0) {", "+\t\t\t\t\t    StringTokenizer tokenizer = new StringTokenizer(forbiddenReferences[j], \";\");", "+\t\t\t\t\t    int count = tokenizer.countTokens();", "+\t\t\t\t\t    accessRules = new IAccessRule[count];", "+\t\t\t\t\t    String token = null;", "+\t\t\t\t\t    for (int i = 0; i < count; i++) {", "+\t\t\t\t\t    \ttoken = tokenizer.nextToken();", "+\t\t\t\t\t\t\taccessRules[i] = JavaCore.newAccessRule(new Path(token), IAccessRule.K_NON_ACCESSIBLE);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\taccessRules = new IAccessRule[0];", "+\t\t\t\t\t}", "-\t\t\t\t        entries[j] = JavaCore.newProjectEntry(path, isExported);", "+\t\t\t\t        entries[j] = JavaCore.newProjectEntry(path, accessRules, true, null, isExported);", "-\t\t\t\t\t\tentries[j] = JavaCore.newLibraryEntry(path, null, null, isExported);", "+\t\t\t\t\t\tentries[j] = JavaCore.newLibraryEntry(path, null, null, accessRules, null, isExported);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c6b2a21971421421a42437f60abea1a1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java", "commitBeforeChange": "b420bfdd4a859691c7aeac5921ac84f8a5db1f18", "commitAfterChange": "6cf1783794eb1a6e5e7c6e98927f2c861618e7ac", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tpublic String getQualifiedName()", "signatureAfterChange": " \tpublic String getQualifiedName()", "diff": ["-\t\treturn this.getName();", "+\t\tReferenceBinding referenceBinding = getReferenceBinding();", "+\t\tif (referenceBinding != null) {", "+\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\tchar[] brackets = new char[this.dimensions * 2];", "+\t\t\tfor (int i = this.dimensions * 2 - 1; i >= 0; i -= 2) {", "+\t\t\t\tbrackets[i] = ']';", "+\t\t\t\tbrackets[i - 1] = '[';", "+\t\t\t}", "+\t\t\tbuffer.append(CharOperation.toString(referenceBinding.compoundName));", "+\t\t\tbuffer.append(brackets);", "+\t\t\treturn String.valueOf(buffer);", "+\t\t} else { ", "+\t\t\treturn getName();", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf4403dee3517501eda801a918432466", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tprotected IJavaElement[] getUnqualifiedMethodHandle(IMethod method, boolean noDollar)", "signatureAfterChange": " \tprotected IJavaElement[] getUnqualifiedMethodHandle(IMethod method, boolean noDollar)", "diff": ["-\t\t\tif (qualifiedName.charAt(count) == Signature.C_RESOLVED) {", "+\t\t\tchar currentChar = qualifiedName.charAt(count);", "+\t\t\tif (currentChar == Signature.C_RESOLVED || currentChar == Signature.C_TYPE_VARIABLE) {", "-\t\t\t\tif(!noDollar) {", "-\t\t\t\t\tif(!hasDollar && simpleName.indexOf('$') != -1) {", "-\t\t\t\t\t\thasDollar = true;", "+\t\t\t\tint lastDollar = simpleName.lastIndexOf('$');", "+\t\t\t\thasDollar |= lastDollar != -1;", "+\t\t\t\tint start = noDollar ? lastDollar + 1 : 0;", "+\t\t\t\tboolean sigStart = false;", "+\t\t\t\tfor (int j = start, length = simpleName.length(); j < length; j++) {", "+\t\t\t\t\tchar current = simpleName.charAt(j);", "+\t\t\t\t\tswitch (current) {", "+\t\t\t\t\t\tcase Signature.C_SUPER:", "+\t\t\t\t\t\tcase Signature.C_EXTENDS:", "+\t\t\t\t\t\tcase Signature.C_GENERIC_START:", "+\t\t\t\t\t\tcase Signature.C_NAME_END:", "+\t\t\t\t\t\t\tunqualifiedName.append(current);", "+\t\t\t\t\t\t\tsigStart = true;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\tif (sigStart) {", "+\t\t\t\t\t\t\t\tif (current == Signature.C_TYPE_VARIABLE) {", "+\t\t\t\t\t\t\t\t\tunqualifiedName.append(Signature.C_UNRESOLVED);", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tunqualifiedName.append(current);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tsigStart = false;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tunqualifiedName.append(current);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\tunqualifiedName.append(simpleName);", "-\t\t\t\t} else {", "-\t\t\t\t\tunqualifiedName.append(CharOperation.lastSegment(simpleName.toCharArray(), '$'));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd53824c178993ed0a03e989bf3d8f8e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java", "commitBeforeChange": "0218d2fde27ae288f3eb227e030a2aee2bd32f49", "commitAfterChange": "025f6a96e3e3c149e01b0d88c99b73f42c4c49af", "methodNumberBeforeChange": 111, "methodNumberAfterChange": 111, "signatureBeforeChange": " \tprivate static String toUnresolvedTypeSignature(char[] signature)", "signatureAfterChange": "  \tprivate static int toUnresolvedTypeSignature(char[] signature, int start, int length, StringBuffer buffer)", "diff": ["-\tprivate static String toUnresolvedTypeSignature(char[] signature) {", "-\t\tint length = signature.length;", "-\t\tif (length <= 1) {", "-\t\t\treturn new String(signature);", "-\t\t}", "-\t\tStringBuffer buffer = new StringBuffer(length);", "-\t\ttoUnresolvedTypeSignature(signature, 0, length, buffer);", "-\t\treturn String.valueOf(buffer);", "-\t}", "+\tprivate static int toUnresolvedTypeSignature(char[] signature, int start, int length, StringBuffer buffer) {", "+\t\t\t\ti = toUnresolvedTypeSignature(signature, i+1, length, buffer);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dfc0bd455b43a56aef0ecd3d38b12034", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterMassiveRegressionTests.java", "commitBeforeChange": "48b439005b4e27b9edf7ac75008df6663dca3609", "commitAfterChange": "db94ada762c25cbafb7604978ccc4fc3df281550", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  private static void setLogDir(StringBuffer buffer)", "signatureAfterChange": "  private static void setLogDir(StringBuffer buffer) throws CoreException", "diff": ["-private static void setLogDir(StringBuffer buffer) {", "+private static void setLogDir(StringBuffer buffer) throws CoreException {", "+//\tIWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();", "+//\tIProject project = root.getProject(\"Bugs\");", "+//\tIFolder rootFolder = project.getFolder(\"Formatter\");", "+//\tIFolder folder = rootFolder.getFolder(ECLIPSE_VERSION);", "+//\tif (!folder.exists()) folder.create(true, true, null);", "+\t\tlogDir = new File(logDir, PATCH_VERSION);", "+//\t\tfolder = folder.getFolder(\"tests\");", "+//\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\tfolder = folder.getFolder(PATCH_BUG);", "+//\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\tfolder = folder.getFolder(PATCH_VERSION);", "+//\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\tfolder = folder.getFolder(\"HEAD\");", "+//\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\tfolder = folder.getFolder(ECLIPSE_MILESTONE);", "+//\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\tfolder = folder.getFolder(JDT_CORE_VERSION);", "+//\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\tfolder = folder.getFolder(\"profiles\");", "+//\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\t\tfolder = folder.getFolder(\"join_lines\");", "+//\t\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\t\tfolder = folder.getFolder(JOIN_LINES);", "+//\t\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\t\tfolder = folder.getFolder(\"no_comments\");", "+//\t\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\t\tfolder = folder.getFolder(\"braces\");", "+//\t\t\tif (!folder.exists()) folder.create(true, true, null);", "+//\t\t\tfolder = folder.getFolder(BRACES);", "+//\t\t\tif (!folder.exists()) folder.create(true, true, null);", "-\tString logFileName = INPUT_DIR.getName().replaceAll(\"\\\\.\", \"\")+\".txt\";", "+\tString filePrefix = INPUT_DIR.getName().replaceAll(\"\\\\.\", \"\");", "+\tString logFileName = filePrefix+\".txt\";", "+\tif (LOG_FILE.exists()) {", "+\t\tFile saveDir = new File(logDir, \"save\");", "+\t\tsaveDir.mkdir();", "+\t\tint i=0;", "+\t\twhile (true) {", "+\t\t\tString newFileName = filePrefix+\"_\";", "+\t\t\tif (i<10) newFileName += \"0\";", "+\t\t\tnewFileName += i+\".txt\";", "+\t\t\tFile renamedFile = new File(saveDir, newFileName);", "+\t\t\tif (LOG_FILE.renameTo(renamedFile)) break;", "+\t\t\ti++;", "+\t\t}", "+\t}", "+//\tLOG_RESOURCE = folder.getFile(logFileName);", "+//\tbuffer.append(LOG_RESOURCE.getFullPath());", "-\t\tif (LOG_FILE.exists()) {", "-\t\t\tUtil.delete(LOG_FILE);", "-\t\t}", "+\t\tLOG_STREAM.flush();", "+//\tif (LOG_RESOURCE.exists()) {", "+//\t\tUtil.delete(LOG_RESOURCE);", "+//\t}", "+//\tLOG_BUFFER = new StringBuffer();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ebf9df1d6ef015f2e0265a76fa4e7e43", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "1ba6cf1a1cd58ea6964d3e53d500ba37300ad6c5", "commitAfterChange": "122386dad13a4daa4a6eb3fe318a2c079a2655ef", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r \tITypeBinding resolveType(Type type)", "signatureAfterChange": "\r \tITypeBinding resolveType(Type type)", "diff": ["+\t\t\t\t\tif (type.isArrayType()) {\r", "+\t\t\t\t\t\tArrayType array = (ArrayType) type;\r", "+\t\t\t\t\t\tif (typeBinding.getDimensions() != array.getDimensions()) {\r", "+\t\t\t\t\t\t\tArrayBinding arrayBinding = (ArrayBinding)typeReference.binding;\r", "+\t\t\t\t\t\t\tfor (int i = 0, max = typeBinding.getDimensions() - array.getDimensions(); i < max; i++) {\r", "+\t\t\t\t\t\t\t\tarrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else if (typeBinding.isArray() && type.isSimpleType()) {\r", "+\t\t\t\t\t\treturn this.getTypeBinding(((ArrayBinding)typeReference.binding).leafComponentType());\r", "+\t\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5798d350719e7220e4c4c5bb7ebff3c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 8, "signatureBeforeChange": " public boolean generateSubRoutineInvocation(BlockScope currentScope, CodeStream codeStream, Object targetLocation, int stateIndex, LocalVariableBinding secretLocal)", "signatureAfterChange": " public boolean generateSubRoutineInvocation(BlockScope currentScope, CodeStream codeStream, Object targetLocation, int stateIndex, LocalVariableBinding secretLocal)", "diff": ["+\tint resourceCount = this.resources.length;", "+\tif (resourceCount > 0) {", "+\t\tfor (int i = resourceCount; i > 0; --i) {", "+\t\t\t// Disarm the handlers and take care of resource closure.", "+\t\t\tthis.resourceExceptionLabels[i].placeEnd();", "+\t\t\tLocalVariableBinding localVariable = this.resources[i-1].binding;", "+\t\t\tBranchLabel exitLabel = new BranchLabel(codeStream);", "+\t\t\tint invokeCloseStartPc = codeStream.position; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=343785", "+\t\t\tcodeStream.load(localVariable);", "+\t\t\tcodeStream.ifnull(exitLabel);", "+\t\t\tcodeStream.load(localVariable);", "+\t\t\tcodeStream.invokeAutoCloseableClose(localVariable.type);", "+\t\t\tcodeStream.recordPositionsFrom(invokeCloseStartPc, this.tryBlock.sourceEnd);", "+\t\t\texitLabel.place();", "+\t\t}", "+\t\t// Reinstall handlers", "+\t\tfor (int i = resourceCount; i > 0; --i) {", "+\t\t\tthis.resourceExceptionLabels[i].placeStart();", "+\t\t}", "+\t}", "+", "-\t\t\tif (this.naturalExitMergeInitStateIndex != -1 || stateIndex != -1) {", "-\t\t\t\t// reset initialization state, as for a normal catch block", "-\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.naturalExitMergeInitStateIndex);", "-\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.naturalExitMergeInitStateIndex);", "-\t\t\t}", "-\t\t} else {", "-\t\t\tif (this.naturalExitMergeInitStateIndex != -1) {", "-\t\t\t\t// reset initialization state, as for a normal catch block", "-\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.naturalExitMergeInitStateIndex);", "-\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.naturalExitMergeInitStateIndex);", "-\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f59366d07ead035c8972a71f3330aeb2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/OrPattern.java", "commitBeforeChange": "9037a5669c89fc0ae3f8548a99dce6fa5402fb31", "commitAfterChange": "e4e1e1935f0e7607d1265df332c7ce922de89c18", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": " protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "diff": ["-\tint leftLevel = this.leftPattern.matchLevel(reference, true);", "-\tif (leftLevel == ACCURATE_MATCH || leftLevel == INACCURATE_MATCH) {", "-\t\tthis.leftPattern.matchReportReference(reference, element, accuracy, locator);", "-\t} else {", "-\t\tthis.rightPattern.matchReportReference(reference, element, accuracy, locator);", "+\tif (this.bestMatch != null) {", "+\t\tthis.bestMatch.matchReportReference(reference, element, accuracy, locator);", "+\t\treturn;", "+", "+\tSearchPattern closestPattern = null;", "+\tint level = IMPOSSIBLE_MATCH;", "+\tfor (int i = 0, length = this.patterns.length; i < length; i++) {", "+\t\tint newLevel = this.patterns[i].matchLevel(reference, true);", "+\t\tif (newLevel > level) {", "+\t\t\tif (newLevel == ACCURATE_MATCH) {", "+\t\t\t\tthis.patterns[i].matchReportReference(reference, element, accuracy, locator);", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tlevel = newLevel;", "+\t\t\tclosestPattern = this.patterns[i];", "+\t\t}", "+\t}", "+\tif (closestPattern != null)", "+\t\tclosestPattern.matchReportReference(reference, element, accuracy, locator);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f6f8a5d713dce6cd329ba45d42955e67", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/TestingEnvironment.java", "commitBeforeChange": "5978fb5add266a6b89021d9e3d0424d77fb0f8da", "commitAfterChange": "108542969a1d7f14803221b232d5a5fa98603735", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 43, "signatureBeforeChange": " \tprivate void handleCoreException(CoreException e)", "signatureAfterChange": " \tprivate void handleCoreException(CoreException e)", "diff": ["+\t\tIStatus status = e.getStatus();", "+\t\tString message = e.getMessage();", "+\t\tif (status.isMultiStatus()) {", "+\t\t\tMultiStatus multiStatus = (MultiStatus) status;", "+\t\t\tIStatus[] children = multiStatus.getChildren();", "+\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\tfor (int i = 0, max = children.length; i < max; i++) {", "+\t\t\t\tIStatus child = children[i];", "+\t\t\t\tif (child != null) {", "+\t\t\t\t\tbuffer.append(child.getMessage());", "+\t\t\t\t\tbuffer.append(System.getProperty(\"line.separator\"));//$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tmessage = String.valueOf(buffer);", "+\t\t}", "-\t\t\t\"Core exception in testing environment: \" + e.getMessage()); //$NON-NLS-1$", "+\t\t\t\"Core exception in testing environment: \" + message); //$NON-NLS-1$"]}], "num": 32957}