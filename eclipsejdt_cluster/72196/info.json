{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c6df9d06695eee9167e050423b964fd4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f9a7221f8155a2d2976a41635941f0d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "618f3771c49dbf9480ae16a58263680af2b36ad6", "commitAfterChange": "7cfc4523cdcfe787f1d0d2fd75b08c06e5b4b089", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate Expression parseArguments(TypeReference receiver) throws InvalidInputException", "signatureAfterChange": " \tprotected Object createMethodReference(Object receiver, List arguments) throws InvalidInputException", "diff": ["-\tprivate Expression parseArguments(TypeReference receiver) throws InvalidInputException {", "-", "-\t\t// Init", "-\t\tint modulo = 0; // should be 2 for (Type,Type,...) or 3 for (Type arg,Type arg,...)", "-\t\tint iToken = 0;", "-\t\tchar[] argName = null;", "-\t\tint ptr = this.astPtr;", "-\t\tint lptr = this.astLengthPtr;", "-\t\t", "-\t\t// Decide whether we have a constructor or not", "-\t\tboolean isConstructor = true;", "-\t\tif (receiver != null) {", "-\t\t\tchar[][] receiverTokens = receiver.getTypeName();", "-\t\t\tchar[] memberName = this.identifierStack[0];", "-\t\t\tisConstructor = CharOperation.equals(memberName, receiverTokens[receiverTokens.length-1]);", "-\t\t}", "-", "-\t\t// Parse arguments declaration if method reference", "-\t\tnextArg : while (this.index < this.scanner.eofPosition) {", "-", "-\t\t\t// Read argument type reference", "-\t\t\tTypeReference typeRef;", "-\t\t\ttry {", "-\t\t\t\ttypeRef = parseQualifiedName(false);", "-\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\tboolean firstArg = modulo == 0;", "-\t\t\tif (firstArg) { // verify position", "-\t\t\t\tif (iToken != 0)", "-\t\t\t\t\tbreak nextArg;", "-\t\t\t} else if ((iToken % modulo) != 0) {", "-\t\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\tif (typeRef == null) {", "-\t\t\t\tif (firstArg && this.currentTokenType == TerminalTokens.TokenNameRPAREN) {", "-\t\t\t\t\tif (isConstructor) {", "-\t\t\t\t\t\tJavadocAllocationExpression expr = new JavadocAllocationExpression(this.identifierPositionStack[0]);", "-\t\t\t\t\t\texpr.type = receiver;", "-\t\t\t\t\t\treturn expr;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[0], this.identifierPositionStack[0]);", "-\t\t\t\t\t\tmsg.receiver = receiver;", "-\t\t\t\t\t\treturn msg;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\tint argStart = typeRef.sourceStart;", "-\t\t\tint argEnd = typeRef.sourceEnd;", "-\t\t\tiToken++;", "-", "-\t\t\t// Read possible array declaration", "-\t\t\tint dim = 0;", "-\t\t\tif (readToken() == TerminalTokens.TokenNameLBRACKET) {", "-\t\t\t\twhile (readToken() == TerminalTokens.TokenNameLBRACKET) {", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tif (readToken() != TerminalTokens.TokenNameRBRACKET) {", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t\t}", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tdim++;", "-\t\t\t\t}", "-\t\t\t\tlong pos = ((long) typeRef.sourceStart) << 32 + typeRef.sourceEnd;", "-\t\t\t\t\ttypeRef = new JavadocArraySingleTypeReference(singleRef.token, dim, pos);", "-\t\t\t\t\ttypeRef = new JavadocArrayQualifiedTypeReference(qualifRef, dim);", "-", "-\t\t\t// Read argument name", "-\t\t\tif (readToken() == TerminalTokens.TokenNameIdentifier) {", "-\t\t\t\tconsumeToken();", "-\t\t\t\tif (firstArg) { // verify position", "-\t\t\t\t\tif (iToken != 1)", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t} else if ((iToken % modulo) != 1) {", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t}", "-\t\t\t\tif (argName == null) { // verify that all arguments name are declared", "-\t\t\t\t\tif (!firstArg) {", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\targName = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\targEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\tiToken++;", "-\t\t\t} else if (argName != null) { // verify that no argument name is declared", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\t", "-\t\t\t// Verify token position", "-\t\t\tif (firstArg) {", "-\t\t\t\tmodulo = iToken + 1;", "-\t\t\t} else {", "-\t\t\t\tif ((iToken % modulo) != (modulo - 1)) {", "-\t\t\t\t\tbreak nextArg;", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\t// Read separator or end arguments declaration", "-\t\t\tint token = readToken();", "-\t\t\tchar[] name = argName == null ? new char[0] : argName;", "-\t\t\tif (token == TerminalTokens.TokenNameCOMMA) {", "-\t\t\t\t// Create new argument", "-\t\t\t\tJavadocArgumentExpression expr = new JavadocArgumentExpression(name, argStart, argEnd, typeRef);", "-\t\t\t\tpushOnAstStack(expr, firstArg);", "-\t\t\t\tconsumeToken();", "-\t\t\t\tiToken++;", "-\t\t\t} else if (token == TerminalTokens.TokenNameRPAREN) {", "-\t\t\t\t// Create new argument", "-\t\t\t\tJavadocArgumentExpression expr = new JavadocArgumentExpression(name, argStart, argEnd, typeRef);", "-\t\t\t\tpushOnAstStack(expr, firstArg);", "-\t\t\t\tint size = this.astLengthStack[this.astLengthPtr--];", "-\t\t\t\t// Build arguments array", "-\t\t\t\tJavadocArgumentExpression[] arguments = new JavadocArgumentExpression[size];", "-\t\t\t\tfor (int i = (size - 1); i >= 0; i--) {", "-\t\t\t\t\targuments[i] = (JavadocArgumentExpression) this.astStack[this.astPtr--];", "-\t\t\t\t}", "-\t\t\t\t// Create message send", "-\t\t\t\tif (isConstructor) {", "-\t\t\t\t\tJavadocAllocationExpression alloc = new JavadocAllocationExpression(this.identifierPositionStack[0]);", "-\t\t\t\t\talloc.arguments = arguments;", "-\t\t\t\t\talloc.type = receiver;", "-\t\t\t\t\treturn alloc;", "-\t\t\t\t} else {", "-\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[0], this.identifierPositionStack[0], arguments);", "-\t\t\t\t\tmsg.receiver = receiver;", "-\t\t\t\t\treturn msg;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-", "-\t\t// Invalid input: reset ast stacks pointers", "-\t\tconsumeToken();", "-\t\tif (iToken > 0) {", "-\t\t\tthis.astPtr = ptr;", "-\t\t\tthis.astLengthPtr = lptr;", "-\t\t}", "-\t\tthrow new InvalidInputException();", "-\t}", "+\tprotected Object createMethodReference(Object receiver, List arguments) throws InvalidInputException {", "+\t\t\t// Get receiver type", "+\t\t\tTypeReference typeRef = (TypeReference) receiver;", "+\t\t\tif (typeRef == null) {", "+\t\t\t\tchar[] name = this.sourceParser.compilationUnit.compilationResult.compilationUnit.getMainTypeName();", "+\t\t\t\tif (name == null) {", "+\t\t\t\t\tthrow new InvalidInputException();", "+\t\t\t\t}", "+\t\t\t\ttypeRef = new JavadocSingleTypeReference(name, 0, 0, 0);", "+\t\t\t// Decide whether we have a constructor or not", "+\t\t\tchar[][] receiverTokens = typeRef.getTypeName();", "+\t\t\tchar[] memberName = this.identifierStack[0];", "+\t\t\tboolean isConstructor = CharOperation.equals(memberName, receiverTokens[receiverTokens.length-1]);", "+\t\t\t// Create node", "+\t\t\tif (arguments == null) {", "+\t\t\t\tif (isConstructor) {", "+\t\t\t\t\tJavadocAllocationExpression expr = new JavadocAllocationExpression(this.identifierPositionStack[0]);", "+\t\t\t\t\texpr.type = typeRef;", "+\t\t\t\t\treturn expr;", "+\t\t\t\t} else {", "+\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[0], this.identifierPositionStack[0]);", "+\t\t\t\t\tmsg.receiver = typeRef;", "+\t\t\t\t\treturn msg;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tJavadocArgumentExpression[] expressions = new JavadocArgumentExpression[arguments.size()];", "+\t\t\t\targuments.toArray(expressions);", "+\t\t\t\tif (isConstructor) {", "+\t\t\t\t\tJavadocAllocationExpression alloc = new JavadocAllocationExpression(this.identifierPositionStack[0]);", "+\t\t\t\t\talloc.arguments = expressions;", "+\t\t\t\t\talloc.type = typeRef;", "+\t\t\t\t\treturn alloc;", "+\t\t\t\t} else {", "+\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[0], this.identifierPositionStack[0], expressions);", "+\t\t\t\t\tmsg.receiver = typeRef;", "+\t\t\t\t\treturn msg;", "+\t\t\t\t}", "+\t\t\t}", "+\t\tcatch (ClassCastException ex) {", "+\t\t\t\tthrow new InvalidInputException();", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f169c44d4d4d685da7380f28c340be2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "b8b8ddf64dedf8c9c31f5a6a372768428e737f63", "commitAfterChange": "4889f3babd91783f30bca6f07ba58254cecf87d1", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " void faultInImports()", "signatureAfterChange": " void faultInImports()", "diff": ["-\tImportBinding[] resolvedImports = new ImportBinding[numberOfImports];", "-\tresolvedImports[0] = getDefaultImports()[0];", "-\tint index = 1;", "-", "+\tthis.tempImports = new ImportBinding[numberOfImports];", "+\tthis.tempImports[0] = getDefaultImports()[0];", "+\tthis.importPtr = 1;", "+\t", "-\t\tfor (int j = 0; j < index; j++) {", "-\t\t\tImportBinding resolved = resolvedImports[j];", "+\t\tfor (int j = 0; j < this.importPtr; j++) {", "+\t\t\tImportBinding resolved = this.tempImports[j];", "-\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, true, importBinding, importReference);", "+\t\t\trecordImportBinding(new ImportBinding(compoundName, true, importBinding, importReference));", "-\t\t\tReferenceBinding conflictingType = null;", "-\t\t\tif (importBinding instanceof MethodBinding) {", "-\t\t\t\tconflictingType = (ReferenceBinding) getType(compoundName, compoundName.length);", "-\t\t\t\tif (!conflictingType.isValidBinding() || (importReference.isStatic() && !conflictingType.isStatic()))", "-\t\t\t\t\tconflictingType = null;", "-\t\t\t}", "-\t\t\t// collisions between an imported static field & a type should be checked according to spec... but currently not by javac", "-\t\t\tif (importBinding instanceof ReferenceBinding || conflictingType != null) {", "-\t\t\t\tReferenceBinding referenceBinding = conflictingType == null ? (ReferenceBinding) importBinding : conflictingType;", "-\t\t\t\tReferenceBinding typeToCheck = referenceBinding.problemId() == ProblemReasons.Ambiguous", "-\t\t\t\t\t? ((ProblemReferenceBinding) referenceBinding).closestMatch", "-\t\t\t\t\t: referenceBinding;", "-\t\t\t\tif (importReference.isTypeUseDeprecated(typeToCheck, this))", "-\t\t\t\t\tproblemReporter().deprecatedType(typeToCheck, importReference);", "-", "-\t\t\t\tReferenceBinding existingType = typesBySimpleNames.get(compoundName[compoundName.length - 1]);", "-\t\t\t\tif (existingType != null) {", "-\t\t\t\t\t// duplicate test above should have caught this case, but make sure", "-\t\t\t\t\tif (existingType == referenceBinding) {", "-\t\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=302865", "-\t\t\t\t\t\t// Check all resolved imports to see if this import qualifies as a duplicate", "-\t\t\t\t\t\tfor (int j = 0; j < index; j++) {", "-\t\t\t\t\t\t\tImportBinding resolved = resolvedImports[j];", "-\t\t\t\t\t\t\tif (resolved instanceof ImportConflictBinding) {", "-\t\t\t\t\t\t\t\tImportConflictBinding importConflictBinding = (ImportConflictBinding) resolved;", "-\t\t\t\t\t\t\t\tif (importConflictBinding.conflictingTypeBinding == referenceBinding) {", "-\t\t\t\t\t\t\t\t\tif (!importReference.isStatic()) {", "-\t\t\t\t\t\t\t\t\t\t// resolved is implicitly static", "-\t\t\t\t\t\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\t\t\t\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, false, importBinding, importReference);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (resolved.resolvedImport == referenceBinding) {", "-\t\t\t\t\t\t\t\tif (importReference.isStatic() != resolved.isStatic()) {", "-\t\t\t\t\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\t\t\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, false, importBinding, importReference);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t\t}", "-\t\t\t\t\t// either the type collides with a top level type or another imported type", "-\t\t\t\t\tfor (int j = 0, length = this.topLevelTypes.length; j < length; j++) {", "-\t\t\t\t\t\tif (CharOperation.equals(this.topLevelTypes[j].sourceName, existingType.sourceName)) {", "-\t\t\t\t\t\t\tproblemReporter().conflictingImport(importReference);", "-\t\t\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t}", "-\t\t\t\ttypesBySimpleNames.put(compoundName[compoundName.length - 1], referenceBinding);", "-\t\t\t} else if (importBinding instanceof FieldBinding) {", "-\t\t\t\tfor (int j = 0; j < index; j++) {", "-\t\t\t\t\tImportBinding resolved = resolvedImports[j];", "-\t\t\t\t\t// find other static fields with the same name", "-\t\t\t\t\tif (resolved.isStatic() && resolved.resolvedImport instanceof FieldBinding && importBinding != resolved.resolvedImport) {", "-\t\t\t\t\t\tif (CharOperation.equals(compoundName[compoundName.length - 1], resolved.compoundName[resolved.compoundName.length - 1])) {", "-\t\t\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t// all the code here which checks for valid bindings have been moved to the method ", "+\t\t\t// checkAndRecordImportBinding() since bug 361327", "+\t\t\tif(checkAndRecordImportBinding(importBinding, typesBySimpleNames, importReference, compoundName) == -1)", "+\t\t\t\tcontinue nextImport;", "+\t\t\tif (importReference.isStatic()) {", "+\t\t\t\t// look for more static bindings being imported by single static import(bug 361327).", "+\t\t\t\t// findSingleImport() finds fields first, followed by method and then type", "+\t\t\t\t// So if a type is found, no fields and methods are available anyway", "+\t\t\t\t// similarly when method is found, type may be available but no field available for sure", "+\t\t\t\tif (importBinding.kind() == Binding.FIELD) {", "+\t\t\t\t\tcheckMoreStaticBindings(compoundName, typesBySimpleNames, Binding.TYPE | Binding.METHOD, importReference);\t\t", "+\t\t\t\t} else if (importBinding.kind() == Binding.METHOD) {", "+\t\t\t\t\tcheckMoreStaticBindings(compoundName, typesBySimpleNames, Binding.TYPE, importReference);", "-\t\t\tresolvedImports[index++] = conflictingType == null", "-\t\t\t\t? new ImportBinding(compoundName, false, importBinding, importReference)", "-\t\t\t\t: new ImportConflictBinding(compoundName, importBinding, conflictingType, importReference);", "-\tif (resolvedImports.length > index)", "-\t\tSystem.arraycopy(resolvedImports, 0, resolvedImports = new ImportBinding[index], 0, index);", "-\tthis.imports = resolvedImports;", "-", "+\tif (this.tempImports.length > this.importPtr)", "+\t\tSystem.arraycopy(this.tempImports, 0, this.tempImports = new ImportBinding[this.importPtr], 0, this.importPtr);", "+\tthis.imports = this.tempImports;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa3b2a3f8708197c25de46c44cd15586", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "386973a3070496c014c76dfef6b370eb80aa95d3", "commitAfterChange": "1e351d47b6a42ac5f4bfe0ec77b007aad61afe06", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["+\t\tthis.internalGenerateCode(classScope, classFile);\r", "+\t} catch (AbortMethod e) {\r", "+\t\tif (e.compilationResult == CodeStream.RESTART_IN_WIDE_MODE) {\r", "+\t\t\t// a branch target required a goto_w, restart code gen in wide mode.\r", "+\t\t\ttry {\r", "+\t\t\t\tif (statements != null) {\r", "+\t\t\t\t\tfor (int i = 0, max = statements.length; i < max; i++)\r", "+\t\t\t\t\t\tstatements[i].resetStateForCodeGeneration();\r", "+\t\t\t\t}\r", "+\t\t\t\tclassFile.contentsOffset = problemResetPC;\r", "+\t\t\t\tclassFile.methodCount--;\r", "+\t\t\t\tclassFile.codeStream.wideMode = true; // request wide mode \r", "+\t\t\t\tthis.internalGenerateCode(classScope, classFile); // restart method generation\r", "+\t\t\t} catch(AbortMethod e2) {\r", "+\t\t\t\tint problemsLength;\r", "+\t\t\t\tIProblem[] problems = scope.referenceCompilationUnit().compilationResult.getProblems();\r", "+\t\t\t\tIProblem[] problemsCopy = new IProblem[problemsLength = problems.length];\r", "+\t\t\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);\r", "+\t\t\t\tclassFile.addProblemConstructor(this, binding, problemsCopy, problemResetPC);\r", "+\t\t\t}\r", "+\t\t} else {\r", "+\t\t\t\tint problemsLength;\r", "+\t\t\t\tIProblem[] problems = scope.referenceCompilationUnit().compilationResult.getProblems();\r", "+\t\t\t\tIProblem[] problemsCopy = new IProblem[problemsLength = problems.length];\r", "+\t\t\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);\r", "+\t\t\t\tclassFile.addProblemConstructor(this, binding, problemsCopy, problemResetPC);\r", "+\t\t}\r", "+\t}\r", "+}\r", "-\t} catch (AbortMethod e) {\r", "-\t\tint problemsLength;\r", "-\t\tIProblem[] problems = scope.referenceCompilationUnit().compilationResult.getProblems();\r", "-\t\tIProblem[] problemsCopy = new IProblem[problemsLength = problems.length];\r", "-\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);\r", "-\t\tclassFile.addProblemConstructor(this, binding, problemsCopy, problemResetPC);\r", "-\t}\r"]}], "num": 72196}