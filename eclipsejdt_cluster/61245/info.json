{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f134a0cdb922b60428dd945fe994f681", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e87d6f5e86f3d2a351c7bf7bd093715", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "e67d1dc6830648c83fdb0e0b83b59925424638d8", "commitAfterChange": "4817a4bde9db799e7a793068d64037f59bfa521f", "methodNumberBeforeChange": 48, "methodNumberAfterChange": 47, "signatureBeforeChange": " private TypeBinding findDefaultNullness(Scope currentScope, LookupEnvironment environment)", "signatureAfterChange": " private int findNonNullDefault(Scope currentScope, LookupEnvironment environment)", "diff": ["-private TypeBinding findDefaultNullness(Scope currentScope, LookupEnvironment environment) {", "+private int findNonNullDefault(Scope currentScope, LookupEnvironment environment) {", "-\tTypeBinding annotationBinding;", "-\t\t\t\t\tannotationBinding = environment.getNullAnnotationBindingFromDefault(referenceMethod.binding.tagBits, true/*resolve*/);", "-\t\t\t\t\tif (annotationBinding != null)", "-\t\t\t\t\t\treturn annotationBinding;", "+\t\t\t\t\tlong methodTagBits = referenceMethod.binding.tagBits;", "+\t\t\t\t\tif ((methodTagBits & TagBits.AnnotationNonNullByDefault) != 0)", "+\t\t\t\t\t\treturn NONNULL_BY_DEFAULT;", "+\t\t\t\t\tif ((methodTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)", "+\t\t\t\t\t\treturn NULL_UNSPECIFIED_BY_DEFAULT;", "-\t\t\t\t\tannotationBinding = currentType.getNullnessDefaultAnnotation();", "-\t\t\t\t\tif (annotationBinding != null)", "-\t\t\t\t\t\treturn annotationBinding;", "+\t\t\t\t\tint foundDefaultNullness = currentType.defaultNullness;", "+\t\t\t\t\tif (foundDefaultNullness != NO_NULL_DEFAULT) {", "+\t\t\t\t\t\treturn foundDefaultNullness;", "+\t\t\t\t\t}", "-\t\tannotationBinding = currentType.getPackage().getNullnessDefaultAnnotation(this.scope);", "-\t\tif (annotationBinding != null)", "-\t\t\treturn annotationBinding;", "+\t\tint foundDefaultNullness = currentType.getPackage().defaultNullness;", "+\t\tif (foundDefaultNullness != NO_NULL_DEFAULT) {", "+\t\t\treturn foundDefaultNullness;", "+\t\t}", "-\tlong defaultNullness = environment.globalOptions.defaultNonNullness;", "-\tif (defaultNullness != 0) {", "-\t\t// we have a default, so we need an annotation type to record this during compile and in the byte code", "-\t\tannotationBinding = environment.getNullAnnotationBinding(defaultNullness, true/*resolve*/);", "-\t\tif (annotationBinding != null)", "-\t\t\treturn annotationBinding;", "-", "-\t\t// on this branch default was not defined using an annotation, thus annotation type can still be missing", "-\t\tif (defaultNullness == TagBits.AnnotationNonNull)", "-\t\t\tthis.scope.problemReporter().missingNullAnnotationType(environment.getNonNullAnnotationName());", "-\t\telse", "-\t\t\tthis.scope.problemReporter().abortDueToInternalError(\"Illegal default nullness value: \"+defaultNullness); //$NON-NLS-1$", "-\t\t// reset default to avoid duplicate errors:", "-\t\tenvironment.globalOptions.defaultNonNullness = 0;", "-\t}", "-\treturn null;", "+\tif (environment.globalOptions.defaultNonNullness == TagBits.AnnotationNonNull)", "+\t\treturn NONNULL_BY_DEFAULT;", "+\treturn NO_NULL_DEFAULT;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "acb4032869e82a3d16b83fe8e900a0eb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "16bbff04917b9cd9bd7cceaf4adfc1563daef0bc", "commitAfterChange": "898da07e1ab8f70e81db909fb2e1c38edc9b87c3", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-        \tint len = this.binding.parameters.length;", "+        \tint len;", "+        \tint expectedlen = this.binding.parameters.length;", "+        \tint providedLen = this.descriptor.parameters.length;", "+        \tboolean isVarArgs = false;", "+        \tif (this.binding.isVarargs()) {", "+        \t\tisVarArgs = (providedLen == expectedlen)", "+\t\t\t\t\t? !this.descriptor.parameters[expectedlen-1].isCompatibleWith(this.binding.parameters[expectedlen-1])", "+\t\t\t\t\t: true;", "+        \t\tlen = providedLen; // binding parameters will be padded from InferenceContext18.getParameter()", "+        \t} else {", "+        \t\tlen = Math.min(expectedlen, providedLen);", "+        \t}", "-    \t\t\tlong declared = this.descriptor.parameters[i+paramOffset].tagBits & TagBits.AnnotationNullMASK;", "-    \t\t\tlong implemented = this.binding.parameters[i].tagBits & TagBits.AnnotationNullMASK;", "-    \t\t\tif (declared == TagBits.AnnotationNullable) { // promise to accept null", "-    \t\t\t\tif (implemented != TagBits.AnnotationNullable) {", "-    \t\t\t\t\tchar[][] requiredAnnot = implemented == 0L ? null : scope.environment().getNonNullAnnotationName();", "-    \t\t\t\t\tscope.problemReporter().parameterLackingNullableAnnotation(this, this.descriptor, i, paramOffset, ", "-    \t\t\t\t\t\t\tscope.environment().getNullableAnnotationName(),", "-    \t\t\t\t\t\t\trequiredAnnot, this.binding.parameters[i]);", "-    \t\t\t\t}", "-    \t\t\t} else if (declared == 0L) {", "-    \t\t\t\tif (implemented == TagBits.AnnotationNonNull) {", "-    \t\t\t\t\tscope.problemReporter().parameterRequiresNonnull(this, this.descriptor, i+paramOffset,", "-    \t\t\t\t\t\t\tscope.environment().getNonNullAnnotationName(), this.binding.parameters[i]);", "-    \t\t\t\t}", "+    \t\t\tTypeBinding descriptorParameter = this.descriptor.parameters[i+paramOffset];", "+    \t\t\tTypeBinding bindingParameter = InferenceContext18.getParameter(this.binding.parameters, i, isVarArgs);", "+    \t\t\tNullAnnotationMatching annotationStatus = NullAnnotationMatching.analyse(bindingParameter, descriptorParameter, FlowInfo.UNKNOWN);", "+    \t\t\tif (annotationStatus.isAnyMismatch()) {", "+    \t\t\t\t// immediate reporting:", "+    \t\t\t\tscope.problemReporter().referenceExpressionArgumentNullityMismatch(this, bindingParameter, descriptorParameter, this.descriptor, i, annotationStatus);"]}], "num": 61245}