{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c83e25c56dca13189cfc6ad0cea8501d", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26c4889b7ea0255b0578c9746fe8f4ab", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 32, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod( \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\tpublic MethodBinding getImplicitMethod(", "-\t\tchar[] selector,", "-\t\tTypeBinding[] argumentTypes,", "-\t\tInvocationSite invocationSite) {", "+\tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "-\t\tProblemMethodBinding foundFuzzyProblem = null;", "+\t\tMethodBinding foundFuzzyProblem = null;", "-\t\tProblemMethodBinding foundInsideProblem = null;", "+\t\tMethodBinding foundInsideProblem = null;", "-\t\t\t\t\t\t\t? classScope.findExactMethod(", "-\t\t\t\t\t\t\t\treceiverType,", "-\t\t\t\t\t\t\t\tselector,", "-\t\t\t\t\t\t\t\targumentTypes,", "-\t\t\t\t\t\t\t\tinvocationSite)", "-\t\t\t\t\t\t\t: classScope.findExactMethod(", "-\t\t\t\t\t\t\t\treceiverType,", "-\t\t\t\t\t\t\t\tfoundMethod.selector,", "-\t\t\t\t\t\t\t\tfoundMethod.parameters,", "-\t\t\t\t\t\t\t\tinvocationSite);", "-\t\t\t\t\t//\t\t\t\t\t\t? findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-\t\t\t\t\t//\t\t\t\t\t\t: findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "+\t\t\t\t\t\t\t? classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "+\t\t\t\t\t\t\t: classScope.findExactMethod( receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "+\t\t\t\t\t//\t\t? findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "+\t\t\t\t\t//\t\t: findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-\t\t\t\t\t\tmethodBinding =", "-\t\t\t\t\t\t\tclassScope.findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t//\t\t\t\t\tmethodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "+\t\t\t\t\t\tmethodBinding = classScope.findMethod(receiverType, selector, argumentTypes, invocationSite);", "+\t\t\t\t\t\t// methodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\tProblemMethodBinding fuzzyProblem = null;", "-\t\t\t\t\t\tProblemMethodBinding insideProblem = null;", "+\t\t\t\t\t\tMethodBinding fuzzyProblem = null;", "+\t\t\t\t\t\tMethodBinding insideProblem = null;", "-\t\t\t\t\t\t\t\tif (!areParametersAssignable(methodBinding.parameters, argumentTypes)) {", "-\t\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == NotVisible){", "+\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "+\t\t\t\t\t\t\t\tif (compatibleMethod == null) {", "+\t\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == NotVisible)", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(selector, methodBinding.parameters, InheritedNameHidesEnclosingName);", "-", "-\t\t\t\t\t\t\t\t} else if (!methodBinding.canBeSeenBy(receiverType, invocationSite, classScope)) {", "-\t\t\t\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "-\t\t\t\t\t\t\t\t\tfuzzyProblem =", "-\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding,", "-\t\t\t\t\t\t\t\t\t\t\tselector,", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\tNotVisible);", "+\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t} else if (!compatibleMethod.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tfuzzyProblem = compatibleMethod;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tmethodBinding = compatibleMethod;", "+\t\t\t\t\t\t\t\t\tif (!methodBinding.canBeSeenBy(receiverType, invocationSite, classScope)) {", "+\t\t\t\t\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "+\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, NotVisible);", "+\t\t\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "70accad36931ea0990b5e3ef3a7be7b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "3d4c211d581e5ab7a648e648f6e07c2d98cd2b06", "commitAfterChange": "985d5704b5812718c29d572a9f4e88e4ef1e7e81", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\t\t\t// check on demand imports", "-\t\t\t\t\tif (importBinding.isStatic() && importBinding.onDemand) {", "+\t\t\t\t\tif (importBinding.isStatic()) {", "-\t\t\t\t\t\tif (resolvedImport instanceof ReferenceBinding) {", "+\t\t\t\t\t\tMethodBinding possible = null;", "+\t\t\t\t\t\tif (resolvedImport instanceof MethodBinding && !importBinding.onDemand) {", "+\t\t\t\t\t\t\tMethodBinding staticMethod = (MethodBinding) resolvedImport;", "-\t\t\t\t\t\t\tMethodBinding temp = findMethod((ReferenceBinding) resolvedImport, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\tif (temp != null) {", "-\t\t\t\t\t\t\t\tif (!temp.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tif (foundMethod == null)", "-\t\t\t\t\t\t\t\t\t\tfoundMethod = temp;", "-\t\t\t\t\t\t\t\t} else if (temp.isStatic()) {", "-\t\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(temp, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\t\t\tif (compatibleMethod != null) {", "-\t\t\t\t\t\t\t\t\t\tif (compatibleMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\t\t\tif (compatibleMethod.canBeSeenBy(unitScope.fPackage)) {", "-\t\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "-\t\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\t\t\t\t\t\t\tif (foundInImport)", "-\t\t\t\t\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand types.", "-\t\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, Ambiguous);", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundInImport = true;", "-\t\t\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, NotVisible);", "-\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tpossible = findMethod(staticMethod.declaringClass, staticMethod.selector, argumentTypes, invocationSite);", "+\t\t\t\t\t\t} else if (resolvedImport instanceof ReferenceBinding && importBinding.onDemand) {", "+\t\t\t\t\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "+\t\t\t\t\t\t\tpossible = findMethod((ReferenceBinding) resolvedImport, selector, argumentTypes, invocationSite);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (possible != null) {", "+\t\t\t\t\t\t\tif (!possible.isValidBinding()) {", "+\t\t\t\t\t\t\t\tif (foundMethod == null)", "+\t\t\t\t\t\t\t\t\tfoundMethod = possible; // answer as error case match", "+\t\t\t\t\t\t\t} else if (possible.isStatic()) {", "+\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(possible, argumentTypes, invocationSite);", "+\t\t\t\t\t\t\t\tif (compatibleMethod != null) {", "+\t\t\t\t\t\t\t\t\tif (compatibleMethod.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\t\tif (compatibleMethod.canBeSeenBy(unitScope.fPackage)) {", "+\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\t\t\t\t\t\t\tif (!importBinding.onDemand) // single method selector import", "+\t\t\t\t\t\t\t\t\t\t\t\treturn compatibleMethod;", "+\t\t\t\t\t\t\t\t\t\t\tif (foundInImport)", "+\t\t\t\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand types.", "+\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, Ambiguous);", "+\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t\t\tfoundInImport = true;", "+\t\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, NotVisible);", "-\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(temp, selector, argumentTypes, NotFound);", "+\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(possible, selector, argumentTypes, NotFound);"]}], "num": 47376}