{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c711257375f828b5d555cb4cce17f326", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5223d6731719673e9593d9dd32006d9c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClassFileMatchLocator.java", "commitBeforeChange": "45a50f132d1a94817dc9fe333d375cdfb8483391", "commitAfterChange": "c6f039f09be385a8260b048a357d065b24687173", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void locateMatches(MatchLocator locator, ClassFile classFile, IBinaryType info) throws CoreException", "signatureAfterChange": " public void locateMatches(MatchLocator locator, ClassFile classFile, IBinaryType info) throws CoreException", "diff": ["-\tint accuracy = SearchMatch.A_ACCURATE;", "-\tif (((InternalSearchPattern)pattern).mustResolve) {", "-\t\ttry {", "-\t\t\tBinaryTypeBinding binding = locator.cacheBinaryType(binaryType, info);", "-\t\t\tif (binding != null) {", "-\t\t\t\t// filter out element not in hierarchy scope", "-\t\t\t\tif (!locator.typeInHierarchy(binding)) return;", "+\t// Get methods from binary type info", "+\tIBinaryMethod[] binaryMethods = info.getMethods();", "+\tint bMethodsLength = binaryMethods == null ? 0 : binaryMethods.length;", "+\tIBinaryMethod[] inaccurateMethods = new IBinaryMethod[bMethodsLength];", "+\tchar[][] binaryMethodSignatures = null;", "+\tif (bMethodsLength > 0) {", "+\t\tSystem.arraycopy(binaryMethods, 0, inaccurateMethods, 0, bMethodsLength);", "+\t}", "-\t\t\t\tMethodBinding[] methods = binding.methods();", "-\t\t\t\tfor (int i = 0, l = methods.length; i < l; i++) {", "-\t\t\t\t\tMethodBinding method = methods[i];", "-\t\t\t\t\tif (locator.patternLocator.resolveLevel(method) == PatternLocator.ACCURATE_MATCH) {", "-\t\t\t\t\t\tchar[] methodSignature = method.genericSignature();", "-\t\t\t\t\t\tif (methodSignature == null) methodSignature = method.signature();", "+\t// Get fields from binary type info", "+\tIBinaryField[] binaryFields = info.getFields();", "+\tint bFieldsLength = binaryFields == null ? 0 : binaryFields.length;", "+\tIBinaryField[] inaccurateFields = new IBinaryField[bFieldsLength];", "+\tif (bFieldsLength > 0) {", "+\t\tSystem.arraycopy(binaryFields, 0, inaccurateFields, 0, bFieldsLength);", "+\t}", "+\t", "+\t// Report as many accurate matches as possible", "+\tif (((InternalSearchPattern)pattern).mustResolve) {", "+\t\tBinaryTypeBinding binding = locator.cacheBinaryType(binaryType, info);", "+\t\tif (binding != null) {", "+\t\t\t// filter out element not in hierarchy scope", "+\t\t\tif (!locator.typeInHierarchy(binding)) return;", "+", "+\t\t\t// Report accurate methods", "+\t\t\tMethodBinding[] availableMethods = binding.availableMethods();", "+\t\t\tint aMethodsLength = availableMethods == null ? 0 : availableMethods.length;", "+\t\t\tfor (int i = 0; i < aMethodsLength; i++) {", "+\t\t\t\tMethodBinding method = availableMethods[i];", "+\t\t\t\tint level = locator.patternLocator.resolveLevel(method);", "+\t\t\t\tchar[] methodSignature = method.genericSignature();", "+\t\t\t\tif (methodSignature == null) methodSignature = method.signature();", "+\t\t\t\tswitch (level) {", "+\t\t\t\t\tcase PatternLocator.ACCURATE_MATCH:", "-\t\t\t\t\t}", "+\t\t\t\t\t\t// fall through impossible match case to remove the reported method", "+\t\t\t\t\tcase PatternLocator.IMPOSSIBLE_MATCH:", "+\t\t\t\t\t\t// Store binary method signatures to avoid multiple computation", "+\t\t\t\t\t\tif (binaryMethodSignatures == null) {", "+\t\t\t\t\t\t\tbinaryMethodSignatures = new char[bMethodsLength][];", "+\t\t\t\t\t\t\tfor (int j=0; j<bMethodsLength; j++) {", "+\t\t\t\t\t\t\t\tIBinaryMethod binaryMethod = binaryMethods[j];", "+\t\t\t\t\t\t\t\tchar[] signature = binaryMethod.getGenericSignature();", "+\t\t\t\t\t\t\t\tif (signature == null) signature = binaryMethod.getMethodDescriptor();", "+\t\t\t\t\t\t\t\tbinaryMethodSignatures[j] = signature;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// The method is either accurate or impossible so remove from inaccurate methods list", "+\t\t\t\t\t\tfor (int j=0; j<bMethodsLength; j++) {", "+\t\t\t\t\t\t\tif (CharOperation.equals(binaryMethods[j].getSelector(), method.selector) && CharOperation.equals(binaryMethodSignatures[j], methodSignature)) {", "+\t\t\t\t\t\t\t\tinaccurateMethods[j] = null;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t}", "-\t\t\t\tFieldBinding[] fields = binding.fields();", "-\t\t\t\tfor (int i = 0, l = fields.length; i < l; i++) {", "-\t\t\t\t\tFieldBinding field = fields[i];", "-\t\t\t\t\tif (locator.patternLocator.resolveLevel(field) == PatternLocator.ACCURATE_MATCH) {", "+\t\t\t// Report accurate fields", "+\t\t\tFieldBinding[] availableFields = binding.availableFields();", "+\t\t\tint aFieldsLength = availableFields == null ? 0 : availableFields.length;", "+\t\t\tfor (int i = 0; i < aFieldsLength; i++) {", "+\t\t\t\tFieldBinding field = availableFields[i];", "+\t\t\t\tint level = locator.patternLocator.resolveLevel(field);", "+\t\t\t\tswitch (level) {", "+\t\t\t\t\tcase PatternLocator.ACCURATE_MATCH:", "-\t\t\t\t\t}", "+\t\t\t\t\t\t// fall through impossible match case to remove reported field", "+\t\t\t\t\tcase PatternLocator.IMPOSSIBLE_MATCH:", "+\t\t\t\t\t\t// The field is either an accurate or impossible match, so remove it from inaccurate fields list", "+\t\t\t\t\t\tfor (int j=0; j<bFieldsLength; j++) {", "+\t\t\t\t\t\t\tif ( CharOperation.equals(binaryFields[j].getName(), field.name)) {", "+\t\t\t\t\t\t\t\tinaccurateFields[j] = null;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t}", "-\t\t\t\t// no need to check binary info since resolve was successful", "+\t\t\t// If all methods/fields were accurate then returns now", "+\t\t\tif (bMethodsLength == aMethodsLength && bFieldsLength == aFieldsLength) {", "-\t\t} catch (AbortCompilation e) { // if compilation was aborted it is a problem with the class path", "-\t\t// report as a potential match if binary info matches the pattern\t\t", "-\t\taccuracy = SearchMatch.A_INACCURATE;", "-\tIBinaryMethod[] methods = info.getMethods();", "-\tif (methods != null) {", "-\t\tfor (int i = 0, l = methods.length; i < l; i++) {", "-\t\t\tIBinaryMethod method = methods[i];", "-\t\t\tif (matchBinary(pattern, method, info)) {", "-\t\t\t\tchar[] name;", "-\t\t\t\tif (method.isConstructor()) {", "-\t\t\t\t\tname = info.getName();", "-\t\t\t\t\tint lastSlash = CharOperation.lastIndexOf('/', name);", "-\t\t\t\t\tif (lastSlash != -1) {", "-\t\t\t\t\t\tname = CharOperation.subarray(name, lastSlash+1, name.length);", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tname = method.getSelector();", "+\t// Report inaccurate methods", "+\tfor (int i=0; i < bMethodsLength; i++) {", "+\t\tIBinaryMethod method = inaccurateMethods[i];", "+\t\tif (method == null) continue; // impossible match or already reported as accurate", "+\t\tif (matchBinary(pattern, method, info)) {", "+\t\t\tchar[] name;", "+\t\t\tif (method.isConstructor()) {", "+\t\t\t\tname = info.getName();", "+\t\t\t\tint lastSlash = CharOperation.lastIndexOf('/', name);", "+\t\t\t\tif (lastSlash != -1) {", "+\t\t\t\t\tname = CharOperation.subarray(name, lastSlash+1, name.length);", "-\t\t\t\tString selector = new String(name);", "-\t\t\t\tString[] parameterTypes = CharOperation.toStrings(Signature.getParameterTypes(convertClassFileFormat(method.getMethodDescriptor())));", "-\t\t\t\tIMethod methodHandle = binaryType.getMethod(selector, parameterTypes);", "-\t\t\t\tmethodHandle = new ResolvedBinaryMethod(binaryType, selector, parameterTypes, methodHandle.getKey());", "-\t\t\t\tlocator.reportBinaryMemberDeclaration(null, methodHandle, null, info, accuracy);", "+\t\t\t} else {", "+\t\t\t\tname = method.getSelector();", "+\t\t\tString selector = new String(name);", "+\t\t\tchar[] methodSignature = binaryMethodSignatures == null ? null : binaryMethodSignatures[i];", "+\t\t\tif (methodSignature == null) {", "+\t\t\t\tmethodSignature = method.getGenericSignature();", "+\t\t\t\tif (methodSignature == null) methodSignature = method.getMethodDescriptor();", "+\t\t\t}", "+\t\t\tString[] parameterTypes = CharOperation.toStrings(Signature.getParameterTypes(convertClassFileFormat(methodSignature)));", "+\t\t\tIMethod methodHandle = binaryType.getMethod(selector, parameterTypes);", "+\t\t\tmethodHandle = new ResolvedBinaryMethod(binaryType, selector, parameterTypes, methodHandle.getKey());", "+\t\t\tlocator.reportBinaryMemberDeclaration(null, methodHandle, null, info, SearchMatch.A_INACCURATE);", "-\tIBinaryField[] fields = info.getFields();", "-\tif (fields != null) {", "-\t\tfor (int i = 0, l = fields.length; i < l; i++) {", "-\t\t\tIBinaryField field = fields[i];", "-\t\t\tif (matchBinary(pattern, field, info)) {", "-\t\t\t\tString fieldName = new String(field.getName());", "-\t\t\t\tIField fieldHandle = binaryType.getField(fieldName);", "-\t\t\t\tfieldHandle = new ResolvedBinaryField(binaryType, fieldName, fieldHandle.getKey());", "-\t\t\t\tlocator.reportBinaryMemberDeclaration(null, fieldHandle, null, info, accuracy);", "-\t\t\t}", "+\t// Report inaccurate fields", "+\tfor (int i=0; i<bFieldsLength; i++) {", "+\t\tIBinaryField field = inaccurateFields[i];", "+\t\tif (field == null) continue; // impossible match or already reported as accurate", "+\t\tif (matchBinary(pattern, field, info)) {", "+\t\t\tString fieldName = new String(field.getName());", "+\t\t\tIField fieldHandle = binaryType.getField(fieldName);", "+\t\t\tfieldHandle = new ResolvedBinaryField(binaryType, fieldName, fieldHandle.getKey());", "+\t\t\tlocator.reportBinaryMemberDeclaration(null, fieldHandle, null, info, SearchMatch.A_INACCURATE);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a5ea98b7a03cf00ca29f9d0c534ed867", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClassFileMatchLocator.java", "commitBeforeChange": "630793cce0a64642fbc1993a23f5569e404d0323", "commitAfterChange": "28076bd39732aa043b533cdb44f2f309abe05417", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void locateMatches(MatchLocator locator, ClassFile classFile, IBinaryType info) throws CoreException", "signatureAfterChange": " public void locateMatches(MatchLocator locator, ClassFile classFile, IBinaryType info) throws CoreException", "diff": ["+\t\treturn;", "-\t// Get methods from binary type info", "+\t// Define arrays to store methods/fields from binary type if necessary", "-\tIBinaryMethod[] inaccurateMethods = new IBinaryMethod[bMethodsLength];", "+\tIBinaryMethod[] unresolvedMethods = null;", "-\tif (bMethodsLength > 0) {", "-\t\tSystem.arraycopy(binaryMethods, 0, inaccurateMethods, 0, bMethodsLength);", "-\t}", "+\tboolean hasUnresolvedMethods = false;", "-\tIBinaryField[] inaccurateFields = new IBinaryField[bFieldsLength];", "-\tif (bFieldsLength > 0) {", "-\t\tSystem.arraycopy(binaryFields, 0, inaccurateFields, 0, bFieldsLength);", "-\t}", "+\tIBinaryField[] unresolvedFields = null;", "+\tboolean hasUnresolvedFields = false;", "-\tif (((InternalSearchPattern)pattern).mustResolve) {", "+\tint accuracy = SearchMatch.A_ACCURATE;", "+\tboolean mustResolve = ((InternalSearchPattern)pattern).mustResolve;", "+\tif (mustResolve) {", "-\t\t\t// Report accurate methods", "+\t\t\t// Search matches on resolved methods", "+\t\t\thasUnresolvedMethods = bMethodsLength != aMethodsLength;", "-\t\t\t\tint level = locator.patternLocator.resolveLevel(method);", "-\t\t\t\tswitch (level) {", "-\t\t\t\t\tcase PatternLocator.ACCURATE_MATCH:", "-\t\t\t\t\t\tIMethod methodHandle = binaryType.getMethod(", "-\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),", "-\t\t\t\t\t\t\tCharOperation.toStrings(Signature.getParameterTypes(convertClassFileFormat(methodSignature))));", "-\t\t\t\t\t\tlocator.reportBinaryMemberDeclaration(null, methodHandle, method, info, SearchMatch.A_ACCURATE);", "-\t\t\t\t\t\t// fall through impossible match case to remove the reported method", "-\t\t\t\t\tcase PatternLocator.IMPOSSIBLE_MATCH:", "-\t\t\t\t\t\t// Store binary method signatures to avoid multiple computation", "-\t\t\t\t\t\tif (binaryMethodSignatures == null) {", "-\t\t\t\t\t\t\tbinaryMethodSignatures = new char[bMethodsLength][];", "-\t\t\t\t\t\t\tfor (int j=0; j<bMethodsLength; j++) {", "-\t\t\t\t\t\t\t\tIBinaryMethod binaryMethod = binaryMethods[j];", "-\t\t\t\t\t\t\t\tchar[] signature = binaryMethod.getGenericSignature();", "-\t\t\t\t\t\t\t\tif (signature == null) signature = binaryMethod.getMethodDescriptor();", "-\t\t\t\t\t\t\t\tbinaryMethodSignatures[j] = signature;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// The method is either accurate or impossible so remove from inaccurate methods list", "+", "+\t\t\t\t// Report the match if possible", "+\t\t\t\tint level = locator.patternLocator.resolveLevel(method);", "+\t\t\t\tif (level != PatternLocator.IMPOSSIBLE_MATCH) {", "+\t\t\t\t\tIMethod methodHandle = binaryType.getMethod(", "+\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),", "+\t\t\t\t\t\tCharOperation.toStrings(Signature.getParameterTypes(convertClassFileFormat(methodSignature))));", "+\t\t\t\t\taccuracy = level == PatternLocator.ACCURATE_MATCH ? SearchMatch.A_ACCURATE : SearchMatch.A_INACCURATE;", "+\t\t\t\t\tlocator.reportBinaryMemberDeclaration(null, methodHandle, method, info, accuracy);", "+\t\t\t\t}", "+", "+\t\t\t\t// Remove method from unresolved list", "+\t\t\t\tif (hasUnresolvedMethods) {", "+\t\t\t\t\tif (binaryMethodSignatures == null) { // Store binary method signatures to avoid multiple computation", "+\t\t\t\t\t\tbinaryMethodSignatures = new char[bMethodsLength][];", "-\t\t\t\t\t\t\tif (CharOperation.equals(binaryMethods[j].getSelector(), method.selector) && CharOperation.equals(binaryMethodSignatures[j], methodSignature)) {", "-\t\t\t\t\t\t\t\tinaccurateMethods[j] = null;", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tIBinaryMethod binaryMethod = binaryMethods[j];", "+\t\t\t\t\t\t\tchar[] signature = binaryMethod.getGenericSignature();", "+\t\t\t\t\t\t\tif (signature == null) signature = binaryMethod.getMethodDescriptor();", "+\t\t\t\t\t\t\tbinaryMethodSignatures[j] = signature;", "-\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tfor (int j=0; j<bMethodsLength; j++) {", "+\t\t\t\t\t\tif (CharOperation.equals(binaryMethods[j].getSelector(), method.selector) && CharOperation.equals(binaryMethodSignatures[j], methodSignature)) {", "+\t\t\t\t\t\t\tif (unresolvedMethods == null) {", "+\t\t\t\t\t\t\t\tSystem.arraycopy(binaryMethods, 0, unresolvedMethods = new IBinaryMethod[bMethodsLength], 0, bMethodsLength);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tunresolvedMethods[j] = null;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t// Report accurate fields", "+\t\t\t// Search matches on resolved fields", "+\t\t\thasUnresolvedFields = bFieldsLength != aFieldsLength;", "+", "+\t\t\t\t// Report the match if possible", "-\t\t\t\tswitch (level) {", "-\t\t\t\t\tcase PatternLocator.ACCURATE_MATCH:", "-\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));", "-\t\t\t\t\t\tlocator.reportBinaryMemberDeclaration(null, fieldHandle, field, info, SearchMatch.A_ACCURATE);", "-\t\t\t\t\t\t// fall through impossible match case to remove reported field", "-\t\t\t\t\tcase PatternLocator.IMPOSSIBLE_MATCH:", "-\t\t\t\t\t\t// The field is either an accurate or impossible match, so remove it from inaccurate fields list", "-\t\t\t\t\t\tfor (int j=0; j<bFieldsLength; j++) {", "-\t\t\t\t\t\t\tif ( CharOperation.equals(binaryFields[j].getName(), field.name)) {", "-\t\t\t\t\t\t\t\tinaccurateFields[j] = null;", "-\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\tif (level != PatternLocator.IMPOSSIBLE_MATCH) {", "+\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));", "+\t\t\t\t\taccuracy = level == PatternLocator.ACCURATE_MATCH ? SearchMatch.A_ACCURATE : SearchMatch.A_INACCURATE;", "+\t\t\t\t\tlocator.reportBinaryMemberDeclaration(null, fieldHandle, field, info, accuracy);", "+\t\t\t\t}", "+", "+\t\t\t\t// Remove the field from unresolved list", "+\t\t\t\tif (hasUnresolvedFields) {", "+\t\t\t\t\tfor (int j=0; j<bFieldsLength; j++) {", "+\t\t\t\t\t\tif ( CharOperation.equals(binaryFields[j].getName(), field.name)) {", "+\t\t\t\t\t\t\tif (unresolvedFields == null) {", "+\t\t\t\t\t\t\t\tSystem.arraycopy(binaryFields, 0, unresolvedFields = new IBinaryField[bFieldsLength], 0, bFieldsLength);", "+\t\t\t\t\t\t\tunresolvedFields[j] = null;", "+\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "-\t\t\tif (bMethodsLength == aMethodsLength && bFieldsLength == aFieldsLength) {", "+\t\t\tif (!hasUnresolvedMethods && !hasUnresolvedFields) {", "+\t\taccuracy = SearchMatch.A_INACCURATE;", "+\tif (mustResolve) binaryMethods = unresolvedMethods;", "+\tbMethodsLength = binaryMethods == null ? 0 : binaryMethods.length;", "-\t\tIBinaryMethod method = inaccurateMethods[i];", "+\t\tIBinaryMethod method = binaryMethods[i];", "-\t\t\tlocator.reportBinaryMemberDeclaration(null, methodHandle, null, info, SearchMatch.A_INACCURATE);", "+\t\t\tlocator.reportBinaryMemberDeclaration(null, methodHandle, null, info, accuracy);", "+\tif (mustResolve) binaryFields =  unresolvedFields;", "+\tbFieldsLength = binaryFields == null ? 0 : binaryFields.length;", "-\t\tIBinaryField field = inaccurateFields[i];", "+\t\tIBinaryField field = binaryFields[i];", "-\t\t\tlocator.reportBinaryMemberDeclaration(null, fieldHandle, null, info, SearchMatch.A_INACCURATE);", "+\t\t\tlocator.reportBinaryMemberDeclaration(null, fieldHandle, null, info, accuracy);"]}], "num": 2553}