{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fc674265e04af06844b5ebf3e2bb3679", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4ab62b310adf9374f723a4842d77c1d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java", "commitBeforeChange": "56484abf3afec06a3b2fe9a53e3d4859e1a90d5d", "commitAfterChange": "c98606727e89fdf50e483c7870bb4651b90d6014", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tboolean incorporate(InferenceContext18 context) throws InferenceFailureException", "signatureAfterChange": " \tboolean incorporate(InferenceContext18 context) throws InferenceFailureException", "diff": ["-\t\tboolean hasUpdate;", "+\t\tif (this.isIncorporated)", "+\t\t\treturn true;", "+\t\tboolean analyzeNull = context.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled;", "-\t\t\thasUpdate = false;", "+\t\t\tthis.isIncorporated = true;", "+\t\t\t\tfinal boolean setHasI = boundI.id < this.incorporatedBounds.length && this.incorporatedBounds[boundI.id] == true;", "-\t\t\t\t\tif (this.incorporatedBounds.contains(boundI) && this.incorporatedBounds.contains(boundJ))", "+\t\t\t\t\tif (setHasI && boundJ.id < this.incorporatedBounds.length && this.incorporatedBounds[boundJ.id] == true)", "+\t\t\t\t\tboolean deriveTypeArgumentConstraints = false;", "+\t\t\t\t\t\t\t\t\tderiveTypeArgumentConstraints = TypeBinding.equalsEquals(boundI.left, boundJ.left);", "-\t\t\t\t\t\t// TODO here and below: better checking if constraint really added to the boundset (optimization)?", "-\t\t\t\t\t\thasUpdate = true;", "-\t\t\t\t\t\t// not per JLS: if the new constraint relates types where at least one has a null annotations,", "-\t\t\t\t\t\t// record all null tagBits as hints for the final inference solution.", "-\t\t\t\t\t\tlong nullHints = (newConstraint.left.tagBits | newConstraint.right.tagBits) & TagBits.AnnotationNullMASK;", "-\t\t\t\t\t\tboundI.nullHints |= nullHints;", "-\t\t\t\t\t\tboundJ.nullHints |= nullHints;", "+\t\t\t\t\t\tif (analyzeNull) {", "+\t\t\t\t\t\t\t// not per JLS: if the new constraint relates types where at least one has a null annotations,", "+\t\t\t\t\t\t\t// record all null tagBits as hints for the final inference solution.", "+\t\t\t\t\t\t\tlong nullHints = (newConstraint.left.tagBits | newConstraint.right.tagBits) & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\tboundI.nullHints |= nullHints;", "+\t\t\t\t\t\t\tboundJ.nullHints |= nullHints;", "+\t\t\t\t\t\t}", "-\t\t\t\t\tConstraintFormula[] typeArgumentConstraints = deriveTypeArgumentConstraints(boundI, boundJ);", "+\t\t\t\t\tConstraintFormula[] typeArgumentConstraints = deriveTypeArgumentConstraints ? deriveTypeArgumentConstraints(boundI, boundJ) : null;", "-\t\t\t\t\t\tfor (int k = 0; k < typeArgumentConstraints.length; k++) {", "+\t\t\t\t\t\tfor (int k = 0, length = typeArgumentConstraints.length; k < length; k++) {", "-\t\t\t\t\t\t\thasUpdate = true;", "-\t\t\t\tthis.incorporatedBounds.add(boundI);", "+\t\t\t\tif (!setHasI) {", "+\t\t\t\t\tint length = this.incorporatedBounds.length;", "+\t\t\t\t\tif (boundI.id >= length)", "+\t\t\t\t\t\tSystem.arraycopy(this.incorporatedBounds, 0, this.incorporatedBounds = new boolean[boundI.id * 2], 0, length);", "+\t\t\t\t\tthis.incorporatedBounds[boundI.id] = true;", "+\t\t\t\t}", "-\t\t\t\thasUpdate = true;", "-\t\t\t\tfor (int i = 0; i < parameters.length; i++) {", "+\t\t\t\tfor (int i = 0, length = parameters.length; i < length; i++) {", "-\t\t} while (hasUpdate);", "+\t\t} while (!this.isIncorporated);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9a0539def1524d645429fd877f4d3c24", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java", "commitBeforeChange": "7ba9ff29fe6b05ec0a2f58eaa1f5d3e68bb11101", "commitAfterChange": "427a01e331e57852efc472cca3a8360bd121fda9", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 52, "signatureBeforeChange": "  protected void resolveAnnotations(Scope scope)", "signatureAfterChange": "  protected void resolveAnnotations(Scope scope)", "diff": ["+\t\t\tlong tagBits = 0;", "-\t\t\tboolean shouldAnalyzeArrayNullAnnotations = scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled && this instanceof ArrayTypeReference;", "+\t\t\tboolean evalNullAnnotations = scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled;", "+\t\t\tboolean isArrayReference = this instanceof ArrayTypeReference && dimensions > 0;", "-\t\t\t\t\t\tif (shouldAnalyzeArrayNullAnnotations) {", "+\t\t\t\t\t\tif (evalNullAnnotations) {", "-\t\t\t\t\t\t\t\t\tif (tagBitsPerDimension == null)", "-\t\t\t\t\t\t\t\t\t\ttagBitsPerDimension = new long[dimensions+1]; // each dimension plus leaf component type at last position", "-\t\t\t\t\t\t\t\t\t// @NonNull Foo [][][] means the leaf component type is @NonNull:", "-\t\t\t\t\t\t\t\t\ttagBitsPerDimension[dimensions] = ((Annotation.TypeUseBinding)recipient).tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\t\tif (isArrayReference) {", "+\t\t\t\t\t\t\t\t\t\tif (tagBitsPerDimension == null)", "+\t\t\t\t\t\t\t\t\t\t\ttagBitsPerDimension = new long[dimensions+1]; // each dimension plus leaf component type at last position", "+\t\t\t\t\t\t\t\t\t\t// @NonNull Foo [][][] means the leaf component type is @NonNull:", "+\t\t\t\t\t\t\t\t\t\ttagBitsPerDimension[dimensions] = ((Annotation.TypeUseBinding)recipient).tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\ttagBits |= ((Annotation.TypeUseBinding)recipient).tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (shouldAnalyzeArrayNullAnnotations) {", "+\t\t\t\t\t\tif (evalNullAnnotations && isArrayReference) {", "-\t\t\tif (tagBitsPerDimension != null && this.resolvedType.isValidBinding()) {", "-\t\t\t\t// TODO(stephan): wouldn't it be more efficient to store the array bindings inside the type binding rather than the environment?", "-\t\t\t\t// cf. LocalTypeBinding.createArrayType()", "-\t\t\t\tthis.resolvedType = scope.environment().createArrayType(this.resolvedType.leafComponentType(), dimensions, tagBitsPerDimension);", "+\t\t\tif (this.resolvedType != null && this.resolvedType.isValidBinding()) {", "+\t\t\t\tif (isArrayReference) {", "+\t\t\t\t\tif (tagBitsPerDimension != null) {", "+\t\t\t\t\t\t// TODO(stephan): wouldn't it be more efficient to store the array bindings inside the type binding rather than the environment?", "+\t\t\t\t\t\t// cf. LocalTypeBinding.createArrayType()", "+\t\t\t\t\t\tthis.resolvedType = scope.environment().createArrayType(this.resolvedType.leafComponentType(), dimensions, tagBitsPerDimension);", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tif (tagBits != 0) {", "+\t\t\t\t\t\tif (this.resolvedType instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\tthis.resolvedType = scope.environment().createAnnotatedType((ReferenceBinding) this.resolvedType, tagBits);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// TODO(stephan) report null annotation on non-reference type", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}"]}], "num": 28031}