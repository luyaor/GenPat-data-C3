{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1e5d31e352add7e29ada024fe07d9a36", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a766ab6d18d281a5422ff03d1ecc6cb4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java", "commitBeforeChange": "1bd28947ec61a68bcbaa48e5f62a38f1082dad74", "commitAfterChange": "158f15ed7305b84f608a44b2b3e60c3a50fa4c1b", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprivate static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus, boolean overrideDetailChecking)", "signatureAfterChange": " \tprivate static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus, CheckMode mode, boolean requiredIsTypeVariable)", "diff": ["-\tprivate static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus, boolean overrideDetailChecking) {", "-\t\t// nullStatus: ", "-\t\t// overrideDetailChecking: ", "-\t\tif ((requiredBits != 0 || overrideDetailChecking) && requiredBits != providedBits) {", "-\t\t\tif (requiredBits == TagBits.AnnotationNonNull && nullStatus == FlowInfo.NON_NULL) {", "-\t\t\t\treturn 0; // OK by flow analysis", "+\tprivate static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus, CheckMode mode, boolean requiredIsTypeVariable) {", "+\t\tif (requiredBits == providedBits)", "+\t\t\treturn 0;", "+\t\tif (requiredBits == 0) { ", "+\t\t\tswitch (mode) {", "+\t\t\t\tcase COMPATIBLE:", "+\t\t\t\tcase BOUND_CHECK:", "+\t\t\t\tcase EXACT:", "+\t\t\t\t\treturn 0;", "+\t\t\t\tcase OVERRIDE_RETURN:", "+\t\t\t\t\tif (providedBits == TagBits.AnnotationNonNull)", "+\t\t\t\t\t\treturn 0; // covariant redefinition to nonnull is good", "+\t\t\t\t\tif (!requiredIsTypeVariable)", "+\t\t\t\t\t\treturn 0; // refining an unconstrained non-TVB return to nullable is also legal", "+\t\t\t\t\treturn 1;", "+\t\t\t\tcase OVERRIDE:", "+\t\t\t\t\treturn 1; // warn about dropped annotation", "-\t\t\tif (requiredBits == TagBits.AnnotationNullMASK)", "-\t\t\t\treturn 0; // OK since LHS accepts either", "-\t\t\tif (nullStatus != -1 && !overrideDetailChecking && requiredBits == TagBits.AnnotationNullable)", "-\t\t\t\treturn 0; // when using flow info, everything is compatible to nullable", "-\t\t\tif (providedBits != 0) {", "-\t\t\t\treturn 2; // mismatching annotations", "-\t\t\t} else {", "-\t\t\t\treturn 1; // need unchecked conversion regarding type detail", "+\t\t} else if (requiredBits == TagBits.AnnotationNullMASK) {", "+\t\t\treturn 0; // OK since LHS accepts either", "+\t\t} else if (requiredBits == TagBits.AnnotationNonNull) {", "+\t\t\tswitch (mode) {", "+\t\t\t\tcase COMPATIBLE:", "+\t\t\t\t\tif (nullStatus == FlowInfo.NON_NULL)", "+\t\t\t\t\t\treturn 0; // OK by flow analysis", "+\t\t\t\t\t//$FALL-THROUGH$", "+\t\t\t\tcase BOUND_CHECK:", "+\t\t\t\tcase EXACT:", "+\t\t\t\tcase OVERRIDE_RETURN:", "+\t\t\t\tcase OVERRIDE:", "+\t\t\t\t\tif (providedBits == 0)", "+\t\t\t\t\t\treturn 1;", "+\t\t\t\t\treturn 2;", "+\t\t\t}", "+\t\t\t", "+\t\t} else if (requiredBits == TagBits.AnnotationNullable) {", "+\t\t\tswitch (mode) {", "+\t\t\t\tcase COMPATIBLE:", "+\t\t\t\tcase OVERRIDE_RETURN:", "+\t\t\t\t\treturn 0; // in these modes everything is compatible to nullable", "+\t\t\t\tcase BOUND_CHECK:", "+\t\t\t\tcase EXACT:", "+\t\t\t\t\tif (providedBits == 0)", "+\t\t\t\t\t\treturn 1;", "+\t\t\t\t\treturn 2;", "+\t\t\t\tcase OVERRIDE:", "+\t\t\t\t\treturn 2;", "-\t\treturn 0; // OK by tagBits", "+\t\treturn 0; // shouldn't get here, requiredBits should be one of the listed cases"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f6d26cd7cfd27650ee616b661b18a6a8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/newbuilder/ReferenceCollection.java", "commitBeforeChange": "d5488a3ba93291ed8339edaad64e7cedc13fb558", "commitAfterChange": "8635a189d924741fc24bc4be873c4d30df46a524", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \r static char[][] internSimpleNames(char[][] simpleNames, boolean removeWellKnown)", "signatureAfterChange": "\r \r static char[][] internSimpleNames(char[][] simpleNames, boolean removeWellKnown)", "diff": ["-\t\t\tif (sLength == wellKnownName.length && CharOperation.equals(name, wellKnownName)) {\r", "+\t\t\tif (CharOperation.equals(name, wellKnownName)) {\r", "-\t\tfor (int j = 0, k = InternedSimpleNames.size(); j < k; j++) {\r", "-\t\t\tchar[] internedName = (char[]) InternedSimpleNames.get(j);\r", "-\t\t\tif (sLength == internedName.length && CharOperation.equals(name, internedName)) {\r", "+\r", "+\t\tArrayList internedNames = null;\r", "+\t\tswitch (sLength) {\r", "+\t\t\tcase 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 :\r", "+\t\t\t\tinternedNames = InternedSimpleNames[0];\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase 8 : case 9 : case 10 : case 11 :\r", "+\t\t\t\tinternedNames = InternedSimpleNames[1];\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase 12 : case 13 : case 14 : case 15 :\r", "+\t\t\t\tinternedNames = InternedSimpleNames[2];\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase 16 : case 17 : case 18 : case 19 :\r", "+\t\t\t\tinternedNames = InternedSimpleNames[3];\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase 20 : case 21 : case 22 : case 23 : case 24 :\r", "+\t\t\t\tinternedNames = InternedSimpleNames[4];\r", "+\t\t\t\tbreak;\r", "+\t\t\tdefault :\r", "+\t\t\t\tinternedNames = InternedSimpleNames[5];\r", "+\t\t\t\tbreak;\r", "+\t\t}\r", "+\t\tfor (int j = 0, k = internedNames.size(); j < k; j++) {\r", "+\t\t\tchar[] internedName = (char[]) internedNames.get(j);\r", "+\t\t\tif (CharOperation.equals(name, internedName)) {\r", "-\t\tInternedSimpleNames.add(name);\r", "+\t\tinternedNames.add(name);\r"]}], "num": 24943}