{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c49aec21725f0e8527eea973e1a8d83a", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7beb92d008bd7e3ac5884dae5bcd67e8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "8e2ef31cf8fd6f75aa20407e8ef5b91a95949af6", "commitAfterChange": "7b76bd109981132b10232dab12b61206fb5d8435", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tprivate synchronized boolean checkIntegrity() throws IllegalStateException", "signatureAfterChange": " \tprivate synchronized boolean checkIntegrity() throws IllegalStateException", "diff": ["-\t\tif (ENABLE_INTEGRITY_CHECKS) {", "-\t\t\t// Every working copy in the working copy dependency map should be", "-\t\t\t// in the", "-\t\t\t// _workingCopies list and should not be in the _hiddenBuiltTypes", "-\t\t\t// list.", "-\t\t\tfor (ICompilationUnit wc : _parentToGenWorkingCopies.getValueSet()) {", "-\t\t\t\tif (!_workingCopies.containsValue(wc)) {", "-\t\t\t\t\tString s = \"Dependency map contains a working copy that is not in the regular list: \" + //$NON-NLS-1$", "-\t\t\t\t\t\t\twc.getElementName();", "-\t\t\t\t\tAptPlugin.log(new IllegalStateException(s), s);", "-\t\t\t\t}", "-\t\t\t\tif (_hiddenBuiltTypes.containsValue(wc)) {", "-\t\t\t\t\tString s = \"Dependency map contains a working copy that is on the hidden list: \" + //$NON-NLS-1$", "-\t\t\t\t\t\t\twc.getElementName();", "-\t\t\t\t\tAptPlugin.log(new IllegalStateException(s), s);", "-\t\t\t\t}", "+\t\tif (!ENABLE_INTEGRITY_CHECKS) {", "+\t\t\treturn true;", "+\t\t}", "+\t\t", "+\t\t// There is a 1:1 correspondence between values in _reconcileDeps and", "+\t\t// keys in _reconcileGenTypes.", "+\t\tSet<IFile> depChildren = _reconcileDeps.getValueSet(); // copy - safe to modify", "+\t\tSet<IFile> genTypes = _reconcileGenTypes.keySet(); // not a copy!", "+\t\tList<IFile> extraFiles = new ArrayList<IFile>(); ", "+\t\tfor (IFile f : genTypes) {", "+\t\t\tif (!depChildren.remove(f)) {", "+\t\t\t\textraFiles.add(f);", "-\t\t\t// Every entry in the hidden type list should be a working copy", "-\t\t\tfor (ICompilationUnit hidden : _hiddenBuiltTypes.values()) {", "-\t\t\t\tif (!hidden.isWorkingCopy()) {", "-\t\t\t\t\tString s = \"Hidden list contains a compilation unit that is not a working copy: \" + //$NON-NLS-1$", "-\t\t\t\t\t\t\thidden.getElementName();", "-\t\t\t\t\tAptPlugin.log(new IllegalStateException(s), s);", "+\t\t}", "+\t\tif (!extraFiles.isEmpty()) {", "+\t\t\tlogExtraFiles(\"File(s) in reconcile-generated list but not in reconcile dependency map: \", //$NON-NLS-1$", "+\t\t\t\t\textraFiles);", "+\t\t}", "+\t\tif (!depChildren.isEmpty()) {", "+\t\t\tlogExtraFiles(\"File(s) in reconcile dependency map but not in reconcile-generated list: \", //$NON-NLS-1$", "+\t\t\t\t\tdepChildren);", "+\t\t}", "+\t\t", "+\t\t// Every key in _hiddenBuiltTypes must be a value in _reconcileNonDeps.", "+\t\tList<IFile> extraHiddenTypes = new ArrayList<IFile>();", "+\t\tfor (IFile hidden : _hiddenBuiltTypes.keySet()) {", "+\t\t\tif (!_reconcileNonDeps.containsValue(hidden)) {", "+\t\t\t\textraHiddenTypes.add(hidden);", "+\t\t\t}", "+\t\t}", "+\t\tif (!extraHiddenTypes.isEmpty()) {", "+\t\t\tlogExtraFiles(\"File(s) in hidden types list but not in reconcile-obsoleted list: \", //$NON-NLS-1$", "+\t\t\t\t\textraHiddenTypes);", "+\t\t}", "+\t\t", "+\t\t// There can be no parent/child pairs that exist in both _reconcileDeps", "+\t\t// and _reconcileNonDeps.", "+\t\tMap<IFile, IFile> reconcileOverlaps = new HashMap<IFile, IFile>();", "+\t\tfor (IFile parent : _reconcileNonDeps.getKeySet()) {", "+\t\t\tfor (IFile child : _reconcileNonDeps.getValues(parent)) {", "+\t\t\t\tif (_reconcileDeps.containsKeyValuePair(parent, child)) {", "+\t\t\t\t\treconcileOverlaps.put(parent, child);", "+\t\tif (!reconcileOverlaps.isEmpty()) {", "+\t\t\tlogExtraFilePairs(\"Entries exist in both reconcile map and reconcile-obsoleted maps: \",  //$NON-NLS-1$", "+\t\t\t\t\treconcileOverlaps);", "+\t\t}", "+\t\t", "+\t\t// Every parent/child pair in _reconcileNonDeps must have a matching", "+\t\t// parent/child pair in _buildDeps.", "+\t\tMap<IFile, IFile> extraNonDeps = new HashMap<IFile, IFile>();", "+\t\tfor (IFile parent : _reconcileNonDeps.getKeySet()) {", "+\t\t\tfor (IFile child : _reconcileNonDeps.getValues(parent)) {", "+\t\t\t\tif (!_buildDeps.containsKeyValuePair(parent, child)) {", "+\t\t\t\t\textraNonDeps.put(parent, child);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (!extraNonDeps.isEmpty()) {", "+\t\t\tlogExtraFilePairs(\"Entries exist in reconcile-obsoleted map but not in build map: \", //$NON-NLS-1$", "+\t\t\t\t\textraNonDeps);", "+\t\t}", "+\t\t", "+\t\t// Values in _hiddenBuiltTypes must not be null", "+\t\tList<IFile> nullHiddenTypes = new ArrayList<IFile>();", "+\t\tfor (Map.Entry<IFile, ICompilationUnit> entry : _hiddenBuiltTypes.entrySet()) {", "+\t\t\tif (entry.getValue() == null) {", "+\t\t\t\tnullHiddenTypes.add(entry.getKey());", "+\t\t\t}", "+\t\t}", "+\t\tif (!nullHiddenTypes.isEmpty()) {", "+\t\t\tlogExtraFiles(\"Null entries in hidden type list: \", nullHiddenTypes); //$NON-NLS-1$", "+\t\t}", "+\t\t", "+\t\t// Values in _reconcileGenTypes must not be null", "+\t\tList<IFile> nullReconcileTypes = new ArrayList<IFile>();", "+\t\tfor (Map.Entry<IFile, ICompilationUnit> entry : _reconcileGenTypes.entrySet()) {", "+\t\t\tif (entry.getValue() == null) {", "+\t\t\t\tnullReconcileTypes.add(entry.getKey());", "+\t\t\t}", "+\t\t}", "+\t\tif (!nullReconcileTypes.isEmpty()) {", "+\t\t\tlogExtraFiles(\"Null entries in reconcile type list: \", nullReconcileTypes); //$NON-NLS-1$", "+\t\t}", "+\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a372e3adb1190428e622c050766aa3fd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexAllProject.java", "commitBeforeChange": "2acf337b771d06ad716c2ae54bdb8443b5b5d1d6", "commitAfterChange": "28f793f875e5d5b5aa1f2b69f1f41ea8e36715ac", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "signatureAfterChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "diff": ["-\t\t", "-\t\tif (progressMonitor != null && progressMonitor.isCanceled()) return COMPLETE;", "-\t\tif (!project.isOpen())", "-\t\t\treturn COMPLETE; // nothing to do", "+\t\tif (progressMonitor != null && progressMonitor.isCanceled()) return true;", "+\t\tif (!project.isAccessible()) return true; // nothing to do", "-\t\tIIndex index = manager.getIndex(project.getFullPath(), true /*reuse index file*/, true /*create if none*/);", "-\t\tif (index == null)", "-\t\t\treturn COMPLETE;", "-\t\tReadWriteMonitor monitor = manager.getMonitorFor(index);", "-\t\tif (monitor == null)", "-\t\t\treturn COMPLETE; // index got deleted since acquired", "+\t\tIPath projectPath = this.project.getFullPath();", "+\t\tIIndex index = this.manager.getIndex(projectPath, true, /*reuse index file*/ true /*create if none*/);", "+\t\tif (index == null) return true;", "+\t\tReadWriteMonitor monitor = this.manager.getMonitorFor(index);", "+\t\tif (monitor == null) return true; // index got deleted since acquired", "+", "+\t\t\tsaveIfNecessary(index, monitor);", "-\t\t\t/* if index has changed, commit these before querying */", "-\t\t\tif (index.hasChanged()) {", "-\t\t\t\ttry {", "-\t\t\t\t\tmonitor.exitRead(); // free read lock", "-\t\t\t\t\tmonitor.enterWrite(); // ask permission to write", "-\t\t\t\t\tif (IndexManager.VERBOSE)", "-\t\t\t\t\t\tJobManager.verbose(\"-> merging index \" + index.getIndexFile()); //$NON-NLS-1$", "-\t\t\t\t\tindex.save();", "-\t\t\t\t} catch (IOException e) {", "-\t\t\t\t\treturn FAILED;", "-\t\t\t\t} finally {", "-\t\t\t\t\tmonitor.exitWriteEnterRead(); // finished writing and reacquire read permission", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tthis.indexLastModified = index.getIndexFile().lastModified();", "-", "-\t\t\tthis.indexedFileNames = new Hashtable(100);", "-\t\t\tfor (int i = 0, max = results == null ? 0 : results.length; i < max; i++) {", "-\t\t\t\tString fileName = results[i].getPath();", "-\t\t\t\tthis.indexedFileNames.put(fileName, DELETED);", "-\t\t\t}", "-\t\t\tIJavaProject javaProject = JavaCore.create(this.project);", "-\t\t\tIClasspathEntry[] entries = javaProject.getRawClasspath(); //only interested in source folders", "+\t\t\tint max = results == null ? 0 : results.length;", "+\t\t\tfinal Hashtable indexedFileNames = new Hashtable(100);", "+\t\t\tfinal String OK = \"OK\"; //$NON-NLS-1$", "+\t\t\tfinal String DELETED = \"DELETED\"; //$NON-NLS-1$", "+\t\t\tfor (int i = 0; i < max; i++)", "+\t\t\t\tindexedFileNames.put(results[i].getPath(), DELETED);", "+\t\t\tfinal long indexLastModified = max == 0 ? 0L : index.getIndexFile().lastModified();", "+", "+\t\t\tIClasspathEntry[] entries = JavaCore.create(this.project).getRawClasspath();", "-\t\t\t\tif (this.isCancelled) return FAILED;", "-\t\t\t\t", "+\t\t\t\tif (this.isCancelled) return false;", "+", "-\t\t\t\t// Index only the project's source folders.", "-\t\t\t\t// Indexing of libraries is done in a separate job", "-\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_SOURCE)) {", "-\t\t\t\t\tIPath entryPath = entry.getPath();", "-\t\t\t\t\tIResource sourceFolder = root.findMember(entryPath);", "+\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_SOURCE)) { // Index only source folders. Libraries are done as a separate job", "+\t\t\t\t\tIResource sourceFolder = root.findMember(entry.getPath());", "-\t\t\t\t\t\tthis.currentExclusionPatterns = ((ClasspathEntry)entry).fullExclusionPatternChars();", "-\t\t\t\t\t\tsourceFolder.accept(this);", "+\t\t\t\t\t\tfinal char[][] patterns = ((ClasspathEntry) entry).fullExclusionPatternChars();", "+\t\t\t\t\t\tif (max == 0) {", "+\t\t\t\t\t\t\tsourceFolder.accept(new IResourceVisitor() {", "+\t\t\t\t\t\t\t\tpublic boolean visit(IResource resource) {", "+\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "+\t\t\t\t\t\t\t\t\tif (resource.getType() == IResource.FILE) {", "+\t\t\t\t\t\t\t\t\t\tif (Util.isJavaFileName(resource.getName()) && resource.getLocation() != null) {", "+\t\t\t\t\t\t\t\t\t\t\tif (patterns == null || !Util.isExcluded(resource, patterns)) {", "+\t\t\t\t\t\t\t\t\t\t\t\tString name = new IFileDocument((IFile) resource).getName();", "+\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(name, resource);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t});", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tsourceFolder.accept(new IResourceVisitor() {", "+\t\t\t\t\t\t\t\tpublic boolean visit(IResource resource) {", "+\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "+\t\t\t\t\t\t\t\t\tif (resource.getType() == IResource.FILE) {", "+\t\t\t\t\t\t\t\t\t\tif (Util.isJavaFileName(resource.getName())) {", "+\t\t\t\t\t\t\t\t\t\t\tIPath path = resource.getLocation();", "+\t\t\t\t\t\t\t\t\t\t\tif (path != null && (patterns == null || !Util.isExcluded(resource, patterns))) {", "+\t\t\t\t\t\t\t\t\t\t\t\tString name = new IFileDocument((IFile) resource).getName();", "+\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(name,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.get(name) == null || indexLastModified < path.toFile().lastModified()", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t? (Object) resource", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t: (Object) OK);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t});", "+\t\t\t\t\t\t}", "-\t\t\t", "-\t\t\tIPath projectPath = this.project.getFullPath();", "+", "+\t\t\tboolean shouldSave = false;", "-\t\t\t\tif (this.isCancelled) return FAILED;", "+\t\t\t\tif (this.isCancelled) return false;", "-\t\t\t\tif (value instanceof IFile) {", "-\t\t\t\t\tmanager.addSource((IFile) value, projectPath);", "-\t\t\t\t} else if (value == DELETED) {", "-\t\t\t\t\tmanager.remove(name, projectPath);", "+\t\t\t\tif (value != OK) {", "+\t\t\t\t\tshouldSave = true;", "+\t\t\t\t\tif (value == DELETED)", "+\t\t\t\t\t\tthis.manager.remove(name, projectPath);", "+\t\t\t\t\telse", "+\t\t\t\t\t\tthis.manager.addSource((IFile) value, projectPath);", "-\t\t\tmanager.request(new SaveIndex(projectPath, manager));", "+\t\t\tif (shouldSave)", "+\t\t\t\tthis.manager.request(new SaveIndex(projectPath, manager));", "-\t\t\tmanager.removeIndex(project.getFullPath());", "-\t\t\treturn FAILED;", "+\t\t\tthis.manager.removeIndex(projectPath);", "+\t\t\treturn false;", "-\t\t\tmanager.removeIndex(project.getFullPath());", "-\t\t\treturn FAILED;", "+\t\t\tthis.manager.removeIndex(projectPath);", "+\t\t\treturn false;", "-\t\treturn COMPLETE;", "-\t}"]}], "num": 46897}