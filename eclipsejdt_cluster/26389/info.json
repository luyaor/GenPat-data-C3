{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4e37b77e995ad931ef4cdb0f888118a5", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2ff328bf4004e4165eb3e442129fbb56", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "49221e1dedf80843e710093d67caabba63367062", "commitAfterChange": "26bd6002dbcadf28eb844a4d87a4d9f705c01741", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " \t \tprivate boolean complete(ASTNode astNode, ASTNode astNodeParent, Binding qualifiedBinding, Scope scope, boolean insideTypeAnnotation)", "signatureAfterChange": " \t \tprivate boolean complete(ASTNode astNode, ASTNode astNodeParent, Binding qualifiedBinding, Scope scope, boolean insideTypeAnnotation)", "diff": ["+\t\t\tCompletionOnAnnotationOfType fakeType = (CompletionOnAnnotationOfType)scope.parent.referenceContext();", "+\t\t\tif (fakeType.annotations[0] == annot) {", "+\t\t\t\t// When the completion is inside a method body the annotation cannot be accuratly attached to the correct node by completion recovery.", "+\t\t\t\t// So 'targetedElement' is not computed in this case.", "+\t\t\t\tif (scope.parent.parent == null || !(scope.parent.parent instanceof MethodScope)) {", "+\t\t\t\t\tthis.targetedElement = computeTargetedElement(fakeType);", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t}", "+\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d5a3508b06b324938b2afebbb2c8a30c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "e589570c4bd9e6c5ed804728bca5f124c9938845", "commitAfterChange": "876d1e29545f3823ab6b6c14229362303cd9cc00", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 14, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["+\t\t\t\t// Skip the otherInheritedMethod if it is completely replaced by inheritedMethod", "+\t\t\t\t// This elimination used to happen rather eagerly in computeInheritedMethods step", "+\t\t\t\t// itself earlier. (https://bugs.eclipse.org/bugs/show_bug.cgi?id=302358)", "+\t\t\t\tif (inheritedMethod.declaringClass != otherInheritedMethod.declaringClass) {", "+\t\t\t\t\tif (otherInheritedMethod.declaringClass.isInterface()) {", "+\t\t\t\t\t\tif (isInterfaceMethodImplemented(otherInheritedMethod, inheritedMethod, otherInheritedMethod.declaringClass)) {", "+\t\t\t\t\t\t\tskip[j] = true;", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (areMethodsCompatible(inheritedMethod, otherInheritedMethod)) {", "+\t\t\t\t\t\tskip[j] = true;", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t}", "+\t\t\t\t}"]}], "num": 26389}