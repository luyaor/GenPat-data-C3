{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0ef8c0f09810f21641a742a5d59c2c13", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "829c90e60eb1a8ff4bfb3ca3fc1d260d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "da5e3044bf1aa602314b19a69e01c7d30d0c61d0", "commitAfterChange": "d2a7051ad6f971a1319fef017042d09bcae83b4b", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "\r \tpublic void fire()", "signatureAfterChange": "\r \tpublic void fire(JavaElementDelta customDelta, int originalEventType)", "diff": ["-\tpublic void fire() {\r", "+\tpublic void fire(JavaElementDelta customDelta, int originalEventType) {\r", "+\r", "-\t\t\tthis.mergeDeltas();\r", "-\t\t\ttry {\r", "-\t\t\t\tIterator iterator = fJavaModelDeltas.iterator();\r", "-\t\t\t\twhile (iterator.hasNext()) {\r", "-\t\t\t\t\tIJavaElementDelta delta= (IJavaElementDelta) iterator.next();\r", "-\t\t\t\t\tif (DeltaProcessor.VERBOSE){\r", "-\t\t\t\t\t\tSystem.out.println(\"FIRING Delta [\"+Thread.currentThread()+\"]:\\n\" + delta);//$NON-NLS-1$//$NON-NLS-2$\r", "+\r", "+\t\t\tint eventType;\r", "+\t\t\t\r", "+\t\t\t/* DEFAULT event type is used when operation doesn't know actual event type and needed to fire immediately:\r", "+\t\t\t * e.g. non-resource modifying operation, create/destroy shared working copies\r", "+\t\t\t *\r", "+\t\t\t * this is mapped to a POST-change + PRE-build change for all interested listeners\r", "+\t\t\t */\r", "+\t\t\tif (originalEventType == DEFAULT_CHANGE_EVENT){\r", "+\t\t\t\teventType = ElementChangedEvent.POST_CHANGE;\r", "+\t\t\t} else {\r", "+\t\t\t\teventType = originalEventType;\r", "+\t\t\t}\r", "+\t\t\t\r", "+\t\t\tJavaElementDelta deltaToNotify;\r", "+\t\t\tif (customDelta == null){\r", "+\t\t\t\tthis.mergeDeltas();\r", "+\t\t\t\tif (fJavaModelDeltas.size() > 0){ \r", "+\r", "+\t\t\t\t\t// cannot be more than 1 after merge\r", "+\t\t\t\t\tdeltaToNotify = (JavaElementDelta)fJavaModelDeltas.get(0);\r", "+\r", "+\t\t\t\t\t// empty the queue only after having fired final volley of deltas and no custom deltas was superposed\r", "+\t\t\t\t\tif (eventType == ElementChangedEvent.POST_CHANGE){\r", "+\t\t\t\t\t\t// flush now so as to keep listener reactions to post their own deltas for subsequent iteration\r", "+\t\t\t\t\t\tthis.flush();\r", "-\t\t\t\t\t\r", "-\t\t\t\t\t// Refresh internal scopes\r", "-\t\t\t\t\tIterator scopes = this.scopes.keySet().iterator();\r", "-\t\t\t\t\twhile (scopes.hasNext()) {\r", "-\t\t\t\t\t\tAbstractSearchScope scope = (AbstractSearchScope)scopes.next();\r", "-\t\t\t\t\t\tscope.processDelta(delta);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\t\r", "-\t\t\t\t\tElementChangedEvent event= new ElementChangedEvent(delta);\r", "-\t\t\t\t\t// Clone the listeners since they could remove themselves when told about the event \r", "-\t\t\t\t\t// (eg. a type hierarchy becomes invalid (and thus it removes itself) when the type is removed\r", "-\t\t\t\t\tArrayList listeners= (ArrayList) fElementChangedListeners.clone();\r", "-\t\t\t\t\tfor (int i= 0; i < listeners.size(); i++) {\r", "-\t\t\t\t\t\tIElementChangedListener listener= (IElementChangedListener) listeners.get(i);\r", "-\t\t\t\t\t\tlistener.elementChanged(event);\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\treturn;\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\tdeltaToNotify = customDelta;\r", "+\t\t\t}\r", "+\t\t\tif (DeltaProcessor.VERBOSE){\r", "+\t\t\t\tSystem.out.println(\"FIRING Delta [\"+Thread.currentThread()+\"]:\\n\" + deltaToNotify);//$NON-NLS-1$//$NON-NLS-2$\r", "+\t\t\t}\r", "+\t\t\t\t\r", "+\t\t\t// Refresh internal scopes\r", "+\t\t\tIterator scopes = this.scopes.keySet().iterator();\r", "+\t\t\twhile (scopes.hasNext()) {\r", "+\t\t\t\tAbstractSearchScope scope = (AbstractSearchScope)scopes.next();\r", "+\t\t\t\tscope.processDelta(deltaToNotify);\r", "+\t\t\t}\r", "+\t\t\t\t\r", "+\t\t\t// Notification\r", "+\r", "+\t\t\t// Important: if any listener reacts to notification by updating the listeners list or mask, these lists will\r", "+\t\t\t// be duplicated, so it is necessary to remember original lists in a variable (since field values may change under us)\r", "+\t\t\tIElementChangedListener[] listeners = this.elementChangedListeners;\r", "+\t\t\tint[] listenerMask = this.elementChangedListenerMasks;\r", "+\t\t\tint listenerCount = this.elementChangedListenerCount;\r", "+\r", "+\t\t\t// in case using a DEFAULT change event, will notify also all listeners also interested in PRE-build events\r", "+\t\t\tif (originalEventType == DEFAULT_CHANGE_EVENT){\r", "+\t\t\t\tElementChangedEvent extraEvent = new ElementChangedEvent(deltaToNotify, ElementChangedEvent.PRE_AUTO_BUILD);\r", "+\t\t\t\tfor (int i= 0; i < listenerCount; i++) {\r", "+\t\t\t\t\tif ((listenerMask[i] & ElementChangedEvent.PRE_AUTO_BUILD) != 0){\r", "+\t\t\t\t\t\tlisteners[i].elementChanged(extraEvent);\r", "-\t\t\t} finally {\r", "-\t\t\t\t// empty the queue\r", "-\t\t\t\tthis.flush();\r", "+\t\t\t}\r", "+\r", "+\t\t\t// regular notification\r", "+\t\t\tElementChangedEvent event = new ElementChangedEvent(deltaToNotify, eventType);\r", "+\t\t\tfor (int i= 0; i < listenerCount; i++) {\r", "+\t\t\t\tif ((listenerMask[i] & eventType) != 0){\r", "+\t\t\t\t\tlisteners[i].elementChanged(event);\r", "+\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d6813bad26a98cc682081360192a228b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java", "commitBeforeChange": "e781f8e7f01bf193d5dc75f48e7e40aa2b3a1ff8", "commitAfterChange": "253b6e86274d6a434f078cf2295ba672e6b070f0", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tprivate String computeRootPath()", "signatureAfterChange": " \tprivate String computeRootPath(final String fullName)", "diff": ["-\tprivate String computeRootPath() {", "+\tprivate String computeRootPath(final String fullName) {", "+\t\t\t\tint index = Integer.MAX_VALUE;", "+\t\t\t\tString foundEntry = null;", "-\t\t\t\t\t\tchar[] contents = this.readSource(entry, zip);", "-\t\t\t\t\t\tString rootPath = computeRootPath(name, contents);", "-\t\t\t\t\t\tif (rootPath != null) {", "-\t\t\t\t\t\t\treturn rootPath;", "+\t\t\t\t\t\tif (name.endsWith(fullName)) {", "+\t\t\t\t\t\t\tindex = Math.min(index, name.indexOf(fullName));", "+\t\t\t\t\t\t\tfoundEntry = name;", "+\t\t\t\t}", "+\t\t\t\tif (foundEntry != null) {", "+\t\t\t\t\treturn foundEntry.substring(0, index);", "+\t\t\t\tfinal int[] index = new int[] { Integer.MAX_VALUE };", "-\t\t\t\t\t\t\t\t\t\tchar[] contents = org.eclipse.jdt.internal.core.Util.getResourceContentsAsCharArray((IFile)resource, encoding);", "-\t\t\t\t\t\t\t\t\t\tIPath fullPath = resource.getFullPath();", "+\t\t\t\t\t\t\t\t\t\tIPath resourceFullPath = resource.getFullPath();", "-\t\t\t\t\t\t\t\t\t\tIPath javaFilePath = fullPath.removeFirstSegments(sourcePathSegmentCount);", "-\t\t\t\t\t\t\t\t\t\tString rootPath = computeRootPath(javaFilePath.toString(), contents);", "-\t\t\t\t\t\t\t\t\t\tif (rootPath != null) {", "-\t\t\t\t\t\t\t\t\t\t\trootPathHolder[0] = rootPath;", "-\t\t\t\t\t\t\t\t\t\t\tthrow new CoreException(new JavaModelStatus()); // abort visit", "+\t\t\t\t\t\t\t\t\t\tIPath javaFilePath = resourceFullPath.removeFirstSegments(sourcePathSegmentCount);", "+\t\t\t\t\t\t\t\t\t\tString javaFilePathString = javaFilePath.toString();", "+\t\t\t\t\t\t\t\t\t\tif (javaFilePathString.endsWith(fullName)) {", "+\t\t\t\t\t\t\t\t\t\t\tindex[0] = Math.min(index[0], javaFilePathString.indexOf(javaFilePathString));", "+\t\t\t\t\t\t\t\t\t\t\trootPathHolder[0] = javaFilePathString;", "-\t\t\t\t\treturn rootPathHolder[0];", "+\t\t\t\t\tif (index[0] == 0) {", "+\t\t\t\t\t\treturn \"\"; //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t\treturn rootPathHolder[0].substring(0, index[0]);", "-\t\t\t\t\treturn computeRootPath(file);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\treturn null;", "-\t}", "+\t\t\t\t\tfinal String[] rootPathHolder = new String[1];", "+\t\t\t\t\tfinal int[] index = new int[] { Integer.MAX_VALUE };", "+\t\t\t\t\tcomputeRootPath(file, fullName, rootPathHolder, index);", "+\t\t\t\t\tif (rootPathHolder[0] != null) {", "+\t\t\t\t\t\tif (index[0] == 0) {", "+\t\t\t\t\t\t\treturn \"\"; //$NON-NLS-1$", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn rootPathHolder[0].substring(0, index[0]);", "+\t\t\t\t\t}"]}], "num": 64315}