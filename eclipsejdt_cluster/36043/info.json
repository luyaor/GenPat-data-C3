{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8a44d52d0cb425f21619170055939b90", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c71989ca0f7570213ad14de4588a8283", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": "  public void checkExceptionHandlers(TypeBinding[] raisedExceptions, ASTNode location, FlowInfo flowInfo, BlockScope scope)", "signatureAfterChange": "  public void checkExceptionHandlers(TypeBinding[] raisedExceptions, ASTNode location, FlowInfo flowInfo, BlockScope scope)", "diff": ["-\t\tif (((sub = traversedContext.subRoutine()) != null) && sub.isSubRoutineEscaping()) {", "+\t\tif (((sub = traversedContext.subroutine()) != null) && sub.isSubRoutineEscaping()) {", "-\t\tif (traversedContext.associatedNode instanceof TryStatement){", "-\t\t\tTryStatement tryStatement = (TryStatement) traversedContext.associatedNode;", "-\t\t\t\tflowInfo = flowInfo.addInitializationsFrom(tryStatement.subRoutineInits);", "-\t\t}", "+\t\t", "+\t\tif (traversedContext instanceof InsideSubRoutineFlowContext) {", "+\t\t\tASTNode node = traversedContext.associatedNode;", "+\t\t\tif (node instanceof TryStatement) {", "+\t\t\t\tTryStatement tryStatement = (TryStatement) node;", "+\t\t\t\tflowInfo.addInitializationsFrom(tryStatement.subRoutineInits); // collect inits\t\t\t", "+\t\t\t}", "+\t\t}\t\t", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd959afb1e34adfc786d2261b715dff4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public void checkExceptionHandlers(TypeBinding raisedException, ASTNode location, FlowInfo flowInfo, BlockScope scope)", "signatureAfterChange": "  public void checkExceptionHandlers(TypeBinding raisedException, ASTNode location, FlowInfo flowInfo, BlockScope scope)", "diff": ["+", "+public void checkExceptionHandlers(TypeBinding raisedException, ASTNode location, FlowInfo flowInfo, BlockScope scope) {", "+\t// LIGHT-VERSION OF THE EQUIVALENT WITH AN ARRAY OF EXCEPTIONS", "+\t// check that all the argument exception types are handled", "+\t// JDK Compatible implementation - when an exception type is thrown, ", "+\t// all related catch blocks are marked as reachable... instead of those only", "+\t// until the point where it is safely handled (Smarter - see comment at the end)", "+\tFlowContext traversedContext = this;", "+\twhile (traversedContext != null) {", "+\t\tSubRoutineStatement sub;", "+\t\tif (((sub = traversedContext.subroutine()) != null) && sub.isSubRoutineEscaping()) {", "+\t\t\t// traversing a non-returning subroutine means that all unhandled ", "+\t\t\t// exceptions will actually never get sent...", "+\t\t\treturn;", "+\t\t}", "+\t\t", "+\t\t// filter exceptions that are locally caught from the innermost enclosing ", "+\t\t// try statement to the outermost ones.", "+\t\tif (traversedContext instanceof ExceptionHandlingFlowContext) {", "+\t\t\tExceptionHandlingFlowContext exceptionContext =", "+\t\t\t\t(ExceptionHandlingFlowContext) traversedContext;", "+\t\t\tReferenceBinding[] caughtExceptions;", "+\t\t\tif ((caughtExceptions = exceptionContext.handledExceptions) != Binding.NO_EXCEPTIONS) {", "+\t\t\t\tboolean definitelyCaught = false;", "+\t\t\t\tfor (int caughtIndex = 0, caughtCount = caughtExceptions.length;", "+\t\t\t\t\tcaughtIndex < caughtCount;", "+\t\t\t\t\tcaughtIndex++) {", "+\t\t\t\t\tReferenceBinding caughtException = caughtExceptions[caughtIndex];", "+\t\t\t\t    int state = caughtException == null ", "+\t\t\t\t    \t? Scope.EQUAL_OR_MORE_SPECIFIC /* any exception */", "+\t\t\t\t        : Scope.compareTypes(raisedException, caughtException);\t\t\t\t\t\t", "+\t\t\t\t\tswitch (state) {", "+\t\t\t\t\t\tcase Scope.EQUAL_OR_MORE_SPECIFIC :", "+\t\t\t\t\t\t\texceptionContext.recordHandlingException(", "+\t\t\t\t\t\t\t\tcaughtException,", "+\t\t\t\t\t\t\t\tflowInfo.unconditionalInits(),", "+\t\t\t\t\t\t\t\traisedException,", "+\t\t\t\t\t\t\t\tlocation,", "+\t\t\t\t\t\t\t\tdefinitelyCaught);", "+\t\t\t\t\t\t\t// was it already definitely caught ?", "+\t\t\t\t\t\t\tdefinitelyCaught = true;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase Scope.MORE_GENERIC :", "+\t\t\t\t\t\t\texceptionContext.recordHandlingException(", "+\t\t\t\t\t\t\t\tcaughtException,", "+\t\t\t\t\t\t\t\tflowInfo.unconditionalInits(),", "+\t\t\t\t\t\t\t\traisedException,", "+\t\t\t\t\t\t\t\tlocation,", "+\t\t\t\t\t\t\t\tfalse);", "+\t\t\t\t\t\t\t// was not caught already per construction", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (definitelyCaught)", "+\t\t\t\t\treturn;", "+\t\t\t}", "+\t\t\t// method treatment for unchecked exceptions", "+\t\t\tif (exceptionContext.isMethodContext) {", "+\t\t\t\tif (raisedException.isUncheckedException(false))", "+\t\t\t\t\treturn;", "+\t\t\t\t\t", "+\t\t\t\t// anonymous constructors are allowed to throw any exceptions (their thrown exceptions", "+\t\t\t\t// clause will be fixed up later as per JLS 8.6).", "+\t\t\t\tif (exceptionContext.associatedNode instanceof AbstractMethodDeclaration){", "+\t\t\t\t\tAbstractMethodDeclaration method = (AbstractMethodDeclaration)exceptionContext.associatedNode;", "+\t\t\t\t\tif (method.isConstructor() && method.binding.declaringClass.isAnonymousType()){", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\texceptionContext.mergeUnhandledException(raisedException);", "+\t\t\t\t\t\treturn; // no need to complain, will fix up constructor exceptions\t\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak; // not handled anywhere, thus jump to error handling", "+\t\t\t}", "+\t\t}", "+", "+\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "+\t\t", "+\t\tif (traversedContext instanceof InsideSubRoutineFlowContext) {", "+\t\t\tASTNode node = traversedContext.associatedNode;", "+\t\t\tif (node instanceof TryStatement) {", "+\t\t\t\tTryStatement tryStatement = (TryStatement) node;", "+\t\t\t\tflowInfo.addInitializationsFrom(tryStatement.subRoutineInits); // collect inits\t\t\t", "+\t\t\t}", "+\t\t}", "+\t\ttraversedContext = traversedContext.parent;", "+\t}", "+\t// if reaches this point, then there are some remaining unhandled exception types.", "+\tscope.problemReporter().unhandledException(raisedException, location);", "-", "-public void checkExceptionHandlers(TypeBinding raisedException, ASTNode location, FlowInfo flowInfo, BlockScope scope) {", "-\t// LIGHT-VERSION OF THE EQUIVALENT WITH AN ARRAY OF EXCEPTIONS", "-\t// check that all the argument exception types are handled", "-\t// JDK Compatible implementation - when an exception type is thrown, ", "-\t// all related catch blocks are marked as reachable... instead of those only", "-\t// until the point where it is safely handled (Smarter - see comment at the end)", "-\tFlowContext traversedContext = this;", "-\twhile (traversedContext != null) {", "-\t\tSubRoutineStatement sub;", "-\t\tif (((sub = traversedContext.subRoutine()) != null) && sub.isSubRoutineEscaping()) {", "-\t\t\t// traversing a non-returning subroutine means that all unhandled ", "-\t\t\t// exceptions will actually never get sent...", "-\t\t\treturn;", "-\t\t}", "-\t\t", "-\t\t// filter exceptions that are locally caught from the innermost enclosing ", "-\t\t// try statement to the outermost ones.", "-\t\tif (traversedContext instanceof ExceptionHandlingFlowContext) {", "-\t\t\tExceptionHandlingFlowContext exceptionContext =", "-\t\t\t\t(ExceptionHandlingFlowContext) traversedContext;", "-\t\t\tReferenceBinding[] caughtExceptions;", "-\t\t\tif ((caughtExceptions = exceptionContext.handledExceptions) != Binding.NO_EXCEPTIONS) {", "-\t\t\t\tboolean definitelyCaught = false;", "-\t\t\t\tfor (int caughtIndex = 0, caughtCount = caughtExceptions.length;", "-\t\t\t\t\tcaughtIndex < caughtCount;", "-\t\t\t\t\tcaughtIndex++) {", "-\t\t\t\t\tReferenceBinding caughtException = caughtExceptions[caughtIndex];", "-\t\t\t\t    int state = caughtException == null ", "-\t\t\t\t    \t? Scope.EQUAL_OR_MORE_SPECIFIC /* any exception */", "-\t\t\t\t        : Scope.compareTypes(raisedException, caughtException);\t\t\t\t\t\t", "-\t\t\t\t\tswitch (state) {", "-\t\t\t\t\t\tcase Scope.EQUAL_OR_MORE_SPECIFIC :", "-\t\t\t\t\t\t\texceptionContext.recordHandlingException(", "-\t\t\t\t\t\t\t\tcaughtException,", "-\t\t\t\t\t\t\t\tflowInfo.unconditionalInits(),", "-\t\t\t\t\t\t\t\traisedException,", "-\t\t\t\t\t\t\t\tlocation,", "-\t\t\t\t\t\t\t\tdefinitelyCaught);", "-\t\t\t\t\t\t\t// was it already definitely caught ?", "-\t\t\t\t\t\t\tdefinitelyCaught = true;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase Scope.MORE_GENERIC :", "-\t\t\t\t\t\t\texceptionContext.recordHandlingException(", "-\t\t\t\t\t\t\t\tcaughtException,", "-\t\t\t\t\t\t\t\tflowInfo.unconditionalInits(),", "-\t\t\t\t\t\t\t\traisedException,", "-\t\t\t\t\t\t\t\tlocation,", "-\t\t\t\t\t\t\t\tfalse);", "-\t\t\t\t\t\t\t// was not caught already per construction", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (definitelyCaught)", "-\t\t\t\t\treturn;", "-\t\t\t}", "-\t\t\t// method treatment for unchecked exceptions", "-\t\t\tif (exceptionContext.isMethodContext) {", "-\t\t\t\tif (raisedException.isUncheckedException(false))", "-\t\t\t\t\treturn;", "-\t\t\t\t\t", "-\t\t\t\t// anonymous constructors are allowed to throw any exceptions (their thrown exceptions", "-\t\t\t\t// clause will be fixed up later as per JLS 8.6).", "-\t\t\t\tif (exceptionContext.associatedNode instanceof AbstractMethodDeclaration){", "-\t\t\t\t\tAbstractMethodDeclaration method = (AbstractMethodDeclaration)exceptionContext.associatedNode;", "-\t\t\t\t\tif (method.isConstructor() && method.binding.declaringClass.isAnonymousType()){", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\texceptionContext.mergeUnhandledException(raisedException);", "-\t\t\t\t\t\treturn; // no need to complain, will fix up constructor exceptions\t\t\t\t\t\t", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak; // not handled anywhere, thus jump to error handling", "-\t\t\t}", "-\t\t}", "-", "-\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "-\t\tif (traversedContext.associatedNode instanceof TryStatement){", "-\t\t\tTryStatement tryStatement = (TryStatement) traversedContext.associatedNode;", "-\t\t\t\tflowInfo = flowInfo.addInitializationsFrom(tryStatement.subRoutineInits);", "-\t\t}", "-\t\ttraversedContext = traversedContext.parent;", "-\t}", "-\t// if reaches this point, then there are some remaining unhandled exception types.", "-\tscope.problemReporter().unhandledException(raisedException, location);"]}], "num": 36043}