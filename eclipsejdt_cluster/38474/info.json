{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6b1cd35074f6b597a36be2a91f8e856b", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09a12cf0c4e249af0cc64ba6daf4609b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptUtil.java", "commitBeforeChange": "c1f8b23725dd7ea4b476b40485a277dac1e772a8", "commitAfterChange": "9aadd271aa6b9408f381dcc08f67ae2c31958a0a", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static boolean hasAnnotationInstance( IFile f )", "signatureAfterChange": " \tprivate AptUtil()", "diff": ["+\t// Private c-tor to prevent construction", "+\tprivate AptUtil() {}", "-\tpublic static boolean hasAnnotationInstance( IFile f ) {", "-\t\tInputStreamReader reader = null;", "-\t\tInputStream input = null;", "-\t\ttry {", "-\t\t\tAnnotationScanner scanner;", "-\t\t\t// If this is a single byte encoding, we can deal directly ", "-\t\t\t// with the bytes, which is *much* faster", "-\t\t\tif (SINGLE_BYTE_ENCODINGS.contains(f.getCharset())) {", "-\t\t\t\tinput = ProcessorEnvImpl.getInputStream(f);", "-\t\t\t\tscanner = new InputStreamAnnotationScanner(input);", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\treader = ProcessorEnvImpl.getFileReader( f );", "-\t\t\t\tscanner = new ReaderAnnotationScanner(reader);", "-\t\t\t}", "-\t\t\treturn scanner.containsAnnotations();", "-\t\t}", "-\t\tcatch( Exception ioe ) {", "-\t\t\treturn false;", "-\t\t}", "-\t\tfinally {", "-\t\t\tif (reader != null) { try {reader.close();} catch (IOException ioe) {} }", "-\t\t\tif (input != null) { try {input.close();} catch (IOException ioe) {} }", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e6625f830dfd4a069a1fc95f951d18b9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptUtil.java", "commitBeforeChange": "9378f12e46617b3c47a50827083b7b76b76aaf96", "commitAfterChange": "ecc05f0ca2665c6c46b18bc8153f342d2808fcb6", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static boolean hasAnnotationInstance( IFile f )", "signatureAfterChange": " \tpublic static boolean hasAnnotationInstance( IFile f )", "diff": ["-\tpublic static boolean hasAnnotationInstance( IFile f )", "-\t{", "-\t\ttry", "-\t\t{", "-\t\t\tchar[] source = ProcessorEnvImpl.getFileContents( f );", "-\t\t\treturn hasAnnotationInstance( source );", "+\tpublic static boolean hasAnnotationInstance( IFile f ) {", "+\t\t", "+\t\tInputStreamReader reader = null;", "+\t\tInputStream input = null;", "+\t\ttry {", "+\t\t\tAnnotationScanner scanner;", "+\t\t\t// If this is a single byte encoding, we can deal directly ", "+\t\t\t// with the bytes, which is *much* faster", "+\t\t\tif (SINGLE_BYTE_ENCODINGS.contains(f.getCharset())) {", "+\t\t\t\tinput = ProcessorEnvImpl.getInputStream(f);", "+\t\t\t\tscanner = new InputStreamAnnotationScanner(input);", "+\t\t\t}", "+\t\t\telse {", "+\t\t\t\treader = ProcessorEnvImpl.getFileReader( f );", "+\t\t\t\tscanner = new ReaderAnnotationScanner(reader);", "+\t\t\t}", "+\t\t\treturn scanner.containsAnnotations();", "-\t\tcatch( Exception ioe )", "-\t\t{", "+\t\tcatch( Exception ioe ) {", "+\t\t}", "+\t\tfinally {", "+\t\t\tif (reader != null) { try {reader.close();} catch (IOException ioe) {} }", "+\t\t\tif (input != null) { try {input.close();} catch (IOException ioe) {} }"]}], "num": 38474}