{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4970b942bd2a7a8557bdfa00553fc91a", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f867ce452cae2fe4d639da47033e332", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "d02bd6550c58d90c9715e43cd6d6787e2666be1b", "commitAfterChange": "108af22a70bd5ce5bac2996d806c5c7df39f1d74", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprivate boolean checkSelection( \t\tchar[] source, \t\tint selectionStart, \t\tint selectionEnd)", "signatureAfterChange": " \tprivate boolean checkSelection( \t\tchar[] source, \t\tint selectionStart, \t\tint selectionEnd)", "diff": ["+\t\t\t// compute end position of the selection", "+\t\t\tint end = selectionEnd + 1 == source.length ? selectionEnd : selectionEnd + 1;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tint endOfUnicode = pos + 3;", "+\t\t\t\t\t\tif (end < endOfUnicode) {", "+\t\t\t\t\t\t\tif (endOfUnicode < source.length) {", "+\t\t\t\t\t\t\t\tend = endOfUnicode;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\treturn false; // not enough characters to decode an unicode", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t", "-\t\t\tscanner.resetTo(nextCharacterPosition, selectionEnd + 1 == source.length ? selectionEnd : selectionEnd + 1);", "+\t\t\tscanner.resetTo(nextCharacterPosition, end);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c8e2c268281b93b339b0d544ab6c977", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LongLiteral.java", "commitBeforeChange": "13104368bab2c644cc28925b08109cccdd658f94", "commitAfterChange": "714f4513b0858f77d40d227c61f24987b7f442ac", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public void computeConstant()", "signatureAfterChange": " public void computeConstant()", "diff": ["-", "-\tif (source[0] == '0')", "-\t{\tif (length == 1) { \tconstant = Constant.fromValue(0L);\treturn;\t}", "+\tif (source[0] == '0') {", "+\t\tif (length == 1) {", "+\t\t\tconstant = Constant.fromValue(0L);", "+\t\t\treturn;", "+\t\t}", "-\t\tif ( (source[1] == 'x') || (source[1] == 'X') )", "-\t\t{\tshift = 4 ; j = 2; radix = 16;}", "-\t\telse", "-\t\t{\tshift = 3 ; j = 1; radix = 8;}", "+\t\tif ( (source[1] == 'x') || (source[1] == 'X') ) {", "+\t\t\tshift = 4 ; j = 2; radix = 16;", "+\t\t} else {", "+\t\t\tshift = 3 ; j = 1; radix = 8;", "+\t\t}", "-\t\twhile (source[j]=='0') ", "-\t\t{\tj++; //jump over redondant zero", "-\t\t\tif ( j == length)", "-\t\t\t{\t//watch for 0000000000000L", "+\t\twhile (source[j]=='0') {", "+\t\t\tj++; //jump over redondant zero", "+\t\t\tif ( j == length) {", "+\t\t\t\t//watch for 0000000000000L", "-\t\t\t\treturn ;}}", "+\t\t\t\treturn ;", "+\t\t\t}", "+\t\t}", "-\t\tif ((digitValue = Character.digit(source[j++],radix))\t< 0 ) \t", "-\t\t{\tconstant = FORMAT_ERROR; return ;}", "-\t\tif (digitValue >= 8) nbDigit = 4;", "-\t\telse \tif (digitValue >= 4) nbDigit = 3;", "-\t\t\t\telse \tif (digitValue >= 2) nbDigit = 2;", "-\t\t\t\t\t\telse nbDigit = 1; //digitValue is not 0", "+\t\tif ((digitValue = Character.digit(source[j++],radix)) < 0 ) {", "+\t\t\tconstant = FORMAT_ERROR; return ;", "+\t\t}", "+\t\tif (digitValue >= 8)", "+\t\t\tnbDigit = 4;", "+\t\telse if (digitValue >= 4)", "+\t\t\tnbDigit = 3;", "+\t\telse if (digitValue >= 2)", "+\t\t\tnbDigit = 2;", "+\t\telse", "+\t\t\tnbDigit = 1; //digitValue is not 0", "-\t\twhile (j<length)", "-\t\t{\tif ((digitValue = Character.digit(source[j++],radix))\t< 0 ) \t", "-\t\t\t{\tconstant = FORMAT_ERROR; return ;}", "-\t\t\tif ((nbDigit += shift) > 64) return /*constant stays null*/ ;", "-\t\t\tcomputedValue = (computedValue<<shift) | digitValue ;}}", "-", "-\telse", "-\t{\t//-----------case radix=10-----------------", "-\t\tlong previous = computedValue = 0;", "-\t\tfor (int i = 0 ; i < length; i++) ", "-\t\t{\tint digitValue ;\t", "-\t\t\tif ((digitValue = Character.digit(source[i], 10)) < 0 ) return /*constant stays null*/ ;", "+\t\twhile (j<length) {", "+\t\t\tif ((digitValue = Character.digit(source[j++],radix)) < 0) {", "+\t\t\t\tconstant = FORMAT_ERROR; return ;", "+\t\t\t}", "+\t\t\tif ((nbDigit += shift) > 64)", "+\t\t\t\treturn /*constant stays null*/ ;", "+\t\t\tcomputedValue = (computedValue<<shift) | digitValue ;", "+\t\t}", "+\t} else {", "+\t\t//-----------case radix=10-----------------", "+\t\tlong previous = 0;", "+\t\tcomputedValue = 0;", "+\t\tfinal long limit = Long.MAX_VALUE / 10; // needed to check prior to the multiplication", "+\t\tfor (int i = 0 ; i < length; i++) {", "+\t\t\tint digitValue ;\t", "+\t\t\tif ((digitValue = Character.digit(source[i], 10)) < 0 ) return /*constant stays null*/;", "-\t\t\tcomputedValue = 10 * computedValue + digitValue ;", "-\t\t\tif (previous > computedValue) return /*constant stays null*/;}}", "-\t", "+\t\t\tif (computedValue > limit)", "+\t\t\t\treturn /*constant stays null*/;", "+\t\t\tcomputedValue *= 10;", "+\t\t\tif ((computedValue + digitValue) > Long.MAX_VALUE)", "+\t\t\t\treturn /*constant stays null*/;", "+\t\t\tcomputedValue += digitValue;", "+\t\t\tif (previous > computedValue)", "+\t\t\t\treturn /*constant stays null*/;", "+\t\t}", "+\t}"]}], "num": 24314}