{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cb425ba2160481882482ca1ac546d761", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "602f2ed128d26937920bc638206c7ded", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java", "commitBeforeChange": "0eef8a719c726a9948e73db62c7f81adbce0f319", "commitAfterChange": "b54c3afd14262a683a389ccef497f8aa51da674c", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "  public BinaryTypeBinding createBinaryTypeFrom(IBinaryType binaryType, PackageBinding packageBinding, boolean needFieldsAndMethods, AccessRestriction accessRestriction)", "signatureAfterChange": "  public BinaryTypeBinding createBinaryTypeFrom(IBinaryType binaryType, PackageBinding packageBinding, boolean needFieldsAndMethods, AccessRestriction accessRestriction)", "diff": ["-\tif (cachedType != null) { // update reference to unresolved binding after having read classfile (knows whether generic for raw conversion)", "-\t\tif (cachedType instanceof UnresolvedReferenceBinding) {", "-\t\t\t((UnresolvedReferenceBinding) cachedType).setResolvedType(binaryBinding, this);", "-\t\t} else {", "-\t\t\tif (cachedType.isBinaryBinding()) // sanity check... at this point the cache should ONLY contain unresolved types", "-\t\t\t\treturn (BinaryTypeBinding) cachedType;", "-\t\t\t// it is possible with a large number of source files (exceeding AbstractImageBuilder.MAX_AT_ONCE) that a member type can be in the cache as an UnresolvedType,", "-\t\t\t// but because its enclosingType is resolved while its created (call to BinaryTypeBinding constructor), its replaced with a source type", "-\t\t\treturn null;", "-\t\t}", "+\tif (cachedType != null && !cachedType.isUnresolvedType()) {", "+\t\tif (cachedType.isBinaryBinding()) // sanity check... at this point the cache should ONLY contain unresolved types", "+\t\t\treturn (BinaryTypeBinding) cachedType;", "+\t\t// it is possible with a large number of source files (exceeding AbstractImageBuilder.MAX_AT_ONCE) that a member type can be in the cache as an UnresolvedType,", "+\t\t// but because its enclosingType is resolved while its created (call to BinaryTypeBinding constructor), its replaced with a source type", "+\t\treturn null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e447733e6a7e69651a85631325441d42", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java", "commitBeforeChange": "6ba33977e63feb9d08c7d3c1dcfe1d17fe38ce32", "commitAfterChange": "0cfc1909e7a79aeaf7a72a81c013f0897f47ac1d", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " public BinaryTypeBinding createBinaryTypeFrom(IBinaryType binaryType, PackageBinding packageBinding, boolean needFieldsAndMethods, AccessRestriction accessRestriction)", "signatureAfterChange": " public BinaryTypeBinding createBinaryTypeFrom(IBinaryType binaryType, PackageBinding packageBinding, boolean needFieldsAndMethods, AccessRestriction accessRestriction)", "diff": ["-\t\t// TODO (kent) suspect the check below is no longer required, since we should not be requesting a binary which is already in the cache", "-\t\tif (cachedType.isBinaryBinding()) // sanity check before the cast... at this point the cache should ONLY contain unresolved types", "-\t\t\treturn (BinaryTypeBinding) cachedType;", "-", "-\t\t((UnresolvedReferenceBinding) cachedType).setResolvedType(binaryBinding, this);", "+\t\tif (cachedType instanceof UnresolvedReferenceBinding) {", "+\t\t\t((UnresolvedReferenceBinding) cachedType).setResolvedType(binaryBinding, this);", "+\t\t} else {", "+\t\t\tif (cachedType.isBinaryBinding()) // sanity check... at this point the cache should ONLY contain unresolved types", "+\t\t\t\treturn (BinaryTypeBinding) cachedType;", "+\t\t\t// it is possible with a large number of source files (exceeding AbstractImageBuilder.MAX_AT_ONCE) that a member type can be in the cache as an UnresolvedType,", "+\t\t\t// but because its enclosingType is resolved while its created (call to BinaryTypeBinding constructor), its replaced with a source type", "+\t\t\treturn null;", "+\t\t}"]}], "num": 24588}