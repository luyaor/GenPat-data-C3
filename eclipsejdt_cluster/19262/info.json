{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6864f158024b7c99a900de930c97fdf2", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3b73423293c979e5973259a163c7a86c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "af330be1052a8d3b1a31b10596d367fb42f89f79", "commitAfterChange": "b3a6b4ddf9d5bd5365b7e897739a001bb2ff860b", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " boolean doesSubstituteMethodOverride(MethodBinding method, MethodBinding substituteMethod)", "signatureAfterChange": " boolean doesSubstituteMethodOverride(MethodBinding method, MethodBinding substituteMethod)", "diff": ["+// if it does not then a name clash error is likely", "-\tif (doTypeVariablesClash(method, substituteMethod)) return false;", "-\tif (areParametersEqual(method, substituteMethod)) return true;", "-\tif (method.declaringClass == substituteMethod.declaringClass) return false;", "+\tif (!areParametersEqual(method, substituteMethod)) {", "+\t\t// method can still override substituteMethod in cases like :", "+\t\t// <U extends Number> void c(U u) {}", "+\t\t// @Override void c(Number n) {}", "+\t\t// but method cannot have a \"generic-enabled\" parameter type", "+\t\tif (substituteMethod.hasSubstitutedParameters() && method.areParameterErasuresEqual(substituteMethod))", "+\t\t\treturn method.typeVariables == Binding.NO_TYPE_VARIABLES && !hasGenericParameter(method);", "+\t\treturn false;", "+\t}", "+\tif (substituteMethod instanceof ParameterizedGenericMethodBinding) {", "+\t\t// since substituteMethod has substituted type variables, method cannot have a generic signature AND no variables -> its a name clash if it does", "+\t\treturn ! (hasGenericParameter(method) && method.typeVariables == Binding.NO_TYPE_VARIABLES);", "+\t}", "+", "+\t// if method has its own variables, then substituteMethod failed bounds check in computeSubstituteMethod()", "+\treturn method.typeVariables == Binding.NO_TYPE_VARIABLES;", "+}", "-\tTypeBinding[] inheritedParams = substituteMethod.parameters;", "-\tint length = params.length;", "-\tif (length != inheritedParams.length)", "-\t\treturn false;", "-", "-\t// also allow a method such as Number foo(Number) to override <U> T foo(T) where T extends Number", "-\tif (method.typeVariables != Binding.NO_TYPE_VARIABLES || !substituteMethod.hasSubstitutedParameters())", "-\t\treturn false;", "-", "-\tfor (int i = 0; i < length; i++) {", "-\t\tif (inheritedParams[i].kind() == Binding.TYPE_PARAMETER) {", "-\t\t\tif (params[i] != ((TypeVariableBinding) inheritedParams[i]).upperBound())", "-\t\t\t\treturn false;", "-\t\t} else if (params[i] != inheritedParams[i]) {", "-\t\t\treturn false;\t\t\t", "-\treturn true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6c6a715e8b1e427e19958bea06e2aeb4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "f9968462ad3e78057baba9747e91f7b6e3ea59e1", "commitAfterChange": "1f65e2f1d1142c8be683dea8425f1840c9121137", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 25, "signatureBeforeChange": " boolean doesSubstituteMethodOverride(MethodBinding method, MethodBinding substituteMethod)", "signatureAfterChange": " boolean isSubstituteParameterSubsignature(MethodBinding method, MethodBinding substituteMethod)", "diff": ["-// if it does not then a name clash error is likely", "-boolean doesSubstituteMethodOverride(MethodBinding method, MethodBinding substituteMethod) {", "-\tif (!areParametersEqual(method, substituteMethod)) {", "-\t\t// method can still override substituteMethod in cases like :", "-\t\t// <U extends Number> void c(U u) {}", "-\t\t// @Override void c(Number n) {}", "-\t\t// but method cannot have a \"generic-enabled\" parameter type", "-\t\tif (substituteMethod.hasSubstitutedParameters() && method.areParameterErasuresEqual(substituteMethod))", "-\t\t\treturn method.typeVariables == Binding.NO_TYPE_VARIABLES && !hasGenericParameter(method);", "-\tif (substituteMethod instanceof ParameterizedGenericMethodBinding) {", "-\t\t// since substituteMethod has substituted type variables, method cannot have a generic signature AND no variables -> its a name clash if it does", "-\t\treturn ! (hasGenericParameter(method) && method.typeVariables == Binding.NO_TYPE_VARIABLES);", "-\t}", "-", "-\t// if method has its own variables, then substituteMethod failed bounds check in computeSubstituteMethod()", "-\treturn method.typeVariables == Binding.NO_TYPE_VARIABLES;", "+// if it does not then a name clash error is likely", "+boolean isSubstituteParameterSubsignature(MethodBinding method, MethodBinding substituteMethod) {", "+\tif (!areParametersEqual(method, substituteMethod)) {", "+\t\t// method can still override substituteMethod in cases like :", "+\t\t// <U extends Number> void c(U u) {}", "+\t\t// @Override void c(Number n) {}", "+\t\t// but method cannot have a \"generic-enabled\" parameter type", "+\t\tif (substituteMethod.hasSubstitutedParameters() && method.areParameterErasuresEqual(substituteMethod))", "+\t\t\treturn method.typeVariables == Binding.NO_TYPE_VARIABLES && !hasGenericParameter(method);", "+\t\treturn false;", "+\t}", "+", "+\tif (substituteMethod instanceof ParameterizedGenericMethodBinding) {", "+\t\t// since substituteMethod has substituted type variables, method cannot have a generic signature AND no variables -> its a name clash if it does", "+\t\treturn ! (hasGenericParameter(method) && method.typeVariables == Binding.NO_TYPE_VARIABLES);", "+\t}", "+", "+\t// if method has its own variables, then substituteMethod failed bounds check in computeSubstituteMethod()", "+\treturn method.typeVariables == Binding.NO_TYPE_VARIABLES;", "+}"]}], "num": 19262}