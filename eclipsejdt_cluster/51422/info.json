{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9b11fad4fb19ce37e37cabe88490de3f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "06a37ca6d98825665585235494f1d54c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "24ecdaaa88a3d3df53c6657b56b1c35a02f254d7", "commitAfterChange": "b77d2ea3108de5650fdc8f1f0c9f51bf7203159f", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic NameLookup(IPackageFragmentRoot[] packageFragmentRoots, HashtableOfArrayToObject packageFragments, ICompilationUnit[] workingCopies, Map rootToResolvedEntries)", "signatureAfterChange": "  \tpublic NameLookup(IPackageFragmentRoot[] packageFragmentRoots, HashtableOfArrayToObject packageFragments, ICompilationUnit[] workingCopies, Map rootToResolvedEntries)", "diff": ["-\t\t\tthis.unitsToLookInside = new HashMap();", "+\t\t\tthis.typesInWorkingCopies = new HashMap();", "-\t\t\t\tHashMap typeMap = (HashMap) this.unitsToLookInside.get(pkg);", "+\t\t\t\tHashMap typeMap = (HashMap) this.typesInWorkingCopies.get(pkg);", "-\t\t\t\t\tthis.unitsToLookInside.put(pkg, typeMap);", "+\t\t\t\t\tthis.typesInWorkingCopies.put(pkg, typeMap);", "-\t\t\t\t\tfor (int j = 0, typeLength = types.length; j < typeLength; j++) {", "-\t\t\t\t\t\tIType type = types[j];", "-\t\t\t\t\t\tString typeName = type.getElementName();", "-\t\t\t\t\t\tObject existing = typeMap.get(typeName);", "-\t\t\t\t\t\tif (existing == null) {", "-\t\t\t\t\t\t\ttypeMap.put(typeName, type);", "-\t\t\t\t\t\t} else if (existing instanceof IType) {", "-\t\t\t\t\t\t\ttypeMap.put(typeName, new IType[] {(IType) existing, type});", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tIType[] existingTypes = (IType[]) existing;", "-\t\t\t\t\t\t\tint existingTypeLength = existingTypes.length;", "-\t\t\t\t\t\t\tSystem.arraycopy(existingTypes, 0, existingTypes = new IType[existingTypeLength+1], 0, existingTypeLength);", "-\t\t\t\t\t\t\texistingTypes[existingTypeLength] = type;", "-\t\t\t\t\t\t\ttypeMap.put(typeName, existingTypes);", "+\t\t\t\t\tint typeLength = types.length;", "+\t\t\t\t\tif (typeLength == 0) {", "+\t\t\t\t\t\tString typeName = Util.getNameWithoutJavaLikeExtension(workingCopy.getElementName());", "+\t\t\t\t\t\ttypeMap.put(typeName, NO_TYPES);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfor (int j = 0; j < typeLength; j++) {", "+\t\t\t\t\t\t\tIType type = types[j];", "+\t\t\t\t\t\t\tString typeName = type.getElementName();", "+\t\t\t\t\t\t\tObject existing = typeMap.get(typeName);", "+\t\t\t\t\t\t\tif (existing == null) {", "+\t\t\t\t\t\t\t\ttypeMap.put(typeName, type);", "+\t\t\t\t\t\t\t} else if (existing instanceof IType) {", "+\t\t\t\t\t\t\t\ttypeMap.put(typeName, new IType[] {(IType) existing, type});", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tIType[] existingTypes = (IType[]) existing;", "+\t\t\t\t\t\t\t\tint existingTypeLength = existingTypes.length;", "+\t\t\t\t\t\t\t\tSystem.arraycopy(existingTypes, 0, existingTypes = new IType[existingTypeLength+1], 0, existingTypeLength);", "+\t\t\t\t\t\t\t\texistingTypes[existingTypeLength] = type;", "+\t\t\t\t\t\t\t\ttypeMap.put(typeName, existingTypes);", "+\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37613fe3e95205c982f7891b3394b7e3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "bde9840f9573d77080a23dfde60bdb51dc549649", "commitAfterChange": "e5950298e29dbaf979a85e6f3f4a27d3f4b008e8", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic NameLookup(IPackageFragmentRoot[] packageFragmentRoots, HashtableOfArrayToObject packageFragments, ICompilationUnit[] workingCopies, Map rootToResolvedEntries)", "signatureAfterChange": "  \tpublic NameLookup(IPackageFragmentRoot[] packageFragmentRoots, HashtableOfArrayToObject packageFragments, ICompilationUnit[] workingCopies, Map rootToResolvedEntries)", "diff": ["-\t\t\t\tICompilationUnit unitToLookInside = workingCopies[i];", "-\t\t\t\tICompilationUnit original = unitToLookInside.getPrimary();", "-\t\t\t\tthis.unitsToLookInside.put(original, unitToLookInside);", "+\t\t\t\tICompilationUnit workingCopy = workingCopies[i];", "+\t\t\t\tPackageFragment pkg = (PackageFragment) workingCopy.getParent();", "+\t\t\t\tHashMap typeMap = (HashMap) this.unitsToLookInside.get(pkg);", "+\t\t\t\tif (typeMap == null) {", "+\t\t\t\t\ttypeMap = new HashMap();", "+\t\t\t\t\tthis.unitsToLookInside.put(pkg, typeMap);", "+\t\t\t\t}", "+\t\t\t\ttry {", "+\t\t\t\t\tIType[] types = workingCopy.getTypes();", "+\t\t\t\t\tfor (int j = 0, typeLength = types.length; j < typeLength; j++) {", "+\t\t\t\t\t\tIType type = types[j];", "+\t\t\t\t\t\tString typeName = type.getElementName();", "+\t\t\t\t\t\tObject existing = typeMap.get(typeName);", "+\t\t\t\t\t\tif (existing == null) {", "+\t\t\t\t\t\t\ttypeMap.put(typeName, type);", "+\t\t\t\t\t\t} else if (existing instanceof IType) {", "+\t\t\t\t\t\t\ttypeMap.put(typeName, new IType[] {(IType) existing, type});", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tIType[] existingTypes = (IType[]) existing;", "+\t\t\t\t\t\t\tint existingTypeLength = existingTypes.length;", "+\t\t\t\t\t\t\tSystem.arraycopy(existingTypes, 0, existingTypes = new IType[existingTypeLength+1], 0, existingTypeLength);", "+\t\t\t\t\t\t\texistingTypes[length] = type;", "+\t\t\t\t\t\t\ttypeMap.put(typeName, existingTypes);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t// working copy doesn't exist -> ignore", "+\t\t\t\t}", "-\t\t\t\tPackageFragment pkg = (PackageFragment) unitToLookInside.getParent();", "+\t\t\t\t// add root of package fragment to cache"]}], "num": 51422}