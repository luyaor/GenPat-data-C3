{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cbe603c9ecf48074a121dcc5e63df238", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "14b23b94d223a54491b62ed3e7e4b57d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PotentialMatch.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic void locateMatchesInClassFile() throws CoreException", "signatureAfterChange": " public void locateMatchesInClassFile() throws CoreException", "diff": ["-\t */", "-\tpublic void locateMatchesInClassFile() throws CoreException {", "-\t\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.openable;", "-\t\tIBinaryType info = this.locator.getBinaryInfo(classFile, this.resource);", "-\t\tif (info == null) ", "-\t\t\treturn; // unable to go further", "-\t", "-\t\t// check class definition", "-\t\tBinaryType binaryType = (BinaryType)classFile.getType();", "-\t\tif (this.locator.pattern.matchesBinary(info, null)) {", "-\t\t\tthis.locator.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);", "-\t\t}", "-\t", "-\t\tboolean compilationAborted = false;", "-\t\tif (this.locator.pattern.mustResolve) {", "-\t\t\t// resolve", "-\t\t\tBinaryTypeBinding binding = null;", "-\t\t\t\tbinding = this.locator.cacheBinaryType(binaryType);", "-\t\t\t\tif (binding != null) {", "-\t\t\t\t\t// filter out element not in hierarchy scope", "-\t\t\t\t\tif (!this.locator.typeInHierarchy(binding)) {", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\t}", "-\t\t", "-\t\t\t\t\t// check methods", "-\t\t\t\t\tMethodBinding[] methods = binding.methods();", "-\t\t\t\t\tfor (int i = 0; i < methods.length; i++) {", "-\t\t\t\t\t\tMethodBinding method = methods[i];", "-\t\t\t\t\t\tint level = this.locator.pattern.matchLevel(method);", "-\t\t\t\t\t\tswitch (level) {", "-\t\t\t\t\t\t\tcase SearchPattern.IMPOSSIBLE_MATCH:", "-\t\t\t\t\t\t\tcase SearchPattern.INACCURATE_MATCH:", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\tIMethod methodHandle = ", "-\t\t\t\t\t\t\t\t\tbinaryType.getMethod(", "-\t\t\t\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),", "-\t\t\t\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.'))", "-\t\t\t\t\t\t\t\t\t);", "-\t\t\t\t\t\t\t\tthis.locator.reportBinaryMatch(", "-\t\t\t\t\t\t\t\t\tmethodHandle, ", "-\t\t\t\t\t\t\t\t\tinfo, ", "-\t\t\t\t\t\t\t\t\tlevel == SearchPattern.ACCURATE_MATCH ? ", "-\t\t\t\t\t\t\t\t\t\tIJavaSearchResultCollector.EXACT_MATCH : ", "-\t\t\t\t\t\t\t\t\t\tIJavaSearchResultCollector.POTENTIAL_MATCH);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t", "-\t\t\t\t\t// check fields", "-\t\t\t\t\tFieldBinding[] fields = binding.fields();", "-\t\t\t\t\tfor (int i = 0; i < fields.length; i++) {", "-\t\t\t\t\t\tFieldBinding field = fields[i];", "-\t\t\t\t\t\tint level = this.locator.pattern.matchLevel(field);", "-\t\t\t\t\t\tswitch (level) {", "-\t\t\t\t\t\t\tcase SearchPattern.IMPOSSIBLE_MATCH:", "-\t\t\t\t\t\t\tcase SearchPattern.INACCURATE_MATCH:", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));", "-\t\t\t\t\t\t\t\tthis.locator.reportBinaryMatch(", "-\t\t\t\t\t\t\t\t\tfieldHandle, ", "-\t\t\t\t\t\t\t\t\tinfo, ", "-\t\t\t\t\t\t\t\t\tlevel == SearchPattern.ACCURATE_MATCH ? ", "-\t\t\t\t\t\t\t\t\t\tIJavaSearchResultCollector.EXACT_MATCH : ", "-\t\t\t\t\t\t\t\t\t\tIJavaSearchResultCollector.POTENTIAL_MATCH);", "-\t\t\t\t\t\t}", "+ */", "+public void locateMatchesInClassFile() throws CoreException {", "+\tMatchLocator locator = this.matchingNodeSet.locator;", "+\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile) this.openable;", "+\tIBinaryType info = locator.getBinaryInfo(classFile, this.resource);", "+\tif (info == null) return; // unable to go further", "+", "+\t// check class definition", "+\tSearchPattern pattern = locator.pattern;", "+\tBinaryType binaryType = (BinaryType) classFile.getType();", "+\tif (pattern.matchesBinary(info, null))", "+\t\tlocator.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);", "+", "+\tint accuracy = IJavaSearchResultCollector.EXACT_MATCH;", "+\tif (pattern.mustResolve) {", "+\t\ttry {", "+\t\t\tBinaryTypeBinding binding = locator.cacheBinaryType(binaryType);", "+\t\t\tif (binding != null) {", "+\t\t\t\t// filter out element not in hierarchy scope", "+\t\t\t\tif (!locator.typeInHierarchy(binding)) return;", "+", "+\t\t\t\tMethodBinding[] methods = binding.methods();", "+\t\t\t\tfor (int i = 0, l = methods.length; i < l; i++) {", "+\t\t\t\t\tMethodBinding method = methods[i];", "+\t\t\t\t\tint level = pattern.matchLevel(method);", "+\t\t\t\t\tif (level >= SearchPattern.POTENTIAL_MATCH) {", "+\t\t\t\t\t\tIMethod methodHandle = binaryType.getMethod(", "+\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),", "+\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.')));", "+\t\t\t\t\t\tlocator.reportBinaryMatch(", "+\t\t\t\t\t\t\tmethodHandle, ", "+\t\t\t\t\t\t\tinfo, ", "+\t\t\t\t\t\t\tlevel == SearchPattern.ACCURATE_MATCH", "+\t\t\t\t\t\t\t\t? IJavaSearchResultCollector.EXACT_MATCH", "+\t\t\t\t\t\t\t\t: IJavaSearchResultCollector.POTENTIAL_MATCH);", "-\t\t\t} catch (AbortCompilation e) {", "-\t\t\t\tbinding = null;", "+", "+\t\t\t\tFieldBinding[] fields = binding.fields();", "+\t\t\t\tfor (int i = 0, l = fields.length; i < l; i++) {", "+\t\t\t\t\tFieldBinding field = fields[i];", "+\t\t\t\t\tint level = pattern.matchLevel(field);", "+\t\t\t\t\tif (level >= SearchPattern.POTENTIAL_MATCH) {", "+\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));", "+\t\t\t\t\t\tlocator.reportBinaryMatch(", "+\t\t\t\t\t\t\tfieldHandle, ", "+\t\t\t\t\t\t\tinfo, ", "+\t\t\t\t\t\t\tlevel == SearchPattern.ACCURATE_MATCH", "+\t\t\t\t\t\t\t\t? IJavaSearchResultCollector.EXACT_MATCH", "+\t\t\t\t\t\t\t\t: IJavaSearchResultCollector.POTENTIAL_MATCH);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+", "+\t\t\t\t// no need to check binary info since resolve was successful", "+\t\t\t\treturn;", "-\t", "-\t\t\t// no need to check binary info if resolve was successful", "-\t\t\tcompilationAborted = binding == null;", "-\t\t\tif (!compilationAborted) return;", "+\t\t} catch (AbortCompilation e) { // if compilation was aborted it is a problem with the class path", "-\t", "-\t\t// if compilation was aborted it is a problem with the class path: ", "-\t\t// report as a potential match if binary info matches the pattern", "-\t\tint accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;", "-\t\t", "-\t\t// check methods", "-\t\tIBinaryMethod[] methods = info.getMethods();", "-\t\tint length = methods == null ? 0 : methods.length;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tIBinaryMethod method = methods[i];", "-\t\t\tif (this.locator.pattern.matchesBinary(method, info)) {", "-\t\t\t\tIMethod methodHandle = ", "-\t\t\t\t\tbinaryType.getMethod(", "-\t\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),", "-\t\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))", "-\t\t\t\t\t);", "-\t\t\t\tthis.locator.reportBinaryMatch(methodHandle, info, accuracy);", "-\t\t\t}", "-\t\t}", "-\t", "-\t\t// check fields", "-\t\tIBinaryField[] fields = info.getFields();", "-\t\tlength = fields == null ? 0 : fields.length;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tIBinaryField field = fields[i];", "-\t\t\tif (this.locator.pattern.matchesBinary(field, info)) {", "-\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));", "-\t\t\t\tthis.locator.reportBinaryMatch(fieldHandle, info, accuracy);", "-\t\t\t}", "-\t\t}", "-\t}", "+\t\t// report as a potential match if binary info matches the pattern\t\t", "+\t\taccuracy = IJavaSearchResultCollector.POTENTIAL_MATCH;", "+\tIBinaryMethod[] methods = info.getMethods();", "+\tif (methods != null) {", "+\t\tfor (int i = 0, l = methods.length; i < l; i++) {", "+\t\t\tIBinaryMethod method = methods[i];", "+\t\t\tif (pattern.matchesBinary(method, info)) {", "+\t\t\t\tIMethod methodHandle = binaryType.getMethod(", "+\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),", "+\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.')));", "+\t\t\t\tlocator.reportBinaryMatch(methodHandle, info, accuracy);", "+\t\t\t}", "+\t\t}", "+\t}", "+", "+\tIBinaryField[] fields = info.getFields();", "+\tif (fields != null) {", "+\t\tfor (int i = 0, l = fields.length; i < l; i++) {", "+\t\t\tIBinaryField field = fields[i];", "+\t\t\tif (pattern.matchesBinary(field, info)) {", "+\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));", "+\t\t\t\tlocator.reportBinaryMatch(fieldHandle, info, accuracy);", "+\t\t\t}", "+\t\t}", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "17b3ed23ba977b21cc4dbfc8b07c9c3e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ConstantPool.java", "commitBeforeChange": "3413778e1bd5154fc1bb3b2fe41a2f5c159f06ae", "commitAfterChange": "b6700c6040587d6a407e0aa87172122e678ac070", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic IConstantPoolEntry decodeEntry(int index)", "signatureAfterChange": " \tpublic IConstantPoolEntry decodeEntry(int index)", "diff": ["-\t\tthis.constantPoolEntry.reset();", "+\t\tConstantPoolEntry constantPoolEntry = new ConstantPoolEntry();", "+\t\tconstantPoolEntry.reset();", "-\t\tthis.constantPoolEntry.setKind(kind);", "+\t\tconstantPoolEntry.setKind(kind);", "-\t\t\t\tthis.constantPoolEntry.setClassInfoNameIndex(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "-\t\t\t\tthis.constantPoolEntry.setClassInfoName(getUtf8ValueAt(this.constantPoolEntry.getClassInfoNameIndex()));", "+\t\t\t\tconstantPoolEntry.setClassInfoNameIndex(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "+\t\t\t\tconstantPoolEntry.setClassInfoName(getUtf8ValueAt(constantPoolEntry.getClassInfoNameIndex()));", "-\t\t\t\tthis.constantPoolEntry.setDoubleValue(doubleAt(classFileBytes, 1, this.constantPoolOffset[index]));", "+\t\t\t\tconstantPoolEntry.setDoubleValue(doubleAt(classFileBytes, 1, this.constantPoolOffset[index]));", "-\t\t\t\tthis.constantPoolEntry.setClassIndex(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "-\t\t\t\tint declaringClassIndex = u2At(this.classFileBytes,  1, this.constantPoolOffset[this.constantPoolEntry.getClassIndex()]);", "-\t\t\t\tthis.constantPoolEntry.setClassName(getUtf8ValueAt(declaringClassIndex));", "-\t\t\t\tthis.constantPoolEntry.setNameAndTypeIndex(u2At(this.classFileBytes,  3, this.constantPoolOffset[index]));", "-\t\t\t\tint fieldNameIndex = u2At(this.classFileBytes,  1, this.constantPoolOffset[this.constantPoolEntry.getNameAndTypeIndex()]);", "-\t\t\t\tint fieldDescriptorIndex = u2At(this.classFileBytes,  3, this.constantPoolOffset[this.constantPoolEntry.getNameAndTypeIndex()]);", "-\t\t\t\tthis.constantPoolEntry.setFieldName(getUtf8ValueAt(fieldNameIndex));", "-\t\t\t\tthis.constantPoolEntry.setFieldDescriptor(getUtf8ValueAt(fieldDescriptorIndex));", "+\t\t\t\tconstantPoolEntry.setClassIndex(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "+\t\t\t\tint declaringClassIndex = u2At(this.classFileBytes,  1, this.constantPoolOffset[constantPoolEntry.getClassIndex()]);", "+\t\t\t\tconstantPoolEntry.setClassName(getUtf8ValueAt(declaringClassIndex));", "+\t\t\t\tconstantPoolEntry.setNameAndTypeIndex(u2At(this.classFileBytes,  3, this.constantPoolOffset[index]));", "+\t\t\t\tint fieldNameIndex = u2At(this.classFileBytes,  1, this.constantPoolOffset[constantPoolEntry.getNameAndTypeIndex()]);", "+\t\t\t\tint fieldDescriptorIndex = u2At(this.classFileBytes,  3, this.constantPoolOffset[constantPoolEntry.getNameAndTypeIndex()]);", "+\t\t\t\tconstantPoolEntry.setFieldName(getUtf8ValueAt(fieldNameIndex));", "+\t\t\t\tconstantPoolEntry.setFieldDescriptor(getUtf8ValueAt(fieldDescriptorIndex));", "-\t\t\t\tthis.constantPoolEntry.setClassIndex(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "-\t\t\t\tdeclaringClassIndex = u2At(this.classFileBytes,  1, this.constantPoolOffset[this.constantPoolEntry.getClassIndex()]);", "-\t\t\t\tthis.constantPoolEntry.setClassName(getUtf8ValueAt(declaringClassIndex));", "-\t\t\t\tthis.constantPoolEntry.setNameAndTypeIndex(u2At(this.classFileBytes,  3, this.constantPoolOffset[index]));", "-\t\t\t\tint methodNameIndex = u2At(this.classFileBytes,  1, this.constantPoolOffset[this.constantPoolEntry.getNameAndTypeIndex()]);", "-\t\t\t\tint methodDescriptorIndex = u2At(this.classFileBytes,  3, this.constantPoolOffset[this.constantPoolEntry.getNameAndTypeIndex()]);", "-\t\t\t\tthis.constantPoolEntry.setMethodName(getUtf8ValueAt(methodNameIndex));", "-\t\t\t\tthis.constantPoolEntry.setMethodDescriptor(getUtf8ValueAt(methodDescriptorIndex));", "+\t\t\t\tconstantPoolEntry.setClassIndex(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "+\t\t\t\tdeclaringClassIndex = u2At(this.classFileBytes,  1, this.constantPoolOffset[constantPoolEntry.getClassIndex()]);", "+\t\t\t\tconstantPoolEntry.setClassName(getUtf8ValueAt(declaringClassIndex));", "+\t\t\t\tconstantPoolEntry.setNameAndTypeIndex(u2At(this.classFileBytes,  3, this.constantPoolOffset[index]));", "+\t\t\t\tint methodNameIndex = u2At(this.classFileBytes,  1, this.constantPoolOffset[constantPoolEntry.getNameAndTypeIndex()]);", "+\t\t\t\tint methodDescriptorIndex = u2At(this.classFileBytes,  3, this.constantPoolOffset[constantPoolEntry.getNameAndTypeIndex()]);", "+\t\t\t\tconstantPoolEntry.setMethodName(getUtf8ValueAt(methodNameIndex));", "+\t\t\t\tconstantPoolEntry.setMethodDescriptor(getUtf8ValueAt(methodDescriptorIndex));", "-\t\t\t\tthis.constantPoolEntry.setFloatValue(floatAt(classFileBytes, 1, this.constantPoolOffset[index]));", "+\t\t\t\tconstantPoolEntry.setFloatValue(floatAt(classFileBytes, 1, this.constantPoolOffset[index]));", "-\t\t\t\tthis.constantPoolEntry.setIntegerValue(i4At(classFileBytes, 1, this.constantPoolOffset[index]));", "+\t\t\t\tconstantPoolEntry.setIntegerValue(i4At(classFileBytes, 1, this.constantPoolOffset[index]));", "-\t\t\t\tthis.constantPoolEntry.setLongValue(i8At(classFileBytes, 1, this.constantPoolOffset[index]));", "+\t\t\t\tconstantPoolEntry.setLongValue(i8At(classFileBytes, 1, this.constantPoolOffset[index]));", "-\t\t\t\tthis.constantPoolEntry.setNameAndTypeNameIndex(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "-\t\t\t\tthis.constantPoolEntry.setNameAndTypeDescriptorIndex(u2At(this.classFileBytes,  3, this.constantPoolOffset[index]));", "+\t\t\t\tconstantPoolEntry.setNameAndTypeNameIndex(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "+\t\t\t\tconstantPoolEntry.setNameAndTypeDescriptorIndex(u2At(this.classFileBytes,  3, this.constantPoolOffset[index]));", "-\t\t\t\tthis.constantPoolEntry.setStringIndex(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "-\t\t\t\tthis.constantPoolEntry.setStringValue(getUtf8ValueAt(this.constantPoolEntry.getStringIndex()));", "+\t\t\t\tconstantPoolEntry.setStringIndex(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "+\t\t\t\tconstantPoolEntry.setStringValue(getUtf8ValueAt(constantPoolEntry.getStringIndex()));", "-\t\t\t\tthis.constantPoolEntry.setUtf8Length(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "-\t\t\t\tthis.constantPoolEntry.setUtf8Value(getUtf8ValueAt(index));", "+\t\t\t\tconstantPoolEntry.setUtf8Length(u2At(this.classFileBytes,  1, this.constantPoolOffset[index]));", "+\t\t\t\tconstantPoolEntry.setUtf8Value(getUtf8ValueAt(index));", "-\t\treturn this.constantPoolEntry;", "+\t\treturn constantPoolEntry;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c115973ce843e2e42c275815fdedfb9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "ef3c2078d9cee48378a186a3e9a6e61cb6a67acc", "commitAfterChange": "18c98a5a751096350077436fcf968eb63364ccb9", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-", "-\t\t} else if (((ReferenceBinding) receiverType).isFinal()) {", "-\t\t\tif (this.anonymousType != null) {", "-\t\t\t\tif (!receiverType.isEnum()) {", "-\t\t\t\t\tscope.problemReporter().anonymousClassCannotExtendFinalClass(this.type, receiverType);", "-\t\t\t\t\thasError = true;", "-\t\t\t\t}", "-\t\t\t} else if (!receiverType.canBeInstantiated()) {", "-\t\t\t\tscope.problemReporter().cannotInstantiate(this.type, receiverType);", "-\t\t\t\treturn this.resolvedType = receiverType;", "-\t\t\t}", "+\t\t\t\tReferenceBinding referenceReceiver = (ReferenceBinding) receiverType;", "-\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding) receiverType, TypeConstants.INIT, pseudoArgs, this);", "+\t\t\t\tthis.binding = scope.findMethod(referenceReceiver, TypeConstants.INIT, pseudoArgs, this);", "-\t\t\t\t", "+\t\t\t\tif (this.anonymousType != null) {", "+\t\t\t\t\t// insert anonymous type in scope (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=210070)", "+\t\t\t\t\tscope.addAnonymousType(this.anonymousType, referenceReceiver);", "+\t\t\t\t\tthis.anonymousType.resolve(scope);", "+\t\t\t\t\treturn this.resolvedType = this.anonymousType.binding;", "+\t\t\t\t}", "-", "-\t\tif (receiverType.isTypeVariable()) {", "-\t\t\treceiverType = new ProblemReferenceBinding(receiverType.sourceName(), (ReferenceBinding)receiverType, ProblemReasons.IllegalSuperTypeVariable);", "-\t\t\tscope.problemReporter().invalidType(this, receiverType);", "+\t\tReferenceBinding superType = (ReferenceBinding) receiverType;", "+\t\tif (superType.isTypeVariable()) {", "+\t\t\tsuperType = new ProblemReferenceBinding(superType.sourceName(), superType, ProblemReasons.IllegalSuperTypeVariable);", "+\t\t\tscope.problemReporter().invalidType(this, superType);", "-\t\t} else if (this.type != null && receiverType.isEnum()) { // tolerate enum constant body", "-\t\t\tscope.problemReporter().cannotInstantiate(this.type, receiverType);", "-\t\t\treturn this.resolvedType = receiverType;", "+\t\t} else if (this.type != null && superType.isEnum()) { // tolerate enum constant body", "+\t\t\tscope.problemReporter().cannotInstantiate(this.type, superType);", "+\t\t\treturn this.resolvedType = superType;", "-\t\tthis.superTypeBinding = receiverType.isInterface() ? scope.getJavaLangObject() : (ReferenceBinding) receiverType;", "+\t\tReferenceBinding anonymousSuperclass = superType.isInterface() ? scope.getJavaLangObject() : superType;", "-\t\tscope.addAnonymousType(this.anonymousType, (ReferenceBinding) receiverType);", "-\t\tthis.anonymousType.resolve(scope);\t\t", "-\t\tif (this.superTypeBinding.erasure().id == TypeIds.T_JavaLangEnum) {", "-\t\t\tscope.problemReporter().cannotExtendEnum(this.anonymousType.binding, this.type, this.superTypeBinding);", "-\t\t}", "-\t\t", "-\t\tif ((receiverType.tagBits & TagBits.HasDirectWildcard) != 0) {", "-\t\t\tscope.problemReporter().superTypeCannotUseWildcard(this.anonymousType.binding, this.type, receiverType);", "-\t\t}\t\t", "+\t\tscope.addAnonymousType(this.anonymousType, superType);", "+\t\tthis.anonymousType.resolve(scope);\t", "+\t\t\t", "-\t\tMethodBinding inheritedBinding = scope.getConstructor(this.superTypeBinding, argumentTypes, this);", "+\t\tthis.resolvedType = this.anonymousType.binding; // 1.2 change", "+\t\tif ((this.resolvedType.tagBits & TagBits.HierarchyHasProblems) != 0) {", "+\t\t\treturn null; // stop secondary errors", "+\t\t}", "+\t\tMethodBinding inheritedBinding = scope.getConstructor(anonymousSuperclass, argumentTypes, this);", "-\t\t\t\tinheritedBinding.declaringClass = this.superTypeBinding;", "+\t\t\t\tinheritedBinding.declaringClass = anonymousSuperclass;", "-\t\t\treturn this.resolvedType = this.anonymousType.binding;", "+\t\t\treturn this.resolvedType;", "-\t\t\t\tscope.problemReporter().unnecessaryEnclosingInstanceSpecification(this.enclosingInstance, (ReferenceBinding)receiverType);", "-\t\t\t\treturn this.resolvedType = this.anonymousType.binding;", "+\t\t\t\tscope.problemReporter().unnecessaryEnclosingInstanceSpecification(this.enclosingInstance, superType);", "+\t\t\t\treturn this.resolvedType;", "-\t\t\t\treturn this.resolvedType = this.anonymousType.binding;", "+\t\t\t\treturn this.resolvedType;", "-\t\tif (this.arguments != null)", "-\t\t\tcheckInvocationArguments(scope, null, this.superTypeBinding, inheritedBinding, this.arguments, argumentTypes, argsContainCast, this);", "-", "+\t\tif (this.arguments != null) {", "+\t\t\tcheckInvocationArguments(scope, null, anonymousSuperclass, inheritedBinding, this.arguments, argumentTypes, argsContainCast, this);", "+\t\t}", "-\t\treturn this.resolvedType = this.anonymousType.binding; // 1.2 change", "+\t\treturn this.resolvedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "70a7c21653f5b5ac2c563b0a52d950cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchingNodeSet.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": " public void reportMatching(CompilationUnitDeclaration unit) throws CoreException", "signatureAfterChange": " public void reportMatching(CompilationUnitDeclaration unit, boolean mustResolve) throws CoreException", "diff": ["-public void reportMatching(CompilationUnitDeclaration unit) throws CoreException {", "-\tif (this.cuHasBeenResolved) {", "+public void reportMatching(CompilationUnitDeclaration unit, boolean mustResolve) throws CoreException {", "+\tif (mustResolve) {", "-\t\tfor (Iterator potentialMatches = this.potentialMatchingNodes.keySet().iterator(); potentialMatches.hasNext();) {", "-\t\t\tAstNode node = (AstNode) potentialMatches.next();", "-\t\t\tint level;", "+\t\tObject[] nodes = this.potentialMatchingNodesSet.values;", "+\t\tfor (int i = 0, l = nodes.length; i < l; i++) {", "+\t\t\tAstNode node = (AstNode) nodes[i];", "+\t\t\tif (node == null) continue;", "-\t\t\t\tlevel = this.locator.pattern.matchLevel(node, true);", "-\t\t\t\tif (level == SearchPattern.ACCURATE_MATCH || level == SearchPattern.INACCURATE_MATCH) {", "-\t\t\t\t\tthis.matchingNodes.put(node, new Integer(level));", "-\t\t\t\t}", "+\t\t\t\tint level = this.locator.pattern.matchLevel(node, true);", "+\t\t\t\tif (level == SearchPattern.ACCURATE_MATCH)", "+\t\t\t\t\tthis.matchingNodes.put(node, EXACT_MATCH);", "+\t\t\t\telse if (level == SearchPattern.INACCURATE_MATCH)", "+\t\t\t\t\tthis.matchingNodes.put(node, POTENTIAL_MATCH);", "-\t\tthis.potentialMatchingNodes = new HashMap();", "+\t\tthis.potentialMatchingNodesSet = new SimpleSet();", "-\t", "-\t// package declaration", "+", "+\tif (this.matchingNodes.elementSize == 0) return; // no matching nodes were found", "+", "-\tInteger level;", "-\tif (pkg != null && (level = (Integer)this.matchingNodes.remove(pkg)) != null) {", "-\t\tif ((this.matchContainer & SearchPattern.COMPILATION_UNIT) != 0) {", "+\tif (pkg != null && this.matchingNodes.removeKey(pkg) != null)", "+\t\tif ((this.matchContainer & SearchPattern.COMPILATION_UNIT) != 0)", "+", "+\tImportReference[] imports = unit.imports;", "+\tif (imports != null) {", "+\t\tfor (int i = 0, l = imports.length; i < l; i++) {", "+\t\t\tImportReference importRef = imports[i];", "+\t\t\tInteger level = (Integer) this.matchingNodes.removeKey(importRef);", "+\t\t\tif (level != null && (this.matchContainer & SearchPattern.COMPILATION_UNIT) != 0)", "+\t\t\t\tthis.locator.reportImport(importRef, level.intValue());", "-\t// import declarations", "-\tif (!this.cuHasBeenResolved) {", "-\t\tImportReference[] imports = unit.imports;", "-\t\tif (imports != null) {", "-\t\t\tfor (int i = 0; i < imports.length; i++) {", "-\t\t\t\tImportReference importRef = imports[i];", "-\t\t\t\tif ((level = (Integer)this.matchingNodes.remove(importRef)) != null) {", "-\t\t\t\t\tif ((this.matchContainer & SearchPattern.COMPILATION_UNIT) != 0) {", "-\t\t\t\t\t\tthis.locator.reportImport(", "-\t\t\t\t\t\t\timportRef, ", "-\t\t\t\t\t\t\tlevel.intValue() == SearchPattern.ACCURATE_MATCH ?", "-\t\t\t\t\t\t\t\tIJavaSearchResultCollector.EXACT_MATCH :", "-\t\t\t\t\t\t\t\tIJavaSearchResultCollector.POTENTIAL_MATCH);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t} // else import declarations have already been processed above", "-", "-\t// types", "-\t\tfor (int i = 0; i < types.length; i++) {", "+\t\tfor (int i = 0, l = types.length; i < l; i++) {", "+\t\t\tif (this.matchingNodes.elementSize == 0) return; // reported all the matching nodes", "-\t\t\tif ((level = (Integer)this.matchingNodes.remove(type)) != null) {", "-\t\t\t\tif ((this.matchContainer & SearchPattern.COMPILATION_UNIT) != 0) {", "-\t\t\t\t\tthis.locator.reportTypeDeclaration(", "-\t\t\t\t\t\ttype, ", "-\t\t\t\t\t\tnull, ", "-\t\t\t\t\t\tlevel.intValue() == SearchPattern.ACCURATE_MATCH ?", "-\t\t\t\t\t\t\tIJavaSearchResultCollector.EXACT_MATCH :", "-\t\t\t\t\t\t\tIJavaSearchResultCollector.POTENTIAL_MATCH);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tthis.reportMatching(type, null);", "+\t\t\tInteger level = (Integer) this.matchingNodes.removeKey(type);", "+\t\t\tif (level != null && (this.matchContainer & SearchPattern.COMPILATION_UNIT) != 0)", "+\t\t\t\tthis.locator.reportTypeDeclaration(type, null, level.intValue());", "+\t\t\treportMatching(type, null);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7eb52b298a31e852dd202b415abc6147", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PackageReferenceLocator.java", "commitBeforeChange": "309be04a155363e9f398875d6734d13ff5334b6c", "commitAfterChange": "6b58c2063066f4462a27490669b336c2263fae86", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": " protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "diff": ["-\tchar[][] tokens = null;", "+\tlong[] positions = null;", "+\tint last = -1;", "-\t\tif (importRef.onDemand) {", "-\t\t\ttokens = importRef.tokens;", "-\t\t} else {", "-\t\t\tint length = importRef.tokens.length - 1;", "-\t\t\ttokens = new char[length][];", "-\t\t\tSystem.arraycopy(importRef.tokens, 0, tokens, 0, length);", "-\t\t}", "-\t} else if (reference instanceof QualifiedNameReference) {", "-\t\tQualifiedNameReference qNameRef = (QualifiedNameReference) reference;", "-\t\tBinding binding = qNameRef.binding;", "+\t\tpositions = importRef.sourcePositions;", "+\t\tlast = importRef.onDemand ? positions.length : positions.length - 1;", "+\t} else {", "-\t\tswitch (qNameRef.bits & AstNode.RestrictiveFlagMASK) {", "-\t\t\tcase BindingIds.FIELD : // reading a field", "-\t\t\t\ttypeBinding = qNameRef.actualReceiverType;", "-\t\t\t\tbreak;", "-\t\t\tcase BindingIds.TYPE : //=============only type ==============", "-\t\t\t\tif (binding instanceof ProblemBinding) {", "-\t\t\t\t\tProblemBinding pbBinding = (ProblemBinding) binding;", "-\t\t\t\t\ttypeBinding = pbBinding.searchType; // second chance with recorded type so far", "-\t\t\t\t} else {", "-\t\t\t\t\ttypeBinding = (TypeBinding) binding;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase BindingIds.VARIABLE : //============unbound cases===========", "-\t\t\tcase BindingIds.TYPE | BindingIds.VARIABLE :\t\t\t\t\t\t", "-\t\t\t\tif (binding instanceof ProblemBinding) {", "-\t\t\t\t\tProblemBinding pbBinding = (ProblemBinding) binding;", "-\t\t\t\t\ttypeBinding = pbBinding.searchType; // second chance with recorded type so far", "-\t\t\t\t}", "-\t\t\t\tbreak;", "+\t\tif (reference instanceof QualifiedNameReference) {", "+\t\t\tQualifiedNameReference qNameRef = (QualifiedNameReference) reference;", "+\t\t\tpositions = qNameRef.sourcePositions;", "+\t\t\tswitch (qNameRef.bits & AstNode.RestrictiveFlagMASK) {", "+\t\t\t\tcase BindingIds.FIELD : // reading a field", "+\t\t\t\t\ttypeBinding = qNameRef.actualReceiverType;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase BindingIds.TYPE : //=============only type ==============", "+\t\t\t\t\tif (qNameRef.binding instanceof TypeBinding)", "+\t\t\t\t\t\ttypeBinding = (TypeBinding) qNameRef.binding;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase BindingIds.VARIABLE : //============unbound cases===========", "+\t\t\t\tcase BindingIds.TYPE | BindingIds.VARIABLE :", "+\t\t\t\t\tBinding binding = qNameRef.binding; ", "+\t\t\t\t\tif (binding instanceof TypeBinding) {", "+\t\t\t\t\t\ttypeBinding = (TypeBinding) binding;", "+\t\t\t\t\t} else if (binding instanceof ProblemFieldBinding) {", "+\t\t\t\t\t\ttypeBinding = qNameRef.actualReceiverType;", "+\t\t\t\t\t\tlast = qNameRef.tokens.length - (qNameRef.otherBindings == null ? 2 : qNameRef.otherBindings.length + 2);", "+\t\t\t\t\t} else if (binding instanceof ProblemBinding) {", "+\t\t\t\t\t\tProblemBinding pbBinding = (ProblemBinding) binding;", "+\t\t\t\t\t\ttypeBinding = pbBinding.searchType;", "+\t\t\t\t\t\tlast = CharOperation.occurencesOf('.', pbBinding.name);", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;\t\t\t\t\t", "+\t\t\t}", "+\t\t} else if (reference instanceof QualifiedTypeReference) {", "+\t\t\tQualifiedTypeReference qTypeRef = (QualifiedTypeReference) reference;", "+\t\t\tpositions = qTypeRef.sourcePositions;", "+\t\t\ttypeBinding = qTypeRef.resolvedType;", "-\t\tif (typeBinding instanceof ReferenceBinding) {", "-\t\t\tPackageBinding pkgBinding = ((ReferenceBinding) typeBinding).fPackage;", "-\t\t\tif (pkgBinding != null)", "-\t\t\t\ttokens = pkgBinding.compoundName;", "-\t\t} ", "-\t\tif (tokens == null)", "-\t\t\ttokens = qNameRef.tokens;", "-\t} else if (reference instanceof QualifiedTypeReference) {", "-\t\tQualifiedTypeReference qTypeRef = (QualifiedTypeReference) reference;", "-\t\tTypeBinding typeBinding = qTypeRef.resolvedType;", "-\t\t\ttypeBinding = ((ArrayBinding)typeBinding).leafComponentType;", "+\t\t\ttypeBinding = ((ArrayBinding) typeBinding).leafComponentType;", "+\t\tif (typeBinding instanceof ProblemReferenceBinding)", "+\t\t\ttypeBinding = ((ProblemReferenceBinding) typeBinding).original;", "-\t\t\t\ttokens = pkgBinding.compoundName;", "-\t\t} ", "-\t\tif (tokens == null)", "-\t\t\ttokens = qTypeRef.tokens;", "+\t\t\t\tlast = pkgBinding.compoundName.length;", "+\t\t}", "-\tif (tokens == null)", "-\t\ttokens = CharOperation.NO_CHAR_CHAR;", "-\tlocator.reportAccurateReference(reference.sourceStart, reference.sourceEnd, tokens, element, accuracy);", "+\tif (last == -1) {", "+\t\tlast = this.pattern.segments.length;", "+\t\tif (last > positions.length) last = positions.length;", "+\t}", "+\tlocator.report(positions[0], positions[last - 1], element, accuracy);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9b81025f175d51e92ff38e3e05584e26", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "c62ecfd031507c11ea236866605fedd6f3a952c5", "commitAfterChange": "ded73445e8c5cf2db0a4abcc53e1680f02ae6cf7", "methodNumberBeforeChange": 122, "methodNumberAfterChange": 122, "signatureBeforeChange": " \tpublic boolean visit(SwitchStatement switchStatement, BlockScope scope)", "signatureAfterChange": " \tpublic boolean visit(SwitchStatement switchStatement, BlockScope scope)", "diff": ["-", "-\t\tif (this.preferences.indent_switchstatements_compare_to_switch) {", "-\t\t\tthis.scribe.indent();", "-\t\t}", "+\t\tint switchIndentationLevel = this.scribe.indentationLevel;", "+\t\tint caseIndentation = 0;", "+\t\tint statementIndentation = 0;", "+\t\tint breakIndentation = 0;", "+\t\tif (this.preferences.indent_switchstatements_compare_to_switch) {", "+\t\t\tcaseIndentation++;", "+\t\t\tstatementIndentation++;", "+\t\t\tbreakIndentation++;", "+\t\t}", "+\t\tif (this.preferences.indent_switchstatements_compare_to_cases) {", "+\t\t\tstatementIndentation++;", "+\t\t}", "+\t\tif (this.preferences.indent_breaks_compare_to_cases) {", "+\t\t\tbreakIndentation++;", "+\t\t}", "-\t\tboolean wasAStatement = false;", "+\t\tboolean wasABreak = false;", "+\t\t\t\t\tif (wasABreak) {", "+\t\t\t\t\t\tthis.scribe.setIndentation(switchIndentationLevel, caseIndentation);", "+\t\t\t\t\t\tthis.scribe.printComment();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (wasACase) {", "+\t\t\t\t\t\t\tthis.scribe.printComment(Scribe.PRESERVE_EMPTY_LINES_IN_SWITCH_CASE);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.scribe.printComment();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.scribe.setIndentation(switchIndentationLevel, caseIndentation);", "+\t\t\t\t\t}", "-\t\t\t\t\tif ((wasACase && this.preferences.indent_switchstatements_compare_to_cases)", "-\t\t\t\t\t\t|| (wasAStatement && this.preferences.indent_switchstatements_compare_to_cases)) {", "-\t\t\t\t\t\tthis.scribe.unIndent();", "-\t\t\t\t\t}", "-\t\t\t\t\twasACase = true;", "-\t\t\t\t\twasAStatement = false;", "-\t\t\t\t\tif (this.preferences.indent_switchstatements_compare_to_cases) {", "-\t\t\t\t\t\tthis.scribe.indent();", "-\t\t\t\t\t}", "+\t\t\t\t\t// Print following trailing (if any) comment at statement indentation", "+\t\t\t\t\tthis.scribe.setIndentation(switchIndentationLevel, statementIndentation);", "+\t\t\t\t\twasACase = true;", "+\t\t\t\t\twasABreak = false;", "-\t\t\t\t\tif (this.preferences.indent_breaks_compare_to_cases) {", "-\t\t\t\t\t\tif (wasAStatement && !this.preferences.indent_switchstatements_compare_to_cases) {", "-\t\t\t\t\t\t\tthis.scribe.indent();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (wasAStatement) {", "-\t\t\t\t\t\t\tif (this.preferences.indent_switchstatements_compare_to_cases) {", "-\t\t\t\t\t\t\t\tthis.scribe.unIndent();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (wasACase && this.preferences.indent_switchstatements_compare_to_cases) {", "-\t\t\t\t\t\t\tthis.scribe.unIndent();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.setIndentation(switchIndentationLevel, breakIndentation);", "+\t\t\t\t\tthis.scribe.printComment();", "-\t\t\t\t\tif (this.preferences.indent_breaks_compare_to_cases) {", "-\t\t\t\t\t\tthis.scribe.unIndent();", "-\t\t\t\t\t}", "-\t\t\t\t\twasAStatement = false;", "+\t\t\t\t\twasABreak = true;", "-\t\t\t\t\tString bracePosition;", "-\t\t\t\t\tif (wasACase) {", "-\t\t\t\t\t\tif (this.preferences.indent_switchstatements_compare_to_cases) {", "-\t\t\t\t\t\t\tthis.scribe.unIndent();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbracePosition =\tthis.preferences.brace_position_for_block_in_case;", "-\t\t\t\t\t\tformatBlock((Block) statement, scope, bracePosition, this.preferences.insert_space_after_colon_in_case);", "-\t\t\t\t\t\tif (this.preferences.indent_switchstatements_compare_to_cases) {", "-\t\t\t\t\t\t\tthis.scribe.indent();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tbracePosition =\tthis.preferences.brace_position_for_block;", "-\t\t\t\t\t\tformatBlock((Block) statement, scope, bracePosition, this.preferences.insert_space_before_opening_brace_in_block);", "-\t\t\t\t\t}", "-\t\t\t\t\twasAStatement = true;", "+\t\t\t\t\tthis.scribe.setIndentation(switchIndentationLevel, wasACase ? caseIndentation : statementIndentation);", "+\t\t\t\t\tthis.scribe.printComment();", "+\t\t\t\t\tString bracePosition = wasACase ? this.preferences.brace_position_for_block_in_case : this.preferences.brace_position_for_block;", "+\t\t\t\t\tformatBlock((Block) statement, scope, bracePosition, this.preferences.insert_space_before_opening_brace_in_block);", "+\t\t\t\t\twasABreak = false;", "+\t\t\t\t\tthis.scribe.setIndentation(switchIndentationLevel, statementIndentation);", "+\t\t\t\t\tthis.scribe.printComment();", "-\t\t\t\t\twasAStatement = true;", "+\t\t\t\t\twasABreak = false;", "-\t\t\t\tthis.scribe.printComment();", "-", "-\t\tif ((wasACase || wasAStatement) && this.preferences.indent_switchstatements_compare_to_cases) {", "-\t\t\tthis.scribe.unIndent();", "-\t\t}", "-\t\tif (this.preferences.indent_switchstatements_compare_to_switch) {", "-\t\t\tthis.scribe.unIndent();", "-\t\t}", "+\t\tif (wasABreak) {", "+\t\t\tthis.scribe.setIndentation(switchIndentationLevel, 0);", "+\t\t\tthis.scribe.printComment();", "+\t\t} else {", "+\t\t\tthis.scribe.printComment();", "+\t\t\tthis.scribe.setIndentation(switchIndentationLevel, 0);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f4b19b2af59e32e7b596f0666f5655c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "cee242bcb21b999953c5459d6b40de2d782355f3", "commitAfterChange": "de0ba5a5e09b42f4671d55cb69260aca34e3da86", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tprotected boolean parseReference(boolean plain) throws InvalidInputException", "signatureAfterChange": " \tprotected boolean parseReference(boolean plain) throws InvalidInputException", "diff": ["+\t\tint typeRefStartPosition = -1;", "-\t\t\t\tcase TerminalTokens.TokenNameStringLiteral :", "-\t\t\t\t\t// @see \"string\"", "+\t\t\t\tcase TerminalTokens.TokenNameStringLiteral : // @see \"string\"", "-\t\t\t\t\tif (typeRef == null) {", "-\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\twhile (Character.isWhitespace(this.source[this.index])) {", "-\t\t\t\t\t\t\tif (this.source[this.index] == '\\r' || this.source[this.index] == '\\n') {", "-\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) {", "-\t\t\t\t\t\t\t\t\tparseTag();", "-\t\t\t\t\t\t\t\t\tpushText(previousPosition, this.index);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthis.index++;", "-\t\t\t\t\t\t}", "+\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t}", "+\t\t\t\t\t// verify end line (expecting empty or end comment)", "+\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\treturn true;", "-\t\t\t\tcase TerminalTokens.TokenNameLESS :", "-\t\t\t\t\t// @see \"<a href=\"URL#Value\">label</a>", "+\t\t\t\tcase TerminalTokens.TokenNameLESS : // @see \"<a href=\"URL#Value\">label</a>", "-\t\t\t\t\t\tif (typeRef == null) {", "-\t\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\t\twhile (Character.isWhitespace(this.source[this.index])) {", "-\t\t\t\t\t\t\t\tif (this.source[this.index] == '\\r' || this.source[this.index] == '\\n') {", "-\t\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) {", "-\t\t\t\t\t\t\t\t\t\tparseTag();", "-\t\t\t\t\t\t\t\t\t\tpushText(previousPosition, this.index);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tthis.index++;", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "+\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\ttypeRefStartPosition = this.scanner.getCurrentTokenStartPosition();", "-\t\t// Verify that line end does not start with an open parenthese (which could be a constructor reference wrongly written...)", "-\t\t// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=47215", "-\t\tint start = this.scanner.getCurrentTokenStartPosition();", "-\t\ttry {", "-\t\t\tint token = readToken();", "-\t\t\tif (token != TerminalTokens.TokenNameLPAREN) {", "-\t\t\t\t// Reset position: we want to rescan last token", "-\t\t\t\tif (this.currentTokenType != -1) {", "-\t\t\t\t\tthis.index = this.tokenPreviousPosition;", "-\t\t\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "-\t\t\t\t\tthis.currentTokenType = -1;", "-\t\t\t\t}", "-\t\t\t\treturn pushSeeRef(reference, plain);", "-\t\t\t}", "-\t\t} catch (InvalidInputException e) {", "-\t\t\t// Do nothing as we report an error after", "-\t\t}", "-\t\t// Reset position to avoid missing tokens when new line was encountered", "-\t\tthis.index = this.tokenPreviousPosition;", "-\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t// Reset position at the end of type reference", "+\t\tthis.index = this.lastIdentifierEndPosition+1;", "+\t\tthis.scanner.currentPosition = this.index;", "-\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidSeeReference(start, this.lineEnd);", "-\t\treturn false;", "+", "+\t\t// Verify that line end does not start with an open parenthese (which could be a constructor reference wrongly written...)", "+\t\t// See bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=47215", "+\t\tchar ch = peekChar();", "+\t\tif (ch == '(') {", "+\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingHashCharacter(typeRefStartPosition, this.lineEnd, String.valueOf(this.source, typeRefStartPosition, this.lineEnd-typeRefStartPosition));", "+\t\t\treturn false;", "+\t\t}", "+", "+\t\t// Verify that we get white space after reference", "+\t\tif (!verifySpaceOrEndComment()) {", "+\t\t\tthis.index = this.tokenPreviousPosition;", "+\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t\tthis.currentTokenType = -1;", "+\t\t\tint end = this.starPosition == -1 ? this.lineEnd : this.starPosition;", "+\t\t\tif (this.source[end]=='\\n') end--;", "+\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMalformedSeeReference(typeRefStartPosition, end);", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\t// Everything is OK, store reference", "+\t\treturn pushSeeRef(reference, plain);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cbab33ea9983252b5105a8b85aa0dc19", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java", "commitBeforeChange": "372799d5bd955eabbf1069fe0bbf8aba8ea8af85", "commitAfterChange": "baf433f0226e8b9036b18a28d560e5a42cb8b949", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 11, "signatureBeforeChange": " \t \tprivate APTResult runAPT( \t\t\tfinal List<AnnotationProcessorFactory> factories, \t\t\tfinal ProcessorEnvImpl processorEnv)", "signatureAfterChange": " \t \tprivate APTResult runAPT( \t\t\tfinal List<AnnotationProcessorFactory> factories, \t\t\tfinal ProcessorEnvImpl processorEnv)", "diff": ["-\t\t\t\t", "+\t\t\t// TODO: put the short circuit back in!!! (theodora)", "+\t\t\t/*\t\t\t", "-\t\t", "-\t\t\tfinal Map<String, AnnotationTypeDeclaration> annotationDecls = getAnnotationTypeDeclarations(", "-\t\t\t\t\tprocessorEnv.getAstCompilationUnit(), processorEnv);", "-\t\t\t", "-\t\t\tif (annotationDecls.isEmpty())", "-\t\t\t{", "-\t\t\t\tif ( AptPlugin.DEBUG ) trace( \"runAPT:  leaving early because annotationDecls is empty\" ); //$NON-NLS-1$", "-\t\t\t\treturn EMPTY_APT_RESULT;", "-\t\t\t}", "-", "+\t\t*/", "-\t\t\tSet<IFile> lastGeneratedFiles = gfm.getGeneratedFilesForParent( processorEnv.getFile() );", "-\t\t\t", "-\t\t\tfor (int i = 0, size = factories.size(); i < size; i++) {", "-\t\t\t\tfinal AnnotationProcessorFactory factory = factories.get(i);", "-\t\t\t\tSet<AnnotationTypeDeclaration> factoryDecls = getAnnotations(factory, annotationDecls);", "-\t\t\t\tboolean done = false;", "-\t\t\t\tif( factoryDecls != null ){", "-\t\t\t\t\tif(factoryDecls.size() == 0 ){", "-\t\t\t\t\t\tdone = true;", "-\t\t\t\t\t\tfactoryDecls = new HashSet(annotationDecls.values());", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (factoryDecls != null && factoryDecls.size() > 0) {", "-\t\t\t\t\tfinal AnnotationProcessor processor = factory", "-\t\t\t\t\t\t\t.getProcessorFor(factoryDecls, processorEnv);", "-\t\t\t\t\tif (processor != null)", "-\t\t\t\t\t{", "-\t\t\t\t\t\tif ( AptPlugin.DEBUG ) trace( \"runAPT: invoking processor \" + processor.getClass().getName() ); //$NON-NLS-1$", "-                        processorEnv.setLatestProcessor(processor);", "-\t\t\t\t\t\tprocessor.process();", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\tif (annotationDecls.isEmpty() || done)", "-\t\t\t\t\tbreak;", "+\t\t\tfinal Set<IFile> lastGeneratedFiles = new HashSet<IFile>();", "+\t\t\tfor( int i=0, len=_filesToProcess.length; i<len; i++ ){", "+\t\t\t\tfinal Set<IFile> genFiles = gfm.getGeneratedFilesForParent( _filesToProcess[i] );", "+\t\t\t\tif( genFiles != null )", "+\t\t\t\t\tlastGeneratedFiles.addAll(genFiles);", "-\t\t\t// TODO: (theodora) log unclaimed annotations.", "+\t\t\t", "+\t\t\tif( shouldDispatchToBatchProcessor(factories, processorEnv) )", "+\t\t\t\trunAPTInMixedMode(factories, processorEnv);", "+\t\t\telse", "+\t\t\t\trunAPTInFileBasedMode(factories, processorEnv);", "+\t\t\t", "-\t\t\tSet<IFile> deletedFiles = cleanupNoLongerGeneratedFiles( processorEnv.getFile(), processorEnv.getCompilationUnit(), lastGeneratedFiles, allGeneratedFiles, gfm );", "+\t\t\tSet<IFile> allDeletedFiles = new HashSet<IFile>();", "+\t\t\tfor( int i=0, len=_filesToProcess.length; i<len; i++ ){", "+\t\t\t\tfinal Set<IFile> deletedFiles = ", "+\t\t\t\t\tcleanupNoLongerGeneratedFiles( _filesToProcess[i], processorEnv.getCompilationUnit(), lastGeneratedFiles, allGeneratedFiles, gfm );", "+\t\t\t\tif(deletedFiles != null )", "+\t\t\t\t\tallDeletedFiles.addAll(deletedFiles);\t\t", "+\t\t\t}", "+\t\t\t", "-\t\t\t\t\t\t\t\t\t\t\t  deletedFiles, ", "+\t\t\t\t\t\t\t\t\t\t\t  allDeletedFiles, ", "-\t\t\tAptPlugin.log(t, \"Unexpected failure running APT \" + _file); //$NON-NLS-1$", "+\t\t\tAptPlugin.log(t, \"Unexpected failure running APT \" + getFileNameForPrint()); //$NON-NLS-1$", "+\t}"]}], "num": 36767}