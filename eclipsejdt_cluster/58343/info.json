{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "79e8f23e5a2bd9f4d8dde85dadd8204c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85bc8a4e9f8e26bd613554831829ddb1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "c68bc9934e48a34d453d6810fef3f4032fb88b14", "commitAfterChange": "7389e11979cd050788c8fca32e602540d323e3bc", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "signatureAfterChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "diff": ["-\t\tchar[] tag = new char[length];", "-\t\tSystem.arraycopy(this.source, this.tagSourceStart, tag, 0, length);", "+\t\tif (length == 0) return false; // may happen for some parser (completion for example)", "+\t\tchar firstChar = this.source[this.tagSourceStart];", "-\t\t\t\tif (length == 0) break; // may happen for some parser (completion for example)", "-\t\t\t\tswitch (tag[0]) {", "+\t\t\t\tswitch (firstChar) {", "-\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_CATEGORY)) {", "+\t\t\t\t\t\tif (length == TAG_CATEGORY_LENGTH && CharOperation.equals(TAG_CATEGORY, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "-\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "+\t\t\t\t\t\tif (length == TAG_DEPRECATED_LENGTH && CharOperation.equals(TAG_DEPRECATED, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "-\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\tif (length == TAG_EXCEPTION_LENGTH && CharOperation.equals(TAG_EXCEPTION, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "-\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_INHERITDOC)) {", "+\t\t\t\t\t\tif (length == TAG_INHERITDOC_LENGTH && CharOperation.equals(TAG_INHERITDOC, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "-\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_LINK)) {", "+\t\t\t\t\t\tif (length == TAG_LINK_LENGTH && CharOperation.equals(TAG_LINK, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "-\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_LINKPLAIN)) {", "+\t\t\t\t\t\t} else if (length == TAG_LINKPLAIN_LENGTH && CharOperation.equals(TAG_LINKPLAIN, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "-\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_PARAM)) {", "+\t\t\t\t\t\tif (length == TAG_PARAM_LENGTH && CharOperation.equals(TAG_PARAM, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "-\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_SEE)) {", "+\t\t\t\t\t\tif (length == TAG_SEE_LENGTH && this.source[this.tagSourceStart+1] == TAG_SEE[1] &&  this.source[this.tagSourceEnd] == TAG_SEE[2]) {", "-\t\t\t\t\t\tif (this.sourceLevel >= ClassFileConstants.JDK1_5 && CharOperation.equals(tag, TAG_VALUE)) {", "+\t\t\t\t\t\tif (this.sourceLevel >= ClassFileConstants.JDK1_5 && length == TAG_VALUE_LENGTH && CharOperation.equals(TAG_VALUE, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e322adbd293c8587d3e0ba7fa98ab4ec", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "3cbc5a17035fd93e630a5ce3a447371924b2eaec", "commitAfterChange": "2fbac062d3f933d7974166e3d20ea9843fdd9750", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 61, "signatureBeforeChange": " \tvoid printComment(int kind, int trailing)", "signatureAfterChange": " \tvoid printComment(int kind, int trailing)", "diff": ["-\t\t\t\t\t\tif (trailing == IMPORT_TRAILING_COMMENT && this.scanner.currentCharacter == '/' && lines <= 1) {", "-\t\t\t\t\t\t\tint currentPosition = this.scanner.currentPosition;", "-\t\t\t\t\t\t\tif (this.scanner.getNextToken() == TerminalTokens.TokenNameCOMMENT_LINE) {", "-\t\t\t\t\t\t\t\tint token = this.scanner.getNextToken();", "-\t\t\t\t\t\t\t\twhile (token == TerminalTokens.TokenNameCOMMENT_LINE) {", "-\t\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "-\t\t\t\t\t\t\t\t\tchar[] secondWhiteSpaces = this.scanner.getCurrentTokenSource();", "-\t\t\t\t\t\t\t\t\tloop: for (int i = 0, max = secondWhiteSpaces.length; i < max; i++) {", "-\t\t\t\t\t\t\t\t\t\tswitch(secondWhiteSpaces[i]) {", "-\t\t\t\t\t\t\t\t\t\t\tcase '\\r' :", "-\t\t\t\t\t\t\t\t\t\t\tcase '\\n' :", "-\t\t\t\t\t\t\t\t\t\t\t\trealTrailing = false;", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (realTrailing && this.scanner.currentCharacter == '/' && (lines == 0 || (lines == 1 && !hasLineComment && trailing == IMPORT_TRAILING_COMMENT))) {", "+\t\t\t\t\t\t\t// sometimes changing the trailing may not be the best idea", "+\t\t\t\t\t\t\t// for complex trailing comment, it's basically a good idea", "+\t\t\t\t\t\t\tboolean canChangeTrailing = (trailing & COMPLEX_TRAILING_COMMENT) != 0;", "+\t\t\t\t\t\t\t// for basic trailing comment preceded by a line comment, then it depends on the comments relative position", "+\t\t\t\t\t\t\t// when following comment column (after having been rounded) is below the preceding one,", "+\t\t\t\t\t\t\t// then it becomes not a good idea to change the trailing flag", "+\t\t\t\t\t\t\tif (trailing == BASIC_TRAILING_COMMENT && hasLineComment) {", "+\t\t\t\t\t\t\t\tint currentCommentColumn = getCurrentColumn(whiteSpaces);", "+\t\t\t\t\t\t\t\tint lastCommentColumn = this.lastLineComment.currentColumn;", "+\t\t\t\t\t\t\t\tif (this.tabLength > 0) {", "+\t\t\t\t\t\t\t\t\tif ((currentCommentColumn % this.tabLength) == 0) {", "+\t\t\t\t\t\t\t\t\t\tlastCommentColumn = (lastCommentColumn / this.tabLength) * this.tabLength;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tcurrentCommentColumn = ((currentCommentColumn / this.tabLength) + 1) * this.tabLength;", "+\t\t\t\t\t\t\t\tcanChangeTrailing = currentCommentColumn >= lastCommentColumn;", "-\t\t\t\t\t\t\tthis.scanner.resetTo(currentPosition, this.scanner.eofPosition - 1);", "+\t\t\t\t\t\t\t// if the trailing can be change, then look at the following tokens", "+\t\t\t\t\t\t\tif (canChangeTrailing) {", "+\t\t\t\t\t\t\t\tint currentPosition = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\tif (this.scanner.getNextToken() == TerminalTokens.TokenNameCOMMENT_LINE) {", "+\t\t\t\t\t\t\t\t\trealTrailing = !hasLineComment;", "+\t\t\t\t\t\t\t\t\tswitch (this.scanner.getNextToken()) {", "+\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameCOMMENT_LINE:", "+\t\t\t\t\t\t\t\t\t\t\t// at least two contiguous line comments", "+\t\t\t\t\t\t\t\t\t\t\t// the formatter should not consider comments as trailing ones", "+\t\t\t\t\t\t\t\t\t\t\trealTrailing = false;", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\t\t\t\t\tif (this.scanner.getNextToken() == TerminalTokens.TokenNameCOMMENT_LINE) {", "+\t\t\t\t\t\t\t\t\t\t\t\t// at least two contiguous line comments", "+\t\t\t\t\t\t\t\t\t\t\t\t// the formatter should not consider comments as trailing ones", "+\t\t\t\t\t\t\t\t\t\t\t\trealTrailing = false;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tthis.scanner.resetTo(currentPosition, this.scanner.eofPosition - 1);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t// Look whether comments line may be contiguous or not", "+\t\t\t\t\t\t// Note that when preceding token is a comment line, then only one line", "+\t\t\t\t\t\t// is enough to have an empty line as the line end is included in the comment line...", "+\t\t\t\t\t\t// If comments are contiguous, store the white spaces to be able to compute the current comment indentation", "+\t\t\t\t\t\tif (lines > 1 || (lines == 1 && hasLineComment)) {", "+\t\t\t\t\t\t\tthis.lastLineComment.contiguous = false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.lastLineComment.leadingSpaces = whiteSpaces;", "+\t\t\t\t\t\tthis.lastLineComment.lines = lines;", "+\t\t\t\t\t\t// Strategy to consume spaces and eventually leave at this stage", "+\t\t\t\t\t\t// depends on the fact that a trailing comment is expected or not", "+\t\t\t\t\t\tthis.lastLineComment.contiguous = false;", "+\t\t\t\t\t\tthis.lastLineComment.contiguous = false;", "+\t\t\t\t\t\tthis.lastLineComment.contiguous = false;"]}], "num": 58343}