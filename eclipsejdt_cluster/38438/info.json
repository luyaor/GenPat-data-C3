{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0d1417402fb172007fc0354cbb871e14", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "157a11ce493e5c9de5e5f7db3cfa56ce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "a8073c80a69f6c184e71b3ada3faf15faa3ff3ae", "commitAfterChange": "33e49b6e14282ee69dc2c2cf0c73bec5e674cdf2", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType)", "signatureAfterChange": " \tpublic static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType)", "diff": ["+\t\t\tMap implicitContainerAnnotations = null;", "-\t\t\t\tTypeBinding annotationType = annotation.getAnnotationType();", "+\t\t\t\tReferenceBinding annotationType = annotation.getAnnotationType();", "-\t\t\t\t\t\tfoundDuplicate = true;", "-\t\t\t\t\t\tif (distinctAnnotations == annotations) {", "-\t\t\t\t\t\t\tSystem.arraycopy(distinctAnnotations, 0, distinctAnnotations = new AnnotationBinding[length], 0, length);", "+\t\t\t\t\t\tif (annotationType.isRepeatableAnnotation()) {", "+\t\t\t\t\t\t\tReferenceBinding resolvedContainer = annotationType.resolveContainerAnnotation();", "+\t\t\t\t\t\t\tif (resolvedContainer != null) {", "+\t\t\t\t\t\t\t\t// Since this is a repeated annotation, we need to check if the container is also used - so store it", "+\t\t\t\t\t\t\t\t// in a map of (container's ReferenceBinding -> the repeated source Annotation)", "+\t\t\t\t\t\t\t\tif (implicitContainerAnnotations == null) implicitContainerAnnotations = new HashMap(3);", "+\t\t\t\t\t\t\t\timplicitContainerAnnotations.put(resolvedContainer, sourceAnnotations[i]);", "+\t\t\t\t\t\t\t\tAnnotation.checkAnnotationContainerTarget(sourceAnnotations[i], scope, annotationType, resolvedContainer);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tfoundDuplicate = true;", "+\t\t\t\t\t\t\tif (distinctAnnotations == annotations) {", "+\t\t\t\t\t\t\t\tSystem.arraycopy(distinctAnnotations, 0, distinctAnnotations = new AnnotationBinding[length], 0, length);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tdistinctAnnotations[j] = null; // report it only once", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateAnnotation(sourceAnnotations[j], scope.compilerOptions().sourceLevel);", "-\t\t\t\t\t\tdistinctAnnotations[j] = null; // report it only once", "-\t\t\t\t\t\tscope.problemReporter().duplicateAnnotation(sourceAnnotations[j]);", "-\t\t\t\t\tscope.problemReporter().duplicateAnnotation(sourceAnnotations[i]);", "+\t\t\t\t\tscope.problemReporter().duplicateAnnotation(sourceAnnotations[i], scope.compilerOptions().sourceLevel);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (implicitContainerAnnotations != null) {", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tif (distinctAnnotations[i] == null) continue;", "+\t\t\t\t\tAnnotation annotation = sourceAnnotations[i];", "+\t\t\t\t\tReferenceBinding annotationType = distinctAnnotations[i].getAnnotationType();", "+\t\t\t\t\tif (implicitContainerAnnotations.containsKey(annotationType)) {", "+\t\t\t\t\t\tscope.problemReporter().repeatedAnnotationWithContainer((Annotation) implicitContainerAnnotations.get(annotationType), annotation);", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eea6e5a8b2788218fef24a31640da4a7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "ed1175e5f3196c1368a9a2b98678b1f4969f4620", "commitAfterChange": "cdead094a9813fdba5ccda0ce2f9f48a99552dbc", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprivate void resolveThrowsTags(MethodScope methScope, boolean reportMissing)", "signatureAfterChange": " \tprivate void resolveThrowsTags(MethodScope methScope, boolean reportMissing)", "diff": ["-\t\tint throwsTagsNbre = thrownExceptions == null ? 0 : thrownExceptions.length;", "-\t\tint thrownExceptionSize = md.thrownExceptions == null ? 0 : md.thrownExceptions.length;", "+\t\tint throwsTagsNbre = this.thrownExceptions == null ? 0 : this.thrownExceptions.length;", "+", "+\t\t// If no referenced method (field initializer for example) then report a problem for each param tag", "+\t\tif (md == null) {", "+\t\t\tfor (int i = 0; i < throwsTagsNbre; i++) {", "+\t\t\t\tTypeReference typeRef = this.thrownExceptions[i];", "+\t\t\t\tint start = typeRef.sourceStart;", "+\t\t\t\tint end = typeRef.sourceEnd;", "+\t\t\t\tif (typeRef instanceof JavadocQualifiedTypeReference) {", "+\t\t\t\t\tstart = ((JavadocQualifiedTypeReference) typeRef).tagSourceStart;", "+\t\t\t\t\tend = ((JavadocQualifiedTypeReference) typeRef).tagSourceEnd;", "+\t\t\t\t} else if (typeRef instanceof JavadocSingleTypeReference) {", "+\t\t\t\t\tstart = ((JavadocSingleTypeReference) typeRef).tagSourceStart;", "+\t\t\t\t\tend = ((JavadocSingleTypeReference) typeRef).tagSourceEnd;", "+\t\t\t\t}", "+\t\t\t\tmethScope.problemReporter().javadocUnexpectedTag(start, end);", "+\t\t\t}", "+\t\t\treturn;", "+\t\t}", "+\t\tint thrownExceptionSize = md.thrownExceptions == null ? 0 : md.thrownExceptions.length;", "-\t\t\t\t\t\tmethScope.problemReporter().javadocMissingThrowsTag(typeRef);", "+\t\t\t\t\t\tmethScope.problemReporter().javadocMissingThrowsTag(typeRef, md.binding.modifiers);", "-\t\t\t\tTypeReference typeRef = thrownExceptions[i];", "+\t\t\t\tTypeReference typeRef = this.thrownExceptions[i];", "-\t\t\t\t\t\t\tmethScope.problemReporter().javadocInvalidThrowsClassName(typeRef, true);", "+\t\t\t\t\t\t\tmethScope.problemReporter().javadocDuplicatedThrowsClassName(typeRef, md.binding.modifiers);", "-\t\t\tif (reportMissing) {", "-\t\t\t\tfor (int i = 0; i < thrownExceptionSize; i++) {", "-\t\t\t\t\tTypeReference exception = md.thrownExceptions[i];", "-\t\t\t\t\tboolean found = false;", "-\t\t\t\t\tfor (int j = 0; j < maxRef && !found; j++) {", "-\t\t\t\t\t\tif (typeReferences[j] != null) {", "-\t\t\t\t\t\t\tTypeBinding typeBinding = typeReferences[j].resolvedType;", "-\t\t\t\t\t\t\tif (exception.resolvedType == typeBinding) {", "-\t\t\t\t\t\t\t\tfound = true;", "-\t\t\t\t\t\t\t\ttypeReferences[j] = null;", "-\t\t\t\t\t\t\t}", "+\t\t\tfor (int i = 0; i < thrownExceptionSize; i++) {", "+\t\t\t\tTypeReference exception = md.thrownExceptions[i];", "+\t\t\t\tboolean found = false;", "+\t\t\t\tfor (int j = 0; j < maxRef && !found; j++) {", "+\t\t\t\t\tif (typeReferences[j] != null) {", "+\t\t\t\t\t\tTypeBinding typeBinding = typeReferences[j].resolvedType;", "+\t\t\t\t\t\tif (exception.resolvedType == typeBinding) {", "+\t\t\t\t\t\t\tfound = true;", "+\t\t\t\t\t\t\ttypeReferences[j] = null;", "-\t\t\t\t\tif (!found) {", "-\t\t\t\t\t\tif (exception.resolvedType != null && exception.resolvedType.isValidBinding()) { // flag only valid class name", "-\t\t\t\t\t\t\tmethScope.problemReporter().javadocMissingThrowsTag(exception);", "-\t\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (!found && reportMissing) {", "+\t\t\t\t\tif (exception.resolvedType != null && exception.resolvedType.isValidBinding()) { // flag only valid class name", "+\t\t\t\t\t\tmethScope.problemReporter().javadocMissingThrowsTag(exception, md.binding.modifiers);", "-\t\t\t\t\t\tmethScope.problemReporter().javadocInvalidThrowsClassName(typeRef, false);", "+\t\t\t\t\t\tmethScope.problemReporter().javadocInvalidThrowsClassName(typeRef, md.binding.modifiers);"]}], "num": 38438}