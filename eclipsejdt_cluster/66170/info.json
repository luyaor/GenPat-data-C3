{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "295bbc7cdb65a1bb5778566403a2f07e", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ea0759d0d0f35ace16758171cc59e83", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "59e26d7d44dd6102df4b7a4747425328bf55da24", "commitAfterChange": "74b7e9bbbee0eebec4c9550b37cb671ca5d91239", "methodNumberBeforeChange": 124, "methodNumberAfterChange": 125, "signatureBeforeChange": " \tpublic void resolveClasspath(PerProjectInfo perProjectInfo, boolean usePreviousSession) throws JavaModelException", "signatureAfterChange": " \tpublic void resolveClasspath(PerProjectInfo perProjectInfo, boolean usePreviousSession) throws JavaModelException", "diff": ["-\t\t\tExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();", "-", "-", "-\t\t\tIJavaModelStatus unresolvedEntryStatus = JavaModelStatus.VERIFIED_OK;", "-\t\t\tHashMap rawReverseMap = new HashMap();", "-\t\t\tMap rootPathToResolvedEntries = new HashMap();", "-", "-\t\t\tArrayList resolvedEntries = new ArrayList();", "-\t\t\tint length = rawClasspath.length;", "-\t\t\tfor (int i = 0; i < length; i++) {", "-", "-\t\t\t\tIClasspathEntry rawEntry = rawClasspath[i];", "-\t\t\t\tIPath resolvedPath;", "-", "-\t\t\t\tswitch (rawEntry.getEntryKind()){", "-", "-\t\t\t\t\tcase IClasspathEntry.CPE_VARIABLE :", "-\t\t\t\t\t\tIClasspathEntry resolvedEntry = null;", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tresolvedEntry = manager.getResolvedClasspathEntry(rawEntry, usePreviousSession);", "-\t\t\t\t\t\t} catch (ClasspathEntry.AssertionFailedException e) {", "-\t\t\t\t\t\t\t// Catch the assertion failure and set status instead", "-\t\t\t\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=55992", "-\t\t\t\t\t\t\tunresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, e.getMessage());", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (resolvedEntry == null) {", "-\t\t\t\t\t\t\tunresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND, this, rawEntry.getPath());", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) {", "-\t\t\t\t\t\t\t\trawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t\t\trootPathToResolvedEntries.put(resolvedPath, resolvedEntry);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-", "-\t\t\t\t\tcase IClasspathEntry.CPE_CONTAINER :", "-\t\t\t\t\t\tIClasspathContainer container = usePreviousSession ? manager.getPreviousSessionContainer(rawEntry.getPath(), this) : JavaCore.getClasspathContainer(rawEntry.getPath(), this);", "-\t\t\t\t\t\tif (container == null){", "-\t\t\t\t\t\t\tunresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.CP_CONTAINER_PATH_UNBOUND, this, rawEntry.getPath());", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\tIClasspathEntry[] containerEntries = container.getClasspathEntries();", "-\t\t\t\t\t\tif (containerEntries == null) {", "-\t\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE || JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {", "-\t\t\t\t\t\t\t\tJavaModelManager.getJavaModelManager().verbose_missbehaving_container_null_entries(this, rawEntry.getPath());", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t// container was bound", "-\t\t\t\t\t\tfor (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){", "-\t\t\t\t\t\t\tClasspathEntry cEntry = (ClasspathEntry) containerEntries[j];", "-\t\t\t\t\t\t\tif (cEntry == null) {", "-\t\t\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE || JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {", "-\t\t\t\t\t\t\t\t\tJavaModelManager.getJavaModelManager().verbose_missbehaving_container(this, rawEntry.getPath(), containerEntries);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// if container is exported or restricted, then its nested entries must in turn be exported  (21749) and/or propagate restrictions", "-\t\t\t\t\t\t\tcEntry = cEntry.combineWith((ClasspathEntry) rawEntry);", "-\t\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = cEntry.getPath()) == null) {", "-\t\t\t\t\t\t\t\trawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t\t\trootPathToResolvedEntries.put(resolvedPath, cEntry);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tresolvedEntries.add(cEntry);", "-\t\t\t\t\t\t\tif (cEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-", "-\t\t\t\t\tdefault :", "-\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = rawEntry.getPath()) == null) {", "-\t\t\t\t\t\t\trawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t\trootPathToResolvedEntries.put(resolvedPath, rawEntry);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tresolvedEntries.add(rawEntry);", "-\t\t\t\t\t\tif (rawEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\t", "+\t\t\tResolvedClasspath result = resolveClasspath(rawClasspath, usePreviousSession);", "-\t\t\tIClasspathEntry[] resolvedClasspath = new IClasspathEntry[resolvedEntries.size()];", "-\t\t\tresolvedEntries.toArray(resolvedClasspath);", "-\t\t\tperProjectInfo.setResolvedClasspath(resolvedClasspath, rawReverseMap, rootPathToResolvedEntries, usePreviousSession ? PerProjectInfo.NEED_RESOLUTION : unresolvedEntryStatus, timeStamp);", "+\t\t\tperProjectInfo.setResolvedClasspath(result.resolvedClasspath, result.rawReverseMap, result.rootPathToResolvedEntries, usePreviousSession ? PerProjectInfo.NEED_RESOLUTION : result.unresolvedEntryStatus, timeStamp);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "49cadf49b98b06fe5858061b94dfe662", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatch.java", "commitBeforeChange": "835454076c7c84a3d008630e11d7802ddd16d580", "commitAfterChange": "dfc6a6fda29de48e066662fb088bf2e300f9b1e1", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tprivate static APTResult runAPT( \t\t\tfinal List<AnnotationProcessorFactory> factories, \t\t\tfinal ProcessorEnvImpl processorEnv)", "signatureAfterChange": " \t\t \tprivate static APTResult runAPT(final List<AnnotationProcessorFactory> factories, \t\t\tIJavaProject javaProj, IFile file,  \t\t\tICompilationUnit compilationUnit )", "diff": ["+\tprivate static APTResult runAPT(final List<AnnotationProcessorFactory> factories,", "+\t\t\tIJavaProject javaProj, IFile file, ", "+\t\t\tICompilationUnit compilationUnit )", "+\t{", "+\t\t", "+\t\tAptDispatchRunnable runnable;", "+\t\tif ( file != null )", "+\t\t\t runnable = new AptDispatchRunnable( file, javaProj, factories );", "+\t\telse", "+\t\t\trunnable = new AptDispatchRunnable( compilationUnit, javaProj, factories );", "+\t\t", "+\t\tIWorkspace w = ResourcesPlugin.getWorkspace();", "+\t\ttry", "+\t\t\tw.run( runnable, null );", "-", "-\tprivate static APTResult runAPT(", "-\t\t\tfinal List<AnnotationProcessorFactory> factories,", "-\t\t\tfinal ProcessorEnvImpl processorEnv) ", "-\t{", "-\t\ttry {", "-\t\t\tif (factories.size() == 0)", "-\t\t\t{", "-\t\t\t\tif ( DEBUG ) trace( \"runAPT: leaving early because there are no factories\");", "-\t\t\t\treturn EMPTY_APT_RESULT;", "-\t\t\t}", "-\t\t\t\t", "-\t\t\tif ( ! processorEnv.getFile().exists() )", "-\t\t\t{", "-\t\t\t\tif ( DEBUG ) trace( \"runAPT: leaving early because file doesn't exist\");", "-\t\t\t\treturn EMPTY_APT_RESULT;", "-\t\t\t}", "-\t\t\t\t", "-\t\t\t// clear out all the markers from the previous round.", "-\t\t\tfinal String markerType = processorEnv.getPhase() == ProcessorEnvImpl.Phase.RECONCILE ? ProcessorEnvImpl.RECONCILE_MARKER", "-\t\t\t\t\t: ProcessorEnvImpl.BUILD_MARKER;", "-\t\t\ttry {", "-\t\t\t\tprocessorEnv.getFile().deleteMarkers(markerType, true,", "-\t\t\t\t\t\tIResource.DEPTH_INFINITE);", "-", "-\t\t\t} catch (CoreException e) {", "-\t\t\t\tthrow new IllegalStateException(e);", "-\t\t\t}", "-\t\t\tfinal Map<String, AnnotationTypeDeclaration> annotationDecls = getAnnotationTypeDeclarations(", "-\t\t\t\t\tprocessorEnv.getAstCompilationUnit(), processorEnv);", "-\t\t\t", "-\t\t\tif (annotationDecls.isEmpty())", "-\t\t\t{", "-\t\t\t\tif ( DEBUG ) trace ( \"runAPT:  leaving early because annotationDecls is empty\" );", "-\t\t\t\treturn EMPTY_APT_RESULT;", "-\t\t\t}", "-", "-\t\t\tGeneratedFileManager gfm = GeneratedFileManager.getGeneratedFileManager( processorEnv.getJavaProject().getProject() );", "-\t\t\tSet<IFile> lastGeneratedFiles = gfm.getGeneratedFilesForParent( processorEnv.getFile() );", "-\t\t\t", "-\t\t\tfor (int i = 0, size = factories.size(); i < size; i++) {", "-\t\t\t\tfinal AnnotationProcessorFactory factory = (AnnotationProcessorFactory) factories.get(i);", "-\t\t\t\tSet<AnnotationTypeDeclaration> factoryDecls = getAnnotations(factory, annotationDecls);", "-\t\t\t\tboolean done = false;", "-\t\t\t\tif( factoryDecls != null ){", "-\t\t\t\t\tif(factoryDecls.size() == 0 ){", "-\t\t\t\t\t\tdone = true;", "-\t\t\t\t\t\tfactoryDecls = new HashSet(annotationDecls.values());", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (factoryDecls != null && factoryDecls.size() > 0) {", "-\t\t\t\t\tfinal AnnotationProcessor processor = factory", "-\t\t\t\t\t\t\t.getProcessorFor(factoryDecls, processorEnv);", "-\t\t\t\t\tif (processor != null)", "-\t\t\t\t\t{", "-\t\t\t\t\t\tif ( DEBUG ) trace( \"runAPT: invoking processor \" + processor.getClass().getName() );", "-\t\t\t\t\t\tprocessor.process();", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\tif (annotationDecls.isEmpty() || done)", "-\t\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\t// TODO: (theodora) log unclaimed annotations.", "-", "-\t\t\t// notify the processor listeners", "-\t\t\tfinal Set<AnnotationProcessorListener> listeners = processorEnv", "-\t\t\t\t\t.getProcessorListeners();", "-\t\t\tfor (AnnotationProcessorListener listener : listeners) {", "-\t\t\t\tEclipseRoundCompleteEvent event = null;", "-\t\t\t\tif (listener instanceof RoundCompleteListener) {", "-\t\t\t\t\tif (event == null)", "-\t\t\t\t\t\tevent = new EclipseRoundCompleteEvent(processorEnv);", "-\t\t\t\t\tfinal RoundCompleteListener rcListener = (RoundCompleteListener) listener;", "-\t\t\t\t\trcListener.roundComplete(event);", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\tfinal Set<IFile> allGeneratedFiles = new HashSet<IFile>();", "-\t\t\tSet<IFile> modifiedFiles = new HashSet<IFile>();", "-\t\t\tMap<IFile, Boolean> filesMap = processorEnv.getGeneratedFiles();", "-\t\t\tfor (Map.Entry<IFile, Boolean> entry : filesMap.entrySet()) {", "-\t\t\t\tallGeneratedFiles.add(entry.getKey());", "-\t\t\t\tif (entry.getValue()) {", "-\t\t\t\t\tmodifiedFiles.add(entry.getKey());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// any files that were generated for this parent on the last", "-\t\t\t// run, but are no longer generated should be removed", "-\t\t\tSet<IFile> deletedFiles = cleanupNoLongerGeneratedFiles( processorEnv.getFile(), lastGeneratedFiles, allGeneratedFiles, gfm );", "-", "-\t\t\tAPTResult result = new APTResult( modifiedFiles, deletedFiles, processorEnv.getTypeDependencies() );", "-\t\t\tprocessorEnv.close();", "-\t\t\treturn result;", "-", "-\t\t\t// log unclaimed annotations.", "-\t\t} catch (Throwable t) {", "-\t\t\tt.printStackTrace();", "-\t\t}", "-\t\treturn EMPTY_APT_RESULT;", "-\t}", "+\t\tcatch( CoreException ce )", "+\t\t\t// TODO:  deal with this exception", "+\t\t\tce.printStackTrace();", "+\t\t\t", "+\t\treturn runnable.getResult();"]}], "num": 66170}