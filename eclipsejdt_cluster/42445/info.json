{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "11b788df75a2fbbe7b30c85d991ed775", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0d80397b88021af55240fe2a442f8521", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java", "commitBeforeChange": "bf1ba1c1732b0be00fbd03cfd8ae394b6a169e63", "commitAfterChange": "debb51f61b0b4a5b1a6926f67a451ba72125546c", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic void resolve(BlockScope scope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope scope)", "diff": ["-", "-\t\t// duplicate checks", "-\t\tif ((binding = scope.duplicateName(name)) != null) {", "-\t\t\t// the name already exists... may carry on with the first binding...", "-\t\t\tscope.problemReporter().redefineLocal(this);", "-\t\t} else {", "+\t\tBinding existingVariable = scope.getBinding(name, BindingIds.VARIABLE, this);", "+\t\tboolean shouldInsertInScope = true;", "+\t\tif (existingVariable != null && existingVariable.isValidBinding()){", "+\t\t\tif (existingVariable instanceof LocalVariableBinding && this.hiddenVariableDepth == 0) {", "+\t\t\t\tshouldInsertInScope = false;", "+\t\t\t\tscope.problemReporter().redefineLocal(this);", "+\t\t\t} else {", "+\t\t\t\tscope.problemReporter().localVariableHiding(this, existingVariable, false);", "+\t\t\t}", "+\t\t}", "+\t\t\t\t", "+\t\tif (shouldInsertInScope) {", "-\t\t\tbinding.constant =", "-\t\t\t\tbinding.isFinal()", "-\t\t\t\t\t? initialization.constant.castTo((tb.id << 4) + initialization.constant.typeID())", "-\t\t\t\t\t: NotAConstant;", "+\t\t\tif (binding != null) {", "+\t\t\t\tbinding.constant =", "+\t\t\t\t\tbinding.isFinal()", "+\t\t\t\t\t\t? initialization.constant.castTo((tb.id << 4) + initialization.constant.typeID())", "+\t\t\t\t\t\t: NotAConstant;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "706357f1ff8e15e02b45d7c2524425ff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java", "commitBeforeChange": "bf1ba1c1732b0be00fbd03cfd8ae394b6a169e63", "commitAfterChange": "debb51f61b0b4a5b1a6926f67a451ba72125546c", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic TypeBinding resolveForCatch(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveForCatch(BlockScope scope)", "diff": ["-\t\tif ((binding = scope.duplicateName(name)) != null) {", "-\t\t\t// the name already exists....may carry on with the first binding ....", "-\t\t\tscope.problemReporter().redefineArgument(this);", "-\t\t\treturn null;", "+", "+\t\tBinding existingVariable = scope.getBinding(name, BindingIds.VARIABLE, this);", "+\t\tif (existingVariable != null && existingVariable.isValidBinding()){", "+\t\t\tif (existingVariable instanceof LocalVariableBinding && this.hiddenVariableDepth == 0) {", "+\t\t\t\tscope.problemReporter().redefineArgument(this);", "+\t\t\t\treturn null;", "+\t\t\t} else {", "+\t\t\t\tscope.problemReporter().localVariableHiding(this, existingVariable, false);", "+\t\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e3dd1d52ffa4084c0ac706f3ebc2c56", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java", "commitBeforeChange": "bf1ba1c1732b0be00fbd03cfd8ae394b6a169e63", "commitAfterChange": "debb51f61b0b4a5b1a6926f67a451ba72125546c", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic void bind(MethodScope scope, TypeBinding typeBinding, boolean used)", "signatureAfterChange": "  \tpublic void bind(MethodScope scope, TypeBinding typeBinding, boolean used)", "diff": ["-\t\tif ((this.binding = scope.duplicateName(this.name)) != null) {", "-\t\t\t//the name already exist....may carry on with the first binding ....", "-\t\t\tscope.problemReporter().redefineArgument(this);", "-\t\t} else {", "-\t\t\tscope.addLocalVariable(", "-\t\t\t\tthis.binding =", "-\t\t\t\t\tnew LocalVariableBinding(this, typeBinding, modifierFlag, true));", "-\t\t\t//true stand for argument instead of just local", "-\t\t\tif (typeBinding != null && isTypeUseDeprecated(typeBinding, scope))", "-\t\t\t\tscope.problemReporter().deprecatedType(typeBinding, this.type);", "-\t\t\tthis.binding.declaration = this;", "-\t\t\tthis.binding.useFlag = used ? LocalVariableBinding.USED : LocalVariableBinding.UNUSED;", "+", "+\t\tBinding existingVariable = scope.getBinding(name, BindingIds.VARIABLE, this);", "+\t\tif (existingVariable != null && existingVariable.isValidBinding()){", "+\t\t\tif (existingVariable instanceof LocalVariableBinding && this.hiddenVariableDepth == 0) {", "+\t\t\t\tscope.problemReporter().redefineArgument(this);", "+\t\t\t\treturn;", "+\t\t\t} else {", "+\t\t\t\tscope.problemReporter().localVariableHiding(this, existingVariable, scope.isInsideConstructor() && existingVariable instanceof FieldBinding);", "+\t\t\t}", "+", "+\t\tscope.addLocalVariable(", "+\t\t\tthis.binding =", "+\t\t\t\tnew LocalVariableBinding(this, typeBinding, modifierFlag, true));", "+\t\t//true stand for argument instead of just local", "+\t\tif (typeBinding != null && isTypeUseDeprecated(typeBinding, scope))", "+\t\t\tscope.problemReporter().deprecatedType(typeBinding, this.type);", "+\t\tthis.binding.declaration = this;", "+\t\tthis.binding.useFlag = used ? LocalVariableBinding.USED : LocalVariableBinding.UNUSED;"]}], "num": 42445}