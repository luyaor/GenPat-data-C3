{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "aa82e2f58790e74de0da729b2c832999", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9224a77e3e13e759ba2c0756cc57c9c1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "8a765fa23ce703d1d5f2388d447ea40d7aad9f99", "commitAfterChange": "988b834a35e1571af05adddd8db1ce5aaa1f0ff0", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tif (use18specifics) { ", "-\t\t\tif (this.valueIfTrue.isPolyExpression()) // context propagated already.", "+\t\tif (use18specifics) {", "+\t\t\tif (this.expressionContext == ASSIGNMENT_CONTEXT || this.expressionContext == INVOCATION_CONTEXT) {", "+\t\t\t\t/* 15.25.3 : Where a poly reference conditional expression appears in a context of a particular kind with target ", "+\t\t\t\t   type T (5), its second and third operand expressions similarly appear in a context of the same kind with target", "+\t\t\t\t   type T. We eagerly propagate the context and target type here, but that should be harmless. Nonpoly expressions", "+\t\t\t\t   won't respond to it at all. If someone down below does get influenced, then the conditional is poly.", "+\t\t\t\t*/", "+\t\t\t\tthis.valueIfTrue.setExpressionContext(this.expressionContext);", "-\t\t\tif (this.valueIfFalse.isPolyExpression())", "+", "+\t\t\t\tthis.valueIfFalse.setExpressionContext(this.expressionContext);", "+\t\t\t}", "+\t\tif (use18specifics && this.expectedType != null) { // so the story is still untold for invocations.", "+\t\t\t", "+\t\t\t    TypeBinding trueType = originalValueIfTrueType;", "+\t\t\t    TypeBinding falseType = originalValueIfFalseType;", "+\t\t\t    if (this.valueIfTrue instanceof MessageSend) {", "+\t\t\t    \tMessageSend message = (MessageSend) this.valueIfTrue;", "+\t\t\t    \tif (message.binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t    \t\tParameterizedGenericMethodBinding pgmb = (ParameterizedGenericMethodBinding) message.binding;", "+\t\t\t    \t\tif (pgmb.inferredReturnType) {", "+\t\t\t    \t\t\ttrueType = pgmb.original().returnType;", "+\t\t\t    \t\t}", "+\t\t\t    \t}", "+\t\t\t    }", "+\t\t\t    if (this.valueIfFalse instanceof MessageSend) {", "+\t\t\t    \tMessageSend message = (MessageSend) this.valueIfFalse;", "+\t\t\t    \tif (message.binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t    \t\tParameterizedGenericMethodBinding pgmb = (ParameterizedGenericMethodBinding) message.binding;", "+\t\t\t    \t\tif (pgmb.inferredReturnType) {", "+\t\t\t    \t\t\tfalseType = pgmb.original().returnType;", "+\t\t\t    \t\t}", "+\t\t\t    \t}", "+\t\t\t    }", "+\t\t\t    ", "+\t\t\t    if (!trueType.isPrimitiveOrBoxedPrimitiveType() || !falseType.isPrimitiveOrBoxedPrimitiveType()) { // reference conditional ==> poly expression.", "+\t\t\t    \tif (!originalValueIfTrueType.isCompatibleWith(this.expectedType, scope))", "+\t\t\t    \t\tscope.problemReporter().typeMismatchError(originalValueIfTrueType, this.expectedType, this.valueIfTrue, null);", "+\t\t\t    \tif (!originalValueIfFalseType.isCompatibleWith(this.expectedType, scope))", "+\t\t\t    \t\tscope.problemReporter().typeMismatchError(originalValueIfFalseType, this.expectedType, this.valueIfFalse, null);", "+\t\t\t    \t// 15.25.3: The type of a poly reference conditional expression is the same as its target type.", "+\t\t\t    \treturn this.resolvedType = this.expectedType;", "+\t\t\t    }", "+\t\t\t", "+\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f6848a7c143466b67099466fe41f589b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "bca01eadc82a3abb71100149fcbedb07d33a04ad", "commitAfterChange": "a6f21a01110fe95a43760ec08fc8cc1e27e1c4bc", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tboolean use18specifics = sourceLevel >= ClassFileConstants.JDK1_8;", "+\t\tthis.use18specifics = sourceLevel >= ClassFileConstants.JDK1_8;", "-\t\tif (use18specifics) {", "+\t\tif (this.use18specifics) {", "-", "-\t\t\tif (isPolyExpression()) {", "-\t\t\t\tthis.polyExpressionScope = scope;", "-\t\t\t}", "-", "-\t\t\tif (this.originalValueIfTrueType.kind() == Binding.POLY_TYPE || this.originalValueIfFalseType.kind() == Binding.POLY_TYPE) {", "-\t\t\t\treturn new PolyTypeBinding(this);", "-\t\t\t}", "+\t\t\t/* Not reached as of now as we don't evaluate conditional expressions multiple times, left in for now.", "+\t\t\t   If in future, we change things so control reaches here, a precondition is that this.expectedType is", "+\t\t\t   the final target type.", "+\t\t\t*/", "-\t\t", "+\t\tif (isPolyExpression()) {", "+\t\t\tif (this.expectedType == null) {", "+\t\t\t\tthis.polyExpressionScope = scope; // preserve for eventual resolution/error reporting.", "+\t\t\t\treturn new PolyTypeBinding(this);", "+\t\t\t}", "+\t\t\tcomputeConversions(scope, this.expectedType);", "+\t\t\treturn this.resolvedType = this.expectedType;", "+\t\t}", "-\t\tif (use18specifics && isPolyExpression()) {", "-\t\t\tif (this.expectedType == null) {", "-\t\t\t\tthis.polyExpressionScope = scope;", "-\t\t\t\treturn new PolyTypeBinding(this);", "-\t\t\t}", "-\t\t\tif (valueIfTrueType != null) {", "-\t\t\t\tif (!valueIfTrueType.isCompatibleWith(this.expectedType, scope)) {", "-\t\t\t\t\tscope.problemReporter().typeMismatchError(valueIfTrueType, this.expectedType, this.valueIfTrue, null);", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.valueIfTrue.computeConversion(scope, this.expectedType, this.originalValueIfTrueType);\t", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (valueIfFalseType != null) {", "-\t\t\t\tif (!valueIfFalseType.isCompatibleWith(this.expectedType, scope)) {", "-\t\t\t\t\tscope.problemReporter().typeMismatchError(valueIfFalseType, this.expectedType, this.valueIfFalse, null);", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.valueIfFalse.computeConversion(scope, this.expectedType, this.originalValueIfFalseType);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn this.resolvedType = this.expectedType;", "-\t\t}"]}], "num": 46772}