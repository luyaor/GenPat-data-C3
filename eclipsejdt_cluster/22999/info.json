{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c4bbccf657a0eea70c0b776bb53a8ecb", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd1e7db32928991aca4cb4666aa64841", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "82743b33822fbb1e8747641a56800f2dd66cbc54", "commitAfterChange": "ab734870d680bdde73d51371df0336cce36fb2b0", "methodNumberBeforeChange": 160, "methodNumberAfterChange": 160, "signatureBeforeChange": " protected void consumeStatementIfWithElse()", "signatureAfterChange": " protected void consumeStatementIfWithElse()", "diff": ["-\tastLengthPtr--; // optimized {..., Then, Else } ==> {..., If }", "-\t//optimize the push/pop", "-\tStatement elseStatement = (Statement) astStack[astPtr--];", "-\tStatement thenStatement = (Statement) astStack[astPtr];", "-\tif (elseStatement instanceof EmptyStatement) {", "-\t\telseStatement = Block.None;", "+", "+\t// optimized {..., Then, Else } ==> {..., If }", "+\tint elseLength = astLengthStack[astLengthPtr--];", "+\tint thenLength = astLengthStack[astLengthPtr];", "+", "+\tif (thenLength != 0 && elseLength != 0) { // silent empty statement (length==0)", "+\t\t//optimize the push/pop", "+\t\tastStack[--astPtr] = ", "+\t\t\tnew IfStatement(", "+\t\t\t\texpressionStack[expressionPtr--], ", "+\t\t\t\t(Statement) astStack[astPtr], ", "+\t\t\t\t(Statement) astStack[astPtr + 1], ", "+\t\t\t\tintStack[intPtr--], ", "+\t\t\t\tendStatementPosition); ", "+\t} else {", "+\t\tastLengthPtr--; //second decrement", "+\t\tpushOnAstStack(", "+\t\t\tnew IfStatement(expressionStack[expressionPtr--],", "+\t\t\t\t//here only one of then/else length can be different 0", "+\t\t\t\t(thenLength == 0) ? null : (Statement) astStack[astPtr--], ", "+\t\t\t\t(elseLength == 0) ? null : (Statement) astStack[astPtr--], ", "+\t\t\t\tintStack[intPtr--], ", "+\t\t\t\tendStatementPosition)); ", "-\tif (thenStatement instanceof EmptyStatement) {", "-\t\tthenStatement = Block.None;", "-\t}", "-\tastStack[astPtr] = ", "-\t\tnew IfStatement(", "-\t\t\texpressionStack[expressionPtr--], ", "-\t\t\tthenStatement, ", "-\t\t\telseStatement, ", "-\t\t\tintStack[intPtr--], ", "-\t\t\tendStatementPosition); "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e63528e402b9845839ca2e66b02c09a7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "09f42f58bcdf2fa84ccd2b8b65f28ab3036222ca", "commitAfterChange": "57e8dd41219d846363c918d62edb5007994c5c79", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, \t\t\tInvocationSite invocationSite, int inferenceLevel)", "diff": ["-\tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite) {", "+\tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope,", "+\t\t\tInvocationSite invocationSite, int inferenceLevel)", "+\t{", "-\t\t\tif (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8)", "-\t\t\t\tinfCtx18 = invocationSite.freshInferenceContext(scope);", "+\t\t\tif (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\t\tif ((inferenceLevel & Scope.APPLICABILITY) != 0)", "+\t\t\t\t\tinfCtx18 = invocationSite.freshInferenceContext(scope);", "+\t\t\t\telse if (invocationSite instanceof Invocation && originalMethod instanceof ParameterizedGenericMethodBinding)", "+\t\t\t\t\tinfCtx18 = ((Invocation) invocationSite).getInferenceContext((ParameterizedGenericMethodBinding) originalMethod);", "+\t\t\t}", "-\t\t\t\tint checkKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.", "-\t\t\t\t// 18.5.1 (Applicability):", "-\t\t\t\tboolean isDiamond = originalMethod.isConstructor()", "-\t\t\t\t\t\t&& invocationSite instanceof Expression", "-\t\t\t\t\t\t&& ((Expression)invocationSite).isPolyExpression(originalMethod);", "-\t\t\t\tinfCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond, checkKind);", "-\t\t\t\t\tBoundSet provisionalResult = infCtx18.solve();", "-\t\t\t\t\tif (provisionalResult == null && originalMethod.isVarargs()) {", "-\t\t\t\t\t\t// check for variable arity applicability", "-\t\t\t\t\t\tinfCtx18 = invocationSite.freshInferenceContext(scope); // start over", "-\t\t\t\t\t\tcheckKind = InferenceContext18.CHECK_VARARG;", "-\t\t\t\t\t\tinfCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond, checkKind);", "-\t\t\t\t\t\tprovisionalResult = infCtx18.solve();", "-\t\t\t\t\t}", "-\t\t\t\t\tBoundSet result = infCtx18.currentBounds.copy(); // the result after reduction, without effects of resolve()", "-\t\t\t\t\tif (provisionalResult != null && infCtx18.isResolved(provisionalResult)) {", "-\t\t\t\t\t\t// 18.5.2 (Invocation type):", "-\t\t\t\t\t\tTypeBinding expectedType = invocationSite.invocationTargetType();", "-\t\t\t\t\t\tboolean hasReturnProblem = false;", "-\t\t\t\t\t\tboolean invocationTypeInferred = false;", "-\t\t\t\t\t\tif (expectedType != null || invocationSite.getExpressionContext() == ExpressionContext.VANILLA_CONTEXT) {", "-\t\t\t\t\t\t\tresult = infCtx18.inferInvocationType(result, expectedType, invocationSite, originalMethod, checkKind);", "-\t\t\t\t\t\t\tinvocationTypeInferred = true;", "-\t\t\t\t\t\t\thasReturnProblem |= result == null;", "-\t\t\t\t\t\t\tif (hasReturnProblem)", "-\t\t\t\t\t\t\t\tresult = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t// we're not yet ready for invocation type inference", "-\t\t\t\t\t\t\tresult = provisionalResult;", "+\t\t\t\t\tBoundSet provisionalResult = null;", "+\t\t\t\t\tBoundSet result = null;", "+\t\t\t\t\tif ((inferenceLevel & Scope.APPLICABILITY) != 0) {", "+", "+\t\t\t\t\t\t// ---- 18.5.1 (Applicability): ----", "+\t\t\t\t\t\tboolean isDiamond = originalMethod.isConstructor()", "+\t\t\t\t\t\t\t\t&& invocationSite instanceof Expression", "+\t\t\t\t\t\t\t\t&& ((Expression)invocationSite).isPolyExpression(originalMethod);", "+\t\t\t\t\t\tif (arguments.length == parameters.length) {", "+\t\t\t\t\t\t\tinfCtx18.inferenceKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.", "+\t\t\t\t\t\t\tinfCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);", "+\t\t\t\t\t\t\tprovisionalResult = infCtx18.solve();", "+\t\t\t\t\t\tif (provisionalResult == null && originalMethod.isVarargs()) {", "+\t\t\t\t\t\t\t// check for variable-arity applicability", "+\t\t\t\t\t\t\tinfCtx18 = invocationSite.freshInferenceContext(scope); // start over", "+\t\t\t\t\t\t\tinfCtx18.inferenceKind = InferenceContext18.CHECK_VARARG;", "+\t\t\t\t\t\t\tinfCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);", "+\t\t\t\t\t\t\tprovisionalResult = infCtx18.solve();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (provisionalResult != null && infCtx18.isResolved(provisionalResult)) {", "+\t\t\t\t\t\t\tinfCtx18.storedSolution = provisionalResult;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tprovisionalResult = infCtx18.storedSolution;", "+\t\t\t\t\t}", "+\t\t\t\t\tresult = infCtx18.currentBounds.copy(); // the result after reduction, without effects of resolve()", "+", "+\t\t\t\t\tTypeBinding expectedType = invocationSite.invocationTargetType();", "+\t\t\t\t\tboolean hasReturnProblem = false;", "+\t\t\t\t\tboolean invocationTypeInferred = false;", "+\t\t\t\t\tif ((inferenceLevel & Scope.INVOCATION_TYPE) != 0 // requested?", "+\t\t\t\t\t\t\t&& (expectedType != null || invocationSite.getExpressionContext() == ExpressionContext.VANILLA_CONTEXT)) { // possible?", "+", "+\t\t\t\t\t\t// ---- 18.5.2 (Invocation type): ----", "+\t\t\t\t\t\tresult = infCtx18.inferInvocationType(result, expectedType, invocationSite, originalMethod);", "+\t\t\t\t\t\tinvocationTypeInferred = true;", "+\t\t\t\t\t\thasReturnProblem |= result == null;", "+\t\t\t\t\t\tif (hasReturnProblem)", "+\t\t\t\t\t\t\tresult = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// we're not yet ready for invocation type inference", "+\t\t\t\t\t\tresult = provisionalResult;", "+\t\t\t\t\t}", "+", "+\t\t\t\t\tif (result != null) {", "+\t\t\t\t\t\t// assemble the solution etc:", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tif (InferenceContext18.SIMULATE_BUG_JDK_8026527 && expectedType != null && methodSubstitute.returnType instanceof ReferenceBinding)", "-\t\t\t\t\t\t\t\thasReturnProblem &= !methodSubstitute.returnType.erasure().isCompatibleWith(expectedType);", "-\t\t\t\t\t\t\tif (hasReturnProblem) {", "-\t\t\t\t\t\t\t\tProblemMethodBinding problemMethod = new ProblemMethodBinding(methodSubstitute, methodSubstitute.selector, parameters, ProblemReasons.ParameterizedMethodExpectedTypeProblem);", "-\t\t\t\t\t\t\t\tproblemMethod.returnType = invocationSite.invocationTargetType();", "-\t\t\t\t\t\t\t\tproblemMethod.inferenceContext = infCtx18;", "-\t\t\t\t\t\t\t\treturn problemMethod;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (invocationSite instanceof Invocation) {", "-\t\t\t\t\t\t\t\tInvocation invocation = (Invocation)invocationSite;", "-\t\t\t\t\t\t\t\tinvocation.setInferenceKind(checkKind);", "+\t\t\t\t\t\t\tif (hasReturnProblem) { // illegally working from the provisional result?", "+\t\t\t\t\t\t\t\tMethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(expectedType, methodSubstitute);", "+\t\t\t\t\t\t\t\tif (problemMethod instanceof ProblemMethodBinding)", "+\t\t\t\t\t\t\t\t\treturn problemMethod;", "-\t\t\t\t\t\t\t\tif (invocationSite instanceof PolyExpression)", "-\t\t\t\t\t\t\t\t\t((PolyExpression) invocationSite).markInferenceFinished();\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tinfCtx18.rebindInnerPolies(result, arguments);", "+\t\t\t\t\t\t\t\tinfCtx18.rebindInnerPolies(result, methodSubstitute.parameters);", "+\t\t\t\t\t\t\t\treturn methodSubstitute.boundCheck18(scope, arguments);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (invocationSite instanceof Invocation)", "+\t\t\t\t\t\t\t\t\t((Invocation) invocationSite).registerInferenceContext(methodSubstitute, infCtx18); // keep context so we can finish later", "+\t\t\t\t\t\t\t\treturn methodSubstitute;", "-\t\t\t\t\t\t\tbreak computeSubstitutes;"]}], "num": 22999}