{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "80a371d6b1f1d93161bc5ff14afbbd38", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1341ecdaef74114f80fc135680412319", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java", "commitBeforeChange": "e94011fcc318ef65fa86c3461da146f3ce7811d6", "commitAfterChange": "93adf51608925f1838440c274601d52ca5dd3d46", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " public TypeDeclaration updatedTypeDeclaration(int depth, Set knownTypes)", "signatureAfterChange": " public TypeDeclaration updatedTypeDeclaration(int depth, Set knownTypes)", "diff": ["+\t\t", "+\t\tfor (int i = this.fieldCount - 1; 0 < i; i--) {", "+\t\t\tif (fieldDeclarations[existingCount + i - 1].declarationSourceStart == fieldDeclarations[existingCount + i].declarationSourceStart) {", "+\t\t\t\tfieldDeclarations[existingCount + i - 1].declarationSourceEnd = fieldDeclarations[existingCount + i].declarationSourceEnd;", "+\t\t\t\tfieldDeclarations[existingCount + i - 1].declarationEnd = fieldDeclarations[existingCount + i].declarationEnd;", "+\t\t\t}", "+\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8229657378c092b158ca89ba5effed83", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "66fe9194782f846d946fc257cc3a475661c8281c", "commitAfterChange": "474eb5356258f18fd9cfbd1a24f6dbe20ed6eea5", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "diff": ["+\tMethodBinding superClassMethod = null;", "+\tfor (int i = 0; i < length; i++) {", "+\t\tif (!methods[i].declaringClass.isInterface() && methods[i].declaringClass != this.type) {", "+\t\t\tsuperClassMethod = methods[i];", "+\t\t\tbreak;", "+\t\t}", "+\t}", "-\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, concreteMethod, methods[i]);", "-\t\t\t\tcontinueInvestigation = false;", "+\t\t\t\t// 8.4.8.4 defines an exception for default methods if", "+\t\t\t\t// (a) there exists an abstract method declared in a superclass of C and inherited by C", "+\t\t\t\t// (b) that is override-equivalent with the two methods.", "+\t\t\t\tif (methods[i].isDefaultMethod() ", "+\t\t\t\t\t\t&& superClassMethod != null\t\t\t\t\t\t\t// condition (a)", "+\t\t\t\t\t\t&& areParametersEqual(superClassMethod, methods[i]) // condition (b)...", "+\t\t\t\t\t\t&& areParametersEqual(superClassMethod, concreteMethod)) {", "+\t\t\t\t\t// skip, class method trumps this default method", "+\t\t\t\t} else {", "+\t\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, concreteMethod, methods[i]);", "+\t\t\t\t\tcontinueInvestigation = false;", "+\t\t\t\t}"]}], "num": 18811}