{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0b29c107d028d827c85e57d0e8575a2b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4dd0ca94e6b8bb9f886f34dbff811def", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeReferencePattern.java", "commitBeforeChange": "9ccc53063dda8b7e1afdde95ae36a8417c582abc", "commitAfterChange": "7143e72571bb2e6a2e74f6791210a97b375b5ab6", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 7, "signatureBeforeChange": " public void findIndexMatches(IndexInput input, IndexQueryRequestor requestor, SearchParticipant participant, IJavaSearchScope scope, IProgressMonitor progressMonitor) throws IOException", "signatureAfterChange": " public EntryResult[] queryIn(Index index) throws IOException", "diff": ["- */", "-public void findIndexMatches(IndexInput input, IndexQueryRequestor requestor, SearchParticipant participant, IJavaSearchScope scope, IProgressMonitor progressMonitor) throws IOException {", "-\tif (this.entryResults == null) {", "-\t\t// non-optimized case", "-\t\tsuper.findIndexMatches(input, requestor, participant, scope, progressMonitor);\t", "-\t\treturn;", "-\t}", "-", "-\tif (progressMonitor != null && progressMonitor.isCanceled()) throw new OperationCanceledException();", "-", "-\t/* narrow down a set of entries using prefix criteria */", "-\tEntryResult[] entries = (EntryResult[]) this.entryResults.get(input);", "-\tif (entries == null) {", "-\t\tentries = input.queryEntriesPrefixedBy(SUPER_REF);", "-\t\tif (entries == null)", "-\t\t\tentries = NO_ENTRY_RESULT;", "-\t\tthis.entryResults.put(input, entries);", "-\t}", "-\tif (entries == NO_ENTRY_RESULT) return;", "-", "-\t/* only select entries which actually match the entire search pattern */", "-\tint slash = SUPER_REF.length;", "-\tchar[] name = this.superSimpleName;", "-\tint length = name == null ? 0 : name.length;", "-\tnextEntry: for (int i = 0, max = entries.length; i < max; i++) {", "-\t\t/* check that the entry is a super ref to the super simple name */", "-\t\tEntryResult entry = entries[i];", "-\t\tif (name != null) {", "-\t\t\tchar[] word = entry.getWord();", "-\t\t\tif (slash + length >= word.length) continue;", "-\t\t\t", "-\t\t\t// ensure it is the end of the ref (a simple name is not a prefix of ref)", "-\t\t\tif (word[length + slash] != '/') continue; ", "-\t\t\t", "-\t\t\t// compare ref to simple name", "-\t\t\tfor (int j = 0; j < length; j++)", "-\t\t\t\tif (word[j + slash] != name[j]) continue nextEntry;", "-\t\t}", "-", "-\t\t/* retrieve and decode entry */\t", "-\t\tchar[] word = entry.getWord();", "-\t\tchar[] indexKey = CharOperation.subarray(word, SUPER_REF.length, word.length);", "-\t\tSearchPattern decodedPattern = getBlankPattern();", "-\t\tdecodedPattern.decodeIndexKey(indexKey);", "-", "-\t\tint[] references = entry.getFileReferences();", "-\t\tfor (int iReference = 0, refererencesLength = references.length; iReference < refererencesLength; iReference++) {", "-\t\t\tString documentPath = IndexedFile.convertPath( input.getIndexedFile(references[iReference]).getPath());", "-\t\t\tif (scope.encloses(documentPath)) {", "-\t\t\t\tif (!requestor.acceptIndexMatch(documentPath, decodedPattern, participant)) ", "-\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t}", "-\t\t}", "-\t}", "+}", "+public EntryResult[] queryIn(Index index) throws IOException {", "+\tchar[] key = this.superSimpleName; // can be null", "+\tint matchRule = getMatchRule();", "+", "+\t// cannot include the superQualification since it may not exist in the index", "+\tswitch(this.matchMode) {", "+\t\tcase R_EXACT_MATCH :", "+\t\t\t// do a prefix query with the superSimpleName", "+\t\t\tmatchRule = matchRule - R_EXACT_MATCH + R_PREFIX_MATCH;", "+\t\t\tif (this.superSimpleName != null)", "+\t\t\t\tkey = CharOperation.append(this.superSimpleName, SEPARATOR);", "+\t\t\tbreak;", "+\t\tcase R_PREFIX_MATCH :", "+\t\t\t// do a prefix query with the superSimpleName", "+\t\t\tbreak;", "+\t\tcase R_PATTERN_MATCH :", "+\t\t\t// do a pattern query with the superSimpleName", "+\t\t\tbreak;", "+\t}", "+", "+\treturn index.query(getMatchCategories(), key, matchRule); // match rule is irrelevant when the key is null"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a47ddc959bed479e5cc6d0eae93cc881", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "98c49c7e442095e4ddf2a6384735e696e7050501", "commitAfterChange": "182b54f27909efda960637e81e9fbc3f1f6ab16a", "methodNumberBeforeChange": 295, "methodNumberAfterChange": 295, "signatureBeforeChange": " public void recordPositionsFrom(int startPC, int sourcePos)", "signatureAfterChange": " public void recordPositionsFrom(int startPC, int sourcePos)", "diff": ["+\tthis.recordPositionsFrom(startPC, sourcePos, false);", "+}", "-\tif ((this.generateAttributes & ClassFileConstants.ATTR_LINES) == 0)", "-\t\treturn;", "-\tif (sourcePos == 0)", "-\t\treturn;", "-", "-\t// no code generated for this node. e.g. field without any initialization", "-\tif (position == startPC)", "-\t\t\tif (startPC < lastEntryPC) {", "-\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lastEntryPC;", "-\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lineNumber;"]}], "num": 8437}