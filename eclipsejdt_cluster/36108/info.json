{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1b94e1ecf57d540bdad9e318bec1ad10", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0e49985839a152d03c5fe082a3233183", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateImpl.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 63, "signatureBeforeChange": "\r \tprotected void getSourceElementEntries(\r \t\tIPackage pkg,\r \t\tIPath path,\r \t\tLookupTable entryTable)", "signatureAfterChange": "\r \tprotected void getSourceElementEntries(IPackage pkg, IPath path, LookupTable entryTable)", "diff": ["-\tprotected void getSourceElementEntries(\r", "-\t\tIPackage pkg,\r", "-\t\tIPath path,\r", "-\t\tLookupTable entryTable) {\r", "+\tprotected void getSourceElementEntries(IPackage pkg, IPath path, LookupTable entryTable) {\r", "-\t\t\tIPackageFragmentRoot root = null;\r", "-\t\t\tIPackageFragment frag = null;\r", "-\t\t\tboolean isDefault = pkg.isUnnamed();\r", "-\t\t\tString pkgName =\r", "-\t\t\t\tisDefault ? IPackageFragment.DEFAULT_PACKAGE_NAME : pkg.getName();\r", "-\t\t\tString pkgPath = pkgName.replace('.', '/');\r", "+\t\t\tIPackageFragmentRoot root= null;\r", "+\t\t\tIPackageFragment frag= null;\r", "+\t\t\tboolean isDefault= pkg.isUnnamed();\r", "+\t\t\tString pkgName= isDefault ? IPackageFragment.DEFAULT_PACKAGE_NAME : pkg.getName();\r", "+\t\t\tString pkgPath= pkgName.replace('.', '/');\r", "-\t\t\t\tIResource member = null;\r", "-\t\t\t\tif (!path.isAbsolute()\r", "-\t\t\t\t\t|| getProject().getWorkspace().getRoot().findMember(path) != null) {\r", "-\t\t\t\t\troot = getJavaProject().getPackageFragmentRoot(getFile(path));\r", "+\t\t\t\tIResource member= null;\r", "+\t\t\t\tif (!path.isAbsolute() || getProject().getWorkspace().getRoot().findMember(path) != null) {\r", "+\t\t\t\t\troot= getJavaProject().getPackageFragmentRoot(getFile(path));\r", "-\t\t\t\t\troot = getJavaProject().getPackageFragmentRoot(path.toOSString());\r", "+\t\t\t\t\troot= getJavaProject().getPackageFragmentRoot(path.toOSString());\r", "-\t\t\t\tfrag = root.getPackageFragment(pkgName);\r", "+\t\t\t\tfrag= root.getPackageFragment(pkgName);\r", "-\t\t\t\tIPackageFragmentRoot[] roots = getPackageFragmentRootsInClassPath();\r", "-\t\t\t\tfor (int i = 0; i < roots.length; ++i) {\r", "-\t\t\t\t\tIPackageFragmentRoot testRoot = roots[i];\r", "-\t\t\t\t\tif (!testRoot.isArchive()\r", "-\t\t\t\t\t\t&& testRoot.getUnderlyingResource().getFullPath().isPrefixOf(path)) {\r", "-\t\t\t\t\t\troot = testRoot;\r", "-\t\t\t\t\t\tfrag = testRoot.getPackageFragment(pkgName);\r", "+\t\t\t\tIPackageFragmentRoot[] roots= getPackageFragmentRootsInClassPath();\r", "+\t\t\t\tfor (int i= 0; i < roots.length; ++i) {\r", "+\t\t\t\t\tIPackageFragmentRoot testRoot= roots[i];\r", "+\t\t\t\t\tif (!testRoot.isArchive() && testRoot.getUnderlyingResource().getFullPath().isPrefixOf(path)) {\r", "+\t\t\t\t\t\troot= testRoot;\r", "+\t\t\t\t\t\tfrag= testRoot.getPackageFragment(pkgName);\r", "-\t\t\tboolean isArchive = root.isArchive();\r", "+\t\t\tboolean isArchive= root.isArchive();\r", "-\t\t\tif (isArchive\r", "-\t\t\t\t&& root.getUnderlyingResource() != null\r", "-\t\t\t\t&& !root.getUnderlyingResource().isLocal(IResource.DEPTH_ZERO)) {\r", "+\t\t\tif (isArchive && root.getUnderlyingResource() != null && !root.getUnderlyingResource().isLocal(IResource.DEPTH_ZERO)) {\r", "-\t\t\tIPath entryPath = null;\r", "+\t\t\tIPath entryPath= null;\r", "-\t\t\tString zipEntryFileName = null;\r", "+\t\t\tString zipEntryFileName= null;\r", "-\t\t\tICompilationUnit[] units = frag.getCompilationUnits();\r", "-\t\t\tfor (int i = 0; i < units.length; ++i) {\r", "-\t\t\t\tICompilationUnit unit = units[i];\r", "-\t\t\t\tString fileName = unit.getElementName();\r", "-\t\t\t\t/* see if a source entry exists for this file name */\r", "-\t\t\t\tif (entryTable.get(fileName) == null) {\r", "+\t\t\tICompilationUnit[] units= frag.getCompilationUnits();\r", "+\t\t\tfor (int i= 0; i < units.length; ++i) {\r", "+\t\t\t\tICompilationUnit unit= units[i];\r", "+\t\t\t\tString fileName= unit.getElementName();\r", "+\t\t\t\t// get the corresponding .class file name\r", "+\t\t\t\tString classFileName = \"\";\r", "+\t\t\t\tif (Util.isJavaFileName(fileName)) { // paranoia check\r", "+\t\t\t\t\tclassFileName = fileName.substring(0, fileName.length()-5).concat(\".class\");\r", "+\t\t\t\t}\r", "+\t\t\t\t// see if a source entry exists for this file name\r", "+\t\t\t\t// or for the corresponding .class file\r", "+\t\t\t\tif (entryTable.get(fileName) == null && entryTable.get(classFileName) == null) {\r", "-\t\t\t\t\t\tentryPath = path;\r", "+\t\t\t\t\t\tentryPath= path;\r", "-\t\t\t\t\t\tzipEntryFileName = fileName;\r", "+\t\t\t\t\t\tzipEntryFileName= fileName;\r", "-\t\t\t\t\t\tentryPath = unit.getUnderlyingResource().getFullPath();\r", "+\t\t\t\t\t\tentryPath= unit.getUnderlyingResource().getFullPath();\r", "-\t\t\t\t\t\tzipEntryFileName = null;\r", "+\t\t\t\t\t\tzipEntryFileName= null;\r", "-\t\t\t\t\tSourceEntry sEntry = new SourceEntry(entryPath, zipEntryPath, zipEntryFileName);\r", "+\t\t\t\t\tSourceEntry sEntry= new SourceEntry(entryPath, zipEntryPath, zipEntryFileName);\r", "-\t\t\tIClassFile[] classFiles = frag.getClassFiles();\r", "-\t\t\tfor (int i = 0; i < classFiles.length; ++i) {\r", "-\t\t\t\tIClassFile classFile = classFiles[i];\r", "-\t\t\t\tString fileName = classFile.getElementName();\r", "-\t\t\t\t/* see if a source entry exists for this file name */\r", "-\t\t\t\tif (entryTable.get(fileName) == null) {\r", "+\t\t\tIClassFile[] classFiles= frag.getClassFiles();\r", "+\t\t\tfor (int i= 0; i < classFiles.length; ++i) {\r", "+\t\t\t\tIClassFile classFile= classFiles[i];\r", "+\t\t\t\tString fileName= classFile.getElementName();\r", "+\t\t\t\t// get the corresponding .java file name\r", "+\t\t\t\t// note: this handles nested types, but not secondary types (e.g. class B defined in A.java)\r", "+\t\t\t\tString javaFileName = \"\";\r", "+\t\t\t\tif (Util.isClassFileName(fileName)) { // paranoia check\r", "+\t\t\t\t\t// strip off any nested types\r", "+\t\t\t\t\tjavaFileName = fileName.substring(0, fileName.length()-6);\r", "+\t\t\t\t\tint dol = javaFileName.indexOf('$');\r", "+\t\t\t\t\tif (dol != -1) {\r", "+\t\t\t\t\t\tjavaFileName = javaFileName.substring(0, dol);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tjavaFileName = javaFileName.concat(\".java\");\r", "+\t\t\t\t}\r", "+\t\t\t\t// see if a source entry exists for this file name\r", "+\t\t\t\t// or for the corresponding .java file\r", "+\t\t\t\tif (entryTable.get(fileName) == null && entryTable.get(javaFileName) == null) {\r", "-\t\t\t\t\t\tentryPath = path;\r", "+\t\t\t\t\t\tentryPath= path;\r", "-\t\t\t\t\t\tzipEntryFileName = fileName;\r", "+\t\t\t\t\t\tzipEntryFileName= fileName;\r", "-\t\t\t\t\t\tentryPath = classFile.getUnderlyingResource().getFullPath();\r", "+\t\t\t\t\t\tentryPath= classFile.getUnderlyingResource().getFullPath();\r", "-\t\t\t\t\t\tzipEntryFileName = null;\r", "+\t\t\t\t\t\tzipEntryFileName= null;\r", "-\t\t\t\t\tSourceEntry sEntry = new SourceEntry(entryPath, zipEntryPath, zipEntryFileName);\r", "+\t\t\t\t\tSourceEntry sEntry= new SourceEntry(entryPath, zipEntryPath, zipEntryFileName);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cba0e05bd7f2939eb263e63f0b3f50f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/IncrementalImageBuilder.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \tprotected void computeNamespaceChanges()", "signatureAfterChange": "\r protected void computeNamespaceChanges()", "diff": ["+ */\r", "+protected void computeNamespaceChanges() {\r", "-\t */\r", "-\tprotected void computeNamespaceChanges() {\r", "-\r", "-\t\tfor (Enumeration e = fSourceDeltas.elements(); e.hasMoreElements();) {\r", "-\t\t\tIResourceDelta delta = (IResourceDelta) e.nextElement();\r", "-\t\t\tJavaModelManager.getJavaModelManager().closeAffectedElements(delta);\r", "-\t\t}\r", "-\r", "-\t\t// Should really only process packages in image context here,\r", "-\t\t// but in general other packages may depend on namespaces being added, \r", "-\t\t// not just those being removed and changed.  So for now, process everything.\r", "-\r", "-\t\t// The computations here must be based on the computed namespaces rather than\r", "-\t\t// directly off of the namespace contributions of affected source elements\r", "-\t\t// since the namespace computation may remove items due to conflicts.\r", "-\r", "-\t\tint numPackages =\r", "-\t\t\tfAddedPackageHandles.size()\r", "-\t\t\t\t+ fRemovedPackageHandles.size()\r", "-\t\t\t\t+ fChangedPackageHandles.size();\r", "-\t\tif (numPackages == 0) {\r", "-\t\t\tfNotifier.updateProgressDelta(0.10f);\r", "-\t\t\treturn;\r", "-\t\t}\r", "-\t\tfloat progressDelta = 0.10f / numPackages;\r", "-\r", "-\t\t// Process changes in the set of package prefixes\r", "-\t\tif (fAddedPackageHandles.size() > 0 || fRemovedPackageHandles.size() > 0) {\r", "-\t\t\tcomputePackagePrefixChanges();\r", "-\t\t}\r", "-\r", "-\t\t// Process added packages\r", "-\t\tfor (Enumeration addedPkgs = fAddedPackageHandles.elements();\r", "-\t\t\taddedPkgs.hasMoreElements();\r", "-\t\t\t) {\r", "-\t\t\tIPackage pkg = (IPackage) addedPkgs.nextElement();\r", "-\t\t\tfNotifier.subTask(\"Analyzing \" + PackageImpl.readableName(pkg));\r", "-\r", "-\t\t\t// Mark all dependents of missing namespace as needing compile.\r", "-\t\t\tmarkDependentsAsNeedingCompile(pkg);\r", "-\r", "-\t\t\t// If any types currently exist with the same name as this package,\r", "-\t\t\t// they must be recompiled\r", "-\t\t\tmarkOverlappingTypesAsNeedingCompile(pkg);\r", "-\t\t\tfNotifier.updateProgressDelta(progressDelta);\r", "-\t\t\tfNotifier.checkCancel();\r", "-\t\t}\r", "-\r", "-\t\t// Process removed packages\r", "-\t\tfor (Enumeration removedPkgs = fRemovedPackageHandles.elements();\r", "-\t\t\tremovedPkgs.hasMoreElements();\r", "-\t\t\t) {\r", "-\t\t\tIPackage pkg = (IPackage) removedPkgs.nextElement();\r", "-\t\t\tfNotifier.subTask(\"Analyzing \" + PackageImpl.readableName(pkg));\r", "-\r", "-\t\t\t// Mark all dependents of namespace as needing compile.\r", "-\t\t\tmarkDependentsAsNeedingCompile(pkg);\r", "-\r", "-\t\t\t// If any types currently exist with the same name as this package,\r", "-\t\t\t// they must be recompiled\r", "-\t\t\tmarkOverlappingTypesAsNeedingCompile(pkg);\r", "-\t\t\tfNotifier.updateProgressDelta(progressDelta);\r", "-\t\t\tfNotifier.checkCancel();\r", "-\t\t}\r", "-\r", "-\t\t// Process changed packages\r", "-\t\tfor (Enumeration changedPkgs = fChangedPackageHandles.elements();\r", "-\t\t\tchangedPkgs.hasMoreElements();\r", "-\t\t\t) {\r", "-\t\t\tIPackage pkg = (IPackage) changedPkgs.nextElement();\r", "-\t\t\tfNotifier.subTask(\"Analyzing \" + PackageImpl.readableName(pkg));\r", "-\t\t\tcomputeNamespaceChanges(pkg);\r", "-\t\t\tfNotifier.updateProgressDelta(progressDelta);\r", "-\t\t\tfNotifier.checkCancel();\r", "-\t\t}\r", "+\tfor (Enumeration e = fSourceDeltas.elements(); e.hasMoreElements();) {\r", "+\t\tIResourceDelta delta = (IResourceDelta) e.nextElement();\r", "+\t\tJavaModelManager.getJavaModelManager().closeAffectedElements(delta);\r", "+\t// Should really only process packages in image context here,\r", "+\t// but in general other packages may depend on namespaces being added, \r", "+\t// not just those being removed and changed.  So for now, process everything.\r", "+\r", "+\t// The computations here must be based on the computed namespaces rather than\r", "+\t// directly off of the namespace contributions of affected source elements\r", "+\t// since the namespace computation may remove items due to conflicts.\r", "+\r", "+\tint numPackages = fAddedPackageHandles.size() + fRemovedPackageHandles.size() + fChangedPackageHandles.size();\r", "+\tif (numPackages == 0) {\r", "+\t\tfNotifier.updateProgressDelta(0.10f);\r", "+\t\treturn;\r", "+\t}\r", "+\tfloat progressDelta = 0.10f / numPackages;\r", "+\r", "+\t// Process changes in the set of package prefixes\r", "+\tif (fAddedPackageHandles.size() > 0 || fRemovedPackageHandles.size() > 0) {\r", "+\t\tcomputePackagePrefixChanges();\r", "+\t// Process added packages\r", "+\tfor (Enumeration addedPkgs = fAddedPackageHandles.elements(); addedPkgs.hasMoreElements();) {\r", "+\t\tIPackage pkg = (IPackage) addedPkgs.nextElement();\r", "+\t\tfNotifier.subTask(Util.bind(\"build.analyzing\"/*nonNLS*/, PackageImpl.readableName(pkg)));\r", "+\r", "+\t\t// Mark all dependents of missing namespace as needing compile.\r", "+\t\tmarkDependentsAsNeedingCompile(pkg);\r", "+\r", "+\t\t// If any types currently exist with the same name as this package,\r", "+\t\t// they must be recompiled\r", "+\t\tmarkOverlappingTypesAsNeedingCompile(pkg);\r", "+\t\tfNotifier.updateProgressDelta(progressDelta);\r", "+\t\tfNotifier.checkCancel();\r", "+\t}\r", "+\r", "+\t// Process removed packages\r", "+\tfor (Enumeration removedPkgs = fRemovedPackageHandles.elements(); removedPkgs.hasMoreElements();) {\r", "+\t\tIPackage pkg = (IPackage) removedPkgs.nextElement();\r", "+\t\tfNotifier.subTask(Util.bind(\"build.analyzing\"/*nonNLS*/, PackageImpl.readableName(pkg)));\r", "+\r", "+\t\t// Mark all dependents of namespace as needing compile.\r", "+\t\tmarkDependentsAsNeedingCompile(pkg);\r", "+\r", "+\t\t// If any types currently exist with the same name as this package,\r", "+\t\t// they must be recompiled\r", "+\t\tmarkOverlappingTypesAsNeedingCompile(pkg);\r", "+\t\tfNotifier.updateProgressDelta(progressDelta);\r", "+\t\tfNotifier.checkCancel();\r", "+\t}\r", "+\r", "+\t// Process changed packages\r", "+\tfor (Enumeration changedPkgs = fChangedPackageHandles.elements(); changedPkgs.hasMoreElements();) {\r", "+\t\tIPackage pkg = (IPackage) changedPkgs.nextElement();\r", "+\t\tfNotifier.subTask(Util.bind(\"build.analyzing\"/*nonNLS*/, PackageImpl.readableName(pkg)));\r", "+\t\tcomputeNamespaceChanges(pkg);\r", "+\t\tfNotifier.updateProgressDelta(progressDelta);\r", "+\t\tfNotifier.checkCancel();\r", "+\t}\r", "+}\r"]}], "num": 36108}