{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "61c16ace50e7c59726bb93112325803b", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0339fc7d8f8be0120db01c9df89a437c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java", "commitBeforeChange": "d827489386a0080be2baf2be380c0f3630a2f239", "commitAfterChange": "b0e22c1c1f34d79e167c112a42cdff6b01498911", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "+\t// process the condition", "+\tFlowInfo conditionFlowInfo = this.condition.analyseCode(currentScope, flowContext, flowInfo);", "+\tint initialComplaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;", "+", "+\tConstant cst = this.condition.optimizedBooleanConstant();", "+\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "+", "+\t// process the THEN part", "+\tFlowInfo thenFlowInfo = conditionFlowInfo.safeInitsWhenTrue();", "+\tif (isConditionOptimizedFalse) {", "+\t\tthenFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\tFlowInfo elseFlowInfo = conditionFlowInfo.initsWhenFalse();", "+\tif (isConditionOptimizedTrue) {", "+\t\telseFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "-", "-\tpublic FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "-\t\t// process the condition", "-\t\tFlowInfo conditionFlowInfo = this.condition.analyseCode(currentScope, flowContext, flowInfo);", "-\t\tint initialComplaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;", "-", "-\t\tConstant cst = this.condition.optimizedBooleanConstant();", "-\t\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "-", "-\t\t// process the THEN part", "-\t\tFlowInfo thenFlowInfo = conditionFlowInfo.safeInitsWhenTrue();", "+\tif (this.thenStatement != null) {", "+\t\t// Save info for code gen", "+\t\tthis.thenInitStateIndex = currentScope.methodScope().recordInitializationStates(thenFlowInfo);", "-\t\t\tthenFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t}", "-\t\tFlowInfo elseFlowInfo = conditionFlowInfo.initsWhenFalse();", "-\t\tif (isConditionOptimizedTrue) {", "-\t\t\telseFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t}", "-\t\tif (this.thenStatement != null) {", "-\t\t\t// Save info for code gen", "-\t\t\tthis.thenInitStateIndex = currentScope.methodScope().recordInitializationStates(thenFlowInfo);", "-\t\t\tif (this.thenStatement.complainIfUnreachable(thenFlowInfo, currentScope, initialComplaintLevel) < Statement.COMPLAINED_UNREACHABLE) {", "-\t\t\t\tthenFlowInfo = this.thenStatement.analyseCode(currentScope, flowContext, thenFlowInfo);", "+\t\t\tif (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {", "+\t\t\t\tthis.thenStatement.complainIfUnreachable(thenFlowInfo, currentScope, initialComplaintLevel);", "-\t\t// code gen: optimizing the jump around the ELSE part", "-\t\tif ((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) {", "-\t\t\tthis.bits |= ASTNode.ThenExit;", "-\t\t}", "-", "-\t\t// process the ELSE part", "-\t\tif (this.elseStatement != null) {", "-\t\t    // signal else clause unnecessarily nested, tolerate else-if code pattern", "-\t\t    if (thenFlowInfo == FlowInfo.DEAD_END", "-\t\t            && (this.bits & IsElseIfStatement) == 0 \t// else of an else-if", "-\t\t            && !(this.elseStatement instanceof IfStatement)) {", "-\t\t        currentScope.problemReporter().unnecessaryElse(this.elseStatement);", "-\t\t    }", "-\t\t\t// Save info for code gen", "-\t\t\tthis.elseInitStateIndex = currentScope.methodScope().recordInitializationStates(elseFlowInfo);", "-\t\t\tif (this.elseStatement.complainIfUnreachable(elseFlowInfo, currentScope, initialComplaintLevel) < Statement.COMPLAINED_UNREACHABLE) {", "-\t\t\t\telseFlowInfo = this.elseStatement.analyseCode(currentScope, flowContext, elseFlowInfo);", "-\t\t\t}", "-\t\t}", "-", "-\t\t// merge THEN & ELSE initializations", "-\t\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "-\t\t\tthenFlowInfo,", "-\t\t\tisConditionOptimizedTrue,", "-\t\t\telseFlowInfo,", "-\t\t\tisConditionOptimizedFalse,", "-\t\t\ttrue /*if(true){ return; }  fake-reachable(); */);", "-\t\tthis.mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\treturn mergedInfo;", "+\t\tthenFlowInfo = this.thenStatement.analyseCode(currentScope, flowContext, thenFlowInfo);", "+\t}", "+\t// code gen: optimizing the jump around the ELSE part", "+\tif ((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) {", "+\t\tthis.bits |= ASTNode.ThenExit;", "+\t// process the ELSE part", "+\tif (this.elseStatement != null) {", "+\t    // signal else clause unnecessarily nested, tolerate else-if code pattern", "+\t    if (thenFlowInfo == FlowInfo.DEAD_END", "+\t            && (this.bits & IsElseIfStatement) == 0 \t// else of an else-if", "+\t            && !(this.elseStatement instanceof IfStatement)) {", "+\t        currentScope.problemReporter().unnecessaryElse(this.elseStatement);", "+\t    }", "+\t\t// Save info for code gen", "+\t\tthis.elseInitStateIndex = currentScope.methodScope().recordInitializationStates(elseFlowInfo);", "+\t\tif (isConditionOptimizedTrue) {", "+\t\t\tif (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {", "+\t\t\t\tthis.elseStatement.complainIfUnreachable(elseFlowInfo, currentScope, initialComplaintLevel);", "+\t\t\t}", "+\t\telseFlowInfo = this.elseStatement.analyseCode(currentScope, flowContext, elseFlowInfo);", "+\t}", "+\t// merge THEN & ELSE initializations", "+\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "+\t\tthenFlowInfo,", "+\t\tisConditionOptimizedTrue,", "+\t\telseFlowInfo,", "+\t\tisConditionOptimizedFalse,", "+\t\ttrue /*if(true){ return; }  fake-reachable(); */);", "+\tthis.mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "+\treturn mergedInfo;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb4a8fbb15cd6980d631a73f00d0e253", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java", "commitBeforeChange": "babe82af3726a6979eb5da4c747f51906154b2bc", "commitAfterChange": "fab4ac0c2a45db58d02407ad5972d843c8dba1e6", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\tpublic FlowInfo analyseCode(", "-\t\tBlockScope currentScope,", "-\t\tFlowContext flowContext,", "-\t\tFlowInfo flowInfo) {", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "+\tthis.breakLabel = new BranchLabel();", "+\tthis.continueLabel = new BranchLabel();", "+\tLoopingFlowContext loopingContext =", "+\t\tnew LoopingFlowContext(", "+\t\t\tflowContext,", "+\t\t\tflowInfo,", "+\t\t\tthis,", "+\t\t\tthis.breakLabel,", "+\t\t\tthis.continueLabel,", "+\t\t\tcurrentScope);", "-\t\tbreakLabel = new BranchLabel();", "-\t\tcontinueLabel = new BranchLabel();", "-\t\tLoopingFlowContext loopingContext =", "-\t\t\tnew LoopingFlowContext(", "-\t\t\t\tflowContext,", "-\t\t\t\tflowInfo,", "-\t\t\t\tthis,", "-\t\t\t\tbreakLabel,", "-\t\t\t\tcontinueLabel,", "-\t\t\t\tcurrentScope);", "+\tConstant cst = this.condition.constant;", "+\tboolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\tcst = this.condition.optimizedBooleanConstant();", "+\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "-\t\tConstant cst = condition.constant;", "-\t\tboolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\tcst = condition.optimizedBooleanConstant();", "-\t\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "+\tint previousMode = flowInfo.reachMode();", "+\t\t\t", "+\tUnconditionalFlowInfo actionInfo = flowInfo.nullInfoLessUnconditionalCopy();", "+\t// we need to collect the contribution to nulls of the coming paths through the", "+\t// loop, be they falling through normally or branched to break, continue labels", "+\t// or catch blocks", "+\tif ((this.action != null) && !this.action.isEmptyBlock()) {", "+\t\tactionInfo = this.action.", "+\t\t\tanalyseCode(currentScope, loopingContext, actionInfo).", "+\t\t\tunconditionalInits();", "-\t\tint previousMode = flowInfo.reachMode();", "-\t\t\t\t", "-\t\tUnconditionalFlowInfo actionInfo = flowInfo.nullInfoLessUnconditionalCopy();", "-\t\t// we need to collect the contribution to nulls of the coming paths through the", "-\t\t// loop, be they falling through normally or branched to break, continue labels", "-\t\t// or catch blocks", "-\t\tif ((action != null) && !action.isEmptyBlock()) {", "-\t\t\tactionInfo = action.", "-\t\t\t\tanalyseCode(currentScope, loopingContext, actionInfo).", "-\t\t\t\tunconditionalInits();", "-", "-\t\t\t// code generation can be optimized when no need to continue in the loop", "-\t\t\tif ((actionInfo.tagBits & ", "-\t\t\t\t\tloopingContext.initsOnContinue.tagBits & ", "-\t\t\t\t\tFlowInfo.UNREACHABLE) != 0) {", "-\t\t\t\tcontinueLabel = null;", "-\t\t\t}", "+\t\t// code generation can be optimized when no need to continue in the loop", "+\t\tif ((actionInfo.tagBits & ", "+\t\t\t\tloopingContext.initsOnContinue.tagBits & ", "+\t\t\t\tFlowInfo.UNREACHABLE) != 0) {", "+\t\t\tthis.continueLabel = null;", "-\t\t/* Reset reach mode, to address following scenario.", "-\t\t *   final blank;", "-\t\t *   do { if (true) break; else blank = 0; } while(false);", "-\t\t *   blank = 1; // may be initialized already ", "-\t\t */", "-\t\tactionInfo.setReachMode(previousMode);", "-\t\t", "-\t\tLoopingFlowContext condLoopContext;", "-\t\tFlowInfo condInfo =", "-\t\t\tcondition.analyseCode(", "-\t\t\t\tcurrentScope,", "-\t\t\t\t(condLoopContext =", "-\t\t\t\t\tnew LoopingFlowContext(flowContext,\tflowInfo, this, null, ", "-\t\t\t\t\t\tnull, currentScope)),", "-\t\t\t\t(action == null", "-\t\t\t\t\t? actionInfo", "-\t\t\t\t\t: (actionInfo.mergedWith(loopingContext.initsOnContinue))).copy());", "-\t\tif (!isConditionOptimizedFalse && continueLabel != null) {", "-\t\t\tloopingContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "-\t\t\tcondLoopContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "-\t\t\tUnconditionalFlowInfo checkFlowInfo;", "-\t\t\tloopingContext.complainOnDeferredNullChecks(currentScope, ", "-\t\t\t\t\tcheckFlowInfo = actionInfo.", "-\t\t\t\t\t\taddPotentialNullInfoFrom(", "-\t\t\t\t\t\t  condInfo.initsWhenTrue().unconditionalInits()));", "-\t\t\tcondLoopContext.complainOnDeferredNullChecks(currentScope, ", "-\t\t\t\t\tcheckFlowInfo);", "-\t\t}", "-", "-\t\t// end of loop", "-\t\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "-\t\t\t\t(loopingContext.initsOnBreak.tagBits &", "-\t\t\t\t\tFlowInfo.UNREACHABLE) != 0 ?", "-\t\t\t\t\tloopingContext.initsOnBreak :", "-\t\t\t\t\tflowInfo.unconditionalCopy().addInitializationsFrom(loopingContext.initsOnBreak), ", "-\t\t\t\t\t\t// recover upstream null info", "-\t\t\t\tisConditionOptimizedTrue,", "-\t\t\t\t(condInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ?", "-\t\t\t\t\t\tflowInfo.addInitializationsFrom(condInfo.initsWhenFalse()) : condInfo, ", "-\t\t\t\t\t// recover null inits from before condition analysis", "-\t\t\t\tfalse, // never consider opt false case for DO loop, since break can always occur (47776)", "-\t\t\t\t!isConditionTrue /*do{}while(true); unreachable(); */);", "-\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\treturn mergedInfo;", "+\t/* Reset reach mode, to address following scenario.", "+\t *   final blank;", "+\t *   do { if (true) break; else blank = 0; } while(false);", "+\t *   blank = 1; // may be initialized already ", "+\tactionInfo.setReachMode(previousMode);", "+\t", "+\tLoopingFlowContext condLoopContext;", "+\tFlowInfo condInfo =", "+\t\tthis.condition.analyseCode(", "+\t\t\tcurrentScope,", "+\t\t\t(condLoopContext =", "+\t\t\t\tnew LoopingFlowContext(flowContext,\tflowInfo, this, null, ", "+\t\t\t\t\tnull, currentScope)),", "+\t\t\t(this.action == null", "+\t\t\t\t? actionInfo", "+\t\t\t\t: (actionInfo.mergedWith(loopingContext.initsOnContinue))).copy());", "+\tif (!isConditionOptimizedFalse && this.continueLabel != null) {", "+\t\tloopingContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "+\t\tcondLoopContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "+\t\tUnconditionalFlowInfo checkFlowInfo;", "+\t\tloopingContext.complainOnDeferredNullChecks(currentScope, ", "+\t\t\t\tcheckFlowInfo = actionInfo.", "+\t\t\t\t\taddPotentialNullInfoFrom(", "+\t\t\t\t\t  condInfo.initsWhenTrue().unconditionalInits()));", "+\t\tcondLoopContext.complainOnDeferredNullChecks(currentScope, ", "+\t\t\t\tcheckFlowInfo);", "+\t// end of loop", "+\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "+\t\t\t(loopingContext.initsOnBreak.tagBits &", "+\t\t\t\tFlowInfo.UNREACHABLE) != 0 ?", "+\t\t\t\tloopingContext.initsOnBreak :", "+\t\t\t\tflowInfo.unconditionalCopy().addInitializationsFrom(loopingContext.initsOnBreak), ", "+\t\t\t\t\t// recover upstream null info", "+\t\t\tisConditionOptimizedTrue,", "+\t\t\t(condInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ?", "+\t\t\t\t\tflowInfo.addInitializationsFrom(condInfo.initsWhenFalse()) : condInfo, ", "+\t\t\t\t// recover null inits from before condition analysis", "+\t\t\tfalse, // never consider opt false case for DO loop, since break can always occur (47776)", "+\t\t\t!isConditionTrue /*do{}while(true); unreachable(); */);", "+\tthis.mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "+\treturn mergedInfo;", "+}"]}], "num": 9111}