{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c95784bf3e043df45c3b7449ba8953ff", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "de7aa2502fca958733903404395cd169", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "e96b81a52412e43aed69f6e87de2caadbf8506ca", "commitAfterChange": "5b1750b71e3273cfdbb40314841207d241dd1ece", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tif (anonymousType == null && enclosingInstance == null)", "+\t\t// added for code assist...cannot occur with 'normal' code", "+\t\tif (anonymousType == null && enclosingInstance == null) {", "-\t\t// added for code assist... is not possible with 'normal' code", "+\t\t}", "-", "-\t\tTypeBinding enclosingInstTb = null;", "-\t\tTypeBinding recType;", "-\t\tif (anonymousType == null) {", "-\t\t\t//----------------no anonymous class------------------------\t", "-\t\t\tif ((enclosingInstTb = enclosingInstance.resolveType(scope)) == null)", "-\t\t\t\treturn null;", "-\t\t\tif (enclosingInstTb.isBaseType() | enclosingInstTb.isArrayType()) {", "+\t\tTypeBinding enclosingInstanceType = null;", "+\t\tTypeBinding receiverType = null;", "+\t\tboolean hasError = false;", "+\t\tif (anonymousType == null) { //----------------no anonymous class------------------------\t", "+\t\t\tif ((enclosingInstanceType = enclosingInstance.resolveType(scope)) == null){", "+\t\t\t\thasError = true;", "+\t\t\t} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {", "-\t\t\t\t\tenclosingInstTb,", "+\t\t\t\t\tenclosingInstanceType,", "-\t\t\t\treturn null;", "+\t\t\t} else if ((receiverType = ((SingleTypeReference) type).resolveTypeEnclosing(", "+\t\t\t\t\t\t\tscope,", "+\t\t\t\t\t\t\t(ReferenceBinding) enclosingInstanceType)) == null) {", "+\t\t\t\thasError = true;", "-\t\t\trecType =", "-\t\t\t\t((SingleTypeReference) type).resolveTypeEnclosing(", "-\t\t\t\t\tscope,", "-\t\t\t\t\t(ReferenceBinding) enclosingInstTb);", "-\t\t\t\tboolean argHasError = false;", "-\t\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)", "-\t\t\t\t\t\targHasError = true;", "-\t\t\t\tif (argHasError)", "-\t\t\t\t\treturn recType;", "+\t\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null){", "+\t\t\t\t\t\thasError = true;", "+\t\t\t\t\t}", "-\t\t\tif (recType == null)", "-\t\t\t\treturn null;", "-\t\t\tif (!recType.canBeInstantiated()) {", "-\t\t\t\tscope.problemReporter().cannotInstantiate(type, recType);", "-\t\t\t\treturn recType;", "+\t\t\t// limit of fault-tolerance", "+\t\t\tif (hasError) {", "+\t\t\t\t\treturn receiverType;", "+\t\t\t}", "+\t\t\tif (!receiverType.canBeInstantiated()) {", "+\t\t\t\tscope.problemReporter().cannotInstantiate(type, receiverType);", "+\t\t\t\treturn receiverType;", "-\t\t\t\tscope.getConstructor((ReferenceBinding) recType, argumentTypes, this))", "+\t\t\t\tscope.getConstructor((ReferenceBinding) receiverType, argumentTypes, this))", "-\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) recType;", "+\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) receiverType;", "-\t\t\t\treturn recType;", "+\t\t\t\treturn receiverType;", "-\t\t\tif (Scope.areTypesCompatible(enclosingInstTb, expectedType))", "-\t\t\t\treturn recType;", "+\t\t\tif (Scope.areTypesCompatible(enclosingInstanceType, expectedType))", "+\t\t\t\treturn receiverType;", "-\t\t\t\tenclosingInstTb,", "+\t\t\t\tenclosingInstanceType,", "-\t\t\treturn recType;", "+\t\t\treturn receiverType;", "-\t\t\tif ((enclosingInstTb = enclosingInstance.resolveType(scope)) == null)", "-\t\t\t\treturn null;", "-\t\t\tif (enclosingInstTb.isBaseType() | enclosingInstTb.isArrayType()) {", "+\t\t\tif ((enclosingInstanceType = enclosingInstance.resolveType(scope)) == null) {", "+\t\t\t\thasError = true;", "+\t\t\t} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {", "-\t\t\t\t\tenclosingInstTb,", "+\t\t\t\t\tenclosingInstanceType,", "-\t\t\t\treturn null;", "+\t\t\t\thasError = true;", "+\t\t\t} else {", "+\t\t\t\treceiverType = ((SingleTypeReference) type).resolveTypeEnclosing(", "+\t\t\t\t\t\t\t\t\t\tscope,", "+\t\t\t\t\t\t\t\t\t\t(ReferenceBinding) enclosingInstanceType);\t\t\t\t", "+\t\t} else {", "+\t\t\treceiverType = type.resolveType(scope);", "-\t\t// due to syntax-construction, recType is a ReferenceBinding\t\t", "-\t\trecType =", "-\t\t\t(enclosingInstance == null)", "-\t\t\t\t? type.resolveType(scope)", "-\t\t\t\t: ((SingleTypeReference) type).resolveTypeEnclosing(", "-\t\t\t\t\tscope,", "-\t\t\t\t\t(ReferenceBinding) enclosingInstTb);", "-\t\tif (recType == null)", "-\t\t\treturn null;", "-\t\tif (((ReferenceBinding) recType).isFinal()) {", "-\t\t\tscope.problemReporter().anonymousClassCannotExtendFinalClass(type, recType);", "-\t\t\treturn null;", "+\t\tif (receiverType == null) {", "+\t\t\thasError = true;", "+\t\t} else if (((ReferenceBinding) receiverType).isFinal()) {", "+\t\t\tscope.problemReporter().anonymousClassCannotExtendFinalClass(type, receiverType);", "+\t\t\thasError = true;", "-\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)", "-\t\t\t\t\treturn null;", "+\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null) {", "+\t\t\t\t\thasError = true;", "+\t\t\t\t}", "+\t\t}", "+\t\t// limit of fault-tolerance", "+\t\tif (hasError) {", "+\t\t\t\treturn receiverType;", "-\t\t\trecType.isInterface() ? scope.getJavaLangObject() : (ReferenceBinding) recType;", "+\t\t\treceiverType.isInterface() ? scope.getJavaLangObject() : (ReferenceBinding) receiverType;", "-\t\t\t\t\tenclosingInstTb,", "+\t\t\t\t\tenclosingInstanceType,", "-\t\t\t\t\tenclosingInstTb,", "+\t\t\t\t\tenclosingInstanceType,", "-\t\tscope.addAnonymousType(anonymousType, (ReferenceBinding) recType);", "+\t\tscope.addAnonymousType(anonymousType, (ReferenceBinding) receiverType);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e16e32c31ab4798361f7fa3d7e38947b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "6d3fe5277decae5e3a5511d22405bbe1fbb97924", "commitAfterChange": "5bcc7ea24a8cf84eab4e39ad9a998ea7bce03b7a", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tif (anonymousType == null) { //----------------no anonymous class------------------------\t", "+\t\t", "+\t\tif (enclosingInstance != null) {", "-\t\t\t\tif (receiverType == null) {", "-\t\t\t\t\thasError = true;", "-\t\t\t\t} else {", "-\t\t\t\t\tif (enclosingInstanceContainsCast) {", "+\t\t\t\tif (receiverType != null && enclosingInstanceContainsCast) {", "-\t\t\t\t\t}", "-\t\t\t// will check for null after args are resolved", "-\t\t\tTypeBinding[] argumentTypes = NoParameters;", "-\t\t\tif (arguments != null) {", "-\t\t\t\tint length = arguments.length;", "-\t\t\t\targumentTypes = new TypeBinding[length];", "-\t\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\t\tExpression argument = this.arguments[i];", "-\t\t\t\t\tif (argument instanceof CastExpression) {", "-\t\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "-\t\t\t\t\t\targsContainCast = true;", "-\t\t\t\t\t}", "-\t\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null){", "-\t\t\t\t\t\thasError = true;", "-\t\t\t\t\t}", "+\t\t} else {", "+\t\t\treceiverType = type.resolveType(scope);", "+\t\t}", "+\t\tif (receiverType == null) {", "+\t\t\thasError = true;", "+\t\t} else if (((ReferenceBinding) receiverType).isFinal() && this.anonymousType != null) {", "+\t\t\tscope.problemReporter().anonymousClassCannotExtendFinalClass(type, receiverType);", "+\t\t\thasError = true;", "+\t\t}", "+", "+\t\t// will check for null after args are resolved", "+\t\tTypeBinding[] argumentTypes = NoParameters;", "+\t\tif (arguments != null) {", "+\t\t\tint length = arguments.length;", "+\t\t\targumentTypes = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\t\targsContainCast = true;", "+\t\t\t\t}", "+\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null){", "+\t\t\t\t\thasError = true;", "-\t\t\t// limit of fault-tolerance", "-\t\t\tif (hasError) return receiverType;", "+\t\t}", "+\t\t// limit of fault-tolerance", "+\t\tif (hasError) return this.resolvedType = receiverType;", "+\t\t", "+\t\tif (this.anonymousType == null) {", "+\t\t\t// qualified allocation with no anonymous type", "-\t\t//--------------there is an anonymous type declaration-----------------", "-\t\tif (this.enclosingInstance != null) {", "-\t\t\tif (enclosingInstance instanceof CastExpression) {", "-\t\t\t\tenclosingInstance.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "-\t\t\t\tenclosingInstanceContainsCast = true;", "-\t\t\t}", "-\t\t\tif ((enclosingInstanceType = this.enclosingInstance.resolveType(scope)) == null) {", "-\t\t\t\thasError = true;", "-\t\t\t} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {", "-\t\t\t\tscope.problemReporter().illegalPrimitiveOrArrayTypeForEnclosingInstance(", "-\t\t\t\t\tenclosingInstanceType,", "-\t\t\t\t\tthis.enclosingInstance);", "-\t\t\t\thasError = true;", "-\t\t\t} else {", "-\t\t\t\treceiverType = ((SingleTypeReference) type).resolveTypeEnclosing(", "-\t\t\t\t\t\t\t\t\t\tscope,", "-\t\t\t\t\t\t\t\t\t\t(ReferenceBinding) enclosingInstanceType);\t\t\t\t", "-\t\t\t\tif (enclosingInstanceContainsCast) {", "-\t\t\t\t\tCastExpression.checkNeedForEnclosingInstanceCast(scope, enclosingInstance, enclosingInstanceType, receiverType);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} else {", "-\t\t\treceiverType = type.resolveType(scope);", "-\t\t}", "-\t\tif (receiverType == null) {", "-\t\t\thasError = true;", "-\t\t} else if (((ReferenceBinding) receiverType).isFinal()) {", "-\t\t\tscope.problemReporter().anonymousClassCannotExtendFinalClass(type, receiverType);", "-\t\t\thasError = true;", "-\t\t}", "-\t\tTypeBinding[] argumentTypes = NoParameters;", "-\t\tif (arguments != null) {", "-\t\t\tint length = arguments.length;", "-\t\t\targumentTypes = new TypeBinding[length];", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tExpression argument = this.arguments[i];", "-\t\t\t\tif (argument instanceof CastExpression) {", "-\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "-\t\t\t\t\targsContainCast = true;", "-\t\t\t\t}", "-\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null) {", "-\t\t\t\t\thasError = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t// limit of fault-tolerance", "-\t\tif (hasError) {", "-\t\t\treturn this.resolvedType = receiverType;", "-\t\t}", "-", "+\t\t// anonymous type scenario", "-\t\tthis.superTypeBinding =", "-\t\t\treceiverType.isInterface() ? scope.getJavaLangObject() : (ReferenceBinding) receiverType;", "-\t\tMethodBinding inheritedBinding =", "-\t\t\tscope.getConstructor(this.superTypeBinding, argumentTypes, this);", "+\t\tthis.superTypeBinding = receiverType.isInterface() ? scope.getJavaLangObject() : (ReferenceBinding) receiverType;", "+\t\t// insert anonymous type in scope", "+\t\tscope.addAnonymousType(this.anonymousType, (ReferenceBinding) receiverType);", "+\t\tthis.anonymousType.resolve(scope);\t\t", "+\t\t", "+\t\t// find anonymous super constructor", "+\t\tMethodBinding inheritedBinding = scope.getConstructor(this.superTypeBinding, argumentTypes, this);", "-\t\t\treturn null;", "+\t\t\treturn this.resolvedType = anonymousType.binding;", "-\t\t\t\treturn null;", "+\t\t\t\treturn this.resolvedType = anonymousType.binding;", "-\t\tscope.addAnonymousType(anonymousType, (ReferenceBinding) receiverType);", "-\t\tanonymousType.resolve(scope);"]}], "num": 48233}