{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3629539c1d3c75b43f69267eb0d2b3d8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60d0c2961023d5bc3a70f18a16091a3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tpublic void locateMatches( \t\tString[] filePaths,  \t\tIWorkspace workspace, \t\torg.eclipse.jdt.core.ICompilationUnit[] copies) \t\tthrows JavaModelException", "signatureAfterChange": " public void locateMatches(String[] filePaths, IWorkspace workspace, org.eclipse.jdt.core.ICompilationUnit[] copies) throws JavaModelException", "diff": ["-\t */", "-\tpublic void locateMatches(", "-\t\tString[] filePaths, ", "-\t\tIWorkspace workspace,", "-\t\torg.eclipse.jdt.core.ICompilationUnit[] copies)", "-\t\tthrows JavaModelException {", "-\t\t\t", "-\t\tif (SearchEngine.VERBOSE) {", "-\t\t\tSystem.out.println(\"Locating matches in files [\"); //$NON-NLS-1$", "-\t\t\tfor (int i = 0, length = filePaths.length; i < length; i++) {", "-\t\t\t\tString path = filePaths[i];", "-\t\t\t\tSystem.out.println(\"\\t\" + path); //$NON-NLS-1$", "-\t\t\t}", "-\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "-\t\t\tif (copies != null) {", "-\t\t\t\t System.out.println(\"and working copies [\"); //$NON-NLS-1$", "-\t\t\t\tfor (int i = 0, length = copies.length; i < length; i++) {", "-\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit wc = copies[i];", "-\t\t\t\t\tSystem.out.println(\"\\t\" + ((JavaElement)wc).toStringWithAncestors()); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "-\t\t\t}", "+ */", "+public void locateMatches(String[] filePaths, IWorkspace workspace, org.eclipse.jdt.core.ICompilationUnit[] copies) throws JavaModelException {", "+\tif (SearchEngine.VERBOSE) {", "+\t\tSystem.out.println(\"Locating matches in files [\"); //$NON-NLS-1$", "+\t\tfor (int i = 0, length = filePaths.length; i < length; i++)", "+\t\t\tSystem.out.println(\"\\t\" + filePaths[i]); //$NON-NLS-1$", "+\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "+\t\tif (copies != null) {", "+\t\t\t System.out.println(\"and working copies [\"); //$NON-NLS-1$", "+\t\t\tfor (int i = 0, length = copies.length; i < length; i++)", "+\t\t\t\tSystem.out.println(\"\\t\" + ((JavaElement) copies[i]).toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "+\t\t}", "+\t}", "+", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\ttry {", "+\t\t// optimize access to zip files during search operation", "+\t\tmanager.cacheZipFiles();", "+\t\t\t", "+\t\t// initialize handle factory (used as a cache of handles so as to optimize space)", "+\t\tif (this.handleFactory == null)", "+\t\t\tthis.handleFactory = new HandleFactory(workspace);", "-\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t\ttry {", "-\t\t\t// optimize access to zip files during search operation", "-\t\t\tmanager.cacheZipFiles();", "-\t\t\t\t", "-\t\t\t// initialize handle factory (used as a cache of handles so as to optimize space)", "-\t\t\tif (this.handleFactory == null) {", "-\t\t\t\tthis.handleFactory = new HandleFactory(workspace);", "-\t\t\t}", "-\t\t\t", "-\t\t\t// initialize locator with working copies", "-\t\t\tthis.workingCopies = copies;", "-\t\t\t", "-\t\t\t// substitute compilation units with working copies", "-\t\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies", "-\t\t\tint wcLength;", "-\t\t\tif (copies != null && (wcLength = copies.length) > 0) {", "+\t\t// substitute compilation units with working copies", "+\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies", "+\t\tif ((this.workingCopies = copies) != null) {", "+\t\t\tint wcLength = this.workingCopies.length;", "+\t\t\tif (wcLength > 0) {", "-\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = copies[i];", "+\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = this.workingCopies[i];", "-\t\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);", "+\t\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength + wcLength], 0, filePathsLength);", "-\t\t\t", "-\t\t\tint length = filePaths.length;", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tif (this.pattern.mustResolve) {", "-\t\t\t\t\tprogressMonitor.beginTask(\"\", length * 10); // 1 for file path, 4 for parsing and binding creation, 5 for binding resolution //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tprogressMonitor.beginTask(\"\", length * 5); // 1 for file path, 4 for parsing and binding creation //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t}", "-\t", "-\t\t\t// sort file paths projects", "-\t\t\tUtil.sort(filePaths); ", "-\t\t\t", "-\t\t\t// initialize pattern for polymorphic search (ie. method reference pattern)", "-\t\t\tthis.matchSet = new PotentialMatchSet();", "-\t\t\tthis.pattern.initializePolymorphicSearch(this, progressMonitor);", "-\t\t\t", "-\t\t\tJavaProject previousJavaProject = null;", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {", "-\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t\t}", "-\t\t\t\tString pathString = filePaths[i];", "-\t\t\t\t", "-\t\t\t\t// skip duplicate paths", "-\t\t\t\tif (i > 0 && pathString.equals(filePaths[i-1])) continue;", "-\t\t\t\t", "-\t\t\t\tOpenable openable;", "-\t\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = (org.eclipse.jdt.core.ICompilationUnit)wcPaths.get(pathString);", "-\t\t\t\tif (workingCopy != null) {", "-\t\t\t\t\topenable = (Openable)workingCopy;", "-\t\t\t\t} else {", "-\t\t\t\t\topenable = this.handleFactory.createOpenable(pathString, this.scope);", "-\t\t\t\t\tif (openable == null)", "-\t\t\t\t\t\tcontinue; // match is outside classpath", "-\t\t\t\t}", "-\t", "-\t\t\t\t// create new parser and lookup environment if this is a new project", "-\t\t\t\tIResource resource = null;", "-\t\t\t\tJavaProject javaProject = null;", "-\t\t\t\ttry {", "-\t\t\t\t\tjavaProject = (JavaProject) openable.getJavaProject();", "-\t\t\t\t\tif (workingCopy != null) {", "-\t\t\t\t\t\tresource = workingCopy.getResource();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tresource = openable.getResource();", "-\t\t\t\t\t}", "-\t\t\t\t\tif (resource == null) { // case of a file in an external jar", "-\t\t\t\t\t\tresource = javaProject.getProject();", "-\t\t\t\t\t}", "-\t\t\t\t\tif (!javaProject.equals(previousJavaProject)) {", "-\t\t\t\t\t\t// locate matches in previous project", "-\t\t\t\t\t\tif (previousJavaProject != null) {", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tthis.locateMatches(previousJavaProject);", "-\t\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) {", "-\t\t\t\t\t\t\t\t\tthrow e;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t// problem with classpath in this project -> skip it", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthis.matchSet = new PotentialMatchSet();", "-\t\t\t\t\t\t}", "-\t", "-\t\t\t\t\t\tpreviousJavaProject = javaProject;", "-\t\t\t\t\t}", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t// file doesn't exist -> skip it", "-\t\t\t\t\tcontinue;", "-\t\t\t\t}", "-\t", "-\t\t\t\t// add potential match", "-\t\t\t\tthis.addPotentialMatch(resource, openable);", "-\t", "-\t\t\t\tif (progressMonitor != null) {", "-\t\t\t\t\tprogressMonitor.worked(1);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// last project", "-\t\t\tif (previousJavaProject != null) {", "-\t\t\t\ttry {", "-\t\t\t\t\tthis.locateMatches(previousJavaProject);", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\tif (e.getException() instanceof CoreException) {", "-\t\t\t\t\t\tthrow e;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// problem with classpath in last project -> skip it", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tthis.matchSet = new PotentialMatchSet();", "-\t\t\t} ", "-\t\t\t", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tprogressMonitor.done();", "-\t\t\t}", "-\t\t} finally {", "-\t\t\tif (this.nameEnvironment != null) {", "-\t\t\t\tthis.nameEnvironment.cleanup();", "-\t\t\t}", "-\t\t\tmanager.flushZipFiles();", "-\t\t}\t", "-\t}", "+\t\t}", "+\t\tif (this.progressMonitor != null) {", "+\t\t\t// 1 for file path, 4 for parsing and binding creation, 5 for binding resolution? //$NON-NLS-1$", "+\t\t\tthis.progressMonitor.beginTask(\"\", filePaths.length * (this.pattern.mustResolve ? 10 : 5));", "+\t\t}", "+", "+\t\t// initialize pattern for polymorphic search (ie. method reference pattern)", "+\t\tthis.pattern.initializePolymorphicSearch(this, this.progressMonitor);", "+", "+\t\tJavaProject previousJavaProject = null;", "+\t\tPotentialMatchSet matchSet = new PotentialMatchSet();", "+\t\tUtil.sort(filePaths); ", "+\t\tfor (int i = 0, l = filePaths.length; i < l; i++) {", "+\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "+\t\t\t\tthrow new OperationCanceledException();", "+", "+\t\t\t// skip duplicate paths", "+\t\t\tString pathString = filePaths[i];", "+\t\t\tif (i > 0 && pathString.equals(filePaths[i - 1])) continue;", "+\t\t\t", "+\t\t\tOpenable openable;", "+\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = (org.eclipse.jdt.core.ICompilationUnit) wcPaths.get(pathString);", "+\t\t\tif (workingCopy != null) {", "+\t\t\t\topenable = (Openable) workingCopy;", "+\t\t\t} else {", "+\t\t\t\topenable = this.handleFactory.createOpenable(pathString, this.scope);", "+\t\t\t\tif (openable == null) continue; // match is outside classpath", "+", "+\t\t\t// create new parser and lookup environment if this is a new project", "+\t\t\tIResource resource = null;", "+\t\t\ttry {", "+\t\t\t\tJavaProject javaProject = (JavaProject) openable.getJavaProject();", "+\t\t\t\tresource = workingCopy != null ? workingCopy.getResource() : openable.getResource();", "+\t\t\t\tif (resource == null)", "+\t\t\t\t\tresource = javaProject.getProject(); // case of a file in an external jar", "+\t\t\t\tif (!javaProject.equals(previousJavaProject)) {", "+\t\t\t\t\t// locate matches in previous project", "+\t\t\t\t\tif (previousJavaProject != null) {", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tlocateMatches(previousJavaProject, matchSet);", "+\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) throw e;", "+\t\t\t\t\t\t\t// problem with classpath in this project -> skip it", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tmatchSet.reset();", "+\t\t\t\t\t}", "+\t\t\t\t\tpreviousJavaProject = javaProject;", "+\t\t\t\t}", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// file doesn't exist -> skip it", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tmatchSet.add(new PotentialMatch(this, resource, openable));", "+", "+\t\t\tif (this.progressMonitor != null)", "+\t\t\t\tthis.progressMonitor.worked(1);", "+\t\t// last project", "+\t\tif (previousJavaProject != null) {", "+\t\t\ttry {", "+\t\t\t\tlocateMatches(previousJavaProject, matchSet);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\tif (e.getException() instanceof CoreException) throw e;", "+\t\t\t\t// problem with classpath in last project -> skip it", "+\t\t\t}", "+\t\t} ", "+", "+\t\tif (this.progressMonitor != null)", "+\t\t\tthis.progressMonitor.done();", "+\t} finally {", "+\t\tif (this.nameEnvironment != null)", "+\t\t\tthis.nameEnvironment.cleanup();", "+\t\tmanager.flushZipFiles();", "+\t}\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "78ddd944e8e28558b50c1bd8ed879057", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "ad99e8346223888eb2f8e2613d918829f95fd2b2", "commitAfterChange": "7c65ba31905e387e2902b13fe71f33b55f069273", "methodNumberBeforeChange": 125, "methodNumberAfterChange": 125, "signatureBeforeChange": " \t \tprivate char[] getResolvedSignature(char[][] parameterTypes, char[] fullyQualifiedTypeName, int parameterCount, Scope scope)", "signatureAfterChange": " \t \tprivate char[] getResolvedSignature(char[][] parameterTypes, char[] fullyQualifiedTypeName, int parameterCount, Scope scope)", "diff": ["-\t\t\tif (guessedType instanceof ReferenceBinding) {", "-\t\t\t\tReferenceBinding refBinding = (ReferenceBinding) guessedType;", "+\t\t\tif (guessedType instanceof SourceTypeBinding) {", "+\t\t\t\tSourceTypeBinding refBinding = (SourceTypeBinding) guessedType;", "-\t\t\t\tMethodBinding bestConstructor = null;", "-\t\t\t\tint[] bestMatchingLengths = null;", "-\t\t\t\t", "-\t\t\t\tMethodBinding[] methods = refBinding.methods();", "+\t\t\t\trefBinding.methods(); // force resolution", "+\t\t\t\tif (refBinding.scope == null || refBinding.scope.referenceContext == null) return null;", "+\t\t\t\tTypeDeclaration typeDeclaration = refBinding.scope.referenceContext;", "+\t\t\t\tAbstractMethodDeclaration[] methods = typeDeclaration.methods;", "-\t\t\t\t\tMethodBinding method = methods[i];", "+\t\t\t\t\tAbstractMethodDeclaration method = methods[i];", "-\t\t\t\t\tif (!method.isConstructor()) break next;", "+\t\t\t\t\tif (method.binding == null || !method.isConstructor()) continue next;", "-\t\t\t\t\tTypeBinding[] parameters = method.parameters;", "-\t\t\t\t\t//TODO take careful of member types", "-\t\t\t\t\tint parametersLength = parameters == null ? 0 : parameters.length;", "-\t\t\t\t\tif (parameterCount != parametersLength) continue next;", "+\t\t\t\t\tArgument[] arguments = method.arguments;", "+\t\t\t\t\tint argumentsLength = arguments == null ? 0 : arguments.length;", "+\t\t\t\t\tif (parameterCount != argumentsLength) continue next;", "-\t\t\t\t\tint[] matchingLengths = new int[parameterCount];", "-\t\t\t\t\tfor (int j = 0; j < parametersLength; j++) {", "-\t\t\t\t\t\tTypeBinding parameter = parameters[j];", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tchar[] parameterTypeName;", "-\t\t\t\t\t\tif (parameter instanceof ReferenceBinding) {", "-\t\t\t\t\t\t\tparameterTypeName = CharOperation.concatWith(((ReferenceBinding)parameter).compoundName, '.');", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tparameterTypeName = parameter.sourceName();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tif (!CharOperation.endsWith(parameterTypeName, parameterTypes[j])) {", "+\t\t\t\t\tfor (int j = 0; j < argumentsLength; j++) {", "+\t\t\t\t\t\tif (!CharOperation.equals(CharOperation.concatWith(arguments[j].type.getTypeName(), '.'), parameterTypes[j])) {", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tint matchingLength = parameterTypes[j].length;", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tif (bestMatchingLengths != null) {", "-\t\t\t\t\t\t\tif (bestMatchingLengths[j] > matchingLength) {", "-\t\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tmatchingLengths[j] = matchingLength;", "-\t\t\t\t\t", "-\t\t\t\t\tbestConstructor = method;", "-\t\t\t\t\tbestMatchingLengths = matchingLengths;", "+\t\t\t\t\treturn getSignature(method.binding);", "-\t\t\t\t", "-\t\t\t\tif (bestConstructor == null) return null;", "-\t\t\t\treturn getSignature(bestConstructor);"]}], "num": 38027}