{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9116e8bd4c3541c9e9bcaebeba9aec68", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "02e03250e5486588934849228ba1d5e2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "1542690d818b56ca31610b1599cca37ada2a98ce", "commitAfterChange": "d4b5cd49c818d92f78d88015c4faceb62aabb90c", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "signatureAfterChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "diff": ["+\t\t\tTypeBinding[] newArgs = null;", "+\t\t\tfor (int i = 0; i < argLength; i++) {", "+\t\t\t\tTypeBinding param = i < paramLength ? parameters[i] : parameters[paramLength - 1];", "+\t\t\t\tif (arguments[i].isBaseType() != param.isBaseType()) {", "+\t\t\t\t\tif (newArgs == null) {", "+\t\t\t\t\t\tnewArgs = new TypeBinding[argLength];", "+\t\t\t\t\t\tSystem.arraycopy(arguments, 0, newArgs, 0, argLength);", "+\t\t\t\t\t}", "+\t\t\t\t\tnewArgs[i] = environment().computeBoxingType(arguments[i]);", "+\t\t\t\t}\t", "+\t\t\t}", "+\t\t\tif (newArgs != null)", "+\t\t\t\targuments = newArgs;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5db50e523ad6c6a1bf0e64054fd5006", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "b0ee678b65f48d1cfab35972dd53d6bd85389446", "commitAfterChange": "5a11933bf440021c4c92ce580c9967dadb549d6e", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic static MethodBinding computeCompatibleMethod18(MethodBinding originalMethod, TypeBinding[] arguments, final Scope scope, InvocationSite invocationSite)", "signatureAfterChange": "  \tpublic static MethodBinding computeCompatibleMethod18(MethodBinding originalMethod, TypeBinding[] arguments, final Scope scope, InvocationSite invocationSite)", "diff": ["-\t\tInferenceContext18 infCtx18 = null;", "+\t\tInferenceContext18 infCtx18 = invocationSite.freshInferenceContext(scope);", "-\t\tinfCtx18 = invocationSite.freshInferenceContext(scope);", "+\t\tboolean requireBoxing = false;", "+\t\t", "+\t\t// See if we should start in loose inference mode.", "+\t\tTypeBinding [] argumentsCopy = new TypeBinding[arguments.length];", "+\t\tfor (int i = 0, length = arguments.length, parametersLength = parameters.length ; i < length; i++) {", "+\t\t\tTypeBinding parameter = i < parametersLength ? parameters[i] : parameters[parametersLength - 1];", "+\t\t\tfinal TypeBinding argument = arguments[i];", "+\t\t\tif (argument.isPrimitiveType() != parameter.isPrimitiveType()) { // Scope.cCM incorrectly but harmlessly uses isBaseType which answers true for null.", "+\t\t\t\targumentsCopy[i] = scope.environment().computeBoxingType(argument);", "+\t\t\t\trequireBoxing = true; // can't be strict mode, needs at least loose.", "+\t\t\t} else {", "+\t\t\t\targumentsCopy[i] = argument;", "+\t\t\t}", "+\t\t}", "+\t\targuments = argumentsCopy; // either way, this allows the engine to update arguments without harming the callers. ", "-\t\t\t\tinfCtx18.inferenceKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.", "+\t\t\t\tinfCtx18.inferenceKind = requireBoxing ? InferenceContext18.CHECK_LOOSE : InferenceContext18.CHECK_STRICT; // engine may still slip into loose mode and adjust level."]}], "num": 55026}