{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "298ce1ba4e32017de525b323c135f42d", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0a1f0156da4156c92cf13b3869a95e9d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "be4eba91f6e950a319d5fcff0a9532d13e1e01c3", "commitAfterChange": "7a1c3f0abab2342889b25f645c23994ef13ac53b", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 28, "signatureBeforeChange": " boolean reportIncompatibleReturnTypeError(MethodBinding currentMethod, MethodBinding inheritedMethod)", "signatureAfterChange": " boolean reportIncompatibleReturnTypeError(MethodBinding currentMethod, MethodBinding inheritedMethod)", "diff": ["+\t// JLS 3 \ufffd8.4.5: more are accepted, with an unchecked conversion", "+\tif (currentMethod.returnType == inheritedMethod.returnType.erasure()) {", "+\t\tTypeBinding[] currentParams = currentMethod.parameters;", "+\t\tTypeBinding[] inheritedParams = inheritedMethod.parameters;", "+\t\tfor (int i = 0, l = currentParams.length; i < l; i++) {", "+\t\t\tif (!areTypesEqual(currentParams[i], inheritedParams[i])) {", "+\t\t\t\tproblemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, inheritedMethod, this.type);", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0aa97a4f15dcc3b68796808fd9781049", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "c458ad2d505b6f4a7e2ec3bba3954504b01472bd", "commitAfterChange": "f802d6fc991463cb62d45c1ee5e011116f9ae063", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  protected void findSourceFiles(IResourceDelta sourceDelta, ClasspathMultiDirectory md, int segmentCount) throws CoreException", "signatureAfterChange": "  protected void findSourceFiles(IResourceDelta sourceDelta, ClasspathMultiDirectory md, int segmentCount) throws CoreException", "diff": ["-\tif (md.exclusionPatterns != null && Util.isExcluded(resource, md.exclusionPatterns)) return;", "+\t// remember that if inclusion & exclusion patterns change then a full build is done", "+\tboolean isExcluded = (md.exclusionPatterns != null || md.inclusionPatterns != null)", "+\t\t&& Util.isExcluded(resource, md.inclusionPatterns, md.exclusionPatterns);", "+\t\t\tif (isExcluded && md.inclusionPatterns == null)", "+\t\t        return; // no need to go further with this delta since its children cannot be included", "+", "-\t\t\t\t\tIPath addedPackagePath = resource.getFullPath().removeFirstSegments(segmentCount);", "-\t\t\t\t\tcreateFolder(addedPackagePath, md.binaryFolder); // ensure package exists in the output folder", "-\t\t\t\t\t// add dependents even when the package thinks it exists to be on the safe side", "-\t\t\t\t\tif (JavaBuilder.DEBUG)", "-\t\t\t\t\t\tSystem.out.println(\"Found added package \" + addedPackagePath); //$NON-NLS-1$", "-\t\t\t\t\taddDependentsOf(addedPackagePath, true);", "+\t\t\t\t    if (!isExcluded) {", "+\t\t\t\t\t\tIPath addedPackagePath = resource.getFullPath().removeFirstSegments(segmentCount);", "+\t\t\t\t\t\tcreateFolder(addedPackagePath, md.binaryFolder); // ensure package exists in the output folder", "+\t\t\t\t\t\t// add dependents even when the package thinks it exists to be on the safe side", "+\t\t\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\t\t\tSystem.out.println(\"Found added package \" + addedPackagePath); //$NON-NLS-1$", "+\t\t\t\t\t\taddDependentsOf(addedPackagePath, true);", "+\t\t\t\t    }", "+\t\t\t\t    if (isExcluded) {", "+\t\t\t\t    \t// since this folder is excluded then there is nothing to delete (from this md), but must walk any included subfolders", "+\t\t\t\t\t\tchildren = sourceDelta.getAffectedChildren();", "+\t\t\t\t\t\tfor (int i = 0, l = children.length; i < l; i++)", "+\t\t\t\t\t\t\tfindSourceFiles(children[i], md, segmentCount);", "+\t\t\t\t\t\treturn;", "+\t\t\t\t    }", "+\t\t\tif (isExcluded) return;", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46e12f5cfd0bf87d77217ca17e22633d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "5121c9e56fe5f00b9263f63c8225d577bc580b73", "commitAfterChange": "ff119e6fb7d599c80d7b7bf4e0ea59e3938447d5", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  protected boolean findSourceFiles(IResourceDelta delta) throws CoreException", "signatureAfterChange": "  protected boolean findSourceFiles(IResourceDelta delta) throws CoreException", "diff": ["-\t\tIResourceDelta sourceDelta = delta.findMember(md.sourceFolder.getProjectRelativePath());", "-\t\tif (sourceDelta != null) {", "-\t\t\tif (sourceDelta.getKind() == IResourceDelta.REMOVED) {", "-\t\t\t\tif (JavaBuilder.DEBUG)", "-\t\t\t\t\tSystem.out.println(\"ABORTING incremental build... found removed source folder\"); //$NON-NLS-1$", "-\t\t\t\treturn false; // removed source folder should not make it here, but handle anyways (ADDED is supported)", "-\t\t\t}", "-\t\t\tint segmentCount = sourceDelta.getFullPath().segmentCount();", "-\t\t\tIResourceDelta[] children = sourceDelta.getAffectedChildren();", "+\t\tif (md.sourceFolder.equals(javaBuilder.currentProject)) {", "+\t\t\t// skip nested source & output folders when the project is a source folder", "+\t\t\tint segmentCount = delta.getFullPath().segmentCount();", "+\t\t\tIResourceDelta[] children = delta.getAffectedChildren();", "-\t\t\t\tfindSourceFiles(children[j], md, segmentCount);", "-\t\t\tnotifier.checkCancel();", "+\t\t\t\tif (!isExcludedFromProject(children[i].getFullPath()))", "+\t\t\t\t\tfindSourceFiles(children[j], md, segmentCount);", "+\t\t} else {", "+\t\t\tIResourceDelta sourceDelta = delta.findMember(md.sourceFolder.getProjectRelativePath());", "+", "+\t\t\tif (sourceDelta != null) {", "+\t\t\t\tif (sourceDelta.getKind() == IResourceDelta.REMOVED) {", "+\t\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\t\tSystem.out.println(\"ABORTING incremental build... found removed source folder\"); //$NON-NLS-1$", "+\t\t\t\t\treturn false; // removed source folder should not make it here, but handle anyways (ADDED is supported)", "+\t\t\t\t}", "+\t\t\t\tint segmentCount = sourceDelta.getFullPath().segmentCount();", "+\t\t\t\tIResourceDelta[] children = sourceDelta.getAffectedChildren();", "+\t\t\t\tfor (int j = 0, m = children.length; j < m; j++)", "+\t\t\t\t\tfindSourceFiles(children[j], md, segmentCount);", "+\t\t\t}", "+\t\tnotifier.checkCancel();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6780cb0a5fad2e399415cf8d6f7552c1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "b978e7a94d48cd82dbef3b42c2ac323ce05ae123", "commitAfterChange": "434c1aaf125f5f9b1333fb895bef73ae37de8528", "methodNumberBeforeChange": 130, "methodNumberAfterChange": 130, "signatureBeforeChange": "  \tpublic ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, IClasspathEntry[] referencedEntries, boolean usePreviousSession, boolean resolveChainedLibraries) throws JavaModelException", "signatureAfterChange": "  \tpublic ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, IClasspathEntry[] referencedEntries, boolean usePreviousSession, boolean resolveChainedLibraries) throws JavaModelException", "diff": ["-\t\t\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=305037", "-\t\t\t\t\t\t\t// responsibility of resolving chained (referenced) libraries lies with the container", "+\t\t\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=313965", "+\t\t\t\t\t\t\t// Do not resolve if the system attribute is set to false\t", "+\t\t\t\t\t\t\tif (resolveChainedLibraries", "+\t\t\t\t\t\t\t\t\t&& JavaModelManager.getJavaModelManager().resolveReferencedLibrariesForContainers", "+\t\t\t\t\t\t\t\t\t&& result.rawReverseMap.get(cEntry.getPath()) == null) {", "+\t\t\t\t\t\t\t\t// resolve Class-Path: in manifest", "+\t\t\t\t\t\t\t\tClasspathEntry[] extraEntries = cEntry.resolvedChainedLibraries();", "+\t\t\t\t\t\t\t\tfor (int k = 0, length2 = extraEntries.length; k < length2; k++) {", "+\t\t\t\t\t\t\t\t\tif (!rawLibrariesPath.contains(extraEntries[k].getPath())) {", "+\t\t\t\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[k], result, resolvedEntries, externalFoldersManager, referencedEntriesMap, false);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}"]}], "num": 5343}