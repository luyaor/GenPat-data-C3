{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1c423a01371c6389adf6be965971b39e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "01a56b2c5275d1a1f2df87093581ee00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "5f100ab0d61beb34b23838f330bd40314a77e0dc", "commitAfterChange": "d583ac0d52375fce8272e2954c7bfc180f0599f4", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] rawClasspath, IPath projectOutputLocation)", "diff": ["-\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {", "+\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] rawClasspath, IPath projectOutputLocation) {", "-\t\tif (outputLocation == null) {", "+\t\tif (projectOutputLocation == null) {", "-\t\tif (outputLocation.isAbsolute()) {", "-\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "+\t\tif (projectOutputLocation.isAbsolute()) {", "+\t\t\tif (!projectPath.isPrefixOf(projectOutputLocation)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, projectOutputLocation.toString());", "-\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "+\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, projectOutputLocation);", "-\t\tboolean allowNestingInOutput = false;", "+", "-\t\tint length = classpath == null ? 0 : classpath.length; ", "-\t", "-\t\tArrayList resolvedEntries = new ArrayList();", "+\t\tif (rawClasspath == null) ", "+\t\t\treturn JavaModelStatus.VERIFIED_OK;", "+\t\t", "+\t\t// retrieve resolved classpath", "+\t\tIClasspathEntry[] classpath; ", "+\t\ttry {", "+\t\t\tclasspath = ((JavaProject)javaProject).getResolvedClasspath(rawClasspath, true/*ignore pb*/, false/*no marker*/);", "+\t\t} catch(JavaModelException e){", "+\t\t\treturn e.getJavaModelStatus();", "+\t\t}", "+\t\tint length = classpath.length; ", "+", "+\t\tint outputCount = 1;", "+\t\tIPath[] outputLocations\t= new IPath[length+1];", "+\t\tboolean[] allowNestingInOutputLocations = new boolean[length+1];", "+\t\toutputLocations[0] = projectOutputLocation;", "+\t\t", "+\t\t// retrieve and check output locations", "-\t\t\tIClasspathEntry rawEntry = classpath[i];", "-\t\t\tswitch(rawEntry.getEntryKind()){", "-\t\t\t\t", "-\t\t\t\tcase IClasspathEntry.CPE_VARIABLE :", "-\t\t\t\t\tIClasspathEntry resolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);", "-\t\t\t\t\tif (resolvedEntry != null){", "-\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t", "-\t\t\t\tcase IClasspathEntry.CPE_CONTAINER :", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tIClasspathContainer container = JavaCore.getClasspathContainer(rawEntry.getPath(), javaProject);", "-\t\t\t\t\t\tif (container != null){", "-\t\t\t\t\t\t\tIClasspathEntry[] containerEntries = container.getClasspathEntries();", "-\t\t\t\t\t\t\tif (containerEntries != null){", "-\t\t\t\t\t\t\t\tfor (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){", "-\t\t\t\t\t\t\t\t\t//resolvedEntry = JavaCore.getResolvedClasspathEntry(containerEntries[j]);", "-\t\t\t\t\t\t\t\t\tresolvedEntry = containerEntries[j];", "-\t\t\t\t\t\t\t\t\tif (resolvedEntry != null){", "-\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "+\t\t\tIClasspathEntry resolvedEntry = classpath[i];", "+\t\t\tswitch(resolvedEntry.getEntryKind()){", "+\t\t\t\tcase IClasspathEntry.CPE_SOURCE :", "+\t\t\t\t\tIPath customOutput; ", "+\t\t\t\t\tif ((customOutput = resolvedEntry.getOutputLocation()) != null) {", "+\t\t\t\t\t\tint index;", "+\t\t\t\t\t\tif ((index = indexOfMatchingPath(customOutput, outputLocations, outputCount)) != -1) {", "+\t\t\t\t\t\t\tcontinue; // already found", "-\t\t\t\t\t} catch(JavaModelException e){", "-\t\t\t\t\t\treturn new JavaModelStatus(e);", "+\t\t\t\t\t\tif ((index = indexOfEnclosingPath(customOutput, outputLocations, outputCount)) != -1) {", "+\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInOutput\", customOutput.toString(), outputLocations[index].toString())); //$NON-NLS-1$", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\toutputLocations[outputCount++] = resolvedEntry.getOutputLocation();", "-\t\t\t\t\tbreak;", "-\t\t\t\t\t", "+\t\t\t}\t", "+\t\t}\t", "+\t\t", "+\t\tfor (int i = 0 ; i < length; i++) {", "+\t\t\tIClasspathEntry resolvedEntry = classpath[i];", "+\t\t\tint index;", "+\t\t\tswitch(resolvedEntry.getEntryKind()){", "+\t\t\t\t", "-\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "-\t\t\t\t\tif (!org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "-\t\t\t\t\t\thasLibFolder = true;", "+\t\t\t\t\tif ((index = indexOfMatchingPath(resolvedEntry.getPath(), outputLocations, outputCount)) != -1){", "+\t\t\t\t\t\tallowNestingInOutputLocations[index] = true;", "-\t\t\t\tdefault :", "-\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\tresolvedEntries.add(rawEntry);", "+\t\t\t\t\tbreak;", "+", "+\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "+\t\t\t\t\thasLibFolder |= !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(resolvedEntry.getPath().lastSegment());", "+\t\t\t\t\tif ((index = indexOfMatchingPath(resolvedEntry.getPath(), outputLocations, outputCount)) != -1){", "+\t\t\t\t\t\tallowNestingInOutputLocations[index] = true;", "+\t\t\t\t\t}", "-\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput = true; // if no source and no lib folder, then allowed", "-\t\t", "-\t\tlength = resolvedEntries.size();", "-\t\tclasspath = new IClasspathEntry[length];", "-\t\tresolvedEntries.toArray(classpath);", "+\t\tif (!hasSource && !hasLibFolder) { // if no source and no lib folder, then allowed", "+\t\t\tfor (int i = 0; i < outputCount; i++) allowNestingInOutputLocations[i] = true;", "+\t\t}", "+\t\t\t\t// tolerate nesting output in src if src==prj", "-\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "+\t\t\tint index;", "+\t\t\tif ((index = indexOfNestedPath(entryPath, outputLocations, outputCount)) != -1) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocations[index].toString(), entryPath.toString())); //$NON-NLS-1$", "-\t", "+", "-\t\t\tif (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "+\t\t\tif ((index = indexOfEnclosingPath(entryPath, outputLocations, outputCount)) != -1) {", "+\t\t\t\tif (!allowNestingInOutputLocations[index]){", "+\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocations[index].toString())); //$NON-NLS-1$", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37dbd12da1be296b02322354bee3910f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeReferenceLocator.java", "commitBeforeChange": "98ad487e103c268099d7117573693243c8d3b8fc", "commitAfterChange": "721a9dcda02493639666143934bddb089e848d18", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " protected void matchReportReference(QualifiedTypeReference qTypeRef, IJavaElement element, Binding elementBinding, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": " protected void matchReportReference(ASTNode reference, IJavaElement element, Binding elementBinding, Scope scope, int accuracy, MatchLocator locator) throws CoreException", "diff": ["+ */", "+protected void matchReportReference(ASTNode reference, IJavaElement element, Binding elementBinding, Scope scope, int accuracy, MatchLocator locator) throws CoreException {", "+\tif (scope == null || (scope.kind != Scope.BLOCK_SCOPE && scope.kind != Scope.METHOD_SCOPE)) {", "+\t\tmatchReportReference(reference, element, elementBinding, accuracy, locator);", "+\t\treturn;", "+\t}", "+\t", "+\t// Look if some block scope local variable declarations include reference start position", "+\tBlockScope blockScope = (BlockScope) scope;", "+\tLocalDeclaration[] localDeclarations = blockScope.findLocalVariableDeclarations(reference.sourceStart);", "+\tint length = localDeclarations == null ? 0 : localDeclarations.length;", "+\tIJavaElement localElement = null;", "+\tIJavaElement[] otherElements = null;", "+", "+\t// Some local variable declaration are matching", "+\tif (length > 0) {", "+", "+\t\t// Set local element to first matching local declaration", "+\t\tint idx = 0;", "+\t\tfor (; idx<length; idx++) {", "+\t\t\tif (localDeclarations[idx] == null) break;", "+\t\t\tif (reference.sourceStart == localDeclarations[idx].declarationSourceStart) {", "+\t\t\t\tlocalElement = locator.createHandle(localDeclarations[idx], element);", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tif (idx>0 && localDeclarations[idx].sourceStart > reference.sourceStart) {", "+\t\t\t\tlocalElement = locator.createHandle(localDeclarations[idx-1], element);", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\tif (localElement == null && idx > 0) {", "+\t\t\tif (reference.sourceEnd < localDeclarations[idx-1].declarationEnd) {", "+\t\t\t\tlocalElement = locator.createHandle(localDeclarations[idx-1], element);", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Store other local variable declarations in other elements", "+\t\tint size = 0;", "+\t\tfor (int j=1; j<length; j++) {", "+\t\t\tif (localDeclarations[j] == null) break;", "+\t\t\tif (reference.sourceStart == localDeclarations[j].declarationSourceStart) {", "+\t\t\t\tif (otherElements == null) {", "+\t\t\t\t\totherElements = new IJavaElement[length-j];", "+\t\t\t\t}", "+\t\t\t\totherElements[size++] = locator.createHandle(localDeclarations[j], element);", "+\t\t\t}", "+\t\t}", "+\t\tif (size > 0 && size != (length-1)) {", "+\t\t\tSystem.arraycopy(otherElements, 0, otherElements = new IJavaElement[size], 0, size);", "+\t\t}", "+\t}", "+\t", "+\t// Report match with local and other elements if any", "+\tmatchReportReference(reference, element, localElement, otherElements, elementBinding, accuracy, locator);", "-\tmatch = locator.newTypeReferenceMatch(element, elementBinding, accuracy, qTypeRef);"]}], "num": 12599}