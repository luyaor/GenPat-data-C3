{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cfa36a0f1e4dfa15b3a439b74b0163a0", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "afc247feec575aa42b4e5ec9718597a1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/TextEditsBuilder.java", "commitBeforeChange": "ea5c9cc312f4b4f8b75e3a6a2f95be1c2b2c1422", "commitAfterChange": "1d27cfb65a8550e3dd44f890da53c4bdcdcccdbf", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tprivate void flushBuffer(int currentPosition)", "signatureAfterChange": "  \tprivate void flushBuffer(int currentPosition)", "diff": ["-\t\tif (!sourceMatch && checkRegions(this.counter, currentPosition)) {", "-\t\t\tTextEdit edit = getReplaceEdit(this.counter, currentPosition, buffered);", "-\t\t\tthis.edits.add(edit);", "+\t\twhile (!sourceMatch && this.currentRegion < this.regions.size()) {", "+\t\t\tIRegion region = this.regions.get(this.currentRegion);", "+\t\t\tif (currentPosition < region.getOffset())", "+\t\t\t\tbreak;", "+\t\t\tint regionEnd = region.getOffset() + region.getLength();", "+\t\t\tif (this.counter >= regionEnd) {", "+\t\t\t\tthis.currentRegion++;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (this.currentRegion == this.regions.size() - 1", "+\t\t\t\t\t|| this.regions.get(this.currentRegion + 1).getOffset() > currentPosition) {", "+\t\t\t\tthis.edits.add(getReplaceEdit(this.counter, currentPosition, buffered, region));", "+\t\t\t\tbreak;", "+\t\t\t}", "+", "+\t\t\t// this edit will span more than one region, split it", "+\t\t\tIRegion nextRegion = this.regions.get(this.currentRegion + 1);", "+\t\t\tint bestSplit = 0;", "+\t\t\tint bestSplitScore = Integer.MAX_VALUE;", "+\t\t\tfor (int i = 0; i < buffered.length(); i++) {", "+\t\t\t\tReplaceEdit edit1 = getReplaceEdit(this.counter, regionEnd, buffered.substring(0, i), region);", "+\t\t\t\tReplaceEdit edit2 = getReplaceEdit(regionEnd, currentPosition, buffered.substring(i), nextRegion);", "+\t\t\t\tint score = edit1.getLength() + edit1.getText().length() + edit2.getLength() + edit2.getText().length();", "+\t\t\t\tif (score < bestSplitScore) {", "+\t\t\t\t\tbestSplit = i;", "+\t\t\t\t\tbestSplitScore = score;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tthis.edits.add(getReplaceEdit(this.counter, regionEnd, buffered.substring(0, bestSplit), region));", "+\t\t\tbuffered = buffered.substring(bestSplit);", "+\t\t\tthis.counter = regionEnd;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ccea1dbf0d963cbb6663d6788270a120", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "9ee78f50bb7fb9d70095ea7ff2d9f2e27d840c37", "commitAfterChange": "b6410432af18704990f18fa69a09dd7a76e8fb04", "methodNumberBeforeChange": 59, "methodNumberAfterChange": 61, "signatureBeforeChange": " protected void reportAccurateTypeReference(ASTNode typeRef, char[] name, IJavaElement element, int accuracy) throws CoreException", "signatureAfterChange": " protected void reportAccurateParameterizedMethodReference(SearchMatch match, ASTNode statement, TypeReference[] typeArguments) throws CoreException", "diff": ["-protected void reportAccurateTypeReference(ASTNode typeRef, char[] name, IJavaElement element, int accuracy) throws CoreException {", "-\treportAccurateTypeReference(typeRef, name, element, accuracy, SearchPattern.R_EXACT_MATCH);", "-}", "+protected void reportAccurateParameterizedMethodReference(SearchMatch match, ASTNode statement, TypeReference[] typeArguments) throws CoreException {", "+\tif (match.getRule() == 0) return;", "+\tif (!encloses((IJavaElement)match.getElement())) return;", "+", "+\t// If there's type arguments, look for end (ie. char '>') of last one.", "+\tint start = match.getOffset();", "+\tif (typeArguments != null && typeArguments.length > 0) {", "+\t\tboolean isErasureMatch= (pattern instanceof OrPattern) ? ((OrPattern)pattern).isErasureMatch() : ((JavaSearchPattern)pattern).isErasureMatch();", "+\t\tif (!isErasureMatch) {", "+\t\t\t", "+\t\t\t// Initialize scanner", "+\t\t\tScanner scanner = this.parser.scanner;", "+\t\t\tchar[] source = this.currentPossibleMatch.getContents();", "+\t\t\tscanner.setSource(source);", "+", "+\t\t\t// Search previous opening '<'", "+\t\t\tstart = typeArguments[0].sourceStart;", "+\t\t\tint end = statement.sourceEnd;", "+\t\t\tscanner.resetTo(start, end);", "+\t\t\tint lineStart = start;", "+\t\t\ttry {", "+\t\t\t\tlinesUp: while (true) {", "+\t\t\t\t\twhile (scanner.source[scanner.currentPosition] != '\\n') {", "+\t\t\t\t\t\tscanner.currentPosition--;", "+\t\t\t\t\t\tif (scanner.currentPosition == 0) break linesUp;", "+\t\t\t\t\t}", "+\t\t\t\t\tlineStart = scanner.currentPosition+1;", "+\t\t\t\t\tscanner.resetTo(lineStart, end);", "+\t\t\t\t\twhile (!scanner.atEnd()) {", "+\t\t\t\t\t\tif (scanner.getNextToken() == TerminalTokens.TokenNameLESS) {", "+\t\t\t\t\t\t\tstart = scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\tbreak linesUp;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tend = lineStart - 2;", "+\t\t\t\t\tscanner.currentPosition = end;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tcatch (InvalidInputException ex) {", "+\t\t\t\t// give up", "+\t\t\t}", "+\t \t}", "+\t}", "+\t", "+\t// Report match", "+\tmatch.setOffset(start);", "+\tmatch.setLength(statement.sourceEnd-start+1);", "+\treport(match);", "+}"]}], "num": 42668}