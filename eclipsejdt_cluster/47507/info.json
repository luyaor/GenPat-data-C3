{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b9c59afcbb7412e6e90bbf05bc1d9ec4", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b980eaa24eaa988b50136080ab343c07", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "368e7b2744bb4a520a4dfc9ab8183508aa7c626d", "commitAfterChange": "93b70485a331557e06c4f378f7086f6e4f12616a", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "signatureAfterChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "diff": ["-\t\t\t", "-\t\tBinding binding = null;", "-\t\tFieldBinding problemField = null;", "-\t\tif ((mask & VARIABLE) != 0) {", "-\t\t\tboolean insideStaticContext = false;", "-\t\t\tboolean insideConstructorCall = false;", "-\t\t\tFieldBinding foundField = null;", "-\t\t\t// can be a problem field which is answered if a valid field is not found", "-\t\t\tProblemFieldBinding foundInsideProblem = null;", "-\t\t\t// inside Constructor call or inside static context", "-\t\t\tScope scope = this;", "-\t\t\tint depth = 0;", "-\t\t\tint foundDepth = 0;", "-\t\t\tReferenceBinding foundActualReceiverType = null;", "-\t\t\tdone : while (true) { // done when a COMPILATION_UNIT_SCOPE is found", "-\t\t\t\tswitch (scope.kind) {", "-\t\t\t\t\tcase METHOD_SCOPE :", "-\t\t\t\t\t\tMethodScope methodScope = (MethodScope) scope;", "-\t\t\t\t\t\tinsideStaticContext |= methodScope.isStatic;", "-\t\t\t\t\t\tinsideConstructorCall |= methodScope.isConstructorCall;", "-\t\t\t\t\t\t// Fall through... could duplicate the code below to save a cast - questionable optimization", "-\t\t\t\t\tcase BLOCK_SCOPE :", "-\t\t\t\t\t\tLocalVariableBinding variableBinding = scope.findVariable(name);", "-\t\t\t\t\t\t// looks in this scope only", "-\t\t\t\t\t\tif (variableBinding != null) {", "-\t\t\t\t\t\t\tif (foundField != null && foundField.isValidBinding())", "-\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "-\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\tif (depth > 0)", "-\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\treturn variableBinding;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase CLASS_SCOPE :", "-\t\t\t\t\t\tClassScope classScope = (ClassScope) scope;", "-\t\t\t\t\t\tSourceTypeBinding enclosingType = classScope.referenceContext.binding;", "-\t\t\t\t\t\tFieldBinding fieldBinding =", "-\t\t\t\t\t\t\tclassScope.findField(enclosingType, name, invocationSite, needResolve);", "-\t\t\t\t\t\t// Use next line instead if willing to enable protected access accross inner types", "-\t\t\t\t\t\t// FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);", "-\t\t\t\t\t\tif (fieldBinding != null) { // skip it if we did not find anything", "-\t\t\t\t\t\t\tif (fieldBinding.problemId() == Ambiguous) {", "-\t\t\t\t\t\t\t\tif (foundField == null || foundField.problemId() == NotVisible)", "-\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t\treturn fieldBinding;", "-\t\t\t\t\t\t\t\t// make the user qualify the field, likely wants the first inherited field (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\ttry {", "+\t\t\tBinding binding = null;", "+\t\t\tFieldBinding problemField = null;", "+\t\t\tif ((mask & VARIABLE) != 0) {", "+\t\t\t\tboolean insideStaticContext = false;", "+\t\t\t\tboolean insideConstructorCall = false;", "+\t", "+\t\t\t\tFieldBinding foundField = null;", "+\t\t\t\t// can be a problem field which is answered if a valid field is not found", "+\t\t\t\tProblemFieldBinding foundInsideProblem = null;", "+\t\t\t\t// inside Constructor call or inside static context", "+\t\t\t\tScope scope = this;", "+\t\t\t\tint depth = 0;", "+\t\t\t\tint foundDepth = 0;", "+\t\t\t\tReferenceBinding foundActualReceiverType = null;", "+\t\t\t\tdone : while (true) { // done when a COMPILATION_UNIT_SCOPE is found", "+\t\t\t\t\tswitch (scope.kind) {", "+\t\t\t\t\t\tcase METHOD_SCOPE :", "+\t\t\t\t\t\t\tMethodScope methodScope = (MethodScope) scope;", "+\t\t\t\t\t\t\tinsideStaticContext |= methodScope.isStatic;", "+\t\t\t\t\t\t\tinsideConstructorCall |= methodScope.isConstructorCall;", "+\t\t\t\t\t\t\t// Fall through... could duplicate the code below to save a cast - questionable optimization", "+\t\t\t\t\t\tcase BLOCK_SCOPE :", "+\t\t\t\t\t\t\tLocalVariableBinding variableBinding = scope.findVariable(name);", "+\t\t\t\t\t\t\t// looks in this scope only", "+\t\t\t\t\t\t\tif (variableBinding != null) {", "+\t\t\t\t\t\t\t\tif (foundField != null && foundField.isValidBinding())", "+\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "+\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\tif (depth > 0)", "+\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\treturn variableBinding;", "-", "-\t\t\t\t\t\t\tProblemFieldBinding insideProblem = null;", "-\t\t\t\t\t\t\tif (fieldBinding.isValidBinding()) {", "-\t\t\t\t\t\t\t\tif (!fieldBinding.isStatic()) {", "-\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "-\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase CLASS_SCOPE :", "+\t\t\t\t\t\t\tClassScope classScope = (ClassScope) scope;", "+\t\t\t\t\t\t\tSourceTypeBinding enclosingType = classScope.referenceContext.binding;", "+\t\t\t\t\t\t\tFieldBinding fieldBinding =", "+\t\t\t\t\t\t\t\tclassScope.findField(enclosingType, name, invocationSite, needResolve);", "+\t\t\t\t\t\t\t// Use next line instead if willing to enable protected access accross inner types", "+\t\t\t\t\t\t\t// FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);", "+\t\t\t\t\t\t\tif (fieldBinding != null) { // skip it if we did not find anything", "+\t\t\t\t\t\t\t\tif (fieldBinding.problemId() == Ambiguous) {", "+\t\t\t\t\t\t\t\t\tif (foundField == null || foundField.problemId() == NotVisible)", "+\t\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "+\t\t\t\t\t\t\t\t\t\treturn fieldBinding;", "+\t\t\t\t\t\t\t\t\t// make the user qualify the field, likely wants the first inherited field (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\tif (enclosingType == fieldBinding.declaringClass", "-\t\t\t\t\t\t\t\t\t|| environment().options.complianceLevel >= ClassFileConstants.JDK1_4){", "-\t\t\t\t\t\t\t\t\t// found a valid field in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "-\t\t\t\t\t\t\t\t\tif (foundField == null) {", "-\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "-\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(enclosingType);", "+\t", "+\t\t\t\t\t\t\t\tProblemFieldBinding insideProblem = null;", "+\t\t\t\t\t\t\t\tif (fieldBinding.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (!fieldBinding.isStatic()) {", "+\t\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "+\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "+\t\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "+\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t\t\t// return the fieldBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\t\treturn insideProblem == null ? fieldBinding : insideProblem;", "-\t\t\t\t\t\t\t\t\tif (foundField.isValidBinding())", "-\t\t\t\t\t\t\t\t\t\t// if a valid field was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "-\t\t\t\t\t\t\t\t\t\tif (foundField.declaringClass != fieldBinding.declaringClass)", "-\t\t\t\t\t\t\t\t\t\t\t// ie. have we found the same field - do not trust field identity yet", "-\t\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\tif (enclosingType == fieldBinding.declaringClass", "+\t\t\t\t\t\t\t\t\t\t|| environment().options.complianceLevel >= ClassFileConstants.JDK1_4){", "+\t\t\t\t\t\t\t\t\t\t// found a valid field in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "+\t\t\t\t\t\t\t\t\t\tif (foundField == null) {", "+\t\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "+\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(enclosingType);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t// return the fieldBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\t\treturn insideProblem == null ? fieldBinding : insideProblem;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tif (foundField.isValidBinding())", "+\t\t\t\t\t\t\t\t\t\t\t// if a valid field was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundField.declaringClass != fieldBinding.declaringClass)", "+\t\t\t\t\t\t\t\t\t\t\t\t// ie. have we found the same field - do not trust field identity yet", "+\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t", "+\t\t\t\t\t\t\t\tif (foundField == null", "+\t\t\t\t\t\t\t\t\t|| (foundField.problemId() == NotVisible", "+\t\t\t\t\t\t\t\t\t\t&& fieldBinding.problemId() != NotVisible)) {", "+\t\t\t\t\t\t\t\t\t// only remember the fieldBinding if its the first one found or the previous one was not visible & fieldBinding is...", "+\t\t\t\t\t\t\t\t\tfoundDepth = depth;", "+\t\t\t\t\t\t\t\t\tfoundActualReceiverType = enclosingType;", "+\t\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "+\t\t\t\t\t\t\t\t\tfoundField = fieldBinding;", "-", "-\t\t\t\t\t\t\tif (foundField == null", "-\t\t\t\t\t\t\t\t|| (foundField.problemId() == NotVisible", "-\t\t\t\t\t\t\t\t\t&& fieldBinding.problemId() != NotVisible)) {", "-\t\t\t\t\t\t\t\t// only remember the fieldBinding if its the first one found or the previous one was not visible & fieldBinding is...", "-\t\t\t\t\t\t\t\tfoundDepth = depth;", "-\t\t\t\t\t\t\t\tfoundActualReceiverType = enclosingType;", "-\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\t\t\t\t\t\tfoundField = fieldBinding;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tdepth++;", "-\t\t\t\t\t\tinsideStaticContext |= enclosingType.isStatic();", "-\t\t\t\t\t\t// 1EX5I8Z - accessing outer fields within a constructor call is permitted", "-\t\t\t\t\t\t// in order to do so, we change the flag as we exit from the type, not the method", "-\t\t\t\t\t\t// itself, because the class scope is used to retrieve the fields.", "-\t\t\t\t\t\tMethodScope enclosingMethodScope = scope.methodScope();", "-\t\t\t\t\t\tinsideConstructorCall =", "-\t\t\t\t\t\t\tenclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase COMPILATION_UNIT_SCOPE :", "-\t\t\t\t\t\tbreak done;", "-\t\t\t\t}", "-\t\t\t\tscope = scope.parent;", "-\t\t\t}", "-", "-\t\t\tif (foundInsideProblem != null)", "-\t\t\t\treturn foundInsideProblem;", "-\t\t\tif (foundField != null) {", "-\t\t\t\tif (foundField.isValidBinding()){", "-\t\t\t\t\tif (foundDepth > 0){", "-\t\t\t\t\t\tinvocationSite.setDepth(foundDepth);", "-\t\t\t\t\t\tinvocationSite.setActualReceiverType(foundActualReceiverType);", "+\t\t\t\t\t\t\tdepth++;", "+\t\t\t\t\t\t\tinsideStaticContext |= enclosingType.isStatic();", "+\t\t\t\t\t\t\t// 1EX5I8Z - accessing outer fields within a constructor call is permitted", "+\t\t\t\t\t\t\t// in order to do so, we change the flag as we exit from the type, not the method", "+\t\t\t\t\t\t\t// itself, because the class scope is used to retrieve the fields.", "+\t\t\t\t\t\t\tMethodScope enclosingMethodScope = scope.methodScope();", "+\t\t\t\t\t\t\tinsideConstructorCall =", "+\t\t\t\t\t\t\t\tenclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase COMPILATION_UNIT_SCOPE :", "+\t\t\t\t\t\t\tbreak done;", "-\t\t\t\t\treturn foundField;", "+\t\t\t\t\tscope = scope.parent;", "-\t\t\t\tproblemField = foundField;", "+\t", "+\t\t\t\tif (foundInsideProblem != null)", "+\t\t\t\t\treturn foundInsideProblem;", "+\t\t\t\tif (foundField != null) {", "+\t\t\t\t\tif (foundField.isValidBinding()){", "+\t\t\t\t\t\tif (foundDepth > 0){", "+\t\t\t\t\t\t\tinvocationSite.setDepth(foundDepth);", "+\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(foundActualReceiverType);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn foundField;", "+\t\t\t\t\t}", "+\t\t\t\t\tproblemField = foundField;", "+\t\t\t\t}", "-\t\t}", "+\t", "+\t\t\t// We did not find a local or instance variable.", "+\t\t\tif ((mask & TYPE) != 0) {", "+\t\t\t\tif ((binding = getBaseType(name)) != null)", "+\t\t\t\t\treturn binding;", "+\t\t\t\tbinding = getTypeOrPackage(name, (mask & PACKAGE) == 0 ? TYPE : TYPE | PACKAGE);", "+\t\t\t\tif (binding.isValidBinding() || mask == TYPE)", "+\t\t\t\t\treturn binding;", "+\t\t\t\t// answer the problem type binding if we are only looking for a type", "+\t\t\t} else if ((mask & PACKAGE) != 0) {", "+\t\t\t\tcompilationUnitScope().recordSimpleReference(name);", "+\t\t\t\tif ((binding = environment().getTopLevelPackage(name)) != null)", "+\t\t\t\t\treturn binding;", "+\t\t\t}", "+\t\t\tif (problemField != null) return problemField;", "+\t\t\treturn new ProblemBinding(name, enclosingSourceType(), NotFound);", "-\t\t// We did not find a local or instance variable.", "-\t\tif ((mask & TYPE) != 0) {", "-\t\t\tif ((binding = getBaseType(name)) != null)", "-\t\t\t\treturn binding;", "-\t\t\tbinding = getTypeOrPackage(name, (mask & PACKAGE) == 0 ? TYPE : TYPE | PACKAGE);", "-\t\t\tif (binding.isValidBinding() || mask == TYPE)", "-\t\t\t\treturn binding;", "-\t\t\t// answer the problem type binding if we are only looking for a type", "-\t\t} else if ((mask & PACKAGE) != 0) {", "-\t\t\tcompilationUnitScope().recordSimpleReference(name);", "-\t\t\tif ((binding = environment().getTopLevelPackage(name)) != null)", "-\t\t\t\treturn binding;", "+\t\t} catch (AbortCompilation e) {", "+\t\t\te.updateContext(invocationSite, referenceCompilationUnit().compilationResult);", "+\t\t\tthrow e;", "-\t\tif (problemField != null) return problemField;", "-\t\treturn new ProblemBinding(name, enclosingSourceType(), NotFound);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bb125c39b04b3989e7f1ba57371aba79", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "368e7b2744bb4a520a4dfc9ab8183508aa7c626d", "commitAfterChange": "93b70485a331557e06c4f378f7086f6e4f12616a", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": "  \tpublic MethodBinding getConstructor(ReferenceBinding receiverType, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tpublic MethodBinding getConstructor(ReferenceBinding receiverType, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tcompilationUnitScope().recordTypeReference(receiverType);", "-\t\tcompilationUnitScope().recordTypeReferences(argumentTypes);", "-\t\tMethodBinding methodBinding = receiverType.getExactConstructor(argumentTypes);", "-\t\tif (methodBinding != null && methodBinding.canBeSeenBy(invocationSite, this))", "-\t\t\treturn methodBinding;", "-\t\tMethodBinding[] methods = receiverType.getMethods(ConstructorDeclaration.ConstantPoolName);", "-\t\tif (methods == NoMethods)", "-\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\tConstructorDeclaration.ConstantPoolName,", "-\t\t\t\targumentTypes,", "-\t\t\t\tNotFound);", "-", "-\t\tMethodBinding[] compatible = new MethodBinding[methods.length];", "-\t\tint compatibleIndex = 0;", "-\t\tfor (int i = 0, length = methods.length; i < length; i++)", "-\t\t\tif (areParametersAssignable(methods[i].parameters, argumentTypes))", "-\t\t\t\tcompatible[compatibleIndex++] = methods[i];", "-\t\tif (compatibleIndex == 0)", "-\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\tConstructorDeclaration.ConstantPoolName,", "-\t\t\t\targumentTypes,", "-\t\t\t\tNotFound);", "-\t\t// need a more descriptive error... cannot convert from X to Y", "-", "-\t\tMethodBinding[] visible = new MethodBinding[compatibleIndex];", "-\t\tint visibleIndex = 0;", "-\t\tfor (int i = 0; i < compatibleIndex; i++) {", "-\t\t\tMethodBinding method = compatible[i];", "-\t\t\tif (method.canBeSeenBy(invocationSite, this))", "-\t\t\t\tvisible[visibleIndex++] = method;", "+\t\ttry {", "+\t\t\tcompilationUnitScope().recordTypeReference(receiverType);", "+\t\t\tcompilationUnitScope().recordTypeReferences(argumentTypes);", "+\t\t\tMethodBinding methodBinding = receiverType.getExactConstructor(argumentTypes);", "+\t\t\tif (methodBinding != null && methodBinding.canBeSeenBy(invocationSite, this))", "+\t\t\t\treturn methodBinding;", "+\t\t\tMethodBinding[] methods = receiverType.getMethods(ConstructorDeclaration.ConstantPoolName);", "+\t\t\tif (methods == NoMethods)", "+\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\tConstructorDeclaration.ConstantPoolName,", "+\t\t\t\t\targumentTypes,", "+\t\t\t\t\tNotFound);", "+\t", "+\t\t\tMethodBinding[] compatible = new MethodBinding[methods.length];", "+\t\t\tint compatibleIndex = 0;", "+\t\t\tfor (int i = 0, length = methods.length; i < length; i++)", "+\t\t\t\tif (areParametersAssignable(methods[i].parameters, argumentTypes))", "+\t\t\t\t\tcompatible[compatibleIndex++] = methods[i];", "+\t\t\tif (compatibleIndex == 0)", "+\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\tConstructorDeclaration.ConstantPoolName,", "+\t\t\t\t\targumentTypes,", "+\t\t\t\t\tNotFound);", "+\t\t\t// need a more descriptive error... cannot convert from X to Y", "+\t", "+\t\t\tMethodBinding[] visible = new MethodBinding[compatibleIndex];", "+\t\t\tint visibleIndex = 0;", "+\t\t\tfor (int i = 0; i < compatibleIndex; i++) {", "+\t\t\t\tMethodBinding method = compatible[i];", "+\t\t\t\tif (method.canBeSeenBy(invocationSite, this))", "+\t\t\t\t\tvisible[visibleIndex++] = method;", "+\t\t\t}", "+\t\t\tif (visibleIndex == 1) return visible[0];", "+\t\t\tif (visibleIndex == 0)", "+\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\tcompatible[0],", "+\t\t\t\t\tConstructorDeclaration.ConstantPoolName,", "+\t\t\t\t\tcompatible[0].parameters,", "+\t\t\t\t\tNotVisible);", "+\t\t\treturn mostSpecificClassMethodBinding(visible, visibleIndex);", "+\t\t} catch (AbortCompilation e) {", "+\t\t\te.updateContext(invocationSite, referenceCompilationUnit().compilationResult);", "+\t\t\tthrow e;", "-\t\tif (visibleIndex == 1) return visible[0];", "-\t\tif (visibleIndex == 0)", "-\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\tcompatible[0],", "-\t\t\t\tConstructorDeclaration.ConstantPoolName,", "-\t\t\t\tcompatible[0].parameters,", "-\t\t\t\tNotVisible);", "-\t\treturn mostSpecificClassMethodBinding(visible, visibleIndex);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d5dc25f4cc57cb1caeeaabb37dc0fe7a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "61d2e9bd09460e9985288e8ef72cfc838f3c761c", "commitAfterChange": "834e812ce170c841e2ca1bd37b0a1867199e9deb", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \t \tvoid connectTypeHierarchy()", "signatureAfterChange": " \t \tvoid connectTypeHierarchy()", "diff": ["-\t\tcheckForInheritedMemberTypes(sourceType);", "+\t\ttry {", "+\t\t\tcheckForInheritedMemberTypes(sourceType);", "+\t\t} catch (AbortCompilation e) {", "+\t\t\te.updateContext(referenceContext, referenceCompilationUnit().compilationResult);", "+\t\t\tthrow e;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e63e3715c796a9a9d187610a50f6480d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "368e7b2744bb4a520a4dfc9ab8183508aa7c626d", "commitAfterChange": "93b70485a331557e06c4f378f7086f6e4f12616a", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": "  \tpublic MethodBinding getMethod(TypeBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tpublic MethodBinding getMethod(TypeBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tif (receiverType.isArrayType())", "-\t\t\treturn findMethodForArray((ArrayBinding) receiverType, selector, argumentTypes, invocationSite);", "-\t\tif (receiverType.isBaseType())", "-\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, NotFound);", "-", "-\t\tReferenceBinding currentType = (ReferenceBinding) receiverType;", "-\t\tif (!currentType.canBeSeenBy(this))", "-\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, ReceiverTypeNotVisible);", "-", "-\t\t// retrieve an exact visible match (if possible)", "-\t\tMethodBinding methodBinding = findExactMethod(currentType, selector, argumentTypes, invocationSite);", "-\t\tif (methodBinding != null) return methodBinding;", "-", "-\t\t// answers closest approximation, may not check argumentTypes or visibility", "-\t\tmethodBinding = findMethod(currentType, selector, argumentTypes, invocationSite);", "-\t\tif (methodBinding == null)", "-\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, NotFound);", "-\t\tif (methodBinding.isValidBinding()) {", "-\t\t\tif (!areParametersAssignable(methodBinding.parameters, argumentTypes))", "-\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\tmethodBinding,", "-\t\t\t\t\tselector,", "-\t\t\t\t\targumentTypes,", "-\t\t\t\t\tNotFound);", "-\t\t\tif (!methodBinding.canBeSeenBy(currentType, invocationSite, this))", "-\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\tmethodBinding,", "-\t\t\t\t\tselector,", "-\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\tNotVisible);", "+\t\ttry {", "+\t\t\tif (receiverType.isArrayType())", "+\t\t\t\treturn findMethodForArray((ArrayBinding) receiverType, selector, argumentTypes, invocationSite);", "+\t\t\tif (receiverType.isBaseType())", "+\t\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, NotFound);", "+\t", "+\t\t\tReferenceBinding currentType = (ReferenceBinding) receiverType;", "+\t\t\tif (!currentType.canBeSeenBy(this))", "+\t\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, ReceiverTypeNotVisible);", "+\t", "+\t\t\t// retrieve an exact visible match (if possible)", "+\t\t\tMethodBinding methodBinding = findExactMethod(currentType, selector, argumentTypes, invocationSite);", "+\t\t\tif (methodBinding != null) return methodBinding;", "+\t", "+\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "+\t\t\tmethodBinding = findMethod(currentType, selector, argumentTypes, invocationSite);", "+\t\t\tif (methodBinding == null)", "+\t\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, NotFound);", "+\t\t\tif (methodBinding.isValidBinding()) {", "+\t\t\t\tif (!areParametersAssignable(methodBinding.parameters, argumentTypes))", "+\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\tmethodBinding,", "+\t\t\t\t\t\tselector,", "+\t\t\t\t\t\targumentTypes,", "+\t\t\t\t\t\tNotFound);", "+\t\t\t\tif (!methodBinding.canBeSeenBy(currentType, invocationSite, this))", "+\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\tmethodBinding,", "+\t\t\t\t\t\tselector,", "+\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\tNotVisible);", "+\t\t\t}", "+\t\t\treturn methodBinding;", "+\t\t\t", "+\t\t} catch (AbortCompilation e) {", "+\t\t\te.updateContext(invocationSite, referenceCompilationUnit().compilationResult);", "+\t\t\tthrow e;", "-\t\treturn methodBinding;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f1cc41287562e62434955e806ba41e0e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "368e7b2744bb4a520a4dfc9ab8183508aa7c626d", "commitAfterChange": "93b70485a331557e06c4f378f7086f6e4f12616a", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "  \tpublic FieldBinding getField(TypeBinding receiverType, char[] fieldName, InvocationSite invocationSite)", "signatureAfterChange": "  \tpublic FieldBinding getField(TypeBinding receiverType, char[] fieldName, InvocationSite invocationSite)", "diff": ["-\t\tFieldBinding field = findField(receiverType, fieldName, invocationSite, true /*resolve*/);", "-\t\tif (field != null) return field;", "-", "-\t\treturn new ProblemFieldBinding(", "-\t\t\treceiverType instanceof ReferenceBinding ? (ReferenceBinding) receiverType : null,", "-\t\t\tfieldName,", "-\t\t\tNotFound);", "+\t\ttry {", "+\t\t\tFieldBinding field = findField(receiverType, fieldName, invocationSite, true /*resolve*/);", "+\t\t\tif (field != null) return field;", "+\t", "+\t\t\treturn new ProblemFieldBinding(", "+\t\t\t\treceiverType instanceof ReferenceBinding ? (ReferenceBinding) receiverType : null,", "+\t\t\t\tfieldName,", "+\t\t\t\tNotFound);", "+\t\t} catch (AbortCompilation e) {", "+\t\t\te.updateContext(invocationSite, referenceCompilationUnit().compilationResult);", "+\t\t\tthrow e;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f4780070139277b6fb55a752513ae8db", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "368e7b2744bb4a520a4dfc9ab8183508aa7c626d", "commitAfterChange": "93b70485a331557e06c4f378f7086f6e4f12616a", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": " \t \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes", "-\t\tchar[][] compoundName = typeReference.getTypeName();", "-\t\tcompilationUnitScope().recordQualifiedReference(compoundName);", "-\t\tSourceTypeBinding sourceType = referenceContext.binding;", "-\t\tint size = compoundName.length;", "-\t\tint n = 1;", "-\t\tReferenceBinding superType;", "-", "-\t\t// resolve the first name of the compoundName", "-\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {", "-\t\t\tsuperType = sourceType;", "-\t\t\t// match against the sourceType even though nested members cannot be supertypes", "-\t\t} else {", "-\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())", "-\t\t\t\treturn new ProblemReferenceBinding(", "-\t\t\t\t\tcompoundName[0],", "-\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());", "-", "-\t\t\tboolean checkVisibility = false;", "-\t\t\tfor (; n < size; n++) {", "-\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))", "-\t\t\t\t\tbreak;", "-\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;", "-\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);", "+\t\ttry {", "+\t\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes", "+\t\t\tchar[][] compoundName = typeReference.getTypeName();", "+\t\t\tcompilationUnitScope().recordQualifiedReference(compoundName);", "+\t\t\tSourceTypeBinding sourceType = referenceContext.binding;", "+\t\t\tint size = compoundName.length;", "+\t\t\tint n = 1;", "+\t\t\tReferenceBinding superType;", "+\t", "+\t\t\t// resolve the first name of the compoundName", "+\t\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {", "+\t\t\t\tsuperType = sourceType;", "+\t\t\t\t// match against the sourceType even though nested members cannot be supertypes", "+\t\t\t} else {", "+\t\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);", "-\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),", "+\t\t\t\t\t\tcompoundName[0],", "-\t\t\t\tcheckVisibility = true;", "+\t", "+\t\t\t\tboolean checkVisibility = false;", "+\t\t\t\tfor (; n < size; n++) {", "+\t\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;", "+\t\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);", "+\t\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())", "+\t\t\t\t\t\treturn new ProblemReferenceBinding(", "+\t\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),", "+\t\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());", "+\t\t\t\t\tcheckVisibility = true;", "+\t\t\t\t}", "+\t", "+\t\t\t\t// convert to a ReferenceBinding", "+\t\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName", "+\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);", "+\t\t\t\tsuperType = (ReferenceBinding) typeOrPackage;", "+\t\t\t\tcompilationUnitScope().recordTypeReference(superType); // to record supertypes", "+\t", "+\t\t\t\tif (checkVisibility", "+\t\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility", "+\t\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))", "+\t\t\t\t\t\t// its a toplevel type so just check package access", "+\t\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), superType, NotVisible);", "+\t\t\t\t}", "-", "-\t\t\t// convert to a ReferenceBinding", "-\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);", "-\t\t\tsuperType = (ReferenceBinding) typeOrPackage;", "-\t\t\tcompilationUnitScope().recordTypeReference(superType); // to record supertypes", "-", "-\t\t\tif (checkVisibility", "-\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility", "-\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))", "-\t\t\t\t\t// its a toplevel type so just check package access", "-\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), superType, NotVisible);", "+\t\t\t// at this point we know we have a type but we have to look for cycles", "+\t\t\twhile (true) {", "+\t\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.", "+\t\t\t\t// must be guaranteed that the superType knows its entire hierarchy", "+\t\t\t\tif (detectCycle(sourceType, superType, typeReference))", "+\t\t\t\t\treturn null; // cycle error was already reported", "+\t", "+\t\t\t\tif (n >= size)", "+\t\t\t\t\tbreak;", "+\t", "+\t\t\t\t// retrieve the next member type", "+\t\t\t\tchar[] typeName = compoundName[n++];", "+\t\t\t\tsuperType = findMemberType(typeName, superType);", "+\t\t\t\tif (superType == null)", "+\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);", "+\t\t\t\tif (!superType.isValidBinding()) {", "+\t\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);", "+\t\t\t\t\treturn superType;", "+\t\t\t\t}", "+\t\t\treturn superType;", "+\t\t} catch (AbortCompilation e) {", "+\t\t\te.updateContext(typeReference, referenceCompilationUnit().compilationResult);", "+\t\t\tthrow e;", "-\t\t// at this point we know we have a type but we have to look for cycles", "-\t\twhile (true) {", "-\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.", "-\t\t\t// must be guaranteed that the superType knows its entire hierarchy", "-\t\t\tif (detectCycle(sourceType, superType, typeReference))", "-\t\t\t\treturn null; // cycle error was already reported", "-", "-\t\t\tif (n >= size)", "-\t\t\t\tbreak;", "-", "-\t\t\t// retrieve the next member type", "-\t\t\tchar[] typeName = compoundName[n++];", "-\t\t\tsuperType = findMemberType(typeName, superType);", "-\t\t\tif (superType == null)", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);", "-\t\t\tif (!superType.isValidBinding()) {", "-\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);", "-\t\t\t\treturn superType;", "-\t\t\t}", "-\t\t}", "-\t\treturn superType;"]}], "num": 47507}