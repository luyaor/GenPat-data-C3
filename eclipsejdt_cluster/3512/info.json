{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8c5eeb13e49a61014e3f7ec142955595", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "70e54f11faa1939487ebf8bb9c0069e0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "7fb86fb96d585ee8957fc13764a67f220efdab28", "commitAfterChange": "ac9209adc3bf5bee5093a73bfc9f86fe5825e76d", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic void createParser(JavaProject project) throws JavaModelException", "signatureAfterChange": " \tpublic void initialize(JavaProject project) throws JavaModelException", "diff": ["+\t */", "+\tpublic void initialize(JavaProject project) throws JavaModelException {", "+\t\t// create lookup environment", "+\t\tCompilerOptions options = new CompilerOptions(project.getOptions(true));", "+\t\tProblemReporter problemReporter =", "+\t\t\tnew ProblemReporter(", "+\t\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(),", "+\t\t\t\toptions,", "+\t\t\t\tnew DefaultProblemFactory());", "+\t\tthis.lookupEnvironment =", "+\t\t\tnew LookupEnvironment(this, options, problemReporter, this.nameEnvironment);", "+\t\t\t", "+\t\t// create parser", "+\t\tthis.parser = new MatchLocatorParser(problemReporter, options.sourceLevel >= CompilerOptions.JDK1_4);", "+\t\t", "+\t\t// reset parsed units (they could hold onto obsolete bindings: see bug 16052)", "+\t\tMatchingOpenable[] openables = this.matchingOpenables.getMatchingOpenables(project.getPackageFragmentRoots());", "+\t\tfor (int i = 0, length = openables.length; i < length; i++) {", "+\t\t\tMatchingOpenable matchingOpenable = openables[i];", "+\t\t\tmatchingOpenable.reset();", "+\t\t}", "+\t\tthis.parsedUnits = new HashtableOfObject(10);", "+\t\t", "+\t\t// remember project's name lookup", "+\t\tthis.nameLookup = project.getNameLookup();", "+\t}", "-\t */", "-\tpublic void createParser(JavaProject project) throws JavaModelException {", "-\t\t// cleaup and recreate file name environment", "-\t\tif (this.nameEnvironment != null) {", "-\t\t\tthis.nameEnvironment.cleanup();", "-\t\t}", "-\t\tthis.nameEnvironment = this.getNameEnvironment(project);", "-\t\t", "-\t\t// create lookup environment", "-\t\tCompilerOptions options = new CompilerOptions(project.getOptions(true));", "-\t\tProblemReporter problemReporter =", "-\t\t\tnew ProblemReporter(", "-\t\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(),", "-\t\t\t\toptions,", "-\t\t\t\tnew DefaultProblemFactory());", "-\t\tthis.lookupEnvironment =", "-\t\t\tnew LookupEnvironment(this, options, problemReporter, this.nameEnvironment);", "-\t\t\t", "-\t\t// create parser", "-\t\tthis.parser = new MatchLocatorParser(problemReporter, options.sourceLevel >= CompilerOptions.JDK1_4);", "-\t\t", "-\t\t// reset parsed units (they could hold onto obsolete bindings: see bug 16052)", "-\t\tMatchingOpenable[] openables = this.matchingOpenables.getMatchingOpenables(project.getPackageFragmentRoots());", "-\t\tfor (int i = 0, length = openables.length; i < length; i++) {", "-\t\t\tMatchingOpenable matchingOpenable = openables[i];", "-\t\t\tmatchingOpenable.reset();", "-\t\t}", "-\t\tthis.parsedUnits = new HashtableOfObject(10);", "-\t\t", "-\t\t// remember project's name lookup", "-\t\tthis.nameLookup = project.getNameLookup();", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8fbb1030d8cd45da804d718b4ecd2bac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "70416b46b1375461a92d89ffa1cb077778dc6e86", "commitAfterChange": "0c53505dd9d8f221929a96f99e04ff55bfc4fc05", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tpublic void initialize(JavaProject project) throws JavaModelException", "signatureAfterChange": " \tpublic void initialize(JavaProject project, PotentialMatch[] potentialMatches) throws JavaModelException", "diff": ["+\t */", "+\tpublic void initialize(JavaProject project, PotentialMatch[] potentialMatches) throws JavaModelException {", "+\t\t// create name environment", "+\t\tif (this.nameEnvironment != null) { // cleanup", "+\t\t\tthis.nameEnvironment.cleanup();", "+\t\t}", "+\t\tif (potentialMatches.length == 1) {", "+\t\t\t// if only one potential match, a file name environment costs too much,", "+\t\t\t// so use the existing searchable  environment which will populate the java model", "+\t\t\t// only for this potential match and its required types.", "+\t\t\tthis.nameEnvironment = project.getSearchableNameEnvironment();", "+\t\t} else {", "+\t\t\tthis.nameEnvironment = new JavaSearchNameEnvironment2(project);", "+\t\t}", "+", "-\t\tCompilerOptions options = new CompilerOptions(project.getOptions(true));", "+\t\tthis.options = new CompilerOptions(project.getOptions(true));", "-\t\t\t\toptions,", "+\t\t\t\tthis.options,", "-\t\t\tnew LookupEnvironment(this, options, problemReporter, this.nameEnvironment);", "+\t\t\tnew LookupEnvironment(this, this.options, problemReporter, this.nameEnvironment);", "-\t\tthis.parser = new MatchLocatorParser(problemReporter, options.sourceLevel);", "-\t\t", "-\t\t// reset parsed units (they could hold onto obsolete bindings: see bug 16052)", "-\t\tMatchingOpenable[] openables = this.matchingOpenables.getMatchingOpenables(project.getPackageFragmentRoots());", "-\t\tfor (int i = 0, length = openables.length; i < length; i++) {", "-\t\t\tMatchingOpenable matchingOpenable = openables[i];", "-\t\t\tmatchingOpenable.reset();", "-\t\t}", "-\t\tthis.parsedUnits = new HashtableOfObject(10);", "-\t\t", "+\t\tthis.parser = new MatchLocatorParser(problemReporter, this.options.sourceLevel);", "+\t\t\t\t", "-\t}", "+\t\t", "+\t\t// initialize queue of units", "+\t\tthis.totalUnits = 0;", "+\t\tint maxUnits = potentialMatches.length;", "+\t\tthis.unitsToProcess = new CompilationUnitDeclaration[maxUnits];", "+\t\tthis.matchesToProcess = new PotentialMatch[maxUnits];", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bed6711f1bb04f1c150f3657db338983", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic void initialize(JavaProject project, PotentialMatch[] potentialMatches) throws JavaModelException", "signatureAfterChange": " public void initialize(JavaProject project, int potentialMatchSize) throws JavaModelException", "diff": ["-\t */", "-\tpublic void initialize(JavaProject project, PotentialMatch[] potentialMatches) throws JavaModelException {", "-\t\t// create name environment", "-\t\tif (this.nameEnvironment != null) { // cleanup", "-\t\t\tthis.nameEnvironment.cleanup();", "-\t\t}", "-\t\tif (potentialMatches.length == 1) {", "-\t\t\t// if only one potential match, a file name environment costs too much,", "-\t\t\t// so use the existing searchable  environment which will populate the java model", "-\t\t\t// only for this potential match and its required types.", "-\t\t\tthis.nameEnvironment = project.getSearchableNameEnvironment();", "-\t\t} else {", "-\t\t\tthis.nameEnvironment = new JavaSearchNameEnvironment(project);", "-\t\t}", "-", "-\t\t// create lookup environment", "-\t\tthis.options = new CompilerOptions(project.getOptions(true));", "-\t\tthis.lookupEnvironment =", "-\t\t\tnew LookupEnvironment(this, this.options, problemReporter, this.nameEnvironment);", "-\t\t\t", "-\t\t// create parser", "-\t\tthis.parser = new MatchLocatorParser(problemReporter);", "-\t\t\t\t", "-\t\t// remember project's name lookup", "-\t\tthis.nameLookup = project.getNameLookup();", "-\t\t", "-\t\t// initialize queue of units", "-\t\tthis.totalUnits = 0;", "-\t\tint maxUnits = potentialMatches.length;", "-\t\tthis.unitsToProcess = new CompilationUnitDeclaration[maxUnits];", "-\t\tthis.matchesToProcess = new PotentialMatch[maxUnits];", "-\t}", "+ */", "+public void initialize(JavaProject project, int potentialMatchSize) throws JavaModelException {", "+\tif (this.nameEnvironment != null)", "+\t\tthis.nameEnvironment.cleanup();", "+", "+\t// if only one potential match, a file name environment costs too much,", "+\t// so use the existing searchable  environment which will populate the java model", "+\t// only for this potential match and its required types.", "+\tthis.nameEnvironment = potentialMatchSize == 1", "+\t\t? (INameEnvironment) project.getSearchableNameEnvironment()", "+\t\t: (INameEnvironment) new JavaSearchNameEnvironment(project);", "+", "+\t// create lookup environment", "+\tthis.options = new CompilerOptions(project.getOptions(true));", "+\tProblemReporter problemReporter =", "+\t\tnew ProblemReporter(", "+\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(),", "+\t\t\tthis.options,", "+\t\t\tnew DefaultProblemFactory());", "+\tthis.lookupEnvironment = new LookupEnvironment(this, this.options, problemReporter, this.nameEnvironment);", "+", "+\tthis.parser = new MatchLocatorParser(problemReporter);", "+", "+\t// remember project's name lookup", "+\tthis.nameLookup = project.getNameLookup();", "+", "+\t// initialize queue of units", "+\tthis.numberOfMatches = 0;", "+\tthis.matchesToProcess = new PotentialMatch[potentialMatchSize];", "+}"]}], "num": 3512}