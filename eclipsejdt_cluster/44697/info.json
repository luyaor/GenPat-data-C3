{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "881aaf913664334b95e282c5aa57eca6", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09097489857d8d4ef78785a93fbaa03f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "2fd2027f1bd96549ae174a672a3e75a3fbef9f00", "commitAfterChange": "bbdc67ca80e8d3933fe67f2dadba11598c084b7c", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r \tpublic IJavaElementDelta processExternalJarChanges()", "signatureAfterChange": "\r \tpublic void checkExternalJarChanges(IProgressMonitor monitor)", "diff": ["+\t */\r", "+\tpublic void checkExternalJarChanges(IProgressMonitor monitor) {\r", "+\r", "+\t\ttry {\r", "+\t\t\tHashMap externalJARsStatus = new HashMap();\r", "+\t\t\t\r", "+\t\t\tJavaModel model = manager.getJavaModel();\t\t\t\r", "+\t\t\tfCurrentDelta = new JavaElementDelta(model);\r", "+\t\t\tboolean hasDelta = false;\r", "+\t\t\t\r", "+\t\t\tIJavaProject[] projects =model.getOldJavaProjectsList();\r", "+\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {\r", "+\t\t\t\tIJavaProject project = projects[i];\r", "+\t\t\t\tIClasspathEntry[] entries = project.getResolvedClasspath(true);\r", "+\t\t\t\tfor (int j = 0; j < entries.length; j++){\r", "+\t\t\t\t\tif (entries[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY) {\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\t\tIPath entryPath = entries[j].getPath();\r", "+\t\t\t\t\t\tString status = (String)externalJARsStatus.get(entryPath); \r", "+\t\t\t\t\t\tif (status == null){\r", "+\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t// compute shared status\r", "+\t\t\t\t\t\t\tObject targetLibrary = JavaModel.getTarget(project.getProject(), entryPath, true);\r", "+\r", "+\t\t\t\t\t\t\tif (targetLibrary == null){ // missing JAR\r", "+\t\t\t\t\t\t\t\tif (this.externalTimeStamps.containsKey(entryPath)){\r", "+\t\t\t\t\t\t\t\t\tthis.externalTimeStamps.remove(entryPath);\r", "+\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_REMOVED);\r", "+\t\t\t\t\t\t\t\t\t// the jar was physically removed: remove the index\r", "+\t\t\t\t\t\t\t\t\tindexManager.removeIndex(entryPath);\r", "+\t\t\t\t\t\t\t\t}\r", "+\r", "+\t\t\t\t\t\t\t} else if (targetLibrary instanceof File){ // external JAR\r", "+\r", "+\t\t\t\t\t\t\t\tFile externalFile = (File)targetLibrary;\r", "+\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t\t// check timestamp to figure if JAR has changed in some way\r", "+\t\t\t\t\t\t\t\tLong oldTimestamp =(Long) this.externalTimeStamps.get(entryPath);\r", "+\t\t\t\t\t\t\t\tlong newTimeStamp = getTimeStamp(externalFile);\r", "+\t\t\t\t\t\t\t\tif (oldTimestamp != null){\r", "+\r", "+\t\t\t\t\t\t\t\t\tif (newTimeStamp == 0){ // file doesn't exist\r", "+\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_REMOVED);\r", "+\t\t\t\t\t\t\t\t\t\tthis.externalTimeStamps.remove(entryPath);\r", "+\t\t\t\t\t\t\t\t\t\t// remove the index\r", "+\t\t\t\t\t\t\t\t\t\tindexManager.removeIndex(entryPath);\r", "+\r", "+\t\t\t\t\t\t\t\t\t} else if (oldTimestamp.longValue() != newTimeStamp){\r", "+\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_CHANGED);\r", "+\t\t\t\t\t\t\t\t\t\tthis.externalTimeStamps.put(entryPath, new Long(newTimeStamp));\r", "+\t\t\t\t\t\t\t\t\t\t// first remove the index so that it is forced to be re-indexed\r", "+\t\t\t\t\t\t\t\t\t\tindexManager.removeIndex(entryPath);\r", "+\t\t\t\t\t\t\t\t\t\t// then index the jar\r", "+\t\t\t\t\t\t\t\t\t\tindexManager.indexLibrary(entryPath, project.getProject());\r", "+\t\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);\r", "+\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\tif (newTimeStamp == 0){ // jar still doesn't exist\r", "+\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);\r", "+\t\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_ADDED);\r", "+\t\t\t\t\t\t\t\t\t\tthis.externalTimeStamps.put(entryPath, new Long(newTimeStamp));\r", "+\t\t\t\t\t\t\t\t\t\t// index the new jar\r", "+\t\t\t\t\t\t\t\t\t\tindexManager.indexLibrary(entryPath, project.getProject());\r", "+\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t} else { // internal JAR\r", "+\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, INTERNAL_JAR_IGNORE);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t// according to computed status, generate a delta\r", "+\t\t\t\t\t\tstatus = (String)externalJARsStatus.get(entryPath); \r", "+\t\t\t\t\t\tif (status != null){\r", "+\t\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)project.getPackageFragmentRoot(entryPath.toString());\r", "+\t\t\t\t\t\t\tif (status == EXTERNAL_JAR_ADDED){\r", "+\t\t\t\t\t\t\t\tif (VERBOSE){\r", "+\t\t\t\t\t\t\t\t\tSystem.out.println(\"- External JAR ADDED, affecting root: \"+root.getElementName());\r", "+\t\t\t\t\t\t\t\t} \r", "+\t\t\t\t\t\t\t\telementAdded(root, null);\r", "+\t\t\t\t\t\t\t\thasDelta = true;\r", "+\t\t\t\t\t\t\t} else if (status == EXTERNAL_JAR_CHANGED) {\r", "+\t\t\t\t\t\t\t\tif (VERBOSE){\r", "+\t\t\t\t\t\t\t\t\tSystem.out.println(\"- External JAR CHANGED, affecting root: \"+root.getElementName());\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\tcontentChanged(root, null);\r", "+\t\t\t\t\t\t\t\thasDelta = true;\r", "+\t\t\t\t\t\t\t} else if (status == EXTERNAL_JAR_REMOVED) {\r", "+\t\t\t\t\t\t\t\tif (VERBOSE){\r", "+\t\t\t\t\t\t\t\t\tSystem.out.println(\"- External JAR REMOVED, affecting root: \"+root.getElementName());\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\telementRemoved(root, null);\r", "+\t\t\t\t\t\t\t\thasDelta = true;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tif (hasDelta){\r", "+\t\t\t\tthis.manager.fire(fCurrentDelta, JavaModelManager.DEFAULT_CHANGE_EVENT);\t\t\t\r", "+\t\t\t}\r", "+\t\t} catch (JavaModelException e) { // nothing can be done\r", "+\t\t} finally {\r", "+\t\t\tfCurrentDelta = null;\r", "+\t\t}\r", "+\t}\r", "-\t */\r", "-\tpublic IJavaElementDelta processExternalJarChanges() {\r", "-\t\t\r", "-\t\t// did any external JAR change ?\r", "-\t\tif (this.externalJarPathsToUpdate.isEmpty()) return null;\r", "-\t\ttry {\r", "-\t\t\tJavaModel model = manager.getJavaModel();\r", "-\t\t\tfCurrentDelta = new JavaElementDelta(model);\r", "-\t\t\tIJavaProject[] projects =model.getOldJavaProjectsList();\r", "-\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {\r", "-\t\t\t\tIJavaProject project = projects[i];\r", "-\t\t\t\tIPackageFragmentRoot[] roots = project.getPackageFragmentRoots();\r", "-\t\t\t\tfor (int j = 0; j < roots.length; j++){\r", "-\t\t\t\t\tif (this.externalJarPathsToUpdate.contains(roots[j].getPath())){\r", "-\t\t\t\t\t\tif (VERBOSE){\r", "-\t\t\t\t\t\t\tSystem.out.println(\"External JAR changed, affecting root: \"+roots[j].getElementName());\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tcontentChanged((Openable)roots[j], null);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\treturn fCurrentDelta;\r", "-\t\t} catch (JavaModelException e) { // nothing can be done\r", "-\t\t} finally {\r", "-\t\t\tthis.externalJarPathsToUpdate.clear();\r", "-\t\t}\r", "-\t\treturn null;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "17e97c2b96060f32d5ceebd7627a572a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests.java", "commitBeforeChange": "a4c87b85ad074ebb6b6f76117f9e2f37a165a84d", "commitAfterChange": "4464f32c1c4717c63fedbced19c6da0d541eee99", "methodNumberBeforeChange": 613, "methodNumberAfterChange": 613, "signatureBeforeChange": " public void testBug286379c() throws CoreException", "signatureAfterChange": " public void testBug286379c() throws CoreException", "diff": ["-\tSystem.out.println(\"Forbidden reference at the start of the test is \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "+\tSystem.out.println(\"================================================================================\");", "+\tSystem.out.println(\"Starting test JavaSearchBugTests.testBug286379c()...\");", "+\tSystem.out.println(\"\t- Options at test start:\");", "+\tSystem.out.println(\"\t\t+ Task tags:           \" + JavaCore.getOption(JavaCore.COMPILER_TASK_TAGS));", "+\tSystem.out.println(\"\t\t+ Task priorities:     \" + JavaCore.getOption(JavaCore.COMPILER_TASK_PRIORITIES));", "+\tSystem.out.println(\"\t\t+ Forbidden reference: \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "-\t\tSystem.out.println(\"Forbidden reference before first exit \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "+\t\tSystem.out.println(\"\t- Options before first exit:\");", "+\t\tSystem.out.println(\"\t\t+ Task tags:           \" + JavaCore.getOption(JavaCore.COMPILER_TASK_TAGS));", "+\t\tSystem.out.println(\"\t\t+ Task priorities:     \" + JavaCore.getOption(JavaCore.COMPILER_TASK_PRIORITIES));", "+\t\tSystem.out.println(\"\t\t+ Forbidden reference: \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "-\t\tSystem.out.println(\"Forbidden reference after first restart \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "+\t\tSystem.out.println(\"\t- Options after first restart:\");", "+\t\tSystem.out.println(\"\t\t+ Task tags:           \" + JavaCore.getOption(JavaCore.COMPILER_TASK_TAGS));", "+\t\tSystem.out.println(\"\t\t+ Task priorities:     \" + JavaCore.getOption(JavaCore.COMPILER_TASK_PRIORITIES));", "+\t\tSystem.out.println(\"\t\t+ Forbidden reference: \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "-\t\tSystem.out.println(\"Forbidden reference before second exit \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "+\t\tSystem.out.println(\"\t- Options before second exit:\");", "+\t\tSystem.out.println(\"\t\t+ Task tags:           \" + JavaCore.getOption(JavaCore.COMPILER_TASK_TAGS));", "+\t\tSystem.out.println(\"\t\t+ Task priorities:     \" + JavaCore.getOption(JavaCore.COMPILER_TASK_PRIORITIES));", "+\t\tSystem.out.println(\"\t\t+ Forbidden reference: \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "-\t\tSystem.out.println(\"Forbidden reference after second restart \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "+\t\tSystem.out.println(\"\t- Options after second restart:\");", "+\t\tSystem.out.println(\"\t\t+ Task tags:           \" + JavaCore.getOption(JavaCore.COMPILER_TASK_TAGS));", "+\t\tSystem.out.println(\"\t\t+ Task priorities:     \" + JavaCore.getOption(JavaCore.COMPILER_TASK_PRIORITIES));", "+\t\tSystem.out.println(\"\t\t+ Forbidden reference: \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "+\t\tSystem.out.println(\"\t- Options after search:\");", "+\t\tSystem.out.println(\"\t\t+ Task tags:           \" + JavaCore.getOption(JavaCore.COMPILER_TASK_TAGS));", "+\t\tSystem.out.println(\"\t\t+ Task priorities:     \" + JavaCore.getOption(JavaCore.COMPILER_TASK_PRIORITIES));", "+\t\tSystem.out.println(\"\t\t+ Forbidden reference: \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "+\t\tSystem.out.println(\"\t- Options at test end:\");", "+\t\tSystem.out.println(\"\t\t+ Task tags:           \" + JavaCore.getOption(JavaCore.COMPILER_TASK_TAGS));", "+\t\tSystem.out.println(\"\t\t+ Task priorities:     \" + JavaCore.getOption(JavaCore.COMPILER_TASK_PRIORITIES));", "+\t\tSystem.out.println(\"\t\t+ Forbidden reference: \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "+\t\tSystem.out.println(\"================================================================================\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1cfdd2c07cb0505605b9a1563c21de90", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "1f208848d9d92ae1f4b172b0ad007166a9efef48", "commitAfterChange": "5b3251005dd395c785cb3022359f7008572b8d06", "methodNumberBeforeChange": 53, "methodNumberAfterChange": 53, "signatureBeforeChange": "  \tpublic void printModifiers(Annotation[] annotations, ASTVisitor visitor)", "signatureAfterChange": "  \tpublic void printModifiers(Annotation[] annotations, ASTVisitor visitor)", "diff": ["-\t\tprintModifiers(annotations, visitor, false);", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46b2951351041bd029d4f64331ac24a7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java", "commitBeforeChange": "06e44af1d1177a8820136cde1fbe3146b9563e7f", "commitAfterChange": "c0452100f2ed18d65cf0dd0efb6f9fc0ffa98156", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 35, "signatureBeforeChange": "  \tprotected void setUp() throws Exception", "signatureAfterChange": "  \tprotected void setUp() throws Exception", "diff": ["+\t\tif (RUN_JAVAC) {", "+\t\t\tif (!getClass().getName().equals(CURRENT_CLASS_NAME)) {", "+\t\t\t\tif (javacFullLog == null) {", "+\t\t\t\t\t// One time initialization of javac related concerns", "+\t\t\t\t\t// compute command lines and extract javac version", "+\t\t\t\t\tString jdkRootDirectory = System.getProperty(\"jdk.root\");", "+\t\t\t\t\tif (jdkRootDirectory == null)", "+\t\t\t\t\t  jdkRootDirPath = (new Path(Util.getJREDirectory())).removeLastSegments(1);", "+\t\t\t\t\telse ", "+\t\t\t\t\t\tjdkRootDirPath = new Path(jdkRootDirectory);", "+\t\t", "+\t\t\t\t\tStringBuffer cmdLineHeader = new StringBuffer(jdkRootDirPath.", "+\t\t\t\t\t\t\tappend(\"bin\").append(JAVA_NAME).toString()); // PREMATURE replace JAVA_NAME and JAVAC_NAME with locals? depends on potential reuse", "+\t\t\t\t\tjavaCommandLineHeader = cmdLineHeader.toString();", "+\t\t\t\t\tcmdLineHeader = new StringBuffer(jdkRootDirPath.", "+\t\t\t\t\t\t\tappend(\"bin\").append(JAVAC_NAME).toString());", "+\t\t\t\t\tcmdLineHeader.append(\" -classpath . \");", "+\t\t\t\t\t  // start with the current directory which contains the source files", "+\t\t\t\t\tProcess compileProcess = Runtime.getRuntime().exec(", "+\t\t\t\t\t\tcmdLineHeader.toString() + \" -version\", null, null);", "+\t        Logger versionLogger = new Logger(compileProcess.getErrorStream(), \"\"); // WORK            ", "+\t        versionLogger.start();", "+\t        compileProcess.waitFor();", "+\t\t\t\t\tversionLogger.join(); // make sure we get the whole output", "+\t\t\t\t\tString version = versionLogger.buffer.toString();", "+\t\t\t\t\tint eol = version.indexOf('\\n');", "+\t\t\t\t\tversion = version.substring(0, eol);", "+\t\t\t\t\tcmdLineHeader.append(\" -d \");", "+\t\t\t\t\tcmdLineHeader.append(JAVAC_OUTPUT_DIR.indexOf(\" \") != -1 ? \"\\\"\" + JAVAC_OUTPUT_DIR + \"\\\"\" : JAVAC_OUTPUT_DIR);", "+\t\t\t\t\tcmdLineHeader.append(\" -source 1.5 -deprecation -Xlint:unchecked \"); // enable recommended warnings", "+\t\t\t\t\t// REVIEW consider enabling all warnings instead? Philippe does not see", "+\t\t\t\t\t//        this as ez to use (too many changes in logs)", "+\t\t\t\t\tjavacCommandLineHeader = cmdLineHeader.toString();", "+", "+\t\t\t\t\t// open output log", "+\t\t\t\t\tString javacFullLogFileName = ", "+\t\t\t\t\t\t\tUtil.getOutputDirectory() +\tFile.separatorChar + ", "+\t\t\t\t\t\t\tversion.replace(' ', '_') + \"_\" + ", "+\t\t\t\t\t    (new SimpleDateFormat(\"yyyyMMdd_HHmmss\")).format(new Date()) +", "+\t\t\t\t\t    \".txt\";", "+\t\t\t\t\tjavacFullLog = ", "+\t\t\t\t\t  \tnew PrintWriter(new FileOutputStream(javacFullLogFileName));", "+\t\t\t\t\tjavacFullLog.println(version); // so that the contents is self sufficient", "+\t\t\t\t\tSystem.out.println(\"***************************************************************************\");", "+\t\t\t\t\tSystem.out.println(\"* Sun Javac compiler output archived into file:\");", "+\t\t\t\t\tSystem.out.println(\"* \" + javacFullLogFileName);", "+\t\t\t\t\tSystem.out.println(\"***************************************************************************\");", "+\t\t\t\t}", "+\t\t\t\t// per class initialization", "+\t\t\t\tCURRENT_CLASS_NAME = getClass().getName();", "+\t\t\t\tdualPrintln(\"***************************************************************************\");", "+\t\t\t\tSystem.out.print(\"* Comparison with Sun Javac compiler for class \");", "+\t\t\t\tdualPrintln(CURRENT_CLASS_NAME.substring(CURRENT_CLASS_NAME.lastIndexOf('.')+1) + ", "+\t\t\t\t\t\t\" (\" + TESTS_COUNTERS.get(CURRENT_CLASS_NAME) + \" tests)\");", "+\t\t\t\tSystem.out.println(\"***************************************************************************\");", "+\t\t\t\tDIFF_COUNTERS[0] = 0;", "+\t\t\t\tDIFF_COUNTERS[1] = 0;", "+\t\t\t\tDIFF_COUNTERS[2] = 0;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "78549818ab66c10474ba2b1d48b63697", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor.java", "commitBeforeChange": "64298556651d81e68f8405c1642b36744d7373dd", "commitAfterChange": "b92bafecd030777e0d6056677f8286cf640a489f", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 1, "signatureBeforeChange": " public void acceptType(char[] packageName, char[] typeName, char[] completionName, int completionStart, int completionEnd, int relevance)", "signatureAfterChange": " \tpublic void accept(CompletionProposal proposal)", "diff": ["- */", "-public void acceptType(char[] packageName, char[] typeName, char[] completionName, int completionStart, int completionEnd, int relevance) {", "-\tfElements.addElement(new String(typeName));", "-\tfCompletions.addElement(new String(completionName));", "-\tfRelevances.addElement(String.valueOf(relevance));", "-\tfCompletionStart.addElement(String.valueOf(completionStart));", "-\tfCompletionEnd.addElement(String.valueOf(completionEnd));", "-\tif (fDebug)", "-\t\tSystem.out.println(\"type \" + new String(typeName));", "-}", "+\t}", "+\tpublic void accept(CompletionProposal proposal) {", "+\t\tchar[] typeName = null;", "+\t\tswitch(proposal.getKind()) {", "+\t\t\tcase CompletionProposal.ANONYMOUS_CLASS_DECLARATION :", "+\t\t\t\ttypeName = Signature.getSignatureSimpleName(proposal.getDeclarationSignature());", "+\t\t\t\tfElements.addElement(new String(typeName));", "+\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\tif (fDebug)", "+\t\t\t\t\tSystem.out.println(\"anonymous type \" + new String(typeName));", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tcase CompletionProposal.TYPE_REF :", "+\t\t\t\tif((proposal.getFlags() & Flags.AccEnum) != 0) {", "+\t\t\t\t\t", "+\t\t\t\t} else if((proposal.getFlags() & Flags.AccInterface) != 0) {", "+\t\t\t\t\ttypeName = Signature.getSignatureSimpleName(proposal.getSignature());", "+\t\t\t\t\tfElements.addElement(new String(typeName));", "+\t\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\t\tif (fDebug)", "+\t\t\t\t\t\tSystem.out.println(\"Interface \" + new String(typeName));", "+\t\t\t\t} else {", "+\t\t\t\t\ttypeName = Signature.getSignatureSimpleName(proposal.getSignature());", "+\t\t\t\t\tfElements.addElement(new String(typeName));", "+\t\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\t\tif (fDebug) {", "+\t\t\t\t\t\tif(Signature.getTypeSignatureKind(proposal.getSignature()) == Signature.TYPE_VARIABLE_SIGNATURE) {", "+\t\t\t\t\t\t\tSystem.out.println(\"type parameter \" + new String(typeName));", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tSystem.out.println(\"Class \" + new String(typeName));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tcase CompletionProposal.FIELD_REF :", "+\t\t\t\tfElements.addElement(new String(proposal.getName()));", "+\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\tif (fDebug)", "+\t\t\t\t\tSystem.out.println(\"Field \" + new String(proposal.getName()));", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tcase CompletionProposal.KEYWORD:", "+\t\t\t\tfElements.addElement(new String(proposal.getName()));", "+\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\tif (fDebug)", "+\t\t\t\t\tSystem.out.println(\"Keyword \" + new String(proposal.getName()));", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tcase CompletionProposal.LABEL_REF:", "+\t\t\t\tfElements.addElement(new String(proposal.getName()));", "+\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\tif (fDebug)", "+\t\t\t\t\tSystem.out.println(\"Label \" + new String(proposal.getName()));", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tcase CompletionProposal.LOCAL_VARIABLE_REF:", "+\t\t\t\tfElements.addElement(new String(proposal.getName()));", "+\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\tif (fDebug)", "+\t\t\t\t\tSystem.out.println(\"Local variable \" + new String(proposal.getName()));", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tcase CompletionProposal.METHOD_REF:", "+\t\t\t\tfElements.addElement(new String(proposal.getName()));", "+\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\tif (fDebug)", "+\t\t\t\t\tSystem.out.println(\"method \" + new String(proposal.getName()));", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tcase CompletionProposal.METHOD_DECLARATION:", "+\t\t\t\tfElements.addElement(new String(proposal.getName()));", "+\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\tif (fDebug)", "+\t\t\t\t\tSystem.out.println(\"method declaration \" + new String(proposal.getName()));", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tcase CompletionProposal.PACKAGE_REF:", "+\t\t\t\tfElements.addElement(new String(proposal.getDeclarationSignature()));", "+\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\tif (fDebug)", "+\t\t\t\t\tSystem.out.println(\"package \" + new String(proposal.getDeclarationSignature()));", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tcase CompletionProposal.VARIABLE_DECLARATION:", "+\t\t\t\tfElements.addElement(new String(proposal.getName()));", "+\t\t\t\tthis.acceptCommon(proposal);", "+\t\t\t\tif (fDebug)", "+\t\t\t\t\tSystem.out.println(\"variable name \" + new String(proposal.getName()));", "+\t\t\t\tbreak;", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b4dc44fe41d6c2dcbd280efd5bc4d02a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "416bf44f74a0795b6b6bec20a356ce5017d1b9d5", "commitAfterChange": "724250dda70a6e8357696d4ee32f28e4f44952f6", "methodNumberBeforeChange": 114, "methodNumberAfterChange": 114, "signatureBeforeChange": " public void generateBoxingConversion(int unboxedTypeID)", "signatureAfterChange": " public void generateBoxingConversion(int unboxedTypeID)", "diff": ["-\tswitch (unboxedTypeID) {", "-\t\tcase T_byte :", "-\t\t\t// invokestatic: Byte.valueOf(byte)", "-\t\t\tthis.invoke(", "-\t\t\t\tOPC_invokestatic,", "-\t\t\t\t1, // argCount", "-\t\t\t\t1, // return type size", "-\t\t\t\tConstantPool.JavaLangByteConstantPoolName,", "-\t\t\t\tConstantPool.ValueOf,", "-\t\t\t\tConstantPool.byteByteSignature);", "-\t\t\tbreak;", "-\t\tcase T_short :", "-\t\t\t// invokestatic: Short.valueOf(short)", "-\t\t\tthis.invoke(", "-\t\t\t\tOPC_invokestatic,", "-\t\t\t\t1, // argCount", "-\t\t\t\t1, // return type size", "-\t\t\t\tConstantPool.JavaLangShortConstantPoolName,", "-\t\t\t\tConstantPool.ValueOf,", "-\t\t\t\tConstantPool.shortShortSignature);", "-\t\t\tbreak;", "-\t\tcase T_char :", "-\t\t\t// invokestatic: Character.valueOf(char)", "-\t\t\tthis.invoke(", "-\t\t\t\tOPC_invokestatic,", "-\t\t\t\t1, // argCount", "-\t\t\t\t1, // return type size", "-\t\t\t\tConstantPool.JavaLangCharacterConstantPoolName,", "-\t\t\t\tConstantPool.ValueOf,", "-\t\t\t\tConstantPool.charCharacterSignature);", "-\t\t\tbreak;", "-\t\tcase T_int :", "-\t\t\t// invokestatic: Integer.valueOf(int)", "-\t\t\tthis.invoke(", "-\t\t\t\tOPC_invokestatic,", "-\t\t\t\t1, // argCount", "-\t\t\t\t1, // return type size", "-\t\t\t\tConstantPool.JavaLangIntegerConstantPoolName,", "-\t\t\t\tConstantPool.ValueOf,", "-\t\t\t\tConstantPool.IntIntegerSignature);", "-\t\t\tbreak;", "-\t\tcase T_long :", "-\t\t\t// invokestatic: Long.valueOf(long)", "-\t\t\tthis.invoke(", "-\t\t\t\tOPC_invokestatic,", "-\t\t\t\t2, // argCount", "-\t\t\t\t1, // return type size", "-\t\t\t\tConstantPool.JavaLangLongConstantPoolName,", "-\t\t\t\tConstantPool.ValueOf,", "-\t\t\t\tConstantPool.longLongSignature);", "-\t\t\tbreak;", "-\t\tcase T_float :", "-\t\t\t// invokestatic: Float.valueOf(float)", "-\t\t\tthis.invoke(", "-\t\t\t\tOPC_invokestatic,", "-\t\t\t\t1, // argCount", "-\t\t\t\t1, // return type size", "-\t\t\t\tConstantPool.JavaLangFloatConstantPoolName,", "-\t\t\t\tConstantPool.ValueOf,", "-\t\t\t\tConstantPool.floatFloatSignature);", "-\t\t\tbreak;", "-\t\tcase T_double :", "-\t\t\t// invokestatic: Double.valueOf(double)", "-\t\t\tthis.invoke(", "-\t\t\t\tOPC_invokestatic,", "-\t\t\t\t2, // argCount", "-\t\t\t\t1, // return type size", "-\t\t\t\tConstantPool.JavaLangDoubleConstantPoolName,", "-\t\t\t\tConstantPool.ValueOf,", "-\t\t\t\tConstantPool.doubleDoubleSignature);", "-\t\t\tbreak;", "-\t\tcase T_boolean :", "-\t\t\t// invokestatic: Boolean.valueOf(boolean)", "-\t\t\tthis.invoke(", "-\t\t\t\tOPC_invokestatic,", "-\t\t\t\t1, // argCount", "-\t\t\t\t1, // return type size", "-\t\t\t\tConstantPool.JavaLangBooleanConstantPoolName,", "-\t\t\t\tConstantPool.ValueOf,", "-\t\t\t\tConstantPool.booleanBooleanSignature);", "-\t}", "+    switch (unboxedTypeID) {", "+        case T_byte :", "+            if (this.targetLevel >= ClassFileConstants.JDK1_5) {", "+    \t\t\tif (DEBUG) System.out.println(position + \"\\t\\tinvokestatic java.lang.Byte.valueOf(byte)\"); //$NON-NLS-1$", "+               // invokestatic: Byte.valueOf(byte)", "+                this.invoke(", "+                    OPC_invokestatic,", "+                    1, // argCount", "+                    1, // return type size", "+                    ConstantPool.JavaLangByteConstantPoolName,", "+                    ConstantPool.ValueOf,", "+                    ConstantPool.byteByteSignature);", "+            } else {", "+               // new Byte( byte )", "+    \t\t\tif (DEBUG) System.out.println(position + \"\\t\\tinvokespecial java.lang.Byte(byte)\"); //$NON-NLS-1$", "+                newWrapperFor(unboxedTypeID);", "+                dup_x1();", "+                swap();", "+                this.invoke(", "+                    OPC_invokespecial,", "+                    1, // argCount", "+                    0, // return type size", "+                    ConstantPool.JavaLangByteConstantPoolName,", "+                    ConstantPool.Init,", "+                    ConstantPool.ByteConstrSignature);", "+            }       ", "+            break;", "+        case T_short :", "+            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {", "+                // invokestatic: Short.valueOf(short)", "+    \t\t\tif (DEBUG) System.out.println(position + \"\\t\\tinvokestatic java.lang.Short.valueOf(short)\"); //$NON-NLS-1$", "+                this.invoke(", "+                    OPC_invokestatic,", "+                    1, // argCount", "+                    1, // return type size", "+                    ConstantPool.JavaLangShortConstantPoolName,", "+                    ConstantPool.ValueOf,", "+                    ConstantPool.shortShortSignature);", "+            } else {", "+                // new Short(short)", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokespecial java.lang.Short(short)\"); //$NON-NLS-1$", "+            \tnewWrapperFor(unboxedTypeID);                ", "+                dup_x1();", "+                swap();             ", "+                this.invoke(", "+                    OPC_invokespecial,", "+                    1, // argCount", "+                    0, // return type size", "+                    ConstantPool.JavaLangShortConstantPoolName,", "+                    ConstantPool.Init,", "+                    ConstantPool.ShortConstrSignature);     ", "+            }", "+            break;", "+        case T_char :", "+            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {", "+                // invokestatic: Character.valueOf(char)", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokestatic java.lang.Character.valueOf(char)\"); //$NON-NLS-1$", "+                this.invoke(", "+                    OPC_invokestatic,", "+                    1, // argCount", "+                    1, // return type size", "+                    ConstantPool.JavaLangCharacterConstantPoolName,", "+                    ConstantPool.ValueOf,", "+                    ConstantPool.charCharacterSignature);", "+            } else {", "+                // new Char( char )", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokespecial java.lang.Character(char)\"); //$NON-NLS-1$", "+                newWrapperFor(unboxedTypeID);", "+                dup_x1();", "+                swap();", "+                this.invoke(", "+                    OPC_invokespecial,", "+                    1, // argCount", "+                    0, // return type size", "+                    ConstantPool.JavaLangCharacterConstantPoolName,", "+                    ConstantPool.Init,", "+                    ConstantPool.CharConstrSignature);", "+            }       ", "+            break;", "+        case T_int :             ", "+            if (this.targetLevel >= ClassFileConstants.JDK1_5) {", "+                // invokestatic: Integer.valueOf(int)", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokestatic java.lang.Integer.valueOf(int)\"); //$NON-NLS-1$", "+                this.invoke(", "+                    OPC_invokestatic,", "+                    1, // argCount", "+                    1, // return type size", "+                    ConstantPool.JavaLangIntegerConstantPoolName,", "+                    ConstantPool.ValueOf,", "+                    ConstantPool.IntIntegerSignature);", "+            } else {", "+                // new Integer(int)", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokespecial java.lang.Integer(int)\"); //$NON-NLS-1$", "+                newWrapperFor(unboxedTypeID);", "+                dup_x1();", "+                swap();             ", "+                this.invoke(", "+                    OPC_invokespecial,", "+                    1, // argCount", "+                    0, // return type size", "+                    ConstantPool.JavaLangIntegerConstantPoolName,", "+                    ConstantPool.Init,", "+                    ConstantPool.IntConstrSignature);", "+            }", "+            break;", "+        case T_long :", "+            if (this.targetLevel >= ClassFileConstants.JDK1_5) { ", "+                // invokestatic: Long.valueOf(long)", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokestatic java.lang.Long.valueOf(long)\"); //$NON-NLS-1$", "+                this.invoke(", "+                    OPC_invokestatic,", "+                    2, // argCount", "+                    1, // return type size", "+                    ConstantPool.JavaLangLongConstantPoolName,", "+                    ConstantPool.ValueOf,", "+                    ConstantPool.longLongSignature);", "+            } else {", "+                // new Long( long )", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokespecial java.lang.Long(long)\"); //$NON-NLS-1$", "+                newWrapperFor(unboxedTypeID);", "+                dup_x2();", "+                dup_x2();", "+                pop();", "+                this.invoke(", "+                    OPC_invokespecial,", "+                    2, // argCount", "+                    0, // return type size", "+                    ConstantPool.JavaLangLongConstantPoolName,", "+                    ConstantPool.Init,", "+                    ConstantPool.LongConstrSignature);", "+            }                   ", "+            break;", "+        case T_float :", "+            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {", "+                // invokestatic: Float.valueOf(float)", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokestatic java.lang.Float.valueOf(float)\"); //$NON-NLS-1$", "+                this.invoke(", "+                    OPC_invokestatic,", "+                    1, // argCount", "+                    1, // return type size", "+                    ConstantPool.JavaLangFloatConstantPoolName,", "+                    ConstantPool.ValueOf,", "+                    ConstantPool.floatFloatSignature);", "+            } else {", "+                // new Float(float)", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokespecial java.lang.Float(float)\"); //$NON-NLS-1$", "+                newWrapperFor(unboxedTypeID);", "+                dup_x1();", "+                swap();             ", "+                this.invoke(", "+                    OPC_invokespecial,", "+                    1, // argCount", "+                    0, // return type size", "+                    ConstantPool.JavaLangFloatConstantPoolName,", "+                    ConstantPool.Init,", "+                    ConstantPool.FloatConstrSignature);", "+            }       ", "+            break;", "+        case T_double :", "+            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) { ", "+                // invokestatic: Double.valueOf(double)", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokestatic java.lang.Double.valueOf(double)\"); //$NON-NLS-1$", "+                this.invoke(", "+                    OPC_invokestatic,", "+                    2, // argCount", "+                    1, // return type size", "+                    ConstantPool.JavaLangDoubleConstantPoolName,", "+                    ConstantPool.ValueOf,", "+                    ConstantPool.doubleDoubleSignature);", "+            } else {", "+                // new Double( double )", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokespecial java.lang.Double(double)\"); //$NON-NLS-1$", "+            \tnewWrapperFor(unboxedTypeID);                ", "+                dup_x2();", "+                dup_x2();", "+                pop();", "+                ", "+                this.invoke(", "+                    OPC_invokespecial,", "+                    2, // argCount", "+                    0, // return type size", "+                    ConstantPool.JavaLangDoubleConstantPoolName,", "+                    ConstantPool.Init,", "+                    ConstantPool.DoubleConstrSignature);", "+            }       ", "+            ", "+            break;  ", "+        case T_boolean :", "+            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {", "+                // invokestatic: Boolean.valueOf(boolean)", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokestatic java.lang.Boolean.valueOf(boolean)\"); //$NON-NLS-1$", "+                this.invoke(", "+                    OPC_invokestatic,", "+                    1, // argCount", "+                    1, // return type size", "+                    ConstantPool.JavaLangBooleanConstantPoolName,", "+                    ConstantPool.ValueOf,", "+                    ConstantPool.booleanBooleanSignature);", "+            } else {", "+                // new Boolean(boolean)", "+            \tif (DEBUG) System.out.println(position + \"\\t\\tinvokespecial java.lang.Boolean(boolean)\"); //$NON-NLS-1$", "+                newWrapperFor(unboxedTypeID);", "+                dup_x1();", "+                swap();             ", "+                this.invoke(", "+                    OPC_invokespecial,", "+                    1, // argCount", "+                    0, // return type size", "+                    ConstantPool.JavaLangBooleanConstantPoolName,", "+                    ConstantPool.Init,", "+                    ConstantPool.BooleanConstrSignature);", "+            }", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c7f2517c199beb00295976f67b956aee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "900c13d17fd147c187a2b319111ff0c850c4ae89", "commitAfterChange": "f02cc00df615ce0df96d2675e50465c713b4b942", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tprivate String getPreserveEmptyLines(int count)", "signatureAfterChange": " \tprivate String getPreserveEmptyLines(int count)", "diff": ["-\t\t\t\t// insert a new line only if it has not been already done before", "-\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=283476", "-\t\t\t\tif (this.lastNumberOfNewLines == 0) {", "+\t\t\t\t// Insert a new line only if it has not been already done before", "+\t\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=283476)", "+\t\t\t\t// or when there's no direct member alignment", "+\t\t\t\t// (additional fix for bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=286601)", "+\t\t\t\tif (this.lastNumberOfNewLines == 0 || this.memberAlignment == null || this.memberAlignment.location.inputOffset < this.currentAlignment.location.inputOffset) {", "+\t\t\t\t\t", "+\t\t\t\t\t// Debug", "+\t\t\t\t\tif (DefaultCodeFormatter.DEBUG) {", "+\t\t\t\t\t\tSystem.out.println(\"Preserve empty lines:\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - indentation level = \"+this.indentationLevel); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - current alignment: \"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(this.currentAlignment.toString(new StringBuffer(), 1));", "+\t\t\t\t\t\tif (this.memberAlignment != null) {", "+\t\t\t\t\t\t\tSystem.out.println(\" - member alignment: \"); //$NON-NLS-1$", "+\t\t\t\t\t\t\tSystem.out.print(this.memberAlignment.toString(new StringBuffer(), 1));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+", "-\t\t\t\t\tthis.numberOfIndentations = this.currentAlignment.location.numberOfIndentations;", "-\t\t\t\t\tthis.formatter.lastLocalDeclarationSourceStart = this.currentAlignment.location.lastLocalDeclarationSourceStart;", "-\t\t\t\t\t// Create new line keeping the existing indentation", "+", "+\t\t\t\t\t// Create new line", "+\t\t\t\t\t", "+\t\t\t\t\t// Look for current indentation", "-\t\t\t\t\tAlignment rootAlignment = this.currentAlignment;", "-\t\t\t\t\twhile (rootAlignment.enclosing != null) {", "-\t\t\t\t\t\trootAlignment = rootAlignment.enclosing;", "+\t\t\t\t\t", "+\t\t\t\t\t// Determine whether the alignment indentation can be used or not", "+\t\t\t\t\t// So far, the best algorithm is to use it when", "+\t\t\t\t\t// 1. this is not the opening brace of a local declaration assignment", "+\t\t\t\t\t// 2. this is not the first opening brace", "+\t\t\t\t\t//     or this is an array initializer alignment ", "+\t\t\t\t\t//     or this is an binary expression alignment", "+\t\t\t\t\t// 3. the indentation level is below the alignment break indentation", "+\t\t\t\t\tint currentTokenStartPosition = this.scanner.currentPosition;", "+\t\t\t\t\tint nextToken = -1;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tnextToken = this.scanner.getNextToken();", "+\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\t// skip", "-\t\t\t\t\tLocation location = rootAlignment.location;", "-\t\t\t\t\tif (currentColumn > location.inputColumn) {", "-\t\t\t\t\t\tint savedIndentation = this.indentationLevel;", "-\t\t\t\t\t\tthis.indentationLevel += currentColumn - location.inputColumn;", "-\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "-\t\t\t\t\t\tthis.indentationLevel = savedIndentation;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "+\t\t\t\t\tthis.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);", "+\t\t\t\t\tboolean canUseAlignmentIndentation = (nextToken != TerminalTokens.TokenNameLBRACE || !this.currentAlignment.name.equals(\"localDeclarationAssignmentAlignment\")); //$NON-NLS-1$", "+\t\t\t\t\tif (canUseAlignmentIndentation &&", "+\t\t\t\t\t\t\t(!this.formatBrace ||", "+\t\t\t\t\t\t\t\t\tthis.currentAlignment.name.equals(\"array_initializer\") || //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tthis.currentAlignment.name.equals(\"binaryExpressionAlignment\")) && //$NON-NLS-1$", "+\t\t\t\t\t\t\tthis.indentationLevel < this.currentAlignment.breakIndentationLevel) {", "+\t\t\t\t\t\tthis.indentationLevel = this.currentAlignment.breakIndentationLevel;", "+\t\t\t\t\t", "+\t\t\t\t\t// Use the current indentation if over the computed indentation", "+\t\t\t\t\tif (this.indentationLevel < currentColumn) {", "+\t\t\t\t\t\tthis.indentationLevel = currentColumn;", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// Debug", "+\t\t\t\t\tif (DefaultCodeFormatter.DEBUG) {", "+\t\t\t\t\t\tSystem.out.println(\" - format brace = \"+this.formatBrace); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - current column = \"+currentColumn); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - current position = \"+this.scanner.currentPosition); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(\" - current line = \"); //$NON-NLS-1$", "+\t\t\t\t\t\tint linePtr = Arrays.binarySearch(this.lineEnds, this.scanner.currentPosition);", "+\t\t\t\t\t\tif (linePtr < 0) {", "+\t\t\t\t\t\t\tlinePtr = -linePtr - 1;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tint i = getLineEnd(linePtr)+1;", "+\t\t\t\t\t\twhile (this.scanner.source[i] != '\\r') {", "+\t\t\t\t\t\t\tSystem.out.print(this.scanner.source[i++]);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tSystem.out.println();", "+\t\t\t\t\t\tSystem.out.println(\" - indentation level = \"+this.indentationLevel); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println();", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// Set the flag to indicate that a specific indentation is currently in used", "+\t\t\t\t\tthis.preserveLineBreakIndentation = true;", "+\t\t\t\t\t", "+\t\t\t\t\t// Print the computed indentation in the buffer", "+\t\t\t\t\tprintIndentationIfNecessary(buffer);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dfbce253a3ba7e80071547ebba05d36b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tprivate int parseCheck(int stck[], int stack_top, int first_token, int buffer_position)", "signatureAfterChange": " \tprivate int parseCheck(int stck[], int stack_top, int first_token, int buffer_position)", "diff": ["+\t\t\tif(DEBUG_PARSECHECK) {", "+\t\t\t\tSystem.out.println(tempStackTop);", "+\t\t\t}", "+\t\t\t\t// same loop as 'process_non_terminal'", "+\t\t\t\t\t", "+\t\t\t\t\tif(DEBUG_PARSECHECK) {", "+\t\t\t\t\t\tSystem.out.print(tempStackTop);", "+\t\t\t\t\t\tSystem.out.print(\" (\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(-(Parser.rhs[act]-1));", "+\t\t\t\t\t\tSystem.out.print(\") [max:\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(max_pos);", "+\t\t\t\t\t\tSystem.out.print(\"]\\tprocess_non_terminal\\t\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(act);", "+\t\t\t\t\t\tSystem.out.print(\"\\t\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(Parser.name[Parser.non_terminal_index[Parser.lhs[act]]]);", "+\t\t\t\t\t\tSystem.out.println();", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\tif(Parser.rules_compliance[act] > this.options.sourceLevel) {", "+\t\t\t\t\t \treturn 0;", "+\t\t\t\t\t}", "+\t\t\t", "+\t\t\tif(DEBUG_PARSECHECK) {", "+\t\t\t\tSystem.out.println(tempStackTop);", "+\t\t\t}", "+\t\t\t", "+\t\t\tif(DEBUG_PARSECHECK) {", "+\t\t\t\tSystem.out.print(tempStackTop + 1);", "+\t\t\t\tSystem.out.print(\" (+1) [max:\"); //$NON-NLS-1$", "+\t\t\t\tSystem.out.print(max_pos);", "+\t\t\t\tSystem.out.print(\"]\\tprocess_terminal    \\t\"); //$NON-NLS-1$", "+\t\t\t\tSystem.out.print(ct);", "+\t\t\t\tSystem.out.print(\"\\t\"); //$NON-NLS-1$", "+\t\t\t\tSystem.out.print(Parser.name[Parser.terminal_index[ct]]);", "+\t\t\t\tSystem.out.println();", "+\t\t\t}", "+\t\t\t", "+\t\t\t\t", "+\t\t\t\tif(DEBUG_PARSECHECK) {", "+\t\t\t\t\tSystem.out.print(tempStackTop);", "+\t\t\t\t\tSystem.out.print(\" (-1) [max:\"); //$NON-NLS-1$", "+\t\t\t\t\tSystem.out.print(max_pos);", "+\t\t\t\t\tSystem.out.print(\"]\\treduce\"); //$NON-NLS-1$", "+\t\t\t\t\tSystem.out.println();", "+\t\t\t\t}", "-\t\t\t\t\t act -= ERROR_ACTION;", "+\t\t\t\t\tact -= ERROR_ACTION;", "+\t\t\t\t\t", "+\t\t\t\t\tif(DEBUG_PARSECHECK) {", "+\t\t\t\t\t\tSystem.out.print(tempStackTop);", "+\t\t\t\t\t\tSystem.out.print(\"\\tshift reduce\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println();", "+\t\t\t\t\t}", "+\t\t\t\t\tif(DEBUG_PARSECHECK) {", "+\t\t\t\t\t\tSystem.out.println(\"\\tshift\"); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t// same loop as first token initialization", "+\t\t\t\t", "+\t\t\t\tif(DEBUG_PARSECHECK) {", "+\t\t\t\t\tSystem.out.print(tempStackTop);", "+\t\t\t\t\tSystem.out.print(\" (\"); //$NON-NLS-1$", "+\t\t\t\t\tSystem.out.print(-(Parser.rhs[act]-1));", "+\t\t\t\t\tSystem.out.print(\") [max:\"); //$NON-NLS-1$", "+\t\t\t\t\tSystem.out.print(max_pos);", "+\t\t\t\t\tSystem.out.print(\"]\\tprocess_non_terminal\\t\"); //$NON-NLS-1$", "+\t\t\t\t\tSystem.out.print(act);", "+\t\t\t\t\tSystem.out.print(\"\\t\"); //$NON-NLS-1$", "+\t\t\t\t\tSystem.out.print(Parser.name[Parser.non_terminal_index[Parser.lhs[act]]]);", "+\t\t\t\t\tSystem.out.println();", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tif(act <= NUM_RULES) {", "+\t\t\t\t\tif(Parser.rules_compliance[act] > this.options.sourceLevel) {", "+\t\t\t\t\t \treturn 0;", "+\t\t\t\t\t}", "+\t\t\t\t}"]}], "num": 44697}