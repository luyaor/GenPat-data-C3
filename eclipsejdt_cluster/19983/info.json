{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7a5cab7ee9db63017cac59f2e80e6f10", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1d45b69fa7d4a2d9491e7f0cc336c4a0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "600cc6e957b3608b8d3c26027936fe87489e52d9", "commitAfterChange": "23ffb43b2ebb4c3a8ec95cae07baf3650cc30157", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tpublic static final Constant getConstantFor( \t\tFieldBinding binding, \t\tboolean implicitReceiver, \t\tReference reference, \t\tScope referenceScope, \t\tint indexInQualification)", "signatureAfterChange": "  \tpublic static final Constant getConstantFor( \t\tFieldBinding binding, \t\tReference reference, \t\tboolean isImplicit, \t\tScope referenceScope)", "diff": ["-\t\tboolean implicitReceiver,", "-\t\tScope referenceScope,", "-\t\tint indexInQualification) {", "+\t\tboolean isImplicit,", "+\t\tScope referenceScope) {", "-\t\t\tif (indexInQualification == 0) {", "-\t\t\t\treturn binding.constant;", "-\t\t\t}", "-\t\t\t//see previous comment for the (sould-always-be) valid cast", "-\t\t\tQualifiedNameReference qualifiedReference = (QualifiedNameReference) reference;", "-\t\t\tif (indexInQualification == (qualifiedReference.indexOfFirstFieldBinding - 1)) {", "+\t\t\tif (isImplicit || (reference instanceof QualifiedNameReference", "+\t\t\t\t\t&& binding == ((QualifiedNameReference)reference).binding)) {", "-\t\t//what scope to use (depend on the staticness of the field binding)", "-\t\tMethodScope fieldScope =", "-\t\t\tbinding.isStatic()", "+\t\tfieldDecl.resolve(binding.isStatic() //side effect on binding ", "-\t\t\t\t: typeDecl.initializerScope;", "+\t\t\t\t: typeDecl.initializerScope); ", "-\t\tif (implicitReceiver) { //Determine if the ref is legal in the current class of the field", "-\t\t\t//i.e. not a forward reference .... ", "-\t\t\tif (fieldScope.fieldDeclarationIndex == MethodScope.NotInFieldDecl) {", "-\t\t\t\t// no field is currently being analysed in typeDecl", "-\t\t\t\tfieldDecl.resolve(fieldScope); //side effect on binding ", "-\t\t\t\treturn binding.constant;", "-\t\t\t}", "-\t\t\t//We are re-entering the same class fields analysing", "-\t\t\tif ((reference != null)", "-\t\t\t\t&& (binding.declaringClass == referenceScope.enclosingSourceType()) // only complain for access inside same type", "-\t\t\t\t&& (binding.id > fieldScope.fieldDeclarationIndex)) {", "-\t\t\t\t//forward reference. The declaration remains unresolved.", "-\t\t\t\treferenceScope.problemReporter().forwardReference(reference, indexInQualification, typeBinding);", "-\t\t\t\treturn NotAConstant;", "-\t\t\t}", "-\t\t\tfieldDecl.resolve(fieldScope); //side effect on binding ", "+\t\tif (isImplicit || (reference instanceof QualifiedNameReference", "+\t\t\t\t&& binding == ((QualifiedNameReference)reference).binding)) {", "-\t\t//the field reference is explicity. It has to be a \"simple\" like field reference to get the", "-\t\t//constant propagation. For example in Packahe.Type.field1.field2 , field1 may have its", "-\t\t//constant having a propagation where field2 is always not propagating its", "-\t\tif (indexInQualification == 0) {", "-\t\t\tfieldDecl.resolve(fieldScope); //side effect on binding ... ", "-\t\t\treturn binding.constant;", "-\t\t}", "-\t\t// Side-effect on the field binding may not be propagated out for the qualified reference", "-\t\t// unless it occurs in first place of the name sequence", "-\t\tfieldDecl.resolve(fieldScope); //side effect on binding ... ", "-\t\t//see previous comment for the cast that should always be valid", "-\t\tQualifiedNameReference qualifiedReference = (QualifiedNameReference) reference;", "-\t\tif (indexInQualification == (qualifiedReference.indexOfFirstFieldBinding - 1)) {", "-\t\t\treturn binding.constant;", "-\t\t} else {", "-\t\t\treturn NotAConstant;", "-\t\t}", "+\t\treturn NotAConstant;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2ba485fb92d0f8fcc112208dfdd8b819", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "\r \tpublic void reportReference(\r \t\tAstNode reference,\r \t\tTypeDeclaration typeDeclaration,\r \t\tFieldDeclaration fieldDeclaration,\r \t\tchar[][] definingTypeNames,\r \t\tint accuracy)\r \t\tthrows CoreException", "signatureAfterChange": "\r public void reportReference(\r \tAstNode reference,\r \tTypeDeclaration typeDeclaration,\r \tFieldDeclaration fieldDeclaration, \r \tchar[][] definingTypeNames, \r \tint accuracy) throws CoreException", "diff": ["+ */\r", "+public void reportReference(\r", "+\tAstNode reference,\r", "+\tTypeDeclaration typeDeclaration,\r", "+\tFieldDeclaration fieldDeclaration, \r", "+\tchar[][] definingTypeNames, \r", "+\tint accuracy) throws CoreException {\r", "+\tif (fieldDeclaration.isField()) {\r", "+\t\t// create defining field handle\r", "+\t\tIField field = this.createFieldHandle(fieldDeclaration, definingTypeNames);\r", "+\t\r", "+\t\tif (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {\r", "+\t\t\tthis.pattern.matchReportReference((AstNode)reference, field, accuracy, this);\r", "+\t\t} else if (reference instanceof MessageSend) { // message ref are starting at the selector start\r", "+\t\t\tthis.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, field, accuracy);\r", "+\t\t\tthis.report(reference.sourceStart, reference.sourceEnd, field, accuracy);\r", "+\t\t}\r", "+\t} else { // initializer\r", "+\t\t// create defining initializer\r", "+\t\tIInitializer initializer = this.createInitializerHandle(typeDeclaration, fieldDeclaration, definingTypeNames);\r", "+\t\t\r", "+\t\t// accept reference\r", "+\t\tif (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {\r", "+\t\t\tthis.pattern.matchReportReference((AstNode)reference, initializer, accuracy, this);\r", "+\t\t} else if (reference instanceof MessageSend) { // message ref are starting at the selector start\r", "+\t\t\tthis.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, initializer, accuracy);\r", "+\t\t} else {\r", "+\t\t\tthis.report(reference.sourceStart, reference.sourceEnd, initializer, accuracy);\r", "+}\r", "-\t */\r", "-\tpublic void reportReference(\r", "-\t\tAstNode reference,\r", "-\t\tTypeDeclaration typeDeclaration,\r", "-\t\tFieldDeclaration fieldDeclaration,\r", "-\t\tchar[][] definingTypeNames,\r", "-\t\tint accuracy)\r", "-\t\tthrows CoreException {\r", "-\t\tif (fieldDeclaration.isField()) {\r", "-\t\t\t// create defining field handle\r", "-\t\t\tIField field = this.createFieldHandle(fieldDeclaration, definingTypeNames);\r", "-\r", "-\t\t\t// accept reference\r", "-\t\t\tif (reference instanceof QualifiedNameReference\r", "-\t\t\t\t|| reference instanceof QualifiedTypeReference) {\r", "-\t\t\t\tthis.pattern.matchReportReference((AstNode) reference, field, accuracy, this);\r", "-\t\t\t} else {\r", "-\t\t\t\tthis.report(reference.sourceStart, reference.sourceEnd, field, accuracy);\r", "-\t\t\t}\r", "-\t\t} else { // initializer\r", "-\t\t\t// create defining initializer\r", "-\t\t\tIInitializer initializer =\r", "-\t\t\t\tthis.createInitializerHandle(\r", "-\t\t\t\t\ttypeDeclaration,\r", "-\t\t\t\t\tfieldDeclaration,\r", "-\t\t\t\t\tdefiningTypeNames);\r", "-\r", "-\t\t\t// accept reference\r", "-\t\t\tif (reference instanceof QualifiedNameReference\r", "-\t\t\t\t|| reference instanceof QualifiedTypeReference) {\r", "-\t\t\t\tthis.pattern.matchReportReference(\r", "-\t\t\t\t\t(AstNode) reference,\r", "-\t\t\t\t\tinitializer,\r", "-\t\t\t\t\taccuracy,\r", "-\t\t\t\t\tthis);\r", "-\t\t\t} else {\r", "-\t\t\t\tthis.report(reference.sourceStart, reference.sourceEnd, initializer, accuracy);\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r"]}], "num": 19983}