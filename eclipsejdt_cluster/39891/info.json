{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0d7b60aef261b2cf5045897a8b43ebb8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "361766e5c2a4019a07989555ac7dfcd9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingExpressionsTest.java", "commitBeforeChange": "0878e1dc107fb190292b2de3d6e4f25e19c0489c", "commitAfterChange": "80b12656ac31b339fd22081301db662b77277ac4", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 16, "signatureBeforeChange": "  \tpublic static Test setUpTest(Test someTest)", "signatureAfterChange": "  \tpublic void testInfixExpression2() throws Exception", "diff": ["-", "-\tpublic static Test setUpTest(Test someTest) {", "-\t\tTestSuite suite= new Suite(\"one test\");", "-\t\tsuite.addTest(someTest);", "-\t\treturn suite;", "+\tpublic void testInfixExpression2() throws Exception {", "+\t\tIPackageFragment pack1= this.sourceFolder.createPackageFragment(\"test1\", false, null);", "+\t\tStringBuffer buf= new StringBuffer();", "+\t\tbuf.append(\"package test1;\\n\");", "+\t\tbuf.append(\"public class E {\\n\");", "+\t\tbuf.append(\"    public void foo() {\\n\");", "+\t\tbuf.append(\"        i= 0 + 2;\\n\");", "+\t\tbuf.append(\"        j= 1 + 0;\\n\");", "+\t\tbuf.append(\"        k= 0 + 2 + 3 + 4 + 5;\\n\");", "+\t\tbuf.append(\"        l= 1 + 0 + 3 + 4 + 5;\\n\");", "+\t\tbuf.append(\"        m= 0 + 0 + 0 + 4 + 5;\\n\");", "+\t\tbuf.append(\"    }\\n\");", "+\t\tbuf.append(\"}\\n\");", "+\t\tICompilationUnit cu= pack1.createCompilationUnit(\"E.java\", buf.toString(), false, null);", "+\t", "+\t\tCompilationUnit astRoot= createAST(cu);", "+\t\tASTRewrite rewrite= ASTRewrite.create(astRoot.getAST());", "+\t", "+\t\tassertTrue(\"Parse errors\", (astRoot.getFlags() & ASTNode.MALFORMED) == 0);", "+\t\tTypeDeclaration type= findTypeDeclaration(astRoot, \"E\");", "+\t\tMethodDeclaration methodDecl= findMethodDeclaration(type, \"foo\");", "+\t\tBlock block= methodDecl.getBody();", "+\t\tList statements= block.statements();", "+\t\t{ // remove left side", "+\t\t\tExpressionStatement stmt= (ExpressionStatement) statements.get(0);", "+\t\t\tAssignment assignment= (Assignment) stmt.getExpression();", "+\t\t\tInfixExpression expr= (InfixExpression) assignment.getRightHandSide();", "+\t", "+\t\t\trewrite.remove(expr.getLeftOperand(), null);", "+\t\t}", "+\t", "+\t\t{ // remove right side", "+\t\t\tExpressionStatement stmt= (ExpressionStatement) statements.get(1);", "+\t\t\tAssignment assignment= (Assignment) stmt.getExpression();", "+\t\t\tInfixExpression expr= (InfixExpression) assignment.getRightHandSide();", "+\t", "+\t\t\trewrite.remove(expr.getRightOperand(), null);", "+\t\t}", "+\t", "+\t\t{ // remove left side (with extended operands)", "+\t\t\tExpressionStatement stmt= (ExpressionStatement) statements.get(2);", "+\t\t\tAssignment assignment= (Assignment) stmt.getExpression();", "+\t\t\tInfixExpression expr= (InfixExpression) assignment.getRightHandSide();", "+\t", "+\t\t\trewrite.remove(expr.getLeftOperand(), null);", "+\t\t}", "+\t", "+\t\t{ // remove right side (with extended operands)", "+\t\t\tExpressionStatement stmt= (ExpressionStatement) statements.get(3);", "+\t\t\tAssignment assignment= (Assignment) stmt.getExpression();", "+\t\t\tInfixExpression expr= (InfixExpression) assignment.getRightHandSide();", "+\t\t\t", "+\t\t\trewrite.remove(expr.getRightOperand(), null);", "+\t\t}", "+\t\t", "+\t\t{ // remove left, right, and extended operand", "+\t\t\tExpressionStatement stmt= (ExpressionStatement) statements.get(4);", "+\t\t\tAssignment assignment= (Assignment) stmt.getExpression();", "+\t\t\tInfixExpression expr= (InfixExpression) assignment.getRightHandSide();", "+\t\t\t", "+\t\t\trewrite.remove(expr.getLeftOperand(), null);", "+\t\t\trewrite.remove(expr.getRightOperand(), null);", "+\t\t\trewrite.remove((ASTNode) expr.extendedOperands().get(0), null);", "+\t\t}", "+\t\t", "+\t\tString preview= evaluateRewrite(cu, rewrite);", "+\t", "+\t\tbuf= new StringBuffer();", "+\t\tbuf.append(\"package test1;\\n\");", "+\t\tbuf.append(\"public class E {\\n\");", "+\t\tbuf.append(\"    public void foo() {\\n\");", "+\t\tbuf.append(\"        i= 2;\\n\");", "+\t\tbuf.append(\"        j= 1;\\n\");", "+\t\tbuf.append(\"        k= 2 + 3 + 4 + 5;\\n\");", "+\t\tbuf.append(\"        l= 1 + 3 + 4 + 5;\\n\");", "+\t\tbuf.append(\"        m= 4 + 5;\\n\");", "+\t\tbuf.append(\"    }\\n\");", "+\t\tbuf.append(\"}\\n\");", "+\t\tassertEqualString(preview, buf.toString());", "+\t", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e43acf1aef4eef1af469721b3fd2c49", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java", "commitBeforeChange": "581702d71a138ac97fe73cfd2b06cc855f39a496", "commitAfterChange": "d47f7e16ee9a06ebea0c1bfa73440fda6af0235f", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprotected boolean computeChildren(OpenableElementInfo info) throws JavaModelException", "signatureAfterChange": " \tprotected boolean computeChildren(OpenableElementInfo info, Map newElements) throws JavaModelException", "diff": ["-\tprotected boolean computeChildren(OpenableElementInfo info) throws JavaModelException {", "+\tprotected boolean computeChildren(OpenableElementInfo info, Map newElements) throws JavaModelException {", "+\t\t", "-\t\tcomputeJarChildren((JarPackageFragmentRootInfo) info, vChildren);", "+\t\tfinal int JAVA = 0;", "+\t\tfinal int NON_JAVA = 1;", "+\t\tZipFile jar= null;", "+\t\ttry {", "+\t\t\tjar= getJar();", "+\t", "+\t\t\tHashMap packageFragToTypes= new HashMap();", "+\t", "+\t\t\t// always create the default package", "+\t\t\tpackageFragToTypes.put(IPackageFragment.DEFAULT_PACKAGE_NAME, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });", "+\t", "+\t\t\tfor (Enumeration e= jar.entries(); e.hasMoreElements();) {", "+\t\t\t\tZipEntry member= (ZipEntry) e.nextElement();", "+\t\t\t\tString entryName= member.getName();", "+\t", "+\t\t\t\tif (member.isDirectory()) {", "+\t\t\t\t\t", "+\t\t\t\t\tint last = entryName.length() - 1;", "+\t\t\t\t\tentryName= entryName.substring(0, last);", "+\t\t\t\t\tentryName= entryName.replace('/', '.');", "+\t", "+\t\t\t\t\t// add the package name & all of its parent packages", "+\t\t\t\t\twhile (true) {", "+\t\t\t\t\t\t// extract the package name", "+\t\t\t\t\t\tif (packageFragToTypes.containsKey(entryName)) break;", "+\t\t\t\t\t\tpackageFragToTypes.put(entryName, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif ((last = entryName.lastIndexOf('.')) < 0) break;", "+\t\t\t\t\t\tentryName = entryName.substring(0, last);", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t//store the class file / non-java rsc entry name to be cached in the appropriate package fragment", "+\t\t\t\t\t//zip entries only use '/'", "+\t\t\t\t\tint lastSeparator= entryName.lastIndexOf('/');", "+\t\t\t\t\tString packageName;", "+\t\t\t\t\tString fileName;", "+\t\t\t\t\tif (lastSeparator != -1) { //not in the default package", "+\t\t\t\t\t\tentryName= entryName.replace('/', '.');", "+\t\t\t\t\t\tfileName= entryName.substring(lastSeparator + 1);", "+\t\t\t\t\t\tpackageName= entryName.substring(0, lastSeparator);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfileName = entryName;", "+\t\t\t\t\t\tpackageName =  IPackageFragment.DEFAULT_PACKAGE_NAME;", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// add the package name & all of its parent packages", "+\t\t\t\t\tString currentPackageName = packageName;", "+\t\t\t\t\twhile (true) {", "+\t\t\t\t\t\t// extract the package name", "+\t\t\t\t\t\tif (packageFragToTypes.containsKey(currentPackageName)) break;", "+\t\t\t\t\t\tpackageFragToTypes.put(currentPackageName, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tint last;", "+\t\t\t\t\t\tif ((last = currentPackageName.lastIndexOf('.')) < 0) break;", "+\t\t\t\t\t\tcurrentPackageName = currentPackageName.substring(0, last);", "+\t\t\t\t\t}", "+\t\t\t\t\t// add classfile info amongst children", "+\t\t\t\t\tArrayList[] children = (ArrayList[]) packageFragToTypes.get(packageName);", "+\t\t\t\t\tif (Util.isClassFileName(entryName)) {", "+\t\t\t\t\t\tif (children[JAVA] == EMPTY_LIST) children[JAVA] = new ArrayList();", "+\t\t\t\t\t\tchildren[JAVA].add(fileName);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (children[NON_JAVA] == EMPTY_LIST) children[NON_JAVA] = new ArrayList();", "+\t\t\t\t\t\tchildren[NON_JAVA].add(fileName);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t//loop through all of referenced packages, creating package fragments if necessary", "+\t\t\t// and cache the entry names in the infos created for those package fragments", "+\t\t\tIterator packages = packageFragToTypes.keySet().iterator();", "+\t\t\twhile (packages.hasNext()) {", "+\t\t\t\tString packName = (String) packages.next();", "+\t\t\t\t", "+\t\t\t\tArrayList[] entries= (ArrayList[]) packageFragToTypes.get(packName);", "+\t\t\t\tJarPackageFragment packFrag= (JarPackageFragment) getPackageFragment(packName);", "+\t\t\t\tJarPackageFragmentInfo fragInfo= (JarPackageFragmentInfo) packFrag.createElementInfo();", "+\t\t\t\tif (entries[0].size() > 0){", "+\t\t\t\t\tfragInfo.setEntryNames(entries[JAVA]);", "+\t\t\t\t}", "+\t\t\t\tint resLength= entries[NON_JAVA].size();", "+\t\t\t\tif (resLength == 0) {", "+\t\t\t\t\tpackFrag.computeNonJavaResources(NO_STRINGS, fragInfo, jar.getName());", "+\t\t\t\t} else {", "+\t\t\t\t\tString[] resNames= new String[resLength];", "+\t\t\t\t\tentries[NON_JAVA].toArray(resNames);", "+\t\t\t\t\tpackFrag.computeNonJavaResources(resNames, fragInfo, jar.getName());", "+\t\t\t\t}", "+\t\t\t\tpackFrag.computeChildren(fragInfo);", "+\t\t\t\tnewElements.put(packFrag, fragInfo);", "+\t\t\t\tvChildren.add(packFrag);", "+\t\t\t}", "+\t\t} catch (CoreException e) {", "+\t\t\tif (e instanceof JavaModelException) throw (JavaModelException)e;", "+\t\t\tthrow new JavaModelException(e);", "+\t\t} finally {", "+\t\t\tJavaModelManager.getJavaModelManager().closeZipFile(jar);", "+\t\t}", "+", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8eea02a8824be2f77bbbbba057072382", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "a0827b5ed51f9fc68d50a6070897f74217550da1", "commitAfterChange": "266357791826a02f1dd87ad4cdccffd484f96fd9", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "  \tprivate ConstraintFormula pickFromCycle(Set<ConstraintFormula> c)", "signatureAfterChange": "  \tprivate ConstraintFormula pickFromCycle(Set<ConstraintFormula> c)", "diff": ["-\t\tmissingImplementation(\"Breaking a dependency cycle NYI\"); //$NON-NLS-1$", "-\t\treturn null; // never", "+\t\t// Detail from 18.5.2 bullet 6.1", "+", "+\t\t// Note on performance: this implementation could quite possibly be optimized a lot.", "+\t\t// However, we only *very rarely* reach here,", "+\t\t// so nobody should really be affected by the performance penalty paid here.", "+", "+\t\t// Note on spec conformance: the spec seems to require _all_ criteria (i)-(iv) to be fulfilled", "+\t\t// with the sole exception of (iii), which should only be used, if _any_ constraints matching (i) & (ii)", "+\t\t// also fulfill this condition.", "+\t\t// Experiments, however, show that strict application of the above is prone to failing to pick any constraint,", "+\t\t// causing non-termination of the algorithm.", "+\t\t// Since that is not acceptable, I'm *interpreting* the spec to request a search for a constraint", "+\t\t// that \"best matches\" the given conditions.", "+\t\t", "+\t\t// collect all constraints participating in a cycle", "+\t\tHashMap<ConstraintFormula,Set<ConstraintFormula>> dependencies = new HashMap<ConstraintFormula, Set<ConstraintFormula>>();", "+\t\tSet<ConstraintFormula> cycles = new HashSet<ConstraintFormula>();", "+\t\tfor (ConstraintFormula constraint : c) {", "+\t\t\tCollection<InferenceVariable> infVars = constraint.inputVariables(this);", "+\t\t\tfor (ConstraintFormula other : c) {", "+\t\t\t\tif (other == constraint) continue;", "+\t\t\t\tif (dependsOn(infVars, other.outputVariables(this))) {", "+\t\t\t\t\t// found a dependency, record it:", "+\t\t\t\t\tSet<ConstraintFormula> targetSet = dependencies.get(constraint);", "+\t\t\t\t\tif (targetSet == null)", "+\t\t\t\t\t\tdependencies.put(constraint, targetSet = new HashSet<ConstraintFormula>());", "+\t\t\t\t\ttargetSet.add(other);", "+\t\t\t\t\t// look for a cycle:", "+\t\t\t\t\tSet<ConstraintFormula> nodesInCycle = new HashSet<ConstraintFormula>();", "+\t\t\t\t\tif (isReachable(dependencies, other, constraint, new HashSet<ConstraintFormula>(), nodesInCycle)) {", "+\t\t\t\t\t\t// found a cycle, record the involved nodes:", "+\t\t\t\t\t\tcycles.addAll(nodesInCycle);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tSet<ConstraintFormula> outside = new HashSet<ConstraintFormula>(c);", "+\t\toutside.removeAll(cycles);", "+", "+\t\tSet<ConstraintFormula> candidatesII = new HashSet<ConstraintFormula>();", "+\t\t// (i): participates in a cycle:", "+\t\tcandidates: for (ConstraintFormula candidate : cycles) {", "+\t\t\tCollection<InferenceVariable> infVars = candidate.inputVariables(this);", "+\t\t\t// (ii) does not depend on any constraints outside the cycle", "+\t\t\tfor (ConstraintFormula out : outside) {", "+\t\t\t\tif (dependsOn(infVars, out.outputVariables(this)))", "+\t\t\t\t\tcontinue candidates;", "+\t\t\t}", "+\t\t\tcandidatesII.add(candidate);", "+\t\t}", "+\t\tif (candidatesII.isEmpty())", "+\t\t\tcandidatesII = c; // not spec'ed but needed to avoid returning null below, witness: java.util.stream.Collectors", "+\t\t", "+\t\t// tentatively: (iii)  has the form \u27e8Expression \u2192 T\u27e9", "+\t\tSet<ConstraintFormula> candidatesIII = new HashSet<ConstraintFormula>();", "+\t\tfor (ConstraintFormula candidate : candidatesII) {", "+\t\t\tif (candidate instanceof ConstraintExpressionFormula)", "+\t\t\t\tcandidatesIII.add(candidate);", "+\t\t}", "+\t\tif (candidatesIII.isEmpty()) {", "+\t\t\tcandidatesIII = candidatesII; // no constraint fulfills (iii) -> ignore this condition", "+\t\t} else { // candidatesIII contains all relevant constraints \u27e8Expression \u2192 T\u27e9", "+\t\t\t// (iv) contains an expression that appears to the left of the expression", "+\t\t\t// \t\tof every other constraint satisfying the previous three requirements", "+\t\t\t", "+\t\t\t// collect containment info regarding all expressions in candidate constraints:", "+\t\t\t// (a) find minimal enclosing expressions:", "+\t\t\tMap<ConstraintExpressionFormula,ConstraintExpressionFormula> expressionContainedBy = new HashMap<ConstraintExpressionFormula, ConstraintExpressionFormula>();", "+\t\t\tfor (ConstraintFormula one : candidatesIII) {", "+\t\t\t\tConstraintExpressionFormula oneCEF = (ConstraintExpressionFormula) one;", "+\t\t\t\tExpression exprOne = oneCEF.left;", "+\t\t\t\tfor (ConstraintFormula two : candidatesIII) {", "+\t\t\t\t\tif (one == two) continue;", "+\t\t\t\t\tConstraintExpressionFormula twoCEF = (ConstraintExpressionFormula) two;", "+\t\t\t\t\tExpression exprTwo = twoCEF.left;", "+\t\t\t\t\tif (doesExpressionContain(exprOne, exprTwo)) {", "+\t\t\t\t\t\tConstraintExpressionFormula previous = expressionContainedBy.get(two);", "+\t\t\t\t\t\tif (previous == null || doesExpressionContain(previous.left, exprOne)) // only if improving", "+\t\t\t\t\t\t\texpressionContainedBy.put(twoCEF, oneCEF);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// (b) build the tree from the above", "+\t\t\tMap<ConstraintExpressionFormula,Set<ConstraintExpressionFormula>> containmentForest = new HashMap<ConstraintExpressionFormula, Set<ConstraintExpressionFormula>>();", "+\t\t\tfor (Map.Entry<ConstraintExpressionFormula, ConstraintExpressionFormula> parentRelation : expressionContainedBy.entrySet()) {", "+\t\t\t\tConstraintExpressionFormula parent = parentRelation.getValue();", "+\t\t\t\tSet<ConstraintExpressionFormula> children = containmentForest.get(parent);", "+\t\t\t\tif (children == null)", "+\t\t\t\t\tcontainmentForest.put(parent, children = new HashSet<ConstraintExpressionFormula>());", "+\t\t\t\tchildren.add(parentRelation.getKey());", "+\t\t\t}", "+\t\t\t", "+\t\t\t// approximate the spec by searching the largest containment tree:", "+\t\t\tint bestRank = -1;", "+\t\t\tConstraintExpressionFormula candidate = null;", "+\t\t\tfor (ConstraintExpressionFormula parent : containmentForest.keySet()) {", "+\t\t\t\tint rank = rankNode(parent, expressionContainedBy, containmentForest);", "+\t\t\t\tif (rank > bestRank) {", "+\t\t\t\t\tbestRank = rank;", "+\t\t\t\t\tcandidate = parent;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (candidate != null)", "+\t\t\t\treturn candidate;", "+\t\t}", "+\t\t", "+\t\tif (candidatesIII.isEmpty())", "+\t\t\tthrow new IllegalStateException(\"cannot pick constraint from cyclic set\"); //$NON-NLS-1$", "+\t\treturn candidatesIII.iterator().next();", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0b4366bd6d8f8fd10c88340b3c02416", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java", "commitBeforeChange": "372799d5bd955eabbf1069fe0bbf8aba8ea8af85", "commitAfterChange": "baf433f0226e8b9036b18a28d560e5a42cb8b949", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tprivate static Map<String, AnnotationTypeDeclaration> getAnnotationTypeDeclarations( \t\t\tCompilationUnit astCompilationUnit, BaseProcessorEnv env)", "signatureAfterChange": " \tprivate void runAPTInMixedMode( \t\t\tfinal List<AnnotationProcessorFactory> factories, \t\t\tfinal ProcessorEnvImpl processorEnv)", "diff": ["+\t */", "+\tprivate void runAPTInMixedMode(", "+\t\t\tfinal List<AnnotationProcessorFactory> factories,", "+\t\t\tfinal ProcessorEnvImpl processorEnv)", "+\t{", "+\t\tfinal Map<IFile, Set<AnnotationTypeDeclaration>> file2AnnotationDecls = ", "+\t\t\tnew HashMap<IFile, Set<AnnotationTypeDeclaration>>(_filesToProcess.length * 4/3 + 1);", "+\t\tfinal Map<String, AnnotationTypeDeclaration> annotationDecls = ", "+\t\t\tprocessorEnv.getAllAnnotationTypes(file2AnnotationDecls);\t", "+\t\t", "+\t\tSystem.err.println(file2AnnotationDecls);", "+\t\t", "+\t\tif (annotationDecls.isEmpty())", "+\t\t{", "+\t\t\tif ( AptPlugin.DEBUG ) ", "+\t\t\t\ttrace( \"runAPT:  leaving early because annotationDecls is empty\" ); //$NON-NLS-1$", "+\t\t\treturn;", "+\t\t}", "+\t\t", "+\t\t// file based processing factory to the set of annotations that it 'claims'", "+\t\tfinal Map<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>> fileFactory2Annos =", "+\t\t\tnew HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( factories.size() * 4/3 + 1 );", "+\t\t", "+\t\t// batch processing factory to the set of annotations that it 'claims'", "+\t\tfinal Map<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>> batchFactory2Annos =", "+\t\t\tnew HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( factories.size() * 4/3 + 1 );\t\t", "+\t\t", "+\t\tfor( int i=0, size=factories.size(); i<size; i++ ){", "+\t\t\tfinal AnnotationProcessorFactory factory = factories.get(i);", "+\t\t\tSet<AnnotationTypeDeclaration> annotationTypes = getFactorySupportedAnnotations(factory, annotationDecls);", "+\t\t\tif( annotationTypes != null ){", "+\t\t\t\t", "+\t\t\t\tboolean batch = isBatchFactory(factory);", "+\t\t\t\tMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration> > factory2Annos = ", "+\t\t\t\t\tbatch ? batchFactory2Annos : fileFactory2Annos;", "+\t\t\t\tif( annotationTypes.size() == 0 ){", "+\t\t\t\t\t// this factory is claiming all (remaining) annotations. ", "+\t\t\t\t\tannotationTypes = new HashSet<AnnotationTypeDeclaration>(annotationDecls.values());", "+\t\t\t\t\tfactory2Annos.put(factory, annotationTypes);", "+\t\t\t\t\tannotationDecls.clear();", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\telse{", "+\t\t\t\t\tfactory2Annos.put(factory, annotationTypes);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif( annotationDecls.isEmpty() )", "+\t\t\t\tbreak;", "+\t\t}", "+\t\t", "+\t\tif( ! annotationDecls.isEmpty() )", "+\t\t\t; // TODO: (theodora) log unclaimed annotations.", "+\t\t", "+\t\t// Dispatch to the batch process factories first.", "+\t\t// Batch processors only get executed on a full/clean build.", "+\t\tif( !batchFactory2Annos.isEmpty() ){", "+\t\t\tprocessorEnv.setBatchProcessing();", "+\t\t\t// Once we figure out which factory claims what annotation,", "+\t\t\t// the order of the factory doesn't matter.", "+\t\t\t// But in order to make things consists between runs, will ", "+\t\t\t// dispatch base on factory order.", "+\t\t\tfor( int i=0, size=factories.size(); i<size; i++ ){", "+\t\t\t\tfinal AnnotationProcessorFactory factory = factories.get(i);", "+\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypes = batchFactory2Annos.get(factory);", "+\t\t\t\tif( annotationTypes == null ) continue;", "+\t\t\t\tfinal AnnotationProcessor processor = ", "+\t\t\t\t\tfactory.getProcessorFor(annotationTypes, processorEnv);", "+\t\t\t\tif( processor != null ){", "+\t\t\t\t\tif ( AptPlugin.DEBUG ) ", "+\t\t\t\t\t\ttrace( \"runAPT: invoking batch processor \" + processor.getClass().getName() ); //$NON-NLS-1$", "+                    processorEnv.setLatestProcessor(processor);", "+\t\t\t\t\tprocessor.process();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Now, do the file based dispatch", "+\t\tif( !fileFactory2Annos.isEmpty() ){", "+\t\t\tfor( int fileIndex=0, numFiles=_filesToProcess.length; fileIndex<numFiles; fileIndex ++ ){", "+\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypesInFile = file2AnnotationDecls.get(_filesToProcess[fileIndex]);", "+\t\t\t\tif( annotationTypesInFile == null || annotationTypesInFile.isEmpty() )", "+\t\t\t\t\tcontinue;", "+\t\t\t\tfor( int i=0, size=factories.size(); i<size; i++ ){", "+\t\t\t\t\tfinal AnnotationProcessorFactory factory = factories.get(i);", "+\t\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypesForFactory = fileFactory2Annos.get(factory);", "+\t\t\t\t\tif( annotationTypesForFactory == null || annotationTypesForFactory.isEmpty() ) ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tfinal Set<AnnotationTypeDeclaration> intersect = setIntersect(annotationTypesInFile, annotationTypesForFactory);", "+\t\t\t\t\tif( intersect != null && !intersect.isEmpty() ){", "+\t\t\t\t\t\tprocessorEnv.setFileProcessing(_filesToProcess[fileIndex]);", "+\t\t\t\t\t\tfinal AnnotationProcessor processor = ", "+\t\t\t\t\t\t\tfactory.getProcessorFor(intersect, processorEnv);", "+\t\t\t\t\t\tif( processor != null ){", "+\t\t\t\t\t\t\tif ( AptPlugin.DEBUG ) ", "+\t\t\t\t\t\t\t\ttrace( \"runAPT: invoking file-based processor \" + processor.getClass().getName() ); //$NON-NLS-1$", "+\t\t                    processorEnv.setLatestProcessor(processor);", "+\t\t\t\t\t\t\tprocessor.process();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "-", "-\tprivate static Map<String, AnnotationTypeDeclaration> getAnnotationTypeDeclarations(", "-\t\t\tCompilationUnit astCompilationUnit, BaseProcessorEnv env) {", "-\t\tfinal List<Annotation> instances = new ArrayList<Annotation>();", "-\t\tfinal AnnotationVisitor visitor = new AnnotationVisitor(instances);", "-\t\tastCompilationUnit.accept(visitor);", "-\t\tfinal Map<String, AnnotationTypeDeclaration> decls = new HashMap<String, AnnotationTypeDeclaration>();", "-\t\tfor (int i = 0, size = instances.size(); i < size; i++) {", "-\t\t\tfinal Annotation instance = instances.get(i);", "-\t\t\tfinal ITypeBinding annoType = instance.resolveTypeBinding();", "-\t\t\tif (annoType == null)", "-\t\t\t\tcontinue;", "-\t\t\tfinal TypeDeclarationImpl annoDecl = Factory.createReferenceType(", "-\t\t\t\t\tannoType, env);", "-\t\t\tif (annoDecl.kind() == EclipseMirrorImpl.MirrorKind.TYPE_ANNOTATION)", "-\t\t\t\tdecls.put(annoDecl.getQualifiedName(),", "-\t\t\t\t\t\t(AnnotationTypeDeclaration) annoDecl);", "-\t\t}", "-\t\treturn decls;", "-\t}"]}], "num": 39891}