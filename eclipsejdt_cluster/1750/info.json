{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fabf975d370094bc903fdfcf0194e242", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "92df2c9d6cfbe37e62a80d8474f85c1a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "607ff419d62fc0f91055d1c2d16685459d9fa667", "commitAfterChange": "0cad9a75d8029433899afbdf88cbb39e8dd0618a", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " void computeInheritedMethods()", "signatureAfterChange": " void computeInheritedMethods()", "diff": ["+\t// only want to remember inheritedMethods that can have an impact on the current type", "+\t// if an inheritedMethod has been 'replaced' by a supertype's method then skip it", "+", "-\t\t\t\tMethodBinding method = methods[m];", "-\t\t\t\tif (method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())", "+\t\t\t\tMethodBinding inheritedMethod = methods[m];", "+\t\t\t\tif (inheritedMethod.isPrivate() || inheritedMethod.isConstructor() || inheritedMethod.isDefaultAbstract())", "-\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);", "+\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);", "-\t\t\t\t\t\tif (areReturnTypesEqual(method, existingMethods[i]) && areParametersEqual(method, existingMethods[i])) {", "-\t\t\t\t\t\t\tif (method.isDefault() && method.isAbstract() && method.declaringClass.fPackage != type.fPackage)", "-\t\t\t\t\t\t\t\tcheckPackagePrivateAbstractMethod(method);", "+\t\t\t\t\t\tif (doesMethodOverride(existingMethods[i], inheritedMethod)) {", "+\t\t\t\t\t\t\tif (inheritedMethod.isDefault() && inheritedMethod.isAbstract())", "+\t\t\t\t\t\t\t\tcheckPackagePrivateAbstractMethod(inheritedMethod);", "-\t\t\t\tMethodBinding[] nonVisible = (MethodBinding[]) nonVisibleDefaultMethods.get(method.selector);", "+\t\t\t\tMethodBinding[] nonVisible = (MethodBinding[]) nonVisibleDefaultMethods.get(inheritedMethod.selector);", "-\t\t\t\t\t\tif (areReturnTypesEqual(method, nonVisible[i]) && areParametersEqual(method, nonVisible[i])) ", "+\t\t\t\t\t\tif (doesMethodOverride(nonVisible[i], inheritedMethod))", "-\t\t\t\tif (!method.isDefault() || method.declaringClass.fPackage == type.fPackage) {", "+\t\t\t\tif (!inheritedMethod.isDefault() || inheritedMethod.declaringClass.fPackage == type.fPackage) {", "-\t\t\t\t\t\texistingMethods = new MethodBinding[] {method};", "+\t\t\t\t\t\texistingMethods = new MethodBinding[] {inheritedMethod};", "-\t\t\t\t\t\texistingMethods[length] = method;", "+\t\t\t\t\t\texistingMethods[length] = inheritedMethod;", "-\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);", "+\t\t\t\t\tthis.inheritedMethods.put(inheritedMethod.selector, existingMethods);", "-\t\t\t\t\t\tnonVisible = new MethodBinding[] {method};", "+\t\t\t\t\t\tnonVisible = new MethodBinding[] {inheritedMethod};", "-\t\t\t\t\t\tnonVisible[length] = method;", "+\t\t\t\t\t\tnonVisible[length] = inheritedMethod;", "-\t\t\t\t\tnonVisibleDefaultMethods.put(method.selector, nonVisible);", "+\t\t\t\t\tnonVisibleDefaultMethods.put(inheritedMethod.selector, nonVisible);", "-\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract", "-\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, method);", "+\t\t\t\t\tif (inheritedMethod.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract", "+\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, inheritedMethod);", "-\t\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(method.selector);", "+\t\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(inheritedMethod.selector);", "-\t\t\t\t\t\t\tif (areReturnTypesEqual(method, current[i]) && areParametersEqual(method, current[i])) {", "-\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);", "+\t\t\t\t\t\t\tif (doesMethodOverride(current[i], inheritedMethod)) {", "+\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], inheritedMethod);", "-\t\t\t\t\t\tMethodBinding method = methods[m];", "-\t\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);", "+\t\t\t\t\t\tMethodBinding inheritedMethod = methods[m];", "+\t\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);", "-\t\t\t\t\t\t\texistingMethods = new MethodBinding[] {method};", "+\t\t\t\t\t\t\texistingMethods = new MethodBinding[] {inheritedMethod};", "-\t\t\t\t\t\t\t\tif (areParametersEqual(method, existing) && existing.declaringClass.implementsInterface(superType, true))", "+\t\t\t\t\t\t\t\t// look to see if any of the existingMethods implement this inheritedMethod", "+\t\t\t\t\t\t\t\tif (areParametersEqual(existing, inheritedMethod) && existing.declaringClass.implementsInterface(superType, true))", "+// so if the implemented method is abstract & has a different return type then did it get a bridge method?", "-\t\t\t\t\t\t\texistingMethods[length] = method;", "+\t\t\t\t\t\t\texistingMethods[length] = inheritedMethod;", "-\t\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);", "+\t\t\t\t\t\tthis.inheritedMethods.put(inheritedMethod.selector, existingMethods);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a6f237cb2cf45b155fa3a674ec225b74", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "cefc7f3f8677282aa49e610700500999ffcaffcb", "commitAfterChange": "89e8879d5dd978e5f2535f9d8b7bac080dd4f73b", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "signatureAfterChange": " protected IJavaElement createHandle(LambdaExpression lambdaExpression, IJavaElement parent)", "diff": ["+ */", "+protected IJavaElement createHandle(LambdaExpression lambdaExpression, IJavaElement parent) {", "+\tif (!(parent instanceof IType)) return parent;", "+", "+\tIType type = (IType) parent;", "+\tArgument[] arguments = lambdaExpression.arguments();", "+\tint syntheticArgumentSize = lambdaExpression.getSyntheticArgumentSize();", "+\tMethodBinding descriptor = lambdaExpression.descriptor;", "+\tint argCount = arguments == null ? 0 : arguments.length;", "+\tif (type.isBinary()) {", "+\t\tClassFileReader reader = classFileReader(type);", "+\t\tif (reader != null) {", "+\t\t\t// build arguments names", "+\t\t\tchar[][] argumentTypeNames = new char[argCount - syntheticArgumentSize][];", "+\t\t\tfor (int i = syntheticArgumentSize; i < argCount; i++) {", "+\t\t\t\tchar[] typeName = null;", "+\t\t\t\tif (arguments != null) {", "+\t\t\t\t\tTypeReference typeRef = arguments[i].type;", "+\t\t\t\t\ttypeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "+\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "+\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t\t}", "+\t\t\t\tif (typeName == null) {", "+\t\t\t\t\t// invalid type name", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t\targumentTypeNames[i - syntheticArgumentSize] = typeName;", "+\t\t\t}", "+\t\t\t// return binary method", "+\t\t\tIMethod binaryMethod = createBinaryMethodHandle(type, descriptor.selector, argumentTypeNames);", "+\t\t\tif (binaryMethod == null) {", "+\t\t\t\t// when first attempt fails, try with similar matches if any...", "+\t\t\t\tPossibleMatch similarMatch = this.currentPossibleMatch.getSimilarMatch();", "+\t\t\t\twhile (similarMatch != null) {", "+\t\t\t\t\ttype = ((ClassFile)similarMatch.openable).getType();", "+\t\t\t\t\tbinaryMethod = createBinaryMethodHandle(type, descriptor.selector, argumentTypeNames);", "+\t\t\t\t\tif (binaryMethod != null) {", "+\t\t\t\t\t\treturn binaryMethod;", "+\t\t\t\t\t}", "+\t\t\t\t\tsimilarMatch = similarMatch.getSimilarMatch();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn binaryMethod;", "+\t\t}", "+\t\tif (BasicSearchEngine.VERBOSE) {", "+\t\t\tSystem.out.println(\"Not able to createHandle for the lambda expression \" + //$NON-NLS-1$", "+\t\t\t\t\tCharOperation.charToString(descriptor.selector) + \" May miss some results\");  //$NON-NLS-1$", "+\t\t}", "+\t\treturn null;", "+\t}", "+", "+\tString[] parameterTypeSignatures = new String[argCount - syntheticArgumentSize];", "+\tif (arguments != null) {", "+\t\tfor (int i = syntheticArgumentSize; i < argCount; i++) {", "+\t\t\tTypeReference typeRef = arguments[i].type;", "+\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getParameterizedTypeName(), '.');", "+\t\t\tparameterTypeSignatures[i - syntheticArgumentSize] = Signature.createTypeSignature(typeName, false);", "+\t\t}", "+\t}", "+", "+\treturn createMethodHandle(type, new String(descriptor.selector), parameterTypeSignatures);", "+}"]}], "num": 1750}