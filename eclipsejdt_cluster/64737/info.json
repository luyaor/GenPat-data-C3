{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c34e442e89852b5ab3c21db96895ba8c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46d4735650706660b2b7d3ae6438c76a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java", "commitBeforeChange": "a44f85b2f1ceea345211e0233ce1a337f2608f27", "commitAfterChange": "48b7af2e3739986d2ddc652f88a3f13a620e9f11", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r \tpublic synchronized void discardJobs(String jobFamily)", "signatureAfterChange": "\r \tpublic void discardJobs(String jobFamily)", "diff": ["-\tpublic synchronized void discardJobs(String jobFamily) {\r", "+\tpublic void discardJobs(String jobFamily) {\r", "-\t\t\t// flush and compact awaiting jobs\r", "-\t\t\tint loc = -1;\r", "-\t\t\tfor (int i = jobStart; i <= jobEnd; i++) {\r", "-\t\t\t\tIJob currentJob = awaitingJobs[i];\r", "-\t\t\t\tawaitingJobs[i] = null;\r", "-\t\t\t\tif (!(jobFamily == null\r", "-\t\t\t\t\t|| currentJob.belongsTo(jobFamily))) { // copy down, compacting\r", "-\t\t\t\t\tawaitingJobs[++loc] = currentJob;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tcurrentJob.cancel();\r", "-\t\t\t\t\tif (i == jobStart) {\r", "-\t\t\t\t\t\t// wait until current active job has accepted the cancel\r", "-\t\t\t\t\t\twhile (thread != null && executing){\r", "-\t\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\t\tThread.currentThread().sleep(50);\r", "-\t\t\t\t\t\t\t} catch(InterruptedException e){\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "+\t\t\t// cancel current job if it belongs to the given family\r", "+\t\t\tIJob currentJob = this.currentJob();\r", "+\t\t\tif (currentJob != null \r", "+\t\t\t\t\t&& (jobFamily == null || currentJob.belongsTo(jobFamily))) {\r", "+\t\r", "+\t\t\t\tcurrentJob.cancel();\r", "+\t\t\t\r", "+\t\t\t\t// wait until current active job has finished\r", "+\t\t\t\twhile (thread != null && executing){\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tThread.currentThread().sleep(50);\r", "+\t\t\t\t\t} catch(InterruptedException e){\r", "-\t\t\tjobStart = 0;\r", "-\t\t\tjobEnd = loc;\r", "+\t\r", "+\t\t\t// flush and compact awaiting jobs\r", "+\t\t\tint loc = -1;\r", "+\t\t\tsynchronized(this) {\r", "+\t\t\t\tfor (int i = jobStart; i <= jobEnd; i++) {\r", "+\t\t\t\t\tcurrentJob = awaitingJobs[i];\r", "+\t\t\t\t\tawaitingJobs[i] = null;\r", "+\t\t\t\t\tif (!(jobFamily == null\r", "+\t\t\t\t\t\t|| currentJob.belongsTo(jobFamily))) { // copy down, compacting\r", "+\t\t\t\t\t\tawaitingJobs[++loc] = currentJob;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tcurrentJob.cancel();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tjobStart = 0;\r", "+\t\t\t\tjobEnd = loc;\r", "+\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7da06ac4eb2ee7453141d0e669ebaf81", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java", "commitBeforeChange": "a892b0b3c0635e3209dc7ab575a387f1b279c366", "commitAfterChange": "2f9879f724f9f3e353901133d237ccdd9a5fa50d", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r public synchronized void discardJobsUntilNextProjectAddition(String jobFamily)", "signatureAfterChange": "\r public void discardJobsUntilNextProjectAddition(String jobFamily)", "diff": ["-public synchronized void discardJobsUntilNextProjectAddition(String jobFamily) {\r", "+public void discardJobsUntilNextProjectAddition(String jobFamily) {\r", "-\r", "-\t\t// flush and compact awaiting jobs\r", "-\t\tint loc = -1;\r", "-\t\tboolean foundProjectAddition = false;\r", "-\t\tfor (int i = jobStart; i <= jobEnd; i++){\r", "-\t\t\tIJob currentJob = awaitingJobs[i];\r", "-\t\t\tawaitingJobs[i] = null;\r", "-\t\t\tboolean discard = jobFamily == null;\r", "-\t\t\tif (!discard && currentJob.belongsTo(jobFamily)){ // might discard\r", "-\t\t\t\tif (!(foundProjectAddition || (foundProjectAddition = currentJob instanceof IndexAllProject))) {\r", "-\t\t\t\t\tdiscard = true;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tif (discard) {\r", "-\t\t\t\tcurrentJob.cancel();\r", "-\t\t\t\tif (i == jobStart) {\r", "-\t\t\t\t\t// wait until current active job has accepted the cancel\r", "-\t\t\t\t\twhile (thread != null && executing){\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tThread.currentThread().sleep(50);\r", "-\t\t\t\t\t\t} catch(InterruptedException e){\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t} else {\r", "-\t\t\t\tawaitingJobs[++loc] = currentJob;\r", "+\t\t\r", "+\t\t// wait until current active job has finished\r", "+\t\twhile (thread != null && executing){\r", "+\t\t\ttry {\r", "+\t\t\t\tThread.currentThread().sleep(50);\r", "+\t\t\t} catch(InterruptedException e){\r", "-\t\tjobStart = 0;\r", "-\t\tjobEnd = loc;\r", "+\r", "+\t\tsynchronized(this) {\r", "+\t\t\t// flush and compact awaiting jobs\r", "+\t\t\tint loc = -1;\r", "+\t\t\tboolean foundProjectAddition = false;\r", "+\t\t\tfor (int i = jobStart+1; i <= jobEnd; i++){\r", "+\t\t\t\tIJob currentJob = awaitingJobs[i];\r", "+\t\t\t\tawaitingJobs[i] = null;\r", "+\t\t\t\tboolean discard = jobFamily == null;\r", "+\t\t\t\tif (!discard && currentJob.belongsTo(jobFamily)){ // might discard\r", "+\t\t\t\t\tif (!(foundProjectAddition || (foundProjectAddition = currentJob instanceof IndexAllProject))) {\r", "+\t\t\t\t\t\tdiscard = true;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tif (discard) {\r", "+\t\t\t\t\tcurrentJob.cancel();\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tawaitingJobs[++loc] = currentJob;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tjobStart = 0;\r", "+\t\t\tjobEnd = loc;\r", "+\t\t}\r", "-\t\tif (wasEnabled)\tenable();\r", "+\t\tif (wasEnabled) enable();\r"]}], "num": 64737}