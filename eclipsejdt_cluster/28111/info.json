{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "21018bb812c4f88a1eda6497d6a384b7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b564afdadd4f3272fd690e79c52b015f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "4b7408bf1768e4fe08faa711e23ea5c6fe36d225", "commitAfterChange": "4088e11dac262e43550a58fc93a14d090417ec2f", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 76, "signatureBeforeChange": " \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "signatureAfterChange": " \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["-\t\t\t\tSimpleSet possibleMethods = null;", "+\t\t\t\tboolean shouldIntersectExceptions = original.declaringClass.isInterface() && original.thrownExceptions != Binding.NO_EXCEPTIONS; // only needed when selecting from interface methods", "-\t\t\t\t\t\tif (original.thrownExceptions != original2.thrownExceptions) {", "-\t\t\t\t\t\t\tif (mostSpecificExceptions == null)", "-\t\t\t\t\t\t\t\tmostSpecificExceptions = original.thrownExceptions;", "-\t\t\t\t\t\t\tif (possibleMethods == null)", "-\t\t\t\t\t\t\t\tpossibleMethods = new SimpleSet(3);", "-\t\t\t\t\t\t\tint mostSpecificLength = mostSpecificExceptions.length;", "-\t\t\t\t\t\t\tint original2Length = original2.thrownExceptions.length;", "-\t\t\t\t\t\t\tSimpleSet temp = new SimpleSet(mostSpecificLength);", "-\t\t\t\t\t\t\tnextException : for (int t = 0; t < mostSpecificLength; t++) {", "-\t\t\t\t\t\t\t\tReferenceBinding exception = mostSpecificExceptions[t];", "-\t\t\t\t\t\t\t\tfor (int s = 0; s < original2Length; s++) {", "-\t\t\t\t\t\t\t\t\tif (exception.isCompatibleWith(original2.thrownExceptions[s])) {", "-\t\t\t\t\t\t\t\t\t\tpossibleMethods.add(current);", "-\t\t\t\t\t\t\t\t\t\ttemp.add(exception);", "-\t\t\t\t\t\t\t\t\t\tcontinue nextException;", "-\t\t\t\t\t\t\t\t\t} else if (original2.thrownExceptions[s].isCompatibleWith(exception)) {", "-\t\t\t\t\t\t\t\t\t\tpossibleMethods.add(next);", "-\t\t\t\t\t\t\t\t\t\ttemp.add(original2.thrownExceptions[s]);", "-\t\t\t\t\t\t\t\t\t\tcontinue nextException;", "+\t\t\t\t\t\tif (shouldIntersectExceptions && original2.declaringClass.isInterface()) {", "+\t\t\t\t\t\t\tif (original.thrownExceptions != original2.thrownExceptions) {", "+\t\t\t\t\t\t\t\tif (original2.thrownExceptions == Binding.NO_EXCEPTIONS) {", "+\t\t\t\t\t\t\t\t\tmostSpecificExceptions = Binding.NO_EXCEPTIONS;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tif (mostSpecificExceptions == null) {", "+\t\t\t\t\t\t\t\t\t\tmostSpecificExceptions = original.thrownExceptions;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tint mostSpecificLength = mostSpecificExceptions.length;", "+\t\t\t\t\t\t\t\t\tint original2Length = original2.thrownExceptions.length;", "+\t\t\t\t\t\t\t\t\tSimpleSet temp = new SimpleSet(mostSpecificLength);", "+\t\t\t\t\t\t\t\t\tboolean changed = false;", "+\t\t\t\t\t\t\t\t\tnextException : for (int t = 0; t < mostSpecificLength; t++) {", "+\t\t\t\t\t\t\t\t\t\tReferenceBinding exception = mostSpecificExceptions[t];", "+\t\t\t\t\t\t\t\t\t\tfor (int s = 0; s < original2Length; s++) {", "+\t\t\t\t\t\t\t\t\t\t\tif (exception.isCompatibleWith(original2.thrownExceptions[s])) {", "+\t\t\t\t\t\t\t\t\t\t\t\ttemp.add(exception);", "+\t\t\t\t\t\t\t\t\t\t\t\tcontinue nextException;", "+\t\t\t\t\t\t\t\t\t\t\t} else if (original2.thrownExceptions[s].isCompatibleWith(exception)) {", "+\t\t\t\t\t\t\t\t\t\t\t\ttemp.add(original2.thrownExceptions[s]);", "+\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;", "+\t\t\t\t\t\t\t\t\t\t\t\tcontinue nextException;", "+\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (changed) {", "+\t\t\t\t\t\t\t\t\t\tmostSpecificExceptions = temp.elementSize == 0 ? Binding.NO_EXCEPTIONS : new ReferenceBinding[temp.elementSize];", "+\t\t\t\t\t\t\t\t\t\ttemp.asArray(mostSpecificExceptions);", "-\t\t\t\t\t\t\tmostSpecificExceptions = temp.elementSize == 0 ? Binding.NO_EXCEPTIONS : new ReferenceBinding[temp.elementSize];", "-\t\t\t\t\t\t\ttemp.asArray(mostSpecificExceptions);", "-\t\t\t\tif (mostSpecificExceptions != null) {", "-\t\t\t\t\tObject[] values = possibleMethods.values;", "-\t\t\t\t\tint exceptionLength = mostSpecificExceptions.length;", "-\t\t\t\t\tnextMethod : for (int p = 0, vLength = values.length; p < vLength; p++) {", "-\t\t\t\t\t\tMethodBinding possible = (MethodBinding) values[p];", "-\t\t\t\t\t\tif (possible == null) continue nextMethod;", "-\t\t\t\t\t\tReferenceBinding[] itsExceptions = possible.thrownExceptions;", "-\t\t\t\t\t\tif (itsExceptions.length == exceptionLength) {", "-\t\t\t\t\t\t\tnextException : for (int e = 0; e < exceptionLength; e++) {", "-\t\t\t\t\t\t\t\tReferenceBinding exception = itsExceptions[e];", "-\t\t\t\t\t\t\t\tfor (int f = 0; f < exceptionLength; f++)", "-\t\t\t\t\t\t\t\t\tif (exception == mostSpecificExceptions[f]) continue nextException;", "-\t\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn possible;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\treturn new MethodBinding(", "-\t\t\t\t\t\tcurrent.modifiers | ClassFileConstants.AccSynthetic,", "-\t\t\t\t\t\tcurrent.selector,", "-\t\t\t\t\t\tcurrent.returnType,", "-\t\t\t\t\t\tcurrent.parameters,", "-\t\t\t\t\t\tmostSpecificExceptions,", "-\t\t\t\t\t\tcurrent.declaringClass", "-\t\t\t\t\t);", "+\t\t\t\tif (mostSpecificExceptions != null && mostSpecificExceptions != current.thrownExceptions) {", "+\t\t\t\t\treturn new MostSpecificExceptionMethodBinding(current, mostSpecificExceptions);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bd47b9735538eea21c062d24a8a30ad5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "a746953c3c39228e621101bf14cd960b61f268e5", "commitAfterChange": "8d9e4d82b7907a3f11b58a9fee1e77dc3999b852", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " public static int validateMatchRule(String stringPattern, int matchRule)", "signatureAfterChange": " public static int validateMatchRule(String stringPattern, int matchRule)", "diff": ["-\t\t\t(matchRule & R_CAMEL_CASE_MATCH) != 0 || (matchRule & R_CAMELCASE_MATCH) != 0) {", "+\t\t\t(matchRule & R_CAMELCASE_MATCH) != 0 || (matchRule & R_CAMELCASE_SAME_PART_COUNT_MATCH) != 0) {", "+\t\t\t// regexp is not supported yet", "-\tint starIndex = stringPattern.indexOf('*');", "-\tint questionIndex = stringPattern.indexOf('?');", "-\tif (starIndex < 0 && questionIndex < 0) {", "-\t\t// reset pattern match flag if any", "-\t\tmatchRule &= ~R_PATTERN_MATCH;", "-\t} else {", "-\t\t// force Pattern rule", "-\t\tmatchRule |= R_PATTERN_MATCH;", "+\tif (stringPattern != null) {", "+\t\tint starIndex = stringPattern.indexOf('*');", "+\t\tint questionIndex = stringPattern.indexOf('?');", "+\t\tif (starIndex < 0 && questionIndex < 0) {", "+\t\t\t// reset pattern match flag if any", "+\t\t\tmatchRule &= ~R_PATTERN_MATCH;", "+\t\t} else {", "+\t\t\t// force Pattern rule", "+\t\t\tmatchRule |= R_PATTERN_MATCH;", "+\t\t}", "-\t\t// remove Camel Case and Prefix match flags if any", "+\t\t// reset other incompatible flags", "-\t\tmatchRule &= ~R_CAMEL_CASE_MATCH;", "+\t\tmatchRule &= ~R_CAMELCASE_SAME_PART_COUNT_MATCH;", "+\t\treturn matchRule;", "-\t// Verify Camel Case match rule", "-\tif ((matchRule & R_CAMEL_CASE_MATCH) != 0) {", "-\t\tmatchRule &= ~R_CAMELCASE_MATCH; // in case of some user specify both constants", "-\t\t// Verify sting pattern validity", "-\t\tint length = stringPattern.length();", "-\t\tboolean validCamelCase = true;", "-\t\tboolean uppercase = false;", "-\t\tfor (int i=0; i<length && validCamelCase; i++) {", "-\t\t\tchar ch = stringPattern.charAt(i);", "-\t\t\tvalidCamelCase = i==0 ? ScannerHelper.isJavaIdentifierStart(ch) : ScannerHelper.isJavaIdentifierPart(ch);", "-\t\t\t// at least one uppercase character is need in CamelCase pattern", "-\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=136313)", "-\t\t\tif (!uppercase) uppercase = ScannerHelper.isUpperCase(ch);", "-\t\t}", "-\t\tvalidCamelCase = validCamelCase && uppercase;", "-\t\t// Verify flags compatibility", "+\t// Verify Camel Case", "+\tif ((matchRule & R_CAMELCASE_MATCH) != 0) {", "+\t\t// reset other incompatible flags", "+\t\tmatchRule &= ~R_CAMELCASE_SAME_PART_COUNT_MATCH;", "+\t\tmatchRule &= ~R_PREFIX_MATCH;", "+\t\t// validate camel case rule and modify it if not valid", "+\t\tboolean validCamelCase = validateCamelCasePattern(stringPattern);", "-\t\t\tmatchRule &= ~R_CAMEL_CASE_MATCH;", "+\t\t\tmatchRule &= ~R_CAMELCASE_MATCH;", "+\t\treturn matchRule;", "+\t}", "+\t", "+\t// Verify Camel Case with same count of parts", "+\tif ((matchRule & R_CAMELCASE_SAME_PART_COUNT_MATCH) != 0) {", "+\t\t// reset other incompatible flags", "+\t\tmatchRule &= ~R_PREFIX_MATCH;", "+\t\t// validate camel case rule and modify it if not valid", "+\t\tboolean validCamelCase = validateCamelCasePattern(stringPattern);", "+\t\tif (!validCamelCase) {", "+\t\t\tmatchRule &= ~R_CAMELCASE_SAME_PART_COUNT_MATCH;", "+\t\t}", "+\t\treturn matchRule;", "-\t// Verify deprecated Camel Case match rule for backward compatibility", "-\telse if ((matchRule & R_CAMELCASE_MATCH) != 0) {", "-\t\t// Verify sting pattern validity", "-\t\tint length = stringPattern.length();", "-\t\tboolean validCamelCase = true;", "-\t\tboolean uppercase = false;", "-\t\tfor (int i=0; i<length && validCamelCase; i++) {", "-\t\t\tchar ch = stringPattern.charAt(i);", "-\t\t\tvalidCamelCase = i==0 ? ScannerHelper.isJavaIdentifierStart(ch) : ScannerHelper.isJavaIdentifierPart(ch);", "-\t\t\t// at least one uppercase character is need in CamelCase pattern", "-\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=136313)", "-\t\t\tif (!uppercase) uppercase = ScannerHelper.isUpperCase(ch);", "-\t\t}", "-\t\tvalidCamelCase = validCamelCase && uppercase;", "-\t\t// Verify flags compatibility", "-\t\tif (validCamelCase) {", "-\t\t\tif ((matchRule & R_PREFIX_MATCH) != 0) {", "-\t\t\t\tif ((matchRule & R_CASE_SENSITIVE) != 0) {", "-\t\t\t\t\t// This is equivalent to Camel Case match rule", "-\t\t\t\t\tmatchRule &= ~R_PREFIX_MATCH;", "-\t\t\t\t\tmatchRule &= ~R_CASE_SENSITIVE;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} else {", "-\t\t\tmatchRule &= ~R_CAMELCASE_MATCH;", "-\t\t\tif ((matchRule & R_PREFIX_MATCH) == 0) {", "-\t\t\t\tmatchRule |= R_PREFIX_MATCH;", "-\t\t\t\tmatchRule |= R_CASE_SENSITIVE;", "-\t\t\t}", "-\t\t}", "-\t}", "+\t// Return the validated match rule (modified if necessary)"]}], "num": 28111}