{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ed117b8553a36c04c93f66320edbe9cc", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "56827fa4e86e769fc037daff34a997a6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java", "commitBeforeChange": "ba27b8beba862586d02454473338bb69e72c4fad", "commitAfterChange": "424434f0bc8f5f118b22e054c33acbc180d3cbd4", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r public MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "\r public MethodBinding findMethod(\r \tReferenceBinding receiverType,\r \tchar[] selector,\r \tTypeBinding[] argumentTypes,\r \tInvocationSite invocationSite)", "diff": ["-public MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite) {\r", "+public MethodBinding findMethod(\r", "+\tReferenceBinding receiverType,\r", "+\tchar[] selector,\r", "+\tTypeBinding[] argumentTypes,\r", "+\tInvocationSite invocationSite) {\r", "+\r", "-\tObjectVector found = null;\r", "+\tObjectVector found = new ObjectVector();\r", "+\r", "+\t//compilationUnitScope().recordTypeReference(receiverType);\r", "+\t//compilationUnitScope().recordTypeReferences(argumentTypes);\r", "-\t\t\tfound = new ObjectVector();\r", "-\r", "-\t\tReferenceBinding[] itsInterfaces = currentType.superInterfaces();\r", "-\t\tif (itsInterfaces != NoSuperInterfaces) {\r", "-\t\t\tReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];\r", "-\t\t\tint lastPosition = -1;\r", "-\t\t\tif (++lastPosition == interfacesToVisit.length)\r", "-\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);\r", "-\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;\r", "-\t\t\t\r", "-\t\t\tfor (int i = 0; i <= lastPosition; i++) {\r", "-\t\t\t\tReferenceBinding[] interfaces = interfacesToVisit[i];\r", "-\t\t\t\tfor (int j = 0, length = interfaces.length; j < length; j++) {\r", "-\t\t\t\t\tcurrentType = interfaces[j];\r", "-\t\t\t\t\tif ((currentType.tagBits & InterfaceVisited) == 0) { // if interface as not already been visited\r", "-\t\t\t\t\t\tcurrentType.tagBits |= InterfaceVisited;\r", "-\r", "-\t\t\t\t\t\tcurrentMethods = currentType.getMethods(selector);\r", "-\t\t\t\t\t\tif ((currentLength = currentMethods.length) == 1 && matchingMethod == null && found == null) {\r", "-\t\t\t\t\t\t\tmatchingMethod = currentMethods[0];\r", "-\t\t\t\t\t\t} else if (currentLength > 0) {\r", "-\t\t\t\t\t\t\tif (found == null) {\r", "-\t\t\t\t\t\t\t\tfound = new ObjectVector();\r", "-\t\t\t\t\t\t\t\tif (matchingMethod != null)\r", "-\t\t\t\t\t\t\t\t\tfound.add(matchingMethod);\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\tfor (int f = 0; f < currentLength; f++)\r", "-\t\t\t\t\t\t\t\tfound.add(currentMethods[f]);\r", "-\t\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\t\titsInterfaces = currentType.superInterfaces();\r", "-\t\t\t\t\t\tif (itsInterfaces != NoSuperInterfaces) {\r", "-\t\t\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)\r", "-\t\t\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);\r", "-\t\t\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\t// bit reinitialization\r", "-\t\t\tfor (int i = 0; i <= lastPosition; i++) {\r", "-\t\t\t\tReferenceBinding[] interfaces = interfacesToVisit[i];\r", "-\t\t\t\tfor (int j = 0, length = interfaces.length; j < length; j++)\r", "-\t\t\t\t\tinterfaces[j].tagBits &= ~InterfaceVisited;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\tcurrentType = (matchingMethod == null && found == null) ? getJavaLangObject() : null;\r", "+\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "+\t\tcurrentType = getJavaLangObject();\r", "+\t// superclass lookup\r", "+\tboolean hierarchyContainsAbstractClasses = false;\r", "+\tReferenceBinding classHierarchyStart = currentType;\r", "+\t\r", "-\t\tif (currentLength == 1 && matchingMethod == null && found == null) {\r", "+\t\tif (currentLength == 1 && matchingMethod == null && found.size == 0) {\r", "-\t\t\tif (found == null) {\r", "-\t\t\t\tfound = new ObjectVector();\r", "-\t\t\t\tif (matchingMethod != null)\r", "-\t\t\t\t\tfound.add(matchingMethod);\r", "-\t\t\t}\r", "+\t\t\tif (found.size == 0 && matchingMethod != null)\r", "+\t\t\t\tfound.add(matchingMethod);\r", "+\t\tif (currentType.isAbstract()) hierarchyContainsAbstractClasses = true;\r", "-\tif (found == null)\r", "-\t\treturn matchingMethod; // may be null - have not checked arg types or visibility\r", "+\t// abstract superclass superinterface lookup (since maybe missing default\r", "+\t// abstract methods)\r", "+\tif (hierarchyContainsAbstractClasses){\r", "+\t\tcurrentType = classHierarchyStart;\r", "+\t\twhile (currentType != null){\r", "+\t\t\tif (currentType.isAbstract()){\r", "+\t\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "+\t\t\t}\r", "+\t\t\tcurrentType = currentType.superclass();\r", "+\t\t}\r", "+\t}\r", "-\tMethodBinding[] compatible = new MethodBinding[foundSize];\r", "-\tint compatibleIndex = 0;\r", "+\tif (foundSize == 0)\r", "+\t\treturn matchingMethod; // may be null - have not checked arg types or visibility\r", "+\r", "+\tMethodBinding[] candidates = new MethodBinding[foundSize];\r", "+\tint candidatesCount = 0;\r", "+\r", "+\t// argument type compatibility check\r", "-\t\t\tcompatible[compatibleIndex++] = methodBinding;\r", "+\t\t\tcandidates[candidatesCount++] = methodBinding;\r", "-\tif (compatibleIndex == 1)\r", "-\t\treturn compatible[0]; // have not checked visibility\r", "-\tif (compatibleIndex == 0)\r", "+\tif (candidatesCount == 1)\r", "+\t\treturn candidates[0]; // have not checked visibility\r", "+\tif (candidatesCount == 0) { // try to find a close match when the parameter order is wrong or missing some parameters\r", "+\t\tint argLength = argumentTypes.length;\r", "+\t\tnextMethod : for (int i = 0; i < foundSize; i++) {\r", "+\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);\r", "+\t\t\tTypeBinding[] params = methodBinding.parameters;\r", "+\t\t\tint paramLength = params.length;\r", "+\t\t\tnextArg: for (int a = 0; a < argLength; a++) {\r", "+\t\t\t\tTypeBinding arg = argumentTypes[a];\r", "+\t\t\t\tfor (int p = 0; p < paramLength; p++)\r", "+\t\t\t\t\tif (params[p] == arg)\r", "+\t\t\t\t\t\tcontinue nextArg;\r", "+\t\t\t\tcontinue nextMethod;\r", "+\t\t\t}\r", "+\t\t\treturn methodBinding;\r", "+\t\t}\r", "+\t}\r", "-\tMethodBinding[] visible = new MethodBinding[compatibleIndex];\r", "-\tint visibleIndex = 0;\r", "-\tfor (int i = 0; i < compatibleIndex; i++) {\r", "-\t\tMethodBinding methodBinding = compatible[i];\r", "-\t\tif (canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this))\r", "-\t\t\tvisible[visibleIndex++] = methodBinding;\r", "+\t// visibility check\r", "+\tint visiblesCount = 0;\r", "+\tfor (int i = 0; i < candidatesCount; i++) {\r", "+\t\tMethodBinding methodBinding = candidates[i];\r", "+\t\tif (canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this)){\r", "+\t\t\tif (visiblesCount != i) {\r", "+\t\t\t\tcandidates[i] = null;\r", "+\t\t\t\tcandidates[visiblesCount] = methodBinding;\r", "+\t\t\t}\r", "+\t\t\tvisiblesCount++;\r", "+\t\t}\r", "-\tif (visibleIndex == 1){\r", "-\t\treturn visible[0];\r", "+\tif (visiblesCount == 1) {\r", "+\t\t//compilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);\r", "+\t\treturn candidates[0];\r", "-\tif (visibleIndex == 0)\r", "-\t\treturn new ProblemMethodBinding(compatible[0].selector, argumentTypes, compatible[0].declaringClass, NotVisible);\r", "-\tif (visible[0].declaringClass.isClass())\r", "-\t\treturn mostSpecificClassMethodBinding(visible, visibleIndex);\r", "-\telse\r", "-\t\treturn mostSpecificInterfaceMethodBinding(visible, visibleIndex);\r", "+\tif (visiblesCount == 0){\r", "+\t\treturn new ProblemMethodBinding(\r", "+\t\t\tcandidates[0].selector,\r", "+\t\t\targumentTypes,\r", "+\t\t\tcandidates[0].declaringClass,\r", "+\t\t\tNotVisible);\r", "+\t}\r", "+\tif (candidates[0].declaringClass.isClass()) {\r", "+\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount);\r", "+\t} else {\r", "+\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount);\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66173712a6ad83564b1af0d9ba01522b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "4977ef90a9cbab898d33f6e3ba736939d7ac7a85", "commitAfterChange": "ed3a0c0705f2be20be3aaf856f81a3803e4ac341", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " public MethodBinding getMethodBinding(MethodPattern methodPattern)", "signatureAfterChange": " public MethodBinding getMethodBinding(MethodPattern methodPattern)", "diff": ["+    MethodBinding methodBinding = getMethodBinding0(methodPattern);", "+    if (methodBinding != null)", "+    \treturn methodBinding; // known to be valid.", "+    // special handling for methods of anonymous/local types. Since these cannot be looked up in the environment the usual way ...", "+    if (methodPattern.focus instanceof SourceMethod) {", "+    \tchar[] typeName = PatternLocator.qualifiedPattern(methodPattern.declaringSimpleName, methodPattern.declaringQualification);", "+    \tif (CharOperation.indexOf(IIndexConstants.ONE_STAR, typeName, true) >= 0) { // See org.eclipse.jdt.core.search.SearchPattern.enclosingTypeNames(IType)", "+    \t\tIType type = methodPattern.declaringType;", "+    \t\tIType enclosingType = type.getDeclaringType();", "+    \t\twhile (enclosingType != null) {", "+    \t\t\ttype = enclosingType;", "+    \t\t\tenclosingType = type.getDeclaringType();", "+    \t\t}", "+    \t\ttypeName = type.getFullyQualifiedName().toCharArray();", "+    \t\tTypeBinding declaringTypeBinding = getType(typeName, typeName);", "+    \t\tif (declaringTypeBinding instanceof SourceTypeBinding) {", "+    \t\t\tSourceTypeBinding sourceTypeBinding = ((SourceTypeBinding) declaringTypeBinding);", "+    \t\t\tClassScope skope = sourceTypeBinding.scope;", "+    \t\t\tif (skope != null) {", "+    \t\t\t\tCompilationUnitDeclaration unit = skope.referenceCompilationUnit();", "+    \t\t\t\tif (unit != null) {", "+    \t\t\t\t\tAbstractMethodDeclaration amd = new ASTNodeFinder(unit).findMethod((IMethod) methodPattern.focus);", "+    \t\t\t\t\tif (amd != null && amd.binding != null && amd.binding.isValidBinding()) {", "+    \t\t\t\t\t\tthis.bindings.put(methodPattern, amd.binding);", "+    \t\t\t\t\t\treturn amd.binding;", "+    \t\t\t\t\t}", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t}", "+    \t}", "+    }", "+\treturn null;", "+}"]}], "num": 34381}