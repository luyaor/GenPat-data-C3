{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "46f783c30ba493cbfefe5e6f1d66be38", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "41eded65e4d8c560ea70069e66be440d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "25a0c02d6979e76d70832f78f8eb60bd371c0ad1", "commitAfterChange": "1b6413921860c74cfa469f859f6fc627d6400adf", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["+\t */", "-\t\tsuper.resolveType(blockScope);", "-\t\tthis.scope = new MethodScope(blockScope, this, blockScope.methodScope().isStatic);", "-\t\tthis.binding = this.scope.createAnonymousMethodBinding(this);", "-\t\tif (this.functionalInterfaceType.isValidBinding()) {", "-\t\t\tthis.binding.thrownExceptions = computeKosherThrowables();", "-\t\t\t// Resolve arguments, validate signature ...", "-\t\t\tif (this.arguments != null && this.singleAbstractMethod != null) {", "-\t\t\t\tint parameterCount = this.singleAbstractMethod.parameters != null ? this.singleAbstractMethod.parameters.length : 0;", "-\t\t\t\tint lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;", "+\t\t", "+\t\tsuper.resolveType(blockScope); // compute & capture interface function descriptor in singleAbstractMethod.", "+\t\t", "+\t\tfinal boolean argumentsTypeElided = argumentsTypeElided();", "+\t\tfinal boolean haveDescriptor = this.singleAbstractMethod != null;", "+\t\t", "+\t\tif (!haveDescriptor && argumentsTypeElided) ", "+\t\t\treturn null; // FUBAR, bail out...", "-\t\t\t\tif (parameterCount == lambdaArgumentCount) {", "-\t\t\t\t\tfor (int i = 0, length = this.arguments.length; i < length; i++) {", "-\t\t\t\t\t\tArgument argument = this.arguments[i];", "-\t\t\t\t\t\tif (argument.type != null) {", "-\t\t\t\t\t\t\targument.resolve(this.scope); // TODO: Check it!", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\targument.bind(this.scope, this.singleAbstractMethod.parameters[i], false);", "-\t\t\t\t\t\t}", "+\t\tthis.scope = new MethodScope(blockScope, this, blockScope.methodScope().isStatic);", "+\t\t", "+\t\tthis.binding = new MethodBinding(ClassFileConstants.AccPublic | ExtraCompilerModifiers.AccUnresolved,", "+\t\t\t\t\t\t\thaveDescriptor ? this.singleAbstractMethod.selector : TypeConstants.ANONYMOUS_METHOD, ", "+\t\t\t\t\t\t\thaveDescriptor ? this.singleAbstractMethod.returnType : null, ", "+\t\t\t\t\t\t\tBinding.NO_PARAMETERS, // for now. ", "+\t\t\t\t\t\t\thaveDescriptor ? this.singleAbstractMethod.thrownExceptions : Binding.NO_EXCEPTIONS, ", "+\t\t\t\t\t\t\tnull); // declaring class.", "+\t\tthis.binding.typeVariables = Binding.NO_TYPE_VARIABLES; // descriptor may have type variables, but they are useless in lambda and lambda cannot be generic.", "+\t\t", "+\t\tif (haveDescriptor) {", "+\t\t\tint descriptorParameterCount = this.singleAbstractMethod.parameters.length;", "+\t\t\tint lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;", "+            if (descriptorParameterCount != lambdaArgumentCount) {", "+            \tthis.scope.problemReporter().lambdaSignatureMismatched(this);", "+            \tif (argumentsTypeElided) ", "+            \t\treturn null; // FUBAR, bail out ...", "+            }", "+\t\t}", "+\t\t", "+\t\tboolean buggyArguments = false;", "+\t\tint length = this.arguments == null ? 0 : this.arguments.length;", "+\t\tTypeBinding[] newParameters = new TypeBinding[length];", "+", "+\t\tAnnotationBinding [][] parameterAnnotations = null;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tArgument argument = this.arguments[i];", "+\t\t\tif (argument.isVarArgs()) {", "+\t\t\t\tif (i == length - 1) {", "+\t\t\t\t\tthis.binding.modifiers |= ClassFileConstants.AccVarargs;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.scope.problemReporter().illegalVarargInLambda(argument);", "+\t\t\t\t\tbuggyArguments = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (argument.annotations != null) {", "+\t\t\t\tthis.binding.tagBits |= TagBits.HasParameterAnnotations;", "+\t\t\t\tif (parameterAnnotations == null) {", "+\t\t\t\t\tparameterAnnotations = new AnnotationBinding[length][];", "+\t\t\t\t\tfor (int j = 0; j < i; j++) {", "+\t\t\t\t\t\tparameterAnnotations[j] = Binding.NO_ANNOTATIONS;", "-\t\t\t\t} /* TODO: else complain */", "+\t\t\t\t}", "+\t\t\t\tparameterAnnotations[i] = argument.binding.getAnnotations();", "+\t\t\t} else if (parameterAnnotations != null) {", "+\t\t\t\tparameterAnnotations[i] = Binding.NO_ANNOTATIONS;", "+\t\t\t}", "+\t\t\t", "+\t\t\tTypeBinding parameterType;", "+\t\t\tfinal TypeBinding expectedParameterType = this.singleAbstractMethod.parameters[i];", "+\t\t\tparameterType = argumentsTypeElided ? expectedParameterType : argument.type.resolveType(this.scope, true /* check bounds*/);", "+\t\t\tif (parameterType == null) {", "+\t\t\t\tbuggyArguments = true;", "+\t\t\t} else if (parameterType == TypeBinding.VOID) {", "+\t\t\t\tthis.scope.problemReporter().argumentTypeCannotBeVoid(this, argument);", "+\t\t\t\tbuggyArguments = true;", "+\t\t\t} else {", "+\t\t\t\tif (!parameterType.isValidBinding()) {", "+\t\t\t\t\tthis.binding.tagBits |= TagBits.HasUnresolvedArguments;", "+\t\t\t\t}", "+\t\t\t\tif ((parameterType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\tthis.binding.tagBits |= TagBits.HasMissingType;", "+\t\t\t\t}", "+\t\t\t\tif (haveDescriptor && parameterType != expectedParameterType) {", "+\t\t\t\t\tthis.scope.problemReporter().lambdaParameterTypeMismatched(argument, argument.type, expectedParameterType);", "+\t\t\t\t}", "+", "+\t\t\t\tTypeBinding leafType = parameterType.leafComponentType();", "+\t\t\t\tif (leafType instanceof ReferenceBinding && (((ReferenceBinding) leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)", "+\t\t\t\t\tthis.binding.modifiers |= ExtraCompilerModifiers.AccGenericSignature;", "+\t\t\t\tnewParameters[i] = parameterType;", "+\t\t\t\targument.bind(this.scope, parameterType, false);", "+\t\t// only assign parameters if no problems are found", "+\t\tif (!buggyArguments) {", "+\t\t\tthis.binding.parameters = newParameters;", "+\t\t\tif (parameterAnnotations != null)", "+\t\t\t\tthis.binding.setParameterAnnotations(parameterAnnotations);", "+\t\t}", "+\t", "+\t\tif (!argumentsTypeElided && this.binding.isVarargs()) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=337795", "+\t\t\tif (!this.binding.parameters[this.binding.parameters.length - 1].isReifiable()) {", "+\t\t\t\tthis.scope.problemReporter().possibleHeapPollutionFromVararg(this.arguments[this.arguments.length - 1]);", "+\t\t\t}", "+\t\t}", "+", "+\t\tReferenceBinding [] exceptions = this.binding.thrownExceptions;", "+\t\tlength = exceptions.length;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tReferenceBinding exception = exceptions[i];", "+\t\t\tif ((exception.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\tthis.binding.tagBits |= TagBits.HasMissingType;", "+\t\t\t}", "+\t\t\tthis.binding.modifiers |= (exception.modifiers & ExtraCompilerModifiers.AccGenericSignature);", "+\t\t}", "+\t\t", "+\t\tTypeBinding returnType = this.binding.returnType;", "+\t\tif ((returnType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\tthis.binding.tagBits |= TagBits.HasMissingType;", "+\t\t}", "+\t\tTypeBinding leafType = returnType.leafComponentType();", "+\t\tif (leafType instanceof ReferenceBinding && (((ReferenceBinding) leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)", "+\t\t\tthis.binding.modifiers |= ExtraCompilerModifiers.AccGenericSignature;", "+", "+\t\tthis.binding.modifiers &= ~ExtraCompilerModifiers.AccUnresolved;", "+\t\t", "-\t\t\tif (this.functionalInterfaceType.isValidBinding()) {", "-\t\t\t\texpression.setExpectedType(this.singleAbstractMethod.returnType); // chain expected type for any nested lambdas.", "-\t\t\t\t/* TypeBinding expressionType = */ expression.resolveType(this.scope);", "-\t\t\t\t// TODO: checkExpressionResult(singleAbstractMethod.returnType, expression, expressionType);", "-\t\t\t}", "+\t\t\tnew ReturnStatement(expression, expression.sourceStart, expression.sourceEnd, true).resolve(this.scope); // :-) ;-)", "-\t\treturn this.functionalInterfaceType;", "+\t\treturn this.resolvedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3fc3c606bbcba3f200ab288e38130af", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java", "commitBeforeChange": "8ad7ea4a3e807d9d57eeeda9a3a7bd6598dfbdb1", "commitAfterChange": "b7a41e13e2a80300225883c3cc5ff3990406ce0a", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope, ReferenceBinding enclosingType, boolean checkBounds)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope, ReferenceBinding enclosingType, boolean checkBounds)", "diff": ["+\t\t\t\t\t\tcase ProblemReasons.InheritedNameHidesEnclosingName :", "-\t\t} ", "+\t\t}", "+\t\tboolean hasGenericError = false;", "+\t\tReferenceBinding currentType;", "-\t\t\tif (!(this.resolvedType.isValidBinding())) {", "+\t\t\tif (this.resolvedType.isValidBinding()) {", "+\t\t\t\tcurrentType = (ReferenceBinding) this.resolvedType;", "+\t\t\t} else {", "+\t\t\t\thasGenericError = true;", "-\t\t\t\t// be resilient, still attempt resolving arguments", "-\t\t\t\tboolean isClassScope = scope.kind == Scope.CLASS_SCOPE;", "-\t\t\t\tint argLength = this.typeArguments.length;", "-\t\t\t\tfor (int i = 0; i < argLength; i++) {", "-\t\t\t\t\tTypeReference typeArgument = this.typeArguments[i];", "-\t\t\t\t\tif (isClassScope) {", "-\t\t\t\t\t\ttypeArgument.resolveType((ClassScope) scope);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\ttypeArgument.resolveType((BlockScope) scope, checkBounds);", "+\t\t\t\tswitch (this.resolvedType.problemId()) {", "+\t\t\t\t\tcase ProblemReasons.NotFound :", "+\t\t\t\t\tcase ProblemReasons.NotVisible :", "+\t\t\t\t\tcase ProblemReasons.InheritedNameHidesEnclosingName :", "+\t\t\t\t\t\tTypeBinding type = this.resolvedType.closestMatch();", "+\t\t\t\t\t\tif (type instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\tcurrentType = (ReferenceBinding) type;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// fallthrough - unable to complete type binding, but still resolve type arguments", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\tboolean isClassScope = scope.kind == Scope.CLASS_SCOPE;", "+\t\t\t\t\tint argLength = this.typeArguments.length;", "+\t\t\t\t\tfor (int i = 0; i < argLength; i++) {", "+\t\t\t\t\t\tTypeReference typeArgument = this.typeArguments[i];", "+\t\t\t\t\t\tif (isClassScope) {", "+\t\t\t\t\t\t\ttypeArgument.resolveType((ClassScope) scope);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\ttypeArgument.resolveType((BlockScope) scope, checkBounds);", "+\t\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\treturn null;", "+\t\t\t\t\treturn null;", "+\t\t\t\t}\t\t\t", "+\t\t\t\t// be resilient, still attempt resolving arguments", "-\t\t\tenclosingType = this.resolvedType.enclosingType(); // if member type", "-\t\t\tif (enclosingType != null && (enclosingType.isGenericType() || enclosingType.isParameterizedType())) {", "-\t\t\t\tReferenceBinding referenceType = (ReferenceBinding) this.resolvedType;", "-\t\t\t\tenclosingType = referenceType.isStatic()", "+\t\t\tenclosingType = currentType.enclosingType(); // if member type", "+\t\t\tif (enclosingType != null) {", "+\t\t\t\tenclosingType = currentType.isStatic()", "-\t\t\t\tthis.resolvedType = scope.environment().createParameterizedType((ReferenceBinding) referenceType.erasure(), null /* no arg */, enclosingType);", "+\t\t\t\tcurrentType = scope.environment().createParameterizedType((ReferenceBinding) currentType.erasure(), null /* no arg */, enclosingType);", "-\t\t\tthis.resolvedType = scope.getMemberType(token, enclosingType);", "+\t\t\tthis.resolvedType = currentType = scope.getMemberType(token, enclosingType);", "-\t\t\t\tscope.problemReporter().invalidEnclosingType(this, this.resolvedType, enclosingType);", "+\t\t\t\thasGenericError = true;", "+\t\t\t\tscope.problemReporter().invalidEnclosingType(this, currentType, enclosingType);", "-\t\t\tif (isTypeUseDeprecated(this.resolvedType, scope))", "-\t\t\t\tscope.problemReporter().deprecatedType(this.resolvedType, this);", "+\t\t\tif (isTypeUseDeprecated(currentType, scope))", "+\t\t\t\tscope.problemReporter().deprecatedType(currentType, this);", "-\t\tReferenceBinding currentType = (ReferenceBinding) this.resolvedType;", "+\t\tReferenceBinding currentErasure = (ReferenceBinding)currentType.erasure();", "-\t\t\t\t? typeArgument.resolveTypeArgument((ClassScope) scope, currentType, i)", "-\t\t\t\t: typeArgument.resolveTypeArgument((BlockScope) scope, currentType, i);", "+\t\t\t\t? typeArgument.resolveTypeArgument((ClassScope) scope, currentErasure, i)", "+\t\t\t\t: typeArgument.resolveTypeArgument((BlockScope) scope, currentErasure, i);", "-\t\tif (argHasError) return null;", "+\t\tif (argHasError) {", "+\t\t\treturn null;", "+\t\t}", "-\t\t\tif (((ClassScope) scope).detectHierarchyCycle(currentType, this))", "+\t\t\tif (((ClassScope) scope).detectHierarchyCycle(currentErasure, this))", "-\t\tTypeVariableBinding[] typeVariables = currentType.typeVariables();", "-\t\tif (typeVariables == Binding.NO_TYPE_VARIABLES) { // check generic", "-\t\t\tif (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) { // below 1.5, already reported as syntax error", "-\t\t\t\tscope.problemReporter().nonGenericTypeCannotBeParameterized(0, this, currentType, argTypes);", "-\t\t\t\treturn null;", "+\t\tTypeVariableBinding[] typeVariables = currentErasure.typeVariables();", "+\t\tif (typeVariables == Binding.NO_TYPE_VARIABLES) { // non generic invoked with arguments", "+\t\t\tboolean isCompliant15 = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\t\tif ((currentErasure.tagBits & TagBits.HasMissingType) == 0) {", "+\t\t\t\tif (isCompliant15) { // below 1.5, already reported as syntax error", "+\t\t\t\t\tthis.resolvedType = currentType;", "+\t\t\t\t\tscope.problemReporter().nonGenericTypeCannotBeParameterized(0, this, currentType, argTypes);", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "-\t\t\tthis.resolvedType = currentType;", "-\t\t\t// array type ?", "-\t\t\tif (this.dimensions > 0) {", "-\t\t\t\tif (dimensions > 255) ", "-\t\t\t\t\tscope.problemReporter().tooManyDimensions(this);", "-\t\t\t\tthis.resolvedType = scope.createArrayType(this.resolvedType, dimensions);", "-\t\t\t}\t\t\t", "-\t\t\treturn this.resolvedType;", "+\t\t\t// resilience do not rebuild a parameterized type unless compliance is allowing it", "+\t\t\tif (!isCompliant15) {", "+\t\t\t\t// array type ?", "+\t\t\t\tTypeBinding type = currentType;", "+\t\t\t\tif (this.dimensions > 0) {", "+\t\t\t\t\tif (this.dimensions > 255) ", "+\t\t\t\t\t\tscope.problemReporter().tooManyDimensions(this);", "+\t\t\t\t\ttype = scope.createArrayType(type, dimensions);", "+\t\t\t\t}\t\t\t", "+\t\t\t\tif (hasGenericError) ", "+\t\t\t\t\treturn type;", "+\t\t\t\treturn this.resolvedType = type;", "+\t\t\t}", "+\t\t\t// if missing generic type, and compliance >= 1.5, then will rebuild a parameterized binding", "-\t\t\t\t\t\tthis, scope.environment().createRawType((ReferenceBinding)currentType.erasure(), actualEnclosing), argTypes);", "+\t\t\t\t\t\tthis, scope.environment().createRawType(currentErasure, actualEnclosing), argTypes);", "-    \tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), argTypes, enclosingType);", "+    \tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(currentErasure, argTypes, enclosingType);", "-\t\tthis.resolvedType = parameterizedType;", "-\t\tif (isTypeUseDeprecated(this.resolvedType, scope))", "-\t\t\treportDeprecatedType(this.resolvedType, scope);", "+\t\tif (isTypeUseDeprecated(parameterizedType, scope))", "+\t\t\treportDeprecatedType(parameterizedType, scope);", "+\t\tTypeBinding type = parameterizedType;", "-\t\t\tif (dimensions > 255)", "+\t\t\tif (this.dimensions > 255) ", "-\t\t\tthis.resolvedType = scope.createArrayType(this.resolvedType, dimensions);", "+\t\t\ttype = scope.createArrayType(type, dimensions);", "-\t\treturn this.resolvedType;", "+\t\tif (hasGenericError) {", "+\t\t\treturn type;", "+\t\t}", "+\t\treturn this.resolvedType = type;\t\t"]}], "num": 38266}