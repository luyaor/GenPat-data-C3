{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "efb2b676f728b71cc899403c2679d8f3", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "615f31e64588cfcb692430d1e624469f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "26e96a017b590b444a246c8fba814dc78fd85b77", "commitAfterChange": "80351fb8a54757084b1b27c49cb8b0584bf78834", "methodNumberBeforeChange": 77, "methodNumberAfterChange": 77, "signatureBeforeChange": "  \tpublic ReturnStatement convert(org.eclipse.jdt.internal.compiler.ast.ReturnStatement statement)", "signatureAfterChange": "  \tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.ReferenceExpression reference)", "diff": ["+", "+\tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.ReferenceExpression reference) {", "+\t\tif (this.ast.apiLevel < AST.JLS8) {", "+\t\t\treturn createFakeNullLiteral(reference);", "+\t\t}", "+\t\tExpression result = null;", "+\t\torg.eclipse.jdt.internal.compiler.ast.Expression lhs = reference.lhs;", "+\t\torg.eclipse.jdt.internal.compiler.ast.TypeReference[] arguments = reference.typeArguments;", "+\t\tint start = arguments != null && arguments.length > 0 ? arguments[arguments.length - 1].sourceEnd + 1 : reference.lhs.sourceEnd + 1;", "+\t\tfinal SimpleName name = new SimpleName(this.ast);", "+\t\tretrieveIdentifierAndSetPositions(start, reference.sourceEnd, name);", "+\t\tname.internalSetIdentifier(new String(reference.selector));", "+\t\tif (this.resolveBindings) {", "+\t\t\trecordNodes(name, reference);", "+\t\t}", "+\t\tList typeArguments = null;", "+\t\tif (name.getStartPosition() < start) {// check for new ", "+\t\t\tretrieveInitAndSetPositions(start, reference.sourceEnd, name);", "+\t\t\tif (!name.getIdentifier().equals(\"<init>\")) { //$NON-NLS-1$", "+\t\t\t\tNullLiteral nullLiteral = new NullLiteral(this.ast);", "+\t\t\t\tnullLiteral.setFlags(nullLiteral.getFlags() | ASTNode.MALFORMED);", "+\t\t\t\tresult = nullLiteral;", "+\t\t\t} else {", "+\t\t\t\tCreationReference creationReference = new CreationReference(this.ast);", "+\t\t\t\tcreationReference.setExpression(convert(lhs));", "+\t\t\t\ttypeArguments = creationReference.typeArguments();", "+\t\t\t\tresult = creationReference;", "+\t\t\t}", "+\t\t} else if (lhs instanceof TypeReference) {", "+\t\t\tTypeMethodReference typeMethodReference = new TypeMethodReference(this.ast);", "+\t\t\ttypeMethodReference.setType(convertType((TypeReference) lhs));", "+\t\t\ttypeMethodReference.setName(name);", "+\t\t\ttypeArguments = typeMethodReference.typeArguments();", "+\t\t\tresult = typeMethodReference;", "+\t\t} else if (lhs instanceof SuperReference) {", "+\t\t\tSuperMethodReference superMethodReference = new SuperMethodReference(this.ast);", "+\t\t\tsuperMethodReference.setName(name);", "+\t\t\ttypeArguments = superMethodReference.typeArguments();", "+\t\t\tresult = superMethodReference;", "+\t\t} else if (lhs instanceof QualifiedSuperReference) {", "+\t\t\tSuperMethodReference superMethodReference = new SuperMethodReference(this.ast);", "+\t\t\tsuperMethodReference.setQualifier(convert((QualifiedSuperReference)lhs));", "+\t\t\tsuperMethodReference.setName(name);", "+\t\t\ttypeArguments = superMethodReference.typeArguments();", "+\t\t\tresult = superMethodReference;", "+\t\t} else {", "+\t\t\tExpressionMethodReference expressionMethodReference = new ExpressionMethodReference(this.ast);", "+\t\t\texpressionMethodReference.setExpression(convert(lhs));", "+\t\t\ttypeArguments = expressionMethodReference.typeArguments();", "+\t\t\texpressionMethodReference.setName(name);", "+\t\t\tresult = expressionMethodReference;", "+\t\t}", "+\t\tif (typeArguments != null && arguments != null) {", "+\t\t\tint argumentsLength = arguments.length;", "+\t\t\tfor (int i = 0; i < argumentsLength; i++) {", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeReference argument = arguments[i];", "+\t\t\t\ttypeArguments.add(convertType(argument));", "+\t\t\t}", "+\t\t}", "+\t\tif (this.resolveBindings) {", "+\t\t\trecordNodes(result, reference);", "+\t\t}", "+\t\tint sourceStart = reference.sourceStart; ", "+\t\tresult.setSourceRange(sourceStart, reference.sourceEnd - sourceStart + 1);", "+\t\treturn result;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e0dbad2da6f5213b7135f9133d637dc0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "45797eb81fedd425de5e79dad7220a380a5e9acc", "commitAfterChange": "ef73d5c5809aab39b3a874478bfc9cb39129fe3f", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic void configure(String[] argv) throws InvalidInputException", "signatureAfterChange": " \tpublic void configure(String[] argv) throws InvalidInputException", "diff": ["+\t\tfinal int InsideBootClasspath = 128;", "+\t\tString[] bootclasspaths = null;", "+\t\tint bootclasspathCount = 0;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (currentArg.equals(\"-bootclasspath\")) {//$NON-NLS-1$", "+\t\t\t\tif (bootclasspathCount > 0)", "+\t\t\t\t\tthrow new InvalidInputException(", "+\t\t\t\t\t\tMain.bind(\"configure.duplicateBootClasspath\", currentArg)); //$NON-NLS-1$", "+\t\t\t\tbootclasspaths = new String[DEFAULT_SIZE_CLASSPATH];", "+\t\t\t\tmode = InsideBootClasspath;", "+\t\t\tif (mode == InsideBootClasspath) {", "+\t\t\t\tStringTokenizer tokenizer = new StringTokenizer(currentArg, File.pathSeparator);", "+\t\t\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\t\t\tint length;", "+\t\t\t\t\tif ((length = bootclasspaths.length) <= bootclasspathCount) {", "+\t\t\t\t\t\tSystem.arraycopy(", "+\t\t\t\t\t\t\tbootclasspaths,", "+\t\t\t\t\t\t\t0,", "+\t\t\t\t\t\t\t(bootclasspaths = new String[length * 2]),", "+\t\t\t\t\t\t\t0,", "+\t\t\t\t\t\t\tlength);", "+\t\t\t\t\t}", "+\t\t\t\t\tbootclasspaths[bootclasspathCount++] = tokenizer.nextToken();", "+\t\t\t\t}", "+\t\t\t\tmode = Default;", "+\t\t\t\tcontinue;", "+\t\t\t}\t\t\t", "-\t\t\tString classProp = System.getProperty(\"DEFAULT_CLASSPATH\"); //$NON-NLS-1$", "+\t\t\t// no user classpath specified.", "+\t\t\tString classProp = System.getProperty(\"java.class.path\"); //$NON-NLS-1$", "+\t\t", "+\t\tif (bootclasspathCount == 0) {", "+\t\t\t/* no bootclasspath specified", "+\t\t\t * we can try to retrieve the default librairies of the VM used to run", "+\t\t\t * the batch compiler", "+\t\t\t */", "+\t\t\t String javaversion = System.getProperty(\"java.version\");//$NON-NLS-1$", "+\t\t\t if (javaversion != null && javaversion.equalsIgnoreCase(\"1.1.8\")) { //$NON-NLS-1$", "+\t\t\t\tout.println(Main.bind(\"configure.requiresJDK1.2orAbove\")); //$NON-NLS-1$", "+\t\t\t\tproceed = false;", "+\t\t\t\treturn;", "+\t\t\t } else {", "+\t\t\t\t String javaVMName = System.getProperty(\"java.vm.name\");//$NON-NLS-1$", "+\t\t\t\t if (javaVMName != null && javaVMName.equalsIgnoreCase(\"J9\")) {//$NON-NLS-1$", "+\t\t\t\t \t/*", "+\t\t\t\t \t * Handle J9 VM settings: Retrieve jclMax by default", "+\t\t\t\t \t */", "+\t\t\t\t \t String javaHome = System.getProperty(\"java.home\");//$NON-NLS-1$", "+\t\t\t\t \t if (javaHome != null) {", "+\t\t\t\t \t \tFile javaHomeFile = new File(javaHome);", "+\t\t\t\t \t \tif (javaHomeFile.exists()) {", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\tjavaHomeFile = new File(javaHomeFile.getCanonicalPath());", "+\t\t\t\t\t\t\t\tFile defaultLibrary = new File(javaHomeFile, \"lib\" + File.separator + \"jclMax\" +  File.separator + \"classes.zip\"); //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$", "+\t\t\t\t\t\t\t\tFile locales = new File(javaHomeFile, \"lib\" + File.separator + \"jclMax\" +  File.separator + \"locale.zip\"); //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$", "+\t\t\t\t\t\t\t\tFile charconv = new File(javaHomeFile, \"lib\" +  File.separator + \"charconv.zip\"); //$NON-NLS-1$//$NON-NLS-2$", "+\t\t\t\t\t\t\t\t/* we don't need to check if defaultLibrary exists. This is done later when the user", "+\t\t\t\t\t\t\t\t * classpath and the bootclasspath are merged. ", "+\t\t\t\t\t\t\t\t */", "+\t\t\t\t\t\t\t\tbootclasspaths = new String[] {", "+\t\t\t\t\t\t\t\t\tdefaultLibrary.getAbsolutePath(),", "+\t\t\t\t\t\t\t\t\tlocales.getAbsolutePath(),", "+\t\t\t\t\t\t\t\t\tcharconv.getAbsolutePath()};", "+\t\t\t\t\t\t\t\tbootclasspathCount = 3;", "+\t\t\t\t\t\t\t} catch (IOException e) {", "+\t\t\t\t\t\t\t}", "+\t\t\t\t \t \t}", "+\t\t\t\t \t }", "+\t\t\t\t } else {", "+\t\t\t\t \t/*", "+\t\t\t\t \t * Handle >= JDK 1.2.2 settings: retrieve rt.jar", "+\t\t\t\t \t */", "+\t\t\t\t \t String javaHome = System.getProperty(\"java.home\");//$NON-NLS-1$", "+\t\t\t\t \t if (javaHome != null) {", "+\t\t\t\t \t \tFile javaHomeFile = new File(javaHome);", "+\t\t\t\t \t \tif (javaHomeFile.exists()) {", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\tjavaHomeFile = new File(javaHomeFile.getCanonicalPath());", "+\t\t\t\t\t\t\t\t// add all jars in the lib subdirectory", "+\t\t\t\t\t\t\t\tFile[] systemLibrariesJars = getFilesFrom(new File(javaHomeFile, \"lib\"), \".jar\");//$NON-NLS-1$//$NON-NLS-2$", "+\t\t\t\t\t\t\t\tint length = systemLibrariesJars.length;", "+\t\t\t\t\t\t\t\tbootclasspaths = new String[length];", "+\t\t\t\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t/* we don't need to check if this file exists. This is done later when the user", "+\t\t\t\t\t\t\t\t\t * classpath and the bootclasspath are merged. ", "+\t\t\t\t\t\t\t\t\t */", "+\t\t\t\t\t\t\t\t\tbootclasspaths[bootclasspathCount++] = systemLibrariesJars[i].getAbsolutePath();", "+\t\t\t\t\t\t\t\t} ", "+\t\t\t\t\t\t\t} catch (IOException e) {", "+\t\t\t\t\t\t\t}", "+\t\t\t\t \t \t}", "+\t\t\t\t \t }", "+\t\t\t\t }", "+\t\t\t }", "+\t\t}", "-\t\tif (classpaths == null)", "+\t\tif (classpaths == null) {", "+\t\t}", "+\t\t/* ", "+\t\t * We put the bootclasspath at the beginning of the classpath entries", "+\t\t */", "+\t\tString[] newclasspaths = null;", "+\t\tif ((pathCount + bootclasspathCount) != classpaths.length) {", "+\t\t\tnewclasspaths = new String[pathCount + bootclasspathCount];", "+\t\t} else {", "+\t\t\tnewclasspaths = classpaths;", "+\t\t}", "-\t\t\t(classpaths = new String[pathCount]),", "-\t\t\t0,", "+\t\t\tnewclasspaths,", "+\t\t\tbootclasspathCount,", "+", "+\t\tif (bootclasspathCount != 0) {", "+\t\t\tSystem.arraycopy(", "+\t\t\t\tbootclasspaths,", "+\t\t\t\t0,", "+\t\t\t\tnewclasspaths,", "+\t\t\t\t0,", "+\t\t\t\tbootclasspathCount);", "+\t\t}", "+\t\tclasspaths = newclasspaths;", "-\t\t\tif (!file.exists()) // signal missing classpath entry file", "+\t\t\tif (!file.exists()) { // signal missing classpath entry file", "+\t\t\t} /* else {", "+\t\t\t\tout.println(classpaths[i]);", "+\t\t\t}*/"]}], "num": 66755}