{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "653191712a22ffda2ceedcbc5fc6ff06", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9468d08add33a8393ae553ae610b18fe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "6214978e7f95991a58a94c92ca3aaa2f1fb276e7", "commitAfterChange": "e51ee3261ac6e39dfe94f9022da64a162a2b4dbc", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " public MethodBinding getHighestOverridenMethod()", "signatureAfterChange": " public MethodBinding getHighestOverridenMethod(LookupEnvironment environment)", "diff": ["-public MethodBinding getHighestOverridenMethod() {", "+public MethodBinding getHighestOverridenMethod(LookupEnvironment environment) {", "+    MethodVerifier verifier = environment.methodVerifier();", "-\t\tMethodBinding superMethod = currentType.getExactMethod(this.selector, this.parameters, null);", "-\t\tif (superMethod != null) {", "-\t\t\tbestMethod = superMethod;", "+\t\tMethodBinding[] superMethods = currentType.getMethods(this.selector);", "+\t\tfor (int i = 0, length = superMethods.length; i < length; i++) {", "+\t\t\tif (verifier.doesMethodOverride(this, superMethods[i])) {", "+\t\t\t\tbestMethod = superMethods[i];", "+\t\t\t\tbreak;", "+\t\t\t}", "-\t\tMethodBinding superMethod = currentType.getExactMethod(this.selector, this.parameters, null);", "-\t\tif (superMethod != null) {", "-\t\t\tbestMethod = superMethod;", "-\t\t}\t\t", "+\t\tMethodBinding[] superMethods = currentType.getMethods(this.selector);", "+\t\tfor (int j = 0, length = superMethods.length; j < length; j++) {", "+\t\t\tMethodBinding superMethod = superMethods[j];", "+\t\t\tif (verifier.doesMethodOverride(this, superMethod)) {", "+\t\t\t\tTypeBinding bestReturnType = bestMethod.returnType;", "+\t\t\t\tif (bestReturnType == superMethod.returnType", "+\t\t\t\t\t\t|| bestMethod.returnType.findSuperTypeOriginatingFrom(superMethod.returnType) != null) {", "+\t\t\t\t\tbestMethod = superMethod;", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cca1e28bdf7df6c97098fc95b4e3b2a9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "607ff419d62fc0f91055d1c2d16685459d9fa667", "commitAfterChange": "0cad9a75d8029433899afbdf88cbb39e8dd0618a", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " void checkPackagePrivateAbstractMethod(MethodBinding abstractMethod)", "signatureAfterChange": " void checkPackagePrivateAbstractMethod(MethodBinding abstractMethod)", "diff": ["+\t// check that the inherited abstract method (package private visibility) is implemented within the same package", "+\tPackageBinding necessaryPackage = abstractMethod.declaringClass.fPackage;", "+\tif (necessaryPackage == this.type.fPackage) return; // not a problem", "+", "-\t\tMethodBinding[] methods = superType.getMethods(selector);", "-\t\tnextMethod : for (int m = methods.length; --m >= 0;) {", "-\t\t\tMethodBinding method = methods[m];", "-\t\t\tif (!areReturnTypesEqual(method, abstractMethod) || !areParametersEqual(method, abstractMethod))", "-\t\t\t\tcontinue nextMethod;", "-\t\t\tif (method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())", "-\t\t\t\tcontinue nextMethod;", "-\t\t\tif (superType.fPackage == abstractMethod.declaringClass.fPackage) return; // found concrete implementation of abstract method in same package", "+\t\tif (necessaryPackage == superType.fPackage) {", "+\t\t\tMethodBinding[] methods = superType.getMethods(selector);", "+\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) {", "+\t\t\t\tMethodBinding method = methods[m];", "+\t\t\t\tif (method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())", "+\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\tif (doesMethodOverride(method, abstractMethod))", "+\t\t\t\t\treturn; // found concrete implementation of abstract method in same package", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d5535827acd636764b4824d25d6e0e35", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5a10f519c81ebdddb6bd4a37e304977f9bce5290", "commitAfterChange": "7b4e4fcfdd4d04f13dc930d8b751701d20daa4d2", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\t\t\t\t} else if (method.isStatic()) {", "+\t\t\t\t\t\t// detect collision between static import methods", "+\t\t\t\t\t\tif (method.declaringClass != method2.declaringClass && method.original().areParametersEqual(method2.original()))", "+\t\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t\t\t// its possible with 2 abstract methods that one does not inherit from the other", "+\t\t\t\t\t\t\t// its possible with 2 methods that one does not inherit from the other", "+\t\t\t\t\t\t\t// see cases in verify test #43", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "-\t\t\t\t\t\t\t\t\t\toriginal = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tif (superType != null) {", "+\t\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original.selector);", "+\t\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "+\t\t\t\t\t\t\t\t\t\t\toriginal = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original2.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "-\t\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tif (superType != null) {", "+\t\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original2.selector);", "+\t\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "+\t\t\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}"]}], "num": 63853}