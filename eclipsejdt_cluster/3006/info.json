{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f9b62dfefb2427d66fea489096acb364", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "072194160097b70f97ee395c3cf9cbf0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "2a6fc21e132c7337a2ad9e75a03356551f0e9060", "commitAfterChange": "2f8f6c0c9552d7ebf46ec13ce513e098823a7a4e", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic String disassemble(IClassFileReader classFileReader, String lineSeparator)", "signatureAfterChange": " \tpublic String disassemble(IClassFileReader classFileReader, String lineSeparator)", "diff": ["+\t\tif (classFileReader == null) return EMPTY_OUTPUT;", "+\t\t", "+\t\t}", "+\t\tchar[] className = classFileReader.getClassName();", "+\t\tif (className == null) {", "+\t\t\t// incomplete initialization. We cannot go further.", "+\t\t\treturn buffer.toString();", "-\t\tdisassemble(classFileReader.getInnerClassesAttribute(), buffer, lineSeparator, 1);", "+\t\tIInnerClassesAttribute innerClassesAttribute = classFileReader.getInnerClassesAttribute();", "+\t\tif (innerClassesAttribute != null) {", "+\t\t\tdisassemble(innerClassesAttribute, buffer, lineSeparator, 1);", "+\t\t}", "+\t\twriteNewLine(buffer, lineSeparator, 0);", "+\t\tIClassFileAttribute[] attributes = classFileReader.getAttributes();", "+\t\tlength = attributes.length;", "+\t\tif (length != 0) {", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tIClassFileAttribute attribute = attributes[i];", "+\t\t\t\tif (attribute != innerClassesAttribute", "+\t\t\t\t\t&& attribute != sourceAttribute) {", "+\t\t\t\t\tdisassemble(attribute, buffer, lineSeparator, 0);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}\t\t", "+\t\twriteNewLine(buffer, lineSeparator, 0);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "194028b2d0e0eb2ae2c1023d37d87e24", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "44bb613cc5c3c46c068bd744b8bd3672d2dacb7a", "commitAfterChange": "3e29de302b9f16584da144bfb4192f62d3964b7a", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r private void computeInheritedMethods()", "signatureAfterChange": "\r private void computeInheritedMethods()", "diff": ["+*/\r", "-\t} else {\r", "-\t\tMethodBinding[] methods = this.type.scope.getJavaLangObject().methods();\r", "-\t\tfor (int m = methods.length; --m >= 0;) {\r", "-\t\t\tMethodBinding method = methods[m];\r", "-\t\t\tif (!method.isConstructor()) {\r", "-\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);\r", "-\t\t\t\tif (existingMethods == null)\r", "-\t\t\t\t\texistingMethods = new MethodBinding[1];\r", "-\t\t\t\telse\r", "-\t\t\t\t\tSystem.arraycopy(existingMethods, 0,\r", "-\t\t\t\t\t\t(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);\r", "-\t\t\t\texistingMethods[existingMethods.length - 1] = method;\r", "-\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);\r", "-\t\t\t}\r", "-\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "31ecf85a6038ce21c663b20c0e82f6d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "264dd88468cd014ae7150e1040d5982ca933b94b", "commitAfterChange": "fc8ba03f9916b4ab5a789fe72fe040f0a158e1e5", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["+\t\tif (current == null && this.type.isPublic()) {", "+\t\t\tint length = inherited.length;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tMethodBinding inheritedMethod = inherited[i];", "+\t\t\t\tif (inheritedMethod.isPublic() && !inheritedMethod.declaringClass.isPublic())", "+\t\t\t\t\tthis.type.addSyntheticBridgeMethod(inheritedMethod);", "+\t\t\t}", "+\t\t}", "+\t\t\tif (matchMethod == null && current != null && this.type.isPublic()) { // current == null case handled already.", "+\t\t\t\tMethodBinding inheritedMethod = inherited[i];", "+\t\t\t\tif (inheritedMethod.isPublic() && !inheritedMethod.declaringClass.isPublic()) {", "+\t\t\t\t\tthis.type.addSyntheticBridgeMethod(inheritedMethod);", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "429b2c635b986b678598864de54e2340", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "e3ab7adcf5341254d66eeef47fc0727dbe42868f", "commitAfterChange": "8915ec2bb74e44419be85002d7c3a4c9f8582635", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t \tprivate void disassemble(ICodeAttribute codeAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "signatureAfterChange": " \t \tprivate void disassemble(ICodeAttribute codeAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "diff": ["-\t\tint exceptionTableLength = codeAttribute.getExceptionTableLength();", "+\t\tfinal int exceptionTableLength = codeAttribute.getExceptionTableLength();", "-\t\t\tIExceptionTableEntry[] exceptionTableEntries = codeAttribute.getExceptionTable();", "+\t\t\tfinal IExceptionTableEntry[] exceptionTableEntries = codeAttribute.getExceptionTable();", "-\t\tILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();", "-\t\tint lineAttributeLength = lineNumberAttribute == null ? 0 : lineNumberAttribute.getLineNumberTableLength();", "+\t\tfinal ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();", "+\t\tfinal int lineAttributeLength = lineNumberAttribute == null ? 0 : lineNumberAttribute.getLineNumberTableLength();", "-\t\tILocalVariableAttribute localVariableAttribute = codeAttribute.getLocalVariableAttribute();", "-\t\tint localVariableAttributeLength = localVariableAttribute == null ? 0 : localVariableAttribute.getLocalVariableTableLength();", "+\t\tfinal ILocalVariableAttribute localVariableAttribute = codeAttribute.getLocalVariableAttribute();", "+\t\tfinal int localVariableAttributeLength = localVariableAttribute == null ? 0 : localVariableAttribute.getLocalVariableTableLength();", "-\t\tILocalVariableTypeTableAttribute localVariableTypeAttribute= getLocalVariableTypeAttribute(codeAttribute);", "-\t\tint localVariableTypeTableLength = localVariableTypeAttribute == null ? 0 : localVariableTypeAttribute.getLocalVariableTypeTableLength();", "+\t\tfinal ILocalVariableTypeTableAttribute localVariableTypeAttribute= (ILocalVariableTypeTableAttribute) getAttribute(IAttributeNamesConstants.LOCAL_VARIABLE_TYPE_TABLE, codeAttribute);", "+\t\tfinal int localVariableTypeTableLength = localVariableTypeAttribute == null ? 0 : localVariableTypeAttribute.getLocalVariableTypeTableLength();", "-\t\t} ", "+\t\t}", "+\t\tfinal int length = codeAttribute.getAttributesCount();", "+\t\tif (length != 0) {", "+\t\t\tIClassFileAttribute[] attributes = codeAttribute.getAttributes();", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tIClassFileAttribute attribute = attributes[i];", "+\t\t\t\tif (CharOperation.equals(attribute.getAttributeName(), IAttributeNamesConstants.STACK_MAP_TABLE)) {", "+\t\t\t\t\tdisassemble((StackMapTableAttribute) attribute, buffer, lineSeparator, tabNumber + 1);", "+\t\t\t\t} else if (attribute != lineNumberAttribute", "+\t\t\t\t\t\t&& attribute != localVariableAttribute", "+\t\t\t\t\t\t&& attribute != localVariableTypeAttribute) {", "+\t\t\t\t\tdisassemble(attribute, buffer, lineSeparator, tabNumber + 1);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46fe1bd67b166da821577d4d6bbd20a9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "673b7eda95cd26449992e862f0c63f2c612903a0", "commitAfterChange": "b04602938404af4f8569a399fb36a5018768a262", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r \tprivate void computeInheritedMethods()", "signatureAfterChange": "\r private void computeInheritedMethods()", "diff": ["+}\r", "+private void computeInheritedMethods() {\r", "+\tthis.inheritedMethods = new HashtableOfObject(51); // maps method selectors to an array of methods... must search to match paramaters & return type\r", "+\tReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];\r", "+\tint lastPosition = 0;\r", "+\tinterfacesToVisit[lastPosition] = type.superInterfaces();\r", "-\t*/\r", "-\tprivate void computeInheritedMethods() {\r", "-\t\tthis.inheritedMethods = new HashtableOfObject(51);\r", "-\t\t// maps method selectors to an array of methods... must search to match paramaters & return type\r", "-\t\tReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];\r", "-\t\tint lastPosition = 0;\r", "-\t\tinterfacesToVisit[lastPosition] = type.superInterfaces();\r", "+\tif (this.type.isClass()) {\r", "+\t\tReferenceBinding superType = this.type;\r", "+\t\tMethodBinding[] nonVisibleDefaultMethods = null;\r", "+\t\tint nonVisibleCount = 0;\r", "-\t\tif (this.type.isClass()) {\r", "-\t\t\tReferenceBinding superType = this.type;\r", "-\t\t\tMethodBinding[] nonVisibleDefaultMethods = null;\r", "-\t\t\tint nonVisibleCount = 0;\r", "+\t\twhile ((superType = superType.superclass()) != null) {\r", "+\t\t\tif (superType.isValidBinding()) {\r", "+\t\t\t\tReferenceBinding[] itsInterfaces = superType.superInterfaces();\r", "+\t\t\t\tif (itsInterfaces != NoSuperInterfaces) {\r", "+\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)\r", "+\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);\r", "+\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;\r", "+\t\t\t\t}\r", "-\t\t\twhile ((superType = superType.superclass()) != null) {\r", "-\t\t\t\tif (superType.isValidBinding()) {\r", "-\t\t\t\t\tReferenceBinding[] itsInterfaces = superType.superInterfaces();\r", "-\t\t\t\t\tif (itsInterfaces != NoSuperInterfaces) {\r", "-\t\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)\r", "-\t\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\tinterfacesToVisit,\r", "-\t\t\t\t\t\t\t\t0,\r", "-\t\t\t\t\t\t\t\tinterfacesToVisit = new ReferenceBinding[lastPosition * 2][],\r", "-\t\t\t\t\t\t\t\t0,\r", "-\t\t\t\t\t\t\t\tlastPosition);\r", "-\t\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;\r", "-\t\t\t\t\t}\r", "-\r", "-\t\t\t\t\tMethodBinding[] methods = superType.methods();\r", "-\t\t\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) {\r", "-\t\t\t\t\t\tMethodBinding method = methods[m];\r", "-\t\t\t\t\t\tif (!(method.isPrivate()\r", "-\t\t\t\t\t\t\t|| method.isConstructor()\r", "-\t\t\t\t\t\t\t|| method.isDefaultAbstract())) {\r", "-\t\t\t\t\t\t\t// look at all methods which are NOT private or constructors or default abstract\r", "-\t\t\t\t\t\t\tMethodBinding[] existingMethods =\r", "-\t\t\t\t\t\t\t\t(MethodBinding[]) this.inheritedMethods.get(method.selector);\r", "-\t\t\t\t\t\t\tif (existingMethods != null)\r", "-\t\t\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++)\r", "-\t\t\t\t\t\t\t\t\tif (method.returnType == existingMethods[i].returnType)\r", "-\t\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(existingMethods[i]))\r", "+\t\t\t\tMethodBinding[] methods = superType.methods();\r", "+\t\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) {\r", "+\t\t\t\t\tMethodBinding method = methods[m];\r", "+\t\t\t\t\tif (!(method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())) { // look at all methods which are NOT private or constructors or default abstract\r", "+\t\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);\r", "+\t\t\t\t\t\tif (existingMethods != null)\r", "+\t\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++)\r", "+\t\t\t\t\t\t\t\tif (method.returnType == existingMethods[i].returnType)\r", "+\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(existingMethods[i]))\r", "+\t\t\t\t\t\t\t\t\t\tcontinue nextMethod;\r", "+\t\t\t\t\t\tif (nonVisibleDefaultMethods != null)\r", "+\t\t\t\t\t\t\tfor (int i = 0; i < nonVisibleCount; i++)\r", "+\t\t\t\t\t\t\t\tif (method.returnType == nonVisibleDefaultMethods[i].returnType)\r", "+\t\t\t\t\t\t\t\t\tif (CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector))\r", "+\t\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(nonVisibleDefaultMethods[i]))\r", "-\t\t\t\t\t\t\tif (nonVisibleDefaultMethods != null)\r", "-\t\t\t\t\t\t\t\tfor (int i = 0; i < nonVisibleCount; i++)\r", "-\t\t\t\t\t\t\t\t\tif (method.returnType == nonVisibleDefaultMethods[i].returnType)\r", "-\t\t\t\t\t\t\t\t\t\tif (CharOperation\r", "-\t\t\t\t\t\t\t\t\t\t\t.equals(method.selector, nonVisibleDefaultMethods[i].selector))\r", "-\t\t\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(nonVisibleDefaultMethods[i]))\r", "-\t\t\t\t\t\t\t\t\t\t\t\tcontinue nextMethod;\r", "-\t\t\t\t\t\t\tif (!(method.isDefault()\r", "-\t\t\t\t\t\t\t\t&& (method.declaringClass.fPackage != type.fPackage))) {\r", "-\t\t\t\t\t\t\t\t// ignore methods which have default visibility and are NOT defined in another package\r", "-\t\t\t\t\t\t\t\tif (existingMethods == null)\r", "-\t\t\t\t\t\t\t\t\texistingMethods = new MethodBinding[1];\r", "-\t\t\t\t\t\t\t\telse\r", "-\t\t\t\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\t\t\texistingMethods,\r", "-\t\t\t\t\t\t\t\t\t\t0,\r", "-\t\t\t\t\t\t\t\t\t\t(existingMethods = new MethodBinding[existingMethods.length + 1]),\r", "-\t\t\t\t\t\t\t\t\t\t0,\r", "-\t\t\t\t\t\t\t\t\t\texistingMethods.length - 1);\r", "-\t\t\t\t\t\t\t\texistingMethods[existingMethods.length - 1] = method;\r", "-\t\t\t\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);\r", "-\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\tif (nonVisibleDefaultMethods == null)\r", "-\t\t\t\t\t\t\t\t\tnonVisibleDefaultMethods = new MethodBinding[10];\r", "-\t\t\t\t\t\t\t\telse\r", "-\t\t\t\t\t\t\t\t\tif (nonVisibleCount == nonVisibleDefaultMethods.length)\r", "-\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\t\t\t\tnonVisibleDefaultMethods,\r", "-\t\t\t\t\t\t\t\t\t\t\t0,\r", "-\t\t\t\t\t\t\t\t\t\t\t(nonVisibleDefaultMethods = new MethodBinding[nonVisibleCount * 2]),\r", "-\t\t\t\t\t\t\t\t\t\t\t0,\r", "-\t\t\t\t\t\t\t\t\t\t\tnonVisibleCount);\r", "-\t\t\t\t\t\t\t\tnonVisibleDefaultMethods[nonVisibleCount++] = method;\r", "+\t\t\t\t\t\tif (!(method.isDefault() && (method.declaringClass.fPackage != type.fPackage))) { // ignore methods which have default visibility and are NOT defined in another package\r", "+\t\t\t\t\t\t\tif (existingMethods == null)\r", "+\t\t\t\t\t\t\t\texistingMethods = new MethodBinding[1];\r", "+\t\t\t\t\t\t\telse\r", "+\t\t\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0,\r", "+\t\t\t\t\t\t\t\t\t(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);\r", "+\t\t\t\t\t\t\texistingMethods[existingMethods.length - 1] = method;\r", "+\t\t\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tif (nonVisibleDefaultMethods == null)\r", "+\t\t\t\t\t\t\t\tnonVisibleDefaultMethods = new MethodBinding[10];\r", "+\t\t\t\t\t\t\telse if (nonVisibleCount == nonVisibleDefaultMethods.length)\r", "+\t\t\t\t\t\t\t\tSystem.arraycopy(nonVisibleDefaultMethods, 0,\r", "+\t\t\t\t\t\t\t\t\t(nonVisibleDefaultMethods = new MethodBinding[nonVisibleCount * 2]), 0, nonVisibleCount);\r", "+\t\t\t\t\t\t\tnonVisibleDefaultMethods[nonVisibleCount++] = method;\r", "-\t\t\t\t\t\t\t\tif (method.isAbstract()\r", "-\t\t\t\t\t\t\t\t\t&& !this.type.isAbstract())\r", "-\t\t\t\t\t\t\t\t\t// non visible abstract methods cannot be overridden so the type must be defined abstract\r", "-\t\t\t\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, method);\r", "+\t\t\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract\r", "+\t\t\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, method);\r", "-\t\t\t\t\t\t\t\tMethodBinding[] current =\r", "-\t\t\t\t\t\t\t\t\t(MethodBinding[]) this.currentMethods.get(method.selector);\r", "-\t\t\t\t\t\t\t\tif (current != null) {\r", "-\t\t\t\t\t\t\t\t\t// non visible methods cannot be overridden so a warning is issued\r", "-\t\t\t\t\t\t\t\t\tfoundMatch : for (int i = 0, length = current.length; i < length; i++) {\r", "-\t\t\t\t\t\t\t\t\t\tif (method.returnType == current[i].returnType) {\r", "-\t\t\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(current[i])) {\r", "-\t\t\t\t\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);\r", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak foundMatch;\r", "-\t\t\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(method.selector);\r", "+\t\t\t\t\t\t\tif (current != null) { // non visible methods cannot be overridden so a warning is issued\r", "+\t\t\t\t\t\t\t\tfoundMatch : for (int i = 0, length = current.length; i < length; i++) {\r", "+\t\t\t\t\t\t\t\t\tif (method.returnType == current[i].returnType) {\r", "+\t\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(current[i])) {\r", "+\t\t\t\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);\r", "+\t\t\t\t\t\t\t\t\t\t\tbreak foundMatch;\r", "+\t} else {\r", "+\t\tMethodBinding[] methods = this.type.scope.getJavaLangObject().methods();\r", "+\t\tfor (int m = methods.length; --m >= 0;) {\r", "+\t\t\tMethodBinding method = methods[m];\r", "+\t\t\tif (!method.isConstructor()) {\r", "+\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);\r", "+\t\t\t\tif (existingMethods == null)\r", "+\t\t\t\t\texistingMethods = new MethodBinding[1];\r", "+\t\t\t\telse\r", "+\t\t\t\t\tSystem.arraycopy(existingMethods, 0,\r", "+\t\t\t\t\t\t(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);\r", "+\t\t\t\texistingMethods[existingMethods.length - 1] = method;\r", "+\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r", "-\t\tfor (int i = 0; i <= lastPosition; i++) {\r", "-\t\t\tReferenceBinding[] interfaces = interfacesToVisit[i];\r", "-\t\t\tfor (int j = 0, length = interfaces.length; j < length; j++) {\r", "-\t\t\t\tReferenceBinding superType = interfaces[j];\r", "-\t\t\t\tif ((superType.tagBits & InterfaceVisited) == 0) {\r", "-\t\t\t\t\tsuperType.tagBits |= InterfaceVisited;\r", "-\t\t\t\t\tif (superType.isValidBinding()) {\r", "-\t\t\t\t\t\tReferenceBinding[] itsInterfaces = superType.superInterfaces();\r", "-\t\t\t\t\t\tif (itsInterfaces != NoSuperInterfaces) {\r", "-\t\t\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)\r", "-\t\t\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\t\tinterfacesToVisit,\r", "-\t\t\t\t\t\t\t\t\t0,\r", "-\t\t\t\t\t\t\t\t\tinterfacesToVisit = new ReferenceBinding[lastPosition * 2][],\r", "-\t\t\t\t\t\t\t\t\t0,\r", "-\t\t\t\t\t\t\t\t\tlastPosition);\r", "-\t\t\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;\r", "-\t\t\t\t\t\t}\r", "+\tfor (int i = 0; i <= lastPosition; i++) {\r", "+\t\tReferenceBinding[] interfaces = interfacesToVisit[i];\r", "+\t\tfor (int j = 0, length = interfaces.length; j < length; j++) {\r", "+\t\t\tReferenceBinding superType = interfaces[j];\r", "+\t\t\tif ((superType.tagBits & InterfaceVisited) == 0) {\r", "+\t\t\t\tsuperType.tagBits |= InterfaceVisited;\r", "+\t\t\t\tif (superType.isValidBinding()) {\r", "+\t\t\t\t\tReferenceBinding[] itsInterfaces = superType.superInterfaces();\r", "+\t\t\t\t\tif (itsInterfaces != NoSuperInterfaces) {\r", "+\t\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)\r", "+\t\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);\r", "+\t\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;\r", "+\t\t\t\t\t}\r", "-\t\t\t\t\t\tMethodBinding[] methods = superType.methods();\r", "-\t\t\t\t\t\tfor (int m = methods.length;\r", "-\t\t\t\t\t\t\t--m >= 0;\r", "-\t\t\t\t\t\t\t) { // Interface methods are all abstract public\r", "-\t\t\t\t\t\t\tMethodBinding method = methods[m];\r", "-\t\t\t\t\t\t\tMethodBinding[] existingMethods =\r", "-\t\t\t\t\t\t\t\t(MethodBinding[]) this.inheritedMethods.get(method.selector);\r", "-\t\t\t\t\t\t\tif (existingMethods == null)\r", "-\t\t\t\t\t\t\t\texistingMethods = new MethodBinding[1];\r", "-\t\t\t\t\t\t\telse\r", "-\t\t\t\t\t\t\t\tSystem.arraycopy(\r", "-\t\t\t\t\t\t\t\t\texistingMethods,\r", "-\t\t\t\t\t\t\t\t\t0,\r", "-\t\t\t\t\t\t\t\t\t(existingMethods = new MethodBinding[existingMethods.length + 1]),\r", "-\t\t\t\t\t\t\t\t\t0,\r", "-\t\t\t\t\t\t\t\t\texistingMethods.length - 1);\r", "-\t\t\t\t\t\t\texistingMethods[existingMethods.length - 1] = method;\r", "-\t\t\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);\r", "-\t\t\t\t\t\t}\r", "+\t\t\t\t\tMethodBinding[] methods = superType.methods();\r", "+\t\t\t\t\tfor (int m = methods.length; --m >= 0;) { // Interface methods are all abstract public\r", "+\t\t\t\t\t\tMethodBinding method = methods[m];\r", "+\t\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);\r", "+\t\t\t\t\t\tif (existingMethods == null)\r", "+\t\t\t\t\t\t\texistingMethods = new MethodBinding[1];\r", "+\t\t\t\t\t\telse\r", "+\t\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0,\r", "+\t\t\t\t\t\t\t\t(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);\r", "+\t\t\t\t\t\texistingMethods[existingMethods.length - 1] = method;\r", "+\t\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);\r", "+\t}\r", "-\t\t// bit reinitialization\r", "-\t\tfor (int i = 0; i <= lastPosition; i++) {\r", "-\t\t\tReferenceBinding[] interfaces = interfacesToVisit[i];\r", "-\t\t\tfor (int j = 0, length = interfaces.length; j < length; j++)\r", "-\t\t\t\tinterfaces[j].tagBits &= ~InterfaceVisited;\r", "+\t// bit reinitialization\r", "+\tfor (int i = 0; i <= lastPosition; i++) {\r", "+\t\tReferenceBinding[] interfaces = interfacesToVisit[i];\r", "+\t\tfor (int j = 0, length = interfaces.length; j < length; j++)\r", "+\t\t\tinterfaces[j].tagBits &= ~InterfaceVisited;\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e34f34a6670fcc5cb36c21505cbab569", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "f5937020c6b957eed03745f57cfee671f23dd9b8", "commitAfterChange": "ad2aca1c2960107e50013b8f7866125addb168b4", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType)", "signatureAfterChange": " \tpublic static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType)", "diff": ["+", "+\t\tif (annotations != null && length > 0 && recipient != null && recipient.isAnnotationType()) {", "+\t\t\t// See if this is meta-annotated as repeatable and if so validate constraints.", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tAnnotation annotation = sourceAnnotations[i];", "+\t\t\t\tMemberValuePair[] valuePairs = annotation.memberValuePairs();", "+\t\t\t\tReferenceBinding annotationType = annotations[i] != null ? annotations[i].getAnnotationType() : null;", "+\t\t\t\tif (annotationType != null && annotationType.id == TypeIds.T_JavaLangAnnotationRepeatable && valuePairs != null && valuePairs.length > 0) {", "+\t\t\t\t\tannotation.checkRepeatableAnnotation(valuePairs[0], scope, valuePairs[0].compilerElementPair.value);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\t\t\t\t\t\t\tAnnotation.checkAnnotationContainerTarget(sourceAnnotations[i], scope, annotationType, resolvedContainer);", "+\t\t\t\t\t\t\t\t// Validate the repeated *use* of a repeatable annotation.", "+\t\t\t\t\t\t\t\tAnnotation.checkContainingAnnotation(sourceAnnotations[i], scope, resolvedContainer, annotationType);", "+\t\t\t// Check for presence of repeating annotation together with the containing annotation"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fcf9da7ce9eb32f7f3745469f436b079", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocAllocationExpression.java", "commitBeforeChange": "ab74babcdf0f89ee66e36b91189c0d301a4da95d", "commitAfterChange": "66a4221dd418603b7f2bc6722d99e4e300585ef1", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tprivate TypeBinding internalResolveType(Scope scope)", "signatureAfterChange": "  \tTypeBinding internalResolveType(Scope scope)", "diff": ["-\tprivate TypeBinding internalResolveType(Scope scope) {", "+\tTypeBinding internalResolveType(Scope scope) {", "+\t\t} else if (this.resolvedType.isMemberType()) { // inner class constructor reference must be qualified", "+\t\t\tint length = qualification.length;", "+\t\t\tReferenceBinding enclosingTypeBinding = allocationType;", "+\t\t\tif (type instanceof JavadocQualifiedTypeReference && (((JavadocQualifiedTypeReference)type).tokens.length != length)) {", "+\t\t\t\tscope.problemReporter().javadocInvalidConstructorQualification(this.memberStart+1, this.sourceEnd); //, scope.getDeclarationModifiers());", "+\t\t\t} else {", "+\t\t\t\tint idx = length;", "+\t\t\t\twhile (idx > 0 && CharOperation.equals(qualification[--idx], enclosingTypeBinding.sourceName) && (enclosingTypeBinding = enclosingTypeBinding.enclosingType()) != null) {", "+\t\t\t\t\t// verify that each qualification token matches enclosing types", "+\t\t\t\t}", "+\t\t\t\tif (idx > 0 || enclosingTypeBinding != null) {", "+\t\t\t\t\tscope.problemReporter().javadocInvalidConstructorQualification(this.memberStart+1, this.sourceEnd); //, scope.getDeclarationModifiers());", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 3006}