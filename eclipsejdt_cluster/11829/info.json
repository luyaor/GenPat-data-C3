{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fe0dcbed6fe29839093f01a1b91559c2", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "54c07eb058c4029763f8dead8d80a5b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectReferenceChange.java", "commitBeforeChange": "bf5fdbab3898ef946bf2a56347acd790a3f7a7bd", "commitAfterChange": "bb09a0a12eeeef679eb6c43515683a3f275882d3", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic void updateProjectReferencesIfNecessary() throws JavaModelException", "signatureAfterChange": " \tpublic void updateProjectReferencesIfNecessary() throws JavaModelException", "diff": ["-\t\tString[] oldRequired = this.oldResolvedClasspath == null ? CharOperation.NO_STRINGS : this.project.projectPrerequisites(this.oldResolvedClasspath);", "+\t\tfinal String[] oldRequired = this.oldResolvedClasspath == null ? CharOperation.NO_STRINGS : this.project.projectPrerequisites(this.oldResolvedClasspath);", "-\t\tString[] newRequired = this.project.projectPrerequisites(newResolvedClasspath);", "-\t\ttry {", "-\t\t\tIProject projectResource = this.project.getProject();", "-\t\t\tIProjectDescription description = projectResource.getDescription();", "-\t\t\t ", "-\t\t\tIProject[] projectReferences = description.getDynamicReferences();", "-\t\t\t", "-\t\t\tHashSet oldReferences = new HashSet(projectReferences.length);", "-\t\t\tfor (int i = 0; i < projectReferences.length; i++){", "-\t\t\t\tString projectName = projectReferences[i].getName();", "-\t\t\t\toldReferences.add(projectName);", "-\t\t\t}", "-\t\t\tHashSet newReferences = (HashSet)oldReferences.clone();", "-\t", "-\t\t\tfor (int i = 0; i < oldRequired.length; i++){", "-\t\t\t\tString projectName = oldRequired[i];", "-\t\t\t\tnewReferences.remove(projectName);", "-\t\t\t}", "-\t\t\tfor (int i = 0; i < newRequired.length; i++){", "-\t\t\t\tString projectName = newRequired[i];", "-\t\t\t\tnewReferences.add(projectName);", "-\t\t\t}", "-\t", "-\t\t\tIterator iter;", "-\t\t\tint newSize = newReferences.size();", "-\t\t\t", "-\t\t\tcheckIdentity: {", "-\t\t\t\tif (oldReferences.size() == newSize){", "-\t\t\t\t\titer = newReferences.iterator();", "-\t\t\t\t\twhile (iter.hasNext()){", "-\t\t\t\t\t\tif (!oldReferences.contains(iter.next())){", "-\t\t\t\t\t\t\tbreak checkIdentity;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\treturn;", "+\t\tfinal String[] newRequired = this.project.projectPrerequisites(newResolvedClasspath);", "+\t\tfinal IProject projectResource = this.project.getProject();", "+\t\tIWorkspaceRunnable runnable = new IWorkspaceRunnable() {", "+\t\t\tpublic void run(IProgressMonitor monitor) throws CoreException {", "+\t\t\t\tIProjectDescription description = projectResource.getDescription();", "+\t\t\t\t ", "+\t\t\t\tIProject[] projectReferences = description.getDynamicReferences();", "+\t\t\t\t", "+\t\t\t\tHashSet oldReferences = new HashSet(projectReferences.length);", "+\t\t\t\tfor (int i = 0; i < projectReferences.length; i++){", "+\t\t\t\t\tString projectName = projectReferences[i].getName();", "+\t\t\t\t\toldReferences.add(projectName);", "+\t\t\t\tHashSet newReferences = (HashSet)oldReferences.clone();", "+\t\t", "+\t\t\t\tfor (int i = 0; i < oldRequired.length; i++){", "+\t\t\t\t\tString projectName = oldRequired[i];", "+\t\t\t\t\tnewReferences.remove(projectName);", "+\t\t\t\t}", "+\t\t\t\tfor (int i = 0; i < newRequired.length; i++){", "+\t\t\t\t\tString projectName = newRequired[i];", "+\t\t\t\t\tnewReferences.add(projectName);", "+\t\t\t\t}", "+\t\t", "+\t\t\t\tIterator iter;", "+\t\t\t\tint newSize = newReferences.size();", "+\t\t\t\t", "+\t\t\t\tcheckIdentity: {", "+\t\t\t\t\tif (oldReferences.size() == newSize){", "+\t\t\t\t\t\titer = newReferences.iterator();", "+\t\t\t\t\t\twhile (iter.hasNext()){", "+\t\t\t\t\t\t\tif (!oldReferences.contains(iter.next())){", "+\t\t\t\t\t\t\t\tbreak checkIdentity;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tString[] requiredProjectNames = new String[newSize];", "+\t\t\t\tint index = 0;", "+\t\t\t\titer = newReferences.iterator();", "+\t\t\t\twhile (iter.hasNext()){", "+\t\t\t\t\trequiredProjectNames[index++] = (String)iter.next();", "+\t\t\t\t}", "+\t\t\t\tUtil.sort(requiredProjectNames); // ensure that if changed, the order is consistent", "+\t\t\t\t", "+\t\t\t\tIProject[] requiredProjectArray = new IProject[newSize];", "+\t\t\t\tIWorkspaceRoot wksRoot = projectResource.getWorkspace().getRoot();", "+\t\t\t\tfor (int i = 0; i < newSize; i++){", "+\t\t\t\t\trequiredProjectArray[i] = wksRoot.getProject(requiredProjectNames[i]);", "+\t\t\t\t}", "+\t\t\t\tdescription.setDynamicReferences(requiredProjectArray);", "+\t\t\t\tprojectResource.setDescription(description, null);", "-\t\t\tString[] requiredProjectNames = new String[newSize];", "-\t\t\tint index = 0;", "-\t\t\titer = newReferences.iterator();", "-\t\t\twhile (iter.hasNext()){", "-\t\t\t\trequiredProjectNames[index++] = (String)iter.next();", "-\t\t\t}", "-\t\t\tUtil.sort(requiredProjectNames); // ensure that if changed, the order is consistent", "-\t\t\t", "-\t\t\tIProject[] requiredProjectArray = new IProject[newSize];", "-\t\t\tIWorkspaceRoot wksRoot = projectResource.getWorkspace().getRoot();", "-\t\t\tfor (int i = 0; i < newSize; i++){", "-\t\t\t\trequiredProjectArray[i] = wksRoot.getProject(requiredProjectNames[i]);", "-\t\t\t}", "-\t\t\tdescription.setDynamicReferences(requiredProjectArray);", "-\t\t\tprojectResource.setDescription(description, null);", "-\t", "+\t\t};", "+\t\ttry {", "+\t\t\t// ensure that a sheduling rule is used so that the project description is not modified by another thread while we update it", "+\t\t\t// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=214981", "+\t\t\tIWorkspace workspace = projectResource.getWorkspace();", "+\t\t\tISchedulingRule rule = workspace.getRuleFactory().modifyRule(projectResource); // sheduling rule for modifying the project", "+\t\t\tworkspace.run(runnable, rule, IWorkspace.AVOID_UPDATE, null);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5cfccb44dc12170cdf505c3f2c4b69bb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "2d45e82533a4fdf2e19ac612c4a04c15da28bf1a", "commitAfterChange": "fabf6bf3cec26424988d597b756c5fec9a4b330d", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 76, "signatureBeforeChange": " \tprivate IClasspathContainer initializeAllContainers(IJavaProject javaProjectToInit, IPath containerToInit) throws JavaModelException", "signatureAfterChange": " \tprivate IClasspathContainer initializeAllContainers(IJavaProject javaProjectToInit, IPath containerToInit) throws JavaModelException", "diff": ["-\t\tHashMap allContainerPaths = new HashMap();", "+\t\tfinal HashMap allContainerPaths = new HashMap();", "-\t\t\tSet keys = allContainerPaths.keySet();", "-\t\t\tint length = keys.size();", "-\t\t\tIJavaProject[] javaProjects = new IJavaProject[length]; // clone as the following will have a side effect", "-\t\t\tkeys.toArray(javaProjects);", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tIJavaProject javaProject = javaProjects[i];", "-\t\t\t\tHashSet pathSet = (HashSet) allContainerPaths.get(javaProject);", "-\t\t\t\tif (pathSet == null) continue;", "-\t\t\t\tint length2 = pathSet.size();", "-\t\t\t\tIPath[] paths = new IPath[length2];", "-\t\t\t\tpathSet.toArray(paths); // clone as the following will have a side effect", "-\t\t\t\tfor (int j = 0; j < length2; j++) {", "-\t\t\t\t\tIPath path = paths[j];", "-\t\t\t\t\tinitializeContainer(javaProject, path);", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\t// if possible run inside an IWokspaceRunnable with AVOID_UPATE to avoid unwanted builds", "+\t\t\t// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=118507)", "+\t\t\tIWorkspaceRunnable runnable = \t\t\t\t", "+\t\t\t\tnew IWorkspaceRunnable() {", "+\t\t\t\t\tpublic void run(IProgressMonitor monitor) throws CoreException {", "+\t\t\t\t\t\tSet keys = allContainerPaths.keySet();", "+\t\t\t\t\t\tint length = keys.size();", "+\t\t\t\t\t\tIJavaProject[] javaProjects = new IJavaProject[length]; // clone as the following will have a side effect", "+\t\t\t\t\t\tkeys.toArray(javaProjects);", "+\t\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\t\tIJavaProject javaProject = javaProjects[i];", "+\t\t\t\t\t\t\tHashSet pathSet = (HashSet) allContainerPaths.get(javaProject);", "+\t\t\t\t\t\t\tif (pathSet == null) continue;", "+\t\t\t\t\t\t\tint length2 = pathSet.size();", "+\t\t\t\t\t\t\tIPath[] paths = new IPath[length2];", "+\t\t\t\t\t\t\tpathSet.toArray(paths); // clone as the following will have a side effect", "+\t\t\t\t\t\t\tfor (int j = 0; j < length2; j++) {", "+\t\t\t\t\t\t\t\tIPath path = paths[j];", "+\t\t\t\t\t\t\t\tinitializeContainer(javaProject, path);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t};", "+\t\t\tIWorkspace workspace = ResourcesPlugin.getWorkspace();", "+\t\t\tif (workspace.isTreeLocked())", "+\t\t\t\trunnable.run(null/*no progress available*/);", "+\t\t\telse", "+\t\t\t\tworkspace.run(", "+\t\t\t\t\trunnable,", "+\t\t\t\t\tnull/*don't take any lock*/,", "+\t\t\t\t\tIWorkspace.AVOID_UPDATE,", "+\t\t\t\t\tnull/*no progress available here*/);", "+\t\t} catch (CoreException e) {", "+\t\t\t// ignore", "+\t\t\tUtil.log(e, \"Exception while initializing all containers\"); //$NON-NLS-1$"]}], "num": 11829}