{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9ff7be7c3ea96b866ef95a9290a8d7fb", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16fd04fee243aa14bf9097c54d10526f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/DefaultProblem.java", "commitBeforeChange": "4c8a3ba34c720dda98e8d56ba71f0361efbe740b", "commitAfterChange": "c06cfa4791f8eb98381a7dd55dd6950dbcddf37c", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public String errorReportSource(char[] unitSource)", "signatureAfterChange": "  public String errorReportSource(char[] unitSource)", "diff": ["-\treturn errorReportSource(unitSource, 0);", "-}", "+\terrorBuffer.append(' ').append(Messages.bind(Messages.problem_atLine, String.valueOf(this.line))); ", "+\terrorBuffer.append(Util.LINE_SEPARATOR);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "25ba2cf50d7b76bf9dde807431dddd7e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "f797a4fefd78f3a1e278248a5427c284f913a1e4", "commitAfterChange": "aa4e1bcbd015d2517f92b0ecb8f5e5cc59766723", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r \tITypeBinding resolveType(Type type)", "signatureAfterChange": "\r \tITypeBinding resolveType(Type type)", "diff": ["-\t\tAstNode node = (AstNode) this.newAstToOldAst.get(type);\r", "+\t\tint index = 0;\r", "+\t\tASTNode parentType = type.getParent();\r", "+\t\tType arrayType = null;\r", "+\t\twhile ((parentType instanceof Type) && ((Type) parentType).isArrayType()) {\r", "+\t\t\tarrayType = (Type) parentType;\r", "+\t\t\tparentType = parentType.getParent();\r", "+\t\t\tindex++;\r", "+\t\t}\r", "+\t\tAstNode node = null;\r", "+\t\tif (index != 0) {\r", "+\t\t\tnode = (AstNode) this.newAstToOldAst.get(arrayType);\r", "+\t\t} else {\r", "+\t\t\tnode = (AstNode) this.newAstToOldAst.get(type);\r", "+\t\t}\r", "-\t\t\t\treturn this.getTypeBinding(typeReference.binding);\r", "+\t\t\t\tITypeBinding typeBinding = this.getTypeBinding(typeReference.binding);\r", "+\t\t\t\tif (index != 0) {\r", "+\t\t\t\t\tif (typeBinding.isArray()) {\r", "+\t\t\t\t\t\tArrayBinding arrayBinding = (ArrayBinding)typeReference.binding;\r", "+\t\t\t\t\t\tif (index == arrayBinding.dimensions) {\r", "+\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding.leafComponentType);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tfor (int i = 0; i < index; i++) {\r", "+\t\t\t\t\t\t\t\tarrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\treturn null;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\treturn typeBinding;\r", "+\t\t\t\t}\r", "-\t\t\t\t\treturn this.getTypeBinding((ReferenceBinding)singleNameReference.binding);\r", "+\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((ReferenceBinding)singleNameReference.binding);\r", "+\t\t\t\t\tif (index != 0) {\r", "+\t\t\t\t\t\tif (typeBinding.isArray()) {\r", "+\t\t\t\t\t\t\tArrayBinding arrayBinding = (ArrayBinding)singleNameReference.binding;\r", "+\t\t\t\t\t\t\tif (index == arrayBinding.dimensions) {\r", "+\t\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding.leafComponentType);\r", "+\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\tfor (int i = 0; i < index; i++) {\r", "+\t\t\t\t\t\t\t\t\tarrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\treturn null;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\treturn typeBinding;\r", "+\t\t\t\t\t}\r", "-\t\t\t\t\treturn this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);\r", "+\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);\r", "+\t\t\t\t\tif (index != 0) {\r", "+\t\t\t\t\t\tif (typeBinding.isArray()) {\r", "+\t\t\t\t\t\t\tArrayBinding arrayBinding = (ArrayBinding)qualifiedNameReference.binding;\r", "+\t\t\t\t\t\t\tif (index == arrayBinding.dimensions) {\r", "+\t\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding.leafComponentType);\r", "+\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\tfor (int i = 0; i < index; i++) {\r", "+\t\t\t\t\t\t\t\t\tarrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\treturn null;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\treturn typeBinding;\r", "+\t\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "355003a257ad0c919f3b5331716f5397", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java", "commitBeforeChange": "030558e3600e0a604bc6dac35a883b52ac0c5446", "commitAfterChange": "20a2fc3a8fdc6d3e237f88ae81c19fcd38d96cb4", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["+\tcheckParameterizedAllocation: {", "+\t\tif (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()", "+\t\t\tReferenceBinding currentType = (ReferenceBinding)this.resolvedType;", "+\t\t\tif (currentType == null) return currentType;", "+\t\t\tdo {", "+\t\t\t\t// isStatic() is answering true for toplevel types", "+\t\t\t\tif ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;", "+\t\t\t\tif (currentType.isRawType()) break checkParameterizedAllocation;", "+\t\t\t} while ((currentType = currentType.enclosingType())!= null);", "+\t\t\tParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;", "+\t\t\tfor (int i = qRef.typeArguments.length - 2; i >= 0; i--) {", "+\t\t\t\tif (qRef.typeArguments[i] != null) {", "+\t\t\t\t\tscope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, this.resolvedType);", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+", "+\t// resolve type arguments (for generic constructor call)", "+\tif (this.typeArguments != null) {", "+\t\tint length = this.typeArguments.length;", "+\t\tboolean argHasError = scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_5;", "+\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tTypeReference typeReference = this.typeArguments[i];", "+\t\t\tif ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\targHasError = true;", "+\t\t\t}", "+\t\t\tif (argHasError && typeReference instanceof Wildcard) {", "+\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "+\t\t\t}", "+\t\t}", "+\t\tif (argHasError) {", "+\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "+\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t\tthis.arguments[i].resolveType(scope);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn null;", "+\t\t}", "+\t}", "-\t\t    TypeBinding parameterType = this.binding.parameters[i];", "-\t\t    TypeBinding argumentType = argumentTypes[i];", "+\t\t\tTypeBinding parameterType = this.binding.parameters[i];", "+\t\t\tTypeBinding argumentType = argumentTypes[i];", "-\t    scope.problemReporter().unsafeRawInvocation(this, this.binding);", "+\t\tscope.problemReporter().unsafeRawInvocation(this, this.binding);", "+\t}", "+\tif (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "+\t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f11d64427f17799b812bbfbfa862e61", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "617fadfcdd9d3f85493c65c27088f408a3cd9c9d", "commitAfterChange": "b5a733b30758b3fb9ec3d527e7425b5399ba8dc0", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r \tpublic void checkExternalJarChanges(IJavaProject[] projects, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": "\r \tpublic void checkExternalArchiveChanges(IJavaElement[] refreshedElements, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\tpublic void checkExternalJarChanges(IJavaProject[] projects, IProgressMonitor monitor) throws JavaModelException {\r", "+\tpublic void checkExternalArchiveChanges(IJavaElement[] refreshedElements, IProgressMonitor monitor) throws JavaModelException {\r", "-\t\t\tHashMap externalJARsStatus = new HashMap();\r", "-\t\t\t\r", "+\t\t\tHashMap externalArchivesStatus = new HashMap();\r", "+\t\t\t\r", "+\t\t\t// find JARs to refresh\r", "+\t\t\tHashSet archivePathsToRefresh = new HashSet();\r", "+\t\t\tfor (int i = 0, elementsLength = refreshedElements.length; i < elementsLength; i++){\r", "+\t\t\t\tIJavaElement element = refreshedElements[i];\r", "+\t\t\t\tswitch(element.getElementType()){\r", "+\t\t\t\t\tcase IJavaElement.PACKAGE_FRAGMENT_ROOT :\r", "+\t\t\t\t\t\tarchivePathsToRefresh.add(element.getPath());\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase IJavaElement.JAVA_PROJECT :\r", "+\t\t\t\t\t\tIClasspathEntry[] classpath = ((IJavaProject) element).getResolvedClasspath(true);\r", "+\t\t\t\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++){\r", "+\t\t\t\t\t\t\tif (classpath[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY){\r", "+\t\t\t\t\t\t\t\tarchivePathsToRefresh.add(classpath[j].getPath());\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase IJavaElement.JAVA_MODEL :\r", "+\t\t\t\t\t\tIJavaProject[] projects = manager.getJavaModel().getOldJavaProjectsList();\r", "+\t\t\t\t\t\tfor (int j = 0, projectsLength = projects.length; j < projectsLength; j++){\r", "+\t\t\t\t\t\t\tclasspath = ((IJavaProject) projects[j]).getResolvedClasspath(true);\r", "+\t\t\t\t\t\t\tfor (int k = 0, cpLength = classpath.length; k < cpLength; k++){\r", "+\t\t\t\t\t\t\t\tif (classpath[k].getEntryKind() == IClasspathEntry.CPE_LIBRARY){\r", "+\t\t\t\t\t\t\t\t\tarchivePathsToRefresh.add(classpath[k].getPath());\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\t// perform refresh\r", "-\t\t\tif (projects == null){\r", "-\t\t\t\tprojects = manager.getJavaModel().getOldJavaProjectsList();\r", "-\t\t\t}\t\t\t\r", "+\t\t\tIJavaProject[] projects = manager.getJavaModel().getOldJavaProjectsList();\r", "-\t\t\t\t\t\tString status = (String)externalJARsStatus.get(entryPath); \r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\t\tif (!archivePathsToRefresh.contains(entryPath)) continue; // not supposed to be refreshed\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\t\tString status = (String)externalArchivesStatus.get(entryPath); \r", "-\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_REMOVED);\r", "+\t\t\t\t\t\t\t\t\texternalArchivesStatus.put(entryPath, EXTERNAL_JAR_REMOVED);\r", "-\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_REMOVED);\r", "+\t\t\t\t\t\t\t\t\t\texternalArchivesStatus.put(entryPath, EXTERNAL_JAR_REMOVED);\r", "-\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_CHANGED);\r", "+\t\t\t\t\t\t\t\t\t\texternalArchivesStatus.put(entryPath, EXTERNAL_JAR_CHANGED);\r", "-\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);\r", "+\t\t\t\t\t\t\t\t\t\texternalArchivesStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);\r", "-\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);\r", "+\t\t\t\t\t\t\t\t\t\texternalArchivesStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);\r", "-\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_ADDED);\r", "+\t\t\t\t\t\t\t\t\t\texternalArchivesStatus.put(entryPath, EXTERNAL_JAR_ADDED);\r", "-\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, INTERNAL_JAR_IGNORE);\r", "+\t\t\t\t\t\t\t\texternalArchivesStatus.put(entryPath, INTERNAL_JAR_IGNORE);\r", "-\t\t\t\t\t\tstatus = (String)externalJARsStatus.get(entryPath); \r", "+\t\t\t\t\t\tstatus = (String)externalArchivesStatus.get(entryPath); \r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6fa9e926925da55904e71b7e531833dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaWorkspaceScope.java", "commitBeforeChange": "e4f6d0091f68bf4b6ecb46943ad5d4d6a5ce0095", "commitAfterChange": "3a73dbc8d9839c0eb87857ef97f640371d15a626", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": " public IPath[] enclosingProjectsAndJars()", "signatureAfterChange": " public IPath[] enclosingProjectsAndJars()", "diff": ["+ */", "-\tif (this.needsInitialize) {", "-\t\tthis.initialize(5);", "+\tif (this.enclosingPaths != null) {", "+\t\treturn this.enclosingPaths;", "-\treturn super.enclosingProjectsAndJars();", "+\tlong start = BasicSearchEngine.VERBOSE ? System.currentTimeMillis() : -1;", "+\ttry {", "+\t\tIJavaProject[] projects = JavaModelManager.getJavaModelManager().getJavaModel().getJavaProjects();", "+\t\tSet paths = new HashSet(projects.length * 2);", "+\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\t\tJavaProject javaProject = (JavaProject) projects[i];", "+\t\t\t", "+\t\t\t// Add project full path", "+\t\t\tIPath projectPath = javaProject.getProject().getFullPath();", "+\t\t\tpaths.add(projectPath);", "+", "+\t\t\t// Add project libraries paths", "+\t\t\tIClasspathEntry[] entries = javaProject.getResolvedClasspath();", "+\t\t\tfor (int j = 0, eLength = entries.length; j < eLength; j++) {", "+\t\t\t\tIClasspathEntry entry = entries[j];", "+\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {", "+\t\t\t\t\tIPath path = entry.getPath();", "+\t\t\t\t\tObject target = JavaModel.getTarget(path, false/*don't check existence*/);", "+\t\t\t\t\tif (target instanceof IFolder) // case of an external folder", "+\t\t\t\t\t\tpath = ((IFolder) target).getFullPath();", "+\t\t\t\t\tpaths.add(entry.getPath());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tIPath[] result = new IPath[paths.size()];", "+\t\tpaths.toArray(result);", "+\t\treturn this.enclosingPaths = result;", "+\t} catch (JavaModelException e) {", "+\t\tUtil.log(e, \"Exception while computing workspace scope's enclosing projects and jars\"); //$NON-NLS-1$", "+\t\treturn new IPath[0];", "+\t} finally {", "+\t\tif (BasicSearchEngine.VERBOSE) {", "+\t\t\tlong time = System.currentTimeMillis() - start;", "+\t\t\tint length = this.enclosingPaths == null ? 0 : this.enclosingPaths.length;", "+\t\t\tUtil.verbose(\"JavaWorkspaceScope.enclosingProjectsAndJars: \"+length+\" paths computed in \"+time+\"ms.\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "708abae0456e262ef3508c948cf14247", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "da50a11f1737dbee3925e1da64ad7f9cbaff2e84", "commitAfterChange": "99342a278896e2f8caf142911ce817f7cc97d106", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r \r \tprivate void complete(AstNode astNode, Binding qualifiedBinding, Scope scope)", "signatureAfterChange": "\r \r \tprivate void complete(AstNode astNode, Binding qualifiedBinding, Scope scope)", "diff": ["+\t\t\t\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t\t\t\tif(astNode instanceof CompletionOnMethodName) {\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\tCompletionOnMethodName method = (CompletionOnMethodName) astNode;\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\tsetSourceRange(method.sourceStart, method.selectorEnd);\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\tFieldBinding[] fields = scope.enclosingSourceType().fields();\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\tchar[][] excludeNames = new char[fields.length][];\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ; i < fields.length ; i++){\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\texcludeNames[i] = fields[i].name;\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\tfindVariableNames(method.selector, method.returnType, excludeNames);\r", "+\t\t\t\t\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (astNode instanceof CompletionOnFieldName) {\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tCompletionOnFieldName field = (CompletionOnFieldName) astNode;\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tFieldBinding[] fields = scope.enclosingSourceType().fields();\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tchar[][] excludeNames = new char[fields.length][];\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ; i < fields.length ; i++){\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texcludeNames[i] = fields[i].name;\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfindVariableNames(field.name, field.type, excludeNames);\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (astNode instanceof CompletionOnLocalName ||\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tastNode instanceof CompletionOnArgumentName){\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLocalDeclaration variable = (LocalDeclaration) astNode;\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLocalVariableBinding[] locals = ((BlockScope)scope).locals;\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchar[][] excludeNames = new char[locals.length][];\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint localCount = 0;\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ; i < locals.length ; i++){\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(locals[i] != null) {\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texcludeNames[localCount++] = locals[i].name;\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(excludeNames, 0, excludeNames = new char[localCount][], 0, localCount);\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfindVariableNames(variable.name, variable.type, excludeNames);\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t} \r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ae795540d16e1fd1e4a6f36e98a9bf99", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "9f8931bf92b7966fbd8c101a448f79f7965fbbf9", "commitAfterChange": "3bf5bab95449ec256a601c2551910573083178b4", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tprivate void selectDeclaration(TypeDeclaration typeDeclaration, char[] assistIdentifier)", "signatureAfterChange": " \tprivate boolean selectDeclaration(TypeDeclaration typeDeclaration, char[] assistIdentifier, char[] packageName)", "diff": ["-\tprivate void selectDeclaration(TypeDeclaration typeDeclaration, char[] assistIdentifier){", "+\tprivate boolean selectDeclaration(TypeDeclaration typeDeclaration, char[] assistIdentifier, char[] packageName){", "-\t\t\tthrow new SelectionNodeFound(typeDeclaration.binding, true);", "+\t\t\tchar[] qualifiedSourceName = null;", "+\t\t\t", "+\t\t\tTypeDeclaration enclosingType = typeDeclaration;", "+\t\t\twhile(enclosingType != null) {", "+\t\t\t\tqualifiedSourceName = CharOperation.concat(enclosingType.name, qualifiedSourceName, '.');", "+\t\t\t\tenclosingType = enclosingType.enclosingType;", "+\t\t\t}", "+\t\t\t", "+\t\t\tif(!typeDeclaration.isInterface()) {", "+\t\t\t\tthis.requestor.acceptClass(", "+\t\t\t\t\tpackageName,", "+\t\t\t\t\tqualifiedSourceName,", "+\t\t\t\t\tfalse,", "+\t\t\t\t\ttrue,", "+\t\t\t\t\tthis.actualSelectionStart,", "+\t\t\t\t\tthis.actualSelectionEnd);", "+\t\t\t} else {", "+\t\t\t\tthis.requestor.acceptInterface(", "+\t\t\t\t\tpackageName,", "+\t\t\t\t\tqualifiedSourceName,", "+\t\t\t\t\tfalse,", "+\t\t\t\t\ttrue,", "+\t\t\t\t\tthis.actualSelectionStart,", "+\t\t\t\t\tthis.actualSelectionEnd);", "+\t\t\t}", "+\t\t\tthis.noProposal = false;", "+\t\t\treturn true;", "-\t\t\tselectDeclaration(memberTypes[i], assistIdentifier);", "+\t\t\tif(selectDeclaration(memberTypes[i], assistIdentifier, packageName))", "+\t\t\t\treturn true;", "-\t\t\t\tthrow new SelectionNodeFound(fields[i].binding, true);", "+\t\t\t\tchar[] qualifiedSourceName = null;", "+\t\t\t\t", "+\t\t\t\tTypeDeclaration enclosingType = typeDeclaration;", "+\t\t\t\twhile(enclosingType != null) {", "+\t\t\t\t\tqualifiedSourceName = CharOperation.concat(enclosingType.name, qualifiedSourceName, '.');", "+\t\t\t\t\tenclosingType = enclosingType.enclosingType;", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tthis.requestor.acceptField(", "+\t\t\t\t\tpackageName,", "+\t\t\t\t\tqualifiedSourceName,", "+\t\t\t\t\tfields[i].name,", "+\t\t\t\t\ttrue,", "+\t\t\t\t\tthis.actualSelectionStart,", "+\t\t\t\t\tthis.actualSelectionEnd);", "+", "+\t\t\t\tthis.noProposal = false;", "+\t\t\t\treturn true;", "-\t\t\t\tif(method.binding != null) {", "-\t\t\t\t\tthrow new SelectionNodeFound(method.binding, true);", "-\t\t\t\t} else {", "-\t\t\t\t\tif(method.scope != null) {", "-\t\t\t\t\t\tthrow new SelectionNodeFound(new MethodBinding(method.modifiers, method.selector, null, null, null, method.scope.referenceType().binding), true);", "-\t\t\t\t\t}", "+\t\t\t\tchar[] qualifiedSourceName = null;", "+\t\t\t\t", "+\t\t\t\tTypeDeclaration enclosingType = typeDeclaration;", "+\t\t\t\twhile(enclosingType != null) {", "+\t\t\t\t\tqualifiedSourceName = CharOperation.concat(enclosingType.name, qualifiedSourceName, '.');", "+\t\t\t\t\tenclosingType = enclosingType.enclosingType;", "+\t\t\t\t", "+\t\t\t\tthis.requestor.acceptMethod(", "+\t\t\t\t\tpackageName,", "+\t\t\t\t\tqualifiedSourceName,", "+\t\t\t\t\tmethod.selector,", "+\t\t\t\t\tnull, // SelectionRequestor does not need of parameters type for method declaration", "+\t\t\t\t\tnull, // SelectionRequestor does not need of parameters type for method declaration", "+\t\t\t\t\tmethod.isConstructor(),", "+\t\t\t\t\ttrue,", "+\t\t\t\t\tthis.actualSelectionStart,", "+\t\t\t\t\tthis.actualSelectionEnd);", "+\t\t\t\t", "+\t\t\t\tthis.noProposal = false;", "+\t\t\t\treturn true;", "+\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b5caa74e61b9cf14cb3d436bde96f46d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java", "commitBeforeChange": "10862673cc468a686e19591a5da27fefa3c4f311", "commitAfterChange": "d95cddc2779658eead76d04d49201937dc19989e", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " public void searchAllTypeNames( \tIWorkspace workspace, \tchar[] packageName,  \tchar[] typeName, \tint matchMode,  \tboolean isCaseSensitive, \tint searchFor,  \tIJavaSearchScope scope,  \tfinal ITypeNameRequestor nameRequestor, \tint waitingPolicy, \tIProgressMonitor progressMonitor)  throws JavaModelException", "signatureAfterChange": " public void searchAllTypeNames( \tIWorkspace workspace, \tchar[] packageName,  \tchar[] typeName, \tint matchMode,  \tboolean isCaseSensitive, \tint searchFor,  \tIJavaSearchScope scope,  \tfinal ITypeNameRequestor nameRequestor, \tint waitingPolicy, \tIProgressMonitor progressMonitor)  throws JavaModelException", "diff": ["+\tfinal HashSet workingCopyPaths = new HashSet();", "+\tif (this.workingCopies != null) {", "+\t\tfor (int i = 0, length = this.workingCopies.length; i < length; i++) {", "+\t\t\tICompilationUnit workingCopy = this.workingCopies[i];", "+\t\t\tworkingCopyPaths.add(workingCopy.getPath().toString());", "+\t\t}", "+\t}", "+", "-\t\t\tif (enclosingTypeNames != IIndexConstants.ONE_ZERO_CHAR) { // filter out local and anonymous classes", "+\t\t\tif (enclosingTypeNames != IIndexConstants.ONE_ZERO_CHAR  // filter out local and anonymous classes", "+\t\t\t\t\t&& !workingCopyPaths.contains(resourcePath)) { // filter out working copies", "-\t\t\tif (enclosingTypeNames != IIndexConstants.ONE_ZERO_CHAR) { // filter out local and anonymous classes", "+\t\t\tif (enclosingTypeNames != IIndexConstants.ONE_ZERO_CHAR  // filter out local and anonymous classes", "+\t\t\t\t\t&& !workingCopyPaths.contains(resourcePath)) { // filter out working copies", "+\t\t// add type names from indexes", "+\t\t\t", "+\t\t// add type names from working copies", "+\t\tif (this.workingCopies != null) {", "+\t\t\tfor (int i = 0, length = this.workingCopies.length; i < length; i++) {", "+\t\t\t\tICompilationUnit workingCopy = this.workingCopies[i];", "+\t\t\t\tIPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();", "+\t\t\t\tString path = workingCopy.getPath().toString();", "+\t\t\t\tchar[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();", "+\t\t\t\tIType[] allTypes = workingCopy.getAllTypes();", "+\t\t\t\tfor (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {", "+\t\t\t\t\tIType type = allTypes[j];", "+\t\t\t\t\tIJavaElement parent = type.getParent();", "+\t\t\t\t\tchar[][] enclosingTypeNames;", "+\t\t\t\t\tif (parent instanceof IType) {", "+\t\t\t\t\t\tchar[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();", "+\t\t\t\t\t\tenclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tenclosingTypeNames = CharOperation.NO_CHAR_CHAR;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (type.isClass()) {", "+\t\t\t\t\t\tnameRequestor.acceptClass(packageDeclaration, type.getElementName().toCharArray(), enclosingTypeNames, path);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tnameRequestor.acceptInterface(packageDeclaration, type.getElementName().toCharArray(), enclosingTypeNames, path);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0f712a8b7e9a8da38532f8c144c0547", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodPattern.java", "commitBeforeChange": "9037a5669c89fc0ae3f8548a99dce6fa5402fb31", "commitAfterChange": "e4e1e1935f0e7607d1265df332c7ce922de89c18", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 9, "signatureBeforeChange": " public abstract String getPatternName();", "signatureAfterChange": " public boolean matchesBinary(Object binaryInfo, Object enclosingBinaryInfo)", "diff": ["-}", "-public abstract String getPatternName();", "+ */", "+public boolean matchesBinary(Object binaryInfo, Object enclosingBinaryInfo) {", "+\tif (!this.findDeclarations) return false; // only relevant when finding declarations", "+\tif (!(binaryInfo instanceof IBinaryMethod)) return false;", "+", "+\tIBinaryMethod method = (IBinaryMethod) binaryInfo;", "+\tif (!matchesName(this.selector, method.getSelector())) return false;", "+", "+\t// declaring type", "+\tif (enclosingBinaryInfo != null && (this.declaringSimpleName != null || this.declaringQualification != null)) {", "+\t\tIBinaryType declaringType = (IBinaryType) enclosingBinaryInfo;", "+\t\tchar[] declaringTypeName = (char[]) declaringType.getName().clone();", "+\t\tCharOperation.replace(declaringTypeName, '/', '.');", "+\t\tif (!matchesType(this.declaringSimpleName, this.declaringQualification, declaringTypeName))", "+\t\t\treturn false;", "+\t}", "+", "+\t// parameter types", "+\tboolean checkReturnType = this.declaringSimpleName == null && (this.returnSimpleName != null || this.returnQualification != null);", "+\tint parameterCount = this.parameterSimpleNames == null ? -1 : this.parameterSimpleNames.length;", "+\tif (checkReturnType || parameterCount > -1) {", "+\t\tString methodDescriptor = new String(method.getMethodDescriptor()).replace('/', '.');", "+", "+\t\t// look at return type only if declaring type is not specified", "+\t\tif (checkReturnType) {", "+\t\t\tString returnTypeSignature = Signature.toString(Signature.getReturnType(methodDescriptor));", "+\t\t\tif (!matchesType(this.returnSimpleName, this.returnQualification, returnTypeSignature.toCharArray()))", "+\t\t\t\treturn false;", "+\t\t}", "+", "+\t\tif (parameterCount > -1) {", "+\t\t\tString[] arguments = Signature.getParameterTypes(methodDescriptor);", "+\t\t\tif (parameterCount != arguments.length) return false;", "+\t\t\tfor (int i = 0; i < parameterCount; i++)", "+\t\t\t\tif (!matchesType(this.parameterSimpleNames[i], this.parameterQualifications[i], Signature.toString(arguments[i]).toCharArray()))", "+\t\t\t\t\treturn false;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c59a0619ea664f0d552d1050e2c6fa27", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/FieldReferencePattern.java", "commitBeforeChange": "948661c4cb198af70b598b9954e5159cb73d7234", "commitAfterChange": "b1348e3d0230a581c7eb25acd6ec072853b12bb0", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": "\r protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "diff": ["-\tlocator.reportAccurateReference(reference.sourceStart, reference.sourceEnd, new char[][] {this.name}, element, accuracy);\r", "+\tif (reference instanceof QualifiedNameReference) {\r", "+\t\tQualifiedNameReference qNameRef = (QualifiedNameReference)reference;\r", "+\t\tint length = qNameRef.tokens.length;\r", "+\t\tint[] accuracies = new int[length];\r", "+\t\tBinding binding = qNameRef.binding;\r", "+\t\tint indexOfFirstFieldBinding = qNameRef.indexOfFirstFieldBinding > 0 ? qNameRef.indexOfFirstFieldBinding : 1;\r", "+\t\t// first token\r", "+\t\tif (this.matchesName(this.name, qNameRef.tokens[indexOfFirstFieldBinding-1])) {\r", "+\t\t\tFieldBinding fieldBinding =\r", "+\t\t\t\tbinding instanceof FieldBinding ?\r", "+\t\t\t\t\t (FieldBinding)binding :\r", "+\t\t\t\t\t null;\r", "+\t\t\tint level = this.matchLevel(fieldBinding);\r", "+\t\t\tswitch (level) {\r", "+\t\t\t\tcase ACCURATE_MATCH:\r", "+\t\t\t\t\taccuracies[0] = IJavaSearchResultCollector.EXACT_MATCH;\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase INACCURATE_MATCH:\r", "+\t\t\t\t\taccuracies[0] = IJavaSearchResultCollector.POTENTIAL_MATCH;\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tdefault:\r", "+\t\t\t\t\taccuracies[0] = -1;\r", "+\t\t\t}\r", "+\t\t} else {\r", "+\t\t\taccuracies[0] = -1;\r", "+\t\t}\r", "+\t\t// other tokens\r", "+\t\tfor (int i = qNameRef.indexOfFirstFieldBinding; i < length; i++){\r", "+\t\t\tchar[] token = qNameRef.tokens[i];\r", "+\t\t\tif (this.matchesName(this.name, token)) {\r", "+\t\t\t\tFieldBinding otherBinding = qNameRef.otherBindings == null ? null : qNameRef.otherBindings[i-indexOfFirstFieldBinding];\r", "+\t\t\t\tint level = this.matchLevel(otherBinding);\r", "+\t\t\t\tswitch (level) {\r", "+\t\t\t\t\tcase ACCURATE_MATCH:\r", "+\t\t\t\t\t\taccuracies[i] = IJavaSearchResultCollector.EXACT_MATCH;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase INACCURATE_MATCH:\r", "+\t\t\t\t\t\taccuracies[i] = IJavaSearchResultCollector.POTENTIAL_MATCH;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tdefault:\r", "+\t\t\t\t\t\taccuracies[i] = -1;\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\taccuracies[i] = -1;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tlocator.reportAccurateReference(\r", "+\t\t\treference.sourceStart, \r", "+\t\t\treference.sourceEnd, \r", "+\t\t\tnew char[][] {this.name}, \r", "+\t\t\telement, \r", "+\t\t\taccuracies,\r", "+\t\t\ttrue); // accuracy starts on first token\r", "+\t} else {\r", "+\t\tlocator.reportAccurateReference(reference.sourceStart, reference.sourceEnd, new char[][] {this.name}, element, accuracy);\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d48f4a2c89c7123ccfb53b61cec90320", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tprivate boolean selectDeclaration(TypeDeclaration typeDeclaration, char[] assistIdentifier, char[] packageName)", "signatureAfterChange": " \tprivate boolean selectDeclaration(TypeDeclaration typeDeclaration, char[] assistIdentifier, char[] packageName)", "diff": ["+\t\t\t", "+\t\t\t", "+\t\t\tTypeParameter[] methodTypeParameters = method.typeParameters();", "+\t\t\tfor (int j = 0, length2 = methodTypeParameters == null ? 0 : methodTypeParameters.length; j < length2; j++){", "+\t\t\t\tTypeParameter methodTypeParameter = methodTypeParameters[j];", "+\t\t\t\t", "+\t\t\t\tif(methodTypeParameter.name == assistIdentifier) {", "+\t\t\t\t\tchar[] qualifiedSourceName = null;", "+\t\t\t\t\t", "+\t\t\t\t\tTypeDeclaration enclosingType = typeDeclaration;", "+\t\t\t\t\twhile(enclosingType != null) {", "+\t\t\t\t\t\tqualifiedSourceName = CharOperation.concat(enclosingType.name, qualifiedSourceName, '.');", "+\t\t\t\t\t\tenclosingType = enclosingType.enclosingType;", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\tthis.requestor.acceptMethodTypeParameter(", "+\t\t\t\t\t\tpackageName,", "+\t\t\t\t\t\tqualifiedSourceName,", "+\t\t\t\t\t\tmethod.selector,", "+\t\t\t\t\t\tnull, // SelectionRequestor does not need of parameters type for declaration", "+\t\t\t\t\t\tnull, // SelectionRequestor does not need of parameters type for declaration", "+\t\t\t\t\t\tmethod.isConstructor(),", "+\t\t\t\t\t\tmethodTypeParameter.name,", "+\t\t\t\t\t\ttrue,", "+\t\t\t\t\t\tthis.actualSelectionStart,", "+\t\t\t\t\t\tthis.actualSelectionEnd);", "+\t\t\t\t\t", "+\t\t\t\t\tthis.noProposal = false;", "+\t\t\t\t\treturn true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t", "+\t\tTypeParameter[] typeParameters = typeDeclaration.typeParameters;", "+\t\tfor (int i = 0, length = typeParameters == null ? 0 : typeParameters.length; i < length; i++){", "+\t\t\tTypeParameter typeParameter = typeParameters[i];", "+\t\t\tif(typeParameter.name == assistIdentifier) {", "+\t\t\t\tchar[] qualifiedSourceName = null;", "+\t\t\t\t", "+\t\t\t\tTypeDeclaration enclosingType = typeDeclaration;", "+\t\t\t\twhile(enclosingType != null) {", "+\t\t\t\t\tqualifiedSourceName = CharOperation.concat(enclosingType.name, qualifiedSourceName, '.');", "+\t\t\t\t\tenclosingType = enclosingType.enclosingType;", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tthis.requestor.acceptTypeParameter(", "+\t\t\t\t\tpackageName,", "+\t\t\t\t\tqualifiedSourceName,", "+\t\t\t\t\ttypeParameter.name,", "+\t\t\t\t\ttrue,", "+\t\t\t\t\tthis.actualSelectionStart,", "+\t\t\t\t\tthis.actualSelectionEnd);", "+\t\t\t\t", "+\t\t\t\tthis.noProposal = false;", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t}", "+\t\t"]}], "num": 34116}