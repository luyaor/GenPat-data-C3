{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bb089eb41418201e480f1d3c4cd501f1", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "28fba4c5571c41d4f5676a5ac11628f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "37b393962270992362b04cbe26e00f2658c11b4c", "commitAfterChange": "c62f0c1bab5e955aabde01c278daeb6c0b3de6ab", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t\t\tTypeBinding expectedType = null;", "+\t\t\t\t\tTypeBinding expectedType = null;", "-\t\t\t\t\tif (expectedType == null) expectedType = scope.getJavaLangObject(); // assume Object by default", "+\t\t\t\t\tif (expectedType != null) {", "+\t\t\t\t\t\t// record it was explicit from context, as opposed to assumed by default (see below)", "+\t\t\t\t\t\tinferenceContext.hasExplicitExpectedType = true; ", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\texpectedType = scope.getJavaLangObject(); // assume Object by default", "+\t\t\t\t\t}", "+\t\t\t\t\tinferenceContext.expectedType = expectedType;", "-\t\t\t\tmethodSubstitute = methodSubstitute.inferFromExpectedType(scope, expectedType, inferenceContext);", "+\t\t\t\tmethodSubstitute = methodSubstitute.inferFromExpectedType(scope, inferenceContext);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f36f11b0854168618a9d4e91226d074a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "bfbf3f49a0dcb5eb58a64e930945ffa64c1495d2", "commitAfterChange": "2530ef5c12660a11a10ed9656ad746e180fd0c24", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t\t\tmethodSubstitute.inferFromExpectedType(", "-\t\t\t\t\t\t// 15.12.2.8 - if no expected type, then assume Object", "-\t\t\t\t\t\texpectedType == null ? scope.getJavaLangObject() : expectedType, ", "-\t\t\t\t\t\tscope);", "+\t\t\t\tif (expectedType == null) {", "+\t\t\t\t\t// 15.12.2.8 - if no expected type, then assume Object", "+\t\t\t\t\t// actually it rather seems to handle the returned variable case by expecting its erasure instead", "+\t\t\t\t\tif (methodSubstitute.returnType.isTypeVariable()) {", "+\t\t\t\t\t\texpectedType = methodSubstitute.returnType.erasure();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\texpectedType =scope.getJavaLangObject(); ", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tmethodSubstitute.inferFromExpectedType(expectedType, scope);"]}], "num": 48224}