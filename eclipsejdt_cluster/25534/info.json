{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ea741cd6300ec8282951c723cb3d7689", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0a3adc5f4c3db86481ea1c73683fc957", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "e0d288b4c5d221af1fb44c4eee4c4a8f6aec1f71", "commitAfterChange": "9f1b0fdafed3069249aac13c0e22c34d0cdf6455", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\t\t\t\t\t\t\tif (interfaceMethod != null) {", "+\t\t\t\t\t\t\t\tif (interfaceMethod != null && interfaceMethod.isValidBinding()) {", "-\t\t\t\tif (interfaceMethod != null) {", "+\t\t\t\tif (interfaceMethod != null && interfaceMethod.isValidBinding()) {", "-\t\t\t\tif (interfaceMethod != null) {", "+\t\t\t\tif (interfaceMethod != null && interfaceMethod.isValidBinding()) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46294686aa9732260c79206c652b1c58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "7e00ac35502a1ca240692e402a21abc4965fcca3", "commitAfterChange": "d3df82b4b651a728dac7ad34ce68970057ee30f8", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void computeInheritedMethods()", "signatureAfterChange": " private void computeInheritedMethods()", "diff": ["-\t\t\t\t\tif (existingMethods != null)", "-\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++)", "-\t\t\t\t\t\t\tif (method.returnType == existingMethods[i].returnType)", "-\t\t\t\t\t\t\t\tif (method.areParametersEqual(existingMethods[i]))", "-\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\tif (existingMethods != null) {", "+\t\t\t\t\t\t// 30805 - non-visible (abstract) method still needs to be implemented even if similar method defined below (overridesPackageDefaultMethod) ", "+\t\t\t\t\t\tif (!(method.isDefault() && method.isAbstract() && (method.declaringClass.fPackage != type.fPackage))) { ", "+\t\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++)", "+\t\t\t\t\t\t\t\tif (method.returnType == existingMethods[i].returnType)", "+\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(existingMethods[i]))", "+\t\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "51b5d8011beb611ad8833033fd9336a8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java", "commitBeforeChange": "c85c898de3099d8d87b870385bc47667302c5e21", "commitAfterChange": "73c6d3ea7dc5df8e531fcab68ea3f39bbd288577", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode( \tBlockScope currentScope, \tFlowContext flowContext, \tFlowInfo flowInfo)", "diff": ["-\tpublic FlowInfo analyseCode(", "-\t\tBlockScope currentScope,", "-\t\tFlowContext flowContext,", "-\t\tFlowInfo flowInfo) {", "-\t\t// record setting a variable: various scenarii are possible, setting an array reference, ", "-\t\t// a field reference, a blank final field reference, a field of an enclosing instance or ", "-\t\t// just a local variable.", "-", "-\t\tLocalVariableBinding local = this.lhs.localVariableBinding();", "-\t\tint nullStatus = this.expression.nullStatus(flowInfo);", "-\t\tif (local != null && nullStatus == FlowInfo.NULL) {", "-\t\t\t\tflowContext.recordUsingNullReference(currentScope, local, this.lhs, FlowInfo.NON_NULL, flowInfo);", "+public FlowInfo analyseCode(", "+\tBlockScope currentScope,", "+\tFlowContext flowContext,", "+\tFlowInfo flowInfo) {", "+\t// record setting a variable: various scenarii are possible, setting an array reference, ", "+\t// a field reference, a blank final field reference, a field of an enclosing instance or ", "+\t// just a local variable.", "+\tLocalVariableBinding local = this.lhs.localVariableBinding();", "+\tint nullStatus = this.expression.nullStatus(flowInfo);", "+\tif (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {", "+\t\tif (nullStatus == FlowInfo.NULL) {", "+\t\t\tflowContext.recordUsingNullReference(currentScope, local, this.lhs, ", "+\t\t\t\tFlowContext.CAN_ONLY_NULL, flowInfo);", "-\t\tflowInfo = ((Reference) lhs)", "-\t\t\t.analyseAssignment(currentScope, flowContext, flowInfo, this, false)", "-\t\t\t.unconditionalInits();", "-\t\tif (local != null) {", "-\t\t\tswitch(nullStatus) {", "-\t\t\t\tcase FlowInfo.NULL :", "-\t\t\t\t\tflowInfo.markAsDefinitelyNull(local);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase FlowInfo.NON_NULL :", "-\t\t\t\t\tflowInfo.markAsDefinitelyNonNull(local);", "-\t\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}\t\t", "-\t\treturn flowInfo;", "+\tflowInfo = ((Reference) lhs)", "+\t\t.analyseAssignment(currentScope, flowContext, flowInfo, this, false)", "+\t\t.unconditionalInits();", "+\tif (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {", "+\t\tswitch(nullStatus) {", "+\t\t\tcase FlowInfo.NULL :", "+\t\t\t\tflowInfo.markAsDefinitelyNull(local);", "+\t\t\t\tbreak;", "+\t\t\tcase FlowInfo.NON_NULL :", "+\t\t\t\tflowInfo.markAsDefinitelyNonNull(local);", "+\t\t\t\tbreak;", "+\t\t\tdefault:", "+\t\t\t\tflowInfo.markAsDefinitelyUnknown(local);", "+\t\t}", "+\t}\t\t", "+\treturn flowInfo;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "73d7d0637a5e0d583a1e0c6969624cad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "4f899ed65a6db0134a5169430983a39f00dbaf4c", "commitAfterChange": "302ba575da16bb6fb5610129dd618d637661239d", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] allInheritedMethods)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] allInheritedMethods)", "diff": ["-\t\t\t} else {", "+\t\t\t} else if (inheritedMethod.isPublic() || !type.isInterface()) {", "+\t\t\t\t// interface I { @Override Object clone(); } does not override Object#clone()", "-\t\t\tif (!areReturnTypesCompatible(currentMethod, inheritedMethod))", "+\t\t\tif (!areReturnTypesCompatible(currentMethod, inheritedMethod)", "+\t\t\t\t\t&& (currentMethod.returnType.tagBits & TagBits.HasMissingType) == 0) {", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "785b267d517809ea3689acb6b7a1ac4f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "41f0eedac440a5a7408e664ba09866184ebddd55", "commitAfterChange": "e0b93cd9388950bd51950e07247cdecc9e3263df", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprivate void resolveThrowsTags(MethodScope methScope, boolean reportMissing)", "signatureAfterChange": " \tprivate void resolveThrowsTags(MethodScope methScope, boolean reportMissing)", "diff": ["-\t\t\t\t\tif (typeRef.resolvedType != null) { // flag only valid class name", "+\t\t\t\t\tif (typeRef.resolvedType != null && typeRef.resolvedType.isValidBinding()) { // flag only valid class name", "-\t\t\t\tif (typeBinding.isValidBinding() && typeBinding.isClass()) {", "+\t\t\t\tif (typeBinding != null && typeBinding.isValidBinding() && typeBinding.isClass()) {", "-\t\t\t\t\t\tif (exception.resolvedType != null) { // flag only valid class name", "+\t\t\t\t\t\tif (exception.resolvedType != null && exception.resolvedType.isValidBinding()) { // flag only valid class name"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "864a3bbc252d49142ec15f07fe6d345c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "fb8f376e81332a8e2eb0b6ab7b009417715a2326", "commitAfterChange": "504159d7229f244fe60c96f9b15d6167193a85b6", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \t \tpublic boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)", "signatureAfterChange": " \t \tpublic boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)", "diff": ["-\t\t\tif (!isNarrowing) tagAsUnnecessaryCast(scope, castType);", "+\t\t\tif (!isNarrowing && castType == this.resolvedType.leafComponentType()) { // do not tag as unnecessary when recursing through upper bounds", "+\t\t\t\ttagAsUnnecessaryCast(scope, castType);", "+\t\t\t}", "-\t\tif (!isNarrowing) tagAsUnnecessaryCast(scope, castType);", "+\t\tif (!isNarrowing && castType == this.resolvedType.leafComponentType()) { // do not tag as unnecessary when recursing through upper bounds", "+\t\t\ttagAsUnnecessaryCast(scope, castType);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "abd91d923fbfd2c9d87d78a5a9e31a6b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java", "commitBeforeChange": "c85c898de3099d8d87b870385bc47667302c5e21", "commitAfterChange": "73c6d3ea7dc5df8e531fcab68ea3f39bbd288577", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse)", "signatureAfterChange": " \tprivate void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse)", "diff": ["-\tpublic void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse) {", "+\tprivate void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse) {", "-\t\tif (local != null) {", "+\t\tif (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {", "-\t\tif (local != null) {", "+\t\tif (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c96ea8c007d577e4eec43ef7821ee05e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "6dc3139df48b05a697942ac75c097b0346555e03", "commitAfterChange": "68b132a771077222c8a489923225ada23ba86a6a", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod, LookupEnvironment env)", "signatureAfterChange": " protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod, LookupEnvironment env)", "diff": ["-\t\t\t} else if (sourceMethod != null && (parameter.tagBits & TagBits.AnnotationNonNull) != 0) {", "+\t\t\t} else if (sourceMethod != null && (parameter.tagBits & TagBits.AnnotationNonNull) != 0", "+\t\t\t\t\t\t\t&& sourceMethod.arguments[i].hasNullTypeAnnotation()) {", "-\t\t} else if (sourceMethod != null && (this.returnType.tagBits & TagBits.AnnotationNonNull) != 0) {", "+\t\t} else if (sourceMethod instanceof MethodDeclaration && (this.returnType.tagBits & TagBits.AnnotationNonNull) != 0 ", "+\t\t\t\t\t\t&& ((MethodDeclaration)sourceMethod).hasNullTypeAnnotation()) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ca002cf4b991d4baac98e381d6930d88", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "0d572e21d0471752d40a14d0e46feeba076c749a", "commitAfterChange": "c6bc0e9452fe67df7425d9508d5f53a0b8c2038f", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  protected void findSourceFiles(IResourceDelta sourceDelta, ClasspathMultiDirectory md, int segmentCount) throws CoreException", "signatureAfterChange": "  protected void findSourceFiles(IResourceDelta sourceDelta, ClasspathMultiDirectory md, int segmentCount) throws CoreException", "diff": ["-\t\t\t\t\t\tif ((sourceDelta.getFlags() & IResourceDelta.CONTENT) == 0)", "+\t\t\t\t\t\tif ((sourceDelta.getFlags() & IResourceDelta.CONTENT) == 0", "+\t\t\t\t\t\t\t\t&& (sourceDelta.getFlags() & IResourceDelta.ENCODING) == 0)", "-\t\t\t\t\t\tif ((sourceDelta.getFlags() & IResourceDelta.CONTENT) == 0)", "+\t\t\t\t\t\tif ((sourceDelta.getFlags() & IResourceDelta.CONTENT) == 0", "+\t\t\t\t\t\t\t\t&& (sourceDelta.getFlags() & IResourceDelta.ENCODING) == 0)"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc4639ad5e83f66c2d222a4ac6f466ea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "83393c42b2bb8a7100c4a42bf5cd8fe234436ee5", "commitAfterChange": "8962621085b2247c6ff805ec82d289a9a0613a10", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public static void checkNeedForArgumentCasts(BlockScope scope, int operator, int operatorSignature, Expression left, int leftTypeId, boolean leftIsCast, Expression right, int rightTypeId, boolean rightIsCast)", "signatureAfterChange": " public static void checkNeedForArgumentCasts(BlockScope scope, int operator, int operatorSignature, Expression left, int leftTypeId, boolean leftIsCast, Expression right, int rightTypeId, boolean rightIsCast)", "diff": ["-\t\t\tif ((alternateLeftTypeId = alternateLeftType.id) == leftTypeId) { // obvious identity cast", "+\t\t\tif ((alternateLeftTypeId = alternateLeftType.id) == leftTypeId || scope.environment().computeBoxingType(alternateLeftType).id == leftTypeId) { // obvious identity cast", "-\t\t\tif ((alternateRightTypeId = alternateRightType.id) == rightTypeId) { // obvious identity cast", "+\t\t\tif ((alternateRightTypeId = alternateRightType.id) == rightTypeId || scope.environment().computeBoxingType(alternateRightType).id == rightTypeId) { // obvious identity cast"]}], "num": 25534}