{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "daee67a08a417847613360d29a1dacde", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8a93d185f5ab1038c822d27ea97886a2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java", "commitBeforeChange": "8a55616a15f0e12ee24162781746f45ed8c24b78", "commitAfterChange": "d7c285a09f8cde2ba05e7f838f10ce545b90c736", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \t\r \tpublic void checkExceptionHandlers(\r \t\tTypeBinding[] raisedExceptions,\r \t\tAstNode location,\r \t\tFlowInfo flowInfo,\r \t\tBlockScope scope)", "signatureAfterChange": "\r \t\r \tpublic void checkExceptionHandlers(\r \t\tTypeBinding[] raisedExceptions,\r \t\tAstNode location,\r \t\tFlowInfo flowInfo,\r \t\tBlockScope scope)", "diff": ["-\t\t\t\t\t\t\t\tswitch (scope.compareTypes(raisedException, caughtException)) {\r", "+\t\t\t\t\t\t\t\tswitch (Scope.compareTypes(raisedException, caughtException)) {\r", "+\t\t\t\t\t// anonymous constructors are allowed to throw any exceptions (their thrown exceptions\r", "+\t\t\t\t\t// clause will be fixed up later as per JLS 8.6).\r", "+\t\t\t\t\tif (exceptionContext.associatedNode instanceof AbstractMethodDeclaration){\r", "+\t\t\t\t\t\tAbstractMethodDeclaration method = (AbstractMethodDeclaration)exceptionContext.associatedNode;\r", "+\t\t\t\t\t\tif (method.isConstructor() \r", "+\t\t\t\t\t\t\t&& method.binding.declaringClass.isAnonymousType()\r", "+\t\t\t\t\t\t\t&& scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4){\r", "+\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\tfor (int i = 0; i < raisedCount; i++) {\r", "+\t\t\t\t\t\t\t\tTypeBinding raisedException;\r", "+\t\t\t\t\t\t\t\tif ((raisedException = raisedExceptions[i]) != null) {\r", "+\t\t\t\t\t\t\t\t\t// only required for actually thrown exceptions\r", "+\t\t\t\t\t\t\t\t\tif (!flowInfo.isDeadEnd() && !flowInfo.isFakeReachable()){\r", "+\t\t\t\t\t\t\t\t\t\texceptionContext.mergeUnhandledException(raisedException);\r", "+\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\treturn; // no need to complain, will fix up constructor exceptions\t\t\t\t\t\t\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tbreak; // not handled anywhere, thus jump to error handling\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e6ef25dfc987cceb552a1ef2f80fb7f4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java", "commitBeforeChange": "8a55616a15f0e12ee24162781746f45ed8c24b78", "commitAfterChange": "d7c285a09f8cde2ba05e7f838f10ce545b90c736", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r \r \tpublic void checkExceptionHandlers(\r \t\tTypeBinding raisedException,\r \t\tAstNode location,\r \t\tFlowInfo flowInfo,\r \t\tBlockScope scope)", "signatureAfterChange": "\r \r \tpublic void checkExceptionHandlers(\r \t\tTypeBinding raisedException,\r \t\tAstNode location,\r \t\tFlowInfo flowInfo,\r \t\tBlockScope scope)", "diff": ["-\t\t\t\t\t\tswitch (scope.compareTypes(raisedException, caughtException)) {\r", "+\t\t\t\t\t\tswitch (Scope.compareTypes(raisedException, caughtException)) {\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\t// anonymous constructors are allowed to throw any exceptions (their thrown exceptions\r", "+\t\t\t\t\t// clause will be fixed up later as per JLS 8.6).\r", "+\t\t\t\t\tif (exceptionContext.associatedNode instanceof AbstractMethodDeclaration){\r", "+\t\t\t\t\t\tAbstractMethodDeclaration method = (AbstractMethodDeclaration)exceptionContext.associatedNode;\r", "+\t\t\t\t\t\tif (method.isConstructor() \r", "+\t\t\t\t\t\t\t&& method.binding.declaringClass.isAnonymousType()\r", "+\t\t\t\t\t\t\t&& scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4){\r", "+\t\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t// only required for actually thrown exceptions\r", "+\t\t\t\t\t\t\tif (!flowInfo.isDeadEnd() && !flowInfo.isFakeReachable()){\r", "+\t\t\t\t\t\t\t\texceptionContext.mergeUnhandledException(raisedException);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\treturn; // no need to complain, will fix up constructor exceptions\t\t\t\t\t\t\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r"]}], "num": 22734}