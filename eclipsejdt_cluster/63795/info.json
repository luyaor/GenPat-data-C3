{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "34bd029e731117100a9271d29589e3c9", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09c732ea55e2ff58dc8c49f8a98d716a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java", "commitBeforeChange": "888ff915accf0f7dc08ba845bca467c94f1e290b", "commitAfterChange": "f69c200469412ca3b93e80844c6c1f4e077169ac", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 73, "signatureBeforeChange": " public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException", "signatureAfterChange": " public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException", "diff": ["- */", "-public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException {", "-\t", "-\t// if factory is null, default factory must be used", "-\tif (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();", "-", "-\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t", "-\t// In order to be shared, working copies have to denote the same compilation unit ", "-\t// AND use the same buffer factory.", "-\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "-\tMap sharedWorkingCopies = manager.sharedWorkingCopies;", "-\t", "-\tMap perFactoryWorkingCopies = (Map) sharedWorkingCopies.get(factory);", "-\tif (perFactoryWorkingCopies == null){", "-\t\tperFactoryWorkingCopies = new HashMap();", "-\t\tsharedWorkingCopies.put(factory, perFactoryWorkingCopies);", "-\t}", "-\tWorkingCopy workingCopy = (WorkingCopy)perFactoryWorkingCopies.get(this);", "-\tif (workingCopy != null) {", "-\t\tworkingCopy.useCount++;", "-", "-\t\tif (SHARED_WC_VERBOSE) {", "-\t\t\tSystem.out.println(\"Incrementing use count of shared working copy \" + workingCopy.toStringWithAncestors()); //$NON-NLS-1$", "-\t\t}", "-", "-\t\treturn workingCopy;", "-\t} else {", "-\t\tCreateWorkingCopyOperation op = new CreateWorkingCopyOperation(this, perFactoryWorkingCopies, factory, problemRequestor);", "-\t\trunOperation(op, pm);", "-\t\treturn op.getResultElements()[0];", "-\t}", "-}", "+ */", "+public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException {", "+\t", "+\tif (isWorkingCopy()) return this;", "+\t", "+\t// if factory is null, default factory must be used", "+\tif (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();", "+", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\t", "+\t// In order to be shared, working copies have to denote the same compilation unit ", "+\t// AND use the same buffer factory.", "+\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "+\tMap sharedWorkingCopies = manager.sharedWorkingCopies;", "+\t", "+\tCompilationUnitOwner workingCopyOwner = new DefaultCompilationUnitOwner(factory, problemRequestor);", "+\tMap perOwnerWorkingCopies = (Map) sharedWorkingCopies.get(workingCopyOwner);", "+\tif (perOwnerWorkingCopies == null){", "+\t\tperOwnerWorkingCopies = new HashMap();", "+\t\tsharedWorkingCopies.put(workingCopyOwner, perOwnerWorkingCopies);", "+\t}", "+\tCompilationUnit workingCopy = (CompilationUnit)perOwnerWorkingCopies.get(this);", "+\tif (workingCopy != null) {", "+\t\tObject info = manager.getInfo(workingCopy);", "+\t\tif (info instanceof WorkingCopyElementInfo) {", "+\t\t\t((WorkingCopyElementInfo)info).incrementUseCount();", "+", "+\t\t\tif (SHARED_WC_VERBOSE) {", "+\t\t\t\tSystem.out.println(\"Incrementing use count of shared working copy \" + workingCopy.toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\t}", "+", "+\t\t\treturn workingCopy;", "+\t\t}", "+\t} ", "+\tworkingCopy = new CompilationUnit((IPackageFragment)getParent(), getElementName(), workingCopyOwner);", "+\tBecomeWorkingCopyOperation op = new BecomeWorkingCopyOperation(workingCopy, perOwnerWorkingCopies);", "+\trunOperation(op, pm);", "+\treturn workingCopy;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "103b6bac16f2dcf7aa08ad7988a8e0be", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java", "commitBeforeChange": "888ff915accf0f7dc08ba845bca467c94f1e290b", "commitAfterChange": "f69c200469412ca3b93e80844c6c1f4e077169ac", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 46, "signatureBeforeChange": " public IJavaElement findSharedWorkingCopy(IBufferFactory factory)", "signatureAfterChange": " public IJavaElement findSharedWorkingCopy(IBufferFactory factory)", "diff": ["- */", "-public IJavaElement findSharedWorkingCopy(IBufferFactory factory) {", "-", "-\t// if factory is null, default factory must be used", "-\tif (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();", "-", "-\t// In order to be shared, working copies have to denote the same compilation unit ", "-\t// AND use the same buffer factory.", "-\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "-\tMap sharedWorkingCopies = JavaModelManager.getJavaModelManager().sharedWorkingCopies;", "-\t", "-\tMap perFactoryWorkingCopies = (Map) sharedWorkingCopies.get(factory);", "-\tif (perFactoryWorkingCopies == null) return null;", "-\treturn (WorkingCopy)perFactoryWorkingCopies.get(this);", "-}", "+ */", "+public IJavaElement findSharedWorkingCopy(IBufferFactory factory) {", "+", "+\t// if factory is null, default factory must be used", "+\tif (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();", "+", "+\t// In order to be shared, working copies have to denote the same compilation unit ", "+\t// AND use the same buffer factory.", "+\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "+\tMap sharedWorkingCopies = JavaModelManager.getJavaModelManager().sharedWorkingCopies;", "+\t", "+\tCompilationUnitOwner workingCopyOwner = new DefaultCompilationUnitOwner(factory, null);", "+\tMap perFactoryWorkingCopies = (Map) sharedWorkingCopies.get(workingCopyOwner);", "+\tif (perFactoryWorkingCopies == null) return null;", "+\treturn (CompilationUnit)perFactoryWorkingCopies.get(this);", "+}"]}], "num": 63795}