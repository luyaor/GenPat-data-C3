{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "71675667a155e26279a0c8273a44e67e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "33ed7068b982211d3c0726867525028c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "67da1da15e9afbcd33679f07597c706e7915cf4a", "commitAfterChange": "027fccb2c17e0f0d2b28705c6704af10fc8ce0aa", "methodNumberBeforeChange": 49, "methodNumberAfterChange": 49, "signatureBeforeChange": " \tprivate void computeExpectedTypes(AstNode parent, Scope scope)", "signatureAfterChange": " \tprivate void computeExpectedTypes(AstNode parent, Scope scope)", "diff": ["-\t\tint expectedTypeCount = 0;", "-\t\texpectedTypes = new TypeBinding[1];", "+\t\t// default filter", "+\t\texpectedTypesFilter = SUBTYPE;", "+\t\t", "+\t\t// find types from parent", "-\t\t\t\texpectedTypes[expectedTypeCount++] = binding;", "+\t\t\t\taddExpectedType(binding);", "-\t\t\t\texpectedTypes[expectedTypeCount++] = binding;", "+\t\t\t\taddExpectedType(binding);", "-\t\t\t\texpectedTypes[expectedTypeCount++] = binding;", "+\t\t\t\taddExpectedType(binding);", "+\t\t\t}", "+\t\t} else if(parent instanceof CastExpression) {", "+\t\t\tExpression e = ((CastExpression)parent).type;", "+\t\t\tTypeBinding binding = e.expressionType;", "+\t\t\tif(binding != null){", "+\t\t\t\taddExpectedType(binding);", "+\t\t\t\texpectedTypesFilter = SUBTYPE | SUPERTYPE;", "+\t\t\t}", "+\t\t} else if(parent instanceof MessageSend) {", "+\t\t\tMessageSend messageSend = (MessageSend) parent;", "+\t\t\t", "+\t\t\tReferenceBinding binding = (ReferenceBinding)messageSend.receiverType;", "+\t\t\tboolean isStatic = messageSend.receiver.isTypeReference();", "+\t\t\t", "+\t\t\twhile(binding != null) {\t", "+\t\t\t\tcomputeExpectedTypesForMessageSend(", "+\t\t\t\t\tbinding,", "+\t\t\t\t\tmessageSend.selector,", "+\t\t\t\t\tmessageSend.arguments,", "+\t\t\t\t\t(ReferenceBinding)messageSend.receiverType,", "+\t\t\t\t\tscope,", "+\t\t\t\t\tmessageSend,", "+\t\t\t\t\tisStatic);", "+\t\t\t\tcomputeExpectedTypesForMessageSendForInterface(", "+\t\t\t\t\tbinding,", "+\t\t\t\t\tmessageSend.selector,", "+\t\t\t\t\tmessageSend.arguments,", "+\t\t\t\t\t(ReferenceBinding)messageSend.receiverType,", "+\t\t\t\t\tscope,", "+\t\t\t\t\tmessageSend,", "+\t\t\t\t\tisStatic);", "+\t\t\t\tbinding = binding.superclass();", "+\t\t\t}", "+\t\t} else if(parent instanceof AllocationExpression) {", "+\t\t\tAllocationExpression allocationExpression = (AllocationExpression) parent;", "+\t\t\t", "+\t\t\tReferenceBinding binding = (ReferenceBinding)allocationExpression.type.binding;", "+", "+\t\t\tif(binding != null) {\t", "+\t\t\t\tcomputeExpectedTypesForAllocationExpression(", "+\t\t\t\t\tbinding,", "+\t\t\t\t\tallocationExpression.arguments,", "+\t\t\t\t\tscope,", "+\t\t\t\t\tallocationExpression);", "-\t\tSystem.arraycopy(expectedTypes, 0, expectedTypes = new TypeBinding[expectedTypeCount], 0, expectedTypeCount);", "+\t\tif(expectedTypesCount + 1 != expectedTypes.length) {", "+\t\t\tSystem.arraycopy(expectedTypes, 0, expectedTypes = new TypeBinding[expectedTypesCount + 1], 0, expectedTypesCount + 1);", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e5f9872739f6ca7711ed0f3db6620ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java", "commitBeforeChange": "8f261bb6c49278e86707910a4be5450c713c940a", "commitAfterChange": "b5977e771dcaa856815c805c4cdc6cf2a2c18650", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowInfo)", "signatureAfterChange": " public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowInfo)", "diff": ["-\t\t\tExpression expression = this.nullReferences[i];", "+\t\t\tASTNode location = this.nullReferences[i];", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableNullComparedToNonNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableNullComparedToNonNull(local, location);", "+\t\t\t\t\tExpression expression = (Expression)location;", "-\t\t\t\t\t\tscope.problemReporter().variableNullReference(local, expression);", "+\t\t\t\t\t\tscope.problemReporter().variableNullReference(local, location);", "-\t\t\t\t\tthis.parent.recordNullityMismatch(scope, expression, flowInfo.nullStatus(local), this.expectedTypes[i]);", "+\t\t\t\t\tthis.parent.recordNullityMismatch(scope, (Expression)location, flowInfo.nullStatus(local), this.expectedTypes[i]);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase EXIT_RESOURCE:", "+\t\t\t\t\tif (local instanceof LocalVariableBinding) {", "+\t\t\t\t\t\tFakedTrackingVariable trackingVar = ((LocalVariableBinding) local).closeTracker;", "+\t\t\t\t\t\tif (trackingVar != null) {", "+\t\t\t\t\t\t\tif (trackingVar.hasDefinitelyNoResource(flowInfo)) {", "+\t\t\t\t\t\t\t\tcontinue; // no resource - no warning.", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (trackingVar.isClosedInFinallyOfEnclosing(scope)) {", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.parent.recordExitAgainstResource(scope, flowInfo, trackingVar, location)) {", "+\t\t\t\t\t\t\t\tthis.nullReferences[i] = null;", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\tthis.parent.recordUsingNullReference(scope, local, expression,", "+\t\t\tthis.parent.recordUsingNullReference(scope, local, location,", "-\t\t\tExpression expression = this.nullReferences[i];", "+\t\t\tASTNode location = this.nullReferences[i];", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, location);", "+\t\t\t\t\tExpression expression = (Expression) location;", "-\t\t\t\t\t\tscope.problemReporter().variableNullReference(local, expression);", "+\t\t\t\t\t\tscope.problemReporter().variableNullReference(local, location);", "-\t\t\t\t\t\tscope.problemReporter().variablePotentialNullReference(local, expression);", "+\t\t\t\t\t\tscope.problemReporter().variablePotentialNullReference(local, location);", "-\t\t\t\t\t\tscope.problemReporter().nullityMismatch(expression, this.expectedTypes[i], nullStatus, annotationName);", "+\t\t\t\t\t\tscope.problemReporter().nullityMismatch((Expression) location, this.expectedTypes[i], nullStatus, annotationName);", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase EXIT_RESOURCE:", "+\t\t\t\t\tnullStatus = flowInfo.nullStatus(local);", "+\t\t\t\t\tif (nullStatus != FlowInfo.NON_NULL && local instanceof LocalVariableBinding) {", "+\t\t\t\t\t\tFakedTrackingVariable closeTracker = ((LocalVariableBinding)local).closeTracker;", "+\t\t\t\t\t\tif (closeTracker != null) {", "+\t\t\t\t\t\t\tif (closeTracker.hasDefinitelyNoResource(flowInfo)) {", "+\t\t\t\t\t\t\t\tcontinue; // no resource - no warning.", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (closeTracker.isClosedInFinallyOfEnclosing(scope)) {", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tnullStatus = closeTracker.findMostSpecificStatus(flowInfo, scope, null);", "+\t\t\t\t\t\t\tcloseTracker.recordErrorLocation(this.nullReferences[i], nullStatus);", "+\t\t\t\t\t\t\tcloseTracker.reportRecordedErrors(scope, nullStatus);", "+\t\t\t\t\t\t\tthis.nullReferences[i] = null;", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9224a77e3e13e759ba2c0756cc57c9c1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "8a765fa23ce703d1d5f2388d447ea40d7aad9f99", "commitAfterChange": "988b834a35e1571af05adddd8db1ce5aaa1f0ff0", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tif (use18specifics) { ", "-\t\t\tif (this.valueIfTrue.isPolyExpression()) // context propagated already.", "+\t\tif (use18specifics) {", "+\t\t\tif (this.expressionContext == ASSIGNMENT_CONTEXT || this.expressionContext == INVOCATION_CONTEXT) {", "+\t\t\t\t/* 15.25.3 : Where a poly reference conditional expression appears in a context of a particular kind with target ", "+\t\t\t\t   type T (5), its second and third operand expressions similarly appear in a context of the same kind with target", "+\t\t\t\t   type T. We eagerly propagate the context and target type here, but that should be harmless. Nonpoly expressions", "+\t\t\t\t   won't respond to it at all. If someone down below does get influenced, then the conditional is poly.", "+\t\t\t\t*/", "+\t\t\t\tthis.valueIfTrue.setExpressionContext(this.expressionContext);", "-\t\t\tif (this.valueIfFalse.isPolyExpression())", "+", "+\t\t\t\tthis.valueIfFalse.setExpressionContext(this.expressionContext);", "+\t\t\t}", "+\t\tif (use18specifics && this.expectedType != null) { // so the story is still untold for invocations.", "+\t\t\t", "+\t\t\t    TypeBinding trueType = originalValueIfTrueType;", "+\t\t\t    TypeBinding falseType = originalValueIfFalseType;", "+\t\t\t    if (this.valueIfTrue instanceof MessageSend) {", "+\t\t\t    \tMessageSend message = (MessageSend) this.valueIfTrue;", "+\t\t\t    \tif (message.binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t    \t\tParameterizedGenericMethodBinding pgmb = (ParameterizedGenericMethodBinding) message.binding;", "+\t\t\t    \t\tif (pgmb.inferredReturnType) {", "+\t\t\t    \t\t\ttrueType = pgmb.original().returnType;", "+\t\t\t    \t\t}", "+\t\t\t    \t}", "+\t\t\t    }", "+\t\t\t    if (this.valueIfFalse instanceof MessageSend) {", "+\t\t\t    \tMessageSend message = (MessageSend) this.valueIfFalse;", "+\t\t\t    \tif (message.binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t    \t\tParameterizedGenericMethodBinding pgmb = (ParameterizedGenericMethodBinding) message.binding;", "+\t\t\t    \t\tif (pgmb.inferredReturnType) {", "+\t\t\t    \t\t\tfalseType = pgmb.original().returnType;", "+\t\t\t    \t\t}", "+\t\t\t    \t}", "+\t\t\t    }", "+\t\t\t    ", "+\t\t\t    if (!trueType.isPrimitiveOrBoxedPrimitiveType() || !falseType.isPrimitiveOrBoxedPrimitiveType()) { // reference conditional ==> poly expression.", "+\t\t\t    \tif (!originalValueIfTrueType.isCompatibleWith(this.expectedType, scope))", "+\t\t\t    \t\tscope.problemReporter().typeMismatchError(originalValueIfTrueType, this.expectedType, this.valueIfTrue, null);", "+\t\t\t    \tif (!originalValueIfFalseType.isCompatibleWith(this.expectedType, scope))", "+\t\t\t    \t\tscope.problemReporter().typeMismatchError(originalValueIfFalseType, this.expectedType, this.valueIfFalse, null);", "+\t\t\t    \t// 15.25.3: The type of a poly reference conditional expression is the same as its target type.", "+\t\t\t    \treturn this.resolvedType = this.expectedType;", "+\t\t\t    }", "+\t\t\t", "+\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a7ffd3027c9cfb98693fbd8f09bb3215", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "feb6545df47d2c5c5dddbb92489d5f562545b32e", "commitAfterChange": "f2175e743261684fe3de1337b02bb7bc5e74c85c", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 20, "signatureBeforeChange": "\r \tprotected boolean traverseDelta(IResourceDelta delta, int parentType)", "signatureAfterChange": "\r \tprotected boolean traverseDelta(IResourceDelta delta, int parentType, IJavaProject currentProject)", "diff": ["-\tprotected boolean traverseDelta(IResourceDelta delta, int parentType) {\r", "+\tprotected boolean traverseDelta(IResourceDelta delta, int parentType, IJavaProject currentProject) {\r", "-\t\tboolean isOnClasspath = false;\r", "+\t\tIPath fullPath = res.getFullPath();\r", "+\t\tIJavaProject projectOfRoot = (IJavaProject)this.roots.get(fullPath);\r", "-\t\tswitch (parentType) {\r", "-\t\t\tcase IJavaElement.JAVA_MODEL:\r", "-\t\t\tcase IJavaElement.JAVA_PROJECT:\r", "-\t\t\t\tisOnClasspath = this.isOnClasspath(res.getFullPath());\r", "-\t\t\t\tif (isOnClasspath) {\r", "-\t\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT_ROOT;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\telementType = IJavaElement.JAVA_PROJECT; // not yet in a package fragment root\r", "-\t\t\t\t}\r", "-\t\t\t\tbreak;\r", "-\t\t\tcase IJavaElement.PACKAGE_FRAGMENT_ROOT:\r", "-\t\t\tcase IJavaElement.PACKAGE_FRAGMENT:\r", "-\t\t\t\tisOnClasspath = true;\r", "-\t\t\t\tif (res instanceof IFolder) {\r", "-\t\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tString extension = res.getFileExtension();\r", "-\t\t\t\t\tif (\"java\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "-\t\t\t\t\t\telementType = IJavaElement.COMPILATION_UNIT;\r", "-\t\t\t\t\t} else if (\"class\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "-\t\t\t\t\t\telementType = IJavaElement.CLASS_FILE;\r", "+\t\tif (projectOfRoot != null) {\r", "+\t\t\tcurrentProject = projectOfRoot;\r", "+\t\t\tif (parentType == IJavaElement.JAVA_MODEL && delta.getKind() != IResourceDelta.CHANGED) {\r", "+\t\t\t\t// project is added or removed\r", "+\t\t\t\telementType = IJavaElement.JAVA_PROJECT;\r", "+\t\t\t} else {\r", "+\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT_ROOT;\r", "+\t\t\t}\r", "+\t\t} else {\r", "+\t\t\tswitch (parentType) {\r", "+\t\t\t\tcase IJavaElement.JAVA_MODEL:\r", "+\t\t\t\tcase IJavaElement.JAVA_PROJECT:\r", "+\t\t\t\t\tif (currentProject != null) {\r", "+\t\t\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT_ROOT;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\telementType = IJavaElement.JAVA_PROJECT; // not yet in a package fragment root\r", "-\t\t\t\t}\r", "-\t\t\t\tbreak;\r", "-\t\t}\t\t\t\t\t\t\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase IJavaElement.PACKAGE_FRAGMENT_ROOT:\r", "+\t\t\t\tcase IJavaElement.PACKAGE_FRAGMENT:\r", "+\t\t\t\t\tif (res instanceof IFolder) {\r", "+\t\t\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tString extension = res.getFileExtension();\r", "+\t\t\t\t\t\tif (\"java\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "+\t\t\t\t\t\t\telementType = IJavaElement.COMPILATION_UNIT;\r", "+\t\t\t\t\t\t} else if (\"class\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "+\t\t\t\t\t\t\telementType = IJavaElement.CLASS_FILE;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t}\r", "+\t\t}\r", "-\t\tif (isOnClasspath) {\r", "+\t\tif (currentProject != null) {\r", "+\t\t\tif (this.currentElement == null || !this.currentElement.getJavaProject().equals(currentProject)) {\r", "+\t\t\t\t// force the currentProject to be used\r", "+\t\t\t\tthis.currentElement = (Openable)currentProject;\r", "+\t\t\t}\r", "+\t\tboolean result;\r", "-\t\t\t\tif (!traverseDelta(child, elementType)) {\r", "+\t\t\t\tif (!traverseDelta(child, elementType, currentProject)) {\r", "-\t\t\t\t\t\tif (isOnClasspath) { \r", "+\t\t\t\t\t\tif (currentProject != null) { \r", "+\t\t\t\t\t\t\t\tif (this.currentElement == null || !this.currentElement.getJavaProject().equals(currentProject)) {\r", "+\t\t\t\t\t\t\t\t\t// force the currentProject to be used\r", "+\t\t\t\t\t\t\t\t\tthis.currentElement = (Openable)currentProject;\r", "+\t\t\t\t\t\t\t\t}\r", "-\t\t\t\tJavaProject project = (JavaProject)JavaCore.getJavaCore().create(res.getProject());\r", "-\t\t\t\tif (project != null) {\r", "+\t\t\t\tJavaProject adoptiveProject = (JavaProject)JavaCore.getJavaCore().create(res.getProject());\r", "+\t\t\t\tif (adoptiveProject != null) {\r", "-\t\t\t\t\t\t\t\tnonJavaResourcesChanged(project, orphanChildren[i]);\r", "+\t\t\t\t\t\t\t\tnonJavaResourcesChanged(adoptiveProject, orphanChildren[i]);\r", "-\t\t\treturn isOnClasspath || oneChildOnClasspath;\r", "+\t\t\tresult = currentProject != null || oneChildOnClasspath;\r", "-\t\t\treturn \r", "-\t\t\t\tisOnClasspath \r", "+\t\t\tresult = \r", "+\t\t\t\tcurrentProject != null \r", "+\t\t\r", "+\t\t// other roots\r", "+\t\tHashSet set;\r", "+\t\tif ((set = (HashSet)this.otherRoots.get(fullPath)) != null) {\r", "+\t\t\tIterator iterator = set.iterator();\r", "+\t\t\twhile (iterator.hasNext()) {", "+\t\t\t\tIJavaProject project = (IJavaProject) iterator.next();", "+\t\t\t\tthis.cloneCurrentDelta(project, res);", "+\t\t\t}\r", "+\t\t}\r", "+\t\t\r", "+\t\treturn result;\r"]}], "num": 39038}