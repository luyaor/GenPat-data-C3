{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "07f1f4005bf0e23583040da8476403e0", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "73525f26d6d34bae19a0acb02f94eb51", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "6ee69a27bb90b4501869adce2a7020b0fadb9402", "commitAfterChange": "886d0f0c1c856616883aceae38186164d207f2a8", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprotected boolean parseReference() throws InvalidInputException", "signatureAfterChange": " \tprotected boolean parseReference() throws InvalidInputException", "diff": ["+\t\t\t\t\t\t\t// String reference are not allowed for @value tag", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "-\t\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "-\t\t\t\t\t\t\tif (typeRef != null) {", "-\t\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "-\t\t\t\t\t\t\t\tpreviousPosition = start;", "-\t\t\t\t\t\t\t\ttypeRef = null;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "-\t\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "-\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocUnexpectedText(this.scanner.currentPosition, this.lineEnd);", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// verify end line", "+\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocUnexpectedText(this.scanner.currentPosition, this.lineEnd);", "-\t\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "-\t\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "-\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\t\t\t\t\t// String reference are not allowed for @value tag", "+\t\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidValueReference(start, getIndexPosition());", "+\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\tif (this.tagValue != TAG_VALUE_VALUE && this.sourceParser != null) {", "-//\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidReference(start, this.lineEnd);", "-\t\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocUnexpectedText(this.scanner.currentPosition, this.lineEnd);", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// verify end line", "+\t\t\t\t\t\t\tif (verifyEndLine(previousPosition)) return true;", "+\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocUnexpectedText(this.scanner.currentPosition, this.lineEnd);", "-\t\t\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE && this.sourceParser != null) {", "-\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidValueReference(start, getIndexPosition());", "+\t\t\t\t\t\telse if (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidValueReference(start, getIndexPosition());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a2032ac2821e6aebad2f7ae25d00f1cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "66c4d7e89245a1968f7426f462a950cfd030c75f", "commitAfterChange": "2ac5935e329f05252aa80d99bbc2b0ab777d1cf5", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " public SyntheticMethodBinding addSyntheticBridgeMethod(MethodBinding inheritedMethodToBridge, MethodBinding localTargetMethod)", "signatureAfterChange": " public SyntheticMethodBinding addSyntheticBridgeMethod(MethodBinding inheritedMethodToBridge, MethodBinding localTargetMethod)", "diff": ["-\tif (inheritedMethodToBridge.returnType.erasure() == localTargetMethod.returnType.erasure())", "-\t\tif (inheritedMethodToBridge.areParameterErasuresEqual(localTargetMethod))", "+\tif (inheritedMethodToBridge.returnType.erasure() == localTargetMethod.returnType.erasure()", "+\t\t\t\t&& inheritedMethodToBridge.areParameterErasuresEqual(localTargetMethod)) {", "-", "+\t}", "-\t\t// TODO (philippe) MethodBindings do not implement equals() so how do we prevent adding 2 'equal' inherited methods?", "-\t\t\tObject method = synthMethods.next();", "-\t\t\tif (method instanceof MethodBinding)", "-\t\t\t\tif (inheritedMethodToBridge.returnType.erasure() == ((MethodBinding) method).returnType.erasure())", "-\t\t\t\t\tif (inheritedMethodToBridge.areParameterErasuresEqual((MethodBinding) method))", "-\t\t\t\t\t\treturn null;", "+\t\t\tObject synthetic = synthMethods.next();", "+\t\t\tif (synthetic instanceof MethodBinding) {", "+\t\t\t\tMethodBinding method = (MethodBinding) synthetic;", "+\t\t\t\tif (CharOperation.equals(inheritedMethodToBridge.selector, method.selector)", "+\t\t\t\t\t\t&& inheritedMethodToBridge.returnType.erasure() == method.returnType.erasure()", "+\t\t\t\t\t\t&& inheritedMethodToBridge.areParameterErasuresEqual(method)) {", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 68279}