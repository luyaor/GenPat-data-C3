{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2da5a16de95ad69e7e50056b45c426d0", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c6173c0b0e6a812cb6995c76e42809f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/HierarchyResolver.java", "commitBeforeChange": "673b7eda95cd26449992e862f0c63f2c612903a0", "commitAfterChange": "b04602938404af4f8569a399fb36a5018768a262", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r \r \tpublic void resolve(\r \t\tIGenericType[] suppliedTypes,\r \t\tICompilationUnit[] sourceUnits)", "signatureAfterChange": "\r \r public void resolve(IGenericType[] suppliedTypes, ICompilationUnit[] sourceUnits)", "diff": ["+\r", "+public void resolve(IGenericType[] suppliedTypes, ICompilationUnit[] sourceUnits) {\r", "+\ttry {\r", "+\t\tint suppliedLength = suppliedTypes == null ? 0 : suppliedTypes.length;\r", "+\t\tint sourceLength = sourceUnits == null ? 0 : sourceUnits.length;\r", "+\t\tCompilationUnitDeclaration[] units = new CompilationUnitDeclaration[suppliedLength + sourceLength];\r", "+\t\tint count = -1;\r", "+\t\tfor (int i = 0; i < suppliedLength; i++) {\r", "+\t\t\tif (suppliedTypes[i].isBinaryType()) {\r", "+\t\t\t\tIBinaryType binaryType = (IBinaryType) suppliedTypes[i];\r", "+\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\r", "+\t\t\t\t\tremember(binaryType, lookupEnvironment.cacheBinaryType(binaryType, false));\r", "+\t\t\t\t\t// classpath problem for this type: ignore\r", "+\t\t\t} else {\r", "+\t\t\t\t// must start with the top level type\r", "+\t\t\t\tISourceType topLevelType = (ISourceType) suppliedTypes[i];\r", "+\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\t\t\t\t\r", "+\t\t\t\twhile (topLevelType.getEnclosingType() != null)\r", "+\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();\r", "+\t\t\t\tCompilationResult result = new CompilationResult(topLevelType.getFileName(), i, suppliedLength);\r", "+\t\t\t\tunits[++count] = SourceTypeConverter.buildCompilationUnit(topLevelType, false, true, lookupEnvironment.problemReporter, result);\r", "-\r", "-\tpublic void resolve(\r", "-\t\tIGenericType[] suppliedTypes,\r", "-\t\tICompilationUnit[] sourceUnits) {\r", "-\t\ttry {\r", "-\t\t\tint suppliedLength = suppliedTypes == null ? 0 : suppliedTypes.length;\r", "-\t\t\tint sourceLength = sourceUnits == null ? 0 : sourceUnits.length;\r", "-\t\t\tCompilationUnitDeclaration[] units =\r", "-\t\t\t\tnew CompilationUnitDeclaration[suppliedLength + sourceLength];\r", "-\t\t\tint count = -1;\r", "-\t\t\tfor (int i = 0; i < suppliedLength; i++) {\r", "-\t\t\t\tif (suppliedTypes[i].isBinaryType()) {\r", "-\t\t\t\t\tIBinaryType binaryType = (IBinaryType) suppliedTypes[i];\r", "-\t\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\r", "+\t\t\t\tif (units[count] == null) {\r", "+\t\t\t\t\tcount--;\r", "+\t\t\t\t} else {\r", "-\t\t\t\t\t\tremember(binaryType, lookupEnvironment.cacheBinaryType(binaryType, false));\r", "+\t\t\t\t\t\tlookupEnvironment.buildTypeBindings(units[count]);\r", "+\t\t\t\t\t\trememberWithMemberTypes(topLevelType, units[count].types[0].binding);\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\t// must start with the top level type\r", "-\t\t\t\t\tISourceType topLevelType = (ISourceType) suppliedTypes[i];\r", "-\t\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\t\t\t\t\r", "-\t\t\t\t\twhile (topLevelType.getEnclosingType() != null)\r", "-\t\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();\r", "-\t\t\t\t\tCompilationResult result =\r", "-\t\t\t\t\t\tnew CompilationResult(topLevelType.getFileName(), i, suppliedLength);\r", "-\t\t\t\t\tunits[++count] =\r", "-\t\t\t\t\t\tSourceTypeConverter.buildCompilationUnit(\r", "-\t\t\t\t\t\t\ttopLevelType,\r", "-\t\t\t\t\t\t\tfalse,\r", "-\t\t\t\t\t\t\ttrue,\r", "-\t\t\t\t\t\t\tlookupEnvironment.problemReporter,\r", "-\t\t\t\t\t\t\tresult);\r", "-\r", "-\t\t\t\t\tif (units[count] == null) {\r", "-\t\t\t\t\t\tcount--;\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tlookupEnvironment.buildTypeBindings(units[count]);\r", "-\t\t\t\t\t\t\trememberWithMemberTypes(topLevelType, units[count].types[0].binding);\r", "-\t\t\t\t\t\t} catch (AbortCompilation e) {\r", "-\t\t\t\t\t\t\t// classpath problem for this type: ignore\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\tfor (int i = 0; i < sourceLength; i++) {\r", "-\t\t\t\tICompilationUnit sourceUnit = sourceUnits[i];\r", "-\t\t\t\tsourceUnits[i] = null; // no longer needed pass this point\r", "-\t\t\t\tCompilationResult unitResult =\r", "-\t\t\t\t\tnew CompilationResult(\r", "-\t\t\t\t\t\tsourceUnit,\r", "-\t\t\t\t\t\tsuppliedLength + i,\r", "-\t\t\t\t\t\tsuppliedLength + sourceLength);\r", "-\t\t\t\tParser parser = new Parser(lookupEnvironment.problemReporter);\r", "-\t\t\t\tCompilationUnitDeclaration parsedUnit =\r", "-\t\t\t\t\tparser.dietParse(sourceUnit, unitResult);\r", "-\t\t\t\tif (parsedUnit != null) {\r", "-\t\t\t\t\tunits[++count] = parsedUnit;\r", "-\t\t\t\t\tlookupEnvironment.buildTypeBindings(units[count]);\r", "-\t\t\t\t\tint typeCount = parsedUnit.types == null ? 0 : parsedUnit.types.length;\r", "-\t\t\t\t\tfor (int j = 0; j < typeCount; j++) {\r", "-\t\t\t\t\t\trememberWithMemberTypes(parsedUnit.types[j], null, sourceUnit);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tfor (int i = 0; i <= count; i++)\r", "-\t\t\t\tlookupEnvironment.completeTypeBindings(units[i], false);\r", "-\r", "-\t\t\treportHierarchy();\r", "-\t\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "-\t\t} finally {\r", "-\t\t\treset();\r", "-\t}\r", "+\t\tfor (int i = 0; i < sourceLength; i++){\r", "+\t\t\tICompilationUnit sourceUnit = sourceUnits[i];\r", "+\t\t\tsourceUnits[i] = null; // no longer needed pass this point\r", "+\t\t\tCompilationResult unitResult = new CompilationResult(sourceUnit, suppliedLength+i, suppliedLength+sourceLength); \r", "+\t\t\tParser parser = new Parser(lookupEnvironment.problemReporter);\r", "+\t\t\tCompilationUnitDeclaration parsedUnit = parser.dietParse(sourceUnit, unitResult);\r", "+\t\t\tif (parsedUnit != null) {\r", "+\t\t\t\tunits[++count] = parsedUnit;\r", "+\t\t\t\tlookupEnvironment.buildTypeBindings(units[count]);\r", "+\t\t\t\tint typeCount = parsedUnit.types == null ? 0 : parsedUnit.types.length;\r", "+\t\t\t\tfor (int j = 0; j < typeCount; j++){\r", "+\t\t\t\t\trememberWithMemberTypes(parsedUnit.types[j], null, sourceUnit);\r", "+\t\tfor (int i = 0; i <= count; i++)\r", "+\t\t\tlookupEnvironment.completeTypeBindings(units[i], false);\r", "+\t\treportHierarchy();\r", "+\t\t\r", "+\t} catch (ClassCastException e){ // work-around for 1GF5W1S - can happen in case duplicates are fed to the hierarchy with binaries hiding sources\r", "+\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "+\t} finally {\r", "+\t\treset();\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ff917bd24b106891b049f5b70e129061", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java", "commitBeforeChange": "b17f0033873962e79cd540a0937b76249dec8a6c", "commitAfterChange": "360e136a8e044225071869fa38d7072ea1d3cdac", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": "  public void resolve(IGenericType[] suppliedTypes, ICompilationUnit[] sourceUnits, IProgressMonitor monitor)", "signatureAfterChange": "  public void resolve(IGenericType[] suppliedTypes, org.eclipse.jdt.core.ICompilationUnit[] closedCUs, HashSet localTypes, IProgressMonitor monitor)", "diff": ["-public void resolve(IGenericType[] suppliedTypes, ICompilationUnit[] sourceUnits, IProgressMonitor monitor) {", "+public void resolve(IGenericType[] suppliedTypes, org.eclipse.jdt.core.ICompilationUnit[] closedCUs, HashSet localTypes, IProgressMonitor monitor) {", "-\t\tint sourceLength = sourceUnits == null ? 0 : sourceUnits.length;", "+\t\tint sourceLength = closedCUs == null ? 0 : closedCUs.length;", "+\t\tboolean[] hasLocalType = new boolean[suppliedLength + sourceLength];", "+\t\t\t\t", "+\t\t\t\t// contains a potential subtype as a local or anonymous type?", "+\t\t\t\tboolean containsLocalType = false;", "+\t\t\t\tif (localTypes == null) { // case of hierarchy on region", "+\t\t\t\t\tcontainsLocalType = false;", "+\t\t\t\t} else if (topLevelType instanceof SourceTypeElementInfo) {", "+\t\t\t\t\tIPath path = ((SourceTypeElementInfo)topLevelType).getHandle().getPath();", "+\t\t\t\t\tcontainsLocalType = localTypes.contains(path.toString());", "+\t\t\t\t}", "+\t\t\t\t", "-\t\t\t\tunits[i] = ", "-\t\t\t\t\tSourceTypeConverter.buildCompilationUnit(", "-\t\t\t\t\t\tnew ISourceType[]{topLevelType}, ", "-\t\t\t\t\t\tfalse, // no need for field and methods", "-\t\t\t\t\t\ttrue, // need member types", "-\t\t\t\t\t\tfalse, // no need for field initialization", "-\t\t\t\t\t\tthis.lookupEnvironment.problemReporter, ", "-\t\t\t\t\t\tresult);", "+\t\t\t\tif (!containsLocalType) {", "+\t\t\t\t\tunits[i] = ", "+\t\t\t\t\t\tSourceTypeConverter.buildCompilationUnit(", "+\t\t\t\t\t\t\tnew ISourceType[]{topLevelType}, ", "+\t\t\t\t\t\t\ttrue, // need for field and methods // TODO (jerome) need fields and methods only for supertypes of local types", "+\t\t\t\t\t\t\ttrue, // need member types", "+\t\t\t\t\t\t\tfalse, // no need for field initialization", "+\t\t\t\t\t\t\tthis.lookupEnvironment.problemReporter, ", "+\t\t\t\t\t\t\tresult);", "+\t\t\t\t} else {", "+\t\t\t\t\tunits[i] =", "+\t\t\t\t\t\tElementInfoConverter.buildCompilationUnit(", "+\t\t\t\t\t\t\tnew SourceTypeElementInfo[]{(SourceTypeElementInfo)topLevelType}, ", "+\t\t\t\t\t\t\ttrue, // need local types", "+\t\t\t\t\t\t\tthis.lookupEnvironment.problemReporter, ", "+\t\t\t\t\t\t\tresult);", "+\t\t\t\t\tunits[i].bits |= AstNode.HasAllMethodBodies;", "+\t\t\t\t\thasLocalType[i] = true;", "+\t\t\t\t}", "-\t\t\tICompilationUnit sourceUnit = sourceUnits[i];", "+\t\t\torg.eclipse.jdt.core.ICompilationUnit closedCU = closedCUs[i];", "+\t\t\tIResource file = closedCU.getResource();", "+\t\t\tString osPath = file.getLocation().toOSString();", "+\t\t\tICompilationUnit sourceUnit = this.requestor.createCompilationUnitFromPath((Openable)closedCU, osPath);", "+\t\t\t", "+", "+\t\t\t\t// contains a potential subtype as a local or anonymous type?", "+\t\t\t\tif (localTypes == null) { // case of hierarchy on region", "+\t\t\t\t\thasLocalType[suppliedLength+i] = false;", "+\t\t\t\t} else {", "+\t\t\t\t\tIPath path = file.getFullPath();", "+\t\t\t\t\thasLocalType[suppliedLength+i] = localTypes.contains(path.toString());", "+\t\t\t\t}", "+\t\t\t", "-\t\t// complete type bindings (ie. connect super types) and remember them", "+\t\t// complete type bindings (ie. connect super types)", "-\t\t\t\t\t// must start with the top level type", "-\t\t\t\t\tISourceType topLevelType = (ISourceType) suppliedTypes[i];", "-\t\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\t\t\t\t", "-\t\t\t\t\twhile (topLevelType.getEnclosingType() != null)", "-\t\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();", "-\t\t\t\t\t\tthis.lookupEnvironment.completeTypeBindings(parsedUnit, false);", "-\t\t\t\t\t\trememberWithMemberTypes(topLevelType, parsedUnit.types[0].binding);", "+\t\t\t\t\t\t// NB: No need to get method bodies as they were already computed", "+\t\t\t\t\t\tthis.lookupEnvironment.completeTypeBindings(parsedUnit, true); // TODO (jerome) build fields and methods only for super types of local types", "-\t\t\t\tthis.lookupEnvironment.completeTypeBindings(parsedUnit, false);", "-\t\t\t\tint typeCount = parsedUnit.types == null ? 0 : parsedUnit.types.length;", "-\t\t\t\tICompilationUnit sourceUnit = sourceUnits[i];", "-\t\t\t\tsourceUnits[i] = null; // no longer needed pass this point", "-\t\t\t\tfor (int j = 0; j < typeCount; j++){", "-\t\t\t\t\trememberWithMemberTypes(parsedUnit.types[j], null, sourceUnit);", "+\t\t\t\ttry {", "+\t\t\t\t\tboolean localType = hasLocalType[suppliedLength+i];", "+\t\t\t\t\tif (localType) {", "+\t\t\t\t\t\tparser.getMethodBodies(parsedUnit);", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.lookupEnvironment.completeTypeBindings(parsedUnit, localType);", "+\t\t\t\t} catch (AbortCompilation e) {", "+\t\t\t\t\t// classpath problem for this type: ignore", "+\t\t}", "+\t\t", "+\t\t// remember type bindings", "+\t\tfor (int i = 0; i < suppliedLength; i++) {", "+\t\t\tif (!suppliedTypes[i].isBinaryType()) { // note that binary types have already been remembered above", "+\t\t\t\tCompilationUnitDeclaration parsedUnit = units[i];", "+\t\t\t\tif (parsedUnit != null) {", "+\t\t\t\t\tboolean localType = hasLocalType[i];", "+\t\t\t\t\tif (localType) {", "+\t\t\t\t\t\tparsedUnit.scope.faultInTypes();", "+\t\t\t\t\t\tparsedUnit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());", "+\t\t\t\t\t\tparsedUnit.resolve();", "+\t\t\t\t\t}", "+\t\t\t\t\t\t", "+\t\t\t\t\t// must start with the top level type", "+\t\t\t\t\tISourceType topLevelType = (ISourceType) suppliedTypes[i];", "+\t\t\t\t\tsuppliedTypes[i] = null; // no longer needed pass this point\t\t\t\t", "+\t\t\t\t\twhile (topLevelType.getEnclosingType() != null) {", "+\t\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();", "+\t\t\t\t\t}", "+\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit cu = ((SourceTypeElementInfo)topLevelType).getHandle().getCompilationUnit();", "+\t\t\t\t\trememberAllTypes(parsedUnit, cu, localType);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tfor (int i = 0; i < sourceLength; i++) {", "+\t\t\tCompilationUnitDeclaration parsedUnit = units[suppliedLength+i];", "+\t\t\tif (parsedUnit != null) {", "+\t\t\t\tboolean localType = hasLocalType[suppliedLength+i];", "+\t\t\t\tif (localType) {", "+\t\t\t\t\tparsedUnit.scope.faultInTypes();", "+\t\t\t\t\tparsedUnit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());", "+\t\t\t\t\tparsedUnit.resolve();", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\trememberAllTypes(parsedUnit, closedCUs[i], localType);", "+\t\t\t}", "-}"]}], "num": 885}