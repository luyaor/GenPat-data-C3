{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "157f8ba62de0bfa85b9359a389a118f8", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "29bb0c8c02ace244e2c9b44ceb85bbc6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "42a66623ce2a3ec71a2f28506ffd67d2c8d2cf8c", "commitAfterChange": "97c795afd8d70a26c90859be85631c2f80038330", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 61, "signatureBeforeChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask, boolean needResolve)", "signatureAfterChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask, boolean needResolve)", "diff": ["-\t\t\t// walk single static imports. A type found here will shadow types with same name in other CU's, or types coming", "-\t\t\t// from on-demand imports. JLS 7.5.3", "+\t\t\t// In this location we had a fix for ", "-\t\t\tif (imports != null) {", "-\t\t\t\tReferenceBinding type = null;", "-\t\t\t\tnextImport : for (int i = 0, length = imports.length; i < length; i++) {", "-\t\t\t\t\tImportBinding importBinding = imports[i];", "-\t\t\t\t\tif (importBinding.isStatic()) {", "-\t\t\t\t\t\tReferenceBinding temp = null;", "-\t\t\t\t\t\tif (CharOperation.equals(importBinding.compoundName[importBinding.compoundName.length - 1], name)) {", "-\t\t\t\t\t\t\tBinding resolvedImport = importBinding.resolvedImport;", "-\t\t\t\t\t\t\tif (resolvedImport == null) continue nextImport;", "-\t\t\t\t\t\t\tif (resolvedImport instanceof MethodBinding || resolvedImport instanceof FieldBinding) {", "-\t\t\t\t\t\t\t\t// check to see if there are also member types with the same name", "-\t\t\t\t\t\t\t\t// must find the importRef's type again since the method/field can be from an inherited type", "-\t\t\t\t\t\t\t\t// see StaticImportTest#test084 for more clarity", "-\t\t\t\t\t\t\t\tchar[][] importName = importBinding.reference.tokens;", "-\t\t\t\t\t\t\t\tTypeBinding referencedType = getType(importName, importName.length - 1);", "-\t\t\t\t\t\t\t\tif (referencedType != null && referencedType instanceof ReferenceBinding) {", "-\t\t\t\t\t\t\t\t\ttemp = findMemberType(name, (ReferenceBinding) referencedType);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (temp != null && temp.isStatic() && temp != type) {", "-\t\t\t\t\t\t\t\tif (temp.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tif (!temp.canBeSeenBy(unitScope.fPackage)) {", "-\t\t\t\t\t\t\t\t\t\t// Answer error binding - type is not visible", "-\t\t\t\t\t\t\t\t\t\tfoundType = new ProblemReferenceBinding(new char[][]{name}, type, ProblemReasons.NotVisible);", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "-\t\t\t\t\t\t\t\t\t\tif (importReference != null) {", "-\t\t\t\t\t\t\t\t\t\t\timportReference.bits |= ASTNode.Used;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\ttype = temp;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t} else if (foundType == null) {", "-\t\t\t\t\t\t\t\t\tfoundType = temp;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (type != null) {", "-\t\t\t\t\tif (typeOrPackageCache != null)", "-\t\t\t\t\t\ttypeOrPackageCache.put(name, type);", "-\t\t\t\t\treturn type;", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\t// However, as of today (4.3M6 candidate) this fix seems unnecessary, while causing StackOverflowError in", "+\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=401271", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a1f5d59a9c4c32636f0ccad6c3fac1c8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "da7a5227e034c2b6c8a4762e61c3ccf43066f02e", "commitAfterChange": "38b5290055a0d2229f0d3e99304508f0eb9f2352", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 63, "signatureBeforeChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask, boolean needResolve)", "signatureAfterChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask, boolean needResolve)", "diff": ["-\t\t\t// walk single static imports. A type found here will shadow types with same name in other CU's, or types coming", "-\t\t\t// from on-demand imports. JLS 7.5.3", "+\t\t\t// In this location we had a fix for ", "-\t\t\tif (imports != null) {", "-\t\t\t\tReferenceBinding type = null;", "-\t\t\t\tnextImport : for (int i = 0, length = imports.length; i < length; i++) {", "-\t\t\t\t\tImportBinding importBinding = imports[i];", "-\t\t\t\t\tif (importBinding.isStatic()) {", "-\t\t\t\t\t\tReferenceBinding temp = null;", "-\t\t\t\t\t\tif (CharOperation.equals(importBinding.compoundName[importBinding.compoundName.length - 1], name)) {", "-\t\t\t\t\t\t\tBinding resolvedImport = importBinding.resolvedImport;", "-\t\t\t\t\t\t\tif (resolvedImport == null) continue nextImport;", "-\t\t\t\t\t\t\tif (resolvedImport instanceof MethodBinding || resolvedImport instanceof FieldBinding) {", "-\t\t\t\t\t\t\t\t// check to see if there are also member types with the same name", "-\t\t\t\t\t\t\t\t// must find the importRef's type again since the method/field can be from an inherited type", "-\t\t\t\t\t\t\t\t// see StaticImportTest#test084 for more clarity", "-\t\t\t\t\t\t\t\tchar[][] importName = importBinding.reference.tokens;", "-\t\t\t\t\t\t\t\tTypeBinding referencedType = getType(importName, importName.length - 1);", "-\t\t\t\t\t\t\t\tif (referencedType != null && referencedType instanceof ReferenceBinding) {", "-\t\t\t\t\t\t\t\t\ttemp = findMemberType(name, (ReferenceBinding) referencedType);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (temp != null && temp.isStatic() && temp != type) {", "-\t\t\t\t\t\t\t\tif (temp.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tif (!temp.canBeSeenBy(unitScope.fPackage)) {", "-\t\t\t\t\t\t\t\t\t\t// Answer error binding - type is not visible", "-\t\t\t\t\t\t\t\t\t\tfoundType = new ProblemReferenceBinding(new char[][]{name}, type, ProblemReasons.NotVisible);", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "-\t\t\t\t\t\t\t\t\t\tif (importReference != null) {", "-\t\t\t\t\t\t\t\t\t\t\timportReference.bits |= ASTNode.Used;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\ttype = temp;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t} else if (foundType == null) {", "-\t\t\t\t\t\t\t\t\tfoundType = temp;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (type != null) {", "-\t\t\t\t\tif (typeOrPackageCache != null)", "-\t\t\t\t\t\ttypeOrPackageCache.put(name, type);", "-\t\t\t\t\treturn type;", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\t// However, as of today (4.3M6 candidate) this fix seems unnecessary, while causing StackOverflowError in", "+\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=401271", "+"]}], "num": 33408}