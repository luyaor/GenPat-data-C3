{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "347f701f48fbf912f4279bcbf27db6ee", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3c74849a37a59e512cfbd29fde6ae58c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "694b8ccf96bd76967363d1bcdba493ae5464ca4d", "commitAfterChange": "88b45f0d87eead26518b1d6a35c12c8894aa8965", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["-\tboolean mustImplementAbstractMethods = ((this.type.modifiers & IConstants.AccInterface) == 0) && !this.type.isAbstract();", "-\tif (mustImplementAbstractMethods && this.type.isEnum() && !this.type.isAnonymousType()) {", "-\t\t// enum type only needs to implement abstract methods if any of its constants does not supply a body", "-\t\tcheckEnumConstantBodies: {", "-\t\t\tTypeDeclaration typeDeclaration = this.type.scope.referenceContext;", "-\t\t\tfor (int i = 0, length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length; i < length; i++) {", "-\t\t\t\tFieldDeclaration fieldDecl = typeDeclaration.fields[i];", "-\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT && !(fieldDecl.initialization instanceof QualifiedAllocationExpression)) {", "-\t\t\t\t\tbreak checkEnumConstantBodies; // leave mustImplementAbstractMethods flag on ", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tmustImplementAbstractMethods = false; // since all enum constants define an anonymous body", "-\t\t}", "-\t}", "+\tboolean mustImplementAbstractMethods = mustImplementAbstractMethods();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c68868ee14a5523028c3e81f4f1e8156", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "8816a21753c2d607b8868597ac43f18ef7dd2d50", "commitAfterChange": "3af20c8fa9116cf8e52dcf498c1b4eea06f21754", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["+\tif (mustImplementAbstractMethods && this.type.isEnum() && !this.type.isAnonymousType()) {", "+\t\t// enum type only needs to implement abstract methods if any of its constants does not supply a body", "+\t\tcheckEnumConstantBodies: {", "+\t\t\tTypeDeclaration typeDeclaration = this.type.scope.referenceContext;", "+\t\t\tfor (int i = 0, length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length; i < length; i++) {", "+\t\t\t\tFieldDeclaration fieldDecl = typeDeclaration.fields[i];", "+\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT && !(fieldDecl.initialization instanceof QualifiedAllocationExpression)) {", "+\t\t\t\t\tbreak checkEnumConstantBodies; // leave mustImplementAbstractMethods flag on ", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tmustImplementAbstractMethods = false; // since all enum constants define an anonymous body", "+\t\t}", "+\t}"]}], "num": 16314}