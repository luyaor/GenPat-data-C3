{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "99773e7fb18baf8065ad6d40c350f643", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "636e74e560f91697117ee59c0e7b79b2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java", "commitBeforeChange": "d9396647e280a0cdb636c94fae9233a7a2475f6f", "commitAfterChange": "09617092d586fc57d56d7255b395176bf3d6b1e7", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  \tprivate ASTNode internalCreateAST(IProgressMonitor monitor)", "signatureAfterChange": "  \tprivate ASTNode internalCreateAST(IProgressMonitor monitor)", "diff": ["+\t\t\t\t\tif (this.typeRoot instanceof ClassFileWorkingCopy) {", "+\t\t\t\t\t\t// special case: class file mimics as compilation unit, but that would use a wrong file name below, so better unwrap now:", "+\t\t\t\t\t\tthis.typeRoot = ((ClassFileWorkingCopy) this.typeRoot).classFile;", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "95fee47f0db6a64df406193d8e4a78b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "349c3b5a850fbdbf23ec6c6153a095f70d61338c", "commitAfterChange": "00a3f3c32948c64188954cac2f1e0a1305db911b", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "  \tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method, boolean interleaved) \t\t\tthrows InferenceFailureException", "signatureAfterChange": "  \tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method, boolean interleaved) \t\t\tthrows InferenceFailureException", "diff": ["+\t\t\t\t\tif (!t.isProperType(true) && t.isParameterizedType()) {", "+\t\t\t\t\t\t// prevent already resolved inference variables from leaking into the lambda", "+\t\t\t\t\t\tt = (ReferenceBinding) Scope.substitute(getResultSubstitution(this.currentBounds, false), t);", "+\t\t\t\t\t}"]}], "num": 34468}