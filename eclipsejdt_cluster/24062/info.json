{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "343932df60806d77c964928fb66aedf4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8a4aa45ee5e0c1bba219a0bc4faa508f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "74d118e989117eba0163f0f707314197db0891af", "commitAfterChange": "43cdae5117454d896e9e9cf435f63b0b509e3a4c", "methodNumberBeforeChange": 56, "methodNumberAfterChange": 56, "signatureBeforeChange": "  private void evaluateNullAnnotations(long annotationTagBits)", "signatureAfterChange": "  private void evaluateNullAnnotations(long annotationTagBits)", "diff": ["-\t// transfer nullness info from tagBits to this.nullnessDefaultAnnotation", "-\tint newDefaultNullness = NO_NULL_DEFAULT;", "-\tif ((annotationTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)", "-\t\tnewDefaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;", "-\telse if ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0)", "-\t\tnewDefaultNullness = NONNULL_BY_DEFAULT;", "-\tif (newDefaultNullness != NO_NULL_DEFAULT) {", "-\t\tif (isPackageInfo) {", "-\t\t\tpkg.defaultNullness = newDefaultNullness;", "-\t\t} else {", "-\t\t\tthis.defaultNullness = newDefaultNullness;", "-\t\t\tTypeDeclaration typeDecl = this.scope.referenceContext;", "-\t\t\tlong nullDefaultBits = annotationTagBits & (TagBits.AnnotationNullUnspecifiedByDefault|TagBits.AnnotationNonNullByDefault);", "-\t\t\tcheckRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, nullDefaultBits);", "+\tboolean isJdk18 = this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8;", "+\tif (isJdk18) {", "+\t\tif (this.defaultNullness != 0) {", "+\t\t\tif (isPackageInfo) {", "+\t\t\t\tpkg.defaultNullness = this.defaultNullness;", "+\t\t\t} else {", "+\t\t\t\tTypeDeclaration typeDecl = this.scope.referenceContext;", "+\t\t\t\tcheckRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, this.defaultNullness, isJdk18);", "+\t\t\t}", "+\t\t} else if (isPackageInfo || (isInDefaultPkg && !(this instanceof NestedTypeBinding))) {", "+\t\t\tthis.scope.problemReporter().missingNonNullByDefaultAnnotation(this.scope.referenceContext);", "+\t\t\tif (!isInDefaultPkg)", "+\t\t\t\tpkg.defaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;", "-\t} else if (isPackageInfo || (isInDefaultPkg && !(this instanceof NestedTypeBinding))) {", "-\t\tthis.scope.problemReporter().missingNonNullByDefaultAnnotation(this.scope.referenceContext);", "-\t\tif (!isInDefaultPkg)", "-\t\t\tpkg.defaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;", "+\t} else {", "+\t\t// transfer nullness info from tagBits to this.nullnessDefaultAnnotation", "+\t\tint newDefaultNullness = NO_NULL_DEFAULT;", "+\t\tif ((annotationTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)", "+\t\t\tnewDefaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;", "+\t\telse if ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0)", "+\t\t\tnewDefaultNullness = NONNULL_BY_DEFAULT;", "+\t\tif (newDefaultNullness != NO_NULL_DEFAULT) {", "+\t\t\tif (isPackageInfo) {", "+\t\t\t\tpkg.defaultNullness = newDefaultNullness;", "+\t\t\t} else {", "+\t\t\t\tthis.defaultNullness = newDefaultNullness;", "+\t\t\t\tTypeDeclaration typeDecl = this.scope.referenceContext;", "+\t\t\t\tlong nullDefaultBits = annotationTagBits & (TagBits.AnnotationNullUnspecifiedByDefault|TagBits.AnnotationNonNullByDefault);", "+\t\t\t\tcheckRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, nullDefaultBits, false);", "+\t\t\t}", "+\t\t} else if (isPackageInfo || (isInDefaultPkg && !(this instanceof NestedTypeBinding))) {", "+\t\t\tthis.scope.problemReporter().missingNonNullByDefaultAnnotation(this.scope.referenceContext);", "+\t\t\tif (!isInDefaultPkg)", "+\t\t\t\tpkg.defaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;", "+\t\t}", "+\t}", "+\tmaybeMarkTypeParametersNonNull();", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b17a8e396bbb98b412f83478323d6e19", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "333e183ebe56f659f1083c452edbf2ef4089fa56", "commitAfterChange": "f09e5b387a9b27a1161db6587b5598aa2acd37a0", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 39, "signatureBeforeChange": " protected void locateMatches(JavaProject javaProject, PossibleMatch[] possibleMatches, int start, int length) throws CoreException", "signatureAfterChange": " protected void locateMatches(JavaProject javaProject, PossibleMatch[] possibleMatches, int start, int length) throws CoreException", "diff": ["-\tboolean mustResolve = ((InternalSearchPattern)this.pattern).mustResolve;", "+\tboolean mustResolvePattern = ((InternalSearchPattern)this.pattern).mustResolve;", "+\tboolean mustResolve = mustResolvePattern;", "+\tthis.patternLocator.mayBeGeneric = this.options.sourceLevel >= ClassFileConstants.JDK1_5;", "-\t\t\t\tparseAndBuildBindings(possibleMatch, mustResolve);", "-\t\t\t\tif (!mustResolve) {", "+\t\t\t\tif (!parseAndBuildBindings(possibleMatch, mustResolvePattern)) continue;", "+\t\t\t\t// Currently we only need to resolve over pattern flag if there's potential parameterized types", "+\t\t\t\tif (this.patternLocator.mayBeGeneric) {", "+\t\t\t\t\t// If pattern does not resolve then rely on possible match node set resolution", "+\t\t\t\t\t// which may have been modified while locator was adding possible matches to it", "+\t\t\t\t\tif (!mustResolvePattern && !mustResolve) {", "+\t\t\t\t\t\tmustResolve = possibleMatch.nodeSet.mustResolve;", "+\t\t\t\t\t\tbindingsWereCreated = mustResolve;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t// Reset matching node resolution with pattern one if there's no potential parameterized type", "+\t\t\t\t\t// to minimize side effect on previous search behavior", "+\t\t\t\t\tpossibleMatch.nodeSet.mustResolve = mustResolvePattern;", "+\t\t\t\t}", "+\t\t\t\t// possible match node resolution has been merged with pattern one, so rely on it to know", "+\t\t\t\t// whether we need to process compilation unit now or later", "+\t\t\t\tif (!possibleMatch.nodeSet.mustResolve) {", "+\t\t\t\t\tif (this.numberOfMatches>0 && this.matchesToProcess[this.numberOfMatches-1] == possibleMatch) {", "+\t\t\t\t\t\t// forget last possible match as it was processed", "+\t\t\t\t\t\tthis.numberOfMatches--;", "+\t\t\t\t\t}", "-\t\t\t\tif (!mustResolve)", "+\t\t\t\tif (!possibleMatch.nodeSet.mustResolve)"]}], "num": 24062}