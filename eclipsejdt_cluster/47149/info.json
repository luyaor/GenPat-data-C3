{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "98704e6eed4be7f21e65161f4d6c416e", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f9a7221f8155a2d2976a41635941f0d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "618f3771c49dbf9480ae16a58263680af2b36ad6", "commitAfterChange": "7cfc4523cdcfe787f1d0d2fd75b08c06e5b4b089", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate Expression parseArguments(TypeReference receiver) throws InvalidInputException", "signatureAfterChange": " \tprotected Object createMethodReference(Object receiver, List arguments) throws InvalidInputException", "diff": ["-\tprivate Expression parseArguments(TypeReference receiver) throws InvalidInputException {", "-", "-\t\t// Init", "-\t\tint modulo = 0; // should be 2 for (Type,Type,...) or 3 for (Type arg,Type arg,...)", "-\t\tint iToken = 0;", "-\t\tchar[] argName = null;", "-\t\tint ptr = this.astPtr;", "-\t\tint lptr = this.astLengthPtr;", "-\t\t", "-\t\t// Decide whether we have a constructor or not", "-\t\tboolean isConstructor = true;", "-\t\tif (receiver != null) {", "-\t\t\tchar[][] receiverTokens = receiver.getTypeName();", "-\t\t\tchar[] memberName = this.identifierStack[0];", "-\t\t\tisConstructor = CharOperation.equals(memberName, receiverTokens[receiverTokens.length-1]);", "-\t\t}", "-", "-\t\t// Parse arguments declaration if method reference", "-\t\tnextArg : while (this.index < this.scanner.eofPosition) {", "-", "-\t\t\t// Read argument type reference", "-\t\t\tTypeReference typeRef;", "-\t\t\ttry {", "-\t\t\t\ttypeRef = parseQualifiedName(false);", "-\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\tboolean firstArg = modulo == 0;", "-\t\t\tif (firstArg) { // verify position", "-\t\t\t\tif (iToken != 0)", "-\t\t\t\t\tbreak nextArg;", "-\t\t\t} else if ((iToken % modulo) != 0) {", "-\t\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\tif (typeRef == null) {", "-\t\t\t\tif (firstArg && this.currentTokenType == TerminalTokens.TokenNameRPAREN) {", "-\t\t\t\t\tif (isConstructor) {", "-\t\t\t\t\t\tJavadocAllocationExpression expr = new JavadocAllocationExpression(this.identifierPositionStack[0]);", "-\t\t\t\t\t\texpr.type = receiver;", "-\t\t\t\t\t\treturn expr;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[0], this.identifierPositionStack[0]);", "-\t\t\t\t\t\tmsg.receiver = receiver;", "-\t\t\t\t\t\treturn msg;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\tint argStart = typeRef.sourceStart;", "-\t\t\tint argEnd = typeRef.sourceEnd;", "-\t\t\tiToken++;", "-", "-\t\t\t// Read possible array declaration", "-\t\t\tint dim = 0;", "-\t\t\tif (readToken() == TerminalTokens.TokenNameLBRACKET) {", "-\t\t\t\twhile (readToken() == TerminalTokens.TokenNameLBRACKET) {", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tif (readToken() != TerminalTokens.TokenNameRBRACKET) {", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t\t}", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tdim++;", "-\t\t\t\t}", "-\t\t\t\tlong pos = ((long) typeRef.sourceStart) << 32 + typeRef.sourceEnd;", "-\t\t\t\t\ttypeRef = new JavadocArraySingleTypeReference(singleRef.token, dim, pos);", "-\t\t\t\t\ttypeRef = new JavadocArrayQualifiedTypeReference(qualifRef, dim);", "-", "-\t\t\t// Read argument name", "-\t\t\tif (readToken() == TerminalTokens.TokenNameIdentifier) {", "-\t\t\t\tconsumeToken();", "-\t\t\t\tif (firstArg) { // verify position", "-\t\t\t\t\tif (iToken != 1)", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t} else if ((iToken % modulo) != 1) {", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t}", "-\t\t\t\tif (argName == null) { // verify that all arguments name are declared", "-\t\t\t\t\tif (!firstArg) {", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\targName = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\targEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\tiToken++;", "-\t\t\t} else if (argName != null) { // verify that no argument name is declared", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\t", "-\t\t\t// Verify token position", "-\t\t\tif (firstArg) {", "-\t\t\t\tmodulo = iToken + 1;", "-\t\t\t} else {", "-\t\t\t\tif ((iToken % modulo) != (modulo - 1)) {", "-\t\t\t\t\tbreak nextArg;", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\t// Read separator or end arguments declaration", "-\t\t\tint token = readToken();", "-\t\t\tchar[] name = argName == null ? new char[0] : argName;", "-\t\t\tif (token == TerminalTokens.TokenNameCOMMA) {", "-\t\t\t\t// Create new argument", "-\t\t\t\tJavadocArgumentExpression expr = new JavadocArgumentExpression(name, argStart, argEnd, typeRef);", "-\t\t\t\tpushOnAstStack(expr, firstArg);", "-\t\t\t\tconsumeToken();", "-\t\t\t\tiToken++;", "-\t\t\t} else if (token == TerminalTokens.TokenNameRPAREN) {", "-\t\t\t\t// Create new argument", "-\t\t\t\tJavadocArgumentExpression expr = new JavadocArgumentExpression(name, argStart, argEnd, typeRef);", "-\t\t\t\tpushOnAstStack(expr, firstArg);", "-\t\t\t\tint size = this.astLengthStack[this.astLengthPtr--];", "-\t\t\t\t// Build arguments array", "-\t\t\t\tJavadocArgumentExpression[] arguments = new JavadocArgumentExpression[size];", "-\t\t\t\tfor (int i = (size - 1); i >= 0; i--) {", "-\t\t\t\t\targuments[i] = (JavadocArgumentExpression) this.astStack[this.astPtr--];", "-\t\t\t\t}", "-\t\t\t\t// Create message send", "-\t\t\t\tif (isConstructor) {", "-\t\t\t\t\tJavadocAllocationExpression alloc = new JavadocAllocationExpression(this.identifierPositionStack[0]);", "-\t\t\t\t\talloc.arguments = arguments;", "-\t\t\t\t\talloc.type = receiver;", "-\t\t\t\t\treturn alloc;", "-\t\t\t\t} else {", "-\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[0], this.identifierPositionStack[0], arguments);", "-\t\t\t\t\tmsg.receiver = receiver;", "-\t\t\t\t\treturn msg;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-", "-\t\t// Invalid input: reset ast stacks pointers", "-\t\tconsumeToken();", "-\t\tif (iToken > 0) {", "-\t\t\tthis.astPtr = ptr;", "-\t\t\tthis.astLengthPtr = lptr;", "-\t\t}", "-\t\tthrow new InvalidInputException();", "-\t}", "+\tprotected Object createMethodReference(Object receiver, List arguments) throws InvalidInputException {", "+\t\t\t// Get receiver type", "+\t\t\tTypeReference typeRef = (TypeReference) receiver;", "+\t\t\tif (typeRef == null) {", "+\t\t\t\tchar[] name = this.sourceParser.compilationUnit.compilationResult.compilationUnit.getMainTypeName();", "+\t\t\t\tif (name == null) {", "+\t\t\t\t\tthrow new InvalidInputException();", "+\t\t\t\t}", "+\t\t\t\ttypeRef = new JavadocSingleTypeReference(name, 0, 0, 0);", "+\t\t\t// Decide whether we have a constructor or not", "+\t\t\tchar[][] receiverTokens = typeRef.getTypeName();", "+\t\t\tchar[] memberName = this.identifierStack[0];", "+\t\t\tboolean isConstructor = CharOperation.equals(memberName, receiverTokens[receiverTokens.length-1]);", "+\t\t\t// Create node", "+\t\t\tif (arguments == null) {", "+\t\t\t\tif (isConstructor) {", "+\t\t\t\t\tJavadocAllocationExpression expr = new JavadocAllocationExpression(this.identifierPositionStack[0]);", "+\t\t\t\t\texpr.type = typeRef;", "+\t\t\t\t\treturn expr;", "+\t\t\t\t} else {", "+\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[0], this.identifierPositionStack[0]);", "+\t\t\t\t\tmsg.receiver = typeRef;", "+\t\t\t\t\treturn msg;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tJavadocArgumentExpression[] expressions = new JavadocArgumentExpression[arguments.size()];", "+\t\t\t\targuments.toArray(expressions);", "+\t\t\t\tif (isConstructor) {", "+\t\t\t\t\tJavadocAllocationExpression alloc = new JavadocAllocationExpression(this.identifierPositionStack[0]);", "+\t\t\t\t\talloc.arguments = expressions;", "+\t\t\t\t\talloc.type = typeRef;", "+\t\t\t\t\treturn alloc;", "+\t\t\t\t} else {", "+\t\t\t\t\tJavadocMessageSend msg = new JavadocMessageSend(this.identifierStack[0], this.identifierPositionStack[0], expressions);", "+\t\t\t\t\tmsg.receiver = typeRef;", "+\t\t\t\t\treturn msg;", "+\t\t\t\t}", "+\t\t\t}", "+\t\tcatch (ClassCastException ex) {", "+\t\t\t\tthrow new InvalidInputException();", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34567f66a32cf1b129cbb5fc4f3a5642", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "d5b9ab15bb3f769b7e2ac485fe6da55027818828", "commitAfterChange": "e98478cd38caef5e23457b8b0fdc364bf2846afc", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t\t  \tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException", "signatureAfterChange": "  \tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException", "diff": ["+\tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException {", "+", "+\t\tint modulo = 0; // should be 2 for (Type,Type,...) and 3 for (Type arg,Type arg,...)", "+\t\tint iToken = 0;", "+\t\tchar[] argName = null;", "+\t\tint ptr = astPtr;", "+\t\tint lptr = astLengthPtr;", "+", "+\t\t// Parse arguments declaration if method reference", "+\t\tnextArg : while (this.index < this.scanner.eofPosition) {", "+", "+\t\t\t// Read argument type reference", "+\t\t\tint argStart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\tTypeReference typeRef;", "+\t\t\ttry {", "+\t\t\t\ttypeRef = parseQualifiedName(false);", "+\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t\tboolean firstArg = modulo == 0;", "+\t\t\tif (firstArg) { // verify position", "+\t\t\t\tif (iToken != 0)", "+\t\t\t\t\tbreak nextArg;", "+\t\t\t} else if ((iToken % modulo) != 0) {", "+\t\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t\tif (typeRef == null) {", "+\t\t\t\tif (firstArg && this.currentTokenType == TerminalTokens.TokenNameRPAREN) {", "+\t\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0]);", "+\t\t\t\t\tmsg.receiver = receiver;", "+\t\t\t\t\treturn msg;", "+\t\t\t\t}", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t\tiToken++;", "+", "+\t\t\t// Read possible array declaration", "+\t\t\tint dim = 0;", "+\t\t\tif (readToken() == TerminalTokens.TokenNameLBRACKET) {", "+\t\t\t\twhile (readToken() == TerminalTokens.TokenNameLBRACKET) {", "+\t\t\t\t\tconsumeToken();", "+\t\t\t\t\tif (readToken() != TerminalTokens.TokenNameRBRACKET) {", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t\t}", "+\t\t\t\t\tconsumeToken();", "+\t\t\t\t\tdim++;", "+\t\t\t\t}", "+\t\t\t\tlong pos = ((long) typeRef.sourceStart) << 32 + typeRef.sourceEnd;", "+\t\t\t\tif (typeRef instanceof AnnotationSingleTypeReference) {", "+\t\t\t\t\tAnnotationSingleTypeReference singleRef = (AnnotationSingleTypeReference) typeRef;", "+\t\t\t\t\ttypeRef = new AnnotationArraySingleTypeReference(singleRef.token, dim, pos);", "+\t\t\t\t} else {", "+\t\t\t\t\tAnnotationQualifiedTypeReference qualifRef = (AnnotationQualifiedTypeReference) typeRef;", "+\t\t\t\t\ttypeRef = new AnnotationArrayQualifiedTypeReference(qualifRef, dim);", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\t// Read argument name", "+\t\t\tif (readToken() == TerminalTokens.TokenNameIdentifier) {", "+\t\t\t\tconsumeToken();", "+\t\t\t\tif (firstArg) { // verify position", "+\t\t\t\t\tif (iToken != 1)", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t} else if ((iToken % modulo) != 1) {", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t}", "+\t\t\t\tif (argName == null) { // verify that all arguments name are declared", "+\t\t\t\t\tif (!firstArg) {", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\targName = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\tiToken++;", "+\t\t\t} else if (argName != null) { // verify that no argument name is declared", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+", "+\t\t\t// Verify token position", "+\t\t\tif (firstArg) {", "+\t\t\t\tmodulo = iToken + 1;", "+\t\t\t} else {", "+\t\t\t\tif ((iToken % modulo) != (modulo - 1)) {", "+\t\t\t\t\tbreak nextArg;", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\t// Read separator or end arguments declaration", "+\t\t\tint token = readToken();", "+\t\t\tchar[] name = argName == null ? new char[0] : argName;", "+\t\t\tif (token == TerminalTokens.TokenNameCOMMA) {", "+\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner", "+\t\t\t\t\t\t.getCurrentTokenStartPosition()", "+\t\t\t\t\t\t- 1, typeRef);", "+\t\t\t\tpushOnAstStack(expr, firstArg);", "+\t\t\t\tconsumeToken();", "+\t\t\t\tiToken++;", "+\t\t\t} else if (token == TerminalTokens.TokenNameRPAREN) {", "+\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name,", "+\t\t\t\t\t\targStart,", "+\t\t\t\t\t\tthis.scanner.getCurrentTokenStartPosition()- 1,", "+\t\t\t\t\t\ttypeRef);", "+\t\t\t\tpushOnAstStack(expr, (iToken == (modulo - 1)));", "+\t\t\t\tint size = astLengthStack[astLengthPtr--];", "+\t\t\t\tAnnotationArgumentExpression[] arguments = new AnnotationArgumentExpression[size];", "+\t\t\t\tfor (int i = (size - 1); i >= 0; i--) {", "+\t\t\t\t\targuments[i] = (AnnotationArgumentExpression) astStack[astPtr--];", "+\t\t\t\t}", "+\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0], arguments);", "+\t\t\t\tmsg.receiver = receiver;", "+\t\t\t\treturn msg;", "+\t\t\t} else {", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t}", "+", "+\t\t// Invalid input: reset ast stacks pointers", "+\t\tconsumeToken();", "+\t\tif (iToken > 0) {", "+\t\t\tthis.astPtr = ptr;", "+\t\t\tthis.astLengthPtr = lptr;", "+\t\t}", "+\t\tthrow new InvalidInputException();", "+\t}", "-\tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException {", "-", "-\t\tint modulo = 0;\t// should be 2 for (Type,Type,...) and 3 for (Type arg,Type arg,...)", "-\t\tint iToken = 0;", "-\t\tchar[] argName = null;", "-\t\tint ptr = astPtr;", "-\t\tint lptr = astLengthPtr;", "-", "-\t\t// Parse arguments declaration if method reference", "-\t\tnextArg: while (this.index < this.scanner.eofPosition) {", "-", "-\t\t\t// Read argument type reference", "-\t\t\tint argStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\tTypeReference typeRef;", "-\t\t\t\ttypeRef = parseQualifiedName(false);", "-\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\tbreak nextArg;", "-\t\t\tboolean firstArg = modulo == 0;", "-\t\t\tif (firstArg) { // verify position", "-\t\t\t\tif (iToken != 0) break nextArg;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tif ((iToken % modulo) != 0) break nextArg;", "-\t\t\t}", "-\t\t\tif (typeRef == null) {", "-\t\t\t\tif (firstArg && this.currentTokenType == TerminalTokens.TokenNameRPAREN) {", "-\t\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0]);", "-\t\t\t\t\tmsg.receiver = receiver;", "-\t\t\t\t\treturn msg;", "-\t\t\t\t} ", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\tiToken++;", "-", "-\t\t\t// Read possible array declaration", "-\t\t\tint dim = 0;", "-\t\t\tif (readToken() == TerminalTokens.TokenNameLBRACKET) {", "-\t\t\t\twhile (readToken() == TerminalTokens.TokenNameLBRACKET) {", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tif (readToken() != TerminalTokens.TokenNameRBRACKET) {", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t\t}", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tdim++;", "-\t\t\t\t}", "-\t\t\t\tlong pos = ((long)typeRef.sourceStart)<<32 + typeRef.sourceEnd;", "-\t\t\t\tif (typeRef instanceof AnnotationSingleTypeReference) {", "-\t\t\t\t\tAnnotationSingleTypeReference singleRef = (AnnotationSingleTypeReference) typeRef;", "-\t\t\t\t\ttypeRef = new AnnotationArraySingleTypeReference(singleRef.token, dim, pos);", "-\t\t\t\t} else {", "-\t\t\t\t\tAnnotationQualifiedTypeReference qualifRef = (AnnotationQualifiedTypeReference) typeRef;", "-\t\t\t\t\ttypeRef = new AnnotationArrayQualifiedTypeReference(qualifRef, dim);", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\t// Read argument name", "-\t\t\tif (readToken() == TerminalTokens.TokenNameIdentifier) {", "-\t\t\t\tconsumeToken();", "-\t\t\t\tif (firstArg) { // verify position", "-\t\t\t\t\tif (iToken != 1) break nextArg;", "-\t\t\t\t}", "-\t\t\t\telse {", "-\t\t\t\t\tif ((iToken % modulo) != 1) break nextArg;", "-\t\t\t\t}", "-\t\t\t\tif (argName == null) { // verify that all arguments name are declared", "-\t\t\t\t\tif (!firstArg)  break nextArg;", "-\t\t\t\t}", "-\t\t\t\targName = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\tiToken++;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tif (argName != null) { // verify that no argument name is declared", "-\t\t\t\t\tbreak nextArg;", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\t// Verify token position", "-\t\t\tif (firstArg) {", "-\t\t\t\tmodulo = iToken+1;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tif ((iToken % modulo) != (modulo-1)) break nextArg;", "-\t\t\t}", "-", "-\t\t\t// Read separator or end arguments declaration", "-\t\t\tint token = readToken();", "-\t\t\tchar[] name = argName==null ? new char[0] : argName;", "-\t\t\tif (token == TerminalTokens.TokenNameCOMMA) {", "-\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner.getCurrentTokenStartPosition()-1, typeRef);", "-\t\t\t\tpushOnAstStack(expr, firstArg);", "-\t\t\t\tconsumeToken();", "-\t\t\t\tiToken++;", "-\t\t\t}", "-\t\t\telse if (token == TerminalTokens.TokenNameRPAREN) {", "-\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner.getCurrentTokenStartPosition()-1, typeRef);", "-\t\t\t\tpushOnAstStack(expr, (iToken==(modulo-1)));", "-\t\t\t\tint size = astLengthStack[astLengthPtr--];", "-\t\t\t\tAnnotationArgumentExpression[] arguments = new AnnotationArgumentExpression[size];", "-\t\t\t\tfor (int i=(size-1); i>=0; i--) {", "-\t\t\t\t\targuments[i] = (AnnotationArgumentExpression) astStack[astPtr--];", "-\t\t\t\t}", "-\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0], arguments);", "-\t\t\t\tmsg.receiver = receiver;", "-\t\t\t\treturn msg;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// Invalid input: reset ast stacks pointers", "-\t\tconsumeToken();", "-\t\tif (iToken > 0) {", "-\t\t\tthis.astPtr = ptr;", "-\t\t\tthis.astLengthPtr = lptr;", "-\t\t}", "-\t\tthrow new InvalidInputException();", "-\t}"]}], "num": 47149}