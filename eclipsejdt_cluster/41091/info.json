{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e0233ba0dbc2971ce6ba91e8e894c249", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "71e13b2492ad56c2353864f7580e7cf7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "5046f0da42323773845d7a3edf39df0b8c6a1944", "commitAfterChange": "80f69cca108e407e297e62382ba04bd29eb1703d", "methodNumberBeforeChange": 127, "methodNumberAfterChange": 130, "signatureBeforeChange": " \t \tpublic ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, boolean usePreviousSession, boolean resolveChainedLibraries) throws JavaModelException", "signatureAfterChange": "  \tpublic ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, IClasspathEntry[] referencedEntries, boolean usePreviousSession, boolean resolveChainedLibraries) throws JavaModelException", "diff": ["+", "+\tpublic ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, IClasspathEntry[] referencedEntries, boolean usePreviousSession, boolean resolveChainedLibraries) throws JavaModelException {", "+\t\tMap referencedEntriesMap = new HashMap();", "+\t\tList rawLibrariesPath = new ArrayList();", "+\t\t", "+\t\tif(resolveChainedLibraries) {", "+\t\t\tfor (int index = 0; index < rawClasspath.length; index++) {", "+\t\t\t\tIClasspathEntry currentEntry = rawClasspath[index]; ", "+\t\t\t\tif (currentEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {", "+\t\t\t\t\trawLibrariesPath.add(ClasspathEntry.resolveDotDot(currentEntry.getPath()));", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (referencedEntries != null) {", "+\t\t\t\t// The Set is required to keep the order intact while the referencedEntriesMap (Map)", "+\t\t\t\t// is used to map the referenced entries with path", "+\t\t\t\tLinkedHashSet referencedEntriesSet = new LinkedHashSet();", "+\t\t\t\tfor (int index = 0; index < referencedEntries.length; index++) {", "+\t\t\t\t\tIPath path = referencedEntries[index].getPath();", "+\t\t\t\t\tif (!rawLibrariesPath.contains(path) && referencedEntriesMap.get(path) == null) {", "+\t\t\t\t\t\treferencedEntriesMap.put(path, referencedEntries[index]);", "+\t\t\t\t\t\treferencedEntriesSet.add(referencedEntries[index]);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tresult.referencedEntries = new IClasspathEntry[referencedEntriesSet.size()];", "+\t\t\t\treferencedEntriesSet.toArray(result.referencedEntries);", "+\t\t\t}", "+\t\t}", "+\t\t", "-\t\t\t\t\t\tif (resolveChainedLibraries && resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {", "+\t\t\t\t\t\t// If the entry is already present in the rawReversetMap, it means the entry and the chained libraries", "+\t\t\t\t\t\t// have already been processed. So, skip it.", "+\t\t\t\t\t\tif (resolveChainedLibraries && resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY", "+\t\t\t\t\t\t\t\t\t\t\t\t\t&& result.rawReverseMap.get(resolvedEntry.getPath()) == null) {", "-\t\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[j], result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t\t\t\tif (!rawLibrariesPath.contains(extraEntries[j].getPath())) {", "+\t\t\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[j], result, resolvedEntries, externalFoldersManager, referencedEntriesMap, true);", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager, referencedEntriesMap, false);", "-\t\t\t\t\t\t\tif (resolveChainedLibraries) {", "+\t\t\t\t\t\t\tif (resolveChainedLibraries && result.rawReverseMap.get(cEntry.getPath()) == null) {", "-\t\t\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[k], result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t\t\t\t\tif (!rawLibrariesPath.contains(extraEntries[k].getPath())) {", "+\t\t\t\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[k], result, resolvedEntries, externalFoldersManager, referencedEntriesMap, true);", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\taddToResult(rawEntry, cEntry, result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t\taddToResult(rawEntry, cEntry, result, resolvedEntries, externalFoldersManager, referencedEntriesMap, false);", "-\t\t\t\t\tif (resolveChainedLibraries) {", "+\t\t\t\t\tif (resolveChainedLibraries && result.rawReverseMap.get(resolvedEntry.getPath()) == null) {", "-\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[k], result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t\t\tif (!rawLibrariesPath.contains(extraEntries[k].getPath())) {", "+\t\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[k], result, resolvedEntries, externalFoldersManager, referencedEntriesMap, true);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager, referencedEntriesMap, false);", "-\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager, referencedEntriesMap, false);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1cdd3a076ab652d3c06ce2fb5ecba6c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "795236662f4c72deb433448a946f4a36cebbebd0", "commitAfterChange": "b74a7b82d9221b86893a88ea5453e92534ffe51b", "methodNumberBeforeChange": 124, "methodNumberAfterChange": 127, "signatureBeforeChange": " \t \tprivate ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, boolean usePreviousSession) throws JavaModelException", "signatureAfterChange": " \t \tprivate ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, boolean usePreviousSession) throws JavaModelException", "diff": ["-\t\t\tIPath resolvedPath;", "-\t\t\t\t\t\tresolvedEntry = manager.getResolvedClasspathEntry(rawEntry, usePreviousSession);", "+\t\t\t\t\t\tresolvedEntry = manager.resolveVariableEntry(rawEntry, usePreviousSession);", "-\t\t\t\t\t\tif (result.rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) {", "-\t\t\t\t\t\t\tresult.rawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t\tresult.rootPathToResolvedEntries.put(resolvedPath, resolvedEntry);", "+\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {", "+\t\t\t\t\t\t\t// resolve Class-Path: in manifest", "+\t\t\t\t\t\t\tClasspathEntry[] extraEntries = ((ClasspathEntry) resolvedEntry).resolvedChainedLibraries();", "+\t\t\t\t\t\t\tfor (int j = 0, length2 = extraEntries.length; j < length2; j++) {", "+\t\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[j], result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager);", "-\t\t\t\t\t\t// resolve \"..\" in library path", "+\t\t\t\t\t\t", "+\t\t\t\t\t\t\t// resolve \"..\" in library path", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t// resolve Class-Path: in manifest", "+\t\t\t\t\t\t\tClasspathEntry[] extraEntries = cEntry.resolvedChainedLibraries();", "+\t\t\t\t\t\t\tfor (int k = 0, length2 = extraEntries.length; k < length2; k++) {", "+\t\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[k], result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (result.rawReverseMap.get(resolvedPath = cEntry.getPath()) == null) {", "-\t\t\t\t\t\t\tresult.rawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t\tresult.rootPathToResolvedEntries.put(resolvedPath, cEntry);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tresolvedEntries.add(cEntry);", "-\t\t\t\t\t\tif (cEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\taddToResult(rawEntry, cEntry, result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t// resolve \"..\" in library path", "-\t\t\t\t\t// $FALL-THROUGH$ use the default code below", "-\t\t\t\tdefault :", "-\t\t\t\t\tif (result.rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) {", "-\t\t\t\t\t\tresult.rawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\tresult.rootPathToResolvedEntries.put(resolvedPath, resolvedEntry);", "-\t\t\t\t\t}", "-\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "+\t\t\t\t\t", "+\t\t\t\t\t// resolve Class-Path: in manifest", "+\t\t\t\t\tClasspathEntry[] extraEntries = ((ClasspathEntry) resolvedEntry).resolvedChainedLibraries();", "+\t\t\t\t\tfor (int k = 0, length2 = extraEntries.length; k < length2; k++) {", "+\t\t\t\t\t\taddToResult(rawEntry, extraEntries[k], result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault :", "+\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\tbreak;", "+\t}"]}], "num": 41091}