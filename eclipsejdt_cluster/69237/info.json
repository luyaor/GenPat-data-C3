{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a509bb4ed27fba7b6cbccbfb72b71d03", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "73bfa8b2de404c0abf15c031cf5af9ae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "948661c4cb198af70b598b9954e5159cb73d7234", "commitAfterChange": "b1348e3d0230a581c7eb25acd6ec072853b12bb0", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "\r \tpublic void reportAccurateReference(\r \t\tint sourceStart,\r \t\tint sourceEnd,\r \t\tchar[][] qualifiedName,\r \t\tIJavaElement element,\r \t\tint accuracy)\r \t\tthrows CoreException", "signatureAfterChange": "\r \tpublic void reportAccurateReference(\r \t\tint sourceStart,\r \t\tint sourceEnd,\r \t\tchar[][] qualifiedName,\r \t\tIJavaElement element,\r \t\tint accuracy)\r \t\tthrows CoreException", "diff": ["+\t\tthrows CoreException {\r", "+\t\t\t\r", "+\t\tthis.reportAccurateReference(\r", "+\t\t\tsourceStart,\r", "+\t\t\tsourceEnd,\r", "+\t\t\tqualifiedName,\r", "+\t\t\telement,\r", "+\t\t\tnew int[] {accuracy},\r", "+\t\t\tfalse);\r", "+\t}\r", "-\t\t\t\t\t&& !CharOperation.equals(currentTokenSource, qualifiedName[i++])) {\r", "-\t\t\t\tif (CharOperation.equals(currentTokenSource, qualifiedName[i - 1])\r", "-\t\t\t\t\t&& (previousValid == -1 || previousValid == i - 2)) {\r", "-\t\t}\r", "-\t\twhile (token != TerminalSymbols.TokenNameEOF && i < tokenNumber);\r", "-\t\t// accept reference\r", "-\t\tif (refSourceStart != -1) {\r", "-\t\t\tthis.report(refSourceStart, refSourceEnd, element, accuracy);\r", "-\t\t} else {\r", "-\t\t\tthis.report(sourceStart, sourceEnd, element, accuracy);\r", "-\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ff1acf23a4730b248809105e55563a11", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java", "commitBeforeChange": "aa46ed677ee85f03d71a5e403b6a2449b883ffe1", "commitAfterChange": "c0de86876da4886baced9b3782c3e678b86d856e", "methodNumberBeforeChange": 340, "methodNumberAfterChange": 117, "signatureBeforeChange": " public void test2999_coverage()", "signatureAfterChange": " public void test0340_if_else_nested()", "diff": ["+// null analysis - if/else nested", "+public void test0340_if_else_nested() {", "+\tthis.runNegativeTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"  void foo(Object o) {\\n\" + ", "+\t\t\t\"    if (o == null) {\\n\" + ", "+\t\t\t\"      if (bar() == o) {\\n\" + ", "+\t\t\t\"        o.toString();\\n\" + ", "+\t\t\t\"      }\\n\" + ", "+\t\t\t\"    }\\n\" + ", "+\t\t\t\"  }\\n\" + ", "+\t\t\t\"  Object bar() {\\n\" + ", "+\t\t\t\"    return new Object();\\n\" + ", "+\t\t\t\"  }\\n\" + ", "+\t\t\t\"}\"},", "+\t\t\"----------\\n\" + ", "+\t\t\"1. ERROR in X.java (at line 5)\\n\" + ", "+\t\t\"\to.toString();\\n\" + ", "+\t\t\"\t^\\n\" + ", "+\t\t\"The variable o can only be null; it was either set to null or checked for null when last used\\n\" + ", "+\t\t\"----------\\n\");", "+}", "-// Coverage by code samples.", "-public void test2999_coverage() {", "-\tif (UnconditionalFlowInfo.coverageTestFlag) {", "-\t\t// sanity check: need to be sure that the tests execute properly when not", "-\t\t// trying to check coverage", "-\t\tUnconditionalFlowInfo.coverageTestId = 0;", "-\t\ttest0001_simple_local();", "-\t\ttest0053_array();", "-\t\ttest0070_type_reference();", "-\t\ttest0327_if_else();", "-\t\ttest0401_while();", "-\t\ttest0420_while();", "-\t\ttest0509_try_finally_embedded();", "-\t\ttest2000_flow_info();", "-\t\ttest2004_flow_info();", "-\t\ttest2008_flow_info();", "-\t\ttest2011_flow_info();", "-\t\ttest2013_flow_info();", "-\t\ttest2018_flow_info();", "-\t\ttest2019_flow_info();", "-\t\ttest2020_flow_info();", "-\t\t// coverage check", "-\t\tint failuresNb = 0;", "-\t\tfor (int i = 1; i <= coveragePointsNb; i++) {", "-\t\t\tif (i > 4 && i < 15 ||", "-\t\t\t\ti > 15 && i < 19 ||", "-\t\t\t\ti == 22 ||", "-\t\t\t\ti == 23 ||", "-\t\t\t\ti == 27 ||", "-\t\t\t\ti == 28 ||", "-\t\t\t\ti == 30 ||", "-\t\t\t\ti == 33 ||", "-\t\t\t\ti == 34 ||", "-\t\t\t\ti == 38 ||", "-\t\t\t\ti >= 43", "-\t\t\t\t) { // TODO (maxime) complete coverage tests", "-\t\t\t\tcontinue;", "-\t\t\t}", "-\t\t\ttry {", "-\t\t\t\tUnconditionalFlowInfo.coverageTestId = i;", "-\t\t\t\ttest0001_simple_local();", "-\t\t\t\ttest0053_array();", "-\t\t\t\ttest0070_type_reference();", "-\t\t\t\ttest0327_if_else();", "-\t\t\t\ttest0401_while();", "-\t\t\t\ttest0420_while();", "-\t\t\t\ttest0509_try_finally_embedded();", "-\t\t\t\ttest2000_flow_info();", "-\t\t\t\ttest2004_flow_info();", "-\t\t\t\ttest2008_flow_info();", "-\t\t\t\ttest2011_flow_info();", "-\t\t\t\ttest2013_flow_info();", "-\t\t\t\ttest2018_flow_info();", "-\t\t\t\ttest2019_flow_info();", "-\t\t\t\ttest2020_flow_info();", "-\t\t\t}", "-\t\t\tcatch (AssertionFailedError e) {", "-\t\t\t\tcontinue;", "-\t\t\t}", "-\t\t\tcatch (AssertionFailedException e) {", "-\t\t\t\tcontinue;", "-\t\t\t}", "-\t\t\tfailuresNb++;", "-\t\t\tSystem.out.println(\"Missing coverage point: \" + i);", "-\t\t}", "-\t\tUnconditionalFlowInfo.coverageTestId = 0; // reset for other tests", "-\t\tassertEquals(failuresNb + \" missing coverage point(s)\", failuresNb, 0);", "-\t}", "-}"]}], "num": 69237}