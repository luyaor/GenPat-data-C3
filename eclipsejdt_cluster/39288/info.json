{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9c66333f552ef83533ebdf576421667d", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36f0861935dc6b2cc065bed1efec6e1b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java", "commitBeforeChange": "653b549b2ec915800fe34bbb2ab9809b71ca66a5", "commitAfterChange": "2caa59d033a9b6c8ec71aab586472ad7fe749893", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected void analyseArguments(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, MethodBinding methodBinding, Expression[] arguments)", "signatureAfterChange": " protected void analyseArguments(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, MethodBinding methodBinding, Expression[] arguments)", "diff": ["-\tif (arguments != null && methodBinding.parameterNonNullness != null) {", "-", "-\t\t// check if varargs need special treatment:", "+\tif (arguments != null) {", "+\t\tCompilerOptions compilerOptions = currentScope.compilerOptions();", "+\t\tboolean considerTypeAnnotations = compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8", "+\t\t\t\t&& compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "+\t\tboolean hasJDK15NullAnnotations = methodBinding.parameterNonNullness != null;", "-\t\tboolean passThrough = false;", "-\t\tif (methodBinding.isVarargs()) {", "-\t\t\tint varArgPos = numParamsToCheck-1;", "-\t\t\t// this if-block essentially copied from generateArguments(..):", "-\t\t\tif (numParamsToCheck == arguments.length) {", "-\t\t\t\tTypeBinding varArgsType = methodBinding.parameters[varArgPos];", "-\t\t\t\tTypeBinding lastType = arguments[varArgPos].resolvedType;", "-\t\t\t\tif (lastType == TypeBinding.NULL", "-\t\t\t\t\t\t|| (varArgsType.dimensions() == lastType.dimensions()", "-\t\t\t\t\t\t&& lastType.isCompatibleWith(varArgsType)))", "-\t\t\t\t\tpassThrough = true; // pass directly as-is", "+\t\tif (considerTypeAnnotations || hasJDK15NullAnnotations) {", "+\t\t\t// check if varargs need special treatment:", "+\t\t\tboolean passThrough = false;", "+\t\t\tif (methodBinding.isVarargs()) {", "+\t\t\t\tint varArgPos = numParamsToCheck-1;", "+\t\t\t\t// this if-block essentially copied from generateArguments(..):", "+\t\t\t\tif (numParamsToCheck == arguments.length) {", "+\t\t\t\t\tTypeBinding varArgsType = methodBinding.parameters[varArgPos];", "+\t\t\t\t\tTypeBinding lastType = arguments[varArgPos].resolvedType;", "+\t\t\t\t\tif (lastType == TypeBinding.NULL", "+\t\t\t\t\t\t\t|| (varArgsType.dimensions() == lastType.dimensions()", "+\t\t\t\t\t\t\t&& lastType.isCompatibleWith(varArgsType)))", "+\t\t\t\t\t\tpassThrough = true; // pass directly as-is", "+\t\t\t\t}", "+\t\t\t\tif (!passThrough)", "+\t\t\t\t\tnumParamsToCheck--; // with non-passthrough varargs last param is fed from individual args -> don't check", "-\t\t\tif (!passThrough)", "-\t\t\t\tnumParamsToCheck--; // with non-passthrough varargs last param is fed from individual args -> don't check", "-", "-\t\tfor (int i = 0; i < numParamsToCheck; i++) {", "-\t\t\tif (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {", "+\t\tif (considerTypeAnnotations) {", "+\t\t\tfor (int i=0; i<numParamsToCheck; i++) {", "-\t\t\t\tint nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.", "-\t\t\t\tif (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided", "-\t\t\t\t\tflowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);", "+\t\t\t\t// prefer check based on type annotations:", "+\t\t\t\tint severity = findNullTypeAnnotationMismatch(expectedType, argument.resolvedType);", "+\t\t\t\tif (severity > 0) {", "+\t\t\t\t\t// immediate reporting:", "+\t\t\t\t\tcurrentScope.problemReporter().nullityMismatchingTypeAnnotation(argument, argument.resolvedType, expectedType, severity==1, currentScope.environment());", "+\t\t\t\t\t// next check flow-based null status against null JDK15-style annotations:", "+\t\t\t\t} else if (hasJDK15NullAnnotations && methodBinding.parameterNonNullness[i] == Boolean.TRUE) {", "+\t\t\t\t\tint nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.", "+\t\t\t\t\tif (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided", "+\t\t\t\t\t\tflowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);", "+\t\t\t\t}", "-\t\t}", "+\t\t} else if (hasJDK15NullAnnotations) {", "+\t\t\tfor (int i = 0; i < numParamsToCheck; i++) {", "+\t\t\t\tif (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {", "+\t\t\t\t\tTypeBinding expectedType = methodBinding.parameters[i];", "+\t\t\t\t\tExpression argument = arguments[i];", "+\t\t\t\t\tint nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.", "+\t\t\t\t\tif (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided", "+\t\t\t\t\t\tflowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9b730b56036bd57f07766781dcc1cfb5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "2a46362da18e1189829e578c276cfbf726376a20", "commitAfterChange": "948661c4cb198af70b598b9954e5159cb73d7234", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": "\r \tprivate void findLocalMethodDeclarations(\r \t\tchar[] methodName,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \t\tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType)", "signatureAfterChange": "\r \tprivate void findLocalMethodDeclarations(\r \t\tchar[] methodName,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \t\tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType)", "diff": ["+\t\t\t\t\tif(mustQualifyType(CharOperation.splitOn('.',parameterPackageNames[i]), parameterTypeNames[i])){\r", "+\t\t\t\t\t\tcompletion.append(parameterPackageNames[i]);\r", "+\t\t\t\t\t\tcompletion.append('.');\r", "+\t\t\t\t\t}\r", "-\t\t\t\t\tcompletion.append(parameterNames[i]);\r", "+\t\t\t\t\tif(parameterNames != null){\r", "+\t\t\t\t\t\tcompletion.append(parameterNames[i]);\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tcompletion.append('%');\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\r", "+\t\t\t\tReferenceBinding[] exceptions = method.thrownExceptions;\r", "+\t\t\t\tint exceptionCount =0;\r", "+\t\t\t\tif (exceptions != null && (( exceptionCount = exceptions.length) > 0)){\r", "+\t\t\t\t\tcompletion.append(' ');\r", "+\t\t\t\t\tcompletion.append(THROWS);\r", "+\t\t\t\t\tcompletion.append(' ');\r", "+\t\t\t\t\tfor(int i = 0; i < exceptionCount ; i++){\r", "+\t\t\t\t\t\tReferenceBinding exception = exceptions[i];\r", "+\t\t\t\t\t\tchar[] typeName = exception.qualifiedSourceName();\r", "+\t\t\t\t\t\tchar[] packageName = exception.qualifiedPackageName();\r", "+\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\tif(mustQualifyType(CharOperation.splitOn('.',packageName), typeName)){\r", "+\t\t\t\t\t\t\tcompletion.append(packageName);\r", "+\t\t\t\t\t\t\tcompletion.append('.');\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tcompletion.append(typeName);\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\t\tif(i != (exceptionCount - 1)){\r", "+\t\t\t\t\t\t\tcompletion.append(',');\r", "+\t\t\t\t\t\t\tcompletion.append(' ');\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r"]}], "num": 39288}