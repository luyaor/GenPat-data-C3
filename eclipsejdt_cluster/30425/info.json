{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e344b977cdbfe2147d28026d4ffcc03a", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f399d907dfd88149dceececb3019e83", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java", "commitBeforeChange": "8c67d56825136ce0d7026162576ad6997e930bdc", "commitAfterChange": "0b88f9a0bb1950edae0865a8658608a49edfc445", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " private void checkAndSetModifiersForMethod(MethodBinding methodBinding)", "signatureAfterChange": " private void checkAndSetModifiersForMethod(MethodBinding methodBinding)", "diff": ["-\t\t// 9.4 got updated for JSR 335 (default methods), more permissive grammar plus:", "-\t\t// \"It is a compile-time error if an abstract method declaration contains either of the keywords strictfp or synchronized.\"", "-\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8 && !methodBinding.isAbstract()) {", "-\t\t\texpectedModifiers |= (ClassFileConstants.AccSynchronized | ClassFileConstants.AccStrictfp);", "-\t\t}", "+\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8 && !declaringClass.isAnnotationType()) {", "+\t\t\tif (!methodBinding.isAbstract()) {", "+\t\t\t\texpectedModifiers |= ClassFileConstants.AccStrictfp", "+\t\t\t\t\t\t\t\t\t\t| (isDefaultMethod ?  ExtraCompilerModifiers.AccDefaultMethod : ClassFileConstants.AccStatic);", "+\t\t\t}", "+\t\t\t// Kludge - The AccDefaultMethod bit is outside the lower 16 bits and got removed earlier. Putting it back.", "+\t\t\tif (isDefaultMethod) {", "+\t\t\t\trealModifiers |= ExtraCompilerModifiers.AccDefaultMethod;", "+\t\t\t}", "+\t\t}", "-\t\t}", "-\t\tif (isDefaultMethod && (modifiers & ClassFileConstants.AccAbstract) != 0) {", "-\t\t\tproblemReporter().abstractMethodNeedingNoBody((AbstractMethodDeclaration) this.referenceContext);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "829067c782eb6fd34069e05942a502a8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java", "commitBeforeChange": "4c2900096a422605a0884d5ca39839064ce0c89a", "commitAfterChange": "e0956e75ff6cb3066016adc9dae90f9c1534dda4", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": "  public int getNextToken() throws InvalidInputException", "signatureAfterChange": "  public int getNextToken() throws InvalidInputException", "diff": ["-\tint token = this.nextToken != TokenNameNotAToken ? this.nextToken : getNextToken0();", "-\tthis.nextToken = TokenNameNotAToken;", "+\tint token;", "+\tif (this.nextToken != TokenNameNotAToken) {", "+\t\ttoken = this.nextToken;", "+\t\tthis.nextToken = TokenNameNotAToken;", "+\t\treturn token; // presumed to be unambiguous.", "+\t}", "-\tif (!this.scanningJava8Plus) {", "-\t\treturn token;", "+\ttoken = getNextToken0();", "+\tif (!this.scanningJava8Plus || this.activeParser == null) {", "+\t\treturn token;  // no audience, no magic.", "-\tif (token == TokenNameLPAREN && this.lookAheadState == POST_LAMBDA_PREFIX) {", "+\tif (token == TokenNameLPAREN && this.activeParser.atConflictScenario(token)) {", "-\t} else if (token == TokenNameLESS && this.lookAheadState == POST_IDENTIFIER) {", "+\t} else if (token == TokenNameLESS && this.activeParser.atConflictScenario(token)) {", "-\t}", "-\tif (token < ParserBasicInformation.NUM_TERMINALS) {", "-\t\tthis.lookAheadState = lookAheadTable[this.lookAheadState][token];"]}], "num": 30425}