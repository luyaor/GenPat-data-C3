{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ac4f05b0141975e1ff82a48e97c0cf55", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1175b037659027bbcd1b1ab06f22bb4a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "b2caa750738c585e3970cd6cbdee229067bea596", "commitAfterChange": "8d1eb8a1ba1f8d42e85f057c2e74fe0db8cb690d", "methodNumberBeforeChange": 93, "methodNumberAfterChange": 93, "signatureBeforeChange": " \tpublic boolean visit(NullLiteral nullLiteral, BlockScope scope)", "signatureAfterChange": " \tpublic boolean visit(StringLiteralConcetanation stringLiteral, BlockScope scope)", "diff": ["+\t */", "+\tpublic boolean visit(StringLiteralConcetanation stringLiteral, BlockScope scope) {", "+\t\tfinal int numberOfParens = (stringLiteral.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;", "+\t\tif (numberOfParens > 0) {", "+\t\t\tmanageOpeningParenthesizedExpression(stringLiteral, numberOfParens);", "+\t\t}", "+", "+\t\tthis.scribe.printComment();", "+\t\tASTNode[] fragments = stringLiteral.literals;", "+\t\tint fragmentsSize = stringLiteral.counter;", "+\t\tAlignment binaryExpressionAlignment = this.scribe.createAlignment(\"binaryExpressionAlignment\", this.preferences.alignment_for_binary_expression, Alignment.R_OUTERMOST, fragmentsSize, this.scribe.scanner.currentPosition); //$NON-NLS-1$", "+\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "+\t\tboolean ok = false;", "+\t\tdo {", "+\t\t\ttry {", "+\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\tASTNode fragment = fragments[i];", "+\t\t\t\t\tfragment.traverse(this, scope);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t// a new line has been inserted by printTrailingComment()", "+\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNamePLUS, this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tfragments[fragmentsSize - 1].traverse(this, scope);", "+\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\tok = true;", "+\t\t\t} catch(AlignmentException e){", "+\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t}", "+\t\t} while (!ok);\t\t", "+\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);", "+\t\tif (numberOfParens > 0) {", "+\t\t\tmanageClosingParenthesizedExpression(stringLiteral, numberOfParens);", "+\t\t}", "+\t\treturn false;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7db0f0b7bfae0567cf76d1811cda76fa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor2.java", "commitBeforeChange": "74d059b3fbdc00070c70bee76509a44ccad7fb4d", "commitAfterChange": "31d2b0bac7c9b032f1ad8765fd4577eaff8d79fd", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 53, "signatureBeforeChange": "  \tpublic boolean visit(InfixExpression node)", "signatureAfterChange": "  \tpublic boolean visit(InfixExpression node)", "diff": ["-\t\t// TODO Auto-generated method stub", "-\t\treturn super.visit(node);", "+\t\t// active line wrapping", "+\t\tfinal InfixExpressionWrappingBuilder builder = new InfixExpressionWrappingBuilder();", "+\t\tnode.accept(builder);", "+\t\tfinal int fragmentsSize = builder.getFragmentsCounter();", "+\t\tthis.scribe.printComment();", "+\t\tAlignment2 binaryExpressionAlignment = this.scribe.createAlignment(\"binaryExpressionAlignment\", this.preferences.alignment_for_binary_expression, Alignment.R_OUTERMOST, fragmentsSize, this.scribe.scanner.currentPosition); //$NON-NLS-1$", "+\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "+\t\tboolean ok = false;", "+\t\tList fragments = builder.fragments;", "+\t\tint[] operators = builder.getOperators();", "+/*\t\tdo {", "+\t\t\ttry {", "+\t\t\t\tfinal boolean alignAfterOperator = false;", "+\t\t\t\tif (alignAfterOperator) {", "+\t\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\t((Expression) fragments.get(i)).accept(this);", "+\t\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t\t// a new line has been inserted by printTrailingComment()", "+\t\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, fragmentsSize - 1);", "+\t\t\t\t\t((Expression) fragments.get(fragmentsSize - 1)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, 0);", "+\t\t\t\t\t((Expression) fragments.get(0)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tfor (int i = 1; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\tthis.scribe.printNextToken(operators[i - 1], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t((Expression) fragments.get(i)).accept(this);", "+\t\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, fragmentsSize - 1);", "+\t\t\t\t\tthis.scribe.printNextToken(operators[fragmentsSize - 2], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\tif (operators[fragmentsSize - 2] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t\t((Expression) fragments.get(fragmentsSize - 1)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tok = true;", "+\t\t\t} catch(AlignmentException e){", "+\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t}", "+\t\t} while (!ok);", "+\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);*/", "+\t\tdo {", "+\t\t\ttry {", "+\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\t((Expression) fragments.get(i)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\tif ( this.preferences.insert_space_after_binary_operator", "+\t\t\t\t\t\t\t|| (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS))) {", "+\t\t\t\t\t\t// the next character is a minus (unary operator) or the preference is set to true", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t((Expression) fragments.get(fragmentsSize - 1)).accept(this);", "+\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tok = true;", "+\t\t\t} catch(AlignmentException e){", "+\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t}", "+\t\t} while (!ok);\t\t", "+\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);\t\t", "+/*\t\t\tleftOperand.accept(this);", "+\t\t\tfinal int operator = extractInfixExpressionOperator(node);", "+\t\t\tthis.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);", "+\t\t\tif ( this.preferences.insert_space_after_binary_operator", "+\t\t\t\t\t|| (operator == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS))) {", "+\t\t\t\t// the next character is a minus (unary operator) or the preference is set to true", "+\t\t\t\tthis.scribe.space();", "+\t\t\t}", "+\t\t\trightOperand.accept(this);*/", "+\t\treturn false;"]}], "num": 14280}