{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c6c3ecd4743204bbb8be6d47e6f5d378", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ad8591528b274a320b131bc069711dc8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "673b7eda95cd26449992e862f0c63f2c612903a0", "commitAfterChange": "b04602938404af4f8569a399fb36a5018768a262", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r \r \tprivate void checkInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": "\r private void checkInheritedMethods(MethodBinding[] methods, int length)", "diff": ["-\r", "-\tprivate void checkInheritedMethods(MethodBinding[] methods, int length) {\r", "-\t\tTypeBinding returnType = methods[0].returnType;\r", "-\t\tint index = length;\r", "-\t\twhile ((--index > 0) && (returnType == methods[index].returnType));\r", "-\t\tif (index > 0) { // All inherited methods do NOT have the same vmSignature\r", "-\t\t\tthis.problemReporter().inheritedMethodsHaveIncompatibleReturnTypes(\r", "-\t\t\t\tthis.type,\r", "-\t\t\t\tmethods,\r", "-\t\t\t\tlength);\r", "-\t\t\treturn;\r", "-\t\t}\r", "-\r", "-\t\tMethodBinding concreteMethod = null;\r", "-\t\tfor (int i = length;\r", "-\t\t\t--i >= 0;\r", "-\t\t\t) // Remember that only one of the methods can be non-abstract\r", "-\t\t\tif (!methods[i].isAbstract()) {\r", "-\t\t\t\tconcreteMethod = methods[i];\r", "-\t\t\t\tbreak;\r", "-\t\t\t}\r", "-\t\tif (concreteMethod == null) {\r", "-\t\t\tif (this.type.isClass() && !this.type.isAbstract()) {\r", "-\t\t\t\tfor (int i = length; --i >= 0;)\r", "-\t\t\t\t\tif (!mustImplementAbstractMethod(methods[i]))\r", "-\t\t\t\t\t\treturn;\r", "-\t\t\t\t// in this case, we have already reported problem against the concrete superclass\r", "-\t\t\t\tthis.problemReporter().abstractMethodMustBeImplemented(this.type, methods[0]);\r", "-\t\t\t}\r", "-\t\t\treturn;\r", "-\t\t}\r", "-\r", "-\t\tMethodBinding[] abstractMethods = new MethodBinding[length - 1];\r", "-\t\tindex = 0;\r", "-\t\tfor (int i = length; --i >= 0;)\r", "-\t\t\tif (methods[i] != concreteMethod)\r", "-\t\t\t\tabstractMethods[index++] = methods[i];\r", "-\r", "-\t\t// Remember that interfaces can only define public instance methods\r", "-\t\tif (concreteMethod.isStatic())\r", "-\t\t\t// Cannot inherit a static method which is specified as an instance method by an interface\r", "-\t\t\tthis.problemReporter().staticInheritedMethodConflicts(\r", "-\t\t\t\ttype,\r", "-\t\t\t\tconcreteMethod,\r", "-\t\t\t\tabstractMethods);\r", "-\t\tif (!concreteMethod.isPublic())\r", "-\t\t\t// Cannot reduce visibility of a public method specified by an interface\r", "-\t\t\tthis.problemReporter().inheritedMethodReducesVisibility(\r", "-\t\t\t\ttype,\r", "-\t\t\t\tconcreteMethod,\r", "-\t\t\t\tabstractMethods);\r", "-\t\tif (concreteMethod.thrownExceptions != NoExceptions)\r", "-\t\t\tfor (int i = abstractMethods.length; --i >= 0;)\r", "-\t\t\t\tthis.checkExceptions(concreteMethod, abstractMethods[i]);\r", "-\t}\r", "+}\r", "+private void checkInheritedMethods(MethodBinding[] methods, int length) {\r", "+\tTypeBinding returnType = methods[0].returnType;\r", "+\tint index = length;\r", "+\twhile ((--index > 0) && (returnType == methods[index].returnType));\r", "+\tif (index > 0) {\t\t// All inherited methods do NOT have the same vmSignature\r", "+\t\tthis.problemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);\r", "+\t\treturn;\r", "+\t}\r", "+\r", "+\tMethodBinding concreteMethod = null;\r", "+\tfor (int i = length; --i >= 0;)\t\t// Remember that only one of the methods can be non-abstract\r", "+\t\tif (!methods[i].isAbstract()) {\r", "+\t\t\tconcreteMethod = methods[i];\r", "+\t\t\tbreak;\r", "+\t\t}\r", "+\tif (concreteMethod == null) {\r", "+\t\tif (this.type.isClass() && !this.type.isAbstract()) {\r", "+\t\t\tfor (int i = length; --i >= 0;)\r", "+\t\t\t\tif (!mustImplementAbstractMethod(methods[i]))\r", "+\t\t\t\t\treturn;\t\t// in this case, we have already reported problem against the concrete superclass\r", "+\t\t\tthis.problemReporter().abstractMethodMustBeImplemented(this.type, methods[0]);\r", "+\t\t}\r", "+\t\treturn;\r", "+\t} else if ((concreteMethod.declaringClass == this.type.scope.getJavaLangObject()) && this.type.isInterface() ){\r", "+\t\t// no reason to compare Object's method against inherited interface methods\r", "+\t\treturn;\r", "+\t}\r", "+\r", "+\tMethodBinding[] abstractMethods = new MethodBinding[length - 1];\r", "+\tindex = 0;\r", "+\tfor (int i = length; --i >= 0;)\r", "+\t\tif (methods[i] != concreteMethod)\r", "+\t\t\tabstractMethods[index++] = methods[i];\r", "+\r", "+\t// Remember that interfaces can only define public instance methods\r", "+\tif (concreteMethod.isStatic())\r", "+\t\t// Cannot inherit a static method which is specified as an instance method by an interface\r", "+\t\tthis.problemReporter().staticInheritedMethodConflicts(type, concreteMethod, abstractMethods);\t\r", "+\tif (!concreteMethod.isPublic())\r", "+\t\t// Cannot reduce visibility of a public method specified by an interface\r", "+\t\tthis.problemReporter().inheritedMethodReducesVisibility(type, concreteMethod, abstractMethods);\r", "+\tif (concreteMethod.thrownExceptions != NoExceptions)\r", "+\t\tfor (int i = abstractMethods.length; --i >= 0;)\r", "+\t\t\tthis.checkExceptions(concreteMethod, abstractMethods[i]);\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d5246d1411d8746b147542ea173492e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "e8809c830aa9910fa512262ec2fd91fe29f694ac", "commitAfterChange": "35baf3186aac25eb2ca497b2ad6369f011992017", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[] abstractMethods)", "signatureAfterChange": " void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[] abstractMethods)", "diff": ["-\t\tif (originalInherited.declaringClass.isInterface()", "-\t\t\t\t&& this.type.superclass.erasure().findSuperTypeOriginatingFrom(originalInherited.declaringClass) == null) {", "-\t\t\tthis.type.addSyntheticBridgeMethod(originalInherited, concreteMethod.original());", "+\t\tif (originalInherited.declaringClass.isInterface()) {", "+\t\t\tif ((concreteMethod.declaringClass == this.type.superclass && this.type.superclass.isParameterizedType())", "+\t\t\t\t|| this.type.superclass.erasure().findSuperTypeOriginatingFrom(originalInherited.declaringClass) == null)", "+\t\t\t\t\tthis.type.addSyntheticBridgeMethod(originalInherited, concreteMethod.original());"]}], "num": 8907}