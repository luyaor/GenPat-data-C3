{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b6510532b94d8378371a5405201ffaa8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "963980ac4b155d8def9889281f472700", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "4bca3a5b750a1427c84a78f92ee835c1f5e75da7", "commitAfterChange": "65cffea518e323981e83002b5b2ff520f43d6c58", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static String buildAllDirectoriesInto( \t\tString outputPath, \t\tString relativeFileName) \t\tthrows IOException", "signatureAfterChange": " \tpublic static String buildAllDirectoriesInto( \t\tString outputPath, \t\tString relativeFileName) \t\tthrows IOException", "diff": ["-\t\t// First we ensure that the outputPath exists", "-\t\t// To be able to pass the mkdirs() method we need to remove the extra file separator at the end of the outDir name", "-\t\tif (outputPath.endsWith(fileSeparator)) {", "-\t\t\toutputPath = outputPath.substring(0, outputPath.length() - 1);", "-\t\t}", "-\t\tf = new File(outputPath);", "-\t\tif (f.exists()) {", "-\t\t\tif (!f.isDirectory()) {", "-\t\t\t\tfinal String message = Messages.bind(Messages.output_isFile, f.getAbsolutePath());", "-\t\t\t\tthrow new IOException(message);", "+\t\t\t// these could be optimized out if we normalized paths once and for", "+\t\t\t// all", "+\t\trelativeFileName = relativeFileName.replace('/', fileSeparatorChar);", "+\t\tString outputDirPath, fileName;", "+\t\tint separatorIndex = relativeFileName.lastIndexOf(fileSeparatorChar);", "+\t\tif (separatorIndex == -1) {", "+\t\t\tif (outputPath.endsWith(fileSeparator)) {", "+\t\t\t\toutputDirPath = outputPath.substring(0, outputPath.length() - 1);", "+\t\t\t\tfileName = outputPath + relativeFileName;", "+\t\t\t} else {", "+\t\t\t\toutputDirPath = outputPath;", "+\t\t\t\tfileName = outputPath + fileSeparator + relativeFileName;", "-\t\t\t// we have to create that directory", "-\t\t\tif (!f.mkdirs()) {", "-\t\t\t\tfinal String message = Messages.bind(Messages.output_notValidAll, f.getAbsolutePath());", "-\t\t\t\tthrow new IOException(message);", "+\t\t\tif (outputPath.endsWith(fileSeparator)) {", "+\t\t\t\toutputDirPath = outputPath + ", "+\t\t\t\t\trelativeFileName.substring(0, separatorIndex);", "+\t\t\t\tfileName = outputPath + relativeFileName;", "+\t\t\t} else {", "+\t\t\t\toutputDirPath = outputPath + fileSeparator +", "+\t\t\t\t\trelativeFileName.substring(0, separatorIndex);", "+\t\t\t\tfileName = outputPath + fileSeparator + relativeFileName;", "-\t\tStringBuffer outDir = new StringBuffer(outputPath);", "-\t\toutDir.append(fileSeparator);", "-\t\tStringTokenizer tokenizer =", "-\t\t\tnew StringTokenizer(relativeFileName, fileSeparator);", "-\t\tString token = tokenizer.nextToken();", "-\t\twhile (tokenizer.hasMoreTokens()) {", "-\t\t\tf = new File(outDir.append(token).append(fileSeparator).toString());", "+\t\tf = new File(outputDirPath);", "+\t\tf.mkdirs();", "+\t\tif (f.isDirectory()) {", "+\t\t\treturn fileName;", "+\t\t} else {", "+\t\t\t// the directory creation failed for some reason - retry using", "+\t\t\t// a slower algorithm so as to refine the diagnostic", "+\t\t\tif (outputPath.endsWith(fileSeparator)) {", "+\t\t\t\toutputPath = outputPath.substring(0, outputPath.length() - 1);", "+\t\t\t}", "+\t\t\tf = new File(outputPath);", "+\t\t\tboolean checkFileType = false;", "-\t\t\t\t// The outDir already exists, so we proceed the next entry", "-\t\t\t\t// System.out.println(\"outDir: \" + outDir + \" already exists.\");", "+\t\t\t  \tcheckFileType = true; // pre-existed", "-\t\t\t\t// Need to add the outDir", "-\t\t\t\tif (!f.mkdir()) {", "-\t\t\t\t\tthrow new IOException(Messages.bind(Messages.output_notValid, f.getName()));", "+\t\t\t\t// we have to create that directory", "+\t\t\t\tif (!f.mkdirs()) {", "+\t\t\t\t  \tif (f.exists()) {", "+\t\t\t\t  \t  \t// someone else created f -- need to check its type", "+\t\t\t\t  \t  \tcheckFileType = true;", "+\t\t\t\t  \t} else {", "+\t\t\t\t  \t  \t// no one could create f -- complain", "+\t    \t\t\t\tthrow new IOException(Messages.bind(", "+\t    \t\t\t\t\tMessages.output_notValidAll, f.getAbsolutePath()));", "+\t\t\t\t  \t}", "-\t\t\ttoken = tokenizer.nextToken();", "+\t\t\tif (checkFileType) {", "+\t\t\t  \tif (!f.isDirectory()) {", "+\t    \t\t\tthrow new IOException(Messages.bind(", "+\t    \t\t\t\tMessages.output_isFile, f.getAbsolutePath()));", "+\t\t\t  \t}", "+\t\t\t}", "+\t\t\tStringBuffer outDir = new StringBuffer(outputPath);", "+\t\t\toutDir.append(fileSeparator);", "+\t\t\tStringTokenizer tokenizer =", "+\t\t\t\tnew StringTokenizer(relativeFileName, fileSeparator);", "+\t\t\tString token = tokenizer.nextToken();", "+\t\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\t\tf = new File(outDir.append(token).append(fileSeparator).toString());", "+\t\t\t  \tcheckFileType = false; // reset", "+\t\t\t\tif (f.exists()) {", "+\t\t\t\t  \tcheckFileType = true; // this is suboptimal, but it catches corner cases", "+\t\t\t\t  \t\t\t\t\t\t  // in which a regular file pre-exists", "+\t\t\t\t} else {", "+\t\t\t\t// we have to create that directory", "+\t    \t\t\tif (!f.mkdir()) {", "+\t    \t\t\t  \tif (f.exists()) {", "+\t    \t\t\t  \t  \t// someone else created f -- need to check its type", "+\t    \t\t\t  \t  \tcheckFileType = true;", "+\t    \t\t\t  \t} else {", "+\t    \t\t\t  \t  \t// no one could create f -- complain", "+\t        \t\t\t\tthrow new IOException(Messages.bind(", "+\t        \t\t\t\t\tMessages.output_notValid, ", "+\t        \t\t\t\t\t\toutDir.substring(outputPath.length() + 1, ", "+\t        \t\t\t\t\t\t\toutDir.length() - 1),", "+\t        \t\t\t\t\t\toutputPath));", "+\t    \t\t\t  \t}", "+\t    \t\t\t}", "+\t\t\t\t}", "+\t    \t\tif (checkFileType) {", "+\t    \t\t  \tif (!f.isDirectory()) {", "+\t        \t\t\tthrow new IOException(Messages.bind(", "+\t        \t\t\t\tMessages.output_isFile, f.getAbsolutePath()));", "+\t    \t\t  \t}", "+\t    \t\t}", "+\t\t\t\ttoken = tokenizer.nextToken();", "+\t\t\t}", "+\t\t\t// token contains the last one", "+\t\t\treturn outDir.append(token).toString();", "-\t\t// token contains the last one", "-\t\treturn outDir.append(token).toString();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf11b25af413da7ba15afb1179c815f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java", "commitBeforeChange": "40ad9904e939ba54abece52421044021edd6e1c0", "commitAfterChange": "8d45cb26fc5ad244f93e8632d761d46ad4a120cf", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic static void handleResourceAssignment(FlowInfo flowInfo, Statement location, Expression rhs, LocalVariableBinding local, \t\t\t\tLocalVariableBinding previousTrackerBinding)", "signatureAfterChange": " \tpublic static void handleResourceAssignment(BlockScope scope, FlowInfo upstreamInfo, FlowInfo flowInfo, ASTNode location, Expression rhs, LocalVariableBinding local)", "diff": ["-\tpublic static void handleResourceAssignment(FlowInfo flowInfo, Statement location, Expression rhs, LocalVariableBinding local,", "-\t\t\t\tLocalVariableBinding previousTrackerBinding) ", "+\tpublic static void handleResourceAssignment(BlockScope scope, FlowInfo upstreamInfo, FlowInfo flowInfo, ASTNode location, Expression rhs, LocalVariableBinding local)", "-\t\tif (isAutoCloseable(rhs.resolvedType)) {", "+\t\t// does the LHS (local) already have a tracker, indicating we may leak a resource by the assignment?", "+\t\tFakedTrackingVariable previousTracker = null;", "+\t\tFakedTrackingVariable disconnectedTracker = null;", "+\t\tif (local.closeTracker != null) {", "+\t\t\t// assigning to a variable already holding an AutoCloseable, has it been closed before?", "+\t\t\tpreviousTracker = local.closeTracker;", "+\t\t\tint nullStatus = upstreamInfo.nullStatus(local);", "+\t\t\tif (nullStatus != FlowInfo.NULL && nullStatus != FlowInfo.UNKNOWN) // only if previous value may be relevant", "+\t\t\t\tdisconnectedTracker = previousTracker; // report error below, unless we have a self-wrap assignment", "+\t\t}", "+", "+\t\tif (rhs.resolvedType != TypeBinding.NULL) {", "-\t", "-\t\t\tif (rhsTrackVar != null) {\t\t\t\t\t\t\t\t// 1. share tracking variable with RHS?", "-\t\t\t\tlocal.closeTracker = rhsTrackVar;", "-\t\t\t\t// keep null-status unchanged across this assignment", "-\t\t\t} else if (previousTrackerBinding != null) {\t\t\t// 2. re-use tracking variable from the LHS?", "-\t\t\t\t// re-assigning from a fresh, mark as not-closed again:", "-\t\t\t\tflowInfo.markAsDefinitelyNull(previousTrackerBinding);", "+\t\t\tif (rhsTrackVar != null) {\t\t\t\t\t\t\t\t// 1. if RHS has a tracking variable...", "+\t\t\t\tif (local.closeTracker == null) {", "+\t\t\t\t\t// null shouldn't occur but let's play safe", "+\t\t\t\t\tif (rhsTrackVar.originalBinding != null)", "+\t\t\t\t\t\tlocal.closeTracker = rhsTrackVar;\t\t\t//\t\ta.: let fresh LHS share it ", "+\t\t\t\t} else {", "+\t\t\t\t\tif (rhsTrackVar == disconnectedTracker && rhs instanceof AllocationExpression)", "+\t\t\t\t\t\treturn; \t\t\t\t\t\t\t\t\t// \t\tb.: self wrapper: res = new Wrap(res); -> done!", "+\t\t\t\t\tlocal.closeTracker = rhsTrackVar;\t\t\t\t//\t\tc.: conflicting LHS and RHS, proceed with recordErrorLocation below", "+\t\t\t\t}", "+\t\t\t\t// keep close-status of RHS unchanged across this assignment", "+\t\t\t} else if (previousTracker != null) {\t\t\t\t\t// 2. re-use tracking variable from the LHS?", "+\t\t\t\t// re-assigning from a fresh value, mark as not-closed again:", "+\t\t\t\tif ((previousTracker.globalClosingState & (SHARED_WITH_OUTSIDE|OWNED_BY_OUTSIDE)) == 0)", "+\t\t\t\t\tflowInfo.markAsDefinitelyNull(previousTracker.binding);", "+\t\t\t\tlocal.closeTracker = analyseCloseableExpression(flowInfo, local, location, rhs, previousTracker);", "-\t\t\t\tlocal.closeTracker = new FakedTrackingVariable(local, location);", "-\t\t\t\t// a fresh resource, mark as not-closed:", "-\t\t\t\tflowInfo.markAsDefinitelyNull(local.closeTracker.binding);", "+\t\t\t\trhsTrackVar = analyseCloseableExpression(flowInfo, local, location, rhs, null);", "+\t\t\t\tif (rhsTrackVar != null) {", "+\t\t\t\t\tlocal.closeTracker = rhsTrackVar;", "+\t\t\t\t\t// a fresh resource, mark as not-closed:", "+\t\t\t\t\tif ((rhsTrackVar.globalClosingState & (SHARED_WITH_OUTSIDE|OWNED_BY_OUTSIDE)) == 0)", "+\t\t\t\t\t\tflowInfo.markAsDefinitelyNull(rhsTrackVar.binding);", "-//\t\t\t\tif (flowContext.initsOnFinally != null)", "-//\t\t\t\t\tflowContext.initsOnFinally.markAsDefinitelyNonNull(trackerBinding);", "+//\t\t\t\t\tif (flowContext.initsOnFinally != null)", "+//\t\t\t\t\t\tflowContext.initsOnFinally.markAsDefinitelyNonNull(trackerBinding);", "+\t\t\t\t}", "+\t\t}", "+", "+\t\tif (disconnectedTracker != null) {", "+\t\t\tif (disconnectedTracker.innerTracker != null && disconnectedTracker.innerTracker.binding.declaringScope == scope) {", "+\t\t\t\t// discard tracker for the wrapper but keep the inner:", "+\t\t\t\tdisconnectedTracker.innerTracker.outerTracker = null;", "+\t\t\t\tscope.pruneWrapperTrackingVar(disconnectedTracker);", "+\t\t\t} else {", "+\t\t\t\tint upstreamStatus = upstreamInfo.nullStatus(disconnectedTracker.binding);", "+\t\t\t\tif (upstreamStatus != FlowInfo.NON_NULL)", "+\t\t\t\t\tdisconnectedTracker.recordErrorLocation(location, upstreamStatus);", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f7461e995ca5566f395e12ecdc537231", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/FormatJavadocBlock.java", "commitBeforeChange": "b7259e61ad84f1dda95b63bf74b4b4f38727c3a6", "commitAfterChange": "db331d5badcb0b35069c87387ccad89f9c226a52", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  protected void toString(StringBuffer buffer)", "signatureAfterChange": "  protected void toString(StringBuffer buffer)", "diff": ["+\t}", "+\tStringBuffer flagsBuffer = new StringBuffer();", "+\tif (isDescription()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"description\"); //$NON-NLS-1$", "+\t}", "+\tif (isFirst()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"first\"); //$NON-NLS-1$", "+\t}", "+\tif (isHeaderLine()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"header line\"); //$NON-NLS-1$", "+\t}", "+\tif (isImmutable()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"immutable\"); //$NON-NLS-1$", "+\t}", "+\tif (isInDescription()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"in description\"); //$NON-NLS-1$", "+\t}", "+\tif (isInlined()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"inlined\"); //$NON-NLS-1$", "+\t}", "+\tif (isInParamTag()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"in param tag\"); //$NON-NLS-1$", "+\t}", "+\tif (isOneLineTag()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"one line tag\"); //$NON-NLS-1$", "+\t}", "+\tif (isParamTag()) {", "+\t\tif (flagsBuffer.length() > 0) flagsBuffer.append(',');", "+\t\tflagsBuffer.append(\"param tag\"); //$NON-NLS-1$", "+\t}", "+\tif (flagsBuffer.length() > 0) {", "+\t\tif (inlined) buffer.append('\\t');", "+\t\tbuffer.append(\"\tflags: \"); //$NON-NLS-1$", "+\t\tbuffer.append(flagsBuffer);", "+\t\tbuffer.append('\\n');"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f7d08580c29cf8c9c0424a1a8877143f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "17d4fac2e2145f81ae8773e6bd604f552ec24c76", "commitAfterChange": "8f4037084194a0a8c6b51e4ac889744e5d6e68a8", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " public void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["+\tboolean requiresCatchesExit = false;", "+\t\tBranchLabel catchesExitLabel = null;", "+\t\tBranchLabel postCatchesFinallyLabel = null;\t\t", "+\t\tfor (int i = 0; i < maxCatches; i++) {", "+\t\t\texceptionLabels[i].placeEnd();", "+\t\t}", "-\t\t\t\t\t// fall through", "+\t\t\t\t\tif (this.postTryInitStateIndex != -1) {", "+\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t}", "+\t\t\t\t\tcodeStream.goto_(naturalExitLabel);", "+\t\t\t\t\tbreak;", "+\t\t\t\t\tif (this.postTryInitStateIndex != -1) {", "+\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t}", "-\t\tfor (int i = 0; i < maxCatches; i++) {", "-\t\t\texceptionLabels[i].placeEnd();", "-\t\t}", "+\t\t\tcatchesExitLabel = new BranchLabel(codeStream);", "+\t\t\tpostCatchesFinallyLabel = new BranchLabel(codeStream);", "+\t\t\t", "+\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "-\t\t\t\t\t\tcase FINALLY_SUBROUTINE :", "+\t\t\t\t\t\t\trequiresCatchesExit = true;", "+\t\t\t\t\t\t\tcodeStream.goto_(catchesExitLabel);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase FINALLY_SUBROUTINE :", "+\t\t\t\t\t\t\tif (this.postTryInitStateIndex != -1) {", "+\t\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\t\t}", "-//\t\t\t\tCaseLabel defaultReturnLocationLabel = null; // only used when emulating RET instruction", "-//\t\t\t\tCaseLabel naturalExitReturnLocationLabel = null; // only used when emulating RET instruction", "+\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "+\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\t\t\t\t}", "+\t\t\t", "-\t\t\tnaturalExitLabel.place();", "+\t\t\t\t\t\tnaturalExitLabel.place();", "-\t\t\t\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\t\t\t\t\t// needed since any exception handler got inlined subroutine", "-\t\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "-\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\t\t\t\t\t// inlined finally here can see all merged variables", "+\t\t\t\t\t\tif (this.postTryInitStateIndex != -1) {", "+\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.postTryInitStateIndex);", "+\t\t\t\t\t\tnaturalExitLabel.place();", "+\t\t\t\t\t\tif (postCatchesFinallyLabel != null && requiresCatchesExit) {", "+\t\t\t\t\t\t\tcodeStream.goto_(postCatchesFinallyLabel);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\tnaturalExitLabel.place();", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (requiresCatchesExit) {", "+\t\t\t\tswitch(finallyMode) {", "+\t\t\t\t\tcase FINALLY_INLINE :", "+\t\t\t\t\t\t// inlined finally here can see all merged variables", "+\t\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "+\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcatchesExitLabel.place();", "+\t\t\t\t\t\t// entire sequence for finally is associated to finally block", "+\t\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "+\t\t\t\t\t\tpostCatchesFinallyLabel.place();", "+\t\t\tif (catchesExitLabel != null) {", "+\t\t\t\tcatchesExitLabel.place();", "+\t\t\t}"]}], "num": 61299}