{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4d71ddc2417924937ce7a463aad9d4cb", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "45f163fe27629e51beb74d530514b5ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "7b9f5afc03b2a8eb9ffa3e6741b37f04d8f60a08", "commitAfterChange": "45eeabd31b9c2797f8358a82ef28ccf00894105c", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " protected boolean resolveLevelAsSuperInvocation(ReferenceBinding type)", "signatureAfterChange": " protected boolean resolveLevelAsSuperInvocation(ReferenceBinding type, TypeBinding[] argumentTypes, boolean verifyMethod)", "diff": ["-protected boolean resolveLevelAsSuperInvocation(ReferenceBinding type) {", "+protected boolean resolveLevelAsSuperInvocation(ReferenceBinding type, TypeBinding[] argumentTypes, boolean verifyMethod) {", "-\t\t\treturn true;", "+\t\t\tif (!verifyMethod) return true;", "+\t\t\t// need to verify if the type implements the pattern method", "+\t\t\tMethodBinding[] methods = type.getMethods(this.pattern.selector);", "+\t\t\tfor (int j=0, length=methods.length; j<length; j++) {", "+\t\t\t\tMethodBinding method = methods[j];", "+\t\t\t\tTypeBinding[] parameters = method.parameters;", "+\t\t\t\tif (argumentTypes.length == parameters.length) {", "+\t\t\t\t\tboolean found = true;", "+\t\t\t\t\tfor (int k=0,l=parameters.length; k<l; k++) {", "+\t\t\t\t\t\tif (parameters[k].erasure() != argumentTypes[k].erasure()) {", "+\t\t\t\t\t\t\tfound = false;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (found) {", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbreak;", "-\t\t\tif (resolveLevelAsSuperInvocation(interfaces[i])) {", "+\t\t\tif (resolveLevelAsSuperInvocation(interfaces[i], argumentTypes, true)) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f309940f0b01a8d4d58b5885ee3946d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "9d0a10f56589d65d04aaea495d852ef502b02233", "commitAfterChange": "913c08568caa0adfd1165460a3e2394884803092", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type)", "signatureAfterChange": " protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type, TypeBinding[] argumentTypes)", "diff": ["-protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type) {", "+protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type, TypeBinding[] argumentTypes) {", "-\tif (level != IMPOSSIBLE_MATCH) return level;", "+\tif (level != IMPOSSIBLE_MATCH) {", "+\t\tif (!type.isAbstract() && !type.isInterface()) { // if concrete class, then method is overridden", "+\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "+\t\t}", "+\t\treturn level;", "+\t}", "-\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, type.superclass());", "-\t\tif (level != IMPOSSIBLE_MATCH) return level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, type.superclass(), argumentTypes);", "+\t\tif (level != IMPOSSIBLE_MATCH) {", "+\t\t\tif (argumentTypes != null) {", "+\t\t\t\t// need to verify if method may be overridden", "+\t\t\t\tMethodBinding[] methods = type.getMethods(this.pattern.selector);", "+\t\t\t\tfor (int i=0, length=methods.length; i<length; i++) {", "+\t\t\t\t\tMethodBinding method = methods[i];", "+\t\t\t\t\tTypeBinding[] parameters = method.parameters;", "+\t\t\t\t\tif (argumentTypes.length == parameters.length) {", "+\t\t\t\t\t\tboolean found = true;", "+\t\t\t\t\t\tfor (int j=0,l=parameters.length; j<l; j++) {", "+\t\t\t\t\t\t\tif (parameters[j].erasure() != argumentTypes[j].erasure()) {", "+\t\t\t\t\t\t\t\tfound = false;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (found) { // one method match in hierarchy", "+\t\t\t\t\t\t\tif ((level & OVERRIDDEN_METHOD_FLAVOR) != 0) {", "+\t\t\t\t\t\t\t\t// this method is already overridden on a super class, current match is impossible", "+\t\t\t\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!method.isAbstract() && !type.isInterface()) {", "+\t\t\t\t\t\t\t\t// store the fact that the method is overridden", "+\t\t\t\t\t\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\t}", "-\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, interfaces[i]);", "-\t\tif (level != IMPOSSIBLE_MATCH) return level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, interfaces[i], null);", "+\t\tif (level != IMPOSSIBLE_MATCH) {", "+\t\t\tif (!type.isAbstract() && !type.isInterface()) { // if concrete class, then method is overridden", "+\t\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "+\t\t\t}", "+\t\t\treturn level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "de7aa2502fca958733903404395cd169", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "e96b81a52412e43aed69f6e87de2caadbf8506ca", "commitAfterChange": "5b1750b71e3273cfdbb40314841207d241dd1ece", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tif (anonymousType == null && enclosingInstance == null)", "+\t\t// added for code assist...cannot occur with 'normal' code", "+\t\tif (anonymousType == null && enclosingInstance == null) {", "-\t\t// added for code assist... is not possible with 'normal' code", "+\t\t}", "-", "-\t\tTypeBinding enclosingInstTb = null;", "-\t\tTypeBinding recType;", "-\t\tif (anonymousType == null) {", "-\t\t\t//----------------no anonymous class------------------------\t", "-\t\t\tif ((enclosingInstTb = enclosingInstance.resolveType(scope)) == null)", "-\t\t\t\treturn null;", "-\t\t\tif (enclosingInstTb.isBaseType() | enclosingInstTb.isArrayType()) {", "+\t\tTypeBinding enclosingInstanceType = null;", "+\t\tTypeBinding receiverType = null;", "+\t\tboolean hasError = false;", "+\t\tif (anonymousType == null) { //----------------no anonymous class------------------------\t", "+\t\t\tif ((enclosingInstanceType = enclosingInstance.resolveType(scope)) == null){", "+\t\t\t\thasError = true;", "+\t\t\t} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {", "-\t\t\t\t\tenclosingInstTb,", "+\t\t\t\t\tenclosingInstanceType,", "-\t\t\t\treturn null;", "+\t\t\t} else if ((receiverType = ((SingleTypeReference) type).resolveTypeEnclosing(", "+\t\t\t\t\t\t\tscope,", "+\t\t\t\t\t\t\t(ReferenceBinding) enclosingInstanceType)) == null) {", "+\t\t\t\thasError = true;", "-\t\t\trecType =", "-\t\t\t\t((SingleTypeReference) type).resolveTypeEnclosing(", "-\t\t\t\t\tscope,", "-\t\t\t\t\t(ReferenceBinding) enclosingInstTb);", "-\t\t\t\tboolean argHasError = false;", "-\t\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)", "-\t\t\t\t\t\targHasError = true;", "-\t\t\t\tif (argHasError)", "-\t\t\t\t\treturn recType;", "+\t\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null){", "+\t\t\t\t\t\thasError = true;", "+\t\t\t\t\t}", "-\t\t\tif (recType == null)", "-\t\t\t\treturn null;", "-\t\t\tif (!recType.canBeInstantiated()) {", "-\t\t\t\tscope.problemReporter().cannotInstantiate(type, recType);", "-\t\t\t\treturn recType;", "+\t\t\t// limit of fault-tolerance", "+\t\t\tif (hasError) {", "+\t\t\t\t\treturn receiverType;", "+\t\t\t}", "+\t\t\tif (!receiverType.canBeInstantiated()) {", "+\t\t\t\tscope.problemReporter().cannotInstantiate(type, receiverType);", "+\t\t\t\treturn receiverType;", "-\t\t\t\tscope.getConstructor((ReferenceBinding) recType, argumentTypes, this))", "+\t\t\t\tscope.getConstructor((ReferenceBinding) receiverType, argumentTypes, this))", "-\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) recType;", "+\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) receiverType;", "-\t\t\t\treturn recType;", "+\t\t\t\treturn receiverType;", "-\t\t\tif (Scope.areTypesCompatible(enclosingInstTb, expectedType))", "-\t\t\t\treturn recType;", "+\t\t\tif (Scope.areTypesCompatible(enclosingInstanceType, expectedType))", "+\t\t\t\treturn receiverType;", "-\t\t\t\tenclosingInstTb,", "+\t\t\t\tenclosingInstanceType,", "-\t\t\treturn recType;", "+\t\t\treturn receiverType;", "-\t\t\tif ((enclosingInstTb = enclosingInstance.resolveType(scope)) == null)", "-\t\t\t\treturn null;", "-\t\t\tif (enclosingInstTb.isBaseType() | enclosingInstTb.isArrayType()) {", "+\t\t\tif ((enclosingInstanceType = enclosingInstance.resolveType(scope)) == null) {", "+\t\t\t\thasError = true;", "+\t\t\t} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {", "-\t\t\t\t\tenclosingInstTb,", "+\t\t\t\t\tenclosingInstanceType,", "-\t\t\t\treturn null;", "+\t\t\t\thasError = true;", "+\t\t\t} else {", "+\t\t\t\treceiverType = ((SingleTypeReference) type).resolveTypeEnclosing(", "+\t\t\t\t\t\t\t\t\t\tscope,", "+\t\t\t\t\t\t\t\t\t\t(ReferenceBinding) enclosingInstanceType);\t\t\t\t", "+\t\t} else {", "+\t\t\treceiverType = type.resolveType(scope);", "-\t\t// due to syntax-construction, recType is a ReferenceBinding\t\t", "-\t\trecType =", "-\t\t\t(enclosingInstance == null)", "-\t\t\t\t? type.resolveType(scope)", "-\t\t\t\t: ((SingleTypeReference) type).resolveTypeEnclosing(", "-\t\t\t\t\tscope,", "-\t\t\t\t\t(ReferenceBinding) enclosingInstTb);", "-\t\tif (recType == null)", "-\t\t\treturn null;", "-\t\tif (((ReferenceBinding) recType).isFinal()) {", "-\t\t\tscope.problemReporter().anonymousClassCannotExtendFinalClass(type, recType);", "-\t\t\treturn null;", "+\t\tif (receiverType == null) {", "+\t\t\thasError = true;", "+\t\t} else if (((ReferenceBinding) receiverType).isFinal()) {", "+\t\t\tscope.problemReporter().anonymousClassCannotExtendFinalClass(type, receiverType);", "+\t\t\thasError = true;", "-\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)", "-\t\t\t\t\treturn null;", "+\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null) {", "+\t\t\t\t\thasError = true;", "+\t\t\t\t}", "+\t\t}", "+\t\t// limit of fault-tolerance", "+\t\tif (hasError) {", "+\t\t\t\treturn receiverType;", "-\t\t\trecType.isInterface() ? scope.getJavaLangObject() : (ReferenceBinding) recType;", "+\t\t\treceiverType.isInterface() ? scope.getJavaLangObject() : (ReferenceBinding) receiverType;", "-\t\t\t\t\tenclosingInstTb,", "+\t\t\t\t\tenclosingInstanceType,", "-\t\t\t\t\tenclosingInstTb,", "+\t\t\t\t\tenclosingInstanceType,", "-\t\tscope.addAnonymousType(anonymousType, (ReferenceBinding) recType);", "+\t\tscope.addAnonymousType(anonymousType, (ReferenceBinding) receiverType);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5d708809c8962e9ea026993ea7fd902", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "c9cd00a8dc1b877b2c5187fd0281ae7de37ff02a", "commitAfterChange": "4b3b23614cfca32dd53fa7e699914bb6d6883a79", "methodNumberBeforeChange": 49, "methodNumberAfterChange": 49, "signatureBeforeChange": " \tprivate void findLocalMethods( \t\tchar[] methodName, \t\tTypeBinding[] typeArgTypes, \t\tTypeBinding[] argTypes, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType, \t\tInvocationSite invocationSite, \t\tScope invocationScope, \t\tboolean implicitCall, \t\tboolean superCall, \t\tboolean canBePrefixed)", "signatureAfterChange": " \tprivate void findLocalMethods( \t\tchar[] methodName, \t\tTypeBinding[] typeArgTypes, \t\tTypeBinding[] argTypes, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType, \t\tInvocationSite invocationSite, \t\tScope invocationScope, \t\tboolean implicitCall, \t\tboolean superCall, \t\tboolean canBePrefixed)", "diff": ["-", "-\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)", "-\t\t\t\t\t&& lookupEnvironment.methodVerifier().doesMethodOverride(otherMethod, method)) {", "-", "-\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))", "-\t\t\t\t\t\tcontinue next;", "-", "-\t\t\t\t\tif (otherMethod.declaringClass.isInterface()) {", "-\t\t\t\t\t\tif(method.declaringClass == scope.getJavaLangObject())", "-\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tif (method.declaringClass.isInterface())", "-\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tif (!superCall && method", "-\t\t\t\t\t\t\t.declaringClass", "-\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))", "-\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t}", "-", "-\t\t\t\t\tif (method.declaringClass.isInterface())", "-\t\t\t\t\t\tif(otherMethod", "-\t\t\t\t\t\t\t.declaringClass", "-\t\t\t\t\t\t\t.implementsInterface(method.declaringClass,true))", "-\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t", "-\t\t\t\t\tif(receiverType.isAnonymousType()) continue next;", "-\t\t\t\t\t", "-\t\t\t\t\tif(!superCall) {", "-\t\t\t\t\t\tif(canBePrefixed) {", "-\t\t\t\t\t\t\tprefixRequired = true;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcontinue next;", "+\t\t\t\t", "+\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)) {", "+\t\t\t\t\tif (receiverType == otherReceiverType) {", "+\t\t\t\t\t\tif (lookupEnvironment.methodVerifier().doesMethodOverride(otherMethod, method)) {", "+\t\t\t\t\t\t\tif (!superCall || !otherMethod.declaringClass.isInterface()) {", "+\t\t\t\t\t\t\t\tcontinue next;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (lookupEnvironment.methodVerifier().doesMethodOverride(otherMethod, method)) {", "+\t\t\t\t\t\t\tif(receiverType.isAnonymousType()) continue next;", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tif(!superCall) {", "+\t\t\t\t\t\t\t\tif(!canBePrefixed) continue next;", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\tprefixRequired = true;", "+\t\t\t\t\t\t\t}", "+\t\t\t", "+\t\t\tReferenceBinding superTypeWithSameErasure = (ReferenceBinding)receiverType.findSuperTypeWithSameErasure(method.declaringClass);", "+\t\t\tif (method.declaringClass != superTypeWithSameErasure) {", "+\t\t\t\tMethodBinding[] otherMethods = superTypeWithSameErasure.getMethods(method.selector);", "+\t\t\t\tfor (int i = 0; i < otherMethods.length; i++) {", "+\t\t\t\t\tif(otherMethods[i].original() == method.original()) {", "+\t\t\t\t\t\tmethod = otherMethods[i];", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t"]}], "num": 26412}