{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "73f8f8fec032dd80a3f056e602819ed3", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "525c2a41be585ed54c168f34f1c3c3f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java", "commitBeforeChange": "dca0c800b618e06354348679c785dbf10c5f5a8f", "commitAfterChange": "cab98b2b8859caae533ee4cfbe628b2265262135", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic Object reduce(InferenceContext18 inferenceContext)", "signatureAfterChange": " \t \tpublic Object reduce(InferenceContext18 inferenceContext)", "diff": ["-\t\tif (this.left instanceof LambdaExpression || this.left instanceof ReferenceExpression) {", "-\t\t\tScope scope = inferenceContext.scope;", "-\t\t\tif (!this.right.isFunctionalInterface(scope))", "+\t\tScope scope = inferenceContext.scope;", "+\t\tif (!this.right.isFunctionalInterface(scope))", "+\t\t\treturn FALSE;", "+\t\tMethodBinding sam = this.right.getSingleAbstractMethod(scope, true);", "+\t\tif (sam == null)", "+\t\t\treturn FALSE;", "+\t\tif (this.left instanceof LambdaExpression) {", "+\t\t\tif (((LambdaExpression)this.left).argumentsTypeElided()) {", "+\t\t\t\tint nParam = sam.parameters.length;", "+\t\t\t\tfor (int i = 0; i < nParam; i++)", "+\t\t\t\t\tif (!sam.parameters[i].isProperType(true))", "+\t\t\t\t\t\treturn FALSE;", "+\t\t\t}", "+\t\t\tif (sam.returnType != TypeBinding.VOID && !sam.returnType.isProperType(true))", "-\t\t\tMethodBinding sam = this.right.getSingleAbstractMethod(scope, true);", "-\t\t\tif (sam == null)", "-\t\t\t\treturn FALSE;", "-\t\t\tif (this.left instanceof LambdaExpression) {", "-\t\t\t\tif (((LambdaExpression)this.left).argumentsTypeElided()) {", "-\t\t\t\t\tint nParam = sam.parameters.length;", "-\t\t\t\t\tfor (int i = 0; i < nParam; i++)", "-\t\t\t\t\t\tif (!sam.parameters[i].isProperType(true))", "-\t\t\t\t\t\t\treturn FALSE;", "-\t\t\t\t}", "+\t\t} else { // reference expression", "+\t\t\tif (!((ReferenceExpression)this.left).isExactMethodReference()) {\t\t\t\t\t", "+\t\t\t\tint nParam = sam.parameters.length;", "+\t\t\t\tfor (int i = 0; i < nParam; i++)", "+\t\t\t\t\tif (!sam.parameters[i].isProperType(true))", "+\t\t\t\t\t\treturn FALSE;", "-\t\t\t} else { // reference expression", "-\t\t\t\tif (!((ReferenceExpression)this.left).isExactMethodReference()) {\t\t\t\t\t", "-\t\t\t\t\tint nParam = sam.parameters.length;", "-\t\t\t\t\tfor (int i = 0; i < nParam; i++)", "-\t\t\t\t\t\tif (!sam.parameters[i].isProperType(true))", "-\t\t\t\t\t\t\treturn FALSE;", "-\t\t\t\t\tif (sam.returnType != TypeBinding.VOID && !sam.returnType.isProperType(true))", "-\t\t\t\t\t\treturn FALSE;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tTypeBinding[] thrown = sam.thrownExceptions;", "-\t\t\tTypeBinding[] e = new TypeBinding[thrown.length];", "-\t\t\tint n = 0;", "-\t\t\tfor (int i = 0; i < thrown.length; i++)", "-\t\t\t\tif (!thrown[i].isProperType(true))", "-\t\t\t\t\te[n++] = thrown[i];", "-\t\t\tTypeBinding[] ePrime = null;", "-\t\t\tif (this.left instanceof LambdaExpression) {", "-// TODO find exceptions thrown by the lambda's body", "-//\t\t\t\t((LambdaExpression)this.left).", "-//\t\t\t\tInferenceContext18.missingImplementation(\"NYI\");", "-\t\t\t} else {", "-\t\t\t\tReferenceExpression referenceExpression = (ReferenceExpression)this.left;", "-\t\t\t\tMethodBinding method = referenceExpression.findCompileTimeMethodTargeting(this.right, scope);", "-\t\t\t\tif (method != null)", "-\t\t\t\t\tePrime = method.thrownExceptions;", "-\t\t\t}", "-\t\t\tif (ePrime == null)", "-\t\t\t\treturn TRUE; // TODO is it a bug if we actually get here?", "-\t\t\tint m = ePrime.length;", "-\t\t\tif (n == 0) {", "-\t\t\t\tactual: for (int i = 0; i < m; i++) {", "-\t\t\t\t\tfor (int j = 0; j < thrown.length; j++)", "-\t\t\t\t\t\tif (ePrime[i].isCompatibleWith(thrown[j]))", "-\t\t\t\t\t\t\tcontinue actual;", "-\t\t\t\t\treturn FALSE;", "-\t\t\t\t}", "-\t\t\t\treturn TRUE;", "-\t\t\t} else {", "-\t\t\t\tList result = new ArrayList();", "-\t\t\t\tactual: for (int i = 0; i < m; i++) {", "-\t\t\t\t\tfor (int j = 0; j < thrown.length; j++)", "-\t\t\t\t\t\tif (ePrime[i].isCompatibleWith(thrown[j]))", "-\t\t\t\t\t\t\tcontinue actual;", "-\t\t\t\t\tfor (int j = 0; j < n; j++)", "-\t\t\t\t\t\tresult.add(new ConstraintTypeFormula(ePrime[i], e[j], SUBTYPE));", "-\t\t\t\t}\t\t\t\t", "-\t\t\t\tfor (int j = 0; j < n; j++)", "-\t\t\t\t\tresult.add(new ConstraintExceptionFormula(this.left, e[j]));", "-\t\t\t\treturn result.toArray(new ConstraintFormula[result.size()]);", "-\t\t\t}", "-\t\t} else if (this.left.isPolyExpression()) {", "-\t\t\t// parenthesized: transparent in our AST", "-", "-\t\t\tif (this.left instanceof ConditionalExpression) {", "-\t\t\t\tConditionalExpression conditional = (ConditionalExpression) this.left;", "-\t\t\t\treturn new ConstraintFormula[] {", "-\t\t\t\t\t\tnew ConstraintExceptionFormula(conditional.valueIfTrue, this.right),", "-\t\t\t\t\t\tnew ConstraintExceptionFormula(conditional.valueIfFalse, this.right)", "-\t\t\t\t};", "-\t\treturn TRUE;", "+\t\tTypeBinding[] thrown = sam.thrownExceptions;", "+\t\tTypeBinding[] e = new TypeBinding[thrown.length];", "+\t\tint n = 0;", "+\t\tfor (int i = 0; i < thrown.length; i++)", "+\t\t\tif (!thrown[i].isProperType(true))", "+\t\t\t\te[n++] = thrown[i];", "+\t\tTypeBinding[] ePrime = null;", "+\t\tif (this.left instanceof LambdaExpression) {", "+// TODO find exceptions thrown by the lambda's body, see 18.2.5 bullet 5", "+//\t\t\t\t((LambdaExpression)this.left).", "+//\t\t\t\tInferenceContext18.missingImplementation(\"NYI\");", "+\t\t} else {", "+\t\t\tReferenceExpression referenceExpression = (ReferenceExpression)this.left;", "+\t\t\tMethodBinding method = referenceExpression.findCompileTimeMethodTargeting(this.right, scope);", "+\t\t\tif (method != null)", "+\t\t\t\tePrime = method.thrownExceptions;", "+\t\t}", "+\t\tif (ePrime == null)", "+\t\t\treturn TRUE; // TODO is it a bug if we actually get here?", "+\t\tint m = ePrime.length;", "+\t\tif (n == 0) {", "+\t\t\tactual: for (int i = 0; i < m; i++) {", "+\t\t\t\tfor (int j = 0; j < thrown.length; j++)", "+\t\t\t\t\tif (ePrime[i].isCompatibleWith(thrown[j]))", "+\t\t\t\t\t\tcontinue actual;", "+\t\t\t\treturn FALSE;", "+\t\t\t}", "+\t\t\treturn TRUE;", "+\t\t} else {", "+\t\t\tList result = new ArrayList();", "+\t\t\tactual: for (int i = 0; i < m; i++) {", "+\t\t\t\tfor (int j = 0; j < thrown.length; j++)", "+\t\t\t\t\tif (thrown[j].isProperType(true) && ePrime[i].isCompatibleWith(thrown[j]))", "+\t\t\t\t\t\tcontinue actual;", "+\t\t\t\tfor (int j = 0; j < n; j++)", "+\t\t\t\t\tresult.add(new ConstraintTypeFormula(ePrime[i], e[j], SUBTYPE));", "+\t\t\t}\t\t\t\t", "+\t\t\tfor (int j = 0; j < n; j++)", "+\t\t\t\tresult.add(new ConstraintExceptionFormula(this.left, e[j]));", "+\t\t\treturn result.toArray(new ConstraintFormula[result.size()]);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "62c9c633dd8083a4faa80e65c5679bcb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "cbe2b622e81a27ceffd382724966e1dd065a9d5c", "commitAfterChange": "5f8bc31fdd9227264ffdb0d653c171e78b54416c", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "  \tpublic boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method)", "signatureAfterChange": "  \tpublic boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method)", "diff": ["-\t\tif (targetType instanceof TypeVariableBinding) {", "-\t\t\tif (method != null) { // when called from type inference", "-\t\t\t\tif (((TypeVariableBinding)targetType).declaringElement == method)", "-\t\t\t\t\treturn false;", "-\t\t\t\tif (method.isConstructor() && ((TypeVariableBinding)targetType).declaringElement == method.declaringClass)", "-\t\t\t\t\treturn false;", "-\t\t\t} else { // for internal calls", "-\t\t\t\tTypeVariableBinding typeVariable = (TypeVariableBinding) targetType;", "-\t\t\t\tif (typeVariable.declaringElement instanceof MethodBinding)", "-\t\t\t\t\treturn false;", "-\t\t\t}", "-\t\t}", "+\t\tif (!super.isPertinentToApplicability(targetType, method))", "+\t\t\treturn false;"]}], "num": 29816}