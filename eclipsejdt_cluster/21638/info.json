{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3ef18d2b62d36408ca4853c0b7ae1d8b", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e5f9872739f6ca7711ed0f3db6620ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java", "commitBeforeChange": "8f261bb6c49278e86707910a4be5450c713c940a", "commitAfterChange": "b5977e771dcaa856815c805c4cdc6cf2a2c18650", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowInfo)", "signatureAfterChange": " public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowInfo)", "diff": ["-\t\t\tExpression expression = this.nullReferences[i];", "+\t\t\tASTNode location = this.nullReferences[i];", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableNullComparedToNonNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableNullComparedToNonNull(local, location);", "+\t\t\t\t\tExpression expression = (Expression)location;", "-\t\t\t\t\t\tscope.problemReporter().variableNullReference(local, expression);", "+\t\t\t\t\t\tscope.problemReporter().variableNullReference(local, location);", "-\t\t\t\t\tthis.parent.recordNullityMismatch(scope, expression, flowInfo.nullStatus(local), this.expectedTypes[i]);", "+\t\t\t\t\tthis.parent.recordNullityMismatch(scope, (Expression)location, flowInfo.nullStatus(local), this.expectedTypes[i]);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase EXIT_RESOURCE:", "+\t\t\t\t\tif (local instanceof LocalVariableBinding) {", "+\t\t\t\t\t\tFakedTrackingVariable trackingVar = ((LocalVariableBinding) local).closeTracker;", "+\t\t\t\t\t\tif (trackingVar != null) {", "+\t\t\t\t\t\t\tif (trackingVar.hasDefinitelyNoResource(flowInfo)) {", "+\t\t\t\t\t\t\t\tcontinue; // no resource - no warning.", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (trackingVar.isClosedInFinallyOfEnclosing(scope)) {", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.parent.recordExitAgainstResource(scope, flowInfo, trackingVar, location)) {", "+\t\t\t\t\t\t\t\tthis.nullReferences[i] = null;", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\tthis.parent.recordUsingNullReference(scope, local, expression,", "+\t\t\tthis.parent.recordUsingNullReference(scope, local, location,", "-\t\t\tExpression expression = this.nullReferences[i];", "+\t\t\tASTNode location = this.nullReferences[i];", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableRedundantCheckOnNonNull(local, location);", "-\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, expression);", "+\t\t\t\t\t\t\t\tscope.problemReporter().variableNonNullComparedToNull(local, location);", "+\t\t\t\t\tExpression expression = (Expression) location;", "-\t\t\t\t\t\tscope.problemReporter().variableNullReference(local, expression);", "+\t\t\t\t\t\tscope.problemReporter().variableNullReference(local, location);", "-\t\t\t\t\t\tscope.problemReporter().variablePotentialNullReference(local, expression);", "+\t\t\t\t\t\tscope.problemReporter().variablePotentialNullReference(local, location);", "-\t\t\t\t\t\tscope.problemReporter().nullityMismatch(expression, this.expectedTypes[i], nullStatus, annotationName);", "+\t\t\t\t\t\tscope.problemReporter().nullityMismatch((Expression) location, this.expectedTypes[i], nullStatus, annotationName);", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase EXIT_RESOURCE:", "+\t\t\t\t\tnullStatus = flowInfo.nullStatus(local);", "+\t\t\t\t\tif (nullStatus != FlowInfo.NON_NULL && local instanceof LocalVariableBinding) {", "+\t\t\t\t\t\tFakedTrackingVariable closeTracker = ((LocalVariableBinding)local).closeTracker;", "+\t\t\t\t\t\tif (closeTracker != null) {", "+\t\t\t\t\t\t\tif (closeTracker.hasDefinitelyNoResource(flowInfo)) {", "+\t\t\t\t\t\t\t\tcontinue; // no resource - no warning.", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (closeTracker.isClosedInFinallyOfEnclosing(scope)) {", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tnullStatus = closeTracker.findMostSpecificStatus(flowInfo, scope, null);", "+\t\t\t\t\t\t\tcloseTracker.recordErrorLocation(this.nullReferences[i], nullStatus);", "+\t\t\t\t\t\t\tcloseTracker.reportRecordedErrors(scope, nullStatus);", "+\t\t\t\t\t\t\tthis.nullReferences[i] = null;", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bf11b25af413da7ba15afb1179c815f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java", "commitBeforeChange": "40ad9904e939ba54abece52421044021edd6e1c0", "commitAfterChange": "8d45cb26fc5ad244f93e8632d761d46ad4a120cf", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic static void handleResourceAssignment(FlowInfo flowInfo, Statement location, Expression rhs, LocalVariableBinding local, \t\t\t\tLocalVariableBinding previousTrackerBinding)", "signatureAfterChange": " \tpublic static void handleResourceAssignment(BlockScope scope, FlowInfo upstreamInfo, FlowInfo flowInfo, ASTNode location, Expression rhs, LocalVariableBinding local)", "diff": ["-\tpublic static void handleResourceAssignment(FlowInfo flowInfo, Statement location, Expression rhs, LocalVariableBinding local,", "-\t\t\t\tLocalVariableBinding previousTrackerBinding) ", "+\tpublic static void handleResourceAssignment(BlockScope scope, FlowInfo upstreamInfo, FlowInfo flowInfo, ASTNode location, Expression rhs, LocalVariableBinding local)", "-\t\tif (isAutoCloseable(rhs.resolvedType)) {", "+\t\t// does the LHS (local) already have a tracker, indicating we may leak a resource by the assignment?", "+\t\tFakedTrackingVariable previousTracker = null;", "+\t\tFakedTrackingVariable disconnectedTracker = null;", "+\t\tif (local.closeTracker != null) {", "+\t\t\t// assigning to a variable already holding an AutoCloseable, has it been closed before?", "+\t\t\tpreviousTracker = local.closeTracker;", "+\t\t\tint nullStatus = upstreamInfo.nullStatus(local);", "+\t\t\tif (nullStatus != FlowInfo.NULL && nullStatus != FlowInfo.UNKNOWN) // only if previous value may be relevant", "+\t\t\t\tdisconnectedTracker = previousTracker; // report error below, unless we have a self-wrap assignment", "+\t\t}", "+", "+\t\tif (rhs.resolvedType != TypeBinding.NULL) {", "-\t", "-\t\t\tif (rhsTrackVar != null) {\t\t\t\t\t\t\t\t// 1. share tracking variable with RHS?", "-\t\t\t\tlocal.closeTracker = rhsTrackVar;", "-\t\t\t\t// keep null-status unchanged across this assignment", "-\t\t\t} else if (previousTrackerBinding != null) {\t\t\t// 2. re-use tracking variable from the LHS?", "-\t\t\t\t// re-assigning from a fresh, mark as not-closed again:", "-\t\t\t\tflowInfo.markAsDefinitelyNull(previousTrackerBinding);", "+\t\t\tif (rhsTrackVar != null) {\t\t\t\t\t\t\t\t// 1. if RHS has a tracking variable...", "+\t\t\t\tif (local.closeTracker == null) {", "+\t\t\t\t\t// null shouldn't occur but let's play safe", "+\t\t\t\t\tif (rhsTrackVar.originalBinding != null)", "+\t\t\t\t\t\tlocal.closeTracker = rhsTrackVar;\t\t\t//\t\ta.: let fresh LHS share it ", "+\t\t\t\t} else {", "+\t\t\t\t\tif (rhsTrackVar == disconnectedTracker && rhs instanceof AllocationExpression)", "+\t\t\t\t\t\treturn; \t\t\t\t\t\t\t\t\t// \t\tb.: self wrapper: res = new Wrap(res); -> done!", "+\t\t\t\t\tlocal.closeTracker = rhsTrackVar;\t\t\t\t//\t\tc.: conflicting LHS and RHS, proceed with recordErrorLocation below", "+\t\t\t\t}", "+\t\t\t\t// keep close-status of RHS unchanged across this assignment", "+\t\t\t} else if (previousTracker != null) {\t\t\t\t\t// 2. re-use tracking variable from the LHS?", "+\t\t\t\t// re-assigning from a fresh value, mark as not-closed again:", "+\t\t\t\tif ((previousTracker.globalClosingState & (SHARED_WITH_OUTSIDE|OWNED_BY_OUTSIDE)) == 0)", "+\t\t\t\t\tflowInfo.markAsDefinitelyNull(previousTracker.binding);", "+\t\t\t\tlocal.closeTracker = analyseCloseableExpression(flowInfo, local, location, rhs, previousTracker);", "-\t\t\t\tlocal.closeTracker = new FakedTrackingVariable(local, location);", "-\t\t\t\t// a fresh resource, mark as not-closed:", "-\t\t\t\tflowInfo.markAsDefinitelyNull(local.closeTracker.binding);", "+\t\t\t\trhsTrackVar = analyseCloseableExpression(flowInfo, local, location, rhs, null);", "+\t\t\t\tif (rhsTrackVar != null) {", "+\t\t\t\t\tlocal.closeTracker = rhsTrackVar;", "+\t\t\t\t\t// a fresh resource, mark as not-closed:", "+\t\t\t\t\tif ((rhsTrackVar.globalClosingState & (SHARED_WITH_OUTSIDE|OWNED_BY_OUTSIDE)) == 0)", "+\t\t\t\t\t\tflowInfo.markAsDefinitelyNull(rhsTrackVar.binding);", "-//\t\t\t\tif (flowContext.initsOnFinally != null)", "-//\t\t\t\t\tflowContext.initsOnFinally.markAsDefinitelyNonNull(trackerBinding);", "+//\t\t\t\t\tif (flowContext.initsOnFinally != null)", "+//\t\t\t\t\t\tflowContext.initsOnFinally.markAsDefinitelyNonNull(trackerBinding);", "+\t\t\t\t}", "+\t\t}", "+", "+\t\tif (disconnectedTracker != null) {", "+\t\t\tif (disconnectedTracker.innerTracker != null && disconnectedTracker.innerTracker.binding.declaringScope == scope) {", "+\t\t\t\t// discard tracker for the wrapper but keep the inner:", "+\t\t\t\tdisconnectedTracker.innerTracker.outerTracker = null;", "+\t\t\t\tscope.pruneWrapperTrackingVar(disconnectedTracker);", "+\t\t\t} else {", "+\t\t\t\tint upstreamStatus = upstreamInfo.nullStatus(disconnectedTracker.binding);", "+\t\t\t\tif (upstreamStatus != FlowInfo.NON_NULL)", "+\t\t\t\t\tdisconnectedTracker.recordErrorLocation(location, upstreamStatus);", "+\t\t\t}", "+\t\t}", "+\t}"]}], "num": 21638}