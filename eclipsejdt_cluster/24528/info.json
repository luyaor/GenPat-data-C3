{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9e95c2ea08ad2d6d8f2db3a262891236", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "18d2e28ed7bf49ffe5bc1e8df3365c1f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "82dc67de142f757f6098e678017a2b32f752c9b7", "commitAfterChange": "5249d37677c0ce4d66ab262efb5c3dd4aa089796", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tvoid buildMethods()", "signatureAfterChange": "  \tvoid buildMethods()", "diff": ["-\t\tfor (int i = 0; i < size; i++) {", "-\t\t\tif (i != clinitIndex) {", "-\t\t\t\tMethodScope scope = new MethodScope(this, methods[i], false);", "-\t\t\t\tMethodBinding methodBinding = scope.createMethod(methods[i]);", "-\t\t\t\tif (methodBinding != null) // is null if binding could not be created", "-\t\t\t\t\tmethodBindings[count++] = methodBinding;", "+\t\tif (sourceType.isAbstract()) {", "+\t\t\tfor (int i = 0; i < size; i++) {", "+\t\t\t\tif (i != clinitIndex) {", "+\t\t\t\t\tMethodScope scope = new MethodScope(this, methods[i], false);", "+\t\t\t\t\tMethodBinding methodBinding = scope.createMethod(methods[i]);", "+\t\t\t\t\tif (methodBinding != null) // is null if binding could not be created", "+\t\t\t\t\t\tmethodBindings[count++] = methodBinding;", "+\t\t\t\t}", "+\t\t} else {", "+\t\t\tMethodBinding[] abstractMethods = null;", "+\t\t\tfor (int i = 0; i < size; i++) {", "+\t\t\t\tif (i != clinitIndex) {", "+\t\t\t\t\tMethodScope scope = new MethodScope(this, methods[i], false);", "+\t\t\t\t\tMethodBinding methodBinding = scope.createMethod(methods[i]);", "+\t\t\t\t\tif (methodBinding != null) { // is null if binding could not be created", "+\t\t\t\t\t\tmethodBindings[count++] = methodBinding;", "+\t\t\t\t\t\tif (methodBinding.isAbstract()) {", "+\t\t\t\t\t\t\tif (abstractMethods == null) {", "+\t\t\t\t\t\t\t\tabstractMethods = new MethodBinding[] {methodBinding};", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tint length = abstractMethods.length;", "+\t\t\t\t\t\t\t\tSystem.arraycopy(abstractMethods, 0, abstractMethods = new MethodBinding[length + 1], 0, length);", "+\t\t\t\t\t\t\t\tabstractMethods[length] = methodBinding;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (abstractMethods != null)", "+\t\t\t\tproblemReporter().abstractMethodInAbstractClass(sourceType, abstractMethods);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4ba91014b819002fafeab1e117f205f2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "7c0534e311ca23dad63801edecab8ecfaf54c055", "commitAfterChange": "f0126485e71d6e9762ea26c839590b2bf7e1a885", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "signatureAfterChange": "\r private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "diff": ["+\tIType focusType = this.getType();\r", "+\t\t\r", "+\tint length = allPotentialSubTypes.length;\r", "+\r", "+\t// inject the compilation unit of the focus type (so that types in\r", "+\t// this cu have special visibility permission (this is also usefull\r", "+\t// when the cu is a working copy)\r", "+\tOpenable focusCU = (Openable)focusType.getCompilationUnit();\r", "+\tString focusPath = null;\r", "+\tif (focusCU != null) {\r", "+\t\ttry {\r", "+\t\t\tIResource underlyingResource;\r", "+\t\t\tif (focusCU instanceof WorkingCopy) {\r", "+\t\t\t\tunderlyingResource = ((WorkingCopy)focusCU).getOriginalElement().getUnderlyingResource();\r", "+\t\t\t} else {\r", "+\t\t\t\tunderlyingResource = focusCU.getUnderlyingResource();\r", "+\t\t\t}\r", "+\t\t\tfocusPath = underlyingResource.getFullPath().toString();\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t\t// type does not exist\r", "+\t\t\treturn;\r", "+\t\t}\r", "+\t\tif (length > 0) {\r", "+\t\t\tSystem.arraycopy(allPotentialSubTypes, 0, allPotentialSubTypes = new String[length+1], 0, length);\r", "+\t\t\tallPotentialSubTypes[length] = focusPath;\t\r", "+\t\t} else {\r", "+\t\t\tallPotentialSubTypes = new String[] {focusPath};\r", "+\t\t}\r", "+\t\tlength++;\r", "+\t}\r", "+\t\r", "-\tIType focusType = this.getType();\r", "-\r", "-\tfor (int i = 0, length = allPotentialSubTypes.length; i < length; i++) {\r", "+\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tOpenable handle = factory.createOpenable(resourcePath);\r", "-\t\t\tif (handle == null) continue; // match is outside classpath\r", "-\t\t\t// working copies take precedence over compilation units\r", "-\t\t\tObject workingCopy = this.handleToWorkingCopy.get(handle);\r", "-\t\t\tif (workingCopy != null) {\r", "-\t\t\t\thandle = (Openable)workingCopy;\r", "-\t\t\t}\r", "+\t\t\t// skip duplicate paths (e.g. if focus path was injected when it was already a potential subtype)\r", "+\t\t\tif (i > 0 && resourcePath.equals(allPotentialSubTypes[i-1])) continue;\r", "+\t\t\t\r", "+\t\t\tOpenable handle = \r", "+\t\t\t\tresourcePath.equals(focusPath) ? \r", "+\t\t\t\t\tfocusCU :\r", "+\t\t\t\t\tfactory.createOpenable(resourcePath);\r", "+\t\t\tif (handle == null) continue; // match is outside classpath\r", "+\t\t\t\t// build current project\r", "+\t\r", "+\t// build last project\r"]}], "num": 24528}