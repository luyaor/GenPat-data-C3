{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "99e80d324888ed4bfb7d53eb2f47963b", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1175b037659027bbcd1b1ab06f22bb4a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "b2caa750738c585e3970cd6cbdee229067bea596", "commitAfterChange": "8d1eb8a1ba1f8d42e85f057c2e74fe0db8cb690d", "methodNumberBeforeChange": 93, "methodNumberAfterChange": 93, "signatureBeforeChange": " \tpublic boolean visit(NullLiteral nullLiteral, BlockScope scope)", "signatureAfterChange": " \tpublic boolean visit(StringLiteralConcetanation stringLiteral, BlockScope scope)", "diff": ["+\t */", "+\tpublic boolean visit(StringLiteralConcetanation stringLiteral, BlockScope scope) {", "+\t\tfinal int numberOfParens = (stringLiteral.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;", "+\t\tif (numberOfParens > 0) {", "+\t\t\tmanageOpeningParenthesizedExpression(stringLiteral, numberOfParens);", "+\t\t}", "+", "+\t\tthis.scribe.printComment();", "+\t\tASTNode[] fragments = stringLiteral.literals;", "+\t\tint fragmentsSize = stringLiteral.counter;", "+\t\tAlignment binaryExpressionAlignment = this.scribe.createAlignment(\"binaryExpressionAlignment\", this.preferences.alignment_for_binary_expression, Alignment.R_OUTERMOST, fragmentsSize, this.scribe.scanner.currentPosition); //$NON-NLS-1$", "+\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "+\t\tboolean ok = false;", "+\t\tdo {", "+\t\t\ttry {", "+\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\tASTNode fragment = fragments[i];", "+\t\t\t\t\tfragment.traverse(this, scope);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t// a new line has been inserted by printTrailingComment()", "+\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNamePLUS, this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tfragments[fragmentsSize - 1].traverse(this, scope);", "+\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\tok = true;", "+\t\t\t} catch(AlignmentException e){", "+\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t}", "+\t\t} while (!ok);\t\t", "+\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);", "+\t\tif (numberOfParens > 0) {", "+\t\t\tmanageClosingParenthesizedExpression(stringLiteral, numberOfParens);", "+\t\t}", "+\t\treturn false;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7db0f0b7bfae0567cf76d1811cda76fa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor2.java", "commitBeforeChange": "74d059b3fbdc00070c70bee76509a44ccad7fb4d", "commitAfterChange": "31d2b0bac7c9b032f1ad8765fd4577eaff8d79fd", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 53, "signatureBeforeChange": "  \tpublic boolean visit(InfixExpression node)", "signatureAfterChange": "  \tpublic boolean visit(InfixExpression node)", "diff": ["-\t\t// TODO Auto-generated method stub", "-\t\treturn super.visit(node);", "+\t\t// active line wrapping", "+\t\tfinal InfixExpressionWrappingBuilder builder = new InfixExpressionWrappingBuilder();", "+\t\tnode.accept(builder);", "+\t\tfinal int fragmentsSize = builder.getFragmentsCounter();", "+\t\tthis.scribe.printComment();", "+\t\tAlignment2 binaryExpressionAlignment = this.scribe.createAlignment(\"binaryExpressionAlignment\", this.preferences.alignment_for_binary_expression, Alignment.R_OUTERMOST, fragmentsSize, this.scribe.scanner.currentPosition); //$NON-NLS-1$", "+\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "+\t\tboolean ok = false;", "+\t\tList fragments = builder.fragments;", "+\t\tint[] operators = builder.getOperators();", "+/*\t\tdo {", "+\t\t\ttry {", "+\t\t\t\tfinal boolean alignAfterOperator = false;", "+\t\t\t\tif (alignAfterOperator) {", "+\t\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\t((Expression) fragments.get(i)).accept(this);", "+\t\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t\t// a new line has been inserted by printTrailingComment()", "+\t\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, fragmentsSize - 1);", "+\t\t\t\t\t((Expression) fragments.get(fragmentsSize - 1)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, 0);", "+\t\t\t\t\t((Expression) fragments.get(0)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tfor (int i = 1; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\tthis.scribe.printNextToken(operators[i - 1], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t((Expression) fragments.get(i)).accept(this);", "+\t\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, fragmentsSize - 1);", "+\t\t\t\t\tthis.scribe.printNextToken(operators[fragmentsSize - 2], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\tif (operators[fragmentsSize - 2] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t\t((Expression) fragments.get(fragmentsSize - 1)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tok = true;", "+\t\t\t} catch(AlignmentException e){", "+\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t}", "+\t\t} while (!ok);", "+\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);*/", "+\t\tdo {", "+\t\t\ttry {", "+\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\t((Expression) fragments.get(i)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\tif ( this.preferences.insert_space_after_binary_operator", "+\t\t\t\t\t\t\t|| (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS))) {", "+\t\t\t\t\t\t// the next character is a minus (unary operator) or the preference is set to true", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t((Expression) fragments.get(fragmentsSize - 1)).accept(this);", "+\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tok = true;", "+\t\t\t} catch(AlignmentException e){", "+\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t}", "+\t\t} while (!ok);\t\t", "+\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);\t\t", "+/*\t\t\tleftOperand.accept(this);", "+\t\t\tfinal int operator = extractInfixExpressionOperator(node);", "+\t\t\tthis.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);", "+\t\t\tif ( this.preferences.insert_space_after_binary_operator", "+\t\t\t\t\t|| (operator == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS))) {", "+\t\t\t\t// the next character is a minus (unary operator) or the preference is set to true", "+\t\t\t\tthis.scribe.space();", "+\t\t\t}", "+\t\t\trightOperand.accept(this);*/", "+\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f1d08d258435c9996568de8c287e7eda", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "080a42c1d10403c7486b8cde9973df6dc09a8d9d", "commitAfterChange": "be2396778954f7686c95a2d45b5130702d13bfe1", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": "  \tprivate void format(TypeDeclaration typeDeclaration)", "signatureAfterChange": "  \tprivate void format(TypeDeclaration typeDeclaration)", "diff": ["-\t\t\t\tloop: for (int i = 0; i < length; i++) {", "+\t\t\t\tint enumConstantsLength = 0;", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\t\tif (fieldDeclaration.getKind() != AbstractVariableDeclaration.ENUM_CONSTANT) {", "-\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\tif (fieldDeclaration.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT) {", "+\t\t\t\t\t\tenumConstantsLength++;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\tif (i < length) {", "-\t\t\t\t\t\thasConstants = true;", "-\t\t\t\t\t\tfieldDeclaration.traverse(this, typeDeclaration.initializerScope);", "-\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\thasConstants = enumConstantsLength != 0;", "+\t\t\t\tif (enumConstantsLength > 1) {", "+\t\t\t\t\tAlignment enumConstantsAlignment = this.scribe.createAlignment(", "+\t\t\t\t\t\t\t\"enumConstants\",//$NON-NLS-1$", "+\t\t\t\t\t\t\tthis.preferences.alignment_for_enum_constants,", "+\t\t\t\t\t\t\tenumConstantsLength,", "+\t\t\t\t\t\t\tthis.scribe.scanner.currentPosition,", "+\t\t\t\t\t\t\t0, // we don't want to indent enum constants when splitting to a new line", "+\t\t\t\t\t\t\tfalse);", "+\t\t\t\t\tthis.scribe.enterAlignment(enumConstantsAlignment);", "+\t\t\t\t\tboolean ok = false;", "+\t\t\t\t\tdo {", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tfor (int i = 0; i < enumConstantsLength; i++) {", "+\t\t\t\t\t\t\t\tthis.scribe.alignFragment(enumConstantsAlignment, i);", "+\t\t\t\t\t\t\t\tFieldDeclaration fieldDeclaration = fieldDeclarations[i];", "+\t\t\t\t\t\t\t\tfieldDeclaration.traverse(this, typeDeclaration.initializerScope);", "+\t\t\t\t\t\t\t\tif (isNextToken(TerminalTokens.TokenNameCOMMA)) {", "+\t\t\t\t\t\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_enum_declarations);", "+\t\t\t\t\t\t\t\t\tif (this.preferences.insert_space_after_comma_in_enum_declarations) {", "+\t\t\t\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\t\t\t\t\tif (fieldDeclaration.initialization instanceof QualifiedAllocationExpression) {", "+\t\t\t\t\t\t\t\t\t\tthis.scribe.printNewLine();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tok = true;", "+\t\t\t\t\t\t} catch (AlignmentException e) {", "+\t\t\t\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} while (!ok);", "+\t\t\t\t\tthis.scribe.exitAlignment(enumConstantsAlignment, true);", "+\t\t\t\t} else {", "+\t\t\t\t\tFieldDeclaration fieldDeclaration = fieldDeclarations[0];", "+\t\t\t\t\tfieldDeclaration.traverse(this, typeDeclaration.initializerScope);", "-\t\t\t\t}\t\t\t", "+\t\t\t\t}"]}], "num": 70387}