{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "083a9774ff1785f09dfbe2f7e5bf08cc", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9a9eb72500919ba946eb0c17040e0462", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/pattern/InternalSearchPattern.java", "commitBeforeChange": "9ccc53063dda8b7e1afdde95ae36a8417c582abc", "commitAfterChange": "7143e72571bb2e6a2e74f6791210a97b375b5ab6", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic void findMatches(SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " public void findMatches(SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException", "diff": ["+ */", "+public void findMatches(SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException {", "+\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "-\t */", "-\tpublic void findMatches(SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException {", "-\t\t", "-\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "-\t\t", "-\t\t/* initialize progress monitor */", "-\t\tif (monitor != null) {", "-\t\t\tmonitor.beginTask(Util.bind(\"engine.searching\"), 100); //$NON-NLS-1$", "-\t\t}", "+\t/* initialize progress monitor */", "+\tif (monitor != null)", "+\t\tmonitor.beginTask(Util.bind(\"engine.searching\"), 100); //$NON-NLS-1$", "+\tif (SearchEngine.VERBOSE)", "+\t\tSystem.out.println(\"Searching for \" + this + \" in \" + scope); //$NON-NLS-1$//$NON-NLS-2$", "-\t\tif (SearchEngine.VERBOSE) {", "-\t\t\tSystem.out.println(\"Searching for \" + this + \" in \" + scope); //$NON-NLS-1$//$NON-NLS-2$", "-\t\t}", "-\t", "-\t\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();", "-\t\ttry {", "-\t\t\trequestor.beginReporting();", "-\t\t\t", "-\t\t\tfor (int iParticipant = 0, length = participants == null ? 0 : participants.length; iParticipant < length; iParticipant++) {", "-\t\t\t\t", "+\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();", "+\ttry {", "+\t\trequestor.beginReporting();", "+\t\tfor (int i = 0, l = participants == null ? 0 : participants.length; i < l; i++) {", "+\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "+", "+\t\t\tSearchParticipant participant = participants[i];", "+\t\t\ttry {", "+\t\t\t\tparticipant.beginSearching();", "+\t\t\t\trequestor.enterParticipant(participant);", "+\t\t\t\tPathCollector pathCollector = new PathCollector();", "+\t\t\t\tindexManager.performConcurrentJob(", "+\t\t\t\t\tnew PatternSearchJob((SearchPattern) this, participant, scope, pathCollector),", "+\t\t\t\t\tIJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,", "+\t\t\t\t\tmonitor);", "-\t", "-\t\t\t\tSearchParticipant participant = participants[iParticipant];", "-\t\t\t\ttry {", "-\t\t\t\t\tparticipant.beginSearching();", "-\t\t\t\t\trequestor.enterParticipant(participant);", "-\t\t", "-\t\t\t\t\t// find index matches\t\t\t", "-\t\t\t\t\tPathCollector pathCollector = new PathCollector();", "-\t\t\t\t\tindexManager.performConcurrentJob(", "-\t\t\t\t\t\tnew PatternSearchJob(", "-\t\t\t\t\t\t\t(SearchPattern)this, ", "-\t\t\t\t\t\t\tparticipant,", "-\t\t\t\t\t\t\tscope, ", "-\t\t\t\t\t\t\tpathCollector),", "-\t\t\t\t\t\tIJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,", "-\t\t\t\t\t\tmonitor);", "-\t\t\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "-\t\t", "-\t\t\t\t\t// locate index matches if any (note that all search matches could have been issued during index querying)", "-\t\t\t\t\tString[] indexMatchPaths = pathCollector.getPaths();", "-\t\t\t\t\tpathCollector = null; // release", "-\t\t\t\t\tint indexMatchLength = indexMatchPaths == null ? 0 : indexMatchPaths.length;", "-\t\t\t\t\tSearchDocument[] indexMatches = new SearchDocument[indexMatchLength];", "-\t\t\t\t\tfor (int iMatch = 0;iMatch < indexMatchLength; iMatch++) {", "-\t\t\t\t\t\tString documentPath = indexMatchPaths[iMatch];", "-\t\t\t\t\t\tindexMatches[iMatch] = participant.getDocument(documentPath);", "-\t\t\t\t\t}", "-\t\t\t\t\tparticipant.locateMatches(indexMatches, (SearchPattern)this, scope, requestor, monitor);", "-\t\t\t\t} finally {\t\t", "-\t\t\t\t\trequestor.exitParticipant(participant);", "-\t\t\t\t\tparticipant.doneSearching();", "-\t\t\t\t}", "-\t\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "+\t\t\t\t// locate index matches if any (note that all search matches could have been issued during index querying)", "+\t\t\t\tString[] indexMatchPaths = pathCollector.getPaths();", "+\t\t\t\tpathCollector = null; // release", "+\t\t\t\tint indexMatchLength = indexMatchPaths == null ? 0 : indexMatchPaths.length;", "+\t\t\t\tSearchDocument[] indexMatches = new SearchDocument[indexMatchLength];", "+\t\t\t\tfor (int j = 0; j < indexMatchLength; j++)", "+\t\t\t\t\tindexMatches[j] = participant.getDocument(indexMatchPaths[j]);", "+\t\t\t\tparticipant.locateMatches(indexMatches, (SearchPattern) this, scope, requestor, monitor);", "+\t\t\t} finally {\t\t", "+\t\t\t\trequestor.exitParticipant(participant);", "+\t\t\t\tparticipant.doneSearching();", "-\t\t} finally {", "-\t\t\trequestor.endReporting();", "-\t\t\tif (monitor != null) monitor.done();", "-\t}\t\t\t", "+\t} finally {", "+\t\trequestor.endReporting();", "+\t\tif (monitor != null)", "+\t\t\tmonitor.done();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a5a142a3acd1b43ad8a3ba08e28260ff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/pattern/InternalSearchPattern.java", "commitBeforeChange": "a9c68df97efd734f3ed326f5e99e4d21e6054bec", "commitAfterChange": "af2f21c145913c8a7ccf22989ee905c5f5c7dd0d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 6, "signatureBeforeChange": " public void findMatches(SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic void findMatches(SearchParticipant[] participants, ICompilationUnit[] workingCopies, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException", "diff": ["- */", "-public void findMatches(SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException {", "-\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "-", "-\t/* initialize progress monitor */", "-\tif (monitor != null)", "-\t\tmonitor.beginTask(Util.bind(\"engine.searching\"), 100); //$NON-NLS-1$", "-\tif (SearchEngine.VERBOSE)", "-\t\tSystem.out.println(\"Searching for \" + this + \" in \" + scope); //$NON-NLS-1$//$NON-NLS-2$", "-", "-\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();", "-\ttry {", "-\t\trequestor.beginReporting();", "-\t\tfor (int i = 0, l = participants == null ? 0 : participants.length; i < l; i++) {", "-\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "-", "-\t\t\tSearchParticipant participant = participants[i];", "-\t\t\ttry {", "-\t\t\t\tparticipant.beginSearching();", "-\t\t\t\trequestor.enterParticipant(participant);", "-\t\t\t\tPathCollector pathCollector = new PathCollector();", "-\t\t\t\tindexManager.performConcurrentJob(", "-\t\t\t\t\tnew PatternSearchJob((SearchPattern) this, participant, scope, pathCollector),", "-\t\t\t\t\tIJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,", "-\t\t\t\t\tmonitor);", "-", "-\t\t\t\t// locate index matches if any (note that all search matches could have been issued during index querying)", "-\t\t\t\tString[] indexMatchPaths = pathCollector.getPaths();", "-\t\t\t\tpathCollector = null; // release", "-\t\t\t\tint indexMatchLength = indexMatchPaths == null ? 0 : indexMatchPaths.length;", "-\t\t\t\tSearchDocument[] indexMatches = new SearchDocument[indexMatchLength];", "-\t\t\t\tfor (int j = 0; j < indexMatchLength; j++)", "-\t\t\t\t\tindexMatches[j] = participant.getDocument(indexMatchPaths[j]);", "-\t\t\t\tparticipant.locateMatches(indexMatches, (SearchPattern) this, scope, requestor, monitor);", "-\t\t\t} finally {\t\t", "-\t\t\t\trequestor.exitParticipant(participant);", "-\t\t\t\tparticipant.doneSearching();", "+\t */", "+\tpublic void findMatches(SearchParticipant[] participants, ICompilationUnit[] workingCopies, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException {", "+\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "+\t", "+\t\t/* initialize progress monitor */", "+\t\tif (monitor != null)", "+\t\t\tmonitor.beginTask(Util.bind(\"engine.searching\"), 100); //$NON-NLS-1$", "+\t\tif (SearchEngine.VERBOSE)", "+\t\t\tSystem.out.println(\"Searching for \" + this + \" in \" + scope); //$NON-NLS-1$//$NON-NLS-2$", "+\t", "+\t\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();", "+\t\ttry {", "+\t\t\trequestor.beginReporting();", "+\t\t\tfor (int i = 0, l = participants == null ? 0 : participants.length; i < l; i++) {", "+\t\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "+\t", "+\t\t\t\tSearchParticipant participant = participants[i];", "+\t\t\t\ttry {", "+\t\t\t\t\tparticipant.beginSearching();", "+\t\t\t\t\trequestor.enterParticipant(participant);", "+\t\t\t\t\tPathCollector pathCollector = new PathCollector();", "+\t\t\t\t\tindexManager.performConcurrentJob(", "+\t\t\t\t\t\tnew PatternSearchJob((SearchPattern) this, participant, scope, pathCollector),", "+\t\t\t\t\t\tIJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,", "+\t\t\t\t\t\tmonitor);", "+\t\t\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "+\t", "+\t\t\t\t\t// locate index matches if any (note that all search matches could have been issued during index querying)", "+\t\t\t\t\tString[] indexMatchPaths = pathCollector.getPaths();", "+\t\t\t\t\tpathCollector = null; // release", "+\t\t\t\t\tint indexMatchLength = indexMatchPaths == null ? 0 : indexMatchPaths.length;", "+\t\t\t\t\tSearchDocument[] indexMatches = new SearchDocument[indexMatchLength];", "+\t\t\t\t\tfor (int j = 0; j < indexMatchLength; j++)", "+\t\t\t\t\t\tindexMatches[j] = participant.getDocument(indexMatchPaths[j]);", "+\t\t\t\t\tSearchDocument[] matches = addWorkingCopies(indexMatches, workingCopies, participant);", "+\t\t\t\t\tparticipant.locateMatches(matches, (SearchPattern) this, scope, requestor, monitor);", "+\t\t\t\t} finally {\t\t", "+\t\t\t\t\trequestor.exitParticipant(participant);", "+\t\t\t\t\tparticipant.doneSearching();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} finally {", "+\t\t\trequestor.endReporting();", "+\t\t\tif (monitor != null)", "+\t\t\t\tmonitor.done();", "+\t\t}", "+\t}", "-\t} finally {", "-\t\trequestor.endReporting();", "-\t\tif (monitor != null)", "-\t\t\tmonitor.done();", "-}"]}], "num": 32924}