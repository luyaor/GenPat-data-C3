{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "97e4577015a5058126249dd9b63f8f0c", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "04134a1aae16cd5580b105dc1faf6c07", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java", "commitBeforeChange": "a094ff45a998c96b23832e90fdde401121899a47", "commitAfterChange": "7b6db9de192fc1976c0d12542fea77102668b433", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " public boolean needsUncheckedConversion(TypeBinding targetType)", "signatureAfterChange": " public boolean needsUncheckedConversion(TypeBinding targetType)", "diff": ["+", "+\tif (this == targetType) return false;", "+\ttargetType = targetType.leafComponentType();", "+\tif (!(targetType instanceof ReferenceBinding)) ", "+\t\treturn false;", "+", "+\tTypeBinding currentType = this.leafComponentType();", "+\tif (!(currentType instanceof ReferenceBinding))", "+\t\treturn false;", "+\t", "+\tReferenceBinding compatible = ((ReferenceBinding)currentType).findSuperTypeErasingTo((ReferenceBinding)targetType.erasure());", "+\tif (compatible == null) ", "+\t\treturn false;", "+\tif (!compatible.isPartOfRawType()) return false;", "+\tdo {", "+\t\tif (compatible.isRawType() && (targetType.isBoundParameterizedType() || targetType.isGenericType())) {", "+\t\t\treturn true;", "+\t\t}", "+\t} while ((compatible = compatible.enclosingType()) != null && (targetType = targetType.enclosingType()) != null);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ce0bbde6f6e19c63bc667df9c826b89d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "2b2b7318d43bbf7988138cdc5eb74c55ddf21827", "commitAfterChange": "6478e2ede221e392aeae64992fd8ab69061b142a", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tpublic MethodBinding findExactMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findExactMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\t\t\tfor (int i = argumentTypes.length; --i >= 0;)", "-\t\t\t\t\tif (isSubtypeOfRawType(argumentTypes[i]))", "+\t\t\t\tfor (int i = argumentTypes.length; --i >= 0;) {", "+\t\t\t\t\t// workaround for bug 464229: The type * cannot be resolved. It is indirectly referenced from required .class files", "+\t\t\t\t\tTypeBinding t = argumentTypes[i].leafComponentType();", "+\t\t\t\t\tif (! (t instanceof ReferenceBinding))", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tReferenceBinding r = (ReferenceBinding)t;", "+\t\t\t\t\tif (r.isHierarchyConnected()) {", "+\t\t\t\t\t\tif (isSubtypeOfRawType(r))", "+\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t} else if (r.isRawType()) {", "+\t\t\t\t\t}", "+\t\t\t\t\t//TODO: should also check if any supertype of r is raw, but can't do this without resolving the whole hierarchy", "+\t\t\t\t}"]}], "num": 15081}