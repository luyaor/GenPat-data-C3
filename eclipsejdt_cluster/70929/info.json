{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "00ea7566973d31497c66c1e76bc546d3", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4145bdf1dbd9e6b3b5584e6c02d0460b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "5e23ed7edfe961d34bd26ee29fb9ade957409733", "commitAfterChange": "28dd1050b46fae522d51f1c10cb06a79601770f3", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 48, "signatureBeforeChange": " \tprivate void findLocalMethods( \t\tchar[] methodName, \t\tTypeBinding[] argTypes, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType, \t\tInvocationSite invocationSite, \t\tScope invocationScope, \t\tboolean implicitCall, \t\tboolean superCall, \t\tboolean canBePrefixed)", "signatureAfterChange": " \tprivate void findLocalMethods( \t\tchar[] methodName, \t\tTypeBinding[] argTypes, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType, \t\tInvocationSite invocationSite, \t\tScope invocationScope, \t\tboolean implicitCall, \t\tboolean superCall, \t\tboolean canBePrefixed)", "diff": ["-\t\tint methodLength = methodName.length;", "-\t\t\tif (exactMatch) {", "-\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */", "-\t\t\t\t\t))", "-\t\t\t\t\tcontinue next;", "-", "-\t\t\t} else {", "-", "-\t\t\t\tif (methodLength > method.selector.length)", "-\t\t\t\t\tcontinue next;", "-", "-\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false", "-\t\t\t\t\t/* ignore case */", "-\t\t\t\t\t))", "-\t\t\t\t\tcontinue next;", "+\t\t\tif (methodName != null) {", "+\t\t\t\tif (exactMatch) {", "+\t\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) {", "+\t\t\t\t\t\tcontinue next;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tif (methodName.length > method.selector.length) {", "+\t\t\t\t\t\tcontinue next;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false\t/* ignore case */)) {", "+\t\t\t\t\t\tcontinue next;", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t\tif (argTypes[a] != null){ // can be null if it could not be resolved properly", "+\t\t\t\tif (argTypes[a] != null && argTypes[a].isValidBinding()) { // can be null if it could not be resolved properly", "-\t\t\t", "-\t\t\t// nothing to insert - do not want to replace the existing selector & arguments", "-\t\t\tif (!exactMatch) {", "-\t\t\t\tif (this.source != null", "-\t\t\t\t\t&& this.source.length > this.endPosition", "-\t\t\t\t\t&& this.source[this.endPosition] == '(')", "-\t\t\t\t\tcompletion = method.selector;", "-\t\t\t\telse", "-\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });", "-\t\t\t} else {", "-\t\t\t\tif(prefixRequired && (this.source != null)) {", "-\t\t\t\t\tcompletion = CharOperation.subarray(this.source, this.startPosition, this.endPosition);", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.startPosition = this.endPosition;", "+", "+\t\t\t// Special case for completion in javadoc", "+\t\t\tif (this.assistNodeInJavadoc > 0) {", "+\t\t\t\tExpression receiver = null;", "+\t\t\t\tif (invocationSite instanceof CompletionOnJavadocMessageSend) {", "+\t\t\t\t\tCompletionOnJavadocMessageSend msg = (CompletionOnJavadocMessageSend) invocationSite;", "+\t\t\t\t\treceiver = msg.receiver;", "+\t\t\t\t} else if (invocationSite instanceof CompletionOnJavadocFieldReference) {", "+\t\t\t\t\tCompletionOnJavadocFieldReference fieldRef = (CompletionOnJavadocFieldReference) invocationSite;", "+\t\t\t\t\treceiver = fieldRef.receiver;", "-\t\t\t}", "-\t\t\t", "-\t\t\tif(prefixRequired || this.options.forceImplicitQualification){", "-\t\t\t\tchar[] prefix = computePrefix(scope.enclosingSourceType(), invocationScope.enclosingSourceType(), method.isStatic());", "-\t\t\t\tcompletion = CharOperation.concat(prefix,completion,'.');", "+\t\t\t\tStringBuffer javadocCompletion = new StringBuffer();", "+\t\t\t\tif (receiver.isThis()) {", "+\t\t\t\t\tif ((this.assistNodeInJavadoc & /*IN_JAVADOC_TEXT*/CompletionOnJavadoc.TEXT) != 0) {", "+\t\t\t\t\t\tjavadocCompletion.append('#');", "+\t\t\t\t\t}", "+\t\t\t\t} else if ((this.assistNodeInJavadoc & /*IN_JAVADOC_TEXT*/CompletionOnJavadoc.TEXT) != 0) {", "+\t\t\t\t\tif (receiver instanceof JavadocSingleTypeReference) {", "+\t\t\t\t\t\tJavadocSingleTypeReference typeRef = (JavadocSingleTypeReference) receiver;", "+\t\t\t\t\t\tjavadocCompletion.append(typeRef.token);", "+\t\t\t\t\t\tjavadocCompletion.append('#');", "+\t\t\t\t\t} else if (receiver instanceof JavadocQualifiedTypeReference) {", "+\t\t\t\t\t\tJavadocQualifiedTypeReference typeRef = (JavadocQualifiedTypeReference) receiver;", "+\t\t\t\t\t\tcompletion = CharOperation.concat(CharOperation.concatWith(typeRef.tokens, '.'), method.selector, '#');", "+\t\t\t\t\t\tfor (int t=0,nt =typeRef.tokens.length; t<nt; t++) {", "+\t\t\t\t\t\t\tif (t>0) javadocCompletion.append('.');", "+\t\t\t\t\t\t\tjavadocCompletion.append(typeRef.tokens[t]);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tjavadocCompletion.append('#');", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tjavadocCompletion.append(method.selector);", "+\t\t\t\t// Append parameters types", "+\t\t\t\tjavadocCompletion.append('(');", "+\t\t\t\tif (method.parameters != null) {", "+\t\t\t\t\tfor (int p=0, ln=method.parameters.length; p<ln; p++) {", "+\t\t\t\t\t\tif (p>0) javadocCompletion.append(\", \"); //$NON-NLS-1$", "+\t\t\t\t\t\tTypeBinding argTypeBinding = method.parameters[p];", "+\t\t\t\t\t\tcreateType(argTypeBinding.erasure(), javadocCompletion);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tjavadocCompletion.append(')');", "+\t\t\t\tcompletion = javadocCompletion.toString().toCharArray();", "+\t\t\t} else {", "+\t\t\t\t// nothing to insert - do not want to replace the existing selector & arguments", "+\t\t\t\tif (!exactMatch) {", "+\t\t\t\t\tif (this.source != null", "+\t\t\t\t\t\t&& this.source.length > this.endPosition", "+\t\t\t\t\t\t&& this.source[this.endPosition] == '(')", "+\t\t\t\t\t\tcompletion = method.selector;", "+\t\t\t\t\telse", "+\t\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });", "+\t\t\t\t} else {", "+\t\t\t\t\tif(prefixRequired && (this.source != null)) {", "+\t\t\t\t\t\tcompletion = CharOperation.subarray(this.source, this.startPosition, this.endPosition);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.startPosition = this.endPosition;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tif(prefixRequired || this.options.forceImplicitQualification){", "+\t\t\t\t\tchar[] prefix = computePrefix(scope.enclosingSourceType(), invocationScope.enclosingSourceType(), method.isStatic());", "+\t\t\t\t\tcompletion = CharOperation.concat(prefix,completion,'.');", "+\t\t\t\t}", "-\t\t\trelevance += computeRelevanceForCaseMatching(methodName, method.selector);", "+\t\t\tif (methodName != null) relevance += computeRelevanceForCaseMatching(methodName, method.selector);", "-\t\t\tif(!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {", "+\t\t\t// Standard proposal", "+\t\t\tif(!this.requestor.isIgnored(CompletionProposal.METHOD_REF) && (this.assistNodeInJavadoc & CompletionOnJavadoc.ONLY_INLINE_TAG) == 0) {", "+\t\t\t\tif(parameterNames != null) proposal.setParameterNames(parameterNames);", "+\t\t\t\tthis.requestor.accept(proposal);", "+\t\t\t\tif(DEBUG) {", "+\t\t\t\t\tthis.printDebug(proposal);", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\t// Javadoc proposal", "+\t\t\tif ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_METHOD_REF)) {", "+\t\t\t\tchar[] javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_LINK);", "+\t\t\t\tCompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_METHOD_REF, this.actualCompletionPosition);", "+\t\t\t\tproposal.setDeclarationSignature(getSignature(method.declaringClass));", "+\t\t\t\tproposal.setSignature(getSignature(method));", "+\t\t\t\tMethodBinding original = method.original();", "+\t\t\t\tif(original != method) {", "+\t\t\t\t\tproposal.setOriginalSignature(getSignature(original));", "+\t\t\t\t}", "+\t\t\t\tproposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());", "+\t\t\t\tproposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());", "+\t\t\t\tproposal.setParameterPackageNames(parameterPackageNames);", "+\t\t\t\tproposal.setParameterTypeNames(parameterTypeNames);", "+\t\t\t\tproposal.setPackageName(method.returnType.qualifiedPackageName());", "+\t\t\t\tproposal.setTypeName(method.returnType.qualifiedSourceName());", "+\t\t\t\tproposal.setName(method.selector);", "+\t\t\t\tproposal.setCompletion(javadocCompletion);", "+\t\t\t\tproposal.setFlags(method.modifiers);", "+\t\t\t\tint start = (this.assistNodeInJavadoc & CompletionOnJavadoc.REPLACE_TAG) != 0 ? this.javadocTagPosition : this.startPosition;", "+\t\t\t\tproposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);", "+\t\t\t\tproposal.setRelevance(relevance+R_INLINE_TAG);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eb48adaa564e4c50c116bd257161f6ee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionJavadocParser.java", "commitBeforeChange": "f97912416c5f4661289c43d63ee763608220be3f", "commitAfterChange": "e5efe07482ca39d7bb013c10359ef31d2cc33138", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tprotected boolean parseParam() throws InvalidInputException", "signatureAfterChange": "  \t\tprotected boolean parseParam() throws InvalidInputException", "diff": ["-\t */", "-\tprotected boolean parseParam() throws InvalidInputException {", "-\t\tint startPosition = this.index;", "-\t\tint endPosition = this.index;", "-\t\tlong namePosition = (((long)startPosition)<<32) + endPosition;", "-\t\tthis.identifierPtr = -1;", "-\t\tboolean valid = super.parseParam();", "-\t\t// See if expression is concerned by completion", "-\t\tif (this.identifierPtr >= 0) {", "-\t\t\tif (this.identifierPtr >= 1) { // type param, identifier is second one: <ID>", "-\t\t\t\tname = this.identifierStack[1];", "-\t\t\t\tnamePosition = this.identifierPositionStack[1];", "-\t\t\tstartPosition = (int)(this.identifierPositionStack[0]>>32);", "-\t\t\tendPosition = (int)this.identifierPositionStack[this.identifierPtr];", "-\t\t} else {", "-\t\t\tCompletionScanner completionScanner = (CompletionScanner) this.scanner;", "-\t\t\tif (completionScanner.getCurrentIdentifierSource() == CompletionScanner.EmptyCompletionIdentifier) {", "-\t\t\t\tnamePosition = completionScanner.completedIdentifierStart;", "-\t\t\t\tstartPosition = completionScanner.completedIdentifierStart;", "-\t\t\t\tendPosition = completionScanner.completedIdentifierEnd;", "-\t\tboolean inCompletion = (startPosition <= (this.cursorLocation+1) && this.cursorLocation <= endPosition) // completion cursor is between first and last stacked identifiers", "-\t\t\t|| ((startPosition == (endPosition+1) && endPosition == this.cursorLocation)); // or it's a completion on empty token", "-\t\tif (inCompletion) {", "-\t\t\tif (this.completionNode == null) {", "-\t\t\t\tif (this.identifierPtr < 0) {", "-\t\t\t\t\tthis.completionNode = new CompletionOnJavadocParamNameReference(namePosition, startPosition, endPosition);", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.completionNode = new CompletionOnJavadocTypeParamReference(name, namePosition, startPosition, endPosition);", "-\t\t\t\t}", "-\t\t\t\tif (CompletionEngine.DEBUG) {", "-\t\t\t\t\tSystem.out.println(\"\tcompletion param=\"+completionNode); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocParamNameReference) {", "-\t\t\t\tCompletionOnJavadocParamNameReference paramNameRef = (CompletionOnJavadocParamNameReference)this.completionNode;", "-\t\t\t\tint nameStart = (int) (namePosition>>32);", "-\t\t\t\tparamNameRef.sourceStart = nameStart;", "-\t\t\t\tint nameEnd = (int) namePosition;", "-\t\t\t\tif (nameStart<this.cursorLocation && this.cursorLocation<nameEnd) {", "-\t\t\t\t\tparamNameRef.sourceEnd = this.cursorLocation + 1;", "-\t\t\t\t} else {", "-\t\t\t\t\tparamNameRef.sourceEnd = nameEnd;", "-\t\t\t\t}", "-\t\t\t\tparamNameRef.tagSourceStart = startPosition;", "-\t\t\t\tparamNameRef.tagSourceEnd = endPosition;", "-\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {", "-\t\t\t\tCompletionOnJavadocTypeParamReference typeParamRef = (CompletionOnJavadocTypeParamReference)this.completionNode;", "-\t\t\t\tint nameStart = (int) (namePosition>>32);", "-\t\t\t\ttypeParamRef.sourceStart = nameStart;", "-\t\t\t\tint nameEnd = (int) namePosition;", "-\t\t\t\tif (nameStart<this.cursorLocation && this.cursorLocation<nameEnd) {", "-\t\t\t\t\ttypeParamRef.sourceEnd = this.cursorLocation + 1;", "-\t\t\t\t} else {", "-\t\t\t\t\ttypeParamRef.sourceEnd = nameEnd;", "-\t\t\t\t}", "-\t\t\t\ttypeParamRef.tagSourceStart = startPosition;", "-\t\t\t\ttypeParamRef.tagSourceEnd = endPosition;", "-\t\t\t}", "-\t\t}", "-\t\treturn valid;", "+", "+\t\tprotected boolean parseParam() throws InvalidInputException {", "+\t\t\tint startPosition = this.index;", "+\t\t\tint endPosition = this.index;", "+\t\t\tlong namePosition = (((long)startPosition)<<32) + endPosition;", "+\t\t\tthis.identifierPtr = -1;", "+\t\t\tboolean valid = super.parseParam();", "+\t\t\tif (this.identifierPtr > 2) return valid;", "+\t\t\t// See if expression is concerned by completion", "+\t\t\tchar[] name = null;", "+\t\t\tCompletionScanner completionScanner = (CompletionScanner) this.scanner;", "+\t\t\tboolean isTypeParam = false;", "+\t\t\tif (this.identifierPtr < 0) {", "+\t\t\t\t// workaround, empty token should set an empty identifier by scanner and so identifierPtr should be == 0", "+\t\t\t\tif (completionScanner.getCurrentIdentifierSource() == CompletionScanner.EmptyCompletionIdentifier) {", "+\t\t\t\t\tnamePosition = completionScanner.completedIdentifierStart;", "+\t\t\t\t\tstartPosition = completionScanner.completedIdentifierStart;", "+\t\t\t\t\tendPosition = completionScanner.completedIdentifierEnd;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tchar[] identifier = null;", "+\t\t\t\tswitch (this.identifierPtr) {", "+\t\t\t\t\tcase 2:", "+\t\t\t\t\t\tif (!valid && completionScanner.getCurrentIdentifierSource() == CompletionScanner.EmptyCompletionIdentifier) {", "+\t\t\t\t\t\t\tvalid = pushParamName(true);", "+\t\t\t\t\t\t}", "+\t\t\t\t\tcase 1:", "+\t\t\t\t\t\tisTypeParam = true;", "+\t\t\t\t\t\tidentifier = this.identifierStack[1];", "+\t\t\t\t\t\tnamePosition = this.identifierPositionStack[1];", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase 0:", "+\t\t\t\t\t\tidentifier = this.identifierStack[0];", "+\t\t\t\t\t\tnamePosition = this.identifierPositionStack[0];", "+\t\t\t\t\t\tisTypeParam = identifier.length > 0 && identifier[0] == '<';", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tif (identifier.length > 0 && Character.isJavaIdentifierPart(identifier[0])) {", "+\t\t\t\t\tname = identifier;", "+\t\t\t\t}", "+\t\t\t\tstartPosition = (int)(this.identifierPositionStack[0]>>32);", "+\t\t\t\tendPosition = (int)this.identifierPositionStack[this.identifierPtr];", "+\t\t\t}", "+\t\t\tboolean inCompletion = (startPosition <= (this.cursorLocation+1) && this.cursorLocation <= endPosition) // completion cursor is between first and last stacked identifiers", "+\t\t\t\t|| ((startPosition == (endPosition+1) && endPosition == this.cursorLocation)); // or it's a completion on empty token", "+\t\t\tif (inCompletion) {", "+\t\t\t\tif (this.completionNode == null) {", "+\t\t\t\t\tif (isTypeParam) {", "+\t\t\t\t\t\tthis.completionNode = new CompletionOnJavadocTypeParamReference(name, namePosition, startPosition, endPosition);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.completionNode = new CompletionOnJavadocParamNameReference(name, namePosition, startPosition, endPosition);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (CompletionEngine.DEBUG) {", "+\t\t\t\t\t\tSystem.out.println(\"\tcompletion param=\"+completionNode); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocParamNameReference) {", "+\t\t\t\t\tCompletionOnJavadocParamNameReference paramNameRef = (CompletionOnJavadocParamNameReference)this.completionNode;", "+\t\t\t\t\tint nameStart = (int) (namePosition>>32);", "+\t\t\t\t\tparamNameRef.sourceStart = nameStart;", "+\t\t\t\t\tint nameEnd = (int) namePosition;", "+\t\t\t\t\tif (nameStart<this.cursorLocation && this.cursorLocation<nameEnd) {", "+\t\t\t\t\t\tparamNameRef.sourceEnd = this.cursorLocation + 1;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tparamNameRef.sourceEnd = nameEnd;", "+\t\t\t\t\t}", "+\t\t\t\t\tparamNameRef.tagSourceStart = startPosition;", "+\t\t\t\t\tparamNameRef.tagSourceEnd = endPosition;", "+\t\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {", "+\t\t\t\t\tCompletionOnJavadocTypeParamReference typeParamRef = (CompletionOnJavadocTypeParamReference)this.completionNode;", "+\t\t\t\t\tint nameStart = (int) (namePosition>>32);", "+\t\t\t\t\ttypeParamRef.sourceStart = nameStart;", "+\t\t\t\t\tint nameEnd = (int) namePosition;", "+\t\t\t\t\tif (nameStart<this.cursorLocation && this.cursorLocation<nameEnd) {", "+\t\t\t\t\t\ttypeParamRef.sourceEnd = this.cursorLocation + 1;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\ttypeParamRef.sourceEnd = nameEnd;", "+\t\t\t\t\t}", "+\t\t\t\t\ttypeParamRef.tagSourceStart = startPosition;", "+\t\t\t\t\ttypeParamRef.tagSourceEnd = endPosition;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn valid;", "+\t\t}"]}], "num": 70929}