{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "da82abc78674c88c064150224dce3bd4", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0a6f581cceda5fa9a84223abd305f107", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java", "commitBeforeChange": "fe01542fcd3aa3aadeb3ef9dbecdc34ba5993c8d", "commitAfterChange": "e89bfd441ddc86e7db4459ee29b0092f7959a77e", "methodNumberBeforeChange": 54, "methodNumberAfterChange": 26, "signatureBeforeChange": "  protected void consumeEnterVariable()", "signatureAfterChange": "  protected void consumeEnterVariable()", "diff": ["+", "+protected void consumeEnterVariable() {", "+\tboolean isLocalDeclaration = this.nestedMethod[this.nestedType] != 0; ", "+\tsuper.consumeEnterVariable();", "+\tif (isLocalDeclaration) {", "+\t\tif ((this.patternFineGrain & IJavaSearchConstants.LOCAL_VARIABLE_DECLARATION_TYPE_REFERENCE) != 0) {", "+\t\t\tLocalDeclaration localDeclaration = (LocalDeclaration) this.astStack[this.astPtr];", "+\t\t\tthis.patternLocator.match(localDeclaration.type, this.nodeSet);", "+\t\t}", "+\t} else {", "+\t\tif ((this.patternFineGrain & IJavaSearchConstants.FIELD_DECLARATION_TYPE_REFERENCE) != 0) {", "+\t\t\tFieldDeclaration fieldDeclaration = (FieldDeclaration) this.astStack[this.astPtr];", "+\t\t\tthis.patternLocator.match(fieldDeclaration.type, this.nodeSet);", "+\t\t}", "+\t}", "+}", "-", "-protected void consumeEnterVariable() {", "-\tint grain = IJavaSearchConstants.FIELD_DECLARATION_TYPE_REFERENCE | IJavaSearchConstants.LOCAL_VARIABLE_DECLARATION_TYPE_REFERENCE;", "-\tthis.typeRefFineGrain |= grain;", "-\tsuper.consumeEnterVariable();", "-\tthis.typeRefFineGrain &= ~grain;", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2d44ab3744a8334867f2ca1214def9e4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/FieldReferencePattern.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r \tprivate boolean matches(NameReference nameRef, boolean resolve)", "signatureAfterChange": "\r private boolean matches(NameReference nameRef, boolean resolve)", "diff": ["-\t */\r", "-\tprivate boolean matches(NameReference nameRef, boolean resolve) {\r", "-\t\t// field name\r", "-\t\tboolean nameMatch = true;\r", "-\t\tif (this.name != null) {\r", "-\t\t\tif (nameRef instanceof SingleNameReference) {\r", "-\t\t\t\tnameMatch = matchesName(this.name, ((SingleNameReference) nameRef).token);\r", "+ */\r", "+private boolean matches(NameReference nameRef, boolean resolve) {\t\r", "+\t// field name\r", "+\tboolean nameMatch = true;\r", "+\tif (this.name != null) {\r", "+\t\tif (nameRef instanceof SingleNameReference) {\r", "+\t\t\tnameMatch = matchesName(this.name, ((SingleNameReference)nameRef).token);\r", "+\t\t} else { // QualifiedNameReference\r", "+\t\t\tnameMatch = false;\r", "+\t\t\tQualifiedNameReference qNameRef = (QualifiedNameReference)nameRef;\r", "+\t\t\tchar[][] tokens = qNameRef.tokens;\r", "+\t\t\tfor (int i = qNameRef.indexOfFirstFieldBinding-1, max = tokens.length; i < max && !nameMatch; i++){\r", "+\t\t\t\tif (i >= 0) nameMatch = matchesName(this.name, tokens[i]);\r", "+\t\t\t}\r", "+\t\t}\t\t\t\t\r", "+\t} \r", "+\tif (!nameMatch) return false;\r", "+\r", "+\tif (resolve){\t\r", "+\t\tBinding binding = nameRef.binding;\r", "+\t\tif (binding != null){\r", "+\t\t\tif (nameRef instanceof SingleNameReference){\r", "+\t\t\t\tif (binding instanceof FieldBinding){\r", "+\t\t\t\t\tif (!this.matches(nameRef.receiverType, false, (FieldBinding) binding)){\r", "+\t\t\t\t\t\treturn false;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\treturn false; // must be a field binding\r", "+\t\t\t\t}\r", "-\t\t\t\tnameMatch = false;\r", "-\t\t\t\tQualifiedNameReference qNameRef = (QualifiedNameReference) nameRef;\r", "-\t\t\t\tchar[][] tokens = qNameRef.tokens;\r", "-\t\t\t\tfor (int i = qNameRef.indexOfFirstFieldBinding - 1, max = tokens.length;\r", "-\t\t\t\t\ti < max && !nameMatch;\r", "-\t\t\t\t\ti++) {\r", "-\t\t\t\t\tif (i >= 0)\r", "-\t\t\t\t\t\tnameMatch = matchesName(this.name, tokens[i]);\r", "+\t\t\t\tQualifiedNameReference qNameRef = (QualifiedNameReference)nameRef;\r", "+\t\t\t\tTypeBinding receiverType = qNameRef.receiverType;\r", "+\t\t\t\tFieldBinding fieldBinding = null;\r", "+\t\t\t\tif (!(binding instanceof FieldBinding \r", "+\t\t\t\t\t\t&& matchesName(this.name, (fieldBinding = (FieldBinding)binding).name) \r", "+\t\t\t\t\t\t&& matches(receiverType, false, fieldBinding))){\r", "+\t\t\t\t\tif (binding instanceof VariableBinding){\r", "+\t\t\t\t\t\treceiverType = ((VariableBinding) binding).type;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tboolean otherMatch = false;\r", "+\t\t\t\t\tint otherMax = qNameRef.otherBindings == null ? 0 : qNameRef.otherBindings.length;\r", "+\t\t\t\t\tfor (int i = 0; i < otherMax && !otherMatch; i++){\r", "+\t\t\t\t\t\tFieldBinding otherBinding = qNameRef.otherBindings[i];\r", "+\t\t\t\t\t\tif (otherBinding == null) break;\r", "+\t\t\t\t\t\totherMatch = matchesName(this.name, otherBinding.name) && matches(receiverType, false, otherBinding);\r", "+\t\t\t\t\t\treceiverType = otherBinding.type;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tif (!otherMatch) return false;\r", "-\t\tif (!nameMatch)\r", "-\t\t\treturn false;\r", "-\r", "-\t\tif (resolve) {\r", "-\t\t\tBinding binding = nameRef.binding;\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tif (nameRef instanceof SingleNameReference) {\r", "-\t\t\t\t\tif (binding instanceof FieldBinding) {\r", "-\t\t\t\t\t\tif (!this.matches((FieldBinding) binding)) {\r", "-\t\t\t\t\t\t\treturn false;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\treturn false; // must be a field binding\r", "-\t\t\t\t\t}\r", "-\t\t\t\t} else { // QualifiedNameReference\r", "-\t\t\t\t\tQualifiedNameReference qNameRef = (QualifiedNameReference) nameRef;\r", "-\t\t\t\t\tif (!(binding instanceof FieldBinding && matches((FieldBinding) binding))) {\r", "-\t\t\t\t\t\tboolean otherMatch = false;\r", "-\t\t\t\t\t\tint otherMax =\r", "-\t\t\t\t\t\t\tqNameRef.otherBindings == null ? 0 : qNameRef.otherBindings.length;\r", "-\t\t\t\t\t\tfor (int i = 0; i < otherMax && !otherMatch; i++) {\r", "-\t\t\t\t\t\t\totherMatch = matches(qNameRef.otherBindings[i]);\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tif (!otherMatch)\r", "-\t\t\t\t\t\t\treturn false;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\treturn true;\r", "+\treturn true;\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3d3da83191a8101a5c3df79ec36b4693", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "2b8d0ac8be572d49eb7c83b89c8816f15915abc9", "commitAfterChange": "f7f7a56a04d63c15c3ecf4e9ea892b7456b63660", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tsynchronized ITypeBinding resolveExpressionType(Expression expression)", "signatureAfterChange": " \tsynchronized ITypeBinding resolveExpressionType(Expression expression)", "diff": ["+\t\t\t\tcase IBinding.METHOD :", "+\t\t\t\t\treturn ((IMethodBinding) binding).getReturnType();", "+\t\t} else if (expression instanceof MarkerAnnotation) {", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.MarkerAnnotation markerAnnotation = (org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation) this.newAstToOldAst.get(expression);", "+\t\t\treturn this.getTypeBinding(markerAnnotation.resolvedType);", "+\t\t} else if (expression instanceof NormalAnnotation) {", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.NormalAnnotation normalAnnotation = (org.eclipse.jdt.internal.compiler.ast.NormalAnnotation) this.newAstToOldAst.get(expression);", "+\t\t\treturn this.getTypeBinding(normalAnnotation.resolvedType);", "+\t\t} else if (expression instanceof SingleMemberAnnotation) {", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation singleMemberAnnotation = (org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation) this.newAstToOldAst.get(expression);", "+\t\t\treturn this.getTypeBinding(singleMemberAnnotation.resolvedType);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "404432c209c17c9fb488b691ee75401d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "dd10489904dda11a1b9c522a71a4705b9646605e", "commitAfterChange": "b0e8687830f97b9ddeb50b010730e5d2fdfd5916", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "signatureAfterChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "diff": ["+\t\tproper:", "-            \treturn (binding != null && binding.declaringClass.isCompatibleWith(this.right)) ? TRUE : FALSE;", "+            \treturn (binding != null && binding.declaringClass.isCompatibleWith(this.right, inferenceContext.scope)) ? TRUE : FALSE;", "+            } else if (this.left instanceof Invocation && this.left.isPolyExpression()) {", "+            \tInvocation invoc = (Invocation) this.left;", "+            \tMethodBinding binding = invoc.binding(this.right, false, null);", "+            \tif (binding instanceof ParameterizedGenericMethodBinding) {", "+            \t\tParameterizedGenericMethodBinding method = (ParameterizedGenericMethodBinding) binding;", "+\t\t\t\t\tInferenceContext18 leftCtx = invoc.getInferenceContext(method);", "+            \t\tif (leftCtx.stepCompleted < InferenceContext18.TYPE_INFERRED) {", "+            \t\t\tbreak proper; // fall through into nested inference below (not explicit in the spec!)", "+            \t\t}", "+            \t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "72ffc28f80688ef423fed793e294315f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "1f258635fb49ca32f9def120a3d2f7561eca1435", "commitAfterChange": "f3cbbf9c2974017737d02d4ae4c1412f1a96ce0d", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected void attachOrphanCompletionNode()", "signatureAfterChange": " protected void attachOrphanCompletionNode()", "diff": ["+\t\tif(orphan instanceof MemberValuePair) {", "+\t\t\tbuildMoreAnnotationCompletionContext((MemberValuePair) orphan);", "+\t\t\treturn;", "+\t\t}", "+\t\t", "+\t", "+\tif (this.isInsideAnnotation()) {", "+\t\t// push top expression on ast stack if it contains the completion node", "+\t\tExpression expression;", "+\t\tif (this.expressionPtr > -1) {", "+\t\t\texpression = this.expressionStack[this.expressionPtr];", "+\t\t\tif(expression == assistNode) {", "+\t\t\t\tif(this.topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_BETWEEN_ANNOTATION_NAME_AND_RPAREN) {", "+\t\t\t\t\tif (expression instanceof SingleNameReference) {", "+\t\t\t\t\t\tSingleNameReference nameReference = (SingleNameReference) expression;", "+\t\t\t\t\t\tCompletionOnMemberValueName memberValueName = new CompletionOnMemberValueName(nameReference.token, nameReference.sourceStart, nameReference.sourceEnd);", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tbuildMoreAnnotationCompletionContext(memberValueName);", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76c66babb191180b019ea7b78ae6476b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "06d5ad0c6e4971f283c2f47bfc7f9df941ae34e8", "commitAfterChange": "4758255b8284af577e4f7f81a9ecd60704ccc85c", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 41, "signatureBeforeChange": "  \tprivate void acceptPendingPolyArguments(BoundSet acceptedResult, TypeBinding[] parameterTypes, boolean isVarArgs)", "signatureAfterChange": "  \tprivate void acceptPendingPolyArguments(BoundSet acceptedResult, TypeBinding[] parameterTypes, boolean isVarArgs)", "diff": ["-\t\t\tthis.invocationArguments[i].checkAgainstFinalTargetType(targetType);", "+\t\t\tExpression expression = this.invocationArguments[i];", "+\t\t\texpression.checkAgainstFinalTargetType(targetType);", "+\t\t\tif (expression instanceof Invocation) {", "+\t\t\t\tInvocation invocation = (Invocation) expression;", "+\t\t\t\tif (!this.innerPolies.contains(invocation)) {", "+\t\t\t\t\tMethodBinding method = invocation.binding(targetType);", "+\t\t\t\t\tif (method instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\t\t\tParameterizedGenericMethodBinding previousBinding = (ParameterizedGenericMethodBinding) method;", "+\t\t\t\t\t\tInferenceContext18 innerCtx = invocation.getInferenceContext(previousBinding);", "+\t\t\t\t\t\tif (innerCtx != null) {", "+\t\t\t\t\t\t\t// we have a non-poly generic invocation, which needs inference but is not connected via innerPolis.", "+\t\t\t\t\t\t\t// Finish that inner inference now (incl. binding updates):", "+\t\t\t\t\t\t\tMethodBinding innerBinding = innerCtx.inferInvocationType(invocation, previousBinding);", "+\t\t\t\t\t\t\tif (invocation.updateBindings(innerBinding, targetType)) { // only if we are actually improving anything", "+\t\t\t\t\t\t\t\tASTNode.resolvePolyExpressionArguments(invocation, innerBinding);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c1e2c02a03cf3eb360b9a641eba76e4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "390e166678e0fa49ec55a0c44a3dd31625f6e21a", "commitAfterChange": "9ea60639cd404b75c69d97f9c48097cabdf417fc", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tsynchronized IBinding resolveImport(ImportDeclaration importDeclaration)", "signatureAfterChange": " \tsynchronized IBinding resolveImport(ImportDeclaration importDeclaration)", "diff": ["+\t\t\t\tfinal boolean isStatic = importReference.isStatic();", "-\t\t\t\t\tBinding binding = this.scope.getImport(CharOperation.subarray(importReference.tokens, 0, importReference.tokens.length), true, importReference.isStatic());", "+\t\t\t\t\tBinding binding = this.scope.getImport(CharOperation.subarray(importReference.tokens, 0, importReference.tokens.length), true, isStatic);", "-\t\t\t\t\t\tif ((binding.kind() & Binding.PACKAGE) != 0) {", "-\t\t\t\t\t\t\tIPackageBinding packageBinding = this.getPackageBinding((org.eclipse.jdt.internal.compiler.lookup.PackageBinding) binding);", "-\t\t\t\t\t\t\tif (packageBinding == null) {", "-\t\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t\tif (isStatic) {", "+\t\t\t\t\t\t\tif (binding instanceof org.eclipse.jdt.internal.compiler.lookup.TypeBinding) {", "+\t\t\t\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding) binding);", "+\t\t\t\t\t\t\t\treturn typeBinding == null ? null : typeBinding;\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\treturn packageBinding;", "-\t\t\t\t\t\t\t// if it is not a package, it has to be a type", "-\t\t\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding) binding);", "-\t\t\t\t\t\t\tif (typeBinding == null) {", "-\t\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t\t\tif ((binding.kind() & Binding.PACKAGE) != 0) {", "+\t\t\t\t\t\t\t\tIPackageBinding packageBinding = this.getPackageBinding((org.eclipse.jdt.internal.compiler.lookup.PackageBinding) binding);", "+\t\t\t\t\t\t\t\tif (packageBinding == null) {", "+\t\t\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\treturn packageBinding;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// if it is not a package, it has to be a type", "+\t\t\t\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding) binding);", "+\t\t\t\t\t\t\t\tif (typeBinding == null) {", "+\t\t\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\treturn typeBinding;", "-\t\t\t\t\t\t\treturn typeBinding;", "-\t\t\t\t\tBinding binding = this.scope.getImport(importReference.tokens, false, importReference.isStatic());", "-\t\t\t\t\tif (binding != null && binding instanceof org.eclipse.jdt.internal.compiler.lookup.TypeBinding) {", "-\t\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding) binding);", "-\t\t\t\t\t\treturn typeBinding == null ? null : typeBinding;", "+\t\t\t\t\tBinding binding = this.scope.getImport(importReference.tokens, false, isStatic);", "+\t\t\t\t\tif (binding != null) {", "+\t\t\t\t\t\tif (isStatic) {", "+\t\t\t\t\t\t\tif (binding instanceof org.eclipse.jdt.internal.compiler.lookup.TypeBinding) {", "+\t\t\t\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding) binding);", "+\t\t\t\t\t\t\t\treturn typeBinding == null ? null : typeBinding;\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t} else if (binding instanceof FieldBinding) {", "+\t\t\t\t\t\t\t\tIVariableBinding variableBinding = this.getVariableBinding((FieldBinding) binding);", "+\t\t\t\t\t\t\t\treturn variableBinding == null ? null : variableBinding;\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t} else if (binding instanceof org.eclipse.jdt.internal.compiler.lookup.MethodBinding) {", "+\t\t\t\t\t\t\t\t// it is a type", "+\t\t\t\t\t\t\t\treturn this.getMethodBinding((org.eclipse.jdt.internal.compiler.lookup.MethodBinding)binding);\t\t\t\t\t\t", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (binding instanceof org.eclipse.jdt.internal.compiler.lookup.TypeBinding) {", "+\t\t\t\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding) binding);", "+\t\t\t\t\t\t\t\treturn typeBinding == null ? null : typeBinding;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c1270fa81c50fb57923c4209c73e201d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "4b1cb82b00b0f3c43755c37280deb732ae600c1a", "commitAfterChange": "1caf2b41c370e66c328190589dd64f01b35d7384", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tpublic void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "signatureAfterChange": " \tpublic void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "diff": ["-\t\tif (!flowInfo.isReachable()) return;", "+ \t\tif (!flowInfo.isReachable()) return;", "-", "-\t\t\tnestedType.addSyntheticArgumentAndField(binding.enclosingType());\t", "+\t\t\tnestedType.addSyntheticArgumentAndField(nestedType.enclosingType());\t", "-\t\tif (binding.isAnonymousType()) { ", "-\t\t\tReferenceBinding superclassBinding = (ReferenceBinding)binding.superclass.erasure();", "+\t\tif (nestedType.isAnonymousType()) {", "+\t\t\tReferenceBinding superclassBinding = (ReferenceBinding)nestedType.superclass.erasure();", "+\t\t\t// From 1.5 on, provide access to enclosing instance synthetic constructor argument when declared inside constructor call", "+\t\t\t// only for direct anonymous type", "+\t\t\t//public class X {", "+\t\t\t//\tvoid foo() {}", "+\t\t\t//\tclass M {", "+\t\t\t//\t\tM(Object o) {}", "+\t\t\t//\t\tM() { this(new Object() { void baz() { foo(); }}); } // access to #foo() indirects through constructor synthetic arg: val$this$0", "+\t\t\t//\t}", "+\t\t\t//}", "+\t\t\tif (!methodScope.isStatic && methodScope.isConstructorCall && currentScope.environment().options.complianceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\t\tReferenceBinding enclosing = nestedType.enclosingType();", "+\t\t\t\tif (enclosing.isNestedType()) {", "+\t\t\t\t\tNestedTypeBinding nestedEnclosing = (NestedTypeBinding)enclosing;", "+//\t\t\t\t\tif (nestedEnclosing.findSuperTypeErasingTo(nestedEnclosing.enclosingType()) == null) { // only if not inheriting", "+\t\t\t\t\t\tSyntheticArgumentBinding syntheticEnclosingInstanceArgument = nestedEnclosing.getSyntheticArgument(nestedEnclosing.enclosingType(), true);", "+\t\t\t\t\t\tif (syntheticEnclosingInstanceArgument != null) {", "+\t\t\t\t\t\t\tnestedType.addSyntheticArgumentAndField(syntheticEnclosingInstanceArgument);\t", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+//\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e3015ae51f0a0dfb71531ead5e965638", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "4b1cb82b00b0f3c43755c37280deb732ae600c1a", "commitAfterChange": "1caf2b41c370e66c328190589dd64f01b35d7384", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean ignoreEnclosingArgInConstructorCall)", "signatureAfterChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean denyEnclosingArgInConstructorCall)", "diff": ["-\t\t\tboolean ignoreEnclosingArgInConstructorCall) {", "+\t\t\tboolean denyEnclosingArgInConstructorCall) {", "-\t\tif (!currentMethodScope.isConstructorCall && !currentMethodScope.isStatic) {", "+\t\tif (!currentMethodScope.isStatic && !currentMethodScope.isConstructorCall) {", "-\t\t\t\tif (ignoreEnclosingArgInConstructorCall ", "+\t\t\t\tif (denyEnclosingArgInConstructorCall", "+\t\tif (sourceType.isAnonymousType()) {", "+\t\t\tReferenceBinding enclosingType = sourceType.enclosingType();", "+\t\t\tif (enclosingType.isNestedType()) {", "+\t\t\t\tNestedTypeBinding nestedEnclosingType = (NestedTypeBinding) enclosingType;", "+\t\t\t\tSyntheticArgumentBinding enclosingArgument = nestedEnclosingType.getSyntheticArgument(nestedEnclosingType.enclosingType(), onlyExactMatch);", "+\t\t\t\tif (enclosingArgument != null) {", "+\t\t\t\t\tFieldBinding syntheticField = sourceType.getSyntheticField(enclosingArgument);", "+\t\t\t\t\tif (syntheticField != null) {", "+\t\t\t\t\t\tif (syntheticField.type == targetEnclosingType || (!onlyExactMatch && ((ReferenceBinding)syntheticField.type).findSuperTypeErasingTo(targetEnclosingType) != null))", "+\t\t\t\t\t\t\treturn new Object[] { syntheticField };", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eba17cf3bf33128bd99ad48f38ee7b6b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java", "commitBeforeChange": "bd3806cc9cec8e9a14826ff23d7065c6143ced5e", "commitAfterChange": "9c3c9a68123a2dba6c0a481afee1d6f36fcdd02a", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " protected void consumeMethodInvocationName()", "signatureAfterChange": " protected void consumeMethodInvocationName()", "diff": ["+\t\tif (requireExtendedRecovery()) {", "+\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=430572, compensate for the hacks elsewhere where super/this gets treated as identifier. See getUnspecifiedReference", "+\t\t\tif (this.astPtr >= 0 && this.astStack[this.astPtr] == this.assistNode && this.assistNode instanceof ThisReference) {", "+\t\t\t\tMessageSend messageSend = (MessageSend) this.expressionStack[this.expressionPtr];", "+\t\t\t\tif (messageSend.receiver instanceof SingleNameReference) {", "+\t\t\t\t\tSingleNameReference snr = (SingleNameReference) messageSend.receiver;", "+\t\t\t\t\tif (snr.token == CharOperation.NO_CHAR) { // dummy reference created by getUnspecifiedReference ???", "+\t\t\t\t\t\tmessageSend.receiver = (Expression) this.astStack[this.astPtr--];", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}], "num": 29018}