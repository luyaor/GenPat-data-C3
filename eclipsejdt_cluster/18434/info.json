{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7447a51d24480b4eb55daa318fd4015c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "15665165ef9bd6428c1a06c37b31151a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "7548eaaea6e1259875e63eaf19dcd9a6bb7fd118", "commitAfterChange": "3d5aa7d7eabaf3445aad76f168f1c9da2ba34591", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public void add(IJavaElement element, IJavaProject project) throws JavaModelException", "signatureAfterChange": " public void add(IJavaElement element) throws JavaModelException", "diff": ["- */", "-public void add(IJavaElement element, IJavaProject project) throws JavaModelException {", "-\tIPackageFragmentRoot root = null;", "+\tIPath containerPath = null;", "-\t\t\tif (project == null)", "-\t\t\t\tadd((JavaProject)element, null, includeMask, new HashSet(2), null);", "-\t\t\telse", "-\t\t\t\tadd((JavaProject)project, element.getPath(), includeMask, new HashSet(2), null);", "+\t\t\tadd((JavaProject)element, null, includeMask, new HashSet(2), null);", "-\t\t\troot = (IPackageFragmentRoot)element;", "-\t\t\tif (project == null)", "-\t\t\t\tadd(root.getPath().toString(), true, null);", "-\t\t\telse", "-\t\t\t\tadd((JavaProject)project, root.getPath(), includeMask, new HashSet(2), null);", "+\t\t\tIPackageFragmentRoot root = (IPackageFragmentRoot)element;", "+\t\t\tIPath rootPath = root.getPath();", "+\t\t\tcontainerPath = root.getKind() == IPackageFragmentRoot.K_SOURCE ? root.getParent().getPath() : rootPath;", "+\t\t\tadd(rootPath.toString(), containerPath.toString(), true, null);", "-\t\t\t\tIPath path = root.getPath().append(new Path(relativePath));", "-\t\t\t\tif (project == null)", "-\t\t\t\t\tadd(path.toString(), false, null);", "-\t\t\t\telse", "-\t\t\t\t\tadd((JavaProject)project, path, includeMask, new HashSet(2), null);", "+\t\t\t\tcontainerPath = root.getPath();", "+\t\t\t\tIPath path = containerPath.append(new Path(relativePath));", "+\t\t\t\tadd(path.toString(), containerPath.toString(), false, null);", "-\t\t\t\t\tif (project == null)", "-\t\t\t\t\t\tadd(resource.getFullPath().toString(), false, null);", "-\t\t\t\t\telse", "-\t\t\t\t\t\tadd((JavaProject)project, resource.getFullPath(), includeMask, new HashSet(2), null);", "+\t\t\t\t\tcontainerPath = root.getKind() == IPackageFragmentRoot.K_SOURCE ? root.getParent().getPath() : root.getPath();", "+\t\t\t\t\tadd(resource.getFullPath().toString(), containerPath.toString(), false, null);", "-\t\t\tadd(fullPath(element), true, null);", "-\t\t\t", "-\t\t\t// find package fragment root including this java element", "-\t\t\tIJavaElement parent = element.getParent();", "-\t\t\twhile (parent != null && !(parent instanceof IPackageFragmentRoot)) {", "-\t\t\t\tparent = parent.getParent();", "-\t\t\t}", "-\t\t\tif (parent instanceof IPackageFragmentRoot) {", "-\t\t\t\troot = (IPackageFragmentRoot)parent;", "-\t\t\t}", "+\t\t\troot = (IPackageFragmentRoot) element.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);", "+\t\t\tcontainerPath = root.getKind() == IPackageFragmentRoot.K_SOURCE ? root.getParent().getPath() : root.getPath();", "+\t\t\tadd(fullPath(element), containerPath.toString(), true, null);", "-\tif (root != null) {", "-\t\tif (root.getKind() == IPackageFragmentRoot.K_BINARY) {", "-\t\t\tthis.addEnclosingProjectOrJar(root.getPath());", "-\t\t} else {", "-\t\t\tthis.addEnclosingProjectOrJar(root.getJavaProject().getProject().getFullPath());", "-\t\t}", "-\t}", "+\tif (containerPath != null)", "+\t\taddEnclosingProjectOrJar(containerPath);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "42ff4035ec4025435ef6bd2bef342e7c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/StackMapFrameCodeStream.java", "commitBeforeChange": "17d4fac2e2145f81ae8773e6bd604f552ec24c76", "commitAfterChange": "8f4037084194a0a8c6b51e4ac889744e5d6e68a8", "methodNumberBeforeChange": 230, "methodNumberAfterChange": 234, "signatureBeforeChange": " public void optimizeBranch(int oldPosition, BranchLabel lbl)", "signatureAfterChange": " public void optimizeBranch(int oldPosition, BranchLabel lbl)", "diff": ["-\tif (lbl.forwardReferenceCount() > 0) {", "-\t\tStackMapFrame frame = this.frames;", "-\t\tloop: while (frame != null) {", "-\t\t\tif (frame.pc == oldPosition) {", "-\t\t\t\tframe.pc = this.position;", "-\t\t\t\tif (frame.prevFrame.pc == this.position) {", "-\t\t\t\t\t// remove the current frame", "-\t\t\t\t\tStackMapFrame prev = frame.prevFrame;", "-\t\t\t\t\tframe.prevFrame = null;", "-\t\t\t\t\tprev.nextFrame = null;", "-\t\t\t\t\tthis.frames = prev;", "-\t\t\t\t}", "-\t\t\t\tbreak loop;", "+\tint frameIndex = this.frames.size() - 1;", "+\tloop: while(frameIndex > 0) {", "+\t\tStackMapFrame frame = (StackMapFrame) this.frames.get(frameIndex);", "+\t\tif (frame.pc == oldPosition) {", "+\t\t\tif (this.framePositions.remove(new Integer(oldPosition))) {", "+\t\t\t\tthis.framePositions.add(new Integer(this.position));", "-\t\t}", "-\t} else {", "-\t\tStackMapFrame frame = this.frames;", "-\t\tloop: while (frame != null) {", "-\t\t\tif (frame.pc == oldPosition) {", "-\t\t\t\tif ((frame.tagBits & StackMapFrame.USED) != 0) {", "-\t\t\t\t\tframe.pc = this.position;", "-\t\t\t\t\tif (frame.prevFrame.pc == this.position) {", "-\t\t\t\t\t\t// remove the current frame", "-\t\t\t\t\t\tStackMapFrame prev = frame.prevFrame;", "-\t\t\t\t\t\tframe.prevFrame = null;", "-\t\t\t\t\t\tprev.nextFrame = null;", "-\t\t\t\t\t\tthis.frames = prev;", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\t// we completely remove this entry if the prevFrame has the same position", "-\t\t\t\t\tStackMapFrame prev = frame.prevFrame;", "-\t\t\t\t\tframe.prevFrame = null;", "-\t\t\t\t\tprev.nextFrame = null;", "-\t\t\t\t\tthis.frames = prev;", "-\t\t\t\t}", "-\t\t\t\tbreak loop;", "+\t\t\tif (this.variablesModificationsPositions.remove(new Integer(oldPosition))) {", "+\t\t\t\tthis.variablesModificationsPositions.add(new Integer(this.position));", "+\t\t\tframe.pc = this.position;", "+\t\t\tStackMapFrame previousFrame = (StackMapFrame) this.frames.get(frameIndex - 1);", "+\t\t\tif (previousFrame.pc == this.position) {", "+\t\t\t\t// remove the current frame", "+\t\t\t\tthis.frames.set(frameIndex - 1, frame);", "+\t\t\t\tthis.frames.remove(frameIndex);", "+\t\t\t}", "+\t\t\tbreak loop;", "+\t\t} else if (frame.pc > oldPosition) {", "+\t\t\treturn;", "+\t\tframeIndex--;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d36855d5cb9272e031d4d19607ba504", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "4bca3a5b750a1427c84a78f92ee835c1f5e75da7", "commitAfterChange": "65cffea518e323981e83002b5b2ff520f43d6c58", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tMethodBinding foundFuzzyProblem = null;", "-\t\t// the weird method lookup case (matches method name in scope, then arg types, then visibility)", "-\t\tMethodBinding foundInsideProblem = null;", "-\t\t// inside Constructor call or inside static context", "+\t\tMethodBinding foundProblem = null;", "-\t\t\t\t\t\tMethodBinding methodBinding =", "-\t\t\t\t\t\t\t(foundMethod == null)", "-\t\t\t\t\t\t\t\t? classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-\t\t\t\t\t\t\t\t: classScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "+\t\t\t\t\t\tMethodBinding methodBinding = classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\tif (methodBinding.problemId() == ProblemReasons.Ambiguous) {", "-\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible) {", "-\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t\treturn methodBinding;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\tselector,", "-\t\t\t\t\t\t\t\t\targumentTypes,", "-\t\t\t\t\t\t\t\t\tProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tMethodBinding fuzzyProblem = null;", "-\t\t\t\t\t\t\tMethodBinding insideProblem = null;", "-\t\t\t\t\t\t\tif (methodBinding.isValidBinding()) {", "-\t\t\t\t\t\t\t\tif (!methodBinding.isStatic()) {", "-\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\t\tProblemReasons.NonStaticReferenceInConstructorInvocation);", "-\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\t\tProblemReasons.NonStaticReferenceInStaticContext);", "+\t\t\t\t\t\t\tif (foundMethod == null) {", "+\t\t\t\t\t\t\t\tif (methodBinding.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (!methodBinding.isStatic() && (insideConstructorCall || insideStaticContext)) {", "+\t\t\t\t\t\t\t\t\t\tif (foundProblem != null && foundProblem.problemId() != ProblemReasons.NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\treturn foundProblem; // takes precedence", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\t\tinsideConstructorCall", "+\t\t\t\t\t\t\t\t\t\t\t\t? ProblemReasons.NonStaticReferenceInConstructorInvocation", "+\t\t\t\t\t\t\t\t\t\t\t\t: ProblemReasons.NonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS", "-\t\t\t\t\t\t\t\t\t\t|| ((foundFuzzyProblem == null || foundFuzzyProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)) {", "+\t\t\t\t\t\t\t\t\t\t|| ((foundProblem == null || foundProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)", "+\t\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS) {", "-\t\t\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundProblem != null && foundProblem.problemId() != ProblemReasons.NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn foundProblem;", "-\t\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.problemId() != ProblemReasons.NotVisible)", "-\t\t\t\t\t\t\t\t\t\t\t\treturn foundFuzzyProblem;", "-\t\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tfuzzyProblem = methodBinding;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (foundMethod != null && foundMethod.declaringClass != methodBinding.declaringClass)", "-\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass || (receiverType.getMethods(selector)) != Binding.NO_METHODS)", "-\t\t\t\t\t\t\t\t\t// if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "+\t\t\t\t\t\t\t\t\tif (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\t\t// only remember the methodBinding if its the first one found", "+\t\t\t\t\t\t\t\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "+\t\t\t\t\t\t\t\t\t\tif (depth > 0) {", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tfoundMethod = methodBinding;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else { // methodBinding is a problem method", "+\t\t\t\t\t\t\t\t\tif (methodBinding.problemId() != ProblemReasons.NotVisible && methodBinding.problemId() != ProblemReasons.NotFound)", "+\t\t\t\t\t\t\t\t\t\treturn methodBinding; // return the error now", "+\t\t\t\t\t\t\t\t\tif (foundProblem == null || (foundProblem.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() == ProblemReasons.NotFound))", "+\t\t\t\t\t\t\t\t\t\tfoundProblem = methodBinding; // hold onto the first not visible/found error and keep the second not found if first is not visible", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else { // found a valid method so check to see if this is a hiding case", "+\t\t\t\t\t\t\t\tif (methodBinding.problemId() == ProblemReasons.Ambiguous", "+\t\t\t\t\t\t\t\t\t|| (foundMethod.declaringClass != methodBinding.declaringClass", "+\t\t\t\t\t\t\t\t\t\t&& (receiverType == methodBinding.declaringClass || receiverType.getMethods(selector) != Binding.NO_METHODS)))", "+\t\t\t\t\t\t\t\t\t// ambiguous case -> must qualify the method (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\t\t// otherwise if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\tselector,", "+\t\t\t\t\t\t\t\t\t\targumentTypes,", "-", "-\t\t\t\t\t\t\tif (foundMethod == null || (foundMethod.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() != ProblemReasons.NotVisible)) {", "-\t\t\t\t\t\t\t\t// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...", "-\t\t\t\t\t\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "-\t\t\t\t\t\t\t\tif (depth > 0) {", "-\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tfoundFuzzyProblem = fuzzyProblem;", "-\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\t\t\t\t\t\tif (fuzzyProblem == null)", "-\t\t\t\t\t\t\t\t\tfoundMethod = methodBinding; // only keep it if no error was found", "-\t\t\t\t\tinsideConstructorCall =", "-\t\t\t\t\t\tenclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "+\t\t\t\t\tinsideConstructorCall = enclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;", "-\t\tif (foundFuzzyProblem != null)", "-\t\t\tif (foundFuzzyProblem.problemId() != ProblemReasons.NotVisible && foundFuzzyProblem.problemId() != ProblemReasons.NotFound)", "-\t\t\t\treturn foundFuzzyProblem;", "-\t\tif (foundInsideProblem != null)", "-\t\t\treturn foundInsideProblem;", "-", "-\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.declaringClass != null && foundFuzzyProblem.declaringClass.id == TypeIds.T_JavaLangObject)", "-\t\t\t\treturn foundFuzzyProblem; // static imports lose to methods from Object", "+\t\t\tif (foundProblem != null) {", "+\t\t\t\tif (foundProblem.declaringClass != null && foundProblem.declaringClass.id == TypeIds.T_JavaLangObject)", "+\t\t\t\t\treturn foundProblem; // static imports lose to methods from Object", "+\t\t\t\tif (foundProblem.problemId() == ProblemReasons.NotFound) {", "+\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding) foundProblem).closestMatch;", "+\t\t\t\t\tif (closestMatch != null && closestMatch.canBeSeenBy(invocationSite, this))", "+\t\t\t\t\t\treturn foundProblem; // visible method selectors take precedence", "+\t\t\t\t}", "+\t\t\t}", "-\t\t\t\t\t\tif (possible != null && possible != foundFuzzyProblem) {", "+\t\t\t\t\t\tif (possible != null && possible != foundProblem) {", "-\t\t\t\t\t\t\t\tif (foundFuzzyProblem == null)", "-\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = possible; // answer as error case match", "+\t\t\t\t\t\t\t\tif (foundProblem == null)", "+\t\t\t\t\t\t\t\t\tfoundProblem = possible; // answer as error case match", "-\t\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "-\t\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t\t} else if (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundProblem = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "-\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "-\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t} else if (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\t\tfoundProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "-\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\t\t\t\t\t\t} else if (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\tfoundProblem = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\tif (foundFuzzyProblem != null)", "-\t\t\treturn foundFuzzyProblem;", "+\t\tif (foundProblem != null)", "+\t\t\treturn foundProblem;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5dcfe368acb010c50104eaf5ce0b5d31", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterJavadocTest.java", "commitBeforeChange": "bc11b8ca976f8360b7224f086a28378398f2dfd3", "commitAfterChange": "48f756ae0727772676a244af8217d19fe8e81145", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tprotected void verifyComments(ICompilationUnit unit) throws JavaModelException", "signatureAfterChange": " \tprotected void verifyComments(ICompilationUnit unit) throws JavaModelException", "diff": ["+\t\tthis.prefix = unit.getElementName()+\": \";", "-\t\tif (problems) {", "-\t\t\ttry {", "-\t\t\t\tproject.setOption(JavaCore.COMPILER_PB_INVALID_JAVADOC, JavaCore.ERROR);", "-\t\t\t\tproject.setOption(JavaCore.COMPILER_PB_MISSING_JAVADOC_TAGS, JavaCore.ERROR);", "-\t\t\t\tproject.setOption(JavaCore.COMPILER_PB_MISSING_JAVADOC_COMMENTS, JavaCore.ERROR);", "-\t\t\t\tCompilationUnit compilUnit = (CompilationUnit) runConversion(this.sourceUnit, true); // resolve bindings", "-\t\t\t\tassertEquals(this.prefix+\"Unexpected problems\", 0, compilUnit.getProblems().length); //$NON-NLS-1$", "+\t\ttry {", "+\t\t\t\tproject.setOption(JavaCore.COMPILER_PB_INVALID_JAVADOC, this.compilerOption);", "+\t\t\t\tproject.setOption(JavaCore.COMPILER_PB_MISSING_JAVADOC_TAGS, this.compilerOption);", "+\t\t\t\tproject.setOption(JavaCore.COMPILER_PB_MISSING_JAVADOC_COMMENTS, this.compilerOption);", "+\t\t\t\tproject.setOption(JavaCore.COMPILER_PB_METHOD_WITH_CONSTRUCTOR_NAME, JavaCore.IGNORE);", "+\t\t\t\tCompilationUnit compilUnit = (CompilationUnit) runConversion(this.sourceUnit, this.resolveBinding); // resolve bindings", "+\t\t\t\tif (problems.equals(JavaCore.ERROR)) {", "+\t\t\t\t\tassertEquals(this.prefix+\"Unexpected problems\", 0, compilUnit.getProblems().length); //$NON-NLS-1$", "+\t\t\t\t} else if (problems.equals(JavaCore.WARNING)) {", "+\t\t\t\t\tIProblem[] problemsList = compilUnit.getProblems();", "+\t\t\t\t\tint length = problemsList.length;", "+\t\t\t\t\tSystem.out.println(this.prefix+length+\" unexpected problems:\"); //$NON-NLS-1$", "+\t\t\t\t\tfor (int i = 0; i < problemsList.length; i++) {", "+\t\t\t\t\t\tSystem.out.println(\"  - \"+problemsList[i]);", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t} finally {", "-\t\t\t\tproject.setOptions(originalOptions);", "-\t\t\t}", "-\t\t} else {", "-\t\t\t\tCompilationUnit compilUnit = (CompilationUnit) runConversion(this.sourceUnit, true); // resolve bindings", "-\t\t\t\tunitComments = compilUnit.getCommentTable();", "+\t\t} finally {", "+\t\t\tproject.setOptions(originalOptions);", "-", "-\t\t// Get comments infos from test file", "+\t\t", "+\t\t// Verify source regardings converted comments", "+\t\tverifyComments(sourceStr, source, unitComments);", "+\t}", "-\t\t\t\tverifyBindings(docComment);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "852c2f62f957ea6f86fe72827c84da89", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "67be753fec1b8f88653e28d3d4d4837dd29cdece", "commitAfterChange": "c76b87d837ed14384819cb84439501329f23edce", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r \r \tprivate IBinding resolveNameForMessageSend(Name name, AstNode node)", "signatureAfterChange": "\r \tIBinding resolveImport(ImportDeclaration importDeclaration)", "diff": ["-\tprivate IBinding resolveNameForMessageSend(Name name, AstNode node) {\r", "-\t\tMessageSend messageSend = (MessageSend) node;\r", "-\t\tif (name.isSimpleName()) {\r", "-\t\t\t// this can be either the qualifier or the method invocation name\r", "-\t\t\tSimpleName simpleName = (SimpleName) name;\r", "-\t\t\tif (simpleName.getIdentifier().equals(new String(messageSend.selector))) {\r", "-\t\t\t\treturn this.getMethodBinding(messageSend.binding); \r", "-\t\t\t} else {\r", "-\t\t\t\t// this is the qualifier\r", "-\t\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression receiver = messageSend.receiver;\r", "-\t\t\t\tif (receiver instanceof SingleNameReference) {\r", "-\t\t\t\t\tSingleNameReference singleNameReference = (SingleNameReference) receiver;\r", "-\t\t\t\t\tif (singleNameReference.isTypeReference()) {\r", "-\t\t\t\t\t\treturn this.getTypeBinding((ReferenceBinding)singleNameReference.binding);\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t// this is a variable or a field\r", "-\t\t\t\t\t\treturn this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding)singleNameReference.binding);\t\t\t\t\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t} else {\r", "-\t\t\t// this is the qualifier\r", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression receiver = messageSend.receiver;\r", "-\t\t\tif (receiver instanceof QualifiedNameReference) {\r", "-\t\t\t\tQualifiedNameReference qualifiedNameReference = (QualifiedNameReference) receiver;\r", "-\t\t\r", "-\t\t\t\tif (qualifiedNameReference.isTypeReference()) {\r", "-\t\t\t\t\treturn this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\t// this is a variable or a field\r", "-\t\t\t\t\treturn this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) qualifiedNameReference.binding);\t\t\t\t\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\treturn super.resolveName(name);\r", "-\t}\r", "+\t */\r", "+\tIBinding resolveImport(ImportDeclaration importDeclaration) {\r", "+\t\tScope scope = retrieveCompilationUnitScope(importDeclaration);\r", "+\t\tAstNode node = (AstNode) this.newAstToOldAst.get(importDeclaration);\r", "+\t\tif (node instanceof ImportReference) {\r", "+\t\t\tImportReference importReference = (ImportReference) node;\r", "+\t\t\tif (importReference.onDemand) {\r", "+\t\t\t\tBinding binding = scope.getTypeOrPackage(CharOperation.subarray(importReference.tokens, 0, importReference.tokens.length));\r", "+\t\t\t\tif ((binding != null) && (binding.isValidBinding())) {\r", "+\t\t\t\t\tIPackageBinding packageBinding = this.getPackageBinding((org.eclipse.jdt.internal.compiler.lookup.PackageBinding) binding);\r", "+\t\t\t\t\tthis.bindingsToAstNodes.put(packageBinding, importDeclaration);\r", "+\t\t\t\t\treturn packageBinding;\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\tBinding binding = scope.getTypeOrPackage(importReference.tokens);\r", "+\t\t\t\tif (binding != null && binding.isValidBinding()) {\r", "+\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding) binding);\r", "+\t\t\t\t\tthis.bindingsToAstNodes.put(typeBinding, importDeclaration);\r", "+\t\t\t\t\treturn typeBinding;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\treturn super.resolveImport(importDeclaration);\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a9cf4cc68bdbce0f1f7000ef88931d50", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "415e478fd80c86e1c699eefa6d86979134ae5921", "commitAfterChange": "63b8bf54c7c6ab31eaeaf33c9d376ceaa28b674d", "methodNumberBeforeChange": 91, "methodNumberAfterChange": 117, "signatureBeforeChange": " \tpublic IClasspathEntry[] getResolvedClasspath( \t\tIClasspathEntry[] classpathEntries, \t\tIPath projectOutputLocation, \t\tboolean ignoreUnresolvedEntry, \t\tboolean generateMarkerOnError, \t\tMap rawReverseMap) \t\tthrows JavaModelException", "signatureAfterChange": " \tpublic void resolveClasspath(PerProjectInfo perProjectInfo) throws JavaModelException", "diff": ["-\tpublic IClasspathEntry[] getResolvedClasspath(", "-\t\tIClasspathEntry[] classpathEntries,", "-\t\tIPath projectOutputLocation, // only set if needing full classpath validation (and markers)", "-\t\tboolean ignoreUnresolvedEntry, // if unresolved entries are met, should it trigger initializations", "-\t\tboolean generateMarkerOnError,", "-\t\tMap rawReverseMap) // can be null if not interested in reverse mapping", "-\t\tthrows JavaModelException {", "-\t\tIJavaModelStatus status;", "-\t\tif (generateMarkerOnError){", "-\t\t\tflushClasspathProblemMarkers(false, false);", "-\t\tint length = classpathEntries.length;", "-\t\tArrayList resolvedEntries = new ArrayList();", "-\t\tfor (int i = 0; i < length; i++) {", "-", "-\t\t\tIClasspathEntry rawEntry = classpathEntries[i];", "-\t\t\tIPath resolvedPath;", "-\t\t\tstatus = null;", "-\t\t\t", "-\t\t\t/* validation if needed */", "-\t\t\tif (generateMarkerOnError || !ignoreUnresolvedEntry) {", "-\t\t\t\tstatus = ClasspathEntry.validateClasspathEntry(this, rawEntry, false /*ignore src attach*/, false /*do not recurse in containers, done later to accumulate*/);", "-\t\t\t\tif (generateMarkerOnError && !status.isOK()) {", "-\t\t\t\t\tif (status.getCode() == IJavaModelStatusConstants.INVALID_CLASSPATH && ((ClasspathEntry) rawEntry).isOptional())", "-\t\t\t\t\t\tcontinue; // ignore this entry", "-\t\t\t\t\tcreateClasspathProblemMarker(status);", "-\t\t\t\t}", "-", "-\t\t\tswitch (rawEntry.getEntryKind()){", "-\t\t\t\t", "-\t\t\t\tcase IClasspathEntry.CPE_VARIABLE :", "-\t\t\t\t", "-\t\t\t\t\tIClasspathEntry resolvedEntry = null;", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tresolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);", "-\t\t\t\t\t} catch (AssertionFailedException e) {", "-\t\t\t\t\t\t// Catch the assertion failure and throw java model exception instead", "-\t\t\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=55992", "-\t\t\t\t\t\t// if ignoredUnresolvedEntry is false, status is set by by ClasspathEntry.validateClasspathEntry", "-\t\t\t\t\t\t// called above as validation was needed", "-\t\t\t\t\t\tif (!ignoreUnresolvedEntry) throw new JavaModelException(status);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (resolvedEntry == null) {", "-\t\t\t\t\t\tif (!ignoreUnresolvedEntry) throw new JavaModelException(status);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (rawReverseMap != null) {", "-\t\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) rawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak; ", "-", "-\t\t\t\tcase IClasspathEntry.CPE_CONTAINER :", "-\t\t\t\t", "-\t\t\t\t\tIClasspathContainer container = JavaCore.getClasspathContainer(rawEntry.getPath(), this);", "-\t\t\t\t\tif (container == null){", "-\t\t\t\t\t\tif (!ignoreUnresolvedEntry) throw new JavaModelException(status);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-", "-\t\t\t\t\tIClasspathEntry[] containerEntries = container.getClasspathEntries();", "-\t\t\t\t\tif (containerEntries == null) break;", "-", "-\t\t\t\t\t// container was bound", "-\t\t\t\t\tfor (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){", "-\t\t\t\t\t\tClasspathEntry cEntry = (ClasspathEntry) containerEntries[j];", "-\t\t\t\t\t\tif (generateMarkerOnError) {", "-\t\t\t\t\t\t\tIJavaModelStatus containerStatus = ClasspathEntry.validateClasspathEntry(this, cEntry, false, true /*recurse*/);", "-\t\t\t\t\t\t\tif (!containerStatus.isOK()) createClasspathProblemMarker(containerStatus);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// if container is exported or restricted, then its nested entries must in turn be exported  (21749) and/or propagate restrictions", "-\t\t\t\t\t\tcEntry = cEntry.combineWith((ClasspathEntry) rawEntry);", "-\t\t\t\t\t\tif (rawReverseMap != null) {", "-\t\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = cEntry.getPath()) == null) rawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tresolvedEntries.add(cEntry);", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\tdefault :", "-", "-\t\t\t\t\tif (rawReverseMap != null) {", "-\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = rawEntry.getPath()) == null) rawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t}", "-\t\t\t\t\tresolvedEntries.add(rawEntry);", "-\t\t\t\t", "-\t\t\t}\t\t\t\t\t", "-", "-\t\tIClasspathEntry[] resolvedPath = new IClasspathEntry[resolvedEntries.size()];", "-\t\tresolvedEntries.toArray(resolvedPath);", "-", "-\t\tif (generateMarkerOnError && projectOutputLocation != null) {", "-\t\t\tstatus = ClasspathEntry.validateClasspath(this, resolvedPath, projectOutputLocation);", "-\t\t\tif (!status.isOK()) createClasspathProblemMarker(status);", "-\t\t}", "-\t\treturn resolvedPath;", "+\t */", "+\tpublic void resolveClasspath(PerProjectInfo perProjectInfo) throws JavaModelException {", "+\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\t\ttry {", "+\t\t\tmanager.setClasspathBeingResolved(this, true);", "+\t\t\t", "+\t\t\t// get raw info inside a synchronized block to ensure that it is consistent", "+\t\t\tIClasspathEntry[] rawClasspath;", "+\t\t\tIPath outputLocation;", "+\t\t\tIJavaModelStatus rawClasspathStatus;", "+\t\t\tsynchronized (perProjectInfo) {", "+\t\t\t\trawClasspath= perProjectInfo.rawClasspath;", "+\t\t\t\tif (rawClasspath == null)", "+\t\t\t\t\trawClasspath = perProjectInfo.readAndCacheClasspath(this);", "+\t\t\t\toutputLocation = perProjectInfo.outputLocation;", "+\t\t\t\trawClasspathStatus = perProjectInfo.rawClasspathStatus;", "+\t\t\t}", "+\t\t\t \t\t\t", "+\t\t\tIJavaModelStatus unresolvedEntryStatus = JavaModelStatus.VERIFIED_OK;", "+\t\t\tHashMap rawReverseMap = new HashMap();", "+\t\t\t", "+\t\t\tArrayList resolvedEntries = new ArrayList();", "+\t\t\tint length = rawClasspath.length;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t", "+\t\t\t\tIClasspathEntry rawEntry = rawClasspath[i];", "+\t\t\t\tIPath resolvedPath;", "+\t\t\t\t", "+\t\t\t\tswitch (rawEntry.getEntryKind()){", "+\t\t\t\t\t", "+\t\t\t\t\tcase IClasspathEntry.CPE_VARIABLE :", "+\t\t\t\t\t\tIClasspathEntry resolvedEntry = null;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tresolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);", "+\t\t\t\t\t\t} catch (AssertionFailedException e) {", "+\t\t\t\t\t\t\t// Catch the assertion failure and set ststus instead", "+\t\t\t\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=55992", "+\t\t\t\t\t\t\tunresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, e.getMessage());", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (resolvedEntry == null) {", "+\t\t\t\t\t\t\tunresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND, this, rawEntry.getPath());", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (rawReverseMap != null) {", "+\t\t\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) rawReverseMap.put(resolvedPath , rawEntry);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak; ", "+\t", "+\t\t\t\t\tcase IClasspathEntry.CPE_CONTAINER :", "+\t\t\t\t\t\tIClasspathContainer container = JavaCore.getClasspathContainer(rawEntry.getPath(), this);", "+\t\t\t\t\t\tif (container == null){", "+\t\t\t\t\t\t\tunresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.CP_CONTAINER_PATH_UNBOUND, this, rawEntry.getPath());", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t", "+\t\t\t\t\t\tIClasspathEntry[] containerEntries = container.getClasspathEntries();", "+\t\t\t\t\t\tif (containerEntries == null) break;", "+\t", "+\t\t\t\t\t\t// container was bound", "+\t\t\t\t\t\tfor (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){", "+\t\t\t\t\t\t\tClasspathEntry cEntry = (ClasspathEntry) containerEntries[j];", "+\t\t\t\t\t\t\t// if container is exported or restricted, then its nested entries must in turn be exported  (21749) and/or propagate restrictions", "+\t\t\t\t\t\t\tcEntry = cEntry.combineWith((ClasspathEntry) rawEntry);", "+\t\t\t\t\t\t\tif (rawReverseMap != null) {", "+\t\t\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = cEntry.getPath()) == null) rawReverseMap.put(resolvedPath , rawEntry);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tresolvedEntries.add(cEntry);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\tif (rawReverseMap != null) {", "+\t\t\t\t\t\t\tif (rawReverseMap.get(resolvedPath = rawEntry.getPath()) == null) rawReverseMap.put(resolvedPath , rawEntry);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tresolvedEntries.add(rawEntry);", "+\t\t\t\t}\t\t\t\t\t", "+\t\t\t}", "+\t", "+\t\t\t// store resolved info along with the raw info to ensure consistency", "+\t\t\tIClasspathEntry[] resolvedClasspath = new IClasspathEntry[resolvedEntries.size()];", "+\t\t\tresolvedEntries.toArray(resolvedClasspath);", "+\t\t\tperProjectInfo.setClasspath(rawClasspath, outputLocation, rawClasspathStatus, resolvedClasspath, rawReverseMap, unresolvedEntryStatus);", "+\t\t} finally {", "+\t\t\tmanager.setClasspathBeingResolved(this, false);", "+\t\t}", "+\t}"]}], "num": 18434}