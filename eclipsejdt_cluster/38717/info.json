{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "30a3d6c4a0a040e47391544c0b6f68bd", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "168b81df764f1a06a8d620367b4d8db0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "0dc7155c5e6d95f70a9aded517c1b54b5c1563f1", "commitAfterChange": "f6b4d99cbdd9c3e7eddd18da23b2ebc6b500e5e0", "methodNumberBeforeChange": 67, "methodNumberAfterChange": 67, "signatureBeforeChange": "  \tprivate TypeBinding leastContainingInvocation(TypeBinding mec, Set invocations, List lubStack)", "signatureAfterChange": "  \tprivate TypeBinding leastContainingInvocation(TypeBinding mec, Object invocationData, List lubStack)", "diff": ["-\tprivate TypeBinding leastContainingInvocation(TypeBinding mec, Set invocations, List lubStack) {", "-\t\tif (invocations == null) return mec; // no alternate invocation", "-\t\tint length = invocations.size();", "-\t\tIterator iter = invocations.iterator();", "-\t\tif (length == 1) return (TypeBinding) iter.next();", "+\tprivate TypeBinding leastContainingInvocation(TypeBinding mec, Object invocationData, List lubStack) {", "+\t\tif (invocationData == null) return mec; // no alternate invocation", "+\t\tif (invocationData instanceof TypeBinding) { // only one invocation, simply return it (array only allocated if more than one)", "+\t\t\treturn (TypeBinding) invocationData;", "+\t\t}", "+\t\tTypeBinding[] invocations = (TypeBinding[]) invocationData;", "-\t\twhile (iter.hasNext()) {", "-\t\t\tTypeBinding invocation = ((TypeBinding)iter.next()).leafComponentType();", "+\t\tfor (int i = 0, length = invocations.length; i < length; i++) {", "+\t\t\tTypeBinding invocation = invocations[i].leafComponentType();", "-\t\t\t\t\tfor (int i = 0; i < argLength; i++) {", "-\t\t\t\t\t\tTypeBinding bestArgument = leastContainingTypeArgument(bestArguments[i], invocationVariables[i], (ReferenceBinding) mec, i, lubStack);", "+\t\t\t\t\tfor (int j = 0; j < argLength; j++) {", "+\t\t\t\t\t\tTypeBinding bestArgument = leastContainingTypeArgument(bestArguments[j], invocationVariables[j], (ReferenceBinding) mec, j, lubStack);", "-\t\t\t\t\t\tbestArguments[i] = bestArgument;", "+\t\t\t\t\t\tbestArguments[j] = bestArgument;", "-\t\t\t\t\tfor (int i = 0; i < argLength; i++) {", "-\t\t\t\t\t\tTypeBinding bestArgument = leastContainingTypeArgument(bestArguments[i], parameterizedType.arguments[i], (ReferenceBinding) mec, i, lubStack);", "+\t\t\t\t\tfor (int j = 0; j < argLength; j++) {", "+\t\t\t\t\t\tTypeBinding bestArgument = leastContainingTypeArgument(bestArguments[j], parameterizedType.arguments[j], (ReferenceBinding) mec, j, lubStack);", "-\t\t\t\t\t\tbestArguments[i] = bestArgument;", "+\t\t\t\t\t\tbestArguments[j] = bestArgument;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "397610c6f592d040537a083af312218e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "afbd59588c9ca5e9f9fa1e0c9c6d428db18067ff", "commitAfterChange": "5d6b68778bc5cc6ff8d2d7502de9a5e78a68b5d0", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " private void createMethods(IBinaryMethod[] iMethods)", "signatureAfterChange": " private void createMethods(IBinaryMethod[] iMethods)", "diff": ["+\tint[] toSkip = null;", "-\t\t\tIBinaryMethod method;", "-\t\t\tchar[] methodName = (method = iMethods[i]).getSelector();", "-\t\t\tif ((methodName[0] == '<' && methodName.length == 8)", "-\t\t\t\t\t|| (method.getModifiers() & AccSynthetic) != 0) { // Can only match <clinit> or synthetics", "-\t\t\t\ttotal--;", "+\t\t\tIBinaryMethod method = iMethods[i];", "+\t\t\tchar[] methodName;", "+\t\t\tif ((method.getModifiers() & AccSynthetic) != 0 ||", "+\t\t\t\t((methodName = method.getSelector()).length == 8 && methodName[0] == '<')) {", "+\t\t\t\t\tif (toSkip == null)", "+\t\t\t\t\t\ttoSkip = new int[iMethods.length];", "+\t\t\t\t\ttoSkip[i] = -1;", "+\t\t\t\t\ttotal--;", "-\tfor (int i = 0, length = iMethods.length; i < length; i++){", "-\t\t\tIBinaryMethod method;", "-\t\t\tchar[] methodName = (method = iMethods[i]).getSelector();", "-\t\t\tif (!((methodName[0] == '<' && methodName.length == 8)", "-\t\t\t\t\t|| (method.getModifiers() & AccSynthetic) != 0)) { // Can only match <clinit> or synthetics", "+\tif (toSkip == null) {", "+\t\tfor (int i = 0, length = iMethods.length; i < length; i++)", "+\t\t\tthis.methods[next++] = createMethod(iMethods[i]);", "+\t} else {", "+\t\tfor (int i = 0, length = iMethods.length; i < length; i++)", "+\t\t\tif (toSkip[i] == 0)", "-\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4e95e7169477dc88849533650d7ca04f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "acb688302e3cacbdc42738d6941f0a71f5b00f9c", "commitAfterChange": "37562c5a562cc71ff03559ef16cdaf50168f2116", "methodNumberBeforeChange": 44, "methodNumberAfterChange": 44, "signatureBeforeChange": " \tpublic boolean visit( \t\tAnonymousLocalTypeDeclaration anonymousTypeDeclaration, \t\tBlockScope scope)", "signatureAfterChange": " \tpublic boolean visit(Argument argument, BlockScope scope)", "diff": ["-\t */", "-\tpublic boolean visit(", "-\t\tAnonymousLocalTypeDeclaration anonymousTypeDeclaration,", "-\t\tBlockScope scope) {", "-\t\t\t", "-\t\t/*", "-\t\t * Type body", "-\t\t */", "-\t\tString anonymous_type_declaration_brace_position = this.preferences.anonymous_type_declaration_brace_position;", "-\t\tformatTypeOpeningBrace(anonymous_type_declaration_brace_position, this.preferences.insert_space_before_anonymous_type_open_brace, anonymousTypeDeclaration);", "-\t\t", "-\t\tthis.scribe.indent();", "-", "-\t\tformatTypeMembers(anonymousTypeDeclaration);", "-\t\t", "-\t\tthis.scribe.printComment();", "-\t\tthis.scribe.unIndent();", "-\t\tif (this.preferences.insert_new_line_in_empty_anonymous_type_declaration) {", "-\t\t\tthis.scribe.printNewLine();", "-\t\t}", "-\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameRBRACE);", "-\t\tif (anonymous_type_declaration_brace_position.equals(DefaultCodeFormatterConstants.NEXT_LINE_SHIFTED)) {", "-\t\t\tthis.scribe.unIndent();", "-\t\t}", "-\t\treturn false;", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "83121e0fa9bec32ff93182f9d65bcac8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "78c62e3a4157070f714848f4de312a55f14f5144", "commitAfterChange": "fb48e11da0ebe84c63fab7b3cb5afd39c0ba6101", "methodNumberBeforeChange": 64, "methodNumberAfterChange": 64, "signatureBeforeChange": " \tprivate TypeBinding leastContainingInvocation(TypeBinding mec, List invocations)", "signatureAfterChange": " \tprivate TypeBinding leastContainingInvocation(TypeBinding mec, Set invocations, List lubStack)", "diff": ["-\tprivate TypeBinding leastContainingInvocation(TypeBinding mec, List invocations) {", "+\tprivate TypeBinding leastContainingInvocation(TypeBinding mec, Set invocations, List lubStack) {", "-\t\tif (length == 0) return mec;", "-\t\tif (length == 1) return (TypeBinding) invocations.get(0);", "+\t\tIterator iter = invocations.iterator();", "+\t\tif (length == 1) return (TypeBinding) iter.next();", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tTypeBinding invocation = (TypeBinding)invocations.get(i);", "+\t\twhile (iter.hasNext()) {", "+\t\t\tTypeBinding invocation = (TypeBinding)iter.next();", "-\t\t\t\tfor (int j = 0; j < argLength; j++) {", "-\t\t\t\t\tTypeBinding bestArgument = leastContainingTypeArgument(bestArguments[j], invocationVariables[j], (ReferenceBinding) mec, j);", "+\t\t\t\tfor (int i = 0; i < argLength; i++) {", "+\t\t\t\t\tTypeBinding bestArgument = leastContainingTypeArgument(bestArguments[i], invocationVariables[i], (ReferenceBinding) mec, i, lubStack);", "-\t\t\t\t\tbestArguments[j] = bestArgument;", "+\t\t\t\t\tbestArguments[i] = bestArgument;", "-\t\t\t\tfor (int j = 0; j < argLength; j++) {", "-\t\t\t\t\tTypeBinding bestArgument = leastContainingTypeArgument(bestArguments[j], parameterizedType.arguments[j], (ReferenceBinding) mec, j);", "+\t\t\t\tfor (int i = 0; i < argLength; i++) {", "+\t\t\t\t\tTypeBinding bestArgument = leastContainingTypeArgument(bestArguments[i], parameterizedType.arguments[i], (ReferenceBinding) mec, i, lubStack);", "-\t\t\t\t\tbestArguments[j] = bestArgument;", "+\t\t\t\t\tbestArguments[i] = bestArgument;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ccf8c212f0268b10069afda6cdec2e4b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java", "commitBeforeChange": "c85c898de3099d8d87b870385bc47667302c5e21", "commitAfterChange": "73c6d3ea7dc5df8e531fcab68ea3f39bbd288577", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic UnconditionalFlowInfo discardNonFieldInitializations()", "signatureAfterChange": " public UnconditionalFlowInfo discardNonFieldInitializations()", "diff": ["+ */", "+public UnconditionalFlowInfo discardNonFieldInitializations() {", "+\tint limit = this.maxFieldCount;", "+\tif (limit < BitCacheSize) {", "+\t\tlong mask = (1L << limit)-1;", "+\t\tthis.definiteInits &= mask;", "+\t\tthis.potentialInits &= mask;", "+\t\tthis.nullAssignmentStatusBit1 &= mask;", "+\t\tthis.nullAssignmentStatusBit2 &= mask;", "+\t\tthis.nullAssignmentValueBit1 &= mask;", "+\t\tthis.nullAssignmentValueBit2 &= mask;", "+\t} ", "+\t// use extra vector", "+\tif (this.extra == null) {", "+\t\treturn this; // if vector not yet allocated, then not initialized", "+\t}", "+\tint vectorIndex, length = this.extra[0].length;", "+\tif ((vectorIndex = (limit / BitCacheSize) - 1) >= length) {", "+\t\treturn this; // not enough room yet", "+\t}", "+\tif (vectorIndex >= 0) { ", "+\t\t// else we only have complete non field array items left", "+\t\tfor (int j = 0; j < extraLength; j++) {", "+\t\t\tthis.extra[j][vectorIndex] &= mask;", "+\t\t}", "+\tfor (int i = vectorIndex + 1; i < length; i++) {", "+\t\tfor (int j = 0; j < extraLength; j++) {", "+\t\t\tthis.extra[j][i] = 0;", "+\t\t}", "+\t}", "+\treturn this;", "+}", "-\tpublic UnconditionalFlowInfo discardNonFieldInitializations(){", "-\t\t", "-\t\tint limit = this.maxFieldCount;", "-\t\t", "-\t\tif (limit < BitCacheSize) {", "-\t\t\tlong mask = (1L << limit)-1;", "-\t\t\tthis.definiteInits &= mask;", "-\t\t\tthis.potentialInits &= mask;", "-\t\t\tthis.definiteNulls &= mask;", "-\t\t\tthis.definiteNonNulls &= mask;", "-\t\t\treturn this;", "-\t\t// use extra vector", "-\t\tif (extraDefiniteInits == null) {", "-\t\t\treturn this; // if vector not yet allocated, then not initialized", "-\t\tint vectorIndex, length = this.extraDefiniteInits.length;", "-\t\tif ((vectorIndex = (limit / BitCacheSize) - 1) >= length) {", "-\t\t\treturn this; // not enough room yet", "-\t\t}", "-\t\tlong mask = (1L << (limit % BitCacheSize))-1;", "-\t\tthis.extraDefiniteInits[vectorIndex] &= mask;", "-\t\tthis.extraPotentialInits[vectorIndex] &= mask;", "-\t\tthis.extraDefiniteNulls[vectorIndex] &= mask;", "-\t\tthis.extraDefiniteNonNulls[vectorIndex] &= mask;", "-\t\tfor (int i = vectorIndex+1; i < length; i++) {", "-\t\t\tthis.extraDefiniteInits[i] = 0L;", "-\t\t\tthis.extraPotentialInits[i] = 0L;", "-\t\t\tthis.extraDefiniteNulls[i] = 0L;", "-\t\t\tthis.extraDefiniteNonNulls[i] = 0L;", "-\t\t}", "-\t\treturn this;"]}], "num": 38717}