{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f6753278ce6b13f21904124d93c4d78e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0d94b585ac526492adfe52b112d766ce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "ad5754fa1c59e0d3b15a306c1fd84679555621c3", "commitAfterChange": "4915e7337ff3d3a037d50fa25171594a7d1743a5", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["+\t\t\t\tboolean removeMethod2 = true;", "+\t\t\t\t\t\tboolean removeMethod = method.returnType == null && method2.returnType != null;", "+\t\t\t\t\t\t\tremoveMethod = true;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.scope.problemReporter().duplicateMethodInType(this, methodDecl, method.areParametersEqual(method2));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (removeMethod) {", "+\t\t\t\t\t\t\tremoveMethod2 = false;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tthis.scope.problemReporter().duplicateMethodInType(this, methodDecl, method.areParametersEqual(method2));", "-\t\t\t\t\tif (isEnumSpecialMethod)", "+\t\t\t\t\tif (isEnumSpecialMethod) {", "-\t\t\t\t\telse", "+\t\t\t\t\t\tremoveMethod2 = true;", "+\t\t\t\t\t} else {", "-\t\t\t\t\tmethod2Decl.binding = null;", "-\t\t\t\t\t// do not alter original method array until resolution is over, due to reentrance (143259)", "-\t\t\t\t\tif (resolvedMethods == this.methods)", "-\t\t\t\t\t\tSystem.arraycopy(this.methods, 0, resolvedMethods = new MethodBinding[length], 0, length);", "-\t\t\t\t\tresolvedMethods[j] = null;", "-\t\t\t\t\tfailed++;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (removeMethod2) {", "+\t\t\t\t\t\tmethod2Decl.binding = null;", "+\t\t\t\t\t\t// do not alter original method array until resolution is over, due to reentrance (143259)", "+\t\t\t\t\t\tif (resolvedMethods == this.methods)", "+\t\t\t\t\t\t\tSystem.arraycopy(this.methods, 0, resolvedMethods = new MethodBinding[length], 0, length);", "+\t\t\t\t\t\tresolvedMethods[j] = null;", "+\t\t\t\t\t\tfailed++;", "+\t\t\t\t\t}", "-\t\t\tif (method.returnType == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions", "+\t\t\tif (method.returnType == null && resolvedMethods[i] != null) { // forget method with invalid return type... was kept to detect possible collisions"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "233cde874020355600c1791bfa6cd022", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java", "commitBeforeChange": "12fb3ecf388804aa7057e14bf4ec17ccc0ebc59e", "commitAfterChange": "0c07824a3373a555044221cb10d67e17d420e689", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " private void initializeKnownFileNames(String[] initialFileNames)", "signatureAfterChange": " private void initializeKnownFileNames(String[] initialFileNames)", "diff": ["+\t\tboolean globalPathMatches = false;", "+\t\t// the most nested path should be the selected one", "-\t\t\tif (this.classpaths[j] instanceof  ClasspathDirectory &&", "-\t\t\t\t\tCharOperation.prefixEquals(matchCandidate, fileName) &&", "-\t\t\t\t\t(matchingPathName == null ||", "-\t\t\t\t\t\t\tmatchCandidate.length < matchingPathName.length)) {", "-\t\t\t\tmatchingPathName = matchCandidate;", "+\t\t\tboolean currentPathMatch = false;", "+\t\t\tif (this.classpaths[j] instanceof ClasspathDirectory", "+\t\t\t\t\t&& CharOperation.prefixEquals(matchCandidate, fileName)) {", "+\t\t\t\tcurrentPathMatch = true;", "+\t\t\t\tif (matchingPathName == null) {", "+\t\t\t\t\tmatchingPathName = matchCandidate;", "+\t\t\t\t} else {", "+\t\t\t\t\tif (currentPathMatch) {", "+\t\t\t\t\t\t// we have a second source folder that matches the path of the source file", "+\t\t\t\t\t\tif (matchCandidate.length > matchingPathName.length) {", "+\t\t\t\t\t\t\t// we want to preserve the shortest possible path", "+\t\t\t\t\t\t\tmatchingPathName = matchCandidate;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// we want to preserve the shortest possible path", "+\t\t\t\t\t\tif (!globalPathMatches && matchCandidate.length < matchingPathName.length) {", "+\t\t\t\t\t\t\tmatchingPathName = matchCandidate;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (currentPathMatch) {", "+\t\t\t\t\tglobalPathMatches = true;", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35564b17e2a7d57712a21b3316f6684f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "9522bc69a2e619eb0dbea360959801b21058eccb", "commitAfterChange": "be2237b06895bb2f911a826de7df01d9e9a9ec91", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 45, "signatureBeforeChange": "  \tpublic void printTrailingComment()", "signatureAfterChange": "  \tpublic void printTrailingComment()", "diff": ["+\t\t\tboolean hasWhitespaces = false;", "+\t\t\tboolean hasComment = false;", "+\t\t\t\t\t\t\tif (hasComment) {", "+\t\t\t\t\t\t\t\tthis.printNewLine(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\thasWhitespaces = true;", "-\t\t\t\t\t\tspace(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\tif (hasWhitespaces) {", "+\t\t\t\t\t\t\tspace(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tspace(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\tif (hasWhitespaces) {", "+\t\t\t\t\t\t\tspace(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\thasComment = true;", "-\t\t\t\t\t\tspace(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\tif (hasWhitespaces) {", "+\t\t\t\t\t\t\tspace(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\thasComment = true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "470b0de4b3d7ee45ba3b7c045aa171b3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java", "commitBeforeChange": "1f16b07138a4ff3970eb777fe51b4defd3508931", "commitAfterChange": "30166c06d6dd51fd7dbca34d0d55442f8ed395c4", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": " \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["-\t\ttry {", "-\t\t\tclinitOffset = classFile.contentsOffset;", "-\t\t\tthis.generateCode(classScope, classFile, clinitOffset);", "-\t\t} catch (AbortMethod e) {", "-\t\t\t// should never occur", "-\t\t\t// the clinit referenceContext is the type declaration", "-\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod", "-\t\t\t// reset the contentsOffset to the value before generating the clinit code", "-\t\t\t// decrement the number of method info as well.", "-\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other", "-\t\t\t// cases.", "-\t\t\tif (e.compilationResult == CodeStream.RESTART_IN_WIDE_MODE) {", "-\t\t\t\t// a branch target required a goto_w, restart code gen in wide mode.", "-\t\t\t\ttry {", "+\t\tboolean restart = false;", "+\t\tdo {", "+\t\t\ttry {", "+\t\t\t\tclinitOffset = classFile.contentsOffset;", "+\t\t\t\tthis.generateCode(classScope, classFile, clinitOffset);", "+\t\t\t\trestart = false;", "+\t\t\t} catch (AbortMethod e) {", "+\t\t\t\t// should never occur", "+\t\t\t\t// the clinit referenceContext is the type declaration", "+\t\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod", "+\t\t\t\t// reset the contentsOffset to the value before generating the clinit code", "+\t\t\t\t// decrement the number of method info as well.", "+\t\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other", "+\t\t\t\t// cases.", "+\t\t\t\tif (e.compilationResult == CodeStream.RESTART_IN_WIDE_MODE) {", "+\t\t\t\t\t// a branch target required a goto_w, restart code gen in wide mode.", "+\t\t\t\t\tif (!restart) {", "+\t\t\t\t\t\tclassFile.contentsOffset = clinitOffset;", "+\t\t\t\t\t\tclassFile.methodCount--;", "+\t\t\t\t\t\tclassFile.codeStream.resetInWideMode(); // request wide mode", "+\t\t\t\t\t\t// restart method generation", "+\t\t\t\t\t\trestart = true;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tclassFile.contentsOffset = clinitOffset;", "+\t\t\t\t\t\tclassFile.methodCount--;", "+\t\t\t\t\t}", "+\t\t\t\t} else if (e.compilationResult == CodeStream.RESTART_CODE_GEN_FOR_UNUSED_LOCALS_MODE) {", "-\t\t\t\t\tclassFile.codeStream.resetInWideMode(); // request wide mode", "-\t\t\t\t\tthis.generateCode(classScope, classFile, clinitOffset);", "+\t\t\t\t\tclassFile.codeStream.resetForCodeGenUnusedLocals();", "-\t\t\t\t} catch (AbortMethod e2) {", "+\t\t\t\t\trestart = true;", "+\t\t\t\t} else {", "+\t\t\t\t\t// produce a problem method accounting for this fatal error", "+\t\t\t\t\trestart = false;", "-\t\t\t} else {", "-\t\t\t\t// produce a problem method accounting for this fatal error", "-\t\t\t\tclassFile.contentsOffset = clinitOffset;", "-\t\t\t\tclassFile.methodCount--;", "-\t\t}", "+\t\t} while (restart);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a1928cb8628cae8389607e952d739039", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java", "commitBeforeChange": "4d0bf071df00d4688845a9086931e919c0d6ab82", "commitAfterChange": "0328928ec6e943d2d976356cfda47a4325798cf6", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public static String displayString(String inputString, int indent)", "signatureAfterChange": " public static String displayString(String inputString, int indent)", "diff": ["-\tjava.util.StringTokenizer tokenizer = new java.util.StringTokenizer(inputString, \"\\n\\r\");", "+\tjava.util.StringTokenizer tokenizer = new java.util.StringTokenizer(inputString, \"\\n\\r\", true);", "+\tboolean wasACr = false;", "+\tboolean newLine = false;", "-\t\tif (count++ != 0) {", "+", "+\t\tString token = tokenizer.nextToken();", "+\t\tif (token.equals(\"\\r\")) {", "+\t\t\twasACr = true;", "+\t\t\tnewLine = true;", "+\t\t} else if (token.equals(\"\\n\")) {", "+\t\t\tif (!wasACr) { // \\r\\n --> \\n", "+\t\t\t\tnewLine = true;", "+\t\t\t}", "+\t\t}\t", "+\t\tif (newLine) {", "+\t\t\tnewLine = false;", "+\t\t\tcontinue;", "-\t\tString token = tokenizer.nextToken();", "+\t\twasACr = false;", "+\t\t\t\tcase '\\r' :", "+\t\t\t\t\ttokenBuffer.append(\"\\\\r\");", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase '\\n' :", "+\t\t\t\t\ttokenBuffer.append(\"\\\\n\");", "+\t\t\t\t\tbreak;", "-\t\t\t\tcase '\\n' :", "-\t\t\t\t\ttokenBuffer.append(\"\\\\n\");", "-\t\t\t\t\tbreak;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase '\\r' :", "-\t\t\t\t\ttokenBuffer.append(\"\\\\r\");"]}], "num": 56798}