{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fd0f541948762eeb41daf4b4daae81f0", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "25ab6125d23148a76cf009b584635609", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tboolean diamondNeedsDeferring = false;", "-\t\t\tif (isDiamond && this.typeExpected == null && this.expressionContext == INVOCATION_CONTEXT && sourceLevel >= ClassFileConstants.JDK1_8) {", "-\t\t\t\tif (this.resolvedType != null && this.resolvedType.isValidBinding())", "-\t\t\t\t\tdiamondNeedsDeferring = true;", "-\t\t\t}", "-\t} else {", "-\t\tthis.resolvedType = this.type.resolvedType;", "-\t}", "-", "-\tif (this.type != null) {", "-\t\tcheckIllegalNullAnnotation(scope, this.resolvedType);", "-\t\tcheckParameterizedAllocation: {", "-\t\t\tif (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()", "-\t\t\t\tReferenceBinding currentType = (ReferenceBinding)this.resolvedType;", "-\t\t\t\tif (currentType == null) return currentType;", "-\t\t\t\tdo {", "-\t\t\t\t\t// isStatic() is answering true for toplevel types", "-\t\t\t\t\tif ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;", "-\t\t\t\t\tif (currentType.isRawType()) break checkParameterizedAllocation;", "-\t\t\t\t} while ((currentType = currentType.enclosingType())!= null);", "-\t\t\t\tParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;", "-\t\t\t\tfor (int i = qRef.typeArguments.length - 2; i >= 0; i--) {", "-\t\t\t\t\tif (qRef.typeArguments[i] != null) {", "-\t\t\t\t\t\tscope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, this.resolvedType);", "-\t\t\t\t\t\tbreak;", "+\t\tif (this.type != null) {", "+\t\t\tcheckIllegalNullAnnotation(scope, this.resolvedType);", "+\t\t\tcheckParameterizedAllocation: {", "+\t\t\t\tif (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()", "+\t\t\t\t\tReferenceBinding currentType = (ReferenceBinding)this.resolvedType;", "+\t\t\t\t\tif (currentType == null) return currentType;", "+\t\t\t\t\tdo {", "+\t\t\t\t\t\t// isStatic() is answering true for toplevel types", "+\t\t\t\t\t\tif ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;", "+\t\t\t\t\t\tif (currentType.isRawType()) break checkParameterizedAllocation;", "+\t\t\t\t\t} while ((currentType = currentType.enclosingType())!= null);", "+\t\t\t\t\tParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;", "+\t\t\t\t\tfor (int i = qRef.typeArguments.length - 2; i >= 0; i--) {", "+\t\t\t\t\t\tif (qRef.typeArguments[i] != null) {", "+\t\t\t\t\t\t\tscope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, this.resolvedType);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "-\t}", "-\t// will check for null after args are resolved", "+\t\t// will check for null after args are resolved", "-\t// resolve type arguments (for generic constructor call)", "-\tif (this.typeArguments != null) {", "-\t\tint length = this.typeArguments.length;", "-\t\tthis.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5;", "-\t\tthis.genericTypeArguments = new TypeBinding[length];", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tTypeReference typeReference = this.typeArguments[i];", "-\t\t\tif ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "-\t\t\t\tthis.argumentsHaveErrors = true;", "-\t\t\t}", "-\t\t\tif (this.argumentsHaveErrors && typeReference instanceof Wildcard) {", "-\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "-\t\t\t}", "-\t\t}", "-\t\tif (isDiamond) {", "-\t\t\tscope.problemReporter().diamondNotWithExplicitTypeArguments(this.typeArguments);", "-\t\t\treturn null;", "-\t\t}", "-\t\tif (this.argumentsHaveErrors) {", "-\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "-\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "-\t\t\t\t\tthis.arguments[i].resolveType(scope);", "+\t\t// resolve type arguments (for generic constructor call)", "+\t\tif (this.typeArguments != null) {", "+\t\t\tint length = this.typeArguments.length;", "+\t\t\tthis.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5;", "+\t\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tTypeReference typeReference = this.typeArguments[i];", "+\t\t\t\tif ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\t\tthis.argumentsHaveErrors = true;", "+\t\t\t\t}", "+\t\t\t\tif (this.argumentsHaveErrors && typeReference instanceof Wildcard) {", "+\t\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "-\t\t\treturn null;", "+\t\t\tif (isDiamond) {", "+\t\t\t\tscope.problemReporter().diamondNotWithExplicitTypeArguments(this.typeArguments);", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t\tif (this.argumentsHaveErrors) {", "+\t\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "+\t\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t\t\tthis.arguments[i].resolveType(scope);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn null;", "+\t\t\t}", "-\t}", "-\t// buffering the arguments' types", "-\tboolean argsContainCast = false;", "-\tif (this.arguments != null) {", "-\t\tthis.argumentsHaveErrors = false;", "-\t\tint length = this.arguments.length;", "-\t\tthis.argumentTypes = new TypeBinding[length];", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tExpression argument = this.arguments[i];", "-\t\t\tif (argument instanceof CastExpression) {", "-\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\t\t\targsContainCast = true;", "+\t\t// buffering the arguments' types", "+\t\tif (this.arguments != null) {", "+\t\t\tthis.argumentsHaveErrors = false;", "+\t\t\tint length = this.arguments.length;", "+\t\t\tthis.argumentTypes = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\t\t\tthis.argsContainCast = true;", "+\t\t\t\t}", "+\t\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "+\t\t\t\tif (this.arguments[i].resolvedType != null) ", "+\t\t\t\t\tscope.problemReporter().genericInferenceError(\"Argument was unexpectedly found resolved\", this); //$NON-NLS-1$", "+\t\t\t\tif ((this.argumentTypes[i] = argument.resolveType(scope)) == null) {", "+\t\t\t\t\tthis.argumentsHaveErrors = true;", "+\t\t\t\t}", "-\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "-\t\t\tif (this.arguments[i].resolvedType != null) ", "-\t\t\t\tscope.problemReporter().genericInferenceError(\"Argument was unexpectedly found resolved\", this); //$NON-NLS-1$", "-\t\t\tif ((this.argumentTypes[i] = argument.resolveType(scope)) == null) {", "-\t\t\t\tthis.argumentsHaveErrors = true;", "-\t\t\t}", "-\t\t\tif (sourceLevel >= ClassFileConstants.JDK1_8 && (argument.isPolyExpression() || ((argument instanceof Invocation) && ((Invocation) argument).usesInference()))) {", "-\t\t\t\tif (this.innerInferenceHelper == null)", "-\t\t\t\t\tthis.innerInferenceHelper = new InnerInferenceHelper();", "-\t\t\t}", "-\t\t}", "-\t\tif (this.argumentsHaveErrors) {", "-\t\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.", "+\t\t\tif (this.argumentsHaveErrors) {", "+\t\t\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.", "-\t\t\t */", "-\t\t\tif (isDiamond) {", "-\t\t\t\treturn null; // not the partially cooked this.resolvedType", "-\t\t\t}", "-\t\t\tif (this.resolvedType instanceof ReferenceBinding) {", "-\t\t\t\t// record a best guess, for clients who need hint about possible constructor match", "-\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "-\t\t\t\tfor (int i = length; --i >= 0;) {", "-\t\t\t\t\tpseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t */", "+\t\t\t\tif (isDiamond) {", "+\t\t\t\t\treturn null; // not the partially cooked this.resolvedType", "-\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding) this.resolvedType, TypeConstants.INIT, pseudoArgs, this, false);", "-\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "-\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "-\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "-\t\t\t\t\tif (closestMatch != null) {", "-\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "-\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "-\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.binding = closestMatch;", "-\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "-\t\t\t\t\t\tif (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {", "-\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "-\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\tif (this.resolvedType instanceof ReferenceBinding) {", "+\t\t\t\t\t// record a best guess, for clients who need hint about possible constructor match", "+\t\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "+\t\t\t\t\tfor (int i = length; --i >= 0;) {", "+\t\t\t\t\t\tpseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding) this.resolvedType, TypeConstants.INIT, pseudoArgs, this, false);", "+\t\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "+\t\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "+\t\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "+\t\t\t\t\t\tif (closestMatch != null) {", "+\t\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "+\t\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "+\t\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.binding = closestMatch;", "+\t\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "+\t\t\t\t\t\t\tif (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {", "+\t\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "+\t\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t\t}", "+\t\t\t\treturn this.resolvedType;", "+\t\t}", "+\t\tif (this.resolvedType == null || !this.resolvedType.isValidBinding()) {", "+\t\t\treturn null;", "+\t\t}", "+", "+\t\t// null type denotes fake allocation for enum constant inits", "+\t\tif (this.type != null && !this.resolvedType.canBeInstantiated()) {", "+\t\t\tscope.problemReporter().cannotInstantiate(this.type, this.resolvedType);", "-\t}", "-\tif (this.resolvedType == null || !this.resolvedType.isValidBinding()) {", "-\t\treturn null;", "-\t}", "-", "-\t// null type denotes fake allocation for enum constant inits", "-\tif (this.type != null && !this.resolvedType.canBeInstantiated()) {", "-\t\tscope.problemReporter().cannotInstantiate(this.type, this.resolvedType);", "-\t\treturn this.resolvedType;", "-\t}", "-\tResolutionState state = new ResolutionState(scope, isDiamond, diamondNeedsDeferring, argsContainCast, this.argumentTypes);", "-\tif (diamondNeedsDeferring) {", "-\t\tthis.suspendedResolutionState = state; // resolving to be continued later (via binding(TypeBinding targetType)).", "-\t\treturn new PolyTypeBinding(this);", "-\t}", "-", "-\tif (!resolvePart2(state))", "-\t\treturn null;", "-\treturn resolvePart3(state);", "-}", "+\t\tif (isDiamond) {", "+\t\t\tReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();", "+\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());", "+\t\t\tif (this.typeExpected == null && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8 && this.expressionContext.definesTargetType()) {", "+\t\t\t\tthis.binding = inferConstructorOfElidedParameterizedType(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+\t\t\t\tif (this.binding == null) {", "+\t\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "+\t\t\t\t\treturn this.resolvedType = null;", "+\t\t\t\t}", "+\t\t\t\treturn new PolyTypeBinding(this);", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+\t\t\tif (inferredTypes == null) {", "+\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "+\t\t\t\treturn this.resolvedType = null;", "+\t\t\t}", "+\t\t\tReferenceBinding allocationType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t\tthis.resolvedType = this.type.resolvedType = allocationType; ", "+\t} else {", "+\t\tif (isDiamond) {", "+\t\t\tReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();", "+\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+\t\t\tif (inferredTypes == null) {", "+\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "+\t\t\t\treturn this.resolvedType = null;", "+\t\t\t}", "+\t\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t}", "+\t", "+\tthis.binding = findConstructorBinding(scope, this, allocationType, this.argumentTypes);", "+\t\t", "+\t\tscope.problemReporter().invalidConstructor(this, this.binding);", "+\t\tscope.problemReporter().missingTypeInConstructor(this, this.binding);", "+\tif (isMethodUseDeprecated(this.binding, scope, true)) {", "+\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "+\tif (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {", "+\t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);", "+\tif (!isDiamond && this.resolvedType.isParameterizedTypeWithActualArguments()) {", "+ \t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+\t\tnew ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)", "+\t\t\t\t.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);", "+\trecordExceptionsForEnclosingLambda(scope, this.binding.thrownExceptions);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f2783e91b739b9aad067c15e14b555d1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java", "commitBeforeChange": "c13b5c8fdc5b98528c9ff5d2f4f3b65852c12b48", "commitAfterChange": "08ce0253d3f5d5ff59d7d3b857a3b4f1f87c7e61", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tprivate String computeRootPath(final String fullName)", "signatureAfterChange": " \t \tprivate void computeAllRootPaths(IType type)", "diff": ["+\tprivate void computeAllRootPaths(IType type) {", "+\t\tIPackageFragmentRoot root = (IPackageFragmentRoot) type.getPackageFragment().getParent();", "+\t\tthis.rootPaths = new HashSet();", "+\t\tlong time = 0;", "+\t\tif (VERBOSE) {", "+\t\t\tSystem.out.println(\"compute all root paths for \" + root.getElementName());", "+\t\t\ttime = System.currentTimeMillis();", "+\t\t}", "+\t\tfinal HashSet firstLevelPackageNames = new HashSet();", "+\t\tboolean containsADefaultPackage = false;", "+", "+\t\tif (root.isArchive()) {", "+\t\t\tJarPackageFragmentRoot jarPackageFragmentRoot = (JarPackageFragmentRoot) root;", "+\t\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\t\t\tZipFile zip = null;", "+\t\t\ttry {", "+\t\t\t\tzip = manager.getZipFile(jarPackageFragmentRoot.getPath());", "+\t\t\t\tfor (Enumeration entries = zip.entries(); entries.hasMoreElements(); ) {", "+\t\t\t\t\tZipEntry entry = (ZipEntry) entries.nextElement();", "+\t\t\t\t\tString entryName = entry.getName();", "+\t\t\t\t\tif (!entry.isDirectory()) {", "+\t\t\t\t\t\tint index = entryName.indexOf('/');", "+\t\t\t\t\t\tif (index != -1) {", "+\t\t\t\t\t\t\tString firstLevelPackageName = entryName.substring(0, index);", "+\t\t\t\t\t\t\tif (JavaConventions.validatePackageName(firstLevelPackageName).isOK()) {", "+\t\t\t\t\t\t\t\tfirstLevelPackageNames.add(firstLevelPackageName);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (Util.isClassFileName(entryName)) {", "+\t\t\t\t\t\t\tcontainsADefaultPackage = true;", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} catch (CoreException e) {", "+\t\t\t} finally {", "+\t\t\t\tmanager.closeZipFile(zip); // handle null case", "+\t\t\t}", "+\t\t} else {", "+\t\t\tObject target = JavaModel.getTarget(ResourcesPlugin.getWorkspace().getRoot(), root.getPath(), true);", "+\t\t\tif (target instanceof IFolder) {", "+\t\t\t\tIResource resource = root.getResource();", "+\t\t\t\tif (resource.getType() == IResource.FOLDER) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tIResource[] members = ((IFolder) resource).members();", "+\t\t\t\t\t\tfor (int i = 0, max = members.length; i < max; i++) {", "+\t\t\t\t\t\t\tIResource member = members[i];", "+\t\t\t\t\t\t\tif (member.getType() == IResource.FOLDER) {", "+\t\t\t\t\t\t\t\tfirstLevelPackageNames.add(member.getName());", "+\t\t\t\t\t\t\t} else if (Util.isClassFileName(member.getName())) {", "+\t\t\t\t\t\t\t\tcontainsADefaultPackage = true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else if (target instanceof File) {", "+\t\t\t\tFile file = (File)target;", "+\t\t\t\tif (file.isDirectory()) {", "+\t\t\t\t\tFile[] files = file.listFiles();", "+\t\t\t\t\tfor (int i = 0, max = files.length; i < max; i++) {", "+\t\t\t\t\t\tFile currentFile = files[i];", "+\t\t\t\t\t\tif (currentFile.isDirectory()) {", "+\t\t\t\t\t\t\tfirstLevelPackageNames.add(currentFile.getName());", "+\t\t\t\t\t\t} else if (Util.isClassFileName(currentFile.getName())) {", "+\t\t\t\t\t\t\tcontainsADefaultPackage = true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t */", "-\tprivate String computeRootPath(final String fullName) {", "+", "-\t\t\t\tint index = Integer.MAX_VALUE;", "-\t\t\t\tString foundEntry = null;", "-\t\t\t\t\tString name;", "-\t\t\t\t\tif (!entry.isDirectory() && Util.isJavaFileName(name = entry.getName())) {", "-\t\t\t\t\t\tif (name.endsWith(fullName)) {", "-\t\t\t\t\t\t\tindex = Math.min(index, name.indexOf(fullName));", "-\t\t\t\t\t\t\tfoundEntry = name;", "+\t\t\t\t\tif (!entry.isDirectory()) {", "+\t\t\t\t\t\tIPath path = new Path(entry.getName());", "+\t\t\t\t\t\tint segmentCount = path.segmentCount();", "+\t\t\t\t\t\tif (segmentCount > 1) {", "+\t\t\t\t\t\t\tloop: for (int i = 0, max = path.segmentCount() - 1; i < max; i++) {", "+\t\t\t\t\t\t\t\tif (firstLevelPackageNames.contains(path.segment(i))) {", "+\t\t\t\t\t\t\t\t\tthis.rootPaths.add(path.uptoSegment(i).toString());", "+\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (i == max - 1 && containsADefaultPackage) {", "+\t\t\t\t\t\t\t\t\tthis.rootPaths.add(path.uptoSegment(max).toString());", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (containsADefaultPackage) {", "+\t\t\t\t\t\t\tthis.rootPaths.add(\"\"); //$NON-NLS-1$", "-\t\t\t\tif (foundEntry != null) {", "-\t\t\t\t\treturn foundEntry.substring(0, index);", "-\t\t\t\t}", "-\t\t\t\treturn null;", "-\t\t\t\treturn null;", "-\t\t\t\tIFolder folder = (IFolder)target;", "-\t\t\t\tfinal String[] rootPathHolder = new String[1];", "-\t\t\t\tfinal int[] index = new int[] { Integer.MAX_VALUE };", "-\t\t\t\ttry {", "-\t\t\t\t\tfolder.accept(", "-\t\t\t\t\t\tnew IResourceProxyVisitor() {", "-\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) throws CoreException {", "-\t\t\t\t\t\t\t\tif (proxy.getType() == IResource.FILE) {", "-\t\t\t\t\t\t\t\t\tif (Util.isJavaFileName(proxy.getName())) { ", "-\t\t\t\t\t\t\t\t\t\tIResource resource = proxy.requestResource();", "-\t\t\t\t\t\t\t\t\t\tIPath resourceFullPath = resource.getFullPath();", "-\t\t\t\t\t\t\t\t\t\tint sourcePathSegmentCount = sourcePath.segmentCount();", "-\t\t\t\t\t\t\t\t\t\tIPath javaFilePath = resourceFullPath.removeFirstSegments(sourcePathSegmentCount);", "-\t\t\t\t\t\t\t\t\t\tString javaFilePathString = javaFilePath.toString();", "-\t\t\t\t\t\t\t\t\t\tif (javaFilePathString.endsWith(fullName)) {", "-\t\t\t\t\t\t\t\t\t\t\tindex[0] = Math.min(index[0], javaFilePathString.indexOf(javaFilePathString));", "-\t\t\t\t\t\t\t\t\t\t\trootPathHolder[0] = javaFilePathString;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t},", "-\t\t\t\t\t\tIResource.NONE", "-\t\t\t\t\t);", "-\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t}", "-\t\t\t\tif (rootPathHolder[0] != null) {", "-\t\t\t\t\tif (index[0] == 0) {", "-\t\t\t\t\t\treturn \"\"; //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t\treturn rootPathHolder[0].substring(0, index[0]);", "-\t\t\t\t}", "+\t\t\t\tcomputeRootPath((IFolder)target, firstLevelPackageNames, containsADefaultPackage);", "-\t\t\t\t\tfinal String[] rootPathHolder = new String[1];", "-\t\t\t\t\tfinal int[] index = new int[] { Integer.MAX_VALUE };", "-\t\t\t\t\tcomputeRootPath(file, fullName, rootPathHolder, index);", "-\t\t\t\t\tif (rootPathHolder[0] != null) {", "-\t\t\t\t\t\tif (index[0] == 0) {", "-\t\t\t\t\t\t\treturn \"\"; //$NON-NLS-1$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn rootPathHolder[0].substring(0, index[0]);", "-\t\t\t\t\t}", "+\t\t\t\t\tcomputeRootPath(file, firstLevelPackageNames, containsADefaultPackage);", "-\t\treturn null;", "+\t\tif (VERBOSE) {", "+\t\t\tSystem.out.println(\"Found \" + this.rootPaths.size() + \" root paths\");\t\t\t", "+\t\t\tSystem.out.println(\"Spent \" + (System.currentTimeMillis() - time) + \"ms\");", "+\t\t}", "+\t\tthis.areRootPathsComputed = true;"]}], "num": 31713}