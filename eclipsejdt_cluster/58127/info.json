{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2bb0d72e5333aed95df8baf8b648ee4a", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6a18f0aeaeb4cb43a955cdfee638a290", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java", "commitBeforeChange": "dbc287e113cd966cc1e20293dfedea17687913c2", "commitAfterChange": "e66f77d0e07fce47c76186011fd33869f4e9edd9", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tpublic IJavaElement getJavaElement()", "signatureAfterChange": "  \tpublic IJavaElement getJavaElement()", "diff": ["-\t */", "-\t\tMethodDeclaration method = (MethodDeclaration) ((DefaultBindingResolver) this.resolver).bindingsToAstNodes.get(this);", "-\t\tif (method == null) return null;", "-\t\tArrayList parameterSignatures = new ArrayList();", "-\t\tIterator iterator = method.parameters().iterator();", "-\t\twhile (iterator.hasNext()) {", "-\t\t\tSingleVariableDeclaration parameter = (SingleVariableDeclaration) iterator.next();", "-\t\t\tType type = parameter.getType();", "-\t\t\tparameterSignatures.add(getSignature(type));", "+\t\tMethodDeclaration methodDeclaration = (MethodDeclaration) ((DefaultBindingResolver) this.resolver).bindingsToAstNodes.get(this);", "+\t\tif (methodDeclaration != null) {", "+\t\t\tArrayList parameterSignatures = new ArrayList();", "+\t\t\tIterator iterator = methodDeclaration.parameters().iterator();", "+\t\t\twhile (iterator.hasNext()) {", "+\t\t\t\tSingleVariableDeclaration parameter = (SingleVariableDeclaration) iterator.next();", "+\t\t\t\tType type = parameter.getType();", "+\t\t\t\tparameterSignatures.add(getSignature(type));", "+\t\t\t}", "+\t\t\tint parameterCount = parameterSignatures.size();", "+\t\t\tString[] parameters = new String[parameterCount];", "+\t\t\tparameterSignatures.toArray(parameters);", "+\t\t\treturn declaringType.getMethod(getName(), parameters);", "+\t\t} else {", "+\t\t\t// case of method not in the created AST", "+\t\t\tString selector = getName();", "+\t\t\tchar[] methodSignature = this.binding.genericSignature();", "+\t\t\tif (methodSignature == null)", "+\t\t\t\tmethodSignature = this.binding.signature();", "+\t\t\tmethodSignature = CharOperation.replaceOnCopy(methodSignature, '/', '.');", "+\t\t\tchar[][] parameterSignatures = Signature.getParameterTypes(methodSignature);", "+\t\t\tString[] parameters = CharOperation.toStrings(parameterSignatures);", "+\t\t\tIMethod result = declaringType.getMethod(selector, parameters);", "+\t\t\tif (declaringType.isBinary())", "+\t\t\t\treturn result;", "+\t\t\tIMethod[] methods = null;", "+\t\t\ttry {", "+\t\t\t\tmethods = declaringType.getMethods();", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// declaring type doesn't exist", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t\tIMethod[] candidates = Member.findMethods(result, methods);", "+\t\t\tif (candidates == null || candidates.length == 0)", "+\t\t\t\treturn null;", "+\t\t\treturn candidates[0];", "-\t\tint parameterCount = parameterSignatures.size();", "-\t\tString[] parameters = new String[parameterCount];", "-\t\tparameterSignatures.toArray(parameters);", "-\t\treturn declaringType.getMethod(getName(), parameters);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "83a2f6a83a0db8cbfe0b1ee951d7d8d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java", "commitBeforeChange": "101210a46f852f04e96181a230ef482b37a8c3d9", "commitAfterChange": "ac0d9cdc25a9d5f3107efd53c6caa6764f8731c8", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " public void removeSourceFolderFromIndex(JavaProject javaProject, IPath sourceFolder)", "signatureAfterChange": " public void removeSourceFolderFromIndex(JavaProject javaProject, IPath sourceFolder)", "diff": ["-\tthis.request(new RemoveFolderFromIndex(sourceFolder.toString(), javaProject.getProject().getFullPath(), this));", "+\t\ttry {", "+\t\t\t/* ensure no concurrent write access to index */", "+\t\t\tIPath indexPath = javaProject.getPath();", "+\t\t\tIIndex index = this.getIndex(indexPath, true, /*reuse index file*/ false /*create if none*/);", "+\t\t\tif (index == null) return;", "+\t\t\tReadWriteMonitor monitor = this.getMonitorFor(index);", "+\t\t\tif (monitor == null) return; // index got deleted since acquired", "+", "+\t\t\ttry {", "+\t\t\t\tmonitor.enterRead(); // ask permission to read", "+\t\t\t\tIQueryResult[] results = index.queryInDocumentNames(sourceFolder.toString());", "+\t\t\t\t// all file names belonging to the folder or its subfolders", "+\t\t\t\tfor (int i = 0, max = results == null ? 0 : results.length; i < max; i++)", "+\t\t\t\t\t// TODO: Should not remove excluded resources", "+\t\t\t\t\tthis.remove(results[i].getPath(), indexPath); // write lock will be acquired by the remove operation", "+\t\t\t} finally {", "+\t\t\t\tmonitor.exitRead(); // free read lock", "+\t\t\t}", "+\t\t} catch (IOException e) {", "+\t\t\tif (JobManager.VERBOSE) {", "+\t\t\t\tJobManager.verbose(\"-> failed to remove \" + sourceFolder.toString() + \" from index because of the following exception:\"); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\te.printStackTrace();", "+\t\t\t}", "+\t\t}"]}], "num": 58127}