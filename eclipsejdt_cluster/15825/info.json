{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "db4d99d05931f4e33de20eb25a0f8e97", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "06bdd71105d65b1576a3141d1ce7377c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptCompilationParticipant.java", "commitBeforeChange": "2894ba75386697d7bf484434d073fb6ffaf6cec9", "commitAfterChange": "c5ef0e6fd93c55fc5204e498f5b58ab9f95c6ab7", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t\t \tprivate CompilationParticipantResult preBuildNotify( PreBuildCompilationEvent pbce )", "signatureAfterChange": " \t \tpublic void processAnnotations(ICompilationParticipantResult[] filesWithAnnotations, boolean isBatchBuild)", "diff": ["-\t\t", "-\tprivate CompilationParticipantResult preBuildNotify( PreBuildCompilationEvent pbce )", "-\t{\t\t", "-\t\tif ( pbce == null )", "-\t\t\treturn EMPTY_PRE_BUILD_COMPILATION_RESULT;", "-", "-\t\tIFile[] buildFiles = pbce.getFiles();", "-\t\tIJavaProject javaProject = pbce.getJavaProject();", "-\t\t", "-\t\tif ( buildFiles == null || buildFiles.length == 0 )", "-\t\t\treturn EMPTY_PRE_BUILD_COMPILATION_RESULT;", "-\t\t", "+\t", "+\tpublic void processAnnotations(ICompilationParticipantResult[] filesWithAnnotations, boolean isBatchBuild) {", "+\t\tif( filesWithAnnotations == null || filesWithAnnotations.length == 0 )", "+\t\t\treturn;", "+\t\tfinal IProject project = filesWithAnnotations[0].getFile().getProject();", "+\t\tfinal IJavaProject javaProject = JavaCore.create(project);", "-\t\tString javaVersion = javaProject.getOption(\"org.eclipse.jdt.core.compiler.source\", true); //$NON-NLS-1$", "-\t\t", "+\t\tString javaVersion = javaProject.getOption(\"org.eclipse.jdt.core.compiler.source\", true); //$NON-NLS-1$\t\t", "-\t\t\treturn EMPTY_PRE_BUILD_COMPILATION_RESULT;", "+\t\t\treturn;", "-\t", "-\t\t// If we're in batch mode, we need to reset the classloaders", "-\t\t// for the batch processors before we begin", "-\t\tboolean isFullBuild = pbce.isFullBuild();", "+\t\t", "-\t\t\tif (isFullBuild && pbce.getRound() == 0) {", "-\t\t\t\tAnnotationProcessorFactoryLoader.getLoader().resetBatchProcessors(pbce.getJavaProject());", "+\t\t\tif (isBatchBuild && _buildRound == 0 ) {", "+\t\t\t\tAnnotationProcessorFactoryLoader.getLoader().resetBatchProcessors(javaProject);", "-\t\t\t", "+\t\t", "-\t\t\tAPTResult result = APTDispatch.runAPTDuringBuild(factories, _previousRoundsBatchFactories, buildFiles, javaProject, isFullBuild);", "-\t\t\tSet<IFile> newFiles = result.getNewFiles();\t\t\t", "-\t\t\tSet<IFile> deletedFiles = new HashSet<IFile>();", "-\t\t\t_previousRoundsBatchFactories.addAll(result.getDispatchedBatchFactory());", "-\t\t\t", "-\t\t\t// for apt, new files will always trump deleted files", "-\t\t\tfor ( IFile df : result.getDeletedFiles() ){", "-\t\t\t\tif ( !newFiles.contains( df ) ){", "-\t\t\t\t\tdeletedFiles.add(df);", "-\t\t\t\t}", "-\t\t\t}", "-\t", "-\t\t\treturn new PreBuildCompilationResult( ", "-\t\t\t\t\tnewFiles.toArray( new IFile[ newFiles.size() ] ), ", "-\t\t\t\t\tdeletedFiles.toArray( new IFile[ deletedFiles.size() ] ), ", "-\t\t\t\t\tresult.getNewDependencies(), ", "-\t\t\t\t\tresult.getProblems());", "+\t\t\tAptProject aptProject = AptPlugin.getAptProject(javaProject);", "+\t\t\tSet<AnnotationProcessorFactory> dispatchedBatchFactories = ", "+\t\t\t\tAPTDispatchRunnable.runAPTDuringBuild(filesWithAnnotations, aptProject, factories, _previousRoundsBatchFactories, isBatchBuild);", "+\t\t\t_previousRoundsBatchFactories.addAll(dispatchedBatchFactories);", "-\t\t\tif (isFullBuild) {", "+\t\t\tif (isBatchBuild) {", "+\t\t\t_buildRound ++;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "28d7983c5f15aafed93a26397eb0fc57", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptCompilationParticipant.java", "commitBeforeChange": "bfcd45867d04fefcde8c411b2c4f613fed962f2b", "commitAfterChange": "8360857ac96415dcd60ac94fbc284e7801424ade", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t \tpublic void processAnnotations(ICompilationParticipantResult[] filesWithAnnotations, boolean isBatchBuild)", "signatureAfterChange": " \t \tpublic void processAnnotations(ICompilationParticipantResult[] allfiles)", "diff": ["-\tpublic void processAnnotations(ICompilationParticipantResult[] filesWithAnnotations, boolean isBatchBuild) {", "-\t\tif( filesWithAnnotations == null || filesWithAnnotations.length == 0 )", "+\t", "+\tpublic void processAnnotations(ICompilationParticipantResult[] allfiles) {\t", "+\t\t// This should not happen. There should always be file that that needs ", "+\t\t// building when ", "+\t\tfinal int total = allfiles == null ? 0 : allfiles.length;", "+\t\tif( total == 0 )", "-\t\tfinal IProject project = filesWithAnnotations[0].getFile().getProject();", "+", "+\t\tfinal IProject project = allfiles[0].getFile().getProject();", "-\t\t}\t\t\t", "+\t\t}", "+\t\t", "+\t\tif ( _isBatch && _buildRound == 0 ) {", "+\t\t\tAnnotationProcessorFactoryLoader.getLoader().resetBatchProcessors(javaProject);", "+\t\t\t_previousRoundsBatchFactories.clear();", "+\t\t}", "-\t\t\tif (isBatchBuild && _buildRound == 0 ) {", "-\t\t\t\tAnnotationProcessorFactoryLoader.getLoader().resetBatchProcessors(javaProject);", "-\t\t\t\t_previousRoundsBatchFactories.clear();", "+\t\t", "+\t\t\t// split up the list of files with annotations from those that don't", "+\t\t\t// also exclude files that has already been processed.", "+\t\t\tint annoFileCount = 0;", "+\t\t\tint noAnnoFileCount = 0;", "+\t\t\tfor( int i=0; i<total; i++ ){", "+\t\t\t\tif( _buildRound > 0 && _processedFiles.contains( allfiles[i].getFile() )){", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tif( allfiles[i].hasAnnotations() )", "+\t\t\t\t\tannoFileCount ++;", "+\t\t\t\telse", "+\t\t\t\t\tnoAnnoFileCount ++;", "+\t\t\t// apt has already processed all files", "+\t\t\t// files that are reported at this point is triggered by", "+\t\t\t// dependencies introduced by type creation. ", "+\t\t\tif( annoFileCount == 0 && noAnnoFileCount == 0 )", "+\t\t\t\treturn;", "+\t\t\t", "+\t\t\tICompilationParticipantResult[] withAnnotation = null;", "+\t\t\tICompilationParticipantResult[] withoutAnnotation = null;", "+\t\t\t", "+\t\t\tif( annoFileCount != 0 )", "+\t\t\t\twithAnnotation = new ICompilationParticipantResult[annoFileCount];", "+\t\t\tif(noAnnoFileCount != 0 )", "+\t\t\t\twithoutAnnotation = new ICompilationParticipantResult[noAnnoFileCount];", "+\t\t\tint wIndex = 0; // index for 'withAnnotation' array", "+\t\t\tint woIndex = 0; // index of 'withoutAnnotation' array", "+\t\t\tfor( int i=0; i<total; i++ ){\t\t", "+\t\t\t\tif( _processedFiles.contains( allfiles[i].getFile() ) )", "+\t\t\t\t\tcontinue;", "+\t\t\t\tif( allfiles[i].hasAnnotations() )", "+\t\t\t\t\twithAnnotation[wIndex ++] = allfiles[i];", "+\t\t\t\telse", "+\t\t\t\t\twithoutAnnotation[woIndex ++] = allfiles[i];", "+\t\t\t}", "+\t\t\t", "+\t\t\tfor( ICompilationParticipantResult file : allfiles )", "+\t\t\t\t_processedFiles.add(file.getFile());", "-\t\t\tAptProject aptProject = AptPlugin.getAptProject(javaProject);", "+\t\t\tAptProject aptProject = AptPlugin.getAptProject(javaProject);\t\t\t", "-\t\t\t\tAPTDispatchRunnable.runAPTDuringBuild(filesWithAnnotations, aptProject, factories, _previousRoundsBatchFactories, isBatchBuild);", "+\t\t\t\tAPTDispatchRunnable.runAPTDuringBuild(", "+\t\t\t\t\t\twithAnnotation, ", "+\t\t\t\t\t\twithoutAnnotation,", "+\t\t\t\t\t\taptProject, ", "+\t\t\t\t\t\tfactories, ", "+\t\t\t\t\t\t_previousRoundsBatchFactories, ", "+\t\t\t\t\t\t_isBatch);", "-\t\t\tif (isBatchBuild) {", "+\t\t\tif (_isBatch) {"]}], "num": 15825}