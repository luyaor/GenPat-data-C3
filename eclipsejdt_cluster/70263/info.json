{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1e31883b7158c8cbd46e926fbf7b0c88", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ba1e9bc62119e10653367aa16d06c59", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "bc36c6c80fea8051d7058a5b477375cffbc00908", "commitAfterChange": "6f60569d194de3bca836674a443f538feb4384aa", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tpublic void complete(ICompilationUnit sourceUnit, int completionPosition, int pos)", "signatureAfterChange": " \tpublic void complete(ICompilationUnit sourceUnit, int completionPosition, int pos)", "diff": ["-\t\t\t\t\tfindPackages((CompletionOnPackageReference) parsedUnit.currentPackage);", "+\t\t\t\t\tif(!this.requestor.isIgnored(CompletionProposal.PACKAGE_REF)) {", "+\t\t\t\t\t\tfindPackages((CompletionOnPackageReference) parsedUnit.currentPackage);", "+\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tthis.findImportsOfMemberTypes(lastToken, ref);", "-\t\t\t\t\t\t\t\t\t\tthis.findImportsOfStaticFields(lastToken, ref);", "-\t\t\t\t\t\t\t\t\t\tthis.findImportsOfStaticMethdods(lastToken, ref);", "+\t\t\t\t\t\t\t\t\t\tif(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.findImportsOfMemberTypes(lastToken, ref);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tif(!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.findImportsOfStaticFields(lastToken, ref);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tif(!this.requestor.isIgnored(CompletionProposal.METHOD_NAME_REFERENCE)) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.findImportsOfStaticMethdods(lastToken, ref);", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tsetSourceRange(importReference.sourceStart, importReference.sourceEnd);", "-\t\t\t\t\t\t\tCompletionOnKeyword keyword = (CompletionOnKeyword)importReference;", "-\t\t\t\t\t\t\tfindKeywords(keyword.getToken(), keyword.getPossibleKeywords());", "+\t\t\t\t\t\t\tif(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {", "+\t\t\t\t\t\t\t\tsetSourceRange(importReference.sourceStart, importReference.sourceEnd);", "+\t\t\t\t\t\t\t\tCompletionOnKeyword keyword = (CompletionOnKeyword)importReference;", "+\t\t\t\t\t\t\t\tfindKeywords(keyword.getToken(), keyword.getPossibleKeywords());", "+\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c5a009b7150295b733a842e0c35fddf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "8c67d56825136ce0d7026162576ad6997e930bdc", "commitAfterChange": "0b88f9a0bb1950edae0865a8658608a49edfc445", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope)", "signatureAfterChange": " public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope)", "diff": ["-\tif (isPublic()) return true;", "+\tif (this.declaringClass.isInterface() && isStatic()) {", "+\t\t// Static interface methods can be explicitly invoked only through the type reference of the declaring interface or implicitly in the interface itself.", "+\t\tif (scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8 || !(invocationSite instanceof MessageSend))", "+\t\t\treturn false;", "+\t\tMessageSend messageSend = (MessageSend) invocationSite;", "+\t\tif (messageSend.isTypeAccess() && receiverType == this.declaringClass)", "+\t\t\treturn true;", "+\t\tif (messageSend.receiver.isImplicitThis() && invocationType == this.declaringClass)", "+\t\t\treturn true;", "+\t\treturn false;", "+\t}", "+\t", "+\tif (isPublic()) return true;", "+\t", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e1c9bb22a43d8bec53886106cac63a7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "bc36c6c80fea8051d7058a5b477375cffbc00908", "commitAfterChange": "6f60569d194de3bca836674a443f538feb4384aa", "methodNumberBeforeChange": 67, "methodNumberAfterChange": 67, "signatureBeforeChange": " \tprivate void findVariablesAndMethods( \t\tchar[] token, \t\tScope scope, \t\tInvocationSite invocationSite, \t\tScope invocationScope)", "signatureAfterChange": " \tprivate void findVariablesAndMethods( \t\tchar[] token, \t\tScope scope, \t\tInvocationSite invocationSite, \t\tScope invocationScope)", "diff": ["-\t\tdone1 : while (true) { // done when a COMPILATION_UNIT_SCOPE is found", "-", "-\t\t\tswitch (currentScope.kind) {", "-", "-\t\t\t\tcase Scope.METHOD_SCOPE :", "-\t\t\t\t\t// handle the error case inside an explicit constructor call (see MethodScope>>findField)", "-\t\t\t\t\tMethodScope methodScope = (MethodScope) currentScope;", "-\t\t\t\t\tstaticsOnly |= methodScope.isStatic | methodScope.isConstructorCall;", "-", "-\t\t\t\tcase Scope.BLOCK_SCOPE :", "-\t\t\t\t\tBlockScope blockScope = (BlockScope) currentScope;", "-", "-\t\t\t\t\tnext : for (int i = 0, length = blockScope.locals.length; i < length; i++) {", "-\t\t\t\t\t\tLocalVariableBinding local = blockScope.locals[i];", "-", "-\t\t\t\t\t\tif (local == null)", "-\t\t\t\t\t\t\tbreak next;", "-", "-\t\t\t\t\t\tif (tokenLength > local.name.length)", "-\t\t\t\t\t\t\tcontinue next;", "-", "-\t\t\t\t\t\tif (!CharOperation.prefixEquals(token, local.name, false /* ignore case */", "-\t\t\t\t\t\t\t))", "-\t\t\t\t\t\t\tcontinue next;", "-", "-\t\t\t\t\t\tif (local.isSecret())", "-\t\t\t\t\t\t\tcontinue next;", "-", "-\t\t\t\t\t\tfor (int f = 0; f < localsFound.size; f++) {", "-\t\t\t\t\t\t\tLocalVariableBinding otherLocal =", "-\t\t\t\t\t\t\t\t(LocalVariableBinding) localsFound.elementAt(f);", "-\t\t\t\t\t\t\tif (CharOperation.equals(otherLocal.name, local.name, true))", "+\t\tif (!this.requestor.isIgnored(CompletionProposal.LOCAL_VARIABLE_REF)) {", "+\t\t\tdone1 : while (true) { // done when a COMPILATION_UNIT_SCOPE is found", "+\t", "+\t\t\t\tswitch (currentScope.kind) {", "+\t", "+\t\t\t\t\tcase Scope.METHOD_SCOPE :", "+\t\t\t\t\t\t// handle the error case inside an explicit constructor call (see MethodScope>>findField)", "+\t\t\t\t\t\tMethodScope methodScope = (MethodScope) currentScope;", "+\t\t\t\t\t\tstaticsOnly |= methodScope.isStatic | methodScope.isConstructorCall;", "+\t", "+\t\t\t\t\tcase Scope.BLOCK_SCOPE :", "+\t\t\t\t\t\tBlockScope blockScope = (BlockScope) currentScope;", "+\t", "+\t\t\t\t\t\tnext : for (int i = 0, length = blockScope.locals.length; i < length; i++) {", "+\t\t\t\t\t\t\tLocalVariableBinding local = blockScope.locals[i];", "+\t", "+\t\t\t\t\t\t\tif (local == null)", "+\t\t\t\t\t\t\t\tbreak next;", "+\t", "+\t\t\t\t\t\t\tif (tokenLength > local.name.length)", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tlocalsFound.add(local);", "-", "-\t\t\t\t\t\tint relevance = computeBaseRelevance();", "-\t\t\t\t\t\trelevance += computeRelevanceForInterestingProposal(local);", "-\t\t\t\t\t\trelevance += computeRelevanceForCaseMatching(token, local.name);", "-\t\t\t\t\t\trelevance += computeRelevanceForExpectingType(local.type);", "-\t\t\t\t\t\trelevance += computeRelevanceForQualification(false);", "-\t\t\t\t\t\trelevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for local variable", "-\t\t\t\t\t\tthis.noProposal = false;", "-\t\t\t\t\t\tif(!this.requestor.isIgnored(CompletionProposal.LOCAL_VARIABLE_REF)) {", "-\t\t\t\t\t\t\tCompletionProposal proposal = this.createProposal(CompletionProposal.LOCAL_VARIABLE_REF, this.actualCompletionPosition);", "-\t\t\t\t\t\t\tproposal.setSignature(", "-\t\t\t\t\t\t\t\tlocal.type == null", "-\t\t\t\t\t\t\t\t? createTypeSignature(", "-\t\t\t\t\t\t\t\t\t\tCharOperation.NO_CHAR,", "-\t\t\t\t\t\t\t\t\t\tlocal.declaration.type.toString().toCharArray())", "-\t\t\t\t\t\t\t\t: getSignature(local.type));", "-\t\t\t\t\t\t\tif(local.type == null) {", "-\t\t\t\t\t\t\t\t//proposal.setPackageName(null);", "-\t\t\t\t\t\t\t\tproposal.setTypeName(local.declaration.type.toString().toCharArray());", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tproposal.setPackageName(local.type.qualifiedPackageName());", "-\t\t\t\t\t\t\t\tproposal.setTypeName(local.type.qualifiedSourceName());", "+\t", "+\t\t\t\t\t\t\tif (!CharOperation.prefixEquals(token, local.name, false /* ignore case */", "+\t\t\t\t\t\t\t\t))", "+\t\t\t\t\t\t\t\tcontinue next;", "+\t", "+\t\t\t\t\t\t\tif (local.isSecret())", "+\t\t\t\t\t\t\t\tcontinue next;", "+\t", "+\t\t\t\t\t\t\tfor (int f = 0; f < localsFound.size; f++) {", "+\t\t\t\t\t\t\t\tLocalVariableBinding otherLocal =", "+\t\t\t\t\t\t\t\t\t(LocalVariableBinding) localsFound.elementAt(f);", "+\t\t\t\t\t\t\t\tif (CharOperation.equals(otherLocal.name, local.name, true))", "+\t\t\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t\tproposal.setName(local.name);", "-\t\t\t\t\t\t\tproposal.setCompletion(local.name);", "-\t\t\t\t\t\t\tproposal.setFlags(local.modifiers);", "-\t\t\t\t\t\t\tproposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);", "-\t\t\t\t\t\t\tproposal.setRelevance(relevance);", "-\t\t\t\t\t\t\tthis.requestor.accept(proposal);", "-\t\t\t\t\t\t\tif(DEBUG) {", "-\t\t\t\t\t\t\t\tthis.printDebug(proposal);", "+\t\t\t\t\t\t\tlocalsFound.add(local);", "+\t", "+\t\t\t\t\t\t\tint relevance = computeBaseRelevance();", "+\t\t\t\t\t\t\trelevance += computeRelevanceForInterestingProposal(local);", "+\t\t\t\t\t\t\trelevance += computeRelevanceForCaseMatching(token, local.name);", "+\t\t\t\t\t\t\trelevance += computeRelevanceForExpectingType(local.type);", "+\t\t\t\t\t\t\trelevance += computeRelevanceForQualification(false);", "+\t\t\t\t\t\t\trelevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for local variable", "+\t\t\t\t\t\t\tthis.noProposal = false;", "+\t\t\t\t\t\t\tif(!this.requestor.isIgnored(CompletionProposal.LOCAL_VARIABLE_REF)) {", "+\t\t\t\t\t\t\t\tCompletionProposal proposal = this.createProposal(CompletionProposal.LOCAL_VARIABLE_REF, this.actualCompletionPosition);", "+\t\t\t\t\t\t\t\tproposal.setSignature(", "+\t\t\t\t\t\t\t\t\tlocal.type == null", "+\t\t\t\t\t\t\t\t\t? createTypeSignature(", "+\t\t\t\t\t\t\t\t\t\t\tCharOperation.NO_CHAR,", "+\t\t\t\t\t\t\t\t\t\t\tlocal.declaration.type.toString().toCharArray())", "+\t\t\t\t\t\t\t\t\t: getSignature(local.type));", "+\t\t\t\t\t\t\t\tif(local.type == null) {", "+\t\t\t\t\t\t\t\t\t//proposal.setPackageName(null);", "+\t\t\t\t\t\t\t\t\tproposal.setTypeName(local.declaration.type.toString().toCharArray());", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tproposal.setPackageName(local.type.qualifiedPackageName());", "+\t\t\t\t\t\t\t\t\tproposal.setTypeName(local.type.qualifiedSourceName());", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tproposal.setName(local.name);", "+\t\t\t\t\t\t\t\tproposal.setCompletion(local.name);", "+\t\t\t\t\t\t\t\tproposal.setFlags(local.modifiers);", "+\t\t\t\t\t\t\t\tproposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);", "+\t\t\t\t\t\t\t\tproposal.setRelevance(relevance);", "+\t\t\t\t\t\t\t\tthis.requestor.accept(proposal);", "+\t\t\t\t\t\t\t\tif(DEBUG) {", "+\t\t\t\t\t\t\t\t\tthis.printDebug(proposal);", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-", "-\t\t\t\tcase Scope.COMPILATION_UNIT_SCOPE :", "-\t\t\t\t\tbreak done1;", "+\t\t\t\t\t\tbreak;", "+\t", "+\t\t\t\t\tcase Scope.COMPILATION_UNIT_SCOPE :", "+\t\t\t\t\t\tbreak done1;", "+\t\t\t\t}", "+\t\t\t\tcurrentScope = currentScope.parent;", "-\t\t\tcurrentScope = currentScope.parent;", "-", "+\t\t", "+\t\tboolean proposeField = !this.requestor.isIgnored(CompletionProposal.FIELD_REF);", "+\t\tboolean proposeMethod = !this.requestor.isIgnored(CompletionProposal.METHOD_REF);", "+\t\t", "-\t\tdone2 : while (true) { // done when a COMPILATION_UNIT_SCOPE is found", "-", "-\t\t\tswitch (currentScope.kind) {", "-\t\t\t\tcase Scope.METHOD_SCOPE :", "-\t\t\t\t\t// handle the error case inside an explicit constructor call (see MethodScope>>findField)", "-\t\t\t\t\tMethodScope methodScope = (MethodScope) currentScope;", "-\t\t\t\t\tstaticsOnly |= methodScope.isStatic | methodScope.isConstructorCall;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase Scope.CLASS_SCOPE :", "-\t\t\t\t\tClassScope classScope = (ClassScope) currentScope;", "-\t\t\t\t\tSourceTypeBinding enclosingType = classScope.referenceContext.binding;", "-\t\t\t\t\t/*\t\t\t\tif (tokenLength == 0) { // only search inside the type itself if no prefix was provided", "-\t\t\t\t\t\t\t\t\t\tfindFields(token, enclosingType.fields(), classScope, fieldsFound, staticsOnly);", "-\t\t\t\t\t\t\t\t\t\tfindMethods(token, enclosingType.methods(), classScope, methodsFound, staticsOnly, false);", "-\t\t\t\t\t\t\t\t\t\tbreak done;", "-\t\t\t\t\t\t\t\t\t} else { */", "-\t\t\t\t\tfindFields(", "-\t\t\t\t\t\ttoken,", "-\t\t\t\t\t\tenclosingType,", "-\t\t\t\t\t\tclassScope,", "-\t\t\t\t\t\tfieldsFound,", "-\t\t\t\t\t\tlocalsFound,", "-\t\t\t\t\t\tstaticsOnly,", "-\t\t\t\t\t\tinvocationSite,", "-\t\t\t\t\t\tinvocationScope,", "-\t\t\t\t\t\ttrue,", "-\t\t\t\t\t\ttrue);", "-", "-\t\t\t\t\tfindMethods(", "-\t\t\t\t\t\ttoken,", "-\t\t\t\t\t\tnull,", "-\t\t\t\t\t\tenclosingType,", "-\t\t\t\t\t\tclassScope,", "-\t\t\t\t\t\tmethodsFound,", "-\t\t\t\t\t\tstaticsOnly,", "-\t\t\t\t\t\tfalse,", "-\t\t\t\t\t\tfalse,", "-\t\t\t\t\t\tinvocationSite,", "-\t\t\t\t\t\tinvocationScope,", "-\t\t\t\t\t\ttrue,", "-\t\t\t\t\t\tfalse,", "-\t\t\t\t\t\ttrue);", "-\t\t\t\t\tstaticsOnly |= enclosingType.isStatic();", "-\t\t\t\t\t//\t\t\t\t}", "-\t\t\t\t\tbreak;", "-", "-\t\t\t\tcase Scope.COMPILATION_UNIT_SCOPE :", "-\t\t\t\t\tbreak done2;", "-\t\t\t}", "-\t\t\tcurrentScope = currentScope.parent;", "-\t\t}", "-\t\t", "-\t\tImportBinding[] importBindings = scope.compilationUnitScope().imports;", "-\t\tfor (int i = 0; i < importBindings.length; i++) {", "-\t\t\tImportBinding importBinding = importBindings[i];", "-\t\t\tif(importBinding.isValidBinding() && importBinding.isStatic()) {", "-\t\t\t\tBinding binding = importBinding.resolvedImport;", "-\t\t\t\tif(binding != null && binding.isValidBinding()) {", "-\t\t\t\t\tif(importBinding.onDemand) {", "-\t\t\t\t\t\tif((binding.kind() & Binding.TYPE) != 0) {", "+\t\tif(proposeField || proposeMethod) {", "+\t\t\tdone2 : while (true) { // done when a COMPILATION_UNIT_SCOPE is found", "+\t", "+\t\t\t\tswitch (currentScope.kind) {", "+\t\t\t\t\tcase Scope.METHOD_SCOPE :", "+\t\t\t\t\t\t// handle the error case inside an explicit constructor call (see MethodScope>>findField)", "+\t\t\t\t\t\tMethodScope methodScope = (MethodScope) currentScope;", "+\t\t\t\t\t\tstaticsOnly |= methodScope.isStatic | methodScope.isConstructorCall;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Scope.CLASS_SCOPE :", "+\t\t\t\t\t\tClassScope classScope = (ClassScope) currentScope;", "+\t\t\t\t\t\tSourceTypeBinding enclosingType = classScope.referenceContext.binding;", "+\t\t\t\t\t\t/*\t\t\t\tif (tokenLength == 0) { // only search inside the type itself if no prefix was provided", "+\t\t\t\t\t\t\t\t\t\t\tfindFields(token, enclosingType.fields(), classScope, fieldsFound, staticsOnly);", "+\t\t\t\t\t\t\t\t\t\t\tfindMethods(token, enclosingType.methods(), classScope, methodsFound, staticsOnly, false);", "+\t\t\t\t\t\t\t\t\t\t\tbreak done;", "+\t\t\t\t\t\t\t\t\t\t} else { */", "+\t\t\t\t\t\tif(proposeField) {", "-\t\t\t\t\t\t\t\t(ReferenceBinding)binding,", "-\t\t\t\t\t\t\t\tscope,", "+\t\t\t\t\t\t\t\tenclosingType,", "+\t\t\t\t\t\t\t\tclassScope,", "-\t\t\t\t\t\t\t\ttrue,", "+\t\t\t\t\t\t\t\tstaticsOnly,", "-\t\t\t\t\t\t\t\tfalse);", "-\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\ttrue);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif(proposeMethod) {", "-\t\t\t\t\t\t\t\t(ReferenceBinding)binding,", "-\t\t\t\t\t\t\t\tscope,", "+\t\t\t\t\t\t\t\tenclosingType,", "+\t\t\t\t\t\t\t\tclassScope,", "-\t\t\t\t\t\t\t\ttrue,", "+\t\t\t\t\t\t\t\tstaticsOnly,", "-\t\t\t\t\t\t\t\tfalse);", "+\t\t\t\t\t\t\t\ttrue);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif ((binding.kind() & Binding.FIELD) != 0) {", "-\t\t\t\t\t\t\t\tfindFields(", "+\t\t\t\t\t\tstaticsOnly |= enclosingType.isStatic();", "+\t\t\t\t\t\t//\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t", "+\t\t\t\t\tcase Scope.COMPILATION_UNIT_SCOPE :", "+\t\t\t\t\t\tbreak done2;", "+\t\t\t\t}", "+\t\t\t\tcurrentScope = currentScope.parent;", "+\t\t\t}", "+\t\t\t", "+\t\t\tImportBinding[] importBindings = scope.compilationUnitScope().imports;", "+\t\t\tfor (int i = 0; i < importBindings.length; i++) {", "+\t\t\t\tImportBinding importBinding = importBindings[i];", "+\t\t\t\tif(importBinding.isValidBinding() && importBinding.isStatic()) {", "+\t\t\t\t\tBinding binding = importBinding.resolvedImport;", "+\t\t\t\t\tif(binding != null && binding.isValidBinding()) {", "+\t\t\t\t\t\tif(importBinding.onDemand) {", "+\t\t\t\t\t\t\tif((binding.kind() & Binding.TYPE) != 0) {", "+\t\t\t\t\t\t\t\tif(proposeField) {", "+\t\t\t\t\t\t\t\t\tfindFields(", "-\t\t\t\t\t\t\t\t\t\tnew FieldBinding[]{(FieldBinding)binding},", "+\t\t\t\t\t\t\t\t\t\t(ReferenceBinding)binding,", "-\t\t\t\t\t\t\t\t\t\t((FieldBinding)binding).declaringClass,", "-\t\t\t\t\t\t} else if ((binding.kind() & Binding.METHOD) != 0) {", "-\t\t\t\t\t\t\t\tMethodBinding methodBinding = (MethodBinding)binding;", "-\t\t\t\t\t\t\t\tif(CharOperation.prefixEquals(token, methodBinding.selector))", "-\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tfindLocalMethodsOfStaticImports(", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.declaringClass.methods(),", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif(proposeMethod) {", "+\t\t\t\t\t\t\t\t\tfindMethods(", "+\t\t\t\t\t\t\t\t\t\ttoken,", "+\t\t\t\t\t\t\t\t\t\tnull,", "+\t\t\t\t\t\t\t\t\t\t(ReferenceBinding)binding,", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\t\tinvocationSite);", "+\t\t\t\t\t\t\t\t\t\tmethodsFound,", "+\t\t\t\t\t\t\t\t\t\ttrue,", "+\t\t\t\t\t\t\t\t\t\tfalse,", "+\t\t\t\t\t\t\t\t\t\tfalse,", "+\t\t\t\t\t\t\t\t\t\tinvocationSite,", "+\t\t\t\t\t\t\t\t\t\tinvocationScope,", "+\t\t\t\t\t\t\t\t\t\ttrue,", "+\t\t\t\t\t\t\t\t\t\tfalse,", "+\t\t\t\t\t\t\t\t\t\tfalse);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif ((binding.kind() & Binding.FIELD) != 0) {", "+\t\t\t\t\t\t\t\tif(proposeField) {", "+\t\t\t\t\t\t\t\t\t\tfindFields(", "+\t\t\t\t\t\t\t\t\t\t\t\ttoken,", "+\t\t\t\t\t\t\t\t\t\t\t\tnew FieldBinding[]{(FieldBinding)binding},", "+\t\t\t\t\t\t\t\t\t\t\t\tscope,", "+\t\t\t\t\t\t\t\t\t\t\t\tfieldsFound,", "+\t\t\t\t\t\t\t\t\t\t\t\tlocalsFound,", "+\t\t\t\t\t\t\t\t\t\t\t\ttrue,", "+\t\t\t\t\t\t\t\t\t\t\t\t((FieldBinding)binding).declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite,", "+\t\t\t\t\t\t\t\t\t\t\t\tinvocationScope,", "+\t\t\t\t\t\t\t\t\t\t\t\ttrue,", "+\t\t\t\t\t\t\t\t\t\t\t\tfalse);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if ((binding.kind() & Binding.METHOD) != 0) {", "+\t\t\t\t\t\t\t\tif(proposeMethod) {", "+\t\t\t\t\t\t\t\t\tMethodBinding methodBinding = (MethodBinding)binding;", "+\t\t\t\t\t\t\t\t\tif(CharOperation.prefixEquals(token, methodBinding.selector))", "+\t\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tfindLocalMethodsOfStaticImports(", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.declaringClass.methods(),", "+\t\t\t\t\t\t\t\t\t\t\tscope,", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cfbbac24c092ff72b5c337ec0fed35d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "bed3ca2531a0bd15601237e5d1a0c8400e43f29e", "commitAfterChange": "cf4403abeadc8dee9dfef541af716a8f200a1ee1", "methodNumberBeforeChange": 108, "methodNumberAfterChange": 108, "signatureBeforeChange": " protected void validateOptions(boolean didSpecifyCompliance) throws InvalidInputException", "signatureAfterChange": " protected void validateOptions(boolean didSpecifyCompliance) throws InvalidInputException", "diff": ["+\t\t} else if (CompilerOptions.VERSION_CLDC1_1.equals(targetVersion)) {", "+\t\t\tif (this.didSpecifySource && CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_4) {", "+\t\t\t\tthrow new InvalidInputException(this.bind(\"configure.incompatibleSourceForCldcTarget\", (String) targetVersion, (String) sourceVersion)); //$NON-NLS-1$", "+\t\t\t}", "+\t\t\tif (CompilerOptions.versionToJdkLevel(compliance) >= ClassFileConstants.JDK1_5) {", "+\t\t\t\tthrow new InvalidInputException(this.bind(\"configure.incompatibleComplianceForCldcTarget\", (String) targetVersion, (String) sourceVersion)); //$NON-NLS-1$", "+\t\t\t}"]}], "num": 70263}