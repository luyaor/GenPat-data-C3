{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1a81aa281bc1a5cccb1428d7bfe1053a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "43f9814eac0a19f066d3f0405c811e6c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java", "commitBeforeChange": "5a3a5f398a8971568181868be2d5d76728016763", "commitAfterChange": "44cc03459f9020b4da0ebdb14fa0624b7d8dfc4d", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 20, "signatureBeforeChange": "  public void resolve(IGenericType suppliedType)", "signatureAfterChange": "  public void resolve(IGenericType suppliedType)", "diff": ["+public void resolve(IGenericType suppliedType) {", "+\ttry {", "+\t\tif (suppliedType.isBinaryType()) {", "+\t\t\tremember(suppliedType, this.lookupEnvironment.cacheBinaryType((IBinaryType) suppliedType));", "+\t\t} else {", "+\t\t\t// must start with the top level type", "+\t\t\tISourceType topLevelType = (ISourceType) suppliedType;", "+\t\t\twhile (topLevelType.getEnclosingType() != null)", "+\t\t\t\ttopLevelType = topLevelType.getEnclosingType();", "+\t\t\tCompilationResult result = new CompilationResult(topLevelType.getFileName(), 1, 1, this.options.maxProblemsPerUnit);", "+\t\t\tCompilationUnitDeclaration unit =", "+\t\t\t\tSourceTypeConverter.buildCompilationUnit(", "+\t\t\t\t\tnew ISourceType[]{topLevelType}, ", "+\t\t\t\t\tfalse, // no need for field and methods", "+\t\t\t\t\ttrue, // need member types", "+\t\t\t\t\tfalse, // no need for field initialization", "+\t\t\t\t\tthis.lookupEnvironment.problemReporter, ", "+\t\t\t\t\tresult);", "+", "+\t\t\tif (unit != null) {", "+\t\t\t\tthis.lookupEnvironment.buildTypeBindings(unit);", "+\t\t\t\trememberWithMemberTypes(topLevelType, unit.types[0].binding);", "+", "+\t\t\t\tthis.lookupEnvironment.completeTypeBindings(unit, false);", "+\t\t\t}", "+\t\t}", "+\t\treportHierarchy();", "+\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object", "+\t} finally {", "+\t\treset();", "+\t}", "-public void resolve(IGenericType suppliedType) {", "-\ttry {", "-\t\tif (suppliedType.isBinaryType()) {", "-\t\t\tremember(suppliedType, lookupEnvironment.cacheBinaryType((IBinaryType) suppliedType));", "-\t\t} else {", "-\t\t\t// must start with the top level type", "-\t\t\tISourceType topLevelType = (ISourceType) suppliedType;", "-\t\t\twhile (topLevelType.getEnclosingType() != null)", "-\t\t\t\ttopLevelType = topLevelType.getEnclosingType();", "-\t\t\tCompilationResult result = new CompilationResult(topLevelType.getFileName(), 1, 1, this.options.maxProblemsPerUnit);", "-\t\t\tCompilationUnitDeclaration unit =", "-\t\t\t\tSourceTypeConverter.buildCompilationUnit(", "-\t\t\t\t\tnew ISourceType[]{topLevelType}, ", "-\t\t\t\t\tfalse, // no need for field and methods", "-\t\t\t\t\ttrue, // need member types", "-\t\t\t\t\tfalse, // no need for field initialization", "-\t\t\t\t\tlookupEnvironment.problemReporter, ", "-\t\t\t\t\tresult);", "-\t\t\tif (unit != null) {", "-\t\t\t\tlookupEnvironment.buildTypeBindings(unit);", "-\t\t\t\trememberWithMemberTypes(topLevelType, unit.types[0].binding);", "-", "-\t\t\t\tlookupEnvironment.completeTypeBindings(unit, false);", "-\t\t\t}", "-\t\t}", "-\t\treportHierarchy();", "-\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object", "-\t} finally {", "-\t\treset();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bd3b03ba3ebf9236452514296932db61", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void accept(ISourceType[] sourceTypes, PackageBinding packageBinding)", "signatureAfterChange": " public void accept(ISourceType[] sourceTypes, PackageBinding packageBinding)", "diff": ["-\t */", "-\tpublic void accept(ISourceType[] sourceTypes, PackageBinding packageBinding) {", "-\t\t// case of SearchableEnvironment of an IJavaProject is used", "-\t\tISourceType sourceType = sourceTypes[0];", "-\t\twhile (sourceType.getEnclosingType() != null)", "-\t\t\tsourceType = sourceType.getEnclosingType();", "-\t\tif (sourceType instanceof SourceTypeElementInfo) {", "-\t\t\t// get source", "-\t\t\tSourceTypeElementInfo elementInfo = (SourceTypeElementInfo) sourceType;", "-\t\t\tIType type = elementInfo.getHandle();", "-\t\t\tICompilationUnit sourceUnit = (ICompilationUnit)type.getCompilationUnit();", "-\t\t\tthis.accept(sourceUnit);", "-\t\t} else {", "-\t\t\tCompilationResult result =", "-\t\t\t\tnew CompilationResult(sourceType.getFileName(), 0, 0, 0);", "-\t\t\tCompilationUnitDeclaration unit =", "-\t\t\t\tSourceTypeConverter.buildCompilationUnit(", "-\t\t\t\t\tsourceTypes,", "-\t\t\t\t\ttrue, // need field and methods", "-\t\t\t\t\ttrue, // need member types", "-\t\t\t\t\tfalse, // no need for field initialization", "-\t\t\t\t\tlookupEnvironment.problemReporter,", "-\t\t\t\t\tresult);", "-\t\t\tthis.lookupEnvironment.buildTypeBindings(unit);", "-\t\t\tthis.lookupEnvironment.completeTypeBindings(unit, true);", "-\t\t}", "-\t}\t", "+ */", "+public void accept(ISourceType[] sourceTypes, PackageBinding packageBinding) {", "+\t// case of SearchableEnvironment of an IJavaProject is used", "+\tISourceType sourceType = sourceTypes[0];", "+\twhile (sourceType.getEnclosingType() != null)", "+\t\tsourceType = sourceType.getEnclosingType();", "+\tif (sourceType instanceof SourceTypeElementInfo) {", "+\t\t// get source", "+\t\tSourceTypeElementInfo elementInfo = (SourceTypeElementInfo) sourceType;", "+\t\tIType type = elementInfo.getHandle();", "+\t\tICompilationUnit sourceUnit = (ICompilationUnit) type.getCompilationUnit();", "+\t\taccept(sourceUnit);", "+\t} else {", "+\t\tCompilationResult result = new CompilationResult(sourceType.getFileName(), 1, 1, 0);", "+\t\tCompilationUnitDeclaration unit =", "+\t\t\tSourceTypeConverter.buildCompilationUnit(", "+\t\t\t\tsourceTypes,", "+\t\t\t\ttrue, // need field and methods", "+\t\t\t\ttrue, // need member types", "+\t\t\t\tfalse, // no need for field initialization", "+\t\t\t\tlookupEnvironment.problemReporter,", "+\t\t\t\tresult);", "+\t\tthis.lookupEnvironment.buildTypeBindings(unit);", "+\t\tthis.lookupEnvironment.completeTypeBindings(unit, true);", "+}\t"]}], "num": 23793}