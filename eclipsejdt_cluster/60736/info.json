{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "250056da9d937ed0d52b24ab515c15a5", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d3c1ae547e3df95c0a74943382e40dc8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "96c7afd29f6893c16cf00a3ac29701c1a81f919d", "commitAfterChange": "dd45817f66a0a68c9747e1c73f77cc12766ad25c", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private int adaptEdit(OptimizedReplaceEdit[] sortedEdits, int start, int regionStart, int regionEnd)", "signatureAfterChange": "     private int adaptEdit(OptimizedReplaceEdit[] sortedEdits, int start, int regionStart, int regionEnd)", "diff": ["-    \tint bottom = start==-1?0:start, top = sortedEdits.length - 1;", "+    \tint initialStart = start==-1 ? 0 : start;", "+\t\tint bottom = initialStart, top = sortedEdits.length - 1;", "-        int linesOutside= -1;", "-    \t\tif (regionStart < editStart) {  // the edit starts after the region's start => no possible overlap of region's start", "+    \t\tif (editStart > regionStart) {  // the edit starts after the region's start => no possible overlap of region's start", "-    \t\t\tif (regionEnd < editStart) { // the edit starts after the region's end => no possible overlap of region's end", "+    \t\t\tif (editStart > regionEnd) { // the edit starts after the region's end => no possible overlap of region's end", "-    \t\t\tif (regionStart >= editEnd) { // the edit ends before the region's start => no possible overlap of region's start", "+    \t\t\tif (editEnd < regionStart) { // the edit ends before the region's start => no possible overlap of region's start", "-\t\t\t\t\tlinesOutside = 0;", "+\t\t\t\t\tint linesOutside = 0;", "+\t\t\t\t\tStringBuffer spacesOutside = new StringBuffer();", "-\t\t\t\t\twhile (!this.scanner.atEnd()) {", "-\t\t\t\t\t\tboolean before = this.scanner.currentPosition < regionStart;", "-\t                    char ch = (char) this.scanner.getNextChar();", "-                    \tif (ch == '\\n' ) {", "-                    \t\tif (before) linesOutside++;", "-                    \t}", "-                    }", "+\t\t\t\t\twhile (this.scanner.currentPosition < regionStart && !this.scanner.atEnd()) {", "+\t\t\t\t\t\tchar ch = (char) this.scanner.getNextChar();", "+\t\t\t\t\t\tswitch (ch) {", "+\t\t\t\t\t\t\tcase '\\n':", "+\t\t\t\t\t\t\t\tlinesOutside++;", "+\t\t\t\t\t\t\t\tspacesOutside.setLength(0);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase '\\r':", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\tspacesOutside.append(ch);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tint editLength = edit.length;", "-\t\t\t\t\t\t// As the edit starts outside the region, remove first lines from edit string if any", "-\t\t\t\t\t\tif (linesReplaced > 0) {", "-\t\t\t\t\t    \tint linesCount = linesOutside >= linesReplaced ? linesReplaced : linesOutside;", "-\t\t\t\t\t    \tif (linesCount > 0) {", "-\t\t\t\t\t    \t\tint idx=0;", "-\t\t\t\t\t    \t\tloop: while (idx < length) {", "-\t\t\t\t\t    \t\t\tchar ch = edit.replacement.charAt(idx);", "-\t\t\t\t\t    \t\t\tswitch (ch) {", "-\t\t\t\t\t    \t\t\t\tcase '\\n':", "-\t\t\t\t\t\t    \t\t\t\tlinesCount--;", "-\t\t\t\t\t\t    \t\t\t\tif (linesCount == 0) {", "-\t\t\t\t\t\t    \t\t\t\t\tidx++;", "-\t\t\t\t\t\t    \t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t    \t\t\t\t}", "-\t\t\t\t\t\t    \t\t\t\tbreak;", "-\t\t\t\t\t    \t\t\t\tcase '\\r':", "-\t\t\t\t\t    \t\t\t\tcase ' ':", "-\t\t\t\t\t    \t\t\t\tcase '\\t':", "-\t\t\t\t\t    \t\t\t\t\tbreak;", "-\t\t\t\t\t    \t\t\t\tdefault:", "-\t\t\t\t\t    \t\t\t\t\tbreak loop;", "-\t\t\t\t\t    \t\t\t}", "-\t\t\t\t\t    \t\t\tidx++;", "-\t\t\t\t\t    \t\t}", "-\t\t\t\t\t    \t\tif (idx >= length) {", "-\t\t\t\t\t    \t\t\tedit.replacement = \"\"; //$NON-NLS-1$", "-\t\t\t\t\t    \t\t} else {", "-\t\t\t\t\t    \t\t\tedit.replacement = edit.replacement.substring(idx);", "-\t\t\t\t\t    \t\t}", "-\t\t\t\t\t    \t}", "+\t\t\t\t\t\t// If the edit was a replacement but become an insertion due to the length reduction", "+\t\t\t\t\t\t// and if the edit finishes just before the region starts and if there's no line to replace", "+\t\t\t\t\t\t// then there's no replacement to do...", "+\t\t\t\t\t\tif (editLength > 0 && edit.length == 0 && editEnd == regionStart && linesReplaced == 0 && linesOutside== 0) {", "+\t\t\t\t\t\t\tedit.valid = false;", "+\t\t\t\t\t\t} else {", "+", "+\t\t\t\t\t\t\t// As the edit starts outside the region, remove first lines from edit string if any", "+\t\t\t\t\t\t\tif (linesReplaced > 0) {", "+\t\t\t\t\t\t\t\tint linesCount = linesOutside >= linesReplaced ? linesReplaced : linesOutside;", "+\t\t\t\t\t\t\t\tif (linesCount > 0) {", "+\t\t\t\t\t\t\t\t\tint idx = 0;", "+\t\t\t\t\t\t\t\t\tloop: while (idx < length) {", "+\t\t\t\t\t\t\t\t\t\tchar ch = edit.replacement.charAt(idx);", "+\t\t\t\t\t\t\t\t\t\tswitch (ch) {", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\n':", "+\t\t\t\t\t\t\t\t\t\t\t\tlinesCount--;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (linesCount == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tidx++;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\r':", "+\t\t\t\t\t\t\t\t\t\t\tcase ' ':", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\t':", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tidx++;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// Compare spaces outside the region and the beginning", "+\t\t\t\t\t\t\t\t\t// of the replacement string to remove the common part", "+\t\t\t\t\t\t\t\t\tint spacesOutsideLength = spacesOutside.length();", "+\t\t\t\t\t\t\t\t\tint replacementStart = idx;", "+\t\t\t\t\t\t\t\t\tfor (int o=0, r=0; o < spacesOutsideLength && r<(length-idx); o++) {", "+\t\t\t\t\t\t\t\t\t\tchar rch = edit.replacement.charAt(idx + r);", "+\t\t\t\t\t\t\t\t\t\tchar och = spacesOutside.charAt(o);", "+\t\t\t\t\t\t\t\t\t\tif (rch == och) {", "+\t\t\t\t\t\t\t\t\t\t\treplacementStart++;", "+\t\t\t\t\t\t\t\t\t\t\tr++;", "+\t\t\t\t\t\t\t\t\t\t} else if (rch == '\\t' && (this.tabLength > 0 && och == ' ')) {", "+\t\t\t\t\t\t\t\t\t\t\tif ((o+1)%this.tabLength == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\treplacementStart++;", "+\t\t\t\t\t\t\t\t\t\t\t\tr++;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// Update the replacement string", "+\t\t\t\t\t\t\t\t\tif (replacementStart >= length) {", "+\t\t\t\t\t\t\t\t\t\tedit.valid = false;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tedit.replacement = edit.replacement.substring(replacementStart);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+    \tint validIndex = (overlapIndex != -1) ? overlapIndex : bottom;", "-    \t\t\tif (regionEnd >= editEnd) {\t// the edit ends before the region's end => no possible overlap of region's end", "+    \t\t\tif (editEnd <= regionEnd) {\t// the edit ends before the region's end => no possible overlap of region's end", "-\t\t\t\t\tlinesOutside = 0;", "+\t\t\t\t\tint linesOutside = 0;", "-\t\t\t\t\treturn i;", "+", "+\t\t\t    \t// Set invalid all edits outside the region", "+\t\t\t    \tfor (int e=initialStart; e<validIndex; e++) {", "+\t\t\t    \t\tsortedEdits[e].valid = false;", "+\t\t\t    \t}", "+\t\t\t    \t", "+\t\t\t    \t// Return the index of next edit to look at", "+\t\t\t\t\treturn i + 1;", "-    \treturn overlapIndex;", "+", "+    \t// Set invalid all edits outside the region", "+    \tfor (int e=initialStart; e<validIndex; e++) {", "+    \t\tsortedEdits[e].valid = false;", "+    \t}", "+    \t", "+    \t// Return the index of next edit to look at", "+    \treturn topEnd+1;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f50a4a9b3b754f5bb051fd8b6b887aad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "48774e458dcfc41c34b203c6488c7b9a8716e5cc", "commitAfterChange": "6224a5dcda094820e09b86e019ae927259ff3273", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private int adaptEdit(OptimizedReplaceEdit[] sortedEdits, int start, int regionStart, int regionEnd)", "signatureAfterChange": "     private int adaptEdit(OptimizedReplaceEdit[] sortedEdits, int start, int regionStart, int regionEnd)", "diff": ["-    \tint bottom = start==-1?0:start, top = sortedEdits.length - 1;", "+    \tint initialStart = start==-1 ? 0 : start;", "+\t\tint bottom = initialStart, top = sortedEdits.length - 1;", "-        int linesOutside= -1;", "-    \t\tif (regionStart < editStart) {  // the edit starts after the region's start => no possible overlap of region's start", "+    \t\tif (editStart > regionStart) {  // the edit starts after the region's start => no possible overlap of region's start", "-    \t\t\tif (regionEnd < editStart) { // the edit starts after the region's end => no possible overlap of region's end", "+    \t\t\tif (editStart > regionEnd) { // the edit starts after the region's end => no possible overlap of region's end", "-    \t\t\tif (regionStart >= editEnd) { // the edit ends before the region's start => no possible overlap of region's start", "+    \t\t\tif (editEnd < regionStart) { // the edit ends before the region's start => no possible overlap of region's start", "-\t\t\t\t\tlinesOutside = 0;", "+\t\t\t\t\tint linesOutside = 0;", "+\t\t\t\t\tStringBuffer spacesOutside = new StringBuffer();", "-\t\t\t\t\twhile (!this.scanner.atEnd()) {", "-\t\t\t\t\t\tboolean before = this.scanner.currentPosition < regionStart;", "-\t                    char ch = (char) this.scanner.getNextChar();", "-                    \tif (ch == '\\n' ) {", "-                    \t\tif (before) linesOutside++;", "-                    \t}", "-                    }", "+\t\t\t\t\twhile (this.scanner.currentPosition < regionStart && !this.scanner.atEnd()) {", "+\t\t\t\t\t\tchar ch = (char) this.scanner.getNextChar();", "+\t\t\t\t\t\tswitch (ch) {", "+\t\t\t\t\t\t\tcase '\\n':", "+\t\t\t\t\t\t\t\tlinesOutside++;", "+\t\t\t\t\t\t\t\tspacesOutside.setLength(0);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase '\\r':", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\tspacesOutside.append(ch);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tint editLength = edit.length;", "-\t\t\t\t\t\t// As the edit starts outside the region, remove first lines from edit string if any", "-\t\t\t\t\t\tif (linesReplaced > 0) {", "-\t\t\t\t\t    \tint linesCount = linesOutside >= linesReplaced ? linesReplaced : linesOutside;", "-\t\t\t\t\t    \tif (linesCount > 0) {", "-\t\t\t\t\t    \t\tint idx=0;", "-\t\t\t\t\t    \t\tloop: while (idx < length) {", "-\t\t\t\t\t    \t\t\tchar ch = edit.replacement.charAt(idx);", "-\t\t\t\t\t    \t\t\tswitch (ch) {", "-\t\t\t\t\t    \t\t\t\tcase '\\n':", "-\t\t\t\t\t\t    \t\t\t\tlinesCount--;", "-\t\t\t\t\t\t    \t\t\t\tif (linesCount == 0) {", "-\t\t\t\t\t\t    \t\t\t\t\tidx++;", "-\t\t\t\t\t\t    \t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t    \t\t\t\t}", "-\t\t\t\t\t\t    \t\t\t\tbreak;", "-\t\t\t\t\t    \t\t\t\tcase '\\r':", "-\t\t\t\t\t    \t\t\t\tcase ' ':", "-\t\t\t\t\t    \t\t\t\tcase '\\t':", "-\t\t\t\t\t    \t\t\t\t\tbreak;", "-\t\t\t\t\t    \t\t\t\tdefault:", "-\t\t\t\t\t    \t\t\t\t\tbreak loop;", "-\t\t\t\t\t    \t\t\t}", "-\t\t\t\t\t    \t\t\tidx++;", "-\t\t\t\t\t    \t\t}", "-\t\t\t\t\t    \t\tif (idx >= length) {", "-\t\t\t\t\t    \t\t\tedit.replacement = \"\"; //$NON-NLS-1$", "-\t\t\t\t\t    \t\t} else {", "-\t\t\t\t\t    \t\t\tedit.replacement = edit.replacement.substring(idx);", "-\t\t\t\t\t    \t\t}", "-\t\t\t\t\t    \t}", "+\t\t\t\t\t\t// If the edit was a replacement but become an insertion due to the length reduction", "+\t\t\t\t\t\t// and if the edit finishes just before the region starts and if there's no line to replace", "+\t\t\t\t\t\t// then there's no replacement to do...", "+\t\t\t\t\t\tif (editLength > 0 && edit.length == 0 && editEnd == regionStart && linesReplaced == 0 && linesOutside== 0) {", "+\t\t\t\t\t\t\tedit.offset = -1;", "+\t\t\t\t\t\t} else {", "+", "+\t\t\t\t\t\t\t// As the edit starts outside the region, remove first lines from edit string if any", "+\t\t\t\t\t\t\tif (linesReplaced > 0) {", "+\t\t\t\t\t\t\t\tint linesCount = linesOutside >= linesReplaced ? linesReplaced : linesOutside;", "+\t\t\t\t\t\t\t\tif (linesCount > 0) {", "+\t\t\t\t\t\t\t\t\tint idx = 0;", "+\t\t\t\t\t\t\t\t\tloop: while (idx < length) {", "+\t\t\t\t\t\t\t\t\t\tchar ch = edit.replacement.charAt(idx);", "+\t\t\t\t\t\t\t\t\t\tswitch (ch) {", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\n':", "+\t\t\t\t\t\t\t\t\t\t\t\tlinesCount--;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (linesCount == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tidx++;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\r':", "+\t\t\t\t\t\t\t\t\t\t\tcase ' ':", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\t':", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tidx++;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// Compare spaces outside the region and the beginning", "+\t\t\t\t\t\t\t\t\t// of the replacement string to remove the common part", "+\t\t\t\t\t\t\t\t\tint spacesOutsideLength = spacesOutside.length();", "+\t\t\t\t\t\t\t\t\tint replacementStart = idx;", "+\t\t\t\t\t\t\t\t\tfor (int o=0, r=0; o < spacesOutsideLength && r<(length-idx); o++) {", "+\t\t\t\t\t\t\t\t\t\tchar rch = edit.replacement.charAt(idx + r);", "+\t\t\t\t\t\t\t\t\t\tchar och = spacesOutside.charAt(o);", "+\t\t\t\t\t\t\t\t\t\tif (rch == och) {", "+\t\t\t\t\t\t\t\t\t\t\treplacementStart++;", "+\t\t\t\t\t\t\t\t\t\t\tr++;", "+\t\t\t\t\t\t\t\t\t\t} else if (rch == '\\t' && (this.tabLength > 0 && och == ' ')) {", "+\t\t\t\t\t\t\t\t\t\t\tif ((o+1)%this.tabLength == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\treplacementStart++;", "+\t\t\t\t\t\t\t\t\t\t\t\tr++;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// Update the replacement string", "+\t\t\t\t\t\t\t\t\tif (replacementStart >= length) {", "+\t\t\t\t\t\t\t\t\t\tedit.offset = -1;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tedit.replacement = edit.replacement.substring(replacementStart);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+    \tint validIndex = (overlapIndex != -1) ? overlapIndex : bottom;", "-    \t\tif (regionEnd < editStart) {\t// the edit starts after the region's end => no possible overlap of region's end", "+   \t\t\tif (regionEnd < editStart) {\t// the edit starts after the region's end => no possible overlap of region's end", "-    \t\t} else {", "-    \t\t\tif (regionEnd >= editEnd) {\t// the edit ends before the region's end => no possible overlap of region's end", "-\t    \t\t\tbottom = i+1;", "-\t\t\t\t} else {", "-\t\t\t\t\t// Count the lines of the edit which are outside the region", "-\t\t\t\t\tlinesOutside = 0;", "-\t\t\t\t\tthis.scanner.resetTo(editStart, editEnd-1);", "-\t\t\t\t\twhile (!this.scanner.atEnd()) {", "-\t\t\t\t\t\tboolean after = this.scanner.currentPosition >= regionEnd;", "-\t                    char ch = (char) this.scanner.getNextChar();", "-                    \tif (ch == '\\n' ) {", "-                    \t\tif (after) linesOutside++;", "-                    \t}", "-                    }", "+    \t\t} else if (regionEnd == editStart) {\t// special case when the edit starts just after the region's end...", "+    \t\t\t// ...we got the last index of the edit inside the region", "+\t\t\t\ttopEnd = i - 1;", "+    \t\t\t// this last edit is valid only if it's an insertion and if it has indentation", "+    \t\t\tif (edit.length == 0) {", "+    \t\t\t\tint nrLength = 0;", "+    \t\t\t\tint rLength = edit.replacement.length();", "+    \t\t\t\tint ch = edit.replacement.charAt(nrLength);", "+    \t\t\t\tloop: while (nrLength < rLength) {", "+\t    \t\t\t\tswitch (ch) {", "+\t    \t\t\t\t\tcase ' ':", "+\t    \t\t\t\t\tcase '\\t':", "+\t    \t\t\t\t\t\tnrLength++;", "+\t    \t\t\t\t\t\tbreak;", "+\t    \t\t\t\t\tdefault:", "+\t    \t\t\t\t\t\tbreak loop;", "+\t    \t\t\t\t}", "+    \t\t\t\t}", "+    \t\t\t\tif (nrLength > 0) {", "+\t    \t\t\t\ttopEnd++;", "+\t    \t\t\t\tif (nrLength < rLength) {", "+\t    \t\t\t\t\tedit.replacement = edit.replacement.substring(0, nrLength);", "+\t    \t\t\t\t}", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tbreak;", "+       \t\t} else if (editEnd <= regionEnd) {\t// the edit ends before the region's end => no possible overlap of region's end", "+    \t\t\tbottom = i+1;", "+\t\t\t} else {", "+\t\t\t\t// Count the lines of the edit which are outside the region", "+\t\t\t\tint linesOutside = 0;", "+\t\t\t\tthis.scanner.resetTo(editStart, editEnd-1);", "+\t\t\t\twhile (!this.scanner.atEnd()) {", "+\t\t\t\t\tboolean after = this.scanner.currentPosition >= regionEnd;", "+                    char ch = (char) this.scanner.getNextChar();", "+                \tif (ch == '\\n' ) {", "+                \t\tif (after) linesOutside++;", "+                \t}", "+                }", "-\t\t\t\t\t// Cut replacement string if necessary", "-\t\t\t\t\tint length = edit.replacement.length();", "-\t\t\t\t\tif (length > 0) {", "+\t\t\t\t// Cut replacement string if necessary", "+\t\t\t\tint length = edit.replacement.length();", "+\t\t\t\tif (length > 0) {", "-\t\t\t\t\t\t// Count the lines in replacement string", "-\t\t\t\t\t\tint linesReplaced = 0;", "-\t\t\t\t\t\tfor (int idx=0; idx < length; idx++) {", "-\t\t\t\t\t\t\tif (edit.replacement.charAt(idx) == '\\n') linesReplaced++;", "-\t\t\t\t\t\t}", "+\t\t\t\t\t// Count the lines in replacement string", "+\t\t\t\t\tint linesReplaced = 0;", "+\t\t\t\t\tfor (int idx=0; idx < length; idx++) {", "+\t\t\t\t\t\tif (edit.replacement.charAt(idx) == '\\n') linesReplaced++;", "+\t\t\t\t\t}", "-\t\t\t\t\t\t// Set the replacement string to the number of missing new lines", "-\t\t\t\t\t\t// As the end of the edit is out of the region, the possible trailing", "-\t\t\t\t\t\t// indentation should not be added...", "-\t\t\t\t\t\tif (linesReplaced == 0) {", "+\t\t\t\t\t// Set the replacement string to the number of missing new lines", "+\t\t\t\t\t// As the end of the edit is out of the region, the possible trailing", "+\t\t\t\t\t// indentation should not be added...", "+\t\t\t\t\tif (linesReplaced == 0) {", "+\t\t    \t\t\tedit.replacement = \"\"; //$NON-NLS-1$", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tint linesCount = linesReplaced > linesOutside ? linesReplaced - linesOutside : 0;", "+\t\t\t\t\t\tif (linesCount == 0) {", "-\t\t\t\t\t\t\tint linesCount = linesReplaced > linesOutside ? linesReplaced - linesOutside : 0;", "-\t\t\t\t\t\t\tif (linesCount == 0) {", "-\t\t\t\t    \t\t\tedit.replacement = \"\"; //$NON-NLS-1$", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tedit.replacement = getNewLineString(linesCount);", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tedit.replacement = getNewLineString(linesCount);", "-\t\t\t\t\tedit.length -= editEnd - regionEnd;", "-\t\t\t\t\treturn i;", "+\t\t\t\tedit.length = regionEnd - editStart;", "+", "+\t\t    \t// We got the last edit of the regions, give up", "+\t\t\t\ttopEnd = i;", "+\t\t\t\tbreak;", "-    \treturn overlapIndex;", "+", "+    \t// Set invalid all edits outside the region", "+    \tfor (int e=initialStart; e<validIndex; e++) {", "+    \t\tsortedEdits[e].offset = -1;", "+    \t}", "+    \t", "+    \t// Return the index of next edit to look at", "+    \treturn topEnd+1;"]}], "num": 60736}