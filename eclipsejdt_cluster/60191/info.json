{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "17e217ddd1ae75e560c78be9780de8fa", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "00fa88cb3c4c3fe399c8328239ed3602", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "aefbe4fa6cca99e486c3ad39d81cae409cc051aa", "commitAfterChange": "936a96650102822fd8a013a5326735fc944194d8", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-\t\t\t\tTypeBinding returnErasure = method.returnType == null ? null : method.returnType.erasure();", "-\t\t\t\t\tif (complyTo15) {", "-\t\t\t\t\t\tif (returnErasure != (method2.returnType == null ? null : method2.returnType.erasure())) {", "-\t\t\t\t\t\t\t // colllision when parameters are identical & type variable erasures match", "-\t\t\t\t\t\t\tif (!method.areParametersEqual(method2))", "-\t\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\t\tif (method.typeVariables != NoTypeVariables && method2.typeVariables != NoTypeVariables)", "-\t\t\t\t\t\t\t\tif (!method.areTypeVariableErasuresEqual(method2))", "-\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\t} else if (!method.areParameterErasuresEqual(method2)) { // colllision when parameter & return type erasures match", "+\t\t\t\t\tif (complyTo15 && method.returnType != null && method2.returnType != null) {", "+\t\t\t\t\t\t// 8.4.2, for collision to be detected between m1 and m2:", "+\t\t\t\t\t\t// signature(m1) == signature(m2) i.e. same arity, same type parameter count, can be substituted", "+\t\t\t\t\t\t// signature(m1) == erasure(signature(m2)) or erasure(signature(m1)) == signature(m2)", "+\t\t\t\t\t\tTypeBinding[] params1 = method.parameters;", "+\t\t\t\t\t\tTypeBinding[] params2 = method2.parameters;", "+\t\t\t\t\t\tint pLength = params1.length;", "+\t\t\t\t\t\tif (pLength != params2.length)", "+", "+\t\t\t\t\t\tTypeVariableBinding[] vars = method.typeVariables;", "+\t\t\t\t\t\tTypeVariableBinding[] vars2 = method2.typeVariables;", "+\t\t\t\t\t\tboolean equalTypeVarLength = vars.length == vars2.length;", "+\t\t\t\t\t\tboolean equalTypeVars = vars == vars2;", "+\t\t\t\t\t\tMethodBinding subMethod = method2;", "+\t\t\t\t\t\tif (!equalTypeVars && equalTypeVarLength) {", "+\t\t\t\t\t\t\tLookupEnvironment env = this.scope.environment();", "+\t\t\t\t\t\t\tint varsLength = vars.length;", "+\t\t\t\t\t\t\tnotEqual : for (int v = 0; v < varsLength; v++) {", "+\t\t\t\t\t\t\t\tif (!vars[v].isInterchangeableWith(env, vars2[v])) {", "+\t\t\t\t\t\t\t\t\tequalTypeVars = false;", "+\t\t\t\t\t\t\t\t\tbreak notEqual;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tequalTypeVars = true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (equalTypeVars) {", "+\t\t\t\t\t\t\t\t// must substitute to detect cases like:", "+\t\t\t\t\t\t\t\t//   <T1 extends X<T1>> void dup() {}", "+\t\t\t\t\t\t\t\t//   <T2 extends X<T2>> Object dup() {return null;}", "+\t\t\t\t\t\t\t\tsubMethod = new ParameterizedGenericMethodBinding(method2, vars, env);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tboolean equalParams = method.areParametersEqual(subMethod);", "+\t\t\t\t\t\tif (equalParams && equalTypeVars) {", "+\t\t\t\t\t\t\t// duplicates regardless of return types", "+\t\t\t\t\t\t} else if (method.returnType.erasure() == subMethod.returnType.erasure() && (equalParams || method.areParameterErasuresEqual(method2))) {", "+\t\t\t\t\t\t\t// name clash for sure if not duplicates, report as duplicates", "+\t\t\t\t\t\t} else if (!equalTypeVars && vars != NoTypeVariables && vars2 != NoTypeVariables) {", "+\t\t\t\t\t\t\t// type variables are different so we can distinguish between methods", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t} else if (pLength > 0) {", "+\t\t\t\t\t\t\t// check to see if the erasure of either method is equal to the other", "+\t\t\t\t\t\t\tint index = pLength;", "+\t\t\t\t\t\t\tfor (; --index >= 0;) {", "+\t\t\t\t\t\t\t\tif (params1[index] != params2[index].erasure())", "+\t\t\t\t\t\t\t\t\tif (!params1[index].isRawType() || params1[index].erasure() != params2[index].erasure()) // want X#RAW to match X#RAW and X<T>", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tif (params1[index] == params2[index]) {", "+\t\t\t\t\t\t\t\t\tTypeBinding type = params1[index].leafComponentType();", "+\t\t\t\t\t\t\t\t\tif (type instanceof SourceTypeBinding && type.typeVariables() != NoTypeVariables) {", "+\t\t\t\t\t\t\t\t\t\tindex = pLength; // handle comparing identical source types like X<T>... its erasure is itself BUT we need to answer false", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (index >= 0 && index < pLength) {", "+\t\t\t\t\t\t\t\tfor (index = pLength; --index >= 0;)", "+\t\t\t\t\t\t\t\t\tif (params1[index].erasure() != params2[index])", "+\t\t\t\t\t\t\t\t\t\tif (!params2[index].isRawType() || params1[index].erasure() != params2[index].erasure()) // want X#RAW to match X#RAW and X<T>", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (index >= 0)", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\tif (returnErasure == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions", "+\t\t\t\tif (method.returnType == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "06f86db995028dd33c0a610287973c9c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "0d3b917e085a30ae0d0e62e1fdd9fed7538807f0", "commitAfterChange": "76b6a3cfd736c0a5d2fa443496ebcce87b457034", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-\t\t\t\t\t\t\t\tseverity = ProblemSeverities.Warning;", "+\t\t\t\t\t\t\t\t// check to see if the erasure of either method is equal to the other", "+\t\t\t\t\t\t\t\t// if not, then change severity to WARNING", "+\t\t\t\t\t\t\t\tTypeBinding[] params1 = method.parameters;", "+\t\t\t\t\t\t\t\tTypeBinding[] params2 = method2.parameters;", "+\t\t\t\t\t\t\t\tint pLength = params1.length;", "+\t\t\t\t\t\t\t\tTypeVariableBinding[] vars = method.typeVariables;", "+\t\t\t\t\t\t\t\tTypeVariableBinding[] vars2 = method2.typeVariables;", "+\t\t\t\t\t\t\t\tboolean equalTypeVars = vars == vars2;", "+\t\t\t\t\t\t\t\tMethodBinding subMethod = method2;", "+\t\t\t\t\t\t\t\tif (!equalTypeVars) {", "+\t\t\t\t\t\t\t\t\tMethodBinding temp = method.computeSubstitutedMethod(method2, this.scope.environment());", "+\t\t\t\t\t\t\t\t\tif (temp != null) {", "+\t\t\t\t\t\t\t\t\t\tequalTypeVars = true;", "+\t\t\t\t\t\t\t\t\t\tsubMethod = temp;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tboolean equalParams = method.areParametersEqual(subMethod);", "+\t\t\t\t\t\t\t\tif (equalParams && equalTypeVars) {", "+\t\t\t\t\t\t\t\t\t// duplicates regardless of return types", "+\t\t\t\t\t\t\t\t} else if (vars != Binding.NO_TYPE_VARIABLES && vars2 != Binding.NO_TYPE_VARIABLES) {", "+\t\t\t\t\t\t\t\t\t// both have type arguments. Erasure of signature of one cannot be equal to signature of other", "+\t\t\t\t\t\t\t\t\tseverity = ProblemSeverities.Warning;", "+\t\t\t\t\t\t\t\t} else if (pLength > 0) {", "+\t\t\t\t\t\t\t\t\tint index = pLength;", "+\t\t\t\t\t\t\t\t\t// is erasure of signature of m2 same as signature of m1?", "+\t\t\t\t\t\t\t\t\tfor (; --index >= 0;) {", "+\t\t\t\t\t\t\t\t\t\tif (params1[index] != params2[index].erasure())", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\tif (params1[index] == params2[index]) {", "+\t\t\t\t\t\t\t\t\t\t\tTypeBinding type = params1[index].leafComponentType();", "+\t\t\t\t\t\t\t\t\t\t\tif (type instanceof SourceTypeBinding && type.typeVariables() != Binding.NO_TYPE_VARIABLES) {", "+\t\t\t\t\t\t\t\t\t\t\t\tindex = pLength; // handle comparing identical source types like X<T>... its erasure is itself BUT we need to answer false", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (index >= 0 && index < pLength) {", "+\t\t\t\t\t\t\t\t\t\t// is erasure of signature of m1 same as signature of m2?", "+\t\t\t\t\t\t\t\t\t\tfor (index = pLength; --index >= 0;)", "+\t\t\t\t\t\t\t\t\t\t\tif (params1[index].erasure() != params2[index])", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (index >= 0) {", "+\t\t\t\t\t\t\t\t\t\t// erasure of neither is equal to signature of other", "+\t\t\t\t\t\t\t\t\t\tseverity = ProblemSeverities.Warning;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else if (pLength != 0){", "+\t\t\t\t\t\t\t\t\tseverity = ProblemSeverities.Warning;", "+\t\t\t\t\t\t\t\t} // pLength = 0 automatically makes erasure of arguments one equal to arguments of other."]}], "num": 60191}