{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d00d113f3deafca8a5fb36d31f5ff52e", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8bbc0fb67427bacb82bb012ec8755531", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "302f1877ad74fd63c3cd5c56aacc5cc510a8d88b", "commitAfterChange": "240c118718aa210b0d9c1362ebe7843e41fba8b4", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": " public void locateMatches(SearchDocument[] searchDocuments) throws CoreException", "signatureAfterChange": " public void locateMatches(SearchDocument[] searchDocuments) throws CoreException", "diff": ["+\tlong start = System.currentTimeMillis(); // debug", "+\tint docsLength = searchDocuments.length;", "-\t\tfor (int i = 0, length = searchDocuments.length; i < length; i++)", "+\t\tfor (int i = 0; i < docsLength; i++)", "-\t", "+", "+\t// init infos for progress increasing", "+\tint n = docsLength<1000 ? Math.min(Math.max(docsLength/100, 2),4) : 5 *(docsLength/1000);", "+\tthis.progressStep = docsLength < n ? 1 : docsLength / n; // step should not be 0", "+\tthis.progressWorked = 0;", "+", "-\tfor (int i = 0, length = searchDocuments.length; i < length; i++) {", "+\tfor (int i = 0; i < docsLength; i++) {", "-\t\tint skipped = 0;", "-\t\tfor (int i = 0, l = searchDocuments.length; i < l; i++) {", "-\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "+\t\tint displayed = 0; // progress worked displayed", "+\t\tfor (int i = 0; i < docsLength; i++) {", "+\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) {", "+\t\t\t}", "-\t\t\t\tskipped++;", "+\t\t\t\tif (this.progressMonitor != null) {", "+\t\t\t\t\tthis.progressWorked++;", "+\t\t\t\t\tif ((this.progressWorked%this.progressStep)==0) this.progressMonitor.worked(this.progressStep);", "+\t\t\t\t}", "+\t\t\t\tdisplayed++;", "-\t\t\t\tif (openable == null) continue; // match is outside classpath", "+\t\t\t\tif (openable == null) {", "+\t\t\t\t\tif (this.progressMonitor != null) {", "+\t\t\t\t\t\tthis.progressWorked++;", "+\t\t\t\t\t\tif ((this.progressWorked%this.progressStep)==0) this.progressMonitor.worked(this.progressStep);", "+\t\t\t\t\t}", "+\t\t\t\t\tdisplayed++;", "+\t\t\t\t\tcontinue; // match is outside classpath", "+\t\t\t\t}", "-\t\t\t\t\t\tlocateMatches(previousJavaProject, matchSet);", "+\t\t\t\t\t\tlocateMatches(previousJavaProject, matchSet, i-displayed);", "+\t\t\t\t\t\tdisplayed = i;", "-\t\t\t\t\tif (this.progressMonitor != null)", "-\t\t\t\t\t\tthis.progressMonitor.worked(skipped);", "-\t\t\t\tskipped = 0;", "-\t\t\tskipped++;", "-\t\t\t\tlocateMatches(previousJavaProject, matchSet);", "+\t\t\t\tlocateMatches(previousJavaProject, matchSet, docsLength-displayed);", "-\t\t\tif (this.progressMonitor != null)", "-\t\t\t\tthis.progressMonitor.worked(skipped);", "-\t}\t", "+\t}", "+\t// debug", "+\tSystem.out.println(\"Time to locate \" + //$NON-NLS-1$", "+\t\t\tthis.progressWorked+", "+\t\t\t\" matches: \" + //$NON-NLS-1$", "+\t\t\t(System.currentTimeMillis() - start) +", "+\t\t\t\" ms\"); //$NON-NLS-1$", "+\t// end debug"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "92395a20a8f44a100f4865366431b594", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "9ccc53063dda8b7e1afdde95ae36a8417c582abc", "commitAfterChange": "7143e72571bb2e6a2e74f6791210a97b375b5ab6", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public static void searchAllPossibleSubTypes( \tIType type, \tIJavaSearchScope scope, \tfinal Map binariesFromIndexMatches, \tfinal IPathRequestor pathRequestor, \tint waitingPolicy, \tIProgressMonitor progressMonitor)", "signatureAfterChange": "  public static void searchAllPossibleSubTypes( \tIType type, \tIJavaSearchScope scope, \tfinal Map binariesFromIndexMatches, \tfinal IPathRequestor pathRequestor, \tint waitingPolicy, \tIProgressMonitor progressMonitor)", "diff": ["-\tfinal Queue awaitings = new Queue();", "+\tfinal Queue queue = new Queue();", "-\t\t\t\tawaitings.add(typeName);", "+\t\t\t\tqueue.add(typeName);", "-\t", "+", "-\t", "-\t/* initialize entry result cache */", "-\tpattern.entryResults = new HashMap();", "-\t/* iterate all queued names */", "+", "-\tawaitings.add(type.getElementName().toCharArray());", "-\twhile (awaitings.start <= awaitings.end){", "-\t\tif (progressMonitor != null && progressMonitor.isCanceled()) return;", "+\tqueue.add(type.getElementName().toCharArray());", "+\ttry {", "+\t\twhile (queue.start <= queue.end) {", "+\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) return;", "-\t\tchar[] currentTypeName = awaitings.retrieve();", "+\t\t\t// all subclasses of OBJECT are actually all types", "+\t\t\tchar[] currentTypeName = queue.retrieve();", "+\t\t\tif (CharOperation.equals(currentTypeName, IIndexConstants.OBJECT))", "+\t\t\t\tcurrentTypeName = null;", "-\t\t/* all subclasses of OBJECT are actually all types */", "-\t\tif (CharOperation.equals(currentTypeName, IIndexConstants.OBJECT)){", "-\t\t\tcurrentTypeName = null;", "-\t\t}\t\t\t", "-\t\t/* search all index references to a given supertype */", "-\t\tpattern.superSimpleName = currentTypeName;", "-\t\tindexManager.performConcurrentJob(", "-\t\t\tjob, ", "-\t\t\twaitingPolicy, ", "-\t\t\tnull); // don't pass a sub progress monitor as this is too costly for deep hierarchies", "-\t\tif (progressMonitor != null && ++ticks <= MAXTICKS) {", "-\t\t\tprogressMonitor.worked(1);", "+\t\t\t// search all index references to a given supertype", "+\t\t\tpattern.superSimpleName = currentTypeName;", "+\t\t\tindexManager.performConcurrentJob(job, waitingPolicy, null); // no sub progress monitor since its too costly for deep hierarchies", "+\t\t\tif (progressMonitor != null && ++ticks <= MAXTICKS)", "+\t\t\t\tprogressMonitor.worked(1);", "+", "+\t\t\t// in case, we search all subtypes, no need to search further", "+\t\t\tif (currentTypeName == null) break;", "-\t\t/* in case, we search all subtypes, no need to search further */", "-\t\tif (currentTypeName == null) break;", "+\t} finally {", "+\t\tjob.finished();", "-\t/* close all cached index inputs */", "-\tjob.closeAll();", "-\t/* flush entry result cache */", "-\tpattern.entryResults = null;"]}], "num": 62198}