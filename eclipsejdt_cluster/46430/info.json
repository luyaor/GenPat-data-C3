{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f4129cf6c720d0630a15423bd1c4fdf8", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "15c1097914f52bea9937162092eb7ab0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic MethodBinding getExactConstructor(TypeBinding[] argumentTypes)", "signatureAfterChange": " \tpublic MethodBinding getExactConstructor(TypeBinding[] argumentTypes)", "diff": ["-\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) {", "-\t\t\t\tMethodBinding method = methods[m];", "-\t\t\t\tif (method.selector == TypeConstants.INIT && method.parameters.length == argCount) {", "-\t\t\t\t\tTypeBinding[] toMatch = method.parameters;", "-\t\t\t\t\tfor (int p = 0; p < argCount; p++)", "-\t\t\t\t\t\tif (toMatch[p] != argumentTypes[p])", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\treturn method;", "+\t\t\tlong range;", "+\t\t\tif ((range = ReferenceBinding.binarySearch(TypeConstants.INIT, this.methods)) >= 0) {", "+\t\t\t\tnextMethod: for (int imethod = (int)range, end = (int)(range >> 32); imethod <= end; imethod++) {", "+\t\t\t\t\tMethodBinding method = methods[imethod];\t\t\t", "+\t\t\t\t\tif (method.parameters.length == argCount) {", "+\t\t\t\t\t\tTypeBinding[] toMatch = method.parameters;", "+\t\t\t\t\t\tfor (int iarg = 0; iarg < argCount; iarg++)", "+\t\t\t\t\t\t\tif (toMatch[iarg] != argumentTypes[iarg])", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\treturn method;", "+\t\t\t\t\t}", "-\t\t\tMethodBinding[] constructors = getMethods(TypeConstants.INIT); // takes care of duplicates & default abstract methods", "-\t\t\tnextConstructor : for (int c = constructors.length; --c >= 0;) {", "-\t\t\t\tMethodBinding constructor = constructors[c];", "-\t\t\t\tTypeBinding[] toMatch = constructor.parameters;", "+\t\t\tMethodBinding[] matchingMethods = getMethods(TypeConstants.INIT); // takes care of duplicates & default abstract methods", "+\t\t\tnextMethod : for (int m = matchingMethods.length; --m >= 0;) {", "+\t\t\t\tMethodBinding method = matchingMethods[m];", "+\t\t\t\tTypeBinding[] toMatch = method.parameters;", "-\t\t\t\t\t\t\tcontinue nextConstructor;", "-\t\t\t\t\treturn constructor;", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\treturn method;", "-\t\t}", "+\t\t}\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6002c8b4515777a6175ff5ad09ddba82", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "0d26cebfc5ac438f5812d87a88435e81d289bbea", "commitAfterChange": "51bd97b9a16ddeaff77cec180dcadc8f8924a66a", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["-\t\t\t\tMethodBinding method = visible[i].tiebreakMethod();", "+\t\t\t\tMethodBinding tiebreakMethod = visible[i].tiebreakMethod();", "-\t\t\t\t\tMethodBinding method2 = visible[j].tiebreakMethod();", "-\t\t\t\t\tif (!isMoreSpecificMethod(method, method2)) {", "-\t\t\t\t\t\tif (!isMoreSpecificMethod(method2, method))", "+\t\t\t\t\tMethodBinding tiebreakMethod2 = visible[j].tiebreakMethod();", "+\t\t\t\t\tif (!isMoreSpecificMethod(tiebreakMethod, tiebreakMethod2)) {", "+\t\t\t\t\t\tif (!isMoreSpecificMethod(tiebreakMethod2, tiebreakMethod))", "-\t\t\t\t\tif (method.areParametersEqual(method2)) {", "+\t\t\t\t\tif (tiebreakMethod.areParametersEqual(tiebreakMethod2)) {", "+\t\t\t\t\t\tMethodBinding method = tiebreakMethod;", "+\t\t\t\t\t\tMethodBinding method2 = tiebreakMethod2;", "-\t\t\t\t\t\tif (method.hasSubstitutedParameters() && method.isAbstract() == method2.isAbstract() && receiverType != null) {", "+\t\t\t\t\t\tif (method.isAbstract() == method2.isAbstract() && receiverType != null", "+\t\t\t\t\t\t\t&& (method.hasSubstitutedParameters() || original.typeVariables != Binding.NO_TYPE_VARIABLES)) {", "+\t\t\t\t\t\t\t// when method has no type variables and method2 does, then you need a way to substitute them with their erasures at least", "+\t\t\t\t\t\t\t// to detect   class AA<T> { void test() {} }   vs   class BB extends AA<CC> { <U> void test() {} }", "-\t\t\t\t\t\t\tcontinue nextVisible; // method2 is better match than method", "-\t\t\t\tmethod = visible[i]; // instead of the tieBreakMethod", "-\t\t\t\tcompilationUnitScope().recordTypeReferences(method.thrownExceptions);", "-\t\t\t\treturn method;", "+\t\t\t\tcompilationUnitScope().recordTypeReferences(visible[i].thrownExceptions);", "+\t\t\t\treturn visible[i];", "-\t}\t", "+\t}"]}], "num": 46430}