{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4c0411a13cceea1bc20a5b5fa052b640", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "30a28430bf304d3d5ae7631682dc9840", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "afcefcc52a6e235f9ed640317727929d84135cf0", "commitAfterChange": "5ce294a787e58643d5e8115fe2ddfea119e53aa2", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tprivate void internalGenerateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "  private void internalGenerateCode(ClassScope classScope, ClassFile classFile)", "diff": ["-", "-\tprivate void internalGenerateCode(ClassScope classScope, ClassFile classFile) {", "-\t\t", "-\t\tclassFile.generateMethodInfoHeader(binding);", "-\t\tint methodAttributeOffset = classFile.contentsOffset;", "-\t\tint attributeNumber = classFile.generateMethodInfoAttribute(this.binding);", "-\t\tif ((!binding.isNative()) && (!binding.isAbstract())) {", "-\t\t\t", "-\t\t\tTypeDeclaration declaringType = classScope.referenceContext;", "-\t\t\tint codeAttributeOffset = classFile.contentsOffset;", "-\t\t\tclassFile.generateCodeAttributeHeader();", "-\t\t\tCodeStream codeStream = classFile.codeStream;", "-\t\t\tcodeStream.reset(this, classFile);", "-", "-\t\t\t// initialize local positions - including initializer scope.", "-\t\t\tReferenceBinding declaringClass = binding.declaringClass;", "-", "-\t\t\tint enumOffset = declaringClass.isEnum() ? 2 : 0; // String name, int ordinal", "-\t\t\tint argSlotSize = 1 + enumOffset; // this==aload0", "-", "-\t\t\tif (declaringClass.isNestedType()){", "-\t\t\t\tNestedTypeBinding nestedType = (NestedTypeBinding) declaringClass;", "-\t\t\t\tthis.scope.extraSyntheticArguments = nestedType.syntheticOuterLocalVariables();", "-\t\t\t\tscope.computeLocalVariablePositions(// consider synthetic arguments if any", "-\t\t\t\t\tnestedType.enclosingInstancesSlotSize + 1 + enumOffset,", "-\t\t\t\t\tcodeStream);", "-\t\t\t\targSlotSize += nestedType.enclosingInstancesSlotSize;", "-\t\t\t\targSlotSize += nestedType.outerLocalVariablesSlotSize;", "-\t\t\t} else {", "-\t\t\t\tscope.computeLocalVariablePositions(1 + enumOffset,  codeStream);", "-\t\t\t}", "-\t\t\t\t", "-\t\t\tif (arguments != null) {", "-\t\t\t\tfor (int i = 0, max = arguments.length; i < max; i++) {", "-\t\t\t\t\t// arguments initialization for local variable debug attributes", "-\t\t\t\t\tLocalVariableBinding argBinding;", "-\t\t\t\t\tcodeStream.addVisibleLocalVariable(argBinding = arguments[i].binding);", "-\t\t\t\t\targBinding.recordInitializationStartPC(0);", "-\t\t\t\t\tTypeBinding argType;", "-\t\t\t\t\tif ((argType = argBinding.type) == TypeBinding.LONG || (argType == TypeBinding.DOUBLE)) {", "-\t\t\t\t\t\targSlotSize += 2;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\targSlotSize++;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\tMethodScope initializerScope = declaringType.initializerScope;", "-\t\t\tinitializerScope.computeLocalVariablePositions(argSlotSize, codeStream); // offset by the argument size (since not linked to method scope)", "-", "-\t\t\tboolean needFieldInitializations = constructorCall == null || constructorCall.accessMode != ExplicitConstructorCall.This;", "-", "-\t\t\t// post 1.4 target level, synthetic initializations occur prior to explicit constructor call", "-\t\t\tboolean preInitSyntheticFields = scope.compilerOptions().targetJDK >= ClassFileConstants.JDK1_4;", "-", "-\t\t\tif (needFieldInitializations && preInitSyntheticFields){", "-\t\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(scope, codeStream, declaringClass);", "-\t\t\t}\t\t\t", "-\t\t\t// generate constructor call", "-\t\t\tif (constructorCall != null) {", "-\t\t\t\tconstructorCall.generateCode(scope, codeStream);", "-\t\t\t}", "-\t\t\t// generate field initialization - only if not invoking another constructor call of the same class", "-\t\t\tif (needFieldInitializations) {", "-\t\t\t\tif (!preInitSyntheticFields){", "-\t\t\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(scope, codeStream, declaringClass);", "-\t\t\t\t}", "-\t\t\t\t// generate user field initialization", "-\t\t\t\tif (declaringType.fields != null) {", "-\t\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {", "-\t\t\t\t\t\tFieldDeclaration fieldDecl;", "-\t\t\t\t\t\tif (!(fieldDecl = declaringType.fields[i]).isStatic()) {", "-\t\t\t\t\t\t\tfieldDecl.generateCode(initializerScope, codeStream);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// generate statements", "-\t\t\tif (statements != null) {", "-\t\t\t\tfor (int i = 0, max = statements.length; i < max; i++) {", "-\t\t\t\t\tstatements[i].generateCode(scope, codeStream);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (this.needFreeReturn) {", "-\t\t\t\tcodeStream.return_();", "-\t\t\t}", "-\t\t\t// local variable attributes", "-\t\t\tcodeStream.exitUserScope(scope);", "-\t\t\tcodeStream.recordPositionsFrom(0, this.bodyEnd);", "-\t\t\tclassFile.completeCodeAttribute(codeAttributeOffset);", "-\t\t\tattributeNumber++;", "-\t\t}", "-\t\tclassFile.completeMethodInfo(methodAttributeOffset, attributeNumber);", "-", "-\t\t// if a problem got reported during code gen, then trigger problem method creation", "-\t\tif (ignoreFurtherInvestigation) {", "-\t\t\tthrow new AbortMethod(scope.referenceCompilationUnit().compilationResult, null);", "-\t\t}", "-\t}", "+", "+private void internalGenerateCode(ClassScope classScope, ClassFile classFile) {", "+\tclassFile.generateMethodInfoHeader(this.binding);", "+\tint methodAttributeOffset = classFile.contentsOffset;", "+\tint attributeNumber = classFile.generateMethodInfoAttribute(this.binding);", "+\tif ((!this.binding.isNative()) && (!this.binding.isAbstract())) {", "+\t\tTypeDeclaration declaringType = classScope.referenceContext;", "+\t\tint codeAttributeOffset = classFile.contentsOffset;", "+\t\tclassFile.generateCodeAttributeHeader();", "+\t\tCodeStream codeStream = classFile.codeStream;", "+\t\tcodeStream.reset(this, classFile);", "+\t\t// initialize local positions - including initializer scope.", "+\t\tReferenceBinding declaringClass = this.binding.declaringClass;", "+\t\tint enumOffset = declaringClass.isEnum() ? 2 : 0; // String name, int ordinal", "+\t\tint argSlotSize = 1 + enumOffset; // this==aload0", "+\t\tif (declaringClass.isNestedType()){", "+\t\t\tNestedTypeBinding nestedType = (NestedTypeBinding) declaringClass;", "+\t\t\tthis.scope.extraSyntheticArguments = nestedType.syntheticOuterLocalVariables();", "+\t\t\tthis.scope.computeLocalVariablePositions(// consider synthetic arguments if any", "+\t\t\t\tnestedType.enclosingInstancesSlotSize + 1 + enumOffset,", "+\t\t\t\tcodeStream);", "+\t\t\targSlotSize += nestedType.enclosingInstancesSlotSize;", "+\t\t\targSlotSize += nestedType.outerLocalVariablesSlotSize;", "+\t\t} else {", "+\t\t\tthis.scope.computeLocalVariablePositions(1 + enumOffset,  codeStream);", "+\t\t\t", "+\t\tif (this.arguments != null) {", "+\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t// arguments initialization for local variable debug attributes", "+\t\t\t\tLocalVariableBinding argBinding;", "+\t\t\t\tcodeStream.addVisibleLocalVariable(argBinding = this.arguments[i].binding);", "+\t\t\t\targBinding.recordInitializationStartPC(0);", "+\t\t\t\tTypeBinding argType;", "+\t\t\t\tif ((argType = argBinding.type) == TypeBinding.LONG || (argType == TypeBinding.DOUBLE)) {", "+\t\t\t\t\targSlotSize += 2;", "+\t\t\t\t} else {", "+\t\t\t\t\targSlotSize++;", "+\t\t", "+\t\tMethodScope initializerScope = declaringType.initializerScope;", "+\t\tinitializerScope.computeLocalVariablePositions(argSlotSize, codeStream); // offset by the argument size (since not linked to method scope)", "+", "+\t\tboolean needFieldInitializations = this.constructorCall == null || this.constructorCall.accessMode != ExplicitConstructorCall.This;", "+", "+\t\t// post 1.4 target level, synthetic initializations occur prior to explicit constructor call", "+\t\tboolean preInitSyntheticFields = this.scope.compilerOptions().targetJDK >= ClassFileConstants.JDK1_4;", "+", "+\t\tif (needFieldInitializations && preInitSyntheticFields){", "+\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(this.scope, codeStream, declaringClass);", "+\t\t}\t\t\t", "+\t\t// generate constructor call", "+\t\tif (this.constructorCall != null) {", "+\t\t\tthis.constructorCall.generateCode(this.scope, codeStream);", "+\t\t}", "+\t\t// generate field initialization - only if not invoking another constructor call of the same class", "+\t\tif (needFieldInitializations) {", "+\t\t\tif (!preInitSyntheticFields){", "+\t\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(this.scope, codeStream, declaringClass);", "+\t\t\t}", "+\t\t\t// generate user field initialization", "+\t\t\tif (declaringType.fields != null) {", "+\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {", "+\t\t\t\t\tFieldDeclaration fieldDecl;", "+\t\t\t\t\tif (!(fieldDecl = declaringType.fields[i]).isStatic()) {", "+\t\t\t\t\t\tfieldDecl.generateCode(initializerScope, codeStream);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t// generate statements", "+\t\tif (this.statements != null) {", "+\t\t\tfor (int i = 0, max = this.statements.length; i < max; i++) {", "+\t\t\t\tthis.statements[i].generateCode(this.scope, codeStream);", "+\t\t\t}", "+\t\t}", "+\t\tif (this.needFreeReturn) {", "+\t\t\tcodeStream.return_();", "+\t\t}", "+\t\t// local variable attributes", "+\t\tcodeStream.exitUserScope(this.scope);", "+\t\tcodeStream.recordPositionsFrom(0, this.bodyEnd);", "+\t\tclassFile.completeCodeAttribute(codeAttributeOffset);", "+\t\tattributeNumber++;", "+\tclassFile.completeMethodInfo(methodAttributeOffset, attributeNumber);", "+", "+\t// if a problem got reported during code gen, then trigger problem method creation", "+\tif (this.ignoreFurtherInvestigation) {", "+\t\tthrow new AbortMethod(this.scope.referenceCompilationUnit().compilationResult, null);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "edd793799fe58e99805f1cac68111ab3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "8b0f83ab2fc2f0377aa0a160aaebc6cf11976024", "commitAfterChange": "841d4b99f7f88577aa004d23df8444d60d488b4b", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tprivate void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": " private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+ */", "+private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {", "+\tif ((this.binding.isPrivate()/* || (this.binding.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType*/) && !this.binding.isUsed()) {", "+\t\tif (!this.scope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "+\t\t\tthis.scope.problemReporter().unusedPrivateType(this);", "+\t\t}", "+\t}", "+\tInitializationFlowContext initializerContext = new InitializationFlowContext(null, this, this.initializerScope);", "+\tInitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, this.staticInitializerScope);", "+\tFlowInfo nonStaticFieldInfo = flowInfo.unconditionalFieldLessCopy();", "+\tFlowInfo staticFieldInfo = flowInfo.unconditionalFieldLessCopy();", "+\tif (this.fields != null) {", "+\t\tfor (int i = 0, count = this.fields.length; i < count; i++) {", "+\t\t\tFieldDeclaration field = this.fields[i];", "+\t\t\tif (field.isStatic()) {", "+\t\t\t\tif ((staticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "+\t\t\t\t\tfield.bits &= ~ASTNode.IsReachable;", "+\t\t\t\t", "+\t\t\t\t/*if (field.isField()){", "+\t\t\t\t\tstaticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "+\t\t\t\t} else {*/", "+\t\t\t\tstaticInitializerContext.handledExceptions = Binding.ANY_EXCEPTION; // tolerate them all, and record them", "+\t\t\t\t/*}*/", "+\t\t\t\tstaticFieldInfo =", "+\t\t\t\t\tfield.analyseCode(", "+\t\t\t\t\t\tthis.staticInitializerScope,", "+\t\t\t\t\t\tstaticInitializerContext,", "+\t\t\t\t\t\tstaticFieldInfo);", "+\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "+\t\t\t\t// branch, since the previous initializer already got the blame.", "+\t\t\t\tif (staticFieldInfo == FlowInfo.DEAD_END) {", "+\t\t\t\t\tthis.staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);", "+\t\t\t\t\tstaticFieldInfo = FlowInfo.initial(this.maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "+\t\t\t} else {", "+\t\t\t\tif ((nonStaticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "+\t\t\t\t\tfield.bits &= ~ASTNode.IsReachable;", "+\t\t\t\t", "+\t\t\t\t/*if (field.isField()){", "+\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "+\t\t\t\t} else {*/", "+\t\t\t\t\tinitializerContext.handledExceptions = Binding.ANY_EXCEPTION; // tolerate them all, and record them", "+\t\t\t\t/*}*/", "+\t\t\t\tnonStaticFieldInfo =", "+\t\t\t\t\tfield.analyseCode(this.initializerScope, initializerContext, nonStaticFieldInfo);", "+\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "+\t\t\t\t// branch, since the previous initializer already got the blame.", "+\t\t\t\tif (nonStaticFieldInfo == FlowInfo.DEAD_END) {", "+\t\t\t\t\tthis.initializerScope.problemReporter().initializerMustCompleteNormally(field);", "+\t\t\t\t\tnonStaticFieldInfo = FlowInfo.initial(this.maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "+\t\t\t\t} ", "+\t\t}", "+\t}", "+\tif (this.memberTypes != null) {", "+\t\tfor (int i = 0, count = this.memberTypes.length; i < count; i++) {", "+\t\t\tif (flowContext != null){ // local type", "+\t\t\t\tthis.memberTypes[i].analyseCode(this.scope, flowContext, nonStaticFieldInfo.copy().setReachMode(flowInfo.reachMode())); // reset reach mode in case initializers did abrupt completely", "+\t\t\t} else {", "+\t\t\t\tthis.memberTypes[i].analyseCode(this.scope);", "+\t\t\t}", "+\t\t}", "+\t}", "+\tif (this.methods != null) {", "+\t\tUnconditionalFlowInfo outerInfo = flowInfo.unconditionalFieldLessCopy();", "+\t\tFlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "+\t\tfor (int i = 0, count = this.methods.length; i < count; i++) {", "+\t\t\tAbstractMethodDeclaration method = this.methods[i];", "+\t\t\tif (method.ignoreFurtherInvestigation)", "+\t\t\t\tcontinue;", "+\t\t\tif (method.isInitializationMethod()) {", "+\t\t\t\tif (method.isStatic()) { // <clinit>", "+\t\t\t\t\tmethod.analyseCode(", "+\t\t\t\t\t\tthis.scope, ", "+\t\t\t\t\t\tstaticInitializerContext,  ", "+\t\t\t\t\t\tstaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo).setReachMode(flowInfo.reachMode()));  // reset reach mode in case initializers did abrupt completely", "+\t\t\t\t} else { // constructor", "+\t\t\t\t\tmethod.analyseCode(this.scope, initializerContext, constructorInfo.copy().setReachMode(flowInfo.reachMode())); // reset reach mode in case initializers did abrupt completely", "-\t */", "-\tprivate void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {", "-", "-\t\tif ((this.binding.isPrivate()/* || (this.binding.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType*/) && !this.binding.isUsed()) {", "-\t\t\tif (!scope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "-\t\t\t\tscope.problemReporter().unusedPrivateType(this);", "+\t\t\t} else { // regular method", "+\t\t\t\tmethod.analyseCode(this.scope, null, flowInfo.copy());", "-", "-\t\tInitializationFlowContext initializerContext = new InitializationFlowContext(null, this, initializerScope);", "-\t\tInitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, staticInitializerScope);", "-\t\tFlowInfo nonStaticFieldInfo = flowInfo.unconditionalFieldLessCopy();", "-\t\tFlowInfo staticFieldInfo = flowInfo.unconditionalFieldLessCopy();", "-\t\tif (fields != null) {", "-\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-\t\t\t\tFieldDeclaration field = fields[i];", "-\t\t\t\tif (field.isStatic()) {", "-\t\t\t\t\tif ((staticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "-\t\t\t\t\t\tfield.bits &= ~ASTNode.IsReachable;", "-\t\t\t\t\t", "-\t\t\t\t\t/*if (field.isField()){", "-\t\t\t\t\t\tstaticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "-\t\t\t\t\t} else {*/", "-\t\t\t\t\tstaticInitializerContext.handledExceptions = Binding.ANY_EXCEPTION; // tolerate them all, and record them", "-\t\t\t\t\t/*}*/", "-\t\t\t\t\tstaticFieldInfo =", "-\t\t\t\t\t\tfield.analyseCode(", "-\t\t\t\t\t\t\tstaticInitializerScope,", "-\t\t\t\t\t\t\tstaticInitializerContext,", "-\t\t\t\t\t\t\tstaticFieldInfo);", "-\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-\t\t\t\t\tif (staticFieldInfo == FlowInfo.DEAD_END) {", "-\t\t\t\t\t\tstaticInitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-\t\t\t\t\t\tstaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tif ((nonStaticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "-\t\t\t\t\t\tfield.bits &= ~ASTNode.IsReachable;", "-\t\t\t\t\t", "-\t\t\t\t\t/*if (field.isField()){", "-\t\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "-\t\t\t\t\t} else {*/", "-\t\t\t\t\t\tinitializerContext.handledExceptions = Binding.ANY_EXCEPTION; // tolerate them all, and record them", "-\t\t\t\t\t/*}*/", "-\t\t\t\t\tnonStaticFieldInfo =", "-\t\t\t\t\t\tfield.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);", "-\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-\t\t\t\t\tif (nonStaticFieldInfo == FlowInfo.DEAD_END) {", "-\t\t\t\t\t\tinitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-\t\t\t\t\t\tnonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t\t} ", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (memberTypes != null) {", "-\t\t\tfor (int i = 0, count = memberTypes.length; i < count; i++) {", "-\t\t\t\tif (flowContext != null){ // local type", "-\t\t\t\t\tmemberTypes[i].analyseCode(scope, flowContext, nonStaticFieldInfo.copy().setReachMode(flowInfo.reachMode())); // reset reach mode in case initializers did abrupt completely", "-\t\t\t\t} else {", "-\t\t\t\t\tmemberTypes[i].analyseCode(scope);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (methods != null) {", "-\t\t\tUnconditionalFlowInfo outerInfo = flowInfo.unconditionalFieldLessCopy();", "-\t\t\tFlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "-\t\t\tfor (int i = 0, count = methods.length; i < count; i++) {", "-\t\t\t\tAbstractMethodDeclaration method = methods[i];", "-\t\t\t\tif (method.ignoreFurtherInvestigation)", "-\t\t\t\t\tcontinue;", "-\t\t\t\tif (method.isInitializationMethod()) {", "-\t\t\t\t\tif (method.isStatic()) { // <clinit>", "-\t\t\t\t\t\tmethod.analyseCode(", "-\t\t\t\t\t\t\tscope, ", "-\t\t\t\t\t\t\tstaticInitializerContext,  ", "-\t\t\t\t\t\t\tstaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo).setReachMode(flowInfo.reachMode()));  // reset reach mode in case initializers did abrupt completely", "-\t\t\t\t\t} else { // constructor", "-\t\t\t\t\t\tmethod.analyseCode(scope, initializerContext, constructorInfo.copy().setReachMode(flowInfo.reachMode())); // reset reach mode in case initializers did abrupt completely", "-\t\t\t\t\t}", "-\t\t\t\t} else { // regular method", "-\t\t\t\t\tmethod.analyseCode(scope, null, flowInfo.copy());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t// enable enum support ?", "-\t\tif (this.binding.isEnum() && !this.binding.isAnonymousType()) {", "-\t\t\tthis.enumValuesSyntheticfield = this.binding.addSyntheticFieldForEnumValues();", "-\t\t}", "+\t// enable enum support ?", "+\tif (this.binding.isEnum() && !this.binding.isAnonymousType()) {", "+\t\tthis.enumValuesSyntheticfield = this.binding.addSyntheticFieldForEnumValues();", "+}"]}], "num": 69086}