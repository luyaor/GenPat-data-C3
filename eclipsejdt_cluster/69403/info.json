{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9254087b57603f1882a12675f90d624a", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "13fb639f51c0200b50d0b5df9a15f8e4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "3a7eebe0921eeefbdbf1fe4891891b6335310197", "commitAfterChange": "e8aa72d0e85424c76c1185b7518db6803dde6255", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t public TypeBinding resolveType(BlockScope scope)", "diff": ["+\t", "+public TypeBinding resolveType(BlockScope scope) {", "+\tboolean leftIsCast, rightIsCast;", "+\tif ((leftIsCast = this.left instanceof CastExpression) == true) this.left.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\tTypeBinding leftType = this.left.resolveType(scope);", "+", "+\tif ((rightIsCast = this.right instanceof CastExpression) == true) this.right.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\tTypeBinding rightType = this.right.resolveType(scope);", "+", "+\t// use the id of the type to navigate into the table", "+\tif (leftType == null || rightType == null) {", "+\t\tthis.constant = Constant.NotAConstant;", "+\t\treturn null;", "+\t}", "+", "+\tint leftTypeID = leftType.id;", "+\tint rightTypeID = rightType.id;", "+", "+\t// autoboxing support", "+\tboolean use15specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\tif (use15specifics) {", "+\t\tif (!leftType.isBaseType() && rightTypeID != TypeIds.T_JavaLangString && rightTypeID != TypeIds.T_null) {", "+\t\t\tleftTypeID = scope.environment().computeBoxingType(leftType).id;", "+\t\t}", "+\t\tif (!rightType.isBaseType() && leftTypeID != TypeIds.T_JavaLangString && leftTypeID != TypeIds.T_null) {", "+\t\t\trightTypeID = scope.environment().computeBoxingType(rightType).id;", "-\t\t", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-", "-\t\tboolean leftIsCast, rightIsCast;", "-\t\tif ((leftIsCast = left instanceof CastExpression) == true) left.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\tTypeBinding leftType = left.resolveType(scope);", "-", "-\t\tif ((rightIsCast = right instanceof CastExpression) == true) right.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\tTypeBinding rightType = right.resolveType(scope);", "-", "-\t\t// use the id of the type to navigate into the table", "-\t\tif (leftType == null || rightType == null) {", "-\t\t\tconstant = Constant.NotAConstant;", "+\tif (leftTypeID > 15", "+\t\t|| rightTypeID > 15) { // must convert String + Object || Object + String", "+\t\tif (leftTypeID == TypeIds.T_JavaLangString) {", "+\t\t\trightTypeID = TypeIds.T_JavaLangObject;", "+\t\t} else if (rightTypeID == TypeIds.T_JavaLangString) {", "+\t\t\tleftTypeID = TypeIds.T_JavaLangObject;", "+\t\t} else {", "+\t\t\tthis.constant = Constant.NotAConstant;", "+\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-", "-\t\tint leftTypeID = leftType.id;", "-\t\tint rightTypeID = rightType.id;", "-", "-\t\t// autoboxing support", "-\t\tboolean use15specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "-\t\tif (use15specifics) {", "-\t\t\tif (!leftType.isBaseType() && rightTypeID != T_JavaLangString && rightTypeID != T_null) {", "-\t\t\t\tleftTypeID = scope.environment().computeBoxingType(leftType).id;", "-\t\t\t}", "-\t\t\tif (!rightType.isBaseType() && leftTypeID != T_JavaLangString && leftTypeID != T_null) {", "-\t\t\t\trightTypeID = scope.environment().computeBoxingType(rightType).id;", "+\t}", "+\tif (((this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) == OperatorIds.PLUS) {", "+\t\tif (leftTypeID == TypeIds.T_JavaLangString) {", "+\t\t\tthis.left.computeConversion(scope, leftType, leftType);", "+\t\t\tif (rightType.isArrayType() && ((ArrayBinding) rightType).elementsType() == TypeBinding.CHAR) {", "+\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(this.right);", "-\t\tif (leftTypeID > 15", "-\t\t\t|| rightTypeID > 15) { // must convert String + Object || Object + String", "-\t\t\tif (leftTypeID == T_JavaLangString) {", "-\t\t\t\trightTypeID = T_JavaLangObject;", "-\t\t\t} else if (rightTypeID == T_JavaLangString) {", "-\t\t\t\tleftTypeID = T_JavaLangObject;", "-\t\t\t} else {", "-\t\t\t\tconstant = Constant.NotAConstant;", "-\t\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-\t\t\t\treturn null;", "+\t\tif (rightTypeID == TypeIds.T_JavaLangString) {", "+\t\t\tthis.right.computeConversion(scope, rightType, rightType);", "+\t\t\tif (leftType.isArrayType() && ((ArrayBinding) leftType).elementsType() == TypeBinding.CHAR) {", "+\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(this.left);", "-\t\tif (((bits & OperatorMASK) >> OperatorSHIFT) == PLUS) {", "-\t\t\tif (leftTypeID == T_JavaLangString) {", "-\t\t\t\tthis.left.computeConversion(scope, leftType, leftType);", "-\t\t\t\tif (rightType.isArrayType() && ((ArrayBinding) rightType).elementsType() == TypeBinding.CHAR) {", "-\t\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(right);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (rightTypeID == T_JavaLangString) {", "-\t\t\t\tthis.right.computeConversion(scope, rightType, rightType);", "-\t\t\t\tif (leftType.isArrayType() && ((ArrayBinding) leftType).elementsType() == TypeBinding.CHAR) {", "-\t\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(left);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-", "-\t\t// the code is an int", "-\t\t// (cast)  left   Op (cast)  right --> result", "-\t\t//  0000   0000       0000   0000      0000", "-\t\t//  <<16   <<12       <<8    <<4       <<0", "-", "-\t\t// Don't test for result = 0. If it is zero, some more work is done.", "-\t\t// On the one hand when it is not zero (correct code) we avoid doing the test\t", "-\t\tint operator = (bits & OperatorMASK) >> OperatorSHIFT;", "-\t\tint operatorSignature = OperatorSignatures[operator][(leftTypeID << 4) + rightTypeID];", "-", "-\t\tleft.computeConversion(\tscope, \tTypeBinding.wellKnownType(scope, (operatorSignature >>> 16) & 0x0000F), leftType);", "-\t\tright.computeConversion(scope, TypeBinding.wellKnownType(scope, (operatorSignature >>> 8) & 0x0000F), rightType);", "-\t\tbits |= operatorSignature & 0xF;", "-\t\tswitch (operatorSignature & 0xF) { // record the current ReturnTypeID", "-\t\t\t// only switch on possible result type.....", "-\t\t\tcase T_boolean :", "-\t\t\t\tthis.resolvedType = TypeBinding.BOOLEAN;", "-\t\t\t\tbreak;", "-\t\t\tcase T_byte :", "-\t\t\t\tthis.resolvedType = TypeBinding.BYTE;", "-\t\t\t\tbreak;", "-\t\t\tcase T_char :", "-\t\t\t\tthis.resolvedType = TypeBinding.CHAR;", "-\t\t\t\tbreak;", "-\t\t\tcase T_double :", "-\t\t\t\tthis.resolvedType = TypeBinding.DOUBLE;", "-\t\t\t\tbreak;", "-\t\t\tcase T_float :", "-\t\t\t\tthis.resolvedType = TypeBinding.FLOAT;", "-\t\t\t\tbreak;", "-\t\t\tcase T_int :", "-\t\t\t\tthis.resolvedType = TypeBinding.INT;", "-\t\t\t\tbreak;", "-\t\t\tcase T_long :", "-\t\t\t\tthis.resolvedType = TypeBinding.LONG;", "-\t\t\t\tbreak;", "-\t\t\tcase T_JavaLangString :", "-\t\t\t\tthis.resolvedType = scope.getJavaLangString();", "-\t\t\t\tbreak;", "-\t\t\tdefault : //error........", "-\t\t\t\tconstant = Constant.NotAConstant;", "-\t\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-\t\t\t\treturn null;", "-\t\t}", "-", "-\t\t// check need for operand cast", "-\t\tif (leftIsCast || rightIsCast) {", "-\t\t\tCastExpression.checkNeedForArgumentCasts(scope, operator, operatorSignature, left, leftTypeID, leftIsCast, right, rightTypeID, rightIsCast);", "-\t\t}", "-\t\t// compute the constant when valid", "-\t\tcomputeConstant(scope, leftTypeID, rightTypeID);", "-\t\treturn this.resolvedType;", "+\t// the code is an int", "+\t// (cast)  left   Op (cast)  right --> result", "+\t//  0000   0000       0000   0000      0000", "+\t//  <<16   <<12       <<8    <<4       <<0", "+", "+\t// Don't test for result = 0. If it is zero, some more work is done.", "+\t// On the one hand when it is not zero (correct code) we avoid doing the test\t", "+\tint operator = (this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT;", "+\tint operatorSignature = OperatorExpression.OperatorSignatures[operator][(leftTypeID << 4) + rightTypeID];", "+", "+\tthis.left.computeConversion(scope, \tTypeBinding.wellKnownType(scope, (operatorSignature >>> 16) & 0x0000F), leftType);", "+\tthis.right.computeConversion(scope, TypeBinding.wellKnownType(scope, (operatorSignature >>> 8) & 0x0000F), rightType);", "+\tthis.bits |= operatorSignature & 0xF;", "+\tswitch (operatorSignature & 0xF) { // record the current ReturnTypeID", "+\t\t// only switch on possible result type.....", "+\t\tcase T_boolean :", "+\t\t\tthis.resolvedType = TypeBinding.BOOLEAN;", "+\t\t\tbreak;", "+\t\tcase T_byte :", "+\t\t\tthis.resolvedType = TypeBinding.BYTE;", "+\t\t\tbreak;", "+\t\tcase T_char :", "+\t\t\tthis.resolvedType = TypeBinding.CHAR;", "+\t\t\tbreak;", "+\t\tcase T_double :", "+\t\t\tthis.resolvedType = TypeBinding.DOUBLE;", "+\t\t\tbreak;", "+\t\tcase T_float :", "+\t\t\tthis.resolvedType = TypeBinding.FLOAT;", "+\t\t\tbreak;", "+\t\tcase T_int :", "+\t\t\tthis.resolvedType = TypeBinding.INT;", "+\t\t\tbreak;", "+\t\tcase T_long :", "+\t\t\tthis.resolvedType = TypeBinding.LONG;", "+\t\t\tbreak;", "+\t\tcase T_JavaLangString :", "+\t\t\tthis.resolvedType = scope.getJavaLangString();", "+\t\t\tbreak;", "+\t\tdefault : //error........", "+\t\t\tthis.constant = Constant.NotAConstant;", "+\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "+\t\t\treturn null;", "+", "+\t// check need for operand cast", "+\tif (leftIsCast || rightIsCast) {", "+\t\tCastExpression.checkNeedForArgumentCasts(scope, operator, operatorSignature, this.left, leftTypeID, leftIsCast, this.right, rightTypeID, rightIsCast);", "+\t}", "+\t// compute the constant when valid", "+\tcomputeConstant(scope, leftTypeID, rightTypeID);", "+\treturn this.resolvedType;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8878c396d9cf435a0d59a0654f7493d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "8b0f83ab2fc2f0377aa0a160aaebc6cf11976024", "commitAfterChange": "841d4b99f7f88577aa004d23df8444d60d488b4b", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tpublic void generateCode(ClassFile enclosingClassFile)", "signatureAfterChange": " public void generateCode(ClassFile enclosingClassFile)", "diff": ["+ */", "+public void generateCode(ClassFile enclosingClassFile) {", "+\tif (this.hasBeenGenerated)", "+\t\treturn;", "+\tthis.hasBeenGenerated = true;", "+\tif (this.ignoreFurtherInvestigation) {", "+\t\tif (this.binding == null)", "+\t\t\treturn;", "+\t\tClassFile.createProblemType(", "+\t\t\tthis,", "+\t\t\tthis.scope.referenceCompilationUnit().compilationResult);", "+\t\treturn;", "+\t}", "+\ttry {", "+\t\t// create the result for a compiled type", "+\t\tClassFile classFile = new ClassFile(this.binding, enclosingClassFile, false);", "+\t\t// generate all fiels", "+\t\tclassFile.addFieldInfos();", "+\t\t// record the inner type inside its own .class file to be able", "+\t\t// to generate inner classes attributes", "+\t\tif (this.binding.isMemberType())", "+\t\t\tclassFile.recordEnclosingTypeAttributes(this.binding);", "+\t\tif (this.binding.isLocalType()) {", "+\t\t\tenclosingClassFile.recordNestedLocalAttribute(this.binding);", "+\t\t\tclassFile.recordNestedLocalAttribute(this.binding);", "+\t\t}", "+\t\tif (this.memberTypes != null) {", "+\t\t\t\t// record the inner type inside its own .class file to be able", "+\t\t\t\t// to generate inner classes attributes", "+\t\t\t\tclassFile.recordNestedMemberAttribute(this.memberTypes[i].binding);", "+\t\t\t\tthis.memberTypes[i].generateCode(this.scope, classFile);", "+\t\t// generate all methods", "+\t\tclassFile.setForMethodInfos();", "+\t\tif (this.methods != null) {", "+\t\t\t\tthis.methods[i].generateCode(this.scope, classFile);", "+\t\t// generate all synthetic and abstract methods", "+\t\tclassFile.addSpecialMethods();", "+\t\tif (this.ignoreFurtherInvestigation) { // trigger problem type generation for code gen errors", "+\t\t\tthrow new AbortType(this.scope.referenceCompilationUnit().compilationResult, null);", "-\t */", "-\tpublic void generateCode(ClassFile enclosingClassFile) {", "-", "-\t\tif (hasBeenGenerated)", "+\t\t// finalize the compiled type result", "+\t\tclassFile.addAttributes();", "+\t\tthis.scope.referenceCompilationUnit().compilationResult.record(", "+\t\t\tthis.binding.constantPoolName(),", "+\t\t\tclassFile);", "+\t} catch (AbortType e) {", "+\t\tif (this.binding == null)", "-\t\thasBeenGenerated = true;", "-\t\tif (ignoreFurtherInvestigation) {", "-\t\t\tif (binding == null)", "-\t\t\t\treturn;", "-\t\t\tClassFile.createProblemType(", "-\t\t\t\tthis,", "-\t\t\t\tscope.referenceCompilationUnit().compilationResult);", "-\t\t\treturn;", "-\t\t}", "-\t\ttry {", "-\t\t\t// create the result for a compiled type", "-\t\t\tClassFile classFile = new ClassFile(binding, enclosingClassFile, false);", "-\t\t\t// generate all fiels", "-\t\t\tclassFile.addFieldInfos();", "+\t\tClassFile.createProblemType(", "+\t\t\tthis,", "+\t\t\tthis.scope.referenceCompilationUnit().compilationResult);", "+\t}", "+}", "-\t\t\t// record the inner type inside its own .class file to be able", "-\t\t\t// to generate inner classes attributes", "-\t\t\tif (binding.isMemberType())", "-\t\t\t\tclassFile.recordEnclosingTypeAttributes(binding);", "-\t\t\tif (binding.isLocalType()) {", "-\t\t\t\tenclosingClassFile.recordNestedLocalAttribute(binding);", "-\t\t\t\tclassFile.recordNestedLocalAttribute(binding);", "-\t\t\t}", "-\t\t\tif (memberTypes != null) {", "-\t\t\t\tfor (int i = 0, max = memberTypes.length; i < max; i++) {", "-\t\t\t\t\t// record the inner type inside its own .class file to be able", "-\t\t\t\t\t// to generate inner classes attributes", "-\t\t\t\t\tclassFile.recordNestedMemberAttribute(memberTypes[i].binding);", "-\t\t\t\t\tmemberTypes[i].generateCode(scope, classFile);", "-\t\t\t// generate all methods", "-\t\t\tclassFile.setForMethodInfos();", "-\t\t\tif (methods != null) {", "-\t\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "-\t\t\t\t\tmethods[i].generateCode(scope, classFile);", "-\t\t\t}", "-\t\t\t// generate all synthetic and abstract methods", "-\t\t\tclassFile.addSpecialMethods();", "-", "-\t\t\tif (ignoreFurtherInvestigation) { // trigger problem type generation for code gen errors", "-\t\t\t\tthrow new AbortType(scope.referenceCompilationUnit().compilationResult, null);", "-\t\t\t}", "-", "-\t\t\t// finalize the compiled type result", "-\t\t\tclassFile.addAttributes();", "-\t\t\tscope.referenceCompilationUnit().compilationResult.record(", "-\t\t\t\tbinding.constantPoolName(),", "-\t\t\t\tclassFile);", "-\t\t} catch (AbortType e) {", "-\t\t\tif (binding == null)", "-\t\t\t\treturn;", "-\t\t\tClassFile.createProblemType(", "-\t\t\t\tthis,", "-\t\t\t\tscope.referenceCompilationUnit().compilationResult);", "-\t\t}", "-\t}"]}], "num": 69403}