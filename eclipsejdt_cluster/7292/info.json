{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3f6f43e7bfa0010905fb2cb521a848e0", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "32825be88604eefd31afda5094107e79", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "fe46c42d584fc9df798276778c11a2ce2f79d8c4", "commitAfterChange": "8904ea4393baa4ec97ffdacde82d6f35bb8add7c", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public void add(IJavaProject javaProject, boolean includesPrereqProjects, HashSet visitedProjects) throws JavaModelException", "signatureAfterChange": "  public void add(IJavaProject javaProject, int includeMask, HashSet visitedProjects) throws JavaModelException", "diff": ["-public void add(IJavaProject javaProject, boolean includesPrereqProjects, HashSet visitedProjects) throws JavaModelException {", "+public void add(IJavaProject javaProject, int includeMask, HashSet visitedProjects) throws JavaModelException {", "-\t\t\t\tIPath path = entry.getPath();", "-\t\t\t\tthis.add(path, true);", "-\t\t\t\tthis.addEnclosingProjectOrJar(path);", "+\t\t\t\tIClasspathEntry rawEntry = null;", "+\t\t\t\tJavaModelManager.PerProjectInfo perProjectInfo = ((JavaProject)javaProject).getPerProjectInfo();", "+\t\t\t\tif (perProjectInfo != null && perProjectInfo.resolvedPathToRawEntries != null) {", "+\t\t\t\t\trawEntry = (IClasspathEntry) perProjectInfo.resolvedPathToRawEntries.get(entry.getPath());", "+\t\t\t\t}", "+\t\t\t\tif (rawEntry == null) break;", "+\t\t\t\tswitch (rawEntry.getEntryKind()) {", "+\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "+\t\t\t\t\tcase IClasspathEntry.CPE_VARIABLE:", "+\t\t\t\t\t\tif ((includeMask & APPLICATION_LIBRARIES) != 0) {", "+\t\t\t\t\t\t\tIPath path = entry.getPath();", "+\t\t\t\t\t\t\tadd(path, true);", "+\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase IClasspathEntry.CPE_CONTAINER:", "+\t\t\t\t\t\tIClasspathContainer container = JavaCore.getClasspathContainer(rawEntry.getPath(), javaProject);", "+\t\t\t\t\t\tif (container == null) break;", "+\t\t\t\t\t\tif ((container.getKind() == IClasspathContainer.K_APPLICATION && (includeMask & APPLICATION_LIBRARIES) != 0)", "+\t\t\t\t\t\t\t\t|| (includeMask & SYSTEM_LIBRARIES) != 0) {", "+\t\t\t\t\t\t\tIPath path = entry.getPath();", "+\t\t\t\t\t\t\tadd(path, true);", "+\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "-\t\t\t\tif (includesPrereqProjects) {", "-\t\t\t\t\tthis.add(model.getJavaProject(entry.getPath().lastSegment()), true, visitedProjects);", "+\t\t\t\tif ((includeMask & REFERENCED_PROJECTS) != 0) {", "+\t\t\t\t\tadd(model.getJavaProject(entry.getPath().lastSegment()), includeMask, visitedProjects);", "-\t\t\t\tthis.add(entry.getPath(), true);", "+\t\t\t\tif ((includeMask & SOURCES) != 0) {", "+\t\t\t\t\tadd(entry.getPath(), true);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3bcbe1bfd18fe09b7867b210ec4f23db", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 48, "signatureBeforeChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask)", "signatureAfterChange": " \t\tfinal Binding getTypeOrPackage(char[] name, int mask)", "diff": ["-\t*/", "-\tfinal Binding getTypeOrPackage(char[] name, int mask) {", "-\t\tScope scope = this;", "-\t\tReferenceBinding foundType = null;", "-\t\tif ((mask & TYPE) == 0) {", "-\t\t\tScope next = scope;", "-\t\t\twhile ((next = scope.parent) != null)", "-\t\t\t\tscope = next;", "-\t\t} else {", "-\t\t\tdone : while (true) { // done when a COMPILATION_UNIT_SCOPE is found", "-\t\t\t\tswitch (scope.kind) {", "-\t\t\t\t\tcase METHOD_SCOPE :", "-\t\t\t\t\tcase BLOCK_SCOPE :", "-\t\t\t\t\t\tReferenceBinding localType = ((BlockScope) scope).findLocalType(name); // looks in this scope only", "-\t\t\t\t\t\tif (localType != null) {", "-\t\t\t\t\t\t\tif (foundType != null && foundType != localType)", "-\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\treturn localType;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase CLASS_SCOPE :", "-\t\t\t\t\t\tSourceTypeBinding sourceType = ((ClassScope) scope).referenceContext.binding;", "-\t\t\t\t\t\t// 6.5.5.1 - simple name favors member type over top-level type in same unit", "-\t\t\t\t\t\tReferenceBinding memberType = findMemberType(name, sourceType);", "-\t\t\t\t\t\tif (memberType != null) { // skip it if we did not find anything", "-\t\t\t\t\t\t\tif (memberType.problemId() == Ambiguous) {", "-\t\t\t\t\t\t\t\tif (foundType == null || foundType.problemId() == NotVisible)", "-\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t\treturn memberType;", "-\t\t\t\t\t\t\t\t// make the user qualify the type, likely wants the first inherited type", "-\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t*/", "+\t\tfinal Binding getTypeOrPackage(char[] name, int mask) {", "+\t\t\tScope scope = this;", "+\t\t\tReferenceBinding foundType = null;", "+\t\t\tboolean insideStaticContext = false;", "+\t\t\tboolean resolvingHierarchy = false;", "+\t\t\tif ((mask & TYPE) == 0) {", "+\t\t\t\tScope next = scope;", "+\t\t\t\twhile ((next = scope.parent) != null)", "+\t\t\t\t\tscope = next;", "+\t\t\t} else {", "+\t\t\t\tdone : while (true) { // done when a COMPILATION_UNIT_SCOPE is found", "+\t\t\t\t\tswitch (scope.kind) {", "+\t\t\t\t\t\tcase METHOD_SCOPE :", "+\t\t\t\t\t\t\tMethodScope methodScope = (MethodScope) scope;", "+\t\t\t\t\t\t\tAbstractMethodDeclaration methodDecl = methodScope.referenceMethod();", "+\t\t\t\t\t\t\tif (methodDecl != null && methodDecl.binding != null) {", "+\t\t\t\t\t\t\t\tTypeVariableBinding typeVariable = methodDecl.binding.getTypeVariable(name);", "+\t\t\t\t\t\t\t\tif (typeVariable != null)\treturn typeVariable;", "-\t\t\t\t\t\t\tif (memberType.isValidBinding()) {", "-\t\t\t\t\t\t\t\tif (sourceType == memberType.enclosingType()", "-\t\t\t\t\t\t\t\t\t\t|| environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "-\t\t\t\t\t\t\t\t\t// found a valid type in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "-\t\t\t\t\t\t\t\t\tif (foundType == null)", "-\t\t\t\t\t\t\t\t\t\treturn memberType; ", "-\t\t\t\t\t\t\t\t\tif (foundType.isValidBinding())", "-\t\t\t\t\t\t\t\t\t\t// if a valid type was found, complain when another is found in an 'immediate' enclosing type (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t\tif (foundType != memberType)", "-\t\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\tinsideStaticContext |= methodScope.isStatic;", "+\t\t\t\t\t\tcase BLOCK_SCOPE :", "+\t\t\t\t\t\t\tReferenceBinding localType = ((BlockScope) scope).findLocalType(name); // looks in this scope only", "+\t\t\t\t\t\t\tif (localType != null) {", "+\t\t\t\t\t\t\t\tif (foundType != null && foundType != localType)", "+\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\treturn localType;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase CLASS_SCOPE :", "+\t\t\t\t\t\t\tSourceTypeBinding sourceType = ((ClassScope) scope).referenceContext.binding;", "+\t\t\t\t\t\t\tif (sourceType.isHierarchyBeingConnected()) {", "+\t\t\t\t\t\t\t\t// type variables take precedence over the source type, ex. class X <X> extends X == class X <Y> extends Y ", "+\t\t\t\t\t\t\t\tTypeVariableBinding typeVariable = sourceType.getTypeVariable(name);", "+\t\t\t\t\t\t\t\tif (typeVariable != null)", "+\t\t\t\t\t\t\t\t\treturn typeVariable;", "+\t\t\t\t\t\t\t\tif (CharOperation.equals(name, sourceType.sourceName))", "+\t\t\t\t\t\t\t\t\treturn sourceType;", "+\t\t\t\t\t\t\t\tresolvingHierarchy = true;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// type variables take precedence over member types", "+\t\t\t\t\t\t\tTypeVariableBinding typeVariable = sourceType.getTypeVariable(name);", "+\t\t\t\t\t\t\tif (typeVariable != null) {", "+\t\t\t\t\t\t\t\tif (resolvingHierarchy)", "+\t\t\t\t\t\t\t\t\t// class X <T> { class MX extends T {}}", "+\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, IllegalSuperTypeVariable); // cannot bind to a type variable", "+\t\t\t\t\t\t\t\tif (insideStaticContext) // do not consider this type modifiers: access is legite within same type", "+\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, NonStaticReferenceInStaticContext);", "+\t\t\t\t\t\t\t\treturn typeVariable;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tinsideStaticContext |= (sourceType.modifiers & AccStatic) != 0; // not isStatic()", "+\t\t\t\t\t\t\t// 6.5.5.1 - member types have precedence over top-level type in same unit", "+\t\t\t\t\t\t\tReferenceBinding memberType = findMemberType(name, sourceType);", "+\t\t\t\t\t\t\tif (memberType != null) { // skip it if we did not find anything", "+\t\t\t\t\t\t\t\tif (memberType.problemId() == Ambiguous) {", "+\t\t\t\t\t\t\t\t\tif (foundType == null || foundType.problemId() == NotVisible)", "+\t\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "+\t\t\t\t\t\t\t\t\t\treturn memberType;", "+\t\t\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\t\t\t// make the user qualify the type, likely wants the first inherited type", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (memberType.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (sourceType == memberType.enclosingType()", "+\t\t\t\t\t\t\t\t\t\t\t|| environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "+\t\t\t\t\t\t\t\t\t\t// found a valid type in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "+\t\t\t\t\t\t\t\t\t\tif (foundType == null)", "+\t\t\t\t\t\t\t\t\t\t\treturn memberType; ", "+\t\t\t\t\t\t\t\t\t\tif (foundType.isValidBinding())", "+\t\t\t\t\t\t\t\t\t\t\t// if a valid type was found, complain when another is found in an 'immediate' enclosing type (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundType != memberType)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (foundType == null || (foundType.problemId() == NotVisible && memberType.problemId() != NotVisible))", "+\t\t\t\t\t\t\t\t\t// only remember the memberType if its the first one found or the previous one was not visible & memberType is...", "+\t\t\t\t\t\t\t\t\tfoundType = memberType;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (CharOperation.equals(sourceType.sourceName, name)) {", "+\t\t\t\t\t\t\t\tif (foundType != null && foundType != sourceType && foundType.problemId() != NotVisible)", "+\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\treturn sourceType;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase COMPILATION_UNIT_SCOPE :", "+\t\t\t\t\t\t\tbreak done;", "+\t\t\t\t\t}", "+\t\t\t\t\tscope = scope.parent;", "+\t\t\t\t}", "+\t\t\t\tif (foundType != null && foundType.problemId() != NotVisible)", "+\t\t\t\t\treturn foundType;", "+\t\t\t}", "+\t", "+\t\t\t// at this point the scope is a compilation unit scope", "+\t\t\tCompilationUnitScope unitScope = (CompilationUnitScope) scope;", "+\t\t\tPackageBinding currentPackage = unitScope.fPackage; ", "+\t\t\t// ask for the imports + name", "+\t\t\tif ((mask & TYPE) != 0) {", "+\t\t\t\t// check single type imports.", "+\t", "+\t\t\t\tImportBinding[] imports = unitScope.imports;", "+\t\t\t\tif (imports != null) {", "+\t\t\t\t\tHashtableOfObject typeImports = unitScope.resolvedSingeTypeImports;", "+\t\t\t\t\tif (typeImports != null) {", "+\t\t\t\t\t\tImportBinding typeImport = (ImportBinding) typeImports.get(name);", "+\t\t\t\t\t\tif (typeImport != null) {", "+\t\t\t\t\t\t\tImportReference importReference = typeImport.reference;", "+\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\t\t\treturn typeImport.resolvedImport; // already know its visible", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// walk all the imports since resolvedSingeTypeImports is not yet initialized", "+\t\t\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "+\t\t\t\t\t\t\tImportBinding typeImport = imports[i];", "+\t\t\t\t\t\t\tif (!typeImport.onDemand) {", "+\t\t\t\t\t\t\t\tif (CharOperation.equals(typeImport.compoundName[typeImport.compoundName.length - 1], name)) {", "+\t\t\t\t\t\t\t\t\tif (unitScope.resolveSingleTypeImport(typeImport) != null) {", "+\t\t\t\t\t\t\t\t\t\tImportReference importReference = typeImport.reference;", "+\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\t\t\t\t\t\treturn typeImport.resolvedImport; // already know its visible", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (foundType == null || (foundType.problemId() == NotVisible && memberType.problemId() != NotVisible))", "-\t\t\t\t\t\t\t\t// only remember the memberType if its the first one found or the previous one was not visible & memberType is...", "-\t\t\t\t\t\t\t\tfoundType = memberType;", "-\t\t\t\t\t\tif (CharOperation.equals(sourceType.sourceName, name)) {", "-\t\t\t\t\t\t\tif (foundType != null && foundType != sourceType && foundType.problemId() != NotVisible)", "-\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\treturn sourceType;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase COMPILATION_UNIT_SCOPE :", "-\t\t\t\t\t\tbreak done;", "-\t\t\t\t}", "-\t\t\t\tscope = scope.parent;", "-\t\t\t}", "-\t\t\tif (foundType != null && foundType.problemId() != NotVisible)", "-\t\t\t\treturn foundType;", "-\t\t}", "-", "-\t\t// at this point the scope is a compilation unit scope", "-\t\tCompilationUnitScope unitScope = (CompilationUnitScope) scope;", "-\t\tPackageBinding currentPackage = unitScope.fPackage; ", "-\t\t// ask for the imports + name", "-\t\tif ((mask & TYPE) != 0) {", "-\t\t\t// check single type imports.", "-", "-\t\t\tImportBinding[] imports = unitScope.imports;", "-\t\t\tif (imports != null) {", "-\t\t\t\tHashtableOfObject typeImports = unitScope.resolvedSingeTypeImports;", "-\t\t\t\tif (typeImports != null) {", "-\t\t\t\t\tImportBinding typeImport = (ImportBinding) typeImports.get(name);", "-\t\t\t\t\tif (typeImport != null) {", "-\t\t\t\t\t\tImportReference importReference = typeImport.reference;", "-\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\treturn typeImport.resolvedImport; // already know its visible", "-\t\t\t\t} else {", "-\t\t\t\t\t// walk all the imports since resolvedSingeTypeImports is not yet initialized", "+\t\t\t\t}", "+\t\t\t\t// check if the name is in the current package, skip it if its a sub-package", "+\t\t\t\tunitScope.recordReference(currentPackage.compoundName, name);", "+\t\t\t\tBinding binding = currentPackage.getTypeOrPackage(name);", "+\t\t\t\tif (binding instanceof ReferenceBinding) return binding; // type is always visible to its own package", "+\t", "+\t\t\t\t// check on demand imports", "+\t\t\t\tif (imports != null) {", "+\t\t\t\t\tboolean foundInImport = false;", "+\t\t\t\t\tReferenceBinding type = null;", "-\t\t\t\t\t\tImportBinding typeImport = imports[i];", "-\t\t\t\t\t\tif (!typeImport.onDemand) {", "-\t\t\t\t\t\t\tif (CharOperation.equals(typeImport.compoundName[typeImport.compoundName.length - 1], name)) {", "-\t\t\t\t\t\t\t\tif (unitScope.resolveSingleTypeImport(typeImport) != null) {", "-\t\t\t\t\t\t\t\t\tImportReference importReference = typeImport.reference;", "+\t\t\t\t\t\tImportBinding someImport = imports[i];", "+\t\t\t\t\t\tif (someImport.onDemand) {", "+\t\t\t\t\t\t\tBinding resolvedImport = someImport.resolvedImport;", "+\t\t\t\t\t\t\tReferenceBinding temp = resolvedImport instanceof PackageBinding", "+\t\t\t\t\t\t\t\t? findType(name, (PackageBinding) resolvedImport, currentPackage)", "+\t\t\t\t\t\t\t\t: findDirectMemberType(name, (ReferenceBinding) resolvedImport);", "+\t\t\t\t\t\t\tif (temp != null) {", "+\t\t\t\t\t\t\t\tif (temp.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tImportReference importReference = someImport.reference;", "-\t\t\t\t\t\t\t\t\treturn typeImport.resolvedImport; // already know its visible", "+\t\t\t\t\t\t\t\t\tif (foundInImport)", "+\t\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand packages.", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, Ambiguous);", "+\t\t\t\t\t\t\t\t\ttype = temp;", "+\t\t\t\t\t\t\t\t\tfoundInImport = true;", "+\t\t\t\t\t\t\t\t} else if (foundType == null) {", "+\t\t\t\t\t\t\t\t\tfoundType = temp;", "+\t\t\t\t\tif (type != null) return type;", "-\t\t\t// check if the name is in the current package, skip it if its a sub-package", "-\t\t\tunitScope.recordReference(currentPackage.compoundName, name);", "-\t\t\tBinding binding = currentPackage.getTypeOrPackage(name);", "-\t\t\tif (binding instanceof ReferenceBinding) return binding; // type is always visible to its own package", "-", "-\t\t\t// check on demand imports", "-\t\t\tif (imports != null) {", "-\t\t\t\tboolean foundInImport = false;", "-\t\t\t\tReferenceBinding type = null;", "-\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "-\t\t\t\t\tImportBinding someImport = imports[i];", "-\t\t\t\t\tif (someImport.onDemand) {", "-\t\t\t\t\t\tBinding resolvedImport = someImport.resolvedImport;", "-\t\t\t\t\t\tReferenceBinding temp = resolvedImport instanceof PackageBinding", "-\t\t\t\t\t\t\t? findType(name, (PackageBinding) resolvedImport, currentPackage)", "-\t\t\t\t\t\t\t: findDirectMemberType(name, (ReferenceBinding) resolvedImport);", "-\t\t\t\t\t\tif (temp != null) {", "-\t\t\t\t\t\t\tif (temp.isValidBinding()) {", "-\t\t\t\t\t\t\t\tImportReference importReference = someImport.reference;", "-\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\t\t\tif (foundInImport)", "-\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand packages.", "-\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, Ambiguous);", "-\t\t\t\t\t\t\t\ttype = temp;", "-\t\t\t\t\t\t\t\tfoundInImport = true;", "-\t\t\t\t\t\t\t} else if (foundType == null) {", "-\t\t\t\t\t\t\t\tfoundType = temp;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (type != null) return type;", "+\t", "+\t\t\tunitScope.recordSimpleReference(name);", "+\t\t\tif ((mask & PACKAGE) != 0) {", "+\t\t\t\tPackageBinding packageBinding = unitScope.environment.getTopLevelPackage(name);", "+\t\t\t\tif (packageBinding != null) return packageBinding;", "+\t", "+\t\t\t// Answer error binding -- could not find name", "+\t\t\tif (foundType != null) return foundType; // problem type from above", "+\t\t\treturn new ProblemReferenceBinding(name, NotFound);", "-", "-\t\tunitScope.recordSimpleReference(name);", "-\t\tif ((mask & PACKAGE) != 0) {", "-\t\t\tPackageBinding packageBinding = unitScope.environment.getTopLevelPackage(name);", "-\t\t\tif (packageBinding != null) return packageBinding;", "-\t\t}", "-", "-\t\t// Answer error binding -- could not find name", "-\t\tif (foundType != null) return foundType; // problem type from above", "-\t\treturn new ProblemReferenceBinding(name, NotFound);", "-\t}"]}], "num": 7292}