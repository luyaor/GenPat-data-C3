{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "89c52d6ab984b267826312dc6e5e220d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "30f471510894e7106fa63dd93ee9d11e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ReconcileWorkingCopyOperation.java", "commitBeforeChange": "8bea847412c36874664a80a329bfe627deff5fa9", "commitAfterChange": "c4145c80a504c8681f4571ff2bd214b778e87107", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected void executeOperation() throws JavaModelException", "signatureAfterChange": " \tprotected void executeOperation() throws JavaModelException", "diff": ["-\t\tif (this.progressMonitor != null) {", "-\t\t\tif (this.progressMonitor.isCanceled()) ", "-\t\t\t\tthrow new OperationCanceledException();", "-\t\t\tthis.progressMonitor.beginTask(Messages.element_reconciling, 2); ", "-\t\t}", "-\t", "-\t\tCompilationUnit workingCopy = getWorkingCopy();", "-\t\tboolean wasConsistent = workingCopy.isConsistent();", "-\t\tIProblemRequestor problemRequestor = workingCopy.getPerWorkingCopyInfo();", "-\t\tthis.resolveBindings |= problemRequestor != null && problemRequestor.isActive();", "-\t\t", "-\t\t// create the delta builder (this remembers the current content of the cu)", "-\t\tthis.deltaBuilder = new JavaElementDeltaBuilder(workingCopy);", "-\t\t", "-\t\t// make working copy consistent if needed and compute AST if needed", "-\t\tmakeConsistent(workingCopy, problemRequestor);", "-\t\t", "-\t\t// notify reconcile participants", "-\t\tnotifyParticipants(workingCopy);", "-\t\t", "-\t\t// recreate ast if needed", "-\t\tif (this.ast == null && (this.astLevel > ICompilationUnit.NO_AST || this.resolveBindings))", "-\t\t\tmakeConsistent(workingCopy, problemRequestor);", "-\t", "-\t\t// report problems", "-\t\tif (this.problems != null && (this.forceProblemDetection || !wasConsistent)) {", "-\t\t\ttry {", "-\t\t\t\tproblemRequestor.beginReporting();", "-\t\t\t\tfor (Iterator iteraror = this.problems.values().iterator(); iteraror.hasNext();) {", "-\t\t\t\t\tCategorizedProblem[] categorizedProblems = (CategorizedProblem[]) iteraror.next();", "-\t\t\t\t\tif (categorizedProblems == null) continue;", "-\t\t\t\t\tfor (int i = 0, length = categorizedProblems.length; i < length; i++) {", "-\t\t\t\t\t\tCategorizedProblem problem = categorizedProblems[i];", "-\t\t\t\t\t\tif (JavaModelManager.VERBOSE){", "-\t\t\t\t\t\t\tSystem.out.println(\"PROBLEM FOUND while reconciling : \" + problem.getMessage());//$NON-NLS-1$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) break;", "-\t\t\t\t\t\tproblemRequestor.acceptProblem(problem);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} finally {", "-\t\t\t\tproblemRequestor.endReporting();", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// report delta", "+\t\tcheckCanceled();", "+\t\t\tbeginTask(Messages.element_reconciling, 2); ", "+\t", "+\t\t\tCompilationUnit workingCopy = getWorkingCopy();", "+\t\t\tboolean wasConsistent = workingCopy.isConsistent();", "+\t\t\tIProblemRequestor problemRequestor = workingCopy.getPerWorkingCopyInfo();", "+\t\t\tthis.resolveBindings |= problemRequestor != null && problemRequestor.isActive();", "+\t\t\t", "+\t\t\t// create the delta builder (this remembers the current content of the cu)", "+\t\t\tthis.deltaBuilder = new JavaElementDeltaBuilder(workingCopy);", "+\t\t\t", "+\t\t\t// make working copy consistent if needed and compute AST if needed", "+\t\t\tmakeConsistent(workingCopy, problemRequestor);", "+\t\t\t", "+\t\t\t// notify reconcile participants", "+\t\t\tnotifyParticipants(workingCopy);", "+\t\t\t", "+\t\t\t// recreate ast if needed", "+\t\t\tif (this.ast == null && (this.astLevel > ICompilationUnit.NO_AST || this.resolveBindings))", "+\t\t\t\tmakeConsistent(workingCopy, problemRequestor);", "+\t\t", "+\t\t\t// report problems", "+\t\t\tif (this.problems != null && (this.forceProblemDetection || !wasConsistent)) {", "+\t\t\t\ttry {", "+\t\t\t\t\tproblemRequestor.beginReporting();", "+\t\t\t\t\tfor (Iterator iteraror = this.problems.values().iterator(); iteraror.hasNext();) {", "+\t\t\t\t\t\tCategorizedProblem[] categorizedProblems = (CategorizedProblem[]) iteraror.next();", "+\t\t\t\t\t\tif (categorizedProblems == null) continue;", "+\t\t\t\t\t\tfor (int i = 0, length = categorizedProblems.length; i < length; i++) {", "+\t\t\t\t\t\t\tCategorizedProblem problem = categorizedProblems[i];", "+\t\t\t\t\t\t\tif (JavaModelManager.VERBOSE){", "+\t\t\t\t\t\t\t\tSystem.out.println(\"PROBLEM FOUND while reconciling : \" + problem.getMessage());//$NON-NLS-1$", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) break;", "+\t\t\t\t\t\t\tproblemRequestor.acceptProblem(problem);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} finally {", "+\t\t\t\t\tproblemRequestor.endReporting();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\t// report delta", "-\t\t\tif (this.progressMonitor != null) this.progressMonitor.done();", "+\t\t\tdone();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "626ba6ae313a55c64a89fa701114441b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "fd4873f8881450efaceb482ead403702f0b3cd50", "commitAfterChange": "efd7cd38b35f875ede44936aed68717b93ca608e", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 12, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["-\tboolean skipInheritedMethods = mustImplementAbstractMethods && this.type.superInterfaces() == NoSuperInterfaces", "-\t\t&& this.type.superclass() != null && !this.type.superclass().isAbstract(); // have a single concrete superclass so only check overridden methods", "+\tboolean skipInheritedMethods = mustImplementAbstractMethods && canSkipInheritedMethods(); // have a single concrete superclass so only check overridden methods", "-\t\t\t\t\tif (otherInheritedMethod != null && otherInheritedMethod.declaringClass != inheritedMethod.declaringClass) { // must be from a different class for their params to be equal", "-\t\t\t\t\t\totherInheritedMethod = computeSubstituteMethod(otherInheritedMethod, inheritedMethod);", "-\t\t\t\t\t\tif (areMethodsEqual(inheritedMethod, otherInheritedMethod)) {", "-\t\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "-\t\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "-\t\t\t\t\t\t}", "+\t\t\t\t\tif (canSkipInheritedMethods(inheritedMethod, otherInheritedMethod))", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\totherInheritedMethod = computeSubstituteMethod(otherInheritedMethod, inheritedMethod);", "+\t\t\t\t\tif (areMethodsEqual(inheritedMethod, otherInheritedMethod)) {", "+\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "+\t\t\t\t\t\tinherited[j] = null; // do not want to find it again"]}], "num": 53591}