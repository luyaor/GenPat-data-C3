{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "801abbfec453811d011ada0c57e481f2", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3e722bdc49da6de41b38d277e67eb7f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic IMethod createMethodHandle( \t\tAbstractMethodDeclaration method, \t\tIType type)", "signatureAfterChange": " public IMethod createMethodHandle(AbstractMethodDeclaration method, IType type)", "diff": ["-\t */", "-\tpublic IMethod createMethodHandle(", "-\t\tAbstractMethodDeclaration method,", "-\t\tIType type) {", "-\t\tif (type == null) return null;", "-\t\tArgument[] arguments = method.arguments;", "-\t\tint length = arguments == null ? 0 : arguments.length;", "-\t\tif (type.isBinary()) {", "-\t\t\t// don't cache the methods of the binary type", "-\t\t\tClassFileReader reader = this.classFileReader(type);", "-\t\t\tif (reader == null) return null;", "-\t\t\tIBinaryMethod[] methods = reader.getMethods();", "-\t\t\tif (methods != null) {", "-\t\t\t\tfor (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "-\t\t\t\t\tIBinaryMethod binaryMethod = methods[i];", "-\t\t\t\t\tchar[] selector = binaryMethod.isConstructor() ? type.getElementName().toCharArray() : binaryMethod.getSelector();", "-\t\t\t\t\tif (CharOperation.equals(selector, method.selector)) {", "-\t\t\t\t\t\tString[] parameterTypes = Signature.getParameterTypes(new String(binaryMethod.getMethodDescriptor()));", "-\t\t\t\t\t\tif (length != parameterTypes.length) continue;", "-\t\t\t\t\t\tboolean sameParameters = true;", "-\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "-\t\t\t\t\t\t\tTypeReference parameterType = arguments[j].type;", "-\t\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');", "-\t\t\t\t\t\t\tfor (int k = 0; k < parameterType.dimensions(); k++) {", "-\t\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, \"[]\" .toCharArray()); //$NON-NLS-1$", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tString parameterTypeName = parameterTypes[j].replace('/', '.');", "-\t\t\t\t\t\t\tif (!Signature.toString(parameterTypeName).endsWith(new String(typeName))) {", "-\t\t\t\t\t\t\t\tsameParameters = false;", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (sameParameters) {", "-\t\t\t\t\t\t\treturn type.getMethod(new String(selector), parameterTypes);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn null;", "-\t\t\tString[] parameterTypeSignatures = new String[length];", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tTypeReference parameterType = arguments[i].type;", "-\t\t\t\tchar[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');", "-\t\t\t\tfor (int j = 0; j < parameterType.dimensions(); j++) {", "-\t\t\t\t\ttypeName = CharOperation.concat(typeName, \"[]\" .toCharArray()); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\tparameterTypeSignatures[i] = Signature.createTypeSignature(typeName, false);", "-\t\t\t}", "-\t\t\treturn type.getMethod(new String(method.selector), parameterTypeSignatures);", "+ */", "+public IMethod createMethodHandle(AbstractMethodDeclaration method, IType type) {", "+\tif (type == null) return null;", "+\tArgument[] arguments = method.arguments;", "+\tint length = arguments == null ? 0 : arguments.length;", "+\tif (type.isBinary()) {", "+\t\t// don't cache the methods of the binary type", "+\t\tClassFileReader reader = classFileReader(type);", "+\t\tif (reader == null) return null;", "+\t\tIBinaryMethod[] methods = reader.getMethods();", "+", "+\t\tif (methods != null) {", "+\t\t\tfor (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "+\t\t\t\tIBinaryMethod binaryMethod = methods[i];", "+\t\t\t\tchar[] selector = binaryMethod.isConstructor() ? type.getElementName().toCharArray() : binaryMethod.getSelector();", "+\t\t\t\tif (CharOperation.equals(selector, method.selector)) {", "+\t\t\t\t\tString[] parameterTypes = Signature.getParameterTypes(new String(binaryMethod.getMethodDescriptor()));", "+\t\t\t\t\tif (length != parameterTypes.length) continue;", "+\t\t\t\t\tboolean sameParameters = true;", "+\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\tTypeReference parameterType = arguments[j].type;", "+\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');", "+\t\t\t\t\t\tfor (int k = 0; k < parameterType.dimensions(); k++)", "+\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, \"[]\" .toCharArray()); //$NON-NLS-1$", "+\t\t\t\t\t\tString parameterTypeName = parameterTypes[j].replace('/', '.');", "+\t\t\t\t\t\tif (!Signature.toString(parameterTypeName).endsWith(new String(typeName))) {", "+\t\t\t\t\t\t\tsameParameters = false;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "+\t\t\t\t\t\t}", "+\t\t\t\t\tif (sameParameters)", "+\t\t\t\t\t\treturn type.getMethod(new String(selector), parameterTypes);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\treturn null;", "+\t}", "+", "+\tString[] parameterTypeSignatures = new String[length];", "+\tfor (int i = 0; i < length; i++) {", "+\t\tTypeReference parameterType = arguments[i].type;", "+\t\tchar[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');", "+\t\tfor (int j = 0; j < parameterType.dimensions(); j++)", "+\t\t\ttypeName = CharOperation.concat(typeName, \"[]\" .toCharArray()); //$NON-NLS-1$", "+\t\tparameterTypeSignatures[i] = Signature.createTypeSignature(typeName, false);", "+\t}", "+\treturn type.getMethod(new String(method.selector), parameterTypeSignatures);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d28a309c045a98ffdf3b95158ff4ad83", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": " \tBinaryTypeBinding cacheBinaryType(IType type) throws JavaModelException", "signatureAfterChange": " protected BinaryTypeBinding cacheBinaryType(IType type) throws JavaModelException", "diff": ["-\t */", "-\tBinaryTypeBinding cacheBinaryType(IType type) throws JavaModelException {", "-\t\tIType enclosingType = type.getDeclaringType();", "-\t\tif (enclosingType != null) {", "-\t\t\t// force caching of enclosing types first, so that binary type can be found in lookup enviroment", "-\t\t\tthis.cacheBinaryType(enclosingType);", "-\t\t}", "-\t\tIBinaryType binaryType = (IBinaryType)((BinaryType)type).getElementInfo();", "-\t\tBinaryTypeBinding binding = this.lookupEnvironment.cacheBinaryType(binaryType);", "-\t\tif (binding == null) { // it was already cached as a result of a previous query", "-\t\t\tchar[][] compoundName = CharOperation.splitOn('.', type.getFullyQualifiedName().toCharArray());", "-\t\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);", "-\t\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding)) {", "-\t\t\t\t// if the binding could be found and if it comes from a binary type,", "-\t\t\t\tbinding = (BinaryTypeBinding)referenceBinding;", "-\t\t\t}", "-\t\t}", "-\t\treturn binding;", "-\t}", "+ */", "+protected BinaryTypeBinding cacheBinaryType(IType type) throws JavaModelException {", "+\tIType enclosingType = type.getDeclaringType();", "+\tif (enclosingType != null)", "+\t\tcacheBinaryType(enclosingType); // cache enclosing types first, so that binary type can be found in lookup enviroment", "+\tIBinaryType binaryType = (IBinaryType) ((BinaryType) type).getElementInfo();", "+\tBinaryTypeBinding binding = this.lookupEnvironment.cacheBinaryType(binaryType);", "+\tif (binding == null) { // it was already cached as a result of a previous query", "+\t\tchar[][] compoundName = CharOperation.splitOn('.', type.getFullyQualifiedName().toCharArray());", "+\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);", "+\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding))", "+\t\t\tbinding = (BinaryTypeBinding) referenceBinding; // if the binding could be found and if it comes from a binary type", "+\t}", "+\treturn binding;", "+}"]}], "num": 68890}