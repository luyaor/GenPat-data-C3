{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0c71867c9ca45c8c160030da0ad76867", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c7a75f784730a40df50ed6ccea3469b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "diff": ["+// 8.4.8.4", "-\tint count = length;", "-\tint[] skip = new int[count];", "-\tnextMethod : for (int i = 0, l = length - 1; i < l; i++) {", "-\t\tif (skip[i] == -1) continue nextMethod;", "-\t\tMethodBinding method = methods[i];", "-\t\tMethodBinding[] duplicates = null;", "-\t\tfor (int j = i + 1; j <= l; j++) {", "-\t\t\tMethodBinding method2 = methods[j];", "-\t\t\tif (method.declaringClass == method2.declaringClass && areMethodsCompatible(method, method2)) {", "-\t\t\t\tskip[j] = -1;", "-\t\t\t\tif (duplicates == null)", "-\t\t\t\t\tduplicates = new MethodBinding[length];", "-\t\t\t\tduplicates[j] = method2;", "+\tboolean continueInvestigation = true;", "+\tMethodBinding concreteMethod = null;", "+\tfor (int i = 0; i < length; i++) {", "+\t\tif (!methods[i].isAbstract()) {", "+\t\t\tif (concreteMethod != null) {", "+\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, concreteMethod, methods[i]);", "+\t\t\t\tcontinueInvestigation = false;", "-\t\t}", "-\t\tif (duplicates != null) {", "-\t\t\t// found an inherited ParameterizedType that defines duplicate methods", "-\t\t\t// if all methods are abstract or more than 1 concrete method exists, then consider them to be duplicates", "-\t\t\t// if a single concrete method 'implements' the abstract methods, then do not report a duplicate error", "-\t\t\tint concreteCount = method.isAbstract() ? 0 : 1;", "-\t\t\tMethodBinding methodToKeep = method; // if a concrete method exists, keep it, otherwise keep the first method", "-\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "-\t\t\t\tif (duplicates[m] != null) {", "-\t\t\t\t\tif (!duplicates[m].isAbstract()) {", "-\t\t\t\t\t\tmethodToKeep = duplicates[m];", "-\t\t\t\t\t\tconcreteCount++;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (concreteCount != 1) {", "-\t\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "-\t\t\t\t\tif (duplicates[m] != null) {", "-\t\t\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, method, duplicates[m]);", "-\t\t\t\t\t\tcount--;", "-\t\t\t\t\t\tif (methodToKeep == duplicates[m])", "-\t\t\t\t\t\t\tmethods[i] = null;", "-\t\t\t\t\t\telse", "-\t\t\t\t\t\t\tmethods[m] = null;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tconcreteMethod = methods[i];", "-\tif (count < length) {", "-\t\tif (count == 1) return; // no need to continue since only 1 inherited method is left", "-\t\tMethodBinding[] newMethods = new MethodBinding[count];", "-\t\tfor (int i = length; --i >= 0;)", "-\t\t\tif (methods[i] != null)", "-\t\t\t\tnewMethods[--count] = methods[i];", "-\t\tmethods = newMethods;", "-\t\tlength = newMethods.length;", "+\tif (continueInvestigation) {", "+\t\tsuper.checkInheritedMethods(methods, length);", "-", "-\tsuper.checkInheritedMethods(methods, length);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e3e1d217829d92bb56eea1f1a43f3c5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "3363755daf5e11f7ba5c27ee1ed39285b9c60a26", "commitAfterChange": "b25ba34af45dc400b54fbb4a1c94812b44a4f39f", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "diff": ["-\tnextMethod : for (int i = 0, l = length - 1; i < l;) {", "-\t\tMethodBinding method = methods[i++];", "-\t\tfor (int j = i; j <= l; j++) {", "-\t\t\tif (method.declaringClass == methods[j].declaringClass && areMethodsEqual(method, methods[j])) {", "-\t\t\t\t// found an inherited ParameterizedType that defines duplicate methods", "-\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, method, methods[j]);", "-\t\t\t\tcount--;", "-\t\t\t\tmethods[i - 1] = null;", "-\t\t\t\tcontinue nextMethod;", "+\tint[] skip = new int[count];", "+\tnextMethod : for (int i = 0, l = length - 1; i < l; i++) {", "+\t\tif (skip[i] == -1) continue nextMethod;", "+\t\tMethodBinding method = methods[i];", "+\t\tMethodBinding[] duplicates = null;", "+\t\tfor (int j = i + 1; j <= l; j++) {", "+\t\t\tMethodBinding method2 = methods[j];", "+\t\t\tif (method.declaringClass == method2.declaringClass && areMethodsEqual(method, method2)) {", "+\t\t\t\tskip[j] = -1;", "+\t\t\t\tif (duplicates == null)", "+\t\t\t\t\tduplicates = new MethodBinding[length];", "+\t\t\t\tduplicates[j] = method2;", "+\t\t\t}", "+\t\t}", "+\t\tif (duplicates != null) {", "+\t\t\t// found an inherited ParameterizedType that defines duplicate methods", "+\t\t\t// if all methods are abstract or more than 1 concrete method exists, then consider them to be duplicates", "+\t\t\t// if a single concrete method 'implements' the abstract methods, then do not report a duplicate error", "+\t\t\tint concreteCount = method.isAbstract() ? 0 : 1;", "+\t\t\tMethodBinding methodToKeep = method; // if a concrete method exists, keep it, otherwise keep the first method", "+\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "+\t\t\t\tif (duplicates[m] != null) {", "+\t\t\t\t\tif (!duplicates[m].isAbstract()) {", "+\t\t\t\t\t\tmethodToKeep = duplicates[m];", "+\t\t\t\t\t\tconcreteCount++;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (concreteCount != 1) {", "+\t\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "+\t\t\t\t\tif (duplicates[m] != null) {", "+\t\t\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, method, duplicates[m]);", "+\t\t\t\t\t\tcount--;", "+\t\t\t\t\t\tif (methodToKeep == duplicates[m])", "+\t\t\t\t\t\t\tmethods[i] = null;", "+\t\t\t\t\t\telse", "+\t\t\t\t\t\t\tmethods[m] = null;", "+\t\t\t\t\t}", "+\t\t\t\t}"]}], "num": 70390}