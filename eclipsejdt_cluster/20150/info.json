{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "00e67445ddc2526bdf296ac94fd65ce7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c96ea8c007d577e4eec43ef7821ee05e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "6dc3139df48b05a697942ac75c097b0346555e03", "commitAfterChange": "68b132a771077222c8a489923225ada23ba86a6a", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod, LookupEnvironment env)", "signatureAfterChange": " protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod, LookupEnvironment env)", "diff": ["-\t\t\t} else if (sourceMethod != null && (parameter.tagBits & TagBits.AnnotationNonNull) != 0) {", "+\t\t\t} else if (sourceMethod != null && (parameter.tagBits & TagBits.AnnotationNonNull) != 0", "+\t\t\t\t\t\t\t&& sourceMethod.arguments[i].hasNullTypeAnnotation()) {", "-\t\t} else if (sourceMethod != null && (this.returnType.tagBits & TagBits.AnnotationNonNull) != 0) {", "+\t\t} else if (sourceMethod instanceof MethodDeclaration && (this.returnType.tagBits & TagBits.AnnotationNonNull) != 0 ", "+\t\t\t\t\t\t&& ((MethodDeclaration)sourceMethod).hasNullTypeAnnotation()) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e3dce94bad88075e1378bfa67104774e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java", "commitBeforeChange": "c58f46702a3cd6fb013870c57db58066e2c73fbe", "commitAfterChange": "5dcad0acfcfbe8755abd38f2836e8e0329153a35", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType, \t\tExpression expression)", "signatureAfterChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType, \t\tExpression expression)", "diff": ["-\t\t\t} else if (use15specifics) { // unboxing - only exact match is allowed", "-\t\t\t\tif (env.computeBoxingType(expressionType) == castType) {", "-\t\t\t\t\t// TODO (philippe) could tagAsUnnecessaryCast(scope, castType);  ", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\treturn false;", "-\t\t} else if (use15specifics && expressionType.isBaseType()) { // boxing - only exact match is allowed", "-\t\t\tif (env.computeBoxingType(castType) == expressionType) {", "-\t\t\t\t// TODO (philippe) could tagAsUnnecessaryCast(scope, castType);  ", "+\t\t\t} else if (use15specifics ", "+\t\t\t\t\t\t\t\t&& env.computeBoxingType(expressionType).isCompatibleWith(castType)) { // unboxing - only widening match is allowed", "+\t\t\t\ttagAsUnnecessaryCast(scope, castType);  ", "+\t\t\treturn false;", "+\t\t} else if (use15specifics ", "+\t\t\t\t\t\t\t&& expressionType.isBaseType() ", "+\t\t\t\t\t\t\t&& env.computeBoxingType(castType) == expressionType) { // boxing - only exact match is allowed", "+\t\t\ttagAsUnnecessaryCast(scope, castType);  ", "+\t\t\treturn true;"]}], "num": 20150}