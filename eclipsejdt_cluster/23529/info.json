{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "79a5fa42e03c2b0941bde982e1f479ac", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4baceb6827f7e2feacdd5ba32cc2035f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "50431e234c5ece34d7b8d3e0af32a86a5079d5cd", "commitAfterChange": "e87f626a0744f3e42bfbad630a4e9545c488a83d", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 43, "signatureBeforeChange": " \tprivate void reconcileClasspathFileUpdate(IResourceDelta delta, IFile file, JavaProject project)", "signatureAfterChange": " \tvoid reconcileClasspathFileUpdate(IResourceDelta delta, JavaProject project)", "diff": ["-\tprivate void reconcileClasspathFileUpdate(IResourceDelta delta, IFile file, JavaProject project) {", "-\t\t\t", "-\t\tswitch (delta.getKind()) {", "-\t\t\tcase IResourceDelta.REMOVED : // recreate one based on in-memory classpath", "-\t\t\t\ttry {", "-\t\t\t\t\tJavaModelManager.PerProjectInfo info = JavaModelManager.getJavaModelManager().getPerProjectInfoCheckExistence(project.getProject());", "-\t\t\t\t\tif (info.classpath != null) { // if there is an in-memory classpath", "-\t\t\t\t\t\tproject.saveClasspath(info.classpath, info.outputLocation);", "-\t\t\t\t\t}", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\tUtil.log(e, \"Could not save classpath for \"+ project.getPath()); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase IResourceDelta.CHANGED :", "-\t\t\t\tif ((delta.getFlags() & IResourceDelta.CONTENT) == 0  // only consider content change", "-\t\t\t\t\t\t&& (delta.getFlags() & IResourceDelta.MOVED_FROM) == 0) // and also move and overide scenario (see http://dev.eclipse.org/bugs/show_bug.cgi?id=21420)", "-\t\t\t\t\tbreak;", "-\t\t\tcase IResourceDelta.ADDED :", "-\t\t\t\t// check if any actual difference", "-\t\t\t\tproject.flushClasspathProblemMarkers(false, true);", "-\t\t\t\tboolean wasSuccessful = false; // flag recording if .classpath file change got reflected", "-\t\t\t\ttry {", "-\t\t\t\t\t// force to (re)read the property file", "-\t\t\t\t\tIClasspathEntry[] fileEntries = project.readClasspathFile(true/*create markers*/, false/*don't log problems*/);", "-\t\t\t\t\tif (fileEntries == null)", "-\t\t\t\t\t\tbreak; // could not read, ignore ", "-\t\t\t\t\tJavaModelManager.PerProjectInfo info = JavaModelManager.getJavaModelManager().getPerProjectInfoCheckExistence(project.getProject());", "-\t\t\t\t\tif (info.classpath != null) { // if there is an in-memory classpath", "-\t\t\t\t\t\tif (project.isClasspathEqualsTo(info.classpath, info.outputLocation, fileEntries)) {", "-\t\t\t\t\t\t\twasSuccessful = true;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\tvoid reconcileClasspathFileUpdate(IResourceDelta delta, JavaProject project) {", "-\t\t\t\t\t// will force an update of the classpath/output location based on the file information", "-\t\t\t\t\t// extract out the output location", "-\t\t\t\t\tIPath outputLocation = null;", "-\t\t\t\t\tif (fileEntries != null && fileEntries.length > 0) {", "-\t\t\t\t\t\tIClasspathEntry entry = fileEntries[fileEntries.length - 1];", "-\t\t\t\t\t\tif (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {", "-\t\t\t\t\t\t\toutputLocation = entry.getPath();", "-\t\t\t\t\t\t\tIClasspathEntry[] copy = new IClasspathEntry[fileEntries.length - 1];", "-\t\t\t\t\t\t\tSystem.arraycopy(fileEntries, 0, copy, 0, copy.length);", "-\t\t\t\t\t\t\tfileEntries = copy;", "+\t\tboolean reloadClasspath = true;", "+\t\tif (delta != null) {", "+\t\t\treloadClasspath = false; // narrow down need to reload based on delta", "+\t\t\tswitch (delta.getKind()) {", "+\t\t\t\tcase IResourceDelta.REMOVED : // recreate one based on in-memory classpath", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tJavaModelManager.PerProjectInfo info = JavaModelManager.getJavaModelManager().getPerProjectInfoCheckExistence(project.getProject());", "+\t\t\t\t\t\tif (info.classpath != null) { // if there is an in-memory classpath", "+\t\t\t\t\t\t\tproject.saveClasspath(info.classpath, info.outputLocation);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\tif (project.getProject().isAccessible()) {", "+\t\t\t\t\t\t\tUtil.log(e, \"Could not save classpath for \"+ project.getPath()); //$NON-NLS-1$", "-\t\t\t\t\t// restore output location\t\t\t\t", "-\t\t\t\t\tif (outputLocation == null) {", "-\t\t\t\t\t\toutputLocation = SetClasspathOperation.ReuseOutputLocation;", "-\t\t\t\t\t\t// clean mode will also default to reusing current one", "-\t\t\t\t\t}", "-\t\t\t\t\tproject.setRawClasspath(", "-\t\t\t\t\t\tfileEntries, ", "-\t\t\t\t\t\toutputLocation, ", "-\t\t\t\t\t\tnull, // monitor", "-\t\t\t\t\t\ttrue, // canChangeResource", "-\t\t\t\t\t\tproject.getResolvedClasspath(true), // ignoreUnresolvedVariable", "-\t\t\t\t\t\ttrue, // needValidation", "-\t\t\t\t\t\tfalse); // no need to save", "-\t\t\t\t\t", "-\t\t\t\t\t// if reach that far, the classpath file change got absorbed", "-\t\t\t\t\twasSuccessful = true;", "-\t\t\t\t} catch (RuntimeException e) {", "-\t\t\t\t\t// setRawClasspath might fire a delta, and a listener may throw an exception", "-\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\tUtil.log(e, \"Could not set classpath for \"+ project.getPath()); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t} catch (JavaModelException e) { // CP failed validation", "-\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\tif (e.getJavaModelStatus().getException() instanceof CoreException) {", "-\t\t\t\t\t\t\t// happens if the .classpath could not be written to disk", "-\t\t\t\t\t\t\tproject.createClasspathProblemMarker(new JavaModelStatus(", "-\t\t\t\t\t\t\t\t\tIJavaModelStatusConstants.INVALID_CLASSPATH_FILE_FORMAT,", "-\t\t\t\t\t\t\t\t\tUtil.bind(\"classpath.couldNotWriteClasspathFile\", project.getElementName(), e.getMessage()))); //$NON-NLS-1$", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tproject.createClasspathProblemMarker(new JavaModelStatus(", "-\t\t\t\t\t\t\t\t\tIJavaModelStatusConstants.INVALID_CLASSPATH_FILE_FORMAT,", "-\t\t\t\t\t\t\t\t\tUtil.bind(\"classpath.invalidClasspathInClasspathFile\", project.getElementName(), e.getMessage()))); //$NON-NLS-1$", "-\t\t\t\t\t\t}\t\t\t", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t\t\t\t} finally {", "-\t\t\t\t\tif (!wasSuccessful) { ", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tproject.setRawClasspath0(JavaProject.INVALID_CLASSPATH);", "-\t\t\t\t\t\t\tproject.updatePackageFragmentRoots();", "-\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t\tcase IResourceDelta.CHANGED :", "+\t\t\t\t\tif ((delta.getFlags() & IResourceDelta.CONTENT) == 0  // only consider content change", "+\t\t\t\t\t\t\t&& (delta.getFlags() & IResourceDelta.MOVED_FROM) == 0) // and also move and overide scenario (see http://dev.eclipse.org/bugs/show_bug.cgi?id=21420)", "+\t\t\t\t\t\tbreak;", "+\t\t\t\tcase IResourceDelta.ADDED :", "+\t\t\t\t\treloadClasspath = true;", "+\t\t\t}", "+\t\t}", "+\t\tif (reloadClasspath) {", "+\t\t\ttry {", "+\t\t\t\tproject.forceClasspathReload(null);", "+\t\t\t} catch (RuntimeException e) {", "+\t\t\t} catch (JavaModelException e) {\t", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9580a806f412be61244b877f9ec112a5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "2e8c81b48304c9e33747060a2a7fcd8295c64afe", "commitAfterChange": "50125dca81221f803e384aaa4267a637e226f1c2", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic void performPreBuildCheck( \t\tIResourceDelta delta, \t\tIJavaElement parent)", "signatureAfterChange": " \tpublic void performPreBuildCheck( \t\tIResourceDelta delta, \t\tIJavaElement parent)", "diff": ["-\t\t\t\t\t/* check classpath property file change */", "-\t\t\t\t\tif (file.getName().equals(", "-\t\t\t\t\t\t\tproject.computeSharedPropertyFileName(", "-\t\t\t\t\t\t\t\tproject.getClasspathPropertyName()))) {", "-\t", "-\t\t\t\t\t\tswitch (delta.getKind()) {", "-\t\t\t\t\t\t\tcase IResourceDelta.REMOVED : // recreate one based on in-memory path", "-\t\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\t\tproject.saveClasspath(project.getRawClasspath(), project.getOutputLocation());", "-\t\t\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\t\t\t\t\tUtil.log(e, \"Could not save classpath for \"+ project.getPath()); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase IResourceDelta.CHANGED :", "-\t\t\t\t\t\t\t\tif ((delta.getFlags() & IResourceDelta.CONTENT) == 0  // only consider content change", "-\t\t\t\t\t\t\t\t\t\t&& (delta.getFlags() & IResourceDelta.MOVED_FROM) == 0) // and also move and overide scenario (see http://dev.eclipse.org/bugs/show_bug.cgi?id=21420)", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase IResourceDelta.ADDED :", "-\t\t\t\t\t\t\t\t// check if any actual difference", "-\t\t\t\t\t\t\t\tproject.flushClasspathProblemMarkers(false, true);", "-\t\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\t\t// force to (re)read the property file", "-\t\t\t\t\t\t\t\t\tIClasspathEntry[] fileEntries = null;", "-\t\t\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\t\t\tString fileClasspathString = project.loadClasspath();", "-\t\t\t\t\t\t\t\t\t\tif (fileClasspathString != null) {", "-\t\t\t\t\t\t\t\t\t\t\tfileEntries = project.readPaths(fileClasspathString);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t} catch(JavaModelException e) {", "-\t\t\t\t\t\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\t\t\t\t\t\tUtil.log(e, ", "-\t\t\t\t\t\t\t\t\t\t\t\t\"Exception while retrieving \"+ project.getPath() //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\t\t\t+\"/.classpath, ignore change\"); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tproject.createClasspathProblemMarker(", "-\t\t\t\t\t\t\t\t\t\t\tUtil.bind(\"classpath.cannotReadClasspathFile\", project.getElementName()), //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\t\tIMarker.SEVERITY_ERROR,", "-\t\t\t\t\t\t\t\t\t\t\tfalse,\t//  cycle error", "-\t\t\t\t\t\t\t\t\t\t\ttrue);\t//\tfile format error", "-\t\t\t\t\t\t\t\t\t} catch (IOException e) {", "-\t\t\t\t\t\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\t\t\t\t\t\tUtil.log(e, ", "-\t\t\t\t\t\t\t\t\t\t\t\t\"Exception while retrieving \"+ project.getPath() //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\t\t\t+\"/.classpath, ignore change\"); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tproject.createClasspathProblemMarker(", "-\t\t\t\t\t\t\t\t\t\t\tUtil.bind(\"classpath.cannotReadClasspathFile\", project.getElementName()), //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\t\tIMarker.SEVERITY_ERROR,", "-\t\t\t\t\t\t\t\t\t\t\tfalse,\t//  cycle error", "-\t\t\t\t\t\t\t\t\t\t\ttrue);\t//\tfile format error", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tif (fileEntries == null)", "-\t\t\t\t\t\t\t\t\t\tbreak; // could not read, ignore ", "-\t\t\t\t\t\t\t\t\tif (project.isClasspathEqualsTo(project.getRawClasspath(), project.getOutputLocation(), fileEntries))", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t", "-\t\t\t\t\t\t\t\t\t// will force an update of the classpath/output location based on the file information", "-\t\t\t\t\t\t\t\t\t// extract out the output location", "-\t\t\t\t\t\t\t\t\tIPath outputLocation = null;", "-\t\t\t\t\t\t\t\t\tif (fileEntries != null && fileEntries.length > 0) {", "-\t\t\t\t\t\t\t\t\t\tIClasspathEntry entry = fileEntries[fileEntries.length - 1];", "-\t\t\t\t\t\t\t\t\t\tif (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {", "-\t\t\t\t\t\t\t\t\t\t\toutputLocation = entry.getPath();", "-\t\t\t\t\t\t\t\t\t\t\tIClasspathEntry[] copy = new IClasspathEntry[fileEntries.length - 1];", "-\t\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(fileEntries, 0, copy, 0, copy.length);", "-\t\t\t\t\t\t\t\t\t\t\tfileEntries = copy;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t// restore output location\t\t\t\t", "-\t\t\t\t\t\t\t\t\tif (outputLocation == null) {", "-\t\t\t\t\t\t\t\t\t\toutputLocation = SetClasspathOperation.ReuseOutputLocation;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tproject.setRawClasspath(", "-\t\t\t\t\t\t\t\t\t\tfileEntries, ", "-\t\t\t\t\t\t\t\t\t\toutputLocation, ", "-\t\t\t\t\t\t\t\t\t\tnull, // monitor", "-\t\t\t\t\t\t\t\t\t\ttrue, // canChangeResource", "-\t\t\t\t\t\t\t\t\t\tfalse, // forceSave", "-\t\t\t\t\t\t\t\t\t\tproject.getResolvedClasspath(true), // ignoreUnresolvedVariable", "-\t\t\t\t\t\t\t\t\t\ttrue); // needValidation", "-\t\t\t\t\t\t\t\t} catch (RuntimeException e) {", "-\t\t\t\t\t\t\t\t\t// setRawClasspath might fire a delta, and a listener may throw an exception", "-\t\t\t\t\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\t\t\t\t\tUtil.log(e, \"Could not set classpath for \"+ project.getPath()); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t\t\t\t\t// happens if the .classpath could not be written to disk", "-\t\t\t\t\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\t\t\t\t\tUtil.log(e, \"Could not set classpath for \"+ project.getPath()); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t}", "-\t", "-\t\t\t\t\t\t}", "+\t\t\t\t\t/* check classpath file change */", "+\t\t\t\t\tif (file.getName().equals(JavaProject.CLASSPATH_FILENAME)) {", "+\t\t\t\t\t\treconcileClasspathFileUpdate(delta, file, project);", "+\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t/* check custom preference file change */", "+//\t\t\t\t\tif (file.getName().equals(JavaProject.PREF_FILENAME)) {", "+//\t\t\t\t\t\treconcilePreferenceFileUpdate(delta, file, project);", "+//\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t}"]}], "num": 23529}