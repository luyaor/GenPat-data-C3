{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2d9bc134acda571af605837701774704", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "02730626b1b10d44a495e8c358e8ff0a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "e58f2038b180bd18be0d01efd245c2dfe6cd7c52", "commitAfterChange": "d5b7a7df240100471f0f4fc25ca0d59acd7e1502", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r \t\r \tpublic static CompilationUnitDeclaration parse(char[] source)", "signatureAfterChange": "\r \t\r \tpublic static CompilationUnitDeclaration parse(char[] source)", "diff": ["-\t\treturn parser.parse(sourceUnit, new CompilationResult(sourceUnit, 0, 0));\r", "+\t\tCompilationUnitDeclaration compilationUnitDeclaration = parser.dietParse(sourceUnit, new CompilationResult(sourceUnit, 0, 0));\r", "+\t\t\r", "+\t\tif (compilationUnitDeclaration.ignoreMethodBodies) {\r", "+\t\t\tcompilationUnitDeclaration.ignoreFurtherInvestigation = true;\r", "+\t\t\t// if initial diet parse did not work, no need to dig into method bodies.\r", "+\t\t\treturn compilationUnitDeclaration; \r", "+\t\t}\r", "+\t\t\r", "+\t\t//fill the methods bodies in order for the code to be generated\r", "+\t\t//real parse of the method....\r", "+\t\tparser.scanner.setSourceBuffer(source);\r", "+\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = compilationUnitDeclaration.types;\r", "+\t\tif (types != null) {\r", "+\t\t\tfor (int i = types.length; --i >= 0;)\r", "+\t\t\t\ttypes[i].parseMethod(parser, compilationUnitDeclaration);\r", "+\t\t}\r", "+\t\treturn compilationUnitDeclaration;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a64209c2f8a25c2699ee2a27e1ec387", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "0307cad3f1b01ed5d7ce67bc78cd9b706e4819f3", "commitAfterChange": "7a57dee588cd632418aaf1f630bac2c2a5d6439a", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 18, "signatureBeforeChange": "  \tpublic static CompilationUnitDeclaration parse(char[] source, NodeSearcher nodeSearcher, Map settings)", "signatureAfterChange": "\t \t \tpublic static CompilationUnitDeclaration parse(char[] source, NodeSearcher nodeSearcher, Map settings)", "diff": ["-", "-\t\tint searchPosition = nodeSearcher.position;", "-\t\tif (searchPosition < 0 || searchPosition > source.length) {", "-\t\t\t// the position is out of range. There is no need to search for a node.", "- \t\t\treturn compilationUnitDeclaration;", "-\t\t}", "-\t", "-\t\tcompilationUnitDeclaration.traverse(nodeSearcher, compilationUnitDeclaration.scope);", "+\t\tif (nodeSearcher != null) {", "+\t\t\tint searchPosition = nodeSearcher.position;", "+\t\t\tif (searchPosition < 0 || searchPosition > source.length) {", "+\t\t\t\t// the position is out of range. There is no need to search for a node.", "+\t \t\t\treturn compilationUnitDeclaration;", "+\t\t\t}", "-\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode node = nodeSearcher.found;", "- \t\tif (node == null) {", "- \t\t\treturn compilationUnitDeclaration;", "- \t\t}", "- \t\t", "- \t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "- \t\t", "-\t\tif (node instanceof AbstractMethodDeclaration) {", "-\t\t\t((AbstractMethodDeclaration)node).parseStatements(parser, compilationUnitDeclaration);", "-\t\t} else if (enclosingTypeDeclaration != null) {", "-\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "-\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(parser, enclosingTypeDeclaration, compilationUnitDeclaration);", "-\t\t\t} else {  \t\t\t\t\t", "-\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(parser, compilationUnitDeclaration);", "-\t\t\t} \t\t\t\t", "+\t\t\tcompilationUnitDeclaration.traverse(nodeSearcher, compilationUnitDeclaration.scope);", "+\t\t\t", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode node = nodeSearcher.found;", "+\t \t\tif (node == null) {", "+\t \t\t\treturn compilationUnitDeclaration;", "+\t \t\t}", "+\t \t\t", "+\t \t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "+\t \t\t", "+\t\t\tif (node instanceof AbstractMethodDeclaration) {", "+\t\t\t\t((AbstractMethodDeclaration)node).parseStatements(parser, compilationUnitDeclaration);", "+\t\t\t} else if (enclosingTypeDeclaration != null) {", "+\t\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "+\t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(parser, enclosingTypeDeclaration, compilationUnitDeclaration);", "+\t\t\t\t} else {  \t\t\t\t\t", "+\t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(parser, compilationUnitDeclaration);", "+\t\t\t\t} \t\t\t\t", "+\t\t\t}", "+\t\t} else {", "+\t\t\t//fill the methods bodies in order for the code to be generated", "+\t\t\t//real parse of the method....", "+\t\t\tparser.scanner.setSource(source);", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = compilationUnitDeclaration.types;", "+\t\t\tif (types != null) {", "+\t\t\t\tfor (int i = types.length; --i >= 0;)", "+\t\t\t\t\ttypes[i].parseMethod(parser, compilationUnitDeclaration);", "+\t\t\t}", "-\t\t", "-\t}"]}], "num": 15551}