{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9496021c4be499a96915e9238ea9485b", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "03ddb4b175aab82d6487b170b17900b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "eedafe9176d5ca60193623550822839844fd4aae", "commitAfterChange": "16a0328cb89c7e4d508e8edfc85e1af4879c13c7", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic boolean equals(Object object)", "signatureAfterChange": " \tpublic boolean equals(Object object)", "diff": ["-\t\t\tIPath[] otherIncludes = otherEntry.getInclusionPatterns();", "-\t\t\tif (this.inclusionPatterns != otherIncludes){", "-\t\t\t    if (this.inclusionPatterns == null) return false;", "-\t\t\t\tint includeLength = this.inclusionPatterns.length;", "-\t\t\t\tif (otherIncludes == null || otherIncludes.length != includeLength) ", "-\t\t\t\t\treturn false;", "-\t\t\t\tfor (int i = 0; i < includeLength; i++) {", "-\t\t\t\t\t// compare toStrings instead of IPaths ", "-\t\t\t\t\t// since IPath.equals is specified to ignore trailing separators", "-\t\t\t\t\tif (!this.inclusionPatterns[i].toString().equals(otherIncludes[i].toString()))", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\tIPath[] otherExcludes = otherEntry.getExclusionPatterns();", "-\t\t\tif (this.exclusionPatterns != otherExcludes){", "-\t\t\t    if (this.exclusionPatterns == null) return false;", "-\t\t\t\tint excludeLength = this.exclusionPatterns.length;", "-\t\t\t\tif (otherExcludes == null || otherExcludes.length != excludeLength) ", "-\t\t\t\t\treturn false;", "-\t\t\t\tfor (int i = 0; i < excludeLength; i++) {", "-\t\t\t\t\t// compare toStrings instead of IPaths ", "-\t\t\t\t\t// since IPath.equals is specified to ignore trailing separators", "-\t\t\t\t\tif (!this.exclusionPatterns[i].toString().equals(otherExcludes[i].toString()))", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tif (!equalPatterns(this.inclusionPatterns, otherEntry.getInclusionPatterns()))", "+\t\t\t\treturn false;", "+\t\t\tif (!equalPatterns(this.exclusionPatterns, otherEntry.getExclusionPatterns()))", "+\t\t\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f04f182591a6bfa078ad23796785343", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/AllPerformanceTests.java", "commitBeforeChange": "beddf7ea3209e604e7dd085747cac8c41b2dfbd0", "commitAfterChange": "cafda46507ac63768e17397affc84b63092c7e46", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic static Test suite()", "signatureAfterChange": " \tpublic static Test suite()", "diff": ["-\t\tint length = 0;", "-\t\ttry {", "-\t\t\tlength = Integer.parseInt(LENGTH);", "-\t\t\tif (length<=0 || length>testSuites.length)", "-\t\t\t\tlength = testSuites.length;", "-\t\t} catch (NumberFormatException e1) {", "-\t\t\tlength = testSuites.length;", "-\t\t}", "-\t\tif (ADDITIONAL != null) {", "-\t\t\tint pos = -1;", "+\t\tint length = testSuites.length;", "+\t\tif (ADD) {", "-\t\t\t\tpos = Integer.parseInt(ADDITIONAL);", "-\t\t\t\tint cl = complete.length;", "-\t\t\t\tClass[] newSuites = new Class[length+cl];", "-\t\t\t\tif (pos <= 0) {", "-\t\t\t\t\tSystem.arraycopy(complete, 0, newSuites, 0, cl);", "-\t\t\t\t\tSystem.arraycopy(testSuites, 0, newSuites, cl, length);", "-\t\t\t\t} else if (pos >= length) {", "-\t\t\t\t\tSystem.arraycopy(testSuites, 0, newSuites, 0, length);", "-\t\t\t\t\tSystem.arraycopy(complete, 0, newSuites, length, cl);", "-\t\t\t\t} else {", "-\t\t\t\t\tfor (int i=0; i<pos; i++)", "-\t\t\t\t\t\tnewSuites[i] = testSuites[i];", "-\t\t\t\t\tfor (int i=pos; i<pos+cl; i++)", "-\t\t\t\t\t\tnewSuites[i] = complete[i-pos];", "-\t\t\t\t\tfor (int i=pos+cl; i<length+cl; i++)", "-\t\t\t\t\t\tnewSuites[i] = testSuites[i-cl];", "-\t\t\t\t}", "+\t\t\t\tint completeLength = complete.length;", "+\t\t\t\tClass[] newSuites = new Class[length+completeLength];", "+\t\t\t\tSystem.arraycopy(testSuites, 0, newSuites, 0, length);", "+\t\t\t\tSystem.arraycopy(complete, 0, newSuites, length, completeLength);", "+", "+\t\t// Get suite acronym", "+\t\tString suitesAcronym = \"\";", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tString name = FullSourceWorkspaceTests.suiteTypeShortName(testSuites[i]);", "+\t\t\tif (name != null) {", "+\t\t\t\tsuitesAcronym += name.substring(0, 1);", "+\t\t\t}", "+\t\t}", "+\t\tFullSourceWorkspaceTests.RUN_ID = suitesAcronym; //.toLowerCase();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "57e34a27caf8c6e87e6dbb0f09b45748", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java", "commitBeforeChange": "457fc77ec96140a15fc3e1c18bbf7bf53c7ea1c9", "commitAfterChange": "44074e366655e2cf89768617c1e64463f5949123", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 16, "signatureBeforeChange": " public int resolveLevel(Binding binding)", "signatureAfterChange": " public int resolveLevel(Binding binding)", "diff": ["-\tMethodBinding method = ((MethodBinding) binding).original();", "-\tif (!method.isConstructor()) return IMPOSSIBLE_MATCH;", "-", "-\t// declaring type, simple name has already been matched by matchIndexEntry()", "-\tint level = resolveLevelForType(this.pattern.declaringSimpleName, this.pattern.declaringQualification, method.declaringClass);", "-\tif (level == IMPOSSIBLE_MATCH) return IMPOSSIBLE_MATCH;", "-", "-\t// parameter types", "-\tint parameterCount = this.pattern.parameterSimpleNames == null ? -1 : this.pattern.parameterSimpleNames.length;", "-\tif (parameterCount > -1) {", "-\t\tif (method.parameters == null) return INACCURATE_MATCH;", "-\t\tif (parameterCount != method.parameters.length) return IMPOSSIBLE_MATCH;", "-\t\tfor (int i = 0; i < parameterCount; i++) {", "-\t\t\tint newLevel = resolveLevelForType(this.pattern.parameterSimpleNames[i], this.pattern.parameterQualifications[i], method.parameters[i]);", "-\t\t\tif (level > newLevel) {", "-\t\t\t\tif (newLevel == IMPOSSIBLE_MATCH) return IMPOSSIBLE_MATCH;", "-\t\t\t\tlevel = newLevel; // can only be downgraded", "-\t\t\t}", "+\tMethodBinding constructor = (MethodBinding) binding;", "+\tint level= matchConstructor(constructor);", "+\tif (level== IMPOSSIBLE_MATCH) {", "+\t\tif (constructor != constructor.original()) {", "+\t\t\tlevel= matchConstructor(constructor.original());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c477fa73e0d6eae42d1548d215c68c3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java", "commitBeforeChange": "029a8f257514071d898cccd4122bad881aa576bc", "commitAfterChange": "89f5de86dbcff10e0a2f2dafa846f8c01996e885", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 4, "signatureBeforeChange": "   public NameEnvironmentAnswer findClass(String sourceFileWithoutExtension, String qualifiedPackageName, String qualifiedSourceFileWithoutExtension)", "signatureAfterChange": "   public NameEnvironmentAnswer findClass(String sourceFileWithoutExtension, String qualifiedPackageName, String qualifiedSourceFileWithoutExtension)", "diff": ["-\t", "-\tString sourceFolderPath = this.sourceFolder.getFullPath().toString() + IPath.SEPARATOR;", "-\tchar[][] javaLikeExtensions = Util.getJavaLikeExtensions();", "-\tfor (int i = 0, length = javaLikeExtensions.length; i < length; i++) {", "-\t\tString extension = '.' + new String(javaLikeExtensions[i]);", "-\t\tString sourceFileName = sourceFileWithoutExtension + extension;", "-\t\tif (!doesFileExist(sourceFileName, qualifiedPackageName)) continue; // most common case", "-\t", "-\t\tString qualifiedSourceFileName = qualifiedSourceFileWithoutExtension + extension;", "-\t\tif (org.eclipse.jdt.internal.compiler.util.Util.isExcluded((sourceFolderPath + qualifiedSourceFileName).toCharArray(), this.fulInclusionPatternChars, this.fullExclusionPatternChars, false/*not a folder path*/))", "-\t\t\tcontinue;", "-\t\tIPath path = new Path(qualifiedSourceFileName);", "-\t\tIFile file = this.sourceFolder.getFile(path);", "-\t\treturn new NameEnvironmentAnswer(new ResourceCompilationUnit(file), null /* no access restriction */);", "+\tSimpleLookupTable dirTable = directoryTable(qualifiedPackageName);", "+\tif (dirTable != null && dirTable.elementSize > 0) {", "+\t\tIFile file = (IFile) dirTable.get(sourceFileWithoutExtension);", "+\t\tif (file != null) {", "+\t\t\treturn new NameEnvironmentAnswer(new ResourceCompilationUnit(file), null /* no access restriction */);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6ef92e9d85c5c003d3413c12be76a9d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "c9df47e6bc4127d80d1e16ea8353f464e792fda3", "commitAfterChange": "514d8e9afb885d3be64fa67a03a4dd281867840f", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tpublic MethodBinding findDefaultAbstractMethod( \t\tReferenceBinding receiverType,  \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite, \t\tReferenceBinding classHierarchyStart, \t\tMethodBinding matchingMethod, \t\tObjectVector found)", "signatureAfterChange": " \tprotected MethodBinding findDefaultAbstractMethod( \t\tReferenceBinding receiverType,  \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite, \t\tReferenceBinding classHierarchyStart, \t\tObjectVector found)", "diff": ["-\tpublic MethodBinding findDefaultAbstractMethod(", "+\tprotected MethodBinding findDefaultAbstractMethod(", "-\t\tMethodBinding matchingMethod,", "-\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);", "+\t\t\tfindMethodInSuperInterfaces(currentType, selector, found);", "-\t\tif (foundSize == startFoundSize) {", "-\t\t\tif (matchingMethod != null)", "-\t\t\t\tunitScope.recordTypeReferences(matchingMethod.thrownExceptions);", "-\t\t\treturn matchingMethod; // maybe null", "-\t\t}", "-\t\tMethodBinding[] candidates = new MethodBinding[foundSize - startFoundSize];", "+\t\tif (foundSize == startFoundSize)", "+\t\t\treturn null;", "+\t\tMethodBinding[] candidates = null;", "-\t\t\t\tif (compatibleMethod.isValidBinding())", "+\t\t\t\tif (compatibleMethod.isValidBinding()) {", "+\t\t\t\t\tif (candidatesCount == 0)", "+\t\t\t\t\t\tcandidates = new MethodBinding[foundSize - startFoundSize];", "-\t\t\t\telse if (problemMethod == null)", "+\t\t\t\t} else if (problemMethod == null) {", "+\t\t\t\t}", "-\t\tif (candidatesCount == 0) { // try to find a close match when the parameter order is wrong or missing some parameters", "-\t\t\tif (problemMethod != null) return problemMethod;", "-\t\t\tint argLength = argumentTypes.length;", "-\t\t\tnextMethod : for (int i = 0; i < foundSize; i++) {", "-\t\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);", "-\t\t\t\tTypeBinding[] params = methodBinding.parameters;", "-\t\t\t\tint paramLength = params.length;", "-\t\t\t\tnextArg: for (int a = 0; a < argLength; a++) {", "-\t\t\t\t\tTypeBinding arg = argumentTypes[a];", "-\t\t\t\t\tfor (int p = 0; p < paramLength; p++)", "-\t\t\t\t\t\tif (params[p] == arg)", "-\t\t\t\t\t\t\tcontinue nextArg;", "-\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t}", "-\t\t\t\treturn methodBinding;", "-\t\t\t}", "-\t\t\treturn (MethodBinding) found.elementAt(0); // no good match so just use the first one found", "-\t\t}", "+\t\tif (candidatesCount == 0)", "+\t\t\treturn problemMethod; // can be null", "-\t\tboolean isCompliant14 = compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4;", "-\t\tif (isCompliant14)", "+\t\tif (compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "77e891008daf472f180893870ee22d9b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/ProcessorEnvImpl.java", "commitBeforeChange": "c87413f1c3fa777cce7cb1df06542ffdf2ba70ba", "commitAfterChange": "dbb59802bd05ea277b4706afb85d6b75d5bdff2a", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": " \t \tpublic void setFileProcessing(IFile file)", "signatureAfterChange": " \t \tpublic void setFileProcessing(IFile file)", "diff": ["-\t\t// already in per-file mode.", "-\t\tif( !_batchMode ){", "-\t\t\t// this is a no-op", "-\t\t\tif(  file.equals(_file) )", "-\t\t\t\treturn;", "-\t\t\t", "-\t\t\t_astRoot = null;", "-\t\t\t_file = null;", "-\t\t\t_curSource = null;", "-\t\t\t", "-\t\t\t// need to match up the file with the ast.", "-\t\t\tif( _files != null ){", "-\t\t\t\tfor( int i=0, len=_files.length; i<len; i++ ){", "-\t\t\t\t\tif( file.equals(_files[i]) ){", "-\t\t\t\t\t\t_file = file;", "-\t\t\t\t\t\tif( _astUnits != null ){", "-\t\t\t\t\t\t\t_astRoot = _astUnits[i];\t\t", "-\t\t\t\t\t\t\t_curSource = _sources[i];", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\telse{", "-\t\t\t\t\t\t\ttry{", "-\t\t\t\t\t\t\t\t_curSource = ProcessorEnvImpl.getFileContents( _files[i] );", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tcatch( Exception e ){", "-\t\t\t\t\t\t\t\t// TODO:  propagate these exceptions out of APTDispatch", "-\t\t\t\t\t\t\t\te.printStackTrace();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t_astRoot = (CompilationUnit)createDietAST(_files[i].toString(), _javaProject, null, _curSource );", "-\t\t\t\t\t\t}", "+\t\t_batchMode = false;", "+\t\tif( file.equals(_file) ) // this is a no-op", "+\t\t\treturn;", "+\t\t", "+\t\t_astRoot = null;", "+\t\t_file = null;", "+\t\t_unit = null;", "+\t\t", "+\t\t// need to match up the file with the ast.", "+\t\tif( _files != null ){", "+\t\t\tfor( int i=0, len=_files.length; i<len; i++ ){", "+\t\t\t\tif( file.equals(_files[i]) ){", "+\t\t\t\t\t_file = file;", "+\t\t\t\t\tif( _astUnits != null ){", "+\t\t\t\t\t\t_astRoot = _astUnits[i];\t\t", "+\t\t\t\t\t\t_unit = _units[i];", "+\t\t\t\t\t}", "+\t\t\t\t\telse{", "+\t\t\t\t\t\t_unit = JavaCore.createCompilationUnitFrom(_files[i]);", "+\t\t\t\t\t\t_astRoot = createDietAST(_javaProject, _unit);", "- ", "-\t\t\tif( _file == null )", "-\t\t\t\tthrow new IllegalStateException(", "-\t\t\t\t\t\t\"file \" +  //$NON-NLS-1$", "-\t\t\t\t\t\tfile.getName() + ", "-\t\t\t\t\t\t\" is not in the list to be processed.\"); //$NON-NLS-1$", "-\t\telse{", "-\t\t\t_batchMode = false;", "-\t\t\tif( _files != null ){", "-\t\t\t\tfor( int i=0, len=_files.length; i<len; i++ ){", "-\t\t\t\t\tif( _files[i] == file ){", "-\t\t\t\t\t\ttry{", "-\t\t\t\t\t\t\t_curSource = ProcessorEnvImpl.getFileContents( _files[i] );", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcatch( Exception e ){", "-\t\t\t\t\t\t\t// TODO:  propagate these exceptions out of APTDispatch", "-\t\t\t\t\t\t\te.printStackTrace();", "-\t\t\t\t\t\t}\t", "-\t\t\t\t\t\t_astRoot = (CompilationUnit)createDietAST(_files[i].toString(), _javaProject, null, _curSource );", "-\t\t\t\t\t\t_file = file;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif( _astRoot == null )", "-\t\t\t\tthrow new IllegalStateException(", "-\t\t\t\t\t\t\"file \" +  //$NON-NLS-1$", "-\t\t\t\t\t\tfile.getName() + ", "-\t\t\t\t\t\t\" is not in the list to be processed.\"); //$NON-NLS-1$", "-\t\t}", "+\t\t", "+\t\tif( _file == null || _astRoot == null)", "+\t\t\tthrow new IllegalStateException(", "+\t\t\t\t\t\"file \" +  //$NON-NLS-1$", "+\t\t\t\t\tfile.getName() + ", "+\t\t\t\t\t\" is not in the list to be processed.\"); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8040cdb528b7c87766069fa5422f9ad9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "bde9840f9573d77080a23dfde60bdb51dc549649", "commitAfterChange": "e5950298e29dbaf979a85e6f3f4a27d3f4b008e8", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tprotected void seekQualifiedMemberTypes(String qualifiedName, IType type, boolean partialMatch, IJavaElementRequestor requestor, int acceptFlags)", "signatureAfterChange": " \t \tprotected void seekTypesInTopLevelType(String prefix, int firstDot, IType topLevelType, IJavaElementRequestor requestor, int acceptFlags)", "diff": ["-\tprotected void seekQualifiedMemberTypes(String qualifiedName, IType type, boolean partialMatch, IJavaElementRequestor requestor, int acceptFlags) {", "-\t\tif (type == null)", "-\t\t\treturn;", "-\t\tString matchName= qualifiedName;", "-\t\tint index= qualifiedName.indexOf('$');", "-\t\tboolean nested= false;", "-\t\tif (index != -1) {", "-\t\t\tmatchName= qualifiedName.substring(0, index);", "-\t\t\tnested= true;", "-\t\t}", "-\t\t\tif (nameMatches(matchName, memberType, partialMatch))", "-\t\t\t\tif (nested) {", "-\t\t\t\t\tseekQualifiedMemberTypes(qualifiedName.substring(index + 1, qualifiedName.length()), memberType, partialMatch, requestor, acceptFlags);", "-\t\t\t\t\tif (acceptType(memberType, acceptFlags)) requestor.acceptMemberType(memberType);", "+\t", "+\tprotected void seekTypesInTopLevelType(String prefix, int firstDot, IType topLevelType, IJavaElementRequestor requestor, int acceptFlags) {", "+\t\tif (!topLevelType.getElementName().toLowerCase().startsWith(prefix))", "+\t\t\treturn;", "+\t\tif (firstDot == -1) {", "+\t\t\tif (acceptType(topLevelType, acceptFlags))", "+\t\t\t\trequestor.acceptType(topLevelType);", "+\t\t} else {", "+\t\t\tseekTypesInType(prefix, firstDot, topLevelType, requestor, acceptFlags);", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85cc0de4a3b862a9f45497e53ff3bd44", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceBuildTests.java", "commitBeforeChange": "f15f3a4daa4f7cbf363475bdb20d4707912f834f", "commitAfterChange": "1e2211eded7d5ae87dfcf507bb00676a5a81d8e9", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tpublic void testPerfBuildCompilerUsingBatchCompiler() throws IOException", "signatureAfterChange": " \tpublic void testPerfBuildCompilerUsingBatchCompiler() throws IOException", "diff": ["-", "-\tpublic void testPerfBuildCompilerUsingBatchCompiler() throws IOException {", "-\t\tIWorkspace workspace = ResourcesPlugin.getWorkspace();", "-\t\tfinal IWorkspaceRoot workspaceRoot = workspace.getRoot();", "-\t\tfinal String targetWorkspacePath = workspaceRoot.getProject(JavaCore.PLUGIN_ID)", "-\t\t\t.getLocation()", "-\t\t\t.toFile()", "-\t\t\t.getCanonicalPath();", "-\t\tfinal String sources = targetWorkspacePath + File.separator + \"compiler\"; //$NON-NLS-1$", "-\t\tfinal String bins = targetWorkspacePath + File.separator + \"bin\"; //$NON-NLS-1$", "-\t\tfinal String logs = targetWorkspacePath + File.separator + \"log.txt\"; //$NON-NLS-1$", "-", "-\t\t// Note this test is not a finger print test, so we don't want to use", "-\t\t// tagAsGlobalSummary(...)", "-\t\ttagAsSummary(\"Build jdt-core/compiler using batch compiler\", Dimension.CPU_TIME);", "-", "-\t\t// Compile 10 times", "-\t\tMain.compile(sources + \" -1.4 -g -preserveAllLocals -enableJavadoc -nowarn -d \" + bins + \" -log \" + logs); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\tfor (int i = 0; i < REPEAT; i++) {", "-\t\t\tstartMeasuring();", "-\t\t\tMain.compile(sources + \" -1.4 -g -preserveAllLocals -enableJavadoc -nowarn -d \" + bins + \" -log \" + logs); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\tstopMeasuring();", "-\t\t\tcleanupDirectory(new File(bins));", "-\t\tcommitMeasurements();", "-\t\tassertPerformance();", "-\t\tFile logsFile = new File(logs);", "+\t */", "+\tpublic void testPerfBuildCompilerUsingBatchCompiler() throws IOException {", "+\t\t// Do no longer print results in performance fingerprint", "+\t\ttagAsSummary(\"Compile>Build>Batch>Src:compiler>Options:DocCommentSupport,None\", Dimension.CPU_TIME, true); // put in fingerprint", "+", "+\t\tFile logsFile = buildUsingBatchCompiler(\"-enableJavadoc -nowarn\");", "+", "+\t\t// Should not get any error", "-\t\tassertEquals(\"Has errors\", 0, logsFile.length());", "+\t\tif (logsFile.length() != 0) {", "+\t\t\tchar[] errors = Util.getFileCharContent(logsFile, null);", "+\t\t\tint length = Math.min(errors.length, 1000);", "+\t\t\tassertTrue(\"Should have NO warning!\\nAlthoug, got following ones:\\n\"+(new String(errors, 0, length)), false);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "935476233f53e86a58300b512ea6064d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "9a828b6f308f1048d5448d6c6f9c881639322d34", "commitAfterChange": "5028738b115a56f3f04beb6089ff2c05854751f1", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public static char[] createMethodSignature(char[][] parameterTypes, char[] returnType)", "signatureAfterChange": " public static char[] createMethodSignature(char[][] parameterTypes, char[] returnType)", "diff": ["-\tint parameterTypesLength = parameterTypes.length;", "-\tint parameterLength = 0;", "-\tfor (int i = 0; i < parameterTypesLength; i++) {", "-\t\tparameterLength += parameterTypes[i].length;", "-\t\t", "-\t}", "-\tint returnTypeLength = returnType.length;", "-\tchar[] result = new char[1 + parameterLength + 1 + returnTypeLength];", "-\tresult[0] = C_PARAM_START;", "-\tint index = 1;", "-\tfor (int i = 0; i < parameterTypesLength; i++) {", "-\t\tchar[] parameterType = parameterTypes[i];", "-\t\tint length = parameterType.length;", "-\t\tSystem.arraycopy(parameterType, 0, result, index, length);", "-\t\tindex += length;", "-\t}", "-\tresult[index] = C_PARAM_END;", "-\tSystem.arraycopy(returnType, 0, result, index+1, returnTypeLength);", "-\treturn result;", "+\treturn createMethodSignature(parameterTypes, returnType, CharOperation.NO_CHAR_CHAR, CharOperation.NO_CHAR_CHAR);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f270da21ba35afa378bd3f0d6ef5130", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "23d1f03b5721ce2de9c0b6bda12e344c2ac468ba", "commitAfterChange": "966ae4bbaf97367f3fc38a9b2c2261f477021842", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 36, "signatureBeforeChange": " public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence)", "signatureAfterChange": " public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence)", "diff": ["-\t\tTypeParameter[] typeParameters = typeDeclaration.typeParameters;", "-\t\tchar[][] typeParameterNames = null;", "-\t\tchar[][][] typeParameterBounds = null;", "-\t\tif (typeParameters != null) {", "-\t\t\tint typeParametersLength = typeParameters.length;", "-\t\t\ttypeParameterNames = new char[typeParametersLength][];", "-\t\t\ttypeParameterBounds = new char[typeParametersLength][][];", "-\t\t\tfor (int i = 0; i < typeParametersLength; i++) {", "-\t\t\t\ttypeParameterNames[i] = typeParameters[i].name;", "-\t\t\t\tTypeReference[] bounds = typeParameters[i].bounds;", "-\t\t\t\tif (bounds != null) {", "-\t\t\t\t\tint boundLength = bounds.length;", "-\t\t\t\t\tchar[][] boundNames = new char[boundLength][];", "-\t\t\t\t\tfor (int j = 0; j < boundLength; j++) {", "-\t\t\t\t\t\tboundNames[j] = ", "-\t\t\t\t\t\t\tCharOperation.concatWith(bounds[j].getParameterizedTypeName(), '.'); ", "-\t\t\t\t\t}", "-\t\t\t\t\ttypeParameterBounds[i] = boundNames;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t\t\t\tinterfaceNames,", "-\t\t\t\t\ttypeParameterNames,", "-\t\t\t\t\ttypeParameterBounds);", "+\t\t\t\t\tinterfaceNames);", "-\t\t\t\t\t\tinterfaceNames,", "-\t\t\t\t\t\ttypeParameterNames,", "-\t\t\t\t\t\ttypeParameterBounds);", "+\t\t\t\t\t\tinterfaceNames);", "-\t\t\t\t\t\tinterfaceNames,", "-\t\t\t\t\t\ttypeParameterNames,", "-\t\t\t\t\t\ttypeParameterBounds);", "+\t\t\t\t\t\tinterfaceNames);", "+\t\t\tnotifySourceElementRequestor(typeDeclaration.typeParameters);\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9be44dcc8ff0c590ed33b709b3ed09e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java", "commitBeforeChange": "b1909bb0c4bbb70fecea5345c2e954fa4204b1dd", "commitAfterChange": "1ef42230a28632657bfac5df1d197b6d35dcc83d", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void collectSubstitutes(Scope scope, TypeBinding actualType, Map substitutes, int constraint)", "signatureAfterChange": " \tpublic void collectSubstitutes(Scope scope, TypeBinding actualType, InferenceContext inferenceContext, int constraint)", "diff": ["-\tpublic void collectSubstitutes(Scope scope, TypeBinding actualType, Map substitutes, int constraint) {", "+\tpublic void collectSubstitutes(Scope scope, TypeBinding actualType, InferenceContext inferenceContext, int constraint) {", "+\t\t", "+\t\t//\tonly infer for type params of the generic method", "+\t\tif (this.declaringElement != inferenceContext.genericMethod) return;", "-\t    TypeBinding[][] variableSubstitutes = (TypeBinding[][])substitutes.get(this);", "-\t    if (variableSubstitutes != null) {", "-\t\t    insertLoop: {", "-\t\t    \tTypeBinding[] constraintSubstitutes = variableSubstitutes[variableConstraint];", "-\t\t    \tint length;", "-\t\t    \tif (constraintSubstitutes == null) {", "-\t\t    \t\tlength = 0;", "-\t\t    \t\tconstraintSubstitutes = new TypeBinding[1];", "-\t\t    \t} else {", "-\t\t    \t\tlength = constraintSubstitutes.length;", "-\t\t\t        for (int i = 0; i < length; i++) {", "-\t\t\t        \tTypeBinding substitute = constraintSubstitutes[i];", "-\t\t\t            if (substitute == actualType) return; // already there", "-\t\t\t            if (substitute == null) {", "-\t\t\t                constraintSubstitutes[i] = actualType;", "-\t\t\t                break insertLoop;", "-\t\t\t            }", "-\t\t\t        }", "-\t\t\t        // no free spot found, need to grow by one", "-\t\t\t        System.arraycopy(constraintSubstitutes, 0, constraintSubstitutes = new TypeBinding[length+1], 0, length);", "-\t\t    \t}", "-\t\t        constraintSubstitutes[length] = actualType;", "-\t\t        variableSubstitutes[variableConstraint] = constraintSubstitutes;", "-\t\t    }", "-\t    }", "+\t\tinferenceContext.recordSubstitute(this, actualType, variableConstraint);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da3a2bcb78dbb21258d9b49274b66b5f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedSourceFolderManager.java", "commitBeforeChange": "c4c0df5e4aeb7d3e8571312c597020a7d0812327", "commitAfterChange": "6fea7eafdd413dccff31028f8da1f1ac6859e6fe", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tprivate void resetGeneratedSrcFolder(final IFolder srcFolder, boolean recreate)", "signatureAfterChange": " \tpublic static boolean validate(final IJavaProject jproj, final String folderName)", "diff": ["-\t */", "-\tprivate void resetGeneratedSrcFolder(final IFolder srcFolder, boolean recreate){", "-\t\t// clean up the classpath first so that when we actually delete the ", "-\t\t// generated source folder and won't cause a classpath error.", "-\t\tif( srcFolder != null ){", "-\t\t\ttry{\t", "-\t\t\t\tClasspathUtil.removeFromProjectClasspath( _aptProject.getJavaProject(), srcFolder, null );\t\t", "-\t\t\t}catch(JavaModelException e){", "-\t\t\t\tAptPlugin.log( e, \"Error occurred deleting old generated src folder \" + srcFolder.getName() ); //$NON-NLS-1$", "-\t\t", "-\t\tif( recreate )", "-\t\t\tensureGeneratedSourceFolder();", "-\t\t", "-\t\t// delete the generated source folder as well as", "-\t\t// all of its derived ancestors that are containers only to the ", "-\t\t// generated source folder", "-\t\tif( srcFolder != null ){", "-\t\t\tIFolder folderToDelete = srcFolder;\t\t", "-\t\t\tfor( IContainer c = srcFolder.getParent(); ", "-\t\t\t \t c != null && (c instanceof IFolder); ", "-\t\t\t \t c = c.getParent() ){", "-\t\t\t\t", "-\t\t\t\ttry{", "-\t\t\t\t\t// members can't be empty, there has to be at least 1.", "-\t\t\t\t\t// will only delete the parent if it contains only the ", "-\t\t\t\t\t// folder that we want to delete.", "-\t\t\t\t\tif( c.isDerived() && c.members().length == 1 ){", "-\t\t\t\t\t\tfolderToDelete = (IFolder)c;", "-\t\t\t\t\t}", "-\t\t\t\t\telse", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}catch(CoreException e){", "-\t\t\t\t\tAptPlugin.log(e, \"failure while accessing member of \" + c.getName() ); //$NON-NLS-1$", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tremoveFolder(folderToDelete);", "-\t\t}", "+\t */", "+\tpublic static boolean validate(final IJavaProject jproj, final String folderName) {", "+\t\tIFolder folder = null;", "+\t\ttry {", "+\t\t\tfolder = jproj.getProject().getFolder( folderName );", "+\t\t}", "+\t\tcatch (IllegalArgumentException e) {", "+\t\t\treturn false;", "+\t\t}", "+\t\treturn folder != null;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd022a3f0ef4d8bfe80fbf278790607d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "cefc7f3f8677282aa49e610700500999ffcaffcb", "commitAfterChange": "89e8879d5dd978e5f2535f9d8b7bac080dd4f73b", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " public int match(MethodDeclaration node, MatchingNodeSet nodeSet)", "signatureAfterChange": "  public int match(LambdaExpression node, MatchingNodeSet nodeSet)", "diff": ["+", "+public int match(LambdaExpression node, MatchingNodeSet nodeSet) {", "+\tif (!this.pattern.findDeclarations) return IMPOSSIBLE_MATCH;", "+\tif (this.pattern.parameterSimpleNames.length != node.arguments().length) return IMPOSSIBLE_MATCH;", "+", "+\tnodeSet.mustResolve = true;", "+\treturn nodeSet.addMatch(node, POSSIBLE_MATCH);", "+}"]}], "num": 44761}