{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7c00b825c73e5a1c64ac4999cec43458", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34f2ae786591e20fca9e5c09c1752932", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java", "commitBeforeChange": "34b4972480c62fc99b17d4728db2648e98460b52", "commitAfterChange": "a234173ab4d645c8990c97cafa00ec82ce0a909f", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] problems) throws CoreException", "signatureAfterChange": " protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] problems) throws CoreException", "diff": ["-\tfor (int i = 0, l = problems.length; i < l; i++) {", "+\tproblems: for (int i = 0, l = problems.length; i < l; i++) {", "+\t\t\tif (id == IProblem.MissingNonNullByDefaultAnnotationOnPackage && !(CharOperation.equals(sourceFile.getMainTypeName(), TypeConstants.PACKAGE_INFO_NAME))) {", "+\t\t\t\t// for this kind of problem, marker needs to be created on the package instead of on the source file", "+\t\t\t\t// see bug 372012", "+\t\t\t\tchar[] fileName = sourceFile.getFileName();", "+\t\t\t\tint pkgEnd = CharOperation.lastIndexOf('/', fileName);", "+\t\t\t\tif (pkgEnd == -1)", "+\t\t\t\t\tpkgEnd = CharOperation.lastIndexOf(File.separatorChar, fileName);", "+\t\t\t\tPackageFragment pkg = null;", "+\t\t\t\tif (pkgEnd != -1)", "+\t\t\t\t\tpkg = (PackageFragment) Util.getPackageFragment(sourceFile.getFileName(), pkgEnd, -1 /*no jar separator for java files*/);", "+\t\t\t\t", "+\t\t\t\tif (pkg != null) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tIMarker[] existingMarkers = pkg.resource().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_ZERO);", "+\t\t\t\t\t\tint len = existingMarkers.length;", "+\t\t\t\t\t\tfor (int j=0; j < len; j++) {", "+\t\t\t\t\t\t\tif (((Integer)existingMarkers[j].getAttribute(IJavaModelMarker.ID)).intValue() == IProblem.MissingNonNullByDefaultAnnotationOnPackage) {", "+\t\t\t\t\t\t\t\tcontinue problems; // marker already present", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\t\t// marker retrieval failed, cannot do much", "+\t\t\t\t\t\tif (JavaModelManager.VERBOSE) {", "+\t\t\t\t\t\t\te.printStackTrace();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tIResource tempRes = pkg.resource();", "+\t\t\t\t\tif (tempRes != null) {", "+\t\t\t\t\t\tresource = tempRes;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "48c261a6ec80d1fbd8f1f728e34ca497", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "415e478fd80c86e1c699eefa6d86979134ae5921", "commitAfterChange": "63b8bf54c7c6ab31eaeaf33c9d376ceaa28b674d", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 52, "signatureBeforeChange": " \tpublic void resourceChanged(IResourceChangeEvent event)", "signatureAfterChange": " \tpublic void resourceChanged(IResourceChangeEvent event)", "diff": ["+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t// generate classpath change deltas", "+\t\t\t\t\t\t\t\tif (this.classpathChanges.size() > 0) {", "+\t\t\t\t\t\t\t\t\tboolean hasDelta = this.currentDelta != null;", "+\t\t\t\t\t\t\t\t\tJavaElementDelta javaDelta = currentDelta();", "+\t\t\t\t\t\t\t\t\tIterator changes = this.classpathChanges.values().iterator();", "+\t\t\t\t\t\t\t\t\twhile (changes.hasNext()) {", "+\t\t\t\t\t\t\t\t\t\tClasspathChange change = (ClasspathChange) changes.next();", "+\t\t\t\t\t\t\t\t\t\tif (change.generateDelta(javaDelta)) {", "+\t\t\t\t\t\t\t\t\t\t\thasDelta = true;", "+\t\t\t\t\t\t\t\t\t\t\tchange.requestIndexing();", "+\t\t\t\t\t\t\t\t\t\t\tthis.state.addClasspathValidation(change.project);", "+\t\t\t\t\t\t\t\t\t\t\tthis.state.addProjectReferenceChange(change.project, change.oldResolvedClasspath);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tthis.classpathChanges.clear();", "+\t\t\t\t\t\t\t\t\tif (!hasDelta)", "+\t\t\t\t\t\t\t\t\t\tthis.currentDelta = null;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t// generate external archive change deltas", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t// generate Java deltas from resource changes", "-\t\t\t\t\t\t\tthis.removedRoots = null;", "+\t\t\t\t\t\t\tthis.oldRoots = null;", "-\t\t\t\t    DeltaProcessingState.ProjectUpdateInfo[] updates = this.state.removeAllProjectUpdates();", "-\t\t\t\t\tif (updates != null) {", "-\t\t\t\t\t    for (int i = 0, length = updates.length; i < length; i++) {", "+\t\t\t\t\tif(!isAffectedBy(delta))", "+\t\t\t\t\t\treturn; // avoid populating for SYNC or MARKER deltas", "+", "+\t\t\t\t\t// create classpath markers if necessary", "+\t\t\t\t\tvalidateClasspaths(delta);", "+\t\t\t\t\tClasspathValidation[] validations = this.state.removeClasspathValidations();", "+\t\t\t\t\tif (validations != null) {", "+\t\t\t\t\t\tfor (int i = 0, length = validations.length; i < length; i++) {", "+\t\t\t\t\t\t\tClasspathValidation validation = validations[i];", "+\t\t\t\t\t\t\tvalidation.validate();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// update all cycle markers since the classpath changes may have affected cycles", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tJavaProject.validateCycles(null);", "+\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\t// a project no longer exist", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// update project references if necessary", "+\t\t\t\t    ProjectReferenceChange[] projectRefChanges = this.state.removeProjectReferenceChanges();", "+\t\t\t\t\tif (projectRefChanges != null) {", "+\t\t\t\t\t    for (int i = 0, length = projectRefChanges.length; i < length; i++) {", "-\t\t\t\t\t\t        updates[i].updateProjectReferencesIfNecessary();", "+\t\t\t\t\t\t        projectRefChanges[i].updateProjectReferencesIfNecessary();", "-\t\t\t\t\t            // do nothing", "+\t\t\t\t\t            // project doesn't exist any longer, continue with next one", "-\t\t\t\t\t// this.processPostChange = false;", "-\t\t\t\t\tif(isAffectedBy(delta)) { // avoid populating for SYNC or MARKER deltas", "-\t\t\t\t\t\tupdateClasspathMarkers(delta, updates);", "-\t\t\t\t\t\tJavaBuilder.buildStarting();", "-\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\tJavaModel.flushExternalFileCache();", "+\t\t\t\t\tJavaBuilder.buildStarting();", "+\t\t\t\t\t"]}], "num": 53076}