{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "36a242a43f1fc798154554093978bdb6", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "06f86db995028dd33c0a610287973c9c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "0d3b917e085a30ae0d0e62e1fdd9fed7538807f0", "commitAfterChange": "76b6a3cfd736c0a5d2fa443496ebcce87b457034", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-\t\t\t\t\t\t\t\tseverity = ProblemSeverities.Warning;", "+\t\t\t\t\t\t\t\t// check to see if the erasure of either method is equal to the other", "+\t\t\t\t\t\t\t\t// if not, then change severity to WARNING", "+\t\t\t\t\t\t\t\tTypeBinding[] params1 = method.parameters;", "+\t\t\t\t\t\t\t\tTypeBinding[] params2 = method2.parameters;", "+\t\t\t\t\t\t\t\tint pLength = params1.length;", "+\t\t\t\t\t\t\t\tTypeVariableBinding[] vars = method.typeVariables;", "+\t\t\t\t\t\t\t\tTypeVariableBinding[] vars2 = method2.typeVariables;", "+\t\t\t\t\t\t\t\tboolean equalTypeVars = vars == vars2;", "+\t\t\t\t\t\t\t\tMethodBinding subMethod = method2;", "+\t\t\t\t\t\t\t\tif (!equalTypeVars) {", "+\t\t\t\t\t\t\t\t\tMethodBinding temp = method.computeSubstitutedMethod(method2, this.scope.environment());", "+\t\t\t\t\t\t\t\t\tif (temp != null) {", "+\t\t\t\t\t\t\t\t\t\tequalTypeVars = true;", "+\t\t\t\t\t\t\t\t\t\tsubMethod = temp;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tboolean equalParams = method.areParametersEqual(subMethod);", "+\t\t\t\t\t\t\t\tif (equalParams && equalTypeVars) {", "+\t\t\t\t\t\t\t\t\t// duplicates regardless of return types", "+\t\t\t\t\t\t\t\t} else if (vars != Binding.NO_TYPE_VARIABLES && vars2 != Binding.NO_TYPE_VARIABLES) {", "+\t\t\t\t\t\t\t\t\t// both have type arguments. Erasure of signature of one cannot be equal to signature of other", "+\t\t\t\t\t\t\t\t\tseverity = ProblemSeverities.Warning;", "+\t\t\t\t\t\t\t\t} else if (pLength > 0) {", "+\t\t\t\t\t\t\t\t\tint index = pLength;", "+\t\t\t\t\t\t\t\t\t// is erasure of signature of m2 same as signature of m1?", "+\t\t\t\t\t\t\t\t\tfor (; --index >= 0;) {", "+\t\t\t\t\t\t\t\t\t\tif (params1[index] != params2[index].erasure())", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\tif (params1[index] == params2[index]) {", "+\t\t\t\t\t\t\t\t\t\t\tTypeBinding type = params1[index].leafComponentType();", "+\t\t\t\t\t\t\t\t\t\t\tif (type instanceof SourceTypeBinding && type.typeVariables() != Binding.NO_TYPE_VARIABLES) {", "+\t\t\t\t\t\t\t\t\t\t\t\tindex = pLength; // handle comparing identical source types like X<T>... its erasure is itself BUT we need to answer false", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (index >= 0 && index < pLength) {", "+\t\t\t\t\t\t\t\t\t\t// is erasure of signature of m1 same as signature of m2?", "+\t\t\t\t\t\t\t\t\t\tfor (index = pLength; --index >= 0;)", "+\t\t\t\t\t\t\t\t\t\t\tif (params1[index].erasure() != params2[index])", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (index >= 0) {", "+\t\t\t\t\t\t\t\t\t\t// erasure of neither is equal to signature of other", "+\t\t\t\t\t\t\t\t\t\tseverity = ProblemSeverities.Warning;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else if (pLength != 0){", "+\t\t\t\t\t\t\t\t\tseverity = ProblemSeverities.Warning;", "+\t\t\t\t\t\t\t\t} // pLength = 0 automatically makes erasure of arguments one equal to arguments of other."]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac7d5c81caf8beb7e2112e8b63dc03e6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "778e64a3c8e6903c625067607c9068d73d8cd5e5", "commitAfterChange": "e12812c02c749e710a55fe1f28fa9764f0ac6bd5", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-\t\tboolean complyTo17 = this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_7;", "-\t\t\t\tif (complyTo15 && method.returnType != null && method2.returnType != null) {", "-\t\t\t\t\t// 8.4.2, for collision to be detected between m1 and m2:", "-\t\t\t\t\t// signature(m1) == signature(m2) i.e. same arity, same type parameter count, can be substituted", "-\t\t\t\t\t// signature(m1) == erasure(signature(m2)) or erasure(signature(m1)) == signature(m2)", "-\t\t\t\t\tTypeBinding[] params1 = method.parameters;", "-\t\t\t\t\tTypeBinding[] params2 = method2.parameters;", "-\t\t\t\t\tint pLength = params1.length;", "-\t\t\t\t\tif (pLength != params2.length)", "-\t\t\t\t\t\tcontinue nextSibling;", "-", "-\t\t\t\t\tTypeVariableBinding[] vars = method.typeVariables;", "-\t\t\t\t\tTypeVariableBinding[] vars2 = method2.typeVariables;", "-\t\t\t\t\tboolean equalTypeVars = vars == vars2;", "-\t\t\t\t\tMethodBinding subMethod = method2;", "-\t\t\t\t\tif (!equalTypeVars) {", "-\t\t\t\t\t\tMethodBinding temp = method.computeSubstitutedMethod(method2, this.scope.environment());", "-\t\t\t\t\t\tif (temp != null) {", "-\t\t\t\t\t\t\tequalTypeVars = true;", "-\t\t\t\t\t\t\tsubMethod = temp;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tboolean equalParams = method.areParametersEqual(subMethod);", "-\t\t\t\t\tif (equalParams && equalTypeVars) {", "-\t\t\t\t\t\t// duplicates regardless of return types", "-\t\t\t\t\t} else if ((complyTo17 || method.returnType.erasure() == subMethod.returnType.erasure())", "-\t\t\t\t\t\t&& (equalParams || method.areParameterErasuresEqual(method2))) {", "-\t\t\t\t\t\t// with fix for http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6182950", "-\t\t\t\t\t\t// we now ignore return types when detecting duplicates, just as we did before 1.5 ", "-\t\t\t\t\t\t// name clash for sure if not duplicates, report as duplicates", "-\t\t\t\t\t\t// FYI for now we will only make this change when compliance is set to 1.7 or higher", "-\t\t\t\t\t} else if (!equalTypeVars && vars != Binding.NO_TYPE_VARIABLES && vars2 != Binding.NO_TYPE_VARIABLES) {", "-\t\t\t\t\t\t// type variables are different so we can distinguish between methods", "-\t\t\t\t\t\tcontinue nextSibling;", "-\t\t\t\t\t} else if (pLength > 0) {", "-\t\t\t\t\t\t// check to see if the erasure of either method is equal to the other", "-\t\t\t\t\t\tint index = pLength;", "-\t\t\t\t\t\tfor (; --index >= 0;) {", "-\t\t\t\t\t\t\tif (params1[index] != params2[index].erasure())", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tif (params1[index] == params2[index]) {", "-\t\t\t\t\t\t\t\tTypeBinding type = params1[index].leafComponentType();", "-\t\t\t\t\t\t\t\tif (type instanceof SourceTypeBinding && type.typeVariables() != Binding.NO_TYPE_VARIABLES) {", "-\t\t\t\t\t\t\t\t\tindex = pLength; // handle comparing identical source types like X<T>... its erasure is itself BUT we need to answer false", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (index >= 0 && index < pLength) {", "-\t\t\t\t\t\t\tfor (index = pLength; --index >= 0;)", "-\t\t\t\t\t\t\t\tif (params1[index].erasure() != params2[index])", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (index >= 0)", "-\t\t\t\t\t\t\tcontinue nextSibling;", "-\t\t\t\t\t}", "-\t\t\t\t} else if (!method.areParametersEqual(method2)) { // prior to 1.5, parameter identity meant a collision case", "-\t\t\t\t\tcontinue nextSibling;", "-\t\t\t\t}", "+\t\t\t\tif (complyTo15 ? !method.areParameterErasuresEqual(method2) : !method.areParametersEqual(method2))", "+\t\t\t\t\tcontinue nextSibling; // otherwise duplicates / name clash"]}], "num": 46209}