{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c05d3dbf85da1dc3a06da2cece1d28a9", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53356ecce67a8b850b54986145f1ee72", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java", "commitBeforeChange": "4d19416746402b8fbbfd02c13772658da70a345a", "commitAfterChange": "81400db64234d6cf1ce3b6a87a8f065ac6bd072f", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \r protected char[][][] collect()", "signatureAfterChange": "\r \r protected char[][][] collect() throws JavaModelException", "diff": ["-protected char[][][] collect() {\r", "-\t\t\r", "-\t// Collect the paths of the cus that declare a type which matches declaringQualification + declaringSimpleName\r", "-\tString[] paths = this.getPathsOfDeclaringType();\r", "+protected char[][][] collect() throws JavaModelException {\r", "-\t// Create bindings from source types and binary types\r", "-\t// and collect super type names of the type declaration \r", "-\t// that match the given declaring type\r", "-\tif (paths != null) {\r", "+\tif (this.type != null) {\r", "-\t\tfor (int i = 0, length = paths.length; i < length; i++) {\r", "+\t\tthis.createParser((JavaProject)this.type.getJavaProject());\r", "+\t\tif (this.type.isBinary()) {\r", "+\t\t\tBinaryTypeBinding binding = this.cacheBinaryType(this.type);\r", "+\t\t\tthis.collectSuperTypeNames(binding);\r", "+\t\t} else {\r", "-\t\t\t\tOpenable openable = locator.handleFactory.createOpenable(paths[i]);\r", "-\t\t\t\tif (openable == null)\r", "-\t\t\t\t\tcontinue; // outside classpath\r", "-\t\t\t\tif (openable instanceof ICompilationUnit) {\r", "-\t\t\t\t\tICompilationUnit unit = (ICompilationUnit)openable;\r", "-\t\t\t\t\tCompilationUnitDeclaration parsedUnit = locator.buildBindings(unit);\r", "-\t\t\t\t\tif (parsedUnit != null) {\r", "-\t\t\t\t\t\tparsedUnit.traverse(new TypeDeclarationVisitor(), parsedUnit.scope);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t} else if (openable instanceof IClassFile) {\r", "-\t\t\t\t\tIClassFile classFile = (IClassFile)openable;\r", "-\t\t\t\t\tBinaryTypeBinding binding = this.cacheBinaryType(classFile.getType());\r", "-\t\t\t\t\tif (this.matches(binding)) {\r", "-\t\t\t\t\t\tthis.collectSuperTypeNames(binding);\r", "-\t\t\t\t\t}\r", "+\t\t\t\tICompilationUnit unit = this.type.getCompilationUnit();\r", "+\t\t\t\tif (unit.isWorkingCopy()) {\r", "+\t\t\t\t\tunit = (ICompilationUnit)unit.getOriginalElement();\r", "+\t\t\t\t}\r", "+\t\t\t\tCompilationUnitDeclaration parsedUnit = this.buildBindings(unit);\r", "+\t\t\t\tif (parsedUnit != null) {\r", "+\t\t\t\t\tparsedUnit.traverse(new TypeDeclarationVisitor(), parsedUnit.scope);\r", "-\t\t\t\t// ignore: continue with next element\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t// ignore: continue with next element\r", "+\t\t\t\t// report inacurrate matches\r", "+\t\t\t\treturn null;\r", "-\t\tSystem.arraycopy(this.result, 0, this.result = new char[this.resultIndex][][], 0, this.resultIndex);\r", "-\t} else {\r", "-\t\treturn null;\r", "+\t} else {\t\r", "+\t\t// Collect the paths of the cus that declare a type which matches declaringQualification + declaringSimpleName\r", "+\t\tString[] paths = this.getPathsOfDeclaringType();\r", "+\t\t\r", "+\t\t// Create bindings from source types and binary types\r", "+\t\t// and collect super type names of the type declaration \r", "+\t\t// that match the given declaring type\r", "+\t\tif (paths != null) {\r", "+\t\t\tUtil.sort(paths); // sort by projects\r", "+\t\t\tJavaProject previousProject = null;\r", "+\t\t\tthis.result = new char[1][][];\r", "+\t\t\tthis.resultIndex = 0;\r", "+\t\t\tfor (int i = 0, length = paths.length; i < length; i++) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tOpenable openable = this.handleFactory.createOpenable(paths[i]);\r", "+\t\t\t\t\tif (openable == null)\r", "+\t\t\t\t\t\tcontinue; // outside classpath\r", "+\t\t\t\t\tIJavaProject project = openable.getJavaProject();\r", "+\t\t\t\t\tif (previousProject == null || !previousProject.equals(project)) {\r", "+\t\t\t\t\t\tpreviousProject = (JavaProject)project;\r", "+\t\t\t\t\t\tthis.createParser(previousProject);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tif (openable instanceof ICompilationUnit) {\r", "+\t\t\t\t\t\tICompilationUnit unit = (ICompilationUnit)openable;\r", "+\t\t\t\t\t\tCompilationUnitDeclaration parsedUnit = this.buildBindings(unit);\r", "+\t\t\t\t\t\tif (parsedUnit != null) {\r", "+\t\t\t\t\t\t\tparsedUnit.traverse(new TypeDeclarationVisitor(), parsedUnit.scope);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else if (openable instanceof IClassFile) {\r", "+\t\t\t\t\t\tIClassFile classFile = (IClassFile)openable;\r", "+\t\t\t\t\t\tBinaryTypeBinding binding = this.cacheBinaryType(classFile.getType());\r", "+\t\t\t\t\t\tif (this.matches(binding)) {\r", "+\t\t\t\t\t\t\tthis.collectSuperTypeNames(binding);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t} catch (AbortCompilation e) {\r", "+\t\t\t\t\t// ignore: continue with next element\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t// ignore: continue with next element\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tSystem.arraycopy(this.result, 0, this.result = new char[this.resultIndex][][], 0, this.resultIndex);\r", "+\t\t\treturn this.result;\r", "+\t\t} else {\r", "+\t\t\treturn null;\r", "+\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5fbc24648a0a1c8c6ecbd2efd2893b72", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "32a99f8c41e7f6505e98564a2fe955f48d80f711", "commitAfterChange": "38819b0397930dbfdcf4973c1bb1a5b3cfbe15eb", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": "\r \tprivate void findVariableName(char[] token, char[] qualifiedPackageName, char[] qualifiedSourceName, char[] sourceName, char[][] excludeNames)", "signatureAfterChange": "\r \tprivate void findVariableName(char[] token, char[] qualifiedPackageName, char[] qualifiedSourceName, char[] sourceName, char[][] excludeNames)", "diff": ["+\t\t\tif(CharOperation.endsWith(sourceName, new char[]{'[' ,']'})) {\r", "+\t\t\t\tsourceName = CharOperation.subarray(sourceName, 0, sourceName.length - 2);\r", "+\t\t\t}\r", "+\r", "+\t\t\tchar[] name = null;\r", "+\t\t\t\r", "+\t\t\t// compute variable name for base type\r", "+\t\t\ttry{\r", "+\t\t\t\tnameScanner.setSourceBuffer(sourceName);\r", "+\t\t\t\tswitch (nameScanner.getNextToken()) {\r", "+\t\t\t\t\tcase TokenNameint :\r", "+\t\t\t\t\tcase TokenNamebyte :\r", "+\t\t\t\t\tcase TokenNameshort :\r", "+\t\t\t\t\tcase TokenNamechar :\r", "+\t\t\t\t\tcase TokenNamelong :\r", "+\t\t\t\t\tcase TokenNamefloat :\r", "+\t\t\t\t\tcase TokenNamedouble :\r", "+\t\t\t\t\t\tif(token != null && token.length != 0)\r", "+\t\t\t\t\t\t\treturn;\r", "+\t\t\t\t\t\tname = computeBaseNames(sourceName[0], excludeNames);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameboolean :\r", "+\t\t\t\t\t\tif(token != null && token.length != 0)\r", "+\t\t\t\t\t\t\treturn;\r", "+\t\t\t\t\t\tname = computeBaseNames('z', excludeNames);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t\tif(name != null) {\r", "+\t\t\t\t\t// accept result\r", "+\t\t\t\t\trequestor.acceptVariableName(\r", "+\t\t\t\t\t\tqualifiedPackageName,\r", "+\t\t\t\t\t\tqualifiedSourceName,\r", "+\t\t\t\t\t\tname,\r", "+\t\t\t\t\t\tname,\r", "+\t\t\t\t\t\tstartPosition,\r", "+\t\t\t\t\t\tendPosition);\r", "+\t\t\t\t\treturn;\r", "+\t\t\t\t}\r", "+\t\t\t} catch(InvalidInputException e){\r", "+\t\t\t}\r", "+\t\t\t\r", "+\t\t\t// compute variable name for non base type\r", "-\t\t\t\tchar[] name = names[i];\r", "+\t\t\t\tname = names[i];\r", "-\t\t\t\t\tidentifierScanner.setSourceBuffer(name);\r", "-\t\t\t\t\tif(identifierScanner.getNextToken() != identifierScanner.TokenNameIdentifier)\r", "+\t\t\t\t\tnameScanner.setSourceBuffer(name);\r", "+\t\t\t\t\tif(nameScanner.getNextToken() != TokenNameIdentifier)\r", "+\t\t\t\tint count = 2;\r", "+\t\t\t\tchar[] originalName = name;\r", "-\t\t\t\t\tif(CharOperation.equals(name, excludeNames[j], false))\r", "-\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t\tif(CharOperation.equals(name, excludeNames[j], false)) {\r", "+\t\t\t\t\t\tname = CharOperation.concat(originalName, String.valueOf(count++).toCharArray());\r", "+\t\t\t\t\t\ti = 0;\r", "+\t\t\t\t\t}\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c2563f1dd73635090cc9c1726785c320", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "70416b46b1375461a92d89ffa1cb077778dc6e86", "commitAfterChange": "0c53505dd9d8f221929a96f99e04ff55bfc4fc05", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tvoid createAndResolveBindings(MatchingOpenable[] openables)", "signatureAfterChange": " \tprotected void createAndResolveBindings(PotentialMatch[] potentialMatches, int start, int length)", "diff": ["+\t */", "+\tprotected void createAndResolveBindings(PotentialMatch[] potentialMatches, int start, int length) {", "+\t\tfor (int i = start, maxUnits = start+length; i < maxUnits; i++) {", "+\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) {", "+\t\t\t\tthrow new OperationCanceledException();", "+\t\t\t}", "+\t\t\tPotentialMatch potentialMatch = potentialMatches[i];", "+\t\t\ttry {", "+\t\t\t\tif (potentialMatch != null) {", "+\t\t\t\t\tthis.parser.matchSet = potentialMatch.matchingNodeSet;", "+\t\t\t\t}", "+\t\t\t\tCompilationResult unitResult =", "+\t\t\t\t\tnew CompilationResult(potentialMatch, i, maxUnits, this.options.maxProblemsPerUnit);", "+\t\t\t\t\t", "+\t\t\t\tif (SearchEngine.VERBOSE) {", "+\t\t\t\t\tSystem.out.println(\"Parsing \" + potentialMatch.openable.toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\t// diet parsing for large collection of units", "+\t\t\t\tCompilationUnitDeclaration parsedUnit;", "+\t\t\t\tif (totalUnits < parseThreshold) {", "+\t\t\t\t\tparsedUnit = this.parser.parse(potentialMatch, unitResult);", "+\t\t\t\t} else {", "+\t\t\t\t\tparsedUnit = this.parser.dietParse(potentialMatch, unitResult);", "+\t\t\t\t}", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t// initial type binding creation", "+\t\t\t\tif (parsedUnit != null && !parsedUnit.isEmpty()) {", "+\t\t\t\t\tthis.lookupEnvironment.buildTypeBindings(parsedUnit);", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tthis.addCompilationUnit(potentialMatch, parsedUnit);", "+\t\t\t\t", "+\t\t\t\t// progress reporting", "+\t\t\t\tif (this.progressMonitor != null) {", "+\t\t\t\t\tthis.progressMonitor.worked(4);", "+\t\t\t\t}", "+\t\t\t} finally {", "+\t\t\t\tthis.parser.matchSet = null;", "+\t\t\t\tpotentialMatches[i] = null; // no longer hold onto the unit", "+\t\t\t}", "+\t\t}", "+\t\t// binding resolution", "+\t\tlookupEnvironment.completeTypeBindings();", "+\t}", "-", "-\tvoid createAndResolveBindings(MatchingOpenable[] openables) {", "-\t\t// binding creation", "-\t\tfor (int i = 0, length = openables.length; i < length; i++) { ", "-\t\t\topenables[i].buildTypeBindings();", "-\t\t\tif (this.progressMonitor != null) {", "-\t\t\t\tif (this.progressMonitor.isCanceled()) {", "-\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.progressMonitor.worked(6);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// binding resolution", "-\t\ttry {", "-\t\t\tthis.lookupEnvironment.completeTypeBindings();", "-\t\t} catch (AbortCompilation e) {", "-\t\t\t// problem with class path: it could not find base classes", "-\t\t\t// continue reporting innacurate matches (since bindings will be null)", "-\t\t\tthis.compilationAborted = true;", "-\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e4e432b14300c27fb0c84607d3602ca3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CommitWorkingCopyOperation.java", "commitBeforeChange": "987b84492820c5eeff2230233c35db158228c8e3", "commitAfterChange": "882e850a9e00f22aac1934fd17ac4c0522b9b030", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected void executeOperation() throws JavaModelException", "signatureAfterChange": " \tprotected void executeOperation() throws JavaModelException", "diff": ["+\t\t\tIFile resource = (IFile)workingCopy.getResource();", "-\t\t", "-\t\t\t// creates the delta builder (this remembers the content of the cu)\t", "-\t\t\tif (!primary.isOpen()) {", "+", "+\t\t\tJavaElementDeltaBuilder deltaBuilder = null;", "+\t\t\t", "+\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)workingCopy.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);", "+\t\t\tif (root.isOnClasspath() && resource.isAccessible()) {", "+\t\t\t", "-\t\t\t\tprimary.open(null);", "-\t\t\t}", "-\t\t\tJavaElementDeltaBuilder deltaBuilder;", "-\t\t\tif (Util.isExcluded(primary)) {", "-\t\t\t\tdeltaBuilder = null;", "-\t\t\t} else {", "-\t\t\t\tdeltaBuilder = new JavaElementDeltaBuilder(primary);", "-\t\t\t}", "-\t\t", "-\t\t\t// save the cu", "-\t\t\tIBuffer primaryBuffer = primary.getBuffer();", "-\t\t\tif (primaryBuffer == null) return;", "-\t\t\tchar[] primaryContents = primaryBuffer.getCharacters();", "-\t\t\tboolean hasSaved = false;", "-\t\t\ttry {", "-\t\t\t\tIBuffer workingCopyBuffer = workingCopy.getBuffer();", "-\t\t\t\tif (workingCopyBuffer == null) return;", "-\t\t\t\tprimaryBuffer.setContents(workingCopyBuffer.getCharacters());", "-\t\t\t\tprimary.save(fMonitor, fForce);", "-\t\t\t\tsetAttribute(HAS_MODIFIED_RESOURCE_ATTR, TRUE); ", "-\t\t\t\thasSaved = true;", "-\t\t\t} finally {", "-\t\t\t\tif (!hasSaved){", "-\t\t\t\t\t// restore original buffer contents since something went wrong", "-\t\t\t\t\tprimaryBuffer.setContents(primaryContents);", "+\t\t\t\tif (!primary.isOpen()) {", "+\t\t\t\t\tprimary.open(null);", "+", "+\t\t\t\t// creates the delta builder (this remembers the content of the cu)\t", "+\t\t\t\tif (!Util.isExcluded(primary)) {", "+\t\t\t\t\tdeltaBuilder = new JavaElementDeltaBuilder(primary);", "+\t\t\t\t}", "+\t\t\t", "+\t\t\t\t// save the cu", "+\t\t\t\tIBuffer primaryBuffer = primary.getBuffer();", "+\t\t\t\tif (primaryBuffer == null) return;", "+\t\t\t\tchar[] primaryContents = primaryBuffer.getCharacters();", "+\t\t\t\tboolean hasSaved = false;", "+\t\t\t\ttry {", "+\t\t\t\t\tIBuffer workingCopyBuffer = workingCopy.getBuffer();", "+\t\t\t\t\tif (workingCopyBuffer == null) return;", "+\t\t\t\t\tprimaryBuffer.setContents(workingCopyBuffer.getCharacters());", "+\t\t\t\t\tprimaryBuffer.save(fMonitor, fForce);", "+\t\t\t\t\tprimary.makeConsistent(this);", "+\t\t\t\t\thasSaved = true;", "+\t\t\t\t} finally {", "+\t\t\t\t\tif (!hasSaved){", "+\t\t\t\t\t\t// restore original buffer contents since something went wrong", "+\t\t\t\t\t\tprimaryBuffer.setContents(primaryContents);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\t// working copy on cu outside classpath OR resource doesn't exist yet", "+\t\t\t\tString encoding = workingCopy.getJavaProject().getOption(JavaCore.CORE_ENCODING, true);", "+\t\t\t\tString contents = workingCopy.getSource();", "+\t\t\t\tif (contents == null) return;", "+\t\t\t\ttry {", "+\t\t\t\t\tbyte[] bytes = encoding == null ", "+\t\t\t\t\t\t? contents.getBytes() ", "+\t\t\t\t\t\t: contents.getBytes(encoding);", "+\t\t\t\t\tByteArrayInputStream stream = new ByteArrayInputStream(bytes);", "+\t\t\t\t\tif (resource.exists()) {", "+\t\t\t\t\t\tresource.setContents(", "+\t\t\t\t\t\t\tstream, ", "+\t\t\t\t\t\t\tfForce ? IResource.FORCE | IResource.KEEP_HISTORY : IResource.KEEP_HISTORY, ", "+\t\t\t\t\t\t\tnull);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tresource.create(", "+\t\t\t\t\t\t\tstream,", "+\t\t\t\t\t\t\tfForce,", "+\t\t\t\t\t\t\tfMonitor);", "+\t\t\t\t\t}", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\tthrow new JavaModelException(e);", "+\t\t\t\t} catch (UnsupportedEncodingException e) {", "+\t\t\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);", "+\t\t\t\t}", "+\t\t\t\t", "+", "+\t\t\tsetAttribute(HAS_MODIFIED_RESOURCE_ATTR, TRUE); ", "+\t\t\t", "+\t\t\t// build the deltas", "-\t\t\t\t// build the deltas"]}], "num": 67098}