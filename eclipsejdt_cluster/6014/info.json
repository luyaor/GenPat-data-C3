{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "841eaa035a0a6778d89488e67e968fbd", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "712bf1a1475a090791b35d3dd12e878c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "63893780bad36827f62e4f410f92f9cc758dcd3a", "commitAfterChange": "8e69a3a7281a71cf8bb89a21d1bb526115e1dbf1", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 40, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspathEntry(IJavaProject project, IClasspathEntry entry, boolean checkSourceAttachment, boolean recurseInContainers)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspathEntry(IJavaProject project, IClasspathEntry entry, boolean checkSourceAttachment, boolean recurseInContainers)", "diff": ["+\t\t\t\t\t\t\t// Validate extra attributes", "+\t\t\t\t\t\t\tIClasspathAttribute[] extraAttributes = entry.getExtraAttributes();", "+\t\t\t\t\t\t\tif (extraAttributes != null) {", "+\t\t\t\t\t\t\t\tint length = extraAttributes.length;", "+\t\t\t\t\t\t\t\tHashSet set = new HashSet(length);", "+\t\t\t\t\t\t\t\tfor (int i=0; i<length; i++) {", "+\t\t\t\t\t\t\t\t\tString attName = extraAttributes[i].getName();", "+\t\t\t\t\t\t\t\t\tif (!set.add(attName)) {", "+\t\t\t\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.NAME_COLLISION, Messages.bind(Messages.classpath_duplicateEntryExtraAttribute, new String[] {attName, entryPathMsg, projectName})); ", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+", "+\t\t// Validate extra attributes", "+\t\tIClasspathAttribute[] extraAttributes = entry.getExtraAttributes();", "+\t\tif (extraAttributes != null) {", "+\t\t\tint length = extraAttributes.length;", "+\t\t\tHashSet set = new HashSet(length);", "+\t\t\tfor (int i=0; i<length; i++) {", "+\t\t\t\tString attName = extraAttributes[i].getName();", "+\t\t\t\tif (!set.add(attName)) {", "+\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.NAME_COLLISION, Messages.bind(Messages.classpath_duplicateEntryExtraAttribute, new String[] {attName, entryPathMsg, projectName})); ", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ad3007fc458c72c1f88c33902c6d7392", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileMap.java", "commitBeforeChange": "f673a1d9c7172b796dd31cfa78dd0dad32318c9f", "commitAfterChange": "bd2b202132c8d4bb0e104bd05827a1b9231c9dc5", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tprivate void readState()", "signatureAfterChange": " \tprivate void readState()", "diff": ["+\t\t\t", "+\t\t\t// Now the _flags map:", "+\t\t\tint sizeOfFlags = in.readInt();", "+\t\t\tfor (int i = 0; i < sizeOfFlags; ++i) {", "+\t\t\t\tString childPath = in.readUTF();", "+\t\t\t\tIFile child = convertPathToIFile(childPath);", "+\t\t\t\tif (!containsValue(child)) {", "+\t\t\t\t\tthrow new IOException(\"Error in generated file attributes: did not expect file \" + childPath); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tint attributeCount = in.readInt();", "+\t\t\t\tEnumSet<Flags> flags = EnumSet.noneOf(Flags.class);", "+\t\t\t\tfor (int j = 0; j < attributeCount; ++j) {", "+\t\t\t\t\tString attr = in.readUTF();", "+\t\t\t\t\tFlags f = Flags.valueOf(attr);", "+\t\t\t\t\tflags.add(f);", "+\t\t\t\t}", "+\t\t\t\t_flags.put(child, flags);", "+\t\t\t}", "+\t\t\t", "+\t\t\t// Avoid partial initialization", "+\t\t\tclear();", "-\t\t\tAptPlugin.log(ioe, \"Could not deserialize APT dependencies\"); //$NON-NLS-1$", "+\t\t\tAptPlugin.logWarning(ioe, \"Could not read APT dependencies: generated files may not be deleted until the next clean\"); //$NON-NLS-1$", "+\t\t}", "+\t\tcatch (IllegalArgumentException iae) {", "+\t\t\t// Avoid partial initialization", "+\t\t\tclear();", "+\t\t\t// We can safely continue without having read our dependencies.", "+\t\t\tAptPlugin.logWarning(iae, \"Could not read APT dependencies: generated files may not be deleted until the next clean\"); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bdb274b0fc5bf805bbc733bd7d0a560b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "d577fece07c4fdbce33b7bc16d2d2a9b7bf263e2", "commitAfterChange": "c4bece6f11e325ba67c44c784cdcd204e747008d", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void buildForProject(JavaProject project, ArrayList potentialSubtypes, org.eclipse.jdt.core.ICompilationUnit[] workingCopies, HashSet localTypes, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " private void buildForProject(JavaProject project, ArrayList potentialSubtypes, org.eclipse.jdt.core.ICompilationUnit[] workingCopies, HashSet localTypes, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\t// copy vectors into arrays", "-\tint openablesLength = potentialSubtypes.size();", "-\tOpenable[] openables = new Openable[openablesLength];", "-\tpotentialSubtypes.toArray(openables);", "-", "+\tint openablesLength = potentialSubtypes.size();", "+\t\t// copy vectors into arrays", "+\t\tOpenable[] openables = new Openable[openablesLength];", "+\t\tpotentialSubtypes.toArray(openables);", "+", "+\t\t// sort in the order of roots and in reverse alphabetical order for .class file", "+\t\t// since requesting top level types in the process of caching an enclosing type is", "+\t\t// not supported by the lookup environment", "+\t\tIPackageFragmentRoot[] roots = project.getPackageFragmentRoots();", "+\t\tint rootsLength = roots.length;", "+\t\tfinal HashtableOfObjectToInt indexes = new HashtableOfObjectToInt(openablesLength);", "+\t\tfor (int i = 0; i < openablesLength; i++) {", "+\t\t\tIJavaElement root = openables[i].getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);", "+\t\t\tint index;", "+\t\t\tfor (index = 0; index < rootsLength; index++) {", "+\t\t\t\tif (roots[index].equals(root))", "+\t\t\t\t\tbreak;", "+\t\t\t}\t\t", "+\t\t\tindexes.put(openables[i], index);", "+\t\t}", "+\t\tUtil.sort(openables, new Util.Comparer() {", "+\t\t\tpublic int compare(Object a, Object b) {", "+\t\t\t\tint aIndex = indexes.get(a);", "+\t\t\t\tint bIndex = indexes.get(b);", "+\t\t\t\tif (aIndex != bIndex)", "+\t\t\t\t\treturn aIndex - bIndex;", "+\t\t\t\treturn ((Openable) b).getElementName().compareTo(((Openable) a).getElementName());", "+\t\t\t}", "+\t\t});", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d1546fd8b0e725d7c43d56e0b3076818", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java", "commitBeforeChange": "f4a4e733ec9a6ee8e5480938f7f746aa2704ad0d", "commitAfterChange": "f775b73fdbd5c38023656e438f9ccb262941721f", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope, boolean checkBounds)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope, boolean checkBounds)", "diff": ["+\t    boolean isClassScope = scope.kind == Scope.CLASS_SCOPE;", "+\t\t\t// be resilient, still attempt resolving arguments", "+\t\t\tif (binding instanceof ProblemReferenceBinding) {", "+\t\t\t    TypeReference[] args = this.typeArguments[((ProblemReferenceBinding) binding).compoundName.length - 1];", "+\t\t\t    if (args != null) {", "+\t\t\t\t\tint argLength = args.length;", "+\t\t\t\t\tfor (int j = 0; j < argLength; j++) {", "+\t\t\t\t\t    TypeReference typeArgument = args[j];", "+\t\t\t\t\t    if (isClassScope) {", "+\t\t\t\t\t    \ttypeArgument.resolveType((ClassScope) scope);", "+\t\t\t\t\t    } else {", "+\t\t\t\t\t    \ttypeArgument.resolveType((BlockScope) scope, checkBounds);", "+\t\t\t\t\t    }", "+\t\t\t\t\t}", "+\t\t\t    }\t\t\t\t", "+\t\t\t}", "-\t    boolean isClassScope = scope.kind == Scope.CLASS_SCOPE;", "+\t\t\t\t// be resilient, still attempt resolving arguments", "+\t\t\t    TypeReference[] args = this.typeArguments[i];", "+\t\t\t    if (args != null) {", "+\t\t\t\t\tint argLength = args.length;", "+\t\t\t\t\tfor (int j = 0; j < argLength; j++) {", "+\t\t\t\t\t    TypeReference typeArgument = args[j];", "+\t\t\t\t\t    if (isClassScope) {", "+\t\t\t\t\t    \ttypeArgument.resolveType((ClassScope) scope);", "+\t\t\t\t\t    } else {", "+\t\t\t\t\t    \ttypeArgument.resolveType((BlockScope) scope);", "+\t\t\t\t\t    }", "+\t\t\t\t\t}", "+\t\t\t    }\t\t\t\t"]}], "num": 6014}