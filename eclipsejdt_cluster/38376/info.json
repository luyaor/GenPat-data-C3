{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d86b8df55db1bd2647fd4cebff2c49db", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26c8de7a121b93c79333e6434edf372f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "031774399eed50847f433b5425b7551aed0c6cbc", "commitAfterChange": "30ba2db951e79b89a330e1209e461b1c083d6de3", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["-\t\treturn TypeBinding.NULL;", "+\t\tthis.scope = new MethodScope(blockScope, this, blockScope.methodScope().isStatic);", "+", "+\t\tTypeBinding expected = this.expectedType();", "+\t\tif (expected == null) return TypeBinding.NULL;", "+", "+\t\tMethodBinding singleAbstractMethod = expected.getSingleAbstractMethod();", "+\t\tif (this.arguments != null && singleAbstractMethod != null) {", "+\t\t\tint parameterCount = singleAbstractMethod.parameters != null ? singleAbstractMethod.parameters.length : 0;", "+\t\t\tint lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;", "+", "+\t\t\tif (parameterCount == lambdaArgumentCount) {", "+\t\t\t\tfor (int i = 0, length = this.arguments.length; i < length; i++) {", "+\t\t\t\t\tArgument argument = this.arguments[i];", "+\t\t\t\t\tif (argument.type != null) {", "+\t\t\t\t\t\targument.resolve(this.scope); // TODO: Check it!", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\targument.bind(this.scope, singleAbstractMethod.parameters[i], false);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} /* TODO: else complain */", "+\t\t}", "+\t\tif (this.body instanceof Expression) {", "+\t\t\tExpression expression = (Expression) this.body;", "+\t\t\tif (singleAbstractMethod != null) {", "+\t\t\t\texpression.setExpectedType(singleAbstractMethod.returnType); // chain expected type for any nested lambdas.", "+\t\t\t\t/* TypeBinding expressionType = */ expression.resolveType(this.scope);", "+\t\t\t\t// TODO: checkExpressionResult(singleAbstractMethod.returnType, expression, expressionType);", "+\t\t\t}", "+\t\t} else {", "+\t\t\tthis.body.resolve(this.scope);", "+\t\t}", "+\t\treturn expected;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2d1e3d42d4ed81f6271d6535361cdc0d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "af7c555b94268663ad75bc44adea174c67a820bf", "commitAfterChange": "5f14954289dcfe3aa64cd723a9ea9807dea33e05", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \t\t \tpublic MethodDeclaration convert(AbstractMethodDeclaration methodDeclaration)", "signatureAfterChange": " \t\t \tpublic MethodDeclaration convert(AbstractMethodDeclaration methodDeclaration)", "diff": ["-\t\tretrieveRightBraceOrSemiColonPosition(methodDecl);", "-\t\t", "-\t\torg.eclipse.jdt.internal.compiler.ast.Statement[] statements = methodDeclaration.statements;", "-\t\t", "-\t\tif (statements != null || explicitConstructorCall != null) {", "-\t\t\tBlock block = this.ast.newBlock();", "-\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "-\t\t\tend = retrieveEndBlockPosition(methodDeclaration.sourceStart, this.compilationUnitSource.length);", "-\t\t\tblock.setSourceRange(start, end - start + 1);", "-\t\t\tif (explicitConstructorCall != null && explicitConstructorCall.accessMode != ExplicitConstructorCall.ImplicitSuper) {", "-\t\t\t\tblock.statements().add(convert(explicitConstructorCall));", "-\t\t\t}", "-\t\t\tint statementsLength = statements == null ? 0 : statements.length;", "-\t\t\tfor (int i = 0; i < statementsLength; i++) {", "-\t\t\t\tif (statements[i] instanceof LocalDeclaration) {", "-\t\t\t\t\tcheckAndAddMultipleLocalDeclaration(statements, i, block.statements());", "-\t\t\t\t} else {", "-\t\t\t\t\tblock.statements().add(convert(statements[i]));", "+\t\tint closingPosition = retrieveRightBraceOrSemiColonPosition(methodDecl, methodDeclaration);", "+\t\tif (closingPosition != -1) {", "+\t\t\tint startPosition = methodDecl.getStartPosition();", "+\t\t\tmethodDecl.setSourceRange(startPosition, closingPosition - startPosition);", "+", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.Statement[] statements = methodDeclaration.statements;", "+\t\t\t", "+\t\t\tif (statements != null || explicitConstructorCall != null) {", "+\t\t\t\tBlock block = this.ast.newBlock();", "+\t\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "+\t\t\t\tend = retrieveEndBlockPosition(methodDeclaration.sourceStart, methodDeclaration.declarationSourceEnd);", "+\t\t\t\tblock.setSourceRange(start, end - start + 1);", "+\t\t\t\tif (explicitConstructorCall != null && explicitConstructorCall.accessMode != ExplicitConstructorCall.ImplicitSuper) {", "+\t\t\t\t\tblock.statements().add(convert(explicitConstructorCall));", "+\t\t\t\t}", "+\t\t\t\tint statementsLength = statements == null ? 0 : statements.length;", "+\t\t\t\tfor (int i = 0; i < statementsLength; i++) {", "+\t\t\t\t\tif (statements[i] instanceof LocalDeclaration) {", "+\t\t\t\t\t\tcheckAndAddMultipleLocalDeclaration(statements, i, block.statements());", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tblock.statements().add(convert(statements[i]));", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tmethodDecl.setBody(block);", "+\t\t\t} else if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract()) {", "+\t\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "+\t\t\t\tend = retrieveEndBlockPosition(methodDeclaration.sourceStart, methodDeclaration.declarationSourceEnd);", "+\t\t\t\tif (start != -1 && end != -1) {", "+\t\t\t\t\t/*", "+\t\t\t\t\t * start or end can be equal to -1 if we have an interface's method.", "+\t\t\t\t\t */", "+\t\t\t\t\tBlock block = this.ast.newBlock();", "+\t\t\t\t\tblock.setSourceRange(start, end - start + 1);", "+\t\t\t\t\tmethodDecl.setBody(block);", "-\t\t\tmethodDecl.setBody(block);", "-\t\t} else if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract()) {", "-\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "-\t\t\tend = retrieveEndBlockPosition(methodDeclaration.sourceStart, this.compilationUnitSource.length);", "-\t\t\tif (start != -1 && end != -1) {", "-\t\t\t\t/*", "-\t\t\t\t * start or end can be equal to -1 if we have an interface's method.", "-\t\t\t\t */", "-\t\t\t\tBlock block = this.ast.newBlock();", "-\t\t\t\tblock.setSourceRange(start, end - start + 1);", "-\t\t\t\tmethodDecl.setBody(block);", "-\t\t\t}", "+\t\t} else {", "+\t\t\t// syntax error in this method declaration", "+\t\t\tif (!methodDeclaration.isNative() && !methodDeclaration.isAbstract()) {", "+\t\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "+\t\t\t\tend = methodDeclaration.bodyEnd;", "+\t\t\t\t// try to get the best end position", "+\t\t\t\tIProblem[] problems = methodDeclaration.compilationResult().problems;", "+\t\t\t\tif (problems != null) {", "+\t\t\t\t\tfor (int i = 0, max = problems.length; i < max; i++) {", "+\t\t\t\t\t\tIProblem currentProblem = problems[i];", "+\t\t\t\t\t\tif (currentProblem.getSourceStart() == start && currentProblem.getID() == IProblem.ParsingErrorInsertToComplete) {", "+\t\t\t\t\t\t\tend = currentProblem.getSourceEnd();", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tint startPosition = methodDecl.getStartPosition();", "+\t\t\t\tmethodDecl.setSourceRange(startPosition, end - startPosition + 1);", "+\t\t\t\tif (start != -1 && end != -1) {", "+\t\t\t\t\t/*", "+\t\t\t\t\t * start or end can be equal to -1 if we have an interface's method.", "+\t\t\t\t\t */", "+\t\t\t\t\tBlock block = this.ast.newBlock();", "+\t\t\t\t\tblock.setSourceRange(start, end - start + 1);", "+\t\t\t\t\tmethodDecl.setBody(block);", "+\t\t\t\t}", "+\t\t\t}\t\t\t", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "339401ba33e1c76d17adb49d60812621", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "51c6ca3e4dfed3078a1640da7a2ab7f26c899e0a", "commitAfterChange": "de8aa9940086fe152901aa168536f30670945804", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 14, "signatureBeforeChange": "  \tprivate int addFieldAttributes(FieldBinding fieldBinding, int fieldAttributeOffset)", "signatureAfterChange": "  \tprivate int addFieldAttributes(FieldBinding fieldBinding, int fieldAttributeOffset)", "diff": ["+\t\t\t\tList allTypeAnnotationContexts = new ArrayList();", "+\t\t\t\tint invisibleTypeAnnotationsCounter = 0;", "+\t\t\t\tint visibleTypeAnnotationsCounter = 0;", "+\t\t\t\t\tif ((this.produceAttributes & ClassFileConstants.ATTR_TYPE_ANNOTATION) != 0) {", "+\t\t\t\t\t\tif ((fieldDeclaration.bits & ASTNode.HasTypeAnnotations) != 0) {", "+\t\t\t\t\t\t\tfieldDeclaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.FIELD, allTypeAnnotationContexts);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tTypeReference fieldType = fieldDeclaration.type;", "+\t\t\t\tif (fieldType != null ", "+\t\t\t\t\t\t&& ((this.produceAttributes & ClassFileConstants.ATTR_TYPE_ANNOTATION) != 0)", "+\t\t\t\t\t\t&& ((fieldType.bits & ASTNode.HasTypeAnnotations) != 0)) {", "+\t\t\t\t\tfieldType.getAllAnnotationContexts(AnnotationTargetTypeConstants.FIELD, allTypeAnnotationContexts);", "+\t\t\t\t}", "+\t\t\t\tint size = allTypeAnnotationContexts.size();", "+\t\t\t\tif (size != 0) {", "+\t\t\t\t\tAnnotationContext[] allTypeAnnotationContextsArray = new AnnotationContext[size];", "+\t\t\t\t\tallTypeAnnotationContexts.toArray(allTypeAnnotationContextsArray);", "+\t\t\t\t\tfor (int i = 0, max = allTypeAnnotationContextsArray.length; i < max; i++) {", "+\t\t\t\t\t\tAnnotationContext annotationContext = allTypeAnnotationContextsArray[i];", "+\t\t\t\t\t\tif ((annotationContext.visibility & AnnotationContext.INVISIBLE) != 0) {", "+\t\t\t\t\t\t\tinvisibleTypeAnnotationsCounter++;", "+\t\t\t\t\t\t\tallTypeAnnotationContexts.add(annotationContext);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tvisibleTypeAnnotationsCounter++;", "+\t\t\t\t\t\t\tallTypeAnnotationContexts.add(annotationContext);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tattributesNumber += generateRuntimeTypeAnnotations(", "+\t\t\t\t\t\t\tallTypeAnnotationContextsArray,", "+\t\t\t\t\t\t\tvisibleTypeAnnotationsCounter,", "+\t\t\t\t\t\t\tinvisibleTypeAnnotationsCounter);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "96fa21a00e34f3db089bef4600b99ac0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java", "commitBeforeChange": "c382c60104b7fa9333f25f2fb10b318d2a6c9d85", "commitAfterChange": "890be42f32773e7ca5496c222c424ace19ee53bc", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \t \tprivate void computeAllRootPaths(IPackageFragmentRoot root)", "signatureAfterChange": " \t \tprivate void computeAllRootPaths(IPackageFragmentRoot root)", "diff": ["-\t\tif (this.rootPaths == null) {", "-\t\t\tthis.rootPaths = new HashSet();", "-\t\t}", "+\t\tfinal HashSet tempRoots = new HashSet();", "-\t\t\t\t\t\t\tIStatus status = JavaConventions.validatePackageName(firstLevelPackageName);", "-\t\t\t\t\t\t\tif (status.isOK() || status.getSeverity() == IStatus.WARNING) {", "-\t\t\t\t\t\t\t\tfirstLevelPackageNames.add(firstLevelPackageName);", "+\t\t\t\t\t\t\tif (!firstLevelPackageNames.contains(firstLevelPackageName)) {", "+\t\t\t\t\t\t\t\tIStatus status = JavaConventions.validatePackageName(firstLevelPackageName);", "+\t\t\t\t\t\t\t\tif (status.isOK() || status.getSeverity() == IStatus.WARNING) {", "+\t\t\t\t\t\t\t\t\tfirstLevelPackageNames.add(firstLevelPackageName);", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tthis.rootPaths.add(path.uptoSegment(i).toString());", "+\t\t\t\t\t\t\t\t\ttempRoots.add(path.uptoSegment(i));", "-\t\t\t\t\t\t\t\t\tthis.rootPaths.add(path.uptoSegment(max).toString());", "+\t\t\t\t\t\t\t\t\ttempRoots.add(path.uptoSegment(max));", "-\t\t\t\t\t\t\tthis.rootPaths.add(\"\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\ttempRoots.add(new Path(\"\")); //$NON-NLS-1$", "-\t\t\t\t\tcomputeRootPath((IContainer)target, firstLevelPackageNames, containsADefaultPackage);", "+\t\t\t\t\tcomputeRootPath((IContainer)target, firstLevelPackageNames, containsADefaultPackage, tempRoots);", "-\t\t\t\t\tcomputeRootPath(file, firstLevelPackageNames, containsADefaultPackage);", "+\t\t\t\t\tcomputeRootPath(file, firstLevelPackageNames, containsADefaultPackage, tempRoots);", "+\t\tint size = tempRoots.size();", "+\t\tif (this.rootPaths != null) {", "+\t\t\tfor (Iterator iterator = this.rootPaths.iterator(); iterator.hasNext(); ) {", "+\t\t\t\ttempRoots.add(iterator.next());", "+\t\t\t\tsize++;", "+\t\t\t}", "+\t\t\tthis.rootPaths.clear();", "+\t\t} else {", "+\t\t\tthis.rootPaths = new ArrayList(size);", "+\t\t}", "+\t\tif (size != 0) {", "+\t\t\tArrayList sortedRoots = new ArrayList(tempRoots);", "+\t\t\tCollections.sort(sortedRoots, new Comparator() {", "+\t\t\t\tpublic int compare(Object o1, Object o2) {", "+\t\t\t\t\tIPath path1 = (IPath) o1;", "+\t\t\t\t\tIPath path2 = (IPath) o2;", "+\t\t\t\t\treturn path1.segmentCount() - path2.segmentCount();", "+\t\t\t\t}", "+\t\t\t});", "+\t\t\tfor (Iterator iter = sortedRoots.iterator(); iter.hasNext();) {", "+\t\t\t\tIPath path = (IPath) iter.next();", "+\t\t\t\tthis.rootPaths.add(path.toString());", "+\t\t\t}", "+\t\t}", "+\t\tthis.areRootPathsComputed = true;", "-\t\t\tfinal int size = this.rootPaths.size();", "+\t\t\tSystem.out.println(\"Spent \" + (System.currentTimeMillis() - time) + \"ms\"); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t\tString rootpath = (String) iterator.next();", "-\t\t\t\tSystem.out.println(\"root[\" + i + \"]=\" + rootpath);//$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\tSystem.out.println(\"root[\" + i + \"]=\" + ((String) iterator.next()));//$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\tSystem.out.println(\"Spent \" + (System.currentTimeMillis() - time) + \"ms\"); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\tthis.areRootPathsComputed = true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b43c69d746e745dfc56d1b960230455c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "b0ee678b65f48d1cfab35972dd53d6bd85389446", "commitAfterChange": "5a11933bf440021c4c92ce580c9967dadb549d6e", "methodNumberBeforeChange": 117, "methodNumberAfterChange": 117, "signatureBeforeChange": "  \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments)", "signatureAfterChange": " \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site)", "diff": ["+\t// Version that just answers based on inference kind (at 1.8+) when available.", "+\tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site) {", "+\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8 && method instanceof ParameterizedGenericMethodBinding) {", "+\t\t\tint inferenceKind = InferenceContext18.CHECK_UNKNOWN;", "+\t\t\tInferenceContext18 context = null;", "+\t\t\tif (site instanceof Invocation) {", "+\t\t\t\tInvocation invocation = (Invocation) site;", "+\t\t\t\tcontext = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);", "+\t\t\t\tif (context != null)", "+\t\t\t\t\tinferenceKind = context.inferenceKind;", "+\t\t\t} else if (site instanceof ReferenceExpression) {", "+\t\t\t\tinferenceKind = ((ReferenceExpression) site).inferenceKind;", "+\t\t\t}", "+\t\t\t/* 1.8+ Post inference compatibility check policy: For non-functional-type arguments, trust inference. For functional type arguments apply compatibility checks as inference", "+\t\t\t   engine may not have checked arguments that are not pertinent to applicability. One complication to deal with is when the generic method's parameter is its own type variable ", "+\t\t\t   and only applicability was inferred and applicability inference instantiated it with jlO due to lack of upper bounds in the bound set.", "+\t\t\t*/", "+\t\t\tif (site instanceof Invocation && context != null) { // this block can be readily seen to be not relevant for reference expressions", "+\t\t\t\tMethodBinding shallowOriginal = method.shallowOriginal();", "+\t\t\t\tfor (int i = 0, length = arguments.length; i < length; i++) {", "+\t\t\t\t\tTypeBinding argument = arguments[i];", "+\t\t\t\t\tif (!argument.isFunctionalType())", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tTypeBinding parameter = InferenceContext18.getParameter(method.parameters, i, context.isVarArgs());", "+\t\t\t\t\tif (argument.isCompatibleWith(parameter, this))", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tTypeBinding shallowParameter = InferenceContext18.getParameter(shallowOriginal.parameters, i, context.isVarArgs());", "+\t\t\t\t\tif (shallowParameter.isPertinentToApplicability(argument, shallowOriginal))", "+\t\t\t\t\t\treturn NOT_COMPATIBLE;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tswitch (inferenceKind) {", "+\t\t\t\tcase InferenceContext18.CHECK_STRICT:", "+\t\t\t\t\treturn COMPATIBLE;", "+\t\t\t\tcase InferenceContext18.CHECK_LOOSE:", "+\t\t\t\t\treturn AUTOBOX_COMPATIBLE;", "+\t\t\t\tcase InferenceContext18.CHECK_VARARG:", "+\t\t\t\t\treturn VARARGS_COMPATIBLE;", "+\t\t\t\tdefault:", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t}", "+\t\treturn parameterCompatibilityLevel(method, arguments, false);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc6e819bb0512cc527b73432ef83e2c4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java", "commitBeforeChange": "91a5b49121a22c32ff81484145fe6ce15b755e81", "commitAfterChange": "16b9910572e7876db169469e4f3c509a31490ed4", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate TypeDeclaration convert(ISourceType sourceType, CompilationResult compilationResult)", "signatureAfterChange": " \tprivate TypeDeclaration convert(ISourceType sourceType, CompilationResult compilationResult)", "diff": ["-\t\tif (sourceType.getEnclosingType() != null) {", "+\t\tif (sourceType.getEnclosingType() == null && sourceType instanceof SourceTypeElementInfo) {", "+\t\t\tIType typeHandle = ((SourceTypeElementInfo)sourceType).getHandle();", "+\t\t\ttry {", "+\t\t\t\tif (typeHandle.isAnonymous()) {", "+\t\t\t\t\ttype.name = TypeDeclaration.ANONYMOUS_EMPTY_NAME;", "+\t\t\t\t\ttype.bits |= ASTNode.AnonymousAndLocalMask;", "+\t\t\t\t} else {", "+\t\t\t\t\tif (typeHandle.isLocal()) {", "+\t\t\t\t\t\ttype.bits |= ASTNode.IsLocalTypeMASK;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// could not figure, assume toplevel", "+\t\t\t}", "+\t\t}  else {", "+\t\t}", "+\t\tif ((type.bits & ASTNode.IsAnonymousTypeMASK) == 0) {", "+\t\t\ttype.name = sourceType.getName();", "-\t\t/* convert fields */", "+\t\t/* convert intializers and fields*/", "+\t\tInitializerElementInfo[] initializers = null;", "+\t\tint initializerCount = 0;", "+\t\tif ((this.flags & LOCAL_TYPE) != 0 && sourceType instanceof SourceTypeElementInfo) {", "+\t\t\tinitializers = ((SourceTypeElementInfo)sourceType).getInitializers();", "+\t\t\tinitializerCount = initializers.length;", "+\t\t}", "+\t\tISourceField[] sourceFields = null;", "+\t\tint sourceFieldCount = 0;", "-\t\t\tISourceField[] sourceFields = sourceType.getFields();", "-\t\t\tint sourceFieldCount = sourceFields == null ? 0 : sourceFields.length;", "-\t\t\ttype.fields = new FieldDeclaration[sourceFieldCount];", "-\t\t\tfor (int i = 0; i < sourceFieldCount; i++) {", "-\t\t\t\ttype.fields[i] = convert(sourceFields[i], type);", "+\t\t\tsourceFields = sourceType.getFields();", "+\t\t\tsourceFieldCount = sourceFields == null ? 0 : sourceFields.length;", "+\t\t}", "+\t\tint length = initializerCount + sourceFieldCount;", "+\t\tif (length > 0) {", "+\t\t\ttype.fields = new FieldDeclaration[length];", "+\t\t\tfor (int i = 0; i < initializerCount; i++) {", "+\t\t\t\ttype.fields[i] = convert(initializers[i], compilationResult);", "+\t\t\t}", "+\t\t\tint index = 0;", "+\t\t\tfor (int i = initializerCount; i < length; i++) {", "+\t\t\t\ttype.fields[i] = convert(sourceFields[index++], type, compilationResult);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d62c6ddb43afe947dcff024d6f47946a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java", "commitBeforeChange": "f682a4f20c4b7c328b7143bcd283abe7fc78f127", "commitAfterChange": "51edd6de0dc9df46bdb409b22473cd853bc26d79", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "\r \r private boolean isWorthBuilding() throws CoreException", "signatureAfterChange": "\r \r private boolean isWorthBuilding() throws CoreException", "diff": ["-//\tboolean abortBuilds = JavaCore.ABORT.equals(JavaCore.getOptions().get(OPTION_InvalidClasspathSwitch));\r", "-//\tif (abortBuilds) {\r", "-//\t\tIMarker[] markers =\r", "-//\t\t\tcurrentProject.findMarkers(IJavaModelMarker.BUILDPATH_PROBLEM_MARKER, false, IResource.DEPTH_ONE);\r", "-//\t\tif (markers.length > 0) {\r", "-//\t\t\tif (DEBUG)\r", "-//\t\t\t\tSystem.out.println(\"Aborted build because project is involved in a cycle or has classpath problems\"); //$NON-NLS-1$\r", "-//\r", "-//\t\t\t// remove all existing class files... causes all dependent projects to do the same\r", "-//\t\t\tnew BatchImageBuilder(this).scrubOutputFolder();\r", "-//\r", "-//\t\t\tremoveProblemsFor(currentProject); // make this the only problem for this project\r", "-//\t\t\treturn false;\r", "-//\t\t}\r", "-//\t}\r", "-//\r", "-//\t// make sure all prereq projects have valid build states\r", "-//\tIProject[] requiredProjects = getRequiredProjects();\r", "-//\tnext : for (int i = 0, length = requiredProjects.length; i < length; i++) {\r", "-//\t\tIProject p = requiredProjects[i];\r", "-//\t\tif (getLastState(p) == null)  {\r", "-//\t\t\tif (!abortBuilds && !p.isOpen()) continue next; // skip closed projects if we're not aborting builds because of classpath problems\r", "-//\t\t\tif (DEBUG)\r", "-//\t\t\t\tSystem.out.println(\"Aborted build because prereq project \" + p.getName() //$NON-NLS-1$\r", "-//\t\t\t\t\t+ \" was not built\"); //$NON-NLS-1$\r", "-//\r", "-//\t\t\t// remove all existing class files... causes all dependent projects to do the same\r", "-//\t\t\tnew BatchImageBuilder(this).scrubOutputFolder();\r", "-//\r", "-//\t\t\tremoveProblemsFor(currentProject); // make this the only problem for this project\r", "-//\t\t\tIMarker marker = currentProject.createMarker(ProblemMarkerTag);\r", "-//\t\t\tmarker.setAttribute(IMarker.MESSAGE, Util.bind(\"build.prereqProjectWasNotBuilt\", p.getName())); //$NON-NLS-1$\r", "-//\t\t\tmarker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);\r", "-//\t\t\treturn false;\r", "-//\t\t}\r", "-//\t}\r", "+\tboolean abortBuilds = JavaCore.ABORT.equals(JavaCore.getOptions().get(OPTION_InvalidClasspathSwitch));\r", "+\tabortBuilds = true;\r", "+\tif (abortBuilds) {\r", "+\t\tIMarker[] markers =\r", "+\t\t\tcurrentProject.findMarkers(IJavaModelMarker.BUILDPATH_PROBLEM_MARKER, false, IResource.DEPTH_ONE);\r", "+\t\tif (markers.length > 0) {\r", "+\t\t\tif (DEBUG)\r", "+\t\t\t\tSystem.out.println(\"Aborted build because project is involved in a cycle or has classpath problems\"); //$NON-NLS-1$\r", "+\r", "+\t\t\t// remove all existing class files... causes all dependent projects to do the same\r", "+\t\t\tnew BatchImageBuilder(this).scrubOutputFolder();\r", "+\r", "+\t\t\tremoveProblemsFor(currentProject); // make this the only problem for this project\r", "+\t\t\treturn false;\r", "+\t\t}\r", "+\t}\r", "+\r", "+\t// make sure all prereq projects have valid build states\r", "+\tIProject[] requiredProjects = getRequiredProjects();\r", "+\tnext : for (int i = 0, length = requiredProjects.length; i < length; i++) {\r", "+\t\tIProject p = requiredProjects[i];\r", "+\t\tif (getLastState(p) == null)  {\r", "+\t\t\tif (!abortBuilds && !p.isOpen()) continue next; // skip closed projects if we're not aborting builds because of classpath problems\r", "+\t\t\tif (DEBUG)\r", "+\t\t\t\tSystem.out.println(\"Aborted build because prereq project \" + p.getName() //$NON-NLS-1$\r", "+\t\t\t\t\t+ \" was not built\"); //$NON-NLS-1$\r", "+\r", "+\t\t\t// remove all existing class files... causes all dependent projects to do the same\r", "+\t\t\tnew BatchImageBuilder(this).scrubOutputFolder();\r", "+\r", "+\t\t\tremoveProblemsFor(currentProject); // make this the only problem for this project\r", "+\t\t\tIMarker marker = currentProject.createMarker(ProblemMarkerTag);\r", "+\t\t\tmarker.setAttribute(IMarker.MESSAGE, Util.bind(\"build.prereqProjectWasNotBuilt\", p.getName())); //$NON-NLS-1$\r", "+\t\t\tmarker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);\r", "+\t\t\treturn false;\r", "+\t\t}\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "db7e76f6c9f1f1378324c7c06b14934d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "15354ef30ff1d65c0145e0a7585cb94774313c51", "commitAfterChange": "f49cf7529ae8b80cdf3f120143dad37a4f24e498", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " public AnnotationBinding[] getParameterAnnotations(int index)", "signatureAfterChange": " public AnnotationBinding[] getParameterAnnotations(int index)", "diff": ["-\treturn holder == null ? Binding.NO_ANNOTATIONS : holder.getParameterAnnotations(index);", "+\tAnnotationBinding[][] allParameterAnnotations = holder == null ? null : holder.getParameterAnnotations();", "+\tif (allParameterAnnotations == null && (this.tagBits & TagBits.HasParameterAnnotations) != 0) {", "+\t\t// forward reference to method, where param annotations have not yet been associated to method", "+\t\tif (this.declaringClass instanceof SourceTypeBinding) {", "+\t\t\tSourceTypeBinding sourceType = (SourceTypeBinding) this.declaringClass;", "+\t\t\tif (sourceType.scope != null) {", "+\t\t\t\tAbstractMethodDeclaration methodDecl = sourceType.scope.referenceType().declarationOf(this);", "+\t\t\t\tif (methodDecl.arguments != null) {", "+\t\t\t\t\tfor (int i = 0, length = methodDecl.arguments.length; i < length; i++) {", "+\t\t\t\t\t\tArgument argument = methodDecl.arguments[i];", "+\t\t\t\t\t\tif (argument.annotations != null) {", "+\t\t\t\t\t\t\tASTNode.resolveAnnotations(methodDecl.scope, argument.annotations, argument.binding);", "+\t\t\t\t\t\t\tif (allParameterAnnotations == null) {", "+\t\t\t\t\t\t\t\tallParameterAnnotations = new AnnotationBinding[length][];", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tallParameterAnnotations[i] = argument.binding.getAnnotations();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (allParameterAnnotations != null)", "+\t\t\t\t\t\tthis.setParameterAnnotations(allParameterAnnotations);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\tAnnotationBinding[] resultParameterAnnotations = allParameterAnnotations == null ? null : allParameterAnnotations[\tindex];", "+\t if (resultParameterAnnotations != null) {", "+\t\t return resultParameterAnnotations;", "+\t }", "+\treturn Binding.NO_ANNOTATIONS;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f460911bf4d9d1d96c0f340fb9eca7f8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "8db2a22a82e2d4efc29edee16188f254a9d47da3", "commitAfterChange": "72fd8c6a4dc73c6ac3a3682b35550798adce77f5", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \t\t\t\t\tpublic void handleException(Throwable exception)", "signatureAfterChange": " \t\t \t\tprivate int sortParticipants(HashMap group, CompilationParticipant[] participants, int index)", "diff": ["-\t\t\t\tPlatform.run(new ISafeRunnable() {", "-\t\t\t\t\tpublic void handleException(Throwable exception) {", "-\t\t\t\t\t\tUtil.log(exception, \"Exception occurred while configuring compilation participant\"); //$NON-NLS-1$", "-\t\t\t\t\t}", "+\t\t", "+\t\tprivate int sortParticipants(HashMap group, CompilationParticipant[] participants, int index) {", "+\t\t\tint size = group.size();", "+\t\t\tif (size == 0) return index;", "+\t\t\tObject[] elements = group.keySet().toArray();", "+\t\t\tUtil.sort(elements, new Util.Comparer() {", "+\t\t\t\tpublic int compare(Object a, Object b) {", "+\t\t\t\t\tString id = ((IConfigurationElement) a).getAttribute(\"id\"); //$NON-NLS-1$", "+\t\t\t\t\tif (id == null) return -1;", "+\t\t\t\t\tIConfigurationElement[] requiredElements = ((IConfigurationElement) b).getChildren(\"requires\"); //$NON-NLS-1$", "+\t\t\t\t\tfor (int i = 0, length = requiredElements.length; i < length; i++) {", "+\t\t\t\t\t\tIConfigurationElement required = requiredElements[i];", "+\t\t\t\t\t\tif (id.equals(required.getAttribute(\"id\"))) //$NON-NLS-1$", "+\t\t\t\t\t\t\treturn 1;", "+\t\t\t\t\t}", "+\t\t\t\t\treturn -1;", "+\t\t\t\t}", "+\t\t\t});", "+\t\t\tfor (int i = 0; i < size; i++)", "+\t\t\t\tparticipants[index+i] = (CompilationParticipant) group.get(elements[i]);", "+\t\t\treturn index + size;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fd3cd44806a153cbabd734ecafffe062", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java", "commitBeforeChange": "e77a13c5cfd8a2800f9cc3d46536a8ccdc632a8b", "commitAfterChange": "c62b2332be65f641e5e7827b79f4caf8cb16c6bb", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic TypeBinding resolveType(BlockScope scope, boolean checkBounds)", "signatureAfterChange": " \tpublic TypeBinding resolveType(BlockScope scope, boolean checkBounds)", "diff": ["-\t\t\t\tif (type.findSuperTypeOriginatingFrom(priorType) != null) {", "+\t\t\t\tif (TypeBinding.equalsEquals(type.findSuperTypeOriginatingFrom(priorType), priorType)) {", "-\t\t\t\tif (priorType.findSuperTypeOriginatingFrom(type) != null)", "+\t\t\t\tif (TypeBinding.equalsEquals(priorType.findSuperTypeOriginatingFrom(type), type))", "+", "-\t\treturn (this.resolvedType = scope.environment().createIntersectionCastType(intersectingTypes));", "+\t\tIntersectionCastTypeBinding intersectionType = (IntersectionCastTypeBinding) scope.environment().createIntersectionCastType(intersectingTypes);", "+\t\t// check for parameterized interface collisions (when different parameterizations occur)", "+\t\tReferenceBinding itsSuperclass = null;", "+\t\tReferenceBinding[] interfaces = intersectingTypes;", "+\t\tReferenceBinding firstType = intersectingTypes[0];", "+\t\tif (firstType.isClass()) {", "+\t\t\titsSuperclass = firstType.superclass();", "+\t\t\tSystem.arraycopy(intersectingTypes, 1, interfaces = new ReferenceBinding[typeCount - 1], 0, typeCount - 1);", "+\t\t}", "+\t\t", "+\t\tMap invocations = new HashMap(2);", "+\t\tnextInterface: for (int i = 0, interfaceCount = interfaces.length; i < interfaceCount; i++) {", "+\t\t\tReferenceBinding one = interfaces[i];", "+\t\t\tif (one == null) continue nextInterface;", "+\t\t\tif (itsSuperclass != null && scope.hasErasedCandidatesCollisions(itsSuperclass, one, invocations, intersectionType, this))", "+\t\t\t\tcontinue nextInterface;", "+\t\t\tnextOtherInterface: for (int j = 0; j < i; j++) {", "+\t\t\t\tReferenceBinding two = interfaces[j];", "+\t\t\t\tif (two == null) continue nextOtherInterface;", "+\t\t\t\tif (scope.hasErasedCandidatesCollisions(one, two, invocations, intersectionType, this))", "+\t\t\t\t\tcontinue nextInterface;", "+\t\t\t}", "+\t\t}", "+\t\tif ((intersectionType.tagBits & TagBits.HierarchyHasProblems) != 0)", "+\t\t\treturn null;", "+", "+\t\treturn (this.resolvedType = intersectionType);"]}], "num": 38376}