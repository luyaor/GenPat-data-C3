{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "43f55fef74edffcc754eb2ad4b3be752", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2319475039cafff3929820bd2625c9c9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8a64589617f7b80b7f12bb3f773ab58c605663c7", "commitAfterChange": "6585c7471e2cc73387fb0d652a600f2678de9051", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tpublic void printBlockComment(char[] s, int commentStart, boolean isJavadoc)", "signatureAfterChange": " \tprivate void printBlockComment(char[] s, boolean isJavadoc)", "diff": ["-\tpublic void printBlockComment(char[] s, int commentStart, boolean isJavadoc) {", "-\t\tString commentSource = new String(s);", "-\t\tStringTokenizer tokenizer = new StringTokenizer(commentSource, \"\\r\\n\");\t//$NON-NLS-1$", "-\t\tprintIndentationIfNecessary();", "-\t\tLocation location = null;", "-\t\tint lineCounter = 0;", "-\t\tint startSearchIndex = 0;", "+\tprivate void printBlockComment(char[] s, boolean isJavadoc) {", "-\t\twhile(tokenizer.hasMoreElements()) {", "-\t\t\tString lineContents = tokenizer.nextToken();", "-\t\t\tif (lineContents.length() != 0) {", "-\t\t\t\tprintIndentationIfNecessary();", "-\t\t\t\tif (lineCounter >= 1) {", "-\t\t\t\t\tbuffer.append(\" \");//$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\t// remove leading whitespaces", "-\t\t\t\tint lineStartPosition = currentTokenStartPosition + commentSource.indexOf(lineContents, startSearchIndex);", "-\t\t\t\tthis.scanner.resetTo(lineStartPosition, this.scannerEndPosition - 1);", "-\t\t\t\tString reduceLine = null;", "-\t\t\t\ttry {", "-\t\t\t\t\t// TODO need investigation in term of edits", "-\t\t\t\t\tif (this.scanner.getNextToken() == ITerminalSymbols.TokenNameWHITESPACE) {", "-\t\t\t\t\t\tint begin = this.scanner.getCurrentTokenEndPosition() + 1 - lineStartPosition;", "-\t\t\t\t\t\tif (begin < lineContents.length()) {", "-\t\t\t\t\t\t\treduceLine = lineContents.substring(begin);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\treduceLine = \"\"; //$NON-NLS-1$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\treduceLine = lineContents;", "+\t\tthis.scanner.resetTo(currentTokenStartPosition, currentTokenEndPosition - 1);", "+\t\tint currentCharacter;", "+\t\tboolean isNewLine = false;", "+\t\tint start = currentTokenStartPosition;", "+\t\tint nextCharacterStart = currentTokenStartPosition;", "+\t\tprintIndentationIfNecessary();", "+\t\tint previousStart = currentTokenStartPosition;", "+", "+\t\twhile (nextCharacterStart <= currentTokenEndPosition && (currentCharacter = this.scanner.getNextChar()) != -1) {", "+\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+", "+\t\t\tswitch(currentCharacter) {", "+\t\t\t\tcase '\\r' :", "+\t\t\t\t\tstart = previousStart;", "+\t\t\t\t\tisNewLine = true;", "+\t\t\t\t\tif (this.scanner.getNextChar('\\n')) {", "+\t\t\t\t\t\tcurrentCharacter = '\\n';", "+\t\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "-\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t// should not happen", "-\t\t\t\t}", "-\t\t\t\tfinal int reduceLineLength = reduceLine.length();", "-\t\t\t\t// add position mapping", "-\t\t\t\tint start = commentSource.indexOf(reduceLine, startSearchIndex);", "-\t\t\t\tif (this.positionsToMap != null) {", "-\t\t\t\t\tmapPositions(start + commentStart, this.buffer.length(), reduceLineLength);", "-\t\t\t\t}", "-\t\t\t\tstartSearchIndex = start + reduceLineLength + 1;", "-\t\t\t\tbuffer.append(reduceLine);", "-\t\t\t\tcolumn += reduceLineLength;", "-\t\t\t\tlocation = new Location(this, 0);", "-\t\t\t\tbuffer.append(this.lineSeparator);", "-\t\t\t\tthis.line++;", "-\t\t\t\tlineCounter++;", "-\t\t\t\tcolumn = 1;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase '\\n' :", "+\t\t\t\t\tstart = previousStart;", "+\t\t\t\t\tisNewLine = true;", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tif (isNewLine) {", "+\t\t\t\t\t\tif (Character.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\twhile(currentCharacter != -1 && currentCharacter != '\\r' && currentCharacter != '\\n' && Character.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\t\tpreviousStart = nextCharacterStart;", "+\t\t\t\t\t\t\t\tcurrentCharacter = this.scanner.getNextChar();", "+\t\t\t\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.column = 1;", "+\t\t\t\t\t\tthis.line++;", "+", "+\t\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t\t\tbuffer.append(this.lineSeparator);", "+\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "+\t\t\t\t\t\tbuffer.append(this.fillingSpace);", "+\t\t\t\t", "+\t\t\t\t\t\taddReplaceEdit(start, previousStart - 1, String.valueOf(buffer)); //$NON-NLS-1$", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.column += (nextCharacterStart - previousStart);", "+\t\t\t\t\t}", "+\t\t\t\t\tisNewLine = false;", "-\t\t}", "-\t\tif (location != null) {", "-\t\t\tresetAt(location);", "+\t\t\tpreviousStart = nextCharacterStart;", "+\t\tthis.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);", "-\t\tthis.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c8ea3105c3f28d02b161abb762456b89", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "0de5167791884524f72d9d44c10f0e243af65d00", "commitAfterChange": "07ab76f69fbeeb2f2fd54cdf3d01ee69344b9ae0", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  \tpublic static CompilationUnitDeclaration parse( \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit, \t\t\tNodeSearcher nodeSearcher, \t\t\tMap settings, \t\t\tint flags)", "signatureAfterChange": " \tpublic static void parse( \t\t\tString[] sourceUnits, \t\t\tString[] encodings, \t\t\tFileASTRequestor astRequestor, \t\t\tint apiLevel, \t\t\tMap options, \t\t\tint flags, \t\t\tIProgressMonitor monitor)", "diff": ["+\tpublic static void parse(", "+\t\t\tString[] sourceUnits,", "+\t\t\tString[] encodings,", "+\t\t\tFileASTRequestor astRequestor,", "+\t\t\tint apiLevel,", "+\t\t\tMap options,", "+\t\t\tint flags,", "+\t\t\tIProgressMonitor monitor) {", "+\t\ttry {", "+\t\t\tCompilerOptions compilerOptions = new CompilerOptions(options);", "+\t\t\tcompilerOptions.ignoreMethodBodies = (flags & ICompilationUnit.IGNORE_METHOD_BODIES) != 0;", "+\t\t\tParser parser = new CommentRecorderParser(", "+\t\t\t\tnew ProblemReporter(", "+\t\t\t\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(),", "+\t\t\t\t\t\tcompilerOptions,", "+\t\t\t\t\t\tnew DefaultProblemFactory()),", "+\t\t\t\tfalse);", "+\t\t\tint unitLength = sourceUnits.length;", "+\t\t\tif (monitor != null) monitor.beginTask(\"\", unitLength); //$NON-NLS-1$", "+\t\t\tfor (int i = 0; i < unitLength; i++) {", "+\t\t\t\tchar[] contents = null;", "+\t\t\t\tString encoding = encodings != null ? encodings[i] : null;", "+\t\t\t\ttry {", "+\t\t\t\t\tcontents = Util.getFileCharContent(new File(sourceUnits[i]), encoding);", "+\t\t\t\t} catch(IOException e) {", "+\t\t\t\t\t// go to the next unit", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tif (contents == null) {", "+\t\t\t\t\t// go to the next unit", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\torg.eclipse.jdt.internal.compiler.batch.CompilationUnit compilationUnit = new org.eclipse.jdt.internal.compiler.batch.CompilationUnit(contents, sourceUnits[i], encoding);", "+\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationUnit;", "+\t\t\t\tCompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, compilerOptions.maxProblemsPerUnit);", "+\t\t\t\tCompilationUnitDeclaration compilationUnitDeclaration = parser.dietParse(sourceUnit, compilationResult);", "+\t\t\t\tif (compilationUnitDeclaration.ignoreMethodBodies) {", "+\t\t\t\t\tcompilationUnitDeclaration.ignoreFurtherInvestigation = true;", "+\t\t\t\t\t// if initial diet parse did not work, no need to dig into method bodies.", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+", "+\t\t\t\t//fill the methods bodies in order for the code to be generated", "+\t\t\t\t//real parse of the method....", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = compilationUnitDeclaration.types;", "+\t\t\t\tif (types != null) {", "+\t\t\t\t\tfor (int j = 0, typeLength = types.length; j < typeLength; j++) {", "+\t\t\t\t\t\ttypes[j].parseMethods(parser, compilationUnitDeclaration);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+", "+\t\t\t\t// convert AST", "+\t\t\t\tCompilationUnit node = convert(compilationUnitDeclaration, parser.scanner.getSource(), apiLevel, options, false/*don't resolve binding*/, null/*no owner needed*/, null/*no binding table needed*/, flags /* flags */, monitor, true);", "+\t\t\t\tnode.setTypeRoot(null);", "+", "+\t\t\t\t// accept AST", "+\t\t\t\tastRequestor.acceptAST(sourceUnits[i], node);", "+", "+\t\t\t\tif (monitor != null) monitor.worked(1);", "+\t\t\t}", "+\t\t} finally {", "+\t\t\tif (monitor != null) monitor.done();", "+\t\t}", "+\t}"]}], "num": 8228}