{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e4ba67d8c9af8d3dd73847f4323c4d1e", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94aa037aaf7a207117372b73056304a3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "e0ebad67303a47fa3ab9d8532c92ffc60ae916e2", "commitAfterChange": "6940f5238f5f044dc7dc7f5472f64a2c5617a365", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["+\tboolean diamondNeedsDeferring = false;", "+\tlong sourceLevel = compilerOptions.sourceLevel;", "-\t\t\tif (isDiamond && this.typeExpected == null && this.expressionContext == INVOCATION_CONTEXT && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\tif (isDiamond && this.typeExpected == null && this.expressionContext == INVOCATION_CONTEXT && sourceLevel >= ClassFileConstants.JDK1_8) {", "-\t\t\t\t\treturn new PolyTypeBinding(this);", "+\t\t\t\t\tdiamondNeedsDeferring = true;", "-\t\tboolean argHasError = compilerOptions.sourceLevel < ClassFileConstants.JDK1_5;", "+\t\tboolean argHasError = sourceLevel < ClassFileConstants.JDK1_5;", "-\t\tTypeBinding argumentType;", "-\t\t\tif ((argumentType = argumentTypes[i] = argument.resolveType(scope)) == null) {", "+\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null) {", "-\t\t\tif (argumentType != null && argumentType.kind() == Binding.POLY_TYPE)", "+\t\t\tif (sourceLevel >= ClassFileConstants.JDK1_8 && argument.isPolyExpression())", "-\tif (isDiamond) {", "-\t\tTypeBinding [] inferredTypes = inferElidedTypes(((ParameterizedTypeBinding) this.resolvedType).genericType(), null, argumentTypes, scope);", "+\tif (isDiamond && !diamondNeedsDeferring) {", "+\t\tReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();", "+\t\tTypeBinding [] inferredTypes = inferElidedTypes(genericType, genericType.enclosingType(), argumentTypes, scope);", "-\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\tReferenceBinding receiverType = (ReferenceBinding) this.resolvedType;", "+\tif (diamondNeedsDeferring) {", "+\t\t// in this preliminary mode use the raw receiver type for constructor lookup, to avoid spurious type errors", "+\t\treceiverType = (ReferenceBinding) receiverType.original();", "+\t\treceiverType = scope.environment().createRawType(receiverType, receiverType.enclosingType());", "+\t\tthis.inferenceKind = 1; // inference needed!", "+\t}", "+\tthis.binding = findConstructorBinding(scope, this, receiverType, argumentTypes, polyExpressionSeen);", "+", "-\tthis.binding = scope.getConstructor(allocationType, argumentTypes, this);", "-\tif (polyExpressionSeen) ", "-\t\tresolvePolyExpressionArguments(scope, this.binding, this.arguments, argumentTypes);", "-\t", "-\tif (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, argumentTypes, argsContainCast, this)) {", "-\t\tthis.bits |= ASTNode.Unchecked;", "+\tif (!diamondNeedsDeferring) { // don't check diamonds before we have the target type", "+\t\tif (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, argumentTypes, argsContainCast, this)) {", "+\t\t\tthis.bits |= ASTNode.Unchecked;", "+\t\t}", "- \t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, null, argumentTypes, scope);", "+ \t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), argumentTypes, scope);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c13b053d252dcbe1fef6e3cb14cdb633", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "175caf4c91bc68c67c64b6e69e5b88fec75be023", "commitAfterChange": "2a90eeb9372f2a1a1f5e7c24d7c19363b361caf2", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tif (isDiamond) {", "-\t\t\tReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();", "-\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());", "-\t\t\tif (this.typeExpected == null && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8 && this.expressionContext.definesTargetType()) {", "-\t\t\t\tthis.binding = inferConstructorOfElidedParameterizedType(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "-\t\t\t\tif (this.binding == null) {", "-\t\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "-\t\t\t\t\treturn this.resolvedType = null;", "-\t\t\t\t}", "-\t\t\t\treturn new PolyTypeBinding(this);", "-\t\t\t}", "-\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "-\t\t\tif (inferredTypes == null) {", "-\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "-\t\t\t\treturn this.resolvedType = null;", "-\t\t\t}", "-\t\t\tReferenceBinding allocationType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "-\t\t\tthis.resolvedType = this.type.resolvedType = allocationType; ", "+\t} ", "+\tif (isDiamond) {", "+\t\tthis.binding = inferConstructorOfElidedParameterizedType(scope);", "+\t\tif (this.binding == null || !this.binding.isValidBinding()) {", "+\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "+\t\t\treturn this.resolvedType = null;", "+\t\tif (this.typeExpected == null && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8 && this.expressionContext.definesTargetType()) {", "+\t\t\treturn new PolyTypeBinding(this);", "+\t\t}", "+\t\tthis.resolvedType = this.type.resolvedType = this.binding.declaringClass;", "+\t\tresolvePolyExpressionArguments(this, this.binding, this.argumentTypes, scope);", "-\t\tif (isDiamond) {", "-\t\t\tReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();", "-\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());", "-\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "-\t\t\tif (inferredTypes == null) {", "-\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "-\t\t\t\treturn this.resolvedType = null;", "-\t\t\t}", "-\t\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "-\t\t}", "+\t\tthis.binding = findConstructorBinding(scope, this, (ReferenceBinding) this.resolvedType, this.argumentTypes);", "-\t", "-\tReferenceBinding allocationType = (ReferenceBinding) this.resolvedType;", "-\tthis.binding = findConstructorBinding(scope, this, allocationType, this.argumentTypes);", "-\t\t", "-\t\t\tthis.binding.declaringClass = allocationType;", "+\t\t\tthis.binding.declaringClass = (ReferenceBinding) this.resolvedType;", "-\tif (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {", "+\tif (checkInvocationArguments(scope, null, this.resolvedType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {", "- \t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+ \t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, scope);", "-\treturn allocationType;", "+\treturn this.resolvedType;"]}], "num": 26144}