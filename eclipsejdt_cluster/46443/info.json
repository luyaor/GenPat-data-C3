{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fcadee1fdfce7fd5db4523befaa5469b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "024924592205fcf6720f22cd06d2e188", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "e760e456d0e96ba9bce504014e582b9dbdf7e542", "commitAfterChange": "c67d112c20f07c2dcda11714ef23687a9781a753", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\tboolean isLegal = checkCastTypesCompatibility(scope, castType, expressionType, this.expression);", "+", "+\t\t\t// internally for type checking use the unannotated types:", "+\t\t\tTypeBinding unannotatedCastType = castType.unannotated();", "+\t\t\tint nullityMismatch = findNullTypeAnnotationMismatch(castType, expressionType, -1);", "+\t\t\tif (nullityMismatch > 0)", "+\t\t\t\tcastType = unannotatedCastType; // problem exists, so use the unannotated type also externally", "+\t\t\texpressionType = expressionType.unannotated();", "+", "+\t\t\tboolean isLegal = checkCastTypesCompatibility(scope, unannotatedCastType, expressionType, this.expression);", "-\t\t\t\tthis.expression.computeConversion(scope, castType, expressionType);", "+\t\t\t\tthis.expression.computeConversion(scope, unannotatedCastType, expressionType);", "+\t\t\t\t} else if (nullityMismatch > 0) {", "+\t\t\t\t\t// report null annotation issue at medium priority", "+\t\t\t\t\tscope.problemReporter().unsafeNullnessCast(this, scope);", "-\t\t\t\t\tif (castType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){", "-\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.type, castType);", "+\t\t\t\t\tif (unannotatedCastType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){", "+\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.type, unannotatedCastType);", "-\t\t\t\tif ((castType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error", "-\t\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "+\t\t\t\tif ((unannotatedCastType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error", "+\t\t\t\t\tscope.problemReporter().typeCastError(this, unannotatedCastType, expressionType);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b651cb39f994e029e8642a66da3654f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java", "commitBeforeChange": "ba9e3449f64c91617b5be3decfc1def93b0260fd", "commitAfterChange": "fc981e7b8dbede817ba4f79a36a2d73299506e96", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t\tTypeBinding resultType = TypeBinding.wellKnownType(scope, result & 0x0000F);", "+\t\tif (checkCastCompatibility()) {", "+\t\t\tif (originalLhsType.id != T_JavaLangString && resultType.id != T_JavaLangString) {", "+\t\t\t\tif (!checkCastTypesCompatibility(scope, originalLhsType, resultType, null)) {", "+\t\t\t\t\tscope.problemReporter().invalidOperator(this, originalLhsType, expressionType);", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}], "num": 46443}