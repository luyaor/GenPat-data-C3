{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "df32e4c6b25d8db1d9550c6a88c7af3f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b40d62558e57519bede9b29fa8830945", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "f6e646cfd67462923a3ee7e8121ae224b9177415", "commitAfterChange": "c2914e56411382198ea8ccc84da3c9283a570f77", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 61, "signatureBeforeChange": "  \tprivate void addNewEntry(final int InsideClasspath, final int InsideSourcepath, ArrayList bootclasspaths, ArrayList classpaths,ArrayList sourcepathClasspaths, String currentClasspathName, ArrayList currentRuleSpecs, int mode, String customEncoding)", "signatureAfterChange": "  \tprivate void addNewEntry(ArrayList paths, String currentClasspathName, ArrayList currentRuleSpecs, String customEncoding, boolean isSource)", "diff": ["+", "+\tprivate void addNewEntry(ArrayList paths, String currentClasspathName, ArrayList currentRuleSpecs, String customEncoding, boolean isSource) {", "+\t\tAccessRule[] accessRules = new AccessRule[currentRuleSpecs.size()];", "+\t\tboolean rulesOK = true;", "+\t\tIterator i = currentRuleSpecs.iterator();", "+\t\tint j = 0;", "+\t\twhile (i.hasNext()) {", "+\t\t\tString ruleSpec = (String) i.next();", "+\t\t\tchar key = ruleSpec.charAt(0);", "+\t\t\tString pattern = ruleSpec.substring(1);", "+\t\t\tif (pattern.length() > 0) {", "+\t\t\t\tswitch (key) {", "+\t\t\t\tcase '+':", "+\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "+\t\t\t\t\t\t\t.toCharArray(), 0);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase '~':", "+\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "+\t\t\t\t\t\t\t.toCharArray(),", "+\t\t\t\t\t\t\tIProblem.DiscouragedReference);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase '-':", "+\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "+\t\t\t\t\t\t\t.toCharArray(),", "+\t\t\t\t\t\t\tIProblem.ForbiddenReference);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase '?':", "+\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "+\t\t\t\t\t\t\t.toCharArray(),", "+\t\t\t\t\t\t\tIProblem.ForbiddenReference, true/*keep looking for accessible type*/);", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\trulesOK = false;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\trulesOK = false;", "+\t\t\t}", "+\t\t}", "+\t\tif (rulesOK) {", "+\t\t\tString templates[] = new String[AccessRuleSet.MESSAGE_TEMPLATES_LENGTH];", "+\t\t\ttemplates[0] = Main.bind(", "+\t\t\t\t\"template.restrictedAccess.type\", //$NON-NLS-1$", "+\t\t\t\tnew String[] {\"{0}\", currentClasspathName}); //$NON-NLS-1$ ", "+\t\t\ttemplates[1] = Main.bind(", "+\t\t\t\t\"template.restrictedAccess.constructor\", //$NON-NLS-1$", "+\t\t\t\tnew String[] {\"{0}\", currentClasspathName}); //$NON-NLS-1$ ", "+\t\t\ttemplates[2] = Main.bind(", "+\t\t\t\t\"template.restrictedAccess.method\", //$NON-NLS-1$", "+\t\t\t\tnew String[] {\"{0}\", \"{1}\", currentClasspathName}); //$NON-NLS-1$ //$NON-NLS-2$ ", "+\t\t\ttemplates[3] = Main.bind(", "+\t\t\t\t\"template.restrictedAccess.field\", //$NON-NLS-1$", "+\t\t\t\tnew String[] {\"{0}\", \"{1}\", currentClasspathName}); //$NON-NLS-1$ //$NON-NLS-2$ ", "+\t\t\tAccessRuleSet accessRuleSet = new AccessRuleSet(accessRules, templates);", "+\t\t\tFileSystem.Classpath currentClasspath = FileSystem", "+\t\t\t\t\t.getClasspath(currentClasspathName,", "+\t\t\t\t\t\t\tcustomEncoding, 0, accessRuleSet);", "+\t\t\tif (currentClasspath != null) {", "+\t\t\t\tpaths.add(currentClasspath);", "+\t\t\t\tif (isSource && currentClasspath instanceof ClasspathDirectory) {", "+\t\t\t\t\t((ClasspathDirectory) currentClasspath).mode = ", "+\t\t\t\t\t\tClasspathDirectory.SOURCE;", "+\t\t\t\t\t// TODO may consider adding this attribute to other classpath natures", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.logger.logIncorrectClasspath(currentClasspathName);", "+\t\t\t\t// we go on anyway", "+\t\t\t}", "+\t\t} else {", "+\t\t\tthis.logger.logIncorrectClasspath(currentClasspathName);", "+\t\t\t// we go on anyway", "+\t\t}", "-\tprivate void addNewEntry(final int InsideClasspath, final int InsideSourcepath, ArrayList bootclasspaths, ArrayList classpaths,ArrayList sourcepathClasspaths, String currentClasspathName, ArrayList currentRuleSpecs, int mode, String customEncoding) {", "-\t\tAccessRule[] accessRules = new AccessRule[currentRuleSpecs", "-\t\t\t\t.size()];", "-\t\tboolean rulesOK = true;", "-\t\tIterator i = currentRuleSpecs.iterator();", "-\t\tint j = 0;", "-\t\twhile (i.hasNext()) {", "-\t\t\tString ruleSpec = (String) i.next();", "-\t\t\tchar key = ruleSpec.charAt(0);", "-\t\t\tString pattern = ruleSpec.substring(1);", "-\t\t\tif (pattern.length() > 0) {", "-\t\t\t\tswitch (key) {", "-\t\t\t\tcase '+':", "-\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t\t.toCharArray(), 0);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase '~':", "-\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t\t.toCharArray(),", "-\t\t\t\t\t\t\tIProblem.DiscouragedReference);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase '-':", "-\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t\t.toCharArray(),", "-\t\t\t\t\t\t\tIProblem.ForbiddenReference);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase '?':", "-\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t\t.toCharArray(),", "-\t\t\t\t\t\t\tIProblem.ForbiddenReference, true/*keep looking for accessible type*/);", "-\t\t\t\t\tbreak;", "-\t\t\t\tdefault:", "-\t\t\t\t\trulesOK = false;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\trulesOK = false;", "-\t\t\t}", "-\t\t}", "-\t\tif (rulesOK) {", "-\t\t\tString templates[] = new String[AccessRuleSet.MESSAGE_TEMPLATES_LENGTH];", "-\t\t\ttemplates[0] = Main.bind(", "-\t\t\t\t\"template.restrictedAccess.type\", //$NON-NLS-1$", "-\t\t\t\tnew String[] {\"{0}\", currentClasspathName}); //$NON-NLS-1$ ", "-\t\t\ttemplates[1] = Main.bind(", "-\t\t\t\t\"template.restrictedAccess.constructor\", //$NON-NLS-1$", "-\t\t\t\tnew String[] {\"{0}\", currentClasspathName}); //$NON-NLS-1$ ", "-\t\t\ttemplates[2] = Main.bind(", "-\t\t\t\t\"template.restrictedAccess.method\", //$NON-NLS-1$", "-\t\t\t\tnew String[] {\"{0}\", \"{1}\", currentClasspathName}); //$NON-NLS-1$ //$NON-NLS-2$ ", "-\t\t\ttemplates[3] = Main.bind(", "-\t\t\t\t\"template.restrictedAccess.field\", //$NON-NLS-1$", "-\t\t\t\tnew String[] {\"{0}\", \"{1}\", currentClasspathName}); //$NON-NLS-1$ //$NON-NLS-2$ ", "-\t\t\tAccessRuleSet accessRuleSet = new AccessRuleSet(accessRules, templates);", "-\t\t\tFileSystem.Classpath currentClasspath = FileSystem", "-\t\t\t\t\t.getClasspath(currentClasspathName,", "-\t\t\t\t\t\t\tcustomEncoding, 0, accessRuleSet);", "-\t\t\tif (currentClasspath != null) {", "-\t\t\t\tif (mode == InsideClasspath) {", "-\t\t\t\t\tclasspaths.add(currentClasspath);", "-\t\t\t\t} else if (mode == InsideSourcepath) {", "-\t\t\t\t\tif (currentClasspath instanceof ClasspathDirectory) {", "-\t\t\t\t\t\t((ClasspathDirectory) currentClasspath).mode = ", "-\t\t\t\t\t\t\tClasspathDirectory.SOURCE; ", "-\t\t\t\t\t\t// TODO may consider adding this attribute to other classpath natures", "-\t\t\t\t\t}", "-\t\t\t\t\tsourcepathClasspaths.add(currentClasspath);", "-\t\t\t\t} else { // inside bootclasspath", "-\t\t\t\t\tbootclasspaths.add(currentClasspath);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tthis.logger.logIncorrectClasspath(currentClasspathName);", "-\t\t\t\t// we go on anyway", "-\t\t\t}", "-\t\t} else {", "-\t\t\tthis.logger.logIncorrectClasspath(currentClasspathName);", "-\t\t\t// we go on anyway", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c6bdaeb781af64c3929260cf7ce80d18", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "1fd4391b9d956e4b222e75746a12248fe673ae09", "commitAfterChange": "0ac06ace387f6f7ca79dcd41a12a6564b157c4e4", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 57, "signatureBeforeChange": "  private void addNewEntry(ArrayList paths, String currentClasspathName,  \t\tArrayList currentRuleSpecs, String customEncoding,  \t\tString destPath, boolean isSourceOnly,  \t\tboolean rejectDestinationPathOnJars) throws InvalidInputException", "signatureAfterChange": "  protected void addNewEntry(ArrayList paths, String currentClasspathName,  \t\tArrayList currentRuleSpecs, String customEncoding,  \t\tString destPath, boolean isSourceOnly,  \t\tboolean rejectDestinationPathOnJars) throws InvalidInputException", "diff": ["+", "+protected void addNewEntry(ArrayList paths, String currentClasspathName, ", "+\t\tArrayList currentRuleSpecs, String customEncoding, ", "+\t\tString destPath, boolean isSourceOnly, ", "+\t\tboolean rejectDestinationPathOnJars) throws InvalidInputException {", "+\t", "+\tint rulesSpecsSize = currentRuleSpecs.size();", "+\tAccessRuleSet accessRuleSet = null;\t", "+\tif (rulesSpecsSize != 0) {", "+\t\tAccessRule[] accessRules = new AccessRule[currentRuleSpecs.size()];", "+    \tboolean rulesOK = true;", "+    \tIterator i = currentRuleSpecs.iterator();", "+    \tint j = 0;", "+    \twhile (i.hasNext()) {", "+    \t\tString ruleSpec = (String) i.next();", "+    \t\tchar key = ruleSpec.charAt(0);", "+    \t\tString pattern = ruleSpec.substring(1);", "+    \t\tif (pattern.length() > 0) {", "+    \t\t\tswitch (key) {", "+    \t\t\tcase '+':", "+    \t\t\t\taccessRules[j++] = new AccessRule(pattern", "+    \t\t\t\t\t\t.toCharArray(), 0);", "+    \t\t\t\tbreak;", "+    \t\t\tcase '~':", "+    \t\t\t\taccessRules[j++] = new AccessRule(pattern", "+    \t\t\t\t\t\t.toCharArray(),", "+    \t\t\t\t\t\tIProblem.DiscouragedReference);", "+    \t\t\t\tbreak;", "+    \t\t\tcase '-':", "+    \t\t\t\taccessRules[j++] = new AccessRule(pattern", "+    \t\t\t\t\t\t.toCharArray(),", "+    \t\t\t\t\t\tIProblem.ForbiddenReference);", "+    \t\t\t\tbreak;", "+    \t\t\tcase '?':", "+    \t\t\t\taccessRules[j++] = new AccessRule(pattern", "+    \t\t\t\t\t\t.toCharArray(),", "+    \t\t\t\t\t\tIProblem.ForbiddenReference, true/*keep looking for accessible type*/);", "+    \t\t\t\tbreak;", "+    \t\t\tdefault:", "+    \t\t\t\trulesOK = false;", "+    \t\t\t}", "+    \t\t} else {", "+    \t\t\trulesOK = false;", "+    \t\t}", "+    \t}", "+    \tif (rulesOK) {", "+    \t\tString templates[] = new String[AccessRuleSet.MESSAGE_TEMPLATES_LENGTH];", "+    \t\ttemplates[0] = this.bind(", "+    \t\t\t\"template.restrictedAccess.type\", //$NON-NLS-1$", "+    \t\t\tnew String[] {\"{0}\", currentClasspathName}); //$NON-NLS-1$ ", "+    \t\ttemplates[1] = this.bind(", "+    \t\t\t\"template.restrictedAccess.constructor\", //$NON-NLS-1$", "+    \t\t\tnew String[] {\"{0}\", currentClasspathName}); //$NON-NLS-1$ ", "+    \t\ttemplates[2] = this.bind(", "+    \t\t\t\"template.restrictedAccess.method\", //$NON-NLS-1$", "+    \t\t\tnew String[] {\"{0}\", \"{1}\", currentClasspathName}); //$NON-NLS-1$ //$NON-NLS-2$ ", "+    \t\ttemplates[3] = this.bind(", "+    \t\t\t\"template.restrictedAccess.field\", //$NON-NLS-1$", "+    \t\t\tnew String[] {\"{0}\", \"{1}\", currentClasspathName}); //$NON-NLS-1$ //$NON-NLS-2$ ", "+    \t\taccessRuleSet = new AccessRuleSet(accessRules, templates);", "+    \t} else {", "+    \t\t// we go on anyway", "+    \t\tthis.logger.logIncorrectClasspath(currentClasspathName);", "+    \t\treturn;", "+    \t}", "+\tif (NONE.equals(destPath)) {", "+\t\tdestPath = NONE; // keep == comparison valid", "+\t}", "+\tif (rejectDestinationPathOnJars && destPath != null &&", "+\t\t\t(currentClasspathName.endsWith(\".jar\") || //$NON-NLS-1$ ", "+\t\t\t\tcurrentClasspathName.endsWith(\".zip\"))) { //$NON-NLS-1$ ", "+\t\tthrow new InvalidInputException(", "+\t\t\tthis.bind(\"configure.unexpectedDestinationPathEntryFile\", //$NON-NLS-1$ ", "+\t\t\t\t\t\tcurrentClasspathName));", "+\t}", "+\tFileSystem.Classpath currentClasspath = FileSystem.getClasspath(", "+\t\t\tcurrentClasspathName,", "+\t\t\tcustomEncoding,", "+\t\t\tisSourceOnly,", "+\t\t\taccessRuleSet,", "+\t\t\tdestPath);", "+\tif (currentClasspath != null) {", "+\t\tpaths.add(currentClasspath);", "+\t} else {", "+\t\t// we go on anyway", "+\t\tthis.logger.logIncorrectClasspath(currentClasspathName);", "+\t}", "+}", "-", "-private void addNewEntry(ArrayList paths, String currentClasspathName, ", "-\t\tArrayList currentRuleSpecs, String customEncoding, ", "-\t\tString destPath, boolean isSourceOnly, ", "-\t\tboolean rejectDestinationPathOnJars) throws InvalidInputException {", "-\tAccessRule[] accessRules = new AccessRule[currentRuleSpecs.size()];", "-\tboolean rulesOK = true;", "-\tIterator i = currentRuleSpecs.iterator();", "-\tint j = 0;", "-\twhile (i.hasNext()) {", "-\t\tString ruleSpec = (String) i.next();", "-\t\tchar key = ruleSpec.charAt(0);", "-\t\tString pattern = ruleSpec.substring(1);", "-\t\tif (pattern.length() > 0) {", "-\t\t\tswitch (key) {", "-\t\t\tcase '+':", "-\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t.toCharArray(), 0);", "-\t\t\t\tbreak;", "-\t\t\tcase '~':", "-\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t.toCharArray(),", "-\t\t\t\t\t\tIProblem.DiscouragedReference);", "-\t\t\t\tbreak;", "-\t\t\tcase '-':", "-\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t.toCharArray(),", "-\t\t\t\t\t\tIProblem.ForbiddenReference);", "-\t\t\t\tbreak;", "-\t\t\tcase '?':", "-\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t.toCharArray(),", "-\t\t\t\t\t\tIProblem.ForbiddenReference, true/*keep looking for accessible type*/);", "-\t\t\t\tbreak;", "-\t\t\tdefault:", "-\t\t\t\trulesOK = false;", "-\t\t\t}", "-\t\t} else {", "-\t\t\trulesOK = false;", "-\t\t}", "-\t}", "-\tif (rulesOK) {", "-\t\tString templates[] = new String[AccessRuleSet.MESSAGE_TEMPLATES_LENGTH];", "-\t\ttemplates[0] = Main.bind(", "-\t\t\t\"template.restrictedAccess.type\", //$NON-NLS-1$", "-\t\t\tnew String[] {\"{0}\", currentClasspathName}); //$NON-NLS-1$ ", "-\t\ttemplates[1] = Main.bind(", "-\t\t\t\"template.restrictedAccess.constructor\", //$NON-NLS-1$", "-\t\t\tnew String[] {\"{0}\", currentClasspathName}); //$NON-NLS-1$ ", "-\t\ttemplates[2] = Main.bind(", "-\t\t\t\"template.restrictedAccess.method\", //$NON-NLS-1$", "-\t\t\tnew String[] {\"{0}\", \"{1}\", currentClasspathName}); //$NON-NLS-1$ //$NON-NLS-2$ ", "-\t\ttemplates[3] = Main.bind(", "-\t\t\t\"template.restrictedAccess.field\", //$NON-NLS-1$", "-\t\t\tnew String[] {\"{0}\", \"{1}\", currentClasspathName}); //$NON-NLS-1$ //$NON-NLS-2$ ", "-\t\tAccessRuleSet accessRuleSet = new AccessRuleSet(accessRules, templates);", "-\t\tif (NONE.equals(destPath)) {", "-\t\t\tdestPath = NONE; // keep == comparison valid", "-\t\t}", "-\t\tif (rejectDestinationPathOnJars && destPath != null &&", "-\t\t\t\t(currentClasspathName.endsWith(\".jar\") || //$NON-NLS-1$ ", "-\t\t\t\t\tcurrentClasspathName.endsWith(\".zip\"))) { //$NON-NLS-1$ ", "-\t\t\tthrow new InvalidInputException(", "-\t\t\t\tMain.bind(\"configure.unexpectedDestinationPathEntryFile\", //$NON-NLS-1$ ", "-\t\t\t\t\t\t\tcurrentClasspathName));", "-\t\t}", "-\t\tFileSystem.Classpath currentClasspath = FileSystem.getClasspath(", "-\t\t\t\tcurrentClasspathName,", "-\t\t\t\tcustomEncoding,", "-\t\t\t\tisSourceOnly,", "-\t\t\t\taccessRuleSet,", "-\t\t\t\tdestPath);", "-\t\tif (currentClasspath != null) {", "-\t\t\tpaths.add(currentClasspath);", "-\t\t} else {", "-\t\t\tthis.logger.logIncorrectClasspath(currentClasspathName);", "-\t\t\t// we go on anyway", "-\t\t}", "-\t} else {", "-\t\tthis.logger.logIncorrectClasspath(currentClasspathName);", "-\t\t// we go on anyway", "-\t}"]}], "num": 50848}