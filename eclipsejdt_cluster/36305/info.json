{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d6ce6175c3ff2c7c704001a3f8d4f196", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b0508f62e76bcff40bd7b4907c4edd8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \r \tprivate void locateMatchesInCompilationUnit() throws CoreException", "signatureAfterChange": "\r private void locateMatchesInCompilationUnit() throws CoreException", "diff": ["-\r", "-\tprivate void locateMatchesInCompilationUnit() throws CoreException {\r", "-\t\t// get source\r", "-\t\tfinal char[] source = getContents((IFile) this.currentResource);\r", "-\r", "-\t\t// get main type name\r", "-\t\tString pathString = this.currentResource.toString();\r", "-\t\tint lastDot = pathString.lastIndexOf('/');\r", "-\t\t// remove folder path and extension \".java\"\r", "-\t\tfinal char[] mainTypeName =\r", "-\t\t\tpathString.substring(lastDot + 1, pathString.length() - 5).toCharArray();\r", "-\r", "-\t\t// parse\r", "-\t\tICompilationUnit sourceUnit = new ICompilationUnit() {\r", "-\t\t\tpublic char[] getContents() {\r", "-\t\t\t\treturn source;\r", "-\t\t\t}\r", "-\t\t\tpublic char[] getFileName() {\r", "-\t\t\t\treturn MatchLocator.this.currentResource.getName().toCharArray();\r", "-\t\t\t}\r", "-\t\t\tpublic char[] getMainTypeName() {\r", "-\t\t\t\treturn mainTypeName;\r", "-\t\t\t}\r", "-\t\t};\r", "-\t\tMatchSet set = new MatchSet(this);\r", "-\t\tthis.parser.matchSet = set;\r", "-\t\tCompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0);\r", "-\t\tCompilationUnitDeclaration parsedUnit =\r", "-\t\t\tthis.parser.parse(sourceUnit, compilationResult);\r", "-\r", "-\t\tif (parsedUnit != null) {\r", "-\t\t\t// report matches that don't need resolve\r", "-\t\t\tset.cuHasBeenResolved = false;\r", "-\t\t\tset.accuracy = IJavaSearchResultCollector.EXACT_MATCH;\r", "-\t\t\tset.reportMatching(parsedUnit);\r", "-\r", "-\t\t\t// resolve if needed\r", "-\t\t\tif (set.needsResolve()) {\r", "-\t\t\t\tif (parsedUnit.types != null) {\r", "-\t\t\t\t\t/**\r", "-\t\t\t\t\t * First approximation: reset the lookup environment -> this will recreate the bindings for the current CU\r", "-\t\t\t\t\t * Optimization: the binding resolution should be done for all compilation units at once\r", "-\t\t\t\t\t */\r", "-\t\t\t\t\tthis.lookupEnvironment.reset();\r", "-\r", "-\t\t\t\t\ttry {\r", "-\t\t\t\t\t\tlookupEnvironment.buildTypeBindings(parsedUnit);\r", "-\t\t\t\t\t\tif (parsedUnit.scope != null) {\r", "-\t\t\t\t\t\t\tlookupEnvironment.completeTypeBindings(parsedUnit, true);\r", "-\t\t\t\t\t\t\tparsedUnit.scope.faultInTypes();\r", "-\t\t\t\t\t\t\tparsedUnit.resolve();\r", "-\t\t\t\t\t\t\tthis.pattern.initializeFromLookupEnvironment(this.lookupEnvironment);\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t// report matches that needed resolve\r", "-\t\t\t\t\t\tset.cuHasBeenResolved = true;\r", "-\t\t\t\t\t\tset.accuracy = IJavaSearchResultCollector.EXACT_MATCH;\r", "-\t\t\t\t\t\tset.reportMatching(parsedUnit);\r", "-\t\t\t\t\t} catch (AbortCompilation e) {\r", "-\t\t\t\t\t\t// could not resolve (reasons include \"could not find library class\") -> ignore and report the unresolved nodes\r", "-\t\t\t\t\t\tset.cuHasBeenResolved = false;\r", "-\t\t\t\t\t\tset.accuracy = IJavaSearchResultCollector.POTENTIAL_MATCH;\r", "-\t\t\t\t\t\tset.reportMatching(parsedUnit);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r", "+}\r", "+private void locateMatchesInCompilationUnit() throws CoreException {\r", "+\t// get source\r", "+\tfinal char[] source = getContents((IFile)this.currentResource);\r", "+\t// get main type name\r", "+\tString pathString = this.currentResource.toString();\r", "+\tint lastDot = pathString.lastIndexOf('/');\r", "+\t// remove folder path and extension \".java\"\r", "+\tfinal char[] mainTypeName = pathString.substring(lastDot+1, pathString.length()-5).toCharArray(); \r", "+\r", "+\t// parse\r", "+\tICompilationUnit sourceUnit = new ICompilationUnit() {\r", "+\t\tpublic char[] getContents() {\r", "+\t\t\treturn source;\r", "+\t\t}\r", "+\t\tpublic char[] getFileName() {\r", "+\t\t\treturn MatchLocator.this.currentResource.getName().toCharArray();\r", "+\t\t}\r", "+\t\tpublic char[] getMainTypeName() {\r", "+\t\t\treturn mainTypeName;\r", "+\t\t}\r", "+\t};\r", "+\tMatchSet set = new MatchSet(this);\r", "+\tthis.parser.matchSet = set;\r", "+\tCompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0);  \r", "+\tCompilationUnitDeclaration parsedUnit = this.parser.parse(sourceUnit, compilationResult);\r", "+\r", "+\tif (parsedUnit != null) {\r", "+\t\t// report matches that don't need resolve\r", "+\t\tset.cuHasBeenResolved = false;\r", "+\t\tset.accuracy = IJavaSearchResultCollector.EXACT_MATCH;\r", "+\t\tset.reportMatching(parsedUnit);\r", "+\t\t\r", "+\t\t// resolve if needed\r", "+\t\tif (set.needsResolve()) {\r", "+\t\t\tif (parsedUnit.types != null) {\r", "+\t\t\t\t/**\r", "+\t\t\t\t * First approximation: reset the lookup environment -> this will recreate the bindings for the current CU\r", "+\t\t\t\t * Optimization: the binding resolution should be done for all compilation units at once\r", "+\t\t\t\t */\r", "+\t\t\t\tthis.lookupEnvironment.reset();\r", "+\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tlookupEnvironment.buildTypeBindings(parsedUnit);\r", "+\t\t\t\t\tif (parsedUnit.scope != null) {\r", "+\t\t\t\t\t\tlookupEnvironment.completeTypeBindings(parsedUnit, true);\r", "+\t\t\t\t\t\tparsedUnit.scope.faultInTypes();\r", "+\t\t\t\t\t\tparsedUnit.resolve();\r", "+\t\t\t\t\t\t//this.pattern.initializeFromLookupEnvironment(this.lookupEnvironment);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\t// report matches that needed resolve\r", "+\t\t\t\t\tset.cuHasBeenResolved = true;\r", "+\t\t\t\t\tset.accuracy = IJavaSearchResultCollector.EXACT_MATCH;\r", "+\t\t\t\t\tset.reportMatching(parsedUnit);\r", "+\t\t\t\t} catch (AbortCompilation e) {\r", "+\t\t\t\t\t// could not resolve (reasons include \"could not find library class\") -> ignore and report the unresolved nodes\r", "+\t\t\t\t\tset.cuHasBeenResolved = false;\r", "+\t\t\t\t\tset.accuracy = IJavaSearchResultCollector.POTENTIAL_MATCH;\r", "+\t\t\t\t\tset.reportMatching(parsedUnit);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f2ae4c0ae154e9457993fd5291493b4e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "673b7eda95cd26449992e862f0c63f2c612903a0", "commitAfterChange": "b04602938404af4f8569a399fb36a5018768a262", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r \tpublic void select(\r \t\tICompilationUnit sourceUnit,\r \t\tint selectionSourceStart,\r \t\tint selectionSourceEnd)", "signatureAfterChange": "\r public void select(ICompilationUnit sourceUnit, int selectionSourceStart, int selectionSourceEnd)", "diff": ["-\t */\r", "-\tpublic void select(\r", "-\t\tICompilationUnit sourceUnit,\r", "-\t\tint selectionSourceStart,\r", "-\t\tint selectionSourceEnd) {\r", "-\r", "-\t\tchar[] source = sourceUnit.getContents();\r", "-\t\tif (!checkSelection(source, selectionSourceStart, selectionSourceEnd - 1))\r", "-\t\t\treturn;\r", "-\t\ttry {\r", "-\t\t\tacceptedAnswer = false;\r", "-\t\t\tCompilationResult result = new CompilationResult(sourceUnit, 1, 1);\r", "-\t\t\tCompilationUnitDeclaration parsedUnit =\r", "-\t\t\t\tparser.dietParse(sourceUnit, result, actualSelectionStart, actualSelectionEnd);\r", "-\r", "-\t\t\tif (parsedUnit != null) {\r", "-\t\t\t\t// scan the package & import statements first\r", "-\t\t\t\tif (parsedUnit.currentPackage instanceof SelectionOnPackageReference) {\r", "-\t\t\t\t\tchar[][] tokens =\r", "-\t\t\t\t\t\t((SelectionOnPackageReference) parsedUnit.currentPackage).tokens;\r", "-\t\t\t\t\trequestor.acceptPackage(CharOperation.concatWith(tokens, '.'));\r", "-\t\t\t\t\treturn;\r", "-\t\t\t\t}\r", "-\t\t\t\tImportReference[] imports = parsedUnit.imports;\r", "-\t\t\t\tif (imports != null) {\r", "-\t\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {\r", "-\t\t\t\t\t\tImportReference importReference = imports[i];\r", "-\t\t\t\t\t\tif (importReference instanceof SelectionOnImportReference) {\r", "-\t\t\t\t\t\t\tchar[][] tokens = ((SelectionOnImportReference) importReference).tokens;\r", "-\t\t\t\t\t\t\trequestor.acceptPackage(CharOperation.concatWith(tokens, '.'));\r", "-\t\t\t\t\t\t\tnameEnvironment.findTypes(CharOperation.concatWith(tokens, '.'), this);\r", "-\t\t\t\t\t\t\tif (!acceptedAnswer)\r", "-\t\t\t\t\t\t\t\tnameEnvironment.findTypes(selectedIdentifier, this);\r", "-\t\t\t\t\t\t\t// try with simple type name\r", "-\t\t\t\t\t\t\treturn;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\r", "-\t\t\t\tif (parsedUnit.types != null) {\r", "-\t\t\t\t\tlookupEnvironment.buildTypeBindings(parsedUnit);\r", "-\t\t\t\t\tif (parsedUnit.scope != null) {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tlookupEnvironment.completeTypeBindings(parsedUnit, true);\r", "-\t\t\t\t\t\t\tparsedUnit.scope.faultInTypes();\r", "-\t\t\t\t\t\t\tparseMethod(parsedUnit, selectionSourceStart);\r", "-\t\t\t\t\t\t\tparsedUnit.resolve();\r", "-\t\t\t\t\t\t} catch (SelectionNodeFound e) {\r", "-\t\t\t\t\t\t\tif (e.binding != null) {\r", "-\t\t\t\t\t\t\t\t// if null then we found a problem in the selection node\r", "-\t\t\t\t\t\t\t\tselectFrom(e.binding);\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\t// only reaches here if no selection could be derived from the parsed tree\r", "-\t\t\t// thus use the selected source and perform a textual type search\r", "-\t\t\tif (!acceptedAnswer) {\r", "-\t\t\t\tnameEnvironment.findTypes(selectedIdentifier, this);\r", "-\t\t\t}\r", "-\t\t} catch (IndexOutOfBoundsException e) { // work-around internal failure - 1GEMF6D\t\t\r", "-\t\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "-\t\t} finally {\r", "-\t\t\treset();\r", "+ */\r", "+public void select(ICompilationUnit sourceUnit, int selectionSourceStart, int selectionSourceEnd) {\r", "+\tchar[] source = sourceUnit.getContents();\r", "+\tif (!checkSelection(source, selectionSourceStart, selectionSourceEnd)) return;\r", "+\ttry{\r", "+\t\tacceptedAnswer = false;\r", "+\t\tCompilationResult result = new CompilationResult(sourceUnit, 1, 1);\r", "+\t\tCompilationUnitDeclaration parsedUnit = parser.dietParse(sourceUnit, result, actualSelectionStart, actualSelectionEnd);\r", "+\r", "+\t\tif (parsedUnit != null) {\r", "+\t\t\t// scan the package & import statements first\r", "+\t\t\tif (parsedUnit.currentPackage instanceof SelectionOnPackageReference) {\r", "+\t\t\t\tchar[][] tokens = ((SelectionOnPackageReference) parsedUnit.currentPackage).tokens;\r", "+\t\t\t\trequestor.acceptPackage(CharOperation.concatWith(tokens, '.'));\r", "+\t\t\tImportReference[] imports = parsedUnit.imports;\r", "+\t\t\tif (imports != null) {\r", "+\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {\r", "+\t\t\t\t\tImportReference importReference = imports[i];\r", "+\t\t\t\t\tif (importReference instanceof SelectionOnImportReference) {\r", "+\t\t\t\t\t\tchar[][] tokens = ((SelectionOnImportReference) importReference).tokens;\r", "+\t\t\t\t\t\trequestor.acceptPackage(CharOperation.concatWith(tokens, '.'));\r", "+\t\t\t\t\t\tnameEnvironment.findTypes(CharOperation.concatWith(tokens, '.'), this);\r", "+\t\t\t\t\t\tif (!acceptedAnswer)\r", "+\t\t\t\t\t\t\tnameEnvironment.findTypes(selectedIdentifier, this); // try with simple type name\r", "+\t\t\t\t\t\treturn;\r", "+\t\t\t\t}\r", "+\t\t\tif (parsedUnit.types != null) {\r", "+\t\t\t\tlookupEnvironment.buildTypeBindings(parsedUnit);\r", "+\t\t\t\tif (parsedUnit.scope != null) {\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tlookupEnvironment.completeTypeBindings(parsedUnit, true);\r", "+\t\t\t\t\t\tparsedUnit.scope.faultInTypes();\r", "+\t\t\t\t\t\tparseMethod(parsedUnit, selectionSourceStart);\r", "+\t\t\t\t\t\tparsedUnit.resolve();\r", "+\t\t\t\t\t} catch (SelectionNodeFound e) {\r", "+\t\t\t\t\t\tif (e.binding != null) { // if null then we found a problem in the selection node\r", "+\t\t\t\t\t\t\tselectFrom(e.binding);\r", "+\t\t}\r", "+\t\t// only reaches here if no selection could be derived from the parsed tree\r", "+\t\t// thus use the selected source and perform a textual type search\r", "+\t\tif (!acceptedAnswer) {\r", "+\t\t\tnameEnvironment.findTypes(selectedIdentifier, this);\r", "+\t\t}\r", "+\t} catch (IndexOutOfBoundsException e) { // work-around internal failure - 1GEMF6D\t\t\r", "+\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "+\t} finally {\r", "+\t\treset();\r", "+\t}\t\r", "+}\r"]}], "num": 36305}