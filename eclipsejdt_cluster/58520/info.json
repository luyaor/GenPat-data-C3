{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "17a86f990a4d134ddbc4d185a75c0e8f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60782119c3f7a1365c03cba5ff585d04", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "673b7eda95cd26449992e862f0c63f2c612903a0", "commitAfterChange": "b04602938404af4f8569a399fb36a5018768a262", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r \r \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "\r public TypeBinding resolveType(BlockScope scope)", "diff": ["+}\r", "+public TypeBinding resolveType(BlockScope scope) {\r", "+\t// Answer the signature type of the field.\r", "+\t// constants are propaged when the field is final\r", "+\t// and initialized with a (compile time) constant \r", "+\r", "+\t// regular receiver reference \r", "+\tthis.receiverType = receiver.resolveType(scope);\r", "+\tif (this.receiverType == null){\r", "+\t\tconstant = NotAConstant;\r", "+\t\treturn null;\r", "+\t}\r", "+\t// the case receiverType.isArrayType and token = 'length' is handled by the scope API\r", "+\tbinding = scope.getField(this.receiverType, token, this);\r", "+\tif (!binding.isValidBinding()) {\r", "+\t\tconstant = NotAConstant;\r", "+\t\tscope.problemReporter().invalidField(this, this.receiverType);\r", "+\t\treturn null;\r", "+\tif (isFieldUseDeprecated(binding, scope))\r", "+\t\tscope.problemReporter().deprecatedField(binding, this);\r", "+\t// check for this.x in static is done in the resolution of the receiver\r", "+\tconstant = FieldReference.getConstantFor(binding, receiver == ThisReference.ThisImplicit, this, 0);\r", "+\tif (!receiver.isThis())\r", "+\t\tconstant = NotAConstant;\r", "+\r", "+\t// if the binding declaring class is not visible, need special action\r", "+\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "+\tif (binding.declaringClass != this.receiverType\r", "+\t\t&& binding.declaringClass != null // array.length\r", "+\t\t&& binding.constant == NotAConstant\r", "+\t\t&& !binding.declaringClass.canBeSeenBy(scope))\r", "+\t\t\tbinding = new FieldBinding(binding, (ReferenceBinding) this.receiverType);\r", "+\treturn binding.type;\r", "+}\r", "-\r", "-\tpublic TypeBinding resolveType(BlockScope scope) {\r", "-\t\t// Answer the signature type of the field.\r", "-\t\t// constants are propaged when the field is final\r", "-\t\t// and initialized with a (compile time) constant \r", "-\r", "-\t\t// regular receiver reference \r", "-\t\tTypeBinding receiverType = receiver.resolveType(scope);\r", "-\t\tif (receiverType == null) {\r", "-\t\t\tconstant = NotAConstant;\r", "-\t\t\treturn null;\r", "-\t\t}\r", "-\t\t// the case receiverType.isArrayType and token = 'length' is handled by the scope API\r", "-\t\tbinding = scope.getField(receiverType, token, this);\r", "-\t\tif (!binding.isValidBinding()) {\r", "-\t\t\tconstant = NotAConstant;\r", "-\t\t\tscope.problemReporter().invalidField(this, receiverType);\r", "-\t\t\treturn null;\r", "-\t\t}\r", "-\r", "-\t\tif (isFieldUseDeprecated(binding, scope))\r", "-\t\t\tscope.problemReporter().deprecatedField(binding, this);\r", "-\r", "-\t\t// check for this.x in static is done in the resolution of the receiver\r", "-\t\tconstant =\r", "-\t\t\tFieldReference.getConstantFor(\r", "-\t\t\t\tbinding,\r", "-\t\t\t\treceiver == ThisReference.ThisImplicit,\r", "-\t\t\t\tthis,\r", "-\t\t\t\t0);\r", "-\t\tif (!receiver.isThis())\r", "-\t\t\tconstant = NotAConstant;\r", "-\r", "-\t\t// if the binding declaring class is not visible, need special action\r", "-\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "-\t\tif (binding.declaringClass != receiverType\r", "-\t\t\t&& binding.declaringClass != null // array.length\r", "-\t\t\t&& binding.constant == NotAConstant\r", "-\t\t\t&& !binding.declaringClass.canBeSeenBy(scope))\r", "-\t\t\tbinding = new FieldBinding(binding, (ReferenceBinding) receiverType);\r", "-\t\treturn binding.type;\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eaab5ef6bc8cf58581f6f2313d8f1f9c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "717a44c6b6c761be0c48243cde9dff6857a6db32", "commitAfterChange": "df9941361641a347d1ba4ee80fe7f9c7468ba17a", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "\r \r \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-}\r", "-public TypeBinding resolveType(BlockScope scope) {\r", "-\t// Answer the signature type of the field.\r", "-\t// constants are propaged when the field is final\r", "-\t// and initialized with a (compile time) constant \r", "-\t// regular receiver reference \r", "-\tthis.receiverType = receiver.resolveType(scope);\r", "-\tif (this.receiverType == null){\r", "-\t\tconstant = NotAConstant;\r", "-\t\treturn null;\r", "-\t}\r", "-\t// the case receiverType.isArrayType and token = 'length' is handled by the scope API\r", "-\tthis.codegenBinding = this.binding = scope.getField(this.receiverType, token, this);\r", "-\tif (!binding.isValidBinding()) {\r", "-\t\tconstant = NotAConstant;\r", "-\t\tscope.problemReporter().invalidField(this, this.receiverType);\r", "-\t\treturn null;\r", "+\tpublic TypeBinding resolveType(BlockScope scope) {\r", "+\r", "+\t\t// Answer the signature type of the field.\r", "+\t\t// constants are propaged when the field is final\r", "+\t\t// and initialized with a (compile time) constant \r", "+\r", "+\t\t// regular receiver reference \r", "+\t\tthis.receiverType = receiver.resolveType(scope);\r", "+\t\tif (this.receiverType == null) {\r", "+\t\t\tconstant = NotAConstant;\r", "+\t\t\treturn null;\r", "+\t\t}\r", "+\t\t// the case receiverType.isArrayType and token = 'length' is handled by the scope API\r", "+\t\tthis.codegenBinding =\r", "+\t\t\tthis.binding = scope.getField(this.receiverType, token, this);\r", "+\t\tif (!binding.isValidBinding()) {\r", "+\t\t\tconstant = NotAConstant;\r", "+\t\t\tscope.problemReporter().invalidField(this, this.receiverType);\r", "+\t\t\treturn null;\r", "+\t\t}\r", "+\r", "+\t\tif (isFieldUseDeprecated(binding, scope))\r", "+\t\t\tscope.problemReporter().deprecatedField(binding, this);\r", "+\r", "+\t\t// check for this.x in static is done in the resolution of the receiver\r", "+\t\tconstant =\r", "+\t\t\tFieldReference.getConstantFor(\r", "+\t\t\t\tbinding,\r", "+\t\t\t\treceiver == ThisReference.ThisImplicit,\r", "+\t\t\t\tthis,\r", "+\t\t\t\tscope,\r", "+\t\t\t\t0);\r", "+\t\tif (!receiver.isThis())\r", "+\t\t\tconstant = NotAConstant;\r", "+\r", "+\t\treturn binding.type;\r", "-\tif (isFieldUseDeprecated(binding, scope))\r", "-\t\tscope.problemReporter().deprecatedField(binding, this);\r", "-\r", "-\t// check for this.x in static is done in the resolution of the receiver\r", "-\tconstant = FieldReference.getConstantFor(binding, receiver == ThisReference.ThisImplicit, this, 0);\r", "-\tif (!receiver.isThis())\r", "-\t\tconstant = NotAConstant;\r", "-\r", "-\treturn binding.type;\r", "-}\r"]}], "num": 58520}