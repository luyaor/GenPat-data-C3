{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f9ba148f215ce430cf145f3dd1fea581", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "312b67703b19974bb55b0f0ea263d3df", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java", "commitBeforeChange": "6fdaa2b9d78c89a1ed2269f5279c3e02cee4b6cd", "commitAfterChange": "8ec1d344fc5f9b16a04a2a15e36cb4db52cac4eb", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void generateCode( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tboolean valueRequired)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "diff": ["-\tpublic void generateCode(", "-\t\tBlockScope currentScope,", "-\t\tCodeStream codeStream,", "-\t\tboolean valueRequired) {", "+\tpublic void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {", "+", "-\t\tLabel falseLabel, endLabel;", "+\t\t\t// inlined value", "-\t\tbits |= OnlyValueRequiredMASK;", "-\t\tgenerateOptimizedBoolean(", "-\t\t\tcurrentScope,", "-\t\t\tcodeStream,", "-\t\t\tnull,", "-\t\t\t(falseLabel = new Label(codeStream)),", "-\t\t\tvalueRequired);", "-\t\t/*  improving code gen for such a case:\t\tboolean b = i < 0 || true; ", "-\t\t * since the label has never been used, we have the inlined value on the stack. */", "-\t\tif (falseLabel.hasForwardReferences()) {", "-\t\t\tif (valueRequired) {", "-\t\t\t\tcodeStream.iconst_1();", "-\t\t\t\tif ((bits & ValueForReturnMASK) != 0) {", "-\t\t\t\t\tcodeStream.ireturn();", "-\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.goto_(endLabel = new Label(codeStream));", "-\t\t\t\t\tcodeStream.decrStackSize(1);", "-\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\tendLabel.place();", "+", "+\t\tLabel trueLabel = new Label(codeStream), endLabel;", "+\t\tConstant cst = left.optimizedBooleanConstant();", "+\t\tboolean leftIsConst = cst != NotAConstant;", "+\t\tboolean leftIsTrue = leftIsConst && cst.booleanValue() == true;", "+", "+\t\tcst = right.optimizedBooleanConstant();", "+\t\tboolean rightIsConst = cst != NotAConstant;", "+\t\tboolean rightIsTrue = rightIsConst && cst.booleanValue() == true;", "+", "+\t\tgenerateOperands : {", "+\t\t\tif (leftIsConst) {", "+\t\t\t\tleft.generateCode(currentScope, codeStream, false);", "+\t\t\t\tif (leftIsTrue) {", "+\t\t\t\t\tbreak generateOperands; // no need to generate right operand", "-\t\t\t\tfalseLabel.place();", "+\t\t\t\tleft.generateOptimizedBoolean(currentScope, codeStream, trueLabel, null, true); ", "+\t\t\t\t// need value, e.g. if (a == 1 || ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a==1 ", "+\t\t\t}", "+\t\t\tif (rightInitStateIndex != -1) {", "+\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);", "+\t\t\t}", "+\t\t\tif (rightIsConst) {", "+\t\t\t\tright.generateCode(currentScope, codeStream, false);", "+\t\t\t} else {", "+\t\t\t\tright.generateOptimizedBoolean(currentScope, codeStream, trueLabel, null, valueRequired);", "-\t\tif (valueRequired) {", "-\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "+\t\tif (mergedInitStateIndex != -1) {", "+\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "-\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\t\t/*", "+\t\t * improving code gen for such a case: boolean b = i < 0 || true since", "+\t\t * the label has never been used, we have the inlined value on the", "+\t\t * stack.", "+\t\t */", "+\t\tif (valueRequired) {", "+\t\t\tif (leftIsConst && leftIsTrue) {", "+\t\t\t\tcodeStream.iconst_1();", "+\t\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "+\t\t\t} else {", "+\t\t\t\tif (rightIsConst && rightIsTrue) {", "+\t\t\t\t\tcodeStream.iconst_1();", "+\t\t\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.iconst_0();", "+\t\t\t\t}", "+\t\t\t\tif (trueLabel.hasForwardReferences()) {", "+\t\t\t\t\tif ((bits & ValueForReturnMASK) != 0) {", "+\t\t\t\t\t\tcodeStream.ireturn();", "+\t\t\t\t\t\ttrueLabel.place();", "+\t\t\t\t\t\tcodeStream.iconst_1();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcodeStream.goto_(endLabel = new Label(codeStream));", "+\t\t\t\t\t\tcodeStream.decrStackSize(1);", "+\t\t\t\t\t\ttrueLabel.place();", "+\t\t\t\t\t\tcodeStream.iconst_1();", "+\t\t\t\t\t\tendLabel.place();", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\ttrueLabel.place();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "+\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "+\t\t} else {", "+\t\t\ttrueLabel.place();", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "903dec3c1883f6d5da5fdb478e795e83", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java", "commitBeforeChange": "6fdaa2b9d78c89a1ed2269f5279c3e02cee4b6cd", "commitAfterChange": "8ec1d344fc5f9b16a04a2a15e36cb4db52cac4eb", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void generateCode( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tboolean valueRequired)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "diff": ["-\tpublic void generateCode(", "-\t\tBlockScope currentScope,", "-\t\tCodeStream codeStream,", "-\t\tboolean valueRequired) {", "-\t\t\t", "+\tpublic void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {", "+", "-\t\tLabel falseLabel, endLabel;", "-\t\tbits |= OnlyValueRequiredMASK;", "-\t\tgenerateOptimizedBoolean(", "-\t\t\tcurrentScope,", "-\t\t\tcodeStream,", "-\t\t\tnull,", "-\t\t\t(falseLabel = new Label(codeStream)),", "-\t\t\tvalueRequired);", "-\t\t/* improving code gen for such a case: boolean b = i < 0 && false", "-\t\t * since the label has never been used, we have the inlined value on the stack. */", "-\t\tif (falseLabel.hasForwardReferences()) {", "-\t\t\tif (valueRequired) {", "-\t\t\t\tcodeStream.iconst_1();", "-\t\t\t\tif ((bits & ValueForReturnMASK) != 0) {", "-\t\t\t\t\tcodeStream.ireturn();", "-\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.goto_(endLabel = new Label(codeStream));", "-\t\t\t\t\tcodeStream.decrStackSize(1);", "-\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\tendLabel.place();", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tfalseLabel.place();", "-\t\t\t}", "-\t\t}", "-\t\tif (valueRequired) {", "-\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "-\t\t}", "-\t\t// reposition the endPC", "-\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);\t\t", "-\t}", "+\t\tLabel falseLabel = new Label(codeStream), endLabel;", "+\t\tConstant cst = left.optimizedBooleanConstant();", "+\t\tboolean leftIsConst = cst != NotAConstant;", "+\t\tboolean leftIsTrue = leftIsConst && cst.booleanValue() == true;", "+", "+\t\tcst = right.optimizedBooleanConstant();", "+\t\tboolean rightIsConst = cst != NotAConstant;", "+\t\tboolean rightIsTrue = rightIsConst && cst.booleanValue() == true;", "+", "+\t\tgenerateOperands : {", "+\t\t\tif (leftIsConst) {", "+\t\t\t\tleft.generateCode(currentScope, codeStream, false);", "+\t\t\t\tif (!leftIsTrue) {", "+\t\t\t\t\tbreak generateOperands; // no need to generate right operand", "+\t\t\t\tleft.generateOptimizedBoolean(currentScope, codeStream, null, falseLabel, true); ", "+\t\t\t\t// need value, e.g. if (a == 1 && ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a!=1 ", "+\t\t\tif (rightInitStateIndex != -1) {", "+\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);", "+\t\t\tif (rightIsConst) {", "+\t\t\t\tright.generateCode(currentScope, codeStream, false);", "+\t\t\t\tright.generateOptimizedBoolean(currentScope, codeStream, null, falseLabel, valueRequired);", "+\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "+\t\t}", "+\t\t/*", "+\t\t * improving code gen for such a case: boolean b = i < 0 && false since", "+\t\t * the label has never been used, we have the inlined value on the", "+\t\t * stack.", "+\t\t */", "+\t\tif (valueRequired) {", "+\t\t\tif (leftIsConst && !leftIsTrue) {", "+\t\t\t\tcodeStream.iconst_0();", "+\t\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "+\t\t\t} else {", "+\t\t\t\tif (rightIsConst && !rightIsTrue) {", "+\t\t\t\t\tcodeStream.iconst_0();", "+\t\t\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.iconst_1();", "+\t\t\t\t}", "+\t\t\t\tif (falseLabel.hasForwardReferences()) {", "+\t\t\t\t\tif ((bits & ValueForReturnMASK) != 0) {", "+\t\t\t\t\t\tcodeStream.ireturn();", "+\t\t\t\t\t\tfalseLabel.place();", "+\t\t\t\t\t\tcodeStream.iconst_0();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcodeStream.goto_(endLabel = new Label(codeStream));", "+\t\t\t\t\t\tcodeStream.decrStackSize(1);", "+\t\t\t\t\t\tfalseLabel.place();", "+\t\t\t\t\t\tcodeStream.iconst_0();", "+\t\t\t\t\t\tendLabel.place();", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tfalseLabel.place();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "+\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "+\t\t} else {", "+\t\t\tfalseLabel.place();", "+\t\t}", "+\t}"]}], "num": 16817}