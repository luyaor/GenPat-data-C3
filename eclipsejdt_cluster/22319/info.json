{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "df08df000852cd4bc7473e0533fe3d52", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "63464a012e74b993aacc783f616d1025", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java", "commitBeforeChange": "ff17444fcc31fe021d6a45c4b051acce1b3894e3", "commitAfterChange": "eb15457015da4dfaee5df4c21a851b245805072a", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " public void enterMethod(MethodInfo methodInfo)", "signatureAfterChange": " public void enterMethod(MethodInfo methodInfo)", "diff": ["-\tinfo.setArgumentNames(methodInfo.parameterNames);", "-\tinfo.setReturnType(methodInfo.returnType == null ? new char[]{'v', 'o','i', 'd'} : methodInfo.returnType);", "-\tinfo.setExceptionTypeNames(methodInfo.exceptionTypes);", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\tchar[][] parameterNames = methodInfo.parameterNames;", "+\tfor (int i = 0, length = parameterNames.length; i < length; i++)", "+\t\tparameterNames[i] = manager.intern(parameterNames[i]);", "+\tinfo.setArgumentNames(parameterNames);", "+\tchar[] returnType = methodInfo.returnType == null ? new char[]{'v', 'o','i', 'd'} : methodInfo.returnType;", "+\tinfo.setReturnType(manager.intern(returnType));", "+\tchar[][] exceptionTypes = methodInfo.exceptionTypes;", "+\tinfo.setExceptionTypeNames(exceptionTypes);", "+\tfor (int i = 0, length = exceptionTypes.length; i < length; i++)", "+\t\texceptionTypes[i] = manager.intern(exceptionTypes[i]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76f2b59a95244919f52963021ae0ab6d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java", "commitBeforeChange": "b0ee678b65f48d1cfab35972dd53d6bd85389446", "commitAfterChange": "5a11933bf440021c4c92ce580c9967dadb549d6e", "methodNumberBeforeChange": 75, "methodNumberAfterChange": 75, "signatureBeforeChange": " public boolean isTypeArgumentContainedBy(TypeBinding otherType)", "signatureAfterChange": " public boolean isTypeArgumentContainedBy(TypeBinding otherType)", "diff": ["+\t\t\t\t\tif (otherBound instanceof IntersectionCastTypeBinding) {", "+\t\t\t\t\t\tTypeBinding [] intersectingTypes = ((IntersectionCastTypeBinding) otherBound).intersectingTypes;", "+\t\t\t\t\t\tfor (int i = 0, length = intersectingTypes.length; i < length; i++)", "+\t\t\t\t\t\t\tif (TypeBinding.equalsEquals(intersectingTypes[i], this))", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (otherBound instanceof IntersectionCastTypeBinding) {", "+\t\t\t\t\t\tTypeBinding [] intersectingTypes = ((IntersectionCastTypeBinding) otherBound).intersectingTypes;", "+\t\t\t\t\t\tfor (int i = 0, length = intersectingTypes.length; i < length; i++)", "+\t\t\t\t\t\t\tif (TypeBinding.equalsEquals(intersectingTypes[i], this))", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ea7e7854313bcb2854e8181e0bd1198e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java", "commitBeforeChange": "1780102e8a06260eba129007a669ddcafe6f2f5f", "commitAfterChange": "a5722689742a043213ccdec9d3d691140ed7f4f9", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tprivate Object reduceSubType(Scope scope, TypeBinding subCandidate, TypeBinding superCandidate)", "signatureAfterChange": "  \tprivate Object reduceSubType(Scope scope, TypeBinding subCandidate, TypeBinding superCandidate)", "diff": ["-\t\t\t\t// TODO If S is an intersection type of which T is an element, the constraint reduces to true. ", "-\t\t\t\tif (subCandidate.kind() == Binding.INTERSECTION_TYPE)", "-\t\t\t\t\tInferenceContext18.missingImplementation(\"NYI\"); //$NON-NLS-1$", "+\t\t\t\tif (subCandidate.kind() == Binding.INTERSECTION_TYPE) {", "+\t\t\t\t\tReferenceBinding[] intersectingTypes = subCandidate.getIntersectingTypes();", "+\t\t\t\t\tif (intersectingTypes != null)", "+\t\t\t\t\t\tfor (int i = 0; i < intersectingTypes.length; i++)", "+\t\t\t\t\t\t\tif (TypeBinding.equalsEquals(intersectingTypes[i], superCandidate))", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t}", "-\t\t\t\t// same as wildcard (but we don't have a lower bound any way)", "-\t\t\t\t// TODO If S is an intersection type of which T is an element, the constraint reduces to true.", "-\t\t\t\tif (subCandidate.kind() == Binding.INTERSECTION_TYPE)", "-\t\t\t\t\tInferenceContext18.missingImplementation(\"NYI\"); //$NON-NLS-1$", "+\t\t\t\t// similar to wildcard, but different queries for lower bound", "+\t\t\t\tif (subCandidate.kind() == Binding.INTERSECTION_TYPE) {", "+\t\t\t\t\tReferenceBinding[] intersectingTypes = subCandidate.getIntersectingTypes();", "+\t\t\t\t\tif (intersectingTypes != null)", "+\t\t\t\t\t\tfor (int i = 0; i < intersectingTypes.length; i++)", "+\t\t\t\t\t\t\tif (TypeBinding.equalsEquals(intersectingTypes[i], superCandidate))", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t}", "+\t\t\t\tif (superCandidate instanceof CaptureBinding) {", "+\t\t\t\t\tCaptureBinding capture = (CaptureBinding) superCandidate;", "+\t\t\t\t\tif (capture.lowerBound != null && capture.firstBound == null)", "+\t\t\t\t\t\treturn new ConstraintTypeFormula(subCandidate, capture.lowerBound, SUBTYPE, this.isSoft);", "+\t\t\t\t}"]}], "num": 22319}