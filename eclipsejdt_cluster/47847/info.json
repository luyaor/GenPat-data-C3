{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b4affbf56c2e4c21063c9fcb528a427f", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "00b253c7ba34413c69d0a3c347d86670", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "931e434bb3e4b9f62577b10f8123cfc028893969", "commitAfterChange": "c0b519c3b149b13ea0f307f0d3414359b2cf0639", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic void manageSyntheticAccessIfNecessary( \t\t\tBlockScope currentScope, \t\t\tFieldBinding fieldBinding, \t\t\tTypeBinding lastReceiverType, \t\t\tint index, \t\t\tFlowInfo flowInfo)", "signatureAfterChange": " public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FieldBinding fieldBinding, TypeBinding lastReceiverType, \tint index, FlowInfo flowInfo)", "diff": ["-\t */", "-\tpublic void manageSyntheticAccessIfNecessary(", "-\t\t\tBlockScope currentScope,", "-\t\t\tFieldBinding fieldBinding,", "-\t\t\tTypeBinding lastReceiverType,", "-\t\t\tint index,", "-\t\t\tFlowInfo flowInfo) {", "-\t\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)\treturn;", "-\t\t// index == 0 denotes the first fieldBinding, index > 0 denotes one of the 'otherBindings', index < 0 denotes a write access (to last binding)", "-\t\tif (fieldBinding.constant() != Constant.NotAConstant)", "+ */", "+public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FieldBinding fieldBinding, TypeBinding lastReceiverType, \tint index, FlowInfo flowInfo) {", "+\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)\treturn;", "+\t// index == 0 denotes the first fieldBinding, index > 0 denotes one of the 'otherBindings', index < 0 denotes a write access (to last binding)", "+\tif (fieldBinding.constant() != Constant.NotAConstant)", "+\t\treturn;", "+", "+\t// if field from parameterized type got found, use the original field at codegen time", "+\tFieldBinding originalField = fieldBinding.original();", "+\tif (originalField != fieldBinding) {", "+\t\tsetCodegenBinding(index < 0 ? (this.otherBindings == null ? 0 : this.otherBindings.length) : index, originalField);", "+\t}", "+\t", "+\tif (fieldBinding.isPrivate()) { // private access", "+\t    FieldBinding someCodegenBinding = getCodegenBinding(index < 0 ? (this.otherBindings == null ? 0 : this.otherBindings.length) : index);", "+\t\tif (someCodegenBinding.declaringClass != currentScope.enclosingSourceType()) {", "+\t\t    setSyntheticAccessor(fieldBinding, index, ", "+\t\t            ((SourceTypeBinding) someCodegenBinding.declaringClass).addSyntheticMethod(someCodegenBinding, index >= 0 /*read-access?*/));", "+\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(someCodegenBinding, this, index >= 0 /*read-access?*/);", "-", "-\t\t// if field from parameterized type got found, use the original field at codegen time", "-\t\tFieldBinding originalField = fieldBinding.original();", "-\t\tif (originalField != fieldBinding) {", "-\t\t\tsetCodegenBinding(index < 0 ? (this.otherBindings == null ? 0 : this.otherBindings.length) : index, originalField);", "+\t} else if (fieldBinding.isProtected()){", "+\t    int depth = (index == 0 || (index < 0 && this.otherDepths == null))", "+\t    \t\t? (this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT ", "+\t    \t\t : this.otherDepths[index < 0 ? this.otherDepths.length-1 : index-1];", "-\t\tif (fieldBinding.isPrivate()) { // private access", "+\t\t// implicit protected access ", "+\t\tif (depth > 0 && (fieldBinding.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage())) {", "-\t\t\tif (someCodegenBinding.declaringClass != currentScope.enclosingSourceType()) {", "-\t\t\t    setSyntheticAccessor(fieldBinding, index, ", "-\t\t\t            ((SourceTypeBinding) someCodegenBinding.declaringClass).addSyntheticMethod(someCodegenBinding, index >= 0 /*read-access?*/));", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(someCodegenBinding, this, index >= 0 /*read-access?*/);", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t} else if (fieldBinding.isProtected()){", "-\t\t    int depth = (index == 0 || (index < 0 && this.otherDepths == null))", "-\t\t    \t\t? (bits & DepthMASK) >> DepthSHIFT ", "-\t\t    \t\t : otherDepths[index < 0 ? otherDepths.length-1 : index-1];", "-\t\t\t", "-\t\t\t// implicit protected access ", "-\t\t\tif (depth > 0 && (fieldBinding.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage())) {", "-\t\t\t    FieldBinding someCodegenBinding = getCodegenBinding(index < 0 ? (this.otherBindings == null ? 0 : this.otherBindings.length) : index);", "-\t\t\t    setSyntheticAccessor(fieldBinding, index, ", "-\t\t\t            ((SourceTypeBinding) currentScope.enclosingSourceType().enclosingTypeAt(depth)).addSyntheticMethod(someCodegenBinding, index >= 0 /*read-access?*/));", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(someCodegenBinding, this, index >= 0 /*read-access?*/);", "-\t\t\t\treturn;", "-\t\t\t}", "+\t\t    setSyntheticAccessor(fieldBinding, index, ", "+\t\t            ((SourceTypeBinding) currentScope.enclosingSourceType().enclosingTypeAt(depth)).addSyntheticMethod(someCodegenBinding, index >= 0 /*read-access?*/));", "+\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(someCodegenBinding, this, index >= 0 /*read-access?*/);", "+\t\t\treturn;", "-\t\t// if the binding declaring class is not visible, need special action", "-\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "-\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "-\t\t// and not from Object or implicit static field access.\t", "-\t\tif (fieldBinding.declaringClass != lastReceiverType", "-\t\t\t\t&& !lastReceiverType.isArrayType()", "-\t\t\t\t&& fieldBinding.declaringClass != null // array.length", "-\t\t\t\t&& fieldBinding.constant() == Constant.NotAConstant) {", "-\t\t\tCompilerOptions options = currentScope.compilerOptions();", "-\t\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "-\t\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !(index <= 1 &&  indexOfFirstFieldBinding == 1 && fieldBinding.isStatic()))", "-\t\t\t\t\t&& fieldBinding.declaringClass.id != T_JavaLangObject) // no change for Object fields", "+\t}", "+\t// if the binding declaring class is not visible, need special action", "+\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "+\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "+\t// and not from Object or implicit static field access.\t", "+\tif (fieldBinding.declaringClass != lastReceiverType", "+\t\t\t&& !lastReceiverType.isArrayType()", "+\t\t\t&& fieldBinding.declaringClass != null // array.length", "+\t\t\t&& fieldBinding.constant() == Constant.NotAConstant) {", "+\t\tCompilerOptions options = currentScope.compilerOptions();", "+\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "+\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !(index <= 1 &&  this.indexOfFirstFieldBinding == 1 && fieldBinding.isStatic()))", "+\t\t\t\t&& fieldBinding.declaringClass.id != TypeIds.T_JavaLangObject) // no change for Object fields", "-\t\t\t}", "-\t\t}\t\t\t", "-\t}", "+\t\t}", "+\t}\t\t\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0fc429eaec87ca6ac0aadb3b40b545c7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java", "commitBeforeChange": "6c5ff7a40e06214003233124a78f91b46a0db4e6", "commitAfterChange": "abfab6e38455079c19f7f3fadcf15c77c144ade8", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 4, "signatureBeforeChange": "   \tpublic void traverse(ASTVisitor visitor, BlockScope scope)", "signatureAfterChange": "   \tpublic void traverse(ASTVisitor visitor, BlockScope scope)", "diff": ["-", "-\t\t\tint dimensionsLength = dimensions.length;", "-\t\t\ttype.traverse(visitor, scope);", "+\t\t\tint dimensionsLength = this.dimensions.length;", "+\t\t\tthis.type.traverse(visitor, scope);", "-\t\t\t\tif (dimensions[i] != null)", "-\t\t\t\t\tdimensions[i].traverse(visitor, scope);", "+\t\t\t\tif (this.dimensions[i] != null)", "+\t\t\t\t\tthis.dimensions[i].traverse(visitor, scope);", "-\t\t\tif (initializer != null)", "-\t\t\t\tinitializer.traverse(visitor, scope);", "+\t\t\tif (this.initializer != null)", "+\t\t\t\tthis.initializer.traverse(visitor, scope);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1b011a54642fcc256dff2a503ec3825c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 119, "methodNumberAfterChange": 119, "signatureBeforeChange": " protected void consumeLocalVariableDeclarationStatement()", "signatureAfterChange": " protected void consumeLocalVariableDeclarationStatement()", "diff": ["-\trealBlockStack[realBlockPtr]++;", "+\tthis.realBlockStack[this.realBlockPtr]++;", "-\tint variableDeclaratorsCounter = astLengthStack[astLengthPtr];", "+\tint variableDeclaratorsCounter = this.astLengthStack[this.astLengthPtr];", "-\t\tLocalDeclaration localDeclaration = (LocalDeclaration) astStack[astPtr - i];", "-\t\tlocalDeclaration.declarationSourceEnd = endStatementPosition; ", "-\t\tlocalDeclaration.declarationEnd = endStatementPosition;\t// semi-colon included", "+\t\tLocalDeclaration localDeclaration = (LocalDeclaration) this.astStack[this.astPtr - i];", "+\t\tlocalDeclaration.declarationSourceEnd = this.endStatementPosition; ", "+\t\tlocalDeclaration.declarationEnd = this.endStatementPosition;\t// semi-colon included"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1c5baa749ccaa5dae906518f312cf0b2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java", "commitBeforeChange": "7daf62bc284b30571754ce8d7fd5c3a7c9740dcb", "commitAfterChange": "b8c9923212bd9598e5d2ca68e0dc316b81a3eccb", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tprotected synchronized void moveToNextJob()", "signatureAfterChange": " \tprotected synchronized void moveToNextJob()", "diff": ["-", "-\t\tif (jobStart <= jobEnd) {", "-\t\t\tawaitingJobs[jobStart++] = null;", "-\t\t\tif (jobStart > jobEnd) {", "-\t\t\t\tjobStart = 0;", "-\t\t\t\tjobEnd = -1;", "+\t\tif (this.jobStart <= this.jobEnd) {", "+\t\t\tthis.awaitingJobs[this.jobStart++] = null;", "+\t\t\tif (this.jobStart > this.jobEnd) {", "+\t\t\t\tthis.jobStart = 0;", "+\t\t\t\tthis.jobEnd = -1;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "65a816b6f77b55c39047a39a5896c273", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java", "commitBeforeChange": "1d27ab4a3d73ff8313e5972d7d4f96a23b370614", "commitAfterChange": "b25ed407ef1d09375524d9c9e824c1c1084b119b", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tpublic Map properties()", "signatureAfterChange": " \tpublic Map properties()", "diff": ["-\t\tif (property1 == null) {", "+\t\tif (this.property1 == null) {", "-\t\tif (property1 instanceof String) {", "+\t\tif (this.property1 instanceof String) {", "-\t\t\treturn Collections.singletonMap(property1, property2);", "+\t\t\treturn Collections.singletonMap(this.property1, this.property2);", "-\t\tif (property2 == null) {", "-\t\t\tproperty2 = Collections.unmodifiableMap((Map) property1);", "+\t\tif (this.property2 == null) {", "+\t\t\tthis.property2 = Collections.unmodifiableMap((Map) this.property1);", "-\t\treturn (Map) property2;", "+\t\treturn (Map) this.property2;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "770992efd360b51ea108fecfd179ca7d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java", "commitBeforeChange": "372d175da142eb06ee96f2b4e45c55b51d9b736f", "commitAfterChange": "3fc938efd67d7f1d6ba4971b3e0f4aa8cd107965", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "\r public ExceptionHandlingFlowContext(\r \tFlowContext parent, \r \tAstNode associatedNode, \r \tReferenceBinding[] handledExceptions, \r \tBlockScope scope, \r \tUnconditionalFlowInfo flowInfo)", "signatureAfterChange": "\r \r \tpublic ExceptionHandlingFlowContext(\r \t\tFlowContext parent,\r \t\tAstNode associatedNode,\r \t\tReferenceBinding[] handledExceptions,\r \t\tBlockScope scope,\r \t\tUnconditionalFlowInfo flowInfo)", "diff": ["-public ExceptionHandlingFlowContext(\r", "-\tFlowContext parent, \r", "-\tAstNode associatedNode, \r", "-\tReferenceBinding[] handledExceptions, \r", "-\tBlockScope scope, \r", "-\tUnconditionalFlowInfo flowInfo) {\r", "-\tsuper(parent, associatedNode);\r", "-\tisMethodContext = scope == scope.methodScope();\r", "-/*\t\r", "-\t// for a method, append the unchecked exceptions to the handled exceptions collection\r", "+\tpublic ExceptionHandlingFlowContext(\r", "+\t\tFlowContext parent,\r", "+\t\tAstNode associatedNode,\r", "+\t\tReferenceBinding[] handledExceptions,\r", "+\t\tBlockScope scope,\r", "+\t\tUnconditionalFlowInfo flowInfo) {\r", "-\tif (scope.methodScope() == scope) {\r", "-\t\tint length;\r", "-\t\tSystem.arraycopy(\r", "-\t\t\thandledExceptions, \r", "-\t\t\t0, \r", "-\t\t\t(handledExceptions = \r", "-\t\t\t\tnew ReferenceBinding[(length = handledExceptions.length) + 2]), \r", "-\t\t\t0, \r", "-\t\t\tlength); \r", "-\t\thandledExceptions[length] = scope.getJavaLangRuntimeException();\r", "-\t\thandledExceptions[length + 1] = scope.getJavaLangError();\r", "-\t}\r", "-*/\t\r", "-\tthis.handledExceptions = handledExceptions;\r", "-\tint count = handledExceptions.length, cacheSize = (count / BitCacheSize) + 1;\r", "-\tisReached = new int[cacheSize]; // none is reached by default\r", "-\tisNeeded = new int[cacheSize]; // none is needed by default\r", "-\tinitsOnExceptions = new UnconditionalFlowInfo[count];\r", "-\tfor (int i = 0; i < count; i++) {\r", "-\t\tindexes.put(handledExceptions[i], i); // key type  -> value index\r", "-\t\tboolean isUnchecked = \r", "-\t\t\t(scope.compareUncheckedException(handledExceptions[i]) != NotRelated); \r", "-\t\tint cacheIndex = i / BitCacheSize, bitMask = 1 << (i % BitCacheSize);\r", "-\t\tif (isUnchecked) {\r", "-\t\t\tisReached[cacheIndex] |= bitMask;\r", "-\t\t\tinitsOnExceptions[i] = flowInfo.copy().unconditionalInits();\r", "-\t\t} else {\r", "-\t\t\tinitsOnExceptions[i] = FlowInfo.DeadEnd;\r", "-\t\t}\r", "-\t}\r", "-\tSystem.arraycopy(isReached, 0, isNeeded, 0, cacheSize);\r", "-}\r", "+\t\tsuper(parent, associatedNode);\r", "+\t\tisMethodContext = scope == scope.methodScope();\r", "+\t\tthis.handledExceptions = handledExceptions;\r", "+\t\tint count = handledExceptions.length, cacheSize = (count / BitCacheSize) + 1;\r", "+\t\tthis.isReached = new int[cacheSize]; // none is reached by default\r", "+\t\tthis.isNeeded = new int[cacheSize]; // none is needed by default\r", "+\t\tthis.initsOnExceptions = new UnconditionalFlowInfo[count];\r", "+\t\tfor (int i = 0; i < count; i++) {\r", "+\t\t\tthis.indexes.put(handledExceptions[i], i); // key type  -> value index\r", "+\t\t\tboolean isUnchecked =\r", "+\t\t\t\t(scope.compareUncheckedException(handledExceptions[i]) != NotRelated);\r", "+\t\t\tint cacheIndex = i / BitCacheSize, bitMask = 1 << (i % BitCacheSize);\r", "+\t\t\tif (isUnchecked) {\r", "+\t\t\t\tisReached[cacheIndex] |= bitMask;\r", "+\t\t\t\tthis.initsOnExceptions[i] = flowInfo.copy().unconditionalInits();\r", "+\t\t\t\tthis.initsOnExceptions[i] = FlowInfo.DeadEnd;\r", "+\t\tSystem.arraycopy(this.isReached, 0, this.isNeeded, 0, cacheSize);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8cd97947b87ab08ba3ae907a5351f7ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " protected void consumeArrayCreationExpressionWithoutInitializer()", "signatureAfterChange": " protected void consumeArrayCreationExpressionWithoutInitializer()", "diff": ["-\tlength = (expressionLengthStack[expressionLengthPtr--]);", "-\texpressionPtr -= length ;", "+\tlength = (this.expressionLengthStack[this.expressionLengthPtr--]);", "+\tthis.expressionPtr -= length ;", "-\t\texpressionStack,", "-\t\texpressionPtr+1,", "+\t\tthis.expressionStack,", "+\t\tthis.expressionPtr+1,", "-\taae.sourceStart = intStack[intPtr--];", "+\taae.sourceStart = this.intStack[this.intPtr--];", "-\t\taae.sourceEnd = endPosition;", "+\t\taae.sourceEnd = this.endPosition;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd0f690787a87d9a8f70152eee322c99", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tpublic TypeBinding reportError(BlockScope scope)", "signatureAfterChange": " public TypeBinding reportError(BlockScope scope)", "diff": ["+}", "+public TypeBinding reportError(BlockScope scope) {", "+\t//=====error cases=======", "+\tthis.constant = Constant.NotAConstant;", "+\tif (this.binding instanceof ProblemFieldBinding) {", "+\t\tscope.problemReporter().invalidField(this, (FieldBinding) this.binding);", "+\t} else if (this.binding instanceof ProblemReferenceBinding || this.binding instanceof MissingTypeBinding) {", "+\t\tscope.problemReporter().invalidType(this, (TypeBinding) this.binding);", "+\t} else {", "+\t\tscope.problemReporter().unresolvableReference(this, this.binding);", "-\tpublic TypeBinding reportError(BlockScope scope) {", "-\t\t", "-\t\t//=====error cases=======", "-\t\tconstant = Constant.NotAConstant;", "-\t\tif (binding instanceof ProblemFieldBinding) {", "-\t\t\tscope.problemReporter().invalidField(this, (FieldBinding) binding);", "-\t\t} else if (binding instanceof ProblemReferenceBinding) {", "-\t\t\tscope.problemReporter().invalidType(this, (TypeBinding) binding);", "-\t\t} else {", "-\t\t\tscope.problemReporter().unresolvableReference(this, binding);", "-\t\t}", "-\t\treturn null;", "-\t}", "+\treturn null;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e095c5e89877f7957fa0f88de7141d53", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/HashtableOfObjectToInt.java", "commitBeforeChange": "f66ad7c89d5efefebf4bda51f9089ef887e9d108", "commitAfterChange": "97459ae998e10691456e7e2a3002f99ff1d092bb", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tpublic int removeKey(Object key)", "signatureAfterChange": "  \tpublic int removeKey(Object key)", "diff": ["-\t\tint index = key.hashCode() % valueTable.length;", "+\t\tint index = key.hashCode() % this.valueTable.length;", "-\t\twhile ((currentKey = keyTable[index]) != null) {", "+\t\twhile ((currentKey = this.keyTable[index]) != null) {", "-\t\t\t\tint value = valueTable[index];", "+\t\t\t\tint value = this.valueTable[index];", "-\t\t\t\tkeyTable[index] = null;", "-\t\t\t\tvalueTable[index] = -1;", "+\t\t\t\tthis.keyTable[index] = null;", "-\t\t\tindex = (index + 1) % keyTable.length;", "+\t\t\tindex = (index + 1) % this.keyTable.length;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e3073815aec7e2fe0a65b5da654c7012", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic void complainIfUnusedExceptionHandlers(AbstractMethodDeclaration method)", "signatureAfterChange": "  public void complainIfUnusedExceptionHandlers(AbstractMethodDeclaration method)", "diff": ["-\tpublic void complainIfUnusedExceptionHandlers(AbstractMethodDeclaration method) {", "-\t\tMethodScope scope = method.scope;", "-\t\t// can optionally skip overriding methods", "-\t\tif ((method.binding.modifiers & (ExtraCompilerModifiers.AccOverriding | ExtraCompilerModifiers.AccImplementing)) != 0", "-\t\t        && !scope.compilerOptions().reportUnusedDeclaredThrownExceptionWhenOverriding) {", "-\t\t    return;", "-\t\t}", "-\t\t    ", "-\t\t// report errors for unreachable exception handlers", "-\t\tfor (int i = 0, count = handledExceptions.length; i < count; i++) {", "-\t\t\tint index = indexes.get(handledExceptions[i]);", "-\t\t\tint cacheIndex = index / BitCacheSize;", "-\t\t\tint bitMask = 1 << (index % BitCacheSize);", "-\t\t\tif ((isReached[cacheIndex] & bitMask) == 0) {", "-\t\t\t\tscope.problemReporter().unusedDeclaredThrownException(", "-\t\t\t\t\thandledExceptions[index],", "-\t\t\t\t\tmethod,", "-\t\t\t\t\tmethod.thrownExceptions[index]);", "-\t\t\t}", "+public void complainIfUnusedExceptionHandlers(AbstractMethodDeclaration method) {", "+\tMethodScope scope = method.scope;", "+\t// can optionally skip overriding methods", "+\tif ((method.binding.modifiers & (ExtraCompilerModifiers.AccOverriding | ExtraCompilerModifiers.AccImplementing)) != 0", "+\t        && !scope.compilerOptions().reportUnusedDeclaredThrownExceptionWhenOverriding) {", "+\t    return;", "+\t}", "+\t    ", "+\t// report errors for unreachable exception handlers", "+\tfor (int i = 0, count = this.handledExceptions.length; i < count; i++) {", "+\t\tint index = this.indexes.get(this.handledExceptions[i]);", "+\t\tint cacheIndex = index / ExceptionHandlingFlowContext.BitCacheSize;", "+\t\tint bitMask = 1 << (index % ExceptionHandlingFlowContext.BitCacheSize);", "+\t\tif ((this.isReached[cacheIndex] & bitMask) == 0) {", "+\t\t\tscope.problemReporter().unusedDeclaredThrownException(", "+\t\t\t\tthis.handledExceptions[index],", "+\t\t\t\tmethod,", "+\t\t\t\tmethod.thrownExceptions[index]);", "+}"]}], "num": 47847}