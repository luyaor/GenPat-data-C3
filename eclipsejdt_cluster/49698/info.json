{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0a705f5d5c1a4a6ae2952023286aa45b", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "747e229e2d91c8f8b6a1cd21c94cafd5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "b9bb6123c3e4c0567c677af33c7c0e8037ba4975", "commitAfterChange": "4dd974a226271180ff02d909a12722017f80ff3a", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " abstract void checkMethods();", "diff": ["-void checkMethods() {", "-\tboolean mustImplementAbstractMethods = mustImplementAbstractMethods();", "-\tboolean skipInheritedMethods = mustImplementAbstractMethods && canSkipInheritedMethods(); // have a single concrete superclass so only check overridden methods", "-\tboolean isOrEnclosedByPrivateType = this.type.isOrEnclosedByPrivateType();", "-\tchar[][] methodSelectors = this.inheritedMethods.keyTable;", "-\tnextSelector : for (int s = methodSelectors.length; --s >= 0;) {", "-\t\tif (methodSelectors[s] == null) continue nextSelector;", "-", "-\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(methodSelectors[s]);", "-\t\tMethodBinding[] inherited = (MethodBinding[]) this.inheritedMethods.valueTable[s];", "-\t\t", "-\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=296660, if current type is exposed,", "-\t\t// inherited methods of super classes are too. current != null case handled below.", "-\t\tif (current == null && !isOrEnclosedByPrivateType) {", "-\t\t\tint length = inherited.length;", "-\t\t\tfor (int i = 0; i < length; i++){", "-\t\t\t\tinherited[i].original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "-\t\t\t}", "-\t\t}", "-", "-\t\tif (current == null && skipInheritedMethods)", "-\t\t\tcontinue nextSelector;", "-", "-\t\tif (inherited.length == 1 && current == null) { // handle the common case", "-\t\t\tif (mustImplementAbstractMethods && inherited[0].isAbstract())", "-\t\t\t\tcheckAbstractMethod(inherited[0]);", "-\t\t\tcontinue nextSelector;", "-\t\t}", "-", "-\t\tint index = -1;", "-\t\tMethodBinding[] matchingInherited = new MethodBinding[inherited.length];", "-\t\tif (current != null) {", "-\t\t\tfor (int i = 0, length1 = current.length; i < length1; i++) {", "-\t\t\t\tMethodBinding currentMethod = current[i];", "-\t\t\t\tfor (int j = 0, length2 = inherited.length; j < length2; j++) {", "-\t\t\t\t\tMethodBinding inheritedMethod = computeSubstituteMethod(inherited[j], currentMethod);", "-\t\t\t\t\tif (inheritedMethod != null) {", "-\t\t\t\t\t\tif (isParameterSubsignature(currentMethod, inheritedMethod)) {", "-\t\t\t\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (index >= 0) {", "-\t\t\t\t\tcheckAgainstInheritedMethods(currentMethod, matchingInherited, index + 1, inherited); // pass in the length of matching", "-\t\t\t\t\twhile (index >= 0) matchingInherited[index--] = null; // clear the contents of the matching methods", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-", "-\t\tfor (int i = 0, length = inherited.length; i < length; i++) {", "-\t\t\tMethodBinding inheritedMethod = inherited[i];", "-\t\t\tif (inheritedMethod == null) continue;", "-\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=296660, if current type is exposed,", "-\t\t\t// inherited methods of super classes are too. current == null case handled already.", "-\t\t\tif (!isOrEnclosedByPrivateType && current != null) {", "-\t\t\t\tinheritedMethod.original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "-\t\t\t}", "-\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\tfor (int j = i + 1; j < length; j++) {", "-\t\t\t\tMethodBinding otherInheritedMethod = inherited[j];", "-\t\t\t\tif (canSkipInheritedMethods(inheritedMethod, otherInheritedMethod))", "-\t\t\t\t\tcontinue;", "-\t\t\t\totherInheritedMethod = computeSubstituteMethod(otherInheritedMethod, inheritedMethod);", "-\t\t\t\tif (otherInheritedMethod != null) {", "-\t\t\t\t\tif (isParameterSubsignature(inheritedMethod, otherInheritedMethod)) {", "-\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "-\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (index == -1) continue;", "-\t\t\tif (index > 0)", "-\t\t\t\tcheckInheritedMethods(matchingInherited, index + 1); // pass in the length of matching", "-\t\t\telse if (mustImplementAbstractMethods && matchingInherited[0].isAbstract())", "-\t\t\t\tcheckAbstractMethod(matchingInherited[0]);", "-\t\t\twhile (index >= 0) matchingInherited[index--] = null; // clear the contents of the matching methods", "-\t\t}", "-\t}", "-}", "+abstract void checkMethods();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7668501df069f12083b0a397e6dfcc53", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "eaf0108cc4594b9874621f7838e6b5fcab99f228", "commitAfterChange": "505b0db16406f11df3227a34e8e784faefbd6e90", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": " private void checkMethods()", "signatureAfterChange": " private void checkMethods()", "diff": ["-\tfor (int s = methodSelectors.length; --s >= 0;) {", "-\t\tif (methodSelectors[s] != null) {", "-\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(methodSelectors[s]);", "-\t\t\tMethodBinding[] inherited = (MethodBinding[]) this.inheritedMethods.valueTable[s];", "+\tnextSelector : for (int s = methodSelectors.length; --s >= 0;) {", "+\t\tif (methodSelectors[s] == null) continue nextSelector;", "-\t\t\tint index = -1;", "-\t\t\tMethodBinding[] matchingInherited = new MethodBinding[inherited.length];", "-\t\t\tif (current != null) {", "-\t\t\t\tfor (int i = 0, length1 = current.length; i < length1; i++) {", "-\t\t\t\t\twhile (index >= 0) matchingInherited[index--] = null; // clear the previous contents of the matching methods", "-\t\t\t\t\tMethodBinding currentMethod = current[i];", "-\t\t\t\t\tfor (int j = 0, length2 = inherited.length; j < length2; j++) {", "-\t\t\t\t\t\tif (inherited[j] != null && areParametersEqual(currentMethod, inherited[j])) {", "-\t\t\t\t\t\t\tmatchingInherited[++index] = inherited[j];", "-\t\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tif (index >= 0)", "-\t\t\t\t\t\tthis.checkAgainstInheritedMethods(currentMethod, matchingInherited, index + 1); // pass in the length of matching", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tfor (int i = 0, length = inherited.length; i < length; i++) {", "+\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(methodSelectors[s]);", "+\t\tMethodBinding[] inherited = (MethodBinding[]) this.inheritedMethods.valueTable[s];", "+\t\tif (inherited.length == 1 && current == null) { // handle the common case", "+\t\t\tif (mustImplementAbstractMethods && inherited[0].isAbstract())", "+\t\t\t\tcheckAbstractMethod(inherited[0]);", "+\t\t\tcontinue nextSelector;", "+\t\t}", "+", "+\t\tint index = -1;", "+\t\tMethodBinding[] matchingInherited = new MethodBinding[inherited.length];", "+\t\tif (current != null) {", "+\t\t\tfor (int i = 0, length1 = current.length; i < length1; i++) {", "-\t\t\t\tif (inherited[i] != null) {", "-\t\t\t\t\tmatchingInherited[++index] = inherited[i];", "-\t\t\t\t\tfor (int j = i + 1; j < length; j++) {", "-\t\t\t\t\t\tif (inherited[j] != null && areParametersEqual(inherited[i], inherited[j])) {", "-\t\t\t\t\t\t\tmatchingInherited[++index] = inherited[j];", "-\t\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "-\t\t\t\t\t\t}", "+\t\t\t\tMethodBinding currentMethod = current[i];", "+\t\t\t\tfor (int j = 0, length2 = inherited.length; j < length2; j++) {", "+\t\t\t\t\tif (inherited[j] != null && areParametersEqual(currentMethod, inherited[j])) {", "+\t\t\t\t\t\tmatchingInherited[++index] = inherited[j];", "+\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "-\t\t\t\tif (index > 0) {", "-\t\t\t\t\tthis.checkInheritedMethods(matchingInherited, index + 1); // pass in the length of matching", "-\t\t\t\t} else if (mustImplementAbstractMethods && index == 0 && matchingInherited[0].isAbstract()) {", "-\t\t\t\t\tif (mustImplementAbstractMethod(matchingInherited[0])) {", "-\t\t\t\t\t\tTypeDeclaration typeDeclaration = this.type.scope.referenceContext;", "-\t\t\t\t\t\tif (typeDeclaration != null) {", "-\t\t\t\t\t\t\tMethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(matchingInherited[0]);", "-\t\t\t\t\t\t\tmissingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, matchingInherited[0]);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tthis.problemReporter().abstractMethodMustBeImplemented(this.type, matchingInherited[0]);", "-\t\t\t\t\t\t}", "+\t\t\t\tif (index >= 0)", "+\t\t\t\t\tthis.checkAgainstInheritedMethods(currentMethod, matchingInherited, index + 1); // pass in the length of matching", "+\t\t\t}", "+\t\t}", "+", "+\t\tfor (int i = 0, length = inherited.length; i < length; i++) {", "+\t\t\twhile (index >= 0) matchingInherited[index--] = null; // clear the previous contents of the matching methods", "+\t\t\tif (inherited[i] != null) {", "+\t\t\t\tmatchingInherited[++index] = inherited[i];", "+\t\t\t\tfor (int j = i + 1; j < length; j++) {", "+\t\t\t\t\tif (inherited[j] != null && areParametersEqual(inherited[i], inherited[j])) {", "+\t\t\t\t\t\tmatchingInherited[++index] = inherited[j];", "+\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "+\t\t\tif (index > 0)", "+\t\t\t\tthis.checkInheritedMethods(matchingInherited, index + 1); // pass in the length of matching", "+\t\t\telse if (mustImplementAbstractMethods && index == 0 && matchingInherited[0].isAbstract())", "+\t\t\t\tcheckAbstractMethod(matchingInherited[0]);"]}], "num": 49698}