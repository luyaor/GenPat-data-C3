{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5440f7bbe10db4424a376f117e347377", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3730f68cfc4cd0db80fb8b7199f410be", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "25da2d2772e9dbe01e64990a2188903ca45b793c", "commitAfterChange": "48628a48bc30e9f74feb6b693bbfe398c063e4b8", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "  public boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)", "signatureAfterChange": "  public boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)", "diff": ["-\t\t\t\t\t\t\tTypeBinding genericCastType = castType.erasure(); // jump to generic type", "-\t\t\t\t\t\t\tTypeBinding genericMatch = genericCastType.findSuperTypeOriginatingFrom(expressionType);", "-\t\t\t\t\t\t\tif (genericMatch == match) {", "+\t\t\t\t\t\t\t// if I2<T,U> extends I1<T>, then cast from I1<T> to I2<T,U> is unchecked", "+\t\t\t\t\t\t\tParameterizedTypeBinding paramCastType = (ParameterizedTypeBinding) castType;", "+\t\t\t\t\t\t\tParameterizedTypeBinding paramMatch = (ParameterizedTypeBinding) match;", "+\t\t\t\t\t\t\t// easy case if less parameters on match", "+\t\t\t\t\t\t\tTypeBinding[] castArguments = paramCastType.arguments;", "+\t\t\t\t\t\t\tint length = castArguments.length;", "+\t\t\t\t\t\t\tif (length > paramMatch.arguments.length) {", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t// if I2<T,U> extends I1<T>, then cast from I1<T> to I2<T,U> is unchecked", "-\t\t\t\t\t\t\t\tParameterizedTypeBinding paramCastType = (ParameterizedTypeBinding) castType;", "-\t\t\t\t\t\t\t\tParameterizedTypeBinding paramMatch = (ParameterizedTypeBinding) match;", "-\t\t\t\t\t\t\t\t// easy case if less parameters on match", "-\t\t\t\t\t\t\t\tTypeBinding[] castArguments = paramCastType.arguments;", "-\t\t\t\t\t\t\t\tint length = castArguments.length;", "-\t\t\t\t\t\t\t\tif (length > paramMatch.arguments.length) {", "-\t\t\t\t\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "-\t\t\t\t\t\t\t\t} else if ((paramCastType.tagBits & (TagBits.HasDirectWildcard|TagBits.HasTypeVariable)) != 0) {", "-\t\t\t\t\t\t\t\t\t// verify alternate cast type, substituting different type arguments", "+\t\t\t\t\t\t\t} else if ((paramCastType.tagBits & (TagBits.HasDirectWildcard|TagBits.HasTypeVariable)) != 0) {", "+\t\t\t\t\t\t\t\t// verify alternate cast type, substituting different type arguments", "+\t\t\t\t\t\t\t\tnextAlternateArgument: for (int i = 0; i < length; i++) {", "+\t\t\t\t\t\t\t\t\tswitch (castArguments[i].kind()) {", "+\t\t\t\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\t\t\t\t\t\tcase Binding.TYPE_PARAMETER :", "+\t\t\t\t\t\t\t\t\t\t\tbreak; // check substituting with other", "+\t\t\t\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\t\t\t\tcontinue nextAlternateArgument; // no alternative possible", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tTypeBinding[] alternateArguments;", "+\t\t\t\t\t\t\t\t\t// need to clone for each iteration to avoid env paramtype cache interference", "+\t\t\t\t\t\t\t\t\tSystem.arraycopy(paramCastType.arguments, 0, alternateArguments = new TypeBinding[length], 0, length);", "+\t\t\t\t\t\t\t\t\talternateArguments[i] = scope.getJavaLangObject();", "-\t\t\t\t\t\t\t\t\tnextAlternateArgument: for (int i = 0; i < length; i++) {", "-\t\t\t\t\t\t\t\t\t\tswitch (castArguments[i].kind()) {", "-\t\t\t\t\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "-\t\t\t\t\t\t\t\t\t\t\tcase Binding.TYPE_PARAMETER :", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak; // check substituting with other", "-\t\t\t\t\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\t\t\t\t\tcontinue nextAlternateArgument; // no alternative possible", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tTypeBinding[] alternateArguments;", "-\t\t\t\t\t\t\t\t\t\t// need to clone for each iteration to avoid env paramtype cache interference", "-\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(paramCastType.arguments, 0, alternateArguments = new TypeBinding[length], 0, length);", "-\t\t\t\t\t\t\t\t\t\talternateArguments[i] = scope.getJavaLangObject();", "-\t\t\t\t\t\t\t\t\t\tParameterizedTypeBinding alternateCastType = environment.createParameterizedType((ReferenceBinding)genericCastType, alternateArguments, castType.enclosingType());", "-\t\t\t\t\t\t\t\t\t\tif (alternateCastType.findSuperTypeOriginatingFrom(expressionType) == match) {", "-\t\t\t\t\t\t\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "-\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tParameterizedTypeBinding alternateCastType = environment.createParameterizedType((ReferenceBinding)castType.erasure(), alternateArguments, castType.enclosingType());", "+\t\t\t\t\t\t\t\t\tif (alternateCastType.findSuperTypeOriginatingFrom(expressionType) == match) {", "+\t\t\t\t\t\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "+\t\t\t\t\t\t\t\t\t\tbreak;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "84ab1bbff6bfb5f0d58cad7e6300ebce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "2e4e63b9ed8aad7925bed1f9109d7e2d1a341f45", "commitAfterChange": "6f2d59d80da8490e52a278944b98c97220ac4149", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "  static MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod, LookupEnvironment environment)", "signatureAfterChange": "  static MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod, LookupEnvironment environment)", "diff": ["-\t\tTypeBinding argument = arguments[i];", "-\t\tif (argument instanceof TypeVariableBinding) {", "-\t\t\tTypeVariableBinding typeVariable = (TypeVariableBinding) argument;", "-\t\t\tif (typeVariable.firstBound == inheritedTypeVariable.firstBound) {", "-\t\t\t\tif (typeVariable.firstBound == null)", "-\t\t\t\t\tcontinue; // both are null", "-\t\t\t} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {", "-\t\t\t\tif (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())", "-\t\t\t\t\treturn inheritedMethod; // not a match", "-\t\t\t}", "-\t\t\tif (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)", "+\t\tTypeVariableBinding typeVariable = (TypeVariableBinding) arguments[i]; // cast is safe by construction: arguments is copied from TypeVariableBinding[]", "+\t\tif (typeVariable.firstBound == inheritedTypeVariable.firstBound) {", "+\t\t\tif (typeVariable.firstBound == null)", "+\t\t\t\tcontinue; // both are null", "+\t\t} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {", "+\t\t\tif (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())", "-\t\t\tint interfaceLength = inheritedTypeVariable.superInterfaces.length;", "-\t\t\tReferenceBinding[] interfaces = typeVariable.superInterfaces;", "-\t\t\tif (interfaceLength != interfaces.length)", "-\t\t\t\treturn inheritedMethod; // not a match", "-\t\t\tnext : for (int j = 0; j < interfaceLength; j++) {", "-\t\t\t\tTypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);", "-\t\t\t\tfor (int k = 0; k < interfaceLength; k++)", "-\t\t\t\t\tif (superType == interfaces[k])", "-\t\t\t\t\t\tcontinue next;", "-\t\t\t\treturn inheritedMethod; // not a match", "-\t\t\t}", "-\t\t} else if (inheritedTypeVariable.boundCheck(substitute, argument, null) != TypeConstants.OK) {", "-\t    \treturn inheritedMethod;", "+\t\t}", "+\t\tif (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)", "+\t\t\treturn inheritedMethod; // not a match", "+\t\tint interfaceLength = inheritedTypeVariable.superInterfaces.length;", "+\t\tReferenceBinding[] interfaces = typeVariable.superInterfaces;", "+\t\tif (interfaceLength != interfaces.length)", "+\t\t\treturn inheritedMethod; // not a match", "+\t\tnext : for (int j = 0; j < interfaceLength; j++) {", "+\t\t\tTypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);", "+\t\t\tfor (int k = 0; k < interfaceLength; k++)", "+\t\t\t\tif (superType == interfaces[k])", "+\t\t\t\t\tcontinue next;", "+\t\t\treturn inheritedMethod; // not a match"]}], "num": 48831}