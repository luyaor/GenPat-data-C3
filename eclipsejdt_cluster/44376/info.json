{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "24f60ae3b424393738a5547592b3b336", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "01a56b2c5275d1a1f2df87093581ee00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "5f100ab0d61beb34b23838f330bd40314a77e0dc", "commitAfterChange": "d583ac0d52375fce8272e2954c7bfc180f0599f4", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] rawClasspath, IPath projectOutputLocation)", "diff": ["-\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {", "+\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] rawClasspath, IPath projectOutputLocation) {", "-\t\tif (outputLocation == null) {", "+\t\tif (projectOutputLocation == null) {", "-\t\tif (outputLocation.isAbsolute()) {", "-\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "+\t\tif (projectOutputLocation.isAbsolute()) {", "+\t\t\tif (!projectPath.isPrefixOf(projectOutputLocation)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, projectOutputLocation.toString());", "-\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "+\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, projectOutputLocation);", "-\t\tboolean allowNestingInOutput = false;", "+", "-\t\tint length = classpath == null ? 0 : classpath.length; ", "-\t", "-\t\tArrayList resolvedEntries = new ArrayList();", "+\t\tif (rawClasspath == null) ", "+\t\t\treturn JavaModelStatus.VERIFIED_OK;", "+\t\t", "+\t\t// retrieve resolved classpath", "+\t\tIClasspathEntry[] classpath; ", "+\t\ttry {", "+\t\t\tclasspath = ((JavaProject)javaProject).getResolvedClasspath(rawClasspath, true/*ignore pb*/, false/*no marker*/);", "+\t\t} catch(JavaModelException e){", "+\t\t\treturn e.getJavaModelStatus();", "+\t\t}", "+\t\tint length = classpath.length; ", "+", "+\t\tint outputCount = 1;", "+\t\tIPath[] outputLocations\t= new IPath[length+1];", "+\t\tboolean[] allowNestingInOutputLocations = new boolean[length+1];", "+\t\toutputLocations[0] = projectOutputLocation;", "+\t\t", "+\t\t// retrieve and check output locations", "-\t\t\tIClasspathEntry rawEntry = classpath[i];", "-\t\t\tswitch(rawEntry.getEntryKind()){", "-\t\t\t\t", "-\t\t\t\tcase IClasspathEntry.CPE_VARIABLE :", "-\t\t\t\t\tIClasspathEntry resolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);", "-\t\t\t\t\tif (resolvedEntry != null){", "-\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t", "-\t\t\t\tcase IClasspathEntry.CPE_CONTAINER :", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tIClasspathContainer container = JavaCore.getClasspathContainer(rawEntry.getPath(), javaProject);", "-\t\t\t\t\t\tif (container != null){", "-\t\t\t\t\t\t\tIClasspathEntry[] containerEntries = container.getClasspathEntries();", "-\t\t\t\t\t\t\tif (containerEntries != null){", "-\t\t\t\t\t\t\t\tfor (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){", "-\t\t\t\t\t\t\t\t\t//resolvedEntry = JavaCore.getResolvedClasspathEntry(containerEntries[j]);", "-\t\t\t\t\t\t\t\t\tresolvedEntry = containerEntries[j];", "-\t\t\t\t\t\t\t\t\tif (resolvedEntry != null){", "-\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "+\t\t\tIClasspathEntry resolvedEntry = classpath[i];", "+\t\t\tswitch(resolvedEntry.getEntryKind()){", "+\t\t\t\tcase IClasspathEntry.CPE_SOURCE :", "+\t\t\t\t\tIPath customOutput; ", "+\t\t\t\t\tif ((customOutput = resolvedEntry.getOutputLocation()) != null) {", "+\t\t\t\t\t\tint index;", "+\t\t\t\t\t\tif ((index = indexOfMatchingPath(customOutput, outputLocations, outputCount)) != -1) {", "+\t\t\t\t\t\t\tcontinue; // already found", "-\t\t\t\t\t} catch(JavaModelException e){", "-\t\t\t\t\t\treturn new JavaModelStatus(e);", "+\t\t\t\t\t\tif ((index = indexOfEnclosingPath(customOutput, outputLocations, outputCount)) != -1) {", "+\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInOutput\", customOutput.toString(), outputLocations[index].toString())); //$NON-NLS-1$", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\toutputLocations[outputCount++] = resolvedEntry.getOutputLocation();", "-\t\t\t\t\tbreak;", "-\t\t\t\t\t", "+\t\t\t}\t", "+\t\t}\t", "+\t\t", "+\t\tfor (int i = 0 ; i < length; i++) {", "+\t\t\tIClasspathEntry resolvedEntry = classpath[i];", "+\t\t\tint index;", "+\t\t\tswitch(resolvedEntry.getEntryKind()){", "+\t\t\t\t", "-\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "-\t\t\t\t\tif (!org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "-\t\t\t\t\t\thasLibFolder = true;", "+\t\t\t\t\tif ((index = indexOfMatchingPath(resolvedEntry.getPath(), outputLocations, outputCount)) != -1){", "+\t\t\t\t\t\tallowNestingInOutputLocations[index] = true;", "-\t\t\t\tdefault :", "-\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\tresolvedEntries.add(rawEntry);", "+\t\t\t\t\tbreak;", "+", "+\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "+\t\t\t\t\thasLibFolder |= !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(resolvedEntry.getPath().lastSegment());", "+\t\t\t\t\tif ((index = indexOfMatchingPath(resolvedEntry.getPath(), outputLocations, outputCount)) != -1){", "+\t\t\t\t\t\tallowNestingInOutputLocations[index] = true;", "+\t\t\t\t\t}", "-\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput = true; // if no source and no lib folder, then allowed", "-\t\t", "-\t\tlength = resolvedEntries.size();", "-\t\tclasspath = new IClasspathEntry[length];", "-\t\tresolvedEntries.toArray(classpath);", "+\t\tif (!hasSource && !hasLibFolder) { // if no source and no lib folder, then allowed", "+\t\t\tfor (int i = 0; i < outputCount; i++) allowNestingInOutputLocations[i] = true;", "+\t\t}", "+\t\t\t\t// tolerate nesting output in src if src==prj", "-\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "+\t\t\tint index;", "+\t\t\tif ((index = indexOfNestedPath(entryPath, outputLocations, outputCount)) != -1) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocations[index].toString(), entryPath.toString())); //$NON-NLS-1$", "-\t", "+", "-\t\t\tif (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "+\t\t\tif ((index = indexOfEnclosingPath(entryPath, outputLocations, outputCount)) != -1) {", "+\t\t\t\tif (!allowNestingInOutputLocations[index]){", "+\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocations[index].toString())); //$NON-NLS-1$", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37dbd12da1be296b02322354bee3910f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeReferenceLocator.java", "commitBeforeChange": "98ad487e103c268099d7117573693243c8d3b8fc", "commitAfterChange": "721a9dcda02493639666143934bddb089e848d18", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " protected void matchReportReference(QualifiedTypeReference qTypeRef, IJavaElement element, Binding elementBinding, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": " protected void matchReportReference(ASTNode reference, IJavaElement element, Binding elementBinding, Scope scope, int accuracy, MatchLocator locator) throws CoreException", "diff": ["+ */", "+protected void matchReportReference(ASTNode reference, IJavaElement element, Binding elementBinding, Scope scope, int accuracy, MatchLocator locator) throws CoreException {", "+\tif (scope == null || (scope.kind != Scope.BLOCK_SCOPE && scope.kind != Scope.METHOD_SCOPE)) {", "+\t\tmatchReportReference(reference, element, elementBinding, accuracy, locator);", "+\t\treturn;", "+\t}", "+\t", "+\t// Look if some block scope local variable declarations include reference start position", "+\tBlockScope blockScope = (BlockScope) scope;", "+\tLocalDeclaration[] localDeclarations = blockScope.findLocalVariableDeclarations(reference.sourceStart);", "+\tint length = localDeclarations == null ? 0 : localDeclarations.length;", "+\tIJavaElement localElement = null;", "+\tIJavaElement[] otherElements = null;", "+", "+\t// Some local variable declaration are matching", "+\tif (length > 0) {", "+", "+\t\t// Set local element to first matching local declaration", "+\t\tint idx = 0;", "+\t\tfor (; idx<length; idx++) {", "+\t\t\tif (localDeclarations[idx] == null) break;", "+\t\t\tif (reference.sourceStart == localDeclarations[idx].declarationSourceStart) {", "+\t\t\t\tlocalElement = locator.createHandle(localDeclarations[idx], element);", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tif (idx>0 && localDeclarations[idx].sourceStart > reference.sourceStart) {", "+\t\t\t\tlocalElement = locator.createHandle(localDeclarations[idx-1], element);", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\tif (localElement == null && idx > 0) {", "+\t\t\tif (reference.sourceEnd < localDeclarations[idx-1].declarationEnd) {", "+\t\t\t\tlocalElement = locator.createHandle(localDeclarations[idx-1], element);", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Store other local variable declarations in other elements", "+\t\tint size = 0;", "+\t\tfor (int j=1; j<length; j++) {", "+\t\t\tif (localDeclarations[j] == null) break;", "+\t\t\tif (reference.sourceStart == localDeclarations[j].declarationSourceStart) {", "+\t\t\t\tif (otherElements == null) {", "+\t\t\t\t\totherElements = new IJavaElement[length-j];", "+\t\t\t\t}", "+\t\t\t\totherElements[size++] = locator.createHandle(localDeclarations[j], element);", "+\t\t\t}", "+\t\t}", "+\t\tif (size > 0 && size != (length-1)) {", "+\t\t\tSystem.arraycopy(otherElements, 0, otherElements = new IJavaElement[size], 0, size);", "+\t\t}", "+\t}", "+\t", "+\t// Report match with local and other elements if any", "+\tmatchReportReference(reference, element, localElement, otherElements, elementBinding, accuracy, locator);", "-\tmatch = locator.newTypeReferenceMatch(element, elementBinding, accuracy, qTypeRef);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f61720369a2fcf2d8f68c03ee09ea5e5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "5292c15945b50fef548808f853ce39423b5670f2", "commitAfterChange": "e32dbbc9904e1f7eb4c6e79a7595e742217638b3", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 63, "signatureBeforeChange": "  \tprivate void printJavadocBlock(FormatJavadocBlock block)", "signatureAfterChange": "  \tprivate void printJavadocBlock(FormatJavadocBlock block)", "diff": ["+\t\t// Compute indentation", "+\t\tboolean headerLine = block.isHeaderLine() && this.lastNumberOfNewLines == 0;", "+\t\tint firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;", "+\t\tif (headerLine) firstColumn++;", "+\t\tStringBuffer indentationBuffer = printJavadocIndentationBuffer(block, firstColumn);", "+", "-\t\tint maxColumn = this.formatter.preferences.comment_line_length;", "+\t\tint maxColumn = this.formatter.preferences.comment_line_length + 1;", "+\t\tif (!block.isInlined()) {", "+\t\t\tthis.lastNumberOfNewLines = 0;", "+\t\t}", "-\t\t\tif (maxNodes < 0)  return;", "+\t\t\tif (maxNodes < 0)  {", "+\t\t\t\tif (block.isInlined()) {", "+\t\t\t\t\t// Need to print the closing brace", "+\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t\tif ((this.column+2) > (maxColumn+1)) {", "+\t\t\t\t\t\tthis.lastNumberOfNewLines++;", "+\t\t\t\t\t\tthis.line++;", "+\t\t\t\t    \tbuffer.append(this.lineSeparator);", "+\t\t\t\t    \tthis.column = 1;", "+\t\t\t\t    \tprintIndentationIfNecessary(buffer);", "+\t\t\t    \t\tbuffer.append(BLOCK_LINE_PREFIX);", "+\t\t\t\t    \tthis.column = headerLine ? firstColumn-1 : firstColumn;", "+\t\t\t\t    \tif (indentationBuffer != null) {", "+\t\t\t\t\t\t\tbuffer.append(indentationBuffer);", "+\t\t\t\t\t\t\tthis.column += indentationBuffer.length();", "+\t\t\t\t    \t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scanner.resetTo(previousEnd+1, block.sourceEnd+1);", "+\t\t\t\t\ttry {", "+\t                    int token = this.scanner.getNextToken();", "+\t                    while (token == TerminalTokens.TokenNameWHITESPACE || token == TerminalTokens.TokenNameMULTIPLY) {", "+\t                    \ttoken = this.scanner.getNextToken();", "+\t                    }", "+\t                    buffer.append(this.scanner.source, this.scanner.startPosition, this.scanner.currentPosition-this.scanner.startPosition);", "+                    } catch (InvalidInputException e) {", "+\t\t\t\t\t\tbuffer.append('}');", "+                    }", "+                    addReplaceEdit(previousEnd+1, block.sourceEnd, buffer.toString());", "+\t\t\t\t}", "+\t\t\t\treturn;", "+\t\t\t}", "-\t\tif (block.isHeaderLine()) maxColumn++;", "+//\t\tif (block.isHeaderLine()) maxColumn++;", "-\t\t\t\tnewLines = this.formatter.preferences.comment_insert_new_line_for_parameter && !block.isInlined() && block.isParamTag() ? 1 : 0;", "+\t\t\t\tnewLines = this.formatter.preferences.comment_insert_new_line_for_parameter && block.isParamTag() ? 1 : 0;", "+\t\t\t\t\tif (newLines == 0) {", "+\t\t\t\t\t\tnewLines = printJavadocBlockNodesNewLines(block, node, previousEnd);", "+\t\t\t\t\t}", "-\t\t\t\tnewLines = this.column > this.formatter.preferences.comment_line_length ? 1 : 0;", "-\t\t\t\tif (node.isText()) {", "-\t\t\t\t\t// Need to verify if new line is necessary for immutable tag", "-\t\t\t\t\tFormatJavadocText text = (FormatJavadocText) node;", "-\t\t\t\t\tif (newLines < text.linesBefore) newLines = text.linesBefore;", "-\t\t\t\t\tif (newLines == 0 && text.isImmutableHtmlTag()) {", "-\t\t\t\t\t\ttextLength = getTextLength(block, text);", "-\t\t\t\t\t\tif ((this.column + textLength) > maxColumn) {", "-\t\t\t\t\t\t\tnewLines = 1;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t\tnewLines = this.column > maxColumn ? 1 : 0;", "+\t\t\t\tif (newLines < node.linesBefore) newLines = node.linesBefore;", "+\t\t\t\tif (newLines == 0) {", "+\t\t\t\t\tnewLines = printJavadocBlockNodesNewLines(block, node, previousEnd);", "-\t\t\t\tif (!node.isText() || newLines > 0 || nodeStart > (previousEnd+1)) {", "-\t\t\t\t\tif (newLines == 0 && node.isText()) {", "-\t\t\t\t\t\t// Special case when two texts are consecutive (html tag->text or text->html tag)", "-\t\t\t\t\t\t// If no line is to be inserted, then no space should not be inserted either", "-\t\t\t\t\t\t// and column reset if the next token is over the max line length", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tthis.scanner.resetTo(nodeStart, block.sourceEnd);", "-\t\t\t\t\t\t\tthis.scanner.getNextToken();", "-\t\t\t\t    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;", "-\t\t\t\t    \t\tif (((FormatJavadocText)node).isHtmlTag()) {", "-\t\t\t\t\t\t\t\t// read the html tag", "-\t\t\t\t\t\t\t\tif (this.scanner.getNextToken() == TerminalTokens.TokenNameDIVIDE) {", "-\t\t\t\t\t\t\t\t\ttokenLength++;", "-\t\t\t\t\t\t\t\t\tthis.scanner.getNextToken();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\ttokenLength += (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;", "-\t\t\t\t\t\t\t\tthis.scanner.getNextToken(); // '>'", "-\t\t\t\t\t\t\t\ttokenLength++;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (nodeStart > (previousEnd+1)) {", "-\t\t\t\t\t\t\t\ttokenLength++; // include space between nodes", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif ((this.column + tokenLength) > maxColumn) {", "-\t\t\t\t\t\t\t\t// finally a new line will be inserted while printing next text", "-\t\t\t\t\t\t\t\tnewLines = 1;", "-\t\t\t\t\t\t\t\t((FormatJavadocText)node).linesBefore = 1;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t   \t\t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "-\t\t\t\t\t\t} catch (InvalidInputException iie) {", "-\t\t\t\t\t\t\t// skip", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t   \t\t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "-\t\t\t\t\t}", "+\t\t\t\tif (newLines > 0 || nodeStart > (previousEnd+1)) {", "+\t\t   \t\t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "-\t\t\t\t\t\tprintJavadocHtmlTag(text, block);", "+\t\t\t\t\t\tprintJavadocHtmlTag(text, block, newLines>0);", "-\t\t\t\t\tprintJavadocText(text, block);", "+\t\t\t\t\tprintJavadocText(text, block, newLines>0);", "+\t\t\t\tif (newLines > 0 && indentationBuffer != null) {", "+\t\t\t\t\taddInsertEdit(node.sourceStart, indentationBuffer.toString());", "+\t\t\t\t\tthis.column += indentationBuffer.length();", "+\t\t\t\t}", "+\t\tthis.lastNumberOfNewLines = 0;"]}], "num": 44376}