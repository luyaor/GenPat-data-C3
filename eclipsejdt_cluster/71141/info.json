{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "abc21780281ad150d5118e5db43db166", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2bc1db4bfd2290d4c425d84fc9a2d4da", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/antadapter/org/eclipse/jdt/core/JDTCompilerAdapter.java", "commitBeforeChange": "cdefa638776da3a046378c28559a0f9103ab4eaa", "commitAfterChange": "364f4a6fecddde86cbff58b22f5a3999ee18f64c", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \t \tprotected Commandline setupJavacCommand() throws BuildException", "signatureAfterChange": "  \tprotected Commandline setupJavacCommand() throws BuildException", "diff": ["-\t", "-\tprotected Commandline setupJavacCommand() throws BuildException {", "-\t\tCommandline cmd = new Commandline();", "-\t\t", "-\t\t/*", "-\t\t * This option is used to never exit at the end of the ant task. ", "-\t\t */", "-\t\tcmd.createArgument().setValue(\"-noExit\"); //$NON-NLS-1$", "-", "-\t\tcmd.createArgument().setValue(\"-bootclasspath\"); //$NON-NLS-1$", "-        if (bootclasspath != null && bootclasspath.size() != 0) {", "-\t\t\t/*", "-\t\t\t * Set the bootclasspath for the Eclipse compiler.", "-\t\t\t */", "-\t\t\tcmd.createArgument().setPath(bootclasspath);        \t", "-        } else {", "-            includeJavaRuntime = true;", "-        }", "-", "-        Path classpath = new Path(project);", "-", "-       /*", "-         * Eclipse compiler doesn't support -extdirs.", "-         * It is emulated using the classpath. We add extdirs entries after the ", "-         * bootclasspath.", "-         */", "-        addExtdirs(extdirs, classpath);", "-", "-\t\t/*", "-\t\t * The java runtime is already handled, so we simply want to retrieve the", "-\t\t * ant runtime and the compile classpath.", "-\t\t */", "-        classpath.append(getCompileClasspath());", "-", "-        // For -sourcepath, use the \"sourcepath\" value if present.", "-        // Otherwise default to the \"srcdir\" value.", "-        Path sourcepath = null;", "-        ", "-        // retrieve the method getSourcepath() using reflect", "-        // This is done to improve the compatibility to ant 1.5", "-        Class javacClass = Javac.class;", "-        Method getSourcepathMethod = null;", "-        try {", "-\t        getSourcepathMethod = javacClass.getMethod(\"getSourcepath\", null); //$NON-NLS-1$", "-        } catch(NoSuchMethodException e) {", "-        \t// if not found, then we cannot use this method (ant 1.5)", "-        }", "-        Path compileSourcePath = null;", "-        if (getSourcepathMethod != null) {", "-\t \t\ttry {", "-\t\t\t\tcompileSourcePath = (Path) getSourcepathMethod.invoke(attributes, null);", "-\t\t\t} catch (IllegalAccessException e) {", "-\t\t\t\t// should never happen", "-\t\t\t} catch (InvocationTargetException e) {", "-\t\t\t\t// should never happen", "-\t\t\t}", "-        }", "-        if (compileSourcePath != null) {", "-            sourcepath = compileSourcePath;", "-        } else {", "-            sourcepath = src;", "-        }", "-\t\tclasspath.append(sourcepath);", "-\t\t/*", "-\t\t * Set the classpath for the Eclipse compiler.", "-\t\t */", "-\t\tcmd.createArgument().setValue(\"-classpath\"); //$NON-NLS-1$", "-\t\tcmd.createArgument().setPath(classpath);", "-", "-        String memoryParameterPrefix = JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_1) ? \"-J-\" : \"-J-X\";//$NON-NLS-1$//$NON-NLS-2$", "-        if (memoryInitialSize != null) {", "-            if (!attributes.isForkedJavac()) {", "-                attributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryInitialSize\"), Project.MSG_WARN); //$NON-NLS-1$", "-            } else {", "-                cmd.createArgument().setValue(memoryParameterPrefix", "-                                              + \"ms\" + memoryInitialSize); //$NON-NLS-1$", "-            }", "-        }", "-", "-        if (memoryMaximumSize != null) {", "-            if (!attributes.isForkedJavac()) {", "-                attributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryMaximumSize\"), Project.MSG_WARN); //$NON-NLS-1$", "-            } else {", "-                cmd.createArgument().setValue(memoryParameterPrefix", "-                                              + \"mx\" + memoryMaximumSize); //$NON-NLS-1$", "-            }", "-        }", "-", "-        if (debug) {", "-\t       // retrieve the method getSourcepath() using reflect", "-\t        // This is done to improve the compatibility to ant 1.5", "-\t        Method getDebugLevelMethod = null;", "-\t        try {", "-\t\t        getDebugLevelMethod = javacClass.getMethod(\"getDebugLevel\", null); //$NON-NLS-1$", "-\t        } catch(NoSuchMethodException e) {", "-\t        \t// if not found, then we cannot use this method (ant 1.5)", "-\t        \t// debug level is only available with ant 1.5.x", "-\t        }", "-     \t    String debugLevel = null;", "-\t        if (getDebugLevelMethod != null) {", "-\t\t\t\ttry {", "-\t\t\t\t\tdebugLevel = (String) getDebugLevelMethod.invoke(attributes, null);", "-\t\t\t\t} catch (IllegalAccessException e) {", "-\t\t\t\t\t// should never happen", "-\t\t\t\t} catch (InvocationTargetException e) {", "-\t\t\t\t\t// should never happen", "-\t\t\t\t}", "-        \t}", "-\t\t\tif (debugLevel != null) {", "-\t\t\t\tif (debugLevel.length() == 0) {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-g:\" + debugLevel); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(\"-g\"); //$NON-NLS-1$", "-            }", "-        } else {", "-            cmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "-        }", "-        ", "-\t\t/*", "-\t\t * Handle the nowarn option. If none, then we generate all warnings.", "-\t\t */\t\t", "-        if (attributes.getNowarn()) {", "-\t\t\tif (deprecation) {", "-\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "-\t\t\t} else {", "-\t            cmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "-\t\t\t}", "-        } else {", "-\t\t\t/*", "-\t\t\t * deprecation option.", "-\t\t\t */\t\t", "-\t\t\tif (deprecation) {", "-\t\t\t\tcmd.createArgument().setValue(", "-\t\t\t\t\t\"-warn:allDeprecation,constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(", "-\t\t\t\t\t\"-warn:constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "-\t\t\t}", "-        }", "-", "-\t\t/*", "-\t\t * destDir option.", "-\t\t */\t\t", "-\t\tif (destDir != null) {", "-\t\t\tcmd.createArgument().setValue(\"-d\"); //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setFile(destDir.getAbsoluteFile());", "-\t\t}", "-", "-\t\t/*", "-\t\t * target option.", "-\t\t */\t\t", "-\t\tif (target != null) {", "-\t\t\tcmd.createArgument().setValue(\"-target\"); //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setValue(target);", "-\t\t}", "-", "-\t\t/*", "-\t\t * verbose option", "-\t\t */", "-\t\tif (verbose) {", "-\t\t\tcmd.createArgument().setValue(\"-verbose\"); //$NON-NLS-1$", "-\t\t\t/*", "-\t\t\t * extra option allowed by the Eclipse compiler", "-\t\t\t */", "-\t\t\tcmd.createArgument().setValue(\"-log\"); //$NON-NLS-1$", "-\t\t\tlogFileName = destDir.getAbsolutePath() + \".log\"; //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setValue(logFileName);", "-\t\t}", "-", "-\t\t/*", "-\t\t * failnoerror option", "-\t\t */", "-\t\tif (!attributes.getFailonerror()) {", "-\t\t\tcmd.createArgument().setValue(\"-proceedOnError\"); //$NON-NLS-1$", "-\t\t}", "-", "-\t\t/*", "-\t\t * source option", "-\t\t */", "-\t\tString source = attributes.getSource();", "-        if (source != null) {", "-            cmd.createArgument().setValue(\"-source\"); //$NON-NLS-1$", "-            cmd.createArgument().setValue(source);", "-        }", "-        ", "-\t\tif (JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_4)) {", "-\t\t\tif (target != null && target.equals(\"1.1\")) {\t\t\t   //$NON-NLS-1$\t", "-\t\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(\"-1.4\"); //$NON-NLS-1$", "-\t\t\t}", "-\t\t} else {", "-\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "-\t\t}", "-\t\t", "-\t\t/*", "-\t\t * encoding option", "-\t\t */", "-        if (encoding != null) {", "-            cmd.createArgument().setValue(\"-encoding\"); //$NON-NLS-1$", "-            cmd.createArgument().setValue(encoding);", "-        }", "-", "-\t\t/*", "-\t\t * extra option allowed by the Eclipse compiler", "-\t\t */", "-\t\tcmd.createArgument().setValue(\"-time\"); //$NON-NLS-1$", "-", "-\t\t/*", "-\t\t * Eclipse compiler doesn't have a -sourcepath option. This is", "-\t\t * handled through the javac task that collects all source files in", "-\t\t * srcdir option.", "-\t\t */        ", "-        logAndAddFilesToCompile(cmd);", "-\t\treturn cmd;", "-\t}", "+", "+\tprotected Commandline setupJavacCommand() throws BuildException {", "+\t\tCommandline cmd = new Commandline();", "+", "+\t\t/*", "+\t\t * This option is used to never exit at the end of the ant task. ", "+\t\t */", "+\t\tcmd.createArgument().setValue(\"-noExit\"); //$NON-NLS-1$", "+", "+\t\tcmd.createArgument().setValue(\"-bootclasspath\"); //$NON-NLS-1$", "+\t\tfinal Javac javac = getJavac();", "+\t\tPath bootcp = javac.getBootclasspath();", "+\t\tif (bootcp != null && bootcp.size() != 0) {", "+\t\t\t/*", "+\t\t\t * Set the bootclasspath for the Eclipse compiler.", "+\t\t\t */", "+\t\t\tcmd.createArgument().setPath(bootcp);", "+\t\t} else {", "+\t\t\tjavac.setIncludejavaruntime(true);", "+\t\t}", "+", "+\t\tProject proj = javac.getProject();", "+\t\tPath classpath = new Path(proj);", "+", "+\t\t/*", "+\t\t * Eclipse compiler doesn't support -extdirs.", "+\t\t * It is emulated using the classpath. We add extdirs entries after the ", "+\t\t * bootclasspath.", "+\t\t */", "+\t\taddExtdirs(classpath, javac.getExtdirs());", "+", "+\t\t/*", "+\t\t * The java runtime is already handled, so we simply want to retrieve the", "+\t\t * ant runtime and the compile classpath.", "+\t\t */", "+\t\tclasspath.append(getCompileClasspath());", "+", "+\t\t// For -sourcepath, use the \"sourcepath\" value if present.", "+\t\t// Otherwise default to the \"srcdir\" value.", "+\t\tPath sourcepath = null;", "+", "+        // retrieve the method getSourcepath() using reflect", "+        // This is done to improve the compatibility to ant 1.5", "+        Class javacClass = Javac.class;", "+        Method getSourcepathMethod = null;", "+        try {", "+\t        getSourcepathMethod = javacClass.getMethod(\"getSourcepath\", null); //$NON-NLS-1$", "+        } catch(NoSuchMethodException e) {", "+        \t// if not found, then we cannot use this method (ant 1.5)", "+        }", "+        Path compileSourcePath = null;", "+        if (getSourcepathMethod != null) {", "+\t \t\ttry {", "+\t\t\t\tcompileSourcePath = (Path) getSourcepathMethod.invoke(javac, null);", "+\t\t\t} catch (IllegalAccessException e) {", "+\t\t\t\t// should never happen", "+\t\t\t} catch (InvocationTargetException e) {", "+\t\t\t\t// should never happen", "+\t\t\t}", "+        }", "+ ", "+\t\tif (compileSourcePath != null) {", "+\t\t\tsourcepath = compileSourcePath;", "+\t\t} else {", "+\t\t\tsourcepath = javac.getSrcdir();", "+\t\t}", "+\t\tclasspath.append(sourcepath);", "+\t\t/*", "+\t\t * Set the classpath for the Eclipse compiler.", "+\t\t */", "+\t\tcmd.createArgument().setValue(\"-classpath\"); //$NON-NLS-1$", "+\t\tcmd.createArgument().setPath(javac.getClasspath());", "+", "+\t\tString memoryParameterPrefix = JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_1) ? \"-J-\" : \"-J-X\"; //$NON-NLS-1$//$NON-NLS-2$", "+\t\tString memInitialSize = javac.getMemoryInitialSize();", "+\t\tif (memInitialSize != null) {", "+\t\t\tif (!javac.isForkedJavac()) {", "+\t\t\t\tattributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryInitialSize\"), Project.MSG_WARN); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(memoryParameterPrefix + \"ms\" + memInitialSize); //$NON-NLS-1$", "+\t\t\t}", "+\t\t}", "+", "+\t\tString memMaximumSize = javac.getMemoryMaximumSize();", "+\t\tif (memMaximumSize != null) {", "+\t\t\tif (!javac.isForkedJavac()) {", "+\t\t\t\tattributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryMaximumSize\"), Project.MSG_WARN); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(memoryParameterPrefix + \"mx\" + memMaximumSize); //$NON-NLS-1$", "+\t\t\t}", "+\t\t}", "+", "+\t\tif (javac.getDebug()) {", "+\t       // retrieve the method getDebugLevel() using reflect", "+\t        // This is done to improve the compatibility to ant 1.5", "+\t        Method getDebugLevelMethod = null;", "+\t        try {", "+\t\t        getDebugLevelMethod = javacClass.getMethod(\"getDebugLevel\", null); //$NON-NLS-1$", "+\t        } catch(NoSuchMethodException e) {", "+\t        \t// if not found, then we cannot use this method (ant 1.5)", "+\t        \t// debug level is only available with ant 1.5.x", "+\t        }", "+     \t    String debugLevel = null;", "+\t        if (getDebugLevelMethod != null) {", "+\t\t\t\ttry {", "+\t\t\t\t\tdebugLevel = (String) getDebugLevelMethod.invoke(javac, null);", "+\t\t\t\t} catch (IllegalAccessException e) {", "+\t\t\t\t\t// should never happen", "+\t\t\t\t} catch (InvocationTargetException e) {", "+\t\t\t\t\t// should never happen", "+\t\t\t\t}", "+        \t}", "+\t\t\tif (debugLevel != null) {", "+\t\t\t\tif (debugLevel.length() == 0) {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "+\t\t\t\t} else {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-g:\" + debugLevel); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(\"-g\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t} else {", "+\t\t\tcmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "+\t\t}", "+", "+       // retrieve the method getCurrentCompilerArgs() using reflect", "+        // This is done to improve the compatibility to ant 1.5", "+        Method getCurrentCompilerArgsMethod = null;", "+        try {", "+\t        getCurrentCompilerArgsMethod = javacClass.getMethod(\"getCurrentCompilerArgs\", null); //$NON-NLS-1$", "+        } catch(NoSuchMethodException e) {", "+        \t// if not found, then we cannot use this method (ant 1.5)", "+        \t// debug level is only available with ant 1.5.x", "+        }", "+ \t    String[] compilerArgs = null;", "+        if (getCurrentCompilerArgsMethod != null) {", "+\t\t\ttry {", "+\t\t\t\tcompilerArgs = (String[]) getCurrentCompilerArgsMethod.invoke(javac, null);", "+\t\t\t} catch (IllegalAccessException e) {", "+\t\t\t\t// should never happen", "+\t\t\t} catch (InvocationTargetException e) {", "+\t\t\t\t// should never happen", "+\t\t\t}", "+    \t}", "+    \t", "+\t\tfinal boolean deprecationSetting = javac.getDeprecation();", "+\t   \tif (compilerArgs == null) {", "+\t\t\t/*", "+\t\t\t * Handle the nowarn option. If none, then we generate all warnings.", "+\t\t\t */", "+\t\t\tif (javac.getNowarn()) {", "+\t\t\t\tif (deprecationSetting) {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "+\t\t\t\t} else {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t} else if (deprecationSetting) {", "+\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation,constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(\"-warn:constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "+\t\t\t}", "+    \t} else {", "+\t\t\t/*", "+\t\t\t * Handle the nowarn option. If none, then we generate all warnings.", "+\t\t\t */", "+\t\t\tif (javac.getNowarn()) {", "+\t\t\t\tif (deprecationSetting) {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "+\t\t\t\t} else {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t} else if (deprecationSetting) {", "+\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "+\t\t\t}", "+\t   \t}", "+", "+\t\t/*", "+\t\t * destDir option.", "+\t\t */", "+\t\tfinal File destdir = javac.getDestdir();", "+\t\tif (destdir != null) {", "+\t\t\tcmd.createArgument().setValue(\"-d\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setFile(destdir.getAbsoluteFile());", "+\t\t}", "+", "+\t\t/*", "+\t\t * target option.", "+\t\t */", "+\t\tfinal String targetSetting = javac.getTarget();", "+\t\tif (targetSetting != null) {", "+\t\t\tcmd.createArgument().setValue(\"-target\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setValue(targetSetting);", "+\t\t}", "+", "+\t\t/*", "+\t\t * verbose option", "+\t\t */", "+\t\tif (javac.getVerbose()) {", "+\t\t\tcmd.createArgument().setValue(\"-verbose\"); //$NON-NLS-1$", "+\t\t\t/*", "+\t\t\t * extra option allowed by the Eclipse compiler", "+\t\t\t */", "+\t\t\tcmd.createArgument().setValue(\"-log\"); //$NON-NLS-1$", "+\t\t\tlogFileName = destdir.getAbsolutePath() + \".log\"; //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setValue(logFileName);", "+\t\t}", "+", "+\t\t/*", "+\t\t * failnoerror option", "+\t\t */", "+\t\tif (!javac.getFailonerror()) {", "+\t\t\tcmd.createArgument().setValue(\"-proceedOnError\"); //$NON-NLS-1$", "+\t\t}", "+", "+\t\t/*", "+\t\t * source option", "+\t\t */", "+\t\tfinal String source = javac.getSource();", "+\t\tif (source != null) {", "+\t\t\tcmd.createArgument().setValue(\"-source\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setValue(source);", "+\t\t}", "+", "+\t\tif (JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_4)) {", "+\t\t\tif (targetSetting != null && targetSetting.equals(\"1.1\")) { //$NON-NLS-1$\t", "+\t\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(\"-1.4\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t} else {", "+\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "+\t\t}", "+", "+\t\t/*", "+\t\t * encoding option", "+\t\t */", "+\t\tfinal String encodingSetting = javac.getEncoding();", "+\t\tif (encodingSetting != null) {", "+\t\t\tcmd.createArgument().setValue(\"-encoding\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setValue(encodingSetting);", "+\t\t}", "+", "+\t\t/*", "+\t\t * Add extra argument on the command line", "+\t\t */", "+\t\tif (compilerArgs != null) {", "+\t        cmd.addArguments(compilerArgs);", "+\t\t}", "+\t\t/*", "+\t\t * Eclipse compiler doesn't have a -sourcepath option. This is", "+\t\t * handled through the javac task that collects all source files in", "+\t\t * srcdir option.", "+\t\t */", "+\t\tlogAndAddFilesToCompile(cmd);", "+\t\treturn cmd;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "83d03769f660ec10417f8b0c32a0d2b6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/ElementProc.java", "commitBeforeChange": "f4eb00a745a91dbc4b9bd7fa4022524e166e1b90", "commitAfterChange": "a4f11659e59fa8a478723fa3bc2c5651f04c5382", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \t@Override \tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)", "signatureAfterChange": " \t@Override \tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)", "diff": ["+\t// Always return false from this processor, because it supports \"*\".", "-\t\tMap<String, String> options = processingEnv.getOptions();", "-\t\tif (!options.containsKey(\"org.eclipse.jdt.compiler.apt.tests.processors.elements.ElementProc\")) {", "+\t\tif (roundEnv.processingOver()) {", "+\t\t\t// We're not interested in the postprocessing round.", "-\t\tfor (Element e : roundEnv.getRootElements()) {", "-\t\t\tSystem.out.println(\"Found element \" + e.getSimpleName());", "+\t\tMap<String, String> options = processingEnv.getOptions();", "+\t\tif (!options.containsKey(CLASSNAME)) {", "+\t\t\t// Disable this processor unless we are intentionally performing the test.", "+\t\t\treturn false;", "+\t\t", "+\t\t// Verify that we get the root elements we expect", "+\t\tSet<String> expectedRootElementNames = new HashSet<String>(_rootElementNames.length);", "+\t\tfor (String name : _rootElementNames) {", "+\t\t\texpectedRootElementNames.add(name);", "+\t\t}", "+\t\tSet<? extends Element> actualRootElements = roundEnv.getRootElements();", "+\t\tif (null == actualRootElements) {", "+\t\t\tElementProc.reportError(\"getRootElements() returned null\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tfor (Element e : actualRootElements) {", "+\t\t\tString name = e.getSimpleName().toString();", "+\t\t\tif (!expectedRootElementNames.remove(name)) {", "+\t\t\t\tElementProc.reportError(\"Missing root element \" + name);", "+\t\t\t}", "+\t\t}", "+\t\tif (!expectedRootElementNames.isEmpty()) {", "+\t\t\tElementProc.reportError(\"Found extra root elements including \" + expectedRootElementNames.iterator().next());", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\t// Check some basic attributes", "+\t\tTypeElement elementIA = _elementUtils.getTypeElement(\"targets.model.pa.IA\");", "+\t\tif (elementIA == null) {", "+\t\t\tElementProc.reportError(\"element IA was not found\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tTypeElement elementAB = _elementUtils.getTypeElement(\"targets.model.pb.AB\");", "+\t\tif (elementAB == null) {", "+\t\t\tElementProc.reportError(\"element AB was not found\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tif (elementIA.getKind() != ElementKind.INTERFACE) {", "+\t\t\tElementProc.reportError(\"IA claims to not be an interface\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tif (elementAB.getKind() != ElementKind.CLASS) {", "+\t\t\tElementProc.reportError(\"AB claims to not be a class\");", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\t// Can we look at what interfaces AB implements?", "+\t\tList<? extends TypeMirror> ABinterfaces = elementAB.getInterfaces();", "+\t\tif (null == ABinterfaces) {", "+\t\t\tElementProc.reportError(\"AB.getInterfaces() returned null\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tboolean foundIAinterface = false;", "+\t\tfor (TypeMirror type : ABinterfaces) {", "+\t\t\tElement decl = _typeUtils.asElement(type);", "+\t\t\tif (null == decl) {", "+\t\t\t\tElementProc.reportError(\"One of AB's interfaces, \" + type.toString() + \", produced null from Types.asElement()\");", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t\tif (elementIA.equals(decl)) {", "+\t\t\t\tfoundIAinterface = true;", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\tif (!foundIAinterface) {", "+\t\t\tElementProc.reportError(\"AB does not have IA as an interface\");", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\tElementProc.reportSuccess();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "858eb19aa5e8098fd4fd1139e3f902ef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java", "commitBeforeChange": "30087d59ff5bea89d3392799267963cf724c3b0a", "commitAfterChange": "b08badd66fa6a6f7b4561ee1019c14e2a696043e", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " protected IBuffer openBuffer(IProgressMonitor pm) throws JavaModelException", "signatureAfterChange": " protected IBuffer openBuffer(IProgressMonitor pm) throws JavaModelException", "diff": ["+\t\treturn mapSource(mapper);", "+\t} else if (!checkAutomaticSourceMapping) {", "+\t\t/*", "+\t\t * We try to see if we can automatically attach a source", "+\t\t * source files located inside the same folder than its .class file", "+\t\t * See bug 36510.", "+\t\t */", "+\t\tPackageFragmentRoot root = getPackageFragmentRoot();", "+\t\tif (root.isArchive()) {", "+\t\t\t// root is a jar file or a zip file", "+\t\t\tString elementName = getElementName();", "+\t\t\tStringBuffer sourceFileName = new StringBuffer(elementName.substring(0, elementName.lastIndexOf('.')));", "+\t\t\tsourceFileName.append(Util.SUFFIX_java);", "+\t\t\tJarPackageFragmentRoot jarPackageFragmentRoot = (JarPackageFragmentRoot) root;", "+\t\t\tZipFile jar = null;", "+\t\t\ttry {", "+\t\t\t\tjar = jarPackageFragmentRoot.getJar();", "+\t\t\t\tIPackageFragment packageFragment = (IPackageFragment) getParent();", "+\t\t\t\tZipEntry zipEntry = null;", "+\t\t\t\tif (packageFragment.isDefaultPackage()) {", "+\t\t\t\t\tzipEntry = jar.getEntry(sourceFileName.toString());", "+\t\t\t\t} else {", "+\t\t\t\t\tzipEntry = jar.getEntry(getParent().getElementName() + '/' + sourceFileName.toString());", "+\t\t\t\t}", "+\t\t\t\tif (zipEntry != null) {", "+\t\t\t\t\t// found a source file", "+\t\t\t\t\tcheckAutomaticSourceMapping = true;", "+\t\t\t\t\troot.attachSource(root.getPath(), null, null);", "+\t\t\t\t\tSourceMapper sourceMapper = getSourceMapper();", "+\t\t\t\t\tif (sourceMapper != null) {", "+\t\t\t\t\t\treturn mapSource(sourceMapper);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} catch (CoreException e) {", "+\t\t\t\tif (e instanceof JavaModelException) throw (JavaModelException)e;", "+\t\t\t\tthrow new JavaModelException(e);", "+\t\t\t} finally {", "+\t\t\t\tJavaModelManager.getJavaModelManager().closeZipFile(jar);", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// Attempts to find the corresponding java file", "+\t\t\tString qualifiedName = getType().getFullyQualifiedName();", "+\t\t\tNameLookup lookup = ((JavaProject) getJavaProject()).getNameLookup();", "+\t\t\tICompilationUnit cu = lookup.findCompilationUnit(qualifiedName);", "+\t\t\tif (cu != null) {", "+\t\t\t\treturn cu.getBuffer();", "+\t\t\t} else\t{", "+\t\t\t\t// root is a class folder", "+\t\t\t\tIPath sourceFilePath = getPath().removeFileExtension().addFileExtension(\"java\");", "+\t\t\t\tIWorkspace workspace = ResourcesPlugin.getWorkspace();", "+\t\t\t\tif (workspace == null) {", "+\t\t\t\t\tcheckAutomaticSourceMapping = true; // we don't want to check again", "+\t\t\t\t\treturn null; // workaround for http://bugs.eclipse.org/bugs/show_bug.cgi?id=34069", "+\t\t\t\t}", "+\t\t\t\tif (JavaModel.getTarget(", "+\t\t\t\t\t\tworkspace.getRoot(),", "+\t\t\t\t\t\tsourceFilePath.makeRelative(), // ensure path is relative (see http://dev.eclipse.org/bugs/show_bug.cgi?id=22517)", "+\t\t\t\t\t\ttrue) != null) {", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t// found a source file", "+\t\t\t\t\t // we don't need to check again. The source will be attached.", "+\t\t\t\t\tcheckAutomaticSourceMapping = true;", "+\t\t\t\t\troot.attachSource(root.getPath(), null, null);", "+\t\t\t\t\tSourceMapper sourceMapper = getSourceMapper();", "+\t\t\t\t\tif (sourceMapper != null) {", "+\t\t\t\t\t\treturn mapSource(sourceMapper);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn null;", "+}", "-\t} else {", "-\t\t// Attempts to find the corresponding java file", "-\t\tString qualifiedName = getType().getFullyQualifiedName();", "-\t\tNameLookup lookup = ((JavaProject) getJavaProject()).getNameLookup();", "-\t\tICompilationUnit cu = lookup.findCompilationUnit(qualifiedName);", "-\t\tif (cu != null) {", "-\t\t\treturn cu.getBuffer();", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "914e575f3eff52eca77cde5b4a425938", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java", "commitBeforeChange": "1cd36da9dd049ac527dcab1976c08155d6c121b9", "commitAfterChange": "f2c2a11caa27156fb260986cef359f78136ce40c", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic String getKey()", "signatureAfterChange": " \tpublic String getKey()", "diff": ["-\t\tif (isLocal()) {", "-\t\t\treturn null;", "+\t\tif (this.key == null) {", "+\t\t\tif (isLocal()) {", "+\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t", "+\t\t\t\t// declaring method or type", "+\t\t\t\tSourceTypeBinding sourceBinding = (SourceTypeBinding) this.binding; // per construction, a local type can only be defined in source", "+\t\t\t\tClassScope scope = sourceBinding.scope;", "+\t\t\t\tReferenceContext referenceContext;", "+\t\t\t\tif (isAnonymous()) {", "+\t\t\t\t\tClassScope classScope = scope.enclosingClassScope();", "+\t\t\t\t\treferenceContext = classScope.referenceContext;", "+\t\t\t\t} else {", "+\t\t\t\t\tMethodScope methodScope = scope.enclosingMethodScope();", "+\t\t\t\t\treferenceContext = methodScope.referenceContext;", "+\t\t\t\t}", "+\t\t\t\tif (referenceContext instanceof AbstractMethodDeclaration) {", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.lookup.MethodBinding internalBinding = ((AbstractMethodDeclaration) referenceContext).binding;", "+\t\t\t\t\tIMethodBinding methodBinding = this.resolver.getMethodBinding(internalBinding);", "+\t\t\t\t\tif (methodBinding != null) {", "+\t\t\t\t\t\tbuffer.append(methodBinding.getKey());", "+\t\t\t\t\t}", "+\t\t\t\t} else if (referenceContext instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.lookup.TypeBinding internalBinding = ((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) referenceContext).binding;", "+\t\t\t\t\tITypeBinding typeBinding = this.resolver.getTypeBinding(internalBinding);", "+\t\t\t\t\tif (typeBinding != null) {", "+\t\t\t\t\t\tbuffer.append(typeBinding.getKey());", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t", "+\t\t\t\tif (isAnonymous()) {", "+\t\t\t\t\tbuffer.append('$');", "+\t\t\t\t\tCompilationUnitScope compilationUnitScope = scope.compilationUnitScope();", "+\t\t\t\t\tCompilationUnitDeclaration compilationUnitDeclaration = compilationUnitScope.referenceContext;", "+\t\t\t\t\tLocalTypeBinding[] localTypeBindings = compilationUnitDeclaration.localTypes;", "+\t\t\t\t\tfor (int i = 0, max = compilationUnitDeclaration.localTypeCount; i < max; i++) {", "+\t\t\t\t\t\tif (localTypeBindings[i] == sourceBinding) {", "+\t\t\t\t\t\t\tbuffer.append(i+1);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t// type name", "+\t\t\t\t\tbuffer.append('/');", "+\t\t\t\t\tbuffer.append(getName());", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tthis.key = buffer.toString();", "+\t\t\t} else {", "+\t\t\t\tif (this.binding.isClass() || this.binding.isInterface()) {", "+\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t\tbuffer", "+\t\t\t\t\t\t.append(getPackage().getName())", "+\t\t\t\t\t\t.append('/')", "+\t\t\t\t\t\t.append(getName());", "+\t\t\t\t\tthis.key = buffer.toString();", "+\t\t\t\t} else if (this.binding.isArrayType()) {", "+\t\t\t\t\tthis.key = this.getElementType().getKey() + this.getDimensions();", "+\t\t\t\t} else {", "+\t\t\t\t\t// this is a primitive type", "+\t\t\t\t\tthis.key = this.getName();", "+\t\t\t\t}", "+\t\t\t}", "-\t\tif (this.binding.isClass() || this.binding.isInterface()) {", "-\t\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\tbuffer", "-\t\t\t\t.append(getPackage().getName())", "-\t\t\t\t.append('.')", "-\t\t\t\t.append(getName());", "-\t\t\treturn buffer.toString();", "-\t\t} else if (this.binding.isArrayType()) {", "-\t\t\treturn this.getElementType().getKey() + this.getDimensions();", "-\t\t}", "-\t\t// this is a primitive type", "-\t\treturn this.getName();", "+\t\treturn this.key;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a5341719ece51db009e218387019965d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java", "commitBeforeChange": "4374063ffc07d9e5a6e12269e991cbcb89c32543", "commitAfterChange": "996ea5997dae4e7ec05722a233804ef32ae29f15", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 18, "signatureBeforeChange": "  \tpublic String getName()", "signatureAfterChange": "  \tpublic String getName()", "diff": ["-\t\tif (isClass() || isInterface() || isEnum()) {", "-\t\t\tReferenceBinding referenceBinding = (ReferenceBinding) this.binding;", "-\t\t\tif (referenceBinding.isAnonymousType()) {", "-\t\t\t\treturn NO_NAME;", "-\t\t\t} else {", "-\t\t\t\tchar[] shortName = referenceBinding.shortReadableName();", "-\t\t\t\tif (referenceBinding.isMemberType() || referenceBinding.isLocalType()) {", "-\t\t\t\t\treturn new String(CharOperation.subarray(shortName, CharOperation.lastIndexOf('.', shortName) + 1, shortName.length));", "-\t\t\t\t} else {", "-\t\t\t\t\treturn new String(shortName);", "+\t\tif (isWildcardType()) {", "+\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) this.binding;", "+\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\tbuffer.append(TypeConstants.WILDCARD_NAME);", "+\t\t\tif (wildcardBinding.bound != null) {", "+\t\t\t\tswitch(wildcardBinding.kind) {", "+\t\t\t        case Wildcard.SUPER :", "+\t\t\t        \tbuffer.append(TypeConstants.WILDCARD_SUPER);", "+\t\t\t            break;", "+\t\t\t        case Wildcard.EXTENDS :", "+\t\t\t        \tbuffer.append(TypeConstants.WILDCARD_EXTENDS);", "+\t\t\t\tbuffer.append(getBound().getName());", "-\t\t} else if (this.binding.isArrayType()) {", "-\t\t\tArrayBinding arrayBinding = (ArrayBinding) this.binding;", "-\t\t\tint dimensions = arrayBinding.dimensions;", "+\t\t\treturn String.valueOf(buffer);", "+\t\t}", "+\t\tif (isParameterizedType()) {", "+\t\t\tParameterizedTypeBinding parameterizedTypeBinding = (ParameterizedTypeBinding) this.binding;", "+\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\tbuffer.append(parameterizedTypeBinding.sourceName());", "+\t\t\tITypeBinding[] typeArguments = getTypeArguments();", "+\t\t\tfinal int typeArgumentsLength = typeArguments.length;", "+\t\t\tif (typeArgumentsLength != 0) {", "+\t\t\t\tbuffer.append('<');", "+\t\t\t\tfor (int i = 0, max = typeArguments.length; i < max; i++) {", "+\t\t\t\t\tif (i > 0) {", "+\t\t\t\t\t\tbuffer.append(',');", "+\t\t\t\t\t}", "+\t\t\t\t\tbuffer.append(typeArguments[i].getName());", "+\t\t\t\t}", "+\t\t\t\tbuffer.append('>');\t", "+\t\t\t}", "+\t\t\treturn String.valueOf(buffer);", "+\t\t}", "+\t\tif (isRawType()) {", "+\t\t\treturn getErasure().getName();", "+\t\t}", "+\t\tif (isPrimitive() || isNullType()) {", "+\t\t\tBaseTypeBinding baseTypeBinding = (BaseTypeBinding) this.binding;", "+\t\t\treturn new String(baseTypeBinding.simpleName);", "+\t\t}", "+\t\tif (isArray()) {", "+\t\t\tint dimensions = getDimensions();", "-\t\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\torg.eclipse.jdt.internal.compiler.lookup.TypeBinding leafComponentTypeBinding = arrayBinding.leafComponentType;", "-\t\t\tif ((leafComponentTypeBinding.isClass() || leafComponentTypeBinding.isInterface() || leafComponentTypeBinding.isEnum())", "-\t\t\t\t\t&& !leafComponentTypeBinding.isTypeVariable()) {", "-\t\t\t\tReferenceBinding referenceBinding2 = (ReferenceBinding) leafComponentTypeBinding;", "-\t\t\t\tchar[] shortName = referenceBinding2.shortReadableName();", "-\t\t\t\tif (referenceBinding2.isMemberType() || referenceBinding2.isLocalType()) {", "-\t\t\t\t\tbuffer.append(CharOperation.subarray(shortName, CharOperation.lastIndexOf('.', shortName) + 1, shortName.length));", "-\t\t\t\t} else {", "-\t\t\t\t\tbuffer.append(shortName);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tbuffer.append(leafComponentTypeBinding.readableName());", "-\t\t\t}", "+\t\t\tStringBuffer buffer = new StringBuffer(getElementType().getName());", "-\t\t\treturn buffer.toString();", "-\t\t} else {", "-\t\t\treturn new String(this.binding.readableName());", "+\t\t\treturn String.valueOf(buffer);", "+\t\tif (isAnonymous()) {", "+\t\t\treturn NO_NAME;", "+\t\t}", "+\t\tif (isTypeVariable()) {", "+\t\t\tTypeVariableBinding typeVariableBinding = (TypeVariableBinding) this.binding;", "+\t\t\treturn new String(typeVariableBinding.sourceName);", "+\t\t}", "+\t\treturn new String(this.binding.sourceName());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd140831c01c7272f21936c0dbcc4acd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "18811c004d543a3728cc5dfc4e05503a79b434ee", "commitAfterChange": "96cbe57b16442df110d3b0ecde11c12b456820b8", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \r public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope)", "signatureAfterChange": "\r public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope)", "diff": ["-\r", "-\treturn this.canBeSeenBy(receiverType,invocationSite.isSuperAccess(),scope);\r", "-}\r", "+\t\tint depth = 0;\r", "+\t\t\t\tif (invocationSite.isSuperAccess()){\r", "+\t\t\t\t}\r", "+\t\t\t\t// receiverType can be an array binding in one case... see if you can change it\r", "+\t\t\t\tif (receiverType instanceof ArrayBinding){\r", "+\t\t\t\t\treturn false;\r", "+\t\t\t\t}\r", "+\t\t\t\tif (isStatic()){\r", "+\t\t\t\t}\r", "+\t\t\t\tif (currentType == receiverType || currentType.isSuperclassOf((ReferenceBinding) receiverType)){\r", "+\t\t\t\t\tif (depth > 0) invocationSite.setDepth(depth);\r", "+\t\t\t\t\treturn true;\r", "+\t\t\t\t}\r", "+\t\t\tdepth++;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ceb8cb02bff7c3a26c34e569b09ece5d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java", "commitBeforeChange": "4374063ffc07d9e5a6e12269e991cbcb89c32543", "commitAfterChange": "996ea5997dae4e7ec05722a233804ef32ae29f15", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic String getQualifiedName()", "signatureAfterChange": " \tpublic String getQualifiedName()", "diff": ["-\t\t", "-\t\tif (isPrimitive() || isNullType() || this.isTypeVariable()) {", "-\t\t\treturn new String(this.binding.sourceName());", "+\t\tif (isPrimitive() || isNullType()) {", "+\t\t\tBaseTypeBinding baseTypeBinding = (BaseTypeBinding) this.binding;", "+\t\t\treturn new String(baseTypeBinding.simpleName);", "-\t\t", "-\t\tif (isArray()) {", "-\t\t\tITypeBinding elementType = getElementType();", "-\t\t\tString elementTypeQualifiedName = elementType.getQualifiedName();", "-\t\t\tif (elementTypeQualifiedName.length() != 0) {", "-\t\t\t\tint dimensions = this.getDimensions();", "-\t\t\t\tchar[] brackets = new char[dimensions * 2];", "-\t\t\t\tfor (int i = dimensions * 2 - 1; i >= 0; i -= 2) {", "-\t\t\t\t\tbrackets[i] = ']';", "-\t\t\t\t\tbrackets[i - 1] = '[';", "-\t\t\t\t}", "-\t\t\t\tStringBuffer stringBuffer = new StringBuffer(elementTypeQualifiedName);", "-\t\t\t\tstringBuffer.append(brackets);", "-\t\t\t\treturn stringBuffer.toString();", "-\t\t\t} else {", "-\t\t\t\treturn NO_NAME;", "-\t\t\t}", "-\t\t}", "-\t\tif (isTopLevel() || isMember()) {", "-\t\t\tPackageBinding packageBinding = this.binding.getPackage();", "-\t\t\t", "+\t\tif (isWildcardType()) {", "+\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) this.binding;", "-\t\t\tif (isWildcardType()) {", "-\t\t\t\tbuffer.append(TypeConstants.WILDCARD_NAME);", "-\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) this.binding;", "-\t\t\t\tif (wildcardBinding.bound != null) {", "-\t\t\t\t\tswitch(wildcardBinding.kind) {", "-\t\t\t\t\t\tcase Wildcard.SUPER :", "-\t\t\t\t\t\t\tbuffer.append(TypeConstants.WILDCARD_SUPER);", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase Wildcard.EXTENDS :", "-\t\t\t\t\t\t\tbuffer.append(TypeConstants.WILDCARD_EXTENDS);", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\tbuffer.append(getBound().getQualifiedName());\t\t\t\t", "+\t\t\tbuffer.append(TypeConstants.WILDCARD_NAME);", "+\t\t\tfinal ITypeBinding bound = getBound();", "+\t\t\tif (bound != null) {", "+\t\t\t\tswitch(wildcardBinding.kind) {", "+\t\t\t        case Wildcard.SUPER :", "+\t\t\t        \tbuffer.append(TypeConstants.WILDCARD_SUPER);", "+\t\t\t            break;", "+\t\t\t        case Wildcard.EXTENDS :", "+\t\t\t        \tbuffer.append(TypeConstants.WILDCARD_EXTENDS);", "-\t\t\t} else {", "-\t\t\t\tif (packageBinding != null && packageBinding.compoundName != CharOperation.NO_CHAR_CHAR) {", "-\t\t\t\t\tbuffer.append(packageBinding.readableName()).append('.');", "-\t\t\t\t}", "-\t\t\t\tbuffer.append(this.binding.qualifiedSourceName());", "-\t\t\t\tif (!isRawType()) {", "-\t\t\t\t\t// only one of the type parameters or type arguments is non-empty at the same time", "-\t\t\t\t\tappendQualifiedTypeParameters(buffer, getTypeParameters());", "-\t\t\t\t\tappendQualifiedTypeArguments(buffer, getTypeArguments());", "-\t\t\t\t}", "+\t\t\t\tbuffer.append(bound.getQualifiedName());", "-\t\treturn NO_NAME;", "+\t\tif (isRawType()) {", "+\t\t\treturn getErasure().getQualifiedName();", "+\t\t}", "+\t\tif (isArray()) {", "+\t\t\tITypeBinding elementType = getElementType();", "+\t\t\tif (elementType.isLocal() || elementType.isAnonymous()) {", "+\t\t\t\treturn NO_NAME;", "+\t\t\t}", "+\t\t\tfinal int dimensions = getDimensions();", "+\t\t\tchar[] brackets = new char[dimensions * 2];", "+\t\t\tfor (int i = dimensions * 2 - 1; i >= 0; i -= 2) {", "+\t\t\t\tbrackets[i] = ']';", "+\t\t\t\tbrackets[i - 1] = '[';", "+\t\t\t}", "+\t\t\tStringBuffer buffer = new StringBuffer(elementType.getQualifiedName());", "+\t\t\tbuffer.append(brackets);", "+\t\t\treturn String.valueOf(buffer);", "+\t\t}", "+\t\tif (isTypeVariable()) {", "+\t\t\tTypeVariableBinding typeVariableBinding = (TypeVariableBinding) this.binding;", "+\t\t\treturn new String(typeVariableBinding.sourceName);", "+\t\t}", "+\t\tif (isMember()) {", "+\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\tbuffer", "+\t\t\t\t.append(this.resolver.getTypeBinding(this.binding.enclosingType()).getQualifiedName())", "+\t\t\t\t.append('.')", "+\t\t\t\t.append(getName());", "+\t\t\treturn String.valueOf(buffer);", "+\t\t}", "+\t\tif (isParameterizedType()) {", "+\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\tbuffer.append(getErasure().getQualifiedName());", "+\t\t\tITypeBinding[] typeArguments = getTypeArguments();", "+\t\t\tfinal int typeArgumentsLength = typeArguments.length;", "+\t\t\tif (typeArgumentsLength != 0) {", "+\t\t\t\tbuffer.append('<');", "+\t\t\t\tfor (int i = 0, max = typeArguments.length; i < max; i++) {", "+\t\t\t\t\tif (i > 0) {", "+\t\t\t\t\t\tbuffer.append(',');", "+\t\t\t\t\t}", "+\t\t\t\t\tbuffer.append(typeArguments[i].getQualifiedName());", "+\t\t\t\t}", "+\t\t\t\tbuffer.append('>');", "+\t\t\t}", "+\t\t\treturn String.valueOf(buffer);", "+\t\t}", "+\t\tif (isRawType()) {", "+\t\t\treturn getErasure().getQualifiedName();", "+\t\t}", "+\t\tPackageBinding packageBinding = this.binding.getPackage();", "+\t\t", "+\t\tStringBuffer buffer = new StringBuffer();", "+\t\tif (packageBinding != null && packageBinding.compoundName != CharOperation.NO_CHAR_CHAR) {", "+\t\t\tbuffer.append(CharOperation.concatWith(packageBinding.compoundName, '.')).append('.');", "+\t\t}", "+\t\tbuffer.append(getName());", "+", "+\t\treturn String.valueOf(buffer);"]}], "num": 71141}