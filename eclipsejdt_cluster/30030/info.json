{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "90abf7327bf671b62bbf67283ff5e406", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34da968b08d7d6d083afc57df05724db", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java", "commitBeforeChange": "7511ce8ac2a616c416b32731f4d10587027e3f25", "commitAfterChange": "71d14c28198258a4d6a7c5df6309a1aa1f387bf3", "methodNumberBeforeChange": 99, "methodNumberAfterChange": 99, "signatureBeforeChange": " \tvoid genericPropertyListTest(ASTNode node, List children, Property prop)", "signatureAfterChange": " \tvoid genericPropertyListTest(ASTNode node, List children, Property prop)", "diff": ["-\t\t\tAST newAST;", "-\t\t\tif (node.getAST().apiLevel() == AST.LEVEL_2_0) {", "-\t\t\t\tnewAST = AST.newAST2();", "-\t\t\t} else {", "-\t\t\t\tnewAST = AST.newAST3();", "-\t\t\t}", "+\t\t\tAST newAST = AST.newAST(node.getAST().apiLevel());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6bdc5c7d27f31afda983db76cd67098a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "e29082e6108e43f171cfe9fae0a56914a1f2ec3e", "commitAfterChange": "c9393df013a58676e5f14d40d6c8db0b129e07c0", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t    /* https://bugs.eclipse.org/bugs/show_bug.cgi?id=375394, To avoid spurious bounds check failures due to circularity in formal bounds, ", "-\t\t       we should eliminate only the lingering embedded type variable references after substitution, not alien type variable references", "-\t\t       that constitute the inference per se. Also short circuit this step, if the substitution has no type variables in the first place ", "-\t\t       (as it is effectively a nop.)", "-\t\t     */ ", "-\t\t    TypeBinding substituteForChecks;", "-\t\t    if (substitute instanceof TypeVariableBinding || ((substitute.tagBits & TagBits.HasTypeVariable) == 0)) {", "-\t\t    \tsubstituteForChecks = substitute;", "-\t\t    } else {", "-\t\t    \tsubstituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "-\t\t    }", "-\t\t    ", "+\t\t    TypeBinding substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check"]}], "num": 30030}