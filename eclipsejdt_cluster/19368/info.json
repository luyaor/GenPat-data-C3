{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "17fd8cc08985aa81679c69625762f54e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "30ac8ccd443ce5035453d9d7f13debf3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "1b80cae94595518122618b458eed60915f76d171", "commitAfterChange": "92d6141bb346285ff13c588faa5a059cb9f83b3d", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tpreTryInitStateIndex =", "+\t\tthis.preTryInitStateIndex =", "-\t\tif (anyExceptionVariable != null) {", "-\t\t\tanyExceptionVariable.useFlag = LocalVariableBinding.USED;", "+\t\tif (this.anyExceptionVariable != null) {", "+\t\t\tthis.anyExceptionVariable.useFlag = LocalVariableBinding.USED;", "-\t\tif (returnAddressVariable != null) { // TODO (philippe) if subroutine is escaping, unused", "-\t\t\treturnAddressVariable.useFlag = LocalVariableBinding.USED;", "+\t\tif (this.returnAddressVariable != null) { // TODO (philippe) if subroutine is escaping, unused", "+\t\t\tthis.returnAddressVariable.useFlag = LocalVariableBinding.USED;", "-\t\tif (subRoutineStartLabel == null) {", "+\t\tif (this.subRoutineStartLabel == null) {", "-\t\t\t\tfinallyBlock", "+\t\t\t\tthis.finallyBlock", "-\t\t\t\t\t\tfinallyContext = new FinallyFlowContext(flowContext, finallyBlock),", "+\t\t\t\t\t\tfinallyContext = new FinallyFlowContext(flowContext, this.finallyBlock),", "-\t\t\t\tisSubRoutineEscaping = true;", "-\t\t\t\tscope.problemReporter().finallyMustCompleteNormally(finallyBlock);", "+\t\t\t\tthis.isSubRoutineEscaping = true;", "+\t\t\t\tthis.scope.problemReporter().finallyMustCompleteNormally(this.finallyBlock);", "-\t\t\t\ttryBlock,", "-\t\t\t\tcaughtExceptionTypes,", "-\t\t\t\tscope,", "+\t\t\t\tthis.tryBlock,", "+\t\t\t\tthis.caughtExceptionTypes,", "+\t\t\t\tthis.scope,", "-\t\tif (tryBlock.isEmptyBlock()) {", "+\t\tif (this.tryBlock.isEmptyBlock()) {", "-\t\t\ttryBlockExit = false;", "+\t\t\tthis.tryBlockExit = false;", "-\t\t\ttryInfo = tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "-\t\t\ttryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\tthis.tryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\thandlingContext.complainIfUnusedExceptionHandlers(scope, this);", "+\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "-\t\tif (catchArguments != null) {", "+\t\tif (this.catchArguments != null) {", "-\t\t\tcatchExits = new boolean[catchCount = catchBlocks.length];", "+\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "-\t\t\t\t\t\t\t\tcaughtExceptionTypes[i]))", "+\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "-\t\t\t\tLocalVariableBinding catchArg = catchArguments[i].binding;", "+\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\tif (tryBlock.statements == null) {", "+\t\t\t\tif (this.tryBlock.statements == null) {", "-\t\t\t\t\tcatchBlocks[i].analyseCode(", "+\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "-\t\t\t\tcatchExits[i] = ", "+\t\t\t\tthis.catchExits[i] = ", "-\t\tif (subRoutineStartLabel == null) {", "-\t\t\tmergedInitStateIndex =", "+\t\tif (this.subRoutineStartLabel == null) {", "+\t\t\tthis.mergedInitStateIndex =", "-\t\t\tmergedInitStateIndex =", "+\t\t\tthis.mergedInitStateIndex =", "-\t\t\tmergedInitStateIndex =", "+\t\t\tthis.mergedInitStateIndex ="]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "69e2f5c83864484bb8dbc21728fbf18a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/HandleFactory.java", "commitBeforeChange": "9f8c0aff4541413a1d59ce816c9847753c28077a", "commitAfterChange": "9252f03474977360ba3ba4ad93fe71b877d8ccd9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprivate IPackageFragmentRoot getJarPkgFragmentRoot(String jarPathString)", "signatureAfterChange": " \tprivate IPackageFragmentRoot getJarPkgFragmentRoot(String jarPathString, IJavaSearchScope scope)", "diff": ["-\tprivate IPackageFragmentRoot getJarPkgFragmentRoot(String jarPathString) {", "+\tprivate IPackageFragmentRoot getJarPkgFragmentRoot(String jarPathString, IJavaSearchScope scope) {", "-\t\t// walk all projects and find the first one that has the given jar path in its classpath", "+\t\t// walk projects in the scope and find the first one that has the given jar path in its classpath", "+\t\tif (scope != null) {", "+\t\t\tIPath[] enclosingProjectsAndJars = scope.enclosingProjectsAndJars();", "+\t\t\tint length = enclosingProjectsAndJars.length;", "+\t\t\tprojects = new IJavaProject[length];", "+\t\t\tint index = 0;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tIPath path = enclosingProjectsAndJars[i];", "+\t\t\t\tif (!Util.isArchiveFileName(path.lastSegment())) {", "+\t\t\t\t\tprojects[index++] = this.javaModel.getJavaProject(path.segment(0));", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (index < length) {", "+\t\t\t\tSystem.arraycopy(projects, 0, projects = new IJavaProject[index], 0, index);", "+\t\t\t}", "+\t\t\tIPackageFragmentRoot root = getJarPkgFragmentRoot(jarPathString, jarPath, target, projects);", "+\t\t\tif (root != null) {", "+\t\t\t\treturn root;", "+\t\t\t}", "+\t\t} ", "+\t\t", "+\t\t// not found in the scope, walk all projects", "+\t\treturn getJarPkgFragmentRoot(jarPathString, jarPath, target, projects);", "+\t}"]}], "num": 19368}