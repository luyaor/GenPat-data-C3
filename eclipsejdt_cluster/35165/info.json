{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8494af9072c6aed7b3065897896e7817", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3d0939339490c151e078ed8b900f211b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "cbeae19d2fbc13263c1b9f693649af94787713c0", "commitAfterChange": "bfd17b0ed14dc5643292e77fa62ae765f4f8c89d", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " int[] findOverriddenInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": " int[] findOverriddenInheritedMethods(MethodBinding[] methods, int length)", "diff": ["-\t\tint firstInterfaceMethod = length;", "-\t\t\tif (toSkip != null && toSkip[i] == -1) continue nextMethod;", "-\t\t\t\tif (firstInterfaceMethod == length)", "-\t\t\t\t\tfirstInterfaceMethod = i;", "-\t\t\t\tfor (int j = firstInterfaceMethod; j < length; j++) {", "-\t\t\t\t\tif (i == j) continue;", "+\t\t\t\tif (toSkip != null && toSkip[i] == -1) continue nextMethod;", "+\t\t\t\tfor (int j = i + 1; j < length; j++) {", "+\t\t\t\t\tif (toSkip != null && toSkip[j] == -1) continue;", "-\t\t\t\t\tif (declaringClass2.implementsInterface(declaringClass, true)) {", "+\t\t\t\t\tif (declaringClass.implementsInterface(declaringClass2, true)) {", "+\t\t\t\t\t\tif (toSkip == null)", "+\t\t\t\t\t\t\ttoSkip = new int[length];", "+\t\t\t\t\t\ttoSkip[j] = -1;", "+\t\t\t\t\t} else if (declaringClass2.implementsInterface(declaringClass, true)) {", "-\t\t\t} else { ", "-\t\t\t\tfor (int j = i + 1; j < firstInterfaceMethod; j++) {", "+\t\t\t} else {", "+\t\t\t\t// only keep methods from the closest superclass, all others from higher superclasses can be skipped", "+\t\t\t\t// NOTE: methods were added in order by walking up the superclass hierarchy", "+\t\t\t\tfor (int j = i + 1; j < length; j++) {", "+\t\t\t\t\tif (declaringClass == declaringClass2) continue;", "-\t\t\t\t\t\t// no methods from classes left", "-\t\t\t\t\t\tfirstInterfaceMethod = j;", "+\t\t\t\t\t\ti = j - 1; // start the interface comparison with this method", "-\t\t\t\t\t}", "-\t\t\t\t\tif (declaringClass != declaringClass2 && declaringClass2.isSuperclassOf(declaringClass)) {", "+\t\t\t\t\t} else {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6002c8b4515777a6175ff5ad09ddba82", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "0d26cebfc5ac438f5812d87a88435e81d289bbea", "commitAfterChange": "51bd97b9a16ddeaff77cec180dcadc8f8924a66a", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["-\t\t\t\tMethodBinding method = visible[i].tiebreakMethod();", "+\t\t\t\tMethodBinding tiebreakMethod = visible[i].tiebreakMethod();", "-\t\t\t\t\tMethodBinding method2 = visible[j].tiebreakMethod();", "-\t\t\t\t\tif (!isMoreSpecificMethod(method, method2)) {", "-\t\t\t\t\t\tif (!isMoreSpecificMethod(method2, method))", "+\t\t\t\t\tMethodBinding tiebreakMethod2 = visible[j].tiebreakMethod();", "+\t\t\t\t\tif (!isMoreSpecificMethod(tiebreakMethod, tiebreakMethod2)) {", "+\t\t\t\t\t\tif (!isMoreSpecificMethod(tiebreakMethod2, tiebreakMethod))", "-\t\t\t\t\tif (method.areParametersEqual(method2)) {", "+\t\t\t\t\tif (tiebreakMethod.areParametersEqual(tiebreakMethod2)) {", "+\t\t\t\t\t\tMethodBinding method = tiebreakMethod;", "+\t\t\t\t\t\tMethodBinding method2 = tiebreakMethod2;", "-\t\t\t\t\t\tif (method.hasSubstitutedParameters() && method.isAbstract() == method2.isAbstract() && receiverType != null) {", "+\t\t\t\t\t\tif (method.isAbstract() == method2.isAbstract() && receiverType != null", "+\t\t\t\t\t\t\t&& (method.hasSubstitutedParameters() || original.typeVariables != Binding.NO_TYPE_VARIABLES)) {", "+\t\t\t\t\t\t\t// when method has no type variables and method2 does, then you need a way to substitute them with their erasures at least", "+\t\t\t\t\t\t\t// to detect   class AA<T> { void test() {} }   vs   class BB extends AA<CC> { <U> void test() {} }", "-\t\t\t\t\t\t\tcontinue nextVisible; // method2 is better match than method", "-\t\t\t\tmethod = visible[i]; // instead of the tieBreakMethod", "-\t\t\t\tcompilationUnitScope().recordTypeReferences(method.thrownExceptions);", "-\t\t\t\treturn method;", "+\t\t\t\tcompilationUnitScope().recordTypeReferences(visible[i].thrownExceptions);", "+\t\t\t\treturn visible[i];", "-\t}\t", "+\t}"]}], "num": 35165}