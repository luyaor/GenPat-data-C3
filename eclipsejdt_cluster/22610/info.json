{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "241dcd6805a7da5cddaef868842f10a7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f6d8fde1780f743c0c073d0f18de707", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "0f841a0360389f0f91aef636ca6531276c4a074d", "commitAfterChange": "4e57894c46e6fdc6da393db7e5519e070814fd68", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner)", "signatureAfterChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner, int flags)", "diff": ["-\tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner) {", "-\t", "+\tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner, int flags) {", "+", "-\t\t\t\t\tchar[] fileName = unit.compilationResult.getFileName();\t\t\t\t\t", "+\t\t\t\t\tchar[] fileName = unit.compilationResult.getFileName();", "+\t\t\t\t\t\tast.setFlag(flags | AST.RESOLVED_BINDINGS);", "-\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables);", "+\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables, (flags & ICompilationUnit.ENABLE_BINDINGS_RECOVERY) != 0);", "-\t\t\t\t\t\t", "+", "-\t\t\t\t\t\t", "+", "-\t\t\t\t\t} ", "-\t\t\t\t\t", "+\t\t\t\t\t}", "+", "-\t\t\t\t\t", "+", "-\t\t\t\t\t\t", "-/*\tCode used to fault in types and resolve which is no longer necessary as all questions asked to forward references are", "- * lazily resolved.", "- * Code used to be:", "-\t\t\t\t\tif (this.requestedKeys.containsKey(fileName) || this.requestedSources.containsKey(fileName)) {", "-\t\t\t\t\t   ...", "-\t\t\t\t\t} else {", "-", "-\t\t\t\t\t\tif (unit.scope != null)", "-\t\t\t\t\t\t\tunit.scope.faultInTypes();// still force resolution of signatures, so clients can query DOM AST", "-\t\t\t\t", "-\t\t\t\t\t\t// the following ensures that all type, method and field bindings are correctly initialized", "-\t\t\t\t\t\t// as they may be needed by further units", "-\t\t\t\t\t\t// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=111822)", "-\t\t\t\t\t\tunit.resolve();", "-\t\t\t\t\t\t", "-\t\t\t\t\t\t// note that if this has a performance penalty on clients, the above code should be removed", "-\t\t\t\t\t\t// the following patch would workaround bug 111822:", "-", "-Index: FieldReference.java", "-===================================================================", "-RCS file: /cvsroot/eclipse/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java,v", "-retrieving revision 1.87", "-diff -u -r1.87 FieldReference.java", "---- FieldReference.java\t24 Sep 2005 15:23:46 -0000\t1.87", "-+++ FieldReference.java\t7 Oct 2005 13:46:12 -0000", "-@@ -407,7 +407,14 @@", "- ", "- \t\tFieldBinding originalField = binding.original();", "- \t\tSourceTypeBinding sourceType = (SourceTypeBinding) originalField.declaringClass;", "--\t\tTypeDeclaration typeDecl = sourceType.scope.referenceContext;", "-+\t\tClassScope classScope = sourceType.scope;", "-+\t\tif (classScope == null) {", "-+\t\t\t// Non compiler clients may not have resolved enough of the unit when processing it, and", "-+\t\t\t// scopes got cleaned. Assuming these clients thus do not care about constant info, will simply", "-+\t\t\t// pretend it is not a constant.", "-+\t\t\treturn NotAConstant;", "-+\t\t}", "-+\t\tTypeDeclaration typeDecl = classScope.referenceContext;", "- \t\tFieldDeclaration fieldDecl = typeDecl.declarationOf(originalField);", "- ", "- \t\tfieldDecl.resolve(originalField.isStatic() //side effect on binding ", "-*/\t\t\t\t\t", "-\t\t\t", "+", "-\t\t\tDefaultBindingResolver resolver = new DefaultBindingResolver(this.lookupEnvironment, owner, this.bindingTables);", "+\t\t\tDefaultBindingResolver resolver = new DefaultBindingResolver(this.lookupEnvironment, owner, this.bindingTables, (flags & ICompilationUnit.ENABLE_BINDINGS_RECOVERY) != 0);", "-            astRequestor.compilationUnitResolver = null;", "+\t\t\tastRequestor.compilationUnitResolver = null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7508fbe1cc994c9ddec8ff687dbf0ac8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java", "commitBeforeChange": "cbbe8b69b29b99c8c679b98644156abe11f1564d", "commitAfterChange": "ab74babcdf0f89ee66e36b91189c0d301a4da95d", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tpublic void searchAllTypeNames( \t\tfinal char[] packageName,  \t\tfinal char[] typeName, \t\tfinal int matchRule,  \t\tint searchFor,  \t\tIJavaSearchScope scope,  \t\tfinal IRestrictedAccessTypeRequestor nameRequestor, \t\tint waitingPolicy, \t\tIProgressMonitor progressMonitor)  throws JavaModelException", "signatureAfterChange": " \tpublic void searchAllTypeNames( \t\tfinal char[] packageName,  \t\tfinal int packageMatchRule,  \t\tfinal char[] typeName, \t\tfinal int typeMatchRule,  \t\tint searchFor,  \t\tIJavaSearchScope scope,  \t\tfinal IRestrictedAccessTypeRequestor nameRequestor, \t\tint waitingPolicy, \t\tIProgressMonitor progressMonitor)  throws JavaModelException", "diff": ["-\t */", "-\tpublic void searchAllTypeNames(", "-\t\tfinal char[] packageName, ", "-\t\tfinal char[] typeName,", "-\t\tfinal int matchRule, ", "-\t\tint searchFor, ", "-\t\tIJavaSearchScope scope, ", "-\t\tfinal IRestrictedAccessTypeRequestor nameRequestor,", "-\t\tint waitingPolicy,", "-\t\tIProgressMonitor progressMonitor)  throws JavaModelException {", "-", "-\t\tif (VERBOSE) {", "-\t\t\tUtil.verbose(\"BasicSearchEngine.searchAllTypeNames(char[], char[], int, int, IJavaSearchScope, IRestrictedAccessTypeRequestor, int, IProgressMonitor)\"); //$NON-NLS-1$", "-\t\t\tUtil.verbose(\"\t- package name: \"+(packageName==null?\"null\":new String(packageName))); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\tUtil.verbose(\"\t- type name: \"+(typeName==null?\"null\":new String(typeName))); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\tUtil.verbose(\"\t- match rule: \"+getMatchRuleString(matchRule)); //$NON-NLS-1$", "-\t\t\tUtil.verbose(\"\t- search for: \"+searchFor); //$NON-NLS-1$", "-\t\t\tUtil.verbose(\"\t- scope: \"+scope); //$NON-NLS-1$", "-\t\t}", "-", "-\t\t// Return on invalid combination of package and type names", "-\t\tif (packageName == null || packageName.length == 0) {", "-\t\t\tif (typeName != null && typeName.length == 0) {", "-\t\t\t\tif (VERBOSE) {", "-\t\t\t\t\tUtil.verbose(\"\t=> return no result due to invalid empty values for package and type names!\"); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t}", "-", "-\t\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();", "-\t\tfinal char typeSuffix;", "-\t\tswitch(searchFor){", "-\t\t\tcase IJavaSearchConstants.CLASS :", "-\t\t\t\ttypeSuffix = IIndexConstants.CLASS_SUFFIX;", "-\t\t\t\tbreak;", "-\t\t\tcase IJavaSearchConstants.CLASS_AND_INTERFACE :", "-\t\t\t\ttypeSuffix = IIndexConstants.CLASS_AND_INTERFACE_SUFFIX;", "-\t\t\t\tbreak;", "-\t\t\tcase IJavaSearchConstants.CLASS_AND_ENUM :", "-\t\t\t\ttypeSuffix = IIndexConstants.CLASS_AND_ENUM_SUFFIX;", "-\t\t\t\tbreak;", "-\t\t\tcase IJavaSearchConstants.INTERFACE :", "-\t\t\t\ttypeSuffix = IIndexConstants.INTERFACE_SUFFIX;", "-\t\t\t\tbreak;", "-\t\t\tcase IJavaSearchConstants.ENUM :", "-\t\t\t\ttypeSuffix = IIndexConstants.ENUM_SUFFIX;", "-\t\t\t\tbreak;", "-\t\t\tcase IJavaSearchConstants.ANNOTATION_TYPE :", "-\t\t\t\ttypeSuffix = IIndexConstants.ANNOTATION_TYPE_SUFFIX;", "-\t\t\t\tbreak;", "-\t\t\tdefault : ", "-\t\t\t\ttypeSuffix = IIndexConstants.TYPE_SUFFIX;", "-\t\t\t\tbreak;", "-\t\t}", "-\t\tfinal TypeDeclarationPattern pattern = new TypeDeclarationPattern(", "-\t\t\tpackageName,", "-\t\t\tnull, // do find member types", "-\t\t\ttypeName,", "-\t\t\ttypeSuffix,", "-\t\t\tmatchRule);", "-", "-\t\t// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor", "-\t\tfinal HashSet workingCopyPaths = new HashSet();", "-\t\tString workingCopyPath = null;", "-\t\tICompilationUnit[] copies = getWorkingCopies();", "-\t\tfinal int copiesLength = copies == null ? 0 : copies.length;", "-\t\tif (copies != null) {", "-\t\t\tif (copiesLength == 1) {", "-\t\t\t\tworkingCopyPath = copies[0].getPath().toString();", "-\t\t\t} else {", "-\t\t\t\tfor (int i = 0; i < copiesLength; i++) {", "-\t\t\t\t\tICompilationUnit workingCopy = copies[i];", "-\t\t\t\t\tworkingCopyPaths.add(workingCopy.getPath().toString());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tfinal String singleWkcpPath = workingCopyPath;", "-", "-\t\t// Index requestor", "-\t\tIndexQueryRequestor searchRequestor = new IndexQueryRequestor(){", "-\t\t\tpublic boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {", "-\t\t\t\t// Filter unexpected types", "-\t\t\t\tTypeDeclarationPattern record = (TypeDeclarationPattern)indexRecord;", "-\t\t\t\tif (record.enclosingTypeNames == IIndexConstants.ONE_ZERO_CHAR) {", "-\t\t\t\t\treturn true; // filter out local and anonymous classes", "-\t\t\t\t}", "-\t\t\t\tswitch (copiesLength) {", "-\t\t\t\t\tcase 0:", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase 1:", "-\t\t\t\t\t\tif (singleWkcpPath.equals(documentPath)) {", "-\t\t\t\t\t\t\treturn true; // fliter out *the* working copy", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\tif (workingCopyPaths.contains(documentPath)) {", "-\t\t\t\t\t\t\treturn true; // filter out working copies", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "-", "-\t\t\t\t// Accept document path", "-\t\t\t\tAccessRestriction accessRestriction = null;", "-\t\t\t\tif (access != null) {", "-\t\t\t\t\t// Compute document relative path", "-\t\t\t\t\tint pkgLength = (record.pkg==null || record.pkg.length==0) ? 0 : record.pkg.length+1;", "-\t\t\t\t\tint nameLength = record.simpleName==null ? 0 : record.simpleName.length;", "-\t\t\t\t\tchar[] path = new char[pkgLength+nameLength];", "-\t\t\t\t\tint pos = 0;", "-\t\t\t\t\tif (pkgLength > 0) {", "-\t\t\t\t\t\tSystem.arraycopy(record.pkg, 0, path, pos, pkgLength-1);", "-\t\t\t\t\t\tCharOperation.replace(path, '.', '/');", "-\t\t\t\t\t\tpath[pkgLength-1] = '/';", "-\t\t\t\t\t\tpos += pkgLength;", "-\t\t\t\t\t}", "-\t\t\t\t\tif (nameLength > 0) {", "-\t\t\t\t\t\tSystem.arraycopy(record.simpleName, 0, path, pos, nameLength);", "-\t\t\t\t\t\tpos += nameLength;", "-\t\t\t\t\t}", "-\t\t\t\t\t// Update access restriction if path is not empty", "-\t\t\t\t\tif (pos > 0) {", "-\t\t\t\t\t\taccessRestriction = access.getViolatedRestriction(path);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (match(record.typeSuffix, record.modifiers)) {", "-\t\t\t\t\tnameRequestor.acceptType(record.modifiers, record.pkg, record.simpleName, record.enclosingTypeNames, documentPath, accessRestriction);", "-\t\t\t\t}", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t};", "-\t", "-\t\ttry {", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tprogressMonitor.beginTask(Messages.engine_searching, 100); ", "-\t\t\t}", "-\t\t\t// add type names from indexes", "-\t\t\tindexManager.performConcurrentJob(", "-\t\t\t\tnew PatternSearchJob(", "-\t\t\t\t\tpattern, ", "-\t\t\t\t\tgetDefaultSearchParticipant(), // Java search only", "-\t\t\t\t\tscope, ", "-\t\t\t\t\tsearchRequestor),", "-\t\t\t\twaitingPolicy,", "-\t\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));\t", "-\t\t\t\t", "-\t\t\t// add type names from working copies", "-\t\t\tif (copies != null) {", "-\t\t\t\tfor (int i = 0; i < copiesLength; i++) {", "-\t\t\t\t\tICompilationUnit workingCopy = copies[i];", "-\t\t\t\t\tif (!scope.encloses(workingCopy)) continue;", "-\t\t\t\t\tfinal String path = workingCopy.getPath().toString();", "-\t\t\t\t\tif (workingCopy.isConsistent()) {", "-\t\t\t\t\t\tIPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();", "-\t\t\t\t\t\tchar[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();", "-\t\t\t\t\t\tIType[] allTypes = workingCopy.getAllTypes();", "-\t\t\t\t\t\tfor (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {", "-\t\t\t\t\t\t\tIType type = allTypes[j];", "-\t\t\t\t\t\t\tIJavaElement parent = type.getParent();", "-\t\t\t\t\t\t\tchar[][] enclosingTypeNames;", "-\t\t\t\t\t\t\tif (parent instanceof IType) {", "-\t\t\t\t\t\t\t\tchar[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();", "-\t\t\t\t\t\t\t\tenclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tenclosingTypeNames = CharOperation.NO_CHAR_CHAR;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tchar[] simpleName = type.getElementName().toCharArray();", "-\t\t\t\t\t\t\tint kind;", "-\t\t\t\t\t\t\tif (type.isEnum()) {", "-\t\t\t\t\t\t\t\tkind = TypeDeclaration.ENUM_DECL;", "-\t\t\t\t\t\t\t} else if (type.isAnnotation()) {", "-\t\t\t\t\t\t\t\tkind = TypeDeclaration.ANNOTATION_TYPE_DECL;", "-\t\t\t\t\t\t\t}\telse if (type.isClass()) {", "-\t\t\t\t\t\t\t\tkind = TypeDeclaration.CLASS_DECL;", "-\t\t\t\t\t\t\t} else /*if (type.isInterface())*/ {", "-\t\t\t\t\t\t\t\tkind = TypeDeclaration.INTERFACE_DECL;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (match(typeSuffix, packageName, typeName, matchRule, kind, packageDeclaration, simpleName)) {", "-\t\t\t\t\t\t\t\tnameRequestor.acceptType(type.getFlags(), packageDeclaration, simpleName, enclosingTypeNames, path, null);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tParser basicParser = getParser();", "-\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;", "-\t\t\t\t\t\tCompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);", "-\t\t\t\t\t\tCompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);", "-\t\t\t\t\t\tif (parsedUnit != null) {", "-\t\t\t\t\t\t\tfinal char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');", "-\t\t\t\t\t\t\tclass AllTypeDeclarationsVisitor extends ASTVisitor {", "-\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {", "-\t\t\t\t\t\t\t\t\treturn false; // no local/anonymous type", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope compilationUnitScope) {", "-\t\t\t\t\t\t\t\t\tif (match(typeSuffix, packageName, typeName, matchRule, TypeDeclaration.kind(typeDeclaration.modifiers), packageDeclaration, typeDeclaration.name)) {", "-\t\t\t\t\t\t\t\t\t\tnameRequestor.acceptType(typeDeclaration.modifiers, packageDeclaration, typeDeclaration.name, CharOperation.NO_CHAR_CHAR, path, null);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {", "-\t\t\t\t\t\t\t\t\tif (match(typeSuffix, packageName, typeName, matchRule, TypeDeclaration.kind(memberTypeDeclaration.modifiers), packageDeclaration, memberTypeDeclaration.name)) {", "-\t\t\t\t\t\t\t\t\t\t// compute encloising type names", "-\t\t\t\t\t\t\t\t\t\tTypeDeclaration enclosing = memberTypeDeclaration.enclosingType;", "-\t\t\t\t\t\t\t\t\t\tchar[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;", "-\t\t\t\t\t\t\t\t\t\twhile (enclosing != null) {", "-\t\t\t\t\t\t\t\t\t\t\tenclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);", "-\t\t\t\t\t\t\t\t\t\t\tif ((enclosing.bits & ASTNode.IsMemberType) != 0) {", "-\t\t\t\t\t\t\t\t\t\t\t\tenclosing = enclosing.enclosingType;", "-\t\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t\tenclosing = null;", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t// report", "-\t\t\t\t\t\t\t\t\t\tnameRequestor.acceptType(memberTypeDeclaration.modifiers, packageDeclaration, memberTypeDeclaration.name, enclosingTypeNames, path, null);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tparsedUnit.traverse(new AllTypeDeclarationsVisitor(), parsedUnit.scope);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}\t", "-\t\t} finally {", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tprogressMonitor.done();", "-\t\t\t}", "-\t\t}", "-\t}", "+\t */", "+\tpublic void searchAllTypeNames(", "+\t\tfinal char[] packageName, ", "+\t\tfinal int packageMatchRule, ", "+\t\tfinal char[] typeName,", "+\t\tfinal int typeMatchRule, ", "+\t\tint searchFor, ", "+\t\tIJavaSearchScope scope, ", "+\t\tfinal IRestrictedAccessTypeRequestor nameRequestor,", "+\t\tint waitingPolicy,", "+\t\tIProgressMonitor progressMonitor)  throws JavaModelException {", "+", "+\t\tif (VERBOSE) {", "+\t\t\tUtil.verbose(\"BasicSearchEngine.searchAllTypeNames(char[], char[], int, int, IJavaSearchScope, IRestrictedAccessTypeRequestor, int, IProgressMonitor)\"); //$NON-NLS-1$", "+\t\t\tUtil.verbose(\"\t- package name: \"+(packageName==null?\"null\":new String(packageName))); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\tUtil.verbose(\"\t- match rule: \"+getMatchRuleString(packageMatchRule)); //$NON-NLS-1$", "+\t\t\tUtil.verbose(\"\t- type name: \"+(typeName==null?\"null\":new String(typeName))); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\tUtil.verbose(\"\t- match rule: \"+getMatchRuleString(typeMatchRule)); //$NON-NLS-1$", "+\t\t\tUtil.verbose(\"\t- search for: \"+searchFor); //$NON-NLS-1$", "+\t\t\tUtil.verbose(\"\t- scope: \"+scope); //$NON-NLS-1$", "+\t\t}", "+", "+\t\t// Return on invalid combination of package and type names", "+\t\tif (packageName == null || packageName.length == 0) {", "+\t\t\tif (typeName != null && typeName.length == 0) {", "+\t\t\t\t// TODO (frederic) Throw a JME instead?", "+\t\t\t\tif (VERBOSE) {", "+\t\t\t\t\tUtil.verbose(\"\t=> return no result due to invalid empty values for package and type names!\"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t}", "+", "+\t\t// Create pattern", "+\t\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();", "+\t\tfinal char typeSuffix;", "+\t\tswitch(searchFor){", "+\t\t\tcase IJavaSearchConstants.CLASS :", "+\t\t\t\ttypeSuffix = IIndexConstants.CLASS_SUFFIX;", "+\t\t\t\tbreak;", "+\t\t\tcase IJavaSearchConstants.CLASS_AND_INTERFACE :", "+\t\t\t\ttypeSuffix = IIndexConstants.CLASS_AND_INTERFACE_SUFFIX;", "+\t\t\t\tbreak;", "+\t\t\tcase IJavaSearchConstants.CLASS_AND_ENUM :", "+\t\t\t\ttypeSuffix = IIndexConstants.CLASS_AND_ENUM_SUFFIX;", "+\t\t\t\tbreak;", "+\t\t\tcase IJavaSearchConstants.INTERFACE :", "+\t\t\t\ttypeSuffix = IIndexConstants.INTERFACE_SUFFIX;", "+\t\t\t\tbreak;", "+\t\t\tcase IJavaSearchConstants.ENUM :", "+\t\t\t\ttypeSuffix = IIndexConstants.ENUM_SUFFIX;", "+\t\t\t\tbreak;", "+\t\t\tcase IJavaSearchConstants.ANNOTATION_TYPE :", "+\t\t\t\ttypeSuffix = IIndexConstants.ANNOTATION_TYPE_SUFFIX;", "+\t\t\t\tbreak;", "+\t\t\tdefault : ", "+\t\t\t\ttypeSuffix = IIndexConstants.TYPE_SUFFIX;", "+\t\t\t\tbreak;", "+\t\t}", "+\t\tfinal TypeDeclarationPattern pattern = packageMatchRule == SearchPattern.R_EXACT_MATCH", "+\t\t\t? new TypeDeclarationPattern(", "+\t\t\t\tpackageName,", "+\t\t\t\tnull,", "+\t\t\t\ttypeName,", "+\t\t\t\ttypeSuffix,", "+\t\t\t\ttypeMatchRule)", "+\t\t\t: new QualifiedTypeDeclarationPattern(", "+\t\t\t\tpackageName,", "+\t\t\t\tpackageMatchRule,", "+\t\t\t\ttypeName,", "+\t\t\t\ttypeSuffix,", "+\t\t\t\ttypeMatchRule);", "+", "+\t\t// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor", "+\t\tfinal HashSet workingCopyPaths = new HashSet();", "+\t\tString workingCopyPath = null;", "+\t\tICompilationUnit[] copies = getWorkingCopies();", "+\t\tfinal int copiesLength = copies == null ? 0 : copies.length;", "+\t\tif (copies != null) {", "+\t\t\tif (copiesLength == 1) {", "+\t\t\t\tworkingCopyPath = copies[0].getPath().toString();", "+\t\t\t} else {", "+\t\t\t\tfor (int i = 0; i < copiesLength; i++) {", "+\t\t\t\t\tICompilationUnit workingCopy = copies[i];", "+\t\t\t\t\tworkingCopyPaths.add(workingCopy.getPath().toString());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tfinal String singleWkcpPath = workingCopyPath;", "+", "+\t\t// Index requestor", "+\t\tIndexQueryRequestor searchRequestor = new IndexQueryRequestor(){", "+\t\t\tpublic boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {", "+\t\t\t\t// Filter unexpected types", "+\t\t\t\tTypeDeclarationPattern record = (TypeDeclarationPattern)indexRecord;", "+\t\t\t\tif (record.enclosingTypeNames == IIndexConstants.ONE_ZERO_CHAR) {", "+\t\t\t\t\treturn true; // filter out local and anonymous classes", "+\t\t\t\t}", "+\t\t\t\tswitch (copiesLength) {", "+\t\t\t\t\tcase 0:", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase 1:", "+\t\t\t\t\t\tif (singleWkcpPath.equals(documentPath)) {", "+\t\t\t\t\t\t\treturn true; // fliter out *the* working copy", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tif (workingCopyPaths.contains(documentPath)) {", "+\t\t\t\t\t\t\treturn true; // filter out working copies", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+", "+\t\t\t\t// Accept document path", "+\t\t\t\tAccessRestriction accessRestriction = null;", "+\t\t\t\tif (access != null) {", "+\t\t\t\t\t// Compute document relative path", "+\t\t\t\t\tint pkgLength = (record.pkg==null || record.pkg.length==0) ? 0 : record.pkg.length+1;", "+\t\t\t\t\tint nameLength = record.simpleName==null ? 0 : record.simpleName.length;", "+\t\t\t\t\tchar[] path = new char[pkgLength+nameLength];", "+\t\t\t\t\tint pos = 0;", "+\t\t\t\t\tif (pkgLength > 0) {", "+\t\t\t\t\t\tSystem.arraycopy(record.pkg, 0, path, pos, pkgLength-1);", "+\t\t\t\t\t\tCharOperation.replace(path, '.', '/');", "+\t\t\t\t\t\tpath[pkgLength-1] = '/';", "+\t\t\t\t\t\tpos += pkgLength;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (nameLength > 0) {", "+\t\t\t\t\t\tSystem.arraycopy(record.simpleName, 0, path, pos, nameLength);", "+\t\t\t\t\t\tpos += nameLength;", "+\t\t\t\t\t}", "+\t\t\t\t\t// Update access restriction if path is not empty", "+\t\t\t\t\tif (pos > 0) {", "+\t\t\t\t\t\taccessRestriction = access.getViolatedRestriction(path);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (match(record.typeSuffix, record.modifiers)) {", "+\t\t\t\t\tnameRequestor.acceptType(record.modifiers, record.pkg, record.simpleName, record.enclosingTypeNames, documentPath, accessRestriction);", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t};", "+\t", "+\t\ttry {", "+\t\t\tif (progressMonitor != null) {", "+\t\t\t\tprogressMonitor.beginTask(Messages.engine_searching, 100); ", "+\t\t\t}", "+\t\t\t// add type names from indexes", "+\t\t\tindexManager.performConcurrentJob(", "+\t\t\t\tnew PatternSearchJob(", "+\t\t\t\t\tpattern, ", "+\t\t\t\t\tgetDefaultSearchParticipant(), // Java search only", "+\t\t\t\t\tscope, ", "+\t\t\t\t\tsearchRequestor),", "+\t\t\t\twaitingPolicy,", "+\t\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));\t", "+\t\t\t\t", "+\t\t\t// add type names from working copies", "+\t\t\tif (copies != null) {", "+\t\t\t\tfor (int i = 0; i < copiesLength; i++) {", "+\t\t\t\t\tICompilationUnit workingCopy = copies[i];", "+\t\t\t\t\tif (!scope.encloses(workingCopy)) continue;", "+\t\t\t\t\tfinal String path = workingCopy.getPath().toString();", "+\t\t\t\t\tif (workingCopy.isConsistent()) {", "+\t\t\t\t\t\tIPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();", "+\t\t\t\t\t\tchar[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();", "+\t\t\t\t\t\tIType[] allTypes = workingCopy.getAllTypes();", "+\t\t\t\t\t\tfor (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {", "+\t\t\t\t\t\t\tIType type = allTypes[j];", "+\t\t\t\t\t\t\tIJavaElement parent = type.getParent();", "+\t\t\t\t\t\t\tchar[][] enclosingTypeNames;", "+\t\t\t\t\t\t\tif (parent instanceof IType) {", "+\t\t\t\t\t\t\t\tchar[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();", "+\t\t\t\t\t\t\t\tenclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tenclosingTypeNames = CharOperation.NO_CHAR_CHAR;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tchar[] simpleName = type.getElementName().toCharArray();", "+\t\t\t\t\t\t\tint kind;", "+\t\t\t\t\t\t\tif (type.isEnum()) {", "+\t\t\t\t\t\t\t\tkind = TypeDeclaration.ENUM_DECL;", "+\t\t\t\t\t\t\t} else if (type.isAnnotation()) {", "+\t\t\t\t\t\t\t\tkind = TypeDeclaration.ANNOTATION_TYPE_DECL;", "+\t\t\t\t\t\t\t}\telse if (type.isClass()) {", "+\t\t\t\t\t\t\t\tkind = TypeDeclaration.CLASS_DECL;", "+\t\t\t\t\t\t\t} else /*if (type.isInterface())*/ {", "+\t\t\t\t\t\t\t\tkind = TypeDeclaration.INTERFACE_DECL;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (match(typeSuffix, packageName, typeName, typeMatchRule, kind, packageDeclaration, simpleName)) {", "+\t\t\t\t\t\t\t\tnameRequestor.acceptType(type.getFlags(), packageDeclaration, simpleName, enclosingTypeNames, path, null);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tParser basicParser = getParser();", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;", "+\t\t\t\t\t\tCompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);", "+\t\t\t\t\t\tCompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);", "+\t\t\t\t\t\tif (parsedUnit != null) {", "+\t\t\t\t\t\t\tfinal char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');", "+\t\t\t\t\t\t\tclass AllTypeDeclarationsVisitor extends ASTVisitor {", "+\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {", "+\t\t\t\t\t\t\t\t\treturn false; // no local/anonymous type", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope compilationUnitScope) {", "+\t\t\t\t\t\t\t\t\tif (match(typeSuffix, packageName, typeName, typeMatchRule, TypeDeclaration.kind(typeDeclaration.modifiers), packageDeclaration, typeDeclaration.name)) {", "+\t\t\t\t\t\t\t\t\t\tnameRequestor.acceptType(typeDeclaration.modifiers, packageDeclaration, typeDeclaration.name, CharOperation.NO_CHAR_CHAR, path, null);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {", "+\t\t\t\t\t\t\t\t\tif (match(typeSuffix, packageName, typeName, typeMatchRule, TypeDeclaration.kind(memberTypeDeclaration.modifiers), packageDeclaration, memberTypeDeclaration.name)) {", "+\t\t\t\t\t\t\t\t\t\t// compute encloising type names", "+\t\t\t\t\t\t\t\t\t\tTypeDeclaration enclosing = memberTypeDeclaration.enclosingType;", "+\t\t\t\t\t\t\t\t\t\tchar[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;", "+\t\t\t\t\t\t\t\t\t\twhile (enclosing != null) {", "+\t\t\t\t\t\t\t\t\t\t\tenclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);", "+\t\t\t\t\t\t\t\t\t\t\tif ((enclosing.bits & ASTNode.IsMemberType) != 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\tenclosing = enclosing.enclosingType;", "+\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\tenclosing = null;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t// report", "+\t\t\t\t\t\t\t\t\t\tnameRequestor.acceptType(memberTypeDeclaration.modifiers, packageDeclaration, memberTypeDeclaration.name, enclosingTypeNames, path, null);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tparsedUnit.traverse(new AllTypeDeclarationsVisitor(), parsedUnit.scope);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}\t", "+\t\t} finally {", "+\t\t\tif (progressMonitor != null) {", "+\t\t\t\tprogressMonitor.done();", "+\t\t\t}", "+\t\t}", "+\t}"]}], "num": 22610}