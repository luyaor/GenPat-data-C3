{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "47a7a127914bc58ba840ec1ca39dc09c", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1f61069ff5c18a3c534d9c0695697b6b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java", "commitBeforeChange": "43ba239664019dd489061a00645e975e2ecd1a6c", "commitAfterChange": "a19171d5a6cc8e94c6df1651af7a51cd6da24781", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope upperScope)", "diff": ["-\t\t\tif (expressionType == null)", "-\t\t\t\treturn;", "-\t\t\texpression.computeConversion(upperScope, expressionType, expressionType);", "-\t\t\tcheckType: {", "-\t\t\t\tif (expressionType.isBaseType()) {", "-\t\t\t\t\tif (expression.isConstantValueOfTypeAssignableToType(expressionType, IntBinding))", "+\t\t\tif (expressionType != null) {", "+\t\t\t\texpression.computeConversion(upperScope, expressionType, expressionType);", "+\t\t\t\tcheckType: {", "+\t\t\t\t\tif (expressionType.isBaseType()) {", "+\t\t\t\t\t\tif (expression.isConstantValueOfTypeAssignableToType(expressionType, IntBinding))", "+\t\t\t\t\t\t\tbreak checkType;", "+\t\t\t\t\t\tif (expressionType.isCompatibleWith(IntBinding))", "+\t\t\t\t\t\t\tbreak checkType;", "+\t\t\t\t\t} else if (expressionType.isEnum()) {", "+\t\t\t\t\t\tisEnumSwitch = true;", "-\t\t\t\t\tif (expressionType.isCompatibleWith(IntBinding))", "+\t\t\t\t\t} else if (upperScope.isBoxingCompatibleWith(expressionType, IntBinding)) {", "+\t\t\t\t\t\texpression.computeConversion(upperScope, IntBinding, expressionType);", "-\t\t\t\t} else if (expressionType.isEnum()) {", "-\t\t\t\t\tisEnumSwitch = true;", "-\t\t\t\t\tbreak checkType;", "-\t\t\t\t} else if (upperScope.isBoxingCompatibleWith(expressionType, IntBinding)) {", "-\t\t\t\t\texpression.computeConversion(upperScope, IntBinding, expressionType);", "-\t\t\t\t\tbreak checkType;", "+\t\t\t\t\t}", "+\t\t\t\t\tupperScope.problemReporter().incorrectSwitchType(expression, expressionType);", "+\t\t\t\t\texpressionType = null; // fault-tolerance: ignore type mismatch from constants from hereon", "-\t\t\t\tupperScope.problemReporter().incorrectSwitchType(expression, expressionType);", "-\t\t\t\t// TODO (philippe) could keep analyzing switch statements in case of error", "-\t\t\t\treturn;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a6484d3b064a05439a319260f66b080", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java", "commitBeforeChange": "b21d6f8f20d5a0613166092aaf1883f1403e1251", "commitAfterChange": "b3921c5eea6f0c6a7e0f7e9f7a3a4e8e611961a3", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedType)", "signatureAfterChange": "  \tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedType)", "diff": ["-\t\t\t\tTypeBinding exprType = expression instanceof ArrayInitializer", "+\t\t\t\tTypeBinding expressionType = expression instanceof ArrayInitializer", "-\t\t\t\tif (exprType == null)", "-\t\t\t\t\treturn null;", "+\t\t\t\tif (expressionType == null)", "+\t\t\t\t\tcontinue;", "-\t\t\t\tif (elementType != exprType) // must call before computeConversion() and typeMismatchError()", "-\t\t\t\t\tscope.compilationUnitScope().recordTypeConversion(elementType, exprType);", "+\t\t\t\tif (elementType != expressionType) // must call before computeConversion() and typeMismatchError()", "+\t\t\t\t\tscope.compilationUnitScope().recordTypeConversion(elementType, expressionType);", "-\t\t\t\tif ((expression.isConstantValueOfTypeAssignableToType(exprType, elementType)", "-\t\t\t\t\t\t|| (elementType.isBaseType() && BaseTypeBinding.isWidening(elementType.id, exprType.id)))", "-\t\t\t\t\t\t|| exprType.isCompatibleWith(elementType)) {", "-\t\t\t\t\texpression.computeConversion(scope, elementType, exprType);", "-\t\t\t\t} else if (scope.isBoxingCompatibleWith(exprType, elementType) ", "-\t\t\t\t\t\t\t\t\t|| (exprType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\tif ((expression.isConstantValueOfTypeAssignableToType(expressionType, elementType)", "+\t\t\t\t\t\t|| (elementType.isBaseType() && BaseTypeBinding.isWidening(elementType.id, expressionType.id)))", "+\t\t\t\t\t\t|| expressionType.isCompatibleWith(elementType)) {", "+\t\t\t\t\texpression.computeConversion(scope, elementType, expressionType);", "+\t\t\t\t} else if (scope.isBoxingCompatibleWith(expressionType, elementType) ", "+\t\t\t\t\t\t\t\t\t|| (expressionType.isBaseType()  // narrowing then boxing ?", "-\t\t\t\t\t\t\t\t\t\t\t&& expression.isConstantValueOfTypeAssignableToType(exprType, scope.environment().computeBoxingType(elementType)))) {", "-\t\t\t\t\texpression.computeConversion(scope, elementType, exprType);", "+\t\t\t\t\t\t\t\t\t\t\t&& expression.isConstantValueOfTypeAssignableToType(expressionType, scope.environment().computeBoxingType(elementType)))) {", "+\t\t\t\t\texpression.computeConversion(scope, elementType, expressionType);", "-\t\t\t\t\tscope.problemReporter().typeMismatchError(exprType, elementType, expression);", "-\t\t\t\t\treturn null;", "+\t\t\t\t\tscope.problemReporter().typeMismatchError(expressionType, elementType, expression);"]}], "num": 58209}