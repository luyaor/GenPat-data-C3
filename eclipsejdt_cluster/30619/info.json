{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1f4b140055b55fae374d4935e13d6ae8", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0a9e06820aab3b54f6476fa73ee683fe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsMassiveTests.java", "commitBeforeChange": "7a24b5673519868b3d216b53b0f32f47ba6cb3b0", "commitAfterChange": "07f0481ff2b1a4347f81b0851eed1d1f6479507f", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": "  String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator)", "signatureAfterChange": "  String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator)", "diff": ["+\t\tString previousResult = result;", "-\t\t\tString newResult = org.eclipse.jdt.internal.core.util.Util.editedString(result, edit);", "-\t\t\tif (!result.equals(newResult)) {", "-\t\t\t\tswitch (IGNORE_SPACES) {", "-\t\t\t\t\tcase ALL_SPACES:", "-\t\t\t\t\t\tString trimmedExpected = ModelTestsUtil.removeWhiteSpace(result);", "-\t\t\t\t\t\tString trimmedActual= ModelTestsUtil.removeWhiteSpace(newResult);", "-\t\t\t\t\t\tif (trimmedExpected.equals(trimmedActual)) {", "-\t\t\t\t\t\t\tthis.whitespacesFailures.add(this.path);", "-\t\t\t\t\t\t\tthis.hasSpaceFailure = true;", "-\t\t\t\t\t\t\treturn result;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase LINES_LEADING_SPACES:", "-\t\t\t\t\t\ttrimmedExpected = ModelTestsUtil.trimLinesLeadingWhitespaces(result);", "-\t\t\t\t\t\ttrimmedActual= ModelTestsUtil.trimLinesLeadingWhitespaces(newResult);", "-\t\t\t\t\t\tif (trimmedExpected.equals(trimmedActual)) {", "-\t\t\t\t\t\t\tthis.leadingWhitespacesFailures.add(this.path);", "-\t\t\t\t\t\t\tthis.hasSpaceFailure = true;", "-\t\t\t\t\t\t\treturn result;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (ModelTestsUtil.removeWhiteSpace(result).equals(ModelTestsUtil.removeWhiteSpace(newResult))) {", "-\t\t\t\t\t\t\tthis.whitespacesFailures.add(this.path);", "-\t\t\t\t\t\t\tthis.hasSpaceFailure = true;", "-\t\t\t\t\t\t\treturn result;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\ttrimmedExpected = filterFormattingInComments(result);", "-\t\t\t\t\t\ttrimmedActual= filterFormattingInComments(newResult);", "-\t\t\t\t\t\tif (trimmedExpected.equals(trimmedActual)) {", "-\t\t\t\t\t\t\tthis.whitespacesFailures.add(this.path);", "-\t\t\t\t\t\t\tthis.hasSpaceFailure = true;", "-\t\t\t\t\t\t\treturn result;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\tif (!isExpectedFailure()) {", "-\t\t\t\t\tassertSourceEquals(\"2nd formatting is different from first one!\", Util.convertToIndependantLineDelimiter(result), Util.convertToIndependantLineDelimiter(newResult));", "-\t\t\t\t}", "+\t\t\tpreviousResult = result;", "+\t\t\tresult = org.eclipse.jdt.internal.core.util.Util.editedString(result, edit);", "+\t\t}", "+\t\tif (!previousResult.equals(result)) {", "+\t\t\tswitch (IGNORE_SPACES) {", "+\t\t\t\tcase ALL_SPACES:", "+\t\t\t\t\tString trimmedExpected = ModelTestsUtil.removeWhiteSpace(previousResult);", "+\t\t\t\t\tString trimmedActual= ModelTestsUtil.removeWhiteSpace(result);", "+\t\t\t\t\tif (trimmedExpected.equals(trimmedActual)) {", "+\t\t\t\t\t\tthis.whitespacesFailures.add(this.path);", "+\t\t\t\t\t\tthis.hasSpaceFailure = true;", "+\t\t\t\t\t\treturn previousResult;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase LINES_LEADING_SPACES:", "+\t\t\t\t\ttrimmedExpected = ModelTestsUtil.trimLinesLeadingWhitespaces(previousResult);", "+\t\t\t\t\ttrimmedActual= ModelTestsUtil.trimLinesLeadingWhitespaces(result);", "+\t\t\t\t\tif (trimmedExpected.equals(trimmedActual)) {", "+\t\t\t\t\t\tthis.leadingWhitespacesFailures.add(this.path);", "+\t\t\t\t\t\tthis.hasSpaceFailure = true;", "+\t\t\t\t\t\treturn previousResult;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (ModelTestsUtil.removeWhiteSpace(previousResult).equals(ModelTestsUtil.removeWhiteSpace(result))) {", "+\t\t\t\t\t\tthis.whitespacesFailures.add(this.path);", "+\t\t\t\t\t\tthis.hasSpaceFailure = true;", "+\t\t\t\t\t\treturn previousResult;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\ttrimmedExpected = filterFormattingInComments(previousResult);", "+\t\t\t\t\ttrimmedActual= filterFormattingInComments(result);", "+\t\t\t\t\tif (trimmedExpected.equals(trimmedActual)) {", "+\t\t\t\t\t\tthis.whitespacesFailures.add(this.path);", "+\t\t\t\t\t\tthis.hasSpaceFailure = true;", "+\t\t\t\t\t\treturn previousResult;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\tif (!isExpectedFailure()) {", "+\t\t\t\tString counterString = counterToString(count);", "+\t\t\t\tassertSourceEquals(counterString+\" formatting is different from first one!\", Util.convertToIndependantLineDelimiter(previousResult), Util.convertToIndependantLineDelimiter(result));", "+\t\t\t}", "+\t\t\tresult = previousResult;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c08b47df009d0b1e61a7b641ab064205", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "875cc8d42787c90738d8dc077a25eb401e9e38f9", "commitAfterChange": "adfd584faf146517cb3e86f9f2b585f2851a3630", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 10, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["-\t\t\t\t\tif (inheritedMethod != null && areParametersEqual(currentMethod, inheritedMethod)) {", "-\t\t\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "+\t\t\t\t\tif (inheritedMethod != null) {", "+\t\t\t\t\t\tinheritedMethod = computeSubstituteMethod(inheritedMethod, currentMethod);", "+\t\t\t\t\t\tif (areMethodsEqual(currentMethod, inheritedMethod)) {", "+\t\t\t\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "+\t\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "+\t\t\t\t\t\t}", "-\t\t\t\t\tthis.checkAgainstInheritedMethods(currentMethod, matchingInherited, index + 1); // pass in the length of matching", "+\t\t\t\t\tcheckAgainstInheritedMethods(currentMethod, matchingInherited, index + 1); // pass in the length of matching", "-\t\t\t\t\tif (inherited[j] != null && areParametersEqual(inheritedMethod, inherited[j])) {", "-\t\t\t\t\t\tmatchingInherited[++index] = inherited[j];", "-\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "+\t\t\t\t\tMethodBinding otherInheritedMethod = inherited[j];", "+\t\t\t\t\tif (otherInheritedMethod != null && otherInheritedMethod.declaringClass != inheritedMethod.declaringClass) { // must be from a different class for their params to be equal", "+\t\t\t\t\t\totherInheritedMethod = computeSubstituteMethod(otherInheritedMethod, inheritedMethod);", "+\t\t\t\t\t\tif (areMethodsEqual(inheritedMethod, otherInheritedMethod)) {", "+\t\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "+\t\t\t\t\t\t\tinherited[j] = null; // do not want to find it again", "+\t\t\t\t\t\t}", "-\t\t\t\tthis.checkInheritedMethods(matchingInherited, index + 1); // pass in the length of matching", "+\t\t\t\tcheckInheritedMethods(matchingInherited, index + 1); // pass in the length of matching"]}], "num": 30619}