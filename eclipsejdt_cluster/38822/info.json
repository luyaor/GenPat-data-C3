{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8a0095cba43c1948f650d833be824522", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3d48cbd40a31df5e3947d4711241e4fb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "9fa4ee2d52d7a35a0c57f8c4b875f0f155754f75", "commitAfterChange": "330462fa1b1e3cc7e6b257e0a0f3470535bf4f54", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic static SearchPattern createPattern(IJavaElement element, int limitTo)", "signatureAfterChange": " \tpublic static SearchPattern createPattern(IJavaElement element, int limitTo, int matchRule)", "diff": ["+\t */", "+\tpublic static SearchPattern createPattern(IJavaElement element, int limitTo, int matchRule) {", "-\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\tsearchPattern = createPackagePattern(elementName.substring(0, lastDot), limitTo, R_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\tsearchPattern = createPackagePattern(elementName.substring(0, lastDot), limitTo, matchRule);", "+\t\t\t\t\t\t\tfalse, // does not need signature", "-\t\t\t\t\t\t\tfalse,", "-\t\t\t\t\t\t\tlimitTo);", "+\t\t\t\t\t\t\tlimitTo,", "+\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\t\tmatchRule);", "-\t\t\t\t\t\t\t\t\tR_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\t\t\t\t\t\tmatchRule);", "+\t\t\t\t\t\t\ttrue, // need signature", "-\t\t\t\t\t\t\ttrue, /* generic type */", "-\t\t\t\t\t\t\tlimitTo);", "+\t\t\t\t\t\t\tlimitTo,", "+\t\t\t\t\t\t\tmatchRule);", "+\t\t\t\tif (searchPattern == null) { // TODO (frederic) remove when new API IType.getParameterizedName() will be available", "+\t\t\t\t\tsearchPattern = new TypeReferencePattern(", "+\t\t\t\t\t\tCharOperation.concatWith(type.getPackageFragment().getElementName().toCharArray(), enclosingTypeNames(type), '.'), ", "+\t\t\t\t\t\ttype.getElementName().toCharArray(),", "+\t\t\t\t\t\ttype,", "+\t\t\t\t\t\tmatchRule);", "+\t\t\t\t}", "-\t\t\t\tsearchPattern = createPackagePattern(element.getElementName(), limitTo, R_EXACT_MATCH | R_CASE_SENSITIVE);", "+\t\t\t\tsearchPattern = createPackagePattern(element.getElementName(), limitTo, matchRule);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "425d3862527f7f8ace951347dcc0872d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "de0f1812a2159827ab464df5cef59ee9edaa3ab7", "commitAfterChange": "52749e60066d0fcd4c1a6df86d6646106f09eae5", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \t \tvoid checkMemberValues(MemberValuePair[] valuePairs, Scope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t", "+\tpublic TypeBinding resolveType(BlockScope scope) {", "+\t\t", "+\t\tTypeBinding typeBinding = this.type.resolveType(scope);", "+\t\tif (typeBinding == null)", "+\t\tthis.resolvedType = typeBinding;", "+\t\tif (!typeBinding.isAnnotationType()) {", "+\t\t\tscope.problemReporter().typeMismatchError(typeBinding, scope.getJavaLangAnnotationAnnotation(), this.type);", "-\t", "-\tvoid checkMemberValues(MemberValuePair[] valuePairs, Scope scope) {", "-\t\t", "+", "-\t\tTypeBinding expectedValueType = null;", "+\t\tMemberValuePair[] valuePairs = memberValuePairs();", "-\t\t\t\t\tExpression memberValue = valuePair.value;", "-\t\t\t\t\texpectedValueType = method.returnType;", "-\t\t\t\t\tmemberValue.setExpectedType(expectedValueType); // needed in case of generic method invocation", "-\t\t\t\t\tTypeBinding valueType = scope instanceof ClassScope", "-\t\t\t\t\t\t? memberValue.resolveType((ClassScope)scope)", "-\t\t\t\t\t\t: memberValue.resolveType((BlockScope)scope);", "-\t\t\t\t\tif (expectedValueType == null || valueType == null)", "-\t\t\t\t\t\tcontinue nextPair;", "-", "-\t\t\t\t\tcheckAnnotationValue(expectedValueType, method.declaringClass, method.selector, memberValue, scope);", "+\t\t\t\t\tvaluePair.resolveTypeExpecting(scope, method.returnType);", "-\t}", "+\t\treturn this.resolvedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b19eaa84659784a500f1238490df8d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "4d657d16dcce8d103534cfb60b4be82696664aa1", "commitAfterChange": "497330b1202ed51ff374b68cee6dd523314e3109", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tprotected String encodeClasspath(IClasspathEntry[] classpath, IPath outputLocation, boolean useLineSeparator) throws JavaModelException", "signatureAfterChange": " \tprotected String encodeClasspath(IClasspathEntry[] classpath, IPath outputLocation, boolean indent) throws JavaModelException", "diff": ["-\tprotected String encodeClasspath(IClasspathEntry[] classpath, IPath outputLocation, boolean useLineSeparator) throws JavaModelException {", "-", "-\t\tDocument document = new DocumentImpl();", "-\t\tElement cpElement = document.createElement(\"classpath\"); //$NON-NLS-1$", "-\t\tdocument.appendChild(cpElement);", "-", "-\t\tfor (int i = 0; i < classpath.length; ++i) {", "-\t\t\tcpElement.appendChild(((ClasspathEntry)classpath[i]).elementEncode(document, getProject().getFullPath()));", "-\t\t}", "-", "-\t\tif (outputLocation != null) {", "-\t\t\toutputLocation = outputLocation.removeFirstSegments(1);", "-\t\t\toutputLocation = outputLocation.makeRelative();", "-\t\t\tElement oElement = document.createElement(\"classpathentry\"); //$NON-NLS-1$", "-\t\t\toElement.setAttribute(\"kind\", ClasspathEntry.kindToString(ClasspathEntry.K_OUTPUT));\t//$NON-NLS-1$", "-\t\t\toElement.setAttribute(\"path\", outputLocation.toString()); //$NON-NLS-1$", "-\t\t\tcpElement.appendChild(oElement);", "-\t\t}", "-", "-\t\t// produce a String output", "+\tprotected String encodeClasspath(IClasspathEntry[] classpath, IPath outputLocation, boolean indent) throws JavaModelException {", "-\t\t\tOutputFormat format = new OutputFormat();", "-\t\t\tif (useLineSeparator) {", "-\t\t\t\tformat.setIndenting(true);", "-\t\t\t\tformat.setLineSeparator(System.getProperty(\"line.separator\"));  //$NON-NLS-1$", "-\t\t\t} else {", "-\t\t\t\tformat.setPreserveSpace(true);", "-\t\t\t}\t\t\t", "-\t\t\tSerializer serializer =", "-\t\t\t\tSerializerFactory.getSerializerFactory(Method.XML).makeSerializer(", "-\t\t\t\t\tnew OutputStreamWriter(s, \"UTF8\"), //$NON-NLS-1$", "-\t\t\t\t\tformat);", "-\t\t\tserializer.asDOMSerializer().serialize(document);", "-\t\t\treturn s.toString(\"UTF8\"); //$NON-NLS-1$", "+\t\t\tOutputStreamWriter writer = new OutputStreamWriter(s, \"UTF8\"); //$NON-NLS-1$", "+\t\t\tXMLWriter xmlWriter = new XMLWriter(writer);", "+\t\t\t", "+\t\t\txmlWriter.startTag(\"classpath\", indent); //$NON-NLS-1$", "+\t\t\tfor (int i = 0; i < classpath.length; ++i) {", "+\t\t\t\t((ClasspathEntry)classpath[i]).elementEncode(xmlWriter, getProject().getFullPath(), indent, true);", "+\t\t\t}", "+\t", "+\t\t\tif (outputLocation != null) {", "+\t\t\t\toutputLocation = outputLocation.removeFirstSegments(1);", "+\t\t\t\toutputLocation = outputLocation.makeRelative();", "+\t\t\t\tHashMap parameters = new HashMap();", "+\t\t\t\tparameters.put(\"kind\", ClasspathEntry.kindToString(ClasspathEntry.K_OUTPUT));//$NON-NLS-1$", "+\t\t\t\tparameters.put(\"path\", String.valueOf(outputLocation));//$NON-NLS-1$", "+\t\t\t\txmlWriter.printTag(\"classpathentry\", parameters, indent, true, true);//$NON-NLS-1$", "+\t\t\t}", "+\t", "+\t\t\txmlWriter.endTag(\"classpath\", indent);//$NON-NLS-1$", "+\t\t\twriter.flush();", "+\t\t\twriter.close();", "+\t\t\tSystem.out.println(s.toString(\"UTF8\"));//$NON-NLS-1$", "+\t\t\treturn s.toString(\"UTF8\");//$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85704ad57451a0264ff13d364f3c68f1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "64c79aaade93cc6bf9061f58a0917e55ce5f44d7", "commitAfterChange": "0f30dd165e42ed7c89f5ae15972d54606f639fe9", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " public void checkAnnotation()", "signatureAfterChange": " public void checkAnnotation()", "diff": ["-\t\tflushAnnotationsDefinedPriorTo(endStatementPosition); // discard obsolete comments", "+\t\tflushAnnotationsDefinedPriorTo(endStatementPosition); // discard obsolete comments during recovery", "-\tboolean deprecated = false;", "-\tboolean checkDeprecated = false;", "-\tint lastAnnotationIndex = -1;", "-", "-\t//since jdk1.2 look only in the last java doc comment...", "-\tnextComment : for (lastAnnotationIndex = scanner.commentPtr; lastAnnotationIndex >= 0; lastAnnotationIndex--){", "-\t\t//look for @deprecated into the first javadoc comment preceeding the declaration", "-\t\tint commentSourceStart = scanner.commentStarts[lastAnnotationIndex];", "-\t\t// javadoc only (non javadoc comment have negative end positions.)", "-\t\tif (modifiersSourceStart != -1 && modifiersSourceStart < commentSourceStart) {", "-\t\t\tcontinue nextComment;", "+\t", "+\tint lastComment = this.scanner.commentPtr;", "+\t", "+\tif (this.modifiersSourceStart >= 0) {", "+\t\t// eliminate comments located after modifierSourceStart if positionned", "+\t\twhile (lastComment >= 0 && this.scanner.commentStarts[lastComment] > modifiersSourceStart) lastComment--;", "+\t}", "+\tif (lastComment >= 0) {", "+\t\t// consider all remaining leading comments to be part of current declaration", "+\t\tthis.modifiersSourceStart = scanner.commentStarts[0]; ", "+\t", "+\t\t// check deprecation in last comment if javadoc \t", "+\t\tif (this.scanner.commentStops[lastComment] > 0) { \t// non javadoc comment have negative end positions", "+\t\t\tif (checkDeprecation(", "+\t\t\t\t\tthis.scanner.commentStarts[lastComment],", "+\t\t\t\t\tthis.scanner.commentStops[lastComment] - 1, //stop is one over,", "+\t\t\t\t\tthis.scanner.source)) {", "+\t\t\t\tcheckAndSetModifiers(AccDeprecated);", "+\t\t\t}", "-\t\tif (scanner.commentStops[lastAnnotationIndex] < 0) {", "-\t\t\tcontinue nextComment;", "-\t\t}", "-\t\tcheckDeprecated = true;", "-\t\tint commentSourceEnd = scanner.commentStops[lastAnnotationIndex] - 1; //stop is one over", "-\t\tchar[] comment = scanner.source;", "-", "-\t\tdeprecated =", "-\t\t\tcheckDeprecation(", "-\t\t\t\tcommentSourceStart,", "-\t\t\t\tcommentSourceEnd,", "-\t\t\t\tcomment);", "-\t\tbreak nextComment;", "-\t}", "-\tif (deprecated) {", "-\t\tcheckAndSetModifiers(AccDeprecated);", "-\t}", "-\t// modify the modifier source start to point at the first comment", "-\tif (lastAnnotationIndex >= 0 && checkDeprecated) {", "-\t\tmodifiersSourceStart = scanner.commentStarts[lastAnnotationIndex]; "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b6194aef3aba52038c206fd762d548f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java", "commitBeforeChange": "d1246b4aff159c8bec10d39c7616aa371724fb25", "commitAfterChange": "3aaa02433bee6eae022db09efeb9fd0aba7da6a0", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 17, "signatureBeforeChange": "  \tprivate ASTNode parseSourceCode(ASTParser parser, int parserMode, boolean ignoreErrors)", "signatureAfterChange": "  \tprivate TextEdit internalFormatStatements(String source, int indentationLevel, String lineSeparator, ConstructorDeclaration constructorDeclaration, IRegion[] regions, boolean includeComments)", "diff": ["-\tprivate ASTNode parseSourceCode(ASTParser parser, int parserMode, boolean ignoreErrors) {", "-\t\tparser.setKind(parserMode);", "-\t\tparser.setSource(this.sourceArray);", "-\t\tASTNode astNode = parser.createAST(null);", "-\t\tif (ignoreErrors)", "-\t\t\treturn astNode;", "-\t\tboolean hasErrors = false;", "-\t\tCompilationUnit root = (CompilationUnit) astNode.getRoot();", "-\t\tfor (IProblem problem : root.getProblems()) {", "-\t\t\tif (problem.isError()) {", "-\t\t\t\thasErrors = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\treturn hasErrors ? null : astNode;", "+", "+\tprivate TextEdit internalFormatStatements(String source, int indentationLevel, String lineSeparator, ConstructorDeclaration constructorDeclaration, IRegion[] regions, boolean includeComments) {", "+\t\tif (lineSeparator != null) {", "+\t\t\tthis.preferences.line_separator = lineSeparator;", "+\t\t} else {", "+\t\t\tthis.preferences.line_separator = Util.LINE_SEPARATOR;", "+\t\t}", "+\t\tthis.preferences.initial_indentation_level = indentationLevel;", "+", "+\t\tthis.newCodeFormatter = new CodeFormatterVisitor(this.preferences, this.options, regions, this.codeSnippetParsingUtil, includeComments);", "+", "+\t\treturn this.newCodeFormatter.format(source, constructorDeclaration);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b75f4711da2c40c293da3a4ccbe103de", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "c2862088078b3d0bc7ba3af4b4865ffe4ca72da7", "commitAfterChange": "945521c99c895e07ea8e1e22071b43333b314109", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic FlowInfo analyseAssignment( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo, \t\tAssignment assignment, \t\tboolean isCompound)", "signatureAfterChange": " \tpublic FlowInfo analyseAssignment( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo, \t\tAssignment assignment, \t\tboolean isCompound)", "diff": ["-\t\tint indexOfFirstValueRequired = otherBindingsCount;", "-\t\twhile (indexOfFirstValueRequired > 0) {", "-\t\t\tFieldBinding otherBinding = otherBindings[indexOfFirstValueRequired - 1];", "-\t\t\tif (otherBinding.isStatic())", "-\t\t\t\tbreak; // no longer need any value before this point", "-\t\t\tindexOfFirstValueRequired--;", "-\t\t}", "-\t\tFieldBinding lastFieldBinding = null;", "-\t\tif ((bits & FIELD) != 0) {", "-\t\t\t// reading from a field", "-\t\t\t// check if final blank field", "-\t\t\tif ((lastFieldBinding = (FieldBinding) binding).isBlankFinal()", "-\t\t\t    && this.otherBindings != null // the last field binding is only assigned", "- \t\t\t\t&& currentScope.allowBlankFinalFieldAssignment(lastFieldBinding)) {", "-\t\t\t\tif (!flowInfo.isDefinitelyAssigned(lastFieldBinding)) {", "-\t\t\t\t\tcurrentScope.problemReporter().uninitializedBlankFinalField(", "-\t\t\t\t\t\tlastFieldBinding,", "-\t\t\t\t\t\tthis);", "+\t\tboolean needValue = otherBindingsCount == 0 || !this.otherBindings[0].isStatic();", "+\t\tswitch (bits & RestrictiveFlagMASK) {", "+\t\t\tcase FIELD : // reading a field", "+\t\t\t\tlastFieldBinding = (FieldBinding) binding;", "+\t\t\t\tif (needValue) {", "+\t\t\t\t\tmanageSyntheticReadAccessIfNecessary(currentScope, lastFieldBinding, this.actualReceiverType, 0);", "+\t\t\t\t}\t\t\t\t// check if final blank field", "+\t\t\t\tif (lastFieldBinding.isBlankFinal()", "+\t\t\t\t    && this.otherBindings != null // the last field binding is only assigned", "+\t \t\t\t\t&& currentScope.allowBlankFinalFieldAssignment(lastFieldBinding)) {", "+\t\t\t\t\tif (!flowInfo.isDefinitelyAssigned(lastFieldBinding)) {", "+\t\t\t\t\t\tcurrentScope.problemReporter().uninitializedBlankFinalField(", "+\t\t\t\t\t\t\tlastFieldBinding,", "+\t\t\t\t\t\t\tthis);", "+\t\t\t\t\t}", "-\t\t\t}", "-\t\t} else {", "-\t\t\tif ((bits & LOCAL) != 0) {", "+\t\t\t\tbreak;", "+\t\t\tcase LOCAL :", "-\t\t\t}", "-\t\tif (indexOfFirstValueRequired == 0) {", "+\t\t", "+\t\tif (needValue) {", "-\t\t\tint start = indexOfFirstValueRequired == 0 ? 0 : indexOfFirstValueRequired - 1;", "-\t\t\tfor (int i = start; i < otherBindingsCount; i++) {", "-\t\t\t\tif (lastFieldBinding != null) { // could be null if first was a local variable", "-\t\t\t\t\tTypeBinding lastReceiverType;", "-\t\t\t\t\tswitch(i){", "-\t\t\t\t\t\tcase 0 :", "-\t\t\t\t\t\t\tlastReceiverType = this.actualReceiverType;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase 1 :", "-\t\t\t\t\t\t\tlastReceiverType = ((VariableBinding)binding).type;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tdefault :", "-\t\t\t\t\t\t\tlastReceiverType = otherBindings[i-2].type;", "-\t\t\t\t\t}", "+\t\t\tfor (int i = 0; i < otherBindingsCount-1; i++) {", "+\t\t\t\tlastFieldBinding = otherBindings[i];", "+\t\t\t\tneedValue = !otherBindings[i+1].isStatic();", "+\t\t\t\tif (needValue) {", "-\t\t\t\t\t\tlastReceiverType,", "-\t\t\t\t\t\ti);", "+\t\t\t\t\t\ti == 0 ", "+\t\t\t\t\t\t\t? ((VariableBinding)binding).type", "+\t\t\t\t\t\t\t: otherBindings[i-1].type,", "+\t\t\t\t\t\ti + 1);", "-\t\t\t\tlastFieldBinding = otherBindings[i];", "+\t\t\tlastFieldBinding = otherBindings[otherBindingsCount-1];", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c3de2506a30efe139ad57de7dd5efdd9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceTests.java", "commitBeforeChange": "5281f7a1d02f4134760334f239cbffb833f0ed1c", "commitAfterChange": "b8222e0e4564cc4472bb2fdfd410e7de68bbf0fa", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprotected void setUp() throws Exception", "signatureAfterChange": "  \tprotected void setUp() throws Exception", "diff": ["-\t */", "+", "-\t\tthis.scenario = Performance.getDefault().getDefaultScenarioId(this);", "+", "+\t\t// Store scenario readable name", "+\t\tString scenario = Performance.getDefault().getDefaultScenarioId(this);", "+\t\tthis.scenarioReadableName = scenario.substring(scenario.lastIndexOf('.')+1, scenario.length()-2);", "+\t\tthis.scenarioShortName = this.scenarioReadableName.substring(this.scenarioReadableName.lastIndexOf('#')+5/*1+\"test\".length()*/, this.scenarioReadableName.length());", "+\t\tthis.scenarioComment = null;", "+", "+\t\t// Set testing environment if null", "-\t\t// Perform gc several times to be sure that it won't take time while executing current test", "-\t\tint iterations = 0;", "-\t\tlong delta;", "-\t\tdo {", "-\t\t\tlong free = Runtime.getRuntime().freeMemory();", "-\t\t\tSystem.gc();", "-\t\t\tdelta = Runtime.getRuntime().freeMemory() -free;", "-\t\t\tif (DEBUG) System.out.println(\"Loop gc \"+ ++iterations + \" (free=\"+free+\", delta=\"+delta+\")\");", "-\t\t\tThread.sleep(500);", "-\t\t} while (iterations<10 && delta>100);", "+\t\t", "+\t\t// Increment test position", "+\t\tTEST_POSITION++;"]}], "num": 38822}