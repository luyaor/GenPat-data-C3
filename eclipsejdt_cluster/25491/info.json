{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "84dbfcfb6c0ee9981b46b21293c503d5", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26c8de7a121b93c79333e6434edf372f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "031774399eed50847f433b5425b7551aed0c6cbc", "commitAfterChange": "30ba2db951e79b89a330e1209e461b1c083d6de3", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["-\t\treturn TypeBinding.NULL;", "+\t\tthis.scope = new MethodScope(blockScope, this, blockScope.methodScope().isStatic);", "+", "+\t\tTypeBinding expected = this.expectedType();", "+\t\tif (expected == null) return TypeBinding.NULL;", "+", "+\t\tMethodBinding singleAbstractMethod = expected.getSingleAbstractMethod();", "+\t\tif (this.arguments != null && singleAbstractMethod != null) {", "+\t\t\tint parameterCount = singleAbstractMethod.parameters != null ? singleAbstractMethod.parameters.length : 0;", "+\t\t\tint lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;", "+", "+\t\t\tif (parameterCount == lambdaArgumentCount) {", "+\t\t\t\tfor (int i = 0, length = this.arguments.length; i < length; i++) {", "+\t\t\t\t\tArgument argument = this.arguments[i];", "+\t\t\t\t\tif (argument.type != null) {", "+\t\t\t\t\t\targument.resolve(this.scope); // TODO: Check it!", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\targument.bind(this.scope, singleAbstractMethod.parameters[i], false);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} /* TODO: else complain */", "+\t\t}", "+\t\tif (this.body instanceof Expression) {", "+\t\t\tExpression expression = (Expression) this.body;", "+\t\t\tif (singleAbstractMethod != null) {", "+\t\t\t\texpression.setExpectedType(singleAbstractMethod.returnType); // chain expected type for any nested lambdas.", "+\t\t\t\t/* TypeBinding expressionType = */ expression.resolveType(this.scope);", "+\t\t\t\t// TODO: checkExpressionResult(singleAbstractMethod.returnType, expression, expressionType);", "+\t\t\t}", "+\t\t} else {", "+\t\t\tthis.body.resolve(this.scope);", "+\t\t}", "+\t\treturn expected;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "99aab4e14eb8c77dec6d4be0ea744966", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "ea916b0462fec6996e619f84c30f348e2877686a", "commitAfterChange": "558c64a899c0debc518d6eb92e85f37b05902eba", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["-\t\tTypeBinding expected = this.expectedType();", "-\t\tif (expected == null) return TypeBinding.NULL;", "+\t\tif (this.functionalInterfaceType.isValidBinding()) {", "+\t\t\t// Resolve arguments, validate signature ...", "+\t\t\tif (this.arguments != null && this.singleAbstractMethod != null) {", "+\t\t\t\tint parameterCount = this.singleAbstractMethod.parameters != null ? this.singleAbstractMethod.parameters.length : 0;", "+\t\t\t\tint lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;", "-\t\tMethodBinding singleAbstractMethod = expected.getSingleAbstractMethod();", "-\t\tif (this.arguments != null && singleAbstractMethod != null) {", "-\t\t\tint parameterCount = singleAbstractMethod.parameters != null ? singleAbstractMethod.parameters.length : 0;", "-\t\t\tint lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;", "-", "-\t\t\tif (parameterCount == lambdaArgumentCount) {", "-\t\t\t\tfor (int i = 0, length = this.arguments.length; i < length; i++) {", "-\t\t\t\t\tArgument argument = this.arguments[i];", "-\t\t\t\t\tif (argument.type != null) {", "-\t\t\t\t\t\targument.resolve(this.scope); // TODO: Check it!", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\targument.bind(this.scope, singleAbstractMethod.parameters[i], false);", "+\t\t\t\tif (parameterCount == lambdaArgumentCount) {", "+\t\t\t\t\tfor (int i = 0, length = this.arguments.length; i < length; i++) {", "+\t\t\t\t\t\tArgument argument = this.arguments[i];", "+\t\t\t\t\t\tif (argument.type != null) {", "+\t\t\t\t\t\t\targument.resolve(this.scope); // TODO: Check it!", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\targument.bind(this.scope, this.singleAbstractMethod.parameters[i], false);", "+\t\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} /* TODO: else complain */", "+\t\t\t\t} /* TODO: else complain */", "+\t\t\t}", "-\t\t\tif (singleAbstractMethod != null) {", "-\t\t\t\texpression.setExpectedType(singleAbstractMethod.returnType); // chain expected type for any nested lambdas.", "+\t\t\tif (this.functionalInterfaceType.isValidBinding()) {", "+\t\t\t\texpression.setExpectedType(this.singleAbstractMethod.returnType); // chain expected type for any nested lambdas.", "-\t\treturn expected;", "+\t\treturn this.functionalInterfaceType;"]}], "num": 25491}