{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0f0f949e8ac8b392e197089e50caf1fb", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e3e1d217829d92bb56eea1f1a43f3c5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "3363755daf5e11f7ba5c27ee1ed39285b9c60a26", "commitAfterChange": "b25ba34af45dc400b54fbb4a1c94812b44a4f39f", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "diff": ["-\tnextMethod : for (int i = 0, l = length - 1; i < l;) {", "-\t\tMethodBinding method = methods[i++];", "-\t\tfor (int j = i; j <= l; j++) {", "-\t\t\tif (method.declaringClass == methods[j].declaringClass && areMethodsEqual(method, methods[j])) {", "-\t\t\t\t// found an inherited ParameterizedType that defines duplicate methods", "-\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, method, methods[j]);", "-\t\t\t\tcount--;", "-\t\t\t\tmethods[i - 1] = null;", "-\t\t\t\tcontinue nextMethod;", "+\tint[] skip = new int[count];", "+\tnextMethod : for (int i = 0, l = length - 1; i < l; i++) {", "+\t\tif (skip[i] == -1) continue nextMethod;", "+\t\tMethodBinding method = methods[i];", "+\t\tMethodBinding[] duplicates = null;", "+\t\tfor (int j = i + 1; j <= l; j++) {", "+\t\t\tMethodBinding method2 = methods[j];", "+\t\t\tif (method.declaringClass == method2.declaringClass && areMethodsEqual(method, method2)) {", "+\t\t\t\tskip[j] = -1;", "+\t\t\t\tif (duplicates == null)", "+\t\t\t\t\tduplicates = new MethodBinding[length];", "+\t\t\t\tduplicates[j] = method2;", "+\t\t\t}", "+\t\t}", "+\t\tif (duplicates != null) {", "+\t\t\t// found an inherited ParameterizedType that defines duplicate methods", "+\t\t\t// if all methods are abstract or more than 1 concrete method exists, then consider them to be duplicates", "+\t\t\t// if a single concrete method 'implements' the abstract methods, then do not report a duplicate error", "+\t\t\tint concreteCount = method.isAbstract() ? 0 : 1;", "+\t\t\tMethodBinding methodToKeep = method; // if a concrete method exists, keep it, otherwise keep the first method", "+\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "+\t\t\t\tif (duplicates[m] != null) {", "+\t\t\t\t\tif (!duplicates[m].isAbstract()) {", "+\t\t\t\t\t\tmethodToKeep = duplicates[m];", "+\t\t\t\t\t\tconcreteCount++;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (concreteCount != 1) {", "+\t\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "+\t\t\t\t\tif (duplicates[m] != null) {", "+\t\t\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, method, duplicates[m]);", "+\t\t\t\t\t\tcount--;", "+\t\t\t\t\t\tif (methodToKeep == duplicates[m])", "+\t\t\t\t\t\t\tmethods[i] = null;", "+\t\t\t\t\t\telse", "+\t\t\t\t\t\t\tmethods[m] = null;", "+\t\t\t\t\t}", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9939059388de0f999f6cba6cfd303e81", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "6cbac45128bba7fa6d271bf8229dffb842e17b14", "commitAfterChange": "068cd980b5edbe213826c80d8c3fb1a72582288a", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " private TypeVariableBinding createTypeVariable(SignatureWrapper wrapper, int rank)", "signatureAfterChange": "  private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, Binding declaringElement)", "diff": ["-private TypeVariableBinding createTypeVariable(SignatureWrapper wrapper, int rank) {", "-\t// ParameterSignature = Identifier ':' TypeSignature", "-\t//   or Identifier ':' TypeSignature(optional) InterfaceBound(s)", "-\t// InterfaceBound = ':' TypeSignature", "-\tint colon = CharOperation.indexOf(':', wrapper.signature, wrapper.start);", "-\tchar[] variableName = CharOperation.subarray(wrapper.signature, wrapper.start, colon);", "-\tTypeVariableBinding variable = new TypeVariableBinding(variableName, this, rank);", "-\treturn variable;", "+", "+private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, Binding declaringElement) {", "+\t// detect all type variables first", "+\tchar[] typeSignature = wrapper.signature;", "+\tint depth = 0, length = typeSignature.length;", "+\tint rank = 0;", "+\tArrayList variables = new ArrayList(1);", "+\tdepth = 0;", "+\tboolean pendingVariable = true;", "+\tcreateVariables: {", "+\t\tfor (int i = 1; i < length; i++) {", "+\t\t\tswitch(typeSignature[i]) {", "+\t\t\t\tcase '<' : ", "+\t\t\t\t\tdepth++;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase '>' : ", "+\t\t\t\t\tif (--depth < 0)", "+\t\t\t\t\t\tbreak createVariables;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase ';' :", "+\t\t\t\t\tif ((depth == 0) && (i +1 < length) && (typeSignature[i+1] != ':'))", "+\t\t\t\t\t\tpendingVariable = true;", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tif (pendingVariable) {", "+\t\t\t\t\t\tpendingVariable = false;", "+\t\t\t\t\t\tint colon = CharOperation.indexOf(':', typeSignature, i);", "+\t\t\t\t\t\tchar[] variableName = CharOperation.subarray(typeSignature, i, colon);", "+\t\t\t\t\t\tvariables.add(new TypeVariableBinding(variableName, declaringElement, rank++));", "+\t\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\t// initialize type variable bounds - may refer to forward variables", "+\tTypeVariableBinding[] result;", "+\tvariables.toArray(result = new TypeVariableBinding[rank]);", "+\tfor (int i = 0; i < rank; i++) {", "+\t\tinitializeTypeVariable(result[i], result, wrapper);", "+\t}", "+\treturn result;"]}], "num": 68907}