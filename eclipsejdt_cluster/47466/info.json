{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "07757870b388176e6e322fb8b1107707", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "43873adcf94396a17cd1e34ffaaed167", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "cf895c35367340c7abd90778e60347850683ddea", "commitAfterChange": "04e1bf5f2770f9a2cdfb59f2c6a93389d529209c", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "signatureAfterChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "diff": ["+\t\t\t\t// build arguments names", "-\t\t\t\tnextMethod : for (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "-\t\t\t\t\tIBinaryMethod binaryMethod = methods[i];", "-\t\t\t\t\tchar[] selector = binaryMethod.isConstructor() ? type.getElementName().toCharArray() : binaryMethod.getSelector();", "-\t\t\t\t\tif (CharOperation.equals(selector, method.selector)) {", "-\t\t\t\t\t\tchar[] signature = binaryMethod.getGenericSignature();", "-\t\t\t\t\t\tif (signature == null) signature = binaryMethod.getMethodDescriptor();", "-\t\t\t\t\t\tchar[][] parameterTypes = Signature.getParameterTypes(signature);", "-\t\t\t\t\t\tif (argCount != parameterTypes.length) continue nextMethod;", "-\t\t\t\t\t\tif (arguments != null) {", "-\t\t\t\t\t\t\tfor (int j = 0; j < argCount; j++) {", "-\t\t\t\t\t\t\t\tchar[] typeName;", "-\t\t\t\t\t\t\t\tif (j == 0 && firstIsSynthetic) {", "-\t\t\t\t\t\t\t\t\ttypeName = type.getDeclaringType().getFullyQualifiedName().toCharArray();", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tTypeReference typeRef = arguments[firstIsSynthetic ? j - 1 : j].type;", "-\t\t\t\t\t\t\t\t\ttypeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "-\t\t\t\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "-\t\t\t\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tchar[] parameterTypeName = ClassFileMatchLocator.convertClassFileFormat(parameterTypes[j]);", "-\t\t\t\t\t\t\t\tif (!CharOperation.endsWith(Signature.toCharArray(Signature.getTypeErasure(parameterTypeName)), typeName))", "-\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn createMethodHandle(type, new String(selector), CharOperation.toStrings(parameterTypes));", "+\t\t\t\tchar[][] argumentTypeNames = new char[argCount][];", "+\t\t\t\tfor (int i = 0; i < argCount; i++) {", "+\t\t\t\t\tchar[] typeName = null;", "+\t\t\t\t\tif (i == 0 && firstIsSynthetic) {", "+\t\t\t\t\t\ttypeName = type.getDeclaringType().getFullyQualifiedName().toCharArray();", "+\t\t\t\t\t} else if (arguments != null) {", "+\t\t\t\t\t\tTypeReference typeRef = arguments[firstIsSynthetic ? i - 1 : i].type;", "+\t\t\t\t\t\ttypeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "+\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "+\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t\t\tif (typeName == null) {", "+\t\t\t\t\t\t// invalid type name", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "+\t\t\t\t\targumentTypeNames[i] = typeName;", "+\t\t\t\t", "+\t\t\t\t// return binary method", "+\t\t\t\treturn createBinaryMethodHandle(type, method.selector, argumentTypeNames);", "-//\t\t\tfor (int j = 0, dim = typeRef.dimensions(); j < dim; j++)", "-//\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e97e40558ef86780285ddecb1836fc9f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "875cc8d42787c90738d8dc077a25eb401e9e38f9", "commitAfterChange": "adfd584faf146517cb3e86f9f2b585f2851a3630", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 11, "signatureBeforeChange": " boolean isTypeSubstituable(TypeBinding one, TypeBinding two)", "signatureAfterChange": " boolean isInterfaceMethodImplemented(MethodBinding inheritedMethod, MethodBinding existingMethod, ReferenceBinding superType)", "diff": ["+boolean isInterfaceMethodImplemented(MethodBinding inheritedMethod, MethodBinding existingMethod, ReferenceBinding superType) {", "+\tinheritedMethod = computeSubstituteMethod(inheritedMethod, existingMethod);", "+\treturn inheritedMethod.returnType == existingMethod.returnType", "+\t\t&& super.isInterfaceMethodImplemented(inheritedMethod, existingMethod, superType);", "-boolean isTypeSubstituable(TypeBinding one, TypeBinding two) {", "-\tif (one == two) return true;", "-\tif (one.isArrayType() || two.isArrayType()) {", "-\t\tif (one.isArrayType() != two.isArrayType()) return false;", "-\t\tArrayBinding arrayOne = (ArrayBinding) one;", "-\t\tArrayBinding arrayTwo = (ArrayBinding) two;", "-\t\tif (arrayOne.dimensions != arrayTwo.dimensions) return false;", "-\t\tone = arrayOne.leafComponentType;", "-\t\ttwo = arrayTwo.leafComponentType;", "-\t}", "-\tif (one.isBaseType() || two.isBaseType()) return false;", "-", "-\tReferenceBinding subType = (ReferenceBinding) one;", "-\tReferenceBinding superType = (ReferenceBinding) two;", "-\tif (CharOperation.equals(subType.compoundName, superType.compoundName)) return true;", "-", "-\tsuperType = BinaryTypeBinding.resolveType(superType, this.environment, true);", "-\tsubType = BinaryTypeBinding.resolveType(subType, this.environment, true);", "-\tif (superType.isInterface())", "-\t\treturn subType.implementsInterface(superType, true);", "-\treturn isSameClassOrSubclassOf(subType, superType); // interfaces are subclasses of Object too", "-}"]}], "num": 47466}