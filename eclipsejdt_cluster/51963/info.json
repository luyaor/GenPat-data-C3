{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bdecb0e1ab6e372e2b35d01a8c6059a2", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8d80bf985d482553b15aaac6a1c01844", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "85d82ef92c86e257cfcb71c0ec95b6b64432a5cb", "commitAfterChange": "db5b57ec76798735e1deba7d6189161973304788", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+        if (scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled) {", "+        \tint len = this.descriptor.parameters.length;", "+    \t\tfor (int i = 0; i < len; i++) {", "+    \t\t\tBoolean declared = this.descriptor.parameterNonNullness == null ? null : this.descriptor.parameterNonNullness[i];", "+    \t\t\tBoolean implemented = this.binding.parameterNonNullness == null ? null : this.binding.parameterNonNullness[i];", "+    \t\t\tif (declared == Boolean.FALSE) { // promise to accept null", "+    \t\t\t\tif (implemented != Boolean.FALSE) {", "+    \t\t\t\t\tchar[][] requiredAnnot = implemented == null ? null : scope.environment().getNonNullAnnotationName();", "+    \t\t\t\t\tscope.problemReporter().parameterLackingNullableAnnotation(this, this.descriptor, i, ", "+    \t\t\t\t\t\t\tscope.environment().getNullableAnnotationName(),", "+    \t\t\t\t\t\t\trequiredAnnot, this.binding.parameters[i]);", "+    \t\t\t\t}", "+    \t\t\t} else if (declared == null) {", "+    \t\t\t\tif (implemented == Boolean.TRUE) {", "+    \t\t\t\t\tscope.problemReporter().parameterRequiresNonnull(this, this.descriptor, i,", "+    \t\t\t\t\t\t\tscope.environment().getNonNullAnnotationName(), this.binding.parameters[i]);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t}", "+        \tif ((this.descriptor.tagBits & TagBits.AnnotationNonNull) != 0) {", "+        \t\tif ((this.binding.tagBits & TagBits.AnnotationNonNull) == 0) {", "+        \t\t\tchar[][] providedAnnotationName = ((this.binding.tagBits & TagBits.AnnotationNullable) != 0) ?", "+        \t\t\t\t\tscope.environment().getNullableAnnotationName() : null;", "+        \t\t\tscope.problemReporter().illegalReturnRedefinition(this, this.descriptor,", "+        \t\t\t\t\tscope.environment().getNonNullAnnotationName(),", "+        \t\t\t\t\tprovidedAnnotationName, this.binding.returnType);", "+        \t\t}", "+        \t}", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c37ea218d9612f6a3e3129a7a8a48325", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["+\tTypeBinding[] argumentTypes = Binding.NO_PARAMETERS;", "-\t\tfor (int a = argsLength; --a >= 0;)", "-\t\t\tthis.arguments[a].resolveType(scope);", "+\t\tint length = this.arguments.length;", "+\t\targumentTypes = new TypeBinding[length];", "+\t\tfor (int a = argsLength; --a >= 0;) {", "+\t\t\targumentTypes[a] = this.arguments[a].resolveType(scope);", "+\t\t}", "-", "+\tfinal boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;", "+\t\tif (enclosingType == null) {", "+\t\t\t// try to propose something even if enclosing type cannot be resolved.", "+\t\t\t// Eg.: new Test<>().new Test<>(#cursor#", "+\t\t\tif (this.enclosingInstance instanceof AllocationExpression) {", "+\t\t\t\tTypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;", "+\t\t\t\tif (enclosingInstanceType != null) {", "+\t\t\t\t\tenclosingType = enclosingInstanceType.resolvedType;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(((ParameterizedTypeBinding) this.resolvedType).genericType(), null, argumentTypes, scope);", "+\t\t\tif (inferredTypes != null) {", "+\t\t\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t\t} else {", "+\t\t\t\t// inference failed. Resolved type will be of the form Test<>", "+\t\t\t\tthis.bits |= ASTNode.IsDiamond;", "+\t\t\t}", "+\t \t}", "-\t\tthis.resolvedType = this.type.resolveType(scope, true /* check bounds*/);", "+\t \tthis.resolvedType = this.type.resolveType(scope, true /* check bounds*/);", "+\t \tif (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(((ParameterizedTypeBinding) this.resolvedType).genericType(), null, argumentTypes, scope);", "+\t\t\tif (inferredTypes != null) {", "+\t\t\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t\t} else {", "+\t\t\t\t// inference failed. Resolved type will be of the form Test<>", "+\t\t\t\tthis.bits |= ASTNode.IsDiamond;", "+\t\t\t}", "+\t \t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fb7e8af762e424be5aa3b9caab32fd0a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "c7e61e314902d7cf48e71c1a1c0437bb40107c2e", "commitAfterChange": "8a1621e802c664e59aba36b8a87f59ae57902e37", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\t\t\tif ((sourceMethod.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {", "+\t\t\t\t\t\tlong nullBits = sourceMethod.tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\tif (nullBits == TagBits.AnnotationNullMASK) {", "-\t\t\t\t\t\t\tsourceMethod.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems", "+\t\t\t\t\t\t\tsourceMethod.tagBits &= ~TagBits.AnnotationNullMASK; // avoid secondary problems", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (nullBits != 0 && sourceMethod.isConstructor()) {", "+\t\t\t\t\t\t\tif (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8)", "+\t\t\t\t\t\t\t\tscope.problemReporter().nullAnnotationUnsupportedLocation(this);", "+\t\t\t\t\t\t\t// for declaration annotations the inapplicability will be reported below", "+\t\t\t\t\t\t\tsourceMethod.tagBits &= ~TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t// fields don't yet have their type resolved, in 1.8 null annotations", "+\t\t\t\t\t\t// will be transfered from the field to its type during STB.resolveTypeFor().", "-\t\t\t\t\t\tvariable.tagBits |= tagBits;", "+\t\t\t\t\t\tif ((annotationType.tagBits & TagBits.AnnotationTargetMASK) == TagBits.AnnotationForTypeUse) {", "+\t\t\t\t\t\t\tif (variable.type != null) {", "+\t\t\t\t\t\t\t\tif (variable.type.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().illegalAnnotationForBaseType(this, variable.type);", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tlong nullTagBits = tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\t\tvariable.type = scope.environment().createAnnotatedType(variable.type, nullTagBits);", "+\t\t\t\t\t\t\t\t\tif ((variable.type.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {", "+\t\t\t\t\t\t\t\t\t\tscope.problemReporter().contradictoryNullAnnotations(this);", "+\t\t\t\t\t\t\t\t\t\tvariable.type.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8) {", "+\t\t\t\t\t\t\t\tvariable.tagBits |= tagBits;", "+\t\t\t\t\t\t\t\tif ((variable.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().contradictoryNullAnnotations(this);", "+\t\t\t\t\t\t\t\t\tvariable.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if (variable.type != null) {", "+\t\t\t\t\t\t\t\t// bits not relating to null analysis go into the variable:", "+\t\t\t\t\t\t\t\tvariable.tagBits |= tagBits & ~TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\t// null bits go into the type:", "+\t\t\t\t\t\t\t\tlong nullTagBits = tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\tif (nullTagBits != 0) {", "+\t\t\t\t\t\t\t\t\tvariable.type = scope.environment().pushAnnotationIntoType(variable.type, variable.declaration.type, nullTagBits);", "+\t\t\t\t\t\t\t\t\tif ((variable.type.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {", "+\t\t\t\t\t\t\t\t\t\tscope.problemReporter().contradictoryNullAnnotations(this);", "+\t\t\t\t\t\t\t\t\t\tvariable.type = variable.type.unannotated();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif ((variable.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {", "-\t\t\t\t\t\t\tscope.problemReporter().contradictoryNullAnnotations(this);", "-\t\t\t\t\t\t\tvariable.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems"]}], "num": 51963}