{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8f2c764274ff9d0f088a0ff2caaedc7e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "13fb639f51c0200b50d0b5df9a15f8e4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "3a7eebe0921eeefbdbf1fe4891891b6335310197", "commitAfterChange": "e8aa72d0e85424c76c1185b7518db6803dde6255", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t public TypeBinding resolveType(BlockScope scope)", "diff": ["+\t", "+public TypeBinding resolveType(BlockScope scope) {", "+\tboolean leftIsCast, rightIsCast;", "+\tif ((leftIsCast = this.left instanceof CastExpression) == true) this.left.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\tTypeBinding leftType = this.left.resolveType(scope);", "+", "+\tif ((rightIsCast = this.right instanceof CastExpression) == true) this.right.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\tTypeBinding rightType = this.right.resolveType(scope);", "+", "+\t// use the id of the type to navigate into the table", "+\tif (leftType == null || rightType == null) {", "+\t\tthis.constant = Constant.NotAConstant;", "+\t\treturn null;", "+\t}", "+", "+\tint leftTypeID = leftType.id;", "+\tint rightTypeID = rightType.id;", "+", "+\t// autoboxing support", "+\tboolean use15specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\tif (use15specifics) {", "+\t\tif (!leftType.isBaseType() && rightTypeID != TypeIds.T_JavaLangString && rightTypeID != TypeIds.T_null) {", "+\t\t\tleftTypeID = scope.environment().computeBoxingType(leftType).id;", "+\t\t}", "+\t\tif (!rightType.isBaseType() && leftTypeID != TypeIds.T_JavaLangString && leftTypeID != TypeIds.T_null) {", "+\t\t\trightTypeID = scope.environment().computeBoxingType(rightType).id;", "-\t\t", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-", "-\t\tboolean leftIsCast, rightIsCast;", "-\t\tif ((leftIsCast = left instanceof CastExpression) == true) left.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\tTypeBinding leftType = left.resolveType(scope);", "-", "-\t\tif ((rightIsCast = right instanceof CastExpression) == true) right.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\tTypeBinding rightType = right.resolveType(scope);", "-", "-\t\t// use the id of the type to navigate into the table", "-\t\tif (leftType == null || rightType == null) {", "-\t\t\tconstant = Constant.NotAConstant;", "+\tif (leftTypeID > 15", "+\t\t|| rightTypeID > 15) { // must convert String + Object || Object + String", "+\t\tif (leftTypeID == TypeIds.T_JavaLangString) {", "+\t\t\trightTypeID = TypeIds.T_JavaLangObject;", "+\t\t} else if (rightTypeID == TypeIds.T_JavaLangString) {", "+\t\t\tleftTypeID = TypeIds.T_JavaLangObject;", "+\t\t} else {", "+\t\t\tthis.constant = Constant.NotAConstant;", "+\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-", "-\t\tint leftTypeID = leftType.id;", "-\t\tint rightTypeID = rightType.id;", "-", "-\t\t// autoboxing support", "-\t\tboolean use15specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "-\t\tif (use15specifics) {", "-\t\t\tif (!leftType.isBaseType() && rightTypeID != T_JavaLangString && rightTypeID != T_null) {", "-\t\t\t\tleftTypeID = scope.environment().computeBoxingType(leftType).id;", "-\t\t\t}", "-\t\t\tif (!rightType.isBaseType() && leftTypeID != T_JavaLangString && leftTypeID != T_null) {", "-\t\t\t\trightTypeID = scope.environment().computeBoxingType(rightType).id;", "+\t}", "+\tif (((this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) == OperatorIds.PLUS) {", "+\t\tif (leftTypeID == TypeIds.T_JavaLangString) {", "+\t\t\tthis.left.computeConversion(scope, leftType, leftType);", "+\t\t\tif (rightType.isArrayType() && ((ArrayBinding) rightType).elementsType() == TypeBinding.CHAR) {", "+\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(this.right);", "-\t\tif (leftTypeID > 15", "-\t\t\t|| rightTypeID > 15) { // must convert String + Object || Object + String", "-\t\t\tif (leftTypeID == T_JavaLangString) {", "-\t\t\t\trightTypeID = T_JavaLangObject;", "-\t\t\t} else if (rightTypeID == T_JavaLangString) {", "-\t\t\t\tleftTypeID = T_JavaLangObject;", "-\t\t\t} else {", "-\t\t\t\tconstant = Constant.NotAConstant;", "-\t\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-\t\t\t\treturn null;", "+\t\tif (rightTypeID == TypeIds.T_JavaLangString) {", "+\t\t\tthis.right.computeConversion(scope, rightType, rightType);", "+\t\t\tif (leftType.isArrayType() && ((ArrayBinding) leftType).elementsType() == TypeBinding.CHAR) {", "+\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(this.left);", "-\t\tif (((bits & OperatorMASK) >> OperatorSHIFT) == PLUS) {", "-\t\t\tif (leftTypeID == T_JavaLangString) {", "-\t\t\t\tthis.left.computeConversion(scope, leftType, leftType);", "-\t\t\t\tif (rightType.isArrayType() && ((ArrayBinding) rightType).elementsType() == TypeBinding.CHAR) {", "-\t\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(right);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (rightTypeID == T_JavaLangString) {", "-\t\t\t\tthis.right.computeConversion(scope, rightType, rightType);", "-\t\t\t\tif (leftType.isArrayType() && ((ArrayBinding) leftType).elementsType() == TypeBinding.CHAR) {", "-\t\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(left);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-", "-\t\t// the code is an int", "-\t\t// (cast)  left   Op (cast)  right --> result", "-\t\t//  0000   0000       0000   0000      0000", "-\t\t//  <<16   <<12       <<8    <<4       <<0", "-", "-\t\t// Don't test for result = 0. If it is zero, some more work is done.", "-\t\t// On the one hand when it is not zero (correct code) we avoid doing the test\t", "-\t\tint operator = (bits & OperatorMASK) >> OperatorSHIFT;", "-\t\tint operatorSignature = OperatorSignatures[operator][(leftTypeID << 4) + rightTypeID];", "-", "-\t\tleft.computeConversion(\tscope, \tTypeBinding.wellKnownType(scope, (operatorSignature >>> 16) & 0x0000F), leftType);", "-\t\tright.computeConversion(scope, TypeBinding.wellKnownType(scope, (operatorSignature >>> 8) & 0x0000F), rightType);", "-\t\tbits |= operatorSignature & 0xF;", "-\t\tswitch (operatorSignature & 0xF) { // record the current ReturnTypeID", "-\t\t\t// only switch on possible result type.....", "-\t\t\tcase T_boolean :", "-\t\t\t\tthis.resolvedType = TypeBinding.BOOLEAN;", "-\t\t\t\tbreak;", "-\t\t\tcase T_byte :", "-\t\t\t\tthis.resolvedType = TypeBinding.BYTE;", "-\t\t\t\tbreak;", "-\t\t\tcase T_char :", "-\t\t\t\tthis.resolvedType = TypeBinding.CHAR;", "-\t\t\t\tbreak;", "-\t\t\tcase T_double :", "-\t\t\t\tthis.resolvedType = TypeBinding.DOUBLE;", "-\t\t\t\tbreak;", "-\t\t\tcase T_float :", "-\t\t\t\tthis.resolvedType = TypeBinding.FLOAT;", "-\t\t\t\tbreak;", "-\t\t\tcase T_int :", "-\t\t\t\tthis.resolvedType = TypeBinding.INT;", "-\t\t\t\tbreak;", "-\t\t\tcase T_long :", "-\t\t\t\tthis.resolvedType = TypeBinding.LONG;", "-\t\t\t\tbreak;", "-\t\t\tcase T_JavaLangString :", "-\t\t\t\tthis.resolvedType = scope.getJavaLangString();", "-\t\t\t\tbreak;", "-\t\t\tdefault : //error........", "-\t\t\t\tconstant = Constant.NotAConstant;", "-\t\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-\t\t\t\treturn null;", "-\t\t}", "-", "-\t\t// check need for operand cast", "-\t\tif (leftIsCast || rightIsCast) {", "-\t\t\tCastExpression.checkNeedForArgumentCasts(scope, operator, operatorSignature, left, leftTypeID, leftIsCast, right, rightTypeID, rightIsCast);", "-\t\t}", "-\t\t// compute the constant when valid", "-\t\tcomputeConstant(scope, leftTypeID, rightTypeID);", "-\t\treturn this.resolvedType;", "+\t// the code is an int", "+\t// (cast)  left   Op (cast)  right --> result", "+\t//  0000   0000       0000   0000      0000", "+\t//  <<16   <<12       <<8    <<4       <<0", "+", "+\t// Don't test for result = 0. If it is zero, some more work is done.", "+\t// On the one hand when it is not zero (correct code) we avoid doing the test\t", "+\tint operator = (this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT;", "+\tint operatorSignature = OperatorExpression.OperatorSignatures[operator][(leftTypeID << 4) + rightTypeID];", "+", "+\tthis.left.computeConversion(scope, \tTypeBinding.wellKnownType(scope, (operatorSignature >>> 16) & 0x0000F), leftType);", "+\tthis.right.computeConversion(scope, TypeBinding.wellKnownType(scope, (operatorSignature >>> 8) & 0x0000F), rightType);", "+\tthis.bits |= operatorSignature & 0xF;", "+\tswitch (operatorSignature & 0xF) { // record the current ReturnTypeID", "+\t\t// only switch on possible result type.....", "+\t\tcase T_boolean :", "+\t\t\tthis.resolvedType = TypeBinding.BOOLEAN;", "+\t\t\tbreak;", "+\t\tcase T_byte :", "+\t\t\tthis.resolvedType = TypeBinding.BYTE;", "+\t\t\tbreak;", "+\t\tcase T_char :", "+\t\t\tthis.resolvedType = TypeBinding.CHAR;", "+\t\t\tbreak;", "+\t\tcase T_double :", "+\t\t\tthis.resolvedType = TypeBinding.DOUBLE;", "+\t\t\tbreak;", "+\t\tcase T_float :", "+\t\t\tthis.resolvedType = TypeBinding.FLOAT;", "+\t\t\tbreak;", "+\t\tcase T_int :", "+\t\t\tthis.resolvedType = TypeBinding.INT;", "+\t\t\tbreak;", "+\t\tcase T_long :", "+\t\t\tthis.resolvedType = TypeBinding.LONG;", "+\t\t\tbreak;", "+\t\tcase T_JavaLangString :", "+\t\t\tthis.resolvedType = scope.getJavaLangString();", "+\t\t\tbreak;", "+\t\tdefault : //error........", "+\t\t\tthis.constant = Constant.NotAConstant;", "+\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "+\t\t\treturn null;", "+", "+\t// check need for operand cast", "+\tif (leftIsCast || rightIsCast) {", "+\t\tCastExpression.checkNeedForArgumentCasts(scope, operator, operatorSignature, this.left, leftTypeID, leftIsCast, this.right, rightTypeID, rightIsCast);", "+\t}", "+\t// compute the constant when valid", "+\tcomputeConstant(scope, leftTypeID, rightTypeID);", "+\treturn this.resolvedType;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2030005bc02621bb1d1ee33662e834c2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 260, "methodNumberAfterChange": 260, "signatureBeforeChange": " public void recoveryTokenCheck()", "signatureAfterChange": " public void recoveryTokenCheck()", "diff": ["-\tswitch (currentToken) {", "+\tswitch (this.currentToken) {", "-\t\t\tif(!ignoreNextOpeningBrace) {", "-\t\t\t\tnewElement = currentElement.updateOnOpeningBrace(scanner.startPosition - 1, scanner.currentPosition - 1);", "+\t\t\tif(!this.ignoreNextOpeningBrace) {", "+\t\t\t\tnewElement = this.currentElement.updateOnOpeningBrace(this.scanner.startPosition - 1, this.scanner.currentPosition - 1);", "-\t\t\tlastCheckPoint = scanner.currentPosition;\t\t\t\t", "+\t\t\tthis.lastCheckPoint = this.scanner.currentPosition;\t\t\t\t", "-\t\t\t\trestartRecovery = true; // opening brace detected", "-\t\t\t\tcurrentElement = newElement;", "+\t\t\t\tthis.restartRecovery = true; // opening brace detected", "+\t\t\t\tthis.currentElement = newElement;", "-\t\t\tthis.rBraceStart = scanner.startPosition - 1;", "-\t\t\tthis.rBraceEnd = scanner.currentPosition - 1;", "-\t\t\tendPosition = this.flushCommentsDefinedPriorTo(this.rBraceEnd);", "+\t\t\tthis.rBraceStart = this.scanner.startPosition - 1;", "+\t\t\tthis.rBraceEnd = this.scanner.currentPosition - 1;", "+\t\t\tthis.endPosition = this.flushCommentsDefinedPriorTo(this.rBraceEnd);", "-\t\t\t\tcurrentElement.updateOnClosingBrace(scanner.startPosition, this.rBraceEnd);", "-\t\t\t\tlastCheckPoint = scanner.currentPosition;", "-\t\t\tif (newElement != currentElement){", "-\t\t\t\tcurrentElement = newElement;", "+\t\t\t\tthis.currentElement.updateOnClosingBrace(this.scanner.startPosition, this.rBraceEnd);", "+\t\t\t\tthis.lastCheckPoint = this.scanner.currentPosition;", "+\t\t\tif (newElement != this.currentElement){", "+\t\t\t\tthis.currentElement = newElement;", "-\t\t\tendStatementPosition = scanner.currentPosition - 1;", "-\t\t\tendPosition = scanner.startPosition - 1; ", "+\t\t\tthis.endStatementPosition = this.scanner.currentPosition - 1;", "+\t\t\tthis.endPosition = this.scanner.startPosition - 1; ", "-\t\t\tif (this.rBraceEnd > this.rBraceSuccessorStart && scanner.currentPosition != scanner.startPosition){", "-\t\t\t\tthis.rBraceSuccessorStart = scanner.startPosition;", "+\t\t\tif (this.rBraceEnd > this.rBraceSuccessorStart && this.scanner.currentPosition != this.scanner.startPosition){", "+\t\t\t\tthis.rBraceSuccessorStart = this.scanner.startPosition;", "-\tignoreNextOpeningBrace = false;", "+\tthis.ignoreNextOpeningBrace = false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "30ac8ccd443ce5035453d9d7f13debf3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "1b80cae94595518122618b458eed60915f76d171", "commitAfterChange": "92d6141bb346285ff13c588faa5a059cb9f83b3d", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tpreTryInitStateIndex =", "+\t\tthis.preTryInitStateIndex =", "-\t\tif (anyExceptionVariable != null) {", "-\t\t\tanyExceptionVariable.useFlag = LocalVariableBinding.USED;", "+\t\tif (this.anyExceptionVariable != null) {", "+\t\t\tthis.anyExceptionVariable.useFlag = LocalVariableBinding.USED;", "-\t\tif (returnAddressVariable != null) { // TODO (philippe) if subroutine is escaping, unused", "-\t\t\treturnAddressVariable.useFlag = LocalVariableBinding.USED;", "+\t\tif (this.returnAddressVariable != null) { // TODO (philippe) if subroutine is escaping, unused", "+\t\t\tthis.returnAddressVariable.useFlag = LocalVariableBinding.USED;", "-\t\tif (subRoutineStartLabel == null) {", "+\t\tif (this.subRoutineStartLabel == null) {", "-\t\t\t\tfinallyBlock", "+\t\t\t\tthis.finallyBlock", "-\t\t\t\t\t\tfinallyContext = new FinallyFlowContext(flowContext, finallyBlock),", "+\t\t\t\t\t\tfinallyContext = new FinallyFlowContext(flowContext, this.finallyBlock),", "-\t\t\t\tisSubRoutineEscaping = true;", "-\t\t\t\tscope.problemReporter().finallyMustCompleteNormally(finallyBlock);", "+\t\t\t\tthis.isSubRoutineEscaping = true;", "+\t\t\t\tthis.scope.problemReporter().finallyMustCompleteNormally(this.finallyBlock);", "-\t\t\t\ttryBlock,", "-\t\t\t\tcaughtExceptionTypes,", "-\t\t\t\tscope,", "+\t\t\t\tthis.tryBlock,", "+\t\t\t\tthis.caughtExceptionTypes,", "+\t\t\t\tthis.scope,", "-\t\tif (tryBlock.isEmptyBlock()) {", "+\t\tif (this.tryBlock.isEmptyBlock()) {", "-\t\t\ttryBlockExit = false;", "+\t\t\tthis.tryBlockExit = false;", "-\t\t\ttryInfo = tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "-\t\t\ttryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\tthis.tryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\thandlingContext.complainIfUnusedExceptionHandlers(scope, this);", "+\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "-\t\tif (catchArguments != null) {", "+\t\tif (this.catchArguments != null) {", "-\t\t\tcatchExits = new boolean[catchCount = catchBlocks.length];", "+\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "-\t\t\t\t\t\t\t\tcaughtExceptionTypes[i]))", "+\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "-\t\t\t\tLocalVariableBinding catchArg = catchArguments[i].binding;", "+\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\tif (tryBlock.statements == null) {", "+\t\t\t\tif (this.tryBlock.statements == null) {", "-\t\t\t\t\tcatchBlocks[i].analyseCode(", "+\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "-\t\t\t\tcatchExits[i] = ", "+\t\t\t\tthis.catchExits[i] = ", "-\t\tif (subRoutineStartLabel == null) {", "-\t\t\tmergedInitStateIndex =", "+\t\tif (this.subRoutineStartLabel == null) {", "+\t\t\tthis.mergedInitStateIndex =", "-\t\t\tmergedInitStateIndex =", "+\t\t\tthis.mergedInitStateIndex =", "-\t\t\tmergedInitStateIndex =", "+\t\t\tthis.mergedInitStateIndex ="]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "45ca6910641771c08f9c3c7f34ee9100", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 229, "methodNumberAfterChange": 229, "signatureBeforeChange": " protected boolean moveRecoveryCheckpoint()", "signatureAfterChange": " protected boolean moveRecoveryCheckpoint()", "diff": ["-\tint pos = lastCheckPoint;", "+\tint pos = this.lastCheckPoint;", "-\tscanner.startPosition = pos;", "-\tscanner.currentPosition = pos;", "-\tscanner.diet = false; // quit jumping over method bodies", "+\tthis.scanner.startPosition = pos;", "+\tthis.scanner.currentPosition = pos;", "+\tthis.scanner.diet = false; // quit jumping over method bodies", "-\tif (restartRecovery){", "-\t\tlastIgnoredToken = -1;", "-\t\tscanner.currentLine = null;", "+\tif (this.restartRecovery){", "+\t\tthis.lastIgnoredToken = -1;", "+\t\tthis.scanner.currentLine = null;", "-\tlastIgnoredToken = nextIgnoredToken;", "-\tnextIgnoredToken = -1;", "+\tthis.lastIgnoredToken = this.nextIgnoredToken;", "+\tthis.nextIgnoredToken = -1;", "-\t\t\tnextIgnoredToken = scanner.getNextToken();", "-\t\t\tif(scanner.currentPosition == scanner.startPosition){", "-\t\t\t\tscanner.currentPosition++; // on fake completion identifier", "-\t\t\t\tnextIgnoredToken = -1;", "+\t\t\tthis.nextIgnoredToken = this.scanner.getNextToken();", "+\t\t\tif(this.scanner.currentPosition == this.scanner.startPosition){", "+\t\t\t\tthis.scanner.currentPosition++; // on fake completion identifier", "+\t\t\t\tthis.nextIgnoredToken = -1;", "-\t\t\tpos = scanner.currentPosition;", "+\t\t\tpos = this.scanner.currentPosition;", "-\t} while (nextIgnoredToken < 0);", "+\t} while (this.nextIgnoredToken < 0);", "-\tif (nextIgnoredToken == TokenNameEOF) { // no more recovery after this point", "-\t\tif (currentToken == TokenNameEOF) { // already tried one iteration on EOF", "-\t\t\tscanner.currentLine = null;", "+\tif (this.nextIgnoredToken == TokenNameEOF) { // no more recovery after this point", "+\t\tif (this.currentToken == TokenNameEOF) { // already tried one iteration on EOF", "+\t\t\tthis.scanner.currentLine = null;", "-\tlastCheckPoint = scanner.currentPosition;", "+\tthis.lastCheckPoint = this.scanner.currentPosition;", "-\tscanner.startPosition = pos;", "-\tscanner.currentPosition = pos;", "-\tscanner.commentPtr = -1;", "-\tscanner.foundTaskCount = 0;", "-\tscanner.currentLine = null;", "+\tthis.scanner.startPosition = pos;", "+\tthis.scanner.currentPosition = pos;", "+\tthis.scanner.commentPtr = -1;", "+\tthis.scanner.foundTaskCount = 0;", "+\tthis.scanner.currentLine = null;", "-\tint pos = lastCheckPoint;", "+\tint pos = this.lastCheckPoint;", "-\tscanner.startPosition = pos;", "-\tscanner.currentPosition = pos;", "-\tscanner.diet = false; // quit jumping over method bodies", "+\tthis.scanner.startPosition = pos;", "+\tthis.scanner.currentPosition = pos;", "+\tthis.scanner.diet = false; // quit jumping over method bodies", "-\tif (restartRecovery){", "-\t\tlastIgnoredToken = -1;", "+\tif (this.restartRecovery){", "+\t\tthis.lastIgnoredToken = -1;", "-\tlastIgnoredToken = nextIgnoredToken;", "-\tnextIgnoredToken = -1;", "+\tthis.lastIgnoredToken = this.nextIgnoredToken;", "+\tthis.nextIgnoredToken = -1;", "-\tboolean wasTokenizingWhiteSpace = scanner.tokenizeWhiteSpace;", "-\tscanner.tokenizeWhiteSpace = true;", "+\tboolean wasTokenizingWhiteSpace = this.scanner.tokenizeWhiteSpace;", "+\tthis.scanner.tokenizeWhiteSpace = true;", "-\t\t\t\tnextIgnoredToken = scanner.getNextToken();", "-\t\t\t\tswitch(nextIgnoredToken){", "+\t\t\t\tthis.nextIgnoredToken = this.scanner.getNextToken();", "+\t\t\t\tswitch(this.nextIgnoredToken){", "-\t\t\t\t\t\tif(scanner.getLineNumber(scanner.startPosition)", "-\t\t\t\t\t\t\t== scanner.getLineNumber(scanner.currentPosition)){", "-\t\t\t\t\t\t\tnextIgnoredToken = -1;", "+\t\t\t\t\t\tif(this.scanner.getLineNumber(this.scanner.startPosition)", "+\t\t\t\t\t\t\t== this.scanner.getLineNumber(this.scanner.currentPosition)){", "+\t\t\t\t\t\t\tthis.nextIgnoredToken = -1;", "-\t\t\t\t\t\tif(scanner.currentPosition == scanner.startPosition){", "-\t\t\t\t\t\t\tscanner.currentPosition++; // on fake completion identifier", "+\t\t\t\t\t\tif(this.scanner.currentPosition == this.scanner.startPosition){", "+\t\t\t\t\t\t\tthis.scanner.currentPosition++; // on fake completion identifier", "-\t\t\t\t\t\tnextIgnoredToken = -1;", "+\t\t\t\t\t\tthis.nextIgnoredToken = -1;", "-\t\t\t\tpos = scanner.currentPosition;", "+\t\t\t\tpos = this.scanner.currentPosition;", "-\t\t} while (nextIgnoredToken < 0);", "-\tscanner.tokenizeWhiteSpace = wasTokenizingWhiteSpace;", "+\t\t} while (this.nextIgnoredToken < 0);", "+\tthis.scanner.tokenizeWhiteSpace = wasTokenizingWhiteSpace;", "-\tif (nextIgnoredToken == TokenNameEOF) { // no more recovery after this point", "-\t\tif (currentToken == TokenNameEOF) { // already tried one iteration on EOF", "+\tif (this.nextIgnoredToken == TokenNameEOF) { // no more recovery after this point", "+\t\tif (this.currentToken == TokenNameEOF) { // already tried one iteration on EOF", "-\tlastCheckPoint = scanner.currentPosition;", "+\tthis.lastCheckPoint = this.scanner.currentPosition;", "-\tscanner.startPosition = pos;", "-\tscanner.currentPosition = pos;", "-\tscanner.commentPtr = -1;", "+\tthis.scanner.startPosition = pos;", "+\tthis.scanner.currentPosition = pos;", "+\tthis.scanner.commentPtr = -1;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "59efd68e0855729bec8becba7c1b043d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "afcefcc52a6e235f9ed640317727929d84135cf0", "commitAfterChange": "5ce294a787e58643d5e8115fe2ddfea119e53aa2", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \tpublic void analyseCode( \t\tClassScope classScope, \t\tInitializationFlowContext initializerFlowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode)", "diff": ["+ */", "+public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode) {", "+\tif (this.ignoreFurtherInvestigation)", "+\t\treturn;", "+", "+\tint nonStaticFieldInfoReachMode = flowInfo.reachMode();", "+\tflowInfo.setReachMode(initialReachMode);", "-\tpublic void analyseCode(", "-\t\tClassScope classScope,", "-\t\tInitializationFlowContext initializerFlowContext,", "-\t\tFlowInfo flowInfo) {", "+\tif (this.binding != null && !this.binding.isUsed() && (this.binding.isPrivate() || (this.binding.declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType)) {", "+\t\tif (!classScope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "+\t\t\tthis.scope.problemReporter().unusedPrivateConstructor(this);", "+\t\t}", "+\t}", "+\t\t", "+\t// check constructor recursion, once all constructor got resolved", "+\tif (isRecursive(null /*lazy initialized visited list*/)) {\t\t\t\t", "+\t\tthis.scope.problemReporter().recursiveConstructorInvocation(this.constructorCall);", "+\t}", "+\t\t", "+\ttry {", "+\t\tExceptionHandlingFlowContext constructorContext =", "+\t\t\tnew ExceptionHandlingFlowContext(", "+\t\t\t\tinitializerFlowContext.parent,", "+\t\t\t\tthis,", "+\t\t\t\tthis.binding.thrownExceptions,", "+\t\t\t\tthis.scope,", "+\t\t\t\tFlowInfo.DEAD_END);", "+\t\tinitializerFlowContext.checkInitializerExceptions(", "+\t\t\tthis.scope,", "+\t\t\tconstructorContext,", "+\t\t\tflowInfo);", "-\t\tif (ignoreFurtherInvestigation)", "-\t\t\treturn;", "-", "-\t\tif (this.binding != null && !this.binding.isUsed() && (this.binding.isPrivate() || (this.binding.declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType)) {", "-\t\t\tif (!classScope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "-\t\t\t\tscope.problemReporter().unusedPrivateConstructor(this);", "+\t\t// anonymous constructor can gain extra thrown exceptions from unhandled ones", "+\t\tif (this.binding.declaringClass.isAnonymousType()) {", "+\t\t\tArrayList computedExceptions = constructorContext.extendedExceptions;", "+\t\t\tif (computedExceptions != null){", "+\t\t\t\tint size;", "+\t\t\t\tif ((size = computedExceptions.size()) > 0){", "+\t\t\t\t\tReferenceBinding[] actuallyThrownExceptions;", "+\t\t\t\t\tcomputedExceptions.toArray(actuallyThrownExceptions = new ReferenceBinding[size]);", "+\t\t\t\t\tthis.binding.thrownExceptions = actuallyThrownExceptions;", "+\t\t\t\t}", "-\t\t\t", "-\t\t// check constructor recursion, once all constructor got resolved", "-\t\tif (isRecursive(null /*lazy initialized visited list*/)) {\t\t\t\t", "-\t\t\tthis.scope.problemReporter().recursiveConstructorInvocation(this.constructorCall);", "+\t\t", "+\t\t// tag parameters as being set", "+\t\tif (this.arguments != null) {", "+\t\t\tfor (int i = 0, count = this.arguments.length; i < count; i++) {", "+\t\t\t\tflowInfo.markAsDefinitelyAssigned(this.arguments[i].binding);", "+\t\t\t}", "-\t\t\t", "-\t\ttry {", "-\t\t\tExceptionHandlingFlowContext constructorContext =", "-\t\t\t\tnew ExceptionHandlingFlowContext(", "-\t\t\t\t\tinitializerFlowContext.parent,", "-\t\t\t\t\tthis,", "-\t\t\t\t\tbinding.thrownExceptions,", "-\t\t\t\t\tscope,", "-\t\t\t\t\tFlowInfo.DEAD_END);", "-\t\t\tinitializerFlowContext.checkInitializerExceptions(", "-\t\t\t\tscope,", "-\t\t\t\tconstructorContext,", "-\t\t\t\tflowInfo);", "-", "-\t\t\t// anonymous constructor can gain extra thrown exceptions from unhandled ones", "-\t\t\tif (binding.declaringClass.isAnonymousType()) {", "-\t\t\t\tArrayList computedExceptions = constructorContext.extendedExceptions;", "-\t\t\t\tif (computedExceptions != null){", "-\t\t\t\t\tint size;", "-\t\t\t\t\tif ((size = computedExceptions.size()) > 0){", "-\t\t\t\t\t\tReferenceBinding[] actuallyThrownExceptions;", "-\t\t\t\t\t\tcomputedExceptions.toArray(actuallyThrownExceptions = new ReferenceBinding[size]);", "-\t\t\t\t\t\tbinding.thrownExceptions = actuallyThrownExceptions;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// tag parameters as being set", "-\t\t\tif (this.arguments != null) {", "-\t\t\t\tfor (int i = 0, count = this.arguments.length; i < count; i++) {", "-\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(this.arguments[i].binding);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// propagate to constructor call", "-\t\t\tif (constructorCall != null) {", "-\t\t\t\t// if calling 'this(...)', then flag all non-static fields as definitely", "-\t\t\t\t// set since they are supposed to be set inside other local constructor", "-\t\t\t\tif (constructorCall.accessMode == ExplicitConstructorCall.This) {", "-\t\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();", "-\t\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-\t\t\t\t\t\tFieldBinding field;", "-\t\t\t\t\t\tif (!(field = fields[i]).isStatic()) {", "-\t\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(field);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tflowInfo = constructorCall.analyseCode(scope, constructorContext, flowInfo);", "-\t\t\t}", "-\t\t\t// propagate to statements", "-\t\t\tif (statements != null) {", "-\t\t\t\tboolean didAlreadyComplain = false;", "-\t\t\t\tfor (int i = 0, count = statements.length; i < count; i++) {", "-\t\t\t\t\tStatement stat = statements[i];", "-\t\t\t\t\tif (!stat.complainIfUnreachable(flowInfo, scope, didAlreadyComplain)) {", "-\t\t\t\t\t\tflowInfo = stat.analyseCode(scope, constructorContext, flowInfo);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tdidAlreadyComplain = true;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// check for missing returning path", "-\t\t\tthis.needFreeReturn = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "-", "-", "-\t\t\t// check missing blank final field initializations", "-\t\t\tif ((constructorCall != null)", "-\t\t\t\t&& (constructorCall.accessMode != ExplicitConstructorCall.This)) {", "-\t\t\t\tflowInfo = flowInfo.mergedWith(constructorContext.initsOnReturn);", "-\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();", "+\t\t", "+\t\t// propagate to constructor call", "+\t\tif (this.constructorCall != null) {", "+\t\t\t// if calling 'this(...)', then flag all non-static fields as definitely", "+\t\t\t// set since they are supposed to be set inside other local constructor", "+\t\t\tif (this.constructorCall.accessMode == ExplicitConstructorCall.This) {", "+\t\t\t\tFieldBinding[] fields = this.binding.declaringClass.fields();", "-\t\t\t\t\tif ((!(field = fields[i]).isStatic())", "-\t\t\t\t\t\t&& field.isFinal()", "-\t\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {", "-\t\t\t\t\t\tscope.problemReporter().uninitializedBlankFinalField(", "-\t\t\t\t\t\t\tfield,", "-\t\t\t\t\t\t\tisDefaultConstructor ? (ASTNode) scope.referenceType() : this);", "+\t\t\t\t\tif (!(field = fields[i]).isStatic()) {", "+\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(field);", "-\t\t\t// check unreachable catch blocks", "-\t\t\tconstructorContext.complainIfUnusedExceptionHandlers(this);", "-\t\t} catch (AbortMethod e) {", "-\t\t\tthis.ignoreFurtherInvestigation = true;", "+\t\t\tflowInfo = this.constructorCall.analyseCode(this.scope, constructorContext, flowInfo);", "-\t}", "+\t\t// reuse the reachMode from non static field info", "+\t\tflowInfo.setReachMode(nonStaticFieldInfoReachMode);", "+", "+\t\t// propagate to statements", "+\t\tif (this.statements != null) {", "+\t\t\tboolean didAlreadyComplain = false;", "+\t\t\tfor (int i = 0, count = this.statements.length; i < count; i++) {", "+\t\t\t\tStatement stat = this.statements[i];", "+\t\t\t\tif (!stat.complainIfUnreachable(flowInfo, this.scope, didAlreadyComplain)) {", "+\t\t\t\t\tflowInfo = stat.analyseCode(this.scope, constructorContext, flowInfo);", "+\t\t\t\t} else {", "+\t\t\t\t\tdidAlreadyComplain = true;", "+\t\t\t}", "+\t\t}", "+\t\t// check for missing returning path", "+\t\tthis.needFreeReturn = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "+", "+\t\t// reuse the initial reach mode for diagnosing missing blank finals", "+\t\tflowInfo.setReachMode(initialReachMode);\t\t", "+", "+\t\t// check missing blank final field initializations", "+\t\tif ((this.constructorCall != null)", "+\t\t\t&& (this.constructorCall.accessMode != ExplicitConstructorCall.This)) {", "+\t\t\tflowInfo = flowInfo.mergedWith(constructorContext.initsOnReturn);", "+\t\t\tFieldBinding[] fields = this.binding.declaringClass.fields();", "+\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "+\t\t\t\tFieldBinding field;", "+\t\t\t\tif ((!(field = fields[i]).isStatic())", "+\t\t\t\t\t&& field.isFinal()", "+\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {", "+\t\t\t\t\tthis.scope.problemReporter().uninitializedBlankFinalField(", "+\t\t\t\t\t\tfield,", "+\t\t\t\t\t\tthis.isDefaultConstructor ? (ASTNode) this.scope.referenceType() : this);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t// check unreachable catch blocks", "+\t\tconstructorContext.complainIfUnusedExceptionHandlers(this);", "+\t} catch (AbortMethod e) {", "+\t\tthis.ignoreFurtherInvestigation = true;", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5af29c48ab6e90544d0e46988284ccaf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/BranchLabel.java", "commitBeforeChange": "b6af6dcd9d59b97edc4052f4f7dbcdc0b2982ddb", "commitAfterChange": "9d7258bf3ad30f4e44cac31c46a6f0a185b84bcd", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 9, "signatureBeforeChange": " public void place()", "signatureAfterChange": " public void place()", "diff": ["-\tif (CodeStream.DEBUG) System.out.println(\"\\t\\t\\t\\t<place at: \"+codeStream.position+\" - \"+ this); //$NON-NLS-1$ //$NON-NLS-2$", "+\tif (CodeStream.DEBUG) System.out.println(\"\\t\\t\\t\\t<place at: \"+this.codeStream.position+\" - \"+ this); //$NON-NLS-1$ //$NON-NLS-2$", "-\tif (position == POS_NOT_SET) {", "-\t\tif ((this.tagBits & USED) != 0 || this.forwardReferenceCount != 0) {", "-\t\t\tthis.position = codeStream.getPosition();", "+\tif (this.position == Label.POS_NOT_SET) {", "+\t\tif ((this.tagBits & BranchLabel.USED) != 0 || this.forwardReferenceCount != 0) {", "+\t\t\tthis.position = this.codeStream.getPosition();", "-\t\t\tthis.position = codeStream.position;", "+\t\t\tthis.position = this.codeStream.position;", "-\t\tcodeStream.addLabel(this);", "-\t\tint oldPosition = position;", "+\t\tthis.codeStream.addLabel(this);", "+\t\tint oldPosition = this.position;", "-\t\tif (forwardReferenceCount != 0) {", "-\t\t\tisOptimizedBranch = (forwardReferences[forwardReferenceCount - 1] + 2 == position) && (codeStream.bCodeStream[codeStream.classFileOffset - 3] == Opcodes.OPC_goto);", "+\t\tif (this.forwardReferenceCount != 0) {", "+\t\t\tisOptimizedBranch = (this.forwardReferences[this.forwardReferenceCount - 1] + 2 == this.position) && (this.codeStream.bCodeStream[this.codeStream.classFileOffset - 3] == Opcodes.OPC_goto);", "-\t\t\t\tcodeStream.position = (position -= 3);", "-\t\t\t\tcodeStream.classFileOffset -= 3;", "-\t\t\t\tforwardReferenceCount--;", "+\t\t\t\tthis.codeStream.position = (this.position -= 3);", "+\t\t\t\tthis.codeStream.classFileOffset -= 3;", "+\t\t\t\tthis.forwardReferenceCount--;", "-\t\t\t\tint index = codeStream.pcToSourceMapSize - 2;", "-\t\t\t\tif (codeStream.lastEntryPC == oldPosition) {", "-\t\t\t\t\tcodeStream.lastEntryPC = position;", "+\t\t\t\tint index = this.codeStream.pcToSourceMapSize - 2;", "+\t\t\t\tif (this.codeStream.lastEntryPC == oldPosition) {", "+\t\t\t\t\tthis.codeStream.lastEntryPC = this.position;", "-\t\t\t\tif ((index >= 0) && (codeStream.pcToSourceMap[index] == position)) {", "-\t\t\t\t\tcodeStream.pcToSourceMapSize-=2;", "+\t\t\t\tif ((index >= 0) && (this.codeStream.pcToSourceMap[index] == this.position)) {", "+\t\t\t\t\tthis.codeStream.pcToSourceMapSize-=2;", "-\t\t\t\tif ((codeStream.generateAttributes & ClassFileConstants.ATTR_VARS) != 0) {", "-\t\t\t\t\tLocalVariableBinding locals[] = codeStream.locals;", "+\t\t\t\tif ((this.codeStream.generateAttributes & ClassFileConstants.ATTR_VARS) != 0) {", "+\t\t\t\t\tLocalVariableBinding locals[] = this.codeStream.locals;", "-\t\t\t\t\t\t\t\tlocal.initializationPCs[((local.initializationCount - 1) << 1) + 1] = position;", "+\t\t\t\t\t\t\t\tlocal.initializationPCs[((local.initializationCount - 1) << 1) + 1] = this.position;", "-\t\t\t\t\t\t\t\tlocal.initializationPCs[(local.initializationCount - 1) << 1] = position;", "+\t\t\t\t\t\t\t\tlocal.initializationPCs[(local.initializationCount - 1) << 1] = this.position;", "-\t\tfor (int i = 0; i < forwardReferenceCount; i++) {", "-\t\t\tcodeStream.writePosition(this, forwardReferences[i]);", "+\t\tfor (int i = 0; i < this.forwardReferenceCount; i++) {", "+\t\t\tthis.codeStream.writePosition(this, this.forwardReferences[i]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1829b6de2a9c7f4a1fc0f94a1332b24", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 47, "methodNumberAfterChange": 49, "signatureBeforeChange": " public String toString()", "signatureAfterChange": " public String toString()", "diff": ["-    if (id == TypeIds.NoId) ", "+    if (this.id == TypeIds.NoId) ", "-        buffer.append(id);", "+        buffer.append(this.id);", "-\tbuffer.append((compoundName != null) ? CharOperation.toString(compoundName) : \"UNNAMED TYPE\"); //$NON-NLS-1$", "+\tbuffer.append((this.compoundName != null) ? CharOperation.toString(this.compoundName) : \"UNNAMED TYPE\"); //$NON-NLS-1$", "-\tbuffer.append((superclass != null) ? superclass.debugName() : \"NULL TYPE\"); //$NON-NLS-1$", "+\tbuffer.append((this.superclass != null) ? this.superclass.debugName() : \"NULL TYPE\"); //$NON-NLS-1$", "-\tif (superInterfaces != null) {", "-\t\tif (superInterfaces != Binding.NO_SUPERINTERFACES) {", "+\tif (this.superInterfaces != null) {", "+\t\tif (this.superInterfaces != Binding.NO_SUPERINTERFACES) {", "-\t\t\tfor (int i = 0, length = superInterfaces.length; i < length; i++) {", "+\t\t\tfor (int i = 0, length = this.superInterfaces.length; i < length; i++) {", "-\t\t\t\tbuffer.append((superInterfaces[i] != null) ? superInterfaces[i].debugName() : \"NULL TYPE\"); //$NON-NLS-1$", "+\t\t\t\tbuffer.append((this.superInterfaces[i] != null) ? this.superInterfaces[i].debugName() : \"NULL TYPE\"); //$NON-NLS-1$", "-\tif (fields != null) {", "-\t\tif (fields != Binding.NO_FIELDS) {", "+\tif (this.fields != null) {", "+\t\tif (this.fields != Binding.NO_FIELDS) {", "-\t\t\tfor (int i = 0, length = fields.length; i < length; i++)", "-\t\t\t    buffer.append('\\n').append((fields[i] != null) ? fields[i].toString() : \"NULL FIELD\"); //$NON-NLS-1$ ", "+\t\t\tfor (int i = 0, length = this.fields.length; i < length; i++)", "+\t\t\t    buffer.append('\\n').append((this.fields[i] != null) ? this.fields[i].toString() : \"NULL FIELD\"); //$NON-NLS-1$ ", "-\tif (methods != null) {", "-\t\tif (methods != Binding.NO_METHODS) {", "+\tif (this.methods != null) {", "+\t\tif (this.methods != Binding.NO_METHODS) {", "-\t\t\tfor (int i = 0, length = methods.length; i < length; i++)", "-\t\t\t\tbuffer.append('\\n').append((methods[i] != null) ? methods[i].toString() : \"NULL METHOD\"); //$NON-NLS-1$", "+\t\t\tfor (int i = 0, length = this.methods.length; i < length; i++)", "+\t\t\t\tbuffer.append('\\n').append((this.methods[i] != null) ? this.methods[i].toString() : \"NULL METHOD\"); //$NON-NLS-1$", "-\tif (memberTypes != null) {", "-\t\tif (memberTypes != Binding.NO_MEMBER_TYPES) {", "+\tif (this.memberTypes != null) {", "+\t\tif (this.memberTypes != Binding.NO_MEMBER_TYPES) {", "-\t\t\tfor (int i = 0, length = memberTypes.length; i < length; i++)", "-\t\t\t\tbuffer.append('\\n').append((memberTypes[i] != null) ? memberTypes[i].toString() : \"NULL TYPE\"); //$NON-NLS-1$", "+\t\t\tfor (int i = 0, length = this.memberTypes.length; i < length; i++)", "+\t\t\t\tbuffer.append('\\n').append((this.memberTypes[i] != null) ? this.memberTypes[i].toString() : \"NULL TYPE\"); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fb39dc24a34ad0bd1dc904b623adcdb4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "1b80cae94595518122618b458eed60915f76d171", "commitAfterChange": "92d6141bb346285ff13c588faa5a059cb9f83b3d", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope upperScope)", "diff": ["-\t\tBlockScope tryScope = new BlockScope(scope);", "+\t\tBlockScope tryScope = new BlockScope(this.scope);", "-\t\tif (finallyBlock != null) {", "-\t\t\tif (finallyBlock.isEmptyBlock()) {", "-\t\t\t\tif ((finallyBlock.bits & UndocumentedEmptyBlock) != 0) {", "-\t\t\t\t\tscope.problemReporter().undocumentedEmptyBlock(finallyBlock.sourceStart, finallyBlock.sourceEnd);", "+\t\tif (this.finallyBlock != null) {", "+\t\t\tif (this.finallyBlock.isEmptyBlock()) {", "+\t\t\t\tif ((this.finallyBlock.bits & ASTNode.UndocumentedEmptyBlock) != 0) {", "+\t\t\t\t\tthis.scope.problemReporter().undocumentedEmptyBlock(this.finallyBlock.sourceStart, this.finallyBlock.sourceEnd);", "-\t\t\t\tfinallyScope = new BlockScope(scope, false); // don't add it yet to parent scope", "+\t\t\t\tfinallyScope = new BlockScope(this.scope, false); // don't add it yet to parent scope", "-\t\t\t\tMethodScope methodScope = scope.methodScope();", "+\t\t\t\tMethodScope methodScope = this.scope.methodScope();", "-\t\t\t\t\t\tnew LocalVariableBinding(SecretReturnName, upperScope.getJavaLangObject(), ClassFileConstants.AccDefault, false);", "-\t\t\t\t\tfinallyScope.addLocalVariable(returnAddressVariable);", "+\t\t\t\t\t\tnew LocalVariableBinding(TryStatement.SecretReturnName, upperScope.getJavaLangObject(), ClassFileConstants.AccDefault, false);", "+\t\t\t\t\tfinallyScope.addLocalVariable(this.returnAddressVariable);", "-\t\t\t\t\tnew LocalVariableBinding(SecretAnyHandlerName, scope.getJavaLangThrowable(), ClassFileConstants.AccDefault, false);", "+\t\t\t\t\tnew LocalVariableBinding(TryStatement.SecretAnyHandlerName, this.scope.getJavaLangThrowable(), ClassFileConstants.AccDefault, false);", "-\t\t\t\t\t\tif (methodReturnType.id != T_void) {", "+\t\t\t\t\t\tif (methodReturnType.id != TypeIds.T_void) {", "-\t\t\t\t\t\t\t\t\tSecretLocalDeclarationName,", "+\t\t\t\t\t\t\t\t\tTryStatement.SecretLocalDeclarationName,", "-\t\t\t\tfinallyBlock.resolveUsing(finallyScope);", "+\t\t\t\tthis.finallyBlock.resolveUsing(finallyScope);", "-\t\t\t\tfinallyScope.shiftScopes = new BlockScope[catchArguments == null ? 1 : catchArguments.length+1];", "+\t\t\t\tfinallyScope.shiftScopes = new BlockScope[this.catchArguments == null ? 1 : this.catchArguments.length+1];", "-\t\t\t\tBlockScope catchScope = new BlockScope(scope);", "+\t\t\t\tBlockScope catchScope = new BlockScope(this.scope);", "-\t\t\t\tif ((argumentTypes[i] = catchArguments[i].resolveForCatch(catchScope)) == null) {", "+\t\t\t\tif ((argumentTypes[i] = this.catchArguments[i].resolveForCatch(catchScope)) == null) {", "-\t\t\t\tcatchBlocks[i].resolveUsing(catchScope);", "+\t\t\t\tthis.catchBlocks[i].resolveUsing(catchScope);", "-\t\t\t\tcaughtExceptionTypes[i] = (ReferenceBinding) argumentTypes[i];", "+\t\t\t\tthis.caughtExceptionTypes[i] = (ReferenceBinding) argumentTypes[i];", "-\t\t\t\t\tif (caughtExceptionTypes[i].isCompatibleWith(argumentTypes[j])) {", "-\t\t\t\t\t\tscope.problemReporter().wrongSequenceOfExceptionTypesError(this, caughtExceptionTypes[i], i, argumentTypes[j]);", "+\t\t\t\t\tif (this.caughtExceptionTypes[i].isCompatibleWith(argumentTypes[j])) {", "+\t\t\t\t\t\tthis.scope.problemReporter().wrongSequenceOfExceptionTypesError(this, this.caughtExceptionTypes[i], i, argumentTypes[j]);", "-\t\t\tcaughtExceptionTypes = new ReferenceBinding[0];", "+\t\t\tthis.caughtExceptionTypes = new ReferenceBinding[0];"]}], "num": 49811}