{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "da210f7cbed30f3f73e2278e78811aa9", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "267f43ee7fa6f1638a7cbda697a14f16", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "605cc5dd745b7e1d6935bfc34c1be6fcea51b4ab", "commitAfterChange": "03be42bb9ac6b223bea20e29a7b3f31a76dae9e4", "methodNumberBeforeChange": 66, "methodNumberAfterChange": 66, "signatureBeforeChange": " protected void reportMatching(Annotation[] annotations, IJavaElement enclosingElement, IJavaElement[] otherElements, Binding elementBinding, MatchingNodeSet nodeSet, boolean matchedContainer, boolean enclosesElement) throws CoreException", "signatureAfterChange": " protected void reportMatching(Annotation[] annotations, IJavaElement enclosingElement, IJavaElement[] otherElements, Binding elementBinding, MatchingNodeSet nodeSet, boolean matchedContainer, boolean enclosesElement) throws CoreException", "diff": ["-\t\tIJavaElement localElement = null;", "+\t\tIJavaElement localAnnotation = null;", "+\t\tIJavaElement[] otherAnnotations = null;", "+\t\tint length = otherElements == null ? 0 : otherElements.length;", "+\t\tboolean handlesCreated = false;", "-\t\t\tlocalElement = createHandle(annotationType, (IAnnotatable) enclosingElement);", "-\t\t\tthis.patternLocator.matchReportReference(typeRef, enclosingElement, localElement, otherElements, elementBinding, level.intValue(), this);", "+\t\t\tlocalAnnotation = createHandle(annotationType, (IAnnotatable) enclosingElement);", "+\t\t\tif (length > 0) {", "+\t\t\t\totherAnnotations = new IJavaElement[length];", "+\t\t\t\tfor (int o=0; o<length; o++) {", "+\t\t\t\t\totherAnnotations[o] = createHandle(annotationType, (IAnnotatable) otherElements[o]);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\thandlesCreated = true;", "+\t\t\tthis.patternLocator.matchReportReference(typeRef, enclosingElement, localAnnotation, otherAnnotations, elementBinding, level.intValue(), this);", "-\t\t\t\tif (localElement == null) {", "-\t\t\t\t\tlocalElement = createHandle(annotationType, (IAnnotatable) enclosingElement);", "+\t\t\t\tif (!handlesCreated) {", "+\t\t\t\t\tlocalAnnotation = createHandle(annotationType, (IAnnotatable) enclosingElement);", "+\t\t\t\t\tif (length > 0) {", "+\t\t\t\t\t\totherAnnotations = new IJavaElement[length];", "+\t\t\t\t\t\tfor (int o=0; o<length; o++) {", "+\t\t\t\t\t\t\totherAnnotations[o] = createHandle(annotationType, (IAnnotatable) otherElements[o]);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\thandlesCreated = true;", "-\t\t\t\tthis.patternLocator.matchReportReference(reference, enclosingElement, localElement, otherElements, pair.binding, level.intValue(), this);", "+\t\t\t\tthis.patternLocator.matchReportReference(reference, enclosingElement, localAnnotation, otherAnnotations, pair.binding, level.intValue(), this);", "-\t\t\t\t\t\tif (localElement == null) {", "-\t\t\t\t\t\t\tlocalElement = createHandle(annotationType, (IAnnotatable) enclosingElement);", "+\t\t\t\t\t\tif (!handlesCreated) {", "+\t\t\t\t\t\t\tlocalAnnotation = createHandle(annotationType, (IAnnotatable) enclosingElement);", "+\t\t\t\t\t\t\tif (length > 0) {", "+\t\t\t\t\t\t\t\totherAnnotations = new IJavaElement[length];", "+\t\t\t\t\t\t\t\tfor (int o=0; o<length; o++) {", "+\t\t\t\t\t\t\t\t\totherAnnotations[o] = createHandle(annotationType, (IAnnotatable) otherElements[o]);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\thandlesCreated = true;", "-\t\t\t\t\t\tthis.patternLocator.matchReportReference(node, enclosingElement, localElement, otherElements, elementBinding, level.intValue(), this);", "+\t\t\t\t\t\tthis.patternLocator.matchReportReference(node, enclosingElement, localAnnotation, otherAnnotations, elementBinding, level.intValue(), this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a8fb9f00d5c90241a5b8ae29f82a54d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "d3d3fd84014a6dcb70309f0821240a82ccf93b29", "commitAfterChange": "495498c492866181dc63a6039b81ee18c37f454c", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " public char[] computeUniqueKey(boolean isLeaf)", "signatureAfterChange": " public char[] computeUniqueKey(boolean isLeaf)", "diff": ["-\tif (sig == null) sig = signature();", "+\tboolean isGeneric = sig != null;", "+\tif (!isGeneric) sig = signature();", "-\tchar[] uniqueKey = new char[declaringLength + 1 + selectorLength + signatureLength];", "+\t// thrown exceptions", "+\tint thrownExceptionsLength = this.thrownExceptions.length;", "+\tint thrownExceptionsSignatureLength = 0;", "+\tchar[][] thrownExceptionsSignatures = null;", "+\tboolean addThrownExceptions = thrownExceptionsLength > 0 && (!isGeneric || CharOperation.lastIndexOf('^', sig) < 0);", "+\tif (addThrownExceptions) {", "+\t\tthrownExceptionsSignatures = new char[thrownExceptionsLength][];", "+\t\tfor (int i = 0; i < thrownExceptionsLength; i++) {", "+\t\t\tif (this.thrownExceptions[i] != null) {", "+\t\t\t\tthrownExceptionsSignatures[i] = this.thrownExceptions[i].signature();", "+\t\t\t\tthrownExceptionsSignatureLength += thrownExceptionsSignatures[i].length + 1;\t// add one char for separator", "+\t\t\t}", "+\t\t}", "+\t}", "+\t", "+\tchar[] uniqueKey = new char[declaringLength + 1 + selectorLength + signatureLength + thrownExceptionsSignatureLength];", "-\t//index += signatureLength;", "+\tif (thrownExceptionsSignatureLength > 0) {", "+\t\tindex += signatureLength;", "+\t\tfor (int i = 0; i < thrownExceptionsLength; i++) {", "+\t\t\tchar[] thrownExceptionSignature = thrownExceptionsSignatures[i];", "+\t\t\tif (thrownExceptionSignature != null) {", "+\t\t\t\tuniqueKey[index++] = '|';", "+\t\t\t\tint length = thrownExceptionSignature.length;", "+\t\t\t\tSystem.arraycopy(thrownExceptionSignature, 0, uniqueKey, index, length);", "+\t\t\t\tindex += length;", "+\t\t\t}", "+\t\t}", "+\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e3e1d217829d92bb56eea1f1a43f3c5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "3363755daf5e11f7ba5c27ee1ed39285b9c60a26", "commitAfterChange": "b25ba34af45dc400b54fbb4a1c94812b44a4f39f", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "diff": ["-\tnextMethod : for (int i = 0, l = length - 1; i < l;) {", "-\t\tMethodBinding method = methods[i++];", "-\t\tfor (int j = i; j <= l; j++) {", "-\t\t\tif (method.declaringClass == methods[j].declaringClass && areMethodsEqual(method, methods[j])) {", "-\t\t\t\t// found an inherited ParameterizedType that defines duplicate methods", "-\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, method, methods[j]);", "-\t\t\t\tcount--;", "-\t\t\t\tmethods[i - 1] = null;", "-\t\t\t\tcontinue nextMethod;", "+\tint[] skip = new int[count];", "+\tnextMethod : for (int i = 0, l = length - 1; i < l; i++) {", "+\t\tif (skip[i] == -1) continue nextMethod;", "+\t\tMethodBinding method = methods[i];", "+\t\tMethodBinding[] duplicates = null;", "+\t\tfor (int j = i + 1; j <= l; j++) {", "+\t\t\tMethodBinding method2 = methods[j];", "+\t\t\tif (method.declaringClass == method2.declaringClass && areMethodsEqual(method, method2)) {", "+\t\t\t\tskip[j] = -1;", "+\t\t\t\tif (duplicates == null)", "+\t\t\t\t\tduplicates = new MethodBinding[length];", "+\t\t\t\tduplicates[j] = method2;", "+\t\t\t}", "+\t\t}", "+\t\tif (duplicates != null) {", "+\t\t\t// found an inherited ParameterizedType that defines duplicate methods", "+\t\t\t// if all methods are abstract or more than 1 concrete method exists, then consider them to be duplicates", "+\t\t\t// if a single concrete method 'implements' the abstract methods, then do not report a duplicate error", "+\t\t\tint concreteCount = method.isAbstract() ? 0 : 1;", "+\t\t\tMethodBinding methodToKeep = method; // if a concrete method exists, keep it, otherwise keep the first method", "+\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "+\t\t\t\tif (duplicates[m] != null) {", "+\t\t\t\t\tif (!duplicates[m].isAbstract()) {", "+\t\t\t\t\t\tmethodToKeep = duplicates[m];", "+\t\t\t\t\t\tconcreteCount++;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (concreteCount != 1) {", "+\t\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "+\t\t\t\t\tif (duplicates[m] != null) {", "+\t\t\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, method, duplicates[m]);", "+\t\t\t\t\t\tcount--;", "+\t\t\t\t\t\tif (methodToKeep == duplicates[m])", "+\t\t\t\t\t\t\tmethods[i] = null;", "+\t\t\t\t\t\telse", "+\t\t\t\t\t\t\tmethods[m] = null;", "+\t\t\t\t\t}", "+\t\t\t\t}"]}], "num": 14598}