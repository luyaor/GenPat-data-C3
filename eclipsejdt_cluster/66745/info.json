{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d917fc7ffc5274233ff754ffb98c7760", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "215fa78e8d1fe21bbbecfc2a23f1fda5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "135399ac7f48d47679e738d0a583e6c95ff87fd6", "commitAfterChange": "092d49846655da2c4e511a256ba551dc4e15c674", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \r private void findMethods(\r \tchar[] methodName,\r \tTypeBinding[] argTypes,\r \tMethodBinding[] methods,\r \tScope scope,\r \tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \tboolean exactMatch)", "signatureAfterChange": "\r \r \tprivate void findMethods(\r \t\tchar[] methodName,\r \t\tTypeBinding[] argTypes,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType,\r \t\tInvocationSite invocationSite)", "diff": ["-\r", "-private void findMethods(\r", "-\tchar[] methodName,\r", "-\tTypeBinding[] argTypes,\r", "-\tMethodBinding[] methods,\r", "-\tScope scope,\r", "-\tObjectVector methodsFound,\r", "-//\tboolean noVoidReturnType, how do you know?\r", "-\tboolean onlyStaticMethods,\r", "-\tboolean exactMatch) {\r", "-\r", "-\t// Inherited methods which are hidden by subclasses are filtered out\r", "-\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\tint methodLength = methodName.length;\r", "-\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\tMethodBinding method = methods[f];\r", "-\t\tif (method.isConstructor()) continue next;\r", "-//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "-\t\tif (onlyStaticMethods && !method.isStatic()) continue next;\r", "-\t\tif (exactMatch) {\r", "-\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) continue next;\r", "-\t\t} else {\r", "-\t\t\tif (methodLength > method.selector.length) continue next;\r", "-\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false /* ignore case */)) continue next;\r", "-\t\t}\r", "-\t\tif (minArgLength > method.parameters.length) continue next;\r", "-\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a])) continue next;\r", "-\r", "-\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "-\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "-\t\t\tif (method == otherMethod) continue next;\r", "-\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true) && method.areParametersEqual(otherMethod)) {\r", "-\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass)) continue next;\r", "-\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "-\t\t\t\t\tif (method.declaringClass.implementsInterface(otherMethod.declaringClass, true)) continue next;\r", "-\t\t}\r", "-\t\tmethodsFound.add(method);\r", "-\t\tint length = method.parameters.length;\r", "-\t\tchar[][] parameterPackageNames = new char[length][];\r", "-\t\tchar[][] parameterTypeNames = new char[length][];\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tTypeBinding type = method.parameters[i];\r", "-\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\tif (!exactMatch) {\r", "-\t\t\tif (source != null && source.length > endPosition && source[endPosition] == '(')\r", "-\t\t\t\tcompletion = method.selector;\r", "-\t\t\telse\r", "-\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] {'(', ')'});\r", "-\t\t}\r", "-\t\trequestor.acceptMethod(\r", "-\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "-\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "-\t\t\tmethod.selector,\r", "-\t\t\tparameterPackageNames,\r", "-\t\t\tparameterTypeNames,\r", "-\t\t\tmethod.returnType.qualifiedPackageName(),\r", "-\t\t\tmethod.returnType.qualifiedSourceName(),\r", "-\t\t\tcompletion,\r", "-\t\t\tmethod.modifiers,\r", "-\t\t\tstartPosition,\r", "-\t\t\tendPosition);\r", "-}\r", "+\tprivate void findMethods(\r", "+\t\tchar[] methodName,\r", "+\t\tTypeBinding[] argTypes,\r", "+\t\tMethodBinding[] methods,\r", "+\t\tScope scope,\r", "+\t\tObjectVector methodsFound,\r", "+\t//\tboolean noVoidReturnType, how do you know?\r", "+\tboolean onlyStaticMethods,\r", "+\t\tboolean exactMatch,\r", "+\t\tTypeBinding receiverType,\r", "+\t\tInvocationSite invocationSite) {\r", "+\t\t// Inherited methods which are hidden by subclasses are filtered out\r", "+\t\t// No visibility checks can be performed without the scope & invocationSite\r", "+\t\tint methodLength = methodName.length;\r", "+\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\tMethodBinding method = methods[f];\r", "+\t\t\tif (method.isConstructor())\r", "+\t\t\t\tcontinue next;\r", "+\t\t\t//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "+\t\t\tif (onlyStaticMethods && !method.isStatic())\r", "+\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tif (options.checkVisibilitySensitive()\r", "+\t\t\t\t&& !method.canBeSeenBy(receiverType, invocationSite, scope))\r", "+\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tif (exactMatch) {\r", "+\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */\r", "+\t\t\t\t\t))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t} else {\r", "+\t\t\t\tif (methodLength > method.selector.length)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false\r", "+\t\t\t\t\t/* ignore case */\r", "+\t\t\t\t\t))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t}\r", "+\t\t\tif (minArgLength > method.parameters.length)\r", "+\t\t\t\tcontinue next;\r", "+\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a]))\r", "+\t\t\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "+\t\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "+\t\t\t\tif (method == otherMethod)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)\r", "+\t\t\t\t\t&& method.areParametersEqual(otherMethod)) {\r", "+\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))\r", "+\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "+\t\t\t\t\t\tif (method\r", "+\t\t\t\t\t\t\t.declaringClass\r", "+\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))\r", "+\t\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\tmethodsFound.add(method);\r", "+\t\t\tint length = method.parameters.length;\r", "+\t\t\tchar[][] parameterPackageNames = new char[length][];\r", "+\t\t\tchar[][] parameterTypeNames = new char[length][];\r", "+\t\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\t\tTypeBinding type = method.parameters[i];\r", "+\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t}\r", "+\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\tif (!exactMatch) {\r", "+\t\t\t\tif (source != null\r", "+\t\t\t\t\t&& source.length > endPosition\r", "+\t\t\t\t\t&& source[endPosition] == '(')\r", "+\t\t\t\t\tcompletion = method.selector;\r", "+\t\t\t\telse\r", "+\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });\r", "+\t\t\t}\r", "+\t\t\trequestor.acceptMethod(\r", "+\t\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "+\t\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "+\t\t\t\tmethod.selector,\r", "+\t\t\t\tparameterPackageNames,\r", "+\t\t\t\tparameterTypeNames,\r", "+\t\t\t\tmethod.returnType.qualifiedPackageName(),\r", "+\t\t\t\tmethod.returnType.qualifiedSourceName(),\r", "+\t\t\t\tcompletion,\r", "+\t\t\t\tmethod.modifiers,\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2b8775b2d9596c326f3ceef1001e49cd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "40383c2427f4645edcb9e28f2e15a8a778f0a951", "commitAfterChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \r private void findMethods(\r \tchar[] methodName,\r \tTypeBinding[] argTypes,\r \tMethodBinding[] methods,\r \tScope scope,\r \tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \tboolean exactMatch)", "signatureAfterChange": "\r \r \tprivate void findMethods(\r \t\tchar[] methodName,\r \t\tTypeBinding[] argTypes,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType,\r \t\tInvocationSite invocationSite)", "diff": ["-\r", "-private void findMethods(\r", "-\tchar[] methodName,\r", "-\tTypeBinding[] argTypes,\r", "-\tMethodBinding[] methods,\r", "-\tScope scope,\r", "-\tObjectVector methodsFound,\r", "-//\tboolean noVoidReturnType, how do you know?\r", "-\tboolean onlyStaticMethods,\r", "-\tboolean exactMatch) {\r", "-\r", "-\t// Inherited methods which are hidden by subclasses are filtered out\r", "-\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\tint methodLength = methodName.length;\r", "-\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\tMethodBinding method = methods[f];\r", "-\t\tif (method.isConstructor()) continue next;\r", "-//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "-\t\tif (onlyStaticMethods && !method.isStatic()) continue next;\r", "-\t\tif (exactMatch) {\r", "-\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) continue next;\r", "-\t\t} else {\r", "-\t\t\tif (methodLength > method.selector.length) continue next;\r", "-\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false /* ignore case */)) continue next;\r", "-\t\t}\r", "-\t\tif (minArgLength > method.parameters.length) continue next;\r", "-\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a])) continue next;\r", "-\r", "-\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "-\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "-\t\t\tif (method == otherMethod) continue next;\r", "-\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true) && method.areParametersEqual(otherMethod)) {\r", "-\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass)) continue next;\r", "-\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "-\t\t\t\t\tif (method.declaringClass.implementsInterface(otherMethod.declaringClass, true)) continue next;\r", "-\t\t}\r", "-\t\tmethodsFound.add(method);\r", "-\t\tint length = method.parameters.length;\r", "-\t\tchar[][] parameterPackageNames = new char[length][];\r", "-\t\tchar[][] parameterTypeNames = new char[length][];\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tTypeBinding type = method.parameters[i];\r", "-\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\tif (!exactMatch) {\r", "-\t\t\tif (source != null && source.length > endPosition && source[endPosition] == '(')\r", "-\t\t\t\tcompletion = method.selector;\r", "-\t\t\telse\r", "-\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] {'(', ')'});\r", "-\t\t}\r", "-\t\trequestor.acceptMethod(\r", "-\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "-\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "-\t\t\tmethod.selector,\r", "-\t\t\tparameterPackageNames,\r", "-\t\t\tparameterTypeNames,\r", "-\t\t\tmethod.returnType.qualifiedPackageName(),\r", "-\t\t\tmethod.returnType.qualifiedSourceName(),\r", "-\t\t\tcompletion,\r", "-\t\t\tmethod.modifiers,\r", "-\t\t\tstartPosition,\r", "-\t\t\tendPosition);\r", "-}\r", "+\tprivate void findMethods(\r", "+\t\tchar[] methodName,\r", "+\t\tTypeBinding[] argTypes,\r", "+\t\tMethodBinding[] methods,\r", "+\t\tScope scope,\r", "+\t\tObjectVector methodsFound,\r", "+\t//\tboolean noVoidReturnType, how do you know?\r", "+\tboolean onlyStaticMethods,\r", "+\t\tboolean exactMatch,\r", "+\t\tTypeBinding receiverType,\r", "+\t\tInvocationSite invocationSite) {\r", "+\t\t// Inherited methods which are hidden by subclasses are filtered out\r", "+\t\t// No visibility checks can be performed without the scope & invocationSite\r", "+\t\tint methodLength = methodName.length;\r", "+\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\tMethodBinding method = methods[f];\r", "+\t\t\tif (method.isConstructor())\r", "+\t\t\t\tcontinue next;\r", "+\t\t\t//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "+\t\t\tif (onlyStaticMethods && !method.isStatic())\r", "+\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tif (options.checkVisibilitySensitive()\r", "+\t\t\t\t&& !method.canBeSeenBy(receiverType, invocationSite, scope))\r", "+\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tif (exactMatch) {\r", "+\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */\r", "+\t\t\t\t\t))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t} else {\r", "+\t\t\t\tif (methodLength > method.selector.length)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false\r", "+\t\t\t\t\t/* ignore case */\r", "+\t\t\t\t\t))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t}\r", "+\t\t\tif (minArgLength > method.parameters.length)\r", "+\t\t\t\tcontinue next;\r", "+\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a]))\r", "+\t\t\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "+\t\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "+\t\t\t\tif (method == otherMethod)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)\r", "+\t\t\t\t\t&& method.areParametersEqual(otherMethod)) {\r", "+\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))\r", "+\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "+\t\t\t\t\t\tif (method\r", "+\t\t\t\t\t\t\t.declaringClass\r", "+\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))\r", "+\t\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\tmethodsFound.add(method);\r", "+\t\t\tint length = method.parameters.length;\r", "+\t\t\tchar[][] parameterPackageNames = new char[length][];\r", "+\t\t\tchar[][] parameterTypeNames = new char[length][];\r", "+\t\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\t\tTypeBinding type = method.parameters[i];\r", "+\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t}\r", "+\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\tif (!exactMatch) {\r", "+\t\t\t\tif (source != null\r", "+\t\t\t\t\t&& source.length > endPosition\r", "+\t\t\t\t\t&& source[endPosition] == '(')\r", "+\t\t\t\t\tcompletion = method.selector;\r", "+\t\t\t\telse\r", "+\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });\r", "+\t\t\t}\r", "+\t\t\trequestor.acceptMethod(\r", "+\t\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "+\t\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "+\t\t\t\tmethod.selector,\r", "+\t\t\t\tparameterPackageNames,\r", "+\t\t\t\tparameterTypeNames,\r", "+\t\t\t\tmethod.returnType.qualifiedPackageName(),\r", "+\t\t\t\tmethod.returnType.qualifiedSourceName(),\r", "+\t\t\t\tcompletion,\r", "+\t\t\t\tmethod.modifiers,\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bce44b01a3af33185ad34518f76b3b6b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "commitAfterChange": "7e5cc03e445550d3cbc10c611218c79332074276", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \r private void findMethods(\r \tchar[] methodName,\r \tTypeBinding[] argTypes,\r \tMethodBinding[] methods,\r \tScope scope,\r \tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \tboolean exactMatch)", "signatureAfterChange": "\r \r \tprivate void findMethods(\r \t\tchar[] methodName,\r \t\tTypeBinding[] argTypes,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType,\r \t\tInvocationSite invocationSite)", "diff": ["-\r", "-private void findMethods(\r", "-\tchar[] methodName,\r", "-\tTypeBinding[] argTypes,\r", "-\tMethodBinding[] methods,\r", "-\tScope scope,\r", "-\tObjectVector methodsFound,\r", "-//\tboolean noVoidReturnType, how do you know?\r", "-\tboolean onlyStaticMethods,\r", "-\tboolean exactMatch) {\r", "-\r", "-\t// Inherited methods which are hidden by subclasses are filtered out\r", "-\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\tint methodLength = methodName.length;\r", "-\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\tMethodBinding method = methods[f];\r", "-\t\tif (method.isConstructor()) continue next;\r", "-//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "-\t\tif (onlyStaticMethods && !method.isStatic()) continue next;\r", "-\t\tif (exactMatch) {\r", "-\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) continue next;\r", "-\t\t} else {\r", "-\t\t\tif (methodLength > method.selector.length) continue next;\r", "-\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false /* ignore case */)) continue next;\r", "-\t\t}\r", "-\t\tif (minArgLength > method.parameters.length) continue next;\r", "-\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a])) continue next;\r", "-\r", "-\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "-\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "-\t\t\tif (method == otherMethod) continue next;\r", "-\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true) && method.areParametersEqual(otherMethod)) {\r", "-\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass)) continue next;\r", "-\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "-\t\t\t\t\tif (method.declaringClass.implementsInterface(otherMethod.declaringClass, true)) continue next;\r", "-\t\t}\r", "-\t\tmethodsFound.add(method);\r", "-\t\tint length = method.parameters.length;\r", "-\t\tchar[][] parameterPackageNames = new char[length][];\r", "-\t\tchar[][] parameterTypeNames = new char[length][];\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tTypeBinding type = method.parameters[i];\r", "-\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\tif (!exactMatch) {\r", "-\t\t\tif (source != null && source.length > endPosition && source[endPosition] == '(')\r", "-\t\t\t\tcompletion = method.selector;\r", "-\t\t\telse\r", "-\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] {'(', ')'});\r", "-\t\t}\r", "-\t\trequestor.acceptMethod(\r", "-\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "-\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "-\t\t\tmethod.selector,\r", "-\t\t\tparameterPackageNames,\r", "-\t\t\tparameterTypeNames,\r", "-\t\t\tmethod.returnType.qualifiedPackageName(),\r", "-\t\t\tmethod.returnType.qualifiedSourceName(),\r", "-\t\t\tcompletion,\r", "-\t\t\tmethod.modifiers,\r", "-\t\t\tstartPosition,\r", "-\t\t\tendPosition);\r", "-}\r", "+\tprivate void findMethods(\r", "+\t\tchar[] methodName,\r", "+\t\tTypeBinding[] argTypes,\r", "+\t\tMethodBinding[] methods,\r", "+\t\tScope scope,\r", "+\t\tObjectVector methodsFound,\r", "+\t//\tboolean noVoidReturnType, how do you know?\r", "+\tboolean onlyStaticMethods,\r", "+\t\tboolean exactMatch,\r", "+\t\tTypeBinding receiverType,\r", "+\t\tInvocationSite invocationSite) {\r", "+\t\t// Inherited methods which are hidden by subclasses are filtered out\r", "+\t\t// No visibility checks can be performed without the scope & invocationSite\r", "+\t\tint methodLength = methodName.length;\r", "+\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\tMethodBinding method = methods[f];\r", "+\t\t\tif (method.isConstructor())\r", "+\t\t\t\tcontinue next;\r", "+\t\t\t//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "+\t\t\tif (onlyStaticMethods && !method.isStatic())\r", "+\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tif (options.checkVisibilitySensitive()\r", "+\t\t\t\t&& !method.canBeSeenBy(receiverType, invocationSite, scope))\r", "+\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tif (exactMatch) {\r", "+\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */\r", "+\t\t\t\t\t))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t} else {\r", "+\t\t\t\tif (methodLength > method.selector.length)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false\r", "+\t\t\t\t\t/* ignore case */\r", "+\t\t\t\t\t))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t}\r", "+\t\t\tif (minArgLength > method.parameters.length)\r", "+\t\t\t\tcontinue next;\r", "+\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a]))\r", "+\t\t\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "+\t\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "+\t\t\t\tif (method == otherMethod)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)\r", "+\t\t\t\t\t&& method.areParametersEqual(otherMethod)) {\r", "+\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))\r", "+\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "+\t\t\t\t\t\tif (method\r", "+\t\t\t\t\t\t\t.declaringClass\r", "+\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))\r", "+\t\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\tmethodsFound.add(method);\r", "+\t\t\tint length = method.parameters.length;\r", "+\t\t\tchar[][] parameterPackageNames = new char[length][];\r", "+\t\t\tchar[][] parameterTypeNames = new char[length][];\r", "+\t\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\t\tTypeBinding type = method.parameters[i];\r", "+\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t}\r", "+\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\tif (!exactMatch) {\r", "+\t\t\t\tif (source != null\r", "+\t\t\t\t\t&& source.length > endPosition\r", "+\t\t\t\t\t&& source[endPosition] == '(')\r", "+\t\t\t\t\tcompletion = method.selector;\r", "+\t\t\t\telse\r", "+\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });\r", "+\t\t\t}\r", "+\t\t\trequestor.acceptMethod(\r", "+\t\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "+\t\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "+\t\t\t\tmethod.selector,\r", "+\t\t\t\tparameterPackageNames,\r", "+\t\t\t\tparameterTypeNames,\r", "+\t\t\t\tmethod.returnType.qualifiedPackageName(),\r", "+\t\t\t\tmethod.returnType.qualifiedSourceName(),\r", "+\t\t\t\tcompletion,\r", "+\t\t\t\tmethod.modifiers,\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e7bd22eaf133d935bc31e7bc4acb0ff1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "commitAfterChange": "44855522f87e615f1ca0bfcda268b074e4443dfe", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \r private void findMethods(\r \tchar[] methodName,\r \tTypeBinding[] argTypes,\r \tMethodBinding[] methods,\r \tScope scope,\r \tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \tboolean exactMatch)", "signatureAfterChange": "\r \r \tprivate void findMethods(\r \t\tchar[] methodName,\r \t\tTypeBinding[] argTypes,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType,\r \t\tInvocationSite invocationSite)", "diff": ["-\r", "-private void findMethods(\r", "-\tchar[] methodName,\r", "-\tTypeBinding[] argTypes,\r", "-\tMethodBinding[] methods,\r", "-\tScope scope,\r", "-\tObjectVector methodsFound,\r", "-//\tboolean noVoidReturnType, how do you know?\r", "-\tboolean onlyStaticMethods,\r", "-\tboolean exactMatch) {\r", "-\r", "-\t// Inherited methods which are hidden by subclasses are filtered out\r", "-\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\tint methodLength = methodName.length;\r", "-\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\tMethodBinding method = methods[f];\r", "-\t\tif (method.isConstructor()) continue next;\r", "-//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "-\t\tif (onlyStaticMethods && !method.isStatic()) continue next;\r", "-\t\tif (exactMatch) {\r", "-\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) continue next;\r", "-\t\t} else {\r", "-\t\t\tif (methodLength > method.selector.length) continue next;\r", "-\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false /* ignore case */)) continue next;\r", "-\t\t}\r", "-\t\tif (minArgLength > method.parameters.length) continue next;\r", "-\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a])) continue next;\r", "-\r", "-\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "-\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "-\t\t\tif (method == otherMethod) continue next;\r", "-\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true) && method.areParametersEqual(otherMethod)) {\r", "-\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass)) continue next;\r", "-\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "-\t\t\t\t\tif (method.declaringClass.implementsInterface(otherMethod.declaringClass, true)) continue next;\r", "-\t\t}\r", "-\t\tmethodsFound.add(method);\r", "-\t\tint length = method.parameters.length;\r", "-\t\tchar[][] parameterPackageNames = new char[length][];\r", "-\t\tchar[][] parameterTypeNames = new char[length][];\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tTypeBinding type = method.parameters[i];\r", "-\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\tif (!exactMatch) {\r", "-\t\t\tif (source != null && source.length > endPosition && source[endPosition] == '(')\r", "-\t\t\t\tcompletion = method.selector;\r", "-\t\t\telse\r", "-\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] {'(', ')'});\r", "-\t\t}\r", "-\t\trequestor.acceptMethod(\r", "-\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "-\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "-\t\t\tmethod.selector,\r", "-\t\t\tparameterPackageNames,\r", "-\t\t\tparameterTypeNames,\r", "-\t\t\tmethod.returnType.qualifiedPackageName(),\r", "-\t\t\tmethod.returnType.qualifiedSourceName(),\r", "-\t\t\tcompletion,\r", "-\t\t\tmethod.modifiers,\r", "-\t\t\tstartPosition,\r", "-\t\t\tendPosition);\r", "-}\r", "+\tprivate void findMethods(\r", "+\t\tchar[] methodName,\r", "+\t\tTypeBinding[] argTypes,\r", "+\t\tMethodBinding[] methods,\r", "+\t\tScope scope,\r", "+\t\tObjectVector methodsFound,\r", "+\t//\tboolean noVoidReturnType, how do you know?\r", "+\tboolean onlyStaticMethods,\r", "+\t\tboolean exactMatch,\r", "+\t\tTypeBinding receiverType,\r", "+\t\tInvocationSite invocationSite) {\r", "+\t\t// Inherited methods which are hidden by subclasses are filtered out\r", "+\t\t// No visibility checks can be performed without the scope & invocationSite\r", "+\t\tint methodLength = methodName.length;\r", "+\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\tMethodBinding method = methods[f];\r", "+\t\t\tif (method.isConstructor())\r", "+\t\t\t\tcontinue next;\r", "+\t\t\t//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "+\t\t\tif (onlyStaticMethods && !method.isStatic())\r", "+\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tif (options.checkVisibilitySensitive()\r", "+\t\t\t\t&& !method.canBeSeenBy(receiverType, invocationSite, scope))\r", "+\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tif (exactMatch) {\r", "+\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */\r", "+\t\t\t\t\t))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t} else {\r", "+\t\t\t\tif (methodLength > method.selector.length)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false\r", "+\t\t\t\t\t/* ignore case */\r", "+\t\t\t\t\t))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t}\r", "+\t\t\tif (minArgLength > method.parameters.length)\r", "+\t\t\t\tcontinue next;\r", "+\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a]))\r", "+\t\t\t\t\t\tcontinue next;\r", "+\r", "+\t\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "+\t\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "+\t\t\t\tif (method == otherMethod)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)\r", "+\t\t\t\t\t&& method.areParametersEqual(otherMethod)) {\r", "+\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))\r", "+\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "+\t\t\t\t\t\tif (method\r", "+\t\t\t\t\t\t\t.declaringClass\r", "+\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))\r", "+\t\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\tmethodsFound.add(method);\r", "+\t\t\tint length = method.parameters.length;\r", "+\t\t\tchar[][] parameterPackageNames = new char[length][];\r", "+\t\t\tchar[][] parameterTypeNames = new char[length][];\r", "+\t\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\t\tTypeBinding type = method.parameters[i];\r", "+\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t}\r", "+\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\tif (!exactMatch) {\r", "+\t\t\t\tif (source != null\r", "+\t\t\t\t\t&& source.length > endPosition\r", "+\t\t\t\t\t&& source[endPosition] == '(')\r", "+\t\t\t\t\tcompletion = method.selector;\r", "+\t\t\t\telse\r", "+\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });\r", "+\t\t\t}\r", "+\t\t\trequestor.acceptMethod(\r", "+\t\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "+\t\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "+\t\t\t\tmethod.selector,\r", "+\t\t\t\tparameterPackageNames,\r", "+\t\t\t\tparameterTypeNames,\r", "+\t\t\t\tmethod.returnType.qualifiedPackageName(),\r", "+\t\t\t\tmethod.returnType.qualifiedSourceName(),\r", "+\t\t\t\tcompletion,\r", "+\t\t\t\tmethod.modifiers,\r"]}], "num": 66745}