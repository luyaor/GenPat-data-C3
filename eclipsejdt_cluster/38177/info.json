{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4e6540997cedd2a1a53c735ebaae8769", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3b2ec4107c78254698a1df014e1876f0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java", "commitBeforeChange": "ff17444fcc31fe021d6a45c4b051acce1b3894e3", "commitAfterChange": "eb15457015da4dfaee5df4c21a851b245805072a", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " public void enterField(FieldInfo fieldInfo)", "signatureAfterChange": " public void enterField(FieldInfo fieldInfo)", "diff": ["-\tinfo.setTypeName(fieldInfo.type);", "+\tchar[] typeName = JavaModelManager.getJavaModelManager().intern(fieldInfo.type);", "+\tinfo.setTypeName(typeName);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93ce59dceb6e4494f6dab55d8c74d850", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "c4112ab397da10b85cbb2a3f081c4c91ed7c7975", "commitAfterChange": "2077df1da6fa132fd5beb7d042b102e760cf8cbf", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  protected void addAffectedSourceFiles(StringSet qualifiedSet, StringSet simpleSet, StringSet affectedTypes)", "signatureAfterChange": "  protected void addAffectedSourceFiles(StringSet qualifiedSet, StringSet simpleSet, StringSet rootSet, StringSet affectedTypes)", "diff": ["-protected void addAffectedSourceFiles(StringSet qualifiedSet, StringSet simpleSet, StringSet affectedTypes) {", "+protected void addAffectedSourceFiles(StringSet qualifiedSet, StringSet simpleSet, StringSet rootSet, StringSet affectedTypes) {", "-\tchar[][] internedSimpleNames = ReferenceCollection.internSimpleNames(simpleSet);", "+\tchar[][] internedSimpleNames = ReferenceCollection.internSimpleNames(simpleSet, true);", "+\tchar[][] internedRootNames = ReferenceCollection.internSimpleNames(rootSet, false);", "-\t\t\tif (refs.includes(internedQualifiedNames, internedSimpleNames)) {", "+\t\t\tif (refs.includes(internedQualifiedNames, internedSimpleNames, internedRootNames)) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a5a142a3acd1b43ad8a3ba08e28260ff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/pattern/InternalSearchPattern.java", "commitBeforeChange": "a9c68df97efd734f3ed326f5e99e4d21e6054bec", "commitAfterChange": "af2f21c145913c8a7ccf22989ee905c5f5c7dd0d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 6, "signatureBeforeChange": " public void findMatches(SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic void findMatches(SearchParticipant[] participants, ICompilationUnit[] workingCopies, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException", "diff": ["- */", "-public void findMatches(SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException {", "-\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "-", "-\t/* initialize progress monitor */", "-\tif (monitor != null)", "-\t\tmonitor.beginTask(Util.bind(\"engine.searching\"), 100); //$NON-NLS-1$", "-\tif (SearchEngine.VERBOSE)", "-\t\tSystem.out.println(\"Searching for \" + this + \" in \" + scope); //$NON-NLS-1$//$NON-NLS-2$", "-", "-\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();", "-\ttry {", "-\t\trequestor.beginReporting();", "-\t\tfor (int i = 0, l = participants == null ? 0 : participants.length; i < l; i++) {", "-\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "-", "-\t\t\tSearchParticipant participant = participants[i];", "-\t\t\ttry {", "-\t\t\t\tparticipant.beginSearching();", "-\t\t\t\trequestor.enterParticipant(participant);", "-\t\t\t\tPathCollector pathCollector = new PathCollector();", "-\t\t\t\tindexManager.performConcurrentJob(", "-\t\t\t\t\tnew PatternSearchJob((SearchPattern) this, participant, scope, pathCollector),", "-\t\t\t\t\tIJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,", "-\t\t\t\t\tmonitor);", "-", "-\t\t\t\t// locate index matches if any (note that all search matches could have been issued during index querying)", "-\t\t\t\tString[] indexMatchPaths = pathCollector.getPaths();", "-\t\t\t\tpathCollector = null; // release", "-\t\t\t\tint indexMatchLength = indexMatchPaths == null ? 0 : indexMatchPaths.length;", "-\t\t\t\tSearchDocument[] indexMatches = new SearchDocument[indexMatchLength];", "-\t\t\t\tfor (int j = 0; j < indexMatchLength; j++)", "-\t\t\t\t\tindexMatches[j] = participant.getDocument(indexMatchPaths[j]);", "-\t\t\t\tparticipant.locateMatches(indexMatches, (SearchPattern) this, scope, requestor, monitor);", "-\t\t\t} finally {\t\t", "-\t\t\t\trequestor.exitParticipant(participant);", "-\t\t\t\tparticipant.doneSearching();", "+\t */", "+\tpublic void findMatches(SearchParticipant[] participants, ICompilationUnit[] workingCopies, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException {", "+\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "+\t", "+\t\t/* initialize progress monitor */", "+\t\tif (monitor != null)", "+\t\t\tmonitor.beginTask(Util.bind(\"engine.searching\"), 100); //$NON-NLS-1$", "+\t\tif (SearchEngine.VERBOSE)", "+\t\t\tSystem.out.println(\"Searching for \" + this + \" in \" + scope); //$NON-NLS-1$//$NON-NLS-2$", "+\t", "+\t\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();", "+\t\ttry {", "+\t\t\trequestor.beginReporting();", "+\t\t\tfor (int i = 0, l = participants == null ? 0 : participants.length; i < l; i++) {", "+\t\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "+\t", "+\t\t\t\tSearchParticipant participant = participants[i];", "+\t\t\t\ttry {", "+\t\t\t\t\tparticipant.beginSearching();", "+\t\t\t\t\trequestor.enterParticipant(participant);", "+\t\t\t\t\tPathCollector pathCollector = new PathCollector();", "+\t\t\t\t\tindexManager.performConcurrentJob(", "+\t\t\t\t\t\tnew PatternSearchJob((SearchPattern) this, participant, scope, pathCollector),", "+\t\t\t\t\t\tIJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,", "+\t\t\t\t\t\tmonitor);", "+\t\t\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "+\t", "+\t\t\t\t\t// locate index matches if any (note that all search matches could have been issued during index querying)", "+\t\t\t\t\tString[] indexMatchPaths = pathCollector.getPaths();", "+\t\t\t\t\tpathCollector = null; // release", "+\t\t\t\t\tint indexMatchLength = indexMatchPaths == null ? 0 : indexMatchPaths.length;", "+\t\t\t\t\tSearchDocument[] indexMatches = new SearchDocument[indexMatchLength];", "+\t\t\t\t\tfor (int j = 0; j < indexMatchLength; j++)", "+\t\t\t\t\t\tindexMatches[j] = participant.getDocument(indexMatchPaths[j]);", "+\t\t\t\t\tSearchDocument[] matches = addWorkingCopies(indexMatches, workingCopies, participant);", "+\t\t\t\t\tparticipant.locateMatches(matches, (SearchPattern) this, scope, requestor, monitor);", "+\t\t\t\t} finally {\t\t", "+\t\t\t\t\trequestor.exitParticipant(participant);", "+\t\t\t\t\tparticipant.doneSearching();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} finally {", "+\t\t\trequestor.endReporting();", "+\t\t\tif (monitor != null)", "+\t\t\t\tmonitor.done();", "+\t\t}", "+\t}", "-\t} finally {", "-\t\trequestor.endReporting();", "-\t\tif (monitor != null)", "-\t\t\tmonitor.done();", "-}"]}], "num": 38177}