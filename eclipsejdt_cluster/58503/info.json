{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9164ea0d118ed8535451aa23b6ec7063", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39a0759d918f30470e101b3de53d40b3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "b9de5f3466a9b4d6687de837720c445097067b16", "commitAfterChange": "39416e9e4305b172d90b88aed3085d98ded0a86c", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "\r \r \tpublic void emulateOuterAccess(\r \t\tReferenceBinding targetEnclosingType,\r \t\tboolean useDirectReference)", "signatureAfterChange": "\r \r \tpublic void emulateOuterAccess(\r \t\tReferenceBinding targetEnclosingType,\r \t\tboolean useDirectReference)", "diff": ["-\t\t\tNestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;\r", "+\t\t\t\tNestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;\r", "-\t\t\t} else if (currentNestedType.isLocalType()) {\r", "-\t\t\t\t// direct enclosing instance link\r", "-\t\t\t\t// must also add a synthetic field if we're not inside a constructor\r", "-\t\t\t\tcurrentType = currentNestedType.enclosingType;\r", "-\t\t\t\tif (methodScope().isInsideInitializerOrConstructor())\r", "-\t\t\t\t\tcurrentNestedType.addSyntheticArgument(currentType);\r", "-\t\t\t\telse\r", "-\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "-\t\t\t\t// further indirect cases\r", "-\t\t\t\twhile (currentType.isNestedType()\r", "-\t\t\t\t\t&& currentType != targetEnclosingType\r", "-\t\t\t\t\t&& !targetEnclosingType.isSuperclassOf(currentType)) {\r", "-\r", "-\t\t\t\t\tcurrentNestedType = (NestedTypeBinding) currentType;\r", "+\t\t\t\t\t\r", "+\t\t\t} else { // indirect reference sequence\r", "+\t\t\t\tint depth = 0;\r", "+\t\t\t\t\r", "+\t\t\t\t// saturate all the way up until reaching compatible enclosing type\r", "+\t\t\t\twhile (currentType.isLocalType()){\r", "+\t\t\t\t\tNestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;\r", "-\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tif (depth == 0){\r", "+\t\t\t\t\t\tif (methodScope().isInsideInitializerOrConstructor()) {\r", "+\t\t\t\t\t\t\t// must also add a synthetic field if we're not inside a constructor\r", "+\t\t\t\t\t\t\tcurrentNestedType.addSyntheticArgument(currentType);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "+\t\t\t\t\t\t}\t\t\t\t\t\r", "+\t\t\t\t\t} else if (currentNestedType == targetEnclosingType \r", "+\t\t\t\t\t\t\t\t\t\t|| targetEnclosingType.isSuperclassOf(currentNestedType)) {\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "+\t\t\t\t\t} \r", "+\t\t\t\t\tdepth++;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "532c87598c8712a57a0976cb70cda671", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "c099c1c915ea3c2425fc3259553c0cf5526a58b0", "commitAfterChange": "c712e524fc146f884a167061179343b82ef9e12d", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void computeInheritedMethods()", "signatureAfterChange": " private void computeInheritedMethods()", "diff": ["-\t\t\t\t\t\t// 30805 - non-visible (abstract) method still needs to be implemented even if similar method defined below (overridesPackageDefaultMethod) ", "-\t\t\t\t\t\tif (!(method.isDefault() && method.isAbstract() && (method.declaringClass.fPackage != type.fPackage))) { ", "-\t\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++)", "-\t\t\t\t\t\t\t\tif (method.returnType == existingMethods[i].returnType)", "-\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(existingMethods[i]))", "-\t\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++) {", "+\t\t\t\t\t\t\tMethodBinding existingMethod = existingMethods[i];", "+\t\t\t\t\t\t\tif (method.returnType == existingMethod.returnType", "+\t\t\t\t\t\t\t\t\t&& !(method.isDefault() // (31398,30805) keep non-visible default abstract, if no implementation exists in same package", "+\t\t\t\t\t\t\t\t\t\t\t\t&& method.isAbstract() ", "+\t\t\t\t\t\t\t\t\t\t\t\t&& method.declaringClass.fPackage != existingMethod.declaringClass.fPackage)", "+\t\t\t\t\t\t\t\t\t&& method.areParametersEqual(existingMethod)) {", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\tif (nonVisibleDefaultMethods != null)", "-\t\t\t\t\t\tfor (int i = 0; i < nonVisibleCount; i++)", "-\t\t\t\t\t\t\tif (method.returnType == nonVisibleDefaultMethods[i].returnType)", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector))", "-\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(nonVisibleDefaultMethods[i]))", "+\t\t\t\t\tif (nonVisibleDefaultMethods != null) {", "+\t\t\t\t\t\tfor (int i = 0; i < nonVisibleCount; i++) {", "+\t\t\t\t\t\t\tif (method.returnType == nonVisibleDefaultMethods[i].returnType", "+\t\t\t\t\t\t\t\t\t&& CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector)", "+\t\t\t\t\t\t\t\t\t&& method.areParametersEqual(nonVisibleDefaultMethods[i])) {", "-", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\t\t\tif (existingMethods == null)", "+\t\t\t\t\t\tif (existingMethods == null) {", "-\t\t\t\t\t\telse", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (nonVisibleDefaultMethods == null)", "+\t\t\t\t\t\tif (nonVisibleDefaultMethods == null) {", "-\t\t\t\t\t\telse if (nonVisibleCount == nonVisibleDefaultMethods.length)", "+\t\t\t\t\t\t} else if (nonVisibleCount == nonVisibleDefaultMethods.length) {", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract", "+\t\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) { // non visible abstract methods cannot be overridden so the type must be defined abstract", "-", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (method.returnType == current[i].returnType) {", "-\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(current[i])) {", "-\t\t\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);", "-\t\t\t\t\t\t\t\t\t\tbreak foundMatch;", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (method.returnType == current[i].returnType", "+\t\t\t\t\t\t\t\t\t\t&& method.areParametersEqual(current[i])) {", "+\t\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);", "+\t\t\t\t\t\t\t\t\tbreak foundMatch;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a1c5a9db2ba66435ca4ede55dc5b7e78", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "1ba6cf1a1cd58ea6964d3e53d500ba37300ad6c5", "commitAfterChange": "122386dad13a4daa4a6eb3fe318a2c079a2655ef", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "\r \r \tpublic SingleVariableDeclaration convert(Argument argument)", "signatureAfterChange": "\r \r \tpublic SingleVariableDeclaration convert(Argument argument)", "diff": ["-\t\tvariableDecl.setType(convertType(argument.type));\r", "-\t\tvariableDecl.setSourceRange(argument.declarationSourceStart, argument.declarationSourceEnd - argument.declarationSourceStart + 1);\r", "+\t\tType type = convertType(argument.type);\r", "+\t\tvariableDecl.setType(type);\r", "+\t\tint typeEnd = type.getStartPosition() + type.getLength() - 1;\r", "+\t\tint rightEnd = Math.max(typeEnd, argument.declarationSourceEnd);\r", "+\t\tvariableDecl.setSourceRange(argument.declarationSourceStart, rightEnd - argument.declarationSourceStart + 1);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b49e5a82096bdb6fc53e1fef161935f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "bae98ccb647b46a2d5cfccf36593de0c5db401c9", "commitAfterChange": "230a5cd410205aeead21b12e1ec93eae10a08fda", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 61, "signatureBeforeChange": " \t \tpublic NormalAnnotation convert(org.eclipse.jdt.internal.compiler.ast.NormalAnnotation annotation)", "signatureAfterChange": " \t \tpublic NormalAnnotation convert(org.eclipse.jdt.internal.compiler.ast.NormalAnnotation annotation)", "diff": ["+\t\t", "+\t\tint start = annotation.sourceStart;", "+\t\tint end = annotation.declarationSourceEnd;", "+\t\t", "-\t\t\t\tnormalAnnotation.values().add(convert(memberValuePairs[i]));", "+\t\t\t\tMemberValuePair memberValuePair = convert(memberValuePairs[i]);", "+\t\t\t\tint memberValuePairEnd = memberValuePair.getStartPosition() + memberValuePair.getLength() - 1;", "+\t\t\t\tif (end == memberValuePairEnd) {", "+\t\t\t\t\tnormalAnnotation.setFlags(normalAnnotation.getFlags() | ASTNode.RECOVERED);", "+\t\t\t\t}", "+\t\t\t\tnormalAnnotation.values().add(memberValuePair);", "-\t\tint start = annotation.sourceStart;", "-\t\tint end = annotation.declarationSourceEnd;", "+\t\t"]}], "num": 58503}