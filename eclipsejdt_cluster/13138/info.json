{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1b16605aec297d52b98d779b01888c57", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "12a6b5d35098073d89b0a4509a4647c1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "9d6421c97941435b71726699128d0343d2af1a6d", "commitAfterChange": "f6b352b97c4d3f236828cd9dab83777ae77d4959", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 63, "signatureBeforeChange": " \tpublic IClasspathEntry[] getResolvedClasspath( \t\tIClasspathEntry[] classpathEntries, \t\tboolean ignoreUnresolvedEntry, \t\tboolean generateMarkerOnError) \t\tthrows JavaModelException", "signatureAfterChange": " \tpublic IClasspathEntry[] getResolvedClasspath( \t\tIClasspathEntry[] classpathEntries, \t\tboolean ignoreUnresolvedEntry, \t\tboolean generateMarkerOnError) \t\tthrows JavaModelException", "diff": ["+\t\tIJavaModelStatus status;", "-", "+\t\t\tstatus = null;", "+\t\t\t", "-\t\t\tIJavaModelStatus status = null;", "+\t\tif (generateMarkerOnError) {", "+\t\t\tstatus = JavaConventions.validateClasspath(this, resolvedPath, this.getOutputLocation());", "+\t\t\tif (!status.isOK()) createClasspathProblemMarker(status);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1897b1a4c83aa8abf2a782b359fc4e3e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 80, "signatureBeforeChange": "\r \tpublic IClasspathEntry[] getResolvedClasspath(boolean ignoreUnresolvedVariable) throws JavaModelException", "signatureAfterChange": "\r \tpublic IClasspathEntry[] getResolvedClasspath(boolean ignoreUnresolvedVariable, boolean generateMarkerOnError) throws JavaModelException", "diff": ["-\t\tIClasspathEntry[] classpath = getRawClasspath();\r", "-\t\tIClasspathEntry[] resolvedPath = classpath; // clone only if necessary\r", "-\t\tint length = classpath.length;\r", "-\t\tint index = 0;\r", "-\t\t\r", "-\t\tfor (int i = 0; i < length; i++){\r", "-\t\t\t\r", "-\t\t\tIClasspathEntry entry = classpath[i];\r", "-\r", "-\t\t\t/* resolve variables if any, unresolved ones are ignored */\r", "-\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_VARIABLE){\r", "-\r", "-\t\t\t\t// clone original path\r", "-\t\t\t\tif (resolvedPath == classpath){\r", "-\t\t\t\t\tSystem.arraycopy(classpath, 0, resolvedPath = new IClasspathEntry[length], 0, i);\r", "-\t\t\t\t}\r", "-\t\t\t\t// resolve current variable (handling variable->variable->variable->entry\r", "-\t\t\t\tIPath variablePath = entry.getPath(); // for error reporting\r", "-\t\t\t\tentry = JavaCore.getResolvedClasspathEntry(entry);\r", "-\t\t\t\tif (entry == null && !ignoreUnresolvedVariable){\r", "-\t\t\t\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND, variablePath.toString()));\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tif (entry != null){\r", "-\t\t\t\tresolvedPath[index++] = entry;\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\t// resize resolved classpath in case some variable entries could not be resolved\r", "-\t\tif (index != length){\r", "-\t\t\tSystem.arraycopy(resolvedPath, 0, resolvedPath = new IClasspathEntry[index], 0, index);\r", "-\t\t}\r", "-\t\treturn resolvedPath;\r", "+\t */\r", "+\tpublic IClasspathEntry[] getResolvedClasspath(boolean ignoreUnresolvedVariable, boolean generateMarkerOnError) throws JavaModelException {\r", "+\r", "+\t\tIClasspathEntry[] classpath = getRawClasspath();\r", "+\t\tIClasspathEntry[] resolvedPath = classpath; // clone only if necessary\r", "+\t\tint length = classpath.length;\r", "+\t\tint index = 0;\r", "+\t\t\r", "+\t\tfor (int i = 0; i < length; i++){\r", "+\t\t\t\r", "+\t\t\tIClasspathEntry entry = classpath[i];\r", "+\r", "+\t\t\t/* validation if needed */\r", "+\t\t\tif (generateMarkerOnError){\r", "+\t\t\t\tIJavaModelStatus status = JavaConventions.validateClasspathEntry(this, entry, false);\r", "+\t\t\t\tif (!status.isOK()) createClasspathProblemMarker(entry, status.getMessage());\r", "+\t\t\t}\r", "+\r", "+\t\t\t/* resolve variables if any, unresolved ones are ignored */\r", "+\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_VARIABLE){\r", "+\r", "+\t\t\t\t// clone original path\r", "+\t\t\t\tif (resolvedPath == classpath){\r", "+\t\t\t\t\tSystem.arraycopy(classpath, 0, resolvedPath = new IClasspathEntry[length], 0, i);\r", "+\t\t\t\t}\r", "+\t\t\t\t// resolve current variable (handling variable->variable->variable->entry\r", "+\t\t\t\tIPath variablePath = entry.getPath(); // for error reporting\r", "+\t\t\t\tentry = JavaCore.getResolvedClasspathEntry(entry);\r", "+\t\t\t\tif (entry == null){\r", "+\t\t\t\t\tif (!ignoreUnresolvedVariable){\r", "+\t\t\t\t\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND, variablePath.toString()));\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tif (entry != null){\r", "+\t\t\t\tresolvedPath[index++] = entry;\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\t// resize resolved classpath in case some variable entries could not be resolved\r", "+\t\tif (index != length){\r", "+\t\t\tSystem.arraycopy(resolvedPath, 0, resolvedPath = new IClasspathEntry[index], 0, index);\r", "+\t\t}\r", "+\t\treturn resolvedPath;\r", "+\t}\r"]}], "num": 13138}