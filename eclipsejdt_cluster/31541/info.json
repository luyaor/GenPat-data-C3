{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "480331828e737b3379dc9efe118dbbe6", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3c20bf28ec91615d65d1ade97aee1e14", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8bd987839355c299213c95f3874a2e3574283d9c", "commitAfterChange": "76b6723dbe61d0b9874754d0d6572d1a4d8c0cbc", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": "  \tprivate void printJavadocBlockReference(StringBuffer buffer, FormatJavadocReference reference, FormatJavadocBlock block)", "signatureAfterChange": "  \tprivate void printJavadocBlockReference(FormatJavadocBlock block, FormatJavadocReference reference)", "diff": ["-\tprivate void printJavadocBlockReference(StringBuffer buffer, FormatJavadocReference reference, FormatJavadocBlock block) {", "-", "-\t\tboolean indentRootTags = this.formatter.preferences.comment_indent_root_tags && !block.isInDescription();", "-\t\tboolean indentParamTag = this.formatter.preferences.comment_indent_parameter_description && block.isInParamTag();", "+\tprivate void printJavadocBlockReference(FormatJavadocBlock block, FormatJavadocReference reference) {", "+\t\tint maxColumn = this.formatter.preferences.comment_line_length + 1;", "-\t\tStringBuffer tokensBuffer = new StringBuffer();", "+\t\tboolean inlined = block.isInlined();", "+\t\tif (headerLine) maxColumn++;", "-\t\tint firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;", "-\t\tif (headerLine) firstColumn++;", "-\t\tStringBuffer indentationBuffer = null;", "-\t\tif (indentRootTags) {", "-\t\t\tint indentLevel = this.indentationLevel;", "-\t\t\tint indentations = this.numberOfIndentations;", "-\t\t\tthis.numberOfIndentations += (BLOCK_LINE_PREFIX_LENGTH / this.indentationSize) + 1;", "-\t\t\tthis.indentationLevel = this.numberOfIndentations * this.indentationSize;", "-\t\t\tint currentColumn = this.column;", "-\t\t\tthis.column = firstColumn;", "-\t\t\tif (indentParamTag) {", "-\t\t\t\tthis.indentationLevel += this.indentationSize;", "-\t\t\t\tthis.numberOfIndentations++;", "-\t\t\t}", "-\t\t\tprintIndentationIfNecessary(indentationBuffer = new StringBuffer());", "-\t\t\tfirstColumn = this.indentationLevel + 1;", "-\t\t\tthis.column = currentColumn;", "-\t\t\tthis.indentationLevel = indentLevel;", "-\t\t\tthis.numberOfIndentations = indentations;", "-\t\t}", "-", "-\t\t// Scan the text token per token to compact it and size it the max line length", "-\t\tint maxColumn = this.formatter.preferences.comment_line_length + 1;", "+\t\tthis.scanner.resetTo(block.tagEnd+1, reference.sourceEnd);", "+\t\tStringBuffer buffer = new StringBuffer();", "+\t\tboolean needFormat = false;", "-\t\tthis.scanner.resetTo(reference.sourceStart, reference.sourceEnd);", "+\t\tint spacePosition = -1;", "+\t\tString newLineString = null;", "+\t\tStringBuffer newLineBuffer = null;", "+\t\tint firstColumn = -1;", "+\t    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;", "-\t\t\t\t\t\tbuffer.append(tokensBuffer);", "-\t\t\t\t\t\tthis.column += tokensBuffer.length();", "-\t\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\t\t\tif (CharOperation.indexOf('\\n', this.scanner.source, this.scanner.startPosition, this.scanner.getCurrentTokenEndPosition()) >= 0) {", "-\t\t\t\t\t\t\t// consume line break", "-\t\t\t\t\t\t\tloop: while (true) {", "-\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "-\t\t\t\t\t\t\t\tswitch (token) {", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "-\t\t\t\t\t\t\t\t\t\tpreviousToken = token; // will not insert space", "-\t\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tif (previousToken != -1 || tokenLength > 1 || this.scanner.currentCharacter != ' ') needFormat = true;", "+\t\t\t\t\t\tif (previousToken == -1) { // space before reference", "+\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\tthis.column++;", "-\t\t\t\t\t\tpreviousToken = token;", "-\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\tif (previousToken == TerminalTokens.TokenNameCOMMA) { // space between method arguments", "+\t\t\t\t\t\t\tspacePosition = buffer.length();", "+\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\tthis.column++; // space before reference", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tpreviousToken = token;", "-\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tif (!inlined && spacePosition > 0 && (this.column+tokenLength) > maxColumn) {", "+\t\t\t\t\t\t\t// not enough space on the line", "+\t\t\t\t\t\t\tthis.lastNumberOfNewLines++;", "+\t\t\t\t\t\t\tthis.line++;", "+\t\t\t\t\t\t\tif (newLineString == null) {", "+\t\t\t\t\t\t\t\tnewLineBuffer = new StringBuffer(this.lineSeparator);", "+\t\t\t\t\t\t    \tthis.column = 1;", "+\t\t\t\t\t\t    \tprintIndentationIfNecessary(newLineBuffer);", "+\t\t\t\t\t    \t\tnewLineBuffer.append(BLOCK_LINE_PREFIX);", "+\t\t\t\t\t    \t\tthis.column += BLOCK_LINE_PREFIX_LENGTH;", "+\t\t\t\t\t\t\t\tif (this.commentIndentation != null) {", "+\t\t\t\t\t\t\t    \tnewLineBuffer.append(this.commentIndentation);", "+\t\t\t\t\t\t\t    \tthis.column += this.commentIndentation.length();", "+\t\t\t\t\t\t    \t}", "+\t\t\t\t\t\t    \tnewLineString = newLineBuffer.substring(0, newLineBuffer.length()-1); // remove last space as buffer will be inserted before a space", "+\t\t\t\t\t\t    \tfirstColumn = this.column;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tthis.column = firstColumn;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.column = firstColumn + buffer.length() - spacePosition - 1;", "+\t\t\t\t\t\t\tbuffer.insert(spacePosition, newLineString);", "+\t\t\t\t\t\t\tif (headerLine) {", "+\t\t\t\t\t\t\t\theaderLine = false;", "+\t\t\t\t\t\t\t\tmaxColumn--;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbuffer.append(this.scanner.source, this.scanner.startPosition, tokenLength);", "+\t\t\t    \t\tthis.column += tokenLength;", "+\t\t\t    \t\tbreak;", "+\t\t\t\tpreviousToken = token;", "-\t\t\t\tcontinue;", "+\t\t\t\t// does not happen as syntax is correct", "-\t\t\tint tokenStart = this.scanner.getCurrentTokenStartPosition();", "-    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;", "-    \t\tint lastColumn = this.column + tokensBuffer.length() + tokenLength;", "-    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE || previousToken == -1;", "-    \t\tif (insertSpace) lastColumn++;", "-    \t\tif (headerLine) {", "-    \t\t\t// special case when text is on the same line of the javadoc's header", "-    \t\t\tif (lastColumn > maxColumn)  {", "-    \t\t\t\tlastColumn--; // new line gives an extra character", "-    \t\t\t}", "-    \t\t}", "-\t\t\tif (lastColumn > maxColumn) {", "-\t\t    \tString tokensString = tokensBuffer.toString().trim();", "-\t\t    \tint indentLength = indentationBuffer==null ? 0 : indentationBuffer.length();", "-\t\t\t\tif ((firstColumn-1+indentLength+tokensString.length()+tokenLength) > maxColumn) {", "-\t\t\t\t\t// there won't be enough room even if we break the line before the buffered tokens", "-\t\t\t\t\t// So add the buffered tokens now", "-\t\t\t\t\tif (buffer.length() == 0) {", "-\t\t\t\t\t\tbuffer.append(' ');", "-\t\t\t\t\t\tthis.column++;", "-\t\t\t\t\t}", "-\t\t\t\t\tbuffer.append(tokensString);", "-\t\t\t\t\tthis.column += tokensString.length();", "-\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\t}", "-\t\t\t\t// not enough space on the line", "-\t\t\t\tthis.lastNumberOfNewLines++;", "-\t\t\t\tthis.line++;", "-\t\t    \tbuffer.append(this.lineSeparator);", "-\t\t    \tthis.column = 1;", "-\t\t    \tprintIndentationIfNecessary(buffer);", "-\t    \t\tbuffer.append(BLOCK_LINE_PREFIX);", "-\t\t    \tthis.column = headerLine ? firstColumn-1 : firstColumn;", "-\t\t    \tif (indentationBuffer != null) {", "-\t\t    \t\tbuffer.append(indentationBuffer);", "-\t\t    \t}", "-\t\t    \tif (tokensBuffer.length() > 0) {", "-\t\t\t\t\tbuffer.append(tokensString);", "-\t\t\t\t\tthis.column += tokensString.length();", "-\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t    \t}", "-\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "-\t\t\t\tthis.column += tokenLength;", "-\t\t\t\tif (headerLine) {", "-\t\t\t\t\tfirstColumn--;", "-\t\t\t\t\theaderLine = false;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t// append token to the line", "-\t\t\t\tif (insertSpace) {", "-\t\t\t\t\ttokensBuffer.append(' ');", "-\t\t\t\t}", "-\t\t\t\ttokensBuffer.append(this.scanner.source, tokenStart, tokenLength);", "-\t\t\t}", "-\t\t\tpreviousToken = token;", "-\t\tif (tokensBuffer.length() > 0) {", "-\t\t\tbuffer.append(tokensBuffer);", "-\t\t\tthis.column += tokensBuffer.length();", "+\t\tif (needFormat) {", "+\t\t    addReplaceEdit(block.tagEnd+1, reference.sourceEnd, buffer.toString());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e45f4e3332074e92a9c5ff6ba5059270", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8bd987839355c299213c95f3874a2e3574283d9c", "commitAfterChange": "76b6723dbe61d0b9874754d0d6572d1a4d8c0cbc", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 73, "signatureBeforeChange": " \tprivate void printJavadocTextLine(StringBuffer buffer, int textStart, int textEnd, FormatJavadocBlock block, boolean firstText, boolean needIndentation, boolean isHtmlTag)", "signatureAfterChange": " \tprivate void printJavadocTextLine(StringBuffer buffer, int textStart, int textEnd, FormatJavadocBlock block, boolean firstText, boolean needIndentation, boolean isHtmlTag)", "diff": ["-\t\tboolean indentRootTags = this.formatter.preferences.comment_indent_root_tags && !block.isInDescription();", "-\t\tboolean indentParamTag = this.formatter.preferences.comment_indent_parameter_description && block.isInParamTag();", "-\t\tif (headerLine) firstColumn++;", "-\t\tStringBuffer indentationBuffer = null;", "-\t\tif (indentRootTags) {", "-\t\t\tint indentLevel = this.indentationLevel;", "-\t\t\tint indentations = this.numberOfIndentations;", "-\t\t\tthis.numberOfIndentations += (BLOCK_LINE_PREFIX_LENGTH / this.indentationSize) + 1;", "-\t\t\tthis.indentationLevel = this.numberOfIndentations * this.indentationSize;", "-\t\t\tint currentColumn = this.column;", "-\t\t\tthis.column = firstColumn;", "-\t\t\tif (indentParamTag) {", "-\t\t\t\tthis.indentationLevel += this.indentationSize;", "-\t\t\t\tthis.numberOfIndentations++;", "-\t\t\t}", "-\t\t\tprintIndentationIfNecessary(indentationBuffer = new StringBuffer());", "-\t\t\tif (needIndentation) {", "-\t\t\t\tthis.column = firstColumn;", "-\t\t\t\tprintIndentationIfNecessary(buffer);", "-\t\t\t}", "-\t\t\tfirstColumn = this.indentationLevel + 1;", "-\t\t\tthis.column = currentColumn < firstColumn ? firstColumn : currentColumn;", "-\t\t\tthis.indentationLevel = indentLevel;", "-\t\t\tthis.numberOfIndentations = indentations;", "-\t\t} else if (this.column < firstColumn) {", "+\t\tint maxColumn = this.formatter.preferences.comment_line_length + 1;", "+\t\tif (headerLine) {", "+\t\t\tfirstColumn++;", "+\t\t\tmaxColumn++;", "+\t\t}", "+\t\tif (needIndentation && this.commentIndentation != null) {", "+\t\t\tbuffer.append(this.commentIndentation);", "+\t    \tthis.column += this.commentIndentation.length();", "+\t\t}", "+\t\tif (this.column < firstColumn) {", "-\t\tint maxColumn = this.formatter.preferences.comment_line_length + 1;", "+\t\tString newLineString = null;", "-\t\t\tboolean openedString  =false;", "-\t\t\t\t\tboolean insertSpace = (previousToken == TerminalTokens.TokenNameWHITESPACE || (this.scanner.startPosition == textStart && this.column > firstColumn && !firstText)) && !isHtmlTag;", "-\t\t\t\t\tString msg = iie.getMessage();", "-\t\t\t\t\tif (msg == Scanner.INVALID_CHARACTER_CONSTANT) {", "-\t\t\t\t\t\tif (insertSpace) {", "-\t\t\t\t\t\t\ttokensBuffer.append(' ');", "+\t\t\t\t\tboolean insertSpace = (previousToken == TerminalTokens.TokenNameWHITESPACE || this.needSpace) && !isHtmlTag && !textOnNewLine;", "+\t\t    \t\tif (insertSpace) {", "+\t\t    \t\t\ttokensBuffer.append(' ');", "+\t\t    \t\t}", "+\t\t\t\t\tint restart = this.scanner.startPosition;", "+\t\t\t\t\tthis.scanner.resetTo(restart, textEnd);", "+\t\t    \t\tchar ch = (char) this.scanner.getNextChar();", "+\t\t\t\t\twhile (!this.scanner.atEnd() && !ScannerHelper.isWhitespace(ch)) {", "+\t\t\t\t\t\ttokensBuffer.append(ch);", "+\t\t\t\t\t\tif (this.scanner.atEnd()) {", "+\t\t\t\t\t\t\tpreviousToken = TerminalTokens.TokenNameEOF;", "+\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\ttokensBuffer.append('\\'');", "-\t\t\t\t\t} else if (msg == Scanner.INVALID_CHAR_IN_STRING) {", "-\t\t\t\t\t\tif (openedString) {", "-\t\t\t\t\t\t\topenedString = false;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (insertSpace) {", "-\t\t\t\t\t\t\t\ttokensBuffer.append(' ');", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\topenedString = true;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\ttokensBuffer.append('\"');", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// skip failure", "+\t\t\t\t\t\trestart = this.scanner.currentPosition;", "+\t\t\t\t\t\tch = (char) this.scanner.getNextChar();", "-\t\t\t\t\t// Need to retrieve correct position", "-\t\t\t\t\tthis.scanner.resetTo(this.scanner.startPosition, textEnd);", "-\t\t\t\t\tthis.scanner.getNextChar();", "-\t\t\t\t\tpreviousToken = 1;", "+\t\t\t\t\t// restart at the beginning of the whitespace", "+\t\t\t\t\tif (this.scanner.atEnd()) {", "+\t\t\t\t\t\ttokensBuffer.append(ch);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.scanner.resetTo(restart, textEnd);", "+\t\t\t\t\t}", "-\t    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE || (tokenStart == textStart && this.column > firstColumn && !(firstText || isHtmlTag));", "+\t    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;", "+\t\t\t\tboolean insertSpace = (previousToken == TerminalTokens.TokenNameWHITESPACE || this.needSpace) && !textOnNewLine;", "+\t\t\t\tString tokensBufferString = tokensBuffer.toString().trim();", "-\t\t\t\t\t\tpreviousToken = token;", "-\t\t\t\t\t\t\tbuffer.append(tokensBuffer);", "-\t\t\t\t\t\t\tthis.column += tokensBufferLength;", "+\t\t\t\t\t\t\tboolean shouldSplit = (this.column+tokensBufferLength) > maxColumn // the max length is reached", "+\t\t\t\t\t\t\t\t&& !isHtmlTag", "+\t\t\t\t\t\t\t\t&& (insertSpace || tokensBufferLength > 1) // allow to split at the beginning only when starting with an identifier or a token with a length > 1", "+\t\t\t\t\t\t\t\t&& tokensBufferString.charAt(0) != '@'; // avoid to split just before a '@'", "+\t\t\t\t\t\t\tif (shouldSplit) {", "+\t\t\t\t\t\t\t\tthis.lastNumberOfNewLines++;", "+\t\t\t\t\t\t\t\tthis.line++;", "+\t\t\t\t\t\t\t\tif (newLineString == null) {", "+\t\t\t\t\t\t\t\t\tStringBuffer newLineBuffer = new StringBuffer(this.lineSeparator);", "+\t\t\t\t\t\t\t    \tthis.column = 1;", "+\t\t\t\t\t\t\t    \tprintIndentationIfNecessary(newLineBuffer);", "+\t\t\t\t\t\t    \t\tnewLineBuffer.append(BLOCK_LINE_PREFIX);", "+\t\t\t\t\t\t\t    \tthis.column += BLOCK_LINE_PREFIX_LENGTH;", "+\t\t\t\t\t\t\t\t\tif (this.commentIndentation != null) {", "+\t\t\t\t\t\t\t\t\t\tnewLineBuffer.append(this.commentIndentation);", "+\t\t\t\t\t\t\t\t    \tthis.column += this.commentIndentation.length();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t    \t\tfirstColumn = this.column;", "+\t\t\t\t\t\t    \t\tnewLineString = newLineBuffer.toString();", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.column = firstColumn;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbuffer.append(newLineString);", "+\t\t\t\t\t\t\t\tbuffer.append(tokensBufferString);", "+\t\t\t\t\t\t\t\tthis.column += tokensBufferString.length();", "+\t\t\t\t\t\t\t\tif (headerLine) {", "+\t\t\t\t\t\t\t\t\tfirstColumn--;", "+\t\t\t\t\t\t\t\t\tmaxColumn--;", "+\t\t\t\t\t\t\t\t\theaderLine = false;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tbuffer.append(tokensBuffer);", "+\t\t\t\t\t\t\t\tthis.column += tokensBufferLength;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tpreviousToken = token;", "-\t    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;", "-\t    \t\tif (headerLine) {", "-\t    \t\t\t// special case when text is on the same line of the javadoc's header", "-\t    \t\t\tif (lastColumn > maxColumn)  {", "-\t    \t\t\t\tlastColumn--; // new line gives an extra character", "-\t    \t\t\t\tthis.lastNumberOfNewLines++; // the javadoc will become multi lines", "-\t    \t\t\t\tthis.line++;", "-\t    \t\t\t}", "-\t    \t\t}", "-\t\t\t\tif (lastColumn > maxColumn && token != TerminalTokens.TokenNameAT && (tokensBufferLength == 0 || tokensBuffer.charAt(tokensBufferLength-1) != '@')) {", "+\t\t\t\tboolean shouldSplit = lastColumn > maxColumn // the max length is reached", "+\t\t\t\t\t&& (!isHtmlTag || previousToken == -1) // not an html tag or just at the beginning of it", "+\t\t\t\t\t&& token != TerminalTokens.TokenNameAT && (tokensBufferLength == 0 || tokensBuffer.charAt(tokensBufferLength-1) != '@'); // avoid to split just before a '@'", "+\t\t\t\tif (shouldSplit) {", "-\t\t\t\t\tif (!isHtmlTag && tokensBufferLength > 0 && (firstColumn+tokensBufferLength+tokenLength) >= maxColumn) {", "+\t\t\t\t\tif ((tokensBufferLength > 0 || tokenLength < maxColumn) && !isHtmlTag && tokensBufferLength > 0 && (firstColumn+tokensBufferLength+tokenLength) >= maxColumn) {", "-\t\t\t\t\tif (!textOnNewLine) {", "-\t\t\t\t\t\tif (headerLine && lastColumn == this.column) {", "-\t\t\t\t\t\t\tthis.lastNumberOfNewLines++;", "-\t\t\t\t\t\t\tthis.line++;", "+\t\t\t\t\tif ((tokensBufferLength > 0 || tokenLength < maxColumn) && (!textOnNewLine || !firstText)) {", "+\t\t\t\t\t\tthis.lastNumberOfNewLines++;", "+\t\t\t\t\t\tthis.line++;", "+\t\t\t\t\t\tif (newLineString == null) {", "+\t\t\t\t\t\t\tStringBuffer newLineBuffer = new StringBuffer(this.lineSeparator);", "+\t\t\t\t\t    \tthis.column = 1;", "+\t\t\t\t\t    \tprintIndentationIfNecessary(newLineBuffer);", "+\t\t\t\t    \t\tnewLineBuffer.append(BLOCK_LINE_PREFIX);", "+\t\t\t\t\t    \tthis.column += BLOCK_LINE_PREFIX_LENGTH;", "+\t\t\t\t\t\t\tif (this.commentIndentation != null) {", "+\t\t\t\t\t\t\t\tnewLineBuffer.append(this.commentIndentation);", "+\t\t\t\t\t\t    \tthis.column += this.commentIndentation.length();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t    \t\tfirstColumn = this.column;", "+\t\t\t\t    \t\tnewLineString = newLineBuffer.toString();", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.column = firstColumn;", "-\t\t\t\t    \tbuffer.append(this.lineSeparator);", "-\t\t\t\t    \tthis.column = 1;", "-\t\t\t\t    \tprintIndentationIfNecessary(buffer);", "-\t\t\t    \t\tbuffer.append(BLOCK_LINE_PREFIX);", "-\t\t\t\t    \tthis.column = headerLine ? firstColumn-1 : firstColumn;", "-\t\t\t\t    \tif (indentationBuffer != null) {", "-\t\t\t\t    \t\tbuffer.append(indentationBuffer);", "-\t\t\t\t    \t}", "+\t\t\t\t\t\tbuffer.append(newLineString);", "-\t\t\t    \t\tString tokensString = tokensBuffer.toString().trim();", "+\t\t\t    \t\tString tokensString = tokensBufferString;", "+\t\t\t\t\t\tmaxColumn--;", "+    \t\t\tthis.needSpace = false;", "+    \t\t\tif (headerLine && lastColumn == maxColumn && this.scanner.atEnd()) {", "+\t\t\t\t\tthis.lastNumberOfNewLines++;", "+\t\t\t\t\tthis.line++;", "+    \t\t\t}"]}], "num": 31541}