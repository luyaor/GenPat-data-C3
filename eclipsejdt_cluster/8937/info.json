{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "42b16f6c6543fe0a0fcaac7419fd2b27", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "27082451f1f7995829abc0f25f345c83", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "e733dacf7e2cb0f1c468842218b8cf0fff8a2c3b", "commitAfterChange": "ef98b1110b7ab3f8a6089643c80689cd9cb542d0", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tprivate String getPreserveEmptyLines(int count)", "signatureAfterChange": " \tprivate String getPreserveEmptyLines(int count)", "diff": ["+\t\t\t\t\t// Reset indentation level to the location output", "+\t\t\t\t\tthis.indentationLevel = this.currentAlignment.location.outputIndentationLevel;", "+\t\t\t\t\tthis.numberOfIndentations = this.currentAlignment.location.numberOfIndentations;", "+\t\t\t\t\tthis.formatter.lastLocalDeclarationSourceStart = this.currentAlignment.location.lastLocalDeclarationSourceStart;", "+\t\t\t\t\t// Create new line keeping the existing indentation", "-\t\t\t\t\tif (this.currentAlignment.useBreakIndentation) {", "+\t\t\t\t\tint currentColumn = getCurrentIndentation(this.scanner.currentPosition);", "+\t\t\t\t\tAlignment rootAlignment = this.currentAlignment;", "+\t\t\t\t\twhile (rootAlignment.enclosing != null) {", "+\t\t\t\t\t\trootAlignment = rootAlignment.enclosing;", "+\t\t\t\t\t}", "+\t\t\t\t\tLocation location = rootAlignment.location;", "+\t\t\t\t\tif (currentColumn > location.inputColumn) {", "-\t\t\t\t\t\tthis.indentationLevel = this.currentAlignment.breakIndentationLevel;", "+\t\t\t\t\t\tthis.indentationLevel += currentColumn - location.inputColumn;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7ce83622299de4e0fc9f66e3a617fa8e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "db9994e6bbc68b36b6835d66f1e05a3b040360e2", "commitAfterChange": "01c814e6bd45b7fbd49eec3a490338a17c21d9fb", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "  private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[][][] missingTypeNames)", "signatureAfterChange": "  private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[][][] missingTypeNames)", "diff": ["-\t\t\t\t\texceptions[i] = this.environment.getTypeFromConstantPoolName(exceptionTypes[i], 0, -1, false, missingTypeNames);", "+\t\t\t\t\texceptions[i] = this.environment.getTypeFromConstantPoolName(exceptionTypes[i], 0, -1, false, missingTypeNames, walker.toThrows(i));", "-// \t\tNote(stephan): currently the compiler is not interested in retrieving receiver annotations, here is how we would do it:", "-//\t\tIBinaryAnnotation[] receiverAnnotations = walker.toReceiver().getAnnotationsAtCursor();", "-\t\t", "-\t\t\t\t\t\texceptions[i] = this.environment.getTypeFromConstantPoolName(exceptionTypes[i], 0, -1, false, missingTypeNames);", "+\t\t\t\t\t\texceptions[i] = this.environment.getTypeFromConstantPoolName(exceptionTypes[i], 0, -1, false, missingTypeNames, walker.toThrows(i));", "-\tif (this.environment.globalOptions.storeAnnotations)", "+\t", "+\tIBinaryAnnotation[] receiverAnnotations = walker.toReceiver().getAnnotationsAtCursor();", "+\tif (receiverAnnotations != null && receiverAnnotations.length > 0) {", "+\t\tresult.receiver = this.environment.createAnnotatedType(this, createAnnotations(receiverAnnotations, this.environment, missingTypeNames));", "+\t}", "+", "+\tif (this.environment.globalOptions.storeAnnotations) {", "+\t\tIBinaryAnnotation[] annotations = method.getAnnotations();", "+\t    if (annotations == null || annotations.length == 0)", "+\t    \tif (method.isConstructor())", "+\t    \t\tannotations = walker.toMethodReturn().getAnnotationsAtCursor(); // FIXME: When both exist, order could become an issue.", "-\t\t\tcreateAnnotations(method.getAnnotations(), this.environment, missingTypeNames),", "+\t\t\tcreateAnnotations(annotations, this.environment, missingTypeNames),", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7dc822525f66727d4265bfc446229c91", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java", "commitBeforeChange": "fe340d4e08886c2e5ab7c8b78c5aa34503b63a80", "commitAfterChange": "5c4eafbe7595640e5dc9f4b4ddb502602d61de2e", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic void set(Map settings)", "signatureAfterChange": "  \tpublic void set(Map settings)", "diff": ["-\t\tfinal Object commentClearBlankLinesOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_COMMENT_CLEAR_BLANK_LINES);", "-\t\tif (commentClearBlankLinesOption != null) {", "-\t\t\tthis.comment_clear_blank_lines = DefaultCodeFormatterConstants.TRUE.equals(commentClearBlankLinesOption);", "+\t\tfinal Object commentClearBlankLinesInJavadocCommentOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_COMMENT_CLEAR_BLANK_LINES_IN_JAVADOC_COMMENT);", "+\t\tif (commentClearBlankLinesInJavadocCommentOption != null) {", "+\t\t\tthis.comment_clear_blank_lines_in_javadoc_comment = DefaultCodeFormatterConstants.TRUE.equals(commentClearBlankLinesInJavadocCommentOption);", "-\t\tfinal Object commentFormatOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_COMMENT_FORMAT);", "-\t\tif (commentFormatOption != null) {", "-\t\t\tthis.comment_format = DefaultCodeFormatterConstants.TRUE.equals(commentFormatOption);", "+\t\tfinal Object commentClearBlankLinesInBlockCommentOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_COMMENT_CLEAR_BLANK_LINES_IN_BLOCK_COMMENT);", "+\t\tif (commentClearBlankLinesInBlockCommentOption != null) {", "+\t\t\tthis.comment_clear_blank_lines_in_block_comment = DefaultCodeFormatterConstants.TRUE.equals(commentClearBlankLinesInBlockCommentOption);", "+\t\tfinal Object commentFormatJavadocCommentOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_COMMENT_FORMAT_JAVADOC_COMMENT);", "+\t\tif (commentFormatJavadocCommentOption != null) {", "+\t\t\tthis.comment_format_javadoc_comment = DefaultCodeFormatterConstants.TRUE.equals(commentFormatJavadocCommentOption);", "+\t\t}", "+\t\tfinal Object commentFormatBlockCommentOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_COMMENT_FORMAT_BLOCK_COMMENT);", "+\t\tif (commentFormatBlockCommentOption != null) {", "+\t\t\tthis.comment_format_block_comment = DefaultCodeFormatterConstants.TRUE.equals(commentFormatBlockCommentOption);", "+\t\t}", "+\t\tfinal Object commentFormatLineCommentOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_COMMENT_FORMAT_LINE_COMMENT);", "+\t\tif (commentFormatLineCommentOption != null) {", "+\t\t\tthis.comment_format_line_comment = DefaultCodeFormatterConstants.TRUE.equals(commentFormatLineCommentOption);", "+\t\t}\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c4598096e7ea04058aa0a7adaf54635b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "a11ec54f2e1e149e77b968382e79f482cc29add9", "commitAfterChange": "831d96bc5763622ed503192c35bfd6688abedd96", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "  \tpublic TypeVariableBinding[] createTypeVariables(TypeParameter[] typeParameters, Binding declaringElement)", "signatureAfterChange": "  \tpublic TypeVariableBinding[] createTypeVariables(TypeParameter[] typeParameters, Binding declaringElement)", "diff": ["+\t\t\tif ((typeParameter.bits & ASTNode.HasTypeAnnotations) != 0) {", "+\t\t\t\tswitch(declaringElement.kind()) {", "+\t\t\t\t\tcase Binding.METHOD :", "+\t\t\t\t\t\tMethodBinding methodBinding = (MethodBinding) declaringElement;", "+\t\t\t\t\t\tAbstractMethodDeclaration sourceMethod = methodBinding.sourceMethod();", "+\t\t\t\t\t\tif (sourceMethod != null) {", "+\t\t\t\t\t\t\tsourceMethod.bits |= ASTNode.HasTypeAnnotations;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Binding.TYPE :", "+\t\t\t\t\t\tif (declaringElement instanceof SourceTypeBinding) {", "+\t\t\t\t\t\t\tSourceTypeBinding sourceTypeBinding = (SourceTypeBinding) declaringElement;", "+\t\t\t\t\t\t\tTypeDeclaration typeDeclaration = sourceTypeBinding.scope.referenceContext;", "+\t\t\t\t\t\t\tif (typeDeclaration != null) {", "+\t\t\t\t\t\t\t\ttypeDeclaration.bits |= ASTNode.HasTypeAnnotations;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 8937}