{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c886db771092d637d2c28eeb2106a629", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39636cb830d60b5a069891cfd20abe1f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r \tprivate void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "signatureAfterChange": "\r private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "diff": ["+ */\r", "+private void buildFromPotentialSubtypes(String[] allPotentialSubTypes) {\r", "+\t// sort by projects\r", "+\t/*\r", "+\t * NOTE: To workaround pb with hierarchy resolver that requests top  \r", "+\t * level types in the process of caching an enclosing type, this needs to\r", "+\t * be sorted in reverse alphabetical order so that top level types are cached\r", "+\t * before their inner types.\r", "-\tprivate void buildFromPotentialSubtypes(String[] allPotentialSubTypes) {\r", "-\t\t// sort by projects\r", "-\t\t/*\r", "-\t\t * NOTE: To workaround pb with hierarchy resolver that requests top  \r", "-\t\t * level types in the process of caching an enclosing type, this needs to\r", "-\t\t * be sorted in reverse alphabetical order so that top level types are cached\r", "-\t\t * before their inner types.\r", "-\t\t */\r", "-\t\tUtil.sortReverseOrder(allPotentialSubTypes);\r", "+\tUtil.sortReverseOrder(allPotentialSubTypes);\r", "+\t\r", "+\tVector infos = new Vector();\r", "+\tVector units = new Vector();\r", "-\t\tVector infos = new Vector();\r", "-\t\tVector units = new Vector();\r", "+\tIType focusType = this.getType();\r", "-\t\tIType focusType = this.getType();\r", "-\r", "-\t\t// create element infos for subtypes\r", "-\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "-\t\tIWorkspace workspace = focusType.getJavaProject().getProject().getWorkspace();\r", "-\t\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "-\t\tIJavaProject currentProject = null;\r", "-\t\tfor (int i = 0, length = allPotentialSubTypes.length; i < length; i++) {\r", "-\t\t\ttry {\r", "-\t\t\t\tString resourcePath = allPotentialSubTypes[i];\r", "-\t\t\t\tOpenable handle = factory.createOpenable(resourcePath);\r", "-\t\t\t\tif (handle == null)\r", "-\t\t\t\t\tcontinue; // match is outside classpath\r", "-\t\t\t\tIJavaProject project = handle.getJavaProject();\r", "-\t\t\t\tif (currentProject == null) {\r", "-\t\t\t\t\tcurrentProject = project;\r", "-\t\t\t\t\tinfos = new Vector(5);\r", "-\t\t\t\t\tunits = new Vector(5);\r", "-\t\t\t\t} else\r", "-\t\t\t\t\tif (!currentProject.equals(project)) {\r", "-\t\t\t\t\t\tthis.buildForProject((JavaProject) currentProject, infos, units);\r", "-\t\t\t\t\t\tcurrentProject = project;\r", "-\t\t\t\t\t\tinfos = new Vector(5);\r", "-\t\t\t\t\t\tunits = new Vector(5);\r", "-\t\t\t\t\t}\r", "-\t\t\t\tif (handle.isOpen()) {\r", "-\t\t\t\t\t// reuse the info from the java model cache\r", "-\t\t\t\t\tif (handle instanceof CompilationUnit) {\r", "-\t\t\t\t\t\tthis.addInfoFromOpenCU((CompilationUnit) handle, infos);\r", "-\t\t\t\t\t} else\r", "-\t\t\t\t\t\tif (handle instanceof ClassFile) {\r", "-\t\t\t\t\t\t\tthis.addInfoFromOpenClassFile((ClassFile) handle, infos);\r", "-\t\t\t\t\t\t}\r", "+\t// create element infos for subtypes\r", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\tIWorkspace workspace = focusType.getJavaProject().getProject().getWorkspace();\r", "+\tHandleFactory factory = new HandleFactory(workspace.getRoot(), manager);\r", "+\tIJavaProject currentProject = null;\r", "+\tfor (int i = 0, length = allPotentialSubTypes.length; i < length; i++) {\r", "+\t\ttry {\r", "+\t\t\tString resourcePath = allPotentialSubTypes[i];\r", "+\t\t\tOpenable handle = factory.createOpenable(resourcePath);\r", "+\t\t\tif (handle == null) continue; // match is outside classpath\r", "+\t\t\tIJavaProject project = handle.getJavaProject();\r", "+\t\t\tif (currentProject == null) {\r", "+\t\t\t\tcurrentProject = project;\r", "+\t\t\t\tinfos = new Vector(5);\r", "+\t\t\t\tunits = new Vector(5);\r", "+\t\t\t} else if (!currentProject.equals(project)) {\r", "+\t\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units);\r", "+\t\t\t\tcurrentProject = project;\r", "+\t\t\t\tinfos = new Vector(5);\r", "+\t\t\t\tunits = new Vector(5);\r", "+\t\t\t}\r", "+\t\t\tif (handle.isOpen()) {\r", "+\t\t\t\t// reuse the info from the java model cache\r", "+\t\t\t\tif (handle instanceof CompilationUnit) {\r", "+\t\t\t\t\tthis.addInfoFromOpenCU((CompilationUnit)handle, infos);\r", "+\t\t\t\t} else if (handle instanceof ClassFile) {\r", "+\t\t\t\t\tthis.addInfoFromOpenClassFile((ClassFile)handle, infos);\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\tHierarchyBinaryType binaryType = (HierarchyBinaryType) binariesFromIndexMatches.get(resourcePath);\r", "+\t\t\t\tif (binaryType != null){\r", "+\t\t\t\t\tthis.addInfoFromBinaryIndexMatch(handle, binaryType, infos);\r", "-\t\t\t\t\tHierarchyBinaryType binaryType =\r", "-\t\t\t\t\t\t(HierarchyBinaryType) binariesFromIndexMatches.get(resourcePath);\r", "-\t\t\t\t\tif (binaryType != null) {\r", "-\t\t\t\t\t\tthis.addInfoFromBinaryIndexMatch(handle, binaryType, infos);\r", "+\t\t\t\t\t// create a temporary info\r", "+\t\t\t\t\tIJavaElement pkg = handle.getParent();\r", "+\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "+\t\t\t\t\tif (root.isArchive()) {\r", "+\t\t\t\t\t\t// class file in a jar\r", "+\t\t\t\t\t\tthis.createInfoFromClassFileInJar(handle, infos);\r", "-\t\t\t\t\t\t// create a temporary info\r", "-\t\t\t\t\t\tIJavaElement pkg = handle.getParent();\r", "-\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot) pkg.getParent();\r", "-\t\t\t\t\t\tif (root.isArchive()) {\r", "-\t\t\t\t\t\t\t// class file in a jar\r", "-\t\t\t\t\t\t\tthis.createInfoFromClassFileInJar(handle, infos);\r", "-\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t// file in a directory\r", "-\t\t\t\t\t\t\tIPath path = new Path(resourcePath);\r", "-\t\t\t\t\t\t\tIFile file = workspace.getRoot().getFile(path);\r", "-\t\t\t\t\t\t\tString osPath = file.getLocation().toOSString();\r", "+\t\t\t\t\t\t// file in a directory\r", "+\t\t\t\t\t\tIPath path = new Path(resourcePath);\r", "+\t\t\t\t\t\tIFile file = workspace.getRoot().getFile(path);\r", "+\t\t\t\t\t\tIPath location = file.getLocation();\r", "+\t\t\t\t\t\tif (location != null){\r", "+\t\t\t\t\t\t\tString osPath = location.toOSString();\r", "-\t\t\t\t\t\t\t} else\r", "-\t\t\t\t\t\t\t\tif (handle instanceof ClassFile) {\r", "-\t\t\t\t\t\t\t\t\t// class file in a directory\r", "-\t\t\t\t\t\t\t\t\tthis.createInfoFromClassFile(handle, osPath, infos);\r", "-\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t} else if (handle instanceof ClassFile) {\r", "+\t\t\t\t\t\t\t\t// class file in a directory\r", "+\t\t\t\t\t\t\t\tthis.createInfoFromClassFile(handle, osPath, infos);\r", "+\t\t\t\t\t\t\t}\r", "-\t\t\t\tworked(1);\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\tcontinue;\r", "+\t\t\tworked(1);\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t\tcontinue;\r", "+\t}\r", "+\ttry {\r", "+\t\tif (currentProject == null) currentProject = focusType.getJavaProject(); // case of no potential subtypes\r", "+\t\tthis.buildForProject((JavaProject)currentProject, infos, units);\r", "+\t} catch (JavaModelException e) {\r", "+\t}\r", "+\t\r", "+\t// Compute hierarchy of focus type if not already done (case of a type with potential subtypes that are not real subtypes)\r", "+\tif (!this.hierarchy.contains(focusType)) {\r", "-\t\t\tif (currentProject == null)\r", "-\t\t\t\tcurrentProject = focusType.getJavaProject(); // case of no potential subtypes\r", "-\t\t\tthis.buildForProject((JavaProject) currentProject, infos, units);\r", "+\t\t\tcurrentProject = focusType.getJavaProject();\r", "+\t\t\tthis.buildForProject((JavaProject)currentProject, new Vector(), new Vector());\r", "-\r", "-\t\t// Add focus if not already in (case of a type with no explicit super type)\r", "-\t\tif (!this.hierarchy.contains(focusType)) {\r", "-\t\t\tthis.hierarchy.addRootClass(focusType);\r", "-\t\t}\r", "+\t\r", "+\t// Add focus if not already in (case of a type with no explicit super type)\r", "+\tif (!this.hierarchy.contains(focusType)) {\r", "+\t\tthis.hierarchy.addRootClass(focusType);\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7c2158c7eb9aadcd19546f3a97934d95", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "e70a97840585a3ede400b971666912929897851b", "commitAfterChange": "f5104ea8b01f4418b9868445123db4c689077583", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "signatureAfterChange": " private void buildFromPotentialSubtypes(String[] allPotentialSubTypes, IProgressMonitor monitor)", "diff": ["-private void buildFromPotentialSubtypes(String[] allPotentialSubTypes) {", "+private void buildFromPotentialSubtypes(String[] allPotentialSubTypes, IProgressMonitor monitor) {", "-\t// create element infos for subtypes", "-\tHandleFactory factory = new HandleFactory(ResourcesPlugin.getWorkspace());", "-\tIJavaProject currentProject = null;", "-\tfor (int i = 0; i < length; i++) {", "-\t\ttry {", "-\t\t\tString resourcePath = allPotentialSubTypes[i];", "-\t\t\t", "-\t\t\t// skip duplicate paths (e.g. if focus path was injected when it was already a potential subtype)", "-\t\t\tif (i > 0 && resourcePath.equals(allPotentialSubTypes[i-1])) continue;", "-\t\t\t", "-\t\t\tOpenable handle;", "-\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(resourcePath);", "-\t\t\tif (workingCopy != null) {", "-\t\t\t\thandle = (Openable)workingCopy;", "-\t\t\t} else {", "-\t\t\t\thandle = ", "-\t\t\t\t\tresourcePath.equals(focusPath) ? ", "-\t\t\t\t\t\tfocusCU :", "-\t\t\t\t\t\tfactory.createOpenable(resourcePath, this.scope);", "-\t\t\t\tif (handle == null) continue; // match is outside classpath", "-\t\t\t}", "-\t\t\t", "-\t\t\tIJavaProject project = handle.getJavaProject();", "-\t\t\tif (currentProject == null) {", "-\t\t\t\tcurrentProject = project;", "-\t\t\t\tinfos = new ArrayList(5);", "-\t\t\t\tunits = new ArrayList(5);", "-\t\t\t} else if (!currentProject.equals(project)) {", "-\t\t\t\t// build current project", "-\t\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies);", "-\t\t\t\tcurrentProject = project;", "-\t\t\t\tinfos = new ArrayList(5);", "-\t\t\t\tunits = new ArrayList(5);", "-\t\t\t}", "-\t\t\t", "-\t\t\tthis.addInfoFromElement(handle, infos, units, resourcePath);", "-\t\t\t", "-\t\t\tworked(1);", "-\t\t} catch (JavaModelException e) {", "-\t\t\tcontinue;", "-\t\t}", "-\t}", "-\t", "-\t// build last project", "-\t\tif (currentProject == null) {", "-\t\t\t// case of no potential subtypes", "-\t\t\tcurrentProject = focusType.getJavaProject();", "-\t\t\tthis.addInfosFromType(focusType, infos);", "+\t\t// create element infos for subtypes", "+\t\tHandleFactory factory = new HandleFactory(ResourcesPlugin.getWorkspace());", "+\t\tIJavaProject currentProject = null;", "+\t\tif (monitor != null) monitor.beginTask(\"\", length*2 /* 1 for build binding, 1 for connect hierarchy*/); //$NON-NLS-1$", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\ttry {", "+\t\t\t\tString resourcePath = allPotentialSubTypes[i];", "+\t\t\t\t", "+\t\t\t\t// skip duplicate paths (e.g. if focus path was injected when it was already a potential subtype)", "+\t\t\t\tif (i > 0 && resourcePath.equals(allPotentialSubTypes[i-1])) continue;", "+\t\t\t\t", "+\t\t\t\tOpenable handle;", "+\t\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(resourcePath);", "+\t\t\t\tif (workingCopy != null) {", "+\t\t\t\t\thandle = (Openable)workingCopy;", "+\t\t\t\t} else {", "+\t\t\t\t\thandle = ", "+\t\t\t\t\t\tresourcePath.equals(focusPath) ? ", "+\t\t\t\t\t\t\tfocusCU :", "+\t\t\t\t\t\t\tfactory.createOpenable(resourcePath, this.scope);", "+\t\t\t\t\tif (handle == null) continue; // match is outside classpath", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tIJavaProject project = handle.getJavaProject();", "+\t\t\t\tif (currentProject == null) {", "+\t\t\t\t\tcurrentProject = project;", "+\t\t\t\t\tinfos = new ArrayList(5);", "+\t\t\t\t\tunits = new ArrayList(5);", "+\t\t\t\t} else if (!currentProject.equals(project)) {", "+\t\t\t\t\t// build current project", "+\t\t\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies, monitor);", "+\t\t\t\t\tcurrentProject = project;", "+\t\t\t\t\tinfos = new ArrayList(5);", "+\t\t\t\t\tunits = new ArrayList(5);", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tthis.addInfoFromElement(handle, infos, units, resourcePath);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\tcontinue;", "+\t\t\t}", "-\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies);", "-\t} catch (JavaModelException e) {", "-\t}", "-\t", "-\t// Compute hierarchy of focus type if not already done (case of a type with potential subtypes that are not real subtypes)", "-\tif (!this.hierarchy.contains(focusType)) {", "+\t\t", "+\t\t// build last project", "-\t\t\tcurrentProject = focusType.getJavaProject();", "-\t\t\tinfos = new ArrayList();", "-\t\t\tunits = new ArrayList();", "-\t\t\tthis.addInfosFromType(focusType, infos);", "-\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies);", "+\t\t\tif (currentProject == null) {", "+\t\t\t\t// case of no potential subtypes", "+\t\t\t\tcurrentProject = focusType.getJavaProject();", "+\t\t\t\tthis.addInfosFromType(focusType, infos);", "+\t\t\t}", "+\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies, monitor);", "-\t}", "-\t", "-\t// Add focus if not already in (case of a type with no explicit super type)", "-\tif (!this.hierarchy.contains(focusType)) {", "-\t\tthis.hierarchy.addRootClass(focusType);", "+\t\t", "+\t\t// Compute hierarchy of focus type if not already done (case of a type with potential subtypes that are not real subtypes)", "+\t\tif (!this.hierarchy.contains(focusType)) {", "+\t\t\ttry {", "+\t\t\t\tcurrentProject = focusType.getJavaProject();", "+\t\t\t\tinfos = new ArrayList();", "+\t\t\t\tunits = new ArrayList();", "+\t\t\t\tthis.addInfosFromType(focusType, infos);", "+\t\t\t\tthis.buildForProject((JavaProject)currentProject, infos, units, workingCopies, monitor);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Add focus if not already in (case of a type with no explicit super type)", "+\t\tif (!this.hierarchy.contains(focusType)) {", "+\t\t\tthis.hierarchy.addRootClass(focusType);", "+\t\t}", "+\t} finally {", "+\t\tif (monitor != null) monitor.done();"]}], "num": 2151}