{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "01a101fd768402ab090a9ec69664b210", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "14f1eaa886b89b9078f58ac30cdd4500", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "3091564ff71d95ca83672941f8a4ec3464344683", "commitAfterChange": "ac6c2726bc9770d7575dff83ad9611f141165280", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public int match(MethodDeclaration node, MatchingNodeSet nodeSet)", "signatureAfterChange": " public int match(ASTNode node, MatchingNodeSet nodeSet)", "diff": ["+public int match(ASTNode node, MatchingNodeSet nodeSet) {", "+\tint declarationsLevel = IMPOSSIBLE_MATCH;", "+\tif (this.pattern.findReferences) {", "+\t\tif (node instanceof ImportReference) {", "+\t\t\t// With static import, we can have static method reference in import reference", "+\t\t\tImportReference importRef = (ImportReference) node;", "+\t\t\tint length = importRef.tokens.length-1;", "+\t\t\tif (importRef.isStatic() && !importRef.onDemand && matchesName(this.pattern.selector, importRef.tokens[length])) {", "+\t\t\t\tchar[][] compoundName = new char[length][];", "+\t\t\t\tSystem.arraycopy(importRef.tokens, 0, compoundName, 0, length);", "+\t\t\t\tchar[] declaringType = CharOperation.concat(pattern.declaringQualification, pattern.declaringSimpleName, '.');", "+\t\t\t\tif (matchesName(declaringType, CharOperation.concatWith(compoundName, '.'))) {", "+\t\t\t\t\tdeclarationsLevel = ((InternalSearchPattern)this.pattern).mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn nodeSet.addMatch(node, declarationsLevel);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2e5de2872b92cac5ed9ec9c6a23362ed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/FieldLocator.java", "commitBeforeChange": "203954a19427f44b197aa09593f6f49177e09606", "commitAfterChange": "3ed9acfe644f3aa92ee72abfaf147fb3ef3a87d3", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public int match(FieldDeclaration node, MatchingNodeSet nodeSet)", "signatureAfterChange": " public int match(ASTNode node, MatchingNodeSet nodeSet)", "diff": ["+public int match(ASTNode node, MatchingNodeSet nodeSet) {", "+\tint declarationsLevel = IMPOSSIBLE_MATCH;", "+\tif (this.pattern.findReferences) {", "+\t\tif (node instanceof ImportReference) {", "+\t\t\t// With static import, we can have static field reference in import reference", "+\t\t\tImportReference importRef = (ImportReference) node;", "+\t\t\tint length = importRef.tokens.length-1;", "+\t\t\tif (importRef.isStatic() && !importRef.onDemand && matchesName(this.pattern.name, importRef.tokens[length])) {", "+\t\t\t\tchar[][] compoundName = new char[length][];", "+\t\t\t\tSystem.arraycopy(importRef.tokens, 0, compoundName, 0, length);", "+\t\t\t\tFieldPattern fieldPattern = (FieldPattern) this.pattern;", "+\t\t\t\tchar[] declaringType = CharOperation.concat(fieldPattern.declaringQualification, fieldPattern.declaringSimpleName, '.');", "+\t\t\t\tif (matchesName(declaringType, CharOperation.concatWith(compoundName, '.'))) {", "+\t\t\t\t\tdeclarationsLevel = ((InternalSearchPattern)this.pattern).mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn nodeSet.addMatch(node, declarationsLevel);", "+}"]}], "num": 37142}