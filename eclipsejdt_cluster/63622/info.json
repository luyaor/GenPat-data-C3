{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4e8535d668c64bd38e5ff85b255e5127", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82868cd0529ce746ef01373d58f27e59", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "88b7c7eb3469a024202ea445bb4a9f81206035c9", "commitAfterChange": "38981955f1b194aa266ea7fa397baf3099ab8081", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tpublic static SearchPattern createPattern(IJavaElement element, int limitTo, int matchRule)", "signatureAfterChange": " \tpublic static SearchPattern createPattern(IJavaElement element, int limitTo, int matchRule)", "diff": ["+\t\tboolean ignoreDeclaringType = false;", "+\t\tboolean ignoreReturnType = false;", "+\t\tint maskedLimitTo = limitTo & ~(IJavaSearchConstants.IGNORE_DECLARING_TYPE+IJavaSearchConstants.IGNORE_RETURN_TYPE);", "+\t\tif (maskedLimitTo == IJavaSearchConstants.DECLARATIONS || maskedLimitTo == IJavaSearchConstants.ALL_OCCURRENCES) {", "+\t\t\tignoreDeclaringType = (limitTo & IJavaSearchConstants.IGNORE_DECLARING_TYPE) != 0;", "+\t\t\tignoreReturnType = (limitTo & IJavaSearchConstants.IGNORE_RETURN_TYPE) != 0;", "+\t\t}", "+\t\tchar[] declaringSimpleName = null;", "+\t\tchar[] declaringQualification = null;", "-\t\t\t\tIType declaringClass = field.getDeclaringType();", "-\t\t\t\tchar[] declaringSimpleName = declaringClass.getElementName().toCharArray();", "-\t\t\t\tchar[] declaringQualification = declaringClass.getPackageFragment().getElementName().toCharArray();", "-\t\t\t\tchar[][] enclosingNames = enclosingTypeNames(declaringClass);", "-\t\t\t\tif (enclosingNames.length > 0)", "-\t\t\t\t\tdeclaringQualification = CharOperation.concat(declaringQualification, CharOperation.concatWith(enclosingNames, '.'), '.');", "-\t\t\t\tchar[] name = field.getElementName().toCharArray();", "-\t\t\t\tchar[] typeSimpleName;", "-\t\t\t\tchar[] typeQualification;", "-\t\t\t\tString typeSignature;", "-\t\t\t\ttry {", "-\t\t\t\t\ttypeSignature = field.getTypeSignature();", "-\t\t\t\t\tchar[] signature = typeSignature.toCharArray();", "-\t\t\t\t\tchar[] typeErasure = Signature.toCharArray(Signature.getTypeErasure(signature));", "-\t\t\t\t\tCharOperation.replace(typeErasure, '$', '.');", "-\t\t\t\t\tif ((lastDot = CharOperation.lastIndexOf('.', typeErasure)) == -1) {", "-\t\t\t\t\t\ttypeSimpleName = typeErasure;", "-\t\t\t\t\t\ttypeQualification = null;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\ttypeSimpleName = CharOperation.subarray(typeErasure, lastDot + 1, typeErasure.length);", "-\t\t\t\t\t\ttypeQualification = CharOperation.subarray(typeErasure, 0, lastDot);", "-\t\t\t\t\t\tif (!field.isBinary()) {", "-\t\t\t\t\t\t\t// prefix with a '*' as the full qualification could be bigger (because of an import)", "-\t\t\t\t\t\t\tCharOperation.concat(IIndexConstants.ONE_STAR, typeQualification);", "-\t\t\t\t\t\t}", "+\t\t\t\tif (!ignoreDeclaringType) {", "+\t\t\t\t\tIType declaringClass = field.getDeclaringType();", "+\t\t\t\t\tdeclaringSimpleName = declaringClass.getElementName().toCharArray();", "+\t\t\t\t\tdeclaringQualification = declaringClass.getPackageFragment().getElementName().toCharArray();", "+\t\t\t\t\tchar[][] enclosingNames = enclosingTypeNames(declaringClass);", "+\t\t\t\t\tif (enclosingNames.length > 0) {", "+\t\t\t\t\t\tdeclaringQualification = CharOperation.concat(declaringQualification, CharOperation.concatWith(enclosingNames, '.'), '.');", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t\tchar[] name = field.getElementName().toCharArray();", "+\t\t\t\tchar[] typeSimpleName = null;", "+\t\t\t\tchar[] typeQualification = null;", "+\t\t\t\tString typeSignature = null;", "+\t\t\t\tif (!ignoreReturnType) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\ttypeSignature = field.getTypeSignature();", "+\t\t\t\t\t\tchar[] signature = typeSignature.toCharArray();", "+\t\t\t\t\t\tchar[] typeErasure = Signature.toCharArray(Signature.getTypeErasure(signature));", "+\t\t\t\t\t\tCharOperation.replace(typeErasure, '$', '.');", "+\t\t\t\t\t\tif ((lastDot = CharOperation.lastIndexOf('.', typeErasure)) == -1) {", "+\t\t\t\t\t\t\ttypeSimpleName = typeErasure;", "+\t\t\t\t\t\t\ttypeQualification = null;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\ttypeSimpleName = CharOperation.subarray(typeErasure, lastDot + 1, typeErasure.length);", "+\t\t\t\t\t\t\ttypeQualification = CharOperation.subarray(typeErasure, 0, lastDot);", "+\t\t\t\t\t\t\tif (!field.isBinary()) {", "+\t\t\t\t\t\t\t\t// prefix with a '*' as the full qualification could be bigger (because of an import)", "+\t\t\t\t\t\t\t\tCharOperation.concat(IIndexConstants.ONE_STAR, typeQualification);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "-\t\t\t\tswitch (limitTo) {", "+\t\t\t\tswitch (maskedLimitTo) {", "-\t\t\t\t\tsearchPattern = createPackagePattern(elementName.substring(0, lastDot), limitTo, matchRule);", "+\t\t\t\t\tsearchPattern = createPackagePattern(elementName.substring(0, lastDot), maskedLimitTo, matchRule);", "-\t\t\t\t\t\t\tlimitTo,", "+\t\t\t\t\t\t\tmaskedLimitTo,", "-\t\t\t\tswitch (limitTo) {", "+\t\t\t\tswitch (maskedLimitTo) {", "-\t\t\t\tswitch (limitTo) {", "+\t\t\t\tswitch (maskedLimitTo) {", "-\t\t\t\tdeclaringClass = method.getDeclaringType();", "-\t\t\t\tdeclaringSimpleName = declaringClass.getElementName().toCharArray();", "-\t\t\t\tdeclaringQualification = declaringClass.getPackageFragment().getElementName().toCharArray();", "-\t\t\t\tenclosingNames = enclosingTypeNames(declaringClass);", "-\t\t\t\tif (enclosingNames.length > 0)", "-\t\t\t\t\tdeclaringQualification = CharOperation.concat(declaringQualification, CharOperation.concatWith(enclosingNames, '.'), '.');", "-\t\t\t\tchar[] selector = method.getElementName().toCharArray();", "-\t\t\t\tchar[] returnSimpleName;", "-\t\t\t\tchar[] returnQualification;", "-\t\t\t\tString returnSignature;", "-\t\t\t\ttry {", "-\t\t\t\t\treturnSignature = method.getReturnType();", "-\t\t\t\t\tchar[] signature = returnSignature.toCharArray();", "-\t\t\t\t\tchar[] returnErasure = Signature.toCharArray(Signature.getTypeErasure(signature));", "-\t\t\t\t\tCharOperation.replace(returnErasure, '$', '.');", "-\t\t\t\t\tif ((lastDot = CharOperation.lastIndexOf('.', returnErasure)) == -1) {", "-\t\t\t\t\t\treturnSimpleName = returnErasure;", "-\t\t\t\t\t\treturnQualification = null;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\treturnSimpleName = CharOperation.subarray(returnErasure, lastDot + 1, returnErasure.length);", "-\t\t\t\t\t\treturnQualification = CharOperation.subarray(returnErasure, 0, lastDot);", "-\t\t\t\t\t\tif (!method.isBinary()) {", "-\t\t\t\t\t\t\t// prefix with a '*' as the full qualification could be bigger (because of an import)", "-\t\t\t\t\t\t\tCharOperation.concat(IIndexConstants.ONE_STAR, returnQualification);", "-\t\t\t\t\t\t}", "+\t\t\t\tif (!ignoreDeclaringType) {", "+\t\t\t\t\tIType declaringClass = method.getDeclaringType();", "+\t\t\t\t\tdeclaringSimpleName = declaringClass.getElementName().toCharArray();", "+\t\t\t\t\tdeclaringQualification = declaringClass.getPackageFragment().getElementName().toCharArray();", "+\t\t\t\t\tchar[][] enclosingNames = enclosingTypeNames(declaringClass);", "+\t\t\t\t\tif (enclosingNames.length > 0) {", "+\t\t\t\t\t\tdeclaringQualification = CharOperation.concat(declaringQualification, CharOperation.concatWith(enclosingNames, '.'), '.');", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t\tchar[] selector = method.getElementName().toCharArray();", "+\t\t\t\tchar[] returnSimpleName = null;", "+\t\t\t\tchar[] returnQualification = null;", "+\t\t\t\tString returnSignature = null;", "+\t\t\t\tif (!ignoreReturnType) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\treturnSignature = method.getReturnType();", "+\t\t\t\t\t\tchar[] signature = returnSignature.toCharArray();", "+\t\t\t\t\t\tchar[] returnErasure = Signature.toCharArray(Signature.getTypeErasure(signature));", "+\t\t\t\t\t\tCharOperation.replace(returnErasure, '$', '.');", "+\t\t\t\t\t\tif ((lastDot = CharOperation.lastIndexOf('.', returnErasure)) == -1) {", "+\t\t\t\t\t\t\treturnSimpleName = returnErasure;", "+\t\t\t\t\t\t\treturnQualification = null;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\treturnSimpleName = CharOperation.subarray(returnErasure, lastDot + 1, returnErasure.length);", "+\t\t\t\t\t\t\treturnQualification = CharOperation.subarray(returnErasure, 0, lastDot);", "+\t\t\t\t\t\t\tif (!method.isBinary()) {", "+\t\t\t\t\t\t\t\t// prefix with a '*' as the full qualification could be bigger (because of an import)", "+\t\t\t\t\t\t\t\tCharOperation.concat(IIndexConstants.ONE_STAR, returnQualification);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "-\t\t\t\tswitch (limitTo) {", "+\t\t\t\tswitch (maskedLimitTo) {", "-\t\t\t\t\t\t\tenclosingTypeNames(type),", "+\t\t\t\t\t\t\tignoreDeclaringType ? null : enclosingTypeNames(type),", "-\t\t\t\t\t\t\tlimitTo,", "+\t\t\t\t\t\t\tmaskedLimitTo,", "-\t\t\t\tsearchPattern = createPackagePattern(element.getElementName(), limitTo, matchRule);", "+\t\t\t\tsearchPattern = createPackagePattern(element.getElementName(), maskedLimitTo, matchRule);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3d6ece6d2574bac06c8258e7099d7e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java", "commitBeforeChange": "c8403236a1da36770c42adade61fff44b4064b9a", "commitAfterChange": "dc8046a1f26c48f37690a73dc98185cd18d7251b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprivate TypeDeclaration convert( \t\tISourceType sourceType, \t\tboolean needFieldsAndMethods, \t\tboolean needMemberTypes, \t\tCompilationResult compilationResult)", "signatureAfterChange": " \tprivate TypeDeclaration convert(ISourceType sourceType, CompilationResult compilationResult)", "diff": ["-\tprivate TypeDeclaration convert(", "-\t\tISourceType sourceType,", "-\t\tboolean needFieldsAndMethods,", "-\t\tboolean needMemberTypes,", "-\t\tCompilationResult compilationResult) {", "+\tprivate TypeDeclaration convert(ISourceType sourceType, CompilationResult compilationResult) {", "-\t\tif (needMemberTypes) {", "+\t\tif ((this.flags & MEMBER_TYPE) != 0) {", "-\t\t\t\t\t(MemberTypeDeclaration) convert(sourceMemberTypes[i],", "-\t\t\t\t\t\tneedFieldsAndMethods,", "-\t\t\t\t\t\ttrue,", "-\t\t\t\t\t\tcompilationResult);", "+\t\t\t\t\t(MemberTypeDeclaration) convert(sourceMemberTypes[i], compilationResult);", "-\t\t/* convert fields and methods */", "-\t\tif (needFieldsAndMethods) {", "-\t\t\t/* convert fields */", "+", "+\t\t/* convert fields */", "+\t\tif ((this.flags & FIELD) != 0) {", "+\t\t}", "-\t\t\t/* convert methods - need to add default constructor if necessary */", "+\t\t/* convert methods - need to add default constructor if necessary */", "+\t\tboolean needConstructor = (this.flags & CONSTRUCTOR) != 0;", "+\t\tboolean needMethod = (this.flags & METHOD) != 0;", "+\t\tif (needConstructor || needMethod) {", "+\t\t\t", "-", "+\t", "-\t\t\tint neededCount = 0;", "-\t\t\tif (!type.isInterface()) {", "-\t\t\t\tneededCount = 1;", "+\t\t\tint extraConstructor = 0;", "+\t\t\tint methodCount = 0;", "+\t\t\tboolean isInterface = type.isInterface();", "+\t\t\tif (!isInterface) {", "+\t\t\t\textraConstructor = needConstructor ? 1 : 0;", "-\t\t\t\t\t\tneededCount = 0;", "-\t\t\t\t\t\t// Does not need the extra constructor since one constructor already exists.", "-\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tif (needConstructor) {", "+\t\t\t\t\t\t\textraConstructor = 0; // Does not need the extra constructor since one constructor already exists.", "+\t\t\t\t\t\t\tmethodCount++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (needMethod) {", "+\t\t\t\t\t\tmethodCount++;", "+\t\t\t} else {", "+\t\t\t\tmethodCount = needMethod ? sourceMethodCount : 0;", "-\t\t\ttype.methods = new AbstractMethodDeclaration[sourceMethodCount + neededCount];", "-\t\t\tif (neededCount != 0) { // add default constructor in first position", "+\t\t\ttype.methods = new AbstractMethodDeclaration[methodCount + extraConstructor];", "+\t\t\tif (extraConstructor != 0) { // add default constructor in first position", "-\t\t\tboolean isInterface = type.isInterface();", "+\t\t\tint index = 0;", "-\t\t\t\tAbstractMethodDeclaration method =convert(sourceMethods[i], compilationResult);", "-\t\t\t\tif (isInterface || method.isAbstract()) { // fix-up flag ", "-\t\t\t\t\tmethod.modifiers |= AccSemicolonBody;", "+\t\t\t\tISourceMethod sourceMethod = sourceMethods[i];", "+\t\t\t\tboolean isConstructor = sourceMethod.isConstructor();", "+\t\t\t\tif ((isConstructor && needConstructor) || (!isConstructor && needMethod)) {", "+\t\t\t\t\tAbstractMethodDeclaration method =convert(sourceMethod, compilationResult);", "+\t\t\t\t\tif (isInterface || method.isAbstract()) { // fix-up flag ", "+\t\t\t\t\t\tmethod.modifiers |= AccSemicolonBody;", "+\t\t\t\t\t}", "+\t\t\t\t\ttype.methods[extraConstructor + index++] = method;", "-\t\t\t\ttype.methods[neededCount + i] = method;", "+\t\t"]}], "num": 63622}