{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "62dc5729632d3ca67f0412882e1a0bb2", "detectedBy": ["DIFF_HIERARCHICAL", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82d85d17406ff25ae39f34674b1959ef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "9aa23d789697e75fd166c7fcd35afb3e194c7006", "commitAfterChange": "d82bc9dede0d0806039833ecdf21498718909ebc", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " private FlowInfo prepareCatchInfo(FlowInfo flowInfo, ExceptionHandlingFlowContext handlingContext, FlowInfo tryInfo, int i)", "signatureAfterChange": " private FlowInfo prepareCatchInfo(FlowInfo flowInfo, ExceptionHandlingFlowContext handlingContext, FlowInfo tryInfo, int i)", "diff": ["-\t\tcatchInfo =", "-\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "-\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "-\t\t\t\t.addNullInfoFrom(initsOnException)\t// null info only from here, this is the only way to enter the catch block", "-\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "+\t\tif ((handlingContext.tagBits & (FlowContext.DEFER_NULL_DIAGNOSTIC | FlowContext.PREEMPT_NULL_DIAGNOSTIC))", "+\t\t\t\t== FlowContext.DEFER_NULL_DIAGNOSTIC)", "+\t\t{", "+\t\t\t// if null diagnostics are being deferred, initsOnException are incomplete,", "+\t\t\t// need to start with the more accurate upstream flowInfo", "+\t\t\tcatchInfo =", "+\t\t\t\tflowInfo.unconditionalCopy()", "+\t\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "+\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\ttryInfo.unconditionalCopy())", "+\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());\t\t\t\t\t\t", "+\t\t} else {", "+\t\t\t// here initsOnException are precise, so use them as the only source for null information into the catch block:", "+\t\t\tcatchInfo =", "+\t\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "+\t\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "+\t\t\t\t\t.addNullInfoFrom(initsOnException)", "+\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9eb3e9ea2dc602eb0999a3d1e4c64eec", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "2afe0ff8ea6baebe3984eac1cae395cec750c15a", "commitAfterChange": "39dfb84707f2e819cbc1bd0e286b8bf17da8d99c", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " private FlowInfo prepareCatchInfo(FlowInfo flowInfo, ExceptionHandlingFlowContext handlingContext, FlowInfo tryInfo, int i)", "signatureAfterChange": " private FlowInfo prepareCatchInfo(FlowInfo flowInfo, ExceptionHandlingFlowContext handlingContext, FlowInfo tryInfo, int i)", "diff": ["-\t\tcatchInfo =", "-\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "-\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "-\t\t\t\t.addNullInfoFrom(initsOnException)\t// null info only from here, this is the only way to enter the catch block", "-\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "+\t\tif ((handlingContext.tagBits & (FlowContext.DEFER_NULL_DIAGNOSTIC | FlowContext.PREEMPT_NULL_DIAGNOSTIC))", "+\t\t\t\t== FlowContext.DEFER_NULL_DIAGNOSTIC)", "+\t\t{", "+\t\t\t// if null diagnostics are being deferred, initsOnException are incomplete,", "+\t\t\t// need to start with the more accurate upstream flowInfo", "+\t\t\tcatchInfo =", "+\t\t\t\tflowInfo.unconditionalCopy()", "+\t\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "+\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\ttryInfo.unconditionalCopy())", "+\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());\t\t\t\t\t\t", "+\t\t} else {", "+\t\t\t// here initsOnException are precise, so use them as the only source for null information into the catch block:", "+\t\t\tcatchInfo =", "+\t\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "+\t\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "+\t\t\t\t\t.addNullInfoFrom(initsOnException)", "+\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "+\t\t}"]}], "num": 45934}