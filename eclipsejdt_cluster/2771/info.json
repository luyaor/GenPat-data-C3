{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6c0c673c875aa1c9462f47de4f239ca7", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "094cff8e57bd1aa666e4238f091428d5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-\t\t// for code gen, harm the restrictiveFlag \t", "-\t\tif (this.actualReceiverType != null) {", "-\t\t\tthis.binding = scope.getField(this.actualReceiverType, token, this);", "-\t\t} else {", "-\t\t\tthis.actualReceiverType = scope.enclosingSourceType();", "-\t\t\tthis.binding = scope.getBinding(token, bits & RestrictiveFlagMASK, this, true /*resolve*/);", "-\t\t}", "-\t\tthis.codegenBinding = this.binding;", "-\t\tif (this.binding.isValidBinding()) {", "-\t\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\t\tcase Binding.VARIABLE : // =========only variable============", "-\t\t\t\tcase Binding.VARIABLE | Binding.TYPE : //====both variable and type============", "-\t\t\t\t\tif (binding instanceof VariableBinding) {", "-\t\t\t\t\t\tVariableBinding variable = (VariableBinding) binding;", "-\t\t\t\t\t\tif (binding instanceof LocalVariableBinding) {", "-\t\t\t\t\t\t\tbits &= ~RestrictiveFlagMASK;  // clear bits", "-\t\t\t\t\t\t\tbits |= Binding.LOCAL;", "-\t\t\t\t\t\t\tif (!variable.isFinal() && (bits & DepthMASK) != 0) {", "-\t\t\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal((LocalVariableBinding)variable, this);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tTypeBinding fieldType = variable.type;", "-\t\t\t\t\t\t\tif ((this.bits & IsStrictlyAssigned) == 0) {", "-\t\t\t\t\t\t\t\tconstant = variable.constant();", "-\t\t\t\t\t\t\t\tif (fieldType != null) ", "-\t\t\t\t\t\t\t\t\tfieldType = fieldType.capture(scope, this.sourceEnd); // perform capture conversion if read access", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tconstant = Constant.NotAConstant;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn this.resolvedType = fieldType;", "+public TypeBinding resolveType(BlockScope scope) {", "+\t// for code gen, harm the restrictiveFlag \t", "+", "+\tif (this.actualReceiverType != null) {", "+\t\tthis.binding = scope.getField(this.actualReceiverType, this.token, this);", "+\t} else {", "+\t\tthis.actualReceiverType = scope.enclosingSourceType();", "+\t\tthis.binding = scope.getBinding(this.token, this.bits & ASTNode.RestrictiveFlagMASK, this, true /*resolve*/);", "+\t}", "+\tthis.codegenBinding = this.binding;", "+\tif (this.binding.isValidBinding()) {", "+\t\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\t\tcase Binding.VARIABLE : // =========only variable============", "+\t\t\tcase Binding.VARIABLE | Binding.TYPE : //====both variable and type============", "+\t\t\t\tif (this.binding instanceof VariableBinding) {", "+\t\t\t\t\tVariableBinding variable = (VariableBinding) this.binding;", "+\t\t\t\t\tTypeBinding variableType;", "+\t\t\t\t\tif (this.binding instanceof LocalVariableBinding) {", "+\t\t\t\t\t\tthis.bits &= ~ASTNode.RestrictiveFlagMASK;  // clear bits", "+\t\t\t\t\t\tthis.bits |= Binding.LOCAL;", "+\t\t\t\t\t\tif (!variable.isFinal() && (this.bits & ASTNode.DepthMASK) != 0) {", "+\t\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal((LocalVariableBinding)variable, this);", "+\t\t\t\t\t\tvariableType = variable.type;", "+\t\t\t\t\t\tthis.constant = (this.bits & ASTNode.IsStrictlyAssigned) == 0 ? variable.constant() : Constant.NotAConstant;", "+\t\t\t\t\t} else {", "-\t\t\t\t\t\t// perform capture conversion if read access", "-\t\t\t\t\t\tTypeBinding fieldType = checkFieldAccess(scope);", "-\t\t\t\t\t\treturn this.resolvedType = ", "-\t\t\t\t\t\t\t(((this.bits & IsStrictlyAssigned) == 0) ", "-\t\t\t\t\t\t\t\t? fieldType.capture(scope, this.sourceEnd)", "-\t\t\t\t\t\t\t\t: fieldType);", "+\t\t\t\t\t\tvariableType = checkFieldAccess(scope);", "-\t", "-\t\t\t\t\t// thus it was a type", "-\t\t\t\t\tbits &= ~RestrictiveFlagMASK;  // clear bits", "-\t\t\t\t\tbits |= Binding.TYPE;", "-\t\t\t\tcase Binding.TYPE : //========only type==============", "-\t\t\t\t\tconstant = Constant.NotAConstant;", "-\t\t\t\t\t//deprecated test", "-\t\t\t\t\tTypeBinding type = (TypeBinding)binding;", "-\t\t\t\t\tif (isTypeUseDeprecated(type, scope))", "-\t\t\t\t\t\tscope.problemReporter().deprecatedType(type, this);", "-\t\t\t\t\ttype = scope.environment().convertToRawType(type, false /*do not force conversion of enclosing types*/);", "-\t\t\t\t\treturn this.resolvedType = type;", "-\t\t\t}", "-\t\t}", "-\t", "-\t\t// error scenarii", "-\t\treturn this.resolvedType = this.reportError(scope);", "-\t}", "+\t\t\t\t\t// perform capture conversion if read access", "+\t\t\t\t\tif (variableType != null) {", "+\t\t\t\t\t\tthis.resolvedType = variableType = (((this.bits & ASTNode.IsStrictlyAssigned) == 0) ", "+\t\t\t\t\t\t\t\t? variableType.capture(scope, this.sourceEnd)", "+\t\t\t\t\t\t\t\t: variableType);", "+\t\t\t\t\t\tif ((variableType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\t\t\tif ((this.bits & Binding.LOCAL) == 0) {", "+\t\t\t\t\t\t\t\t// only complain if field reference (for local, its type got flagged already)", "+\t\t\t\t\t\t\t\tscope.problemReporter().invalidType(this, variableType);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\treturn variableType;", "+\t\t\t\t}", "+\t\t\t\t// thus it was a type", "+\t\t\t\tthis.bits &= ~ASTNode.RestrictiveFlagMASK;  // clear bits", "+\t\t\t\tthis.bits |= Binding.TYPE;", "+\t\t\tcase Binding.TYPE : //========only type==============", "+\t\t\t\tthis.constant = Constant.NotAConstant;", "+\t\t\t\t//deprecated test", "+\t\t\t\tTypeBinding type = (TypeBinding)this.binding;", "+\t\t\t\tif (isTypeUseDeprecated(type, scope))", "+\t\t\t\t\tscope.problemReporter().deprecatedType(type, this);", "+\t\t\t\ttype = scope.environment().convertToRawType(type, false /*do not force conversion of enclosing types*/);", "+\t\t\t\treturn this.resolvedType = type;", "+\t\t}", "+\t}", "+\t// error scenarii", "+\treturn this.resolvedType = this.reportError(scope);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d4fbf57eb21fc31999d1353cc94bd978", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "931e434bb3e4b9f62577b10f8123cfc028893969", "commitAfterChange": "c0b519c3b149b13ea0f307f0d3414359b2cf0639", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t}", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-\t\t// field and/or local are done before type lookups", "-\t\t// the only available value for the restrictiveFlag BEFORE", "-\t\t// the TC is Flag_Type Flag_LocalField and Flag_TypeLocalField ", "-\t\tthis.actualReceiverType = scope.enclosingReceiverType();", "-\t\tconstant = Constant.NotAConstant;", "-\t\tif ((this.codegenBinding = this.binding = scope.getBinding(tokens, bits & RestrictiveFlagMASK, this, true /*resolve*/)).isValidBinding()) {", "-\t\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\t\tcase Binding.VARIABLE : //============only variable===========", "-\t\t\t\tcase Binding.TYPE | Binding.VARIABLE :", "-\t\t\t\t\tif (binding instanceof LocalVariableBinding) {", "-\t\t\t\t\t\tif (!((LocalVariableBinding) binding).isFinal() && ((bits & DepthMASK) != 0))", "-\t\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal(", "-\t\t\t\t\t\t\t\t(LocalVariableBinding) binding,", "-\t\t\t\t\t\t\t\tthis);", "-\t\t\t\t\t\tbits &= ~RestrictiveFlagMASK; // clear bits", "-\t\t\t\t\t\tbits |= Binding.LOCAL;", "-\t\t\t\t\t\treturn this.resolvedType = getOtherFieldBindings(scope);", "+", "+public TypeBinding resolveType(BlockScope scope) {", "+\t// field and/or local are done before type lookups", "+\t// the only available value for the restrictiveFlag BEFORE", "+\t// the TC is Flag_Type Flag_LocalField and Flag_TypeLocalField ", "+\tthis.actualReceiverType = scope.enclosingReceiverType();", "+\tthis.constant = Constant.NotAConstant;", "+\tif ((this.codegenBinding = this.binding = scope.getBinding(this.tokens, this.bits & ASTNode.RestrictiveFlagMASK, this, true /*resolve*/)).isValidBinding()) {", "+\t\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\t\tcase Binding.VARIABLE : //============only variable===========", "+\t\t\tcase Binding.TYPE | Binding.VARIABLE :", "+\t\t\t\tif (this.binding instanceof LocalVariableBinding) {", "+\t\t\t\t\tif (!((LocalVariableBinding) this.binding).isFinal() && ((this.bits & ASTNode.DepthMASK) != 0))", "+\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal(", "+\t\t\t\t\t\t\t(LocalVariableBinding) this.binding,", "+\t\t\t\t\t\t\tthis);", "+\t\t\t\t\tthis.bits &= ~ASTNode.RestrictiveFlagMASK; // clear bits", "+\t\t\t\t\tthis.bits |= Binding.LOCAL;", "+\t\t\t\t\treturn this.resolvedType = getOtherFieldBindings(scope);", "+\t\t\t\t}", "+\t\t\t\tif (this.binding instanceof FieldBinding) {", "+\t\t\t\t\tFieldBinding fieldBinding = (FieldBinding) this.binding;", "+\t\t\t\t\tMethodScope methodScope = scope.methodScope();", "+\t\t\t\t\t// check for forward references", "+\t\t\t\t\tif (this.indexOfFirstFieldBinding == 1", "+\t\t\t\t\t\t\t&& methodScope.enclosingSourceType() == fieldBinding.original().declaringClass", "+\t\t\t\t\t\t\t&& methodScope.lastVisibleFieldID >= 0", "+\t\t\t\t\t\t\t&& fieldBinding.id >= methodScope.lastVisibleFieldID", "+\t\t\t\t\t\t\t&& (!fieldBinding.isStatic() || methodScope.isStatic)) {", "+\t\t\t\t\t\tscope.problemReporter().forwardReference(this, 0, methodScope.enclosingSourceType());", "-\t\t\t\t\tif (binding instanceof FieldBinding) {", "-\t\t\t\t\t\tFieldBinding fieldBinding = (FieldBinding) binding;", "-\t\t\t\t\t\tMethodScope methodScope = scope.methodScope();", "-\t\t\t\t\t\t// check for forward references", "-\t\t\t\t\t\tif (this.indexOfFirstFieldBinding == 1", "-\t\t\t\t\t\t\t\t&& methodScope.enclosingSourceType() == fieldBinding.original().declaringClass", "-\t\t\t\t\t\t\t\t&& methodScope.lastVisibleFieldID >= 0", "-\t\t\t\t\t\t\t\t&& fieldBinding.id >= methodScope.lastVisibleFieldID", "-\t\t\t\t\t\t\t\t&& (!fieldBinding.isStatic() || methodScope.isStatic)) {", "-\t\t\t\t\t\t\tscope.problemReporter().forwardReference(this, 0, methodScope.enclosingSourceType());", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (!fieldBinding.isStatic() ", "-\t\t\t\t\t\t\t\t&& this.indexOfFirstFieldBinding == 1", "-\t\t\t\t\t\t\t\t&& scope.compilerOptions().getSeverity(CompilerOptions.UnqualifiedFieldAccess) != ProblemSeverities.Ignore) {", "-\t\t\t\t\t\t\tscope.problemReporter().unqualifiedFieldAccess(this, fieldBinding);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbits &= ~RestrictiveFlagMASK; // clear bits", "-\t\t\t\t\t\tbits |= Binding.FIELD;", "-\t\t\t\t\t\t", "+\t\t\t\t\tif (!fieldBinding.isStatic() ", "+\t\t\t\t\t\t\t&& this.indexOfFirstFieldBinding == 1", "+\t\t\t\t\t\t\t&& scope.compilerOptions().getSeverity(CompilerOptions.UnqualifiedFieldAccess) != ProblemSeverities.Ignore) {", "+\t\t\t\t\t\tscope.problemReporter().unqualifiedFieldAccess(this, fieldBinding);", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.bits &= ~ASTNode.RestrictiveFlagMASK; // clear bits", "+\t\t\t\t\tthis.bits |= Binding.FIELD;", "+\t\t\t\t\t", "-\t\t\t\t\t\t", "-\t\t\t\t\t\treturn this.resolvedType = getOtherFieldBindings(scope);", "-\t\t\t\t\t}", "-\t\t\t\t\t// thus it was a type", "-\t\t\t\t\tbits &= ~RestrictiveFlagMASK; // clear bits", "-\t\t\t\t\tbits |= Binding.TYPE;", "-\t\t\t\tcase Binding.TYPE : //=============only type ==============", "-\t\t\t\t    TypeBinding type = (TypeBinding) binding;", "+\t\t\t\t\t", "+\t\t\t\t\treturn this.resolvedType = getOtherFieldBindings(scope);", "+\t\t\t\t}", "+\t\t\t\t// thus it was a type", "+\t\t\t\tthis.bits &= ~ASTNode.RestrictiveFlagMASK; // clear bits", "+\t\t\t\tthis.bits |= Binding.TYPE;", "+\t\t\tcase Binding.TYPE : //=============only type ==============", "+\t\t\t    TypeBinding type = (TypeBinding) this.binding;", "-\t\t\t\t\ttype = scope.environment().convertToRawType(type);", "-\t\t\t\t\treturn this.resolvedType = type;", "-\t\t\t}", "+\t\t\t\ttype = scope.environment().convertToRawType(type);", "+\t\t\t\treturn this.resolvedType = type;", "-\t\t//========error cases===============", "-\t\treturn this.resolvedType = this.reportError(scope);", "+\t//========error cases===============", "+\treturn this.resolvedType = this.reportError(scope);", "+}"]}], "num": 2771}