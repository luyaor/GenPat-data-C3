{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "81ebdb1ac8c280deee340a10982bf12f", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a64209c2f8a25c2699ee2a27e1ec387", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "0307cad3f1b01ed5d7ce67bc78cd9b706e4819f3", "commitAfterChange": "7a57dee588cd632418aaf1f630bac2c2a5d6439a", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 18, "signatureBeforeChange": "  \tpublic static CompilationUnitDeclaration parse(char[] source, NodeSearcher nodeSearcher, Map settings)", "signatureAfterChange": "\t \t \tpublic static CompilationUnitDeclaration parse(char[] source, NodeSearcher nodeSearcher, Map settings)", "diff": ["-", "-\t\tint searchPosition = nodeSearcher.position;", "-\t\tif (searchPosition < 0 || searchPosition > source.length) {", "-\t\t\t// the position is out of range. There is no need to search for a node.", "- \t\t\treturn compilationUnitDeclaration;", "-\t\t}", "-\t", "-\t\tcompilationUnitDeclaration.traverse(nodeSearcher, compilationUnitDeclaration.scope);", "+\t\tif (nodeSearcher != null) {", "+\t\t\tint searchPosition = nodeSearcher.position;", "+\t\t\tif (searchPosition < 0 || searchPosition > source.length) {", "+\t\t\t\t// the position is out of range. There is no need to search for a node.", "+\t \t\t\treturn compilationUnitDeclaration;", "+\t\t\t}", "-\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode node = nodeSearcher.found;", "- \t\tif (node == null) {", "- \t\t\treturn compilationUnitDeclaration;", "- \t\t}", "- \t\t", "- \t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "- \t\t", "-\t\tif (node instanceof AbstractMethodDeclaration) {", "-\t\t\t((AbstractMethodDeclaration)node).parseStatements(parser, compilationUnitDeclaration);", "-\t\t} else if (enclosingTypeDeclaration != null) {", "-\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "-\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(parser, enclosingTypeDeclaration, compilationUnitDeclaration);", "-\t\t\t} else {  \t\t\t\t\t", "-\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(parser, compilationUnitDeclaration);", "-\t\t\t} \t\t\t\t", "+\t\t\tcompilationUnitDeclaration.traverse(nodeSearcher, compilationUnitDeclaration.scope);", "+\t\t\t", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode node = nodeSearcher.found;", "+\t \t\tif (node == null) {", "+\t \t\t\treturn compilationUnitDeclaration;", "+\t \t\t}", "+\t \t\t", "+\t \t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "+\t \t\t", "+\t\t\tif (node instanceof AbstractMethodDeclaration) {", "+\t\t\t\t((AbstractMethodDeclaration)node).parseStatements(parser, compilationUnitDeclaration);", "+\t\t\t} else if (enclosingTypeDeclaration != null) {", "+\t\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "+\t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(parser, enclosingTypeDeclaration, compilationUnitDeclaration);", "+\t\t\t\t} else {  \t\t\t\t\t", "+\t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(parser, compilationUnitDeclaration);", "+\t\t\t\t} \t\t\t\t", "+\t\t\t}", "+\t\t} else {", "+\t\t\t//fill the methods bodies in order for the code to be generated", "+\t\t\t//real parse of the method....", "+\t\t\tparser.scanner.setSource(source);", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = compilationUnitDeclaration.types;", "+\t\t\tif (types != null) {", "+\t\t\t\tfor (int i = types.length; --i >= 0;)", "+\t\t\t\t\ttypes[i].parseMethod(parser, compilationUnitDeclaration);", "+\t\t\t}", "-\t\t", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e4a6052c70fc497f763ddfff9db49987", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "e0e6245d2f5b446cd8eba278aee2ec57c56c32e6", "commitAfterChange": "b42787861f816a2d5e1ca0d96a18df1cf4233d07", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "  \tprivate static void reportProblems(CompilationUnitDeclaration unit, IAbstractSyntaxTreeVisitor visitor)", "signatureAfterChange": "  \tpublic static CompilationUnitDeclaration parse(char[] source, NodeSearcher nodeSearcher, Map settings)", "diff": ["-\tprivate static void reportProblems(CompilationUnitDeclaration unit, IAbstractSyntaxTreeVisitor visitor) {", "-\t\tCompilationResult unitResult = unit.compilationResult;", "-\t\tIProblem[] problems = unitResult.getAllProblems();", "-\t\tfor (int i = 0, problemLength = problems == null ? 0 : problems.length; i < problemLength; i++) {", "-\t\t\tvisitor.acceptProblem(problems[i]);\t\t\t\t", "-\t\t}\t", "+\tpublic static CompilationUnitDeclaration parse(char[] source, NodeSearcher nodeSearcher, Map settings) {", "+\t\tif (source == null) {", "+\t\t\tthrow new IllegalArgumentException();", "+\t\t}", "+\t\tCompilerOptions compilerOptions = new CompilerOptions(settings);", "+\t\tParser parser = createDomParser(", "+\t\t\tnew ProblemReporter(", "+\t\t\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(), ", "+\t\t\t\t\tcompilerOptions, ", "+\t\t\t\t\tnew DefaultProblemFactory()));", "+\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = ", "+\t\t\tnew org.eclipse.jdt.internal.compiler.batch.CompilationUnit(", "+\t\t\t\tsource, ", "+\t\t\t\t\"\", //$NON-NLS-1$", "+\t\t\t\tcompilerOptions.defaultEncoding);", "+\t\tCompilationUnitDeclaration compilationUnitDeclaration = parser.dietParse(sourceUnit, new CompilationResult(sourceUnit, 0, 0, compilerOptions.maxProblemsPerUnit));", "+\t\t", "+\t\tif (compilationUnitDeclaration.ignoreMethodBodies) {", "+\t\t\tcompilationUnitDeclaration.ignoreFurtherInvestigation = true;", "+\t\t\t// if initial diet parse did not work, no need to dig into method bodies.", "+\t\t\treturn null; ", "+\t\t}", "+\t\t\t\t", "+\t\tcompilationUnitDeclaration.traverse(nodeSearcher, compilationUnitDeclaration.scope);", "+\t\t", "+\t\tAstNode node = nodeSearcher.found;", "+ \t\tif (node == null) {", "+ \t\t\treturn compilationUnitDeclaration;", "+ \t\t}", "+ \t\t", "+ \t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "+ \t\t", "+\t\tif (node instanceof AbstractMethodDeclaration) {", "+\t\t\t((AbstractMethodDeclaration)node).parseStatements(parser, compilationUnitDeclaration);", "+\t\t} else if (enclosingTypeDeclaration != null) {", "+\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "+\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(parser, enclosingTypeDeclaration, compilationUnitDeclaration);", "+\t\t\t} else {  \t\t\t\t\t", "+\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(parser, compilationUnitDeclaration);", "+\t\t\t} \t\t\t\t", "+\t\t}", "+\t\t", "+\t\treturn compilationUnitDeclaration;"]}], "num": 30872}