{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dddd6b3db62310b68be26265c5296a01", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "19de1d3c20bd3144ae2aff016061004c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java", "commitBeforeChange": "7df061f9da0ab96be87e5851cb157a28c5f5bca0", "commitAfterChange": "5138a70372af4817aefdd3da44dfadf7f7557bf3", "methodNumberBeforeChange": 94, "methodNumberAfterChange": 95, "signatureBeforeChange": "  public MethodBinding getSingleAbstractMethod()", "signatureAfterChange": " public MethodBinding getSingleAbstractMethod(Scope scope)", "diff": ["-public MethodBinding getSingleAbstractMethod() {", "+}", "+public MethodBinding getSingleAbstractMethod(Scope scope) {", "-\tMethodBinding [] methods;", "-\tif (!isInterface() || (methods = methods()).length != 1) {", "+", "+\tMethodBinding[] methods = null;", "+\ttry {", "+\t\tmethods = getInterfaceAbstractContracts(scope);", "+\t} catch (InvalidInputException e) {", "-\treturn this.singleAbstractMethod = methods[0];", "+\tif (methods != null && methods.length == 1)", "+\t\treturn this.singleAbstractMethod = methods[0];", "+\t", "+\tfinal LookupEnvironment environment = scope.environment();", "+\tboolean genericMethodSeen = false;", "+\tnext:for (int i = 0, length = methods.length; i < length; i++) {", "+\t\tMethodBinding method = methods[i], otherMethod = null;", "+\t\tif (method.typeVariables != Binding.NO_TYPE_VARIABLES)", "+\t\t\tgenericMethodSeen = true;", "+\t\tfor (int j = 0; j < length; j++) {", "+\t\t\tif (i == j) continue;", "+\t\t\totherMethod = methods[j];", "+\t\t\tif (otherMethod.typeVariables != Binding.NO_TYPE_VARIABLES)", "+\t\t\t\tgenericMethodSeen = true;", "+\t\t\tif (!MethodVerifier.isParameterSubsignature(method, otherMethod, environment) || !MethodVerifier.areReturnTypesCompatible(method, otherMethod, environment)) ", "+\t\t\t\tcontinue next; ", "+\t\t}", "+\t\t// If we reach here, we found a method that is override equivalent with every other method and is also return type substitutable. Compute kosher exceptions now ...", "+\t\tReferenceBinding [] exceptions = new ReferenceBinding[0];", "+\t\tint exceptionsCount = 0, exceptionsLength = 0;", "+\t\tfinal MethodBinding theAbstractMethod = method;", "+\t\tboolean shouldEraseThrows = theAbstractMethod.typeVariables == Binding.NO_TYPE_VARIABLES && genericMethodSeen;", "+\t\tboolean shouldAdaptThrows = theAbstractMethod.typeVariables != Binding.NO_TYPE_VARIABLES;", "+\t\tfinal int typeVariableLength = theAbstractMethod.typeVariables.length;", "+\t\t", "+\t\tnone:for (i = 0; i < length; i++) {", "+\t\t\tmethod = methods[i];", "+\t\t\tReferenceBinding[] methodThrownExceptions = method.thrownExceptions;", "+\t\t\tint methodExceptionsLength = methodThrownExceptions == null ? 0: methodThrownExceptions.length;", "+\t\t\tif (methodExceptionsLength == 0) break none;", "+\t\t\tif (shouldAdaptThrows && method != theAbstractMethod) {", "+\t\t\t\tSystem.arraycopy(methodThrownExceptions, 0, methodThrownExceptions = new ReferenceBinding[methodExceptionsLength], 0, methodExceptionsLength);", "+\t\t\t\tfor (int tv = 0; tv < typeVariableLength; tv++) {", "+\t\t\t\t\tif (methodThrownExceptions[tv] instanceof TypeVariableBinding) {", "+\t\t\t\t\t\tmethodThrownExceptions[tv] = theAbstractMethod.typeVariables[tv];", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tnextException: for (int j = 0; j < methodExceptionsLength; j++) {", "+\t\t\t\tReferenceBinding methodException = methodThrownExceptions[j];", "+\t\t\t\tif (shouldEraseThrows)", "+\t\t\t\t\tmethodException = (ReferenceBinding) methodException.erasure();", "+\t\t\t\tnextMethod: for (int k = 0; k < length; k++) {", "+\t\t\t\t\tif (i == k) continue;", "+\t\t\t\t\totherMethod = methods[k];", "+\t\t\t\t\tReferenceBinding[] otherMethodThrownExceptions = otherMethod.thrownExceptions;", "+\t\t\t\t\tint otherMethodExceptionsLength =  otherMethodThrownExceptions == null ? 0 : otherMethodThrownExceptions.length;", "+\t\t\t\t\tif (otherMethodExceptionsLength == 0) break none;", "+\t\t\t\t\tif (shouldAdaptThrows && otherMethod != theAbstractMethod) {", "+\t\t\t\t\t\tSystem.arraycopy(otherMethodThrownExceptions, ", "+\t\t\t\t\t\t\t\t0, ", "+\t\t\t\t\t\t\t\totherMethodThrownExceptions = new ReferenceBinding[otherMethodExceptionsLength], ", "+\t\t\t\t\t\t\t\t0, ", "+\t\t\t\t\t\t\t\totherMethodExceptionsLength);", "+\t\t\t\t\t\tfor (int tv = 0; tv < typeVariableLength; tv++) {", "+\t\t\t\t\t\t\tif (otherMethodThrownExceptions[tv] instanceof TypeVariableBinding) {", "+\t\t\t\t\t\t\t\totherMethodThrownExceptions[tv] = theAbstractMethod.typeVariables[tv];", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tfor (int l = 0; l < otherMethodExceptionsLength; l++) {", "+\t\t\t\t\t\tReferenceBinding otherException = otherMethodThrownExceptions[l];", "+\t\t\t\t\t\tif (shouldEraseThrows)", "+\t\t\t\t\t\t\totherException = (ReferenceBinding) otherException.erasure();", "+\t\t\t\t\t\tif (methodException.isCompatibleWith(otherException))", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t}", "+\t\t\t\t\tcontinue nextException;", "+\t\t\t\t}", "+\t\t\t\t// If we reach here, method exception or its super type is covered by every throws clause.", "+\t\t\t\tif (exceptionsCount == exceptionsLength) {", "+\t\t\t\t\tSystem.arraycopy(exceptions, 0, exceptions = new ReferenceBinding[exceptionsLength += 16], 0, exceptionsCount);", "+\t\t\t\t}", "+\t\t\t\texceptions[exceptionsCount++] = methodException;", "+\t\t\t}", "+\t\t}", "+\t\tif (exceptionsCount != exceptionsLength) {", "+\t\t\tSystem.arraycopy(exceptions, 0, exceptions = new ReferenceBinding[exceptionsCount], 0, exceptionsCount);", "+\t\t}", "+\t\tthis.singleAbstractMethod = new MethodBinding(theAbstractMethod.modifiers, ", "+\t\t\t\ttheAbstractMethod.selector, ", "+\t\t\t\ttheAbstractMethod.returnType, ", "+\t\t\t\ttheAbstractMethod.parameters, ", "+\t\t\t\texceptions, ", "+\t\t\t\ttheAbstractMethod.declaringClass);", "+\t    this.singleAbstractMethod.typeVariables = theAbstractMethod.typeVariables;", "+\t\treturn this.singleAbstractMethod;", "+\t}", "+\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NoSuchSingleAbstractMethod);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c8dbf2db60ee227121cd0d7ff1ad4cc6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "51c6ca3e4dfed3078a1640da7a2ab7f26c899e0a", "commitAfterChange": "de8aa9940086fe152901aa168536f30670945804", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 42, "signatureBeforeChange": " \tpublic void completeMethodInfo( \t\t\tMethodBinding binding, \t\t\tint methodAttributeOffset, \t\t\tint attributesNumber)", "signatureAfterChange": " \tpublic void completeMethodInfo( \t\t\tMethodBinding binding, \t\t\tint methodAttributeOffset, \t\t\tint attributesNumber)", "diff": ["+", "+\t\tif ((this.produceAttributes & ClassFileConstants.ATTR_TYPE_ANNOTATION) != 0) {", "+\t\t\tList allTypeAnnotationContexts = ((TypeAnnotationCodeStream) this.codeStream).allTypeAnnotationContexts;", "+\t\t\tint invisibleTypeAnnotationsCounter = 0;", "+\t\t\tint visibleTypeAnnotationsCounter = 0;", "+\t\t\tfor (int i = 0, max = this.codeStream.allLocalsCounter; i < max; i++) {", "+\t\t\t\tLocalVariableBinding localVariable = this.codeStream.locals[i];", "+\t\t\t\tLocalDeclaration declaration = localVariable.declaration;", "+\t\t\t\tif (declaration == null", "+\t\t\t\t\t\t|| (declaration.isArgument() && ((declaration.bits & ASTNode.IsUnionType) == 0))", "+\t\t\t\t\t\t|| (localVariable.initializationCount == 0)", "+\t\t\t\t\t\t|| ((declaration.bits & ASTNode.HasTypeAnnotations) == 0)) {", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tdeclaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.LOCAL_VARIABLE, localVariable, allTypeAnnotationContexts);", "+\t\t\t}", "+\t\t\tAbstractMethodDeclaration methodDeclaration = binding.sourceMethod();", "+\t\t\tif (methodDeclaration != null) {", "+\t\t\t\tif ((methodDeclaration.bits & ASTNode.HasTypeAnnotations) != 0) {", "+\t\t\t\t\tArgument[] arguments = methodDeclaration.arguments;", "+\t\t\t\t\tif (arguments != null) {", "+\t\t\t\t\t\tfor (int i = 0, max = arguments.length; i < max; i++) {", "+\t\t\t\t\t\t\tArgument argument = arguments[i];", "+\t\t\t\t\t\t\tif ((argument.bits & ASTNode.HasTypeAnnotations) != 0) {", "+\t\t\t\t\t\t\t\targument.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_PARAMETER, i, allTypeAnnotationContexts);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tAnnotation[] annotations = (methodDeclaration.receiver==null?null:methodDeclaration.receiver.annotations);", "+\t\t\t\t\tif (annotations != null) {", "+\t\t\t\t\t\tfor (int i = 0, max = annotations.length; i < max; i++) {", "+\t\t\t\t\t\t\tAnnotation annotation = annotations[i];", "+\t\t\t\t\t\t\tAnnotationContext annotationContext = null;", "+\t\t\t\t\t\t\tif (annotation.isRuntimeTypeInvisible()) {", "+\t\t\t\t\t\t\t\tannotationContext = new AnnotationContext(annotation, null, AnnotationTargetTypeConstants.METHOD_RECEIVER, null, AnnotationContext.INVISIBLE, null);", "+\t\t\t\t\t\t\t\tinvisibleTypeAnnotationsCounter++;", "+\t\t\t\t\t\t\t} else if (annotation.isRuntimeTypeVisible()) {", "+\t\t\t\t\t\t\t\tannotationContext = new AnnotationContext(annotation, null, AnnotationTargetTypeConstants.METHOD_RECEIVER, null, AnnotationContext.VISIBLE, null);", "+\t\t\t\t\t\t\t\tvisibleTypeAnnotationsCounter++;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (annotationContext != null) {", "+\t\t\t\t\t\t\t\tallTypeAnnotationContexts.add(annotationContext);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tAnnotation[] annotations = methodDeclaration.annotations;", "+\t\t\t\tif (annotations != null && binding.returnType.id != T_void) {", "+\t\t\t\t\tmethodDeclaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RETURN_TYPE, allTypeAnnotationContexts);", "+\t\t\t\t}", "+\t\t\t\tif (!methodDeclaration.isConstructor() && !methodDeclaration.isClinit() && binding.returnType.id != T_void) {", "+\t\t\t\t\tMethodDeclaration declaration = (MethodDeclaration) methodDeclaration;", "+\t\t\t\t\tTypeReference typeReference = declaration.returnType;", "+\t\t\t\t\tif ((typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {", "+\t\t\t\t\t\ttypeReference.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RETURN_TYPE, allTypeAnnotationContexts);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tTypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;", "+\t\t\t\tif (thrownExceptions != null) {", "+\t\t\t\t\tfor (int i = 0, max = thrownExceptions.length; i < max; i++) {", "+\t\t\t\t\t\tTypeReference thrownException = thrownExceptions[i];", "+\t\t\t\t\t\tthrownException.getAllAnnotationContexts(AnnotationTargetTypeConstants.THROWS, i, allTypeAnnotationContexts);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tTypeParameter[] typeParameters = methodDeclaration.typeParameters();", "+\t\t\t\tif (typeParameters != null) {", "+\t\t\t\t\tfor (int i = 0, max = typeParameters.length; i < max; i++) {", "+\t\t\t\t\t\tTypeParameter typeParameter = typeParameters[i];", "+\t\t\t\t\t\tif ((typeParameter.bits & ASTNode.HasTypeAnnotations) != 0) {", "+\t\t\t\t\t\t\ttypeParameter.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER, i, allTypeAnnotationContexts);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tint size = allTypeAnnotationContexts.size();", "+\t\t\tif (size != 0) {", "+\t\t\t\tAnnotationContext[] allTypeAnnotationContextsArray = new AnnotationContext[size];", "+\t\t\t\tallTypeAnnotationContexts.toArray(allTypeAnnotationContextsArray);", "+\t\t\t\tfor (int j = 0, max2 = allTypeAnnotationContextsArray.length; j < max2; j++) {", "+\t\t\t\t\tAnnotationContext annotationContext = allTypeAnnotationContextsArray[j];", "+\t\t\t\t\tif ((annotationContext.visibility & AnnotationContext.INVISIBLE) != 0) {", "+\t\t\t\t\t\tinvisibleTypeAnnotationsCounter++;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tvisibleTypeAnnotationsCounter++;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tattributesNumber += generateRuntimeTypeAnnotations(", "+\t\t\t\t\t\tallTypeAnnotationContextsArray,", "+\t\t\t\t\t\tvisibleTypeAnnotationsCounter,", "+\t\t\t\t\t\tinvisibleTypeAnnotationsCounter);", "+\t\t\t}", "+\t\t}", "+"]}], "num": 52335}