{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1abd571fef507a1e43336390b05d1c12", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f190303bcbb97463a3043e19a3efea3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "18a717c02ecdc2d409aa7cc135839941fa4c74e6", "commitAfterChange": "96bd3255b48a32c1785eb6f69a6cdfc9035c7d2a", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "diff": ["+\t\tboolean isCompliant14 = compilationUnitScope().environment.options.complianceLevel >= CompilerOptions.JDK1_4;", "-\t\t\tif (compilationUnitScope().environment.options.complianceLevel >= CompilerOptions.JDK1_4){\t\t\t ", "+\t\t\tif (isCompliant14){\t\t\t ", "-\t\t\tif (matchingMethod != null && areParametersAssignable(matchingMethod.parameters, argumentTypes))", "+\t\t\tif (matchingMethod != null && areParametersAssignable(matchingMethod.parameters, argumentTypes)) {", "+\t\t\t\t// (if no default abstract) must explicitly look for one instead, which could be a better match", "+\t\t\t\tif (!matchingMethod.canBeSeenBy(receiverType, invocationSite, this)) {", "+\t\t\t\t\t// ignore matching method (to be consistent with multiple matches, none visible (matching method is then null)", "+\t\t\t\t\tMethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, null, found);\t\t\t\t\t\t", "+\t\t\t\t\tif (interfaceMethod != null) return interfaceMethod;", "+\t\t\t\t}", "+\t\t\t} "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9cb7f15a7527011e44012f979a728378", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "050b48aa4655d04d8ebd3c1cccebaabdd5848e02", "commitAfterChange": "dd23dd84454d0fa5c72d126d13e15a9ff7a73fdd", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "diff": ["+\t\t\t\t\tcompilationUnitScope().recordTypeReferences(matchingMethod.thrownExceptions);", "-\t\t\tcompilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);", "-\t\t\treturn candidates[0]; // have not checked visibility", "+\t\t\t\t// (if no default abstract) must explicitly look for one instead, which could be a better match", "+\t\t\t\tif (!candidates[0].canBeSeenBy(receiverType, invocationSite, this)) {", "+\t\t\t\t\t// ignore matching method (to be consistent with multiple matches, none visible (matching method is then null)", "+\t\t\t\t\tMethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, null, found);\t\t\t\t\t\t", "+\t\t\t\t\tif (interfaceMethod != null) return interfaceMethod;", "+\t\t\t\t\tcompilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);", "+\t\t\t\t\treturn candidates[0];", "+\t\t\t\t}", "+\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, candidates[0], found); // have not checked visibility"]}], "num": 60759}