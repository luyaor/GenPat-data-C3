{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "971ed2fac45bcccede2c4bdc95cdd4c4", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c320336c46d110e959f2cd5cde8201d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java", "commitBeforeChange": "8f5b67bd80ff7e72bd80828779ffdbdb5bad5276", "commitAfterChange": "50d8267275b181894c19c15246b42f9711f997ad", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 57, "signatureBeforeChange": " public void test012b()", "signatureAfterChange": " public void test012b()", "diff": ["-        \" Warning options:\\n\" +", "-        \"    -deprecation         + deprecation outside deprecated code\\n\" +", "-        \"    -nowarn -warn:none disable all warnings\\n\" +", "-        \"    -warn:<warnings separated by ,>    enable exactly the listed warnings\\n\" +", "-        \"    -warn:+<warnings separated by ,>   enable additional warnings\\n\" +", "-        \"    -warn:-<warnings separated by ,>   disable specific warnings\\n\" +", "-        \"      allDeadCode          dead code including trivial if(DEBUG) check\\n\" +", "-        \"      allDeprecation       deprecation including inside deprecated code\\n\" +", "-        \"      allJavadoc           invalid or missing javadoc\\n\" +", "-        \"      allOver-ann          all missing @Override annotations\\n\" +", "-        \"      assertIdentifier   + ''assert'' used as identifier\\n\" +", "-        \"      boxing               autoboxing conversion\\n\" +", "-        \"      charConcat         + char[] in String concat\\n\" +", "-        \"      compareIdentical   + comparing identical expressions\\n\" +", "-        \"      conditionAssign      possible accidental boolean assignment\\n\" +", "-        \"      constructorName    + method with constructor name\\n\" +", "-        \"      deadCode           + dead code excluding trivial if (DEBUG) check\\n\" +", "-        \"      dep-ann              missing @Deprecated annotation\\n\" +", "-        \"      deprecation        + deprecation outside deprecated code\\n\" +", "-        \"      discouraged        + use of types matching a discouraged access rule\\n\" +", "-        \"      emptyBlock           undocumented empty block\\n\" +", "+        \" Warning options:\\n\" + ", "+        \"    -deprecation         + deprecation outside deprecated code\\n\" + ", "+        \"    -nowarn -warn:none disable all warnings\\n\" + ", "+        \"    -warn:<warnings separated by ,>    enable exactly the listed warnings\\n\" + ", "+        \"    -warn:+<warnings separated by ,>   enable additional warnings\\n\" + ", "+        \"    -warn:-<warnings separated by ,>   disable specific warnings\\n\" + ", "+        \"      allDeadCode          dead code including trivial if(DEBUG) check\\n\" + ", "+        \"      allDeprecation       deprecation including inside deprecated code\\n\" + ", "+        \"      allJavadoc           invalid or missing javadoc\\n\" + ", "+        \"      allOver-ann          all missing @Override annotations\\n\" + ", "+        \"      assertIdentifier   + ''assert'' used as identifier\\n\" + ", "+        \"      boxing               autoboxing conversion\\n\" + ", "+        \"      charConcat         + char[] in String concat\\n\" + ", "+        \"      compareIdentical   + comparing identical expressions\\n\" + ", "+        \"      conditionAssign      possible accidental boolean assignment\\n\" + ", "+        \"      constructorName    + method with constructor name\\n\" + ", "+        \"      deadCode           + dead code excluding trivial if (DEBUG) check\\n\" + ", "+        \"      dep-ann              missing @Deprecated annotation\\n\" + ", "+        \"      deprecation        + deprecation outside deprecated code\\n\" + ", "+        \"      discouraged        + use of types matching a discouraged access rule\\n\" + ", "+        \"      emptyBlock           undocumented empty block\\n\" + ", "-        \"      enumSwitch           incomplete enum switch\\n\" +", "-        \"      fallthrough          possible fall-through case\\n\" +", "-        \"      fieldHiding          field hiding another variable\\n\" +", "-        \"      finalBound           type parameter with final bound\\n\" +", "-        \"      finally            + finally block not completing normally\\n\" +", "-        \"      forbidden          + use of types matching a forbidden access rule\\n\" +", "+        \"      enumSwitch           incomplete enum switch\\n\" + ", "+        \"      fallthrough          possible fall-through case\\n\" + ", "+        \"      fieldHiding          field hiding another variable\\n\" + ", "+        \"      finalBound           type parameter with final bound\\n\" + ", "+        \"      finally            + finally block not completing normally\\n\" + ", "+        \"      forbidden          + use of types matching a forbidden access rule\\n\" + ", "-        \"      hiding               macro for fieldHiding, localHiding, typeHiding and\\n\" +", "-        \"                           maskedCatchBlock\\n\" +", "-        \"      incomplete-switch    same as enumSwitch\\n\" +", "-        \"      indirectStatic       indirect reference to static member\\n\" +", "-        \"      intfAnnotation     + annotation type used as super interface\\n\" +", "-        \"      intfNonInherited   + interface non-inherited method compatibility\\n\" +", "+        \"      hiding               macro for fieldHiding, localHiding, typeHiding and\\n\" + ", "+        \"                           maskedCatchBlock\\n\" + ", "+        \"\t   includeAssertNull    raise null warnings for variables\\n\" + ", "+        \"\t\t\t\t\t\t\tthat got tainted in an assert expression\\n\" + ", "+        \"      incomplete-switch    same as enumSwitch\\n\" + ", "+        \"      indirectStatic       indirect reference to static member\\n\" + ", "+        \"      intfAnnotation     + annotation type used as super interface\\n\" + ", "+        \"      intfNonInherited   + interface non-inherited method compatibility\\n\" + ", "-        \"      javadoc              invalid javadoc\\n\" +", "-        \"      localHiding          local variable hiding another variable\\n\" +", "-        \"      maskedCatchBlock   + hidden catch block\\n\" +", "-        \"      nls                  string literal lacking non-nls tag //$NON-NLS-<n>$\\n\" +", "-        \"      noEffectAssign     + assignment without effect\\n\" +", "-        \"      null                 potential missing or redundant null check\\n\" +", "-        \"      nullDereference    + missing null check\\n\" +", "-        \"      over-ann             missing @Override annotation (superclass)\\n\" +", "-        \"      paramAssign          assignment to a parameter\\n\" +", "-        \"      pkgDefaultMethod   + attempt to override package-default method\\n\" +", "-        \"      raw                + usage of raw type\\n\" +", "-        \"      semicolon            unnecessary semicolon, empty statement\\n\" +", "-        \"      serial             + missing serialVersionUID\\n\" +", "-        \"      specialParamHiding   constructor or setter parameter hiding a field\\n\" +", "-        \"      static-access        macro for indirectStatic and staticReceiver\\n\" +", "-        \"      staticReceiver     + non-static reference to static member\\n\" +", "-        \"      super                overriding a method without making a super invocation\\n\" +", "+        \"      javadoc              invalid javadoc\\n\" + ", "+        \"      localHiding          local variable hiding another variable\\n\" + ", "+        \"      maskedCatchBlock   + hidden catch block\\n\" + ", "+        \"      nls                  string literal lacking non-nls tag //$NON-NLS-<n>$\\n\" + ", "+        \"      noEffectAssign     + assignment without effect\\n\" + ", "+        \"      null                 potential missing or redundant null check\\n\" + ", "+        \"      nullDereference    + missing null check\\n\" + ", "+        \"      over-ann             missing @Override annotation (superclass)\\n\" + ", "+        \"      paramAssign          assignment to a parameter\\n\" + ", "+        \"      pkgDefaultMethod   + attempt to override package-default method\\n\" + ", "+        \"      raw                + usage of raw type\\n\" + ", "+        \"      semicolon            unnecessary semicolon, empty statement\\n\" + ", "+        \"      serial             + missing serialVersionUID\\n\" + ", "+        \"      specialParamHiding   constructor or setter parameter hiding a field\\n\" + ", "+        \"      static-access        macro for indirectStatic and staticReceiver\\n\" + ", "+        \"      staticReceiver     + non-static reference to static member\\n\" + ", "+        \"      super                overriding a method without making a super invocation\\n\" + ", "-        \"                           When used with -err:, it can also silent optional\\n\" +", "-        \"                           errors and warnings\\n\" +", "-        \"\t   suppressAssertNull   suppress null warnings for variables\\n\" +", "-        \"\t\t\t\t\t\t\tthat got tainted in an assert expression\\n\" +", "-        \"      syncOverride         missing synchronized in synchr. method override\\n\" +", "-        \"      syntheticAccess      synthetic access for innerclass\\n\" +", "-        \"      tasks(<tags separated by |>) tasks identified by tags inside comments\\n\" +", "-        \"      typeHiding         + type parameter hiding another type\\n\" +", "-        \"      unchecked          + unchecked type operation\\n\" +", "-        \"      unnecessaryElse      unnecessary else clause\\n\" +", "-        \"      unqualifiedField     unqualified reference to field\\n\" +", "-        \"      unused               macro for unusedAllocation, unusedArgument,\\n\" +", "-        \"                               unusedImport, unusedLabel, unusedLocal,\\n\" +", "-        \"                               unusedPrivate, unusedThrown, and unusedTypeArgs\\n\" +", "-        \"      unusedAllocation     allocating an object that is not used\\n\" +", "-        \"      unusedArgument       unread method parameter\\n\" +", "-        \"      unusedImport       + unused import declaration\\n\" +", "-        \"      unusedLabel        + unused label\\n\" +", "-        \"      unusedLocal        + unread local variable\\n\" +", "-        \"      unusedPrivate      + unused private member declaration\\n\" +", "-        \"      unusedThrown         unused declared thrown exception\\n\" +", "-        \"      unusedTypeArgs     + unused type arguments for method\\n\" +", "-        \"      uselessTypeCheck     unnecessary cast/instanceof operation\\n\" +", "-        \"      varargsCast        + varargs argument need explicit cast\\n\" +", "-        \"      warningToken       + unsupported or unnecessary @SuppressWarnings\\n\" +", "-\t\t\"\\n\";", "+        \"                           When used with -err:, it can also silent optional\\n\" + ", "+        \"                           errors and warnings\\n\" + ", "+        \"\\n\";"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a8246b088297e5850e28519544848535", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/AnnotationMirrorImpl.java", "commitBeforeChange": "a3d873b0829375e0f0465ac99af6f9753248e839", "commitAfterChange": "2ed8d2842cd060fd2ed1992ac37d7e3f157e19c9", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r \r     private Object getReflectionValue(final Expression expr, final Class targetType)\r         throws Throwable", "signatureAfterChange": "      private Object getReflectionValue(final Object value, final Class targetType)         throws Throwable", "diff": ["-\r", "-    private Object getReflectionValue(final Expression expr, final Class targetType)\r", "-        throws Throwable\r", "-    {\r", "-        if( expr == null ) return null;\r", "-\t\tfinal Object constantValue = expr.resolveConstantExpressionValue();\r", "-\t\tif( constantValue != null ) return constantValue;\r", "-        switch(expr.getNodeType())\r", "-        {\r", "-        case ASTNode.SIMPLE_NAME:\r", "-        case ASTNode.QUALIFIED_NAME:\r", "-            final Name name = (Name)expr;\r", "-            final IBinding nameBinding = name.resolveBinding();\r", "-            if( nameBinding.getKind() == IBinding.VARIABLE ) {\r", "-                final IVariableBinding varBinding = (IVariableBinding)nameBinding;\r", "-                final ITypeBinding declaringClass = varBinding.getDeclaringClass();\r", "-                if( declaringClass != null ){\r", "-                    final String className = new String( declaringClass.getBinaryName() );\r", "-                    final Class clazz = expr.getClass().getClassLoader().loadClass( className );\r", "-                    final Field returnedField = clazz.getField( varBinding.getName() );\r", "-                    if( returnedField.getType() != targetType )\r", "-                        throw new ClassCastException( targetType.getName() );\r", "-                    return returnedField.get(null);\r", "-                }\r", "-            }\r", "-            break;\r", "-        case ASTNode.ARRAY_INITIALIZER:\r", "-            assert targetType.isArray();\r", "-            final Class componentType = targetType.getComponentType();\r", "-            final char componentTypeName = componentType.getName().charAt(0);\r", "-            final ArrayInitializer arrayInit = (ArrayInitializer)expr;\r", "-            final List<Expression> exprs = arrayInit.expressions();\r", "-            final int length = exprs == null ? 0 : exprs.size();\r", "-            final Object array = Array.newInstance(componentType, length);\r", "-            if( length == 0) return array;\r", "-\r", "-            for( int i=0; i<length; i++ ){\r", "-                final Expression element = exprs.get(i);\r", "-                final Object returnObj = getReflectionValue( element, componentType );\r", "-                // fill in the array.\r", "-                // If it is an array of some primitive type, we will need to unwrap it.\r", "-                if( componentType.isPrimitive() ){\r", "-                    if( componentType == boolean.class ){\r", "-                        final Boolean bool = (Boolean)returnObj;\r", "-                        Array.setBoolean( array, i, bool.booleanValue());\r", "-                    }\r", "-                    else if( componentType == byte.class ){\r", "-                        final Byte b = (Byte)returnObj;\r", "-                        Array.setByte( array, i, b.byteValue() );\r", "-                    }\r", "-                    else if( componentType == char.class ){\r", "-                        final Character c = (Character)returnObj;\r", "-                        Array.setChar( array, i, c.charValue() );\r", "-                    }\r", "-                    else if( componentType == double.class ){\r", "-                        final Double d = (Double)returnObj;\r", "-                        Array.setDouble( array, i, d.doubleValue() );\r", "-                    }\r", "-                    else if( componentType == float.class ){\r", "-                        final Float f = (Float)returnObj;\r", "-                        Array.setFloat( array, i, f.floatValue() );\r", "-                    }\r", "-                    else if( componentType == int.class ){\r", "-                        final Integer integer = (Integer)returnObj;\r", "-                        Array.setInt( array, i, integer.intValue() );\r", "-                    }\r", "-                    else if( componentType == long.class ){\r", "-                        final Long l = (Long)returnObj;\r", "-                        Array.setLong( array, i, l.longValue() );\r", "-                    }\r", "-                    else if( componentType == short.class ){\r", "-                        final Short s = (Short)returnObj;\r", "-                        Array.setShort( array, i, s.shortValue() );\r", "-                    }\r", "-                    else {\r", "-                        throw new IllegalStateException(\"unrecognized primitive type: \"  + componentType );\r", "-                    }\r", "-                }\r", "-                else{\r", "-                    Array.set( array, i, returnObj );\r", "-                }\r", "-            }\r", "-            return array;\r", "-        case ASTNode.NORMAL_ANNOTATION:\r", "-        case ASTNode.MARKER_ANNOTATION:\r", "-        case ASTNode.SINGLE_MEMBER_ANNOTATION:\r", "-            return Factory.createAnnotationMirror((Annotation)expr, _annotated, _env);        \r", "-        case ASTNode.TYPE_LITERAL:\r", "-            throw new IllegalStateException(\"illegal expression \" + expr);     \r", "-        }\r", "-\r", "-        return null;\r", "-    }\r", "+", "+    private Object getReflectionValue(final Object value, final Class targetType)", "+        throws Throwable", "+    {", "+        if( value == null ) return null;", "+        else if(value instanceof Boolean   ||", "+\t\t\t\tvalue instanceof Byte      ||", "+\t\t\t\tvalue instanceof Character ||", "+\t\t\t\tvalue instanceof Double    || ", "+\t\t\t\tvalue instanceof Float     ||", "+\t\t\t\tvalue instanceof Integer   ||", "+\t\t\t\tvalue instanceof Long      ||", "+\t\t\t\tvalue instanceof Short     ||", "+\t\t\t\tvalue instanceof String ) ", "+\t\t\treturn value;", "+        else if( value instanceof IVariableBinding )", "+\t\t{", "+\t\t\tfinal IVariableBinding varBinding = (IVariableBinding)value;", "+            final ITypeBinding declaringClass = varBinding.getDeclaringClass();", "+            if( declaringClass != null ){", "+                final String className = new String( declaringClass.getBinaryName() );", "+                final Class clazz = value.getClass().getClassLoader().loadClass( className );", "+                final Field returnedField = clazz.getField( varBinding.getName() );", "+                if( returnedField.getType() != targetType )", "+                    throw new ClassCastException( targetType.getName() );", "+                return returnedField.get(null);", "+            }", "+\t\t}", "+        else if (value instanceof Object[])", "+\t\t{", "+\t\t\tfinal Object[] elements = (Object[])value;", "+\t\t\tassert targetType.isArray();", "+            final Class componentType = targetType.getComponentType();", "+            final char componentTypeName = componentType.getName().charAt(0);", "+            final int length = elements.length;;", "+            final Object array = Array.newInstance(componentType, length);", "+            if( length == 0) return array;", "+", "+            for( int i=0; i<length; i++ ){                ", "+                final Object returnObj = getReflectionValue( elements[i], componentType );", "+                // fill in the array.", "+                // If it is an array of some primitive type, we will need to unwrap it.", "+                if( componentType.isPrimitive() ){", "+                    if( componentType == boolean.class ){", "+                        final Boolean bool = (Boolean)returnObj;", "+                        Array.setBoolean( array, i, bool.booleanValue());", "+                    }", "+                    else if( componentType == byte.class ){", "+                        final Byte b = (Byte)returnObj;", "+                        Array.setByte( array, i, b.byteValue() );", "+                    }", "+                    else if( componentType == char.class ){", "+                        final Character c = (Character)returnObj;", "+                        Array.setChar( array, i, c.charValue() );", "+                    }", "+                    else if( componentType == double.class ){", "+                        final Double d = (Double)returnObj;", "+                        Array.setDouble( array, i, d.doubleValue() );", "+                    }", "+                    else if( componentType == float.class ){", "+                        final Float f = (Float)returnObj;", "+                        Array.setFloat( array, i, f.floatValue() );", "+                    }", "+                    else if( componentType == int.class ){", "+                        final Integer integer = (Integer)returnObj;", "+                        Array.setInt( array, i, integer.intValue() );", "+                    }", "+                    else if( componentType == long.class ){", "+                        final Long l = (Long)returnObj;", "+                        Array.setLong( array, i, l.longValue() );", "+                    }", "+                    else if( componentType == short.class ){", "+                        final Short s = (Short)returnObj;", "+                        Array.setShort( array, i, s.shortValue() );", "+                    }", "+                    else {", "+                        throw new IllegalStateException(\"unrecognized primitive type: \"  + componentType );", "+                    }", "+                }", "+                else{", "+                    Array.set( array, i, returnObj );", "+                }", "+            }", "+\t\t}", "+\t\t// caller should have caught this case.", "+        else if( value instanceof ITypeBinding )", "+\t\t\tthrow new IllegalStateException();", "+\t\t", "+        else if( value instanceof IResolvedAnnotation )", "+\t\t{", "+\t\t\treturn Factory.createAnnotationMirror((IResolvedAnnotation)value, _annotated, _env);", "+\t\t}", "+", "+        return null;", "+    }"]}], "num": 72361}