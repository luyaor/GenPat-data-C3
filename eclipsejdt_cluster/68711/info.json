{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b18f9be57f05f45163ac18e7ff95457c", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "041366edfb42d7ef02582c8eeb0ecb7d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 247, "methodNumberAfterChange": 247, "signatureBeforeChange": " public void test100()", "signatureAfterChange": " public void test100()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tthis.runNegativeTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"import java.util.Collection;\\n\" + ", "-\t\t\t\t\"public class X<E> {\\n\" + ", "-\t\t\t\t\"  boolean removeAll(Collection<? extends E> c) {\\n\" + ", "-\t\t\t\t\"    return false;\\n\" + ", "-\t\t\t\t\"  }\\n\" + ", "-\t\t\t\t\"}\\n\",", "-\t\t\t\t\"Y.java\",", "-\t\t\t\t\"import java.util.Collection;\\n\" + ", "-\t\t\t\t\"public class Y<E> extends X<E>\\n\" + ", "-\t\t\t\t\"{\\n\" + ", "-\t\t\t\t\"  <T extends E> boolean removeAll(Collection<T> c) {\\n\" + ", "-\t\t\t\t\"    return false;\\n\" + ", "-\t\t\t\t\"  }\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"----------\\n\" + ", "-\t\t\t\"1. ERROR in Y.java (at line 4)\\n\" + ", "-\t\t\t\"\t<T extends E> boolean removeAll(Collection<T> c) {\\n\" + ", "-\t\t\t\"\t                      ^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\" + ", "-\t\t\t\"Name clash: The method removeAll(Collection<T>) of type Y<E> has the same erasure as removeAll(Collection<? extends E>) of type X<E> but does not override it\\n\" + ", "-\t\t\t\"----------\\n\"", "-\t\t);", "-\t}", "+\tthis.runNegativeTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"import java.util.Collection;\\n\" + ", "+\t\t\t\"public class X<E> {\\n\" + ", "+\t\t\t\"  boolean removeAll(Collection<? extends E> c) {\\n\" + ", "+\t\t\t\"    return false;\\n\" + ", "+\t\t\t\"  }\\n\" + ", "+\t\t\t\"}\\n\",", "+\t\t\t\"Y.java\",", "+\t\t\t\"import java.util.Collection;\\n\" + ", "+\t\t\t\"public class Y<E> extends X<E>\\n\" + ", "+\t\t\t\"{\\n\" + ", "+\t\t\t\"  <T extends E> boolean removeAll(Collection<T> c) {\\n\" + ", "+\t\t\t\"    return false;\\n\" + ", "+\t\t\t\"  }\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"----------\\n\" + ", "+\t\t\"1. ERROR in Y.java (at line 4)\\n\" + ", "+\t\t\"\t<T extends E> boolean removeAll(Collection<T> c) {\\n\" + ", "+\t\t\"\t                      ^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\" + ", "+\t\t\"Name clash: The method removeAll(Collection<T>) of type Y<E> has the same erasure as removeAll(Collection<? extends E>) of type X<E> but does not override it\\n\" + ", "+\t\t\"----------\\n\"", "+\t);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "182214b65513a7daef601b0e7d0a17e8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 264, "methodNumberAfterChange": 264, "signatureBeforeChange": " public void test117()", "signatureAfterChange": " public void test117()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-    \tMap options = this.getCompilerOptions();", "-    \toptions.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.ERROR);", "-    \tthis.runNegativeTest(", "-    \t\tnew String[] {", "-    \t\t\t\"X.java\",", "-    \t\t\t\"class Y {\\n\" + ", "-    \t\t\t\"  Object foo() {\\n\" +", "-    \t\t\t\"     return null;\\n\" +", "-    \t\t\t\"  }\\n\" + ", "-    \t\t\t\"}\\n\" + ", "-    \t\t\t\"public class X extends Y {\\n\" + ", "-    \t\t\t\"  @Override\\n\" +", "-    \t\t\t\"  Object foo() {\\n\" +", "-    \t\t\t\"     return new Y() {\\n\" +", "-       \t\t\t\"         @Override\\n\" +", "-    \t\t\t\"         Object foo() {\\n\" +", "-    \t\t\t\"            return null;\\n\" +", "-    \t\t\t\"         }\\n\" +", "-    \t\t\t\"     };\" +", "-    \t\t\t\"  }\\n\" + ", "-    \t\t\t\"}\"", "-    \t\t},", "-    \t\t\"----------\\n\" + ", "-    \t\t\"1. ERROR in X.java (at line 8)\\n\" + ", "-    \t\t\"\tObject foo() {\\n\" + ", "-    \t\t\"\t       ^^^^^\\n\" + ", "-    \t\t\"The method X.foo() is overriding a method without making a super invocation\\n\" + ", "-    \t\t\"----------\\n\" + ", "-    \t\t\"2. ERROR in X.java (at line 11)\\n\" + ", "-    \t\t\"\tObject foo() {\\n\" + ", "-    \t\t\"\t       ^^^^^\\n\" + ", "-    \t\t\"The method new Y(){}.foo() is overriding a method without making a super invocation\\n\" + ", "-    \t\t\"----------\\n\",", "-    \t\tnull,", "-    \t\ttrue,", "-    \t\toptions", "-    \t);", "-\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.ERROR);", "+\tthis.runNegativeTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"class Y {\\n\" + ", "+\t\t\t\"  Object foo() {\\n\" +", "+\t\t\t\"     return null;\\n\" +", "+\t\t\t\"  }\\n\" + ", "+\t\t\t\"}\\n\" + ", "+\t\t\t\"public class X extends Y {\\n\" + ", "+\t\t\t\"  @Override\\n\" +", "+\t\t\t\"  Object foo() {\\n\" +", "+\t\t\t\"     return new Y() {\\n\" +", "+   \t\t\t\"         @Override\\n\" +", "+\t\t\t\"         Object foo() {\\n\" +", "+\t\t\t\"            return null;\\n\" +", "+\t\t\t\"         }\\n\" +", "+\t\t\t\"     };\" +", "+\t\t\t\"  }\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"----------\\n\" + ", "+\t\t\"1. ERROR in X.java (at line 8)\\n\" + ", "+\t\t\"\tObject foo() {\\n\" + ", "+\t\t\"\t       ^^^^^\\n\" + ", "+\t\t\"The method X.foo() is overriding a method without making a super invocation\\n\" + ", "+\t\t\"----------\\n\" + ", "+\t\t\"2. ERROR in X.java (at line 11)\\n\" + ", "+\t\t\"\tObject foo() {\\n\" + ", "+\t\t\"\t       ^^^^^\\n\" + ", "+\t\t\"The method new Y(){}.foo() is overriding a method without making a super invocation\\n\" + ", "+\t\t\"----------\\n\",", "+\t\tnull,", "+\t\ttrue,", "+\t\toptions", "+\t);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2089fd40c85ba1187d70f33fad30376f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 266, "methodNumberAfterChange": 266, "signatureBeforeChange": " public void test119()", "signatureAfterChange": " public void test119()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-    \tMap options = this.getCompilerOptions();", "-    \toptions.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.ERROR);", "-    \tthis.runNegativeTest(", "-    \t\tnew String[] {", "-    \t\t\t\"X.java\",", "-    \t\t\t\"class Y<E> {\\n\" + ", "-    \t\t\t\"\tE foo() {\\n\" + ", "-    \t\t\t\"\t\treturn null;\\n\" + ", "-    \t\t\t\"\t}\\n\" + ", "-    \t\t\t\"}\\n\" + ", "-    \t\t\t\"\\n\" + ", "-    \t\t\t\"public class X<T> extends Y<T> {\\n\" + ", "-    \t\t\t\"\t@Override\\n\" + ", "-    \t\t\t\"\tT foo() {\\n\" + ", "-    \t\t\t\"\t\treturn null;\\n\" + ", "-    \t\t\t\"\t}\\n\" + ", "-    \t\t\t\"}\"", "-    \t\t},", "-    \t\t\"----------\\n\" + ", "-    \t\t\"1. ERROR in X.java (at line 9)\\n\" + ", "-    \t\t\"\tT foo() {\\n\" + ", "-    \t\t\"\t  ^^^^^\\n\" + ", "-    \t\t\"The method X<T>.foo() is overriding a method without making a super invocation\\n\" + ", "-    \t\t\"----------\\n\",", "-    \t\tnull,", "-    \t\ttrue,", "-    \t\toptions", "-    \t);", "-\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.ERROR);", "+\tthis.runNegativeTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"class Y<E> {\\n\" + ", "+\t\t\t\"\tE foo() {\\n\" + ", "+\t\t\t\"\t\treturn null;\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"public class X<T> extends Y<T> {\\n\" + ", "+\t\t\t\"\t@Override\\n\" + ", "+\t\t\t\"\tT foo() {\\n\" + ", "+\t\t\t\"\t\treturn null;\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"----------\\n\" + ", "+\t\t\"1. ERROR in X.java (at line 9)\\n\" + ", "+\t\t\"\tT foo() {\\n\" + ", "+\t\t\"\t  ^^^^^\\n\" + ", "+\t\t\"The method X<T>.foo() is overriding a method without making a super invocation\\n\" + ", "+\t\t\"----------\\n\",", "+\t\tnull,", "+\t\ttrue,", "+\t\toptions", "+\t);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "311ec2d5719a58da57ed60b211f486a9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 255, "methodNumberAfterChange": 255, "signatureBeforeChange": " public void test108()", "signatureAfterChange": " public void test108()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runNegativeTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnLeaf extends ReturnDerived {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface Interface<E> {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Implementation<T> {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child<U> extends Implementation<U> implements Interface<U> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> implements Interface<V> {\\n\" +", "-\t\t\t\t\"\t\t@Override\\n\" + ", "-\t\t\t\t\"\t\tpublic ReturnLeaf bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild<String>();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"----------\\n\" + ", "-\t\t\t\"1. ERROR in X.java (at line 26)\\n\" + ", "-\t\t\t\"\tpublic ReturnLeaf bar() {\\n\" + ", "-\t\t\t\"\t                  ^^^^^\\n\" + ", "-\t\t\t\"Cannot override the final method from X.Implementation<V>\\n\" + ", "-\t\t\t\"----------\\n\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\toptions", "-\t\t);", "-\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runNegativeTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnLeaf extends ReturnDerived {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface Interface<E> {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Implementation<T> {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child<U> extends Implementation<U> implements Interface<U> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> implements Interface<V> {\\n\" +", "+\t\t\t\"\t\t@Override\\n\" + ", "+\t\t\t\"\t\tpublic ReturnLeaf bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild<String>();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"----------\\n\" + ", "+\t\t\"1. ERROR in X.java (at line 26)\\n\" + ", "+\t\t\"\tpublic ReturnLeaf bar() {\\n\" + ", "+\t\t\"\t                  ^^^^^\\n\" + ", "+\t\t\"Cannot override the final method from X.Implementation<V>\\n\" + ", "+\t\t\"----------\\n\",", "+\t\tnull,", "+\t\ttrue,", "+\t\toptions", "+\t);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "448fff14fa41dc31e83013cae658dd91", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 261, "methodNumberAfterChange": 261, "signatureBeforeChange": " public void test114()", "signatureAfterChange": " public void test114()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-    \tMap options = this.getCompilerOptions();", "-    \toptions.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.ERROR);", "-    \tthis.runNegativeTest(", "-    \t\tnew String[] {", "-    \t\t\t\"X.java\",", "-    \t\t\t\"class Y {\\n\" + ", "-    \t\t\t\"  void foo() {}\\n\" + ", "-    \t\t\t\"}\\n\" + ", "-    \t\t\t\"public class X extends Y {\\n\" + ", "-    \t\t\t\"  @Override\\n\" +", "-    \t\t\t\"  void foo() {\\n\" + ", "-    \t\t\t\"  }\\n\" + ", "-    \t\t\t\"}\"", "-    \t\t},", "-    \t\t\"----------\\n\" + ", "-    \t\t\"1. ERROR in X.java (at line 6)\\n\" + ", "-    \t\t\"\tvoid foo() {\\n\" + ", "-    \t\t\"\t     ^^^^^\\n\" + ", "-    \t\t\"The method X.foo() is overriding a method without making a super invocation\\n\" + ", "-    \t\t\"----------\\n\",", "-    \t\tnull,", "-    \t\ttrue,", "-    \t\toptions", "-    \t);", "-\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.ERROR);", "+\tthis.runNegativeTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"class Y {\\n\" + ", "+\t\t\t\"  void foo() {}\\n\" + ", "+\t\t\t\"}\\n\" + ", "+\t\t\t\"public class X extends Y {\\n\" + ", "+\t\t\t\"  @Override\\n\" +", "+\t\t\t\"  void foo() {\\n\" + ", "+\t\t\t\"  }\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"----------\\n\" + ", "+\t\t\"1. ERROR in X.java (at line 6)\\n\" + ", "+\t\t\"\tvoid foo() {\\n\" + ", "+\t\t\"\t     ^^^^^\\n\" + ", "+\t\t\"The method X.foo() is overriding a method without making a super invocation\\n\" + ", "+\t\t\"----------\\n\",", "+\t\tnull,", "+\t\ttrue,", "+\t\toptions", "+\t);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d8c03fe9aea472e71ee19861f0cc2b5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 259, "methodNumberAfterChange": 259, "signatureBeforeChange": " public void test112()", "signatureAfterChange": " public void test112()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Super<E> {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static abstract class Implementation<T> extends Super<T> {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child<U> extends Implementation<U> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\tnull,", "-\t\t\toptions,", "-\t\t\tnull", "-\t\t);", "-\t\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "-\t\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "-\t\tboolean found = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runConformTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Super<E> {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static abstract class Implementation<T> extends Super<T> {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child<U> extends Implementation<U> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"\",", "+\t\tnull,", "+\t\ttrue,", "+\t\tnull,", "+\t\toptions,", "+\t\tnull", "+\t);", "+\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "+\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "+\tboolean found = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tint count = 0;", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tIMethodInfo methodInfo = methodInfos[i];", "-\t\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "-\t\t\t\tcount++;", "-\t\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "-\t\t\t\t\tfound = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tassertEquals(\"should have two methods bar\", 2, count);", "-\t\tassertTrue(\"should have one bridge method\", found);", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tint count = 0;", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tIMethodInfo methodInfo = methodInfos[i];", "+\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "+\t\t\tcount++;", "+\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "+\t\t\t\tfound = true;", "+\t\t\t}", "+\t\t}", "+\t}", "+\tassertEquals(\"should have two methods bar\", 2, count);", "+\tassertTrue(\"should have one bridge method\", found);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "79d16a5ff2f54774f1c71e2abf8eebbb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 252, "methodNumberAfterChange": 252, "signatureBeforeChange": " public void test105()", "signatureAfterChange": " public void test105()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Super {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Implementation extends Super {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child extends Implementation {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild extends Child {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\tnull,", "-\t\t\toptions,", "-\t\t\tnull", "-\t\t);", "-\t\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "-\t\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "-\t\tboolean found = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runConformTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Super {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Implementation extends Super {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child extends Implementation {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild extends Child {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"\",", "+\t\tnull,", "+\t\ttrue,", "+\t\tnull,", "+\t\toptions,", "+\t\tnull", "+\t);", "+\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "+\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "+\tboolean found = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tint count = 0;", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tIMethodInfo methodInfo = methodInfos[i];", "-\t\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "-\t\t\t\tcount++;", "-\t\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "-\t\t\t\t\tfound = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tassertEquals(\"Should have two method bar\", 2, count);", "-\t\tassertTrue(\"should have one bridge method\", found);", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tint count = 0;", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tIMethodInfo methodInfo = methodInfos[i];", "+\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "+\t\t\tcount++;", "+\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "+\t\t\t\tfound = true;", "+\t\t\t}", "+\t\t}", "+\t}", "+\tassertEquals(\"Should have two method bar\", 2, count);", "+\tassertTrue(\"should have one bridge method\", found);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "830d64433cf1b363b8e9ad80535d827d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 251, "methodNumberAfterChange": 251, "signatureBeforeChange": " public void test104()", "signatureAfterChange": " public void test104()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface Interface {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Implementation {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child extends Implementation implements Interface {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild extends Child implements Interface {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\tnull,", "-\t\t\toptions,", "-\t\t\tnull", "-\t\t);", "-\t\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "-\t\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "-\t\tboolean found = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runConformTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface Interface {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Implementation {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child extends Implementation implements Interface {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild extends Child implements Interface {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"\",", "+\t\tnull,", "+\t\ttrue,", "+\t\tnull,", "+\t\toptions,", "+\t\tnull", "+\t);", "+\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "+\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "+\tboolean found = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "-\t\tassertTrue(\"bar should be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\tassertFalse(\"bar should not be there\", found);\t\t", "+\tassertTrue(\"bar should be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+\tassertFalse(\"bar should not be there\", found);\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "866d68b6ff91426b74695e90a3755b02", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 249, "methodNumberAfterChange": 249, "signatureBeforeChange": " public void test102()", "signatureAfterChange": " public void test102()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runNegativeTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnLeaf extends ReturnDerived {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface Interface {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Implementation {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child extends Implementation implements Interface {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild extends Child implements Interface {\\n\" +", "-\t\t\t\t\"\t\t@Override\\n\" + ", "-\t\t\t\t\"\t\tpublic ReturnLeaf bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"----------\\n\" + ", "-\t\t\t\"1. ERROR in X.java (at line 26)\\n\" + ", "-\t\t\t\"\tpublic ReturnLeaf bar() {\\n\" + ", "-\t\t\t\"\t                  ^^^^^\\n\" + ", "-\t\t\t\"Cannot override the final method from X.Implementation\\n\" + ", "-\t\t\t\"----------\\n\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\toptions", "-\t\t);", "-\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runNegativeTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnLeaf extends ReturnDerived {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface Interface {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Implementation {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child extends Implementation implements Interface {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild extends Child implements Interface {\\n\" +", "+\t\t\t\"\t\t@Override\\n\" + ", "+\t\t\t\"\t\tpublic ReturnLeaf bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"----------\\n\" + ", "+\t\t\"1. ERROR in X.java (at line 26)\\n\" + ", "+\t\t\"\tpublic ReturnLeaf bar() {\\n\" + ", "+\t\t\"\t                  ^^^^^\\n\" + ", "+\t\t\"Cannot override the final method from X.Implementation\\n\" + ", "+\t\t\"----------\\n\",", "+\t\tnull,", "+\t\ttrue,", "+\t\toptions", "+\t);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8acfcf0b4e2c28efa0c15548c25c5fbd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 250, "methodNumberAfterChange": 250, "signatureBeforeChange": " public void test103()", "signatureAfterChange": " public void test103()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface Interface {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Implementation {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild extends Child implements Interface {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child extends Implementation implements Interface {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\tnull,", "-\t\t\toptions,", "-\t\t\tnull", "-\t\t);", "-\t\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "-\t\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "-\t\tboolean found = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runConformTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface Interface {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Implementation {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild extends Child implements Interface {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child extends Implementation implements Interface {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"\",", "+\t\tnull,", "+\t\ttrue,", "+\t\tnull,", "+\t\toptions,", "+\t\tnull", "+\t);", "+\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "+\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "+\tboolean found = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "-\t\tassertTrue(\"bar should be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\tassertFalse(\"bar should not be there\", found);\t\t", "+\tassertTrue(\"bar should be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+\tassertFalse(\"bar should not be there\", found);\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e46221eb64066ec868e6599e6b76483", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 256, "methodNumberAfterChange": 256, "signatureBeforeChange": " public void test109()", "signatureAfterChange": " public void test109()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface Interface<E> {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Implementation<T> {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> implements Interface<V> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child<U> extends Implementation<U> implements Interface<U> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\tnull,", "-\t\t\toptions,", "-\t\t\tnull", "-\t\t);", "-\t\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "-\t\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "-\t\tboolean found = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runConformTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface Interface<E> {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Implementation<T> {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> implements Interface<V> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child<U> extends Implementation<U> implements Interface<U> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"\",", "+\t\tnull,", "+\t\ttrue,", "+\t\tnull,", "+\t\toptions,", "+\t\tnull", "+\t);", "+\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "+\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "+\tboolean found = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "-\t\tassertTrue(\"bar should be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\tassertFalse(\"bar should not be there\", found);\t\t", "+\tassertTrue(\"bar should be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+\tassertFalse(\"bar should not be there\", found);\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9239670b17de13b0131f90522ee98b75", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 265, "methodNumberAfterChange": 265, "signatureBeforeChange": " public void test118()", "signatureAfterChange": " public void test118()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-    \tMap options = this.getCompilerOptions();", "-    \toptions.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.ERROR);", "-    \tthis.runNegativeTest(", "-    \t\tnew String[] {", "-    \t\t\t\"X.java\",", "-    \t\t\t\"class Y<E> {\\n\" + ", "-    \t\t\t\"\t<U extends E> U foo() {\\n\" + ", "-    \t\t\t\"\t\treturn null;\\n\" + ", "-    \t\t\t\"\t}\\n\" + ", "-    \t\t\t\"}\\n\" + ", "-    \t\t\t\"\\n\" + ", "-    \t\t\t\"public class X<T> extends Y<T> {\\n\" + ", "-    \t\t\t\"\t@Override\\n\" + ", "-    \t\t\t\"\t<V extends T> V foo() {\\n\" + ", "-    \t\t\t\"\t\treturn null;\\n\" + ", "-    \t\t\t\"\t}\\n\" + ", "-    \t\t\t\"}\"", "-    \t\t},", "-    \t\t\"----------\\n\" + ", "-    \t\t\"1. ERROR in X.java (at line 9)\\n\" + ", "-    \t\t\"\t<V extends T> V foo() {\\n\" + ", "-    \t\t\"\t                ^^^^^\\n\" + ", "-    \t\t\"The method X<T>.foo() is overriding a method without making a super invocation\\n\" + ", "-    \t\t\"----------\\n\",", "-    \t\tnull,", "-    \t\ttrue,", "-    \t\toptions", "-    \t);", "-\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.ERROR);", "+\tthis.runNegativeTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"class Y<E> {\\n\" + ", "+\t\t\t\"\t<U extends E> U foo() {\\n\" + ", "+\t\t\t\"\t\treturn null;\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"public class X<T> extends Y<T> {\\n\" + ", "+\t\t\t\"\t@Override\\n\" + ", "+\t\t\t\"\t<V extends T> V foo() {\\n\" + ", "+\t\t\t\"\t\treturn null;\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"----------\\n\" + ", "+\t\t\"1. ERROR in X.java (at line 9)\\n\" + ", "+\t\t\"\t<V extends T> V foo() {\\n\" + ", "+\t\t\"\t                ^^^^^\\n\" + ", "+\t\t\"The method X<T>.foo() is overriding a method without making a super invocation\\n\" + ", "+\t\t\"----------\\n\",", "+\t\tnull,", "+\t\ttrue,", "+\t\toptions", "+\t);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a7d820c3bc286925b38d4cce399ff0f2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 248, "methodNumberAfterChange": 248, "signatureBeforeChange": " public void test101()", "signatureAfterChange": " public void test101()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tthis.runNegativeTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"import java.util.List;\\n\" + ", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"    Integer getX(List<Integer> l) {\\n\" + ", "-\t\t\t\t\"        return null;\\n\" + ", "-\t\t\t\t\"    }\\n\" + ", "-\t\t\t\t\"    String getX(List<String> l) {\\n\" + ", "-\t\t\t\t\"        return null;\\n\" + ", "-\t\t\t\t\"    }\\n\" + ", "-\t\t\t\t\"}\\n\" + ", "-\t\t\t\t\"class Y {\\n\" + ", "-\t\t\t\t\"    Integer getX(List<Integer> l) {\\n\" + ", "-\t\t\t\t\"        return null;\\n\" + ", "-\t\t\t\t\"    }\\n\" + ", "-\t\t\t\t\"    String getX(List<Integer> l) {\\n\" + ", "-\t\t\t\t\"        return null;\\n\" + ", "-\t\t\t\t\"    }\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"----------\\n\" + ", "-\t\t\t\"1. ERROR in X.java (at line 11)\\n\" + ", "-\t\t\t\"\tInteger getX(List<Integer> l) {\\n\" + ", "-\t\t\t\"\t        ^^^^^^^^^^^^^^^^^^^^^\\n\" + ", "-\t\t\t\"Duplicate method getX(List<Integer>) in type Y\\n\" + ", "-\t\t\t\"----------\\n\" + ", "-\t\t\t\"2. ERROR in X.java (at line 14)\\n\" + ", "-\t\t\t\"\tString getX(List<Integer> l) {\\n\" + ", "-\t\t\t\"\t       ^^^^^^^^^^^^^^^^^^^^^\\n\" + ", "-\t\t\t\"Duplicate method getX(List<Integer>) in type Y\\n\" + ", "-\t\t\t\"----------\\n\"", "-\t\t);", "-\t}", "+\tthis.runNegativeTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"import java.util.List;\\n\" + ", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"    Integer getX(List<Integer> l) {\\n\" + ", "+\t\t\t\"        return null;\\n\" + ", "+\t\t\t\"    }\\n\" + ", "+\t\t\t\"    String getX(List<String> l) {\\n\" + ", "+\t\t\t\"        return null;\\n\" + ", "+\t\t\t\"    }\\n\" + ", "+\t\t\t\"}\\n\" + ", "+\t\t\t\"class Y {\\n\" + ", "+\t\t\t\"    Integer getX(List<Integer> l) {\\n\" + ", "+\t\t\t\"        return null;\\n\" + ", "+\t\t\t\"    }\\n\" + ", "+\t\t\t\"    String getX(List<Integer> l) {\\n\" + ", "+\t\t\t\"        return null;\\n\" + ", "+\t\t\t\"    }\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"----------\\n\" + ", "+\t\t\"1. ERROR in X.java (at line 11)\\n\" + ", "+\t\t\"\tInteger getX(List<Integer> l) {\\n\" + ", "+\t\t\"\t        ^^^^^^^^^^^^^^^^^^^^^\\n\" + ", "+\t\t\"Duplicate method getX(List<Integer>) in type Y\\n\" + ", "+\t\t\"----------\\n\" + ", "+\t\t\"2. ERROR in X.java (at line 14)\\n\" + ", "+\t\t\"\tString getX(List<Integer> l) {\\n\" + ", "+\t\t\"\t       ^^^^^^^^^^^^^^^^^^^^^\\n\" + ", "+\t\t\"Duplicate method getX(List<Integer>) in type Y\\n\" + ", "+\t\t\"----------\\n\"", "+\t);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3bfbac166c362477483ffbaf9129d16", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 258, "methodNumberAfterChange": 258, "signatureBeforeChange": " public void test111()", "signatureAfterChange": " public void test111()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Super<E> {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Implementation<T> extends Super<T> {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child<U> extends Implementation<U> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\tnull,", "-\t\t\toptions,", "-\t\t\tnull", "-\t\t);", "-\t\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "-\t\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "-\t\tboolean found = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runConformTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Super<E> {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Implementation<T> extends Super<T> {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child<U> extends Implementation<U> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"\",", "+\t\tnull,", "+\t\ttrue,", "+\t\tnull,", "+\t\toptions,", "+\t\tnull", "+\t);", "+\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "+\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "+\tboolean found = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tint count = 0;", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tIMethodInfo methodInfo = methodInfos[i];", "-\t\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "-\t\t\t\tcount++;", "-\t\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "-\t\t\t\t\tfound = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tassertEquals(\"should have two methods bar\", 2, count);", "-\t\tassertTrue(\"should have one bridge method\", found);", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tint count = 0;", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tIMethodInfo methodInfo = methodInfos[i];", "+\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "+\t\t\tcount++;", "+\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "+\t\t\t\tfound = true;", "+\t\t\t}", "+\t\t}", "+\t}", "+\tassertEquals(\"should have two methods bar\", 2, count);", "+\tassertTrue(\"should have one bridge method\", found);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d2cda0ac6ea04bd424c324459ba058e8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 253, "methodNumberAfterChange": 253, "signatureBeforeChange": " public void test106()", "signatureAfterChange": " public void test106()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Super {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static abstract class Implementation extends Super {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child extends Implementation {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild extends Child {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\tnull,", "-\t\t\toptions,", "-\t\t\tnull", "-\t\t);", "-\t\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "-\t\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "-\t\tboolean found = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runConformTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Super {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static abstract class Implementation extends Super {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child extends Implementation {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild extends Child {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"\",", "+\t\tnull,", "+\t\ttrue,", "+\t\tnull,", "+\t\toptions,", "+\t\tnull", "+\t);", "+\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "+\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "+\tboolean found = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tint count = 0;", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tIMethodInfo methodInfo = methodInfos[i];", "-\t\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "-\t\t\t\tcount ++;", "-\t\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "-\t\t\t\t\tfound = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tassertEquals(\"should have two methods bar\", 2, count);", "-\t\tassertTrue(\"should have one bridge method\", found);", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tint count = 0;", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tIMethodInfo methodInfo = methodInfos[i];", "+\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "+\t\t\tcount ++;", "+\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "+\t\t\t\tfound = true;", "+\t\t\t}", "+\t\t}", "+\t}", "+\tassertEquals(\"should have two methods bar\", 2, count);", "+\tassertTrue(\"should have one bridge method\", found);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ed4a5a24d2aba6f46d578ad431be713e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 262, "methodNumberAfterChange": 262, "signatureBeforeChange": " public void test115()", "signatureAfterChange": " public void test115()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-    \tMap options = this.getCompilerOptions();", "-    \toptions.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.ERROR);", "-    \tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-    \t\t\t\"class Y {\\n\" + ", "-    \t\t\t\"  void foo() {}\\n\" + ", "-    \t\t\t\"}\\n\" + ", "-    \t\t\t\"public class X extends Y {\\n\" + ", "-    \t\t\t\"  @Override\\n\" +", "-    \t\t\t\"  void foo() {\\n\" + ", "-    \t\t\t\"    super.foo();\\n\" + ", "-    \t\t\t\"  }\\n\" + ", "-    \t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\tnull,", "-\t\t\toptions,", "-\t\t\tnull", "-\t\t);", "-\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.ERROR);", "+\tthis.runConformTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"class Y {\\n\" + ", "+\t\t\t\"  void foo() {}\\n\" + ", "+\t\t\t\"}\\n\" + ", "+\t\t\t\"public class X extends Y {\\n\" + ", "+\t\t\t\"  @Override\\n\" +", "+\t\t\t\"  void foo() {\\n\" + ", "+\t\t\t\"    super.foo();\\n\" + ", "+\t\t\t\"  }\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"\",", "+\t\tnull,", "+\t\ttrue,", "+\t\tnull,", "+\t\toptions,", "+\t\tnull", "+\t);"]}], "num": 68711}