{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c8f66476a00cff7e29e930442899a530", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3592058f60f72185226a894ac100a7c0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, Assignment assignment, boolean isCompound)", "signatureAfterChange": "  public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, Assignment assignment, boolean isCompound)", "diff": ["-\t}", "-\tpublic FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, Assignment assignment, boolean isCompound) {", "-\t", "-\t\tboolean isReachable = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "-\t\t// compound assignment extra work", "-\t\tif (isCompound) { // check the variable part is initialized if blank final", "-\t\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\t\tcase Binding.FIELD : // reading a field", "-\t\t\t\t\tFieldBinding fieldBinding;", "-\t\t\t\t\tif ((fieldBinding = (FieldBinding) binding).isBlankFinal() ", "-\t\t\t\t\t\t\t&& currentScope.needBlankFinalFieldInitializationCheck(fieldBinding)) {", "-\t\t\t\t\t\tif (!flowInfo.isDefinitelyAssigned(fieldBinding)) {", "-\t\t\t\t\t\t\tcurrentScope.problemReporter().uninitializedBlankFinalField(fieldBinding, this);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tmanageSyntheticAccessIfNecessary(currentScope, flowInfo, true /*read-access*/);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase Binding.LOCAL : // reading a local variable", "-\t\t\t\t\t// check if assigning a final blank field", "-\t\t\t\t\tLocalVariableBinding localBinding;", "-\t\t\t\t\tif (!flowInfo.isDefinitelyAssigned(localBinding = (LocalVariableBinding) binding)) {", "-\t\t\t\t\t\tcurrentScope.problemReporter().uninitializedLocalVariable(localBinding, this);", "-\t\t\t\t\t\t// we could improve error msg here telling \"cannot use compound assignment on final local variable\"", "-\t\t\t\t\t}", "-\t\t\t\t\tif (isReachable) {", "-\t\t\t\t\t\tlocalBinding.useFlag = LocalVariableBinding.USED;", "-\t\t\t\t\t} else if (localBinding.useFlag == LocalVariableBinding.UNUSED) {", "-\t\t\t\t\t\tlocalBinding.useFlag = LocalVariableBinding.FAKE_USED;", "-\t\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (assignment.expression != null) {", "-\t\t\tflowInfo = assignment.expression.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();", "-\t\t}", "-\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\tcase Binding.FIELD : // assigning to a field", "-\t\t\t\tmanageSyntheticAccessIfNecessary(currentScope, flowInfo, false /*write-access*/);", "-\t", "-\t\t\t\tFieldBinding fieldBinding = (FieldBinding) binding;", "-\t\t\t\tReferenceBinding declaringClass = fieldBinding.declaringClass;", "-\t\t\t\t// check if accessing enum static field in initializer", "-\t\t\t\tif (declaringClass.isEnum()) {", "-\t\t\t\t\tMethodScope methodScope = currentScope.methodScope();", "-\t\t\t\t\tSourceTypeBinding sourceType = currentScope.enclosingSourceType();", "-\t\t\t\t\tif (fieldBinding.isStatic()", "-\t\t\t\t\t\t\t&& this.constant == Constant.NotAConstant", "-\t\t\t\t\t\t\t&& !methodScope.isStatic", "-\t\t\t\t\t\t\t&& (sourceType == declaringClass || sourceType.superclass == declaringClass) // enum constant body", "-\t\t\t\t\t\t\t&& methodScope.isInsideInitializerOrConstructor()) {", "-\t\t\t\t\t\tcurrentScope.problemReporter().enumStaticFieldUsedDuringInitialization(fieldBinding, this);", "-\t\t\t\t\t}", "-\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t// check if assigning a final field", "-\t\t\t\tif (fieldBinding.isFinal()) {", "-\t\t\t\t\t// inside a context where allowed", "-\t\t\t\t\tif (!isCompound && fieldBinding.isBlankFinal() && currentScope.allowBlankFinalFieldAssignment(fieldBinding)) {", "-\t\t\t\t\t\tif (flowInfo.isPotentiallyAssigned(fieldBinding)) {", "-\t\t\t\t\t\t\tcurrentScope.problemReporter().duplicateInitializationOfBlankFinalField(fieldBinding, this);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tflowContext.recordSettingFinal(fieldBinding, this, flowInfo);\t\t\t\t\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(fieldBinding);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalField(fieldBinding, this);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase Binding.LOCAL : // assigning to a local variable ", "-\t\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) binding;", "-\t\t\t\tif (!flowInfo.isDefinitelyAssigned(localBinding)){// for local variable debug attributes", "-\t\t\t\t\tbits |= FirstAssignmentToLocal;", "-\t\t\t\t} else {", "-\t\t\t\t\tbits &= ~FirstAssignmentToLocal;", "-\t\t\t\t}", "-\t\t\t\tif (localBinding.isFinal()) {", "-\t\t\t\t\tif ((bits & DepthMASK) == 0) {", "-\t\t\t\t\t\t// tolerate assignment to final local in unreachable code (45674)", "-\t\t\t\t\t\tif ((isReachable && isCompound) || !localBinding.isBlankFinal()){", "-\t\t\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalLocal(localBinding, this);", "-\t\t\t\t\t\t} else if (flowInfo.isPotentiallyAssigned(localBinding)) {", "-\t\t\t\t\t\t\tcurrentScope.problemReporter().duplicateInitializationOfFinalLocal(localBinding, this);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tflowContext.recordSettingFinal(localBinding, this, flowInfo);\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalOuterLocal(localBinding, this);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\telse /* avoid double diagnostic */ if ((localBinding.tagBits & TagBits.IsArgument) != 0) {", "-\t\t\t\t\tcurrentScope.problemReporter().parameterAssignment(localBinding, this);", "-\t\t\t\t}", "-\t\t\t\tflowInfo.markAsDefinitelyAssigned(localBinding);", "-\t\t}", "-\t\tmanageEnclosingInstanceAccessIfNecessary(currentScope, flowInfo);", "-\t\treturn flowInfo;", "-\t}", "+", "+public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, Assignment assignment, boolean isCompound) {", "+\tboolean isReachable = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "+\t// compound assignment extra work", "+\tif (isCompound) { // check the variable part is initialized if blank final", "+\t\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\t\t\tFieldBinding fieldBinding;", "+\t\t\t\tif ((fieldBinding = (FieldBinding) this.binding).isBlankFinal() ", "+\t\t\t\t\t\t&& currentScope.needBlankFinalFieldInitializationCheck(fieldBinding)) {", "+\t\t\t\tmanageSyntheticAccessIfNecessary(currentScope, flowInfo, true /*read-access*/);", "+\t\t\t\t// check if assigning a final blank field", "+\t\t\t\tif (!flowInfo.isDefinitelyAssigned(localBinding = (LocalVariableBinding) this.binding)) {", "+\t\t\t\t\t// we could improve error msg here telling \"cannot use compound assignment on final local variable\"", "+\t\t\t\tif (isReachable) {", "+\tif (assignment.expression != null) {", "+\t\tflowInfo = assignment.expression.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();", "+\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\tcase Binding.FIELD : // assigning to a field", "+\t\t\tmanageSyntheticAccessIfNecessary(currentScope, flowInfo, false /*write-access*/);", "+\t\t\tFieldBinding fieldBinding = (FieldBinding) this.binding;", "+\t\t\tReferenceBinding declaringClass = fieldBinding.declaringClass;", "+\t\t\t// check if accessing enum static field in initializer", "+\t\t\tif (declaringClass.isEnum()) {", "+\t\t\t\tMethodScope methodScope = currentScope.methodScope();", "+\t\t\t\tSourceTypeBinding sourceType = currentScope.enclosingSourceType();", "+\t\t\t\tif (fieldBinding.isStatic()", "+\t\t\t\t\t\t&& this.constant == Constant.NotAConstant", "+\t\t\t\t\t\t&& !methodScope.isStatic", "+\t\t\t\t\t\t&& (sourceType == declaringClass || sourceType.superclass == declaringClass) // enum constant body", "+\t\t\t\t\t\t&& methodScope.isInsideInitializerOrConstructor()) {", "+\t\t\t\t\tcurrentScope.problemReporter().enumStaticFieldUsedDuringInitialization(fieldBinding, this);", "+\t\t\t\t}", "+\t\t\t}\t\t\t\t\t", "+\t\t\t// check if assigning a final field", "+\t\t\tif (fieldBinding.isFinal()) {", "+\t\t\t\t// inside a context where allowed", "+\t\t\t\tif (!isCompound && fieldBinding.isBlankFinal() && currentScope.allowBlankFinalFieldAssignment(fieldBinding)) {", "+\t\t\t\t\tif (flowInfo.isPotentiallyAssigned(fieldBinding)) {", "+\t\t\t\t\t\tcurrentScope.problemReporter().duplicateInitializationOfBlankFinalField(fieldBinding, this);", "+\t\t\t\t\t\tflowContext.recordSettingFinal(fieldBinding, this, flowInfo);\t\t\t\t\t\t", "+\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(fieldBinding);", "+\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalField(fieldBinding, this);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbreak;", "+\t\tcase Binding.LOCAL : // assigning to a local variable ", "+\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.binding;", "+\t\t\tif (!flowInfo.isDefinitelyAssigned(localBinding)){// for local variable debug attributes", "+\t\t\t\tthis.bits |= ASTNode.FirstAssignmentToLocal;", "+\t\t\t} else {", "+\t\t\t\tthis.bits &= ~ASTNode.FirstAssignmentToLocal;", "+\t\t\t}", "+\t\t\tif (localBinding.isFinal()) {", "+\t\t\t\tif ((this.bits & ASTNode.DepthMASK) == 0) {", "+\t\t\t\t\t// tolerate assignment to final local in unreachable code (45674)", "+\t\t\t\t\tif ((isReachable && isCompound) || !localBinding.isBlankFinal()){", "+\t\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalLocal(localBinding, this);", "+\t\t\t\t\t} else if (flowInfo.isPotentiallyAssigned(localBinding)) {", "+\t\t\t\t\t\tcurrentScope.problemReporter().duplicateInitializationOfFinalLocal(localBinding, this);", "+\t\t\t\t\t\tflowContext.recordSettingFinal(localBinding, this, flowInfo);\t\t\t\t\t\t\t\t", "+\t\t\t\t} else {", "+\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalOuterLocal(localBinding, this);", "+\t\t\t}", "+\t\t\telse /* avoid double diagnostic */ if ((localBinding.tagBits & TagBits.IsArgument) != 0) {", "+\t\t\t\tcurrentScope.problemReporter().parameterAssignment(localBinding, this);", "+\t\t\t}", "+\t\t\tflowInfo.markAsDefinitelyAssigned(localBinding);", "+\t}", "+\tmanageEnclosingInstanceAccessIfNecessary(currentScope, flowInfo);", "+\treturn flowInfo;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3fe6ccb08f9c8a9ba75193e23701b5c3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "82f5102778189bf9bcdbbea71144f216c8634383", "commitAfterChange": "9471974fe3ca746b196cad8681aab599eb9e787d", "methodNumberBeforeChange": 165, "methodNumberAfterChange": 165, "signatureBeforeChange": " public void initializeMaxLocals(MethodBinding methodBinding)", "signatureAfterChange": " public void initializeMaxLocals(MethodBinding methodBinding)", "diff": ["-\tmaxLocals = (methodBinding == null || methodBinding.isStatic()) ? 0 : 1;", "+\tif (methodBinding == null) {", "+\t\tthis.maxLocals = 0;", "+\t\treturn;", "+\t}", "+\t", "+\tthis.maxLocals = methodBinding.isStatic() ? 0 : 1;", "+\t", "+\t// take into account enum constructor synthetic name+ordinal", "+\tif (methodBinding.isConstructor() && methodBinding.declaringClass.isEnum()) {", "+\t\tthis.maxLocals += 2; // String and int (enum constant name+ordinal)", "+\t}", "+\t", "-\tif (methodBinding != null) {", "-\t\tif (methodBinding.isConstructor() && methodBinding.declaringClass.isNestedType()) {", "-\t\t\tReferenceBinding enclosingInstanceTypes[];", "-\t\t\tif ((enclosingInstanceTypes = methodBinding.declaringClass.syntheticEnclosingInstanceTypes()) != null) {", "-\t\t\t\tfor (int i = 0, max = enclosingInstanceTypes.length; i < max; i++) {", "-\t\t\t\t\tmaxLocals++; // an enclosingInstanceType can only be a reference binding. It cannot be", "-\t\t\t\t\t// LongBinding or DoubleBinding", "-\t\t\t\t}", "+\tif (methodBinding.isConstructor() && methodBinding.declaringClass.isNestedType()) {", "+\t\tReferenceBinding enclosingInstanceTypes[];", "+\t\tif ((enclosingInstanceTypes = methodBinding.declaringClass.syntheticEnclosingInstanceTypes()) != null) {", "+\t\t\tfor (int i = 0, max = enclosingInstanceTypes.length; i < max; i++) {", "+\t\t\t\tthis.maxLocals++; // an enclosingInstanceType can only be a reference binding. It cannot be", "+\t\t\t\t// LongBinding or DoubleBinding", "-\t\t\tSyntheticArgumentBinding syntheticArguments[];", "-\t\t\tif ((syntheticArguments = methodBinding.declaringClass.syntheticOuterLocalVariables()) != null) {", "-\t\t\t\tfor (int i = 0, max = syntheticArguments.length; i < max; i++) {", "-\t\t\t\t\tTypeBinding argType;", "-\t\t\t\t\tif (((argType = syntheticArguments[i].type) == LongBinding) || (argType == DoubleBinding)) {", "-\t\t\t\t\t\tmaxLocals += 2;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tmaxLocals++;", "-\t\t\t\t\t}", "+\t\t}", "+\t\tSyntheticArgumentBinding syntheticArguments[];", "+\t\tif ((syntheticArguments = methodBinding.declaringClass.syntheticOuterLocalVariables()) != null) {", "+\t\t\tfor (int i = 0, max = syntheticArguments.length; i < max; i++) {", "+\t\t\t\tTypeBinding argType;", "+\t\t\t\tif (((argType = syntheticArguments[i].type) == LongBinding) || (argType == DoubleBinding)) {", "+\t\t\t\t\tthis.maxLocals += 2;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.maxLocals++;", "-\t\tTypeBinding[] arguments;", "-\t\tif ((arguments = methodBinding.parameters) != null) {", "-\t\t\tfor (int i = 0, max = arguments.length; i < max; i++) {", "-\t\t\t\tTypeBinding argType;", "-\t\t\t\tif (((argType = arguments[i]) == LongBinding) || (argType == DoubleBinding)) {", "-\t\t\t\t\tmaxLocals += 2;", "-\t\t\t\t} else {", "-\t\t\t\t\tmaxLocals++;", "-\t\t\t\t}", "+\t}", "+\tTypeBinding[] arguments;", "+\tif ((arguments = methodBinding.parameters) != null) {", "+\t\tfor (int i = 0, max = arguments.length; i < max; i++) {", "+\t\t\tTypeBinding argType;", "+\t\t\tif (((argType = arguments[i]) == LongBinding) || (argType == DoubleBinding)) {", "+\t\t\t\tthis.maxLocals += 2;", "+\t\t\t} else {", "+\t\t\t\tthis.maxLocals++;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "87449223cc40ea8b6c01b45c1628eee9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "signatureAfterChange": "  public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "diff": ["-\t}", "-\tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {", "-\t", "-\t\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)\treturn;", "-\t", "-\t\t//If inlinable field, forget the access emulation, the code gen will directly target it", "-\t\tif (constant != Constant.NotAConstant)", "-\t\t\treturn;", "-\t", "-\t\tif ((bits & Binding.FIELD) != 0) {", "-\t\t\tFieldBinding fieldBinding = (FieldBinding) binding;", "-\t\t\tFieldBinding codegenField = fieldBinding.original();", "-\t\t\tthis.codegenBinding = codegenField;", "-\t\t\tif (((bits & DepthMASK) != 0)", "-\t\t\t\t&& (codegenField.isPrivate() // private access", "-\t\t\t\t\t|| (codegenField.isProtected() // implicit protected access", "-\t\t\t\t\t\t\t&& codegenField.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage()))) {", "-\t\t\t\tif (syntheticAccessors == null)", "-\t\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "-\t\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = ", "-\t\t\t\t    ((SourceTypeBinding)currentScope.enclosingSourceType().", "-\t\t\t\t\t\tenclosingTypeAt((bits & DepthMASK) >> DepthSHIFT)).addSyntheticMethod(codegenField, isReadAccess);", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(codegenField, this, isReadAccess);", "-\t\t\t\treturn;", "-\t\t\t// if the binding declaring class is not visible, need special action", "-\t\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "-\t\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "-\t\t\t// and not from Object or implicit static field access.\t", "-\t\t\tif (fieldBinding.declaringClass != this.actualReceiverType", "-\t\t\t\t\t&& !this.actualReceiverType.isArrayType()", "-\t\t\t\t\t&& fieldBinding.declaringClass != null // array.length", "-\t\t\t\t\t&& fieldBinding.constant() == Constant.NotAConstant) {", "-\t\t\t\tCompilerOptions options = currentScope.compilerOptions();", "-\t\t\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "-\t\t\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !fieldBinding.isStatic())", "-\t\t\t\t\t\t&& fieldBinding.declaringClass.id != T_JavaLangObject) // no change for Object fields", "+", "+public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {", "+\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)\treturn;", "+", "+\t//If inlinable field, forget the access emulation, the code gen will directly target it", "+\tif (this.constant != Constant.NotAConstant)", "+\t\treturn;", "+", "+\tif ((this.bits & Binding.FIELD) != 0) {", "+\t\tFieldBinding fieldBinding = (FieldBinding) this.binding;", "+\t\tFieldBinding codegenField = fieldBinding.original();", "+\t\tthis.codegenBinding = codegenField;", "+\t\tif (((this.bits & ASTNode.DepthMASK) != 0)", "+\t\t\t&& (codegenField.isPrivate() // private access", "+\t\t\t\t|| (codegenField.isProtected() // implicit protected access", "+\t\t\t\t\t\t&& codegenField.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage()))) {", "+\t\t\tif (this.syntheticAccessors == null)", "+\t\t\t\tthis.syntheticAccessors = new MethodBinding[2];", "+\t\t\tthis.syntheticAccessors[isReadAccess ? SingleNameReference.READ : SingleNameReference.WRITE] = ", "+\t\t\t    ((SourceTypeBinding)currentScope.enclosingSourceType().", "+\t\t\t\t\tenclosingTypeAt((this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT)).addSyntheticMethod(codegenField, isReadAccess);", "+\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(codegenField, this, isReadAccess);", "+\t\t\treturn;", "+\t\t}", "+\t\t// if the binding declaring class is not visible, need special action", "+\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "+\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "+\t\t// and not from Object or implicit static field access.\t", "+\t\tif (fieldBinding.declaringClass != this.actualReceiverType", "+\t\t\t\t&& !this.actualReceiverType.isArrayType()", "+\t\t\t\t&& fieldBinding.declaringClass != null // array.length", "+\t\t\t\t&& fieldBinding.constant() == Constant.NotAConstant) {", "+\t\t\tCompilerOptions options = currentScope.compilerOptions();", "+\t\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "+\t\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !fieldBinding.isStatic())", "+\t\t\t\t\t&& fieldBinding.declaringClass.id != TypeIds.T_JavaLangObject) // no change for Object fields", "-\t\t\t\t}", "-\t\t\t}\t\t\t\t\t", "-\t\t}", "+\t\t\t}", "+\t\t}\t\t\t\t\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a467982c2c7df9655c14751589ca2aa8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " protected void consumeAllocationHeader()", "signatureAfterChange": " protected void consumeAllocationHeader()", "diff": ["-\tif (currentElement == null){", "+\tif (this.currentElement == null){", "-\tif (currentToken == TokenNameLBRACE){", "+\tif (this.currentToken == TokenNameLBRACE){", "-\t\tanonymousType.sourceStart = intStack[intPtr--];", "-\t\tanonymousType.sourceEnd = rParenPos; // closing parenthesis", "-\t\tlastCheckPoint = anonymousType.bodyStart = scanner.currentPosition;", "-\t\tcurrentElement = currentElement.add(anonymousType, 0);", "-\t\tlastIgnoredToken = -1;", "-\t\tcurrentToken = 0; // opening brace already taken into account", "+\t\tanonymousType.sourceStart = this.intStack[this.intPtr--];", "+\t\tanonymousType.sourceEnd = this.rParenPos; // closing parenthesis", "+\t\tthis.lastCheckPoint = anonymousType.bodyStart = this.scanner.currentPosition;", "+\t\tthis.currentElement = this.currentElement.add(anonymousType, 0);", "+\t\tthis.lastIgnoredToken = -1;", "+\t\tthis.currentToken = 0; // opening brace already taken into account", "-\tlastCheckPoint = scanner.startPosition; // force to restart at this exact position", "-\trestartRecovery = true; // request to restart from here on", "+\tthis.lastCheckPoint = this.scanner.startPosition; // force to restart at this exact position", "+\tthis.restartRecovery = true; // request to restart from here on"]}], "num": 72305}