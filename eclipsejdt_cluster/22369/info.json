{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8f1347955aa5b6eb08b6a6631ea59a9d", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f6868fe2cba3c37aac90ed5ace688f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeleteResourceElementsOperation.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r \tprivate void deletePackageFragment(IPackageFragment frag)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r private void deletePackageFragment(IPackageFragment frag)\r \tthrows JavaModelException", "diff": ["+ */\r", "+private void deletePackageFragment(IPackageFragment frag)\r", "+\tthrows JavaModelException {\r", "+\tIResource res = frag.getCorrespondingResource();\r", "+\tif (res != null && res.getType() == IResource.FOLDER) {\r", "+\t\t// collect the children to remove\r", "+\t\tIJavaElement[] childrenOfInterest = frag.getChildren();\r", "+\t\tif (childrenOfInterest.length > 0) {\r", "+\t\t\tIResource[] resources = new IResource[childrenOfInterest.length];\r", "+\t\t\t// remove the children\r", "+\t\t\tfor (int i = 0; i < childrenOfInterest.length; i++) {\r", "+\t\t\t\tresources[i] = childrenOfInterest[i].getCorrespondingResource();\r", "+\t\t\t}\r", "+\t\t\tdeleteResources(resources, fForce);\r", "+\t\t}\r", "-\t */\r", "-\tprivate void deletePackageFragment(IPackageFragment frag)\r", "-\t\tthrows JavaModelException {\r", "-\t\tIResource res = frag.getCorrespondingResource();\r", "-\t\tif (res != null && res.getType() == IResource.FOLDER) {\r", "-\t\t\t// collect the children to remove\r", "-\t\t\tIJavaElement[] childrenOfInterest;\r", "-\t\t\tif (frag.getKind() == IPackageFragmentRoot.K_SOURCE) {\r", "-\t\t\t\tchildrenOfInterest = frag.getCompilationUnits();\r", "-\t\t\t} else { // K_BINARY\r", "-\t\t\t\tchildrenOfInterest = frag.getClassFiles();\r", "-\t\t\t}\r", "-\t\t\tif (childrenOfInterest.length > 0) {\r", "-\t\t\t\tIResource[] resources = new IResource[childrenOfInterest.length];\r", "-\t\t\t\t// remove the children\r", "-\t\t\t\tfor (int i = 0; i < childrenOfInterest.length; i++) {\r", "-\t\t\t\t\tresources[i] = childrenOfInterest[i].getCorrespondingResource();\r", "-\t\t\t\t}\r", "-\t\t\t\tdeleteResources(resources, fForce);\r", "-\t\t\t}\r", "-\r", "-\t\t\t// Discard non-java resources\r", "-\t\t\tObject[] nonJavaResources = frag.getNonJavaResources();\r", "-\t\t\tint actualResourceCount = 0;\r", "-\t\t\tfor (int i = 0, max = nonJavaResources.length; i < max; i++) {\r", "-\t\t\t\tif (nonJavaResources[i] instanceof IResource)\r", "-\t\t\t\t\tactualResourceCount++;\r", "-\t\t\t}\r", "-\t\t\tIResource[] actualNonJavaResources = new IResource[actualResourceCount];\r", "-\t\t\tfor (int i = 0, max = nonJavaResources.length, index = 0; i < max; i++) {\r", "-\t\t\t\tif (nonJavaResources[i] instanceof IResource)\r", "-\t\t\t\t\tactualNonJavaResources[index++] = (IResource) nonJavaResources[i];\r", "-\t\t\t}\r", "-\t\t\tdeleteResources(actualNonJavaResources, fForce);\r", "-\r", "-\t\t\t// remove the folder if it is empty\r", "-\t\t\tIResource[] members;\r", "-\t\t\ttry {\r", "-\t\t\t\tmembers = ((IFolder) res).members();\r", "-\t\t\t} catch (CoreException ce) {\r", "-\t\t\t\tthrow new JavaModelException(ce);\r", "-\t\t\t}\r", "-\t\t\tif (members.length == 0) {\r", "-\t\t\t\tdeleteEmptyPackageFragment(frag, fForce);\r", "-\t\t\t}\r", "+\t\t// Discard non-java resources\r", "+\t\tObject[] nonJavaResources = frag.getNonJavaResources();\r", "+\t\tint actualResourceCount = 0;\r", "+\t\tfor (int i = 0, max = nonJavaResources.length; i < max; i++){\r", "+\t\t\tif (nonJavaResources[i] instanceof IResource) actualResourceCount++;\r", "+\t\t}\r", "+\t\tIResource[] actualNonJavaResources = new IResource[actualResourceCount];\r", "+\t\tfor (int i = 0, max = nonJavaResources.length, index = 0; i < max; i++){\r", "+\t\t\tif (nonJavaResources[i] instanceof IResource) actualNonJavaResources[index++] = (IResource)nonJavaResources[i];\r", "+\t\t}\r", "+\t\tdeleteResources(actualNonJavaResources, fForce);\r", "+\t\t\r", "+\t\t// remove the folder if it is empty\r", "+\t\tIResource[] members;\r", "+\t\ttry {\r", "+\t\t\tmembers = ((IFolder) res).members();\r", "+\t\t} catch (CoreException ce) {\r", "+\t\t\tthrow new JavaModelException(ce);\r", "+\t\t}\r", "+\t\tif (members.length == 0) {\r", "+\t\t\tdeleteEmptyPackageFragment(frag, fForce);\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6bdc5c7d27f31afda983db76cd67098a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "e29082e6108e43f171cfe9fae0a56914a1f2ec3e", "commitAfterChange": "c9393df013a58676e5f14d40d6c8db0b129e07c0", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t    /* https://bugs.eclipse.org/bugs/show_bug.cgi?id=375394, To avoid spurious bounds check failures due to circularity in formal bounds, ", "-\t\t       we should eliminate only the lingering embedded type variable references after substitution, not alien type variable references", "-\t\t       that constitute the inference per se. Also short circuit this step, if the substitution has no type variables in the first place ", "-\t\t       (as it is effectively a nop.)", "-\t\t     */ ", "-\t\t    TypeBinding substituteForChecks;", "-\t\t    if (substitute instanceof TypeVariableBinding || ((substitute.tagBits & TagBits.HasTypeVariable) == 0)) {", "-\t\t    \tsubstituteForChecks = substitute;", "-\t\t    } else {", "-\t\t    \tsubstituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "-\t\t    }", "-\t\t    ", "+\t\t    TypeBinding substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check"]}], "num": 22369}