{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "93ac08274a83fe4288794037421fc830", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f055d2137414c5bc6bcd698455e7903", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java", "commitBeforeChange": "0927ffa25a2592bfca0a67c9cc9e0e69775118de", "commitAfterChange": "7b934c773095ee4cd83d9fe1d55bbb70d8656cbb", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tint lhsId = lhsType.id;", "-\t\tint expressionId = expressionType.id;", "+\t\tint lhsID = lhsType.id;", "+\t\tint expressionID = expressionType.id;", "+\t\t", "+\t\t// autoboxing support", "+\t\tboolean use15specifics = scope.environment().options.sourceLevel >= JDK1_5;", "+\t\tboolean unboxedLhs = false, unboxedExpression = false;", "+\t\tif (use15specifics) {", "+\t\t\tif (!lhsType.isBaseType() && expressionID != T_JavaLangString) {", "+\t\t\t\tint unboxedID = scope.computeBoxingType(lhsType).id;", "+\t\t\t\tif (unboxedID != lhsID) {", "+\t\t\t\t\tlhsID = unboxedID;", "+\t\t\t\t\tunboxedLhs = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (!expressionType.isBaseType() && lhsID != T_JavaLangString) {", "+\t\t\t\tint unboxedID = scope.computeBoxingType(expressionType).id;", "+\t\t\t\tif (unboxedID != expressionID) {", "+\t\t\t\t\texpressionID = unboxedID;", "+\t\t\t\t\tunboxedExpression = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t", "-\t\tif (lhsId > 15 || expressionId > 15) {", "-\t\t\tif (lhsId != T_String) { // String += Thread is valid whereas Thread += String  is not", "+\t\tif (lhsID > 15 || expressionID > 15) {", "+\t\t\tif (lhsID != T_JavaLangString) { // String += Thread is valid whereas Thread += String  is not", "-\t\t\texpressionId = T_Object; // use the Object has tag table", "+\t\t\texpressionID = T_JavaLangObject; // use the Object has tag table", "-\t\tint result = OperatorExpression.OperatorSignatures[operator][ (lhsId << 4) + expressionId];", "+\t\tint result = OperatorExpression.OperatorSignatures[operator][ (lhsID << 4) + expressionID];", "-\t\t\tif(lhsId == T_JavaLangObject) {", "+\t\t\tif(lhsID == T_JavaLangObject) {", "-\t\t\t\tif ((lhsType.isNumericType() || lhsId == T_boolean) && !expressionType.isNumericType()){", "+\t\t\t\tif ((lhsType.isNumericType() || lhsID == T_boolean) && !expressionType.isNumericType()){", "-\t\t// TODO (philippe) should retrofit in using #computeConversion", "-\t\tlhs.implicitConversion = result >>> 12;", "-\t\texpression.implicitConversion = (result >>> 4) & 0x000FF;", "-\t\tassignmentImplicitConversion = (lhsId << 4) + (result & 0x0000F);", "+\t\tthis.lhs.implicitConversion = (unboxedLhs ? UNBOXING : 0) | (result >>> 12);", "+\t\tthis.expression.implicitConversion = (unboxedExpression ? UNBOXING : 0) | ((result >>> 4) & 0x000FF);", "+\t\tthis.assignmentImplicitConversion =  (unboxedLhs ? BOXING : 0) | (lhsID << 4) | (result & 0x0000F);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8aebf364adfe15947ee0152cc52277aa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "905cf94d64f942e28e58015355605b9b9383c577", "commitAfterChange": "c73dc602d3a7bc78582f5168e9ef91cc511da90a", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tint leftTypeId = leftType.id;", "-\t\tint rightTypeId = rightType.id;", "-\t\tif (leftTypeId > 15", "-\t\t\t|| rightTypeId > 15) { // must convert String + Object || Object + String", "-\t\t\tif (leftTypeId == T_String) {", "-\t\t\t\trightTypeId = T_Object;", "-\t\t\t} else if (rightTypeId == T_String) {", "-\t\t\t\tleftTypeId = T_Object;", "+", "+\t\tint leftTypeID = leftType.id;", "+\t\tint rightTypeID = rightType.id;", "+", "+\t\t// autoboxing support", "+\t\tboolean use15specifics = scope.environment().options.sourceLevel >= JDK1_5;", "+\t\tboolean unboxedLeft = false, unboxedRight = false;", "+\t\tif (use15specifics) {", "+\t\t\tif (leftType.isBaseType()) {", "+\t\t\t\tif (!rightType.isBaseType()) {", "+\t\t\t\t\tint unboxedID = scope.computeBoxingType(rightType).id;", "+\t\t\t\t\tif (unboxedID != rightTypeID) {", "+\t\t\t\t\t\trightTypeID = unboxedID;", "+\t\t\t\t\t\tunboxedRight = true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else if (rightType.isBaseType()) {", "+\t\t\t\tint unboxedID = scope.computeBoxingType(leftType).id;", "+\t\t\t\t\tif (unboxedID != leftTypeID) {", "+\t\t\t\t\t\tleftTypeID = unboxedID;", "+\t\t\t\t\t\tunboxedLeft = true;", "+\t\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (leftTypeID > 15", "+\t\t\t|| rightTypeID > 15) { // must convert String + Object || Object + String", "+\t\t\tif (leftTypeID == T_String) {", "+\t\t\t\trightTypeID = T_Object;", "+\t\t\t} else if (rightTypeID == T_String) {", "+\t\t\t\tleftTypeID = T_Object;", "-\t\t\tif (leftTypeId == T_String) {", "+\t\t\tif (leftTypeID == T_String) {", "-\t\t\tif (rightTypeId == T_String) {", "+\t\t\tif (rightTypeID == T_String) {", "-\t\tint operatorSignature = OperatorSignatures[operator][(leftTypeId << 4) + rightTypeId];", "-\t\tleft.implicitConversion = operatorSignature >>> 12;", "-\t\tright.implicitConversion = (operatorSignature >>> 4) & 0xFF;", "+\t\tint operatorSignature = OperatorSignatures[operator][(leftTypeID << 4) + rightTypeID];", "+\t\tleft.implicitConversion = (unboxedLeft ? UNBOXING : 0) | (operatorSignature >>> 12);", "+\t\tright.implicitConversion = (unboxedRight ? UNBOXING : 0) | ((operatorSignature >>> 4) & 0xFF);", "-\t\t\tCastExpression.checkNeedForArgumentCasts(scope, operator, operatorSignature, left, leftTypeId, leftIsCast, right, rightTypeId, rightIsCast);", "+\t\t\tCastExpression.checkNeedForArgumentCasts(scope, operator, operatorSignature, left, leftTypeID, leftIsCast, right, rightTypeID, rightIsCast);", "-\t\tcomputeConstant(scope, leftTypeId, rightTypeId);", "+\t\tcomputeConstant(scope, leftTypeID, rightTypeID);"]}], "num": 41739}