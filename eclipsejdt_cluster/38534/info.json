{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cdfa160d841c31562326d5fbd23c4f1e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "48ce82e2d90a461ff4ed7a5fa89ae12f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "c8d00cbf2814182ef1ce07d7254dc4a8d85157bc", "commitAfterChange": "76285abc2e18a9626166def15ee7d0b4124f0aa5", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " public int literalIndexForLdc(char[] stringCharArray)", "signatureAfterChange": " public int literalIndexForLdc(char[] stringCharArray)", "diff": ["+\tint savedCurrentIndex = this.currentIndex;", "+\tint savedCurrentOffset = this.currentOffset;", "-\t\t\tint savedCurrentOffset = currentOffset;", "+\t\t\tint lengthOffset = currentOffset;", "-\t\t\t\tcurrentOffset = savedCurrentOffset - 1;", "+\t\t\t\tthis.currentOffset = savedCurrentOffset;", "+\t\t\t\tthis.currentIndex = savedCurrentIndex;", "+\t\t\t\tthis.stringCache.remove(stringCharArray);", "+\t\t\t\tthis.UTF8Cache.remove(stringCharArray);", "-\t\t\t// Now we know the length that we have to write in the constant pool", "-\t\t\t// we use savedCurrentOffset to do that", "-\t\t\tif (length > 65535) {", "-\t\t\t\treturn 0;", "-\t\t\t}", "-\t\t\tpoolContent[savedCurrentOffset++] = (byte) (length >> 8);", "-\t\t\tpoolContent[savedCurrentOffset] = (byte) length;", "+\t\t\tpoolContent[lengthOffset++] = (byte) (length >> 8);", "+\t\t\tpoolContent[lengthOffset] = (byte) length;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76dc17284c9232ea8af1cb110222a97e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "e0ebad67303a47fa3ab9d8532c92ffc60ae916e2", "commitAfterChange": "6940f5238f5f044dc7dc7f5472f64a2c5617a365", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  public void checkTypeArgumentRedundancy(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope)", "signatureAfterChange": "  public void checkTypeArgumentRedundancy(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope)", "diff": ["-\tTypeBinding [] inferredTypes = inferElidedTypes(allocationType.genericType(), enclosingType, argumentTypes, scope);", "+\tTypeBinding [] inferredTypes;", "+\tint previousBits = this.type.bits;", "+\tint previousInferenceKind = this.inferenceKind;", "+\ttry {", "+\t\t// checking for redundant type parameters must fake a diamond, ", "+\t\t// so we infer the same results as we would get with a diamond in source code:", "+\t\tthis.type.bits |= IsDiamond;", "+\t\tinferredTypes = inferElidedTypes(allocationType.genericType(), enclosingType, argumentTypes, scope);", "+\t} finally {", "+\t\t// reset effects of inference", "+\t\tthis.type.bits = previousBits;", "+\t\tthis.inferenceKind = previousInferenceKind;", "+\t}"]}], "num": 38534}