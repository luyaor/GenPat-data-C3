{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7dc042cf796cda69f49f2e2352bf0852", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2ac5ed4afdcc6902b4da1c54cae2729d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/FormatterCommentParser.java", "commitBeforeChange": "0f7f9d63e5fbc5d41771bd4e2e39b628130add76", "commitAfterChange": "ed4cdf5cf5dec0284dce12a661248f2f9a27a709", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " protected boolean parseParam() throws InvalidInputException", "signatureAfterChange": " protected boolean parseParam() throws InvalidInputException", "diff": ["-\t\tif (ch != ' ' && !ScannerHelper.isWhitespace(ch)) {", "-\t\t\t// no space after the tag, just create a normal tag", "-\t\t\treturn false;", "+\t\t// Try to push an identifier in the stack, otherwise restart from the end tag position", "+\t\tif (ch == ' ' || ScannerHelper.isWhitespace(ch)) {", "+\t\t\tint token = this.scanner.getNextToken();", "+\t\t\tif (token == TerminalTokens.TokenNameIdentifier) {", "+\t\t\t\tch = peekChar();", "+\t\t\t\tif (ch == ' ' || ScannerHelper.isWhitespace(ch)) {", "+\t\t\t\t\tpushIdentifier(true, false);", "+\t\t\t\t\tpushParamName(false);", "+\t\t\t\t\tthis.index = this.scanner.currentPosition;", "+\t\t\t\t\tvalid = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tthis.scanner.resetTo(this.tagSourceEnd+1, this.javadocEnd);", "-\t\tthis.scanner.getNextToken(); // consume first token", "-\t\tpushIdentifier(true, false); // force the identifier even if invalid", "-\t\tpushParamName(false);", "-\t\tthis.index = this.scanner.currentPosition;", "-\t\tvalid = true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "51a4525ae674ad879090dc32a5bb699f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceJavadocParser.java", "commitBeforeChange": "b9048812dd88e4e03993f3f1485c45b1b5d06172", "commitAfterChange": "746639968f86f3ad41d15e0e45898b6cf0685369", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected boolean parseIdentifierTag(boolean report)", "signatureAfterChange": " protected boolean parseIdentifierTag(boolean report)", "diff": ["+\t\t\t// Store first category id", "+\t\t\t\tlength += 5;", "+\t\t\t// Store optional additional category identifiers", "+\t\t\tconsumeToken();", "+\t\t\twhile (this.index < this.javadocEnd) {", "+\t\t\t\tif (readTokenSafely() == TerminalTokens.TokenNameIdentifier && (this.scanner.currentCharacter == ' ' || Character.isWhitespace(this.scanner.currentCharacter))) {", "+\t\t\t\t\tif (this.index > (this.lineEnd+1)) break;", "+\t\t\t\t\t// valid additional identifier", "+\t\t\t\t\tif (++this.categoriesPtr >= length) {", "+\t\t\t\t\t\tSystem.arraycopy(this.categories, 0, this.categories = new char[length+5][], 0, length);", "+\t\t\t\t\t\tlength += 5;", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.categories[this.categoriesPtr] = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\tconsumeToken();", "+\t\t\t\t} else {", "+\t\t\t\t\t// TODO (frederic) raise warning for invalid syntax when javadoc spec will be finalized...", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// Reset position to end of line", "+\t\t\tthis.index = this.lineEnd;", "+\t\t\tthis.scanner.currentPosition = this.lineEnd;", "+\t\t\tconsumeToken();"]}], "num": 8511}