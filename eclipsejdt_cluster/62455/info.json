{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7bc4b0b9a52c94cb0fd0e975b66f5613", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "48c21273ddca0ef65a99cae7e3191d6e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "3d0cee6e94784a6b3bd48a07f7ded01c1ecae704", "commitAfterChange": "4a091e274958592dbd1ebba3d64bb9359dcb3c8a", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tpublic void seekPackageFragments(String name, boolean partialMatch, IJavaElementRequestor requestor)", "signatureAfterChange": " \tpublic void seekPackageFragments(String name, boolean partialMatch, IJavaElementRequestor requestor)", "diff": ["-\t\t\tint count= this.packageFragmentRoots.length;", "-\t\t\tString matchName= name.toLowerCase();", "-\t\t\tfor (int i= 0; i < count; i++) {", "+\t\t\tString[] splittedName = Util.splitOn('.', name, 0, name.length());", "+\t\t\tObject[][] keys = this.packageFragments.keyTable;", "+\t\t\tfor (int i = 0, length = keys.length; i < length; i++) {", "-\t\t\t\tIPackageFragmentRoot root= this.packageFragmentRoots[i];", "-\t\t\t\tIJavaElement[] list= null;", "-\t\t\t\ttry {", "-\t\t\t\t\tlist= root.getChildren();", "-\t\t\t\t} catch (JavaModelException npe) {", "-\t\t\t\t\tcontinue; // this root package fragment is not present", "-\t\t\t\t}", "-\t\t\t\tint elementCount= list.length;", "-\t\t\t\tfor (int j= 0; j < elementCount; j++) {", "-\t\t\t\t\tif (requestor.isCanceled())", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\tIPackageFragment packageFragment= (IPackageFragment) list[j];", "-\t\t\t\t\tif (packageFragment.getElementName().toLowerCase().startsWith(matchName))", "-\t\t\t\t\t\trequestor.acceptPackageFragment(packageFragment);", "+\t\t\t\tString[] pkgName = (String[]) keys[i];", "+\t\t\t\tif (pkgName != null && Util.startsWithIgnoreCase(pkgName, splittedName)) {", "+\t\t\t\t\tIPackageFragmentRoot[] roots = (IPackageFragmentRoot[]) this.packageFragments.valueTable[i];", "+\t\t\t\t\tfor (int j = 0, length2 = roots.length; j < length2; j++) {", "+\t\t\t\t\t\tif (requestor.isCanceled())", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot) roots[j];", "+\t\t\t\t\t\trequestor.acceptPackageFragment(root.getPackageFragment(pkgName));\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t\tif (requestor.isCanceled())", "+\t\t\t\t\t\treturn;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bebf52699b9bb96115f789de1a875e20", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "27d7a3f1b3dd8726f49b3c45b8ae92fd365eeb4f", "commitAfterChange": "27ff50a9809c3e55581c713af1b876f5db7707ee", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tpublic NameLookup( \t\t\tIPackageFragmentRoot[] packageFragmentRoots,  \t\t\tHashtableOfArrayToObject packageFragments,  \t\t\tICompilationUnit[] workingCopies,  \t\t\tMap rootToResolvedEntries)", "signatureAfterChange": "  \tpublic NameLookup( \t\t\tIPackageFragmentRoot[] packageFragmentRoots,  \t\t\tHashtableOfArrayToObject packageFragments,  \t\t\tICompilationUnit[] workingCopies,  \t\t\tMap rootToResolvedEntries)", "diff": ["-\t\t\tHashSet rootsSet = new HashSet();", "+\t\t\tHashtableOfObjectToInt rootPositions = new HashtableOfObjectToInt();", "-\t\t\t\trootsSet.add(packageFragmentRoots[i]);", "+\t\t\t\trootPositions.put(packageFragmentRoots[i], i);", "-\t\t\t\tif (!rootsSet.contains(pkg.getParent()))", "+\t\t\t\tIPackageFragmentRoot root = (IPackageFragmentRoot) pkg.getParent();", "+\t\t\t\tint rootPosition = rootPositions.get(root);", "+\t\t\t\tif (rootPosition == -1)", "-\t\t\t\tIPackageFragmentRoot root = (IPackageFragmentRoot) pkg.getParent();", "-\t\t\t\t\t\tif (!existing.equals(root))", "-\t\t\t\t\t\t\tthis.packageFragments.put(pkgName, new IPackageFragmentRoot[] {(PackageFragmentRoot) existing, root});", "+\t\t\t\t\t\tint exisitingPosition = rootPositions.get(existing);", "+\t\t\t\t\t\tif (rootPosition != exisitingPosition) { // if not equal", "+\t\t\t\t\t\t\tthis.packageFragments.put(", "+\t\t\t\t\t\t\t\tpkgName, ", "+\t\t\t\t\t\t\t\texisitingPosition < rootPosition ?", "+\t\t\t\t\t\t\t\t\tnew IPackageFragmentRoot[] {(PackageFragmentRoot) existing, root} :", "+\t\t\t\t\t\t\t\t\tnew IPackageFragmentRoot[] {root, (PackageFragmentRoot) existing});", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// insert root in the existing list", "-\t\t\t\t\t\tboolean containsRoot = false;", "+\t\t\t\t\t\tint insertionIndex = 0;", "-\t\t\t\t\t\t\tif (roots[j].equals(root)) {", "-\t\t\t\t\t\t\t\tcontainsRoot = true;", "+\t\t\t\t\t\t\tint existingPosition = rootPositions.get(roots[j]);", "+\t\t\t\t\t\t\tif (rootPosition > existingPosition) {", "+\t\t\t\t\t\t\t\t// root is after this index", "+\t\t\t\t\t\t\t\tinsertionIndex = j;", "+\t\t\t\t\t\t\t} else if (rootPosition == existingPosition) {", "+\t\t\t\t\t\t\t\t // root already in the existing list", "+\t\t\t\t\t\t\t\tinsertionIndex = -1;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t} else if (rootPosition < existingPosition) {", "+\t\t\t\t\t\t\t\t// root is before this index (thus it is at the insertion index)", "-\t\t\t\t\t\tif (containsRoot) {", "-\t\t\t\t\t\t\tSystem.arraycopy(roots, 0, roots = new IPackageFragmentRoot[rootLength+1], 0, rootLength);", "-\t\t\t\t\t\t\troots[rootLength] = root;", "-\t\t\t\t\t\t\tthis.packageFragments.put(pkgName, roots);", "+\t\t\t\t\t\tif (insertionIndex != -1) {", "+\t\t\t\t\t\t\tIPackageFragmentRoot[] newRoots = new IPackageFragmentRoot[rootLength+1];", "+\t\t\t\t\t\t\tSystem.arraycopy(roots, 0, newRoots, 0, insertionIndex);", "+\t\t\t\t\t\t\tnewRoots[insertionIndex] = root;", "+\t\t\t\t\t\t\tSystem.arraycopy(roots, insertionIndex, newRoots, insertionIndex+1, rootLength-insertionIndex);", "+\t\t\t\t\t\t\tthis.packageFragments.put(pkgName, newRoots);"]}], "num": 62455}