{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1624d59572d1475bf04a4140e137c1f5", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "624eb0cba34eb2ba630fd9b4d9ac77d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "2e1e850482d90086f267196870c1a847d5fe0441", "commitAfterChange": "7cd8d4cd3f07fb844c8ea150f6fb9724f3e46dcf", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 15, "signatureBeforeChange": "  protected boolean writeClassFileCheck(IFile file, String fileName, byte[] newBytes, boolean isSecondaryType) throws CoreException", "signatureAfterChange": "  protected void writeClassFileBytes(byte[] bytes, IFile file, String qualifiedFileName, boolean isSecondaryType) throws CoreException", "diff": ["-protected boolean writeClassFileCheck(IFile file, String fileName, byte[] newBytes, boolean isSecondaryType) throws CoreException {", "+protected void writeClassFileBytes(byte[] bytes, IFile file, String qualifiedFileName, boolean isSecondaryType) throws CoreException {", "-\t\ttry {", "-\t\t\tbyte[] oldBytes = Util.getResourceContentsAsByteArray(file);", "-\t\t\tnotEqual : if (newBytes.length == oldBytes.length) {", "-\t\t\t\tfor (int i = newBytes.length; --i >= 0;)", "-\t\t\t\t\tif (newBytes[i] != oldBytes[i]) break notEqual;", "-\t\t\t\treturn false; // bytes are identical so skip them", "-\t\t\t}", "-\t\t\tClassFileReader reader = new ClassFileReader(oldBytes, file.getLocation().toString().toCharArray());", "-\t\t\t// ignore local types since they're only visible inside a single method", "-\t\t\tif (!(reader.isLocal() || reader.isAnonymous()) && reader.hasStructuralChanges(newBytes)) {", "-\t\t\t\tif (JavaBuilder.DEBUG)", "-\t\t\t\t\tSystem.out.println(\"Type has structural changes \" + fileName); //$NON-NLS-1$", "-\t\t\t\taddDependentsOf(new Path(fileName), true);", "-\t\t\t}", "-\t\t} catch (ClassFormatException e) {", "-\t\t\taddDependentsOf(new Path(fileName), true);", "+\t\tif (isClassFileChanged(file, qualifiedFileName, bytes)) {", "+\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\tSystem.out.println(\"Writing changed class file \" + file.getName());//$NON-NLS-1$", "+\t\t\tfile.setContents(new ByteArrayInputStream(bytes), true, false, null);", "+\t\t} else if (JavaBuilder.DEBUG) {", "+\t\t\tSystem.out.println(\"Skipped over unchanged class file \" + file.getName());//$NON-NLS-1$", "-", "-\t\tfile.delete(IResource.FORCE, null);", "-\t} else if (isSecondaryType) {", "-\t\taddDependentsOf(new Path(fileName), true); // new secondary type", "+\t} else {", "+\t\tif (isSecondaryType)", "+\t\t\taddDependentsOf(new Path(qualifiedFileName), true); // new secondary type", "+\t\tsuper.writeClassFileBytes(bytes, file, qualifiedFileName, isSecondaryType);", "-\treturn true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d6484224726b0c9e14bf6927e696f2f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "786bdcb54629de0c38fe45d8c9c539f76fe7da89", "commitAfterChange": "0f2bcb9853eb25fef3d26daa6737dcdc0dcad109", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "diff": ["-\tint[] areIncompatible = null;", "+\t// so find 1 method that is compatible with every other method", "-\tfor (int i = 0, l = methods[0].isAbstract() ? length - 2 : 0; i <= l;) {", "-\t\tMethodBinding method = methods[i++];", "-\t\tnextMethod : for (int j = i; j < length; j++) {", "+\tmatch : for (int i = 0, l = methods[0].isAbstract() ? length - 1 : 0; i <= l; i++) {", "+\t\tMethodBinding method = methods[i];", "+\t\tnext : for (int j = 0; j < length; j++) {", "+\t\t\tif (i == j) continue;", "-\t\t\t\t\t\t\tcontinue nextMethod; // do not complain since the super interface already got blamed", "+\t\t\t\t\t\t\treturn true; // do not complain since the super interface already got blamed", "-\t\t\t\t\tif (method.isAbstract() && method.declaringClass.isClass())", "-\t\t\t\t\t\tif (areReturnTypesCompatible(methods[j], method))", "-\t\t\t\t\t\t\tcontinue nextMethod; // return type of the superclass' inherited method is a supertype of the return type of the interface's method ", "-\t\t\t\t\t\t\tcontinue nextMethod; // do not complain since the superclass already got blamed", "+\t\t\t\t\t\t\tcontinue next; // do not complain since the superclass already got blamed", "-\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\tcontinue next;", "-\t\t\t\tif (areIncompatible == null)", "-\t\t\t\t\tareIncompatible = new int[length];", "-\t\t\t\tareIncompatible[i - 1] = -1;", "-\t\t\t\tareIncompatible[j] = -1;", "+\t\t\t\tcontinue match;", "-\t}", "-\tif (areIncompatible == null)", "-", "-\tint count = 0;", "-\tfor (int i = 0; i < length; i++)", "-\t\tif (areIncompatible[i] == -1) count++;", "-\tif (count == length) {", "-\t\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);", "-\t\treturn false;", "-\tMethodBinding[] methodsToReport = new MethodBinding[count];", "-\tfor (int i = 0, index = 0; i < length; i++)", "-\t\tif (areIncompatible[i] == -1)", "-\t\t\tmethodsToReport[index++] = methods[i];", "-\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methodsToReport, count);", "+", "+\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);"]}], "num": 13970}