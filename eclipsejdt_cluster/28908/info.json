{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4920b8e7cec480dba20dc67460a13e34", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4257e70fdc87ea4eb0b6677e0c296e2e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "9c0097e084b2c48ccca0e818ba9c1c1a50818167", "commitAfterChange": "ed04e9efb45ff73e01fac12a6ae0aba550054536", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tprivate static SearchPattern createTypePattern(String patternString, int limitTo, int matchRule)", "signatureAfterChange": " \tprivate static SearchPattern createTypePattern(String patternString, int limitTo, int matchRule)", "diff": ["-\t\tboolean storeType = true, storeParam = true;", "-\t\tint parameterized = 0;", "-\t\tint paramPtr = -1;", "-\t\tchar[] paramName = null;", "-\t\tchar[][] paramNames = null;", "-\t\tint[] wildcards = null;", "+\t\tint paramCount = 0;", "-\t\t\tif (token != TerminalTokens.TokenNameWHITESPACE) {", "-\t\t\t\tif (storeParam) {", "+\t\t\tswitch (token) {", "+\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\tif (paramCount == 0) break;", "+\t\t\t\t\t// fall through default case if we're inside a type argument...", "+\t\t\t\tdefault: // all other tokens are considered identifiers (see bug 21763 Problem in Java search [search])", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "-\t\t\t\t\t\t\tif (parameterized > 0) {", "-\t\t\t\t\t\t\t\t// TODO (frederic) Should warn user that syntax is not valid", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameQUESTION:", "-\t\t\t\t\t\t\tif (parameterized > 0) {", "-\t\t\t\t\t\t\t\tif (wildcards[paramPtr] == -1) {", "-\t\t\t\t\t\t\t\t\twildcards[paramPtr] = Wildcard.UNBOUND;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t// TODO (frederic) Should warn user that syntax is not valid", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameextends:", "-\t\t\t\t\t\t\tif (parameterized > 0) {", "-\t\t\t\t\t\t\t\tif (wildcards[paramPtr] == Wildcard.UNBOUND) {", "-\t\t\t\t\t\t\t\t\twildcards[paramPtr] = Wildcard.EXTENDS;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t// TODO (frederic) Should warn user that syntax is not valid", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase TerminalTokens.TokenNamesuper:", "-\t\t\t\t\t\t\tif (parameterized > 0) {", "-\t\t\t\t\t\t\t\tif (wildcards[paramPtr] == Wildcard.UNBOUND) {", "-\t\t\t\t\t\t\t\t\twildcards[paramPtr] = Wildcard.SUPER;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t// TODO (frederic) Should warn user that syntax is not valid", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameCOMMA:", "-\t\t\t\t\t\t\tif (parameterized == 1 && storeParam) {", "-\t\t\t\t\t\t\t\tif (paramPtr < paramNames.length) {", "-\t\t\t\t\t\t\t\t\tparamNames[paramPtr++] = paramName;", "-\t\t\t\t\t\t\t\t\tparamName = null;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\twildcards[paramPtr] = -1;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tif (parameterized == 1) {", "-\t\t\t\t\t\t\t\tif (storeParam) {", "-\t\t\t\t\t\t\t\t\tstoreParam = false;", "-\t\t\t\t\t\t\t\t\tif (paramPtr < paramNames.length) {", "-\t\t\t\t\t\t\t\t\t\tparamNames[paramPtr] = paramName;", "-\t\t\t\t\t\t\t\t\t\tparamName = null;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tparameterized--;", "+\t\t\t\t\t\t\tparamCount++;", "-\t\t\t\t\t\t\tif (parameterized == 0) {", "-\t\t\t\t\t\t\t\tparamNames = new char[10][]; // 10 parameters max", "-\t\t\t\t\t\t\t\tparamPtr++;", "-\t\t\t\t\t\t\t\twildcards = new int[10]; // 10 parameters max", "-\t\t\t\t\t\t\t\twildcards[paramPtr] = -1;", "-\t\t\t\t\t\t\t\tstoreType = false;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tparameterized++;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier:", "-\t\t\t\t\t\t\tif (parameterized == 1 && storeParam) {", "-\t\t\t\t\t\t\t\tif (paramName == null) {", "-\t\t\t\t\t\t\t\t\t// never store id at this index", "-\t\t\t\t\t\t\t\t\tparamName = scanner.getCurrentIdentifierSource();", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tparamName = CharOperation.concat(paramName, scanner.getCurrentIdentifierSource());", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase TerminalTokens.TokenNameDOT:", "-\t\t\t\t\t\t\tif (parameterized == 1 && storeParam && paramName != null) {", "-\t\t\t\t\t\t\t\tparamName = CharOperation.append(paramName, '.');", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tparamCount--;", "-\t\t\t\t}", "-\t\t\t\tif (storeType) { // store type if not in type arguments declaration", "-\t\t\t\t}", "-\t\t\t\tstoreType = parameterized == 0;", "-\t\t// Resize param names array if necessary", "-\t\tif (paramPtr >= 0) {", "-\t\t\tSystem.arraycopy(paramNames, 0, paramNames = new char[paramPtr+1][], 0, paramPtr+1);", "-\t\t\tSystem.arraycopy(wildcards, 0, wildcards = new int[paramPtr+1], 0, paramPtr+1);", "-\t\t}", "-\t", "+\t\tchar[] typeSignature = null;", "-\t\t\tchar[] typePart = type.toCharArray();", "+\t\t\t// get type part and signature", "+\t\t\tchar[] typePart = null;", "+\t\t\ttry {", "+\t\t\t\tString signature = Signature.createTypeSignature(type, false);", "+\t\t\t\tif (signature.indexOf(Signature.C_GENERIC_START) < 0) {", "+\t\t\t\t\ttypePart = type.toCharArray();", "+\t\t\t\t} else {", "+\t\t\t\t\ttypeSignature = signature.toCharArray();", "+\t\t\t\t\ttypePart = Signature.toCharArray(Signature.getTypeErasure(typeSignature));", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tcatch (IllegalArgumentException iae) {", "+\t\t\t\t// string is not a valid type syntax", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t\t// get qualification name", "-\t\t\t\treturn new TypeReferencePattern(qualificationChars, typeChars, paramNames, false /* not generic */, wildcards, matchRule);", "+\t\t\t\treturn new TypeReferencePattern(qualificationChars, typeChars, typeSignature, false /* not generic */, matchRule);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a13042c373372e8f5b6716ac9577a0cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "b1ce5a863ad0a541f80dd0793ff207f1e4ecf677", "commitAfterChange": "72d60854091bd7e8a5aafafdfea62cc297a3eb41", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tprivate static SearchPattern createTypePattern(String patternString, int limitTo, int matchRule)", "signatureAfterChange": " \tprivate static SearchPattern createTypePattern(String patternString, int limitTo, int matchRule)", "diff": ["+\t\tboolean storeType = true, storeParam = true;", "+\t\tint parameterized = 0;", "+\t\tint paramPtr = -1;", "+\t\tchar[][] paramNames = null;", "+\t\tint[] wildcards = new int[10];", "-\t\t\tswitch (token) {", "-\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\tbreak;", "-\t\t\t\tdefault: // all other tokens are considered identifiers (see bug 21763 Problem in Java search [search])", "+\t\t\tif (token != TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\t\tif (storeParam) {", "+\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "+\t\t\t\t\t\t\tif (parameterized > 0) {", "+\t\t\t\t\t\t\t\t// SEARCH_15 (frederic) Not treated yet...", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameQUESTION:", "+\t\t\t\t\t\t\tif (parameterized > 0) {", "+\t\t\t\t\t\t\t\tif (wildcards[paramPtr] == -1) {", "+\t\t\t\t\t\t\t\t\twildcards[paramPtr] = Wildcard.UNBOUND;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t// SEARCH_15 (frederic) Invalid syntax", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameextends:", "+\t\t\t\t\t\t\tif (parameterized > 0) {", "+\t\t\t\t\t\t\t\tif (wildcards[paramPtr] == Wildcard.UNBOUND) {", "+\t\t\t\t\t\t\t\t\twildcards[paramPtr] = Wildcard.EXTENDS;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t// SEARCH_15 (frederic) Invalid syntax", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNamesuper:", "+\t\t\t\t\t\t\tif (parameterized > 0) {", "+\t\t\t\t\t\t\t\tif (wildcards[paramPtr] == Wildcard.UNBOUND) {", "+\t\t\t\t\t\t\t\t\twildcards[paramPtr] = Wildcard.SUPER;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t// SEARCH_15 (frederic) Invalid syntax", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameCOMMA:", "+\t\t\t\t\t\t\tif (parameterized == 1) {", "+\t\t\t\t\t\t\t\tparamPtr++;", "+\t\t\t\t\t\t\t\twildcards[paramPtr] = -1;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameGREATER:", "+\t\t\t\t\t\t\tif (parameterized == 1) storeParam = false;", "+\t\t\t\t\t\t\tparameterized--;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\t\t\tif (parameterized == 0) {", "+\t\t\t\t\t\t\t\tparamNames = new char[10][]; // 10 parameters max", "+\t\t\t\t\t\t\t\tparamPtr++;", "+\t\t\t\t\t\t\t\twildcards[paramPtr] = -1;", "+\t\t\t\t\t\t\t\tstoreType = false;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tparameterized++;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier:", "+\t\t\t\t\t\t\tif (parameterized == 1 && storeParam) {", "+\t\t\t\t\t\t\t\tif (paramPtr < paramNames.length) {", "+\t\t\t\t\t\t\t\t\tif (paramNames[paramPtr] == null) {", "+\t\t\t\t\t\t\t\t\t\t// never store id at this index", "+\t\t\t\t\t\t\t\t\t\tparamNames[paramPtr] = scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t// syntax error", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (storeType) { // store type if not in type arguments declaration", "+\t\t\t\t}", "+\t\t\t\tstoreType = parameterized == 0;", "+\t\t// Resize param names array if necessary", "+\t\tif (paramPtr >= 0) {", "+\t\t\tSystem.arraycopy(paramNames, 0, paramNames = new char[paramPtr+1][], 0, paramPtr+1);", "+\t\t\tSystem.arraycopy(wildcards, 0, wildcards = new int[paramPtr+1], 0, paramPtr+1);", "+\t\t}", "-\t\t\t\treturn new TypeReferencePattern(qualificationChars, typeChars, matchRule);", "+\t\t\t\treturn new TypeReferencePattern(qualificationChars, typeChars, paramNames, false /* not generic */, wildcards, matchRule);"]}], "num": 28908}