{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a3af57d9cd998cd0dedefdb0f8338fcf", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "24cb7d996d227af7a8f14d7c0b455ba0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "8263b1bf4e0979f16664b3ec7a3f63f9c444d8c1", "commitAfterChange": "b19e9753b2440fbc565e94b25c4419c1ce3ce1f2", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static void createProblemType(TypeDeclaration typeDeclaration, CompilationResult unitResult)", "signatureAfterChange": " \tpublic static void createProblemType(TypeDeclaration typeDeclaration, CompilationResult unitResult)", "diff": ["+\t\tboolean abstractMethodsOnly = false;", "-\t\t\t\t// we cannot create problem methods for an interface. So we have to generate a clinit", "-\t\t\t\t// which should contain all the problem", "+\t\t\t\tif (typeBinding.scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8)", "+\t\t\t\t\tabstractMethodsOnly = true;", "+\t\t\t\t// We generate a clinit which contains all the problems, since we may not be able to generate problem methods (< 1.8) and problem constructors (all levels).", "-\t\t\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "-\t\t\t\t\tAbstractMethodDeclaration methodDecl = methodDecls[i];", "-\t\t\t\t\tMethodBinding method = methodDecl.binding;", "-\t\t\t\t\tif (method == null || method.isConstructor()) continue;", "+\t\t\t}", "+\t\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "+\t\t\t\tAbstractMethodDeclaration methodDecl = methodDecls[i];", "+\t\t\t\tMethodBinding method = methodDecl.binding;", "+\t\t\t\tif (method == null) continue;", "+\t\t\t\tif (abstractMethodsOnly) {", "-\t\t\t\t\tclassFile.addAbstractMethod(methodDecl, method);", "-\t\t\t} else {", "-\t\t\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "-\t\t\t\t\tAbstractMethodDeclaration methodDecl = methodDecls[i];", "-\t\t\t\t\tMethodBinding method = methodDecl.binding;", "-\t\t\t\t\tif (method == null) continue;", "-\t\t\t\t\tif (method.isConstructor()) {", "-\t\t\t\t\t\tclassFile.addProblemConstructor(methodDecl, method, problemsCopy);", "-\t\t\t\t\t} else if (method.isAbstract()) {", "-\t\t\t\t\t\tclassFile.addAbstractMethod(methodDecl, method);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tclassFile.addProblemMethod(methodDecl, method, problemsCopy);", "-\t\t\t\t\t}", "+\t\t\t\tif (method.isConstructor()) {", "+\t\t\t\t\tif (typeBinding.isInterface()) continue;", "+\t\t\t\t\tclassFile.addProblemConstructor(methodDecl, method, problemsCopy);", "+\t\t\t\t} else if (method.isAbstract()) {", "+\t\t\t\t\tclassFile.addAbstractMethod(methodDecl, method);", "+\t\t\t\t} else {", "+\t\t\t\t\tclassFile.addProblemMethod(methodDecl, method, problemsCopy);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8de500ea7fac001043bb970dbd0f747b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetClassFile.java", "commitBeforeChange": "8263b1bf4e0979f16664b3ec7a3f63f9c444d8c1", "commitAfterChange": "b19e9753b2440fbc565e94b25c4419c1ce3ce1f2", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public static void createProblemType(TypeDeclaration typeDeclaration, CompilationResult unitResult)", "signatureAfterChange": " public static void createProblemType(TypeDeclaration typeDeclaration, CompilationResult unitResult)", "diff": ["+\tboolean abstractMethodsOnly = false;", "-\t\t\t// we cannot create problem methods for an interface. So we have to generate a clinit", "-\t\t\t// which should contain all the problem", "+\t\t\tif (typeBinding.scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8)", "+\t\t\t\tabstractMethodsOnly = true;", "+\t\t\t// We generate a clinit which contains all the problems, since we may not be able to generate problem methods (< 1.8) and problem constructors (all levels).", "-\t\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "-\t\t\t\tAbstractMethodDeclaration methodDecl = methodDecls[i];", "-\t\t\t\tMethodBinding method = methodDecl.binding;", "-\t\t\t\tif (method == null || method.isConstructor()) continue;", "+\t\t}", "+\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "+\t\t\tAbstractMethodDeclaration methodDecl = methodDecls[i];", "+\t\t\tMethodBinding method = methodDecl.binding;", "+\t\t\tif (method == null) continue;", "+\t\t\tif (abstractMethodsOnly) {", "-\t\t\t\tclassFile.addAbstractMethod(methodDecl, method);", "-\t\t} else {", "-\t\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "-\t\t\t\tAbstractMethodDeclaration methodDecl = methodDecls[i];", "-\t\t\t\tMethodBinding method = methodDecl.binding;", "-\t\t\t\tif (method == null) continue;", "-\t\t\t\tif (method.isConstructor()) {", "-\t\t\t\t\tclassFile.addProblemConstructor(methodDecl, method, problemsCopy);", "-\t\t\t\t} else if (method.isAbstract()) {", "-\t\t\t\t\tclassFile.addAbstractMethod(methodDecl, method);", "-\t\t\t\t} else {", "-\t\t\t\t\tclassFile.addProblemMethod(methodDecl, method, problemsCopy);", "-\t\t\t\t}", "+\t\t\tif (method.isConstructor()) {", "+\t\t\t\tif (typeBinding.isInterface()) continue;", "+\t\t\t\tclassFile.addProblemConstructor(methodDecl, method, problemsCopy);", "+\t\t\t} else if (method.isAbstract()) {", "+\t\t\t\tclassFile.addAbstractMethod(methodDecl, method);", "+\t\t\t} else {", "+\t\t\t\tclassFile.addProblemMethod(methodDecl, method, problemsCopy);"]}], "num": 20434}