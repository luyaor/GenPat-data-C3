{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0ec54df2d53cf048df749c430bc21740", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0bcaea2858241904d808ae14303655e4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "931e434bb3e4b9f62577b10f8123cfc028893969", "commitAfterChange": "c0b519c3b149b13ea0f307f0d3414359b2cf0639", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tpublic void generatePostIncrement( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tCompoundAssignment postIncrement, \t\tboolean valueRequired)", "signatureAfterChange": "  public void generatePostIncrement( \tBlockScope currentScope, \tCodeStream codeStream, \tCompoundAssignment postIncrement, \tboolean valueRequired)", "diff": ["-\t", "-\tpublic void generatePostIncrement(", "-\t\tBlockScope currentScope,", "-\t\tCodeStream codeStream,", "-\t\tCompoundAssignment postIncrement,", "-\t\tboolean valueRequired) {", "-\t    ", "-\t\tFieldBinding lastFieldBinding = generateReadSequence(currentScope, codeStream);", "-\t\tSyntheticMethodBinding accessor =", "-\t\t\tsyntheticReadAccessors == null", "-\t\t\t\t? null", "-\t\t\t\t: syntheticReadAccessors[syntheticReadAccessors.length - 1];", "-\t\tif (lastFieldBinding.isStatic()) {", "-\t\t\tif (accessor == null) {", "-\t\t\t\tcodeStream.getstatic(lastFieldBinding);", "-\t\t\t} else {", "-\t\t\t\tcodeStream.invokestatic(accessor);", "-\t\t\t}", "-\t\t} else {", "-\t\t\tcodeStream.dup();", "-\t\t\tif (accessor == null) {", "-\t\t\t\tcodeStream.getfield(lastFieldBinding);", "-\t\t\t} else {", "-\t\t\t\tcodeStream.invokestatic(accessor);", "-\t\t\t}", "-\t\t}", "-\t\t// duplicate the old field value", "-\t\tif (valueRequired) {", "-\t\t\tif (lastFieldBinding.isStatic()) {", "-\t\t\t\tif ((lastFieldBinding.type == TypeBinding.LONG)", "-\t\t\t\t\t|| (lastFieldBinding.type == TypeBinding.DOUBLE)) {", "-\t\t\t\t\tcodeStream.dup2();", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.dup();", "-\t\t\t\t}", "-\t\t\t} else { // Stack:  [owner][old field value]  ---> [old field value][owner][old field value]", "-\t\t\t\tif ((lastFieldBinding.type == TypeBinding.LONG)", "-\t\t\t\t\t|| (lastFieldBinding.type == TypeBinding.DOUBLE)) {", "-\t\t\t\t\tcodeStream.dup2_x1();", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.dup_x1();", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tTypeBinding requiredGenericCast = getGenericCast(this.otherCodegenBindings == null ? 0 : this.otherCodegenBindings.length);", "-\t\tif (requiredGenericCast != null) codeStream.checkcast(requiredGenericCast);", "-\t\tcodeStream.generateImplicitConversion(implicitConversion);\t\t", "-\t\tcodeStream.generateConstant(", "-\t\t\tpostIncrement.expression.constant,", "-\t\t\timplicitConversion);", "-\t\tcodeStream.sendOperator(postIncrement.operator, this.implicitConversion & COMPILE_TYPE_MASK);", "-\t\tcodeStream.generateImplicitConversion(", "-\t\t\tpostIncrement.preAssignImplicitConversion);", "-\t\tfieldStore(codeStream, lastFieldBinding, syntheticWriteAccessor, false);", "-\t}\t", "+", "+public void generatePostIncrement(", "+\tBlockScope currentScope,", "+\tCodeStream codeStream,", "+\tCompoundAssignment postIncrement,", "+\tboolean valueRequired) {", "+    ", "+\tFieldBinding lastFieldBinding = generateReadSequence(currentScope, codeStream);", "+\tSyntheticMethodBinding accessor =", "+\t\tthis.syntheticReadAccessors == null", "+\t\t\t? null", "+\t\t\t: this.syntheticReadAccessors[this.syntheticReadAccessors.length - 1];", "+\tif (lastFieldBinding.isStatic()) {", "+\t\tif (accessor == null) {", "+\t\t\tcodeStream.getstatic(lastFieldBinding);", "+\t\t} else {", "+\t\t\tcodeStream.invokestatic(accessor);", "+\t\t}", "+\t} else {", "+\t\tcodeStream.dup();", "+\t\tif (accessor == null) {", "+\t\t\tcodeStream.getfield(lastFieldBinding);", "+\t\t} else {", "+\t\t\tcodeStream.invokestatic(accessor);", "+\t\t}", "+\t}", "+\t// duplicate the old field value", "+\tif (valueRequired) {", "+\t\tif (lastFieldBinding.isStatic()) {", "+\t\t\tif ((lastFieldBinding.type == TypeBinding.LONG)", "+\t\t\t\t|| (lastFieldBinding.type == TypeBinding.DOUBLE)) {", "+\t\t\t\tcodeStream.dup2();", "+\t\t\t} else {", "+\t\t\t\tcodeStream.dup();", "+\t\t\t}", "+\t\t} else { // Stack:  [owner][old field value]  ---> [old field value][owner][old field value]", "+\t\t\tif ((lastFieldBinding.type == TypeBinding.LONG)", "+\t\t\t\t|| (lastFieldBinding.type == TypeBinding.DOUBLE)) {", "+\t\t\t\tcodeStream.dup2_x1();", "+\t\t\t} else {", "+\t\t\t\tcodeStream.dup_x1();", "+\tTypeBinding requiredGenericCast = getGenericCast(this.otherCodegenBindings == null ? 0 : this.otherCodegenBindings.length);", "+\tif (requiredGenericCast != null) codeStream.checkcast(requiredGenericCast);", "+\tcodeStream.generateImplicitConversion(this.implicitConversion);\t\t", "+\tcodeStream.generateConstant(", "+\t\tpostIncrement.expression.constant,", "+\t\tthis.implicitConversion);", "+\tcodeStream.sendOperator(postIncrement.operator, this.implicitConversion & TypeIds.COMPILE_TYPE_MASK);", "+\tcodeStream.generateImplicitConversion(", "+\t\tpostIncrement.preAssignImplicitConversion);", "+\tfieldStore(codeStream, lastFieldBinding, this.syntheticWriteAccessor, false);", "+}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "15fc83f83e35c7fb761f3894b54ccd10", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic void generateCompoundAssignment( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tExpression expression, \t\tint operator, \t\tint assignmentImplicitConversion, \t\tboolean valueRequired)", "signatureAfterChange": "  public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "diff": ["-", "-\tpublic void generateCompoundAssignment(", "-\t\tBlockScope currentScope,", "-\t\tCodeStream codeStream,", "-\t\tExpression expression,", "-\t\tint operator,", "-\t\tint assignmentImplicitConversion,", "-\t\tboolean valueRequired) {", "-", "-\t\treceiver.generateCode(currentScope, codeStream, true);", "-\t\tif (receiver instanceof CastExpression\t// ((type[])null)[0]", "-\t\t\t\t&& ((CastExpression)receiver).innermostCastedExpression().resolvedType == TypeBinding.NULL){", "-\t\t\tcodeStream.checkcast(receiver.resolvedType); ", "-\t\t}\t", "-\t\tposition.generateCode(currentScope, codeStream, true);", "-\t\tcodeStream.dup2();", "-\t\tcodeStream.arrayAt(this.resolvedType.id);", "-\t\tint operationTypeID;", "-\t\tswitch(operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) {", "-\t\t\tcase T_JavaLangString :", "-\t\t\tcase T_JavaLangObject :", "-\t\t\tcase T_undefined :", "-\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t\t\t// promote the array reference to the suitable operation type", "-\t\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "-\t\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\t\tif (expression == IntLiteral.One) { // prefix operation", "-\t\t\t\t\tcodeStream.generateConstant(expression.constant, implicitConversion);", "-\t\t\t\t} else {", "-\t\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t\t}", "-\t\t\t\t// perform the operation", "-\t\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t\t// cast the value back to the array reference type", "-\t\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "-\t\tcodeStream.arrayAtPut(this.resolvedType.id, valueRequired);", "+public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired) {", "+\tthis.receiver.generateCode(currentScope, codeStream, true);", "+\tif (this.receiver instanceof CastExpression\t// ((type[])null)[0]", "+\t\t\t&& ((CastExpression)this.receiver).innermostCastedExpression().resolvedType == TypeBinding.NULL){", "+\t\tcodeStream.checkcast(this.receiver.resolvedType); ", "+\t}\t", "+\tthis.position.generateCode(currentScope, codeStream, true);", "+\tcodeStream.dup2();", "+\tcodeStream.arrayAt(this.resolvedType.id);", "+\tint operationTypeID;", "+\tswitch(operationTypeID = (this.implicitConversion & TypeIds.IMPLICIT_CONVERSION_MASK) >> 4) {", "+\t\tcase T_JavaLangString :", "+\t\tcase T_JavaLangObject :", "+\t\tcase T_undefined :", "+\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "+\t\t\tbreak;", "+\t\tdefault :", "+\t\t\t// promote the array reference to the suitable operation type", "+\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "+\t\t\tif (expression == IntLiteral.One) { // prefix operation", "+\t\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);", "+\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "+\t\t\t// perform the operation", "+\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "+\t\t\t// cast the value back to the array reference type", "+\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "+\tcodeStream.arrayAtPut(this.resolvedType.id, valueRequired);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4dd98e1aa125dfebab6d30bab13143a3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "931e434bb3e4b9f62577b10f8123cfc028893969", "commitAfterChange": "c0b519c3b149b13ea0f307f0d3414359b2cf0639", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic void generateCompoundAssignment( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tExpression expression, \t\tint operator, \t\tint assignmentImplicitConversion, \t\tboolean valueRequired)", "signatureAfterChange": "  public void generateCompoundAssignment( \tBlockScope currentScope, \tCodeStream codeStream, \tExpression expression, \tint operator, \tint assignmentImplicitConversion, \tboolean valueRequired)", "diff": ["-\tpublic void generateCompoundAssignment(", "-\t\tBlockScope currentScope,", "-\t\tCodeStream codeStream,", "-\t\tExpression expression,", "-\t\tint operator,", "-\t\tint assignmentImplicitConversion,", "-\t\tboolean valueRequired) {", "-\t\t\t", "-\t\tFieldBinding lastFieldBinding = generateReadSequence(currentScope, codeStream);", "-\t\tSyntheticMethodBinding accessor =", "-\t\t\tsyntheticReadAccessors == null", "-\t\t\t\t? null", "-\t\t\t\t: syntheticReadAccessors[syntheticReadAccessors.length - 1];", "-\t\tif (lastFieldBinding.isStatic()) {", "-\t\t\tif (accessor == null) {", "-\t\t\t\tcodeStream.getstatic(lastFieldBinding);", "-\t\t\t} else {", "-\t\t\t\tcodeStream.invokestatic(accessor);", "-\t\t\t}", "-\t\t} else {", "-\t\t\tcodeStream.dup();", "-\t\t\tif (accessor == null) {", "-\t\t\t\tcodeStream.getfield(lastFieldBinding);", "-\t\t\t} else {", "-\t\t\t\tcodeStream.invokestatic(accessor);", "-\t\t\t}", "-\t\t}", "-\t\t// the last field access is a write access", "-\t\t// perform the actual compound operation", "-\t\tint operationTypeID;", "-\t\tswitch(operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) {", "-\t\t\tcase T_JavaLangString :", "-\t\t\tcase T_JavaLangObject :", "-\t\t\tcase T_undefined :", "-\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t\t\tbreak;", "-\t\t\tdefault :", "-\t\t\t\tTypeBinding requiredGenericCast = getGenericCast(this.otherCodegenBindings == null ? 0 : this.otherCodegenBindings.length);", "-\t\t\t\tif (requiredGenericCast != null) codeStream.checkcast(requiredGenericCast);\t\t\t\t", "-\t\t\t\t// promote the array reference to the suitable operation type", "-\t\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "-\t\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\t\tif (expression == IntLiteral.One) { // prefix operation", "-\t\t\t\t\tcodeStream.generateConstant(expression.constant, implicitConversion);", "-\t\t\t\t} else {", "-\t\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t\t}", "-\t\t\t\t// perform the operation", "-\t\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t\t// cast the value back to the array reference type", "-\t\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "-\t\t}", "-\t\t// actual assignment", "-\t\tfieldStore(codeStream, lastFieldBinding, syntheticWriteAccessor, valueRequired);", "-\t\t// equivalent to valuesRequired[maxOtherBindings]", "-\t}", "+", "+public void generateCompoundAssignment(", "+\tBlockScope currentScope,", "+\tCodeStream codeStream,", "+\tExpression expression,", "+\tint operator,", "+\tint assignmentImplicitConversion,", "+\tboolean valueRequired) {", "+\tFieldBinding lastFieldBinding = generateReadSequence(currentScope, codeStream);", "+\tSyntheticMethodBinding accessor =", "+\t\tthis.syntheticReadAccessors == null", "+\t\t\t? null", "+\t\t\t: this.syntheticReadAccessors[this.syntheticReadAccessors.length - 1];", "+\tif (lastFieldBinding.isStatic()) {", "+\t\tif (accessor == null) {", "+\t\t\tcodeStream.getstatic(lastFieldBinding);", "+\t\t} else {", "+\t\t\tcodeStream.invokestatic(accessor);", "+\t} else {", "+\t\tcodeStream.dup();", "+\t\tif (accessor == null) {", "+\t\t\tcodeStream.getfield(lastFieldBinding);", "+\t\t} else {", "+\t\t\tcodeStream.invokestatic(accessor);", "+\t\t}", "+\t}", "+\t// the last field access is a write access", "+\t// perform the actual compound operation", "+\tint operationTypeID;", "+\tswitch(operationTypeID = (this.implicitConversion & TypeIds.IMPLICIT_CONVERSION_MASK) >> 4) {", "+\t\tcase T_JavaLangString :", "+\t\tcase T_JavaLangObject :", "+\t\tcase T_undefined :", "+\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "+\t\t\tbreak;", "+\t\tdefault :", "+\t\t\tTypeBinding requiredGenericCast = getGenericCast(this.otherCodegenBindings == null ? 0 : this.otherCodegenBindings.length);", "+\t\t\tif (requiredGenericCast != null) codeStream.checkcast(requiredGenericCast);\t\t\t\t", "+\t\t\t// promote the array reference to the suitable operation type", "+\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "+\t\t\tif (expression == IntLiteral.One) { // prefix operation", "+\t\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);", "+\t\t\t} else {", "+\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "+\t\t\t}", "+\t\t\t// perform the operation", "+\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "+\t\t\t// cast the value back to the array reference type", "+\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "+\t}", "+\t// actual assignment", "+\tfieldStore(codeStream, lastFieldBinding, this.syntheticWriteAccessor, valueRequired);", "+\t// equivalent to valuesRequired[maxOtherBindings]", "+}"]}], "num": 33001}