{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cf22253c3d5c3614a143431864c76d21", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2706547e8db202c1d2e2e94c7d2001f2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "135399ac7f48d47679e738d0a583e6c95ff87fd6", "commitAfterChange": "092d49846655da2c4e511a256ba551dc4e15c674", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r private void findConstructors(ReferenceBinding currentType, TypeBinding[] argTypes, Scope scope)", "signatureAfterChange": "\r \tprivate void findConstructors(\r \t\tReferenceBinding currentType,\r \t\tTypeBinding[] argTypes,\r \t\tScope scope,\r \t\tInvocationSite invocationSite)", "diff": ["-}\r", "-private void findConstructors(ReferenceBinding currentType, TypeBinding[] argTypes, Scope scope) {\r", "-\t// No visibility checks can be performed without the scope & invocationSite\r", "-\tMethodBinding[] methods = currentType.methods();\r", "-\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\tMethodBinding constructor = methods[f];\r", "-\t\tif (constructor.isConstructor()) {\r", "-\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "-\t\t\tint paramLength = parameters.length;\r", "-\t\t\tif (minArgLength > paramLength) continue next;\r", "-\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a])) continue next;\r", "-\r", "-\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "-\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "-\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "-\t\t\t\tTypeBinding type = parameters[i];\r", "-\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\t\t}\r", "-\t\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\tif (source == null || source.length <= endPosition || source[endPosition] != ')')\r", "-\t\t\t\tcompletion = new char[] {')'};\r", "-\t\t\trequestor.acceptMethod(\r", "-\t\t\t\tcurrentType.qualifiedPackageName(),\r", "-\t\t\t\tcurrentType.qualifiedSourceName(),\r", "-\t\t\t\tcurrentType.sourceName(),\r", "-\t\t\t\tparameterPackageNames,\r", "-\t\t\t\tparameterTypeNames,\r", "-\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\tcompletion,\r", "-\t\t\t\tconstructor.modifiers,\r", "-\t\t\t\tendPosition,\r", "-\t\t\t\tendPosition);\r", "-\t\t}\r", "-\t}\r", "-}\r", "+\tprivate void findConstructors(\r", "+\t\tReferenceBinding currentType,\r", "+\t\tTypeBinding[] argTypes,\r", "+\t\tScope scope,\r", "+\t\tInvocationSite invocationSite) {\r", "+\t\t// No visibility checks can be performed without the scope & invocationSite\r", "+\t\tMethodBinding[] methods = currentType.methods();\r", "+\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\tMethodBinding constructor = methods[f];\r", "+\t\t\tif (constructor.isConstructor()) {\r", "+\t\t\t\tif (options.checkVisibilitySensitive()\r", "+\t\t\t\t\t&& !constructor.canBeSeenBy(invocationSite, scope))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "+\t\t\t\tint paramLength = parameters.length;\r", "+\t\t\t\tif (minArgLength > paramLength)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a]))\r", "+\t\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "+\t\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "+\t\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "+\t\t\t\t\tTypeBinding type = parameters[i];\r", "+\t\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t\t}\r", "+\t\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\t\tif (source == null\r", "+\t\t\t\t\t|| source.length <= endPosition\r", "+\t\t\t\t\t|| source[endPosition] != ')')\r", "+\t\t\t\t\tcompletion = new char[] { ')' };\r", "+\t\t\t\trequestor.acceptMethod(\r", "+\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "+\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "+\t\t\t\t\tcurrentType.sourceName(),\r", "+\t\t\t\t\tparameterPackageNames,\r", "+\t\t\t\t\tparameterTypeNames,\r", "+\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\tcompletion,\r", "+\t\t\t\t\tconstructor.modifiers,\r", "+\t\t\t\t\tendPosition,\r", "+\t\t\t\t\tendPosition);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2bfdc7ac1319c42202e6d7497c10c8e3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "commitAfterChange": "7e5cc03e445550d3cbc10c611218c79332074276", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r private void findConstructors(ReferenceBinding currentType, TypeBinding[] argTypes, Scope scope)", "signatureAfterChange": "\r \tprivate void findConstructors(\r \t\tReferenceBinding currentType,\r \t\tTypeBinding[] argTypes,\r \t\tScope scope,\r \t\tInvocationSite invocationSite)", "diff": ["-}\r", "-private void findConstructors(ReferenceBinding currentType, TypeBinding[] argTypes, Scope scope) {\r", "-\t// No visibility checks can be performed without the scope & invocationSite\r", "-\tMethodBinding[] methods = currentType.methods();\r", "-\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\tMethodBinding constructor = methods[f];\r", "-\t\tif (constructor.isConstructor()) {\r", "-\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "-\t\t\tint paramLength = parameters.length;\r", "-\t\t\tif (minArgLength > paramLength) continue next;\r", "-\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a])) continue next;\r", "-\r", "-\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "-\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "-\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "-\t\t\t\tTypeBinding type = parameters[i];\r", "-\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\t\t}\r", "-\t\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\tif (source == null || source.length <= endPosition || source[endPosition] != ')')\r", "-\t\t\t\tcompletion = new char[] {')'};\r", "-\t\t\trequestor.acceptMethod(\r", "-\t\t\t\tcurrentType.qualifiedPackageName(),\r", "-\t\t\t\tcurrentType.qualifiedSourceName(),\r", "-\t\t\t\tcurrentType.sourceName(),\r", "-\t\t\t\tparameterPackageNames,\r", "-\t\t\t\tparameterTypeNames,\r", "-\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\tcompletion,\r", "-\t\t\t\tconstructor.modifiers,\r", "-\t\t\t\tendPosition,\r", "-\t\t\t\tendPosition);\r", "-\t\t}\r", "-\t}\r", "-}\r", "+\tprivate void findConstructors(\r", "+\t\tReferenceBinding currentType,\r", "+\t\tTypeBinding[] argTypes,\r", "+\t\tScope scope,\r", "+\t\tInvocationSite invocationSite) {\r", "+\t\t// No visibility checks can be performed without the scope & invocationSite\r", "+\t\tMethodBinding[] methods = currentType.methods();\r", "+\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\tMethodBinding constructor = methods[f];\r", "+\t\t\tif (constructor.isConstructor()) {\r", "+\t\t\t\tif (options.checkVisibilitySensitive()\r", "+\t\t\t\t\t&& !constructor.canBeSeenBy(invocationSite, scope))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "+\t\t\t\tint paramLength = parameters.length;\r", "+\t\t\t\tif (minArgLength > paramLength)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a]))\r", "+\t\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "+\t\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "+\t\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "+\t\t\t\t\tTypeBinding type = parameters[i];\r", "+\t\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t\t}\r", "+\t\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\t\tif (source == null\r", "+\t\t\t\t\t|| source.length <= endPosition\r", "+\t\t\t\t\t|| source[endPosition] != ')')\r", "+\t\t\t\t\tcompletion = new char[] { ')' };\r", "+\t\t\t\trequestor.acceptMethod(\r", "+\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "+\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "+\t\t\t\t\tcurrentType.sourceName(),\r", "+\t\t\t\t\tparameterPackageNames,\r", "+\t\t\t\t\tparameterTypeNames,\r", "+\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\tcompletion,\r", "+\t\t\t\t\tconstructor.modifiers,\r", "+\t\t\t\t\tendPosition,\r", "+\t\t\t\t\tendPosition);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f0eda420c033596dbc8eac3d86abc86", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "40383c2427f4645edcb9e28f2e15a8a778f0a951", "commitAfterChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r private void findConstructors(ReferenceBinding currentType, TypeBinding[] argTypes, Scope scope)", "signatureAfterChange": "\r \tprivate void findConstructors(\r \t\tReferenceBinding currentType,\r \t\tTypeBinding[] argTypes,\r \t\tScope scope,\r \t\tInvocationSite invocationSite)", "diff": ["-}\r", "-private void findConstructors(ReferenceBinding currentType, TypeBinding[] argTypes, Scope scope) {\r", "-\t// No visibility checks can be performed without the scope & invocationSite\r", "-\tMethodBinding[] methods = currentType.methods();\r", "-\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\tMethodBinding constructor = methods[f];\r", "-\t\tif (constructor.isConstructor()) {\r", "-\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "-\t\t\tint paramLength = parameters.length;\r", "-\t\t\tif (minArgLength > paramLength) continue next;\r", "-\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a])) continue next;\r", "-\r", "-\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "-\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "-\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "-\t\t\t\tTypeBinding type = parameters[i];\r", "-\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\t\t}\r", "-\t\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\tif (source == null || source.length <= endPosition || source[endPosition] != ')')\r", "-\t\t\t\tcompletion = new char[] {')'};\r", "-\t\t\trequestor.acceptMethod(\r", "-\t\t\t\tcurrentType.qualifiedPackageName(),\r", "-\t\t\t\tcurrentType.qualifiedSourceName(),\r", "-\t\t\t\tcurrentType.sourceName(),\r", "-\t\t\t\tparameterPackageNames,\r", "-\t\t\t\tparameterTypeNames,\r", "-\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\tcompletion,\r", "-\t\t\t\tconstructor.modifiers,\r", "-\t\t\t\tendPosition,\r", "-\t\t\t\tendPosition);\r", "-\t\t}\r", "-\t}\r", "-}\r", "+\tprivate void findConstructors(\r", "+\t\tReferenceBinding currentType,\r", "+\t\tTypeBinding[] argTypes,\r", "+\t\tScope scope,\r", "+\t\tInvocationSite invocationSite) {\r", "+\t\t// No visibility checks can be performed without the scope & invocationSite\r", "+\t\tMethodBinding[] methods = currentType.methods();\r", "+\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\tMethodBinding constructor = methods[f];\r", "+\t\t\tif (constructor.isConstructor()) {\r", "+\t\t\t\tif (options.checkVisibilitySensitive()\r", "+\t\t\t\t\t&& !constructor.canBeSeenBy(invocationSite, scope))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "+\t\t\t\tint paramLength = parameters.length;\r", "+\t\t\t\tif (minArgLength > paramLength)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a]))\r", "+\t\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "+\t\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "+\t\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "+\t\t\t\t\tTypeBinding type = parameters[i];\r", "+\t\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t\t}\r", "+\t\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\t\tif (source == null\r", "+\t\t\t\t\t|| source.length <= endPosition\r", "+\t\t\t\t\t|| source[endPosition] != ')')\r", "+\t\t\t\t\tcompletion = new char[] { ')' };\r", "+\t\t\t\trequestor.acceptMethod(\r", "+\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "+\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "+\t\t\t\t\tcurrentType.sourceName(),\r", "+\t\t\t\t\tparameterPackageNames,\r", "+\t\t\t\t\tparameterTypeNames,\r", "+\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\tcompletion,\r", "+\t\t\t\t\tconstructor.modifiers,\r", "+\t\t\t\t\tendPosition,\r", "+\t\t\t\t\tendPosition);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "825852b5bd15a1b6d6bee35a2b72b3a1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "3ff7b81bced83cc6ffeee9cd4ddf361110eeeb98", "commitAfterChange": "25f2a2d3f2ea6a2ed84c0af6dba49f7f2a42eab8", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "\r \r \tprivate void findConstructors(\r \t\tReferenceBinding currentType,\r \t\tTypeBinding[] argTypes,\r \t\tScope scope,\r \t\tInvocationSite invocationSite,\r \t\tboolean forAnonymousType)", "signatureAfterChange": "\r \r \tprivate void findConstructors(\r \t\tReferenceBinding currentType,\r \t\tTypeBinding[] argTypes,\r \t\tScope scope,\r \t\tInvocationSite invocationSite,\r \t\tboolean forAnonymousType)", "diff": ["-\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\t\tMethodBinding constructor = methods[f];\r", "-\t\t\tif (constructor.isConstructor()) {\r", "-\t\t\t\t\r", "-\t\t\t\tif (constructor.isSynthetic()) continue next;\r", "+\t\tif(methods != null) {\r", "+\t\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\t\tMethodBinding constructor = methods[f];\r", "+\t\t\t\tif (constructor.isConstructor()) {\r", "-\t\t\t\tif (options.checkVisibility\r", "-\t\t\t\t\t&& !constructor.canBeSeenBy(invocationSite, scope)) continue next;\r", "-\r", "-\t\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "-\t\t\t\tint paramLength = parameters.length;\r", "-\t\t\t\tif (minArgLength > paramLength)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a]))\r", "-\t\t\t\t\t\t\tcontinue next;\r", "-\r", "-\t\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "-\t\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "-\t\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "-\t\t\t\t\tTypeBinding type = parameters[i];\r", "-\t\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\t\t\t}\r", "-\t\t\t\tchar[][] parameterNames = findMethodParameterNames(constructor,parameterTypeNames);\r", "-\t\t\t\t\r", "-\t\t\t\tchar[] completion = TypeConstants.NoChar;\r", "-\t\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\t\tif (source == null\r", "-\t\t\t\t\t|| source.length <= endPosition\r", "-\t\t\t\t\t|| source[endPosition] != ')')\r", "-\t\t\t\t\tcompletion = new char[] { ')' };\r", "-\t\t\t\t\r", "-\t\t\t\tint relevance = DEFAULTRELEVANCE;\r", "-\t\t\t\t\r", "-\t\t\t\tif(forAnonymousType){\r", "-\t\t\t\t\trequestor.acceptAnonymousType(\r", "-\t\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "-\t\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "-\t\t\t\t\t\tparameterPackageNames,\r", "-\t\t\t\t\t\tparameterTypeNames,\r", "-\t\t\t\t\t\tparameterNames,\r", "-\t\t\t\t\t\tcompletion,\r", "-\t\t\t\t\t\tconstructor.modifiers,\r", "-\t\t\t\t\t\tendPosition - offset,\r", "-\t\t\t\t\t\tendPosition - offset,\r", "-\t\t\t\t\t\trelevance);\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\trequestor.acceptMethod(\r", "-\t\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "-\t\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "-\t\t\t\t\t\tcurrentType.sourceName(),\r", "-\t\t\t\t\t\tparameterPackageNames,\r", "-\t\t\t\t\t\tparameterTypeNames,\r", "-\t\t\t\t\t\tparameterNames,\r", "-\t\t\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\t\t\tcompletion,\r", "-\t\t\t\t\t\tconstructor.modifiers,\r", "-\t\t\t\t\t\tendPosition - offset,\r", "-\t\t\t\t\t\tendPosition - offset,\r", "-\t\t\t\t\t\trelevance);\r", "+\t\t\t\t\tif (constructor.isSynthetic()) continue next;\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\tif (options.checkVisibility\r", "+\t\t\t\t\t\t&& !constructor.canBeSeenBy(invocationSite, scope)) continue next;\r", "+\t\r", "+\t\t\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "+\t\t\t\t\tint paramLength = parameters.length;\r", "+\t\t\t\t\tif (minArgLength > paramLength)\r", "+\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a]))\r", "+\t\t\t\t\t\t\t\tcontinue next;\r", "+\t\r", "+\t\t\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "+\t\t\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "+\t\t\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "+\t\t\t\t\t\tTypeBinding type = parameters[i];\r", "+\t\t\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tchar[][] parameterNames = findMethodParameterNames(constructor,parameterTypeNames);\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\t\t\tif (source == null\r", "+\t\t\t\t\t\t|| source.length <= endPosition\r", "+\t\t\t\t\t\t|| source[endPosition] != ')')\r", "+\t\t\t\t\t\tcompletion = new char[] { ')' };\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tint relevance = DEFAULTRELEVANCE;\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tif(forAnonymousType){\r", "+\t\t\t\t\t\trequestor.acceptAnonymousType(\r", "+\t\t\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "+\t\t\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "+\t\t\t\t\t\t\tparameterPackageNames,\r", "+\t\t\t\t\t\t\tparameterTypeNames,\r", "+\t\t\t\t\t\t\tparameterNames,\r", "+\t\t\t\t\t\t\tcompletion,\r", "+\t\t\t\t\t\t\tconstructor.modifiers,\r", "+\t\t\t\t\t\t\tendPosition - offset,\r", "+\t\t\t\t\t\t\tendPosition - offset,\r", "+\t\t\t\t\t\t\trelevance);\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\trequestor.acceptMethod(\r", "+\t\t\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "+\t\t\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "+\t\t\t\t\t\t\tcurrentType.sourceName(),\r", "+\t\t\t\t\t\t\tparameterPackageNames,\r", "+\t\t\t\t\t\t\tparameterTypeNames,\r", "+\t\t\t\t\t\t\tparameterNames,\r", "+\t\t\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\t\t\tcompletion,\r", "+\t\t\t\t\t\t\tconstructor.modifiers,\r", "+\t\t\t\t\t\t\tendPosition - offset,\r", "+\t\t\t\t\t\t\tendPosition - offset,\r", "+\t\t\t\t\t\t\trelevance);\r", "+\t\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b987243dbf7b27508af667c1859cf940", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "commitAfterChange": "44855522f87e615f1ca0bfcda268b074e4443dfe", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r private void findConstructors(ReferenceBinding currentType, TypeBinding[] argTypes, Scope scope)", "signatureAfterChange": "\r \tprivate void findConstructors(\r \t\tReferenceBinding currentType,\r \t\tTypeBinding[] argTypes,\r \t\tScope scope,\r \t\tInvocationSite invocationSite)", "diff": ["-}\r", "-private void findConstructors(ReferenceBinding currentType, TypeBinding[] argTypes, Scope scope) {\r", "-\t// No visibility checks can be performed without the scope & invocationSite\r", "-\tMethodBinding[] methods = currentType.methods();\r", "-\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\tMethodBinding constructor = methods[f];\r", "-\t\tif (constructor.isConstructor()) {\r", "-\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "-\t\t\tint paramLength = parameters.length;\r", "-\t\t\tif (minArgLength > paramLength) continue next;\r", "-\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a])) continue next;\r", "-\r", "-\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "-\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "-\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "-\t\t\t\tTypeBinding type = parameters[i];\r", "-\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\t\t}\r", "-\t\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\tif (source == null || source.length <= endPosition || source[endPosition] != ')')\r", "-\t\t\t\tcompletion = new char[] {')'};\r", "-\t\t\trequestor.acceptMethod(\r", "-\t\t\t\tcurrentType.qualifiedPackageName(),\r", "-\t\t\t\tcurrentType.qualifiedSourceName(),\r", "-\t\t\t\tcurrentType.sourceName(),\r", "-\t\t\t\tparameterPackageNames,\r", "-\t\t\t\tparameterTypeNames,\r", "-\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\tcompletion,\r", "-\t\t\t\tconstructor.modifiers,\r", "-\t\t\t\tendPosition,\r", "-\t\t\t\tendPosition);\r", "-\t\t}\r", "-\t}\r", "-}\r", "+\tprivate void findConstructors(\r", "+\t\tReferenceBinding currentType,\r", "+\t\tTypeBinding[] argTypes,\r", "+\t\tScope scope,\r", "+\t\tInvocationSite invocationSite) {\r", "+\t\t// No visibility checks can be performed without the scope & invocationSite\r", "+\t\tMethodBinding[] methods = currentType.methods();\r", "+\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\tMethodBinding constructor = methods[f];\r", "+\t\t\tif (constructor.isConstructor()) {\r", "+\t\t\t\tif (options.checkVisibilitySensitive()\r", "+\t\t\t\t\t&& !constructor.canBeSeenBy(invocationSite, scope))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "+\t\t\t\tint paramLength = parameters.length;\r", "+\t\t\t\tif (minArgLength > paramLength)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a]))\r", "+\t\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "+\t\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "+\t\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "+\t\t\t\t\tTypeBinding type = parameters[i];\r", "+\t\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t\t}\r", "+\t\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\t\tif (source == null\r", "+\t\t\t\t\t|| source.length <= endPosition\r", "+\t\t\t\t\t|| source[endPosition] != ')')\r", "+\t\t\t\t\tcompletion = new char[] { ')' };\r", "+\t\t\t\trequestor.acceptMethod(\r", "+\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "+\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "+\t\t\t\t\tcurrentType.sourceName(),\r", "+\t\t\t\t\tparameterPackageNames,\r", "+\t\t\t\t\tparameterTypeNames,\r", "+\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\tcompletion,\r", "+\t\t\t\t\tconstructor.modifiers,\r", "+\t\t\t\t\tendPosition,\r", "+\t\t\t\t\tendPosition);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1b3a1d9bf89fd888115601903b16125", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "dfc3b8264596f4754baac29eef1af815f182c4f3", "commitAfterChange": "db0143bfca2398448195a62173050bd24d4fcb31", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r private void findConstructors(ReferenceBinding currentType, TypeBinding[] argTypes, Scope scope)", "signatureAfterChange": "\r \tprivate void findConstructors(\r \t\tReferenceBinding currentType,\r \t\tTypeBinding[] argTypes,\r \t\tScope scope,\r \t\tInvocationSite invocationSite)", "diff": ["-}\r", "-private void findConstructors(ReferenceBinding currentType, TypeBinding[] argTypes, Scope scope) {\r", "-\t// No visibility checks can be performed without the scope & invocationSite\r", "-\tMethodBinding[] methods = currentType.methods();\r", "-\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\tMethodBinding constructor = methods[f];\r", "-\t\tif (constructor.isConstructor()) {\r", "-\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "-\t\t\tint paramLength = parameters.length;\r", "-\t\t\tif (minArgLength > paramLength) continue next;\r", "-\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a])) continue next;\r", "-\r", "-\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "-\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "-\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "-\t\t\t\tTypeBinding type = parameters[i];\r", "-\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\t\t}\r", "-\t\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\tif (source == null || source.length <= endPosition || source[endPosition] != ')')\r", "-\t\t\t\tcompletion = new char[] {')'};\r", "-\t\t\trequestor.acceptMethod(\r", "-\t\t\t\tcurrentType.qualifiedPackageName(),\r", "-\t\t\t\tcurrentType.qualifiedSourceName(),\r", "-\t\t\t\tcurrentType.sourceName(),\r", "-\t\t\t\tparameterPackageNames,\r", "-\t\t\t\tparameterTypeNames,\r", "-\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\tcompletion,\r", "-\t\t\t\tconstructor.modifiers,\r", "-\t\t\t\tendPosition,\r", "-\t\t\t\tendPosition);\r", "-\t\t}\r", "-\t}\r", "-}\r", "+\tprivate void findConstructors(\r", "+\t\tReferenceBinding currentType,\r", "+\t\tTypeBinding[] argTypes,\r", "+\t\tScope scope,\r", "+\t\tInvocationSite invocationSite) {\r", "+\t\t// No visibility checks can be performed without the scope & invocationSite\r", "+\t\tMethodBinding[] methods = currentType.methods();\r", "+\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\tMethodBinding constructor = methods[f];\r", "+\t\t\tif (constructor.isConstructor()) {\r", "+\t\t\t\tif (options.checkVisibilitySensitive()\r", "+\t\t\t\t\t&& !constructor.canBeSeenBy(invocationSite, scope))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "+\t\t\t\tint paramLength = parameters.length;\r", "+\t\t\t\tif (minArgLength > paramLength)\r", "+\t\t\t\t\tcontinue next;\r", "+\t\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a]))\r", "+\t\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "+\t\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "+\t\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "+\t\t\t\t\tTypeBinding type = parameters[i];\r", "+\t\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t\t}\r", "+\t\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\t\tif (source == null\r", "+\t\t\t\t\t|| source.length <= endPosition\r", "+\t\t\t\t\t|| source[endPosition] != ')')\r", "+\t\t\t\t\tcompletion = new char[] { ')' };\r", "+\t\t\t\trequestor.acceptMethod(\r", "+\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "+\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "+\t\t\t\t\tcurrentType.sourceName(),\r", "+\t\t\t\t\tparameterPackageNames,\r", "+\t\t\t\t\tparameterTypeNames,\r", "+\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\tcompletion,\r", "+\t\t\t\t\tconstructor.modifiers,\r", "+\t\t\t\t\tendPosition,\r", "+\t\t\t\t\tendPosition);\r"]}], "num": 53142}