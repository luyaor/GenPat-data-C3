{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "15b16ef1d3e7eb05c349b0f554b198cd", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37d842d62336aa5eff6f32e0eb358829", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "1784048e951cac8e5c6590cc5827817757e6384e", "commitAfterChange": "4a48abb3b4027036bdeac61104059b6c83710144", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int javadocStart, int javadocEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int javadocStart, int javadocEnd)", "diff": ["+\t\t\tthis.index = javadocStart +3;", "+\t\t\tint endComment = javadocEnd - 2;", "+\t\t\t\t// Initialization", "-\t\t\t} else if (this.sourceParser.options.getSeverity(CompilerOptions.MissingJavadocComments) != ProblemSeverities.Ignore) {", "-\t\t\t\tthis.javadoc = new Javadoc(javadocStart, javadocEnd);", "-\t\t\t} else {", "-\t\t\t\tthis.javadoc = null;", "-\t\t\t}", "-", "-\t\t\tint firstLineNumber = this.sourceParser.scanner.getLineNumber(javadocStart);", "-\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(javadocEnd);", "-", "-\t\t\t// scan line per line, since tags must be at beginning of lines only", "-\t\t\tnextLine : for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "-\t\t\t\tint lineStart = line == firstLineNumber", "-\t\t\t\t\t\t? javadocStart + 3 // skip leading /**", "-\t\t\t\t\t\t: this.sourceParser.scanner.getLineStart(line);", "-\t\t\t\tthis.index = lineStart;", "-\t\t\t\tthis.lineEnd = line == lastLineNumber", "-\t\t\t\t\t\t? javadocEnd - 2 // remove trailing */", "-\t\t\t\t\t\t: this.sourceParser.scanner.getLineEnd(line);", "-\t\t\t\twhile (this.index < this.lineEnd) {", "-\t\t\t\t\tchar nextCharacter = readChar(); // consider unicodes", "+\t\t\t\tthis.scanner.startPosition = this.index;", "+\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\tthis.lineStarted = false;", "+\t\t\t\tint lineNumber = this.sourceParser.scanner.getLineNumber(javadocStart);", "+\t\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(javadocEnd);", "+\t\t\t\tthis.lineEnd = lineNumber == lastLineNumber ? javadocEnd - 2 : javadocStart + 3;", "+\t\t\t\tchar nextCharacter= 0, previousChar;", "+\t\t\t\tint charPosition = -1, inlineStartPosition = 0;", "+\t\t\t\t", "+\t\t\t\t// Loop on each comment character", "+\t\t\t\twhile (this.index < endComment) {", "+\t\t\t\t\tint previousPosition = this.index;", "+\t\t\t\t\tpreviousChar = nextCharacter;", "+\t\t\t\t\t", "+\t\t\t\t\t// Calculate line end (cannot use this.scanner.linePtr as scanner does not parse line ends again)", "+\t\t\t\t\tif (this.index > this.lineEnd) {", "+\t\t\t\t\t\tif (lineNumber < lastLineNumber) {", "+\t\t\t\t\t\t\tthis.lineEnd = this.sourceParser.scanner.getLineEnd(++lineNumber) - 1;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.lineEnd = javadocEnd - 2;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.lineStarted = false;", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// Read next char only if token was consumed", "+\t\t\t\t\tif (this.currentTokenType < 0) {", "+\t\t\t\t\t\tnextCharacter = readChar(); // consider unicodes", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tswitch (this.currentTokenType) {", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameRBRACE:", "+\t\t\t\t\t\t\t\tnextCharacter = '}';", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "+\t\t\t\t\t\t\t\tnextCharacter = '*';", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\tnextCharacter = this.scanner.currentCharacter;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t}", "+\t\t\t\t\t", "-\t\t\t\t\t\t\tif (!this.checkJavadoc) {", "-\t\t\t\t\t\t\t\tif ((readChar() == 'd') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'e') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'p') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'r') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'e') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'c') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'a') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 't') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'e') &&", "-\t\t\t\t\t\t\t\t\t(readChar() == 'd')) {", "-\t\t\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "-\t\t\t\t\t\t\t\t\tnextCharacter = readChar();", "-\t\t\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "-\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t\t\tbreak nextLine; // done", "+\t\t\t\t\t\t\tboolean valid = false;", "+\t\t\t\t\t\t\t// Start tag parsing only if we are on line beginning or at inline tag beginning", "+\t\t\t\t\t\t\tif (!this.lineStarted || previousChar == '{') {", "+\t\t\t\t\t\t\t\tthis.lineStarted = true;", "+\t\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "+\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\t\t\t\t\t\tint start = this.astStack[this.astPtr].sourceStart;", "+\t\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidTag(start, charPosition);", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tif (previousChar == '{') {", "+\t\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = true;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, endComment);", "+\t\t\t\t\t\t\t\t\tthis.currentTokenType = -1; // flush token cache at line begin", "+\t\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "+\t\t\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\t\t\t\tswitch (tk) {", "+\t\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_INHERITDOC)) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tthis.javadoc.inherited = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseParam();", "+\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseThrows();", "+\t\t\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE) ||", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.equals(tag, TAG_LINK) ||", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.equals(tag, TAG_LINKPLAIN)) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseSee();", "+\t\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseTag();", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "+\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseReturn();", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamethrows :", "+\t\t\t\t\t\t\t\t\t\t\t\tvalid = parseThrows();", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tif (!valid && this.inlineTagStarted) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\t\t\tcontinue nextLine;", "-\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.lineEnd);", "-\t\t\t\t\t\t\tthis.currentTokenType = -1; // flush token cache at line begin", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "-\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\t\t\tswitch (tk) {", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "-\t\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "-\t\t\t\t\t\t\t\t\t\t\tparseParam();", "-\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {", "-\t\t\t\t\t\t\t\t\t\t\tparseThrows();", "-\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE)) {", "-\t\t\t\t\t\t\t\t\t\t\tparseSee();", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "-\t\t\t\t\t\t\t\t\t\tparseReturn();", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamethrows :", "-\t\t\t\t\t\t\t\t\t\tparseThrows();", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase '\\r':", "+\t\t\t\t\t\tcase '\\n':", "+\t\t\t\t\t\t\tthis.lineStarted = false;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase '}' :", "+\t\t\t\t\t\t\tif (this.inlineTagStarted) this.inlineTagStarted = false;", "+\t\t\t\t\t\t\tthis.lineStarted = true;", "+\t\t\t\t\t\t\tcharPosition = previousPosition;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase '{' :", "+\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "+\t\t\t\t\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidTag(inlineStartPosition, this.index);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tinlineStartPosition = previousPosition;", "-\t\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcharPosition = previousPosition;", "-\t\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) {", "-\t\t\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\t\tcharPosition = previousPosition;", "+\t\t\t\t\t\t\tif (!this.lineStarted && !CharOperation.isWhitespace(nextCharacter)) {", "+\t\t\t\t\t\t\t\tthis.lineStarted = true;", "+\t\t\t} else {", "+\t\t\t\t// Init javadoc if necessary", "+\t\t\t\tif (this.sourceParser.options.getSeverity(CompilerOptions.MissingJavadocComments) != ProblemSeverities.Ignore) {", "+\t\t\t\t\tthis.javadoc = new Javadoc(javadocStart, javadocEnd);", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.javadoc = null;", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// Parse comment", "+\t\t\t\tint firstLineNumber = this.sourceParser.scanner.getLineNumber(javadocStart);", "+\t\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(javadocEnd);", "+\t", "+\t\t\t\t// scan line per line, since tags must be at beginning of lines only", "+\t\t\t\tnextLine : for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "+\t\t\t\t\tint lineStart = line == firstLineNumber", "+\t\t\t\t\t\t\t? javadocStart + 3 // skip leading /**", "+\t\t\t\t\t\t\t: this.sourceParser.scanner.getLineStart(line);", "+\t\t\t\t\tthis.index = lineStart;", "+\t\t\t\t\tthis.lineEnd = line == lastLineNumber", "+\t\t\t\t\t\t\t? javadocEnd - 2 // remove trailing * /", "+\t\t\t\t\t\t\t: this.sourceParser.scanner.getLineEnd(line);", "+\t\t\t\t\twhile (this.index < this.lineEnd) {", "+\t\t\t\t\t\tchar nextCharacter = readChar(); // consider unicodes", "+\t\t\t\t\t\tif  (nextCharacter == '@' &&", "+\t\t\t\t\t\t\t(readChar() == 'd') &&", "+\t\t\t\t\t\t\t(readChar() == 'e') &&", "+\t\t\t\t\t\t\t(readChar() == 'p') &&", "+\t\t\t\t\t\t\t(readChar() == 'r') &&", "+\t\t\t\t\t\t\t(readChar() == 'e') &&", "+\t\t\t\t\t\t\t(readChar() == 'c') &&", "+\t\t\t\t\t\t\t(readChar() == 'a') &&", "+\t\t\t\t\t\t\t(readChar() == 't') &&", "+\t\t\t\t\t\t\t(readChar() == 'e') &&", "+\t\t\t\t\t\t\t(readChar() == 'd'))", "+\t\t\t\t\t\t{", "+\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "+\t\t\t\t\t\t\tnextCharacter = readChar();", "+\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39088a6ee514efb1ff54001aa2e37c8d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "9ca09d5ed1be915e478e63cfb298cfaff9af7f75", "commitAfterChange": "264dd88468cd014ae7150e1040d5982ca933b94b", "methodNumberBeforeChange": 59, "methodNumberAfterChange": 59, "signatureBeforeChange": " \tprivate void printCodeSnippet(int startPosition, int endPosition)", "signatureAfterChange": " \tprivate void printCodeSnippet(int startPosition, int endPosition, int linesGap)", "diff": ["-\tprivate void printCodeSnippet(int startPosition, int endPosition) {", "+\tprivate void printCodeSnippet(int startPosition, int endPosition, int linesGap) {", "-", "+\t", "-\t\tILineTracker tracker= new DefaultLineTracker();", "-\t\tString contentPrefix= IJavaDocTagConstants.JAVADOC_STAR;", "-", "+\t\tint firstLine = Util.getLineNumber(startPosition, this.lineEnds, 0, this.maxLines) - 1;", "+\t\tint lastLine = Util.getLineNumber(endPosition, this.lineEnds, firstLine>1 ? firstLine-2 : 0, this.maxLines) - 1;", "-\t\tinputBuffer.setLength(0);", "-\t\tinputBuffer.append(snippet);", "-\t\ttracker.set(snippet);", "-\t\tfor (int lines= tracker.getNumberOfLines() - 1; lines > 0; lines--) {", "-\t\t\tint lineOffset;", "-\t\t\ttry {", "-\t\t\t\tlineOffset= tracker.getLineOffset(lines);", "-\t\t\t} catch (BadLocationException e) {", "-\t\t\t\t// should not happen", "-\t\t\t\tCommentFormatterUtil.log(e);", "-\t\t\t\treturn;", "+\t\tif (firstLine == lastLine && linesGap == 0) {", "+\t\t\tinputBuffer.append(snippet);", "+\t\t} else {", "+\t\t\tboolean hasCharsAfterStar = false;", "+\t\t\tif (linesGap == 0) {", "+\t\t\t\tinputBuffer.append(this.scanner.source, startPosition, this.lineEnds[firstLine]+1-startPosition);", "+\t\t\t\tfirstLine++;", "-\t\t\tint prefixOffset = inputBuffer.indexOf(contentPrefix, lineOffset);", "-\t\t\tif (prefixOffset >= 0 && inputBuffer.substring(lineOffset, prefixOffset).trim().length() == 0) {", "-\t\t\t\tint offsetEnd = prefixOffset + 1;", "-\t\t\t\tchar ch = inputBuffer.charAt(offsetEnd);", "-\t\t\t\tswitch (ch) {", "-\t\t\t\t\tcase '\\n':", "-\t\t\t\t\tcase '\\r':", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase ' ':", "-\t\t\t\t\tcase '\\t':", "-\t\t\t\t\tcase '\\u000c' :    /* FORM FEED               */", "-\t\t\t\t\t\toffsetEnd++;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\tif (ScannerHelper.isWhitespace(ch)) {", "-\t\t\t\t\t\t\toffsetEnd++;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "+\t\t\tint initialLength = inputBuffer.length();", "+\t\t\tfor (int currentLine=firstLine; currentLine<=lastLine; currentLine++) {", "+\t\t\t\tthis.scanner.resetTo(this.lineEnds[currentLine-1]+1, this.lineEnds[currentLine]);", "+\t\t\t\tint lineStart = this.scanner.currentPosition;", "+\t\t\t\tboolean hasStar = false;", "+\t\t\t\tloop: while (!this.scanner.atEnd()) {", "+\t\t\t\t\tchar ch = (char) this.scanner.getNextChar();", "+\t\t\t\t\tswitch (ch) {", "+\t\t\t\t\t\tcase ' ':", "+\t\t\t\t\t\tcase '\\t' :", "+\t\t\t\t\t\tcase '\\u000c' :", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase '\\r' :", "+\t\t\t\t\t\tcase '\\n' :", "+\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\tcase '*':", "+\t\t\t\t\t\t\thasStar = true;", "+\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\tif (ScannerHelper.isWhitespace(ch)) {", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t}", "-\t\t\t\tinputBuffer.delete(lineOffset, offsetEnd);", "+\t\t\t\tif (hasStar) {", "+\t\t\t\t\tlineStart = this.scanner.currentPosition;", "+\t\t\t\t\tif (!hasCharsAfterStar && !this.scanner.atEnd()) {", "+\t\t\t\t\t\tchar ch = (char) this.scanner.getNextChar();", "+\t\t\t\t\t\tboolean atEnd = this.scanner.atEnd();", "+\t\t\t\t\t\tswitch (ch) {", "+\t\t\t\t\t\t\tcase ' ':", "+\t\t\t\t\t\t\tcase '\\t' :", "+\t\t\t\t\t\t\tcase '\\u000c' :", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase '\\r' :", "+\t\t\t\t\t\t\tcase '\\n' :", "+\t\t\t\t\t\t\t\tatEnd = true;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\tif (!ScannerHelper.isWhitespace(ch)) {", "+\t\t\t\t\t\t\t\t\tif (hasStar) {", "+\t\t\t\t\t\t\t\t\t\t// A non whitespace character is just after the star", "+\t\t\t\t\t\t\t\t\t\t// then we need to restart from the beginning without", "+\t\t\t\t\t\t\t\t\t\t// consuming the space after the star", "+\t\t\t\t\t\t\t\t\t\thasCharsAfterStar = true;", "+\t\t\t\t\t\t\t\t\t\tcurrentLine = firstLine-1;", "+\t\t\t\t\t\t\t\t\t\tinputBuffer.setLength(initialLength);", "+\t\t\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (!hasCharsAfterStar && !atEnd) {", "+\t\t\t\t\t\t\t// Until then, there's always a whitespace after each star", "+\t\t\t\t\t\t\t// of the comment, hence we need to consume it as it will", "+\t\t\t\t\t\t\t// be rewritten while reindenting the snippet lines", "+\t\t\t\t\t\t\tlineStart = this.scanner.currentPosition;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tint end = currentLine == lastLine ? endPosition : this.lineEnds[currentLine];", "+\t\t\t\tinputBuffer.append(this.scanner.source, lineStart, end+1-lineStart);", "-", "+\t", "-\t\tchar[] buf= new char[snippet.length()]; // html2text never gets longer, only shorter!", "+\t\tchar[] buf= new char[inputBuffer.length()]; // html2text never gets longer, only shorter!", "-", "+\t", "-", "+\t", "-", "+\t", "-\t\ttracker = new DefaultLineTracker();", "+\t\tILineTracker tracker = new DefaultLineTracker();", "-\t\toutputBuffer.append(formattedSnippet);", "-\t\ttracker.set(outputBuffer.toString());", "-\t\tfor (int lines=tracker.getNumberOfLines() - 1; lines > 0; lines--) {", "-\t\t\ttry {", "-\t\t\t\toutputBuffer.insert(tracker.getLineOffset(lines), linePrefix);", "-\t\t\t} catch (BadLocationException e) {", "-\t\t\t\t// should not happen", "-\t\t\t\tCommentFormatterUtil.log(e);", "-\t\t\t\treturn;", "+\t\tString replacement = formattedSnippet;", "+\t\ttracker.set(formattedSnippet);", "+\t\tint numberOfLines = tracker.getNumberOfLines();", "+\t\tif (numberOfLines > 1) {", "+\t\t\tint lastLineOffset = -1;", "+\t\t\tfor (int i=0; i<numberOfLines-1; i++) {", "+\t\t\t\tif (i>0) outputBuffer.append(linePrefix);", "+\t\t\t\ttry {", "+\t\t\t\t\tlastLineOffset = tracker.getLineOffset(i+1);", "+\t\t\t\t\toutputBuffer.append(formattedSnippet.substring(tracker.getLineOffset(i), lastLineOffset));", "+\t\t\t\t} catch (BadLocationException e) {", "+\t\t\t\t\t// should not happen", "+\t\t\t\t\tCommentFormatterUtil.log(e);", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\toutputBuffer.append(linePrefix);", "+\t\t\toutputBuffer.append(formattedSnippet.substring(lastLineOffset));", "+\t\t\treplacement = outputBuffer.toString();", "-", "+\t", "-\t\taddReplaceEdit(startPosition, endPosition, outputBuffer.toString());", "+\t\taddReplaceEdit(startPosition, endPosition, replacement);"]}], "num": 50681}