{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "951403137f645f43f6e5f2c3eaa956a7", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "01cd37c6801621d6eb2e0b01fb08f0e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoubleLiteral.java", "commitBeforeChange": "464f6cfbc4d7c79e3b0be7d1378b5d3f2b61c7f8", "commitAfterChange": "70954c7e4ef90552afbd3c4b7199bb0a07ca0943", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public void computeConstant()", "signatureAfterChange": " \tpublic void computeConstant()", "diff": ["-}", "-public void computeConstant() {", "+\t}", "+\tpublic void computeConstant() {", "+\t\t//the source is correctly formated so the exception should never occurs", "+\t\tDouble computedValue;", "+\t\ttry {", "+\t\t\tcomputedValue = Double.valueOf(String.valueOf(source));", "+\t\t} catch (NumberFormatException e) {", "+\t\t\t/*", "+\t\t\t * this can happen if this is an hexadecimal floating-point literal and the libraries used ", "+\t\t\t * are < 1.5", "+\t\t\t */", "+\t\t\tcomputedValue = new Double(Util.getFloatingPoint(source));", "+\t\t}", "-\t//the source is correctly formated so the exception should never occurs", "-", "-\tDouble computedValue;", "-\ttry { computedValue = Double.valueOf(String.valueOf(source));}", "-\tcatch(NumberFormatException e){return ;} //how can it happen ????", "-", "-\tif (computedValue.doubleValue() > Double.MAX_VALUE) return ; //may be Infinity", "-\tif (computedValue.doubleValue() < Double.MIN_VALUE)", "-\t{\t//only a true 0 can be made of zeros", "-\t\t//2.00000000000000000e-324 is illegal .... ", "-\t\tlabel :", "-\t\t\tfor (int i=0;i<source.length;i++)", "-\t\t\t{\t//it is welled formated so just test against '0' and potential . D d  ", "-\t\t\t\tswitch (source[i]){", "+\t\tfinal double doubleValue = computedValue.doubleValue();", "+\t\tif (doubleValue > Double.MAX_VALUE)", "+\t\t\treturn; //may be Infinity", "+\t\tif (doubleValue < Double.MIN_VALUE) { //only a true 0 can be made of zeros", "+\t\t\t//2.00000000000000000e-324 is illegal .... ", "+\t\t\tlabel : for (int i = 0; i < source.length; i++) { //it is welled formated so just test against '0' and potential . D d  ", "+\t\t\t\tswitch (source[i]) {", "-\t\t\t\t\tcase 'D' : break ;", "-\t\t\t\t\tcase 'e' : ", "-\t\t\t\t\tcase 'E' : break label ; //exposant are valid....!", "-\t\t\t\t\tdefault  : return;}}} //error", "+\t\t\t\t\tcase 'D' :", "+\t\t\t\t\tcase 'x' :", "+\t\t\t\t\tcase 'X' :", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase 'e' :", "+\t\t\t\t\tcase 'E' :", "+\t\t\t\t\tcase 'p' :", "+\t\t\t\t\tcase 'P' :", "+\t\t\t\t\t\tbreak label; //exposant are valid....!", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} //error", "-\tconstant = Constant.fromValue(value = computedValue.doubleValue());}", "+\t\tconstant = Constant.fromValue(value = doubleValue);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0f8fb65986897c9a32c826d91205d7b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FloatLiteral.java", "commitBeforeChange": "464f6cfbc4d7c79e3b0be7d1378b5d3f2b61c7f8", "commitAfterChange": "70954c7e4ef90552afbd3c4b7199bb0a07ca0943", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public void computeConstant()", "signatureAfterChange": " \tpublic void computeConstant()", "diff": ["-}", "-public void computeConstant() {", "-", "-\t//the source is correctly formated so the exception should never occurs", "-", "-\tFloat computedValue;", "-\ttry {", "-\t\tcomputedValue = Float.valueOf(String.valueOf(source));", "-\t} catch (NumberFormatException e) {", "-\t\treturn;", "-\t} ", "-", "-\tif (computedValue.doubleValue() > Float.MAX_VALUE){", "-\t\treturn; //may be Infinity", "-\tif (computedValue.floatValue() < Float_MIN_VALUE){", "-\t\t// see 1F6IGUU", "-\t\t//only a true 0 can be made of zeros", "-\t\t//1.00000000e-46f is illegal ....", "-\t\tlabel : for (int i = 0; i < source.length; i++) { ", "-\t\t\tswitch (source[i]) {", "-\t\t\t\tcase '.' :", "-\t\t\t\tcase 'f' :", "-\t\t\t\tcase 'F' :", "-\t\t\t\tcase '0' :", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase 'e' :", "-\t\t\t\tcase 'E' :", "-\t\t\t\t\tbreak label; //exposant are valid !....", "-\t\t\t\tdefault :", "-\t\t\t\t\treturn; //error", "+\tpublic void computeConstant() {", "+\t\t//the source is correctly formated so the exception should never occurs", "+\t\tFloat computedValue;", "+\t\ttry {", "+\t\t\tcomputedValue = Float.valueOf(String.valueOf(source));", "+\t\t} catch (NumberFormatException e) {", "+\t\t\t/*", "+\t\t\t * this can happen if this is an hexadecimal floating-point literal and the libraries used ", "+\t\t\t * are < 1.5", "+\t\t\t */", "+\t\t\tcomputedValue = new Float(Util.getFloatingPoint(source));", "+\t\t}", "+", "+\t\tif (computedValue.doubleValue() > Float.MAX_VALUE) {", "+\t\t\treturn; //may be Infinity", "+\t\t}", "+\t\tif (computedValue.floatValue() < Float_MIN_VALUE) {", "+\t\t\t// see 1F6IGUU", "+\t\t\t//only a true 0 can be made of zeros", "+\t\t\t//1.00000000e-46f is illegal ....", "+\t\t\tlabel : for (int i = 0; i < source.length; i++) {", "+\t\t\t\tswitch (source[i]) {", "+\t\t\t\t\tcase '.' :", "+\t\t\t\t\tcase 'f' :", "+\t\t\t\t\tcase 'F' :", "+\t\t\t\t\tcase '0' :", "+\t\t\t\t\tcase 'x' :", "+\t\t\t\t\tcase 'X' :", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase 'e' :", "+\t\t\t\t\tcase 'E' :", "+\t\t\t\t\tcase 'p' :", "+\t\t\t\t\tcase 'P' :", "+\t\t\t\t\t\tbreak label; //exposant are valid !....", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\treturn; //error", "+\t\t\t\t}", "+\t\tconstant = Constant.fromValue(value = computedValue.floatValue());", "-\tconstant = Constant.fromValue(value = computedValue.floatValue());", "-}"]}], "num": 37781}