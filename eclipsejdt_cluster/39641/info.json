{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "46ad95cd10835ffebf9d4e2f8260d328", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "277d3183bf230ae4e6fe2c7567c4d87b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java", "commitBeforeChange": "b8f31731e75965ced53a2b2bb7747f2f3f0bdc77", "commitAfterChange": "90b243491d35267d13bcf8f4b3b622ed87af2ae7", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " \tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, int nullStatus, CheckMode mode)", "signatureAfterChange": " \tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, int nullStatus, CheckMode mode)", "diff": ["-\t\t\t\t\t\tif (providedDimsTagBits == null) {", "-\t\t\t\t\t\t\tseverity = 1; // required is annotated, provided not, need unchecked conversion", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tfor (int i=0; i<=dims; i++) {", "-\t\t\t\t\t\t\t\tlong requiredBits = validNullTagBits(requiredDimsTagBits[i]);", "-\t\t\t\t\t\t\t\tlong providedBits = validNullTagBits(providedDimsTagBits[i]);", "-\t\t\t\t\t\t\t\tif (i > 0)", "-\t\t\t\t\t\t\t\t\tnullStatus = -1; // don't use beyond the outermost dimension", "-\t\t\t\t\t\t\t\tseverity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, nullStatus, mode == CheckMode.OVERRIDE));", "-\t\t\t\t\t\t\t\tif (severity == 2)", "-\t\t\t\t\t\t\t\t\treturn NullAnnotationMatching.NULL_ANNOTATIONS_MISMATCH;", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (providedDimsTagBits == null)", "+\t\t\t\t\t\t\tprovidedDimsTagBits = new long[dims+1]; // set to unspec'd at all dimensions", "+\t\t\t\t\t\tfor (int i=0; i<=dims; i++) {", "+\t\t\t\t\t\t\tlong requiredBits = validNullTagBits(requiredDimsTagBits[i]);", "+\t\t\t\t\t\t\tlong providedBits = validNullTagBits(providedDimsTagBits[i]);", "+\t\t\t\t\t\t\tif (i > 0)", "+\t\t\t\t\t\t\t\tnullStatus = -1; // don't use beyond the outermost dimension", "+\t\t\t\t\t\t\tseverity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, nullStatus, mode == CheckMode.OVERRIDE && nullStatus == -1));", "+\t\t\t\t\t\t\tif (severity == 2)", "+\t\t\t\t\t\t\t\treturn NullAnnotationMatching.NULL_ANNOTATIONS_MISMATCH;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9d07a8d245ed46f9c31f668e277b276", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java", "commitBeforeChange": "6b8ea1fe34801155ff098e297d8447ae3bdf9761", "commitAfterChange": "a12821fa8f0e23855d8771487235dddff394d6b5", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, Substitution substitution, int nullStatus, CheckMode mode)", "signatureAfterChange": " \tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, Substitution substitution, int nullStatus, CheckMode mode)", "diff": ["-\t\t\t\t\t\t\tif (i > 0)", "-\t\t\t\t\t\t\t\tcurrentNullStatus = -1; // don't use beyond the outermost dimension", "-\t\t\t\t\t\t\tseverity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, currentNullStatus, i == 0 ? mode : mode.toDetail(), false));", "-\t\t\t\t\t\t\tif (severity == 2)", "-\t\t\t\t\t\t\t\treturn NullAnnotationMatching.NULL_ANNOTATIONS_MISMATCH;", "+\t\t\t\t\t\t\tif (i == 0 && requiredBits == TagBits.AnnotationNullable && nullStatus != -1 && mode.requiredNullableMatchesAll()) {", "+\t\t\t\t\t\t\t\t// toplevel nullable array: no need to check ", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (i > 0)", "+\t\t\t\t\t\t\t\t\tcurrentNullStatus = -1; // don't use beyond the outermost dimension", "+\t\t\t\t\t\t\t\tseverity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, currentNullStatus, i == 0 ? mode : mode.toDetail(), false));", "+\t\t\t\t\t\t\t\tif (severity == 2)", "+\t\t\t\t\t\t\t\t\treturn NullAnnotationMatching.NULL_ANNOTATIONS_MISMATCH;", "+\t\t\t\t\t\t\t}", "-\t\t\t\tif (requiredBits != TagBits.AnnotationNullable // nullable lhs accepts everything, ...", "-\t\t\t\t\t\t|| nullStatus == -1) // only at detail/recursion even nullable must be matched exactly", "-\t\t\t\t{", "+\t\t\t\tif (requiredBits == TagBits.AnnotationNullable && nullStatus != -1 && mode.requiredNullableMatchesAll()) {", "+\t\t\t\t\t// at toplevel (having a nullStatus) nullable matches all", "+\t\t\t\t} else {"]}], "num": 39641}