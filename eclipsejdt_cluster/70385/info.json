{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c33ea00b3f4f508402d7d4946e027999", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "54f7df3c6c3e76047c200137e481b2fc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes, Scope scope)", "signatureAfterChange": " \tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding method, TypeBinding[] argumentTypes, BlockScope scope)", "diff": ["-\tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes, Scope scope) {", "-\t\tif (!invocation.innersNeedUpdate())", "+\tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding method, TypeBinding[] argumentTypes, BlockScope scope) {", "+\t\tMethodBinding candidateMethod = method.isValidBinding() ? method : method instanceof ProblemMethodBinding ? ((ProblemMethodBinding) method).closestMatch : null;", "+\t\tif (candidateMethod == null)", "-\t\tint problemReason = 0;", "-\t\tMethodBinding candidateMethod;", "-\t\tif (methodBinding.isValidBinding()) {", "-\t\t\tcandidateMethod = methodBinding;", "-\t\t} else if (methodBinding instanceof ProblemMethodBinding) {", "-\t\t\tproblemReason = methodBinding.problemId();", "-\t\t\tcandidateMethod = ((ProblemMethodBinding) methodBinding).closestMatch;", "-\t\t} else {", "-\t\t\tcandidateMethod = null;", "-\t\t}", "-\t\tif (candidateMethod != null) {", "-\t\t\tboolean variableArity = candidateMethod.isVarargs();", "-\t\t\tInferenceContext18 infCtx = null;", "-\t\t\tif (candidateMethod instanceof ParameterizedMethodBinding) {", "-\t\t\t\tinfCtx = invocation.getInferenceContext((ParameterizedMethodBinding) candidateMethod);", "-\t\t\t\tif (infCtx != null) {", "-\t\t\t\t\tif (infCtx.stepCompleted != InferenceContext18.TYPE_INFERRED) {", "-\t\t\t\t\t\t// only work in the exact state of TYPE_INFERRED", "-\t\t\t\t\t\t// - below we're not yet ready", "-\t\t\t\t\t\t// - above we're already done-done", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\t}", "-\t\t\t\t\tvariableArity &= infCtx.isVarArgs(); // TODO: if no infCtx is available, do we have to re-check if this is a varargs invocation?", "-\t\t\t\t}", "-\t\t\t} else if (invocation instanceof AllocationExpression) {", "-\t\t\t\tif (((AllocationExpression)invocation).suspendedResolutionState != null)", "-\t\t\t\t\treturn; // not yet ready", "-\t\t\t}", "-\t\t\t", "-\t\t\tfinal TypeBinding[] parameters = candidateMethod.parameters;", "-\t\t\tExpression[] innerArguments = invocation.arguments();", "-\t\t\tExpression [] arguments = innerArguments;", "-\t\t\tif (infCtx == null && variableArity && arguments != null && parameters.length == arguments.length) { // re-check", "-\t\t\t\tTypeBinding lastParam = parameters[parameters.length-1];", "-\t\t\t\tExpression lastArg = arguments[arguments.length-1];", "-\t\t\t\tif (lastArg.isCompatibleWith(lastParam, null)) {", "-\t\t\t\t\tvariableArity = false;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tfor (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {", "-\t\t\t\tExpression argument = arguments[i];", "-\t\t\t\tTypeBinding updatedArgumentType = null;", "-\t\t\t\tTypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);", "-\t\t\t\tif (parameterType == null && problemReason != ProblemReasons.NoError)", "-\t\t\t\t\tcontinue; // not much we can do without a target type, assume it only happens after some resolve error", "-", "-\t\t\t\tif (argument instanceof LambdaExpression && ((LambdaExpression) argument).hasErrors())", "-\t\t\t\t\tcontinue; // don't update if inner poly has errors", "-", "-\t\t\t\tif (argument instanceof Invocation) {", "-\t\t\t\t\tInvocation innerInvocation = (Invocation)argument;", "-\t\t\t\t\tMethodBinding binding = innerInvocation.binding(parameterType, true, scope);", "-\t\t\t\t\tif (binding instanceof ParameterizedGenericMethodBinding) {", "-\t\t\t\t\t\tParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) binding;", "-\t\t\t\t\t\tInferenceContext18 innerContext = innerInvocation.getInferenceContext(parameterizedMethod);", "-\t\t\t\t\t\tif (innerContext != null) {", "-\t\t\t\t\t\t\tif (!innerContext.hasResultFor(parameterType)) {", "-\t\t\t\t\t\t\t\targument.setExpectedType(parameterType);", "-\t\t\t\t\t\t\t\tMethodBinding improvedBinding = innerContext.inferInvocationType(innerInvocation, parameterizedMethod);", "-\t\t\t\t\t\t\t\tif (!improvedBinding.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tinnerContext.reportInvalidInvocation(innerInvocation, improvedBinding);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (innerInvocation.updateBindings(improvedBinding, parameterType)) {", "-\t\t\t\t\t\t\t\t\tresolvePolyExpressionArguments(innerInvocation, improvedBinding, scope);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (innerContext.stepCompleted < InferenceContext18.BINDINGS_UPDATED) {", "-\t\t\t\t\t\t\t\tinnerContext.rebindInnerPolies(parameterizedMethod, innerInvocation);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcontinue; // otherwise these have been dealt with during inner method lookup", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\tif (argument.isPolyExpression()) {", "-\t\t\t\t\t// poly expressions in an invocation context may need to be resolved now:", "-\t\t\t\t\tif (infCtx != null && infCtx.stepCompleted == InferenceContext18.BINDINGS_UPDATED)", "-\t\t\t\t\t\tupdatedArgumentType = argument.resolvedType; // in this case argument was already resolved via InferenceContext18.acceptPendingPolyArguments()", "-\t\t\t\t\telse", "-\t\t\t\t\t\tupdatedArgumentType = argument.checkAgainstFinalTargetType(parameterType, scope);", "-", "-\t\t\t\t\tif (problemReason == ProblemReasons.NoError // preserve errors", "-\t\t\t\t\t\t\t&& updatedArgumentType != null\t\t\t\t\t// do we have a relevant update? ...", "-\t\t\t\t\t\t\t&& !(updatedArgumentType instanceof PolyTypeBinding))", "-\t\t\t\t\t{", "-\t\t\t\t\t\t// update the argumentTypes array (supposed to be owned by the calling method)", "-\t\t\t\t\t\t// in order to give better information for subsequent checks", "-\t\t\t\t\t\targumentTypes[i] = updatedArgumentType;", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\tboolean variableArity = candidateMethod.isVarargs();", "+\t\tfinal TypeBinding[] parameters = candidateMethod.parameters;", "+\t\tExpression[] arguments = invocation.arguments();", "+\t\tif (variableArity && arguments != null && parameters.length == arguments.length) {", "+\t\t\tif (arguments[arguments.length-1].isCompatibleWith(parameters[parameters.length-1], scope)) {", "+\t\t\t\tvariableArity = false;", "-\t\tinvocation.innerUpdateDone();", "-\t}", "+\t\tfor (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {", "+\t\t\tExpression argument = arguments[i];", "+\t\t\tTypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);", "+\t\t\tif (parameterType == null)", "+\t\t\t\tcontinue; // not much we can do without a target type, assume it only happens after some resolve error", "+\t\t\tif (argumentTypes[i].isPolyType()) {", "+\t\t\t\targument.setExpectedType(parameterType);", "+\t\t\t\tTypeBinding updatedArgumentType = argument.resolveType(scope); ", "+\t\t\t\tif (argument instanceof LambdaExpression) {", "+\t\t\t\t\t// LE.resolveType may return a valid binding because resolve does not detect structural errors at this point.", "+\t\t\t\t\tLambdaExpression lambda = (LambdaExpression) argument;", "+\t\t\t\t\tif (!lambda.isCompatibleWith(parameterType, scope) || lambda.hasErrors())", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tif (updatedArgumentType != null && updatedArgumentType.kind() != Binding.POLY_TYPE)", "+\t\t\t\t\targumentTypes[i] = updatedArgumentType;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ab76315c0f0f2d08fa4480b47afe4fd9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "b9c215c1a0014055731b42921e6d8437fe5d1c30", "commitAfterChange": "cf30dcc5cf110d772b62d35f57e0c35d494f0e46", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic static void checkInvocationArguments(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding method, Expression[] arguments, TypeBinding[] argumentTypes, boolean argsContainCast, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static void checkInvocationArguments(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding method, Expression[] arguments, TypeBinding[] argumentTypes, boolean argsContainCast, InvocationSite invocationSite)", "diff": ["-\t\tboolean isRawMemberInvocation = !method.isStatic() && !receiverType.isUnboundWildcard() && method.declaringClass.isRawType() && method.hasSubstitutedParameters();", "+\t\tint paramLength = params.length;", "+\t\tboolean isRawMemberInvocation = !method.isStatic() && !receiverType.isUnboundWildcard() && method.declaringClass.isRawType() && (method.hasSubstitutedParameters() || method.hasSubstitutedReturnType());", "-\t\t\t\tif (((ParameterizedGenericMethodBinding)method).isRaw && method.hasSubstitutedParameters()) {", "+\t\t\t\tif (((ParameterizedGenericMethodBinding)method).isRaw && (method.hasSubstitutedParameters() || method.hasSubstitutedReturnType())) {", "-\t\tif (method.isVarargs()) {", "-\t\t\t// 4 possibilities exist for a call to the vararg method foo(int i, long ... value) : foo(1), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new long[] {1, 2})", "-\t\t\tint lastIndex = params.length - 1;", "-\t\t\tfor (int i = 0; i < lastIndex; i++) {", "-\t\t\t\tTypeBinding originalRawParam = rawOriginalGenericMethod == null ? null : rawOriginalGenericMethod.parameters[i];", "-\t\t\t    if (checkInvocationArgument(scope, arguments[i], params[i] , argumentTypes[i], originalRawParam)) {", "-\t\t\t\t    unsafeWildcardInvocation = true;", "-\t\t\t    }", "-\t\t\t}", "-\t\t   int argLength = arguments.length;", "-\t\t   if (lastIndex < argLength) { // vararg argument was provided", "-\t\t\t   \tTypeBinding parameterType = params[lastIndex];", "-\t\t\t\tTypeBinding originalRawParam = null;", "-", "-\t\t\t    if (params.length != argLength || parameterType.dimensions() != argumentTypes[lastIndex].dimensions()) {", "-\t\t\t    \tparameterType = ((ArrayBinding) parameterType).elementsType(); // single element was provided for vararg parameter", "-\t\t\t\t\toriginalRawParam = rawOriginalGenericMethod == null ? null : ((ArrayBinding)rawOriginalGenericMethod.parameters[lastIndex]).elementsType();", "-\t\t\t    }", "-\t\t\t\tfor (int i = lastIndex; i < argLength; i++) {", "-\t\t\t\t    if (checkInvocationArgument(scope, arguments[i], parameterType, argumentTypes[i], originalRawParam))", "+\t\tif (arguments != null) {", "+\t\t\tif (method.isVarargs()) {", "+\t\t\t\t// 4 possibilities exist for a call to the vararg method foo(int i, long ... value) : foo(1), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new long[] {1, 2})", "+\t\t\t\tint lastIndex = paramLength - 1;", "+\t\t\t\tfor (int i = 0; i < lastIndex; i++) {", "+\t\t\t\t\tTypeBinding originalRawParam = rawOriginalGenericMethod == null ? null : rawOriginalGenericMethod.parameters[i];", "+\t\t\t\t    if (checkInvocationArgument(scope, arguments[i], params[i] , argumentTypes[i], originalRawParam)) {", "+\t\t\t\t\t    unsafeWildcardInvocation = true;", "+\t\t\t\t    }", "+\t\t\t\t}", "+\t\t\t   int argLength = arguments.length;", "+\t\t\t   if (lastIndex < argLength) { // vararg argument was provided", "+\t\t\t\t   \tTypeBinding parameterType = params[lastIndex];", "+\t\t\t\t\tTypeBinding originalRawParam = null;", "+\t", "+\t\t\t\t    if (paramLength != argLength || parameterType.dimensions() != argumentTypes[lastIndex].dimensions()) {", "+\t\t\t\t    \tparameterType = ((ArrayBinding) parameterType).elementsType(); // single element was provided for vararg parameter", "+\t\t\t\t\t\toriginalRawParam = rawOriginalGenericMethod == null ? null : ((ArrayBinding)rawOriginalGenericMethod.parameters[lastIndex]).elementsType();", "+\t\t\t\t    }", "+\t\t\t\t\tfor (int i = lastIndex; i < argLength; i++) {", "+\t\t\t\t\t    if (checkInvocationArgument(scope, arguments[i], parameterType, argumentTypes[i], originalRawParam))", "+\t\t\t\t\t\t    unsafeWildcardInvocation = true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t", "+\t\t\t   if (paramLength == argumentTypes.length) { // 70056", "+\t\t\t\t\tint varargIndex = paramLength - 1;", "+\t\t\t\t\tArrayBinding varargType = (ArrayBinding) params[varargIndex];", "+\t\t\t\t\tTypeBinding lastArgType = argumentTypes[varargIndex];", "+\t\t\t\t\tif (lastArgType == NullBinding) {", "+\t\t\t\t\t\tif (!(varargType.leafComponentType().isBaseType() && varargType.dimensions() == 1))", "+\t\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "+\t\t\t\t\t} else if (varargType.dimensions <= lastArgType.dimensions()) {", "+\t\t\t\t\t\tint dimensions = lastArgType.dimensions();", "+\t\t\t\t\t\tif (lastArgType.leafComponentType().isBaseType())", "+\t\t\t\t\t\t\tdimensions--;", "+\t\t\t\t\t\tif (varargType.dimensions < dimensions)", "+\t\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "+\t\t\t\t\t\telse if (varargType.dimensions == dimensions && varargType.leafComponentType != lastArgType.leafComponentType())", "+\t\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tfor (int i = 0; i < paramLength; i++) {", "+\t\t\t\t\tTypeBinding originalRawParam = rawOriginalGenericMethod == null ? null : rawOriginalGenericMethod.parameters[i];", "+\t\t\t\t    if (checkInvocationArgument(scope, arguments[i], params[i], argumentTypes[i], originalRawParam))", "-", "-\t\t   if (method.parameters.length == argumentTypes.length) { // 70056", "-\t\t\t\tint varargIndex = method.parameters.length - 1;", "-\t\t\t\tArrayBinding varargType = (ArrayBinding) method.parameters[varargIndex];", "-\t\t\t\tTypeBinding lastArgType = argumentTypes[varargIndex];", "-\t\t\t\tif (lastArgType == NullBinding) {", "-\t\t\t\t\tif (!(varargType.leafComponentType().isBaseType() && varargType.dimensions() == 1))", "-\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "-\t\t\t\t} else if (varargType.dimensions <= lastArgType.dimensions()) {", "-\t\t\t\t\tint dimensions = lastArgType.dimensions();", "-\t\t\t\t\tif (lastArgType.leafComponentType().isBaseType())", "-\t\t\t\t\t\tdimensions--;", "-\t\t\t\t\tif (varargType.dimensions < dimensions)", "-\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "-\t\t\t\t\telse if (varargType.dimensions == dimensions && varargType.leafComponentType != lastArgType.leafComponentType())", "-\t\t\t\t\t\tscope.problemReporter().varargsArgumentNeedCast(method, lastArgType, invocationSite);", "-\t\t\t\t}", "+\t\t\tif (argsContainCast) {", "+\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, receiver, receiverType, method, arguments, argumentTypes, invocationSite);", "-\t\t} else {", "-\t\t\tfor (int i = 0, argLength = arguments.length; i < argLength; i++) {", "-\t\t\t\tTypeBinding originalRawParam = rawOriginalGenericMethod == null ? null : rawOriginalGenericMethod.parameters[i];", "-\t\t\t    if (checkInvocationArgument(scope, arguments[i], params[i], argumentTypes[i], originalRawParam))", "-\t\t\t\t    unsafeWildcardInvocation = true;", "-\t\t\t}", "-\t\t}", "-\t\tif (argsContainCast) {", "-\t\t\tCastExpression.checkNeedForArgumentCasts(scope, receiver, receiverType, method, arguments, argumentTypes, invocationSite);", "-\t\t} else if (!method.isStatic() && !receiverType.isUnboundWildcard() && method.declaringClass.isRawType() && method.hasSubstitutedParameters()) {", "+\t\t} else if (!method.isStatic() && !receiverType.isUnboundWildcard() && method.declaringClass.isRawType() && (method.hasSubstitutedParameters() || method.hasSubstitutedReturnType())) {"]}], "num": 70385}