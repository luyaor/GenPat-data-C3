{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8b30e6545ab0f9df7f53a921b8c15cf9", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "06bdd71105d65b1576a3141d1ce7377c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptCompilationParticipant.java", "commitBeforeChange": "2894ba75386697d7bf484434d073fb6ffaf6cec9", "commitAfterChange": "c5ef0e6fd93c55fc5204e498f5b58ab9f95c6ab7", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t\t \tprivate CompilationParticipantResult preBuildNotify( PreBuildCompilationEvent pbce )", "signatureAfterChange": " \t \tpublic void processAnnotations(ICompilationParticipantResult[] filesWithAnnotations, boolean isBatchBuild)", "diff": ["-\t\t", "-\tprivate CompilationParticipantResult preBuildNotify( PreBuildCompilationEvent pbce )", "-\t{\t\t", "-\t\tif ( pbce == null )", "-\t\t\treturn EMPTY_PRE_BUILD_COMPILATION_RESULT;", "-", "-\t\tIFile[] buildFiles = pbce.getFiles();", "-\t\tIJavaProject javaProject = pbce.getJavaProject();", "-\t\t", "-\t\tif ( buildFiles == null || buildFiles.length == 0 )", "-\t\t\treturn EMPTY_PRE_BUILD_COMPILATION_RESULT;", "-\t\t", "+\t", "+\tpublic void processAnnotations(ICompilationParticipantResult[] filesWithAnnotations, boolean isBatchBuild) {", "+\t\tif( filesWithAnnotations == null || filesWithAnnotations.length == 0 )", "+\t\t\treturn;", "+\t\tfinal IProject project = filesWithAnnotations[0].getFile().getProject();", "+\t\tfinal IJavaProject javaProject = JavaCore.create(project);", "-\t\tString javaVersion = javaProject.getOption(\"org.eclipse.jdt.core.compiler.source\", true); //$NON-NLS-1$", "-\t\t", "+\t\tString javaVersion = javaProject.getOption(\"org.eclipse.jdt.core.compiler.source\", true); //$NON-NLS-1$\t\t", "-\t\t\treturn EMPTY_PRE_BUILD_COMPILATION_RESULT;", "+\t\t\treturn;", "-\t", "-\t\t// If we're in batch mode, we need to reset the classloaders", "-\t\t// for the batch processors before we begin", "-\t\tboolean isFullBuild = pbce.isFullBuild();", "+\t\t", "-\t\t\tif (isFullBuild && pbce.getRound() == 0) {", "-\t\t\t\tAnnotationProcessorFactoryLoader.getLoader().resetBatchProcessors(pbce.getJavaProject());", "+\t\t\tif (isBatchBuild && _buildRound == 0 ) {", "+\t\t\t\tAnnotationProcessorFactoryLoader.getLoader().resetBatchProcessors(javaProject);", "-\t\t\t", "+\t\t", "-\t\t\tAPTResult result = APTDispatch.runAPTDuringBuild(factories, _previousRoundsBatchFactories, buildFiles, javaProject, isFullBuild);", "-\t\t\tSet<IFile> newFiles = result.getNewFiles();\t\t\t", "-\t\t\tSet<IFile> deletedFiles = new HashSet<IFile>();", "-\t\t\t_previousRoundsBatchFactories.addAll(result.getDispatchedBatchFactory());", "-\t\t\t", "-\t\t\t// for apt, new files will always trump deleted files", "-\t\t\tfor ( IFile df : result.getDeletedFiles() ){", "-\t\t\t\tif ( !newFiles.contains( df ) ){", "-\t\t\t\t\tdeletedFiles.add(df);", "-\t\t\t\t}", "-\t\t\t}", "-\t", "-\t\t\treturn new PreBuildCompilationResult( ", "-\t\t\t\t\tnewFiles.toArray( new IFile[ newFiles.size() ] ), ", "-\t\t\t\t\tdeletedFiles.toArray( new IFile[ deletedFiles.size() ] ), ", "-\t\t\t\t\tresult.getNewDependencies(), ", "-\t\t\t\t\tresult.getProblems());", "+\t\t\tAptProject aptProject = AptPlugin.getAptProject(javaProject);", "+\t\t\tSet<AnnotationProcessorFactory> dispatchedBatchFactories = ", "+\t\t\t\tAPTDispatchRunnable.runAPTDuringBuild(filesWithAnnotations, aptProject, factories, _previousRoundsBatchFactories, isBatchBuild);", "+\t\t\t_previousRoundsBatchFactories.addAll(dispatchedBatchFactories);", "-\t\t\tif (isFullBuild) {", "+\t\t\tif (isBatchBuild) {", "+\t\t\t_buildRound ++;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b2ffb3c74b5d46723f6c0004bc0c10e9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/antadapter/org/eclipse/jdt/core/JDTCompilerAdapter.java", "commitBeforeChange": "89b6b4d9cc0c0dba647129d352a752277e787a7f", "commitAfterChange": "43cd6a7d9958222f67164398a9ef01da87132a6f", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tprotected Commandline setupJavacCommand() throws BuildException", "signatureAfterChange": " \t \t \tprotected Commandline setupJavacCommand() throws BuildException", "diff": ["+\t", "+\tprotected Commandline setupJavacCommand() throws BuildException {", "+\t\tCommandline cmd = new Commandline();", "+\t\t", "+\t\t/*", "+\t\t * This option is used to never exit at the end of the ant task. ", "+\t\t */", "+\t\tcmd.createArgument().setValue(\"-noExit\"); //$NON-NLS-1$", "+", "+        if (bootclasspath != null && bootclasspath.size() != 0) {", "+\t\t\t/*", "+\t\t\t * Set the bootclasspath for the Eclipse compiler.", "+\t\t\t */", "+\t\t\tcmd.createArgument().setValue(\"-bootclasspath\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setPath(bootclasspath);        \t", "+        } else {", "+            includeJavaRuntime = true;", "+        }", "+", "+        Path classpath = new Path(project);", "+", "+       /*", "+         * Eclipse compiler doesn't support -extdirs.", "+         * It is emulated using the classpath. We add extdirs entries after the ", "+         * bootclasspath.", "+         */", "+        addExtdirs(extdirs, classpath);", "+", "+\t\t/*", "+\t\t * The java runtime is already handled, so we simply want to retrieve the", "+\t\t * ant runtime and the compile classpath.", "+\t\t */", "+        classpath.append(getCompileClasspath());", "+", "+        // For -sourcepath, use the \"sourcepath\" value if present.", "+        // Otherwise default to the \"srcdir\" value.", "+        Path sourcepath = null;", "+        ", "+        // retrieve the method getSourcepath() using reflect", "+        // This is done to improve the compatibility to ant 1.5", "+        Class javacClass = Javac.class;", "+        Method getSourcepathMethod = null;", "+        try {", "+\t        getSourcepathMethod = javacClass.getMethod(\"getSourcepath\", null); //$NON-NLS-1$", "+        } catch(NoSuchMethodException e) {", "+        \t// if not found, then we cannot use this method (ant 1.5)", "+        }", "+        Path compileSourcePath = null;", "+        if (getSourcepathMethod != null) {", "+\t \t\ttry {", "+\t\t\t\tcompileSourcePath = (Path) getSourcepathMethod.invoke(attributes, null);", "+\t\t\t} catch (IllegalAccessException e) {", "+\t\t\t\t// should never happen", "+\t\t\t} catch (InvocationTargetException e) {", "+\t\t\t\t// should never happen", "+\t\t\t}", "+        }", "+        if (compileSourcePath != null) {", "+            sourcepath = compileSourcePath;", "+        } else {", "+            sourcepath = src;", "+        }", "+\t\tclasspath.append(sourcepath);", "+\t\t/*", "+\t\t * Set the classpath for the Eclipse compiler.", "+\t\t */", "+\t\tcmd.createArgument().setValue(\"-classpath\"); //$NON-NLS-1$", "+\t\tcmd.createArgument().setPath(classpath);", "+", "+        String memoryParameterPrefix = JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_1) ? \"-J-\" : \"-J-X\";//$NON-NLS-1$//$NON-NLS-2$", "+        if (memoryInitialSize != null) {", "+            if (!attributes.isForkedJavac()) {", "+                attributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryInitialSize\"), Project.MSG_WARN); //$NON-NLS-1$", "+            } else {", "+                cmd.createArgument().setValue(memoryParameterPrefix", "+                                              + \"ms\" + memoryInitialSize); //$NON-NLS-1$", "+            }", "+        }", "+", "+        if (memoryMaximumSize != null) {", "+            if (!attributes.isForkedJavac()) {", "+                attributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryMaximumSize\"), Project.MSG_WARN); //$NON-NLS-1$", "+            } else {", "+                cmd.createArgument().setValue(memoryParameterPrefix", "+                                              + \"mx\" + memoryMaximumSize); //$NON-NLS-1$", "+            }", "+        }", "+", "+        if (debug) {", "+\t       // retrieve the method getSourcepath() using reflect", "+\t        // This is done to improve the compatibility to ant 1.5", "+\t        Method getDebugLevelMethod = null;", "+\t        try {", "+\t\t        getDebugLevelMethod = javacClass.getMethod(\"getDebugLevel\", null); //$NON-NLS-1$", "+\t        } catch(NoSuchMethodException e) {", "+\t        \t// if not found, then we cannot use this method (ant 1.5)", "+\t        \t// debug level is only available with ant 1.5.x", "+\t        }", "+     \t    String debugLevel = null;", "+\t        if (getDebugLevelMethod != null) {", "+\t\t\t\ttry {", "+\t\t\t\t\tdebugLevel = (String) getDebugLevelMethod.invoke(attributes, null);", "+\t\t\t\t} catch (IllegalAccessException e) {", "+\t\t\t\t\t// should never happen", "+\t\t\t\t} catch (InvocationTargetException e) {", "+\t\t\t\t\t// should never happen", "+\t\t\t\t}", "+        \t}", "+\t\t\tif (debugLevel != null) {", "+\t\t\t\tif (debugLevel.length() == 0) {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "+\t\t\t\t} else {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-g:\" + debugLevel); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(\"-g\"); //$NON-NLS-1$", "+            }", "+        } else {", "+            cmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "+        }", "+        ", "+       // retrieve the method getCurrentCompilerArgs() using reflect", "+        // This is done to improve the compatibility to ant 1.5", "+        Method getCurrentCompilerArgsMethod = null;", "+        try {", "+\t        getCurrentCompilerArgsMethod = javacClass.getMethod(\"getCurrentCompilerArgs\", null); //$NON-NLS-1$", "+        } catch(NoSuchMethodException e) {", "+        \t// if not found, then we cannot use this method (ant 1.5)", "+        \t// debug level is only available with ant 1.5.x", "+        }", "+ \t    String[] compilerArgs = null;", "+        if (getCurrentCompilerArgsMethod != null) {", "+\t\t\ttry {", "+\t\t\t\tcompilerArgs = (String[]) getCurrentCompilerArgsMethod.invoke(attributes, null);", "+\t\t\t} catch (IllegalAccessException e) {", "+\t\t\t\t// should never happen", "+\t\t\t} catch (InvocationTargetException e) {", "+\t\t\t\t// should never happen", "+\t\t\t}", "+    \t}", "+    \t", "+\t   \tif (compilerArgs == null) {", "+\t\t\t/*", "+\t\t\t * Handle the nowarn option. If none, then we generate all warnings.", "+\t\t\t */", "+\t\t\tif (attributes.getNowarn()) {", "+\t\t\t\tif (deprecation) {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "+\t\t\t\t} else {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t} else if (deprecation) {", "+\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation,constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(\"-warn:constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "+\t\t\t}", "+    \t} else {", "+\t\t\t/*", "+\t\t\t * Handle the nowarn option. If none, then we generate all warnings.", "+\t\t\t */", "+\t\t\tif (attributes.getNowarn()) {", "+\t\t\t\tif (deprecation) {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "+\t\t\t\t} else {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t} else if (deprecation) {", "+\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "+\t\t\t}", "+\t        /*", "+\t\t\t * Add extra argument on the command line", "+\t\t\t */", "+\t        cmd.addArguments(compilerArgs);", "+\t   \t}", "+", "+\t   \t/*", "+\t\t * destDir option.", "+\t\t */\t\t", "+\t\tif (destDir != null) {", "+\t\t\tcmd.createArgument().setValue(\"-d\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setFile(destDir.getAbsoluteFile());", "+\t\t}", "+", "+\t\t/*", "+\t\t * target option.", "+\t\t */\t\t", "+\t\tif (target != null) {", "+\t\t\tcmd.createArgument().setValue(\"-target\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setValue(target);", "+\t\t}", "+", "+\t\t/*", "+\t\t * verbose option", "+\t\t */", "+\t\tif (verbose) {", "+\t\t\tcmd.createArgument().setValue(\"-verbose\"); //$NON-NLS-1$", "+\t\t\t/*", "+\t\t\t * extra option allowed by the Eclipse compiler", "+\t\t\t */", "+\t\t\tcmd.createArgument().setValue(\"-log\"); //$NON-NLS-1$", "+\t\t\tlogFileName = destDir.getAbsolutePath() + \".log\"; //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setValue(logFileName);", "+\t\t}", "+", "+\t\t/*", "+\t\t * failnoerror option", "+\t\t */", "+\t\tif (!attributes.getFailonerror()) {", "+\t\t\tcmd.createArgument().setValue(\"-proceedOnError\"); //$NON-NLS-1$", "+\t\t}", "+", "+\t\t/*", "+\t\t * source option", "+\t\t */", "+\t\tString source = attributes.getSource();", "+        if (source != null) {", "+            cmd.createArgument().setValue(\"-source\"); //$NON-NLS-1$", "+            cmd.createArgument().setValue(source);", "+        }", "+        ", "+\t\tif (JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_4)) {", "+\t\t\tif (target != null && target.equals(\"1.1\")) {\t\t\t   //$NON-NLS-1$\t", "+\t\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(\"-1.4\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t} else {", "+\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "+\t\t}", "+\t\t", "+\t\t/*", "+\t\t * encoding option", "+\t\t */", "+        if (encoding != null) {", "+            cmd.createArgument().setValue(\"-encoding\"); //$NON-NLS-1$", "+            cmd.createArgument().setValue(encoding);", "+        }", "+", "+     \t/*", "+\t\t * Eclipse compiler doesn't have a -sourcepath option. This is", "+\t\t * handled through the javac task that collects all source files in", "+\t\t * srcdir option.", "+\t\t */        ", "+        logAndAddFilesToCompile(cmd);", "+\t\treturn cmd;", "+\t}", "-", "-\tprotected Commandline setupJavacCommand() throws BuildException {", "-\t\tCommandline cmd = new Commandline();", "-", "-\t\t/*", "-\t\t * This option is used to never exit at the end of the ant task. ", "-\t\t */", "-\t\tcmd.createArgument().setValue(\"-noExit\"); //$NON-NLS-1$", "-", "-\t\tcmd.createArgument().setValue(\"-bootclasspath\"); //$NON-NLS-1$", "-\t\tfinal Javac javac = getJavac();", "-\t\tPath bootcp = javac.getBootclasspath();", "-\t\tif (bootcp != null && bootcp.size() != 0) {", "-\t\t\t/*", "-\t\t\t * Set the bootclasspath for the Eclipse compiler.", "-\t\t\t */", "-\t\t\tcmd.createArgument().setPath(bootcp);", "-\t\t} else {", "-\t\t\tjavac.setIncludejavaruntime(true);", "-\t\t}", "-", "-\t\tProject proj = javac.getProject();", "-\t\tPath classpath = new Path(proj);", "-", "-\t\t/*", "-\t\t * Eclipse compiler doesn't support -extdirs.", "-\t\t * It is emulated using the classpath. We add extdirs entries after the ", "-\t\t * bootclasspath.", "-\t\t */", "-\t\taddExtdirs(classpath, javac.getExtdirs());", "-", "-\t\t/*", "-\t\t * The java runtime is already handled, so we simply want to retrieve the", "-\t\t * ant runtime and the compile classpath.", "-\t\t */", "-\t\tclasspath.append(getCompileClasspath());", "-", "-\t\t// For -sourcepath, use the \"sourcepath\" value if present.", "-\t\t// Otherwise default to the \"srcdir\" value.", "-\t\tPath sourcepath = null;", "-", "-        // retrieve the method getSourcepath() using reflect", "-        // This is done to improve the compatibility to ant 1.5", "-        Class javacClass = Javac.class;", "-        Method getSourcepathMethod = null;", "-        try {", "-\t        getSourcepathMethod = javacClass.getMethod(\"getSourcepath\", null); //$NON-NLS-1$", "-        } catch(NoSuchMethodException e) {", "-        \t// if not found, then we cannot use this method (ant 1.5)", "-        }", "-        Path compileSourcePath = null;", "-        if (getSourcepathMethod != null) {", "-\t \t\ttry {", "-\t\t\t\tcompileSourcePath = (Path) getSourcepathMethod.invoke(javac, null);", "-\t\t\t} catch (IllegalAccessException e) {", "-\t\t\t\t// should never happen", "-\t\t\t} catch (InvocationTargetException e) {", "-\t\t\t\t// should never happen", "-\t\t\t}", "-        }", "- ", "-\t\tif (compileSourcePath != null) {", "-\t\t\tsourcepath = compileSourcePath;", "-\t\t} else {", "-\t\t\tsourcepath = javac.getSrcdir();", "-\t\t}", "-\t\tclasspath.append(sourcepath);", "-\t\t/*", "-\t\t * Set the classpath for the Eclipse compiler.", "-\t\t */", "-\t\tcmd.createArgument().setValue(\"-classpath\"); //$NON-NLS-1$", "-\t\tcmd.createArgument().setPath(classpath);", "-", "-\t\tString memoryParameterPrefix = JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_1) ? \"-J-\" : \"-J-X\"; //$NON-NLS-1$//$NON-NLS-2$", "-\t\tString memInitialSize = javac.getMemoryInitialSize();", "-\t\tif (memInitialSize != null) {", "-\t\t\tif (!javac.isForkedJavac()) {", "-\t\t\t\tattributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryInitialSize\"), Project.MSG_WARN); //$NON-NLS-1$", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(memoryParameterPrefix + \"ms\" + memInitialSize); //$NON-NLS-1$", "-\t\t\t}", "-\t\t}", "-", "-\t\tString memMaximumSize = javac.getMemoryMaximumSize();", "-\t\tif (memMaximumSize != null) {", "-\t\t\tif (!javac.isForkedJavac()) {", "-\t\t\t\tattributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryMaximumSize\"), Project.MSG_WARN); //$NON-NLS-1$", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(memoryParameterPrefix + \"mx\" + memMaximumSize); //$NON-NLS-1$", "-\t\t\t}", "-\t\t}", "-", "-\t\tif (javac.getDebug()) {", "-\t       // retrieve the method getDebugLevel() using reflect", "-\t        // This is done to improve the compatibility to ant 1.5", "-\t        Method getDebugLevelMethod = null;", "-\t        try {", "-\t\t        getDebugLevelMethod = javacClass.getMethod(\"getDebugLevel\", null); //$NON-NLS-1$", "-\t        } catch(NoSuchMethodException e) {", "-\t        \t// if not found, then we cannot use this method (ant 1.5)", "-\t        \t// debug level is only available with ant 1.5.x", "-\t        }", "-     \t    String debugLevel = null;", "-\t        if (getDebugLevelMethod != null) {", "-\t\t\t\ttry {", "-\t\t\t\t\tdebugLevel = (String) getDebugLevelMethod.invoke(javac, null);", "-\t\t\t\t} catch (IllegalAccessException e) {", "-\t\t\t\t\t// should never happen", "-\t\t\t\t} catch (InvocationTargetException e) {", "-\t\t\t\t\t// should never happen", "-\t\t\t\t}", "-        \t}", "-\t\t\tif (debugLevel != null) {", "-\t\t\t\tif (debugLevel.length() == 0) {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-g:\" + debugLevel); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(\"-g\"); //$NON-NLS-1$", "-\t\t\t}", "-\t\t} else {", "-\t\t\tcmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "-\t\t}", "-", "-       // retrieve the method getCurrentCompilerArgs() using reflect", "-        // This is done to improve the compatibility to ant 1.5", "-        Method getCurrentCompilerArgsMethod = null;", "-        try {", "-\t        getCurrentCompilerArgsMethod = javacClass.getMethod(\"getCurrentCompilerArgs\", null); //$NON-NLS-1$", "-        } catch(NoSuchMethodException e) {", "-        \t// if not found, then we cannot use this method (ant 1.5)", "-        \t// debug level is only available with ant 1.5.x", "-        }", "- \t    String[] compilerArgs = null;", "-        if (getCurrentCompilerArgsMethod != null) {", "-\t\t\ttry {", "-\t\t\t\tcompilerArgs = (String[]) getCurrentCompilerArgsMethod.invoke(javac, null);", "-\t\t\t} catch (IllegalAccessException e) {", "-\t\t\t\t// should never happen", "-\t\t\t} catch (InvocationTargetException e) {", "-\t\t\t\t// should never happen", "-\t\t\t}", "-    \t}", "-    \t", "-\t\tfinal boolean deprecationSetting = javac.getDeprecation();", "-\t   \tif (compilerArgs == null) {", "-\t\t\t/*", "-\t\t\t * Handle the nowarn option. If none, then we generate all warnings.", "-\t\t\t */", "-\t\t\tif (javac.getNowarn()) {", "-\t\t\t\tif (deprecationSetting) {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t} else if (deprecationSetting) {", "-\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation,constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(\"-warn:constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "-\t\t\t}", "-    \t} else {", "-\t\t\t/*", "-\t\t\t * Handle the nowarn option. If none, then we generate all warnings.", "-\t\t\t */", "-\t\t\tif (javac.getNowarn()) {", "-\t\t\t\tif (deprecationSetting) {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t} else if (deprecationSetting) {", "-\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "-\t\t\t}", "-\t   \t}", "-", "-\t\t/*", "-\t\t * destDir option.", "-\t\t */", "-\t\tfinal File destdir = javac.getDestdir();", "-\t\tif (destdir != null) {", "-\t\t\tcmd.createArgument().setValue(\"-d\"); //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setFile(destdir.getAbsoluteFile());", "-\t\t}", "-", "-\t\t/*", "-\t\t * target option.", "-\t\t */", "-\t\tfinal String targetSetting = javac.getTarget();", "-\t\tif (targetSetting != null) {", "-\t\t\tcmd.createArgument().setValue(\"-target\"); //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setValue(targetSetting);", "-\t\t}", "-", "-\t\t/*", "-\t\t * verbose option", "-\t\t */", "-\t\tif (javac.getVerbose()) {", "-\t\t\tcmd.createArgument().setValue(\"-verbose\"); //$NON-NLS-1$", "-\t\t\t/*", "-\t\t\t * extra option allowed by the Eclipse compiler", "-\t\t\t */", "-\t\t\tcmd.createArgument().setValue(\"-log\"); //$NON-NLS-1$", "-\t\t\tlogFileName = destdir.getAbsolutePath() + \".log\"; //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setValue(logFileName);", "-\t\t}", "-", "-\t\t/*", "-\t\t * failnoerror option", "-\t\t */", "-\t\tif (!javac.getFailonerror()) {", "-\t\t\tcmd.createArgument().setValue(\"-proceedOnError\"); //$NON-NLS-1$", "-\t\t}", "-", "-\t\t/*", "-\t\t * source option", "-\t\t */", "-\t\tfinal String source = javac.getSource();", "-\t\tif (source != null) {", "-\t\t\tcmd.createArgument().setValue(\"-source\"); //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setValue(source);", "-\t\t}", "-", "-\t\tif (JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_4)) {", "-\t\t\tcmd.createArgument().setValue(\"-1.4\"); //$NON-NLS-1$", "-\t\t} else {", "-\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "-\t\t}", "-", "-\t\t/*", "-\t\t * encoding option", "-\t\t */", "-\t\tfinal String encodingSetting = javac.getEncoding();", "-\t\tif (encodingSetting != null) {", "-\t\t\tcmd.createArgument().setValue(\"-encoding\"); //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setValue(encodingSetting);", "-\t\t}", "-", "-\t\t/*", "-\t\t * Add extra argument on the command line", "-\t\t */", "-\t\tif (compilerArgs != null) {", "-\t        cmd.addArguments(compilerArgs);", "-\t\t}", "-\t\t/*", "-\t\t * Eclipse compiler doesn't have a -sourcepath option. This is", "-\t\t * handled through the javac task that collects all source files in", "-\t\t * srcdir option.", "-\t\t */", "-\t\tlogAndAddFilesToCompile(cmd);", "-\t\treturn cmd;", "-\t}"]}], "num": 8828}