{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f499174129a4414b3858d1e89a2aeb7f", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1655b761aac50f0c428eb9900ded14ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "84a8f41b2dd2dacf2e433dcace83425a3df5cf2d", "commitAfterChange": "2cb54434593d4e5dfdb20e79742efc2e53dbb162", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "signatureAfterChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "diff": ["-\t\t\t&& (method.returnType.tagBits & HasTypeVariable) == 0 ", "+\t\t\t&& (method.returnType.tagBits & TagBits.HasTypeVariable) == 0 ", "-\t\t\t\t\treturn new ProblemMethodBinding(method, method.selector, genericTypeArguments, TypeArgumentsForRawGenericMethod);", "+\t\t\t\t\treturn new ProblemMethodBinding(method, method.selector, genericTypeArguments, ProblemReasons.TypeArgumentsForRawGenericMethod);", "-\t\t\t\treturn new ProblemMethodBinding(method, method.selector, genericTypeArguments, TypeParameterArityMismatch);", "+\t\t\t\treturn new ProblemMethodBinding(method, method.selector, genericTypeArguments, ProblemReasons.TypeParameterArityMismatch);", "-\t\t\treturn new ProblemMethodBinding(method, method.selector, arguments, ParameterizedMethodTypeMismatch);", "+\t\t\treturn new ProblemMethodBinding(method, method.selector, arguments, ProblemReasons.ParameterizedMethodTypeMismatch);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9eb1fc2c14a3125663c97d6da00509d4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 58, "signatureBeforeChange": " \tpublic MethodBinding getReturnProblemMethodIfNeeded(TypeBinding expectedType, MethodBinding method)", "signatureAfterChange": " \tpublic MethodBinding getReturnProblemMethodIfNeeded(TypeBinding expectedType, MethodBinding method)", "diff": ["-\t\tif (expectedType == null)", "-\t\t\treturn method; // assume inference failure concerned another expression", "-\t\tProblemMethodBinding problemMethod = new ProblemMethodBinding(method, method.selector, method.parameters, ProblemReasons.ParameterizedMethodExpectedTypeProblem);", "+\t\t/* We used to check if expected type is null and if so return method, but that is wrong - it injects an incompatible method into overload resolution.", "+\t\t   if we get here with expected type set to null at all, the target context does not define a target type (vanilla context), so inference has done its", "+\t\t   best and nothing more to do than to signal error. ", "+\t\t */", "+\t\tProblemMethodBinding problemMethod = new ProblemMethodBinding(method, method.selector, method.parameters, ProblemReasons.InvocationTypeInferenceFailure);", "-\t}"]}], "num": 43752}