{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f7e5f43acd300b744b37704eec9e0132", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "088d0154331cfdfff564fb64af229999", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/CompilationResult.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 18, "signatureBeforeChange": "  \tpublic void record(CategorizedProblem newProblem, ReferenceContext referenceContext)", "signatureAfterChange": "  public void record(CategorizedProblem newProblem, ReferenceContext referenceContext)", "diff": ["-", "-\tpublic void record(CategorizedProblem newProblem, ReferenceContext referenceContext) {", "-", "-\t\t//new Exception(\"VERBOSE PROBLEM REPORTING\").printStackTrace();", "-\t\tif(newProblem.getID() == IProblem.Task) {", "-\t\t\t\trecordTask(newProblem);", "-\t\t\t\treturn;", "-\t\t}", "-\t\tif (problemCount == 0) {", "-\t\t\tproblems = new CategorizedProblem[5];", "-\t\t} else if (problemCount == problems.length) {", "-\t\t\tSystem.arraycopy(problems, 0, (problems = new CategorizedProblem[problemCount * 2]), 0, problemCount);", "-\t\t}", "-\t\tproblems[problemCount++] = newProblem;", "-\t\tif (referenceContext != null){", "-\t\t\tif (problemsMap == null) problemsMap = new HashMap(5);", "-\t\t\tif (firstErrors == null) firstErrors = new HashSet(5);", "-\t\t\tif (newProblem.isError() && !referenceContext.hasErrors()) firstErrors.add(newProblem);", "-\t\t\tproblemsMap.put(newProblem, referenceContext);", "-\t\t}", "-\t\tif ((newProblem.getID() & IProblem.Syntax) != 0 && newProblem.isError())", "-\t\t\tthis.hasSyntaxError = true;", "-\t}", "+", "+public void record(CategorizedProblem newProblem, ReferenceContext referenceContext) {", "+\t//new Exception(\"VERBOSE PROBLEM REPORTING\").printStackTrace();", "+\tif(newProblem.getID() == IProblem.Task) {", "+\t\t\trecordTask(newProblem);", "+\t\t\treturn;", "+\t}", "+\tif (this.problemCount == 0) {", "+\t\tthis.problems = new CategorizedProblem[5];", "+\t} else if (this.problemCount == this.problems.length) {", "+\t\tSystem.arraycopy(this.problems, 0, (this.problems = new CategorizedProblem[this.problemCount * 2]), 0, this.problemCount);", "+\t}", "+\tthis.problems[this.problemCount++] = newProblem;", "+\tif (referenceContext != null){", "+\t\tif (this.problemsMap == null) this.problemsMap = new HashMap(5);", "+\t\tif (this.firstErrors == null) this.firstErrors = new HashSet(5);", "+\t\tif (newProblem.isError() && !referenceContext.hasErrors()) this.firstErrors.add(newProblem);", "+\t\tthis.problemsMap.put(newProblem, referenceContext);", "+\t}", "+\tif ((newProblem.getID() & IProblem.Syntax) != 0 && newProblem.isError())", "+\t\tthis.hasSyntaxError = true;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6a2acea7715c1868ddd47c05e2e927a6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/CompilationResult.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic CategorizedProblem[] getProblems()", "signatureAfterChange": " public CategorizedProblem[] getProblems()", "diff": ["-\t */", "-\tpublic CategorizedProblem[] getProblems() {", "-\t\t", "-\t\t// Re-adjust the size of the problems if necessary.", "-\t\tif (problems != null) {", "-\t\t\tdiscardSuppressedWarnings();", "-\t", "-\t\t\tif (this.problemCount != problems.length) {", "-\t\t\t\tSystem.arraycopy(problems, 0, (problems = new CategorizedProblem[problemCount]), 0, problemCount);", "-\t\t\t}", "-\t", "-\t\t\tif (this.maxProblemPerUnit > 0 && this.problemCount > this.maxProblemPerUnit){", "-\t\t\t\tquickPrioritize(problems, 0, problemCount - 1);", "-\t\t\t\tthis.problemCount = this.maxProblemPerUnit;", "-\t\t\t\tSystem.arraycopy(problems, 0, (problems = new CategorizedProblem[problemCount]), 0, problemCount);", "-\t\t\t}", "-\t", "-\t\t\t// Sort problems per source positions.", "-\t\t\tquickSort(problems, 0, problems.length-1);", "-\t\t}", "-\t\treturn problems;", "-\t}", "+ */", "+public CategorizedProblem[] getProblems() {", "+\t// Re-adjust the size of the problems if necessary.", "+\tif (this.problems != null) {", "+\t\tdiscardSuppressedWarnings();", "+", "+\t\tif (this.problemCount != this.problems.length) {", "+\t\t\tSystem.arraycopy(this.problems, 0, (this.problems = new CategorizedProblem[this.problemCount]), 0, this.problemCount);", "+\t\t}", "+", "+\t\tif (this.maxProblemPerUnit > 0 && this.problemCount > this.maxProblemPerUnit){", "+\t\t\tquickPrioritize(this.problems, 0, this.problemCount - 1);", "+\t\t\tthis.problemCount = this.maxProblemPerUnit;", "+\t\t\tSystem.arraycopy(this.problems, 0, (this.problems = new CategorizedProblem[this.problemCount]), 0, this.problemCount);", "+\t\t}", "+", "+\t\t// Stable sort problems per source positions.", "+\t\tArrays.sort(this.problems, 0, this.problems.length, CompilationResult.PROBLEM_COMPARATOR);", "+\t\t//quickSort(problems, 0, problems.length-1);", "+\t}", "+\treturn this.problems;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f16ed6d16b1b5b6e55564e136045d23", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java", "commitBeforeChange": "8ff87d310a91c2a77c65ad68bb4b1fd94425fd85", "commitAfterChange": "dbf8a869161361178e399dd7e18a85b9a48bde74", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tint treeSize()", "signatureAfterChange": " \tint treeSize()", "diff": ["-\t\t\t+ (getJavadoc() == null ? 0 : getJavadoc().treeSize())", "-\t\t\t+ (methodName == null ? 0 : getName().treeSize())", "-\t\t\t+ (returnType == null ? 0 : getReturnType().treeSize())", "-\t\t\t+ parameters.listSize()", "-\t\t\t+ thrownExceptions.listSize()", "-\t\t\t+ (optionalBody == null ? 0 : getBody().treeSize());", "+\t\t\t+ (this.optionalDocComment == null ? 0 : getJavadoc().treeSize())", "+\t\t\t+ (this.modifiers == null ? 0 : this.modifiers.listSize())", "+\t\t\t+ (this.typeParameters == null ? 0 : this.typeParameters.listSize())", "+\t\t\t+ (this.methodName == null ? 0 : getName().treeSize())", "+\t\t\t+ (this.returnType == null ? 0 : this.returnType.treeSize())", "+\t\t\t+ this.parameters.listSize()", "+\t\t\t+ this.thrownExceptions.listSize()", "+\t\t\t+ (this.optionalBody == null ? 0 : getBody().treeSize());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3acea674dc39bf8fdf6badd4d1847c9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 125, "methodNumberAfterChange": 125, "signatureBeforeChange": " protected void consumeMethodHeaderParameters()", "signatureAfterChange": " protected void consumeMethodHeaderParameters()", "diff": ["-\tint length = astLengthStack[astLengthPtr--];", "-\tastPtr -= length;", "-\tAbstractMethodDeclaration md = (AbstractMethodDeclaration) astStack[astPtr];", "-\tmd.sourceEnd = \trParenPos;", "+\tint length = this.astLengthStack[this.astLengthPtr--];", "+\tthis.astPtr -= length;", "+\tAbstractMethodDeclaration md = (AbstractMethodDeclaration) this.astStack[this.astPtr];", "+\tmd.sourceEnd = \tthis.rParenPos;", "-\t\t\tastStack, ", "-\t\t\tastPtr + 1, ", "+\t\t\tthis.astStack, ", "+\t\t\tthis.astPtr + 1, ", "-\tmd.bodyStart = rParenPos+1;", "-\tlistLength = 0; // reset listLength after having read all parameters", "+\tmd.bodyStart = this.rParenPos+1;", "+\tthis.listLength = 0; // reset listLength after having read all parameters", "-\tif (currentElement != null){", "-\t\tlastCheckPoint = md.bodyStart;", "-\t\tif (currentElement.parseTree() == md) return;", "+\tif (this.currentElement != null){", "+\t\tthis.lastCheckPoint = md.bodyStart;", "+\t\tif (this.currentElement.parseTree() == md) return;", "-\t\t\t\t|| (currentToken == TokenNameLBRACE) ", "-\t\t\t\t|| (currentToken == TokenNamethrows)){", "-\t\t\t\tcurrentElement = currentElement.add(md, 0);", "-\t\t\t\tlastIgnoredToken = -1;", "+\t\t\t\t|| (this.currentToken == TokenNameLBRACE) ", "+\t\t\t\t|| (this.currentToken == TokenNamethrows)){", "+\t\t\t\tthis.currentElement = this.currentElement.add(md, 0);", "+\t\t\t\tthis.lastIgnoredToken = -1;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb4a8fbb15cd6980d631a73f00d0e253", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java", "commitBeforeChange": "babe82af3726a6979eb5da4c747f51906154b2bc", "commitAfterChange": "fab4ac0c2a45db58d02407ad5972d843c8dba1e6", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\tpublic FlowInfo analyseCode(", "-\t\tBlockScope currentScope,", "-\t\tFlowContext flowContext,", "-\t\tFlowInfo flowInfo) {", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "+\tthis.breakLabel = new BranchLabel();", "+\tthis.continueLabel = new BranchLabel();", "+\tLoopingFlowContext loopingContext =", "+\t\tnew LoopingFlowContext(", "+\t\t\tflowContext,", "+\t\t\tflowInfo,", "+\t\t\tthis,", "+\t\t\tthis.breakLabel,", "+\t\t\tthis.continueLabel,", "+\t\t\tcurrentScope);", "-\t\tbreakLabel = new BranchLabel();", "-\t\tcontinueLabel = new BranchLabel();", "-\t\tLoopingFlowContext loopingContext =", "-\t\t\tnew LoopingFlowContext(", "-\t\t\t\tflowContext,", "-\t\t\t\tflowInfo,", "-\t\t\t\tthis,", "-\t\t\t\tbreakLabel,", "-\t\t\t\tcontinueLabel,", "-\t\t\t\tcurrentScope);", "+\tConstant cst = this.condition.constant;", "+\tboolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\tcst = this.condition.optimizedBooleanConstant();", "+\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "-\t\tConstant cst = condition.constant;", "-\t\tboolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\tcst = condition.optimizedBooleanConstant();", "-\t\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "+\tint previousMode = flowInfo.reachMode();", "+\t\t\t", "+\tUnconditionalFlowInfo actionInfo = flowInfo.nullInfoLessUnconditionalCopy();", "+\t// we need to collect the contribution to nulls of the coming paths through the", "+\t// loop, be they falling through normally or branched to break, continue labels", "+\t// or catch blocks", "+\tif ((this.action != null) && !this.action.isEmptyBlock()) {", "+\t\tactionInfo = this.action.", "+\t\t\tanalyseCode(currentScope, loopingContext, actionInfo).", "+\t\t\tunconditionalInits();", "-\t\tint previousMode = flowInfo.reachMode();", "-\t\t\t\t", "-\t\tUnconditionalFlowInfo actionInfo = flowInfo.nullInfoLessUnconditionalCopy();", "-\t\t// we need to collect the contribution to nulls of the coming paths through the", "-\t\t// loop, be they falling through normally or branched to break, continue labels", "-\t\t// or catch blocks", "-\t\tif ((action != null) && !action.isEmptyBlock()) {", "-\t\t\tactionInfo = action.", "-\t\t\t\tanalyseCode(currentScope, loopingContext, actionInfo).", "-\t\t\t\tunconditionalInits();", "-", "-\t\t\t// code generation can be optimized when no need to continue in the loop", "-\t\t\tif ((actionInfo.tagBits & ", "-\t\t\t\t\tloopingContext.initsOnContinue.tagBits & ", "-\t\t\t\t\tFlowInfo.UNREACHABLE) != 0) {", "-\t\t\t\tcontinueLabel = null;", "-\t\t\t}", "+\t\t// code generation can be optimized when no need to continue in the loop", "+\t\tif ((actionInfo.tagBits & ", "+\t\t\t\tloopingContext.initsOnContinue.tagBits & ", "+\t\t\t\tFlowInfo.UNREACHABLE) != 0) {", "+\t\t\tthis.continueLabel = null;", "-\t\t/* Reset reach mode, to address following scenario.", "-\t\t *   final blank;", "-\t\t *   do { if (true) break; else blank = 0; } while(false);", "-\t\t *   blank = 1; // may be initialized already ", "-\t\t */", "-\t\tactionInfo.setReachMode(previousMode);", "-\t\t", "-\t\tLoopingFlowContext condLoopContext;", "-\t\tFlowInfo condInfo =", "-\t\t\tcondition.analyseCode(", "-\t\t\t\tcurrentScope,", "-\t\t\t\t(condLoopContext =", "-\t\t\t\t\tnew LoopingFlowContext(flowContext,\tflowInfo, this, null, ", "-\t\t\t\t\t\tnull, currentScope)),", "-\t\t\t\t(action == null", "-\t\t\t\t\t? actionInfo", "-\t\t\t\t\t: (actionInfo.mergedWith(loopingContext.initsOnContinue))).copy());", "-\t\tif (!isConditionOptimizedFalse && continueLabel != null) {", "-\t\t\tloopingContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "-\t\t\tcondLoopContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "-\t\t\tUnconditionalFlowInfo checkFlowInfo;", "-\t\t\tloopingContext.complainOnDeferredNullChecks(currentScope, ", "-\t\t\t\t\tcheckFlowInfo = actionInfo.", "-\t\t\t\t\t\taddPotentialNullInfoFrom(", "-\t\t\t\t\t\t  condInfo.initsWhenTrue().unconditionalInits()));", "-\t\t\tcondLoopContext.complainOnDeferredNullChecks(currentScope, ", "-\t\t\t\t\tcheckFlowInfo);", "-\t\t}", "-", "-\t\t// end of loop", "-\t\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "-\t\t\t\t(loopingContext.initsOnBreak.tagBits &", "-\t\t\t\t\tFlowInfo.UNREACHABLE) != 0 ?", "-\t\t\t\t\tloopingContext.initsOnBreak :", "-\t\t\t\t\tflowInfo.unconditionalCopy().addInitializationsFrom(loopingContext.initsOnBreak), ", "-\t\t\t\t\t\t// recover upstream null info", "-\t\t\t\tisConditionOptimizedTrue,", "-\t\t\t\t(condInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ?", "-\t\t\t\t\t\tflowInfo.addInitializationsFrom(condInfo.initsWhenFalse()) : condInfo, ", "-\t\t\t\t\t// recover null inits from before condition analysis", "-\t\t\t\tfalse, // never consider opt false case for DO loop, since break can always occur (47776)", "-\t\t\t\t!isConditionTrue /*do{}while(true); unreachable(); */);", "-\t\tmergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\treturn mergedInfo;", "+\t/* Reset reach mode, to address following scenario.", "+\t *   final blank;", "+\t *   do { if (true) break; else blank = 0; } while(false);", "+\t *   blank = 1; // may be initialized already ", "+\tactionInfo.setReachMode(previousMode);", "+\t", "+\tLoopingFlowContext condLoopContext;", "+\tFlowInfo condInfo =", "+\t\tthis.condition.analyseCode(", "+\t\t\tcurrentScope,", "+\t\t\t(condLoopContext =", "+\t\t\t\tnew LoopingFlowContext(flowContext,\tflowInfo, this, null, ", "+\t\t\t\t\tnull, currentScope)),", "+\t\t\t(this.action == null", "+\t\t\t\t? actionInfo", "+\t\t\t\t: (actionInfo.mergedWith(loopingContext.initsOnContinue))).copy());", "+\tif (!isConditionOptimizedFalse && this.continueLabel != null) {", "+\t\tloopingContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "+\t\tcondLoopContext.complainOnDeferredFinalChecks(currentScope, condInfo);", "+\t\tUnconditionalFlowInfo checkFlowInfo;", "+\t\tloopingContext.complainOnDeferredNullChecks(currentScope, ", "+\t\t\t\tcheckFlowInfo = actionInfo.", "+\t\t\t\t\taddPotentialNullInfoFrom(", "+\t\t\t\t\t  condInfo.initsWhenTrue().unconditionalInits()));", "+\t\tcondLoopContext.complainOnDeferredNullChecks(currentScope, ", "+\t\t\t\tcheckFlowInfo);", "+\t// end of loop", "+\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "+\t\t\t(loopingContext.initsOnBreak.tagBits &", "+\t\t\t\tFlowInfo.UNREACHABLE) != 0 ?", "+\t\t\t\tloopingContext.initsOnBreak :", "+\t\t\t\tflowInfo.unconditionalCopy().addInitializationsFrom(loopingContext.initsOnBreak), ", "+\t\t\t\t\t// recover upstream null info", "+\t\t\tisConditionOptimizedTrue,", "+\t\t\t(condInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ?", "+\t\t\t\t\tflowInfo.addInitializationsFrom(condInfo.initsWhenFalse()) : condInfo, ", "+\t\t\t\t// recover null inits from before condition analysis", "+\t\t\tfalse, // never consider opt false case for DO loop, since break can always occur (47776)", "+\t\t\t!isConditionTrue /*do{}while(true); unreachable(); */);", "+\tthis.mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "+\treturn mergedInfo;", "+}"]}], "num": 37043}