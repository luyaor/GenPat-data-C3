{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "466536e2f1c62e17df0673f63dfd5128", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "07b1730d5a6b66699c226356e2de3d44", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "64048b0f093f9425eaa40658b41da232045fddbb", "commitAfterChange": "aec82daf3a949438484a5a183bdf5f3fca44d3fc", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " boolean areParametersEqual(MethodBinding one, MethodBinding two)", "signatureAfterChange": " boolean areParametersEqual(MethodBinding one, MethodBinding two)", "diff": ["-\tfor (int i = 0; i < length; i++) {", "-\t\tif (!areTypesEqual(oneArgs[i], twoArgs[i])) {", "-\t\t\t// methods with raw parameters are considered equal to inherited methods with parameterized parameters for backwards compatibility", "-\t\t\tif (!one.declaringClass.isInterface() && oneArgs[i].leafComponentType().isRawType())", "-\t\t\t\tif (oneArgs[i].dimensions() == twoArgs[i].dimensions() && oneArgs[i].leafComponentType().isEquivalentTo(twoArgs[i].leafComponentType()))", "-\t\t\t\t\tcontinue;", "-\t\t\treturn false;", "+\tif (one.declaringClass.isInterface()) {", "+\t\tfor (int i = 0; i < length; i++)", "+\t\t\tif (!areTypesEqual(oneArgs[i], twoArgs[i]))", "+\t\t\t\treturn false;", "+\t} else {", "+\t\t// methods with raw parameters are considered equal to inherited methods", "+\t\t// with parameterized parameters for backwards compatibility, need a more complex check", "+\t\tint i;", "+\t\tfoundRAW: for (i = 0; i < length; i++) {", "+\t\t\tif (!areTypesEqual(oneArgs[i], twoArgs[i])) {", "+\t\t\t\tif (oneArgs[i].leafComponentType().isRawType()) {", "+\t\t\t\t\tif (oneArgs[i].dimensions() == twoArgs[i].dimensions() && oneArgs[i].leafComponentType().isEquivalentTo(twoArgs[i].leafComponentType())) {", "+\t\t\t\t\t\t// one parameter type is raw, hence all parameters types must be raw or non generic", "+\t\t\t\t\t\t// otherwise we have a mismatch check backwards", "+\t\t\t\t\t\tfor (int j = 0; j < i; j++)", "+\t\t\t\t\t\t\tif (oneArgs[j].leafComponentType().isParameterizedType())", "+\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t// switch to all raw mode", "+\t\t\t\t\t\tbreak foundRAW;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t}", "+\t\t// all raw mode for remaining parameters (if any)", "+\t\tfor (i++; i < length; i++) {", "+\t\t\tif (!areTypesEqual(oneArgs[i], twoArgs[i])) {", "+\t\t\t\tif (oneArgs[i].leafComponentType().isRawType())", "+\t\t\t\t\tif (oneArgs[i].dimensions() == twoArgs[i].dimensions() && oneArgs[i].leafComponentType().isEquivalentTo(twoArgs[i].leafComponentType()))", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\treturn false;", "+\t\t\t} else if (oneArgs[i].leafComponentType().isParameterizedType()) {", "+\t\t\t\treturn false; // no remaining parameter can be a Parameterized type (if one has been converted then all RAW types must be converted)", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ada8e59cb483eca2477f346f3c74bd7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "8a0b8147f0cecac2ce3556609ced767532ecf02f", "commitAfterChange": "f7ac9a023a19399b6d2bc4bf79cc66ebc7cf056e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  \tprivate void verifyTypeReference(Expression reference, Expression typeReference, Scope scope, boolean source15, ReferenceBinding resolvedType, int modifiers)", "signatureAfterChange": "  \tprivate void verifyTypeReference(Expression reference, Expression typeReference, Scope scope, boolean source15, ReferenceBinding resolvedType, int modifiers)", "diff": ["-", "+\t\t\t", "-\t\t\t\tint depth = 0;", "+\t\t\t\t// rebuild and store (in reverse order) compound name to handle embedded inner class", "+\t\t\t\tint packageLength = topLevelType.fPackage.compoundName.length;", "+\t\t\t\tint depth = resolvedType.depth();", "+\t\t\t\tint idx = depth + packageLength;", "+\t\t\t\tchar[][] computedCompoundName = new char[idx+1][];", "+\t\t\t\tcomputedCompoundName[idx] = topLevelType.sourceName;", "-\t\t\t\t\tdepth++;", "+\t\t\t\t\tcomputedCompoundName[--idx] = topLevelType.sourceName;", "+\t\t\t\t", "+\t\t\t\t// add package information", "+\t\t\t\tfor (int i = packageLength; --i >= 0;) {", "+\t\t\t\t\tcomputedCompoundName[--idx] = topLevelType.fPackage.compoundName[i];", "+\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "-\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);", "-\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t\t// search for corresponding import", "+\t\t\t\t\t\t\tboolean hasValidImport = false;", "+\t\t\t\t\t\t\tif (source15) {", "+\t\t\t\t\t\t\t\tCompilationUnitScope unitScope = topLevelScope.compilationUnitScope();", "+\t\t\t\t\t\t\t\tImportBinding[] imports = unitScope.imports;", "+\t\t\t\t\t\t\t\tint length = imports == null ? 0 : imports.length;", "+\t\t\t\t\t\t\t\tmainLoop: for (int i=0; i<length; i++) {", "+\t\t\t\t\t\t\t\t\tchar[][] compoundName = imports[i].compoundName;", "+\t\t\t\t\t\t\t\t\tint compoundNameLength = compoundName.length;", "+\t\t\t\t\t\t\t\t\tif ((imports[i].onDemand && compoundNameLength == computedCompoundName.length-1) ||", "+\t\t\t\t\t\t\t\t\t\t(compoundNameLength == computedCompoundName.length))", "+\t\t\t\t\t\t\t\t\t{", "+\t\t\t\t\t\t\t\t\t\tfor (int j = compoundNameLength; --j >= 0;) {", "+\t\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(imports[i].compoundName[j], computedCompoundName[j])) {", "+\t\t\t\t\t\t\t\t\t\t\t\tif (j == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\thasValidImport = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak mainLoop;", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;\t", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (!hasValidImport) {", "+\t\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "21a47900980de651513531bc5a64da9a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 51, "methodNumberAfterChange": 55, "signatureBeforeChange": " public void duplicateMethodInType(SourceTypeBinding type, AbstractMethodDeclaration methodDecl)", "signatureAfterChange": " public void duplicateMethodInType(SourceTypeBinding type, AbstractMethodDeclaration methodDecl)", "diff": ["-\tString[] arguments = new String[] {new String(methodDecl.selector), new String(type.sourceName())};", "-\tthis.handle(", "-\t\tIProblem.DuplicateMethod,", "-\t\targuments,", "-\t\targuments,", "-\t\tmethodDecl.sourceStart,", "-\t\tmethodDecl.sourceEnd);", "+    MethodBinding method = methodDecl.binding;", "+    boolean duplicateErasure = false;", "+    if ((method.modifiers & CompilerModifiers.AccGenericSignature) != 0) {", "+        // chech it occurs in parameters (the bit is set for return type | params | thrown exceptions", "+        for (int i = 0, length = method.parameters.length; i < length; i++) {", "+            if ((method.parameters[i].tagBits & TagBits.HasTypeVariable) != 0) {", "+                duplicateErasure = true;", "+                break;", "+            }", "+        }", "+    }", "+    if (duplicateErasure) {", "+        int length = method.parameters.length;", "+        TypeBinding[] erasures = new TypeBinding[length];", "+        for (int i = 0; i < length; i++)  {", "+            erasures[i] = method.parameters[i].erasure();", "+        }", "+\t\tthis.handle(", "+\t\t\tIProblem.DuplicateMethodErasure,", "+\t\t\tnew String[] {", "+\t\t        new String(methodDecl.selector),", "+\t\t\t\tnew String(method.declaringClass.readableName()),", "+\t\t\t\tparametersAsString(method.parameters, false),", "+\t\t\t\tparametersAsString(erasures, false) } ,", "+\t\t\tnew String[] {", "+\t\t\t\tnew String(methodDecl.selector),", "+\t\t\t\tnew String(method.declaringClass.shortReadableName()),", "+\t\t\t\tparametersAsString(method.parameters, true),", "+\t\t\t\tparametersAsString(erasures, true) },", "+\t\t\tmethodDecl.sourceStart,", "+\t\t\tmethodDecl.sourceEnd);", "+    } else {", "+\t\tthis.handle(", "+\t\t\tIProblem.DuplicateMethod,", "+\t\t\tnew String[] {", "+\t\t        new String(methodDecl.selector),", "+\t\t\t\tnew String(method.declaringClass.readableName()),", "+\t\t\t\tparametersAsString(method.parameters, false)},", "+\t\t\tnew String[] {", "+\t\t\t\tnew String(methodDecl.selector),", "+\t\t\t\tnew String(method.declaringClass.shortReadableName()),", "+\t\t\t\tparametersAsString(method.parameters, true)},", "+\t\t\tmethodDecl.sourceStart,", "+\t\t\tmethodDecl.sourceEnd);", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "352ed496236de15d033252a17a4c57e8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java", "commitBeforeChange": "7675c409a4b3b1e15b1cc476a0a66b988b5fb4a0", "commitAfterChange": "28d83829a5c5453c02025fb74750ed1594ff644e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r public IType getDeclaringType()", "signatureAfterChange": "\r public IType getDeclaringType()", "diff": ["-\ttry {\r", "-\t\tchar[] enclosingTypeName = ((IBinaryType) getRawInfo()).getEnclosingTypeName();\r", "-\t\tif (enclosingTypeName == null) {\r", "+\tIClassFile classFile = this.getClassFile();\r", "+\tif (classFile.isOpen()) {\r", "+\t\ttry {\r", "+\t\t\tchar[] enclosingTypeName = ((IBinaryType) getRawInfo()).getEnclosingTypeName();\r", "+\t\t\tif (enclosingTypeName == null) {\r", "+\t\t\t\treturn null;\r", "+\t\t\t}\r", "+\t\t \tenclosingTypeName = ClassFile.unqualifiedName(enclosingTypeName);\r", "+\t\t \t\r", "+\t\t\t// workaround problem with class files compiled with javac 1.1.* \r", "+\t\t\t// that return a non-null enclosing type name for local types defined in anonymous (e.g. A$1$B)\r", "+\t\t\tif (classFile.getElementName().length() > enclosingTypeName.length+1 \r", "+\t\t\t\t\t&& Character.isDigit(classFile.getElementName().charAt(enclosingTypeName.length+1))) {\r", "+\t\t\t\treturn null;\r", "+\t\t\t} \r", "+\t\t\t\r", "+\t\t\treturn getPackageFragment().getClassFile(new String(enclosingTypeName) + \".class\").getType(); //$NON-NLS-1$;\r", "+\t\t} catch (JavaModelException npe) {\r", "-\t\tenclosingTypeName = ClassFile.unqualifiedName(enclosingTypeName);\r", "-\t\treturn getPackageFragment().getClassFile(new String(enclosingTypeName) + \".class\").getType(); //$NON-NLS-1$\r", "-\t} catch (JavaModelException npe) {\r", "-\t\treturn null;\r", "+\t} else {\r", "+\t\t// cannot access .class file without opening it \r", "+\t\t// and getDeclaringType() is supposed to be a handle-only method,\r", "+\t\t// so default to assuming $ is an enclosing type separator\r", "+\t\tString classFileName = classFile.getElementName();\r", "+\t\tint lastDollar = -1;\r", "+\t\tfor (int i = 0, length = classFileName.length(); i < length; i++) {", "+\t\t\tchar c = classFileName.charAt(i);\r", "+\t\t\tif (Character.isDigit(c) && lastDollar == i-1) {\r", "+\t\t\t\t// anonymous or local type\r", "+\t\t\t\treturn null;\r", "+\t\t\t} else if (c == '$') {\r", "+\t\t\t\tlastDollar = i;\r", "+\t\t\t}", "+\t\t}\r", "+\t\tif (lastDollar == -1) {\r", "+\t\t\treturn null;\r", "+\t\t} else {\r", "+\t\t\tString enclosingName = classFileName.substring(0, lastDollar);\r", "+\t\t\tString enclosingClassFileName = enclosingName + \".class\"; //$NON-NLS-1$\r", "+\t\t\treturn \r", "+\t\t\t\tnew BinaryType(\r", "+\t\t\t\t\tthis.getPackageFragment().getClassFile(enclosingClassFileName),\r", "+\t\t\t\t\tenclosingName.substring(enclosingName.lastIndexOf('$')+1));\r", "+\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5d1c9da11cf238068f7601bb5cdacc79", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "b2ae5b84e851673c2a38346fddf34788249a797b", "commitAfterChange": "4d607b0a1e816e979fcd959b6151941b0be77df7", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation)", "diff": ["-\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {", "+\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation) {", "-\t\t/* validate output location */", "-\t\tif (outputLocation == null) {", "+\t\t/* validate output locations */", "+\t\tif (projectOutputLocation == null) {", "-\t\tif (outputLocation.isAbsolute()) {", "-\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "-\t\t\t}", "-\t\t} else {", "-\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "-\t\t}", "-\t", "-\t\tboolean allowNestingInOutput = false;", "-\t\tboolean hasSource = false;", "-\t\tboolean hasLibFolder = false;", "-\t", "+\t\t// collect other output locations", "+\t\tint outputsLength = length+1;", "+\t\tIPath[] outputLocations = new IPath[outputsLength];", "+\t\toutputLocations[length] = projectOutputLocation;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tIClasspathEntry entry = classpath[i];", "+\t\t\tIPath outputLocation = entry.getOutputLocation();", "+\t\t\tif (outputLocation != null) {", "+\t\t\t\tif (outputLocation.isAbsolute()) {", "+\t\t\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\toutputLocations[i] = outputLocation;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tboolean[] allowNestingInOutput = new boolean[length+1];", "+\t\tboolean hasSource = false;", "+\t\tboolean hasLibFolder = false;", "+\t\t", "-\t\t\tswitch(rawEntry.getEntryKind()){", "+\t\t\tint kind = rawEntry.getEntryKind();", "+\t\t\tswitch(kind){", "-\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "+\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "+\t\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "+\t\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "+\t\t\t\t\t\t\tif (outputLocation != null ", "+\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "+\t\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "+\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "+\t\t\t\t\t\t\t\t\t\tfor (int k = 0; k < outputsLength; k++) {", "+\t\t\t\t\t\t\t\t\t\t\tIPath outputLocation = outputLocations[k];", "+\t\t\t\t\t\t\t\t\t\t\tif (outputLocation != null ", "+\t\t\t\t\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "+\t\t\t\t\t\t\t\t\t\t\t\tallowNestingInOutput[k] = true;\t\t", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\tif (!org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "+\t\t\t\t\tif (kind != IClasspathEntry.CPE_SOURCE", "+\t\t\t\t\t\t\t&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "-\t\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "+\t\t\t\t\tIPath rawPath = rawEntry.getPath();", "+\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "+\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "+\t\t\t\t\t\tif (outputLocation != null ", "+\t\t\t\t\t\t\t\t&& rawPath.equals(outputLocation)) {", "+\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput = true; // if no source and no lib folder, then allowed", "+\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput[length] = true; // if no source and no lib folder, then allowed for project output", "-\t\t\t\tfor (int j = 0; j < classpath.length; j++){", "+\t\t\t\tfor (int j = 0; j < length; j++){", "-\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "-\t\t\t}", "-\t", "-\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "-\t\t\tif (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "+\t\t\tfor (int j = 0; j < outputsLength; j++) {", "+\t\t\t\tIPath outputLocation = outputLocations[j];", "+\t\t\t\tif (outputLocation != null) {", "+\t\t\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t", "+\t\t\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "+\t\t\t\t\tif (!allowNestingInOutput[j] && outputLocation.isPrefixOf(entryPath)) {", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6a24a442d1ccdb78441677bd28f2dbd2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "d2d42dc68198e20f3f5cc7326a07cced2c751eb5", "commitAfterChange": "add5c6babb13b20df1267306ec710a4efca88a4d", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": "\r public void notifySourceElementRequestor()", "signatureAfterChange": "\r public void notifySourceElementRequestor()", "diff": ["+\t// collect the top level ast nodes\r", "+\tint length = 0;\r", "+\tAstNode[] nodes = null;\r", "-\t\t// first we notify the package declaration\r", "-\t\tif (currentPackage != null) {\r", "-\t\t\tnotifySourceElementRequestor(currentPackage, true);\r", "-\t\t}\r", "-\t\t// then the imports\r", "+\t\tTypeDeclaration[] types = compilationUnit.types;\r", "+\t\tlength = \r", "+\t\t\t(currentPackage == null ? 0 : 1) \r", "+\t\t\t+ (imports == null ? 0 : imports.length)\r", "+\t\t\t+ (types == null ? 0 : types.length);\r", "+\t\tnodes = new AstNode[length];\r", "+\t\tint index = 0;\r", "+\t\tif (currentPackage != null) {\r", "+\t\t\tnodes[index++] = currentPackage;\r", "+\t\t}\r", "-\t\t\t\tnotifySourceElementRequestor(imports[i], false);\r", "+\t\t\t\tnodes[index++] = imports[i];\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (types != null) {\r", "+\t\t\tfor (int i = 0, max = types.length; i < max; i++) {\r", "+\t\t\t\tnodes[index++] = types[i];\r", "+\t\t\t}\r", "+\t\t}\r", "+\t} else {\r", "+\t\tTypeDeclaration[] types = compilationUnit.types;\r", "+\t\tif (types != null) {\r", "+\t\t\tlength = types.length;\r", "+\t\t\tnodes = new AstNode[length];\r", "+\t\t\tfor (int i = 0, max = types.length; i < max; i++) {\r", "+\t\t\t\tnodes[i] = types[i];\r", "-\t// then the types contained by this compilation unit\r", "-\tTypeDeclaration[] types = compilationUnit.types;\r", "-\tif (types != null) {\r", "-\t\tfor (int i = 0, max = types.length; i < max; i++) {\r", "-\t\t\tnotifySourceElementRequestor(types[i], sourceType == null);\r", "+\t\r", "+\t// notify the nodes in the syntactical order\r", "+\tif (nodes != null && length > 0) {\r", "+\t\tquickSort(nodes, 0, length-1);\r", "+\t\tfor (int i=0;i<length;i++) {\r", "+\t\t\tAstNode node = nodes[i];\r", "+\t\t\tif (node instanceof ImportReference) {\r", "+\t\t\t\tImportReference importRef = (ImportReference)node;\r", "+\t\t\t\tif (node == compilationUnit.currentPackage) {\r", "+\t\t\t\t\tnotifySourceElementRequestor(importRef, true);\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tnotifySourceElementRequestor(importRef, false);\r", "+\t\t\t\t}\r", "+\t\t\t} else { // instanceof TypeDeclaration\r", "+\t\t\t\tnotifySourceElementRequestor((TypeDeclaration)node, sourceType == null);\r", "+\t\t\t}\r", "+\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "792a19dec151ccb5fa4172848c4ac49d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/impl/IndexSummary.java", "commitBeforeChange": "eaed8b4c57bf985bb0b4f36634f058b94194b2e7", "commitAfterChange": "9b0b9be20fe15cfaaf5f2085fd6c89bedb4ddb87", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " public int getFirstBlockLocationForPrefix(char[] prefix)", "signatureAfterChange": " public int getFirstBlockLocationForPrefix(char[] prefix)", "diff": ["-\treturn getFirstBlockLocationForPrefix(prefix, true);", "-}", "+\t\tint compare = CharOperation.compareWith(entry.word, prefix);", "+\t\t\tif (!CharOperation.prefixEquals(prefix, entry.word))"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7cdfb691d81e6a194abb212ae1cd228a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java", "commitBeforeChange": "a3da1013b6fe549ad5c2ee5b7dc726eba38ff59e", "commitAfterChange": "30692448718de71df165cc52c018bee7df31a8fb", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public char[] getGenericSignature()", "signatureAfterChange": " public char[] getGenericSignature()", "diff": ["-\treturn null;", "+\tif (this.typeParameterSignatures != null && this.genericSignature == null) {", "+\t\tStringBuffer buffer = new StringBuffer();", "+\t\tbuffer.append('<');", "+\t\tfor (int i = 0, length = this.typeParameterSignatures.length; i < length; i++) {", "+\t\t\tbuffer.append(this.typeParameterSignatures[i]);", "+\t\t\tif (i != length-1)", "+\t\t\t\tbuffer.append(',');", "+\t\t}", "+\t\tbuffer.append('>');", "+\t\tif (this.superclass == null)", "+\t\t\tbuffer.append(Signature.createTypeSignature(\"java.lang.Object\", true/*resolved*/)); //$NON-NLS-1$", "+\t\telse", "+\t\t\tbuffer.append(Signature.createTypeSignature(this.superclass, true/*resolved*/));", "+\t\tif (this.superInterfaces != null) ", "+\t\t\tfor (int i = 0, length = this.superInterfaces.length; i < length; i++)", "+\t\t\t\tbuffer.append(Signature.createTypeSignature(this.superInterfaces[i], true/*resolved*/));", "+\t\tthis.genericSignature = buffer.toString().toCharArray();", "+\t\tCharOperation.replace(this.genericSignature, '.', '/');", "+\t}", "+\treturn this.genericSignature;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "851d9bad45958ec05e3ad2138fd4466e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java", "commitBeforeChange": "e719dd5a3586c01e5265dc68f8e6023c180424cf", "commitAfterChange": "4e66475f9a73014d666c99c51fe059857a4663fa", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r \tpublic void findTypes(char[] prefix, final ISearchRequestor storage)", "signatureAfterChange": "\r \tpublic void findTypes(char[] prefix, final ISearchRequestor storage)", "diff": ["-\t\t\tIProject projectRsc = (IProject) this.project.getUnderlyingResource();\r", "-\t\t\tIJavaSearchScope scope =\r", "-\t\t\t\tsearchEngine.createJavaSearchScope(new IResource[] { projectRsc });\r", "-\r", "+\t\t\t// Collect the project and its prerequisites (ie. referenced projects and jars)\r", "+\t\t\tJavaSearchScope scope = new JavaSearchScope();\r", "+\t\t\tIWorkspaceRoot root = this.project.getUnderlyingResource().getWorkspace().getRoot();\r", "+\t\t\tIClasspathEntry[] entries = this.project.getExpandedClasspath(true);\r", "+\t\t\tfor (int i = 0, length = entries.length; i < length; i++) {\r", "+\t\t\t\tIClasspathEntry entry = entries[i];\r", "+\t\t\t\tswitch (entry.getEntryKind()) {\r", "+\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:\r", "+\t\t\t\t\t\tscope.add(root.getFile(entry.getPath()), false);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase IClasspathEntry.CPE_PROJECT:\r", "+\t\t\t\t\t\tscope.add(root.getProject(entry.getPath().lastSegment()), false);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase IClasspathEntry.CPE_SOURCE:\r", "+\t\t\t\t\t\tIPath path = entry.getPath();\r", "+\t\t\t\t\t\tif (path.segmentCount() == 1) {\r", "+\t\t\t\t\t\t\t// project is source\r", "+\t\t\t\t\t\t\tscope.add(root.getProject(path.lastSegment()), false);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t// regular source folder\r", "+\t\t\t\t\t\t\tscope.add(root.getFolder(path), false);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\t\r", "-\t\t\t\t\tprojectRsc.getWorkspace(),\r", "+\t\t\t\t\tthis.project.getUnderlyingResource().getWorkspace(),\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93fe7f0f8061ae1dc819dda5dcd928da", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/newbuilder/State.java", "commitBeforeChange": "4e88e1625bb1c2659a2ee4ba931e466f5126f9f4", "commitAfterChange": "075da32620f3ceb13a370a8be8550de2baf091f1", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \r void write(DataOutputStream out) throws IOException", "signatureAfterChange": "\r \r void write(DataOutputStream out) throws IOException", "diff": ["+\tint length;\r", "+\tObject[] keyTable;\r", "+\tObject[] valueTable;\r", "+\r", "+/*\r", "+ * byte\t\t\tVERSION\r", "+ * String\t\tproject name\r", "+ * int\t\t\t\tbuild number\r", "+ * int\t\t\t\tlast structural build number\r", "+ * String\t\toutput location\r", "+*/\r", "-\tint length = classpathLocations.length;\r", "-\tout.writeInt(length);\r", "+/*\r", "+ * Class path locations[]\r", "+ * int\t\t\t\tid\r", "+ * String\t\tpath(s)\r", "+*/\r", "+\tout.writeInt(length = classpathLocations.length);\r", "-\tlength = structuralBuildNumbers.size();\r", "-\tout.writeInt(length);\r", "+/*\r", "+ * Structural build numbers table\r", "+ * String\t\tprereq project name\r", "+ * int\t\t\t\tlast structural build number\r", "+*/\r", "+\tout.writeInt(length = structuralBuildNumbers.elementSize);\r", "-\t\tObject[] keyTable = structuralBuildNumbers.keyTable;\r", "-\t\tObject[] valueTable = structuralBuildNumbers.valueTable;\r", "+\t\tkeyTable = structuralBuildNumbers.keyTable;\r", "+\t\tvalueTable = structuralBuildNumbers.valueTable;\r", "+/*\r", "+ * String[]\t\tInterned locations\r", "+ */\r", "+\tout.writeInt(length = references.elementSize);\r", "+\tArrayList internedLocations = new ArrayList(length);\r", "+\tkeyTable = references.keyTable;\r", "+\tfor (int i = 0, l = keyTable.length; i < l; i++) {\r", "+\t\tif (keyTable[i] != null) {\r", "+\t\t\tString key = (String) keyTable[i];\r", "+\t\t\tout.writeUTF(key);\r", "+\t\t\tinternedLocations.add(key);\r", "+\t\t}\r", "+\t}\r", "+\r", "+/*\r", "+ * Type locations table\r", "+ * String\t\ttype name\r", "+ * int\t\t\t\tinterned location id\r", "+ */\r", "+\tout.writeInt(length = typeLocations.elementSize);\r", "+\tif (length > 0) {\r", "+\t\tkeyTable = typeLocations.keyTable;\r", "+\t\tvalueTable = typeLocations.valueTable;\r", "+\t\tfor (int i = 0, l = keyTable.length; i < l; i++) {\r", "+\t\t\tif (keyTable[i] != null) {\r", "+\t\t\t\tout.writeUTF((String) keyTable[i]);\r", "+\t\t\t\tout.writeInt(internedLocations.indexOf((String) valueTable[i]));\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r", "+\r", "+/*\r", "+ * char[][][]\tInterned qualified names\r", "+ * char[][]\t\tInterned simple names\r", "+ */\r", "-\tObject[] valueTable = references.valueTable;\r", "+\tvalueTable = references.valueTable;\r", "-\tlength = internedQualifiedNames.size();\r", "-\tout.writeInt(length);\r", "+\tout.writeInt(length = internedQualifiedNames.size());\r", "-\tlength = references.size();\r", "-\tout.writeInt(length);\r", "-\tObject[] keyTable = references.keyTable;\r", "+/*\r", "+ * References table\r", "+ * int\t\t\tinterned location id\r", "+ * ReferenceCollection\r", "+*/\r", "+\tout.writeInt(length = references.elementSize);\r", "+\tkeyTable = references.keyTable;\r", "-\t\t\tout.writeUTF((String) keyTable[i]);\r", "+\t\t\tout.writeInt(internedLocations.indexOf((String) keyTable[i]));\r", "-\t\t\t\twriteNames(atc.additionalTypeNames, out);\r", "+\t\t\t\twriteNames(atc.definedTypeNames, out);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "97c09da05c8498a1b1417e5d4e274244", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java", "commitBeforeChange": "70e6cb7abc9d1f82b12c9182e5b9d5f442b62682", "commitAfterChange": "96e2d72045a6fecadbb495cf120a991e9af97b69", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tprivate void generateCode( \t\tClassScope classScope, \t\tClassFile classFile, \t\tint clinitOffset)", "signatureAfterChange": " \tprivate void generateCode( \t\tClassScope classScope, \t\tClassFile classFile, \t\tint clinitOffset)", "diff": ["+\t\tint remainingFieldCount = 0;", "-\t\t\tint enumCount = 0;", "-\t\t\tint remainingFieldCount = 0;", "-\t\t\tif (fieldDeclarations != null) {", "+\t\t\tint enumCount = declaringType.enumConstantsCounter;", "+\t\t\tif (enumCount > ENUM_CONSTANTS_THRESHOLD) {", "+\t\t\t\t// generate synthetic methods to initialize all the enum constants", "+\t\t\t\tint begin = -1;", "+\t\t\t\tint count = 0;", "+\t\t\t\tif (fieldDeclarations != null) {", "+\t\t\t\t\tint max = fieldDeclarations.length;", "+\t\t\t\t\tfor (int i = 0; i < max; i++) {", "+\t\t\t\t\t\tFieldDeclaration fieldDecl = fieldDeclarations[i];", "+\t\t\t\t\t\tif (fieldDecl.isStatic()) {", "+\t\t\t\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT) {", "+\t\t\t\t\t\t\t\tif (begin == -1) {", "+\t\t\t\t\t\t\t\t\tbegin = i;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tcount++;", "+\t\t\t\t\t\t\t\tif (count > ENUM_CONSTANTS_THRESHOLD) {", "+\t\t\t\t\t\t\t\t\tSyntheticMethodBinding syntheticMethod = declaringType.binding.addSyntheticMethodForEnumInitialization(begin, i);", "+\t\t\t\t\t\t\t\t\tcodeStream.invoke(Opcodes.OPC_invokestatic, syntheticMethod, null /* default declaringClass */);", "+\t\t\t\t\t\t\t\t\tbegin = -1;", "+\t\t\t\t\t\t\t\t\tcount = 0;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (count != 0) {", "+\t\t\t\t\t\t// add last synthetic method", "+\t\t\t\t\t\tSyntheticMethodBinding syntheticMethod = declaringType.binding.addSyntheticMethodForEnumInitialization(begin, max);", "+\t\t\t\t\t\tcodeStream.invoke(Opcodes.OPC_invokestatic, syntheticMethod, null /* default declaringClass */);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else if (fieldDeclarations != null) {", "-\t\t\t\t\t\t\tenumCount++;", "-\t\t\t\tfor (int i = 0, max = fieldDeclarations.length; i < max; i++) {", "+\t\t\t\tfor (int i = 0, max = fieldDeclarations.length; i < max && remainingFieldCount >= 0; i++) {", "-\t\t\t\t\t\t\tif (!fieldDecl.isStatic())", "+\t\t\t\t\t\t\tif (!fieldDecl.isStatic()) {", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tremainingFieldCount--;", "-\t\t\t\t\t\t\tif (!fieldDecl.binding.isStatic())", "+\t\t\t\t\t\t\tif (!fieldDecl.binding.isStatic()) {", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tremainingFieldCount--;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9a1e813aaeda94375cdc05ad34c5a74b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "c0a0c19db3e1c410023eabce30626d520ce59204", "commitAfterChange": "b522a66d284b0239a056370560676a12fc9ec458", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 62, "signatureBeforeChange": "\r \tprotected IClasspathEntry[] readPaths(String xmlClasspath) throws IOException", "signatureAfterChange": "\r \tprotected IClasspathEntry[] readPaths(String xmlClasspath) throws IOException", "diff": ["-\t\tIPath projectPath= getProject().getFullPath();\r", "+\r", "+\t\tIPath projectPath = getProject().getFullPath();\r", "+\r", "-\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\r", "+\t\t\tDocumentBuilder parser =\r", "+\t\t\t\tDocumentBuilderFactory.newInstance().newDocumentBuilder();\r", "-\t\t} catch(SAXException e) {\r", "+\t\t} catch (SAXException e) {\r", "-\t\t} catch(ParserConfigurationException e){\r", "+\t\t} catch (ParserConfigurationException e) {\r", "+\r", "-\t\tNodeList list= cpElement.getChildNodes();\r", "-\t\tVector paths= new Vector();\r", "-\t\tint length= list.getLength();\r", "-\t\tfor (int i= 0; i < length; ++i) {\r", "-\t\t\tNode node= list.item(i);\r", "-\t\t\tshort type= node.getNodeType();\r", "+\t\tNodeList list = cpElement.getChildNodes();\r", "+\t\tVector paths = new Vector();\r", "+\t\tint length = list.getLength();\r", "+\r", "+\t\tfor (int i = 0; i < length; ++i) {\r", "+\t\t\tNode node = list.item(i);\r", "+\t\t\tshort type = node.getNodeType();\r", "-\t\t\t\tElement cpeElement= (Element) node;\r", "-\t\t\t\tif (cpeElement.getNodeName().equalsIgnoreCase(\"classpathentry\")) { //$NON-NLS-1$\r", "+\t\t\t\tElement cpeElement = (Element) node;\r", "+\r", "+\t\t\t\tif (cpeElement.getNodeName().equalsIgnoreCase(\"classpathentry\")) {\r", "+\t\t\t\t\t//$NON-NLS-1$\r", "-\t\t\t\t\tIPath path= new Path(pathStr);\r", "-\t\t\t\t\tint kind= kindFromString(cpeElementKind);\r", "+\t\t\t\t\tIPath path = new Path(pathStr);\r", "+\t\t\t\t\tint kind = kindFromString(cpeElementKind);\r", "-\t\t\t\t\t\tpath= projectPath.append(path);\r", "+\t\t\t\t\t\tpath = projectPath.append(path);\r", "-\t\t\t\t\tString sourceAttachmentPathStr = cpeElement.getAttribute(\"sourcepath\"); //$NON-NLS-1$\r", "-\t\t\t\t\tIPath sourceAttachmentPath = sourceAttachmentPathStr.equals(\"\") ? null : new Path(sourceAttachmentPathStr); //$NON-NLS-1$\r", "+\t\t\t\t\tString sourceAttachmentPathStr = cpeElement.getAttribute(\"sourcepath\");\t//$NON-NLS-1$\r", "+\t\t\t\t\tIPath sourceAttachmentPath =\r", "+\t\t\t\t\t\tsourceAttachmentPathStr.equals(\"\") ? null : new Path(sourceAttachmentPathStr); //$NON-NLS-1$\r", "-\t\t\t\t\tIPath sourceAttachmentRootPath = sourceAttachmentRootPathStr.equals(\"\") ? null : new Path(sourceAttachmentRootPathStr); //$NON-NLS-1$\r", "+\t\t\t\t\tIPath sourceAttachmentRootPath =\r", "+\t\t\t\t\t\tsourceAttachmentRootPathStr.equals(\"\") //$NON-NLS-1$\r", "+\t\t\t\t\t\t\t? null\r", "+\t\t\t\t\t\t\t: new Path(sourceAttachmentRootPathStr);\r", "-\t\t\t\t\tIClasspathEntry entry= createClasspathEntry(path, kind, sourceAttachmentPath, sourceAttachmentRootPath);\r", "-\t\t\t\t\tif (entry == null) return null;\r", "-\t\t\t\t\tpaths.addElement(entry);\r", "+\t\t\t\t\t// exported flag\r", "+\t\t\t\t\tboolean isExported = cpeElement.getAttribute(\"exported\").equals(\"true\"); //$NON-NLS-1$ //$NON-NLS-2$\r", "+\r", "+\t\t\t\t\t// recreate the CP entry\r", "+\t\t\t\t\tswitch (kind) {\r", "+\t\t\t\r", "+\t\t\t\t\t\tcase IClasspathEntry.CPE_PROJECT :\r", "+\t\t\t\t\t\t\tif (!path.isAbsolute()) return null;\r", "+\t\t\t\t\t\t\tpaths.addElement(JavaCore.newProjectEntry(path, isExported));\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY :\r", "+\t\t\t\t\t\t\tif (!path.isAbsolute()) return null;\r", "+\t\t\t\t\t\t\tpaths.addElement(JavaCore.newLibraryEntry(\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpath,\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceAttachmentPath,\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceAttachmentRootPath,\r", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tisExported));\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\tcase IClasspathEntry.CPE_SOURCE :\r", "+\t\t\t\t\t\t\tif (!path.isAbsolute()) return null;\r", "+\t\t\t\t\t\t\t// must be an entry in this project or specify another project\r", "+\t\t\t\t\t\t\tString projSegment = path.segment(0);\r", "+\t\t\t\t\t\t\tif (projSegment != null && projSegment.equals(getElementName())) {\r", "+\t\t\t\t\t\t\t\t// this project\r", "+\t\t\t\t\t\t\t\tpaths.addElement(JavaCore.newSourceEntry(path));\r", "+\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t// another project\r", "+\t\t\t\t\t\t\t\tpaths.addElement(JavaCore.newProjectEntry(path, isExported));\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\r", "+\t\t\t\t\t\tcase IClasspathEntry.CPE_VARIABLE :\r", "+\t\t\t\t\t\t\tpaths.addElement(JavaCore.newVariableEntry(\r", "+\t\t\t\t\t\t\t\t\tpath,\r", "+\t\t\t\t\t\t\t\t\tsourceAttachmentPath,\r", "+\t\t\t\t\t\t\t\t\tsourceAttachmentRootPath, \r", "+\t\t\t\t\t\t\t\t\tisExported));\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\tcase ClasspathEntry.K_OUTPUT :\r", "+\t\t\t\t\t\t\tif (!path.isAbsolute()) return null;\r", "+\t\t\t\t\t\t\tpaths.addElement(new ClasspathEntry(\r", "+\t\t\t\t\t\t\t\t\tClasspathEntry.K_OUTPUT,\r", "+\t\t\t\t\t\t\t\t\tIClasspathEntry.CPE_LIBRARY,\r", "+\t\t\t\t\t\t\t\t\tpath,\r", "+\t\t\t\t\t\t\t\t\tnull,\r", "+\t\t\t\t\t\t\t\t\tnull,\r", "+\t\t\t\t\t\t\t\t\tfalse));\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t}\r", "-\t\t\tIClasspathEntry[] ips= new IClasspathEntry[paths.size()];\r", "+\t\t\tIClasspathEntry[] ips = new IClasspathEntry[paths.size()];\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9a658349e3a2ed114fee693c844df515", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "0243628c08ab4b4900a7554ddbc8a451c6a47550", "commitAfterChange": "047584befb8673c45fb37a5eec1f22e3adb791d0", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  \tprivate void selectFrom(Binding binding, CompilationUnitDeclaration parsedUnit, boolean isDeclaration)", "signatureAfterChange": "  \tprivate void selectFrom(Binding binding, CompilationUnitDeclaration parsedUnit, boolean isDeclaration)", "diff": ["+\t\t\t\t\tTypeVariableBinding[] typeVariables = methodBinding.original().typeVariables;", "+\t\t\t\t\tlength = typeVariables == null ? 0 : typeVariables.length;", "+\t\t\t\t\tchar[][] typeParameterNames = new char[length][];", "+\t\t\t\t\tchar[][][] typeParameterBoundNames = new char[length][][];", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\tTypeVariableBinding typeVariable = typeVariables[i];", "+\t\t\t\t\t\ttypeParameterNames[i] = typeVariable.sourceName;", "+\t\t\t\t\t\tif (typeVariable.firstBound == null) {", "+\t\t\t\t\t\t\ttypeParameterBoundNames[i] = new char[0][];", "+\t\t\t\t\t\t} else if (typeVariable.firstBound == typeVariable.superclass) {", "+\t\t\t\t\t\t\tint boundCount = 1 + (typeVariable.superInterfaces == null ? 0 : typeVariable.superInterfaces.length);", "+\t\t\t\t\t\t\ttypeParameterBoundNames[i] = new char[boundCount][];", "+\t\t\t\t\t\t\ttypeParameterBoundNames[i][0] = typeVariable.superclass.sourceName;", "+\t\t\t\t\t\t\tfor (int j = 1; j < boundCount; j++) {", "+\t\t\t\t\t\t\t\ttypeParameterBoundNames[i][j] = typeVariables[i].superInterfaces[j - 1].sourceName;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tint boundCount = typeVariable.superInterfaces == null ? 0 : typeVariable.superInterfaces.length;", "+\t\t\t\t\t\t\ttypeParameterBoundNames[i] = new char[boundCount][];", "+\t\t\t\t\t\t\tfor (int j = 0; j < boundCount; j++) {", "+\t\t\t\t\t\t\t\ttypeParameterBoundNames[i][j] = typeVariables[i].superInterfaces[j].sourceName;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t\t\ttypeParameterNames,", "+\t\t\t\t\t\t\ttypeParameterBoundNames,"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9cda996db5b2ad6e35671dce7abf750c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTest.java", "commitBeforeChange": "474eb5356258f18fd9cfbd1a24f6dbe20ed6eea5", "commitAfterChange": "b0f361db26dd11f4be4974027111b70136b11d5b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic void tearDownSuite() throws Exception", "signatureAfterChange": "  \tprivate static int getASTLevelsForTest(String name)", "diff": ["-", "-\tpublic void tearDownSuite() throws Exception {", "-\t\tsuper.tearDownSuite();", "+\tprivate static int getASTLevelsForTest(String name) {", "+\t\tint index = name.indexOf(ONLY_AST_STRING);", "+\t\tint levels = 0;", "+\t\tif (index == -1) {", "+\t\t\tindex = name.indexOf(SINCE_AST_STRING);", "+\t\t\tif (index != -1) {", "+\t\t\t\tString subString = name.substring(index, name.length());", "+\t\t\t\tif (subString.indexOf(STRING_8) != -1) {", "+\t\t\t\t\treturn LEVEL_8;", "+\t\t\t\t} else if (subString.indexOf(STRING_4) != -1) {", "+\t\t\t\t\treturn SINCE_4;", "+\t\t\t\t} else if (subString.indexOf(STRING_3) != -1) {", "+\t\t\t\t\treturn SINCE_3;", "+\t\t\t\t} else {", "+\t\t\t\t\treturn SINCE_2;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\tString subString = name.substring(index, name.length());", "+\t\t\tif (subString.indexOf(STRING_2) != -1) {", "+\t\t\t\tlevels |= LEVEL_2;", "+\t\t\t}", "+\t\t\tif (subString.indexOf(STRING_3) != -1) {", "+\t\t\t\tlevels |= LEVEL_3;", "+\t\t\t}", "+\t\t\tif (subString.indexOf(STRING_4) != -1) {", "+\t\t\t\tlevels |= LEVEL_4;", "+\t\t\t}", "+\t\t\tif (subString.indexOf(STRING_8) != -1) {", "+\t\t\t\tlevels |= LEVEL_8;", "+\t\t\t}", "+\t\t\treturn levels;", "+\t\t}", "+\t\treturn SINCE_2;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bc61ebbbf920de4f5af90e9e9f46b20d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/AllPerformanceTests.java", "commitBeforeChange": "f15f3a4daa4f7cbf363475bdb20d4707912f834f", "commitAfterChange": "1e2211eded7d5ae87dfcf507bb00676a5a81d8e9", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic static Test suite()", "signatureAfterChange": " \tpublic static Test suite()", "diff": ["+\t}", "+", "+\t\t// Reset subsets of tests (after having test classes loaded", "+\t\tTestCase.TESTS_NAMES = null;", "+\t\tTestCase.TESTS_PREFIX = null;", "+\t\tTestCase.TESTS_NUMBERS = null;", "+\t\tTestCase.TESTS_RANGE = null;", "+", "+\t\t// Get test suites subset", "+\t\tif (COMPLETE != null) {", "+\t\t\tint pos = -1;", "+\t\t\ttry {", "+\t\t\t\tpos = Integer.parseInt(COMPLETE);", "+\t\t\t\tClass[] complete = getCompleteClasses();", "+\t\t\t\tint cl = complete.length;", "+\t\t\t\tClass[] newSuites = new Class[length+cl];", "+\t\t\t\tif (pos <= 0) {", "+\t\t\t\t\tSystem.arraycopy(complete, 0, newSuites, 0, cl);", "+\t\t\t\t\tSystem.arraycopy(testSuites, 0, newSuites, cl, length);", "+\t\t\t\t} else if (pos >= length) {", "+\t\t\t\t\tSystem.arraycopy(testSuites, 0, newSuites, 0, length);", "+\t\t\t\t\tSystem.arraycopy(complete, 0, newSuites, length, cl);", "+\t\t\t\t} else {", "+\t\t\t\t\tfor (int i=0; i<pos; i++)", "+\t\t\t\t\t\tnewSuites[i] = testSuites[i];", "+\t\t\t\t\tfor (int i=pos; i<pos+cl; i++)", "+\t\t\t\t\t\tnewSuites[i] = complete[i-pos];", "+\t\t\t\t\tfor (int i=pos+cl; i<length+cl; i++)", "+\t\t\t\t\t\tnewSuites[i] = testSuites[i-cl];", "+\t\t\t\t}", "+\t\t\t\ttestSuites = newSuites;", "+\t\t\t\tlength = testSuites.length;", "+\t\t\t} catch (NumberFormatException e1) {", "+\t\t\t\t// do nothing", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Get tests of suites"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "be53a70cd6e2eeb35300bc0bc834d07a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java", "commitBeforeChange": "7dce3ced6f2c34a63721a3fda038e2fad50139b7", "commitAfterChange": "4a258c24dea43b906f3daa4041c94e7315633dfe", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 6, "signatureBeforeChange": " protected char[] indexEntryPrefix()", "signatureAfterChange": " public char[] encodeIndexKey()", "diff": ["-protected char[] indexEntryPrefix() {", "-\tchar[] packageName = this.isCaseSensitive ? pkg : null;", "+ */", "+public char[] encodeIndexKey() {", "+\tchar[] packageName = isCaseSensitive() ? pkg : null;", "-\t\t\tif (packageName == null) return CLASS_DECL;", "+\t\t\tif (packageName == null) ", "+\t\t\t\treturn new char[] {CLASS_SUFFIX, SEPARATOR};", "-\t\t\tif (packageName == null) return INTERFACE_DECL;", "+\t\t\tif (packageName == null) ", "+\t\t\t\treturn new char[] {INTERFACE_SUFFIX, SEPARATOR};", "-\t\t\treturn TYPE_DECL; // cannot do better given encoding", "+\t\t\treturn CharOperation.NO_CHAR; // cannot do better given encoding", "-\tchar[] typeName = this.isCaseSensitive ? simpleName : null;", "-\tif (typeName != null && this.matchMode == PATTERN_MATCH) {", "+\tchar[] typeName = isCaseSensitive() ? this.simpleName : null;", "+\tif (typeName != null && matchMode() == PATTERN_MATCH) {", "-\tint typeLength = typeName == null ? 0 : typeName.length;", "-\tint pos = TYPE_DECL_LENGTH;", "-\tchar[] result = new char[pos + packageLength + typeLength + 3];", "-\tSystem.arraycopy(TYPE_DECL, 0, result, 0, pos);", "-\tresult[pos++] = classOrInterface;", "+\tint enclosingTypeNamesLength = 0;", "+\tif (this.enclosingTypeNames != null)", "+\t\tfor (int i = 0, length = this.enclosingTypeNames.length; i < length; i++)", "+\t\t\tenclosingTypeNamesLength += this.enclosingTypeNames[i].length + 1;", "+\tint pos = 0;", "+\tint typeNameLength = typeName == null ? 0 : typeName.length;", "+\tint resultLength = pos + packageLength + typeNameLength + enclosingTypeNamesLength + 4;", "+\tchar[] result = new char[resultLength];", "+\tresult[pos++] = this.classOrInterface;", "-\tSystem.arraycopy(packageName, 0, result, pos, packageLength);", "-\tpos += packageLength;", "+\tif (packageLength > 0) {", "+\t\tSystem.arraycopy(packageName, 0, result, pos, packageLength);", "+\t\tpos += packageLength;", "+\t}", "-\tif (typeLength > 0)", "-\t\tSystem.arraycopy(typeName, 0, result, pos, typeName.length);", "+\tif (typeName != null) {", "+\t\tSystem.arraycopy(typeName, 0, result, pos, typeNameLength);", "+\t\tpos += typeNameLength;", "+", "+\t\tresult[pos++] = SEPARATOR;", "+\t\tif (enclosingTypeNames != null) {", "+\t\t\tfor (int i = 0, length = this.enclosingTypeNames.length; i < length; i++) {", "+\t\t\t\tint enclosingTypeNameLength = this.enclosingTypeNames[i].length;", "+\t\t\t\tSystem.arraycopy(this.enclosingTypeNames[i], 0, result, pos, enclosingTypeNameLength);", "+\t\t\t\tpos += enclosingTypeNameLength;", "+\t\t\t\tresult[pos++] = SEPARATOR;", "+\t\t\t}", "+\t\t}", "+\t}", "+\tif (pos != resultLength) {", "+\t\tSystem.arraycopy(result, 0, result = new char[pos], 0, pos);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d8d4f663acda3adf9336953fcfce2cf8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "4b4dbca0bb97a8d7d91d56de2e2d0246704ead9c", "commitAfterChange": "f45c88f3e7a99f05a0822482d3d6807236a1c216", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 31, "signatureBeforeChange": " \tpublic String toString()", "signatureAfterChange": " \tpublic String toString()", "diff": ["-\t\tIPath[] patterns = getInclusionPatterns();", "+\t\tIPath[] patterns = this.inclusionPatterns;", "-\t\tpatterns = getExclusionPatterns();", "+\t\tpatterns = this.exclusionPatterns;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tbuffer.append(patterns[i]);", "+\t\t\t\tif (i != length-1) {", "+\t\t\t\t\tbuffer.append('|');", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbuffer.append(']');", "+\t\t}", "+\t\tpatterns = getAccessibleFiles();", "+\t\tif ((length = patterns == null ? 0 : patterns.length) > 0) {", "+\t\t\tbuffer.append(\"[accessible files:\"); //$NON-NLS-1$", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tbuffer.append(patterns[i]);", "+\t\t\t\tif (i != length-1) {", "+\t\t\t\t\tbuffer.append('|');", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbuffer.append(']');", "+\t\t}", "+\t\tpatterns = getNonAccessibleFiles();", "+\t\tif ((length = patterns == null ? 0 : patterns.length) > 0) {", "+\t\t\tbuffer.append(\"[non accessible files:\"); //$NON-NLS-1$", "+\t\tif ((length = this.extraAttributes == null ? 0 : this.extraAttributes.length) > 0) {", "+\t\t\tbuffer.append(\"[attributes:\"); //$NON-NLS-1$", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tbuffer.append(this.extraAttributes[i]);", "+\t\t\t\tif (i != length-1) {", "+\t\t\t\t\tbuffer.append(',');", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbuffer.append(']');", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e9d9062c647a0807e1e93dde37ea1eeb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "6a44e0777af1a4632e0d20c0e9b92d35d2ad59f3", "commitAfterChange": "2ca339c139c0fe73a5bd2705f66592731098d347", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic StringBuffer print(int indent, StringBuffer output)", "signatureAfterChange": " \tpublic StringBuffer print(int indent, StringBuffer output)", "diff": ["+\t\tprintIndent(indent, output).append(\"/**\\n\"); //$NON-NLS-1$", "+\t\tif (this.parameters != null) {", "+\t\t\tfor (int i = 0, length = this.parameters.length; i < length; i++) {", "+\t\t\t\tprintIndent(indent+1, output).append(\" * @param \"); //$NON-NLS-1$\t\t", "+\t\t\t\tthis.parameters[i].print(indent, output).append('\\n');", "+\t\t\t}", "+\t\t}", "+\t\tif (this.thrownExceptions != null) {", "+\t\t\tfor (int i = 0, length = this.thrownExceptions.length; i < length; i++) {", "+\t\t\t\tprintIndent(indent+1, output).append(\" * @throws \"); //$NON-NLS-1$\t\t", "+\t\t\t\tthis.thrownExceptions[i].print(indent, output).append('\\n');", "+\t\t\t}", "+\t\t}", "+\t\tif (this.references != null) {", "+\t\t\tfor (int i = 0, length = this.references.length; i < length; i++) {", "+\t\t\t\tprintIndent(indent+1, output).append(\" * @see\"); //$NON-NLS-1$\t\t", "+\t\t\t\tthis.references[i].print(indent, output).append('\\n');", "+\t\t\t}", "+\t\t}", "+\t\tprintIndent(indent, output).append(\" */\\n\"); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ee592fb0e722f8e23cbba183376db3f0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java", "commitBeforeChange": "c4112ab397da10b85cbb2a3f081c4c91ed7c7975", "commitAfterChange": "2077df1da6fa132fd5beb7d042b102e760cf8cbf", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "  void write(DataOutputStream out) throws IOException", "signatureAfterChange": "  void write(DataOutputStream out) throws IOException", "diff": ["+ * char[][]\tInterned root names", "+\tSimpleLookupTable internedRootNames = new SimpleLookupTable(3);", "+\t\t\tchar[][] rNames = collection.rootReferences;", "+\t\t\tfor (int j = 0, m = rNames.length; j < m; j++) {", "+\t\t\t\tchar[] rName = rNames[j];", "+\t\t\t\tif (!internedRootNames.containsKey(rName)) // remember the names have been interned", "+\t\t\t\t\tinternedRootNames.put(rName, new Integer(internedRootNames.elementSize));", "+\t\t\t}", "-\tchar[][] internedArray = new char[internedSimpleNames.elementSize][];", "+\tchar[][] internedArray = new char[internedRootNames.elementSize][];", "+\tObject[] rootNames = internedRootNames.keyTable;", "+\tObject[] positions = internedRootNames.valueTable;", "+\tfor (int i = positions.length; --i >= 0; ) {", "+\t\tif (positions[i] != null) {", "+\t\t\tint index = ((Integer) positions[i]).intValue();", "+\t\t\tinternedArray[index] = (char[]) rootNames[i];", "+\t\t}", "+\t}", "+\twriteNames(internedArray, out);", "+\t// now write the interned simple names", "+\tinternedArray = new char[internedSimpleNames.elementSize][];", "-\tObject[] positions = internedSimpleNames.valueTable;", "+\tpositions = internedSimpleNames.valueTable;", "+\t\t\t\tchar[][] rNames = collection.rootReferences;", "+\t\t\t\tint rLength = rNames.length;", "+\t\t\t\tout.writeInt(rLength);", "+\t\t\t\tfor (int j = 0; j < rLength; j++) {", "+\t\t\t\t\tindex = (Integer) internedRootNames.get(rNames[j]);", "+\t\t\t\t\tout.writeInt(index.intValue());", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fbadda35fd57886257a47a5b025b0d3a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java", "commitBeforeChange": "f711a2e15fc3de73f79ccc61d2dafcbdd0d9f0f1", "commitAfterChange": "e823242f8d03d0ef2504eab819b418e785f092ee", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "  \tprivate String getLocalVariableName(int pc, int index, boolean showIndex)", "signatureAfterChange": "  \tprivate String getLocalVariableName(int pc, int index, boolean showIndex)", "diff": ["-        int nextPC = pc + 1;", "-        switch(index) {", "-            case 0 :", "-            case 1 :", "-            case 2 :", "-            case 3 :", "-                break;", "-            default :", "-                nextPC = index <= 255 ? pc + 2 : pc + 3;", "-        }", "+\t\tint nextPC = pc + 1;", "+\t\tswitch(index) {", "+\t\t\tcase 0 :", "+\t\t\tcase 1 :", "+\t\t\tcase 2 :", "+\t\t\tcase 3 :", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\tnextPC = index <= 255 ? pc + 2 : pc + 3;", "+\t\t}", "-        for (int i = 0, max = this.localVariableAttributeLength; i < max; i++) {", "-            final ILocalVariableTableEntry entry = this.localVariableTableEntries[i];", "-            final int startPC = entry.getStartPC();", "-            if (entry.getIndex() == index && (startPC <= nextPC) && ((startPC + entry.getLength()) > nextPC)) {", "-            \tfinal StringBuffer stringBuffer = new StringBuffer();", "-            \tif (showIndex) {", "-            \t\tstringBuffer.append(' ').append(index);", "-            \t}", "-            \tstringBuffer.append(' ').append('[').append(entry.getName()).append(']');", "-            \treturn String.valueOf(stringBuffer);", "-            }", "-        }", "-    \tif (showIndex) {", "-        \tfinal StringBuffer stringBuffer = new StringBuffer();", "-        \tstringBuffer.append(' ').append(index);", "-         \treturn String.valueOf(stringBuffer);", "-    \t}", "-        return EMPTY_LOCAL_NAME;", "+\t\tfor (int i = 0, max = this.localVariableAttributeLength; i < max; i++) {", "+\t\t\tfinal ILocalVariableTableEntry entry = this.localVariableTableEntries[i];", "+\t\t\tfinal int startPC = entry.getStartPC();", "+\t\t\tif (entry.getIndex() == index && (startPC <= nextPC) && ((startPC + entry.getLength()) > nextPC)) {", "+\t\t\t\tfinal StringBuffer stringBuffer = new StringBuffer();", "+\t\t\t\tif (showIndex) {", "+\t\t\t\t\tstringBuffer.append(' ').append(index);", "+\t\t\t\t}", "+\t\t\t\tstringBuffer.append(' ').append('[').append(entry.getName()).append(']');", "+\t\t\t\treturn String.valueOf(stringBuffer);", "+\t\t\t}", "+\t\t}", "+\t\tif (this.parameterNames != null) {", "+\t\t\tif (index == 0) {", "+\t\t\t\tif (!this.isStatic) {", "+\t\t\t\t\tfinal StringBuffer stringBuffer = new StringBuffer();", "+\t\t\t\t\tstringBuffer.append(' ').append('[').append(\"this\").append(']'); //$NON-NLS-1$", "+\t\t\t\t\treturn String.valueOf(stringBuffer);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tint indexInParameterNames = index;", "+\t\t\tif (index != 0) {", "+\t\t\t\tint resolvedPosition = 0;", "+\t\t\t\tif (!this.isStatic) {", "+\t\t\t\t\tresolvedPosition = 1;", "+\t\t\t\t}", "+\t\t\t\tint i = 0;", "+\t\t\t\tloop: for (int max = this.argumentSizes.length; i < max; i++) {", "+\t\t\t\t\tif (index == resolvedPosition) {", "+\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t}", "+\t\t\t\t\tresolvedPosition += this.argumentSizes[i];", "+\t\t\t\t}", "+\t\t\t\tindexInParameterNames = i;", "+\t\t\t}", "+\t\t\tif (indexInParameterNames < this.parameterNames.length", "+\t\t\t\t\t&& this.parameterNames[indexInParameterNames] != null) {", "+\t\t\t\tfinal StringBuffer stringBuffer = new StringBuffer();", "+\t\t\t\tif (showIndex) {", "+\t\t\t\t\tstringBuffer.append(' ').append(index);", "+\t\t\t\t}", "+\t\t\t\tstringBuffer.append(' ').append('[').append(this.parameterNames[indexInParameterNames]).append(']');", "+\t\t\t\treturn String.valueOf(stringBuffer);", "+\t\t\t}", "+\t\t}", "+\t\tif (showIndex) {", "+\t\t\tfinal StringBuffer stringBuffer = new StringBuffer();", "+\t\t\tstringBuffer.append(' ').append(index);", "+\t\t\treturn String.valueOf(stringBuffer);", "+\t\t}", "+\t\treturn EMPTY_LOCAL_NAME;"]}], "num": 35655}