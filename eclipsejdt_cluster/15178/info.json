{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "276a63e70b0861f601c2f77a37340581", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "305c51191bdcfd76bd17ff4ddc7a29f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SearchPattern.java", "commitBeforeChange": "fdf8a7c625823b4365f60e2b73aad682cd437b32", "commitAfterChange": "f32db68c729263506f55f86cbc0d190382ce9b72", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r private static SearchPattern createTypePattern(String patternString, int limitTo, int matchMode, boolean isCaseSensitive)", "signatureAfterChange": "\r private static SearchPattern createTypePattern(String patternString, int limitTo, int matchMode, boolean isCaseSensitive)", "diff": ["-\tStringTokenizer tokenizer = new StringTokenizer(patternString, \" .\", true); //$NON-NLS-1$\r", "+\tScanner scanner = new Scanner(false, true); // tokenize white spaces\r", "+\tscanner.setSourceBuffer(patternString.toCharArray());\r", "-\tString lastToken = null;\r", "-\twhile (tokenizer.hasMoreTokens()){\r", "-\t\tString token = tokenizer.nextToken();\r", "-\t\tif (!token.equals(\" \")){ //$NON-NLS-1$\r", "-\t\t\tif (type == null){\r", "-\t\t\t\ttype = token;\r", "-\t\t\t} else {\r", "-\t\t\t\tif (!(\".\".equals(lastToken) || \".\".equals(token) || \"[]\".equals(token))) return null; //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$\r", "-\t\t\t\ttype += token;\r", "-\t\t\t}\r", "+\tint token;\r", "+\ttry {\r", "+\t\ttoken = scanner.getNextToken();\r", "+\t} catch (InvalidInputException e) {\r", "+\t\treturn null;\r", "+\t}\r", "+\twhile (token != TerminalSymbols.TokenNameEOF){\r", "+\t\tswitch (token) {\r", "+\t\t\tcase Scanner.TokenNameWHITESPACE:\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase TerminalSymbols.TokenNameDOT:\r", "+\t\t\tcase TerminalSymbols.TokenNameIdentifier:\r", "+\t\t\tcase TerminalSymbols.TokenNameMULTIPLY:\r", "+\t\t\tcase TerminalSymbols.TokenNameLBRACKET:\r", "+\t\t\tcase TerminalSymbols.TokenNameRBRACKET:\r", "+\t\t\tcase TerminalSymbols.TokenNameboolean:\r", "+\t\t\tcase TerminalSymbols.TokenNamebyte:\r", "+\t\t\tcase TerminalSymbols.TokenNamechar:\r", "+\t\t\tcase TerminalSymbols.TokenNamedouble:\r", "+\t\t\tcase TerminalSymbols.TokenNamefloat:\r", "+\t\t\tcase TerminalSymbols.TokenNameint:\r", "+\t\t\tcase TerminalSymbols.TokenNamelong:\r", "+\t\t\tcase TerminalSymbols.TokenNameshort:\r", "+\t\t\tcase TerminalSymbols.TokenNamevoid:\r", "+\t\t\t\tif (type == null){\r", "+\t\t\t\t\ttype = new String(scanner.getCurrentTokenSource());\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\ttype += new String(scanner.getCurrentTokenSource());\r", "+\t\t\t\t}\r", "+\t\t\t\tbreak;\r", "+\t\t\tdefault:\r", "+\t\t\t\treturn null;\r", "-\t\tlastToken = token;\r", "+\t\ttry {\r", "+\t\t\ttoken = scanner.getNextToken();\r", "+\t\t} catch (InvalidInputException e) {\r", "+\t\t\treturn null;\r", "+\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b915b5724bd1282f3709a1ed4b46fc3d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "8975a4993759f4f0cb2d8fff2da5bbb83e0cb45e", "commitAfterChange": "cf2efa3dda03cbfe4678da60ea7973c079a8dcf8", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tprivate boolean checkQualification(ASTNode node, char[] qualifiedPackageName, char[] qualifiedSourceName)", "signatureAfterChange": " \tprivate boolean checkTypeArgument(Scanner scanner, CheckState state) throws InvalidInputException", "diff": ["-\t}", "-\tprivate boolean checkQualification(ASTNode node, char[] qualifiedPackageName, char[] qualifiedSourceName) {", "-\t\tif (this.qualifiedSelection != null) {", "-\t\t\tif(node != null && node instanceof QualifiedTypeReference) {", "-\t\t\t\tchar[] tokens = CharOperation.concatWith(((QualifiedTypeReference) node).tokens, '.');", "-\t\t\t\tif(CharOperation.equals(tokens, this.qualifiedSelection)) {", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\tchar[] qualifiedTypeName = CharOperation.concat(qualifiedPackageName, qualifiedSourceName, '.');", "-\t\t\treturn CharOperation.equals(qualifiedTypeName, this.qualifiedSelection) ||", "-\t\t\t\t\tCharOperation.equals(qualifiedSourceName, this.qualifiedSelection);", "-\t\t}", "-\t\treturn true;", "+\tprivate boolean checkTypeArgument(Scanner scanner, CheckState state) throws InvalidInputException {", "+\t\tboolean expectingIdentifier = true;", "+\t\t", "+\t\tint token;", "+\t\tdo {", "+\t\t\ttoken = scanner.getNextToken();", "+\t", "+\t\t\tswitch(token) {", "+\t\t\t\tcase TerminalTokens.TokenNameDOT :", "+\t\t\t\t\tif (expectingIdentifier)", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\texpectingIdentifier = true;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\tif (!expectingIdentifier)", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\texpectingIdentifier = false;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase TerminalTokens.TokenNameCOMMA :", "+\t\t\t\t\tif (expectingIdentifier)", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\texpectingIdentifier = true;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase TerminalTokens.TokenNameLESS :", "+\t\t\t\t\tint oldDepth = state.depth;", "+\t\t\t\t\tstate.depth++;", "+\t\t\t\t\tif(checkTypeArgument(scanner, state)) {", "+\t\t\t\t\t\tif(state.depth < oldDepth) {", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase TerminalTokens.TokenNameGREATER :", "+\t\t\t\t\tstate.depth--;", "+\t\t\t\t\treturn state.depth >= 0;", "+\t\t\t\tcase TerminalTokens.TokenNameRIGHT_SHIFT :", "+\t\t\t\t\tstate.depth-=2;", "+\t\t\t\t\treturn state.depth >= 0;", "+\t\t\t\tcase TerminalTokens.TokenNameUNSIGNED_RIGHT_SHIFT :", "+\t\t\t\t\tstate.depth-=3;", "+\t\t\t\t\treturn state.depth >= 0;", "+\t\t\t\tcase TerminalTokens.TokenNameQUESTION :\t", "+\t\t\t\t\ttoken = scanner.getNextToken();", "+\t\t\t\t\tif(token != TerminalTokens.TokenNameextends &&", "+\t\t\t\t\t\t\ttoken != TerminalTokens.TokenNamesuper) {", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\ttoken = scanner.getNextToken();", "+\t\t\t\t\tif(token != TerminalTokens.TokenNameIdentifier)", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\t", "+\t\t\t\t\texpectingIdentifier = false;", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\treturn false;", "+\t\t\t}", "+\t\t} while (token != TerminalTokens.TokenNameEOF);", "+\t\t", "+\t\treturn false;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b9ad9bd81dcb95248f0cf9976434f4b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SearchPattern.java", "commitBeforeChange": "fdf8a7c625823b4365f60e2b73aad682cd437b32", "commitAfterChange": "f32db68c729263506f55f86cbc0d190382ce9b72", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r private static SearchPattern createFieldPattern(String patternString, int limitTo, int matchMode, boolean isCaseSensitive)", "signatureAfterChange": "\r private static SearchPattern createFieldPattern(String patternString, int limitTo, int matchMode, boolean isCaseSensitive)", "diff": ["-\tStringTokenizer tokenizer = new StringTokenizer(patternString, \" .(,)\", true); //$NON-NLS-1$\r", "+\tScanner scanner = new Scanner(false, true); // tokenize white spaces\r", "+\tscanner.setSourceBuffer(patternString.toCharArray());\r", "-\tString lastToken = null;\r", "+\tint lastToken = -1;\r", "-\tString declaringType = null, fieldName = null, parameterType = null;\r", "+\tString declaringType = null, fieldName = null;\r", "-\twhile (tokenizer.hasMoreTokens()){\r", "-\t\tString token = tokenizer.nextToken();\r", "+\tint token;\r", "+\ttry {\r", "+\t\ttoken = scanner.getNextToken();\r", "+\t} catch (InvalidInputException e) {\r", "+\t\treturn null;\r", "+\t}\r", "+\twhile (token != TerminalSymbols.TokenNameEOF){\r", "-\t\t\t\tif (token.equals(\".\")){ //$NON-NLS-1$\r", "-\t\t\t\t\tif (declaringType == null){\r", "-\t\t\t\t\t\tif (fieldName == null) return null;\r", "-\t\t\t\t\t\tdeclaringType = fieldName;\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tdeclaringType += token + fieldName;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tfieldName = null;\r", "-\t\t\t\t} else if (token.equals(\" \")){ //$NON-NLS-1$\r", "-\t\t\t\t\tif (!(\" \".equals(lastToken) || \".\".equals(lastToken))){ //$NON-NLS-1$ //$NON-NLS-2$\r", "-\t\t\t\t\t\tmode = InsideType;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t} else { // name\r", "-\t\t\t\t\tif (fieldName != null) return null;\r", "-\t\t\t\t\tfieldName = token;\r", "+\t\t\t\tswitch (token) {\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameDOT:\r", "+\t\t\t\t\t\tif (declaringType == null){\r", "+\t\t\t\t\t\t\tif (fieldName == null) return null;\r", "+\t\t\t\t\t\t\tdeclaringType = fieldName;\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tString tokenSource = new String(scanner.getCurrentTokenSource());\r", "+\t\t\t\t\t\t\tdeclaringType += tokenSource + fieldName;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tfieldName = null;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase Scanner.TokenNameWHITESPACE:\r", "+\t\t\t\t\t\tif (!(Scanner.TokenNameWHITESPACE == lastToken \r", "+\t\t\t\t\t\t\t|| TerminalSymbols.TokenNameDOT == lastToken)){\r", "+\t\t\t\t\t\t\tmode = InsideType;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameIdentifier:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameMULTIPLY:\r", "+\t\t\t\t\t\tif (fieldName == null) {\r", "+\t\t\t\t\t\t\tfieldName = new String(scanner.getCurrentTokenSource());\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tfieldName += new String(scanner.getCurrentTokenSource());\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tdefault:\r", "+\t\t\t\t\t\treturn null;\r", "-\t\t\t\tif (!token.equals(\" \")){ //$NON-NLS-1$\r", "-\t\t\t\t\tif (type == null){\r", "-\t\t\t\t\t\ttype = token;\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tif (!(!(\".\".equals(lastToken) || \".\".equals(token) || \"[]\".equals(token)))) return null; //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$\r", "-\t\t\t\t\t\ttype += token;\r", "-\t\t\t\t\t}\r", "+\t\t\t\tswitch (token) {\r", "+\t\t\t\t\tcase Scanner.TokenNameWHITESPACE:\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameDOT:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameIdentifier:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameMULTIPLY:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameLBRACKET:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameRBRACKET:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameboolean:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNamebyte:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNamechar:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNamedouble:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNamefloat:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameint:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNamelong:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNameshort:\r", "+\t\t\t\t\tcase TerminalSymbols.TokenNamevoid:\r", "+\t\t\t\t\t\tif (type == null){\r", "+\t\t\t\t\t\t\ttype = new String(scanner.getCurrentTokenSource());\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\ttype += new String(scanner.getCurrentTokenSource());\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tdefault:\r", "+\t\t\t\t\t\treturn null;\r", "+\t\t\t\tbreak;\r", "+\t\ttry {\r", "+\t\t\ttoken = scanner.getNextToken();\r", "+\t\t} catch (InvalidInputException e) {\r", "+\t\t\treturn null;\r", "+\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ddcbfd58f5c0089a1d64d08579c7cfbd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "ae980cab0e47f9f9109f15f27f7ea765847cf9bc", "commitAfterChange": "4d657d16dcce8d103534cfb60b4be82696664aa1", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-", "-\t\tif (tryBlock.isEmptyBlock()) {", "-\t\t\tif (subRoutineStartLabel != null) {", "-\t\t\t\t// since not passing the finallyScope, the block generation will exitUserScope(finallyScope)", "-\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "-\t\t\t}", "-\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\t\tif (mergedInitStateIndex != -1) {", "-\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "-\t\t\t\t\tcurrentScope,", "-\t\t\t\t\tmergedInitStateIndex);", "-\t\t\t}", "-\t\t\t// no local bytecode produced so no need for position remembering", "-\t\t\treturn;", "-\t\t}", "-\t\tLabel endLabel = new Label(codeStream);", "-\t\tboolean requiresNaturalJsr = false;", "-", "+\t\tfinal int NoFinally = 0;\t\t\t\t\t\t\t// no finally block", "+\t\tfinal int FinallySubroutine = 1; \t\t\t\t// finally is generated as a subroutine (using jsr/ret bytecodes)", "+\t\tfinal int FinallyDoesNotComplete = 2;\t// non returning finally is optimized with only one instance of finally block", "+\t\tfinal int FinallyMustBeInlined = 3;\t\t\t// finally block must be inlined since cannot use jsr/ret bytecodes >1.5", "+\t\tint finallyMode;", "+\t\tif (subRoutineStartLabel == null) { ", "+\t\t\tfinallyMode = NoFinally;", "+\t\t} else {", "+\t\t\tif (this.isSubRoutineEscaping) {", "+\t\t\t\tfinallyMode = FinallyDoesNotComplete;", "+\t\t\t} else if (scope.environment().options.targetJDK < ClassFileConstants.JDK1_5) {", "+\t\t\t\tfinallyMode = FinallySubroutine;", "+\t\t\t} else {", "+\t\t\t\tfinallyMode = FinallyMustBeInlined;", "+\t\t\t}", "+\t\t}", "+\t\tboolean requiresNaturalExit = false;", "-\t\t// natural exit: only if necessary", "-\t\tboolean nonReturningSubRoutine = subRoutineStartLabel != null && isSubRoutineEscaping; ", "-\t\tif ((!tryBlockExit) && tryBlockHasSomeCode) {", "-\t\t\tint position = codeStream.position;", "-\t\t\tif (nonReturningSubRoutine) {", "-\t\t\t\tcodeStream.goto_(subRoutineStartLabel);", "-\t\t\t} else {", "-\t\t\t\trequiresNaturalJsr = true;", "-\t\t\t\tcodeStream.goto_(endLabel);", "-\t\t\t}", "-\t\t\tcodeStream.updateLastRecordedEndPC(position);", "-\t\t\t//goto is tagged as part of the try block", "-\t\t}", "+\t\t\t// natural exit may require subroutine invocation (if finally != null)", "+\t\t\tLabel naturalExitLabel = new Label(codeStream);", "+\t\t\tif (!tryBlockExit) {", "+\t\t\t\tint position = codeStream.position;", "+\t\t\t\tswitch(finallyMode) {", "+\t\t\t\t\tcase FinallySubroutine :", "+\t\t\t\t\tcase FinallyMustBeInlined :", "+\t\t\t\t\t\trequiresNaturalExit = true;", "+\t\t\t\t\t\t// fall through", "+\t\t\t\t\tcase NoFinally :", "+\t\t\t\t\t\tcodeStream.goto_(naturalExitLabel);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase FinallyDoesNotComplete :", "+\t\t\t\t\t\tcodeStream.goto_(subRoutineStartLabel);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tcodeStream.updateLastRecordedEndPC(position);", "+\t\t\t\t//goto is tagged as part of the try block", "+\t\t\t}", "-\t\t\t\t\t\tif (nonReturningSubRoutine) {", "-\t\t\t\t\t\t\tcodeStream.goto_(subRoutineStartLabel);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\trequiresNaturalJsr = true;", "-\t\t\t\t\t\t\tcodeStream.goto_(endLabel);", "+\t\t\t\t\t\tswitch(finallyMode) {", "+\t\t\t\t\t\t\tcase FinallySubroutine :", "+\t\t\t\t\t\t\tcase FinallyMustBeInlined :", "+\t\t\t\t\t\t\t\trequiresNaturalExit = true;", "+\t\t\t\t\t\t\t\t// fall through", "+\t\t\t\t\t\t\tcase NoFinally :", "+\t\t\t\t\t\t\t\tcodeStream.goto_(naturalExitLabel);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase FinallyDoesNotComplete :", "+\t\t\t\t\t\t\t\tcodeStream.goto_(subRoutineStartLabel);", "+\t\t\t\t\t\t\t\tbreak;", "-\t\t\tExceptionLabel naturalExitExceptionHandler = null;", "-\t\t\tif (requiresNaturalJsr) {", "-\t\t\t\tnaturalExitExceptionHandler = this.enterAnyExceptionHandler(codeStream);", "-\t\t\t}", "+\t\t\tExceptionLabel naturalExitExceptionHandler = ", "+\t\t\t\tfinallyMode == FinallySubroutine && requiresNaturalExit ? this.enterAnyExceptionHandler(codeStream) : null;", "-\t\t\t\tif (nonReturningSubRoutine) {", "-\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t\t// \"if subroutine cannot return, no need to jsr/jump to subroutine since it will be entered in sequence", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.store(anyExceptionVariable, false);", "-\t\t\t\t\tcodeStream.jsr(subRoutineStartLabel);", "-\t\t\t\t\tcodeStream.load(anyExceptionVariable);", "-\t\t\t\t\tcodeStream.athrow();", "-\t\t\t\t}", "-\t\t\t\t// end of catch sequence, place label that will correspond to the finally block beginning, or end of statement\t", "-\t\t\t\tsubRoutineStartLabel.place();", "-\t\t\t\tif (!nonReturningSubRoutine) {", "-\t\t\t\t\tcodeStream.incrStackSize(1);", "-\t\t\t\t\tcodeStream.store(returnAddressVariable, false);", "-\t\t\t\t}", "-\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "-\t\t\t\t// entire sequence for finally is associated to finally block", "-\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "-\t\t\t\tif (!nonReturningSubRoutine) {", "-\t\t\t\t\tint position = codeStream.position;", "-\t\t\t\t\tcodeStream.ret(returnAddressVariable.resolvedPosition);", "-\t\t\t\t\tcodeStream.updateLastRecordedEndPC(position);", "-\t\t\t\t\tcodeStream.recordPositionsFrom(", "-\t\t\t\t\t\tposition,", "-\t\t\t\t\t\tfinallyBlock.sourceEnd);", "-\t\t\t\t\t// the ret bytecode is part of the subroutine", "+\t\t\t\tswitch(finallyMode) {", "+\t\t\t\t\t", "+\t\t\t\t\tcase FinallySubroutine :", "+\t\t\t\t\t\tcodeStream.store(anyExceptionVariable, false);", "+\t\t\t\t\t\tcodeStream.jsr(subRoutineStartLabel);", "+\t\t\t\t\t\tcodeStream.load(anyExceptionVariable);", "+\t\t\t\t\t\tcodeStream.athrow();", "+\t\t\t\t\t\tsubRoutineStartLabel.place();", "+\t\t\t\t\t\tcodeStream.incrStackSize(1);", "+\t\t\t\t\t\tcodeStream.store(returnAddressVariable, false);", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "+\t\t\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "+\t\t\t\t\t\tint position = codeStream.position;", "+\t\t\t\t\t\tcodeStream.ret(returnAddressVariable.resolvedPosition);", "+\t\t\t\t\t\tcodeStream.updateLastRecordedEndPC(position);", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(", "+\t\t\t\t\t\t\tposition,", "+\t\t\t\t\t\t\tfinallyBlock.sourceEnd);", "+\t\t\t\t\t\t// the ret bytecode is part of the subroutine", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t", "+\t\t\t\t\tcase FinallyMustBeInlined :", "+\t\t\t\t\t\tcodeStream.store(anyExceptionVariable, false);", "+\t\t\t\t\t\tthis.finallyBlock.generateCode(currentScope, codeStream);", "+\t\t\t\t\t\tcodeStream.load(anyExceptionVariable);", "+\t\t\t\t\t\tcodeStream.athrow();", "+\t\t\t\t\t\tsubRoutineStartLabel.place();", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t", "+\t\t\t\t\tcase FinallyDoesNotComplete :", "+\t\t\t\t\t\tcodeStream.pop();", "+\t\t\t\t\t\tsubRoutineStartLabel.place();", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);", "+\t\t\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "+\t\t\t\t\t\tbreak;", "-\t\t\t\tendLabel.place();", "-\t\t\t\tif (naturalExitExceptionHandler != null) {", "-\t\t\t\t\tint position = codeStream.position;\t\t\t\t\t", "-\t\t\t\t\t// fix up natural exit handler", "-\t\t\t\t\tnaturalExitExceptionHandler.placeStart();", "-\t\t\t\t\tcodeStream.jsr(subRoutineStartLabel);", "-\t\t\t\t\tnaturalExitExceptionHandler.placeEnd();", "-\t\t\t\t\tcodeStream.recordPositionsFrom(", "-\t\t\t\t\t\tposition,", "-\t\t\t\t\t\tfinallyBlock.sourceStart);\t\t\t\t\t", "+\t\t\t\tnaturalExitLabel.place();", "+\t\t\t\tif (requiresNaturalExit) {", "+\t\t\t\t\tswitch(finallyMode) {", "+", "+\t\t\t\t\t\tcase FinallySubroutine :", "+\t\t\t\t\t\t\tint position = codeStream.position;\t\t\t\t\t", "+\t\t\t\t\t\t\t// fix up natural exit handler", "+\t\t\t\t\t\t\tnaturalExitExceptionHandler.placeStart();", "+\t\t\t\t\t\t\tcodeStream.jsr(subRoutineStartLabel);", "+\t\t\t\t\t\t\tnaturalExitExceptionHandler.placeEnd();", "+\t\t\t\t\t\t\tcodeStream.recordPositionsFrom(", "+\t\t\t\t\t\t\t\tposition,", "+\t\t\t\t\t\t\t\tfinallyBlock.sourceStart);\t\t\t\t\t", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tcase FinallyMustBeInlined :", "+\t\t\t\t\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "+\t\t\t\t\t\t\t// needed since any exception handler got inlined subroutine", "+\t\t\t\t\t\t\tif (preTryInitStateIndex != -1) {", "+\t\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "+\t\t\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\t\t\tpreTryInitStateIndex);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// entire sequence for finally is associated to finally block", "+\t\t\t\t\t\t\tfinallyBlock.generateCode(scope, codeStream);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tcase FinallyDoesNotComplete :", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "-\t\t\t\t// no subroutine, simply position end label", "-\t\t\t\tendLabel.place();", "+\t\t\t\t// no subroutine, simply position end label (natural exit == end)", "+\t\t\t\tnaturalExitLabel.place();", "-\t\t\tendLabel.place();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5e8dc15b657cbb226413380f10fdc68", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "ed740421873de649d1358b98ff0b1d7119124148", "commitAfterChange": "e5a2903f60957a9d72ce9cb5ec153611e499dfc4", "methodNumberBeforeChange": 93, "methodNumberAfterChange": 93, "signatureBeforeChange": " \tpublic boolean isOnClasspath(IJavaElement element)", "signatureAfterChange": " \tpublic boolean isOnClasspath(IJavaElement element)", "diff": ["-\t\tIPath path = element.getPath();", "-\t\tIClasspathEntry[] classpath;", "+\t\tIClasspathEntry[] rawClasspath;", "-\t\t\tclasspath = getResolvedClasspath(true/*ignoreUnresolvedEntry*/, false/*don't generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);", "+\t\t\trawClasspath = getRawClasspath();", "+\t\tint elementType = element.getElementType();", "+\t\tboolean isPackageFragmentRoot = false;", "-\t\tswitch (element.getElementType()) {", "-\t\t\tcase IJavaElement.PACKAGE_FRAGMENT_ROOT:", "-\t\t\t\t// package fragment roots must match exactly entry pathes (no exclusion there)", "-\t\t\t\tfor (int i = 0; i < classpath.length; i++) {", "-\t\t\t\t\tIClasspathEntry entry = classpath[i];", "-\t\t\t\t\tIPath entryPath = entry.getPath();", "-\t\t\t\t\tif (entryPath.equals(path)) {", "-\t\t\t\t\t\treturn true;", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\tboolean isSource = false;", "+\t\tswitch (elementType) {", "+\t\t\tcase IJavaElement.JAVA_MODEL:", "-\t\t\t\t", "+\t\t\tcase IJavaElement.JAVA_PROJECT:", "+\t\t\t\tbreak;", "+\t\t\tcase IJavaElement.PACKAGE_FRAGMENT_ROOT:", "+\t\t\t\tisPackageFragmentRoot = true;", "+\t\t\t\tbreak;", "-\t\t\t\tif (!((IPackageFragmentRoot)element.getParent()).isArchive()) {", "-\t\t\t\t\t// ensure that folders are only excluded if all of their children are excluded", "-\t\t\t\t\tisFolderPath = true;", "-\t\t\t\t}", "+\t\t\t\tisFolderPath = !((IPackageFragmentRoot)element.getParent()).isArchive();", "+\t\t\t\tbreak;", "+\t\t\tcase IJavaElement.COMPILATION_UNIT:", "+\t\t\t\tisSource = true;", "+\t\t\t\tbreak;", "+\t\t\tdefault:", "+\t\t\t\tisSource = element.getAncestor(IJavaElement.COMPILATION_UNIT) != null;", "-\t\tfor (int i = 0; i < classpath.length; i++) {", "-\t\t\tIClasspathEntry entry = classpath[i];", "-\t\t\tIPath entryPath = entry.getPath();", "-\t\t\tif (entryPath.isPrefixOf(path) ", "-\t\t\t\t\t&& !Util.isExcluded(path, ((ClasspathEntry)entry).fullInclusionPatternChars(), ((ClasspathEntry)entry).fullExclusionPatternChars(), isFolderPath)) {", "-\t\t\t\treturn true;", "+\t\tIPath elementPath = element.getPath();", "+\t\t", "+\t\t// first look at unresolved entries", "+\t\tint length = rawClasspath.length;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tIClasspathEntry entry = rawClasspath[i];", "+\t\t\tswitch (entry.getEntryKind()) {", "+\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "+\t\t\t\tcase IClasspathEntry.CPE_PROJECT:", "+\t\t\t\tcase IClasspathEntry.CPE_SOURCE:", "+\t\t\t\t\tif (isOnClasspathEntry(elementPath, isFolderPath, isPackageFragmentRoot, entry))", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\tbreak;", "+\t\t", "+\t\t// no need to go further for compilation units and elements inside a compilation unit", "+\t\t// it can only be in a source folder, thus on the raw classpath", "+\t\tif (isSource)", "+\t\t\treturn false;", "+\t\t", "+\t\t// then look at resolved entries", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tIClasspathEntry rawEntry = rawClasspath[i];", "+\t\t\tswitch (rawEntry.getEntryKind()) {", "+\t\t\t\tcase IClasspathEntry.CPE_CONTAINER:", "+\t\t\t\t\tIClasspathContainer container;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tcontainer = JavaCore.getClasspathContainer(rawEntry.getPath(), this);", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (container == null)", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tIClasspathEntry[] containerEntries = container.getClasspathEntries();", "+\t\t\t\t\tif (containerEntries == null) ", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t// container was bound", "+\t\t\t\t\tfor (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){", "+\t\t\t\t\t\tIClasspathEntry resolvedEntry = containerEntries[j];", "+\t\t\t\t\t\tif (isOnClasspathEntry(elementPath, isFolderPath, isPackageFragmentRoot, resolvedEntry))", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IClasspathEntry.CPE_VARIABLE:", "+\t\t\t\t\tIClasspathEntry resolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);", "+\t\t\t\t\tif (resolvedEntry == null) ", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tif (isOnClasspathEntry(elementPath, isFolderPath, isPackageFragmentRoot, resolvedEntry))", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\treturn false;", "+\t}"]}], "num": 15178}