{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ff9023bea903d344830d2fcf776ced10", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c503b70d67998d3d004d893b6b6be389", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "80a36bf53ae731edac012c99749b4fd073634fd5", "commitAfterChange": "775667d78092a7c5a2c35b021921f25b4037d7f4", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\t\t\t\t\t\t: classScope.findExactMethod( receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "+\t\t\t\t\t\t\t: classScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != NotVisible) && environment().options.complianceLevel >= ClassFileConstants.JDK1_4)){", "+\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != NotVisible) && environment().options.complianceLevel >= ClassFileConstants.JDK1_4)) {", "-\t\t\t\t\t\tif (foundMethod == null", "-\t\t\t\t\t\t\t|| (foundMethod.problemId() == NotVisible", "-\t\t\t\t\t\t\t\t&& methodBinding.problemId() != NotVisible)) {", "+\t\t\t\t\t\tif (foundMethod == null || (foundMethod.problemId() == NotVisible && methodBinding.problemId() != NotVisible)) {", "-\t\t\t\t\t\t\tif (depth > 0){", "+\t\t\t\t\t\t\tif (depth > 0) {", "+", "+\t\tif (insideStaticContext && environment().options.complianceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\t// at this point the scope is a compilation unit scope & need to check for imported static methods", "+\t\t\tCompilationUnitScope unitScope = (CompilationUnitScope) scope;", "+\t\t\tImportBinding[] imports = unitScope.imports;", "+\t\t\tif (imports != null) {", "+\t\t\t\t// check on demand imports", "+\t\t\t\tboolean foundInImport = false;", "+\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "+\t\t\t\t\tImportBinding importBinding = imports[i];", "+\t\t\t\t\tif (importBinding.isStatic() && importBinding.onDemand) {", "+\t\t\t\t\t\tBinding resolvedImport = importBinding.resolvedImport;", "+\t\t\t\t\t\tif (resolvedImport instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\tMethodBinding temp = findMethod((ReferenceBinding) resolvedImport, selector, argumentTypes, invocationSite);", "+\t\t\t\t\t\t\tif (temp != null) {", "+\t\t\t\t\t\t\t\tif (!temp.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (foundMethod == null)", "+\t\t\t\t\t\t\t\t\t\tfoundMethod = temp;", "+\t\t\t\t\t\t\t\t} else if (temp.isStatic()) {", "+\t\t\t\t\t\t\t\t\tif (temp.canBeSeenBy(unitScope.fPackage)) {", "+\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\t\t\t\t\t\tif (foundInImport)", "+\t\t\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand types.", "+\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(temp, selector, temp.parameters, Ambiguous);", "+\t\t\t\t\t\t\t\t\t\tfoundMethod = temp;", "+\t\t\t\t\t\t\t\t\t\tfoundInImport = true;", "+\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(temp, selector, temp.parameters, NotVisible);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (foundMethod != null)", "+\t\t\t\treturn foundMethod;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e083c1fd95cf20ddd58072fd6c1b0711", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "2d89f0516f5e5910bcd18015e8090ed0805dbb4e", "commitAfterChange": "817ed71692e2e331f7e0ac3a90af87bc08553ba4", "methodNumberBeforeChange": 59, "methodNumberAfterChange": 59, "signatureBeforeChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask, boolean needResolve)", "signatureAfterChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask, boolean needResolve)", "diff": ["-", "+\t\t\t// walk single static imports. A type found here will shadow types with same name in other CU's, or types coming", "+\t\t\t// from on-demand imports. JLS 7.5.3", "+\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318401", "+\t\t\tif (imports != null) {", "+\t\t\t\tReferenceBinding type = null;", "+\t\t\t\tnextImport : for (int i = 0, length = imports.length; i < length; i++) {", "+\t\t\t\t\tImportBinding importBinding = imports[i];", "+\t\t\t\t\tif (importBinding.isStatic()) {", "+\t\t\t\t\t\tReferenceBinding temp = null;", "+\t\t\t\t\t\tif (CharOperation.equals(importBinding.compoundName[importBinding.compoundName.length - 1], name)) {", "+\t\t\t\t\t\t\tBinding resolvedImport = importBinding.resolvedImport;", "+\t\t\t\t\t\t\tif (resolvedImport == null) continue nextImport;", "+\t\t\t\t\t\t\tif (resolvedImport instanceof MethodBinding || resolvedImport instanceof FieldBinding) {", "+\t\t\t\t\t\t\t\t// check to see if there are also member types with the same name", "+\t\t\t\t\t\t\t\t// must find the importRef's type again since the method/field can be from an inherited type", "+\t\t\t\t\t\t\t\t// see StaticImportTest#test084 for more clarity", "+\t\t\t\t\t\t\t\tchar[][] importName = importBinding.reference.tokens;", "+\t\t\t\t\t\t\t\tTypeBinding referencedType = getType(importName, importName.length - 1);", "+\t\t\t\t\t\t\t\tif (referencedType != null && referencedType instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\t\t\ttemp = findMemberType(name, (ReferenceBinding) referencedType);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (temp != null && temp.isStatic() && temp != type) {", "+\t\t\t\t\t\t\t\tif (temp.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (!temp.canBeSeenBy(unitScope.fPackage)) {", "+\t\t\t\t\t\t\t\t\t\t// Answer error binding - type is not visible", "+\t\t\t\t\t\t\t\t\t\tfoundType = new ProblemReferenceBinding(new char[][]{name}, type, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\tif (importReference != null) {", "+\t\t\t\t\t\t\t\t\t\t\timportReference.bits |= ASTNode.Used;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\ttype = temp;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else if (foundType == null) {", "+\t\t\t\t\t\t\t\t\tfoundType = temp;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (type != null) {", "+\t\t\t\t\tif (typeOrPackageCache != null)", "+\t\t\t\t\t\ttypeOrPackageCache.put(name, type);", "+\t\t\t\t\treturn type;", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 46827}