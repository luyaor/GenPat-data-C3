{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3d7b8a3719f73ba0d41ab98026c09332", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "674d29130a9d070c49f3c5a60138f046", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java", "commitBeforeChange": "457fc77ec96140a15fc3e1c18bbf7bf53c7ea1c9", "commitAfterChange": "44074e366655e2cf89768617c1e64463f5949123", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": " protected int matchLevelForDeclarations(ConstructorDeclaration constructor)", "signatureAfterChange": " protected int matchLevelForDeclarations(ConstructorDeclaration constructor)", "diff": ["+\t\t/* Remove as we need to resolve to be really sure that method matches or not...", "+\t\t*/", "+\t}", "+", "+\t// Verify type arguments (do not reject if pattern has no argument as it can be an erasure match)", "+\tif (this.pattern.hasConstructorArguments()) {", "+\t\tif (constructor.typeParameters == null || constructor.typeParameters.length != this.pattern.constructorArguments.length) return IMPOSSIBLE_MATCH;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7bbeddc0a76f4bb83de31a91113a1243", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "457fc77ec96140a15fc3e1c18bbf7bf53c7ea1c9", "commitAfterChange": "44074e366655e2cf89768617c1e64463f5949123", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public int match(MethodDeclaration node, MatchingNodeSet nodeSet)", "signatureAfterChange": " public int match(MethodDeclaration node, MatchingNodeSet nodeSet)", "diff": ["+\t// Verify method name", "+\t", "+\t// Verify parameters types count", "+\t\t/* Remove as we need to resolve to be really sure that method matches or not...", "+\t\t*/", "+\t", "+\t// Verify return type", "+\t// Verify type arguments (do not reject if pattern has no argument as it can be an erasure match)", "+\tif (this.pattern.hasMethodArguments()) {", "+\t\tif (node.typeParameters == null || node.typeParameters.length != this.pattern.methodArguments.length) return IMPOSSIBLE_MATCH;", "+\t}", "+", "+\t// Method declaration may match pattern"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "807e8515428b5cab1a8e1b79663a4d51", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "2ae41539e386d12d9e7c121e231730e370deda2f", "commitAfterChange": "05dd526dbb279df7b7e23a1d7ccb53d445943919", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r public boolean encloses(String resourcePathString)", "signatureAfterChange": "\r public boolean encloses(String resourcePathString)", "diff": ["+\tIPath resourcePath;\r", "-\t\tresourcePathString = resourcePathString.substring(0, separatorIndex);\r", "+\t\tresourcePath = \r", "+\t\t\tnew Path(resourcePathString.substring(0, separatorIndex)).\r", "+\t\t\t\tappend(new Path(resourcePathString.substring(separatorIndex+1)));\r", "+\t} else {\r", "+\t\t\tresourcePath = new Path(resourcePathString);\r", "-\tIPath resourcePath = new Path(resourcePathString);\r", "-\tfor (int i = 0; i < this.pathsCount; i++){\r", "-\t\tif (this.paths[i].isPrefixOf(resourcePath)) {\r", "-\t\t\treturn true;\r", "-\t\t}\r", "-\t}\r", "-\treturn false;\r", "+\treturn this.encloses(resourcePath);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b7793c414a394d1875ba1601b14a2857", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "bb58594beea7321f1a2a3673bab3e26af89ead20", "commitAfterChange": "7376fb10956e4a03cc528e86b634b5ca73ef755b", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 62, "signatureBeforeChange": " public void exitUserScope(BlockScope blockScope)", "signatureAfterChange": " public void exitUserScope(BlockScope currentScope)", "diff": ["-public void exitUserScope(BlockScope blockScope) {", "+public void exitUserScope(BlockScope currentScope) {", "-\tfor (int i = 0; i < visibleLocalsCount; i++) {", "-\t\tLocalVariableBinding visibleLocal = visibleLocals[i];", "-\t\tif ((visibleLocal != null) && (visibleLocal.declaringScope == blockScope)) { ", "-\t\t\t// there maybe some some preserved locals never initialized", "-\t\t\tif (visibleLocal.initializationCount > 0){", "-\t\t\t\tvisibleLocals[i].recordInitializationEndPC(position);", "-\t\t\t}", "-\t\t\tvisibleLocals[i] = null; // this variable is no longer visible afterwards", "+\twhile (visibleLocalsCount > 0) {", "+\t\tLocalVariableBinding visibleLocal = visibleLocals[this.visibleLocalsCount - 1];", "+\t\tif (visibleLocal == null)", "+\t\t\tcontinue;", "+\t\tif (visibleLocal.declaringScope != currentScope) // left currentScope", "+\t\t\tbreak;", "+", "+\t\t// there maybe some some preserved locals never initialized", "+\t\tif (visibleLocal.initializationCount > 0){", "+\t\t\tvisibleLocal.recordInitializationEndPC(position);", "+\t\tvisibleLocals[--this.visibleLocalsCount] = null; // this variable is no longer visible afterwards"]}], "num": 2552}