{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b9da9fa6ad505370b035d705adb7e0c2", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "03ea310e5b319818f9dbea68a35052b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "diff": ["+\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "+\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "+\t\t\tcontinue nextMethod;", "+\t\t}", "+", "-\t\tif (!areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "+\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType()", "+\t\t\t&& isSameOrSubTypeOf(currentMethod.returnType, inheritedMethod.returnType);", "+\t\tif (!addBridgeMethod && !areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "-\t\t} else if (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "-\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "-\t\t} else {", "-\t\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "-\t\t\tif (inheritedMethod.isFinal())", "-\t\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "-\t\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\tcontinue nextMethod;", "+\t\t}", "-\t\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "-\t\t\t\t}", "+\t\tif (addBridgeMethod || inheritedMethod.hasSubstitutedParameters()) {", "+\t\t    MethodBinding original = inheritedMethod.original();", "+\t\t    if (!areReturnTypeErasuresEqual(original, currentMethod) || !areParameterErasuresEqual(original, currentMethod))", "+\t\t\t\tthis.type.addSyntheticBridgeMethod(original, currentMethod);", "+\t\t}", "+", "+\t\tif (currentMethod.thrownExceptions != NoExceptions)", "+\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "+\t\tif (inheritedMethod.isFinal())", "+\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "+\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "+\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "+\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "+\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "+\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "+\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "+\t\t\t\tif (declaringClass.isInterface())", "+\t\t\t\t\tfor (int j = length; --j >= 0;)", "+\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+", "+\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "319154b284f67531c4201356d7057736", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PotentialMatch.java", "commitBeforeChange": "681a5bade45a4fbc7e91de35fbcc82af340ee68f", "commitAfterChange": "604e4e53d0f6d2071361616f30ebe463c893bb44", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "\r public PotentialMatch(MatchLocator locator, IResource resource, Openable openable)", "signatureAfterChange": "\r public PotentialMatch(MatchLocator locator, IResource resource, Openable openable)", "diff": ["+\t\t\t\t\r", "+\t\t\t\t// try to use the main type's class file as the openable\r", "+\t\t\t\tTypeDeclaration[] types = this.parsedUnit.types;\r", "+\t\t\t\tif (types != null && types.length > 0) {\r", "+\t\t\t\t\tString simpleTypeName = new String(types[0].name);\r", "+\t\t\t\t\tIPackageFragment parent = (IPackageFragment)openable.getParent();\r", "+\t\t\t\t\torg.eclipse.jdt.core.IClassFile classFile = \r", "+\t\t\t\t\t\tparent.getClassFile(simpleTypeName + \".class\");\r", "+\t\t\t\t\tif (classFile.exists()) {\r", "+\t\t\t\t\t\tthis.openable = (Openable)classFile;\r", "+\t\t\t\t\t} \r", "+\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "72adf0a06dfad891b460e62adff550aa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "8fdb14b64608b58e620c67bc0f2758fb559de717", "commitAfterChange": "447dafd45d9eea3d096b0cc1d1d11fe893f03ec0", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": " protected void reportMatching(TypeDeclaration type, AbstractMethodDeclaration method, IJavaElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException", "signatureAfterChange": " protected void reportMatching(AbstractMethodDeclaration method, TypeDeclaration type, IJavaElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException", "diff": ["-protected void reportMatching(TypeDeclaration type, AbstractMethodDeclaration method, IJavaElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException {", "+protected void reportMatching(AbstractMethodDeclaration method, TypeDeclaration type, IJavaElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException {", "+", "+\t// report method declaration itself", "-\t\t\t\t\tfor (int i = 0, l = nodes.length; i < l; i++) {", "-\t\t\t\t\t\tASTNode node = nodes[i];", "-\t\t\t\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(node);", "-\t\t\t\t\t\tthis.patternLocator.matchReportReference(node, enclosingElement, method.binding, method.scope, level.intValue(), this);", "+\t\t\t\t\t// standard reporting", "+\t\t\t\t\tif (this.patternFineGrain == 0) {", "+\t\t\t\t\t\tfor (int i = 0, l = nodes.length; i < l; i++) {", "+\t\t\t\t\t\t\tASTNode node = nodes[i];", "+\t\t\t\t\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(node);", "+\t\t\t\t\t\t\tthis.patternLocator.matchReportReference(node, enclosingElement, method.binding, method.scope, level.intValue(), this);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn;", "-\t\t\t\t\treturn;", "+\t\t\t\t\t// finegrain reporting", "+\t\t\t\t\tFineGrainVisitor visitor = new FineGrainVisitor(enclosingElement, method.binding, nodeSet, nodes, this.patternLocator, this);", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tClassScope classScope = method.scope == null ? null : method.scope.classScope();", "+\t\t\t\t\t\tmethod.traverse(visitor, classScope);", "+\t\t\t\t\t} catch (WrappedCoreException e) {", "+\t\t\t\t\t\tthrow e.coreException;", "+\t\t\t\t\t}", "-\t\t\tfor (int i = 0, l = nodes.length; i < l; i++)", "+\t\t\t// Remove all remaining nodes", "+\t\t\tfor (int i = 0, l = nodes.length; i < l; i++) {", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7ea8c7ec4e42418d02b5307c42a853e0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "74cb74226fe254108607eae80c548bb2b6719e32", "commitAfterChange": "dadef2fc0573a510ff313dd625ee1ba4e2b2e6e3", "methodNumberBeforeChange": 68, "methodNumberAfterChange": 68, "signatureBeforeChange": " \tprivate int generateMethodParameters(final MethodBinding binding)", "signatureAfterChange": " \tprivate int generateMethodParameters(final MethodBinding binding)", "diff": ["-\t\t\t// take into account the synthetic argument names", "-\t\t\tint modifier = (! declaringClass.isPrivate()) || declaringClass.isAnonymousType() ? ClassFileConstants.AccMandated : ClassFileConstants.AccSynthetic;", "+\t\t\t// Take into account the synthetic argument names", "+\t\t\t// This tracks JLS8, paragraph 8.8.9", "+\t\t\tboolean anonymousWithLocalSuper = declaringClass.isAnonymousType() && declaringClass.superclass().isLocalType();", "+\t\t\tboolean anonymousWithNestedSuper = declaringClass.isAnonymousType() && declaringClass.superclass().isNestedType();", "+\t\t\tboolean isImplicitlyDeclared = ((! declaringClass.isPrivate()) || declaringClass.isAnonymousType()) && !anonymousWithLocalSuper;", "+\t\t\t\t\t// This behaviour tracks JLS 15.9.5.1", "+\t\t\t\t\t// This covers that the parameter ending up in a nested class must be mandated \"on the way in\", even if it", "+\t\t\t\t\t// isn't the first. The practical relevance of this is questionable, since the constructor call will be", "+\t\t\t\t\t// generated by the same constructor.", "+\t\t\t\t\tboolean couldForwardToMandated = anonymousWithNestedSuper ? declaringClass.superclass().enclosingType().equals(syntheticArgumentTypes[i]) : true;", "+\t\t\t\t\tint modifier = couldForwardToMandated && isImplicitlyDeclared ? ClassFileConstants.AccMandated : ClassFileConstants.AccSynthetic;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b0ce8262eb910160627dff7d7872faf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "6b97e0e0385eaee70dad3a39c532ecba2f431f7d", "commitAfterChange": "b2f247d693fb1c4457e39814eacc8edd600c0ad7", "methodNumberBeforeChange": 86, "methodNumberAfterChange": 86, "signatureBeforeChange": " \tprotected synchronized void putInfos(IJavaElement openedElement, Map newElements)", "signatureAfterChange": " \tprotected synchronized void putInfos(IJavaElement openedElement, Map newElements)", "diff": ["-\t\tIterator iterator = newElements.keySet().iterator();", "+\t\t// Need to put any JarPackageFragmentRoot in first.", "+\t\t// This is due to the way the LRU cache flushes entries.", "+\t\t// When a JarPackageFragment is flused from the LRU cache, the entire", "+\t\t// jar is flushed by removing the JarPackageFragmentRoot and all of its", "+\t\t// children (see ElementCache.close()). If we flush the JarPackageFragment ", "+\t\t// when its JarPackageFragmentRoot is not in the cache and the root is about to be ", "+\t\t// added (during the 'while' loop), we will end up in an inconsist state. ", "+\t\t// Subsequent resolution against package in the jar would fail as a result.", "+\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=102422", "+\t\t// (theodora)", "+\t\tfor(Iterator it = newElements.entrySet().iterator(); it.hasNext(); ) {", "+\t\t\tMap.Entry entry = (Map.Entry)it.next();", "+\t\t\tIJavaElement element = (IJavaElement)entry.getKey();", "+\t\t\tif( element instanceof JarPackageFragmentRoot ){", "+\t\t\t\tObject info = entry.getValue();", "+\t\t\t\tit.remove();", "+\t\t\t\tthis.cache.putInfo(element, info);", "+\t\t\t}", "+\t\t}\t", "+\t", "+\t\tIterator iterator = newElements.keySet().iterator();\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f1fa8d1d9e5600d142e7fd0ce03dd08", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "0ae44cb94fd5970ee99a6625f01c4e21cfef9943", "commitAfterChange": "7d0759aa475ed30414afbcf0da4d76dd1b16cba1", "methodNumberBeforeChange": 48, "methodNumberAfterChange": 46, "signatureBeforeChange": "\r \tpublic static void setOptions(Hashtable newOptions)", "signatureAfterChange": "\r \tpublic static void setOptions(Hashtable newOptions)", "diff": ["+\t */\r", "+\tpublic static void setOptions(Hashtable newOptions) {\r", "+\t\t\r", "+\t\t// see #initializeDefaultPluginPreferences() for changing default settings\r", "+\t\tPreferences preferences = getPlugin().getPluginPreferences();\r", "+\r", "+\t\tif (newOptions == null){\r", "+\t\t\tnewOptions = JavaCore.getDefaultOptions();\r", "+\t\t}\r", "+\t\tEnumeration keys = newOptions.keys();\r", "+\t\twhile (keys.hasMoreElements()){\r", "+\t\t\tString key = (String)keys.nextElement();\r", "+\t\t\tif (key.equals(CompilerOptions.OPTION_Encoding)) continue; // skipped, contributed by resource prefs\r", "+\t\t\tString value = (String)newOptions.get(key);\r", "+\t\t\tpreferences.setValue(key, value);\r", "+\t\t}\r", "+\t}\r", "-\t */\r", "-\tpublic static void setOptions(Hashtable newOptions) {\r", "-\t\tif (newOptions == null){\r", "-\t\t\tJavaModelManager.Options = getDefaultOptions();\r", "-\t\t} else {\r", "-\t\t\tJavaModelManager.Options = (Hashtable)newOptions.clone();\r", "-\t\t}\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b497538b6f33a65d0a4f263ec4883fdc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.tests/src/org/eclipse/jdt/apt/tests/annotations/aptrounding/Round1GenAnnotationProcessor.java", "commitBeforeChange": "7064f5cf4e1b20562054db6ff22e27e2bfde4008", "commitAfterChange": "c020688b25edf08bbc7d8d68981663ad78d2a9d8", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic void process()", "signatureAfterChange": " \t \tpublic void process()", "diff": ["+\t\t", "+\t\tfinal Collection<TypeDeclaration> typeDecls = _env.getTypeDeclarations();", "+\t\tfinal Messager msger = _env.getMessager();", "+\t\tif( typeDecls.size() == 1 ){", "+\t\t\tfinal TypeDeclaration type = typeDecls.iterator().next();", "+\t\t\tif( !type.getQualifiedName().equals( \"p1.X\") )", "+\t\t\t\tmsger.printError(\"Expected to find p1.X but got \" + type.getQualifiedName() ); ", "+\t\t}", "+\t\telse", "+\t\t\tmsger.printError(\"expected one type declaration but got \" + typeDecls );\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c2b16cbcb225f1c8c00eb9a22efbe6ff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessingState.java", "commitBeforeChange": "fbfdac6d7ce3e57d87b2a41c24ca19b307df27cb", "commitAfterChange": "1f2bb3880562da32cc48ce4bb6e920301c0ee336", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  \tpublic void saveExternalLibTimeStamps() throws CoreException", "signatureAfterChange": "  \tpublic void saveExternalLibTimeStamps() throws CoreException", "diff": ["+\t\t", "+\t\t// cleanup to avoid any leak ( https://bugs.eclipse.org/bugs/show_bug.cgi?id=244849 )", "+\t\tHashSet toRemove = new HashSet();", "+\t\tif (this.roots != null) {", "+\t\t\tEnumeration keys = this.externalTimeStamps.keys();", "+\t\t\twhile (keys.hasMoreElements()) {", "+\t\t\t\tObject key = keys.nextElement();", "+\t\t\t\tif (this.roots.get(key) == null) {", "+\t\t\t\t\ttoRemove.add(key);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t", "-\t\t\tout.writeInt(this.externalTimeStamps.size());", "+\t\t\tout.writeInt(this.externalTimeStamps.size() - toRemove.size());", "-\t\t\t\tout.writeUTF(key.toPortableString());", "-\t\t\t\tLong timestamp = (Long) entry.getValue();", "-\t\t\t\tout.writeLong(timestamp.longValue());", "+\t\t\t\tif (!toRemove.contains(key)) {", "+\t\t\t\t\tout.writeUTF(key.toPortableString());", "+\t\t\t\t\tLong timestamp = (Long) entry.getValue();", "+\t\t\t\t\tout.writeLong(timestamp.longValue());", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cbeb29dcb7a66be42bde870b5a70ed28", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java", "commitBeforeChange": "189e4902a8cd4c72cdcb57f23d61ddb627236e43", "commitAfterChange": "02009b41ec945f5cfcf629234ac75cbc76ce6809", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": " protected void resolveDuplicates(SourceRefElement handle)", "signatureAfterChange": " protected void resolveDuplicates(SourceRefElement handle)", "diff": ["+", "+\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=342393", "+\t// For anonymous source types, the occurrence count should be in the context", "+\t// of the enclosing type.", "+\tif (handle instanceof SourceType && handle.getElementName().length() == 0) {", "+\t\tObject key = handle.getParent().getAncestor(IJavaElement.TYPE);", "+\t\toccurenceCount = this.localOccurrenceCounts.get(key);", "+\t\tif (occurenceCount == -1)", "+\t\t\tthis.localOccurrenceCounts.put(key, 1);", "+\t\telse {", "+\t\t\tthis.localOccurrenceCounts.put(key, ++occurenceCount);", "+\t\t\t((SourceType)handle).localOccurrenceCount = occurenceCount;", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e46b276bf82174aa8bdc7e42d3713db5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "fe01542fcd3aa3aadeb3ef9dbecdc34ba5993c8d", "commitAfterChange": "e89bfd441ddc86e7db4459ee29b0092f7959a77e", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": " protected void reportMatching(AbstractMethodDeclaration method, TypeDeclaration type, IJavaElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException", "signatureAfterChange": " protected void reportMatching(AbstractMethodDeclaration method, TypeDeclaration type, IJavaElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException", "diff": ["-\t\t\t\t\t// standard reporting", "-\t\t\t\t\tif (this.patternFineGrain == 0) {", "-\t\t\t\t\t\tfor (int i = 0, l = nodes.length; i < l; i++) {", "-\t\t\t\t\t\t\tASTNode node = nodes[i];", "-\t\t\t\t\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(node);", "-\t\t\t\t\t\t\tthis.patternLocator.matchReportReference(node, enclosingElement, method.binding, method.scope, level.intValue(), this);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn;", "+\t\t\t\t\tfor (int i = 0, l = nodes.length; i < l; i++) {", "+\t\t\t\t\t\tASTNode node = nodes[i];", "+\t\t\t\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(node);", "+\t\t\t\t\t\tthis.patternLocator.matchReportReference(node, enclosingElement, method.binding, method.scope, level.intValue(), this);", "-\t\t\t\t\t// finegrain reporting", "-\t\t\t\t\tFineGrainVisitor visitor = new FineGrainVisitor(enclosingElement, method.binding, nodeSet, nodes, this.patternLocator, this);", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tClassScope classScope = method.scope == null ? null : method.scope.classScope();", "-\t\t\t\t\t\tmethod.traverse(visitor, classScope);", "-\t\t\t\t\t} catch (WrappedCoreException e) {", "-\t\t\t\t\t\tthrow e.coreException;", "-\t\t\t\t\t}", "+\t\t\t\t\treturn;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fec882b9bc93f62a44f30be2bda70f48", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "f18746495477338a9b83fca4f673d973bc3b28e9", "commitAfterChange": "b7c75d5af8ed9aa46f28be9d8bc08449dc25dc4e", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic boolean deleteGeneratedFile(IFile generatedFile, IFile parentFile, IProgressMonitor progressMonitor ) \t\tthrows CoreException", "signatureAfterChange": " \tpublic boolean deleteGeneratedFile(IFile generatedFile, IFile parentFile, IProgressMonitor progressMonitor ) \t\tthrows CoreException", "diff": ["-\t\tif ( delete )", "+\t\tif ( delete ){", "+\t\t\tfinal IFolder genFolder = getGeneratedSourceFolder();", "+\t\t\tIContainer parent = generatedFile.getParent();", "+\t\t\twhile( !genFolder.equals(parent) && parent != null ){", "+\t\t\t\tfinal IResource[] members = parent.members();", "+\t\t\t\tIContainer grandParent = parent.getParent();", "+\t\t\t\t// last one turns the light off.", "+\t\t\t\tif( members == null || members.length == 0 )", "+\t\t\t\t\tparent.delete(true, progressMonitor);", "+\t\t\t\telse", "+\t\t\t\t\tbreak;", "+\t\t\t\tparent = grandParent;", "+\t\t\t}", "+\t\t}"]}], "num": 62383}