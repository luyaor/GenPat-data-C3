{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ea7799f00b7d1d2542fe23e8cf396c5e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2eb640df1b61047abe235ab7ff28856b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "9fa4ee2d52d7a35a0c57f8c4b875f0f155754f75", "commitAfterChange": "330462fa1b1e3cc7e6b257e0a0f3470535bf4f54", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments, \t\t\t\t\t\t\t\t\tint depth, \t\t\t\t\t\t\t\t\tboolean mustResolve, \t\t\t\t\t\t\t\t\tTypeBinding type)", "signatureAfterChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments, \t\t\t\t\t\t\t\t\tint depth, \t\t\t\t\t\t\t\t\tTypeBinding type)", "diff": ["-\t\t\t\t\t\t\t\t\tboolean mustResolve,", "-\tif (type == null || patternTypeArguments == null|| patternTypeArguments.length == 0) return level;", "+\tif (type == null || patternTypeArguments == null|| patternTypeArguments.length == 0 || depth>=patternTypeArguments.length || patternTypeArguments[depth] == null) return level;", "+\t", "+\t// if pattern is erasure match (see bug 79790), commute impossible to erasure", "+\tint impossible = this.isErasureMatch ? ERASURE_MATCH : IMPOSSIBLE_MATCH;", "-\t\t\tif (mustResolve)", "+\t\t\tif (this.mustResolve)", "+\t\t\t\tboolean patternTypeArgHasAnyChars = CharOperation.contains(new char[] {'*', '?'}, patternTypeArgument);", "-\t\t\t\t\t\t\t// We cannot know in this case...", "-\t\t\t\t\t\t\tlevel = INACCURATE_MATCH;", "+\t\t\t\t\t\t\t// Invalid if type argument is not exact", "+\t\t\t\t\t\t\tif (patternTypeArgHasAnyChars) return impossible;", "-\t\t\t\t\t// Look for bound name in hierarchy", "+\t\t\t\t\t// Look if bound name match pattern type argument", "+\t\t\t\t\tif (CharOperation.match(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\tCharOperation.match(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\t// found name in hierarchy => match", "+\t\t\t\t\t\tcontinue nextTypeArgument;", "+\t\t\t\t\t}", "+", "+\t\t\t\t\t// If pattern is not exact then match fails", "+\t\t\t\t\tif (patternTypeArgHasAnyChars) return impossible;", "+\t\t\t\t\t\t", "+\t\t\t\t\t// Look for bound name in type argument superclasses", "+\t\t\t\t\tboundBinding = boundBinding.superclass();", "-\t\t\t\t\t\tif (CharOperation.match(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\t\tCharOperation.match(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\tif (CharOperation.equals(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\t\tCharOperation.equals(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\t\treturn impossible;", "+", "+\t\t\t\t// If pattern is not exact then match fails", "+\t\t\t\tif (patternTypeArgHasAnyChars) return impossible;", "-\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\treturn impossible;", "-\t\t\tif (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeArguments, depth+1, mustResolve, enclosingType) == IMPOSSIBLE_MATCH) {", "-\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t}", "+\t\t\tint enclosingLevel = resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeArguments, depth+1, enclosingType);", "+\t\t\tif (enclosingLevel == impossible) return impossible;", "+\t\t\tif (enclosingLevel == IMPOSSIBLE_MATCH) return IMPOSSIBLE_MATCH;", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8d7cdd0995ebf930e5ff114a38501550", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 27, "signatureBeforeChange": " public TypeReference getTypeReference(int dim)", "signatureAfterChange": " public TypeReference getTypeReference(int dim)", "diff": ["-\tint length;", "-\tif ((length = identifierLengthStack[identifierLengthPtr--]) == 1) {", "-\t\t// single variable reference", "+\tint length = identifierLengthStack[identifierLengthPtr--];", "+\tif (length < 0) { //flag for precompiled type reference on base types", "+\t\tTypeReference ref = TypeReference.baseTypeReference(-length, dim);", "+\t\tref.sourceStart = intStack[intPtr--];", "-\t\t\tSingleTypeReference ref = ", "-\t\t\t\tnew SingleTypeReference(", "-\t\t\t\t\tidentifierStack[identifierPtr], ", "-\t\t\t\t\tidentifierPositionStack[identifierPtr--]);", "-\t\t\tif (reportReferenceInfo) {", "-\t\t\t\trequestor.acceptTypeReference(ref.token, ref.sourceStart);", "-\t\t\t}", "-\t\t\treturn ref;", "+\t\t\tref.sourceEnd = intStack[intPtr--];", "-\t\t\tArrayTypeReference ref = ", "-\t\t\t\tnew ArrayTypeReference(", "-\t\t\t\t\tidentifierStack[identifierPtr], ", "-\t\t\t\t\tdim, ", "-\t\t\t\t\tidentifierPositionStack[identifierPtr--]); ", "+\t\t\tintPtr--; // no need to use this position as it is an array", "-\t\t\tif (reportReferenceInfo) {", "-\t\t\t\trequestor.acceptTypeReference(ref.token, ref.sourceStart);", "-\t\t\t}", "-\t\t\treturn ref;", "+\t\tif (reportReferenceInfo){", "+\t\t\t\trequestor.acceptTypeReference(ref.getParameterizedTypeName(), ref.sourceStart, ref.sourceEnd);", "+\t\t}", "+\t\treturn ref;", "-\t\tif (length < 0) { //flag for precompiled type reference on base types", "-\t\t\tTypeReference ref = TypeReference.baseTypeReference(-length, dim);", "-\t\t\tref.sourceStart = intStack[intPtr--];", "-\t\t\tif (dim == 0) {", "-\t\t\t\tref.sourceEnd = intStack[intPtr--];", "-\t\t\t} else {", "-\t\t\t\tintPtr--; // no need to use this position as it is an array", "-\t\t\t\tref.sourceEnd = endPosition;", "-\t\t\t}", "-\t\t\tif (reportReferenceInfo){", "-\t\t\t\t\trequestor.acceptTypeReference(ref.getTypeName(), ref.sourceStart, ref.sourceEnd);", "+\t\tint numberOfIdentifiers = this.genericsIdentifiersLengthStack[this.genericsIdentifiersLengthPtr--];", "+\t\tif (length != numberOfIdentifiers || this.genericsLengthStack[this.genericsLengthPtr] != 0) {", "+\t\t\t// generic type", "+\t\t\tTypeReference ref = getTypeReferenceForGenericType(dim, length, numberOfIdentifiers);", "+\t\t\tif (reportReferenceInfo) {", "+\t\t\t\tif (length == 1 && numberOfIdentifiers == 1) {", "+\t\t\t\t\tParameterizedSingleTypeReference parameterizedSingleTypeReference = (ParameterizedSingleTypeReference) ref;", "+\t\t\t\t\trequestor.acceptTypeReference(parameterizedSingleTypeReference.token, parameterizedSingleTypeReference.sourceStart);", "+\t\t\t\t} else {", "+\t\t\t\t\tParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference = (ParameterizedQualifiedTypeReference) ref;", "+\t\t\t\t\trequestor.acceptTypeReference(parameterizedQualifiedTypeReference.tokens, parameterizedQualifiedTypeReference.sourceStart, parameterizedQualifiedTypeReference.sourceEnd);", "+\t\t\t\t}", "-\t\t} else { //Qualified variable reference", "+\t\t} else if (length == 1) {", "+\t\t\t// single variable reference", "+\t\t\tthis.genericsLengthPtr--; // pop the 0", "+\t\t\tif (dim == 0) {", "+\t\t\t\tSingleTypeReference ref = ", "+\t\t\t\t\tnew SingleTypeReference(", "+\t\t\t\t\t\tidentifierStack[identifierPtr], ", "+\t\t\t\t\t\tidentifierPositionStack[identifierPtr--]);", "+\t\t\t\tif (reportReferenceInfo) {", "+\t\t\t\t\trequestor.acceptTypeReference(ref.token, ref.sourceStart);", "+\t\t\t\t}", "+\t\t\t\treturn ref;", "+\t\t\t} else {", "+\t\t\t\tArrayTypeReference ref = ", "+\t\t\t\t\tnew ArrayTypeReference(", "+\t\t\t\t\t\tidentifierStack[identifierPtr], ", "+\t\t\t\t\t\tdim, ", "+\t\t\t\t\t\tidentifierPositionStack[identifierPtr--]); ", "+\t\t\t\tref.sourceEnd = endPosition;", "+\t\t\t\tif (reportReferenceInfo) {", "+\t\t\t\t\trequestor.acceptTypeReference(ref.token, ref.sourceStart);", "+\t\t\t\t}", "+\t\t\t\treturn ref;", "+\t\t\t}", "+\t\t} else {//Qualified variable reference", "+\t\t\tthis.genericsLengthPtr--;"]}], "num": 16214}