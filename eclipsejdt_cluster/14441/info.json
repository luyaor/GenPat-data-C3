{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6ba47af8f79e0846245bfee9d0f7265c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0dc4974575c865a15d469c00cdf42284", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " public int literalIndexForNameAndType(char[] name, char[] signature)", "signatureAfterChange": " public int literalIndexForNameAndType(char[] name, char[] signature)", "diff": ["-\tint index;", "-\tif ((index = putInNameAndTypeCacheIfAbsent(name, signature, currentIndex)) < 0) {", "-\t\t// The entry doesn't exit yet", "-\t\tcurrentIndex++;", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\twriteU1(NameAndTypeTag);", "-\t\tint nameIndexOffset = this.currentOffset;", "-\t\tif (currentOffset + 4 >= poolContent.length) {", "-\t\t\tresizePoolContents(4);", "-\t\t}", "-\t\tcurrentOffset+=4;", "-\t\t", "-\t\tfinal int nameIndex = literalIndex(name);", "-\t\tfinal int typeIndex = literalIndex(signature);", "-\t\tpoolContent[nameIndexOffset++] = (byte) (nameIndex >> 8);", "-\t\tpoolContent[nameIndexOffset++] = (byte) nameIndex;", "-\t\tpoolContent[nameIndexOffset++] = (byte) (typeIndex >> 8);", "-\t\tpoolContent[nameIndexOffset] = (byte) typeIndex;", "-\t}", "-\treturn index;", "+    int index;", "+    if ((index = putInNameAndTypeCacheIfAbsent(name, signature, currentIndex)) < 0) {", "+        // The entry doesn't exit yet", "+        currentIndex++;", "+        if ((index = -index) > 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(NameAndTypeTag);", "+        int nameIndexOffset = this.currentOffset;", "+        if (currentOffset + 4 >= poolContent.length) {", "+            resizePoolContents(4);", "+        }", "+        currentOffset+=4;", "+", "+        final int nameIndex = literalIndex(name);", "+        final int typeIndex = literalIndex(signature);", "+        poolContent[nameIndexOffset++] = (byte) (nameIndex >> 8);", "+        poolContent[nameIndexOffset++] = (byte) nameIndex;", "+        poolContent[nameIndexOffset++] = (byte) (typeIndex >> 8);", "+        poolContent[nameIndexOffset] = (byte) typeIndex;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16b15ca1f60eef1f32b5f3ce461302f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " public int literalIndexForType(final char[] constantPoolName)", "signatureAfterChange": " public int literalIndexForType(final char[] constantPoolName)", "diff": ["-\tint index;", "-\tif ((index = classCache.putIfAbsent(constantPoolName, this.currentIndex)) < 0) {", "-\t\t// The entry doesn't exit yet", "-\t\tthis.currentIndex++;", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\twriteU1(ClassTag);", "+    int index;", "+    if ((index = classCache.putIfAbsent(constantPoolName, this.currentIndex)) < 0) {", "+        // The entry doesn't exit yet", "+        this.currentIndex++;", "+        if ((index = -index) > 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+       this.offsets[index] = this.currentOffset;", "+        writeU1(ClassTag);", "-\t\t// Then the name index", "-\t\tint nameIndexOffset = this.currentOffset;", "-\t\tif (currentOffset + 2 >= poolContent.length) {", "-\t\t\tresizePoolContents(2);", "-\t\t}", "-\t\tcurrentOffset+=2;", "-\t\tfinal int nameIndex = literalIndex(constantPoolName);", "-\t\tpoolContent[nameIndexOffset++] = (byte) (nameIndex >> 8);", "-\t\tpoolContent[nameIndexOffset] = (byte) nameIndex;", "-\t}", "-\treturn index;", "+        // Then the name index", "+        int nameIndexOffset = this.currentOffset;", "+        if (currentOffset + 2 >= poolContent.length) {", "+            resizePoolContents(2);", "+        }", "+        currentOffset+=2;", "+        final int nameIndex = literalIndex(constantPoolName);", "+        poolContent[nameIndexOffset++] = (byte) (nameIndex >> 8);", "+        poolContent[nameIndexOffset] = (byte) nameIndex;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4892f6a4e0cac17826b63f99699c74d1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public int literalIndex(char[] stringCharArray, byte[] utf8encoding)", "signatureAfterChange": " public int literalIndex(char[] stringCharArray, byte[] utf8encoding)", "diff": ["-\tint index;", "-\tif ((index = stringCache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "-\t\t// The entry doesn't exit yet", "-\t\tthis.currentIndex++;", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\t// Write the tag first", "-\t\twriteU1(StringTag);", "-\t\t// Then the string index", "-\t\tint stringIndexOffset = this.currentOffset;", "-\t\tif (currentOffset + 2 >= poolContent.length) {", "-\t\t\tresizePoolContents(2);", "-\t\t}", "-\t\tcurrentOffset+=2;", "+    int index;", "+    if ((index = stringCache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "+        // The entry doesn't exit yet", "+        this.currentIndex++;", "+        if ((index = -index) > 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        // Write the tag first", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(StringTag);", "+        // Then the string index", "+        int stringIndexOffset = this.currentOffset;", "+        if (currentOffset + 2 >= poolContent.length) {", "+            resizePoolContents(2);", "+        }", "+        currentOffset+=2;", "-\t\tfinal int stringIndex = literalIndex(utf8encoding, stringCharArray);", "-\t\tpoolContent[stringIndexOffset++] = (byte) (stringIndex >> 8);", "-\t\tpoolContent[stringIndexOffset] = (byte) stringIndex;", "-\t}", "-\treturn index;", "+        final int stringIndex = literalIndex(utf8encoding, stringCharArray);", "+        poolContent[stringIndexOffset++] = (byte) (stringIndex >> 8);", "+        poolContent[stringIndexOffset] = (byte) stringIndex;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "61f0fb12f57d4f71afad71e0f541790a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public int literalIndex(byte[] utf8encoding, char[] stringCharArray)", "signatureAfterChange": " public int literalIndex(byte[] utf8encoding, char[] stringCharArray)", "diff": ["-\tint index;", "-\tif ((index = UTF8Cache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "-\t\t// The entry doesn't exit yet", "-\t\tif ((index = -index)> 0xFFFF) {", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\tcurrentIndex++;", "-\t\t// Write the tag first", "-\t\twriteU1(Utf8Tag);", "-\t\tint utf8encodingLength = utf8encoding.length;", "-\t\tif (currentOffset + 2 + utf8encodingLength >= poolContent.length) {", "-\t\t\t// we need to resize the poolContent array because we won't have", "-\t\t\t// enough space to write the length", "-\t\t\tresizePoolContents(2 + utf8encodingLength);", "-\t\t}", "-\t\tpoolContent[currentOffset++] = (byte) (utf8encodingLength >> 8);", "-\t\tpoolContent[currentOffset++] = (byte) utf8encodingLength;", "-\t\t// add in once the whole byte array", "-\t\tSystem.arraycopy(utf8encoding, 0, poolContent, currentOffset, utf8encodingLength);", "-\t\tcurrentOffset += utf8encodingLength;", "-\t}", "-\treturn index;", "+    int index;", "+    if ((index = UTF8Cache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "+        // The entry doesn't exit yet", "+        if ((index = -index)> 0xFFFF) {", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        currentIndex++;", "+        // Write the tag first", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(Utf8Tag);", "+        int utf8encodingLength = utf8encoding.length;", "+        if (currentOffset + 2 + utf8encodingLength >= poolContent.length) {", "+            // we need to resize the poolContent array because we won't have", "+            // enough space to write the length", "+            resizePoolContents(2 + utf8encodingLength);", "+        }", "+        poolContent[currentOffset++] = (byte) (utf8encodingLength >> 8);", "+        poolContent[currentOffset++] = (byte) utf8encodingLength;", "+        // add in once the whole byte array", "+        System.arraycopy(utf8encoding, 0, poolContent, currentOffset, utf8encodingLength);", "+        currentOffset += utf8encodingLength;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64897ef31da6feedd7dedc8c828cfcf6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " public int literalIndex(float key)", "signatureAfterChange": " public int literalIndex(float key)", "diff": ["-\t//Retrieve the index from the cache", "-\tint index;", "-\t// lazy initialization for base type caches", "-\t// If it is null, initialize it, otherwise use it", "-\tif (floatCache == null) {", "-\t\tfloatCache = new FloatCache(FLOAT_INITIAL_SIZE);", "-\t}", "-\tif ((index = floatCache.putIfAbsent(key, this.currentIndex)) < 0) {", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\tthis.currentIndex++;", "-\t\t// Write the float constant entry into the constant pool", "-\t\t// First add the tag", "-\t\twriteU1(FloatTag);", "-\t\t// Then add the 4 bytes representing the float", "-\t\tint temp = java.lang.Float.floatToIntBits(key);", "-\t\tif (currentOffset + 4 >= poolContent.length) {", "-\t\t\tresizePoolContents(4);", "-\t\t}", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 24);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 16);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 8);", "-\t\tpoolContent[currentOffset++] = (byte) temp;", "-\t}", "-\treturn index;", "+    //Retrieve the index from the cache", "+    int index;", "+    // lazy initialization for base type caches", "+    // If it is null, initialize it, otherwise use it", "+    if (floatCache == null) {", "+        floatCache = new FloatCache(FLOAT_INITIAL_SIZE);", "+    }", "+    if ((index = floatCache.putIfAbsent(key, this.currentIndex)) < 0) {", "+        if ((index = -index) > 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        this.currentIndex++;", "+        // Write the float constant entry into the constant pool", "+        // First add the tag", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(FloatTag);", "+        // Then add the 4 bytes representing the float", "+        int temp = java.lang.Float.floatToIntBits(key);", "+        if (currentOffset + 4 >= poolContent.length) {", "+            resizePoolContents(4);", "+        }", "+        poolContent[currentOffset++] = (byte) (temp >>> 24);", "+        poolContent[currentOffset++] = (byte) (temp >>> 16);", "+        poolContent[currentOffset++] = (byte) (temp >>> 8);", "+        poolContent[currentOffset++] = (byte) temp;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7960befa4d144005684661850fcbaa50", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " public int literalIndexForField(char[] declaringClass, char[] name, char[] signature)", "signatureAfterChange": " public int literalIndexForField(char[] declaringClass, char[] name, char[] signature)", "diff": ["-\tint index;", "-\tif ((index = putInCacheIfAbsent(declaringClass, name, signature, this.currentIndex)) < 0) {", "-\t\tthis.currentIndex++;", "-\t\t// doesn't exist yet", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\t// Write the interface method ref constant into the constant pool", "-\t\t// First add the tag", "-\t\twriteU1(FieldRefTag);", "-\t\tint classIndexOffset = this.currentOffset;", "-\t\tif (currentOffset + 4 >= poolContent.length) {", "-\t\t\tresizePoolContents(4);", "-\t\t}", "-\t\tcurrentOffset+=4;", "-\t\t", "-\t\tfinal int classIndex = literalIndexForType(declaringClass);", "-\t\tfinal int nameAndTypeIndex = literalIndexForNameAndType(name, signature);", "+    int index;", "+    if ((index = putInCacheIfAbsent(declaringClass, name, signature, this.currentIndex)) < 0) {", "+        this.currentIndex++;", "+        // doesn't exist yet", "+        if ((index = -index) > 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        // Write the interface method ref constant into the constant pool", "+        // First add the tag", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(FieldRefTag);", "+        int classIndexOffset = this.currentOffset;", "+        if (currentOffset + 4 >= poolContent.length) {", "+            resizePoolContents(4);", "+        }", "+        currentOffset+=4;", "-\t\tpoolContent[classIndexOffset++] = (byte) (classIndex >> 8);", "-\t\tpoolContent[classIndexOffset++] = (byte) classIndex;", "-\t\tpoolContent[classIndexOffset++] = (byte) (nameAndTypeIndex >> 8);", "-\t\tpoolContent[classIndexOffset] = (byte) nameAndTypeIndex;\t\t", "-\t}", "-\treturn index;", "+        final int classIndex = literalIndexForType(declaringClass);", "+        final int nameAndTypeIndex = literalIndexForNameAndType(name, signature);", "+", "+        poolContent[classIndexOffset++] = (byte) (classIndex >> 8);", "+        poolContent[classIndexOffset++] = (byte) classIndex;", "+        poolContent[classIndexOffset++] = (byte) (nameAndTypeIndex >> 8);", "+        poolContent[classIndexOffset] = (byte) nameAndTypeIndex;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8de0a8d53b30ea5a0d5b9f850f6634a0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java", "commitBeforeChange": "f2fb5e44531d4df5da9264367df0b14b50434c61", "commitAfterChange": "a3da1013b6fe549ad5c2ee5b7dc726eba38ff59e", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "     public ReferenceBinding[] superInterfaces()", "signatureAfterChange": "     public ReferenceBinding[] superInterfaces()", "diff": ["+        \tif (this.typeVariable() != null) {", "+        \t\tthis.superInterfaces = this.typeVariable.superInterfaces();", "+        \t} else {", "+        \t\tthis.superInterfaces = NoSuperInterfaces;", "+        \t}", "-\t\t\t\tif (this.bound.isInterface())", "-\t\t\t\t\treturn new ReferenceBinding[] {(ReferenceBinding) this.bound};", "-\t\t\t\treturn NoSuperInterfaces;", "-\t\t\t} else if (this.typeVariable() != null) {", "-\t\t\t\treturn this.typeVariable.superInterfaces();", "+\t\t\t\tif (this.bound.isInterface()) {", "+\t\t\t\t\t// augment super interfaces with the wildcard bound", "+\t\t\t\t\tint length = this.superInterfaces.length;", "+\t\t\t\t\tSystem.arraycopy(this.superInterfaces, 0, this.superInterfaces = new ReferenceBinding[length+1], 1, length);", "+\t\t\t\t\tthis.superInterfaces[0] = (ReferenceBinding) this.bound; // make bound first", "+\t\t\t\t}", "-\t\t\t// TODO (philippe) if we fall thru, we'll answer null but no one will expect it", "-\t\t\t// return NoSuperInterfaces;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa0528757cb81869f7b7c07ba82a4845", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "644c4d9043a8634631a6c37637807f9484dbb1d4", "commitAfterChange": "fff3d1bb7cd12822df70202db7e6a801aeeb63a2", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic void createInitialConstraintsForParameters(TypeBinding[] parameters, boolean checkVararg, TypeBinding varArgsType, MethodBinding method)", "signatureAfterChange": " \tpublic void createInitialConstraintsForParameters(TypeBinding[] parameters, boolean checkVararg, TypeBinding varArgsType, MethodBinding method)", "diff": ["+\t\tboolean ownConstraints;", "+\t\t\townConstraints = true;", "+\t\t\townConstraints = false; // these are lifted from a nested poly expression.", "+\t\tif (ownConstraints) { // lifted constraints get validated at their own context.", "+\t\t\tfinal int length = this.initialConstraints.length;", "+\t\t\tSystem.arraycopy(this.initialConstraints, 0, this.finalConstraints = new ConstraintExpressionFormula[length], 0, length);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b1236aa46a46d9ba9e0dc3d46cb5f4de", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " public int literalIndex(String stringConstant)", "signatureAfterChange": " public int literalIndex(String stringConstant)", "diff": ["-\tint index;", "-\tchar[] stringCharArray = stringConstant.toCharArray();", "-\tif ((index = stringCache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "-\t\t// The entry doesn't exit yet", "-\t\tcurrentIndex++;", "-\t\tif ((index  = -index)> 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\t// Write the tag first", "-\t\twriteU1(StringTag);", "-\t\t// Then the string index", "-\t\tint stringIndexOffset = this.currentOffset;", "-\t\tif (currentOffset + 2 >= poolContent.length) {", "-\t\t\tresizePoolContents(2);", "-\t\t}", "-\t\tcurrentOffset+=2;", "-\t\tfinal int stringIndex = literalIndex(stringCharArray);", "-\t\tpoolContent[stringIndexOffset++] = (byte) (stringIndex >> 8);", "-\t\tpoolContent[stringIndexOffset] = (byte) stringIndex;", "-\t}", "-\treturn index;", "+    int index;", "+    char[] stringCharArray = stringConstant.toCharArray();", "+    if ((index = stringCache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "+        // The entry doesn't exit yet", "+        currentIndex++;", "+        if ((index  = -index)> 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        // Write the tag first", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(StringTag);", "+        // Then the string index", "+        int stringIndexOffset = this.currentOffset;", "+        if (currentOffset + 2 >= poolContent.length) {", "+            resizePoolContents(2);", "+        }", "+        currentOffset+=2;", "+        final int stringIndex = literalIndex(stringCharArray);", "+        poolContent[stringIndexOffset++] = (byte) (stringIndex >> 8);", "+        poolContent[stringIndexOffset] = (byte) stringIndex;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c5d2d3eba0876d8f258af8b6bbc39e74", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " public int literalIndex(int key)", "signatureAfterChange": " public int literalIndex(int key)", "diff": ["-\t//Retrieve the index from the cache", "-\tint index;", "-\t// lazy initialization for base type caches", "-\t// If it is null, initialize it, otherwise use it", "-\tif (intCache == null) {", "-\t\tintCache = new IntegerCache(INT_INITIAL_SIZE);", "-\t}", "-\tif ((index = intCache.putIfAbsent(key, this.currentIndex)) < 0) {", "-\t\tthis.currentIndex++;", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t// Write the integer constant entry into the constant pool", "-\t\t// First add the tag", "-\t\twriteU1(IntegerTag);", "-\t\t// Then add the 4 bytes representing the int", "-\t\tif (currentOffset + 4 >= poolContent.length) {", "-\t\t\tresizePoolContents(4);", "-\t\t}", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 24);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 16);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 8);", "-\t\tpoolContent[currentOffset++] = (byte) key;", "-\t}", "-\treturn index;", "+    //Retrieve the index from the cache", "+    int index;", "+    // lazy initialization for base type caches", "+    // If it is null, initialize it, otherwise use it", "+    if (intCache == null) {", "+        intCache = new IntegerCache(INT_INITIAL_SIZE);", "+    }", "+    if ((index = intCache.putIfAbsent(key, this.currentIndex)) < 0) {", "+        this.currentIndex++;", "+        if ((index = -index) > 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+ \t   // Write the integer constant entry into the constant pool", "+        // First add the tag", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(IntegerTag);", "+        // Then add the 4 bytes representing the int", "+        if (currentOffset + 4 >= poolContent.length) {", "+            resizePoolContents(4);", "+        }", "+        poolContent[currentOffset++] = (byte) (key >>> 24);", "+        poolContent[currentOffset++] = (byte) (key >>> 16);", "+        poolContent[currentOffset++] = (byte) (key >>> 8);", "+        poolContent[currentOffset++] = (byte) key;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c693239070c516d537c2a220d783a790", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ReferenceCollection.java", "commitBeforeChange": "c4112ab397da10b85cbb2a3f081c4c91ed7c7975", "commitAfterChange": "2077df1da6fa132fd5beb7d042b102e760cf8cbf", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public void addDependencies(String[] typeNameDependencies)", "signatureAfterChange": "  public void addDependencies(String[] typeNameDependencies)", "diff": ["+\t\t\t}", "+\t\t\tif (!insideRoot(qualifiedTypeName[0])) {", "+\t\t\t\tint length = this.rootReferences.length;", "+\t\t\t\tSystem.arraycopy(this.rootReferences, 0, this.rootReferences = new char[length + 1][], 0, length);", "+\t\t\t\tthis.rootReferences[length] = qualifiedTypeName[0];"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ccc83290466479606adbc29a9d165891", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " public int literalIndex(long key)", "signatureAfterChange": " public int literalIndex(long key)", "diff": ["-\t// Retrieve the index from the cache", "-\t// The long constant takes two indexes into the constant pool, but we only store", "-\t// the first index into the long table", "-\tint index;", "-\t// lazy initialization for base type caches", "-\t// If it is null, initialize it, otherwise use it", "-\tif (longCache == null) {", "-\t\tlongCache = new LongCache(LONG_INITIAL_SIZE);", "-\t}", "-\tif ((index = longCache.putIfAbsent(key, this.currentIndex)) < 0) {", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\tthis.currentIndex+= 2; // long value need an extra place into thwe constant pool", "-\t\t// Write the long into the constant pool", "-\t\t// First add the tag", "-\t\twriteU1(LongTag);", "-\t\t// Then add the 8 bytes representing the long", "-\t\tif (currentOffset + 8 >= poolContent.length) {", "-\t\t\tresizePoolContents(8);", "-\t\t}", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 56);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 48);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 40);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 32);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 24);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 16);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 8);", "-\t\tpoolContent[currentOffset++] = (byte) key;", "-\t}", "-\treturn index;", "+    // Retrieve the index from the cache", "+    // The long constant takes two indexes into the constant pool, but we only store", "+    // the first index into the long table", "+    int index;", "+    // lazy initialization for base type caches", "+    // If it is null, initialize it, otherwise use it", "+    if (longCache == null) {", "+        longCache = new LongCache(LONG_INITIAL_SIZE);", "+    }", "+    if ((index = longCache.putIfAbsent(key, this.currentIndex)) < 0) {", "+        if ((index = -index) > 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        this.currentIndex+= 2; // long value need an extra place into thwe constant pool", "+        // Write the long into the constant pool", "+        // First add the tag", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(LongTag);", "+        // Then add the 8 bytes representing the long", "+        if (currentOffset + 8 >= poolContent.length) {", "+            resizePoolContents(8);", "+        }", "+        poolContent[currentOffset++] = (byte) (key >>> 56);", "+        poolContent[currentOffset++] = (byte) (key >>> 48);", "+        poolContent[currentOffset++] = (byte) (key >>> 40);", "+        poolContent[currentOffset++] = (byte) (key >>> 32);", "+        poolContent[currentOffset++] = (byte) (key >>> 24);", "+        poolContent[currentOffset++] = (byte) (key >>> 16);", "+        poolContent[currentOffset++] = (byte) (key >>> 8);", "+        poolContent[currentOffset++] = (byte) key;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cec23661d67d5dfc3fdc706903ce828a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public int literalIndex(double key)", "signatureAfterChange": " public int literalIndex(double key)", "diff": ["-\t//Retrieve the index from the cache", "-\t// The double constant takes two indexes into the constant pool, but we only store", "-\t// the first index into the long table", "-\tint index;", "-\t// lazy initialization for base type caches", "-\t// If it is null, initialize it, otherwise use it", "-\tif (doubleCache == null) {", "-\t\t\tdoubleCache = new DoubleCache(DOUBLE_INITIAL_SIZE);", "-\t}", "-\tif ((index = doubleCache.putIfAbsent(key, this.currentIndex)) < 0) {", "-\t\tif ((index = -index)> 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\tthis.currentIndex += 2; // a double needs an extra place into the constant pool", "-\t\t// Write the double into the constant pool", "-\t\t// First add the tag", "-\t\twriteU1(DoubleTag);", "-\t\t// Then add the 8 bytes representing the double", "-\t\tlong temp = java.lang.Double.doubleToLongBits(key);", "-\t\tint length = poolContent.length;", "-\t\tif (currentOffset + 8 >= length) {", "-\t\t\tresizePoolContents(8);", "-\t\t}", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 56);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 48);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 40);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 32);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 24);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 16);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 8);", "-\t\tpoolContent[currentOffset++] = (byte) temp;", "-\t}", "-\treturn index;", "+    //Retrieve the index from the cache", "+    // The double constant takes two indexes into the constant pool, but we only store", "+    // the first index into the long table", "+    int index;", "+    // lazy initialization for base type caches", "+    // If it is null, initialize it, otherwise use it", "+    if (doubleCache == null) {", "+            doubleCache = new DoubleCache(DOUBLE_INITIAL_SIZE);", "+    }", "+    if ((index = doubleCache.putIfAbsent(key, this.currentIndex)) < 0) {", "+        if ((index = -index)> 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        this.currentIndex += 2; // a double needs an extra place into the constant pool", "+        // Write the double into the constant pool", "+        // First add the tag", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(DoubleTag);", "+        // Then add the 8 bytes representing the double", "+        long temp = java.lang.Double.doubleToLongBits(key);", "+        length = poolContent.length;", "+        if (currentOffset + 8 >= length) {", "+            resizePoolContents(8);", "+        }", "+        poolContent[currentOffset++] = (byte) (temp >>> 56);", "+        poolContent[currentOffset++] = (byte) (temp >>> 48);", "+        poolContent[currentOffset++] = (byte) (temp >>> 40);", "+        poolContent[currentOffset++] = (byte) (temp >>> 32);", "+        poolContent[currentOffset++] = (byte) (temp >>> 24);", "+        poolContent[currentOffset++] = (byte) (temp >>> 16);", "+        poolContent[currentOffset++] = (byte) (temp >>> 8);", "+        poolContent[currentOffset++] = (byte) temp;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e4002d1fde220fb03f456923c3ae1e91", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " public int literalIndexForMethod(char[] declaringClass, char[] selector, char[] signature, boolean isInterface)", "signatureAfterChange": " public int literalIndexForMethod(char[] declaringClass, char[] selector, char[] signature, boolean isInterface)", "diff": ["-\tint index;", "-\tif ((index = putInCacheIfAbsent(declaringClass, selector, signature, this.currentIndex)) < 0) {", "-\t\t// it doesn't exist yet", "-\t\tthis.currentIndex++;", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\t// Write the interface method ref constant into the constant pool", "-\t\t// First add the tag", "-\t\twriteU1(isInterface ? InterfaceMethodRefTag : MethodRefTag);", "+    int index;", "+    if ((index = putInCacheIfAbsent(declaringClass, selector, signature, this.currentIndex)) < 0) {", "+        // it doesn't exist yet", "+        this.currentIndex++;", "+        if ((index = -index) > 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        // Write the interface method ref constant into the constant pool", "+        // First add the tag", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(isInterface ? InterfaceMethodRefTag : MethodRefTag);", "-\t\tint classIndexOffset = this.currentOffset;", "-\t\tif (currentOffset + 4 >= poolContent.length) {", "-\t\t\tresizePoolContents(4);", "-\t\t}", "-\t\tcurrentOffset+=4;", "-\t\t", "-\t\tfinal int classIndex = literalIndexForType(declaringClass);", "-\t\tfinal int nameAndTypeIndex = literalIndexForNameAndType(selector, signature);", "+        int classIndexOffset = this.currentOffset;", "+        if (currentOffset + 4 >= poolContent.length) {", "+            resizePoolContents(4);", "+        }", "+        currentOffset+=4;", "-\t\tpoolContent[classIndexOffset++] = (byte) (classIndex >> 8);", "-\t\tpoolContent[classIndexOffset++] = (byte) classIndex;", "-\t\tpoolContent[classIndexOffset++] = (byte) (nameAndTypeIndex >> 8);", "-\t\tpoolContent[classIndexOffset] = (byte) nameAndTypeIndex;", "-\t}", "-\treturn index;", "+        final int classIndex = literalIndexForType(declaringClass);", "+        final int nameAndTypeIndex = literalIndexForNameAndType(selector, signature);", "+", "+        poolContent[classIndexOffset++] = (byte) (classIndex >> 8);", "+        poolContent[classIndexOffset++] = (byte) classIndex;", "+        poolContent[classIndexOffset++] = (byte) (nameAndTypeIndex >> 8);", "+        poolContent[classIndexOffset] = (byte) nameAndTypeIndex;", "+    }", "+    return index;"]}], "num": 14441}