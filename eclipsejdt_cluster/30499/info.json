{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "576bbdb5cd0aaf0e4c57c367aad739d0", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "198701e1df0468499f6cb1d8df158433", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "a8ae4c61c3fd8e7af5944aa40683b300c7cbf9e8", "commitAfterChange": "06d5ad0c6e4971f283c2f47bfc7f9df941ae34e8", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic BoundSet inferInvocationType(BoundSet b1, TypeBinding expectedType, InvocationSite invocationSite, MethodBinding method) \t\t\tthrows InferenceFailureException", "signatureAfterChange": " \tpublic BoundSet inferInvocationType(BoundSet b1, TypeBinding expectedType, InvocationSite invocationSite, MethodBinding method) \t\t\tthrows InferenceFailureException", "diff": ["-\t\t\tSet c = new HashSet();", "+\t\t\tSet<ConstraintFormula> c = new HashSet<ConstraintFormula>();", "-\t\t\t\tSet bottomSet = findBottomSet(c, allOutputVariables(c));", "+\t\t\t\tSet<ConstraintFormula> bottomSet = findBottomSet(c, allOutputVariables(c));", "-\t\t\t\tSet allInputs = new HashSet();", "-\t\t\t\tIterator bottomIt = bottomSet.iterator();", "+\t\t\t\tSet<InferenceVariable> allInputs = new HashSet<InferenceVariable>();", "+\t\t\t\tIterator<ConstraintFormula> bottomIt = bottomSet.iterator();", "-\t\t\t\t\tallInputs.addAll(((ConstraintFormula)bottomIt.next()).inputVariables(this));", "+\t\t\t\t\tallInputs.addAll(bottomIt.next().inputVariables(this));", "-\t\t\t\tInferenceVariable[] variablesArray = (InferenceVariable[]) allInputs.toArray(new InferenceVariable[allInputs.size()]);", "+\t\t\t\tInferenceVariable[] variablesArray = allInputs.toArray(new InferenceVariable[allInputs.size()]);", "-\t\t\t\t\tConstraintFormula constraint = ((ConstraintFormula)bottomIt.next());", "+\t\t\t\t\tConstraintFormula constraint = bottomIt.next();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34a00c39319a769368a4988075485eff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "3fa398907bc325a632b9517a054fc223461325fb", "commitAfterChange": "4e3d522e86b4dbde916017a602e046903b89c502", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " \tprivate Set<InferenceVariable> getSmallestVariableSet(BoundSet bounds, InferenceVariable[] subSet)", "signatureAfterChange": " \tprivate Set<InferenceVariable> getSmallestVariableSet(BoundSet bounds, InferenceVariable[] subSet)", "diff": ["+\t\t// \"Given a set of inference variables to resolve, let V be the union of this set and", "+\t\t//  all variables upon which the resolution of at least one variable in this set depends.\" ", "+\t\tSet<InferenceVariable> v = new HashSet<InferenceVariable>();", "+\t\tMap<InferenceVariable,Set<InferenceVariable>> dependencies = new HashMap<>(); // compute only once, store for the final loop over 'v'.", "+\t\tfor (InferenceVariable iv : subSet) {", "+\t\t\tSet<InferenceVariable> tmp = new HashSet<>();", "+\t\t\taddDependencies(bounds, tmp, iv);", "+\t\t\tdependencies.put(iv, tmp);", "+\t\t\tv.addAll(tmp);", "+\t\t}", "+\t\t// \"If every variable in V has an instantiation, then resolution succeeds and this procedure terminates.\"", "+\t\t//  -> (implicit if result remains unassigned)", "+\t\t// \"Otherwise, let { \u03b11, ..., \u03b1n } be a non-empty subset of uninstantiated variables in V such that ...", "-\t\tfor (int i = 0; i < subSet.length; i++) {", "-\t\t\tInferenceVariable currentVariable = subSet[i];", "+\t\t// \"i) for all i (1 \u2264 i \u2264 n), ...\"", "+\t\tfor (InferenceVariable currentVariable : v) {", "-\t\t\t\tSet<InferenceVariable> set = new HashSet<InferenceVariable>();", "-\t\t\t\tif (!addDependencies(bounds, set, currentVariable, min))", "-\t\t\t\t\tcontinue;", "+\t\t\t\t// \"... if \u03b1i depends on the resolution of a variable \u03b2, then either \u03b2 has an instantiation or there is some j such that \u03b2 = \u03b1j; ...\"", "+\t\t\t\tSet<InferenceVariable> set = dependencies.get(currentVariable);", "+\t\t\t\tif (set == null) // not an element of the original subSet, still need to fetch this var's dependencies", "+\t\t\t\t\taddDependencies(bounds, set = new HashSet<>(), currentVariable);", "+\t\t\t\t//  \"... and ii) there exists no non-empty proper subset of { \u03b11, ..., \u03b1n } with this property.\""]}], "num": 30499}